uint64_t BOMCFArrayMaxRange(const __CFArray *a1)
{
  CFArrayGetCount(a1);
  return 0LL;
}

CFStringRef BOMCFStringGetUTF8String(CFStringRef theString)
{
  v1 = theString;
  uint64_t v11 = *MEMORY[0x1895F89C0];
  if (theString)
  {
    CStringPtr = CFStringGetCStringPtr(theString, 0x8000100u);
    if (!CStringPtr || (v3 = (char *)CStringPtr, !*CStringPtr))
    {
      if (!CFStringGetCString(v1, buffer, 1024LL, 0x8000100u)) {
        return 0LL;
      }
      size_t v8 = strlen(buffer) + 1;
      v5 = (__CFString *)BOM_malloc(v8);
      if (!v5) {
        return 0LL;
      }
      v1 = v5;
      v6 = buffer;
      size_t v7 = v8;
      goto LABEL_9;
    }

    size_t v4 = strlen(CStringPtr) + 1;
    v5 = (__CFString *)BOM_malloc(v4);
    v1 = v5;
    if (v5)
    {
      v6 = v3;
      size_t v7 = v4;
LABEL_9:
      memmove(v5, v6, v7);
    }
  }

  return v1;
}

CFPropertyListRef BOMCFPropertyListReadFromPath(uint64_t a1, CFOptionFlags a2)
{
  return BOMCFPropertyListReadFromPathWithSys(a1, a2, 0LL);
}

CFPropertyListRef BOMCFPropertyListReadFromPathWithSys( uint64_t a1, CFOptionFlags a2, unsigned int (**a3)(void, uint64_t, uint64_t *))
{
  if (!a1) {
    return 0LL;
  }
  v3 = a3;
  if (!a3) {
    v3 = (unsigned int (**)(void, uint64_t, uint64_t *))BomSys_default();
  }
  if (v3[10](v3[1], a1, &v16)) {
    return 0LL;
  }
  CFIndex v6 = v17;
  size_t v7 = BOM_malloc(v17);
  if (!v7) {
    return 0LL;
  }
  size_t v8 = v7;
  uint64_t v9 = ((uint64_t (*)(unsigned int (*)(void, uint64_t, uint64_t *), uint64_t, void, void))v3[2])( v3[1],  a1,  0LL,  0LL);
  if ((_DWORD)v9 == -1
    || (uint64_t v10 = v9,
        uint64_t v11 = ((uint64_t (*)(unsigned int (*)(void, uint64_t, uint64_t *), uint64_t, void *, CFIndex))v3[6])( v3[1],  v9,  v8,  v6),  ((void (*)(unsigned int (*)(void, uint64_t, uint64_t *), uint64_t))v3[4])(v3[1], v10),  v11 != v6)
    || (v12 = CFDataCreateWithBytesNoCopy(0LL, (const UInt8 *)v8, v6, (CFAllocatorRef)*MEMORY[0x189604DB8])) == 0LL)
  {
    free(v8);
    return 0LL;
  }

  v13 = v12;
  CFPropertyListRef v14 = CFPropertyListCreateWithData((CFAllocatorRef)*MEMORY[0x189604DB0], v12, a2, 0LL, 0LL);
  CFRelease(v13);
  return v14;
}

BOOL BOMCFPropertyListWriteToPath(const void *a1, uint64_t a2)
{
  return BOMCFPropertyListWriteToPathWithSys(a1, a2, 0LL);
}

BOOL BOMCFPropertyListWriteToPathWithSys( CFPropertyListRef propertyList, uint64_t a2, uint64_t (**a3)(void, uint64_t, uint64_t, uint64_t))
{
  BOOL v3 = 1LL;
  if (propertyList)
  {
    if (a2)
    {
      CFDataRef Data = CFPropertyListCreateData( (CFAllocatorRef)*MEMORY[0x189604DB0],  propertyList,  kCFPropertyListXMLFormat_v1_0,  0LL,  0LL);
      if (Data)
      {
        size_t v7 = Data;
        if (!a3) {
          a3 = (uint64_t (**)(void, uint64_t, uint64_t, uint64_t))BomSys_default();
        }
        uint64_t v8 = a3[2](a3[1], a2, 513LL, 420LL);
        if ((_DWORD)v8 != -1)
        {
          uint64_t v9 = v8;
          CFIndex Length = CFDataGetLength(v7);
          uint64_t v11 = (uint64_t (*)(void, uint64_t, const UInt8 *, CFIndex))a3[7];
          v12 = a3[1];
          BytePtr = CFDataGetBytePtr(v7);
          BOOL v3 = v11(v12, v9, BytePtr, Length) != Length;
          ((void (*)(uint64_t (*)(void, uint64_t, uint64_t, uint64_t), uint64_t))a3[4])(a3[1], v9);
        }

        CFRelease(v7);
      }
    }
  }

  return v3;
}

CFBooleanRef BOMCFGetBoolValue(const __CFBoolean *result)
{
  if (result)
  {
    v1 = result;
    CFTypeID v2 = CFGetTypeID(result);
    if (v2 == CFBooleanGetTypeID())
    {
      return (const __CFBoolean *)CFBooleanGetValue(v1);
    }

    else
    {
      CFTypeID v3 = CFGetTypeID(v1);
      if (v3 == CFNumberGetTypeID())
      {
        CFNumberGetValue(v1, kCFNumberIntType, &valuePtr);
        return (const __CFBoolean *)(valuePtr != 0);
      }

      else
      {
        CFTypeID v4 = CFGetTypeID(v1);
        if (v4 == CFStringGetTypeID())
        {
          UTF8String = (const char *)BOMCFStringGetUTF8String((CFStringRef)v1);
          CFIndex v6 = (char *)UTF8String;
          do
          {
            char v7 = __tolower(*v6);
            *v6++ = v7;
          }

          while (v7);
          return (const __CFBoolean *)(strcmp(UTF8String, "yes") == 0);
        }

        else
        {
          return 0LL;
        }
      }
    }
  }

  return result;
}

uint64_t BOMCFGetIntValue(const void *a1)
{
  if (!a1) {
    return 0xFFFFFFFFLL;
  }
  CFTypeID TypeID = CFNumberGetTypeID();
  if (TypeID != CFGetTypeID(a1)) {
    return 0xFFFFFFFFLL;
  }
  if (CFNumberGetValue((CFNumberRef)a1, kCFNumberSInt32Type, &valuePtr)) {
    return valuePtr;
  }
  return 0xFFFFFFFFLL;
}

void *BOM_malloc(size_t a1)
{
  v1 = malloc(a1);
  if (!v1)
  {
    CFTypeID v2 = __error();
    CFTypeID v3 = strerror(*v2);
    CFTypeID v4 = BOMExceptionHandlerMessage("malloc: %s\n", v3);
    v5 = __error();
    _BOMExceptionHandlerCall( (uint64_t)v4,  1,  "/Library/Caches/com.apple.xbs/Sources/Bom/Common/BOMSystemCmds.c",  27,  *v5);
  }

  return v1;
}

void *BOM_malloczero(size_t __size)
{
  CFTypeID v2 = calloc(1uLL, __size);
  CFTypeID v3 = v2;
  if (v2)
  {
    bzero(v2, __size);
  }

  else
  {
    CFTypeID v4 = __error();
    v5 = strerror(*v4);
    CFIndex v6 = BOMExceptionHandlerMessage("calloc: %s\n", v5);
    char v7 = __error();
    _BOMExceptionHandlerCall( (uint64_t)v6,  1,  "/Library/Caches/com.apple.xbs/Sources/Bom/Common/BOMSystemCmds.c",  38,  *v7);
  }

  return v3;
}

void *BOM_calloc(size_t a1, size_t a2)
{
  CFTypeID v2 = calloc(a1, a2);
  if (!v2)
  {
    CFTypeID v3 = __error();
    CFTypeID v4 = strerror(*v3);
    v5 = BOMExceptionHandlerMessage("calloc: %s\n", v4);
    CFIndex v6 = __error();
    _BOMExceptionHandlerCall( (uint64_t)v5,  1,  "/Library/Caches/com.apple.xbs/Sources/Bom/Common/BOMSystemCmds.c",  52,  *v6);
  }

  return v2;
}

void *BOM_realloc(void *a1, size_t a2)
{
  CFTypeID v2 = reallocf(a1, a2);
  if (!v2)
  {
    CFTypeID v3 = __error();
    CFTypeID v4 = strerror(*v3);
    v5 = BOMExceptionHandlerMessage("reallocf: %s\n", v4);
    CFIndex v6 = __error();
    _BOMExceptionHandlerCall( (uint64_t)v5,  1,  "/Library/Caches/com.apple.xbs/Sources/Bom/Common/BOMSystemCmds.c",  66,  *v6);
  }

  return v2;
}

char *BOM_realloczero(void *a1, unint64_t a2, size_t __size)
{
  v5 = (char *)reallocf(a1, __size);
  CFIndex v6 = v5;
  if (v5)
  {
    if (__size > a2) {
      bzero(&v5[a2], __size - a2);
    }
  }

  else
  {
    char v7 = __error();
    uint64_t v8 = strerror(*v7);
    uint64_t v9 = BOMExceptionHandlerMessage("reallocf: %s\n", v8);
    uint64_t v10 = __error();
    _BOMExceptionHandlerCall( (uint64_t)v9,  1,  "/Library/Caches/com.apple.xbs/Sources/Bom/Common/BOMSystemCmds.c",  80,  *v10);
  }

  return v6;
}

uint64_t BOM_strrncmp(const char *a1, const char *a2, size_t a3)
{
  size_t v6 = strlen(a1);
  size_t v7 = strlen(a2);
  if (v6 >= v7) {
    size_t v8 = v7;
  }
  else {
    size_t v8 = v6;
  }
  if (v8 >= a3) {
    size_t v9 = a3;
  }
  else {
    size_t v9 = v8;
  }
  return strncmp(&a1[v6 - v8], &a2[v7 - v8], v9);
}

uint64_t pkzip_crypto_init(int *a1, char *__s)
{
  CFTypeID v2 = __s;
  *(void *)a1 = 0x2345678912345678LL;
  a1[2] = 878082192;
  uint64_t result = strlen(__s);
  if (result)
  {
    uint64_t v5 = result;
    do
    {
      unsigned int v6 = *v2++;
      uint64_t result = pkzip_crypto_update(a1, v6);
      --v5;
    }

    while (v5);
  }

  return result;
}

uint64_t pkzip_crypto_update(int *a1, uint64_t a2)
{
  int v2 = PKZip_crctab[(*a1 ^ a2)] ^ (*a1 >> 8);
  unsigned int v3 = 134775813 * (a1[1] + v2) + 1;
  *a1 = v2;
  a1[1] = v3;
  a1[2] = PKZip_crctab[a1[2] ^ HIBYTE(v3)] ^ (a1[2] >> 8);
  return a2;
}

uint64_t pkzip_crypto_decrypt_buffer(int *a1, unsigned __int8 *a2, uint64_t a3)
{
  if (a3)
  {
    uint64_t v3 = a3;
    do
    {
      int v6 = *a2;
      unsigned int v7 = (a1[2] & 0xFFFD ^ 3) * (a1[2] | 2);
      int v8 = v6 ^ (v7 >> 8);
      pkzip_crypto_update(a1, (char)(v6 ^ BYTE1(v7)));
      *a2++ = v8;
      --v3;
    }

    while (v3);
  }

  return 0LL;
}

void **BOMStackNew()
{
  v0 = (void **)BOM_calloc(1uLL, 0x18uLL);
  v1 = v0;
  if (v0)
  {
    v0[1] = (void *)1024;
    int v2 = BOM_malloczero(0x2000uLL);
    void *v1 = v2;
    if (!v2)
    {
      BOMStackFree(v1);
      return 0LL;
    }
  }

  return v1;
}

void BOMStackFree(void **a1)
{
  if (a1)
  {
    int v2 = *a1;
    if (v2) {
      free(v2);
    }
    free(a1);
  }
}

uint64_t *BOMStackPop(uint64_t *result)
{
  if (result)
  {
    uint64_t v1 = *result;
    if (*result && (uint64_t v2 = result[2]) != 0)
    {
      uint64_t v3 = v2 - 1;
      result[2] = v3;
      uint64_t result = *(uint64_t **)(v1 + 8 * v3);
      *(void *)(v1 + 8 * v3) = 0LL;
    }

    else
    {
      return 0LL;
    }
  }

  return result;
}

void *BOMStackPeek(void *result)
{
  if (result)
  {
    if (*result && (uint64_t v1 = result[2]) != 0) {
      return *(void **)(*result + 8 * v1 - 8);
    }
    else {
      return 0LL;
    }
  }

  return result;
}

void *BOMStackPoke(void *result, uint64_t a2)
{
  if (result && *result)
  {
    uint64_t v2 = result[2];
    if (v2) {
      *(void *)(*result + 8 * v2 - 8) = a2;
    }
  }

  return result;
}

char *BOMStackPush(char *result, uint64_t a2)
{
  if (result)
  {
    uint64_t v2 = result;
    uint64_t result = *(char **)result;
    if (result)
    {
      unint64_t v5 = v2[1];
      uint64_t v4 = v2[2];
      uint64_t v6 = v4 + 1;
      if (v4 + 1 < v5)
      {
LABEL_9:
        v2[2] = v6;
        *(void *)&result[8 * v4] = a2;
        return result;
      }

      if (v5 != 0xFFFFFFF)
      {
        uint64_t v7 = 2 * v5;
        if (2 * v5 >= 0xFFFFFFF) {
          uint64_t v7 = 0xFFFFFFFLL;
        }
        v2[1] = v7;
        uint64_t result = BOM_realloczero(result, 8 * v5, 8 * v7);
        *uint64_t v2 = result;
        if (result)
        {
          uint64_t v4 = v2[2];
          uint64_t v6 = v4 + 1;
          goto LABEL_9;
        }
      }
    }
  }

  return result;
}

BOOL BOMStackIsEmpty(uint64_t a1)
{
  return !a1 || !*(void *)a1 || *(_DWORD *)(a1 + 16) < 1;
}

uint64_t BOMStackCount(uint64_t result)
{
  if (result)
  {
    if (*(void *)result) {
      return *(unsigned int *)(result + 16);
    }
    else {
      return 0LL;
    }
  }

  return result;
}

void *darc_format_entry_new(uint64_t a1, uint64_t a2)
{
  if (a2) {
    return 0LL;
  }
  uint64_t result = platform_calloc(a1, 1uLL, 0x48uLL);
  if (result)
  {
    *(_DWORD *)uint64_t result = 1853125241;
    result[1] = a1;
    *((_DWORD *)result + 16) = 2037544037;
  }

  return result;
}

void darc_format_entry_free(void *__b)
{
  if (__b && *(_DWORD *)__b == 1853125241 && *((_DWORD *)__b + 16) == 2037544037)
  {
    uint64_t v2 = (char *)__b[5];
    if (v2)
    {
      if (*((_DWORD *)__b + 8))
      {
        uint64_t v3 = 0LL;
        unint64_t v4 = 0LL;
        do
        {
          if (*(void *)&v2[v3])
          {
            platform_free(__b[1], *(void **)&v2[v3]);
            uint64_t v2 = (char *)__b[5];
            *(void *)&v2[v3] = 0LL;
          }

          *(void *)&v2[v3 + 8] = 0LL;
          if (*(void *)&v2[v3 + 16])
          {
            platform_free(__b[1], *(void **)&v2[v3 + 16]);
            uint64_t v2 = (char *)__b[5];
            *(void *)&v2[v3 + 16] = 0LL;
          }

          *(void *)&v2[v3 + 24] = 0LL;
          ++v4;
          v3 += 32LL;
        }

        while (v4 < *((unsigned int *)__b + 8));
      }

      platform_free(__b[1], v2);
    }

    uint64_t v5 = __b[1];
    platform_memset(v5, __b, 0LL, 0x48uLL);
    platform_free(v5, __b);
  }

uint64_t darc_format_entry_set_type(_DWORD *a1, int a2)
{
  if (!a1 || *a1 != 1853125241 || a1[16] != 2037544037) {
    return 0xFFFFFFFFLL;
  }
  uint64_t result = 0LL;
  a1[4] = a2;
  return result;
}

_DWORD *darc_format_entry_get_type(_DWORD *result)
{
  if (result)
  {
    if (*result == 1853125241 && result[16] == 2037544037) {
      return (_DWORD *)result[4];
    }
    else {
      return 0LL;
    }
  }

  return result;
}

uint64_t darc_format_entry_set_size(uint64_t a1, uint64_t a2)
{
  if (!a1 || *(_DWORD *)a1 != 1853125241 || *(_DWORD *)(a1 + 64) != 2037544037) {
    return 0xFFFFFFFFLL;
  }
  uint64_t result = 0LL;
  *(void *)(a1 + 24) = a2;
  return result;
}

uint64_t darc_format_entry_set_attribute(uint64_t a1, char *__s, void *a3, size_t a4)
{
  if (!a1) {
    return 0xFFFFFFFFLL;
  }
  if (*(_DWORD *)a1 != 1853125241) {
    return 0xFFFFFFFFLL;
  }
  uint64_t result = 0xFFFFFFFFLL;
  if (__s)
  {
    if (*(_DWORD *)(a1 + 64) == 2037544037)
    {
      size_t v9 = strlen(__s);
      uint64_t result = 0xFFFFFFFFLL;
      if (a4)
      {
        if (a3 && v9)
        {
          unsigned int v10 = *(_DWORD *)(a1 + 32);
          if (v10)
          {
            uint64_t v11 = 0LL;
            uint64_t v12 = 0LL;
            LODWORD(v13) = 0;
            do
            {
              uint64_t v14 = *(void *)(a1 + 40);
              if (v9 == *(void *)(v14 + v11 + 8))
              {
                int v15 = platform_strncmp(*(void *)(a1 + 8), __s, *(char **)(v14 + v11), v9);
                BOOL v16 = v15 == 0;
                if (!v15) {
                  LODWORD(v13) = v12;
                }
                unsigned int v10 = *(_DWORD *)(a1 + 32);
              }

              else
              {
                BOOL v16 = 0;
              }

              v11 += 32LL;
            }

            while (!v16);
            if (v16)
            {
              size_t v17 = *(void **)(*(void *)(a1 + 40) + 32LL * v13 + 16);
              if (v17) {
                platform_free(*(void *)(a1 + 8), v17);
              }
              goto LABEL_24;
            }
          }

          unsigned int v18 = v10 + 1;
          v19 = platform_realloc(*(void *)(a1 + 8), *(void **)(a1 + 40), 32LL * (v10 + 1));
          if (v19)
          {
            uint64_t v13 = *(unsigned int *)(a1 + 32);
            *(_DWORD *)(a1 + 32) = v18;
            *(void *)(a1 + 40) = v19;
            v20 = platform_strdup(*(void *)(a1 + 8), __s);
            if (v20)
            {
              v21 = (char **)(*(void *)(a1 + 40) + 32 * v13);
              *v21 = v20;
              v21[1] = (char *)v9;
LABEL_24:
              v22 = platform_malloc(*(void *)(a1 + 8), a4);
              if (v22)
              {
                v23 = v22;
                platform_memcpy(*(void *)(a1 + 8), v22, a3, a4);
                uint64_t result = 0LL;
                uint64_t v24 = *(void *)(a1 + 40) + 32LL * v13;
                *(void *)(v24 + 16) = v23;
                *(void *)(v24 + 24) = a4;
                return result;
              }

              v27 = (FILE *)*MEMORY[0x1895F89D0];
              v28 = __error();
              strerror(*v28);
              fprintf(v27, "Could not allocate %ld bytes for value: %s\n");
              return 0xFFFFFFFFLL;
            }

            v29 = (FILE *)*MEMORY[0x1895F89D0];
            v30 = __error();
            strerror(*v30);
            fprintf(v29, "Could not duplicate key %s: %s\n");
          }

          else
          {
            v25 = (FILE *)*MEMORY[0x1895F89D0];
            v26 = __error();
            strerror(*v26);
            fprintf(v25, "Could not re-allocate the entry list: %s\n");
          }

          return 0xFFFFFFFFLL;
        }
      }
    }
  }

  return result;
}

uint64_t darc_format_entry_get_attribute(uint64_t a1, char *__s, void *a3)
{
  if (!a1 || *(_DWORD *)a1 != 1853125241) {
    return -1LL;
  }
  uint64_t v5 = -1LL;
  if (__s)
  {
    if (*(_DWORD *)(a1 + 64) == 2037544037)
    {
      uint64_t v7 = platform_strlen(*(void *)(a1 + 8), __s);
      if (v7)
      {
        if (*(_DWORD *)(a1 + 32))
        {
          size_t v8 = v7;
          uint64_t v9 = 0LL;
          unint64_t v10 = 0LL;
          do
          {
            uint64_t v11 = *(void *)(a1 + 40);
            if (v8 == *(void *)(v11 + v9 + 8)
              && !platform_strncmp(*(void *)(a1 + 8), __s, *(char **)(v11 + v9), v8))
            {
              uint64_t v12 = *(void *)(a1 + 40) + v9;
              uint64_t v5 = *(void *)(v12 + 24);
              if (a3) {
                platform_memcpy(*(void *)(a1 + 8), a3, *(void **)(v12 + 16), *(void *)(v12 + 24));
              }
            }

            ++v10;
            v9 += 32LL;
          }

          while (v10 < *(unsigned int *)(a1 + 32));
        }
      }
    }
  }

  return v5;
}

uint64_t darc_format_entry_set_range(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (!a1 || *(_DWORD *)a1 != 1853125241 || *(_DWORD *)(a1 + 64) != 2037544037) {
    return 0xFFFFFFFFLL;
  }
  uint64_t result = 0LL;
  *(void *)(a1 + 48) = a2;
  *(void *)(a1 + 56) = a3;
  return result;
}

CFMutableArrayRef BOMPatternListNew()
{
  return CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x189604DB0], 0LL, 0LL);
}

void BOMPatternListFree(const __CFArray *a1)
{
  if (a1)
  {
    CFTypeID TypeID = CFArrayGetTypeID();
    if (TypeID == CFGetTypeID(a1))
    {
      CFIndex Count = CFArrayGetCount(a1);
      if (Count >= 1)
      {
        CFIndex v4 = Count;
        for (CFIndex i = 0LL; i != v4; ++i)
        {
          ValueAtIndex = (void *)CFArrayGetValueAtIndex(a1, i);
          if (ValueAtIndex)
          {
            uint64_t v7 = ValueAtIndex;
            MEMORY[0x186E383EC]();
            free(v7);
          }
        }
      }

      CFRelease(a1);
    }
  }

void BOMPatternFree(void *a1)
{
  if (a1)
  {
    MEMORY[0x186E383EC]();
    free(a1);
  }

regex_t *BOMPatternCompileString(const char *a1)
{
  uint64_t v2 = (regex_t *)BOM_malloc(0x20uLL);
  uint64_t v3 = v2;
  if (v2 && regcomp(v2, a1, 5))
  {
    CFIndex v4 = BOMExceptionHandlerMessage("**** WARNING **** Can't compile pattern: %s\n", a1);
    uint64_t v5 = __error();
    _BOMExceptionHandlerCall( (uint64_t)v4,  0,  "/Library/Caches/com.apple.xbs/Sources/Bom/Common/BOMPatternList.c",  47,  *v5);
    free(v3);
    return 0LL;
  }

  return v3;
}

BOOL BOMPatternMatch(regex_t *a1, const char *a2)
{
  BOOL result = 0LL;
  if (a1)
  {
    if (a2) {
      return regexec(a1, a2, 0LL, 0LL, 0) == 0;
    }
  }

  return result;
}

uint64_t BOMPatternListMatch(const __CFArray *a1, const char *a2)
{
  uint64_t result = 0LL;
  if (a1 && a2)
  {
    CFTypeID TypeID = CFArrayGetTypeID();
    if (TypeID == CFGetTypeID(a1) && (CFIndex Count = CFArrayGetCount(a1), Count >= 1))
    {
      CFIndex v7 = Count;
      CFIndex v8 = 0LL;
      while (1)
      {
        ValueAtIndex = (const regex_t *)CFArrayGetValueAtIndex(a1, v8);
        if (ValueAtIndex)
        {
          if (!regexec(ValueAtIndex, a2, 0LL, 0LL, 0)) {
            break;
          }
        }

        if (v7 == ++v8) {
          return 0LL;
        }
      }

      return 1LL;
    }

    else
    {
      return 0LL;
    }
  }

  return result;
}

__CFArray *BOMPatternListFromStringList(const void *a1)
{
  if (!a1) {
    return 0LL;
  }
  CFTypeID TypeID = CFArrayGetTypeID();
  if (TypeID != CFGetTypeID(a1)) {
    return 0LL;
  }
  Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x189604DB0], 0LL, 0LL);
  if (Mutable)
  {
    CFIndex Count = CFArrayGetCount((CFArrayRef)a1);
    if (Count >= 1)
    {
      CFIndex v5 = Count;
      for (CFIndex i = 0LL; i != v5; ++i)
      {
        ValueAtIndex = (const char *)CFArrayGetValueAtIndex((CFArrayRef)a1, i);
        if (ValueAtIndex)
        {
          CFIndex v8 = BOMPatternCompileString(ValueAtIndex);
          if (v8) {
            CFArrayAppendValue(Mutable, v8);
          }
        }
      }
    }
  }

  return Mutable;
}

__CFArray *BOMPatternListExtractFromFile(const char *a1)
{
  uint64_t v15 = *MEMORY[0x1895F89C0];
  uint64_t v2 = fopen(a1, "r");
  if (v2)
  {
    uint64_t v3 = v2;
    Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x189604DB0], 0LL, 0LL);
    if (Mutable)
    {
      while (1)
      {
        do
        {
          if (!fgets(__s, 1025, v3)) {
            goto LABEL_11;
          }
          size_t v5 = strlen(__s);
        }

        while (!v5);
        size_t v6 = v5 - 1;
        if (__s[v5 - 1] == 10) {
          break;
        }
LABEL_7:
        size_t v7 = strlen(__s);
        if (v7)
        {
          size_t v6 = v7 - 1;
          if (__s[v7 - 1] == 47) {
            break;
          }
        }

        CFIndex v8 = BOMPatternCompileString(__s);
        if (v8) {
          CFArrayAppendValue(Mutable, v8);
        }
      }

      __s[v6] = 0;
      goto LABEL_7;
    }

LABEL_11:
    fclose(v3);
  }

  else
  {
    uint64_t v9 = __error();
    unint64_t v10 = strerror(*v9);
    uint64_t v11 = BOMExceptionHandlerMessage("can't open %s for reading: %s\n", a1, v10);
    uint64_t v12 = __error();
    _BOMExceptionHandlerCall( (uint64_t)v11,  0,  "/Library/Caches/com.apple.xbs/Sources/Bom/Common/BOMPatternList.c",  130,  *v12);
    return 0LL;
  }

  return Mutable;
}

    __new = 0LL;
    uint64_t v11 = *(char **)(a1 + 344);
    if (v11)
    {
      if (make_path(*(os_log_s **)a1, v11, a3))
      {
        uint64_t v12 = __error();
        strerror(*v12);
        BOMCopierErrorCapture( a3,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  6457,  (uint64_t)"apply_retention_policy",  "Could not make the kept file directory %s: %s");
        return 1LL;
      }

      if (*(_BYTE *)(a1 + 352))
      {
        if (!*(void *)(a1 + 360))
        {
          v20 = calloc(1uLL, 0x400uLL);
          *(void *)(a1 + 360) = v20;
          if (!v20)
          {
            v37 = *__error();
            v38 = __error();
            strerror(*v38);
            BOMCopierErrorCapture( a3,  v37,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  6476,  (uint64_t)"apply_retention_policy",  "Could not allocate kept file subdirectory path: %s");
            return 1LL;
          }
        }

        v21 = *(void *)(a1 + 312);
        if (!v21 || !(v21 % *(unsigned int *)(a1 + 356)))
        {
          uuid_generate_random(out);
          uuid_unparse(out, (char *)buf);
          snprintf( *(char **)(a1 + 360),  0x400uLL,  "%s/%c%c/%c%c/%c%c/%s",  *(const char **)(a1 + 344),  (char)buf[0],  (char)buf[1],  (char)buf[2],  (char)buf[3],  (char)v45,  SBYTE1(v45),  (const char *)buf);
          if (make_path(*(os_log_s **)a1, *(char **)(a1 + 360), a3))
          {
            v22 = __error();
            strerror(*v22);
            BOMCopierErrorCapture( a3,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  6503,  (uint64_t)"apply_retention_policy",  "Could not make the kept file subdirectory %s: %s");
            return 1LL;
          }
        }

        asprintf(&__new, "%s/%lu");
      }

      else
      {
        getpid();
        asprintf(&__new, "%s/%s.dittoKeptBinary.%d.%lu");
      }
    }

    else
    {
      getpid();
      asprintf(&__new, "%s.dittoKeptBinary.%d.%lu");
    }

    uint64_t v15 = __new;
    if (!__new)
    {
      v23 = *__error();
      uint64_t v24 = __error();
      strerror(*v24);
      BOMCopierErrorCapture( a3,  v23,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  6523,  (uint64_t)"apply_retention_policy",  "Could not asprintf kept path: %s\n");
      return 1LL;
    }

    ++*(void *)(a1 + 312);
    BOOL v16 = *(const char **)(a2 + 120);
    size_t v17 = *(os_log_s **)a1;
    if (*(void *)a1)
    {
      if (!os_log_type_enabled(*(os_log_t *)a1, OS_LOG_TYPE_DEFAULT)
        || (*(_DWORD *)buf = 136315138,
            v45 = (void *)v16,
            _os_log_impl(&dword_1862F3000, v17, OS_LOG_TYPE_DEFAULT, "kept old: %s", buf, 0xCu),
            (size_t v17 = *(os_log_s **)a1) != 0LL))
      {
        if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136315138;
          v45 = v15;
          _os_log_impl(&dword_1862F3000, v17, OS_LOG_TYPE_DEFAULT, "kept new: %s", buf, 0xCu);
        }
      }
    }

    if (rename(v16, v15))
    {
      unsigned int v18 = *__error();
      v19 = __error();
      strerror(*v19);
      BOMCopierErrorCapture( a3,  v18,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  6538,  (uint64_t)"apply_retention_policy",  "Could not rename kept %s to %s: %s",  v16);
LABEL_24:
      free(__new);
      return 1LL;
    }

    v25 = *(const char **)(a1 + 320);
    if (v25)
    {
      v26 = *(_DWORD *)(a1 + 328);
      if (v26 == -1)
      {
        v27 = open(v25, 1545, 420LL);
        if (v27 == -1)
        {
          v41 = *__error();
          v42 = __error();
          strerror(*v42);
          BOMCopierErrorCapture( a3,  v41,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  6561,  (uint64_t)"apply_retention_policy",  "Could not open %s: %s");
          goto LABEL_24;
        }

        v26 = v27;
        *(_DWORD *)(a1 + 328) = v27;
      }

      v28 = strlen(__new);
      if (write(v26, __new, v28) != v28)
      {
        v35 = *__error();
        v36 = __error();
        strerror(*v36);
        BOMCopierErrorCapture( a3,  v35,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  6577,  (uint64_t)"apply_retention_policy",  "Could not write to %s: %s");
        goto LABEL_24;
      }

      if (write(v26, "\n", 1uLL) != 1)
      {
        v39 = *__error();
        v40 = __error();
        strerror(*v40);
        BOMCopierErrorCapture( a3,  v39,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  6586,  (uint64_t)"apply_retention_policy",  "Could not write to %s: %s");
        goto LABEL_24;
      }
    }

    free(__new);
  }

  if (v14) {
    BOMTreeFree(v9);
  }
  return v4;
}

      if (CNCRCFinal())
      {
        unint64_t v10 = *__error();
        uint64_t v11 = __error();
        strerror(*v11);
        BOMCopierErrorCapture( a2,  v10,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDataAnalyzer.c",  851,  (uint64_t)"finalize_data_analyzer",  "Could not finalize CRC_32 POSIX context: %s");
        return 1LL;
      }

      *((_DWORD *)a1 + 10) = 0;
      CFIndex v4 = *a1;
    }

    if ((v4 & 8) != 0)
    {
      CC_MD5_Final((unsigned __int8 *)a1[12], (CC_MD5_CTX *)a1[6]);
      CFIndex v4 = *a1;
      if ((*a1 & 0x10) == 0)
      {
LABEL_18:
        if ((v4 & 0x20) == 0) {
          goto LABEL_19;
        }
        goto LABEL_27;
      }
    }

    else if ((v4 & 0x10) == 0)
    {
      goto LABEL_18;
    }

    CC_SHA1_Final((unsigned __int8 *)a1[13], (CC_SHA1_CTX *)a1[7]);
    CFIndex v4 = *a1;
    if ((*a1 & 0x20) == 0)
    {
LABEL_19:
      if ((v4 & 0x40) == 0) {
        goto LABEL_20;
      }
      goto LABEL_28;
    }

__CFArray *BOMPatternListExtractFromStrings(int a1, uint64_t a2)
{
  uint64_t v13 = *MEMORY[0x1895F89C0];
  Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x189604DB0], 0LL, 0LL);
  if (Mutable) {
    BOOL v5 = a1 == 0;
  }
  else {
    BOOL v5 = 1;
  }
  if (!v5)
  {
    uint64_t v6 = 0LL;
    while (1)
    {
      strncpy(__dst, *(const char **)(a2 + 8 * v6), 0x400uLL);
      size_t v7 = strlen(__dst);
      if (v7) {
        break;
      }
LABEL_13:
      if (++v6 == a1) {
        return Mutable;
      }
    }

    size_t v8 = v7 - 1;
    if (__dst[v7 - 1] != 10) {
      goto LABEL_9;
    }
    while (1)
    {
      __dst[v8] = 0;
LABEL_9:
      size_t v9 = strlen(__dst);
      if (v9)
      {
        size_t v8 = v9 - 1;
        if (__dst[v9 - 1] == 47) {
          continue;
        }
      }

      unint64_t v10 = BOMPatternCompileString(__dst);
      if (v10) {
        CFArrayAppendValue(Mutable, v10);
      }
      goto LABEL_13;
    }
  }

  return Mutable;
}

uint64_t BOMFileNewFromFD(void *a1, uint64_t a2, char a3, unsigned __int8 *a4)
{
  return BOMFileNewFromFDWithSys(a1, a2, a3, a4, 0LL);
}

uint64_t BOMFileNewFromFDWithSys( void *a1, uint64_t a2, char a3, unsigned __int8 *a4, void (**a5)(void, uint64_t, uint64_t, uint64_t))
{
  unint64_t v10 = BOM_malloczero(0x118uLL);
  if (!v10) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v11 = v10;
  if (a5)
  {
    if ((a3 & 0x10) == 0) {
      goto LABEL_5;
    }
    goto LABEL_4;
  }

  a5 = (void (**)(void, uint64_t, uint64_t, uint64_t))BomSys_default();
  if ((a3 & 0x10) != 0) {
LABEL_4:
  }
    a5[5](a5[1], a2, 48LL, 1LL);
LABEL_5:
  *uint64_t v11 = *a4 == 119;
  v11[2] = a2;
  if (_BOMFileInit(v11, a3 & 0xF, a5))
  {
LABEL_6:
    uint64_t v12 = v11;
LABEL_7:
    _freeBOMFile(v12);
    return 0xFFFFFFFFLL;
  }

  if ((a3 & 0x20) != 0)
  {
    if (getenv("BOM_ASYNC_DEBUG"))
    {
      gBOMAsyncDebug = 1;
    }

    else if (gBOMAsyncDebug != 1)
    {
LABEL_17:
      uint64_t v14 = BOM_malloczero(0x118uLL);
      if (!v14) {
        goto LABEL_6;
      }
      uint64_t v15 = v14;
      if (*v11 == 1) {
        int v16 = 6;
      }
      else {
        int v16 = 5;
      }
      *(_DWORD *)uint64_t v14 = v16;
      v14[1] = v11;
      if (_BOMFileInit(v14, 0, a5))
      {
        uint64_t v12 = v15;
        goto LABEL_7;
      }

      uint64_t v11 = v15;
      goto LABEL_12;
    }

    fprintf((FILE *)*MEMORY[0x1895F89D0], "async compression enabled for %d\n", a2);
    goto LABEL_17;
  }

LABEL_12:
  uint64_t result = 0LL;
  *a1 = v11;
  return result;
}

  _BOMExceptionHandlerCall((uint64_t)v10, v11, "/Library/Caches/com.apple.xbs/Sources/Bom/Bom/BOMBom.c", v12, v9);
  return 0LL;
}

      ++v9;
    }

    while (v9 < v8);
  }

  else
  {
    unint64_t v10 = 0;
  }

  unsigned int v18 = *(void **)(a1 + 112);
  if (v18) {
    free(v18);
  }
  *(_DWORD *)(a1 + 104) = v10;
  *(void *)(a1 + 112) = v7;
  if (v10 == 1)
  {
    uint64_t result = 0LL;
    *(void *)(a1 + 64) = *((void *)v7 + 1);
    *(_DWORD *)(a1 + 88) = *((_DWORD *)v7 + 4);
    return result;
  }

  return 0LL;
}

    size_t v8 = BOMStreamWithAddress((uint64_t)v16, 0x2AuLL, 0);
    if (!v8) {
      goto LABEL_3;
    }
    size_t v9 = (uint64_t)v8;
    if (BOMStreamSetByteOrder((uint64_t)v8, 2u))
    {
      BOMStreamFree(v9);
      goto LABEL_3;
    }

    BOMStreamReadUInt16(v9);
    BOMStreamReadUInt16(v9);
    BOMStreamReadUInt16(v9);
    BOMStreamReadUInt16(v9);
    BOMStreamReadUInt16(v9);
    BOMStreamReadUInt16(v9);
    UInt32 = BOMStreamReadUInt32(v9);
    uint64_t v11 = BOMStreamReadUInt32(v9);
    uint64_t v12 = BOMStreamReadUInt32(v9);
    BOMStreamReadUInt16(v9);
    BOMStreamReadUInt16(v9);
    BOMStreamReadUInt16(v9);
    BOMStreamReadUInt16(v9);
    BOMStreamReadUInt16(v9);
    BOMStreamReadUInt32(v9);
    BOMStreamReadUInt32(v9);
    BOMStreamFree(v9);
    uint64_t v13 = *(_DWORD *)(a1 + 72);
    uint64_t v14 = (_DWORD *)(*(void *)(a1 + 80) + 12LL * v13);
    *uint64_t v14 = UInt32;
    v14[1] = v11;
    v14[2] = v12;
    *(_DWORD *)(a1 + 72) = v13 + 1;
    BOMFileSeek();
  }

  if (v15 == 6) {
    uint64_t v2 = 0LL;
  }
  else {
    uint64_t v2 = 0xFFFFFFFFLL;
  }
LABEL_4:
  BOMFileSeek();
  return v2;
}

uint64_t _BOMFileInit(_DWORD *a1, int a2, void *a3)
{
  uint64_t v23 = *MEMORY[0x1895F89C0];
  if (!a3) {
    a3 = BomSys_default();
  }
  *((void *)a1 + 34) = a3;
  BOOL v5 = malloc(0x20000uLL);
  *((void *)a1 + 11) = v5;
  if (!v5) {
    return 0xFFFFFFFFLL;
  }
  switch(a2)
  {
    case 8:
      int v6 = 4;
      goto LABEL_10;
    case 2:
      int v6 = 2;
      a1[8] = 2;
      goto LABEL_12;
    case 1:
      int v6 = 1;
LABEL_10:
      a1[8] = v6;
      a1[60] = -1;
      goto LABEL_12;
  }

  int v6 = 0;
  a1[8] = 0;
LABEL_12:
  switch(*a1)
  {
    case 0:
    case 3:
      if (((1 << v6) & 0x16) == 0) {
        goto LABEL_58;
      }
      *(_DWORD *)((char *)&__attr.__sig + 7) = 0;
      __attr.__sig = 0LL;
      size_t Raw = _BOMFileReadRaw((uint64_t)a1, (UInt8 *)&__attr, 11LL);
      if (Raw == -1LL) {
        return 0xFFFFFFFFLL;
      }
      int v8 = a1[8];
      if (v8 == 1)
      {
        if (LOBYTE(__attr.__sig) != 31) {
          goto LABEL_56;
        }
        goto LABEL_47;
      }

      if (v8 == 4 && LOBYTE(__attr.__sig) == 31)
      {
LABEL_47:
        if (BYTE1(__attr.__sig) == 139 && BYTE2(__attr.__sig) == 8)
        {
          int v19 = 1;
          goto LABEL_57;
        }

        goto LABEL_56;
      }

      if ((v8 == 2 || v8 == 4) && LOBYTE(__attr.__sig) == 66 && BYTE1(__attr.__sig) == 90 && BYTE2(__attr.__sig) == 104)
      {
        int v19 = 2;
        goto LABEL_57;
      }

LABEL_56:
      int v19 = 0;
LABEL_57:
      a1[8] = v19;
      *((void *)a1 + 9) = Raw;
      a1[20] = 1;
      memcpy(*((void **)a1 + 11), &__attr, Raw);
      int v6 = a1[8];
LABEL_58:
      if (v6 == 2)
      {
        uint64_t result = _BOMFileSetupBzip2((uint64_t)a1, 0);
      }

      else if (v6 == 1)
      {
        uint64_t result = _BOMFileSetupGzip((uint64_t)a1, 0, 1);
      }

      else
      {
LABEL_61:
        uint64_t result = 0LL;
      }

      break;
    case 1:
    case 2:
      if (v6 == 1) {
        goto LABEL_22;
      }
      if (v6 == 2) {
        return _BOMFileSetupBzip2((uint64_t)a1, 1);
      }
      if (v6 != 4) {
        goto LABEL_61;
      }
      a1[8] = 1;
LABEL_22:
      *(_DWORD *)((char *)&__attr.__sig + 7) = 196608;
      __attr.__sig = 559903LL;
      if (!_BOMFileSetupGzip((uint64_t)a1, 1, 1))
      {
        deflateEnd(*((z_streamp *)a1 + 5));
      }

      return 0xFFFFFFFFLL;
    case 4:
      size_t v9 = BOM_malloczero(8uLL);
      if (!v9) {
        return 0xFFFFFFFFLL;
      }
      unint64_t v10 = v9;
      uint64_t result = 0LL;
      *unint64_t v10 = 0LL;
      *((void *)a1 + 1) = v10;
      return result;
    case 5:
      uint64_t result = pthread_once(&gBufferPoolOnce, (void (*)(void))_initBufferPool);
      if ((_DWORD)result) {
        return result;
      }
      uint64_t v12 = BOMBufferAllocate(gBOMAsyncBufferSize);
      if (!v12) {
        return 0xFFFFFFFFLL;
      }
      BOMBufferPoolAddBuffer(gBufferPool, (uint64_t)v12);
      *((void *)a1 + 12) = BOMBufferFIFOCreate();
      *((void *)a1 + 13) = 0LL;
      *((void *)a1 + 29) = 0LL;
      if (pthread_mutex_init((pthread_mutex_t *)(a1 + 42), 0LL) || pthread_cond_init((pthread_cond_t *)(a1 + 30), 0LL)) {
        return 1LL;
      }
      qos_class_t v13 = qos_class_self();
      int v14 = pthread_attr_init(&__attr);
      if (!v14) {
        int v14 = pthread_attr_set_qos_class_np(&__attr, v13, 0);
      }
      if (v14) {
        p_attr = 0LL;
      }
      else {
        p_attr = &__attr;
      }
      int v16 = (pthread_t *)(a1 + 28);
      size_t v17 = (void *(__cdecl *)(void *))_asyncReadThread;
      return pthread_create(v16, p_attr, v17, a1) != 0;
    case 6:
      uint64_t result = pthread_once(&gBufferPoolOnce, (void (*)(void))_initBufferPool);
      if ((_DWORD)result) {
        return result;
      }
      unsigned int v18 = BOMBufferAllocate(gBOMAsyncBufferSize);
      if (!v18) {
        return 0xFFFFFFFFLL;
      }
      BOMBufferPoolAddBuffer(gBufferPool, (uint64_t)v18);
      *((void *)a1 + 12) = BOMBufferFIFOCreate();
      *((void *)a1 + 13) = 0LL;
      *((void *)a1 + 29) = 0LL;
      if (pthread_mutex_init((pthread_mutex_t *)(a1 + 42), 0LL) || pthread_cond_init((pthread_cond_t *)(a1 + 30), 0LL)) {
        return 1LL;
      }
      qos_class_t v20 = qos_class_self();
      int v21 = pthread_attr_init(&__attr);
      if (!v21) {
        int v21 = pthread_attr_set_qos_class_np(&__attr, v20, 0);
      }
      if (v21) {
        p_attr = 0LL;
      }
      else {
        p_attr = &__attr;
      }
      int v16 = (pthread_t *)(a1 + 28);
      size_t v17 = (void *(__cdecl *)(void *))_asyncWriteThread;
      return pthread_create(v16, p_attr, v17, a1) != 0;
    default:
      return 0xFFFFFFFFLL;
  }

  return result;
}

void _freeBOMFile(void *a1)
{
  if (*(_DWORD *)a1 == 4)
  {
    uint64_t v2 = (void *)a1[1];
    if (v2)
    {
      free(v2);
      a1[1] = 0LL;
    }
  }

  uint64_t v3 = (void *)a1[5];
  if (v3)
  {
    free(v3);
    a1[5] = 0LL;
  }

  CFIndex v4 = (void *)a1[6];
  if (v4)
  {
    free(v4);
    a1[6] = 0LL;
  }

  uint64_t v5 = a1[12];
  if (v5)
  {
    BOMBufferFIFODestroy(v5);
    a1[12] = 0LL;
  }

  int v6 = (void *)a1[11];
  if (v6) {
    free(v6);
  }
  free(a1);
}

uint64_t BOMFileNewFromCFWriteStream(void *a1, const void *a2, char a3)
{
  if (!a2) {
    return 0xFFFFFFFFLL;
  }
  CFTypeID TypeID = CFWriteStreamGetTypeID();
  if (TypeID != CFGetTypeID(a2)) {
    return 0xFFFFFFFFLL;
  }
  size_t v7 = BOM_malloczero(0x118uLL);
  if (!v7) {
    return 0xFFFFFFFFLL;
  }
  int v8 = v7;
  *(_DWORD *)size_t v7 = 2;
  v7[1] = a2;
  uint64_t result = _BOMFileInit(v7, a3 & 0xF, 0LL);
  if ((_DWORD)result)
  {
    _freeBOMFile(v8);
    return 0xFFFFFFFFLL;
  }

  *a1 = v8;
  return result;
}

uint64_t BOMFileNewFromCFReadStream(void *a1, const void *a2, char a3)
{
  if (!a2) {
    return 0xFFFFFFFFLL;
  }
  CFTypeID TypeID = CFReadStreamGetTypeID();
  if (TypeID != CFGetTypeID(a2)) {
    return 0xFFFFFFFFLL;
  }
  size_t v7 = BOM_malloczero(0x118uLL);
  if (!v7) {
    return 0xFFFFFFFFLL;
  }
  int v8 = v7;
  *(_DWORD *)size_t v7 = 3;
  v7[1] = a2;
  uint64_t result = _BOMFileInit(v7, a3 & 0xF, 0LL);
  if ((_DWORD)result)
  {
    _freeBOMFile(v8);
    return 0xFFFFFFFFLL;
  }

  *a1 = v8;
  return result;
}

uint64_t BOMFileNewMirror(void *a1)
{
  return BOMFileNewMirrorWithSys(a1, 0LL);
}

uint64_t BOMFileNewMirrorWithSys(void *a1, void *a2)
{
  CFIndex v4 = BOM_malloczero(0x118uLL);
  if (!v4) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v5 = v4;
  *CFIndex v4 = 4;
  uint64_t result = _BOMFileInit(v4, 0, a2);
  if ((_DWORD)result)
  {
    _freeBOMFile(v5);
    return 0xFFFFFFFFLL;
  }

  *a1 = v5;
  return result;
}

uint64_t BOMFileOpen(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, char a5)
{
  return BOMFileOpenWithSys(a1, a2, a3, a4, a5, 0LL);
}

uint64_t BOMFileOpenWithSys( void *a1, uint64_t a2, uint64_t a3, uint64_t a4, char a5, void (**a6)(void, uint64_t, uint64_t, uint64_t))
{
  int v6 = a6;
  uint64_t v24 = *MEMORY[0x1895F89C0];
  if (!a6) {
    int v6 = (void (**)(void, uint64_t, uint64_t, uint64_t))BomSys_default();
  }
  int v20 = 25202;
  uint64_t result = ((uint64_t (*)(void, uint64_t, uint64_t, uint64_t))v6[2])(v6[1], a2, a3, a4);
  if ((_DWORD)result != -1)
  {
    uint64_t v13 = result;
    uint64_t result = ((uint64_t (*)(void (*)(void, uint64_t, uint64_t, uint64_t), uint64_t, _BYTE *))v6[11])( v6[1],  result,  v17);
    if ((_DWORD)result != -1)
    {
      int v14 = v18 & 0xF000;
      if (v14 == 0x8000)
      {
        if (!((unsigned int (*)(void (*)(void, uint64_t, uint64_t, uint64_t), uint64_t, _BYTE *))v6[14])( v6[1],  v13,  v21)
          && !(v22 ^ 0x73666361 | v23))
        {
          v16[0] = 0x300000000LL;
          v16[1] = 0LL;
          v16[2] = v19;
          v6[5](v6[1], v13, 42LL, (uint64_t)v16);
        }
      }

      else if (v14 == 0x4000)
      {
        *__error() = 21;
        return 0xFFFFFFFFLL;
      }

      if ((a3 & 1) != 0)
      {
        BYTE2(v20) = 0;
        __int16 v15 = 25207;
      }

      else
      {
        if ((a3 & 2) == 0)
        {
LABEL_16:
          uint64_t result = BOMFileNewFromFDWithSys(a1, v13, a5, (unsigned __int8 *)&v20, v6);
          if (!(_DWORD)result) {
            return result;
          }
          ((void (*)(void (*)(void, uint64_t, uint64_t, uint64_t), uint64_t))v6[4])(v6[1], v13);
          return 0xFFFFFFFFLL;
        }

        BYTE2(v20) = 0;
        __int16 v15 = 25185;
      }

      LOWORD(v20) = v15;
      goto LABEL_16;
    }
  }

  return result;
}

uint64_t BOMFileOpenSTDIN(void *a1, char a2)
{
  return BOMFileNewFromFDWithSys(a1, 0LL, a2 & 0xF, "rb", 0LL);
}

uint64_t BOMFileOpenSTDOUT(void *a1, char a2)
{
  return BOMFileNewFromFDWithSys(a1, 1LL, a2 & 0xF, "wb", 0LL);
}

uint64_t BOMFileClose(uint64_t a1)
{
  if (!a1) {
    return 0xFFFFFFFFLL;
  }
  int v2 = *(_DWORD *)a1;
  if ((*(_DWORD *)a1 - 1) <= 1)
  {
    int v3 = *(_DWORD *)(a1 + 32);
    if (v3 == 1)
    {
    }

    else if (v3 == 2)
    {
      CFIndex v4 = *(bz_stream **)(a1 + 40);
      if (v4->avail_out) {
        goto LABEL_73;
      }
      BOOL v5 = 0;
      while (1)
      {
        CFIndex v21 = 0x20000 - v4->avail_out;
        int v22 = *(UInt8 **)(a1 + 48);
        while (v21)
        {
          uint64_t v23 = _BOMFileWriteRaw(a1, v22, v21);
          v21 -= v23;
          v22 += v23;
          if (v23 == -1) {
            return 0xFFFFFFFFLL;
          }
        }

        v4->next_out = *(char **)(a1 + 48);
        v4->avail_out = 0x20000;
        if (v5) {
          break;
        }
LABEL_73:
        int v20 = BZ2_bzCompress(v4, 2);
        BOOL v5 = 1;
        if (v20 != 4)
        {
          BOOL v5 = 0;
          if (v20 != 3)
          {
            if (v20) {
              return 0xFFFFFFFFLL;
            }
            BOOL v5 = v4->avail_out != 0;
          }
        }
      }

      BZ2_bzCompressEnd(v4);
    }

    int v2 = *(_DWORD *)a1;
  }

  if (v2 == 3 || v2 == 0)
  {
    int v7 = *(_DWORD *)(a1 + 32);
    if (v7 == 2)
    {
      uint64_t v9 = *(void *)(a1 + 40);
      int v8 = *(void **)(a1 + 48);
      size_t v10 = *(unsigned int *)(v9 + 8);
      *(void *)(a1 + 72) = v10;
      *(_DWORD *)(a1 + 80) = 0;
      memmove(v8, *(const void **)v9, v10);
      if (BZ2_bzDecompressEnd(*(bz_stream **)(a1 + 40))) {
        return 0xFFFFFFFFLL;
      }
    }

    else
    {
      if (v7 != 1) {
        goto LABEL_20;
      }
    }

    int v2 = *(_DWORD *)a1;
  }

LABEL_20:
  if (v2 != 5)
  {
    if (v2 != 6) {
      goto LABEL_60;
    }
    uint64_t v11 = *(void **)(a1 + 104);
    if (v11)
    {
      *(void *)(a1 + 104) = 0LL;
    }

    else
    {
      uint64_t v11 = BOMBufferPoolRequestBuffer(gBufferPool);
      v11[1] = 0LL;
      v11[2] = 0LL;
    }

    *((_DWORD *)v11 + 12) |= 1u;
    BOMBufferFIFOEnqueue(*(void *)(a1 + 96), (uint64_t)v11);
    if (pthread_mutex_lock((pthread_mutex_t *)(a1 + 168))) {
      return 0xFFFFFFFFLL;
    }
    int v16 = *(_DWORD *)(a1 + 232);
    if (!v16)
    {
      int v16 = 1;
      *(_DWORD *)(a1 + 232) = 1;
    }

    if (gBOMAsyncDebug == 1)
    {
      fwrite("waiting for async write thread to finish...", 0x2BuLL, 1uLL, (FILE *)*MEMORY[0x1895F89D0]);
      int v16 = *(_DWORD *)(a1 + 232);
    }

    if (v16 != 2)
    {
      while (!pthread_cond_wait((pthread_cond_t *)(a1 + 120), (pthread_mutex_t *)(a1 + 168)))
      {
        if (*(_DWORD *)(a1 + 232) == 2) {
          goto LABEL_52;
        }
      }

      return 0xFFFFFFFFLL;
    }

  *v4 |= 8uLL;
  if ((v3 & 0x10) == 0)
  {
LABEL_7:
    if ((v3 & 0x20) == 0) {
      goto LABEL_8;
    }
    goto LABEL_22;
  }

  *((_BYTE *)v10 + 402) = a2;
  *((_BYTE *)v10 + 407) = a2;
  *((_DWORD *)v10 + 94) = 16843009 * a2;
  if ((a3 & 0x400) == 0)
  {
LABEL_11:
    if ((a3 & 0x1000) == 0) {
      goto LABEL_12;
    }
    goto LABEL_22;
  }

LABEL_52:
    if (pthread_mutex_unlock((pthread_mutex_t *)(a1 + 168)) || pthread_join(*(pthread_t *)(a1 + 112), 0LL)) {
      return 0xFFFFFFFFLL;
    }
    if (gBOMAsyncDebug == 1) {
      fwrite("async write thread terminated. Draining FIFO...", 0x2FuLL, 1uLL, (FILE *)*MEMORY[0x1895F89D0]);
    }
    while (BOMBufferFIFOCount(*(uint64_t **)(a1 + 96)))
    {
      uint64_t v17 = BOMBufferFIFODequeue(*(uint64_t **)(a1 + 96));
      BOMBufferPoolReturnBuffer(gBufferPool, v17);
    }

    if ((gBOMAsyncDebug & 1) == 0) {
      goto LABEL_60;
    }
    goto LABEL_59;
  }

  if (pthread_mutex_lock((pthread_mutex_t *)(a1 + 168))) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v12 = *(void *)(a1 + 104);
  if (v12)
  {
    BOMBufferPoolReturnBuffer(gBufferPool, v12);
    *(void *)(a1 + 104) = 0LL;
  }

  while (BOMBufferFIFOCount(*(uint64_t **)(a1 + 96)))
  {
    uint64_t v13 = BOMBufferFIFODequeue(*(uint64_t **)(a1 + 96));
    BOMBufferPoolReturnBuffer(gBufferPool, v13);
  }

  int v14 = *(_DWORD *)(a1 + 232);
  if (!v14)
  {
    int v14 = 1;
    *(_DWORD *)(a1 + 232) = 1;
  }

  if (gBOMAsyncDebug == 1)
  {
    fwrite("waiting for async read thread to finish...", 0x2AuLL, 1uLL, (FILE *)*MEMORY[0x1895F89D0]);
    int v14 = *(_DWORD *)(a1 + 232);
  }

  if (v14 != 2)
  {
    while (!pthread_cond_wait((pthread_cond_t *)(a1 + 120), (pthread_mutex_t *)(a1 + 168)))
    {
      if (*(_DWORD *)(a1 + 232) == 2) {
        goto LABEL_37;
      }
    }

    return 0xFFFFFFFFLL;
  }

        v46 = v44 & 0xF000;
        if (v46 != 0x4000)
        {
          if (v46 == 40960)
          {
            v104 = 0LL;
            if ((*(unsigned int (**)(void, uint64_t, char *))(*(void *)(a1 + 12832) + 96LL))( *(void *)(*(void *)(a1 + 12832) + 8LL),  a1 + 7424,  v100))
            {
              v79 = __error();
              strerror(*v79);
              BOMCopierNotifyFatalError(a1, "Could not lstat %s: %s", v80, v81, v82, v83, v84, v85, a1);
              goto LABEL_110;
            }

            if (v101 >= 1024)
            {
              BOMCopierNotifyFatalError(a1, "%s is too large: %ld", v47, v48, v49, v50, v51, v52, a1);
              goto LABEL_110;
            }

            if (BOMFileOpenWithSys( &v104,  a1 + 7424,  0LL,  0LL,  16,  *(void (***)(void, uint64_t, uint64_t, uint64_t))(a1 + 12832)))
            {
              BOMCopierNotifyFatalError(a1, "Could not open symlink %s", v53, v54, v55, v56, v57, v58, a1);
              goto LABEL_110;
            }

            v59 = v41;
            v60 = BOMFileRead(v104, (char *)(a1 + 3328), v101);
            if (v60 != v101)
            {
              BOMCopierNotifyFatalError(a1, "Could not read %s", v61, v62, v63, v64, v65, v66, a1);
              goto LABEL_110;
            }

            *(_BYTE *)(a1 + v60 + 3328) = 0;
            BOMFileClose((uint64_t)v104);
            _parentPath((const char *)(a1 + 7424), v110, 0x400uLL);
            v67 = (*(uint64_t (**)(void, char *, uint64_t))(*(void *)(a1 + 12832) + 184LL))( *(void *)(*(void *)(a1 + 12832) + 8LL),  v110,  2LL);
            if (v67)
            {
              if ((*(unsigned int (**)(void, char *, char *))(*(void *)(a1 + 12832) + 96LL))( *(void *)(*(void *)(a1 + 12832) + 8LL),  v110,  v102))
              {
                goto LABEL_110;
              }

              if ((*(unsigned int (**)(void, char *, void))(*(void *)(a1 + 12832) + 200LL))( *(void *)(*(void *)(a1 + 12832) + 8LL),  v110,  v103 | 0x1C0u))
              {
LABEL_89:
                v74 = __error();
                v75 = *(void (**)(uint64_t, char *, uint64_t))(a1 + 64);
                if (!v75) {
                  goto LABEL_110;
                }
                v76 = *v74;
                v77 = v110;
                v78 = a1;
LABEL_97:
                v75(v78, v77, v76);
                goto LABEL_110;
              }
            }

            if ((*(unsigned int (**)(void, uint64_t))(*(void *)(a1 + 12832) + 224LL))( *(void *)(*(void *)(a1 + 12832) + 8LL),  a1 + 7424))
            {
              v68 = __error();
              v69 = *(void (**)(uint64_t, uint64_t, void))(a1 + 64);
              if (v69) {
                v69(a1, a1 + 7424, *v68);
              }
            }

            if ((*(unsigned int (**)(void, uint64_t, uint64_t))(*(void *)(a1 + 12832) + 248LL))( *(void *)(*(void *)(a1 + 12832) + 8LL),  a1 + 3328,  a1 + 7424) == -1)
            {
              v86 = __error();
              v75 = *(void (**)(uint64_t, char *, uint64_t))(a1 + 64);
              if (!v75) {
                goto LABEL_110;
              }
              v76 = *v86;
              v78 = a1;
              v77 = (char *)(a1 + 7424);
              goto LABEL_97;
            }

            if (v67
              && (*(unsigned int (**)(void, char *, void))(*(void *)(a1 + 12832) + 200LL))( *(void *)(*(void *)(a1 + 12832) + 8LL),  v110,  v103 & 0xFFF))
            {
              goto LABEL_89;
            }

            v41 = v59;
            v40 = (const char *)(a1 + 249);
            goto LABEL_73;
          }

          if (v46 != 0x8000) {
            goto LABEL_73;
          }
        }

        if (_chPerms(a1, (char *)(a1 + 7424), (uint64_t)v106, 0LL, 0) == -1)
        {
          if (*__error() != 2 && *__error() != 63)
          {
            v92 = __error();
            strerror(*v92);
            BOMCopierNotifyFatalError(a1, "Could not chmod %s: %s", v93, v94, v95, v96, v97, v98, a1);
            goto LABEL_110;
          }

          *__error() = 0;
        }

LABEL_37:
  if (pthread_mutex_unlock((pthread_mutex_t *)(a1 + 168)) || pthread_join(*(pthread_t *)(a1 + 112), 0LL)) {
    return 0xFFFFFFFFLL;
  }
  while (BOMBufferFIFOCount(*(uint64_t **)(a1 + 96)))
  {
    uint64_t v15 = BOMBufferFIFODequeue(*(uint64_t **)(a1 + 96));
    BOMBufferPoolReturnBuffer(gBufferPool, v15);
  }

  if (gBOMAsyncDebug == 1) {
LABEL_59:
  }
    fwrite("done\n", 5uLL, 1uLL, (FILE *)*MEMORY[0x1895F89D0]);
LABEL_60:
  if (*(_DWORD *)(a1 + 32) == 3)
  {
    if (!CloseStreamCompressor())
    {
      *(void *)(a1 + 40) = 0LL;
      goto LABEL_63;
    }

    return 0xFFFFFFFFLL;
  }

  BOMTreeSetDensePacking(*(void *)(v6 + 16), 0);
  v30 = *(void **)(v6 + 56);
  if (v30) {
    free(v30);
  }
  v31 = *(unsigned int *)(a2 + 48);
  *(_DWORD *)(v6 + 48) = v31;
  v32 = 24 * v31;
  v33 = BOM_malloczero(24 * v31);
  *(void *)(v6 + 56) = v33;
  if (v33) {
    memmove(v33, *(const void **)(a2 + 56), v32);
  }
  *(_DWORD *)int v6 = *(_DWORD *)a2;
  return v6;
}

      if (*(_DWORD *)(a1 + 12716) == 4)
      {
        BOMFileClose(v45);
        BOMCopierNotifyFatalError(a1, "Cannot create CPIO file at %s", v31, v32, v33, v34, v35, v36, v45);
      }

      else
      {
        BOMFileClose(v45);
        BOMCopierNotifyFatalError(a1, "Cannot create PKZip file at %s", v37, v38, v39, v40, v41, v42, v45);
      }

      return 1LL;
    }

    CFIndex v21 = *(unsigned int *)(a1 + 12988);
    if ((_DWORD)v21 == -1)
    {
      v29 = *(const void **)(a1 + 12952);
      v30 = __error();
      uint64_t v23 = *(void (**)(uint64_t, const char *, uint64_t))(a1 + 64);
      if (!v23) {
        return 1LL;
      }
      uint64_t v24 = *v30;
      v25 = "wstream";
    }

    else
    {
      if (!BOMFileNewFromFDWithSys( &v45,  v21,  v19,  "wb",  *(void (***)(void, uint64_t, uint64_t, uint64_t))(a1 + 12832))) {
        goto LABEL_37;
      }
      int v22 = __error();
      uint64_t v23 = *(void (**)(uint64_t, const char *, uint64_t))(a1 + 64);
      if (!v23) {
        return 1LL;
      }
      uint64_t v24 = *v22;
      v25 = "fdesc";
    }

    v27 = a1;
    goto LABEL_34;
  }

  if (__s1)
  {
    uint64_t v11 = *(void *)(a1 + 12936);
    if (v11)
    {
      uint64_t result = _mkdirs(a1, v11);
      if (!(_DWORD)result) {
        return result;
      }
      v44 = *(void *)(a1 + 12936);
      goto LABEL_16;
    }

    return 0LL;
  }

  BOMCopierNotifyFatalError( a1,  "If the destination is a filesystem, the toObj argument cannot be nil",  a3,  a4,  a5,  a6,  a7,  a8,  v43);
  _resetCopier(a1);
  return 1LL;
}

          if (++v13 == v9) {
            goto LABEL_38;
          }
        }

        v37 = __error();
        BOMCopierErrorCapture( a3,  *v37,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierMatchRecord.c",  347,  (uint64_t)"BOMCopierMatchBinary",  "Could not get arch record for index %d",  MEMORY[0x1895FB810]);
        free(v48);
        return 1LL;
      }

        int v14 = 0LL;
        goto LABEL_97;
      case 2:
        v38 = (uint64_t *)&a1[14 * v17];
        v40 = v38[10];
        v39 = v38 + 10;
        if (v40 <= a6) {
          goto LABEL_41;
        }
        if (BOMFileSeek() < 0)
        {
LABEL_114:
          v74 = __error();
          v43 = v81;
          v70 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v81 + 72);
          if (v70)
          {
LABEL_115:
            v71 = *v74;
            v72 = v43;
            v73 = v77;
LABEL_116:
            v75 = v70(v72, v73, v71);
            if (v75 == 1)
            {
              v75 = 0;
LABEL_120:
              if (*(_BYTE *)(v43 + 168)) {
                int v14 = 2LL;
              }
              else {
                int v14 = v75;
              }
              goto LABEL_123;
            }

            if (v75) {
              goto LABEL_120;
            }
          }

          goto LABEL_118;
        }

        a6 = *v39;
LABEL_41:
        v78 = &a1[14 * v17 + 18];
        if (*v78 >= 1)
        {
          v41 = 0;
          v42 = (unint64_t *)&a1[14 * v17 + 16];
          while (1)
          {
            v43 = v81;
            v44 = *v42;
            if (*(_DWORD *)(v81 + 12776))
            {
              v45 = 0LL;
              while (1)
              {
                v46 = BOMFileRead(v15, buf, v44 - v45);
                if ((v46 & 0x8000000000000000LL) != 0) {
                  goto LABEL_111;
                }
                v45 += v46;
                if (!BOMFileEndOfCompressionStream((BOOL)v15))
                {
                  v44 = *v42;
                  if (v45 != *v42) {
                    continue;
                  }
                }

                goto LABEL_50;
              }
            }

            v45 = BOMFileRead(v15, buf, v44);
LABEL_50:
            if (v45 != *v42) {
              goto LABEL_111;
            }
            v47 = BOMFileWrite(v21, (UInt8 *)buf, v45);
            if (v47 != *v42) {
              break;
            }
            v48 = v47;
            if (v82)
            {
              crc = crc32(crc, (const Bytef *)buf, v47);
              v48 = *v42;
            }

            if (v80)
            {
              CNCRCUpdate();
              v48 = *v42;
            }

            v19 += v48;
            v49 = *(void (**)(uint64_t, void, uint64_t))(v81 + 104);
            if (v49)
            {
              v49(v81, *((void *)a1 + 3), v19);
              if (*(_BYTE *)(v81 + 168))
              {
                int v14 = 2LL;
                goto LABEL_123;
              }
            }

            int v14 = 0LL;
            a6 += v45;
            if (++v41 >= *v78) {
              goto LABEL_97;
            }
          }

          v74 = __error();
          v70 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v81 + 72);
          if (v70) {
            goto LABEL_115;
          }
          goto LABEL_118;
        }

        goto LABEL_96;
      case 3:
        v50 = *((void *)a1 + 4);
        v51 = v50 - a6;
        if (v50 - a6 >= v79) {
          v51 = v79;
        }
        if (v50 == -1) {
          v52 = v79;
        }
        else {
          v52 = v51;
        }
        int v14 = v18;
        if (!v52) {
          goto LABEL_97;
        }
        while (2)
        {
          if ((*(_DWORD *)(v81 + 12776) || *(_BYTE *)(v81 + 12796))
            && *(_BYTE *)(v81 + 12769)
            && BOMFileEndOfCompressionStream((BOOL)v15))
          {
            goto LABEL_96;
          }

          v53 = BOMFileRead(v15, buf, v52);
          if (v53 < 0 || (v54 = v53, v55 = *((void *)a1 + 4), v52 != v53) && v55 != -1)
          {
            v61 = __error();
            v62 = v81;
            v63 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v81 + 72);
            if (!v63) {
              goto LABEL_105;
            }
            v64 = *v61;
            v65 = v81;
            v66 = v81 + 248;
LABEL_103:
            v68 = v63(v65, v66, v64);
            if (v68 == 1)
            {
              v68 = 0;
LABEL_107:
              if (*(_BYTE *)(v62 + 168)) {
                int v14 = 2LL;
              }
              else {
                int v14 = v68;
              }
              goto LABEL_97;
            }

            if (v68) {
              goto LABEL_107;
            }
LABEL_105:
            v68 = 1;
            goto LABEL_107;
          }

          a6 += v53;
          if (!v53 && v55 == -1) {
            goto LABEL_96;
          }
          if (BOMFileWrite(v21, (UInt8 *)buf, v53) != v53)
          {
            v67 = __error();
            v62 = v81;
            v63 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v81 + 72);
            if (!v63) {
              goto LABEL_105;
            }
            v64 = *v67;
            v65 = v81;
            v66 = v77;
            goto LABEL_103;
          }

          if (v82) {
            crc = crc32(crc, (const Bytef *)buf, v54);
          }
          if (v80) {
            CNCRCUpdate();
          }
          v19 += v54;
          v56 = *(void (**)(uint64_t, void, uint64_t))(v81 + 104);
          if (!v56 || (v56(v81, *((void *)a1 + 3), v19), !*(_BYTE *)(v81 + 168)))
          {
            uint64_t v18 = 0LL;
            int v14 = 0LL;
            v57 = *((void *)a1 + 4);
            v58 = v57 - a6;
            if (v57 - a6 >= v79) {
              v58 = v79;
            }
            if (v57 == -1) {
              v52 = v79;
            }
            else {
              v52 = v58;
            }
            if (!v52) {
              goto LABEL_97;
            }
            continue;
          }

          break;
        }

LABEL_63:
  uint64_t v18 = 0LL;
  switch(*(_DWORD *)a1)
  {
    case 0:
    case 1:
      uint64_t v18 = (*(uint64_t (**)(void, void))(*(void *)(a1 + 272) + 32LL))( *(void *)(*(void *)(a1 + 272) + 8LL),  *(unsigned int *)(a1 + 8));
      *(_DWORD *)(a1 + 8) = -1;
      break;
    case 2:
      CFWriteStreamClose(*(CFWriteStreamRef *)(a1 + 8));
      goto LABEL_68;
    case 3:
      CFReadStreamClose(*(CFReadStreamRef *)(a1 + 8));
LABEL_68:
      uint64_t v18 = 0LL;
      goto LABEL_69;
    case 5:
    case 6:
      uint64_t v18 = BOMFileClose(*(void *)(a1 + 8));
LABEL_69:
      *(void *)(a1 + 8) = 0LL;
      break;
    default:
      break;
  }

  _freeBOMFile((void *)a1);
  return v18;
}

    v38 = a1;
  }

    uint64_t v23 = (*(unsigned int (**)(void, uint64_t, statfs *, uint64_t *))(*(void *)(a1 + 12832) + 296LL))( *(void *)(*(void *)(a1 + 12832) + 8LL),  v19,  &v79,  &v76) == 0;
    uint64_t v24 = v76;
    if (!v23 || v76 == 0) {
      goto LABEL_20;
    }
  }

  v39 = v75 & 0xF000;
  if (v32)
  {
    if (v39 != 0x4000) {
      goto LABEL_63;
    }
    goto LABEL_86;
  }

  if (v39 != 0x8000)
  {
LABEL_86:
    HIDWORD(v47) = v39;
    LODWORD(v47) = v39 - 0x2000;
    switch((v47 >> 13))
    {
      case 0u:
      case 2u:
        v48 = _copyDevice(a1, (uint64_t)v74);
        break;
      case 1u:
        v48 = _copyDir(a1, (uint64_t)v74, (uint64_t)v73, v34, v78, (uint64_t)v13, v21, v14, __size, v68, v32);
        break;
      case 3u:
        v48 = _copyFile(a1, (uint64_t)v74, (uint64_t)v73, v78, *(_DWORD **)(a1 + 136), &v77, 0);
        break;
      case 4u:
        v48 = _copyLink(a1, (uint64_t)v74, (uint64_t)v73, v78);
        break;
      default:
        goto LABEL_63;
    }

    if ((_DWORD)v48 == 1)
    {
      uint64_t v17 = 1LL;
    }

    else if ((_DWORD)v48 == 2)
    {
      uint64_t v17 = v48;
      goto LABEL_104;
    }

    goto LABEL_63;
  }

  if (*(_DWORD *)(a1 + 12716) != 3)
  {
    v39 = 0x8000;
    goto LABEL_86;
  }

  if (!BOMAppleDoubleIsADFile((const char *)(a1 + 248)))
  {
    v39 = v75 & 0xF000;
    goto LABEL_86;
  }

  if (v63)
  {
    if (v63 == v29)
    {
      v63 = 2 * v29;
      v46 = (void **)BOM_realloc(v70, 32 * v29);
    }

    else
    {
      v46 = v70;
    }
  }

  else
  {
    v46 = (void **)BOM_malloc(0x40uLL);
    v63 = 4LL;
  }

  v70 = v46;
  if (!v46)
  {
    BOMCopierNotifyFatalError(a1, "Could not allocate space for Apple Double files.", v40, v41, v42, v43, v44, v45, v60);
    uint64_t v17 = 2LL;
    goto LABEL_110;
  }

  v49 = (char *)BOM_malloc(v34 + 1);
  if (v49)
  {
    v56 = v49;
    strlcpy(v49, v13, v34 + 1);
    v57 = (char **)&v70[2 * v29];
    *v57 = v56;
    v57[1] = (char *)v34;
    ++v29;
    goto LABEL_63;
  }

  BOMCopierNotifyFatalError( a1,  "Could not allocate space for Apple Double filename.",  v50,  v51,  v52,  v53,  v54,  v55,  v60);
LABEL_35:
  uint64_t v17 = 2LL;
  v28 = v70;
LABEL_105:
  if (v29)
  {
    v58 = v28;
    do
    {
      free(*v58);
      *v58 = 0LL;
      v58 += 2;
      --v29;
    }

    while (v29);
  }

  free(v28);
LABEL_109:
  if (v19) {
LABEL_110:
  }
    (*(void (**)(void, uint64_t))(*(void *)(a1 + 12832) + 280LL))( *(void *)(*(void *)(a1 + 12832) + 8LL),  v19);
  return v17;
}

unint64_t BOMFileRead(int *a1, char *a2, unint64_t a3)
{
  if (!a1) {
    return -1LL;
  }
  int v3 = *a1;
  if (!*a1) {
    return _BOMFileDirectRead((uint64_t)a1, a2, a3);
  }
  if (v3 != 5)
  {
    if (v3 == 3) {
      return _BOMFileDirectRead((uint64_t)a1, a2, a3);
    }
    return -1LL;
  }

  return _BOMFileAsyncRead((uint64_t)a1, a2, a3);
}

uint64_t _BOMFileDirectRead(uint64_t a1, char *__dst, unint64_t a3)
{
  if (a3)
  {
    if (!__dst) {
      return -1LL;
    }
    unint64_t v4 = a3;
    int v6 = *(_DWORD *)(a1 + 32);
    if (v6)
    {
      if (v6 == 2)
      {
        uint64_t v15 = *(bz_stream **)(a1 + 40);
        v15->next_out = __dst;
        v15->uint64_t avail_out = a3;
        do
        {
          if (!v15->avail_in && !*(_BYTE *)(a1 + 64))
          {
            uint64_t Raw = _BOMFileReadRaw(a1, *(UInt8 **)(a1 + 48), 0x20000LL);
            uint64_t v8 = Raw;
            if (Raw)
            {
              if (Raw == -1) {
                return v8;
              }
            }

            else
            {
              *(_BYTE *)(a1 + 64) = 1;
            }

            v15->avail_in = Raw;
            v15->next_in = *(char **)(a1 + 48);
          }

          int v17 = BZ2_bzDecompress(v15);
          if (v17)
          {
            if (v17 != 4) {
              return -1LL;
            }
            *(_BYTE *)(a1 + 64) = 1;
          }

          uint64_t avail_out = v15->avail_out;
        }

        while ((_DWORD)avail_out && !*(_BYTE *)(a1 + 65) && !*(_BYTE *)(a1 + 64));
        goto LABEL_46;
      }

      if (v6 == 1)
      {
        int v7 = *(z_stream **)(a1 + 40);
        v7->next_out = (Bytef *)__dst;
        v7->uint64_t avail_out = a3;
        do
        {
          LODWORD(v8) = v7->avail_in;
          if (!(_DWORD)v8)
          {
            if (*(_BYTE *)(a1 + 64))
            {
              LODWORD(v8) = 0;
            }

            else
            {
              uint64_t v9 = _BOMFileReadRaw(a1, *(UInt8 **)(a1 + 48), 0x20000LL);
              uint64_t v8 = v9;
              if (v9)
              {
                if (v9 == -1) {
                  return v8;
                }
              }

              else
              {
                *(_BYTE *)(a1 + 64) = 1;
              }

              *(_DWORD *)(a1 + 264) = v9;
              v7->avail_in = v9;
              v7->next_in = *(Bytef **)(a1 + 48);
            }
          }

          if (*(_BYTE *)(a1 + 256))
          {
            int v10 = *(_DWORD *)(a1 + 264);
            if (v10)
            {
              unsigned int v11 = *(_DWORD *)(a1 + 260);
              else {
                int v12 = v8;
              }
              *(_DWORD *)(a1 + 260) = v11 - v12;
              *(_DWORD *)(a1 + 264) = v10 - v12;
              decrypt_buffer((uint64_t)v7->next_in, v12, (int *)(a1 + 244));
            }
          }

          int v13 = inflate(v7, 0);
          if (v13)
          {
            if (v13 != 1) {
              return -1LL;
            }
            *(_BYTE *)(a1 + 64) = 1;
          }

          uint64_t avail_out = v7->avail_out;
        }

        while ((_DWORD)avail_out && (avail_out == v4 || !*(_BYTE *)(a1 + 65)) && !*(_BYTE *)(a1 + 64));
LABEL_46:
        uint64_t v8 = v4 - avail_out;
        goto LABEL_47;
      }

      return -1LL;
    }

    if (*(_BYTE *)(a1 + 67) == 1)
    {
      uint64_t v8 = 0LL;
      *(_WORD *)(a1 + 66) = 0;
LABEL_47:
      *(void *)(a1 + 24) += v8;
      return v8;
    }

    uint64_t v8 = *(void *)(a1 + 72);
    if (v8)
    {
      uint64_t v19 = 88LL;
      if (!*(_DWORD *)(a1 + 80)) {
        uint64_t v19 = 48LL;
      }
      int v20 = *(char **)(a1 + v19);
      if (*(_BYTE *)(a1 + 66) == 1)
      {
        unint64_t v29 = 0LL;
        if (search_for_data_descriptor((uint64_t)v20, v8, &v29))
        {
          *(_BYTE *)(a1 + 67) = 1;
          unint64_t v4 = v29;
          if (!v29)
          {
            uint64_t v8 = 0LL;
            goto LABEL_47;
          }
        }
      }

      if (v4 < v8) {
        uint64_t v8 = v4;
      }
      if (v8 >= 1)
      {
        memcpy(__dst, v20, v8);
        uint64_t v21 = *(void *)(a1 + 72);
        v4 -= v8;
        *(_DWORD *)(a1 + 264) -= v8;
        int v22 = (UInt8 *)&__dst[v8];
        *(void *)(a1 + 72) = v21 - v8;
        if (v21 != v8) {
          memmove(v20, &v20[v8], v21 - v8);
        }
        if (!v4) {
          goto LABEL_70;
        }
        goto LABEL_65;
      }

      uint64_t v8 = 0LL;
    }

    int v22 = (UInt8 *)__dst;
LABEL_65:
    uint64_t v23 = _BOMFileReadRaw(a1, v22, v4);
    if (v23 == -1)
    {
      uint64_t v8 = -1LL;
      goto LABEL_47;
    }

    if (v23) {
      v8 += v23;
    }
    else {
      *(_BYTE *)(a1 + 64) = 1;
    }
LABEL_70:
    if (*(_BYTE *)(a1 + 66) != 1
      || (unint64_t v29 = 0LL, !search_for_data_descriptor((uint64_t)__dst, v8, &v29))
      || (*(_BYTE *)(a1 + 67) = 1, uint64_t v24 = v29, v25 = v8 - v29, v8 == v29))
    {
LABEL_73:
      if (*(_BYTE *)(a1 + 256) == 1) {
        decrypt_buffer((uint64_t)__dst, v8, (int *)(a1 + 244));
      }
      goto LABEL_47;
    }

    if (*(void *)(a1 + 72))
    {
      v26 = (FILE *)*MEMORY[0x1895F89D0];
      v27 = "The extra buffer is not empty";
      size_t v28 = 29LL;
    }

    else
    {
      if (v25 <= 0x20000)
      {
        *(void *)(a1 + 72) = v25;
        *(_DWORD *)(a1 + 80) = 1;
        memcpy(*(void **)(a1 + 88), &v22[v24], v25);
        uint64_t v8 = v24;
        goto LABEL_73;
      }

      v26 = (FILE *)*MEMORY[0x1895F89D0];
      v27 = "The extra buffer is not large enough";
      size_t v28 = 36LL;
    }

    fwrite(v27, v28, 1uLL, v26);
    uint64_t v8 = -1LL;
    goto LABEL_47;
  }

  return 0LL;
}

unint64_t _BOMFileAsyncRead(uint64_t a1, char *__dst, size_t a3)
{
  if (!a3)
  {
    unint64_t v6 = 0LL;
    goto LABEL_17;
  }

  size_t v4 = a3;
  unint64_t v6 = 0LL;
  while (1)
  {
    int v7 = *(void **)(a1 + 104);
    if (!v7)
    {
      int v7 = (void *)BOMBufferFIFODequeue(*(uint64_t **)(a1 + 96));
      *(void *)(a1 + 104) = v7;
    }

    uint64_t v8 = v7[1];
    if (v4 >= v7[2] - v8) {
      size_t v9 = v7[2] - v8;
    }
    else {
      size_t v9 = v4;
    }
    memcpy(__dst, (const void *)(v7[3] + v8), v9);
    uint64_t v10 = v7[2];
    size_t v11 = v7[1] + v9;
    v7[1] = v11;
    v6 += v9;
    if (v10 != v11) {
      goto LABEL_14;
    }
    if (!v11)
    {
      if (pthread_mutex_lock((pthread_mutex_t *)(a1 + 168))) {
        goto LABEL_17;
      }
      int v13 = *(_DWORD *)(a1 + 232);
      int v12 = *(_DWORD *)(a1 + 236);
      if (pthread_mutex_unlock((pthread_mutex_t *)(a1 + 168))) {
        goto LABEL_17;
      }
    }

    BOMBufferPoolReturnBuffer(gBufferPool, (uint64_t)v7);
    *(void *)(a1 + 104) = 0LL;
LABEL_14:
    __dst += v9;
    v4 -= v9;
    if (!v4) {
      goto LABEL_17;
    }
  }

  if (v12)
  {
    *__error() = v12;
    return -1LL;
  }

LABEL_17:
  *(int64x2_t *)(a1 + 16) = vaddq_s64(*(int64x2_t *)(a1 + 16), vdupq_n_s64(v6));
  return v6;
}

              BOMBomRemoveFSObject((unint64_t)v12, v26);
              goto LABEL_18;
            }

  if ((v9 & 0xF000) == 0x8000 && *(_BYTE *)(a1 + 206) == 1) {
    v14 &= 0xFFB6u;
  }
  int v16 = v9 & v14;
  if (a4 && v10 > ((unsigned __int16)v9 & (unsigned __int16)v14 & 0x1C0u))
  {
    *(_WORD *)(a3 + 4) = v9 & v14;
    int v16 = v16 | v10;
    *a4 = 1;
  }

  if (a5
    && (v15 & v8) != 0xFFFFFFFF
    && (*(unsigned int (**)(void, char *, uint64_t))(*(void *)(a1 + 12832) + 192LL))( *(void *)(*(void *)(a1 + 12832) + 8LL),  a2,  v15)
    && (*__error() == 45 || *__error() == 1 && (v16 & 0xF000) == 0xA000))
  {
    *__error() = 0;
  }

  if ((v16 & 0xF000) == 0xA000) {
    return lchmod(a2, v16);
  }
  uint64_t v18 = (*(uint64_t (**)(void, char *, uint64_t))(*(void *)(a1 + 12832) + 200LL))( *(void *)(*(void *)(a1 + 12832) + 8LL),  a2,  v16);
  if ((_DWORD)v18)
  {
    if (*__error() == 45)
    {
      uint64_t v18 = 0LL;
      *__error() = 0;
    }
  }

  return v18;
}

CFIndex BOMFileWrite(uint64_t a1, UInt8 *a2, CFIndex a3)
{
  if (!a1) {
    return -1LL;
  }
  size_t v3 = a3;
  size_t v4 = a2;
  int v6 = *(_DWORD *)a1;
  if (v6 != 6)
  {
    if (v6 != 4) {
      return -1LL;
    }
    if (!**(void **)(a1 + 8)) {
      return v3;
    }
    uint64_t v7 = 8LL;
    while (BOMFileWrite() == v3)
    {
      uint64_t v8 = *(void *)(*(void *)(a1 + 8) + v7);
      v7 += 8LL;
      if (!v8) {
        return v3;
      }
    }

    return -1LL;
  }

  unint64_t v10 = 0LL;
  if (!a3) {
    goto LABEL_24;
  }
  while (1)
  {
    size_t v11 = *(void **)(a1 + 104);
    if (v11)
    {
      uint64_t v12 = v11[1];
    }

    else
    {
      size_t v11 = BOMBufferPoolRequestBuffer(gBufferPool);
      uint64_t v12 = 0LL;
      v11[1] = 0LL;
      v11[2] = 0LL;
      *(void *)(a1 + 104) = v11;
    }

    if (v3 >= *v11 - v12) {
      size_t v13 = *v11 - v12;
    }
    else {
      size_t v13 = v3;
    }
    memcpy((void *)(v11[3] + v12), v4, v13);
    int64x2_t v14 = vaddq_s64(*(int64x2_t *)(v11 + 1), vdupq_n_s64(v13));
    *(int64x2_t *)(v11 + 1) = v14;
    v10 += v13;
    if (*v11 != v14.i64[0]) {
      goto LABEL_23;
    }
    if (pthread_mutex_lock((pthread_mutex_t *)(a1 + 168))) {
      goto LABEL_24;
    }
    int v16 = *(_DWORD *)(a1 + 232);
    int v15 = *(_DWORD *)(a1 + 236);
    if (pthread_mutex_unlock((pthread_mutex_t *)(a1 + 168))) {
      goto LABEL_24;
    }
    BOMBufferFIFOEnqueue(*(void *)(a1 + 96), (uint64_t)v11);
    *(void *)(a1 + 104) = 0LL;
LABEL_23:
    v4 += v13;
    v3 -= v13;
    if (!v3) {
      goto LABEL_24;
    }
  }

  if (v15)
  {
    *__error() = v15;
    return -1LL;
  }

LABEL_24:
  *(int64x2_t *)(a1 + 16) = vaddq_s64(*(int64x2_t *)(a1 + 16), vdupq_n_s64(v10));
  return v10;
}

    BOMTreeIteratorNext((uint64_t)v19);
    a6 = v86;
  }

  while (!BOMTreeIteratorIsAtEnd((uint64_t)v19));
  BOMTreeIteratorFree(v19);
  uint64_t v21 = v73;
  if (v73) {
    *((_BYTE *)a2 + 64) = 1;
  }
LABEL_10:
  if (!v9) {
    BOMHardLinkTableFree((const void **)v85);
  }
  if (v20) {
    free(v20);
  }
  return v21;
}

      *(void *)&v96 = byte_stream_read_uint32((uint64_t)v45);
      goto LABEL_25;
    }

    v55 = a1[6];
    byte_stream_new(a1[1], 0LL);
    if (!v56)
    {
      v90 = "Could not create extra byte stream";
      v91 = v5;
      v92 = 3416;
      goto LABEL_103;
    }

    v60 = (void *)v56;
    v61 = v55 + v16;
    uint64_t v24 = v12;
    byte_stream_attach(v56, v61, v12);
    if (a4)
    {
      v62 = "pkzip local header";
      if (darc_format_entry_get_attribute(a2, "pkzip local header", 0LL) != 32)
      {
        v90 = "Could not extract PKZip local header from entry";
        v91 = v5;
        v92 = 3465;
LABEL_103:
        capture_error( v91,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_decoder.c",  v92,  (uint64_t)"parse_entry_pkzip_extra_field_zip64",  v90,  v57,  v58,  v59,  v93);
        v75 = "Could not parse extended timestamp";
        v76 = v5;
        v77 = 3288;
        goto LABEL_104;
      }
    }

    else
    {
      v62 = "pkzip central directory header";
      if (darc_format_entry_get_attribute(a2, "pkzip central directory header", 0LL) != 48)
      {
        v90 = "Could not extract PKZip central directory header from entry";
        v91 = v5;
        v92 = 3483;
        goto LABEL_103;
      }
    }

    darc_format_entry_get_attribute(a2, v62, &v95);
    v69 = DWORD1(v96);
    v68 = DWORD2(v96);
    v97 = 0LL;
    v95 = 0u;
    v96 = 0u;
    if (v68 == -1)
    {
      LOBYTE(v95) = 1;
      *((void *)&v95 + 1) = byte_stream_read_uint64((uint64_t)v60);
    }

    if (v69 == -1)
    {
      BYTE1(v95) = 1;
      *(void *)&v96 = byte_stream_read_uint64((uint64_t)v60);
    }

    if ((a4 & 1) == 0)
    {
    }

    if (byte_stream_exception((BOOL)v60))
    {
      v90 = "Could not parse the PKZip ZIP64 extra block";
      v91 = v5;
      v92 = 3523;
      goto LABEL_103;
    }

    if (darc_format_entry_set_attribute(a2, "pkzip extra field ZIP64", &v95, 0x28uLL))
    {
      v90 = "Could not set ZIP64";
      v91 = v5;
      v92 = 3534;
      goto LABEL_103;
    }

    byte_stream_free(v60);
    if (darc_format_entry_set_size(a2, *((uint64_t *)&v95 + 1)))
    {
      v90 = "Could not reset pkzip entry size";
      v91 = v5;
      v92 = 3547;
      goto LABEL_103;
    }

      BOMTreeIteratorFree(v15);
      return v11;
    }
  }

  return 0LL;
}

  *v4 |= 0x80uLL;
  if ((v3 & 0x100) != 0) {
LABEL_11:
  }
    *v4 |= 0x100uLL;
LABEL_12:
  inited = init_data_analyzer(v4, a2);
  if (inited)
  {
    BOMCopierErrorCapture( a2,  inited,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDataAnalyzer.c",  112,  (uint64_t)"BOMCopierDataAnalyzerNew",  "Could not initialize BOMCopierDataAnalyzer");
    BOMCopierDataAnalyzerFree(v5);
    return 0LL;
  }

  return v5;
}

CFIndex _BOMFileDirectWrite(uint64_t a1, UInt8 *buffer, CFIndex bufferLength)
{
  CFIndex v3 = bufferLength;
  if (bufferLength)
  {
    if (buffer)
    {
      switch(*(_DWORD *)(a1 + 32))
      {
        case 0:
          CFIndex v6 = 0LL;
          while (v3)
          {
            uint64_t v7 = _BOMFileWriteRaw(a1, buffer, v3);
            v6 += v7;
            v3 -= v7;
            if (v7 < 0) {
              return -1LL;
            }
          }

          goto LABEL_18;
        case 1:
          uint64_t v8 = *(z_stream **)(a1 + 40);
          v8->next_in = buffer;
          v8->avail_in = bufferLength;
          if (!(_DWORD)bufferLength) {
            goto LABEL_27;
          }
          uInt avail_out = v8->avail_out;
          if (!avail_out) {
            goto LABEL_22;
          }
          while (!deflate(v8, 0))
          {
            uInt avail_out = v8->avail_out;
LABEL_22:
            CFIndex v13 = 0x20000 - avail_out;
            int64x2_t v14 = *(UInt8 **)(a1 + 48);
            while (v13)
            {
              uint64_t v15 = _BOMFileWriteRaw(a1, v14, v13);
              v14 += v15;
              v13 -= v15;
              if (v15 < 0) {
                return -1LL;
              }
            }

            v8->uInt avail_out = 0x20000;
            v8->next_out = *(Bytef **)(a1 + 48);
            if (!v8->avail_in)
            {
LABEL_27:
              *(void *)(a1 + 56) = crc32(*(void *)(a1 + 56), buffer, v3);
              goto LABEL_28;
            }
          }

          return -1LL;
        case 2:
          unint64_t v10 = *(bz_stream **)(a1 + 40);
          v10->next_in = (char *)buffer;
          v10->avail_in = bufferLength;
          if (!(_DWORD)bufferLength) {
            goto LABEL_28;
          }
          unsigned int v11 = v10->avail_out;
          if (!v11) {
            goto LABEL_32;
          }
          while (BZ2_bzCompress(v10, 0) <= 1)
          {
            unsigned int v11 = v10->avail_out;
LABEL_32:
            CFIndex v17 = 0x20000 - v11;
            uint64_t v18 = *(UInt8 **)(a1 + 48);
            while (v17)
            {
              uint64_t v19 = _BOMFileWriteRaw(a1, v18, v17);
              v18 += v19;
              v17 -= v19;
              if (v19 < 0) {
                return -1LL;
              }
            }

            v10->uInt avail_out = 0x20000;
            v10->next_out = *(char **)(a1 + 48);
            if (!v10->avail_in) {
              goto LABEL_28;
            }
          }

          return -1LL;
        case 3:
          CFIndex v6 = 0LL;
          break;
        default:
          return -1LL;
      }

      while (v3)
      {
        uint64_t v12 = WriteToStreamCompressor();
        v6 += v12;
        v3 -= v12;
        if (v12 < 0) {
          return -1LL;
        }
      }

LABEL_18:
      CFIndex v3 = v6;
LABEL_28:
      *(void *)(a1 + 24) += v3;
    }

    else
    {
      return -1LL;
    }
  }

  return v3;
}

    BOMBomEnumeratorFree(v4);
  }

  return v2;
}

        BOMCopierNotifyFatalError(a1, "The options dictionary is not a CFDictionary", v15, v16, v17, v18, v19, v20, v56);
        return 1LL;
      }
    }

    return BOMCopierCopyWithOptions2(a1, a2, a3, a4);
  }

  int v22 = 1LL;
  fwrite("Invalid BOMCopier\n", 0x12uLL, 1uLL, (FILE *)*MEMORY[0x1895F89D0]);
  return v22;
}

    v25[48] = v34;
    if (!*v95 && !*(void *)(a2 + 96))
    {
      v44 = v99;
      if (v99 >= 1)
      {
        v45 = 0LL;
        while (1)
        {
          v46 = v44 - v45;
          v47 = v46 >= 1024 ? 1024LL : v46;
          File = (int *)BOMPKZipGetFile(*(void *)(a1 + 12752));
          if (BOMFileRead(File, _copyFromPKZip_junk, v47) != v47) {
            break;
          }
          v45 += v47;
          v44 = v99;
          if (v45 == v99)
          {
            v99 = 0LL;
            size_t v25 = (_BYTE *)(a1 + 12721);
            *(_BYTE *)(a1 + 12769) = 0;
            goto LABEL_19;
          }
        }

        v69 = "Couldn't extract junk data";
        goto LABEL_113;
      }
    }

  *((_BYTE *)v10 + 388) = a2;
  *((_DWORD *)v10 + 96) = 16843009 * a2;
  if ((a3 & 0x8000) == 0)
  {
LABEL_9:
    if ((a3 & 0x200) == 0) {
      goto LABEL_10;
    }
    goto LABEL_20;
  }

uint64_t BOMFileSeek()
{
  v0 = (int64x2_t *)MEMORY[0x1895F8858]();
  uint64_t v18 = *MEMORY[0x1895F89C0];
  int64_t v3 = v1;
  uint64_t v4 = (uint64_t)v0;
  switch(v0->i32[0])
  {
    case 0:
      if (!v0[2].i32[0]) {
        goto LABEL_44;
      }
      goto LABEL_3;
    case 1:
      if (v0[2].i32[0]) {
        goto LABEL_14;
      }
LABEL_44:
      uint64_t result = (*(uint64_t (**)(void, void, int64_t, uint64_t))(v0[17].i64[0] + 64))( *(void *)(v0[17].i64[0] + 8),  v0->u32[2],  v1,  v2);
      *(void *)(v4 + 16) = result;
      *(void *)(v4 + 24) = result;
      return result;
    case 2:
    case 6:
LABEL_14:
      if ((_DWORD)v2 == 1) {
        goto LABEL_17;
      }
      if ((_DWORD)v2) {
        return -1LL;
      }
      int64_t v3 = v1 - v0[1].i64[0];
LABEL_17:
      if (v3 < 1) {
        return -1LL;
      }
      bzero(__dst, 0x20000uLL);
      while (v3)
      {
        if (v3 >= 0x20000) {
          CFIndex v7 = 0x20000LL;
        }
        else {
          CFIndex v7 = v3;
        }
        CFIndex v8 = _BOMFileDirectWrite(v4, (UInt8 *)__dst, v7);
        v3 -= v8;
        if (v8 < 0) {
          return -1LL;
        }
      }

      return *(void *)(v4 + 16);
    case 3:
LABEL_3:
      if ((_DWORD)v2 == 1) {
        goto LABEL_6;
      }
      if ((_DWORD)v2) {
        return -1LL;
      }
      int64_t v3 = v1 - v0[1].i64[0];
LABEL_6:
      if (v3 < 1) {
        return -1LL;
      }
      do
      {
        if (v3 < 1) {
          return *(void *)(v4 + 16);
        }
        if (v3 >= 0x20000) {
          unint64_t v5 = 0x20000LL;
        }
        else {
          unint64_t v5 = v3;
        }
        uint64_t v6 = _BOMFileDirectRead(v4, __dst, v5);
        v3 -= v6;
      }

      while (v6 > 0);
      return -1LL;
    case 4:
      uint64_t result = -1LL;
      if (v1 < 0 || (_DWORD)v2 != 1) {
        return result;
      }
      if (!**(void **)(v4 + 8)) {
        goto LABEL_31;
      }
      uint64_t v10 = 8LL;
      break;
    case 5:
      if ((_DWORD)v2 == 1) {
        goto LABEL_35;
      }
      if ((_DWORD)v2)
      {
        int64_t v3 = -1LL;
      }

      else
      {
        int64_t v3 = v1 - v0[1].i64[0];
LABEL_35:
        if ((v3 & 0x8000000000000000LL) == 0)
        {
          if (!v3) {
            return -1LL;
          }
          do
          {
            if (v3 < 1) {
              return *(void *)(v4 + 16);
            }
            if (v3 >= 0x20000) {
              size_t v12 = 0x20000LL;
            }
            else {
              size_t v12 = v3;
            }
            int64_t v13 = _BOMFileAsyncRead(v4, __dst, v12);
            v3 -= v13;
          }

          while (v13 > 0);
          return -1LL;
        }
      }

      uint64_t v14 = v0[6].i64[1];
      if (v14)
      {
        unint64_t v15 = *(void *)(v14 + 24);
        if (v15)
        {
          if (*(void *)(v14 + 8) + v3 != 0 && v15 + *(void *)(v14 + 8) + v3 >= v15)
          {
            *(void *)(v14 + 8) += v3;
            int64x2_t v16 = vaddq_s64(v0[1], vdupq_n_s64(v3));
            v0[1] = v16;
            return v16.i64[0];
          }
        }
      }

      return -1LL;
    default:
      return -1LL;
  }

  while (1)
  {
    uint64_t result = BOMFileSeek();
    if (result == -1) {
      break;
    }
    uint64_t v11 = *(void *)(*(void *)(v4 + 8) + v10);
    v10 += 8LL;
    if (!v11)
    {
LABEL_31:
      uint64_t result = *(void *)(v4 + 16) + v3;
      *(void *)(v4 + 16) = result;
      return result;
    }
  }

  return result;
}

uint64_t BOMFileOffset(uint64_t result)
{
  if (result) {
    return *(void *)(result + 16);
  }
  return result;
}

uint64_t BOMFileUncompressedOffset(uint64_t result)
{
  if (result) {
    return *(void *)(result + 24);
  }
  return result;
}

uint64_t BOMFileSetPartialRead(uint64_t result, char a2)
{
  if (result) {
    *(_BYTE *)(result + 65) = a2;
  }
  return result;
}

uint64_t BOMFileSetDataDescriptor(uint64_t result, char a2)
{
  if (result)
  {
    *(_BYTE *)(result + 66) = a2;
    *(_BYTE *)(result + 67) = 0;
  }

  return result;
}

uint64_t BOMFileSetCompression(uint64_t result, int a2, int a3, int a4)
{
  if (result)
  {
    if (*(_DWORD *)(result + 32) == (a2 == 0))
    {
      *(_DWORD *)(result + 240) = a4;
      *(_DWORD *)(result + 32) = a2 != 0;
      if (a2)
      {
        else {
          return 0LL;
        }
      }

      else if (a3)
      {
        return _BOMFileFinishGzipDecompression(result);
      }

      else
      {
        return _BOMFileFinishGzipCompression((void *)result, 0);
      }
    }

    else
    {
      return 0LL;
    }
  }

  return result;
}

uint64_t _BOMFileSetupGzip(uint64_t a1, int a2, int a3)
{
  CFIndex v7 = (z_streamp *)(a1 + 40);
  uint64_t v6 = *(z_stream **)(a1 + 40);
  if (!v6)
  {
    uint64_t v6 = (z_stream *)BOM_malloc(0x70uLL);
    *CFIndex v7 = v6;
    if (!v6) {
      return 0xFFFFFFFFLL;
    }
  }

  CFIndex v8 = *(void **)(a1 + 48);
  if (!v8)
  {
    CFIndex v8 = BOM_malloc(0x20000uLL);
    *(void *)(a1 + 48) = v8;
    uint64_t v6 = *(z_stream **)(a1 + 40);
    if (!v8)
    {
      free(*(void **)(a1 + 40));
      goto LABEL_13;
    }
  }

  v6->zalloc = 0LL;
  (*v7)->zfree = 0LL;
  (*v7)->opaque = 0LL;
  size_t v9 = *v7;
  if (a2)
  {
    *size_t v9 = 0LL;
    *(void *)(*(void *)(a1 + 40) + 24LL) = v8;
    *(_DWORD *)(*(void *)(a1 + 40) + 8LL) = 0;
    *(_DWORD *)(*(void *)(a1 + 40) + 32LL) = 0x20000;
    if (deflateInit2_(*(z_streamp *)(a1 + 40), *(_DWORD *)(a1 + 240), 8, -15, 8, 0, "1.2.12", 112))
    {
LABEL_7:
      free(*(void **)(a1 + 40));
      free(*(void **)(a1 + 48));
      v7[1] = 0LL;
LABEL_13:
      *CFIndex v7 = 0LL;
      return 0xFFFFFFFFLL;
    }
  }

  else
  {
    *size_t v9 = v8;
    size_t v10 = *(void *)(a1 + 72);
    if (v10)
    {
      uint64_t v11 = 88LL;
      if (!*(_DWORD *)(a1 + 80)) {
        uint64_t v11 = 48LL;
      }
      memcpy(**(void ***)(a1 + 40), *(const void **)(a1 + v11), v10);
      *(_DWORD *)(*(void *)(a1 + 40) + 8LL) = *(void *)(a1 + 72);
      *(void *)(a1 + 72) = 0LL;
    }

    else
    {
      (*v7)->avail_in = 0;
    }

    (*v7)->next_out = 0LL;
    (*v7)->uInt avail_out = 0;
    if (a3) {
      int v13 = 47;
    }
    else {
      int v13 = -15;
    }
    if (inflateInit2_(*v7, v13, "1.2.12", 112)) {
      goto LABEL_7;
    }
  }

  uLong v14 = crc32(0LL, 0LL, 0);
  uint64_t result = 0LL;
  *(void *)(a1 + 56) = v14;
  *(_BYTE *)(a1 + 64) = 0;
  return result;
}

uint64_t _BOMFileFinishGzipDecompression(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 40);
  uint64_t v2 = *(void **)(a1 + 48);
  size_t v4 = *(unsigned int *)(v3 + 8);
  *(void *)(a1 + 72) = v4;
  *(_DWORD *)(a1 + 80) = 0;
  memmove(v2, *(const void **)v3, v4);
  return inflateEnd(*(z_streamp *)(a1 + 40));
}

uint64_t _BOMFileFinishGzipCompression(void *a1, int a2)
{
  size_t v4 = (z_stream *)a1[5];
  uInt avail_out = v4->avail_out;
  if (avail_out) {
    goto LABEL_3;
  }
  BOOL v6 = 0;
  while (1)
  {
    CFIndex v8 = 0x20000 - avail_out;
    size_t v9 = (UInt8 *)a1[6];
    while (v8)
    {
      uint64_t v10 = _BOMFileWriteRaw((uint64_t)a1, v9, v8);
      v8 -= v10;
      v9 += v10;
      if (v10 == -1) {
        return 0xFFFFFFFFLL;
      }
    }

    v4->next_out = (Bytef *)a1[6];
    v4->uInt avail_out = 0x20000;
    if (v6) {
      break;
    }
LABEL_3:
    int v7 = deflate(v4, 4);
    if (v7)
    {
      if (v7 != 1) {
        return 0xFFFFFFFFLL;
      }
      uInt avail_out = v4->avail_out;
      BOOL v6 = 1;
    }

    else
    {
      uInt avail_out = v4->avail_out;
      BOOL v6 = avail_out != 0;
    }
  }

  if (a2)
  {
    uint64_t v12 = 0LL;
    uint64_t v13 = a1[7];
    a1[7] = v13;
    *(_DWORD *)buffer = v13;
    while (v12 != 4)
    {
      uint64_t v14 = _BOMFileWriteRaw((uint64_t)a1, buffer, 4 - v12);
      v12 += v14;
      if (v14 < 0) {
        return 0xFFFFFFFFLL;
      }
    }

    uint64_t v15 = 0LL;
    uLong total_in = v4->total_in;
    v4->uLong total_in = total_in;
    *(_DWORD *)uint64_t v18 = total_in;
    while (v15 != 4)
    {
      uint64_t v17 = _BOMFileWriteRaw((uint64_t)a1, v18, 4 - v15);
      v15 += v17;
      if (v17 < 0) {
        return 0xFFFFFFFFLL;
      }
    }
  }

  deflateEnd(v4);
  return 0LL;
}

BOOL BOMFileEndOfCompressionStream(BOOL result)
{
  if (result) {
    return *(_BYTE *)(result + 64) != 0;
  }
  return result;
}

uint64_t BOMFileSetAFSCCompression(uint64_t a1)
{
  if (*(_DWORD *)a1 != 1) {
    return 0xFFFFFFFFLL;
  }
  if (*(_DWORD *)(a1 + 32)) {
    return 0xFFFFFFFFLL;
  }
  uint64_t StreamCompressor = CreateStreamCompressor();
  if (!StreamCompressor) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v4 = StreamCompressor;
  uint64_t result = 0LL;
  *(_DWORD *)(a1 + 32) = 3;
  *(void *)(a1 + 40) = v4;
  return result;
}

uint64_t BOMFileSetKeys(uint64_t a1, _BYTE *a2)
{
  uint64_t v2 = a1 + 244;
  *(_BYTE *)(a1 + 256) = a2 != 0LL;
  if (a2) {
    init_keys(a1 + 244, a2);
  }
  return v2;
}

uint64_t BOMFileSetEncryptedRemainder(uint64_t result, int a2)
{
  if (result) {
    *(_DWORD *)(result + 260) = a2;
  }
  return result;
}

uint64_t BOMFileClearEncrypted(uint64_t result)
{
  if (result) {
    *(_BYTE *)(result + 256) = 0;
  }
  return result;
}

uint64_t BOMFileGetFileDescriptor(uint64_t a1)
{
  return *(unsigned int *)(a1 + 8);
}

uint64_t _BOMFileReadRaw(uint64_t a1, UInt8 *buffer, CFIndex bufferLength)
{
  uint64_t v6 = 0LL;
  do
  {
    if (*(_DWORD *)a1 == 3)
    {
      CFIndex v7 = CFReadStreamRead(*(CFReadStreamRef *)(a1 + 8), buffer, bufferLength);
    }

    else if (*(_DWORD *)a1)
    {
      CFIndex v7 = -1LL;
    }

    else
    {
      CFIndex v7 = (*(uint64_t (**)(void, void, UInt8 *, CFIndex))(*(void *)(a1 + 272) + 48LL))( *(void *)(*(void *)(a1 + 272) + 8LL),  *(unsigned int *)(a1 + 8),  buffer,  bufferLength);
    }

    uint64_t v8 = v7 & ~(v7 >> 63);
    v6 += v8;
    if (v7 < 1) {
      break;
    }
    if (*(_BYTE *)(a1 + 65)) {
      break;
    }
    buffer += v8;
    bufferLength -= v8;
  }

  while (bufferLength);
  *(void *)(a1 + 16) += v6;
  if (v7 < 0) {
    return -1LL;
  }
  else {
    return v6;
  }
}

uint64_t _BOMFileSetupBzip2(uint64_t a1, int a2)
{
  unint64_t v5 = (bz_stream **)(a1 + 40);
  uint64_t v4 = *(bz_stream **)(a1 + 40);
  if (!v4)
  {
    uint64_t v4 = (bz_stream *)BOM_malloc(0x50uLL);
    void *v5 = v4;
    if (!v4) {
      return 0xFFFFFFFFLL;
    }
  }

  uint64_t v6 = *(char **)(a1 + 48);
  if (!v6)
  {
    uint64_t v6 = (char *)BOM_malloc(0x20000uLL);
    *(void *)(a1 + 48) = v6;
    uint64_t v4 = *(bz_stream **)(a1 + 40);
    if (!v6)
    {
      free(*(void **)(a1 + 40));
      goto LABEL_13;
    }
  }

  v4->bzalloc = 0LL;
  (*v5)->bzfree = 0LL;
  (*v5)->opaque = 0LL;
  CFIndex v7 = *v5;
  if (a2)
  {
    v7->next_in = 0LL;
    (*v5)->next_out = v6;
    (*v5)->avail_in = 0;
    (*v5)->uInt avail_out = 0x20000;
    if (BZ2_bzCompressInit(*v5, 9, 0, 0))
    {
LABEL_7:
      free(*(void **)(a1 + 40));
      free(*(void **)(a1 + 48));
      v5[1] = 0LL;
LABEL_13:
      void *v5 = 0LL;
      return 0xFFFFFFFFLL;
    }
  }

  else
  {
    v7->next_in = v6;
    size_t v8 = *(void *)(a1 + 72);
    if (v8)
    {
      uint64_t v9 = 88LL;
      if (!*(_DWORD *)(a1 + 80)) {
        uint64_t v9 = 48LL;
      }
      memcpy(**(void ***)(a1 + 40), *(const void **)(a1 + v9), v8);
      *(_DWORD *)(*(void *)(a1 + 40) + 8LL) = *(void *)(a1 + 72);
      *(void *)(a1 + 72) = 0LL;
    }

    else
    {
      (*v5)->avail_in = 0;
    }

    (*v5)->next_out = 0LL;
    (*v5)->uInt avail_out = 0;
    if (BZ2_bzDecompressInit(*v5, 0, 0)) {
      goto LABEL_7;
    }
  }

  uLong v11 = crc32(0LL, 0LL, 0);
  uint64_t result = 0LL;
  *(void *)(a1 + 56) = v11;
  *(_BYTE *)(a1 + 64) = 0;
  return result;
}

uint64_t _BOMFileWriteRaw(uint64_t a1, UInt8 *buffer, CFIndex bufferLength)
{
  uint64_t v6 = 0LL;
  do
  {
    if (*(_DWORD *)a1 == 2)
    {
      CFIndex v7 = CFWriteStreamWrite(*(CFWriteStreamRef *)(a1 + 8), buffer, bufferLength);
    }

    else if (*(_DWORD *)a1 == 1)
    {
      CFIndex v7 = (*(uint64_t (**)(void, void, UInt8 *, CFIndex))(*(void *)(a1 + 272) + 56LL))( *(void *)(*(void *)(a1 + 272) + 8LL),  *(unsigned int *)(a1 + 8),  buffer,  bufferLength);
    }

    else
    {
      CFIndex v7 = -1LL;
    }

    uint64_t v8 = v7 & ~(v7 >> 63);
    v6 += v8;
    if (v7 < 1) {
      break;
    }
    buffer += v8;
    bufferLength -= v8;
  }

  while (bufferLength);
  *(void *)(a1 + 16) += v6;
  if (v7 < 0) {
    return -1LL;
  }
  else {
    return v6;
  }
}

void *_initBufferPool()
{
  uint64_t result = BOMBufferPoolAllocate(gBOMAsyncBufferSize, gBOMAsyncBufferCount);
  if (!result)
  {
    int64_t v1 = BOMExceptionHandlerMessage( "Unable to allocate BOM buffer pool gBOMAsyncBufferSize=%lu gBOMAsyncBufferCount=%u!\n",  gBOMAsyncBufferSize,  gBOMAsyncBufferCount);
    uint64_t v2 = __error();
    _BOMFatalException((uint64_t)v1, "/Library/Caches/com.apple.xbs/Sources/Bom/Common/BOMFile.c", 2825, *v2);
  }

  gBufferPool = (uint64_t)result;
  return result;
}

uint64_t _asyncWriteThread(uint64_t a1)
{
  uint64_t v2 = (FILE **)MEMORY[0x1895F89D0];
  if (gBOMAsyncDebug == 1) {
    fwrite("async write thread starting\n", 0x1CuLL, 1uLL, (FILE *)*MEMORY[0x1895F89D0]);
  }
  int v3 = 0;
  do
  {
    uint64_t v4 = BOMBufferFIFODequeue(*(uint64_t **)(a1 + 96));
    CFIndex v5 = BOMFileWrite(*(void *)(a1 + 8), *(UInt8 **)(v4 + 24), *(void *)(v4 + 16));
    int v6 = *(_DWORD *)(v4 + 48);
    if ((v6 & 1) != 0 && gBOMAsyncDebug == 1) {
      fwrite("async write thread asked to finish\n", 0x23uLL, 1uLL, *v2);
    }
    if (v5 == -1)
    {
      if (gBOMAsyncDebug == 1)
      {
        uint64_t v8 = *v2;
        uint64_t v9 = __error();
        fprintf(v8, "async write thread finished file (errno=%d)\n", *v9);
      }

      int v3 = *__error();
      int v7 = 1;
    }

    else
    {
      int v7 = v6 & 1;
    }

    ++*(void *)(v4 + 40);
    BOMBufferPoolReturnBuffer(gBufferPool, v4);
  }

  while (!v7);
  if (!pthread_mutex_lock((pthread_mutex_t *)(a1 + 168)))
  {
    *(_DWORD *)(a1 + 232) = 2;
    *(_DWORD *)(a1 + 236) = v3;
    if (!pthread_cond_signal((pthread_cond_t *)(a1 + 120))
      && !pthread_mutex_unlock((pthread_mutex_t *)(a1 + 168))
      && gBOMAsyncDebug == 1)
    {
      fwrite("async write thread terminating\n", 0x1FuLL, 1uLL, *v2);
    }
  }

  return 0LL;
}

uint64_t _asyncReadThread(uint64_t a1)
{
  if (gBOMAsyncDebug == 1) {
    fwrite("async read thread starting\n", 0x1BuLL, 1uLL, (FILE *)*MEMORY[0x1895F89D0]);
  }
  for (CFIndex i = BOMBufferPoolRequestBuffer(gBufferPool); ; CFIndex i = BOMBufferPoolRequestBuffer(gBufferPool))
  {
    if (pthread_mutex_lock((pthread_mutex_t *)(a1 + 168))
      || (int v3 = *(_DWORD *)(a1 + 232), pthread_mutex_unlock((pthread_mutex_t *)(a1 + 168))))
    {
      int v5 = 0;
      goto LABEL_20;
    }

    if (v3 == 1)
    {
      if (gBOMAsyncDebug == 1)
      {
        fwrite("async read thread asked to finish\n", 0x22uLL, 1uLL, (FILE *)*MEMORY[0x1895F89D0]);
LABEL_13:
        if (gBOMAsyncDebug == 1) {
          fwrite("async read thread finished file\n", 0x20uLL, 1uLL, (FILE *)*MEMORY[0x1895F89D0]);
        }
      }

      int v5 = 0;
      goto LABEL_19;
    }

    unint64_t v4 = BOMFileRead(*(int **)(a1 + 8), (char *)i[3], *i);
    if (v4 == -1LL) {
      break;
    }
    if (!v4) {
      goto LABEL_13;
    }
    i[1] = 0LL;
    i[2] = v4;
    ++i[5];
    BOMBufferFIFOEnqueue(*(void *)(a1 + 96), (uint64_t)i);
  }

  if (gBOMAsyncDebug == 1)
  {
    int v6 = (FILE *)*MEMORY[0x1895F89D0];
    int v7 = __error();
    fprintf(v6, "async read thread finished file (errno=%d)\n", *v7);
  }

  int v5 = *__error();
LABEL_19:
  i[1] = 0LL;
  i[2] = 0LL;
  ++i[5];
LABEL_20:
  if (!pthread_mutex_lock((pthread_mutex_t *)(a1 + 168)))
  {
    *(_DWORD *)(a1 + 232) = 2;
    *(_DWORD *)(a1 + 236) = v5;
    if (!pthread_cond_signal((pthread_cond_t *)(a1 + 120)) && !pthread_mutex_unlock((pthread_mutex_t *)(a1 + 168)))
    {
      if (i) {
        BOMBufferFIFOEnqueue(*(void *)(a1 + 96), (uint64_t)i);
      }
      if (gBOMAsyncDebug == 1) {
        fwrite("async read thread terminating\n", 0x1EuLL, 1uLL, (FILE *)*MEMORY[0x1895F89D0]);
      }
    }
  }

  return 0LL;
}

uint64_t decrypt_buffer(uint64_t result, int a2, int *a3)
{
  if (a2)
  {
    int v4 = a2;
    int v5 = (unsigned __int8 *)result;
    do
    {
      --v4;
      unsigned __int8 v6 = *v5 ^ decrypt_byte((uint64_t)a3);
      *v5++ = v6;
      uint64_t result = update_keys(a3, v6);
    }

    while (v4);
  }

  return result;
}

uint64_t search_for_data_descriptor(uint64_t a1, unint64_t a2, void *a3)
{
  *a3 = 0LL;
  if (a2 <= 4) {
    return 0LL;
  }
  uint64_t v3 = 0LL;
  uint64_t v4 = a1 + 1;
  while (*(_BYTE *)(a1 + v3) != 80
       || *(_BYTE *)(v4 + v3) != 75
       || *(_BYTE *)(v4 + v3 + 1) != 7
       || *(_BYTE *)(v4 + v3 + 2) != 8)
  {
    if (a2 - 4 == ++v3) {
      return 0LL;
    }
  }

  *a3 = v3;
  return 1LL;
}

uint64_t BOMExceptionHandlerSet(uint64_t result)
{
  gHandler = result;
  return result;
}

void _BOMFatalException(uint64_t a1, const char *a2, int a3, int a4)
{
  uint64_t v4 = (uint64_t (*)(uint64_t))gHandler;
  if (!gHandler) {
    uint64_t v4 = _defaultHandler;
  }
  uint64_t v5 = gMessage;
  if (a1) {
    uint64_t v5 = a1;
  }
  uint64_t v7 = v5;
  char v8 = 1;
  if (a2) {
    unsigned __int8 v6 = a2;
  }
  else {
    unsigned __int8 v6 = "";
  }
  uint64_t v9 = v6;
  int v10 = a3;
  int v11 = a4;
  v4((uint64_t)&v7);
  abort();
}

uint64_t _defaultHandler(uint64_t a1)
{
  int v2 = *(_DWORD *)(a1 + 24);
  uint64_t v3 = (FILE *)*MEMORY[0x1895F89D0];
  if (v2) {
    uint64_t result = fprintf(v3, "[%s:%u] %s\n");
  }
  else {
    uint64_t result = fprintf(v3, "%s\n");
  }
  if (*(_BYTE *)(a1 + 8)) {
    abort();
  }
  return result;
}

uint64_t _BOMExceptionHandlerCall(uint64_t a1, char a2, const char *a3, int a4, int a5)
{
  uint64_t v5 = (uint64_t (*)(uint64_t))gHandler;
  if (!gHandler) {
    uint64_t v5 = _defaultHandler;
  }
  uint64_t v6 = gMessage;
  if (a1) {
    uint64_t v6 = a1;
  }
  uint64_t v9 = v6;
  uint64_t v7 = "";
  char v10 = a2;
  if (a3) {
    uint64_t v7 = a3;
  }
  int v11 = v7;
  int v12 = a4;
  int v13 = a5;
  return v5((uint64_t)&v9);
}

char *BOMExceptionHandlerMessage(char *__format, ...)
{
  uint64_t result = (char *)gMessage;
  if (!gMessage)
  {
    uint64_t result = (char *)malloc(0x1000uLL);
    gMessage = (uint64_t)result;
    if (!result) {
      return result;
    }
    *uint64_t result = 0;
  }

  vsnprintf(result, 0x1000uLL, __format, va);
  return (char *)gMessage;
}

uint64_t BOMCRC32ForFile(const char *a1, _DWORD *a2, off_t *a3)
{
  uint64_t v3 = 1LL;
  if (a1 && a2)
  {
    if (stat(a1, &v20))
    {
      uint64_t v7 = __error();
      char v8 = strerror(*v7);
      uint64_t v9 = BOMExceptionHandlerMessage("stat: %s\n", v8);
      int v10 = *__error();
      uint64_t v11 = (uint64_t)v9;
      int v12 = 213;
LABEL_5:
      _BOMExceptionHandlerCall(v11, 0, "/Library/Caches/com.apple.xbs/Sources/Bom/Common/BOMCRC32.c", v12, v10);
      return v3;
    }

    off_t st_size = v20.st_size;
    int v15 = open(a1, 0, 0LL);
    if (v15 == -1)
    {
      uint64_t v17 = __error();
      uint64_t v18 = strerror(*v17);
      uint64_t v19 = BOMExceptionHandlerMessage("open: %s\n", v18);
      int v10 = *__error();
      uint64_t v11 = (uint64_t)v19;
      int v12 = 220;
      goto LABEL_5;
    }

    int v16 = v15;
    uint64_t v3 = posix_checksum(v15, a2, st_size);
    close(v16);
    if (a3) {
      *a3 = st_size;
    }
  }

  return v3;
}

uint64_t posix_checksum(int a1, _DWORD *a2, uint64_t a3)
{
  uint64_t v6 = malloc(0x20000uLL);
  if (v6)
  {
    uint64_t v7 = v6;
    CNCRCInit();
    if (a3)
    {
      uint64_t v8 = 0LL;
      do
      {
        else {
          size_t v9 = a3 - v8;
        }
        if (read(a1, v7, v9) != v9)
        {
          int v15 = (FILE *)*MEMORY[0x1895F89D0];
          int v16 = __error();
          uint64_t v17 = strerror(*v16);
          fprintf(v15, "Could not read: %s", v17);
          free(v7);
          return 0xFFFFFFFFLL;
        }

        CNCRCUpdate();
        v8 += v9;
      }

      while (v8 != a3);
      do
      {
        CNCRCUpdate();
        BOOL v10 = (unint64_t)a3 > 0xFF;
        a3 >>= 8;
      }

      while (v10);
    }

    CNCRCFinal();
    *a2 = 0;
    free(v7);
    CNCRCRelease();
    return 0LL;
  }

  else
  {
    int v12 = (FILE *)*MEMORY[0x1895F89D0];
    int v13 = __error();
    uint64_t v14 = strerror(*v13);
    fprintf(v12, "Could not allocate buffer: %s", v14);
    return 0xFFFFFFFFLL;
  }

uint64_t BOMCRC32ForFileDesc(int a1, _DWORD *a2, uint64_t a3)
{
  else {
    return posix_checksum(a1, a2, a3);
  }
}

uint64_t BOMCRC32ForBuffer(uint64_t a1, _DWORD *a2, unint64_t a3)
{
  if (!a3)
  {
LABEL_6:
    if (!CNCRCFinal())
    {
      CNCRCRelease();
      uint64_t v5 = 0LL;
      *a2 = 0;
      return v5;
    }

    return 1LL;
  }

  while (1)
  {
    uint64_t v5 = 1LL;
    BOOL v6 = a3 >= 0x100;
    a3 >>= 8;
    if (!v6) {
      goto LABEL_6;
    }
  }

uint64_t BOMCRC32ForBufferSegment(unsigned __int8 *a1, unsigned int *a2, uint64_t a3)
{
  uint64_t v3 = 1LL;
  if (a1 && a2)
  {
    for (unsigned int i = *a2; a3; --a3)
    {
      int v5 = *a1++;
      unsigned int i = crctab[v5 ^ HIBYTE(i)] ^ (i << 8);
    }

    uint64_t v3 = 0LL;
    *a2 = i;
  }

  return v3;
}

uint64_t BOMCRC32ForBufferSegmentFinal( unsigned __int8 *a1, unsigned int *a2, uint64_t a3, unint64_t a4)
{
  if (a1) {
    BOOL v4 = 1;
  }
  else {
    BOOL v4 = a3 == 0;
  }
  int v5 = v4;
  uint64_t v6 = 1LL;
  if (a2 && v5)
  {
    for (unsigned int i = *a2; a3; --a3)
    {
      int v8 = *a1++;
      unsigned int i = crctab[v8 ^ HIBYTE(i)] ^ (i << 8);
    }

    if (a4)
    {
      do
      {
        unsigned int i = crctab[a4 ^ (unint64_t)HIBYTE(i)] ^ (i << 8);
        BOOL v9 = a4 > 0xFF;
        a4 >>= 8;
      }

      while (v9);
    }

    uint64_t v6 = 0LL;
    *a2 = ~i;
  }

  return v6;
}

_DWORD *_BOMBomGetFSObjectWithBlockID(uint64_t a1, unsigned int a2)
{
  uint64_t v4 = BOMStreamWithBlockID(*(void *)(a1 + 8), a2, 0LL, 0);
  if (v4)
  {
    uint64_t v5 = v4;
    uint64_t v6 = BOMFSObjectUnarchive(v4);
    BOMStreamFree(v5);
  }

  else
  {
    uint64_t v6 = 0LL;
  }

  uint64_t v7 = *(void *)(a1 + 40);
  if (v7)
  {
    unsigned int v12 = bswap32(a2);
    uint64_t v11 = 0LL;
    else {
      BOOL v8 = v11 == 8;
    }
    if (v8 && BOMTreeGetValue(*(void *)(a1 + 40), &v12, 4uLL))
    {
      __memcpy_chk();
      BOMFSObjectSetSize((uint64_t)v6, bswap64(v10));
    }
  }

  return v6;
}

uint64_t BOMBomPathsTree(uint64_t result)
{
  if (result) {
    return *(void *)(result + 16);
  }
  return result;
}

char *BOMBomOpen(char *a1, int a2)
{
  return BOMBomOpenWithSys(a1, a2, 0LL);
}

char *BOMBomOpenWithSys(char *a1, int a2, void *a3)
{
  uint64_t v3 = a3;
  if (!a3) {
    uint64_t v3 = BomSys_default();
  }
  if (a1)
  {
    if (a2) {
      uint64_t v6 = 6LL;
    }
    else {
      uint64_t v6 = 4LL;
    }
    if (!(*((unsigned int (**)(void, char *, uint64_t))v3 + 23))(*((void *)v3 + 1), a1, v6))
    {
      uint64_t v8 = BOMStorageOpenWithSys(a1, a2, v3);
      if (v8)
      {
        BOOL v9 = (_DWORD *)v8;
        unsigned int NamedBlock = BOMStorageGetNamedBlock(v8, "BomInfo");
        if (NamedBlock)
        {
          unsigned int v11 = NamedBlock;
          a1 = (char *)BOM_malloczero(0x48uLL);
          if (!a1)
          {
            BOMStorageFree(v9);
            return a1;
          }

          uint64_t v12 = BOMStreamWithBlockID((uint64_t)v9, v11, 0LL, 0);
          if (!v12
            || (uint64_t v13 = v12,
                BOMStreamReadUInt32(v12),
                int UInt32 = BOMStreamReadUInt32(v13),
                int ArchInfo = _readArchInfo((uint64_t)a1, v13),
                int v16 = BOMStreamFree(v13),
                ArchInfo)
            || v16)
          {
            BOMStorageFree(v9);
            free(a1);
          }

          else
          {
            *(_DWORD *)a1 = UInt32;
            *((void *)a1 + 1) = v9;
            *((void *)a1 + 2) = BOMTreeOpenWithName((uint64_t)v9, "Paths", a2);
            *((void *)a1 + 3) = BOMBomHLIndexOpen((uint64_t)v9, a2);
            uint64_t v17 = BOMBomVIndexOpen((uint64_t)v9, a2);
            *((void *)a1 + 4) = v17;
            if (*((void *)a1 + 2))
            {
              if (*((void *)a1 + 3))
              {
                if (v17)
                {
                  uint64_t v18 = BOMTreeOpenWithName((uint64_t)v9, "Size64", a2);
                  *((void *)a1 + 5) = v18;
                  if (a2 != 1
                    || v18
                    || (uint64_t v19 = BOMTreeNewWithName((uint64_t)v9, "Size64"), (*((void *)a1 + 5) = v19) != 0LL))
                  {
                    a1[65] = a2;
                    return a1;
                  }
                }
              }
            }

            BOMBomFree((uint64_t)a1);
          }
        }

        else
        {
          fprintf((FILE *)*MEMORY[0x1895F89D0], "file %s is not a bom file\n", a1);
        }
      }
    }

    return 0LL;
  }

  return a1;
}

uint64_t _readArchInfo(uint64_t a1, uint64_t a2)
{
  uint64_t result = BOMStreamReadUInt32(a2);
  *(_DWORD *)(a1 + 48) = result;
  if ((_DWORD)result)
  {
    uint64_t v5 = BOM_malloczero(24LL * result);
    *(void *)(a1 + 56) = v5;
    if (v5)
    {
      if (*(_DWORD *)(a1 + 48))
      {
        uint64_t v6 = 0LL;
        unint64_t v7 = 0LL;
        do
        {
          *(_DWORD *)(*(void *)(a1 + 56) + v6) = BOMStreamReadUInt32(a2);
          *(_DWORD *)(*(void *)(a1 + 56) + v6 + 4) = BOMStreamReadUInt32(a2);
          *(void *)(*(void *)(a1 + 56) + v6 + 8) = BOMStreamReadUInt32(a2);
          *(_DWORD *)(*(void *)(a1 + 56) + v6 + 16) = BOMStreamReadUInt32(a2);
          ++v7;
          v6 += 24LL;
        }

        while (v7 < *(unsigned int *)(a1 + 48));
      }

      return 0LL;
    }

    else
    {
      return 1LL;
    }
  }

  return result;
}

uint64_t BOMBomFree(uint64_t a1)
{
  if (!a1) {
    return 1LL;
  }
  uint64_t v3 = *(void *)(a1 + 16);
  if (v3)
  {
    BOMTreeFree(v3);
    *(void *)(a1 + 16) = 0LL;
  }

  uint64_t v4 = *(void *)(a1 + 24);
  if (v4)
  {
    BOMBomHLIndexFree(v4);
    *(void *)(a1 + 24) = 0LL;
  }

  uint64_t v5 = *(_BYTE **)(a1 + 32);
  if (v5)
  {
    BOMBomVIndexFree(v5);
    *(void *)(a1 + 32) = 0LL;
  }

  uint64_t v6 = *(void *)(a1 + 40);
  if (v6)
  {
    BOMTreeFree(v6);
    *(void *)(a1 + 40) = 0LL;
  }

  unint64_t v7 = *(_DWORD **)(a1 + 8);
  if (v7)
  {
    uint64_t result = BOMStorageFree(v7);
    if ((_DWORD)result) {
      return result;
    }
    *(void *)(a1 + 8) = 0LL;
  }

  free(*(void **)(a1 + 56));
  free((void *)a1);
  return 0LL;
}

_DWORD *BOMBomOpenWithStorage(_DWORD *a1, int a2)
{
  unsigned int NamedBlock = BOMStorageGetNamedBlock(a1, "BomInfo");
  if (NamedBlock)
  {
    unsigned int v5 = NamedBlock;
    uint64_t v6 = BOM_malloczero(0x48uLL);
    if (!v6)
    {
      BOMStorageFree(a1);
      return v6;
    }

    uint64_t v7 = BOMStreamWithBlockID((uint64_t)a1, v5, 0LL, 0);
    if (!v7
      || (uint64_t v8 = v7,
          BOMStreamReadUInt32(v7),
          int UInt32 = BOMStreamReadUInt32(v8),
          int ArchInfo = _readArchInfo((uint64_t)v6, v8),
          int v11 = BOMStreamFree(v8),
          ArchInfo)
      || v11)
    {
      BOMStorageFree(a1);
      free(v6);
    }

    else
    {
      _DWORD *v6 = UInt32;
      *((void *)v6 + 1) = a1;
      *((void *)v6 + 2) = BOMTreeOpenWithName((uint64_t)a1, "Paths", a2);
      *((void *)v6 + 3) = BOMBomHLIndexOpen((uint64_t)a1, a2);
      uint64_t v13 = BOMBomVIndexOpen((uint64_t)a1, a2);
      *((void *)v6 + 4) = v13;
      if (*((void *)v6 + 2))
      {
        if (*((void *)v6 + 3))
        {
          if (v13)
          {
            uint64_t v14 = BOMTreeOpenWithName((uint64_t)a1, "Size64", a2);
            *((void *)v6 + 5) = v14;
            if (a2 != 1 || v14 || (int v15 = BOMTreeNewWithName((uint64_t)a1, "Size64"), (*((void *)v6 + 5) = v15) != 0LL))
            {
              *((_BYTE *)v6 + 65) = a2;
              return v6;
            }
          }
        }
      }

      BOMBomFree((uint64_t)v6);
    }
  }

  else
  {
    fprintf((FILE *)*MEMORY[0x1895F89D0], "file %s is not a bom file\n", "<storage>");
  }

  return 0LL;
}

void *BOMBomNewWithStorage(_DWORD *a1)
{
  if (a1)
  {
    int64_t v1 = a1;
    int v2 = BOM_malloczero(0x48uLL);
    if (!v2) {
      return v2;
    }
  }

  else
  {
    uint64_t v3 = BOMStorageNewInRAM();
    if (!v3) {
      return 0LL;
    }
    int64_t v1 = (_DWORD *)v3;
    int v2 = BOM_malloczero(0x48uLL);
    if (!v2)
    {
      BOMStorageFree(v1);
      return v2;
    }
  }

  *(_DWORD *)int v2 = 1;
  v2[1] = v1;
  unsigned int v4 = BOMStorageNewNamedBlock((uint64_t)v1, "BomInfo");
  if (!v4) {
    goto LABEL_13;
  }
  uint64_t v5 = BOMStreamWithBlockID(v2[1], v4, (16LL * *((unsigned int *)v2 + 12)) | 0xC, 1);
  if (!v5) {
    goto LABEL_13;
  }
  uint64_t v6 = v5;
  BOMStreamWriteUInt32(v5, 1u);
  BOMStreamWriteUInt32(v6, *(_DWORD *)v2);
  _writeArchInfo((uint64_t)v2, v6);
  BOMStreamFree(v6);
  v2[2] = BOMTreeNewWithName((uint64_t)v1, "Paths");
  v2[3] = BOMBomHLIndexNew((uint64_t)v1);
  uint64_t v7 = BOMBomVIndexNew((uint64_t)v1);
  v2[4] = v7;
  if (!v2[2] || !v2[3] || !v7 || (uint64_t v8 = BOMTreeNewWithName((uint64_t)v1, "Size64"), (v2[5] = v8) == 0LL))
  {
LABEL_13:
    BOMBomFree((uint64_t)v2);
    return 0LL;
  }

  *((_WORD *)v2 + 32) = 257;
  return v2;
}

uint64_t _writeArchInfo(uint64_t a1, uint64_t a2)
{
  uint64_t result = BOMStreamWriteUInt32(a2, *(_DWORD *)(a1 + 48));
  if (*(_DWORD *)(a1 + 48))
  {
    uint64_t v5 = 0LL;
    unint64_t v6 = 0LL;
    do
    {
      BOMStreamWriteUInt32(a2, *(_DWORD *)(*(void *)(a1 + 56) + v5));
      BOMStreamWriteUInt32(a2, *(_DWORD *)(*(void *)(a1 + 56) + v5 + 4));
      BOMStreamWriteUInt32(a2, *(_DWORD *)(*(void *)(a1 + 56) + v5 + 8));
      uint64_t result = BOMStreamWriteUInt32(a2, *(_DWORD *)(*(void *)(a1 + 56) + v5 + 16));
      ++v6;
      v5 += 24LL;
    }

    while (v6 < *(unsigned int *)(a1 + 48));
  }

  return result;
}

void *BOMBomNew(const char *a1)
{
  return BOMBomNewWithSys(a1, 0LL);
}

void *BOMBomNewWithSys(const char *a1, uint64_t (**a2)(void, const char *, uint64_t, uint64_t))
{
  int v2 = a2;
  if (!a2)
  {
    int v2 = (uint64_t (**)(void, const char *, uint64_t, uint64_t))BomSys_default();
    if (a1) {
      goto LABEL_3;
    }
LABEL_7:
    unsigned int v4 = 0LL;
    return BOMBomNewWithStorage(v4);
  }

  if (!a1) {
    goto LABEL_7;
  }
LABEL_3:
  if (((unsigned int (*)(uint64_t (*)(void, const char *, uint64_t, uint64_t), const char *, uint64_t))v2[23])( v2[1],  a1,  6LL)
    || !((unsigned int (*)(uint64_t (*)(void, const char *, uint64_t, uint64_t), const char *))v2[28])( v2[1],  a1))
  {
    unsigned int v4 = (_DWORD *)BOMStorageNewWithSys(a1, v2);
    if (!v4) {
      return 0LL;
    }
    return BOMBomNewWithStorage(v4);
  }

  fprintf((FILE *)*MEMORY[0x1895F89D0], "can't unlink %s\n", a1);
  return 0LL;
}

BOOL BOMBomFSObjectExistsAtPath(uint64_t a1, uint64_t a2)
{
  BOOL result = 0LL;
  if (a1)
  {
    if (a2) {
      return _valueAtPath(a1) != 0LL;
    }
  }

  return result;
}

unsigned int *_valueAtPath(uint64_t a1)
{
  uint64_t v12 = *MEMORY[0x1895F89C0];
  __stringp = &v11;
  __strlcpy_chk();
  int v2 = strsep(&__stringp, "/");
  if (v2)
  {
    uint64_t v3 = v2;
    unsigned int v4 = 0;
    while (1)
    {
      uint64_t v5 = BOMNewPathKey(v4, v3, &v9);
      if (!v5) {
        break;
      }
      unint64_t v6 = v5;
      Value = (unsigned int *)BOMTreeGetValue(*(void *)(a1 + 16), v5, v9);
      free(v6);
      if (Value)
      {
        unsigned int v4 = BOMPathIDFromPathKey(Value);
        uint64_t v3 = strsep(&__stringp, "/");
        if (v3) {
          continue;
        }
      }

      return Value;
    }
  }

  return 0LL;
}

uint64_t BOMBomNewFromBom(const char *a1, uint64_t a2)
{
  uint64_t v41 = *MEMORY[0x1895F89C0];
  Sys = (uint64_t (**)(void, const char *, uint64_t, uint64_t))BOMStorageGetSys(*(void *)(a2 + 8));
  uint64_t v5 = BOMBomNewWithSys(a1, Sys);
  uint64_t v6 = (uint64_t)v5;
  if (!a2 || !v5) {
    goto LABEL_43;
  }
  BOMTreeSetDensePacking(v5[2], 1);
  uint64_t v7 = (const void **)BOMHardLinkTableNew();
  if (!v7) {
    goto LABEL_44;
  }
  uint64_t v8 = v7;
  size_t v9 = (char *)BOMTreeIteratorNew(*(void *)(a2 + 16), 0LL, 0LL, 0LL);
  if (!v9)
  {
    BOMHardLinkTableFree(v8);
    goto LABEL_44;
  }

  unint64_t v10 = v9;
  if (BOMTreeIteratorIsAtEnd((uint64_t)v9))
  {
    BOMHardLinkTableFree(v8);
    BOMTreeIteratorFree(v10);
    goto LABEL_37;
  }

  size_t v11 = 0LL;
  uint64_t v12 = 0LL;
  while (1)
  {
    uint64_t v13 = (unsigned int *)BOMTreeIteratorValue((uint64_t)v10);
    unsigned int v14 = BOMBlockIDFromPathValue((uint64_t)v13);
    unsigned int v15 = BOMPathIDFromPathKey(v13);
    int v16 = BOMHardLinkTableGet((CFDictionaryRef *)v8, 0, v14);
    if (v16)
    {
      *(_DWORD *)bytes = *(_DWORD *)v16;
      goto LABEL_22;
    }

    size_t v17 = BOMStorageSizeOfBlock(*(void *)(a2 + 8), v14);
    if (v17 > v11)
    {
      if (v12) {
        free(v12);
      }
      uint64_t v12 = BOM_malloc(v17);
      size_t v11 = v17;
    }

    if (BOMStorageCopyFromBlock(*(void *)(a2 + 8), v14, v12))
    {
      v35 = BOMExceptionHandlerMessage( "_copyFilesFromBomToBomInOrder failed while getting data (pid=%u bid=%u)",  v15,  v14);
      v36 = __error();
      _BOMFatalException((uint64_t)v35, "/Library/Caches/com.apple.xbs/Sources/Bom/Bom/BOMBom.c", 985, *v36);
    }

    uint64_t v18 = BOMStorageNewBlock(*(void *)(v6 + 8));
    *(_DWORD *)bytes = v18;
    unsigned int v19 = BOMBomHLIndexCount(*(void *)(a2 + 24), v14);
    if (v19 >= 2)
    {
      unsigned int v20 = v19;
      BOMHardLinkTableSet((CFDictionaryRef *)v8, 0, v14, bytes, 4LL);
      unsigned int v21 = 0;
      while (1)
      {
        if (BOMBomHLIndexGet(*(void *)(a2 + 24), v14, v21, v40, &v37))
        {
          v27 = (FILE *)*MEMORY[0x1895F89D0];
          size_t v28 = "can't get hardlink data\n";
          size_t v29 = 24LL;
          goto LABEL_33;
        }

        if (v20 == ++v21) {
          goto LABEL_22;
        }
      }

      v27 = (FILE *)*MEMORY[0x1895F89D0];
      size_t v28 = "can't set hardlink index\n";
      goto LABEL_32;
    }

LABEL_22:
    int v22 = BOMNewPathValue(v15, *(unsigned int *)bytes, &v38);
    uint64_t v23 = *(void **)(v6 + 16);
    uint64_t v24 = (const void *)BOMTreeIteratorKey((uint64_t)v10);
    size_t v25 = BOMTreeIteratorKeySize((uint64_t)v10);
    if (BOMTreeSetValue(v23, v24, v25, (uint64_t)v22, v38))
    {
      if (v22) {
        free(v22);
      }
      v27 = (FILE *)*MEMORY[0x1895F89D0];
      size_t v28 = "can't set new path value\n";
LABEL_32:
      size_t v29 = 25LL;
      goto LABEL_33;
    }

    if (v22) {
      free(v22);
    }
    BOMTreeIteratorNext((uint64_t)v10);
    if (BOMTreeIteratorIsAtEnd((uint64_t)v10))
    {
      int v26 = 1;
      goto LABEL_34;
    }
  }

  v27 = (FILE *)*MEMORY[0x1895F89D0];
  size_t v28 = "can't set file data\n";
  size_t v29 = 20LL;
LABEL_33:
  fwrite(v28, v29, 1uLL, v27);
  int v26 = 0;
LABEL_34:
  if (v12) {
    free(v12);
  }
  BOMHardLinkTableFree(v8);
  BOMTreeIteratorFree(v10);
  if (!v26)
  {
LABEL_43:
    if (!v6) {
      return v6;
    }
LABEL_44:
    BOMBomFree(v6);
    return 0LL;
  }

  *v4 |= 0x20uLL;
  if ((v3 & 0x40) == 0)
  {
LABEL_9:
    if ((v3 & 0x80) == 0) {
      goto LABEL_10;
    }
    goto LABEL_24;
  }

  *((_BYTE *)v10 + 396) = a2;
  if ((a3 & 0x800) != 0) {
    goto LABEL_23;
  }
LABEL_13:
  if ((a3 & 0x4000) != 0)
  {
LABEL_14:
    *((_BYTE *)v10 + 401) = a2;
    *(_DWORD *)((char *)v10 + 397) = 16843009 * a2;
  }

  return v10;
}

uint64_t BOMBomNewFromPath(char *a1, char *a2)
{
  return BOMBomNewFromPathWithSys(a1, a2, 0LL);
}

uint64_t BOMBomNewFromPathWithSys( char *__s1, char *__s2, unsigned int (**a3)(void, char *, int *))
{
  if (!__s2 || __s1 && !strcmp(__s1, __s2)) {
    return 0LL;
  }
  if (a3)
  {
    if (!__s1) {
      goto LABEL_10;
    }
  }

  else
  {
    a3 = (unsigned int (**)(void, char *, int *))BomSys_default();
    if (!__s1) {
      goto LABEL_10;
    }
  }

  if (a3[12](a3[1], __s1, &v15))
  {
    if (*__error() == 2) {
      goto LABEL_10;
    }
    unint64_t v10 = (FILE *)*MEMORY[0x1895F89D0];
    size_t v11 = __error();
    strerror(*v11);
    fprintf(v10, "can't stat %s: %s\n");
    return 0LL;
  }

  if (a3[12](a3[1], __s2, &v13))
  {
    uint64_t v8 = (FILE *)*MEMORY[0x1895F89D0];
    size_t v9 = __error();
    strerror(*v9);
    fprintf(v8, "can't stat %s: %s\n");
    return 0LL;
  }

  if (v15 == v13 && v16 == v14)
  {
    fprintf((FILE *)*MEMORY[0x1895F89D0], "%s and %s are identical.\n");
    return 0LL;
  }

LABEL_10:
  uint64_t v6 = BOMBomOpenWithSys(__s2, 0, a3);
  uint64_t v7 = BOMBomNewFromBom(__s1, (uint64_t)v6);
  if (v6) {
    BOMBomFree((uint64_t)v6);
  }
  return v7;
}

  size_t v11 = *(void *)(a1 + 8);
  if (v11) {
    BOMTreeFree(v11);
  }
  free((void *)a1);
  return 0LL;
}

  int v22 = v56;
  if (v56)
  {
    uint64_t v23 = *(void **)v56;
    if (*(void *)v56)
    {
      uint64_t v24 = 0LL;
      do
      {
        free(v23);
        *(void *)((char *)v56 + v24) = 0LL;
        int v22 = v56;
        uint64_t v23 = *(void **)((char *)v56 + v24 + 8);
        v24 += 8LL;
      }

      while (v23);
    }

    free(v22);
  }

  size_t v25 = *(char **)(a1 + 12904);
  if (v25)
  {
    int v26 = BOMBomOpenWithSys(v25, 0, *(void **)(a1 + 12832));
    *(void *)(a1 + 160) = v26;
    if (!v26)
    {
      v33 = *(void *)(a1 + 12904);
      goto LABEL_27;
    }
  }

  if (*(void *)(a1 + 12920))
  {
    if (_mkdirs_parent(a1))
    {
      BOMCopierNotifyFatalError( a1,  "Cannot create parent directory for %s",  v27,  v28,  v29,  v30,  v31,  v32,  *(void *)(a1 + 12920));
      return 1LL;
    }

    if (BOMFileOpenWithSys( &v55,  *(void *)(a1 + 12920),  1545LL,  420LL,  0,  *(void (***)(void, uint64_t, uint64_t, uint64_t))(a1 + 12832)))
    {
      size_t v37 = *(void *)(a1 + 12920);
      uint64_t v38 = __error();
      strerror(*v38);
      BOMCopierNotifyFatalError(a1, "Cannot open file %s for writing: %s", v39, v40, v41, v42, v43, v44, v37);
      return 1LL;
    }

    *(void *)(a1 + 176) = v55;
  }

  v45 = *(const char **)(a1 + 12928);
  if (v45)
  {
    v46 = BOMPatternCompileString(v45);
    *(void *)(a1 + 184) = v46;
    if (!v46)
    {
      BOMCopierNotifyFatalError( a1,  "Cannot compile %s as a regular expression pattern",  v47,  v48,  v49,  v50,  v51,  v52,  *(void *)(a1 + 12928));
      return 1LL;
    }
  }

  v53 = geteuid();
  *(_DWORD *)(a1 + 10496) = v53;
  if (*(_BYTE *)(a1 + 195) && (*(_DWORD *)(a1 + 12716) != 3 || !*(_BYTE *)(a1 + 170) && !*(_BYTE *)(a1 + 169))) {
    *(_BYTE *)(a1 + 195) = 0;
  }
  while (!BOMStackIsEmpty(*(void *)(a1 + 40)))
    BOMStackPop(*(uint64_t **)(a1 + 40));
  return 0LL;
}

  *a5 = 0;
  return 0LL;
}

  *unsigned int v4 = a2;
}

unsigned int *BOMBomNewFromBomWithStripping(const char *a1, uint64_t *a2, const char **a3, const char **a4)
{
  return BOMBomNewFromBomWithOptions(a1, a2, 3, a3, a4);
}

unsigned int *BOMBomNewFromBomWithOptions( const char *a1, uint64_t *a2, char a3, const char **a4, const char **a5)
{
  uint64_t v81 = *MEMORY[0x1895F89C0];
  if (!a2) {
    return 0LL;
  }
  uint64_t Sys = BOMStorageGetSys(a2[1]);
  uint64_t v11 = Sys;
  if (a1
    && !(*(unsigned int (**)(void, const char *, uint64_t))(Sys + 184))(*(void *)(Sys + 8), a1, 6LL)
    && (*(unsigned int (**)(void, const char *))(v11 + 224))(*(void *)(v11 + 8), a1))
  {
    fprintf((FILE *)*MEMORY[0x1895F89D0], "can't unlink %s\n", a1);
    return 0LL;
  }

  uint64_t v12 = (unsigned int *)BOMBomNewWithSys(a1, (uint64_t (**)(void, const char *, uint64_t, uint64_t))v11);
  if (v12)
  {
    __s[0] = 0;
    size_t v13 = strlen(__s);
    _copyFilesFromBomToBom(a2, v12, 0LL, __s, &__s[v13], 0, 0, 0LL, 1);
    _copyVariantsFromBomToBom((uint64_t)a2, (uint64_t)v12, v14, v15, v16, v17, v18, v19);
    if ((a3 & 1) != 0)
    {
      unsigned int v20 = _patternListForArchAndLangs((uint64_t)a2, a4, a5, 1);
      unsigned int v21 = v20;
      if (v20)
      {
        if (CFArrayGetCount(v20))
        {
          RootFSObject = (unsigned int *)BOMBomGetRootFSObject((uint64_t)v12);
          uint64_t v23 = BOMBomEnumeratorNew((uint64_t)v12, RootFSObject);
          BOMFSObjectFree((uint64_t)RootFSObject);
          if (v23)
          {
            v78 = a5;
            char v79 = a3;
            CFIndex Count = CFArrayGetCount(v21);
            size_t v25 = BOMBomEnumeratorNext((uint64_t)v23);
            if (v25)
            {
              int v26 = v25;
              BOOL v27 = 0;
              while (1)
              {
                uint64_t v28 = BOMFSObjectPathName((uint64_t)v26);
                if (Count >= 1) {
                  break;
                }
LABEL_16:
                if (v27) {
                  goto LABEL_17;
                }
LABEL_18:
                BOMFSObjectFree((uint64_t)v26);
                int v26 = BOMBomEnumeratorNext((uint64_t)v23);
                if (!v26) {
                  goto LABEL_19;
                }
              }

              size_t v29 = (const char *)v28;
              CFIndex v30 = 0LL;
              while (1)
              {
                ValueAtIndex = (regex_t *)CFArrayGetValueAtIndex(v21, v30);
                if (ValueAtIndex)
                {
                  BOOL v27 = BOMPatternMatch(ValueAtIndex, v29);
                  if (v27) {
                    break;
                  }
                }

                if (Count == ++v30) {
                  goto LABEL_16;
                }
              }

LABEL_19:
            BOMBomEnumeratorFree(v23);
            a3 = v79;
            a5 = v78;
          }
        }
      }

      BOMPatternListFree(v21);
      __s[0] = 0;
      size_t v32 = _patternListForArchAndLangs((uint64_t)a2, a4, a5, 0);
      size_t v33 = strlen(__s);
      _copyFilesFromBomToBom(a2, v12, v32, __s, &__s[v33], 0, 0, 0LL, 1);
      BOMPatternListFree(v32);
    }

    if ((a3 & 2) != 0 && a4 && *a4)
    {
      uint64_t v34 = 0LL;
      while (a4[++v34])
        ;
      uint64_t v36 = v34;
      size_t v37 = BOM_malloczero(32LL * v34);
      uint64_t v38 = (char *)v37;
      if ((_DWORD)v34)
      {
        v39 = v37 + 2;
        while (1)
        {
          v40 = *a4;
          uint64_t v41 = BOMGetArchInfoFromName((char *)*a4);
          if (!v41) {
            break;
          }
          int v42 = *((_DWORD *)v41 + 3);
          v43 = BOMGetArchInfoFromCpuType(*((_DWORD *)v41 + 2), -1);
          if (!v43) {
            break;
          }
          int v45 = *((_DWORD *)v43 + 2);
          int v44 = *((_DWORD *)v43 + 3);
          int v46 = 16777228;
          BOOL v47 = v45 == 16777228 && v42 == 0;
          if (v47)
          {
            char v48 = 0;
          }

          else
          {
            int v46 = *((_DWORD *)v43 + 2);
            char v48 = 1;
          }

          if (v47) {
            int v49 = 0;
          }
          else {
            int v49 = -1;
          }
          if (v45 == 16777223 && v42 == 3)
          {
            int v46 = 16777223;
            char v48 = 0;
            int v49 = 3;
          }

          BOOL v51 = v42 == v44;
          if (v42 == v44) {
            int v52 = v46;
          }
          else {
            int v52 = *((_DWORD *)v43 + 2);
          }
          if (v51) {
            char v53 = v48;
          }
          else {
            char v53 = 0;
          }
          if (v51) {
            int v54 = v49;
          }
          else {
            int v54 = v42;
          }
          *(v39 - 2) = v52;
          *((_BYTE *)v39 - 4) = v53;
          int *v39 = v54;
          v39 += 8;
          ++a4;
          if (!--v36) {
            goto LABEL_54;
          }
        }

        fprintf((FILE *)*MEMORY[0x1895F89D0], "can't get arch info for '%s'", v40);
      }

      else
      {
LABEL_54:
        v55 = (unsigned int *)BOMBomGetRootFSObject((uint64_t)v12);
        v56 = BOMBomEnumeratorNew((uint64_t)v12, v55);
        BOMFSObjectFree((uint64_t)v55);
        if (v56)
        {
          v57 = BOMBomEnumeratorNext((uint64_t)v56);
          if (v57)
          {
            v58 = v57;
            do
            {
              if (BOMFSObjectType(v58) == 1 && BOMFSObjectIsBinaryObject((uint64_t)v58))
              {
                int v59 = BOMFSObjectArchCount((uint64_t)v58);
                if (v59)
                {
                  int v60 = v59;
                  unsigned int v61 = 0;
                  while (1)
                  {
                    int Arch = BOMFSObjectGetArch((uint64_t)v58, v61);
                    int ArchSubtype = BOMFSObjectGetArchSubtype((uint64_t)v58, v61);
                    if ((_DWORD)v34) {
                      break;
                    }
LABEL_67:
                    if (++v61 == v60) {
                      goto LABEL_68;
                    }
                  }

                  uint64_t v64 = 0LL;
                  while (Arch != *(_DWORD *)&v38[v64]
                       || !v38[v64 + 4] && ((*(_DWORD *)&v38[v64 + 8] ^ ArchSubtype) & 0xFFFFFF) != 0)
                  {
                    v64 += 32LL;
                  }

                  if (!BOMFSObjectThinKeepingArchsAndSubArchs((uint64_t)v58, (uint64_t)v38, v34))
                  {
                    unsigned int v65 = BOMFSObjectBlockID((uint64_t)v58);
                  }
                }

                else
                {
LABEL_68:
                  BOMBomRemoveFSObject((unint64_t)v12, v58);
                }
              }

              BOMFSObjectFree((uint64_t)v58);
              v58 = BOMBomEnumeratorNext((uint64_t)v56);
            }

            while (v58);
          }

          BOMBomEnumeratorFree(v56);
          if (*((_BYTE *)v12 + 64))
          {
            uint64_t v66 = v12[12];
            v67 = (void *)*((void *)v12 + 7);
            v68 = BOM_malloczero(24LL * (v66 + 1));
            *((void *)v12 + 7) = v68;
            uint64_t v69 = v67[2];
            *(_OWORD *)v68 = *(_OWORD *)v67;
            v68[2] = v69;
            if (v66 < 2)
            {
              unsigned int v71 = 1;
            }

            else
            {
              uint64_t v70 = 1LL;
              unsigned int v71 = 1;
              do
              {
                if ((_DWORD)v34)
                {
                  v72 = (char *)&v67[3 * v70];
                  uint64_t v73 = v34;
                  v74 = v38 + 8;
                  while (*(_DWORD *)v72 != *(v74 - 2)
                       || !*((_BYTE *)v74 - 4) && ((*v74 ^ *((_DWORD *)v72 + 1)) & 0xFFFFFF) != 0)
                  {
                    v74 += 8;
                    if (!--v73) {
                      goto LABEL_84;
                    }
                  }

                  uint64_t v75 = *((void *)v12 + 7) + 24LL * v71++;
                  __int128 v76 = *(_OWORD *)v72;
                  *(void *)(v75 + 16) = *((void *)v72 + 2);
                  *(_OWORD *)uint64_t v75 = v76;
                }

      uint64_t v19 = *(void *)(a1 + 112);
      if (v19)
      {
        unsigned int v20 = *(char **)(a1 + 104);
      }

      else
      {
        if (*(void *)(a1 + 88) >= *(void *)(a1 + 56) - *(void *)(a1 + 72)) {
          v35 = *(void *)(a1 + 56) - *(void *)(a1 + 72);
        }
        else {
          v35 = *(void *)(a1 + 88);
        }
        data = data_archive_decoder_read_data(*(void *)(a1 + 40), *(void **)(a1 + 96), v35, 0LL, a5, a6, a7, a8);
        if (!data)
        {
          size_t v13 = "decompress_data";
          uint64_t v14 = "End of decoder";
          uint64_t v15 = a4;
          uint64_t v16 = 1082;
          goto LABEL_9;
        }

        uint64_t v19 = data;
        if (data == -1LL && *__error() != 35)
        {
          capture_error( a4,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive.c",  1075,  (uint64_t)"decompress_data",  "Could not read %ld bytes from decoder",  v37,  v38,  v39,  v35);
          return -1LL;
        }

        unsigned int v20 = *(char **)(a1 + 96);
        *(void *)(a1 + 104) = v20;
        *(void *)(a1 + 112) = v19;
        *(void *)(a1 + 72) += v19;
      }

      v40 = 0;
      uint64_t v41 = 0LL;
      int v42 = *(z_stream **)(a1 + 120);
      do
      {
        v42->next_in = (Bytef *)&v20[v41];
        v42->avail_in = v19 - v41;
        v42->next_out = (Bytef *)a2;
        v42->uInt avail_out = a3;
        v43 = inflate(v42, 0);
        if (v43)
        {
          if (v43 != 1)
          {
            capture_error( a4,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive.c",  1134,  (uint64_t)"decompress_data",  "Could not inflate: %d",  v45,  v46,  v47,  v43);
            return -1LL;
          }

          v40 = 1;
          *(_BYTE *)(a1 + 80) = 1;
        }

        char v48 = *(void *)(a1 + 112);
        int v42 = *(z_stream **)(a1 + 120);
        int v49 = v19 - v41 - v42->avail_in;
        unsigned int v20 = (char *)(*(void *)(a1 + 104) + v49);
        *(void *)(a1 + 104) = v20;
        *(void *)(a1 + 112) = v48 - v49;
        uint64_t v17 = a3 - v42->avail_out;
        if ((v40 & 1) != 0) {
          break;
        }
        v41 += v49;
      }

      while (!v17 && v19 != v41);
      if ((v40 & 1) == 0) {
        return v17;
      }
      if (v48 != v49)
      {
        BOOL v51 = data_archive_decoder_rewind_data(*(void *)(a1 + 40), v20, v48 - v49, 0LL, v44, v45, v46, v47);
        if (v51)
        {
          capture_error( a4,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive.c",  1163,  (uint64_t)"decompress_data",  "Could not rewind remaining data: %d",  v52,  v53,  v54,  v51);
          return -1LL;
        }

        *(void *)(a1 + 104) = *(void *)(a1 + 96);
        *(void *)(a1 + 112) = 0LL;
        int v42 = *(z_stream **)(a1 + 120);
      }

      v95 = inflateEnd(v42);
      if (!v95) {
        goto LABEL_107;
      }
      capture_error( a4,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive.c",  1178,  (uint64_t)"decompress_data",  "Could not inflateEnd: %d",  v96,  v97,  v98,  v95);
      return -1LL;
    case 4:
      if (!*(_BYTE *)(a1 + 168) && init_pkzip_cipher(a1, a4, a3, (uint64_t)a4, a5, a6, a7, a8))
      {
        size_t v13 = "decrypt_data";
        uint64_t v14 = "Could not initialize the PKZip cipher";
        uint64_t v15 = a4;
        uint64_t v16 = 1206;
        goto LABEL_9;
      }

      if (*(void *)(a1 + 64) == *(void *)(a1 + 72))
      {
        uint64_t v17 = 0LL;
        goto LABEL_33;
      }

      data_direct = read_data_direct((uint64_t *)a1, a2, a3, a4, a5, a6, a7, a8);
      if (data_direct <= 0)
      {
        int v26 = __error();
        BOOL v27 = strerror(*v26);
        capture_error( a4,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive.c",  1222,  (uint64_t)"decrypt_data",  "Could not read ciphertext: %s",  v28,  v29,  v30,  v27);
        return -1LL;
      }

      uint64_t v17 = data_direct;
      pkzip_crypto_decrypt_buffer((int *)(a1 + 172), (unsigned __int8 *)a2, data_direct);
      if (*(void *)(a1 + 64) != *(void *)(a1 + 72)) {
        return v17;
      }
      goto LABEL_33;
    case 5:
      return read_streamed_data(a1, (char *)a2, a3, a4, a5, a6, a7, a8);
    case 6:
      if (*(_BYTE *)(a1 + 80)) {
        return 0LL;
      }
      if (*(void *)(a1 + 96)) {
        goto LABEL_39;
      }
      *(void *)(a1 + 88) = 0x20000LL;
      uint64_t v23 = platform_valloc(*(void *)(a1 + 8), 0x20000uLL);
      *(void *)(a1 + 96) = v23;
      if (!v23)
      {
        v80 = *(void *)(a1 + 88);
        uint64_t v81 = __error();
        strerror(*v81);
        capture_error( a4,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive.c",  1378,  (uint64_t)"decompress_streamed_data",  "Could not allocate %ld for read buffer: %s",  v82,  v83,  v84,  v80);
        return -1LL;
      }

      platform_memset(*(void *)(a1 + 8), v23, 0LL, *(void *)(a1 + 88));
      *(void *)(a1 + 104) = *(void *)(a1 + 96);
      *(void *)(a1 + 112) = 0LL;
LABEL_39:
      if (*(void *)(a1 + 120)) {
        goto LABEL_40;
      }
      size_t v33 = (z_stream *)platform_calloc(*(void *)(a1 + 8), 1uLL, 0x70uLL);
      *(void *)(a1 + 120) = v33;
      if (!v33)
      {
        v90 = __error();
        v91 = strerror(*v90);
        capture_error( a4,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive.c",  1394,  (uint64_t)"decompress_streamed_data",  "Could not allocate zlib stream: %s",  v92,  v93,  v94,  v91);
        return -1LL;
      }

      uint64_t v34 = inflateInit2_(v33, -15, "1.2.12", 112);
      if (v34)
      {
        capture_error( a4,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive.c",  1401,  (uint64_t)"decompress_streamed_data",  "Could not inflateInit2: %d",  a6,  a7,  a8,  v34);
        return -1LL;
      }

    v35 = v10;
    if (*v10 == 46)
    {
      if (*v89 == 47) {
        v35 = (const char *)(a1 + 249);
      }
      else {
        v35 = v10;
      }
    }

    if (strlcpy(__dst, v35, a5) >= a5)
    {
      uint64_t v70 = *(void (**)(uint64_t, const char *, uint64_t))(a1 + 64);
      if (v70) {
        v70(a1, v35, 63LL);
      }
LABEL_114:
      uint64_t v23 = 2LL;
LABEL_115:
      if (!v93) {
        goto LABEL_7;
      }
      if (v26)
      {
        v83 = v93;
        do
        {
          free(*(void **)v83);
          *(void *)v83 = 0LL;
          *((void *)v83 + 1) = 0LL;
          v83 += 16;
          --v26;
        }

        while (v26);
      }

      uint64_t v73 = v93;
LABEL_120:
      free(v73);
      goto LABEL_7;
    }

    if (strncmp(v10, v13, __n)) {
      break;
    }
    unsigned int *v25 = 1;
    if ((*(_WORD *)(a2 + 4) & 0xF000) == 0x8000 && BOMAppleDoubleIsADFile(v10) && *(_BYTE *)(a1 + 169))
    {
      if (*(_DWORD *)(a1 + 12716) != 3) {
        goto LABEL_59;
      }
      if (v25[47])
      {
        int v42 = *v10;
        if (v42 == 46 && *v89 == 47) {
          v43 = 2LL;
        }
        else {
          v43 = v42 == 47;
        }
        if (!strncmp("__MACOSX", &v10[v43], 8uLL))
        {
          _parentPath(v10, v88, 0x400uLL);
          if (_insertQuarantinePath(*(void *)(a1 + 12752), v88, 0LL))
          {
            __error();
            _checkCopyFileError(a1);
            goto LABEL_114;
          }
        }
      }

      int v49 = v87;
      if (v87)
      {
        if (v87 == v26)
        {
          v50 = (char *)BOM_realloc(v93, 32 * v26);
          int v49 = 2 * v26;
        }

        else
        {
          v50 = v93;
        }
      }

      else
      {
        v50 = (char *)BOM_malloc(0x40uLL);
        int v49 = 4LL;
      }

      if (!v50)
      {
        BOMCopierNotifyFatalError( a1,  "Could not allocate space for Apple Double files.",  v36,  v37,  v38,  v39,  v40,  v41,  v84);
        goto LABEL_7;
      }

      v87 = v49;
      v93 = v50;
      v85 = strlen(__s);
      BOOL v51 = (char *)malloc(v85 + 1);
      strlcpy(v51, __s, v85 + 1);
      int v52 = (char **)&v93[16 * v26];
      *int v52 = v51;
      size_t v25 = (_BYTE *)(a1 + 12721);
      v52[1] = (char *)v85;
      ++v26;
    }

    if (*(_DWORD *)(a1 + 12716) == 3)
    {
      char v53 = _checkForDestinationConflict(a1, __s, a2, v91, &v97, v100);
      if (v100[0] == 1)
      {
        int v54 = v53;
        if (v54 == 1) {
          uint64_t v23 = 1LL;
        }
        else {
          uint64_t v23 = v23;
        }
        goto LABEL_78;
      }
    }

      BOMFSObjectFree((uint64_t)v5);
      return 0LL;
    }
  }

  return v5;
}

  *((_BYTE *)v10 + 393) = a2;
  *(_DWORD *)((char *)v10 + 389) = 16843009 * a2;
  if ((a3 & 0x200) == 0)
  {
LABEL_10:
    if ((a3 & 0x400) == 0) {
      goto LABEL_11;
    }
    goto LABEL_21;
  }

LABEL_84:
                ++v70;
              }

              while (v70 != v66);
            }

            v12[12] = v71;
            free(v67);
          }
        }
      }

      free(v38);
    }
  }

  return v12;
}

uint64_t _copyFilesFromBomToBom( uint64_t *a1, unsigned int *a2, const __CFArray *a3, const char *a4, char *a5, unsigned int a6, unsigned int a7, CFDictionaryRef *a8, char a9)
{
  size_t v9 = a8;
  uint64_t v96 = *MEMORY[0x1895F89C0];
  v85 = a8;
  if (!a8) {
    v85 = (CFDictionaryRef *)BOMHardLinkTableNew();
  }
  uint64_t v17 = BOMNewPathKey(a6, "", &v94);
  if (!v17) {
    goto LABEL_9;
  }
  uint64_t v18 = v17;
  uint64_t v19 = (char *)BOMTreeIteratorNew(a1[2], v17, v94, 0LL);
  free(v18);
  if (!v19) {
    goto LABEL_9;
  }
  __dst = (char *)a4;
  if (a4 != a5)
  {
    *a5 = 47;
    __dst = a5 + 1;
  }

  if (BOMTreeIteratorIsAtEnd((uint64_t)v19))
  {
    BOMTreeIteratorFree(v19);
LABEL_9:
    unsigned int v20 = 0LL;
    unsigned __int8 v21 = 0;
    goto LABEL_10;
  }

  size_t v88 = 0LL;
  theArray = a3;
  unsigned int v71 = a7;
  unsigned int v20 = 0LL;
  int v73 = 0;
  uint64_t __size = a4 - __dst + 1025;
  v87 = a4;
  v72 = v9;
  unsigned int v86 = a6;
  do
  {
    uint64_t v23 = (unsigned int *)BOMTreeIteratorKey((uint64_t)v19);
    uint64_t v24 = (uint64_t)a2;
    size_t v25 = (const char *)BOMShortNameFromPathKey((uint64_t)v23);
    int v26 = (unsigned int *)BOMTreeIteratorValue((uint64_t)v19);
    unsigned int v27 = BOMBlockIDFromPathValue((uint64_t)v26);
    unsigned int v28 = BOMPathIDFromPathKey(v26);
    size_t v29 = BOMStorageSizeOfBlock(a1[1], v27);
    if (v29 > v88)
    {
      if (v20) {
        free(v20);
      }
      unsigned int v20 = BOM_malloc(v29);
      size_t v88 = v29;
    }

    if (BOMStorageCopyFromBlock(a1[1], v27, v20))
    {
      fprintf((FILE *)*MEMORY[0x1895F89D0], "can't unarchive %s. skipping...\n");
LABEL_23:
      a2 = (unsigned int *)v24;
      goto LABEL_24;
    }

    unsigned int v80 = v28;
    unsigned int v84 = BOMFSObjectTypeFromRawData((unsigned __int8 *)v20);
    strlcpy(__dst, v25, __size);
    size_t v79 = strlen(v25);
    unsigned int v92 = 0;
    if (!a9)
    {
      char v78 = 0;
      int v81 = 0;
      LODWORD(v82) = 1;
      a2 = (unsigned int *)v24;
      goto LABEL_39;
    }

    a2 = (unsigned int *)v24;
    CFIndex v30 = _valueAtPath(v24);
    if (!v30)
    {
      char v78 = 0;
      int v81 = 0;
      LODWORD(v82) = 1;
      goto LABEL_39;
    }

    uint64_t v31 = (uint64_t)v30;
    size_t v32 = v9;
    size_t v33 = BOMPathIDFromPathKey(v30);
    unsigned int v92 = BOMBlockIDFromPathValue(v31);
    if (BOMStorageCopyFromBlockRange(*(void *)(v24 + 8), v92, 0LL, 1uLL, &v90))
    {
      uint64_t v34 = BOMExceptionHandlerMessage( "BOMStorageCopyFromBlockRange(storage=%p, bid=%u, location=%u, length=%u, data=%p) failed!",  *(const void **)(v24 + 8),  v92,  0,  1,  &v90);
      v35 = __error();
      _BOMExceptionHandlerCall((uint64_t)v34, 1, "/Library/Caches/com.apple.xbs/Sources/Bom/Bom/BOMBom.c", 743, *v35);
    }

    unsigned int v36 = BOMFSObjectTypeFromRawData(&v90);
    int v81 = v36;
    if (BOMBomHLIndexCount(*(void *)(v24 + 24), v92))
    {
      if (v36 == 1)
      {
        size_t v37 = v33;
        char v78 = 1;
        LODWORD(v82) = 0;
        HIDWORD(v82) = v92;
        int v81 = 1;
        size_t v9 = v32;
        a4 = v87;
      }

      else
      {
        LODWORD(v82) = 0;
        char v78 = 1;
        size_t v9 = v32;
        a4 = v87;
LABEL_39:
        HIDWORD(v82) = 0;
        size_t v37 = (unsigned int *)*a2;
        *a2 = (_DWORD)v37 + 1;
      }

      if (v84 == 1 && BOMBomHLIndexCount(a1[3], v27))
      {
        v91 = 0LL;
        BOMHardLinkTableGetPathAndData(v85, 0, v27, __s, &v91);
        if (v91)
        {
          unsigned int v38 = *v91;
          BOOL v75 = 1;
        }

        else
        {
          unsigned int v38 = BOMStorageNewBlock(*((void *)a2 + 1));
          BOOL v75 = 0;
        }

        char v77 = 0;
        unsigned int v92 = v38;
      }

      else
      {
        BOOL v75 = 0;
        unsigned int v92 = BOMStorageNewBlock(*((void *)a2 + 1));
        char v77 = 1;
      }

      goto LABEL_50;
    }

    size_t v37 = v33;
    if (v84 == 1)
    {
      size_t v9 = v32;
      if (BOMBomHLIndexCount(a1[3], v27))
      {
        v91 = 0LL;
        BOMHardLinkTableGetPathAndData(v85, 0, v27, __s, &v91);
        uint64_t v82 = 0LL;
        BOOL v75 = v91 != 0LL;
        char v77 = 0;
        char v78 = 1;
      }

      else
      {
        uint64_t v82 = 0LL;
        BOOL v75 = 0;
        char v77 = 1;
        char v78 = 1;
      }
    }

    else
    {
      uint64_t v82 = 0LL;
      BOOL v75 = 0;
      char v77 = 1;
      char v78 = 1;
      size_t v9 = v32;
    }

    a4 = v87;
LABEL_50:
    if (!v92 || !(_DWORD)v37) {
      goto LABEL_24;
    }
    if (theArray)
    {
      v39 = v37;
      CFIndex Count = CFArrayGetCount(theArray);
      if (Count < 1)
      {
        BOOL v45 = 0;
      }

      else
      {
        CFIndex v41 = Count;
        CFIndex v42 = 0LL;
        while (1)
        {
          ValueAtIndex = (regex_t *)CFArrayGetValueAtIndex(theArray, v42);
          if (ValueAtIndex)
          {
            BOOL v44 = BOMPatternMatch(ValueAtIndex, v87);
            if (v44) {
              break;
            }
          }

          if (v41 == ++v42)
          {
            BOOL v45 = 0;
            goto LABEL_63;
          }
        }

        BOOL v45 = v44;
LABEL_63:
        size_t v9 = v72;
      }

      size_t v37 = v39;
      if (v84 == 2)
      {
        if (v45) {
          int v46 = 0LL;
        }
        else {
          int v46 = theArray;
        }
        LOBYTE(v70) = v78;
        a4 = v87;
        int v47 = _copyFilesFromBomToBom(a1, v24, v46, v87, &__dst[v79], v80, v37, v85, v70);
      }

      else
      {
        int v47 = 0;
        a4 = v87;
      }

      int v48 = v47 | v45;
      a2 = (unsigned int *)v24;
      if (!v48) {
        goto LABEL_24;
      }
    }

    else if (v84 == 2)
    {
      LOBYTE(v70) = v78;
      _copyFilesFromBomToBom(a1, a2, 0LL, a4, &__dst[v79], v80, v37, v85, v70);
    }

    unsigned int v74 = v37;
    int v49 = v82;
    if (v81 == 2) {
      int v50 = v82;
    }
    else {
      int v50 = 1;
    }
    if (v50 == 1)
    {
      if ((v82 & 1) == 0)
      {
        if (HIDWORD(v82)) {
          unsigned int v51 = HIDWORD(v82);
        }
        else {
          unsigned int v51 = v92;
        }
        FSObjectWithBlockID = _BOMBomGetFSObjectWithBlockID((uint64_t)a2, v51);
        if (FSObjectWithBlockID)
        {
          uint64_t v53 = (uint64_t)FSObjectWithBlockID;
          _removeArchInfoForFSObject((unint64_t)a2, (uint64_t)FSObjectWithBlockID);
          BOMFSObjectFree(v53);
        }

        int v49 = v82;
        if (HIDWORD(v82))
        {
          size_t v54 = strlen(a4) + 1;
          int v49 = v82;
          BOMBomHLIndexRemove(*((void *)a2 + 3), HIDWORD(v82), a4, v54);
        }
      }

      if (BOMStorageSetBlockData(*((void *)a2 + 1), v92, v20, v29))
      {
        fprintf((FILE *)*MEMORY[0x1895F89D0], "can't archive %s. skipping...\n", a4);
        goto LABEL_24;
      }

      v55 = _BOMBomGetFSObjectWithBlockID((uint64_t)a2, v92);
      if (v55)
      {
        uint64_t v56 = (uint64_t)v55;
        _addArchInfoForFSObject((uint64_t)a2, (uint64_t)v55);
        BOMFSObjectFree(v56);
      }
    }

    if (HIDWORD(v82)) {
      int v57 = 1;
    }
    else {
      int v57 = v49;
    }
    if (v57 == 1)
    {
      uint64_t v58 = BOMTreeIteratorKey((uint64_t)v19);
      int v59 = (char *)BOMShortNameFromPathKey(v58);
      int v60 = BOMNewPathKey(v71, v59, &v94);
      unsigned int v61 = BOMNewPathValue(v74, v92, &v93);
      int v62 = BOMTreeSetValue(*((void **)a2 + 2), v60, v94, (uint64_t)v61, v93);
      free(v60);
      free(v61);
      if (v62)
      {
        fprintf((FILE *)*MEMORY[0x1895F89D0], "can't set path info for %s. skipping...\n");
        goto LABEL_23;
      }

      int v73 = 1;
      a2 = (unsigned int *)v24;
    }

    if ((v77 & 1) == 0)
    {
      if (v75)
      {
        uint64_t v63 = *((void *)a2 + 3);
        if (!__s[0])
        {
          size_t v69 = strlen(a4);
          BOMBomHLIndexSet(v63, v92, a4, v69 + 1);
          goto LABEL_24;
        }

        size_t v64 = strlen(__s);
        BOMBomHLIndexSet(v63, v92, __s, v64 + 1);
        size_t v65 = strlen(a4);
        BOMBomHLIndexSet(*((void *)a2 + 3), v92, a4, v65 + 1);
        uint64_t v66 = v27;
        v67 = v85;
        v68 = "";
      }

      else
      {
        uint64_t v66 = v27;
        v67 = v85;
        v68 = (char *)a4;
      }

      BOMHardLinkTableSetPathAndData(v67, 0, v66, v68, &v92, 4uLL);
    }

uint64_t _copyVariantsFromBomToBom( uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v43 = *MEMORY[0x1895F89C0];
  if (result)
  {
    uint64_t v9 = result;
    BOOL result = BOMBomVIndexCount(*(void *)(result + 32), 0LL, 0LL, 0LL, a5, a6, a7, a8);
    int v37 = result;
    if ((int)result >= 1)
    {
      unsigned int v11 = 0;
      do
      {
        BOMBomVIndexGet(*(void *)(v9 + 32), 0LL, 0LL, 0LL, v11, v42, 0x64uLL, v10);
        BOOL result = BOMBomVIndexCount(*(void *)(v9 + 32), v42, 0LL, 0LL, v12, v13, v14, v15);
        if ((int)result >= 1)
        {
          int v16 = result;
          for (unsigned int i = 0; i != v16; ++i)
          {
            BOMBomVIndexGet(*(void *)(v9 + 32), v42, 0LL, 0LL, i, v41, 0x64uLL, v10);
            BOOL result = BOMBomVIndexCount(*(void *)(v9 + 32), v42, (uint64_t)v41, 0LL, v18, v19, v20, v21);
            if ((int)result >= 1)
            {
              int v22 = result;
              for (unsigned int j = 0; j != v22; ++j)
              {
                BOMBomVIndexGet(*(void *)(v9 + 32), v42, (uint64_t)v41, 0LL, j, v40, 0x64uLL, v10);
                int v28 = BOMBomVIndexCount(*(void *)(v9 + 32), v42, (uint64_t)v41, (uint64_t)v40, v24, v25, v26, v27);
                if (v28 >= 1)
                {
                  int v32 = v28;
                  for (unsigned int k = 0; k != v32; ++k)
                  {
                    int v34 = BOMBomVIndexGet(*(void *)(v9 + 32), v42, (uint64_t)v41, (uint64_t)v40, k, v39, 0x64uLL, v31);
                    if (a2
                      && !v34
                      && !BOMBomVIndexSet( *(void *)(a2 + 32),  v42,  (uint64_t)v41,  (uint64_t)v40,  v39,  v29,  v30,  v31))
                    {
                      *(_BYTE *)(a2 + 64) = 1;
                    }
                  }
                }

                BOOL result = BOMBomVIndexGetApproxDiskSpace( *(void *)(a2 + 32),  v42,  (uint64_t)v41,  (uint64_t)v40,  &v38,  v29,  v30,  v31);
                if (!(_DWORD)result) {
                  BOOL result = BOMBomVIndexSetApproxDiskSpace( *(void *)(a2 + 32),  v42,  (uint64_t)v41,  (uint64_t)v40,  v38,  v35,  v36,  v10);
                }
              }
            }
          }
        }

        ++v11;
      }

      while (v11 != v37);
    }
  }

  return result;
}

__CFArray *_patternListForArchAndLangs(uint64_t a1, const char **a2, const char **a3, int a4)
{
  uint64_t v10 = BOMPatternListNew();
  if (!v10) {
    return v10;
  }
  if (!a2) {
    goto LABEL_5;
  }
  if (a4)
  {
    _addPathsToList(a1, "arch", v10, a2, 1LL, 1LL, v8, v9);
    _addPathsToList(a1, "arch", v10, a2, 0LL, 0LL, v11, v12);
LABEL_5:
    if (!a3) {
      goto LABEL_12;
    }
    if (a4)
    {
      _addPathsToList(a1, "lang", v10, a3, 1LL, 1LL, v8, v9);
      uint64_t v13 = 0LL;
    }

    else
    {
      uint64_t v13 = 1LL;
    }

    goto LABEL_11;
  }

  uint64_t v13 = 1LL;
  _addPathsToList(a1, "arch", v10, a2, 1LL, 0LL, v8, v9);
  if (a3) {
LABEL_11:
  }
    _addPathsToList(a1, "lang", v10, a3, v13, 0LL, v8, v9);
LABEL_12:
  CFIndex Count = CFArrayGetCount(v10);
  if (Count >= 1)
  {
    CFIndex v15 = Count;
    for (CFIndex i = 0LL; i != v15; ++i)
    {
      ValueAtIndex = (char *)CFArrayGetValueAtIndex(v10, i);
      uint64_t v18 = BOMPatternCompileString(ValueAtIndex);
      CFArraySetValueAtIndex(v10, i, v18);
      free(ValueAtIndex);
    }
  }

  return v10;
}

char *BOMBomNewFromDirectory(char *a1, char *a2, uint64_t a3)
{
  return BOMBomNewFromDirectoryWithSys(a1, a2, a3, 0LL);
}

char *BOMBomNewFromDirectoryWithSys(char *a1, char *a2, uint64_t a3, void *a4)
{
  keys[1] = *(void **)MEMORY[0x1895F89C0];
  uint64_t v8 = getenv("BOMBomNewFromDirectory_parallel");
  if (v8 && (uint64_t v9 = v8, strcmp(v8, "1")) && !strcmp(v9, "0"))
  {
    if (!a4) {
      a4 = BomSys_default();
    }
    if ((*((unsigned int (**)(void, char *, void *))a4 + 10))(*((void *)a4 + 1), a2, block))
    {
      uint64_t v10 = (FILE *)*MEMORY[0x1895F89D0];
      uint64_t v13 = __error();
      v91 = a2;
      uint64_t v93 = strerror(*v13);
      uint64_t v12 = "can't stat %s (%s)\n";
      goto LABEL_14;
    }

    if ((WORD2(block[0]) & 0xF000) != 0x4000) {
      goto LABEL_53;
    }
    a1 = (char *)BOMBomNewWithSys(a1, (uint64_t (**)(void, const char *, uint64_t, uint64_t))a4);
    if (a1)
    {
      v55 = (const void **)BOMHardLinkTableNew();
      if (v55)
      {
        uint64_t v56 = v55;
        (*((void (**)(void, stat *, uint64_t))a4 + 38))(*((void *)a4 + 1), &v107, 1025LL);
        if (!(*((unsigned int (**)(void, char *))a4 + 39))(*((void *)a4 + 1), a2))
        {
          __strlcpy_chk();
          size_t v57 = strlen(__s);
          if (!_visitDir((unsigned int *)a1, __s, &__s[v57], 0, (CFDictionaryRef *)v56, a3))
          {
            BOMHardLinkTableFree(v56);
            (*((void (**)(void, stat *))a4 + 39))(*((void *)a4 + 1), &v107);
            return a1;
          }
        }
      }

      BOMBomFree((uint64_t)a1);
      return 0LL;
    }
  }

  else
  {
    if (a1)
    {
      if (!a2)
      {
        fwrite("directory_path is NULL\n", 0x17uLL, 1uLL, (FILE *)*MEMORY[0x1895F89D0]);
        return 0LL;
      }

      if (stat(a2, &v107))
      {
        uint64_t v10 = (FILE *)*MEMORY[0x1895F89D0];
        uint64_t v11 = __error();
        v91 = a2;
        uint64_t v93 = strerror(*v11);
        uint64_t v12 = "Could not stat %s: %s\n";
LABEL_14:
        uint64_t v14 = v10;
LABEL_54:
        fprintf(v14, v12, v91, v93);
        return 0LL;
      }

      if ((v107.st_mode & 0xF000) == 0x4000)
      {
        *(void *)__s = 0LL;
        v100 = __s;
        uint64_t v101 = 0x6000000000LL;
        __int128 v102 = 0u;
        __int128 v103 = 0u;
        __int128 v104 = 0u;
        __int128 v105 = 0u;
        uint64_t v106 = 0LL;
        values = (void *)*MEMORY[0x189604DE8];
        keys[0] = @"disableLexicographicSort";
        CFIndex v15 = CFDictionaryCreate( (CFAllocatorRef)*MEMORY[0x189604DB0],  (const void **)keys,  (const void **)&values,  1LL,  MEMORY[0x189605240],  MEMORY[0x189605250]);
        if (!v15
          || (int v16 = v15,
              uint64_t v17 = BOMCopierSourceNew(a2, v15, 0LL, 0LL),
              *((void *)v100 + 3) = v17,
              CFRelease(v16),
              !*((void *)v100 + 3)))
        {
          int v59 = (FILE *)*MEMORY[0x1895F89D0];
          int v60 = "Could not create BOMCopierSource\n";
          size_t v61 = 33LL;
          goto LABEL_58;
        }

        dispatch_queue_global_t global_queue = dispatch_get_global_queue(0LL, 0LL);
        if (!global_queue)
        {
          int v59 = (FILE *)*MEMORY[0x1895F89D0];
          int v60 = "Could not get the global queue\n";
          size_t v61 = 31LL;
          goto LABEL_58;
        }

        uint64_t v19 = global_queue;
        dispatch_group_t v20 = dispatch_group_create();
        *((void *)v100 + 6) = v20;
        if (!v20)
        {
          int v59 = (FILE *)*MEMORY[0x1895F89D0];
          int v60 = "Could not create dispatch group\n";
          size_t v61 = 32LL;
          goto LABEL_58;
        }

        *((void *)v100 + 7) = BOMStackNew();
        uint64_t v21 = BOMHardLinkTableNew();
        *((void *)v100 + 9) = v21;
        if (v21)
        {
          int v22 = calloc(1uLL, 0x400uLL);
          uint64_t v29 = v100;
          *((void *)v100 + 10) = v22;
          if (!v22)
          {
            int v59 = (FILE *)*MEMORY[0x1895F89D0];
            int v60 = "Could not create empty hardlink path\n";
            size_t v61 = 37LL;
            goto LABEL_58;
          }

          v98 = 0LL;
          uint64_t v30 = BOMCopierSourceNext(*((void *)v29 + 3), &v98, v23, v24, v25, v26, v27, v28);
          if (v30)
          {
            uint64_t v31 = v30;
            int v32 = 1;
            while (1)
            {
              size_t v33 = calloc(1uLL, 0x50uLL);
              if (!v33)
              {
                int v59 = (FILE *)*MEMORY[0x1895F89D0];
                int v60 = "Could not allocate entry node\n";
                size_t v61 = 30LL;
                goto LABEL_58;
              }

              int v34 = v33;
              void *v33 = v31;
              uint64_t v35 = v100;
              if (*((void *)v100 + 4))
              {
                uint64_t v36 = v100 + 40;
                *(void *)(*((void *)v100 + 5) + 72LL) = v33;
              }

              else
              {
                *((void *)v100 + 4) = v33;
                uint64_t v36 = v35 + 40;
              }

              void *v36 = v33;
              int Type = BOMCopierSourceEntryGetType((uint64_t)v31);
              BOOL v44 = v100;
              BOOL v45 = (_DWORD *)*((void *)v100 + 8);
              if (v45)
              {
                *((_DWORD *)v34 + 4) = *v45;
                if (Type == 13)
                {
                  free(v45);
                  BOOL v44 = v100;
                  *((void *)v100 + 8) = 0LL;
LABEL_32:
                  int v46 = BOMStackPop(*((uint64_t **)v44 + 7));
                  *((void *)v100 + 8) = v46;
                  goto LABEL_41;
                }

                *((_DWORD *)v34 + 5) = v32;
                int v47 = (_DWORD *)v34 + 5;
                ++v32;
                if (Type != 6) {
                  goto LABEL_40;
                }
                BOMStackPush(*((char **)v44 + 7), (uint64_t)v45);
                BOOL v44 = v100;
                *((void *)v100 + 8) = 0LL;
              }

              else
              {
                if (Type == 13) {
                  goto LABEL_32;
                }
                *((_DWORD *)v34 + 5) = v32;
                int v47 = (_DWORD *)v34 + 5;
                ++v32;
                if (Type != 6)
                {
LABEL_40:
                  switch(Type)
                  {
                    case 4:
                    case 10:
                      goto LABEL_41;
                    case 6:
                      goto LABEL_38;
                    case 8:
                      int Device = BOMCopierSourceEntryGetDevice(*v34);
                      uint64_t Inode = BOMCopierSourceEntryGetInode(*v34);
                      *((_DWORD *)v34 + 8) = Device;
                      v34[5] = Inode;
                      v97 = 0LL;
                      if (BOMHardLinkTableGetPathAndData( *((CFDictionaryRef **)v100 + 9),  Device,  Inode,  *((char **)v100 + 10),  &v97))
                      {
                        Path = (char *)BOMCopierSourceEntryGetPath((uint64_t)v31);
                        int v96 = 1;
                        BOMHardLinkTableSetPathAndData(*((CFDictionaryRef **)v100 + 9), Device, Inode, Path, &v96, 4uLL);
                        *((_BYTE *)v34 + 24) = 1;
                        *((_DWORD *)v34 + 7) = v96;
                        goto LABEL_39;
                      }

                      *((_BYTE *)v34 + 25) = 1;
                      size_t v54 = (char *)BOMCopierSourceEntryGetPath((uint64_t)v31);
                      int v96 = 0;
                      int v96 = *v97 + 1;
                      BOMHardLinkTableSetPathAndData(*((CFDictionaryRef **)v100 + 9), Device, Inode, v54, &v96, 4uLL);
                      *((_DWORD *)v34 + 7) = v96;
                      break;
                    default:
                      goto LABEL_39;
                  }

                  goto LABEL_41;
                }
              }

              int v48 = malloc(4uLL);
              *((void *)v44 + 8) = v48;
              if (!v48)
              {
                v87 = (FILE *)*MEMORY[0x1895F89D0];
                unsigned __int8 v90 = __error();
                unsigned int v92 = strerror(*v90);
                v89 = "Could not create parent element: %s\n";
                goto LABEL_112;
              }

              *int v48 = *v47;
LABEL_38:
              ActualPath = (const char *)BOMCopierSourceEntryGetActualPath((uint64_t)v31);
              if (access(ActualPath, 1))
              {
                v87 = (FILE *)*MEMORY[0x1895F89D0];
                size_t v88 = __error();
                unsigned int v92 = (char *)ActualPath;
                uint64_t v93 = strerror(*v88);
                v89 = "Could not access %s: %s\n";
LABEL_112:
                fprintf(v87, v89, v92, v93);
                goto LABEL_59;
              }

LABEL_39:
              dispatch_group_enter(*((dispatch_group_t *)v100 + 6));
              int v50 = (dispatch_group_s *)*((void *)v100 + 6);
              block[0] = MEMORY[0x1895F87A8];
              block[1] = 0x40000000LL;
              block[2] = __BOMBomNewFromDirectory_parallel_block_invoke;
              block[3] = &unk_189E3F670;
              __int16 v95 = a3;
              block[6] = a4;
              block[7] = v34;
              block[4] = __s;
              block[5] = v31;
              dispatch_group_async(v50, v19, block);
LABEL_41:
              v98 = 0LL;
              uint64_t v31 = BOMCopierSourceNext(*((void *)v100 + 3), &v98, v38, v39, v40, v41, v42, v43);
              if (!v31) {
                goto LABEL_68;
              }
            }
          }

          int v32 = 1;
LABEL_68:
          if (v98)
          {
            int v62 = (FILE *)*MEMORY[0x1895F89D0];
            Message = (const char *)BOMCopierErrorGetMessage((uint64_t)v98);
            fprintf(v62, "Could not get next entry: %s\n", Message);
            BOMCopierErrorFree(v98);
            goto LABEL_59;
          }

          dispatch_group_wait(*((dispatch_group_t *)v100 + 6), 0xFFFFFFFFFFFFFFFFLL);
          uint64_t v64 = *((void *)v100 + 4);
          while (v64)
          {
            uint64_t v65 = v64;
            uint64_t v64 = *(void *)(v64 + 72);
            if (!*(void *)(v65 + 8) && *(_BYTE *)(v65 + 52) && *(void *)(v65 + 56) && *(void *)(v65 + 64))
            {
              uint64_t v66 = BOMFSObjectNewFromPathWithSys( *(const char **)(v65 + 56),  a3,  (unsigned int (**)(void, const char *, __int128 *))a4);
              if (!v66)
              {
                fprintf((FILE *)*MEMORY[0x1895F89D0], "Could not make second attempt to create BOMFSObject for %s\n");
                goto LABEL_59;
              }

              v67 = v66;
              BOMFSObjectSetPathName((uint64_t)v66, *(char **)(v65 + 64), 1);
              *(void *)(v65 + 8) = v67;
              v68 = *(void **)(v65 + 64);
              if (v68)
              {
                free(v68);
                *(void *)(v65 + 64) = 0LL;
              }

              size_t v69 = *(void **)(v65 + 56);
              if (v69)
              {
                free(v69);
                *(void *)(v65 + 56) = 0LL;
              }

              *(_BYTE *)(v65 + 52) = 0;
            }
          }

          uint64_t v70 = BOMBomNewWithSys(a1, 0LL);
          unsigned int v71 = v100;
          *((void *)v100 + 11) = v70;
          if (!v70)
          {
            int v59 = (FILE *)*MEMORY[0x1895F89D0];
            int v60 = "Could not create empty bom\n";
            size_t v61 = 27LL;
            goto LABEL_58;
          }

          uint64_t v72 = *((void *)v71 + 4);
          if (v72)
          {
            while (1)
            {
              int v73 = (void **)v72;
              uint64_t v72 = *(void *)(v72 + 72);
              if (v73[1] || *((_BYTE *)v73 + 25))
              {
                int v74 = BOMCopierSourceEntryGetType((uint64_t)*v73);
                if (v74 != 13)
                {
                  int v75 = v74;
                  __int128 v76 = (char *)BOMCopierSourceEntryGetPath((uint64_t)*v73);
                  int v96 = 0;
                  if (*((_BYTE *)v73 + 25))
                  {
                    v98 = 0LL;
                    if (BOMHardLinkTableGetPathAndData( *((CFDictionaryRef **)v100 + 9),  *((_DWORD *)v73 + 8),  (uint64_t)v73[5],  *((char **)v100 + 10),  &v98))
                    {
                      int v59 = (FILE *)*MEMORY[0x1895F89D0];
                      int v60 = "Could not get entry for hardlink node\n";
                      goto LABEL_64;
                    }

                    int v96 = *(_DWORD *)v98;
                  }

                  else
                  {
                    unsigned int v77 = BOMStorageNewBlock(*(void *)(*((void *)v100 + 11) + 8LL));
                    int v96 = v77;
                    if (!v77)
                    {
                      int v59 = (FILE *)*MEMORY[0x1895F89D0];
                      int v60 = "Could not get storage block for fso\n";
                      size_t v61 = 36LL;
                      goto LABEL_58;
                    }

                    *((_DWORD *)v73 + 12) = v77;
                    if (_BOMBomSetFSObjectWithBlockID(*((void *)v100 + 11), (uint64_t)v73[1], v77))
                    {
                      fprintf((FILE *)*MEMORY[0x1895F89D0], "Could not archive fso for %s\n");
                      goto LABEL_59;
                    }

                    if ((v75 & 0xFFFFFFFE) == 8) {
                      _addArchInfoForFSObject(*((void *)v100 + 11), (uint64_t)v73[1]);
                    }
                    if (*((_BYTE *)v73 + 24))
                    {
                      v98 = 0LL;
                      if (BOMHardLinkTableGetPathAndData( *((CFDictionaryRef **)v100 + 9),  *((_DWORD *)v73 + 8),  (uint64_t)v73[5],  *((char **)v100 + 10),  &v98))
                      {
                        int v59 = (FILE *)*MEMORY[0x1895F89D0];
                        int v60 = "Could not lookup count for hardlink origin\n";
                        size_t v61 = 43LL;
                        goto LABEL_58;
                      }

                      BOMHardLinkTableSetPathAndData( *((CFDictionaryRef **)v100 + 9),  *((_DWORD *)v73 + 8),  (uint64_t)v73[5],  v76,  &v96,  4uLL);
                    }
                  }

                  Name = BOMCopierSourceEntryGetName(*v73);
                  size_t v79 = BOMNewPathKey(*((_DWORD *)v73 + 4), Name, &v98);
                  if (!v79)
                  {
                    fprintf((FILE *)*MEMORY[0x1895F89D0], "Could not create path key for %u %s\n");
                    goto LABEL_59;
                  }

                  unsigned int v80 = v79;
                  int v81 = BOMNewPathValue(*((_DWORD *)v73 + 5), v96, &v97);
                  if (!v81)
                  {
                    fprintf( (FILE *)*MEMORY[0x1895F89D0],  "Could not create path value for %u %u\n",  *((_DWORD *)v73 + 5),  v96);
                    free(v80);
                    goto LABEL_59;
                  }

                  uint64_t v82 = v81;
                  int v83 = BOMTreeSetValue( *(void **)(*((void *)v100 + 11) + 16LL),  v80,  (size_t)v98,  (uint64_t)v81,  (uint64_t)v97);
                  free(v80);
                  free(v82);
                  if (v83)
                  {
                    fprintf((FILE *)*MEMORY[0x1895F89D0], "Could not set path info for %s\n");
                    goto LABEL_59;
                  }

                  if (*((_BYTE *)v73 + 25))
                  {
                    if (*((_DWORD *)v73 + 7) == 2)
                    {
                      size_t v84 = strlen(*((const char **)v100 + 10));
                      BOMBomHLIndexSet( *(void *)(*((void *)v100 + 11) + 24LL),  v96,  *((const void **)v100 + 10),  v84 + 1);
                    }

                    size_t v85 = strlen(v76);
                    BOMBomHLIndexSet(*(void *)(*((void *)v100 + 11) + 24LL), v96, v76, v85 + 1);
                  }
                }
              }

              if (!v72)
              {
                uint64_t v70 = (void *)*((void *)v100 + 11);
                break;
              }
            }
          }

          *(_DWORD *)uint64_t v70 = v32;
          uint64_t v86 = (uint64_t)(v100 + 24);
          a1 = (char *)*((void *)v100 + 11);
          *((void *)v100 + 11) = 0LL;
          release_discovery_state(v86);
        }

        else
        {
          int v59 = (FILE *)*MEMORY[0x1895F89D0];
          int v60 = "Could not create empty hardlink table\n";
LABEL_64:
          size_t v61 = 38LL;
LABEL_58:
          fwrite(v60, v61, 1uLL, v59);
LABEL_59:
          release_discovery_state((uint64_t)(v100 + 24));
          a1 = 0LL;
        }

        _Block_object_dispose(__s, 8);
        return a1;
      }

      BOMCopierErrorCapture( v3,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c",  3627,  (uint64_t)"synthesize_filesystem_stuff",  "Could not discover resource fork");
      return 0xFFFFFFFFLL;
    }

    return 0LL;
  }

  uint64_t v10 = *__error();
  uint64_t v11 = __error();
  strerror(*v11);
  BOMCopierErrorCapture( v3,  v10,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c",  3796,  (uint64_t)"synthesize_apple_double",  "Could not copyfile %s to %s: %s",  ActualPath);
LABEL_14:
  BOMCopierErrorCapture( v3,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c",  3605,  (uint64_t)"synthesize_filesystem_stuff",  "Could not synthesize the AppleDouble file");
  return 0xFFFFFFFFLL;
}

          uint64_t v41 = BOMCopierSourceNext((uint64_t)v31, 0LL, v50, v51, v52, v53, v54, v55);
          if (!v41) {
            goto LABEL_54;
          }
          break;
        default:
          goto LABEL_31;
      }
    }
  }

  uint64_t v43 = 0LL;
  uint64_t v42 = 0LL;
LABEL_54:
  BOMCopierSourceFree(v31);
  unsigned int v71 = BOMCopierReleaseMatchContext((unsigned int *)&v89, &v88);
  if ((_DWORD)v71)
  {
    size_t v69 = v71;
    uint64_t v72 = (const char *)BOMCopierErrorGetMessage((uint64_t)v88);
    BOMCopierNotifyFatalError(a1, v72, v73, v74, v75, v76, v77, v78, v86);
    BOMCopierErrorFree(v88);
  }

  else
  {
    if (a4) {
      *a4 = v42;
    }
    size_t v69 = 0LL;
    if (a5) {
      *a5 = v43;
    }
  }

  return v69;
}

LABEL_53:
      uint64_t v14 = (FILE *)*MEMORY[0x1895F89D0];
      v91 = a2;
      uint64_t v12 = "%s is not a directory\n";
      goto LABEL_54;
    }

    fwrite("bom_path is NULL\n", 0x11uLL, 1uLL, (FILE *)*MEMORY[0x1895F89D0]);
  }

  return a1;
}

        byte_stream_free(v45);
        uint64_t v5 = v94;
        goto LABEL_72;
      }

      __int16 v95 = 0uLL;
      *(void *)&int v96 = 0LL;
      if ((v47 & 1) != 0)
      {
        *(void *)&__int16 v95 = byte_stream_read_uint32((uint64_t)v45);
        if ((v48 & 2) == 0)
        {
LABEL_23:
          if ((v48 & 4) == 0) {
            goto LABEL_25;
          }
          goto LABEL_24;
        }
      }

      else if ((v47 & 2) == 0)
      {
        goto LABEL_23;
      }

      *((void *)&v95 + 1) = byte_stream_read_uint32((uint64_t)v45);
      if ((v48 & 4) == 0)
      {
LABEL_25:
        if (byte_stream_exception((BOOL)v45))
        {
          v87 = "Could not parse the PKZip extended-timestamp extra block";
          uint64_t v5 = v94;
          size_t v88 = v94;
          v89 = 3625;
          goto LABEL_101;
        }

        if (darc_format_entry_set_attribute(a2, "pkzip extra field extended timestamp", &v95, 0x18uLL))
        {
          v87 = "Could not set extended timestamp";
          uint64_t v5 = v94;
          size_t v88 = v94;
          v89 = 3636;
LABEL_101:
          capture_error( v88,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_decoder.c",  v89,  (uint64_t)"parse_entry_pkzip_extra_field_extended_timestamp",  v87,  v42,  v43,  v44,  v93);
          int v75 = "Could not parse extended timestamp";
          __int128 v76 = v5;
          unsigned int v77 = 3309;
          goto LABEL_104;
        }

        goto LABEL_53;
      }

      BOOL v44 = *(void *)(a3 + 96);
      if (!v14)
      {
        v200 = 0;
        v203 = 0LL;
        BOOL v45 = 0LL;
        HIDWORD(v222) = 0;
LABEL_61:
        if ((unint64_t)v44 >> 33 && *(_BYTE *)(a1 + 12824))
        {
          v202 = 0LL;
          v204 = 0;
          v205 = 0LL;
          __src = 0LL;
          v207 = 0LL;
          LODWORD(a2) = 1;
          int v46 = 0x40000000LL;
        }

        else
        {
          LODWORD(a2) = 0;
          v202 = 0LL;
          v204 = 0;
          v205 = 0LL;
          __src = 0LL;
          v207 = 0LL;
          int v46 = v44;
        }

        goto LABEL_128;
      }

      int v47 = v9;
      int v48 = *(int *)(a1 + 16);
      v210 = *(void *)(a3 + 96);
      if (v44 == -1)
      {
        int v74 = 0LL;
        BOOL v45 = 0LL;
        do
        {
          int v75 = BOMFileRead(v224, (char *)(*(void *)(a1 + 8) + v74), v48 - v74);
          if ((v75 & 0x8000000000000000LL) != 0)
          {
            __error();
            uint64_t v43 = _checkCopyFileError(a1);
            LOBYTE(a2) = 0;
            v202 = 0LL;
            v203 = 0LL;
            int v46 = 0LL;
            v204 = 0;
            v205 = 0LL;
            __src = 0LL;
            v207 = 0LL;
            v200 = 0;
            BOOL v44 = -1LL;
            goto LABEL_168;
          }

          v74 += v75;
          v45 += v75;
        }

        while (v74 < v48 && !BOMFileEndOfCompressionStream((BOOL)v224));
      }

      else
      {
        if (v44 >= v48) {
          int v49 = *(int *)(a1 + 16);
        }
        else {
          int v49 = *(void *)(a3 + 96);
        }
        BOOL v45 = BOMFileRead(v224, *(char **)(a1 + 8), v49);
        if (v45 < 0)
        {
          __error();
          uint64_t v43 = _checkCopyFileError(a1);
          LOBYTE(a2) = 0;
          v202 = 0LL;
          v203 = 0LL;
          BOOL v45 = 0LL;
          int v46 = 0LL;
          v204 = 0;
          v205 = 0LL;
          __src = 0LL;
          v207 = 0LL;
          v200 = 0;
          LOBYTE(v14) = 1;
          goto LABEL_259;
        }
      }

      __int128 v76 = BOMArchFlagForHeader(*(int **)(a1 + 8), v45);
      if (v76 == 1)
      {
        size_t v85 = *(void *)(a1 + 8);
        uint64_t v86 = (char *)BOM_malloc(0x1CuLL);
        if (!v86)
        {
          LOBYTE(a2) = 0;
          v202 = 0LL;
          v203 = 0LL;
          int v46 = 0LL;
          v204 = 0;
          v205 = 0LL;
          __src = 0LL;
          v207 = 0LL;
          v200 = 0;
          goto LABEL_259;
        }

        *(void *)uint64_t v86 = 0x1CAFEBABELL;
        size_t v84 = (uint64_t)(v86 + 8);
        v87 = 0LL;
        size_t v88 = *(_DWORD *)v85;
        if (*(int *)v85 > -17958195)
        {
          if (v88 == -17958193 || v88 == -17958194) {
            v87 = *(int8x8_t *)(v85 + 4);
          }
        }

        else if (v88 == -822415874 || v88 == -805638658)
        {
          v87 = vrev32_s8(*(int8x8_t *)(v85 + 4));
        }

        *((int8x8_t *)v86 + 1) = v87;
        char v78 = 1;
        v200 = 1;
        *((_DWORD *)v86 + 4) = 0;
        v203 = (unsigned int *)v86;
        *(void *)(v86 + 20) = v210;
        BOOL v44 = v210;
      }

      else
      {
        if (v76 == 2)
        {
          unsigned int v77 = *(unsigned int **)(a1 + 8);
          char v78 = bswap32(v77[1]);
          size_t v79 = (int)(20 * v78 + 8);
          unsigned int v80 = (unsigned int *)BOM_malloc(v79);
          if (!v80)
          {
            LOBYTE(a2) = 0;
            v202 = 0LL;
            v203 = 0LL;
            int v46 = 0LL;
            v204 = 0;
            v205 = 0LL;
            __src = 0LL;
            v207 = 0LL;
            v200 = 0;
            goto LABEL_258;
          }

          int v81 = v80;
          uint64_t v82 = v77;
          int v83 = (char *)(v80 + 2);
          memmove(v80, v82, v79);
          v203 = v81;
          _fat_header_big_to_host(v81, v79);
          size_t v84 = (uint64_t)v83;
          v200 = 1;
        }

        else
        {
          char v78 = 0;
          size_t v84 = 0LL;
          v203 = 0LL;
          v200 = 0;
        }

        BOOL v44 = v210;
      }

      if (_determine_thin_type_and_archs(v84, v78, v47, &v221, &v222, (_DWORD *)&v222 + 1, 0))
      {
        LOBYTE(a2) = 0;
        v202 = 0LL;
        int v46 = 0LL;
        v204 = 0;
        v205 = 0LL;
        __src = 0LL;
        v207 = 0LL;
        uint64_t v43 = 0LL;
        *a7 = 1;
        a3 = v213;
        goto LABEL_157;
      }

      a3 = v213;
      if (!HIDWORD(v222)) {
        goto LABEL_61;
      }
      v100 = 20 * v222 + 8;
      uint64_t v101 = BOM_malloc(v100);
      v204 = v100;
      if (v101)
      {
        __int128 v102 = (uint64_t)(v101 + 2);
        *uint64_t v101 = -889275714;
        __int128 v103 = v222;
        __src = v101;
        v101[1] = v222;
        _sortFatArchsByOffset(v221, v103);
        if (HIDWORD(v222) == 1) {
          __int128 v104 = 0;
        }
        else {
          __int128 v104 = v100;
        }
        _createNewFatArchArray((uint64_t *)v221, v222, v102, v104);
        LODWORD(a2) = 0;
        v202 = 0LL;
        v207 = 0LL;
        v205 = v102;
        int v46 = (*(_DWORD *)(v102 + 20LL * (int)v222 - 8) + *(_DWORD *)(v102 + 20LL * (int)v222 - 12));
        goto LABEL_128;
      }

      LOBYTE(a2) = 0;
      v202 = 0LL;
      int v46 = 0LL;
      v205 = 0LL;
      __src = 0LL;
      v207 = 0LL;
      while (1)
      {
LABEL_168:
        if (v223 && *(_DWORD *)(a1 + 12716) == 3)
        {
          if (BOMFileClose(v223) && !(_DWORD)v43)
          {
            __error();
            uint64_t v43 = _checkCopyFileError(a1);
          }

          v223 = 0LL;
        }

        uint64_t v43 = 0LL;
        if (v14) {
          LOBYTE(v14) = 0;
        }
        if (v46 >= v44 - v45) {
          int v46 = v44 - v45;
        }
        LODWORD(a2) = 1;
        a8 = 1;
LABEL_128:
        v109 = *(_DWORD *)(a1 + 12716);
        if (v109 != 3)
        {
          if (v46 == -1) {
            v114 = 0LL;
          }
          else {
            v114 = v46;
          }
          *(void *)(a3 + 96) = v114;
          v115 = (char *)(a1 + 7424);
          if (v109 == 4)
          {
            v223 = BOMCPIOGetFile(*(void *)(a1 + 12736));
          }

          else
          {
            v122 = BOMPKZipGetFile(*(void *)(a1 + 12760));
            v223 = v122;
            if (v46 >= 1)
            {
              v202 = BOMFileOffset(v223);
            }
          }

          goto LABEL_203;
        }

        v110 = v44;
        v111 = 16 * (*(_BYTE *)(a1 + 12814) == 0);
        if (a5) {
          v112 = *(_BYTE *)(a1 + 12823) == 0;
        }
        else {
          v112 = 1;
        }
        if (v112) {
          v113 = 1;
        }
        else {
          v113 = a8;
        }
        if ((v113 & 1) != 0
          || !(*(unsigned int (**)(void, uint64_t))(*(void *)(a1 + 12832) + 224LL))( *(void *)(*(void *)(a1 + 12832) + 8LL),  a1 + 7424))
        {
          if (a8) {
            v116 = 521LL;
          }
          else {
            v116 = 2561LL;
          }
          if (BOMFileOpenWithSys( &v223,  a1 + 7424,  v116,  384LL,  v111,  *(void (***)(void, uint64_t, uint64_t, uint64_t))(a1 + 12832)))
          {
            if (*__error() != 2
              || !*(_DWORD *)(a1 + 12712)
              || _mkdirs_parent(a1)
              || (!a8 ? (v117 = 1537LL) : (v117 = 521LL),
                  BOMFileOpenWithSys( &v223,  a1 + 7424,  v117,  384LL,  v111,  *(void (***)(void, uint64_t, uint64_t, uint64_t))(a1 + 12832))))
            {
              __error();
              uint64_t v43 = _checkCopyFileError(a1);
              a3 = v213;
              goto LABEL_156;
            }
          }

          if (*(_BYTE *)(a1 + 207) == 1 || *(_BYTE *)(a1 + 208) == 1 || *(_BYTE *)(a1 + 211) == 1)
          {
            FileDescriptor = BOMFileGetFileDescriptor(v223);
            a3 = v213;
            if (FileDescriptor != -1)
            {
              v121 = FileDescriptor;
              BOOL v44 = v110;
              if (*(_BYTE *)(a1 + 211) == 1 && fcntl(FileDescriptor, 64, *(unsigned int *)(a1 + 212))
                || *(_BYTE *)(a1 + 207) == 1 && fcntl(v121, 68, 1LL)
                || *(_BYTE *)(a1 + 208) == 1 && fcntl(v121, 76, 1LL))
              {
                __error();
                uint64_t v43 = _checkCopyFileError(a1);
                goto LABEL_157;
              }

              goto LABEL_203;
            }
          }

          else
          {
            a3 = v213;
          }

          BOOL v44 = v110;
LABEL_203:
          if (HIDWORD(v222))
          {
            v127 = BOM_calloc(168 * (int)v222 + 168, 1uLL);
            if (v127)
            {
              v128 = (uint64_t)v127;
              v129 = 0;
              v130 = v44;
              v131 = 0LL;
              *v127 = a1;
              v132 = v223;
              v127[1] = v224;
              v127[2] = v132;
              v127[3] = v212;
              v127[4] = v130;
              v210 = v130;
              v127[5] = v46;
              v133 = v127 + 7;
              if (HIDWORD(v222) != 2) {
                goto LABEL_208;
              }
              v131 = v204;
              v134 = (unsigned int *)BOM_malloc(v204);
              if (v134)
              {
                v135 = v134;
                memmove(v134, __src, v204);
                _fat_header_host_to_big(v135, v204);
                v129 = 1;
                *(_DWORD *)(v128 + 56) = 1;
                *(void *)(v128 + 64) = v204;
                *(_DWORD *)(v128 + 72) = 1;
                *(void *)(v128 + 80) = 0LL;
                *(void *)(v128 + 88) = v135;
                v207 = v135;
                *(void *)(v128 + 96) = 0LL;
                *(void *)(v128 + 104) = 0LL;
                a3 = v213;
LABEL_208:
                if ((int)v222 >= 1)
                {
                  v136 = 0LL;
                  v137 = (unsigned int *)(v205 + 8);
                  while (1)
                  {
                    v138 = *((void *)v221 + v136);
                    v140 = *v137;
                    v137 += 5;
                    v139 = v140;
                    v141 = v140 - v131;
                    if (v140 <= v131)
                    {
                      v139 = v131;
                    }

                    else
                    {
                      v142 = &v133[7 * v129];
                      *(_DWORD *)v142 = 0;
                      v142[1] = v141;
                      *((_DWORD *)v142 + 4) = 1;
                      v142[3] = 0LL;
                      v142[4] = 0LL;
                      v142[5] = v131;
                      v142[6] = 0LL;
                      ++v129;
                    }

                    v143 = *(unsigned int *)(v138 + 8);
                    v144 = *(unsigned int *)(v138 + 12);
                    v145 = v45 - v143;
                    if (v45 <= v143) {
                      break;
                    }
                    v146 = (v144 + v143);
                    v147 = v146 <= v45;
                    v148 = v146 - v45;
                    if (v147)
                    {
                      v151 = &v133[7 * v129];
                      *(_DWORD *)v151 = 1;
                      v151[1] = v144;
                      *((_DWORD *)v151 + 4) = 1;
                      v151[3] = 0LL;
                      v151[4] = *(void *)(a1 + 8) + v143;
                      goto LABEL_218;
                    }

                    v149 = &v133[7 * v129];
                    *(_DWORD *)v149 = 1;
                    v149[1] = v145;
                    *((_DWORD *)v149 + 4) = 1;
                    v149[3] = 0LL;
                    v149[4] = *(void *)(a1 + 8) + v143;
                    v149[5] = v139;
                    v149[6] = 0LL;
                    v150 = v145 + v139;
                    ++v129;
                    *((_DWORD *)v149 + 14) = 2;
                    v149[8] = v148;
                    *((_DWORD *)v149 + 18) = 1;
                    v149[10] = v45;
                    v149[11] = 0LL;
                    v149[12] = v150;
                    v149[13] = 0LL;
                    v131 = v148 + v150;
LABEL_219:
                    ++v129;
                  }

                  v151 = &v133[7 * v129];
                  *(_DWORD *)v151 = 2;
                  v151[1] = v144;
                  *((_DWORD *)v151 + 4) = 1;
                  v151[3] = v143;
                  v151[4] = 0LL;
LABEL_218:
                  v151[5] = v139;
                  v151[6] = 0LL;
                  v131 = v139 + v144;
                  goto LABEL_219;
                }

char *BOMBomNewFromDirectoryWithOptions(char *a1, char *a2, uint64_t a3, char a4)
{
  uint64_t v15 = *MEMORY[0x1895F89C0];
  v13.rlim_cur = 0LL;
  v13.int rlim_max = 0LL;
  if ((a4 & 1) == 0) {
    return BOMBomNewFromDirectoryWithSys(a1, a2, a3, 0LL);
  }
  if (getrlimit(8, &v13)) {
    return 0LL;
  }
  *(void *)uint64_t v14 = 0x1D00000001LL;
  int rlim_max = 0;
  size_t v11 = 4LL;
  if (sysctl(v14, 2u, &rlim_max, &v11, 0LL, 0LL)) {
    return 0LL;
  }
  rlim_t rlim_max_low = rlim_max;
  if (v13.rlim_max < rlim_max)
  {
    int rlim_max = v13.rlim_max;
    rlim_t rlim_max_low = SLODWORD(v13.rlim_max);
  }

  if (v13.rlim_cur >= rlim_max_low) {
    goto LABEL_14;
  }
  rlimit v10 = v13;
  if (v13.rlim_cur + 2304 < rlim_max_low) {
    rlim_t rlim_max_low = v13.rlim_cur + 2304;
  }
  v10.rlim_cur = rlim_max_low;
  if (setrlimit(8, &v10)) {
    return BOMBomNewFromDirectoryWithSys(a1, a2, a3, 0LL);
  }
LABEL_14:
  uint64_t v8 = BOMBomNewFromDirectoryWithSys(a1, a2, a3, 0LL);
  setrlimit(8, &v13);
  return v8;
}

uint64_t _visitDir( unsigned int *a1, const char *a2, char *a3, unsigned int a4, CFDictionaryRef *a5, uint64_t a6)
{
  uint64_t v57 = *MEMORY[0x1895F89C0];
  uint64_t v12 = *a1;
  *a1 = v12 + 1;
  uint64_t Sys = BOMStorageGetSys(*((void *)a1 + 1));
  uint64_t v14 = BOMFSObjectNewFromPathWithSys(".", a6, (unsigned int (**)(void, const char *, __int128 *))Sys);
  if (!v14)
  {
    fprintf((FILE *)*MEMORY[0x1895F89D0], "can't read %s. skipping...\n");
    return 0LL;
  }

  uint64_t v15 = (uint64_t)v14;
  unsigned int v16 = BOMStorageNewBlock(*((void *)a1 + 1));
  unsigned int v51 = v16;
  if (!v16) {
    return 1LL;
  }
  if (_BOMBomSetFSObjectWithBlockID((uint64_t)a1, v15, v16))
  {
LABEL_5:
    fprintf((FILE *)*MEMORY[0x1895F89D0], "can't archive %s. skipping...\n", a2);
    return 1LL;
  }

  BOMFSObjectFree(v15);
  uint64_t v18 = a3;
  do
  {
    if (v18 <= a2) {
      break;
    }
    int v19 = *--v18;
  }

  while (v19 != 47);
  if (v18 <= a2) {
    dispatch_group_t v20 = v18;
  }
  else {
    dispatch_group_t v20 = v18 + 1;
  }
  uint64_t v21 = BOMNewPathKey(a4, v20, &v49);
  int v22 = BOMNewPathValue(v12, v51, &v48);
  int v23 = BOMTreeSetValue(*((void **)a1 + 2), v21, v49, (uint64_t)v22, v48);
  free(v21);
  free(v22);
  if (v23)
  {
    fprintf((FILE *)*MEMORY[0x1895F89D0], "can't set path info for %s. skipping...\n");
    return 0LL;
  }

  uint64_t v24 = (*(uint64_t (**)(void, const char *))(Sys + 272))(*(void *)(Sys + 8), ".");
  if (!v24)
  {
LABEL_46:
    perror(a2);
    return 1LL;
  }

  uint64_t v25 = v24;
  *a3 = 47;
  uint64_t v26 = a3 + 1;
  uint64_t v27 = (*(uint64_t (**)(void, uint64_t))(Sys + 288))(*(void *)(Sys + 8), v24);
  if (!v27)
  {
LABEL_48:
    (*(void (**)(void, uint64_t))(Sys + 280))(*(void *)(Sys + 8), v25);
    return 0LL;
  }

  uint64_t v28 = v27;
  uint64_t v47 = v25;
  while (1)
  {
    uint64_t v29 = (char *)(v28 + 21);
    strlcpy(v26, (const char *)(v28 + 21), a2 - v26 + 1025);
    int v30 = v53 & 0xF000;
    if (v30 == 0x4000) {
      break;
    }
    int v50 = 0LL;
    if (v30 == 0x8000
      && v54 >= 2u
      && (__s[0] = 0, BOMHardLinkTableGetPathAndData(a5, v52, *(uint64_t *)v55, __s, &v50), v50))
    {
      int v46 = 0;
      unsigned int v51 = *v50;
    }

    else
    {
      uint64_t v31 = BOMFSObjectNewFromPathWithSys( (const char *)(v28 + 21),  a6,  (unsigned int (**)(void, const char *, __int128 *))Sys);
      if (!v31) {
        goto LABEL_36;
      }
      uint64_t v32 = (uint64_t)v31;
      unsigned int v33 = BOMStorageNewBlock(*((void *)a1 + 1));
      unsigned int v51 = v33;
      if (!v33) {
        goto LABEL_50;
      }
      _addArchInfoForFSObject((uint64_t)a1, v32);
      BOMFSObjectFree(v32);
      int v46 = 1;
    }

    unsigned int v34 = (*a1)++;
    uint64_t v35 = BOMNewPathKey(v12, v29, &v49);
    uint64_t v36 = BOMNewPathValue(v34, v51, &v48);
    int v37 = BOMTreeSetValue(*((void **)a1 + 2), v35, v49, (uint64_t)v36, v48);
    free(v35);
    free(v36);
    if (v37)
    {
      fprintf((FILE *)*MEMORY[0x1895F89D0], "can't set path info for %s. skipping...\n", a2);
      uint64_t v25 = v47;
    }

    else
    {
      uint64_t v25 = v47;
      if ((v53 & 0xF000) != 0x8000 || v54 < 2u) {
        goto LABEL_36;
      }
      if (v46)
      {
        int v38 = v52;
        uint64_t v39 = *(void *)v55;
        uint64_t v40 = a5;
        uint64_t v41 = (char *)a2;
      }

      else
      {
        uint64_t v42 = *((void *)a1 + 3);
        if (!__s[0])
        {
          size_t v45 = strlen(a2);
          BOMBomHLIndexSet(v42, v51, a2, v45 + 1);
          goto LABEL_36;
        }

        size_t v43 = strlen(__s);
        BOMBomHLIndexSet(v42, v51, __s, v43 + 1);
        size_t v44 = strlen(a2) + 1;
        uint64_t v25 = v47;
        BOMBomHLIndexSet(*((void *)a1 + 3), v51, a2, v44);
        int v38 = v52;
        uint64_t v39 = *(void *)v55;
        uint64_t v40 = a5;
        uint64_t v41 = "";
      }

      BOMHardLinkTableSetPathAndData(v40, v38, v39, v41, &v51, 4uLL);
    }

LABEL_36:
    uint64_t v28 = (*(uint64_t (**)(void, uint64_t))(Sys + 288))(*(void *)(Sys + 8), v25);
    if (!v28) {
      goto LABEL_48;
    }
  }

  if (!(*(unsigned int (**)(void, uint64_t))(Sys + 312))(*(void *)(Sys + 8), v28 + 21))
  {
  }

    *a6 = 1;
    uint64_t v14 = a1;
    return _checkCopyFileError(v14);
  }

  if (v19) {
    return 0LL;
  }
  if ((*(unsigned int (**)(void, uint64_t))(*(void *)(a1 + 12832) + 224LL))( *(void *)(*(void *)(a1 + 12832) + 8LL),  a1 + 3328))
  {
LABEL_31:
    *a6 = 1;
    __error();
LABEL_32:
    uint64_t v14 = a1;
    return _checkCopyFileError(v14);
  }

LABEL_49:
  perror(a2);
LABEL_50:
  (*(void (**)(void, uint64_t))(Sys + 280))(*(void *)(Sys + 8), v25);
  return 1LL;
}

          if (*(_DWORD *)(a1 + 12712)
            || (_BYTE *)(*(uint64_t (**)(void, char *, _BYTE *))(*(void *)(a1 + 12832) + 160LL))( *(void *)(*(void *)(a1 + 12832) + 8LL),  a2,  v57) == v57)
          {
            if (!_prepareCopierDestination(a1, a3, v28, v29, v30, v31, v32, v33))
            {
              int v22 = 1LL;
              switch(*(_DWORD *)(a1 + 12712))
              {
                case 0:
                  v55 = _BOMCopierCopyFromFilesystem(a1, a2, a3);
                  goto LABEL_57;
                case 1:
                  v55 = _BOMCopierCopyFromCPIO(a1, *(void *)(a1 + 12976), a3, v50, v51, v52, v53, v54);
                  goto LABEL_57;
                case 2:
                  v55 = _BOMCopierCopyFromPKZip(a1, *(void *)(a1 + 12976), a3, v50, v51, v52, v53, v54);
LABEL_57:
                  int v22 = v55;
                  if (!(_DWORD)v55) {
                    goto LABEL_58;
                  }
                  goto LABEL_59;
                case 3:
                  goto LABEL_59;
                default:
LABEL_58:
                  int v22 = _finalizeCopierDestination(a1, v48, v49, v50, v51, v52, v53, v54);
LABEL_59:
                  _resetCopier(a1);
                  break;
              }

              return v22;
            }
          }

          else
          {
            BOMCopierNotifyFatalError( a1,  "Cannot get the real path for source '%s'",  v28,  v29,  v30,  v31,  v32,  v33,  (char)a2);
          }

          goto LABEL_17;
        }

            *(void *)(v12 + 1088) = _NewFreeList();
            goto LABEL_50;
          }

          uint64_t v21 = (FILE *)*MEMORY[0x1895F89D0];
          size_t v44 = __error();
          uint64_t v47 = strerror(*v44);
          int v23 = "mmap: %s\n";
          goto LABEL_15;
        }

        fprintf((FILE *)*MEMORY[0x1895F89D0], "%s: stream invalid; overflow of admin offset+size\n");
LABEL_20:
        (*((void (**)(void, uint64_t))v3 + 4))(*((void *)v3 + 1), v7);
        return 0LL;
      }

      fprintf((FILE *)*MEMORY[0x1895F89D0], "%s has an unknown version: 0x%X\n", a1, UInt32);
    }

    else
    {
      uint64_t v25 = BOMExceptionHandlerMessage("%s is not a BOMStorage file\n", a1);
      uint64_t v26 = __error();
      _BOMExceptionHandlerCall( (uint64_t)v25,  0,  "/Library/Caches/com.apple.xbs/Sources/Bom/Storage/BOMStorage.c",  323,  *v26);
    }

    BOMStreamFree(v9);
    goto LABEL_20;
  }

  uint64_t v18 = (FILE *)*MEMORY[0x1895F89D0];
  int v19 = __error();
  dispatch_group_t v20 = strerror(*v19);
  fprintf(v18, "can't open %s: %s\n", a1, v20);
  return 0LL;
}

        ;
      }
    }

    uint64_t v12 = CFStringCreateByCombiningStrings(alloc, MutableCopy, @"/");
    CFRelease(MutableCopy);
    uint64_t v9 = v27;
    goto LABEL_51;
  }

  uint64_t v25 = CFStringCreateWithCString(v10, cStr, 0x600u);
  if (v25)
  {
    uint64_t v12 = v25;
    uint64_t v9 = 3071;
    if ((v5 & 1) == 0) {
      goto LABEL_51;
    }
    goto LABEL_35;
  }

  return 1LL;
}

    ++v15;
    a3 = v38;
    rlimit v13 = v62;
    if (v15 == v61) {
      return v13;
    }
  }

  int v60 = (char *)BOM_malloczero((4 * v42 + 4) & 0x3FFFFFFFCLL);
  if (!v60) {
    return 0LL;
  }
  uint64_t v56 = v43;
  uint64_t v57 = a4;
  size_t v44 = 0LL;
  int v59 = 4LL * v43;
  while (1)
  {
    size_t v45 = (const __CFString *)CFArrayGetValueAtIndex(v40, v15);
    if (!v45 || (int v46 = v45, v47 = CFStringGetTypeID(), v47 != CFGetTypeID(v46)))
    {
      v55 = v58;
      if (!*(void *)(v58 + 56)) {
        goto LABEL_73;
      }
      snprintf(__str, 0x800uLL, "can't read fallback arch #%d from fallback archs list");
LABEL_69:
      (*(void (**)(uint64_t, char *))(v55 + 56))(v55, __str);
      goto LABEL_73;
    }

    uint64_t v48 = (char *)BOMCFStringGetUTF8String(v46);
    if (!v48)
    {
      v55 = v58;
      if (!*(void *)(v58 + 56)) {
        goto LABEL_73;
      }
      snprintf(__str, 0x800uLL, "can't convert fallback arch #%d from fallback archs listinto UTF8 encoded C string");
      goto LABEL_69;
    }

    size_t v49 = v48;
    int v50 = BOMGetArchInfoFromName(v48);
    if (!v50) {
      break;
    }
    unsigned int v51 = v50;
    free(v49);
    *(_DWORD *)&v60[v44] = *((_DWORD *)v51 + 3);
    v44 += 4LL;
    if (v59 == v44)
    {
      _DWORD *v36 = v60;
      a4 = v57;
      *int v37 = v56;
      goto LABEL_49;
    }
  }

  if (*(void *)(v58 + 56))
  {
    snprintf(__str, 0x800uLL, "can't get arch info for '%s'", v49);
    (*(void (**)(uint64_t, char *))(v58 + 56))(v58, __str);
  }

  free(v49);
LABEL_73:
  free(v60);
  free(v20);
  free(*v63);
  free(v62);
  rlimit v13 = 0LL;
  unsigned int *v57 = 0;
  return v13;
}

uint64_t BOMBomCommit(uint64_t a1)
{
  if (!a1) {
    return 1LL;
  }
  if (!*(_BYTE *)(a1 + 65)) {
    return 0LL;
  }
  unsigned int NamedBlock = BOMStorageGetNamedBlock(*(void *)(a1 + 8), "BomInfo");
  if (!NamedBlock) {
    return 1LL;
  }
  uint64_t v3 = 1LL;
  uint64_t v4 = BOMStreamWithBlockID(*(void *)(a1 + 8), NamedBlock, (16LL * *(unsigned int *)(a1 + 48)) | 0xC, 1);
  if (v4)
  {
    uint64_t v5 = v4;
    BOMStreamWriteUInt32(v4, 1u);
    BOMStreamWriteUInt32(v5, *(_DWORD *)a1);
    _writeArchInfo(a1, v5);
    if (!BOMStreamFree(v5))
    {
      uint64_t v6 = *(void *)(a1 + 16);
      if (v6) {
        BOMTreeCommit(v6);
      }
      uint64_t v7 = *(void *)(a1 + 24);
      if (v7) {
        BOMBomHLIndexCommit(v7);
      }
      uint64_t v8 = *(void *)(a1 + 32);
      if (v8) {
        BOMBomVIndexCommit(v8);
      }
      uint64_t v9 = *(void *)(a1 + 40);
      if (v9) {
        BOMTreeCommit(v9);
      }
      if (!BOMStorageCommit(*(void *)(a1 + 8)))
      {
        uint64_t v3 = 0LL;
        *(_BYTE *)(a1 + 64) = 0;
      }
    }
  }

  return v3;
}

void *BOMBomPathIDForKey(uint64_t a1, unsigned int a2, char *a3)
{
  return BOMBomPathIDAndArchsForKey(a1, a2, a3, 0LL);
}

void *BOMBomPathIDAndArchsForKey(uint64_t a1, unsigned int a2, char *__s, uint64_t a4)
{
  uint64_t v4 = 0LL;
  if (a1)
  {
    if (__s)
    {
      uint64_t v4 = BOMNewPathKey(a2, __s, &v15);
      if (v4)
      {
        Value = (unsigned int *)BOMTreeGetValue(*(void *)(a1 + 16), v4, v15);
        free(v4);
        if (!Value) {
          return 0LL;
        }
        uint64_t v4 = BOMPathIDFromPathKey(Value);
        if (!a4) {
          return v4;
        }
        unsigned int v8 = BOMBlockIDFromPathValue((uint64_t)Value);
        FSObjectWithBlockID = _BOMBomGetFSObjectWithBlockID(a1, v8);
        if (!FSObjectWithBlockID) {
          return 0LL;
        }
        uint64_t v10 = (uint64_t)FSObjectWithBlockID;
        if (BOMFSObjectType(FSObjectWithBlockID) == 1)
        {
          unsigned int v11 = BOMFSObjectArchCount(v10);
          if (v11)
          {
            uint64_t v12 = 0LL;
            uint64_t v13 = v11;
            do
            {
              *(_DWORD *)(a4 + 4 * v12) = BOMFSObjectGetArch(v10, v12);
              ++v12;
            }

            while (v13 != v12);
          }

          else
          {
            uint64_t v13 = 0LL;
          }

          *(_DWORD *)(a4 + 4 * v13) = 0;
        }

        BOMFSObjectFree(v10);
      }
    }
  }

  return v4;
}

uint64_t BOMBomFSObjectCount(uint64_t result)
{
  if (result) {
    return BOMTreeCount(*(void *)(result + 16));
  }
  return result;
}

char *BOMBomGetRootFSObject(uint64_t a1)
{
  if (!a1) {
    return 0LL;
  }
  int v2 = BOMNewPathKey(0, ".", &v14);
  if (!v2) {
    return 0LL;
  }
  uint64_t v3 = v2;
  unint64_t Value = BOMTreeGetValue(*(void *)(a1 + 16), v2, v14);
  unint64_t v5 = Value;
  if (Value)
  {
    uint64_t v6 = (unsigned int *)Value;
  }

  else
  {
    uint64_t v12 = (char *)BOMTreeIteratorNew(*(void *)(a1 + 16), v3, v14, 0LL);
    free(v3);
    if (!v12) {
      return v12;
    }
    uint64_t v3 = (void *)BOMTreeIteratorKey((uint64_t)v12);
    size_t v14 = BOMTreeIteratorKeySize((uint64_t)v12);
    uint64_t v6 = (unsigned int *)BOMTreeIteratorValue((uint64_t)v12);
    BOMTreeIteratorFree(v12);
    uint64_t v12 = 0LL;
    if (!v3 || !v14 || !v6) {
      return v12;
    }
  }

  unsigned int v7 = BOMBlockIDFromPathValue((uint64_t)v6);
  int v8 = BOMPathIDFromPathKey(v6);
  int v9 = BOMPathIDFromPathKey((unsigned int *)v3);
  uint64_t v10 = (char *)BOMShortNameFromPathKey((uint64_t)v3);
  FSObjectWithBlockID = (char *)_BOMBomGetFSObjectWithBlockID(a1, v7);
  uint64_t v12 = FSObjectWithBlockID;
  if (FSObjectWithBlockID)
  {
    BOMFSObjectSetPathName((uint64_t)FSObjectWithBlockID, v10, 1);
    BOMFSObjectSetShortName((uint64_t)v12, v10, 1);
    BOMFSObjectSetPathID((uint64_t)v12, v8);
    BOMFSObjectSetParentPathID((uint64_t)v12, v9);
    BOMFSObjectSetBlockID((uint64_t)v12, v7);
  }

  if (v5) {
    free(v3);
  }
  return v12;
}

uint64_t BOMBomGetFSObjectAtPath(uint64_t a1, char *__s)
{
  uint64_t v2 = 0LL;
  size_t v18 = 0LL;
  if (a1 && __s)
  {
    size_t v5 = strlen(__s) + 1;
    uint64_t v6 = (char *)BOM_malloc(v5);
    __stringp = v6;
    if (v6)
    {
      unsigned int v7 = v6;
      memmove(v6, __s, v5);
      int v8 = strsep(&__stringp, "/");
      if (v8)
      {
        unsigned int v9 = 0;
        while (1)
        {
          int v10 = v9;
          unsigned int v11 = v8;
          uint64_t v12 = BOMNewPathKey(v9, v8, &v18);
          if (!v12) {
            break;
          }
          uint64_t v13 = v12;
          unint64_t Value = (unsigned int *)BOMTreeGetValue(*(void *)(a1 + 16), v12, v18);
          free(v13);
          if (!Value) {
            break;
          }
          unsigned int v9 = BOMPathIDFromPathKey(Value);
          int v8 = strsep(&__stringp, "/");
          if (!v8)
          {
            unsigned int v15 = BOMBlockIDFromPathValue((uint64_t)Value);
            FSObjectWithBlockID = _BOMBomGetFSObjectWithBlockID(a1, v15);
            uint64_t v2 = (uint64_t)FSObjectWithBlockID;
            if (FSObjectWithBlockID)
            {
              BOMFSObjectSetPathName((uint64_t)FSObjectWithBlockID, __s, 1);
              BOMFSObjectSetShortName(v2, v11, 1);
              BOMFSObjectSetPathID(v2, v9);
              BOMFSObjectSetParentPathID(v2, v10);
              BOMFSObjectSetBlockID(v2, v15);
            }

            goto LABEL_12;
          }
        }
      }

      uint64_t v2 = 0LL;
LABEL_12:
      free(v7);
    }

    else
    {
      return 0LL;
    }
  }

  return v2;
}

uint64_t BOMBomInsertFSObject(unint64_t a1, unsigned int *a2, int a3)
{
  uint64_t v31 = *MEMORY[0x1895F89C0];
  uint64_t v28 = 0LL;
  size_t v29 = 0LL;
  uint64_t result = 0xFFFFFFFFLL;
  if (a1 && a2)
  {
    unsigned int v7 = (const char *)BOMFSObjectPathName((uint64_t)a2);
    __strlcpy_chk();
    int v8 = strrchr(__s, 47);
    if (v8)
    {
      *int v8 = 0;
      unsigned int v9 = _valueAtPath(a1);
      if (!v9)
      {
        fprintf((FILE *)*MEMORY[0x1895F89D0], "parent directory %s does not exist\n", __s);
        return 401LL;
      }

      unsigned int v10 = BOMPathIDFromPathKey(v9);
    }

    else
    {
      unsigned int v10 = 0;
    }

    unsigned int v11 = (char *)BOMFSObjectShortName((uint64_t)a2);
    uint64_t v12 = _valueAtPath(a1);
    if (v12)
    {
      if (!a3) {
        return 0LL;
      }
      uint64_t v13 = (uint64_t)v12;
      unsigned int v14 = BOMPathIDFromPathKey(v12);
      unsigned int v15 = BOMBlockIDFromPathValue(v13);
      if (BOMStorageCopyFromBlockRange(*(void *)(a1 + 8), v15, 0LL, 1uLL, &__dst))
      {
        uint64_t v25 = BOMExceptionHandlerMessage( "BOMBomInsertFSObject failed while getting data for '%s' (parentPathID=%u pathID=%u bid=%u)",  v11,  v10,  v14,  v15);
        uint64_t v26 = __error();
        _BOMFatalException((uint64_t)v25, "/Library/Caches/com.apple.xbs/Sources/Bom/Bom/BOMBom.c", 3022, *v26);
      }

      unsigned int v16 = BOMFSObjectTypeFromRawData(&__dst);
      int v17 = BOMFSObjectType(a2);
      if (v17 == 2 && v16 != 2) {
        return 402LL;
      }
      if (v17 != 2 && v16 == 2) {
        return 403LL;
      }
      FSObjectWithBlockID = _BOMBomGetFSObjectWithBlockID(a1, v15);
      if (FSObjectWithBlockID)
      {
        uint64_t v23 = (uint64_t)FSObjectWithBlockID;
        _removeArchInfoForFSObject(a1, (uint64_t)FSObjectWithBlockID);
        BOMFSObjectFree(v23);
      }

      if (!BOMBomHLIndexCount(*(void *)(a1 + 24), v15)
        || (size_t v24 = strlen(v7),
            BOMBomHLIndexRemove(*(void *)(a1 + 24), v15, v7, v24 + 1),
            !BOMBomHLIndexCount(*(void *)(a1 + 24), v15)))
      {
        int v18 = 0;
        goto LABEL_15;
      }
    }

    else
    {
      unsigned int v14 = (*(_DWORD *)a1)++;
    }

    unsigned int v15 = BOMStorageNewBlock(*(void *)(a1 + 8));
    int v18 = 1;
LABEL_15:
    if (_BOMBomSetFSObjectWithBlockID(a1, (uint64_t)a2, v15))
    {
      fprintf((FILE *)*MEMORY[0x1895F89D0], "can't archive %s\n", v7);
      return 404LL;
    }

    _addArchInfoForFSObject(a1, (uint64_t)a2);
    if (v18)
    {
      int v19 = BOMNewPathKey(v10, v11, &v29);
      dispatch_group_t v20 = BOMNewPathValue(v14, v15, &v28);
      int v21 = BOMTreeSetValue(*(void **)(a1 + 16), v19, v29, (uint64_t)v20, v28);
      free(v19);
      free(v20);
      if (v21)
      {
        fprintf((FILE *)*MEMORY[0x1895F89D0], "can't set path info for %s.\n", v7);
        return 405LL;
      }
    }

    *(_BYTE *)(a1 + 64) = 1;
    BOMBomVIndexInvalidateDiskSpace(*(void *)(a1 + 32));
    return 0LL;
  }

  return result;
}

unint64_t _removeArchInfoForFSObject(unint64_t result, uint64_t a2)
{
  if (*(_DWORD *)(result + 48))
  {
    unint64_t v2 = result;
    if (*(void *)(result + 56))
    {
      if (BOMFSObjectIsBinaryObject(a2))
      {
        uint64_t result = BOMFSObjectArchCount(a2);
        if ((_DWORD)result)
        {
          int v4 = result;
          for (unsigned int i = 0; i != v4; ++i)
          {
            int Arch = BOMFSObjectGetArch(a2, i);
            uint64_t result = BOMFSObjectGetArchSize(a2, i);
            uint64_t v7 = *(unsigned int *)(v2 + 48);
            if (v7 >= 2)
            {
              int v8 = (void *)(*(void *)(v2 + 56) + 32LL);
              uint64_t v9 = v7 - 1;
              while (*((_DWORD *)v8 - 2) != Arch)
              {
                v8 += 3;
                if (!--v9) {
                  goto LABEL_14;
                }
              }

              uint64_t v10 = *v8 - result;
              *int v8 = v10;
            }

LABEL_14:
            ;
          }
        }
      }

      else
      {
        uint64_t result = BOMFSObjectSize(a2);
        uint64_t v11 = *(void *)(v2 + 56);
        unint64_t v12 = *(void *)(v11 + 8);
        BOOL v13 = v12 >= result;
        unint64_t v14 = v12 - result;
        if (!v13) {
          unint64_t v14 = 0LL;
        }
        *(void *)(v11 + 8) = v14;
      }
    }
  }

  return result;
}

      unsigned int v15 = __error();
      unsigned int v16 = *(void (**)(uint64_t, char *, uint64_t))(a1 + 64);
      if (!v16) {
        return 1LL;
      }
      int v17 = *v15;
      int v18 = __s;
      goto LABEL_16;
  }

  int v46 = 0LL;
  size_t v45 = 1;
LABEL_86:
  uint64_t v47 = strlen((const char *)(a1 + 248));
  uint64_t v48 = strlen((const char *)(a1 + 3328));
  size_t v49 = (_BYTE *)(a1 + 3328 + v48);
  int v50 = 1024 - v47;
  unsigned int v51 = 1024 - v48;
  int v52 = (_BYTE *)(a1 + 248 + v47);
  if (v22 == 0x4000) {
    uint64_t result = _copyFromDirToDir(a1, &v65, v52, v50, v49, v51, v13);
  }
  else {
    uint64_t result = _copyFromFileToDir(a1, (uint64_t)&v65, v52, v50, v49, v51, v13, v45);
  }
  if (!(_DWORD)result)
  {
    if (v45 || *(_DWORD *)(a1 + 12716) != 3) {
      return 0LL;
    }
    if (!*(_BYTE *)(a1 + 170) && !*(_BYTE *)(a1 + 169)
      || (v53 = _copyExtendedAttributes(a1, a1 + 248, (uint64_t)&v65, 0, 0LL), uint64_t result = 0LL, !v53))
    {
      if (!*(_BYTE *)(a1 + 171) || (v54 = _copyACLs(a1, (char *)(a1 + 248), 0, 0, 0LL), uint64_t result = 0LL, !v54))
      {
        if (v61
          && (*(unsigned int (**)(void, uint64_t, uint64_t))(*(void *)(a1 + 12832) + 200LL))( *(void *)(*(void *)(a1 + 12832) + 8LL),  a1 + 3328,  v46))
        {
LABEL_99:
          v55 = __error();
          uint64_t v56 = *(void (**)(uint64_t, uint64_t, void))(a1 + 64);
          if (v56) {
            v56(a1, a1 + 3328, *v55);
          }
          return 0LL;
        }

        uint64_t result = set_timestamps_0((const char *)(a1 + 3328), &v63, &v62);
        if ((_DWORD)result)
        {
          if (*__error() == 13 || *__error() == 1)
          {
            int v59 = __error();
            uint64_t result = 0LL;
            *int v59 = 0;
            return result;
          }

          goto LABEL_99;
        }
      }
    }
  }

  return result;
}

      ++v9;
    }

    while (v9 < v8);
  }

  else
  {
    uint64_t v10 = 0;
  }

  int v17 = *(void **)(a1 + 112);
  if (v17) {
    free(v17);
  }
  *(_DWORD *)(a1 + 104) = v10;
  *(void *)(a1 + 112) = v7;
  if (v10 == 1)
  {
    uint64_t result = 0LL;
    *(void *)(a1 + 64) = *((void *)v7 + 1);
    *(_DWORD *)(a1 + 88) = *((_DWORD *)v7 + 4);
    return result;
  }

  return 0LL;
}

    a1[4] = v2;
  }

  return v2;
}

    a1[5] = v2;
  }

  return v2;
}

uint64_t _BOMBomSetFSObjectWithBlockID(uint64_t a1, uint64_t a2, unsigned int a3)
{
  uint64_t v3 = 0xFFFFFFFFLL;
  if (a1 && a2 && a3)
  {
    uint64_t v7 = BOMStorageSizeOfBlock(*(void *)(a1 + 8), a3);
    int64_t v8 = BOMFSObjectArchiveLength(a2);
    if (v8 < 1)
    {
      return 0LL;
    }

    else
    {
      uint64_t v9 = BOMStreamWithBlockID(*(void *)(a1 + 8), a3, v8, 1);
      uint64_t v10 = v9;
      BOMStreamFree(v10);
      if (*(void *)(a1 + 40))
      {
        unsigned int v14 = bswap32(a3);
        int64_t v11 = BOMFSObjectSize(a2);
        if (v11 < 0x100000000LL)
        {
          if (v7) {
            BOMTreeRemoveValue(*(void *)(a1 + 40), &v14, 4uLL);
          }
        }

        else
        {
          unint64_t v13 = bswap64(v11);
          BOMTreeSetValue(*(void **)(a1 + 40), &v14, 4uLL, (uint64_t)&v13, 8LL);
        }
      }
    }
  }

  return v3;
}

uint64_t _addArchInfoForFSObject(uint64_t a1, uint64_t a2)
{
  if (!*(_DWORD *)(a1 + 48) || !*(void *)(a1 + 56))
  {
    *(_DWORD *)(a1 + 48) = 1;
    uint64_t result = (uint64_t)BOM_malloczero(0x18uLL);
    *(void *)(a1 + 56) = result;
    if (!result) {
      return result;
    }
    *(_DWORD *)uint64_t result = 0;
  }

  if (BOMFSObjectIsBinaryObject(a2))
  {
    uint64_t result = BOMFSObjectArchCount(a2);
    if ((_DWORD)result)
    {
      int v5 = result;
      for (unsigned int i = 0; i != v5; ++i)
      {
        int Arch = BOMFSObjectGetArch(a2, i);
        unsigned int ArchSize = BOMFSObjectGetArchSize(a2, i);
        uint64_t v9 = *(unsigned int *)(a1 + 48);
        uint64_t result = *(void *)(a1 + 56);
        if (v9 < 2)
        {
LABEL_12:
          uint64_t result = (uint64_t)BOM_realloczero((void *)result, 24 * v9, 24LL * (v9 + 1));
          *(void *)(a1 + 56) = result;
          if (!result) {
            return result;
          }
          unsigned int v12 = *(_DWORD *)(a1 + 48);
          *(_DWORD *)(a1 + 48) = v12 + 1;
          unint64_t v13 = (_DWORD *)(result + 24LL * v12);
          _DWORD *v13 = Arch;
          uint64_t v10 = v13 + 2;
        }

        else
        {
          uint64_t v10 = (void *)(result + 32);
          uint64_t v11 = v9 - 1;
          while (*((_DWORD *)v10 - 2) != Arch)
          {
            v10 += 3;
            if (!--v11) {
              goto LABEL_12;
            }
          }
        }

        *v10 += ArchSize;
      }
    }
  }

  else
  {
    uint64_t result = BOMFSObjectSize(a2);
    *(void *)(*(void *)(a1 + 56) + 8LL) += result;
  }

  return result;
}

uint64_t BOMBomRemoveFSObject(unint64_t a1, unsigned int *a2)
{
  uint64_t v2 = 0LL;
  if (a1 && a2)
  {
    int v4 = BOMBomEnumeratorNewWithOptions(a1, a2, 2);
    int v5 = BOMBomEnumeratorNext((uint64_t)v4);
    if (v5)
    {
      uint64_t v6 = v5;
      uint64_t v7 = 1LL;
      while (1)
      {
        unsigned int v8 = BOMFSObjectBlockID((uint64_t)v6);
        if (!v8)
        {
          unsigned int v8 = _BOMBlockIDForFSObject(a1, (uint64_t)v6);
          if (!v8) {
            break;
          }
        }

        if (BOMFSObjectGetHardlinkCount(a1, (uint64_t)v6))
        {
          uint64_t v9 = (const char *)BOMFSObjectPathName((uint64_t)v6);
          size_t v10 = strlen(v9);
          BOMBomHLIndexRemove(*(void *)(a1 + 24), v8, v9, v10 + 1);
        }

        unsigned int v11 = BOMFSObjectParentPathID((uint64_t)v6);
        unsigned int v12 = (char *)BOMFSObjectShortName((uint64_t)v6);
        unint64_t v13 = BOMNewPathKey(v11, v12, &v16);
        if (!v13) {
          break;
        }
        unsigned int v14 = v13;
        if (BOMTreeRemoveValue(*(void *)(a1 + 16), v13, v16))
        {
          free(v14);
          break;
        }

        _removeArchInfoForFSObject(a1, (uint64_t)v6);
        *(_BYTE *)(a1 + 64) = 1;
        BOMBomVIndexInvalidateDiskSpace(*(void *)(a1 + 32));
        BOMFSObjectFree((uint64_t)v6);
        free(v14);
        uint64_t v6 = BOMBomEnumeratorNext((uint64_t)v4);
        uint64_t v7 = 0LL;
        uint64_t v2 = 0LL;
        if (!v6) {
          goto LABEL_18;
        }
      }

      uint64_t v2 = v7;
    }

    else
    {
      uint64_t v2 = 1LL;
    }

unsigned int *_BOMBlockIDForFSObject(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (const char *)BOMFSObjectPathName(a2);
  if (!v3) {
    return 0LL;
  }
  int v4 = v3;
  size_t v5 = strlen(v3) + 1;
  uint64_t v6 = (char *)BOM_malloc(v5);
  __stringp = v6;
  if (!v6) {
    return 0LL;
  }
  uint64_t v7 = v6;
  memmove(v6, v4, v5);
  unsigned int v8 = strsep(&__stringp, "/");
  if (v8)
  {
    uint64_t v9 = v8;
    unsigned int v10 = 0;
    while (1)
    {
      unsigned int v11 = BOMNewPathKey(v10, v9, &v15);
      if (!v11) {
        break;
      }
      unsigned int v12 = v11;
      unint64_t Value = (unsigned int *)BOMTreeGetValue(*(void *)(a1 + 16), v11, v15);
      free(v12);
      if (Value)
      {
        unsigned int v10 = BOMPathIDFromPathKey(Value);
        unint64_t Value = (unsigned int *)BOMBlockIDFromPathValue((uint64_t)Value);
        uint64_t v9 = strsep(&__stringp, "/");
        if (v9) {
          continue;
        }
      }

      goto LABEL_11;
    }
  }

  unint64_t Value = 0LL;
LABEL_11:
  free(v7);
  return Value;
}

BOOL BOMFSObjectIsHardlink(uint64_t a1, uint64_t a2)
{
  return BOMFSObjectGetHardlinkCount(a1, a2) != 0;
}

uint64_t BOMBomMergeInto(uint64_t *a1, uint64_t a2)
{
  return BOMBomMergeIntoBomWithPatternList(a1, a2, 0LL);
}

uint64_t BOMBomMergeIntoBomWithPatternList(uint64_t *a1, uint64_t a2, const __CFArray *a3)
{
  uint64_t v16 = *MEMORY[0x1895F89C0];
  __s[0] = 0;
  uint64_t v3 = 1LL;
  if (a1 && a2)
  {
    if (a1 == (uint64_t *)a2)
    {
      uint64_t v3 = 1LL;
      fwrite("boms are identical.\n", 0x14uLL, 1uLL, (FILE *)*MEMORY[0x1895F89D0]);
    }

    else
    {
      size_t v7 = strlen(__s);
      _copyFilesFromBomToBom(a1, (unsigned int *)a2, a3, __s, &__s[v7], 0, 0, 0LL, 1);
      _copyVariantsFromBomToBom((uint64_t)a1, a2, v8, v9, v10, v11, v12, v13);
      BOMBomVIndexInvalidateDiskSpace(*(void *)(a2 + 32));
      return 0LL;
    }
  }

  return v3;
}

uint64_t BOMBomMergeIntoBom(uint64_t *a1, uint64_t a2)
{
  return BOMBomMergeIntoBomWithPatternList(a1, a2, 0LL);
}

uint64_t BOMBomMaskWithBom(unint64_t a1, uint64_t a2)
{
  uint64_t v6 = *MEMORY[0x1895F89C0];
  uint64_t result = 1LL;
  if (a1)
  {
    if (a2)
    {
      v5[0] = 0;
      v4[0] = 0;
      _maskWithBom(a1, v5, v5, 0, a2, v4, v4, 0);
      BOMBomVIndexInvalidateDiskSpace(*(void *)(a1 + 32));
      return 0LL;
    }
  }

  return result;
}

BOOL _maskWithBom( unint64_t a1, char *a2, char *a3, unsigned int a4, uint64_t a5, char *a6, char *a7, unsigned int a8)
{
  uint64_t v16 = BOMNewPathKey(a4, "", &v54);
  if (v16)
  {
    int v17 = v16;
    int v18 = (char *)BOMTreeIteratorNew(*(void *)(a1 + 16), v16, v54, 0LL);
    free(v17);
    if (v18)
    {
      int v19 = BOMNewPathKey(a8, "", &v54);
      if (!v19
        || (dispatch_group_t v20 = v19, v50 = a5, v21 = (char *)BOMTreeIteratorNew(*(void *)(a5 + 16), v19, v54, 0LL), free(v20), !v21))
      {
        BOOL v25 = 0LL;
        int v21 = v18;
LABEL_39:
        BOMTreeIteratorFree(v21);
        return v25;
      }

      int v22 = a2;
      if (a2 != a3)
      {
        *a3 = 47;
        int v22 = a3 + 1;
      }

      unsigned __int8 __dst = v22;
      uint64_t v23 = a6;
      if (a6 != a7)
      {
        *a7 = 47;
        uint64_t v23 = a7 + 1;
      }

      if (BOMTreeIteratorIsAtEnd((uint64_t)v18))
      {
        int v24 = 0;
LABEL_38:
        BOOL v25 = v24 == 0;
        BOMTreeIteratorFree(v18);
        goto LABEL_39;
      }

      uint64_t v26 = v23;
      int v24 = 0;
      int v47 = 0;
      uint64_t v27 = a6;
      uint64_t v28 = 0LL;
      int v46 = v26;
      __s2 = v27;
      uint64_t v45 = v27 - v26 + 1025;
      while (2)
      {
        if (BOMTreeIteratorIsAtEnd((uint64_t)v21)
          || (size_t v29 = (unsigned int *)BOMTreeIteratorKey((uint64_t)v18), BOMPathIDFromPathKey(v29) != a4))
        {
LABEL_36:
          if (v47) {
            *(_BYTE *)(a1 + 64) = 1;
          }
          goto LABEL_38;
        }

        int v52 = v24;
        int v30 = (const char *)BOMShortNameFromPathKey((uint64_t)v29);
        size_t v31 = strlen(v30);
        uint64_t v32 = (unsigned int *)BOMTreeIteratorValue((uint64_t)v18);
        uint64_t v48 = BOMPathIDFromPathKey(v32);
        unsigned int v33 = BOMBlockIDFromPathValue((uint64_t)v32);
        if (BOMStorageCopyFromBlockRange(*(void *)(a1 + 8), v33, 0LL, 1uLL, &v53))
        {
          uint64_t v42 = BOMExceptionHandlerMessage( "_maskWithBom failed while getting data for '%s' (parentPathID=%u pathID=%u bid=%u)",  v30,  a4,  (_DWORD)v48,  v33);
          size_t v43 = __error();
          _BOMFatalException((uint64_t)v42, "/Library/Caches/com.apple.xbs/Sources/Bom/Bom/BOMBom.c", 3363, *v43);
        }

        unsigned int v51 = BOMFSObjectTypeFromRawData(&v53);
        while (1)
        {
          if (BOMTreeIteratorIsAtEnd((uint64_t)v21))
          {
            unsigned int v35 = 0;
            goto LABEL_23;
          }

          unsigned int v34 = (unsigned int *)BOMTreeIteratorKey((uint64_t)v21);
          uint64_t v28 = (const char *)BOMShortNameFromPathKey((uint64_t)v34);
          if ((strcmp(v28, v30) & 0x80000000) == 0) {
            break;
          }
          BOMTreeIteratorNext((uint64_t)v21);
        }

        int v37 = (unsigned int *)BOMTreeIteratorValue((uint64_t)v21);
        unsigned int v35 = BOMPathIDFromPathKey(v37);
LABEL_23:
        if (BOMTreeIteratorIsAtEnd((uint64_t)v21))
        {
LABEL_35:
          int v24 = v52 + 1;
          goto LABEL_36;
        }

        if (!v28 || strcmp(v28, v30)) {
          goto LABEL_26;
        }
        strlcpy(__dst, v30, a2 - __dst + 1025);
        strlcpy(v46, v28, v45);
        if (v51 == 2)
        {
          int v36 = _maskWithBom(a1, a2, &__dst[v31], v48, v50, __s2, &v46[v31], v35);
          __dst[v31] = 0;
          if (!v36) {
            goto LABEL_26;
          }
        }

        else if (strcmp(a2, __s2))
        {
LABEL_26:
          int v24 = v52 + 1;
          goto LABEL_27;
        }

        int v38 = (unsigned int *)BOMTreeIteratorKey((uint64_t)v18);
        uint64_t v39 = (unsigned int *)BOMTreeIteratorValue((uint64_t)v18);
        uint64_t v40 = (unsigned int *)_BOMGetFSObject(a1, v38, v39, a2);
        BOMBomRemoveFSObject(a1, v40);
        BOMFSObjectFree((uint64_t)v40);
        int v47 = 1;
        int v24 = v52;
LABEL_27:
        BOMTreeIteratorNext((uint64_t)v18);
        goto LABEL_36;
      }
    }
  }

  return 0LL;
}

CFIndex BOMBomMaskWithPatternList(unint64_t a1, CFArrayRef theArray)
{
  uint64_t v6 = *MEMORY[0x1895F89C0];
  CFIndex result = 1LL;
  if (a1 && theArray)
  {
    CFIndex result = CFArrayGetCount(theArray);
    if (result)
    {
      v5[0] = 0;
      _maskWithPatternList(a1, theArray, v5, v5, 0);
      BOMBomVIndexInvalidateDiskSpace(*(void *)(a1 + 32));
      return 0LL;
    }
  }

  return result;
}

char *_maskWithPatternList(unint64_t a1, const __CFArray *a2, char *a3, char *a4, unsigned int a5)
{
  CFIndex result = BOMNewPathKey(a5, "", &v35);
  if (!result) {
    return result;
  }
  uint64_t v10 = result;
  uint64_t v11 = (char *)BOMTreeIteratorNew(*(void *)(a1 + 16), result, v35, 0LL);
  free(v10);
  if (!v11) {
    return 0LL;
  }
  unsigned __int8 __dst = a3;
  if (a3 != a4)
  {
    *a4 = 47;
    unsigned __int8 __dst = a4 + 1;
  }

  if (BOMTreeIteratorIsAtEnd((uint64_t)v11))
  {
    BOMTreeIteratorFree(v11);
    unsigned int v12 = 0;
    int v13 = 0;
    goto LABEL_23;
  }

  int v31 = 0;
  int v13 = 0;
  do
  {
    unsigned int v14 = (unsigned int *)BOMTreeIteratorKey((uint64_t)v11);
    size_t v15 = (const char *)BOMShortNameFromPathKey((uint64_t)v14);
    uint64_t v16 = (unsigned int *)BOMTreeIteratorValue((uint64_t)v11);
    int v17 = BOMPathIDFromPathKey(v16);
    unsigned int v18 = BOMBlockIDFromPathValue((uint64_t)v16);
    if (BOMStorageCopyFromBlockRange(*(void *)(a1 + 8), v18, 0LL, 1uLL, &v34))
    {
      size_t v29 = BOMExceptionHandlerMessage( "_maskWithPatternList failed while getting data for '%s' (parentPathID=%u pathID=%u bid=%u)",  v15,  a5,  (_DWORD)v17,  v18);
      int v30 = __error();
      _BOMFatalException((uint64_t)v29, "/Library/Caches/com.apple.xbs/Sources/Bom/Bom/BOMBom.c", 3252, *v30);
    }

    unsigned int v19 = BOMFSObjectTypeFromRawData(&v34);
    strlcpy(__dst, v15, a3 - __dst + 1025);
    size_t v20 = strlen(v15);
    CFIndex Count = CFArrayGetCount(a2);
    if (Count < 1)
    {
LABEL_16:
      if (v19 != 2 || !_maskWithPatternList(a1, a2, a3, &__dst[v20], v17))
      {
        int v28 = 1;
        goto LABEL_20;
      }
    }

    else
    {
      CFIndex v22 = Count;
      CFIndex v23 = 0LL;
      while (1)
      {
        ValueAtIndex = (regex_t *)CFArrayGetValueAtIndex(a2, v23);
        if (ValueAtIndex)
        {
          if (BOMPatternMatch(ValueAtIndex, a3)) {
            break;
          }
        }

        if (v22 == ++v23) {
          goto LABEL_16;
        }
      }
    }

    BOOL v25 = (unsigned int *)BOMTreeIteratorKey((uint64_t)v11);
    uint64_t v26 = (unsigned int *)BOMTreeIteratorValue((uint64_t)v11);
    uint64_t v27 = (unsigned int *)_BOMGetFSObject(a1, v25, v26, a3);
    BOMBomRemoveFSObject(a1, v27);
    BOMFSObjectFree((uint64_t)v27);
    int v28 = 0;
    int v31 = 1;
LABEL_20:
    v13 += v28;
    BOMTreeIteratorNext((uint64_t)v11);
  }

  while (!BOMTreeIteratorIsAtEnd((uint64_t)v11));
  BOMTreeIteratorFree(v11);
  unsigned int v12 = v31;
  if (v31)
  {
    unsigned int v12 = 1;
    *(_BYTE *)(a1 + 64) = 1;
  }

LABEL_23:
  if (v13) {
    return 0LL;
  }
  else {
    return (char *)v12;
  }
}

      int v13 = 1LL;
LABEL_24:
      int v17 = BOMCopierSourceEntryNew(v14, 0LL);
      size_t v15 = (uint64_t)v17;
      if (!v17)
      {
        BOMCopierErrorCapture( a4,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c",  1693,  (uint64_t)"BOMCopierSourceEntryNewFromAppleArchive",  "Could not create BOMCopierSourceEntry from %d",  v14);
        return v15;
      }

      *int v17 = 7;
      *((void *)v17 + 36) = a1;
      *((void *)v17 + 37) = header;
      v17[76] = 5521732;
      FieldCFIndex Count = AAHeaderGetFieldCount(header);
      if (!FieldCount) {
        goto LABEL_42;
      }
      unsigned int v19 = FieldCount;
      size_t v20 = 0;
      break;
  }

  do
  {
    Fieldint Type = AAHeaderGetFieldType(header, v20);
    CFIndex v22 = FieldType;
    if (FieldType < 0)
    {
      BOMCopierErrorCapture( a4,  FieldType,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c",  5501,  (uint64_t)"populate_source_entry_from_apple_archive",  "Could not get field type from AppleArchive header index %u: %d");
      goto LABEL_149;
    }

    FieldKey = AAHeaderGetFieldKey(header, v20);
    if (!FieldKey.ikey)
    {
      BOMCopierErrorCapture( a4,  v22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c",  5508,  (uint64_t)"populate_source_entry_from_apple_archive",  "Could not get field key from AppleArchive header index %u: %u");
      goto LABEL_149;
    }

    if (v22 >= 5)
    {
      if (v22 != 5)
      {
        BOMCopierErrorCapture( a4,  45,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c",  5593,  (uint64_t)"populate_source_entry_from_apple_archive",  "Unknown AppleArchive field type: %u");
        goto LABEL_149;
      }

      int v24 = FieldKey;
      if (FieldKey.ikey != 5521732)
      {
        value[0] = 0LL;
        offset[0] = 0LL;
        FieldBlob = AAHeaderGetFieldBlob(header, v20, value, offset);
        if (FieldBlob < 0)
        {
          BOMCopierErrorCapture( a4,  FieldBlob,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c",  5553,  (uint64_t)"populate_source_entry_from_apple_archive",  "Could not get AppleArchive blob: %d");
          goto LABEL_149;
        }

        uint64_t v26 = v13;
        uint64_t v27 = *(unsigned int *)(v15 + 308);
        int v28 = (char *)realloc(*(void **)(v15 + 312), 32LL * (v27 + 1));
        if (!v28)
        {
          v67 = *__error();
          v68 = __error();
          strerror(*v68);
          BOMCopierErrorCapture( a4,  v67,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c",  5564,  (uint64_t)"populate_source_entry_from_apple_archive",  "Could not allocate blob list: %s");
          goto LABEL_149;
        }

        size_t v29 = &v28[32 * v27];
        *(AAFieldKey *)size_t v29 = v24;
        int v30 = value[0];
        *((void *)v29 + 1) = offset[0];
        *((void *)v29 + 2) = v30;
        int v31 = a3 >> 5;
        if (v24.ikey == 4997953 || (int v31 = a3 >> 2, v24.ikey == 5521752)) {
          v29[24] = v31 & 1;
        }
        *(_DWORD *)(v15 + 308) = v27 + 1;
        *(void *)(v15 + 312) = v28;
        int v13 = v26;
      }
    }

    ++v20;
  }

  while (v19 != v20);
LABEL_42:
  bzero(value, 0x400uLL);
  length = 0LL;
  v32.ikey = 5521744;
  unsigned int v33 = AAHeaderGetKeyIndex(header, v32);
  if ((v33 & 0x80000000) != 0)
  {
    int v36 = 0;
LABEL_89:
    BOMCopierErrorCapture( a4,  v36,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c",  5614,  (uint64_t)"populate_source_entry_from_apple_archive",  "Could not get path from AppleArchive: %d");
    goto LABEL_149;
  }

  unsigned __int8 v34 = (const char *)value;
  FieldString = AAHeaderGetFieldString(header, v33, 0x400uLL, (char *)value, &length);
  if (FieldString <= 1) {
    int v36 = 1;
  }
  else {
    int v36 = FieldString;
  }
  if (v36 <= 0) {
    goto LABEL_89;
  }
  if (!length) {
    unsigned __int8 v34 = ".";
  }
  int v37 = strdup(v34);
  *(void *)(v15 + 24) = v37;
  if (!v37)
  {
    int v62 = *__error();
    uint64_t v63 = __error();
    strerror(*v63);
    BOMCopierErrorCapture( a4,  v62,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c",  5631,  (uint64_t)"populate_source_entry_from_apple_archive",  "Could not duplicate %s: %s");
    goto LABEL_149;
  }

  int v38 = strdup((const char *)value);
  *(void *)(v15 + 16) = v38;
  if (!v38)
  {
    uint64_t v64 = *__error();
    uint64_t v65 = __error();
    strerror(*v65);
    BOMCopierErrorCapture( a4,  v64,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c",  5638,  (uint64_t)"populate_source_entry_from_apple_archive",  "Could not duplicate %s: %s");
    goto LABEL_149;
  }

  if (*(_DWORD *)(v15 + 4) == 9)
  {
    bzero(offset, 0x400uLL);
    size_t v94 = 0LL;
    v39.ikey = 4935244;
    uint64_t v40 = AAHeaderGetKeyIndex(header, v39);
    if ((v40 & 0x80000000) != 0
      || ((uint64_t v41 = AAHeaderGetFieldString(header, v40, 0x400uLL, (char *)offset, &v94), v41 <= 1)
        ? (uint64_t v42 = 1)
        : (uint64_t v42 = v41),
          v42 <= 0))
    {
      uint64_t v66 = *__error();
      BOMCopierErrorCapture( a4,  v66,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c",  5654,  (uint64_t)"populate_source_entry_from_apple_archive",  "Could not get symlink target path: %d");
      goto LABEL_149;
    }

    size_t v43 = strdup((const char *)offset);
    *(void *)(v15 + 48) = v43;
    if (!v43)
    {
      size_t v69 = *__error();
      uint64_t v70 = __error();
      strerror(*v70);
      BOMCopierErrorCapture( a4,  v69,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c",  5661,  (uint64_t)"populate_source_entry_from_apple_archive",  "Could not duplicate %s: %s\n");
      goto LABEL_149;
    }
  }

  size_t v94 = 0LL;
  v44.ikey = 5653828;
  uint64_t v45 = AAHeaderGetKeyIndex(header, v44);
  if ((v45 & 0x80000000) == 0)
  {
    int v46 = AAHeaderGetFieldUInt(header, v45, &v94);
    if (v46 <= 1) {
      int v47 = 1;
    }
    else {
      int v47 = v46;
    }
    if (v47 < 0)
    {
      BOMCopierErrorCapture( a4,  v47,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c",  5674,  (uint64_t)"populate_source_entry_from_apple_archive",  "Could not get AppleArchive device: %d");
LABEL_149:
      BOMCopierErrorCapture( a4,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c",  1706,  (uint64_t)"BOMCopierSourceEntryNewFromAppleArchive",  "Could not populate source entry from AppleArchive");
      goto LABEL_150;
    }

    if (v46 <= 1) {
      *(_DWORD *)(v15 + 64) = v94;
    }
  }

  v48.ikey = 5197385;
  size_t v49 = AAHeaderGetKeyIndex(header, v48);
  if ((v49 & 0x80000000) != 0) {
    goto LABEL_72;
  }
  uint64_t v50 = AAHeaderGetFieldUInt(header, v49, &v94);
  if (v50 <= 1) {
    unsigned int v51 = 1;
  }
  else {
    unsigned int v51 = v50;
  }
  if (v51 < 0)
  {
    BOMCopierErrorCapture( a4,  v51,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c",  5686,  (uint64_t)"populate_source_entry_from_apple_archive",  "Could not get AppleArchive inode: %d");
    goto LABEL_149;
  }

  if (v50 <= 1) {
    *(void *)(v15 + 72) = v94;
  }
LABEL_72:
  v52.ikey = 4934734;
  unsigned __int8 v53 = AAHeaderGetKeyIndex(header, v52);
  if ((v53 & 0x80000000) != 0) {
    goto LABEL_79;
  }
  size_t v54 = AAHeaderGetFieldUInt(header, v53, &v94);
  if (v54 <= 1) {
    v55 = 1;
  }
  else {
    v55 = v54;
  }
  if (v55 < 0)
  {
    BOMCopierErrorCapture( a4,  v55,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c",  5698,  (uint64_t)"populate_source_entry_from_apple_archive",  "Could not get AppleArchive nlink: %d");
    goto LABEL_149;
  }

  if (v54 <= 1) {
    *(_WORD *)(v15 + 80) = v94;
  }
LABEL_79:
  v56.ikey = 4476749;
  uint64_t v57 = AAHeaderGetKeyIndex(header, v56);
  if ((v57 & 0x80000000) != 0) {
    goto LABEL_103;
  }
  uint64_t v58 = AAHeaderGetFieldUInt(header, v57, &v94);
  if (v58 <= 1) {
    int v59 = 1;
  }
  else {
    int v59 = v58;
  }
  if (v59 < 0)
  {
    BOMCopierErrorCapture( a4,  v59,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c",  5710,  (uint64_t)"populate_source_entry_from_apple_archive",  "Could not get AppleArchive mode: %d");
    goto LABEL_149;
  }

  if (v58 <= 1)
  {
    int v60 = v94;
    *(_WORD *)(v15 + 92) = v94;
    size_t v61 = *(_DWORD *)(v15 + 4) - 4;
    if (v61 >= 8 || ((0xF7u >> v61) & 1) == 0)
    {
      BOMCopierErrorCapture( a4,  45,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c",  5757,  (uint64_t)"populate_source_entry_from_apple_archive",  "Unsupported entry type: %u");
      goto LABEL_149;
    }

    *(_WORD *)(v15 + 92) = word_18635AE90[v61] | v60;
  }

  size_t v5 = 1LL;
LABEL_25:
  while (!BOMStackIsEmpty((uint64_t)v12))
  {
    size_t v20 = BOMStackPop(v12);
    *((_WORD *)v20 + 2) &= ~8u;
  }

  BOMStackFree((void **)v12);
  return v5;
}

      if (!a5) {
        goto LABEL_26;
      }
      size_t v20 = v18 == 0;
LABEL_25:
      *a5 = v20;
LABEL_26:
      if (v10 == v9)
      {
        if (v18 <= 0) {
          return v11;
        }
        else {
          return (v11 + 1);
        }
      }

      if (v18 >= 1)
      {
        if ((_DWORD)v11 == v10) {
          v9 += (v10 - v9) >> 1;
        }
        else {
          uint64_t v9 = v11 + 1;
        }
      }

      else
      {
        if ((v18 & 0x80000000) == 0) {
          return v11;
        }
        uint64_t v10 = v11 - ((v10 - v9) > 1);
      }
    }

    unsigned int v12 = 0LL;
LABEL_13:
    unsigned int v14 = 0LL;
    goto LABEL_14;
  }

  uint64_t v11 = 0LL;
  if (a5) {
    *a5 = 0;
  }
  return v11;
}

  *v4 |= 0x40uLL;
  if ((v3 & 0x80) == 0)
  {
LABEL_10:
    if ((v3 & 0x100) == 0) {
      goto LABEL_12;
    }
    goto LABEL_11;
  }

CFDictionaryRef *BOMBomApproximateBytesRepresentedWithBlockSize(CFDictionaryRef *a1, unsigned int a2)
{
  return BOMBomApproximateBytesRepresentedWithBlockSize64(a1, a2);
}

CFDictionaryRef *BOMBomApproximateBytesRepresentedWithBlockSize64(CFDictionaryRef *result, unsigned int a2)
{
  uint64_t v7 = *MEMORY[0x1895F89C0];
  uint64_t v5 = 0LL;
  if (result)
  {
    uint64_t v3 = (uint64_t)result;
    CFIndex result = (CFDictionaryRef *)BOMHardLinkTableNew();
    if (result)
    {
      int v4 = (const void **)result;
      v6[0] = 0;
      _sizeBom(v3, result, v6, v6, 0, a2, &v5);
      BOMHardLinkTableFree(v4);
      return (CFDictionaryRef *)v5;
    }
  }

  return result;
}

void _sizeBom( uint64_t a1, CFDictionaryRef *a2, char *a3, char *a4, unsigned int a5, unsigned int a6, void *a7)
{
  unsigned int v14 = BOMNewPathKey(a5, "", &v31);
  if (v14)
  {
    size_t v15 = v14;
    uint64_t v16 = (char *)BOMTreeIteratorNew(*(void *)(a1 + 16), v14, v31, 0LL);
    free(v15);
    if (v16)
    {
      unsigned int v27 = a6;
      int v28 = a7;
      unsigned __int8 __dst = a3;
      if (a3 != a4)
      {
        *a4 = 47;
        unsigned __int8 __dst = a4 + 1;
      }

      while (!BOMTreeIteratorIsAtEnd((uint64_t)v16))
      {
        int v17 = (unsigned int *)BOMTreeIteratorKey((uint64_t)v16);
        unsigned int v18 = (const char *)BOMShortNameFromPathKey((uint64_t)v17);
        size_t v19 = strlen(v18);
        size_t v20 = (unsigned int *)BOMTreeIteratorValue((uint64_t)v16);
        int v21 = BOMPathIDFromPathKey(v20);
        *(_DWORD *)bytes = BOMBlockIDFromPathValue((uint64_t)v20);
        if (!BOMHardLinkTableGet(a2, 0, *(unsigned int *)bytes))
        {
          BOMHardLinkTableSet(a2, 0, *(unsigned int *)bytes, bytes, 4LL);
          FSObjectWithBlockID = _BOMBomGetFSObjectWithBlockID(a1, *(unsigned int *)bytes);
          int v23 = BOMFSObjectType(FSObjectWithBlockID);
          if (v23 != 4)
          {
            int v24 = v23;
            strlcpy(__dst, v18, a3 - __dst + 1025);
            if (v24 == 2) {
              _sizeBom(a1, a2, a3, &__dst[v19], v21, v27, v28);
            }
            uint64_t v25 = BOMFSObjectSize((uint64_t)FSObjectWithBlockID);
            if (v25 % v27) {
              uint64_t v26 = v27 - v25 % v27;
            }
            else {
              uint64_t v26 = 0LL;
            }
            *v28 += v25 + v26;
            BOMFSObjectFree((uint64_t)FSObjectWithBlockID);
          }
        }

        BOMTreeIteratorNext((uint64_t)v16);
      }

      BOMTreeIteratorFree(v16);
    }
  }

CFDictionaryRef *BOMBomApproximateBytesRepresented(CFDictionaryRef *a1)
{
  return BOMBomApproximateBytesRepresentedWithBlockSize64(a1, 0x200u);
}

CFDictionaryRef *BOMBomApproximateBytesRepresented64(CFDictionaryRef *a1)
{
  return BOMBomApproximateBytesRepresentedWithBlockSize64(a1, 0x200u);
}

uint64_t BOMFSObjectGetHardlinkCount(uint64_t a1, uint64_t a2)
{
  else {
    return 0LL;
  }
}

uint64_t BOMFSObjectGetHardlinkPath(uint64_t a1, uint64_t a2, unsigned int a3, char *a4)
{
  uint64_t result = 0LL;
  uint64_t v12 = *MEMORY[0x1895F89C0];
  if (a1 && a4)
  {
    uint64_t v7 = *(void *)(a1 + 24);
    if (v7)
    {
      uint64_t result = BOMFSObjectBlockID(a2);
      if (!(_DWORD)result) {
        return result;
      }
      unsigned int v9 = result;
      if (BOMBomHLIndexCount(v7, result) > a3
        && !BOMBomHLIndexGet(v7, v9, a3, __source, &v10))
      {
        strlcpy(a4, __source, 0x400uLL);
        return 1LL;
      }
    }

    return 0LL;
  }

  return result;
}

uint64_t BOMBomLinkToPathFromPath(uint64_t a1, char *a2, uint64_t a3)
{
  uint64_t FSObjectAtPath = BOMBomGetFSObjectAtPath(a1, a2);
  return BOMBomLinkToFSObjectFromPath(a1, FSObjectAtPath, a3);
}

uint64_t BOMBomLinkToFSObjectFromPath(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v27 = *MEMORY[0x1895F89C0];
  uint64_t v3 = 1LL;
  if (!a2 || !a1 || !a3) {
    return v3;
  }
  uint64_t v5 = (unsigned int *)a2;
  unsigned int v6 = BOMFSObjectBlockID(a2);
  unsigned int v7 = v6;
  if (v6)
  {
    unsigned int v8 = v6;
LABEL_6:
    if (BOMFSObjectType(v5) != 1 || _valueAtPath(a1))
    {
      uint64_t FSObjectAtPath = 0LL;
      goto LABEL_9;
    }

    __strlcpy_chk();
    int v13 = strrchr(__s, 47);
    unsigned int v14 = v13;
    if (v13)
    {
      char *v13 = 0;
      uint64_t FSObjectAtPath = BOMBomGetFSObjectAtPath(a1, __s);
      *v14++ = 47;
      if (!FSObjectAtPath)
      {
LABEL_9:
        uint64_t v3 = 1LL;
        if (v7) {
          goto LABEL_10;
        }
        goto LABEL_19;
      }
    }

    else
    {
      uint64_t FSObjectAtPath = BOMBomGetFSObjectAtPath(a1, __s);
      if (!FSObjectAtPath) {
        goto LABEL_9;
      }
    }

    unsigned int v16 = BOMFSObjectPathID(FSObjectAtPath);
    unsigned int v17 = (*(_DWORD *)a1)++;
    unsigned int v18 = BOMNewPathKey(v16, v14, &v25);
    size_t v19 = BOMNewPathValue(v17, v8, &v24);
    int v20 = BOMTreeSetValue(*(void **)(a1 + 16), v18, v25, (uint64_t)v19, v24);
    free(v18);
    free(v19);
    if (!v20)
    {
      size_t v21 = strlen(__s);
      BOMBomHLIndexSet(*(void *)(a1 + 24), v8, __s, v21 + 1);
      CFIndex v22 = (const char *)BOMFSObjectPathName((uint64_t)v5);
      size_t v23 = strlen(v22);
      BOMBomHLIndexSet(*(void *)(a1 + 24), v8, v22, v23 + 1);
      uint64_t v3 = 0LL;
      if (v7)
      {
LABEL_10:
        if (!FSObjectAtPath) {
          return v3;
        }
        goto LABEL_20;
      }

      goto LABEL_19;
    }

    goto LABEL_9;
  }

  size_t v10 = (char *)BOMFSObjectPathName((uint64_t)v5);
  uint64_t v11 = BOMBomGetFSObjectAtPath(a1, v10);
  if (!v11) {
    return v3;
  }
  uint64_t v5 = (unsigned int *)v11;
  unsigned int v12 = BOMFSObjectBlockID(v11);
  if (v12)
  {
    unsigned int v8 = v12;
    goto LABEL_6;
  }

  uint64_t FSObjectAtPath = 0LL;
LABEL_19:
  BOMFSObjectFree((uint64_t)v5);
  if (FSObjectAtPath) {
LABEL_20:
  }
    BOMFSObjectFree(FSObjectAtPath);
  return v3;
}

uint64_t BOMBomDumpLinks(uint64_t result)
{
  uint64_t v9 = *MEMORY[0x1895F89C0];
  if (result)
  {
    uint64_t v1 = *(void *)(result + 24);
    if (v1)
    {
      uint64_t result = BOMBomHLIndexCount(*(void *)(result + 24), 0);
      if ((_DWORD)result)
      {
        int v2 = result;
        for (unsigned int i = 0; i != v2; ++i)
        {
          uint64_t result = BOMBomHLIndexBlock(v1, i);
          if ((_DWORD)result)
          {
            unsigned int v4 = result;
            int v5 = BOMBomHLIndexCount(v1, result);
            uint64_t result = printf("hardlink group #%d: (%d links)\n", v4, v5);
            if (v5)
            {
              for (unsigned int j = 0; j != v5; ++j)
              {
                uint64_t result = BOMBomHLIndexGet(v1, v4, j, v8, &v7);
                if (!(_DWORD)result) {
                  uint64_t result = printf("    %s\n", v8);
                }
              }
            }
          }
        }
      }
    }
  }

  return result;
}

uint64_t BOMBomVariantAdd( uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, const char *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t result = 1LL;
  if (a1 && a2 && a3 && a4 && a5)
  {
    uint64_t result = BOMBomVIndexSet(*(void *)(a1 + 32), a2, a3, a4, a5, a6, a7, a8);
    if (!(_DWORD)result) {
      *(_BYTE *)(a1 + 64) = 1;
    }
  }

  return result;
}

uint64_t BOMBomVariantGetList( uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, CFMutableArrayRef *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1 && a2 && a3 && a4) {
    return BOMBomVIndexGetList(*(void *)(a1 + 32), a2, a3, a4, a5, a6, a7, a8);
  }
  else {
    return 1LL;
  }
}

uint64_t BOMBomVariantCount( uint64_t result, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (result) {
    return BOMBomVIndexCount(*(void *)(result + 32), a2, a3, a4, a5, a6, a7, a8);
  }
  return result;
}

uint64_t BOMBomVariantGet( uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, unsigned int a5, char *a6, uint64_t a7, uint64_t a8)
{
  if (a1) {
    return BOMBomVIndexGet(*(void *)(a1 + 32), a2, a3, a4, a5, a6, 0x64uLL, a8);
  }
  else {
    return 1LL;
  }
}

uint64_t BOMBomVariantRemove( uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, const char *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1) {
    return BOMBomVIndexRemove(*(void *)(a1 + 32), a2, a3, a4, a5, a6, a7, a8);
  }
  else {
    return 1LL;
  }
}

uint64_t BOMBomApproximateBytesRepresentedByVariantWithBlockSize( uint64_t *a1, const char *a2, uint64_t a3, uint64_t a4, unsigned int *a5, unsigned int a6)
{
  uint64_t v80 = *MEMORY[0x1895F89C0];
  if (!a1) {
    return 1LL;
  }
  if (!BOMBomVIndexDiskSpaceInfoIsValid(a1[4]))
  {
    value = 0LL;
    CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x189604DB0], 0LL, 0LL, 0LL);
    if (Mutable)
    {
      theDict = Mutable;
      uint64_t v70 = a2;
      int v17 = BOMBomVIndexCount(a1[4], 0LL, 0LL, 0LL, v16, v12, v13, v14);
      int v19 = v17;
      uint64_t v71 = a3;
      if (v17 < 101)
      {
        if (v17 < 1)
        {
LABEL_19:
          uint64_t v68 = a4;
          size_t v69 = a5;
          CFIndex Count = CFDictionaryGetCount(theDict);
          int v46 = (const void **)BOM_malloczero(8 * Count + 8);
          CFDictionaryGetKeysAndValues(theDict, v46, 0LL);
          int v47 = BOM_malloczero(8 * Count + 8);
          int v73 = BOMBomEnumeratorNew((uint64_t)a1, 0LL);
          uint64_t v48 = BOMBomEnumeratorNext((uint64_t)v73);
          if (v48)
          {
            size_t v49 = v48;
            uint64_t v50 = a6;
            do
            {
              unsigned int v51 = (const char *)BOMFSObjectPathName((uint64_t)v49);
              uint64_t v52 = BOMFSObjectSize((uint64_t)v49);
              if (v52 % v50) {
                uint64_t v53 = v50 - v52 % v50;
              }
              else {
                uint64_t v53 = 0LL;
              }
              uint64_t v54 = v53 + v52;
              if (Count < 1) {
                goto LABEL_33;
              }
              uint64_t v55 = 0LL;
              char v56 = 1;
              do
              {
                while (BOMPatternListMatch((const __CFArray *)v46[v55], v51))
                {
                  char v56 = 0;
                  v47[v55] += v54;
                  if (Count - 1 == v55++) {
                    goto LABEL_34;
                  }
                }

                ++v55;
              }

              while (Count != v55);
              if ((v56 & 1) != 0) {
LABEL_33:
              }
                v47[Count] += v54;
LABEL_34:
              BOMFSObjectFree((uint64_t)v49);
              size_t v49 = BOMBomEnumeratorNext((uint64_t)v73);
            }

            while (v49);
          }

          BOMBomEnumeratorFree(v73);
          if (Count < 1)
          {
            BOMBomVIndexSetApproxDiskSpace(a1[4], 0LL, 0LL, 0LL, v47[Count], v58, v59, v60);
            free(v47);
            a4 = v68;
            a5 = v69;
            int v62 = theDict;
          }

          else
          {
            uint64_t v61 = 0LL;
            a4 = v68;
            a5 = v69;
            int v62 = theDict;
            do
            {
              value = (void *)CFDictionaryGetValue(theDict, v46[v61]);
              BOMBomVIndexSetApproxDiskSpaceWithKey(a1[4], (char *)value, v47[v61++]);
            }

            while (Count != v61);
            BOMBomVIndexSetApproxDiskSpace(a1[4], 0LL, 0LL, 0LL, v47[Count], v63, v64, v65);
            free(v47);
            do
            {
              value = (void *)CFDictionaryGetValue(theDict, *v46);
              free(value);
              uint64_t v66 = *v46++;
              CFRelease(v66);
              --Count;
            }

            while (Count);
          }

          v67 = v62;
LABEL_44:
          CFRelease(v67);
          a2 = v70;
          a3 = v71;
          return BOMBomVIndexGetApproxDiskSpace(a1[4], a2, a3, a4, a5, v12, v13, v14);
        }
      }

      else
      {
        int v20 = BOMExceptionHandlerMessage( "_computeVariantSizes(bom=%p, blockSize=%u): catcnt(%d) > catmax(%d)!",  a1,  a6,  v17,  100);
        size_t v21 = __error();
        _BOMExceptionHandlerCall((uint64_t)v20, 1, "/Library/Caches/com.apple.xbs/Sources/Bom/Bom/BOMBom.c", 3818, *v21);
      }

      unsigned int v23 = 0;
      int v72 = v19;
      while (1)
      {
        BOMBomVIndexGet(a1[4], 0LL, 0LL, 0LL, v23, v79, 0x64uLL, v18);
        int v28 = BOMBomVIndexCount(a1[4], v79, 0LL, 0LL, v24, v25, v26, v27);
        if (v28 >= 1) {
          break;
        }
LABEL_18:
        if (++v23 == v72) {
          goto LABEL_19;
        }
      }

      int v29 = v28;
      unsigned int v30 = 0;
      while (1)
      {
        BOMBomVIndexGet(a1[4], v79, 0LL, 0LL, v30, v78, 0x64uLL, v18);
        int v35 = BOMBomVIndexCount(a1[4], v79, (uint64_t)v78, 0LL, v31, v32, v33, v34);
        if (v35 >= 1) {
          break;
        }
LABEL_17:
        if (++v30 == v29) {
          goto LABEL_18;
        }
      }

      int v36 = v35;
      unsigned int v37 = 0;
      while (1)
      {
        CFTypeRef cf = 0LL;
        BOMBomVIndexGet(a1[4], v79, (uint64_t)v78, 0LL, v37, v77, 0x64uLL, v18);
        if (BOMBomVIndexGetList( a1[4],  v79,  (uint64_t)v78,  (uint64_t)v77,  (CFMutableArrayRef *)&cf,  v41,  v42,  v43)) {
          break;
        }
        size_t v44 = BOMPatternListFromStringList(cf);
        CFRelease(cf);
        if (!v44) {
          break;
        }
        CFDictionarySetValue(theDict, v44, value);
        if (v36 == ++v37) {
          goto LABEL_17;
        }
      }

      v67 = theDict;
      goto LABEL_44;
    }
  }

  return BOMBomVIndexGetApproxDiskSpace(a1[4], a2, a3, a4, a5, v12, v13, v14);
}

uint64_t BOMBomApproximateBytesRepresentedByVariantWithBlockSize64( uint64_t *a1, const char *a2, uint64_t a3, uint64_t a4, void *a5, unsigned int a6)
{
  unsigned int v8 = 0;
  uint64_t result = BOMBomApproximateBytesRepresentedByVariantWithBlockSize(a1, a2, a3, a4, &v8, a6);
  *a5 = v8;
  return result;
}

uint64_t BOMBomApproximateBytesRepresentedByVariant( uint64_t *a1, const char *a2, uint64_t a3, uint64_t a4, unsigned int *a5)
{
  return BOMBomApproximateBytesRepresentedByVariantWithBlockSize(a1, a2, a3, a4, a5, 0x200u);
}

uint64_t BOMBomApproximateBytesRepresentedByVariant64( uint64_t *a1, const char *a2, uint64_t a3, uint64_t a4, void *a5)
{
  uint64_t result = BOMBomApproximateBytesRepresentedByVariantWithBlockSize(a1, a2, a3, a4, &v7, 0x200u);
  if (!(_DWORD)result) {
    *a5 = v7;
  }
  return result;
}

uint64_t BOMBomApproximateBytesRepresentedByVariantIsValid(uint64_t result)
{
  if (result) {
    return BOMBomVIndexDiskSpaceInfoIsValid(*(void *)(result + 32));
  }
  return result;
}

uint64_t BOMBomEInsertFSObject(unint64_t a1, uint64_t a2, unsigned int a3, unsigned int *a4)
{
  uint64_t v4 = 1LL;
  if (!a1 || !a2) {
    return v4;
  }
  uint64_t v9 = (const char *)BOMFSObjectPathName(a2);
  size_t v10 = (char *)BOMFSObjectShortName(a2);
  uint64_t v11 = BOMNewPathKey(a3, v10, &v25);
  if (!v11) {
    return 1LL;
  }
  uint64_t v12 = v11;
  unint64_t Value = (unsigned int *)BOMTreeGetValue(*(void *)(a1 + 16), v11, v25);
  uint64_t v14 = (uint64_t)Value;
  if (Value)
  {
    unsigned int v23 = a4;
    size_t v15 = v9;
    unsigned int v16 = BOMPathIDFromPathKey(Value);
    unsigned int v17 = BOMBlockIDFromPathValue(v14);
    FSObjectWithBlockID = _BOMBomGetFSObjectWithBlockID(a1, v17);
    if (FSObjectWithBlockID)
    {
      uint64_t v19 = (uint64_t)FSObjectWithBlockID;
      _removeArchInfoForFSObject(a1, (uint64_t)FSObjectWithBlockID);
      BOMFSObjectFree(v19);
    }

    unsigned int v20 = v16;
    uint64_t v9 = v15;
    a4 = v23;
  }

  else
  {
    unsigned int v20 = (*(_DWORD *)a1)++;
    unsigned int v17 = BOMStorageNewBlock(*(void *)(a1 + 8));
  }

  if (_BOMBomSetFSObjectWithBlockID(a1, a2, v17))
  {
    fprintf((FILE *)*MEMORY[0x1895F89D0], "can't archive %s\n", v9);
    size_t v21 = 0LL;
    uint64_t v4 = 1LL;
LABEL_17:
    free(v12);
    goto LABEL_18;
  }

  _addArchInfoForFSObject(a1, a2);
  if (v14)
  {
    size_t v21 = 0LL;
    goto LABEL_14;
  }

  free(v12);
  uint64_t v12 = BOMNewPathKey(a3, v10, &v25);
  size_t v21 = BOMNewPathValue(v20, v17, &v24);
  if (!BOMTreeSetValue(*(void **)(a1 + 16), v12, v25, (uint64_t)v21, v24))
  {
LABEL_14:
    *(_BYTE *)(a1 + 64) = 1;
    uint64_t v4 = 0LL;
    if (a4) {
      *a4 = v20;
    }
    if (!v12) {
      goto LABEL_18;
    }
    goto LABEL_17;
  }

  fprintf((FILE *)*MEMORY[0x1895F89D0], "can't set path info for %s.\n", v9);
  uint64_t v4 = 1LL;
  if (v12) {
    goto LABEL_17;
  }
LABEL_18:
  if (v21) {
    free(v21);
  }
  return v4;
}

uint64_t BOMBomELinkFromPathToPath(uint64_t a1, const char *a2, const char *a3, unsigned int a4)
{
  uint64_t v4 = 1LL;
  if (a2)
  {
    if (a1)
    {
      if (a3)
      {
        uint64_t v9 = _valueAtPath(a1);
        if (v9)
        {
          unsigned int v10 = BOMBlockIDFromPathValue((uint64_t)v9);
          if (v10)
          {
            unsigned int v11 = v10;
            uint64_t v12 = strrchr(a3, 47);
            if (v12) {
              uint64_t v13 = v12 + 1;
            }
            else {
              uint64_t v13 = (char *)a3;
            }
            uint64_t v14 = BOMNewPathKey(a4, v13, &v25);
            if (v14)
            {
              size_t v15 = v14;
              unint64_t Value = BOMTreeGetValue(*(void *)(a1 + 16), v14, v25);
              unint64_t v17 = Value;
              if (Value)
              {
                uint64_t v18 = 8LL;
                uint64_t v24 = 8LL;
                uint64_t v19 = (_DWORD *)Value;
              }

              else
              {
                unsigned int v20 = (*(_DWORD *)a1)++;
                uint64_t v19 = BOMNewPathValue(v20, v11, &v24);
                uint64_t v18 = v24;
              }

              if (BOMTreeSetValue(*(void **)(a1 + 16), v15, v25, (uint64_t)v19, v18))
              {
                uint64_t v4 = 1LL;
              }

              else
              {
                size_t v21 = strlen(a3);
                BOMBomHLIndexSet(*(void *)(a1 + 24), v11, a3, v21 + 1);
                size_t v22 = strlen(a2);
                BOMBomHLIndexSet(*(void *)(a1 + 24), v11, a2, v22 + 1);
                uint64_t v4 = 0LL;
              }

              free(v15);
              if (!v17) {
                free(v19);
              }
            }

            else
            {
              return 1LL;
            }
          }
        }
      }
    }
  }

  return v4;
}

uint64_t BOMBomEInvalidateCachedData(uint64_t a1)
{
  return 0LL;
}

uint64_t _BOMBomPrintDiagnostics(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = (uint64_t *)result;
    int v2 = (FILE **)MEMORY[0x1895F89D0];
    fprintf((FILE *)*MEMORY[0x1895F89D0], "Tree: %s\n", "Paths");
    _BOMTreePrintDiagnostics(v1[2]);
    _BOMBomHLIndexPrintDiagnostics(v1[3]);
    _BOMBomVIndexPrintDiagnostics(v1[4], v3, v4, v5, v6, v7, v8, v9);
    fwrite("Storage:\n", 9uLL, 1uLL, *v2);
    return _BOMStoragePrintDiagnostics(v1[1]);
  }

  return result;
}

uint64_t BOMBomVerifyBom(uint64_t a1, char a2)
{
  if (a1)
  {
    uint64_t v4 = *(void *)(a1 + 16);
    if (v4)
    {
      if (!BOMTreeVerifyLeaves(v4))
      {
        int v9 = *__error();
        unsigned int v10 = "BOMBomVerifyBom: leaves do not verify.\n";
        char v11 = a2;
        int v12 = 4300;
        goto LABEL_12;
      }

      uint64_t v4 = *(void *)(a1 + 16);
    }

    int v5 = BOMTreeCount(v4);
    uint64_t v6 = (char *)BOMTreeIteratorNew(*(void *)(a1 + 16), 0LL, 0LL, 0LL);
    int v7 = 0;
    while (!BOMTreeIteratorIsAtEnd((uint64_t)v6))
    {
      ++v7;
      BOMTreeIteratorNext((uint64_t)v6);
    }

    BOMTreeIteratorFree(v6);
    if (v7 == v5) {
      return 1LL;
    }
    int v9 = *__error();
    unsigned int v10 = "BOMBomVerifyBom: count is wrong.\n";
    char v11 = a2;
    int v12 = 4316;
  }

  else
  {
    int v9 = *__error();
    unsigned int v10 = "BOMBomVerifyBom: bom is NULL.\n";
    char v11 = a2;
    int v12 = 4293;
  }

void _addPathsToList( uint64_t a1, const char *a2, __CFArray *a3, const char **a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8 = a6;
  int v9 = a5;
  uint64_t v28 = *MEMORY[0x1895F89C0];
  int v14 = BOMBomVIndexCount(*(void *)(a1 + 32), a2, 0LL, 0LL, a5, a6, a7, a8);
  if (v14)
  {
    int v16 = v14;
    unsigned int v17 = 0;
    uint64_t v18 = kBOMBomVariantExtra;
    if (!v9) {
      uint64_t v18 = &kBOMBomVariantException;
    }
    uint64_t v19 = (uint64_t)*v18;
    do
    {
      if (!BOMBomVIndexGet(*(void *)(a1 + 32), a2, 0LL, 0LL, v17, __s2, 0x64uLL, v15))
      {
        if (a4)
        {
          size_t v22 = a4;
          while (1)
          {
            unsigned int v23 = *v22;
            if (!*v22) {
              break;
            }
            ++v22;
            if (!strcmp(v23, __s2))
            {
              if (v8) {
                goto LABEL_6;
              }
              goto LABEL_15;
            }
          }
        }

        if (v8)
        {
LABEL_15:
          CFTypeRef cf = 0LL;
          if (!BOMBomVIndexGetList( *(void *)(a1 + 32),  a2,  (uint64_t)__s2,  v19,  (CFMutableArrayRef *)&cf,  v20,  v21,  v15))
          {
            uint64_t v24 = (const __CFArray *)cf;
            v29.location = BOMCFArrayMaxRange((const __CFArray *)cf);
            v29.length = v25;
            CFArrayAppendArray(a3, v24, v29);
            CFRelease(cf);
          }
        }
      }

LABEL_6:
      ++v17;
    }

    while (v17 != v16);
  }

  if (v7) {
    free(v7);
  }
  return v9;
}

void release_discovery_state(uint64_t a1)
{
  if (a1)
  {
    int v2 = *(dispatch_group_s **)(a1 + 24);
    if (v2)
    {
      dispatch_group_wait(v2, 0xFFFFFFFFFFFFFFFFLL);
      dispatch_release(*(dispatch_object_t *)(a1 + 24));
      *(void *)(a1 + 24) = 0LL;
    }

    uint64_t v3 = *(void **)(a1 + 56);
    if (v3)
    {
      free(v3);
      *(void *)(a1 + 56) = 0LL;
    }

    uint64_t v4 = *(const void ***)(a1 + 48);
    if (v4)
    {
      BOMHardLinkTableFree(v4);
      *(void *)(a1 + 48) = 0LL;
    }

    uint64_t v5 = *(void *)(a1 + 64);
    if (v5)
    {
      BOMBomFree(v5);
      *(void *)(a1 + 64) = 0LL;
    }

    uint64_t v6 = *(void **)(a1 + 40);
    if (v6)
    {
      free(v6);
      *(void *)(a1 + 40) = 0LL;
    }

    int v7 = *(uint64_t **)(a1 + 32);
    if (v7)
    {
      while (1)
      {
        int v8 = BOMStackPop(v7);
        if (!v8) {
          break;
        }
        free(v8);
        int v7 = *(uint64_t **)(a1 + 32);
      }

      BOMStackFree(*(void ***)(a1 + 32));
      *(void *)(a1 + 32) = 0LL;
    }

    uint64_t v9 = *(void *)(a1 + 8);
    if (v9)
    {
      do
      {
        uint64_t v10 = *(void *)(v9 + 72);
        uint64_t v11 = *(void *)(v9 + 8);
        if (v11)
        {
          BOMFSObjectFree(v11);
          *(void *)(v9 + 8) = 0LL;
        }

        BOMCopierSourceEntryFree(*(unsigned int **)v9);
        free((void *)v9);
        uint64_t v9 = v10;
      }

      while (v10);
    }

    *(void *)(a1 + 8) = 0LL;
    *(void *)(a1 + 16) = 0LL;
    if (*(void *)a1)
    {
      BOMCopierSourceFree(*(void **)a1);
      *(void *)a1 = 0LL;
    }
  }

uint64_t _BOMGetFSObject(uint64_t a1, unsigned int *a2, unsigned int *a3, char *a4)
{
  unsigned int v8 = BOMBlockIDFromPathValue((uint64_t)a3);
  int v9 = BOMPathIDFromPathKey(a3);
  int v10 = BOMPathIDFromPathKey(a2);
  uint64_t v11 = (char *)BOMShortNameFromPathKey((uint64_t)a2);
  FSObjectWithBlockID = _BOMBomGetFSObjectWithBlockID(a1, v8);
  uint64_t v13 = (uint64_t)FSObjectWithBlockID;
  if (FSObjectWithBlockID)
  {
    BOMFSObjectSetPathName((uint64_t)FSObjectWithBlockID, a4, 1);
    BOMFSObjectSetShortName(v13, v11, 1);
    BOMFSObjectSetPathID(v13, v9);
    BOMFSObjectSetParentPathID(v13, v10);
    BOMFSObjectSetBlockID(v13, v8);
  }

  return v13;
}

void *BOMHardLinkTableNew()
{
  return BOM_malloczero(8uLL);
}

void BOMHardLinkTableFree(const void **a1)
{
  if (a1)
  {
    int v2 = *a1;
    if (v2) {
      CFRelease(v2);
    }
    free(a1);
  }

void BOMHardLinkTableSet(CFDictionaryRef *a1, int a2, uint64_t a3, UInt8 *bytes, CFIndex length)
{
  if (a1)
  {
    if (bytes)
    {
      CFDataRef v8 = CFDataCreate((CFAllocatorRef)*MEMORY[0x189604DB0], bytes, length);
      if (v8)
      {
        CFDataRef v9 = v8;
        BOMHardLinkTableSetCFData(a1, a2, a3, v8);
        CFRelease(v9);
      }

      else
      {
        int v10 = (FILE *)*MEMORY[0x1895F89D0];
        uint64_t v11 = __error();
        int v12 = strerror(*v11);
        fprintf(v10, "CFDataCreate: %s\n", v12);
      }
    }

    else
    {
      BOMHardLinkTableSetCFData(a1, a2, a3, 0LL);
    }
  }

void BOMHardLinkTableSetCFData(CFDictionaryRef *a1, int a2, uint64_t a3, const void *a4)
{
  int valuePtr = a2;
  uint64_t v18 = a3;
  uint64_t v6 = (const __CFAllocator *)*MEMORY[0x189604DB0];
  if (!*a1)
  {
    CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable( (CFAllocatorRef)*MEMORY[0x189604DB0],  0LL,  MEMORY[0x189605240],  MEMORY[0x189605250]);
    if (!Mutable) {
      goto LABEL_15;
    }
    *a1 = Mutable;
  }

  CFNumberRef v8 = CFNumberCreate(v6, kCFNumberSInt32Type, &valuePtr);
  if (!v8)
  {
LABEL_11:
    int v14 = (FILE *)*MEMORY[0x1895F89D0];
    uint64_t v15 = __error();
    strerror(*v15);
    fprintf(v14, "CFNumberCreate: %s\n");
    return;
  }

  CFNumberRef v9 = v8;
  unint64_t Value = (void *)CFDictionaryGetValue(*a1, v8);
  if (!Value)
  {
    CFMutableDictionaryRef v11 = CFDictionaryCreateMutable(v6, 0LL, MEMORY[0x189605240], MEMORY[0x189605250]);
    if (v11)
    {
      unint64_t Value = v11;
      CFDictionarySetValue(*a1, v9, v11);
      CFRelease(Value);
      goto LABEL_8;
    }

    CFRelease(v9);
LABEL_15:
    int v16 = (FILE *)*MEMORY[0x1895F89D0];
    unsigned int v17 = __error();
    strerror(*v17);
    fprintf(v16, "CFDictionaryCreateMutable: %s\n");
    return;
  }

LABEL_8:
  CFRelease(v9);
  CFNumberRef v12 = CFNumberCreate(v6, kCFNumberSInt64Type, &v18);
  if (!v12) {
    goto LABEL_11;
  }
  CFNumberRef v13 = v12;
  if (a4) {
    CFDictionarySetValue((CFMutableDictionaryRef)Value, v12, a4);
  }
  else {
    CFDictionaryRemoveValue((CFMutableDictionaryRef)Value, v12);
  }
  CFRelease(v13);
}

  if (v109) {
    BOMPKZipFree(v109);
  }
  return v17;
}

const UInt8 *BOMHardLinkTableGet(CFDictionaryRef *a1, int a2, uint64_t a3)
{
  if (a1 && (CFCFDataRef Data = (const __CFData *)BOMHardLinkTableGetCFData(a1, a2, a3)) != 0LL) {
    return CFDataGetBytePtr(CFData);
  }
  else {
    return 0LL;
  }
}

const void *BOMHardLinkTableGetCFData(CFDictionaryRef *a1, int a2, uint64_t a3)
{
  int valuePtr = a2;
  uint64_t v12 = a3;
  if (!*a1) {
    return 0LL;
  }
  uint64_t v4 = (const __CFAllocator *)*MEMORY[0x189604DB0];
  CFNumberRef v5 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x189604DB0], kCFNumberSInt32Type, &valuePtr);
  if (!v5) {
    return 0LL;
  }
  CFNumberRef v6 = v5;
  unint64_t Value = (const __CFDictionary *)CFDictionaryGetValue(*a1, v5);
  CFRelease(v6);
  if (!Value) {
    return 0LL;
  }
  CFNumberRef v8 = CFNumberCreate(v4, kCFNumberSInt64Type, &v12);
  if (!v8) {
    return 0LL;
  }
  CFNumberRef v9 = v8;
  int v10 = CFDictionaryGetValue(Value, v8);
  CFRelease(v9);
  return v10;
}

void BOMHardLinkTableSetPathAndData( CFDictionaryRef *a1, int a2, uint64_t a3, char *__s, const void *a5, size_t a6)
{
  if (a1)
  {
    if (__s && a5)
    {
      size_t v12 = strlen(__s) + 1;
      size_t v13 = v12 + a6;
      int v14 = (char *)BOM_malloc(v12 + a6);
      if (v14)
      {
        uint64_t v15 = (UInt8 *)v14;
        strlcpy(v14, __s, v13);
        memmove(&v15[v12], a5, a6);
        CFDataRef v16 = CFDataCreateWithBytesNoCopy( (CFAllocatorRef)*MEMORY[0x189604DB0],  v15,  v13,  (CFAllocatorRef)*MEMORY[0x189604DB8]);
        if (v16)
        {
          CFDataRef v17 = v16;
          BOMHardLinkTableSetCFData(a1, a2, a3, v16);
          CFRelease(v17);
        }

        else
        {
          free(v15);
          uint64_t v18 = (FILE *)*MEMORY[0x1895F89D0];
          uint64_t v19 = __error();
          uint64_t v20 = strerror(*v19);
          fprintf(v18, "CFDataCreate: %s\n", v20);
        }
      }
    }

    else
    {
      BOMHardLinkTableSetCFData(a1, a2, a3, 0LL);
    }
  }

uint64_t BOMHardLinkTableGetPathAndData(CFDictionaryRef *a1, int a2, uint64_t a3, char *a4, void *a5)
{
  uint64_t result = 1LL;
  if (a1 && a4 && a5)
  {
    CFCFDataRef Data = (const __CFData *)BOMHardLinkTableGetCFData(a1, a2, a3);
    if (CFData)
    {
      int v10 = CFData;
      BytePtr = (const char *)CFDataGetBytePtr(CFData);
      size_t Length = CFDataGetLength(v10);
      size_t v13 = strncpy(a4, BytePtr, Length);
      size_t v14 = strlen(v13);
      uint64_t result = 0LL;
      *a5 = &BytePtr[v14 + 1];
    }

    else
    {
      return 1LL;
    }
  }

  return result;
}

void *BOMFSEnumeratorNew(uint64_t a1, __int16 a2, char a3)
{
  return BOMFSEnumeratorNewWithSys(a1, a2, a3, 0LL);
}

void *BOMFSEnumeratorNewWithSys( uint64_t a1, __int16 a2, char a3, void (**a4)(void, uint64_t, uint64_t))
{
  v15[2] = *(char **)MEMORY[0x1895F89C0];
  if (!a1) {
    return 0LL;
  }
  CFNumberRef v8 = BOM_malloczero(0x420uLL);
  if (v8)
  {
    if (!a4) {
      a4 = (void (**)(void, uint64_t, uint64_t))BomSys_default();
    }
    v8[2] = a4;
    if (((unsigned int (*)(void (*)(void, uint64_t, uint64_t), uint64_t))a4[39])(a4[1], a1))
    {
      CFNumberRef v9 = __error();
      int v10 = strerror(*v9);
      CFMutableDictionaryRef v11 = BOMExceptionHandlerMessage("chdir: %s\n", v10);
      size_t v12 = __error();
      _BOMExceptionHandlerCall( (uint64_t)v11,  0,  "/Library/Caches/com.apple.xbs/Sources/Bom/Bom/BOMFSEnumerator.c",  56,  *v12);
    }

    else
    {
      *((_WORD *)v8 + 4) = a2;
      *((_BYTE *)v8 + 10) = a3;
      a4[38](a4[1], (uint64_t)(v8 + 3), 1025LL);
      v15[0] = ".";
      v15[1] = 0LL;
      size_t v14 = fts_open(v15, 92, (int (__cdecl *)(const FTSENT **, const FTSENT **))_sort);
      *CFNumberRef v8 = v14;
      if (v14) {
        return v8;
      }
    }

    free(v8);
    return 0LL;
  }

  return v8;
}

uint64_t _sort(uint64_t a1, uint64_t a2)
{
  return strcmp((const char *)(*(void *)a1 + 104LL), (const char *)(*(void *)a2 + 104LL));
}

FTSENT *BOMFSEnumeratorNext(FTSENT *result)
{
  if (result)
  {
    uint64_t v1 = result;
    do
    {
      uint64_t result = fts_read((FTS *)v1->fts_cycle);
      if (!result) {
        return result;
      }
      int fts_info = result->fts_info;
    }

    while (fts_info == 6);
    int fts_errno = result->fts_errno;
    if (fts_errno)
    {
      *__error() = fts_errno;
      uint64_t v4 = __error();
      CFNumberRef v5 = strerror(*v4);
      CFNumberRef v6 = BOMExceptionHandlerMessage("fts_read: %s\n", v5);
      int v7 = __error();
      _BOMExceptionHandlerCall( (uint64_t)v6,  0,  "/Library/Caches/com.apple.xbs/Sources/Bom/Bom/BOMFSEnumerator.c",  94,  *v7);
      return 0LL;
    }

    if (!BYTE2(v1->fts_parent)) {
      return (FTSENT *)BOMFSObjectNewFromPathWithSys(result->fts_path, (__int16)v1->fts_parent, v1->fts_link);
    }
    if (result->fts_info > 7u)
    {
      if (fts_info == 8)
      {
        __int16 v8 = 0x8000;
        goto LABEL_19;
      }

      if (fts_info == 12)
      {
        __int16 v8 = -24576;
        goto LABEL_19;
      }
    }

    else
    {
      if (fts_info == 1)
      {
        __int16 v8 = 0x4000;
        goto LABEL_19;
      }

      if (fts_info == 3)
      {
        __int16 v8 = 24576;
LABEL_19:
        __int16 v10 = v8;
        return (FTSENT *)BOMFSObjectNewFromPathDeferredWithSys( (uint64_t)v9,  result->fts_path,  (__int16)v1->fts_parent,  (const char *)&v1->fts_number,  0,  v1->fts_link);
      }
    }

    __int16 v8 = 0;
    goto LABEL_19;
  }

  return result;
}

void BOMFSEnumeratorFree(FTS **a1)
{
  if (a1)
  {
    int v2 = *a1;
    if (v2) {
      fts_close(v2);
    }
    free(a1);
  }

_DWORD *BOMBomVIndexNew(uint64_t a1)
{
  int v2 = BOM_malloczero(0x30uLL);
  uint64_t v3 = v2;
  if (v2)
  {
    *int v2 = 1;
    int v4 = BOMStorageNewNamedBlock(a1, "VIndex");
    if (!v4) {
      goto LABEL_7;
    }
    *((void *)v3 + 2) = a1;
    v3[6] = v4;
    unsigned int v5 = BOMStorageNewBlock(a1);
    if (!v5) {
      goto LABEL_7;
    }
    unsigned int v6 = v5;
    int v7 = BOMTreeNewWithOptions(a1, v5, "VIndex", 0x80u, 0);
    if (!v7) {
      goto LABEL_7;
    }
    *((void *)v3 + 1) = v7;
    uint64_t v8 = BOMStreamWithBlockID(*((void *)v3 + 2), v3[6], 0xDuLL, 1);
    if (v8
      && (CFNumberRef v9 = (int *)v8,
          BOMStreamWriteUInt32(v8, *v3),
          BOMStreamWriteUInt32((uint64_t)v9, v6),
          BOMStreamWriteUInt32((uint64_t)v9, v3[7]),
          BOMStreamWriteUInt8((uint64_t)v9, *((_BYTE *)v3 + 33)),
          !BOMStreamFlush(v9)))
    {
      BOMStreamFree((uint64_t)v9);
    }

    else
    {
LABEL_7:
      BOMBomVIndexFree(v3);
      return 0LL;
    }
  }

  return v3;
}

uint64_t BOMBomVIndexFree(_BYTE *a1)
{
  if (!a1) {
    return 1LL;
  }
  uint64_t v3 = *((void *)a1 + 1);
  if (v3) {
    BOMTreeFree(v3);
  }
  int v4 = (const void *)*((void *)a1 + 5);
  if (v4) {
    CFRelease(v4);
  }
  free(a1);
  return 0LL;
}

void *BOMBomVIndexOpen(uint64_t a1, char a2)
{
  int v4 = BOM_malloczero(0x30uLL);
  if (v4)
  {
    unsigned int NamedBlock = BOMStorageGetNamedBlock(a1, "VIndex");
    if (!NamedBlock) {
      goto LABEL_5;
    }
    v4[2] = a1;
    *((_DWORD *)v4 + 6) = NamedBlock;
    uint64_t v6 = BOMStreamWithBlockID(a1, NamedBlock, 0xDuLL, 0);
    if (!v6) {
      goto LABEL_5;
    }
    uint64_t v7 = v6;
    *(_DWORD *)int v4 = BOMStreamReadUInt32(v6);
    unsigned int UInt32 = BOMStreamReadUInt32(v7);
    *((_DWORD *)v4 + 7) = BOMStreamReadUInt32(v7);
    *((_BYTE *)v4 + 33) = BOMStreamReadUInt8(v7);
    BOMStreamFree(v7);
    uint64_t v9 = BOMTreeOpen(a1, UInt32, a2);
    v4[1] = v9;
    if (!v9)
    {
LABEL_5:
      BOMBomVIndexFree(v4);
      return 0LL;
    }
  }

  return v4;
}

uint64_t BOMBomVIndexCommit(uint64_t a1)
{
  if (!a1) {
    return 1LL;
  }
  if (!*(_BYTE *)(a1 + 32)) {
    return 0LL;
  }
  uint64_t result = BOMStorageIsOpenForWriting(*(void *)(a1 + 16));
  if ((_DWORD)result)
  {
    BOMTreeCommit(*(void *)(a1 + 8));
    uint64_t v3 = BOMStreamWithBlockID(*(void *)(a1 + 16), *(_DWORD *)(a1 + 24), 0xDuLL, 2);
    if (v3
      && (int v4 = (int *)v3,
          BOMStreamReadUInt32(v3),
          BOMStreamReadUInt32((uint64_t)v4),
          BOMStreamWriteUInt32((uint64_t)v4, *(_DWORD *)(a1 + 28)),
          BOMStreamWriteUInt8((uint64_t)v4, *(_BYTE *)(a1 + 33)),
          !BOMStreamFlush(v4)))
    {
      BOMStreamFree((uint64_t)v4);
      uint64_t result = 0LL;
      *(_BYTE *)(a1 + 32) = 0;
    }

    else
    {
      return 1LL;
    }
  }

  return result;
}

uint64_t BOMBomVIndexCopyFromVIndex(uint64_t a1, uint64_t a2)
{
  uint64_t v31 = *MEMORY[0x1895F89C0];
  if (!a1 || !a2)
  {
    uint64_t v14 = 1LL;
    if (a1)
    {
      uint64_t v11 = 0LL;
      uint64_t v12 = 0LL;
      size_t v13 = 0LL;
      goto LABEL_9;
    }

    return v14;
  }

  if (BOMTreeCount(*(void *)(a1 + 8)) || BOMCKTreeBuildKey(__s, v4, v5, v6, v7, v8, v9, v10, "path"))
  {
    uint64_t v11 = 0LL;
    uint64_t v12 = 0LL;
    size_t v13 = 0LL;
    goto LABEL_6;
  }

  int v17 = strlen(__s);
  uint64_t v18 = *(void *)(a1 + 16);
  uint64_t v19 = *(void *)(a2 + 16);
  size_t v13 = (char *)BOMTreeIteratorNew(*(void *)(a2 + 8), 0LL, 0LL, 0LL);
  if (!v13)
  {
LABEL_32:
    uint64_t v11 = 0LL;
    uint64_t v12 = 0LL;
    goto LABEL_6;
  }

  BOMTreeSetDensePacking(*(void *)(a1 + 8), 1);
  if (BOMTreeIteratorIsAtEnd((uint64_t)v13))
  {
LABEL_20:
    uint64_t v11 = 0LL;
    uint64_t v12 = 0LL;
    uint64_t v14 = 0LL;
    *(_BYTE *)(a1 + 33) = *(_BYTE *)(a2 + 33);
    *(_BYTE *)(a1 + 32) = 1;
    goto LABEL_9;
  }

  while (1)
  {
    uint64_t v20 = (const void *)BOMTreeIteratorKey((uint64_t)v13);
    if (BOM_strrncmp((const char *)v20, __s, v17))
    {
      uint64_t v21 = *(void **)(a1 + 8);
      size_t v22 = BOMTreeIteratorKeySize((uint64_t)v13);
      uint64_t v23 = BOMTreeIteratorValue((uint64_t)v13);
      uint64_t v24 = BOMTreeIteratorValueSize((uint64_t)v13);
      goto LABEL_30;
    }

    size_t v25 = strlen((const char *)v20) + 1;
    unint64_t Value = (unsigned int *)BOMTreeGetValue(*(void *)(a2 + 8), v20, v25);
    if (!Value) {
      break;
    }
    uint64_t v12 = BOMTreeOpen(v19, bswap32(*Value), 0);
    if (!v12) {
      goto LABEL_34;
    }
    unsigned int v27 = BOMStorageNewBlock(v18);
    unsigned int v29 = v27;
    if (!v27) {
      goto LABEL_34;
    }
    uint64_t v28 = BOMTreeNewWithOptions(v18, v27, 0LL, 0x80u, 0);
    uint64_t v11 = (uint64_t)v28;
    if (!v28) {
      goto LABEL_6;
    }
    BOMTreeSetDensePacking((uint64_t)v28, 1);
    BOMTreeFree(v12);
    BOMTreeFree(v11);
    unsigned int v29 = bswap32(v29);
    BOMTreeSetValue(*(void **)(a1 + 8), v20, v25, (uint64_t)&v29, 4LL);
LABEL_30:
    BOMTreeIteratorNext((uint64_t)v13);
  }

  uint64_t v12 = 0LL;
LABEL_34:
  uint64_t v11 = 0LL;
LABEL_6:
  uint64_t v14 = 1LL;
LABEL_9:
  uint64_t v15 = *(void *)(a1 + 8);
  if (v15) {
    BOMTreeSetDensePacking(v15, 0);
  }
  if (v12) {
    BOMTreeFree(v12);
  }
  if (v11) {
    BOMTreeFree(v11);
  }
  if (v13) {
    BOMTreeIteratorFree(v13);
  }
  return v14;
}

uint64_t BOMBomVIndexSet( uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, const char *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = 1LL;
  if (a1)
  {
    if (a2)
    {
      if (a3)
      {
        if (a4)
        {
          if (a5)
          {
            uint64_t TreeFor = _v_findTreeFor(a1, 1LL, 1LL, a2, a3, a4, a7, a8);
            if (TreeFor)
            {
              uint64_t v12 = (void *)TreeFor;
              size_t v13 = strlen(a5);
              uint64_t v8 = BOMTreeSetValue(v12, a5, v13 + 1, 0LL, 0LL);
              BOMTreeFree((uint64_t)v12);
              if (!(_DWORD)v8) {
                *(_WORD *)(a1 + 32) = 1;
              }
            }
          }
        }
      }
    }
  }

  return v8;
}

uint64_t _v_findTreeFor( uint64_t a1, uint64_t a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = 0LL;
  uint64_t v20 = *MEMORY[0x1895F89C0];
  if (a4)
  {
    if (a5)
    {
      if (a6)
      {
        int v9 = a3;
        char v10 = a2;
        uint64_t v12 = *(void *)(a1 + 16);
        uint64_t v8 = 0LL;
        if (!BOMCKTreeBuildKey(__s, a2, a3, (uint64_t)a4, a5, a6, a7, a8, a4))
        {
          size_t v13 = strlen(__s) + 1;
          unint64_t Value = (unsigned int *)BOMTreeGetValue(*(void *)(a1 + 8), __s, v13);
          if (Value)
          {
            return BOMTreeOpen(v12, bswap32(*Value), v10);
          }

          else if (v9 && (unsigned int v15 = BOMStorageNewBlock(v12)) != 0)
          {
            unsigned int v16 = v15;
            uint64_t v8 = BOMTreeNewWithOptions(v12, v15, 0LL, 0x80u, 0);
            if (v8)
            {
              unsigned int v18 = bswap32(v16);
              BOMTreeSetValue(*(void **)(a1 + 8), __s, v13, (uint64_t)&v18, 4LL);
            }
          }

          else
          {
            return 0LL;
          }
        }
      }
    }
  }

  return (uint64_t)v8;
}

uint64_t BOMBomVIndexCount( uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    return 0LL;
  }
  uint64_t TreeFor = _v_findTreeFor(a1, 0LL, 0LL, a2, a3, a4, a7, a8);
  if (TreeFor)
  {
    uint64_t v18 = TreeFor;
    uint64_t v19 = BOMTreeCount(TreeFor);
    if (v18 != *(void *)(a1 + 8)) {
      BOMTreeFree(v18);
    }
    return v19;
  }

  return BOMCKTreeCount(*(void *)(a1 + 8), v11, v12, v13, v14, v15, v16, v17, a2);
}

uint64_t BOMBomVIndexGet( uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, unsigned int a5, char *a6, size_t a7, uint64_t a8)
{
  uint64_t result = 1LL;
  if (a1 && a6)
  {
    *a6 = 0;
    uint64_t TreeFor = _v_findTreeFor(a1, 0LL, 0LL, a2, a3, a4, a7, a8);
    if (TreeFor)
    {
      uint64_t v21 = TreeFor;
      size_t v22 = (char *)BOMTreeIteratorNew(v21, 0LL, 0LL, 0LL);
      if (!v22) {
        return 1LL;
      }
      for (unsigned int i = v22; a5; --a5)
        BOMTreeIteratorNext((uint64_t)i);
      uint64_t v24 = (const char *)BOMTreeIteratorKey((uint64_t)i);
      strlcpy(a6, v24, a7);
      BOMTreeIteratorFree(i);
      BOMTreeFree(v21);
    }

    else
    {
      size_t v25 = BOMCKTreeGet(*(void *)(a1 + 8), a5, v15, v16, v17, v18, v19, v20, a2);
      strlcpy(a6, v25, a7);
    }

    return 0LL;
  }

  return result;
}

uint64_t BOMBomVIndexGetList( uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, CFMutableArrayRef *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = 1LL;
  if (a1)
  {
    if (a2)
    {
      if (a3)
      {
        if (a4)
        {
          if (a5)
          {
            if (*a5
              || (CFMutableArrayRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x189604DB0], 0LL, 0LL), (*a5 = Mutable) != 0LL))
            {
              uint64_t TreeFor = _v_findTreeFor(a1, 0LL, 0LL, a2, a3, a4, a7, a8);
              uint64_t v23 = TreeFor;
              if (TreeFor)
              {
                uint64_t v24 = (char *)BOMTreeIteratorNew(TreeFor, 0LL, 0LL, 0LL);
                if (!v24) {
                  goto LABEL_27;
                }
                for (unsigned int i = v24; ; BOMTreeIteratorNext((uint64_t)i))
                {
                  if (BOMTreeIteratorIsAtEnd((uint64_t)i))
                  {
                    uint64_t v8 = 0LL;
                    goto LABEL_25;
                  }

                  uint64_t v26 = (const char *)BOMTreeIteratorKey((uint64_t)i);
                  if (!v26) {
                    break;
                  }
                  unsigned int v27 = v26;
                  size_t v28 = strlen(v26) + 1;
                  unsigned int v29 = (char *)BOM_malloc(v28);
                  if (!v29) {
                    break;
                  }
                  unsigned int v30 = v29;
                  strlcpy(v29, v27, v28);
                  CFArrayAppendValue(*a5, v30);
                }

                uint64_t v8 = 1LL;
LABEL_25:
                BOMTreeIteratorFree(i);
LABEL_26:
                if (v23) {
LABEL_27:
                }
                  BOMTreeFree(v23);
              }

              else
              {
                int v31 = BOMCKTreeCount(*(void *)(a1 + 8), v16, v17, v18, v19, v20, v21, v22, a2);
                if (v31 < 1)
                {
                  return 0LL;
                }

                else
                {
                  int v38 = v31;
                  int v39 = 0;
                  while (1)
                  {
                    uint64_t v40 = BOMCKTreeGet(*(void *)(a1 + 8), v39, v32, v33, v34, v35, v36, v37, a2);
                    if (!v40) {
                      return 1LL;
                    }
                    uint64_t v41 = v40;
                    size_t v42 = strlen(v40) + 1;
                    uint64_t v43 = (char *)BOM_malloc(v42);
                    if (!v43) {
                      return 1LL;
                    }
                    size_t v44 = v43;
                    strlcpy(v43, v41, v42);
                    CFArrayAppendValue(*a5, v44);
                    if (v38 == ++v39)
                    {
                      uint64_t v8 = 0LL;
                      uint64_t v23 = 0LL;
                      goto LABEL_26;
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }

  return v8;
}

uint64_t BOMBomVIndexRemove( uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, const char *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v31 = *MEMORY[0x1895F89C0];
  uint64_t v8 = 1LL;
  if (a1)
  {
    if (a2)
    {
      if (a3)
      {
        if (a4)
        {
          uint64_t TreeFor = _v_findTreeFor(a1, 1LL, 0LL, a2, a3, a4, a7, a8);
          if (TreeFor)
          {
            uint64_t v15 = TreeFor;
            while (a5)
            {
              size_t v16 = strlen(a5);
              uint64_t v17 = BOMTreeRemoveValue(v15, a5, v16 + 1);
              if ((_DWORD)v17) {
                return v17;
              }
              int v18 = BOMTreeCount(v15);
              BOMTreeFree(v15);
              if (v18) {
                goto LABEL_16;
              }
              uint64_t v8 = 1LL;
              *(_WORD *)(a1 + 32) = 1;
              uint64_t v15 = _v_findTreeFor(a1, 1LL, 0LL, a2, a3, a4, v19, v20);
              a5 = 0LL;
              if (!v15) {
                return v8;
              }
            }

            BOMTreeRemoveAndFree(v15);
            if (BOMCKTreeBuildKey(__s, v21, v22, v23, v24, v25, v26, v27, a2)) {
              return 1LL;
            }
            int v28 = strlen(__s);
            uint64_t v8 = BOMTreeRemoveValue(*(void *)(a1 + 8), __s, (v28 + 1));
            if (!(_DWORD)v8)
            {
LABEL_16:
              uint64_t v8 = 0LL;
              *(_WORD *)(a1 + 32) = 1;
            }
          }
        }
      }
    }
  }

  return v8;
}

uint64_t BOMBomVIndexGetApproxDiskSpace( uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, unsigned int *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v22 = *MEMORY[0x1895F89C0];
  if (!a1) {
    return 1LL;
  }
  if (!a2 && !a3 && !a4)
  {
    uint64_t result = 0LL;
    unsigned int v11 = *(_DWORD *)(a1 + 28);
LABEL_6:
    *a5 = v11;
    return result;
  }

  uint64_t result = 1LL;
  if (a4 && a2 && a3 && a5)
  {
    *a5 = 0;
    size_t v12 = strlen(__s) + 1;
    if (*(void *)(a1 + 40))
    {
      CFDataRef v13 = CFDataCreate((CFAllocatorRef)*MEMORY[0x189604DB0], (const UInt8 *)__s, v12);
      if (!v13)
      {
        uint64_t v15 = (FILE *)*MEMORY[0x1895F89D0];
        size_t v16 = __error();
        uint64_t v17 = strerror(*v16);
        fprintf(v15, "CFDataCreate: %s\n", v17);
        return 1LL;
      }

      CFDataRef v14 = v13;
      if (CFDictionaryGetValueIfPresent(*(CFDictionaryRef *)(a1 + 40), v13, (const void **)&value))
      {
        *a5 = value;
        CFRelease(v14);
        return 0LL;
      }

      CFRelease(v14);
    }

    unint64_t v18 = BOMTreeGetValue(*(void *)(a1 + 8), __s, v12);
    if (v18)
    {
      uint64_t v19 = (unsigned int *)v18;
      uint64_t result = 0LL;
      unsigned int v11 = bswap32(*v19);
      goto LABEL_6;
    }

    return 1LL;
  }

  return result;
}

uint64_t BOMBomVIndexSetApproxDiskSpace( uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v12 = *MEMORY[0x1895F89C0];
  if (!a1) {
    return 1LL;
  }
  unsigned int v8 = a5;
  if (!a2 && !a3 && !a4)
  {
    uint64_t result = 0LL;
    *(_DWORD *)(a1 + 28) = a5;
    *(_WORD *)(a1 + 32) = 257;
    return result;
  }

  uint64_t result = 1LL;
  if (a2 && a3 && a4)
  {
    return 1LL;
  }

  return result;
}

uint64_t BOMBomVIndexSetApproxDiskSpaceWithKey(uint64_t a1, char *__s, unsigned int a3)
{
  uint64_t result = 1LL;
  if (a1 && __s)
  {
    size_t v7 = strlen(__s) + 1;
    if (BOMStorageIsOpenForWriting(*(void *)(a1 + 16)))
    {
      unsigned int v15 = bswap32(a3);
      uint64_t result = BOMTreeSetValue(*(void **)(a1 + 8), __s, v7, (uint64_t)&v15, 4LL);
      if (!(_DWORD)result)
      {
        *(_WORD *)(a1 + 32) = 257;
        return result;
      }
    }

    else
    {
      unsigned int v8 = (const __CFAllocator *)*MEMORY[0x189604DB0];
      if (*(void *)(a1 + 40)
        || (CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x189604DB0], 0LL, MEMORY[0x189605240], 0LL),
            (*(void *)(a1 + 40) = Mutable) != 0LL))
      {
        CFDataRef v10 = CFDataCreate(v8, (const UInt8 *)__s, v7);
        if (v10)
        {
          CFDataRef v11 = v10;
          CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 40), v10, (const void *)a3);
          CFRelease(v11);
          uint64_t result = 0LL;
          *(_BYTE *)(a1 + 33) = 1;
          return result;
        }

        uint64_t v12 = (FILE *)*MEMORY[0x1895F89D0];
        CFDataRef v13 = __error();
        CFDataRef v14 = strerror(*v13);
        fprintf(v12, "CFDataCreate: %s\n", v14);
      }
    }

    return 1LL;
  }

  return result;
}

uint64_t BOMBomVIndexDiskSpaceKey( uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, void *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v14 = *MEMORY[0x1895F89C0];
  uint64_t result = 1LL;
  if (a1 && a2 && a3 && a4)
  {
    size_t v11 = strlen(__s) + 1;
    uint64_t v12 = BOM_malloc(v11);
    *a5 = v12;
    if (!v12)
    {
      return 1LL;
    }

    else
    {
      memmove(v12, __s, v11);
      return 0LL;
    }
  }

  return result;
}

uint64_t BOMBomVIndexDiskSpaceInfoIsValid(uint64_t result)
{
  if (result) {
    return *(unsigned __int8 *)(result + 33);
  }
  return result;
}

uint64_t BOMBomVIndexInvalidateDiskSpace(uint64_t result)
{
  *(_WORD *)(result + 32) = 1;
  return result;
}

uint64_t _BOMBomVIndexPrintDiagnostics( uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v20 = *MEMORY[0x1895F89C0];
  if (result)
  {
    uint64_t v8 = result;
    uint64_t result = BOMCKTreeBuildKey(__s, a2, a3, a4, a5, a6, a7, a8, "path");
    if (!(_DWORD)result)
    {
      int v9 = strlen(__s);
      CFDataRef v10 = (FILE **)MEMORY[0x1895F89D0];
      fprintf((FILE *)*MEMORY[0x1895F89D0], "Tree: %s\n", "VIndex");
      int v11 = BOMTreeCount(*(void *)(v8 + 8));
      uint64_t result = (uint64_t)BOMTreeIteratorNew(*(void *)(v8 + 8), 0LL, 0LL, 0LL);
      if (result)
      {
        uint64_t v12 = (char *)result;
        int v13 = 0;
        while (!BOMTreeIteratorIsAtEnd((uint64_t)v12))
        {
          uint64_t v14 = (const char *)BOMTreeIteratorKey((uint64_t)v12);
          if (!BOM_strrncmp(v14, __s, v9))
          {
            int v15 = strlen(v14);
            uint64_t result = BOMTreeGetValue(*(void *)(v8 + 8), v14, (v15 + 1));
            if (!result) {
              return result;
            }
            size_t v16 = (unsigned int *)result;
            uint64_t v17 = BOMTreeStorage(*(void *)(v8 + 8));
            uint64_t result = BOMTreeOpen(v17, bswap32(*v16), 0);
            if (!result) {
              return result;
            }
            uint64_t v18 = result;
            v13 += BOMTreeCount(result);
            BOMTreeFree(v18);
          }

          BOMTreeIteratorNext((uint64_t)v12);
        }

        BOMTreeIteratorFree(v12);
        fprintf(*v10, " i # records: %d\n", v11);
        fprintf(*v10, " i # pages  : %d (%d)\n", 0, 0);
        fprintf(*v10, "   i leaf   : %d (%d)\n", 0, 0);
        fprintf(*v10, "   i branch : %d (%d)\n", 0, 0);
        fprintf(*v10, " i key size : %zd\n", 0LL);
        fprintf(*v10, " i data size: %zd\n", 0LL);
        fprintf(*v10, "   # records: %d\n", v13);
        fprintf(*v10, "   # pages  : %d (%d)\n", 0, 0);
        fprintf(*v10, "     leaf   : %d (%d)\n", 0, 0);
        fprintf(*v10, "     branch : %d (%d)\n", 0, 0);
        fprintf(*v10, "   key size : %zd\n", 0LL);
        return fprintf(*v10, "   data size: %zd\n", 0LL);
      }
    }
  }

  return result;
}

double byte_stream_new(uint64_t a1, uint64_t a2)
{
  if (!a2)
  {
    uint64_t v3 = platform_calloc(a1, 1uLL, 0x50uLL);
    if (v3)
    {
      *(_DWORD *)uint64_t v3 = 1651733613;
      v3[1] = a1;
      *(void *)&double result = 0x200000002LL;
      v3[2] = 0x200000002LL;
      *((_DWORD *)v3 + 18) = 1836348258;
    }
  }

  return result;
}

void byte_stream_free(void *__b)
{
  if (__b && *(_DWORD *)__b == 1651733613 && *((_DWORD *)__b + 18) == 1836348258)
  {
    int v2 = (void *)__b[7];
    if (v2) {
      platform_free(__b[1], v2);
    }
    uint64_t v3 = __b[1];
    platform_memset(v3, __b, 0LL, 0x50uLL);
    platform_free(v3, __b);
  }

uint64_t byte_stream_attach(uint64_t result, uint64_t a2, unint64_t a3)
{
  if (result && *(_DWORD *)result == 1651733613 && *(_DWORD *)(result + 72) == 1836348258)
  {
    if (a3 < 0xE8D4A51001LL)
    {
      *(_BYTE *)(result + 24) = 0;
      *(void *)(result + 40) = a3;
      *(void *)(result + 48) = 0LL;
      *(void *)(result + 32) = a2;
    }

    else
    {
      *(_BYTE *)(result + 24) = 1;
    }
  }

  return result;
}

BOOL byte_stream_exception(BOOL result)
{
  if (result) {
    return *(_DWORD *)result == 1651733613 && *(_DWORD *)(result + 72) == 1836348258 && *(_BYTE *)(result + 24) != 0;
  }
  return result;
}

_DWORD *byte_stream_set_byte_order(_DWORD *result, int a2)
{
  if (result && *result == 1651733613 && result[18] == 1836348258) {
    result[5] = a2;
  }
  return result;
}

uint64_t byte_stream_read_uint8(uint64_t a1)
{
  if (a1 && *(_DWORD *)a1 == 1651733613 && *(_DWORD *)(a1 + 72) == 1836348258 && !*(_BYTE *)(a1 + 24))
  {
    uint64_t v1 = *(void *)(a1 + 48);
    uint64_t v2 = v1 + 1;
    if ((unint64_t)(v1 + 1) <= *(void *)(a1 + 40))
    {
      uint64_t v3 = *(unsigned __int8 *)(*(void *)(a1 + 32) + v1);
      *(void *)(a1 + 48) = v2;
      return v3;
    }

    *(_BYTE *)(a1 + 24) = 1;
  }

  return 255LL;
}

uint64_t byte_stream_read_uint16(uint64_t a1)
{
  if (a1)
  {
    if (*(_DWORD *)a1 != 1651733613 || *(_DWORD *)(a1 + 72) != 1836348258 || *(_BYTE *)(a1 + 24)) {
      return (unsigned __int16)-1;
    }
    uint64_t v2 = *(void *)(a1 + 48);
    if ((unint64_t)(v2 + 2) > *(void *)(a1 + 40))
    {
      *(_BYTE *)(a1 + 24) = 1;
      return (unsigned __int16)-1;
    }

    unsigned __int16 __dst = 0;
    platform_memcpy(*(void *)(a1 + 8), &__dst, (void *)(*(void *)(a1 + 32) + v2), 2uLL);
    *(void *)(a1 + 48) += 2LL;
    unsigned int v5 = bswap32(__dst) >> 16;
    if (*(_DWORD *)(a1 + 16) == *(_DWORD *)(a1 + 20)) {
      return __dst;
    }
    else {
      return (unsigned __int16)v5;
    }
  }

  else
  {
    return (unsigned __int16)-1;
  }

uint64_t byte_stream_read_uint32(uint64_t a1)
{
  if (!a1) {
    return 0xFFFFFFFFLL;
  }
  if (*(_DWORD *)a1 != 1651733613 || *(_DWORD *)(a1 + 72) != 1836348258 || *(_BYTE *)(a1 + 24)) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v2 = *(void *)(a1 + 48);
  if ((unint64_t)(v2 + 4) > *(void *)(a1 + 40))
  {
    *(_BYTE *)(a1 + 24) = 1;
    return 0xFFFFFFFFLL;
  }

  unsigned int __dst = 0;
  platform_memcpy(*(void *)(a1 + 8), &__dst, (void *)(*(void *)(a1 + 32) + v2), 4uLL);
  *(void *)(a1 + 48) += 4LL;
  unsigned int v4 = bswap32(__dst);
  if (*(_DWORD *)(a1 + 16) == *(_DWORD *)(a1 + 20)) {
    return __dst;
  }
  else {
    return v4;
  }
}

unint64_t byte_stream_read_uint64(uint64_t a1)
{
  if (!a1) {
    return -1LL;
  }
  if (*(_DWORD *)a1 != 1651733613 || *(_DWORD *)(a1 + 72) != 1836348258 || *(_BYTE *)(a1 + 24)) {
    return -1LL;
  }
  uint64_t v2 = *(void *)(a1 + 48);
  if ((unint64_t)(v2 + 8) > *(void *)(a1 + 40))
  {
    *(_BYTE *)(a1 + 24) = 1;
    return -1LL;
  }

  unint64_t __dst = 0LL;
  platform_memcpy(*(void *)(a1 + 8), &__dst, (void *)(*(void *)(a1 + 32) + v2), 8uLL);
  *(void *)(a1 + 48) += 8LL;
  unint64_t v4 = bswap64(__dst);
  if (*(_DWORD *)(a1 + 16) == *(_DWORD *)(a1 + 20)) {
    return __dst;
  }
  else {
    return v4;
  }
}

uint64_t *byte_stream_read_buffer(uint64_t *result, void *a2, size_t __n)
{
  if (result)
  {
    uint64_t v3 = result;
    if (*(_DWORD *)result == 1651733613 && *((_DWORD *)result + 18) == 1836348258 && !*((_BYTE *)result + 24))
    {
      if (!a2) {
        goto LABEL_8;
      }
      if (!__n) {
        return result;
      }
      uint64_t v5 = result[6];
      if (v5 + __n <= result[5])
      {
        double result = (uint64_t *)platform_memcpy(result[1], a2, (void *)(result[4] + v5), __n);
        v3[6] += __n;
      }

      else
      {
LABEL_8:
        *((_BYTE *)result + 24) = 1;
      }
    }
  }

  return result;
}

uint64_t byte_stream_read_string(uint64_t a1, size_t a2, uint64_t a3)
{
  if (!a1) {
    return -1LL;
  }
  if (*(_DWORD *)a1 != 1651733613 || *(_DWORD *)(a1 + 72) != 1836348258 || *(_BYTE *)(a1 + 24)) {
    return -1LL;
  }
  if (*(void *)(a1 + 48) + a2 > *(void *)(a1 + 40)) {
    goto LABEL_6;
  }
  size_t v7 = a2 + 1;
  size_t v8 = *(void *)(a1 + 64);
  if (v8 >= a2 + 1)
  {
    platform_memset(*(void *)(a1 + 8), *(void **)(a1 + 56), 0LL, v8);
    CFDataRef v10 = *(void **)(a1 + 56);
  }

  else
  {
    int v9 = *(void **)(a1 + 56);
    if (v9) {
      platform_free(*(void *)(a1 + 8), v9);
    }
    *(void *)(a1 + 64) = v7;
    CFDataRef v10 = platform_calloc(*(void *)(a1 + 8), a2 + 1, 1uLL);
    *(void *)(a1 + 56) = v10;
    if (!v10)
    {
      *(_BYTE *)(a1 + 24) = 1;
      return -1LL;
    }
  }

  byte_stream_read_buffer((uint64_t *)a1, v10, a2);
  if (*(_BYTE *)(a1 + 24)) {
    return -1LL;
  }
  uint64_t result = platform_strtoq(*(void *)(a1 + 8), *(char **)(a1 + 56), &__endptr, a3);
  if (!result)
  {
    if (!*__error()) {
      return 0LL;
    }
LABEL_6:
    *(_BYTE *)(a1 + 24) = 1;
    return -1LL;
  }

  return result;
}

uint64_t byte_stream_remaining(uint64_t a1)
{
  if (a1 && *(_DWORD *)a1 == 1651733613 && *(_DWORD *)(a1 + 72) == 1836348258) {
    return *(void *)(a1 + 40) - *(void *)(a1 + 48);
  }
  else {
    return -1LL;
  }
}

uint64_t byte_stream_advance(uint64_t result, uint64_t a2)
{
  if (result && *(_DWORD *)result == 1651733613 && *(_DWORD *)(result + 72) == 1836348258 && !*(_BYTE *)(result + 24))
  {
    unint64_t v2 = *(void *)(result + 48) + a2;
    if (v2 <= *(void *)(result + 40)) {
      *(void *)(result + 48) = v2;
    }
    else {
      *(_BYTE *)(result + 24) = 1;
    }
  }

  return result;
}

void *data_archive_decoder_new(uint64_t a1, uint64_t a2)
{
  if (!a2)
  {
    uint64_t v5 = platform_calloc(a1, 1uLL, 0x60uLL);
    unint64_t v2 = v5;
    if (!v5) {
      return v2;
    }
    *(_DWORD *)uint64_t v5 = 1919315316;
    v5[1] = a1;
    byte_stream_new(a1, 0LL);
    v2[3] = v6;
    if (v6)
    {
      *((_DWORD *)v2 + 23) = 1953326706;
      return v2;
    }

    free(v2);
  }

  return 0LL;
}

void data_archive_decoder_free(void *__b)
{
  if (__b && *(_DWORD *)__b == 1919315316 && *((_DWORD *)__b + 23) == 1953326706)
  {
    unint64_t v2 = (void *)__b[5];
    if (v2) {
      platform_free(__b[1], v2);
    }
    uint64_t v3 = (void *)__b[3];
    if (v3) {
      byte_stream_free(v3);
    }
    uint64_t v4 = __b[1];
    platform_memset(v4, __b, 0LL, 0x60uLL);
    platform_free(v4, __b);
  }

uint64_t data_archive_decoder_set_stream(uint64_t a1, uint64_t a2, void *a3)
{
  if (!a1) {
    return 0xFFFFFFFFLL;
  }
  if (*(_DWORD *)a1 != 1919315316) {
    return 0xFFFFFFFFLL;
  }
  uint64_t result = 0xFFFFFFFFLL;
  if (a2 && *(_DWORD *)(a1 + 92) == 1953326706)
  {
    *(void *)(a1 + 16) = a2;
    *(void *)(a1 + 32) = 0x20000LL;
    uint64_t v6 = platform_valloc(*(void *)(a1 + 8), 0x20000uLL);
    *(void *)(a1 + 40) = v6;
    if (!v6)
    {
      int v13 = __error();
      unsigned __int8 v14 = strerror(*v13);
      CFDataRef v10 = "Could not allocate read buffer: %s";
      char v23 = v14;
      int v11 = a3;
      int v12 = 409;
      goto LABEL_10;
    }

    *(void *)(a1 + 48) = v6;
    *(void *)(a1 + 56) = 0LL;
    *(void *)(a1 + 64) = 0LL;
    *(void *)(a1 + 72) = 0LL;
    if (populate_read_buffer(a1, *(void *)(a1 + 32), a3))
    {
      CFDataRef v10 = "Could not populate the read buffer";
      int v11 = a3;
      int v12 = 425;
LABEL_10:
      capture_error( v11,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_decoder.c",  v12,  (uint64_t)"data_archive_decoder_set_stream",  v10,  v7,  v8,  v9,  v23);
      return 0xFFFFFFFFLL;
    }

    if (!*(void *)(a1 + 72)) {
      return 0LL;
    }
    uint64_t v15 = *(void *)(a1 + 48);
    unint64_t v16 = *(void *)(a1 + 64);
    if (v16 < 0x200)
    {
LABEL_15:
      if (!*(_DWORD *)(a1 + 84))
      {
        if (check_cpio_header(a1, v15, v16, a3))
        {
          CFDataRef v10 = "Could not check for a cpio header";
          int v11 = a3;
          int v12 = 461;
          goto LABEL_10;
        }

        if (!*(_DWORD *)(a1 + 84))
        {
          uint64_t result = is_pkzip_header(a1, v15, v16);
          if ((_DWORD)result)
          {
            uint64_t result = 0LL;
            *(_DWORD *)(a1 + 84) = 9;
          }

          return result;
        }
      }

      return 0LL;
    }

    byte_stream_attach(*(void *)(a1 + 24), *(void *)(a1 + 48), *(void *)(a1 + 64));
    byte_stream_advance(*(void *)(a1 + 24), 257LL);
    if (byte_stream_exception(*(void *)(a1 + 24)))
    {
      uint64_t v20 = "Could not advance to the magic offset";
      uint64_t v21 = a3;
      int v22 = 805;
    }

    else
    {
      byte_stream_read_buffer(*(uint64_t **)(a1 + 24), __s1, 6uLL);
      if (byte_stream_exception(*(void *)(a1 + 24)))
      {
        uint64_t v20 = "Could not read the potential magic value";
        uint64_t v21 = a3;
        int v22 = 815;
      }

      else
      {
        byte_stream_read_buffer(*(uint64_t **)(a1 + 24), v24, 2uLL);
        if (!byte_stream_exception(*(void *)(a1 + 24)))
        {
          if (!platform_memcmp(*(void *)(a1 + 8), __s1, "ustar", 6uLL)
            && !platform_memcmp(*(void *)(a1 + 8), v24, "00", 2uLL))
          {
            *(_DWORD *)(a1 + 84) = 2;
          }

          goto LABEL_15;
        }

        uint64_t v20 = "Could not read the potential version value";
        uint64_t v21 = a3;
        int v22 = 825;
      }
    }

    capture_error( v21,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_decoder.c",  v22,  (uint64_t)"check_tar_posix_header",  v20,  v17,  v18,  v19,  v23);
    CFDataRef v10 = "Could not check for a tar POSIX header";
    int v11 = a3;
    int v12 = 445;
    goto LABEL_10;
  }

  return result;
}

uint64_t populate_read_buffer(uint64_t a1, size_t a2, void *a3)
{
  size_t v4 = *(void *)(a1 + 64);
  if (v4 >= a2) {
    return 0LL;
  }
  uint64_t v6 = *(void **)(a1 + 40);
  if (v4)
  {
    memmove(v6, *(const void **)(a1 + 48), v4);
    uint64_t v6 = *(void **)(a1 + 40);
    *(void *)(a1 + 48) = v6;
    uint64_t v7 = *(void *)(a1 + 64);
  }

  else
  {
    uint64_t v7 = 0LL;
    *(void *)(a1 + 48) = v6;
  }

  size_t v8 = *(void *)(a1 + 32) - v7;
  unint64_t v9 = data_stream_read(*(void *)(a1 + 16), (char *)v6 + v7, v8);
  if (v9 == -1LL)
  {
    int v12 = __error();
    strerror(*v12);
    capture_error( a3,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_decoder.c",  4061,  (uint64_t)"populate_read_buffer",  "Could not read additional %ld bytes onto read buffer: %s\n",  v13,  v14,  v15,  v8);
    return 0xFFFFFFFFLL;
  }

  else
  {
    int64x2_t v10 = vaddq_s64(*(int64x2_t *)(a1 + 64), vdupq_n_s64(v9));
    *(int64x2_t *)(a1 + 64) = v10;
    if (v10.i64[0]) {
      return 0LL;
    }
    uint64_t result = 0LL;
    *(_BYTE *)(a1 + 80) = 1;
  }

  return result;
}

uint64_t check_cpio_header(uint64_t a1, uint64_t a2, unint64_t a3, void *a4)
{
  if (a3 < 2) {
    return 0LL;
  }
  byte_stream_attach(*(void *)(a1 + 24), a2, a3);
  int uint16 = byte_stream_read_uint16(*(void *)(a1 + 24));
  if (byte_stream_exception(*(void *)(a1 + 24)))
  {
    capture_error( a4,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_decoder.c",  867,  (uint64_t)"check_cpio_header",  "Could not read the potential binary magic value",  v11,  v12,  v13,  v4);
    return 0xFFFFFFFFLL;
  }

  if (uint16 == 51057)
  {
    uint64_t result = 0LL;
    int v14 = 8;
    goto LABEL_9;
  }

  if (uint16 == 29127)
  {
    uint64_t result = 0LL;
    int v14 = 7;
LABEL_9:
    *(_DWORD *)(a1 + 84) = v14;
    return result;
  }

  if (a3 < 6) {
    return 0LL;
  }
  byte_stream_attach(*(void *)(a1 + 24), a2, a3);
  uint64_t string = byte_stream_read_string(*(void *)(a1 + 24), 6uLL, 8LL);
  if (byte_stream_exception(*(void *)(a1 + 24))) {
    return 0LL;
  }
  uint64_t result = 0LL;
  if (string > 29126)
  {
    if (string == 29143)
    {
      uint64_t result = 0LL;
      int v14 = 4;
      goto LABEL_9;
    }

    if (string == 29127)
    {
      uint64_t result = 0LL;
      int v14 = 3;
      goto LABEL_9;
    }
  }

  else
  {
    if (string == 29121)
    {
      uint64_t result = 0LL;
      int v14 = 6;
      goto LABEL_9;
    }

    if (string == 29122)
    {
      uint64_t result = 0LL;
      int v14 = 5;
      goto LABEL_9;
    }
  }

  return result;
}

uint64_t is_pkzip_header(uint64_t a1, uint64_t a2, unint64_t a3)
{
  if (a3 < 4) {
    return 0LL;
  }
  byte_stream_attach(*(void *)(a1 + 24), a2, a3);
  int uint32 = byte_stream_read_uint32(*(void *)(a1 + 24));
  uint64_t result = 1LL;
  if (uint32 <= 101075791)
  {
    BOOL v6 = uint32 == 67324752;
    int v7 = 101010256;
  }

  else
  {
    BOOL v6 = uint32 == 101075792 || uint32 == 134695760;
    int v7 = 808471376;
  }

  return result;
}

uint64_t data_archive_decoder_get_type(_DWORD *a1)
{
  if (a1 && *a1 == 1919315316 && a1[23] == 1953326706) {
    return a1[21];
  }
  puts("Invalid decoder?");
  return 0LL;
}

void *data_archive_decoder_read_entry( uint64_t a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1 || *(_DWORD *)a1 != 1919315316 || *(_DWORD *)(a1 + 92) != 1953326706)
  {
    int64x2_t v10 = "Invalid decoder";
    uint64_t v11 = a2;
    int v12 = 527;
    goto LABEL_7;
  }

  if (*(_BYTE *)(a1 + 89))
  {
    int64x2_t v10 = "End of archive";
    uint64_t v11 = a2;
    int v12 = 537;
LABEL_7:
    capture_error( v11,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_decoder.c",  v12,  (uint64_t)"data_archive_decoder_read_entry",  v10,  a6,  a7,  a8,  v28);
    return 0LL;
  }

  if (!*(void *)(a1 + 64) && populate_read_buffer(a1, *(void *)(a1 + 32), a2))
  {
    int64x2_t v10 = "Could not populate the read buffer";
    uint64_t v11 = a2;
    int v12 = 550;
    goto LABEL_7;
  }

  uint64_t v15 = darc_format_entry_new(*(void *)(a1 + 8), 0LL);
  uint64_t v13 = v15;
  if (!v15)
  {
    capture_error( a2,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_decoder.c",  562,  (uint64_t)"data_archive_decoder_read_entry",  "Could not create empty data format entry",  v18,  v19,  v20,  v28);
    return v13;
  }

  if (*(_BYTE *)(a1 + 80))
  {
    if (!darc_format_entry_set_type(v15, 1))
    {
      *(_BYTE *)(a1 + 89) = 1;
      return v13;
    }

    uint64_t v24 = "Could not set EoA entry type";
    uint64_t v25 = a2;
    int v26 = 575;
    goto LABEL_15;
  }

  int v27 = *(_DWORD *)(a1 + 84);
  if (v27 == 9)
  {
    uint64_t v24 = "Could not parse PKZip entry";
    uint64_t v25 = a2;
    int v26 = 620;
    goto LABEL_15;
  }

  if (v27 == 3)
  {
    uint64_t v24 = "Could not parse CPIO ASCII entry";
    uint64_t v25 = a2;
    int v26 = 609;
    goto LABEL_15;
  }

  if (v27 != 2)
  {
    capture_error( a2,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_decoder.c",  628,  (uint64_t)"data_archive_decoder_read_entry",  "Unknown data format: %d",  v18,  v19,  v20,  *(_DWORD *)(a1 + 84));
    return v13;
  }

  if (parse_entry_posix_ustar(a1, v15, a2))
  {
    uint64_t v24 = "Could not parse POSIX ustar entry";
    uint64_t v25 = a2;
    int v26 = 598;
LABEL_15:
    capture_error( v25,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_decoder.c",  v26,  (uint64_t)"data_archive_decoder_read_entry",  v24,  v21,  v22,  v23,  v28);
    darc_format_entry_free(v13);
    return 0LL;
  }

  return v13;
}

uint64_t parse_entry_posix_ustar(uint64_t a1, _DWORD *a2, void *a3)
{
  uint64_t v75 = *MEMORY[0x1895F89C0];
  uint64_t v6 = *(void *)(a1 + 56);
  if (require_minimum_amount(a1, 0x200uLL, (char)"POSIX ustar header", a3))
  {
    int64x2_t v10 = "Minimum amount necessary for POSIX ustar header is unavailable";
    uint64_t v11 = a3;
    int v12 = 1022;
LABEL_3:
    capture_error( v11,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_decoder.c",  v12,  (uint64_t)"parse_entry_posix_ustar",  v10,  v7,  v8,  v9,  v53);
    return 0xFFFFFFFFLL;
  }

  int v14 = platform_calloc(*(void *)(a1 + 8), 1uLL, 0x28uLL);
  if (!v14)
  {
    uint64_t v23 = __error();
    strerror(*v23);
    capture_error( a3,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_decoder.c",  1030,  (uint64_t)"parse_entry_posix_ustar",  "Could not allocate %ld bytes for POSIX ustar header: %s",  v24,  v25,  v26,  40);
    return 0xFFFFFFFFLL;
  }

  uint64_t v15 = v14;
  uint64_t v16 = *(_BYTE **)(a1 + 48);
  if (*v16)
  {
LABEL_8:
    *int v14 = 2;
    byte_stream_attach(*(void *)(a1 + 24), (uint64_t)v16, 0x200uLL);
    memset(__s, 0, sizeof(__s));
    byte_stream_read_buffer(*(uint64_t **)(a1 + 24), __s, 0x64uLL);
    if (byte_stream_exception(*(void *)(a1 + 24)))
    {
      uint64_t v20 = "Could not parse the tar name field";
      uint64_t v21 = a3;
      int v22 = 1113;
      goto LABEL_101;
    }

    size_t v30 = strlen(__s);
    if (darc_format_entry_set_attribute((uint64_t)a2, "name", __s, v30 + 1))
    {
      uint64_t v20 = "Could not set name attribute";
      uint64_t v21 = a3;
      int v22 = 1123;
      goto LABEL_101;
    }

    __int16 string = byte_stream_read_string(*(void *)(a1 + 24), 8uLL, 8LL);
    if (byte_stream_exception(*(void *)(a1 + 24)))
    {
      uint64_t v20 = "Could not parse the tar mode field";
      uint64_t v21 = a3;
      int v22 = 1134;
      goto LABEL_101;
    }

    *((_WORD *)v15 + 2) = string | 0x8000;
    int v32 = byte_stream_read_string(*(void *)(a1 + 24), 8uLL, 8LL);
    if (byte_stream_exception(*(void *)(a1 + 24)))
    {
      uint64_t v20 = "Could not parse the tar uid field";
      uint64_t v21 = a3;
      int v22 = 1148;
      goto LABEL_101;
    }

    v15[2] = v32;
    int v33 = byte_stream_read_string(*(void *)(a1 + 24), 8uLL, 8LL);
    if (byte_stream_exception(*(void *)(a1 + 24)))
    {
      uint64_t v20 = "Could not parse the tar gid field";
      uint64_t v21 = a3;
      int v22 = 1161;
      goto LABEL_101;
    }

    v15[3] = v33;
    uint64_t v34 = byte_stream_read_string(*(void *)(a1 + 24), 0xCuLL, 8LL);
    if (byte_stream_exception(*(void *)(a1 + 24)))
    {
      uint64_t v20 = "Could not parse the tar size field";
      uint64_t v21 = a3;
      int v22 = 1174;
      goto LABEL_101;
    }

    *((void *)v15 + 2) = v34;
    uint64_t v35 = byte_stream_read_string(*(void *)(a1 + 24), 0xCuLL, 8LL);
    if (byte_stream_exception(*(void *)(a1 + 24)))
    {
      uint64_t v20 = "Could not parse the tar mtime field";
      uint64_t v21 = a3;
      int v22 = 1187;
      goto LABEL_101;
    }

    *((void *)v15 + 3) = v35;
    byte_stream_read_buffer(*(uint64_t **)(a1 + 24), v73, 8uLL);
    if (byte_stream_exception(*(void *)(a1 + 24)))
    {
      uint64_t v20 = "Could not parse the tar checksum field";
      uint64_t v21 = a3;
      int v22 = 1202;
      goto LABEL_101;
    }

    char v58 = 0;
    byte_stream_read_buffer(*(uint64_t **)(a1 + 24), &v58, 1uLL);
    if (byte_stream_exception(*(void *)(a1 + 24)))
    {
      uint64_t v20 = "Could not parse the tar type flag field";
      uint64_t v21 = a3;
      int v22 = 1215;
      goto LABEL_101;
    }

    if (v58 > 102)
    {
      if (v58 == 103)
      {
        int v36 = 0;
        int v37 = 1;
      }

      else
      {
        if (v58 != 120)
        {
LABEL_43:
          if ((v58 - 65) > 0x19)
          {
            capture_error( a3,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_decoder.c",  1302,  (uint64_t)"parse_entry_posix_ustar_header_decode",  "Unrecognize tar type flag value: %c",  v17,  v18,  v19,  v58);
LABEL_102:
            capture_error( a3,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_decoder.c",  1037,  (uint64_t)"parse_entry_posix_ustar",  "Could not decode POSIX ustar header",  v42,  v43,  v44,  v54);
            platform_free(*(void *)(a1 + 8), v15);
            return 0xFFFFFFFFLL;
          }

          *__error() = 45;
          uint64_t v20 = "Vendor specific extensions (POSIX.1-1988)";
          uint64_t v21 = a3;
          int v22 = 1298;
LABEL_101:
          capture_error( v21,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_decoder.c",  v22,  (uint64_t)"parse_entry_posix_ustar_header_decode",  v20,  v17,  v18,  v19,  v53);
          goto LABEL_102;
        }

        int v37 = 0;
        int v36 = 1;
      }
    }

    else
    {
      int v36 = 0;
      int v37 = 0;
      switch(v58)
      {
        case '0':
        case '1':
          break;
        case '2':
          int v36 = 0;
          int v37 = 0;
          __int16 v38 = *((_WORD *)v15 + 2) | 0xA000;
          goto LABEL_50;
        case '3':
          int v36 = 0;
          int v37 = 0;
          __int16 v38 = v15[1] & 0x5FFF | 0x2000;
          goto LABEL_50;
        case '4':
          int v36 = 0;
          int v37 = 0;
          __int16 v39 = v15[1] & 0x1FFF | 0x6000;
          goto LABEL_48;
        case '5':
          int v36 = 0;
          int v37 = 0;
          __int16 v39 = v15[1] & 0x3FFF | 0x4000;
LABEL_48:
          *((_WORD *)v15 + 2) = v39;
          break;
        case '6':
          int v36 = 0;
          int v37 = 0;
          __int16 v38 = v15[1] & 0x6FFF | 0x1000;
LABEL_50:
          *((_WORD *)v15 + 2) = v38;
          break;
        case '7':
          *__error() = 45;
          uint64_t v20 = "I do not support contiguous files";
          uint64_t v21 = a3;
          int v22 = 1277;
          goto LABEL_101;
        default:
          int v37 = 0;
          if (v58) {
            goto LABEL_43;
          }
          break;
      }
    }

    memset(v72, 0, sizeof(v72));
    byte_stream_read_buffer(*(uint64_t **)(a1 + 24), v72, 0x64uLL);
    if (byte_stream_exception(*(void *)(a1 + 24)))
    {
      uint64_t v20 = "Could not parse the tar linkname field";
      uint64_t v21 = a3;
      int v22 = 1316;
      goto LABEL_101;
    }

    int v40 = v37;
    size_t v41 = strlen(v72);
    if (v41 && darc_format_entry_set_attribute((uint64_t)a2, "tar linkname", v72, v41 + 1))
    {
      uint64_t v20 = "Could not set linkname attribute";
      uint64_t v21 = a3;
      int v22 = 1328;
      goto LABEL_101;
    }

    __int16 v57 = 0;
    int __s1 = 0;
    byte_stream_read_buffer(*(uint64_t **)(a1 + 24), &__s1, 6uLL);
    if (byte_stream_exception(*(void *)(a1 + 24)))
    {
      uint64_t v20 = "Could not parse the POSIX ustar magic field";
      uint64_t v21 = a3;
      int v22 = 1342;
      goto LABEL_101;
    }

    if (platform_memcmp(*(void *)(a1 + 8), &__s1, "ustar", 6uLL))
    {
      uint64_t v20 = "Invalid magic for POSIX ustar archive";
      uint64_t v21 = a3;
      int v22 = 1348;
      goto LABEL_101;
    }

    __int16 v55 = 0;
    byte_stream_read_buffer(*(uint64_t **)(a1 + 24), &v55, 2uLL);
    if (byte_stream_exception(*(void *)(a1 + 24)))
    {
      uint64_t v20 = "Could not parse the tar version field";
      uint64_t v21 = a3;
      int v22 = 1361;
      goto LABEL_101;
    }

    if (platform_memcmp(*(void *)(a1 + 8), &v55, "00", 2uLL))
    {
      uint64_t v20 = "Invalid version for POSIX ustar archive";
      uint64_t v21 = a3;
      int v22 = 1367;
      goto LABEL_101;
    }

    memset(v71, 0, sizeof(v71));
    byte_stream_read_buffer(*(uint64_t **)(a1 + 24), v71, 0x20uLL);
    if (byte_stream_exception(*(void *)(a1 + 24)))
    {
      uint64_t v20 = "Could not parse the POSIX ustar uname field";
      uint64_t v21 = a3;
      int v22 = 1380;
      goto LABEL_101;
    }

    size_t v45 = strlen((const char *)v71);
    if (v45 && darc_format_entry_set_attribute((uint64_t)a2, "POSIX ustar user name", v71, v45 + 1))
    {
      uint64_t v20 = "Could not set POSIX ustar user name attribute";
      uint64_t v21 = a3;
      int v22 = 1392;
      goto LABEL_101;
    }

    memset(v70, 0, sizeof(v70));
    byte_stream_read_buffer(*(uint64_t **)(a1 + 24), v70, 0x20uLL);
    if (byte_stream_exception(*(void *)(a1 + 24)))
    {
      uint64_t v20 = "Could not parse the POSIX ustar group name field";
      uint64_t v21 = a3;
      int v22 = 1406;
      goto LABEL_101;
    }

    size_t v46 = strlen((const char *)v70);
    if (v46 && darc_format_entry_set_attribute((uint64_t)a2, "POSIX ustar group name", v70, v46 + 1))
    {
      uint64_t v20 = "Could not set POSIX ustar group name attribute";
      uint64_t v21 = a3;
      int v22 = 1418;
      goto LABEL_101;
    }

    int v47 = byte_stream_read_string(*(void *)(a1 + 24), 8uLL, 8LL);
    if (byte_stream_exception(*(void *)(a1 + 24)))
    {
      uint64_t v20 = "Could not parse the POSIX ustar devmajor field";
      uint64_t v21 = a3;
      int v22 = 1430;
      goto LABEL_101;
    }

    v15[8] = v47;
    int v48 = byte_stream_read_string(*(void *)(a1 + 24), 8uLL, 8LL);
    if (byte_stream_exception(*(void *)(a1 + 24)))
    {
      uint64_t v20 = "Could not parse the POSIX ustar devminor field";
      uint64_t v21 = a3;
      int v22 = 1443;
      goto LABEL_101;
    }

    v15[9] = v48;
    __int128 v68 = 0u;
    memset(v69, 0, sizeof(v69));
    __int128 v66 = 0u;
    __int128 v67 = 0u;
    __int128 v64 = 0u;
    __int128 v65 = 0u;
    __int128 v62 = 0u;
    __int128 v63 = 0u;
    *(_OWORD *)uint64_t v61 = 0u;
    byte_stream_read_buffer(*(uint64_t **)(a1 + 24), v61, 0x9BuLL);
    if (byte_stream_exception(*(void *)(a1 + 24)))
    {
      uint64_t v20 = "Could not parse the POSIX ustar prefix field";
      uint64_t v21 = a3;
      int v22 = 1458;
      goto LABEL_101;
    }

    size_t v49 = strlen(v61);
    if (v49)
    {
      size_t v50 = v49;
      bzero(__str, 0x400uLL);
      if (v61[v50] == 47) {
        snprintf(__str, 0x400uLL, "%s%s");
      }
      else {
        snprintf(__str, 0x400uLL, "%s/%s");
      }
      size_t v51 = strlen(__str);
      if (darc_format_entry_set_attribute((uint64_t)a2, "name", __str, v51 + 1))
      {
        uint64_t v20 = "Could not reset POSIX ustar name attribute";
        uint64_t v21 = a3;
        int v22 = 1482;
        goto LABEL_101;
      }
    }

    int v60 = 0;
    *(void *)__str = 0LL;
    byte_stream_read_buffer(*(uint64_t **)(a1 + 24), __str, 0xCuLL);
    if (byte_stream_exception(*(void *)(a1 + 24)))
    {
      uint64_t v20 = "Could not parse the POSIX ustar padding field";
      uint64_t v21 = a3;
      int v22 = 1496;
      goto LABEL_101;
    }

    *(void *)(a1 + 48) += 512LL;
    *(int64x2_t *)(a1 + 56) = vaddq_s64(*(int64x2_t *)(a1 + 56), (int64x2_t)xmmword_18635A720);
    if (v40)
    {
      *uint64_t v15 = 3;
      *__error() = 45;
      uint64_t v20 = "This entry has global extended metadata";
      uint64_t v21 = a3;
      int v22 = 1512;
      goto LABEL_101;
    }

    if (v36)
    {
      *uint64_t v15 = 4;
      if (parse_entry_posix_ustar_extended_metadata(a1, *((void *)v15 + 2), a3))
      {
        uint64_t v20 = "Could not parse the POSIX ustar extended metadata";
        uint64_t v21 = a3;
        int v22 = 1527;
        goto LABEL_101;
      }
    }

    else
    {
      uint64_t v52 = *((void *)v15 + 2);
      if (v52 >= 1 && darc_format_entry_set_size((uint64_t)a2, v52))
      {
        uint64_t v20 = "Could not set entry size";
        uint64_t v21 = a3;
        int v22 = 1543;
        goto LABEL_101;
      }
    }

    if (darc_format_entry_set_type(a2, 2))
    {
      uint64_t v20 = "Could not set entry type";
      uint64_t v21 = a3;
      int v22 = 1553;
      goto LABEL_101;
    }
  }

  else
  {
    uint64_t v27 = 1LL;
    while (v27 != 512)
    {
      if (v16[v27++])
      {
        break;
      }
    }

    darc_format_entry_set_type(a2, 3);
    *uint64_t v15 = 1;
    *(void *)(a1 + 48) += 512LL;
    *(int64x2_t *)(a1 + 56) = vaddq_s64(*(int64x2_t *)(a1 + 56), (int64x2_t)xmmword_18635A720);
  }

  int v29 = darc_format_entry_set_attribute((uint64_t)a2, "POSIX ustar header", v15, 0x28uLL);
  platform_free(*(void *)(a1 + 8), v15);
  if (v29)
  {
    int64x2_t v10 = "Could not set POSIX ustar header attribute";
    uint64_t v11 = a3;
    int v12 = 1052;
    goto LABEL_3;
  }

  uint64_t result = darc_format_entry_set_range((uint64_t)a2, v6, *(void *)(a1 + 56) - v6);
  if ((_DWORD)result)
  {
    int64x2_t v10 = "Could not set entry range";
    uint64_t v11 = a3;
    int v12 = 1065;
    goto LABEL_3;
  }

  return result;
}

uint64_t parse_entry_cpio( uint64_t a1, _DWORD *a2, void *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v11 = *(void *)(a1 + 56);
  if (!*(_BYTE *)(a1 + 88))
  {
    if (require_minimum_amount(a1, 0x4CuLL, (char)"cpio header", a3))
    {
      uint64_t v16 = "parse_entry_cpio_header";
      uint64_t v17 = "Minimum amount necessary for CPIO header is unavailable";
      uint64_t v18 = a3;
      int v19 = 1655;
LABEL_12:
      capture_error( v18,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_decoder.c",  v19,  (uint64_t)v16,  v17,  a6,  a7,  a8,  v51);
      return 0xFFFFFFFFLL;
    }

    uint64_t v21 = (uint64_t *)platform_calloc(*(void *)(a1 + 8), 1uLL, 0x48uLL);
    if (!v21)
    {
      int v29 = __error();
      strerror(*v29);
      capture_error( a3,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_decoder.c",  1663,  (uint64_t)"parse_entry_cpio_header",  "Could not allocate %ld bytes for cpio_header: %s",  v30,  v31,  v32,  72);
      return 0xFFFFFFFFLL;
    }

    int v22 = v21;
    byte_stream_attach(*(void *)(a1 + 24), *(void *)(a1 + 48), 0x4CuLL);
    uint64_t *v22 = byte_stream_read_string(*(void *)(a1 + 24), 6uLL, 8LL);
    *((_DWORD *)v22 + 2) = byte_stream_read_string(*(void *)(a1 + 24), 6uLL, 8LL);
    v22[2] = byte_stream_read_string(*(void *)(a1 + 24), 6uLL, 8LL);
    *((_WORD *)v22 + 12) = byte_stream_read_string(*(void *)(a1 + 24), 6uLL, 8LL);
    *((_DWORD *)v22 + 7) = byte_stream_read_string(*(void *)(a1 + 24), 6uLL, 8LL);
    *((_DWORD *)v22 + 8) = byte_stream_read_string(*(void *)(a1 + 24), 6uLL, 8LL);
    *((_WORD *)v22 + 18) = byte_stream_read_string(*(void *)(a1 + 24), 6uLL, 8LL);
    *((_DWORD *)v22 + 10) = byte_stream_read_string(*(void *)(a1 + 24), 6uLL, 8LL);
    v22[6] = byte_stream_read_string(*(void *)(a1 + 24), 0xBuLL, 8LL);
    v22[7] = byte_stream_read_string(*(void *)(a1 + 24), 6uLL, 8LL);
    v22[8] = byte_stream_read_string(*(void *)(a1 + 24), 0xBuLL, 8LL);
    if (byte_stream_exception(*(void *)(a1 + 24)))
    {
      uint64_t v26 = "Could not parse the CPIO header";
      uint64_t v27 = a3;
      int v28 = 1743;
    }

    else if (*v22 == 29127)
    {
      *(void *)(a1 + 48) += 76LL;
      *(int64x2_t *)(a1 + 56) = vaddq_s64(*(int64x2_t *)(a1 + 56), (int64x2_t)xmmword_18635A730);
      uint64_t v33 = v22[8];
      if (v33 < 1 || !darc_format_entry_set_size((uint64_t)a2, v33))
      {
        size_t v37 = v22[7];
        if (v37)
        {
          if (require_minimum_amount(a1, v37, (char)"cpio entry name", a3))
          {
            uint64_t v26 = "Minimum amount necessary for CPIO name is unavailable";
            uint64_t v27 = a3;
            int v28 = 1785;
            goto LABEL_26;
          }

          byte_stream_attach(*(void *)(a1 + 24), *(void *)(a1 + 48), v22[7]);
          __int16 v38 = platform_calloc(*(void *)(a1 + 8), v22[7], 1uLL);
          if (!v38)
          {
            uint64_t v43 = v22[7];
            uint64_t v44 = __error();
            strerror(*v44);
            capture_error( a3,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_decoder.c",  1794,  (uint64_t)"parse_entry_cpio_header_decode",  "Could not allocate %ld bytes: %s",  v45,  v46,  v47,  v43);
            goto LABEL_27;
          }

          __int16 v39 = v38;
          byte_stream_read_buffer(*(uint64_t **)(a1 + 24), v38, v22[7]);
          if (byte_stream_exception(*(void *)(a1 + 24)))
          {
            capture_error( a3,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_decoder.c",  1802,  (uint64_t)"parse_entry_cpio_header_decode",  "Could not parse the CPIO name",  v40,  v41,  v42,  v51);
            free(v39);
            goto LABEL_27;
          }

          if (darc_format_entry_set_attribute((uint64_t)a2, "name", v39, v22[7]))
          {
            uint64_t v26 = "Could not set name attribute";
            uint64_t v27 = a3;
            int v28 = 1815;
            goto LABEL_26;
          }

          if (platform_strlen(*(void *)(a1 + 8), (char *)v39) == 10
            && !platform_strncmp(*(void *)(a1 + 8), (char *)v39, "TRAILER!!!", 0xAuLL))
          {
            *(_BYTE *)(a1 + 88) = 1;
          }

          platform_free(*(void *)(a1 + 8), v39);
          uint64_t v48 = v22[7];
          uint64_t v49 = *(void *)(a1 + 56) + v48;
          *(void *)(a1 + 48) += v48;
          *(void *)(a1 + 56) = v49;
          *(void *)(a1 + 64) -= v48;
        }

        int v50 = darc_format_entry_set_attribute((uint64_t)a2, "cpio header", v22, 0x48uLL);
        platform_free(*(void *)(a1 + 8), v22);
        if (v50)
        {
          uint64_t v16 = "parse_entry_cpio_header";
          uint64_t v17 = "Could not set cpio header attribute";
          uint64_t v18 = a3;
          int v19 = 1685;
        }

        else if (darc_format_entry_set_type(a2, 4))
        {
          uint64_t v16 = "parse_entry_cpio_header";
          uint64_t v17 = "Could not set entry type";
          uint64_t v18 = a3;
          int v19 = 1696;
        }

        else
        {
          uint64_t result = darc_format_entry_set_range((uint64_t)a2, v11, *(void *)(a1 + 56) - v11);
          if (!(_DWORD)result) {
            return result;
          }
          uint64_t v16 = "parse_entry_cpio_header";
          uint64_t v17 = "Could not set entry range";
          uint64_t v18 = a3;
          int v19 = 1705;
        }

        goto LABEL_12;
      }

      uint64_t v26 = "Could not set entry size";
      uint64_t v27 = a3;
      int v28 = 1764;
    }

    else
    {
      uint64_t v26 = "Invalid CPIO magic: %lld";
      uint64_t v51 = *v22;
      uint64_t v27 = a3;
      int v28 = 1749;
    }

LABEL_26:
    capture_error( v27,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_decoder.c",  v28,  (uint64_t)"parse_entry_cpio_header_decode",  v26,  v23,  v24,  v25,  v51);
LABEL_27:
    capture_error( a3,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_decoder.c",  1670,  (uint64_t)"parse_entry_cpio_header",  "Could not decode CPIO header",  v34,  v35,  v36,  v52);
    platform_free(*(void *)(a1 + 8), v22);
    return 0xFFFFFFFFLL;
  }

  while (!*(_BYTE *)(a1 + 80))
  {
    uint64_t v12 = *(void *)(a1 + 64);
    if (v12)
    {
      uint64_t v13 = v12 - 1;
      uint64_t v14 = *(void *)(a1 + 48) + 1LL;
      while (!*(_BYTE *)(v14 - 1))
      {
        uint64_t v15 = *(void *)(a1 + 56) + 1LL;
        *(void *)(a1 + 48) = v14;
        *(void *)(a1 + 56) = v15;
        *(void *)(a1 + 64) = v13--;
        ++v14;
        if (v13 == -1) {
          goto LABEL_7;
        }
      }

      uint64_t v16 = "parse_entry_cpio_padding";
      uint64_t v17 = "Could not populate the read buffer";
      uint64_t v18 = a3;
      int v19 = 1857;
      goto LABEL_12;
    }

    uint64_t v21 = (uint64_t *)*((void *)a1 + 3);
    uint64_t v15 = 1LL;
    BOMCopierErrorCapture( a5,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  2307,  (uint64_t)"BOMCopierDestinationEntrySeek",  "Could not update data analyzer");
    return v15;
  }

  if (!len) {
    goto LABEL_26;
  }
  uint64_t v16 = 0LL;
  while (1)
  {
    uint64_t v17 = len - v16 >= a3 ? a3 : len - v16;
    v18.ikey = 5521732;
    if (AAArchiveStreamWriteBlob(*((AAArchiveStream *)a1 + 42), v18, data, v17)) {
      break;
    }
    v16 += v17;
    if (v16 == len) {
      goto LABEL_26;
    }
  }

  uint64_t v15 = 1LL;
  BOMCopierErrorCapture( a5,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  7011,  (uint64_t)"seek_apple_archive",  "Could not write zeroes to AppleArchive: %u");
  return v15;
}

    if (*__error() == 2)
    {
      uint64_t v12 = 0LL;
      if (a5) {
        *a5 = 0;
      }
    }

    else
    {
      __error();
      uint64_t v12 = _checkCopyFileError(a1);
    }

    goto LABEL_36;
  }

  file = acl_get_file(path_p, ACL_TYPE_EXTENDED);
  if (!file) {
    goto LABEL_26;
  }
  int64x2_t v10 = file;
  uint64_t v11 = acl_get_file((const char *)(a1 + 3328), ACL_TYPE_EXTENDED);
LABEL_8:
  acl_p = v11;
  if (!v11)
  {
    if (*__error() != 2 && *__error() != 63) {
      goto LABEL_34;
    }
    acl_p = acl_init(4);
  }

  uint64_t v14 = v10;
  uint64_t v15 = 0;
  while (!acl_get_entry(v14, v15, &entry_p))
  {
    acl_get_flagset_np(entry_p, &flagset_d);
    if (!acl_get_flag_np(flagset_d, ACL_ENTRY_INHERITED)
      && (acl_create_entry(&acl_p, &v21) == -1 || acl_copy_entry(v21, entry_p) == -1))
    {
      goto LABEL_34;
    }

    if (entry_p) {
      uint64_t v15 = -1;
    }
    else {
      uint64_t v15 = 0;
    }
    uint64_t v14 = v10;
  }

  if (a3) {
    uint64_t v16 = (const char *)(a1 + 7424);
  }
  else {
    uint64_t v16 = (const char *)(a1 + 3328);
  }
  if (a4) {
    uint64_t v17 = acl_set_link_np(v16, ACL_TYPE_EXTENDED, acl_p);
  }
  else {
    uint64_t v17 = acl_set_file(v16, ACL_TYPE_EXTENDED, acl_p);
  }
  if (v17 != -1)
  {
    uint64_t v12 = 0LL;
    if (a5) {
      *a5 = 0;
    }
    goto LABEL_35;
  }

  int v29 = _findPage(v20, *(_DWORD *)(*(void *)(v17 + 32) + 4LL * v19));
  uint64_t v80 = v29;
  if (!v29)
  {
    __int128 v66 = __error();
    _BOMFatalException( (uint64_t)"BOMTree in invalid state - nextNode is NULL!\n",  "/Library/Caches/com.apple.xbs/Sources/Bom/Storage/BOMTree.c",  1604,  *v66);
  }

  uint64_t v30 = a7;
  uint64_t v31 = v25;
  uint64_t v32 = *((_WORD *)v29 + 2);
  if ((v32 & 8) == 0) {
    *((_WORD *)v29 + 2) = v32 | 8;
  }
  uint64_t v33 = v28;
  a3 = v72;
  if (v72) {
    *(_WORD *)(v72 + 4) &= ~4u;
  }
  a4 = v71;
  if (v71) {
    *(_WORD *)(v71 + 4) &= ~4u;
  }
  *((_WORD *)v29 + 2) &= ~4u;
  uint64_t result = _findRemove(v20, &v80, v21, v26, v68, v67, v30, v69, v78);
  if ((v31 & 1) == 0) {
    *((_WORD *)v21 + 2) &= ~8u;
  }
  if ((v33 & 1) == 0) {
    *((_WORD *)v26 + 2) &= ~8u;
  }
  uint64_t v15 = v20;
  if ((v32 & 8) == 0 && v80) {
    *((_WORD *)v80 + 2) &= ~8u;
  }
  uint64_t v14 = v74;
  a6 = v76;
  if (!(_DWORD)result)
  {
    uint64_t v23 = v81;
    if ((*(_WORD *)(v17 + 4) & 1) == 0) {
      goto LABEL_44;
    }
    goto LABEL_42;
  }

  return result;
}

  uint64_t v15 = (CC_SHA1_CTX *)a1[7];
  if (!v15)
  {
    uint64_t v15 = (CC_SHA1_CTX *)calloc(1uLL, 0x60uLL);
    a1[7] = (uint64_t)v15;
    if (!v15)
    {
      uint64_t v31 = *__error();
      uint64_t v32 = __error();
      strerror(*v32);
      BOMCopierErrorCapture( a2,  v31,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDataAnalyzer.c",  553,  (uint64_t)"init_data_analyzer",  "Could not allocate SHA1 context: %s");
      return 1LL;
    }
  }

  CC_SHA1_Init(v15);
  if (!a1[13])
  {
    uint64_t v16 = malloc(0x14uLL);
    a1[13] = (uint64_t)v16;
    if (!v16)
    {
      uint64_t v33 = *__error();
      uint64_t v34 = __error();
      strerror(*v34);
      BOMCopierErrorCapture( a2,  v33,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDataAnalyzer.c",  565,  (uint64_t)"init_data_analyzer",  "Could not allocate SHA1 digest: %s");
      return 1LL;
    }
  }

  ++v5;
  char v4 = *a1;
  if ((*a1 & 0x20) == 0)
  {
LABEL_6:
    if ((v4 & 0x40) == 0) {
      goto LABEL_7;
    }
LABEL_36:
    int v19 = (CC_SHA256_CTX *)a1[9];
    if (!v19)
    {
      int v19 = (CC_SHA256_CTX *)calloc(1uLL, 0x68uLL);
      a1[9] = (uint64_t)v19;
      if (!v19)
      {
        __int16 v39 = *__error();
        uint64_t v40 = __error();
        strerror(*v40);
        BOMCopierErrorCapture( a2,  v39,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDataAnalyzer.c",  615,  (uint64_t)"init_data_analyzer",  "Could not allocate SHA256 context: %s");
        return 1LL;
      }
    }

    CC_SHA256_Init(v19);
    if (!a1[15])
    {
      uint64_t v20 = malloc(0x20uLL);
      a1[15] = (uint64_t)v20;
      if (!v20)
      {
        uint64_t v41 = *__error();
        uint64_t v42 = __error();
        strerror(*v42);
        BOMCopierErrorCapture( a2,  v41,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDataAnalyzer.c",  627,  (uint64_t)"init_data_analyzer",  "Could not allocate SHA256 digest: %s");
        return 1LL;
      }
    }

    ++v5;
    if ((*a1 & 0x80) == 0) {
      goto LABEL_46;
    }
    goto LABEL_41;
  }

LABEL_7:
    if (populate_read_buffer(a1, *(void *)(a1 + 32), a3))
    {
      uint64_t v16 = "parse_entry_cpio_padding";
      uint64_t v17 = "Could not populate the read buffer";
      uint64_t v18 = a3;
      int v19 = 1867;
      goto LABEL_12;
    }
  }

  if (darc_format_entry_set_type(a2, 5))
  {
    uint64_t v16 = "parse_entry_cpio_padding";
    uint64_t v17 = "Could not set entry type";
    uint64_t v18 = a3;
    int v19 = 1879;
    goto LABEL_12;
  }

  uint64_t result = darc_format_entry_set_range((uint64_t)a2, v11, *(void *)(a1 + 56) - v11);
  if ((_DWORD)result)
  {
    uint64_t v16 = "parse_entry_cpio_padding";
    uint64_t v17 = "Could not set entry range";
    uint64_t v18 = a3;
    int v19 = 1888;
    goto LABEL_12;
  }

  return result;
}

  if (v12 >= a3) {
    uint64_t v13 = a3;
  }
  else {
    uint64_t v13 = v12;
  }
  if (v13)
  {
    platform_memcpy(*(void *)(a1 + 8), __dst, *(void **)(a1 + 48), v13);
    uint64_t v14 = *(void *)(a1 + 56) + v13;
    *(void *)(a1 + 48) += v13;
    *(void *)(a1 + 56) = v14;
    *(void *)(a1 + 64) -= v13;
  }

  return v13;
}

  BOMCopierDestinationEntryFree(a2);
  return 0LL;
}

  free(v13);
  return v23;
}

uint64_t parse_entry_pkzip(uint64_t a1, _DWORD *a2, void *a3)
{
  uint64_t v6 = *(void *)(a1 + 56);
  __int128 v104 = a2;
  __int128 v105 = a3;
  while (1)
  {
    byte_stream_attach(*(void *)(a1 + 24), *(void *)(a1 + 48), 4uLL);
    int uint32 = byte_stream_read_uint32(*(void *)(a1 + 24));
    if (byte_stream_exception(*(void *)(a1 + 24)))
    {
      uint64_t v15 = "parse_entry_pkzip";
      uint64_t v16 = "Could not parse the PKZip entry";
      uint64_t v17 = a3;
      int v18 = 1936;
      goto LABEL_61;
    }

    if (uint32 > 101075791)
    {
      if (uint32 <= 134630223)
      {
        if (uint32 == 101075792)
        {
          uint64_t v31 = a3;
          uint64_t v30 = platform_calloc(*(void *)(a1 + 8), 1uLL, 0x40uLL);
          if (!v30)
          {
            uint64_t v48 = __error();
            strerror(*v48);
            capture_error( a3,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_decoder.c",  3041,  (uint64_t)"parse_entry_pkzip_zip64_end_of_central_directory_record",  "Could not allocate %ld bytes for PKZip ZIP64 central directory header: %s",  v49,  v50,  v51,  64);
            return 0xFFFFFFFFLL;
          }

          int v22 = v30;
          byte_stream_set_byte_order(*(_DWORD **)(a1 + 24), 2);
          byte_stream_attach(*(void *)(a1 + 24), *(void *)(a1 + 48), 0x38uLL);
          *(_DWORD *)int v22 = byte_stream_read_uint32(*(void *)(a1 + 24));
          v22[1] = byte_stream_read_uint64(*(void *)(a1 + 24));
          *((_WORD *)v22 + 8) = byte_stream_read_uint16(*(void *)(a1 + 24));
          *((_WORD *)v22 + 9) = byte_stream_read_uint16(*(void *)(a1 + 24));
          *((_DWORD *)v22 + 5) = byte_stream_read_uint32(*(void *)(a1 + 24));
          *((_DWORD *)v22 + 6) = byte_stream_read_uint32(*(void *)(a1 + 24));
          v22[4] = byte_stream_read_uint64(*(void *)(a1 + 24));
          v22[5] = byte_stream_read_uint64(*(void *)(a1 + 24));
          v22[6] = byte_stream_read_uint64(*(void *)(a1 + 24));
          v22[7] = byte_stream_read_uint64(*(void *)(a1 + 24));
          if (byte_stream_exception(*(void *)(a1 + 24)))
          {
            uint64_t v23 = "parse_entry_pkzip_zip64_end_of_central_directory_record";
            uint64_t v24 = "Could not parse the PKZip ZIP64 end of central directory record";
            uint64_t v25 = a3;
            int v26 = 3062;
            goto LABEL_97;
          }

          if (*(_DWORD *)v22 != 101075792)
          {
            capture_error( a3,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_decoder.c",  3069,  (uint64_t)"parse_entry_pkzip_zip64_end_of_central_directory_record",  "Invalid PKZip ZIP64 end of central directory record signature: %04x",  v9,  v10,  v11,  *(_DWORD *)v22);
            goto LABEL_98;
          }

          uint64_t v61 = *(void *)(a1 + 48);
          uint64_t v62 = *(void *)(a1 + 56);
          *(void *)(a1 + 48) = v61 + 56;
          *(void *)(a1 + 56) = v62 + 56;
          uint64_t v63 = *(void *)(a1 + 64) - 56LL;
          *(void *)(a1 + 64) = v63;
          uint64_t v64 = v22[1];
          if (v64 - 56 >= 1)
          {
            *(void *)(a1 + 48) = v61 + v64;
            *(void *)(a1 + 56) = v64 + v62;
            *(void *)(a1 + 64) = v63 - (v64 - 56);
            uint64_t v15 = "parse_entry_pkzip_zip64_end_of_central_directory_record";
            uint64_t v16 = "TODO: parse ZIP64 extensible data";
            uint64_t v17 = a3;
            int v18 = 3087;
            goto LABEL_61;
          }

          uint64_t v34 = (uint64_t)a2;
          if (!darc_format_entry_set_type(a2, 12))
          {
            if (darc_format_entry_set_attribute( (uint64_t)a2,  "pkzip ZIP64 end of central directory record",  v22,  0x40uLL))
            {
              uint64_t v23 = "parse_entry_pkzip_zip64_end_of_central_directory_record";
              uint64_t v24 = "Could not set PKZip ZIP64 end of central directory record attribute";
              uint64_t v25 = v105;
              int v26 = 3110;
              goto LABEL_97;
            }

            goto LABEL_124;
          }

          uint64_t v23 = "parse_entry_pkzip_zip64_end_of_central_directory_record";
          uint64_t v24 = "Could not set entry type";
          uint64_t v25 = v105;
          int v26 = 3098;
          goto LABEL_97;
        }

        if (uint32 == 117853008)
        {
          uint64_t v31 = a3;
          if (require_minimum_amount( a1,  0x14uLL,  (char)"PKZip ZIP64 end of central directory locator read",  a3)) {
            return 0xFFFFFFFFLL;
          }
          uint64_t v33 = platform_calloc(*(void *)(a1 + 8), 1uLL, 0x18uLL);
          if (!v33)
          {
            char v52 = __error();
            strerror(*v52);
            capture_error( a3,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_decoder.c",  3155,  (uint64_t)"parse_entry_pkzip_zip64_end_of_central_directory_locator",  "Could not allocate %ld bytes for PKZip ZIP64 central directory locator: %s",  v53,  v54,  v55,  24);
            return 0xFFFFFFFFLL;
          }

          int v22 = v33;
          byte_stream_set_byte_order(*(_DWORD **)(a1 + 24), 2);
          byte_stream_attach(*(void *)(a1 + 24), *(void *)(a1 + 48), 0x14uLL);
          *(_DWORD *)int v22 = byte_stream_read_uint32(*(void *)(a1 + 24));
          *((_DWORD *)v22 + 1) = byte_stream_read_uint32(*(void *)(a1 + 24));
          v22[1] = byte_stream_read_uint64(*(void *)(a1 + 24));
          *((_DWORD *)v22 + 4) = byte_stream_read_uint32(*(void *)(a1 + 24));
          uint64_t v34 = (uint64_t)a2;
          if (byte_stream_exception(*(void *)(a1 + 24)))
          {
            uint64_t v23 = "parse_entry_pkzip_zip64_end_of_central_directory_locator";
            uint64_t v24 = "Could not parse the PKZip ZIP64 end of central directory locator";
            uint64_t v25 = v105;
            int v26 = 3170;
            goto LABEL_97;
          }

          if (*(_DWORD *)v22 != 117853008)
          {
            capture_error( v105,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_decoder.c",  3177,  (uint64_t)"parse_entry_pkzip_zip64_end_of_central_directory_locator",  "Invalid PKZip ZIP64 end of central directory record signature: %04x",  v9,  v10,  v11,  *(_DWORD *)v22);
            goto LABEL_98;
          }

          *(void *)(a1 + 48) += 20LL;
          *(int64x2_t *)(a1 + 56) = vaddq_s64(*(int64x2_t *)(a1 + 56), (int64x2_t)xmmword_18635A750);
          if (darc_format_entry_set_type(a2, 13))
          {
            uint64_t v23 = "parse_entry_pkzip_zip64_end_of_central_directory_locator";
            uint64_t v24 = "Could not set entry type";
            uint64_t v25 = v105;
            int v26 = 3191;
          }

          else
          {
            if (!darc_format_entry_set_attribute( (uint64_t)a2,  "pkzip ZIP64 end of central directory locator",  v22,  0x18uLL)) {
              goto LABEL_124;
            }
            uint64_t v23 = "parse_entry_pkzip_zip64_end_of_central_directory_locator";
            uint64_t v24 = "Could not set PKZip ZIP64 end of central directory locator attribute";
            uint64_t v25 = v105;
            int v26 = 3203;
          }

          goto LABEL_97;
        }
      }

      else
      {
        if (uint32 == 134630224)
        {
          uint64_t v31 = a3;
          byte_stream_set_byte_order(*(_DWORD **)(a1 + 24), 2);
          byte_stream_attach(*(void *)(a1 + 24), *(void *)(a1 + 48), 8uLL);
          int v19 = byte_stream_read_uint32(*(void *)(a1 + 24));
          unsigned int v20 = byte_stream_read_uint32(*(void *)(a1 + 24));
          if (byte_stream_exception(*(void *)(a1 + 24)))
          {
            uint64_t v15 = "parse_entry_pkzip_archive_extra_data";
            uint64_t v16 = "Could not parse the PKZip data descriptor";
            uint64_t v17 = a3;
            int v18 = 2516;
            goto LABEL_61;
          }

          if (v19 == 134630224)
          {
            *(void *)(a1 + 48) += 8LL;
            *(int64x2_t *)(a1 + 56) = vaddq_s64(*(int64x2_t *)(a1 + 56), (int64x2_t)xmmword_18635A770);
            if (!v20)
            {
              uint64_t v34 = (uint64_t)a2;
              uint64_t v15 = "parse_entry_pkzip_archive_extra_data";
              uint64_t v16 = "Could not set entry type";
              uint64_t v17 = v105;
              int v18 = 2554;
              goto LABEL_61;
            }

            if (!require_minimum_amount(a1, v20, (char)"PKZip extra data", a3))
            {
              uint64_t v38 = *(void *)(a1 + 56) + v20;
              *(void *)(a1 + 48) += v20;
              *(void *)(a1 + 56) = v38;
              *(void *)(a1 + 64) -= v20;
              uint64_t v15 = "parse_entry_pkzip_archive_extra_data";
              uint64_t v16 = "TODO: parse extra field";
              uint64_t v17 = a3;
              int v18 = 2543;
              goto LABEL_61;
            }
          }

          else
          {
            capture_error( a3,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_decoder.c",  2522,  (uint64_t)"parse_entry_pkzip_archive_extra_data",  "Invalid PKZip archive extra signature: %04x",  v9,  v10,  v11,  v19);
          }

          return 0xFFFFFFFFLL;
        }
      }

      goto LABEL_21;
    }

    if (uint32 <= 84233039)
    {
      if (uint32 != 33639248)
      {
        uint64_t v27 = a3;
        int v29 = platform_calloc(*(void *)(a1 + 8), 1uLL, 0x20uLL);
        if (!v29)
        {
          uint64_t v44 = __error();
          strerror(*v44);
          capture_error( a3,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_decoder.c",  2159,  (uint64_t)"parse_entry_pkzip_local_header",  "Could not allocate %ld bytes for PKZip local header: %s\n",  v45,  v46,  v47,  32);
          return 0xFFFFFFFFLL;
        }

        int v22 = v29;
        byte_stream_attach(*(void *)(a1 + 24), *(void *)(a1 + 48), 0x1EuLL);
        *(_DWORD *)int v22 = byte_stream_read_uint32(*(void *)(a1 + 24));
        *((_WORD *)v22 + 2) = byte_stream_read_uint16(*(void *)(a1 + 24));
        *((_WORD *)v22 + 3) = byte_stream_read_uint16(*(void *)(a1 + 24));
        *((_WORD *)v22 + 4) = byte_stream_read_uint16(*(void *)(a1 + 24));
        *((_WORD *)v22 + 5) = byte_stream_read_uint16(*(void *)(a1 + 24));
        *((_WORD *)v22 + 6) = byte_stream_read_uint16(*(void *)(a1 + 24));
        *((_DWORD *)v22 + 4) = byte_stream_read_uint32(*(void *)(a1 + 24));
        *((_DWORD *)v22 + 5) = byte_stream_read_uint32(*(void *)(a1 + 24));
        *((_DWORD *)v22 + 6) = byte_stream_read_uint32(*(void *)(a1 + 24));
        *((_WORD *)v22 + 14) = byte_stream_read_uint16(*(void *)(a1 + 24));
        *((_WORD *)v22 + 15) = byte_stream_read_uint16(*(void *)(a1 + 24));
        if (byte_stream_exception(*(void *)(a1 + 24)))
        {
          uint64_t v23 = "parse_entry_pkzip_local_header";
          uint64_t v24 = "Could not parse the PKZip local header";
          uint64_t v25 = a3;
          int v26 = 2179;
          goto LABEL_97;
        }

        if (*(_DWORD *)v22 != 67324752)
        {
          capture_error( a3,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_decoder.c",  2186,  (uint64_t)"parse_entry_pkzip_local_header",  "Invalid PKZip local header signature: %04x",  v9,  v10,  v11,  *(_DWORD *)v22);
          goto LABEL_98;
        }

        *(void *)(a1 + 48) += 30LL;
        *(int64x2_t *)(a1 + 56) = vaddq_s64(*(int64x2_t *)(a1 + 56), (int64x2_t)xmmword_18635A780);
        if (darc_format_entry_set_attribute((uint64_t)v104, "pkzip local header", v22, 0x20uLL))
        {
          uint64_t v23 = "parse_entry_pkzip_local_header";
          uint64_t v24 = "Could not set PKZip local header attribute";
          uint64_t v25 = a3;
          int v26 = 2204;
          goto LABEL_97;
        }

        uint64_t v77 = *((unsigned int *)v22 + 5);
        if ((_DWORD)v77 && darc_format_entry_set_size((uint64_t)v104, v77))
        {
          uint64_t v23 = "parse_entry_pkzip_local_header";
          uint64_t v24 = "Could not set entry size";
          uint64_t v25 = a3;
          int v26 = 2215;
          goto LABEL_97;
        }

        if (*((_WORD *)v22 + 14))
        {
          byte_stream_attach(*(void *)(a1 + 24), *(void *)(a1 + 48), *((unsigned __int16 *)v22 + 14));
          size_t v78 = *((unsigned __int16 *)v22 + 14) + 1LL;
          size_t v79 = platform_calloc(*(void *)(a1 + 8), v78, 1uLL);
          if (!v79)
          {
            __int16 v85 = *((_WORD *)v22 + 14);
            uint64_t v86 = __error();
            strerror(*v86);
            capture_error( v105,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_decoder.c",  2247,  (uint64_t)"parse_entry_pkzip_local_header",  "Could not allocate %d bytes: %s",  v87,  v88,  v89,  v85);
            goto LABEL_98;
          }

          size_t v69 = v79;
          byte_stream_read_buffer(*(uint64_t **)(a1 + 24), v79, *((unsigned __int16 *)v22 + 14));
          if (byte_stream_exception(*(void *)(a1 + 24)))
          {
            int v73 = "parse_entry_pkzip_local_header";
            int v74 = "Could not parse the PKZip file name";
            uint64_t v75 = a3;
            int v76 = 2256;
            goto LABEL_143;
          }

          if (darc_format_entry_set_attribute((uint64_t)v104, "name", v69, v78))
          {
            int v73 = "parse_entry_pkzip_local_header";
            int v74 = "Could not set entry name";
            uint64_t v75 = a3;
            int v76 = 2270;
            goto LABEL_143;
          }

          free(v69);
          uint64_t v99 = *((unsigned __int16 *)v22 + 14);
          uint64_t v100 = *(void *)(a1 + 56) + v99;
          *(void *)(a1 + 48) += v99;
          *(void *)(a1 + 56) = v100;
          *(void *)(a1 + 64) -= v99;
          uint64_t v27 = a3;
        }

        if (*((_WORD *)v22 + 15)
          && parse_entry_pkzip_extra_field( (uint64_t *)a1,  (uint64_t)v104,  *((unsigned __int16 *)v22 + 15),  1,  v27))
        {
          uint64_t v23 = "parse_entry_pkzip_local_header";
          uint64_t v24 = "Could not parse local header extra field";
          uint64_t v25 = v27;
          int v26 = 2290;
        }

        else
        {
          if ((*((_WORD *)v22 + 3) & 8) != 0)
          {
            else {
              *(_BYTE *)(a1 + 91) = 1;
            }
          }

          else
          {
            *(_WORD *)(a1 + 90) = 0;
          }

          uint64_t v34 = (uint64_t)v104;
          if (!darc_format_entry_set_type(v104, 6))
          {
            free(v22);
            uint64_t v31 = v105;
            goto LABEL_59;
          }

          uint64_t v23 = "parse_entry_pkzip_local_header";
          uint64_t v24 = "Could not set entry type";
          uint64_t v25 = v105;
          int v26 = 2326;
        }

        goto LABEL_97;
      }

      uint64_t v31 = a3;
      uint64_t v21 = platform_calloc(*(void *)(a1 + 8), 1uLL, 0x30uLL);
      if (!v21)
      {
        uint64_t v40 = __error();
        strerror(*v40);
        capture_error( a3,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_decoder.c",  2610,  (uint64_t)"parse_entry_pkzip_central_directory_header",  "Could not allocate %ld bytes for PKZip central directory header: %s",  v41,  v42,  v43,  48);
        return 0xFFFFFFFFLL;
      }

      int v22 = v21;
      byte_stream_set_byte_order(*(_DWORD **)(a1 + 24), 2);
      byte_stream_attach(*(void *)(a1 + 24), *(void *)(a1 + 48), 0x2EuLL);
      *(_DWORD *)int v22 = byte_stream_read_uint32(*(void *)(a1 + 24));
      *((_WORD *)v22 + 2) = byte_stream_read_uint16(*(void *)(a1 + 24));
      *((_WORD *)v22 + 3) = byte_stream_read_uint16(*(void *)(a1 + 24));
      *((_WORD *)v22 + 4) = byte_stream_read_uint16(*(void *)(a1 + 24));
      *((_WORD *)v22 + 5) = byte_stream_read_uint16(*(void *)(a1 + 24));
      *((_WORD *)v22 + 6) = byte_stream_read_uint16(*(void *)(a1 + 24));
      *((_WORD *)v22 + 7) = byte_stream_read_uint16(*(void *)(a1 + 24));
      *((_DWORD *)v22 + 4) = byte_stream_read_uint32(*(void *)(a1 + 24));
      *((_DWORD *)v22 + 5) = byte_stream_read_uint32(*(void *)(a1 + 24));
      *((_DWORD *)v22 + 6) = byte_stream_read_uint32(*(void *)(a1 + 24));
      *((_WORD *)v22 + 14) = byte_stream_read_uint16(*(void *)(a1 + 24));
      *((_WORD *)v22 + 15) = byte_stream_read_uint16(*(void *)(a1 + 24));
      *((_WORD *)v22 + 16) = byte_stream_read_uint16(*(void *)(a1 + 24));
      *((_WORD *)v22 + 17) = byte_stream_read_uint16(*(void *)(a1 + 24));
      *((_WORD *)v22 + 18) = byte_stream_read_uint16(*(void *)(a1 + 24));
      *((_DWORD *)v22 + 10) = byte_stream_read_uint32(*(void *)(a1 + 24));
      *((_DWORD *)v22 + 11) = byte_stream_read_uint32(*(void *)(a1 + 24));
      if (byte_stream_exception(*(void *)(a1 + 24)))
      {
        uint64_t v23 = "parse_entry_pkzip_central_directory_header";
        uint64_t v24 = "Could not parse the PKZip data descriptor";
        uint64_t v25 = a3;
        int v26 = 2638;
        goto LABEL_97;
      }

      if (*(_DWORD *)v22 != 33639248)
      {
        capture_error( a3,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_decoder.c",  2645,  (uint64_t)"parse_entry_pkzip_central_directory_header",  "Invalid PKZip central directory header signature: %04x",  v9,  v10,  v11,  *(_DWORD *)v22);
        goto LABEL_98;
      }

      *(void *)(a1 + 48) += 46LL;
      *(int64x2_t *)(a1 + 56) = vaddq_s64(*(int64x2_t *)(a1 + 56), (int64x2_t)xmmword_18635A760);
      int v60 = a2;
      if (darc_format_entry_set_attribute((uint64_t)a2, "pkzip central directory header", v22, 0x30uLL))
      {
        uint64_t v23 = "parse_entry_pkzip_central_directory_header";
        uint64_t v24 = "Could not set PKZip central directory header attribute";
        uint64_t v25 = v105;
        int v26 = 2663;
        goto LABEL_97;
      }

      if (*((_WORD *)v22 + 14))
      {
        byte_stream_attach(*(void *)(a1 + 24), *(void *)(a1 + 48), *((unsigned __int16 *)v22 + 14));
        size_t v67 = *((unsigned __int16 *)v22 + 14) + 1LL;
        __int128 v68 = platform_calloc(*(void *)(a1 + 8), v67, 1uLL);
        if (!v68)
        {
          __int16 v80 = *((_WORD *)v22 + 14);
          int v81 = __error();
          strerror(*v81);
          capture_error( v105,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_decoder.c",  2694,  (uint64_t)"parse_entry_pkzip_central_directory_header",  "Could not allocate %d bytes: %s",  v82,  v83,  v84,  v80);
          goto LABEL_98;
        }

        size_t v69 = v68;
        byte_stream_read_buffer(*(uint64_t **)(a1 + 24), v68, *((unsigned __int16 *)v22 + 14));
        if (byte_stream_exception(*(void *)(a1 + 24)))
        {
          int v73 = "parse_entry_pkzip_central_directory_header";
          int v74 = "Could not parse the PKZip file name";
          uint64_t v75 = v105;
          int v76 = 2703;
LABEL_143:
          capture_error( v75,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_decoder.c",  v76,  (uint64_t)v73,  v74,  v70,  v71,  v72,  v103);
          free(v69);
          goto LABEL_98;
        }

        if (darc_format_entry_set_attribute((uint64_t)a2, "name", v69, v67))
        {
          int v73 = "parse_entry_pkzip_central_directory_header";
          int v74 = "Could not set entry name";
          uint64_t v75 = v105;
          int v76 = 2717;
          goto LABEL_143;
        }

        free(v69);
        uint64_t v90 = *((unsigned __int16 *)v22 + 14);
        uint64_t v91 = *(void *)(a1 + 56) + v90;
        *(void *)(a1 + 48) += v90;
        *(void *)(a1 + 56) = v91;
        *(void *)(a1 + 64) -= v90;
        uint64_t v31 = v105;
        int v60 = a2;
      }

      if (*((_WORD *)v22 + 15)
        && parse_entry_pkzip_extra_field( (uint64_t *)a1,  (uint64_t)v60,  *((unsigned __int16 *)v22 + 15),  0,  v31))
      {
        uint64_t v23 = "parse_entry_pkzip_central_directory_header";
        uint64_t v24 = "Could not parse central directory header extra field";
        uint64_t v25 = v31;
        int v26 = 2737;
        goto LABEL_97;
      }

      if (*((_WORD *)v22 + 16))
      {
        byte_stream_attach(*(void *)(a1 + 24), *(void *)(a1 + 48), *((unsigned __int16 *)v22 + 16));
        size_t v92 = *((unsigned __int16 *)v22 + 16);
        uint64_t v93 = platform_calloc(*(void *)(a1 + 8), v92, 1uLL);
        if (!v93)
        {
          __int16 v94 = *((_WORD *)v22 + 16);
          __int16 v95 = __error();
          strerror(*v95);
          capture_error( v105,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_decoder.c",  2769,  (uint64_t)"parse_entry_pkzip_central_directory_header",  "Could not allocate %d bytes: %s",  v96,  v97,  v98,  v94);
          goto LABEL_98;
        }

        size_t v69 = v93;
        byte_stream_read_buffer(*(uint64_t **)(a1 + 24), v93, *((unsigned __int16 *)v22 + 16));
        if (byte_stream_exception(*(void *)(a1 + 24)))
        {
          int v73 = "parse_entry_pkzip_central_directory_header";
          int v74 = "Could not parse the PKZip file comment";
          uint64_t v75 = v105;
          int v76 = 2778;
          goto LABEL_143;
        }

        if (darc_format_entry_set_attribute( (uint64_t)a2,  "pkzip central directory file comment",  v69,  v92))
        {
          int v73 = "parse_entry_pkzip_central_directory_header";
          int v74 = "Could not set entry file comment";
          uint64_t v75 = v105;
          int v76 = 2787;
          goto LABEL_143;
        }

        free(v69);
        uint64_t v101 = *((unsigned __int16 *)v22 + 16);
        uint64_t v102 = *(void *)(a1 + 56) + v101;
        *(void *)(a1 + 48) += v101;
        *(void *)(a1 + 56) = v102;
        *(void *)(a1 + 64) -= v101;
        uint64_t v31 = v105;
        int v60 = a2;
      }

      if (darc_format_entry_set_type(v60, 10))
      {
        uint64_t v23 = "parse_entry_pkzip_central_directory_header";
        uint64_t v24 = "Could not set entry type";
        uint64_t v25 = v31;
        int v26 = 2805;
        goto LABEL_97;
      }

      free(v22);
LABEL_58:
      uint64_t v34 = (uint64_t)a2;
      goto LABEL_59;
    }

    if (uint32 == 101010256)
    {
      uint64_t v31 = a3;
      size_t v37 = platform_calloc(*(void *)(a1 + 8), 1uLL, 0x18uLL);
      if (!v37)
      {
        char v56 = __error();
        strerror(*v56);
        capture_error( a3,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_decoder.c",  2920,  (uint64_t)"parse_entry_pkzip_end_of_central_directory_record",  "Could not allocate %ld bytes for PKZip central directory header: %s",  v57,  v58,  v59,  24);
        return 0xFFFFFFFFLL;
      }

      int v22 = v37;
      byte_stream_set_byte_order(*(_DWORD **)(a1 + 24), 2);
      byte_stream_attach(*(void *)(a1 + 24), *(void *)(a1 + 48), 0x16uLL);
      *(_DWORD *)int v22 = byte_stream_read_uint32(*(void *)(a1 + 24));
      *((_WORD *)v22 + 2) = byte_stream_read_uint16(*(void *)(a1 + 24));
      *((_WORD *)v22 + 3) = byte_stream_read_uint16(*(void *)(a1 + 24));
      *((_WORD *)v22 + 4) = byte_stream_read_uint16(*(void *)(a1 + 24));
      *((_WORD *)v22 + 5) = byte_stream_read_uint16(*(void *)(a1 + 24));
      *((_DWORD *)v22 + 3) = byte_stream_read_uint32(*(void *)(a1 + 24));
      *((_DWORD *)v22 + 4) = byte_stream_read_uint32(*(void *)(a1 + 24));
      *((_WORD *)v22 + 10) = byte_stream_read_uint16(*(void *)(a1 + 24));
      if (byte_stream_exception(*(void *)(a1 + 24)))
      {
        uint64_t v23 = "parse_entry_pkzip_end_of_central_directory_record";
        uint64_t v24 = "Could not parse the PKZip data descriptor";
        uint64_t v25 = a3;
        int v26 = 2939;
        goto LABEL_97;
      }

      if (*(_DWORD *)v22 == 101010256)
      {
        *(void *)(a1 + 48) += 22LL;
        *(int64x2_t *)(a1 + 56) = vaddq_s64(*(int64x2_t *)(a1 + 56), (int64x2_t)xmmword_18635A740);
        if (*((_WORD *)v22 + 10))
        {
          if (!require_minimum_amount(a1, *((unsigned __int16 *)v22 + 10), (char)".ZIP file comment", a3))
          {
            uint64_t v65 = *((unsigned __int16 *)v22 + 10);
            uint64_t v66 = *(void *)(a1 + 56) + v65;
            *(void *)(a1 + 48) += v65;
            *(void *)(a1 + 56) = v66;
            *(void *)(a1 + 64) -= v65;
            uint64_t v15 = "parse_entry_pkzip_end_of_central_directory_record";
            uint64_t v16 = "TODO: parse .ZIP file comment";
            uint64_t v17 = a3;
            int v18 = 2969;
            goto LABEL_61;
          }

LABEL_98:
          free(v22);
          return 0xFFFFFFFFLL;
        }

        uint64_t v34 = (uint64_t)a2;
        if (darc_format_entry_set_type(a2, 14))
        {
          uint64_t v23 = "parse_entry_pkzip_end_of_central_directory_record";
          uint64_t v24 = "Could not set entry type";
          uint64_t v25 = v105;
          int v26 = 2980;
          goto LABEL_97;
        }

        if (darc_format_entry_set_attribute( (uint64_t)a2,  "pkzip end of central directory record",  v22,  0x18uLL))
        {
          uint64_t v23 = "parse_entry_pkzip_end_of_central_directory_record";
          uint64_t v24 = "Could not set PKZip end of central directory record attribute";
          uint64_t v25 = v105;
          int v26 = 2992;
          goto LABEL_97;
        }

LABEL_124:
        free(v22);
        goto LABEL_59;
      }

      uint64_t v23 = "parse_entry_pkzip_end_of_central_directory_record";
      uint64_t v24 = "Invalid PKZip end of central directory record signature: %04x";
      int v103 = *(_DWORD *)v22;
      uint64_t v25 = a3;
      int v26 = 2946;
LABEL_97:
      capture_error( v25,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_decoder.c",  v26,  (uint64_t)v23,  v24,  v9,  v10,  v11,  v103);
      goto LABEL_98;
    }

LABEL_21:
    if ((~uint32 & 0x3000000) != 0)
    {
      if (*(unsigned __int8 *)(a1 + 91) | *(unsigned __int8 *)(a1 + 90))
      {
        int uint32 = 0;
LABEL_55:
        uint64_t v34 = (uint64_t)a2;
        uint64_t v31 = v105;
LABEL_59:
        uint64_t result = darc_format_entry_set_range(v34, v6, *(void *)(a1 + 56) - v6);
        if (!(_DWORD)result) {
          return result;
        }
        uint64_t v15 = "parse_entry_pkzip";
        uint64_t v16 = "Could not set entry range\n";
        uint64_t v17 = v31;
        int v18 = 2109;
LABEL_61:
        capture_error( v17,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_decoder.c",  v18,  (uint64_t)v15,  v16,  v9,  v10,  v11,  v103);
        return 0xFFFFFFFFLL;
      }

      uint64_t v13 = *(void *)(a1 + 56) + 1LL;
      ++*(void *)(a1 + 48);
      *(void *)(a1 + 56) = v13;
      uint64_t v14 = *(void *)(a1 + 64) - 1LL;
      *(void *)(a1 + 64) = v14;
      if (!v14)
      {
        uint64_t v31 = a3;
        capture_error( a3,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_decoder.c",  2080,  (uint64_t)"parse_entry_pkzip",  "Could not find a PKZip signature",  v9,  v10,  v11,  v103);
        *(_BYTE *)(a1 + 80) = 1;
        goto LABEL_58;
      }
    }

    else
    {
      *(void *)(a1 + 48) += 2LL;
      int64x2_t v12 = vaddq_s64(*(int64x2_t *)(a1 + 56), (int64x2_t)xmmword_18635A790);
      *(int64x2_t *)(a1 + 56) = v12;
      uint64_t v13 = v12.i64[0];
    }

    uint64_t v6 = v13;
  }

  uint64_t v31 = a3;
  byte_stream_set_byte_order(*(_DWORD **)(a1 + 24), 2);
  byte_stream_attach(*(void *)(a1 + 24), *(void *)(a1 + 48), 6uLL);
  int v35 = byte_stream_read_uint32(*(void *)(a1 + 24));
  unsigned int uint16 = byte_stream_read_uint16(*(void *)(a1 + 24));
  if (byte_stream_exception(*(void *)(a1 + 24)))
  {
    uint64_t v15 = "parse_entry_pkzip_digital_signature";
    uint64_t v16 = "Could not parse the PKZip digital signature";
    uint64_t v17 = a3;
    int v18 = 2858;
    goto LABEL_61;
  }

  if (v35 != 84233040)
  {
    capture_error( a3,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_decoder.c",  2864,  (uint64_t)"parse_entry_pkzip_digital_signature",  "Invalid PKZip archive digital signature signature: %04x",  v9,  v10,  v11,  v35);
    return 0xFFFFFFFFLL;
  }

  if (!require_minimum_amount(a1, uint16, (char)"PKZip archive digital signature", a3))
  {
    uint64_t v39 = *(void *)(a1 + 56) + uint16;
    *(void *)(a1 + 48) += uint16;
    *(void *)(a1 + 56) = v39;
    *(void *)(a1 + 64) -= uint16;
    goto LABEL_58;
  }

  return 0xFFFFFFFFLL;
}

    free(__s);
    return 0xFFFFFFFFLL;
  }

  uint64_t v11 = __error();
  BOMCopierErrorCapture( a4,  *v11,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c",  5104,  (uint64_t)"path_tree_node_push",  "Could not create node path for %s and %s\n",  a2,  *(const char **)a1);
  return 0xFFFFFFFFLL;
}

  int v19 = *(void (**)(uint64_t, _BYTE *, void))(a1 + 208);
  if (v19)
  {
    *(void *)buf = 0LL;
    v19(a1, buf, *(void *)(a1 + 216));
    if (*(void *)buf)
    {
      free(*(void **)(a3 + 120));
      *(void *)(a3 + 120) = *(void *)buf;
    }

    *(void *)(a1 + 208) = 0LL;
    *(void *)(a1 + 216) = 0LL;
  }

  unsigned int v20 = (char *)calloc(1uLL, 0x400uLL);
  *(void *)(a3 + 128) = v20;
  if (!v20)
  {
    uint64_t v33 = *__error();
    uint64_t v34 = __error();
    strerror(*v34);
    BOMCopierErrorCapture( a5,  v33,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  7975,  (uint64_t)"construct_filesystem_destination",  "Could not allocate destination name: %s");
    goto LABEL_87;
  }

  uint64_t v21 = (const char **)(a3 + 120);
  basename_r(*(const char **)(a3 + 120), v20);
  int v22 = (char *)calloc(1uLL, 0x400uLL);
  *(void *)(a3 + 136) = v22;
  if (!v22)
  {
    int v35 = *__error();
    uint64_t v36 = __error();
    strerror(*v36);
    BOMCopierErrorCapture( a5,  v35,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  7985,  (uint64_t)"construct_filesystem_destination",  "Could not allocate destination parent: %s");
    goto LABEL_87;
  }

  dirname_r(*v21, v22);
  uint64_t v23 = *(os_log_s **)a1;
  if (*(void *)a1 && os_log_type_enabled(*(os_log_t *)a1, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v24 = *v21;
    *(_DWORD *)buf = 136315138;
    *(void *)&buf[4] = v24;
    _os_log_impl(&dword_1862F3000, v23, OS_LOG_TYPE_DEFAULT, "destination_path: %s", buf, 0xCu);
  }

  if (*(_BYTE *)(a1 + 297) && (Type - 7 < 4 || Type == 5) && !BOMCopierSourceEntryIsSegmentedFile(a2))
  {
    *(void *)buf = 0LL;
    if (asprintf((char **)buf, "%s/%s", *(const char **)(a3 + 136), ".BCD.T_XXXXXX") < 0 || !*(void *)buf)
    {
      uint64_t v62 = *__error();
      uint64_t v63 = *(void *)(a3 + 136);
      uint64_t v64 = __error();
      strerror(*v64);
      BOMCopierErrorCapture( a5,  v62,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  8030,  (uint64_t)"construct_filesystem_destination",  "Could not construct atomic template path from %s and %s: %s",  v63);
      goto LABEL_87;
    }

    uint64_t v25 = mktemp(*(char **)buf);
    if (v25 != *(char **)buf)
    {
      int v26 = *__error();
      uint64_t v27 = *(const char **)buf;
      int v28 = __error();
      int v29 = strerror(*v28);
      BOMCopierErrorCapture( a5,  v26,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  8040,  (uint64_t)"construct_filesystem_destination",  "Could not mktemp %s and %s: %s",  v27,  v29,  v174);
      free(*(void **)buf);
      goto LABEL_87;
    }

    size_t v37 = v25;
    *(void *)(a3 + 144) = v25;
    *(_BYTE *)(a3 + 152) = 1;
  }

  else
  {
    size_t v37 = strdup(*(const char **)(a3 + 120));
    *(void *)(a3 + 144) = v37;
    if (!v37)
    {
      int v60 = *__error();
      uint64_t v61 = __error();
      strerror(*v61);
      BOMCopierErrorCapture( a5,  v60,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  8064,  (uint64_t)"construct_filesystem_destination",  "Could not duplicate %s: %s");
      goto LABEL_87;
    }
  }

  uint64_t v38 = *(os_log_s **)a1;
  if (*(void *)a1 && os_log_type_enabled(*(os_log_t *)a1, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 136315138;
    *(void *)&buf[4] = v37;
    _os_log_impl(&dword_1862F3000, v38, OS_LOG_TYPE_DEFAULT, "destination_staging_path: %s", buf, 0xCu);
  }

  uint64_t v39 = 0;
  while (1)
  {
    uint64_t v40 = v39;
    *(_BYTE *)(a3 + 153) = 1;
    if (lstat(*(const char **)(a3 + 120), (stat *)(a3 + 168)))
    {
      if (*__error() != 2)
      {
        size_t v79 = *__error();
        __int16 v80 = __error();
        strerror(*v80);
        BOMCopierErrorCapture( a5,  v79,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  8097,  (uint64_t)"resolve_filesystem_conflict",  "Could not lstat %s: %s");
        goto LABEL_119;
      }

      *(_BYTE *)(a3 + 153) = 0;
      goto LABEL_95;
    }

    uint64_t v41 = BOMCopierSourceEntryGetType(a2);
    uint64_t v42 = *(os_log_t *)a1;
    uint64_t v43 = *(_WORD *)(a3 + 172) & 0xF000;
    switch(v41)
    {
      case 0u:
        BOMCopierErrorCapture( a5,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  8353,  (uint64_t)"check_filesystem_conflict",  "The source entry is unknown");
        goto LABEL_118;
      case 1u:
        BOMCopierErrorCapture( a5,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  8359,  (uint64_t)"check_filesystem_conflict",  "The source entry is a circular directory");
        goto LABEL_118;
      case 2u:
        BOMCopierErrorCapture( a5,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  8365,  (uint64_t)"check_filesystem_conflict",  "The source entry is an unreadable directory");
LABEL_118:
        BOMCopierErrorCapture( a5,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  8122,  (uint64_t)"resolve_filesystem_conflict",  "Could not check for a destination conflict for %s");
        goto LABEL_119;
      case 3u:
      case 0xDu:
      case 0xEu:
      case 0xFu:
      case 0x10u:
      case 0x11u:
      case 0x12u:
      case 0x13u:
        goto LABEL_95;
      case 6u:
        if (v43 == 0x4000) {
          goto LABEL_95;
        }
        if (!v42 || !os_log_type_enabled(*(os_log_t *)a1, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_57;
        }
        *(_WORD *)buf = 0;
        uint64_t v44 = v42;
        uint64_t v45 = "Filesystem Conflict: The source entry is a Directory but the destination entry is not.";
        break;
      default:
        if (v43 != 0x4000) {
          goto LABEL_95;
        }
        if (!v42 || !os_log_type_enabled(*(os_log_t *)a1, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_57;
        }
        *(_WORD *)buf = 0;
        uint64_t v44 = v42;
        uint64_t v45 = "Filesystem Conflict: The source entry is not a Directory but the destination entry is.";
        break;
    }

    _os_log_impl(&dword_1862F3000, v44, OS_LOG_TYPE_DEFAULT, v45, buf, 2u);
LABEL_57:
    uint64_t v46 = *(os_log_s **)a1;
    if (*(void *)a1 && os_log_type_enabled(*(os_log_t *)a1, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v47 = *(void *)(a3 + 120);
      uint64_t v48 = *(const char **)(a3 + 144);
      *(_DWORD *)buf = 136315394;
      *(void *)&buf[4] = v47;
      v181 = 2080;
      v182 = v48;
      _os_log_impl(&dword_1862F3000, v46, OS_LOG_TYPE_DEFAULT, "%s conflicts with %s", buf, 0x16u);
    }

    if (v41 == 6)
    {
      uint64_t v49 = *(_WORD *)(a3 + 172);
      if ((v49 & 0xF000) == 0xA000) {
        break;
      }
    }

    uint64_t v58 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, void, void *))(a1 + 224);
    if (!v58)
    {
      string_for_mode(*(_WORD *)(a3 + 172));
      string_for_entry_type(v41);
      BOMCopierErrorCapture( a5,  21,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  8322,  (uint64_t)"resolve_filesystem_conflict",  "%s: conflict replacing %s with %s",  *(void *)(a3 + 120));
      goto LABEL_119;
    }

  *v4 |= 0x10uLL;
  if ((v3 & 0x20) == 0)
  {
LABEL_8:
    if ((v3 & 0x40) == 0) {
      goto LABEL_9;
    }
    goto LABEL_23;
  }

  uint64_t v13 = (CC_MD5_CTX *)a1[6];
  if (!v13)
  {
    uint64_t v13 = (CC_MD5_CTX *)calloc(1uLL, 0x5CuLL);
    a1[6] = (uint64_t)v13;
    if (!v13)
    {
      uint64_t v27 = *__error();
      int v28 = __error();
      strerror(*v28);
      BOMCopierErrorCapture( a2,  v27,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDataAnalyzer.c",  519,  (uint64_t)"init_data_analyzer",  "Could not allocate MD5 context: %s");
      return 1LL;
    }
  }

  CC_MD5_Init(v13);
  if (!a1[12])
  {
    uint64_t v14 = malloc(0x10uLL);
    a1[12] = (uint64_t)v14;
    if (!v14)
    {
      int v29 = *__error();
      uint64_t v30 = __error();
      strerror(*v30);
      BOMCopierErrorCapture( a2,  v29,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDataAnalyzer.c",  534,  (uint64_t)"init_data_analyzer",  "Could not allocate MD5 digest: %s");
      return 1LL;
    }
  }

  ++v5;
  char v4 = *a1;
  if ((*a1 & 0x10) == 0)
  {
LABEL_5:
    if ((v4 & 0x20) == 0) {
      goto LABEL_6;
    }
    goto LABEL_31;
  }

  *((_BYTE *)v10 + 395) = a2;
  *((_BYTE *)v10 + 403) = a2;
  *((_DWORD *)v10 + 102) = 16843009 * a2;
  *((_WORD *)v10 + 206) = 257 * a2;
  if ((a3 & 0x1000) == 0)
  {
LABEL_12:
    if ((a3 & 0x800) == 0) {
      goto LABEL_13;
    }
LABEL_23:
    *((_BYTE *)v10 + 404) = a2;
    *((_BYTE *)v10 + 405) = a2;
    *((_BYTE *)v10 + 406) = a2;
    if ((a3 & 0x4000) == 0) {
      return v10;
    }
    goto LABEL_14;
  }

size_t data_archive_decoder_read_data( uint64_t a1, void *__dst, size_t a3, void *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1 || *(_DWORD *)a1 != 1919315316 || *(_DWORD *)(a1 + 92) != 1953326706)
  {
    uint64_t v15 = "Invalid decoder";
    uint64_t v16 = a4;
    int v17 = 648;
    goto LABEL_13;
  }

  if (!__dst)
  {
    uint64_t v15 = "Invalid read buffer";
    uint64_t v16 = a4;
    int v17 = 654;
    goto LABEL_13;
  }

  if (!a3)
  {
    uint64_t v15 = "Invalid bytes to read";
    uint64_t v16 = a4;
    int v17 = 660;
    goto LABEL_13;
  }

  size_t v12 = *(void *)(a1 + 64);
  if (!v12)
  {
    if (!populate_read_buffer(a1, *(void *)(a1 + 32), a4))
    {
      size_t v12 = *(void *)(a1 + 64);
      goto LABEL_7;
    }

    uint64_t v15 = "Could not populate the read buffer";
    uint64_t v16 = a4;
    int v17 = 673;
LABEL_13:
    capture_error( v16,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_decoder.c",  v17,  (uint64_t)"data_archive_decoder_read_data",  v15,  a6,  a7,  a8,  v19);
    return -1LL;
  }

uint64_t data_archive_decoder_rewind_data( uint64_t a1, void *__s2, size_t __n, void *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1 || *(_DWORD *)a1 != 1919315316 || *(_DWORD *)(a1 + 92) != 1953326706)
  {
    uint64_t v15 = "Invalid decoder";
    uint64_t v16 = a4;
    int v17 = 710;
    goto LABEL_9;
  }

  if (!__s2)
  {
    uint64_t v15 = "Invalid rewind buffer";
    uint64_t v16 = a4;
    int v17 = 716;
    goto LABEL_9;
  }

  if (!__n)
  {
    uint64_t v15 = "Invalid bytes to rewind";
    uint64_t v16 = a4;
    int v17 = 722;
    goto LABEL_9;
  }

  uint64_t v11 = *(void *)(a1 + 56);
  size_t v12 = (void *)(*(void *)(a1 + 48) - __n);
  uint64_t v13 = *(void *)(a1 + 64);
  uint64_t result = platform_memcmp(*(void *)(a1 + 8), v12, __s2, __n);
  if ((_DWORD)result)
  {
    uint64_t v15 = "Bytes don't match";
    uint64_t v16 = a4;
    int v17 = 732;
LABEL_9:
    capture_error( v16,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_decoder.c",  v17,  (uint64_t)"data_archive_decoder_rewind_data",  v15,  a6,  a7,  a8,  v18);
    return 0xFFFFFFFFLL;
  }

  *(void *)(a1 + 48) = v12;
  *(void *)(a1 + 56) = v11 - __n;
  *(void *)(a1 + 64) = v13 + __n;
  return result;
}

uint64_t require_minimum_amount(uint64_t a1, size_t a2, char a3, void *a4)
{
  if (populate_read_buffer(a1, a2, a4))
  {
    capture_error( a4,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_decoder.c",  4001,  (uint64_t)"require_minimum_amount",  "Could not populate read buffer for %s",  v8,  v9,  v10,  a3);
    return 0xFFFFFFFFLL;
  }

  size_t v11 = *(void *)(a1 + 64);
  if (v11 < a2)
  {
    capture_error( a4,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_decoder.c",  4007,  (uint64_t)"require_minimum_amount",  "Not enough data remaining (%ld) for %s (%ld)",  v8,  v9,  v10,  v11);
    return 0xFFFFFFFFLL;
  }

  return 0LL;
}

uint64_t parse_entry_posix_ustar_extended_metadata(uint64_t a1, uint64_t a2, void *a3)
{
  if (!require_minimum_amount(a1, 0x200uLL, (char)"POSIX ustar extended metadata", a3))
  {
    unint64_t v6 = platform_strnlen(*(void *)(a1 + 8), *(char **)(a1 + 48), 0x200uLL);
    if (v6 < 0x201)
    {
      if (v6 == a2)
      {
        printf("DALLAS: string_length = %lu\n", a2);
        uint64_t result = 0LL;
        *(void *)(a1 + 48) += 512LL;
        *(int64x2_t *)(a1 + 56) = vaddq_s64(*(int64x2_t *)(a1 + 56), (int64x2_t)xmmword_18635A720);
        return result;
      }

      capture_error( a3,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_decoder.c",  1607,  (uint64_t)"parse_entry_posix_ustar_extended_metadata",  "POSIX ustar extended metadata string length %lu does not match expected size %lu",  v7,  v8,  v9,  v6);
    }

    else
    {
      capture_error( a3,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_decoder.c",  1601,  (uint64_t)"parse_entry_posix_ustar_extended_metadata",  "POSIX ustar extended metadata string length %lu is larger than TAR record size %lu",  v7,  v8,  v9,  v6);
    }
  }

  return 0xFFFFFFFFLL;
}

uint64_t parse_entry_pkzip_data_descriptor(uint64_t a1, _DWORD *a2, int a3, void *a4)
{
  BOOL v8 = a3 == 134695760 || a3 == 808471376;
  int v9 = *(unsigned __int8 *)(a1 + 91);
  uint64_t v10 = 4LL;
  if (v8) {
    uint64_t v10 = 8LL;
  }
  size_t v11 = v10 + 8;
  uint64_t v12 = v10 | 0x10;
  if (*(_BYTE *)(a1 + 91)) {
    size_t v13 = v12;
  }
  else {
    size_t v13 = v11;
  }
  size_t v14 = platform_calloc(*(void *)(a1 + 8), 1uLL, 0x18uLL);
  if (!v14)
  {
    char v18 = __error();
    strerror(*v18);
    capture_error( a4,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_decoder.c",  2409,  (uint64_t)"parse_entry_pkzip_data_descriptor",  "Could not allocate %ld bytes for PKZip data descriptor: %s",  v19,  v20,  v21,  24);
    return 0xFFFFFFFFLL;
  }

  uint64_t v15 = v14;
  byte_stream_set_byte_order(*(_DWORD **)(a1 + 24), 2);
  byte_stream_attach(*(void *)(a1 + 24), *(void *)(a1 + 48), v13);
  *uint64_t v15 = 134695760;
  if (a3 == 808471376 || a3 == 134695760) {
    *uint64_t v15 = byte_stream_read_uint32(*(void *)(a1 + 24));
  }
  v15[1] = byte_stream_read_uint32(*(void *)(a1 + 24));
  uint64_t v16 = *(void *)(a1 + 24);
  if (v9)
  {
    *((void *)v15 + 1) = byte_stream_read_uint64(v16);
    unint64_t uint64 = byte_stream_read_uint64(*(void *)(a1 + 24));
  }

  else
  {
    *((void *)v15 + 1) = byte_stream_read_uint32(v16);
    unint64_t uint64 = byte_stream_read_uint32(*(void *)(a1 + 24));
  }

  *((void *)v15 + 2) = uint64;
  if (byte_stream_exception(*(void *)(a1 + 24)))
  {
    uint64_t v25 = "Could not parse the PKZip data descriptor";
    int v26 = a4;
    int v27 = 2438;
LABEL_24:
    capture_error( v26,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_decoder.c",  v27,  (uint64_t)"parse_entry_pkzip_data_descriptor",  v25,  v22,  v23,  v24,  v30);
    free(v15);
    return 0xFFFFFFFFLL;
  }

  if (*v15 != 134695760)
  {
    uint64_t v25 = "Invalid PKZip data descriptor signature: %04x";
    int v30 = *v15;
    int v26 = a4;
    int v27 = 2445;
    goto LABEL_24;
  }

  size_t v28 = *(void *)(a1 + 56) + v13;
  *(void *)(a1 + 48) += v13;
  *(void *)(a1 + 56) = v28;
  *(void *)(a1 + 64) -= v13;
  if (darc_format_entry_set_type(a2, 7))
  {
    uint64_t v25 = "Could not set entry type";
    int v26 = a4;
    int v27 = 2459;
    goto LABEL_24;
  }

  if (darc_format_entry_set_attribute((uint64_t)a2, "pkzip data descriptor", v15, 0x18uLL))
  {
    uint64_t v25 = "Could not set PKZip data descriptor attribute";
    int v26 = a4;
    int v27 = 2471;
    goto LABEL_24;
  }

  *(_WORD *)(a1 + 90) = 0;
  free(v15);
  return 0LL;
}

uint64_t parse_entry_pkzip_extra_field(uint64_t *a1, uint64_t a2, size_t a3, int a4, void *a5)
{
  uint64_t v5 = a5;
  byte_stream_attach(a1[3], a1[6], a3);
  if (!a3)
  {
LABEL_77:
    uint64_t result = byte_stream_remaining(a1[3]);
    if (result)
    {
      capture_error( v5,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_decoder.c",  3394,  (uint64_t)"parse_entry_pkzip_extra_field",  "%ld bytes remaining after parsing %s extra field",  v71,  v72,  v73,  result);
      return 0xFFFFFFFFLL;
    }

    size_t v74 = a1[7] + a3;
    a1[6] += a3;
    a1[7] = v74;
    a1[8] -= a3;
    return result;
  }

  uint64_t v10 = 0LL;
  __int16 v94 = v5;
  while (1)
  {
    int uint16 = byte_stream_read_uint16(a1[3]);
    unsigned int v12 = byte_stream_read_uint16(a1[3]);
    if (byte_stream_exception(a1[3]))
    {
      uint64_t v75 = "Exceed byte stream when parsing extra field";
      int v76 = v5;
      int v77 = 3268;
      goto LABEL_104;
    }

    uint64_t v16 = v10 + 4;
    if (uint16 > 21588)
    {
      if (uint16 != 21589)
      {
        if (uint16 != 22613)
        {
          uint64_t v17 = a1[6];
          byte_stream_new(a1[1], 0LL);
          if (v18)
          {
            uint64_t v22 = (void *)v18;
            uint64_t v23 = v17 + v16;
            uint64_t v24 = v12;
            byte_stream_attach(v18, v23, v12);
            DWORD2(v95) = 0;
            *(void *)&__int128 v95 = 0LL;
            LOBYTE(v95) = byte_stream_read_uint8((uint64_t)v22);
            unsigned int uint8 = byte_stream_read_uint8((uint64_t)v22);
            uint64_t v29 = uint8;
            if (uint8 == 4)
            {
              DWORD1(v95) = byte_stream_read_uint32((uint64_t)v22);
            }

            else
            {
              capture_error( v5,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_decoder.c",  3858,  (uint64_t)"parse_entry_pkzip_extra_field_infozip_unix_v3",  "Unrecognized uid size: %d",  v26,  v27,  v28,  uint8);
              byte_stream_advance((uint64_t)v22, v29);
            }

            if (byte_stream_read_uint8((uint64_t)v22) == 4)
            {
              DWORD2(v95) = byte_stream_read_uint32((uint64_t)v22);
            }

            else
            {
              capture_error( v5,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_decoder.c",  3869,  (uint64_t)"parse_entry_pkzip_extra_field_infozip_unix_v3",  "Unrecognized uid size: %d",  v63,  v64,  v65,  v29);
              byte_stream_advance((uint64_t)v22, v29);
            }

            if (byte_stream_exception((BOOL)v22))
            {
              size_t v78 = "Could not parse the PKZip Info-ZIP UNIX v3";
              size_t v79 = v5;
              int v80 = 3875;
            }

            else
            {
              size_t v78 = "Could not set ctime";
              size_t v79 = v5;
              int v80 = 3886;
            }
          }

          else
          {
            size_t v78 = "Could not create extra byte stream";
            size_t v79 = v5;
            int v80 = 3801;
          }

          capture_error( v79,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_decoder.c",  v80,  (uint64_t)"parse_entry_pkzip_extra_field_infozip_unix_v3",  v78,  v19,  v20,  v21,  v93);
          uint64_t v75 = "Could not parse extended timestamp";
          int v76 = v5;
          int v77 = 3349;
          goto LABEL_104;
        }

        uint64_t v49 = a1[6];
        byte_stream_new(a1[1], 0LL);
        if (v50)
        {
          uint64_t v22 = (void *)v50;
          uint64_t v54 = v49 + v16;
          uint64_t v24 = v12;
          byte_stream_attach(v50, v54, v12);
          __int128 v96 = 0uLL;
          *(void *)&__int128 v95 = byte_stream_read_uint32((uint64_t)v22);
          *((void *)&v95 + 1) = byte_stream_read_uint32((uint64_t)v22);
          if (v12 >= 0xA)
          {
            LOBYTE(v96) = 1;
            DWORD1(v96) = byte_stream_read_uint16((uint64_t)v22);
            if (v12 == 12)
            {
              BYTE8(v96) = 1;
              HIDWORD(v96) = byte_stream_read_uint16((uint64_t)v22);
            }
          }

          if (byte_stream_exception((BOOL)v22))
          {
            int v81 = "Could not parse the PKZip Info-ZIP extra block for UNIX";
            uint64_t v82 = v5;
            int v83 = 3769;
          }

          else
          {
            if (!darc_format_entry_set_attribute(a2, "pkzip extra field InfoZIP UNIX v1", &v95, 0x20uLL))
            {
LABEL_71:
              byte_stream_free(v22);
              goto LABEL_72;
            }

            int v81 = "Could not set ctime";
            uint64_t v82 = v5;
            int v83 = 3780;
          }
        }

        else
        {
          int v81 = "Could not create extra byte stream";
          uint64_t v82 = v5;
          int v83 = 3721;
        }

        capture_error( v82,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_decoder.c",  v83,  (uint64_t)"parse_entry_pkzip_extra_field_infozip_unix_v1",  v81,  v51,  v52,  v53,  v93);
        uint64_t v75 = "Could not parse extended timestamp";
        int v76 = v5;
        int v77 = 3329;
        goto LABEL_104;
      }

      uint64_t v40 = a1[6];
      byte_stream_new(a1[1], 0LL);
      if (!v41)
      {
        uint64_t v87 = "Could not create extra byte stream";
        uint64_t v88 = v5;
        int v89 = 3567;
        goto LABEL_101;
      }

      uint64_t v45 = (void *)v41;
      uint64_t v46 = v40 + v16;
      uint64_t v24 = v12;
      byte_stream_attach(v41, v46, v12);
      char v47 = byte_stream_read_uint8((uint64_t)v45);
      char v48 = v47;
      if (!a4)
      {
        __int128 v95 = 0uLL;
        unint64_t v66 = v12;
        *(void *)&__int128 v96 = 0LL;
        if (v12 >= 4)
        {
          unint64_t v66 = v12;
          if ((v47 & 1) != 0)
          {
            *(void *)&__int128 v95 = byte_stream_read_uint32((uint64_t)v45);
            unint64_t v66 = v12 - 4LL;
          }
        }

        if ((v48 & 2) != 0)
        {
          unint64_t v67 = v66 - 4;
          if (v66 >= 4)
          {
            *((void *)&v95 + 1) = byte_stream_read_uint32((uint64_t)v45);
            unint64_t v66 = v67;
          }
        }

        if ((v48 & 4) != 0 && v66 >= 4) {
          *(void *)&__int128 v96 = byte_stream_read_uint32((uint64_t)v45);
        }
        if (byte_stream_exception((BOOL)v45))
        {
          uint64_t v87 = "Could not parse the PKZip extended-timestamp extra block";
          uint64_t v5 = v94;
          uint64_t v88 = v94;
          int v89 = 3688;
          goto LABEL_101;
        }

        if (darc_format_entry_set_attribute(a2, "pkzip extra field extended timestamp", &v95, 0x18uLL))
        {
          uint64_t v87 = "Could not set timestamp";
          uint64_t v5 = v94;
          uint64_t v88 = v94;
          int v89 = 3699;
          goto LABEL_101;
        }

LABEL_72:
    byte_stream_advance(a1[3], v24);
    uint64_t v10 = v16 + v24;
    if (v10 == a3) {
      goto LABEL_77;
    }
  }

  if (uint16 != 10)
  {
LABEL_82:
    capture_error( v5,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_decoder.c",  3378,  (uint64_t)"parse_entry_pkzip_extra_field",  "Unrecognized extra field header ID: 0x%04x %d %d",  v13,  v14,  v15,  uint16);
    byte_stream_advance(a1[3], v12);
    return 0xFFFFFFFFLL;
  }

  uint64_t v30 = a1[6];
  byte_stream_new(a1[1], 0LL);
  if (!v31)
  {
    uint64_t v84 = "Could not create extra byte stream";
    __int16 v85 = v5;
    int v86 = 3907;
    goto LABEL_95;
  }

  uint64_t v22 = (void *)v31;
  uint64_t v35 = v30 + v16;
  uint64_t v24 = v12;
  byte_stream_attach(v31, v35, v12);
  LODWORD(v95) = byte_stream_read_uint32((uint64_t)v22);
  int v36 = byte_stream_read_uint16((uint64_t)v22);
  WORD2(v95) = v36;
  WORD3(v95) = byte_stream_read_uint16((uint64_t)v22);
  if (v36 != 1)
  {
    capture_error( v5,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_decoder.c",  3960,  (uint64_t)"parse_entry_pkzip_extra_field_ntfs",  "Unknown NTFS tag value: %u",  v37,  v38,  v39,  v36);
    goto LABEL_96;
  }

  *((void *)&v95 + 1) = byte_stream_read_uint64((uint64_t)v22);
  *(void *)&__int128 v96 = byte_stream_read_uint64((uint64_t)v22);
  *((void *)&v96 + 1) = byte_stream_read_uint64((uint64_t)v22);
  if (!byte_stream_exception((BOOL)v22))
  {
    if (darc_format_entry_set_attribute(a2, "pkzip extra field NTFS", &v95, 0x20uLL))
    {
      uint64_t v84 = "Could not set NTFS extra field";
      __int16 v85 = v5;
      int v86 = 3981;
      goto LABEL_95;
    }

    goto LABEL_71;
  }

  uint64_t v84 = "Could not parse the PKZip NTFS extra field";
  __int16 v85 = v5;
  int v86 = 3970;
LABEL_95:
  capture_error( v85,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_decoder.c",  v86,  (uint64_t)"parse_entry_pkzip_extra_field_ntfs",  v84,  v32,  v33,  v34,  v93);
LABEL_96:
  uint64_t v75 = "Could not parse NFTS extra field";
  int v76 = v5;
  int v77 = 3369;
LABEL_104:
  capture_error( v76,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_decoder.c",  v77,  (uint64_t)"parse_entry_pkzip_extra_field",  v75,  v13,  v14,  v15,  v93);
  return 0xFFFFFFFFLL;
}

void *data_source_new(uint64_t a1, uint64_t a2)
{
  if (a2) {
    return 0LL;
  }
  uint64_t result = platform_calloc(a1, 1uLL, 0x48uLL);
  if (result)
  {
    *(_DWORD *)uint64_t result = 1936876321;
    result[1] = a1;
    *((_DWORD *)result + 4) = -1;
    *((_DWORD *)result + 16) = 560165491;
  }

  return result;
}

void data_source_free(void *__b)
{
  if (__b && *(_DWORD *)__b == 1936876321 && *((_DWORD *)__b + 16) == 560165491)
  {
    uint64_t v2 = __b[1];
    platform_memset(v2, __b, 0LL, 0x48uLL);
    platform_free(v2, __b);
  }

_DWORD *data_source_set_fd(_DWORD *result, int a2)
{
  if (result && *result == 1936876321 && result[16] == 560165491) {
    result[4] = a2;
  }
  return result;
}

uint64_t data_source_set_handler(uint64_t result, uint64_t a2, uint64_t a3)
{
  if (result && *(_DWORD *)result == 1936876321 && *(_DWORD *)(result + 64) == 560165491)
  {
    *(void *)(result + 48) = a2;
    *(void *)(result + 56) = a3;
  }

  return result;
}

size_t data_source_read(uint64_t a1, void *a2, size_t a3)
{
  if (!a1 || *(_DWORD *)a1 != 1936876321 || *(_DWORD *)(a1 + 64) != 560165491) {
    return -1LL;
  }
  char v4 = *(uint64_t (**)(void, void, void *, size_t))(a1 + 56);
  if (v4) {
    return v4(*(void *)(a1 + 48), *(unsigned int *)(a1 + 16), a2, a3);
  }
  uint64_t v7 = *(void *)(a1 + 24);
  if (v7)
  {
    uint64_t v8 = *(void *)(a1 + 40);
    if (*(void *)(a1 + 32) - v8 >= a3) {
      size_t v6 = a3;
    }
    else {
      size_t v6 = *(void *)(a1 + 32) - v8;
    }
    if (v6)
    {
      platform_memcpy(*(void *)(a1 + 8), a2, (void *)(v7 + v8), v6);
      *(void *)(a1 + 40) += v6;
    }

    return v6;
  }

  return platform_read(*(void *)(a1 + 8), *(unsigned int *)(a1 + 16), a2, a3);
}

_DWORD *data_archive_new(uint64_t a1)
{
  if (a1) {
    return 0LL;
  }
  uint64_t result = platform_toolbox_new(0LL);
  if (result)
  {
    uint64_t v2 = result;
    uint64_t result = platform_calloc((uint64_t)result, 1uLL, 0xD0uLL);
    if (result)
    {
      *uint64_t result = 1684107875;
      *((void *)result + 1) = v2;
      result[5] = -1;
      result[50] = 1668440420;
    }

    else
    {
      platform_toolbox_free(v2);
      return 0LL;
    }
  }

  return result;
}

void data_archive_free(unsigned int *__b)
{
  if (__b && *__b == 1684107875 && __b[50] == 1668440420)
  {
    uint64_t v2 = (void *)*((void *)__b + 20);
    if (v2) {
      platform_free(*((void *)__b + 1), v2);
    }
    uint64_t v3 = (z_stream *)*((void *)__b + 15);
    if (v3)
    {
      inflateEnd(v3);
      platform_free(*((void *)__b + 1), *((void **)__b + 15));
    }

    char v4 = (void *)*((void *)__b + 12);
    if (v4) {
      platform_free(*((void *)__b + 1), v4);
    }
    uint64_t v5 = (void *)*((void *)__b + 5);
    if (v5) {
      data_archive_decoder_free(v5);
    }
    size_t v6 = (void *)*((void *)__b + 4);
    if (v6) {
      data_read_stream_free(v6);
    }
    uint64_t v7 = (void *)*((void *)__b + 3);
    if (v7 && *((_BYTE *)__b + 16)) {
      data_source_free(v7);
    }
    uint64_t v8 = __b[5];
    if ((_DWORD)v8 != -1)
    {
      if (*((_BYTE *)__b + 17)) {
        platform_close(*((void *)__b + 1), v8);
      }
    }

    int v9 = (void *)*((void *)__b + 1);
    platform_memset((uint64_t)v9, __b, 0LL, 0xD0uLL);
    platform_free((uint64_t)v9, __b);
    platform_toolbox_free(v9);
  }

uint64_t data_archive_set_passphrase_callback( uint64_t a1, uint64_t a2, uint64_t a3, void *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1 || *(_DWORD *)a1 != 1684107875 || *(_DWORD *)(a1 + 200) != 1668440420)
  {
    int v9 = "Invalid data archive";
    uint64_t v10 = a4;
    int v11 = 264;
LABEL_7:
    capture_error( v10,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive.c",  v11,  (uint64_t)"data_archive_set_passphrase_callback",  v9,  a6,  a7,  a8,  vars0);
    return 0xFFFFFFFFLL;
  }

  if (!a2)
  {
    int v9 = "Invalid passphrase callback";
    uint64_t v10 = a4;
    int v11 = 270;
    goto LABEL_7;
  }

  uint64_t v8 = 0LL;
  *(void *)(a1 + 128) = a2;
  *(void *)(a1 + 136) = a3;
  return v8;
}

uint64_t data_archive_open_source( uint64_t a1, uint64_t a2, void *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1 || *(_DWORD *)a1 != 1684107875 || *(_DWORD *)(a1 + 200) != 1668440420)
  {
    uint64_t v16 = "Invalid data archive";
    uint64_t v17 = a3;
    int v18 = 292;
LABEL_9:
    capture_error( v17,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive.c",  v18,  (uint64_t)"data_archive_open_source",  v16,  a6,  a7,  a8,  v27);
    return 0xFFFFFFFFLL;
  }

  if (!a2)
  {
    uint64_t v16 = "Invalid data source";
    uint64_t v17 = a3;
    int v18 = 298;
    goto LABEL_9;
  }

  *(void *)(a1 + 24) = a2;
  stream_new = data_read_stream_new(*(void *)(a1 + 8), 0LL);
  *(void *)(a1 + 32) = stream_new;
  if (!stream_new)
  {
    data_source_free(*(void **)(a1 + 24));
    *(void *)(a1 + 24) = 0LL;
    uint64_t v16 = "Could not create data read stream";
    uint64_t v17 = a3;
    int v18 = 310;
    goto LABEL_9;
  }

  int stream_set_source = data_read_stream_set_source((uint64_t)stream_new, *(void *)(a1 + 24));
  if (stream_set_source)
  {
    char v12 = stream_set_source;
    data_read_stream_free(*(void **)(a1 + 32));
    *(void *)(a1 + 32) = 0LL;
    data_source_free(*(void **)(a1 + 24));
    *(void *)(a1 + 24) = 0LL;
    capture_error( a3,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive.c",  323,  (uint64_t)"data_archive_open_source",  "Could not set source for read stream: %d",  v13,  v14,  v15,  v12);
    return 0xFFFFFFFFLL;
  }

  uint64_t v20 = data_archive_decoder_new(*(void *)(a1 + 8), 0LL);
  *(void *)(a1 + 40) = v20;
  if (!v20)
  {
    data_read_stream_free(*(void **)(a1 + 32));
    *(void *)(a1 + 32) = 0LL;
    data_source_free(*(void **)(a1 + 24));
    *(void *)(a1 + 24) = 0LL;
    uint64_t v16 = "Could not create data decoder";
    uint64_t v17 = a3;
    int v18 = 336;
    goto LABEL_9;
  }

  int v21 = data_archive_decoder_set_stream((uint64_t)v20, *(void *)(a1 + 32), a3);
  uint64_t v22 = *(void **)(a1 + 40);
  if (v21)
  {
    data_archive_decoder_free(v22);
    *(void *)(a1 + 40) = 0LL;
    data_read_stream_free(*(void **)(a1 + 32));
    *(void *)(a1 + 32) = 0LL;
    data_source_free(*(void **)(a1 + 24));
    *(void *)(a1 + 24) = 0LL;
    capture_error( a3,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive.c",  352,  (uint64_t)"data_archive_open_source",  "Could not set read stream for decoder: %d",  v23,  v24,  v25,  v21);
    return 0xFFFFFFFFLL;
  }

  int type = data_archive_decoder_get_type(v22);
  *(_DWORD *)(a1 + 48) = type;
  if (!type)
  {
    data_archive_decoder_free(*(void **)(a1 + 40));
    *(void *)(a1 + 40) = 0LL;
    data_read_stream_free(*(void **)(a1 + 32));
    *(void *)(a1 + 32) = 0LL;
    data_source_free(*(void **)(a1 + 24));
    *(void *)(a1 + 24) = 0LL;
    uint64_t v16 = "Unknown archive format";
    uint64_t v17 = a3;
    int v18 = 368;
    goto LABEL_9;
  }

  return 0LL;
}

uint64_t data_archive_open_fd( uint64_t a1, int a2, void *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1 && *(_DWORD *)a1 == 1684107875 && *(_DWORD *)(a1 + 200) == 1668440420)
  {
    if (a2 == -1)
    {
      uint64_t v19 = "Invalid file descriptor";
      uint64_t v20 = a3;
      int v21 = 393;
    }

    else
    {
      *(_BYTE *)(a1 + 16) = 1;
      int v11 = data_source_new(*(void *)(a1 + 8), 0LL);
      if (v11)
      {
        uint64_t v12 = (uint64_t)v11;
        data_source_set_fd(v11, a2);
        return data_archive_open_source(a1, v12, a3, v13, v14, v15, v16, v17);
      }

      uint64_t v19 = "Could not create data source";
      uint64_t v20 = a3;
      int v21 = 407;
    }
  }

  else
  {
    uint64_t v19 = "Invalid data archive";
    uint64_t v20 = a3;
    int v21 = 387;
  }

  capture_error( v20,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive.c",  v21,  (uint64_t)"data_archive_open_fd",  v19,  a6,  a7,  a8,  v22);
  return 0xFFFFFFFFLL;
}

uint64_t data_archive_open( uint64_t a1, char *__s, void *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1 || *(_DWORD *)a1 != 1684107875 || *(_DWORD *)(a1 + 200) != 1668440420)
  {
    int v18 = "Invalid data archive";
    uint64_t v19 = a3;
    int v20 = 428;
LABEL_9:
    capture_error( v19,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive.c",  v20,  (uint64_t)"data_archive_open",  v18,  a6,  a7,  a8,  v25);
    return 0xFFFFFFFFLL;
  }

  if (!__s)
  {
    int v18 = "Invalid path";
    uint64_t v19 = a3;
    int v20 = 434;
    goto LABEL_9;
  }

  if ((unint64_t)platform_strlen(*(void *)(a1 + 8), __s) <= 0x3FF)
  {
    int v11 = open(__s, 0);
    if (v11 != -1)
    {
      *(_BYTE *)(a1 + 17) = 1;
      return data_archive_open_fd(a1, v11, a3, v12, v13, v14, v15, v16);
    }

    int v21 = __error();
    strerror(*v21);
    capture_error( a3,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive.c",  447,  (uint64_t)"data_archive_open",  "Could not open %s: %s",  v22,  v23,  v24,  (char)__s);
  }

  return 0xFFFFFFFFLL;
}

uint64_t data_archive_open_custom( uint64_t a1, uint64_t a2, uint64_t a3, void *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1 && *(_DWORD *)a1 == 1684107875 && *(_DWORD *)(a1 + 200) == 1668440420)
  {
    if (a3)
    {
      *(_BYTE *)(a1 + 16) = 1;
      uint64_t v12 = data_source_new(*(void *)(a1 + 8), 0LL);
      if (v12)
      {
        uint64_t v13 = (uint64_t)v12;
        data_source_set_handler((uint64_t)v12, a2, a3);
        return data_archive_open_source(a1, v13, a4, v14, v15, v16, v17, v18);
      }

      int v20 = "Could not create data source";
      int v21 = a4;
      int v22 = 537;
    }

    else
    {
      int v20 = "Invalid read handler";
      int v21 = a4;
      int v22 = 523;
    }
  }

  else
  {
    int v20 = "Invalid data archive";
    int v21 = a4;
    int v22 = 517;
  }

  capture_error( v21,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive.c",  v22,  (uint64_t)"data_archive_open_custom",  v20,  a6,  a7,  a8,  v23);
  return 0xFFFFFFFFLL;
}

_DWORD *data_archive_read_entry( uint64_t a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1 || *(_DWORD *)a1 != 1684107875 || *(_DWORD *)(a1 + 200) != 1668440420)
  {
    uint64_t v15 = "Invalid data archive";
    uint64_t v16 = a2;
    int v17 = 557;
LABEL_11:
    capture_error( v16,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive.c",  v17,  (uint64_t)"data_archive_read_entry",  v15,  a6,  a7,  a8,  v45);
    return 0LL;
  }

  if (*(_DWORD *)(a1 + 48) == 2)
  {
    uint64_t v10 = *(void *)(a1 + 152);
    if (v10 >= 1)
    {
      int v11 = *(void **)(a1 + 160);
      if (!v11)
      {
        int v11 = platform_malloc(*(void *)(a1 + 8), 0x200uLL);
        *(void *)(a1 + 160) = v11;
        if (!v11)
        {
          uint64_t v40 = __error();
          char v41 = strerror(*v40);
          capture_error( a2,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive.c",  943,  (uint64_t)"consume_padding",  "Could not allocate padding buffer: %s",  v42,  v43,  v44,  v41);
          goto LABEL_38;
        }
      }

      if ((unint64_t)v10 >= 0x201)
      {
        capture_error( a2,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive.c",  950,  (uint64_t)"consume_padding",  "padding amount %lld is larger than buffer %lld",  a6,  a7,  a8,  v10);
LABEL_38:
        capture_error( a2,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive.c",  574,  (uint64_t)"data_archive_read_entry",  "Could not consume padding %llu",  v12,  v13,  v14,  *(void *)(a1 + 152));
        return 0LL;
      }

      if (data_archive_decoder_read_data(*(void *)(a1 + 40), v11, v10, 0LL, a5, a6, a7, a8) == -1LL)
      {
        capture_error( a2,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive.c",  957,  (uint64_t)"consume_padding",  "Could not consume %lld bytes of padding",  a6,  a7,  a8,  v10);
        goto LABEL_38;
      }

      *(void *)(a1 + 152) = 0LL;
    }
  }

  entry = data_archive_decoder_read_entry(*(void *)(a1 + 40), a2, a3, a4, a5, a6, a7, a8);
  if (!entry)
  {
LABEL_31:
    uint64_t v15 = "Could not read next decoder entry";
    uint64_t v16 = a2;
    int v17 = 596;
    goto LABEL_11;
  }

  int v21 = entry;
  int v22 = (void *)(a1 + 52);
  while (2)
  {
    char v23 = *(unsigned int (**)(uint64_t, void *, void, void *))(a1 + 184);
    if (v23 && v23(a1, v21, *(void *)(a1 + 192), a2))
    {
      uint64_t v15 = "Format entry callback failed";
      uint64_t v16 = a2;
      int v17 = 605;
      goto LABEL_11;
    }

    uint64_t v24 = data_archive_entry_new(*(void *)(a1 + 8), 0LL);
    uint64_t v18 = v24;
    if (!v24)
    {
      capture_error( a2,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive.c",  613,  (uint64_t)"data_archive_read_entry",  "Could not create empty archive entry",  v25,  v26,  v27,  v45);
      darc_format_entry_free(v21);
      return v18;
    }

    if (!data_archive_entry_set_format_entry( (uint64_t)v24,  *(_DWORD *)(a1 + 48),  *(_DWORD *)(a1 + 144),  v21,  a2,  v25,  v26,  v27))
    {
      *(_DWORD *)(a1 + 144) = darc_format_entry_get_type(v21);
      int v31 = *(_DWORD *)(a1 + 48);
      if (v31 == 2)
      {
        uint64_t v32 = data_archive_entry_size((uint64_t)v18);
        uint64_t v33 = 512 - v32;
        if (v32 >= 513) {
          uint64_t v33 = v32 & 0x1FF;
        }
        *(void *)(a1 + 152) = v33;
        int v31 = *(_DWORD *)(a1 + 48);
      }

      if (v31 == 9)
      {
        *(_DWORD *)(a1 + 148) = (data_archive_entry_crc32(v18) << 16) & 0xFF000000;
        *(_BYTE *)(a1 + 168) = 0;
      }

      darc_format_entry_free(v21);
      void *v22 = 0LL;
      *(void *)(a1 + 60) = 0LL;
      *(void *)(a1 + 73) = 0LL;
      *(void *)(a1 + 68) = 0LL;
      switch(data_archive_entry_get_type(v18))
      {
        case 0u:
          capture_error( a2,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive.c",  698,  (uint64_t)"data_archive_read_entry",  "Unknown entry type",  v37,  v38,  v39,  v45);
          data_archive_entry_free(v18);
          return 0LL;
        case 1u:
        case 3u:
          *(_DWORD *)int v22 = 1;
          return v18;
        case 2u:
          *(_DWORD *)(a1 + 52) = data_archive_entry_get_data_type(v18);
          *(void *)(a1 + 56) = data_archive_entry_compressed_size((uint64_t)v18);
          *(void *)(a1 + 64) = data_archive_entry_size((uint64_t)v18);
          return v18;
        case 4u:
          *(_DWORD *)int v22 = 1;
          data_archive_entry_free(v18);
          goto LABEL_30;
        default:
LABEL_30:
          int v21 = data_archive_decoder_read_entry(*(void *)(a1 + 40), a2, v34, v35, v36, v37, v38, v39);
          if (!v21) {
            goto LABEL_31;
          }
          continue;
      }
    }

    break;
  }

  capture_error( a2,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive.c",  627,  (uint64_t)"data_archive_read_entry",  "Could not set format entry",  v28,  v29,  v30,  v45);
  data_archive_entry_free(v18);
  darc_format_entry_free(v21);
  return 0LL;
}

size_t data_archive_read_data( uint64_t a1, void *a2, size_t a3, void *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1 || *(_DWORD *)a1 != 1684107875 || *(_DWORD *)(a1 + 200) != 1668440420)
  {
    uint64_t v13 = "data_archive_read_data";
    uint64_t v14 = "Invalid data archive";
    uint64_t v15 = a4;
    int v16 = 771;
    goto LABEL_9;
  }

  if (!a2)
  {
    uint64_t v13 = "data_archive_read_data";
    uint64_t v14 = "Invalid read buffer";
    uint64_t v15 = a4;
    int v16 = 777;
    goto LABEL_9;
  }

  if (!a3)
  {
    uint64_t v13 = "data_archive_read_data";
    uint64_t v14 = "Invalid read size";
    uint64_t v15 = a4;
    int v16 = 783;
LABEL_9:
    capture_error( v15,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive.c",  v16,  (uint64_t)v13,  v14,  a6,  a7,  a8,  v103);
    return -1LL;
  }

  switch(*(_DWORD *)(a1 + 52))
  {
    case 1:
      return 0LL;
    case 2:
      return read_data_direct((uint64_t *)a1, a2, a3, a4, a5, a6, a7, a8);
    case 3:
      if (*(_BYTE *)(a1 + 80)) {
        return 0LL;
      }
      if (*(void *)(a1 + 96)) {
        goto LABEL_18;
      }
      *(void *)(a1 + 88) = 0x20000LL;
      uint64_t v18 = platform_valloc(*(void *)(a1 + 8), 0x20000uLL);
      *(void *)(a1 + 96) = v18;
      if (!v18)
      {
        uint64_t v75 = *(void *)(a1 + 88);
        int v76 = __error();
        strerror(*v76);
        capture_error( a4,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive.c",  1027,  (uint64_t)"decompress_data",  "Could not allocate %ld for read buffer: %s",  v77,  v78,  v79,  v75);
        return -1LL;
      }

      platform_memset(*(void *)(a1 + 8), v18, 0LL, *(void *)(a1 + 88));
      *(void *)(a1 + 104) = *(void *)(a1 + 96);
      *(void *)(a1 + 112) = 0LL;
LABEL_18:
      if (*(void *)(a1 + 120)) {
        goto LABEL_19;
      }
      int v31 = (z_stream *)platform_calloc(*(void *)(a1 + 8), 1uLL, 0x70uLL);
      *(void *)(a1 + 120) = v31;
      if (!v31)
      {
        __int16 v85 = __error();
        char v86 = strerror(*v85);
        capture_error( a4,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive.c",  1043,  (uint64_t)"decompress_data",  "Could not allocate zlib stream: %s",  v87,  v88,  v89,  v86);
        return -1LL;
      }

      int v32 = inflateInit2_(v31, -15, "1.2.12", 112);
      if (v32)
      {
        capture_error( a4,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive.c",  1050,  (uint64_t)"decompress_data",  "Could not inflateInit2: %d",  a6,  a7,  a8,  v32);
        return -1LL;
      }

LABEL_40:
      size_t v24 = *(void *)(a1 + 112);
      if (v24)
      {
        uint64_t v25 = *(char **)(a1 + 104);
      }

      else
      {
        size_t v55 = *(void *)(a1 + 88);
        size_t v56 = data_archive_decoder_read_data(*(void *)(a1 + 40), *(void **)(a1 + 96), v55, 0LL, a5, a6, a7, a8);
        if (!v56)
        {
          uint64_t v13 = "decompress_streamed_data";
          uint64_t v14 = "End of decoder";
          uint64_t v15 = a4;
          int v16 = 1427;
          goto LABEL_9;
        }

        size_t v24 = v56;
        if (v56 == -1LL && *__error() != 35)
        {
          capture_error( a4,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive.c",  1420,  (uint64_t)"decompress_streamed_data",  "Could not read %ld bytes from decoder",  v57,  v58,  v59,  v55);
          return -1LL;
        }

        uint64_t v25 = *(char **)(a1 + 96);
        *(void *)(a1 + 104) = v25;
        *(void *)(a1 + 112) = v24;
      }

      char v60 = 0;
      uint64_t v61 = 0LL;
      uint64_t v62 = *(z_stream **)(a1 + 120);
      do
      {
        v62->next_in = (Bytef *)&v25[v61];
        v62->avail_in = v24 - v61;
        v62->next_out = (Bytef *)a2;
        v62->uInt avail_out = a3;
        int v63 = inflate(v62, 0);
        if (v63)
        {
          if (v63 != 1)
          {
            capture_error( a4,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive.c",  1476,  (uint64_t)"decompress_streamed_data",  "Could not inflate: %d",  v65,  v66,  v67,  v63);
            return -1LL;
          }

          char v60 = 1;
          *(_BYTE *)(a1 + 80) = 1;
        }

        uint64_t v68 = *(void *)(a1 + 112);
        uint64_t v62 = *(z_stream **)(a1 + 120);
        size_t v69 = v24 - v61 - v62->avail_in;
        uint64_t v25 = (char *)(*(void *)(a1 + 104) + v69);
        *(void *)(a1 + 104) = v25;
        *(void *)(a1 + 112) = v68 - v69;
        int64_t v17 = a3 - v62->avail_out;
        if ((v60 & 1) != 0) {
          break;
        }
        v61 += v69;
      }

      while (!v17 && v24 != v61);
      if ((v60 & 1) == 0) {
        return v17;
      }
      if (v68 != v69)
      {
        int v71 = data_archive_decoder_rewind_data(*(void *)(a1 + 40), v25, v68 - v69, 0LL, v64, v65, v66, v67);
        if (v71)
        {
          capture_error( a4,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive.c",  1505,  (uint64_t)"decompress_streamed_data",  "Could not rewind remaining data: %d",  v72,  v73,  v74,  v71);
          return -1LL;
        }

        *(void *)(a1 + 104) = *(void *)(a1 + 96);
        *(void *)(a1 + 112) = 0LL;
        uint64_t v62 = *(z_stream **)(a1 + 120);
      }

      int v99 = inflateEnd(v62);
      if (v99)
      {
        capture_error( a4,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive.c",  1520,  (uint64_t)"decompress_streamed_data",  "Could not inflateEnd: %d",  v100,  v101,  v102,  v99);
        return -1LL;
      }

  if (!*(_BYTE *)(a2 + 152)) {
    return 0LL;
  }
  uint64_t v29 = *(const char **)(a2 + 144);
  uint64_t v30 = *(const char **)(a2 + 120);
  int v31 = *(os_log_s **)a1;
  if (*(void *)a1)
  {
    if (!os_log_type_enabled(*(os_log_t *)a1, OS_LOG_TYPE_DEFAULT)
      || (*(_DWORD *)buf = 136315138,
          uint64_t v45 = (void *)v29,
          _os_log_impl(&dword_1862F3000, v31, OS_LOG_TYPE_DEFAULT, "rename old: %s", buf, 0xCu),
          (int v31 = *(os_log_s **)a1) != 0LL))
    {
      if (os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136315138;
        uint64_t v45 = (void *)v30;
        _os_log_impl(&dword_1862F3000, v31, OS_LOG_TYPE_DEFAULT, "rename new: %s", buf, 0xCu);
      }
    }
  }

  uint64_t result = rename(v29, v30);
  if ((_DWORD)result)
  {
    uint64_t v33 = *__error();
    int v34 = __error();
    strerror(*v34);
    BOMCopierErrorCapture( a3,  v33,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  6607,  (uint64_t)"apply_retention_policy",  "Could not rename staged %s to %s: %s",  v29);
    return 1LL;
  }

  return result;
}

        BOMStackPoke(v23, v24);
        if (v11) {
          goto LABEL_67;
        }
        continue;
      case 3u:
        goto LABEL_37;
      default:
        goto LABEL_61;
    }
  }

LABEL_107:
      platform_free(*(void *)(a1 + 8), *(void **)(a1 + 120));
      *(void *)(a1 + 120) = 0LL;
      return v17;
    case 7:
      if (!*(_BYTE *)(a1 + 168) && init_pkzip_cipher(a1, a4, a3, (uint64_t)a4, a5, a6, a7, a8))
      {
        uint64_t v13 = "decrypt_streamed_data";
        uint64_t v14 = "Could not initialize the PKZip cipher";
        uint64_t v15 = a4;
        int v16 = 1548;
        goto LABEL_9;
      }

      uint64_t streamed_data = read_streamed_data(a1, (char *)a2, a3, a4, a5, a6, a7, a8);
      if (streamed_data < 0)
      {
        uint64_t v13 = "decrypt_streamed_data";
        uint64_t v14 = "Could not read encrypted data";
        uint64_t v15 = a4;
        int v16 = 1561;
        goto LABEL_9;
      }

      int64_t v17 = streamed_data;
      if (streamed_data) {
        pkzip_crypto_decrypt_buffer((int *)(a1 + 172), (unsigned __int8 *)a2, streamed_data);
      }
      else {
LABEL_33:
      }
        *(_BYTE *)(a1 + 168) = 0;
      break;
    default:
      return -1LL;
  }

  return v17;
}

size_t read_data_direct( uint64_t *a1, void *a2, size_t a3, void *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1[8] - a1[9] >= a3) {
    size_t v10 = a3;
  }
  else {
    size_t v10 = a1[8] - a1[9];
  }
  size_t data = data_archive_decoder_read_data(a1[5], a2, v10, 0LL, a5, a6, a7, a8);
  size_t v15 = data;
  if (data == -1LL) {
    capture_error( a4,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive.c",  983,  (uint64_t)"read_data_direct",  "Could not read %ld from data decoder",  v12,  v13,  v14,  v10);
  }
  else {
    a1[9] += data;
  }
  return v15;
}

uint64_t read_streamed_data( uint64_t a1, char *a2, size_t a3, void *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(_BYTE *)(a1 + 80)) {
    return 0LL;
  }
  char v10 = a3;
  size_t data = data_archive_decoder_read_data(*(void *)(a1 + 40), a2, a3, a4, a5, a6, a7, a8);
  if (!data)
  {
    int v22 = "End of decoder";
    char v23 = a4;
    int v24 = 1276;
LABEL_18:
    capture_error( v23,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive.c",  v24,  (uint64_t)"read_streamed_data",  v22,  v14,  v15,  v16,  v34);
    return -1LL;
  }

  unint64_t v8 = data;
  if (data == -1LL && *__error() != 35)
  {
    capture_error( a4,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive.c",  1269,  (uint64_t)"read_streamed_data",  "Could not read %ld bytes from decoder",  v17,  v18,  v19,  v10);
    return -1LL;
  }

  byte_stream_new(*(void *)(a1 + 8), 0LL);
  if (!v20)
  {
    int v22 = "Could not create byte stream";
    char v23 = a4;
    int v24 = 1292;
    goto LABEL_18;
  }

  int v21 = v20;
  if (v8 < 5)
  {
    byte_stream_free(v20);
    return v8;
  }

  uint64_t v25 = 0LL;
  unint64_t v26 = v8;
  do
  {
    byte_stream_attach((uint64_t)v21, (uint64_t)&a2[v25], v26);
    int uint32 = byte_stream_read_uint32((uint64_t)v21);
    v26 -= uint32 != 134695760;
    ++v25;
  }

  while (v26 > 4);
  byte_stream_free(v21);
  if (uint32 == 134695760)
  {
    *(_BYTE *)(a1 + 80) = 1;
    int v32 = data_archive_decoder_rewind_data(*(void *)(a1 + 40), &a2[v25], v26, a4, v28, v29, v30, v31);
    if (!v32)
    {
      v8 -= v26;
      return v8;
    }

    int v22 = "Could not rewind remaining data: %d";
    char v34 = v32;
    char v23 = a4;
    int v24 = 1334;
    goto LABEL_18;
  }

  return v8;
}

uint64_t init_pkzip_cipher( uint64_t a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v29 = *MEMORY[0x1895F89C0];
  *(_DWORD *)(a1 + 172) = 0;
  *(_DWORD *)(a1 + 176) = 0;
  int v9 = (int *)(a1 + 172);
  *(_DWORD *)(a1 + 180) = 0;
  char v10 = *(uint64_t (**)(uint64_t, void, void *))(a1 + 128);
  if (v10)
  {
    uint64_t v12 = (char *)v10(a1, *(void *)(a1 + 136), a2);
    if (v12)
    {
      pkzip_crypto_init(v9, v12);
      uint64_t v14 = 0LL;
      uint64_t v15 = __dst;
      do
      {
        int64_t data = data_archive_decoder_read_data(*(void *)(a1 + 40), v15, 12 - v14, a2, v13, a6, a7, a8);
        if (data <= 0)
        {
          int v22 = __error();
          char v23 = strerror(*v22);
          capture_error( a2,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive.c",  1626,  (uint64_t)"init_pkzip_cipher",  "Could not read initial ciphertext: %s",  v24,  v25,  v26,  v23);
          return 0xFFFFFFFFLL;
        }

        int64_t v17 = data;
        pkzip_crypto_decrypt_buffer(v9, v15, data);
        v15 += v17;
        v14 += v17;
      }

      while (v14 != 12);
      if (*(unsigned __int8 *)(a1 + 151) == __dst[11])
      {
        uint64_t result = 0LL;
        *(_BYTE *)(a1 + 168) = 1;
        return result;
      }

      uint64_t v19 = "Decryption passphrase appears to be incorrect";
      int v20 = a2;
      int v21 = 1641;
    }

    else
    {
      uint64_t v19 = "Client did not provide passphrase";
      int v20 = a2;
      int v21 = 1606;
    }
  }

  else
  {
    uint64_t v19 = "No passphrase callback";
    int v20 = a2;
    int v21 = 1596;
  }

  capture_error( v20,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive.c",  v21,  (uint64_t)"init_pkzip_cipher",  v19,  a6,  a7,  a8,  v27);
  return 0xFFFFFFFFLL;
}

uint64_t BOMCopierSourceNew(char *a1, const __CFDictionary *a2, uint64_t a3, void *a4)
{
  v180[2] = *(char **)MEMORY[0x1895F89C0];
  if (!((unint64_t)a1 | (unint64_t)a2))
  {
    BOMCopierErrorCapture( a4,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c",  577,  (uint64_t)"BOMCopierSourceNew",  "path and options are NULL");
    return 0LL;
  }

  unint64_t v8 = calloc(1uLL, 0x180uLL);
  uint64_t v9 = (uint64_t)v8;
  if (!v8)
  {
    v110 = __error();
    BOMCopierErrorCapture( a4,  *v110,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c",  590,  (uint64_t)"BOMCopierSourceNew",  "Could not allocate empty BOMCopierSource");
    return v9;
  }

  v8[3] = a3;
  *((_DWORD *)v8 + 8) = geteuid();
  gid_t v10 = getegid();
  *(_DWORD *)(v9 + 36) = v10;
  *(_DWORD *)(v9 + 40) = -1;
  *(_DWORD *)(v9 + 100) = 0;
  *(_BYTE *)(v9 + 64) = 1;
  *(void *)(v9 + 232) = 0x4000000LL;
  *(_BYTE *)(v9 + 160) = 1;
  int v11 = *(os_log_s **)(v9 + 24);
  if (v11)
  {
    gid_t v12 = v10;
    if (os_log_type_enabled(*(os_log_t *)(v9 + 24), OS_LOG_TYPE_DEFAULT))
    {
      int32_t v13 = *(_DWORD *)(v9 + 32);
      buf.f_bsize = 67109376;
      buf.f_iosize = v13;
      LOWORD(buf.f_blocks) = 1024;
      *(_DWORD *)((char *)&buf.f_blocks + 2) = v12;
      _os_log_impl(&dword_1862F3000, v11, OS_LOG_TYPE_DEFAULT, "euid: %u egid: %u", (uint8_t *)&buf, 0xEu);
    }
  }

  if (a2)
  {
    CFTypeID TypeID = CFBooleanGetTypeID();
    unint64_t Value = CFDictionaryGetValue(a2, @"useFilesystemCache");
    if (Value)
    {
      uint64_t v16 = Value;
      if (TypeID != CFGetTypeID(Value))
      {
        BOMCopierErrorCapture( a4,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c",  1536,  (uint64_t)"parse_copier_source_options",  "kBOMCopierSourceOptionUseFilesystemCacheKey must be a CFBooleanRef");
        goto LABEL_313;
      }

      *(_BYTE *)(v9 + 64) = CFEqual(v16, (CFTypeRef)*MEMORY[0x189604DE8]) != 0;
    }

    int64_t v17 = CFDictionaryGetValue(a2, @"useEnumerationBom");
    if (v17)
    {
      uint64_t v18 = v17;
      if (TypeID != CFGetTypeID(v17))
      {
        BOMCopierErrorCapture( a4,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c",  1548,  (uint64_t)"parse_copier_source_options",  "kBOMCopierSourceOptionUseEnumerationBomKey must be a CFBooleanRef");
        goto LABEL_313;
      }

      *(_BYTE *)(v9 + 65) = CFEqual(v18, (CFTypeRef)*MEMORY[0x189604DE8]) != 0;
    }

    uint64_t v19 = CFDictionaryGetValue(a2, @"applyBomOwnership");
    if (v19)
    {
      int v20 = v19;
      if (TypeID != CFGetTypeID(v19))
      {
        BOMCopierErrorCapture( a4,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c",  1560,  (uint64_t)"parse_copier_source_options",  "kBOMCopierSourceOptionApplyBomOwnershipKey must be a CFBooleanRef");
        goto LABEL_313;
      }

      *(_BYTE *)(v9 + 208) = CFEqual(v20, (CFTypeRef)*MEMORY[0x189604DE8]) != 0;
    }

    int v21 = CFDictionaryGetValue(a2, @"allowAccessFailures");
    if (v21)
    {
      int v22 = v21;
      if (TypeID != CFGetTypeID(v21))
      {
        BOMCopierErrorCapture( a4,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c",  1572,  (uint64_t)"parse_copier_source_options",  "kBOMCopierSourceAllowAccessFailuresKey must be a CFBooleanRef");
        goto LABEL_313;
      }

      if (CFEqual((CFTypeRef)*MEMORY[0x189604DE8], v22) == 1) {
        *(_BYTE *)(v9 + 209) = 1;
      }
    }

    char v23 = CFDictionaryGetValue(a2, @"crossDevices");
    if (v23)
    {
      uint64_t v24 = v23;
      if (TypeID != CFGetTypeID(v23))
      {
        BOMCopierErrorCapture( a4,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c",  1587,  (uint64_t)"parse_copier_source_options",  "kBOMCopierSourceOptionCrossDevicesKey must be a CFBooleanRef");
        goto LABEL_313;
      }

      *(_BYTE *)(v9 + 160) = CFEqual((CFTypeRef)*MEMORY[0x189604DE8], v24) != 0;
    }

    uint64_t v25 = CFDictionaryGetValue(a2, @"extractLibarchive");
    if (v25)
    {
      uint64_t v26 = v25;
      if (TypeID != CFGetTypeID(v25))
      {
        BOMCopierErrorCapture( a4,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c",  1599,  (uint64_t)"parse_copier_source_options",  "kBOMCopierSourceOptionExtractLibarchiveKey must be a CFBooleanRef");
        goto LABEL_313;
      }

      if (CFEqual((CFTypeRef)*MEMORY[0x189604DE8], v26) == 1) {
        *(_DWORD *)(v9 + 100) = 2;
      }
    }

    char v27 = CFDictionaryGetValue(a2, @"extractDataArchive");
    if (!v27)
    {
LABEL_33:
      uint64_t v29 = CFDictionaryGetValue(a2, @"enforceArchiveEntryPermissions");
      if (v29)
      {
        uint64_t v30 = v29;
        if (TypeID != CFGetTypeID(v29))
        {
          BOMCopierErrorCapture( a4,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c",  1629,  (uint64_t)"parse_copier_source_options",  "kBOMCopierSourceOptionEnforceArchiveEntryPermissionsKey must be a CFBooleanRef");
          goto LABEL_313;
        }

        *(_BYTE *)(v9 + 264) = CFEqual((CFTypeRef)*MEMORY[0x189604DE8], v30) != 0;
      }

      uint64_t v31 = CFDictionaryGetValue(a2, @"extractAppleArchive");
      if (v31)
      {
        int v32 = v31;
        if (TypeID != CFGetTypeID(v31))
        {
          BOMCopierErrorCapture( a4,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c",  1641,  (uint64_t)"parse_copier_source_options",  "kBOMCopierSourceOptionExtractAppleArchiveKey must be a CFBooleanRef");
          goto LABEL_313;
        }

        if (CFEqual((CFTypeRef)*MEMORY[0x189604DE8], v32) == 1) {
          *(_DWORD *)(v9 + 100) = 4;
        }
      }

      CFTypeID v33 = CFNumberGetTypeID();
      char v34 = (const __CFNumber *)CFDictionaryGetValue(a2, @"inputFD");
      if (v34)
      {
        size_t v35 = v34;
        if (v33 != CFGetTypeID(v34))
        {
          BOMCopierErrorCapture( a4,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c",  1658,  (uint64_t)"parse_copier_source_options",  "kBOMCopierSourceOptionExtractAppleArchiveKey must be a CFNumberRef");
          goto LABEL_313;
        }

        buf.f_bsize = -1;
        if (!CFNumberGetValue(v35, kCFNumberSInt32Type, &buf))
        {
          BOMCopierErrorCapture( a4,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c",  1666,  (uint64_t)"parse_copier_source_options",  "Could not convert the input file descriptor number to kCFNumberSInt32Type");
          goto LABEL_313;
        }

        *(_DWORD *)(v9 + 40) = buf.f_bsize;
      }

      CFTypeID v36 = CFReadStreamGetTypeID();
      uint64_t v37 = (__CFReadStream *)CFDictionaryGetValue(a2, @"inputStream");
      if (v37)
      {
        uint64_t v38 = v37;
        if (v36 != CFGetTypeID(v37))
        {
          BOMCopierErrorCapture( a4,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c",  1680,  (uint64_t)"parse_copier_source_options",  "kBOMCopierSourceOptionExtractAppleArchiveKey must be a CFReadStreamRef");
          goto LABEL_313;
        }

        if (CFReadStreamGetStatus(v38) != kCFStreamStatusOpen)
        {
          BOMCopierErrorCapture( a4,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c",  1687,  (uint64_t)"parse_copier_source_options",  "CFReadStream is not open");
          goto LABEL_313;
        }

        *(void *)(v9 + 48) = v38;
      }

      uint64_t v39 = CFDictionaryGetValue(a2, @"synthesizeResourceForks");
      if (v39)
      {
        char v40 = v39;
        if (TypeID != CFGetTypeID(v39))
        {
          BOMCopierErrorCapture( a4,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c",  1699,  (uint64_t)"parse_copier_source_options",  "kBOMCopierSourceOptionSynthesizeResourceForksKey must be a CFBooleanRef");
          goto LABEL_313;
        }

        *(_BYTE *)(v9 + 66) = CFEqual((CFTypeRef)*MEMORY[0x189604DE8], v40) != 0;
      }

      uint64_t v41 = CFDictionaryGetValue(a2, @"synthesizeAppleDoubles");
      if (v41)
      {
        uint64_t v42 = v41;
        if (TypeID != CFGetTypeID(v41))
        {
          BOMCopierErrorCapture( a4,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c",  1711,  (uint64_t)"parse_copier_source_options",  "kBOMCopierSourceOptionExtractAppleArchiveKey must be a CFBooleanRef");
          goto LABEL_313;
        }

        *(_BYTE *)(v9 + 67) = CFEqual((CFTypeRef)*MEMORY[0x189604DE8], v42) != 0;
      }

      int v43 = CFDictionaryGetValue(a2, @"appleDoublesCaptureResourceAttributes");
      if (v43)
      {
        uint64_t v44 = v43;
        if (TypeID != CFGetTypeID(v43))
        {
          BOMCopierErrorCapture( a4,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c",  1725,  (uint64_t)"parse_copier_source_options",  "kBOMCopierSourceOptionAppleDoubleCaptureResourceAttributesKey must be a CFBooleanRef");
          goto LABEL_313;
        }

        *(_BYTE *)(v9 + 68) = CFEqual((CFTypeRef)*MEMORY[0x189604DE8], v44) != 0;
      }

      uint64_t v45 = CFDictionaryGetValue(a2, @"appleDoublesCaptureExtendedAttributes");
      if (v45)
      {
        uint64_t v46 = v45;
        if (TypeID != CFGetTypeID(v45))
        {
          BOMCopierErrorCapture( a4,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c",  1737,  (uint64_t)"parse_copier_source_options",  "kBOMCopierSourceOptionAppleDoubleCaptureExtendedAttributesKey must be a CFBooleanRef");
          goto LABEL_313;
        }

        *(_BYTE *)(v9 + 69) = CFEqual((CFTypeRef)*MEMORY[0x189604DE8], v46) != 0;
      }

      uint64_t v47 = CFDictionaryGetValue(a2, @"appleDoublesCaptureACLs");
      if (v47)
      {
        uint64_t v48 = v47;
        if (TypeID != CFGetTypeID(v47))
        {
          BOMCopierErrorCapture( a4,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c",  1749,  (uint64_t)"parse_copier_source_options",  "kBOMCopierSourceOptionAppleDoubleCaptureACLsKey must be a CFBooleanRef");
          goto LABEL_313;
        }

        *(_BYTE *)(v9 + 70) = CFEqual((CFTypeRef)*MEMORY[0x189604DE8], v48) != 0;
      }

      size_t v49 = CFDictionaryGetValue(a2, @"deferAppleDoubles");
      if (v49)
      {
        uint64_t v50 = v49;
        if (TypeID != CFGetTypeID(v49))
        {
          BOMCopierErrorCapture( a4,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c",  1761,  (uint64_t)"parse_copier_source_options",  "kBOMCopierSourceOptionDeferAppleDoublesKey must be a CFBooleanRef");
          goto LABEL_313;
        }

        *(_BYTE *)(v9 + 71) = CFEqual((CFTypeRef)*MEMORY[0x189604DE8], v50) != 0;
      }

      int v51 = CFDictionaryGetValue(a2, @"replayAppleDoubles");
      if (v51)
      {
        uint64_t v52 = v51;
        if (TypeID != CFGetTypeID(v51))
        {
          BOMCopierErrorCapture( a4,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c",  1773,  (uint64_t)"parse_copier_source_options",  "kBOMCopierSourceOptionReplayAppleDoublesKey must be a CFBooleanRef");
          goto LABEL_313;
        }

        *(_BYTE *)(v9 + 72) = CFEqual((CFTypeRef)*MEMORY[0x189604DE8], v52) != 0;
      }

      uint64_t v53 = CFDictionaryGetValue(a2, @"replaySymlinks");
      if (v53)
      {
        uint64_t v54 = v53;
        if (TypeID != CFGetTypeID(v53))
        {
          BOMCopierErrorCapture( a4,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c",  1785,  (uint64_t)"parse_copier_source_options",  "kBOMCopierSourceOptionReplaySymlinksKey must be a CFBooleanRef");
          goto LABEL_313;
        }

        *(_BYTE *)(v9 + 91) = CFEqual((CFTypeRef)*MEMORY[0x189604DE8], v54) != 0;
      }

      size_t v55 = CFDictionaryGetValue(a2, @"replayDirectories");
      if (v55)
      {
        size_t v56 = v55;
        if (TypeID != CFGetTypeID(v55))
        {
          BOMCopierErrorCapture( a4,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c",  1797,  (uint64_t)"parse_copier_source_options",  "kBOMCopierSourceOptionReplayDirectoriesKey must be a CFBooleanRef");
          goto LABEL_313;
        }

        *(_BYTE *)(v9 + 92) = CFEqual((CFTypeRef)*MEMORY[0x189604DE8], v56) != 0;
      }

      uint64_t v57 = CFDictionaryGetValue(a2, @"excludeRootDirectory");
      if (v57)
      {
        uint64_t v58 = v57;
        if (TypeID != CFGetTypeID(v57))
        {
          BOMCopierErrorCapture( a4,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c",  1809,  (uint64_t)"parse_copier_source_options",  "kBOMCopierSourceOptionExcludeRootDirectoryKey must be a CFBooleanRef");
          goto LABEL_313;
        }

        *(_BYTE *)(v9 + 93) = CFEqual((CFTypeRef)*MEMORY[0x189604DE8], v58) != 0;
      }

      uint64_t v59 = CFDictionaryGetValue(a2, @"skipRootDirectory");
      if (v59)
      {
        char v60 = v59;
        if (TypeID != CFGetTypeID(v59))
        {
          BOMCopierErrorCapture( a4,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c",  1821,  (uint64_t)"parse_copier_source_options",  "kBOMCopierSourceOptionSkipRootDirectoryKey must be a CFBooleanRef");
          goto LABEL_313;
        }

        *(_BYTE *)(v9 + 94) = CFEqual((CFTypeRef)*MEMORY[0x189604DE8], v60) != 0;
      }

      uint64_t v61 = CFDictionaryGetValue(a2, @"sequesterAppleDoubles");
      if (v61)
      {
        uint64_t v62 = v61;
        if (TypeID != CFGetTypeID(v61))
        {
          BOMCopierErrorCapture( a4,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c",  1833,  (uint64_t)"parse_copier_source_options",  "kBOMCopierSourceOptionSequesterAppleDoublesKey must be a CFBooleanRef");
          goto LABEL_313;
        }

        *(_BYTE *)(v9 + 95) = CFEqual((CFTypeRef)*MEMORY[0x189604DE8], v62) != 0;
      }

      int v63 = CFDictionaryGetValue(a2, @"unsequesterAppleDoubles");
      if (v63)
      {
        uint64_t v64 = v63;
        if (TypeID != CFGetTypeID(v63))
        {
          BOMCopierErrorCapture( a4,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c",  1845,  (uint64_t)"parse_copier_source_options",  "kBOMCopierSourceOptionUnsequesterAppleDoublesKey must be a CFBooleanRef");
          goto LABEL_313;
        }

        *(_BYTE *)(v9 + 96) = CFEqual((CFTypeRef)*MEMORY[0x189604DE8], v64) != 0;
      }

      uint64_t v65 = (const __CFNumber *)CFDictionaryGetValue(a2, @"libarchiveReadBlockSize");
      if (v65)
      {
        uint64_t v66 = v65;
        if (v33 != CFGetTypeID(v65))
        {
          BOMCopierErrorCapture( a4,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c",  1857,  (uint64_t)"parse_copier_source_options",  "kBOMCopierSourceOptionLibarchiveReadBlockSize must be a CFNumberRef");
          goto LABEL_313;
        }

        *(void *)&buf.f_bsize = 0LL;
        if (!CFNumberGetValue(v66, kCFNumberSInt64Type, &buf))
        {
          BOMCopierErrorCapture( a4,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c",  1865,  (uint64_t)"parse_copier_source_options",  "Could not convert the read block size number to kCFNumberSInt64Type");
          goto LABEL_313;
        }

        *(void *)(v9 + 232) = *(void *)&buf.f_bsize;
      }

      uint64_t v67 = CFDictionaryGetValue(a2, @"discoverBinaries");
      if (v67)
      {
        uint64_t v68 = v67;
        if (TypeID != CFGetTypeID(v67))
        {
          BOMCopierErrorCapture( a4,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c",  1877,  (uint64_t)"parse_copier_source_options",  "kBOMCopierSourceOptionDiscoverBinaries must be a CFBooleanRef");
          goto LABEL_313;
        }

        *(_BYTE *)(v9 + 360) = CFEqual((CFTypeRef)*MEMORY[0x189604DE8], v68) != 0;
      }

      size_t v69 = CFDictionaryGetValue(a2, @"discoverResourceAttribute");
      if (v69)
      {
        uint64_t v70 = v69;
        if (TypeID != CFGetTypeID(v69))
        {
          BOMCopierErrorCapture( a4,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c",  1889,  (uint64_t)"parse_copier_source_options",  "kBOMCopierSourceOptionDiscoverResourceAttribute must be a CFBooleanRef");
          goto LABEL_313;
        }

        *(_BYTE *)(v9 + 361) = CFEqual((CFTypeRef)*MEMORY[0x189604DE8], v70) != 0;
      }

      int v71 = CFDictionaryGetValue(a2, @"discoverExtendedAttributes");
      if (v71)
      {
        uint64_t v72 = v71;
        if (TypeID != CFGetTypeID(v71))
        {
          BOMCopierErrorCapture( a4,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c",  1901,  (uint64_t)"parse_copier_source_options",  "kBOMCopierSourceOptionDiscoverExtendedAttributes must be a CFBooleanRef");
          goto LABEL_313;
        }

        *(_BYTE *)(v9 + 362) = CFEqual((CFTypeRef)*MEMORY[0x189604DE8], v72) != 0;
      }

      uint64_t v73 = CFDictionaryGetValue(a2, @"discoverCompressionAttributes");
      if (v73)
      {
        uint64_t v74 = v73;
        if (TypeID != CFGetTypeID(v73))
        {
          BOMCopierErrorCapture( a4,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c",  1913,  (uint64_t)"parse_copier_source_options",  "kBOMCopierSourceOptionDiscoverCompressionAttributes must be a CFBooleanRef");
          goto LABEL_313;
        }

        *(_BYTE *)(v9 + 363) = CFEqual((CFTypeRef)*MEMORY[0x189604DE8], v74) != 0;
      }

      uint64_t v75 = CFDictionaryGetValue(a2, @"discoverACLs");
      if (v75)
      {
        int v76 = v75;
        if (TypeID != CFGetTypeID(v75))
        {
          BOMCopierErrorCapture( a4,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c",  1925,  (uint64_t)"parse_copier_source_options",  "kBOMCopierSourceOptionDiscoverACLs must be a CFBooleanRef");
          goto LABEL_313;
        }

        *(_BYTE *)(v9 + 364) = CFEqual((CFTypeRef)*MEMORY[0x189604DE8], v76) != 0;
      }

      uint64_t v77 = CFDictionaryGetValue(a2, @"discoverQuarantine");
      if (v77)
      {
        uint64_t v78 = v77;
        if (TypeID != CFGetTypeID(v77))
        {
          BOMCopierErrorCapture( a4,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c",  1937,  (uint64_t)"parse_copier_source_options",  "kBOMCopierSourceOptionDiscoverQuarantine must be a CFBooleanRef");
          goto LABEL_313;
        }

        *(_BYTE *)(v9 + 365) = CFEqual((CFTypeRef)*MEMORY[0x189604DE8], v78) != 0;
      }

      CFTypeID v79 = CFStringGetTypeID();
      uint64_t v80 = (const __CFString *)CFDictionaryGetValue(a2, @"replayQuarantineFromPath");
      if (v80)
      {
        int v81 = v80;
        if (v79 != CFGetTypeID(v80))
        {
          BOMCopierErrorCapture( a4,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c",  1951,  (uint64_t)"parse_copier_source_options",  "kBOMCopierSourceOptionReplayQuarantineFromPath must be a CFBooleanRef");
          goto LABEL_313;
        }

        CFIndex v82 = CFStringGetLength(v81) + 1;
        uint64_t v83 = (char *)calloc(1uLL, v82);
        *(void *)(v9 + 368) = v83;
        if (!v83)
        {
          BOMCopierErrorCapture( a4,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c",  1963,  (uint64_t)"parse_copier_source_options",  "Could not allocate %ld bytes for path_size");
          goto LABEL_313;
        }

        if (!CFStringGetCString(v81, v83, v82, 0x8000100u))
        {
          BOMCopierErrorCapture( a4,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c",  1970,  (uint64_t)"parse_copier_source_options",  "Could not convert quarantine source path string to C string");
          goto LABEL_313;
        }
      }

      uint64_t v84 = CFDictionaryGetValue(a2, @"keepParent");
      if (v84)
      {
        __int16 v85 = v84;
        if (TypeID != CFGetTypeID(v84))
        {
          BOMCopierErrorCapture( a4,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c",  1980,  (uint64_t)"parse_copier_source_options",  "kBOMCopierSourceOptionKeepParent must be a CFBooleanRef");
          goto LABEL_313;
        }

        *(_BYTE *)(v9 + 376) = CFEqual((CFTypeRef)*MEMORY[0x189604DE8], v85) != 0;
      }

      char v86 = (const __CFString *)CFDictionaryGetValue(a2, @"passphrase");
      if (v86)
      {
        uint64_t v87 = v86;
        if (v79 != CFGetTypeID(v86))
        {
          BOMCopierErrorCapture( a4,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c",  1992,  (uint64_t)"parse_copier_source_options",  "kBOMCopierSourceOptionPassphraseKey must be a CFStringRef");
          goto LABEL_313;
        }

        CFIndex v88 = CFStringGetLength(v87) + 1;
        uint64_t v89 = (char *)calloc(1uLL, v88);
        *(void *)(v9 + 240) = v89;
        if (!v89)
        {
          BOMCopierErrorCapture( a4,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c",  2002,  (uint64_t)"parse_copier_source_options",  "Could not allocate %ld bytes for passphrase_size");
          goto LABEL_313;
        }

        if (!CFStringGetCString(v87, v89, v88, 0x8000100u))
        {
          BOMCopierErrorCapture( a4,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c",  2009,  (uint64_t)"parse_copier_source_options",  "Could not convert passphrase string to C string");
          goto LABEL_313;
        }
      }

      uint64_t v90 = CFDictionaryGetValue(a2, @"discoverSegmentedFiles");
      if (v90)
      {
        char v91 = v90;
        if (TypeID != CFGetTypeID(v90))
        {
          BOMCopierErrorCapture( a4,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c",  2019,  (uint64_t)"parse_copier_source_options",  "kBOMCopierSourceOptionDiscoverSegmentedFilesKey must be a CFBooleanRef");
          goto LABEL_313;
        }

        *(_BYTE *)(v9 + 265) = CFEqual((CFTypeRef)*MEMORY[0x189604DE8], v91) != 0;
      }

      uint64_t v92 = CFDictionaryGetValue(a2, @"ignoreAppleDoubles");
      if (v92)
      {
        uint64_t v93 = v92;
        if (TypeID != CFGetTypeID(v92))
        {
          BOMCopierErrorCapture( a4,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c",  2031,  (uint64_t)"parse_copier_source_options",  "kBOMCopierSourceOptionIgnoreAppleDoubles must be a CFBooleanRef");
          goto LABEL_313;
        }

        *(_BYTE *)(v9 + 88) = CFEqual((CFTypeRef)*MEMORY[0x189604DE8], v93) != 0;
      }

      uint64_t v94 = (const __CFString *)CFDictionaryGetValue(a2, @"appleDoubleSuffix");
      if (v94)
      {
        int v95 = v94;
        if (v79 != CFGetTypeID(v94))
        {
          BOMCopierErrorCapture( a4,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c",  2043,  (uint64_t)"parse_copier_source_options",  "kBOMCopierSourceOptionAppleDoubleSuffix must be a CFStringRef");
          goto LABEL_313;
        }

        CFIndex v96 = CFStringGetLength(v95) + 1;
        uint64_t v97 = (char *)calloc(1uLL, v96);
        *(void *)(v9 + 80) = v97;
        if (!v97)
        {
          BOMCopierErrorCapture( a4,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c",  2053,  (uint64_t)"parse_copier_source_options",  "Could not allocate %ld bytes for suffix_size");
          goto LABEL_313;
        }

        if (!CFStringGetCString(v95, v97, v96, 0x8000100u))
        {
          BOMCopierErrorCapture( a4,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c",  2060,  (uint64_t)"parse_copier_source_options",  "Could not convert AppleDouble suffix string to C string");
          goto LABEL_313;
        }
      }

      uint64_t v98 = CFDictionaryGetValue(a2, @"reorderExtraEntries");
      if (v98)
      {
        int v99 = v98;
        if (TypeID != CFGetTypeID(v98))
        {
          BOMCopierErrorCapture( a4,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c",  2070,  (uint64_t)"parse_copier_source_options",  "kBOMCopierSourceOptionReorderExtraEntriesKey must be a CFBooleanRef");
          goto LABEL_313;
        }

        *(_BYTE *)(v9 + 89) = CFEqual((CFTypeRef)*MEMORY[0x189604DE8], v99) != 0;
      }

      uint64_t v100 = CFDictionaryGetValue(a2, @"replayExtraAppleDoubles");
      if (v100)
      {
        uint64_t v101 = v100;
        if (TypeID != CFGetTypeID(v100))
        {
          BOMCopierErrorCapture( a4,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c",  2082,  (uint64_t)"parse_copier_source_options",  "kBOMCopierSourceOptionReplayExtraAppleDoubleEntriesKey must be a CFBooleanRef");
          goto LABEL_313;
        }

        *(_BYTE *)(v9 + 90) = CFEqual((CFTypeRef)*MEMORY[0x189604DE8], v101) != 0;
      }

      uint64_t v102 = CFDictionaryGetValue(a2, @"disableLexicographicSort");
      if (v102)
      {
        char v103 = v102;
        if (TypeID != CFGetTypeID(v102))
        {
          BOMCopierErrorCapture( a4,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c",  2094,  (uint64_t)"parse_copier_source_options",  "kBOMCopierSourceOptionDisableLexicographicSortKey must be a CFBooleanRef");
          goto LABEL_313;
        }

        *(_BYTE *)(v9 + 97) = CFEqual((CFTypeRef)*MEMORY[0x189604DE8], v103) != 0;
      }

      goto LABEL_139;
    }

    uint64_t v28 = v27;
    if (TypeID == CFGetTypeID(v27))
    {
      if (CFEqual((CFTypeRef)*MEMORY[0x189604DE8], v28) == 1) {
        *(_DWORD *)(v9 + 100) = 3;
      }
      goto LABEL_33;
    }

    BOMCopierErrorCapture( a4,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c",  1614,  (uint64_t)"parse_copier_source_options",  "kBOMCopierSourceOptionExtractDataArchiveKey must be a CFBooleanRef");
LABEL_313:
    BOMCopierSourceFree((void *)v9);
    return 0LL;
  }

LABEL_139:
  int v104 = *(_DWORD *)(v9 + 100);
  if ((v104 - 2) >= 3 && *(_BYTE *)(v9 + 65))
  {
    *(_DWORD *)(v9 + 100) = 1;
    __int128 v105 = *(os_log_s **)(v9 + 24);
    if (!v105 || !os_log_type_enabled(*(os_log_t *)(v9 + 24), OS_LOG_TYPE_DEFAULT))
    {
LABEL_157:
      v111 = realpath_DARWIN_EXTSN(a1, 0LL);
      *(void *)(v9 + 176) = v111;
      if (v111)
      {
        v112 = *(os_log_s **)(v9 + 24);
        if (v112)
        {
          v113 = v111;
          if (os_log_type_enabled(*(os_log_t *)(v9 + 24), OS_LOG_TYPE_DEFAULT))
          {
            buf.f_bsize = 136315138;
            *(void *)&buf.f_iosize = v113;
            v114 = "Source path: %s";
            goto LABEL_161;
          }
        }

        return v9;
      }

      int v131 = *__error();
      v132 = __error();
      strerror(*v132);
      BOMCopierErrorCapture( a4,  v131,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c",  803,  (uint64_t)"BOMCopierSourceNew",  "Could not resolve the path: %s");
      goto LABEL_313;
    }

    LOWORD(buf.f_bsize) = 0;
    _os_log_impl(&dword_1862F3000, v105, OS_LOG_TYPE_DEFAULT, "Using an enumeration bom", (uint8_t *)&buf, 2u);
    int v104 = *(_DWORD *)(v9 + 100);
  }

  switch(v104)
  {
    case 0:
      uint64_t v106 = realpath_DARWIN_EXTSN(a1, 0LL);
      *(void *)(v9 + 128) = v106;
      if (!v106)
      {
        int v133 = *__error();
        v134 = __error();
        strerror(*v134);
        BOMCopierErrorCapture( a4,  v133,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c",  716,  (uint64_t)"BOMCopierSourceNew",  "Could not resolve %s: %s");
        goto LABEL_313;
      }

      stat v107 = v106;
      if (!*(_BYTE *)(v9 + 376)) {
        goto LABEL_149;
      }
      if (!basename_r(v106, (char *)&buf))
      {
        int v151 = *__error();
        v152 = __error();
        strerror(*v152);
        BOMCopierErrorCapture( a4,  v151,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c",  727,  (uint64_t)"BOMCopierSourceNew",  "Could not basename_r %s: %s");
        goto LABEL_313;
      }

      *(void *)(v9 + 136) = strlen((const char *)&buf) + 1;
      stat v107 = *(const char **)(v9 + 128);
LABEL_149:
      *(void *)(v9 + 144) = strlen(v107);
      v180[0] = (char *)v107;
      v180[1] = 0LL;
      if (*(_BYTE *)(v9 + 160)) {
        int v108 = 21;
      }
      else {
        int v108 = 85;
      }
      if (*(_BYTE *)(v9 + 97)) {
        v109 = 0LL;
      }
      else {
        v109 = (int (__cdecl *)(const FTSENT **, const FTSENT **))fts_compare;
      }
      v146 = fts_open(v180, v108, v109);
      *(void *)(v9 + 152) = v146;
      if (!v146)
      {
        int v149 = *__error();
        v150 = __error();
        strerror(*v150);
        BOMCopierErrorCapture( a4,  v149,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c",  758,  (uint64_t)"BOMCopierSourceNew",  "Could not open the FTS handle for %s: %s");
        goto LABEL_313;
      }

      memset(&v176, 0, sizeof(v176));
      if (stat(*(const char **)(v9 + 128), &v176))
      {
        int v147 = *__error();
        v148 = __error();
        strerror(*v148);
        BOMCopierErrorCapture( a4,  v147,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c",  771,  (uint64_t)"BOMCopierSourceNew",  "Could not stat %s: %s");
        goto LABEL_313;
      }

      *(_DWORD *)(v9 + 164) = v176.st_dev;
      bzero(&buf, 0x878uLL);
      if (statfs(*(const char **)(v9 + 128), &buf))
      {
        int v157 = *__error();
        v158 = __error();
        strerror(*v158);
        BOMCopierErrorCapture( a4,  v157,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c",  782,  (uint64_t)"BOMCopierSourceNew",  "Could not statfs %s: %s");
        goto LABEL_313;
      }

      *(_BYTE *)(v9 + 168) = (buf.f_flags & 8) == 0;
      v112 = *(os_log_s **)(v9 + 24);
      if (!v112 || !os_log_type_enabled(*(os_log_t *)(v9 + 24), OS_LOG_TYPE_DEFAULT)) {
        return v9;
      }
      uint64_t v160 = *(void *)(v9 + 128);
      int v177 = 136315138;
      uint64_t v178 = v160;
      v114 = "Opened FTS from %s";
      p_statfs buf = (statfs *)&v177;
      goto LABEL_162;
    case 1:
      goto LABEL_157;
    case 2:
      uint64_t v118 = archive_read_new();
      *(void *)(v9 + 224) = v118;
      if (!v118)
      {
        int v135 = *__error();
        BOMCopierErrorCapture( a4,  v135,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c",  823,  (uint64_t)"BOMCopierSourceNew",  "Could not create archive object");
        goto LABEL_313;
      }

      int support_filter_all = archive_read_support_filter_all();
      if (support_filter_all)
      {
        BOMCopierErrorCapture( a4,  support_filter_all,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c",  832,  (uint64_t)"BOMCopierSourceNew",  "Could not enable read support for all filter types");
LABEL_234:
        archive_read_free();
        *(void *)(v9 + 224) = 0LL;
        goto LABEL_313;
      }

      int support_format_all = archive_read_support_format_all();
      if (support_format_all)
      {
        BOMCopierErrorCapture( a4,  support_format_all,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c",  842,  (uint64_t)"BOMCopierSourceNew",  "Could not enable read support for all format types");
        goto LABEL_234;
      }

      int set_options = archive_read_set_options();
      if (set_options)
      {
        BOMCopierErrorCapture( a4,  set_options,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c",  852,  (uint64_t)"BOMCopierSourceNew",  "Could not disable __MACOSX support\n");
        goto LABEL_234;
      }

      set_passphrase_callbacunsigned int k = archive_read_set_passphrase_callback();
      if (set_passphrase_callback)
      {
        BOMCopierErrorCapture( a4,  set_passphrase_callback,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c",  866,  (uint64_t)"BOMCopierSourceNew",  "Could not set the passphrase callback\n");
        goto LABEL_234;
      }

      if (*(void *)(v9 + 240))
      {
        int add_passphrase = archive_read_add_passphrase();
        if (add_passphrase)
        {
          int v164 = add_passphrase;
          int v165 = archive_errno();
          strerror(v165);
          BOMCopierErrorCapture( a4,  v164,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c",  878,  (uint64_t)"BOMCopierSourceNew",  "Could not add passphrase: %s\n");
          goto LABEL_234;
        }
      }

      if (prepare_archive_source(a1, v9, a4))
      {
        BOMCopierErrorCapture( a4,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c",  894,  (uint64_t)"BOMCopierSourceNew",  "Could not prepare archive source");
        goto LABEL_234;
      }

      if (a1)
      {
        if (archive_read_open_filename())
        {
          archive_error_string();
          BOMCopierErrorCapture( a4,  3,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c",  969,  (uint64_t)"BOMCopierSourceNew",  "Could not open the archive %s for reading: %s");
          goto LABEL_234;
        }

        v112 = *(os_log_s **)(v9 + 24);
        if (v112 && os_log_type_enabled(*(os_log_t *)(v9 + 24), OS_LOG_TYPE_DEFAULT))
        {
          buf.f_bsize = 136315138;
          *(void *)&buf.f_iosize = a1;
          v114 = "Opened archive from %s";
LABEL_161:
          p_statfs buf = &buf;
LABEL_162:
          v116 = v112;
          uint32_t v117 = 12;
          goto LABEL_163;
        }

        return v9;
      }

      if (*(void *)(v9 + 48))
      {
        v169 = valloc(*(void *)(v9 + 232));
        *(void *)(v9 + 56) = v169;
        if (!v169)
        {
          v174 = __error();
          strerror(*v174);
          BOMCopierErrorCapture( a4,  0,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c",  920,  (uint64_t)"BOMCopierSourceNew",  "Could not allocate libarchive buffer: %s");
          goto LABEL_234;
        }

        int open = archive_read_open();
        if (open)
        {
          int v171 = open;
          archive_error_string();
          BOMCopierErrorCapture( a4,  v171,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c",  935,  (uint64_t)"BOMCopierSourceNew",  "Could not open the archive_read_open2 for reading: %s");
          goto LABEL_234;
        }

        v168 = *(os_log_s **)(v9 + 24);
        if (!v168 || !os_log_type_enabled(*(os_log_t *)(v9 + 24), OS_LOG_TYPE_DEFAULT)) {
          return v9;
        }
        LOWORD(buf.f_bsize) = 0;
        v114 = "Opened archive from CFReadStream";
LABEL_263:
        p_statfs buf = &buf;
        v116 = v168;
        uint32_t v117 = 2;
LABEL_163:
        _os_log_impl(&dword_1862F3000, v116, OS_LOG_TYPE_DEFAULT, v114, (uint8_t *)p_buf, v117);
        return v9;
      }

      if (*(_DWORD *)(v9 + 40) != -1)
      {
        int open_fd = archive_read_open_fd();
        if (open_fd)
        {
          int v173 = open_fd;
          archive_error_string();
          BOMCopierErrorCapture( a4,  v173,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c",  954,  (uint64_t)"BOMCopierSourceNew",  "Could not open the archive %d for reading: %s");
          goto LABEL_234;
        }

        v168 = *(os_log_s **)(v9 + 24);
        if (!v168 || !os_log_type_enabled(*(os_log_t *)(v9 + 24), OS_LOG_TYPE_DEFAULT)) {
          return v9;
        }
        LOWORD(buf.f_bsize) = 0;
        v114 = "Opened archive from file descriptor";
        goto LABEL_263;
      }

      BOMCopierErrorCapture( a4,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c",  947,  (uint64_t)"BOMCopierSourceNew",  "No input file descriptor\n");
      return 0LL;
    case 3:
      v120 = data_archive_new(0LL);
      *(void *)(v9 + 280) = v120;
      if (!v120)
      {
        int v136 = *__error();
        BOMCopierErrorCapture( a4,  v136,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c",  986,  (uint64_t)"BOMCopierSourceNew",  "Could not create data_archive object");
        goto LABEL_313;
      }

      *(void *)&v176.st_dev = 0LL;
      int v125 = data_archive_set_passphrase_callback( (uint64_t)v120,  (uint64_t)data_archive_passphrase_callback_handler,  v9,  &v176,  v121,  v122,  v123,  v124);
      if (v125)
      {
        BOMCopierErrorCapture( a4,  v125,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c",  999,  (uint64_t)"BOMCopierSourceNew",  "Could not set the passphrase callback: %s");
        goto LABEL_172;
      }

      int v140 = prepare_archive_source(a1, v9, a4);
      if (v140)
      {
        BOMCopierErrorCapture( a4,  v140,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c",  1013,  (uint64_t)"BOMCopierSourceNew",  "Could not prepare archive source");
        goto LABEL_313;
      }

      if (!a1)
      {
        if (*(void *)(v9 + 48))
        {
          int v162 = data_archive_open_custom( *(void *)(v9 + 280),  v9,  (uint64_t)data_source_read_callback,  &v176,  v142,  v143,  v144,  v145);
          if (!v162)
          {
            v168 = *(os_log_s **)(v9 + 24);
            if (!v168 || !os_log_type_enabled(*(os_log_t *)(v9 + 24), OS_LOG_TYPE_DEFAULT)) {
              return v9;
            }
            LOWORD(buf.f_bsize) = 0;
            v114 = "Opened data archive from CFReadStream";
            goto LABEL_263;
          }

          BOMCopierErrorCapture( a4,  v162,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c",  1030,  (uint64_t)"BOMCopierSourceNew",  "Could not open the archive %d for custom reading: %s");
        }

        else
        {
          int v166 = *(_DWORD *)(v9 + 40);
          if (v166 == -1)
          {
            BOMCopierErrorCapture( a4,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c",  1041,  (uint64_t)"BOMCopierSourceNew",  "No input file descriptor\n");
            goto LABEL_313;
          }

          int v167 = data_archive_open_fd(*(void *)(v9 + 280), v166, &v176, v141, v142, v143, v144, v145);
          if (!v167)
          {
            v168 = *(os_log_s **)(v9 + 24);
            if (!v168 || !os_log_type_enabled(*(os_log_t *)(v9 + 24), OS_LOG_TYPE_DEFAULT)) {
              return v9;
            }
            LOWORD(buf.f_bsize) = 0;
            v114 = "Opened data archive from file descriptor";
            goto LABEL_263;
          }

          BOMCopierErrorCapture( a4,  v167,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c",  1049,  (uint64_t)"BOMCopierSourceNew",  "Could not open the archive %d for reading: %s");
        }

LABEL_172:
        release_error(*(void **)&v176.st_dev);
        goto LABEL_313;
      }

      if (data_archive_open(*(void *)(v9 + 280), a1, &v176, v141, v142, v143, v144, v145))
      {
        BOMCopierErrorCapture( a4,  3,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c",  1063,  (uint64_t)"BOMCopierSourceNew",  "Could not open the archive %s for reading: %s");
        goto LABEL_172;
      }

      v112 = *(os_log_s **)(v9 + 24);
      if (v112 && os_log_type_enabled(*(os_log_t *)(v9 + 24), OS_LOG_TYPE_DEFAULT))
      {
        buf.f_bsize = 136315138;
        *(void *)&buf.f_iosize = a1;
        v114 = "Opened data archive from %s";
        goto LABEL_161;
      }

      return v9;
    case 4:
      if (a1)
      {
        AAByteStream v126 = AAFileStreamOpenWithPath(a1, 0, 0);
        *(void *)(v9 + 288) = v126;
        if (!v126)
        {
          BOMCopierErrorCapture( a4,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c",  1116,  (uint64_t)"BOMCopierSourceNew",  "Could not open AppleArchive byte stream at %s");
          goto LABEL_313;
        }

        v127 = *(os_log_s **)(v9 + 24);
        if (v127 && os_log_type_enabled(*(os_log_t *)(v9 + 24), OS_LOG_TYPE_DEFAULT))
        {
          buf.f_bsize = 136315138;
          *(void *)&buf.f_iosize = a1;
          v128 = "Opened AppleArchive from %s";
          v129 = v127;
          uint32_t v130 = 12;
LABEL_209:
          _os_log_impl(&dword_1862F3000, v129, OS_LOG_TYPE_DEFAULT, v128, (uint8_t *)&buf, v130);
        }

LABEL_210:
        v155 = AADecompressionInputStreamOpen(*(AAByteStream *)(v9 + 288), 0LL, 0);
        *(void *)(v9 + 296) = v155;
        if (v155)
        {
          AAArchiveStream v156 = AADecodeArchiveInputStreamOpen(v155, 0LL, 0LL, 0LL, 0);
          *(void *)(v9 + 304) = v156;
          if (v156) {
            return v9;
          }
          BOMCopierErrorCapture( a4,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c",  1135,  (uint64_t)"BOMCopierSourceNew",  "Could not create AppleArchive decoder");
        }

        else
        {
          BOMCopierErrorCapture( a4,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c",  1127,  (uint64_t)"BOMCopierSourceNew",  "Could not open AppleArchive decompression stream at %s");
        }

        goto LABEL_313;
      }

      if (*(void *)(v9 + 48))
      {
        v137 = AACustomByteStreamOpen();
        *(void *)(v9 + 288) = v137;
        if (!v137)
        {
          BOMCopierErrorCapture( a4,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c",  1082,  (uint64_t)"BOMCopierSourceNew",  "Could not create custom AppleArchive byte stream at %s\n");
          goto LABEL_313;
        }

        AACustomByteStreamSetData(v137, (void *)v9);
        AACustomByteStreamSetCloseProc(*(AAByteStream *)(v9 + 288), (AAByteStreamCloseProc)apple_archive_close_callback);
        AACustomByteStreamSetReadProc(*(AAByteStream *)(v9 + 288), (AAByteStreamReadProc)apple_archive_read_callback);
        v138 = *(os_log_s **)(v9 + 24);
        if (!v138 || !os_log_type_enabled(*(os_log_t *)(v9 + 24), OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_210;
        }
        LOWORD(buf.f_bsize) = 0;
        v128 = "Opened AppleArchive from CFReadStream";
      }

      else
      {
        int v153 = *(_DWORD *)(v9 + 40);
        if (v153 == -1)
        {
          BOMCopierErrorCapture( a4,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c",  1096,  (uint64_t)"BOMCopierSourceNew",  "No input file descriptor\n");
          goto LABEL_313;
        }

        AAByteStream v154 = AAFileStreamOpenWithFD(v153, 0);
        *(void *)(v9 + 288) = v154;
        if (!v154)
        {
          BOMCopierErrorCapture( a4,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c",  1104,  (uint64_t)"BOMCopierSourceNew",  "Could not open AppleArchive byte stream from file descriptor");
          goto LABEL_313;
        }

        v138 = *(os_log_s **)(v9 + 24);
        if (!v138 || !os_log_type_enabled(*(os_log_t *)(v9 + 24), OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_210;
        }
        LOWORD(buf.f_bsize) = 0;
        v128 = "Opened AppleArchive from file descriptor";
      }

      v129 = v138;
      uint32_t v130 = 2;
      goto LABEL_209;
    default:
      return v9;
  }

void BOMCopierSourceFree(void *a1)
{
  if (a1)
  {
    uint64_t v2 = (void *)*((void *)a1 + 7);
    if (v2) {
      free(v2);
    }
    uint64_t v3 = (void *)*((void *)a1 + 34);
    if (v3) {
      free(v3);
    }
    char v4 = (void *)*((void *)a1 + 46);
    if (v4) {
      free(v4);
    }
    uint64_t v5 = *((void *)a1 + 43);
    if (v5) {
      path_tree_node_release(v5);
    }
    uint64_t v6 = *((void *)a1 + 44);
    if (v6)
    {
      while (!BOMStackIsEmpty(v6))
      {
        uint64_t v7 = BOMStackPop(*((uint64_t **)a1 + 44));
        BOMCopierSourceEntryFree((unsigned int *)v7);
        uint64_t v6 = *((void *)a1 + 44);
      }

      BOMStackFree(*((void ***)a1 + 44));
    }

    uint64_t v8 = *((void *)a1 + 42);
    if (v8)
    {
      while (!BOMStackIsEmpty(v8))
      {
        uint64_t v9 = BOMStackPop(*((uint64_t **)a1 + 42));
        BOMCopierSourceEntryFree((unsigned int *)v9);
        uint64_t v8 = *((void *)a1 + 42);
      }

      BOMStackFree(*((void ***)a1 + 42));
    }

    uint64_t v10 = *((void *)a1 + 41);
    if (v10)
    {
      while (!BOMStackIsEmpty(v10))
      {
        int v11 = BOMStackPop(*((uint64_t **)a1 + 41));
        BOMCopierSourceEntryFree((unsigned int *)v11);
        uint64_t v10 = *((void *)a1 + 41);
      }

      BOMStackFree(*((void ***)a1 + 41));
    }

    uint64_t v12 = *((void *)a1 + 40);
    if (v12)
    {
      while (!BOMStackIsEmpty(v12))
      {
        int32_t v13 = BOMStackPop(*((uint64_t **)a1 + 40));
        BOMCopierSourceEntryFree((unsigned int *)v13);
        uint64_t v12 = *((void *)a1 + 40);
      }

      BOMStackFree(*((void ***)a1 + 40));
    }

    uint64_t v14 = *((void *)a1 + 39);
    if (v14)
    {
      while (!BOMStackIsEmpty(v14))
      {
        uint64_t v15 = BOMStackPop(*((uint64_t **)a1 + 39));
        BOMCopierSourceEntryFree((unsigned int *)v15);
        uint64_t v14 = *((void *)a1 + 39);
      }

      BOMStackFree(*((void ***)a1 + 39));
    }

    uint64_t v16 = (void *)*((void *)a1 + 30);
    if (v16) {
      free(v16);
    }
    int64_t v17 = (AAArchiveStream_impl *)*((void *)a1 + 38);
    if (v17 && AAArchiveStreamClose(v17))
    {
      fprintf((FILE *)*MEMORY[0x1895F89D0], "Could not close AppleArchive decoder: %d\n");
    }

    else
    {
      uint64_t v18 = (AAByteStream_impl *)*((void *)a1 + 37);
      if (v18 && AAByteStreamClose(v18))
      {
        fprintf((FILE *)*MEMORY[0x1895F89D0], "Could not close AppleArchive decompression stream: %d\n");
      }

      else
      {
        uint64_t v19 = (AAByteStream_impl *)*((void *)a1 + 36);
        if (v19 && AAByteStreamClose(v19))
        {
          fprintf((FILE *)*MEMORY[0x1895F89D0], "Could not close AppleArchive byte stream: %d\n");
        }

        else
        {
          int v20 = (unsigned int *)*((void *)a1 + 35);
          if (v20) {
            data_archive_free(v20);
          }
          if (*((void *)a1 + 28)) {
            archive_read_free();
          }
          int v21 = (void *)*((void *)a1 + 25);
          if (v21) {
            BOMBomEnumeratorFree(v21);
          }
          uint64_t v22 = *((void *)a1 + 24);
          if (v22) {
            BOMFSObjectFree(v22);
          }
          char v23 = (void *)*((void *)a1 + 22);
          if (v23) {
            free(v23);
          }
          uint64_t v24 = (FTS *)*((void *)a1 + 19);
          if (v24) {
            fts_close(v24);
          }
          uint64_t v25 = (void *)*((void *)a1 + 16);
          if (v25) {
            free(v25);
          }
          uint64_t v26 = (void *)*((void *)a1 + 10);
          if (v26) {
            free(v26);
          }
          free(a1);
        }
      }
    }
  }

uint64_t fts_compare(uint64_t a1, uint64_t a2)
{
  else {
    size_t v2 = *(unsigned __int16 *)(*(void *)a2 + 66LL);
  }
  return strncmp((const char *)(*(void *)a1 + 104LL), (const char *)(*(void *)a2 + 104LL), v2);
}

uint64_t libarchive_passphrase_callback_handler(uint64_t a1, void *a2)
{
  uint64_t result = a2[30];
  if (!result)
  {
    uint64_t v3 = (uint64_t (*)(void *, void, uint64_t *))a2[31];
    if (v3)
    {
      uint64_t v4 = 0LL;
      return v3(a2, a2[32], &v4);
    }

    else
    {
      return 0LL;
    }
  }

  return result;
}

uint64_t prepare_archive_source(const char *a1, uint64_t a2, void *a3)
{
  if (a1)
  {
    if (stat(a1, &v7))
    {
      int v4 = *__error();
      uint64_t v5 = __error();
      strerror(*v5);
      BOMCopierErrorCapture( a3,  v4,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c",  2131,  (uint64_t)"prepare_archive_source",  "Could not stat the archive %s: %s");
      return 1LL;
    }

    if (!v7.st_size)
    {
      BOMCopierErrorCapture( a3,  3,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c",  2137,  (uint64_t)"prepare_archive_source",  "%s is empty: Unrecognized archive format");
      return 1LL;
    }
  }

  else if (!*(void *)(a2 + 48) && *(_DWORD *)(a2 + 40) == -1)
  {
    BOMCopierErrorCapture( a3,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c",  2117,  (uint64_t)"prepare_archive_source",  "No input file descriptor\n");
    return 1LL;
  }

  return 0LL;
}

uint64_t libarchive_open_callback()
{
  return 0LL;
}

uint64_t libarchive_read_callback(uint64_t a1, uint64_t a2, void *a3)
{
  if (!a2) {
    return -1LL;
  }
  *a3 = *(void *)(a2 + 56);
  while (1)
  {
    CFIndex v4 = CFReadStreamRead(*(CFReadStreamRef *)(a2 + 48), *(UInt8 **)(a2 + 56), *(void *)(a2 + 232));
    if ((v4 & 0x8000000000000000LL) == 0) {
      break;
    }
    if (*__error() != 4)
    {
      __error();
      archive_set_error();
      return v4;
    }
  }

  return v4;
}

uint64_t libarchive_close_callback()
{
  return 0LL;
}

uint64_t data_archive_passphrase_callback_handler(uint64_t a1, void *a2)
{
  uint64_t result = a2[30];
  if (!result)
  {
    uint64_t v3 = (uint64_t (*)(void *, void, uint64_t *))a2[31];
    if (v3)
    {
      uint64_t v4 = 0LL;
      return v3(a2, a2[32], &v4);
    }

    else
    {
      return 0LL;
    }
  }

  return result;
}

CFIndex data_source_read_callback(uint64_t a1, int a2, UInt8 *buffer, CFIndex bufferLength)
{
  if (a1) {
    return CFReadStreamRead(*(CFReadStreamRef *)(a1 + 48), buffer, bufferLength);
  }
  else {
    return -1LL;
  }
}

uint64_t apple_archive_close_callback()
{
  return 0LL;
}

CFIndex apple_archive_read_callback(uint64_t a1, UInt8 *a2, CFIndex a3)
{
  if (a1) {
    return CFReadStreamRead(*(CFReadStreamRef *)(a1 + 48), a2, a3);
  }
  else {
    return -1LL;
  }
}

void path_tree_node_release(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 8))
  {
    unint64_t v2 = 0LL;
    do
      path_tree_node_release(*(void *)(*(void *)(a1 + 16) + 8 * v2++));
    while (v2 < *(unsigned int *)(a1 + 8));
  }

  uint64_t v3 = *(void **)(a1 + 16);
  if (v3) {
    free(v3);
  }
  if (*(void *)a1) {
    free(*(void **)a1);
  }
  free((void *)a1);
}

uint64_t BOMCopierSourceSetErrorHandler(void *a1, uint64_t a2, uint64_t a3, void *a4)
{
  if (a1)
  {
    uint64_t v4 = 0LL;
    *a1 = a2;
    a1[1] = a3;
  }

  else
  {
    uint64_t v4 = 22LL;
    BOMCopierErrorCapture( a4,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c",  1329,  (uint64_t)"BOMCopierSourceSetErrorHandler",  "copier_source is NULL");
  }

  return v4;
}

uint64_t BOMCopierSourceSetEnumerationBom(uint64_t a1, uint64_t a2, void *a3)
{
  if (!a1)
  {
    uint64_t v7 = 22LL;
    BOMCopierErrorCapture( a3,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c",  1348,  (uint64_t)"BOMCopierSourceSetEnumerationBom",  "copier_source is NULL");
    return v7;
  }

  if (!a2)
  {
    uint64_t v7 = 22LL;
    BOMCopierErrorCapture( a3,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c",  1354,  (uint64_t)"BOMCopierSourceSetEnumerationBom",  "enumeration_bom is NULL");
    return v7;
  }

  if (*(_DWORD *)(a1 + 100) != 1)
  {
    uint64_t v7 = 22LL;
    BOMCopierErrorCapture( a3,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c",  1360,  (uint64_t)"BOMCopierSourceSetEnumerationBom",  "The copier source is not BOMCopierSourceIndexBom");
    return v7;
  }

  if (!*(_BYTE *)(a1 + 65))
  {
    uint64_t v7 = 22LL;
    BOMCopierErrorCapture( a3,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c",  1366,  (uint64_t)"BOMCopierSourceSetEnumerationBom",  "The copier source is not configured to use an enumeration bom");
    return v7;
  }

  *(void *)(a1 + 184) = a2;
  RootFSObject = (unsigned int *)BOMBomGetRootFSObject(a2);
  *(void *)(a1 + 192) = RootFSObject;
  if (!RootFSObject)
  {
    uint64_t v7 = 1LL;
    BOMCopierErrorCapture( a3,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c",  1375,  (uint64_t)"BOMCopierSourceSetEnumerationBom",  "Could not get the root fso for the enumeration bom");
LABEL_15:
    BOMCopierSourceFree((void *)a1);
    return v7;
  }

  uint64_t v6 = BOMBomEnumeratorNew(*(void *)(a1 + 184), RootFSObject);
  *(void *)(a1 + 200) = v6;
  if (!v6)
  {
    uint64_t v7 = 1LL;
    BOMCopierErrorCapture( a3,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c",  1390,  (uint64_t)"BOMCopierSourceSetEnumerationBom",  "Could not create enumerator for the enumeration bom");
    goto LABEL_15;
  }

  return 0LL;
}

uint64_t BOMCopierSourceSetAllowBom(uint64_t a1, uint64_t a2, void *a3)
{
  if (a1)
  {
    uint64_t v3 = 0LL;
    *(void *)(a1 + 216) = a2;
  }

  else
  {
    uint64_t v3 = 22LL;
    BOMCopierErrorCapture( a3,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c",  1410,  (uint64_t)"BOMCopierSourceSetAllowBom",  "copier_source is NULL");
  }

  return v3;
}

uint64_t BOMCopierSourceSetRedirectCallback(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  if (a1)
  {
    uint64_t v4 = 0LL;
    *(void *)(a1 + 112) = a2;
    *(void *)(a1 + 120) = a3;
  }

  else
  {
    uint64_t v4 = 22LL;
    BOMCopierErrorCapture( a4,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c",  1433,  (uint64_t)"BOMCopierSourceSetRedirectCallback",  "copier_source is NULL");
  }

  return v4;
}

uint64_t BOMCopierSourceSetPassphraseCallback(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  if (a1)
  {
    uint64_t v4 = 0LL;
    *(void *)(a1 + 248) = a2;
    *(void *)(a1 + 256) = a3;
  }

  else
  {
    uint64_t v4 = 22LL;
    BOMCopierErrorCapture( a4,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c",  1453,  (uint64_t)"BOMCopierSourceSetPassphraseCallback",  "copier_source is NULL");
  }

  return v4;
}

uint64_t *BOMCopierSourceNext( uint64_t a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = a2;
  uint64_t v148 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    uint64_t v10 = (_BYTE *)(a1 + 104);
    uint64_t v133 = a1 + 112;
    int v11 = &dword_1862F3000;
    while (1)
    {
      v134 = 0LL;
      uint64_t v12 = *(uint64_t **)(a1 + 312);
      if (v12)
      {
        int32_t v13 = *(os_log_s **)(a1 + 24);
        if (v13 && os_log_type_enabled(*(os_log_t *)(a1 + 24), OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)statfs buf = 0;
          _os_log_impl(v11, v13, OS_LOG_TYPE_DEFAULT, "Retrieving entry from the pre-empt stack", buf, 2u);
          uint64_t v12 = *(uint64_t **)(a1 + 312);
        }

        filesystem_entry = (unsigned int *)BOMStackPop(v12);
        int v136 = 0LL;
        if (filesystem_entry) {
          break;
        }
      }

      else
      {
        int v136 = 0LL;
      }

      if (*v10)
      {
LABEL_11:
        filesystem_entry = 0LL;
      }

      else
      {
        uint64_t v16 = *(os_log_s **)(a1 + 24);
        if (v16 && os_log_type_enabled(*(os_log_t *)(a1 + 24), OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)statfs buf = 0;
          _os_log_impl(v11, v16, OS_LOG_TYPE_DEFAULT, "Retrieving entry from the source", buf, 2u);
        }

        switch(*(_DWORD *)(a1 + 100))
        {
          case 0:
            v139[0] = 0LL;
            if (*(void *)v133)
            {
              (*(void (**)(uint64_t, char **, void))v133)(a1, v139, *(void *)(a1 + 120));
              *(void *)uint64_t v133 = 0LL;
              *(void *)(v133 + 8) = 0LL;
              int64_t v17 = *(os_log_s **)(a1 + 24);
              if (v17)
              {
                if (os_log_type_enabled(*(os_log_t *)(a1 + 24), OS_LOG_TYPE_DEFAULT))
                {
                  *(_DWORD *)statfs buf = 136315138;
                  *(char **)&buf[4] = v139[0];
                  _os_log_impl(v11, v17, OS_LOG_TYPE_DEFAULT, "Redirected to %s", buf, 0xCu);
                }
              }
            }

            filesystem_entry = (unsigned int *)next_filesystem_entry(a1, v139[0], v10, (uint64_t *)&v136);
            if (v139[0]) {
              free(v139[0]);
            }
            break;
          case 1:
            uint64_t v48 = *(void *)(a1 + 200);
            if (!v48)
            {
              BOMCopierErrorCapture( &v136,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c",  2837,  (uint64_t)"next_enumeration_bom_entry",  "The BOMCopierSource does not have an index bom enumerator",  v129);
              goto LABEL_11;
            }

            size_t v49 = BOMBomEnumeratorNext(v48);
            if (v49)
            {
              uint64_t v50 = (uint64_t)v49;
              __int16 v51 = *(_BYTE *)(a1 + 64) == 0;
              if (*(_BYTE *)(a1 + 360)) {
                v51 |= 2u;
              }
              if (*(_BYTE *)(a1 + 361)) {
                v51 |= 8u;
              }
              if (*(_BYTE *)(a1 + 362)) {
                v51 |= 4u;
              }
              if (*(_BYTE *)(a1 + 363)) {
                v51 |= 0x10u;
              }
              if (*(_BYTE *)(a1 + 364)) {
                v51 |= 0x20u;
              }
              if (*(_BYTE *)(a1 + 365)) {
                v51 |= 0x40u;
              }
              if (*(_BYTE *)(a1 + 209)) {
                v51 |= 0x100u;
              }
              if (*(_BYTE *)(a1 + 208)) {
                __int16 v52 = v51 | 0x80;
              }
              else {
                __int16 v52 = v51;
              }
              filesystem_entry = (unsigned int *)BOMCopierSourceEntryNewFromFSObject( *(const char **)(a1 + 176),  (uint64_t)v49,  v52,  &v136);
              if (filesystem_entry)
              {
                int v53 = BOMFSObjectParentPathID(v50);
                int v54 = BOMFSObjectPathID(v50);
                if (!v53 && v54 == 1) {
                  BOMCopierSourceEntrySetRoot((uint64_t)filesystem_entry, 1);
                }
                BOMFSObjectFree(v50);
                if (synthesize_filesystem_stuff())
                {
                  BOMCopierErrorCapture( &v136,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c",  2918,  (uint64_t)"next_enumeration_bom_entry",  "Could not synthesize filesystem stuff");
                  BOMCopierSourceEntryFree(filesystem_entry);
                  goto LABEL_11;
                }
              }

              else
              {
                BOMCopierErrorCapture( &v136,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c",  2900,  (uint64_t)"next_enumeration_bom_entry",  "Could not synthesize filesystem stuff");
                BOMFSObjectFree(v50);
              }
            }

            else
            {
              filesystem_entry = 0LL;
              *uint64_t v10 = 1;
            }

            break;
          case 2:
            if (!*(void *)(a1 + 224))
            {
              BOMCopierErrorCapture( &v136,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c",  2942,  (uint64_t)"next_libarchive_entry",  "copier_source->archive is NULL",  v129);
              goto LABEL_11;
            }

            if (*(_BYTE *)(a1 + 360)) {
              __int16 v55 = (*(unsigned __int8 *)(a1 + 264) << 9) | 2;
            }
            else {
              __int16 v55 = *(unsigned __int8 *)(a1 + 264) << 9;
            }
            int next_header = archive_read_next_header();
            if (archive_read_has_encrypted_entries() == 1
              && !*(void *)(a1 + 240)
              && !*(void *)(a1 + 248))
            {
              BOMCopierErrorCapture( &v136,  45,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c",  2973,  (uint64_t)"next_libarchive_entry",  "archive has encrypted entries");
              goto LABEL_11;
            }

            if (next_header == -30)
            {
              int v81 = (const char *)archive_error_string();
              if (!v81 || strcmp(v81, "Invalid central directory signature"))
              {
                BOMCopierErrorCapture( &v136,  -30,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c",  3010,  (uint64_t)"next_libarchive_entry",  "Could not read archive header: ARCHIVE_FATAL: %s");
                goto LABEL_11;
              }

              goto LABEL_186;
            }

            if (next_header == 1) {
              goto LABEL_186;
            }
            if (next_header)
            {
              archive_error_string();
              BOMCopierErrorCapture( &v136,  next_header,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c",  3018,  (uint64_t)"next_libarchive_entry",  "Could not read archive header: %d: %s");
              goto LABEL_11;
            }

            uint64_t v57 = BOMCopierSourceEntryNewFromLibarchive(*(void *)(a1 + 224), *(uint64_t *)buf, v55, &v136);
LABEL_122:
            filesystem_entry = (unsigned int *)v57;
            break;
          case 3:
            uint64_t v57 = next_data_archive_entry(a1, v10, &v136, a4, a5, a6, a7, a8);
            goto LABEL_122;
          case 4:
            uint64_t v58 = *(AAArchiveStream_impl **)(a1 + 304);
            if (!v58)
            {
              BOMCopierErrorCapture( &v136,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c",  3114,  (uint64_t)"next_apple_archive_entry",  "copier_source->aa_decoder is NULL",  v129);
              goto LABEL_11;
            }

            if (*(_BYTE *)(a1 + 360)) {
              char v59 = 2;
            }
            else {
              char v59 = 0;
            }
            if (*(_BYTE *)(a1 + 362)) {
              v59 |= 4u;
            }
            if (*(_BYTE *)(a1 + 364)) {
              unsigned __int8 v60 = v59 | 0x20;
            }
            else {
              unsigned __int8 v60 = v59;
            }
            *(void *)statfs buf = 0LL;
            int Header = AAArchiveStreamReadHeader(v58, (AAHeader *)buf);
            if (Header < 0)
            {
              int v62 = 3146;
              goto LABEL_155;
            }

            if (Header == 1)
            {
              filesystem_entry = (unsigned int *)BOMCopierSourceEntryNewFromAppleArchive( *(void *)(a1 + 304),  *(AAHeader *)buf,  v60,  &v136);
              AAHeaderDestroy(*(AAHeader *)buf);
            }

            else
            {
              if (Header)
              {
                int v62 = 3154;
LABEL_155:
                BOMCopierErrorCapture( &v136,  Header,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c",  v62,  (uint64_t)"next_apple_archive_entry",  "Could not read AppleArchive header: %d");
                goto LABEL_11;
              }

LABEL_186:
              filesystem_entry = 0LL;
              *uint64_t v10 = 1;
            }

            break;
          default:
            goto LABEL_11;
        }
      }

      if (v136)
      {
        if (*(_DWORD *)(a1 + 16) == 1)
        {
          BOMCopierErrorFree(v136);
          *(_DWORD *)(a1 + 16) = 1;
          uint64_t v15 = *(os_log_s **)(a1 + 24);
          if (v15 && os_log_type_enabled(*(os_log_t *)(a1 + 24), OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)statfs buf = 0;
            _os_log_impl(v11, v15, OS_LOG_TYPE_DEFAULT, "Swallowing error", buf, 2u);
          }
        }

        else
        {
          v134 = v136;
          BOMCopierErrorCapture( &v134,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c",  2354,  (uint64_t)"next_source_entry",  "Could not get the next source entry");
        }

        goto LABEL_318;
      }

      if (filesystem_entry) {
        break;
      }
LABEL_283:
      if (!*v10) {
        goto LABEL_318;
      }
      if (*(void *)(a1 + 344))
      {
        if (!*(void *)(a1 + 352))
        {
          uint64_t v121 = (char *)BOMStackNew();
          *(void *)(a1 + 352) = v121;
          if (!v121)
          {
            BOMCopierErrorCapture( &v134,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c",  4823,  (uint64_t)"populate_sequester_stack",  "Could not create empty sequester stack");
            goto LABEL_317;
          }

          uint64_t v122 = *(void *)(a1 + 344);
          if (*(_BYTE *)(a1 + 93))
          {
            if (path_tree_node_push(*(void *)(a1 + 344), 0LL, v121, &v134))
            {
              BOMCopierErrorCapture( &v134,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c",  4844,  (uint64_t)"populate_sequester_stack",  "Could not push root node %s onto the stack\n");
LABEL_317:
              BOMCopierErrorCapture( &v134,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c",  2400,  (uint64_t)"next_source_entry",  "Could not populate sequester stack");
              goto LABEL_318;
            }
          }

          else if (*(_DWORD *)(v122 + 8))
          {
            uint64_t v123 = 0LL;
            while (!path_tree_node_push( *(void *)(*(void *)(v122 + 16) + 8 * v123),  ".",  *(char **)(a1 + 352),  &v134))
            {
            }

            BOMCopierErrorCapture( &v134,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c",  4860,  (uint64_t)"populate_sequester_stack",  "Could not push child %s of %s onto the stack\n");
            goto LABEL_317;
          }
        }

        CFTypeID v79 = BOMCopierSourceEntryGetPath((uint64_t)v55);
        uint64_t v80 = *(os_log_s **)(a1 + 13000);
        if (v80)
        {
          int v81 = v79;
          if (os_log_type_enabled(*(os_log_t *)(a1 + 13000), OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)v109 = 136315138;
            v110 = (const char *)v81;
            _os_log_impl(&dword_1862F3000, v80, OS_LOG_TYPE_DEFAULT, " %s", v109, 0xCu);
          }
        }

        if (BOMCopierCopySourceEntryToDestinationSet((uint64_t)v55, (unsigned int *)buf, &v108))
        {
          uint64_t v14 = 1LL;
          BOMCopierErrorCapture( &v108,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c",  550,  (uint64_t)"BOMCopierCopyWithOptions2",  "Could not copy from %s to %s: %s",  a2,  a3,  (const char *)0x8200102);
          notify_fatal_file_error(a1, (uint64_t)v55, v108);
LABEL_253:
          BOMCopierSourceEntryFree(v55);
          goto LABEL_227;
        }

        switch(BOMCopierDestinationGetCopyOperation(*v35))
        {
          case 0u:
            BOOL v82 = *(os_log_s **)(a1 + 13000);
            if (!v82 || !os_log_type_enabled(*(os_log_t *)(a1 + 13000), OS_LOG_TYPE_DEFAULT)) {
              goto LABEL_205;
            }
            *(_WORD *)v109 = 0;
            uint64_t v83 = v82;
            uint64_t v84 = "Source entry copied to destination set\n";
            break;
          case 1u:
            char v86 = *(os_log_s **)(a1 + 13000);
            if (!v86 || !os_log_type_enabled(*(os_log_t *)(a1 + 13000), OS_LOG_TYPE_DEFAULT)) {
              goto LABEL_205;
            }
            *(_WORD *)v109 = 0;
            uint64_t v83 = v86;
            uint64_t v84 = "Source entry skipped\n";
            break;
          case 2u:
            int v99 = *(os_log_s **)(a1 + 13000);
            if (!v99 || !os_log_type_enabled(*(os_log_t *)(a1 + 13000), OS_LOG_TYPE_DEFAULT)) {
              goto LABEL_273;
            }
            *(_WORD *)v109 = 0;
            uint64_t v100 = "Client cancelled\n";
            goto LABEL_272;
          case 3u:
            uint64_t v87 = *(os_log_s **)(a1 + 13000);
            if (!v87 || !os_log_type_enabled(*(os_log_t *)(a1 + 13000), OS_LOG_TYPE_DEFAULT)) {
              goto LABEL_205;
            }
            *(_WORD *)v109 = 0;
            uint64_t v83 = v87;
            uint64_t v84 = "Source entry retry?\n";
            break;
          default:
            goto LABEL_205;
        }

        _os_log_impl(&dword_1862F3000, v83, OS_LOG_TYPE_DEFAULT, v84, v109, 2u);
LABEL_205:
        BOMCopierSourceEntryFree(v55);
        if (*(_BYTE *)(a1 + 168) == 1)
        {
          uint64_t v101 = *(os_log_s **)(a1 + 13000);
          if (v101 && os_log_type_enabled(*(os_log_t *)(a1 + 13000), OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)v109 = 0;
            CFIndex v96 = "Client cancelled\n";
            uint64_t v14 = 2LL;
            uint64_t v97 = v101;
            goto LABEL_245;
          }

          goto LABEL_274;
        }
      }
    }
  }

  uint64_t v98 = *(os_log_s **)(a1 + 13000);
  if (v98 && os_log_type_enabled(*(os_log_t *)(a1 + 13000), OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)v109 = 0;
    _os_log_impl(&dword_1862F3000, v98, OS_LOG_TYPE_DEFAULT, "Source exhausted", v109, 2u);
  }

LABEL_286:
        int v108 = *(os_log_s **)(a1 + 24);
        if (v108 && os_log_type_enabled(*(os_log_t *)(a1 + 24), OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)statfs buf = 0;
          _os_log_impl(v11, v108, OS_LOG_TYPE_DEFAULT, "Retrieving entry from the sequester stack", buf, 2u);
        }

        char v91 = BOMStackPop(*(uint64_t **)(a1 + 352));
        if (v91) {
          goto LABEL_302;
        }
      }

      v109 = *(uint64_t **)(a1 + 320);
      if (v109 || *(void *)(a1 + 328) || *(void *)(a1 + 336))
      {
        v110 = *(os_log_s **)(a1 + 24);
        if (v110 && os_log_type_enabled(*(os_log_t *)(a1 + 24), OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)statfs buf = 0;
          _os_log_impl(v11, v110, OS_LOG_TYPE_DEFAULT, "Retrieving entry from the replay stacks", buf, 2u);
          v109 = *(uint64_t **)(a1 + 320);
        }

        if (v109)
        {
          char v91 = BOMStackPop(v109);
          if (v91) {
            goto LABEL_302;
          }
        }

        v111 = *(uint64_t **)(a1 + 328);
        if (v111)
        {
          char v91 = BOMStackPop(v111);
          if (v91) {
            goto LABEL_302;
          }
        }

        v112 = *(uint64_t **)(a1 + 336);
        if (v112)
        {
          char v91 = BOMStackPop(v112);
          if (v91) {
            goto LABEL_302;
          }
        }
      }

LABEL_318:
      stat v107 = v134;
      if (v134)
      {
LABEL_352:
        char v91 = 0LL;
        if (v8) {
          *uint64_t v8 = v107;
        }
        return v91;
      }

      if (*v10) {
        return 0LL;
      }
    }

    int v135 = 0LL;
    if ((*(_DWORD *)(a1 + 100) - 2) <= 2 && *(void *)(a1 + 216))
    {
      Path = (const char *)BOMCopierSourceEntryGetPath((uint64_t)filesystem_entry);
      if (!Path)
      {
        BOMCopierErrorCapture( &v135,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c",  3181,  (uint64_t)"filter_next_source_entry",  "Could not get entry path for source entry",  v129);
LABEL_49:
        char v23 = filesystem_entry;
LABEL_50:
        BOMCopierSourceEntryFree(v23);
        goto LABEL_282;
      }

      *(void *)statfs buf = 0LL;
      if (*Path == 46)
      {
        uint64_t v19 = (uint64_t)Path;
      }

      else if (asprintf((char **)buf, "./%s", Path) == -1 || (uint64_t v19 = *(void *)buf) == 0)
      {
        int v63 = *__error();
        BOMCopierErrorCapture( &v135,  v63,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c",  3194,  (uint64_t)"filter_next_source_entry",  "Could not construct lookup path for skip bom from %s");
        goto LABEL_49;
      }

      BOOL v20 = BOMBomFSObjectExistsAtPath(*(void *)(a1 + 216), v19);
      if (*(void *)buf) {
        free(*(void **)buf);
      }
      if (!v20)
      {
        if (consume_source_entry(filesystem_entry, &v135))
        {
          int v22 = 3216;
          goto LABEL_48;
        }

LABEL_282:
        stat v107 = v135;
        if (v135) {
          goto LABEL_352;
        }
        goto LABEL_283;
      }
    }

    if ((*(_BYTE *)(a1 + 93) || *(_BYTE *)(a1 + 94)) && BOMCopierSourceEntryIsRoot((uint64_t)filesystem_entry))
    {
      int v21 = *(os_log_s **)(a1 + 24);
      if (v21 && os_log_type_enabled(*(os_log_t *)(a1 + 24), OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)statfs buf = 0;
        _os_log_impl(v11, v21, OS_LOG_TYPE_DEFAULT, "Consuming root entry", buf, 2u);
      }

      if (consume_source_entry(filesystem_entry, &v135))
      {
        int v22 = 3240;
LABEL_48:
        BOMCopierErrorCapture( &v135,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c",  v22,  (uint64_t)"filter_next_source_entry",  "Could not consume the source entry",  v129);
        goto LABEL_49;
      }

      goto LABEL_282;
    }

    uint64_t v24 = v11;
    int Type = BOMCopierSourceEntryGetType((uint64_t)filesystem_entry);
    if (*(_BYTE *)(a1 + 96))
    {
      unsigned int v26 = BOMCopierSourceEntryGetType((uint64_t)filesystem_entry);
      if (v26 <= 0xE && ((1 << v26) & 0x6040) != 0)
      {
        char v27 = (const char *)BOMCopierSourceEntryGetPath((uint64_t)filesystem_entry);
        if (v27)
        {
          uint64_t v28 = v27;
          size_t v29 = strlen(v27);
          int v30 = *(unsigned __int8 *)v28;
          size_t v31 = v30 == 46 ? 10LL : 8LL;
          if (v29 >= v31)
          {
            int v32 = v30 == 46 ? "./__MACOSX" : "__MACOSX";
            if (!strncmp(v28, v32, v31))
            {
              uint64_t v66 = *(os_log_s **)(a1 + 24);
              int v11 = v24;
              if (v66 && os_log_type_enabled(*(os_log_t *)(a1 + 24), OS_LOG_TYPE_DEFAULT))
              {
                *(_WORD *)statfs buf = 0;
                _os_log_impl(v24, v66, OS_LOG_TYPE_DEFAULT, "Consuming __MACOSX directory entry", buf, 2u);
              }

              if (consume_source_entry(filesystem_entry, &v135))
              {
                int v22 = 3268;
                goto LABEL_48;
              }

              goto LABEL_282;
            }
          }
        }
      }
    }

    if (*(_BYTE *)(a1 + 95))
    {
      CFTypeID v33 = *(os_log_s **)(a1 + 24);
      if (v33 && os_log_type_enabled(*(os_log_t *)(a1 + 24), OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)statfs buf = 0;
        _os_log_impl(v24, v33, OS_LOG_TYPE_DEFAULT, "Sequestering __MACOSX entry", buf, 2u);
      }

      uint64_t v34 = BOMCopierSourceEntryGetPath((uint64_t)filesystem_entry);
      if (v34)
      {
        size_t v35 = (const char *)v34;
        CFTypeID v36 = *(os_log_s **)(a1 + 24);
        if (v36 && os_log_type_enabled(*(os_log_t *)(a1 + 24), OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)statfs buf = 136315138;
          *(void *)&buf[4] = v35;
          _os_log_impl(v24, v36, OS_LOG_TYPE_DEFAULT, "Sequestering AppleDouble from %s", buf, 0xCu);
        }

        uint64_t v37 = "./__MACOSX";
        if (*(_BYTE *)(a1 + 93)) {
          uint64_t v37 = "__MACOSX";
        }
        uint64_t v38 = &v35[2 * (*v35 == 46)];
        v137 = 0LL;
        if (asprintf(&v137, "%s/%s", v37, v38) != -1 && v137)
        {
          if (BOMCopierSourceEntrySetPath(filesystem_entry, v137))
          {
            BOMCopierErrorCapture( &v135,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c",  4393,  (uint64_t)"sequester_apple_double",  "Could not create set sequester path entry for %s",  v35);
LABEL_269:
            BOMCopierSourceEntryFree(filesystem_entry);
            goto LABEL_270;
          }

          free(v137);
          uint64_t v67 = (const char *)BOMCopierSourceEntryGetPath((uint64_t)filesystem_entry);
          uint64_t v68 = v67;
          v139[0] = 0LL;
          v139[1] = (char *)v139;
          v139[2] = (char *)0x2000000000LL;
          v139[3] = 0LL;
          v138[0] = 0LL;
          v138[1] = v138;
          v138[2] = 0x2000000000LL;
          v138[3] = 0LL;
          *(void *)statfs buf = MEMORY[0x1895F87A8];
          *(void *)&buf[8] = 0x40000000LL;
          *(void *)&buf[16] = __add_sequester_entry_block_invoke;
          uint64_t v142 = &unk_189E3F6B8;
          uint64_t v145 = a1;
          v146 = &v135;
          uint64_t v143 = v139;
          uint64_t v144 = v138;
          int v147 = filesystem_entry;
          if (v67)
          {
            size_t v69 = strlen(v67);
            __s = 0LL;
            if (v69 == asprintf(&__s, "%s", v68))
            {
              uint64_t v70 = __s;
              if (__s)
              {
                int v131 = v68;
                v132 = v8;
                int v71 = strchr(__s, 47);
                uint64_t v72 = v70;
                uint64_t v73 = v70;
                if (v71)
                {
                  while (1)
                  {
                    *int v71 = 0;
                    int v74 = (*(uint64_t (**)(_BYTE *, char *, void))&buf[16])(buf, v72, 0LL);
                    if (v74) {
                      break;
                    }
                    *int v71 = 47;
                    uint64_t v72 = v71 + 1;
                    uint64_t v73 = __s;
                    if (v71 + 1 - __s < v69)
                    {
                      int v71 = strchr(v71 + 1, 47);
                      if (v71) {
                        continue;
                      }
                    }

                    goto LABEL_163;
                  }

                  int v75 = v74;
                  uint64_t v73 = __s;
                }

                else
                {
LABEL_163:
                  if (v72 == &v70[v69]
                    || (int v75 = (*(uint64_t (**)(_BYTE *, char *, uint64_t))&buf[16])(buf, v72, 1LL),
                        uint64_t v73 = __s,
                        !v75))
                  {
                    free(v73);
                    uint64_t v8 = v132;
LABEL_267:
                    _Block_object_dispose(v138, 8);
                    _Block_object_dispose(v139, 8);
                    goto LABEL_281;
                  }
                }

                free(v73);
                BOOL v106 = v75 == -1;
                uint64_t v68 = v131;
                uint64_t v8 = v132;
                if (!v106) {
                  goto LABEL_267;
                }
              }
            }
          }

          BOMCopierErrorCapture( &v135,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c",  4806,  (uint64_t)"add_sequester_entry",  "Could not add sequester entry for %s",  v68);
          _Block_object_dispose(v138, 8);
          _Block_object_dispose(v139, 8);
          BOMCopierErrorCapture( &v135,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c",  4408,  (uint64_t)"sequester_apple_double",  "Could not create set sequester path entry for %s",  v35);
          goto LABEL_269;
        }

        int v64 = *__error();
        uint64_t v65 = __error();
        strerror(*v65);
        BOMCopierErrorCapture( &v135,  v64,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c",  4385,  (uint64_t)"sequester_apple_double",  "Could not create sequester path for %s: %s");
      }

      else
      {
        BOMCopierErrorCapture( &v135,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c",  4359,  (uint64_t)"sequester_apple_double",  "Could not retrieve entry path for AppleDouble entry");
      }

LABEL_270:
      BOMCopierErrorCapture( &v135,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c",  3300,  (uint64_t)"filter_next_source_entry",  "Could not sequester AppleDouble entry",  v130);
      goto LABEL_281;
    }

    uint64_t v39 = v8;
    if (*(_BYTE *)(a1 + 96))
    {
      char v40 = *(os_log_s **)(a1 + 24);
      if (v40 && os_log_type_enabled(*(os_log_t *)(a1 + 24), OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)statfs buf = 0;
        _os_log_impl(v24, v40, OS_LOG_TYPE_DEFAULT, "Unsequestering __MACOSX entry", buf, 2u);
      }

      uint64_t v41 = (const char *)BOMCopierSourceEntryGetPath((uint64_t)filesystem_entry);
      if (v41)
      {
        uint64_t v42 = v41;
        size_t v43 = strlen(v41);
        if (*v42 == 46)
        {
          uint64_t v44 = 0LL;
          size_t v45 = 10LL;
          uint64_t v46 = "./__MACOSX";
          uint64_t v47 = ".";
        }

        else
        {
          size_t v45 = 8LL;
          uint64_t v46 = "__MACOSX";
          uint64_t v47 = "";
          uint64_t v44 = 1LL;
        }

        if (v43 < v45 || strncmp(v42, v46, v45)) {
          goto LABEL_169;
        }
        *(void *)statfs buf = 0LL;
        if (asprintf((char **)buf, "%s%s", v47, &v42[v45 + v44]) == -1 || !*(void *)buf)
        {
          int v99 = *__error();
          uint64_t v100 = __error();
          uint64_t v101 = strerror(*v100);
          BOMCopierErrorCapture( &v135,  v99,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c",  4466,  (uint64_t)"unsequester_apple_double",  "Could not created adjusted path for %s: %s",  v42,  v101);
          uint64_t v8 = v39;
        }

        else
        {
          BOOL v82 = BOMCopierSourceEntrySetPath(filesystem_entry, *(char **)buf);
          free(*(void **)buf);
          if (!v82) {
            goto LABEL_169;
          }
          uint64_t v8 = v39;
          uint64_t v83 = __error();
          strerror(*v83);
          BOMCopierErrorCapture( &v135,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c",  4476,  (uint64_t)"unsequester_apple_double",  "Could not set adjusted path %s: %s");
        }
      }

      else
      {
        BOMCopierErrorCapture( &v135,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c",  4429,  (uint64_t)"unsequester_apple_double",  "Could not retrieve entry path for AppleDouble entry");
      }

      BOMCopierErrorCapture( &v135,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c",  3317,  (uint64_t)"filter_next_source_entry",  "Could not unsequester AppleDouble file");
LABEL_151:
      BOMCopierSourceEntryFree(filesystem_entry);
      goto LABEL_281;
    }

LABEL_169:
    uint64_t v8 = v39;
    if (*(_BYTE *)(a1 + 71))
    {
      int v76 = *(os_log_s **)(a1 + 24);
      int v11 = v24;
      if (v76 && os_log_type_enabled(*(os_log_t *)(a1 + 24), OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)statfs buf = 0;
        _os_log_impl(v24, v76, OS_LOG_TYPE_DEFAULT, "Deferring AppleDouble entry", buf, 2u);
      }

      if (push_replay_stack((void *)a1, (uint64_t)filesystem_entry, 2, &v135))
      {
        BOMCopierErrorCapture( &v135,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c",  3331,  (uint64_t)"filter_next_source_entry",  "Could not push AppleDouble onto the replay stack",  v129);
        goto LABEL_49;
      }

      goto LABEL_282;
    }

    if (*(void *)(a1 + 80))
    {
      uint64_t v77 = (const char *)BOMCopierSourceEntryGetPath((uint64_t)filesystem_entry);
      v139[0] = 0LL;
      asprintf(v139, "%s%s", v77, *(const char **)(a1 + 80));
      uint64_t v78 = v139[0];
      if (!v139[0])
      {
        uint64_t v84 = __error();
        strerror(*v84);
        BOMCopierErrorCapture( &v135,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c",  3353,  (uint64_t)"filter_next_source_entry",  "Could not constructed adjusted AppleDouble path: %s");
        goto LABEL_281;
      }

      CFTypeID v79 = *(os_log_s **)(a1 + 24);
      if (v79 && os_log_type_enabled(*(os_log_t *)(a1 + 24), OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v80 = *(void *)(a1 + 80);
        *(_DWORD *)statfs buf = 136315394;
        *(void *)&buf[4] = v80;
        *(_WORD *)&buf[12] = 2080;
        *(void *)&buf[14] = v77;
        _os_log_impl(v24, v79, OS_LOG_TYPE_DEFAULT, "Appending suffix %s to %s", buf, 0x16u);
        uint64_t v78 = v139[0];
      }

      if (BOMCopierSourceEntrySetPath(filesystem_entry, v78))
      {
        BOMCopierErrorCapture( &v135,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c",  3362,  (uint64_t)"filter_next_source_entry",  "Could not set appended entry path for AppleDouble file",  v129);
        goto LABEL_281;
      }

      free(v139[0]);
    }

    if (Type == 8)
    {
      if (*(_BYTE *)(a1 + 72))
      {
        __int16 v85 = *(os_log_s **)(a1 + 24);
        if (v85 && os_log_type_enabled(*(os_log_t *)(a1 + 24), OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)statfs buf = 0;
          _os_log_impl(v24, v85, OS_LOG_TYPE_DEFAULT, "Synthesizing AppleDouble replay entry", buf, 2u);
        }

        if (synthesize_replay_apple_double(a1, filesystem_entry, &v135))
        {
          BOMCopierErrorCapture( &v135,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c",  3382,  (uint64_t)"filter_next_source_entry",  "Could not replay AppleDouble file");
          goto LABEL_151;
        }
      }

      goto LABEL_219;
    }

        if (*(_BYTE *)(a1 + 168) == 1)
        {
          int v99 = *(os_log_s **)(a1 + 13000);
          if (v99 && os_log_type_enabled(*(os_log_t *)(a1 + 13000), OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)v109 = 0;
            uint64_t v100 = "Client cancelled";
            goto LABEL_272;
          }

          goto LABEL_273;
        }

        if (v8[1025] == 1)
        {
          uint64_t v68 = (const char *)BOMCopierSourceEntryGetPath((uint64_t)v55);
          if (!v68)
          {
            uint64_t v14 = 1LL;
            BOMCopierErrorCapture( &v108,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c",  460,  (uint64_t)"BOMCopierCopyWithOptions2",  "Could not get path for redirected source entry",  v103,  v106);
            goto LABEL_226;
          }

          size_t v69 = strdup(v68);
          if (!v69)
          {
            uint64_t v14 = 1LL;
            BOMCopierErrorCapture( &v108,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c",  468,  (uint64_t)"BOMCopierCopyWithOptions2",  "Could not duplicate path for redirected source entry",  v103,  v106);
            goto LABEL_226;
          }

          uint64_t v70 = v69;
          BOMCopierSourceEntryFree(v55);
          if (BOMCopierSourceSetRedirectCallback( *(void *)(a1 + 13016),  (uint64_t)source_redirection_callback,  a1,  &v108))
          {
            uint64_t v14 = 1LL;
            BOMCopierErrorCapture( &v108,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c",  478,  (uint64_t)"BOMCopierCopyWithOptions2",  "Could not set source redirect callback",  v103,  v106);
            goto LABEL_268;
          }

          uint64_t v77 = BOMCopierSourceNext(*(void *)(a1 + 13016), &v108, v71, v72, v73, v74, v75, v76);
          __int16 v55 = (unsigned int *)v77;
          if (v108)
          {
            if (v77) {
              BOMCopierSourceEntryFree((unsigned int *)v77);
            }
            uint64_t v14 = 1LL;
            BOMCopierErrorCapture( &v108,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c",  493,  (uint64_t)"BOMCopierCopyWithOptions2",  "Could not copy from %s to %s: %s",  a2);
LABEL_268:
            free(v70);
LABEL_226:
            notify_fatal_error(a1, v108);
            goto LABEL_227;
          }

          if (!v77)
          {
            free(v70);
            goto LABEL_258;
          }

          if (BOMCopierSourceEntrySetPath(v77, v70))
          {
            uint64_t v14 = 1LL;
            BOMCopierErrorCapture( &v108,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c",  510,  (uint64_t)"BOMCopierCopyWithOptions2",  "Could not set the saved entry path");
            goto LABEL_268;
          }

          free(v70);
        }

        if (*v8 != 1) {
          goto LABEL_183;
        }
        if (BOMCopierDestinationSetRedirectCallback( *(void *)(a1 + 13032),  (uint64_t)destination_redirection_callback,  a1,  &v108))
        {
          uint64_t v14 = 1LL;
          BOMCopierErrorCapture( &v108,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c",  530,  (uint64_t)"BOMCopierCopyWithOptions2",  "Could not set destination redirect callback");
          notify_fatal_error(a1, v108);
          goto LABEL_253;
        }

        uint64_t v78 = *(os_log_s **)(a1 + 13000);
        if (v78)
        {
          if (os_log_type_enabled(*(os_log_t *)(a1 + 13000), OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)v109 = 0;
            _os_log_impl(&dword_1862F3000, v78, OS_LOG_TYPE_DEFAULT, "Set destination redirect callback", v109, 2u);
LABEL_183:
            uint64_t v78 = *(os_log_s **)(a1 + 13000);
            if (!v78) {
              goto LABEL_186;
            }
          }

          if (os_log_type_enabled(v78, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)v109 = 0;
            _os_log_impl( &dword_1862F3000,  v78,  OS_LOG_TYPE_DEFAULT,  "Copying source entry to destination set",  v109,  2u);
          }
        }

LABEL_203:
    if (*(_BYTE *)(a1 + 91) && Type == 9)
    {
      char v86 = *(os_log_s **)(a1 + 24);
      if (v86 && os_log_type_enabled(*(os_log_t *)(a1 + 24), OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)statfs buf = 0;
        _os_log_impl(v24, v86, OS_LOG_TYPE_DEFAULT, "Synthesizing replay symlink entry", buf, 2u);
      }

      uint64_t v87 = (char *)BOMCopierSourceEntryGetPath((uint64_t)filesystem_entry);
      SymlinkTarget = (char *)BOMCopierSourceEntryGetSymlinkTarget((uint64_t)filesystem_entry);
      size_t v89 = strlen(SymlinkTarget);
      uint64_t v90 = (uint64_t *)BOMCopierSourceEntryNew(8, &v135);
      if (v90)
      {
        char v91 = v90;
        if (BOMCopierSourceEntrySetPath(v90, v87))
        {
          BOMCopierErrorCapture( &v135,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c",  4115,  (uint64_t)"synthesize_replay_symlink",  "Could not set the path for the regular file entry");
LABEL_279:
          CFIndex v96 = (unsigned int *)v91;
          goto LABEL_280;
        }

        if (BOMCopierSourceEntrySetData((uint64_t)v91, SymlinkTarget, v89))
        {
          BOMCopierErrorCapture( &v135,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c",  4123,  (uint64_t)"synthesize_replay_symlink",  "Could not set the data for the regular file entry");
          goto LABEL_279;
        }

        if (copy_entry_metadata((uint64_t)filesystem_entry, (uint64_t)v91, &v135))
        {
          BOMCopierErrorCapture( &v135,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c",  4131,  (uint64_t)"synthesize_replay_symlink",  "Could not copy metadata from the symlink entry to its regular file doppleganger");
          goto LABEL_279;
        }

        if (BOMCopierSourceEntrySetMode((uint64_t)v91, 33188))
        {
          BOMCopierErrorCapture( &v135,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c",  4139,  (uint64_t)"synthesize_replay_symlink",  "Could not set the mode for the regular file entry");
          goto LABEL_279;
        }

        uint64_t v102 = BOMCopierSourceEntryNew(18, &v135);
        if (!v102)
        {
          BOMCopierErrorCapture( &v135,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c",  4155,  (uint64_t)"synthesize_replay_symlink",  "Could create a post order symlink entry");
          goto LABEL_279;
        }

        uint64_t v103 = (uint64_t)v102;
        if (BOMCopierSourceEntrySetPath(v102, v87))
        {
          int v104 = 4163;
LABEL_258:
          BOMCopierErrorCapture( &v135,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c",  v104,  (uint64_t)"synthesize_replay_symlink",  "Could not set the path for the post order symlink entry");
          goto LABEL_279;
        }

        if (copy_entry_metadata((uint64_t)filesystem_entry, v103, &v135))
        {
          BOMCopierErrorCapture( &v135,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c",  4171,  (uint64_t)"synthesize_replay_symlink",  "Could not copy metadata from the symlink entry to its replay symlink");
          goto LABEL_279;
        }

        if (BOMCopierSourceEntrySetSymlinkTarget(v103, SymlinkTarget))
        {
          int v104 = 4179;
          goto LABEL_258;
        }

        if (push_replay_stack((void *)a1, v103, 1, &v135))
        {
          BOMCopierErrorCapture( &v135,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c",  4187,  (uint64_t)"synthesize_replay_symlink",  "Could not push the synthetic post-order symlink");
          goto LABEL_279;
        }

        AAByteStream v126 = *(os_log_s **)(a1 + 24);
        if (v126 && os_log_type_enabled(*(os_log_t *)(a1 + 24), OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)statfs buf = 136315138;
          *(void *)&buf[4] = v87;
          _os_log_impl(v24, v126, OS_LOG_TYPE_DEFAULT, "Synthesizing replay symlink from %s", buf, 0xCu);
        }

        BOMCopierErrorCapture( &v135,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c",  4202,  (uint64_t)"synthesize_replay_symlink",  "Could not consume the symlink entry");
        CFIndex v96 = filesystem_entry;
      }

      else
      {
        BOMCopierErrorCapture( &v135,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c",  4107,  (uint64_t)"synthesize_replay_symlink",  "Could create a regular file entry");
        CFIndex v96 = 0LL;
      }

                if (set_timestamps(v7, a2, *(os_log_s **)a1, a3))
                {
                  CFTypeID v36 = 1LL;
                  BOMCopierErrorCapture( a3,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  6192,  (uint64_t)"finalize_entry_filesystem",  "Could not set timestamps on destination entry");
                  return v36;
                }

                break;
              default:
                BOMCopierSourceEntryTypeString(v175);
                BOMCopierErrorCapture( a3,  45,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  6176,  (uint64_t)"finalize_entry_filesystem",  "Unsupported BOMCopierSourceEntryType: %s");
                return 1LL;
            }

            return 0LL;
          }

          v116 = Mode;
          if (!v153)
          {
LABEL_152:
            if (v115) {
              uint32_t v117 = v116 & 0xFFB6;
            }
            else {
              uint32_t v117 = v116;
            }
            if (Mode != v117)
            {
              v198 = 0u;
              memset(v199, 0, sizeof(v199));
              v196 = 0u;
              v197 = 0u;
              v194 = 0u;
              v195 = 0u;
              memset(&v193, 0, sizeof(v193));
              strmode(Mode, (char *)&v193);
              v191 = 0u;
              memset(v192, 0, sizeof(v192));
              v189 = 0u;
              v190 = 0u;
              v187 = 0u;
              v188 = 0u;
              v185 = 0u;
              v186 = 0u;
              v184 = 0u;
              v182 = 0u;
              v183 = 0u;
              v180 = 0u;
              v181 = 0u;
              memset(__bp, 0, sizeof(__bp));
              strmode(v117, __bp);
              int v118 = *(os_log_s **)a1;
              if (*(void *)a1 && os_log_type_enabled(*(os_log_t *)a1, OS_LOG_TYPE_DEFAULT))
              {
                v119 = *(void *)(a2 + 120);
                *(_DWORD *)statfs buf = 136315650;
                *(void *)&buf[4] = v119;
                *(_WORD *)&buf[12] = 2080;
                *(void *)&buf[14] = &v193;
                *(_WORD *)&buf[22] = 2080;
                uint64_t v178 = __bp;
                _os_log_impl( &dword_1862F3000,  v118,  OS_LOG_TYPE_DEFAULT,  "Filtering the mode for %s from %s to %s",  buf,  0x20u);
              }

              LOWORD(Mode) = v117;
            }

            goto LABEL_160;
          }
        }

        v116 = Mode & 0xF1FF;
        goto LABEL_152;
      }

      char v59 = *__error();
      unsigned __int8 v60 = __error();
      strerror(*v60);
      BOMCopierErrorCapture( a3,  v59,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  5724,  (uint64_t)"finalize_entry_filesystem",  "Could not set rootless xattr %s: %s");
LABEL_68:
      uint64_t v61 = (char *)v58;
LABEL_180:
      free(v61);
      return 1LL;
    case 0x13u:
      if (!*(_DWORD *)(a1 + 8))
      {
        size_t v31 = BOMCopierSourceEntryGetUserID(v7);
        int v32 = BOMCopierSourceEntryGetGroupID(v7);
        if (chown(*(const char **)(a2 + 120), v31, v32))
        {
          CFTypeID v33 = *__error();
          uint64_t v34 = *(void *)(a2 + 120);
          size_t v35 = __error();
          strerror(*v35);
          BOMCopierErrorCapture( a3,  v33,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  5546,  (uint64_t)"finalize_entry_filesystem",  "Could not chown %s to %d:%d: %s",  v34,  v31);
          return 1LL;
        }
      }

      BOOL v20 = BOMCopierSourceEntryGetMode(v7);
      if ((*(_DWORD *)(a1 + 8)
         || *(_BYTE *)(a1 + 305)
         || *(_BYTE *)(a1 + 20) && (BOMCopierSourceEntryGetHonorsSetuid(v7) & 1) == 0)
        && (v20 & 0xE00) != 0)
      {
        int v21 = v20 & 0xF1FF;
        v198 = 0u;
        memset(v199, 0, sizeof(v199));
        v196 = 0u;
        v197 = 0u;
        v194 = 0u;
        v195 = 0u;
        memset(&v193, 0, sizeof(v193));
        strmode(v20, (char *)&v193);
        v191 = 0u;
        memset(v192, 0, sizeof(v192));
        v189 = 0u;
        v190 = 0u;
        v187 = 0u;
        v188 = 0u;
        v185 = 0u;
        v186 = 0u;
        v184 = 0u;
        v182 = 0u;
        v183 = 0u;
        v180 = 0u;
        v181 = 0u;
        memset(__bp, 0, sizeof(__bp));
        strmode(v20 & 0xF1FF, __bp);
        int v22 = *(os_log_s **)a1;
        if (*(void *)a1 && os_log_type_enabled(*(os_log_t *)a1, OS_LOG_TYPE_DEFAULT))
        {
          char v23 = *(void *)(a2 + 120);
          *(_DWORD *)statfs buf = 136315650;
          *(void *)&buf[4] = v23;
          *(_WORD *)&buf[12] = 2080;
          *(void *)&buf[14] = &v193;
          *(_WORD *)&buf[22] = 2080;
          uint64_t v178 = __bp;
          _os_log_impl( &dword_1862F3000,  v22,  OS_LOG_TYPE_DEFAULT,  "Filtering the mode for %s from %s to %s",  buf,  0x20u);
        }

        LOWORD(v20) = v21;
      }

      if (chmod(*(const char **)(a2 + 120), v20))
      {
        v198 = 0u;
        memset(v199, 0, sizeof(v199));
        v196 = 0u;
        v197 = 0u;
        v194 = 0u;
        v195 = 0u;
        memset(&v193, 0, sizeof(v193));
        strmode((unsigned __int16)v20, (char *)&v193);
        uint64_t v24 = *__error();
        uint64_t v25 = *(void *)(a2 + 120);
        unsigned int v26 = __error();
        strerror(*v26);
        BOMCopierErrorCapture( a3,  v24,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  5613,  (uint64_t)"finalize_entry_filesystem",  "Could not chmod relay directory %s to %s: %s",  v25);
        return 1LL;
      }

      CFTypeID v36 = 1LL;
      BOMCopierErrorCapture( a3,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  5628,  (uint64_t)"finalize_entry_filesystem",  "Could not set timestamps on destination entry");
      return v36;
    default:
      goto LABEL_51;
  }

LABEL_280:
      BOMCopierSourceEntryFree(v96);
      BOMCopierErrorCapture( &v135,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c",  3411,  (uint64_t)"filter_next_source_entry",  "Could not synthesize replay symlink",  v129);
      goto LABEL_281;
    }

    if (!*(_BYTE *)(a1 + 92) || Type != 6)
    {
LABEL_219:
      char v91 = (uint64_t *)filesystem_entry;
LABEL_220:
      if (!*(_BYTE *)(a1 + 89)
        || (int v95 = BOMCopierSourceEntryGetType((uint64_t)v91), v95 != 14)
        && v95 != 16
        && (v95 != 15 || !is_apple_double(v91)))
      {
LABEL_246:
        int v11 = v24;
LABEL_302:
        if (!*(_BYTE *)(a1 + 265)) {
          return v91;
        }
        v113 = (const char *)BOMCopierSourceEntryGetPath((uint64_t)v91);
        v114 = v113;
        v115 = *(void **)(a1 + 272);
        if (v115)
        {
          if (!strcmp(v113, *(const char **)(a1 + 272)))
          {
            v116 = *(os_log_s **)(a1 + 24);
            if (v116 && os_log_type_enabled(*(os_log_t *)(a1 + 24), OS_LOG_TYPE_DEFAULT))
            {
              *(_WORD *)statfs buf = 0;
              _os_log_impl(v11, v116, OS_LOG_TYPE_DEFAULT, "Marking segmented file entry", buf, 2u);
            }

            BOMCopierSourceEntrySetSegmentedFile((uint64_t)v91, 1);
            v115 = *(void **)(a1 + 272);
          }

          free(v115);
        }

        uint32_t v117 = strdup(v114);
        *(void *)(a1 + 272) = v117;
        if (v117) {
          return v91;
        }
        int v118 = *__error();
        v119 = __error();
        v120 = strerror(*v119);
        BOMCopierErrorCapture( &v134,  v118,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c",  2493,  (uint64_t)"next_source_entry",  "Could not duplicate entry path: %s",  v120);
        BOMCopierSourceEntryFree((unsigned int *)v91);
        goto LABEL_318;
      }

      switch(Type)
      {
        case 16:
          int v11 = v24;
          if (push_replay_stack((void *)a1, (uint64_t)v91, 1, &v135)) {
            BOMCopierErrorCapture( &v135,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c",  3486,  (uint64_t)"filter_next_source_entry",  "Could not push the extra symlink entry onto the replay stack");
          }
          goto LABEL_282;
        case 15:
          if (!*(_BYTE *)(a1 + 90)) {
            goto LABEL_246;
          }
          uint64_t v98 = *(os_log_s **)(a1 + 24);
          int v11 = v24;
          if (v98 && os_log_type_enabled(*(os_log_t *)(a1 + 24), OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)statfs buf = 0;
            _os_log_impl( v24,  v98,  OS_LOG_TYPE_DEFAULT,  "Synthesizing AppleDouble replay entry from extra AppleDouble entry",  buf,  2u);
          }

          if (synthesize_replay_apple_double(a1, v91, &v135))
          {
            BOMCopierErrorCapture( &v135,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c",  3503,  (uint64_t)"filter_next_source_entry",  "Could not replay AppleDouble file");
          }

          else
          {
            __int128 v105 = *(os_log_s **)(a1 + 24);
            if (v105 && os_log_type_enabled(*(os_log_t *)(a1 + 24), OS_LOG_TYPE_DEFAULT))
            {
              *(_WORD *)statfs buf = 0;
              _os_log_impl(v24, v105, OS_LOG_TYPE_DEFAULT, "Consuming extra AppleDouble entry", buf, 2u);
            }

            BOMCopierErrorCapture( &v135,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c",  3513,  (uint64_t)"filter_next_source_entry",  "Could not consume the source entry");
          }

          char v23 = (unsigned int *)v91;
          goto LABEL_50;
        case 14:
          int v11 = v24;
          if (push_replay_stack((void *)a1, (uint64_t)v91, 3, &v135)) {
            BOMCopierErrorCapture( &v135,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c",  3473,  (uint64_t)"filter_next_source_entry",  "Could not push the extra directory entry onto the replay stack");
          }
          goto LABEL_282;
      }

      BOMCopierErrorCapture( &v135,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c",  3525,  (uint64_t)"filter_next_source_entry",  "Cannot convert %u to replay entry");
LABEL_281:
      int v11 = v24;
      goto LABEL_282;
    }

    uint64_t v92 = *(os_log_s **)(a1 + 24);
    if (v92 && os_log_type_enabled(*(os_log_t *)(a1 + 24), OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)statfs buf = 0;
      _os_log_impl(v24, v92, OS_LOG_TYPE_DEFAULT, "Synthesizing replay directory entry", buf, 2u);
    }

    uint64_t v93 = (char *)BOMCopierSourceEntryGetPath((uint64_t)filesystem_entry);
    uint64_t v94 = (uint64_t *)BOMCopierSourceEntryNew(6, &v135);
    if (v94)
    {
      char v91 = v94;
      if (BOMCopierSourceEntrySetPath(v94, v93))
      {
        BOMCopierErrorCapture( &v135,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c",  4239,  (uint64_t)"synthesize_replay_directory",  "Could not set the path for the directory entry");
      }

      else if (copy_entry_metadata((uint64_t)filesystem_entry, (uint64_t)v91, &v135))
      {
        BOMCopierErrorCapture( &v135,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c",  4248,  (uint64_t)"synthesize_replay_directory",  "Could not copy metadata from the source entry to its directory doppleganger");
      }

      else if (BOMCopierSourceEntrySetMode((uint64_t)v91, 16877))
      {
        BOMCopierErrorCapture( &v135,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c",  4257,  (uint64_t)"synthesize_replay_directory",  "Could not set the mode for the directory entry");
      }

      else if (BOMCopierSourceEntrySetUserID((uint64_t)v91, *(_DWORD *)(a1 + 32)))
      {
        BOMCopierErrorCapture( &v135,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c",  4266,  (uint64_t)"synthesize_replay_directory",  "Could not set the user ID for the directory entry");
      }

      else if (BOMCopierSourceEntrySetGroupID((uint64_t)v91, *(_DWORD *)(a1 + 36)))
      {
        BOMCopierErrorCapture( &v135,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c",  4275,  (uint64_t)"synthesize_replay_directory",  "Could not set the group ID for the directory entry");
      }

      else
      {
        uint64_t v124 = BOMCopierSourceEntryNew(19, &v135);
        if (v124)
        {
          int v125 = v124;
          if (BOMCopierSourceEntrySetPath(v124, v93))
          {
            BOMCopierErrorCapture( &v135,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c",  4300,  (uint64_t)"synthesize_replay_directory",  "Could not copy entry path from the source entry to its replay directory");
          }

          else if (copy_entry_metadata((uint64_t)filesystem_entry, (uint64_t)v125, &v135))
          {
            BOMCopierErrorCapture( &v135,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c",  4310,  (uint64_t)"synthesize_replay_directory",  "Could not copy metadata from the source entry to its replay directory");
          }

          else
          {
            if (!push_replay_stack((void *)a1, (uint64_t)v125, 3, &v135))
            {
              v127 = *(os_log_s **)(a1 + 24);
              if (v127 && os_log_type_enabled(*(os_log_t *)(a1 + 24), OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)statfs buf = 136315138;
                *(void *)&buf[4] = v93;
                _os_log_impl(v24, v127, OS_LOG_TYPE_DEFAULT, "Synthesized replay directory from %s", buf, 0xCu);
              }

              BOMCopierErrorCapture( &v135,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c",  4337,  (uint64_t)"synthesize_replay_directory",  "Could not consume the source entry");
LABEL_275:
              BOMCopierSourceEntryFree(filesystem_entry);
              BOMCopierErrorCapture( &v135,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c",  3440,  (uint64_t)"filter_next_source_entry",  "Could not synthesize replay directory",  v129);
              goto LABEL_281;
            }

            BOMCopierErrorCapture( &v135,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c",  4320,  (uint64_t)"synthesize_replay_directory",  "Could not push the synthetic replay directory onto the replay stack");
          }

          BOMCopierSourceEntryFree(v125);
        }

        else
        {
          BOMCopierErrorCapture( &v135,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c",  4291,  (uint64_t)"synthesize_replay_directory",  "Could not create BOMCopierSourceEntry for replay directory");
        }
      }

      uint64_t v97 = (unsigned int *)v91;
    }

    else
    {
      BOMCopierErrorCapture( &v135,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c",  4230,  (uint64_t)"synthesize_replay_directory",  "Could create a directory entry");
      uint64_t v97 = 0LL;
    }

    BOMCopierSourceEntryFree(v97);
    goto LABEL_275;
  }

  BOMCopierErrorCapture( a2,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c",  1471,  (uint64_t)"BOMCopierSourceNext",  "copier_source is NULL");
  return 0LL;
}

uint64_t next_filesystem_entry(uint64_t a1, char *a2, _BYTE *a3, uint64_t *a4)
{
  uint64_t v36 = *MEMORY[0x1895F89C0];
  uint64_t v6 = *(FTS **)(a1 + 152);
  if (!v6)
  {
    BOMCopierErrorCapture( a4,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c",  2519,  (uint64_t)"next_filesystem_entry",  "The BOMCopierSource does not have an open FTS handle");
    return 0LL;
  }

  char v8 = *(_BYTE *)(a1 + 64) == 0;
  if (*(_BYTE *)(a1 + 360)) {
    v8 |= 2u;
  }
  if (*(_BYTE *)(a1 + 361)) {
    v8 |= 8u;
  }
  if (*(_BYTE *)(a1 + 362)) {
    v8 |= 4u;
  }
  if (*(_BYTE *)(a1 + 363)) {
    v8 |= 0x10u;
  }
  if (*(_BYTE *)(a1 + 364)) {
    v8 |= 0x20u;
  }
  if (*(_BYTE *)(a1 + 365)) {
    char v9 = v8 | 0x40;
  }
  else {
    char v9 = v8;
  }
  if (a2)
  {
    uint64_t v10 = (unsigned int *)BOMCopierSourceEntryNewFromPath(a2, v9, a4);
    if (!v10)
    {
      BOMCopierErrorCapture( a4,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c",  2574,  (uint64_t)"next_filesystem_entry",  "Could not create BOMCopierSourceEntry from redirect path %s",  a2);
      return (uint64_t)v10;
    }

    if (synthesize_filesystem_stuff())
    {
      BOMCopierErrorCapture( a4,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c",  2582,  (uint64_t)"next_filesystem_entry",  "Could not synthesize filesystem stuff");
LABEL_19:
      int v11 = v10;
LABEL_20:
      BOMCopierSourceEntryFree(v11);
      return 0LL;
    }

    uint64_t v18 = *(os_log_s **)(a1 + 24);
    if (v18 && os_log_type_enabled(*(os_log_t *)(a1 + 24), OS_LOG_TYPE_DEFAULT))
    {
      v35.f_bsize = 136315138;
      *(void *)&v35.f_iosize = a2;
      _os_log_impl( &dword_1862F3000,  v18,  OS_LOG_TYPE_DEFAULT,  "Entry created from redirect path %s",  (uint8_t *)&v35,  0xCu);
    }
  }

  else
  {
    uint64_t v14 = fts_read(v6);
    if (v14)
    {
      uint64_t v15 = (uint64_t)v14;
      if (v14->fts_statp->st_dev != *(_DWORD *)(a1 + 164))
      {
        bzero(&v35, 0x878uLL);
        if (statfs(*(const char **)(v15 + 48), &v35))
        {
          int v16 = *__error();
          int64_t v17 = __error();
          strerror(*v17);
          BOMCopierErrorCapture( a4,  v16,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c",  2627,  (uint64_t)"next_filesystem_entry",  "Could not statfs %s: %s");
          return 0LL;
        }

        *(_BYTE *)(a1 + 168) = (v35.f_flags & 8) == 0;
        *(_DWORD *)(a1 + 164) = **(_DWORD **)(v15 + 96);
      }

      BOOL v20 = *(os_log_s **)(a1 + 24);
      if (v20 && os_log_type_enabled(*(os_log_t *)(a1 + 24), OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(v35.f_bsize) = 0;
        _os_log_impl( &dword_1862F3000,  v20,  OS_LOG_TYPE_DEFAULT,  "Creating source entry from FTS entry",  (uint8_t *)&v35,  2u);
      }

      uint64_t v21 = BOMCopierSourceEntryNewFromFTSENT(v15, v9, a4);
      if (!v21)
      {
        if (*(void *)a1)
        {
          uint64_t v22 = *(void *)(v15 + 48);
          *(void *)&v35.f_bsize = 0LL;
          v35.f_blocks = v22;
          v35.f_bfree = 0LL;
          LODWORD(v35.f_bfree) = *__error();
          if (a4)
          {
            uint64_t v23 = *a4;
            *(void *)&v35.f_bsize = v23;
            if (v23) {
              LODWORD(v35.f_bfree) = BOMCopierErrorGetCode(v23);
            }
          }

          uint64_t v24 = *(os_log_s **)(a1 + 24);
          if (v24 && os_log_type_enabled(*(os_log_t *)(a1 + 24), OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)statfs buf = 0;
            _os_log_impl( &dword_1862F3000,  v24,  OS_LOG_TYPE_DEFAULT,  "Could not create FTS entry. Calling error handler",  buf,  2u);
          }

          *(_DWORD *)(a1 + 16) = (*(uint64_t (**)(uint64_t, void, statfs *))a1)( a1,  *(void *)(a1 + 8),  &v35);
        }

        BOMCopierErrorCapture( a4,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c",  2676,  (uint64_t)"next_filesystem_entry",  "Could not create BOMCopierSourceEntry from FTS entry");
        return 0LL;
      }

      uint64_t v10 = (unsigned int *)v21;
      BOMCopierSourceEntrySetHonorsSetuid(v21, *(_BYTE *)(a1 + 168));
      if (*(_WORD *)(v15 + 86))
      {
        if (adjust_filesystem_entry_path(a1, v15, v10, a4))
        {
          BOMCopierErrorCapture( a4,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c",  2780,  (uint64_t)"next_filesystem_entry",  "Could not adjust entry path");
          goto LABEL_19;
        }

        if (!*(_BYTE *)(a1 + 88) || !is_apple_double(v10))
        {
          BOMCopierErrorCapture( a4,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c",  2812,  (uint64_t)"next_filesystem_entry",  "Could not synthesize filesystem stuff");
          goto LABEL_19;
        }

        uint64_t v28 = *(os_log_s **)(a1 + 24);
        if (v28 && os_log_type_enabled(*(os_log_t *)(a1 + 24), OS_LOG_TYPE_DEFAULT))
        {
          LOWORD(v35.f_bsize) = 0;
          _os_log_impl(&dword_1862F3000, v28, OS_LOG_TYPE_DEFAULT, "Consuming AppleDouble entry", (uint8_t *)&v35, 2u);
        }

        if (consume_source_entry(v10, a4))
        {
          BOMCopierErrorCapture( a4,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c",  2796,  (uint64_t)"next_filesystem_entry",  "Could not consume the source entry");
          goto LABEL_19;
        }

        CFTypeID v33 = *(os_log_s **)(a1 + 24);
        if (v33 && os_log_type_enabled(*(os_log_t *)(a1 + 24), OS_LOG_TYPE_DEFAULT))
        {
          LOWORD(v35.f_bsize) = 0;
          _os_log_impl(&dword_1862F3000, v33, OS_LOG_TYPE_DEFAULT, "Ignored AppleDouble", (uint8_t *)&v35, 2u);
        }

        return next_filesystem_entry(a1, 0LL, a3, a4);
      }

      else
      {
        if (*(_BYTE *)(a1 + 376))
        {
          uint64_t v25 = *(os_log_s **)(a1 + 24);
          if (v25 && os_log_type_enabled(*(os_log_t *)(a1 + 24), OS_LOG_TYPE_DEFAULT))
          {
            LOWORD(v35.f_bsize) = 0;
            _os_log_impl( &dword_1862F3000,  v25,  OS_LOG_TYPE_DEFAULT,  "Synthesizing parent entry from FTS root entry",  (uint8_t *)&v35,  2u);
          }

          unsigned int v26 = (unsigned int *)BOMCopierSourceEntryNewFromFTSENT(v15, v9, a4);
          if (!v26)
          {
            BOMCopierErrorCapture( a4,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c",  2702,  (uint64_t)"next_filesystem_entry",  "Could not create parent from FTS entry");
            goto LABEL_19;
          }

          char v27 = v26;
          if (adjust_filesystem_entry_path(a1, v15, v26, a4))
          {
            BOMCopierErrorCapture( a4,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c",  2711,  (uint64_t)"next_filesystem_entry",  "Could not adjust entry path");
            int v11 = v27;
            goto LABEL_20;
          }
        }

        else
        {
          char v27 = 0LL;
        }

        int v29 = *(unsigned __int16 *)(v15 + 88);
        if (v29 == 6 || v29 == 1)
        {
          int v30 = ".";
        }

        else
        {
          memset(&v35, 0, 255);
          basename_r(*(const char **)(v15 + 48), (char *)&v35);
          int v30 = (char *)&v35;
        }

        BOMCopierSourceEntrySetPath(v10, v30);
        BOMCopierSourceEntrySetRoot((uint64_t)v10, 1);
        if (v27)
        {
          int v31 = *(unsigned __int16 *)(v15 + 88);
          int v32 = *(os_log_s **)(a1 + 24);
          if (v31 == 1)
          {
            if (v32 && os_log_type_enabled(*(os_log_t *)(a1 + 24), OS_LOG_TYPE_DEFAULT))
            {
              LOWORD(v35.f_bsize) = 0;
              _os_log_impl( &dword_1862F3000,  v32,  OS_LOG_TYPE_DEFAULT,  "Pushing entry onto the pre-empt stack",  (uint8_t *)&v35,  2u);
            }

            BOMCopierErrorCapture( a4,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c",  2751,  (uint64_t)"next_filesystem_entry",  "Could not push parent entry onto the preempty stack");
          }

          else
          {
            if (v32 && os_log_type_enabled(*(os_log_t *)(a1 + 24), OS_LOG_TYPE_DEFAULT))
            {
              LOWORD(v35.f_bsize) = 0;
              _os_log_impl( &dword_1862F3000,  v32,  OS_LOG_TYPE_DEFAULT,  "Pushing root entry onto the pre-empt stack",  (uint8_t *)&v35,  2u);
            }

            BOMCopierErrorCapture( a4,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c",  2764,  (uint64_t)"next_filesystem_entry",  "Could not push parent entry onto the preempty stack");
          }

          BOMCopierSourceEntryFree(v27);
          goto LABEL_19;
        }
      }
    }

    else
    {
      fts_close(*(FTS **)(a1 + 152));
      *(void *)(a1 + 152) = 0LL;
      free(*(void **)(a1 + 128));
      *(void *)(a1 + 128) = 0LL;
      uint64_t v19 = *(os_log_s **)(a1 + 24);
      if (v19 && os_log_type_enabled(*(os_log_t *)(a1 + 24), OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(v35.f_bsize) = 0;
        _os_log_impl(&dword_1862F3000, v19, OS_LOG_TYPE_DEFAULT, "FTS exhausted", (uint8_t *)&v35, 2u);
      }

      uint64_t v10 = 0LL;
      *a3 = 1;
    }
  }

  return (uint64_t)v10;
}

uint64_t next_data_archive_entry( uint64_t a1, _BYTE *a2, void *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v26 = *MEMORY[0x1895F89C0];
  uint64_t v10 = *(void *)(a1 + 280);
  if (!v10)
  {
    BOMCopierErrorCapture( a3,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c",  3042,  (uint64_t)"next_data_archive_entry",  "copier_source->data_archive is NULL");
    return 0LL;
  }

  if (*(_BYTE *)(a1 + 360)) {
    __int16 v12 = (*(unsigned __int8 *)(a1 + 264) << 9) | 2;
  }
  else {
    __int16 v12 = *(unsigned __int8 *)(a1 + 264) << 9;
  }
  uint64_t v21 = 0LL;
  int32_t v13 = data_archive_read_entry(v10, &v21, (uint64_t)a3, a4, a5, a6, a7, a8);
  if (!v13)
  {
    BOMCopierErrorCapture( a3,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c",  3064,  (uint64_t)"next_data_archive_entry",  "Could not read next data_archive entry: %s",  *((const char **)v21 + 4));
    release_error(v21);
    return 0LL;
  }

  uint64_t v14 = v13;
  unsigned int type = data_archive_entry_get_type(v13);
  int v16 = *(os_log_s **)(a1 + 24);
  if (v16 && os_log_type_enabled(*(os_log_t *)(a1 + 24), OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v17 = data_archive_entry_path((uint64_t)v14);
    if (type > 4) {
      uint64_t v18 = "?";
    }
    else {
      uint64_t v18 = off_189E3F6D8[type];
    }
    *(_DWORD *)statfs buf = 136315394;
    uint64_t v23 = v17;
    __int16 v24 = 2080;
    uint64_t v25 = v18;
    _os_log_impl(&dword_1862F3000, v16, OS_LOG_TYPE_DEFAULT, "%s [%s]", buf, 0x16u);
  }

  if (type == 1)
  {
    *a2 = 1;
    data_archive_entry_free(v14);
    return 0LL;
  }

  if (type == 4)
  {
    data_archive_entry_free(v14);
    return next_data_archive_entry(a1, a2, a3);
  }

  else
  {
    uint64_t v19 = BOMCopierSourceEntryNewFromDataArchive(*(void *)(a1 + 280), v14, v12, a3);
    data_archive_entry_free(v14);
  }

  return v19;
}

uint64_t synthesize_filesystem_stuff()
{
  uint64_t v0 = MEMORY[0x1895F8858]();
  uint64_t v3 = v2;
  uint64_t v4 = v1;
  uint64_t v5 = v0;
  uint64_t v53 = *MEMORY[0x1895F89C0];
  uint64_t v6 = *(os_log_s **)(v5 + 24);
  if (v6 && os_log_type_enabled(*(os_log_t *)(v5 + 24), OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)statfs buf = 0;
    _os_log_impl(&dword_1862F3000, v6, OS_LOG_TYPE_DEFAULT, "Synthesizing AppleDouble entry", buf, 2u);
  }

  int v7 = *(_BYTE *)(v5 + 68) || *(_BYTE *)(v5 + 69) ? 4980740 : 4980736;
  copyfile_flags_t v8 = v7 | *(unsigned __int8 *)(v5 + 70);
  ActualPath = (const char *)BOMCopierSourceEntryGetActualPath(v4);
  if ((copyfile(ActualPath, 0LL, 0LL, v8 | 0x10000) & v8) == 0) {
    goto LABEL_28;
  }
  memcpy(buf, "/tmp/.BC.T_XXXXXX", sizeof(buf));
  if (!mktemp(buf))
  {
    int v12 = *__error();
    int32_t v13 = __error();
    strerror(*v13);
    BOMCopierErrorCapture( v3,  v12,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c",  3789,  (uint64_t)"synthesize_apple_double",  "Could not mktemp %s: %s");
    goto LABEL_14;
  }

  if (!copyfile(ActualPath, buf, 0LL, v8))
  {
    uint64_t v14 = BOMCopierSourceEntryNewFromPath(buf, 0, v3);
    if (!v14)
    {
      BOMCopierErrorCapture( v3,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c",  3808,  (uint64_t)"synthesize_apple_double",  "Could not create BOMCopierSourceEntry from %s",  buf);
      unlink(buf);
      goto LABEL_14;
    }

    uint64_t v15 = (unsigned int *)v14;
    Path = (const char *)BOMCopierSourceEntryGetPath(v4);
    bzero(__s, 0x400uLL);
    bzero(v47, 0x400uLL);
    dirname_r(Path, __s);
    basename_r(Path, (char *)v47);
    bzero(__str, 0x400uLL);
    snprintf(__str, 0x400uLL, "%s/%s%s", __s, "._", (const char *)v47);
    if (BOMCopierSourceEntrySetPath(v15, __str))
    {
      BOMCopierErrorCapture( v3,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c",  3828,  (uint64_t)"synthesize_apple_double",  "Could not create set path entry for %s");
LABEL_24:
      BOMCopierSourceEntryFree(v15);
      goto LABEL_14;
    }

    if (BOMCopierSourceEntrySetOption( (uint64_t)v15,  @"DeleteOnFree",  (const void *)*MEMORY[0x189604DE8]))
    {
      BOMCopierErrorCapture( v3,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c",  3836,  (uint64_t)"synthesize_apple_double",  "Could not set kBOMCopierSourceEntryDeleteOnFree option",  v30);
      goto LABEL_24;
    }

    if (push_preempt_stack(v5, (uint64_t)v15, v3))
    {
      BOMCopierErrorCapture( v3,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c",  3844,  (uint64_t)"synthesize_apple_double",  "Could not push synthetic AppleDouble entry",  v30);
      goto LABEL_24;
    }

    uint64_t v17 = *(os_log_s **)(v5 + 24);
    if (v17 && os_log_type_enabled(*(os_log_t *)(v5 + 24), OS_LOG_TYPE_DEFAULT))
    {
      v52.st_dev = 136315138;
      *(void *)&v52.st_mode = ActualPath;
      _os_log_impl(&dword_1862F3000, v17, OS_LOG_TYPE_DEFAULT, "Synthesized AppleDouble from %s", (uint8_t *)&v52, 0xCu);
    }

LABEL_28:
    uint64_t v19 = *(os_log_s **)(v5 + 24);
    if (v19 && os_log_type_enabled(*(os_log_t *)(v5 + 24), OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)statfs buf = 0;
      _os_log_impl(&dword_1862F3000, v19, OS_LOG_TYPE_DEFAULT, "Synthesizing resource fork entry", buf, 2u);
    }

    BOOL v20 = (const char *)BOMCopierSourceEntryGetActualPath(v4);
    if (asprintf(&v31, "%s%s", v20, "/..namedfork/rsrc") < 0)
    {
      int v24 = *__error();
      uint64_t v25 = __error();
      strerror(*v25);
      BOMCopierErrorCapture( v3,  v24,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c",  3653,  (uint64_t)"synthesize_resource_fork",  "Could not asprintf resource path for %s: %s");
      goto LABEL_39;
    }

    int v21 = lstat(v31, &v52);
    free(v31);
    if (v21)
    {
      if (*__error() != 2)
      {
        int v22 = *__error();
        uint64_t v23 = __error();
        strerror(*v23);
        BOMCopierErrorCapture( v3,  v22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c",  3666,  (uint64_t)"synthesize_resource_fork",  "Could not lstat resource path for %s: %s");
        goto LABEL_39;
      }
    }

    else if (v52.st_size)
    {
      uint64_t v26 = BOMCopierSourceEntryNewFromResourceFork(v20, v3);
      if (v26)
      {
        char v27 = v26;
        uint64_t v28 = (const char *)BOMCopierSourceEntryGetPath(v4);
        bzero(buf, 0x400uLL);
        memset(v47, 0, 255);
        dirname_r(v28, buf);
        basename_r(v28, (char *)v47);
        __int128 v45 = 0u;
        memset(v46, 0, sizeof(v46));
        __int128 v43 = 0u;
        __int128 v44 = 0u;
        __int128 v41 = 0u;
        __int128 v42 = 0u;
        __int128 v40 = 0u;
        __int128 v38 = 0u;
        __int128 v39 = 0u;
        __int128 v36 = 0u;
        __int128 v37 = 0u;
        __int128 v34 = 0u;
        __int128 v35 = 0u;
        *(_OWORD *)__str = 0u;
        __int128 v33 = 0u;
        snprintf(__str, 0xFFuLL, "%s%s", (const char *)v47, "/..namedfork/rsrc");
        bzero(__s, 0x400uLL);
        snprintf(__s, 0x400uLL, "%s/%s", buf, __str);
        if (BOMCopierSourceEntrySetPath(v27, __s))
        {
          BOMCopierErrorCapture( v3,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c",  3709,  (uint64_t)"synthesize_resource_fork",  "Could not create set path entry for %s");
        }

        else if (BOMCopierSourceEntrySetParent((uint64_t)v27, buf))
        {
          BOMCopierErrorCapture( v3,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c",  3717,  (uint64_t)"synthesize_resource_fork",  "Could not create set entry parent for %s");
        }

        else if (BOMCopierSourceEntrySetName((uint64_t)v27, __str))
        {
          BOMCopierErrorCapture( v3,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c",  3725,  (uint64_t)"synthesize_resource_fork",  "Could not create set entry name for %s");
        }

        else
        {
          if (!push_preempt_stack(v5, (uint64_t)v27, v3))
          {
            int v29 = *(os_log_s **)(v5 + 24);
            if (v29)
            {
              if (os_log_type_enabled(*(os_log_t *)(v5 + 24), OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)uint64_t v48 = 136315138;
                size_t v49 = v20;
                _os_log_impl(&dword_1862F3000, v29, OS_LOG_TYPE_DEFAULT, "Synthesized resource fork from %s", v48, 0xCu);
              }
            }

            return 0LL;
          }

          BOMCopierErrorCapture( v3,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c",  3733,  (uint64_t)"synthesize_resource_fork",  "Could not push synthetic resource fork entry");
        }

        BOMCopierSourceEntryFree(v27);
      }

      else
      {
        *(stat *)statfs buf = v52;
        BOMCopierErrorCapture( v3,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c",  3688,  (uint64_t)"synthesize_resource_fork",  "Could not create BOMCopierSourceEntry from %s");
      }

    free(v21);
  }

  else
  {
    BOMCopierNotifyFatalError(a1, "Could not allocate path to resolve\n", v15, v16, v17, v18, v19, v20, v49);
  }

  free(v13);
  return 0xFFFFFFFFLL;
}

        CC_SHA256_Update((CC_SHA256_CTX *)a1[9], data, len);
        copyfile_flags_t v8 = *a1;
        if ((*a1 & 0x80) == 0)
        {
LABEL_22:
          if ((v8 & 0x100) == 0) {
            return 0LL;
          }
LABEL_23:
          CC_SHA512_Update((CC_SHA512_CTX *)a1[11], data, len);
          return 0LL;
        }

    CC_SHA256_Final((unsigned __int8 *)a1[15], (CC_SHA256_CTX *)a1[9]);
    uint64_t v4 = *a1;
    if ((*a1 & 0x80) == 0)
    {
LABEL_21:
      if ((v4 & 0x100) == 0) {
        return 0LL;
      }
LABEL_22:
      CC_SHA512_Final((unsigned __int8 *)a1[17], (CC_SHA512_CTX *)a1[11]);
      return 0LL;
    }

uint64_t adjust_filesystem_entry_path(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  uint64_t v6 = "";
  if (!*(_BYTE *)(a1 + 93)) {
    uint64_t v6 = ".";
  }
  int v7 = (const char *)(*(void *)(a2 + 48)
                    + *(void *)(a1 + 144)
                    - *(void *)(a1 + 136)
                    + *(unsigned __int8 *)(a1 + 93));
  __s = 0LL;
  int v8 = asprintf(&__s, "%s%s", v6, v7);
  if (!__s || v8 < 0)
  {
    int v10 = *__error();
    int v11 = __error();
    int v12 = strerror(*v11);
    BOMCopierErrorCapture( a4,  v10,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c",  3558,  (uint64_t)"adjust_filesystem_entry_path",  "Could not asprintf the entry_path: %s",  v12);
    return 1LL;
  }

  else if (BOMCopierSourceEntrySetPath(a3, __s))
  {
    uint64_t v9 = 1LL;
    BOMCopierErrorCapture( a4,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c",  3571,  (uint64_t)"adjust_filesystem_entry_path",  "Could not set the entry path");
    free(__s);
  }

  else
  {
    free(__s);
    return 0LL;
  }

  return v9;
}

uint64_t push_preempt_stack(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v5 = *(char **)(a1 + 312);
  if (v5 || (uint64_t v5 = (char *)BOMStackNew(), (*(void *)(a1 + 312) = v5) != 0LL))
  {
    BOMStackPush(v5, a2);
    return 0LL;
  }

  else
  {
    BOMCopierErrorCapture( a3,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c",  4589,  (uint64_t)"push_preempt_stack",  "Could not create empty preempt stack");
    return 0xFFFFFFFFLL;
  }

char *is_apple_double(void *a1)
{
  int Type = BOMCopierSourceEntryGetType((uint64_t)a1);
  if (Type != 15 && Type != 8) {
    return 0LL;
  }
  uint64_t result = BOMCopierSourceEntryGetName(a1);
  if (result) {
    return (char *)(strncmp(result, "._", 2uLL) == 0);
  }
  return result;
}

uint64_t consume_source_entry(unsigned int *a1, void *a2)
{
  uint64_t v4 = BOMCopierSourceEntrySkip((uint64_t)a1, 0LL, 0LL, a2);
  if ((_DWORD)v4) {
    BOMCopierErrorCapture( a2,  v4,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c",  3864,  (uint64_t)"consume_source_entry",  "Could not skip source entry");
  }
  else {
    BOMCopierSourceEntryFree(a1);
  }
  return v4;
}

uint64_t push_replay_stack(void *a1, uint64_t a2, int a3, void *a4)
{
  switch(a3)
  {
    case 3:
      int v7 = (char *)a1[42];
      if (!v7)
      {
        int v7 = (char *)BOMStackNew();
        a1[42] = v7;
        if (!v7)
        {
          BOMCopierErrorCapture( a4,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c",  4646,  (uint64_t)"push_replay_stack",  "Could not create empty replay directory stack");
          return 0xFFFFFFFFLL;
        }
      }

      break;
    case 2:
      int v7 = (char *)a1[41];
      if (!v7)
      {
        int v7 = (char *)BOMStackNew();
        a1[41] = v7;
        if (!v7)
        {
          BOMCopierErrorCapture( a4,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c",  4631,  (uint64_t)"push_replay_stack",  "Could not create empty replay AppleDouble stack");
          return 0xFFFFFFFFLL;
        }
      }

      break;
    case 1:
      int v7 = (char *)a1[40];
      if (!v7)
      {
        int v7 = (char *)BOMStackNew();
        a1[40] = v7;
        if (!v7)
        {
          BOMCopierErrorCapture( a4,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c",  4616,  (uint64_t)"push_replay_stack",  "Could not create empty replay symlink stack");
          return 0xFFFFFFFFLL;
        }
      }

      break;
    default:
      uint64_t v8 = 1LL;
      BOMCopierErrorCapture( a4,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c",  4656,  (uint64_t)"push_replay_stack",  "Unknown replay type: %u",  a3);
      return v8;
  }

  BOMStackPush(v7, a2);
  return 0LL;
}

uint64_t synthesize_replay_apple_double(uint64_t a1, void *a2, void *a3)
{
  uint64_t v21 = *MEMORY[0x1895F89C0];
  uint64_t v6 = BOMCopierSourceEntryNew(17, a3);
  if (v6)
  {
    int v7 = v6;
    uint64_t v8 = BOMCopierSourceEntryGetName(a2) + 2;
    uint64_t v9 = strdup(v8);
    if (v9)
    {
      int v10 = v9;
      int v11 = *(const char **)(a1 + 80);
      if (v11)
      {
        size_t v12 = strlen(v11);
        v10[strlen(v10) - v12] = 0;
      }

      if (BOMCopierSourceEntrySetAppleDoubleTarget((uint64_t)v7, v10))
      {
        BOMCopierErrorCapture( a3,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c",  4039,  (uint64_t)"synthesize_replay_apple_double",  "Could not create set AppleDouble target for replay AppleDouble file");
        free(v10);
      }

      else
      {
        Path = (char *)BOMCopierSourceEntryGetPath((uint64_t)a2);
        uint64_t v15 = *(os_log_s **)(a1 + 24);
        if (v15)
        {
          if (os_log_type_enabled(*(os_log_t *)(a1 + 24), OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)statfs buf = 136315394;
            uint64_t v18 = Path;
            __int16 v19 = 2080;
            BOOL v20 = v10;
            _os_log_impl( &dword_1862F3000,  v15,  OS_LOG_TYPE_DEFAULT,  "Synthesizing replay AppleDouble from %s to %s",  buf,  0x16u);
          }
        }

        free(v10);
        if (BOMCopierSourceEntrySetPath(v7, Path))
        {
          BOMCopierErrorCapture( a3,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c",  4054,  (uint64_t)"synthesize_replay_apple_double",  "Could not set entry path for replay AppleDouble file");
        }

        else if (copy_entry_metadata((uint64_t)a2, (uint64_t)v7, a3))
        {
          BOMCopierErrorCapture( a3,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c",  4062,  (uint64_t)"synthesize_replay_apple_double",  "Could not copy metadata from the source entry to its replay apple double");
        }

        else
        {
          uint64_t result = push_replay_stack((void *)a1, (uint64_t)v7, 2, a3);
          if (!(_DWORD)result) {
            return result;
          }
          BOMCopierErrorCapture( a3,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c",  4070,  (uint64_t)"synthesize_replay_apple_double",  "Could not push the synthetic replay AppleDouble");
        }
      }
    }

    else
    {
      int32_t v13 = __error();
      strerror(*v13);
      BOMCopierErrorCapture( a3,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c",  4022,  (uint64_t)"synthesize_replay_apple_double",  "Could not duplicate %s: %s");
    }

    BOMCopierSourceEntryFree(v7);
  }

  else
  {
    BOMCopierErrorCapture( a3,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c",  4006,  (uint64_t)"synthesize_replay_apple_double",  "Could not create BOMCopierSourceEntry for replay AppleDouble file");
  }

  return 0xFFFFFFFFLL;
}

uint64_t __add_sequester_entry_block_invoke(uint64_t a1, const char *a2, int a3)
{
  uint64_t v5 = *(void *)(*(void *)(a1 + 32) + 8LL);
  if (!*(void *)(v5 + 24))
  {
    size_t v18 = strlen(a2);
    uint64_t v19 = *(void *)(a1 + 48);
    if (*(_BYTE *)(v19 + 93)) {
      BOOL v20 = "__MACOSX";
    }
    else {
      BOOL v20 = ".";
    }
    if (!strncmp(a2, v20, v18))
    {
      uint64_t v21 = *(void *)(v19 + 344);
      if (v21)
      {
        uint64_t result = 0LL;
        *(void *)(v5 + 24) = v21;
        return result;
      }

      *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = path_tree_node_create(a2, *(void **)(a1 + 56));
      uint64_t v23 = *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL);
      if (v23)
      {
        uint64_t result = 0LL;
        *(void *)(*(void *)(a1 + 48) + 344LL) = v23;
        return result;
      }

      BOMCopierErrorCapture( *(void **)(a1 + 56),  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c",  4751,  (uint64_t)"add_sequester_entry_block_invoke",  "Could not create root path tree node");
    }

    else
    {
      BOMCopierErrorCapture( *(void **)(a1 + 56),  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c",  4741,  (uint64_t)"add_sequester_entry_block_invoke",  "I was expecting %s not %s");
    }

    return 0xFFFFFFFFLL;
  }

  *(void *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL) = 0LL;
  uint64_t v7 = *(void *)(a1 + 32);
  uint64_t v8 = *(void *)(*(void *)(v7 + 8) + 24LL);
  if (*(_DWORD *)(v8 + 8))
  {
    unint64_t v9 = 0LL;
    do
    {
      uint64_t v10 = *(void *)(*(void *)(a1 + 40) + 8LL);
      if (*(void *)(v10 + 24)) {
        break;
      }
      int v11 = *(const char ***)(*(void *)(v8 + 16) + 8 * v9);
      if (!strncmp(a2, *v11, 0xFFuLL))
      {
        *(void *)(v10 + 24) = v11;
        uint64_t v7 = *(void *)(a1 + 32);
      }

      ++v9;
      uint64_t v8 = *(void *)(*(void *)(v7 + 8) + 24LL);
    }

    while (v9 < *(unsigned int *)(v8 + 8));
  }

  uint64_t v12 = *(void *)(a1 + 40);
  uint64_t v13 = *(void *)(*(void *)(v12 + 8) + 24LL);
  if (v13) {
    goto LABEL_27;
  }
  uint64_t v14 = *(void **)(a1 + 56);
  if (a2)
  {
    uint64_t v15 = path_tree_node_create(a2, *(void **)(a1 + 56));
    if (!v15)
    {
      BOMCopierErrorCapture( v14,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c",  5055,  (uint64_t)"path_tree_node_add_child",  "Could not create child node for %s\n",  a2);
      goto LABEL_26;
    }

    uint64_t v16 = *(unsigned int *)(v8 + 8);
    uint64_t v17 = realloc(*(void **)(v8 + 16), 8LL * (v16 + 1));
    if (v17)
    {
      v17[v16] = v15;
      *(_DWORD *)(v8 + 8) = v16 + 1;
      *(void *)(v8 + 16) = v17;
      goto LABEL_26;
    }

    int v24 = __error();
    BOMCopierErrorCapture( v14,  *v24,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c",  5067,  (uint64_t)"path_tree_node_add_child",  "Could not reallocate new children list\n");
    path_tree_node_release((uint64_t)v15);
  }

  else
  {
    BOMCopierErrorCapture( *(void **)(a1 + 56),  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c",  5047,  (uint64_t)"path_tree_node_add_child",  "child_name is NULL");
  }

  uint64_t v15 = 0LL;
LABEL_26:
  *(void *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL) = v15;
  uint64_t v12 = *(void *)(a1 + 40);
  uint64_t v13 = *(void *)(*(void *)(v12 + 8) + 24LL);
  if (!v13)
  {
    BOMCopierErrorCapture( *(void **)(a1 + 56),  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c",  4786,  (uint64_t)"add_sequester_entry_block_invoke",  "Could not add child %s to %s");
    return 0xFFFFFFFFLL;
  }

LABEL_27:
  if (a3)
  {
    *(void *)(v13 + 24) = *(void *)(a1 + 64);
    uint64_t v12 = *(void *)(a1 + 40);
  }

  uint64_t result = 0LL;
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = *(void *)(*(void *)(v12 + 8) + 24LL);
  return result;
}

    archive_entry_free();
  }

  else
  {
    uint64_t v16 = 1LL;
    BOMCopierErrorCapture( a4,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  4283,  (uint64_t)"create_entry_libarchive",  "Could not create empty archive entry");
  }

  return v16;
}

        CC_SHA224_Update((CC_SHA256_CTX *)a1[8], data, len);
        uint64_t v8 = *a1;
        if ((*a1 & 0x40) == 0)
        {
LABEL_21:
          if ((v8 & 0x80) == 0) {
            goto LABEL_22;
          }
          goto LABEL_29;
        }

    CC_SHA224_Final((unsigned __int8 *)a1[14], (CC_SHA256_CTX *)a1[8]);
    uint64_t v4 = *a1;
    if ((*a1 & 0x40) == 0)
    {
LABEL_20:
      if ((v4 & 0x80) == 0) {
        goto LABEL_21;
      }
      goto LABEL_29;
    }

void *path_tree_node_create(const char *a1, void *a2)
{
  if (!a1)
  {
    BOMCopierErrorCapture( a2,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c",  4985,  (uint64_t)"path_tree_node_create",  "name is NULL");
    return 0LL;
  }

  uint64_t v4 = calloc(1uLL, 0x20uLL);
  if (!v4)
  {
    unint64_t v9 = __error();
    BOMCopierErrorCapture( a2,  *v9,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c",  4992,  (uint64_t)"path_tree_node_create",  "Could not allocate node");
    return v4;
  }

  uint64_t v5 = strdup(a1);
  *uint64_t v4 = v5;
  if (!v5)
  {
    int v6 = *__error();
    uint64_t v7 = __error();
    uint64_t v8 = strerror(*v7);
    BOMCopierErrorCapture( a2,  v6,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c",  4999,  (uint64_t)"path_tree_node_create",  "Could not strdup %s: %s",  a1,  v8);
    free(v4);
    return 0LL;
  }

  return v4;
}

uint64_t copy_entry_metadata(uint64_t a1, uint64_t a2, void *a3)
{
  __int16 Mode = BOMCopierSourceEntryGetMode(a1);
  if (BOMCopierSourceEntrySetMode(a2, Mode))
  {
    BOMCopierErrorCapture( a3,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c",  4504,  (uint64_t)"copy_entry_metadata",  "Could not set mode for entry %s");
  }

  else
  {
    int UserID = BOMCopierSourceEntryGetUserID(a1);
    if (BOMCopierSourceEntrySetUserID(a2, UserID))
    {
      BOMCopierErrorCapture( a3,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c",  4513,  (uint64_t)"copy_entry_metadata",  "Could not set uid for entry %s");
    }

    else
    {
      int GroupID = BOMCopierSourceEntryGetGroupID(a1);
      if (BOMCopierSourceEntrySetGroupID(a2, GroupID))
      {
        BOMCopierErrorCapture( a3,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c",  4522,  (uint64_t)"copy_entry_metadata",  "Could not set gid for entry %s");
      }

      else if (BOMCopierSourceEntryGetAccessTime(a1, &v12))
      {
        BOMCopierErrorCapture( a3,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c",  4531,  (uint64_t)"copy_entry_metadata",  "Could not get access time for entry %s");
      }

      else if (BOMCopierSourceEntrySetAccessTime(a2, v12, *((uint64_t *)&v12 + 1)))
      {
        BOMCopierErrorCapture( a3,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c",  4538,  (uint64_t)"copy_entry_metadata",  "Could not set access time for entry %s");
      }

      else if (BOMCopierSourceEntryGetModificationTime(a1, &v11))
      {
        BOMCopierErrorCapture( a3,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c",  4547,  (uint64_t)"copy_entry_metadata",  "Could not get modification time for entry %s");
      }

      else if (BOMCopierSourceEntrySetModificationTime(a2, v11, *((uint64_t *)&v11 + 1)))
      {
        BOMCopierErrorCapture( a3,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c",  4554,  (uint64_t)"copy_entry_metadata",  "Could not set modification time for entry %s");
      }

      else if (BOMCopierSourceEntryGetStatusTime(a1, &v10))
      {
        BOMCopierErrorCapture( a3,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c",  4563,  (uint64_t)"copy_entry_metadata",  "Could not get status time for entry %s");
      }

      else
      {
        uint64_t result = BOMCopierSourceEntrySetStatusTime(a2, v10, *((uint64_t *)&v10 + 1));
        if (!(_DWORD)result) {
          return result;
        }
        BOMCopierErrorCapture( a3,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c",  4570,  (uint64_t)"copy_entry_metadata",  "Could not set status time for entry %s");
      }
    }
  }

  return 0xFFFFFFFFLL;
}

uint64_t path_tree_node_push(uint64_t a1, const char *a2, char *a3, void *a4)
{
  __s = 0LL;
  if (a2) {
    asprintf(&__s, "%s/%s");
  }
  else {
    asprintf(&__s, "%s");
  }
  if (__s)
  {
    if (*(_DWORD *)(a1 + 8))
    {
      uint64_t v8 = 0LL;
      while (!path_tree_node_push(*(void *)(*(void *)(a1 + 16) + 8 * v8), __s, a3, a4))
      {
      }

      BOMCopierErrorCapture( a4,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c",  5114,  (uint64_t)"path_tree_node_push",  "Could not push child %s of %s onto the stack\n");
      goto LABEL_21;
    }

LABEL_9:
    unint64_t v9 = *(unsigned int **)(a1 + 24);
    if (v9)
    {
LABEL_10:
      BOMStackPush(a3, (uint64_t)v9);
      free(__s);
      return 0LL;
    }

    __int128 v12 = BOMCopierSourceEntryNew(6, a4);
    if (v12)
    {
      unint64_t v9 = v12;
      if (BOMCopierSourceEntrySetPath(v12, __s))
      {
        BOMCopierErrorCapture( a4,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c",  5135,  (uint64_t)"path_tree_node_push",  "Could not path for source entry of %s\n");
      }

      else
      {
        BOMCopierErrorCapture( a4,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c",  5144,  (uint64_t)"path_tree_node_push",  "Could not mode for source entry of %s\n");
      }

      BOMCopierSourceEntryFree(v9);
    }

    else
    {
      BOMCopierErrorCapture( a4,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c",  5127,  (uint64_t)"path_tree_node_push",  "Could not create source entry for %s\n");
    }

      free(v6);
      free(v8);
LABEL_10:
      uint64_t result = BOMTreeCommit(*(void *)(a1 + 8));
      if (!(_DWORD)result)
      {
        *(_BYTE *)(a1 + 24) = 0;
        return result;
      }
    }
  }

  return 1LL;
}

    uint64_t v8 = -1;
    uint64_t v14 = 61951;
    uint64_t v15 = 0xFFFFFFFFLL;
  }

  else
  {
    uint64_t v15 = *(unsigned int *)(a3 + 16);
    if (*(_BYTE *)(a1 + 205) == 1)
    {
LABEL_16:
      uint64_t v14 = 61951;
      goto LABEL_17;
    }

    uint64_t v14 = 0xFFFF;
    if (*(_BYTE *)(a1 + 209) == 1)
    {
      if (*(_BYTE *)(a1 + 210)) {
        uint64_t v14 = 0xFFFF;
      }
      else {
        uint64_t v14 = 61951;
      }
    }
  }

char *BOMNewPathKey(unsigned int a1, char *__s, void *a3)
{
  uint64_t v3 = 0LL;
  if (__s && a3)
  {
    size_t v7 = strlen(__s);
    uint64_t v8 = (char *)BOM_malloc(v7 + 5);
    uint64_t v3 = v8;
    if (v8)
    {
      *a3 = v7 + 5;
      *(_DWORD *)uint64_t v8 = bswap32(a1);
      strlcpy(v8 + 4, __s, v7 + 1);
    }

    else
    {
      unint64_t v9 = (FILE *)*MEMORY[0x1895F89D0];
      __int128 v10 = __error();
      __int128 v11 = strerror(*v10);
      fprintf(v9, "malloc: %s\n", v11);
    }
  }

  return v3;
}

_DWORD *BOMNewPathValue(unsigned int a1, unsigned int a2, void *a3)
{
  if (!a3) {
    return 0LL;
  }
  uint64_t result = BOM_malloc(8uLL);
  if (result)
  {
    *a3 = 8LL;
    *uint64_t result = bswap32(a1);
    result[1] = bswap32(a2);
  }

  else
  {
    size_t v7 = (FILE *)*MEMORY[0x1895F89D0];
    uint64_t v8 = __error();
    unint64_t v9 = strerror(*v8);
    fprintf(v7, "malloc: %s\n", v9);
    return 0LL;
  }

  return result;
}

unsigned int *BOMPathIDFromPathKey(unsigned int *result)
{
  if (result) {
    return (unsigned int *)bswap32(*result);
  }
  return result;
}

uint64_t BOMShortNameFromPathKey(uint64_t a1)
{
  return a1 + 4;
}

uint64_t BOMBlockIDFromPathValue(uint64_t result)
{
  if (result) {
    return bswap32(*(_DWORD *)(result + 4));
  }
  return result;
}

char *BOMCopierDestinationNew(char *__s, const __CFDictionary *a2, void *a3)
{
  uint64_t v175 = *MEMORY[0x1895F89C0];
  if (!((unint64_t)__s | (unint64_t)a2))
  {
    BOMCopierErrorCapture( a3,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  621,  (uint64_t)"BOMCopierDestinationNew",  "path and options are NULL");
    return 0LL;
  }

  if (__s && strlen(__s) >= 0x400)
  {
    BOMCopierErrorCapture( a3,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  630,  (uint64_t)"BOMCopierDestinationNew",  "maximum path length exceeded: %ld");
    return 0LL;
  }

  int v6 = (char *)calloc(1uLL, 0x170uLL);
  if (!v6)
  {
    uint64_t v8 = __error();
    BOMCopierErrorCapture( a3,  *v8,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  644,  (uint64_t)"BOMCopierDestinationNew",  "Could not allocate empty BOMCopierDestination");
    return v6;
  }

  *((_DWORD *)v6 + 2) = geteuid();
  *(void *)(v6 + 124) = 0x10000LL;
  *((_DWORD *)v6 + 36) = -1;
  *((_DWORD *)v6 + 29) = 0;
  v6[297] = 1;
  *((_DWORD *)v6 + 82) = -1;
  size_t v7 = BOMHardLinkTableNew();
  *((void *)v6 + 9) = v7;
  if (!v7)
  {
    int v9 = *__error();
    BOMCopierErrorCapture( a3,  v9,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  662,  (uint64_t)"BOMCopierDestinationNew",  "Could not create BOMHardLinkTable");
    goto LABEL_319;
  }

  *((_DWORD *)v6 + 4) = -1;
  if (!geteuid())
  {
    v6[302] = 1;
    if (!a2) {
      goto LABEL_249;
    }
LABEL_14:
    CFTypeID TypeID = CFBooleanGetTypeID();
    unint64_t Value = CFDictionaryGetValue(a2, @"useFilesystemCache");
    if (Value)
    {
      __int128 v12 = Value;
      if (TypeID != CFGetTypeID(Value))
      {
        BOMCopierErrorCapture( a3,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  2767,  (uint64_t)"parse_copier_destination_options",  "kBOMCopierDestinationOptionUseFilesystemCacheKey must be a CFBooleanRef");
        goto LABEL_319;
      }

      if (CFEqual(v12, (CFTypeRef)*MEMORY[0x189604DE0]) == 1) {
        v6[40] = 1;
      }
    }

    uint64_t v13 = CFDictionaryGetValue(a2, @"applySourcePermissions");
    if (v13)
    {
      uint64_t v14 = v13;
      if (TypeID != CFGetTypeID(v13))
      {
        BOMCopierErrorCapture( a3,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  2782,  (uint64_t)"parse_copier_destination_options",  "kBOMCopierDestinationOptionApplySourcePermissionsKey must be a CFBooleanRef");
        goto LABEL_319;
      }

      v6[43] = CFEqual(v14, (CFTypeRef)*MEMORY[0x189604DE8]) != 0;
    }

    uint64_t v15 = CFDictionaryGetValue(a2, @"createArchive");
    if (v15)
    {
      if (TypeID != CFGetTypeID(v15))
      {
        BOMCopierErrorCapture( a3,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  2794,  (uint64_t)"parse_copier_destination_options",  "kBOMCopierDestinationOptionCreateArchiveKey must be a CFBooleanRef");
        goto LABEL_319;
      }

      *((_DWORD *)v6 + 11) = 1;
    }

    CFTypeID v16 = CFNumberGetTypeID();
    uint64_t v17 = (const __CFNumber *)CFDictionaryGetValue(a2, @"libarchiveFormat");
    if (v17)
    {
      size_t v18 = v17;
      if (v16 != CFGetTypeID(v17))
      {
        BOMCopierErrorCapture( a3,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  2808,  (uint64_t)"parse_copier_destination_options",  "kBOMCopierDestinationOptionLibarchiveFormatKey must be a CFNumberRef");
        goto LABEL_319;
      }

      valuePtr[0].st_dev = -1;
      if (!CFNumberGetValue(v18, kCFNumberSInt32Type, valuePtr))
      {
        BOMCopierErrorCapture( a3,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  2816,  (uint64_t)"parse_copier_destination_options",  "Could not convert the format number to kCFNumberSInt32Type");
        goto LABEL_319;
      }

      *((_DWORD *)v6 + 31) = valuePtr[0].st_dev;
    }

    uint64_t v19 = (const __CFNumber *)CFDictionaryGetValue(a2, @"libarchiveFilter");
    if (v19)
    {
      BOOL v20 = v19;
      if (v16 != CFGetTypeID(v19))
      {
        BOMCopierErrorCapture( a3,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  2828,  (uint64_t)"parse_copier_destination_options",  "kBOMCopierDestinationOptionLibarchiveFilterKey must be a CFNumberRef");
        goto LABEL_319;
      }

      valuePtr[0].st_dev = -1;
      if (!CFNumberGetValue(v20, kCFNumberSInt32Type, valuePtr))
      {
        BOMCopierErrorCapture( a3,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  2836,  (uint64_t)"parse_copier_destination_options",  "Could not convert the format number to kCFNumberSInt32Type");
        goto LABEL_319;
      }

      *((_DWORD *)v6 + 32) = valuePtr[0].st_dev;
    }

    uint64_t v21 = CFDictionaryGetValue(a2, @"createAppleArchive");
    if (v21)
    {
      if (TypeID != CFGetTypeID(v21))
      {
        BOMCopierErrorCapture( a3,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  2848,  (uint64_t)"parse_copier_destination_options",  "kBOMCopierDestinationOptionCreateAppleArchiveKey must be a CFBooleanRef");
        goto LABEL_319;
      }

      *((_DWORD *)v6 + 11) = 2;
    }

    CFTypeID v22 = CFStringGetTypeID();
    uint64_t v23 = CFDictionaryGetValue(a2, @"compressAppleArchive");
    if (v23)
    {
      int v24 = v23;
      if (v22 != CFGetTypeID(v23))
      {
        BOMCopierErrorCapture( a3,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  2862,  (uint64_t)"parse_copier_destination_options",  "kBOMCopierDestinationOptionCompressAppleArchiveKey must be a CFStringRef");
        goto LABEL_319;
      }

      if (CFEqual(v24, @"none") == 1)
      {
        int v25 = 0;
      }

      else if (CFEqual(v24, @"lz4") == 1)
      {
        int v25 = 256;
      }

      else if (CFEqual(v24, @"zlib") == 1)
      {
        int v25 = 1285;
      }

      else if (CFEqual(v24, @"lzma") == 1)
      {
        int v25 = 774;
      }

      else if (CFEqual(v24, @"lzfse") == 1)
      {
        int v25 = 2049;
      }

      else
      {
        if (CFEqual(v24, @"lzbitmap") != 1)
        {
          BOMCopierErrorCapture( a3,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  2896,  (uint64_t)"parse_copier_destination_options",  "Unsupported AppleArchive compression algorithm");
          goto LABEL_319;
        }

        int v25 = 1794;
      }

      *((_DWORD *)v6 + 41) = v25;
    }

    uint64_t v26 = (const __CFNumber *)CFDictionaryGetValue(a2, @"outputFD");
    if (v26)
    {
      char v27 = v26;
      if (v16 != CFGetTypeID(v26))
      {
        BOMCopierErrorCapture( a3,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  2906,  (uint64_t)"parse_copier_destination_options",  "kBOMCopierDestinationOptionOutputFileDescriptorKey must be a CFBooleanRef");
        goto LABEL_319;
      }

      valuePtr[0].st_dev = -1;
      if (!CFNumberGetValue(v27, kCFNumberSInt32Type, valuePtr))
      {
        BOMCopierErrorCapture( a3,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  2914,  (uint64_t)"parse_copier_destination_options",  "Could not convert the format number to kCFNumberSInt32Type");
        goto LABEL_319;
      }

      *((_DWORD *)v6 + 12) = valuePtr[0].st_dev;
    }

    CFTypeID v28 = CFWriteStreamGetTypeID();
    int v29 = (__CFWriteStream *)CFDictionaryGetValue(a2, @"outputStream");
    if (v29)
    {
      uint64_t v30 = v29;
      if (v28 != CFGetTypeID(v29))
      {
        BOMCopierErrorCapture( a3,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  2928,  (uint64_t)"parse_copier_destination_options",  "kBOMCopierDestinationOptionOutputCFWriteStreamKey must be a CFBooleanRef");
        goto LABEL_319;
      }

      if (CFWriteStreamGetStatus(v30) != kCFStreamStatusOpen)
      {
        BOMCopierErrorCapture( a3,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  2935,  (uint64_t)"parse_copier_destination_options",  "CFWriteStream is not open");
        goto LABEL_319;
      }

      *((void *)v6 + 7) = v30;
    }

    int v31 = CFDictionaryGetValue(a2, @"output2Nowhere");
    if (v31)
    {
      int v32 = v31;
      if (TypeID != CFGetTypeID(v31))
      {
        BOMCopierErrorCapture( a3,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  2947,  (uint64_t)"parse_copier_destination_options",  "kBOMCopierDestinationOptionOutputToNowhereKey must be a CFBooleanRef");
        goto LABEL_319;
      }

      if (CFEqual(v32, (CFTypeRef)*MEMORY[0x189604DE8]) == 1) {
        *((_DWORD *)v6 + 11) = 3;
      }
    }

    if (CFDictionaryContainsKey(a2, @"archs") == 1)
    {
      memset(valuePtr, 0, 48);
      if (BOMCopierPrepareMatchContext(a2, (uint64_t)valuePtr, a3))
      {
        BOMCopierErrorCapture( a3,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  2964,  (uint64_t)"parse_copier_destination_options",  "Could not prepare binary matching context");
        goto LABEL_319;
      }

      *((_DWORD *)v6 + 48) = valuePtr[0].st_dev;
      *((void *)v6 + 25) = valuePtr[0].st_ino;
    }

    __int128 v33 = CFDictionaryGetValue(a2, @"enableAtomicCopies");
    if (v33)
    {
      __int128 v34 = v33;
      if (TypeID != CFGetTypeID(v33))
      {
        BOMCopierErrorCapture( a3,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  2977,  (uint64_t)"parse_copier_destination_options",  "kBOMCopierDestinationOptionPerformAtomicCopies must be a CFBooleanRef");
        goto LABEL_319;
      }

      v6[297] = CFEqual((CFTypeRef)*MEMORY[0x189604DE8], v34) != 0;
    }

    __int128 v35 = CFDictionaryGetValue(a2, @"useDefaultDirectoryPermissions");
    if (v35)
    {
      __int128 v36 = v35;
      if (TypeID != CFGetTypeID(v35))
      {
        BOMCopierErrorCapture( a3,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  2989,  (uint64_t)"parse_copier_destination_options",  "kBOMCopierDestinationOptionUseDefaultDirectoryPermissions must be a CFBooleanRef");
        goto LABEL_319;
      }

      v6[296] = CFEqual((CFTypeRef)*MEMORY[0x189604DE8], v36) != 0;
    }

    __int128 v37 = CFDictionaryGetValue(a2, @"useAppleFSCompression");
    if (v37)
    {
      __int128 v38 = v37;
      if (TypeID != CFGetTypeID(v37))
      {
        BOMCopierErrorCapture( a3,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  3001,  (uint64_t)"parse_copier_destination_options",  "kBOMCopierDestinationOptionUseAppleFSCompression must be a CFBooleanRef");
        goto LABEL_319;
      }

      v6[112] = CFEqual((CFTypeRef)*MEMORY[0x189604DE8], v38) != 0;
    }

    __int128 v39 = CFDictionaryGetValue(a2, @"preserveAppleFSCompression");
    if (v39)
    {
      __int128 v40 = v39;
      if (TypeID != CFGetTypeID(v39))
      {
        BOMCopierErrorCapture( a3,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  3013,  (uint64_t)"parse_copier_destination_options",  "kBOMCopierDestinationOptionPreserveAppleFSCompression must be a CFBooleanRef");
        goto LABEL_319;
      }

      v6[113] = CFEqual((CFTypeRef)*MEMORY[0x189604DE8], v40) != 0;
    }

    __int128 v41 = (const __CFNumber *)CFDictionaryGetValue(a2, @"AppleFSCompressionType");
    if (v41)
    {
      __int128 v42 = v41;
      if (v16 != CFGetTypeID(v41))
      {
        BOMCopierErrorCapture( a3,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  3026,  (uint64_t)"parse_copier_destination_options",  "kBOMCopierDestinationOptionAppleFSCompressionType must be a CFNumberRef");
        goto LABEL_319;
      }

      valuePtr[0].st_dev = -1;
      if (!CFNumberGetValue(v42, kCFNumberSInt32Type, valuePtr))
      {
        BOMCopierErrorCapture( a3,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  3034,  (uint64_t)"parse_copier_destination_options",  "Could not convert the format number to kCFNumberSInt32Type");
        goto LABEL_319;
      }

      *((_DWORD *)v6 + 29) = valuePtr[0].st_dev;
    }

    __int128 v43 = (const __CFNumber *)CFDictionaryGetValue(a2, @"AppleFSCompressionFlags");
    if (v43)
    {
      __int128 v44 = v43;
      if (v16 != CFGetTypeID(v43))
      {
        BOMCopierErrorCapture( a3,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  3046,  (uint64_t)"parse_copier_destination_options",  "kBOMCopierDestinationOptionAppleFSCompressionFlags must be a CFNumberRef");
        goto LABEL_319;
      }

      valuePtr[0].st_dev = -1;
      if (!CFNumberGetValue(v44, kCFNumberSInt32Type, valuePtr))
      {
        BOMCopierErrorCapture( a3,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  3054,  (uint64_t)"parse_copier_destination_options",  "Could not convert the format number to kCFNumberSInt32Type");
        goto LABEL_319;
      }

      *((_DWORD *)v6 + 30) = valuePtr[0].st_dev;
    }

    __int128 v45 = CFDictionaryGetValue(a2, @"enforceDestinationEncapsulation");
    if (v45)
    {
      uint64_t v46 = v45;
      if (TypeID != CFGetTypeID(v45))
      {
        BOMCopierErrorCapture( a3,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  3066,  (uint64_t)"parse_copier_destination_options",  "kBOMCopierDestinationOptionEnforceDestinationEncapsulationKey must be a CFBooleanRef");
        goto LABEL_319;
      }

      v6[298] = CFEqual((CFTypeRef)*MEMORY[0x189604DE8], v46) != 0;
    }

    uint64_t v47 = CFDictionaryGetValue(a2, @"enforceDestinationLocation");
    if (v47)
    {
      uint64_t v48 = v47;
      if (TypeID != CFGetTypeID(v47))
      {
        BOMCopierErrorCapture( a3,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  3078,  (uint64_t)"parse_copier_destination_options",  "kBOMCopierDestinationOptionEnforceDestinationLocationKey must be a CFBooleanRef");
        goto LABEL_319;
      }

      v6[299] = CFEqual((CFTypeRef)*MEMORY[0x189604DE8], v48) != 0;
    }

    size_t v49 = CFDictionaryGetValue(a2, @"keepBinaries");
    if (v49)
    {
      uint64_t v50 = v49;
      if (TypeID != CFGetTypeID(v49))
      {
        BOMCopierErrorCapture( a3,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  3090,  (uint64_t)"parse_copier_destination_options",  "kBOMCopierDestinationKeepBinariesKey must be a CFBooleanRef");
        goto LABEL_319;
      }

      v6[307] = CFEqual((CFTypeRef)*MEMORY[0x189604DE8], v50) != 0;
    }

    __int16 v51 = (const __CFString *)CFDictionaryGetValue(a2, @"keptFileList");
    if (v51)
    {
      stat v52 = v51;
      if (v22 != CFGetTypeID(v51))
      {
        BOMCopierErrorCapture( a3,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  3102,  (uint64_t)"parse_copier_destination_options",  "kBOMCopierDestinationKeptFileListKey must be a CFStringRef");
        goto LABEL_319;
      }

      CFIndex v53 = CFStringGetLength(v52) + 1;
      int v54 = (char *)calloc(1uLL, v53);
      *((void *)v6 + 40) = v54;
      if (!v54)
      {
        BOMCopierErrorCapture( a3,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  3112,  (uint64_t)"parse_copier_destination_options",  "Could not allocate %ld bytes for path");
        goto LABEL_319;
      }

      if (!CFStringGetCString(v52, v54, v53, 0x8000100u))
      {
        BOMCopierErrorCapture( a3,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  3119,  (uint64_t)"parse_copier_destination_options",  "Could not convert enumeration_bom_path string to C string");
        goto LABEL_319;
      }
    }

    __int16 v55 = (const __CFString *)CFDictionaryGetValue(a2, @"keepFilePattern");
    if (!v55) {
      goto LABEL_142;
    }
    size_t v56 = v55;
    if (v22 != CFGetTypeID(v55))
    {
      BOMCopierErrorCapture( a3,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  3129,  (uint64_t)"parse_copier_destination_options",  "kBOMCopierDestinationKeepFilePatternKey must be a CFStringRef");
      goto LABEL_319;
    }

    CFIndex v57 = CFStringGetLength(v56) + 1;
    buffer = (char *)calloc(1uLL, v57);
    if (!buffer)
    {
      BOMCopierErrorCapture( a3,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  3139,  (uint64_t)"parse_copier_destination_options",  "Could not allocate %ld bytes for pattern");
      goto LABEL_319;
    }

    if (CFStringGetCString(v56, buffer, v57, 0x8000100u))
    {
      uint64_t v58 = (regex_t *)malloc(0x20uLL);
      *((void *)v6 + 42) = v58;
      if (v58)
      {
        if (regcomp(v58, buffer, 5))
        {
          int v59 = *__error();
          unsigned __int8 v60 = __error();
          uint64_t v61 = strerror(*v60);
          BOMCopierErrorCapture( a3,  v59,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  3162,  (uint64_t)"parse_copier_destination_options",  "Could not compile regular expression from %s: %s",  buffer,  v61);
          int v62 = buffer;
LABEL_140:
          free(v62);
          goto LABEL_319;
        }

        free(buffer);
LABEL_142:
        int v64 = (const __CFString *)CFDictionaryGetValue(a2, @"keptFileDirectory");
        if (v64)
        {
          uint64_t v65 = v64;
          if (v22 != CFGetTypeID(v64))
          {
            BOMCopierErrorCapture( a3,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  3175,  (uint64_t)"parse_copier_destination_options",  "kBOMCopierDestinationKeptFileDirectoryKey must be a CFStringRef");
            goto LABEL_319;
          }

          CFIndex v66 = CFStringGetLength(v65) + 1;
          uint64_t v67 = (char *)calloc(1uLL, v66);
          *((void *)v6 + 43) = v67;
          if (!v67)
          {
            BOMCopierErrorCapture( a3,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  3185,  (uint64_t)"parse_copier_destination_options",  "Could not allocate %ld bytes for kept file directory");
            goto LABEL_319;
          }

          if (!CFStringGetCString(v65, v67, v66, 0x8000100u))
          {
            BOMCopierErrorCapture( a3,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  3192,  (uint64_t)"parse_copier_destination_options",  "Could not convert kept_file_directory string to C string");
            goto LABEL_319;
          }
        }

        uint64_t v68 = CFDictionaryGetValue(a2, @"balanceKeptFiles");
        if (v68)
        {
          size_t v69 = v68;
          if (TypeID != CFGetTypeID(v68))
          {
            BOMCopierErrorCapture( a3,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  3202,  (uint64_t)"parse_copier_destination_options",  "kBOMCopierDestinationBalanceKeptFilesKey must be a CFBooleanRef");
            goto LABEL_319;
          }

          int v70 = CFEqual((CFTypeRef)*MEMORY[0x189604DE8], v69);
          v6[352] = v70 != 0;
          if (v70) {
            *((_DWORD *)v6 + 89) = 100;
          }
        }

        int v71 = (const __CFNumber *)CFDictionaryGetValue(a2, @"keptFileBalanceLimit");
        if (v71)
        {
          uint64_t v72 = v71;
          if (v16 != CFGetTypeID(v71))
          {
            BOMCopierErrorCapture( a3,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  3219,  (uint64_t)"parse_copier_destination_options",  "kBOMCopierDestinationKeptFileBalanceLimitKey must be a CFNumberRef");
            goto LABEL_319;
          }

          valuePtr[0].st_dev = -1;
          if (!CFNumberGetValue(v72, kCFNumberSInt32Type, valuePtr))
          {
            BOMCopierErrorCapture( a3,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  3227,  (uint64_t)"parse_copier_destination_options",  "Could not convert the kept file balance limit to kCFNumberSInt32Type");
            goto LABEL_319;
          }

          if (valuePtr[0].st_dev <= 0)
          {
            BOMCopierErrorCapture( a3,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  3233,  (uint64_t)"parse_copier_destination_options",  "%d is out of range for kept file balance limit");
            goto LABEL_319;
          }

          *((_DWORD *)v6 + 89) = valuePtr[0].st_dev;
        }

        uint64_t v73 = (const __CFNumber *)CFDictionaryGetValue(a2, @"zlibCompressionLevel");
        if (v73)
        {
          int v74 = v73;
          if (v16 != CFGetTypeID(v73))
          {
            BOMCopierErrorCapture( a3,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  3246,  (uint64_t)"parse_copier_destination_options",  "kBOMCopierDestinationOptionZlibCompressionLevel must be a CFNumberRef");
            goto LABEL_319;
          }

          valuePtr[0].st_dev = -1;
          if (!CFNumberGetValue(v74, kCFNumberSInt32Type, valuePtr))
          {
            BOMCopierErrorCapture( a3,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  3254,  (uint64_t)"parse_copier_destination_options",  "Could not convert the zlib compression level to kCFNumberSInt32Type");
            goto LABEL_319;
          }

          if ((valuePtr[0].st_dev - 10) <= 0xFFFFFFF4)
          {
            BOMCopierErrorCapture( a3,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  3260,  (uint64_t)"parse_copier_destination_options",  "%d is out of range for Zlib compression");
            goto LABEL_319;
          }

          *((_DWORD *)v6 + 36) = valuePtr[0].st_dev;
        }

        int v75 = CFDictionaryGetValue(a2, @"symlinkTreatment");
        if (v75)
        {
          int v76 = v75;
          if (CFGetTypeID(v75) != v22)
          {
            BOMCopierErrorCapture( a3,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  3276,  (uint64_t)"parse_copier_destination_options",  "kBOMCopierDestinationOptionSymlinkTreatmentKey is not a CFStringRef");
            goto LABEL_319;
          }

          if (CFEqual(v76, @"unlink"))
          {
            int v77 = 1;
          }

          else if (CFEqual(v76, @"follow"))
          {
            int v77 = 2;
          }

          else
          {
            if (!CFEqual(v76, @"error"))
            {
              BOMCopierErrorCapture( a3,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  3291,  (uint64_t)"parse_copier_destination_options",  "Unknown value for kBOMCopierOptionSymlinkTreatmentKey");
              goto LABEL_319;
            }

            int v77 = 0;
          }

          *((_DWORD *)v6 + 70) = v77;
        }

        uint64_t v78 = CFDictionaryGetValue(a2, @"persistRestrictedFlags");
        if (v78)
        {
          CFTypeID v79 = v78;
          if (TypeID != CFGetTypeID(v78))
          {
            BOMCopierErrorCapture( a3,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  3301,  (uint64_t)"parse_copier_destination_options",  "kBOMCopierDestinationPersistRestrictedFlags must be a CFBooleanRef");
            goto LABEL_319;
          }

          v6[303] = CFEqual((CFTypeRef)*MEMORY[0x189604DE8], v79) != 0;
        }

        uint64_t v80 = CFDictionaryGetValue(a2, @"preserveRestrictedFlags");
        if (v80)
        {
          int v81 = v80;
          if (TypeID != CFGetTypeID(v80))
          {
            BOMCopierErrorCapture( a3,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  3313,  (uint64_t)"parse_copier_destination_options",  "kBOMCopierDestinationPreserveRestrictedFlags must be a CFBooleanRef");
            goto LABEL_319;
          }

          v6[302] = CFEqual((CFTypeRef)*MEMORY[0x189604DE8], v81) != 0;
        }

        BOOL v82 = CFDictionaryGetValue(a2, @"persistRootless");
        if (v82)
        {
          uint64_t v83 = v82;
          if (TypeID != CFGetTypeID(v82))
          {
            BOMCopierErrorCapture( a3,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  3325,  (uint64_t)"parse_copier_destination_options",  "kBOMCopierDestinationOptionPersistRootlessExtendedAttribute must be a CFBooleanRef");
            goto LABEL_319;
          }

          v6[301] = CFEqual((CFTypeRef)*MEMORY[0x189604DE8], v83) != 0;
        }

        uint64_t v84 = (const __CFNumber *)CFDictionaryGetValue(a2, @"initialInode");
        if (v84)
        {
          __int16 v85 = v84;
          if (v16 != CFGetTypeID(v84))
          {
            BOMCopierErrorCapture( a3,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  3337,  (uint64_t)"parse_copier_destination_options",  "kBOMCopierDestinationOptionInitialInodeKey must be a CFNumberRef");
            goto LABEL_319;
          }

          *(void *)&valuePtr[0].st_dev = -1LL;
          if (!CFNumberGetValue(v85, kCFNumberLongLongType, valuePtr))
          {
            BOMCopierErrorCapture( a3,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  3345,  (uint64_t)"parse_copier_destination_options",  "Could not convert kBOMCopierDestinationOptionInitialInodeKey to kCFNumberLongLongType");
            goto LABEL_319;
          }

          *((void *)v6 + 8) = *(void *)&valuePtr[0].st_dev;
        }

        char v86 = CFDictionaryGetValue(a2, @"skipTerminator");
        if (v86)
        {
          uint64_t v87 = v86;
          if (TypeID != CFGetTypeID(v86))
          {
            BOMCopierErrorCapture( a3,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  3357,  (uint64_t)"parse_copier_destination_options",  "kBOMCopierDestinationOptionSkipCPIOTerminatorKey must be a CFBooleanRef");
            goto LABEL_319;
          }

          v6[148] = CFEqual((CFTypeRef)*MEMORY[0x189604DE8], v87) != 0;
        }

        CFIndex v88 = (const __CFNumber *)CFDictionaryGetValue(a2, @"segmentFileSize");
        if (v88)
        {
          size_t v89 = v88;
          if (v16 != CFGetTypeID(v88))
          {
            BOMCopierErrorCapture( a3,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  3369,  (uint64_t)"parse_copier_destination_options",  "kBOMCopierDestinationOptionSegmentFileSizeKey must be a CFNumberRef");
            goto LABEL_319;
          }

          *(void *)&valuePtr[0].st_dev = -1LL;
          if (!CFNumberGetValue(v89, kCFNumberLongLongType, valuePtr))
          {
            BOMCopierErrorCapture( a3,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  3377,  (uint64_t)"parse_copier_destination_options",  "Could not convert kBOMCopierDestinationOptionSegmentFileSizeKey to kCFNumberLongLongType");
            goto LABEL_319;
          }

          *((void *)v6 + 19) = *(void *)&valuePtr[0].st_dev;
        }

        uint64_t v90 = CFDictionaryGetValue(a2, @"appleDoubleMergeACLs");
        if (v90)
        {
          char v91 = v90;
          if (TypeID != CFGetTypeID(v90))
          {
            BOMCopierErrorCapture( a3,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  3389,  (uint64_t)"parse_copier_destination_options",  "kBOMCopierDestinationOptionAppleDoubleMergeACLsKey must be a CFBooleanRef");
            goto LABEL_319;
          }

          v6[160] = CFEqual((CFTypeRef)*MEMORY[0x189604DE8], v91) != 0;
        }

        uint64_t v92 = CFDictionaryGetValue(a2, @"cloneFiles");
        if (v92)
        {
          uint64_t v93 = v92;
          if (TypeID != CFGetTypeID(v92))
          {
            BOMCopierErrorCapture( a3,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  3401,  (uint64_t)"parse_copier_destination_options",  "kBOMCopierDestinationOptionCloneFilesKey must be a CFBooleanRef");
            goto LABEL_319;
          }

          v6[304] = CFEqual((CFTypeRef)*MEMORY[0x189604DE8], v93) != 0;
        }

        uint64_t v94 = CFDictionaryGetValue(a2, @"removeSetuidPermissions");
        if (v94)
        {
          int v95 = v94;
          if (TypeID != CFGetTypeID(v94))
          {
            BOMCopierErrorCapture( a3,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  3413,  (uint64_t)"parse_copier_destination_options",  "kBOMCopierDestinationOptionRemoveSetuidPermissionsKey must be a CFBooleanRef");
            goto LABEL_319;
          }

          v6[305] = CFEqual((CFTypeRef)*MEMORY[0x189604DE8], v95) != 0;
        }

        CFIndex v96 = CFDictionaryGetValue(a2, @"removeExecutablePermissions");
        if (v96)
        {
          uint64_t v97 = v96;
          if (TypeID != CFGetTypeID(v96))
          {
            BOMCopierErrorCapture( a3,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  3425,  (uint64_t)"parse_copier_destination_options",  "kBOMCopierDestinationOptionRemoveExecutablePermissionsKey must be a CFBooleanRef");
            goto LABEL_319;
          }

          v6[306] = CFEqual((CFTypeRef)*MEMORY[0x189604DE8], v97) != 0;
        }

        uint64_t v98 = CFDictionaryGetValue(a2, @"setStaticContent");
        if (v98)
        {
          int v99 = v98;
          if (TypeID != CFGetTypeID(v98))
          {
            BOMCopierErrorCapture( a3,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  3437,  (uint64_t)"parse_copier_destination_options",  "kBOMCopierDestinationOptionSetStaticContentKey must be a CFBooleanRef");
            goto LABEL_319;
          }

          v6[41] = CFEqual((CFTypeRef)*MEMORY[0x189604DE8], v99) != 0;
        }

        uint64_t v100 = CFDictionaryGetValue(a2, @"setSingleWriter");
        if (v100)
        {
          uint64_t v101 = v100;
          if (TypeID != CFGetTypeID(v100))
          {
            BOMCopierErrorCapture( a3,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  3449,  (uint64_t)"parse_copier_destination_options",  "kBOMCopierDestinationOptionSetSingleWriterKey must be a CFBooleanRef");
            goto LABEL_319;
          }

          v6[42] = CFEqual((CFTypeRef)*MEMORY[0x189604DE8], v101) != 0;
        }

        uint64_t v102 = CFDictionaryGetValue(a2, @"setDataProtectionClass");
        if (v102)
        {
          uint64_t v103 = v102;
          if (v22 != CFGetTypeID(v102))
          {
            BOMCopierErrorCapture( a3,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  3461,  (uint64_t)"parse_copier_destination_options",  "kBOMCopierDestinationOptionSetDataProtectionClassKey must be a CFStringRef");
            goto LABEL_319;
          }

          int v104 = CFEqual(v103, @"A");
          int v105 = 1;
          if (v104 != 1)
          {
            if (CFEqual(v103, @"B") == 1)
            {
              int v105 = 2;
            }

            else if (CFEqual(v103, @"C") == 1)
            {
              int v105 = 3;
            }

            else
            {
              if (CFEqual(v103, @"D") != 1)
              {
                BOMCopierErrorCapture( a3,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  3479,  (uint64_t)"parse_copier_destination_options",  "Unsupported data protection class");
                goto LABEL_319;
              }

              int v105 = 4;
            }
          }

          *((_DWORD *)v6 + 4) = v105;
          v6[12] = 1;
        }

        CFTypeID v106 = CFDataGetTypeID();
        stat v107 = (const __CFData *)CFDictionaryGetValue(a2, @"applyProvenance");
        if (!v107) {
          goto LABEL_249;
        }
        int v108 = v107;
        if (v106 == CFGetTypeID(v107))
        {
          size_t Length = CFDataGetLength(v108);
          if (Length)
          {
            size_t v110 = Length;
            v111 = malloc(Length);
            if (v111)
            {
              v112 = v111;
              BytePtr = CFDataGetBytePtr(v108);
              memcpy(v112, BytePtr, v110);
              *((void *)v6 + 3) = v112;
              *((void *)v6 + 4) = v110;
              goto LABEL_249;
            }

            int v167 = *__error();
            BOMCopierErrorCapture( a3,  v167,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  3508,  (uint64_t)"parse_copier_destination_options",  "Could not allocate provenance data buffer");
          }

          else
          {
            BOMCopierErrorCapture( a3,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  3501,  (uint64_t)"parse_copier_destination_options",  "kBOMCopierOptionApplyProvenanceKey has an invalid size");
          }
        }

        else
        {
          BOMCopierErrorCapture( a3,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  3493,  (uint64_t)"parse_copier_destination_options",  "kBOMCopierDestinationOptionApplyProvenanceKey must be a CFDataRef");
        }

LABEL_319:
        BOMCopierDestinationFree((unsigned int *)v6);
        return 0LL;
      }

      int v63 = *__error();
      BOMCopierErrorCapture( a3,  v63,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  3154,  (uint64_t)"parse_copier_destination_options",  "Could not allocate regular expression");
    }

    else
    {
      BOMCopierErrorCapture( a3,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  3146,  (uint64_t)"parse_copier_destination_options",  "Could not convert enumeration_bom_path string to C string");
    }

    int v62 = buffer;
    goto LABEL_140;
  }

  if (a2) {
    goto LABEL_14;
  }
LABEL_249:
  switch(*((_DWORD *)v6 + 11))
  {
    case 0:
      int v114 = stat(__s, &v172);
      if (v114)
      {
        int v115 = v114;
        if (*__error() != 2)
        {
          int v124 = *__error();
          int v125 = __error();
          strerror(*v125);
          BOMCopierErrorCapture( a3,  v124,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  711,  (uint64_t)"BOMCopierDestinationNew",  "Could not stat %s: %s");
          goto LABEL_319;
        }

        v6[284] = 0;
        if (dirname_r(__s, (char *)valuePtr) != (char *)valuePtr)
        {
          v116 = __error();
          strerror(*v116);
          BOMCopierErrorCapture( a3,  v115,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  767,  (uint64_t)"BOMCopierDestinationNew",  "Could not dirname %s: %s");
          goto LABEL_319;
        }

        if (basename_r(__s, v173) != v173)
        {
          v132 = __error();
          strerror(*v132);
          BOMCopierErrorCapture( a3,  v115,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  777,  (uint64_t)"BOMCopierDestinationNew",  "Could not basename %s: %s");
          goto LABEL_319;
        }

        if (make_path(0LL, (char *)valuePtr, a3))
        {
          BOMCopierErrorCapture( a3,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  785,  (uint64_t)"BOMCopierDestinationNew",  "Could not make the parent_path %s");
          goto LABEL_319;
        }

        v155 = realpath_DARWIN_EXTSN((const char *)valuePtr, 0LL);
        if (!v155)
        {
          v161 = __error();
          strerror(*v161);
          BOMCopierErrorCapture( a3,  0,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  793,  (uint64_t)"BOMCopierDestinationNew",  "Could not realpath %s: %s");
          goto LABEL_319;
        }

        AAArchiveStream v156 = v155;
        char v171 = 0;
        __int16 v170 = 0;
        if (get_volume_state(v155, (BOOL *)&v170, a3))
        {
          int v157 = __error();
          strerror(*v157);
          BOMCopierErrorCapture( a3,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  814,  (uint64_t)"BOMCopierDestinationNew",  "Could not get volume state for %s: %s");
          goto LABEL_319;
        }

        if (v6[12]) {
          v6[12] = v170;
        }
        v6[20] = HIBYTE(v170);
        v6[300] = v171;
        asprintf((char **)v6 + 36, "%s/%s", v156, v173);
        free(v156);
        if (!*((void *)v6 + 36))
        {
          v163 = __error();
          strerror(*v163);
          BOMCopierErrorCapture( a3,  0,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  839,  (uint64_t)"BOMCopierDestinationNew",  "Could not construct resolve path from %s and %s: %s",  v156);
          goto LABEL_319;
        }
      }

      else
      {
        v6[285] = (v172.st_mode & 0xF000) == 0x4000;
        if (v6[299])
        {
          if (lstat(__s, valuePtr))
          {
            int v122 = *__error();
            uint64_t v123 = __error();
            strerror(*v123);
            BOMCopierErrorCapture( a3,  v122,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  733,  (uint64_t)"BOMCopierDestinationNew",  "Could not stat %s: %s");
            goto LABEL_319;
          }

          if ((valuePtr[0].st_mode & 0xF000) == 0xA000 && valuePtr[0].st_dev != v172.st_dev)
          {
            int v150 = *__error();
            int v151 = __error();
            strerror(*v151);
            BOMCopierErrorCapture( a3,  v150,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  742,  (uint64_t)"BOMCopierDestinationNew",  "%s exists on a different device from its target");
            goto LABEL_319;
          }
        }

        v6[284] = 1;
        uint64_t v133 = realpath_DARWIN_EXTSN(__s, 0LL);
        if (!v133)
        {
          int v140 = __error();
          strerror(*v140);
          BOMCopierErrorCapture( a3,  0,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  849,  (uint64_t)"BOMCopierDestinationNew",  "Could not realpath %s: %s");
          goto LABEL_319;
        }

        *((void *)v6 + 36) = v133;
        BYTE2(valuePtr[0].st_dev) = 0;
        LOWORD(valuePtr[0].st_dev) = 0;
        int volume_state = get_volume_state(v133, (BOOL *)valuePtr, a3);
        if (volume_state)
        {
          int v135 = volume_state;
          int v136 = __error();
          strerror(*v136);
          BOMCopierErrorCapture( a3,  v135,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  872,  (uint64_t)"BOMCopierDestinationNew",  "Could not get volume state for %s: %s");
          goto LABEL_319;
        }

        if (v6[12]) {
          v6[12] = valuePtr[0].st_dev;
        }
        v6[20] = BYTE1(valuePtr[0].st_dev);
        v6[300] = BYTE2(valuePtr[0].st_dev);
      }

      break;
    case 1:
      uint64_t v118 = archive_write_new();
      *((void *)v6 + 17) = v118;
      if (!v118)
      {
        BOMCopierErrorCapture( a3,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  902,  (uint64_t)"BOMCopierDestinationNew",  "Could not create archive");
        goto LABEL_319;
      }

      int v119 = archive_write_set_format();
      if (v119)
      {
        int v120 = archive_errno();
        strerror(v120);
        BOMCopierErrorCapture( a3,  v119,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  910,  (uint64_t)"BOMCopierDestinationNew",  "Could not set archive format: %s");
        goto LABEL_319;
      }

      int v126 = archive_write_add_filter();
      if (v126)
      {
        int v127 = v126;
        int v128 = archive_errno();
        strerror(v128);
        BOMCopierErrorCapture( a3,  v127,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  918,  (uint64_t)"BOMCopierDestinationNew",  "Could not set archive filter: %s");
        goto LABEL_319;
      }

      if (*((_DWORD *)v6 + 32) == 1 && *((_DWORD *)v6 + 36) != -1)
      {
        snprintf((char *)valuePtr, 0xFFuLL, "%d", *((_DWORD *)v6 + 36));
        int v137 = archive_write_set_filter_option();
        if (v137)
        {
          int v138 = v137;
          int v139 = archive_errno();
          strerror(v139);
          BOMCopierErrorCapture( a3,  v138,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  937,  (uint64_t)"BOMCopierDestinationNew",  "Could not set zlib compression level %s: %s");
          goto LABEL_319;
        }
      }

      if (*((_DWORD *)v6 + 31) == 327680 && *((_DWORD *)v6 + 36) != -1)
      {
        snprintf((char *)valuePtr, 0xFFuLL, "%d", *((_DWORD *)v6 + 36));
        int v141 = archive_write_set_format_option();
        if (v141)
        {
          int v142 = v141;
          int v143 = archive_errno();
          strerror(v143);
          BOMCopierErrorCapture( a3,  v142,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  954,  (uint64_t)"BOMCopierDestinationNew",  "Could not set PKZip compression level %s: %s (%d)",  valuePtr);
          goto LABEL_319;
        }
      }

      if (*((void *)v6 + 8))
      {
        snprintf((char *)valuePtr, 0xFFuLL, "%lld", *((void *)v6 + 8));
        int v144 = archive_write_set_format_option();
        if (v144)
        {
          int v145 = v144;
          int v146 = archive_errno();
          strerror(v146);
          BOMCopierErrorCapture( a3,  v145,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  971,  (uint64_t)"BOMCopierDestinationNew",  "Could not set cpio starting inode %s: %s");
          goto LABEL_319;
        }
      }

      if (v6[148])
      {
        int v147 = archive_write_set_format_option();
        if (v147)
        {
          int v148 = v147;
          int v149 = archive_errno();
          strerror(v149);
          BOMCopierErrorCapture( a3,  v148,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  984,  (uint64_t)"BOMCopierDestinationNew",  "Could not enable cpio skip trailer %s");
          goto LABEL_319;
        }
      }

      if (__s)
      {
        int v152 = archive_write_open_filename();
        if (v152)
        {
          int v153 = v152;
          int v154 = archive_errno();
          strerror(v154);
          BOMCopierErrorCapture( a3,  v153,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  999,  (uint64_t)"BOMCopierDestinationNew",  "Could not archive_write_open_filename %s: %s\n");
          goto LABEL_319;
        }
      }

      else if (*((void *)v6 + 7))
      {
        int v158 = archive_write_open2();
        if (v158)
        {
          int v159 = v158;
          int v160 = archive_errno();
          strerror(v160);
          BOMCopierErrorCapture( a3,  v159,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  1028,  (uint64_t)"BOMCopierDestinationNew",  "Could not archive_write_open2 %s: %s\n");
          goto LABEL_319;
        }
      }

      else
      {
        if (*((_DWORD *)v6 + 12) == -1)
        {
          BOMCopierErrorCapture( a3,  0,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  1036,  (uint64_t)"BOMCopierDestinationNew",  "No output file descriptor\n",  v168);
          goto LABEL_319;
        }

        int v164 = archive_write_open_fd();
        if (v164)
        {
          int v165 = v164;
          int v166 = archive_errno();
          strerror(v166);
          BOMCopierErrorCapture( a3,  v165,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  1044,  (uint64_t)"BOMCopierDestinationNew",  "Could not archive_write_open_fd %s: %s\n");
          goto LABEL_319;
        }
      }

      break;
    case 2:
      if (__s)
      {
        uint32_t v117 = AAFileStreamOpenWithPath(__s, 1537, 0x1A4u);
        *((void *)v6 + 21) = v117;
        if (!v117)
        {
          BOMCopierErrorCapture( a3,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  1063,  (uint64_t)"BOMCopierDestinationNew",  "Could not create AppleArchive byte stream at %s\n");
          goto LABEL_319;
        }
      }

      else if (*((void *)v6 + 7))
      {
        uint64_t v121 = AACustomByteStreamOpen();
        *((void *)v6 + 21) = v121;
        if (!v121)
        {
          BOMCopierErrorCapture( a3,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  1079,  (uint64_t)"BOMCopierDestinationNew",  "Could not create custom AppleArchive byte stream at %s\n");
          goto LABEL_319;
        }

        AACustomByteStreamSetData(v121, v6);
        AACustomByteStreamSetCloseProc( *((AAByteStream *)v6 + 21),  (AAByteStreamCloseProc)apple_archive_close_callback_0);
        AACustomByteStreamSetWriteProc(*((AAByteStream *)v6 + 21), (AAByteStreamWriteProc)apple_archive_write_callback);
        uint32_t v117 = (AAByteStream_impl *)*((void *)v6 + 21);
      }

      else
      {
        int v129 = *((_DWORD *)v6 + 12);
        if (v129 == -1)
        {
          BOMCopierErrorCapture( a3,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  1091,  (uint64_t)"BOMCopierDestinationNew",  "No output file descriptor\n");
          goto LABEL_319;
        }

        uint32_t v117 = AAFileStreamOpenWithFD(v129, 0);
        *((void *)v6 + 21) = v117;
        if (!v117)
        {
          BOMCopierErrorCapture( a3,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  1099,  (uint64_t)"BOMCopierDestinationNew",  "Could not create AppleArchive byte stream from file descriptor\n");
          goto LABEL_319;
        }
      }

      uint64_t v130 = AACompressionOutputStreamOpen(v117, *((_DWORD *)v6 + 41), 0x100000uLL, 0LL, 0);
      *((void *)v6 + 22) = v130;
      if (!v130)
      {
        BOMCopierErrorCapture( a3,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  1118,  (uint64_t)"BOMCopierDestinationNew",  "Could not create AppleArchive compression stream\n");
        goto LABEL_319;
      }

      AAArchiveStream v131 = AAEncodeArchiveOutputStreamOpen(v130, 0LL, 0LL, 0LL, 0);
      *((void *)v6 + 23) = v131;
      if (!v131)
      {
        BOMCopierErrorCapture( a3,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  1132,  (uint64_t)"BOMCopierDestinationNew",  "Could not create AppleArchive encoder\n");
        goto LABEL_319;
      }

      break;
    case 3:
      if (__s)
      {
        BOMCopierErrorCapture( a3,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  1143,  (uint64_t)"BOMCopierDestinationNew",  "I expect path to be NULL for nowhere destinations");
        goto LABEL_319;
      }

      break;
    default:
      return v6;
  }

  return v6;
}

void BOMCopierDestinationFree(unsigned int *a1)
{
  if (!a1)
  {
    fwrite("copier_destination is NULL", 0x1AuLL, 1uLL, (FILE *)*MEMORY[0x1895F89D0]);
    return;
  }

  unint64_t v2 = (void *)*((void *)a1 + 3);
  if (v2) {
    free(v2);
  }
  uint64_t v3 = (void *)*((void *)a1 + 45);
  if (v3) {
    free(v3);
  }
  uint64_t v4 = (void *)*((void *)a1 + 43);
  if (v4) {
    free(v4);
  }
  if (*((void *)a1 + 42))
  {
    MEMORY[0x186E383EC]();
    free(*((void **)a1 + 42));
  }

  int v5 = a1[82];
  if (v5 != -1) {
    close(v5);
  }
  int v6 = (void *)*((void *)a1 + 40);
  if (v6) {
    free(v6);
  }
  size_t v7 = (void *)*((void *)a1 + 36);
  if (v7) {
    free(v7);
  }
  uint64_t v8 = (void *)*((void *)a1 + 25);
  if (v8)
  {
    unint64_t v9 = a1[48];
    if ((_DWORD)v9)
    {
      unint64_t v10 = 0LL;
      uint64_t v11 = 16LL;
      do
      {
        __int128 v12 = *(void **)(*((void *)a1 + 25) + v11);
        if (v12)
        {
          free(v12);
          unint64_t v9 = a1[48];
        }

        ++v10;
        v11 += 32LL;
      }

      while (v10 < v9);
      uint64_t v8 = (void *)*((void *)a1 + 25);
    }

    free(v8);
  }

  uint64_t v13 = (AAArchiveStream_impl *)*((void *)a1 + 23);
  if (v13)
  {
    uint64_t v14 = (char *)AAArchiveStreamClose(v13);
    if ((_DWORD)v14)
    {
      uint64_t v15 = (FILE *)*MEMORY[0x1895F89D0];
      char v27 = v14;
      CFTypeID v16 = "Could not close AppleArchive encoder: %d\n";
LABEL_34:
      uint64_t v21 = v15;
LABEL_35:
      fprintf(v21, v16, v27);
      return;
    }
  }

  uint64_t v17 = (AAByteStream_impl *)*((void *)a1 + 22);
  if (v17)
  {
    size_t v18 = (char *)AAByteStreamClose(v17);
    if ((_DWORD)v18)
    {
      uint64_t v15 = (FILE *)*MEMORY[0x1895F89D0];
      char v27 = v18;
      CFTypeID v16 = "Could not close AppleArchive compression stream: %d\n";
      goto LABEL_34;
    }
  }

  uint64_t v19 = (AAByteStream_impl *)*((void *)a1 + 21);
  if (v19)
  {
    BOOL v20 = (char *)AAByteStreamClose(v19);
    if ((_DWORD)v20)
    {
      uint64_t v15 = (FILE *)*MEMORY[0x1895F89D0];
      char v27 = v20;
      CFTypeID v16 = "Could not close AppleArchive byte stream: %d\n";
      goto LABEL_34;
    }
  }

  if (*((void *)a1 + 17))
  {
    if (archive_write_close())
    {
      CFTypeID v22 = (FILE *)*MEMORY[0x1895F89D0];
      int v23 = archive_errno();
      char v27 = strerror(v23);
      CFTypeID v16 = "Could not close archive %s\n";
LABEL_41:
      uint64_t v21 = v22;
      goto LABEL_35;
    }

    if (archive_write_free())
    {
      CFTypeID v22 = (FILE *)*MEMORY[0x1895F89D0];
      int v24 = archive_errno();
      char v27 = strerror(v24);
      CFTypeID v16 = "Could not free archive: %s\n";
      goto LABEL_41;
    }
  }

  int v25 = (void *)*((void *)a1 + 13);
  if (v25)
  {
    BOMCopierDataAnalyzerFree(v25);
    *((void *)a1 + 13) = 0LL;
  }

  uint64_t v26 = (const void **)*((void *)a1 + 9);
  if (v26) {
    BOMHardLinkTableFree(v26);
  }
  free(a1);
}

uint64_t make_path(os_log_s *a1, char *__s1, void *a3)
{
  uint64_t v23 = *MEMORY[0x1895F89C0];
  int v6 = strdup(__s1);
  if (!v6)
  {
    int v15 = *__error();
    CFTypeID v16 = __error();
    uint64_t v17 = strerror(*v16);
    BOMCopierErrorCapture( a3,  v15,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  3538,  (uint64_t)"make_path",  "Could not duplicate %s: %s",  __s1,  v17);
    return 1LL;
  }

  size_t v7 = v6;
  int v8 = *v6;
  BOOL v9 = v8 == 47;
  if (v8 == 47) {
    ++v6;
  }
  unint64_t v10 = strchr(v6, 47);
  if (!v10)
  {
LABEL_13:
    if (mkdir(v7, 0x1EDu))
    {
      if (*__error() != 17)
      {
        int v13 = *__error();
        uint64_t v14 = __error();
        strerror(*v14);
        BOMCopierErrorCapture( a3,  v13,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  3599,  (uint64_t)"make_path",  "Could not mkdir %s: %s");
        goto LABEL_22;
      }
    }

    else if (a1)
    {
      if (os_log_type_enabled(a1, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)statfs buf = 136315138;
        CFTypeID v22 = v7;
        _os_log_impl(&dword_1862F3000, a1, OS_LOG_TYPE_DEFAULT, "Created directory %s", buf, 0xCu);
      }
    }

    free(v7);
    return 0LL;
  }

  uint64_t v11 = v10;
  __int128 v12 = &v7[v9 + 1];
  while (1)
  {
    *uint64_t v11 = 0;
    if (!mkdir(v7, 0x1EDu))
    {
      if (a1 && os_log_type_enabled(a1, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)statfs buf = 136315138;
        CFTypeID v22 = v7;
        _os_log_impl(&dword_1862F3000, a1, OS_LOG_TYPE_DEFAULT, "Created directory %s", buf, 0xCu);
      }

      goto LABEL_8;
    }

    if (*__error() != 17) {
      break;
    }
LABEL_8:
    *uint64_t v11 = 47;
    uint64_t v11 = strchr(v12++, 47);
    if (!v11) {
      goto LABEL_13;
    }
  }

  int v19 = *__error();
  BOOL v20 = __error();
  strerror(*v20);
  BOMCopierErrorCapture( a3,  v19,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  3562,  (uint64_t)"make_path",  "Could not mkdir %s: %s");
LABEL_22:
  free(v7);
  return 1LL;
}

uint64_t get_volume_state(const char *a1, BOOL *a2, void *a3)
{
  uint64_t v17 = *MEMORY[0x1895F89C0];
  if (!statfs(a1, &v16))
  {
    char f_flags = v16.f_flags;
    *a2 = (v16.f_flags & 0x80) != 0;
    a2[1] = (f_flags & 8) == 0;
    __int128 v14 = xmmword_18635ACC0;
    int v15 = 0;
    __int128 v12 = xmmword_18635ACD4;
    uint64_t v13 = 0LL;
    if (getattrlist(a1, &v12, &v14, 0x14uLL, 0))
    {
      if (*__error() != 22)
      {
        int v10 = *__error();
        uint64_t v11 = __error();
        strerror(*v11);
        BOMCopierErrorCapture( a3,  v10,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  8658,  (uint64_t)"get_volume_state",  "Could not getattrlist %s: %s\n");
        return 1LL;
      }

      if (*(_DWORD *)v16.f_fstypename == 7562856) {
        a2[2] = 1;
      }
    }

    else if ((BYTE6(v14) & 1) == 0)
    {
      return 0LL;
    }

    uint64_t result = 0LL;
    a2[2] = 1;
    return result;
  }

  int v6 = *__error();
  size_t v7 = __error();
  strerror(*v7);
  BOMCopierErrorCapture( a3,  v6,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  8629,  (uint64_t)"get_volume_state",  "Could not statfs %s: %s");
  return 1LL;
}

uint64_t libarchive_open_callback_0()
{
  return 0LL;
}

CFIndex libarchive_write_callback(int a1, uint64_t a2, UInt8 *buffer, CFIndex bufferLength)
{
  if (a2) {
    return CFWriteStreamWrite(*(CFWriteStreamRef *)(a2 + 56), buffer, bufferLength);
  }
  else {
    return -1LL;
  }
}

uint64_t libarchive_close_callback_0()
{
  return 0LL;
}

uint64_t libarchive_free_callback()
{
  return 0LL;
}

uint64_t apple_archive_close_callback_0()
{
  return 0LL;
}

CFIndex apple_archive_write_callback(uint64_t a1, const UInt8 *a2, CFIndex a3)
{
  if (a1) {
    return CFWriteStreamWrite(*(CFWriteStreamRef *)(a1 + 56), a2, a3);
  }
  else {
    return -1LL;
  }
}

void *BOMCopierDestinationSetLog(void *result, uint64_t a2)
{
  if (result)
  {
    if (a2) {
      *uint64_t result = a2;
    }
  }

  return result;
}

uint64_t BOMCopierDestinationSetAllowBom(uint64_t a1, uint64_t a2, void *a3)
{
  if (a1)
  {
    uint64_t v3 = 0LL;
    *(void *)(a1 + 80) = a2;
  }

  else
  {
    uint64_t v3 = 22LL;
    BOMCopierErrorCapture( a3,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  1304,  (uint64_t)"BOMCopierDestinationSetAllowBom",  "copier_destination is NULL");
  }

  return v3;
}

uint64_t BOMCopierDestinationSetDenyBom(uint64_t a1, uint64_t a2, void *a3)
{
  if (a1)
  {
    uint64_t v3 = 0LL;
    *(void *)(a1 + 88) = a2;
  }

  else
  {
    uint64_t v3 = 22LL;
    BOMCopierErrorCapture( a3,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  1326,  (uint64_t)"BOMCopierDestinationSetDenyBom",  "copier_destination is NULL");
  }

  return v3;
}

uint64_t BOMCopierDestinationSetChecksumBom(uint64_t a1, uint64_t a2, void *a3)
{
  if (a1)
  {
    *(void *)(a1 + 96) = a2;
    if (!a2) {
      return 0LL;
    }
    if (*(void *)(a1 + 104)) {
      return 0LL;
    }
    int v5 = BOMCopierDataAnalyzerNew(2, a3);
    *(void *)(a1 + 104) = v5;
    if (v5)
    {
      return 0LL;
    }

    else
    {
      uint64_t v6 = 1LL;
      BOMCopierErrorCapture( a3,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  1365,  (uint64_t)"BOMCopierDestinationSetChecksumBom",  "Could not create BOMCopierDataAnalyzer");
    }
  }

  else
  {
    uint64_t v6 = 22LL;
    BOMCopierErrorCapture( a3,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  1348,  (uint64_t)"BOMCopierDestinationSetChecksumBom",  "copier_destination is NULL");
  }

  return v6;
}

uint64_t BOMCopierDestinationSetRedirectCallback(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  if (a1)
  {
    uint64_t v4 = 0LL;
    *(void *)(a1 + 208) = a2;
    *(void *)(a1 + 216) = a3;
  }

  else
  {
    uint64_t v4 = 22LL;
    BOMCopierErrorCapture( a4,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  1387,  (uint64_t)"BOMCopierDestinationSetRedirectCallback",  "copier_destination is NULL");
  }

  return v4;
}

uint64_t BOMCopierDestinationSetConflictResolver(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  if (a1)
  {
    uint64_t v4 = 0LL;
    *(void *)(a1 + 224) = a2;
    *(void *)(a1 + 232) = a3;
  }

  else
  {
    uint64_t v4 = 22LL;
    BOMCopierErrorCapture( a4,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  1410,  (uint64_t)"BOMCopierDestinationSetConflictResolver",  "copier_destination is NULL");
  }

  return v4;
}

uint64_t BOMCopierDestinationSetFinalizationCallback(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  if (a1)
  {
    uint64_t v4 = 0LL;
    *(void *)(a1 + 264) = a2;
    *(void *)(a1 + 272) = a3;
  }

  else
  {
    uint64_t v4 = 22LL;
    BOMCopierErrorCapture( a4,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  1433,  (uint64_t)"BOMCopierDestinationSetFinalizationCallback",  "copier_destination is NULL");
  }

  return v4;
}

uint64_t BOMCopierDestinationGetCopyOperation(uint64_t a1)
{
  if (a1) {
    return *(unsigned int *)(a1 + 240);
  }
  BOMCopierErrorCapture( 0LL,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  1453,  (uint64_t)"BOMCopierDestinationGetCopyOperation",  "copier_destination is NULL");
  return 2LL;
}

uint64_t BOMCopierDestinationGetCopyResult(uint64_t a1)
{
  if (a1) {
    return *(unsigned int *)(a1 + 244);
  }
  BOMCopierErrorCapture( 0LL,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  1470,  (uint64_t)"BOMCopierDestinationGetCopyResult",  "copier_destination is NULL");
  return 1LL;
}

uint64_t BOMCopierDestinationSetDataWrittenCallback(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  if (a1)
  {
    uint64_t v4 = 0LL;
    *(void *)(a1 + 248) = a2;
    *(void *)(a1 + 256) = a3;
  }

  else
  {
    uint64_t v4 = 22LL;
    BOMCopierErrorCapture( a4,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  1490,  (uint64_t)"BOMCopierDestinationSetDataWrittenCallback",  "copier_destination is NULL");
  }

  return v4;
}

uint64_t BOMCopierDestinationCreateEntry(uint64_t a1, uint64_t a2, char a3, void *a4)
{
  if (!a1)
  {
    BOMCopierErrorCapture( a4,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  1513,  (uint64_t)"BOMCopierDestinationCreateEntry",  "copier_destination is NULL");
    return 0LL;
  }

  if (!a2)
  {
    BOMCopierErrorCapture( a4,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  1519,  (uint64_t)"BOMCopierDestinationCreateEntry",  "source_entry is NULL");
    return 0LL;
  }

  if (*(void *)(a1 + 80) && !BOMCopierSourceEntryIsRoot(a2))
  {
    uint64_t Path = BOMCopierSourceEntryGetPath(a2);
    BOOL v8 = !BOMBomFSObjectExistsAtPath(*(void *)(a1 + 80), Path);
  }

  else
  {
    BOOL v8 = 0;
  }

  if (*(void *)(a1 + 88))
  {
    if (!BOMCopierSourceEntryIsRoot(a2))
    {
      uint64_t v10 = BOMCopierSourceEntryGetPath(a2);
      if (BOMBomFSObjectExistsAtPath(*(void *)(a1 + 88), v10)) {
        BOOL v8 = 1;
      }
    }
  }

  uint64_t v11 = calloc(1uLL, 0x178uLL);
  if (!v11)
  {
    int v13 = *__error();
    __int128 v14 = __error();
    strerror(*v14);
    BOMCopierErrorCapture( a4,  v13,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  1584,  (uint64_t)"BOMCopierDestinationCreateEntry",  "Could not allocate empty destination entry: %s");
    return 0LL;
  }

  uint64_t v12 = (uint64_t)v11;
  v11[8] = -1LL;
  *(_DWORD *)uint64_t v11 = *(_DWORD *)(a1 + 44);
  v11[1] = a2;
  if (!v8)
  {
    BOMCopierDataAnalyzerReset(*(uint64_t **)(a1 + 104));
    *(void *)(v12 + 24) = *(void *)(a1 + 104);
    *(_DWORD *)(v12 + 32) = 1;
    if (BOMCopierSourceEntryGetType(a2) == 8)
    {
      *(void *)(v12 + 56) = BOMCopierSourceEntryGetSize(a2);
      if (BOMCopierSourceEntryGetBinaryType(a2))
      {
        __int128 v19 = 0u;
        __int128 v20 = 0u;
        __int128 v18 = 0u;
        LODWORD(v18) = *(_DWORD *)(a1 + 192);
        *((void *)&v18 + 1) = *(void *)(a1 + 200);
        if (BOMCopierMatchBinary(a2, (unsigned int *)&v18, a4))
        {
          BOMCopierErrorCapture( a4,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  3647,  (uint64_t)"match_binary",  "Could not match the binary");
          BOMCopierErrorCapture( a4,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  1639,  (uint64_t)"BOMCopierDestinationCreateEntry",  "Could not match the source binary");
LABEL_33:
          BOMCopierDestinationEntryFree((void *)v12);
          return 0LL;
        }

        *(_OWORD *)(v12 + 32) = v19;
        *(_DWORD *)(v12 + 48) = v20;
        *(void *)(v12 + 56) = *((void *)&v20 + 1);
      }
    }

    if (*(_DWORD *)(v12 + 32) == 2) {
      return v12;
    }
    int v16 = *(_DWORD *)(a1 + 44);
    if (v16 == 2)
    {
      int entry_apple_archive = create_entry_apple_archive(a1, a2, v12, a4);
    }

    else if (v16 == 1)
    {
      int entry_apple_archive = create_entry_libarchive(a1, a2, (void *)v12, a4);
    }

    else
    {
      if (v16) {
        return v12;
      }
      int entry_apple_archive = create_entry_filesystem(a1, a2, v12, a3, a4);
    }

    if (!entry_apple_archive) {
      return v12;
    }
    BOMCopierErrorCapture( a4,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  1679,  (uint64_t)"BOMCopierDestinationCreateEntry",  "Could not create the entry");
    goto LABEL_33;
  }

  *((_BYTE *)v11 + 16) = 1;
  return v12;
}

void BOMCopierDestinationEntryFree(void *a1)
{
  if (a1)
  {
    unint64_t v2 = (void *)a1[45];
    if (v2) {
      free(v2);
    }
    uint64_t v3 = (void *)a1[43];
    if (v3) {
      free(v3);
    }
    if (a1[10]) {
      archive_entry_free();
    }
    uint64_t v4 = (void *)a1[40];
    if (v4) {
      free(v4);
    }
    if (a1[20])
    {
      if (ParallelCompressionAFSCStreamClose())
      {
        int v5 = (FILE *)*MEMORY[0x1895F89D0];
        uint64_t v6 = __error();
        size_t v7 = strerror(*v6);
        fprintf(v5, "Could not close compressor stream: %s", v7);
      }

      a1[20] = 0LL;
    }

    int v8 = *((_DWORD *)a1 + 17);
    if (v8 != *((_DWORD *)a1 + 16))
    {
      close(v8);
      int v8 = *((_DWORD *)a1 + 16);
    }

    if (v8 != -1) {
      close(v8);
    }
    BOOL v9 = (void *)a1[18];
    if (v9) {
      free(v9);
    }
    uint64_t v10 = (void *)a1[17];
    if (v10) {
      free(v10);
    }
    uint64_t v11 = (void *)a1[16];
    if (v11) {
      free(v11);
    }
    uint64_t v12 = (void *)a1[15];
    if (v12) {
      free(v12);
    }
    int v13 = (void *)a1[5];
    if (v13) {
      free(v13);
    }
    free(a1);
  }

uint64_t create_entry_filesystem(uint64_t a1, uint64_t a2, uint64_t a3, char a4, void *a5)
{
  uint64_t v185 = *MEMORY[0x1895F89C0];
  *(void *)(a1 + 240) = 0LL;
  unsigned int Type = BOMCopierSourceEntryGetType(a2);
  uint64_t Path = (const char *)BOMCopierSourceEntryGetPath(a2);
  uint64_t v12 = *(os_log_s **)a1;
  if (*(void *)a1 && os_log_type_enabled(*(os_log_t *)a1, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)statfs buf = 136315394;
    *(void *)&uint8_t buf[4] = string_for_entry_type(Type);
    __int16 v181 = 2080;
    v182 = Path;
    _os_log_impl(&dword_1862F3000, v12, OS_LOG_TYPE_DEFAULT, "entry_path: [%s] %s", buf, 0x16u);
  }

  size_t v13 = strlen(Path);
  if (!v13)
  {
    BOMCopierErrorCapture( a5,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  7822,  (uint64_t)"construct_filesystem_destination",  "The entry path is empty");
LABEL_87:
    uint64_t v65 = 1LL;
    BOMCopierErrorCapture( a5,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  3690,  (uint64_t)"create_entry_filesystem",  "Could not construct filesystem destinations");
    return v65;
  }

  unint64_t v14 = v13;
  if (!strncmp(Path, ".", v13))
  {
    ++Path;
  }

  else if (v14 >= 3)
  {
    int v15 = *(unsigned __int8 *)Path;
    if (v15 != 46) {
      goto LABEL_12;
    }
    Path += 2 * (Path[1] == 47);
  }

  int v15 = *(unsigned __int8 *)Path;
LABEL_12:
  if (BOMCopierSourceEntryIsRoot(a2))
  {
    if (Type == 6 || !*(_BYTE *)(a1 + 284) || !*(_BYTE *)(a1 + 285))
    {
LABEL_16:
      int v16 = strdup(*(const char **)(a1 + 288));
      *(void *)(a3 + 120) = v16;
      if (!v16)
      {
        int v17 = *__error();
        __int128 v18 = __error();
        strerror(*v18);
        BOMCopierErrorCapture( a5,  v17,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  7939,  (uint64_t)"construct_filesystem_destination",  "Could not construct destination path from %s: %s");
        goto LABEL_87;
      }

      goto LABEL_21;
    }
  }

  else if (!v15)
  {
    goto LABEL_16;
  }

  if (asprintf((char **)(a3 + 120), "%s/%s", *(const char **)(a1 + 288), Path) < 0 || !*(void *)(a3 + 120))
  {
    int v30 = *__error();
    uint64_t v31 = *(void *)(a1 + 288);
    int v32 = __error();
    strerror(*v32);
    BOMCopierErrorCapture( a5,  v30,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  7947,  (uint64_t)"construct_filesystem_destination",  "Could not construct destination path from %s and %s: %s",  v31);
    goto LABEL_87;
  }

LABEL_80:
    *(_DWORD *)(a1 + 240) = 0;
    int v59 = v58(a1, a2, a3, *(void *)(a1 + 232), a5);
    if (v59 != 3)
    {
      if (v59 == 2)
      {
        *(_DWORD *)(a1 + 240) = 2;
        return 1LL;
      }

      if (v59 == 1)
      {
        *(void *)(a1 + 240) = 0x100000001LL;
        return 1LL;
      }

              uint64_t v47 = _copyFromPKZip(a1, a2, a3, v55, v56);
LABEL_82:
              uint64_t v23 = v47;
LABEL_83:
              if ((_DWORD)v23)
              {
LABEL_84:
                if (!v36) {
                  return v23;
                }
                goto LABEL_99;
              }

              if (!v35 && !*(_DWORD *)(a1 + 12712))
              {
                if (*(_DWORD *)(a1 + 12716) == 3)
                {
                  if (*(_BYTE *)(a1 + 170) || *(_BYTE *)(a1 + 169))
                  {
                    uint64_t v23 = _copyExtendedAttributes(a1, (uint64_t)path_p, a2, 0, 0LL);
                    if ((_DWORD)v23) {
                      goto LABEL_84;
                    }
                  }

                  if (!*(_BYTE *)(a1 + 171)) {
                    goto LABEL_88;
                  }
                  __int16 v49 = _copyACLs(a1, path_p, 0, 0, 0LL);
                }

                else
                {
                  __int16 v49 = _copyAppleDoubleToArchive(a1, (uint64_t)path_p, a2, 0LL);
                }

                uint64_t v23 = v49;
                if ((_DWORD)v49) {
                  goto LABEL_84;
                }
              }

LABEL_95:
      if (*(_DWORD *)(a1 + 240)) {
        return 1LL;
      }
      unsigned int v67 = BOMCopierSourceEntryGetType(a2);
      BOOL IsSegmentedFile = BOMCopierSourceEntryIsSegmentedFile(a2);
      BOOL v69 = IsSegmentedFile;
      if (*(_BYTE *)(a1 + 297))
      {
LABEL_97:
        if (*(_BYTE *)(a3 + 153))
        {
          if (v67 == 8) {
            goto LABEL_99;
          }
          goto LABEL_132;
        }
      }

      else if (*(_BYTE *)(a3 + 153))
      {
        if (v67 <= 0xA)
        {
          if (((1 << v67) & 0x6B0) != 0)
          {
            if (unlink(*v21))
            {
              int v75 = *__error();
              int v76 = __error();
              strerror(*v76);
              BOMCopierErrorCapture( a5,  v75,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  3746,  (uint64_t)"create_entry_filesystem",  "Could not unlink %s: %s");
              return 1LL;
            }

            uint64_t v83 = *(os_log_s **)a1;
            if (*(void *)a1 && os_log_type_enabled(*(os_log_t *)a1, OS_LOG_TYPE_DEFAULT))
            {
              uint64_t v84 = *v21;
              *(_DWORD *)statfs buf = 136315138;
              *(void *)&uint8_t buf[4] = v84;
              _os_log_impl(&dword_1862F3000, v83, OS_LOG_TYPE_DEFAULT, "Unlinked %s", buf, 0xCu);
            }

            goto LABEL_97;
          }

          if (v67 == 8)
          {
            if (!IsSegmentedFile)
            {
              if (unlink(*v21))
              {
                int v86 = *__error();
                uint64_t v87 = __error();
                strerror(*v87);
                BOMCopierErrorCapture( a5,  v86,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  3764,  (uint64_t)"create_entry_filesystem",  "Could not unlink %s: %s");
                return 1LL;
              }

              goto LABEL_97;
            }

LABEL_99:
            if (*(_BYTE *)(a1 + 301))
            {
              ssize_t v70 = getxattr(*v21, "com.apple.rootless", 0LL, 0LL, 0, 1);
              if (v70 == -1)
              {
                if (*__error() != 93)
                {
                  __int16 v85 = __error();
                  strerror(*v85);
                  uint64_t v65 = 1LL;
                  BOMCopierErrorCapture( a5,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  3804,  (uint64_t)"create_entry_filesystem",  "Could not get size for rootless attribute %s: %s");
                  return v65;
                }
              }

              else
              {
                size_t v71 = v70;
                if (v70 >= 1)
                {
                  uint64_t v72 = malloc(v70);
                  if (!v72)
                  {
                    int v114 = *__error();
                    BOMCopierErrorCapture( a5,  v114,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  3814,  (uint64_t)"create_entry_filesystem",  "Could not allocate attribute buffer: %s");
                    return 1LL;
                  }

                  uint64_t v73 = v72;
                  ssize_t v74 = getxattr(*v21, "com.apple.rootless", v72, v71, 0, 1);
                  if (v74 == -1)
                  {
                    v116 = *v21;
                    uint32_t v117 = __error();
                    uint64_t v118 = strerror(*v117);
                    uint64_t v65 = 1LL;
                    BOMCopierErrorCapture( a5,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  3821,  (uint64_t)"create_entry_filesystem",  "Could not get rootless attribute for xattr %s: %s",  v116,  v118);
                    free(v73);
                    return v65;
                  }

                  *(void *)(a3 + 312) = v74;
                  *(void *)(a3 + 320) = v73;
                }
              }
            }
          }
        }

LABEL_132:
        if (*(_BYTE *)(a1 + 298))
        {
          size_t v88 = strlen(*(const char **)(a1 + 288));
          size_t v89 = realpath_DARWIN_EXTSN(*(const char **)(a3 + 136), 0LL);
          if (!v89)
          {
            int v96 = *__error();
            uint64_t v97 = __error();
            strerror(*v97);
            BOMCopierErrorCapture( a5,  v96,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  3848,  (uint64_t)"create_entry_filesystem",  "Could not realpath parent %s: %s");
            return 1LL;
          }

          uint64_t v90 = v89;
          int v91 = strncmp(*(const char **)(a1 + 288), v89, v88);
          free(v90);
          if (v91)
          {
            uint64_t v65 = 1LL;
            BOMCopierErrorCapture( a5,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  3858,  (uint64_t)"create_entry_filesystem",  "%s resolves outside of %s");
            return v65;
          }
        }

        uint64_t v65 = 0LL;
        switch(v67)
        {
          case 6u:
            if (*(_BYTE *)(a3 + 153)) {
              return 0LL;
            }
            __int16 Mode = BOMCopierSourceEntryGetMode(a2);
            mode_t v93 = *(_BYTE *)(a1 + 296) ? 493 : Mode;
            if (!mkdir(*v21, v93)) {
              return 0LL;
            }
            int v94 = *__error();
            int v95 = __error();
            strerror(*v95);
            BOMCopierErrorCapture( a5,  v94,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  3882,  (uint64_t)"create_entry_filesystem",  "Could not create directory at %s: %s");
            return 1LL;
          case 8u:
            int Device = BOMCopierSourceEntryGetDevice(a2);
            uint64_t Inode = BOMCopierSourceEntryGetInode(a2);
            uint64_t v175 = 0LL;
            uint64_t Size = BOMCopierSourceEntryGetSize(a2);
            if (BOMHardLinkTableGetPathAndData(*(CFDictionaryRef **)(a1 + 72), Device, Inode, buf, &v175))
            {
              BOMHardLinkTableSetPathAndData(*(CFDictionaryRef **)(a1 + 72), Device, Inode, (char *)*v21, &Size, 8uLL);
            }

            else if (*v175 == Size)
            {
              if (*(_BYTE *)(a3 + 153) && unlink(*v21))
              {
                int v124 = *__error();
                int v125 = __error();
                strerror(*v125);
                BOMCopierErrorCapture( a5,  v124,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  3956,  (uint64_t)"create_entry_filesystem",  "Could not unlink %s: %s");
                return 1LL;
              }

              if (link(buf, *v21))
              {
                if (*__error() != 18)
                {
                  int v126 = *__error();
                  int v127 = *v21;
                  int v128 = __error();
                  strerror(*v128);
                  BOMCopierErrorCapture( a5,  v126,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  3968,  (uint64_t)"create_entry_filesystem",  "Could not create hardlink %s to %s: %s",  v127);
                  return 1LL;
                }
              }

              else
              {
                *(_DWORD *)(a1 + 244) = 2;
                *(_BYTE *)(a3 + 154) = 1;
                *(_BYTE *)(a3 + 152) = 0;
                int v129 = *(os_log_s **)a1;
                if (*(void *)a1 && os_log_type_enabled(*(os_log_t *)a1, OS_LOG_TYPE_DEFAULT))
                {
                  uint64_t v130 = *v21;
                  *(_DWORD *)int v177 = 136315394;
                  *(void *)&v177[4] = v130;
                  __int16 v178 = 2080;
                  v179 = buf;
                  _os_log_impl(&dword_1862F3000, v129, OS_LOG_TYPE_DEFAULT, "Hardlinked %s to %s", v177, 0x16u);
                }
              }
            }

  uint64_t v68 = printBuffer;
  if ((unint64_t)v6 > printBuffer)
  {
    *--uint64_t v6 = 0;
    uint64_t v68 = printBuffer;
  }

  snprintf(v6, v68 - (void)v6 + 4096, "\n");
  return printBuffer;
}

LABEL_176:
            if (!*(_BYTE *)(a1 + 304)) {
              goto LABEL_181;
            }
            buf[0] = 0;
            if (BOMCopierSourceEntryClone(a2, *(char **)(a3 + 144), buf, a5))
            {
              int v131 = *__error();
              v132 = __error();
              strerror(*v132);
              BOMCopierErrorCapture( a5,  v131,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  4003,  (uint64_t)"create_entry_filesystem",  "Could not clone source entry to %s: %s");
              return 1LL;
            }

            if (buf[0]) {
              *(_BYTE *)(a3 + 154) = 1;
            }
LABEL_181:
            if (*(_BYTE *)(a3 + 154)) {
              return 0LL;
            }
            if (v69)
            {
              int v133 = open(*(const char **)(a3 + 144), 1, 420LL);
              if (v133 == -1)
              {
                int v140 = *__error();
                int v141 = __error();
                strerror(*v141);
                BOMCopierErrorCapture( a5,  v140,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  4087,  (uint64_t)"create_entry_filesystem",  "Could not open regular file at %s: %s");
                return 1LL;
              }

              int v134 = v133;
              if (lseek(v133, 0LL, 2) == -1)
              {
                int v153 = *__error();
                int v154 = __error();
                strerror(*v154);
                BOMCopierErrorCapture( a5,  v153,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  4096,  (uint64_t)"create_entry_filesystem",  "Could not seek to the end of %s: %s");
                return 1LL;
              }

              int v135 = *(os_log_s **)a1;
              if (*(void *)a1 && os_log_type_enabled(*(os_log_t *)a1, OS_LOG_TYPE_DEFAULT))
              {
                uint64_t v136 = *(void *)(a3 + 144);
                *(_DWORD *)statfs buf = 136315138;
                *(void *)&uint8_t buf[4] = v136;
                _os_log_impl(&dword_1862F3000, v135, OS_LOG_TYPE_DEFAULT, "Opened segmented file at %s", buf, 0xCu);
              }

              int v137 = v134;
            }

            else
            {
              int v138 = *(const char **)(a3 + 144);
              if (*(_BYTE *)(a1 + 12)) {
                int v139 = open_dprotected_np(v138, 1537, *(_DWORD *)(a1 + 16), 0, 420LL);
              }
              else {
                int v139 = open(v138, 513, 420LL);
              }
              int v137 = v139;
              if (v139 == -1)
              {
                int v144 = *__error();
                int v145 = __error();
                strerror(*v145);
                BOMCopierErrorCapture( a5,  v144,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  4042,  (uint64_t)"create_entry_filesystem",  "Could not create regular file at %s: %s");
                return 1LL;
              }

              int v142 = *(os_log_s **)a1;
              if (*(void *)a1 && os_log_type_enabled(*(os_log_t *)a1, OS_LOG_TYPE_DEFAULT))
              {
                uint64_t v143 = *(void *)(a3 + 144);
                *(_DWORD *)statfs buf = 136315138;
                *(void *)&uint8_t buf[4] = v143;
                _os_log_impl(&dword_1862F3000, v142, OS_LOG_TYPE_DEFAULT, "Created file at %s", buf, 0xCu);
              }

              if ((a4 & 2) != 0)
              {
                asprintf((char **)v177, "%s%s", *(const char **)(a3 + 144), "/..namedfork/rsrc");
                if (!*(void *)v177)
                {
                  int v166 = *__error();
                  int v167 = __error();
                  strerror(*v167);
                  BOMCopierErrorCapture( a5,  v166,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  4060,  (uint64_t)"create_entry_filesystem",  "Could not create rsrc path for %s: %s");
                  return 1LL;
                }

                int v146 = open(*(const char **)v177, 513, 420LL);
                if (v146 == -1)
                {
                  int v168 = *__error();
                  v169 = __error();
                  strerror(*v169);
                  BOMCopierErrorCapture( a5,  v168,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  4067,  (uint64_t)"create_entry_filesystem",  "Could not create resource fork at %s: %s");
                  return 1LL;
                }

                int v134 = v146;
                int v147 = *(os_log_s **)a1;
                if (*(void *)a1 && os_log_type_enabled(*(os_log_t *)a1, OS_LOG_TYPE_DEFAULT))
                {
                  *(_DWORD *)statfs buf = 136315138;
                  *(void *)&uint8_t buf[4] = *(void *)v177;
                  _os_log_impl(&dword_1862F3000, v147, OS_LOG_TYPE_DEFAULT, "Open resource fork at %s", buf, 0xCu);
                }

                free(*(void **)v177);
              }

              else
              {
                int v134 = v137;
              }
            }

            int v148 = *(unsigned __int8 *)(a1 + 41);
            if (*(_BYTE *)(a1 + 41) && fcntl(v137, 68, 1LL))
            {
              int v149 = *__error();
              int v150 = __error();
              strerror(*v150);
              BOMCopierErrorCapture( a5,  v149,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  4116,  (uint64_t)"create_entry_filesystem",  "Could not set F_SETSTATICCONTENT for %s: %s");
              return 1LL;
            }

            if (*(_BYTE *)(a1 + 42))
            {
              if (fcntl(v137, 76, 1LL))
              {
                int v151 = *__error();
                int v152 = __error();
                strerror(*v152);
                BOMCopierErrorCapture( a5,  v151,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  4128,  (uint64_t)"create_entry_filesystem",  "Could not set F_SINGLE_WRITER for %s: %s");
                return 1LL;
              }

              if (!*(_BYTE *)(a1 + 40)) {
                goto LABEL_220;
              }
            }

            else if (!*(_BYTE *)(a1 + 40))
            {
              if (!v148) {
                goto LABEL_231;
              }
LABEL_220:
              int v157 = *(os_log_s **)a1;
              if (*(void *)a1 && os_log_type_enabled(*(os_log_t *)a1, OS_LOG_TYPE_DEFAULT))
              {
                int v158 = "F_SETSTATICCONTENT ";
                if (!*(_BYTE *)(a1 + 41)) {
                  int v158 = "";
                }
                if (*(_BYTE *)(a1 + 42)) {
                  int v159 = "F_SINGLE_WRITER ";
                }
                else {
                  int v159 = "";
                }
                int v160 = *(unsigned __int8 *)(a1 + 40);
                *(_DWORD *)statfs buf = 136315650;
                *(void *)&uint8_t buf[4] = v158;
                __int16 v181 = 2080;
                v182 = v159;
                if (v160) {
                  v161 = "F_NOCACHE ";
                }
                else {
                  v161 = "";
                }
                __int16 v183 = 2080;
                v184 = v161;
                _os_log_impl(&dword_1862F3000, v157, OS_LOG_TYPE_DEFAULT, "Set %s%s%s", buf, 0x20u);
              }

LABEL_231:
              *(_DWORD *)(a3 + 64) = v137;
              *(_DWORD *)(a3 + 68) = v134;
              if (BOMCopierSourceEntryGetSize(a2) <= 0x4000) {
                return 0LL;
              }
              uint64_t v65 = 0LL;
              BOOL v162 = (a4 & 1) == 0 && *(_BYTE *)(a1 + 112) == 0;
              if (v162 || !*(_BYTE *)(a1 + 300)) {
                return v65;
              }
              uint64_t v163 = ParallelCompressionAFSCStreamOpen();
              if (v163)
              {
                *(void *)(a3 + 160) = v163;
                os_log_t v164 = *(os_log_t *)a1;
                if (!*(void *)a1) {
                  return 0LL;
                }
                uint64_t v65 = 0LL;
                if (os_log_type_enabled(*(os_log_t *)a1, OS_LOG_TYPE_DEFAULT))
                {
                  uint64_t v165 = *(void *)(a3 + 144);
                  *(_DWORD *)statfs buf = 136315138;
                  *(void *)&uint8_t buf[4] = v165;
                  uint64_t v121 = "Enabled filesystem compression for %s";
                  int v122 = v164;
                  uint32_t v123 = 12;
                  goto LABEL_165;
                }

                return v65;
              }

              int v170 = *__error();
              char v171 = __error();
              strerror(*v171);
              BOMCopierErrorCapture( a5,  v170,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  4193,  (uint64_t)"create_entry_filesystem",  "Could not create ParallelCompression AFSC stream for %s: %s");
              return 1LL;
            }

            if (fcntl(v137, 48, 1LL))
            {
              int v155 = *__error();
              AAArchiveStream v156 = __error();
              strerror(*v156);
              BOMCopierErrorCapture( a5,  v155,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  4140,  (uint64_t)"create_entry_filesystem",  "Could not F_NOCACHE %s: %s\n");
              return 1LL;
            }

            goto LABEL_220;
          case 9u:
            SymlinkTarget = (const char *)BOMCopierSourceEntryGetSymlinkTarget(a2);
            if (symlink(SymlinkTarget, *(const char **)(a3 + 144)))
            {
              int v112 = *__error();
              v113 = __error();
              strerror(*v113);
              BOMCopierErrorCapture( a5,  v112,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  4211,  (uint64_t)"create_entry_filesystem",  "Could not create symlink at %s: %s");
              return 1LL;
            }

            os_log_t v119 = *(os_log_t *)a1;
            if (!*(void *)a1) {
              return 0LL;
            }
            uint64_t v65 = 0LL;
            if (os_log_type_enabled(*(os_log_t *)a1, OS_LOG_TYPE_DEFAULT))
            {
              uint64_t v120 = *(void *)(a3 + 144);
              *(_DWORD *)statfs buf = 136315394;
              *(void *)&uint8_t buf[4] = v120;
              __int16 v181 = 2080;
              v182 = SymlinkTarget;
              uint64_t v121 = "Created symlink %s -> %s";
              int v122 = v119;
              uint32_t v123 = 22;
LABEL_165:
              _os_log_impl(&dword_1862F3000, v122, OS_LOG_TYPE_DEFAULT, v121, buf, v123);
              return 0LL;
            }

            return v65;
          case 0xDu:
          case 0xEu:
          case 0xFu:
          case 0x10u:
          case 0x11u:
          case 0x12u:
          case 0x13u:
            return v65;
          default:
            BOMCopierSourceEntryTypeString(v67);
            BOMCopierErrorCapture( a5,  45,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  4259,  (uint64_t)"create_entry_filesystem",  "Unsupported BOMCopierSourceEntryType: %s");
            return 1LL;
        }
      }

      if (make_path(*(os_log_s **)a1, *(char **)(a3 + 136), a5))
      {
        int v77 = *__error();
        uint64_t v78 = __error();
        strerror(*v78);
        BOMCopierErrorCapture( a5,  v77,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  3787,  (uint64_t)"create_entry_filesystem",  "Could not make_path %s: %s");
        return 1LL;
      }

      goto LABEL_132;
    }

LABEL_81:
    char v39 = 1;
    if ((v40 & 1) != 0) {
      goto LABEL_95;
    }
  }

  int v50 = *(_DWORD *)(a1 + 280);
  if (!v50)
  {
    uint64_t v58 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, void, void *))(a1 + 224);
    if (!v58)
    {
      string_for_mode(v49);
      BOMCopierErrorCapture( a5,  20,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  8189,  (uint64_t)"resolve_filesystem_conflict",  "%s: conflict replacing %s with %s",  *v21);
      goto LABEL_119;
    }

    goto LABEL_80;
  }

  if (v50 != 2)
  {
    if (v50 == 1)
    {
      if (unlink(*v21))
      {
        int v81 = *__error();
        BOOL v82 = __error();
        strerror(*v82);
        BOMCopierErrorCapture( a5,  v81,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  8199,  (uint64_t)"resolve_filesystem_conflict",  "Could not unlink %s: %s");
        goto LABEL_119;
      }

      *(_BYTE *)(a3 + 153) = 0;
      int v115 = *(os_log_s **)a1;
      if (*(void *)a1 && os_log_type_enabled(*(os_log_t *)a1, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)statfs buf = 0;
        _os_log_impl(&dword_1862F3000, v115, OS_LOG_TYPE_DEFAULT, "Conflicting symlink unlinked", buf, 2u);
      }
    }

    goto LABEL_95;
  }

  if (stat(*v21, (stat *)(a3 + 168)))
  {
    int v98 = *__error();
    int v99 = __error();
    strerror(*v99);
    BOMCopierErrorCapture( a5,  v98,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  8213,  (uint64_t)"resolve_filesystem_conflict",  "Could not stat %s: %s");
    goto LABEL_119;
  }

  if ((*(_WORD *)(a3 + 172) & 0xF000) != 0x4000)
  {
    BOMCopierErrorCapture( a5,  20,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  8219,  (uint64_t)"resolve_filesystem_conflict",  "%s: Not a directory");
    goto LABEL_119;
  }

  if (!basename_r(*v21, buf))
  {
    int v100 = *__error();
    uint64_t v101 = __error();
    strerror(*v101);
    BOMCopierErrorCapture( a5,  v100,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  8231,  (uint64_t)"resolve_filesystem_conflict",  "Could not basename %s: %s");
    goto LABEL_119;
  }

  __int16 v51 = realpath_DARWIN_EXTSN(*v21, 0LL);
  if (!v51)
  {
    int v102 = *__error();
    uint64_t v103 = __error();
    strerror(*v103);
    BOMCopierErrorCapture( a5,  v102,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  8238,  (uint64_t)"resolve_filesystem_conflict",  "Could not resolve %s: %s");
    goto LABEL_119;
  }

  stat v52 = v51;
  free((void *)*v21);
  *uint64_t v21 = 0LL;
  asprintf((char **)(a3 + 120), "%s/%s", v52, buf);
  if (!*v21)
  {
    int v104 = *__error();
    int v105 = __error();
    CFTypeID v106 = strerror(*v105);
    BOMCopierErrorCapture( a5,  v104,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  8248,  (uint64_t)"resolve_filesystem_conflict",  "Could not reconstruct destination path: %s",  v106);
    free(v52);
    goto LABEL_119;
  }

  CFIndex v53 = *(void **)(a3 + 136);
  if (v53) {
    free(v53);
  }
  *(void *)(a3 + 136) = v52;
  int v54 = *(void **)(a3 + 144);
  if (v54) {
    free(v54);
  }
  __int16 v55 = strdup(*(const char **)(a3 + 120));
  *(void *)(a3 + 144) = v55;
  if (v55)
  {
    size_t v56 = *(os_log_s **)a1;
    if (*(void *)a1)
    {
      if (!os_log_type_enabled(*(os_log_t *)a1, OS_LOG_TYPE_DEFAULT)
        || (*(_WORD *)int v177 = 0,
            _os_log_impl(&dword_1862F3000, v56, OS_LOG_TYPE_DEFAULT, "Conflicting symlink followed", v177, 2u),
            (size_t v56 = *(os_log_s **)a1) != 0LL))
      {
        if (os_log_type_enabled(v56, OS_LOG_TYPE_DEFAULT))
        {
          CFIndex v57 = *v21;
          *(_DWORD *)int v177 = 136315138;
          *(void *)&v177[4] = v57;
          _os_log_impl(&dword_1862F3000, v56, OS_LOG_TYPE_DEFAULT, "destination_path: %s", v177, 0xCu);
        }
      }
    }

    goto LABEL_81;
  }

  int v107 = *__error();
  int v108 = __error();
  strerror(*v108);
  BOMCopierErrorCapture( a5,  v107,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  8268,  (uint64_t)"resolve_filesystem_conflict",  "Could not duplicate %s: %s");
LABEL_119:
  uint64_t v65 = 1LL;
  BOMCopierErrorCapture( a5,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  3705,  (uint64_t)"create_entry_filesystem",  "Could not resolve filesystem conflict",  v172,  v173);
  return v65;
}

uint64_t create_entry_libarchive(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  uint64_t v8 = archive_entry_new();
  if (v8)
  {
    uint64_t v9 = v8;
    uint64_t Path = (const char *)BOMCopierSourceEntryGetPath(a2);
    archive_entry_set_pathname();
    uint64_t v11 = strdup(Path);
    a3[15] = v11;
    if (!v11)
    {
      int v17 = __error();
      strerror(*v17);
      uint64_t v16 = 1LL;
      BOMCopierErrorCapture( a4,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  4293,  (uint64_t)"create_entry_libarchive",  "Could not duplicate entry path %s: %s");
      return v16;
    }

    int Device = BOMCopierSourceEntryGetDevice(a2);
    uint64_t Inode = BOMCopierSourceEntryGetInode(a2);
    HardlinkCFIndex Count = BOMCopierSourceEntryGetHardlinkCount(a2);
    int Type = BOMCopierSourceEntryGetType(a2);
    if (Type == 8 && HardlinkCount >= 2)
    {
      int v15 = BOMHardLinkTableGet(*(CFDictionaryRef **)(a1 + 72), Device, Inode);
      if (v15)
      {
        *(void *)bytes = *(void *)v15;
      }

      else
      {
        __int128 v18 = *(CFDictionaryRef **)(a1 + 72);
        *(void *)bytes = *(void *)(a1 + 64);
        BOMHardLinkTableSet(v18, Device, Inode, bytes, 8LL);
        ++*(void *)(a1 + 64);
      }
    }

    else
    {
      *(void *)bytes = *(void *)(a1 + 64);
      *(void *)(a1 + 64) = *(void *)bytes + 1LL;
    }

    BOMCopierSourceEntryGetMode(a2);
    BOMCopierSourceEntryGetUserID(a2);
    BOMCopierSourceEntryGetGroupID(a2);
    if (BOMCopierSourceEntryGetAccessTime(a2, &v24))
    {
      uint64_t v16 = 1LL;
      BOMCopierErrorCapture( a4,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  4362,  (uint64_t)"create_entry_libarchive",  "Could not get source entry access time");
    }

    else if (BOMCopierSourceEntryGetModificationTime(a2, &v23))
    {
      uint64_t v16 = 1LL;
      BOMCopierErrorCapture( a4,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  4372,  (uint64_t)"create_entry_libarchive",  "Could not get source entry modification time");
    }

    else if (BOMCopierSourceEntryGetStatusTime(a2, &v22))
    {
      uint64_t v16 = 1LL;
      BOMCopierErrorCapture( a4,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  4382,  (uint64_t)"create_entry_libarchive",  "Could not get source entry status time");
    }

    else
    {
      archive_entry_set_dev();
      archive_entry_set_nlink();
      archive_entry_set_ino64();
      archive_entry_set_perm();
      archive_entry_set_mode();
      archive_entry_set_uid();
      archive_entry_set_gid();
      archive_entry_set_size();
      archive_entry_set_atime();
      archive_entry_set_mtime();
      archive_entry_set_ctime();
      switch(Type)
      {
        case 4:
        case 6:
        case 10:
          archive_entry_set_filetype();
          break;
        case 8:
          archive_entry_set_filetype();
          a3[9] = *(void *)(a1 + 136);
          uint64_t v19 = *(void *)(a1 + 152);
          if (v19 >= 1 && a3[7] >> 33)
          {
            a3[11] = v19;
            a3[12] = v19;
            archive_entry_set_size();
          }

          break;
        case 9:
          BOMCopierSourceEntryGetSymlinkTarget(a2);
          archive_entry_set_filetype();
          archive_entry_set_symlink();
          break;
        case 13:
        case 17:
        case 18:
        case 19:
          break;
        default:
          uint64_t v16 = 1LL;
          BOMCopierErrorCapture( a4,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  4473,  (uint64_t)"create_entry_libarchive",  "Unknown source entry type: %d");
          goto LABEL_27;
      }

      if (!archive_write_header())
      {
        uint64_t v16 = 0LL;
        a3[10] = v9;
        return v16;
      }

      archive_error_string();
      uint64_t v16 = 1LL;
      BOMCopierErrorCapture( a4,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  4483,  (uint64_t)"create_entry_libarchive",  "Could not write archive entry: %s (%d)");
    }

uint64_t create_entry_apple_archive(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  AAHeader v8 = AAHeaderCreate();
  if (!v8)
  {
    uint64_t v12 = 1LL;
    BOMCopierErrorCapture( a4,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  4511,  (uint64_t)"create_entry_apple_archive",  "Could not create AppleArchive header");
    return v12;
  }

  uint64_t v9 = v8;
  int Type = BOMCopierSourceEntryGetType(a2);
  else {
    uint64_t v11 = qword_18635ACF0[Type - 4];
  }
  v13.ikey = 5265748;
  int v14 = AAHeaderSetFieldUInt(v9, 0xFFFFFFFF, v13, v11);
  if (v14)
  {
    BOMCopierErrorCapture( a4,  v14,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  4553,  (uint64_t)"populate_aa_header",  "Could not set AppleArchive type");
LABEL_11:
    uint64_t v12 = 1LL;
    BOMCopierErrorCapture( a4,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  4518,  (uint64_t)"create_entry_apple_archive",  "Could not populate AppleArchive header");
    AAHeaderDestroy(v9);
    return v12;
  }

  uint64_t Path = (const char *)BOMCopierSourceEntryGetPath(a2);
  size_t v16 = strlen(Path);
  v17.ikey = 5521744;
  int v18 = AAHeaderSetFieldString(v9, 0xFFFFFFFF, v17, Path, v16);
  if (v18)
  {
    BOMCopierErrorCapture( a4,  v18,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  4561,  (uint64_t)"populate_aa_header",  "Could not set AppleArchive path");
    goto LABEL_11;
  }

  __int128 v20 = strdup(Path);
  *(void *)(a3 + 120) = v20;
  if (!v20)
  {
    int v26 = __error();
    strerror(*v26);
    BOMCopierErrorCapture( a4,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  4568,  (uint64_t)"populate_aa_header",  "Could not duplicate entry path %s: %s");
    goto LABEL_11;
  }

  if (Type == 9)
  {
    SymlinkTarget = (const char *)BOMCopierSourceEntryGetSymlinkTarget(a2);
    if (!SymlinkTarget)
    {
      BOMCopierErrorCapture( a4,  0,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  4577,  (uint64_t)"populate_aa_header",  "Could not set AppleArchive size");
      goto LABEL_11;
    }

    __int128 v22 = SymlinkTarget;
    size_t v23 = strlen(SymlinkTarget);
    v24.ikey = 4935244;
    int v25 = AAHeaderSetFieldString(v9, 0xFFFFFFFF, v24, v22, v23);
    if (v25)
    {
      BOMCopierErrorCapture( a4,  v25,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  4587,  (uint64_t)"populate_aa_header",  "Could not set AppleArchive symlink path");
      goto LABEL_11;
    }
  }

  else if ((Type & 0xFFFFFFFD) == 5)
  {
    int Device = BOMCopierSourceEntryGetDevice(a2);
    v28.ikey = 5653828;
    AAHeaderSetFieldUInt(v9, 0xFFFFFFFF, v28, Device);
  }

  unsigned int UserID = BOMCopierSourceEntryGetUserID(a2);
  v30.ikey = 4475221;
  int v31 = AAHeaderSetFieldUInt(v9, 0xFFFFFFFF, v30, UserID);
  if (v31)
  {
    BOMCopierErrorCapture( a4,  v31,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  4608,  (uint64_t)"populate_aa_header",  "Could not set AppleArchive uid");
    goto LABEL_11;
  }

  unsigned int GroupID = BOMCopierSourceEntryGetGroupID(a2);
  v33.ikey = 4475207;
  int v34 = AAHeaderSetFieldUInt(v9, 0xFFFFFFFF, v33, GroupID);
  if (v34)
  {
    BOMCopierErrorCapture( a4,  v34,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  4616,  (uint64_t)"populate_aa_header",  "Could not set AppleArchive gid");
    goto LABEL_11;
  }

  __int16 Mode = BOMCopierSourceEntryGetMode(a2);
  v36.ikey = 4476749;
  int v37 = AAHeaderSetFieldUInt(v9, 0xFFFFFFFF, v36, Mode & 0xFFF);
  if (v37)
  {
    BOMCopierErrorCapture( a4,  v37,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  4624,  (uint64_t)"populate_aa_header",  "Could not set AppleArchive mode");
    goto LABEL_11;
  }

  unsigned int v38 = BOMCopierSourceEntryGetMode(a2);
  v39.ikey = 4672582;
  int v40 = AAHeaderSetFieldUInt(v9, 0xFFFFFFFF, v39, v38);
  if (v40)
  {
    BOMCopierErrorCapture( a4,  v40,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  4632,  (uint64_t)"populate_aa_header",  "Could not set AppleArchive mode");
    goto LABEL_11;
  }

  value.tv_sec = 0LL;
  value.tv_nsec = 0LL;
  int ModificationTime = BOMCopierSourceEntryGetModificationTime(a2, &value);
  if (ModificationTime)
  {
    BOMCopierErrorCapture( a4,  ModificationTime,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  4640,  (uint64_t)"populate_aa_header",  "Could not retrieve modification time");
    goto LABEL_11;
  }

  v42.ikey = 5067853;
  int v43 = AAHeaderSetFieldTimespec(v9, 0xFFFFFFFF, v42, &value);
  if (v43)
  {
    BOMCopierErrorCapture( a4,  v43,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  4647,  (uint64_t)"populate_aa_header",  "Could not set AppleArchive modification time");
    goto LABEL_11;
  }

  uint64_t Inode = BOMCopierSourceEntryGetInode(a2);
  v45.ikey = 5197385;
  AAHeaderSetFieldUInt(v9, 0xFFFFFFFF, v45, Inode);
  HardlinkCFIndex Count = BOMCopierSourceEntryGetHardlinkCount(a2);
  v47.ikey = 4934734;
  AAHeaderSetFieldUInt(v9, 0xFFFFFFFF, v47, HardlinkCount);
  if (Type == 8)
  {
    int64_t v48 = *(void *)(a3 + 56);
    v49.ikey = 5917011;
    int v50 = AAHeaderSetFieldUInt(v9, 0xFFFFFFFF, v49, v48);
    if (v50)
    {
      BOMCopierErrorCapture( a4,  v50,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  4689,  (uint64_t)"populate_aa_header",  "Could not set AppleArchive size");
      goto LABEL_11;
    }

    if (v48 >= 1)
    {
      v51.ikey = 5521732;
      int v52 = AAHeaderSetFieldBlob(v9, 0xFFFFFFFF, v51, v48);
      if (v52)
      {
        BOMCopierErrorCapture( a4,  v52,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  4698,  (uint64_t)"populate_aa_header",  "Could not append AA_FIELD_DAT to AppleArchive header: %d");
        goto LABEL_11;
      }
    }
  }

  uint64_t v55 = 0LL;
  if (BOMCopierSourceEntryGetACL(a2, &v55, a4))
  {
    int v53 = populate_aa_header_acl(a2, a3, v9, a4);
    if (v53)
    {
      BOMCopierErrorCapture( a4,  v53,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  4711,  (uint64_t)"populate_aa_header",  "Could not encode ACL");
      goto LABEL_11;
    }
  }

  if (BOMCopierSourceEntryGetExtendedAttributeCount(a2, a4))
  {
    int v54 = populate_aa_header_xattr(a2, a3, v9, a4);
    if (v54)
    {
      BOMCopierErrorCapture( a4,  v54,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  4722,  (uint64_t)"populate_aa_header",  "Could not encode extended attributes");
      goto LABEL_11;
    }
  }

  uint64_t v12 = AAArchiveStreamWriteHeader(*(AAArchiveStream *)(a1 + 184), v9);
  AAHeaderDestroy(v9);
  if ((_DWORD)v12)
  {
    uint64_t v12 = 1LL;
    BOMCopierErrorCapture( a4,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  4529,  (uint64_t)"create_entry_apple_archive",  "Could not write AppleArchive header");
  }

  else
  {
    *(_DWORD *)(a3 + 328) = 5521732;
    *(void *)(a3 + 336) = *(void *)(a1 + 184);
  }

  return v12;
}

uint64_t BOMCopierDestinationFinalizeEntry(void *a1, void *a2, void *a3)
{
  if (!a1)
  {
    uint64_t v11 = 22LL;
    BOMCopierErrorCapture( a3,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  1786,  (uint64_t)"BOMCopierDestinationFinalizeEntry",  "copier_destination is NULL");
    return v11;
  }

  if (!a2)
  {
    uint64_t v11 = 22LL;
    BOMCopierErrorCapture( a3,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  1792,  (uint64_t)"BOMCopierDestinationFinalizeEntry",  "destination_entry is NULL");
    return v11;
  }

  uint64_t v5 = (uint64_t)a1;
  if (!*((_BYTE *)a2 + 16))
  {
    uint64_t v13 = a1[12];
    uint64_t v14 = a2[3];
    int Type = BOMCopierSourceEntryGetType(a2[1]);
    if (Type == 8 && v14 != 0 && v13 != 0)
    {
      if (BOMCopierDataAnalyzerFinalize((uint64_t *)a2[3], a3))
      {
        uint64_t v11 = 1LL;
        BOMCopierErrorCapture( a3,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  1842,  (uint64_t)"BOMCopierDestinationFinalizeEntry",  "Could not finalize data analyzer");
        return v11;
      }

      int v24 = 0;
      if (BOMCopierDataAnalyzerGetDigest(a2[3], 2, (uint64_t)&v24, a3))
      {
        BOMCopierErrorCapture( a3,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  1851,  (uint64_t)"BOMCopierDestinationFinalizeEntry",  "Could not retrieve CRC32 from data analyzer");
        return 1LL;
      }

      BOMCopierDataAnalyzerReset((uint64_t *)a2[3]);
      uint64_t Path = (char *)BOMCopierSourceEntryGetPath(a2[1]);
      uint64_t FSObjectAtPath = BOMBomGetFSObjectAtPath(*(void *)(v5 + 96), Path);
      if (!FSObjectAtPath)
      {
        BOMCopierErrorCapture( a3,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  1866,  (uint64_t)"BOMCopierDestinationFinalizeEntry",  "Could not lookup %s in checksum bom");
        return 1LL;
      }

      uint64_t v22 = FSObjectAtPath;
      int v23 = BOMFSObjectChecksum(FSObjectAtPath);
      BOMFSObjectFree(v22);
      if (v23 != v24)
      {
        BOMCopierErrorCapture( a3,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  1876,  (uint64_t)"BOMCopierDestinationFinalizeEntry",  "Checksum mismatch for %s: %d vs %d",  Path);
        return 1LL;
      }
    }

    if (*((_DWORD *)a2 + 8) != 2)
    {
      int v18 = *(_DWORD *)(v5 + 44);
      if (v18 == 2)
      {
        if (finalize_entry_apple_archive((uint64_t)a2, a3))
        {
          uint64_t v11 = 1LL;
          BOMCopierErrorCapture( a3,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  1908,  (uint64_t)"BOMCopierDestinationFinalizeEntry",  "Could not finalize AppleArchive entry");
          return v11;
        }
      }

      else if (!v18 && finalize_entry_filesystem(v5, (uint64_t)a2, a3))
      {
        uint64_t v11 = 1LL;
        BOMCopierErrorCapture( a3,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  1898,  (uint64_t)"BOMCopierDestinationFinalizeEntry",  "Could not finalize filesystem entry");
        return v11;
      }
    }

    if (Type == 17) {
      goto LABEL_7;
    }
    uint64_t v6 = *(void (**)(void *, uint64_t, void *, uint64_t, uint64_t))(v5 + 264);
    if (!v6) {
      goto LABEL_7;
    }
    uint64_t v10 = *(unsigned int *)(v5 + 244);
    uint64_t v7 = a2[1];
    uint64_t v8 = *(void *)(v5 + 272);
    a1 = (void *)v5;
    uint64_t v9 = a2;
    goto LABEL_6;
  }

  uint64_t v6 = (void (*)(void *, uint64_t, void *, uint64_t, uint64_t))a1[33];
  if (v6)
  {
    uint64_t v7 = a2[1];
    uint64_t v8 = a1[34];
    uint64_t v9 = a2;
    uint64_t v10 = 1LL;
LABEL_6:
    v6(a1, v7, v9, v10, v8);
  }

uint64_t finalize_entry_filesystem(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v200 = *MEMORY[0x1895F89C0];
  if (*(_BYTE *)(a2 + 154)) {
    return apply_retention_policy(a1, a2, a3);
  }
  uint64_t v7 = *(void *)(a2 + 8);
  unsigned int Type = BOMCopierSourceEntryGetType(v7);
  switch(Type)
  {
    case 8u:
      int v9 = *(_DWORD *)(a2 + 64);
      if (v9 == -1) {
        goto LABEL_51;
      }
      if (*(void *)(a2 + 160))
      {
        if (ParallelCompressionAFSCStreamClose())
        {
          int v10 = *__error();
          uint64_t v11 = __error();
          strerror(*v11);
          BOMCopierErrorCapture( a3,  v10,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  5164,  (uint64_t)"finalize_entry_filesystem",  "Could not close AFSC stream for %s: %s");
          return 1LL;
        }

        *(void *)(a2 + 160) = 0LL;
        int v9 = *(_DWORD *)(a2 + 64);
      }

      if (*(_DWORD *)(a2 + 68) != v9)
      {
        close(*(_DWORD *)(a2 + 68));
        int v9 = *(_DWORD *)(a2 + 64);
      }

      *(_DWORD *)(a2 + 68) = -1;
      close(v9);
      *(_DWORD *)(a2 + 64) = -1;
      goto LABEL_51;
    case 0x10u:
      if (lstat(*(const char **)(a2 + 120), &v193))
      {
        int v15 = *__error();
        BOMCopierErrorCapture( a3,  v15,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  5192,  (uint64_t)"finalize_entry_filesystem",  "Missing symlink target for %s");
        return 1LL;
      }

      if ((v193.st_mode & 0xF000) != 0x8000)
      {
        BOMCopierErrorCapture( a3,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  5198,  (uint64_t)"finalize_entry_filesystem",  "%s is not a regular file");
        return 1LL;
      }

      if (v193.st_size >= 1025)
      {
        BOMCopierErrorCapture( a3,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  5204,  (uint64_t)"finalize_entry_filesystem",  "%s is too large (%luu) to hold a symlink target");
        return 1LL;
      }

      int v76 = calloc(1uLL, v193.st_size + 1);
      if (!v76)
      {
        int v131 = *__error();
        v132 = __error();
        strerror(*v132);
        BOMCopierErrorCapture( a3,  v131,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  5213,  (uint64_t)"finalize_entry_filesystem",  "Could not allocate target buffer %lu: %s");
        return 1LL;
      }

      uint64_t v58 = v76;
      unsigned int v77 = Type;
      int v78 = open(*(const char **)(a2 + 120), 0);
      if (v78 == -1)
      {
        int v135 = *__error();
        uint64_t v136 = __error();
        strerror(*v136);
        BOMCopierErrorCapture( a3,  v135,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  5220,  (uint64_t)"finalize_entry_filesystem",  "Could not open %s: %s");
        goto LABEL_68;
      }

      int v79 = v78;
      ssize_t v80 = read(v78, v58, v193.st_size);
      if (v80 != v193.st_size)
      {
        int v137 = *__error();
        int v138 = *(const char **)(a2 + 120);
        off_t st_size = v193.st_size;
        int v140 = __error();
        int v141 = strerror(*v140);
        BOMCopierErrorCapture( a3,  v137,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  5228,  (uint64_t)"finalize_entry_filesystem",  "Could not read %s %lu: %s",  v138,  st_size,  v141);
        close(v79);
        goto LABEL_68;
      }

      close(v79);
      if (unlink(*(const char **)(a2 + 120)))
      {
        int v81 = *__error();
        BOOL v82 = __error();
        strerror(*v82);
        BOMCopierErrorCapture( a3,  v81,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  5239,  (uint64_t)"finalize_entry_filesystem",  "Could not unlink %s: %s");
        goto LABEL_68;
      }

      if (symlink((const char *)v58, *(const char **)(a2 + 120)))
      {
        int v154 = *__error();
        uint64_t v155 = *(void *)(a2 + 120);
        AAArchiveStream v156 = __error();
        strerror(*v156);
        BOMCopierErrorCapture( a3,  v154,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  5247,  (uint64_t)"finalize_entry_filesystem",  "Could not symlink %s to %s: %s",  v155);
        goto LABEL_68;
      }

      uint64_t v173 = *(os_log_s **)a1;
      if (*(void *)a1 && os_log_type_enabled(*(os_log_t *)a1, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v174 = *(void *)(a2 + 120);
        *(_DWORD *)__bp = 136315394;
        *(void *)&__bp[4] = v174;
        *(_WORD *)&__bp[12] = 2080;
        *(void *)&__bp[14] = v58;
        _os_log_impl( &dword_1862F3000,  v173,  OS_LOG_TYPE_DEFAULT,  "Transmogrified symlink: %s to %s",  (uint8_t *)__bp,  0x16u);
      }

      free(v58);
      unsigned int Type = v77;
      goto LABEL_51;
    case 0x11u:
      AppleDoubleTarget = (const char *)BOMCopierSourceEntryGetAppleDoubleTarget(v7);
      to = 0LL;
      asprintf(&to, "%s/%s", *(const char **)(a2 + 136), AppleDoubleTarget);
      if (!to)
      {
        int v27 = *__error();
        uint64_t v28 = *(void *)(a2 + 136);
        int v29 = __error();
        strerror(*v29);
        BOMCopierErrorCapture( a3,  v27,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  5298,  (uint64_t)"finalize_entry_filesystem",  "Could not construct target path for %s and %s: %s",  v28);
        return 1LL;
      }

      if (lstat(to, &v193))
      {
        int v13 = *__error();
        uint64_t v14 = __error();
        strerror(*v14);
        BOMCopierErrorCapture( a3,  v13,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  5306,  (uint64_t)"finalize_entry_filesystem",  "Could not lstat %s: %s");
        return 1LL;
      }

      if (*(_BYTE *)(a1 + 160)) {
        copyfile_flags_t v37 = 9175045;
      }
      else {
        copyfile_flags_t v37 = 9175044;
      }
      if (copyfile(*(const char **)(a2 + 120), to, 0LL, v37) < 0)
      {
        if (*__error() != 45)
        {
          int v126 = *__error();
          uint64_t v127 = *(void *)(a2 + 120);
          int v128 = __error();
          strerror(*v128);
          BOMCopierErrorCapture( a3,  v126,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  5387,  (uint64_t)"finalize_entry_filesystem",  "Could not merge %s to %s: %s",  v127);
          goto LABEL_179;
        }

        free(to);
        uint64_t v83 = *(os_log_s **)a1;
        if (v83 && os_log_type_enabled(v83, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v84 = *(void *)(a2 + 120);
          *(_DWORD *)__bp = 136315138;
          *(void *)&__bp[4] = v84;
          _os_log_impl( &dword_1862F3000,  v83,  OS_LOG_TYPE_DEFAULT,  "AppleDouble merge not supported on this filesystem. Unlinking %s",  (uint8_t *)__bp,  0xCu);
        }

        if (unlink(*(const char **)(a2 + 120)))
        {
          int v85 = *__error();
          int v86 = __error();
          strerror(*v86);
          BOMCopierErrorCapture( a3,  v85,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  5380,  (uint64_t)"finalize_entry_filesystem",  "Could not unlink %s: %s");
          return 1LL;
        }
      }

      else
      {
        unsigned int v38 = *(os_log_s **)a1;
        if (v38 && os_log_type_enabled(v38, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v39 = *(void *)(a2 + 120);
          *(_DWORD *)__bp = 136315394;
          *(void *)&__bp[4] = v39;
          *(_WORD *)&__bp[12] = 2080;
          *(void *)&__bp[14] = to;
          _os_log_impl( &dword_1862F3000,  v38,  OS_LOG_TYPE_DEFAULT,  "Merged AppleDouble %s to %s",  (uint8_t *)__bp,  0x16u);
        }

        if (unlink(*(const char **)(a2 + 120)))
        {
          int v40 = *__error();
          unsigned int v41 = __error();
          strerror(*v41);
          BOMCopierErrorCapture( a3,  v40,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  5398,  (uint64_t)"finalize_entry_filesystem",  "Could not unlink %s: %s");
LABEL_179:
          uint64_t v61 = to;
          goto LABEL_180;
        }

        acl_t file = acl_get_file(to, ACL_TYPE_EXTENDED);
        if (file)
        {
          size_t v89 = file;
          uint64_t v90 = acl_init(0);
          if (!v90)
          {
            int v146 = *__error();
            int v147 = __error();
            strerror(*v147);
            BOMCopierErrorCapture( a3,  v146,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  5427,  (uint64_t)"finalize_entry_filesystem",  "Could not create empty ACL for %s: %s");
            goto LABEL_179;
          }

          int v91 = v90;
          int v92 = acl_set_file(to, ACL_TYPE_EXTENDED, v90);
          free(v91);
          if (v92)
          {
            int v93 = *__error();
            int v94 = __error();
            strerror(*v94);
            BOMCopierErrorCapture( a3,  v93,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  5438,  (uint64_t)"finalize_entry_filesystem",  "Could not remove saved ACL from %s: %s");
            goto LABEL_179;
          }

          int v148 = acl_set_file(to, ACL_TYPE_EXTENDED, v89);
          acl_free(v89);
          if (v148)
          {
            int v149 = *__error();
            int v150 = __error();
            strerror(*v150);
            BOMCopierErrorCapture( a3,  v149,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  5478,  (uint64_t)"finalize_entry_filesystem",  "Could not re-apply saved ACL to %s: %s");
            goto LABEL_179;
          }
        }

        *(void *)&uint8_t buf[16] = 0LL;
        *(_OWORD *)statfs buf = xmmword_18635ACA8;
        *(timespec *)__bp = v193.st_mtimespec;
        *(timespec *)&__bp[16] = v193.st_atimespec;
        if (setattrlist(to, buf, __bp, 0x20uLL, 1u) && *__error() != 13)
        {
          int v151 = *__error();
          int v152 = __error();
          strerror(*v152);
          BOMCopierErrorCapture( a3,  v151,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  5514,  (uint64_t)"finalize_entry_filesystem",  "Could not setattrlist timestamps for %s: %s");
          return 1LL;
        }

        free(to);
      }

      return 0LL;
    case 0x12u:
      uint64_t SymlinkTarget = BOMCopierSourceEntryGetSymlinkTarget(*(void *)(a2 + 8));
      if (!SymlinkTarget)
      {
        int v30 = *__error();
        BOMCopierErrorCapture( a3,  v30,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  5266,  (uint64_t)"finalize_entry_filesystem",  "Missing symlink target for %s");
        return 1LL;
      }

      AAFieldKey v17 = (const char *)SymlinkTarget;
      if (unlink(*(const char **)(a2 + 120)))
      {
        int v18 = *__error();
        uint64_t v19 = __error();
        strerror(*v19);
        BOMCopierErrorCapture( a3,  v18,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  5273,  (uint64_t)"finalize_entry_filesystem",  "Could not unlink placeholder at %s: %s");
        return 1LL;
      }

      if (symlink(v17, *(const char **)(a2 + 120)))
      {
        int v42 = *__error();
        uint64_t v43 = *(void *)(a2 + 120);
        __int128 v44 = __error();
        strerror(*v44);
        BOMCopierErrorCapture( a3,  v42,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  5280,  (uint64_t)"finalize_entry_filesystem",  "Could not symlink %s to %s: %s",  v43);
        return 1LL;
      }

LABEL_51:
      unsigned int v175 = Type;
      ExtendedAttributeCFIndex Count = BOMCopierSourceEntryGetExtendedAttributeCount(v7, a3);
      if (!ExtendedAttributeCount) {
        goto LABEL_65;
      }
      int v46 = ExtendedAttributeCount;
      for (unsigned int i = 0; i != v46; ++i)
      {
        ExtendedAttributeName = (const char *)BOMCopierSourceEntryGetExtendedAttributeName(v7, i, a3);
        if (!ExtendedAttributeName)
        {
          uint64_t v36 = 1LL;
          BOMCopierErrorCapture( a3,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  5654,  (uint64_t)"finalize_entry_filesystem",  "Could not get xattr name for index %d");
          return v36;
        }

        AAFieldKey v49 = ExtendedAttributeName;
        if (strcmp(ExtendedAttributeName, "com.apple.ResourceFork") || !*(_BYTE *)(a2 + 155))
        {
          ExtendedAttributeuint64_t Size = BOMCopierSourceEntryGetExtendedAttributeSize(v7, i, a3);
          if (!ExtendedAttributeSize)
          {
            uint64_t v36 = 1LL;
            BOMCopierErrorCapture( a3,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  5681,  (uint64_t)"finalize_entry_filesystem",  "Could not get xattr size for index %d: %s");
            return v36;
          }

          size_t v51 = ExtendedAttributeSize;
          int v52 = malloc(ExtendedAttributeSize);
          if (!v52)
          {
            size_t v71 = __error();
            strerror(*v71);
            uint64_t v36 = 1LL;
            BOMCopierErrorCapture( a3,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  5688,  (uint64_t)"finalize_entry_filesystem",  "Could not allocate buffer for value: %s\n");
            return v36;
          }

          int v53 = v52;
          if (BOMCopierSourceEntryCopyExtendedAttribute(v7, i, v52, v51, 0, a3) != v51)
          {
            uint64_t v36 = 1LL;
            BOMCopierErrorCapture( a3,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  5695,  (uint64_t)"finalize_entry_filesystem",  "Could not copy attribute value for index %d: %s\n");
            return v36;
          }

          if (setxattr(*(const char **)(a2 + 144), v49, v53, v51, 0, 1))
          {
            int v72 = *__error();
            uint64_t v73 = __error();
            strerror(*v73);
            BOMCopierErrorCapture( a3,  v72,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  5702,  (uint64_t)"finalize_entry_filesystem",  "Could not set xattr %s on %s: %s",  v49);
            return 1LL;
          }

          int v54 = *(os_log_s **)a1;
          if (*(void *)a1 && os_log_type_enabled(*(os_log_t *)a1, OS_LOG_TYPE_DEFAULT))
          {
            __darwin_ino64_t v55 = *(void *)(a2 + 120);
            v193.st_dev = 136315394;
            *(void *)&v193.st_mode = v49;
            WORD2(v193.st_ino) = 2080;
            *(__darwin_ino64_t *)((char *)&v193.st_ino + 6) = v55;
            _os_log_impl(&dword_1862F3000, v54, OS_LOG_TYPE_DEFAULT, "Applied xattr %s to %s", (uint8_t *)&v193, 0x16u);
          }

          free(v53);
        }
      }

  if (*(_DWORD *)(a1 + 1028) == -1)
  {
    if (v36 > *(_DWORD *)(a1 + 1032)) {
      *(_DWORD *)(a1 + 1032) = v36;
    }
  }

  else
  {
    _AddToWriteCache(a1, v22, v20);
  }

  int v35 = _AdjustFileSize(a1, v22, v20);
  uint64_t result = 1LL;
  if (!v35)
  {
    *(_DWORD *)(a1 + 1116) = 1;
    return 0LL;
  }

  return result;
}

LABEL_65:
      size_t v56 = *(void *)(a2 + 312);
      unsigned int v57 = v175;
      if (!v56) {
        goto LABEL_73;
      }
      uint64_t v58 = *(void **)(a2 + 320);
      if (!setxattr(*(const char **)(a2 + 144), "com.apple.rootless", v58, v56, 0, 1))
      {
        int v62 = *(os_log_s **)a1;
        if (*(void *)a1 && os_log_type_enabled(*(os_log_t *)a1, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v63 = *(void *)(a2 + 120);
          v193.st_dev = 136315138;
          *(void *)&v193.st_mode = v63;
          _os_log_impl( &dword_1862F3000,  v62,  OS_LOG_TYPE_DEFAULT,  "Applied xattr com.apple.rootless to %s",  (uint8_t *)&v193,  0xCu);
        }

LABEL_73:
        to = 0LL;
        ACL = (const char *)BOMCopierSourceEntryGetACL(v7, &to, a3);
        if (ACL && to)
        {
          acl_t v65 = acl_from_text(ACL);
          if (!v65)
          {
            int v74 = *__error();
            int v75 = __error();
            strerror(*v75);
            BOMCopierErrorCapture( a3,  v74,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  5755,  (uint64_t)"finalize_entry_filesystem",  "Could not create ACL from text [%s]: %s");
            return 1LL;
          }

          CFIndex v66 = v65;
          unsigned int v67 = *(const char **)(a2 + 144);
          if (v175 == 9)
          {
            int v68 = open(v67, 0x200000);
            if (v68 == -1)
            {
              int v133 = *__error();
              int v134 = __error();
              strerror(*v134);
              BOMCopierErrorCapture( a3,  v133,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  5768,  (uint64_t)"finalize_entry_filesystem",  "Unable to open the symlink %s: %s\n");
              return 1LL;
            }

            int v69 = v68;
            int v70 = acl_set_fd_np(v68, v66, ACL_TYPE_EXTENDED);
            close(v69);
            unsigned int v57 = v175;
          }

          else
          {
            int v70 = acl_set_file(v67, ACL_TYPE_EXTENDED, v66);
          }

          acl_free(v66);
          if (v70)
          {
            uint64_t v87 = __error();
            strerror(*v87);
            uint64_t v36 = 1LL;
            BOMCopierErrorCapture( a3,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  5783,  (uint64_t)"finalize_entry_filesystem",  "Could not set ACL on %s: %s");
            return v36;
          }

          int v95 = *(os_log_s **)a1;
          if (*(void *)a1 && os_log_type_enabled(*(os_log_t *)a1, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v96 = *(void *)(a2 + 144);
            v193.st_dev = 136315138;
            *(void *)&v193.st_mode = v96;
            _os_log_impl(&dword_1862F3000, v95, OS_LOG_TYPE_DEFAULT, "Applied ACL to %s", (uint8_t *)&v193, 0xCu);
          }
        }

        if (v57 == 8)
        {
          uint64_t v97 = *(const void **)(a1 + 24);
          if (v97)
          {
            if (setxattr(*(const char **)(a2 + 144), "com.apple.provenance", v97, *(void *)(a1 + 32), 0, 1))
            {
              int v98 = *__error();
              int v99 = __error();
              strerror(*v99);
              BOMCopierErrorCapture( a3,  v98,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  5808,  (uint64_t)"finalize_entry_filesystem",  "Could not set provenance xattr %s: %s");
              return 1LL;
            }

            int v129 = *(os_log_s **)a1;
            if (*(void *)a1 && os_log_type_enabled(*(os_log_t *)a1, OS_LOG_TYPE_DEFAULT))
            {
              uint64_t v130 = *(void *)(a2 + 120);
              v193.st_dev = 136315138;
              *(void *)&v193.st_mode = v130;
              _os_log_impl( &dword_1862F3000,  v129,  OS_LOG_TYPE_DEFAULT,  "Applied xattr com.apple.provenance to %s",  (uint8_t *)&v193,  0xCu);
            }
          }
        }

        else if (v57 != 6)
        {
          goto LABEL_141;
        }

        unsigned int Flags = BOMCopierSourceEntryGetFlags(v7);
        if ((Flags & 0x80000) != 0 && *(_BYTE *)(a1 + 302) == 0) {
          unsigned int v102 = Flags & 0xFFF7FFFF;
        }
        else {
          unsigned int v102 = Flags;
        }
        if (*(_BYTE *)(a2 + 153) && *(_BYTE *)(a1 + 303)) {
          v102 |= *(_DWORD *)(a2 + 284) & 0x80000;
        }
        if (lstat(*(const char **)(a2 + 144), &v193))
        {
          int v103 = *__error();
          int v104 = __error();
          strerror(*v104);
          BOMCopierErrorCapture( a3,  v103,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  5863,  (uint64_t)"finalize_entry_filesystem",  "Could not lstat %s: %s\n");
          return 1LL;
        }

        if (BOMCopierSourceEntryIsCompressed(v7) && !*(_BYTE *)(a1 + 113)) {
          v102 &= ~0x20u;
        }
        if (*(_BYTE *)(a1 + 112) && (v193.st_flags & 0x40000020) == 0x20) {
          v102 |= 0x20u;
        }
        uid_t v105 = geteuid();
        unsigned int v106 = v102 & 0xC000FFFF;
        if (!v105) {
          unsigned int v106 = v102;
        }
        if ((~v106 & 0x40000020) != 0) {
          __uint32_t v107 = v106;
        }
        else {
          __uint32_t v107 = v106 & 0xBFFFFFDF;
        }
        if (v107)
        {
          if (change_flags(*(const char **)(a2 + 144), v193.st_flags, v107) && *__error() != 45)
          {
            int v142 = *__error();
            uint64_t v143 = *(void *)(a2 + 144);
            uint64_t st_flags = v193.st_flags;
            int v145 = __error();
            strerror(*v145);
            BOMCopierErrorCapture( a3,  v142,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  5926,  (uint64_t)"finalize_entry_filesystem",  "Could not change file flags on %s from %u to %u: %s. Calling error handler",  v143,  st_flags);
            return 1LL;
          }

          int v108 = *(os_log_s **)a1;
          if (*(void *)a1 && os_log_type_enabled(*(os_log_t *)a1, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v109 = *(void *)(a2 + 120);
            *(_DWORD *)__bp = 136315650;
            *(void *)&__bp[4] = v109;
            *(_WORD *)&__bp[12] = 1024;
            *(_DWORD *)&__bp[14] = v193.st_flags;
            *(_WORD *)&__bp[18] = 1024;
            *(_DWORD *)&__bp[20] = v107;
            _os_log_impl( &dword_1862F3000,  v108,  OS_LOG_TYPE_DEFAULT,  "Changed file flags on %s from %u to %u",  (uint8_t *)__bp,  0x18u);
          }
        }

        --v39;
      }

      while (v39);
    }

    int v70 = (int *)(a1 + 12772);
    size_t v71 = *(_DWORD *)(a1 + 12772);
    if (v71 == 3)
    {
      if (BOMPKZipSkipDigitalSignature(*(int ***)(a1 + 12752)))
      {
        int v72 = "Could not skip the digital signature.";
LABEL_109:
        BOMCopierNotifyFatalError(a1, v72, v33, v34, v35, v36, v37, v38, v99);
        goto LABEL_110;
      }

      if (BOMPKZipReadNextSignature(*(void *)(a1 + 12752), (int *)(a1 + 12772)))
      {
LABEL_88:
        int v72 = "Could not read next signature";
        goto LABEL_109;
      }

      size_t v71 = *v70;
    }

    if (v71 == 4)
    {
      if (BOMPKZipSkipZIP64CentralDirectoryRecord(*(int ***)(a1 + 12752)))
      {
        int v72 = "Could not skip the ZIP64 central dir record.";
        goto LABEL_109;
      }

      size_t v71 = *v70;
    }

    if (v71 == 5)
    {
      if (BOMPKZipSkipZIP64CentralDirectoryLocation(*(int ***)(a1 + 12752)))
      {
        int v72 = "Could not skip the ZIP64 central dir locator.";
        goto LABEL_109;
      }

      if (BOMPKZipReadNextSignature(*(void *)(a1 + 12752), (int *)(a1 + 12772)))
      {
        int v72 = "Couldn't read next signature";
        goto LABEL_109;
      }

      size_t v71 = *v70;
    }

    if (v71 != 6)
    {
      int v72 = "I'm expecting the end of central directory record.";
      goto LABEL_109;
    }

    if (BOMPKZipSkipEndOfCentralDirectoryRecord(*(int ***)(a1 + 12752)))
    {
      int v72 = "Could not skip the end of the central directory record.";
      goto LABEL_109;
    }

    if (*(_BYTE *)(a1 + 12768))
    {
      uint64_t v87 = BOMPKZipQuarantinePathCount((uint64_t)v109);
      if (v87 - 1 >= 0)
      {
        size_t v88 = v87;
        size_t v89 = (unsigned __int8 *)(a1 + 7424);
        while (!BOMPKZipCopyQuarantinePath((uint64_t)v109, --v88, (void *)(a1 + 7424)))
        {
          uint64_t v90 = *v89;
          if (v90 == 46 && *(_BYTE *)(a1 + 7425) == 47) {
            int v91 = 2LL;
          }
          else {
            int v91 = v90 == 47;
          }
          snprintf((char *)(a1 + 3328), 0x400uLL, "%s/%s", __s, (const char *)&v89[v91]);
          (*(void (**)(void, uint64_t))(*(void *)(a1 + 12832) + 232LL))( *(void *)(*(void *)(a1 + 12832) + 8LL),  a1 + 3328);
          AAFieldKey v17 = 0LL;
          if (v88 <= 0) {
            goto LABEL_8;
          }
        }

        int v72 = "Could not copy quarantined directory path.";
        goto LABEL_109;
      }
    }

LABEL_141:
        if (apply_retention_policy(a1, a2, a3))
        {
          uint64_t v36 = 1LL;
          BOMCopierErrorCapture( a3,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  5944,  (uint64_t)"finalize_entry_filesystem",  "Could not apply retention policy");
          return v36;
        }

        int v110 = *(_DWORD *)(a1 + 8);
        uint64_t UserID = BOMCopierSourceEntryGetUserID(v7);
        gid_t GroupID = BOMCopierSourceEntryGetGroupID(v7);
        int Mode = BOMCopierSourceEntryGetMode(v7);
        if (*(_DWORD *)(a1 + 8) || *(_BYTE *)(a1 + 305))
        {
          BOOL v115 = v175 == 8 && *(_BYTE *)(a1 + 306) != 0;
        }

        else
        {
          if (*(_BYTE *)(a1 + 20)) {
            int v153 = BOMCopierSourceEntryGetHonorsSetuid(v7) ^ 1;
          }
          else {
            int v153 = 0;
          }
          BOOL v115 = v175 == 8 && *(_BYTE *)(a1 + 306) != 0;
          if ((v153 & 1) == 0 && !v115)
          {
LABEL_160:
            uint64_t v120 = "symlink";
            uint64_t v121 = "post-order directory";
            switch(v175)
            {
              case 6u:
                uint64_t v121 = "directory";
                goto LABEL_192;
              case 8u:
              case 0xFu:
                if (v175 == 15) {
                  int v122 = "extra regular file";
                }
                else {
                  int v122 = "regular file";
                }
                if (v110 || !chown(*(const char **)(a2 + 120), UserID, GroupID))
                {
                  __int128 v198 = 0u;
                  memset(v199, 0, sizeof(v199));
                  __int128 v196 = 0u;
                  __int128 v197 = 0u;
                  __int128 v194 = 0u;
                  __int128 v195 = 0u;
                  memset(&v193, 0, sizeof(v193));
                  strmode((unsigned __int16)Mode, (char *)&v193);
                  int v123 = *__error();
                  uint64_t v124 = *(void *)(a2 + 120);
                  int v125 = __error();
                  strerror(*v125);
                  BOMCopierErrorCapture( a3,  v123,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  6132,  (uint64_t)"finalize_entry_filesystem",  "Could not chmod %s %s to %s: %s",  v122,  v124);
                }

                else
                {
                  int v169 = *__error();
                  uint64_t v170 = *(void *)(a2 + 120);
                  char v171 = __error();
                  strerror(*v171);
                  BOMCopierErrorCapture( a3,  v169,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  6120,  (uint64_t)"finalize_entry_filesystem",  "Could not chown %s to %d:%d: %s",  v170,  UserID);
                }

                return 1LL;
              case 9u:
              case 0x10u:
                goto LABEL_200;
              case 0xDu:
                goto LABEL_192;
              case 0xEu:
                uint64_t v121 = "extra directory";
LABEL_192:
                if (!v110 && chown(*(const char **)(a2 + 120), UserID, GroupID))
                {
                  int v160 = *__error();
                  uint64_t v161 = *(void *)(a2 + 120);
                  BOOL v162 = __error();
                  strerror(*v162);
                  BOMCopierErrorCapture( a3,  v160,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  6068,  (uint64_t)"finalize_entry_filesystem",  "Could not chown %s to %d:%d: %s",  v161,  UserID);
                  return 1LL;
                }

                if ((!*(_BYTE *)(a2 + 153) || *(_BYTE *)(a1 + 43)) && chmod(*(const char **)(a2 + 120), Mode))
                {
                  __int128 v198 = 0u;
                  memset(v199, 0, sizeof(v199));
                  __int128 v196 = 0u;
                  __int128 v197 = 0u;
                  __int128 v194 = 0u;
                  __int128 v195 = 0u;
                  memset(&v193, 0, sizeof(v193));
                  strmode((unsigned __int16)Mode, (char *)&v193);
                  int v157 = *__error();
                  uint64_t v158 = *(void *)(a2 + 120);
                  int v159 = __error();
                  strerror(*v159);
                  BOMCopierErrorCapture( a3,  v157,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  6098,  (uint64_t)"finalize_entry_filesystem",  "Could not chmod %s %s to %s: %s",  v121,  v158);
                  return 1LL;
                }

                goto LABEL_203;
              case 0x12u:
                uint64_t v120 = "replay symlink";
LABEL_200:
                if (!v110 && lchown(*(const char **)(a2 + 120), UserID, GroupID))
                {
                  int v166 = *__error();
                  uint64_t v167 = *(void *)(a2 + 120);
                  int v168 = __error();
                  strerror(*v168);
                  BOMCopierErrorCapture( a3,  v166,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  6157,  (uint64_t)"finalize_entry_filesystem",  "Could not lchown %s to %d:%d: %s",  v167,  UserID);
                  return 1LL;
                }

                if (lchmod(*(const char **)(a2 + 120), Mode))
                {
                  __int128 v198 = 0u;
                  memset(v199, 0, sizeof(v199));
                  __int128 v196 = 0u;
                  __int128 v197 = 0u;
                  __int128 v194 = 0u;
                  __int128 v195 = 0u;
                  memset(&v193, 0, sizeof(v193));
                  strmode((unsigned __int16)Mode, (char *)&v193);
                  int v163 = *__error();
                  uint64_t v164 = *(void *)(a2 + 120);
                  uint64_t v165 = __error();
                  strerror(*v165);
                  BOMCopierErrorCapture( a3,  v163,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  6169,  (uint64_t)"finalize_entry_filesystem",  "Could not lchmod %s %s to %s: %s",  v120,  v164);
                  return 1LL;
                }

uint64_t finalize_entry_apple_archive(uint64_t a1, void *a2)
{
  uint64_t v4 = *(char **)(a1 + 344);
  if (v4
    && (*(_DWORD *)(a1 + 328) = 4997953,
        BOMCopierDestinationEntryWrite(a1, v4, *(void *)(a1 + 352), a2) != *(void *)(a1 + 352)))
  {
    int v7 = *__error();
    BOMCopierErrorCapture( a2,  v7,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  6221,  (uint64_t)"finalize_entry_apple_archive",  "Could not write encoded AppleArchive ACL buffer to the destination");
  }

  else
  {
    uint64_t v5 = *(char **)(a1 + 360);
    if (!v5) {
      return 0LL;
    }
    *(_DWORD *)(a1 + 328) = 5521752;
    if (BOMCopierDestinationEntryWrite(a1, v5, *(void *)(a1 + 368), a2) == *(void *)(a1 + 368)) {
      return 0LL;
    }
    int v8 = *__error();
    BOMCopierErrorCapture( a2,  v8,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  6241,  (uint64_t)"finalize_entry_apple_archive",  "Could not write encoded AppleArchive XAT buffer to the destination");
  }

  return 1LL;
}

uint64_t BOMCopierDestinationEntryGetMatchType(uint64_t a1, void *a2)
{
  if (a1) {
    return *(unsigned int *)(a1 + 32);
  }
  BOMCopierErrorCapture( a2,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  1943,  (uint64_t)"BOMCopierDestinationEntryGetMatchType",  "destination_entry is NULL");
  return 0LL;
}

uint64_t BOMCopierDestinationEntryGetMatchRecordCount(uint64_t a1, void *a2)
{
  if (a1) {
    return *(unsigned int *)(a1 + 36);
  }
  BOMCopierErrorCapture( a2,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  1961,  (uint64_t)"BOMCopierDestinationEntryGetMatchRecordCount",  "destination_entry is NULL");
  return 0LL;
}

uint64_t BOMCopierDestinationEntryGetMatchRecord(uint64_t a1, unsigned int a2, uint64_t a3, void *a4)
{
  if (a1)
  {
    if (*(_DWORD *)(a1 + 36) <= a2)
    {
      BOMCopierErrorCapture( a4,  34,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  1987,  (uint64_t)"BOMCopierDestinationEntryGetMatchRecord",  "index %d is out of range",  a2);
      return 22LL;
    }

    else if (a3)
    {
      uint64_t v4 = 0LL;
      uint64_t v5 = *(void *)(a1 + 40) + 40LL * a2;
      __int128 v6 = *(_OWORD *)v5;
      __int128 v7 = *(_OWORD *)(v5 + 16);
      *(void *)(a3 + 32) = *(void *)(v5 + 32);
      *(_OWORD *)a3 = v6;
      *(_OWORD *)(a3 + 16) = v7;
    }

    else
    {
      uint64_t v4 = 22LL;
      BOMCopierErrorCapture( a4,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  1993,  (uint64_t)"BOMCopierDestinationEntryGetMatchRecord",  "match_record is NULL");
    }
  }

  else
  {
    uint64_t v4 = 22LL;
    BOMCopierErrorCapture( a4,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  1981,  (uint64_t)"BOMCopierDestinationEntryGetMatchRecord",  "destination_entry is NULL");
  }

  return v4;
}

uint64_t BOMCopierDestinationEntryWriteFatHeader(uint64_t a1, size_t *a2, void *a3)
{
  if (a1)
  {
    if (a2)
    {
      Binaryunsigned int Type = BOMCopierSourceEntryGetBinaryType(*(void *)(a1 + 8));
      if ((BinaryType - 5) > 0xFFFFFFFD)
      {
        int v9 = BinaryType;
        unsigned int v10 = 20;
        if (BinaryType == 4) {
          unsigned int v10 = 32;
        }
        unsigned int v11 = *(_DWORD *)(a1 + 48);
        size_t v12 = v10 * (unint64_t)v11 + 8;
        int v13 = (char *)malloc(v12);
        if (v13)
        {
          uint64_t v14 = v13;
          if (v9 == 4) {
            int v15 = -889275713;
          }
          else {
            int v15 = -889275714;
          }
          int8x8_t v28 = (int8x8_t)__PAIR64__(v11, v15);
          BOMSwapFatHeader(&v28, 2);
          *(int8x8_t *)uint64_t v14 = v28;
          if (*(_DWORD *)(a1 + 36))
          {
            uint64_t v16 = 0LL;
            unint64_t v17 = 0LL;
            int v18 = v14 + 8;
            do
            {
              uint64_t v19 = *(void *)(a1 + 40);
              if (*(_BYTE *)(v19 + v16))
              {
                uint64_t v20 = v19 + v16;
                *(void *)int v27 = *(void *)(v20 + 4);
                if (v9 == 4)
                {
                  *(_OWORD *)&v27[8] = *(_OWORD *)(v20 + 16);
                  *(_DWORD *)&v27[24] = *(void *)(v20 + 32);
                  *(_DWORD *)&v27[28] = 0;
                  BOMSwapFatArch64((uint64_t)v27, 1u, 2);
                  __int128 v21 = *(_OWORD *)&v27[16];
                  *int v18 = *(_OWORD *)v27;
                  v18[1] = v21;
                  v18 += 2;
                }

                else
                {
                  *(int32x2_t *)&v27[8] = vmovn_s64(*(int64x2_t *)(v20 + 16));
                  *(_DWORD *)&v27[16] = *(void *)(v20 + 32);
                  BOMSwapFatArch((uint64_t)v27, 1u, 2);
                  int v22 = *(_DWORD *)&v27[16];
                  *int v18 = *(_OWORD *)v27;
                  *((_DWORD *)v18 + 4) = v22;
                  int v18 = (_OWORD *)((char *)v18 + 20);
                }
              }

              ++v17;
              v16 += 40LL;
            }

            while (v17 < *(unsigned int *)(a1 + 36));
          }

          uint64_t v23 = BOMCopierDestinationEntryWrite(a1, v14, v12, a3);
          free(v14);
          if (v23 == v12)
          {
            uint64_t v7 = 0LL;
            *a2 = v12;
          }

          else
          {
            uint64_t v7 = 1LL;
            BOMCopierErrorCapture( a3,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  2132,  (uint64_t)"BOMCopierDestinationEntryWriteFatHeader",  "Could not write the fat header to the destination entry");
          }
        }

        else
        {
          int v24 = *__error();
          uint64_t v25 = __error();
          int v26 = strerror(*v25);
          BOMCopierErrorCapture( a3,  v24,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  2059,  (uint64_t)"BOMCopierDestinationEntryWriteFatHeader",  "Could not allocate %ld bytes: %s",  v12,  v26);
          return 1LL;
        }
      }

      else
      {
        uint64_t v7 = 22LL;
        BOMCopierErrorCapture( a3,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  2027,  (uint64_t)"BOMCopierDestinationEntryWriteFatHeader",  "source entry is not a fat file");
      }
    }

    else
    {
      uint64_t v7 = 22LL;
      BOMCopierErrorCapture( a3,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  2020,  (uint64_t)"BOMCopierDestinationEntryWriteFatHeader",  "fat_header_size is NULL");
    }
  }

  else
  {
    uint64_t v7 = 22LL;
    BOMCopierErrorCapture( a3,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  2014,  (uint64_t)"BOMCopierDestinationEntryWriteFatHeader",  "destination_entry is NULL");
  }

  return v7;
}

uint64_t BOMCopierDestinationEntryWrite(uint64_t a1, char *__buf, size_t nbyte, void *a4)
{
  if (!a1)
  {
    BOMCopierErrorCapture( a4,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  2159,  (uint64_t)"BOMCopierDestinationEntryWrite",  "destination_entry is NULL");
    return -1LL;
  }

  if (!__buf)
  {
    BOMCopierErrorCapture( a4,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  2165,  (uint64_t)"BOMCopierDestinationEntryWrite",  "buffer is NULL");
    return -1LL;
  }

  if (!nbyte)
  {
    BOMCopierErrorCapture( a4,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  2171,  (uint64_t)"BOMCopierDestinationEntryWrite",  "num_bytes is 0");
    return -1LL;
  }

  switch(*(_DWORD *)a1)
  {
    case 0:
      uint64_t v8 = 0LL;
      int v9 = __buf;
      break;
    case 1:
      if (*(void *)(a1 + 72))
      {
        uint64_t v8 = write_data_libarchive((void *)a1, (uint64_t)__buf, nbyte, a4);
        goto LABEL_27;
      }

      uint64_t v8 = 22LL;
      BOMCopierErrorCapture( a4,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  2192,  (uint64_t)"BOMCopierDestinationEntryWrite",  "destination_entry->archive is NULL");
      return v8;
    case 2:
      AAFieldKey v13 = *(AAFieldKey *)(a1 + 328);
      if (!AAArchiveStreamWriteBlob(*(AAArchiveStream *)(a1 + 336), v13, __buf, nbyte)) {
        goto LABEL_26;
      }
      BOMCopierErrorCapture( a4,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  6930,  (uint64_t)"write_data_apple_archive",  "Could not write to AppleArchive: %u");
      return -1LL;
    case 3:
LABEL_26:
      *(void *)(a1 + 112) += nbyte;
      uint64_t v8 = nbyte;
LABEL_27:
      uint64_t v14 = *(uint64_t **)(a1 + 24);
      BOMCopierErrorCapture( a4,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  2221,  (uint64_t)"BOMCopierDestinationEntryWrite",  "Could not update data analyzer");
      return -1LL;
    default:
      return 0LL;
  }

  while (1)
  {
    size_t v10 = nbyte - v8 >= 0x7FFFFFFF ? 0x7FFFFFFFLL : nbyte - v8;
    if (*(void *)(a1 + 160)) {
      break;
    }
    ssize_t v11 = write(*(_DWORD *)(a1 + 68), v9, v10);
    if (v11 == -1)
    {
      int v15 = __error();
      strerror(*v15);
      BOMCopierErrorCapture( a4,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  6748,  (uint64_t)"write_data_filesystem",  "Could not write %ld bytes: %s\n");
      return -1LL;
    }

LABEL_13:
    v9 += v11;
    v8 += v11;
    if (v11) {
      BOOL v12 = v8 == nbyte;
    }
    else {
      BOOL v12 = 1;
    }
    if (v12)
    {
      *(void *)(a1 + 112) += v8;
      goto LABEL_27;
    }
  }

  ssize_t v11 = ParallelCompressionAFSCStreamWrite();
  if (v11 != -1) {
    goto LABEL_13;
  }
  uint64_t v8 = -1LL;
  BOMCopierErrorCapture( a4,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  6740,  (uint64_t)"write_data_filesystem",  "Could not AFSC compress %ld bytes: %ld\n");
  return v8;
}

  uint64_t v19 = *(const char **)(a1 + 144);
  if (v19)
  {
    uint64_t v20 = strlen(v19) + 1;
    __int128 v21 = (char *)BOM_malloc(v20);
    v3[18] = v21;
    if (v21)
    {
      strlcpy(v21, *(const char **)(a1 + 144), v20);
      *(_BYTE *)(a1 + 152) = 1;
      return v3;
    }

    goto LABEL_16;
  }

  return v3;
}

        BOMTreeFree(v9);
        return 0LL;
      }

      fprintf((FILE *)*MEMORY[0x1895F89D0], "Tree '%s' has an unknown version: 0x%X\n");
    }

    else
    {
      fprintf((FILE *)*MEMORY[0x1895F89D0], "%s is not a Tree\n");
    }

    BOMStreamFree(v11);
    goto LABEL_13;
  }

  return v9;
}

uint64_t write_data_libarchive(void *a1, uint64_t a2, uint64_t a3, void *a4)
{
  uint64_t v8 = 0LL;
  while (1)
  {
    else {
      uint64_t v9 = a3 - v8;
    }
    if ((uint64_t)a1[11] >= 1)
    {
      unint64_t v11 = a1[12];
      uint64_t v10 = a1[13];
      unint64_t v12 = v10 + v9;
      uint64_t v13 = v11 - v10;
      if (v12 > v11) {
        uint64_t v9 = v13;
      }
    }

    uint64_t v14 = archive_write_data();
    if (!v14)
    {
LABEL_18:
      a1[14] += v8;
      return v8;
    }

    uint64_t v15 = v14;
    if (v14 == -1)
    {
      __int128 v21 = (const char *)archive_error_string();
      BOMCopierErrorCapture( a4,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  6843,  (uint64_t)"write_data_libarchive",  "Could not archive file data (%ld bytes): %s\n",  v9,  v21);
      return -1LL;
    }

    v8 += v14;
    uint64_t v16 = a1[11];
    if (v16 >= 1)
    {
      uint64_t v17 = a1[12];
      uint64_t v18 = a1[13] + v14;
      a1[13] = v18;
      if (v17 == v18)
      {
        uint64_t v19 = a1[7];
        uint64_t v20 = v19 - a1[14] - v8 >= v16 ? v16 : v19 - a1[14] - v8;
        a1[12] = v20;
        a1[13] = 0LL;
        if (v20 >= 1)
        {
          archive_entry_set_size();
        }
      }
    }

    a2 += v15;
    if (v8 == a3) {
      goto LABEL_18;
    }
  }

  uint64_t v23 = (const char *)archive_error_string();
  uint64_t v8 = 1LL;
  BOMCopierErrorCapture( a4,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  6903,  (uint64_t)"write_data_libarchive",  "Could not write next segment archive entry: %s\n",  v23);
  return v8;
}

uint64_t BOMCopierDestinationEntrySeek(int *a1, void *data, unint64_t a3, off_t len, void *a5)
{
  if (!a1)
  {
    uint64_t v15 = 22LL;
    BOMCopierErrorCapture( a5,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  2243,  (uint64_t)"BOMCopierDestinationEntrySeek",  "destination_entry is NULL");
    return v15;
  }

  int v10 = *a1;
  if (*a1 != 2)
  {
    if (v10 != 1)
    {
      if (!v10 && lseek(a1[17], len, 1) == -1)
      {
        int v11 = *__error();
        int v12 = a1[17];
        uint64_t v13 = __error();
        uint64_t v14 = strerror(*v13);
        BOMCopierErrorCapture( a5,  v11,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  6950,  (uint64_t)"seek_filesystem",  "Could not lseek in the destination %d:%lu: %s",  v12,  len,  v14);
        return 1LL;
      }

      goto LABEL_26;
    }

    if (!data)
    {
      uint64_t v15 = 22LL;
      BOMCopierErrorCapture( a5,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  2268,  (uint64_t)"BOMCopierDestinationEntrySeek",  "seek_buffer is NULL");
      return v15;
    }

    if (!a3)
    {
      uint64_t v15 = 22LL;
      BOMCopierErrorCapture( a5,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  2274,  (uint64_t)"BOMCopierDestinationEntrySeek",  "seek_buffer is NULL");
      return v15;
    }

    if (!*((void *)a1 + 9))
    {
      uint64_t v15 = 22LL;
      BOMCopierErrorCapture( a5,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  2280,  (uint64_t)"BOMCopierDestinationEntrySeek",  "destination_entry->archive is NULL");
      return v15;
    }

    if (len)
    {
      uint64_t v19 = 0LL;
      while (1)
      {
        uint64_t v20 = len - v19 >= a3 ? a3 : len - v19;
        v19 += v20;
        if (v19 == len) {
          goto LABEL_26;
        }
      }

      uint64_t v15 = 1LL;
      BOMCopierErrorCapture( a5,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  6979,  (uint64_t)"seek_libarchive",  "Could not write zeroes to the archive for seeking");
      return v15;
    }

uint64_t BOMCopierDestinationEntryGetType(uint64_t a1, void *a2)
{
  if (a1) {
    return BOMCopierSourceEntryModeToType(*(unsigned __int16 *)(a1 + 172));
  }
  BOMCopierErrorCapture( a2,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  2326,  (uint64_t)"BOMCopierDestinationEntryGetType",  "destination_entry is NULL");
  return 0LL;
}

uint64_t BOMCopierDestinationEntryGetPath(uint64_t a1, void *a2)
{
  if (a1) {
    return *(void *)(a1 + 120);
  }
  BOMCopierErrorCapture( a2,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  2344,  (uint64_t)"BOMCopierDestinationEntryGetPath",  "destination_entry is NULL");
  return 0LL;
}

uint64_t BOMCopierDestinationEntryGetTotalWritten(uint64_t a1, void *a2)
{
  if (a1) {
    return *(void *)(a1 + 112);
  }
  BOMCopierErrorCapture( a2,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  2362,  (uint64_t)"BOMCopierDestinationEntryGetTotalWritten",  "destination_entry is NULL");
  return 0LL;
}

BOOL BOMCopierDestinationEntrySkipped(uint64_t a1, void *a2)
{
  if (a1) {
    return *(_BYTE *)(a1 + 16) != 0;
  }
  BOMCopierErrorCapture( a2,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  2380,  (uint64_t)"BOMCopierDestinationEntrySkipped",  "destination_entry is NULL");
  return 0LL;
}

uint64_t BOMCopierDestinationSetInit(void *a1, size_t a2, size_t a3, uint64_t a4, void *a5)
{
  if (!a1)
  {
    uint64_t v13 = 22LL;
    BOMCopierErrorCapture( a5,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  2401,  (uint64_t)"BOMCopierDestinationSetInit",  "destination_set is NULL");
    return v13;
  }

  if (!a2)
  {
    uint64_t v13 = 22LL;
    BOMCopierErrorCapture( a5,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  2407,  (uint64_t)"BOMCopierDestinationSetInit",  "io_buffer_size is 0");
    return v13;
  }

  if (!a3)
  {
    uint64_t v13 = 22LL;
    BOMCopierErrorCapture( a5,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  2413,  (uint64_t)"BOMCopierDestinationSetInit",  "zero_buffer_size is 0");
    return v13;
  }

  if (!a4)
  {
    uint64_t v13 = 22LL;
    BOMCopierErrorCapture( a5,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  2419,  (uint64_t)"BOMCopierDestinationSetInit",  "copier_destination is NULL");
    return v13;
  }

  bzero(a1, 0x430uLL);
  *(_DWORD *)a1 = 1;
  int v10 = calloc(1uLL, 8uLL);
  a1[1] = v10;
  if (!v10)
  {
    int v15 = *__error();
    uint64_t v16 = __error();
    strerror(*v16);
    BOMCopierErrorCapture( a5,  v15,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  2435,  (uint64_t)"BOMCopierDestinationSetInit",  "Could not allocate destination list: %s");
    return 1LL;
  }

  *int v10 = a4;
  int v11 = valloc(a2);
  a1[2] = v11;
  if (!v11)
  {
    int v17 = *__error();
    AAFieldKey v18 = __error();
    strerror(*v18);
    BOMCopierErrorCapture( a5,  v17,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  2448,  (uint64_t)"BOMCopierDestinationSetInit",  "Could not allocate I/O buffer: %s");
    return 1LL;
  }

  a1[3] = a2;
  int v12 = valloc(a3);
  a1[4] = v12;
  if (!v12)
  {
    int v19 = *__error();
    uint64_t v20 = __error();
    strerror(*v20);
    BOMCopierErrorCapture( a5,  v19,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  2457,  (uint64_t)"BOMCopierDestinationSetInit",  "Could not allocate zero buffer: %s");
    return 1LL;
  }

  bzero(v12, a3);
  uint64_t v13 = 0LL;
  a1[5] = a3;
  return v13;
}

void BOMCopierDestinationSetRelease(void *a1)
{
  if (a1)
  {
    unint64_t v2 = (void *)a1[4];
    if (v2) {
      free(v2);
    }
    uint64_t v3 = (void *)a1[2];
    if (v3) {
      free(v3);
    }
    uint64_t v4 = (void *)a1[1];
    if (v4) {
      free(v4);
    }
    bzero(a1, 0x430uLL);
  }

  else
  {
    BOMCopierErrorCapture( 0LL,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  2478,  (uint64_t)"BOMCopierDestinationSetRelease",  "destination_set is NULL");
  }

uint64_t BOMCopierCopySourceEntryToDestinationSet(uint64_t a1, unsigned int *a2, void *a3)
{
  uint64_t v131 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    uint64_t v25 = 22LL;
    BOMCopierErrorCapture( a3,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  2512,  (uint64_t)"BOMCopierCopySourceEntryToDestinationSet",  "source_entry is NULL");
    return v25;
  }

  if (!a2)
  {
    uint64_t v25 = 22LL;
    BOMCopierErrorCapture( a3,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  2518,  (uint64_t)"BOMCopierCopySourceEntryToDestinationSet",  "destination_set is NULL");
    return v25;
  }

  if (!*((void *)a2 + 4))
  {
    uint64_t v25 = 22LL;
    BOMCopierErrorCapture( a3,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  2524,  (uint64_t)"BOMCopierCopySourceEntryToDestinationSet",  "zero_buffer is NULL");
    return v25;
  }

  if (!*((void *)a2 + 5))
  {
    uint64_t v25 = 22LL;
    BOMCopierErrorCapture( a3,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  2530,  (uint64_t)"BOMCopierCopySourceEntryToDestinationSet",  "zero_buffer_size is 0");
    return v25;
  }

  size_t v6 = *a2;
  uint64_t v7 = (unsigned int *)calloc(1uLL, 0x48uLL);
  if (!v7)
  {
    int v27 = *__error();
    int8x8_t v28 = __error();
    int v29 = strerror(*v28);
    BOMCopierErrorCapture( a3,  v27,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  2559,  (uint64_t)"BOMCopierCopySourceEntryToDestinationSet",  "Could not allocate copy state: %s",  v29);
    return 1LL;
  }

  uint64_t v8 = v7;
  *uint64_t v7 = *a2;
  *((void *)v7 + 1) = *((void *)a2 + 2);
  *((_OWORD *)v7 + 1) = *(_OWORD *)(a2 + 6);
  *((void *)v7 + 4) = *((void *)a2 + 5);
  *((void *)v7 + 5) = ***((void ***)a2 + 1);
  *((void *)v7 + 6) = a2 + 12;
  uint64_t v9 = (char *)calloc(v6, 0x20uLL);
  if (!v9)
  {
    int v30 = *__error();
    uint64_t v31 = __error();
    gid_t v32 = strerror(*v31);
    BOMCopierErrorCapture( a3,  v30,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  2577,  (uint64_t)"BOMCopierCopySourceEntryToDestinationSet",  "Could not allocate copy target list: %s",  v32);
    release_copy_state(v8);
    return 1LL;
  }

  int v125 = v8;
  if ((_DWORD)v6)
  {
    uint64_t v10 = 0LL;
    int v11 = (uint64_t *)*((void *)a2 + 1);
    do
    {
      uint64_t v12 = *v11++;
      *(void *)&v9[v10] = v12;
      v10 += 32LL;
    }

    while (32 * v6 != v10);
    *((void *)v8 + 7) = v9;
    int v126 = v8 + 14;
    BOOL IsCompressed = BOMCopierSourceEntryIsCompressed(a1);
    *((_BYTE *)v8 + 64) = 0;
    uint64_t v14 = v8 + 16;
    if (IsCompressed)
    {
      int v15 = 0;
      uint64_t v16 = *((void *)a2 + 1);
      size_t v17 = v6;
      do
      {
        if (*(_BYTE *)(*(void *)v16 + 113LL)) {
          v15 += *(unsigned __int8 *)(*(void *)v16 + 300LL);
        }
        v16 += 8LL;
        --v17;
      }

      while (v17);
      if (v15 && v15 == (_DWORD)v6) {
        *uint64_t v14 = 1;
      }
    }

    uint64_t v18 = 0LL;
    for (uint64_t i = 0LL; i != v6; ++i)
    {
      uint64_t v20 = *(void *)(*((void *)a2 + 1) + 8 * i);
      if (IsCompressed && *(_BYTE *)(v20 + 113))
      {
        if (*v14) {
          char v21 = 2;
        }
        else {
          char v21 = 1;
        }
      }

      else
      {
        char v21 = 0;
      }

      if ((*(_DWORD *)(v20 + 44) - 1) > 1
        || !BOMCopierSourceEntryIsRoot(a1) && BOMCopierSourceEntryGetType(a1) != 13)
      {
        uint64_t Entry = BOMCopierDestinationCreateEntry(v20, a1, v21, a3);
        if (!Entry)
        {
          uint64_t v25 = 1LL;
          BOMCopierErrorCapture( a3,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  2715,  (uint64_t)"BOMCopierCopySourceEntryToDestinationSet",  "Could not create destination entry");
          int v46 = v125;
          goto LABEL_208;
        }

        int v23 = *(_DWORD *)(Entry + 32);
        uint64_t v24 = *v126 + v18;
        *(void *)uint64_t v24 = v20;
        *(void *)(v24 + 8) = Entry;
        *(_DWORD *)(v24 + 16) = v23;
      }

      v18 += 32LL;
    }

    uint64_t v8 = v125;
  }

  else
  {
    *((void *)v8 + 7) = v9;
    int v126 = v8 + 14;
    BOMCopierSourceEntryIsCompressed(a1);
    *((_BYTE *)v8 + 64) = 0;
    uint64_t v14 = v8 + 16;
  }

  int v33 = (os_log_s *)*((void *)v8 + 5);
  if (BOMCopierSourceEntryGetType(a1) != 8)
  {
LABEL_81:
    uint64_t v54 = BOMCopierSourceEntrySkip(a1, *((void **)v8 + 1), *((void *)v8 + 2), a3);
    if ((_DWORD)v54)
    {
      uint64_t v25 = v54;
      BOMCopierErrorCapture( a3,  v54,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  7334,  (uint64_t)"copy_entry_to_destinations",  "Could not skip remaning source entry data\n",  v115);
      goto LABEL_207;
    }

    unint64_t v55 = *v8;
    if (!(_DWORD)v55)
    {
LABEL_89:
      uint64_t v25 = 0LL;
      goto LABEL_207;
    }

    uint64_t v56 = 0LL;
    unint64_t v57 = 0LL;
    uint64_t v58 = *v126;
    while (1)
    {
      uint64_t v59 = *(void *)(v58 + v56 + 8);
      if (v59)
      {
        int v60 = *(void **)(v58 + v56);
        snprintf(*((char **)v8 + 6), 0x400uLL, "%s", *(const char **)(v59 + 120));
        uint64_t v61 = BOMCopierDestinationFinalizeEntry(v60, (void *)v59, a3);
        if ((_DWORD)v61)
        {
          uint64_t v25 = v61;
          BOMCopierErrorCapture( a3,  v61,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  7354,  (uint64_t)"copy_entry_to_destinations",  "Could not finalize destination entry\n",  v116);
          goto LABEL_207;
        }

        uint64_t v58 = *((void *)v8 + 7);
        *(void *)(v58 + v56 + 8) = 0LL;
        unint64_t v55 = *v8;
      }

      ++v57;
      v56 += 32LL;
      if (v57 >= v55) {
        goto LABEL_89;
      }
    }
  }

  uint64_t Size = BOMCopierSourceEntryGetSize(a1);
  BOOL v35 = BOMCopierSourceEntryIsCompressed(a1);
  uint64_t v36 = 0LL;
  uint64_t v37 = Size;
  if (Size < 1) {
    goto LABEL_63;
  }
  uint64_t v38 = a1;
  if (v35)
  {
    if (*v14)
    {
      ExtendedAttributeCFIndex Count = BOMCopierSourceEntryGetExtendedAttributeCount(a1, a3);
      if (ExtendedAttributeCount)
      {
        int v40 = ExtendedAttributeCount;
        char v41 = 0;
        for (unsigned int j = 0; j != v40; ++j)
        {
          ExtendedAttributeName = (const char *)BOMCopierSourceEntryGetExtendedAttributeName(a1, j, a3);
          if (!ExtendedAttributeName)
          {
            uint64_t v25 = 1LL;
            BOMCopierErrorCapture( a3,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  7184,  (uint64_t)"copy_entry_to_destinations",  "Could not retrieve extended attribute name for index %u",  j);
            uint64_t v8 = v125;
            goto LABEL_207;
          }

          __int128 v44 = ExtendedAttributeName;
          if (!strcmp(ExtendedAttributeName, "com.apple.ResourceFork"))
          {
            Actualuint64_t Path = (const char *)BOMCopierSourceEntryGetActualPath(a1);
            uint64_t v8 = v125;
            if (!ActualPath)
            {
              uint64_t v25 = 1LL;
              BOMCopierErrorCapture( a3,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  7206,  (uint64_t)"copy_entry_to_destinations",  "Could not retrieve actual path for source entry");
              goto LABEL_207;
            }

            v111 = BOMCopierSourceEntryNewFromResourceFork(ActualPath, a3);
            if (!v111)
            {
              uint64_t v25 = 1LL;
              BOMCopierErrorCapture( a3,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  7213,  (uint64_t)"copy_entry_to_destinations",  "Could not create resource fork entry for %s");
              goto LABEL_207;
            }

            uint64_t v36 = v111;
            uint64_t v112 = *v125;
            uint64_t v37 = 1LL;
            if ((_DWORD)v112)
            {
              uint64_t v113 = *v126 + 8LL;
              do
              {
                if (*(void *)v113) {
                  *(_BYTE *)(*(void *)v113 + 155LL) = 1;
                }
                v113 += 32LL;
                --v112;
              }

              while (v112);
            }

            uint64_t v38 = (uint64_t)v111;
            goto LABEL_64;
          }

          v41 |= strcmp(v44, "com.apple.decmpfs") == 0;
        }

        BOMCopierSourceEntrySetSize(a1, 0LL);
        uint64_t v8 = v125;
        if ((v41 & 1) == 0) {
          goto LABEL_58;
        }
        if (v33 && os_log_type_enabled(v33, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)statfs buf = 0;
          AAFieldKey v45 = "Skipping copying com.apple.decmpfs until finalization";
          goto LABEL_61;
        }
      }

      else
      {
        BOMCopierSourceEntrySetSize(a1, 0LL);
LABEL_58:
        if (v33 && os_log_type_enabled(v33, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)statfs buf = 0;
          AAFieldKey v45 = "Source entry claims to be compressed but there is no com.apple.decmpfs extended attribute. Assuming zero-length file.";
LABEL_61:
          _os_log_impl(&dword_1862F3000, v33, OS_LOG_TYPE_DEFAULT, v45, buf, 2u);
        }
      }

      uint64_t v37 = 0LL;
      uint64_t v36 = 0LL;
    }

    else
    {
      uint64_t v36 = 0LL;
      uint64_t v37 = 1LL;
    }

LABEL_64:
  uint64_t v121 = v37;
  int v122 = v36;
  uint64_t v123 = Size;
  uint64_t v124 = v38;
  int v47 = 0;
  int64_t v48 = (int *)(*v126 + 16LL);
  uint64_t v49 = *v8;
  do
  {
    int v50 = *v48;
    v48 += 8;
    if (v50 == 1) {
      ++v47;
    }
    --v49;
  }

  while (v49);
  if (v47 == *v8)
  {
LABEL_71:
    uint64_t v51 = BOMCopierSourceEntryGetSize(v38);
    BOOL IsStreamed = BOMCopierSourceEntryIsStreamed(v38);
    if (v51) {
      BOOL v53 = 0;
    }
    else {
      BOOL v53 = IsStreamed;
    }
    if (!v51 && !IsStreamed) {
      goto LABEL_76;
    }
    uint64_t v62 = 0LL;
    uint64_t v119 = v51;
    while (1)
    {
      unint64_t v63 = v51 - v62;
      while (1)
      {
        uint64_t v64 = v63 >= *((void *)v8 + 2) ? *((void *)v8 + 2) : v63;
        size_t v65 = v53 ? *((void *)v8 + 2) : v64;
        size_t v66 = BOMCopierSourceEntryRead(v38, *((char **)v8 + 1), v65, a3);
        size_t v67 = v66;
        if (v53) {
          break;
        }
        if ((v66 & 0x8000000000000000LL) != 0)
        {
          BOMCopierErrorCapture( a3,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  7469,  (uint64_t)"copy_file_entry_to_destinations",  "Could not read %lu bytes from source");
LABEL_124:
          uint64_t v25 = 1LL;
          BOMCopierErrorCapture( a3,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  7292,  (uint64_t)"copy_entry_to_destinations",  "Could not copy file entry to destination entry list",  v117);
          goto LABEL_207;
        }

        if (v66) {
          goto LABEL_104;
        }
      }

      if ((v66 & 0x8000000000000000LL) != 0)
      {
        BOMCopierErrorCapture( a3,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  7458,  (uint64_t)"copy_file_entry_to_destinations",  "Could not read %lu bytes from non-deterministic source");
        goto LABEL_124;
      }

      if (!v66) {
        break;
      }
LABEL_104:
      if (*v8)
      {
        uint64_t v68 = 0LL;
        unint64_t v69 = 0LL;
        do
        {
          uint64_t v70 = *(void *)(*v126 + v68 + 8);
          if (v70)
          {
            snprintf(*((char **)v125 + 6), 0x400uLL, "%s", *(const char **)(v70 + 120));
            if (!*(_BYTE *)(v70 + 16) && !*(_BYTE *)(v70 + 154))
            {
              size_t v71 = (os_log_s *)*((void *)v125 + 5);
              if (v71 && os_log_type_enabled(*((os_log_t *)v125 + 5), OS_LOG_TYPE_DEFAULT))
              {
                uint64_t v72 = *(void *)(v70 + 120);
                *(_DWORD *)statfs buf = 134218242;
                *(void *)&uint8_t buf[4] = v67;
                *(_WORD *)&_BYTE buf[12] = 2080;
                *(void *)&buf[14] = v72;
                _os_log_impl(&dword_1862F3000, v71, OS_LOG_TYPE_DEFAULT, "Copying %lu bytes to %s", buf, 0x16u);
              }

              if (BOMCopierDestinationEntryWrite(v70, *((char **)v125 + 1), v67, a3) != v67)
              {
                BOMCopierErrorCapture( a3,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  7499,  (uint64_t)"copy_file_entry_to_destinations",  "Could not write %ld bytes to destination",  v67);
                uint64_t v8 = v125;
                goto LABEL_124;
              }

              uint64_t v73 = *(void *)(*v126 + v68);
              int v74 = *(void (**)(uint64_t, uint64_t, uint64_t, void))(v73 + 248);
              if (v74) {
                v74(v73, v124, v70, *(void *)(v73 + 256));
              }
            }
          }

          ++v69;
          uint64_t v8 = v125;
          v68 += 32LL;
        }

        while (v69 < *v125);
      }

      v62 += v67;
      uint64_t v51 = v119;
      char v75 = v62 != v119 || v53;
      uint64_t v38 = v124;
      if ((v75 & 1) == 0)
      {
        int v76 = (os_log_s *)*((void *)v8 + 5);
        if (v76 && os_log_type_enabled(*((os_log_t *)v8 + 5), OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)statfs buf = 134217984;
          *(void *)&uint8_t buf[4] = v119;
          unsigned int v77 = "Read %llu total bytes from the source.";
          int v78 = v76;
          uint32_t v79 = 12;
          goto LABEL_200;
        }

        goto LABEL_76;
      }
    }

    int v114 = (os_log_s *)*((void *)v8 + 5);
    if (v114 && os_log_type_enabled(*((os_log_t *)v8 + 5), OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)statfs buf = 0;
      unsigned int v77 = "Read 0 bytes from non-deterministic source.";
      int v78 = v114;
      uint32_t v79 = 2;
LABEL_200:
      _os_log_impl(&dword_1862F3000, v78, OS_LOG_TYPE_DEFAULT, v77, buf, v79);
    }

  __error();
  return _checkCopyFileError(a1);
}

          BOMFileClose((uint64_t)v30);
          uint64_t v16 = 0LL;
          if (a4) {
            *a4 = 0;
          }
          return v16;
        }
      }

            size_t v17 = v78;
            if (v35 || (v85 & 0xFFFFFFFD) != 0) {
              continue;
            }
            int v47 = v72;
            if (!v72)
            {
              int64_t v48 = (char *)BOM_malloc(0x40uLL);
              int v47 = 4LL;
              goto LABEL_70;
            }

            if (v72 == v15)
            {
              int64_t v48 = (char *)BOM_realloc(__source, 32 * v72);
              int v47 = 2 * v72;
LABEL_70:
              uint64_t v18 = (char *)v82;
              goto LABEL_72;
            }

            uint64_t v18 = (char *)v82;
            int64_t v48 = __source;
LABEL_72:
            if (!v48)
            {
              BOMCopierNotifyFatalError( a1,  "Could not allocate space for Apple Double files.",  v29,  v30,  v31,  v32,  v33,  v34,  v70);
              goto LABEL_106;
            }

            uint64_t v72 = v47;
            uint64_t v49 = (const char *)(a1 + 3328);
            if (*(_BYTE *)(a1 + 11616)) {
              uint64_t v49 = (const char *)(a1 + 10592);
            }
            __sourcea = (char *)v49;
            int v50 = v48;
            size_t v71 = strlen(v49);
            uint64_t v51 = (char *)malloc(v71 + 1);
            size_t v17 = v78;
            strlcpy(v51, __sourcea, v71 + 1);
            __source = v50;
            int v52 = (char **)&v50[16 * v15];
            *int v52 = v51;
            v52[1] = (char *)v71;
            ++v15;
            break;
          default:
            goto LABEL_64;
        }
      }
    }
  }

  if (v19 == 3)
  {
    size_t v66 = "bad file format";
LABEL_109:
    BOMCopierNotifyFatalError(a1, "cpio read error: %s", v20, v21, v22, v23, v24, v25, (char)v66);
LABEL_110:
    if (__source)
    {
      if (v15)
      {
        uint64_t v68 = (void **)__source;
        do
        {
          free(*v68);
          const void *v68 = 0LL;
          v68 += 2;
          --v15;
        }

        while (v15);
      }

      free(__source);
    }

    uint64_t v14 = 2LL;
    uint64_t v18 = (char *)v82;
    goto LABEL_116;
  }

  if (v19 != 4)
  {
    size_t v67 = __error();
    LOBYTE(v66) = strerror(*v67);
    goto LABEL_109;
  }

  BOOL v53 = __source;
  if (v17 >= 2)
  {
    v82[(v17 - 1)] = 0;
    uint64_t v54 = *(void (**)(uint64_t, const char *, uint64_t, void, void))(a1 + 96);
    if (v54) {
LABEL_84:
    }
      v54(a1, v82, 2LL, 0LL, 0LL);
  }

LABEL_76:
    if (v122) {
      BOMCopierSourceEntryFree(v122);
    }
    if (v123 >= 1 && !v121) {
      BOMCopierSourceEntrySetSize(a1, v123);
    }
    goto LABEL_81;
  }

  uint64_t v80 = 0LL;
  unint64_t v81 = 0LL;
  do
  {
    uint64_t v82 = *v126 + v80;
    uint64_t v83 = *(void *)(v82 + 8);
    if (v83)
    {
      int v84 = *(_DWORD *)(v82 + 16);
      snprintf(*((char **)v8 + 6), 0x400uLL, "%s", *(const char **)(v83 + 120));
      if (v84 == 4 || v84 == 1 && BOMCopierSourceEntryGetBinaryType(v124) - 3 <= 1)
      {
        *(void *)statfs buf = 0LL;
        if (!*(_BYTE *)(v83 + 16) && !*(_BYTE *)(v83 + 154))
        {
          if (BOMCopierDestinationEntryWriteFatHeader(v83, (size_t *)buf, a3))
          {
            BOMCopierErrorCapture( a3,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  7580,  (uint64_t)"copy_binary_entry_to_destinations",  "Could not write fat header\n",  v115);
            goto LABEL_206;
          }

          *(void *)(*v126 + v80 + 24) += *(void *)buf;
        }
      }
    }

    ++v81;
    v80 += 32LL;
  }

  while (v81 < *v8);
  uint64_t v85 = v124;
  ArchCFIndex Count = BOMCopierSourceEntryGetArchCount(v124);
  if (!ArchCount) {
    goto LABEL_76;
  }
  uint64_t v87 = 0LL;
  unsigned int v88 = 0;
  int v118 = ArchCount;
  while (1)
  {
    if (BOMCopierSourceEntryGetArchRecord(v85, v88, &v127, a3))
    {
      BOMCopierErrorCapture( a3,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  7608,  (uint64_t)"copy_binary_entry_to_destinations",  "Could not get arch record at index %d\n");
      goto LABEL_206;
    }

    unsigned int v120 = v88;
    unint64_t v89 = *((void *)&v127 + 1) - v87;
    if (*((void *)&v127 + 1) != v87)
    {
      uint64_t v87 = *((void *)&v127 + 1);
      if (BOMCopierSourceEntrySeek(v85, v89, *((void **)v8 + 1), *((void *)v8 + 2), a3))
      {
        BOMCopierErrorCapture( a3,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  7624,  (uint64_t)"copy_binary_entry_to_destinations",  "Could not seek to beginning of matching slice\n");
        goto LABEL_206;
      }
    }

    uint64_t v90 = v87;
    unint64_t v91 = *v8;
    if ((_DWORD)v91)
    {
      uint64_t v92 = 0LL;
      for (unint64_t k = 0LL; k < v91; ++k)
      {
        uint64_t v94 = *(void *)(*v126 + v92 + 8);
        if (v94)
        {
          snprintf(*((char **)v8 + 6), 0x400uLL, "%s", *(const char **)(v94 + 120));
          uint64_t v130 = 0LL;
          memset(buf, 0, sizeof(buf));
          if (!*(_BYTE *)(v94 + 16))
          {
            if (BOMCopierDestinationEntryGetMatchRecord(v94, v88, (uint64_t)buf, a3))
            {
              BOMCopierErrorCapture( a3,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  7659,  (uint64_t)"copy_binary_entry_to_destinations",  "Could not get match record at index %d\n");
              goto LABEL_206;
            }

            if (buf[0])
            {
              if (*(void *)&buf[16] == -1LL)
              {
                BOMCopierErrorCapture( a3,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  7673,  (uint64_t)"copy_binary_entry_to_destinations",  "dude offset is wack",  v115);
                goto LABEL_206;
              }

              uint64_t v95 = *(void *)(*v126 + v92 + 24);
              uint64_t v96 = *(void *)&buf[16] - v95;
              if (*(void *)&buf[16] != v95)
              {
                if (BOMCopierDestinationEntrySeek( (int *)v94,  *((void **)v8 + 3),  *((void *)v8 + 4),  *(void *)&buf[16] - v95,  a3))
                {
                  BOMCopierErrorCapture( a3,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  7685,  (uint64_t)"copy_binary_entry_to_destinations",  "Could not seek %ld bytes to beginning of new slice");
                  goto LABEL_206;
                }

                *(void *)(*v126 + v92 + 24) += v96;
              }
            }
          }

          unint64_t v91 = *v8;
        }

        v92 += 32LL;
      }
    }

    uint64_t v97 = v128;
    if (v128) {
      break;
    }
    uint64_t v85 = v124;
    uint64_t v87 = v90;
LABEL_176:
    if (++v88 == v118) {
      goto LABEL_76;
    }
  }

  uint64_t v98 = 0LL;
  uint64_t v85 = v124;
  uint64_t v87 = v90;
  while (1)
  {
    size_t v99 = v97 - v98;
    int v100 = (char *)*((void *)v8 + 1);
    uint64_t v101 = v8;
    if (v99 >= *((void *)v8 + 2)) {
      size_t v102 = *((void *)v8 + 2);
    }
    else {
      size_t v102 = v99;
    }
    if (BOMCopierSourceEntryRead(v85, v100, v102, a3) != v102)
    {
      BOMCopierErrorCapture( a3,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  7711,  (uint64_t)"copy_binary_entry_to_destinations",  "Could not read %ld bytes from source",  v102);
      uint64_t v8 = v101;
      goto LABEL_206;
    }

    unint64_t v103 = *v101;
    unsigned int v88 = v120;
    if ((_DWORD)v103) {
      break;
    }
LABEL_173:
    v87 += v102;
    v98 += v102;
    uint64_t v97 = v128;
    uint64_t v85 = v124;
    uint64_t v8 = v125;
    if (v98 == v128) {
      goto LABEL_176;
    }
  }

  uint64_t v104 = 0LL;
  unint64_t v105 = 0LL;
  while (1)
  {
    uint64_t v106 = *(void *)(*v126 + v104 + 8);
    if (v106) {
      break;
    }
LABEL_164:
    ++v105;
    v104 += 32LL;
    if (v105 >= v103) {
      goto LABEL_173;
    }
  }

  snprintf(*((char **)v125 + 6), 0x400uLL, "%s", *(const char **)(v106 + 120));
  uint64_t v130 = 0LL;
  memset(buf, 0, sizeof(buf));
  if (*(_BYTE *)(v106 + 16)) {
    goto LABEL_163;
  }
  if (BOMCopierDestinationEntryGetMatchRecord(v106, v120, (uint64_t)buf, a3))
  {
    BOMCopierErrorCapture( a3,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  7741,  (uint64_t)"copy_binary_entry_to_destinations",  "Could not get match record at index %d\n");
    goto LABEL_189;
  }

  if (!buf[0] || *(_BYTE *)(v106 + 16) || *(_BYTE *)(v106 + 154))
  {
LABEL_163:
    unint64_t v103 = *v125;
    goto LABEL_164;
  }

  if (BOMCopierDestinationEntryWrite(v106, *((char **)v125 + 1), v102, a3) == v102)
  {
    __uint32_t v107 = (void *)(*v126 + v104);
    v107[3] += v102;
    uint64_t v108 = *v107;
    uint64_t v109 = *(void (**)(uint64_t, uint64_t, uint64_t, void))(*v107 + 248LL);
    if (v109) {
      v109(v108, v124, v106, *(void *)(v108 + 256));
    }
    goto LABEL_163;
  }

  BOMCopierErrorCapture( a3,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  7755,  (uint64_t)"copy_binary_entry_to_destinations",  "Could not write %ld bytes to destination: %s\n");
LABEL_189:
  uint64_t v8 = v125;
LABEL_206:
  uint64_t v25 = 1LL;
  BOMCopierErrorCapture( a3,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  7300,  (uint64_t)"copy_entry_to_destinations",  "Could not copy file entry to destination entry list");
LABEL_207:
  int v46 = v8;
LABEL_208:
  release_copy_state(v46);
  return v25;
}

    if (*v25 && BOMPKZipReadNextSignature(*(void *)(a1 + 12752), (int *)(a1 + 12772)))
    {
      BOMCopierNotifyFatalError(a1, "Couldn't read pkzip signature.", v63, v64, v65, v66, v67, v68, v84);
      goto LABEL_115;
    }

void release_copy_state(void *a1)
{
  unint64_t v2 = (char *)a1[7];
  if (v2)
  {
    unint64_t v3 = *(unsigned int *)a1;
    if ((_DWORD)v3)
    {
      unint64_t v4 = 0LL;
      uint64_t v5 = 8LL;
      do
      {
        if (*(void *)&v2[v5])
        {
          BOMCopierDestinationEntryFree(*(void **)&v2[v5]);
          unint64_t v2 = (char *)a1[7];
          *(void *)&v2[v5] = 0LL;
          unint64_t v3 = *(unsigned int *)a1;
        }

        ++v4;
        v5 += 32LL;
      }

      while (v4 < v3);
    }

    free(v2);
  }

  a1[8] = 0LL;
  *((_OWORD *)a1 + 2) = 0u;
  *((_OWORD *)a1 + 3) = 0u;
  *(_OWORD *)a1 = 0u;
  *((_OWORD *)a1 + 1) = 0u;
  free(a1);
}

const char *string_for_entry_type(unsigned int a1)
{
  if (a1 > 0x13) {
    return "?";
  }
  else {
    return off_189E3F700[a1];
  }
}

const char *string_for_mode(__int16 a1)
{
  unsigned int v1 = (a1 & 0xF000) - 4096;
  if (v1 >> 13 > 6) {
    return "?";
  }
  else {
    return off_189E3F7A0[v1 >> 12];
  }
}

uint64_t populate_aa_header_acl(uint64_t a1, uint64_t a2, AAHeader_impl *a3, void *a4)
{
  path_p = 0LL;
  pid_t v8 = getpid();
  asprintf(&path_p, "/tmp/.BCDE.%u.T_XXXXXX", v8);
  if (path_p)
  {
    int v9 = mkstemp(path_p);
    if (v9 == -1)
    {
      uint64_t v20 = __error();
      strerror(*v20);
      uint64_t v19 = 1LL;
      BOMCopierErrorCapture( a4,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  4871,  (uint64_t)"populate_aa_header_acl",  "Could not mkstemp %s: %s\n");
    }

    else
    {
      close(v9);
      uint64_t v36 = 0LL;
      ACL = (const char *)BOMCopierSourceEntryGetACL(a1, &v36, a4);
      if (ACL)
      {
        int v11 = acl_from_text(ACL);
        if (!v11)
        {
          int v21 = *__error();
          int v22 = __error();
          int v23 = strerror(*v22);
          BOMCopierErrorCapture( a4,  v21,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  4890,  (uint64_t)"populate_aa_header_acl",  "Could not convert ACL text: %s",  v23);
          goto LABEL_12;
        }

        uint64_t v12 = v11;
        if (acl_set_file(path_p, ACL_TYPE_EXTENDED, v11))
        {
          int v13 = *__error();
          uint64_t v14 = path_p;
          int v15 = __error();
          uint64_t v16 = strerror(*v15);
          BOMCopierErrorCapture( a4,  v13,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  4898,  (uint64_t)"populate_aa_header_acl",  "Could not set ACL on %s: %s",  v14,  v16);
          acl_free(v12);
LABEL_12:
          uint64_t v24 = path_p;
          goto LABEL_13;
        }

        acl_free(v12);
        int v26 = AAEntryACLBlobCreateWithPath(path_p, "", 0LL);
        if (v26)
        {
          unlink(path_p);
          free(path_p);
          Encodeduint64_t Size = AAEntryACLBlobGetEncodedSize(v26);
          EncodedCFDataRef Data = AAEntryACLBlobGetEncodedData(v26);
          int v29 = (char *)malloc(EncodedSize);
          if (!v29)
          {
            int v33 = *__error();
            uint64_t v34 = __error();
            BOOL v35 = strerror(*v34);
            BOMCopierErrorCapture( a4,  v33,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  4927,  (uint64_t)"populate_aa_header_acl",  "Could not allocate encoded buffer: %s",  v35);
            AAEntryACLBlobDestroy(v26);
            return 1LL;
          }

          int v30 = v29;
          memcpy(v29, EncodedData, EncodedSize);
          AAEntryACLBlobDestroy(v26);
          v31.ikey = 4997953;
          int v32 = AAHeaderSetFieldBlob(a3, 0xFFFFFFFF, v31, EncodedSize);
          if (!v32)
          {
            uint64_t v19 = 0LL;
            *(void *)(a2 + 344) = v30;
            *(void *)(a2 + 352) = EncodedSize;
            return v19;
          }

          BOMCopierErrorCapture( a4,  v32,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  4943,  (uint64_t)"populate_aa_header_acl",  "Could not append AA_FIELD_ACL to AppleArchive header: %d",  v32);
          uint64_t v24 = v30;
LABEL_13:
          free(v24);
          return 1LL;
        }

        uint64_t v19 = 1LL;
        BOMCopierErrorCapture( a4,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  4909,  (uint64_t)"populate_aa_header_acl",  "Could create AppleArchive ACL blob from %s: %s");
      }

      else
      {
        uint64_t v19 = 1LL;
        BOMCopierErrorCapture( a4,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  4882,  (uint64_t)"populate_aa_header_acl",  "Could not get ACL from source entry");
      }
    }

    free(path_p);
  }

  else
  {
    size_t v17 = __error();
    uint64_t v18 = strerror(*v17);
    uint64_t v19 = 1LL;
    BOMCopierErrorCapture( a4,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  4864,  (uint64_t)"populate_aa_header_acl",  "Could not create ACL file path: %s\n",  v18);
  }

  return v19;
}

uint64_t populate_aa_header_xattr(uint64_t a1, uint64_t a2, AAHeader_impl *a3, void *a4)
{
  AAEntryXATBlob v8 = AAEntryXATBlobCreate();
  if (!v8)
  {
    uint64_t v26 = 1LL;
    BOMCopierErrorCapture( a4,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  4750,  (uint64_t)"populate_aa_header_xattr",  "Could not create AppleArchive XAT blob");
    return v26;
  }

  int v9 = v8;
  ExtendedAttributeCFIndex Count = BOMCopierSourceEntryGetExtendedAttributeCount(a1, a4);
  if (ExtendedAttributeCount)
  {
    int v11 = ExtendedAttributeCount;
    uint64_t v32 = a2;
    size_t v12 = 0LL;
    int v13 = 0LL;
    for (unsigned int i = 0; i != v11; ++i)
    {
      uint64_t ExtendedAttributeName = BOMCopierSourceEntryGetExtendedAttributeName(a1, i, a4);
      if (!ExtendedAttributeName)
      {
        uint64_t v26 = 1LL;
        BOMCopierErrorCapture( a4,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  4764,  (uint64_t)"populate_aa_header_xattr",  "Could not get name for xattr %u");
        return v26;
      }

      uint64_t v16 = (const char *)ExtendedAttributeName;
      ExtendedAttributeuint64_t Size = BOMCopierSourceEntryGetExtendedAttributeSize(a1, i, a4);
      if (!ExtendedAttributeSize)
      {
        uint64_t v26 = 1LL;
        BOMCopierErrorCapture( a4,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  4771,  (uint64_t)"populate_aa_header_xattr",  "Could not get size for xattr %u");
        return v26;
      }

      size_t v18 = ExtendedAttributeSize;
      if (v12 < ExtendedAttributeSize)
      {
        int v13 = realloc(v13, ExtendedAttributeSize);
        size_t v12 = v18;
        if (!v13)
        {
          int v29 = *__error();
          int v30 = __error();
          strerror(*v30);
          BOMCopierErrorCapture( a4,  v29,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  4781,  (uint64_t)"populate_aa_header_xattr",  "Could not allocate buffer %u: %s");
          return 1LL;
        }
      }

      if (BOMCopierSourceEntryCopyExtendedAttribute(a1, i, v13, v18, 0, a4) != v18)
      {
        uint64_t v26 = 1LL;
        BOMCopierErrorCapture( a4,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  4789,  (uint64_t)"populate_aa_header_xattr",  "Could not copy xattr %u");
        return v26;
      }

      int appended = AAEntryXATBlobAppendEntry(v9, v16, (const uint8_t *)v13, v18);
      if (appended)
      {
        BOMCopierErrorCapture( a4,  appended,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  4796,  (uint64_t)"populate_aa_header_xattr",  "Could not append %u entry to AppleArchive XAT blob: %d");
        return 1LL;
      }
    }

    a2 = v32;
    if (v13) {
      free(v13);
    }
  }

  Encodeduint64_t Size = AAEntryXATBlobGetEncodedSize(v9);
  EncodedCFDataRef Data = AAEntryXATBlobGetEncodedData(v9);
  int v22 = malloc(EncodedSize);
  if (!v22)
  {
    int v27 = *__error();
    int8x8_t v28 = __error();
    strerror(*v28);
    BOMCopierErrorCapture( a4,  v27,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  4816,  (uint64_t)"populate_aa_header_xattr",  "Could not allocate encoded buffer: %s");
    return 1LL;
  }

  int v23 = v22;
  memcpy(v22, EncodedData, EncodedSize);
  AAEntryXATBlobDestroy(v9);
  v24.ikey = 5521752;
  int v25 = AAHeaderSetFieldBlob(a3, 0xFFFFFFFF, v24, EncodedSize);
  if (v25)
  {
    BOMCopierErrorCapture( a4,  v25,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  4831,  (uint64_t)"populate_aa_header_xattr",  "Could not append AA_FIELD_XAT to AppleArchive header: %d",  v25);
    free(v23);
    return 1LL;
  }

  uint64_t v26 = 0LL;
  *(void *)(a2 + 360) = v23;
  *(void *)(a2 + 368) = EncodedSize;
  return v26;
}

uint64_t apply_retention_policy(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v47 = *MEMORY[0x1895F89C0];
  uint64_t v6 = *(void *)(a2 + 8);
  if (BOMCopierSourceEntryGetType(v6) == 8)
  {
    if (*(_BYTE *)(a1 + 307))
    {
      Binaryunsigned int Type = BOMCopierSourceEntryGetBinaryType(v6);
      BOOL v8 = BinaryType != 0;
      if (!*(void *)(a1 + 336))
      {
        if (!BinaryType) {
          goto LABEL_40;
        }
        goto LABEL_11;
      }
    }

    else
    {
      if (!*(void *)(a1 + 336)) {
        goto LABEL_40;
      }
      BOOL v8 = 0;
    }

    uint64_t Path = (const char *)BOMCopierSourceEntryGetPath(v6);
    int v10 = regexec(*(const regex_t **)(a1 + 336), Path, 0LL, 0LL, 0);
    if (v10)
    {
      if (v10 != 1)
      {
        int v13 = *__error();
        uint64_t v14 = __error();
        strerror(*v14);
        BOMCopierErrorCapture( a3,  v13,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  6427,  (uint64_t)"apply_retention_policy",  "Could not regexec %s: %s\n");
        return 1LL;
      }

      if (!v8) {
        goto LABEL_40;
      }
    }

uint64_t set_timestamps(uint64_t a1, uint64_t a2, os_log_s *a3, void *a4)
{
  uint64_t v34 = *MEMORY[0x1895F89C0];
  __int128 v23 = 0uLL;
  if (BOMCopierSourceEntryGetModificationTime(a1, &v23))
  {
    uint64_t v8 = 1LL;
    BOMCopierErrorCapture( a4,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  6638,  (uint64_t)"set_timestamps",  "Could not retrieve the entry modification time");
  }

  else
  {
    __int128 v22 = 0uLL;
    if (BOMCopierSourceEntryGetAccessTime(a1, &v22))
    {
      uint64_t v8 = 1LL;
      BOMCopierErrorCapture( a4,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  6647,  (uint64_t)"set_timestamps",  "Could not retrieve the entry access time");
    }

    else
    {
      uint64_t v21 = 0LL;
      __int128 v20 = xmmword_18635ACA8;
      uint64_t v11 = *((void *)&v23 + 1);
      uint64_t v10 = v23;
      __int128 v17 = v23;
      if (v22 != 0)
      {
        uint64_t v11 = *((void *)&v22 + 1);
        uint64_t v10 = v22;
      }

      uint64_t v18 = v10;
      uint64_t v19 = v11;
      if (!setattrlist(*(const char **)(a2 + 120), &v20, &v17, 0x20uLL, 1u))
      {
        if (a3)
        {
          uint64_t v8 = 0LL;
          if (!os_log_type_enabled(a3, OS_LOG_TYPE_DEFAULT)) {
            return v8;
          }
          uint64_t v16 = *(void *)(a2 + 120);
          *(_DWORD *)statfs buf = 134219010;
          uint64_t v25 = v17;
          __int16 v26 = 2048;
          uint64_t v27 = *((void *)&v17 + 1);
          __int16 v28 = 2048;
          uint64_t v29 = v18;
          __int16 v30 = 2048;
          uint64_t v31 = v19;
          __int16 v32 = 2080;
          uint64_t v33 = v16;
          _os_log_impl( &dword_1862F3000,  a3,  OS_LOG_TYPE_DEFAULT,  "Set mtime [%ld.%ld] and atime [%ld.%ld] on %s",  buf,  0x34u);
        }

        return 0LL;
      }

      int v12 = *__error();
      int v13 = *(const char **)(a2 + 120);
      uint64_t v14 = __error();
      int v15 = strerror(*v14);
      BOMCopierErrorCapture( a4,  v12,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c",  6677,  (uint64_t)"set_timestamps",  "Could not setattrlist timestamps for %s: %s",  v13,  v15);
      return 1LL;
    }
  }

  return v8;
}

uint64_t change_flags(const char *a1, int a2, __uint32_t a3)
{
  v6[0] = a2;
  v6[1] = a3;
  v6[2] = -1;
  uint64_t result = fsctl(a1, 0xC00C4114uLL, v6, 0);
  if ((_DWORD)result)
  {
    if (*__error() == 25 || *__error() == 45)
    {
      uint64_t result = chflags(a1, a3);
      if ((_DWORD)result) {
        return *__error() != 45;
      }
    }

    else
    {
      return 1LL;
    }
  }

  return result;
}

void *data_read_stream_new(uint64_t a1, uint64_t a2)
{
  if (a2) {
    return 0LL;
  }
  uint64_t result = platform_calloc(a1, 1uLL, 0x68uLL);
  if (result)
  {
    *(_DWORD *)uint64_t result = 1919246692;
    result[1] = a1;
    *((_DWORD *)result + 25) = 1684104557;
  }

  return result;
}

void data_read_stream_free(void *__b)
{
  if (__b && *(_DWORD *)__b == 1919246692 && *((_DWORD *)__b + 25) == 1684104557)
  {
    unint64_t v2 = (bz_stream *)*((void *)__b + 11);
    if (v2)
    {
      BZ2_bzDecompressEnd(v2);
      platform_free(*((void *)__b + 1), *((void **)__b + 11));
    }

    unint64_t v3 = (z_stream *)*((void *)__b + 10);
    if (v3)
    {
      inflateEnd(v3);
      platform_free(*((void *)__b + 1), *((void **)__b + 10));
    }

    unint64_t v4 = (void *)*((void *)__b + 8);
    if (v4) {
      platform_free(*((void *)__b + 1), v4);
    }
    uint64_t v5 = (void *)*((void *)__b + 4);
    if (v5) {
      platform_free(*((void *)__b + 1), v5);
    }
    uint64_t v6 = *((void *)__b + 1);
    platform_memset(v6, __b, 0LL, 0x68uLL);
    platform_free(v6, __b);
  }

uint64_t data_read_stream_set_source(uint64_t a1, uint64_t a2)
{
  if (!a1) {
    return 0xFFFFFFFFLL;
  }
  if (*(_DWORD *)a1 != 1919246692) {
    return 0xFFFFFFFFLL;
  }
  uint64_t result = 0xFFFFFFFFLL;
  if (a2 && *(_DWORD *)(a1 + 100) == 1684104557)
  {
    *(void *)(a1 + 16) = a2;
    unsigned int v4 = getpagesize();
    if (v4 <= 0xE) {
      int v5 = 14;
    }
    else {
      int v5 = v4;
    }
    *(void *)(a1 + 24) = v5;
    uint64_t v6 = platform_valloc(*(void *)(a1 + 8), v5);
    *(void *)(a1 + 32) = v6;
    if (v6)
    {
      size_t v7 = resilient_source_read(*(void *)(a1 + 16), v6, 0xEuLL);
      if (v7 != -1LL)
      {
        *(void *)(a1 + 40) = v7;
        uint64_t v8 = *(unsigned __int8 **)(a1 + 32);
        if (v7 < 0xA)
        {
          if (v7 < 7) {
            goto LABEL_42;
          }
          int v9 = *v8;
LABEL_36:
          if (v9 == 24 && v8[1] == 77 && v8[2] == 34 && v8[3] == 4)
          {
            int v14 = 3;
            goto LABEL_41;
          }

LABEL_42:
          if (*(_DWORD *)(a1 + 72))
          {
            *(void *)(a1 + 56) = 0x20000LL;
            uint64_t v19 = platform_valloc(*(void *)(a1 + 8), 0x20000uLL);
            *(void *)(a1 + 64) = v19;
            if (!v19)
            {
              AAFieldKey v24 = (FILE *)*MEMORY[0x1895F89D0];
              uint64_t v25 = __error();
              __int16 v30 = strerror(*v25);
              __int128 v23 = "Could not allocate read buffer: %s\n";
              goto LABEL_51;
            }

            int v20 = *(_DWORD *)(a1 + 72);
            if (v20 == 2)
            {
              uint64_t v27 = (bz_stream *)platform_calloc(*(void *)(a1 + 8), 1uLL, 0x50uLL);
              *(void *)(a1 + 88) = v27;
              if (v27)
              {
                uint64_t result = BZ2_bzDecompressInit(v27, 0, 0);
                if (!(_DWORD)result) {
                  return result;
                }
                __int128 v22 = (FILE *)*MEMORY[0x1895F89D0];
                __int16 v30 = (char *)result;
                __int128 v23 = "Could not BZ2_bzDecompressInit: %d\n";
                goto LABEL_55;
              }

              AAFieldKey v24 = (FILE *)*MEMORY[0x1895F89D0];
              uint64_t v29 = __error();
              __int16 v30 = strerror(*v29);
              __int128 v23 = "Could not allocate bzip2 stream: %s\n";
LABEL_51:
              __int16 v26 = v24;
LABEL_56:
              fprintf(v26, v23, v30);
              fwrite("Could not initialize decompression\n", 0x23uLL, 1uLL, (FILE *)*MEMORY[0x1895F89D0]);
              return 0xFFFFFFFFLL;
            }

            if (v20 == 1)
            {
              uint64_t v21 = (z_stream *)platform_calloc(*(void *)(a1 + 8), 1uLL, 0x70uLL);
              *(void *)(a1 + 80) = v21;
              if (v21)
              {
                uint64_t result = inflateInit2_(v21, 31, "1.2.12", 112);
                if (!(_DWORD)result) {
                  return result;
                }
                __int128 v22 = (FILE *)*MEMORY[0x1895F89D0];
                __int16 v30 = (char *)result;
                __int128 v23 = "Could not inflateInit2: %d\n";
LABEL_55:
                __int16 v26 = v22;
                goto LABEL_56;
              }

              AAFieldKey v24 = (FILE *)*MEMORY[0x1895F89D0];
              __int16 v28 = __error();
              __int16 v30 = strerror(*v28);
              __int128 v23 = "Could not allocate zlib stream: %s\n";
              goto LABEL_51;
            }
          }

          return 0LL;
        }

        int v9 = *v8;
        if (v9 == 31 && v8[1] == 139 && v8[2] == 8)
        {
          int v14 = 1;
        }

        else
        {
          if (v7 < 0xE || v9 != 66) {
            goto LABEL_36;
          }
          if (*((_DWORD *)v8 + 1) != 643383601 || *((_WORD *)v8 + 4) != 22867)
          {
            int v16 = *((_DWORD *)v8 + 1);
            int v17 = *((unsigned __int16 *)v8 + 4);
            if (v16 != 944075287 || v17 != 36944) {
              goto LABEL_42;
            }
          }

          int v14 = 2;
        }

  AAFieldKey v24 = calloc(1uLL, 0x20uLL);
  if (v24)
  {
    uint64_t v25 = v24;
    if (v15 == -17958194 || v15 == -822415874)
    {
      *(_OWORD *)int64_t v48 = *v8;
      *(_OWORD *)&v48[12] = *(_OWORD *)((char *)v8 + 12);
      if (v15 == -822415874)
      {
        __int16 v26 = BOMHostByteOrder();
        BOMSwapMachHeader((uint64_t)v48, v26);
      }
    }

    else
    {
      __int128 v44 = v8[1];
      *(_OWORD *)int64_t v48 = *v8;
      *(_OWORD *)&v48[16] = v44;
      if (v15 == -805638658)
      {
        AAFieldKey v45 = BOMHostByteOrder();
        BOMSwapMachHeader64((int8x16_t *)v48, v45);
      }
    }

    int *v25 = *(void *)&v48[4];
    v25[1] = 0LL;
    v25[2] = *(void *)(a1 + 96);
    v25[3] = 0LL;
    LODWORD(v23) = 1;
    goto LABEL_77;
  }

  int v41 = *__error();
  int v42 = __error();
  uint64_t v43 = strerror(*v42);
  BOMCopierErrorCapture( a2,  v41,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c",  4149,  (uint64_t)"parse_regular_file",  "Could not allocate BOMCopierArchRecord: %s",  v43);
  free(v8);
  return 1LL;
}

    warnx("Improperly formatted input, too many fields");
  }

  else
  {
LABEL_43:
    warnx("Not enough fields");
  }

  *a4 = v8;
  return v26;
}

LABEL_41:
        *(_DWORD *)(a1 + 72) = v14;
        goto LABEL_42;
      }

      int v12 = (FILE *)*MEMORY[0x1895F89D0];
      int v13 = __error();
      strerror(*v13);
      fprintf(v12, "Could not read minimal data for auto-detection: %s\n");
    }

    else
    {
      uint64_t v10 = (FILE *)*MEMORY[0x1895F89D0];
      uint64_t v11 = __error();
      strerror(*v11);
      fprintf(v10, "Could not allocate discovery buffer: %s\n");
    }

    return 0xFFFFFFFFLL;
  }

  return result;
}

            v20 += strlen(v20) + 1;
            if ((unint64_t)v20 >= v15)
            {
              if (v19)
              {
                uint64_t v25 = 0LL;
                __int16 v26 = v19;
                while (1)
                {
                  uint64_t v27 = getxattr(v6, (const char *)v18[v25], 0LL, 0LL, 0, v8);
                  if (v27 == -1) {
                    break;
                  }
                  v18[v25 + 1] = v27;
                  v25 += 3LL;
                  if (3LL * v19 == v25) {
                    goto LABEL_54;
                  }
                }

                uint64_t v36 = *__error();
                int v37 = __error();
                strerror(*v37);
                BOMCopierErrorCapture( v38,  v36,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c",  4582,  (uint64_t)"capture_extended_attributes",  "Could not getxattr size for %s: %s");
                goto LABEL_57;
              }

              __int16 v26 = 0LL;
LABEL_54:
              qsort(v18, v26, 0x18uLL, (int (__cdecl *)(const void *, const void *))xattr_compare);
              *(_DWORD *)(a1 + 208) = v19;
              *(void *)(a1 + 216) = v18;
              free(v39);
              return 0LL;
            }
          }
        }

        uint64_t v31 = *__error();
        __int16 v32 = __error();
        strerror(*v32);
        BOMCopierErrorCapture( a3,  v31,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c",  4468,  (uint64_t)"capture_extended_attributes",  "Could not allocate extended attribute list: %s");
      }

      else
      {
        __int16 v30 = *__error();
        BOMCopierErrorCapture( a3,  v30,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c",  4434,  (uint64_t)"capture_extended_attributes",  "%ld does not match %ld\n");
      }

      uint64_t v33 = v13;
LABEL_58:
      free(v33);
    }

    else
    {
      __int16 v28 = *__error();
      uint64_t v29 = __error();
      strerror(*v29);
      BOMCopierErrorCapture( a3,  v28,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c",  4427,  (uint64_t)"capture_extended_attributes",  "Could not allocate %ld bytes for name buffer: %s\n");
    }

    return 1LL;
  }

  return result;
}

size_t resilient_source_read(uint64_t a1, void *a2, size_t a3)
{
  do
    size_t v6 = data_source_read(a1, a2, a3);
  while (v6 == -1LL && *__error() == 35);
  return v6;
}

uint64_t data_stream_read(uint64_t a1, char *__dst, size_t a3)
{
  if (!a1 || *(_DWORD *)a1 != 1919246692) {
    return -1LL;
  }
  uint64_t result = -1LL;
  if (__dst && *(_DWORD *)(a1 + 100) == 1684104557)
  {
    if (a3)
    {
      if (*(_DWORD *)(a1 + 72))
      {
        while (1)
        {
          uint64_t result = read_from_source((uint64_t *)a1, *(char **)(a1 + 64), *(void *)(a1 + 56), a3);
          if (result == -1) {
            break;
          }
          uint64_t v7 = result;
          int v8 = *(_DWORD *)(a1 + 72);
          if (v8 == 2)
          {
            int v12 = *(bz_stream **)(a1 + 88);
            v12->next_in = *(char **)(a1 + 64);
            v12->avail_in = v7;
            v12->next_uuid_t out = __dst;
            v12->uInt avail_out = a3;
            int v13 = BZ2_bzDecompress(v12);
            if (v13)
            {
              if (v13 != 4)
              {
                fprintf((FILE *)*MEMORY[0x1895F89D0], "Could not BZ2_bzDecompress: %d\n");
                return -1LL;
              }

              *(_BYTE *)(a1 + 96) = 1;
            }

            uint64_t v11 = *(void *)(a1 + 88);
          }

          else
          {
            if (v8 != 1) {
              return -1LL;
            }
            int v9 = *(z_stream **)(a1 + 80);
            v9->next_in = *(Bytef **)(a1 + 64);
            v9->avail_in = v7;
            v9->next_uuid_t out = (Bytef *)__dst;
            v9->uInt avail_out = a3;
            int v10 = inflate(v9, 0);
            if (v10)
            {
              if (v10 != 1)
              {
                fprintf((FILE *)*MEMORY[0x1895F89D0], "Could not inflate: %d\n");
                return -1LL;
              }

              *(_BYTE *)(a1 + 96) = 1;
            }

            uint64_t v11 = *(void *)(a1 + 80);
          }

          uint64_t v14 = *(unsigned int *)(v11 + 32);
          uint64_t result = a3 - v14;
          if (v7 >= 1 && a3 == v14)
          {
            uint64_t result = 0LL;
            if (!*(_BYTE *)(a1 + 96)) {
              continue;
            }
          }

          return result;
        }
      }

      else
      {
        return read_from_source((uint64_t *)a1, __dst, a3, a3);
      }
    }

    else
    {
      return 0LL;
    }
  }

  return result;
}

size_t read_from_source(uint64_t *a1, char *__dst, size_t a3, size_t a4)
{
  unsigned int v4 = __dst;
  if (a4 >= a3) {
    size_t v6 = a3;
  }
  else {
    size_t v6 = a4;
  }
  unint64_t v8 = a1[5];
  unint64_t v7 = a1[6];
  BOOL v9 = v8 > v7;
  size_t v10 = v8 - v7;
  if (v9)
  {
    if (v6 >= v10) {
      size_t v11 = v10;
    }
    else {
      size_t v11 = v6;
    }
    memcpy(__dst, (const void *)(a1[4] + v7), v11);
    a1[6] += v11;
    v4 += v11;
    v6 -= v11;
    if (v6) {
      goto LABEL_12;
    }
  }

  else
  {
    size_t v11 = 0LL;
    if (v6)
    {
LABEL_12:
      uint64_t v12 = 0LL;
      do
      {
        size_t v13 = resilient_source_read(a1[2], v4, v6 - v12);
        if (v13 == -1LL)
        {
          if (*__error() != 35)
          {
            uint64_t v14 = (FILE *)*MEMORY[0x1895F89D0];
            int v15 = __error();
            int v16 = strerror(*v15);
            fprintf(v14, "Could not read %ld bytes from source: %s\n", v6 - v12, v16);
            return -1LL;
          }
        }

        else
        {
          if (!v13) {
            return v11;
          }
          v4 += v13;
          v12 += v13;
          v11 += v13;
        }
      }

      while (v12 != v6);
    }
  }

  return v11;
}

uint64_t BOMBomHLIndexNew(uint64_t a1)
{
  unint64_t v2 = BOM_malloczero(0x20uLL);
  uint64_t v3 = (uint64_t)v2;
  if (v2)
  {
    *unint64_t v2 = a1;
    unsigned int v4 = BOMTreeNewWithName(a1, "HLIndex");
    *(void *)(v3 + 8) = v4;
    if (!v4
      || (CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x189604DB0], 0LL, MEMORY[0x189605240], 0LL),
          (*(void *)(v3 + 16) = Mutable) == 0LL))
    {
      BOMBomHLIndexFree(v3);
      return 0LL;
    }
  }

  return v3;
}

uint64_t BOMBomHLIndexFree(uint64_t a1)
{
  unint64_t v2 = *(const __CFDictionary **)(a1 + 16);
  if (v2)
  {
    LODWORD(v3) = CFDictionaryGetCount(v2);
    size_t v4 = 8LL * v3;
    int v5 = (const void **)BOM_malloc(v4);
    if (v5)
    {
      size_t v6 = v5;
      unint64_t v7 = (const void **)BOM_malloc(v4);
      if (v7)
      {
        unint64_t v8 = (uint64_t *)v7;
        CFDictionaryGetKeysAndValues(*(CFDictionaryRef *)(a1 + 16), v6, v7);
        uint64_t v3 = v3;
        if ((_DWORD)v3)
        {
          BOOL v9 = v8;
          do
          {
            uint64_t v10 = *v9++;
            BOMTreeFree(v10);
            --v3;
          }

          while (v3);
        }

        free(v6);
        free(v8);
        CFRelease(*(CFTypeRef *)(a1 + 16));
        goto LABEL_10;
      }
    }

    return 1LL;
  }

uint64_t BOMBomHLIndexOpen(uint64_t a1, int a2)
{
  size_t v4 = BOM_malloczero(0x20uLL);
  uint64_t v5 = (uint64_t)v4;
  if (v4)
  {
    *size_t v4 = a1;
    uint64_t v6 = BOMTreeOpenWithName(a1, "HLIndex", a2);
    *(void *)(v5 + 8) = v6;
    if (!v6
      || a2
      && (CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x189604DB0], 0LL, MEMORY[0x189605240], 0LL),
          (*(void *)(v5 + 16) = Mutable) == 0LL))
    {
      BOMBomHLIndexFree(v5);
      return 0LL;
    }
  }

  return v5;
}

uint64_t BOMBomHLIndexCommit(uint64_t a1)
{
  if (!*(_BYTE *)(a1 + 24)) {
    return 0LL;
  }
  unint64_t v2 = *(const __CFDictionary **)(a1 + 16);
  if (!v2) {
    goto LABEL_10;
  }
  unsigned int Count = CFDictionaryGetCount(v2);
  size_t v4 = 8LL * Count;
  uint64_t v5 = (const void **)BOM_malloc(v4);
  if (v5)
  {
    uint64_t v6 = v5;
    unint64_t v7 = (const void **)BOM_malloc(v4);
    if (v7)
    {
      unint64_t v8 = v7;
      CFDictionaryGetKeysAndValues(*(CFDictionaryRef *)(a1 + 16), v6, v7);
      uint64_t v9 = Count;
      if (Count)
      {
        unint64_t v10 = 0LL;
        uint64_t v11 = 8 * v9;
        while (!BOMTreeCommit((uint64_t)v8[v10 / 8]))
        {
          v10 += 8LL;
          if (v11 == v10) {
            goto LABEL_9;
          }
        }

        free(v6);
        free(v8);
        return 1LL;
      }

uint64_t BOMBomHLIndexCount(uint64_t a1, unsigned int a2)
{
  char v5 = 0;
  if (!a1) {
    return 0LL;
  }
  if (a2)
  {
    uint64_t TreeFor = _hl_findTreeFor(a1, a2, &v5);
    if (TreeFor) {
      goto LABEL_4;
    }
    return 0LL;
  }

  uint64_t TreeFor = *(const void **)(a1 + 8);
  if (!TreeFor) {
    return 0LL;
  }
LABEL_4:
  uint64_t v3 = BOMTreeCount((uint64_t)TreeFor);
  if (v5) {
    BOMTreeFree((uint64_t)TreeFor);
  }
  return v3;
}

const void *_hl_findTreeFor(uint64_t a1, unsigned int a2, char *a3)
{
  unsigned int v4 = a2;
  unsigned int valuePtr = a2;
  int IsOpenForWriting = BOMStorageIsOpenForWriting(*(void *)a1);
  if (*(void *)(a1 + 16))
  {
    CFNumberRef v7 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x189604DB0], kCFNumberSInt32Type, &valuePtr);
    if (!v7) {
      return 0LL;
    }
    CFNumberRef v8 = v7;
    unint64_t Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), v7);
    CFRelease(v8);
    if (Value) {
      return Value;
    }
    unsigned int v4 = valuePtr;
  }

  unsigned int valuePtr = bswap32(v4);
  uint64_t v10 = *(void *)a1;
  uint64_t v11 = *(void **)(a1 + 8);
  uint64_t v12 = (unsigned int *)BOMTreeGetValue((uint64_t)v11, &valuePtr, 4uLL);
  if (v12)
  {
    unsigned int v13 = *v12;
    unsigned int v14 = bswap32(*v12);
    unsigned int v21 = v14;
    if (!v13) {
      return 0LL;
    }
    unint64_t Value = (const void *)BOMTreeOpen(v10, v14, IsOpenForWriting);
    if (!Value)
    {
LABEL_18:
      if (a3)
      {
        char v19 = 1;
        goto LABEL_20;
      }

      return Value;
    }
  }

  else
  {
    if (!IsOpenForWriting) {
      return 0LL;
    }
    unsigned int v15 = BOMStorageNewBlock(v10);
    if (!v15) {
      return 0LL;
    }
    unsigned int v16 = v15;
    unint64_t Value = BOMTreeNewWithOptions(v10, v15, 0LL, 0x40u, 0);
    if (!Value) {
      goto LABEL_18;
    }
    unsigned int v21 = bswap32(v16);
    BOMTreeSetValue(v11, &valuePtr, 4uLL, (uint64_t)&v21, 4LL);
  }

  if (!*(void *)(a1 + 16)) {
    goto LABEL_18;
  }
  unsigned int valuePtr = bswap32(valuePtr);
  CFNumberRef v17 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x189604DB0], kCFNumberSInt32Type, &valuePtr);
  if (!v17) {
    return 0LL;
  }
  CFNumberRef v18 = v17;
  CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 16), v17, Value);
  CFRelease(v18);
  if (a3)
  {
    char v19 = 0;
LABEL_20:
    *a3 = v19;
  }

  return Value;
}

uint64_t BOMBomHLIndexBlock(uint64_t a1, unsigned int a2)
{
  if (!a1) {
    return 0LL;
  }
  unsigned int v2 = a2;
  unsigned int v4 = (char *)BOMTreeIteratorNew(*(void *)(a1 + 8), 0LL, 0LL, 0LL);
  if (!v4) {
    return 0LL;
  }
  for (unsigned int i = v4; v2; --v2)
    BOMTreeIteratorNext((uint64_t)i);
  uint64_t v6 = (unsigned int *)BOMTreeIteratorKey((uint64_t)i);
  if (v6) {
    uint64_t v7 = bswap32(*v6);
  }
  else {
    uint64_t v7 = 0LL;
  }
  BOMTreeIteratorFree(i);
  return v7;
}

uint64_t BOMBomHLIndexGet(uint64_t a1, unsigned int a2, unsigned int a3, void *a4, size_t *a5)
{
  uint64_t v5 = 0LL;
  char v15 = 0;
  uint64_t v6 = 1LL;
  if (a1)
  {
    if (a2)
    {
      if (a5)
      {
        uint64_t TreeFor = _hl_findTreeFor(a1, a2, &v15);
        uint64_t v5 = (uint64_t)TreeFor;
        if (TreeFor)
        {
          if (BOMTreeCount((uint64_t)TreeFor) > a3)
          {
            uint64_t v11 = (char *)BOMTreeIteratorNew(v5, 0LL, 0LL, 0LL);
            if (v11)
            {
              for (unsigned int i = v11; a3; --a3)
                BOMTreeIteratorNext((uint64_t)i);
              *a5 = BOMTreeIteratorKeySize((uint64_t)i);
              unsigned int v13 = (const void *)BOMTreeIteratorKey((uint64_t)i);
              memmove(a4, v13, *a5);
              BOMTreeIteratorFree(i);
              uint64_t v6 = 0LL;
            }
          }
        }
      }
    }
  }

  if (v15) {
    BOMTreeFree(v5);
  }
  return v6;
}

uint64_t BOMBomHLIndexSet(uint64_t a1, unsigned int a2, const void *a3, size_t a4)
{
  uint64_t v4 = 0LL;
  char v12 = 0;
  uint64_t v5 = 1LL;
  if (a1)
  {
    if (a2)
    {
      if (a4)
      {
        uint64_t TreeFor = _hl_findTreeFor(a1, a2, &v12);
        uint64_t v4 = (uint64_t)TreeFor;
        if (TreeFor)
        {
          uint64_t v10 = BOMTreeSetValue(TreeFor, a3, a4, 0LL, 0LL);
          *(_BYTE *)(a1 + 24) = 1;
          uint64_t v5 = v10;
        }
      }
    }
  }

  if (v12) {
    BOMTreeFree(v4);
  }
  return v5;
}

uint64_t BOMBomHLIndexRemove(uint64_t a1, unsigned int a2, const void *a3, size_t a4)
{
  unsigned int valuePtr = a2;
  char v14 = 0;
  uint64_t v4 = 1LL;
  if (!a1 || !a2) {
    return v4;
  }
  uint64_t TreeFor = _hl_findTreeFor(a1, a2, &v14);
  uint64_t v9 = (uint64_t)TreeFor;
  if (TreeFor)
  {
    if (a3)
    {
      uint64_t v4 = BOMTreeRemoveValue((uint64_t)TreeFor, a3, a4);
    }

    else
    {
      CFNumberRef v10 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x189604DB0], kCFNumberSInt32Type, &valuePtr);
      if (!v10) {
        goto LABEL_11;
      }
      CFNumberRef v11 = v10;
      char v12 = *(__CFDictionary **)(a1 + 16);
      if (v12) {
        CFDictionaryRemoveValue(v12, v11);
      }
      CFRelease(v11);
      BOMTreeRemoveAndFree(v9);
      uint64_t v4 = 0LL;
    }

    *(_BYTE *)(a1 + 24) = 1;
  }

uint64_t _BOMBomHLIndexPrintDiagnostics(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = *(void *)(result + 8);
    unsigned int v2 = (FILE **)MEMORY[0x1895F89D0];
    fprintf((FILE *)*MEMORY[0x1895F89D0], "Tree: %s\n", "HLIndex");
    uint64_t result = (uint64_t)BOMTreeIteratorNew(v1, 0LL, 0LL, 0LL);
    if (result)
    {
      uint64_t v3 = result;
      int v4 = 0;
      if (BOMTreeIteratorIsAtEnd(result))
      {
LABEL_4:
        fprintf(*v2, "   # records: %d\n", v4);
        fprintf(*v2, "   # pages  : %d (%d)\n", 0, 0);
        fprintf(*v2, "     leaf   : %d (%d)\n", 0, 0);
        fprintf(*v2, "     branch : %d (%d)\n", 0, 0);
        fprintf(*v2, "   key size : %zd\n", 0LL);
        return fprintf(*v2, "   data size: %zd\n", 0LL);
      }

      else
      {
        while (1)
        {
          uint64_t result = BOMTreeIteratorValue(v3);
          if (!result) {
            break;
          }
          if (!*(_DWORD *)result) {
            break;
          }
          unsigned int v5 = bswap32(*(_DWORD *)result);
          uint64_t v6 = BOMTreeStorage(v1);
          uint64_t result = BOMTreeOpen(v6, v5, 0);
          if (!result) {
            break;
          }
          uint64_t v7 = result;
          v4 += BOMTreeCount(result);
          BOMTreeFree(v7);
          BOMTreeIteratorNext(v3);
        }
      }
    }
  }

  return result;
}

uint64_t _BOMBomPrint(uint64_t a1)
{
  if (!a1) {
    return 1LL;
  }
  RootFSObject = (unsigned int *)BOMBomGetRootFSObject(a1);
  uint64_t v3 = BOMBomEnumeratorNew(a1, RootFSObject);
  BOMFSObjectFree((uint64_t)RootFSObject);
  if (!v3) {
    return 1LL;
  }
  int v4 = BOMBomEnumeratorNext((uint64_t)v3);
  if (v4)
  {
    unsigned int v5 = v4;
    uint64_t v6 = (FILE **)MEMORY[0x1895F89D0];
    do
    {
      uint64_t v7 = (const char *)BOMFSObjectPathName((uint64_t)v5);
      int v8 = BOMFSObjectPathID((uint64_t)v5);
      int v9 = BOMFSObjectParentPathID((uint64_t)v5);
      fprintf(*v6, "%d\t%d\t%s\n", v9, v8, v7);
      BOMFSObjectFree((uint64_t)v5);
      unsigned int v5 = BOMBomEnumeratorNext((uint64_t)v3);
    }

    while (v5);
  }

  BOMBomEnumeratorFree(v3);
  return 0LL;
}

uint64_t _BOMBomPathTreePrint(uint64_t a1)
{
  if (!a1) {
    return 1LL;
  }
  uint64_t v1 = BOMBomPathsTree(a1);
  if (!v1) {
    return 1LL;
  }
  uint64_t v2 = v1;
  uint64_t v3 = BOMNewPathKey(0, "", &v15);
  if (!v3) {
    return 1LL;
  }
  int v4 = v3;
  unsigned int v5 = (char *)BOMTreeIteratorNew(v2, v3, v15, 0LL);
  free(v4);
  if (!v5) {
    return 1LL;
  }
  if (!BOMTreeIteratorIsAtEnd((uint64_t)v5))
  {
    uint64_t v6 = (FILE **)MEMORY[0x1895F89D0];
    do
    {
      uint64_t v7 = (unsigned int *)BOMTreeIteratorKey((uint64_t)v5);
      int v8 = (unsigned int *)BOMTreeIteratorValue((uint64_t)v5);
      int v9 = *v6;
      unsigned int v10 = BOMPathIDFromPathKey(v7);
      CFNumberRef v11 = (const char *)BOMShortNameFromPathKey((uint64_t)v7);
      unsigned int v12 = BOMPathIDFromPathKey(v8);
      int v13 = BOMBlockIDFromPathValue((uint64_t)v8);
      fprintf(v9, "%d\t%s -> %d\t%d\n", v10, v11, v12, v13);
      BOMTreeIteratorNext((uint64_t)v5);
    }

    while (!BOMTreeIteratorIsAtEnd((uint64_t)v5));
  }

  BOMTreeIteratorFree(v5);
  return 0LL;
}

uint64_t _BOMCFArrayPrint(const __CFArray *a1)
{
  if (!a1) {
    return 1LL;
  }
  CFTypeID TypeID = CFArrayGetTypeID();
  if (TypeID == CFGetTypeID(a1))
  {
    int Count = CFArrayGetCount(a1);
    if (Count >= 1)
    {
      CFIndex v4 = 0LL;
      uint64_t v5 = Count;
      uint64_t v6 = (FILE **)MEMORY[0x1895F89D0];
      do
      {
        uint64_t v7 = *v6;
        ValueAtIndex = (const char *)CFArrayGetValueAtIndex(a1, v4);
        fprintf(v7, "%d\t%s\n", v4++, ValueAtIndex);
      }

      while (v5 != v4);
    }

    return 0LL;
  }

  else
  {
    uint64_t v9 = 1LL;
    fwrite("[not an array]\n", 0xFuLL, 1uLL, (FILE *)*MEMORY[0x1895F89D0]);
  }

  return v9;
}

uint64_t BOMCopierNew()
{
  return BOMCopierNewWithSys(0LL);
}

uint64_t BOMCopierNewWithSys(void *a1)
{
  uint64_t v2 = BOM_malloczero(0x3308uLL);
  uint64_t v3 = (uint64_t)v2;
  if (v2)
  {
    *((_DWORD *)v2 + 4) = 0x20000;
    if (vm_allocate(*MEMORY[0x1895FBBE0], (vm_address_t *)v2 + 1, 0x20000uLL, 1))
    {
      BOMCopierFree(v3);
      return 0LL;
    }

    else
    {
      *(void *)(v3 + 24) = 4096LL;
      uint64_t v5 = calloc(1uLL, 0x1000uLL);
      *(void *)(v3 + 32) = v5;
      if (v5)
      {
        *(_DWORD *)(v3 + 10568) = getpid();
        *(_BYTE *)(v3 + 2304) = 0;
        *(_BYTE *)(v3 + 6400) = 0;
        *(_DWORD *)(v3 + 12792) = -1;
        uint64_t v6 = BOMHardLinkTableNew();
        *(void *)uint64_t v3 = v6;
        if (v6)
        {
          uint64_t v7 = BOMStackNew();
          *(void *)(v3 + 40) = v7;
          if (v7)
          {
            if (!a1) {
              a1 = BomSys_default();
            }
            *(void *)(v3 + 12832) = a1;
          }
        }
      }
    }
  }

  return v3;
}

void BOMCopierFree(uint64_t a1)
{
  if (a1)
  {
    _resetCopier(a1);
    uint64_t v2 = *(void *)(a1 + 8);
    if (v2)
    {
      MEMORY[0x186E385F0](*MEMORY[0x1895FBBE0], v2, *(int *)(a1 + 16));
      *(void *)(a1 + 8) = 0LL;
    }

    uint64_t v3 = *(void **)(a1 + 32);
    if (v3)
    {
      free(v3);
      *(void *)(a1 + 32) = 0LL;
    }

    if (*(void *)a1)
    {
      BOMHardLinkTableFree(*(const void ***)a1);
      *(void *)a1 = 0LL;
    }

    uint64_t v4 = *(void *)(a1 + 40);
    if (v4)
    {
      while (!BOMStackIsEmpty(v4))
      {
        uint64_t v5 = (void **)BOMStackPop(*(uint64_t **)(a1 + 40));
        free(*v5);
        free(v5[1]);
        free(v5[2]);
        free(v5);
        uint64_t v4 = *(void *)(a1 + 40);
      }

      BOMStackFree(*(void ***)(a1 + 40));
    }

    free((void *)a1);
  }

void _resetCopier(uint64_t a1)
{
  if (a1)
  {
    uint64_t v3 = (void *)(a1 + 216);
    uint64_t v2 = *(void **)(a1 + 216);
    if (v2)
    {
      free(v2);
      void *v3 = 0LL;
      v3[1] = 0LL;
    }

    uint64_t v4 = *(void **)(a1 + 12928);
    if (v4)
    {
      free(v4);
      *(void *)(a1 + 12928) = 0LL;
    }

    uint64_t v5 = *(void **)(a1 + 12920);
    if (v5)
    {
      free(v5);
      *(void *)(a1 + 12920) = 0LL;
    }

    uint64_t v6 = *(void **)(a1 + 12936);
    if (v6)
    {
      free(v6);
      *(void *)(a1 + 12936) = 0LL;
    }

    uint64_t v7 = *(void **)(a1 + 10584);
    if (v7)
    {
      free(v7);
      *(void *)(a1 + 10584) = 0LL;
    }

    int v8 = *(void **)(a1 + 12912);
    if (v8)
    {
      free(v8);
      *(void *)(a1 + 12912) = 0LL;
    }

    uint64_t v9 = *(void **)(a1 + 12904);
    if (v9)
    {
      free(v9);
      *(void *)(a1 + 12904) = 0LL;
    }

    unsigned int v10 = *(void **)(a1 + 12896);
    if (v10)
    {
      free(v10);
      *(void *)(a1 + 12896) = 0LL;
    }

    uint64_t v11 = *(void *)(a1 + 152);
    if (v11)
    {
      BOMBomFree(v11);
      *(void *)(a1 + 152) = 0LL;
    }

    uint64_t v12 = *(void *)(a1 + 160);
    if (v12)
    {
      BOMBomFree(v12);
      *(void *)(a1 + 160) = 0LL;
    }

    char v14 = (void *)(a1 + 176);
    uint64_t v13 = *(void *)(a1 + 176);
    if (v13)
    {
      BOMFileClose(v13);
      *char v14 = 0LL;
    }

    size_t v15 = *(void **)(a1 + 184);
    if (v15)
    {
      BOMPatternFree(v15);
      *(void *)(a1 + 184) = 0LL;
    }

    unsigned int v16 = *(uint64_t **)(a1 + 12736);
    if (v16)
    {
      BOMCPIOFree(v16);
      *(void *)(a1 + 12736) = 0LL;
    }

    CFNumberRef v17 = *(void **)(a1 + 12760);
    if (v17)
    {
      BOMPKZipFree(v17);
      *(void *)(a1 + 12760) = 0LL;
    }

    if (*(void *)(a1 + 12840)) {
      BOMCopierSandbox_unbox(a1);
    }
    CFNumberRef v18 = *(void **)(a1 + 136);
    if (v18)
    {
      unint64_t v19 = *(unsigned int *)(a1 + 144);
      if ((_DWORD)v19)
      {
        unint64_t v20 = 0LL;
        uint64_t v21 = 16LL;
        do
        {
          __int128 v22 = *(void **)(*(void *)(a1 + 136) + v21);
          if (v22)
          {
            free(v22);
            unint64_t v19 = *(unsigned int *)(a1 + 144);
          }

          ++v20;
          v21 += 32LL;
        }

        while (v20 < v19);
        CFNumberRef v18 = *(void **)(a1 + 136);
      }

      free(v18);
      *(void *)(a1 + 136) = 0LL;
    }

    uint64_t v23 = *(void *)(a1 + 152);
    if (v23)
    {
      BOMBomFree(v23);
      *(void *)(a1 + 152) = 0LL;
    }

    uint64_t v24 = *(void *)(a1 + 160);
    if (v24)
    {
      BOMBomFree(v24);
      *(void *)(a1 + 160) = 0LL;
    }

    uint64_t v25 = *(void **)(a1 + 184);
    if (v25)
    {
      BOMPatternFree(v25);
      *(void *)(a1 + 184) = 0LL;
    }

    __int16 v26 = *(void **)(a1 + 12800);
    if (v26)
    {
      free(v26);
      *(void *)(a1 + 12800) = 0LL;
    }

    *(_DWORD *)(a1 + 10564) = 0;
    uint64_t v27 = *(const void **)(a1 + 12856);
    if (v27)
    {
      CFRelease(v27);
      *(void *)(a1 + 12856) = 0LL;
    }

    bzero((void *)(a1 + 248), 0x400uLL);
    bzero((void *)(a1 + 1272), 0x400uLL);
    *(void *)(a1 + 2296) = 0LL;
    bzero((void *)(a1 + 2304), 0x400uLL);
    bzero((void *)(a1 + 3328), 0x400uLL);
    bzero((void *)(a1 + 4352), 0x400uLL);
    bzero((void *)(a1 + 5376), 0x400uLL);
    bzero((void *)(a1 + 6400), 0x400uLL);
    bzero((void *)(a1 + 7424), 0x400uLL);
    bzero((void *)(a1 + 8448), 0x400uLL);
    *(_DWORD *)(a1 + 144) = 0;
    *(_DWORD *)(a1 + 168) = 0;
    *(_WORD *)(a1 + 172) = 0;
    *(void *)(a1 + 12712) = 0x300000000LL;
    *(_BYTE *)(a1 + 12720) = 0;
    *(_WORD *)(a1 + 12768) = 256;
    *char v14 = 0LL;
    *(void *)(a1 + 184) = 0LL;
    *(_WORD *)(a1 + 192) = 1;
    *(_DWORD *)(a1 + 232) = 0;
    *(_WORD *)(a1 + 12813) = 257;
    *(_WORD *)(a1 + 12744) = 0;
    *(_BYTE *)(a1 + 12746) = 0;
    *(_DWORD *)(a1 + 12816) = 2;
    *(_WORD *)(a1 + 12822) = 0;
    *(_BYTE *)(a1 + 12824) = 0;
    *(void *)(a1 + 12960) = 0LL;
    *(void *)(a1 + 12976) = 0LL;
    *(void *)(a1 + 12984) = -1LL;
    *(_DWORD *)(a1 + 212) = -1;
    __int16 v28 = *(unsigned int **)(a1 + 13032);
    if (v28)
    {
      BOMCopierDestinationFree(v28);
      *(void *)(a1 + 13032) = 0LL;
    }

    uint64_t v29 = *(const void **)(a1 + 13008);
    if (v29)
    {
      CFRelease(v29);
      *(void *)(a1 + 13008) = 0LL;
    }

    __int16 v30 = *(void **)(a1 + 13016);
    if (v30)
    {
      BOMCopierSourceFree(v30);
      *(void *)(a1 + 13016) = 0LL;
      uint64_t v31 = *(const void **)(a1 + 13008);
      if (v31)
      {
        CFRelease(v31);
        *(void *)(a1 + 13008) = 0LL;
      }
    }
  }

uint64_t BOMCopierCopy(uint64_t a1, char *a2, char *a3)
{
  return BOMCopierCopyWithOptions(a1, a2, a3, 0LL);
}

uint64_t BOMCopierCopyWithOptions(uint64_t a1, char *a2, char *a3, const void *a4)
{
  uint64_t v58 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    _resetCopier(a1);
    *__error() = 0;
    int v8 = getenv("DITTO2");
    if (v8)
    {
      if (strcmp(v8, "1"))
      {
        if (!a4) {
          goto LABEL_15;
        }
        goto LABEL_5;
      }
    }

    else
    {
      if (!a4) {
        goto LABEL_15;
      }
      CFTypeID TypeID = CFDictionaryGetTypeID();
      if (TypeID != CFGetTypeID(a4)) {
        goto LABEL_18;
      }
      unint64_t Value = CFDictionaryGetValue((CFDictionaryRef)a4, @"DITTO2");
      if (!Value
        || (uint64_t v25 = Value, v26 = CFBooleanGetTypeID(), v26 != CFGetTypeID(v25))
        || !CFEqual(v25, (CFTypeRef)*MEMORY[0x189604DE8]))
      {
LABEL_5:
        CFTypeID v14 = CFDictionaryGetTypeID();
        if (v14 == CFGetTypeID(a4))
        {
          if (_parseCopierOptions(a1, (const __CFDictionary *)a4))
          {
            BOMCopierNotifyFatalError(a1, "Could not parse the options dictionary", v21, v9, v10, v11, v12, v13, v56);
LABEL_17:
            _resetCopier(a1);
            return 1LL;
          }

LABEL_15:
          if (_verifyCopierOptions(a1, (uint64_t)a2, (uint64_t)a3, v9, v10, v11, v12, v13)
            || _prepareCopierState(a1))
          {
            goto LABEL_17;
          }

          int v34 = *(_DWORD *)(a1 + 12712);
          if (v34)
          {
            int v35 = *(_DWORD *)(a1 + 12964);
            *(_DWORD *)(a1 + 12992) = v35;
            if (!*(_BYTE *)(a1 + 12813))
            {
              v35 |= 0x10u;
              *(_DWORD *)(a1 + 12992) = v35;
            }

            if (v34 == 1)
            {
              uint64_t v36 = getenv("BOM_ASYNC");
              if (!v36 || strcmp("0", v36))
              {
                v35 |= 0x20u;
                *(_DWORD *)(a1 + 12992) = v35;
              }
            }

            if (a2)
            {
              int v37 = strcmp("-", a2);
              uint64_t v38 = (void *)(a1 + 12976);
              if (v37)
              {
                if (!BOMFileOpenWithSys( v38,  (uint64_t)a2,  0LL,  0LL,  v35,  *(void (***)(void, uint64_t, uint64_t, uint64_t))(a1 + 12832))) {
                  goto LABEL_49;
                }
                goto LABEL_41;
              }

              if (BOMFileOpenSTDIN(v38, v35))
              {
LABEL_41:
                AAFieldKey v45 = __error();
                int v41 = *(void (**)(uint64_t, const char *, uint64_t))(a1 + 64);
                if (!v41) {
                  goto LABEL_17;
                }
                uint64_t v42 = *v45;
                uint64_t v43 = a1;
                __int128 v44 = a2;
                goto LABEL_43;
              }
            }

            else
            {
              uint64_t v39 = *(unsigned int *)(a1 + 12984);
              if ((_DWORD)v39 == -1)
              {
                int v46 = *(const void **)(a1 + 12944);
                if (v46 && BOMFileNewFromCFReadStream((void *)(a1 + 12976), v46, v35))
                {
                  uint64_t v47 = __error();
                  int v41 = *(void (**)(uint64_t, const char *, uint64_t))(a1 + 64);
                  if (!v41) {
                    goto LABEL_17;
                  }
                  uint64_t v42 = *v47;
                  __int128 v44 = "CFReadStream";
                  uint64_t v43 = a1;
                  goto LABEL_43;
                }
              }

              else if (BOMFileNewFromFDWithSys( (void *)(a1 + 12976),  v39,  v35,  "rb",  *(void (***)(void, uint64_t, uint64_t, uint64_t))(a1 + 12832)))
              {
                int v40 = __error();
                int v41 = *(void (**)(uint64_t, const char *, uint64_t))(a1 + 64);
                if (!v41) {
                  goto LABEL_17;
                }
                uint64_t v42 = *v40;
                uint64_t v43 = a1;
                __int128 v44 = 0LL;
LABEL_43:
                v41(v43, v44, v42);
                goto LABEL_17;
              }
            }
          }

          else
          {
            if (!a2)
            {
              BOMCopierNotifyFatalError( a1,  "If the source is a filesystem, the fromObj argument cannot be nil",  v28,  v29,  v30,  v31,  v32,  v33,  v56);
              _resetCopier(a1);
              goto LABEL_17;
            }

            if (*(_BYTE *)(a1 + 12968))
            {
              uint64_t v28 = *(void *)(a1 + 152);
              if (v28) {
                BOMCopierSandbox_boxup(a1, a2, v28);
              }
            }
          }

  if (a4)
  {
    if ((*(_WORD *)(a2 + 4) & 1) == 0 && (_DWORD)v4 == v10)
    {
      uint64_t v22 = *(void *)(a3 + 32);
      *(_DWORD *)(*(void *)(a2 + 32) + 4LL * v11) = *(_DWORD *)(v22 + 4LL * v14);
      *(_DWORD *)(v22 + 4LL * v14) = 0;
    }

    if ((_DWORD)v4 != v10)
    {
      if ((_DWORD)v4)
      {
        uint64_t v23 = 0LL;
        uint64_t v24 = 4LL * v10;
        uint64_t v25 = v13 + v10;
        do
        {
          if (v23 >= v13)
          {
            uint64_t v27 = *(void *)(a3 + 24);
            if (v13 == v23)
            {
              *(_DWORD *)(v27 + 4 * v13) = 0;
              CFTypeID v26 = *(void *)(a3 + 32);
              *(_DWORD *)(v26 + 4 * v13) = *(_DWORD *)(v26 + 4 * v25);
            }

            else
            {
              *(_DWORD *)(v27 + 4 * v23) = 0;
              CFTypeID v26 = *(void *)(a3 + 32);
              *(_DWORD *)(v26 + 4 * v23) = 0;
            }
          }

          else
          {
            CFTypeID v26 = *(void *)(a3 + 32);
            *(_DWORD *)(*(void *)(a3 + 24) + 4 * v23) = *(_DWORD *)(*(void *)(a3 + 24) + 4 * v23 + v24);
            *(_DWORD *)(v26 + 4 * v23) = *(_DWORD *)(v26 + 4 * v23 + v24);
          }

          ++v23;
        }

        while (v4 != v23);
      }

      else
      {
        CFTypeID v26 = *(void *)(a3 + 32);
      }

      *(_DWORD *)(v26 + 4 * v4) = 0;
    }
  }

  *(_WORD *)(a2 + 16) = v12;
  *(_WORD *)(a2 + 4) |= 2u;
  *(_WORD *)(a3 + 16) = v13;
  *(_WORD *)(a3 + 4) |= 2u;
  return result;
}

      a3 = v14 - (a3 - a2 > 1);
    }

    uint64_t v20 = result != 0;
    if (!(_DWORD)result && v16 <= a5) {
      break;
    }
    if (a3 == a2) {
      goto LABEL_21;
    }
    if (!(_DWORD)result) {
      goto LABEL_15;
    }
LABEL_18:
    if (v14 == a3) {
      a2 += (a3 - a2) >> 1;
    }
    else {
      a2 = v14 + 1;
    }
  }

  if (a3 != a2)
  {
    if (v16 >= a5)
    {
      *a6 = v14;
LABEL_29:
      *a7 = 1;
      return result;
    }

    goto LABEL_18;
  }

  if (v16 >= a5) {
    uint64_t v21 = a2 + ((a3 - a2) >> 1);
  }
  else {
    uint64_t v21 = v14 + 1;
  }
  *a6 = v21;
  if (v16 >= a5) {
    goto LABEL_29;
  }
  return result;
}

void BOMCopierNotifyFatalError( uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  if (a1 && *(void *)(a1 + 56))
  {
    CFTypeID v14 = 0LL;
    if (vasprintf(&v14, a2, &a9) == -1)
    {
      uint64_t v10 = (FILE *)*MEMORY[0x1895F89D0];
      uint64_t v11 = __error();
      strerror(*v11);
      fprintf(v10, "Could not create fatal message: %s\n");
    }

    else if (v14)
    {
      (*(void (**)(uint64_t))(a1 + 56))(a1);
      free(v14);
    }

    else
    {
      uint64_t v12 = (FILE *)*MEMORY[0x1895F89D0];
      uint64_t v13 = __error();
      strerror(*v13);
      fprintf(v12, "Could not allocate fatal message: %s\n");
    }
  }

uint64_t _parseCopierOptions(uint64_t a1, const __CFDictionary *a2)
{
  CFTypeID TypeID = CFArrayGetTypeID();
  CFTypeID v5 = CFDictionaryGetTypeID();
  CFTypeID v6 = CFStringGetTypeID();
  CFTypeID v7 = CFBooleanGetTypeID();
  CFTypeID v8 = CFNumberGetTypeID();
  CFTypeID v9 = CFDataGetTypeID();
  unint64_t Value = CFDictionaryGetValue(a2, @"archs");
  *(void *)(a1 + 12880) = Value;
  if (Value && CFGetTypeID(Value) != TypeID)
  {
    size_t v66 = "kBOMCopierOptionArchitectureArrayKey is not a CFArrayRef";
    goto LABEL_269;
  }

  uint64_t v17 = CFDictionaryGetValue(a2, @"fallbackForSubtype");
  *(void *)(a1 + 12888) = v17;
  if (v17 && CFGetTypeID(v17) != v5)
  {
    size_t v66 = "kBOMCopierOptionArchitectureFallbackKey is not a CFDictionaryRef";
    goto LABEL_269;
  }

  uint64_t v18 = (const __CFString *)CFDictionaryGetValue(a2, @"indexbom");
  if (v18)
  {
    uint64_t v19 = v18;
    if (CFGetTypeID(v18) != v6)
    {
      size_t v66 = "kBOMCopierOptionIndexBomKey is not a CFStringRef";
      goto LABEL_269;
    }

    UTF8String = BOMCFStringGetUTF8String(v19);
    *(void *)(a1 + 12896) = UTF8String;
    if (!UTF8String)
    {
      size_t v66 = "Cannot convert indexbom from options dictionary into UTF8 encoded C string";
      goto LABEL_269;
    }
  }

  uint64_t v21 = (const __CFBoolean *)CFDictionaryGetValue(a2, @"verifyFileDataPerIndexBom");
  if (v21)
  {
    uint64_t v22 = v21;
    if (CFGetTypeID(v21) != v7)
    {
      size_t v66 = "kBOMCopierOptionVerifyFileDataPerIndexBomKey is not a CFBooleanRef";
      goto LABEL_269;
    }

    *(_BYTE *)(a1 + 197) = BOMCFGetBoolValue(v22);
  }

  uint64_t v23 = (const __CFString *)CFDictionaryGetValue(a2, @"skipbom");
  if (v23)
  {
    uint64_t v24 = v23;
    if (CFGetTypeID(v23) != v6)
    {
      size_t v66 = "kBOMCopierOptionSkipBomKey is not a CFStringRef";
      goto LABEL_269;
    }

    uint64_t v25 = BOMCFStringGetUTF8String(v24);
    *(void *)(a1 + 12904) = v25;
    if (!v25)
    {
      size_t v66 = "Cannot convert skipbom from options dictionary into UTF8 encoded C string";
      goto LABEL_269;
    }
  }

  CFTypeID v26 = (const __CFBoolean *)CFDictionaryGetValue(a2, @"sourceIsAppSandboxed");
  if (v26)
  {
    uint64_t v27 = v26;
    if (CFGetTypeID(v26) != v7)
    {
      size_t v66 = "kBOMCopierOptionSourceIsAppSandboxed is not a CFBooleanRef";
      goto LABEL_269;
    }

    *(_BYTE *)(a1 + 12968) = BOMCFGetBoolValue(v27);
  }

  uint64_t v28 = (const __CFBoolean *)CFDictionaryGetValue(a2, @"useHFSPlusCompression");
  if (v28)
  {
    uint64_t v29 = v28;
    if (CFGetTypeID(v28) != v7)
    {
      size_t v66 = "kBOMCopierOptionUseHFSPlusCompressionKey is not a CFBooleanRef";
      goto LABEL_269;
    }

    *(_BYTE *)(a1 + 12848) = BOMCFGetBoolValue(v29);
  }

  uint64_t v30 = (const __CFBoolean *)CFDictionaryGetValue(a2, @"preserveHFSPlusCompression");
  if (v30)
  {
    uint64_t v31 = v30;
    if (CFGetTypeID(v30) != v7)
    {
      size_t v66 = "kBOMCopierOptionPreserveHFSPlusCompressionKey is not a CFBooleanRef";
      goto LABEL_269;
    }

    *(_BYTE *)(a1 + 195) = BOMCFGetBoolValue(v31);
  }

  uint64_t v32 = CFDictionaryGetValue(a2, @"hfsPlusCompressionOptions");
  if (v32)
  {
    uint64_t v33 = v32;
    if (CFGetTypeID(v32) != v5)
    {
      size_t v66 = "kBOMCopierOptionHFSPlusCompressionOptionsDictionaryKey is not a CFDictionaryRef";
      goto LABEL_269;
    }

    *(void *)(a1 + 12856) = v33;
    CFRetain(v33);
  }

  int v34 = (const __CFBoolean *)CFDictionaryGetValue(a2, @"copyResources");
  if (v34)
  {
    int v35 = v34;
    if (CFGetTypeID(v34) != v7)
    {
      size_t v66 = "kBOMCopierOptionCopyResourcesKey is not a CFBooleanRef";
      goto LABEL_269;
    }

    *(_BYTE *)(a1 + 169) = BOMCFGetBoolValue(v35);
  }

  uint64_t v36 = (const __CFBoolean *)CFDictionaryGetValue(a2, @"copyExtendedAttributes");
  if (v36)
  {
    int v37 = v36;
    if (CFGetTypeID(v36) != v7)
    {
      size_t v66 = "kBOMCopierOptionCopyExtendedAttributesKey is not a CFBooleanRef";
      goto LABEL_269;
    }

    *(_BYTE *)(a1 + 170) = BOMCFGetBoolValue(v37);
  }

  uint64_t v38 = (const __CFBoolean *)CFDictionaryGetValue(a2, @"copyACLs");
  if (v38)
  {
    uint64_t v39 = v38;
    if (CFGetTypeID(v38) != v7)
    {
      size_t v66 = "kBOMCopierOptionCopyACLsKey is not a CFBooleanRef";
      goto LABEL_269;
    }

    *(_BYTE *)(a1 + 171) = BOMCFGetBoolValue(v39);
  }

  int v40 = (const __CFBoolean *)CFDictionaryGetValue(a2, @"applySourcePermissions");
  if (v40)
  {
    int v41 = v40;
    if (CFGetTypeID(v40) != v7)
    {
      size_t v66 = "kBOMCopierOptionApplySourcePermissionsKey is not a CFBooleanRef";
      goto LABEL_269;
    }

    *(_BYTE *)(a1 + 12822) = BOMCFGetBoolValue(v41);
  }

  uint64_t v42 = (const __CFBoolean *)CFDictionaryGetValue(a2, @"nonatomicCopy");
  if (v42)
  {
    uint64_t v43 = v42;
    if (CFGetTypeID(v42) != v7)
    {
      size_t v66 = "kBOMCopierOptionNonAtomicCopyKey is not a CFBooleanRef";
      goto LABEL_269;
    }

    *(_BYTE *)(a1 + 12823) = BOMCFGetBoolValue(v43);
  }

  __int128 v44 = (const __CFBoolean *)CFDictionaryGetValue(a2, @"segmentLargeFiles");
  if (v44)
  {
    AAFieldKey v45 = v44;
    if (CFGetTypeID(v44) != v7)
    {
      size_t v66 = "kBOMCopierOptionSegmentLargeFilesKey is not a CFBooleanRef";
      goto LABEL_269;
    }

    *(_BYTE *)(a1 + 12824) = BOMCFGetBoolValue(v45);
  }

  int v46 = (const __CFBoolean *)CFDictionaryGetValue(a2, @"keepBinaries");
  if (v46)
  {
    uint64_t v47 = v46;
    if (CFGetTypeID(v46) != v7)
    {
      size_t v66 = "kBOMCopierOptionKeepBinariesKey is not a CFBooleanRef";
      goto LABEL_269;
    }

    *(_BYTE *)(a1 + 173) = BOMCFGetBoolValue(v47);
  }

  uint64_t v48 = (const __CFString *)CFDictionaryGetValue(a2, @"keepBinariesList");
  if (v48)
  {
    uint64_t v49 = v48;
    if (CFGetTypeID(v48) != v6)
    {
      size_t v66 = "kBOMCopierOptionKeepBinariesListKey is not a CFStringRef";
      goto LABEL_269;
    }

    uint64_t v50 = BOMCFStringGetUTF8String(v49);
    *(void *)(a1 + 12920) = v50;
    if (!v50)
    {
      size_t v66 = "Cannot convert kBOMCopierOptionKeepBinariesListKey from options dictionary into UTF8 encoded C string";
      goto LABEL_269;
    }
  }

  uint64_t v51 = (const __CFString *)CFDictionaryGetValue(a2, @"keepBinariesPattern");
  if (v51)
  {
    uint64_t v52 = v51;
    if (CFGetTypeID(v51) != v6)
    {
      size_t v66 = "kBOMCopierOptionKeepBinariesPatternKey is not a CFStringRef";
      goto LABEL_269;
    }

    uint64_t v53 = BOMCFStringGetUTF8String(v52);
    *(void *)(a1 + 12928) = v53;
    if (!v53)
    {
      size_t v66 = "Cannot convert kBOMCopierOptionKeepBinariesPatternKey from options dictionary into UTF8 encoded C string";
      goto LABEL_269;
    }
  }

  uint64_t v54 = (const __CFString *)CFDictionaryGetValue(a2, @"keepBinariesDir");
  if (v54)
  {
    uint64_t v55 = v54;
    if (CFGetTypeID(v54) != v6)
    {
      size_t v66 = "kBOMCopierOptionKeepBinariesDirKey is not a CFStringRef";
      goto LABEL_269;
    }

    char v56 = BOMCFStringGetUTF8String(v55);
    *(void *)(a1 + 12936) = v56;
    if (!v56)
    {
      size_t v66 = "Cannot convert kBOMCopierOptionKeepBinariesDirKey from options dictionary into UTF8 encoded C string";
      goto LABEL_269;
    }
  }

  unint64_t v57 = (const __CFBoolean *)CFDictionaryGetValue(a2, @"crossDevices");
  if (v57)
  {
    uint64_t v58 = v57;
    if (CFGetTypeID(v57) != v7)
    {
      size_t v66 = "kBOMCopierOptionCrossDevicesKey is not a CFBooleanRef";
      goto LABEL_269;
    }

    *(_BYTE *)(a1 + 192) = BOMCFGetBoolValue(v58);
  }

  uint64_t v59 = CFDictionaryGetValue(a2, @"createCPIO");
  if (v59)
  {
    int v60 = v59;
    if (CFGetTypeID(v59) != v7)
    {
      size_t v66 = "kBOMCopierOptionCreateCPIOKey is not a CFBooleanRef";
      goto LABEL_269;
    }

    if (CFEqual(v60, (CFTypeRef)*MEMORY[0x189604DE8])) {
      *(_DWORD *)(a1 + 12716) = 4;
    }
  }

  uint64_t v61 = CFDictionaryGetValue(a2, @"extractCPIO");
  if (v61)
  {
    uint64_t v62 = v61;
    if (CFGetTypeID(v61) != v7)
    {
      size_t v66 = "kBOMCopierOptionExtractCPIOKey is not a CFBooleanRef";
      goto LABEL_269;
    }

    if (CFEqual(v62, (CFTypeRef)*MEMORY[0x189604DE8])) {
      *(_DWORD *)(a1 + 12712) = 1;
    }
  }

  unint64_t v63 = CFDictionaryGetValue(a2, @"compressCPIO");
  if (v63 || (unint64_t v63 = CFDictionaryGetValue(a2, @"compress")) != 0LL)
  {
    CFTypeRef cf1 = v63;
    if (CFGetTypeID(v63) == v6)
    {
      if (!CFEqual(cf1, @"auto"))
      {
        if (CFEqual(cf1, @"none"))
        {
          char v64 = 0;
          int v65 = 0;
LABEL_103:
          *(_BYTE *)(a1 + 12720) = v64;
          *(_DWORD *)(a1 + 12964) = v65;
          goto LABEL_104;
        }

        if (CFEqual(cf1, @"gzip"))
        {
          char v64 = 1;
          int v65 = 1;
          goto LABEL_103;
        }

        if (!CFEqual(cf1, @"bzip2"))
        {
          size_t v66 = "Unknown compression type";
          goto LABEL_269;
        }

        int v65 = 2;
LABEL_102:
        char v64 = 1;
        goto LABEL_103;
      }
    }

    else if (!CFEqual(cf1, (CFTypeRef)*MEMORY[0x189604DE8]))
    {
      goto LABEL_104;
    }

    int v65 = 8;
    goto LABEL_102;
  }

LABEL_104:
  size_t v67 = (const __CFBoolean *)CFDictionaryGetValue(a2, @"applyIndexBomOwnership");
  if (v67)
  {
    uint64_t v68 = v67;
    if (CFGetTypeID(v67) != v7)
    {
      size_t v66 = "kBOMCopierOptionApplyIndexBomOwnershipKey is not a CFBooleanRef";
      goto LABEL_269;
    }

    *(_BYTE *)(a1 + 12746) = BOMCFGetBoolValue(v68);
  }

  unint64_t v69 = CFDictionaryGetValue(a2, @"createPKZip");
  if (v69)
  {
    uint64_t v70 = v69;
    if (CFGetTypeID(v69) != v7)
    {
      size_t v66 = "kBOMCopierOptionCreatePKZipKey is not a CFBooleanRef";
      goto LABEL_269;
    }

    if (CFEqual(v70, (CFTypeRef)*MEMORY[0x189604DE8])) {
      *(_DWORD *)(a1 + 12716) = 5;
    }
  }

  size_t v71 = CFDictionaryGetValue(a2, @"extractPKZip");
  if (v71)
  {
    uint64_t v72 = v71;
    if (CFGetTypeID(v71) != v7)
    {
      size_t v66 = "kBOMCopierOptionExtractPKZipKey is not a CFBooleanRef";
      goto LABEL_269;
    }

    if (CFEqual(v72, (CFTypeRef)*MEMORY[0x189604DE8]))
    {
      *(_DWORD *)(a1 + 12712) = 2;
      *(_BYTE *)(a1 + 12768) = *(_BYTE *)(a1 + 169);
    }
  }

  uint64_t v73 = CFDictionaryGetValue(a2, @"extractAppleArchive");
  if (v73)
  {
    int v74 = v73;
    if (CFGetTypeID(v73) != v7)
    {
      size_t v66 = "kBOMCopierOptionExtractAppleArchiveKey is not a CFBooleanRef";
      goto LABEL_269;
    }

    if (CFEqual(v74, (CFTypeRef)*MEMORY[0x189604DE8])) {
      *(_DWORD *)(a1 + 12712) = 3;
    }
  }

  char v75 = CFDictionaryGetValue(a2, @"createAppleArchive");
  if (v75)
  {
    int v76 = v75;
    if (CFGetTypeID(v75) != v7)
    {
      size_t v66 = "kBOMCopierOptionCreateAppleArchiveKey is not a CFBooleanRef";
      goto LABEL_269;
    }

    if (CFEqual(v76, (CFTypeRef)*MEMORY[0x189604DE8])) {
      *(_DWORD *)(a1 + 12716) = 6;
    }
  }

  unsigned int v77 = (const __CFNumber *)CFDictionaryGetValue(a2, @"zlibCompressionLevel");
  if (v77)
  {
    int v78 = v77;
    if (CFGetTypeID(v77) != v8)
    {
      size_t v66 = "kBOMCopierOptionZlibCompressionLevel is not a CFNumberRef";
      goto LABEL_269;
    }

    CFNumberGetValue(v78, kCFNumberSInt32Type, (void *)(a1 + 12792));
  }

  uint32_t v79 = (const __CFBoolean *)CFDictionaryGetValue(a2, @"sequesterResources");
  if (v79)
  {
    uint64_t v80 = v79;
    if (CFGetTypeID(v79) != v7)
    {
      size_t v66 = "kBOMCopierOptionSequesterResourcesKey is not a CFBooleanRef";
      goto LABEL_269;
    }

    unsigned __int8 v81 = BOMCFGetBoolValue(v80);
    *(_BYTE *)(a1 + 12768) = v81;
    *(_BYTE *)(a1 + 169) = v81;
  }

  uint64_t v82 = (const __CFBoolean *)CFDictionaryGetValue(a2, @"skipCPIOTerminator");
  if (v82)
  {
    uint64_t v83 = v82;
    if (CFGetTypeID(v82) != v7)
    {
      size_t v66 = "kBOMCopierOptionSkipCPIOTerminatorKey is not a CFBooleanRef";
      goto LABEL_269;
    }

    *(_BYTE *)(a1 + 12744) = BOMCFGetBoolValue(v83);
  }

  int v84 = (const __CFBoolean *)CFDictionaryGetValue(a2, @"skipCPIORoot");
  if (v84)
  {
    uint64_t v85 = v84;
    if (CFGetTypeID(v84) != v7)
    {
      size_t v66 = "kBOMCopierOptionSkipCPIORootKey is not a CFBooleanRef";
      goto LABEL_269;
    }

    *(_BYTE *)(a1 + 12745) = BOMCFGetBoolValue(v85);
  }

  int v86 = (const __CFNumber *)CFDictionaryGetValue(a2, @"initialCPIOInode");
  if (v86)
  {
    uint64_t v87 = v86;
    if (CFGetTypeID(v86) != v8)
    {
      size_t v66 = "kBOMCopierOptionInitialCPIOInodeRootKey is not a CFNumberRef";
      goto LABEL_269;
    }

    CFNumberGetValue(v87, kCFNumberSInt32Type, (void *)(a1 + 12960));
  }

  unsigned int v88 = (const __CFBoolean *)CFDictionaryGetValue(a2, @"keepParent");
  if (v88)
  {
    unint64_t v89 = v88;
    if (CFGetTypeID(v88) != v7)
    {
      size_t v66 = "kBOMCopierOptionKeepParentKey is not a CFBooleanRef";
      goto LABEL_269;
    }

    *(_BYTE *)(a1 + 193) = BOMCFGetBoolValue(v89);
  }

  uint64_t v90 = (const __CFBoolean *)CFDictionaryGetValue(a2, @"useFilesystemCache");
  if (v90)
  {
    unint64_t v91 = v90;
    if (CFGetTypeID(v90) != v7) {
      goto LABEL_186;
    }
    unsigned __int8 v92 = BOMCFGetBoolValue(v91);
    *(_BYTE *)(a1 + 12813) = v92;
    *(_BYTE *)(a1 + 12814) = v92;
  }

  int v93 = (const __CFDictionary *)CFDictionaryGetValue(a2, @"sourceOptions");
  if (v93)
  {
    uint64_t v94 = v93;
    if (CFGetTypeID(v93) != v5)
    {
      size_t v66 = "kBOMCopierOptionSourceOptionsDictionaryKey is not a CFDictionaryRef";
      goto LABEL_269;
    }

    uint64_t v95 = (const __CFBoolean *)CFDictionaryGetValue(v94, @"useFilesystemCache");
    if (v95)
    {
      uint64_t v96 = v95;
      if (CFGetTypeID(v95) != v7) {
        goto LABEL_186;
      }
      *(_BYTE *)(a1 + 12813) = BOMCFGetBoolValue(v96);
    }
  }

  uint64_t v97 = (const __CFDictionary *)CFDictionaryGetValue(a2, @"destinationOptions");
  if (!v97) {
    goto LABEL_154;
  }
  uint64_t v98 = v97;
  if (CFGetTypeID(v97) != v5)
  {
    size_t v66 = "kBOMCopierOptionDestinationOptionsDictionaryKey is not a CFDictionaryRef";
    goto LABEL_269;
  }

  size_t v99 = (const __CFBoolean *)CFDictionaryGetValue(v98, @"useFilesystemCache");
  if (!v99) {
    goto LABEL_154;
  }
  int v100 = v99;
  if (CFGetTypeID(v99) != v7)
  {
LABEL_186:
    size_t v66 = "kBOMCopierOptionUseFilesystemCacheKey is not a CFBooleanRef";
    goto LABEL_269;
  }

  *(_BYTE *)(a1 + 12814) = BOMCFGetBoolValue(v100);
LABEL_154:
  uint64_t v101 = CFDictionaryGetValue(a2, @"inputFD");
  if (v101)
  {
    size_t v102 = v101;
    if (CFGetTypeID(v101) != v8)
    {
      size_t v66 = "kBOMCopierOptionInputFileDescriptorKey is not a CFNumberRef";
      goto LABEL_269;
    }

    *(_DWORD *)(a1 + 12984) = BOMCFGetIntValue(v102);
  }

  unint64_t v103 = CFDictionaryGetValue(a2, @"outputFD");
  if (v103)
  {
    uint64_t v104 = v103;
    if (CFGetTypeID(v103) != v8)
    {
      size_t v66 = "kBOMCopierOptionOutputFileDescriptorKey is not a CFNumberRef";
      goto LABEL_269;
    }

    *(_DWORD *)(a1 + 12988) = BOMCFGetIntValue(v104);
  }

  unint64_t v105 = CFDictionaryGetValue(a2, @"inputStream");
  if (v105)
  {
    uint64_t v106 = v105;
    CFTypeID v107 = CFGetTypeID(v105);
    if (v107 != CFReadStreamGetTypeID())
    {
      size_t v66 = "kBOMCopierOptionInputCFReadStreamKey is not a CFReadStreamRef";
      goto LABEL_269;
    }

    *(void *)(a1 + 12944) = v106;
  }

  uint64_t v108 = CFDictionaryGetValue(a2, @"outputStream");
  if (v108)
  {
    uint64_t v109 = v108;
    CFTypeID v110 = CFGetTypeID(v108);
    if (v110 != CFWriteStreamGetTypeID())
    {
      size_t v66 = "kBOMCopierOptionOutputCFWriteStreamKey is not a CFWriteStreamRef";
      goto LABEL_269;
    }

    *(void *)(a1 + 12952) = v109;
  }

  v111 = CFDictionaryGetValue(a2, @"symlinkTreatment");
  if (v111)
  {
    uint64_t v112 = v111;
    if (CFGetTypeID(v111) != v6)
    {
      size_t v66 = "kBOMCopierOptionSymlinkTreatmentKey is not a CFStringRef";
      goto LABEL_269;
    }

    if (CFEqual(v112, @"unlink"))
    {
      int v113 = 0;
    }

    else if (CFEqual(v112, @"follow"))
    {
      int v113 = 1;
    }

    else
    {
      if (!CFEqual(v112, @"error"))
      {
        size_t v66 = "Unknown value for kBOMCopierOptionSymlinkTreatmentKey";
        goto LABEL_269;
      }

      int v113 = 2;
    }

    *(_DWORD *)(a1 + 12816) = v113;
  }

  int v114 = (const __CFBoolean *)CFDictionaryGetValue(a2, @"enforceDestinationEncapsulation");
  if (v114)
  {
    uint64_t v115 = v114;
    if (CFGetTypeID(v114) != v7)
    {
      size_t v66 = "kBOMCopierOptionEnforceDestinationEncapsulationKey is not a CFBooleanRef";
      goto LABEL_269;
    }

    *(_BYTE *)(a1 + 12820) = BOMCFGetBoolValue(v115);
  }

  uint64_t v116 = (const __CFBoolean *)CFDictionaryGetValue(a2, @"enforceDestinationLocation");
  if (v116)
  {
    uint64_t v117 = v116;
    if (CFGetTypeID(v116) != v7)
    {
      size_t v66 = "kBOMCopierOptionEnforceDestinationLocationKey is not a CFBooleanRef";
      goto LABEL_269;
    }

    *(_BYTE *)(a1 + 12821) = BOMCFGetBoolValue(v117);
  }

  int v118 = (const __CFString *)CFDictionaryGetValue(a2, @"zipFileEncryptionKey");
  if (v118)
  {
    uint64_t v119 = v118;
    if (CFGetTypeID(v118) != v6)
    {
      size_t v66 = "kBOMCopierOptionEncryptionKey is not a CFStringRef";
      goto LABEL_269;
    }

    unsigned int v120 = BOMCFStringGetUTF8String(v119);
    *(void *)(a1 + 12800) = v120;
    if (!v120)
    {
      size_t v66 = "Cannot convert kBOMCopierOptionEncryptionKey from options dictionary into UTF8 encoded C string";
      goto LABEL_269;
    }
  }

  uint64_t v121 = (const __CFBoolean *)CFDictionaryGetValue(a2, @"persistRestrictedFlags");
  if (v121)
  {
    int v122 = v121;
    if (CFGetTypeID(v121) != v7)
    {
      size_t v66 = "kBOMCopierOptionPersistRestrictedFlagsKey is not a CFBooleanRef";
      goto LABEL_269;
    }

    *(_BYTE *)(a1 + 12872) = BOMCFGetBoolValue(v122);
  }

  uint64_t v123 = (const __CFBoolean *)CFDictionaryGetValue(a2, @"preserveRestrictedFlags");
  if (v123)
  {
    uint64_t v124 = v123;
    if (CFGetTypeID(v123) != v7)
    {
      size_t v66 = "kBOMCopierOptionPreserveRestrictedFlagsKey is not a CFBooleanRef";
      goto LABEL_269;
    }

    *(_BYTE *)(a1 + 12873) = BOMCFGetBoolValue(v124);
  }

  int v125 = (const __CFBoolean *)CFDictionaryGetValue(a2, @"persistRootlessEAs");
  if (v125)
  {
    int v126 = v125;
    if (CFGetTypeID(v125) != v7)
    {
      size_t v66 = "kBOMCopierOptionPersistRootlessExtendedAttributesKey is not a CFBooleanRef";
      goto LABEL_269;
    }

    *(_BYTE *)(a1 + 12874) = BOMCFGetBoolValue(v126);
  }

  if (getenv("PRESERVECOMPRESSION")) {
    *(_BYTE *)(a1 + 195) = 1;
  }
  if (CFDictionaryContainsKey(a2, @"output2Nowhere") == 1)
  {
    size_t v66 = "The legacy engine does not support the nowhere destination";
  }

  else
  {
    __int128 v127 = (const __CFBoolean *)CFDictionaryGetValue(a2, @"cloneFiles");
    if (v127)
    {
      uint64_t v128 = v127;
      if (CFGetTypeID(v127) != v7)
      {
        size_t v66 = "kBOMCopierOptionCloneFilesKey is not a CFBooleanRef";
        goto LABEL_269;
      }

      *(_BYTE *)(a1 + 204) = BOMCFGetBoolValue(v128);
    }

    int v129 = (const __CFBoolean *)CFDictionaryGetValue(a2, @"removeSetuidPermissions");
    if (v129)
    {
      uint64_t v130 = v129;
      if (CFGetTypeID(v129) != v7)
      {
        size_t v66 = "kBOMCopierOptionRemoveSetuidPermissionsKey is not a CFBooleanRef";
        goto LABEL_269;
      }

      *(_BYTE *)(a1 + 205) = BOMCFGetBoolValue(v130);
    }

    uint64_t v131 = (const __CFBoolean *)CFDictionaryGetValue(a2, @"removeExecutablePermissions");
    if (v131)
    {
      v132 = v131;
      if (CFGetTypeID(v131) != v7)
      {
        size_t v66 = "kBOMCopierOptionRemoveExecutablePermissionsKey is not a CFBooleanRef";
        goto LABEL_269;
      }

      *(_BYTE *)(a1 + 206) = BOMCFGetBoolValue(v132);
    }

    int v133 = (const __CFBoolean *)CFDictionaryGetValue(a2, @"setStaticContent");
    if (v133)
    {
      int v134 = v133;
      if (CFGetTypeID(v133) != v7)
      {
        size_t v66 = "kBOMCopierOptionSetStaticContentKey is not a CFBooleanRef";
        goto LABEL_269;
      }

      *(_BYTE *)(a1 + 207) = BOMCFGetBoolValue(v134);
    }

    int v135 = (const __CFBoolean *)CFDictionaryGetValue(a2, @"setSingleWriter");
    if (v135)
    {
      uint64_t v136 = v135;
      if (CFGetTypeID(v135) != v7)
      {
        size_t v66 = "kBOMCopierOptionSetSingleWriterKey is not a CFBooleanRef";
        goto LABEL_269;
      }

      *(_BYTE *)(a1 + 208) = BOMCFGetBoolValue(v136);
    }

    int v137 = CFDictionaryGetValue(a2, @"setDataProtectionClass");
    if (v137)
    {
      int v138 = v137;
      if (CFGetTypeID(v137) != v6)
      {
        size_t v66 = "kBOMCopierOptionSetDataProtectionClassKey must be a CFStringRef";
        goto LABEL_269;
      }

      int v139 = CFEqual(v138, @"A");
      int v140 = 1;
      if (v139 != 1)
      {
        if (CFEqual(v138, @"B") == 1)
        {
          int v140 = 2;
        }

        else if (CFEqual(v138, @"C") == 1)
        {
          int v140 = 3;
        }

        else
        {
          if (CFEqual(v138, @"D") != 1)
          {
            size_t v66 = "Unsupported data protection class";
            goto LABEL_269;
          }

          int v140 = 4;
        }
      }

      *(_DWORD *)(a1 + 212) = v140;
      *(_BYTE *)(a1 + 211) = 1;
    }

    uint64_t result = (uint64_t)CFDictionaryGetValue(a2, @"applyProvenance");
    if (!result) {
      return result;
    }
    int v142 = (const __CFData *)result;
    if (CFGetTypeID((CFTypeRef)result) == v9)
    {
      size_t Length = CFDataGetLength(v142);
      if (Length)
      {
        size_t v144 = Length;
        int v145 = malloc(Length);
        if (v145)
        {
          int v146 = v145;
          BytePtr = CFDataGetBytePtr(v142);
          memcpy(v146, BytePtr, v144);
          uint64_t result = 0LL;
          *(void *)(a1 + 216) = v146;
          *(void *)(a1 + 224) = v144;
          return result;
        }

        size_t v66 = "Could not allocate provenance data buffer";
      }

      else
      {
        size_t v66 = "kBOMCopierOptionApplyProvenanceKey has an invalid size";
      }
    }

    else
    {
      size_t v66 = "kBOMCopierOptionApplyProvenanceKey must be a CFDataRef";
    }
  }

LABEL_269:
  BOMCopierNotifyFatalError(a1, v66, v11, v12, v13, v14, v15, v16, v148);
  return 1LL;
}

uint64_t _verifyCopierOptions( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(_BYTE *)(a1 + 12720) && *(_DWORD *)(a1 + 12712) != 1 && *(_DWORD *)(a1 + 12716) != 4)
  {
    uint64_t v11 = "Compression is only used for CPIO archives";
    goto LABEL_23;
  }

  if (*(_BYTE *)(a1 + 12744) && *(_DWORD *)(a1 + 12716) != 4)
  {
    uint64_t v11 = "SkipTerminator is only used for CPIO archives";
    goto LABEL_23;
  }

  if (*(_BYTE *)(a1 + 12745) && *(_DWORD *)(a1 + 12716) != 4)
  {
    uint64_t v11 = "SkipRoot is only used for CPIO archives";
    goto LABEL_23;
  }

  int v10 = *(_DWORD *)(a1 + 12712);
  if (v10 == 2 && *(_DWORD *)(a1 + 12716) != 3)
  {
    uint64_t v11 = "PKZip archives can only be extracted to filesystem destinations";
    goto LABEL_23;
  }

  if (*(_BYTE *)(a1 + 12768) && v10 != 2 && *(_DWORD *)(a1 + 12716) != 5)
  {
    uint64_t v11 = "sequesterResources is only for PKZip archives";
LABEL_23:
    BOMCopierNotifyFatalError(a1, v11, a3, a4, a5, a6, a7, a8, v21);
    return 1LL;
  }

  if ((*(_DWORD *)(a1 + 12792) - 10) <= 0xFFFFFFF4)
  {
    BOMCopierNotifyFatalError( a1,  "%d is out of range for Zlib compression",  a3,  a4,  a5,  a6,  a7,  a8,  *(_DWORD *)(a1 + 12792));
    return 1LL;
  }

  if (v10 == 3 || (int v12 = *(_DWORD *)(a1 + 12716), v12 == 6))
  {
    uint64_t v11 = "The legacy engine does not support AppleArchive";
    goto LABEL_23;
  }

  if (v12 == 3 && *(_BYTE *)(a1 + 193))
  {
    uint64_t v11 = "keepParent is only for archives";
    goto LABEL_23;
  }

  int v14 = *(_DWORD *)(a1 + 12984);
  if (a2 && v14 != -1)
  {
    uint64_t v11 = "Cannot specify a fromObj with kBOMCopierOptionInputFileDescriptorKey";
    goto LABEL_23;
  }

  if (a3 && *(_DWORD *)(a1 + 12988) != -1)
  {
    uint64_t v11 = "Cannot specify a toObj with kBOMCopierOptionOutputFileDescriptorKey";
    goto LABEL_23;
  }

  uint64_t v15 = *(__CFReadStream **)(a1 + 12944);
  if (v15)
  {
    if (!a2 && v14 == -1)
    {
      for (int i = 30; ; --i)
      {
        CFStreamStatus Status = CFReadStreamGetStatus(v15);
        if (Status != kCFStreamStatusOpening) {
          break;
        }
        if (!i)
        {
          uint64_t v11 = "Timed out waiting for the read stream to open";
          goto LABEL_23;
        }

        timespec __rqtp = (timespec)xmmword_18635AD90;
        nanosleep(&__rqtp, 0LL);
        uint64_t v15 = *(__CFReadStream **)(a1 + 12944);
      }

      if (Status == kCFStreamStatusOpen) {
        goto LABEL_43;
      }
      BOMCopierNotifyFatalError(a1, "CFReadStream is not open: %u", a3, a4, a5, a6, a7, a8, Status);
      return 1LL;
    }

    uint64_t v11 = "Cannot specify fromObj or kBOMCopierOptionInputFileDescriptorKey with kBOMCopierOptionInputCFReadStreamKey";
    goto LABEL_23;
  }

LABEL_43:
  uint64_t v18 = *(__CFWriteStream **)(a1 + 12952);
  if (v18)
  {
    if (!a3 && *(_DWORD *)(a1 + 12988) == -1)
    {
      for (int j = 30; ; --j)
      {
        CFStreamStatus v20 = CFWriteStreamGetStatus(v18);
        if (v20 != kCFStreamStatusOpening) {
          break;
        }
        if (!j)
        {
          uint64_t v11 = "Timed out waiting for the write stream to open";
          goto LABEL_23;
        }

        timespec __rqtp = (timespec)xmmword_18635AD90;
        nanosleep(&__rqtp, 0LL);
        uint64_t v18 = *(__CFWriteStream **)(a1 + 12952);
      }

      if (v20 == kCFStreamStatusOpen) {
        goto LABEL_54;
      }
      BOMCopierNotifyFatalError(a1, "CFWriteStream is not open: %u", a3, a4, a5, a6, a7, a8, v20);
      return 1LL;
    }

    uint64_t v11 = "Cannot specify toObj or kBOMCopierOptionOutputFileDescriptorKey with kBOMCopierOptionOutputCFWriteStreamKey";
    goto LABEL_23;
  }

LABEL_54:
  if (*(_BYTE *)(a1 + 204) == 1)
  {
    if (*(_DWORD *)(a1 + 12712))
    {
      uint64_t v11 = "kBOMCopierOptionCloneFiles requires the source to be a filesystem";
      goto LABEL_23;
    }

    if (*(_DWORD *)(a1 + 12716) != 3)
    {
      uint64_t v11 = "kBOMCopierOptionCloneFiles requires the destination to be a filesystem";
      goto LABEL_23;
    }
  }

  if (*(_BYTE *)(a1 + 207) == 1 && *(_DWORD *)(a1 + 12716) != 3)
  {
    uint64_t v11 = "setStaticContent is only for filesystem destinations";
    goto LABEL_23;
  }

  if (*(_BYTE *)(a1 + 208) == 1 && *(_DWORD *)(a1 + 12716) != 3)
  {
    uint64_t v11 = "setSingleWriter is only for filesystem destinations";
    goto LABEL_23;
  }

  if (*(void *)(a1 + 216))
  {
    if (!*(_DWORD *)(a1 + 12712))
    {
      uint64_t v11 = "applyProvenance is only for extracting from archives";
      goto LABEL_23;
    }

    if (*(_DWORD *)(a1 + 12716) != 3)
    {
      uint64_t v11 = "applyProvenance is only applicable when extracting from archives";
      goto LABEL_23;
    }
  }

  return 0LL;
}

uint64_t _prepareCopierState(uint64_t a1)
{
  uint64_t v2 = *(char **)(a1 + 12896);
  if (v2)
  {
    uint64_t v3 = BOMBomOpenWithSys(v2, 0, *(void **)(a1 + 12832));
    *(void *)(a1 + 152) = v3;
    if (!v3)
    {
      uint64_t v33 = *(void *)(a1 + 12896);
LABEL_27:
      char v54 = v33;
      int v12 = "Cannot open BOM at '%s'";
      goto LABEL_28;
    }
  }

  char v56 = 0LL;
  int v10 = *(const __CFArray **)(a1 + 12880);
  if (v10)
  {
    uint64_t v11 = _parse_arch_list(a1, v10, *(const __CFDictionary **)(a1 + 12888), (_DWORD *)(a1 + 144), &v56);
    *(void *)(a1 + 136) = v11;
    if (!v11)
    {
      int v12 = "Could not parse the Mach-O architectures to copy";
LABEL_28:
      BOMCopierNotifyFatalError(a1, v12, v4, v5, v6, v7, v8, v9, v54);
      return 1LL;
    }
  }

  else if (!*(void *)(a1 + 136))
  {
    goto LABEL_10;
  }

  uint64_t v13 = *(uint64_t **)(a1 + 152);
  if (v13)
  {
    int v14 = BOMBomNewFromBomWithOptions(0LL, v13, 1, (const char **)v56, 0LL);
    if (!v14)
    {
      BOMCopierNotifyFatalError(a1, "Cannot thin the index bom", v15, v16, v17, v18, v19, v20, v54);
      if (v56)
      {
        int v34 = *(void **)v56;
        if (*(void *)v56)
        {
          uint64_t v35 = 8LL;
          do
          {
            free(v34);
            int v34 = *(void **)((char *)v56 + v35);
            v35 += 8LL;
          }

          while (v34);
        }
      }

      return 1LL;
    }

    char v21 = v14;
    BOMBomFree(*(void *)(a1 + 152));
    *(void *)(a1 + 152) = v21;
  }

uint64_t _prepareCopierDestination( uint64_t a1, char *__s1, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v10 = *(_DWORD *)(a1 + 12716);
  if (v10 != 3)
  {
    uint64_t v45 = 0LL;
    int v19 = *(_DWORD *)(a1 + 12964);
    *(_DWORD *)(a1 + 12992) = v19;
    if (!*(_BYTE *)(a1 + 12814))
    {
      v19 |= 0x10u;
      *(_DWORD *)(a1 + 12992) = v19;
    }

    if (v10 == 4)
    {
      uint64_t v20 = getenv("BOM_ASYNC");
      if (v20)
      {
        if (strcmp("0", v20))
        {
          v19 |= 0x20u;
          *(_DWORD *)(a1 + 12992) = v19;
        }
      }
    }

    if (__s1)
    {
      if (!strcmp(__s1, "-"))
      {
        if (BOMFileOpenSTDOUT(&v45, v19))
        {
          CFTypeID v26 = __error();
          uint64_t v23 = *(void (**)(uint64_t, const char *, uint64_t))(a1 + 64);
          if (!v23) {
            return 1LL;
          }
          uint64_t v24 = *v26;
          uint64_t v27 = a1;
          uint64_t v25 = 0LL;
LABEL_34:
          v23(v27, v25, v24);
          return 1LL;
        }
      }

      else
      {
        if (_mkdirs_parent(a1))
        {
          LOBYTE(v44) = (_BYTE)__s1;
LABEL_16:
          BOMCopierNotifyFatalError(a1, "Cannot create parent directory for %s", v13, v14, v15, v16, v17, v18, v44);
          return 1LL;
        }

        if (BOMFileOpenWithSys( &v45,  (uint64_t)__s1,  1537LL,  420LL,  *(_DWORD *)(a1 + 12992),  *(void (***)(void, uint64_t, uint64_t, uint64_t))(a1 + 12832)))
        {
          uint64_t v28 = __error();
          uint64_t v23 = *(void (**)(uint64_t, const char *, uint64_t))(a1 + 64);
          if (!v23) {
            return 1LL;
          }
          uint64_t v24 = *v28;
          uint64_t v27 = a1;
          uint64_t v25 = __s1;
          goto LABEL_34;
        }
      }

uint64_t _BOMCopierCopyFromFilesystem(uint64_t a1, const char *a2, const char *a3)
{
  uint64_t v72 = *MEMORY[0x1895F89C0];
  __int128 v63 = 0uLL;
  __int128 v62 = 0uLL;
  char v61 = 0;
  if (!a2 || !*a2 || *(_DWORD *)(a1 + 12716) == 3 && (!a3 || !*a3)) {
    return 1LL;
  }
  *(_BYTE *)(a1 + 168) = 0;
  *(_BYTE *)(a1 + 11616) = 0;
  *(_BYTE *)(a1 + 12641) = 0;
  uint64_t v6 = *(void *)(a1 + 152);
  if (v6)
  {
    unsigned int v13 = BOMBomPathIDForKey(v6, 0, ".");
    if (!v13)
    {
      uint64_t v14 = "Can't find . in bom file";
LABEL_12:
      BOMCopierNotifyFatalError(a1, v14, v7, v8, v9, v10, v11, v12, v60);
      return 1LL;
    }
  }

  else
  {
    unsigned int v13 = 0;
  }

  if (strlen(a2) >= 0x3FF)
  {
    char v60 = (char)a2;
    uint64_t v14 = "source path ('%s') too long [%lu >= %lu]!";
    goto LABEL_12;
  }

  __strlcpy_chk();
  if ((*(uint64_t (**)(void, char *, uint64_t))(*(void *)(a1 + 12832) + 160LL))( *(void *)(*(void *)(a1 + 12832) + 8LL),  __s,  a1 + 248) != a1 + 248) {
    goto LABEL_14;
  }
  if ((*(unsigned int (**)(void, uint64_t, int *))(*(void *)(a1 + 12832) + 96LL))( *(void *)(*(void *)(a1 + 12832) + 8LL),  a1 + 248,  &v65))
  {
LABEL_18:
    uint64_t v20 = __error();
    uint64_t v16 = *(void (**)(uint64_t, char *, uint64_t))(a1 + 64);
    if (!v16) {
      return 1LL;
    }
    uint64_t v17 = *v20;
    uint64_t v19 = a1;
    uint64_t v18 = (char *)(a1 + 248);
LABEL_20:
    v16(v19, v18, v17);
    return 1LL;
  }

  int v22 = v66 & 0xF000;
  memset(v64, 0, sizeof(v64));
  if (*(_DWORD *)(a1 + 12716) == 3)
  {
    if (strlen(a3) >= 0x3FF)
    {
      BOMCopierNotifyFatalError( a1,  "destination path ('%s') too long [%lu >= %lu]!",  v23,  v24,  v25,  v26,  v27,  v28,  (char)a3);
      return 1LL;
    }

    __strlcpy_chk();
    int v31 = (*(uint64_t (**)(void, char *, _OWORD *))(*(void *)(a1 + 12832) + 80LL))( *(void *)(*(void *)(a1 + 12832) + 8LL),  __s,  v64);
    int v30 = *__error();
    if (v31 && v30 != 2 && v30 != 63) {
      goto LABEL_14;
    }
    if (v31) {
      BOOL v32 = v22 == 0x4000;
    }
    else {
      BOOL v32 = (WORD2(v64[0]) & 0xF000) == 0x4000;
    }
    if (!v31 && v22 != 0x4000 && v32)
    {
      strrchr((const char *)(a1 + 248), 47);
      __strlcat_chk();
      __strlcat_chk();
      int v31 = (*(uint64_t (**)(void, char *, _OWORD *))(*(void *)(a1 + 12832) + 80LL))( *(void *)(*(void *)(a1 + 12832) + 8LL),  __s,  v64);
      if (v31) {
        BOOL v32 = v22 == 0x4000;
      }
      else {
        BOOL v32 = (WORD2(v64[0]) & 0xF000) == 0x4000;
      }
    }

    if (v22 == 0x4000 && !v31 && !v32)
    {
      BOMCopierNotifyFatalError(a1, "Can't copy directory %s into a file %s.", v37, v38, v39, v40, v41, v42, a1 - 8);
      return 1LL;
    }

    if (!v31 && v67 == *((void *)&v64[0] + 1) && v65 == LODWORD(v64[0]))
    {
      BOMCopierNotifyFatalError(a1, "%s and %s are identical (not copied).", v37, v38, v39, v40, v41, v42, a1 - 8);
      return 1LL;
    }

    __strlcpy_chk();
  }

  else
  {
    uint64_t v29 = "<unknown>";
    if (a3) {
      uint64_t v29 = a3;
    }
    snprintf((char *)(a1 + 3328), 0x400uLL, "%s:", v29);
    int v30 = 0;
    int v31 = -1;
    BOOL v32 = 1;
  }

  if (v22 == 0x4000)
  {
    *(_BYTE *)(a1 + 2304) = 0;
    *(_BYTE *)(a1 + 6400) = 0;
  }

  else
  {
    _extractFileAndPath((char *)(a1 + 248), (char *)(a1 + 2304));
    if ((*(unsigned int (**)(void, uint64_t, int *))(*(void *)(a1 + 12832) + 80LL))( *(void *)(*(void *)(a1 + 12832) + 8LL),  a1 + 248,  &v65))
    {
      goto LABEL_18;
    }

    if (v32)
    {
      __strlcpy_chk();
    }

    else
    {
      _extractFileAndPath((char *)(a1 + 3328), (char *)(a1 + 6400));
      int v31 = (*(uint64_t (**)(void, uint64_t, _OWORD *))(*(void *)(a1 + 12832) + 80LL))( *(void *)(*(void *)(a1 + 12832) + 8LL),  a1 + 3328,  v64);
      int v30 = *__error();
    }
  }

  if (!*(_BYTE *)(a1 + 193))
  {
    size_t v43 = strlen((const char *)(a1 + 248));
    if (v43 != 1 || strcmp("/", (const char *)(a1 + 248)))
    {
      __strlcat_chk();
      uint64_t v36 = v43 + 1;
      goto LABEL_66;
    }

    __strlcat_chk();
LABEL_65:
    uint64_t v36 = 1LL;
    goto LABEL_66;
  }

  __strlcpy_chk();
  uint64_t v33 = strrchr(__s, 47);
  if (!v33) {
    goto LABEL_67;
  }
  uint64_t v34 = v33;
  if (v33 == __s)
  {
    __strlcpy_chk();
    goto LABEL_65;
  }

  char *v33 = 0;
  size_t v35 = strlen(__s);
  snprintf((char *)(a1 + 248), 0x400uLL, "%s/./%s", __s, v34 + 1);
  uint64_t v36 = v35 + 1;
LABEL_66:
  *(void *)(a1 + 2296) = a1 + v36 + 248;
LABEL_67:
  *(_DWORD *)(a1 + 232) = v65;
  *(_BYTE *)(a1 + 210) = (v70.f_flags & 8) == 0;
  int v44 = *(_DWORD *)(a1 + 12716);
  switch(v44)
  {
    case 5:
      if (!BOMPKZipWriteLocalHeader(*(void *)(a1 + 12760), ".", (uint64_t)&v65, 0, 0)
        && (v22 != 0x4000
         || !*(_BYTE *)(a1 + 193)
         || !BOMPKZipWriteLocalHeader(*(void *)(a1 + 12760), *(char **)(a1 + 2296), (uint64_t)&v65, 0, 0)))
      {
LABEL_84:
        uint64_t v46 = 0LL;
        int v45 = 0;
        goto LABEL_86;
      }

LABEL_112:
      uint64_t v58 = __error();
      uint64_t v16 = *(void (**)(uint64_t, char *, uint64_t))(a1 + 64);
      if (!v16) {
        return 1LL;
      }
      uint64_t v17 = *v58;
      uint64_t v18 = (char *)(a1 + 3328);
LABEL_16:
      uint64_t v19 = a1;
      goto LABEL_20;
    case 4:
      if (*(_BYTE *)(a1 + 12745)) {
        goto LABEL_84;
      }
      if (*(_BYTE *)(a1 + 12746)) {
        _applyIndexBomOwnershipForTargetArchive(a1, ".", (uint64_t)&v65);
      }
      if (!BOMCPIOWriteDirectory(*(void *)(a1 + 12736), ".", (uint64_t)&v65)
        && (v22 != 0x4000
         || !*(_BYTE *)(a1 + 193)
         || !BOMCPIOWriteDirectory(*(void *)(a1 + 12736), *(char **)(a1 + 2296), (uint64_t)&v65)))
      {
        goto LABEL_84;
      }

      goto LABEL_112;
    case 3:
      *(_DWORD *)(a1 + 236) = v64[0];
      *(void *)(a1 + 240) = *((void *)&v64[0] + 1);
      __strlcpy_chk();
      if (v31)
      {
        *__error() = v30;
        if (*__error() != 2 && *__error() != 63) {
          goto LABEL_14;
        }
        int v45 = 0;
      }

      else
      {
        if ((WORD2(v64[0]) & 0xF000) != 0x4000)
        {
          uint64_t v16 = *(void (**)(uint64_t, char *, uint64_t))(a1 + 64);
          if (!v16) {
            return 1LL;
          }
          uint64_t v18 = __s;
          uint64_t v19 = a1;
          uint64_t v17 = 20LL;
          goto LABEL_20;
        }

        int v45 = 1;
        if (!*(_BYTE *)(a1 + 12822))
        {
          uint64_t v46 = 0LL;
          goto LABEL_105;
        }
      }

      uint64_t v46 = v66;
      if ((*(unsigned int (**)(void, char *, _OWORD *))(*(void *)(a1 + 12832) + 96LL))( *(void *)(*(void *)(a1 + 12832) + 8LL),  __s,  v64))
      {
        goto LABEL_14;
      }

      __int128 v62 = v69;
      __int128 v63 = v68;
LABEL_105:
      if ((*(uint64_t (**)(void, char *, uint64_t))(*(void *)(a1 + 12832) + 160LL))( *(void *)(*(void *)(a1 + 12832) + 8LL),  __s,  a1 + 3328) == a1 + 3328)
      {
        _initializeAFSCData(a1);
        if (statfs((const char *)(a1 + 3328), &v70))
        {
          unint64_t v57 = __error();
          uint64_t v16 = *(void (**)(uint64_t, char *, uint64_t))(a1 + 64);
          if (!v16) {
            return 1LL;
          }
          uint64_t v17 = *v57;
          uint64_t v19 = a1;
          uint64_t v18 = (char *)(a1 + 3328);
          goto LABEL_20;
        }

        *(_BYTE *)(a1 + 209) = (v70.f_flags & 8) == 0;
        if (*(_BYTE *)(a1 + 211) == 1) {
          *(_BYTE *)(a1 + 211) = volume_has_data_protection((const char *)(a1 + 3328));
        }
        goto LABEL_86;
      }

          if (__str == 45)
          {
            --v29;
            *v6++ = __str;
            p_str = v77;
          }

          else
          {
            p_str = &__str;
          }

          __int128 v62 = (v29 - 1);
          if (v29 >= 1)
          {
            __int128 v63 = 0LL;
            char v64 = v29 - 1;
            int v65 = v6;
            while (1)
            {
              *v65++ = p_str[v63];
              if ((_DWORD)v62 != (_DWORD)v63 && !(v64 % 3)) {
                break;
              }
              if ((_DWORD)v62 == (_DWORD)v63)
              {
                unsigned __int16 v66 = 9;
                goto LABEL_122;
              }

uint64_t _BOMCopierCopyFromCPIO( uint64_t a1, uint64_t a2, char *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10 = (_BYTE *)(a1 + 12721);
  uint64_t v25 = 0LL;
  if (*(_DWORD *)(a1 + 12716) == 3)
  {
    if (!a3)
    {
      BOMCopierNotifyFatalError(a1, "dstPath is NULL", 0LL, a4, a5, a6, a7, a8, v23[0]);
      goto LABEL_17;
    }

    if (*(_BYTE *)(a1 + 12821) && _enforceDestinationLocation(a1, a3))
    {
      BOMFileClose(a2);
LABEL_17:
      uint64_t v20 = 1LL;
      goto LABEL_18;
    }

    if (v10[99])
    {
    }

    else
    {
      __strlcpy_chk();
    }

    if ((*(unsigned int (**)(void, uint64_t, _OWORD *))(*(void *)(a1 + 12832) + 80LL))( *(void *)(*(void *)(a1 + 12832) + 8LL),  a1 + 3328,  v23))
    {
      if (*__error() != 2 && *__error() != 63
        || _mkdirs(a1, a1 + 3328)
        || (*(unsigned int (**)(void, uint64_t, _OWORD *))(*(void *)(a1 + 12832) + 96LL))( *(void *)(*(void *)(a1 + 12832) + 8LL),  a1 + 3328,  v23))
      {
        int v22 = __error();
        uint64_t v16 = *(void (**)(uint64_t, const char *, uint64_t))(a1 + 64);
        if (!v16) {
          goto LABEL_17;
        }
        uint64_t v17 = *v22;
        uint64_t v19 = a1;
        uint64_t v18 = a3;
        goto LABEL_10;
      }

      int v12 = 0;
    }

    else
    {
      int v12 = 1;
    }

    _initializeAFSCData(a1);
  }

  else
  {
    __strlcpy_chk();
    int v12 = 0;
    memset(v23, 0, sizeof(v23));
  }

  size_t v13 = strlen((const char *)(a1 + 3328));
  uint64_t v14 = (_BYTE *)(a1 + 3328 + (int)v13);
  *uint64_t v14 = 47;
  if (BOMCPIONew(&v25, a2, 1, 0))
  {
    BOMFileClose(a2);
    uint64_t v15 = __error();
    uint64_t v16 = *(void (**)(uint64_t, const char *, uint64_t))(a1 + 64);
    if (!v16) {
      goto LABEL_17;
    }
    uint64_t v17 = *v15;
    uint64_t v18 = "";
    uint64_t v19 = a1;
LABEL_10:
    v16(v19, v18, v17);
    goto LABEL_17;
  }

  *(_BYTE *)(a1 + 248) = 0;
  *(void *)(a1 + 2296) = a1 + 248;
  *(void *)(a1 + 12728) = v25;
  *uint64_t v10 = 1;
  uint64_t v20 = _copyFromCPIO( a1,  (uint64_t)v24,  (uint64_t)v23,  v14 + 1,  ((uint64_t)(0x40000000000LL - (v13 << 32)) >> 32) - 1,  v12);
  if (!(_DWORD)v20) {
    uint64_t v20 = _restoreSymlinks(a1, 0);
  }
LABEL_18:
  if (v10[102]) {
    _restoreSymlinks(a1, 1);
  }
  if (v25) {
    BOMCPIOFree(v25);
  }
  return v20;
}

uint64_t _BOMCopierCopyFromPKZip( uint64_t a1, uint64_t a2, char *__s, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v111 = *MEMORY[0x1895F89C0];
  uint64_t v109 = 0LL;
  uint64_t v108 = 0LL;
  if (*(_DWORD *)(a1 + 12716) != 3)
  {
    uint64_t v17 = 0xFFFFFFFFLL;
    goto LABEL_8;
  }

  if (!__s)
  {
    BOMCopierNotifyFatalError(a1, "dstPath is NULL", 0LL, a4, a5, a6, a7, a8, v99);
    goto LABEL_7;
  }

  if (strlen(__s) >= 0x3FF)
  {
    BOMCopierNotifyFatalError(a1, "Filename('%s') too long [%lu >= %lu]!", v11, v12, v13, v14, v15, v16, (char)__s);
LABEL_7:
    uint64_t v17 = 1LL;
    goto LABEL_8;
  }

  if (*(_BYTE *)(a1 + 12821) && _enforceDestinationLocation(a1, __s))
  {
    BOMFileClose(a2);
    goto LABEL_7;
  }

  if (*(_BYTE *)(a1 + 12820))
  {
  }

  else
  {
    __strlcpy_chk();
  }

  if ((*(unsigned int (**)(void, uint64_t, _BYTE *))(*(void *)(a1 + 12832) + 80LL))( *(void *)(*(void *)(a1 + 12832) + 8LL),  a1 + 3328,  v105)
    && (*__error() != 2 && *__error() != 63 || _mkdirs(a1, a1 + 3328)))
  {
    uint64_t v19 = __error();
    uint64_t v20 = *(void (**)(uint64_t, const char *, uint64_t))(a1 + 64);
    if (!v20) {
      goto LABEL_7;
    }
    uint64_t v21 = *v19;
    uint64_t v22 = a1;
    uint64_t v23 = __s;
LABEL_28:
    v20(v22, v23, v21);
    goto LABEL_7;
  }

  _initializeAFSCData(a1);
  int v24 = strlen((const char *)(a1 + 3328));
  uint64_t v25 = (_BYTE *)(a1 + 3328 + v24);
  _BYTE *v25 = 47;
  uint64_t v26 = v25 + 1;
  if (BOMPKZipNew(&v109, a2, 1))
  {
    BOMFileClose(a2);
    uint64_t v27 = __error();
    uint64_t v20 = *(void (**)(uint64_t, const char *, uint64_t))(a1 + 64);
    if (!v20) {
      goto LABEL_7;
    }
    uint64_t v21 = *v27;
    uint64_t v23 = "Could not create a BOMPKZip object";
    goto LABEL_27;
  }

  *(_BYTE *)(a1 + 248) = 0;
  *(void *)(a1 + 2296) = a1 + 248;
  uint64_t v28 = v109;
  *(void *)(a1 + 12752) = v109;
  *(_BYTE *)(a1 + 12721) = 1;
  if (*(_DWORD *)(a1 + 12716) == 3 && *(_BYTE *)(a1 + 12768))
  {
    int v29 = strlen((const char *)(a1 + 3328));
    *(_DWORD *)(a1 + 12780) = v29 + 8;
    int v30 = (char *)BOM_malloc((v29 + 9));
    *(void *)(a1 + 12784) = v30;
    if (!v30)
    {
      uint64_t v73 = __error();
      uint64_t v20 = *(void (**)(uint64_t, const char *, uint64_t))(a1 + 64);
      if (!v20) {
        goto LABEL_7;
      }
      uint64_t v21 = *v73;
      uint64_t v23 = "";
LABEL_27:
      uint64_t v22 = a1;
      goto LABEL_28;
    }

    snprintf(v30, (*(_DWORD *)(a1 + 12780) + 1), "%s%s", (const char *)(a1 + 3328), "__MACOSX");
    uint64_t v28 = v109;
  }

  BOMPKZipLoadCentralDirectory((uint64_t)v28);
  uint64_t v17 = _copyFromPKZip(a1, (uint64_t)v106, (uint64_t)v105, v26, 1024 - v24 - 1LL);
  int v31 = *(void **)(a1 + 12784);
  if (v31)
  {
    free(v31);
    *(void *)(a1 + 12784) = 0LL;
    *(_DWORD *)(a1 + 12780) = 0;
  }

  if (!(_DWORD)v17)
  {
    int NumLocalHeaders = BOMPKZipGetNumLocalHeaders(*(void *)(a1 + 12752));
    if (NumLocalHeaders)
    {
      int v39 = NumLocalHeaders;
      uint64_t v40 = (const char *)(a1 + 249);
      uint64_t v41 = (const char *)(a1 + 250);
      do
      {
        if (*(_DWORD *)(a1 + 12772) != 2)
        {
          uint64_t v72 = "Not a central directory signature";
          goto LABEL_109;
        }

        if (BOMPKZipReadCentralHeader(*(int ***)(a1 + 12752), (char *)(a1 + 248), (uint64_t)v106, &v108))
        {
          uint64_t v72 = "Couldn't read pkzip central header";
          goto LABEL_109;
        }

        int v42 = *(char *)(a1 + 248);
        if (v42 == 46)
        {
          if (*v40 == 47) {
            size_t v43 = v41;
          }
          else {
            size_t v43 = (const char *)(a1 + 248);
          }
        }

        else
        {
          size_t v43 = (const char *)(a1 + 248);
          if (v42 == 47) {
            size_t v43 = v40;
          }
        }

        snprintf((char *)(a1 + 7424), 0x400uLL, "%s/%s", __s, v43);
        __int16 v44 = v107;
        if ((v107 & 0x1FF) == 0)
        {
          if ((v107 & 0xF000) == 0x4000)
          {
            __int16 v45 = 493;
          }

          else
          {
            if ((v107 & 0xF000) != 0x8000) {
              goto LABEL_52;
            }
            __int16 v45 = 420;
          }

          __int16 v44 = v107 | v45;
          v107 |= v45;
        }

LABEL_110:
    uint64_t v17 = 0LL;
  }

uint64_t _finalizeCopierDestination( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  switch(*(_DWORD *)(a1 + 12716))
  {
    case 3:
      uint64_t v9 = *(const void **)(a1 + 12856);
      if (v9)
      {
        CFRelease(v9);
        *(void *)(a1 + 12856) = 0LL;
      }

      if (!*(void *)(a1 + 12864)) {
        goto LABEL_8;
      }
      int v10 = FinishStreamCompressorQueue();
      if (v10)
      {
        BOMCopierNotifyFatalError( a1,  "Could not finish the HFS FinishStreamCompressorQueue error (%d)",  v11,  v12,  v13,  v14,  v15,  v16,  v10);
        goto LABEL_14;
      }

      uint64_t v17 = 0LL;
      *(void *)(a1 + 12864) = 0LL;
      break;
    case 4:
      if (*(_BYTE *)(a1 + 12744)) {
        goto LABEL_8;
      }
      uint64_t v17 = BOMCPIOWriteTerminator(*(uint64_t **)(a1 + 12736));
      if ((_DWORD)v17) {
        BOMCopierNotifyFatalError( a1,  "Cannot write the terminator for the CPIO archive",  v26,  v27,  v28,  v29,  v30,  v31,  v33);
      }
      break;
    case 5:
      uint64_t v17 = BOMPKZipWriteCentralDirectory(*(void *)(a1 + 12760));
      if ((_DWORD)v17)
      {
        int NumLocalHeaders = BOMPKZipGetNumLocalHeaders(*(void *)(a1 + 12760));
        uint64_t v25 = "Could not write the central directory for";
        if (!NumLocalHeaders) {
          uint64_t v25 = "No files for";
        }
        BOMCopierNotifyFatalError(a1, "%s PKZip archive", v19, v20, v21, v22, v23, v24, (char)v25);
      }

      break;
    case 6:
      BOMCopierNotifyFatalError(a1, "The legacy engine does not support AppleArchive", a3, a4, a5, a6, a7, a8, v33);
LABEL_14:
      uint64_t v17 = 1LL;
      break;
    default:
LABEL_8:
      uint64_t v17 = 0LL;
      break;
  }

  return v17;
}

uint64_t BOMCopierRedirectPath(uint64_t a1, int a2, char *__s)
{
  if (!__s) {
    return 1LL;
  }
  size_t v5 = strlen(__s);
  uint64_t v6 = 1LL;
  if (v5 <= 0x3FF)
  {
    memmove((void *)(a1 + 10592), __s, v5 + 1);
    *(_BYTE *)(a1 + 11616) = 1;
    return 0LL;
  }

  return v6;
}

uint64_t BOMCopierRedirectSourcePath(uint64_t a1, int a2, char *__s)
{
  if (!__s) {
    return 1LL;
  }
  size_t v5 = strlen(__s);
  uint64_t v6 = 1LL;
  if (v5 <= 0x3FF)
  {
    memmove((void *)(a1 + 11617), __s, v5 + 1);
    *(_BYTE *)(a1 + 12641) = 1;
    return 0LL;
  }

  return v6;
}

uint64_t BOMCopierCancelCopy(uint64_t result)
{
  if (result) {
    *(_BYTE *)(result + 168) = 1;
  }
  return result;
}

uint64_t BOMCopierCountFilesInArchive( uint64_t a1, char *__s, void *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  keys[1] = *(void **)MEMORY[0x1895F89C0];
  if (!__s)
  {
    BOMCopierNotifyFatalError(a1, "BOMCopierCountFilesInArchive: missing path", (uint64_t)a3, a4, a5, a6, a7, a8, v72);
    return 22LL;
  }

  size_t v12 = strlen(__s);
  if (v12 >= 0x400)
  {
    BOMCopierNotifyFatalError( a1,  "BOMCopierCountFilesInArchive: maximum path length exceeded: %ld",  v13,  v14,  v15,  v16,  v17,  v18,  v12);
    return 22LL;
  }

  values = (void *)*MEMORY[0x189604DE8];
  keys[0] = @"extractLibarchive";
  uint64_t v20 = CFDictionaryCreate( (CFAllocatorRef)*MEMORY[0x189604DB0],  (const void **)keys,  (const void **)&values,  1LL,  MEMORY[0x189605240],  MEMORY[0x189605250]);
  if (!v20)
  {
    BOMCopierNotifyFatalError(a1, "Could not create empty BOMCopierSource options", v21, v22, v23, v24, v25, v26, v72);
    _resetCopier(a1);
    return 1LL;
  }

  uint64_t v27 = v20;
  int v74 = 0LL;
  uint64_t v28 = BOMCopierSourceNew(__s, v20, 0LL, &v74);
  if (!v28)
  {
    uint64_t Code = BOMCopierErrorGetCode((uint64_t)v74);
    BOMCopierErrorGetMessage((uint64_t)v74);
    BOMCopierNotifyFatalError( a1,  "Could not create BOMCopierSource from %s: %s",  v59,  v60,  v61,  v62,  v63,  v64,  (char)__s);
    CFRelease(v27);
    BOMCopierErrorFree(v74);
    return Code;
  }

  uint64_t v29 = (void *)v28;
  uint64_t v73 = (void *)a4;
  CFRelease(v27);
  uint64_t v36 = BOMCopierSourceNext((uint64_t)v29, &v74, v30, v31, v32, v33, v34, v35);
  if (v36)
  {
    uint64_t v37 = v36;
    uint64_t v38 = 0LL;
    uint64_t v39 = 0LL;
    while (1)
    {
      int Type = BOMCopierSourceEntryGetType((uint64_t)v37);
      if (Type == 9)
      {
        uint64_t SymlinkTarget = (const char *)BOMCopierSourceEntryGetSymlinkTarget((uint64_t)v37);
        if (!SymlinkTarget) {
          goto LABEL_16;
        }
        size_t Size = strlen(SymlinkTarget);
      }

      else
      {
        if (!Type)
        {
          BOMCopierNotifyFatalError(a1, "Unknown BOMCopierSourceEntry", v41, v42, v43, v44, v45, v46, v72);
          BOMCopierSourceEntryFree((unsigned int *)v37);
          BOMCopierSourceFree(v29);
          return 1LL;
        }

        size_t Size = BOMCopierSourceEntryGetSize((uint64_t)v37);
      }

      v39 += Size;
LABEL_16:
      if (a1 && *(void *)(a1 + 88))
      {
        uint64_t Path = BOMCopierSourceEntryGetPath((uint64_t)v37);
        __int16 Mode = BOMCopierSourceEntryGetMode((uint64_t)v37);
        uint64_t v51 = BOMCopierSourceEntryGetSize((uint64_t)v37);
        uint64_t v52 = BOMFSObjectTypeForMode(Mode);
        (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(a1 + 88))(a1, Path, v52, v51);
      }

      BOMCopierSourceEntryFree((unsigned int *)v37);
      uint64_t v37 = BOMCopierSourceNext((uint64_t)v29, &v74, v53, v54, v55, v56, v57, v58);
      ++v38;
      if (!v37) {
        goto LABEL_24;
      }
    }
  }

  uint64_t v39 = 0LL;
  uint64_t v38 = 0LL;
LABEL_24:
  BOMCopierSourceFree(v29);
  if (v74)
  {
    BOMCopierErrorGetMessage((uint64_t)v74);
    BOMCopierNotifyFatalError(a1, "Could not enumerate %s: %s", v65, v66, v67, v68, v69, v70, (char)__s);
    BOMCopierErrorFree(v74);
    return 1LL;
  }

  if (a3) {
    *a3 = v38;
  }
  uint64_t Code = 0LL;
  if (v73) {
    *uint64_t v73 = v39;
  }
  return Code;
}

uint64_t BOMCopierCountFilesInDirectory( uint64_t a1, char *__s, const __CFDictionary *a3, void *a4, void *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    return 1LL;
  }
  if (!__s)
  {
    BOMCopierNotifyFatalError(a1, "missing path parameter", (uint64_t)a3, (uint64_t)a4, (uint64_t)a5, a6, a7, a8, v86);
    return 1LL;
  }

  size_t v13 = strlen(__s);
  if (v13 >= 0x400)
  {
    BOMCopierNotifyFatalError(a1, "maximum path length exceeded: %ld", v14, v15, v16, v17, v18, v19, v13);
    return 1LL;
  }

  if (a3)
  {
    if (_parseCopierOptions(a1, a3))
    {
      uint64_t v26 = "Could not parse the options dictionary";
LABEL_49:
      BOMCopierNotifyFatalError(a1, v26, v20, v21, v22, v23, v24, v25, v86);
      goto LABEL_50;
    }

    if (_verifyCopierOptions(a1, 0LL, 0LL, v21, v22, v23, v24, v25))
    {
      uint64_t v26 = "Could not verify the copier options";
      goto LABEL_49;
    }

    if (_prepareCopierState(a1))
    {
LABEL_50:
      _resetCopier(a1);
      return 1LL;
    }
  }

  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable( (CFAllocatorRef)*MEMORY[0x189604DB0],  0LL,  MEMORY[0x189605240],  MEMORY[0x189605250]);
  if (!Mutable)
  {
    uint64_t v26 = "Could not create empty BOMCopierSource options";
    goto LABEL_49;
  }

  uint64_t v28 = Mutable;
  uint64_t v29 = (const void **)MEMORY[0x189604DE8];
  if (*(_BYTE *)(a1 + 169) == 1) {
    CFDictionarySetValue(Mutable, @"synthesizeResourceForks", (const void *)*MEMORY[0x189604DE8]);
  }
  if (*(_BYTE *)(a1 + 192) == 1) {
    CFDictionarySetValue(v28, @"crossDevices", *v29);
  }
  *(_OWORD *)int v90 = 0u;
  __int128 v91 = 0u;
  __int128 v89 = 0u;
  int v88 = 0LL;
  if (*(void *)(a1 + 136)
    && (CFDictionarySetValue(v28, @"discoverBinaries", *v29),
        BOMCopierPrepareMatchContext(a3, (uint64_t)&v89, &v88))
    || (uint64_t v30 = BOMCopierSourceNew(__s, v28, 0LL, &v88)) == 0)
  {
    BOMCopierErrorGetMessage((uint64_t)v88);
    BOMCopierNotifyFatalError( a1,  "Could not create BOMCopierSource from %s: %s",  v63,  v64,  v65,  v66,  v67,  v68,  (char)__s);
    CFRelease(v28);
    BOMCopierErrorFree(v88);
    return 1LL;
  }

  uint64_t v31 = (void *)v30;
  CFRelease(v28);
  if (*(void *)(a1 + 120))
  {
    *(void *)(a1 + 12680) = 1LL;
    *(_DWORD *)(a1 + 12688) = 0;
    gettimeofday(&v87, 0LL);
    __darwin_time_t v38 = *(void *)(a1 + 12680) + v87.tv_sec;
    *(void *)(a1 + 12696) = v38;
    int v39 = *(_DWORD *)(a1 + 12688) + v87.tv_usec;
    *(_DWORD *)(a1 + 12704) = v39;
    if (v39 > 999999)
    {
      *(void *)(a1 + 12696) = v38 + 1;
      *(_DWORD *)(a1 + 12704) = v39 - 1000000;
    }
  }

  if (a4) {
    *a4 = 0LL;
  }
  if (a5) {
    *a5 = 0LL;
  }
  uint64_t v40 = BOMCopierSourceNext((uint64_t)v31, 0LL, v32, v33, v34, v35, v36, v37);
  if (v40)
  {
    uint64_t v41 = v40;
    uint64_t v42 = 0LL;
    uint64_t v43 = 0LL;
    while (1)
    {
      switch(BOMCopierSourceEntryGetType((uint64_t)v41))
      {
        case 0u:
          BOMCopierNotifyFatalError(a1, "Unknown BOMCopierSourceEntry", v44, v45, v46, v47, v48, v49, v86);
          BOMCopierSourceEntryFree((unsigned int *)v41);
          BOMCopierSourceFree(v31);
          return 1LL;
        case 4u:
        case 5u:
        case 6u:
        case 7u:
        case 9u:
        case 0xBu:
          ++v42;
          goto LABEL_31;
        case 8u:
          if (BOMCopierSourceEntryGetBinaryType((uint64_t)v41))
          {
            uint64_t matched = BOMCopierMatchBinary((uint64_t)v41, (unsigned int *)&v89, &v88);
            if ((_DWORD)matched)
            {
              uint64_t v69 = matched;
              Message = (const char *)BOMCopierErrorGetMessage((uint64_t)v88);
              BOMCopierNotifyFatalError(a1, Message, v80, v81, v82, v83, v84, v85, v86);
              BOMCopierErrorFree(v88);
              BOMCopierSourceEntryFree((unsigned int *)v41);
              BOMCopierSourceFree(v31);
              return v69;
            }

            uint64_t Size = *((void *)&v91 + 1);
            if (v90[1]) {
              free(v90[1]);
            }
          }

          else
          {
            uint64_t Size = BOMCopierSourceEntryGetSize((uint64_t)v41);
          }

          v43 += Size;
          v42 += !BOMCopierSourceEntryIsResourceFork(v41);
LABEL_31:
          BOMCopierSourceEntryFree((unsigned int *)v41);
          if (!*(void *)(a1 + 120)) {
            goto LABEL_39;
          }
          gettimeofday(&v87, 0LL);
          __darwin_time_t tv_sec = v87.tv_sec;
          __darwin_time_t v57 = *(void *)(a1 + 12696);
          if (v87.tv_sec == v57)
          {
            __darwin_suseconds_t tv_usec = v87.tv_usec;
            if (v87.tv_usec >= *(_DWORD *)(a1 + 12704)) {
              goto LABEL_37;
            }
          }

          else if (v87.tv_sec >= v57)
          {
            __darwin_suseconds_t tv_usec = v87.tv_usec;
LABEL_37:
            (*(void (**)(uint64_t, uint64_t, uint64_t))(a1 + 120))(a1, v42, v43);
            __darwin_time_t v59 = *(void *)(a1 + 12680) + tv_sec;
            *(void *)(a1 + 12696) = v59;
            int v60 = *(_DWORD *)(a1 + 12688) + tv_usec;
            *(_DWORD *)(a1 + 12704) = v60;
            if (v60 > 999999)
            {
              *(void *)(a1 + 12696) = v59 + 1;
              *(_DWORD *)(a1 + 12704) = v60 - 1000000;
            }
          }

uint64_t BOMCopierSetUserData(uint64_t result, uint64_t a2)
{
  if (result) {
    *(void *)(result + 48) = a2;
  }
  return result;
}

uint64_t BOMCopierUserData(uint64_t result)
{
  if (result) {
    return *(void *)(result + 48);
  }
  return result;
}

uint64_t BOMCopierSetFatalErrorHandler(uint64_t result, uint64_t a2)
{
  if (result) {
    *(void *)(result + 56) = a2;
  }
  return result;
}

uint64_t BOMCopierSetFatalFileErrorHandler(uint64_t result, uint64_t a2)
{
  if (result) {
    *(void *)(result + 64) = a2;
  }
  return result;
}

uint64_t BOMCopierSetFileErrorHandler(uint64_t result, uint64_t a2)
{
  if (result) {
    *(void *)(result + 72) = a2;
  }
  return result;
}

uint64_t BOMCopierSetFileConflictErrorHandler(uint64_t result, uint64_t a2)
{
  if (result) {
    *(void *)(result + 80) = a2;
  }
  return result;
}

uint64_t BOMCopierSetCopyFileStartedHandler(uint64_t result, uint64_t a2)
{
  if (result) {
    *(void *)(result + 88) = a2;
  }
  return result;
}

uint64_t BOMCopierSetCopyFileFinishedHandler(uint64_t result, uint64_t a2)
{
  if (result) {
    *(void *)(result + 96) = a2;
  }
  return result;
}

uint64_t BOMCopierSetCopyFileUpdateHandler(uint64_t result, uint64_t a2)
{
  if (result) {
    *(void *)(result + 104) = a2;
  }
  return result;
}

uint64_t BOMCopierSetCountFilesUpdateHandler(uint64_t result, uint64_t a2)
{
  if (result) {
    *(void *)(result + 120) = a2;
  }
  return result;
}

uint64_t BOMCopierSetPKZipPasswordRequester(uint64_t result, uint64_t a2)
{
  if (result) {
    *(void *)(result + 128) = a2;
  }
  return result;
}

uint64_t BOMCopierGetArchiveFileDescriptor(uint64_t a1)
{
  if (a1)
  {
    int v1 = *(_DWORD *)(a1 + 12712);
    if (v1 == 2)
    {
      uint64_t v4 = *(void *)(a1 + 12752);
      if (v4)
      {
        uint64_t File = BOMPKZipGetFile(v4);
        return BOMFileGetFileDescriptor(File);
      }
    }

    else if (v1 == 1)
    {
      uint64_t v2 = *(void *)(a1 + 12728);
      if (v2)
      {
        uint64_t File = BOMCPIOGetFile(v2);
        return BOMFileGetFileDescriptor(File);
      }
    }
  }

  return 0xFFFFFFFFLL;
}

size_t _extractFileAndPath(char *a1, char *a2)
{
  uint64_t v4 = strrchr(a1, 47);
  if (v4)
  {
    *uint64_t v4 = 0;
    size_t result = strlcpy(a2, v4 + 1, 0x400uLL);
    if (*a1) {
      return result;
    }
    __int16 v6 = 47;
  }

  else
  {
    size_t result = strlcpy(a2, a1, 0x400uLL);
    __int16 v6 = 46;
  }

  *(_WORD *)a1 = v6;
  return result;
}

uint64_t _initializeAFSCData(uint64_t a1)
{
  uint64_t result = __strlcpy_chk();
  if (!*(_BYTE *)(a1 + 195)) {
    goto LABEL_7;
  }
  if (*(_DWORD *)(a1 + 12712) || (uint64_t result = VolumeSupportsCompression(), (result & 1) == 0))
  {
    *(_BYTE *)(a1 + 195) = 0;
    goto LABEL_7;
  }

  if (!*(_BYTE *)(a1 + 195))
  {
LABEL_7:
    if (!*(_BYTE *)(a1 + 12848)) {
      return result;
    }
  }

  if (*(_DWORD *)(a1 + 12716) == 3 && (uint64_t result = VolumeSupportsCompression(), (_DWORD)result))
  {
    if (*(_BYTE *)(a1 + 12848))
    {
      if (!*(void *)(a1 + 12864))
      {
        uint64_t result = CreateStreamCompressorQueueWithOptions();
        *(void *)(a1 + 12864) = result;
      }
    }
  }

  else
  {
    *(_BYTE *)(a1 + 195) = 0;
    *(_BYTE *)(a1 + 12848) = 0;
  }

  return result;
}

void _applyIndexBomOwnershipForTargetArchive(uint64_t a1, char *a2, uint64_t a3)
{
  uint64_t v3 = *(void *)(a1 + 152);
  if (v3)
  {
    uint64_t FSObjectAtPath = BOMBomGetFSObjectAtPath(v3, a2);
    if (FSObjectAtPath)
    {
      uint64_t v6 = FSObjectAtPath;
      *(_DWORD *)(a3 + 16) = BOMFSObjectUserID(FSObjectAtPath);
      *(_DWORD *)(a3 + 20) = BOMFSObjectGroupID(v6);
      BOMFSObjectFree(v6);
    }
  }

uint64_t _copyFromDirToDir( uint64_t a1, _DWORD *a2, _BYTE *a3, uint64_t a4, _BYTE *a5, uint64_t a6, unsigned int a7)
{
  uint64_t v80 = *MEMORY[0x1895F89C0];
  unsigned __int8 v78 = 0;
  *a3 = 47;
  *a5 = 47;
  a3[1] = 0;
  size_t v13 = a3 + 1;
  uint64_t v76 = 0LL;
  a5[1] = 0;
  uint64_t v14 = a5 + 1;
  if (*(_BYTE *)(a1 + 192) == 1)
  {
    if (*(_DWORD *)(a1 + 232) == *a2) {
      goto LABEL_11;
    }
    if (!statfs((const char *)(a1 + 248), &v79))
    {
      *(_BYTE *)(a1 + 210) = (v79.f_flags & 8) == 0;
      goto LABEL_11;
    }

    uint64_t v15 = __error();
    uint64_t v16 = *(void (**)(uint64_t, uint64_t, void))(a1 + 64);
    if (v16) {
      v16(a1, a1 + 248, *v15);
    }
    return 0LL;
  }

  if (!*(_BYTE *)(a1 + 192) && *(_DWORD *)(a1 + 232) != *a2) {
    return 0LL;
  }
LABEL_11:
  uint64_t v18 = (*(uint64_t (**)(void, uint64_t))(*(void *)(a1 + 12832) + 272LL))( *(void *)(*(void *)(a1 + 12832) + 8LL),  a1 + 248);
  if (!v18)
  {
    *a5 = 0;
    *a3 = 0;
    __error();
    return _checkCopyFileError(a1);
  }

  uint64_t v19 = v18;
  unsigned int v69 = a7;
  uint64_t v64 = a5;
  uint64_t v65 = a3;
  unint64_t v20 = a6 - 1;
  size_t v21 = a4 - 1;
  size_t __size = a6 - 1;
  unint64_t v66 = v20;
  int v22 = (*(uint64_t (**)(void, uint64_t, statfs *, uint64_t *))(*(void *)(a1 + 12832) + 296LL))( *(void *)(*(void *)(a1 + 12832) + 8LL),  v18,  &v79,  &v76);
  BOOL v23 = v22 == 0;
  uint64_t v24 = v76;
  if (v22) {
    BOOL v25 = 1;
  }
  else {
    BOOL v25 = v76 == 0;
  }
  if (v25)
  {
    uint64_t v17 = 0LL;
    uint64_t v70 = 0LL;
    uint64_t v29 = 0LL;
LABEL_20:
    (*(void (**)(void, uint64_t))(*(void *)(a1 + 12832) + 280LL))( *(void *)(*(void *)(a1 + 12832) + 8LL),  v19);
    if (v23)
    {
      if (!(_DWORD)v17)
      {
        if (v70 && v29)
        {
          uint64_t v26 = v70;
          for (uint64_t i = v29; i; --i)
          {
            unsigned int v77 = 0;
            if (*v26)
            {
              if (*(_BYTE *)(a1 + 168)) {
                goto LABEL_34;
              }
              if ((unint64_t)v26[1] + 1 > v66
                || (strlcpy(v14, (const char *)*v26, __size),
                    strncpy(v13, (const char *)*v26, v21),
                    (*(unsigned int (**)(void, uint64_t, _BYTE *))(*(void *)(a1 + 12832) + 96LL))( *(void *)(*(void *)(a1 + 12832) + 8LL),  a1 + 248,  v74)))
              {
                __error();
              }

              else if (_checkForDestinationConflict( a1,  (char *)(a1 + 3328),  (uint64_t)v74,  (uint64_t)v73,  &v78,  &v77) != 1 && _copyFile(a1, (uint64_t)v74, (uint64_t)v73, v78, *(_DWORD **)(a1 + 136), &v77, 0) == 2)
              {
LABEL_34:
                uint64_t v19 = 0LL;
                goto LABEL_35;
              }
            }

            v26 += 2;
          }
        }

        uint64_t v19 = 0LL;
        uint64_t v17 = 0LL;
        *uint64_t v64 = 0;
        *uint64_t v65 = 0;
LABEL_104:
        uint64_t v28 = v70;
        if (v70) {
          goto LABEL_105;
        }
        goto LABEL_109;
      }
    }

    else
    {
      uint64_t v17 = _checkCopyFileError(a1);
    }

    uint64_t v19 = 0LL;
    goto LABEL_104;
  }

  uint64_t v29 = 0LL;
  uint64_t v70 = 0LL;
  uint64_t v17 = 0LL;
  unsigned int v68 = 0;
  uint64_t v63 = 0LL;
  while (1)
  {
    unsigned int v77 = 0;
    if (*(_BYTE *)(a1 + 168)) {
      goto LABEL_102;
    }
    uint64_t v30 = *(void *)(a1 + 152);
    if (v30)
    {
      unsigned int v68 = BOMBomPathIDForKey(v30, v69, (char *)(v76 + 21));
      if (!v68)
      {
        unsigned int v68 = 0;
        goto LABEL_63;
      }
    }

    uint64_t v31 = *(void *)(a1 + 160);
    if (v31) {
      BOOL v32 = BOMBomFSObjectExistsAtPath(v31, *(void *)(a1 + 2296));
    }
    else {
      BOOL v32 = 0;
    }
    if ((*(unsigned int (**)(void, uint64_t, _BYTE *))(*(void *)(a1 + 12832) + 96LL))( *(void *)(*(void *)(a1 + 12832) + 8LL),  a1 + 248,  v74))
    {
      __error();
      uint64_t v33 = a1;
      goto LABEL_61;
    }

    if (*(_BYTE *)(a1 + 12746) && *(_DWORD *)(a1 + 12716) == 4) {
      _applyIndexBomOwnershipForTargetArchive(a1, *(char **)(a1 + 2296), (uint64_t)v74);
    }
    if (*(unsigned __int16 *)(v76 + 18) > 0xF9u)
    {
      BOOL v62 = v32;
      uint64_t v72 = 0LL;
      __int128 v71 = xmmword_18635AD6C;
      uint64_t v35 = (unsigned int *)BOM_malloczero(0x30CuLL);
      if ((*(unsigned int (**)(void, uint64_t, __int128 *, unsigned int *, uint64_t, uint64_t))(*(void *)(a1 + 12832) + 120LL))( *(void *)(*(void *)(a1 + 12832) + 8LL),  a1 + 248,  &v71,  v35,  780LL,  1LL))
      {
        free(v35);
        __error();
        uint64_t v17 = _checkCopyFileError(a1);
        goto LABEL_63;
      }

      unint64_t v36 = v35[2];
      if (v66 < v36)
      {
        free(v35);
LABEL_60:
        uint64_t v33 = a1;
LABEL_61:
        uint64_t v17 = 0LL;
        goto LABEL_63;
      }

      __source = (char *)v35 + (int)v35[1] + 4;
      strlcpy(v14, __source, __size);
      strlcpy(v13, __source, v21);
      free(v35);
      uint64_t v34 = v36 - 1;
      BOOL v32 = v62;
    }

    else
    {
      if (strlcpy(v14, (const char *)(v76 + 21), __size) >= __size)
      {
        uint64_t v33 = a1;
        goto LABEL_61;
      }

      uint64_t v34 = *(unsigned __int16 *)(v76 + 18);
    }

    uint64_t v38 = _checkForDestinationConflict(a1, (char *)(a1 + 3328), (uint64_t)v74, (uint64_t)v73, &v78, &v77);
    if (v77 != 1) {
      break;
    }
    if ((_DWORD)v38 == 1)
    {
      uint64_t v17 = v38;
    }

    else if ((_DWORD)v38)
    {
LABEL_102:
      uint64_t v17 = 2LL;
      goto LABEL_104;
    }

uint64_t _copyFromFileToDir( uint64_t a1, uint64_t a2, _BYTE *a3, uint64_t a4, _BYTE *a5, uint64_t a6, unsigned int a7, int a8)
{
  v27[0] = 0;
  *a3 = 47;
  unsigned int v26 = 0;
  *a5 = 47;
  uint64_t v15 = a5 + 1;
  uint64_t v16 = (_BYTE *)(a1 + 2304);
  uint64_t v17 = *(void *)(a1 + 152);
  if (v17)
  {
  }

  uint64_t v18 = *(void *)(a1 + 160);
  if (v18)
  {
    if (BOMBomFSObjectExistsAtPath(v18, *(void *)(a1 + 2296))) {
      return 1LL;
    }
  }

  if ((*(unsigned int (**)(void, uint64_t, _BYTE *))(*(void *)(a1 + 12832) + 96LL))( *(void *)(*(void *)(a1 + 12832) + 8LL),  a1 + 248,  v24))
  {
LABEL_7:
    __error();
    return _checkCopyFileError(a1);
  }

  size_t v20 = a6 - 1;
  if (*(_BYTE *)(a1 + 12746) && *(_DWORD *)(a1 + 12716) == 4) {
    _applyIndexBomOwnershipForTargetArchive(a1, *(char **)(a1 + 2296), (uint64_t)v24);
  }
  size_t v21 = (const char *)(*(_BYTE *)(a1 + 6400) ? a1 + 6400 : a1 + 2304);
  if (strlcpy(v15, v21, v20) >= v20) {
    return 1LL;
  }
  if (a8)
  {
    uint64_t result = _checkForDestinationConflict(a1, (char *)(a1 + 3328), (uint64_t)v24, (uint64_t)v23, v27, &v26);
    if (v26 == 1) {
      return result;
    }
  }

  else
  {
    v27[0] = 0;
    uint64_t result = 1LL;
  }

  HIDWORD(v22) = v25 & 0xF000;
  LODWORD(v22) = HIDWORD(v22) - 0x2000;
  switch((v22 >> 13))
  {
    case 0u:
    case 2u:
      uint64_t result = _copyDevice(a1, (uint64_t)v24);
      break;
    case 3u:
      uint64_t result = _copyFile(a1, (uint64_t)v24, (uint64_t)v23, v27[0], *(_DWORD **)(a1 + 136), &v26, 0);
      break;
    case 4u:
      uint64_t result = _copyLink(a1, (uint64_t)v24, (uint64_t)v23, v27[0]);
      break;
    default:
      break;
  }

  if (!(_DWORD)result)
  {
    *a5 = 0;
    *a3 = 0;
    *uint64_t v16 = 0;
    if (!a8)
    {
      if (*(_DWORD *)(a1 + 12716) == 3)
      {
        uint64_t result = set_timestamps_0((const char *)(a1 + 3328), (__int128 *)(a2 + 32), (_OWORD *)(a2 + 48));
        if ((_DWORD)result) {
          goto LABEL_7;
        }
      }

      else
      {
        return 0LL;
      }
    }
  }

  return result;
}

uint64_t _copyExtendedAttributes(uint64_t a1, uint64_t a2, uint64_t a3, int a4, _DWORD *a5)
{
  int v10 = *(_DWORD *)(a1 + 12716);
  if (v10 != 3)
  {
    uint64_t v11 = (char *)(a1 + 7424);
    if (*(_BYTE *)(a1 + 11616)) {
      size_t v12 = (const char *)(a1 + 10592);
    }
    else {
      size_t v12 = *(const char **)(a1 + 2296);
    }
    strncpy(v11, v12, 0x400uLL);
  }

  if (a5)
  {
    if (v10 == 3 && *a5 == 2) {
      return 0LL;
    }
  }

  if ((*(_DWORD *)(a3 + 116) & 0x40000020) == 0x20 && *(_BYTE *)(a1 + 195))
  {
    if (*(_BYTE *)(a1 + 196)) {
      uint64_t v14 = 1LL;
    }
    else {
      uint64_t v14 = 33LL;
    }
  }

  else
  {
    uint64_t v14 = 1LL;
  }

  size_t v15 = (*(uint64_t (**)(void, uint64_t, void, void, uint64_t))(*(void *)(a1 + 12832) + 144LL))( *(void *)(*(void *)(a1 + 12832) + 8LL),  a2,  0LL,  0LL,  v14);
  if (v15 == -1LL) {
    goto LABEL_48;
  }
  size_t v16 = v15;
  if (!v15)
  {
    if (a5)
    {
      uint64_t v17 = 0LL;
      *a5 = 1;
      return v17;
    }

    return 0LL;
  }

  uint64_t v19 = (char *)BOM_malloc(v15);
  if (!v19
    || (size_t v20 = v19,
        uint64_t v21 = (*(uint64_t (**)(void, uint64_t, char *, size_t, uint64_t))(*(void *)(a1 + 12832) + 144LL))( *(void *)(*(void *)(a1 + 12832) + 8LL),  a2,  v19,  v16,  v14),  v21 == -1))
  {
LABEL_48:
    __error();
    return _checkCopyFileError(a1);
  }

  if (v21 < 1)
  {
    unint64_t v22 = 0LL;
LABEL_50:
    uint64_t v17 = 0LL;
    if (a5)
    {
      *a5 = 0;
      if (!v22) {
        goto LABEL_56;
      }
    }

    else
    {
LABEL_54:
      if (!v22) {
        goto LABEL_56;
      }
    }

LABEL_55:
    free(v22);
    goto LABEL_56;
  }

  unint64_t v22 = 0LL;
  BOOL v23 = &v20[v21];
  uint64_t v24 = 3328LL;
  if (a4) {
    uint64_t v24 = 7424LL;
  }
  uint64_t v34 = v20;
  uint64_t v35 = a1 + v24;
  __int16 v25 = v20;
  uint64_t v33 = &v20[v21];
  while (1)
  {
    if (!strcmp(v25, "com.apple.FinderInfo") || !strcmp(v25, "com.apple.ResourceFork"))
    {
      if (!*(_BYTE *)(a1 + 169)) {
        goto LABEL_46;
      }
    }

    else if (!*(_BYTE *)(a1 + 170))
    {
      goto LABEL_46;
    }

    uint64_t v26 = (*(uint64_t (**)(void, uint64_t, const char *, void, void, void, uint64_t))(*(void *)(a1 + 12832) + 128LL))( *(void *)(*(void *)(a1 + 12832) + 8LL),  a2,  v25,  0LL,  0LL,  0LL,  v14);
    if (v26 == -1) {
      break;
    }
    uint64_t v27 = v26;
    if (!v22)
    {
      unint64_t v22 = BOM_malloc(0x800000uLL);
      if (!v22)
      {
        __error();
        uint64_t v17 = _checkCopyFileError(a1);
        goto LABEL_56;
      }
    }

    if (v27)
    {
      uint64_t v28 = 0LL;
      uint64_t v29 = 0LL;
      while (1)
      {
        uint64_t v30 = (unint64_t)(v27 - v29) >= 0x800000 ? 0x800000LL : v27 - v29;
        uint64_t v31 = (*(uint64_t (**)(void, uint64_t, const char *, void *, uint64_t, uint64_t, uint64_t))(*(void *)(a1 + 12832) + 128LL))( *(void *)(*(void *)(a1 + 12832) + 8LL),  a2,  v25,  v22,  v30,  v28,  v14);
        if (v31 == -1) {
          break;
        }
        uint64_t v32 = v31;
        if ((*(unsigned int (**)(void, uint64_t, const char *, void *, uint64_t, uint64_t, uint64_t))(*(void *)(a1 + 12832) + 136LL))( *(void *)(*(void *)(a1 + 12832) + 8LL),  v35,  v25,  v22,  v31,  v28,  1LL) == -1) {
          break;
        }
        v29 += v32;
        uint64_t v28 = (v28 + v32);
        if (v29 == v27)
        {
          BOOL v23 = v33;
          size_t v20 = v34;
          goto LABEL_46;
        }
      }

      __error();
      uint64_t v17 = _checkCopyFileError(a1);
      size_t v20 = v34;
      goto LABEL_54;
    }

LABEL_46:
    v25 += strlen(v25) + 1;
    if (v25 >= v23) {
      goto LABEL_50;
    }
  }

  __error();
  uint64_t v17 = _checkCopyFileError(a1);
  if (v22) {
    goto LABEL_55;
  }
LABEL_56:
  free(v20);
  return v17;
}

  if ((*((_BYTE *)a1 + 1) & 1) == 0)
  {
    if (!v5)
    {
      BOOL v23 = __error();
      uint64_t v24 = strerror(*v23);
      uint64_t v11 = 22LL;
      BOMCopierErrorCapture( a2,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDataAnalyzer.c",  699,  (uint64_t)"init_data_analyzer",  "No method enabled",  v24);
      return v11;
    }

    return 0LL;
  }

  __int16 v25 = (CC_SHA512_CTX *)a1[11];
  if (v25 || (__int16 v25 = (CC_SHA512_CTX *)calloc(1uLL, 0xD0uLL), (a1[11] = (uint64_t)v25) != 0))
  {
    CC_SHA512_Init(v25);
    if (a1[17]) {
      return 0LL;
    }
    uint64_t v26 = malloc(0x40uLL);
    a1[17] = (uint64_t)v26;
    if (v26) {
      return 0LL;
    }
    uint64_t v49 = *__error();
    uint64_t v50 = __error();
    strerror(*v50);
    BOMCopierErrorCapture( a2,  v49,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDataAnalyzer.c",  689,  (uint64_t)"init_data_analyzer",  "Could not allocate SHA512 digest: %s");
  }

  else
  {
    unint64_t v47 = *__error();
    uint64_t v48 = __error();
    strerror(*v48);
    BOMCopierErrorCapture( a2,  v47,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDataAnalyzer.c",  677,  (uint64_t)"init_data_analyzer",  "Could not allocate SHA512 context: %s");
  }

  return 1LL;
}

uint64_t _copyACLs(uint64_t a1, char *path_p, int a3, int a4, _DWORD *a5)
{
  acl_entry_t v21 = 0LL;
  acl_entry_t entry_p = 0LL;
  acl_t acl_p = 0LL;
  if (*(_DWORD *)(a1 + 12716) != 3) {
    return 0LL;
  }
  if (a4)
  {
    acl_t link_np = acl_get_link_np(path_p, ACL_TYPE_EXTENDED);
    if (link_np)
    {
      int v10 = link_np;
      uint64_t v11 = acl_get_link_np((const char *)(a1 + 3328), ACL_TYPE_EXTENDED);
      goto LABEL_8;
    }

LABEL_34:
  __error();
  uint64_t v12 = _checkCopyFileError(a1);
LABEL_35:
  acl_free(v10);
LABEL_36:
  if (acl_p) {
    acl_free(acl_p);
  }
  return v12;
}

  uint64_t v27 = CFDictionaryGetValue(a2, @"extractPKZip");
  if (v27)
  {
    uint64_t v28 = v27;
    if (TypeID != CFGetTypeID(v27))
    {
      uint64_t v24 = 22LL;
      BOMCopierErrorCapture( a3,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c",  1274,  (uint64_t)"parse_copier_options",  "kBOMCopierOptionExtractPKZipKey must be a CFBooleanRef");
      return v24;
    }

    uint64_t v29 = (const void *)*MEMORY[0x189604DE8];
    if (CFEqual(v28, (CFTypeRef)*MEMORY[0x189604DE8]) == 1)
    {
      if (*(_DWORD *)(a1 + 12712))
      {
        uint64_t v24 = 22LL;
        BOMCopierErrorCapture( a3,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c",  1282,  (uint64_t)"parse_copier_options",  "The source type has already been assigned to %d");
        return v24;
      }

      *(_DWORD *)(a1 + 12712) = 2;
      CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13008), @"extractDataArchive", v29);
      CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13008), @"enforceArchiveEntryPermissions", v29);
    }
  }

  uint64_t v30 = CFDictionaryGetValue(a2, @"createPKZip");
  if (v30)
  {
    uint64_t v31 = v30;
    if (TypeID != CFGetTypeID(v30))
    {
      uint64_t v24 = 22LL;
      BOMCopierErrorCapture( a3,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c",  1328,  (uint64_t)"parse_copier_options",  "kBOMCopierOptionExtractPKZipKey must be a CFBooleanRef");
      return v24;
    }

    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13024), @"createArchive", v31);
    if (CFEqual(v31, (CFTypeRef)*MEMORY[0x189604DE8]) == 1)
    {
      if (*(_DWORD *)(a1 + 12716) != 3)
      {
        uint64_t v24 = 22LL;
        BOMCopierErrorCapture( a3,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c",  1338,  (uint64_t)"parse_copier_options",  "The destination type has already been assigned to %d");
        return v24;
      }

      *(_DWORD *)(a1 + 12716) = 5;
      CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13008), @"excludeRootDirectory", v31);
      *(_DWORD *)unsigned int valuePtr = 327680;
      uint64_t v32 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x189604DB0], kCFNumberIntType, valuePtr);
      if (!v32)
      {
        uint64_t v24 = 1LL;
        BOMCopierErrorCapture( a3,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c",  1359,  (uint64_t)"parse_copier_options",  "Could not create CFNumber from %d");
        return v24;
      }

      uint64_t v33 = v32;
      CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13024), @"libarchiveFormat", v32);
      CFRelease(v33);
    }
  }

  uint64_t v34 = CFDictionaryGetValue(a2, @"createAppleArchive");
  if (v34)
  {
    uint64_t v35 = v34;
    if (TypeID != CFGetTypeID(v34))
    {
      uint64_t v24 = 22LL;
      BOMCopierErrorCapture( a3,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c",  1377,  (uint64_t)"parse_copier_options",  "kBOMCopierOptionCreateAppleArchiveKey must be a CFBooleanRef");
      return v24;
    }

    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13024), @"createAppleArchive", v35);
    if (CFEqual(v35, (CFTypeRef)*MEMORY[0x189604DE8]) == 1)
    {
      if (*(_DWORD *)(a1 + 12716) != 3)
      {
        uint64_t v24 = 22LL;
        BOMCopierErrorCapture( a3,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c",  1387,  (uint64_t)"parse_copier_options",  "The destination type has already been assigned to %d");
        return v24;
      }

      *(_DWORD *)(a1 + 12716) = 6;
    }
  }

  unint64_t v36 = CFDictionaryGetValue(a2, @"compressAppleArchive");
  if (v36)
  {
    uint64_t v37 = v36;
    if (v7 != CFGetTypeID(v36))
    {
      uint64_t v24 = 22LL;
      BOMCopierErrorCapture( a3,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c",  1400,  (uint64_t)"parse_copier_options",  "kBOMCopierOptionCompressAppleArchiveKey must be a CFStringRef");
      return v24;
    }

    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13024), @"compressAppleArchive", v37);
  }

  uint64_t v38 = CFDictionaryGetValue(a2, @"extractAppleArchive");
  if (v38)
  {
    int v39 = v38;
    if (TypeID != CFGetTypeID(v38))
    {
      uint64_t v24 = 22LL;
      BOMCopierErrorCapture( a3,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c",  1412,  (uint64_t)"parse_copier_options",  "kBOMCopierOptionExtractAppleArchiveKey must be a CFBooleanRef");
      return v24;
    }

    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13008), @"extractAppleArchive", v39);
    if (CFEqual(v39, (CFTypeRef)*MEMORY[0x189604DE8]) == 1)
    {
      if (*(_DWORD *)(a1 + 12712))
      {
        uint64_t v24 = 22LL;
        BOMCopierErrorCapture( a3,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c",  1422,  (uint64_t)"parse_copier_options",  "The source type has already been assigned to %d");
        return v24;
      }

      *(_DWORD *)(a1 + 12712) = 3;
    }
  }

  uint64_t v40 = CFDictionaryGetValue(a2, @"crossDevices");
  if (v40)
  {
    uint64_t v41 = v40;
    if (TypeID != CFGetTypeID(v40))
    {
      uint64_t v24 = 22LL;
      BOMCopierErrorCapture( a3,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c",  1457,  (uint64_t)"parse_copier_options",  "kBOMCopierSourceOptionUseFilesystemCacheKey must be a CFBooleanRef");
      return v24;
    }

    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13008), @"crossDevices", v41);
  }

  uint64_t v42 = CFDictionaryGetValue(a2, @"useFilesystemCache");
  if (v42)
  {
    uint64_t v43 = v42;
    if (TypeID != CFGetTypeID(v42))
    {
      uint64_t v24 = 22LL;
      BOMCopierErrorCapture( a3,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c",  1502,  (uint64_t)"parse_copier_options",  "kBOMCopierOptionUseFilesystemCacheKey must be a CFBooleanRef");
      return v24;
    }

    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13008), @"useFilesystemCache", v43);
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13024), @"useFilesystemCache", v43);
  }

  uint64_t v44 = CFDictionaryGetValue(a2, @"applySourcePermissions");
  if (v44)
  {
    uint64_t v45 = v44;
    if (TypeID != CFGetTypeID(v44))
    {
      uint64_t v24 = 22LL;
      BOMCopierErrorCapture( a3,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c",  1541,  (uint64_t)"parse_copier_options",  "kBOMCopierOptionApplySourcePermissionsKey must be a CFBooleanRef");
      return v24;
    }

    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13024), @"applySourcePermissions", v45);
  }

  uint64_t v46 = CFDictionaryGetValue(a2, @"copyResources");
  if (v46)
  {
    unint64_t v47 = v46;
    if (TypeID != CFGetTypeID(v46))
    {
      uint64_t v24 = 22LL;
      BOMCopierErrorCapture( a3,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c",  1601,  (uint64_t)"parse_copier_options",  "kBOMCopierOptionCopyResourcesKey must be a CFBooleanRef");
      return v24;
    }

    uint64_t v48 = CFEqual((CFTypeRef)*MEMORY[0x189604DE8], v47) != 0;
  }

  else
  {
    uint64_t v48 = 0;
  }

  uint64_t v49 = CFDictionaryGetValue(a2, @"copyExtendedAttributes");
  if (v49)
  {
    uint64_t v50 = v49;
    if (TypeID != CFGetTypeID(v49))
    {
      uint64_t v24 = 22LL;
      BOMCopierErrorCapture( a3,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c",  1642,  (uint64_t)"parse_copier_options",  "kBOMCopierOptionCopyExtendedAttributesKey must be a CFBooleanRef");
      return v24;
    }

    buffer = CFEqual((CFTypeRef)*MEMORY[0x189604DE8], v50) != 0;
  }

  else
  {
    buffer = 0;
  }

  uint64_t v51 = CFDictionaryGetValue(a2, @"copyACLs");
  if (v51)
  {
    uint64_t v52 = v51;
    if (TypeID != CFGetTypeID(v51))
    {
      uint64_t v24 = 22LL;
      BOMCopierErrorCapture( a3,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c",  1683,  (uint64_t)"parse_copier_options",  "kBOMCopierOptionCopyACLsKey must be a CFBooleanRef");
      return v24;
    }

    v211 = CFEqual((CFTypeRef)*MEMORY[0x189604DE8], v52) != 0;
  }

  else
  {
    v211 = 0;
  }

  uint64_t v53 = (os_log_s *)CFDictionaryGetValue(a2, @"sequesterResources");
  uint64_t v54 = v53;
  if (v53)
  {
    if (TypeID != CFGetTypeID(v53))
    {
      uint64_t v24 = 22LL;
      BOMCopierErrorCapture( a3,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c",  1720,  (uint64_t)"parse_copier_options",  "kBOMCopierOptionSequesterResourcesKey must be a CFBooleanRef");
      return v24;
    }

    LODWORD(v54) = CFEqual((CFTypeRef)*MEMORY[0x189604DE8], v54) != 0;
  }

  uint64_t v55 = *(_DWORD *)(a1 + 12712);
  uint64_t v56 = *(_DWORD *)(a1 + 12716);
  if (!v55)
  {
    if (v56 == 3)
    {
      v208 = 0LL;
      *(void *)&v209 = 0LL;
      LODWORD(v206) = 0;
      DWORD1(v206) = v48;
      v205 = 0LL;
      LODWORD(v54) = 0;
      *((void *)&v206 + 1) = 0LL;
      v207 = 0x100000000LL;
    }

    else
    {
      if (v56 != 6)
      {
        HIDWORD(v206) = 0;
        v207 = 0LL;
        v205 = 0LL;
        HIDWORD(v209) = 0;
        v210 = 0;
        LODWORD(v209) = v48 | v54;
        *(void *)((char *)&v209 + 4) = (v48 || buffer) | v211 | v54;
        LODWORD(v208) = v211;
        HIDWORD(v208) = buffer | v54;
        LODWORD(v206) = (_DWORD)v54;
        *(void *)((char *)&v206 + 4) = v48 | v54;
        LODWORD(v54) = 0;
        goto LABEL_120;
      }

      v208 = 0LL;
      *(void *)&v209 = 0LL;
      v205 = 0LL;
      v206 = 0uLL;
      v207 = 0LL;
      LODWORD(v54) = 0;
    }

    __darwin_time_t v57 = v211;
    goto LABEL_115;
  }

  if (v56 == 3)
  {
    if (v55 == 2)
    {
      v208 = 0LL;
      v209 = 0uLL;
      *(void *)&v206 = 0LL;
      v207 = 0LL;
      v210 = 0;
      v205 = v48 | 0x100000000LL;
      LODWORD(v54) = v48;
    }

    else
    {
      if (v55 == 3)
      {
        v208 = 0LL;
        *(void *)&v209 = 0LL;
        v205 = 0LL;
        *(void *)&v206 = 0LL;
        v207 = v48;
        __darwin_time_t v57 = v211;
        *((void *)&v206 + 1) = __PAIR64__(v48, v211);
LABEL_115:
        *((void *)&v209 + 1) = __PAIR64__(buffer, v57);
        v210 = v48;
        goto LABEL_120;
      }

      v208 = 0LL;
      v209 = 0uLL;
      v205 = 0LL;
      *(void *)&v206 = 0LL;
      v207 = v48;
      v210 = 0;
    }

    *((void *)&v206 + 1) = __PAIR64__(v48, v211);
    goto LABEL_120;
  }

  v208 = 0LL;
  v209 = 0uLL;
  v205 = 0LL;
  v206 = 0uLL;
  v207 = 0LL;
  LODWORD(v54) = 0;
  v210 = 0;
LABEL_120:
  uint64_t v58 = getenv("BOMCOPIER_LOG_OPTION_RESULTS");
  if (!v58) {
    goto LABEL_122;
  }
  if (strcmp(v58, "1")) {
    goto LABEL_122;
  }
  uint64_t v108 = *(os_log_s **)(a1 + 13000);
  if (!v108) {
    goto LABEL_122;
  }
  v204 = (int)v54;
  uint64_t v54 = *(os_log_s **)(a1 + 13000);
  if (!os_log_type_enabled(v108, OS_LOG_TYPE_DEFAULT))
  {
    CFTypeID v110 = v54;
    goto LABEL_236;
  }

  uint64_t v109 = "false";
  if (v48) {
    uint64_t v109 = "true";
  }
  *(_DWORD *)unsigned int valuePtr = 136315138;
  *(void *)&valuePtr[4] = v109;
  _os_log_impl(&dword_1862F3000, v54, OS_LOG_TYPE_DEFAULT, "copy_resources: %s", valuePtr, 0xCu);
  CFTypeID v110 = *(os_log_s **)(a1 + 13000);
  LODWORD(v54) = v204;
  if (v110)
  {
LABEL_236:
    uint64_t v54 = v110;
    if (os_log_type_enabled(v110, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v111 = "false";
      if (buffer) {
        uint64_t v111 = "true";
      }
      *(_DWORD *)unsigned int valuePtr = 136315138;
      *(void *)&valuePtr[4] = v111;
      _os_log_impl(&dword_1862F3000, v54, OS_LOG_TYPE_DEFAULT, "copy_extended_attributes: %s", valuePtr, 0xCu);
      uint64_t v112 = *(os_log_s **)(a1 + 13000);
      LODWORD(v54) = v204;
      if (!v112) {
        goto LABEL_122;
      }
    }

    else
    {
      uint64_t v112 = v54;
    }

    uint64_t v54 = v112;
    if (os_log_type_enabled(v112, OS_LOG_TYPE_DEFAULT))
    {
      int v113 = "false";
      if (v211) {
        int v113 = "true";
      }
      *(_DWORD *)unsigned int valuePtr = 136315138;
      *(void *)&valuePtr[4] = v113;
      _os_log_impl(&dword_1862F3000, v54, OS_LOG_TYPE_DEFAULT, "copy_acls: %s", valuePtr, 0xCu);
      int v114 = *(os_log_s **)(a1 + 13000);
      LODWORD(v54) = v204;
      if (!v114) {
        goto LABEL_122;
      }
    }

    else
    {
      int v114 = v54;
    }

    uint64_t v54 = v114;
    if (os_log_type_enabled(v114, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v115 = "false";
      if (v210) {
        uint64_t v115 = "true";
      }
      *(_DWORD *)unsigned int valuePtr = 136315138;
      *(void *)&valuePtr[4] = v115;
      _os_log_impl(&dword_1862F3000, v54, OS_LOG_TYPE_DEFAULT, " discover_resource_attributes: %s", valuePtr, 0xCu);
      uint64_t v116 = *(os_log_s **)(a1 + 13000);
      LODWORD(v54) = v204;
      if (!v116) {
        goto LABEL_122;
      }
    }

    else
    {
      uint64_t v116 = v54;
    }

    uint64_t v54 = v116;
    if (os_log_type_enabled(v116, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v117 = "false";
      if (HIDWORD(v209)) {
        uint64_t v117 = "true";
      }
      *(_DWORD *)unsigned int valuePtr = 136315138;
      *(void *)&valuePtr[4] = v117;
      _os_log_impl(&dword_1862F3000, v54, OS_LOG_TYPE_DEFAULT, " discover_extended_attributes: %s", valuePtr, 0xCu);
      int v118 = *(os_log_s **)(a1 + 13000);
      LODWORD(v54) = v204;
      if (!v118) {
        goto LABEL_122;
      }
    }

    else
    {
      int v118 = v54;
    }

    uint64_t v54 = v118;
    if (os_log_type_enabled(v118, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v119 = "false";
      if (DWORD2(v209)) {
        uint64_t v119 = "true";
      }
      *(_DWORD *)unsigned int valuePtr = 136315138;
      *(void *)&valuePtr[4] = v119;
      _os_log_impl(&dword_1862F3000, v54, OS_LOG_TYPE_DEFAULT, " discover_acls: %s", valuePtr, 0xCu);
      unsigned int v120 = *(os_log_s **)(a1 + 13000);
      LODWORD(v54) = v204;
      if (!v120) {
        goto LABEL_122;
      }
    }

    else
    {
      unsigned int v120 = v54;
    }

    uint64_t v54 = v120;
    if (os_log_type_enabled(v120, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v121 = "false";
      if (DWORD1(v209)) {
        uint64_t v121 = "true";
      }
      *(_DWORD *)unsigned int valuePtr = 136315138;
      *(void *)&valuePtr[4] = v121;
      _os_log_impl(&dword_1862F3000, v54, OS_LOG_TYPE_DEFAULT, " synthesize_apple_doubles: %s", valuePtr, 0xCu);
      int v122 = *(os_log_s **)(a1 + 13000);
      LODWORD(v54) = v204;
      if (!v122) {
        goto LABEL_122;
      }
    }

    else
    {
      int v122 = v54;
    }

    uint64_t v54 = v122;
    if (os_log_type_enabled(v122, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v123 = "false";
      if ((_DWORD)v209) {
        uint64_t v123 = "true";
      }
      *(_DWORD *)unsigned int valuePtr = 136315138;
      *(void *)&valuePtr[4] = v123;
      _os_log_impl(&dword_1862F3000, v54, OS_LOG_TYPE_DEFAULT, " capture_resource_attributes: %s", valuePtr, 0xCu);
      uint64_t v124 = *(os_log_s **)(a1 + 13000);
      LODWORD(v54) = v204;
      if (!v124) {
        goto LABEL_122;
      }
    }

    else
    {
      uint64_t v124 = v54;
    }

    uint64_t v54 = v124;
    if (os_log_type_enabled(v124, OS_LOG_TYPE_DEFAULT))
    {
      int v125 = "false";
      if (HIDWORD(v208)) {
        int v125 = "true";
      }
      *(_DWORD *)unsigned int valuePtr = 136315138;
      *(void *)&valuePtr[4] = v125;
      _os_log_impl(&dword_1862F3000, v54, OS_LOG_TYPE_DEFAULT, " capture_extended_attributes: %s", valuePtr, 0xCu);
      int v126 = *(os_log_s **)(a1 + 13000);
      LODWORD(v54) = v204;
      if (!v126) {
        goto LABEL_122;
      }
    }

    else
    {
      int v126 = v54;
    }

    uint64_t v54 = v126;
    if (os_log_type_enabled(v126, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v128 = "false";
      if ((_DWORD)v208) {
        uint64_t v128 = "true";
      }
      *(_DWORD *)unsigned int valuePtr = 136315138;
      *(void *)&valuePtr[4] = v128;
      _os_log_impl(&dword_1862F3000, v54, OS_LOG_TYPE_DEFAULT, " capture_acls: %s", valuePtr, 0xCu);
      int v129 = *(os_log_s **)(a1 + 13000);
      LODWORD(v54) = v204;
      if (!v129) {
        goto LABEL_122;
      }
    }

    else
    {
      int v129 = v54;
    }

    uint64_t v54 = v129;
    if (os_log_type_enabled(v129, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v130 = "false";
      if (HIDWORD(v207)) {
        uint64_t v130 = "true";
      }
      *(_DWORD *)unsigned int valuePtr = 136315138;
      *(void *)&valuePtr[4] = v130;
      _os_log_impl(&dword_1862F3000, v54, OS_LOG_TYPE_DEFAULT, " defer_apple_doubles: %s", valuePtr, 0xCu);
      uint64_t v131 = *(os_log_s **)(a1 + 13000);
      LODWORD(v54) = v204;
      if (!v131) {
        goto LABEL_122;
      }
    }

    else
    {
      uint64_t v131 = v54;
    }

    uint64_t v54 = v131;
    if (os_log_type_enabled(v131, OS_LOG_TYPE_DEFAULT))
    {
      v132 = "false";
      if ((_DWORD)v207) {
        v132 = "true";
      }
      *(_DWORD *)unsigned int valuePtr = 136315138;
      *(void *)&valuePtr[4] = v132;
      _os_log_impl(&dword_1862F3000, v54, OS_LOG_TYPE_DEFAULT, " replay_apple_doubles: %s", valuePtr, 0xCu);
      int v133 = *(os_log_s **)(a1 + 13000);
      LODWORD(v54) = v204;
      if (!v133) {
        goto LABEL_122;
      }
    }

    else
    {
      int v133 = v54;
    }

    uint64_t v54 = v133;
    if (os_log_type_enabled(v133, OS_LOG_TYPE_DEFAULT))
    {
      int v134 = "false";
      if (HIDWORD(v206)) {
        int v134 = "true";
      }
      *(_DWORD *)unsigned int valuePtr = 136315138;
      *(void *)&valuePtr[4] = v134;
      _os_log_impl(&dword_1862F3000, v54, OS_LOG_TYPE_DEFAULT, " use_apple_double_suffix: %s", valuePtr, 0xCu);
      int v135 = *(os_log_s **)(a1 + 13000);
      LODWORD(v54) = v204;
      if (!v135) {
        goto LABEL_122;
      }
    }

    else
    {
      int v135 = v54;
    }

    uint64_t v54 = v135;
    if (os_log_type_enabled(v135, OS_LOG_TYPE_DEFAULT))
    {
      int v137 = "false";
      if (DWORD2(v206)) {
        int v137 = "true";
      }
      *(_DWORD *)unsigned int valuePtr = 136315138;
      *(void *)&valuePtr[4] = v137;
      _os_log_impl(&dword_1862F3000, v54, OS_LOG_TYPE_DEFAULT, " merge_acls: %s", valuePtr, 0xCu);
      int v138 = *(os_log_s **)(a1 + 13000);
      LODWORD(v54) = v204;
      if (!v138) {
        goto LABEL_122;
      }
    }

    else
    {
      int v138 = v54;
    }

    uint64_t v54 = v138;
    if (os_log_type_enabled(v138, OS_LOG_TYPE_DEFAULT))
    {
      int v140 = "false";
      if (DWORD1(v206)) {
        int v140 = "true";
      }
      *(_DWORD *)unsigned int valuePtr = 136315138;
      *(void *)&valuePtr[4] = v140;
      _os_log_impl(&dword_1862F3000, v54, OS_LOG_TYPE_DEFAULT, " ignore_apple_doubles: %s", valuePtr, 0xCu);
      int v141 = *(os_log_s **)(a1 + 13000);
      LODWORD(v54) = v204;
      if (!v141) {
        goto LABEL_122;
      }
    }

    else
    {
      int v141 = v54;
    }

    uint64_t v54 = v141;
    if (os_log_type_enabled(v141, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v143 = "false";
      if ((_DWORD)v206) {
        uint64_t v143 = "true";
      }
      *(_DWORD *)unsigned int valuePtr = 136315138;
      *(void *)&valuePtr[4] = v143;
      _os_log_impl(&dword_1862F3000, v54, OS_LOG_TYPE_DEFAULT, " sequester_apple_doubles: %s", valuePtr, 0xCu);
      size_t v144 = *(os_log_s **)(a1 + 13000);
      LODWORD(v54) = v204;
      if (!v144) {
        goto LABEL_122;
      }
    }

    else
    {
      size_t v144 = v54;
    }

    uint64_t v54 = v144;
    if (os_log_type_enabled(v144, OS_LOG_TYPE_DEFAULT))
    {
      int v145 = "false";
      if (v204) {
        int v145 = "true";
      }
      *(_DWORD *)unsigned int valuePtr = 136315138;
      *(void *)&valuePtr[4] = v145;
      int v146 = v54;
      LODWORD(v54) = v204;
      _os_log_impl(&dword_1862F3000, v146, OS_LOG_TYPE_DEFAULT, " unsequester_apple_doubles: %s", valuePtr, 0xCu);
      int v147 = *(os_log_s **)(a1 + 13000);
      if (!v147) {
        goto LABEL_122;
      }
    }

    else
    {
      int v147 = v54;
    }

    uint64_t v54 = v147;
    if (os_log_type_enabled(v147, OS_LOG_TYPE_DEFAULT))
    {
      char v148 = "false";
      if (HIDWORD(v205)) {
        char v148 = "true";
      }
      *(_DWORD *)unsigned int valuePtr = 136315138;
      *(void *)&valuePtr[4] = v148;
      _os_log_impl(&dword_1862F3000, v54, OS_LOG_TYPE_DEFAULT, " reorder_extra_files: %s", valuePtr, 0xCu);
      int v149 = *(os_log_s **)(a1 + 13000);
      LODWORD(v54) = v204;
      if (!v149) {
        goto LABEL_122;
      }
    }

    else
    {
      int v149 = v54;
    }

    uint64_t v54 = v149;
    int v150 = os_log_type_enabled(v149, OS_LOG_TYPE_DEFAULT);
    int v151 = v54;
    LODWORD(v54) = v204;
    if (v150)
    {
      int v152 = "false";
      if ((_DWORD)v205) {
        int v152 = "true";
      }
      *(_DWORD *)unsigned int valuePtr = 136315138;
      *(void *)&valuePtr[4] = v152;
      _os_log_impl(&dword_1862F3000, v151, OS_LOG_TYPE_DEFAULT, " convert_extra_apple_doubles: %s", valuePtr, 0xCu);
    }
  }

uint64_t _checkForDestinationConflict(uint64_t a1, char *a2, uint64_t a3, uint64_t a4, _BYTE *a5, _DWORD *a6)
{
  *a5 = 0;
  *a6 = 0;
  if (*(_BYTE *)(a1 + 12820))
  {
    uint64_t v12 = dirname_r(a2, (char *)(a1 + 9472));
    if (!v12
      || !(*(uint64_t (**)(void, char *, uint64_t))(*(void *)(a1 + 12832) + 160LL))( *(void *)(*(void *)(a1 + 12832) + 8LL),  v12,  a1 + 8448)
      && *__error() != 2)
    {
      goto LABEL_31;
    }

    size_t v13 = strlen((const char *)(a1 + 4352));
    if (strncmp((const char *)(a1 + 4352), (const char *)(a1 + 8448), v13))
    {
      *a6 = 1;
      uint64_t v14 = a1;
      return _checkCopyFileError(v14);
    }
  }

  if ((*(unsigned int (**)(void, char *, uint64_t))(*(void *)(a1 + 12832) + 96LL))( *(void *)(*(void *)(a1 + 12832) + 8LL),  a2,  a4))
  {
LABEL_8:
    if (*__error() == 2 || *__error() == 63) {
      goto LABEL_10;
    }
    goto LABEL_31;
  }

  char v16 = 1;
  while (1)
  {
    __int16 v17 = *(_WORD *)(a4 + 4);
    int v18 = v17 & 0xF000;
    if ((*(_WORD *)(a3 + 4) & 0xF000) != 0x4000)
    {
      if (v18 != 0x4000) {
        goto LABEL_35;
      }
LABEL_21:
      if ((v16 & 1) == 0
        || (BOMFSObjectTypeForMode(v17),
            BOMFSObjectTypeForMode(*(_WORD *)(a3 + 4)),
            _checkCopyFileConflictError(a1) != 3))
      {
        *a6 = 1;
        goto LABEL_32;
      }

      goto LABEL_23;
    }

    if (v18 == 0x4000) {
      goto LABEL_35;
    }
    if (v18 != 40960) {
      goto LABEL_21;
    }
    int v19 = *(_DWORD *)(a1 + 12816);
    if (v19 != 2) {
      break;
    }
    if ((v16 & 1) == 0) {
      goto LABEL_36;
    }
    BOMFSObjectTypeForMode(v17);
    BOMFSObjectTypeForMode(*(_WORD *)(a3 + 4));
LABEL_23:
    int v20 = (*(uint64_t (**)(void, char *, uint64_t))(*(void *)(a1 + 12832) + 96LL))( *(void *)(*(void *)(a1 + 12832) + 8LL),  a2,  a4);
    char v16 = 0;
    if (v20) {
      goto LABEL_8;
    }
  }

  if (v19 == 1)
  {
    if ((*(unsigned int (**)(void, char *, uint64_t))(*(void *)(a1 + 12832) + 80LL))( *(void *)(*(void *)(a1 + 12832) + 8LL),  a2,  a4))
    {
      goto LABEL_31;
    }

    if ((*(_WORD *)(a4 + 4) & 0xF000) == 0x4000)
    {
LABEL_35:
      *a5 = 1;
      return 0LL;
    }

uint64_t _copyFile( uint64_t a1, uint64_t a2, uint64_t a3, unsigned __int8 a4, _DWORD *a5, unsigned int *a6, int a7)
{
  v72[0] = a4;
  char v70 = 0;
  uint64_t v69 = 0LL;
  uint64_t v11 = (_BYTE *)(a1 + 11616);
  __int128 v68 = 0uLL;
  __int128 v67 = 0uLL;
  if (*(_DWORD *)(a1 + 12712))
  {
LABEL_2:
    int v12 = 0;
    int v13 = 0;
    uint64_t v14 = (int *)(a2 + 116);
    BOOL v60 = (*(_DWORD *)(a2 + 116) & 0x40000020) == 32;
    uint64_t v15 = *(void *)(a2 + 96);
    goto LABEL_3;
  }

  if (BOMAppleDoubleIsADFile((const char *)(a1 + 248)))
  {
    if (*(_BYTE *)(a1 + 169)) {
      goto LABEL_21;
    }
    goto LABEL_2;
  }

  uint64_t v14 = (int *)(a2 + 116);
  int v29 = *(_DWORD *)(a2 + 116) & 0x40000020;
  BOOL v30 = v29 == 32;
  if (v29 == 32)
  {
    if (*(_BYTE *)(a1 + 195)) {
      uint64_t v32 = 33LL;
    }
    else {
      uint64_t v32 = 1LL;
    }
  }

  else
  {
    uint64_t v32 = 1LL;
  }

  uint64_t v33 = *(void *)(a2 + 96);
  uint64_t v34 = (*(uint64_t (**)(void, uint64_t, const char *, void, void, void, uint64_t))(*(void *)(a1 + 12832)
                                                                                                  + 128LL))( *(void *)(*(void *)(a1 + 12832) + 8LL),  a1 + 248,  "com.apple.ResourceFork",  0LL,  0LL,  0LL,  v32);
  BOOL v60 = v30;
  if (v34 == -1)
  {
    if (*__error() != 2 && *__error() != 93 && *__error() != 45)
    {
      uint64_t v38 = __error();
      uint64_t v34 = 0LL;
      int v13 = *v38;
      goto LABEL_45;
    }

    uint64_t v34 = 0LL;
  }

  int v13 = 0;
LABEL_45:
  uint64_t v15 = v34 + v33;
  int v12 = 1;
LABEL_3:
  if (*(_DWORD *)(a1 + 12712)) {
    uint64_t v16 = a1 + 248;
  }
  else {
    uint64_t v16 = *(void *)(a1 + 2296);
  }
  uint64_t v17 = BOMFSObjectTypeForMode(*(_WORD *)(a2 + 4));
  *uint64_t v11 = 0;
  v11[1025] = 0;
  int v18 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(a1 + 88);
  uint64_t v62 = v16;
  unsigned int v61 = v17;
  if (v18)
  {
    uint64_t v19 = v16;
    uint64_t v20 = v15;
    unsigned int v21 = v18(a1, v19, v17, v15);
  }

  else
  {
    uint64_t v20 = v15;
    unsigned int v21 = 0;
  }

  if (*(_BYTE *)(a1 + 168)) {
    uint64_t v22 = 2LL;
  }
  else {
    uint64_t v22 = v21;
  }
  if ((_DWORD)v22 == 1)
  {
LABEL_21:
    *a6 = 1;
    int v25 = *(_DWORD *)(a1 + 12712);
    if (v25 == 2)
    {
      uint64_t File = BOMPKZipGetFile(*(void *)(a1 + 12752));
      uint64_t v28 = File;
      if (v11[1153] && BOMFileSetCompression(File, 1, 1, *(_DWORD *)(a1 + 12792)))
      {
        __error();
        _checkCopyFileError(a1);
        uint64_t v22 = 2LL;
        goto LABEL_144;
      }

      if (*(_DWORD *)(a1 + 12776)) {
        BOMFileSetPartialRead(v28, 1);
      }
      int v26 = _skipPKZipFile();
    }

    else
    {
      if (v25 != 1) {
        goto LABEL_143;
      }
      int v26 = _skipCPIOFile(a1);
    }

    uint64_t v22 = 2 * (v26 != 0);
    goto LABEL_144;
  }

  if ((_DWORD)v22 != 2)
  {
    if (v13)
    {
      uint64_t v23 = a1;
LABEL_19:
      uint64_t v24 = _checkCopyFileError(v23);
LABEL_20:
      uint64_t v22 = v24;
      goto LABEL_144;
    }

    if (*v11)
    {
      uint64_t v31 = (char *)(a1 + 10592);
      uint64_t v24 = _checkForDestinationConflict(a1, (char *)(a1 + 10592), a2, a3, v72, v65);
      if (v65[0] == 1) {
        goto LABEL_20;
      }
    }

    else
    {
      uint64_t v31 = (char *)(a1 + 3328);
    }

    __darwin_time_t v59 = v31;
    if (v11[1025] && !*(_DWORD *)(a1 + 12712))
    {
      uint64_t v35 = (char *)(a1 + 11617);
      if ((*(unsigned int (**)(void, uint64_t, uint64_t))(*(void *)(a1 + 12832) + 96LL))( *(void *)(*(void *)(a1 + 12832) + 8LL),  a1 + 11617,  a2) == -1)
      {
LABEL_90:
        __error();
        uint64_t v23 = a1;
        goto LABEL_19;
      }

      if ((*(_WORD *)(a2 + 4) & 0xF000) != 0x8000)
      {
        uint64_t v23 = a1;
        goto LABEL_19;
      }
    }

    else
    {
      uint64_t v35 = (char *)(a1 + 248);
    }

    if (*(_DWORD *)(a1 + 12716) == 3) {
      unsigned int v58 = *v14;
    }
    else {
      unsigned int v58 = 0;
    }
    *(_BYTE *)(a1 + 196) = 1;
    uint64_t v36 = _copyDataFork(a1, v35, a2, a3, v72[0], a5, a6, a7);
    if ((_DWORD)v36)
    {
      uint64_t v22 = v36;
      if (*(_DWORD *)(a1 + 12716) != 3) {
        goto LABEL_144;
      }
LABEL_55:
      (*(void (**)(void, uint64_t))(*(void *)(a1 + 12832) + 224LL))( *(void *)(*(void *)(a1 + 12832) + 8LL),  a1 + 7424);
      goto LABEL_144;
    }

    if (*a6)
    {
      unsigned int v71 = *a6;
    }

    else
    {
      if (*(_DWORD *)(a1 + 12716) == 3)
      {
        if (v11[1232] || (unsigned int v37 = *(unsigned __int8 *)(a1 + 195), *(_BYTE *)(a1 + 195)))
        {
          uint64_t v69 = AFSCLockFilePath();
          if (!v69)
          {
LABEL_94:
            __error();
            (*(void (**)(void, uint64_t))(*(void *)(a1 + 12832) + 224LL))( *(void *)(*(void *)(a1 + 12832) + 8LL),  a1 + 7424);
LABEL_95:
            uint64_t v23 = a1;
            goto LABEL_19;
          }

          unsigned int v37 = *a6;
        }
      }

      else
      {
        unsigned int v37 = 0;
      }

      unsigned int v71 = v37;
      if (v37) {
        int v39 = 0;
      }
      else {
        int v39 = v12;
      }
      if (v39 == 1)
      {
        if (*(_DWORD *)(a1 + 12716) == 3)
        {
          if (*(_BYTE *)(a1 + 170) || *(_BYTE *)(a1 + 169)) {
            unsigned int v40 = _copyExtendedAttributes(a1, (uint64_t)v35, a2, 1, &v71);
          }
          else {
            unsigned int v40 = 0;
          }
          if (v40) {
            BOOL v41 = 1;
          }
          else {
            BOOL v41 = *(_BYTE *)(a1 + 172) == 0;
          }
          if (v41) {
            uint64_t v22 = v40;
          }
          else {
            uint64_t v22 = 0LL;
          }
          if (*(_BYTE *)(a1 + 171) && !(_DWORD)v22) {
            uint64_t v22 = _copyACLs(a1, v35, 1, 0, &v71);
          }
          if ((_DWORD)v22) {
            goto LABEL_55;
          }
        }

        else
        {
          uint64_t v22 = _copyAppleDoubleToArchive(a1, (uint64_t)v35, a2, &v71);
          if ((_DWORD)v22) {
            goto LABEL_144;
          }
        }
      }
    }

    uint64_t v42 = *(const void **)(a1 + 216);
    uint64_t v43 = a6;
    uint64_t v44 = v20;
    uint64_t v45 = v62;
    if (!*a6 && *(_DWORD *)(a1 + 12716) == 3)
    {
      __int128 v46 = *(_OWORD *)(a2 + 32);
      __int128 v67 = *(_OWORD *)(a2 + 48);
      __int128 v68 = v46;
      if (set_timestamps_0((const char *)(a1 + 7424), &v68, &v67))
      {
        if (*__error() != 13 && *__error() != 1) {
          goto LABEL_94;
        }
        *__error() = 0;
      }

      if (*(_DWORD *)(a1 + 12712)
        && *(_DWORD *)(a1 + 12716) == 3
        && *(_BYTE *)(a1 + 169)
        && BOMAppleDoubleIsADFile(v59))
      {
        __strlcpy_chk();
        __strlcat_chk();
        if ((*(unsigned int (**)(void, uint64_t, uint64_t))(*(void *)(a1 + 12832) + 264LL))( *(void *)(*(void *)(a1 + 12832) + 8LL),  a1 + 7424,  a1 + 8448))
        {
          goto LABEL_94;
        }

        uint64_t v43 = a6;
        uint64_t v45 = v62;
        if (v62 == a1 + 248) {
          __strlcat_chk();
        }
      }

      else if (!v11[1207] {
             && (a7 & 1) == 0
      }
             && (*(unsigned int (**)(void, uint64_t, char *))(*(void *)(a1 + 12832) + 264LL))( *(void *)(*(void *)(a1 + 12832) + 8LL),  a1 + 7424,  v59))
      {
        goto LABEL_94;
      }

      if (v58)
      {
        if (*(_DWORD *)(a1 + 10496)) {
          uint64_t v47 = v58 & 0xC000FFFF;
        }
        else {
          uint64_t v47 = v58;
        }
        if (v60 && (!*(_BYTE *)(a1 + 195) || *(_BYTE *)(a1 + 196))) {
          uint64_t v47 = v47 & 0xFFFFFFDF;
        }
        if ((_DWORD)v47)
        {
          uint64_t v48 = v45;
          uint64_t v49 = v44;
          int v50 = *v14;
          if (!(*(unsigned int (**)(void, char *, _DWORD *))(*(void *)(a1 + 12832) + 80LL))( *(void *)(*(void *)(a1 + 12832) + 8LL),  v59,  v65))
          {
            int v50 = v66;
            if ((v66 & 0x40000020) == 0x20) {
              unsigned int v51 = v47 | 0x20;
            }
            else {
              unsigned int v51 = v47;
            }
            if (v11[1232]) {
              unsigned int v52 = v51;
            }
            else {
              unsigned int v52 = v47;
            }
            if ((~v52 & 0x40000020) != 0) {
              uint64_t v47 = v52;
            }
            else {
              uint64_t v47 = v52 & 0xBFFFFFDF;
            }
          }

          if (change_flags_0(a1, v59, v50, v47) || set_timestamps_0(v59, &v68, &v67))
          {
            __error();
            goto LABEL_95;
          }

          uint64_t v44 = v49;
          uint64_t v45 = v48;
        }
      }

      if (*(_BYTE *)(a1 + 197))
      {
        uint64_t FSObjectAtPath = BOMBomGetFSObjectAtPath(*(void *)(a1 + 152), *(char **)(a1 + 2296));
        uint64_t v54 = v44;
        int v55 = BOMFSObjectChecksum(FSObjectAtPath);
        BOMFSObjectFree(FSObjectAtPath);
        BOOL v41 = v55 == *(_DWORD *)(a1 + 200);
        uint64_t v44 = v54;
        if (!v41)
        {
          if (*(void *)(a1 + 56)) {
            goto LABEL_95;
          }
        }
      }
    }

    if (*(_DWORD *)(a1 + 12712) == 2 && *(_DWORD *)(a1 + 12776)) {
      uint64_t v44 = *(void *)(a2 + 96);
    }
    uint64_t v56 = *(void (**)(uint64_t, uint64_t, void, uint64_t, void))(a1 + 96);
    if (v56) {
      v56(a1, v45, v61, v44, *v43);
    }
LABEL_143:
    uint64_t v22 = 0LL;
  }

LABEL_144:
  _unlockAFSCFileLock(&v69);
  return v22;
}

uint64_t _copyDir( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, char a5, uint64_t a6, uint64_t a7, char *a8, size_t a9, unsigned int a10, unsigned __int8 a11)
{
  int v16 = a11;
  v67[0] = a5;
  unsigned __int8 v66 = 0;
  __int128 v65 = 0uLL;
  __int128 v64 = 0uLL;
  if (!*(_DWORD *)(a1 + 12712)
    && *(_DWORD *)a2 == *(_DWORD *)(a1 + 236)
    && *(void *)(a2 + 8) == *(void *)(a1 + 240))
  {
    return 0LL;
  }

  uint64_t v17 = (_BYTE *)(a1 + 11616);
  uint64_t v18 = BOMFSObjectTypeForMode(*(_WORD *)(a2 + 4));
  uint64_t v19 = *(void *)(a1 + 2296);
  *uint64_t v17 = 0;
  *(_BYTE *)(a1 + 12641) = 0;
  uint64_t v20 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, void))(a1 + 88);
  int v21 = v20 ? v20(a1, v19, v18, 0LL) : 0;
  int v22 = *(_BYTE *)(a1 + 168) ? 2 : v21;
  if (v22 == 1) {
    return 0LL;
  }
  if (v22 != 2)
  {
    uint64_t v57 = a7;
    if (*v17)
    {
      uint64_t v24 = (char *)(a1 + 10592);
      uint64_t v23 = _checkForDestinationConflict(a1, (char *)(a1 + 10592), a2, a3, v67, &v63);
      if ((_DWORD)v63 == 1) {
        return v23;
      }
    }

    else
    {
      uint64_t v23 = 0LL;
      uint64_t v24 = (char *)(a1 + 3328);
    }

    unsigned int v54 = v18;
    if (*(_BYTE *)(a1 + 12641) && !*(_DWORD *)(a1 + 12712))
    {
      int v26 = (char *)(a1 + 11617);
      if ((*(unsigned int (**)(void, uint64_t, uint64_t))(*(void *)(a1 + 12832) + 96LL))( *(void *)(*(void *)(a1 + 12832) + 8LL),  a1 + 11617,  a2) == -1)
      {
        __error();
        return _checkCopyFileError(a1);
      }

      if ((*(_WORD *)(a2 + 4) & 0xF000) != 0x4000) {
        return _checkCopyFileError(a1);
      }
      size_t v56 = a9;
      int v25 = v24;
    }

    else
    {
      size_t v56 = a9;
      int v25 = v24;
      int v26 = (char *)(a1 + 248);
    }

    if (*(_DWORD *)(a1 + 12712) || *(_DWORD *)(a1 + 12716) != 3 || (*(_BYTE *)(a2 + 118) & 1) == 0)
    {
LABEL_25:
      int v55 = a8;
      int v28 = *(_DWORD *)(a1 + 12716);
      path_p = v26;
      if (v28 == 3)
      {
        if (v67[0])
        {
          int v29 = v16;
          if (v16 || !*(_BYTE *)(a1 + 12822)) {
            goto LABEL_45;
          }
        }

        else
        {
          int v29 = v16;
          if (v16) {
            goto LABEL_45;
          }
        }

        if (!_makeDestDir(a1, v25, 1, a2, &v66))
        {
LABEL_45:
          int v32 = v66;
          BOOL v33 = v66 != 0;
          if (v66)
          {
            unsigned int v51 = *(unsigned __int16 *)(a2 + 4);
            uint64_t v34 = strdup(v25);
          }

          else
          {
            unsigned int v51 = 0;
            uint64_t v34 = v25;
          }

          int v52 = v67[0];
          int v35 = v67[0] | v29;
          if (v35)
          {
            int v36 = v33;
          }

          else
          {
            __int128 v37 = *(_OWORD *)(a2 + 48);
            __int128 v65 = *(_OWORD *)(a2 + 32);
            __int128 v64 = v37;
            if (!v32)
            {
              uint64_t v38 = strdup(v34);
              int v36 = 1;
LABEL_53:
              int v39 = *(_DWORD *)(a1 + 12712);
              if (v39 != 2) {
                goto LABEL_78;
              }
              if (*(_DWORD *)(a1 + 12776))
              {
                if (*(_BYTE *)(a1 + 12769))
                {
                  uint64_t File = BOMPKZipGetFile(*(void *)(a1 + 12752));
                  BOMFileSetPartialRead(File, 1);
                  uint64_t v41 = BOMPKZipGetFile(*(void *)(a1 + 12752));
                  int v50 = v36;
                  uint64_t v42 = (int *)BOMPKZipGetFile(*(void *)(a1 + 12752));
                  while (BOMFileRead(v42, _copyDir_waste, 0x40uLL) != -1
                       && !BOMFileEndOfCompressionStream((BOOL)v42))
                    ;
                  uint64_t v43 = BOMPKZipGetFile(*(void *)(a1 + 12752));
                  if (BOMFileSetCompression(v43, 0, 1, *(_DWORD *)(a1 + 12792)))
                  {
                    __error();
                    uint64_t v23 = _checkCopyFileError(a1);
                    if ((v50 & 1) == 0) {
                      return v23;
                    }
LABEL_99:
                    free(v38);
                    return v23;
                  }

                  uint64_t v45 = BOMPKZipGetFile(*(void *)(a1 + 12752));
                  BOMFileSetPartialRead(v45, 0);
                  int v36 = v50;
                }

                __int128 v46 = (int *)BOMPKZipGetFile(*(void *)(a1 + 12752));
                if (BOMFileRead(v46, (char *)&v62, 4uLL) == 4
                  && v62 == 134695760
                  && !BOMPKZipReadDataDescriptor( *(int ***)(a1 + 12752),  *(unsigned __int8 *)(a1 + 12812),  &v61,  &v63,  &v60))
                {
                  int v39 = *(_DWORD *)(a1 + 12712);
LABEL_78:
                  switch(v39)
                  {
                    case 0:
                      uint64_t v47 = _copyFromDirToDir(a1, a2, a6 + a4, v57 - a4, &v55[a4], v56 - a4, a10);
                      goto LABEL_82;
                    case 1:
                      uint64_t v47 = _copyFromCPIO(a1, a2, a3, v55, v56, v52);
                      goto LABEL_82;
                    case 2:
                      goto LABEL_80;
                    case 3:
                      uint64_t v23 = 2LL;
                      if ((v36 & 1) != 0) {
                        goto LABEL_99;
                      }
                      break;
                    default:
                      goto LABEL_83;
                  }

                  return v23;
                }

                goto LABEL_94;
              }

LABEL_88:
              if (v66)
              {
                if ((*(unsigned int (**)(void, char *, void))(*(void *)(a1 + 12832) + 200LL))( *(void *)(*(void *)(a1 + 12832) + 8LL),  v38,  v51) == -1) {
                  goto LABEL_94;
                }
                int v52 = v67[0];
              }

              if (*(_DWORD *)(a1 + 12716) == 3 && !(v52 | v29) && set_timestamps_0(v38, &v65, &v64))
              {
LABEL_94:
                __error();
                uint64_t v23 = _checkCopyFileError(a1);
                if ((v36 & 1) == 0) {
                  return v23;
                }
                goto LABEL_99;
              }

              if (!*(_DWORD *)(a1 + 12712))
              {
                uint64_t v48 = *(void (**)(uint64_t, void, void, void, void))(a1 + 96);
                if (v48)
                {
                  v48(a1, *(void *)(a1 + 2296), v54, 0LL, 0LL);
                  uint64_t v23 = 0LL;
                  if ((v36 & 1) == 0) {
                    return v23;
                  }
                  goto LABEL_99;
                }
              }

              uint64_t v23 = 0LL;
              goto LABEL_84;
            }

            int v36 = 1;
          }

          uint64_t v38 = v34;
          goto LABEL_53;
        }
      }

      else
      {
        int v29 = v16;
        BOOL v30 = v25;
        if (!*v17) {
          BOOL v30 = *(const char **)(a1 + 2296);
        }
        strncpy((char *)(a1 + 7424), v30, 0x400uLL);
        if (v16) {
          goto LABEL_45;
        }
        if (v28 == 4)
        {
        }

        else if (!BOMPKZipWriteLocalHeader(*(void *)(a1 + 12760), (char *)(a1 + 7424), a2, 0, 0))
        {
          goto LABEL_45;
        }
      }

LABEL_44:
      __error();
      return _checkCopyFileError(a1);
    }

    uint64_t v27 = BOM_malloc(0x400uLL);
    unint64_t v63 = 0LL;
    if (BOMHardLinkTableGetPathAndData( *(CFDictionaryRef **)a1,  *(_DWORD *)a2,  *(void *)(a2 + 8),  (char *)v27,  &v63))
    {
      BOMHardLinkTableSetPathAndData( *(CFDictionaryRef **)a1,  *(_DWORD *)a2,  *(void *)(a2 + 8),  v25,  (const void *)(a2 + 96),  8uLL);
      free(v27);
      goto LABEL_25;
    }

    if (v67[0]
      && (*(unsigned int (**)(void, char *))(*(void *)(a1 + 12832) + 224LL))( *(void *)(*(void *)(a1 + 12832) + 8LL),  v25))
    {
      free(v27);
      goto LABEL_44;
    }

    int v44 = (*(uint64_t (**)(void, void *, char *))(*(void *)(a1 + 12832) + 240LL))( *(void *)(*(void *)(a1 + 12832) + 8LL),  v27,  v25);
    free(v27);
    if (v44)
    {
      int v16 = a11;
      if (*__error() != 18) {
        goto LABEL_44;
      }
      goto LABEL_25;
    }

    return 0LL;
  }

  return 2LL;
}

        *(_WORD *)(v14 + 4) &= ~8u;
      }
    }
  }

  return v6;
}

    if (!*v78) {
      return 0LL;
    }
    goto LABEL_45;
  }

  uint64_t v72 = a3;
  uint64_t v76 = a6;
  if (IndexForKey)
  {
    uint64_t v20 = v15;
    int v21 = _findPage(v15, *(_DWORD *)(*(void *)(v17 + 32) + 4LL * (IndexForKey - 1)));
    int v22 = *((_WORD *)v21 + 2);
    if ((v22 & 8) == 0)
    {
      __int128 v68 = v17;
LABEL_12:
      int v25 = 0;
      *((_WORD *)v21 + 2) = v22 | 8;
      goto LABEL_16;
    }

    int v25 = 1;
    __int128 v68 = v17;
  }

  else if (a3)
  {
    uint64_t v20 = v15;
    int v21 = _findPage(v15, *(_DWORD *)(*(void *)(a3 + 32) + 4LL * *(unsigned __int16 *)(a3 + 16)));
    int v22 = *((_WORD *)v21 + 2);
    if ((v22 & 8) == 0)
    {
      __int128 v68 = a5;
      goto LABEL_12;
    }

    int v25 = 1;
    __int128 v68 = a5;
  }

  else
  {
    uint64_t v20 = v15;
    __int128 v68 = 0LL;
    int v21 = 0LL;
    int v25 = 1;
  }

uint64_t _copyLink(uint64_t a1, uint64_t a2, uint64_t a3, char a4)
{
  uint64_t v7 = (_BYTE *)(a1 + 11616);
  char v43 = a4;
  char v42 = 0;
  uint64_t v8 = BOMFSObjectTypeForMode(*(_WORD *)(a2 + 4));
  if (*(_DWORD *)(a1 + 12712)) {
    uint64_t v9 = (const char *)(a1 + 248);
  }
  else {
    uint64_t v9 = *(const char **)(a1 + 2296);
  }
  *uint64_t v7 = 0;
  v7[1025] = 0;
  int v10 = *(uint64_t (**)(uint64_t, const char *, uint64_t, void))(a1 + 88);
  if (v10) {
    unsigned int v11 = v10(a1, v9, v8, 0LL);
  }
  else {
    unsigned int v11 = 0;
  }
  if (*(_BYTE *)(a1 + 168)) {
    uint64_t v12 = 2LL;
  }
  else {
    uint64_t v12 = v11;
  }
  if ((_DWORD)v12 == 1)
  {
    uint64_t v12 = 0LL;
LABEL_16:
    if (*(_DWORD *)(a1 + 12712) == 1)
    {
      else {
        return v12;
      }
    }

    return v12;
  }

  if ((_DWORD)v12 == 2) {
    return v12;
  }
  if (*v7)
  {
    int v13 = (char *)(a1 + 10592);
    uint64_t v14 = _checkForDestinationConflict(a1, (char *)(a1 + 10592), a2, a3, &v43, &v41);
    if (v41 == 1)
    {
LABEL_14:
      uint64_t v12 = v14;
      goto LABEL_16;
    }
  }

  else
  {
    int v13 = (char *)(a1 + 3328);
  }

  if (!v7[1025] || *(_DWORD *)(a1 + 12712))
  {
    int v16 = (char *)(a1 + 248);
LABEL_25:
    uint64_t v12 = 2LL;
    switch(*(_DWORD *)(a1 + 12712))
    {
      case 0:
        uint64_t v17 = (*(uint64_t (**)(void, char *, void, void))(*(void *)(a1 + 12832) + 256LL))( *(void *)(*(void *)(a1 + 12832) + 8LL),  v16,  *(void *)(a1 + 8),  *(int *)(a1 + 16));
        if (v17 == -1) {
          goto LABEL_64;
        }
        goto LABEL_39;
      case 1:
        uint64_t v17 = *(void *)(a2 + 96);
        if (v17 >= 1025)
        {
          uint64_t v14 = _checkCopyFileError(a1);
          goto LABEL_14;
        }

        unint64_t v18 = BOMCPIORead(*(int ***)(a1 + 12728), *(char **)(a1 + 8), *(void *)(a2 + 96));
LABEL_38:
        if (v18 != v17) {
          goto LABEL_64;
        }
LABEL_39:
        *(_BYTE *)(*(void *)(a1 + 8) + v17) = 0;
        int v20 = *(_DWORD *)(a1 + 12716);
        if (v20 == 5)
        {
          unsigned int v28 = crc32(0LL, 0LL, 0);
          if (*v7) {
            int v29 = v13;
          }
          else {
            int v29 = v9;
          }
          strncpy((char *)(a1 + 7424), v29, 0x400uLL);
          int v30 = crc32(v28, *(const Bytef **)(a1 + 8), v17);
          if (!BOMPKZipWriteLocalHeader(*(void *)(a1 + 12760), (char *)(a1 + 7424), a2, v30, v17))
          {
            uint64_t File = BOMPKZipGetFile(*(void *)(a1 + 12760));
            if (BOMFileWrite(File, *(UInt8 **)(a1 + 8), v17) == v17) {
              goto LABEL_69;
            }
          }
        }

        else if (v20 == 4)
        {
          if (*v7) {
            int v32 = v13;
          }
          else {
            int v32 = v9;
          }
          strncpy((char *)(a1 + 7424), v32, 0x400uLL);
        }

        else
        {
          char v21 = 0;
          if (v20 != 3) {
            goto LABEL_70;
          }
          if (*(_BYTE *)(a1 + 173) && v43 && (*(_WORD *)(a3 + 4) & 0xF000) == 0xA000)
          {
            uint64_t v22 = (*(uint64_t (**)(void, char *, uint64_t, uint64_t))(*(void *)(a1 + 12832) + 256LL))( *(void *)(*(void *)(a1 + 12832) + 8LL),  v13,  a1 + 8448,  1024LL);
            if (v22 == -1) {
              goto LABEL_64;
            }
            *(_BYTE *)(a1 + v22 + 8448) = 0;
          }

          _parentPath(v13, (char *)(a1 + 7424), 0x400uLL);
          __strlcat_chk();
          if ((*(uint64_t (**)(void, uint64_t))(*(void *)(a1 + 12832) + 336LL))( *(void *)(*(void *)(a1 + 12832) + 8LL),  a1 + 7424)
            && !(*(unsigned int (**)(void, void, uint64_t))(*(void *)(a1 + 12832) + 248LL))( *(void *)(*(void *)(a1 + 12832) + 8LL),  *(void *)(a1 + 8),  a1 + 7424))
          {
            if (*(_DWORD *)(a1 + 12712) == 1)
            {
              int v23 = _chPerms(a1, (char *)(a1 + 7424), a2, &v42, 1);
              uint64_t v24 = *(void *)(a1 + 12832);
              int v25 = *(unsigned int (**)(uint64_t, uint64_t))(v24 + 224);
              uint64_t v26 = *(void *)(v24 + 8);
              if (v23)
              {
                v25(v26, a1 + 7424);
                __error();
                uint64_t v27 = a1;
                return _checkCopyFileError(v27);
              }

              if (!v25(v26, (uint64_t)v13) || *__error() == 2 || *__error() == 63)
              {
                int v35 = (void **)BOM_malloc(0x18uLL);
                if (!v35) {
                  goto LABEL_93;
                }
                int v36 = v35;
                size_t __n = strlen(v13) + 1;
                size_t v37 = strlen((const char *)(a1 + 7424)) + 1;
                size_t v38 = strlen(v9) + 1;
                uint64_t *v36 = BOM_malloc(__n);
                v36[1] = BOM_malloc(v37);
                int v39 = BOM_malloc(v38);
                v36[2] = v39;
                if (!*v36 || !v36[1] || !v39)
                {
LABEL_93:
                  uint64_t v27 = a1;
                  return _checkCopyFileError(v27);
                }

                memcpy(*v36, v13, __n);
                memcpy(v36[1], (const void *)(a1 + 7424), v37);
                memcpy(v36[2], v9, v38);
                BOMStackPush(*(char **)(a1 + 40), (uint64_t)v36);
                char v21 = 1;
LABEL_70:
                if (*(_DWORD *)(a1 + 12712)) {
                  goto LABEL_71;
                }
                if (*(_DWORD *)(a1 + 12716) == 3)
                {
                  if (*(_BYTE *)(a1 + 170) || *(_BYTE *)(a1 + 169))
                  {
                    uint64_t v12 = _copyExtendedAttributes(a1, (uint64_t)v16, a2, 0, 0LL);
                    if ((_DWORD)v12) {
                      goto LABEL_16;
                    }
                  }

                  if (!*(_BYTE *)(a1 + 171))
                  {
LABEL_71:
                    if ((v21 & 1) == 0)
                    {
                      BOOL v33 = *(void (**)(uint64_t, const char *, uint64_t, void, void))(a1 + 96);
                      if (v33) {
                        v33(a1, v9, v8, 0LL, 0LL);
                      }
                    }

                    return 0LL;
                  }

                  uint64_t v34 = _copyACLs(a1, v16, 0, 1, 0LL);
                }

                else
                {
                  uint64_t v34 = _copyAppleDoubleToArchive(a1, (uint64_t)v16, a2, 0LL);
                }

                uint64_t v12 = v34;
                if ((_DWORD)v34) {
                  goto LABEL_16;
                }
                goto LABEL_71;
              }

LABEL_68:
              __error();
              uint64_t v27 = a1;
              return _checkCopyFileError(v27);
            }

            if ((*(unsigned int (**)(void, uint64_t, char *))(*(void *)(a1 + 12832) + 264LL))( *(void *)(*(void *)(a1 + 12832) + 8LL),  a1 + 7424,  v13))
            {
              goto LABEL_64;
            }

            if (_chPerms(a1, v13, a2, &v42, 1))
            {
              (*(void (**)(void, char *))(*(void *)(a1 + 12832) + 224LL))( *(void *)(*(void *)(a1 + 12832) + 8LL),  v13);
              goto LABEL_68;
            }

LABEL_69:
            char v21 = 0;
            goto LABEL_70;
          }
        }

        break;
      case 2:
        uint64_t v17 = *(void *)(a2 + 96);
        if (v17 >= 1025) {
          return _checkCopyFileError(a1);
        }
        uint64_t v19 = (int *)BOMPKZipGetFile(*(void *)(a1 + 12752));
        unint64_t v18 = BOMFileRead(v19, *(char **)(a1 + 8), v17);
        goto LABEL_38;
      case 3:
        return v12;
      default:
        uint64_t v17 = 0LL;
        goto LABEL_39;
    }

    goto LABEL_64;
  }

  int v16 = (char *)(a1 + 11617);
  if ((*(unsigned int (**)(void, uint64_t, uint64_t))(*(void *)(a1 + 12832) + 96LL))( *(void *)(*(void *)(a1 + 12832) + 8LL),  a1 + 11617,  a2) != -1)
  {
    if ((*(_WORD *)(a2 + 4) & 0xF000) != 0xA000) {
      return _checkCopyFileError(a1);
    }
    goto LABEL_25;
  }

uint64_t _copyDevice(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (_BYTE *)(a1 + 11616);
  uint64_t v5 = BOMFSObjectTypeForMode(*(_WORD *)(a2 + 4));
  if (*(_DWORD *)(a1 + 12712)) {
    uint64_t v6 = a1 + 248;
  }
  else {
    uint64_t v6 = *(void *)(a1 + 2296);
  }
  *uint64_t v4 = 0;
  char v4[1025] = 0;
  uint64_t v7 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, void))(a1 + 88);
  if (v7) {
    int v8 = v7(a1, v6, v5, 0LL);
  }
  else {
    int v8 = 0;
  }
  if (*(_BYTE *)(a1 + 168)) {
    int v9 = 2;
  }
  else {
    int v9 = v8;
  }
  if (v9 == 1) {
    return 0LL;
  }
  if (v9 == 2) {
    return 2LL;
  }
  if (!*v4)
  {
    unsigned int v11 = (const char *)(a1 + 3328);
    goto LABEL_17;
  }

  unsigned int v11 = (const char *)(a1 + 10592);
  uint64_t result = _checkForDestinationConflict(a1, (char *)(a1 + 10592), a2, (uint64_t)v17, &v16, &v15);
  if (v15 != 1)
  {
LABEL_17:
    if (v4[1025] && !*(_DWORD *)(a1 + 12712))
    {
      if ((*(unsigned int (**)(void, uint64_t, uint64_t))(*(void *)(a1 + 12832) + 96LL))( *(void *)(*(void *)(a1 + 12832) + 8LL),  a1 + 11617,  a2) == -1) {
        goto LABEL_30;
      }
      if ((*(_WORD *)(a2 + 4) & 0xB000 | 0x4000) != 0x6000)
      {
        uint64_t v13 = a1;
        return _checkCopyFileError(v13);
      }
    }

    int v12 = *(_DWORD *)(a1 + 12716);
    if (v12 != 4)
    {
      if (v12 == 3)
      {
        _parentPath(v11, (char *)(a1 + 7424), 0x400uLL);
        __strlcat_chk();
        if (!(*(uint64_t (**)(void, uint64_t))(*(void *)(a1 + 12832) + 336LL))( *(void *)(*(void *)(a1 + 12832) + 8LL),  a1 + 7424)
          || (*(unsigned int (**)(void, uint64_t, void, void))(*(void *)(a1 + 12832) + 176LL))( *(void *)(*(void *)(a1 + 12832) + 8LL),  a1 + 7424,  *(unsigned __int16 *)(a2 + 4),  *(unsigned int *)(a2 + 24))
          || (*(unsigned int (**)(void, uint64_t, void, void))(*(void *)(a1 + 12832) + 192LL))( *(void *)(*(void *)(a1 + 12832) + 8LL),  a1 + 7424,  *(unsigned int *)(a2 + 16),  *(unsigned int *)(a2 + 20))
          || set_timestamps_0((const char *)(a1 + 7424), (__int128 *)(a2 + 32), (_OWORD *)(a2 + 48))
          || (*(unsigned int (**)(void, uint64_t, uint64_t))(*(void *)(a1 + 12832) + 264LL))( *(void *)(*(void *)(a1 + 12832) + 8LL),  a1 + 7424,  a1 + 3328))
        {
          goto LABEL_30;
        }
      }

      goto LABEL_31;
    }

    __strlcpy_chk();
    if (!BOMCPIOWriteDevice(*(void *)(a1 + 12736), (char *)(a1 + 7424), a2))
    {
LABEL_31:
      uint64_t v14 = *(void (**)(uint64_t, uint64_t, uint64_t, void, void))(a1 + 96);
      if (v14) {
        v14(a1, v6, v5, 0LL, 0LL);
      }
      return 0LL;
    }

LABEL_30:
    __error();
    uint64_t v13 = a1;
    return _checkCopyFileError(v13);
  }

  return result;
}

              uint64_t v22 = 1;
              if ((a2 & 0x10) == 0) {
                goto LABEL_38;
              }
              goto LABEL_31;
            }

            uint64_t v22 = 0;
            if ((a2 & 0x10) == 0)
            {
LABEL_38:
              if (v22) {
                goto LABEL_39;
              }
              goto LABEL_41;
            }

void *_unlockAFSCFileLock(void *result)
{
  if (result)
  {
    uint64_t result = (void *)*result;
    if (result)
    {
      uint64_t result = (void *)AFSCUnlockFile();
      if ((_DWORD)result) {
        return (void *)fprintf((FILE *)*MEMORY[0x1895F89D0], "Could not unlock AFSC file: %d\n", (_DWORD)result);
      }
    }
  }

  return result;
}

uint64_t _skipCPIOFile(uint64_t a1)
{
  if (BOMCPIOSeek() != -1LL) {
    return 0LL;
  }
  uint64_t v3 = __error();
  char v4 = strerror(*v3);
  BOMCopierNotifyFatalError(a1, "cpio seek error: %s", v5, v6, v7, v8, v9, v10, v4);
  return 2LL;
}

uint64_t _skipPKZipFile()
{
  uint64_t v0 = MEMORY[0x1895F8858]();
  uint64_t v2 = v1;
  uint64_t v3 = v0;
  uint64_t v43 = *MEMORY[0x1895F89C0];
  char v4 = (_BYTE *)(v0 + 12769);
  uint64_t File = BOMPKZipGetFile(*(void *)(v0 + 12752));
  uint64_t v6 = (int *)File;
  if (!*(_DWORD *)(v3 + 12776)) {
    goto LABEL_22;
  }
  BOMFileSetPartialRead(File, 1);
  if (*v4 && BOMFileSetCompression((uint64_t)v6, 1, 1, *(_DWORD *)(v3 + 12792)))
  {
    uint64_t v7 = __error();
    char v36 = strerror(*v7);
    uint64_t v14 = "pkzip set compression (1,1) error: %s";
LABEL_11:
    BOMCopierNotifyFatalError(v3, v14, v8, v9, v10, v11, v12, v13, v36);
    return 2LL;
  }

  while (!BOMFileEndOfCompressionStream((BOOL)v6))
  {
    if ((BOMFileRead(v6, v42, 0x20000uLL) & 0x8000000000000000LL) != 0)
    {
      char v16 = __error();
      char v36 = strerror(*v16);
      uint64_t v14 = "pkzip read seek error: %s";
      goto LABEL_11;
    }
  }

  if (*v4 && BOMFileSetCompression((uint64_t)v6, 0, 1, *(_DWORD *)(v3 + 12792)))
  {
    int v15 = __error();
    char v36 = strerror(*v15);
    uint64_t v14 = "pkzip set compression (0,1) error: %s";
    goto LABEL_11;
  }

  BOMFileSetPartialRead((uint64_t)v6, 0);
  if (BOMFileRead(v6, (char *)&v41, 4uLL) != 4)
  {
    uint64_t v19 = "pkzip read span error: %s";
LABEL_20:
    int v20 = __error();
    char v37 = strerror(*v20);
    BOMCopierNotifyFatalError(v3, v19, v21, v22, v23, v24, v25, v26, v37);
    return 2LL;
  }

  if (v41 != 134695760)
  {
    uint64_t v19 = "pkzip spanning doesn't match: %s";
    goto LABEL_20;
  }

  if (BOMPKZipReadDataDescriptor(*(int ***)(v3 + 12752), v4[43], &v40, &v39, &v38))
  {
    unint64_t v18 = __error();
    char v36 = strerror(*v18);
    uint64_t v14 = "Could not read pkzip data descriptor: %s";
    goto LABEL_11;
  }

  *(void *)(v2 + 96) = v38;
  uint64_t v27 = BOMPKZipGetFile(*(void *)(v3 + 12752));
  BOMFileSetPartialRead(v27, 1);
LABEL_22:
  if (*v4)
  {
    uint64_t v28 = BOMPKZipGetFile(*(void *)(v3 + 12752));
  }

  if (*(_DWORD *)(v3 + 12776)) {
    return 0LL;
  }
  uint64_t v29 = *(void *)(v3 + 12752);
  int NumLocalHeaders = BOMPKZipGetNumLocalHeaders(v29);
  uint64_t result = BOMPKZipGetFileCompressedSize(v29, NumLocalHeaders - 1);
  if ((_DWORD)result)
  {
    unint64_t v31 = result;
    while (1)
    {
      unint64_t v32 = v31 >= 0x20000 ? 0x20000LL : v31;
      unint64_t v33 = BOMFileRead(v6, v42, v32);
      if ((v33 & 0x8000000000000000LL) != 0) {
        break;
      }
      unint64_t v34 = v33;
      uint64_t result = 0LL;
      v31 -= v34;
      if (!v31) {
        return result;
      }
    }

    int v35 = __error();
    char v36 = strerror(*v35);
    uint64_t v14 = "pkzip seek error: %s";
    goto LABEL_11;
  }

  return result;
}

uint64_t _copyDataFork( uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, int a5, _DWORD *a6, _DWORD *a7, int a8)
{
  uint64_t v9 = a6;
  uint64_t v226 = *MEMORY[0x1895F89C0];
  uint64_t v223 = 0LL;
  v224 = 0LL;
  v221 = 0LL;
  uint64_t v222 = 0LL;
  v219 = 0LL;
  uint64_t v220 = 0LL;
  int v209 = *(_DWORD *)(a1 + 12716);
  int v13 = *(unsigned __int8 *)(a1 + 197);
  if (a6) {
    BOOL v14 = 1;
  }
  else {
    BOOL v14 = *(_BYTE *)(a1 + 173) != 0;
  }
  if (v209 == 5) {
    HIDWORD(v220) = crc32(0LL, 0LL, 0);
  }
  v215 = (_BYTE *)(a1 + 11616);
  if (*(_DWORD *)(a1 + 12712)) {
    int v15 = (const char *)(a1 + 248);
  }
  else {
    int v15 = *(const char **)(a1 + 2296);
  }
  v212 = v15;
  uint64_t v213 = a3;
  int v208 = v13;
  if (*(_DWORD *)(a1 + 12716) == 3)
  {
    if (*(_BYTE *)(a1 + 12823) || (a8 & 1) != 0)
    {
      if (*v215) {
        unint64_t v18 = (const char *)(a1 + 10592);
      }
      else {
        unint64_t v18 = (const char *)(a1 + 3328);
      }
      strncpy((char *)(a1 + 7424), v18, 0x400uLL);
    }

    else
    {
      if (*v215) {
        char v16 = (const char *)(a1 + 10592);
      }
      else {
        char v16 = (const char *)(a1 + 3328);
      }
      _parentPath(v16, (char *)(a1 + 7424), 0x400uLL);
      __strlcat_chk();
      if (!(*(uint64_t (**)(void, uint64_t))(*(void *)(a1 + 12832) + 336LL))( *(void *)(*(void *)(a1 + 12832) + 8LL),  a1 + 7424))
      {
        __error();
        return _checkCopyFileError(a1);
      }

      if (*(_DWORD *)(a1 + 12716) != 3) {
        goto LABEL_35;
      }
    }

    if (*(unsigned __int16 *)(a3 + 6) >= 2u)
    {
      v218 = 0LL;
      if (BOMHardLinkTableGetPathAndData( *(CFDictionaryRef **)a1,  *(_DWORD *)a3,  *(void *)(a3 + 8),  (char *)&v225,  &v218))
      {
        BOMHardLinkTableSetPathAndData( *(CFDictionaryRef **)a1,  *(_DWORD *)a3,  *(void *)(a3 + 8),  (char *)(a1 + 3328),  (const void *)(a3 + 96),  8uLL);
        goto LABEL_35;
      }

      if (*v218 == *(void *)(a3 + 96))
      {
        if (!a5
          || !(*(unsigned int (**)(void, uint64_t))(*(void *)(a1 + 12832) + 224LL))( *(void *)(*(void *)(a1 + 12832) + 8LL),  a1 + 3328))
        {
          if (!(*(unsigned int (**)(void, stat *, uint64_t))(*(void *)(a1 + 12832) + 240LL))( *(void *)(*(void *)(a1 + 12832) + 8LL),  &v225,  a1 + 3328))
          {
            uint64_t v43 = 0LL;
            *a7 = 2;
            goto LABEL_126;
          }

          if (*__error() == 18) {
            goto LABEL_35;
          }
        }

        __error();
        uint64_t v43 = _checkCopyFileError(a1);
LABEL_126:
        LOBYTE(a2) = 0;
        uint64_t v44 = 0LL;
        uint64_t v202 = 0LL;
        v203 = 0LL;
        int64_t v45 = 0LL;
        uint64_t v46 = 0LL;
        int v204 = 0;
        uint64_t v205 = 0LL;
        __src = 0LL;
        v207 = 0LL;
        int v200 = 0;
        goto LABEL_157;
      }
    }
  }

  else
  {
    if (*v215) {
      uint64_t v17 = (const char *)(a1 + 10592);
    }
    else {
      uint64_t v17 = v15;
    }
    strncpy((char *)(a1 + 7424), v17, 0x400uLL);
  }

LABEL_35:
  if (*(_BYTE *)(a1 + 204) == 1)
  {
    int v20 = strdup((const char *)(a1 + 3328));
    if (!v20)
    {
      uint64_t v29 = __error();
      strerror(*v29);
      BOMCopierNotifyFatalError(a1, "Could not duplicate %s: %s", v30, v31, v32, v33, v34, v35, a1);
      goto LABEL_43;
    }

    uint64_t v21 = v20;
    if (!dirname_r((const char *)(a1 + 3328), v20))
    {
      char v36 = __error();
      strerror(*v36);
      BOMCopierNotifyFatalError(a1, "Could not dirname %s: %s", v37, v38, v39, v40, v41, v42, a1);
      goto LABEL_42;
    }

    if (stat(v21, &v225))
    {
      uint64_t v22 = __error();
      strerror(*v22);
      BOMCopierNotifyFatalError(a1, "Could not stat %s: %s", v23, v24, v25, v26, v27, v28, (char)v21);
LABEL_42:
      free(v21);
      goto LABEL_43;
    }

    free(v21);
    if (*(_DWORD *)a3 == v225.st_dev)
    {
      if (!copyfile(a2, (const char *)(a1 + 3328), 0LL, 0x200000Fu))
      {
        LOBYTE(a2) = 0;
        uint64_t v44 = 0LL;
        uint64_t v202 = 0LL;
        v203 = 0LL;
        int64_t v45 = 0LL;
        uint64_t v46 = 0LL;
        int v204 = 0;
        uint64_t v205 = 0LL;
        __src = 0LL;
        v207 = 0LL;
        int v200 = 0;
        uint64_t v43 = 0LL;
        *a7 = 2;
        goto LABEL_157;
      }

      if (*__error() != 45)
      {
        uint64_t v93 = __error();
        strerror(*v93);
        BOMCopierNotifyFatalError(a1, "Could not clone %s to %s: %s", v94, v95, v96, v97, v98, v99, (char)a2);
LABEL_43:
        __error();
        uint64_t v43 = _checkCopyFileError(a1);
LABEL_44:
        LOBYTE(a2) = 0;
        uint64_t v44 = 0LL;
        uint64_t v202 = 0LL;
        v203 = 0LL;
        int64_t v45 = 0LL;
        uint64_t v46 = 0LL;
        int v204 = 0;
        uint64_t v205 = 0LL;
        __src = 0LL;
        v207 = 0LL;
        int v200 = 0;
        goto LABEL_168;
      }
    }
  }

  uint64_t v198 = (uint64_t)a2;
  LOBYTE(a2) = 0;
  uint64_t v44 = 0LL;
  uint64_t v202 = 0LL;
  v203 = 0LL;
  int64_t v45 = 0LL;
  uint64_t v46 = 0LL;
  uint64_t v205 = 0LL;
  __src = 0LL;
  v207 = 0LL;
  int v200 = 0;
  int v204 = 0;
  uint64_t v43 = 0LL;
  switch(*(_DWORD *)(a1 + 12712))
  {
    case 0:
      if (BOMFileOpenWithSys( &v224,  v198,  0LL,  0LL,  16 * (*(_BYTE *)(a1 + 12813) == 0),  *(void (***)(void, uint64_t, uint64_t, uint64_t))(a1 + 12832))) {
        goto LABEL_43;
      }
      uint64_t v43 = 0LL;
      goto LABEL_53;
    case 1:
      uint64_t v43 = 0LL;
      v224 = (int *)BOMCPIOGetFile(*(void *)(a1 + 12728));
      goto LABEL_53;
    case 2:
      uint64_t File = (int *)BOMPKZipGetFile(*(void *)(a1 + 12752));
      v224 = File;
      if (*(_BYTE *)(a1 + 12796))
      {
        if (*(void *)(a1 + 12800))
        {
          v211 = v9;
          uint64_t v43 = 0LL;
        }

        else
        {
          __int128 v89 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1 + 128);
          if (!v89)
          {
            BOMCopierNotifyFatalError( a1,  "No password was provided and the client did not provide a callback for retrieving the PKZip encryption key",  v51,  v52,  v53,  v54,  v55,  v56,  v197);
            uint64_t v43 = 2LL;
            goto LABEL_44;
          }

          uint64_t v43 = v89(a1, a1 + 248, a1 + 12800);
          if ((_DWORD)v43 == 2) {
            goto LABEL_44;
          }
          v211 = v9;
          uint64_t File = v224;
        }

        while (1)
        {
          uint64_t v57 = (int *)BOMFileSetKeys((uint64_t)v224, *(_BYTE **)(a1 + 12800));
          for (uint64_t i = 0LL; i != 12; ++i)
          {
            int v59 = *((unsigned __int8 *)&v225.st_dev + i);
            uint64_t v60 = decrypt_byte((uint64_t)v57) ^ v59;
            update_keys(v57, v60);
          }

          free(*(void **)(a1 + 12800));
          *(void *)(a1 + 12800) = 0LL;
          __int128 v67 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1 + 128);
          if (!v67)
          {
            BOMCopierNotifyFatalError( a1,  "The password appears to be invalid and the client did not provide a callback for retrieving a new PKZip encryption key",  v61,  v62,  v63,  v64,  v65,  v66,  v197);
LABEL_124:
            BOMCopierNotifyFatalError( a1,  "The password provided for the encrypted PKZip archive appears to be invalid",  v68,  v69,  v70,  v71,  v72,  v73,  v197);
            uint64_t v43 = 2LL;
            a3 = v213;
            goto LABEL_44;
          }

          uint64_t v43 = v67(a1, a1 + 248, a1 + 12800);
          if ((_DWORD)v43 == 2) {
            goto LABEL_124;
          }
        }

        unint64_t v105 = v224;
        uint64_t v106 = *(void *)(a1 + 12752);
        int NumLocalHeaders = BOMPKZipGetNumLocalHeaders(v106);
        FileCompresseduint64_t Size = BOMPKZipGetFileCompressedSize(v106, NumLocalHeaders - 1);
        BOMFileSetEncryptedRemainder((uint64_t)v105, FileCompressedSize - 12);
        a3 = v213;
        uint64_t v9 = v211;
      }

      else
      {
        uint64_t v43 = 0LL;
      }

      if (*(_BYTE *)(a1 + 12769))
      {
        *(void *)(a3 + 96) = -1LL;
      }

      if (*(_DWORD *)(a1 + 12776))
      {
        BOMFileSetPartialRead((uint64_t)v224, 1);
        if (!*(_BYTE *)(a1 + 12769))
        {
          uint64_t v90 = *(void *)(a1 + 12752);
          int v91 = BOMPKZipGetNumLocalHeaders(v90);
          FileUncompresseduint64_t Size = BOMPKZipGetFileUncompressedSize(v90, v91 - 1);
          *(void *)(a3 + 96) = FileUncompressedSize;
          if (!FileUncompressedSize)
          {
            BOMFileSetDataDescriptor((uint64_t)v224, 1);
            *(void *)(a3 + 96) = -1LL;
          }
        }
      }

    uint64_t v27 = v9;
    ArrayBySeparatingStrings = CFStringCreateArrayBySeparatingStrings(v10, v12, @"/");
    alloc = v10;
    MutableCopy = CFArrayCreateMutableCopy(v10, 0LL, ArrayBySeparatingStrings);
    CFRelease(v12);
    CFRelease(ArrayBySeparatingStrings);
    int Count = CFArrayGetCount(MutableCopy);
    if (Count >= 1)
    {
      unint64_t v18 = Count;
      for (uint64_t i = 0LL; i != v18; ++i)
      {
        int v20 = CFArrayGetCount(MutableCopy);
        if (v20 >= 1)
        {
          uint64_t v21 = v20;
          uint64_t v22 = 0LL;
          while (1)
          {
            ValueAtIndex = CFArrayGetValueAtIndex(MutableCopy, v22);
            if (CFEqual(ValueAtIndex, @"..")) {
              break;
            }
            if (v22 && (CFEqual(ValueAtIndex, @".") || CFEqual(ValueAtIndex, &stru_189E41230))) {
              goto LABEL_48;
            }
            if (v21 == ++v22) {
              goto LABEL_49;
            }
          }

          CFArrayRemoveValueAtIndex(MutableCopy, v22);
          if (v21 >= 2)
          {
            if (v22)
            {
              --v22;
LABEL_48:
              CFArrayRemoveValueAtIndex(MutableCopy, v22);
              continue;
            }
          }
        }

LABEL_220:
                int v152 = &v133[7 * v129];
                *(_DWORD *)int v152 = 4;
                v152[1] = 0LL;
                *((_DWORD *)v152 + 4) = 1;
                unsigned int v153 = v129 + 1;
                uint64_t v44 = v210;
                v152[3] = v210;
                v152[4] = 0LL;
                v152[5] = 0LL;
                v152[6] = 0LL;
                goto LABEL_221;
              }

              v207 = 0LL;
LABEL_258:
              a3 = v213;
LABEL_259:
              uint64_t v44 = v210;
            }
          }

          else
          {
            int v157 = BOM_calloc(0xA8uLL, 1uLL);
            if (v157)
            {
              uint64_t v128 = (uint64_t)v157;
              *int v157 = a1;
              uint64_t v158 = v223;
              v157[1] = v224;
              v157[2] = v158;
              v157[3] = v212;
              v157[4] = v44;
              v157[5] = v46;
              if (v14)
              {
                unsigned int v153 = 1;
                *((_DWORD *)v157 + 14) = 1;
                v157[8] = v45;
                *((_DWORD *)v157 + 18) = 1;
                v157[10] = 0LL;
                v157[11] = *(void *)(a1 + 8);
                v157[12] = 0LL;
                v157[13] = 0LL;
                int64_t v159 = v45;
                if ((_DWORD)a2)
                {
                  *((_DWORD *)v157 + 28) = 2;
                  v157[15] = v46 - v45;
                  *((_DWORD *)v157 + 32) = 1;
                  v157[17] = v45;
                  v157[18] = 0LL;
                  unsigned int v153 = 2;
                  v157[19] = v45;
                  v157[20] = 0LL;
                  int64_t v45 = v46;
                  goto LABEL_221;
                }
              }

              else
              {
                int64_t v159 = 0LL;
                unsigned int v153 = 0;
                if ((a2 & 1) != 0)
                {
                  *((_DWORD *)v157 + 14) = 2;
                  v157[8] = v46;
                  unsigned int v153 = 1;
                  *((_DWORD *)v157 + 18) = 1;
                  v157[10] = v45;
                  v157[11] = 0LL;
                  v157[12] = v45;
                  v157[13] = 0LL;
                  v45 += v46;
                  goto LABEL_221;
                }
              }

              if (v46 == -1 || v46 > v45)
              {
                uint64_t v160 = (uint64_t)&v157[7 * v153 + 7];
                *(_DWORD *)uint64_t v160 = 3;
                *(void *)(v160 + 8) = 0LL;
                *(_DWORD *)(v160 + 16) = 1;
                *(void *)(v160 + 24) = v45;
                *(void *)(v160 + 32) = 0LL;
                *(void *)(v160 + 40) = v159;
                *(void *)(v160 + 48) = 0LL;
                ++v153;
              }

LABEL_221:
              *(_DWORD *)(v128 + 48) = v153;
              uint64_t v154 = v44;
              _normalizeBomCopySpecification(v128, 0x1000u, *(_DWORD *)(a1 + 16), (size_t *)&v219);
              if ((*(_DWORD *)(a3 + 116) & 0x40000020) == 0x20
                && *(_BYTE *)(a1 + 195)
                && *((void *)v219 + 4) == *((void *)v219 + 5))
              {
                *(_BYTE *)(a1 + 196) = 0;
                if (!v208) {
                  goto LABEL_234;
                }
              }

              else
              {
                BOMFileSetAFSCCompression(v223);
                if (v209 == 5) {
                  uint64_t v155 = (unsigned int *)&v220 + 1;
                }
                else {
                  uint64_t v155 = 0LL;
                }
                if (v208) {
                  AAArchiveStream v156 = &v220;
                }
                else {
                  AAArchiveStream v156 = 0LL;
                }
                uint64_t v43 = _executeBomCopySpecification((int *)v219, 0x1000u, *(_DWORD *)(a1 + 16), v155, (uint64_t)v156, v45);
                if (!v208) {
                  goto LABEL_234;
                }
              }

              *(_DWORD *)(a1 + 200) = v220;
LABEL_234:
              free((void *)v128);
              free(v219);
              v219 = 0LL;
              if ((_DWORD)v43) {
                goto LABEL_235;
              }
              if (a5
                && *(_BYTE *)(a1 + 173)
                && *(_DWORD *)(a1 + 12716) == 3
                && !*a7
                && (v200 || (BOOL v162 = *(regex_t **)(a1 + 184)) != 0LL
                         && BOMPatternMatch(v162, *(const char **)(a1 + 2296))))
              {
                if (!*(void *)(a1 + 12936))
                {
                  ++*(void *)(a1 + 10576);
                  snprintf((char *)(a1 + 8448), 0x400uLL, "%s.dittoKeptBinary.%d.%lu");
                  goto LABEL_286;
                }

                uint64_t v161 = *(void *)(a1 + 10576);
                if (__ROR8__(0x8F5C28F5C28F5C29LL * v161, 1) <= 0x51EB851EB851EB8uLL)
                {
                  __int128 v184 = *(void **)(a1 + 10584);
                  if (v184) {
                    free(v184);
                  }
                  uuid_generate_random((unsigned __int8 *)&v225);
                  __int128 v185 = (char *)malloc(0x25uLL);
                  uuid_unparse((const unsigned __int8 *)&v225, v185);
                  __int128 v186 = (char *)malloc(0x400uLL);
                  *(void *)(a1 + 10584) = v186;
                  snprintf( v186,  0x400uLL,  "%s/%.2s/%.2s/%.2s/%s",  *(const char **)(a1 + 12936),  v185,  v185 + 2,  v185 + 4,  v185);
                  free(v185);
                  if (!_mkdirs(a1, *(void *)(a1 + 10584)))
                  {
                    uint64_t v161 = *(void *)(a1 + 10576);
                    goto LABEL_273;
                  }

                  uint64_t v187 = *(void *)(a1 + 10584);
                  __int128 v188 = __error();
                  __int128 v189 = *(void (**)(uint64_t, uint64_t, void))(a1 + 64);
                  if (v189) {
                    v189(a1, v187, *v188);
                  }
LABEL_302:
                  uint64_t v43 = 0LL;
                }

                else
                {
LABEL_273:
                  *(void *)(a1 + 10576) = v161 + 1;
                  snprintf((char *)(a1 + 8448), 0x400uLL, "%s/%lu");
LABEL_286:
                  uint64_t v169 = *(void *)(a1 + 12832);
                  uint64_t v170 = *(void *)(v169 + 8);
                  uint64_t v171 = a1 + 3328;
                  if ((*(_WORD *)(a4 + 4) & 0xF000) == 0x8000) {
                    int v172 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v169 + 240))(v170, v171, a1 + 8448);
                  }
                  else {
                    int v172 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v169 + 264))(v170, v171, a1 + 8448);
                  }
                  if (v172)
                  {
                    uint64_t v173 = __error();
                    uint64_t v165 = *(void (**)(uint64_t, uint64_t, uint64_t))(a1 + 64);
                    uint64_t v43 = 2LL;
                    if (v165)
                    {
                      uint64_t v166 = *v173;
                      uint64_t v168 = a1;
                      uint64_t v167 = a1 + 8448;
LABEL_292:
                      v165(v168, v167, v166);
                    }
                  }

                  else
                  {
                    uint64_t v174 = *(void *)(a1 + 176);
                    if (!v174) {
                      goto LABEL_244;
                    }
                    size_t v175 = strlen((const char *)(a1 + 8448));
                    if (BOMFileWrite(v174, (UInt8 *)(a1 + 8448), v175) == v175)
                    {
                      a3 = v213;
                      if (BOMFileWrite(*(void *)(a1 + 176), (UInt8 *)"\n", 1LL) == 1) {
                        goto LABEL_244;
                      }
                      stat v176 = __error();
                      char v177 = strerror(*v176);
                      BOMCopierNotifyFatalError( a1,  "can't write to keepBinariesList: %s",  v178,  v179,  v180,  v181,  v182,  v183,  v177);
                      uint64_t v43 = 2LL;
                    }

                    else
                    {
                      __int128 v190 = __error();
                      strerror(*v190);
                      BOMCopierNotifyFatalError( a1,  "can't write %s to keepBinariesList: %s",  v191,  v192,  v193,  v194,  v195,  v196,  a1);
                      uint64_t v43 = 2LL;
                      a3 = v213;
                    }

LABEL_235:
                    uint64_t v44 = v154;
                  }
                }
              }

              else
              {
LABEL_244:
                uint64_t v44 = v154;
                if (*(_DWORD *)(a1 + 12712) != 2) {
                  goto LABEL_278;
                }
                if (*(_BYTE *)(a1 + 12769)
                  && BOMFileSetCompression((uint64_t)v224, 0, 1, *(_DWORD *)(a1 + 12792)))
                {
LABEL_167:
                  __error();
                  uint64_t v43 = _checkCopyFileError(a1);
                }

                else
                {
                  BOMFileClearEncrypted((uint64_t)v224);
                  if (*(_DWORD *)(a1 + 12776))
                  {
                    BOMFileSetPartialRead((uint64_t)v224, 0);
                    BOMFileSetDataDescriptor((uint64_t)v224, 0);
                    if (BOMFileRead(v224, (char *)&v217, 4uLL) != 4
                      || v217 != 134695760
                      || BOMPKZipReadDataDescriptor( *(int ***)(a1 + 12752),  *(unsigned __int8 *)(a1 + 12812),  &v216,  (unint64_t *)&v225,  (unint64_t *)&v218))
                    {
                      goto LABEL_167;
                    }

                    *(void *)(a3 + 96) = v218;
                  }

LABEL_278:
                  if (*(_DWORD *)(a1 + 12716) != 5 || !*(void *)(a3 + 96)) {
                    goto LABEL_302;
                  }
                  uint64_t v163 = BOMFileOffset(v223) - v202;
                  v225.st_dev = 134695760;
                  uint64_t v202 = v163;
                  if (BOMFileWrite(v223, (UInt8 *)&v225, 4LL) != 4) {
                    goto LABEL_167;
                  }
                  uint64_t v43 = 0LL;
                  if (BOMPKZipWriteDataDescriptor(*(void *)(a1 + 12760), HIDWORD(v220), v163, *(_DWORD *)(a3 + 96)))
                  {
                    uint64_t v164 = __error();
                    uint64_t v165 = *(void (**)(uint64_t, uint64_t, uint64_t))(a1 + 64);
                    uint64_t v43 = 2LL;
                    if (v165)
                    {
                      uint64_t v166 = *v164;
                      uint64_t v167 = a1 + 8448;
                      uint64_t v168 = a1;
                      goto LABEL_292;
                    }
                  }
                }
              }
            }
          }
        }

        else
        {
          __error();
          uint64_t v43 = _checkCopyFileError(a1);
LABEL_156:
          uint64_t v44 = v110;
LABEL_157:
          int v118 = *(_DWORD *)(a1 + 12712);
          switch(v118)
          {
            case 3:
              uint64_t v43 = 2LL;
              break;
            case 2:
              *(void *)(a3 + 96) = 0LL;
              int v119 = _skipPKZipFile();
              goto LABEL_163;
            case 1:
              *(void *)(a3 + 96) -= v45;
              int v119 = _skipCPIOFile(a1);
LABEL_163:
              if (v119) {
                uint64_t v43 = 2LL;
              }
              else {
                uint64_t v43 = v43;
              }
              break;
          }
        }
      }

      BOMFileSetDataDescriptor((uint64_t)v224, 0);
      if (v224)
      {
        uint64_t v123 = v203;
        uint64_t v124 = __src;
        int v125 = v207;
        if (!*(_DWORD *)(a1 + 12712))
        {
          int v126 = BOMFileClose((uint64_t)v224);
          if (!(_DWORD)v43 && v126)
          {
            __error();
            uint64_t v43 = _checkCopyFileError(a1);
          }

          v224 = 0LL;
        }
      }

      else
      {
        uint64_t v123 = v203;
        uint64_t v124 = __src;
        int v125 = v207;
      }

      if (v123) {
        free(v123);
      }
      if (v221) {
        free(v221);
      }
      if (v124) {
        free(v124);
      }
      if (v125) {
        free(v125);
      }
      return v43;
    case 3:
      goto LABEL_168;
    default:
      uint64_t v43 = 0LL;
      goto LABEL_53;
  }

uint64_t _copyAppleDoubleToArchive(uint64_t a1, uint64_t a2, uint64_t a3, _DWORD *a4)
{
  uint64_t v35 = *MEMORY[0x1895F89C0];
  if (*(_DWORD *)(a1 + 12716) == 3) {
    goto LABEL_18;
  }
  uint64_t v8 = a1 + 11616;
  uint64_t v9 = *(void *)(a1 + 2296);
  uint64_t v10 = a1 + 7424;
  uint64_t v11 = *(_BYTE *)(a1 + 11616) ? (const char *)(a1 + 10592) : *(const char **)(a1 + 2296);
  uint64_t v12 = strncpy((char *)(a1 + 7424), v11, 0x400uLL);
  BOMAppleDoublePathToADPath(v12, (char *)(a1 + 5376));
  if (*(_BYTE *)(a1 + 170) || *(_BYTE *)(a1 + 169)) {
    int v13 = 4980740;
  }
  else {
    int v13 = 4980736;
  }
  uint64_t v14 = v13 | (*(_BYTE *)(a1 + 171) != 0);
  if (((*(unsigned int (**)(void, uint64_t, void, void, void))(*(void *)(a1 + 12832) + 344LL))( *(void *)(*(void *)(a1 + 12832) + 8LL),  a2,  0LL,  0LL,  v14 | 0x10000) & v14) == 0) {
    goto LABEL_18;
  }
  if (!issetugid()) {
    getenv("TMPDIR");
  }
  if (!(*(uint64_t (**)(void, uint64_t))(*(void *)(a1 + 12832) + 336LL))( *(void *)(*(void *)(a1 + 12832) + 8LL),  v10))
  {
LABEL_22:
    __error();
    return _checkCopyFileError(a1);
  }

  if ((*(unsigned int (**)(void, uint64_t, uint64_t, void, uint64_t))(*(void *)(a1 + 12832) + 344LL))( *(void *)(*(void *)(a1 + 12832) + 8LL),  a2,  v10,  0LL,  v14))
  {
    if (*__error() == 1 && *(void *)(a1 + 12840))
    {
LABEL_18:
      uint64_t v16 = 0LL;
      if (a4) {
        *a4 = 1;
      }
      return v16;
    }

    goto LABEL_22;
  }

  if (!(*(unsigned int (**)(void, uint64_t, _BYTE *))(*(void *)(a1 + 12832) + 96LL))( *(void *)(*(void *)(a1 + 12832) + 8LL),  v10,  v31))
  {
    unint64_t v17 = v32;
    BOOL v18 = *(_BYTE *)(v8 + 1197) == 0;
    uint64_t v30 = 0LL;
    if (!BOMFileOpenWithSys( &v30,  v10,  0LL,  0LL,  16 * v18,  *(void (***)(void, uint64_t, uint64_t, uint64_t))(a1 + 12832))
      || *__error() == 2)
    {
      (*(void (**)(void, uint64_t))(*(void *)(a1 + 12832) + 224LL))( *(void *)(*(void *)(a1 + 12832) + 8LL),  v10);
      *(void *)(a3 + 96) = v17;
      *(_WORD *)(a3 + 4) = *(_WORD *)(a3 + 4) & 0x1B6 | 0x8000;
      int v19 = *(_DWORD *)(a1 + 12716);
      if (v19 == 5)
      {
        if (*(_BYTE *)(v8 + 1152))
        {
          snprintf((char *)__str, 0x400uLL, "./%s/%s", "__MACOSX", (const char *)(a1 + 5378));
          _parentPath((const char *)__str, v33, 0x400uLL);
          __strlcpy_chk();
        }

        uint64_t File = BOMPKZipGetFile(*(void *)(a1 + 12760));
        int v29 = BOMFileOffset(File);
        if (v17)
        {
LABEL_37:
          unint64_t v22 = 0LL;
          unsigned int v23 = 0;
          while (!*(_BYTE *)(a1 + 168))
          {
            if (v17 - v22 >= 0x20000) {
              uint64_t v24 = 0x20000LL;
            }
            else {
              uint64_t v24 = v17 - v22;
            }
            v22 += v24;
            if (a4)
            {
              uint64_t v25 = *(void (**)(uint64_t, uint64_t, unint64_t))(a1 + 104);
              if (v25) {
                v25(a1, v9, *(void *)(a3 + 96) + v22);
              }
            }

            if (*(_DWORD *)(a1 + 12716) == 5) {
              unsigned int v23 = crc32(v23, *(const Bytef **)(a1 + 8), v24);
            }
            if (v22 >= v17) {
              goto LABEL_56;
            }
          }

          BOMFileClose((uint64_t)v30);
          return 2LL;
        }
      }

      else
      {
        if (v19 != 4)
        {
          BOMFileClose((uint64_t)v30);
          uint64_t v20 = a1;
          return _checkCopyFileError(v20);
        }

        uint64_t File = BOMCPIOGetFile(*(void *)(a1 + 12736));
        int v29 = 0;
        if (v17) {
          goto LABEL_37;
        }
      }

      unsigned int v23 = 0;
LABEL_56:
      if (*(_DWORD *)(a1 + 12716) != 5) {
        goto LABEL_64;
      }
      if (!BOMFileSetCompression(File, 0, 0, *(_DWORD *)(a1 + 12792)))
      {
        int v26 = BOMFileOffset(File);
        *(_DWORD *)__str = 134695760;
        if (BOMFileWrite(File, __str, 4LL) == 4)
        {
          if (BOMPKZipWriteDataDescriptor(*(void *)(a1 + 12760), v23, v26 - v29, *(_DWORD *)(a3 + 96)))
          {
            BOMFileClose((uint64_t)v30);
            uint64_t v27 = __error();
            uint64_t v28 = *(void (**)(uint64_t, uint64_t, void))(a1 + 64);
            if (v28) {
              v28(a1, a1 + 8448, *v27);
            }
            return 2LL;
          }

LABEL_62:
      BOMFileClose((uint64_t)v30);
      __error();
      uint64_t v20 = a1;
      return _checkCopyFileError(v20);
    }
  }

  __error();
  uint64_t v16 = _checkCopyFileError(a1);
  (*(void (**)(void, uint64_t))(*(void *)(a1 + 12832) + 224LL))( *(void *)(*(void *)(a1 + 12832) + 8LL),  v10);
  return v16;
}

uint64_t change_flags_0(uint64_t a1, char *a2, int a3, uint64_t a4)
{
  v9[0] = a3;
  v9[1] = a4;
  int v10 = -1;
  if (fsctl(a2, 0xC00C4114uLL, v9, 0))
  {
    if (*__error() != 25 && *__error() != 45) {
      return 1LL;
    }
    uint64_t result = (*(uint64_t (**)(void, char *, uint64_t))(*(void *)(a1 + 12832) + 208LL))( *(void *)(*(void *)(a1 + 12832) + 8LL),  a2,  a4);
    if (!(_DWORD)result) {
      return result;
    }
    BOOL v8 = *__error() == 45;
  }

  else
  {
    BOOL v8 = v9[0] == v10;
  }

  return !v8;
}

void *_parentPath(const char *a1, char *a2, size_t a3)
{
  uint64_t v6 = strrchr(a1, 47);
  if (!v6) {
    return (void *)strlcpy(a2, ".", a3);
  }
  int64_t v7 = v6 - a1;
  uint64_t result = memcpy(a2, a1, v6 - a1);
  a2[v7] = 0;
  return result;
}

uint64_t _insertQuarantinePath(uint64_t a1, char *a2, uint64_t a3)
{
  uint64_t v18 = *MEMORY[0x1895F89C0];
  char v16 = 0;
  if (v16) {
    return 0LL;
  }
  _parentPath(a2, v17, 0x401uLL);
  if ((_DWORD)a3)
  {
    __int128 v14 = 0u;
    __int128 v15 = 0u;
    __int128 v12 = 0u;
    __int128 v13 = 0u;
    __int128 v10 = 0u;
    __int128 v11 = 0u;
    __int128 v8 = 0u;
    __int128 v9 = 0u;
    __int128 v7 = 0u;
    WORD2(v7) = 16893;
    LODWORD(v8) = geteuid();
    DWORD1(v8) = getegid();
    *(void *)&__int128 v9 = time(0LL);
    *(void *)&__int128 v10 = time(0LL);
    *(void *)&__int128 v11 = time(0LL);
    *(void *)&__int128 v13 = 748LL;
  }

  else {
    return 0LL;
  }
}

uint64_t _copyFromCPIO(uint64_t a1, uint64_t a2, uint64_t a3, char *a4, size_t a5, int a6)
{
  __int16 v84 = 0;
  __int128 v9 = (_BYTE *)(a1 + 248);
  unsigned int v10 = strlen((const char *)(a1 + 248));
  __int128 v11 = (char *)BOM_malloc(v10 + 2);
  if (!v11) {
    return 2LL;
  }
  __int128 v12 = v11;
  memmove(v11, v9, v10);
  if (v10)
  {
    unsigned int v13 = v10 + 1;
    v12[v10] = 47;
    v12[v10 + 1] = 0;
  }

  else
  {
    unsigned int v13 = 0;
  }

  uint64_t v82 = v12;
  uint64_t v72 = 0LL;
  uint64_t v73 = 0LL;
  unint64_t v15 = 0LL;
  int v16 = 0;
  int __s1 = (char *)(a1 + 7424);
  __source = 0LL;
  unsigned int v77 = (char *)(a1 + 3328);
  size_t v17 = v13;
  size_t v78 = v13;
  while (1)
  {
    unsigned int v85 = 0;
    uint64_t v18 = (char *)v82;
    if (*(_BYTE *)(a1 + 12721) == 1)
    {
      *__error() = 0;
      __strlcpy_chk();
      int v19 = BOMCPIOReadHeader(*(void *)(a1 + 12728), v9, a2);
      if (v19) {
        break;
      }
    }

    int v26 = v9;
    if (*v9 == 46)
    {
      if (*(_BYTE *)(a1 + 249) == 47) {
        int v26 = (const char *)(a1 + 249);
      }
      else {
        int v26 = v9;
      }
    }

    if (strlcpy(a4, v26, a5) >= a5)
    {
      uint64_t v55 = *(void (**)(uint64_t, const char *, uint64_t))(a1 + 64);
      if (v55) {
        v55(a1, v26, 63LL);
      }
      goto LABEL_110;
    }

    if ((!a6 || *(_BYTE *)(a1 + 12822)) && *v26 == 46 && (!v26[1] || v26[1] == 47 && !v26[2]))
    {
      if (_chPerms(a1, v77, a2, &v84, 1))
      {
        uint64_t v27 = __error();
        uint64_t v28 = *(void (**)(uint64_t, char *, void))(a1 + 64);
        if (v28) {
          v28(a1, v77, *v27);
        }
      }

      LOWORD(v73) = *(_WORD *)(a2 + 4);
    }

    if (strncmp(v9, v82, v17))
    {
      *(_BYTE *)(a1 + 12721) = 0;
      v82[(v17 - 1)] = 0;
      uint64_t v54 = *(void (**)(uint64_t, const char *, uint64_t, void, void))(a1 + 96);
      uint64_t v53 = __source;
      if (v54) {
        goto LABEL_84;
      }
      goto LABEL_85;
    }

    BOOL v35 = 1;
    *(_BYTE *)(a1 + 12721) = 1;
    if (*(_BYTE *)(a1 + 169) && *(_DWORD *)(a1 + 12716) == 3 && (*(_WORD *)(a2 + 4) & 0xF000) == 0x8000) {
      BOOL v35 = BOMAppleDoubleIsADFile(v9) == 0;
    }
    if (!*(_BYTE *)(a1 + 12824) || (*(_WORD *)(a2 + 4) & 0xF000) != 0x8000) {
      goto LABEL_37;
    }
    if (!v16 && *(void *)(a2 + 96) == 0x40000000LL)
    {
      int v36 = 0;
      int v16 = 1;
      goto LABEL_38;
    }

    if ((v16 == 2 || v16 == 1) && !strcmp(__s1, v9))
    {
      int v16 = 2;
      int v36 = 1;
    }

    else
    {
LABEL_37:
      int v36 = 0;
      int v16 = 0;
    }

LABEL_38:
    if (*(_DWORD *)(a1 + 12716) == 3
      && (unsigned int v37 = _checkForDestinationConflict(a1, v77, a2, a3, (_BYTE *)&v84 + 1, &v85), v85 == 1))
    {
      unsigned int v45 = v37;
      int v46 = HIDWORD(v73);
      if (v45 == 1) {
        int v46 = 1;
      }
      HIDWORD(v73) = v46;
      size_t v17 = v78;
    }

    else
    {
      uint64_t v38 = *(void *)(a1 + 152);
      if (v38)
      {
        uint64_t FSObjectAtPath = BOMBomGetFSObjectAtPath(v38, v9);
        if (!FSObjectAtPath) {
          goto LABEL_46;
        }
        BOMFSObjectFree(FSObjectAtPath);
      }

      uint64_t v40 = *(void *)(a1 + 160);
      if (v40)
      {
        BOOL v41 = BOMBomFSObjectExistsAtPath(v40, *(void *)(a1 + 2296));
        __int16 v42 = *(_WORD *)(a2 + 4);
        if (!v41 || (v42 & 0xF000) == 0x4000) {
          goto LABEL_50;
        }
LABEL_46:
        unsigned int v85 = 1;
        size_t v17 = v78;
      }

      else
      {
        __int16 v42 = *(_WORD *)(a2 + 4);
LABEL_50:
        HIDWORD(v43) = v42 & 0xF000;
        LODWORD(v43) = HIDWORD(v43) - 0x2000;
        switch((v43 >> 13))
        {
          case 0u:
          case 2u:
            int v44 = _copyDevice(a1, a2);
            goto LABEL_60;
          case 1u:
            char v70 = a5;
            int v44 = _copyDir(a1, a2, a3, 0LL, HIBYTE(v84), 0LL, 0LL, a4);
            goto LABEL_60;
          case 3u:
            int v44 = _copyFile(a1, a2, a3, HIBYTE(v84), *(_DWORD **)(a1 + 136), &v85, v36);
            goto LABEL_60;
          case 4u:
            int v44 = _copyLink(a1, a2, a3, SHIBYTE(v84));
LABEL_60:
            if (v44 == 1)
            {
              HIDWORD(v73) = 1;
            }

            else if (v44 == 2)
            {
              goto LABEL_110;
            }

      if (v11 == v47)
      {
        uint64_t v29 = 1;
        uint64_t v30 = Size;
      }

      else if (v11)
      {
        if (v11 == 1)
        {
          uint64_t v30 = Size;
          if (!v47)
          {
            uint64_t v29 = 3;
LABEL_67:
            uint64_t v31 = 0LL;
            a2[4] = v29;
            a2[5] = v47;
            *((void *)a2 + 3) = v48;
            a2[8] = v11;
            *((void *)a2 + 5) = v30;
            return v31;
          }

          BOOL v35 = (unint64_t *)(v48 + 24);
          int v36 = v9;
          do
          {
            if (*((_BYTE *)v35 - 24))
            {
              *(v35 - 1) = 0LL;
              uint64_t v30 = *v35;
            }

            v35 += 5;
            --v36;
          }

          while (v36);
          uint64_t v29 = 3;
        }

        else
        {
          uint64_t v30 = Size;
          uint64_t v29 = v45;
          if (v11 < v47)
          {
            Binaryint Type = BOMCopierSourceEntryGetBinaryType(a1);
            uint64_t v39 = 20;
            if (BinaryType == 4) {
              uint64_t v39 = 32;
            }
            uint64_t v30 = v39 * (unint64_t)v11 + 8;
            uint64_t v40 = v48 + 32;
            BOOL v41 = v9;
            do
            {
              if (*((_BYTE *)v40 - 32))
              {
                __int16 v42 = (v30 + (1 << *v40) - 1) & -(uint64_t)(1 << *v40);
                *((void *)v40 - 2) = v42;
                uint64_t v30 = v42 + *((void *)v40 - 1);
              }

              v40 += 10;
              --v41;
            }

            while (v41);
            uint64_t v29 = 4;
          }
        }
      }

      else
      {
        uint64_t v30 = 0LL;
        uint64_t v29 = 2;
      }

      if (v47)
      {
        unint64_t v43 = v48 + 16;
        do
        {
          if (!*((_BYTE *)v43 - 16)) {
            *unint64_t v43 = -1LL;
          }
          v43 += 5;
          --v9;
        }

        while (v9);
      }

      goto LABEL_67;
    }

    uint64_t v31 = 22LL;
    BOMCopierErrorCapture( a3,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierMatchRecord.c",  294,  (uint64_t)"BOMCopierMatchBinary",  "match_context is NULL");
  }

  else
  {
    uint64_t v31 = 22LL;
    BOMCopierErrorCapture( a3,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierMatchRecord.c",  288,  (uint64_t)"BOMCopierMatchBinary",  "source_entry is NULL");
  }

  return v31;
}

LABEL_85:
  if (v53)
  {
    if (v15)
    {
      uint64_t v56 = 0LL;
      uint64_t v57 = v53 + 16;
      do
      {
        unsigned int v58 = (char **)&v53[16 * v56];
        if (*v58)
        {
          __strlcpy_chk();
          __strlcat_chk();
          BOMAppleDoubleADPathToPath(*v58, __s1);
          HIDWORD(v73) = _mergeAppleDouble(a1, &v83);
          if (!v83) {
            (*(void (**)(void, uint64_t))(*(void *)(a1 + 12832) + 224LL))( *(void *)(*(void *)(a1 + 12832) + 8LL),  a1 + 1272);
          }
          uint64_t v59 = v56 + 1;
          if (v56 + 1 < v15)
          {
            uint64_t v60 = &__source[16 * v56 + 8];
            uint64_t v61 = &v57[16 * v56];
            uint64_t v62 = v56 + 1;
            do
            {
              uint64_t v63 = *(char **)v61;
              if (*(void *)v61 && *(void *)v60 == *((void *)v61 + 1) && !strcmp(*v58, *(const char **)v61))
              {
                free(v63);
                *(void *)uint64_t v61 = 0LL;
                *((void *)v61 + 1) = 0LL;
              }

              ++v62;
              v61 += 16;
            }

            while (v15 != v62);
          }

          free(*v58);
          int *v58 = 0LL;
          v58[1] = 0LL;
          uint64_t v53 = __source;
        }

        else
        {
          uint64_t v59 = v56 + 1;
        }

        uint64_t v56 = v59;
      }

      while (v59 != v15);
    }

    free(v53);
    uint64_t v18 = (char *)v82;
  }

  *a4 = 0;
  if ((_BYTE)v84)
  {
    if ((*(unsigned int (**)(void, char *, void))(*(void *)(a1 + 12832) + 200LL))( *(void *)(*(void *)(a1 + 12832) + 8LL),  v77,  (unsigned __int16)v73))
    {
      uint64_t v64 = __error();
      uint64_t v65 = *(void (**)(uint64_t, char *, void))(a1 + 64);
      if (v65) {
        v65(a1, v77, *v64);
      }
    }
  }

  if (getenv("PRESERVECOMPRESSION"))
  {
    uint64_t v28 = (const void *)*MEMORY[0x189604DE8];
    CFDictionarySetValue( *(CFMutableDictionaryRef *)(a1 + 13008),  @"discoverCompressionAttributes",  (const void *)*MEMORY[0x189604DE8]);
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13024), @"preserveAppleFSCompression", v28);
  }

  uint64_t v29 = *(os_log_s **)(a1 + 13000);
  if (v29)
  {
    if (!os_log_type_enabled(*(os_log_t *)(a1 + 13000), OS_LOG_TYPE_DEFAULT)
      || (uint64_t v30 = *(void *)(a1 + 13008),
          *(_DWORD *)statfs buf = 138412290,
          *(void *)&uint8_t buf[4] = v30,
          _os_log_impl(&dword_1862F3000, v29, OS_LOG_TYPE_DEFAULT, "source options: %@", buf, 0xCu),
          (uint64_t v29 = *(os_log_s **)(a1 + 13000)) != 0LL))
    {
      if (os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v31 = *(void *)(a1 + 13024);
        *(_DWORD *)statfs buf = 138412290;
        *(void *)&uint8_t buf[4] = v31;
        _os_log_impl(&dword_1862F3000, v29, OS_LOG_TYPE_DEFAULT, "destination options: %@", buf, 0xCu);
        uint64_t v29 = *(os_log_s **)(a1 + 13000);
      }
    }
  }

  uint64_t v32 = BOMCopierSourceNew(a2, *(const __CFDictionary **)(a1 + 13008), (uint64_t)v29, &v108);
  *(void *)(a1 + 13016) = v32;
  if (!v32)
  {
    BOMCopierErrorCapture( &v108,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c",  783,  (uint64_t)"prepare_copy_state",  "Could not create BOMCopierSource");
    goto LABEL_225;
  }

  uint64_t v33 = BOMCopierDestinationNew(a3, *(const __CFDictionary **)(a1 + 13024), &v108);
  *(void *)(a1 + 13032) = v33;
  if (!v33)
  {
    BOMCopierErrorCapture( &v108,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c",  790,  (uint64_t)"prepare_copy_state",  "Could not create BOMCopierDestination");
    goto LABEL_225;
  }

  BOMCopierDestinationSetLog(v33, *(void *)(a1 + 13000));
  if (BOMCopierSourceSetErrorHandler(*(void **)(a1 + 13016), (uint64_t)source_error_handler, a1, &v108))
  {
    BOMCopierErrorCapture( &v108,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c",  803,  (uint64_t)"prepare_copy_state",  "Could not set BOMCopierSource error handler");
    goto LABEL_225;
  }

  if (*(void *)(a1 + 128))
  {
    if (BOMCopierSourceSetPassphraseCallback( *(void *)(a1 + 13016),  (uint64_t)passphrase_callback,  a1,  &v108))
    {
      BOMCopierErrorCapture( &v108,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c",  816,  (uint64_t)"prepare_copy_state",  "Could not set BOMCopierSource passphrase callback");
      goto LABEL_225;
    }

    uint64_t v34 = *(os_log_s **)(a1 + 13000);
    if (v34 && os_log_type_enabled(*(os_log_t *)(a1 + 13000), OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)statfs buf = 0;
      _os_log_impl(&dword_1862F3000, v34, OS_LOG_TYPE_DEFAULT, "Set passphrase callback", buf, 2u);
    }
  }

  BOOL v35 = (uint64_t *)(a1 + 13032);
  int v36 = *(void *)(a1 + 13040);
  if (v36)
  {
    if (BOMCopierDestinationSetAllowBom(*v35, v36, &v108))
    {
      BOMCopierErrorCapture( &v108,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c",  832,  (uint64_t)"prepare_copy_state",  "Could not set allow bom for destination");
      goto LABEL_225;
    }

    unsigned int v37 = *(os_log_s **)(a1 + 13000);
    if (v37 && os_log_type_enabled(*(os_log_t *)(a1 + 13000), OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)statfs buf = 0;
      _os_log_impl(&dword_1862F3000, v37, OS_LOG_TYPE_DEFAULT, "Set allow bom with destination", buf, 2u);
    }
  }

  uint64_t v38 = *(void *)(a1 + 13048);
  if (v38)
  {
    if (BOMCopierDestinationSetDenyBom(*v35, v38, &v108))
    {
      BOMCopierErrorCapture( &v108,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c",  844,  (uint64_t)"prepare_copy_state",  "Could not set deny bom for destination");
      goto LABEL_225;
    }

    uint64_t v39 = *(os_log_s **)(a1 + 13000);
    if (v39 && os_log_type_enabled(*(os_log_t *)(a1 + 13000), OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)statfs buf = 0;
      _os_log_impl(&dword_1862F3000, v39, OS_LOG_TYPE_DEFAULT, "Set deny bom with destination", buf, 2u);
    }
  }

  if (v8[1440])
  {
    uint64_t v40 = *(void *)(a1 + 13040);
    if (!v40)
    {
      BOMCopierErrorCapture( &v108,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c",  855,  (uint64_t)"prepare_copy_state",  "The client did not provide an index bom to use for enumeration");
      goto LABEL_225;
    }

    if (BOMCopierSourceSetEnumerationBom(*(void *)(a1 + 13016), v40, &v108))
    {
      BOMCopierErrorCapture( &v108,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c",  862,  (uint64_t)"prepare_copy_state",  "Could not set enumeration bom for source");
      goto LABEL_225;
    }

    BOOL v41 = *(os_log_s **)(a1 + 13000);
    if (v41 && os_log_type_enabled(*(os_log_t *)(a1 + 13000), OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)statfs buf = 0;
      _os_log_impl(&dword_1862F3000, v41, OS_LOG_TYPE_DEFAULT, "Set enumeration bom with source", buf, 2u);
    }
  }

  if (v8[1441])
  {
    __int16 v42 = *(void *)(a1 + 13040);
    if (!v42)
    {
      BOMCopierErrorCapture( &v108,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c",  873,  (uint64_t)"prepare_copy_state",  "The client did not provide an index bom to use for checksum validation");
      goto LABEL_225;
    }

    if (BOMCopierDestinationSetChecksumBom(*v35, v42, &v108))
    {
      BOMCopierErrorCapture( &v108,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c",  880,  (uint64_t)"prepare_copy_state",  "Could not set checksum bom for destination");
      goto LABEL_225;
    }

    unint64_t v43 = *(os_log_s **)(a1 + 13000);
    if (v43 && os_log_type_enabled(*(os_log_t *)(a1 + 13000), OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)statfs buf = 0;
      _os_log_impl(&dword_1862F3000, v43, OS_LOG_TYPE_DEFAULT, "Set enumeration bom with destination", buf, 2u);
    }
  }

  if (BOMCopierDestinationSetConflictResolver( *(void *)(a1 + 13032),  (uint64_t)conflict_resolver,  a1,  &v108))
  {
    BOMCopierErrorCapture( &v108,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c",  894,  (uint64_t)"prepare_copy_state",  "Could not set conflict resolver");
    goto LABEL_225;
  }

  if (BOMCopierDestinationSetDataWrittenCallback( *(void *)(a1 + 13032),  (uint64_t)data_written_callback,  a1,  &v108))
  {
    BOMCopierErrorCapture( &v108,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c",  905,  (uint64_t)"prepare_copy_state",  "Could not set data written callback");
    goto LABEL_225;
  }

  if (BOMCopierDestinationSetFinalizationCallback( *(void *)(a1 + 13032),  (uint64_t)finalization_callback,  a1,  &v108))
  {
    BOMCopierErrorCapture( &v108,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c",  916,  (uint64_t)"prepare_copy_state",  "Could not set finalization callback");
    goto LABEL_225;
  }

  uint64_t v14 = *(void *)(a1 + 13000);
  if (v14 && os_log_type_enabled(*(os_log_t *)(a1 + 13000), OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)statfs buf = 0;
    _os_log_impl(&dword_1862F3000, (os_log_t)v14, OS_LOG_TYPE_DEFAULT, "Copy state prepared", buf, 2u);
    uint64_t v14 = *(void *)(a1 + 13000);
  }

  bzero(buf, 0x430uLL);
  *(_DWORD *)statfs buf = 1;
  int v50 = *(void *)(a1 + 8);
  *(void *)&buf[8] = a1 + 13032;
  BOOL v112 = v50;
  uint64_t v51 = *(int *)(a1 + 16);
  uint64_t v52 = *(void *)(a1 + 24);
  uint64_t v114 = *(void *)(a1 + 32);
  uint64_t v115 = v52;
  char v113 = v51;
  if (v14 && os_log_type_enabled((os_log_t)v14, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)int v109 = 0;
    _os_log_impl(&dword_1862F3000, (os_log_t)v14, OS_LOG_TYPE_DEFAULT, "Starting copy", v109, 2u);
  }

  while (1)
  {
    uint64_t v53 = *(os_log_s **)(a1 + 13000);
    if (*(_BYTE *)(a1 + 168) == 1)
    {
      if (v53 && os_log_type_enabled(*(os_log_t *)(a1 + 13000), OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)int v109 = 0;
        uint64_t v96 = "Client cancelled";
        uint64_t v14 = 2LL;
        uint64_t v97 = v53;
LABEL_245:
        _os_log_impl(&dword_1862F3000, v97, OS_LOG_TYPE_DEFAULT, v96, v109, 2u);
        goto LABEL_227;
      }

LABEL_106:
  uint64_t v14 = HIDWORD(v73);
LABEL_116:
  free(v18);
  return v14;
}

uint64_t _copyFromPKZip(uint64_t a1, uint64_t a2, uint64_t a3, char *a4, size_t a5)
{
  int64_t v99 = 0LL;
  int v98 = 0;
  unsigned __int8 v97 = 0;
  unsigned int v10 = (_BYTE *)(a1 + 248);
  unsigned int v11 = strlen((const char *)(a1 + 248));
  __int128 v12 = (char *)BOM_malloc(v11 + 2);
  if (!v12) {
    return 2LL;
  }
  unsigned int v13 = v12;
  uint64_t v14 = v11;
  memmove(v12, v10, v11);
  if (v11)
  {
    ++v11;
    v13[v14] = 47;
    v13[v11] = 0;
  }

  unint64_t v15 = (_DWORD *)(a1 + 12772);
  if (BOMPKZipReadNextSignature(*(void *)(a1 + 12752), (int *)(a1 + 12772)))
  {
    uint64_t v22 = "Couldn't read PKZip signature";
LABEL_6:
    BOMCopierNotifyFatalError(a1, v22, v16, v17, v18, v19, v20, v21, v84);
    uint64_t v23 = 2LL;
    goto LABEL_7;
  }

  uint64_t v25 = (_BYTE *)(a1 + 12721);
  if (*v15 == 2)
  {
    uint64_t v23 = 0LL;
    _BYTE *v25 = 0;
    goto LABEL_7;
  }

  if (*v15 != 1)
  {
    uint64_t v22 = "Incorrect pkzip signature";
    goto LABEL_6;
  }

  uint64_t v91 = a3;
  uint64_t v93 = 0LL;
  unint64_t __dst = a4;
  unint64_t v26 = 0LL;
  uint64_t v87 = 0LL;
  unsigned int v27 = v11;
  uint64_t v23 = 0LL;
  uint64_t v95 = (int *)(a1 + 12776);
  unsigned int v86 = v27;
  size_t __n = v27;
  int v88 = (char *)(a1 + 7424);
  __int128 v89 = (_BYTE *)(a1 + 249);
  __s = (char *)(a1 + 3328);
  while (1)
  {
    v100[0] = 0;
    if (!*v25) {
      goto LABEL_19;
    }
    if (BOMPKZipReadLocalHeader( *(void *)(a1 + 12752),  v10,  a2,  (unint64_t *)&v99,  &v98,  (_BYTE *)(a1 + 12796),  v95,  (unsigned int *)(a1 + 12808),  (_BYTE *)(a1 + 12812)))
    {
      uint64_t v69 = "Couldn't read pkzip local header";
      goto LABEL_113;
    }

    char v34 = v98;
    if (v98)
    {
      if (v98 == 8)
      {
        char v34 = 1;
        goto LABEL_18;
      }

      uint64_t v69 = "Unknown compression type";
LABEL_113:
      BOMCopierNotifyFatalError(a1, v69, v28, v29, v30, v31, v32, v33, v84);
      goto LABEL_114;
    }

LABEL_59:
    uint64_t v55 = *(void *)(a1 + 152);
    if (v55)
    {
      uint64_t FSObjectAtPath = BOMBomGetFSObjectAtPath(v55, v10);
      if (!FSObjectAtPath) {
        goto LABEL_65;
      }
      BOMFSObjectFree(FSObjectAtPath);
    }

    uint64_t v57 = *(void *)(a1 + 160);
    if (v57)
    {
      BOOL v58 = BOMBomFSObjectExistsAtPath(v57, *(void *)(a1 + 2296));
      __int16 v59 = *(_WORD *)(a2 + 4);
      if (v58 && (v59 & 0xF000) != 0x4000)
      {
LABEL_65:
        goto LABEL_78;
      }
    }

    else
    {
      __int16 v59 = *(_WORD *)(a2 + 4);
    }

    HIDWORD(v61) = v59 & 0xF000;
    LODWORD(v61) = HIDWORD(v61) - 0x2000;
    int v60 = v61 >> 13;
    if (v60 == 1)
    {
      char v84 = a5;
      uint64_t v62 = _copyDir(a1, a2, v91, 0LL, v97, 0LL, 0LL, __dst);
    }

    else
    {
      if (v60 != 3) {
        goto LABEL_76;
      }
      uint64_t v62 = _copyFile(a1, a2, v91, v97, *(_DWORD **)(a1 + 136), v100, 0);
    }

    if ((_DWORD)v62 == 1)
    {
      uint64_t v23 = 1LL;
    }

    else if ((_DWORD)v62 == 2)
    {
      uint64_t v23 = v62;
      goto LABEL_115;
    }

        const char *v26 = 0;
LABEL_60:
        BOMStackPoke(*(void **)(a1 + 32), 3LL);
        unsigned int v11 = 0;
LABEL_61:
        if (!v11) {
          continue;
        }
LABEL_67:
        FSObjectWithBlockID = _BOMBomGetFSObjectWithBlockID(*(void *)a1, v4);
        if (FSObjectWithBlockID)
        {
          uint64_t v46 = __s;
          unint64_t v47 = strrchr(__s, 47);
          if (v47) {
            uint64_t v46 = v47 + 1;
          }
          BOMFSObjectSetPathName((uint64_t)FSObjectWithBlockID, __s, 1);
          BOMFSObjectSetShortName((uint64_t)FSObjectWithBlockID, v46, 1);
          BOMFSObjectSetPathID((uint64_t)FSObjectWithBlockID, v5);
          BOMFSObjectSetParentPathID((uint64_t)FSObjectWithBlockID, v6);
          BOMFSObjectSetBlockID((uint64_t)FSObjectWithBlockID, v4);
          BOMFSObjectSetVisitOrder((uint64_t)FSObjectWithBlockID, v8);
        }

        return FSObjectWithBlockID;
      case 2u:
        if (BOMTreeIteratorIsAtEnd(v10)
          || (uint64_t v28 = (unsigned int *)BOMTreeIteratorKey(v10),
              uint64_t v6 = BOMPathIDFromPathKey(v28),
              v6 != BOMStackPeek(*(void **)(a1 + 16))))
        {
          unsigned int v11 = 0;
        }

        else
        {
          if ((*(_BYTE *)(a1 + 44) & 2) != 0)
          {
            uint64_t v44 = (unsigned int *)BOMTreeIteratorKey(v10);
            uint64_t v6 = BOMPathIDFromPathKey(v44);
            uint64_t v45 = (unsigned int *)BOMTreeIteratorValue(v10);
            uint64_t v5 = BOMPathIDFromPathKey(v45);
            char v4 = BOMBlockIDFromPathValue((uint64_t)v45);
            __strlcpy_chk();
            __int128 v8 = 2;
            unsigned int v11 = 1;
          }

          else
          {
            unsigned int v11 = 0;
          }

          BOMTreeIteratorNext(v10);
        }

        uint64_t v29 = (unsigned __int8 *)(*(void *)(a1 + 1080) - 1LL);
        while (1)
        {
          uint64_t v30 = v29 + 1;
          *(void *)(a1 + 1080) = v29;
          uint64_t v31 = *v29--;
          if (v31 == 47)
          {
            uint64_t v30 = v29 + 1;
            break;
          }
        }

        int *v30 = 0;
LABEL_37:
        if (!BOMTreeIteratorIsAtEnd(v10)
          && *(_BYTE *)(a1 + 48)
          && (uint64_t v33 = BOMStackPeek(*(void **)(a1 + 16)),
              char v34 = (unsigned int *)BOMTreeIteratorKey(v10),
              BOMPathIDFromPathKey(v34) == v33)
          && ((*(_BYTE *)(a1 + 44) & 4) != 0 || *(_DWORD *)(a1 + 40) != BOMStackPeek(*(void **)(a1 + 16))))
        {
          uint64_t v23 = *(void **)(a1 + 32);
          uint64_t v24 = 0LL;
        }

        else
        {
          uint64_t v32 = BOMStackPop(*(uint64_t **)(a1 + 24));
          BOMTreeIteratorFree((char *)v32);
          BOMStackPop(*(uint64_t **)(a1 + 16));
          BOMStackPop(*(uint64_t **)(a1 + 32));
LABEL_39:
          uint64_t v23 = *(void **)(a1 + 32);
          uint64_t v24 = 2LL;
        }

LABEL_78:
    if (*v15 != 1) {
      goto LABEL_87;
    }
  }

  _BYTE *v25 = 0;
  v13[v86 - 1] = 0;
  size_t v71 = *(void (**)(uint64_t, char *, uint64_t, void, void))(a1 + 96);
  if (v71) {
    v71(a1, v13, 2LL, 0LL, 0LL);
  }
LABEL_87:
  char *__dst = 0;
  _BYTE *v25 = 0;
  if (v86 >= 2)
  {
    v13[v86 - 1] = 0;
    uint64_t v72 = *(void (**)(uint64_t, char *, uint64_t, void, void))(a1 + 96);
    if (v72) {
      v72(a1, v13, 2LL, 0LL, 0LL);
    }
  }

  uint64_t v73 = v93;
  if (v93)
  {
    if (v26)
    {
      uint64_t v74 = 0LL;
      unint64_t v75 = (void *)(a1 + 8448);
      do
      {
        int v76 = &v73[16 * v74];
        if (*(void *)v76)
        {
          __strlcpy_chk();
          __strlcat_chk();
          BOMAppleDoubleADPathToPath(*(char **)v76, v75);
          if (*(_BYTE *)(a1 + 12768)
            && (unsigned int v77 = *(_DWORD *)(a1 + 12780), !strncmp(*(const char **)(a1 + 12784), (const char *)v75, v77)))
          {
            __strlcpy_chk();
            strlcpy(&v88[v77 - 8], (const char *)v75 + v77 + 1, 1024LL - (v77 - 8));
          }

          else
          {
            __strlcpy_chk();
          }

          int v96 = 0;
          uint64_t v23 = _mergeAppleDouble(a1, &v96);
          if (!v96) {
            (*(void (**)(void, uint64_t))(*(void *)(a1 + 12832) + 224LL))( *(void *)(*(void *)(a1 + 12832) + 8LL),  a1 + 1272);
          }
          uint64_t v78 = v74 + 1;
          if (v74 + 1 < v26)
          {
            size_t v79 = &v93[16 * v74 + 8];
            uint64_t v80 = v26 - 1 - v74;
            uint64_t v81 = (uint64_t)&v93[16 * v74 + 16];
            do
            {
              uint64_t v82 = *(char **)v81;
              if (*(void *)v81
                && *(void *)v79 == *(void *)(v81 + 8)
                && !strcmp(*(const char **)v76, *(const char **)v81))
              {
                free(v82);
                *(void *)uint64_t v81 = 0LL;
                *(void *)(v81 + 8) = 0LL;
              }

              v81 += 16LL;
              --v80;
            }

            while (v80);
          }

          free(*(void **)v76);
          *(void *)int v76 = 0LL;
          *((void *)v76 + 1) = 0LL;
          uint64_t v74 = v78;
          uint64_t v73 = v93;
          unint64_t v75 = (void *)(a1 + 8448);
        }

        else
        {
          ++v74;
        }
      }

      while (v74 != v26);
    }

    goto LABEL_120;
  }

uint64_t _mergeAppleDouble(uint64_t a1, _DWORD *a2)
{
  if (*(_BYTE *)(a1 + 169) || *(_BYTE *)(a1 + 170) || *(_BYTE *)(a1 + 171))
  {
    if ((*(unsigned int (**)(void, uint64_t, _BYTE *))(*(void *)(a1 + 12832) + 96LL))( *(void *)(*(void *)(a1 + 12832) + 8LL),  a1 + 1272,  v17))
    {
      __error();
      return _checkCopyFileError(a1);
    }

    if ((*(unsigned int (**)(void, uint64_t, _BYTE *))(*(void *)(a1 + 12832) + 96LL))( *(void *)(*(void *)(a1 + 12832) + 8LL),  a1 + 7424,  v17))
    {
      *__error() = 0;
      uint64_t v4 = 0LL;
      if (a2) {
        *a2 = 0;
      }
      return v4;
    }

    __int128 v15 = v19;
    __int128 v16 = v18;
    uint64_t v14 = 0LL;
    if (!*(_BYTE *)(a1 + 12848) && !*(_BYTE *)(a1 + 195) || (uint64_t v14 = AFSCLockFilePath()) != 0)
    {
      if (*(_BYTE *)(a1 + 170) || *(_BYTE *)(a1 + 169)) {
        int v6 = 9175044;
      }
      else {
        int v6 = 9175040;
      }
      if (copyfile((const char *)(a1 + 1272), (const char *)(a1 + 7424), 0LL, v6 | (*(_BYTE *)(a1 + 171) != 0)) < 0)
      {
        if (*__error() == 45) {
          *a2 = 0;
        }
        goto LABEL_26;
      }

      acl_t file = acl_get_file((const char *)(a1 + 7424), ACL_TYPE_EXTENDED);
      if (file)
      {
        __int128 v8 = file;
        __int128 v9 = acl_init(0);
        if (!v9
          || (v10 = v9, int v11 = acl_set_file((const char *)(a1 + 7424), ACL_TYPE_EXTENDED, v9), free(v10), v11)
          || (int v12 = acl_set_file((const char *)(a1 + 7424), ACL_TYPE_EXTENDED, v8), acl_free(v8), v12))
        {
LABEL_26:
          __error();
          uint64_t v13 = a1;
LABEL_32:
          uint64_t v4 = _checkCopyFileError(v13);
LABEL_33:
          _unlockAFSCFileLock(&v14);
          return v4;
        }
      }

      if (!set_timestamps_0((const char *)(a1 + 7424), &v16, &v15) || *__error() == 13)
      {
        uint64_t v4 = 0LL;
        if (a2) {
          *a2 = 0;
        }
        goto LABEL_33;
      }
    }

    __error();
    uint64_t v13 = a1;
    goto LABEL_32;
  }

  uint64_t v4 = 0LL;
  if (a2) {
    *a2 = 1;
  }
  return v4;
}

uint64_t _enforceDestinationLocation(uint64_t a1, char *a2)
{
  if (lstat(a2, &v14))
  {
    if (*__error() == 2) {
      return 0LL;
    }
    goto LABEL_6;
  }

  if ((v14.st_mode & 0xF000) == 0xA000)
  {
    if (stat(a2, &v13))
    {
LABEL_6:
      unsigned int v10 = __error();
      int v11 = *(void (**)(uint64_t, char *, void))(a1 + 64);
      if (v11) {
        v11(a1, a2, *v10);
      }
      return 0xFFFFFFFFLL;
    }

    if (v14.st_dev != v13.st_dev)
    {
      BOMCopierNotifyFatalError(a1, "%s exists on a different device from its target", v4, v5, v6, v7, v8, v9, (char)a2);
      return 0xFFFFFFFFLL;
    }
  }

  return 0LL;
}

uint64_t _resolveDestinationPath(uint64_t a1, const char *a2, char *a3)
{
  if (*a2 != 47 && !getcwd(a3, 0x400uLL))
  {
    uint64_t v39 = __error();
    char v49 = strerror(*v39);
    uint64_t v38 = "Could not get current working directory: %s\n";
    goto LABEL_18;
  }

  uint64_t v6 = (char *)calloc(0x400uLL, 1uLL);
  if (!v6)
  {
    uint64_t v38 = "Could not allocate unresolved prefix\n";
LABEL_18:
    BOMCopierNotifyFatalError(a1, v38, v7, v8, v9, v10, v11, v12, v49);
    return 0xFFFFFFFFLL;
  }

  stat v13 = v6;
  stat v14 = (char *)calloc(0x400uLL, 1uLL);
  if (v14)
  {
    uint64_t v21 = v14;
    while (1)
    {
      uint64_t v22 = strchr(a2, 47);
      uint64_t v29 = v22;
      if (v22)
      {
        int64_t v30 = v22 - a2;
        if ((unint64_t)(v22 - a2) >= 0x400)
        {
          BOMCopierNotifyFatalError( a1,  "Unresolved path component too large: %ld\n",  v23,  v24,  v25,  v26,  v27,  v28,  (_BYTE)v22 - (_BYTE)a2);
          goto LABEL_28;
        }

        strncpy(v13, a2, 0x400uLL);
        v13[v30] = 0;
        a2 = v29 + 1;
      }

      else
      {
        if (snprintf(v21, 0x400uLL, "%s/%s", a3, a2) >= 0x400)
        {
LABEL_27:
          BOMCopierNotifyFatalError( a1,  "Could not construct path to resolve: %s %s %ld\n",  v31,  v32,  v33,  v34,  v35,  v36,  (char)a3);
          goto LABEL_28;
        }

        a2 = 0LL;
      }

      if (!(*(uint64_t (**)(void, char *, char *))(*(void *)(a1 + 12832) + 160LL))( *(void *)(*(void *)(a1 + 12832) + 8LL),  v21,  a3)) {
        break;
      }
      if (!v29) {
        goto LABEL_14;
      }
    }

    if (*__error() == 2)
    {
      if (!a2)
      {
LABEL_14:
        free(v21);
        free(v13);
        return 0LL;
      }

      size_t v40 = strlen(a3);
      if (v40 + strlen(a2) + 2 <= 0x3FF)
      {
        *(_WORD *)&a3[strlen(a3)] = 47;
        strncat(a3, a2, 0x400uLL);
        goto LABEL_14;
      }

      BOMCopierNotifyFatalError(a1, "Concatenated path too large: %s %s %ld\n", v41, v42, v43, v44, v45, v46, (char)a3);
    }

    else
    {
      unint64_t v47 = __error();
      uint64_t v48 = *(void (**)(uint64_t, char *, void))(a1 + 64);
      if (v48) {
        v48(a1, v21, *v47);
      }
    }

uint64_t _restoreSymlinks(uint64_t a1, int a2)
{
  uint64_t v4 = 0LL;
  while (!BOMStackIsEmpty(*(void *)(a1 + 40)))
  {
    uint64_t v5 = (void **)BOMStackPop(*(uint64_t **)(a1 + 40));
    if ((*(unsigned int (**)(void, void *, void *))(*(void *)(a1 + 12832) + 264LL))( *(void *)(*(void *)(a1 + 12832) + 8LL),  v5[1],  *v5))
    {
      uint64_t v6 = *v5;
      uint64_t v7 = __error();
      uint64_t v8 = *(void (**)(uint64_t, void *, void))(a1 + 64);
      if (v8) {
        v8(a1, v6, *v7);
      }
      if (!a2)
      {
        free(*v5);
        free(v5[1]);
        free(v5[2]);
        free(v5);
        return 1LL;
      }

      uint64_t v4 = 1LL;
    }

    else
    {
      uint64_t v9 = *(void (**)(uint64_t, void *, uint64_t, void, void))(a1 + 96);
      if (v9) {
        v9(a1, v5[2], 3LL, 0LL, 0LL);
      }
    }

    free(*v5);
    free(v5[1]);
    free(v5[2]);
    free(v5);
  }

  return v4;
}

uint64_t BOMCopierPrepareMatchContext(const __CFDictionary *a1, uint64_t a2, void *a3)
{
  uint64_t v49 = *MEMORY[0x1895F89C0];
  if (!a2)
  {
    uint64_t v40 = 22LL;
    BOMCopierErrorCapture( a3,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierMatchRecord.c",  42,  (uint64_t)"BOMCopierPrepareMatchContext",  "match_context is NULL");
    return v40;
  }

  CFTypeID TypeID = CFArrayGetTypeID();
  if (!a1) {
    goto LABEL_46;
  }
  CFTypeID v7 = TypeID;
  unint64_t Value = (const __CFArray *)CFDictionaryGetValue(a1, @"archs");
  uint64_t v9 = Value;
  if (Value && CFGetTypeID(Value) != v7)
  {
    BOMCopierErrorCapture( a3,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierMatchRecord.c",  61,  (uint64_t)"BOMCopierPrepareMatchContext",  "kBOMCopierOptionArchitectureArrayKey is not a CFArrayRef");
    return 1LL;
  }

  CFTypeID v10 = CFDictionaryGetTypeID();
  uint64_t v11 = (const __CFDictionary *)CFDictionaryGetValue(a1, @"fallbackForSubtype");
  uint64_t v12 = v11;
  if (v11 && CFGetTypeID(v11) != v10)
  {
    BOMCopierErrorCapture( a3,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierMatchRecord.c",  75,  (uint64_t)"BOMCopierPrepareMatchContext",  "kBOMCopierOptionArchitectureFallbackKey is not a CFDictionaryRef");
    return 1LL;
  }

  if (!v9)
  {
LABEL_46:
    uint64_t v15 = 0LL;
    LODWORD(Count) = 0;
LABEL_47:
    uint64_t v40 = 0LL;
    *(_DWORD *)a2 = Count;
    *(void *)(a2 + 8) = v15;
    return v40;
  }

  int64_t Count = CFArrayGetCount(v9);
  stat v14 = calloc(Count, 0x20uLL);
  if (!v14)
  {
    BOMCopierErrorCapture( a3,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierMatchRecord.c",  92,  (uint64_t)"BOMCopierPrepareMatchContext",  "Could not allocate bom_cpu_type_list");
    return 1LL;
  }

  uint64_t v15 = v14;
  CFTypeID v44 = v7;
  CFTypeID v46 = CFStringGetTypeID();
  if (Count < 1) {
    goto LABEL_47;
  }
  CFIndex v16 = 0LL;
  theDict = v12;
  while (1)
  {
    ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(v9, v16);
    if (!ValueAtIndex)
    {
      BOMCopierErrorCapture( a3,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierMatchRecord.c",  105,  (uint64_t)"BOMCopierPrepareMatchContext",  "Could not retrieve item %d from architecture list");
LABEL_63:
      uint64_t v42 = v15;
      goto LABEL_64;
    }

    uint64_t v18 = ValueAtIndex;
    if (v46 != CFGetTypeID(ValueAtIndex))
    {
      BOMCopierErrorCapture( a3,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierMatchRecord.c",  112,  (uint64_t)"BOMCopierPrepareMatchContext",  "Item %d from architecture list is not a CFString");
      goto LABEL_63;
    }

    if (!CFStringGetCString(v18, buffer, 255LL, 0x8000100u))
    {
      BOMCopierErrorCapture( a3,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierMatchRecord.c",  120,  (uint64_t)"BOMCopierPrepareMatchContext",  "Item %d from architecture list could not converted to a UTF8 string");
      goto LABEL_63;
    }

    uint64_t v19 = BOMGetArchInfoFromName(buffer);
    if (!v19)
    {
      BOMCopierErrorCapture( a3,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierMatchRecord.c",  128,  (uint64_t)"BOMCopierPrepareMatchContext",  "Could not resolve architecture info for %s");
      goto LABEL_63;
    }

    uint64_t v20 = v19;
    uint64_t v21 = BOMGetArchInfoFromCpuType(*((_DWORD *)v19 + 2), -1);
    if (!v21)
    {
      BOMCopierErrorCapture( a3,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierMatchRecord.c",  136,  (uint64_t)"BOMCopierPrepareMatchContext",  "Could not resolve family architecture info for %s");
      goto LABEL_63;
    }

    int v22 = *((_DWORD *)v20 + 3);
    int v23 = *((_DWORD *)v21 + 2);
    BOOL v26 = v22 == 3 && v23 == 16777223 || v22 != *((_DWORD *)v21 + 3);
    if (v22) {
      BOOL v27 = 0;
    }
    else {
      BOOL v27 = v23 == 16777228;
    }
    if (v27) {
      BOOL v26 = 1;
    }
    if (!v26) {
      int v22 = -1;
    }
    CFIndex v28 = (CFIndex)v15 + 32 * v16;
    *(_DWORD *)CFIndex v28 = v23;
    *(_BYTE *)(v28 + 4) = !v26;
    *(_DWORD *)(v28 + 8) = v22;
    *(void *)(v28 + 16) = 0LL;
    uint64_t v29 = (void *)(v28 + 16);
    *(_DWORD *)(v28 + 24) = 0;
    int64_t v30 = (_DWORD *)(v28 + 24);
    if (!theDict) {
      goto LABEL_43;
    }
    uint64_t v31 = (const __CFArray *)CFDictionaryGetValue(theDict, v18);
    if (!v31) {
      goto LABEL_43;
    }
    uint64_t v32 = v31;
    if (v44 != CFGetTypeID(v31))
    {
      BOMCopierErrorCapture( a3,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierMatchRecord.c",  172,  (uint64_t)"BOMCopierPrepareMatchContext",  "Corresponding fallback entry for item %d from architecture list is not a CFArray");
      goto LABEL_63;
    }

    uint64_t v43 = v15;
    int64_t v33 = CFArrayGetCount(v32);
    if (v33 >= 1) {
      break;
    }
LABEL_42:
    uint64_t v15 = v43;
LABEL_43:
    if (++v16 == Count) {
      goto LABEL_47;
    }
  }

  int64_t v34 = v33;
  uint64_t v35 = calloc(v33, 4uLL);
  CFIndex v36 = 0LL;
  void *v29 = v35;
  uint64_t v37 = v35;
  _DWORD *v30 = v34;
  while (1)
  {
    uint64_t v38 = (const __CFString *)CFArrayGetValueAtIndex(v32, v36);
    if (!v38)
    {
      BOMCopierErrorCapture( a3,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierMatchRecord.c",  193,  (uint64_t)"BOMCopierPrepareMatchContext",  "Could not retrieve item %d from fallback list");
      goto LABEL_56;
    }

    uint64_t v39 = v38;
    if (v46 != CFGetTypeID(v38))
    {
      BOMCopierErrorCapture( a3,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierMatchRecord.c",  201,  (uint64_t)"BOMCopierPrepareMatchContext",  "Item %d from fallback list is not a CFString");
      goto LABEL_56;
    }

    if (!CFStringGetCString(v39, __s2, 255LL, 0x8000100u)) {
      break;
    }
    v37[v36++] = *((_DWORD *)BOMGetArchInfoFromName(__s2) + 3);
    if (v34 == v36) {
      goto LABEL_42;
    }
  }

  BOMCopierErrorCapture( a3,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierMatchRecord.c",  210,  (uint64_t)"BOMCopierPrepareMatchContext",  "Item %d from fallback list could not converted to a UTF8 string");
LABEL_56:
  free(v37);
  uint64_t v42 = v43;
LABEL_64:
  free(v42);
  return 1LL;
}

uint64_t BOMCopierReleaseMatchContext(unsigned int *a1, void *a2)
{
  if (a1)
  {
    uint64_t v3 = *a1;
    uint64_t v4 = (void **)*((void *)a1 + 1);
    if ((_DWORD)v3)
    {
      uint64_t v5 = v4 + 2;
      do
      {
        if (*v5) {
          free(*v5);
        }
        v5 += 4;
        --v3;
      }

      while (v3);
    }

    else if (!v4)
    {
LABEL_11:
      uint64_t v6 = 0LL;
      *a1 = 0;
      *((void *)a1 + 1) = 0LL;
      return v6;
    }

    free(v4);
    goto LABEL_11;
  }

  uint64_t v6 = 22LL;
  BOMCopierErrorCapture( a2,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierMatchRecord.c",  250,  (uint64_t)"BOMCopierReleaseMatchContext",  "match_context is NULL");
  return v6;
}

uint64_t BOMCopierMatchBinary(uint64_t a1, unsigned int *a2, void *a3)
{
  if (a1)
  {
    if (a2)
    {
      unint64_t v6 = *a2;
      uint64_t v7 = *((void *)a2 + 1);
      a2[4] = 2;
      *((void *)a2 + 5) = 0LL;
      *(void *)(a2 + 7) = 0LL;
      *(void *)(a2 + 5) = 0LL;
      Archint64_t Count = BOMCopierSourceEntryGetArchCount(a1);
      uint64_t v9 = ArchCount;
      uint64_t v48 = (char *)calloc(ArchCount, 0x28uLL);
      if (!v48)
      {
        int v32 = *__error();
        int64_t v33 = __error();
        int64_t v34 = strerror(*v33);
        BOMCopierErrorCapture( a3,  v32,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierMatchRecord.c",  323,  (uint64_t)"BOMCopierMatchBinary",  "Could not allocate empty match record list: %s",  v34);
        return 1LL;
      }

      uint64_t Size = BOMCopierSourceEntryGetSize(a1);
      int v10 = *a2;
      if (*a2) {
        unsigned int v11 = 0;
      }
      else {
        unsigned int v11 = ArchCount;
      }
      if (v10) {
        int v12 = 2;
      }
      else {
        int v12 = 1;
      }
      int v45 = v12;
      unsigned int v47 = ArchCount;
      if (ArchCount)
      {
        uint64_t v13 = 0LL;
        BOOL v14 = v10 == 0;
        if ((_DWORD)v6) {
          BOOL v15 = v10 == 0;
        }
        else {
          BOOL v15 = 1;
        }
        while (!BOMCopierSourceEntryGetArchRecord(a1, v13, &v49, a3))
        {
          CFIndex v16 = (BOOL *)&v48[40 * v13];
          *CFIndex v16 = v14;
          int v17 = v49;
          *((_DWORD *)v16 + 1) = v49;
          int v18 = v50;
          *((_DWORD *)v16 + 2) = v50;
          *((_OWORD *)v16 + 1) = v51;
          *((void *)v16 + 4) = v52;
          if (!v15)
          {
            unint64_t v19 = 0LL;
            uint64_t v20 = (_DWORD *)(v7 + 8);
            do
            {
              if (v17 == *(v20 - 2) && (*((_BYTE *)v20 - 4) || ((*v20 ^ v18) & 0xFFFFFF) == 0))
              {
                *CFIndex v16 = 1;
                ++v11;
                goto LABEL_37;
              }

              v20 += 8;
              ++v19;
            }

            while (v19 < v6);
            if (!v15)
            {
              unint64_t v22 = 0LL;
              do
              {
                int v23 = (int *)(v7 + 32 * v22);
                if (*((_BYTE *)v23 + 4) || (uint64_t v25 = v23[6], !(_DWORD)v25))
                {
                  char v24 = 0;
                }

                else
                {
                  uint64_t v26 = 0LL;
                  char v24 = 0;
                  int v27 = *v23;
                  uint64_t v28 = 4 * v25;
                  do
                  {
                    if (v17 == v27 && v18 == *(_DWORD *)(*(void *)(v7 + 32 * v22 + 16) + v26))
                    {
                      char v24 = 1;
                      *CFIndex v16 = 1;
                      ++v11;
                    }

                    v26 += 4LL;
                  }

                  while (v28 != v26);
                }

                if ((v24 & 1) != 0) {
                  break;
                }
                ++v22;
              }

              while (v22 < v6);
            }
          }

uint64_t BOMFSOArchInfoInitialize()
{
  uint64_t v0 = MEMORY[0x1895F8858]();
  uint64_t v35 = *MEMORY[0x1895F89C0];
  else {
    unint64_t v2 = *(void *)(v1 + 96);
  }
  if (*(_DWORD *)v0 != 1) {
    return 0LL;
  }
  uint64_t v3 = v0;
  uint64_t v4 = *(_BYTE **)(v0 + 24);
  if (v4)
  {
    unint64_t v2 = *(unsigned int *)(v0 + 32);
    goto LABEL_7;
  }

  uint64_t v26 = *(unsigned int *)(v0 + 16);
  if ((_DWORD)v26 != -1)
  {
    if (*(void *)(v0 + 144))
    {
      snprintf(__str, 0x401uLL, "%s/%s", *(const char **)(v0 + 144), *(const char **)(v0 + 72));
      uint64_t v26 = *(unsigned int *)(v3 + 16);
    }

    if ((*(uint64_t (**)(void, uint64_t, void, void))(*(void *)(v3 + 160) + 64LL))( *(void *)(*(void *)(v3 + 160) + 8LL),  v26,  0LL,  0LL) < 0) {
      return 0LL;
    }
    uint64_t v4 = v34;
    if ((*(uint64_t (**)(void, void, _BYTE *, unint64_t))(*(void *)(v3 + 160) + 48LL))( *(void *)(*(void *)(v3 + 160) + 8LL),  *(unsigned int *)(v3 + 16),  v34,  v2) == v2)
    {
LABEL_7:
      if (v2 < 8) {
        return 0LL;
      }
      uint64_t v5 = *(unsigned int *)(v3 + 16);
      if (BOMArchFlagForHeader((int *)v4, v2) == 2)
      {
        int v6 = bswap32(*((_DWORD *)v4 + 1));
        uint64_t v7 = 20LL * v6 + 8;
        if (v7 <= (uint64_t)v2
          || (_DWORD)v5 != -1
          && (*(uint64_t (**)(void, uint64_t, _BYTE *))(*(void *)(v3 + 160) + 48LL))( *(void *)(*(void *)(v3 + 160) + 8LL),  v5,  &v4[v2]) == v7 - v2)
        {
          *(_WORD *)(v3 + 40) |= 2 << B_ARCHOFFT;
          *(_DWORD *)(v3 + 104) = v6;
          *(void *)(v3 + 112) = BOM_malloc(24LL * v6);
          if (v6 >= 1)
          {
            unsigned int v32 = v5;
            uint64_t v8 = 0LL;
            uint64_t v9 = (unsigned int *)(v4 + 20);
            uint64_t v10 = 24LL * v6;
            while (1)
            {
              unsigned int v11 = *(v9 - 3);
              if (*(_DWORD *)v4 == -889275714)
              {
                uint64_t v12 = *(void *)(v3 + 112) + v8;
                *(_DWORD *)uint64_t v12 = v11;
                unsigned int v13 = *(v9 - 2);
                *(_DWORD *)(v12 + 4) = v13;
                unint64_t v14 = *v9;
                *(void *)(v12 + 8) = v14;
                unsigned int v15 = *(v9 - 1);
              }

              else
              {
                uint64_t v16 = *(void *)(v3 + 112) + v8;
                *(_DWORD *)uint64_t v16 = bswap32(v11);
                unsigned int v13 = *(v9 - 2);
                *(_DWORD *)(v16 + 4) = bswap32(v13);
                unint64_t v14 = bswap32(*v9);
                *(void *)(v16 + 8) = v14;
                unsigned int v15 = bswap32(*(v9 - 1));
              }

              uint64_t v17 = v15;
              unint64_t v18 = v14 + v15;
              if (v18 > *(void *)(v3 + 64))
              {
                unint64_t v19 = *(const char **)(v3 + 72);
                uint64_t v20 = BOMGetArchInfoFromCpuType(v11, v13);
                if (v20)
                {
                  uint64_t v21 = *v20;
                }

                else
                {
                  unsigned int v31 = v11;
                  uint64_t v21 = _cpuNameForType_generic;
                  snprintf(_cpuNameForType_generic, 0x50uLL, "<cputype %d, subtype %d>", v31, v13);
                }

                char v24 = BOMExceptionHandlerMessage( "file %s is corrupt: slice for %s extends beyond length of file. (%lu > %lld)\n",  v19,  v21,  v18,  *(void *)(v3 + 64));
                uint64_t v25 = __error();
                _BOMExceptionHandlerCall( (uint64_t)v24,  1,  "/Library/Caches/com.apple.xbs/Sources/Bom/FSObject/BOMFSOArchInfo.c",  470,  *v25);
                goto LABEL_28;
              }

              *(_DWORD *)__str = 0;
              uint64_t v22 = *(void *)(v3 + 24);
              if (v22)
              {
              }

              else
              {
                if ((*(uint64_t (**)(void, void))(*(void *)(v3 + 160) + 64LL))( *(void *)(*(void *)(v3 + 160) + 8LL),  v32) == -1)
                {
                  int v23 = 0;
                  goto LABEL_25;
                }

                if (BOMCRC32ForFileDesc(v32, __str, v14)) {
LABEL_23:
                }
                  *(_DWORD *)__str = 0;
              }

              int v23 = *(_DWORD *)__str;
LABEL_25:
              *(_DWORD *)(*(void *)(v3 + 112) + v8 + 16) = v23;
LABEL_28:
              v8 += 24LL;
              v9 += 5;
              if (v10 == v8) {
                return 1LL;
              }
            }
          }

          return 1LL;
        }
      }

      if (v2 < 0x1C) {
        return 0LL;
      }
      int v28 = *(_DWORD *)v4;
      if (*(_DWORD *)v4 != -17958194)
      {
        if (v28 == -822415874)
        {
LABEL_44:
          int v29 = bswap32(*((_DWORD *)v4 + 1));
          int v30 = bswap32(*((_DWORD *)v4 + 2));
LABEL_50:
          _handleMachO_common(v3, v29, v30);
          return 1LL;
        }

        if (v2 < 0x20) {
          return 0LL;
        }
        if (v28 != -17958193)
        {
          if (v28 != -805638658) {
            return 0LL;
          }
          goto LABEL_44;
        }
      }

      int v29 = *((_DWORD *)v4 + 1);
      int v30 = *((_DWORD *)v4 + 2);
      goto LABEL_50;
    }
  }

  return 1LL;
}

void BOMFSOArchInfoRelease(uint64_t a1)
{
  unint64_t v2 = *(void **)(a1 + 112);
  if (v2) {
    free(v2);
  }
  *(void *)(a1 + 112) = 0LL;
}

uint64_t BOMFSOArchInfoCopy(uint64_t a1, uint64_t a2)
{
  uint64_t result = 1LL;
  if (a1 && a2)
  {
    *(_DWORD *)(a2 + 104) = *(_DWORD *)(a1 + 104);
    uint64_t v5 = BOM_malloc(24LL * *(int *)(a1 + 104));
    *(void *)(a2 + 112) = v5;
    if (v5)
    {
      if (*(_DWORD *)(a2 + 104))
      {
        uint64_t v6 = 0LL;
        unint64_t v7 = 0LL;
        do
        {
          uint64_t v8 = *(void *)(a2 + 112) + v6;
          uint64_t v9 = (__int128 *)(*(void *)(a1 + 112) + v6);
          __int128 v10 = *v9;
          *(void *)(v8 + 16) = *((void *)v9 + 2);
          *(_OWORD *)uint64_t v8 = v10;
          ++v7;
          v6 += 24LL;
        }

        while (v7 < *(unsigned int *)(a2 + 104));
      }

      return 0LL;
    }

    else
    {
      return 1LL;
    }
  }

  return result;
}

uint64_t BOMFSOArchInfoContainsArchitecture(uint64_t a1, int a2)
{
  uint64_t v2 = *(unsigned int *)(a1 + 104);
  if (!(_DWORD)v2) {
    return 0LL;
  }
  uint64_t v3 = *(int **)(a1 + 112);
  while (1)
  {
    int v4 = *v3;
    v3 += 6;
    if (v4 == a2) {
      break;
    }
    if (!--v2) {
      return 0LL;
    }
  }

  return 1LL;
}

uint64_t BOMFSOArchInfoArchCount(_DWORD *a1)
{
  if (*a1 == 1) {
    return a1[26];
  }
  else {
    return 0LL;
  }
}

uint64_t BOMFSOArchInfoGetArch(uint64_t a1, unsigned int a2)
{
  if (*(_DWORD *)(a1 + 104) <= a2) {
    return 0LL;
  }
  else {
    return *(unsigned int *)(*(void *)(a1 + 112) + 24LL * a2);
  }
}

uint64_t BOMFSOArchInfoGetArchSubtype(uint64_t a1, unsigned int a2)
{
  if (*(_DWORD *)(a1 + 104) <= a2) {
    return 0LL;
  }
  else {
    return *(unsigned int *)(*(void *)(a1 + 112) + 24LL * a2 + 4);
  }
}

uint64_t BOMFSOArchInfoGetArchSize(uint64_t a1, unsigned int a2)
{
  if (*(_DWORD *)(a1 + 104) <= a2) {
    return 0LL;
  }
  else {
    return *(unsigned int *)(*(void *)(a1 + 112) + 24LL * a2 + 8);
  }
}

uint64_t BOMFSOArchInfoThinKeepingArchs(uint64_t a1, int *a2, unsigned int a3)
{
  uint64_t v6 = (char *)BOM_malloc(24LL * *(int *)(a1 + 104));
  if (!v6) {
    return 1LL;
  }
  unint64_t v7 = v6;
  unint64_t v8 = *(unsigned int *)(a1 + 104);
  if ((_DWORD)v8)
  {
    unint64_t v9 = 0LL;
    int v10 = 0;
    do
    {
      if (a3)
      {
        uint64_t v11 = *(void *)(a1 + 112) + 24 * v9;
        uint64_t v12 = a3;
        unsigned int v13 = a2;
        while (1)
        {
          int v14 = *v13++;
          if (*(_DWORD *)v11 == v14) {
            break;
          }
          if (!--v12) {
            goto LABEL_12;
          }
        }

        unsigned int v15 = &v6[24 * v10];
        __int128 v16 = *(_OWORD *)v11;
        *((void *)v15 + 2) = *(void *)(v11 + 16);
        *(_OWORD *)unsigned int v15 = v16;
        ++v10;
        unint64_t v8 = *(unsigned int *)(a1 + 104);
      }

uint64_t BOMFSOArchInfoThinKeepingArchsAndSubArchs(uint64_t a1, uint64_t a2, unsigned int a3)
{
  uint64_t v6 = (char *)BOM_malloc(24LL * *(int *)(a1 + 104));
  if (!v6) {
    return 1LL;
  }
  unint64_t v7 = v6;
  unint64_t v8 = *(unsigned int *)(a1 + 104);
  if ((_DWORD)v8)
  {
    unint64_t v9 = 0LL;
    int v10 = 0;
    do
    {
      if (a3)
      {
        uint64_t v11 = *(void *)(a1 + 112) + 24 * v9;
        uint64_t v12 = a3;
        unsigned int v13 = (_DWORD *)(a2 + 8);
        while (*(_DWORD *)v11 != *(v13 - 2) || !*((_BYTE *)v13 - 4) && ((*v13 ^ *(_DWORD *)(v11 + 4)) & 0xFFFFFF) != 0)
        {
          v13 += 8;
          if (!--v12) {
            goto LABEL_14;
          }
        }

        int v14 = &v6[24 * v10];
        __int128 v15 = *(_OWORD *)v11;
        *((void *)v14 + 2) = *(void *)(v11 + 16);
        *(_OWORD *)int v14 = v15;
        ++v10;
        unint64_t v8 = *(unsigned int *)(a1 + 104);
      }

void BOMFSOArchInfoSet(uint64_t a1, unsigned int a2, uint64_t a3)
{
  if (a1)
  {
    uint64_t v6 = *(void **)(a1 + 112);
    if (v6)
    {
      free(v6);
      *(_DWORD *)(a1 + 104) = 0;
      *(void *)(a1 + 112) = 0LL;
      *(_WORD *)(a1 + 40) &= ~B_ARCH;
    }

    if (a2)
    {
      *(_DWORD *)(a1 + 104) = a2;
      unint64_t v7 = BOM_malloc(24LL * (int)a2);
      uint64_t v8 = 0LL;
      *(void *)(a1 + 112) = v7;
      do
      {
        uint64_t v9 = *(void *)(a1 + 112) + v8;
        __int128 v10 = *(_OWORD *)(a3 + v8);
        *(void *)(v9 + 16) = *(void *)(a3 + v8 + 16);
        *(_OWORD *)uint64_t v9 = v10;
        v8 += 24LL;
      }

      while (24LL * a2 != v8);
      if (a2 == 1) {
        __int16 v11 = 1;
      }
      else {
        __int16 v11 = 2;
      }
      *(_WORD *)(a1 + 40) |= B_ARCH | (unsigned __int16)(v11 << B_ARCHOFFT);
    }
  }

uint64_t _handleMachO_common(uint64_t a1, int a2, int a3)
{
  *(_WORD *)(a1 + 40) |= 1 << B_ARCHOFFT;
  *(_DWORD *)(a1 + 104) = 1;
  uint64_t v6 = BOM_malloc(0x18uLL);
  *(void *)(a1 + 112) = v6;
  v6[1] = *(void *)(a1 + 64);
  *(_DWORD *)uint64_t v6 = a2;
  *((_DWORD *)v6 + 1) = a3;
  uint64_t result = BOMFSObjectChecksum(a1);
  *(_DWORD *)(*(void *)(a1 + 112) + 16LL) = result;
  return result;
}

uint64_t BOMFSObjectArchiveLength(uint64_t a1)
{
  if (!a1) {
    return -1LL;
  }
  unsigned __int16 v2 = *(_WORD *)(a1 + 40);
  if (((unsigned __int16)B_STAT & v2) != 0)
  {
    uint64_t v3 = BOMFSOTypeInfoArchiveLength(a1);
    if (v3 < 0) {
      return -1LL;
    }
    uint64_t v4 = v3 + 30;
    unsigned __int16 v2 = *(_WORD *)(a1 + 40);
  }

  else
  {
    uint64_t v4 = 4LL;
  }

  uint64_t v5 = BOMFSOArchInfoArchiveLength(a1);
  if (v5 < 0) {
    return -1LL;
  }
  v4 += v5;
  unsigned __int16 v2 = *(_WORD *)(a1 + 40);
LABEL_9:
  return v4;
}

uint64_t BOMFSObjectArchive(uint64_t a1, uint64_t a2)
{
  uint64_t result = 1LL;
  if (a1 && a2)
  {
    BOMStreamWriteUInt8(a1, *(_BYTE *)a2);
    BOMStreamWriteUInt8(a1, 1);
    BOMStreamWriteUInt16(a1, *(_WORD *)(a2 + 40));
    unsigned __int16 v5 = *(_WORD *)(a2 + 40);
    if (((unsigned __int16)B_STAT & v5) != 0)
    {
      BOMStreamWriteUInt16(a1, *(_WORD *)(a2 + 42));
      BOMStreamWriteUInt32(a1, *(_DWORD *)(a2 + 44));
      BOMStreamWriteUInt32(a1, *(_DWORD *)(a2 + 48));
      BOMStreamWriteUInt32(a1, *(_DWORD *)(a2 + 56));
      BOMStreamWriteUInt32(a1, *(_DWORD *)(a2 + 64));
      BOMFSOTypeInfoArchive(a1, a2);
      unsigned __int16 v5 = *(_WORD *)(a2 + 40);
    }

    if (((unsigned __int16)B_ARCH & v5) != 0)
    {
      BOMFSOArchInfoArchive(a1, a2);
      unsigned __int16 v5 = *(_WORD *)(a2 + 40);
    }

    if (((unsigned __int16)B_OPAQUEDATA & v5) != 0)
    {
      BOMStreamWriteUInt32(a1, *(_DWORD *)(a2 + 128));
      BOMStreamWriteBuffer(a1, *(const void **)(a2 + 120), *(void *)(a2 + 128));
    }

    return 0LL;
  }

  return result;
}

_DWORD *BOMFSObjectUnarchive(uint64_t a1)
{
  if (!a1) {
    return 0LL;
  }
  int UInt8 = BOMStreamReadUInt8(a1);
  int v3 = BOMStreamReadUInt8(a1);
  if ((UInt8 - 6) <= 0xFFFFFFFA)
  {
    fprintf((FILE *)*MEMORY[0x1895F89D0], "filesystem object has an invalid type: 0x%X\nCannot dearchive.\n");
    return 0LL;
  }

  if (v3 != 1)
  {
    fprintf((FILE *)*MEMORY[0x1895F89D0], "filesystem object has an invalid version: 0x%X\nCannot dearchive.\n");
    return 0LL;
  }

  uint64_t Sys = (void *)BOMStreamGetSys(a1);
  unsigned __int16 v5 = BOMFSObjectNewWithSys(UInt8, Sys);
  if (v5)
  {
    unsigned __int16 UInt16 = BOMStreamReadUInt16(a1);
    *((_WORD *)v5 + 20) = UInt16;
    if (((unsigned __int16)B_STAT & UInt16) != 0)
    {
      *((_WORD *)v5 + 21) = BOMStreamReadUInt16(a1);
      v5[11] = BOMStreamReadUInt32(a1);
      v5[12] = BOMStreamReadUInt32(a1);
      *((void *)v5 + 7) = BOMStreamReadUInt32(a1);
      *((void *)v5 + 8) = BOMStreamReadUInt32(a1);
      unsigned __int16 UInt16 = *((_WORD *)v5 + 20);
      if (((unsigned __int16)B_STAT & UInt16) != 0)
      {
        unsigned __int16 UInt16 = *((_WORD *)v5 + 20);
      }
    }

    if (((unsigned __int16)B_ARCH & UInt16) != 0)
    {
      unsigned __int16 UInt16 = *((_WORD *)v5 + 20);
    }

    if (((unsigned __int16)B_OPAQUEDATA & UInt16) != 0)
    {
      unsigned int UInt32 = BOMStreamReadUInt32(a1);
      *((void *)v5 + 16) = UInt32;
      uint64_t v8 = BOM_malloc(UInt32);
      *((void *)v5 + 15) = v8;
      if (v8)
      {
        BOMStreamReadBuffer(a1, v8, *((void *)v5 + 16));
        return v5;
      }

uint64_t BOMFSObjectTypeForMode(__int16 a1)
{
  unsigned int v1 = (a1 & 0xF000) - 4096;
  if (v1 >> 14 > 2) {
    return 0LL;
  }
  else {
    return dword_18635ADF8[v1 >> 12];
  }
}

char *BOMNameForFSObjectType(int a1)
{
  else {
    int v1 = 0;
  }
  return &gTypeStrings[10 * v1];
}

void *BOMFSObjectNew(int a1)
{
  unsigned __int16 v2 = BOM_malloczero(0xA8uLL);
  int v3 = v2;
  if (v2)
  {
    *(_DWORD *)unsigned __int16 v2 = a1;
    v2[20] = BomSys_default();
  }

  return v3;
}

_DWORD *BOMFSObjectNewWithSys(int a1, void *a2)
{
  uint64_t v4 = BOM_malloczero(0xA8uLL);
  unsigned __int16 v5 = v4;
  if (v4)
  {
    *uint64_t v4 = a1;
    if (!a2) {
      a2 = BomSys_default();
    }
    *((void *)v5 + 20) = a2;
  }

  return v5;
}

_DWORD *BOMFSObjectNewFromPath(const char *a1, __int16 a2)
{
  return BOMFSObjectNewFromPathWithSys(a1, a2, 0LL);
}

_DWORD *BOMFSObjectNewFromPathWithSys( const char *a1, __int16 a2, unsigned int (**a3)(void, const char *, __int128 *))
{
  int v3 = a3;
  if (!a3) {
    int v3 = (unsigned int (**)(void, const char *, __int128 *))BomSys_default();
  }
  if (v3[12](v3[1], a1, &v30)) {
    return 0LL;
  }
  int v8 = BOMFSObjectTypeForMode(SWORD2(v30));
  if (v8 == 5) {
    return 0LL;
  }
  if (!v8)
  {
    fprintf((FILE *)*MEMORY[0x1895F89D0], "file '%s' is an unknown file type\n", a1);
    return 0LL;
  }

  uint64_t v6 = BOMFSObjectNewWithSys(v8, v3);
  if (!v6) {
    return v6;
  }
  size_t v9 = strlen(a1) + 1;
  __int128 v10 = BOM_malloc(v9);
  *((void *)v6 + 9) = v10;
  if (!v10)
  {
LABEL_24:
    uint64_t v20 = (void *)*((void *)v6 + 10);
    if (v20) {
      free(v20);
    }
    free(v6);
    return 0LL;
  }

  memmove(v10, a1, v9);
  __int16 v11 = strrchr(a1, 47);
  uint64_t v12 = a1;
  if (v11)
  {
    if (v11[1]) {
      uint64_t v12 = v11 + 1;
    }
    else {
      uint64_t v12 = v11;
    }
  }

  size_t v13 = strlen(v12) + 1;
  int v14 = BOM_malloc(v13);
  *((void *)v6 + 10) = v14;
  if (!v14)
  {
    unint64_t v19 = (void *)*((void *)v6 + 9);
    if (v19) {
      free(v19);
    }
    goto LABEL_24;
  }

  memmove(v14, v12, v13);
  *((_WORD *)v6 + 20) = a2;
  int v15 = a2 & 1;
  if ((a2 & 1) != 0)
  {
    *((_WORD *)v6 + 21) = WORD2(v30);
    *(void *)(v6 + 11) = v31;
    *((void *)v6 + 7) = v33;
    *((void *)v6 + 8) = v36;
  }

  if ((a2 & 0xFFF) != 0 && *v6 == 1)
  {
    unsigned int v16 = v3[23](v3[1], a1, (__int128 *)4);
    uint64_t v17 = v3[1];
    if (v16 == -1)
    {
      v3[25](v17, a1, (__int128 *)(WORD2(v30) & 0xFFF | 0x124u));
      int v18 = ((uint64_t (*)(unsigned int (*)(void, const char *, __int128 *), const char *, void, void))v3[2])( v3[1],  a1,  0LL,  0LL);
      v3[25](v3[1], a1, (__int128 *)(WORD2(v30) & 0xFFF));
    }

    else
    {
      int v18 = ((uint64_t (*)(unsigned int (*)(void, const char *, __int128 *), const char *, void, void))v3[2])( v17,  a1,  0LL,  0LL);
    }

    if (v18 == -1)
    {
      BOMFSObjectFree((uint64_t)v6);
      return 0LL;
    }

    v6[4] = v18;
    *((void *)v6 + 3) = 0LL;
    *((void *)v6 + 4) = 0LL;
    a2 = *((_WORD *)v6 + 20);
    int v15 = a2 & 1;
  }

  if (v15)
  {
    __int128 v27 = v36;
    __int128 v28 = v37;
    __int128 v29 = v38;
    __int128 v23 = v32;
    __int128 v24 = v33;
    __int128 v25 = v34;
    __int128 v26 = v35;
    __int128 v21 = v30;
    __int128 v22 = v31;
    BOMFSOTypeInfoInitialize((uint64_t)v6, (uint64_t)&v21);
    a2 = *((_WORD *)v6 + 20);
  }

  if ((a2 & 4) != 0)
  {
    __int128 v27 = v36;
    __int128 v28 = v37;
    __int128 v29 = v38;
    __int128 v23 = v32;
    __int128 v24 = v33;
    __int128 v25 = v34;
    __int128 v26 = v35;
    __int128 v21 = v30;
    __int128 v22 = v31;
    BOMFSOArchInfoInitialize();
  }

  if (*v6 == 1 && (v6[10] & 0xFFF) != 0)
  {
    ((void (*)(unsigned int (*)(void, const char *, __int128 *), void))v3[4])( v3[1],  v6[4]);
    *((void *)v6 + 3) = 0LL;
    *((void *)v6 + 4) = 0LL;
  }

  return v6;
}

void BOMFSObjectFree(uint64_t a1)
{
  if (a1)
  {
    unsigned __int16 v2 = *(void **)(a1 + 72);
    if (v2) {
      free(v2);
    }
    int v3 = *(void **)(a1 + 80);
    if (v3) {
      free(v3);
    }
    BOMFSOTypeInfoRelease(a1);
    BOMFSOArchInfoRelease(a1);
    uint64_t v4 = *(void **)(a1 + 120);
    if (v4) {
      free(v4);
    }
    unsigned __int16 v5 = *(void **)(a1 + 144);
    if (v5)
    {
      if (*(_BYTE *)(a1 + 152)) {
        free(v5);
      }
    }

    free((void *)a1);
  }

uint64_t BOMFSObjectENewFromPath(const char *a1, __int128 *a2, int a3, __int16 a4)
{
  return BOMFSObjectENewFromPathWithSys(a1, a2, a3, a4, 0LL);
}

uint64_t BOMFSObjectENewFromPathWithSys(const char *a1, __int128 *a2, int a3, __int16 a4, void *a5)
{
  int v10 = BOMFSObjectTypeForMode(*((_WORD *)a2 + 2));
  if (!v10) {
    return 0LL;
  }
  int v11 = v10;
  if (!a5) {
    a5 = BomSys_default();
  }
  uint64_t v12 = BOMFSObjectNewWithSys(v11, a5);
  uint64_t v13 = (uint64_t)v12;
  if (v12)
  {
    v12[4] = -1;
    size_t v14 = strlen(a1) + 1;
    int v15 = BOM_malloc(v14);
    *(void *)(v13 + 72) = v15;
    if (!v15) {
      goto LABEL_18;
    }
    memmove(v15, a1, v14);
    unsigned int v16 = strrchr(a1, 47);
    uint64_t v17 = a1;
    if (v16)
    {
      if (v16[1]) {
        uint64_t v17 = v16 + 1;
      }
      else {
        uint64_t v17 = v16;
      }
    }

    size_t v18 = strlen(v17) + 1;
    unint64_t v19 = BOM_malloc(v18);
    *(void *)(v13 + 80) = v19;
    if (v19)
    {
      memmove(v19, v17, v18);
      *(_WORD *)(v13 + 40) = a4;
      int v20 = a4 & 1;
      if ((a4 & 1) != 0)
      {
        *(_WORD *)(v13 + 42) = *((_WORD *)a2 + 2);
        *(void *)(v13 + 44) = *((void *)a2 + 2);
        *(void *)(v13 + 56) = *((void *)a2 + 6);
        *(void *)(v13 + 64) = *((void *)a2 + 12);
      }

      if ((a4 & 0xFFF) == 0 || *(_DWORD *)v13 != 1) {
        goto LABEL_29;
      }
      if (a3 != -1)
      {
        *(_DWORD *)(v13 + 16) = a3;
LABEL_28:
        *(void *)(v13 + 24) = 0LL;
        *(void *)(v13 + 32) = 0LL;
LABEL_29:
        if (v20)
        {
          __int128 v25 = a2[7];
          __int128 v39 = a2[6];
          __int128 v40 = v25;
          __int128 v41 = a2[8];
          __int128 v26 = a2[3];
          __int128 v35 = a2[2];
          __int128 v36 = v26;
          __int128 v27 = a2[5];
          __int128 v37 = a2[4];
          __int128 v38 = v27;
          __int128 v28 = a2[1];
          __int128 v33 = *a2;
          __int128 v34 = v28;
          BOMFSOTypeInfoInitialize(v13, (uint64_t)&v33);
          a4 = *(_WORD *)(v13 + 40);
        }

        if ((a4 & 4) != 0)
        {
          __int128 v29 = a2[7];
          __int128 v39 = a2[6];
          __int128 v40 = v29;
          __int128 v41 = a2[8];
          __int128 v30 = a2[3];
          __int128 v35 = a2[2];
          __int128 v36 = v30;
          __int128 v31 = a2[5];
          __int128 v37 = a2[4];
          __int128 v38 = v31;
          __int128 v32 = a2[1];
          __int128 v33 = *a2;
          __int128 v34 = v32;
          BOMFSOArchInfoInitialize();
        }

        if (*(_DWORD *)v13 == 1 && (*(_WORD *)(v13 + 40) & 0xFFF) != 0)
        {
          *(void *)(v13 + 24) = 0LL;
          *(void *)(v13 + 32) = 0LL;
          if (a3 == -1)
          {
            (*((void (**)(void, void))a5 + 4))(*((void *)a5 + 1), *(unsigned int *)(v13 + 16));
            *(_DWORD *)(v13 + 16) = -1;
          }
        }

        return v13;
      }

      int v22 = (*((uint64_t (**)(void, const char *, uint64_t))a5 + 23))(*((void *)a5 + 1), a1, 4LL);
      uint64_t v23 = *((void *)a5 + 1);
      if (v22 == -1)
      {
        (*((void (**)(uint64_t, const char *, void))a5 + 25))(v23, a1, *((_WORD *)a2 + 2) & 0xFFF | 0x124u);
        *(_DWORD *)(v13 + 16) = (*((uint64_t (**)(void, const char *, void, void))a5 + 2))( *((void *)a5 + 1),  a1,  0LL,  0LL);
        (*((void (**)(void, const char *, void))a5 + 25))( *((void *)a5 + 1),  a1,  *((_WORD *)a2 + 2) & 0xFFF);
        int v24 = *(_DWORD *)(v13 + 16);
      }

      else
      {
        int v24 = (*((uint64_t (**)(uint64_t, const char *, void, void))a5 + 2))(v23, a1, 0LL, 0LL);
        *(_DWORD *)(v13 + 16) = v24;
      }

      if (v24 != -1)
      {
        a4 = *(_WORD *)(v13 + 40);
        int v20 = a4 & 1;
        goto LABEL_28;
      }
    }

    else
    {
LABEL_18:
      if (a3 == -1 && *(_DWORD *)(v13 + 16) != -1) {
        (*((void (**)(void))a5 + 4))(*((void *)a5 + 1));
      }
    }

    BOMFSObjectFree(v13);
    return 0LL;
  }

  return v13;
}

void *BOMFSObjectCopy(uint64_t a1)
{
  unsigned __int16 v2 = BOMFSObjectNewWithSys(*(_DWORD *)a1, *(void **)(a1 + 160));
  int v3 = v2;
  if (!v2) {
    return v3;
  }
  __int128 v4 = *(_OWORD *)(a1 + 32);
  __int128 v5 = *(_OWORD *)a1;
  *((_OWORD *)v2 + 1) = *(_OWORD *)(a1 + 16);
  *((_OWORD *)v2 + 2) = v4;
  *(_OWORD *)unsigned __int16 v2 = v5;
  __int128 v6 = *(_OWORD *)(a1 + 48);
  __int128 v7 = *(_OWORD *)(a1 + 64);
  __int128 v8 = *(_OWORD *)(a1 + 96);
  *((_OWORD *)v2 + 5) = *(_OWORD *)(a1 + 80);
  *((_OWORD *)v2 + 6) = v8;
  *((_OWORD *)v2 + 3) = v6;
  *((_OWORD *)v2 + 4) = v7;
  __int128 v9 = *(_OWORD *)(a1 + 112);
  __int128 v10 = *(_OWORD *)(a1 + 128);
  __int128 v11 = *(_OWORD *)(a1 + 144);
  *((void *)v2 + 20) = *(void *)(a1 + 160);
  *((_OWORD *)v2 + 8) = v10;
  *((_OWORD *)v2 + 9) = v11;
  *((_OWORD *)v2 + 7) = v9;
  v2[4] = 0;
  *((void *)v2 + 3) = 0LL;
  *((void *)v2 + 4) = 0LL;
  uint64_t v12 = *(const char **)(a1 + 72);
  if (v12)
  {
    size_t v13 = strlen(v12) + 1;
    size_t v14 = (char *)BOM_malloc(v13);
    v3[9] = v14;
    if (!v14) {
      goto LABEL_16;
    }
    strlcpy(v14, *(const char **)(a1 + 72), v13);
  }

  int v15 = *(const char **)(a1 + 80);
  if (v15)
  {
    size_t v16 = strlen(v15) + 1;
    uint64_t v17 = (char *)BOM_malloc(v16);
    v3[10] = v17;
    if (!v17) {
      goto LABEL_16;
    }
    strlcpy(v17, *(const char **)(a1 + 80), v16);
  }

  if (*(void *)(a1 + 120))
  {
    size_t v18 = BOM_malloc(*(void *)(a1 + 128));
    v3[15] = v18;
    if (v18)
    {
      memmove(v18, *(const void **)(a1 + 120), *(void *)(a1 + 128));
      goto LABEL_13;
    }

LABEL_16:
    int v22 = (void *)v3[9];
    if (v22) {
      free(v22);
    }
    uint64_t v23 = (void *)v3[10];
    if (v23) {
      free(v23);
    }
    int v24 = (void *)v3[15];
    if (v24) {
      free(v24);
    }
    __int128 v25 = (void *)v3[18];
    if (v25) {
      free(v25);
    }
    free(v3);
    return 0LL;
  }

  if (*(_DWORD *)(a1 + 1096))
  {
    __int128 v10 = *(unsigned int *)(a1 + 1100);
    *(_DWORD *)(v6 + 1100) = v10;
    if ((_DWORD)v10)
    {
      __int128 v11 = (*(uint64_t (**)(void))(*(void *)(v6 + 1088) + 48LL))();
      uint64_t v12 = v10;
      if (!v11)
      {
        __int128 v11 = *(_DWORD *)(v6 + 1032);
        uint64_t v12 = v10;
      }
    }

    else
    {
      uint64_t v12 = 0LL;
      __int128 v11 = 0;
    }

    *(_DWORD *)(v6 + 1096) = v11;
    _ExpandMapAddress(v6, v11 + v10);
    memmove( (void *)(*(void *)(v6 + 1040) + *(unsigned int *)(v6 + 1096)),  (const void *)(*(void *)(a1 + 1040) + *(unsigned int *)(a1 + 1096)),  v12);
    _AdjustFileSize(v6, v11, v10);
    if (*(_DWORD *)(v6 + 1028) != -1) {
      _AddToWriteCache(v6, v11, v10);
    }
    *(_DWORD *)(v6 + 1116) = 1;
  }

  BOMStorageCommit(v6);
  size_t v14 = BOM_malloc(0x468uLL);
  if (!v14)
  {
    BOMStorageFree((_DWORD *)v6);
    size_t v20 = (FILE *)*MEMORY[0x1895F89D0];
    __int128 v21 = __error();
    strerror(*v21);
    fprintf(v20, "malloc: %s\n");
    return 1LL;
  }

  int v15 = v14;
  memcpy(v14, (const void *)a1, 0x468uLL);
  BOMStorageFree(v15);
  if ((*(unsigned int (**)(void, char *, char *))(v2 + 264))(*(void *)(v2 + 8), __s, v24))
  {
    size_t v16 = (FILE *)*MEMORY[0x1895F89D0];
    uint64_t v17 = __error();
    size_t v18 = strerror(*v17);
    fprintf(v16, "rename: %s\n", v18);
    BOMStorageFree((_DWORD *)v6);
    size_t v13 = 1LL;
    unint64_t v19 = (void *)BOMStorageOpenWithSys(v24, 1, (void *)v2);
    memcpy((void *)a1, v19, 0x468uLL);
    free(v19);
  }

  else
  {
    memcpy((void *)a1, (const void *)v6, 0x468uLL);
    free((void *)v6);
    return 0LL;
  }

  return v13;
}

  uint64_t v74 = v14;
  uint64_t v69 = a8;
  size_t v71 = a4;
  if (v19 == *(unsigned __int16 *)(v17 + 16))
  {
    if (a4)
    {
      __int128 v26 = _findPage(v20, **(_DWORD **)(a4 + 32));
      __int128 v27 = *((_WORD *)v26 + 2);
      if ((v27 & 8) == 0)
      {
        uint64_t v67 = v76;
LABEL_22:
        __int128 v28 = 0;
        *((_WORD *)v26 + 2) = v27 | 8;
        goto LABEL_26;
      }

      __int128 v28 = 1;
      uint64_t v67 = v76;
    }

    else
    {
      uint64_t v67 = 0LL;
      __int128 v26 = 0LL;
      __int128 v28 = 1;
    }
  }

  else
  {
    __int128 v26 = _findPage(v20, *(_DWORD *)(*(void *)(v17 + 32) + 4LL * (v19 + 1)));
    __int128 v27 = *((_WORD *)v26 + 2);
    if ((v27 & 8) == 0)
    {
      uint64_t v67 = v17;
      goto LABEL_22;
    }

    __int128 v28 = 1;
    uint64_t v67 = v17;
  }

_DWORD *BOMFSObjectNewFromPathDeferred(uint64_t a1, const char *a2, __int16 a3, const char *a4, int a5)
{
  return BOMFSObjectNewFromPathDeferredWithSys(a1, a2, a3, a4, a5, 0LL);
}

_DWORD *BOMFSObjectNewFromPathDeferredWithSys( uint64_t a1, const char *a2, __int16 a3, const char *a4, int a5, void *a6)
{
  int v12 = BOMFSObjectTypeForMode(*(_WORD *)(a1 + 4));
  size_t v13 = BOMFSObjectNewWithSys(v12, a6);
  if (v13)
  {
    size_t v14 = strlen(a2) + 1;
    int v15 = BOM_malloc(v14);
    *((void *)v13 + 9) = v15;
    if (v15)
    {
      memmove(v15, a2, v14);
      size_t v16 = strrchr(a2, 47);
      uint64_t v17 = a2;
      if (v16)
      {
        if (v16[1]) {
          uint64_t v17 = v16 + 1;
        }
        else {
          uint64_t v17 = v16;
        }
      }

      size_t v18 = strlen(v17) + 1;
      unint64_t v19 = BOM_malloc(v18);
      *((void *)v13 + 10) = v19;
      if (v19)
      {
        memmove(v19, v17, v18);
        *((_WORD *)v13 + 20) = a3;
        if (a5)
        {
          size_t v20 = strlen(a4) + 1;
          __int128 v21 = BOM_malloc(v20);
          *((void *)v13 + 18) = v21;
          memmove(v21, a4, v20);
          *((_BYTE *)v13 + 152) = 1;
          if ((a3 & 1) == 0)
          {
LABEL_10:
            *((_WORD *)v13 + 68) = 0;
            return v13;
          }
        }

        else
        {
          *((void *)v13 + 18) = a4;
          if ((a3 & 1) == 0) {
            goto LABEL_10;
          }
        }

        *((_WORD *)v13 + 21) = *(_WORD *)(a1 + 4);
        *(void *)(v13 + 11) = *(void *)(a1 + 16);
        uint64_t v24 = *(void *)(a1 + 96);
        *((void *)v13 + 7) = *(void *)(a1 + 48);
        *((void *)v13 + 8) = v24;
        BOMFSOTypeInfoInitializeDeferred((uint64_t)v13, a1, (uint64_t)a2, 1u);
        *((_WORD *)v13 + 68) = 1;
        return v13;
      }

      int v22 = (void *)*((void *)v13 + 9);
      if (v22) {
        free(v22);
      }
    }

    uint64_t v23 = (void *)*((void *)v13 + 10);
    if (v23) {
      free(v23);
    }
    free(v13);
    return 0LL;
  }

  return v13;
}

_DWORD *BOMFSObjectNewFromPathString(const __CFString *a1, __int16 a2)
{
  return BOMFSObjectNewFromPathStringWithSys(a1, a2, 0LL);
}

_DWORD *BOMFSObjectNewFromPathStringWithSys( const __CFString *a1, __int16 a2, unsigned int (**a3)(void, const char *, __int128 *))
{
  CStringPtr = CFStringGetCStringPtr(a1, 0x8000100u);
  if (CStringPtr)
  {
    __int128 v7 = 0LL;
LABEL_5:
    __int128 v9 = BOMFSObjectNewFromPathWithSys(CStringPtr, a2, a3);
    goto LABEL_6;
  }

  __int128 v7 = (char *)BOM_malloc(0x2800uLL);
  int CString = CFStringGetCString(a1, v7, 10240LL, 0x8000100u);
  __int128 v9 = 0LL;
  if (v7)
  {
    int v10 = CString;
    CStringPtr = v7;
    if (v10) {
      goto LABEL_5;
    }
  }

uint64_t BOMFSObjectType(unsigned int *a1)
{
  return *a1;
}

uint64_t BOMFSObjectPathName(uint64_t result)
{
  if (result) {
    return *(void *)(result + 72);
  }
  return result;
}

uint64_t BOMFSObjectShortName(uint64_t result)
{
  if (result) {
    return *(void *)(result + 80);
  }
  return result;
}

CFStringRef BOMFSObjectPathNameString(CFStringRef result)
{
  if (result) {
    return CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x189604DB0], (const char *)result[2].info, 0x8000100u);
  }
  return result;
}

CFStringRef BOMFSObjectShortNameString(CFStringRef result)
{
  if (result) {
    return CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x189604DB0], result[2].data, 0x8000100u);
  }
  return result;
}

uint64_t BOMFSObjectMode(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = result;
    if (*(void *)(result + 144))
    {
      if ((*(_WORD *)(result + 136) & 1) == 0) {
        _loadStatInfo(result);
      }
    }

    return *(unsigned __int16 *)(v1 + 42);
  }

  return result;
}

uint64_t _loadStatInfo(uint64_t a1)
{
  uint64_t v10 = *MEMORY[0x1895F89C0];
  if ((*(_WORD *)(a1 + 136) & 1) != 0) {
    return 0LL;
  }
  snprintf(__str, 0x401uLL, "%s/%s", *(const char **)(a1 + 144), *(const char **)(a1 + 72));
  if ((*(unsigned int (**)(void, char *, _BYTE *))(*(void *)(a1 + 160) + 96LL))( *(void *)(*(void *)(a1 + 160) + 8LL),  __str,  v4))
  {
    fprintf((FILE *)*MEMORY[0x1895F89D0], "stat error for '%s'\n", __str);
    return 1LL;
  }

  else
  {
    *(_WORD *)(a1 + 42) = v5;
    *(void *)(a1 + 44) = v6;
    uint64_t v3 = v8;
    *(void *)(a1 + 56) = v7;
    *(void *)(a1 + 64) = v3;
    BOMFSOTypeInfoInitializeDeferred(a1, (uint64_t)v4, (uint64_t)__str, 1u);
    uint64_t result = 0LL;
    *(_WORD *)(a1 + 136) |= 1u;
  }

  return result;
}

uint64_t BOMFSObjectUserID(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = result;
    if (*(void *)(result + 144))
    {
      if ((*(_WORD *)(result + 136) & 1) == 0) {
        _loadStatInfo(result);
      }
    }

    return *(unsigned int *)(v1 + 44);
  }

  return result;
}

uint64_t BOMFSObjectGroupID(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = result;
    if (*(void *)(result + 144))
    {
      if ((*(_WORD *)(result + 136) & 1) == 0) {
        _loadStatInfo(result);
      }
    }

    return *(unsigned int *)(v1 + 48);
  }

  return result;
}

uint64_t BOMFSObjectModTime(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = result;
    if (*(void *)(result + 144))
    {
      if ((*(_WORD *)(result + 136) & 1) == 0) {
        _loadStatInfo(result);
      }
    }

    return *(void *)(v1 + 56);
  }

  return result;
}

uint64_t BOMFSObjectSize(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = result;
    if (*(void *)(result + 144))
    {
      if ((*(_WORD *)(result + 136) & 1) == 0) {
        _loadStatInfo(result);
      }
    }

    return *(void *)(v1 + 64);
  }

  return result;
}

uint64_t BOMFSObjectPathID(uint64_t result)
{
  if (result) {
    return *(unsigned int *)(result + 4);
  }
  return result;
}

uint64_t BOMFSObjectSetPathID(uint64_t result, int a2)
{
  if (result) {
    *(_DWORD *)(result + 4) = a2;
  }
  return result;
}

uint64_t BOMFSObjectParentPathID(uint64_t result)
{
  if (result) {
    return *(unsigned int *)(result + 8);
  }
  return result;
}

uint64_t BOMFSObjectSetParentPathID(uint64_t result, int a2)
{
  if (result) {
    *(_DWORD *)(result + 8) = a2;
  }
  return result;
}

void BOMFSObjectSetPathName(uint64_t a1, char *__s, int a3)
{
  if (a1)
  {
    uint64_t v6 = *(void **)(a1 + 72);
    if (v6) {
      free(v6);
    }
    if (__s && a3)
    {
      size_t v7 = strlen(__s) + 1;
      uint64_t v8 = BOM_malloc(v7);
      *(void *)(a1 + 72) = v8;
      memmove(v8, __s, v7);
    }

    else
    {
      *(void *)(a1 + 72) = __s;
    }
  }

void BOMFSObjectSetShortName(uint64_t a1, char *__s, int a3)
{
  if (a1)
  {
    uint64_t v6 = *(void **)(a1 + 80);
    if (v6) {
      free(v6);
    }
    if (__s && a3)
    {
      size_t v7 = strlen(__s) + 1;
      uint64_t v8 = BOM_malloc(v7);
      *(void *)(a1 + 80) = v8;
      memmove(v8, __s, v7);
    }

    else
    {
      *(void *)(a1 + 80) = __s;
    }
  }

uint64_t BOMFSObjectSetFlags(uint64_t result, __int16 a2)
{
  if (result) {
    *(_WORD *)(result + 40) = a2;
  }
  return result;
}

uint64_t BOMFSObjectSetMode(uint64_t result, __int16 a2)
{
  if (result)
  {
    *(_WORD *)(result + 40) |= 1u;
    *(_WORD *)(result + 42) = a2;
  }

  return result;
}

uint64_t BOMFSObjectSetUserID(uint64_t result, int a2)
{
  if (result)
  {
    *(_WORD *)(result + 40) |= 1u;
    *(_DWORD *)(result + 44) = a2;
  }

  return result;
}

uint64_t BOMFSObjectSetGroupID(uint64_t result, int a2)
{
  if (result)
  {
    *(_WORD *)(result + 40) |= 1u;
    *(_DWORD *)(result + 48) = a2;
  }

  return result;
}

uint64_t BOMFSObjectSetModTime(uint64_t result, uint64_t a2)
{
  if (result)
  {
    *(_WORD *)(result + 40) |= 1u;
    *(void *)(result + 56) = a2;
  }

  return result;
}

uint64_t BOMFSObjectSetSize(uint64_t result, uint64_t a2)
{
  if (result)
  {
    *(_WORD *)(result + 40) |= 1u;
    *(void *)(result + 64) = a2;
  }

  return result;
}

uint64_t BOMFSObjectVisitOrder(uint64_t a1)
{
  return *(unsigned int *)(a1 + 156);
}

uint64_t BOMFSObjectOpaqueData(uint64_t result)
{
  if (result) {
    return *(void *)(result + 120);
  }
  return result;
}

uint64_t BOMFSObjectOpaqueDataSize(uint64_t result)
{
  if (result) {
    return *(void *)(result + 128);
  }
  return result;
}

uint64_t BOMFSObjectSetOpaqueData(uint64_t a1, const void *a2, size_t a3, int a4)
{
  if (!a1) {
    return 1LL;
  }
  __int128 v9 = (void *)(a1 + 120);
  uint64_t v8 = *(void **)(a1 + 120);
  if (v8) {
    free(v8);
  }
  __int16 v10 = *(_WORD *)(a1 + 40);
  if (a2 && a3)
  {
    *(_WORD *)(a1 + 40) = v10 | 0x10;
    *(void *)(a1 + 128) = a3;
    if (a4)
    {
      __int128 v11 = BOM_malloc(a3);
      *__int128 v9 = v11;
      if (v11)
      {
        memmove(v11, a2, a3);
        return 0LL;
      }

      else
      {
        return 1LL;
      }
    }

    else
    {
      uint64_t result = 0LL;
      *__int128 v9 = a2;
    }
  }

  else
  {
    uint64_t result = 0LL;
    *(_WORD *)(a1 + 40) = v10 & 0xFFEF;
    *__int128 v9 = 0LL;
    v9[1] = 0LL;
  }

  return result;
}

uint64_t BOMFSObjectBlockID(uint64_t result)
{
  if (result) {
    return *(unsigned int *)(result + 12);
  }
  return result;
}

uint64_t BOMFSObjectSetBlockID(uint64_t result, int a2)
{
  if (result)
  {
    if (a2) {
      *(_DWORD *)(result + 12) = a2;
    }
  }

  return result;
}

uint64_t BOMFSObjectSetVisitOrder(uint64_t result, int a2)
{
  if (result) {
    *(_DWORD *)(result + 156) = a2;
  }
  return result;
}

uint64_t BOMFSObjectChecksum(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = (_DWORD *)result;
    if (*(void *)(result + 144))
    {
      if ((*(_WORD *)(result + 136) & 2) == 0) {
        _loadCksumInfo(result);
      }
    }

    return BOMFSOTypeInfoChecksum(v1);
  }

  return result;
}

uint64_t _loadCksumInfo(uint64_t result)
{
  uint64_t v7 = *MEMORY[0x1895F89C0];
  if ((*(_WORD *)(result + 136) & 2) != 0) {
    return result;
  }
  uint64_t v1 = result;
  uint64_t result = _loadStatInfo(result);
  if ((_DWORD)result) {
    return result;
  }
  if (*(_DWORD *)v1 != 1 || (*(_WORD *)(v1 + 40) & 2) == 0) {
    goto LABEL_10;
  }
  snprintf(__str, 0x401uLL, "%s/%s", *(const char **)(v1 + 144), *(const char **)(v1 + 72));
  int v2 = (*(uint64_t (**)(void, char *, uint64_t))(*(void *)(v1 + 160) + 184LL))( *(void *)(*(void *)(v1 + 160) + 8LL),  __str,  4LL);
  uint64_t v3 = *(void *)(v1 + 160);
  uint64_t v4 = *(void *)(v3 + 8);
  if (v2 == -1)
  {
    (*(void (**)(uint64_t, char *, void))(v3 + 200))(v4, __str, *(_WORD *)(v1 + 42) & 0xFFF | 0x124u);
    int v5 = (*(uint64_t (**)(void, char *, void, void))(*(void *)(v1 + 160) + 16LL))( *(void *)(*(void *)(v1 + 160) + 8LL),  __str,  0LL,  0LL);
    uint64_t result = (*(uint64_t (**)(void, char *, void))(*(void *)(v1 + 160) + 200LL))( *(void *)(*(void *)(v1 + 160) + 8LL),  __str,  *(_WORD *)(v1 + 42) & 0xFFF);
  }

  else
  {
    uint64_t result = (*(uint64_t (**)(uint64_t, char *, void, void))(v3 + 16))(v4, __str, 0LL, 0LL);
    int v5 = result;
  }

  if (v5 != -1)
  {
    *(_DWORD *)(v1 + 16) = v5;
    *(void *)(v1 + 24) = 0LL;
    *(void *)(v1 + 32) = 0LL;
LABEL_10:
    uint64_t result = BOMFSOTypeInfoInitializeDeferred(v1, 0LL, (uint64_t)__str, 2u);
    *(_WORD *)(v1 + 136) |= 2u;
    if (*(_DWORD *)v1 == 1 && (*(_WORD *)(v1 + 40) & 2) != 0)
    {
      uint64_t result = (*(uint64_t (**)(void, void))(*(void *)(v1 + 160) + 32LL))( *(void *)(*(void *)(v1 + 160) + 8LL),  *(unsigned int *)(v1 + 16));
      *(_DWORD *)(v1 + 16) = 0;
      *(void *)(v1 + 24) = 0LL;
      *(void *)(v1 + 32) = 0LL;
    }
  }

  return result;
}

uint64_t BOMFSObjectSymlinkTarget(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = result;
    if (*(void *)(result + 144))
    {
      if ((*(_WORD *)(result + 136) & 1) == 0) {
        _loadStatInfo(result);
      }
    }

    return BOMFSOTypeInfoSymlinkTarget(v1);
  }

  return result;
}

CFStringRef BOMFSObjectSymlinkTargetString(CFStringRef result)
{
  if (result)
  {
    uint64_t v1 = (uint64_t)result;
    if (result[4].data)
    {
      if ((result[4].info & 1) == 0) {
        _loadStatInfo((uint64_t)result);
      }
    }

    return BOMFSOTypeInfoSymlinkTargetString(v1);
  }

  return result;
}

_DWORD *BOMFSObjectSetSymlinkTarget(_DWORD *result, char *__s, int a3)
{
  if (result)
  {
    *((_WORD *)result + 20) |= 1u;
    return BOMFSOTypeInfoSetSymlinkTarget(result, __s, a3);
  }

  return result;
}

uint64_t BOMFSObjectDeviceID(uint64_t a1)
{
  if (!a1) {
    return 0xFFFFFFFFLL;
  }
  if (*(void *)(a1 + 144))
  {
    if ((*(_WORD *)(a1 + 136) & 1) == 0) {
      _loadStatInfo(a1);
    }
  }

  return BOMFSOTypeInfoDeviceID((_DWORD *)a1);
}

_DWORD *BOMFSObjectSetChecksum(_DWORD *result, int a2)
{
  if (result) {
    return BOMFSOTypeInfoSetChecksum(result, a2);
  }
  return result;
}

_DWORD *BOMFSObjectSetDeviceID(_DWORD *result, int a2)
{
  if (result)
  {
    *((_WORD *)result + 20) |= 1u;
    return BOMFSOTypeInfoSetDeviceID(result, a2);
  }

  return result;
}

const char *BOMFSObjectSummary(const char *result, int a2, int a3, int a4)
{
  if (result)
  {
    uint64_t v7 = (uint64_t)result;
    if (*((void *)result + 18))
    {
      _loadCksumInfo((uint64_t)result);
      _loadArchInfo(v7);
    }

    return BOMFSOTypeInfoSummary(v7, a2, a3, a4);
  }

  return result;
}

uint64_t _loadArchInfo(uint64_t result)
{
  uint64_t v7 = *MEMORY[0x1895F89C0];
  if ((*(_WORD *)(result + 136) & 4) != 0) {
    return result;
  }
  uint64_t v1 = result;
  uint64_t result = _loadStatInfo(result);
  if ((_DWORD)result) {
    return result;
  }
  snprintf(__str, 0x401uLL, "%s/%s", *(const char **)(v1 + 144), *(const char **)(v1 + 72));
  if (*(_DWORD *)v1 == 1 && (*(_WORD *)(v1 + 40) & 4) != 0)
  {
    int v2 = (*(uint64_t (**)(void, char *, uint64_t))(*(void *)(v1 + 160) + 184LL))( *(void *)(*(void *)(v1 + 160) + 8LL),  __str,  4LL);
    uint64_t v3 = *(void *)(v1 + 160);
    uint64_t v4 = *(void *)(v3 + 8);
    if (v2 == -1)
    {
      (*(void (**)(uint64_t, char *, void))(v3 + 200))(v4, __str, *(_WORD *)(v1 + 42) & 0xFFF | 0x124u);
      int v5 = (*(uint64_t (**)(void, char *, void, void))(*(void *)(v1 + 160) + 16LL))( *(void *)(*(void *)(v1 + 160) + 8LL),  __str,  0LL,  0LL);
      uint64_t result = (*(uint64_t (**)(void, char *, void))(*(void *)(v1 + 160) + 200LL))( *(void *)(*(void *)(v1 + 160) + 8LL),  __str,  *(_WORD *)(v1 + 42) & 0xFFF);
    }

    else
    {
      uint64_t result = (*(uint64_t (**)(uint64_t, char *, void, void))(v3 + 16))(v4, __str, 0LL, 0LL);
      int v5 = result;
    }

    if (v5 == -1) {
      return result;
    }
    *(_DWORD *)(v1 + 16) = v5;
    *(void *)(v1 + 24) = 0LL;
    *(void *)(v1 + 32) = 0LL;
  }

  uint64_t result = BOMFSOArchInfoInitialize();
  if (*(_DWORD *)v1 == 1 && (*(_WORD *)(v1 + 40) & 4) != 0)
  {
    uint64_t result = (*(uint64_t (**)(void, void))(*(void *)(v1 + 160) + 32LL))( *(void *)(*(void *)(v1 + 160) + 8LL),  *(unsigned int *)(v1 + 16));
    *(_DWORD *)(v1 + 16) = 0;
    *(void *)(v1 + 24) = 0LL;
    *(void *)(v1 + 32) = 0LL;
  }

  *(_WORD *)(v1 + 136) |= 4u;
  return result;
}

uint64_t BOMFSObjectSummaryWithFormat(uint64_t a1, char *a2, int a3)
{
  if (!a1 || !a2) {
    return 0LL;
  }
  if (*(void *)(a1 + 144))
  {
    _loadCksumInfo(a1);
    _loadArchInfo(a1);
  }

  return BOMFSOTypeInfoSummaryWithFormat(a1, a2, a3);
}

const char *BOMFSObjectParseSummary(const char *result)
{
  if (result)
  {
    uint64_t v1 = result;
    int v2 = BomSys_default();
    return (const char *)BOMFSOTypeInfoParseSummaryWithSys(v1, v2);
  }

  return result;
}

const char *BOMFSObjectParseSummaryWithSys(const char *result, void *a2)
{
  if (result)
  {
    int v2 = result;
    if (!a2) {
      a2 = BomSys_default();
    }
    return (const char *)BOMFSOTypeInfoParseSummaryWithSys(v2, a2);
  }

  return result;
}

uint64_t BOMFSObjectIsBinaryObject(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = result;
    if (*(void *)(result + 144) && (*(_WORD *)(result + 136) & 4) == 0) {
      _loadArchInfo(result);
    }
    if (*(_DWORD *)v1 == 1)
    {
      unsigned int v2 = *(unsigned __int16 *)(v1 + 40);
      if (v2 > 0xFFF) {
        return (v2 >> 2) & 1;
      }
      else {
        return 0LL;
      }
    }

    else
    {
      return 0LL;
    }
  }

  return result;
}

uint64_t BOMFSObjectContainsArchitecture(uint64_t a1, int a2)
{
  if (*(void *)(a1 + 144) && (*(_WORD *)(a1 + 136) & 4) == 0) {
    _loadArchInfo(a1);
  }
  return BOMFSOArchInfoContainsArchitecture(a1, a2);
}

uint64_t BOMFSObjectArchCount(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = (_DWORD *)result;
    if (*(void *)(result + 144))
    {
      if ((*(_WORD *)(result + 136) & 4) == 0) {
        _loadArchInfo(result);
      }
    }

    return BOMFSOArchInfoArchCount(v1);
  }

  return result;
}

uint64_t BOMFSObjectGetArch(uint64_t result, unsigned int a2)
{
  if (result)
  {
    uint64_t v3 = result;
    if (*(void *)(result + 144))
    {
      if ((*(_WORD *)(result + 136) & 4) == 0) {
        _loadArchInfo(result);
      }
    }

    return BOMFSOArchInfoGetArch(v3, a2);
  }

  return result;
}

uint64_t BOMFSObjectGetArchSubtype(uint64_t result, unsigned int a2)
{
  if (result)
  {
    uint64_t v3 = result;
    if (*(void *)(result + 144))
    {
      if ((*(_WORD *)(result + 136) & 4) == 0) {
        _loadArchInfo(result);
      }
    }

    return BOMFSOArchInfoGetArchSubtype(v3, a2);
  }

  return result;
}

uint64_t BOMFSObjectGetArchSize(uint64_t result, unsigned int a2)
{
  if (result)
  {
    uint64_t v3 = result;
    if (*(void *)(result + 144))
    {
      if ((*(_WORD *)(result + 136) & 4) == 0) {
        _loadArchInfo(result);
      }
    }

    return BOMFSOArchInfoGetArchSize(v3, a2);
  }

  return result;
}

uint64_t BOMFSObjectThinKeepingArchs(uint64_t a1, int *a2, unsigned int a3)
{
  uint64_t result = 1LL;
  if (a1 && a2)
  {
    if (a3)
    {
      if (*(void *)(a1 + 144))
      {
        if ((*(_WORD *)(a1 + 136) & 4) == 0) {
          _loadArchInfo(a1);
        }
      }

      return BOMFSOArchInfoThinKeepingArchs(a1, a2, a3);
    }

    else
    {
      return 0LL;
    }
  }

  return result;
}

uint64_t BOMFSObjectThinKeepingArchsAndSubArchs(uint64_t a1, uint64_t a2, unsigned int a3)
{
  uint64_t result = 1LL;
  if (a1 && a2)
  {
    if (a3)
    {
      if (*(void *)(a1 + 144))
      {
        if ((*(_WORD *)(a1 + 136) & 4) == 0) {
          _loadArchInfo(a1);
        }
      }

      return BOMFSOArchInfoThinKeepingArchsAndSubArchs(a1, a2, a3);
    }

    else
    {
      return 0LL;
    }
  }

  return result;
}

void BOMFSObjectSetArchInfo(uint64_t a1, unsigned int a2, uint64_t a3)
{
  if (a1) {
    BOMFSOArchInfoSet(a1, a2, a3);
  }
}

unsigned __int8 *BOMFSObjectTypeFromRawData(unsigned __int8 *result)
{
  if (result) {
    return (unsigned __int8 *)*result;
  }
  return result;
}

void capture_error( void *a1, uint64_t a2, int a3, uint64_t a4, const char *a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  v23[0] = 0LL;
  if (a1 && !*a1)
  {
    size_t v14 = calloc(1uLL, 0x30uLL);
    if (v14)
    {
      int v15 = v14;
      v23[1] = &a9;
      if (vasprintf(v23, a5, &a9) < 0)
      {
        size_t v20 = (FILE *)*MEMORY[0x1895F89D0];
        __int128 v21 = __error();
        int v22 = strerror(*v21);
        fprintf(v20, "Could not create error message: %s\n", v22);
      }

      else
      {
        size_t v16 = v23[0];
        if (v23[0])
        {
          *(void *)int v15 = a2;
          v15[2] = a3;
          *((void *)v15 + 2) = "Nov 10 2024";
          *((void *)v15 + 3) = a4;
          *((void *)v15 + 4) = v16;
          v15[10] = *__error();
          *a1 = v15;
          return;
        }

        fwrite("Error message is NULL\n", 0x16uLL, 1uLL, (FILE *)*MEMORY[0x1895F89D0]);
      }

      free(v15);
    }

    else
    {
      uint64_t v17 = (FILE *)*MEMORY[0x1895F89D0];
      size_t v18 = __error();
      unint64_t v19 = strerror(*v18);
      fprintf(v17, "Could not allocate error state: %s\n", v19);
    }
  }

void release_error(void *a1)
{
  if (a1)
  {
    unsigned int v2 = (void *)a1[4];
    if (v2) {
      free(v2);
    }
    *((_OWORD *)a1 + 1) = 0u;
    *((_OWORD *)a1 + 2) = 0u;
    *(_OWORD *)a1 = 0u;
    free(a1);
  }

char *BOMCopierSourceEntryTypeString(unsigned int a1)
{
  if (a1 > 0x13) {
    return 0LL;
  }
  else {
    return off_189E3F850[a1];
  }
}

_DWORD *BOMCopierSourceEntryNew(int a1, void *a2)
{
  uint64_t v4 = calloc(1uLL, 0x150uLL);
  int v5 = v4;
  if (v4)
  {
    v4[1] = a1;
    if (once != -1) {
      dispatch_once(&once, &__block_literal_global);
    }
    int v6 = global_groupID;
    v5[21] = global_userID;
    v5[22] = v6;
    *((_WORD *)v5 + 46) = -32348;
    gettimeofday(&v13, 0LL);
    __darwin_time_t tv_sec = v13.tv_sec;
    uint64_t v8 = 1000LL * v13.tv_usec;
    *((void *)v5 + 13) = v13.tv_sec;
    *((void *)v5 + 14) = v8;
    *((void *)v5 + 15) = tv_sec;
    *((void *)v5 + 16) = v8;
    *((void *)v5 + 17) = tv_sec;
    *((void *)v5 + 18) = v8;
    v5[81] = -1;
  }

  else
  {
    int v9 = *__error();
    __int16 v10 = __error();
    __int128 v11 = strerror(*v10);
    BOMCopierErrorCapture( a2,  v9,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c",  514,  (uint64_t)"BOMCopierSourceEntryNew",  "Could not allocate %ld bytes for BOMCopierSourceEntry: %s",  336LL,  v11);
  }

  return v5;
}

uint64_t __BOMCopierSourceEntryNew_block_invoke()
{
  global_userID = geteuid();
  uint64_t result = getegid();
  global_groupID = result;
  return result;
}

uint64_t BOMCopierSourceEntryNewFromPath(char *a1, char a2, void *a3)
{
  uint64_t v26 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    BOMCopierErrorCapture( a3,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c",  557,  (uint64_t)"BOMCopierSourceEntryNewFromPath",  "Invalid path");
    return 0LL;
  }

  if (lstat(a1, &v24))
  {
    int v6 = *__error();
    uint64_t v7 = __error();
    strerror(*v7);
    BOMCopierErrorCapture( a3,  v6,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c",  572,  (uint64_t)"BOMCopierSourceEntryNewFromPath",  "Could not stat %s: %s");
    return 0LL;
  }

  int v10 = mode_to_source_entry_type(v24.st_mode);
  __int128 v11 = BOMCopierSourceEntryNew(v10, a3);
  uint64_t v8 = (uint64_t)v11;
  if (!v11)
  {
    BOMCopierErrorCapture( a3,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c",  581,  (uint64_t)"BOMCopierSourceEntryNewFromPath",  "Could not create BOMCopierSourceEntry for type %d",  v10);
    return v8;
  }

  *__int128 v11 = 1;
  int v12 = resolve_path(a1, v10 == 9, a3);
  *(void *)(v8 + 16) = v12;
  if (!v12)
  {
    BOMCopierErrorCapture( a3,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c",  593,  (uint64_t)"BOMCopierSourceEntryNewFromPath",  "Could not resolve %s");
    goto LABEL_29;
  }

  timeval v13 = v12;
  size_t v14 = strdup(a1);
  *(void *)(v8 + 24) = v14;
  if (!v14)
  {
    int v19 = *__error();
    size_t v20 = __error();
    strerror(*v20);
    BOMCopierErrorCapture( a3,  v19,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c",  602,  (uint64_t)"BOMCopierSourceEntryNewFromPath",  "Could not duplicate path %s: %s");
    goto LABEL_29;
  }

  if (v10 == 9)
  {
    bzero(__s1, 0x400uLL);
    ssize_t v15 = readlink(v13, __s1, 0x400uLL);
    if (v15 == -1)
    {
      if (*__error() != 13)
      {
        int v22 = *__error();
        uint64_t v23 = __error();
        strerror(*v23);
        BOMCopierErrorCapture( a3,  v22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c",  620,  (uint64_t)"BOMCopierSourceEntryNewFromPath",  "Could not readlink %s: %s\n");
        goto LABEL_29;
      }
    }

    else if (v15 >= 1)
    {
      __s1[v15] = 0;
      size_t v16 = strdup(__s1);
      *(void *)(v8 + 48) = v16;
      if (!v16)
      {
        int v17 = *__error();
        size_t v18 = __error();
        strerror(*v18);
        BOMCopierErrorCapture( a3,  v17,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c",  633,  (uint64_t)"BOMCopierSourceEntryNewFromPath",  "Could not duplicate %s: %s\n");
LABEL_29:
        BOMCopierSourceEntryFree((unsigned int *)v8);
        return 0LL;
      }
    }
  }

  *(void *)(v8 + 84) = *(void *)&v24.st_uid;
  timespec st_mtimespec = v24.st_mtimespec;
  *(timespec *)(v8 + 104) = v24.st_atimespec;
  *(_DWORD *)(v8 + 64) = v24.st_dev;
  *(void *)(v8 + 72) = v24.st_ino;
  *(_WORD *)(v8 + 80) = v24.st_nlink;
  *(_WORD *)(v8 + 92) = v24.st_mode;
  *(void *)(v8 + 96) = v24.st_size;
  *(timespec *)(v8 + 120) = st_mtimespec;
  *(timespec *)(v8 + 136) = v24.st_ctimespec;
  *(_DWORD *)(v8 + 152) = v24.st_flags;
  if ((a2 & 2) != 0 && v10 == 8 && parse_regular_file(v8, a3))
  {
    BOMCopierErrorCapture( a3,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c",  672,  (uint64_t)"BOMCopierSourceEntryNewFromPath",  "Could not parse the regular file");
    goto LABEL_29;
  }

  if (capture_extended_attributes(v8, a2, a3))
  {
    BOMCopierErrorCapture( a3,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c",  686,  (uint64_t)"BOMCopierSourceEntryNewFromPath",  "Could not capture extended attributes");
    goto LABEL_29;
  }

  if ((a2 & 0x20) != 0 && capture_acl(v8, a3))
  {
    BOMCopierErrorCapture( a3,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c",  700,  (uint64_t)"BOMCopierSourceEntryNewFromPath",  "Could not capture access control list");
    goto LABEL_29;
  }

  return v8;
}

uint64_t mode_to_source_entry_type(__int16 a1)
{
  unsigned int v1 = (a1 & 0xF000) - 4096;
  if (v1 >> 13 > 6) {
    return 0LL;
  }
  else {
    return dword_18635AE50[v1 >> 12];
  }
}

char *resolve_path(char *a1, char a2, void *a3)
{
  uint64_t v23 = *MEMORY[0x1895F89C0];
  if ((a2 & 1) == 0)
  {
    uint64_t result = realpath_DARWIN_EXTSN(a1, 0LL);
    if (result) {
      return result;
    }
    int v8 = *__error();
    int v9 = __error();
    strerror(*v9);
    BOMCopierErrorCapture( a3,  v8,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c",  5332,  (uint64_t)"resolve_path",  "Could not realpath %s: %s\n");
    return 0LL;
  }

  if (dirname_r(a1, v22) != v22)
  {
    int v5 = *__error();
    int v6 = __error();
    strerror(*v6);
    BOMCopierErrorCapture( a3,  v5,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c",  5346,  (uint64_t)"resolve_path",  "Could not dirname %s: %s\n");
    return 0LL;
  }

  int v10 = realpath_DARWIN_EXTSN(v22, 0LL);
  if (!v10)
  {
    int v15 = *__error();
    __error();
    size_t v16 = __error();
    strerror(*v16);
    BOMCopierErrorCapture( a3,  v15,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c",  5353,  (uint64_t)"resolve_path",  "Could not realpath %s %d: %s\n",  v22);
    return 0LL;
  }

  __int128 v11 = v10;
  if (basename_r(a1, v21) != v21)
  {
    int v12 = *__error();
    timeval v13 = __error();
    size_t v14 = strerror(*v13);
    BOMCopierErrorCapture( a3,  v12,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c",  5360,  (uint64_t)"resolve_path",  "Could not basename %s: %s\n",  a1,  v14);
    free(v11);
    return 0LL;
  }

  size_t v20 = 0LL;
  int v17 = asprintf(&v20, "%s/%s", v11, v21);
  free(v11);
  if (v17 < 0 || (uint64_t result = v20) == 0LL)
  {
    int v18 = *__error();
    int v19 = __error();
    strerror(*v19);
    BOMCopierErrorCapture( a3,  v18,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c",  5373,  (uint64_t)"resolve_path",  "Could not construct resolved path from %s + %s: %s\n",  v22);
    return 0LL;
  }

  return result;
}

uint64_t BOMCopierSourceEntryFree(unsigned int *a1)
{
  if (!a1)
  {
    BOMCopierErrorCapture( 0LL,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c",  1739,  (uint64_t)"BOMCopierSourceEntryFree",  "Invalid source_entry");
    return 1LL;
  }

  int v2 = a1[81];
  if (v2 != -1) {
    close(v2);
  }
  if (*((_BYTE *)a1 + 320))
  {
    if (!*((void *)a1 + 2))
    {
      uint64_t v6 = 1LL;
      fwrite("Could not get actual path", 0x19uLL, 1uLL, (FILE *)*MEMORY[0x1895F89D0]);
      return v6;
    }

    unsigned int v3 = a1[1];
    if (v3 - 8 >= 3)
    {
      if (v3 == 6 && rmdir(*((const char **)a1 + 2)))
      {
        uint64_t v7 = (FILE *)*MEMORY[0x1895F89D0];
        int v8 = __error();
        strerror(*v8);
        fprintf(v7, "Could not rmdir %s: %s");
        return 1LL;
      }
    }

    else if (unlink(*((const char **)a1 + 2)))
    {
      uint64_t v4 = (FILE *)*MEMORY[0x1895F89D0];
      int v5 = __error();
      strerror(*v5);
      fprintf(v4, "Could not unlink %s: %s");
      return 1LL;
    }
  }

  int v9 = (void *)*((void *)a1 + 5);
  if (v9) {
    free(v9);
  }
  int v10 = (void *)*((void *)a1 + 4);
  if (v10) {
    free(v10);
  }
  __int128 v11 = (void *)*((void *)a1 + 3);
  if (v11) {
    free(v11);
  }
  int v12 = (void *)*((void *)a1 + 2);
  if (v12) {
    free(v12);
  }
  timeval v13 = (void *)*((void *)a1 + 6);
  if (v13) {
    free(v13);
  }
  size_t v14 = (void *)*((void *)a1 + 7);
  if (v14) {
    free(v14);
  }
  int v15 = (void *)*((void *)a1 + 25);
  if (v15) {
    free(v15);
  }
  size_t v16 = (void *)*((void *)a1 + 21);
  if (v16) {
    free(v16);
  }
  int v17 = (void *)*((void *)a1 + 30);
  if (v17) {
    free(v17);
  }
  if (a1[52])
  {
    uint64_t v18 = 0LL;
    unint64_t v19 = 0LL;
    do
    {
      free(*(void **)(*((void *)a1 + 27) + v18));
      size_t v20 = *(void **)(*((void *)a1 + 27) + v18 + 16);
      if (v20) {
        free(v20);
      }
      ++v19;
      v18 += 24LL;
    }

    while (v19 < a1[52]);
  }

  __int128 v21 = (void *)*((void *)a1 + 27);
  if (v21) {
    free(v21);
  }
  int v22 = (void *)*((void *)a1 + 28);
  if (v22) {
    free(v22);
  }
  uint64_t v23 = (void *)*((void *)a1 + 39);
  if (v23) {
    free(v23);
  }
  *((_OWORD *)a1 + 19) = 0u;
  *((_OWORD *)a1 + 20) = 0u;
  *((_OWORD *)a1 + 17) = 0u;
  *((_OWORD *)a1 + 18) = 0u;
  *((_OWORD *)a1 + 15) = 0u;
  *((_OWORD *)a1 + 16) = 0u;
  *((_OWORD *)a1 + 13) = 0u;
  *((_OWORD *)a1 + 14) = 0u;
  *((_OWORD *)a1 + 11) = 0u;
  *((_OWORD *)a1 + 12) = 0u;
  *((_OWORD *)a1 + 9) = 0u;
  *((_OWORD *)a1 + 10) = 0u;
  *((_OWORD *)a1 + 7) = 0u;
  *((_OWORD *)a1 + 8) = 0u;
  *((_OWORD *)a1 + 5) = 0u;
  *((_OWORD *)a1 + 6) = 0u;
  *((_OWORD *)a1 + 3) = 0u;
  *((_OWORD *)a1 + 4) = 0u;
  *((_OWORD *)a1 + 1) = 0u;
  *((_OWORD *)a1 + 2) = 0u;
  *(_OWORD *)a1 = 0u;
  free(a1);
  return 0LL;
}

uint64_t parse_regular_file(uint64_t a1, void *a2)
{
  if (a1)
  {
    if (*(_BYTE *)(a1 + 156))
    {
      int v4 = 1;
      size_t v5 = 4096LL;
      goto LABEL_10;
    }
  }

  else
  {
    fwrite("Invalid source_entry", 0x14uLL, 1uLL, (FILE *)*MEMORY[0x1895F89D0]);
  }

  unint64_t Size = BOMCopierSourceEntryGetSize(a1);
  if (Size >= 0x1000) {
    size_t v5 = 4096LL;
  }
  else {
    size_t v5 = Size;
  }
  if (!Size) {
    return 0LL;
  }
  int v4 = 0;
LABEL_10:
  uint64_t v7 = (char *)malloc(0x1000uLL);
  if (!v7)
  {
    int v12 = *__error();
    timeval v13 = __error();
    size_t v14 = strerror(*v13);
    BOMCopierErrorCapture( a2,  v12,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c",  4004,  (uint64_t)"parse_regular_file",  "Could not allocate %lld bytes for parse buffer: %s",  4096LL,  v14);
    return 1LL;
  }

  int v8 = v7;
  size_t v9 = BOMCopierSourceEntryRead(a1, v7, v5, a2);
  unint64_t v10 = v9;
  if (v4)
  {
    if (!v9)
    {
      free(v8);
      return 0LL;
    }

    if (v9 == -1LL)
    {
      BOMCopierSourceEntryGetPath(a1);
      uint64_t v11 = 1LL;
      BOMCopierErrorCapture( a2,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c",  4019,  (uint64_t)"parse_regular_file",  "Could not read %lu bytes from %s");
LABEL_24:
      free(v8);
      return v11;
    }
  }

  else if (v9 != v5)
  {
    BOMCopierSourceEntryGetPath(a1);
    uint64_t v11 = 1LL;
    BOMCopierErrorCapture( a2,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c",  4035,  (uint64_t)"parse_regular_file",  "Could not read %lu bytes from %s");
    goto LABEL_24;
  }

  *(void *)(a1 + 160) = 4096LL;
  *(void *)(a1 + 168) = v8;
  *(void *)(a1 + 176) = v9;
  if (v9 < 0x1C) {
    return 0LL;
  }
  uint64_t v11 = 0LL;
  int v15 = *(_DWORD *)v8;
  if (*(int *)v8 <= -822415875)
  {
    int v16 = 3;
    if (v15 > -889275715)
    {
      if (v15 != -889275714)
      {
        int v17 = -889275713;
        goto LABEL_33;
      }
    }

    else if (v15 != -1095041334)
    {
      int v17 = -1078264118;
LABEL_33:
      if (v15 != v17) {
        return v11;
      }
      int v16 = 4;
    }

    unint64_t v21 = *(void *)v8;
    size_t __count = *(void *)v8;
    if ((v15 & 0xFEFFFFFF) == 0xBEBAFECA)
    {
      int v22 = BOMHostByteOrder();
      BOMSwapFatHeader((int8x8_t *)&__count, v22);
      LODWORD(v23) = HIDWORD(__count);
    }

    else
    {
      unint64_t v23 = HIDWORD(v21);
    }

    uint64_t v27 = v23;
    __int128 v28 = calloc(v23, 0x20uLL);
    if (!v28)
    {
      int v31 = *__error();
      __int128 v32 = __error();
      __int128 v33 = strerror(*v32);
      BOMCopierErrorCapture( a2,  v31,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c",  4235,  (uint64_t)"parse_regular_file",  "Could not allocate BOMCopierArchRecord: %s",  v33);
      uint64_t v11 = 1LL;
      goto LABEL_24;
    }

    __int128 v25 = v28;
    if (v15 == -1078264118 || v15 == -889275713) {
      uint64_t v30 = 32LL;
    }
    else {
      uint64_t v30 = 20LL;
    }
    if (v10 < v30 * (unint64_t)(v23 + 1) + 8)
    {
      uint64_t v11 = 0LL;
      int v8 = v28;
      goto LABEL_24;
    }

    int v46 = v16;
    if ((_DWORD)v23)
    {
      __int128 v34 = (char *)v8 + 8;
      __int128 v35 = v28;
      do
      {
        if (v15 == -889275714 || v15 == -1095041334)
        {
          __memcpy_chk();
          if (v15 == -1095041334)
          {
            int v37 = BOMHostByteOrder();
            BOMSwapFatArch((uint64_t)v48, 1u, v37);
          }

          void *v35 = *(void *)v48;
          *(void *)&__int128 v38 = *(unsigned int *)&v48[8];
          *((void *)&v38 + 1) = *(unsigned int *)&v48[12];
          *(_OWORD *)(v35 + 1) = v38;
          uint64_t v39 = *(unsigned int *)&v48[16];
        }

        else
        {
          __memcpy_chk();
          if (v15 == -1078264118)
          {
            int v40 = BOMHostByteOrder();
            BOMSwapFatArch64((uint64_t)v48, 1u, v40);
          }

          void *v35 = *(void *)v48;
          *(_OWORD *)(v35 + 1) = *(_OWORD *)&v48[8];
          uint64_t v39 = *(unsigned int *)&v48[24];
        }

        v35[3] = v39;
        v34 += v30;
        v35 += 4;
        --v27;
      }

      while (v27);
    }

    int v19 = v46;
LABEL_77:
    uint64_t v11 = 0LL;
    *(_DWORD *)(a1 + 192) = v19;
    *(_DWORD *)(a1 + 196) = v23;
    *(void *)(a1 + 200) = v25;
    return v11;
  }

  int v19 = 1;
  if (v15 > -17958195)
  {
    if (v15 != -17958194)
    {
      int v20 = -17958193;
LABEL_39:
      if (v15 != v20) {
        return v11;
      }
      if (v9 >= 0x20)
      {
        int v19 = 2;
        goto LABEL_42;
      }

      return 0LL;
    }
  }

  else if (v15 != -822415874)
  {
    int v20 = -805638658;
    goto LABEL_39;
  }

ssize_t capture_extended_attributes(uint64_t a1, char a2, void *a3)
{
  if ((a2 & 0x1C) == 0) {
    return 0LL;
  }
  if (a1)
  {
    uint64_t v6 = *(const char **)(a1 + 16);
  }

  else
  {
    fwrite("Invalid source_entry", 0x14uLL, 1uLL, (FILE *)*MEMORY[0x1895F89D0]);
    uint64_t v6 = 0LL;
  }

  if ((a2 & 0x10) != 0) {
    int v8 = 33;
  }
  else {
    int v8 = 1;
  }
  ssize_t result = listxattr(v6, 0LL, 0LL, v8);
  if (result)
  {
    size_t v9 = result;
    if (result == -1)
    {
      if (*__error() == 1 || *__error() == 45 || *__error() == 13) {
        return 0LL;
      }
      int v10 = *__error();
      uint64_t v11 = __error();
      strerror(*v11);
      BOMCopierErrorCapture( a3,  v10,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c",  4409,  (uint64_t)"capture_extended_attributes",  "Could not listxattr %s: %s");
      return 1LL;
    }

    int v12 = (char *)malloc(result);
    if (v12)
    {
      timeval v13 = v12;
      if (listxattr(v6, v12, v9, v8) == v9)
      {
        LODWORD(v14) = 0;
        unint64_t v15 = (unint64_t)&v13[v9];
        int v16 = v13;
        do
        {
          size_t v14 = (v14 + 1);
          v16 += strlen(v16) + 1;
        }

        while ((unint64_t)v16 < v15);
        int v17 = calloc(v14, 0x18uLL);
        if (v17)
        {
          uint64_t v18 = v17;
          unsigned int v19 = 0;
          int v20 = v13;
          unsigned int v21 = 0;
          __int128 v38 = a3;
          uint64_t v39 = (char *)v20;
          while (1)
          {
            if ((a2 & 4) != 0)
            {
              if ((a2 & 8) != 0) {
                goto LABEL_30;
              }
              if (string_compare(v20, "com.apple.FinderInfo"))
              {
                BOOL v22 = string_compare(v20, "com.apple.ResourceFork") != 0;
                if ((a2 & 0x10) == 0) {
                  goto LABEL_38;
                }
                goto LABEL_31;
              }
            }

            else if ((a2 & 8) != 0)
            {
              if (string_compare(v20, "com.apple.FinderInfo"))
              {
                BOOL v22 = string_compare(v20, "com.apple.ResourceFork") == 0;
                if ((a2 & 0x10) == 0) {
                  goto LABEL_38;
                }
                goto LABEL_31;
              }

LABEL_31:
            if (!string_compare(v20, "com.apple.decmpfs")
              || (!string_compare(v20, "com.apple.ResourceFork") ? (char v23 = 1) : (char v23 = v22), (v23 & 1) != 0))
            {
LABEL_39:
              stat v24 = strdup(v20);
              v18[3 * v21] = v24;
              if (!v24)
              {
                int v34 = *__error();
                __int128 v35 = __error();
                strerror(*v35);
                BOMCopierErrorCapture( v38,  v34,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c",  4549,  (uint64_t)"capture_extended_attributes",  "Could not duplicate %s: %s");
LABEL_57:
                free(v18);
                __int128 v33 = v39;
                goto LABEL_58;
              }

              ++v19;
              ++v21;
            }

  int v17 = (CC_SHA256_CTX *)a1[8];
  if (!v17)
  {
    int v17 = (CC_SHA256_CTX *)calloc(1uLL, 0x68uLL);
    a1[8] = (uint64_t)v17;
    if (!v17)
    {
      __int128 v35 = *__error();
      int v36 = __error();
      strerror(*v36);
      BOMCopierErrorCapture( a2,  v35,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDataAnalyzer.c",  584,  (uint64_t)"init_data_analyzer",  "Could not allocate SHA224 context: %s");
      return 1LL;
    }
  }

  CC_SHA224_Init(v17);
  if (!a1[14])
  {
    uint64_t v18 = malloc(0x1CuLL);
    a1[14] = (uint64_t)v18;
    if (!v18)
    {
      int v37 = *__error();
      __int128 v38 = __error();
      strerror(*v38);
      BOMCopierErrorCapture( a2,  v37,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDataAnalyzer.c",  596,  (uint64_t)"init_data_analyzer",  "Could not allocate SHA224 digest: %s");
      return 1LL;
    }
  }

  ++v5;
  int v4 = *a1;
  if ((*a1 & 0x40) != 0) {
    goto LABEL_36;
  }
LABEL_7:
  if ((v4 & 0x80) != 0)
  {
LABEL_41:
    unsigned int v21 = (CC_SHA512_CTX *)a1[10];
    if (!v21)
    {
      unsigned int v21 = (CC_SHA512_CTX *)calloc(1uLL, 0xD0uLL);
      a1[10] = (uint64_t)v21;
      if (!v21)
      {
        uint64_t v43 = *__error();
        __int128 v44 = __error();
        strerror(*v44);
        BOMCopierErrorCapture( a2,  v43,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDataAnalyzer.c",  646,  (uint64_t)"init_data_analyzer",  "Could not allocate SHA384 context: %s");
        return 1LL;
      }
    }

    CC_SHA384_Init(v21);
    if (!a1[16])
    {
      BOOL v22 = malloc(0x30uLL);
      a1[16] = (uint64_t)v22;
      if (!v22)
      {
        int v45 = *__error();
        int v46 = __error();
        strerror(*v46);
        BOMCopierErrorCapture( a2,  v45,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDataAnalyzer.c",  658,  (uint64_t)"init_data_analyzer",  "Could not allocate SHA384 digest: %s");
        return 1LL;
      }
    }

    size_t v5 = 1;
  }

uint64_t capture_acl(uint64_t a1, void *a2)
{
  if (a1)
  {
    int v4 = *(const char **)(a1 + 16);
  }

  else
  {
    fwrite("Invalid source_entry", 0x14uLL, 1uLL, (FILE *)*MEMORY[0x1895F89D0]);
    int v4 = 0LL;
  }

  if (*(_DWORD *)(a1 + 4) == 9) {
    acl_t link_np = acl_get_link_np(v4, ACL_TYPE_EXTENDED);
  }
  else {
    acl_t link_np = acl_get_file(v4, ACL_TYPE_EXTENDED);
  }
  uint64_t v6 = link_np;
  if (link_np)
  {
    ssize_t len_p = 0LL;
    uint64_t v7 = acl_to_text(link_np, &len_p);
    if (v7)
    {
      int v8 = v7;
      acl_free(v6);
      uint64_t result = 0LL;
      ssize_t v10 = len_p;
      *(void *)(a1 + 224) = v8;
      *(void *)(a1 + 232) = v10;
      return result;
    }

    int v11 = *__error();
    int v12 = __error();
    strerror(*v12);
    BOMCopierErrorCapture( a2,  v11,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c",  4682,  (uint64_t)"capture_acl",  "Could not convert ACL to text for %s: %s");
  }

  else
  {
    if (*__error() == 2) {
      return 0LL;
    }
    int v13 = *__error();
    size_t v14 = __error();
    strerror(*v14);
    BOMCopierErrorCapture( a2,  v13,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c",  4666,  (uint64_t)"capture_acl",  "Could not retrieve ACL for %s: %s");
  }

  return 1LL;
}

_DWORD *BOMCopierSourceEntryNewFromResourceFork(const char *a1, void *a2)
{
  uint64_t v33 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    int v4 = realpath_DARWIN_EXTSN(a1, 0LL);
    if (v4)
    {
      size_t v5 = v4;
      if (asprintf(&v30, "%s%s", v4, "/..namedfork/rsrc") < 0)
      {
        int v12 = *__error();
        int v13 = __error();
        size_t v14 = strerror(*v13);
        BOMCopierErrorCapture( a2,  v12,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c",  753,  (uint64_t)"BOMCopierSourceEntryNewFromResourceFork",  "Could not constructed resolved rsrc path: %s",  v14);
        free(v5);
      }

      else
      {
        free(v5);
        if (lstat(v30, &v29))
        {
          int v6 = *__error();
          uint64_t v7 = __error();
          strerror(*v7);
          BOMCopierErrorCapture( a2,  v6,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c",  764,  (uint64_t)"BOMCopierSourceEntryNewFromResourceFork",  "Could not stat %s: %s");
        }

        else
        {
          unint64_t v15 = BOMCopierSourceEntryNew(8, a2);
          ssize_t v10 = v15;
          if (!v15)
          {
            BOMCopierErrorCapture( a2,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c",  771,  (uint64_t)"BOMCopierSourceEntryNewFromResourceFork",  "Could not create BOMCopierSourceEntry for regular file");
            return v10;
          }

          *unint64_t v15 = 2;
          *((void *)v15 + 2) = v30;
          int v16 = v15 + 6;
          if (asprintf((char **)v15 + 3, "%s%s", a1, "/..namedfork/rsrc") == -1 || !*v16)
          {
            int v19 = *__error();
            int v20 = __error();
            strerror(*v20);
            BOMCopierErrorCapture( a2,  v19,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c",  785,  (uint64_t)"BOMCopierSourceEntryNewFromResourceFork",  "Could not constructed entry rsrc path: %s");
          }

          else if (__s1 == dirname_r(a1, __s1))
          {
            unsigned int v21 = strdup(__s1);
            *((void *)v10 + 4) = v21;
            if (v21)
            {
              if (v31 == basename_r(a1, v31))
              {
                if (asprintf((char **)v10 + 5, "%s%s", v31, "/..namedfork/rsrc") != -1 && *((void *)v10 + 5))
                {
                  *(void *)(v10 + 21) = *(void *)&v29.st_uid;
                  timespec st_mtimespec = v29.st_mtimespec;
                  *(timespec *)(v10 + 26) = v29.st_atimespec;
                  v10[16] = v29.st_dev;
                  *((void *)v10 + 9) = v29.st_ino;
                  *((_WORD *)v10 + 40) = v29.st_nlink;
                  *((_WORD *)v10 + 46) = v29.st_mode;
                  *((void *)v10 + 12) = v29.st_size;
                  *(timespec *)(v10 + 30) = st_mtimespec;
                  *(timespec *)(v10 + 34) = v29.st_ctimespec;
                  v10[38] = v29.st_flags;
                  return v10;
                }

                int v27 = *__error();
                int v28 = __error();
                strerror(*v28);
                BOMCopierErrorCapture( a2,  v27,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c",  813,  (uint64_t)"BOMCopierSourceEntryNewFromResourceFork",  "Could not constructed entry rsrc name: %s");
              }

              else
              {
                int v22 = *__error();
                char v23 = __error();
                strerror(*v23);
                BOMCopierErrorCapture( a2,  v22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c",  806,  (uint64_t)"BOMCopierSourceEntryNewFromResourceFork",  "Could not basename_r %s: %s");
              }
            }

            else
            {
              int v24 = *__error();
              uint64_t v25 = __error();
              strerror(*v25);
              BOMCopierErrorCapture( a2,  v24,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c",  799,  (uint64_t)"BOMCopierSourceEntryNewFromResourceFork",  "Could not duplicate %s: %s");
            }
          }

          else
          {
            int v17 = *__error();
            uint64_t v18 = __error();
            strerror(*v18);
            BOMCopierErrorCapture( a2,  v17,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c",  792,  (uint64_t)"BOMCopierSourceEntryNewFromResourceFork",  "Could not dirname_r %s: %s");
          }
        }
      }
    }

    else
    {
      int v8 = *__error();
      __error();
      size_t v9 = __error();
      strerror(*v9);
      BOMCopierErrorCapture( a2,  v8,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c",  745,  (uint64_t)"BOMCopierSourceEntryNewFromResourceFork",  "Could not realpath %s %d: %s\n",  a1);
    }
  }

  else
  {
    BOMCopierErrorCapture( a2,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c",  732,  (uint64_t)"BOMCopierSourceEntryNewFromResourceFork",  "Invalid path");
  }

  return 0LL;
}

uint64_t BOMCopierSourceEntryNewFromFTSENT(uint64_t a1, char a2, void *a3)
{
  uint64_t v20 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    BOMCopierErrorCapture( a3,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c",  850,  (uint64_t)"BOMCopierSourceEntryNewFromFTSENT",  "Invalid filesystem_entry");
    return 0LL;
  }

  int v6 = 6;
  switch(*(_WORD *)(a1 + 88))
  {
    case 1:
      break;
    case 2:
      int v6 = 1;
      break;
    case 3:
      int v6 = mode_to_source_entry_type(*(_WORD *)(*(void *)(a1 + 96) + 4LL));
      break;
    case 4:
      int v6 = 2;
      break;
    case 5:
      int v6 = 3;
      break;
    case 6:
      int v6 = 13;
      break;
    case 8:
      int v6 = 8;
      break;
    case 0xC:
      int v6 = 9;
      break;
    case 0xE:
      int v6 = 11;
      break;
    default:
      int v6 = 0;
      break;
  }

  uint64_t v7 = BOMCopierSourceEntryNew(v6, a3);
  uint64_t v8 = (uint64_t)v7;
  if (v7)
  {
    *uint64_t v7 = 3;
    size_t v9 = copy_string(*(const void **)(a1 + 48), *(unsigned __int16 *)(a1 + 64));
    *(void *)(v8 + 16) = v9;
    if (!v9)
    {
      BOMCopierErrorCapture( a3,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c",  877,  (uint64_t)"BOMCopierSourceEntryNewFromFTSENT",  "Could not duplicate %s");
      goto LABEL_36;
    }

    ssize_t v10 = copy_string(*(const void **)(a1 + 48), *(unsigned __int16 *)(a1 + 64));
    *(void *)(v8 + 24) = v10;
    if (!v10)
    {
      BOMCopierErrorCapture( a3,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c",  886,  (uint64_t)"BOMCopierSourceEntryNewFromFTSENT",  "Could not duplicate %s");
      goto LABEL_36;
    }

    if (v6 == 9)
    {
      bzero(v19, 0x400uLL);
      ssize_t v11 = readlink(*(const char **)(a1 + 40), v19, 0x400uLL);
      if (v11 == -1)
      {
        int v14 = *__error();
        unint64_t v15 = __error();
        strerror(*v15);
        BOMCopierErrorCapture( a3,  v14,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c",  899,  (uint64_t)"BOMCopierSourceEntryNewFromFTSENT",  "Could not readlink %s: %s\n");
        goto LABEL_36;
      }

      v19[v11] = 0;
      int v12 = copy_string(v19, v11);
      *(void *)(v8 + 48) = v12;
      if (!v12)
      {
        int v17 = __error();
        strerror(*v17);
        BOMCopierErrorCapture( a3,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c",  909,  (uint64_t)"BOMCopierSourceEntryNewFromFTSENT",  "Could not duplicate %s: %s\n");
        goto LABEL_36;
      }
    }

    uint64_t v13 = *(void *)(a1 + 96);
    *(_DWORD *)(v8 + 64) = *(_DWORD *)v13;
    *(void *)(v8 + 72) = *(void *)(v13 + 8);
    *(_WORD *)(v8 + 80) = *(_WORD *)(v13 + 6);
    *(_WORD *)(v8 + 92) = *(_WORD *)(v13 + 4);
    *(void *)(v8 + 84) = *(void *)(v13 + 16);
    *(void *)(v8 + 96) = *(void *)(v13 + 96);
    *(_OWORD *)(v8 + 104) = *(_OWORD *)(v13 + 32);
    *(_OWORD *)(v8 + 120) = *(_OWORD *)(v13 + 48);
    *(_OWORD *)(v8 + 136) = *(_OWORD *)(v13 + 64);
    *(_DWORD *)(v8 + 152) = *(_DWORD *)(v13 + 116);
    if ((a2 & 1) != 0 && v6 == 8) {
      *(_BYTE *)(v8 + 321) = 1;
    }
    if ((a2 & 2) != 0 && v6 == 8 && parse_regular_file(v8, a3))
    {
      BOMCopierErrorCapture( a3,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c",  961,  (uint64_t)"BOMCopierSourceEntryNewFromFTSENT",  "Could not parse the regular file");
LABEL_36:
      BOMCopierSourceEntryFree((unsigned int *)v8);
      return 0LL;
    }

    if (capture_extended_attributes(v8, a2, a3))
    {
      BOMCopierErrorCapture( a3,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c",  975,  (uint64_t)"BOMCopierSourceEntryNewFromFTSENT",  "Could not capture extended attributes");
      goto LABEL_36;
    }

    if ((a2 & 0x20) != 0)
    {
      int v16 = capture_acl(v8, a3);
      if (v16)
      {
        BOMCopierErrorCapture( a3,  v16,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c",  989,  (uint64_t)"BOMCopierSourceEntryNewFromFTSENT",  "Could not capture access control list");
        goto LABEL_36;
      }
    }
  }

  else
  {
    BOMCopierErrorCapture( a3,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c",  865,  (uint64_t)"BOMCopierSourceEntryNewFromFTSENT",  "Could not create BOMCopierSourceEntry from %d",  v6);
  }

  return v8;
}

_BYTE *copy_string(const void *a1, size_t a2)
{
  size_t v4 = a2 + 1;
  size_t v5 = malloc(a2 + 1);
  int v6 = v5;
  if (v5)
  {
    memcpy(v5, a1, a2);
    v6[a2] = 0;
  }

  else
  {
    uint64_t v7 = (FILE *)*MEMORY[0x1895F89D0];
    uint64_t v8 = __error();
    size_t v9 = strerror(*v8);
    fprintf(v7, "Could not allocate copy buffer of %ld bytes: %s\n", v4, v9);
  }

  return v6;
}

uint64_t BOMCopierSourceEntryNewFromFSObject(const char *a1, uint64_t a2, __int16 a3, void *a4)
{
  uint64_t v57 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    BOMCopierErrorCapture( a4,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c",  1023,  (uint64_t)"BOMCopierSourceEntryNewFromFSObject",  "Invalid source_path");
    return 0LL;
  }

  if (!a2)
  {
    BOMCopierErrorCapture( a4,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c",  1029,  (uint64_t)"BOMCopierSourceEntryNewFromFSObject",  "Invalid fso");
    return 0LL;
  }

  __int16 v8 = BOMFSObjectMode(a2);
  uint64_t v9 = BOMFSObjectPathName(a2);
  if (!v9)
  {
    BOMCopierErrorCapture( a4,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c",  1047,  (uint64_t)"BOMCopierSourceEntryNewFromFSObject",  "Could not retrieve path from fso\n");
    return 0LL;
  }

  ssize_t v10 = (const char *)v9;
  int v11 = mode_to_source_entry_type(v8);
  int v12 = strcmp(v10, ".");
  if (v12) {
    int v13 = 0;
  }
  else {
    int v13 = 6;
  }
  if (v11) {
    int v14 = v11;
  }
  else {
    int v14 = v13;
  }
  unint64_t v15 = BOMCopierSourceEntryNew(v14, a4);
  uint64_t v16 = (uint64_t)v15;
  if (!v15)
  {
    BOMCopierErrorCapture( a4,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c",  1063,  (uint64_t)"BOMCopierSourceEntryNewFromFSObject",  "Could not create BOMCopierSourceEntry from %d",  v14);
    return v16;
  }

  *unint64_t v15 = 4;
  int v17 = strdup(v10);
  *(void *)(v16 + 24) = v17;
  if (!v17)
  {
    unsigned int v21 = __error();
    strerror(*v21);
    BOMCopierErrorCapture( a4,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c",  1076,  (uint64_t)"BOMCopierSourceEntryNewFromFSObject",  "Could not duplicate fso_path %s: %s\n");
    goto LABEL_23;
  }

  uint64_t v55 = 0LL;
  if (v12)
  {
    if (asprintf(&v55, "%s/%s", a1, v10 + 2) == -1 || (uint64_t v18 = v55) == 0LL)
    {
      int v19 = __error();
      strerror(*v19);
      BOMCopierErrorCapture( a4,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c",  1097,  (uint64_t)"BOMCopierSourceEntryNewFromFSObject",  "Could not construct path from %s and %s: %s\n",  a1);
      goto LABEL_23;
    }
  }

  else
  {
    uint64_t v18 = strdup(a1);
    uint64_t v55 = v18;
    if (!v18)
    {
      int v30 = __error();
      strerror(*v30);
      BOMCopierErrorCapture( a4,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c",  1087,  (uint64_t)"BOMCopierSourceEntryNewFromFSObject",  "Could not duplicate %s: %s\n");
      goto LABEL_23;
    }
  }

  int v22 = lstat(v18, &v54);
  if (v22)
  {
    if (*__error() != 13 && *__error() != 1)
    {
      int v34 = *__error();
      __int128 v35 = __error();
      strerror(*v35);
      BOMCopierErrorCapture( a4,  v34,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c",  1121,  (uint64_t)"BOMCopierSourceEntryNewFromFSObject",  "Could not lstat %s: %s\n");
      goto LABEL_23;
    }

    if ((a3 & 0x100) == 0)
    {
      int v23 = *__error();
      int v24 = __error();
      strerror(*v24);
      BOMCopierErrorCapture( a4,  v23,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c",  1113,  (uint64_t)"BOMCopierSourceEntryNewFromFSObject",  "Could not lstat %s: %s\n");
      goto LABEL_23;
    }
  }

  unsigned int v53 = 0LL;
  uint64_t v25 = resolve_path(v55, v14 == 9, &v53);
  *(void *)(v16 + 16) = v25;
  if (!v25)
  {
    int Code = BOMCopierErrorGetCode((uint64_t)v53);
    if (Code != 13 && Code != 1)
    {
      BOMCopierErrorCapture( a4,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c",  1147,  (uint64_t)"BOMCopierSourceEntryNewFromFSObject",  "Could not resolve %s",  v55);
      BOMCopierSourceEntryFree((unsigned int *)v16);
      free(v55);
      return 0LL;
    }

    if ((a3 & 0x100) == 0)
    {
      int v32 = *__error();
      uint64_t v33 = __error();
      strerror(*v33);
      BOMCopierErrorCapture( a4,  v32,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c",  1137,  (uint64_t)"BOMCopierSourceEntryNewFromFSObject",  "Could not resolve path for %s: %s\n");
      goto LABEL_23;
    }

    BOMCopierErrorFree(v53);
    goto LABEL_49;
  }

  if (v22)
  {
LABEL_49:
    int v36 = v55;
    int v37 = strdup(v55);
    *(void *)(v16 + 16) = v37;
    if (v37)
    {
      free(v36);
      if (v14 == 9)
      {
        __int128 v38 = (const char *)BOMFSObjectSymlinkTarget(a2);
        if (!v38)
        {
          BOMCopierErrorCapture( a4,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c",  1183,  (uint64_t)"BOMCopierSourceEntryNewFromFSObject",  "Could not get symlink target from fso\n",  v51,  v52);
          goto LABEL_23;
        }

        uint64_t v39 = strdup(v38);
        *(void *)(v16 + 48) = v39;
        if (!v39)
        {
          uint64_t v48 = __error();
          strerror(*v48);
          BOMCopierErrorCapture( a4,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c",  1191,  (uint64_t)"BOMCopierSourceEntryNewFromFSObject",  "Could not duplicate %s: %s\n");
          goto LABEL_23;
        }
      }

      *(_WORD *)(v16 + 92) = BOMFSObjectMode(a2);
      *(_DWORD *)(v16 + 84) = BOMFSObjectUserID(a2);
      *(_DWORD *)(v16 + 88) = BOMFSObjectGroupID(a2);
      uint64_t v40 = BOMFSObjectSize(a2);
      *(void *)(v16 + 104) = 0LL;
      *(void *)(v16 + 112) = 0LL;
      *(void *)(v16 + 96) = v40;
      *(void *)(v16 + 120) = BOMFSObjectModTime(a2);
      *(void *)(v16 + 128) = 0LL;
      *(void *)(v16 + 136) = 0LL;
      *(void *)(v16 + 144) = 0LL;
      *(_DWORD *)(v16 + 152) = 0;
      return v16;
    }

    int v41 = *__error();
    uint64_t v42 = v55;
    uint64_t v43 = __error();
    __int128 v44 = strerror(*v43);
    BOMCopierErrorCapture( a4,  v41,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c",  1165,  (uint64_t)"BOMCopierSourceEntryNewFromFSObject",  "Could not duplicate %s: %s",  v42,  v44);
    free(v55);
LABEL_23:
    BOMCopierSourceEntryFree((unsigned int *)v16);
    return 0LL;
  }

  free(v55);
  if (v14 == 9)
  {
    bzero(__s1, 0x400uLL);
    ssize_t v26 = readlink(*(const char **)(v16 + 16), __s1, 0x400uLL);
    if (v26 == -1)
    {
      int v46 = *__error();
      unsigned int v47 = __error();
      strerror(*v47);
      BOMCopierErrorCapture( a4,  v46,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c",  1226,  (uint64_t)"BOMCopierSourceEntryNewFromFSObject",  "Could not readlink %s: %s\n");
      goto LABEL_23;
    }

    __s1[v26] = 0;
    int v27 = strdup(__s1);
    *(void *)(v16 + 48) = v27;
    if (!v27)
    {
      int v49 = *__error();
      int v50 = __error();
      strerror(*v50);
      BOMCopierErrorCapture( a4,  v49,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c",  1236,  (uint64_t)"BOMCopierSourceEntryNewFromFSObject",  "Could not duplicate %s: %s\n");
      goto LABEL_23;
    }
  }

  *(void *)(v16 + 84) = *(void *)&v54.st_uid;
  timespec st_mtimespec = v54.st_mtimespec;
  *(timespec *)(v16 + 104) = v54.st_atimespec;
  *(_DWORD *)(v16 + 64) = v54.st_dev;
  *(void *)(v16 + 72) = v54.st_ino;
  *(_WORD *)(v16 + 80) = v54.st_nlink;
  *(_WORD *)(v16 + 92) = v54.st_mode;
  *(void *)(v16 + 96) = v54.st_size;
  *(timespec *)(v16 + 120) = st_mtimespec;
  *(timespec *)(v16 + 136) = v54.st_ctimespec;
  *(_DWORD *)(v16 + 152) = v54.st_flags;
  if ((a3 & 0x80) != 0) {
    *(_DWORD *)(v16 + 84) = BOMFSObjectUserID(a2);
  }
  if ((a3 & 2) != 0 && v14 == 8)
  {
    int v29 = parse_regular_file(v16, a4);
    if (v29)
    {
      BOMCopierErrorCapture( a4,  v29,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c",  1280,  (uint64_t)"BOMCopierSourceEntryNewFromFSObject",  "Could not parse the regular file",  v51,  v52);
      goto LABEL_23;
    }
  }

  int v45 = capture_extended_attributes(v16, a3, a4);
  if (v45)
  {
    BOMCopierErrorCapture( a4,  v45,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c",  1294,  (uint64_t)"BOMCopierSourceEntryNewFromFSObject",  "Could not capture extended attributes",  v51,  v52);
    goto LABEL_23;
  }

  if ((a3 & 0x20) != 0 && capture_acl(v16, a4))
  {
    BOMCopierErrorCapture( a4,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c",  1308,  (uint64_t)"BOMCopierSourceEntryNewFromFSObject",  "Could not capture access control list",  v51,  v52);
    goto LABEL_23;
  }

  return v16;
}

uint64_t BOMCopierSourceEntryNewFromLibarchive(uint64_t a1, uint64_t a2, __int16 a3, void *a4)
{
  if (!a1)
  {
    BOMCopierErrorCapture( a4,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c",  1343,  (uint64_t)"BOMCopierSourceEntryNewFromLibarchive",  "Invalid archive");
    return 0LL;
  }

  if (!a2)
  {
    BOMCopierErrorCapture( a4,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c",  1349,  (uint64_t)"BOMCopierSourceEntryNewFromLibarchive",  "Invalid archive_entry");
    return 0LL;
  }

  __int16 v8 = archive_entry_mode();
  int v9 = mode_to_source_entry_type(v8);
  ssize_t v10 = BOMCopierSourceEntryNew(v9, 0LL);
  uint64_t v11 = (uint64_t)v10;
  if (!v10)
  {
    BOMCopierErrorCapture( a4,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c",  1364,  (uint64_t)"BOMCopierSourceEntryNewFromLibarchive",  "Could not create BOMCopierSourceEntry from %d",  v9);
    return v11;
  }

  *ssize_t v10 = 5;
  int v12 = (const char *)archive_entry_pathname();
  size_t v13 = strlen(v12) - 1;
  if (v12[v13] == 47)
  {
    int v14 = strdup(v12);
    if (!v14)
    {
      int v24 = *__error();
      uint64_t v25 = __error();
      strerror(*v25);
      BOMCopierErrorCapture( a4,  v24,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c",  1386,  (uint64_t)"BOMCopierSourceEntryNewFromLibarchive",  "Could not duplicate %s: %s");
      goto LABEL_22;
    }

    unint64_t v15 = v14;
    v14[v13] = 0;
    int v12 = v14;
  }

  else
  {
    unint64_t v15 = 0LL;
  }

  uint64_t v16 = strdup(v12);
  *(void *)(v11 + 24) = v16;
  if (!v16)
  {
    int v20 = *__error();
    unsigned int v21 = __error();
    strerror(*v21);
    BOMCopierErrorCapture( a4,  v20,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c",  1398,  (uint64_t)"BOMCopierSourceEntryNewFromLibarchive",  "Could not duplicate %s: %s");
LABEL_22:
    BOMCopierSourceEntryFree((unsigned int *)v11);
    return 0LL;
  }

  int v17 = strdup(v12);
  *(void *)(v11 + 16) = v17;
  if (!v17)
  {
    int v22 = *__error();
    int v23 = __error();
    strerror(*v23);
    BOMCopierErrorCapture( a4,  v22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c",  1406,  (uint64_t)"BOMCopierSourceEntryNewFromLibarchive",  "Could not duplicate %s: %s");
    goto LABEL_22;
  }

  if (v15) {
    free(v15);
  }
  *(void *)(v11 + 256) = a1;
  *(void *)(v11 + 264) = a2;
  *(_DWORD *)(v11 + 64) = archive_entry_dev();
  *(void *)(v11 + 72) = archive_entry_ino();
  *(_WORD *)(v11 + 80) = archive_entry_nlink();
  *(_WORD *)(v11 + 92) = archive_entry_mode();
  *(_DWORD *)(v11 + 84) = archive_entry_uid();
  *(_DWORD *)(v11 + 88) = archive_entry_gid();
  *(void *)(v11 + 96) = archive_entry_size();
  *(void *)(v11 + 104) = archive_entry_atime();
  *(void *)(v11 + 112) = archive_entry_atime_nsec();
  *(void *)(v11 + 120) = archive_entry_mtime();
  *(void *)(v11 + 128) = archive_entry_mtime_nsec();
  *(void *)(v11 + 136) = archive_entry_ctime();
  *(void *)(v11 + 144) = archive_entry_ctime_nsec();
  if ((a3 & 0x200) != 0)
  {
    __int16 v18 = *(_WORD *)(v11 + 92);
    if ((v18 & 0xF000) == 0x4000)
    {
      __int16 v19 = v18 | 0x1ED;
    }

    else if ((*(_WORD *)(v11 + 92) & 0xE00) != 0)
    {
      __int16 v19 = -32348;
    }

    else
    {
      __int16 v19 = v18 | 0x1A4;
    }

    *(_WORD *)(v11 + 92) = v19;
  }

  if (v9 != 8)
  {
    if (v9 != 9) {
      return v11;
    }
    int v27 = (const char *)archive_entry_symlink();
    if (v27)
    {
      int v28 = strdup(v27);
      *(void *)(v11 + 48) = v28;
      if (v28)
      {
        *(void *)(v11 + 96) = strlen(v28);
        return v11;
      }

      int v29 = *__error();
      int v30 = __error();
      strerror(*v30);
      BOMCopierErrorCapture( a4,  v29,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c",  1461,  (uint64_t)"BOMCopierSourceEntryNewFromLibarchive",  "Could not duplicate %s: %s\n");
    }

    else
    {
      BOMCopierErrorCapture( a4,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c",  1453,  (uint64_t)"BOMCopierSourceEntryNewFromLibarchive",  "Could not get symlink target from Libarchive entry\n");
    }

    goto LABEL_22;
  }

  if ((a3 & 2) != 0 && parse_regular_file(v11, a4))
  {
    BOMCopierErrorCapture( a4,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c",  1480,  (uint64_t)"BOMCopierSourceEntryNewFromLibarchive",  "Could not parse the regular file");
    goto LABEL_22;
  }

  return v11;
}

uint64_t BOMCopierSourceEntryNewFromDataArchive(uint64_t a1, _DWORD *a2, __int16 a3, void *a4)
{
  if (!a1)
  {
    BOMCopierErrorCapture( a4,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c",  1500,  (uint64_t)"BOMCopierSourceEntryNewFromDataArchive",  "Invalid data_archive");
    return 0LL;
  }

  if (!a2)
  {
    BOMCopierErrorCapture( a4,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c",  1506,  (uint64_t)"BOMCopierSourceEntryNewFromDataArchive",  "Invalid data_archive_entry");
    return 0LL;
  }

  unsigned int type = data_archive_entry_get_type(a2);
  __int16 v9 = data_archive_entry_mode((uint64_t)a2);
  int v10 = mode_to_source_entry_type(v9);
  int v11 = v10;
  if (type == 3)
  {
    switch(v10)
    {
      case 6:
        int v11 = 14;
        break;
      case 9:
        int v11 = 16;
        break;
      case 8:
        int v11 = 15;
        break;
      default:
        BOMCopierErrorCapture( a4,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c",  1533,  (uint64_t)"BOMCopierSourceEntryNewFromDataArchive",  "Unexpected post order entry type: %u");
        return 0LL;
    }
  }

  int v12 = BOMCopierSourceEntryNew(v11, a4);
  uint64_t v13 = (uint64_t)v12;
  if (!v12)
  {
    BOMCopierErrorCapture( a4,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c",  1541,  (uint64_t)"BOMCopierSourceEntryNewFromDataArchive",  "Could not create BOMCopierSourceEntry from %d",  v11);
    return v13;
  }

  _DWORD *v12 = 6;
  int v14 = (const char *)data_archive_entry_path((uint64_t)a2);
  size_t v15 = strlen(v14) - 1;
  if (v14[v15] == 47)
  {
    uint64_t v16 = strdup(v14);
    if (!v16)
    {
      int v28 = *__error();
      int v29 = __error();
      strerror(*v29);
      BOMCopierErrorCapture( a4,  v28,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c",  1563,  (uint64_t)"BOMCopierSourceEntryNewFromDataArchive",  "Could not duplicate %s: %s");
      goto LABEL_41;
    }

    int v17 = v16;
    v16[v15] = 0;
    int v14 = v16;
  }

  else
  {
    int v17 = 0LL;
  }

  __int16 v18 = strdup(v14);
  *(void *)(v13 + 24) = v18;
  if (!v18)
  {
    int v24 = *__error();
    uint64_t v25 = __error();
    strerror(*v25);
    BOMCopierErrorCapture( a4,  v24,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c",  1575,  (uint64_t)"BOMCopierSourceEntryNewFromDataArchive",  "Could not duplicate %s: %s");
LABEL_41:
    BOMCopierSourceEntryFree((unsigned int *)v13);
    return 0LL;
  }

  __int16 v19 = strdup(v14);
  *(void *)(v13 + 16) = v19;
  if (!v19)
  {
    int v26 = *__error();
    int v27 = __error();
    strerror(*v27);
    BOMCopierErrorCapture( a4,  v26,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c",  1583,  (uint64_t)"BOMCopierSourceEntryNewFromDataArchive",  "Could not duplicate %s: %s");
    goto LABEL_41;
  }

  if (v17) {
    free(v17);
  }
  *(void *)(v13 + 272) = a1;
  *(void *)(v13 + 280) = a2;
  *(_DWORD *)(v13 + 64) = data_archive_entry_dev(a2);
  *(void *)(v13 + 72) = data_archive_entry_inode((uint64_t)a2);
  *(_WORD *)(v13 + 80) = data_archive_entry_nlink((uint64_t)a2);
  *(_WORD *)(v13 + 92) = data_archive_entry_mode((uint64_t)a2);
  *(_DWORD *)(v13 + 84) = data_archive_entry_uid(a2);
  *(_DWORD *)(v13 + 88) = data_archive_entry_gid(a2);
  uint64_t v20 = data_archive_entry_size((uint64_t)a2);
  else {
    uint64_t v21 = 0LL;
  }
  *(void *)(v13 + 96) = v21;
  *(void *)(v13 + 104) = data_archive_entry_atime((uint64_t)a2);
  *(void *)(v13 + 112) = data_archive_entry_atime_nsec(a2);
  *(void *)(v13 + 120) = data_archive_entry_mtime((uint64_t)a2);
  *(void *)(v13 + 128) = data_archive_entry_atime_nsec(a2);
  *(void *)(v13 + 136) = data_archive_entry_ctime((uint64_t)a2);
  *(void *)(v13 + 144) = data_archive_entry_atime_nsec(a2);
  *(_BYTE *)(v13 + 156) = data_archive_entry_is_streamed((BOOL)a2);
  if ((a3 & 0x200) != 0)
  {
    __int16 v22 = *(_WORD *)(v13 + 92);
    if ((v22 & 0xF000) == 0x4000)
    {
      __int16 v23 = v22 | 0x1ED;
    }

    else if ((*(_WORD *)(v13 + 92) & 0xE00) != 0)
    {
      __int16 v23 = -32348;
    }

    else
    {
      __int16 v23 = v22 | 0x1A4;
    }

    *(_WORD *)(v13 + 92) = v23;
  }

  if ((a3 & 2) != 0 && v11 == 8 && parse_regular_file(v13, a4))
  {
    BOMCopierErrorCapture( a4,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c",  1649,  (uint64_t)"BOMCopierSourceEntryNewFromDataArchive",  "Could not parse the regular file");
    goto LABEL_41;
  }

  return v13;
}

uint64_t BOMCopierSourceEntryNewFromAppleArchive(uint64_t a1, AAHeader header, unsigned __int8 a3, void *a4)
{
  value[128] = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    BOMCopierErrorCapture( a4,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c",  1669,  (uint64_t)"BOMCopierSourceEntryNewFromAppleArchive",  "Invalid aa_decoder");
    return 0LL;
  }

  if (!header)
  {
    BOMCopierErrorCapture( a4,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c",  1675,  (uint64_t)"BOMCopierSourceEntryNewFromAppleArchive",  "Invalid header");
    return 0LL;
  }

  value[0] = 0LL;
  v9.ikey = 5265748;
  uint32_t KeyIndex = AAHeaderGetKeyIndex(header, v9);
  if ((KeyIndex & 0x80000000) != 0
    || ((FieldUInt = AAHeaderGetFieldUInt(header, KeyIndex, value), FieldUInt <= 1) ? (int v12 = 1) : (int v12 = FieldUInt),
        v12 < 1))
  {
LABEL_15:
    BOMCopierErrorCapture( a4,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c",  1686,  (uint64_t)"BOMCopierSourceEntryNewFromAppleArchive",  "Unknown source entry type");
    return 0LL;
  }

  uint64_t v13 = 0LL;
  int v14 = 8;
  switch(LODWORD(value[0]))
  {
    case 'B':
      int v14 = 7;
      goto LABEL_23;
    case 'C':
      int v14 = 5;
      goto LABEL_23;
    case 'D':
      int v14 = 6;
      goto LABEL_23;
    case 'E':
    case 'G':
    case 'H':
    case 'I':
    case 'J':
    case 'K':
    case 'M':
    case 'N':
    case 'O':
      goto LABEL_15;
    case 'F':
      goto LABEL_24;
    case 'L':
      int v14 = 9;
      goto LABEL_23;
    case 'P':
      int v14 = 4;
      goto LABEL_23;
    default:
      if (LODWORD(value[0]) == 83)
      {
        int v14 = 10;
      }

      else
      {
        if (LODWORD(value[0]) != 87) {
          goto LABEL_15;
        }
        int v14 = 11;
      }

LABEL_103:
  v71.ikey = 4475221;
  uint32_t v72 = AAHeaderGetKeyIndex(header, v71);
  if ((v72 & 0x80000000) != 0) {
    goto LABEL_110;
  }
  unsigned int v73 = AAHeaderGetFieldUInt(header, v72, &v94);
  if (v73 <= 1) {
    int v74 = 1;
  }
  else {
    int v74 = v73;
  }
  if (v74 < 0)
  {
    BOMCopierErrorCapture( a4,  v74,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c",  5766,  (uint64_t)"populate_source_entry_from_apple_archive",  "Could not get AppleArchive uid: %d");
    goto LABEL_149;
  }

  if (v73 <= 1) {
    *(_DWORD *)(v15 + 84) = v94;
  }
LABEL_110:
  v75.ikey = 4475207;
  uint32_t v76 = AAHeaderGetKeyIndex(header, v75);
  if ((v76 & 0x80000000) != 0) {
    goto LABEL_117;
  }
  unsigned int v77 = AAHeaderGetFieldUInt(header, v76, &v94);
  if (v77 <= 1) {
    int v78 = 1;
  }
  else {
    int v78 = v77;
  }
  if (v78 < 0)
  {
    BOMCopierErrorCapture( a4,  v78,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c",  5778,  (uint64_t)"populate_source_entry_from_apple_archive",  "Could not get AppleArchive gid: %d");
    goto LABEL_149;
  }

  if (v77 <= 1) {
    *(_DWORD *)(v15 + 88) = v94;
  }
LABEL_117:
  uint64_t v92 = 0LL;
  uint64_t size = 0LL;
  v79.ikey = 5521732;
  uint32_t v80 = AAHeaderGetKeyIndex(header, v79);
  if ((v80 & 0x80000000) != 0) {
    goto LABEL_124;
  }
  unsigned int v81 = AAHeaderGetFieldBlob(header, v80, &size, &v92);
  if (v81 <= 1) {
    int v82 = 1;
  }
  else {
    int v82 = v81;
  }
  if (v82 < 0)
  {
    BOMCopierErrorCapture( a4,  v82,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c",  5792,  (uint64_t)"populate_source_entry_from_apple_archive",  "Could not get AppleArchive data size: %d");
    goto LABEL_149;
  }

  if (v81 <= 1) {
    *(void *)(v15 + 96) = size;
  }
LABEL_124:
  v83.ikey = 5917011;
  uint32_t v84 = AAHeaderGetKeyIndex(header, v83);
  if ((v84 & 0x80000000) != 0) {
    goto LABEL_131;
  }
  unsigned int v85 = AAHeaderGetFieldUInt(header, v84, &v94);
  if (v85 <= 1) {
    int v86 = 1;
  }
  else {
    int v86 = v85;
  }
  if (v86 < 0)
  {
    BOMCopierErrorCapture( a4,  v86,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c",  5804,  (uint64_t)"populate_source_entry_from_apple_archive",  "Could not get AppleArchive size: %d");
    goto LABEL_149;
  }

  if (v85 <= 1) {
    *(void *)(v15 + 96) = v94;
  }
LABEL_131:
  v87.ikey = 5067853;
  uint32_t v88 = AAHeaderGetKeyIndex(header, v87);
  if ((v88 & 0x80000000) != 0) {
    goto LABEL_138;
  }
  unsigned int FieldTimespec = AAHeaderGetFieldTimespec(header, v88, (timespec *)offset);
  if (FieldTimespec <= 1) {
    int v90 = 1;
  }
  else {
    int v90 = FieldTimespec;
  }
  if (v90 < 0)
  {
    BOMCopierErrorCapture( a4,  v90,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c",  5817,  (uint64_t)"populate_source_entry_from_apple_archive",  "Could not get AppleArchive modification timespec: %d");
    goto LABEL_149;
  }

  if (FieldTimespec <= 1) {
    *(_OWORD *)(v15 + 120) = *(_OWORD *)offset;
  }
LABEL_138:
  *(void *)(v15 + 104) = 0LL;
  *(void *)(v15 + 112) = 0LL;
  *(void *)(v15 + 136) = 0LL;
  *(void *)(v15 + 144) = 0LL;
  if ((a3 & 2) != 0) {
    char v91 = v13;
  }
  else {
    char v91 = 1;
  }
  if ((v91 & 1) == 0 && parse_regular_file(v15, a4))
  {
    BOMCopierErrorCapture( a4,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c",  1722,  (uint64_t)"BOMCopierSourceEntryNewFromAppleArchive",  "Could not parse the regular file");
LABEL_150:
    BOMCopierSourceEntryFree((unsigned int *)v15);
    return 0LL;
  }

  return v15;
}

uint64_t BOMCopierSourceEntryGetActualPath(uint64_t a1)
{
  if (a1) {
    return *(void *)(a1 + 16);
  }
  fwrite("Invalid source_entry", 0x14uLL, 1uLL, (FILE *)*MEMORY[0x1895F89D0]);
  return 0LL;
}

uint64_t BOMCopierSourceEntryGetType(uint64_t a1)
{
  if (a1) {
    return *(unsigned int *)(a1 + 4);
  }
  fwrite("Invalid source_entry", 0x14uLL, 1uLL, (FILE *)*MEMORY[0x1895F89D0]);
  return 0LL;
}

uint64_t BOMCopierSourceEntryGetPath(uint64_t a1)
{
  if (a1)
  {
    uint64_t result = *(void *)(a1 + 24);
    if (!result) {
      return *(void *)(a1 + 16);
    }
  }

  else
  {
    fwrite("Invalid source_entry", 0x14uLL, 1uLL, (FILE *)*MEMORY[0x1895F89D0]);
    return 0LL;
  }

  return result;
}

char *BOMCopierSourceEntryGetParent(void *a1)
{
  if (!a1)
  {
    size_t v4 = (FILE *)*MEMORY[0x1895F89D0];
    size_t v5 = "Invalid source_entry";
    size_t v6 = 20LL;
LABEL_10:
    fwrite(v5, v6, 1uLL, v4);
    return 0LL;
  }

  int v2 = (char *)a1[4];
  if (v2) {
    return v2;
  }
  unsigned int v3 = (const char *)a1[3];
  if (!v3)
  {
    unsigned int v3 = (const char *)a1[2];
    if (!v3)
    {
      size_t v4 = (FILE *)*MEMORY[0x1895F89D0];
      size_t v5 = "Missing entry_path";
      size_t v6 = 18LL;
      goto LABEL_10;
    }
  }

  if (!strcmp(v3, "."))
  {
    int v2 = strdup(".");
    goto LABEL_14;
  }

  int v2 = (char *)calloc(1uLL, 0x400uLL);
  if (v2)
  {
    if (v2 != dirname_r(v3, v2))
    {
      free(v2);
      return 0LL;
    }

char *BOMCopierSourceEntryGetName(void *a1)
{
  if (!a1)
  {
    size_t v4 = (FILE *)*MEMORY[0x1895F89D0];
    size_t v5 = "Invalid source_entry";
    size_t v6 = 20LL;
LABEL_10:
    fwrite(v5, v6, 1uLL, v4);
    return 0LL;
  }

  int v2 = (char *)a1[5];
  if (v2) {
    return v2;
  }
  unsigned int v3 = (const char *)a1[3];
  if (!v3)
  {
    unsigned int v3 = (const char *)a1[2];
    if (!v3)
    {
      size_t v4 = (FILE *)*MEMORY[0x1895F89D0];
      size_t v5 = "Missing entry_path";
      size_t v6 = 18LL;
      goto LABEL_10;
    }
  }

  if (!strcmp(v3, "."))
  {
    int v2 = strdup(".");
    goto LABEL_14;
  }

  int v2 = (char *)calloc(1uLL, 0x400uLL);
  if (v2)
  {
    if (v2 != basename_r(v3, v2))
    {
      free(v2);
      return 0LL;
    }

uint64_t BOMCopierSourceEntryGetDevice(uint64_t a1)
{
  if (a1) {
    return *(unsigned int *)(a1 + 64);
  }
  BOMCopierErrorCapture( 0LL,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c",  2026,  (uint64_t)"BOMCopierSourceEntryGetDevice",  "Invalid source_entry");
  return 0xFFFFFFFFLL;
}

uint64_t BOMCopierSourceEntryGetInode(uint64_t a1)
{
  if (a1) {
    return *(void *)(a1 + 72);
  }
  BOMCopierErrorCapture( 0LL,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c",  2040,  (uint64_t)"BOMCopierSourceEntryGetInode",  "Invalid source_entry");
  return -1LL;
}

uint64_t BOMCopierSourceEntryGetHardlinkCount(uint64_t a1)
{
  if (a1) {
    return *(unsigned __int16 *)(a1 + 80);
  }
  BOMCopierErrorCapture( 0LL,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c",  2054,  (uint64_t)"BOMCopierSourceEntryGetHardlinkCount",  "Invalid source_entry");
  return 0xFFFFLL;
}

uint64_t BOMCopierSourceEntryGetSize(uint64_t a1)
{
  if (a1)
  {
    if (*(_DWORD *)a1) {
      return *(void *)(a1 + 96);
    }
    else {
      return *(void *)(a1 + 248);
    }
  }

  else
  {
    fwrite("Invalid source_entry", 0x14uLL, 1uLL, (FILE *)*MEMORY[0x1895F89D0]);
    return 0LL;
  }

uint64_t BOMCopierSourceEntryGetMode(uint64_t a1)
{
  if (a1) {
    return *(unsigned __int16 *)(a1 + 92);
  }
  fwrite("Invalid source_entry", 0x14uLL, 1uLL, (FILE *)*MEMORY[0x1895F89D0]);
  return 0LL;
}

uint64_t BOMCopierSourceEntryGetUserID(uint64_t a1)
{
  if (a1) {
    return *(unsigned int *)(a1 + 84);
  }
  fwrite("Invalid source_entry", 0x14uLL, 1uLL, (FILE *)*MEMORY[0x1895F89D0]);
  return 0xFFFFFFFFLL;
}

uint64_t BOMCopierSourceEntryGetGroupID(uint64_t a1)
{
  if (a1) {
    return *(unsigned int *)(a1 + 88);
  }
  fwrite("Invalid source_entry", 0x14uLL, 1uLL, (FILE *)*MEMORY[0x1895F89D0]);
  return 0xFFFFFFFFLL;
}

uint64_t BOMCopierSourceEntryGetFlags(uint64_t a1)
{
  if (a1) {
    return *(unsigned int *)(a1 + 152);
  }
  fwrite("Invalid source_entry", 0x14uLL, 1uLL, (FILE *)*MEMORY[0x1895F89D0]);
  return 0xFFFFFFFFLL;
}

uint64_t BOMCopierSourceEntryGetAccessTime(uint64_t a1, _OWORD *a2)
{
  if (a1)
  {
    if (a2)
    {
      uint64_t v2 = 0LL;
      *a2 = *(_OWORD *)(a1 + 104);
    }

    else
    {
      uint64_t v2 = 1LL;
      fwrite("Invalid access_time", 0x13uLL, 1uLL, (FILE *)*MEMORY[0x1895F89D0]);
    }
  }

  else
  {
    uint64_t v2 = 1LL;
    fwrite("Invalid source_entry", 0x14uLL, 1uLL, (FILE *)*MEMORY[0x1895F89D0]);
  }

  return v2;
}

uint64_t BOMCopierSourceEntryGetModificationTime(uint64_t a1, _OWORD *a2)
{
  if (a1)
  {
    if (a2)
    {
      uint64_t v2 = 0LL;
      *a2 = *(_OWORD *)(a1 + 120);
    }

    else
    {
      uint64_t v2 = 1LL;
      fwrite("Invalid modification_time", 0x19uLL, 1uLL, (FILE *)*MEMORY[0x1895F89D0]);
    }
  }

  else
  {
    uint64_t v2 = 1LL;
    fwrite("Invalid source_entry", 0x14uLL, 1uLL, (FILE *)*MEMORY[0x1895F89D0]);
  }

  return v2;
}

uint64_t BOMCopierSourceEntryGetStatusTime(uint64_t a1, _OWORD *a2)
{
  if (a1)
  {
    if (a2)
    {
      uint64_t v2 = 0LL;
      *a2 = *(_OWORD *)(a1 + 136);
    }

    else
    {
      uint64_t v2 = 1LL;
      fwrite("Invalid status_time", 0x13uLL, 1uLL, (FILE *)*MEMORY[0x1895F89D0]);
    }
  }

  else
  {
    uint64_t v2 = 1LL;
    fwrite("Invalid source_entry", 0x14uLL, 1uLL, (FILE *)*MEMORY[0x1895F89D0]);
  }

  return v2;
}

uint64_t BOMCopierSourceEntryGetSymlinkTarget(uint64_t a1)
{
  if (a1) {
    return *(void *)(a1 + 48);
  }
  fwrite("Invalid source_entry", 0x14uLL, 1uLL, (FILE *)*MEMORY[0x1895F89D0]);
  return 0LL;
}

uint64_t BOMCopierSourceEntryGetAppleDoubleTarget(uint64_t a1)
{
  if (a1) {
    return *(void *)(a1 + 56);
  }
  fwrite("Invalid source_entry", 0x14uLL, 1uLL, (FILE *)*MEMORY[0x1895F89D0]);
  return 0LL;
}

BOOL BOMCopierSourceEntryIsCompressed(BOOL result)
{
  if (result)
  {
    int v1 = *(_DWORD *)(result + 152);
    return (v1 & 0x20) != 0 && (v1 & 0x40000000) == 0;
  }

  return result;
}

uint64_t BOMCopierSourceEntryIsRestricted(uint64_t result)
{
  if (result) {
    return (*(unsigned __int8 *)(result + 154) >> 3) & 1;
  }
  return result;
}

uint64_t BOMCopierSourceEntryGetBinaryType(uint64_t a1)
{
  if (a1) {
    return *(unsigned int *)(a1 + 192);
  }
  fwrite("Invalid source_entry", 0x14uLL, 1uLL, (FILE *)*MEMORY[0x1895F89D0]);
  return 0LL;
}

uint64_t BOMCopierSourceEntryGetArchCount(uint64_t a1)
{
  if (a1) {
    return *(unsigned int *)(a1 + 196);
  }
  fwrite("Invalid source_entry", 0x14uLL, 1uLL, (FILE *)*MEMORY[0x1895F89D0]);
  return 0LL;
}

uint64_t BOMCopierSourceEntryGetArchRecord(uint64_t a1, unsigned int a2, _OWORD *a3, void *a4)
{
  if (a1)
  {
    if (*(_DWORD *)(a1 + 196) <= a2)
    {
      BOMCopierErrorCapture( a4,  34,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c",  2344,  (uint64_t)"BOMCopierSourceEntryGetArchRecord",  "index is out of range");
    }

    else
    {
      if (a3)
      {
        uint64_t result = 0LL;
        size_t v6 = (_OWORD *)(*(void *)(a1 + 200) + 32LL * a2);
        __int128 v7 = v6[1];
        *a3 = *v6;
        a3[1] = v7;
        return result;
      }

      BOMCopierErrorCapture( a4,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c",  2350,  (uint64_t)"BOMCopierSourceEntryGetArchRecord",  "Invalid arch_record");
    }
  }

  else
  {
    BOMCopierErrorCapture( a4,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c",  2338,  (uint64_t)"BOMCopierSourceEntryGetArchRecord",  "Invalid source_entry");
  }

  return 1LL;
}

uint64_t BOMCopierSourceEntryGetExtendedAttributeCount(uint64_t a1, void *a2)
{
  if (a1) {
    return *(unsigned int *)(a1 + 208);
  }
  BOMCopierErrorCapture( a2,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c",  2370,  (uint64_t)"BOMCopierSourceEntryGetExtendedAttributeCount",  "source_entry is NULL");
  return 0LL;
}

uint64_t BOMCopierSourceEntryGetExtendedAttributeName(uint64_t a1, unsigned int a2, void *a3)
{
  if (a1)
  {
    if (*(_DWORD *)(a1 + 208) > a2) {
      return *(void *)(*(void *)(a1 + 216) + 24LL * a2);
    }
    BOMCopierErrorCapture( a3,  34,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c",  2395,  (uint64_t)"BOMCopierSourceEntryGetExtendedAttributeName",  "index is out of range");
  }

  else
  {
    BOMCopierErrorCapture( a3,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c",  2389,  (uint64_t)"BOMCopierSourceEntryGetExtendedAttributeName",  "source_entry is NULL");
  }

  return 0LL;
}

uint64_t BOMCopierSourceEntryGetExtendedAttributeSize(uint64_t a1, unsigned int a2, void *a3)
{
  if (a1)
  {
    if (*(_DWORD *)(a1 + 208) > a2) {
      return *(void *)(*(void *)(a1 + 216) + 24LL * a2 + 8);
    }
    BOMCopierErrorCapture( a3,  34,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c",  2420,  (uint64_t)"BOMCopierSourceEntryGetExtendedAttributeSize",  "index is out of range");
  }

  else
  {
    BOMCopierErrorCapture( a3,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c",  2414,  (uint64_t)"BOMCopierSourceEntryGetExtendedAttributeSize",  "source_entry is NULL");
  }

  return 0LL;
}

ssize_t BOMCopierSourceEntryCopyExtendedAttribute( uint64_t a1, unsigned int a2, void *__dst, size_t __n, u_int32_t a5, void *a6)
{
  if (!a1)
  {
    BOMCopierErrorCapture( a6,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c",  2442,  (uint64_t)"BOMCopierSourceEntryCopyExtendedAttribute",  "source_entry is NULL");
    return -1LL;
  }

  if (*(_DWORD *)(a1 + 208) <= a2)
  {
    BOMCopierErrorCapture( a6,  34,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c",  2448,  (uint64_t)"BOMCopierSourceEntryCopyExtendedAttribute",  "index is out of range");
    return -1LL;
  }

  if (!__dst)
  {
    BOMCopierErrorCapture( a6,  34,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c",  2454,  (uint64_t)"BOMCopierSourceEntryCopyExtendedAttribute",  "value is NULL");
    return -1LL;
  }

  size_t v8 = __n;
  if (!__n)
  {
    BOMCopierErrorCapture( a6,  34,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c",  2460,  (uint64_t)"BOMCopierSourceEntryCopyExtendedAttribute",  "size is 0");
    return -1LL;
  }

  uint64_t v10 = *(void *)(a1 + 216);
  uint64_t v11 = v10 + 24LL * a2;
  if (__n + a5 > *(void *)(v11 + 8))
  {
    BOMCopierErrorCapture( a6,  34,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c",  2473,  (uint64_t)"BOMCopierSourceEntryCopyExtendedAttribute",  "size + position are out of range");
    return -1LL;
  }

  uint64_t v13 = *(void *)(v10 + 24LL * a2 + 16);
  if (v13)
  {
    memcpy(__dst, (const void *)(v13 + a5), __n);
    return v8;
  }

  int v14 = *(const char **)v11;
  int v15 = string_compare(*(const char **)v11, "com.apple.decmpfs");
  else {
    BOOL v16 = 1;
  }
  if (v16) {
    int v17 = 33;
  }
  else {
    int v17 = 1;
  }
  return getxattr(*(const char **)(a1 + 16), v14, __dst, v8, a5, v17);
}

uint64_t string_compare(const char *a1, const char *a2)
{
  size_t v4 = strlen(a1);
  size_t v5 = strlen(a2);
  if (v5 <= v4) {
    size_t v6 = v4;
  }
  else {
    size_t v6 = v5;
  }
  return strncmp(a1, a2, v6);
}

uint64_t BOMCopierSourceEntryGetACL(uint64_t a1, void *a2, void *a3)
{
  if (a1)
  {
    if (a2)
    {
      uint64_t v4 = a1 + 224;
      uint64_t result = *(void *)(a1 + 224);
      *a2 = *(void *)(v4 + 8);
      return result;
    }

    BOMCopierErrorCapture( a3,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c",  2516,  (uint64_t)"BOMCopierSourceEntryGetACL",  "acl_text_size is NULL");
  }

  else
  {
    BOMCopierErrorCapture( a3,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c",  2510,  (uint64_t)"BOMCopierSourceEntryGetACL",  "source_entry is NULL");
  }

  return 0LL;
}

uint64_t BOMCopierSourceEntryGetQuarantine(uint64_t a1, void *a2)
{
  if (!a1) {
    BOMCopierErrorCapture( a2,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c",  2536,  (uint64_t)"BOMCopierSourceEntryGetQuarantine",  "source_entry is NULL");
  }
  return 0LL;
}

uint64_t BOMCopierSourceEntryCheckAccess(uint64_t a1, void *a2)
{
  if (!a1)
  {
    BOMCopierErrorCapture( a2,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c",  2555,  (uint64_t)"BOMCopierSourceEntryCheckAccess",  "Invalid source_entry");
    return 0xFFFFFFFFLL;
  }

  int v3 = *(_DWORD *)(a1 + 4);
  if (v3 == 6) {
    int v4 = 5;
  }
  else {
    int v4 = 4;
  }
  if (v3 == 9) {
    int v5 = 48;
  }
  else {
    int v5 = 16;
  }
  uint64_t result = faccessat(-2, *(const char **)(a1 + 16), v4, v5);
  if ((_DWORD)result)
  {
    int v7 = *__error();
    size_t v8 = __error();
    strerror(*v8);
    BOMCopierErrorCapture( a2,  v7,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c",  2595,  (uint64_t)"BOMCopierSourceEntryCheckAccess",  "Could not faccess %s: %s");
    return 0xFFFFFFFFLL;
  }

  return result;
}

size_t BOMCopierSourceEntryRead(uint64_t a1, char *__dst, size_t a3, void *a4)
{
  if (!a1)
  {
    BOMCopierErrorCapture( a4,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c",  2613,  (uint64_t)"BOMCopierSourceEntryRead",  "Invalid source_entry");
    return -1LL;
  }

  int v5 = __dst;
  if (!__dst)
  {
    BOMCopierErrorCapture( a4,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c",  2619,  (uint64_t)"BOMCopierSourceEntryRead",  "Invalid buffer");
    return -1LL;
  }

  size_t v6 = a3;
  if (!a3)
  {
    BOMCopierErrorCapture( a4,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c",  2625,  (uint64_t)"BOMCopierSourceEntryRead",  "Invalid num_bytes");
    return -1LL;
  }

  AAFieldKey v9 = (void *)(a1 + 168);
  uint64_t v8 = *(void *)(a1 + 168);
  if (!v8)
  {
    size_t v12 = 0LL;
    goto LABEL_16;
  }

  uint64_t v11 = *(void *)(a1 + 176);
  uint64_t v10 = *(void *)(a1 + 184);
  if (v11 - v10 >= a3) {
    size_t v12 = a3;
  }
  else {
    size_t v12 = v11 - v10;
  }
  memcpy(__dst, (const void *)(v8 + v10), v12);
  v5 += v12;
  v6 -= v12;
  uint64_t v13 = *(void *)(a1 + 176);
  size_t v14 = *(void *)(a1 + 184) + v12;
  *(void *)(a1 + 184) = v14;
  if (v14 == v13)
  {
    *(void *)(a1 + 160) = 0LL;
    free(*(void **)(a1 + 168));
    *AAFieldKey v9 = 0LL;
    v9[1] = 0LL;
    _DWORD v9[2] = 0LL;
  }

  if (v6)
  {
LABEL_16:
    int v15 = open_origin(a1, a4);
    if (v15)
    {
      BOMCopierErrorCapture( a4,  v15,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c",  2672,  (uint64_t)"BOMCopierSourceEntryRead",  "Could not open the underlying origin");
    }

    else
    {
      uint64_t v21 = read_from_origin(a1, v5, v6, a4, v16, v17, v18, v19);
      if (v21 != -1)
      {
        if (v21 >= 1) {
          *(void *)(a1 + 328) += v21;
        }
        v12 += v21;
        return v12;
      }

      BOMCopierErrorCapture( a4,  -1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c",  2684,  (uint64_t)"BOMCopierSourceEntryRead",  "Could not read from the underlying origin");
    }

    return -1LL;
  }

  return v12;
}

uint64_t open_origin(uint64_t a1, void *a2)
{
  int v5 = *(const char **)(a1 + 16);
  if (!v5)
  {
    BOMCopierErrorCapture( a2,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c",  4757,  (uint64_t)"open_origin",  "source entry has no actual path");
    return 0xFFFFFFFFLL;
  }

  int v6 = open(*(const char **)(a1 + 16), 0);
  if (v6 == -1)
  {
    int v11 = *__error();
    size_t v12 = __error();
    strerror(*v12);
    BOMCopierErrorCapture( a2,  v11,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c",  4764,  (uint64_t)"open_origin",  "Could not open %s: %s");
    return 0xFFFFFFFFLL;
  }

  int v7 = v6;
  if (*(_BYTE *)(a1 + 321) && fcntl(v6, 48, 1LL))
  {
    int v8 = *__error();
    AAFieldKey v9 = __error();
    uint64_t v10 = strerror(*v9);
    BOMCopierErrorCapture( a2,  v8,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c",  4773,  (uint64_t)"open_origin",  "Could not F_NOCACHE %s: %s",  v5,  v10);
    return 1LL;
  }

  else
  {
    uint64_t result = 0LL;
    *(_DWORD *)(a1 + 324) = v7;
  }

  return result;
}

uint64_t read_from_origin( uint64_t a1, void *a2, size_t a3, void *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  switch(*(_DWORD *)a1)
  {
    case 0:
      uint64_t v14 = *(void *)(a1 + 240);
      if (!v14) {
        return 0LL;
      }
      unint64_t v15 = *(void *)(a1 + 248);
      unint64_t v16 = *(void *)(a1 + 328);
      BOOL v17 = v15 > v16;
      size_t v18 = v15 - v16;
      if (!v17) {
        return 0LL;
      }
      if (v18 >= a3) {
        size_t v11 = a3;
      }
      else {
        size_t v11 = v18;
      }
      memcpy(a2, (const void *)(v14 + v16), v11);
      return v11;
    case 1:
    case 2:
    case 3:
    case 4:
      size_t v11 = read(*(_DWORD *)(a1 + 324), a2, a3);
      if (v11 != -1LL) {
        return v11;
      }
      int v12 = *__error();
      uint64_t v13 = __error();
      strerror(*v13);
      BOMCopierErrorCapture( a4,  v12,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c",  4847,  (uint64_t)"read_from_origin",  "Could not read %ld bytes from file descriptor: %s");
      return -1LL;
    case 5:
      return archive_read_data();
    case 6:
      __int16 v23 = 0LL;
      size_t v11 = data_archive_read_data(*(void *)(a1 + 272), a2, a3, &v23, a5, a6, a7, a8);
      if (v11 == -1LL)
      {
        uint32_t v20 = __error();
        BOMCopierErrorCapture( a4,  *v20,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c",  4864,  (uint64_t)"read_from_origin",  "Could not read %ld bytes from data_archive: %s",  a3,  *((const char **)v23 + 4));
        release_error(v23);
      }

      return v11;
    case 7:
      AAFieldKey v21 = *(AAFieldKey *)(a1 + 304);
      int Blob = AAArchiveStreamReadBlob(*(AAArchiveStream *)(a1 + 288), v21, a2, a3);
      if (!Blob) {
        return a3;
      }
      BOMCopierErrorCapture( a4,  Blob,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c",  4876,  (uint64_t)"read_from_origin",  "Could not read %lu bytes from data_archive: %u");
      return -1LL;
    default:
      return -1LL;
  }

uint64_t BOMCopierSourceEntrySeek(uint64_t a1, unint64_t a2, void *a3, unint64_t a4, void *a5)
{
  if (a1)
  {
    if ((a2 & 0x8000000000000000LL) == 0)
    {
      size_t v11 = (void *)(a1 + 168);
      uint64_t v10 = *(void **)(a1 + 168);
      if (v10)
      {
        uint64_t v12 = *(void *)(a1 + 176);
        uint64_t v13 = *(void *)(a1 + 184);
        if (v12 - v13 >= a2) {
          unint64_t v14 = a2;
        }
        else {
          unint64_t v14 = v12 - v13;
        }
        uint64_t v15 = v14 + v13;
        *(void *)(a1 + 184) = v15;
        if (v15 == v12)
        {
          *(void *)(a1 + 160) = 0LL;
          free(v10);
          *size_t v11 = 0LL;
          v11[1] = 0LL;
          v11[2] = 0LL;
        }
      }

      else
      {
        unint64_t v14 = 0LL;
      }

      off_t v17 = a2 - v14;
      if (!v17) {
        return 0LL;
      }
      uint64_t v18 = open_origin(a1, a5);
      if ((_DWORD)v18)
      {
        uint64_t v16 = v18;
        BOMCopierErrorCapture( a5,  v18,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c",  2764,  (uint64_t)"BOMCopierSourceEntrySeek",  "Could not open the origin");
        return v16;
      }

      off_t v23 = *(void *)(a1 + 328);
      unint64_t v24 = v23 + v17;
      int v25 = *(_DWORD *)a1;
      if ((*(_DWORD *)a1 - 1) < 4)
      {
        off_t v23 = lseek(*(_DWORD *)(a1 + 324), v17, 1);
        if (v23 != -1)
        {
LABEL_29:
          *(void *)(a1 + 328) = v23;
          goto LABEL_39;
        }

        int v28 = *__error();
        int v29 = __error();
        strerror(*v29);
        BOMCopierErrorCapture( a5,  v28,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c",  4969,  (uint64_t)"seek_from_origin",  "Could not lseek: %s");
      }

      else if ((v25 - 5) >= 3)
      {
        if (v25 || !*(void *)(a1 + 240))
        {
LABEL_39:
          if (v24 != v23)
          {
            uint64_t v16 = 1LL;
            BOMCopierErrorCapture( a5,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c",  2776,  (uint64_t)"BOMCopierSourceEntrySeek",  "Could not seek forward in the origin");
            return v16;
          }

          goto LABEL_40;
        }

        if (v24 <= *(void *)(a1 + 248))
        {
LABEL_40:
          uint64_t v16 = 0LL;
          *(void *)(a1 + 328) = v24;
          return v16;
        }

        BOMCopierErrorCapture( a5,  34,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c",  4938,  (uint64_t)"seek_from_origin",  "Cannot seek beyond the end of entry data");
      }

      else
      {
        if (*(_DWORD *)(a1 + 4) != 8) {
          goto LABEL_39;
        }
        if (a3)
        {
          if (a4)
          {
            uint64_t v26 = 0LL;
            while (1)
            {
              size_t v27 = v17 - v26 >= a4 ? a4 : v17 - v26;
              if (read_from_origin(a1, a3, v27, a5, v19, v20, v21, v22) != v27) {
                break;
              }
              v26 += v27;
              if (v26 == v17)
              {
                off_t v23 = *(void *)(a1 + 328) + v17;
                goto LABEL_29;
              }
            }

            int v30 = *__error();
            BOMCopierErrorCapture( a5,  v30,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c",  5063,  (uint64_t)"seek_from_origin",  "Could not read %lld bytes from archive for seeking");
          }

          else
          {
            BOMCopierErrorCapture( a5,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c",  5041,  (uint64_t)"seek_from_origin",  "seek_buffer_size is 0");
          }
        }

        else
        {
          BOMCopierErrorCapture( a5,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c",  5035,  (uint64_t)"seek_from_origin",  "seek_buffer is NULL");
        }
      }

      off_t v23 = -1LL;
      goto LABEL_39;
    }

    uint64_t v16 = 22LL;
    BOMCopierErrorCapture( a5,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c",  2719,  (uint64_t)"BOMCopierSourceEntrySeek",  "Invalid seek_amount");
  }

  else
  {
    uint64_t v16 = 22LL;
    BOMCopierErrorCapture( a5,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c",  2713,  (uint64_t)"BOMCopierSourceEntrySeek",  "source_entry is NULL");
  }

  return v16;
}

uint64_t BOMCopierSourceEntrySkip(uint64_t a1, void *a2, size_t a3, void *a4)
{
  if (!a1)
  {
    BOMCopierErrorCapture( a4,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c",  2796,  (uint64_t)"BOMCopierSourceEntrySkip",  "Invalid source_entry");
    return 1LL;
  }

  if (a3) {
    size_t v7 = a3;
  }
  else {
    size_t v7 = 0x4000000LL;
  }
  int v8 = a2;
  if (!a2)
  {
    int v8 = malloc(v7);
    if (!v8)
    {
      int v11 = *__error();
      uint64_t v12 = __error();
      strerror(*v12);
      BOMCopierErrorCapture( a4,  v11,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c",  2818,  (uint64_t)"BOMCopierSourceEntrySkip",  "Could not allocate %ld bytes for skip buffer: %s\n");
      return 1LL;
    }
  }

  if (*(_DWORD *)a1 != 7)
  {
    if (*(_DWORD *)a1 == 5 && skip_remaining_file_data(a1, v8, v7))
    {
      uint64_t v9 = 1LL;
      BOMCopierErrorCapture( a4,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c",  2834,  (uint64_t)"BOMCopierSourceEntrySkip",  "Could not skip remaining libarchive file data");
LABEL_11:
      if (v8 != a2) {
        free(v8);
      }
      return v9;
    }

    goto LABEL_29;
  }

  int v10 = skip_remaining_file_data(a1, v8, v7);
  if (v10)
  {
    BOMCopierErrorCapture( a4,  v10,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c",  2855,  (uint64_t)"BOMCopierSourceEntrySkip",  "Could not skip remaining AppleArchive file data");
    if (v8 != a2) {
      free(v8);
    }
    return 1LL;
  }

  if (*(_DWORD *)(a1 + 308))
  {
    uint64_t v13 = 0LL;
    unint64_t v14 = 0LL;
    while (1)
    {
      uint64_t v15 = *(void *)(a1 + 312) + v13;
      *(_DWORD *)(a1 + 304) = *(_DWORD *)v15;
      size_t v16 = *(void *)(v15 + 16);
      if (BOMCopierSourceEntryRead(a1, (char *)v8, v16, a4) != v16)
      {
        BOMCopierErrorCapture( a4,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c",  5866,  (uint64_t)"parse_apple_archive_blobs",  "Could not read AppleArchive blob data");
        goto LABEL_36;
      }

      if (*(_BYTE *)(*(void *)(a1 + 312) + v13 + 24))
      {
        int v17 = *(_DWORD *)(a1 + 304);
        if (v17 == 4997953)
        {
          if (parse_apple_archive_acl_blob(a1, (uint8_t *)v8, v16, a4))
          {
            BOMCopierErrorCapture( a4,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c",  5881,  (uint64_t)"parse_apple_archive_blobs",  "Could not parse AppleArchive ACL blob: %d");
            goto LABEL_36;
          }

          int v17 = *(_DWORD *)(a1 + 304);
        }
      }

      ++v14;
      v13 += 32LL;
    }

    BOMCopierErrorCapture( a4,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c",  5891,  (uint64_t)"parse_apple_archive_blobs",  "Could not read parse AppleArchive XAT blob: %d");
LABEL_36:
    uint64_t v9 = 1LL;
    BOMCopierErrorCapture( a4,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c",  2873,  (uint64_t)"BOMCopierSourceEntrySkip",  "Could not parse AppleArchive payload blobs");
    goto LABEL_11;
  }

LABEL_29:
  if (v8 != a2) {
    free(v8);
  }
  return 0LL;
}

        CC_SHA384_Update((CC_SHA512_CTX *)a1[10], data, len);
        if ((*a1 & 0x100) == 0) {
          return 0LL;
        }
        goto LABEL_23;
      }

      int v11 = 22LL;
      BOMCopierErrorCapture( a4,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDataAnalyzer.c",  249,  (uint64_t)"BOMCopierDataAnalyzerUpdate",  "data_size is 0");
    }

    else
    {
      int v11 = 22LL;
      BOMCopierErrorCapture( a4,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDataAnalyzer.c",  243,  (uint64_t)"BOMCopierDataAnalyzerUpdate",  "data is NULL");
    }
  }

  else
  {
    int v11 = 22LL;
    BOMCopierErrorCapture( a4,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDataAnalyzer.c",  237,  (uint64_t)"BOMCopierDataAnalyzerUpdate",  "data_analyzer is NULL");
  }

  return v11;
}

    CC_SHA384_Final((unsigned __int8 *)a1[16], (CC_SHA512_CTX *)a1[10]);
    if ((*a1 & 0x100) == 0) {
      return 0LL;
    }
    goto LABEL_22;
  }

  size_t v7 = 22LL;
  BOMCopierErrorCapture( a2,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDataAnalyzer.c",  267,  (uint64_t)"BOMCopierDataAnalyzerFinalize",  "data_analyzer is NULL");
  return v7;
}

uint64_t skip_remaining_file_data(uint64_t a1, void *a2, unint64_t a3)
{
  if (*(_DWORD *)(a1 + 4) != 8) {
    return 0LL;
  }
  uint64_t Size = BOMCopierSourceEntryGetSize(a1);
  uint64_t v7 = 1LL;
  fwrite("Could not seek to the end of the source entry\n", 0x2EuLL, 1uLL, (FILE *)*MEMORY[0x1895F89D0]);
  return v7;
}

uint64_t BOMCopierSourceEntryClone(uint64_t a1, char *__s1, _BYTE *a3, void *a4)
{
  if (a1)
  {
    if (__s1)
    {
      if (a3)
      {
        *a3 = 0;
        if ((*(_DWORD *)a1 | 2) == 3)
        {
          if (*(_DWORD *)(a1 + 4) == 8)
          {
            int v8 = strdup(__s1);
            if (v8)
            {
              uint64_t v9 = v8;
              if (!dirname_r(__s1, v8))
              {
                unint64_t v14 = __error();
                strerror(*v14);
                uint64_t v11 = 1LL;
                BOMCopierErrorCapture( a4,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c",  2971,  (uint64_t)"BOMCopierSourceEntryClone",  "Could not dirname %s: %s");
                goto LABEL_18;
              }

              if (stat(v9, &v19))
              {
                int v10 = __error();
                strerror(*v10);
                uint64_t v11 = 1LL;
                BOMCopierErrorCapture( a4,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c",  2981,  (uint64_t)"BOMCopierSourceEntryClone",  "Could not stat %s: %s");
LABEL_18:
                free(v9);
                return v11;
              }

              free(v9);
              if (*(_DWORD *)(a1 + 64) == v19.st_dev)
              {
                if (!copyfile(*(const char **)(a1 + 16), __s1, 0LL, 0x200000Fu))
                {
                  uint64_t v11 = 0LL;
                  *a3 = 1;
                  return v11;
                }

                if (*__error() != 45)
                {
                  int v15 = *__error();
                  size_t v16 = *(const char **)(a1 + 16);
                  int v17 = __error();
                  uint64_t v18 = strerror(*v17);
                  BOMCopierErrorCapture( a4,  v15,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c",  2998,  (uint64_t)"BOMCopierSourceEntryClone",  "Could not clone %s to %s: %s",  v16,  __s1,  v18);
                  return 1LL;
                }
              }

              return 0LL;
            }

            else
            {
              uint64_t v12 = __error();
              strerror(*v12);
              uint64_t v11 = 1LL;
              BOMCopierErrorCapture( a4,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c",  2964,  (uint64_t)"BOMCopierSourceEntryClone",  "Could not duplicate %s: %s");
            }
          }

          else
          {
            uint64_t v11 = 1LL;
            BOMCopierErrorCapture( a4,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c",  2957,  (uint64_t)"BOMCopierSourceEntryClone",  "Entry is not a regular file");
          }
        }

        else
        {
          uint64_t v11 = 1LL;
          BOMCopierErrorCapture( a4,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c",  2951,  (uint64_t)"BOMCopierSourceEntryClone",  "Origin %u does not support filesystem cloning");
        }
      }

      else
      {
        uint64_t v11 = 22LL;
        BOMCopierErrorCapture( a4,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c",  2923,  (uint64_t)"BOMCopierSourceEntryClone",  "Invalid cloned");
      }
    }

    else
    {
      uint64_t v11 = 22LL;
      BOMCopierErrorCapture( a4,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c",  2917,  (uint64_t)"BOMCopierSourceEntryClone",  "Invalid path");
    }
  }

  else
  {
    uint64_t v11 = 22LL;
    BOMCopierErrorCapture( a4,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c",  2911,  (uint64_t)"BOMCopierSourceEntryClone",  "Invalid source_entry");
  }

  return v11;
}

uint64_t BOMCopierSourceEntrySetRoot(uint64_t a1, char a2)
{
  if (a1)
  {
    uint64_t v2 = 0LL;
    *(_BYTE *)(a1 + 157) = a2;
  }

  else
  {
    uint64_t v2 = 1LL;
    fwrite("Invalid source_entry", 0x14uLL, 1uLL, (FILE *)*MEMORY[0x1895F89D0]);
  }

  return v2;
}

BOOL BOMCopierSourceEntryIsRoot(uint64_t a1)
{
  if (a1) {
    return *(_BYTE *)(a1 + 157) != 0;
  }
  fwrite("Invalid source_entry", 0x14uLL, 1uLL, (FILE *)*MEMORY[0x1895F89D0]);
  return 0LL;
}

BOOL BOMCopierSourceEntryIsResourceFork(_DWORD *a1)
{
  if (a1) {
    return *a1 == 2;
  }
  fwrite("Invalid source_entry", 0x14uLL, 1uLL, (FILE *)*MEMORY[0x1895F89D0]);
  return 0LL;
}

BOOL BOMCopierSourceEntrySetPath(void *a1, char *__s)
{
  if (a1)
  {
    if (!__s)
    {
      int v5 = (FILE *)*MEMORY[0x1895F89D0];
      int v6 = "Invalid entry_path";
      uint64_t v7 = 1LL;
      size_t v8 = 18LL;
      goto LABEL_7;
    }

    size_t v4 = strlen(__s);
    if (v4 >= 0x400)
    {
      int v5 = (FILE *)*MEMORY[0x1895F89D0];
      int v6 = "entry_path is too long";
      uint64_t v7 = 1LL;
      size_t v8 = 22LL;
LABEL_7:
      fwrite(v6, v8, 1uLL, v5);
      return v7;
    }

    size_t v9 = v4;
    int v10 = (void *)a1[3];
    if (v10)
    {
      free(v10);
      a1[3] = 0LL;
    }

    uint64_t v11 = (void *)a1[4];
    if (v11)
    {
      free(v11);
      a1[4] = 0LL;
    }

    uint64_t v12 = (void *)a1[5];
    if (v12)
    {
      free(v12);
      a1[5] = 0LL;
    }

    uint64_t v13 = copy_string(__s, v9);
    a1[3] = v13;
    return v13 == 0LL;
  }

  else
  {
    uint64_t v7 = 1LL;
    fwrite("Invalid source_entry", 0x14uLL, 1uLL, (FILE *)*MEMORY[0x1895F89D0]);
  }

  return v7;
}

BOOL BOMCopierSourceEntrySetParent(uint64_t a1, char *__s)
{
  if (a1)
  {
    if (!__s)
    {
      int v5 = (FILE *)*MEMORY[0x1895F89D0];
      int v6 = "Invalid entry_parent";
      uint64_t v7 = 1LL;
      size_t v8 = 20LL;
      goto LABEL_7;
    }

    size_t v4 = strlen(__s);
    if (v4 >= 0x400)
    {
      int v5 = (FILE *)*MEMORY[0x1895F89D0];
      int v6 = "entry_path is too long";
      uint64_t v7 = 1LL;
      size_t v8 = 22LL;
LABEL_7:
      fwrite(v6, v8, 1uLL, v5);
      return v7;
    }

    if (!*(void *)(a1 + 32)) {
      *(void *)(a1 + 32) = 0LL;
    }
    size_t v9 = copy_string(__s, v4);
    *(void *)(a1 + 32) = v9;
    return v9 == 0LL;
  }

  else
  {
    uint64_t v7 = 1LL;
    fwrite("Invalid source_entry", 0x14uLL, 1uLL, (FILE *)*MEMORY[0x1895F89D0]);
  }

  return v7;
}

BOOL BOMCopierSourceEntrySetName(uint64_t a1, char *__s)
{
  if (a1)
  {
    if (!__s)
    {
      int v5 = (FILE *)*MEMORY[0x1895F89D0];
      int v6 = "Invalid entry_name";
      uint64_t v7 = 1LL;
      size_t v8 = 18LL;
      goto LABEL_7;
    }

    size_t v4 = strlen(__s);
    if (v4 >= 0xFF)
    {
      int v5 = (FILE *)*MEMORY[0x1895F89D0];
      int v6 = "entry_name is too long";
      uint64_t v7 = 1LL;
      size_t v8 = 22LL;
LABEL_7:
      fwrite(v6, v8, 1uLL, v5);
      return v7;
    }

    if (!*(void *)(a1 + 40)) {
      *(void *)(a1 + 40) = 0LL;
    }
    size_t v9 = copy_string(__s, v4);
    *(void *)(a1 + 40) = v9;
    return v9 == 0LL;
  }

  else
  {
    uint64_t v7 = 1LL;
    fwrite("Invalid source_entry", 0x14uLL, 1uLL, (FILE *)*MEMORY[0x1895F89D0]);
  }

  return v7;
}

uint64_t BOMCopierSourceEntrySetData(uint64_t a1, const void *a2, size_t __size)
{
  if (!a1)
  {
    uint64_t v9 = 1LL;
    fwrite("Invalid source_entry", 0x14uLL, 1uLL, (FILE *)*MEMORY[0x1895F89D0]);
    return v9;
  }

  if (!a2)
  {
    int v10 = (FILE *)*MEMORY[0x1895F89D0];
    uint64_t v11 = "Invalid data";
    uint64_t v9 = 1LL;
    size_t v12 = 12LL;
LABEL_11:
    fwrite(v11, v12, 1uLL, v10);
    return v9;
  }

  if (!__size)
  {
    int v10 = (FILE *)*MEMORY[0x1895F89D0];
    uint64_t v11 = "Invalid data size";
    uint64_t v9 = 1LL;
    size_t v12 = 17LL;
    goto LABEL_11;
  }

  int v6 = *(void **)(a1 + 240);
  if (v6)
  {
    free(v6);
    *(void *)(a1 + 248) = 0LL;
  }

  uint64_t v7 = malloc(__size);
  if (!v7) {
    return 1LL;
  }
  size_t v8 = v7;
  memcpy(v7, a2, __size);
  uint64_t v9 = 0LL;
  *(void *)(a1 + 240) = v8;
  *(void *)(a1 + 248) = __size;
  return v9;
}

uint64_t BOMCopierSourceEntrySetMode(uint64_t a1, __int16 a2)
{
  if (a1)
  {
    uint64_t v2 = 0LL;
    *(_WORD *)(a1 + 92) = a2;
  }

  else
  {
    uint64_t v2 = 1LL;
    fwrite("Invalid source_entry", 0x14uLL, 1uLL, (FILE *)*MEMORY[0x1895F89D0]);
  }

  return v2;
}

uint64_t BOMCopierSourceEntrySetSize(uint64_t a1, uint64_t a2)
{
  if (a1)
  {
    uint64_t v2 = 0LL;
    *(void *)(a1 + 96) = a2;
  }

  else
  {
    uint64_t v2 = 1LL;
    fwrite("Invalid source_entry", 0x14uLL, 1uLL, (FILE *)*MEMORY[0x1895F89D0]);
  }

  return v2;
}

uint64_t BOMCopierSourceEntrySetUserID(uint64_t a1, int a2)
{
  if (a1)
  {
    uint64_t v2 = 0LL;
    *(_DWORD *)(a1 + 84) = a2;
  }

  else
  {
    uint64_t v2 = 1LL;
    fwrite("Invalid source_entry", 0x14uLL, 1uLL, (FILE *)*MEMORY[0x1895F89D0]);
  }

  return v2;
}

uint64_t BOMCopierSourceEntrySetGroupID(uint64_t a1, int a2)
{
  if (a1)
  {
    uint64_t v2 = 0LL;
    *(_DWORD *)(a1 + 88) = a2;
  }

  else
  {
    uint64_t v2 = 1LL;
    fwrite("Invalid source_entry", 0x14uLL, 1uLL, (FILE *)*MEMORY[0x1895F89D0]);
  }

  return v2;
}

uint64_t BOMCopierSourceEntrySetAccessTime(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a1)
  {
    uint64_t v3 = 0LL;
    *(void *)(a1 + 104) = a2;
    *(void *)(a1 + 112) = a3;
  }

  else
  {
    uint64_t v3 = 1LL;
    fwrite("Invalid source_entry", 0x14uLL, 1uLL, (FILE *)*MEMORY[0x1895F89D0]);
  }

  return v3;
}

uint64_t BOMCopierSourceEntrySetModificationTime(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a1)
  {
    uint64_t v3 = 0LL;
    *(void *)(a1 + 120) = a2;
    *(void *)(a1 + 128) = a3;
  }

  else
  {
    uint64_t v3 = 1LL;
    fwrite("Invalid source_entry", 0x14uLL, 1uLL, (FILE *)*MEMORY[0x1895F89D0]);
  }

  return v3;
}

uint64_t BOMCopierSourceEntrySetStatusTime(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a1)
  {
    uint64_t v3 = 0LL;
    *(void *)(a1 + 136) = a2;
    *(void *)(a1 + 144) = a3;
  }

  else
  {
    uint64_t v3 = 1LL;
    fwrite("Invalid source_entry", 0x14uLL, 1uLL, (FILE *)*MEMORY[0x1895F89D0]);
  }

  return v3;
}

BOOL BOMCopierSourceEntrySetSymlinkTarget(uint64_t a1, char *__s1)
{
  if (a1)
  {
    int v3 = *(_DWORD *)(a1 + 4);
    if (v3 == 18 || v3 == 9)
    {
      int v6 = *(void **)(a1 + 48);
      if (v6) {
        free(v6);
      }
      uint64_t v7 = strdup(__s1);
      *(void *)(a1 + 48) = v7;
      return v7 == 0LL;
    }

    else
    {
      return 1LL;
    }
  }

  else
  {
    uint64_t v8 = 1LL;
    fwrite("Invalid source_entry", 0x14uLL, 1uLL, (FILE *)*MEMORY[0x1895F89D0]);
  }

  return v8;
}

BOOL BOMCopierSourceEntrySetAppleDoubleTarget(uint64_t a1, char *__s1)
{
  if (a1)
  {
    if (*(_DWORD *)(a1 + 4) == 17)
    {
      size_t v4 = *(void **)(a1 + 56);
      if (v4) {
        free(v4);
      }
      int v5 = strdup(__s1);
      *(void *)(a1 + 56) = v5;
      return v5 == 0LL;
    }

    else
    {
      return 1LL;
    }
  }

  else
  {
    uint64_t v6 = 1LL;
    fwrite("Invalid source_entry", 0x14uLL, 1uLL, (FILE *)*MEMORY[0x1895F89D0]);
  }

  return v6;
}

uint64_t BOMCopierSourceEntrySetQuarantine()
{
  return 0LL;
}

uint64_t BOMCopierSourceEntrySetSegmentedFile(uint64_t a1, char a2)
{
  if (a1)
  {
    uint64_t v2 = 0LL;
    *(_BYTE *)(a1 + 158) = a2;
  }

  else
  {
    uint64_t v2 = 1LL;
    fwrite("Invalid source_entry", 0x14uLL, 1uLL, (FILE *)*MEMORY[0x1895F89D0]);
  }

  return v2;
}

uint64_t BOMCopierSourceEntrySetHonorsSetuid(uint64_t a1, char a2)
{
  *(_BYTE *)(a1 + 8) = a2;
  return 0LL;
}

BOOL BOMCopierSourceEntryIsSegmentedFile(uint64_t a1)
{
  if (a1) {
    return *(_BYTE *)(a1 + 158) != 0;
  }
  fwrite("Invalid source_entry", 0x14uLL, 1uLL, (FILE *)*MEMORY[0x1895F89D0]);
  return 0LL;
}

BOOL BOMCopierSourceEntryIsStreamed(uint64_t a1)
{
  if (a1) {
    return *(_BYTE *)(a1 + 156) != 0;
  }
  fwrite("Invalid source_entry", 0x14uLL, 1uLL, (FILE *)*MEMORY[0x1895F89D0]);
  return 0LL;
}

uint64_t BOMCopierSourceEntrySetOption(uint64_t a1, CFTypeRef cf1, const void *a3)
{
  if (!a1)
  {
    uint64_t v6 = 1LL;
    fwrite("Invalid source_entry", 0x14uLL, 1uLL, (FILE *)*MEMORY[0x1895F89D0]);
    return v6;
  }

  if (!cf1)
  {
    uint64_t v7 = (FILE *)*MEMORY[0x1895F89D0];
    uint64_t v8 = "Invalid key";
    uint64_t v6 = 1LL;
    size_t v9 = 11LL;
LABEL_9:
    fwrite(v8, v9, 1uLL, v7);
    return v6;
  }

  if (!a3)
  {
    uint64_t v7 = (FILE *)*MEMORY[0x1895F89D0];
    uint64_t v8 = "Invalid value";
    uint64_t v6 = 1LL;
    size_t v9 = 13LL;
    goto LABEL_9;
  }

  if (CFEqual(cf1, @"DeleteOnFree") != 1) {
    return 1LL;
  }
  int v5 = CFEqual(a3, (CFTypeRef)*MEMORY[0x189604DE8]);
  uint64_t v6 = 0LL;
  *(_BYTE *)(a1 + 320) = v5 != 0;
  return v6;
}

uint64_t BOMCopierSourceEntryCompare(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4)
{
  uint64_t v26 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    size_t v9 = (FILE *)*MEMORY[0x1895F89D0];
    int v10 = "Invalid source_entry";
    size_t v11 = 20LL;
LABEL_9:
    fwrite(v10, v11, 1uLL, v9);
    return 0LL;
  }

  if (!a2)
  {
    size_t v9 = (FILE *)*MEMORY[0x1895F89D0];
    int v10 = "Invalid other_entry";
    size_t v11 = 19LL;
    goto LABEL_9;
  }

  if (!a4)
  {
    size_t v9 = (FILE *)*MEMORY[0x1895F89D0];
    int v10 = "Invalid compare_handler";
    size_t v11 = 23LL;
    goto LABEL_9;
  }

  (*(void (**)(uint64_t, uint64_t, uint64_t, void, const char *))(a4 + 16))(a4, a1, a2, 0LL, "");
  if (*(_DWORD *)a1 == *(_DWORD *)a2)
  {
    uint64_t v8 = 1LL;
  }

  else
  {
    snprintf(__str, 0x400uLL, "entry_origin: %d vs %d", *(_DWORD *)a1, *(_DWORD *)a2);
    uint64_t v8 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, const char *, char *))(a4 + 16))( a4,  a1,  a2,  "entry_origin",  __str);
  }

  unsigned int v13 = *(_DWORD *)(a1 + 4);
  unsigned int v14 = *(_DWORD *)(a2 + 4);
  if (v13 != v14)
  {
    int v15 = BOMCopierSourceEntryTypeString(v13);
    size_t v16 = BOMCopierSourceEntryTypeString(v14);
    snprintf(__str, 0x400uLL, "entry_type: %s vs %s", v15, v16);
    uint64_t v8 = (*(unsigned int (**)(uint64_t, uint64_t, uint64_t, const char *, char *))(a4 + 16))( a4,  a1,  a2,  "entry_type",  __str) & v8;
  }

  if ((compare_strings((int)"entry_resolved_path", *(char **)(a1 + 16), *(char **)(a2 + 16), __str) & 1) == 0) {
    uint64_t v8 = (*(unsigned int (**)(uint64_t, uint64_t, uint64_t, const char *, char *))(a4 + 16))( a4,  a1,  a2,  "entry_resolved_path",  __str) & v8;
  }
  if ((compare_strings((int)"entry_path", *(char **)(a1 + 24), *(char **)(a2 + 24), __str) & 1) == 0) {
    uint64_t v8 = (*(unsigned int (**)(uint64_t, uint64_t, uint64_t, const char *, char *))(a4 + 16))( a4,  a1,  a2,  "entry_path",  __str) & v8;
  }
  BOMCopierSourceEntryGetParent((void *)a1);
  BOMCopierSourceEntryGetParent((void *)a2);
  if ((compare_strings((int)"entry_parent", *(char **)(a1 + 32), *(char **)(a2 + 32), __str) & 1) == 0) {
    uint64_t v8 = (*(unsigned int (**)(uint64_t, uint64_t, uint64_t, const char *, char *))(a4 + 16))( a4,  a1,  a2,  "entry_parent",  __str) & v8;
  }
  BOMCopierSourceEntryGetName((void *)a1);
  BOMCopierSourceEntryGetName((void *)a2);
  if ((compare_strings((int)"entry_name", *(char **)(a1 + 40), *(char **)(a2 + 40), __str) & 1) == 0) {
    uint64_t v8 = (*(unsigned int (**)(uint64_t, uint64_t, uint64_t, const char *, char *))(a4 + 16))( a4,  a1,  a2,  "entry_name",  __str) & v8;
  }
  if ((compare_strings((int)"entry_symlink_target", *(char **)(a1 + 48), *(char **)(a2 + 48), __str) & 1) == 0) {
    uint64_t v8 = (*(unsigned int (**)(uint64_t, uint64_t, uint64_t, const char *, char *))(a4 + 16))( a4,  a1,  a2,  "entry_symlink_target",  __str) & v8;
  }
  int v17 = *(_DWORD *)(a2 + 84);
  if (*(_DWORD *)(a1 + 84) != v17)
  {
    snprintf(__str, 0x400uLL, "entry_uid: %d vs %d", *(_DWORD *)(a1 + 84), v17);
    uint64_t v8 = (*(unsigned int (**)(uint64_t, uint64_t, uint64_t, const char *, char *))(a4 + 16))( a4,  a1,  a2,  "entry_uid",  __str) & v8;
  }

  int v18 = *(_DWORD *)(a2 + 88);
  if (*(_DWORD *)(a1 + 88) != v18)
  {
    snprintf(__str, 0x400uLL, "entry_gid: %d vs %d", *(_DWORD *)(a1 + 88), v18);
    uint64_t v8 = (*(unsigned int (**)(uint64_t, uint64_t, uint64_t, const char *, char *))(a4 + 16))( a4,  a1,  a2,  "entry_gid",  __str) & v8;
  }

  int v19 = *(unsigned __int16 *)(a1 + 92);
  if (v19 != *(unsigned __int16 *)(a2 + 92))
  {
    strmode(v19, __bp);
    strmode(*(unsigned __int16 *)(a2 + 92), v23);
    snprintf(__str, 0x400uLL, "entry_mode: %s vs %s", __bp, v23);
    uint64_t v8 = (*(unsigned int (**)(uint64_t, uint64_t, uint64_t, const char *, char *))(a4 + 16))( a4,  a1,  a2,  "entry_mode",  __str) & v8;
  }

  uint64_t v20 = *(void *)(a2 + 96);
  if (*(void *)(a1 + 96) != v20)
  {
    snprintf(__str, 0x400uLL, "entry_size: %lld vs %lld", *(void *)(a1 + 96), v20);
    uint64_t v8 = (*(unsigned int (**)(uint64_t, uint64_t, uint64_t, const char *, char *))(a4 + 16))( a4,  a1,  a2,  "entry_size",  __str) & v8;
  }

  if ((compare_times("entry_access_time", (void *)(a1 + 104), (void *)(a2 + 104), a3, __str) & 1) == 0) {
    uint64_t v8 = (*(unsigned int (**)(uint64_t, uint64_t, uint64_t, const char *, char *))(a4 + 16))( a4,  a1,  a2,  "entry_access_time",  __str) & v8;
  }
  if ((compare_times("entry_modification_time", (void *)(a1 + 120), (void *)(a2 + 120), a3, __str) & 1) == 0) {
    uint64_t v8 = (*(unsigned int (**)(uint64_t, uint64_t, uint64_t, const char *, char *))(a4 + 16))( a4,  a1,  a2,  "entry_modification_time",  __str) & v8;
  }
  if ((compare_times("entry_status_time", (void *)(a1 + 136), (void *)(a2 + 136), a3, __str) & 1) == 0) {
    uint64_t v8 = (*(unsigned int (**)(uint64_t, uint64_t, uint64_t, const char *, char *))(a4 + 16))( a4,  a1,  a2,  "entry_status_time",  __str) & v8;
  }
  if (*(unsigned __int8 *)(a1 + 157) != *(unsigned __int8 *)(a2 + 157))
  {
    if (*(_BYTE *)(a1 + 157)) {
      uint64_t v21 = "yes";
    }
    else {
      uint64_t v21 = "no";
    }
    if (*(_BYTE *)(a2 + 157)) {
      uint64_t v22 = "yes";
    }
    else {
      uint64_t v22 = "no";
    }
    snprintf(__str, 0x400uLL, "is_root: %s vs %s", v21, v22);
    return (*(unsigned int (**)(uint64_t, uint64_t, uint64_t, const char *, char *))(a4 + 16))( a4,  a1,  a2,  "is_root",  __str) & v8;
  }

  return v8;
}

uint64_t compare_strings(int a1, char *__s1, char *__s2, char *__str)
{
  if (__s1 && !__s2 || !__s1 && __s2)
  {
    snprintf(__str, 0x400uLL, "%s is missing %s");
    return 0LL;
  }

  uint64_t result = 1LL;
  if (__s1 && __s2)
  {
    if (!strcmp(__s1, __s2)) {
      return 1LL;
    }
    snprintf(__str, 0x400uLL, "%s: %s vs %s");
    return 0LL;
  }

  return result;
}

uint64_t compare_times(const char *a1, void *a2, void *a3, unint64_t a4, char *__str)
{
  if (*a2 != *a3) {
    snprintf(__str, 0x400uLL, "%s.tv_sec: %ld vs %ld", a1, *a2, *a3);
  }
  uint64_t v10 = a2[1];
  uint64_t v11 = a3[1];
  uint64_t v12 = v10 - v11;
  if (v10 == v11) {
    return 1LL;
  }
  if (v12 < 0) {
    uint64_t v12 = v11 - v10;
  }
  if (v12 < a4) {
    return 1LL;
  }
  snprintf(__str, 0x400uLL, "%s.tv_nsec: %ld vs %ld (%ld margin)", a1, v10, a3[1], a4);
  return 0LL;
}

uint64_t BOMCopierSourceEntryGetHonorsSetuid(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 8);
}

uint64_t parse_apple_archive_acl_blob(uint64_t a1, uint8_t *data, size_t data_size, void *a4)
{
  AAEntryACLBlob v6 = AAEntryACLBlobCreateWithEncodedData(data, data_size);
  if (v6)
  {
    uint64_t v7 = v6;
    dir = 0LL;
    pid_t v8 = getpid();
    asprintf(&dir, "/tmp/.BCSE.%u.T_XXXXXX", v8);
    if (dir)
    {
      int v9 = mkstemp(dir);
      if (v9 == -1)
      {
        unsigned int v14 = dir;
        int v15 = __error();
        size_t v16 = strerror(*v15);
        uint64_t v26 = v14;
        uint64_t v11 = 1LL;
        BOMCopierErrorCapture( a4,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c",  5932,  (uint64_t)"parse_apple_archive_acl_blob",  "Could not mkstemp %s: %s\n",  v26,  v16);
        free(dir);
      }

      else
      {
        close(v9);
        int v10 = AAEntryACLBlobApplyToPath(v7, dir, "", 0LL);
        if (v10)
        {
          BOMCopierErrorCapture( a4,  v10,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c",  5942,  (uint64_t)"parse_apple_archive_acl_blob",  "Could not apply AppleArchive ACL blob to %s: %d\n");
        }

        else
        {
          acl_t file = acl_get_file(dir, ACL_TYPE_EXTENDED);
          if (file)
          {
            int v18 = file;
            ssize_t len_p = 0LL;
            int v19 = acl_to_text(file, &len_p);
            acl_free(v18);
            if (v19)
            {
              ssize_t v21 = len_p;
              uint64_t v20 = dir;
              *(void *)(a1 + 224) = v19;
              *(void *)(a1 + 232) = v21;
              unlink(v20);
              free(dir);
              AAEntryACLBlobClear(v7);
              AAEntryACLBlobDestroy(v7);
              return 0LL;
            }

            int v24 = *__error();
            int v25 = __error();
            strerror(*v25);
            BOMCopierErrorCapture( a4,  v24,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c",  5962,  (uint64_t)"parse_apple_archive_acl_blob",  "Could not convert ACL to text for %s: %s");
          }

          else
          {
            int v22 = *__error();
            off_t v23 = __error();
            strerror(*v23);
            BOMCopierErrorCapture( a4,  v22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c",  5950,  (uint64_t)"parse_apple_archive_acl_blob",  "Could not get ACL for %s: %s\n");
          }
        }

        free(dir);
        return 1LL;
      }
    }

    else
    {
      uint64_t v12 = __error();
      strerror(*v12);
      uint64_t v11 = 1LL;
      BOMCopierErrorCapture( a4,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c",  5925,  (uint64_t)"parse_apple_archive_acl_blob",  "Could not create ACL file path: %s\n");
    }
  }

  else
  {
    uint64_t v11 = 1LL;
    BOMCopierErrorCapture( a4,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c",  5917,  (uint64_t)"parse_apple_archive_acl_blob",  "Could not decode AppleArchive ACL data blob");
  }

  return v11;
}

uint64_t parse_apple_archive_xat_blob(uint64_t a1, uint8_t *data, size_t data_size, void *a4)
{
  AAEntryACLBlob v6 = AAEntryXATBlobCreateWithEncodedData(data, data_size);
  if (v6)
  {
    uint64_t v7 = v6;
    Entryint64_t Count = AAEntryXATBlobGetEntryCount(v6);
    if (EntryCount)
    {
      uint32_t v9 = EntryCount;
      uint32_t v10 = 0;
      while (1)
      {
        size_t data_sizea = 0LL;
        key_size_t length = 0LL;
        if (AAEntryXATBlobGetEntry(v7, v10, 0LL, 0LL, &key_length, 0LL, 0LL, &data_sizea))
        {
          BOMCopierErrorCapture( a4,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c",  6021,  (uint64_t)"parse_apple_archive_xat_blob",  "Could not retrieve AppleArchive XAT entry sizes: %d");
          return 1LL;
        }

        size_t v11 = key_length + 1;
        uint64_t v12 = (char *)malloc(key_length + 1);
        if (!v12)
        {
          int v22 = *__error();
          off_t v23 = __error();
          strerror(*v23);
          BOMCopierErrorCapture( a4,  v22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c",  6029,  (uint64_t)"parse_apple_archive_xat_blob",  "Could not allocate xattr name: %s");
          return 1LL;
        }

        unsigned int v13 = v12;
        size_t v14 = data_sizea;
        int v15 = (uint8_t *)malloc(data_sizea);
        if (!v15)
        {
          int v24 = *__error();
          int v25 = __error();
          uint64_t v26 = strerror(*v25);
          BOMCopierErrorCapture( a4,  v24,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c",  6036,  (uint64_t)"parse_apple_archive_xat_blob",  "Could not allocate xattr value: %s",  v26);
          goto LABEL_19;
        }

        size_t v16 = v15;
        if (AAEntryXATBlobGetEntry(v7, v10, v11, v13, &key_length, v14, v15, &data_sizea))
        {
          BOMCopierErrorCapture( a4,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c",  6044,  (uint64_t)"parse_apple_archive_xat_blob",  "Could not retrieve AppleArchive XAT entry: %d");
          goto LABEL_18;
        }

        int v17 = *(_DWORD *)(a1 + 208);
        int v18 = (char *)realloc(*(void **)(a1 + 216), 24LL * (v17 + 1));
        if (!v18) {
          break;
        }
        size_t v19 = data_sizea;
        uint64_t v20 = (char **)&v18[24 * v17];
        char *v20 = v13;
        v20[1] = (char *)v19;
        v20[2] = (char *)v16;
        *(_DWORD *)(a1 + 208) = v17 + 1;
        *(void *)(a1 + 216) = v18;
        if (v9 == ++v10) {
          goto LABEL_10;
        }
      }

      int v27 = *__error();
      int v28 = __error();
      strerror(*v28);
      BOMCopierErrorCapture( a4,  v27,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c",  6062,  (uint64_t)"parse_apple_archive_xat_blob",  "Could not allocate new_extended_attribute_list: %s");
LABEL_18:
      free(v16);
LABEL_19:
      free(v13);
      return 1LL;
    }

    else
    {
LABEL_10:
      AAEntryXATBlobClear(v7);
      AAEntryXATBlobDestroy(v7);
      return 0LL;
    }
  }

  else
  {
    uint64_t v21 = 1LL;
    BOMCopierErrorCapture( a4,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c",  5998,  (uint64_t)"parse_apple_archive_xat_blob",  "Could not decode AppleArchive XAT data blob");
  }

  return v21;
}

uint64_t xattr_compare(const char **a1, const char **a2)
{
  return string_compare(*a1, *a2);
}

uint64_t BOMFSOTypeInfoArchiveLength(uint64_t a1)
{
  int v1 = *(_DWORD *)a1 - 1;
  uint64_t result = 1LL;
  switch(v1)
  {
    case 0:
      else {
        uint64_t result = 1LL;
      }
      break;
    case 1:
      return result;
    case 2:
      BOOL v4 = (unsigned __int16)(B_CKSUMS & *(_WORD *)(a1 + 40)) == 0;
      uint64_t v5 = *(void *)(a1 + 64);
      if (v4) {
        uint64_t v6 = v5 + 1;
      }
      else {
        uint64_t v6 = v5 + 5;
      }
      uint64_t result = v6 + 5;
      break;
    case 3:
      uint64_t result = 5LL;
      break;
    default:
      uint64_t result = -1LL;
      break;
  }

  return result;
}

uint64_t BOMFSOTypeInfoArchive(uint64_t a1, uint64_t a2)
{
  switch(*(_DWORD *)a2)
  {
    case 1:
      BOMStreamWriteUInt8(a1, 1);
      goto LABEL_11;
    case 2:
      BOMStreamWriteUInt8(a1, 1);
      goto LABEL_11;
    case 3:
      BOMStreamWriteUInt8(a1, 1);
      signed int v5 = *(_DWORD *)(a2 + 64) + 1;
      BOMStreamWriteUInt32(a1, v5);
      BOMStreamWriteBuffer(a1, *(const void **)(a2 + 96), v5);
      goto LABEL_11;
    case 4:
      BOMStreamWriteUInt8(a1, 1);
LABEL_10:
      BOMStreamWriteUInt32(a1, *(_DWORD *)(a2 + 88));
LABEL_11:
      uint64_t result = 0LL;
      break;
    default:
      uint64_t result = 1LL;
      break;
  }

  return result;
}

uint64_t BOMFSOTypeInfoUnarchive(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = 1LL;
  if (a1 && a2)
  {
    switch(*(_DWORD *)a2)
    {
      case 1:
        if (BOMStreamReadUInt8(a1) != 1)
        {
          fprintf((FILE *)*MEMORY[0x1895F89D0], "File object has an invalid version: 0x%X\nCannot dearchive.\n");
          return 1LL;
        }

        goto LABEL_24;
      case 2:
        fprintf((FILE *)*MEMORY[0x1895F89D0], "Directory object has an invalid version: 0x%X\nCannot dearchive.\n");
        return 1LL;
      case 3:
        if (BOMStreamReadUInt8(a1) != 1)
        {
          fprintf((FILE *)*MEMORY[0x1895F89D0], "Symlink object has an invalid version: 0x%X\nCannot dearchive.\n");
          return 1LL;
        }

        int UInt32 = BOMStreamReadUInt32(a1);
        if (UInt32)
        {
          size_t v6 = UInt32;
          uint64_t v7 = (char *)BOM_malloc(UInt32);
          if (!v7) {
            return 1LL;
          }
          pid_t v8 = v7;
          BOMStreamReadBuffer(a1, v7, v6);
        }

        else
        {
          uint64_t v2 = 1LL;
          uint32_t v9 = (char *)BOM_malloc(1uLL);
          if (!v9) {
            return v2;
          }
          pid_t v8 = v9;
          *uint32_t v9 = 0;
        }

        BOMFSObjectSetSymlinkTarget((_DWORD *)a2, v8, 0);
LABEL_24:
        uint64_t v2 = 0LL;
        break;
      case 4:
        if (BOMStreamReadUInt8(a1) == 1)
        {
LABEL_16:
          uint64_t v2 = 0LL;
          *(_DWORD *)(a2 + 88) = BOMStreamReadUInt32(a1);
        }

        else
        {
          fprintf((FILE *)*MEMORY[0x1895F89D0], "Device object has an invalid version: 0x%X\nCannot dearchive.\n");
          return 1LL;
        }

        return v2;
      default:
        return 1LL;
    }
  }

  return v2;
}

uint64_t BOMFSOTypeInfoInitialize(uint64_t a1, uint64_t a2)
{
  uint64_t v14 = *MEMORY[0x1895F89C0];
  int v4 = BOMFSObjectType((unsigned int *)a1);
  if (v4 == 4)
  {
    *(_DWORD *)(a1 + 88) = *(_DWORD *)(a2 + 24);
  }

  else if (v4 == 3)
  {
    uint64_t v7 = (*(uint64_t (**)(void, void, char *, uint64_t))(*(void *)(a1 + 160) + 256LL))( *(void *)(*(void *)(a1 + 160) + 8LL),  *(void *)(a1 + 72),  __s,  1024LL);
    if (v7 < 0 || v7 == 1024)
    {
      pid_t v8 = BOMExceptionHandlerMessage("can't access symlink for %s", *(const char **)(a1 + 72));
      uint32_t v9 = __error();
      _BOMExceptionHandlerCall( (uint64_t)v8,  0,  "/Library/Caches/com.apple.xbs/Sources/Bom/FSObject/BOMFSOTypeInfo.c",  95,  *v9);
      uint64_t v7 = 0LL;
    }

    __s[v7] = 0;
    size_t v10 = strlen(__s) + 1;
    size_t v11 = BOM_malloc(v10);
    memmove(v11, __s, v10);
    BOMFSOTypeInfoSetSymlinkTarget((_DWORD *)a1, (char *)v11, 0);
  }

  else if (v4 == 1 && ((unsigned __int16)B_CKSUMS & *(_WORD *)(a1 + 40)) != 0 && _getFileChecksum(a1))
  {
    signed int v5 = BOMExceptionHandlerMessage("can't compute checksum for %s", *(const char **)(a1 + 72));
    size_t v6 = __error();
    _BOMExceptionHandlerCall( (uint64_t)v5,  0,  "/Library/Caches/com.apple.xbs/Sources/Bom/FSObject/BOMFSOTypeInfo.c",  88,  *v6);
  }

  return 0LL;
}

uint64_t _getFileChecksum(uint64_t a1)
{
  unint64_t v2 = *(void *)(a1 + 64);
  if (!v2)
  {
    int v3 = &v5;
    return BOMCRC32ForBuffer((uint64_t)v3, (_DWORD *)(a1 + 88), v2);
  }

  int v3 = *(char **)(a1 + 24);
  if (v3) {
    return BOMCRC32ForBuffer((uint64_t)v3, (_DWORD *)(a1 + 88), v2);
  }
  if ((*(uint64_t (**)(void, void, void, void))(*(void *)(a1 + 160) + 64LL))( *(void *)(*(void *)(a1 + 160) + 8LL),  *(unsigned int *)(a1 + 16),  0LL,  0LL) < 0) {
    return 0LL;
  }
  else {
    return BOMCRC32ForFileDesc(*(_DWORD *)(a1 + 16), (_DWORD *)(a1 + 88), v2);
  }
}

_DWORD *BOMFSOTypeInfoSetSymlinkTarget(_DWORD *result, char *__s, int a3)
{
  if (__s)
  {
    int v3 = result;
    if (*result == 3)
    {
      char v5 = __s;
      uint64_t result = (_DWORD *)strlen(__s);
      size_t v6 = (size_t)result;
      if (a3)
      {
        uint64_t v7 = BOM_malloc((size_t)result + 1);
        uint64_t result = memmove(v7, v5, v6);
        *((_BYTE *)v7 + v6) = 0;
        char v5 = (char *)v7;
      }

      v3[22] = 0;
      *((void *)v3 + 12) = v5;
      if (((unsigned __int16)B_CKSUMS & (_WORD)v3[10]) != 0)
      {
        size_t v8 = strlen(v5);
        uint64_t result = (_DWORD *)BOMCRC32ForBuffer((uint64_t)v5, v3 + 22, v8);
      }

      *((void *)v3 + 8) = v6;
    }
  }

  return result;
}

uint64_t BOMFSOTypeInfoInitializeDeferred(uint64_t a1, uint64_t a2, uint64_t a3, unsigned __int16 a4)
{
  uint64_t v24 = *MEMORY[0x1895F89C0];
  int v8 = BOMFSObjectType((unsigned int *)a1);
  switch(v8)
  {
    case 4:
      break;
    case 3:
      if (((unsigned __int16)B_STAT & a4) != 0)
      {
        uint64_t v12 = (*(uint64_t (**)(void, uint64_t, char *, uint64_t))(*(void *)(a1 + 160) + 256LL))( *(void *)(*(void *)(a1 + 160) + 8LL),  a3,  __s,  1024LL);
        if (v12 < 0 || v12 == 1024)
        {
          unsigned int v13 = BOMExceptionHandlerMessage("can't access symlink for %s", *(const char **)(a1 + 72));
          uint64_t v14 = __error();
          _BOMExceptionHandlerCall( (uint64_t)v13,  0,  "/Library/Caches/com.apple.xbs/Sources/Bom/FSObject/BOMFSOTypeInfo.c",  136,  *v14);
          uint64_t v12 = 0LL;
        }

        __s[v12] = 0;
        size_t v15 = strlen(__s) + 1;
        size_t v16 = BOM_malloc(v15);
        memmove(v16, __s, v15);
        int v17 = *(void **)(a1 + 96);
        if (v17) {
          free(v17);
        }
        *(void *)(a1 + 96) = v16;
      }

      if (((unsigned __int16)B_CKSUMS & *(_WORD *)(a1 + 40)) != 0 && (unsigned __int16)(B_CKSUMS & a4) != 0)
      {
        size_t v19 = (_DWORD *)(a1 + 88);
        uint64_t v20 = *(const char **)(a1 + 96);
        size_t v21 = strlen(v20);
        BOMCRC32ForBuffer((uint64_t)v20, v19, v21);
      }

      break;
    case 1:
      BOOL v9 = ((unsigned __int16)B_CKSUMS & *(_WORD *)(a1 + 40)) == 0 || (unsigned __int16)(B_CKSUMS & a4) == 0;
      if (!v9 && _getFileChecksum(a1))
      {
        size_t v10 = BOMExceptionHandlerMessage("can't compute checksum for %s", *(const char **)(a1 + 72));
        size_t v11 = __error();
        _BOMExceptionHandlerCall( (uint64_t)v10,  0,  "/Library/Caches/com.apple.xbs/Sources/Bom/FSObject/BOMFSOTypeInfo.c",  127,  *v11);
      }

      break;
  }

  return 0LL;
}

void BOMFSOTypeInfoRelease(uint64_t a1)
{
  if (*(_DWORD *)a1 == 3)
  {
    int v1 = *(void **)(a1 + 96);
    if (v1) {
      free(v1);
    }
  }

uint64_t BOMFSOTypeInfoCopy(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)a1 != 3) {
    return 0LL;
  }
  size_t v4 = strlen(*(const char **)(a1 + 96)) + 1;
  char v5 = (char *)BOM_malloc(v4);
  *(void *)(a2 + 96) = v5;
  if (v5)
  {
    strlcpy(v5, *(const char **)(a1 + 96), v4);
    return 0LL;
  }

  return 1LL;
}

uint64_t BOMFSOTypeInfoChecksum(_DWORD *a1)
{
  if ((*a1 | 2) == 3) {
    return a1[22];
  }
  else {
    return 0LL;
  }
}

uint64_t BOMFSOTypeInfoSymlinkTarget(uint64_t a1)
{
  if (*(_DWORD *)a1 == 3) {
    return *(void *)(a1 + 96);
  }
  else {
    return 0LL;
  }
}

CFStringRef BOMFSOTypeInfoSymlinkTargetString(uint64_t a1)
{
  if (*(_DWORD *)a1 == 3) {
    return CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x189604DB0], *(const char **)(a1 + 96), 0x8000100u);
  }
  else {
    return 0LL;
  }
}

uint64_t BOMFSOTypeInfoDeviceID(_DWORD *a1)
{
  if (*a1 == 4) {
    return a1[22];
  }
  else {
    return 0LL;
  }
}

_DWORD *BOMFSOTypeInfoSetChecksum(_DWORD *result, int a2)
{
  if ((*result | 2) == 3) {
    result[22] = a2;
  }
  return result;
}

_DWORD *BOMFSOTypeInfoSetDeviceID(_DWORD *result, int a2)
{
  if (*result == 4) {
    result[22] = a2;
  }
  return result;
}

const char *BOMFSOTypeInfoSummary(uint64_t a1, int a2, int a3, int a4)
{
  uint64_t v15 = *MEMORY[0x1895F89C0];
  int v8 = (char *)printBuffer;
  if (!printBuffer)
  {
    int v8 = (char *)BOM_malloc(0x1000uLL);
    printBuffer = (uint64_t)v8;
  }

  if ((unsigned __int16)(B_INFOMASK & *(_WORD *)(a1 + 40)) == (unsigned __int16)B_PATHONLY)
  {
    snprintf(v8, 0x1000uLL, "%s\n");
  }

  else
  {
    switch(*(_DWORD *)a1)
    {
      case 1:
        *(_OWORD *)unsigned int v13 = 0u;
        __int128 v14 = 0u;
        if (a4 == -1) {
          goto LABEL_25;
        }
        uint64_t v10 = *(unsigned int *)(a1 + 104);
        if (!(_DWORD)v10) {
          goto LABEL_13;
        }
        uint64_t v11 = *(void *)(a1 + 112) + 8LL;
        break;
      case 2:
        if (!a3) {
          goto LABEL_23;
        }
        snprintf(v8, 0x1000uLL, "%s\t%d/%d\n");
        return (const char *)printBuffer;
      case 3:
        uint64_t v12 = *(void *)(a1 + 72);
        if (a3) {
          snprintf(v8, 0x1000uLL, "%s\t%d/%d\t%lld\t%05u\t%s\n", v12);
        }
        else {
          snprintf(v8, 0x1000uLL, "%s\t%o\t%d/%d\t%lld\t%05u\t%s\n", v12, *(unsigned __int16 *)(a1 + 42));
        }
        return (const char *)printBuffer;
      case 4:
        if (a3) {
LABEL_23:
        }
          snprintf(v8, 0x1000uLL, "%s\t%o\t%d/%d\n");
        else {
          snprintf(v8, 0x1000uLL, "%s\t%o\t%d/%d\t%d\n");
        }
        return (const char *)printBuffer;
      default:
        return "";
    }

    while (*(_DWORD *)(v11 - 8) != a4)
    {
      v11 += 24LL;
      if (!--v10)
      {
LABEL_13:
        if (!a2) {
          goto LABEL_27;
        }
        goto LABEL_26;
      }
    }

LABEL_25:
    if (!a2) {
      goto LABEL_27;
    }
LABEL_26:
    ctime_r((const time_t *)(a1 + 56), v13);
    int v8 = (char *)printBuffer;
LABEL_27:
    snprintf( v8,  0x1000uLL,  "%s\t%o\t%d/%d\t%llu\t%u%s%s%s",  *(void *)(a1 + 72),  *(unsigned __int16 *)(a1 + 42),  *(unsigned int *)(a1 + 44),  *(unsigned int *)(a1 + 48));
  }

  return (const char *)printBuffer;
}

uint64_t BOMFSOTypeInfoSummaryWithFormat(uint64_t a1, char *a2, int a3)
{
  uint64_t v80 = *MEMORY[0x1895F89C0];
  size_t v6 = (char *)printBuffer;
  if (!printBuffer)
  {
    size_t v6 = (char *)BOM_malloc(0x1000uLL);
    printBuffer = (uint64_t)v6;
  }

  int v7 = BOMFSObjectType((unsigned int *)a1);
  char v8 = *a2;
  if (*a2)
  {
    int v9 = v7;
    int v10 = 0;
    int v72 = 0;
    unsigned int v74 = v7 & 0xFFFFFFFD;
    int v73 = v7;
    while (1)
    {
      if (v8 > 98)
      {
        switch(v8)
        {
          case 'c':
            if ((v10 & 0x1000) != 0) {
              goto LABEL_129;
            }
            v10 |= 0x1000u;
            if (v74 != 1) {
              goto LABEL_71;
            }
            if (a3 == -1)
            {
              size_t v53 = printBuffer - (void)v6 + 4096;
            }

            else
            {
              uint64_t v13 = *(unsigned int *)(a1 + 104);
              if (!(_DWORD)v13) {
                goto LABEL_129;
              }
              uint64_t v14 = *(void *)(a1 + 112) + 16LL;
              while (*(_DWORD *)(v14 - 16) != a3)
              {
                v14 += 24LL;
                if (!--v13) {
                  goto LABEL_129;
                }
              }

              size_t v53 = printBuffer - (void)v6 + 4096;
            }

            int v12 = snprintf(v6, v53, "%u\t");
            goto LABEL_128;
          case 'f':
            if ((v10 & 1) != 0) {
              goto LABEL_129;
            }
            v10 |= 1u;
            uint64_t v33 = printBuffer - (void)v6 + 4096;
            BOMFSObjectPathName(a1);
            goto LABEL_62;
          case 'g':
            if ((v10 & 0x10) != 0) {
              goto LABEL_129;
            }
            v10 |= 0x10u;
            uint64_t v34 = printBuffer - (void)v6 + 4096;
            BOMFSObjectGroupID(a1);
            __int128 v35 = v6;
            size_t v36 = v34;
            goto LABEL_74;
          case 'l':
            if ((v10 & 2) != 0) {
              goto LABEL_129;
            }
            v10 |= 2u;
            uint64_t v33 = printBuffer - (void)v6 + 4096;
            BOMFSObjectSymlinkTarget(a1);
LABEL_62:
            int v30 = v6;
            size_t v26 = v33;
LABEL_63:
            int v12 = snprintf(v30, v26, "%s\t");
            goto LABEL_128;
          case 'm':
LABEL_33:
            if ((v10 & 4) != 0) {
              goto LABEL_129;
            }
LABEL_34:
            v10 |= 4u;
            size_t v24 = printBuffer - (void)v6 + 4096;
            BOMFSObjectMode(a1);
            int v12 = snprintf(v6, v24, "%o\t");
            goto LABEL_128;
          case 's':
            if ((v10 & 0x400) != 0) {
              goto LABEL_129;
            }
            v10 |= 0x400u;
            if (BOMFSObjectType((unsigned int *)a1) == B_DirectoryType)
            {
              int v12 = snprintf(v6, printBuffer - (void)v6 + 4096, "\t", v70, v71);
              goto LABEL_128;
            }

            if (a3 == -1)
            {
              int v12 = snprintf(v6, printBuffer - (void)v6 + 4096, "%llu\t");
              goto LABEL_128;
            }

            uint64_t v42 = *(unsigned int *)(a1 + 104);
            if (!(_DWORD)v42) {
              goto LABEL_129;
            }
            uint64_t v43 = *(void *)(a1 + 112) + 8LL;
            while (*(_DWORD *)(v43 - 8) != a3)
            {
              v43 += 24LL;
              if (!--v42) {
                goto LABEL_129;
              }
            }

            size_t v39 = printBuffer - (void)v6 + 4096;
            __int128 v38 = v6;
            goto LABEL_70;
          case 't':
            if ((v10 & 0x100) != 0) {
              goto LABEL_129;
            }
            v10 |= 0x100u;
            if (v74 == 1)
            {
              uint64_t v37 = printBuffer - (void)v6 + 4096;
              BOMFSObjectModTime(a1);
              __int128 v38 = v6;
              size_t v39 = v37;
LABEL_70:
              int v12 = snprintf(v38, v39, "%lu\t");
LABEL_128:
              v6 += v12;
            }

            else
            {
LABEL_71:
              *v6++ = 9;
            }

            goto LABEL_129;
          case 'u':
            if ((v10 & 0x40) != 0) {
              goto LABEL_129;
            }
            v10 |= 0x40u;
            uint64_t v40 = printBuffer - (void)v6 + 4096;
            BOMFSObjectUserID(a1);
            __int128 v35 = v6;
            size_t v36 = v40;
LABEL_74:
            int v12 = snprintf(v35, v36, "%d\t");
            goto LABEL_128;
          default:
            goto LABEL_129;
        }
      }

      switch(v8)
      {
        case 'F':
          if ((v10 & 1) == 0)
          {
            v10 |= 1u;
            size_t v11 = printBuffer - (void)v6 + 4096;
            BOMFSObjectPathName(a1);
            int v12 = snprintf(v6, v11, "%s\t");
            goto LABEL_128;
          }

          goto LABEL_129;
        case 'G':
          if ((v10 & 0x20) == 0)
          {
            if (!BOMFSOTypeInfoSummaryWithFormat_groupNameHash) {
              BOMFSOTypeInfoSummaryWithFormat_groupNameHash = (uint64_t)CFDictionaryCreateMutable( 0LL,  0LL,  0LL,  MEMORY[0x189605250]);
            }
            v10 |= 0x20u;
            size_t v19 = (const void *)(int)BOMFSObjectGroupID(a1);
            if (!CFDictionaryContainsKey((CFDictionaryRef)BOMFSOTypeInfoSummaryWithFormat_groupNameHash, v19))
            {
              gid_t v44 = BOMFSObjectGroupID(a1);
              uint32_t v45 = getgrgid(v44);
              if (v45) {
                gr_name = v45->gr_name;
              }
              else {
                gr_name = "<unknown>";
              }
              goto LABEL_107;
            }

            unint64_t Value = (const __CFString *)CFDictionaryGetValue( (CFDictionaryRef)BOMFSOTypeInfoSummaryWithFormat_groupNameHash,  v19);
            UTF8String = (char *)BOMCFStringGetUTF8String(Value);
            v6 += snprintf(v6, printBuffer - (void)v6 + 4096, "%s\t", UTF8String);
            free(UTF8String);
          }

          goto LABEL_129;
        case 'H':
        case 'I':
        case 'J':
        case 'K':
        case 'N':
        case 'O':
        case 'P':
        case 'Q':
        case 'R':
          goto LABEL_129;
        case 'L':
          if ((v10 & 2) == 0)
          {
            v10 |= 2u;
            if (v9 == B_SymlinkType)
            {
              size_t v22 = printBuffer - (void)v6 + 4096;
              off_t v23 = (const char *)BOMFSObjectSymlinkTarget(a1);
              v6 += snprintf(v6, v22, "%s\t", v23);
              goto LABEL_33;
            }

            *v6++ = 9;
            if ((v10 & 4) == 0) {
              goto LABEL_34;
            }
          }

          goto LABEL_129;
        case 'M':
          if ((v10 & 8) == 0)
          {
            v10 |= 8u;
            int v25 = BOMFSObjectMode(a1);
            strmode(v25, __bp);
            size_t v26 = printBuffer - (void)v6 + 4096;
            goto LABEL_49;
          }

          goto LABEL_129;
        case 'S':
          if ((v10 & 0x800) != 0) {
            goto LABEL_129;
          }
          v10 |= 0x800u;
          if (v74 != 1)
          {
            char *v6 = 0;
            goto LABEL_129;
          }

          if (a3 == -1)
          {
            int v29 = snprintf(&__str, 0xCuLL, "%lld");
          }

          else
          {
            uint64_t v27 = *(unsigned int *)(a1 + 104);
            if (!(_DWORD)v27)
            {
LABEL_44:
              int v29 = v72;
              if (!v72) {
                goto LABEL_45;
              }
              goto LABEL_112;
            }

            uint64_t v28 = *(void *)(a1 + 112) + 8LL;
            while (*(_DWORD *)(v28 - 8) != a3)
            {
              v28 += 24LL;
              if (!--v27) {
                goto LABEL_44;
              }
            }

            int v29 = snprintf(&__str, 0xCuLL, "%lu");
          }

          if (!v29)
          {
LABEL_45:
            int v72 = 0;
            goto LABEL_129;
          }

LABEL_123:
              --v64;
              ++v63;
              size_t v6 = v65;
              if (v62 + 1 == v63)
              {
                int v72 = 0;
                size_t v6 = v65;
                goto LABEL_129;
              }
            }

            char v66 = 44;
LABEL_122:
            uint64_t v65 = v6 + 2;
            v6[1] = v66;
            goto LABEL_123;
          }

          int v72 = v29;
LABEL_129:
          int v67 = *++a2;
          char v8 = v67;
          if (!v67) {
            goto LABEL_132;
          }
          break;
        case 'T':
          if ((v10 & 0x200) == 0)
          {
            v10 |= 0x200u;
            if (v74 != 1) {
              goto LABEL_71;
            }
            time_t v75 = BOMFSObjectModTime(a1);
            ctime_r(&v75, __s);
            __s[strlen(__s) - 1] = 0;
            size_t v26 = printBuffer - (void)v6 + 4096;
LABEL_49:
            int v30 = v6;
            goto LABEL_63;
          }

          goto LABEL_129;
        case 'U':
          if ((v10 & 0x80) == 0)
          {
            if (!BOMFSOTypeInfoSummaryWithFormat_userNameHash) {
              BOMFSOTypeInfoSummaryWithFormat_userNameHash = (uint64_t)CFDictionaryCreateMutable( 0LL,  0LL,  0LL,  MEMORY[0x189605250]);
            }
            v10 |= 0x80u;
            size_t v19 = (const void *)(int)BOMFSObjectUserID(a1);
            if (!CFDictionaryContainsKey((CFDictionaryRef)BOMFSOTypeInfoSummaryWithFormat_userNameHash, v19))
            {
              uid_t v47 = BOMFSObjectUserID(a1);
              AAFieldKey v48 = getpwuid(v47);
              if (v48) {
                pw_name = v48->pw_name;
              }
              else {
                pw_name = "<unknown>";
              }
              CFStringRef v54 = CFStringCreateWithCString(0LL, pw_name, 0x8000100u);
              v6 += snprintf(v6, printBuffer - (void)v6 + 4096, "%s\t", pw_name);
              int v55 = (__CFDictionary *)BOMFSOTypeInfoSummaryWithFormat_userNameHash;
              goto LABEL_108;
            }

            char v31 = (const __CFString *)CFDictionaryGetValue( (CFDictionaryRef)BOMFSOTypeInfoSummaryWithFormat_userNameHash,  v19);
            AAFieldKey v32 = (char *)BOMCFStringGetUTF8String(v31);
            v6 += snprintf(v6, printBuffer - (void)v6 + 4096, "%s\t", v32);
            free(v32);
          }

          goto LABEL_129;
        default:
          if (v8 == 47)
          {
            if ((v10 & 0x2000) == 0)
            {
              v10 |= 0x2000u;
              size_t v41 = printBuffer - (void)v6 + 4096;
              BOMFSObjectUserID(a1);
              BOMFSObjectGroupID(a1);
              int v12 = snprintf(v6, v41, "%d/%d\t");
              goto LABEL_128;
            }
          }

          else if (v8 == 63 && (v10 & 0x4000) == 0)
          {
            if (!BOMFSOTypeInfoSummaryWithFormat_userNameHash) {
              BOMFSOTypeInfoSummaryWithFormat_userNameHash = (uint64_t)CFDictionaryCreateMutable( 0LL,  0LL,  0LL,  MEMORY[0x189605250]);
            }
            uint64_t v15 = (const void *)(int)BOMFSObjectUserID(a1);
            if (CFDictionaryContainsKey((CFDictionaryRef)BOMFSOTypeInfoSummaryWithFormat_userNameHash, v15))
            {
              size_t v16 = (const __CFString *)CFDictionaryGetValue( (CFDictionaryRef)BOMFSOTypeInfoSummaryWithFormat_userNameHash,  v15);
              int v17 = (char *)BOMCFStringGetUTF8String(v16);
              int v18 = snprintf(v6, printBuffer - (void)v6 + 4096, "%s/", v17);
              free(v17);
            }

            else
            {
              uid_t v50 = BOMFSObjectUserID(a1);
              int v51 = getpwuid(v50);
              if (v51) {
                AAFieldKey v52 = v51->pw_name;
              }
              else {
                AAFieldKey v52 = "<unknown>";
              }
              CFStringRef v56 = CFStringCreateWithCString(0LL, v52, 0x8000100u);
              int v18 = snprintf(v6, printBuffer - (void)v6 + 4096, "%s/", v52);
              CFDictionarySetValue((CFMutableDictionaryRef)BOMFSOTypeInfoSummaryWithFormat_userNameHash, v15, v56);
              CFRelease(v56);
            }

            if (!BOMFSOTypeInfoSummaryWithFormat_groupNameHash) {
              BOMFSOTypeInfoSummaryWithFormat_groupNameHash = (uint64_t)CFDictionaryCreateMutable( 0LL,  0LL,  0LL,  MEMORY[0x189605250]);
            }
            v10 |= 0x4000u;
            v6 += v18;
            size_t v19 = (const void *)(int)BOMFSObjectGroupID(a1);
            if (CFDictionaryContainsKey((CFDictionaryRef)BOMFSOTypeInfoSummaryWithFormat_groupNameHash, v19))
            {
              uint32_t v57 = (const __CFString *)CFDictionaryGetValue( (CFDictionaryRef)BOMFSOTypeInfoSummaryWithFormat_groupNameHash,  v19);
              unsigned int v58 = (char *)BOMCFStringGetUTF8String(v57);
              v6 += snprintf(v6, printBuffer - (void)v6 + 4096, "%s\t", v58);
              free(v58);
            }

            else
            {
              gid_t v59 = BOMFSObjectGroupID(a1);
              __int16 v60 = getgrgid(v59);
              if (v60) {
                gr_name = v60->gr_name;
              }
              else {
                gr_name = "<unknown>";
              }
LABEL_107:
              CFStringRef v54 = CFStringCreateWithCString(0LL, gr_name, 0x8000100u);
              v6 += snprintf(v6, printBuffer - (void)v6 + 4096, "%s\t", gr_name);
              int v55 = (__CFDictionary *)BOMFSOTypeInfoSummaryWithFormat_groupNameHash;
LABEL_108:
              CFDictionarySetValue(v55, v19, v54);
              CFRelease(v54);
            }

            int v9 = v73;
          }

          goto LABEL_129;
      }
    }
  }

_DWORD *BOMFSOTypeInfoParseSummaryWithSys(const char *a1, void *a2)
{
  uint64_t v27 = *MEMORY[0x1895F89C0];
  int v3 = strdup(a1);
  uint64_t v4 = 0LL;
  __stringp = v3;
  while (1)
  {
    char v5 = strsep(&__stringp, "\t");
    __s[v4] = v5;
    if (!v5) {
      break;
    }
    if (++v4 == 10) {
      goto LABEL_42;
    }
  }

  if ((_DWORD)v4)
  {
    if ((_DWORD)v4 != 10)
    {
      for (uint64_t i = 0LL; i != v4; ++i)
      {
        if (!*__s[i])
        {
          warnx("Empty field in summary");
          goto LABEL_45;
        }
      }

      int v7 = __s[0];
      char v8 = strrchr(__s[0], 47);
      if (v8) {
        int v9 = v8 + 1;
      }
      else {
        int v9 = v7;
      }
      __int16 v10 = strtol(__s[1], &__endptr, 8);
      if (*__endptr)
      {
LABEL_17:
        uint64_t v13 = 0LL;
      }

      else
      {
        __int16 v11 = v10;
        int v12 = BOMFSObjectTypeForMode(v10);
        switch(v12)
        {
          case 1:
            if ((_DWORD)v4 != 5) {
              goto LABEL_17;
            }
            break;
          case 2:
            if ((_DWORD)v4 != 3) {
              goto LABEL_17;
            }
            break;
          case 3:
            if ((_DWORD)v4 != 6) {
              goto LABEL_17;
            }
            break;
          case 4:
            if ((_DWORD)v4 != 4) {
              goto LABEL_17;
            }
            break;
          default:
            goto LABEL_17;
        }

        if (!a2) {
          a2 = BomSys_default();
        }
        uint64_t v14 = BOMFSObjectNewWithSys(v12, a2);
        uint64_t v13 = v14;
        if (!v14)
        {
          warnx("Can't create FSO for %s");
LABEL_40:
          if (v3) {
            goto LABEL_46;
          }
          goto LABEL_47;
        }

        BOMFSObjectSetFlags((uint64_t)v14, B_CKSUMS | B_STAT);
        BOMFSObjectSetPathName((uint64_t)v13, v7, 1);
        BOMFSObjectSetShortName((uint64_t)v13, v9, 1);
        BOMFSObjectSetMode((uint64_t)v13, v11);
        if (sscanf(__s[2], "%d/%d", &v20, &v19) == 2)
        {
          BOMFSObjectSetUserID((uint64_t)v13, v20);
          BOMFSObjectSetGroupID((uint64_t)v13, v19);
          switch(v12)
          {
            case 1:
LABEL_30:
              uint64_t v15 = strtoll(v24, &__endptr, 10);
              if (!*__endptr)
              {
                BOMFSObjectSetSize((uint64_t)v13, v15);
                int v16 = strtoul(v25, &__endptr, 10);
                if (!*__endptr)
                {
                  BOMFSObjectSetChecksum(v13, v16);
                  if (v12 == 3) {
                    BOMFSObjectSetSymlinkTarget(v13, v26, 1);
                  }
                  goto LABEL_34;
                }
              }

              break;
            case 4:
              int v17 = strtoul(v24, &__endptr, 10);
              if (!*__endptr)
              {
                BOMFSObjectSetDeviceID(v13, v17);
                if (!v3) {
                  return v13;
                }
                goto LABEL_38;
              }

              break;
            case 3:
              goto LABEL_30;
            default:
LABEL_34:
              if (!v3) {
                return v13;
              }
LABEL_38:
              free(v3);
              return v13;
          }
        }
      }

      warnx("Improperly formatted field");
      goto LABEL_40;
    }

LABEL_45:
  uint64_t v13 = 0LL;
  if (v3) {
LABEL_46:
  }
    free(v3);
LABEL_47:
  if (v13)
  {
    BOMFSObjectFree((uint64_t)v13);
    return 0LL;
  }

  return v13;
}

uint64_t BOMFSOArchInfoArchiveLength(uint64_t a1)
{
  uint64_t v1 = *(int *)(a1 + 104);
  uint64_t v2 = 4 * v1;
  uint64_t v3 = 12 * v1;
  else {
    uint64_t v4 = 0LL;
  }
  return v3 + v4 + 5;
}

uint64_t BOMFSOArchInfoArchive(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)a2 == 1)
  {
    if ((unsigned __int16)(B_ARCHMASK & *(_WORD *)(a2 + 40)) >> B_ARCHOFFT)
    {
      uint64_t v4 = *(unsigned int *)(a2 + 104);
      BOMStreamWriteUInt8(a1, 1);
      BOMStreamWriteUInt32(a1, v4);
      if ((int)v4 >= 1)
      {
        uint64_t v5 = 0LL;
        uint64_t v6 = 24 * v4;
        do
        {
          BOMStreamWriteUInt32(a1, *(_DWORD *)(*(void *)(a2 + 112) + v5));
          BOMStreamWriteUInt32(a1, *(_DWORD *)(*(void *)(a2 + 112) + v5 + 4));
          BOMStreamWriteUInt32(a1, *(_DWORD *)(*(void *)(a2 + 112) + v5 + 8));
          v5 += 24LL;
        }

        while (v6 != v5);
      }
    }
  }

  return 0LL;
}

uint64_t BOMFSOArchInfoUnarchive(uint64_t a1, uint64_t a2)
{
  uint64_t result = 1LL;
  if (!a1 || !a2) {
    return result;
  }
  int UInt8 = BOMStreamReadUInt8(a1);
  if (UInt8 != 1)
  {
    fprintf((FILE *)*MEMORY[0x1895F89D0], "Architecture info has an invalid version: 0x%X\nCannot dearchive.\n", UInt8);
    return 1LL;
  }

  int UInt32 = BOMStreamReadUInt32(a1);
  *(_DWORD *)(a2 + 104) = UInt32;
  int v7 = BOM_malloc(24LL * UInt32);
  *(void *)(a2 + 112) = v7;
  if (!v7) {
    return 1LL;
  }
  if (UInt32 < 1) {
    return 0LL;
  }
  uint64_t v8 = 0LL;
  uint64_t v9 = 24LL * UInt32;
  do
  {
    *(_DWORD *)(*(void *)(a2 + 112) + v8) = BOMStreamReadUInt32(a1);
    *(_DWORD *)(*(void *)(a2 + 112) + v8 + 4) = BOMStreamReadUInt32(a1);
    *(void *)(*(void *)(a2 + 112) + v8 + 8) = BOMStreamReadUInt32(a1);
    uint64_t result = 0LL;
    v8 += 24LL;
  }

  while (v9 != v8);
  return result;
}

uint64_t BOMStorageNew(const char *a1, uint64_t a2)
{
  return BOMStorageNewWithOptionsAndSys(a1, a2, 0LL);
}

uint64_t BOMStorageNewWithOptionsAndSys( const char *a1, uint64_t a2, uint64_t (**a3)(void, const char *, uint64_t, uint64_t))
{
  uint64_t v3 = a3;
  uint64_t v14 = *MEMORY[0x1895F89C0];
  if (!a3) {
    uint64_t v3 = (uint64_t (**)(void, const char *, uint64_t, uint64_t))BomSys_default();
  }
  uint64_t v5 = v3[2](v3[1], a1, 1538LL, 420LL);
  if ((_DWORD)v5 == -1)
  {
    uint64_t v8 = (FILE *)*MEMORY[0x1895F89D0];
    uint64_t v9 = __error();
    __int16 v10 = strerror(*v9);
    fprintf(v8, "can't open %s: %s\n", a1, v10);
  }

  else
  {
    uint64_t v6 = v5;
    bzero(v11, 0x460uLL);
    int v12 = v6;
    uint64_t v13 = v3;
    if (!_WriteRootPage((uint64_t)v11))
    {
      ((void (*)(uint64_t (*)(void, const char *, uint64_t, uint64_t), uint64_t))v3[4])(v3[1], v6);
      return BOMStorageOpenWithSys(a1, 1, v3);
    }
  }

  return 0LL;
}

uint64_t BOMStorageNewWithSys( const char *a1, uint64_t (**a2)(void, const char *, uint64_t, uint64_t))
{
  return BOMStorageNewWithOptionsAndSys(a1, (uint64_t)a2, a2);
}

uint64_t BOMStorageNewWithOptions(const char *a1, uint64_t a2)
{
  return BOMStorageNewWithOptionsAndSys(a1, a2, 0LL);
}

uint64_t _WriteRootPage(uint64_t a1)
{
  if (a1) {
    uint64_t v2 = *(void *)(a1 + 1120);
  }
  else {
    uint64_t v2 = 0LL;
  }
  uint64_t v3 = 1LL;
  uint64_t v4 = BOMStreamWithFileAndSys(*(_DWORD *)(a1 + 1028), 0LL, 0x200uLL, 1, 0LL, (void *)v2);
  if (v4)
  {
    uint64_t v5 = v4;
    BOMStreamWriteUInt32(v4, 0x424F4D53u);
    BOMStreamWriteUInt32(v5, 0x746F7265u);
    BOMStreamWriteUInt32(v5, 1u);
    BOMStreamWriteUInt32(v5, *(_DWORD *)(a1 + 1056));
    BOMStreamWriteUInt32(v5, *(_DWORD *)(a1 + 1060));
    BOMStreamWriteUInt32(v5, *(_DWORD *)(a1 + 1064));
    BOMStreamWriteUInt32(v5, *(_DWORD *)(a1 + 1096));
    BOMStreamWriteUInt32(v5, *(_DWORD *)(a1 + 1100));
    uint64_t v3 = BOMStreamFree(v5);
    if ((*(unsigned int (**)(void, void))(v2 + 72))(*(void *)(v2 + 8), *(unsigned int *)(a1 + 1028)))
    {
      uint64_t v6 = (FILE *)*MEMORY[0x1895F89D0];
      int v7 = __error();
      uint64_t v8 = strerror(*v7);
      fprintf(v6, "fsync: %s\n", v8);
      return 1LL;
    }
  }

  return v3;
}

uint64_t BOMStorageOpenWithSys(const char *a1, int a2, void *a3)
{
  uint64_t v3 = a3;
  if (!a3) {
    uint64_t v3 = BomSys_default();
  }
  uint64_t v6 = (*((uint64_t (**)(void, const char *, void, uint64_t))v3 + 2))( *((void *)v3 + 1),  a1,  2 * (a2 != 0),  420LL);
  if ((_DWORD)v6 != -1)
  {
    uint64_t v7 = v6;
    if ((*((unsigned int (**)(void, uint64_t, _BYTE *))v3 + 11))(*((void *)v3 + 1), v6, v48) == -1)
    {
      size_t v21 = (FILE *)*MEMORY[0x1895F89D0];
      size_t v22 = __error();
      uid_t v47 = strerror(*v22);
      off_t v23 = "fstat: %s\n";
LABEL_15:
      size_t v24 = v21;
LABEL_19:
      fprintf(v24, v23, v47);
      goto LABEL_20;
    }

    uint64_t v8 = BOMStreamWithFileAndSys(v7, 0LL, 0x200uLL, 0, 0LL, v3);
    if (!v8)
    {
      size_t v24 = (FILE *)*MEMORY[0x1895F89D0];
      uid_t v47 = (char *)a1;
      off_t v23 = "can't read from %s\n";
      goto LABEL_19;
    }

    uint64_t v9 = v8;
    if (BOMStreamReadUInt32(v8) == 1112493395 && BOMStreamReadUInt32(v9) == 1953460837)
    {
      int UInt32 = BOMStreamReadUInt32(v9);
      if (UInt32 == 1)
      {
        __int16 v11 = BOM_malloc(0x468uLL);
        uint64_t v12 = (uint64_t)v11;
        if (!v11)
        {
          uint64_t v28 = (FILE *)*MEMORY[0x1895F89D0];
          int v29 = __error();
          int v30 = strerror(*v29);
          fprintf(v28, "malloc: %s\n", v30);
          BOMStreamFree(v9);
          (*((void (**)(void, uint64_t))v3 + 4))(*((void *)v3 + 1), v7);
          return v12;
        }

        bzero(v11, 0x468uLL);
        *(void *)(v12 + 1120) = v3;
        *(_DWORD *)(v12 + 1028) = v7;
        int v13 = v49;
        *(_DWORD *)(v12 + 1032) = v49;
        *(_DWORD *)(v12 + 1036) = v13;
        *(_BYTE *)(v12 + 1052) = a2;
        *(_BYTE *)(v12 + 1053) = 0;
        *(_DWORD *)(v12 + 1056) = BOMStreamReadUInt32(v9);
        *(_DWORD *)(v12 + 1060) = BOMStreamReadUInt32(v9);
        *(_DWORD *)(v12 + 1064) = BOMStreamReadUInt32(v9);
        *(_DWORD *)(v12 + 1096) = BOMStreamReadUInt32(v9);
        *(_DWORD *)(v12 + 1100) = BOMStreamReadUInt32(v9);
        BOMStreamFree(v9);
        int v14 = *(_DWORD *)(v12 + 1060);
        int v15 = *(_DWORD *)(v12 + 1064);
        BOOL v16 = __CFADD__(v15, v14);
        unsigned int v17 = v15 + v14;
        if (!v16)
        {
          unsigned int v31 = *(_DWORD *)(v12 + 1032);
          if (v17 > v31)
          {
            fprintf((FILE *)*MEMORY[0x1895F89D0], "%s: stream invalid; admin range is outside file\n");
            goto LABEL_20;
          }

          int v32 = *(_DWORD *)(v12 + 1096);
          int v33 = *(_DWORD *)(v12 + 1100);
          BOOL v16 = __CFADD__(v33, v32);
          unsigned int v34 = v33 + v32;
          if (v16)
          {
            fprintf((FILE *)*MEMORY[0x1895F89D0], "%s: stream invalid; overflow of toc offset+size\n");
            goto LABEL_20;
          }

          if (v34 > v31)
          {
            fprintf((FILE *)*MEMORY[0x1895F89D0], "%s: stream invalid; toc range is outside file\n");
            goto LABEL_20;
          }

          if (a2)
          {
            if (v31 <= 0x4000) {
              unsigned int v35 = 0x4000;
            }
            else {
              unsigned int v35 = *(_DWORD *)(v12 + 1032);
            }
            *(_DWORD *)(v12 + 1048) = v35;
            _CreateMapAddress(v12, v35);
            uint64_t v36 = *(void *)(v12 + 1040);
            if (!v36) {
              goto LABEL_20;
            }
            *(_BYTE *)(v12 + 1053) = 1;
            uint64_t v37 = *(unsigned int *)(v12 + 1096);
            if ((_DWORD)v37)
            {
              uint64_t v38 = BOMStreamWithFileAndSys( *(_DWORD *)(v12 + 1028),  v37,  *(unsigned int *)(v12 + 1100),  0,  (char *)(v36 + v37),  v3);
              if (!v38) {
                goto LABEL_20;
              }
              BOMStreamFree(v38);
            }

            _CreateBlockTable(v12);
            uint64_t v39 = *(unsigned int *)(v12 + 1060);
            if ((_DWORD)v39)
            {
              uint64_t v40 = BOMStreamWithFileAndSys(v7, v39, *(unsigned int *)(v12 + 1064), 0, 0LL, v3);
LABEL_45:
              uint64_t v43 = v40;
              if (!v40)
              {
                uint32_t v45 = (FILE *)*MEMORY[0x1895F89D0];
                unsigned int v46 = __error();
                strerror(*v46);
                fprintf(v45, "can't read from %s: %s\n");
                goto LABEL_20;
              }

              BOMStreamFree(v43);
LABEL_50:
              __strlcpy_chk();
              return v12;
            }

            goto LABEL_49;
          }

          uint64_t v41 = (*((uint64_t (**)(void, void))v3 + 40))(*((void *)v3 + 1), 0LL);
          if (v41 != -1)
          {
            *(_DWORD *)(v12 + 1048) = *(_DWORD *)(v12 + 1032);
            *(void *)(v12 + 1040) = v41;
            *(_BYTE *)(v12 + 1053) = 1;
            _CreateBlockTable(v12);
            uint64_t v42 = *(unsigned int *)(v12 + 1060);
            if ((_DWORD)v42)
            {
              uint64_t v40 = (uint64_t)BOMStreamWithAddress(*(void *)(v12 + 1040) + v42, *(unsigned int *)(v12 + 1064), 0);
              goto LABEL_45;
            }

uint64_t BOMStorageNewInRAM()
{
  uint64_t v0 = (char *)BOM_malloczero(0x468uLL);
  uint64_t v1 = (uint64_t)v0;
  if (v0)
  {
    *(void *)(v0 + 1028) = 0x200FFFFFFFFLL;
    *((_DWORD *)v0 + 259) = 512;
    *((_WORD *)v0 + 526) = 1;
    *((void *)v0 + 140) = BomSys_default();
    if (*(_DWORD *)(v1 + 1032) <= 0x4000u) {
      unsigned int v2 = 0x4000;
    }
    else {
      unsigned int v2 = *(_DWORD *)(v1 + 1032);
    }
    *(_DWORD *)(v1 + 1048) = v2;
    _CreateMapAddress(v1, v2);
    if (*(void *)(v1 + 1040))
    {
      *(_BYTE *)(v1 + 1053) = 1;
      _CreateBlockTable(v1);
      __strlcpy_chk();
      *(void *)(v1 + 1088) = _NewFreeList();
    }

    else
    {
      free((void *)v1);
      return 0LL;
    }
  }

  return v1;
}

uint64_t _CreateMapAddress(uint64_t a1, unsigned int a2)
{
  unint64_t v3 = (unint64_t)a2 % *MEMORY[0x1895FD590];
  if (v3) {
    int v4 = *MEMORY[0x1895FD590] - v3;
  }
  else {
    int v4 = 0;
  }
  uint64_t v5 = v4 + a2;
  uint64_t result = (*(uint64_t (**)(void, void, uint64_t, uint64_t, uint64_t, uint64_t, void))(*(void *)(a1 + 1120)
                                                                                                 + 320LL))( *(void *)(*(void *)(a1 + 1120) + 8LL),  0LL,  v5,  3LL,  4098LL,  0xFFFFFFFFLL,  0LL);
  if (result == -1) {
    uint64_t v7 = 0LL;
  }
  else {
    uint64_t v7 = result;
  }
  *(void *)(a1 + 1040) = v7;
  *(_DWORD *)(a1 + 1048) = v5;
  return result;
}

uint64_t _CreateBlockTable(uint64_t a1)
{
  unint64_t v2 = 0x4000uLL % *MEMORY[0x1895FD590];
  if (v2) {
    vm_size_t v3 = *MEMORY[0x1895FD590] - v2 + 0x4000;
  }
  else {
    vm_size_t v3 = 0x4000LL;
  }
  uint64_t result = vm_allocate(*MEMORY[0x1895FBBE0], (vm_address_t *)(a1 + 1072), v3, 1);
  if ((_DWORD)result) {
    *(void *)(a1 + 1072) = 0LL;
  }
  *(_DWORD *)(a1 + 1080) = v3;
  return result;
}

_DWORD *_NewFreeList()
{
  uint64_t v0 = (const __CFAllocator *)*MEMORY[0x189604DB0];
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable( (CFAllocatorRef)*MEMORY[0x189604DB0],  0LL,  MEMORY[0x189605240],  MEMORY[0x189605250]);
  unint64_t v2 = getenv("BOMFREELISTIMPLEMENTATION");
  if (v2)
  {
    CFStringRef v3 = CFStringCreateWithCString(v0, v2, 0x8000100u);
    CFDictionaryAddValue(Mutable, @"Implementation", v3);
    CFRelease(v3);
  }

  int v4 = _BOMFreeListAllocate(Mutable);
  CFRelease(Mutable);
  return v4;
}

uint64_t BOMStorageOpen(const char *a1, int a2)
{
  return BOMStorageOpenWithSys(a1, a2, 0LL);
}

uint64_t _ReadBlockTable(uint64_t a1, uint64_t a2)
{
  unsigned int UInt32 = BOMStreamReadUInt32(a2);
  if (!UInt32) {
    return 0LL;
  }
  unsigned int v5 = UInt32;
  if (!(UInt32 >> 29) && *(unsigned int *)(a1 + 1064) >= 8 * (unint64_t)UInt32)
  {
    _ExpandBlockTable(a1, 12 * UInt32);
    if (!*(void *)(a1 + 1072))
    {
      uint64_t v12 = (FILE *)*MEMORY[0x1895F89D0];
      int v13 = __error();
      int v14 = strerror(*v13);
      fprintf(v12, "realloc: %s\n", v14);
      return 1LL;
    }

    uint64_t v7 = 0LL;
    *(_DWORD *)(a1 + 1068) = v5;
    uint64_t v8 = 12LL * v5;
    do
    {
      *(_DWORD *)(*(void *)(a1 + 1072) + v7) = BOMStreamReadUInt32(a2);
      int v9 = BOMStreamReadUInt32(a2);
      uint64_t v10 = *(void *)(a1 + 1072) + v7;
      *(_DWORD *)(v10 + 4) = v9;
      *(_BYTE *)(v10 + 8) = (*(_DWORD *)v10 & v9) == -1;
      *(_BYTE *)(v10 + 9) = 0;
      v7 += 12LL;
    }

    while (v8 != v7);
    return 0LL;
  }

  uint64_t v6 = 1LL;
  fwrite("bad value for block table count\n", 0x20uLL, 1uLL, (FILE *)*MEMORY[0x1895F89D0]);
  return v6;
}

uint64_t _ReadFreeList(uint64_t a1, uint64_t a2)
{
  int UInt32 = BOMStreamReadUInt32(a2);
  *(void *)(a1 + 1088) = _NewFreeList();
  if (!UInt32) {
    return 0LL;
  }
  int v5 = 8 * UInt32;
  size_t v6 = 8 * UInt32;
  uint64_t v7 = BOM_malloc(v5);
  if (v7)
  {
    uint64_t v8 = v7;
    BOMStreamReadBuffer(a2, v7, v6);
    uint64_t v9 = *(void *)(a1 + 1088);
    uint64_t v10 = *(void (**)(uint64_t, void *, size_t, BOOL))(v9 + 16);
    BOOL v11 = BOMStreamGetByteOrder(a2) == 1;
    v10(v9, v8, v6, v11);
    free(v8);
    return 0LL;
  }

  return 1LL;
}

uint64_t BOMStorageOpenInRAM(uint64_t a1, unint64_t a2, char a3)
{
  if (a2 <= 0x1FF)
  {
    fwrite("stream invalid; root page is outside of address range\n", 0x36uLL, 1uLL, (FILE *)*MEMORY[0x1895F89D0]);
    return 0LL;
  }

  int v4 = a2;
  size_t v6 = BOMStreamWithAddress(a1, 0x200uLL, 0);
  if (!v6)
  {
    fprintf((FILE *)*MEMORY[0x1895F89D0], "can't read from %s\n");
    return 0LL;
  }

  uint64_t v7 = (uint64_t)v6;
  if (BOMStreamReadUInt32((uint64_t)v6) != 1112493395
    || BOMStreamReadUInt32(v7) != 1953460837)
  {
    int v14 = BOMExceptionHandlerMessage("%s is not a BOMStorage file\n", "<memory>");
    int v15 = __error();
    _BOMExceptionHandlerCall( (uint64_t)v14,  0,  "/Library/Caches/com.apple.xbs/Sources/Bom/Storage/BOMStorage.c",  490,  *v15);
LABEL_12:
    BOMStreamFree(v7);
    return 0LL;
  }

  if (BOMStreamReadUInt32(v7) != 1)
  {
    fprintf((FILE *)*MEMORY[0x1895F89D0], "%s has an unknown version: 0x%X\n");
    goto LABEL_12;
  }

  uint64_t v8 = BOM_malloc(0x468uLL);
  if (!v8)
  {
    unsigned int v17 = (FILE *)*MEMORY[0x1895F89D0];
    int v18 = __error();
    strerror(*v18);
    fprintf(v17, "malloc: %s\n");
    goto LABEL_12;
  }

  uint64_t v9 = (uint64_t)v8;
  bzero(v8, 0x468uLL);
  *(void *)(v9 + 1120) = BomSys_default();
  *(_DWORD *)(v9 + 1028) = -1;
  *(_DWORD *)(v9 + 1032) = v4;
  *(_DWORD *)(v9 + 1036) = v4;
  *(_BYTE *)(v9 + 1052) = a3;
  *(_BYTE *)(v9 + 1053) = 0;
  *(_DWORD *)(v9 + 1056) = BOMStreamReadUInt32(v7);
  *(_DWORD *)(v9 + 1060) = BOMStreamReadUInt32(v7);
  *(_DWORD *)(v9 + 1064) = BOMStreamReadUInt32(v7);
  *(_DWORD *)(v9 + 1096) = BOMStreamReadUInt32(v7);
  *(_DWORD *)(v9 + 1100) = BOMStreamReadUInt32(v7);
  BOMStreamFree(v7);
  int v10 = *(_DWORD *)(v9 + 1060);
  int v11 = *(_DWORD *)(v9 + 1064);
  BOOL v12 = __CFADD__(v11, v10);
  unsigned int v13 = v11 + v10;
  if (v12)
  {
    fprintf((FILE *)*MEMORY[0x1895F89D0], "%s: stream invalid; overflow of admin offset+size\n");
  }

  else
  {
    unsigned int v19 = *(_DWORD *)(v9 + 1032);
    if (v13 <= v19)
    {
      int v20 = *(_DWORD *)(v9 + 1096);
      int v21 = *(_DWORD *)(v9 + 1100);
      BOOL v12 = __CFADD__(v21, v20);
      unsigned int v22 = v21 + v20;
      if (v12)
      {
        fprintf((FILE *)*MEMORY[0x1895F89D0], "%s: stream invalid; overflow of toc offset+size\n");
      }

      else
      {
        if (v22 <= v19)
        {
          *(_DWORD *)(v9 + 1048) = v19;
          *(void *)(v9 + 1040) = a1;
          _CreateBlockTable(v9);
          uint64_t v23 = *(unsigned int *)(v9 + 1060);
          if ((_DWORD)v23)
          {
            size_t v24 = BOMStreamWithAddress(*(void *)(v9 + 1040) + v23, *(unsigned int *)(v9 + 1064), 0);
            if (!v24)
            {
              size_t v26 = (FILE *)*MEMORY[0x1895F89D0];
              uint64_t v27 = __error();
              strerror(*v27);
              fprintf(v26, "can't read from %s: %s\n");
              return 0LL;
            }

            uint64_t v25 = (uint64_t)v24;
            BOMStreamFree(v25);
          }

          else
          {
            *(void *)(v9 + 1088) = _NewFreeList();
          }

          __strlcpy_chk();
          return v9;
        }

        fprintf((FILE *)*MEMORY[0x1895F89D0], "%s: stream invalid; toc range is outside file\n");
      }
    }

    else
    {
      fprintf((FILE *)*MEMORY[0x1895F89D0], "%s: stream invalid; admin range is outside file\n");
    }
  }

  return 0LL;
}

BOOL BOMStorageIsStorageFile(const char *a1)
{
  return BOMStorageIsStorageFileWithSys(a1, 0LL);
}

BOOL BOMStorageIsStorageFileWithSys(const char *a1, void *a2)
{
  unint64_t v2 = a2;
  if (!a2) {
    unint64_t v2 = BomSys_default();
  }
  uint64_t v4 = (*((uint64_t (**)(void, const char *, void, uint64_t))v2 + 2))(*((void *)v2 + 1), a1, 0LL, 420LL);
  if ((_DWORD)v4 == -1)
  {
    uint64_t v9 = (FILE *)*MEMORY[0x1895F89D0];
    int v10 = __error();
    int v11 = strerror(*v10);
    fprintf(v9, "can't open %s: %s\n", a1, v11);
    return 0LL;
  }

  else
  {
    uint64_t v5 = v4;
    uint64_t v6 = BOMStreamWithFileAndSys(v4, 0LL, 0x200uLL, 0, 0LL, v2);
    if (v6)
    {
      uint64_t v7 = v6;
      BOOL v8 = BOMStreamReadUInt32(v6) == 1112493395 && BOMStreamReadUInt32(v7) == 1953460837;
      BOMStreamFree(v7);
    }

    else
    {
      fprintf((FILE *)*MEMORY[0x1895F89D0], "can't read from %s\n", a1);
      BOOL v8 = 0LL;
    }

    (*((void (**)(void, uint64_t))v2 + 4))(*((void *)v2 + 1), v5);
  }

  return v8;
}

uint64_t BOMStorageFree(_DWORD *a1)
{
  if (!a1) {
    return 1LL;
  }
  uint64_t v3 = *((void *)a1 + 134);
  if (v3 && MEMORY[0x186E385F0](*MEMORY[0x1895FBBE0], v3, a1[270]))
  {
    uint64_t v4 = __error();
    _BOMExceptionHandlerCall( (uint64_t)"vm_deallocate failed",  1,  "/Library/Caches/com.apple.xbs/Sources/Bom/Storage/BOMStorage.c",  1550,  *v4);
  }

  uint64_t v5 = (void (**)(void))*((void *)a1 + 136);
  if (v5)
  {
    v5[4](*((void *)a1 + 136));
    free(v5);
  }

  if (*((void *)a1 + 130))
  {
    if (*((_BYTE *)a1 + 1053))
    {
      int v6 = *((unsigned __int8 *)a1 + 1052);
      int v7 = (*(uint64_t (**)(void))(*((void *)a1 + 140) + 328LL))(*(void *)(*((void *)a1 + 140) + 8LL));
      if (v6)
      {
        if (v7 == -1)
        {
          BOOL v8 = __error();
          _BOMExceptionHandlerCall( (uint64_t)"munmap failed",  1,  "/Library/Caches/com.apple.xbs/Sources/Bom/Storage/BOMStorage.c",  1417,  *v8);
        }
      }
    }
  }

  if (a1[257] != -1) {
    (*(void (**)(void))(*((void *)a1 + 140) + 32LL))(*(void *)(*((void *)a1 + 140) + 8LL));
  }
  free(a1);
  return 0LL;
}

uint64_t BOMStorageCommit(uint64_t a1)
{
  if (!a1) {
    return 1LL;
  }
  if (!*(_DWORD *)(a1 + 1116)) {
    return 0LL;
  }
  if (*(_DWORD *)(a1 + 1028) == -1)
  {
    BOOL v2 = 0LL;
    *(_DWORD *)(a1 + 1036) = *(_DWORD *)(a1 + 1032);
    goto LABEL_8;
  }

  _FlushWriteCache(a1);
  uint64_t v4 = *(void *)(a1 + 1088);
  int v5 = 8 * (*(_DWORD *)(a1 + 1068) + *(_DWORD *)(v4 + 8));
  unint64_t v6 = (v5 + 24);
  if (v5 == -24)
  {
    unsigned int v7 = 0;
  }

  else
  {
    unsigned int v7 = (*(uint64_t (**)(uint64_t, unint64_t))(v4 + 48))(v4, v6);
    if (!v7) {
      unsigned int v7 = *(_DWORD *)(a1 + 1032);
    }
  }

  int v8 = *(_DWORD *)(a1 + 1060);
  int v9 = *(_DWORD *)(a1 + 1064);
  *(_DWORD *)(a1 + 1060) = v7;
  *(_DWORD *)(a1 + 1064) = v6;
  if (v8 && v9) {
    (*(void (**)(void))(*(void *)(a1 + 1088) + 40LL))();
  }
  uint64_t v10 = v7;
  BOOL v2 = 1LL;
  uint64_t v11 = BOMStreamWithFile(*(_DWORD *)(a1 + 1028), v10, v6, 1, 0LL);
  if (v11)
  {
    uint64_t v12 = v11;
    uint64_t v13 = *(unsigned int *)(a1 + 1068);
    BOMStreamWriteUInt32(v11, *(_DWORD *)(a1 + 1068));
    if ((_DWORD)v13)
    {
      uint64_t v14 = 0LL;
      uint64_t v15 = 12 * v13;
      do
      {
        BOMStreamWriteUInt32(v12, *(_DWORD *)(*(void *)(a1 + 1072) + v14));
        BOMStreamWriteUInt32(v12, *(_DWORD *)(*(void *)(a1 + 1072) + v14 + 4));
        v14 += 12LL;
      }

      while (v15 != v14);
    }

    BOMStreamWriteUInt32(v12, *(_DWORD *)(*(void *)(a1 + 1088) + 8LL));
    size_t __len = 0LL;
    uint64_t v16 = *(void *)(a1 + 1088);
    unsigned int v17 = *(uint64_t (**)(uint64_t, BOOL, size_t *))(v16 + 24);
    BOOL v18 = BOMStreamGetByteOrder(v12) == 1;
    unsigned int v19 = (void *)v17(v16, v18, &__len);
    BOMStreamWriteBuffer(v12, v19, __len);
    free(v19);
    int v20 = BOMStreamFree(v12);
    *(_DWORD *)(a1 + 1036) = *(_DWORD *)(a1 + 1032);
    BOOL v2 = (_WriteRootPage(a1) | v20) != 0;
LABEL_8:
    *(_DWORD *)(a1 + 1116) = 0;
  }

  return v2;
}

uint64_t BOMStorageGetSys(uint64_t result)
{
  if (result) {
    return *(void *)(result + 1120);
  }
  return result;
}

uint64_t BOMStorageIsOpenForWriting(uint64_t result)
{
  if (result) {
    return *(unsigned __int8 *)(result + 1052);
  }
  return result;
}

uint64_t BOMStorageNewBlock(uint64_t a1)
{
  if (!a1 || !*(_BYTE *)(a1 + 1052)) {
    return 0LL;
  }
  uint64_t v2 = (*(_DWORD *)(a1 + 1056) + 1);
  *(_DWORD *)(a1 + 1056) = v2;
  if (v2 >= *(_DWORD *)(a1 + 1068))
  {
    unsigned int v3 = *(_DWORD *)(a1 + 1080);
    if (v3 >= 0x100000) {
      unsigned int v4 = v3 + 0x100000;
    }
    else {
      unsigned int v4 = 2 * v3;
    }
    _ExpandBlockTable(a1, v4);
    *(_DWORD *)(a1 + 1068) = *(_DWORD *)(a1 + 1080) / 0xCu;
  }

  *(_BYTE *)(*(void *)(a1 + 1072) + 12LL * v2 + 8) = 0;
  return v2;
}

uint64_t _ExpandBlockTable(uint64_t result, unsigned int a2)
{
  uint64_t v2 = result;
  vm_size_t v3 = *(unsigned int *)(result + 1080);
  if (v3 >= a2)
  {
    if (*(void *)(result + 1072)) {
      return result;
    }
    goto LABEL_14;
  }

  unint64_t v4 = (unint64_t)a2 % *MEMORY[0x1895FD590];
  if (v4) {
    int v5 = *MEMORY[0x1895FD590] - v4;
  }
  else {
    int v5 = 0;
  }
  vm_size_t v6 = v5 + a2;
  unsigned int v7 = (vm_map_t *)MEMORY[0x1895FBBE0];
  if (vm_allocate(*MEMORY[0x1895FBBE0], &address, v6, 1))
  {
    int v8 = __error();
    _BOMExceptionHandlerCall( (uint64_t)"vm_allocate failed",  1,  "/Library/Caches/com.apple.xbs/Sources/Bom/Storage/BOMStorage.c",  1570,  *v8);
  }

  if (vm_copy(*v7, *(void *)(v2 + 1072), v3, address))
  {
    int v9 = __error();
    _BOMExceptionHandlerCall( (uint64_t)"vm_copy failed",  1,  "/Library/Caches/com.apple.xbs/Sources/Bom/Storage/BOMStorage.c",  1572,  *v9);
  }

  uint64_t result = MEMORY[0x186E385F0](*v7, *(void *)(v2 + 1072), v3);
  if ((_DWORD)result)
  {
    uint64_t v10 = __error();
    uint64_t result = _BOMExceptionHandlerCall( (uint64_t)"vm_deallocate failed",  1,  "/Library/Caches/com.apple.xbs/Sources/Bom/Storage/BOMStorage.c",  1575,  *v10);
  }

  vm_address_t v11 = address;
  *(void *)(v2 + 1072) = address;
  *(_DWORD *)(v2 + 1080) = v6;
  if (!v11)
  {
LABEL_14:
    uint64_t v12 = __error();
    return _BOMExceptionHandlerCall( (uint64_t)"Out of memory.",  1,  "/Library/Caches/com.apple.xbs/Sources/Bom/Storage/BOMStorage.c",  1591,  *v12);
  }

  return result;
}

uint64_t BOMStorageNewNamedBlock(uint64_t a1, const char *a2)
{
  uint64_t v26 = *MEMORY[0x1895F89C0];
  if (!*(_BYTE *)(a1 + 1052)) {
    return 0LL;
  }
  if (_tocGet(a1, a2))
  {
    fprintf((FILE *)*MEMORY[0x1895F89D0], "name %s already exists!\n", a2);
    return 0LL;
  }

  uint64_t v4 = BOMStorageNewBlock(a1);
  unsigned int v6 = strlen(a2);
  if ((v6 & 0xFFFFFF00) != 0)
  {
    fprintf((FILE *)*MEMORY[0x1895F89D0], "name '%s' is > %d\n", a2, 255);
  }

  else
  {
    unsigned int v7 = v6;
    if (*(_DWORD *)(a1 + 1096)) {
      int v8 = *(_DWORD *)(a1 + 1100);
    }
    else {
      int v8 = 4;
    }
    unsigned int v9 = v6 + v8;
    unsigned int v10 = v9 + 5;
    if (v9 == -5)
    {
      unsigned int v11 = 0;
    }

    else
    {
      unsigned int v11 = (*(uint64_t (**)(void))(*(void *)(a1 + 1088) + 48LL))();
      if (!v11) {
        unsigned int v11 = *(_DWORD *)(a1 + 1032);
      }
    }

    _ExpandMapAddress(a1, v11 + v10);
    uint64_t v12 = *(unsigned int *)(a1 + 1096);
    if ((_DWORD)v12)
    {
      uint64_t v13 = BOMStreamWithAddress(*(void *)(a1 + 1040) + v12, *(unsigned int *)(a1 + 1100), 0);
      if (!v13) {
        return v4;
      }
      uint64_t v14 = (uint64_t)v13;
      int UInt32 = BOMStreamReadUInt32((uint64_t)v13);
    }

    else
    {
      uint64_t v14 = 0LL;
      int UInt32 = 0;
    }

    uint64_t v16 = BOMStreamWithAddress(*(void *)(a1 + 1040) + v11, v10, 1);
    if (v16)
    {
      uint64_t v17 = (uint64_t)v16;
      size_t v18 = v7;
      BOMStreamWriteUInt32((uint64_t)v16, UInt32 + 1);
      if (v14)
      {
        unsigned int v23 = v11;
        for (unsigned int i = v10; UInt32; --UInt32)
        {
          unsigned int v19 = BOMStreamReadUInt32(v14);
          unsigned int UInt8 = BOMStreamReadUInt8(v14);
          char v21 = UInt8;
          size_t v22 = UInt8;
          BOMStreamReadBuffer(v14, __dst, UInt8);
          BOMStreamWriteUInt32(v17, v19);
          BOMStreamWriteUInt8(v17, v21);
          BOMStreamWriteBuffer(v17, __dst, v22);
        }

        BOMStreamFree(v14);
        if (*(_DWORD *)(a1 + 1096) && *(_DWORD *)(a1 + 1100)) {
          (*(void (**)(void))(*(void *)(a1 + 1088) + 40LL))();
        }
        unsigned int v10 = i;
        unsigned int v11 = v23;
        size_t v18 = v7;
      }

      BOMStreamWriteUInt32(v17, v4);
      BOMStreamWriteUInt8(v17, v7);
      BOMStreamWriteBuffer(v17, a2, v18);
      BOMStreamFree(v17);
      *(_DWORD *)(a1 + 1096) = v11;
      *(_DWORD *)(a1 + 1100) = v10;
      _AdjustFileSize(a1, v11, v10);
      if (*(_DWORD *)(a1 + 1028) != -1) {
        _AddToWriteCache(a1, v11, v10);
      }
      *(_DWORD *)(a1 + 1116) = 1;
    }
  }

  return v4;
}

uint64_t _tocGet(uint64_t a1, const char *a2)
{
  uint64_t v13 = *MEMORY[0x1895F89C0];
  if (!a1) {
    return 0LL;
  }
  uint64_t v2 = *(unsigned int *)(a1 + 1096);
  if (!(_DWORD)v2) {
    return 0LL;
  }
  unint64_t v4 = *(unsigned int *)(a1 + 1100);
  if (!(_DWORD)v4) {
    return 0LL;
  }
  int v5 = BOMStreamWithAddress(*(void *)(a1 + 1040) + v2, v4, 0);
  if (!v5) {
    return 0LL;
  }
  uint64_t v6 = (uint64_t)v5;
  int UInt32 = BOMStreamReadUInt32((uint64_t)v5);
  if (UInt32)
  {
    int v8 = UInt32;
    while (1)
    {
      uint64_t v9 = BOMStreamReadUInt32(v6);
      unsigned int UInt8 = BOMStreamReadUInt8(v6);
      BOMStreamReadBuffer(v6, __s2, UInt8);
      __s2[UInt8] = 0;
      if (!strcmp(a2, __s2)) {
        break;
      }
      if (!--v8) {
        goto LABEL_9;
      }
    }
  }

  else
  {
LABEL_9:
    uint64_t v9 = 0LL;
  }

  BOMStreamFree(v6);
  return v9;
}

uint64_t BOMStorageSizeOfBlock(uint64_t a1, unsigned int a2)
{
  uint64_t result = 0LL;
  if (a1 && a2)
  {
    if (*(_DWORD *)(a1 + 1056) < a2) {
      return 0LL;
    }
    if (*(_DWORD *)(a1 + 1068) <= a2) {
      return 0LL;
    }
    uint64_t v4 = *(void *)(a1 + 1072);
    if (*(_BYTE *)(v4 + 12LL * a2 + 8) == 1) {
      return 0LL;
    }
    else {
      return *(unsigned int *)(v4 + 12LL * a2 + 4);
    }
  }

  return result;
}

double BOMStorageFreeBlock(uint64_t a1, unsigned int a2)
{
  if (a1)
  {
    if (a2)
    {
      if (*(_DWORD *)(a1 + 1056) >= a2)
      {
        uint64_t v3 = *(void *)(a1 + 1072);
        if (!*(_BYTE *)(v3 + 12LL * a2 + 8))
        {
          int v5 = (_DWORD *)(v3 + 12LL * a2);
          if (*v5) {
            BOOL v6 = v5[1] == 0;
          }
          else {
            BOOL v6 = 1;
          }
          if (!v6)
          {
            (*(void (**)(void))(*(void *)(a1 + 1088) + 40LL))();
            uint64_t v3 = *(void *)(a1 + 1072);
          }

          uint64_t v7 = v3 + 12LL * a2;
          double result = NAN;
          *(void *)uint64_t v7 = -1LL;
          *(_BYTE *)(v7 + 8) = 1;
        }
      }
    }
  }

  return result;
}

void BOMStorageFreeNamedBlock(uint64_t a1, const char *a2)
{
  uint64_t v17 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    if (a2)
    {
      unsigned int v4 = _tocGet(a1, a2);
      if (v4)
      {
        BOMStorageFreeBlock(a1, v4);
        if (*(_DWORD *)(a1 + 1096))
        {
          int v5 = strlen(a2);
          int v6 = *(_DWORD *)(a1 + 1100);
          if (v6)
          {
            unsigned int v7 = (*(uint64_t (**)(void))(*(void *)(a1 + 1088) + 48LL))();
            if (!v7) {
              unsigned int v7 = *(_DWORD *)(a1 + 1032);
            }
          }

          else
          {
            unsigned int v7 = 0;
          }

          unint64_t v8 = (v6 - v5 - 5);
          _ExpandMapAddress(a1, v7 + v8);
          uint64_t v9 = BOMStreamWithAddress( *(void *)(a1 + 1040) + *(unsigned int *)(a1 + 1096),  *(unsigned int *)(a1 + 1100),  0);
          if (v9)
          {
            uint64_t v10 = (uint64_t)v9;
            unsigned int v11 = BOMStreamWithAddress(*(void *)(a1 + 1040) + v7, v8, 1);
            if (v11)
            {
              uint64_t v12 = (uint64_t)v11;
              int UInt32 = BOMStreamReadUInt32(v10);
              BOMStreamWriteUInt32(v12, UInt32 - 1);
              for (; UInt32; --UInt32)
              {
                unsigned int v14 = BOMStreamReadUInt32(v10);
                size_t UInt8 = BOMStreamReadUInt8(v10);
                BOMStreamReadBuffer(v10, __s1, UInt8);
                __s1[UInt8] = 0;
                if (strcmp(__s1, a2))
                {
                  BOMStreamWriteUInt32(v12, v14);
                  BOMStreamWriteUInt8(v12, UInt8);
                  BOMStreamWriteBuffer(v12, __s1, UInt8);
                }
              }

              BOMStreamFree(v10);
              BOMStreamFree(v12);
              if (*(_DWORD *)(a1 + 1096) && *(_DWORD *)(a1 + 1100)) {
                (*(void (**)(void))(*(void *)(a1 + 1088) + 40LL))();
              }
              *(_DWORD *)(a1 + 1096) = v7;
              *(_DWORD *)(a1 + 1100) = v8;
              _AdjustFileSize(a1, v7, v8);
              if (*(_DWORD *)(a1 + 1028) != -1) {
                _AddToWriteCache(a1, v7, v8);
              }
              *(_DWORD *)(a1 + 1116) = 1;
            }
          }
        }
      }
    }
  }

uint64_t BOMStorageCount(uint64_t result)
{
  if (result) {
    return *(unsigned int *)(result + 1056);
  }
  return result;
}

uint64_t BOMStorageCopyToBlock(uint64_t a1, unsigned int a2, const void *a3, size_t a4)
{
  if (a1 && a2 && *(_DWORD *)(a1 + 1056) >= a2 && *(_BYTE *)(a1 + 1052)) {
    return BOMStorageCopyToBlockRange(a1, a2, a3, a4, 0LL, *(unsigned int *)(*(void *)(a1 + 1072) + 12LL * a2 + 4));
  }
  else {
    return 1LL;
  }
}

uint64_t BOMStorageCopyToBlockRange( uint64_t a1, unsigned int a2, const void *a3, size_t a4, unint64_t a5, uint64_t a6)
{
  uint64_t result = 1LL;
  if (!a1 || !a2 || *(_DWORD *)(a1 + 1056) < a2 || !*(_BYTE *)(a1 + 1052)) {
    return result;
  }
  uint64_t v10 = (unsigned int *)(*(void *)(a1 + 1072) + 12LL * a2);
  unint64_t v11 = v10[1];
  int v12 = a6 + a5;
  if (a6 + a5 > v11)
  {
    int v13 = *__error();
    unsigned int v14 = "BOMStorageCopyToBlockRange: length extends beyond block size";
    int v15 = 893;
LABEL_7:
    _BOMExceptionHandlerCall( (uint64_t)v14,  0,  "/Library/Caches/com.apple.xbs/Sources/Bom/Storage/BOMStorage.c",  v15,  v13);
    return 1LL;
  }

  uint64_t v18 = *v10;
  if (v11 <= a5) {
    unsigned int v19 = a5;
  }
  else {
    unsigned int v19 = v10[1];
  }
  unsigned int v20 = a4 - a6 + v19;
  if ((_DWORD)v11 == v20 && v18 >= *(_DWORD *)(a1 + 1036))
  {
    unsigned int v22 = v18;
  }

  else
  {
    if ((_DWORD)v18) {
      BOOL v21 = (_DWORD)v11 == 0;
    }
    else {
      BOOL v21 = 1;
    }
    if (!v21) {
      (*(void (**)(void))(*(void *)(a1 + 1088) + 40LL))();
    }
    if (v20)
    {
      unsigned int v22 = (*(uint64_t (**)(void))(*(void *)(a1 + 1088) + 48LL))();
      if (!v22) {
        unsigned int v22 = *(_DWORD *)(a1 + 1032);
      }
    }

    else
    {
      unsigned int v22 = 0;
    }

    unsigned int v23 = (unsigned int *)(*(void *)(a1 + 1072) + 12LL * a2);
    unsigned int *v23 = v22;
    v23[1] = v20;
  }

  if (v20) {
    BOOL v24 = v22 == 0;
  }
  else {
    BOOL v24 = 1;
  }
  if (v24) {
    return 0LL;
  }
  unsigned int v36 = v22 + v20;
  _ExpandMapAddress(a1, v22 + v20);
  if (a5)
  {
    memmove((void *)(*(void *)(a1 + 1040) + v22), (const void *)(*(void *)(a1 + 1040) + v18), a5);
    unsigned int v25 = a5;
  }

  else
  {
    unsigned int v25 = 0;
  }

  if (v11 <= a5 || v22 < v18 || v22 >= (int)v11 + (int)v18)
  {
    if (a4)
    {
      uint64_t v28 = a3;
      unsigned int v29 = v25;
      memmove((void *)(*(void *)(a1 + 1040) + v22 + v25), v28, a4);
      unsigned int v25 = v29 + a4;
    }

    if (v20 > v25)
    {
      memmove( (void *)(*(void *)(a1 + 1040) + v22 + v25),  (const void *)(*(void *)(a1 + 1040) + a5 + a6 + v18),  v20 - v25);
      *(_BYTE *)(*(void *)(a1 + 1072) + 12LL * a2 + 9) = 1;
      goto LABEL_51;
    }
  }

  else
  {
    size_t v30 = (v11 - v12);
    if ((_DWORD)v30)
    {
      uint64_t v31 = *(void *)(a1 + 1040);
      int v32 = (const void *)(v31 + a5 + a6 + v18);
      unsigned int v33 = v25;
      memmove((void *)(v31 + v22 + a5 + a4), v32, v30);
      unsigned int v25 = v33;
    }

    if (a4)
    {
      unsigned int v34 = v25;
      memmove((void *)(*(void *)(a1 + 1040) + v22 + v25), a3, a4);
      unsigned int v25 = v34 + a4;
    }

    v25 += v30;
  }

  *(_BYTE *)(*(void *)(a1 + 1072) + 12LL * a2 + 9) = 1;
  if (v25 != v20)
  {
    int v13 = *__error();
    unsigned int v14 = "BOMStorageCopyToBlockRange: internal consistency error";
    int v15 = 997;
    goto LABEL_7;
  }

uint64_t _ExpandMapAddress(uint64_t result, unsigned int a2)
{
  uint64_t v2 = result;
  unsigned int v3 = *(_DWORD *)(result + 1048);
  if (v3 >= a2)
  {
    if (!*(void *)(result + 1040)) {
      goto LABEL_15;
    }
  }

  else
  {
    if (v3 >= 0x100000) {
      LODWORD(v4) = v3 + 0x100000;
    }
    else {
      LODWORD(v4) = 2 * v3;
    }
    else {
      unint64_t v4 = v4;
    }
    unint64_t v5 = v4 % *MEMORY[0x1895FD590];
    int v6 = *MEMORY[0x1895FD590] - v5;
    if (!v5) {
      int v6 = 0;
    }
    uint64_t v7 = (v6 + v4);
    vm_address_t v8 = (*(uint64_t (**)(void, void, uint64_t, uint64_t, uint64_t, uint64_t, void))(*(void *)(result + 1120)
                                                                                               + 320LL))( *(void *)(*(void *)(result + 1120) + 8LL),  0LL,  v7,  3LL,  4098LL,  0xFFFFFFFFLL,  0LL);
    if (v8 == -1LL)
    {
      int v11 = *__error();
      int v12 = "mmap failed";
      int v13 = 1443;
      return _BOMExceptionHandlerCall( (uint64_t)v12,  1,  "/Library/Caches/com.apple.xbs/Sources/Bom/Storage/BOMStorage.c",  v13,  v11);
    }

    vm_address_t v9 = v8;
    if (vm_copy(*MEMORY[0x1895FBBE0], *(void *)(v2 + 1040), *(unsigned int *)(v2 + 1048), v8))
    {
      uint64_t v10 = __error();
      _BOMExceptionHandlerCall( (uint64_t)"vm_copy failed",  1,  "/Library/Caches/com.apple.xbs/Sources/Bom/Storage/BOMStorage.c",  1447,  *v10);
    }

    uint64_t result = (*(uint64_t (**)(void, void, void))(*(void *)(v2 + 1120) + 328LL))( *(void *)(*(void *)(v2 + 1120) + 8LL),  *(void *)(v2 + 1040),  *(unsigned int *)(v2 + 1048));
    if ((_DWORD)result == -1)
    {
      int v11 = *__error();
      int v12 = "munmap failed";
      int v13 = 1449;
      return _BOMExceptionHandlerCall( (uint64_t)v12,  1,  "/Library/Caches/com.apple.xbs/Sources/Bom/Storage/BOMStorage.c",  v13,  v11);
    }

    *(void *)(v2 + 1040) = v9;
    *(_DWORD *)(v2 + 1048) = v7;
    if (!v9)
    {
LABEL_15:
      int v11 = *__error();
      int v12 = "Out of memory.";
      int v13 = 1460;
      return _BOMExceptionHandlerCall( (uint64_t)v12,  1,  "/Library/Caches/com.apple.xbs/Sources/Bom/Storage/BOMStorage.c",  v13,  v11);
    }
  }

  return result;
}

void _AddToWriteCache(uint64_t a1, unsigned int a2, int a3)
{
  if (!a2 || !a3) {
    return;
  }
  unint64_t v5 = *(_DWORD **)(a1 + 1104);
  if (v5)
  {
    unsigned int v6 = v5[2];
    if (v6 <= a2)
    {
      while (1)
      {
        uint64_t v7 = v5;
        unint64_t v5 = *(_DWORD **)v5;
        if (!v5) {
          break;
        }
        unsigned int v8 = v5[2];
        if (v8 >= a2)
        {
          int v10 = v7[3];
          if (v10 + v7[2] != a2) {
            goto LABEL_6;
          }
          v7[3] = v10 + a3;
          if (a3 + a2 == v5[2])
          {
            v7[3] = v5[3] + v10 + a3;
            *(void *)uint64_t v7 = *(void *)v5;
            free(v5);
            int v11 = *(_DWORD *)(a1 + 1112) - 1;
            goto LABEL_23;
          }

          goto LABEL_24;
        }
      }

      int v13 = v7[3];
      if (v13 + v7[2] == a2)
      {
        v7[3] = v13 + a3;
        goto LABEL_24;
      }

      int v12 = _newFreeListEntry(a2, a3);
      if (v12)
      {
        *(void *)int v12 = 0LL;
        goto LABEL_21;
      }
    }

    else
    {
      uint64_t v7 = 0LL;
      unsigned int v8 = v5[2];
LABEL_6:
      if (a3 + a2 == v8)
      {
        int v9 = v5[3] + a3;
        v5[2] = a2;
        v5[3] = v9;
        goto LABEL_24;
      }

      int v12 = _newFreeListEntry(a2, a3);
      if (v12)
      {
        *(void *)int v12 = v5;
        if (v6 <= a2) {
LABEL_21:
        }
          *(void *)uint64_t v7 = v12;
        else {
          *(void *)(a1 + 1104) = v12;
        }
        int v11 = *(_DWORD *)(a1 + 1112) + 1;
        goto LABEL_23;
      }
    }

    uint64_t v18 = __error();
    _BOMExceptionHandlerCall( (uint64_t)"Out of memory.",  1,  "/Library/Caches/com.apple.xbs/Sources/Bom/Storage/BOMStorage.c",  2068,  *v18);
    return;
  }

  *(void *)(a1 + 1104) = _newFreeListEntry(a2, a3);
  int v11 = 1;
LABEL_23:
  *(_DWORD *)(a1 + 1112) = v11;
LABEL_24:
  if (*(_DWORD *)(a1 + 1112) < 0x10u)
  {
    unsigned int v14 = *(_DWORD **)(a1 + 1104);
    if (v14)
    {
      int v15 = 0LL;
      do
      {
        unsigned int v16 = v14[3];
        if (v16 < 0xFFFF)
        {
          uint64_t v17 = *(_DWORD **)v14;
          int v15 = v14;
        }

        else
        {
          uint64_t v17 = *(_DWORD **)v14;
          if (v15)
          {
            *int v15 = v17;
            uint64_t v17 = *(_DWORD **)v14;
          }

          else
          {
            *(void *)(a1 + 1104) = v17;
          }

          _WriteAddress(a1, v14[2], v16);
          free(v14);
          --*(_DWORD *)(a1 + 1112);
        }

        unsigned int v14 = v17;
      }

      while (v17);
    }
  }

  else
  {
    _FlushWriteCache(a1);
  }

uint64_t _AdjustFileSize(uint64_t a1, int a2, int a3)
{
  if (a2)
  {
    if ((a3 + a2) <= *(_DWORD *)(a1 + 1032))
    {
      return 0LL;
    }

    else
    {
      uint64_t result = 0LL;
      *(_DWORD *)(a1 + 1032) = a3 + a2;
    }
  }

  else
  {
    uint64_t v5 = (*(uint64_t (**)(void, void, void, uint64_t))(*(void *)(a1 + 1120) + 64LL))( *(void *)(*(void *)(a1 + 1120) + 8LL),  *(unsigned int *)(a1 + 1028),  0LL,  2LL);
    if (v5 == -1)
    {
      uint64_t v7 = (FILE *)*MEMORY[0x1895F89D0];
      unsigned int v8 = __error();
      int v9 = strerror(*v8);
      fprintf(v7, "lseek: %s\n", v9);
      return 1LL;
    }

    else
    {
      int v6 = v5;
      uint64_t result = 0LL;
      *(_DWORD *)(a1 + 1032) = v6;
    }
  }

  return result;
}

uint64_t BOMStorageCopyFromBlock(uint64_t a1, unsigned int a2, void *a3)
{
  if (a1 && a2)
  {
    if (*(_DWORD *)(a1 + 1056) >= a2) {
      return BOMStorageCopyFromBlockRange(a1, a2, 0LL, *(unsigned int *)(*(void *)(a1 + 1072) + 12LL * a2 + 4), a3);
    }
    int v4 = *__error();
    uint64_t v5 = "BOMStorageCopyFromBlock: bid > storage->blocks";
    int v6 = 1047;
    goto LABEL_11;
  }

  if (a1)
  {
    if (!a2) {
      goto LABEL_10;
    }
  }

  else
  {
    unsigned int v8 = __error();
    _BOMExceptionHandlerCall( (uint64_t)"BOMStorageCopyFromBlock: !storage",  0,  "/Library/Caches/com.apple.xbs/Sources/Bom/Storage/BOMStorage.c",  1035,  *v8);
    if (!a2)
    {
LABEL_10:
      int v4 = *__error();
      uint64_t v5 = "BOMStorageCopyFromBlock: !bid";
      int v6 = 1039;
LABEL_11:
      _BOMExceptionHandlerCall((uint64_t)v5, 0, "/Library/Caches/com.apple.xbs/Sources/Bom/Storage/BOMStorage.c", v6, v4);
    }
  }

  return 1LL;
}

uint64_t BOMStorageCopyFromBlockRange(uint64_t a1, unsigned int a2, uint64_t a3, size_t __len, void *__dst)
{
  if (!a1 || !a2 || !__dst)
  {
    if (a1)
    {
      if (a2) {
        goto LABEL_8;
      }
    }

    else
    {
      int v12 = __error();
      _BOMExceptionHandlerCall( (uint64_t)"BOMStorageCopyFromBlockRange: !storage",  0,  "/Library/Caches/com.apple.xbs/Sources/Bom/Storage/BOMStorage.c",  1066,  *v12);
      if (a2)
      {
LABEL_8:
        if (!__dst) {
          goto LABEL_14;
        }
        return 1LL;
      }
    }

    int v13 = __error();
    _BOMExceptionHandlerCall( (uint64_t)"BOMStorageCopyFromBlockRange: !bid",  0,  "/Library/Caches/com.apple.xbs/Sources/Bom/Storage/BOMStorage.c",  1070,  *v13);
    if (!__dst)
    {
LABEL_14:
      int v8 = *__error();
      int v9 = "BOMStorageCopyFromBlockRange: !data";
      int v10 = 1074;
      goto LABEL_15;
    }

    return 1LL;
  }

  if (*(_DWORD *)(a1 + 1056) < a2)
  {
    int v8 = *__error();
    int v9 = "BOMStorageCopyRangeFromBlockRange: bad block (bid > storage->blocks)";
    int v10 = 1081;
LABEL_15:
    _BOMExceptionHandlerCall((uint64_t)v9, 0, "/Library/Caches/com.apple.xbs/Sources/Bom/Storage/BOMStorage.c", v10, v8);
    return 1LL;
  }

  uint64_t v11 = *(void *)(a1 + 1072);
  if (*(_BYTE *)(v11 + 12LL * a2 + 8))
  {
    int v8 = *__error();
    int v9 = "BOMStorageCopyRangeFromBlockRange: reading from free block";
    int v10 = 1087;
    goto LABEL_15;
  }

  uint64_t v17 = (unsigned int *)(v11 + 12LL * a2);
  uint64_t v19 = *v17;
  unint64_t v18 = v17[1];
  if ((v18 + v19) >> 32)
  {
    int v8 = *__error();
    int v9 = "BOMStorageCopyRangeFromBlockRange: 32-bit overflow with block address+size";
    int v10 = 1098;
    goto LABEL_15;
  }

  if (v18 + v19 > *(unsigned int *)(a1 + 1032))
  {
    int v8 = *__error();
    int v9 = "BOMStorageCopyRangeFromBlockRange: block extends past end of storage";
    int v10 = 1103;
    goto LABEL_15;
  }

  if (__len + a3 > v18)
  {
    int v8 = *__error();
    int v9 = "BOMStorageCopyRangeFromBlockRange: length extends beyond block size";
    int v10 = 1110;
    goto LABEL_15;
  }

  if ((_DWORD)v18)
  {
    if (!(_DWORD)v19)
    {
      int v8 = *__error();
      int v9 = "BOMStorageCopyRangeFromBlockRange: bad block address";
      int v10 = 1123;
      goto LABEL_15;
    }

    if (!*(_BYTE *)(v11 + 12LL * a2 + 9))
    {
      if (*(_BYTE *)(a1 + 1052))
      {
        int v21 = *(_DWORD *)(a1 + 1028);
        if (v21 != -1)
        {
          uint64_t v22 = BOMStreamWithFile(v21, v19, v18, 0, (char *)(*(void *)(a1 + 1040) + v19));
          if (!v22)
          {
            int v8 = *__error();
            int v9 = "BOMStorageCopyRangeFromBlockRange: !stream";
            int v10 = 1147;
            goto LABEL_15;
          }

          BOMStreamFree(v22);
          *(_BYTE *)(*(void *)(a1 + 1072) + 12LL * a2 + 9) = 1;
        }
      }
    }

    memmove(__dst, (const void *)(*(void *)(a1 + 1040) + a3 + v19), __len);
  }

  return 0LL;
}

void _FlushWriteCache(uint64_t a1)
{
  for (unsigned int i = *(_DWORD **)(a1 + 1104); i; unsigned int i = *(_DWORD **)(a1 + 1104))
  {
    *(void *)(a1 + 1104) = *(void *)i;
    _WriteAddress(a1, i[2], i[3]);
    free(i);
  }

  *(_DWORD *)(a1 + 1112) = 0;
}

uint64_t BOMStorageCompact(uint64_t a1)
{
  uint64_t v25 = *MEMORY[0x1895F89C0];
  if (!a1 || !*(_BYTE *)(a1 + 1052) || *(_DWORD *)(a1 + 1028) == -1) {
    return 1LL;
  }
  uint64_t v2 = *(void *)(a1 + 1120);
  BOMStorageCommit(a1);
  __strlcpy_chk();
  __strlcpy_chk();
  unsigned int v3 = strrchr(__s, 47);
  if (v3) {
    char *v3 = 0;
  }
  else {
    __strlcpy_chk();
  }
  __strlcat_chk();
  if (!(*(uint64_t (**)(void, char *))(v2 + 336))(*(void *)(v2 + 8), __s))
  {
    uint64_t v13 = 1LL;
    fwrite("can't get temp file.\n", 0x15uLL, 1uLL, (FILE *)*MEMORY[0x1895F89D0]);
    return v13;
  }

  uint64_t v5 = BOMStorageNewWithOptionsAndSys(__s, v4, (uint64_t (**)(void, const char *, uint64_t, uint64_t))v2);
  if (!v5) {
    return 1LL;
  }
  uint64_t v6 = v5;
  if (*(_DWORD *)(a1 + 1056))
  {
    unsigned int v7 = 1;
    while (v7 == BOMStorageNewBlock(v6))
    {
      uint64_t v8 = *(void *)(a1 + 1072);
      if (*(_BYTE *)(v8 + 12LL * v7 + 8))
      {
        BOMStorageFreeBlock(v6, v7);
      }

      else
      {
        int v9 = BOM_malloc(*(unsigned int *)(v8 + 12LL * v7 + 4));
        BOMStorageCopyFromBlock(a1, v7, v9);
        BOMStorageCopyToBlock(v6, v7, v9, *(unsigned int *)(*(void *)(a1 + 1072) + 12LL * v7 + 4));
        free(v9);
      }

      if (++v7 > *(_DWORD *)(a1 + 1056)) {
        goto LABEL_16;
      }
    }

    fprintf((FILE *)*MEMORY[0x1895F89D0], "unable to reserve block %d.\n");
    return 1LL;
  }

uint64_t BOMStorageDumpFreeList(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 1088) + 64LL))();
}

void BOMStorageFindActualFreeSpace(uint64_t a1)
{
  int v9 = _newFreeListEntry(0, *(_DWORD *)(a1 + 1032));
  unsigned int v2 = *(_DWORD *)(a1 + 1056);
  if (v2)
  {
    unsigned int v3 = 1;
    do
    {
      uint64_t v4 = *(void *)(a1 + 1072);
      unsigned int v5 = v3;
      if (!*(_BYTE *)(v4 + 12LL * v3 + 8))
      {
        _ClearAddress(&v9, *(_DWORD *)(v4 + 12LL * v3), *(_DWORD *)(v4 + 12LL * v3 + 4));
        unsigned int v2 = *(_DWORD *)(a1 + 1056);
      }

      unsigned int v3 = v5 + 1;
    }

    while (v5 + 1 <= v2);
  }

  _ClearAddress(&v9, *(_DWORD *)(a1 + 1060), *(_DWORD *)(a1 + 1064));
  _ClearAddress(&v9, *(_DWORD *)(a1 + 1096), *(_DWORD *)(a1 + 1100));
  uint64_t v6 = v9;
  if (v9)
  {
    int v7 = 0;
    int v8 = 1;
    do
    {
      printf("Node %u:\n", v8);
      printf("\taddr = %u\n\tuint64_t size = %u\n", v6[2], v6[3]);
      v7 += v6[3];
      uint64_t v6 = *(_DWORD **)v6;
      ++v8;
    }

    while (v6);
    if (v7) {
      printf("======\nTotal free bytes: %u\n", v7);
    }
  }

_DWORD *_newFreeListEntry(int a1, int a2)
{
  uint64_t v4 = BOM_malloc(0x10uLL);
  unsigned int v5 = v4;
  if (v4)
  {
    *(void *)uint64_t v4 = 0LL;
    v4[2] = a1;
    v4[3] = a2;
  }

  else
  {
    uint64_t v6 = (FILE *)*MEMORY[0x1895F89D0];
    int v7 = __error();
    int v8 = strerror(*v7);
    fprintf(v6, "malloc: %s\n", v8);
  }

  return v5;
}

void _ClearAddress(void *a1, unsigned int a2, int a3)
{
  if (a2)
  {
    if (a3)
    {
      unsigned int v3 = (_DWORD *)*a1;
      if (*a1)
      {
        unsigned int v5 = 0LL;
        while (1)
        {
          uint64_t v6 = v3;
          unsigned int v7 = v3[2];
          if (v7 <= a2)
          {
            int v8 = v3[3];
            int v9 = v8 + v7;
            if (v8 + v7 > a2) {
              break;
            }
          }

          unsigned int v3 = *(_DWORD **)v6;
          unsigned int v5 = v6;
          if (!*(void *)v6) {
            return;
          }
        }

        if (v7 == a2)
        {
          int v10 = v8 - a3;
          if (v10)
          {
            v6[2] = a2 + a3;
            _DWORD v6[3] = v10;
          }

          else
          {
            if (!v5) {
              unsigned int v5 = a1;
            }
            void *v5 = *(void *)v6;
            free(v6);
          }
        }

        else if (v9 == a3 + a2)
        {
          _DWORD v6[3] = v8 - a3;
        }

        else
        {
          unsigned int v11 = _newFreeListEntry(a3 + a2, v9 - (a3 + a2));
          if (v11)
          {
            *(void *)unsigned int v11 = *(void *)v6;
            _DWORD v6[3] = a2 - v6[2];
            *(void *)uint64_t v6 = v11;
          }

          else
          {
            size_t v12 = __error();
            _BOMExceptionHandlerCall( (uint64_t)"Out of memory.",  1,  "/Library/Caches/com.apple.xbs/Sources/Bom/Storage/BOMStorage.c",  1750,  *v12);
          }
        }
      }
    }
  }

uint64_t _BOMStoragePrintDiagnostics(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = result;
    unsigned int v2 = (FILE **)MEMORY[0x1895F89D0];
    fprintf((FILE *)*MEMORY[0x1895F89D0], "   # blocks : %d\n", *(_DWORD *)(result + 1056));
    fprintf(*v2, "   adm size : %d\n", *(_DWORD *)(v1 + 1064));
    fprintf(*v2, "   bt size  : %d\n", (8 * *(_DWORD *)(v1 + 1068)) | 4);
    fprintf(*v2, "   fl size  : %d\n", *(_DWORD *)(*(void *)(v1 + 1088) + 8LL));
    return fprintf(*v2, "   toc size : %d\n", *(_DWORD *)(v1 + 1100));
  }

  return result;
}

uint64_t BOMStorageDump(uint64_t a1, int a2)
{
  uint64_t v29 = *MEMORY[0x1895F89C0];
  if (!a1) {
    return 1LL;
  }
  uint64_t v3 = *(unsigned int *)(a1 + 1096);
  if (!(_DWORD)v3) {
    return 1LL;
  }
  unint64_t v5 = *(unsigned int *)(a1 + 1100);
  if (!(_DWORD)v5) {
    return 1LL;
  }
  uint64_t v6 = BOMStreamWithAddress(*(void *)(a1 + 1040) + v3, v5, 0);
  if (!v6) {
    return 2LL;
  }
  uint64_t v7 = (uint64_t)v6;
  int UInt32 = BOMStreamReadUInt32((uint64_t)v6);
  if (*(_BYTE *)(a1 + 1052))
  {
    if (*(_DWORD *)(a1 + 1116)) {
      int v9 = "read/write [dirty]";
    }
    else {
      int v9 = "read/write";
    }
  }

  else
  {
    int v9 = "readonly";
  }

  size_t v12 = (FILE **)MEMORY[0x1895F89E0];
  fprintf((FILE *)*MEMORY[0x1895F89E0], "Storage: open %s (%u blocks)\n", v9, *(_DWORD *)(a1 + 1056));
  fprintf(*v12, "    ToC: %u entries (%u bytes)\n", UInt32, *(_DWORD *)(a1 + 1100));
  if (!UInt32)
  {
    uint64_t v10 = 0LL;
    goto LABEL_67;
  }

  int v26 = 0;
  do
  {
    BOMStreamReadUInt32(v7);
    unsigned int UInt8 = BOMStreamReadUInt8(v7);
    BOMStreamReadBuffer(v7, &__dst, UInt8);
    *((_BYTE *)&__dst + UInt8) = 0;
    unsigned int v14 = *v12;
    if ((a2 & 1) != 0) {
      fprintf(v14, "    Bid: 0x%08x (%u) '%s' (%lu bytes)");
    }
    else {
      fprintf(v14, "    Bid: '%s' (%lu bytes)");
    }
    if ((void)__dst == 0x6F666E496D6F42LL
      || ((_DWORD)__dst == 1752457552 ? (BOOL v15 = WORD2(__dst) == 115) : (BOOL v15 = 0),
          v15
       || (void)__dst == 0x7865646E494C48LL
       || ((_DWORD)__dst == 1684949334 ? (BOOL v16 = *(_DWORD *)((char *)&__dst + 3) == 7890276) : (BOOL v16 = 0),
           v16 || ((_DWORD)__dst == 1702521171 ? (BOOL v17 = *(_DWORD *)((char *)&__dst + 3) == 3421797) : (BOOL v17 = 0), v17))))
    {
      fwrite(" [BOM]\n", 7uLL, 1uLL, *v12);
      goto LABEL_54;
    }

    if ((void)__dst == 0x547463656A6F7250LL && *((void *)&__dst + 1) == 0x656C6261546761LL)
    {
      fwrite(" [Metabom]\n", 0xBuLL, 1uLL, *v12);
      v26 |= 0x10u;
      uint64_t v23 = a1;
      p_dst = "ProjectTagTable";
    }

    else if ((void)__dst == 0x546567616B636150LL && *((void *)&__dst + 1) == 0x656C6261546761LL)
    {
      fwrite(" [Metabom]\n", 0xBuLL, 1uLL, *v12);
      v26 |= 0x20u;
      uint64_t v23 = a1;
      p_dst = "PackageTagTable";
    }

    else
    {
      if ((void)__dst != 0x5467615468746150LL || *(void *)((char *)&__dst + 5) != 0x656C6261546761LL)
      {
        if ((void)__dst == 0x547463656A6F7250LL && *((void *)&__dst + 1) == 0x657254687461506FLL && v28 == 101)
        {
          fwrite(" [Metabom]\n", 0xBuLL, 1uLL, *v12);
          v26 |= 0x80u;
          uint64_t v23 = a1;
          p_dst = "ProjectToPathTree";
          unsigned int v25 = a2 | 0x1310000;
        }

        else
        {
          if ((v26 & 0x20) == 0)
          {
            fputc(10, *v12);
            goto LABEL_54;
          }

          fwrite(" [Package]\n", 0xBuLL, 1uLL, *v12);
          p_dst = (const char *)&__dst;
          uint64_t v23 = a1;
          unsigned int v25 = a2 | 0x230000;
        }

        goto LABEL_60;
      }

      fwrite(" [Metabom]\n", 0xBuLL, 1uLL, *v12);
      v26 |= 0x40u;
      uint64_t v23 = a1;
      p_dst = "PathTagTable";
    }

    unsigned int v25 = a2 | 0x210000;
LABEL_60:
    BOMStorageDumpTree(v23, p_dst, v25);
LABEL_54:
    --UInt32;
  }

  while (UInt32);
  uint64_t v10 = 0LL;
  if ((v26 & 0xF0) != 0 && (v26 & 0xF0) != 0xF0)
  {
    fprintf( (FILE *)*MEMORY[0x1895F89D0],  "WARNING: file appears to be a corrupt Metabom! (found %04x expected %04x or %04x)\n",  v26 & 0xF0,  240,  0);
    uint64_t v10 = 3LL;
  }

LABEL_67:
  BOMStreamFree(v7);
  return v10;
}

uint64_t _WriteAddress(uint64_t a1, unsigned int a2, unsigned int a3)
{
  uint64_t v3 = (int *)BOMStreamWithFile(*(_DWORD *)(a1 + 1028), a2, a3, 1, (char *)(*(void *)(a1 + 1040) + a2));
  if (v3)
  {
    uint64_t v4 = (uint64_t)v3;
    BOMStreamFlush(v3);
    return BOMStreamFree(v4);
  }

  else
  {
    uint64_t v6 = __error();
    return _BOMExceptionHandlerCall( (uint64_t)"Unable to create write stream.",  1,  "/Library/Caches/com.apple.xbs/Sources/Bom/Storage/BOMStorage.c",  2141,  *v6);
  }

BOOL BOMCKTreeBuildKey( char *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const char *a9)
{
  return _buildKey(a1, &a9) != 0;
}

uint64_t _buildKey(char *a1, const char **a2)
{
  *a1 = 0;
  int v9 = a2 + 1;
  unsigned int v2 = *a2;
  if (!*a2) {
    return 0LL;
  }
  unsigned int v4 = 0;
  char v5 = 1;
  while (1)
  {
    if ((v5 & 1) == 0)
    {
      if (v4 >= 0x3FF) {
        break;
      }
      *(_WORD *)&a1[v4++] = 47;
    }

    if (strchr(v2, 47))
    {
      fprintf((FILE *)*MEMORY[0x1895F89D0], "invalid key segment: '%s'\n", v2);
      return 1LL;
    }

    v4 += strlen(v2);
    if (v4 >= 0x400) {
      break;
    }
    strlcat(a1, v2, 0x400uLL);
    char v5 = 0;
    uint64_t v6 = v9++;
    unsigned int v2 = *v6;
    if (!*v6)
    {
      if (v4 < 0x3FF) {
        return 0LL;
      }
      break;
    }
  }

  uint64_t v7 = 1LL;
  fwrite("key too long\n", 0xDuLL, 1uLL, (FILE *)*MEMORY[0x1895F89D0]);
  return v7;
}

uint64_t BOMCKTreeCount( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const char *a9)
{
  uint64_t v25 = *MEMORY[0x1895F89C0];
  uint64_t v22 = &a9;
  if (!_buildKey(__s, &a9))
  {
    LODWORD(v11) = strlen(__s);
    size_t v12 = (v11 + 1);
    uint64_t v13 = (char *)BOMTreeIteratorNew(a1, __s, v12, &v21);
    if (v13)
    {
      unsigned int v14 = v13;
      if (!v21)
      {
        if (!BOMTreeIteratorKey((uint64_t)v13) || (__strlcpy_chk(), strlen(__s1) == v11))
        {
          uint64_t v10 = 0LL;
          goto LABEL_9;
        }

        if ((_DWORD)v11)
        {
          else {
            size_t v11 = v12;
          }
        }

        else
        {
          size_t v11 = 0LL;
        }

        BOOL v16 = strchr(&__s1[v11], 47);
        if (v16) {
          v16[1] = 0;
        }
        unsigned int v17 = strlen(__s1);
        BOMTreeIteratorNext((uint64_t)v14);
        if (!BOMTreeIteratorIsAtEnd((uint64_t)v14))
        {
          size_t v18 = v17;
          uint64_t v10 = 1LL;
          do
          {
            uint64_t v19 = (const char *)BOMTreeIteratorKey((uint64_t)v14);
            if (strncmp(__s, v19, v11)) {
              break;
            }
            if (strncmp(__s1, v19, v18))
            {
              __strlcpy_chk();
              unsigned int v20 = strchr(&__s1[v11], 47);
              if (v20) {
                v20[1] = 0;
              }
              size_t v18 = strlen(__s1);
              uint64_t v10 = (v10 + 1);
            }

            BOMTreeIteratorNext((uint64_t)v14);
          }

          while (!BOMTreeIteratorIsAtEnd((uint64_t)v14));
          goto LABEL_9;
        }
      }

      uint64_t v10 = 1LL;
LABEL_9:
      BOMTreeIteratorFree(v14);
      return v10;
    }
  }

  return 0LL;
}

char *BOMCKTreeGet( uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const char *a9)
{
  uint64_t v26 = *MEMORY[0x1895F89C0];
  BOOL v24 = &a9;
  if (!_buildKey(__s, &a9))
  {
    int v12 = strlen(__s);
    size_t v13 = (v12 + 1);
    unsigned int v14 = (char *)BOMTreeIteratorNew(a1, __s, v13, &v23);
    if (v14)
    {
      BOOL v15 = v14;
      if (v23)
      {
        size_t v11 = (char *)BOMTreeIteratorValue((uint64_t)v14);
      }

      else
      {
        if (BOMTreeIteratorKey((uint64_t)v14))
        {
          __strlcpy_chk();
          if (v12) {
            __strlcat_chk();
          }
          else {
            size_t v13 = 0LL;
          }
          size_t v11 = &BOMCKTreeGet_next[v13];
          BOOL v16 = strchr(&BOMCKTreeGet_next[v13], 47);
          if (v16) {
            v16[1] = 0;
          }
          if (!a2)
          {
LABEL_21:
            BOOL v21 = strchr(&BOMCKTreeGet_next[v13], 47);
            if (v21) {
              *BOOL v21 = 0;
            }
            goto LABEL_24;
          }

          int v17 = 0;
          size_t v18 = strlen(BOMCKTreeGet_next);
          while (!BOMTreeIteratorIsAtEnd((uint64_t)v15))
          {
            uint64_t v19 = (const char *)BOMTreeIteratorKey((uint64_t)v15);
            if (strncmp(__s, v19, v13)) {
              break;
            }
            if (strncmp(BOMCKTreeGet_next, v19, v18))
            {
              __strlcpy_chk();
              unsigned int v20 = strchr(&BOMCKTreeGet_next[v13], 47);
              if (v20) {
                v20[1] = 0;
              }
              size_t v18 = strlen(BOMCKTreeGet_next);
              ++v17;
            }

            BOMTreeIteratorNext((uint64_t)v15);
            if (v17 == a2) {
              goto LABEL_21;
            }
          }
        }

        size_t v11 = 0LL;
      }

_DWORD *platform_toolbox_new(uint64_t a1)
{
  if (a1) {
    return 0LL;
  }
  uint64_t result = calloc(1uLL, 0xD0uLL);
  if (result)
  {
    *uint64_t result = 1885499256;
    result[50] = 2020565616;
  }

  return result;
}

void platform_toolbox_free(void *a1)
{
  if (a1 && *(_DWORD *)a1 == 1885499256 && *((_DWORD *)a1 + 50) == 2020565616)
  {
    *((_OWORD *)a1 + 11) = 0u;
    *((_OWORD *)a1 + 12) = 0u;
    *((_OWORD *)a1 + 9) = 0u;
    *((_OWORD *)a1 + 10) = 0u;
    *((_OWORD *)a1 + 7) = 0u;
    *((_OWORD *)a1 + 8) = 0u;
    *((_OWORD *)a1 + 5) = 0u;
    *((_OWORD *)a1 + 6) = 0u;
    *((_OWORD *)a1 + 3) = 0u;
    *((_OWORD *)a1 + 4) = 0u;
    *((_OWORD *)a1 + 1) = 0u;
    *((_OWORD *)a1 + 2) = 0u;
    *(_OWORD *)a1 = 0u;
    free(a1);
  }

void *platform_malloc(uint64_t a1, size_t __size)
{
  if (!a1) {
    return malloc(__size);
  }
  if (*(_DWORD *)a1 == 1885499256 && *(_DWORD *)(a1 + 200) == 2020565616)
  {
    int v3 = *(_DWORD *)(a1 + 4);
    if (!v3) {
      goto LABEL_7;
    }
    int v4 = *(_DWORD *)(a1 + 8);
    if (v4)
    {
      *(_DWORD *)(a1 + 8) = v4 - 1;
LABEL_7:
      char v5 = *(uint64_t (**)(uint64_t, void, size_t))(a1 + 24);
      if (v5) {
        return (void *)v5(a1, *(void *)(a1 + 16), __size);
      }
      return malloc(__size);
    }

    *__error() = v3;
    *(_DWORD *)(a1 + 4) = 0;
  }

  return 0LL;
}

void platform_free(uint64_t a1, void *a2)
{
  if (!a1)
  {
LABEL_9:
    free(a2);
    return;
  }

  if (*(_DWORD *)a1 == 1885499256 && *(_DWORD *)(a1 + 200) == 2020565616)
  {
    int v3 = *(_DWORD *)(a1 + 4);
    if (!v3) {
      goto LABEL_7;
    }
    int v4 = *(_DWORD *)(a1 + 8);
    if (v4)
    {
      *(_DWORD *)(a1 + 8) = v4 - 1;
LABEL_7:
      char v5 = *(void (**)(uint64_t, void, void *))(a1 + 32);
      if (v5)
      {
        v5(a1, *(void *)(a1 + 16), a2);
        return;
      }

      goto LABEL_9;
    }

    *__error() = v3;
    *(_DWORD *)(a1 + 4) = 0;
  }

void *platform_calloc(uint64_t a1, size_t __count, size_t __size)
{
  if (!a1) {
    return calloc(__count, __size);
  }
  if (*(_DWORD *)a1 == 1885499256 && *(_DWORD *)(a1 + 200) == 2020565616)
  {
    int v4 = *(_DWORD *)(a1 + 4);
    if (!v4) {
      goto LABEL_7;
    }
    int v5 = *(_DWORD *)(a1 + 8);
    if (v5)
    {
      *(_DWORD *)(a1 + 8) = v5 - 1;
LABEL_7:
      uint64_t v6 = *(uint64_t (**)(uint64_t, void, size_t, size_t))(a1 + 40);
      if (v6) {
        return (void *)v6(a1, *(void *)(a1 + 16), __count, __size);
      }
      return calloc(__count, __size);
    }

    *__error() = v4;
    *(_DWORD *)(a1 + 4) = 0;
  }

  return 0LL;
}

void *platform_valloc(uint64_t a1, size_t a2)
{
  if (!a1) {
    return valloc(a2);
  }
  if (*(_DWORD *)a1 == 1885499256 && *(_DWORD *)(a1 + 200) == 2020565616)
  {
    int v3 = *(_DWORD *)(a1 + 4);
    if (!v3) {
      goto LABEL_7;
    }
    int v4 = *(_DWORD *)(a1 + 8);
    if (v4)
    {
      *(_DWORD *)(a1 + 8) = v4 - 1;
LABEL_7:
      int v5 = *(uint64_t (**)(uint64_t, void, size_t))(a1 + 48);
      if (v5) {
        return (void *)v5(a1, *(void *)(a1 + 16), a2);
      }
      return valloc(a2);
    }

    *__error() = v3;
    *(_DWORD *)(a1 + 4) = 0;
  }

  return 0LL;
}

void *platform_realloc(uint64_t a1, void *__ptr, size_t __size)
{
  if (!a1) {
    return realloc(__ptr, __size);
  }
  if (*(_DWORD *)a1 == 1885499256 && *(_DWORD *)(a1 + 200) == 2020565616)
  {
    int v4 = *(_DWORD *)(a1 + 4);
    if (!v4) {
      goto LABEL_7;
    }
    int v5 = *(_DWORD *)(a1 + 8);
    if (v5)
    {
      *(_DWORD *)(a1 + 8) = v5 - 1;
LABEL_7:
      uint64_t v6 = *(uint64_t (**)(uint64_t, void, void *, size_t))(a1 + 56);
      if (v6) {
        return (void *)v6(a1, *(void *)(a1 + 16), __ptr, __size);
      }
      return realloc(__ptr, __size);
    }

    *__error() = v4;
    *(_DWORD *)(a1 + 4) = 0;
  }

  return 0LL;
}

void *platform_memset(uint64_t a1, void *__b, uint64_t __c, size_t __len)
{
  int v4 = __b;
  if (!a1)
  {
LABEL_10:
    memset(__b, __c, __len);
    return v4;
  }

  if (*(_DWORD *)a1 == 1885499256 && *(_DWORD *)(a1 + 200) == 2020565616)
  {
    int v6 = *(_DWORD *)(a1 + 4);
    if (v6)
    {
      int v7 = *(_DWORD *)(a1 + 8);
      if (!v7)
      {
        int v4 = 0LL;
        *__error() = v6;
        *(_DWORD *)(a1 + 4) = 0;
        return v4;
      }

      *(_DWORD *)(a1 + 8) = v7 - 1;
    }

    int v8 = *(uint64_t (**)(uint64_t, void, void *, uint64_t, size_t))(a1 + 64);
    if (v8) {
      return (void *)v8(a1, *(void *)(a1 + 16), __b, __c, __len);
    }
    goto LABEL_10;
  }

  return 0LL;
}

void *platform_memcpy(uint64_t a1, void *__dst, void *__src, size_t __n)
{
  int v4 = __dst;
  if (!a1)
  {
LABEL_10:
    memcpy(__dst, __src, __n);
    return v4;
  }

  if (*(_DWORD *)a1 == 1885499256 && *(_DWORD *)(a1 + 200) == 2020565616)
  {
    int v6 = *(_DWORD *)(a1 + 4);
    if (v6)
    {
      int v7 = *(_DWORD *)(a1 + 8);
      if (!v7)
      {
        int v4 = 0LL;
        *__error() = v6;
        *(_DWORD *)(a1 + 4) = 0;
        return v4;
      }

      *(_DWORD *)(a1 + 8) = v7 - 1;
    }

    int v8 = *(uint64_t (**)(uint64_t, void, void *, void *, size_t))(a1 + 72);
    if (v8) {
      return (void *)v8(a1, *(void *)(a1 + 16), __dst, __src, __n);
    }
    goto LABEL_10;
  }

  return 0LL;
}

uint64_t platform_memcmp(uint64_t a1, void *__s1, void *__s2, size_t __n)
{
  if (!a1) {
    return memcmp(__s1, __s2, __n);
  }
  if (*(_DWORD *)a1 == 1885499256 && *(_DWORD *)(a1 + 200) == 2020565616)
  {
    int v5 = *(_DWORD *)(a1 + 4);
    if (!v5) {
      goto LABEL_7;
    }
    int v6 = *(_DWORD *)(a1 + 8);
    if (v6)
    {
      *(_DWORD *)(a1 + 8) = v6 - 1;
LABEL_7:
      int v7 = *(uint64_t (**)(uint64_t, void, void *, void *, size_t))(a1 + 80);
      if (v7) {
        return v7(a1, *(void *)(a1 + 16), __s1, __s2, __n);
      }
      return memcmp(__s1, __s2, __n);
    }

    *__error() = v5;
    *(_DWORD *)(a1 + 4) = 0;
  }

  return 0xFFFFFFFFLL;
}

uint64_t platform_strlen(uint64_t a1, char *__s)
{
  if (!a1) {
    return strlen(__s);
  }
  if (*(_DWORD *)a1 == 1885499256 && *(_DWORD *)(a1 + 200) == 2020565616)
  {
    int v3 = *(_DWORD *)(a1 + 4);
    if (!v3) {
      goto LABEL_7;
    }
    int v4 = *(_DWORD *)(a1 + 8);
    if (v4)
    {
      *(_DWORD *)(a1 + 8) = v4 - 1;
LABEL_7:
      int v5 = *(uint64_t (**)(uint64_t, void, char *))(a1 + 88);
      if (v5) {
        return v5(a1, *(void *)(a1 + 16), __s);
      }
      return strlen(__s);
    }

    *__error() = v3;
    *(_DWORD *)(a1 + 4) = 0;
  }

  return -1LL;
}

uint64_t platform_strnlen(uint64_t a1, char *__s1, size_t __n)
{
  if (!a1) {
    return strnlen(__s1, __n);
  }
  if (*(_DWORD *)a1 == 1885499256 && *(_DWORD *)(a1 + 200) == 2020565616)
  {
    int v4 = *(_DWORD *)(a1 + 4);
    if (!v4) {
      goto LABEL_7;
    }
    int v5 = *(_DWORD *)(a1 + 8);
    if (v5)
    {
      *(_DWORD *)(a1 + 8) = v5 - 1;
LABEL_7:
      int v6 = *(uint64_t (**)(uint64_t, void, char *, size_t))(a1 + 96);
      if (v6) {
        return v6(a1, *(void *)(a1 + 16), __s1, __n);
      }
      return strnlen(__s1, __n);
    }

    *__error() = v4;
    *(_DWORD *)(a1 + 4) = 0;
  }

  return -1LL;
}

uint64_t platform_strncmp(uint64_t a1, char *__s1, char *__s2, size_t __n)
{
  if (!a1) {
    return strncmp(__s1, __s2, __n);
  }
  if (*(_DWORD *)a1 == 1885499256 && *(_DWORD *)(a1 + 200) == 2020565616)
  {
    int v5 = *(_DWORD *)(a1 + 4);
    if (!v5) {
      goto LABEL_7;
    }
    int v6 = *(_DWORD *)(a1 + 8);
    if (v6)
    {
      *(_DWORD *)(a1 + 8) = v6 - 1;
LABEL_7:
      int v7 = *(uint64_t (**)(uint64_t, void, char *, char *, size_t))(a1 + 104);
      if (v7) {
        return v7(a1, *(void *)(a1 + 16), __s1, __s2, __n);
      }
      return strncmp(__s1, __s2, __n);
    }

    *__error() = v5;
    *(_DWORD *)(a1 + 4) = 0;
  }

  return 0xFFFFFFFFLL;
}

char *platform_strdup(uint64_t a1, char *__s1)
{
  if (!a1) {
    return strdup(__s1);
  }
  if (*(_DWORD *)a1 == 1885499256 && *(_DWORD *)(a1 + 200) == 2020565616)
  {
    int v3 = *(_DWORD *)(a1 + 4);
    if (!v3) {
      goto LABEL_7;
    }
    int v4 = *(_DWORD *)(a1 + 8);
    if (v4)
    {
      *(_DWORD *)(a1 + 8) = v4 - 1;
LABEL_7:
      int v5 = *(uint64_t (**)(uint64_t, void, char *))(a1 + 120);
      if (v5) {
        return (char *)v5(a1, *(void *)(a1 + 16), __s1);
      }
      return strdup(__s1);
    }

    *__error() = v3;
    *(_DWORD *)(a1 + 4) = 0;
  }

  return 0LL;
}

uint64_t platform_strtoq(uint64_t a1, char *__str, char **__endptr, uint64_t __base)
{
  if (!a1) {
    return strtoq(__str, __endptr, __base);
  }
  if (*(_DWORD *)a1 == 1885499256 && *(_DWORD *)(a1 + 200) == 2020565616)
  {
    int v5 = *(_DWORD *)(a1 + 4);
    if (!v5) {
      goto LABEL_7;
    }
    int v6 = *(_DWORD *)(a1 + 8);
    if (v6)
    {
      *(_DWORD *)(a1 + 8) = v6 - 1;
LABEL_7:
      int v7 = *(uint64_t (**)(uint64_t, void, char *, char **, uint64_t))(a1 + 136);
      if (v7) {
        return v7(a1, *(void *)(a1 + 16), __str, __endptr, __base);
      }
      return strtoq(__str, __endptr, __base);
    }

    *__error() = v5;
    *(_DWORD *)(a1 + 4) = 0;
  }

  return -1LL;
}

uint64_t platform_read(uint64_t a1, uint64_t a2, void *a3, size_t a4)
{
  if (!a1) {
    return read(a2, a3, a4);
  }
  if (*(_DWORD *)a1 == 1885499256 && *(_DWORD *)(a1 + 200) == 2020565616)
  {
    int v5 = *(_DWORD *)(a1 + 4);
    if (!v5) {
      goto LABEL_7;
    }
    int v6 = *(_DWORD *)(a1 + 8);
    if (v6)
    {
      *(_DWORD *)(a1 + 8) = v6 - 1;
LABEL_7:
      int v7 = *(uint64_t (**)(uint64_t, void, uint64_t, void *, size_t))(a1 + 168);
      if (v7) {
        return v7(a1, *(void *)(a1 + 16), a2, a3, a4);
      }
      return read(a2, a3, a4);
    }

    *__error() = v5;
    *(_DWORD *)(a1 + 4) = 0;
  }

  return -1LL;
}

uint64_t platform_close(uint64_t a1, uint64_t a2)
{
  if (!a1) {
    return close(a2);
  }
  if (*(_DWORD *)a1 == 1885499256 && *(_DWORD *)(a1 + 200) == 2020565616)
  {
    int v3 = *(_DWORD *)(a1 + 4);
    if (!v3) {
      goto LABEL_7;
    }
    int v4 = *(_DWORD *)(a1 + 8);
    if (v4)
    {
      *(_DWORD *)(a1 + 8) = v4 - 1;
LABEL_7:
      int v5 = *(uint64_t (**)(uint64_t, void, uint64_t))(a1 + 176);
      if (v5) {
        return v5(a1, *(void *)(a1 + 16), a2);
      }
      return close(a2);
    }

    *__error() = v3;
    *(_DWORD *)(a1 + 4) = 0;
  }

  return 0xFFFFFFFFLL;
}

uint64_t platform_mktime(uint64_t a1, tm *a2)
{
  if (!a1) {
    return mktime(a2);
  }
  if (*(_DWORD *)a1 == 1885499256 && *(_DWORD *)(a1 + 200) == 2020565616)
  {
    int v3 = *(_DWORD *)(a1 + 4);
    if (!v3) {
      goto LABEL_7;
    }
    int v4 = *(_DWORD *)(a1 + 8);
    if (v4)
    {
      *(_DWORD *)(a1 + 8) = v4 - 1;
LABEL_7:
      int v5 = *(uint64_t (**)(uint64_t, void, tm *))(a1 + 184);
      if (v5) {
        return v5(a1, *(void *)(a1 + 16), a2);
      }
      return mktime(a2);
    }

    *__error() = v3;
    *(_DWORD *)(a1 + 4) = 0;
  }

  return -1LL;
}

void *BOMTreeNew(uint64_t a1, unsigned int a2)
{
  if (a1 && a2) {
    return _BOMTreeNew(a1, 0LL, a2, 0, 0);
  }
  else {
    return 0LL;
  }
}

void *_BOMTreeNew(uint64_t a1, const char *a2, unsigned int a3, int a4, char a5)
{
  uint64_t result = _newBOMTree(a1, a2);
  if (result)
  {
    uint64_t v11 = (uint64_t)result;
    *((_DWORD *)result + 4) = a3;
    if (a4) {
      int v12 = a4;
    }
    else {
      int v12 = 4096;
    }
    *((_DWORD *)result + 78) = v12;
    unsigned int v13 = v12 - 16;
    *((_DWORD *)result + 79) = v13 >> 3;
    *((_DWORD *)result + 80) = (v13 >> 3) + 1;
    *((_DWORD *)result + 81) = v13 >> 4;
    *((_BYTE *)result + 294) = a5;
    unsigned int v14 = _NewPage((uint64_t)result, 0);
    *(void *)(v11 + 24) = v14;
    *((_WORD *)v14 + 2) |= 1u;
    *(_BYTE *)(v11 + 292) = 1;
    BOMTreeFree(v11);
    return (void *)_BOMTreeOpen(a1, a2, a3, 1);
  }

  return result;
}

void *BOMTreeNewWithName(uint64_t a1, const char *a2)
{
  if (a1 && a2 && (unsigned int v4 = BOMStorageNewNamedBlock(a1, a2)) != 0) {
    return _BOMTreeNew(a1, a2, v4, 0, 0);
  }
  else {
    return 0LL;
  }
}

void *BOMTreeNewWithOptions(uint64_t a1, unsigned int a2, const char *a3, unsigned int a4, char a5)
{
  if (!a1) {
    return 0LL;
  }
  int v6 = a4;
  unsigned int v8 = a2;
  if (!a2 && !a3) {
    return 0LL;
  }
  if (!a4)
  {
    int v6 = 4096;
    if (!a2) {
      goto LABEL_9;
    }
    return _BOMTreeNew(a1, a3, v8, v6, a5);
  }

  if (a4 < 0x30) {
    return 0LL;
  }
  if (a2) {
    return _BOMTreeNew(a1, a3, v8, v6, a5);
  }
LABEL_9:
  unsigned int v8 = BOMStorageNewNamedBlock(a1, a3);
  if (v8) {
    return _BOMTreeNew(a1, a3, v8, v6, a5);
  }
  return 0LL;
}

uint64_t BOMTreeOpen(uint64_t a1, unsigned int a2, char a3)
{
  if (a1 && a2) {
    return _BOMTreeOpen(a1, 0LL, a2, a3);
  }
  else {
    return 0LL;
  }
}

uint64_t _BOMTreeOpen(uint64_t a1, const char *a2, unsigned int a3, char a4)
{
  uint64_t v7 = a1;
  uint64_t v17 = *MEMORY[0x1895F89C0];
  unsigned int v8 = _newBOMTree(a1, a2);
  uint64_t v9 = (uint64_t)v8;
  if (v8)
  {
    *unsigned int v8 = v7;
    *((_DWORD *)v8 + 4) = a3;
    if (!a2)
    {
      snprintf(__str, 0x100uLL, "<Tree %d>", a3);
      uint64_t v7 = *(void *)v9;
      a3 = *(_DWORD *)(v9 + 16);
    }

    uint64_t v10 = BOMStreamWithBlockID(v7, a3, 0LL, 0);
    if (!v10) {
      goto LABEL_13;
    }
    uint64_t v11 = v10;
    if (BOMStreamReadUInt32(v10) == 1953654117)
    {
      if (BOMStreamReadUInt32(v11) == 1)
      {
        int UInt32 = BOMStreamReadUInt32(v11);
        *(_DWORD *)(v9 + 312) = BOMStreamReadUInt32(v11);
        *(_DWORD *)(v9 + 20) = BOMStreamReadUInt32(v11);
        *(_BYTE *)(v9 + 294) = BOMStreamReadUInt8(v11);
        BOMStreamFree(v11);
        unsigned int v13 = *(_DWORD *)(v9 + 312) - 16;
        *(_DWORD *)(v9 + 316) = v13 >> 3;
        *(_DWORD *)(v9 + 320) = (v13 >> 3) + 1;
        *(_DWORD *)(v9 + 324) = v13 >> 4;
        unsigned int v14 = _NewPage(v9, UInt32);
        *(void *)(v9 + 24) = v14;
        if (v14 && !_ReadPage(v9, (uint64_t)v14))
        {
          *(_BYTE *)(v9 + 293) = a4;
          return v9;
        }

uint64_t BOMTreeOpenWithName(uint64_t a1, const char *a2, char a3)
{
  if (a1 && a2 && (unsigned int NamedBlock = BOMStorageGetNamedBlock(a1, a2)) != 0) {
    return _BOMTreeOpen(a1, a2, NamedBlock, a3);
  }
  else {
    return 0LL;
  }
}

uint64_t BOMTreeFree(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = result;
    if (*(_BYTE *)(result + 292) && BOMTreeCommit(result))
    {
      return 1LL;
    }

    else
    {
      for (uint64_t i = 32LL; i != 288; i += 8LL)
      {
        int v3 = *(_WORD **)(v1 + i);
        if (v3)
        {
          if ((v3[2] & 2) != 0) {
            _WritePage(v1, *(void *)(v1 + i));
          }
          _FreePage(v3);
          *(void *)(v1 + i) = 0LL;
        }
      }

      _FreePage(*(void **)(v1 + 24));
      *(void *)(v1 + 24) = 0LL;
      unsigned int v4 = *(void **)(v1 + 8);
      if (v4)
      {
        free(v4);
        *(void *)(v1 + 8) = 0LL;
      }

      int v5 = *(const void **)(v1 + 304);
      if (v5)
      {
        CFRelease(v5);
        *(void *)(v1 + 304) = 0LL;
      }

      int v6 = *(void **)(v1 + 344);
      if (v6)
      {
        free(v6);
        *(void *)(v1 + 344) = 0LL;
      }

      uint64_t v7 = *(void **)(v1 + 328);
      if (v7) {
        free(v7);
      }
      free((void *)v1);
      return 0LL;
    }
  }

  return result;
}

uint64_t BOMTreeCommit(uint64_t a1)
{
  if (!a1 || !*(_BYTE *)(a1 + 292)) {
    return 0LL;
  }
  _SyncCache(a1);
  _WritePage(a1, *(void *)(a1 + 24));
  uint64_t v2 = 1LL;
  uint64_t v3 = BOMStreamWithBlockID(*(void *)a1, *(_DWORD *)(a1 + 16), 0x15uLL, 1);
  if (v3)
  {
    uint64_t v4 = v3;
    BOMStreamWriteUInt32(v3, 0x74726565u);
    BOMStreamWriteUInt32(v4, 1u);
    BOMStreamWriteUInt32(v4, **(_DWORD **)(a1 + 24));
    BOMStreamWriteUInt32(v4, *(_DWORD *)(a1 + 312));
    BOMStreamWriteUInt32(v4, *(_DWORD *)(a1 + 20));
    BOMStreamWriteUInt8(v4, *(_BYTE *)(a1 + 294));
    if (!BOMStreamFree(v4))
    {
      uint64_t v2 = 0LL;
      *(_BYTE *)(a1 + 292) = 0;
    }
  }

  return v2;
}

void _FreePage(void *a1)
{
  if (a1)
  {
    *(_DWORD *)a1 = -1;
    *((void *)a1 + 1) = -1LL;
    free(*((void **)a1 + 3));
    *((void *)a1 + 3) = 0LL;
    free(*((void **)a1 + 4));
    free(a1);
  }

uint64_t BOMTreeRemoveAndFree(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = result;
    uint64_t v2 = *(void *)result;
    uint64_t v3 = (char *)BOMTreeIteratorNew(result, 0LL, 0LL, 0LL);
    if (v3)
    {
      for (uint64_t i = v3; !BOMTreeIteratorIsAtEnd((uint64_t)i); BOMTreeIteratorNext((uint64_t)i))
      {
        int v5 = (const void *)BOMTreeIteratorKey((uint64_t)i);
        size_t v6 = BOMTreeIteratorKeySize((uint64_t)i);
        BOMTreeRemoveValue(v1, v5, v6);
      }

      BOMTreeIteratorFree(i);
      BOMStorageFreeBlock(v2, **(_DWORD **)(v1 + 24));
      _FreePage(*(void **)(v1 + 24));
      *(void *)(v1 + 24) = 0LL;
      uint64_t v7 = *(const char **)(v1 + 8);
      if (v7) {
        BOMStorageFreeNamedBlock(v2, v7);
      }
      else {
        BOMStorageFreeBlock(v2, *(_DWORD *)(v1 + 16));
      }
      unsigned int v8 = *(void **)(v1 + 8);
      if (v8)
      {
        free(v8);
        *(void *)(v1 + 8) = 0LL;
      }

      uint64_t v9 = *(const void **)(v1 + 304);
      if (v9) {
        CFRelease(v9);
      }
      free((void *)v1);
      return 0LL;
    }

    else
    {
      return 1LL;
    }
  }

  return result;
}

void *BOMTreeIteratorNew(uint64_t a1, const void *a2, size_t a3, BOOL *a4)
{
  unsigned int v8 = BOM_malloczero(0x48uLL);
  uint64_t v9 = v8;
  if (v8)
  {
    *unsigned int v8 = a1;
    BOMTreeIteratorSet((uint64_t)v8, a2, a3, a4);
    uint64_t v10 = *(const __CFArray **)(a1 + 304);
    if (v10)
    {
      CFIndex v11 = BOMCFArrayMaxRange(v10);
      CFIndex v13 = v12;
      v17.location = v11;
      v17.size_t length = v13;
      if (CFArrayContainsValue(*(CFArrayRef *)(a1 + 304), v17, v9))
      {
LABEL_8:
        v9[3] = BOM_malloc(v9[4]);
        v9[6] = BOM_malloc(v9[7]);
        return v9;
      }

      CFMutableDictionaryRef Mutable = *(__CFArray **)(a1 + 304);
    }

    else
    {
      CFMutableDictionaryRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x189604DB0], 0LL, 0LL);
      *(void *)(a1 + 304) = Mutable;
      if (!Mutable)
      {
        BOOL v15 = __error();
        _BOMExceptionHandlerCall( (uint64_t)"Out of memory.",  1,  "/Library/Caches/com.apple.xbs/Sources/Bom/Storage/BOMTree.c",  2460,  *v15);
        goto LABEL_8;
      }
    }

    CFArrayAppendValue(Mutable, v9);
    goto LABEL_8;
  }

  return v9;
}

uint64_t BOMTreeIteratorIsAtEnd(uint64_t a1)
{
  if (!a1) {
    return 1LL;
  }
  if (*(_BYTE *)(a1 + 67)) {
    return 1LL;
  }
  if (!*(_BYTE *)(a1 + 65))
  {
    uint64_t v3 = *(_DWORD **)(a1 + 8);
    if (v3)
    {
      if (*v3 == *(_DWORD *)(a1 + 16)) {
        return 0LL;
      }
    }
  }

  uint64_t result = 1LL;
  *(_BYTE *)(a1 + 67) = 1;
  return result;
}

uint64_t BOMTreeIteratorKey(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = result;
    if (*(_BYTE *)(result + 67)) {
      return 0LL;
    }
    if ((*(_BYTE *)(result + 65) || (uint64_t v2 = *(_DWORD **)(result + 8)) == 0LL || *v2 != *(_DWORD *)(result + 16))
      && !_revalidateIterator(result))
    {
      uint64_t result = 0LL;
      *(_BYTE *)(v1 + 67) = 1;
      return result;
    }

    if (*(_BYTE *)(*(void *)v1 + 294LL)) {
      return *(unsigned int *)(*(void *)(*(void *)(v1 + 8) + 24LL) + 4LL * *(unsigned int *)(v1 + 20));
    }
    if (!*(_BYTE *)(v1 + 40))
    {
      unint64_t v3 = BOMStorageSizeOfBlock( **(void **)v1,  *(_DWORD *)(*(void *)(*(void *)(v1 + 8) + 24LL) + 4LL * *(unsigned int *)(v1 + 20)));
      uint64_t v4 = *(void **)(v1 + 24);
      unint64_t v5 = *(void *)(v1 + 32);
      if (v3 > v5)
      {
        unint64_t v6 = v3;
        if (v4)
        {
          free(*(void **)(v1 + 24));
          *(void *)(v1 + 24) = 0LL;
          unint64_t v5 = *(void *)(v1 + 32);
        }

        if (v6 <= 2 * v5) {
          size_t v7 = 2 * v5;
        }
        else {
          size_t v7 = v6;
        }
        *(void *)(v1 + 32) = v7;
        uint64_t v4 = BOM_malloc(v7);
        *(void *)(v1 + 24) = v4;
      }

      if (BOMStorageCopyFromBlock( **(void **)v1,  *(_DWORD *)(*(void *)(*(void *)(v1 + 8) + 24LL) + 4LL * *(unsigned int *)(v1 + 20)),  v4)) {
        return 0LL;
      }
      *(_BYTE *)(v1 + 40) = 1;
    }

    return *(void *)(v1 + 24);
  }

  return result;
}

uint64_t BOMTreeIteratorKeySize(uint64_t a1)
{
  if (!a1 || *(_BYTE *)(a1 + 67)) {
    return 0LL;
  }
  if ((*(_BYTE *)(a1 + 65) || (unint64_t v3 = *(_DWORD **)(a1 + 8)) == 0LL || *v3 != *(_DWORD *)(a1 + 16))
    && !_revalidateIterator(a1))
  {
    *(_BYTE *)(a1 + 67) = 1;
    return 0LL;
  }

  if (*(_BYTE *)(*(void *)a1 + 294LL)) {
    return 0LL;
  }
  return BOMStorageSizeOfBlock( **(void **)a1,  *(_DWORD *)(*(void *)(*(void *)(a1 + 8) + 24LL) + 4LL * *(unsigned int *)(a1 + 20)));
}

uint64_t BOMTreeRemoveValue(uint64_t a1, const void *a2, size_t a3)
{
  uint64_t v3 = 1LL;
  if (a1 && a2)
  {
    if (a3 || *(_BYTE *)(a1 + 294))
    {
      if (*(_BYTE *)(a1 + 293))
      {
        uint64_t v6 = *(void *)(a1 + 24);
        uint64_t v3 = _findRemove(a1, &v6, 0LL, 0LL, 0LL, 0LL, a2, a3, 0LL);
        if (!(_DWORD)v3)
        {
          --*(_DWORD *)(a1 + 20);
          *(_BYTE *)(a1 + 292) = 1;
        }
      }

      else
      {
        uint64_t v3 = 1LL;
        fwrite("tree is read-only\n", 0x12uLL, 1uLL, (FILE *)*MEMORY[0x1895F89D0]);
      }
    }

    else
    {
      return 1LL;
    }
  }

  return v3;
}

uint64_t BOMTreeIteratorNext(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = result;
    if (!*(_BYTE *)(result + 67))
    {
      if (!*(_BYTE *)(result + 65) && (unint64_t v5 = *(_DWORD **)(result + 8)) != 0LL && *v5 == *(_DWORD *)(result + 16)
        || (uint64_t result = _revalidateIterator(result), (_DWORD)result))
      {
        if (*(_BYTE *)(v1 + 66))
        {
          unsigned int v2 = *(_DWORD *)(v1 + 20) + 1;
          *(_DWORD *)(v1 + 20) = v2;
          uint64_t v3 = *(void *)(v1 + 8);
          if (v2 >= *(unsigned __int16 *)(v3 + 16))
          {
            *(_DWORD *)(v1 + 20) = 0;
            int v4 = *(_DWORD *)(v3 + 8);
            if (!v4
              || (*(_DWORD *)(v1 + 16) = v4,
                  uint64_t result = (uint64_t)_findPage(*(void *)v1, v4),
                  (*(void *)(v1 + 8) = result) == 0LL))
            {
              *(_BYTE *)(v1 + 67) = 1;
            }
          }
        }

        else
        {
          *(_BYTE *)(v1 + 66) = 1;
        }

        *(_BYTE *)(v1 + 40) = 0;
        *(_BYTE *)(v1 + 64) = 0;
      }

      else
      {
        *(_BYTE *)(v1 + 67) = 1;
      }
    }
  }

  return result;
}

void BOMTreeIteratorFree(char *a1)
{
  if (a1)
  {
    *(_WORD *)(a1 + 65) = 1;
    a1[67] = 1;
    unsigned int v2 = (void *)*((void *)a1 + 3);
    if (v2)
    {
      free(v2);
      *((void *)a1 + 3) = 0LL;
    }

    a1[40] = 0;
    uint64_t v3 = (void *)*((void *)a1 + 6);
    if (v3)
    {
      free(v3);
      *((void *)a1 + 6) = 0LL;
    }

    a1[64] = 0;
    *((_DWORD *)a1 + 4) = -1;
    *((void *)a1 + 1) = 0LL;
    uint64_t v4 = *(void *)a1;
    unint64_t v5 = *(const __CFArray **)(*(void *)a1 + 304LL);
    if (v5)
    {
      CFIndex v6 = BOMCFArrayMaxRange(v5);
      CFIndex v8 = v7;
      v10.location = v6;
      v10.size_t length = v8;
      FirstIndexOfunint64_t Value = CFArrayGetFirstIndexOfValue(*(CFArrayRef *)(v4 + 304), v10, a1);
      if (FirstIndexOfValue != -1)
      {
        CFArrayRemoveValueAtIndex(*(CFMutableArrayRef *)(v4 + 304), FirstIndexOfValue);
        if (!CFArrayGetCount(*(CFArrayRef *)(v4 + 304)))
        {
          CFRelease(*(CFTypeRef *)(v4 + 304));
          *(void *)(v4 + 304) = 0LL;
        }
      }
    }

    free(a1);
  }

uint64_t _SyncCache(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = result;
    for (uint64_t i = 32LL; i != 288; i += 8LL)
    {
      uint64_t v3 = *(void *)(v1 + i);
      if (v3)
      {
        if ((*(_WORD *)(v3 + 4) & 2) != 0) {
          uint64_t result = _WritePage(v1, v3);
        }
      }
    }
  }

  return result;
}

uint64_t _WritePage(uint64_t a1, uint64_t a2)
{
  uint64_t result = BOMStreamWithBlockID(*(void *)a1, *(_DWORD *)a2, *(unsigned int *)(a1 + 312), 1);
  if (result)
  {
    uint64_t v4 = result;
    BOMStreamWriteUInt16(result, *(_WORD *)(a2 + 4) & 1);
    BOMStreamWriteUInt16(v4, *(_WORD *)(a2 + 16));
    BOMStreamWriteUInt32(v4, *(_DWORD *)(a2 + 8));
    BOMStreamWriteUInt32(v4, *(_DWORD *)(a2 + 12));
    if (*(_WORD *)(a2 + 16))
    {
      unint64_t v5 = 0LL;
      do
      {
        BOMStreamWriteUInt32(v4, *(_DWORD *)(*(void *)(a2 + 32) + 4 * v5));
        BOMStreamWriteUInt32(v4, *(_DWORD *)(*(void *)(a2 + 24) + 4 * v5++));
        unint64_t v6 = *(unsigned __int16 *)(a2 + 16);
      }

      while (v5 < v6);
    }

    else
    {
      unint64_t v6 = 0LL;
    }

    BOMStreamWriteUInt32(v4, *(_DWORD *)(*(void *)(a2 + 32) + 4 * v6));
    uint64_t result = BOMStreamFree(v4);
    *(_WORD *)(a2 + 4) &= ~2u;
  }

  return result;
}

uint64_t BOMTreeStorage(uint64_t result)
{
  if (result) {
    return *(void *)result;
  }
  return result;
}

uint64_t BOMTreeSetCompareFunc(uint64_t result, uint64_t a2)
{
  if (result) {
    *(void *)(result + 296) = a2;
  }
  return result;
}

uint64_t BOMTreeCount(uint64_t result)
{
  if (result) {
    return *(unsigned int *)(result + 20);
  }
  return result;
}

uint64_t BOMTreeSetValue(void *a1, const void *a2, size_t a3, uint64_t a4, uint64_t a5)
{
  BOOL v22 = 0;
  uint64_t v5 = 1LL;
  if (!a1 || !a2) {
    return v5;
  }
  if (!a3 && !*((_BYTE *)a1 + 294)) {
    return 1LL;
  }
  if (!*((_BYTE *)a1 + 293))
  {
    uint64_t v5 = 1LL;
    fwrite("tree is read-only\n", 0x12uLL, 1uLL, (FILE *)*MEMORY[0x1895F89D0]);
    return v5;
  }

  PagesForKey = _FindPagesForKey((uint64_t)a1, a2, a3);
  if (!PagesForKey) {
    return 1LL;
  }
  CFIndex v12 = (uint64_t *)PagesForKey;
  if (*((_BYTE *)a1 + 294))
  {
    int v13 = (int)a2;
    goto LABEL_9;
  }

  BOOL v15 = BOMStackPeek(PagesForKey);
  if (!v15) {
    goto LABEL_23;
  }
  BOOL v16 = v15;
  unsigned int IndexForKey = _findIndexForKey((uint64_t)a1, (uint64_t)v15, a2, a3, &v22);
  if (!v22)
  {
    uint64_t v19 = BOMStorageNewBlock(*a1);
    if (!(_DWORD)v19) {
      goto LABEL_23;
    }
    int v13 = v19;
LABEL_9:
    uint64_t v14 = BOMStorageNewBlock(*a1);
    if (!(_DWORD)v14) {
      goto LABEL_23;
    }
    goto LABEL_10;
  }

  uint64_t v18 = v16[4];
  int v13 = *(_DWORD *)(v16[3] + 4LL * IndexForKey);
  uint64_t v14 = *(unsigned int *)(v18 + 4LL * IndexForKey);
  if (!(_DWORD)v14) {
    goto LABEL_9;
  }
LABEL_10:
  if (!BOMStorageSetBlockData(*a1, v14, a4, a5)
    && !_PageSetValue((uint64_t)a1, v12, a2, a3, v13, v14))
  {
    if (!v22) {
      ++*((_DWORD *)a1 + 5);
    }
    uint64_t v5 = 0LL;
    *((_BYTE *)a1 + 292) = 1;
    goto LABEL_25;
  }

void **_FindPagesForKey(uint64_t a1, const void *a2, size_t a3)
{
  unint64_t v6 = BOMStackNew();
  if (!_findPagesForKey(a1, (char *)v6, a2, a3))
  {
    BOMStackFree(v6);
    return 0LL;
  }

  return v6;
}

uint64_t _findIndexForKey(uint64_t a1, uint64_t a2, const void *a3, size_t a4, BOOL *a5)
{
  if (*(_WORD *)(a2 + 16))
  {
    int v9 = 0;
    int v10 = *(unsigned __int16 *)(a2 + 16) - 1;
    while (1)
    {
      uint64_t v11 = v9 + ((v10 - v9) >> 1);
      CFIndex v12 = (void *)*(unsigned int *)(*(void *)(a2 + 24) + 4LL * v11);
      if (!(_DWORD)v12) {
        break;
      }
      if (*(_BYTE *)(a1 + 294)) {
        goto LABEL_13;
      }
      unint64_t v13 = BOMStorageSizeOfBlock(*(void *)a1, v12);
      size_t v14 = v13;
      unint64_t v15 = *(unsigned int *)(a1 + 352);
      CFIndex v12 = *(void **)(a1 + 344);
      if (v13 > v15)
      {
        unint64_t v16 = (2 * v15);
        if (v13 > v16) {
          LODWORD(v16) = v13;
        }
        *(_DWORD *)(a1 + 352) = v16;
        if (v12)
        {
          free(v12);
          *(void *)(a1 + 344) = 0LL;
          LODWORD(v16) = *(_DWORD *)(a1 + 352);
        }

        CFIndex v12 = BOM_malloc(v16);
        *(void *)(a1 + 344) = v12;
      }

      BOMStorageCopyFromBlock(*(void *)a1, *(_DWORD *)(*(void *)(a2 + 24) + 4 * v11), v12);
LABEL_14:
      CFRange v17 = *(uint64_t (**)(const void *, size_t, void *, size_t))(a1 + 296);
      if (v17)
      {
        int v18 = v17(a3, a4, v12, v14);
      }

      else
      {
        if (*(_BYTE *)(a1 + 294))
        {
          if (v12 <= a3) {
            int v19 = 0;
          }
          else {
            int v19 = -1;
          }
          if (v12 < a3) {
            int v18 = 1;
          }
          else {
            int v18 = v19;
          }
          goto LABEL_23;
        }

        if (v12 == a3)
        {
          if (!a5) {
            return v11;
          }
          int v18 = 0;
          BOOL v20 = 1;
          goto LABEL_25;
        }

        if (a3)
        {
          if (!v12)
          {
            int v18 = 1;
            goto LABEL_23;
          }

          if (a4 >= v14) {
            size_t v21 = v14;
          }
          else {
            size_t v21 = a4;
          }
          int v18 = memcmp(a3, v12, v21);
          if (v18) {
            goto LABEL_23;
          }
          if (v14 <= a4)
          {
            int v18 = v14 < a4;
            goto LABEL_23;
          }
        }

        int v18 = -1;
      }

uint64_t _PageSetValue(uint64_t a1, uint64_t *a2, const void *a3, size_t a4, int a5, int a6)
{
  BOOL v47 = 0;
  uint64_t v6 = 1LL;
  if (a5)
  {
    if (a6)
    {
      unint64_t v13 = BOMStackPop(a2);
      if (v13)
      {
        uint64_t v14 = (uint64_t)v13;
        BOOL v15 = (*((_WORD *)v13 + 2) & 1) == 0;
        _invalidateIteratorsForPageID(a1, *(_DWORD *)v13);
        unsigned int IndexForKey = _findIndexForKey(a1, v14, a3, a4, &v47);
        if (v47)
        {
          unsigned __int16 v17 = *(_WORD *)(v14 + 16);
        }

        else
        {
          uint64_t v18 = *(void *)(v14 + 24);
          if (*(_DWORD *)(v18 + 4LL * IndexForKey))
          {
            if (*(_BYTE *)(a1 + 295)) {
              *(_BYTE *)(a1 + 295) = 0;
            }
            int v19 = *(unsigned __int16 *)(v14 + 16);
            LODWORD(v20) = v19 - IndexForKey;
            if (v19 != IndexForKey)
            {
              uint64_t v21 = *(void *)(v14 + 32);
              else {
                uint64_t v20 = v20;
              }
              unsigned int v22 = v15 + v19;
              unsigned int v23 = *(unsigned __int16 *)(v14 + 16);
              do
              {
                *(_DWORD *)(v18 + 4LL * v23) = *(_DWORD *)(v18 + 4LL * (v23 - 1));
                *(_DWORD *)(v21 + 4LL * v22) = *(_DWORD *)(v21 + 4LL * (v22 - 1));
                --v23;
                --v22;
                --v20;
              }

              while (v20);
            }
          }

          else
          {
            LOWORD(v19) = *(_WORD *)(v14 + 16);
          }

          *(_DWORD *)(v18 + 4LL * IndexForKey) = a5;
          unsigned __int16 v17 = v19 + 1;
          *(_WORD *)(v14 + 16) = v19 + 1;
        }

        *(_DWORD *)(*(void *)(v14 + 32) + 4LL * (IndexForKey + v15)) = a6;
        *(_WORD *)(v14 + 4) |= 2u;
        if (*(_DWORD *)(a1 + 316) >= v17)
        {
          uint64_t v6 = 0LL;
        }

        else
        {
          BOOL v24 = _NewPage(a1, 0);
          if (v24)
          {
            uint64_t v25 = (unsigned int *)v24;
            *((_WORD *)v24 + 2) = *((_WORD *)v24 + 2) & 0xFFFC | *(_WORD *)(v14 + 4) & 1 | 2;
            if ((*(_WORD *)(v14 + 4) & 1) == 0
              || (int v26 = *(_DWORD *)v24,
                  int v27 = *(_DWORD *)v14,
                  *((_DWORD *)v24 + 2) = *(_DWORD *)(v14 + 8),
                  *(_DWORD *)(v14 + 8) = v26,
                  *((_DWORD *)v24 + 3) = v27,
                  (int v28 = *((_DWORD *)v24 + 2)) == 0))
            {
LABEL_25:
              if (*(_BYTE *)(a1 + 295))
              {
                LODWORD(v30) = *(_DWORD *)(a1 + 316) - 1;
                unsigned int v31 = *(unsigned __int16 *)(v14 + 16);
              }

              else
              {
                unsigned int v31 = *(unsigned __int16 *)(v14 + 16);
                LODWORD(v30) = v31 >> 1;
              }

              if ((int)v30 + 1 >= (int)v31)
              {
                uint64_t v34 = *((void *)v25 + 4);
                unsigned __int16 v37 = *((_WORD *)v25 + 8);
                uint64_t v30 = (int)v30;
                uint64_t v38 = v31;
                uint64_t v32 = *(void *)(v14 + 24);
                uint64_t v33 = *(void *)(v14 + 32);
              }

              else
              {
                uint64_t v32 = *(void *)(v14 + 24);
                uint64_t v33 = *(void *)(v14 + 32);
                uint64_t v35 = *((void *)v25 + 3);
                uint64_t v34 = *((void *)v25 + 4);
                uint64_t v30 = (int)v30;
                uint64_t v36 = (int)v30 + 1LL;
                unsigned __int16 v37 = *((_WORD *)v25 + 8);
                do
                {
                  *(_DWORD *)(v35 + 4LL * v37) = *(_DWORD *)(v32 + 4 * v36);
                  *(_DWORD *)(v34 + 4LL * v37++) = *(_DWORD *)(v33 + 4 * v36);
                  *(_DWORD *)(v32 + 4 * v36) = 0;
                  *((_WORD *)v25 + 8) = v37;
                  *(_DWORD *)(v33 + 4 * v36++) = 0;
                  uint64_t v38 = *(unsigned __int16 *)(v14 + 16);
                }

                while (v36 < v38);
                LOWORD(v31) = *(_WORD *)(v14 + 16);
              }

              *(_DWORD *)(v34 + 4LL * v37) = *(_DWORD *)(v33 + 4 * v38);
              *(_DWORD *)(v33 + 4 * v38) = 0;
              *(_WORD *)(v14 + 16) = v31 - v37;
              uint64_t v39 = *(unsigned int *)(v32 + 4 * v30);
              if ((*(_BYTE *)(v14 + 4) & 1) == 0)
              {
                *(_DWORD *)(v32 + 4 * v30) = 0;
                *(_WORD *)(v14 + 16) = v31 - v37 - 1;
              }

              _addPageToCache(a1, (uint64_t)v25);
              if (BOMStackIsEmpty((uint64_t)a2))
              {
                uint64_t v40 = _NewPage(a1, 0);
                uint64_t v6 = 1LL;
                if (v40)
                {
                  uint64_t v41 = v40;
                  uint64_t v42 = (_DWORD *)v40[4];
                  *(_DWORD *)v40[3] = v39;
                  *uint64_t v42 = *(_DWORD *)v14;
                  v42[1] = *v25;
                  *((_WORD *)v40 + 8) = 1;
                  *((_WORD *)v40 + 2) |= 2u;
                  _addPageToCache(a1, v14);
                  uint64_t v6 = 0LL;
                  *(void *)(a1 + 24) = v41;
                }
              }

              else
              {
                uint64_t v6 = _PageSetValue(a1, a2, a3, a4, v39, *v25);
              }

              goto LABEL_44;
            }

            Page = _findPage(a1, v28);
            if (Page)
            {
              if (*((_DWORD *)Page + 3) == *(_DWORD *)v14)
              {
                *((_DWORD *)Page + 3) = *v25;
                *((_WORD *)Page + 2) |= 2u;
                goto LABEL_25;
              }

              int v43 = *__error();
              gid_t v44 = "internal btree error";
              uint64_t v6 = 1LL;
              int v45 = 1998;
            }

            else
            {
              int v43 = *__error();
              gid_t v44 = "missing tree page";
              uint64_t v6 = 1LL;
              int v45 = 1994;
            }

            _BOMExceptionHandlerCall( (uint64_t)v44,  1,  "/Library/Caches/com.apple.xbs/Sources/Bom/Storage/BOMTree.c",  v45,  v43);
          }

          else
          {
            uint64_t v6 = 1LL;
          }
        }

uint64_t BOMTreeGetValueSize(uint64_t a1, const void *a2, size_t a3, uint64_t *a4)
{
  uint64_t result = 1LL;
  if (a1 && a2 && a4 && (a3 || *(_BYTE *)(a1 + 294)))
  {
    uint64_t PagesForKey = _findPagesForKey(a1, 0LL, a2, a3);
    if (PagesForKey && (uint64_t v10 = PagesForKey, IndexForKey = _findIndexForKey(a1, PagesForKey, a2, a3, &v13), v13))
    {
      uint64_t v12 = BOMStorageSizeOfBlock(*(void *)a1, *(_DWORD *)(*(void *)(v10 + 32) + 4LL * IndexForKey));
      uint64_t result = 0LL;
      *a4 = v12;
    }

    else
    {
      return 1LL;
    }
  }

  return result;
}

unint64_t BOMTreeGetValue(uint64_t a1, const void *a2, size_t a3)
{
  unint64_t result = 0LL;
  BOOL v13 = 0;
  if (a1 && a2)
  {
    if (!a3 && !*(_BYTE *)(a1 + 294)) {
      return 0LL;
    }
    unint64_t result = _findPagesForKey(a1, 0LL, a2, a3);
    if (!result) {
      return result;
    }
    unint64_t v7 = result;
    unsigned int IndexForKey = _findIndexForKey(a1, result, a2, a3, &v13);
    if (!v13) {
      return 0LL;
    }
    unsigned int v9 = IndexForKey;
    unint64_t result = BOMStorageSizeOfBlock(*(void *)a1, *(_DWORD *)(*(void *)(v7 + 32) + 4LL * IndexForKey));
    if (!result) {
      return result;
    }
    unint64_t v10 = result;
    uint64_t v11 = *(void **)(a1 + 328);
    if (v11)
    {
      free(*(void **)(a1 + 328));
      *(void *)(a1 + 328) = 0LL;
      unint64_t v12 = (2 * *(_DWORD *)(a1 + 336));
      if (v10 <= v12) {
        unint64_t result = v12;
      }
      else {
        unint64_t result = v10;
      }
      *(_DWORD *)(a1 + 336) = result;
    }

    else
    {
      *(_DWORD *)(a1 + 336) = result;
      unint64_t result = result;
    }

    uint64_t v11 = BOM_malloc(result);
    *(void *)(a1 + 328) = v11;
LABEL_16:
    return 0LL;
  }

  return result;
}

uint64_t _findRemove( uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, const void *a7, size_t a8, char *a9)
{
  uint64_t v14 = a2;
  uint64_t v15 = a1;
  unint64_t v16 = a9;
  BOOL v81 = 0;
  uint64_t v17 = *a2;
  uint64_t v80 = 0LL;
  char v79 = 0;
  if (!a9) {
    unint64_t v16 = &v79;
  }
  int v78 = v16;
  unsigned int IndexForKey = _findIndexForKey(a1, v17, a7, a8, &v81);
  unsigned int v19 = IndexForKey;
  *(_DWORD *)(v17 + 20) = IndexForKey;
  if ((*(_BYTE *)(v17 + 4) & 1) != 0)
  {
    BOOL v23 = v81;
    uint64_t result = 1LL;
    if (!v81) {
      return result;
    }
LABEL_42:
    if (v23)
    {
      _invalidateIteratorsForPageID(v15, *(_DWORD *)v17);
LABEL_45:
      unsigned int v34 = *(unsigned __int16 *)(v17 + 16);
      uint64_t v35 = *(void *)(v17 + 24);
      LODWORD(v36) = v34 - v19;
      if (v34 == v19)
      {
        unsigned int v37 = 0;
        unsigned int v38 = 0;
        *(_DWORD *)(v35 + 4LL * (v19 - 1)) = 0;
        uint64_t v39 = *(void *)(v17 + 32);
      }

      else
      {
        unsigned int v37 = *(_DWORD *)(v35 + 4LL * v19);
        uint64_t v39 = *(void *)(v17 + 32);
        unsigned int v38 = *(_DWORD *)(v39 + 4LL * v19);
        else {
          uint64_t v36 = v36;
        }
        unsigned int v40 = v19;
        do
        {
          *(_DWORD *)(v35 + 4LL * v40) = *(_DWORD *)(v35 + 4LL * (v40 + 1));
          *(_DWORD *)(v39 + 4LL * v40) = *(_DWORD *)(v39 + 4LL * (v40 + 1));
          ++v40;
          --v36;
        }

        while (v36);
      }

      *(_DWORD *)(v39 + 4LL * v34) = 0;
      *(_WORD *)(v17 + 16) = v34 - 1;
      if ((*(_WORD *)(v17 + 4) & 1) != 0)
      {
        if (*(_BYTE *)(v15 + 294)) {
          BOOL v41 = 1;
        }
        else {
          BOOL v41 = v37 == 0;
        }
        if (!v41) {
          BOMStorageFreeBlock(*(void *)v15, v37);
        }
        if (v38) {
          BOMStorageFreeBlock(*(void *)v15, v38);
        }
      }

      __int16 v42 = *(_WORD *)(v17 + 4);
      *(_WORD *)(v17 + 4) = v42 | 2;
      unsigned int v43 = *(unsigned __int16 *)(v17 + 16);
      if ((v42 & 1) != 0 && a6 && v19 == v43)
      {
        *(_WORD *)(a6 + 4) |= 2u;
        unsigned int v43 = *(unsigned __int16 *)(v17 + 16);
      }

      unsigned int v44 = *(_DWORD *)(v15 + 324);
      if (v44 <= v43)
      {
        uint64_t result = 0LL;
        *int v78 = 0;
        return result;
      }

      if (v17 == *(void *)(v15 + 24))
      {
        if (!(*(_WORD *)(v17 + 4) & 1 | v43))
        {
          int v51 = **(_DWORD **)(v17 + 32);
          if (v51)
          {
            Page = _findPage(v15, v51);
            Page[2] &= ~8u;
            _removePageFromCache(v15, Page);
            *(void *)(v15 + 24) = Page;
            BOMStorageFreeBlock(*(void *)v15, *(_DWORD *)v17);
            _FreePage((void *)v17);
          }
        }
      }

      else if (a3 | a4)
      {
        uint64_t v73 = a3;
        time_t v75 = v14;
        int v45 = (_WORD *)*v14;
        if (a3) {
          uint64_t v46 = a3;
        }
        else {
          uint64_t v46 = a4;
        }
        uint64_t v47 = a5;
        if (!a3) {
          uint64_t v47 = a6;
        }
        if (a4) {
          BOOL v48 = a3 != 0;
        }
        else {
          BOOL v48 = 0;
        }
        BOOL v70 = v48;
        if (v48)
        {
          unsigned int v49 = *(unsigned __int16 *)(a3 + 16);
          unsigned int v50 = *(unsigned __int16 *)(a4 + 16);
          if (v49 >= v50)
          {
            if (v49 <= v50)
            {
              int v53 = *(_DWORD *)(*(void *)(a6 + 32) + 4LL * *(unsigned int *)(a6 + 20));
              if (*(_DWORD *)v45 == v53) {
                uint64_t v46 = a4;
              }
              else {
                uint64_t v46 = a3;
              }
              if (*(_DWORD *)v45 != v53) {
                a6 = a5;
              }
            }

            else
            {
              uint64_t v46 = a3;
              a6 = a5;
            }
          }

          else
          {
            uint64_t v46 = a4;
          }
        }

        else
        {
          a6 = v47;
        }

        unsigned int v54 = *(unsigned __int16 *)(v46 + 16);
        uint64_t v55 = a4;
        BOOL v41 = v46 == a4;
        BOOL v56 = v46 == a4;
        if (v41) {
          uint32_t v57 = v45;
        }
        else {
          uint32_t v57 = (_WORD *)v46;
        }
        if ((v45[2] & 1) != 0) {
          _invalidateIteratorsForPageID(v15, *(_DWORD *)v46);
        }
        int v58 = *(_DWORD *)(a6 + 20) - (v46 != v55);
        if ((v57[2] & 1) == 0)
        {
          uint64_t v59 = (unsigned __int16)v57[8];
          *(_DWORD *)(*((void *)v57 + 3) + 4 * v59) = *(_DWORD *)(*(void *)(a6 + 24) + 4LL * v58);
          v57[8] = v59 + 1;
          v57[2] |= 2u;
        }

        if (v44 < v54)
        {
          _shiftKeysAndValues(v15, (uint64_t)v45, v46, v56);
          int v60 = *(_DWORD *)(*((void *)v57 + 3) + 4LL * (unsigned __int16)v57[8] - 4);
          uint64_t v61 = *(void *)(a6 + 24);
          if (*(_DWORD *)(v61 + 4LL * v58) != v60)
          {
            *(_DWORD *)(v61 + 4LL * v58) = v60;
            *(_WORD *)(a6 + 4) |= 2u;
          }

          uint64_t v62 = v75;
          char v63 = 0;
          if ((v57[2] & 1) == 0)
          {
            unsigned __int16 v64 = v57[8] - 1;
            v57[8] = v64;
            *(_DWORD *)(*((void *)v57 + 3) + 4LL * v64) = 0;
            v57[2] |= 2u;
          }

          goto LABEL_112;
        }

        uint64_t v65 = v55;
        _shiftKeysAndValues(v15, v46, (uint64_t)v45, v46 != v55);
        if (v70)
        {
          uint64_t v62 = v75;
          *(_DWORD *)(v73 + 8) = *(_DWORD *)v65;
          *(_DWORD *)(v65 + 12) = *(_DWORD *)v73;
          *(_WORD *)(v73 + 4) |= 2u;
        }

        else if (v73)
        {
          *(_DWORD *)(v73 + 8) = 0;
          uint64_t v65 = v73;
          uint64_t v62 = v75;
        }

        else
        {
          uint64_t v62 = v75;
          if (!v65)
          {
LABEL_111:
            v45[2] &= ~8u;
            _removePageFromCache(v15, v45);
            BOMStorageFreeBlock(*(void *)v15, *(_DWORD *)v45);
            _FreePage(v45);
            int v45 = 0LL;
            char v63 = 1;
LABEL_112:
            uint64_t result = 0LL;
            *int v78 = v63;
            *uint64_t v62 = (uint64_t)v45;
            return result;
          }

          *(_DWORD *)(v65 + 12) = 0;
        }

        *(_WORD *)(v65 + 4) |= 2u;
        goto LABEL_111;
      }

      return 0LL;
    }

uint64_t BOMTreeCopyToTree(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = 1LL;
  if (a1 && a2)
  {
    if (!*(_DWORD *)(a2 + 20)) {
      *(_BYTE *)(a2 + 295) = 1;
    }
    uint64_t v4 = (char *)BOMTreeIteratorNew(a1, 0LL, 0LL, 0LL);
    if (!v4) {
      goto LABEL_13;
    }
    for (uint64_t i = v4; ; BOMTreeIteratorNext((uint64_t)i))
    {
      if (BOMTreeIteratorIsAtEnd((uint64_t)i))
      {
        uint64_t v3 = 0LL;
        goto LABEL_11;
      }

      uint64_t v6 = (const void *)BOMTreeIteratorKey((uint64_t)i);
      size_t v7 = BOMTreeIteratorKeySize((uint64_t)i);
      uint64_t v8 = BOMTreeIteratorValue((uint64_t)i);
      uint64_t v9 = BOMTreeIteratorValueSize((uint64_t)i);
    }

    uint64_t v3 = 1LL;
LABEL_11:
    BOMTreeIteratorFree(i);
  }

  if (a2) {
LABEL_13:
  }
    *(_BYTE *)(a2 + 295) = 0;
  return v3;
}

uint64_t BOMTreeIteratorValue(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = result;
    if (*(_BYTE *)(result + 67)) {
      return 0LL;
    }
    if (!*(_BYTE *)(result + 65) && (unsigned int v2 = *(_DWORD **)(result + 8)) != 0LL && *v2 == *(_DWORD *)(result + 16)
      || _revalidateIterator(result))
    {
      if (!*(_BYTE *)(v1 + 64))
      {
        unint64_t v3 = BOMStorageSizeOfBlock( **(void **)v1,  *(_DWORD *)(*(void *)(*(void *)(v1 + 8) + 32LL) + 4LL * *(unsigned int *)(v1 + 20)));
        uint64_t v4 = *(void **)(v1 + 48);
        unint64_t v5 = *(void *)(v1 + 56);
        if (v3 > v5)
        {
          unint64_t v6 = v3;
          if (v4)
          {
            free(*(void **)(v1 + 48));
            *(void *)(v1 + 48) = 0LL;
            unint64_t v5 = *(void *)(v1 + 56);
          }

          if (v6 <= 2 * v5) {
            size_t v7 = 2 * v5;
          }
          else {
            size_t v7 = v6;
          }
          *(void *)(v1 + 56) = v7;
          uint64_t v4 = BOM_malloc(v7);
          *(void *)(v1 + 48) = v4;
        }

        if (BOMStorageCopyFromBlock( **(void **)v1,  *(_DWORD *)(*(void *)(*(void *)(v1 + 8) + 32LL) + 4LL * *(unsigned int *)(v1 + 20)),  v4)) {
          return 0LL;
        }
        *(_BYTE *)(v1 + 64) = 1;
      }

      return *(void *)(v1 + 48);
    }

    else
    {
      uint64_t result = 0LL;
      *(_BYTE *)(v1 + 67) = 1;
    }
  }

  return result;
}

uint64_t BOMTreeIteratorValueSize(uint64_t a1)
{
  if (!a1 || *(_BYTE *)(a1 + 67)) {
    return 0LL;
  }
  if (*(_BYTE *)(a1 + 65) || (uint64_t v3 = *(void *)(a1 + 8)) == 0 || *(_DWORD *)v3 != *(_DWORD *)(a1 + 16))
  {
    if (!_revalidateIterator(a1))
    {
      *(_BYTE *)(a1 + 67) = 1;
      return 0LL;
    }

    uint64_t v3 = *(void *)(a1 + 8);
  }

  return BOMStorageSizeOfBlock(**(void **)a1, *(_DWORD *)(*(void *)(v3 + 32) + 4LL * *(unsigned int *)(a1 + 20)));
}

uint64_t BOMTreeSetDensePacking(uint64_t result, char a2)
{
  if (result) {
    *(_BYTE *)(result + 295) = a2;
  }
  return result;
}

_DWORD *BOMTreeIteratorSet(uint64_t a1, const void *a2, size_t a3, BOOL *a4)
{
  *(_BYTE *)(a1 + 65) = 0;
  *(_BYTE *)(a1 + 67) = 0;
  uint64_t result = (_DWORD *)_findPagesForKey(*(void *)a1, 0LL, a2, a3);
  *(void *)(a1 + 8) = result;
  if (result)
  {
    *(_DWORD *)(a1 + 16) = *result;
    uint64_t result = (_DWORD *)_findIndexForKey(*(void *)a1, (uint64_t)result, a2, a3, a4);
    *(_DWORD *)(a1 + 20) = (_DWORD)result;
    *(_BYTE *)(a1 + 66) = 1;
    uint64_t v9 = *(void *)(a1 + 8);
    if (result >= *(unsigned __int16 *)(v9 + 16))
    {
      *(_DWORD *)(a1 + 20) = 0;
      int v10 = *(_DWORD *)(v9 + 8);
      if (!v10
        || (*(_DWORD *)(a1 + 16) = v10, uint64_t result = _findPage(*(void *)a1, v10), (*(void *)(a1 + 8) = result) == 0LL))
      {
        *(_BYTE *)(a1 + 67) = 1;
      }
    }
  }

  else
  {
    *(_WORD *)(a1 + 66) = 256;
  }

  return result;
}

void *_findPage(uint64_t a1, int a2)
{
  if (a2)
  {
    if (a1)
    {
      uint64_t v4 = 0LL;
      while (1)
      {
        unint64_t v5 = *(void **)(a1 + 32 + v4);
        if (v5)
        {
          if (*(_DWORD *)v5 == a2) {
            break;
          }
        }

        v4 += 8LL;
        if (v4 == 256) {
          goto LABEL_7;
        }
      }
    }

    else
    {
LABEL_7:
      unint64_t v5 = 0LL;
    }

    int v6 = 0;
    while (1)
    {
      if (v5) {
        return v5;
      }
      uint64_t v7 = *(int *)(a1 + 288);
      unint64_t v5 = *(void **)(a1 + 8 * v7 + 32);
      if (!v5)
      {
        unint64_t v5 = _NewPage(a1, a2);
        if (!v5) {
          return v5;
        }
        uint64_t v7 = *(int *)(a1 + 288);
        *(void *)(a1 + 8 * v7 + 32) = v5;
        goto LABEL_22;
      }

      __int16 v8 = *((_WORD *)v5 + 2);
      if ((v8 & 0xC) == 4) {
        break;
      }
      if ((v8 & 4) != 0)
      {
        unint64_t v5 = 0LL;
LABEL_22:
        int v11 = v6;
        goto LABEL_23;
      }

      int v11 = 0;
      *((_WORD *)v5 + 2) = v8 | 4;
      LODWORD(v7) = *(_DWORD *)(a1 + 288);
      unint64_t v5 = 0LL;
LABEL_23:
      int v12 = v7 + 1;
      BOOL v13 = -v12 < 0;
      int v14 = -v12 & 0x1F;
      int v15 = v12 & 0x1F;
      if (!v13) {
        int v15 = -v14;
      }
      *(_DWORD *)(a1 + 288) = v15;
      int v6 = v11 + 1;
      if (!v5 && v11 >= 32)
      {
        unint64_t v16 = __error();
        _BOMExceptionHandlerCall( (uint64_t)"btree cache is deadlocked",  0,  "/Library/Caches/com.apple.xbs/Sources/Bom/Storage/BOMTree.c",  2144,  *v16);
        return 0LL;
      }
    }

    if ((v8 & 2) != 0) {
      _WritePage(a1, (uint64_t)v5);
    }
    uint64_t v9 = (void *)v5[3];
    int v10 = (void *)v5[4];
    *(_OWORD *)unint64_t v5 = 0u;
    *((_OWORD *)v5 + 1) = 0u;
    v5[4] = 0LL;
    bzero(v9, 4LL * *(unsigned int *)(a1 + 316));
    bzero(v10, 4LL * *(unsigned int *)(a1 + 320));
    *(_DWORD *)unint64_t v5 = a2;
    v5[1] = -1LL;
    v5[3] = v9;
    v5[4] = v10;
    uint64_t v7 = *(int *)(a1 + 288);
    *(void *)(a1 + 8 * v7 + 32) = v5;
    goto LABEL_22;
  }

  return 0LL;
}

uint64_t _revalidateIterator(uint64_t a1)
{
  if (!*(_BYTE *)(a1 + 65))
  {
    Page = *(void **)(a1 + 8);
    if (Page)
    {
      int v5 = *(_DWORD *)(a1 + 16);
      if (*(_DWORD *)Page == v5) {
        goto LABEL_9;
      }
    }

    else
    {
      int v5 = *(_DWORD *)(a1 + 16);
    }

    Page = _findPage(*(void *)a1, v5);
    *(void *)(a1 + 8) = Page;
    if (!Page) {
      goto LABEL_11;
    }
    goto LABEL_9;
  }

  uint64_t PagesForKey = _findPagesForKey(*(void *)a1, 0LL, *(const void **)(a1 + 24), *(void *)(a1 + 32));
  *(void *)(a1 + 8) = PagesForKey;
  if (!PagesForKey) {
    goto LABEL_11;
  }
  int IndexForKey = _findIndexForKey( *(void *)a1,  PagesForKey,  *(const void **)(a1 + 24),  *(void *)(a1 + 32),  (BOOL *)(a1 + 66));
  Page = *(void **)(a1 + 8);
  *(_DWORD *)(a1 + 16) = *(_DWORD *)Page;
  *(_DWORD *)(a1 + 20) = IndexForKey;
  *(_BYTE *)(a1 + 65) = 0;
LABEL_9:
LABEL_11:
  uint64_t result = 0LL;
  *(_BYTE *)(a1 + 65) = 1;
  return result;
}

uint64_t BOMTreeVerifyLeaves(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = result;
    unsigned int v2 = *(char **)(result + 24);
    if (!v2) {
      return 0LL;
    }
    _SyncCache(result);
    if ((*((_WORD *)v2 + 2) & 1) == 0)
    {
      while (1)
      {
        uint64_t v3 = (char *)_NewPage(v1, **((_DWORD **)v2 + 4));
        if (!v3)
        {
          int v5 = *__error();
          int v6 = "verifier: can't make page";
          int v7 = 2642;
          goto LABEL_24;
        }

        uint64_t v4 = v3;
        unsigned int v2 = v4;
        if ((*((_WORD *)v4 + 2) & 1) != 0) {
          goto LABEL_11;
        }
      }

      int v5 = *__error();
      int v6 = "verifier: can't read page";
      int v7 = 2647;
      goto LABEL_24;
    }

    uint64_t v4 = v2;
LABEL_11:
    if (*((_DWORD *)v4 + 3))
    {
      int v5 = *__error();
      int v6 = "verifier: first leaf has prev value";
      int v7 = 2658;
LABEL_24:
      _BOMExceptionHandlerCall((uint64_t)v6, 1, "/Library/Caches/com.apple.xbs/Sources/Bom/Storage/BOMTree.c", v7, v5);
      return 0LL;
    }

    uint64_t v9 = v4 + 8;
    int v8 = *((_DWORD *)v4 + 2);
    if (v8)
    {
      while (1)
      {
        int v10 = (char *)_NewPage(v1, v8);
        if (!v10)
        {
          int v5 = *__error();
          int v6 = "verifier: can't make page";
          int v7 = 2666;
          goto LABEL_24;
        }

        int v11 = v10;
        if (_ReadPage(v1, (uint64_t)v10))
        {
          int v5 = *__error();
          int v6 = "verifier: can't read page";
          int v7 = 2671;
          goto LABEL_24;
        }

        if (*v9 != *(_DWORD *)v11)
        {
          int v5 = *__error();
          int v6 = "verifier: page->next != next->bid";
          int v7 = 2678;
          goto LABEL_24;
        }

        if (*((_DWORD *)v11 + 3) != *(_DWORD *)v4) {
          break;
        }
        uint64_t v9 = v11 + 8;
        int v8 = *((_DWORD *)v11 + 2);
        uint64_t v4 = v11;
        if (!v8) {
          goto LABEL_28;
        }
      }

      int v5 = *__error();
      int v6 = "verifier: next->prev != page->bid";
      int v7 = 2683;
      goto LABEL_24;
    }

    int v11 = v4;
LABEL_28:
    return 1LL;
  }

  return result;
}

uint64_t _BOMTreeDiagnosticTraverse(uint64_t a1, uint64_t a2, _DWORD *a3, _DWORD *a4, void *a5, void *a6)
{
  if (!a1) {
    return 1LL;
  }
  uint64_t v10 = a2;
  if (!a2) {
    uint64_t v10 = *(void *)(a1 + 24);
  }
  if ((*(_WORD *)(v10 + 4) & 1) != 0)
  {
    if (a3) {
      ++*a3;
    }
    if (!*(_WORD *)(v10 + 16))
    {
      uint64_t v16 = 0LL;
LABEL_28:
      int v13 = 0;
      if (a6)
      {
        unsigned int v19 = *(_DWORD *)(*(void *)(v10 + 32) + 4 * v16);
        if (v19)
        {
          int v13 = 0;
          *a6 += BOMStorageSizeOfBlock(*(void *)a1, v19);
        }
      }

      return v13 != 0;
    }

    uint64_t v16 = 0LL;
    while (!a5 || *(_BYTE *)(a1 + 294))
    {
      if (a6) {
        goto LABEL_19;
      }
LABEL_20:
    }

    *a5 += BOMStorageSizeOfBlock(*(void *)a1, *(_DWORD *)(*(void *)(v10 + 24) + 4 * v16));
    if (!a6) {
      goto LABEL_20;
    }
LABEL_19:
    *a6 += BOMStorageSizeOfBlock(*(void *)a1, *(_DWORD *)(*(void *)(v10 + 32) + 4 * v16));
    goto LABEL_20;
  }

  if (a4) {
    ++*a4;
  }
  if (*(_WORD *)(v10 + 16))
  {
    unint64_t v12 = 0LL;
    int v13 = 0;
    do
    {
      Page = _findPage(a1, *(_DWORD *)(*(void *)(v10 + 32) + 4 * v12));
      v13 += _BOMTreeDiagnosticTraverse(a1, Page, a3, a4, a5, a6);
      ++v12;
    }

    while (v12 < *(unsigned __int16 *)(v10 + 16));
  }

  else
  {
    unint64_t v12 = 0LL;
    int v13 = 0;
  }

  int v17 = *(_DWORD *)(*(void *)(v10 + 32) + 4 * v12);
  if (v17)
  {
    uint64_t v18 = _findPage(a1, v17);
    v13 += _BOMTreeDiagnosticTraverse(a1, v18, a3, a4, a5, a6);
  }

  return v13 != 0;
}

uint64_t _BOMTreePrintDiagnostics(uint64_t result)
{
  int v7 = 0;
  int v6 = 0;
  size_t v4 = 0LL;
  size_t v5 = 0LL;
  if (result)
  {
    uint64_t v1 = result;
    uint64_t result = _BOMTreeDiagnosticTraverse(result, 0LL, &v7, &v6, &v5, &v4);
    if (!(_DWORD)result)
    {
      int v2 = v6 + v7;
      uint64_t v3 = (FILE **)MEMORY[0x1895F89D0];
      fprintf((FILE *)*MEMORY[0x1895F89D0], "   # records: %d\n", *(_DWORD *)(v1 + 20));
      fprintf(*v3, "   # pages  : %d (%d)\n", v2, *(_DWORD *)(v1 + 312) * v2);
      fprintf(*v3, "     leaf   : %d (%d)\n", v7, *(_DWORD *)(v1 + 312) * v7);
      fprintf(*v3, "     branch : %d (%d)\n", v6, *(_DWORD *)(v1 + 312) * v6);
      fprintf(*v3, "   key size : %zd\n", v5);
      return fprintf(*v3, "   data size: %zd\n", v4);
    }
  }

  return result;
}

uint64_t BOMMemoryDump(unsigned __int8 *a1, uint64_t a2, const char *a3)
{
  uint64_t v3 = a2;
  uint64_t v29 = *MEMORY[0x1895F89C0];
  size_t v5 = (FILE **)MEMORY[0x1895F89E0];
  int v6 = (FILE *)*MEMORY[0x1895F89E0];
  __int16 v27 = a1;
  if (!a1)
  {
    fprintf(v6, "(%lu bytes) (NULL)\n", a2);
    return 0LL;
  }

  fprintf(v6, "(%lu bytes)\n", a2);
  if (v3 >= 1)
  {
    int v8 = v27;
    unint64_t v9 = (unint64_t)&v27[v3];
    uint64_t v10 = "";
    if (a3) {
      uint64_t v10 = a3;
    }
    uint64_t v25 = v3;
    int v26 = v10;
    while (1)
    {
      int v11 = v8;
      fprintf(*v5, "%s%08x:", v26, (_DWORD)v8 - (_DWORD)v27);
      uint64_t v12 = 0LL;
      int v13 = v28;
      do
      {
        fprintf(*v5, " %02x", *v8);
        uint64_t v14 = *v8;
        if ((v14 & 0x80) != 0) {
          int v15 = __maskrune(v14, 0x40000uLL);
        }
        else {
          int v15 = *(_DWORD *)(MEMORY[0x1895F8770] + 4 * v14 + 60) & 0x40000;
        }
        if (v15) {
          char v16 = v14;
        }
        else {
          char v16 = 46;
        }
        char *v13 = v16;
        int v17 = v13 + 1;
        uint64_t v18 = v12 + 1;
        if (v12 < 15)
        {
          unsigned int v19 = &v11[v18];
          if ((unint64_t)&v11[v18] < v9)
          {
            fprintf(*v5, "%02x", *v19);
            uint64_t v20 = *v19;
            if ((v20 & 0x80) != 0) {
              int v21 = __maskrune(v20, 0x40000uLL);
            }
            else {
              int v21 = *(_DWORD *)(MEMORY[0x1895F8770] + 4 * v20 + 60) & 0x40000;
            }
            if (v21) {
              char v22 = v20;
            }
            else {
              char v22 = 46;
            }
            int v17 = v13 + 2;
            v13[1] = v22;
            uint64_t v18 = v12 + 2;
          }
        }

        int v8 = &v11[v18];
        if (v18 > 15) {
          break;
        }
        int v13 = v17;
        uint64_t v12 = v18;
      }

      while ((unint64_t)v8 < v9);
      if (v18 > 15) {
        goto LABEL_29;
      }
      uint64_t v23 = 16 - v18;
      if (((16 - (_DWORD)v18) & 1) == 0) {
        goto LABEL_28;
      }
      fwrite("  ", 2uLL, 1uLL, *v5);
      if (v18 != 15) {
        break;
      }
LABEL_29:
      *int v17 = 0;
      fprintf(*v5, "  %s\n", v28);
    }

    uint64_t v23 = 15 - v18;
    do
    {
LABEL_28:
      fwrite("     ", 5uLL, 1uLL, *v5);
      v23 -= 2LL;
    }

    while (v23);
    goto LABEL_29;
  }

  return v3;
}

uint64_t BOMStorageDumpTree(uint64_t a1, const char *a2, unsigned int a3)
{
  size_t v4 = a2;
  uint64_t v5 = BOMTreeOpenWithName(a1, a2, 0);
  if (v5)
  {
    uint64_t v6 = v5;
    int v7 = (FILE **)MEMORY[0x1895F89E0];
    fprintf((FILE *)*MEMORY[0x1895F89E0], "        %s (%u entries)\n", v4, *(_DWORD *)(v5 + 20));
    uint64_t v26 = v6;
    int v8 = (char *)BOMTreeIteratorNew(v6, 0LL, 0LL, 0LL);
    if (!BOMTreeIteratorIsAtEnd((uint64_t)v8))
    {
      int v9 = HIWORD(a3) & 0xF;
      int v27 = v9;
      unsigned int v28 = a3;
      do
      {
        fprintf(*v7, "        %s   Key ", v4);
        uint64_t v10 = (unsigned __int8 *)BOMTreeIteratorKey((uint64_t)v8);
        uint64_t v11 = BOMTreeIteratorKeySize((uint64_t)v8);
        switch(v9)
        {
          case 3:
            BOMPathKeyDump((uint64_t)v10, v11);
            break;
          case 2:
            BOMPathIdDump(v10, v11);
            break;
          case 1:
            BOMPathDump((char *)v10);
            break;
          default:
            BOMMemoryDump(v10, v11, "        ");
            break;
        }

        fprintf(*v7, "        %s Value ", v4);
        uint64_t v12 = (unsigned __int8 *)BOMTreeIteratorValue((uint64_t)v8);
        unint64_t v13 = BOMTreeIteratorValueSize((uint64_t)v8);
        unint64_t v14 = v13;
        if ((a3 & 0x1000000) != 0)
        {
          if (v13 >= 4)
          {
            int v17 = v4;
            unsigned int v18 = a3;
            unsigned int v20 = *(_DWORD *)v12;
            v12 += 4;
            unsigned int v19 = v20;
            unsigned int v21 = bswap32(v20);
            char v22 = "ies";
            if (v20 == 0x1000000) {
              char v22 = "y";
            }
            fprintf(*v7, "(%lu bytes for %d entr%s)\n", v13, v21, v22);
            BOOL v15 = v19 != 0;
            v14 -= 4LL;
            unsigned int v16 = v18;
            size_t v4 = v17;
            if (!v14) {
              goto LABEL_32;
            }
LABEL_20:
            if (v15)
            {
              int v23 = (v16 >> 20) & 0xF;
              do
              {
                if ((v16 & 0x1000000) != 0) {
                  fprintf(*v7, "  %s", "        ");
                }
                switch(v23)
                {
                  case 3:
                    size_t v24 = BOMPathKeyDump((uint64_t)v12, v14);
                    break;
                  case 2:
                    size_t v24 = BOMPathIdDump(v12, v14);
                    break;
                  case 1:
                    size_t v24 = BOMPathDump((char *)v12);
                    break;
                  default:
                    size_t v24 = BOMMemoryDump(v12, v14, "        ");
                    break;
                }

                v12 += v24;
                v14 -= v24;
              }

              while (v14);
            }

            goto LABEL_32;
          }

          unsigned int v16 = 0;
          BOOL v15 = 1;
          if (v13) {
            goto LABEL_20;
          }
        }

        else
        {
          BOOL v15 = 1;
          unsigned int v16 = a3;
          if (v13) {
            goto LABEL_20;
          }
        }

LABEL_32:
        BOMTreeIteratorNext((uint64_t)v8);
        int v9 = v27;
        a3 = v28;
      }

      while (!BOMTreeIteratorIsAtEnd((uint64_t)v8));
    }

    fputc(10, *v7);
    if (v8) {
      BOMTreeIteratorFree(v8);
    }
    BOMTreeFree(v26);
    return 0LL;
  }

  else
  {
    fputc(10, (FILE *)*MEMORY[0x1895F89E0]);
    return 0xFFFFFFFFLL;
  }

void *_newBOMTree(uint64_t a1, const char *a2)
{
  size_t v4 = BOM_malloczero(0x168uLL);
  uint64_t v5 = v4;
  if (v4)
  {
    *size_t v4 = a1;
    if (a2) {
      v4[1] = strdup(a2);
    }
  }

  else
  {
    uint64_t v6 = (FILE *)*MEMORY[0x1895F89D0];
    int v7 = __error();
    int v8 = strerror(*v7);
    fprintf(v6, "malloc: %s\n", v8);
  }

  return v5;
}

void *_NewPage(uint64_t a1, int a2)
{
  uint64_t v4 = *(void *)a1;
  uint64_t v5 = BOM_malloczero(4LL * (*(_DWORD *)(a1 + 316) + 1));
  if (!v5) {
    return 0LL;
  }
  uint64_t v6 = v5;
  int v7 = BOM_malloczero(4LL * (*(_DWORD *)(a1 + 320) + 1));
  if (!v7)
  {
    free(v6);
    return 0LL;
  }

  int v8 = v7;
  int v9 = BOM_malloczero(0x28uLL);
  if (v9)
  {
    if (!a2) {
      a2 = BOMStorageNewBlock(v4);
    }
    v9[3] = v6;
    _BYTE v9[4] = v8;
    *(_DWORD *)int v9 = a2;
  }

  else
  {
    free(v6);
    free(v8);
  }

  return v9;
}

uint64_t _ReadPage(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = BOMStreamWithBlockID(*(void *)a1, *(_DWORD *)a2, *(unsigned int *)(a1 + 312), 0);
  if (!v3) {
    return 1LL;
  }
  uint64_t v4 = v3;
  *(_WORD *)(a2 + 4) = *(_WORD *)(a2 + 4) & 0xFFFE | (BOMStreamReadUInt16(v3) != 0);
  *(_WORD *)(a2 + 16) = BOMStreamReadUInt16(v4);
  *(_DWORD *)(a2 + 8) = BOMStreamReadUInt32(v4);
  *(_DWORD *)(a2 + 12) = BOMStreamReadUInt32(v4);
  if (*(_WORD *)(a2 + 16))
  {
    unint64_t v5 = 0LL;
    do
    {
      *(_DWORD *)(*(void *)(a2 + 32) + 4 * v5) = BOMStreamReadUInt32(v4);
      *(_DWORD *)(*(void *)(a2 + 24) + 4 * v5++) = BOMStreamReadUInt32(v4);
    }

    while (v5 < *(unsigned __int16 *)(a2 + 16));
  }

  *(_DWORD *)(*(void *)(a2 + 32) + 4LL * *(unsigned __int16 *)(a2 + 16)) = BOMStreamReadUInt32(v4);
  BOMStreamFree(v4);
  return 0LL;
}

void _invalidateIteratorsForPageID(uint64_t a1, unsigned int a2)
{
  uint64_t v3 = *(const __CFArray **)(a1 + 304);
  if (v3)
  {
    CFIndex v5 = BOMCFArrayMaxRange(v3);
    CFIndex v7 = v6;
    v8.location = v5;
    v8.size_t length = v7;
    CFArrayApplyFunction(*(CFArrayRef *)(a1 + 304), v8, (CFArrayApplierFunction)_invalidateIterator, (void *)a2);
  }

void _addPageToCache(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = a1 + 8LL * *(int *)(a1 + 288);
  CFIndex v6 = *(_WORD **)(v3 + 32);
  uint64_t v4 = (void *)(v3 + 32);
  CFIndex v5 = v6;
  if (v6)
  {
    while (1)
    {
      __int16 v8 = v5[2];
      if ((v8 & 0xC) == 4) {
        break;
      }
      v5[2] = v8 | 4;
      int v9 = *(_DWORD *)(a1 + 288) + 1;
      BOOL v10 = -v9 < 0;
      int v11 = -v9 & 0x1F;
      int v12 = v9 & 0x1F;
      if (!v10) {
        int v12 = -v11;
      }
      *(_DWORD *)(a1 + 288) = v12;
      uint64_t v13 = a1 + 8LL * v12;
      unint64_t v14 = *(_WORD **)(v13 + 32);
      uint64_t v4 = (void *)(v13 + 32);
      CFIndex v5 = v14;
      if (!v14) {
        goto LABEL_10;
      }
    }

    if ((v8 & 2) != 0) {
      _WritePage(a1, (uint64_t)v5);
    }
    _FreePage(v5);
    uint64_t v4 = (void *)(a1 + 8LL * *(int *)(a1 + 288) + 32);
  }

uint64_t _invalidateIterator(uint64_t result, int a2)
{
  if (result)
  {
    uint64_t v2 = result;
    if (*(_DWORD *)(result + 16) == a2 && !*(_BYTE *)(result + 67) && !*(_BYTE *)(result + 65))
    {
      uint64_t result = *(void *)(result + 8);
      if (result && *(_DWORD *)result == a2
        || (uint64_t result = (uint64_t)_findPage(*(void *)v2, a2), (*(void *)(v2 + 8) = result) != 0LL))
      {
        if (*(_BYTE *)(*(void *)v2 + 294LL))
        {
          *(void *)(v2 + 24) = *(unsigned int *)(*(void *)(result + 24) + 4LL * *(unsigned int *)(v2 + 20));
          *(void *)(v2 + 32) = 0LL;
        }

        else
        {
          size_t v3 = BOMStorageSizeOfBlock( **(void **)v2,  *(_DWORD *)(*(void *)(result + 24) + 4LL * *(unsigned int *)(v2 + 20)));
          *(void *)(v2 + 32) = v3;
          if (*(void *)(v2 + 24))
          {
            free(*(void **)(v2 + 24));
            *(void *)(v2 + 24) = 0LL;
            size_t v3 = *(void *)(v2 + 32);
          }

          uint64_t v4 = BOM_malloc(v3);
          *(void *)(v2 + 24) = v4;
          if (!v4)
          {
            CFIndex v5 = __error();
            _BOMFatalException( (uint64_t)"BOMTree iterator cannot cache keys. This is a fatal error (!it->key).\n",  "/Library/Caches/com.apple.xbs/Sources/Bom/Storage/BOMTree.c",  2550,  *v5);
          }

          uint64_t result = BOMStorageCopyFromBlock( **(void **)v2,  *(_DWORD *)(*(void *)(*(void *)(v2 + 8) + 24LL) + 4LL * *(unsigned int *)(v2 + 20)),  v4);
          if ((_DWORD)result)
          {
            CFIndex v6 = __error();
            _BOMFatalException( (uint64_t)"BOMTree iterator cannot cache keys. This is a fatal error (BOMStorageCopyFromBlock returned an error).\n",  "/Library/Caches/com.apple.xbs/Sources/Bom/Storage/BOMTree.c",  2554,  *v6);
          }
        }
      }

      *(_BYTE *)(v2 + 65) = 1;
    }
  }

  return result;
}

void _removePageFromCache(uint64_t a1, _WORD *a2)
{
  if ((a2[2] & 8) == 0)
  {
    for (uint64_t i = 32LL; i != 288; i += 8LL)
    {
      if (*(_WORD **)(a1 + i) == a2)
      {
        CFIndex v5 = *(const __CFArray **)(a1 + 304);
        if (v5)
        {
          CFIndex v6 = BOMCFArrayMaxRange(v5);
          CFIndex v8 = v7;
          v9.location = v6;
          v9.size_t length = v8;
          CFArrayApplyFunction(*(CFArrayRef *)(a1 + 304), v9, (CFArrayApplierFunction)_pageRemovedCallback, a2);
        }

        *(void *)(a1 + i) = 0LL;
      }
    }

    if ((a2[2] & 2) != 0) {
      _WritePage(a1, (uint64_t)a2);
    }
  }

uint64_t _pageRemovedCallback(uint64_t result, uint64_t a2)
{
  if (result && a2 && *(void *)(result + 8) == a2) {
    *(void *)(result + 8) = 0LL;
  }
  return result;
}

uint64_t _shiftKeysAndValues(uint64_t result, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t v4 = *(unsigned __int16 *)(a3 + 16);
  unsigned int v5 = *(_DWORD *)(result + 324);
  BOOL v6 = v4 >= v5;
  int v8 = v4 - v5;
  BOOL v7 = v8 != 0 && v6;
  unsigned int v9 = (v8 + 1) >> 1;
  if (v7) {
    unsigned int v10 = v9;
  }
  else {
    unsigned int v10 = *(unsigned __int16 *)(a3 + 16);
  }
  uint64_t v11 = *(unsigned __int16 *)(a2 + 16);
  unsigned int v12 = v10 + v11;
  unint64_t v13 = v4 - v10;
  if (a4)
  {
    unsigned int v14 = 0;
    if (!v10) {
      goto LABEL_15;
    }
    goto LABEL_11;
  }

  uint64_t v15 = *(void *)(a2 + 32);
  *(_DWORD *)(v15 + 4LL * v12) = *(_DWORD *)(v15 + 4 * v11);
  if ((_DWORD)v11)
  {
    uint64_t v16 = *(void *)(a2 + 24);
    do
    {
      unsigned int v17 = v10 - 1 + v11--;
      *(_DWORD *)(v16 + 4LL * v17) = *(_DWORD *)(v16 + 4LL * v11);
      *(_DWORD *)(v15 + 4LL * v17) = *(_DWORD *)(v15 + 4LL * v11);
    }

    while (v11);
  }

  unsigned int v14 = v4 - v10;
  if (v10)
  {
LABEL_11:
    uint64_t v18 = *(void *)(a3 + 24);
    uint64_t v19 = *(void *)(a3 + 32);
    uint64_t v11 = v11;
    unsigned int v20 = v10;
    uint64_t v21 = *(void *)(a2 + 24);
    uint64_t result = *(void *)(a2 + 32);
    do
    {
      *(_DWORD *)(v21 + 4 * v11) = *(_DWORD *)(v18 + 4LL * v14);
      *(_DWORD *)(result + 4 * v11) = *(_DWORD *)(v19 + 4LL * v14);
      if (!a4)
      {
        *(_DWORD *)(v18 + 4LL * v14) = 0;
        *(_DWORD *)(v19 + 4LL * v14) = 0;
      }

      ++v11;
      ++v14;
      --v20;
    }

    while (v20);
  }

uint64_t _findPagesForKey(uint64_t a1, char *a2, const void *a3, size_t a4)
{
  if (!a1) {
    return 0LL;
  }
  uint64_t v8 = *(void *)(a1 + 24);
  if (a2) {
    BOMStackPush(a2, v8);
  }
  if ((*(_WORD *)(v8 + 4) & 1) == 0)
  {
    do
    {
      unsigned int IndexForKey = _findIndexForKey(a1, v8, a3, a4, 0LL);
      Page = _findPage(a1, *(_DWORD *)(*(void *)(v8 + 32) + 4LL * IndexForKey));
      uint64_t v8 = (uint64_t)Page;
      if (!Page) {
        break;
      }
      if (a2)
      {
        BOMStackPush(a2, (uint64_t)Page);
        __int16 v11 = *(_WORD *)(v8 + 4) | 8;
      }

      else
      {
        __int16 v11 = *((_WORD *)Page + 2);
      }

      *(_WORD *)(v8 + 4) = v11 & 0xFFFB;
    }

    while ((v11 & 1) == 0);
  }

  return v8;
}

size_t BOMPathDump(char *__s)
{
  if (__s) {
    size_t v2 = strlen(__s);
  }
  else {
    size_t v2 = 0LL;
  }
  fprintf((FILE *)*MEMORY[0x1895F89E0], "%s (%lu bytes)\n", __s, v2);
  return v2;
}

uint64_t BOMPathIdDump(unsigned __int8 *a1, unint64_t a2)
{
  if (a2 < 4) {
    return BOMMemoryDump(a1, a2, "        ");
  }
  if (a1) {
    fprintf((FILE *)*MEMORY[0x1895F89E0], "0x%02x%02x%02x%02x (%lu bytes)\n", *a1, a1[1], a1[2], a1[3], 4LL);
  }
  return 4LL;
}

uint64_t BOMPathKeyDump(uint64_t a1, unint64_t a2)
{
  if (!a1) {
    return 0LL;
  }
  if (a2 >= 5)
  {
    size_t v2 = strlen((const char *)(a1 + 4)) + 5;
    fprintf((FILE *)*MEMORY[0x1895F89E0], "0x%02x%02x%02x%02x %s (%lu bytes)\n");
    return v2;
  }

  if (a2 == 4)
  {
    size_t v2 = 4LL;
    fprintf((FILE *)*MEMORY[0x1895F89E0], "0x%02x%02x%02x%02x (NULL) (%lu bytes)\n");
    return v2;
  }

  return BOMMemoryDump((unsigned __int8 *)a1, a2, "        ");
}

void *data_archive_entry_new(uint64_t a1, uint64_t a2)
{
  if (a2) {
    return 0LL;
  }
  uint64_t result = platform_calloc(a1, 1uLL, 0x80uLL);
  if (result)
  {
    *(_DWORD *)uint64_t result = 1684369012;
    result[1] = a1;
    *((_DWORD *)result + 30) = 1953391972;
  }

  return result;
}

void data_archive_entry_free(void *__b)
{
  if (__b && *(_DWORD *)__b == 1684369012 && *((_DWORD *)__b + 30) == 1953391972)
  {
    size_t v2 = (void *)__b[3];
    if (v2) {
      platform_free(__b[1], v2);
    }
    uint64_t v3 = __b[1];
    platform_memset(v3, __b, 0LL, 0x80uLL);
    platform_free(v3, __b);
  }

_DWORD *data_archive_entry_get_type(_DWORD *result)
{
  if (result)
  {
    if (*result == 1684369012 && result[30] == 1953391972) {
      return (_DWORD *)result[4];
    }
    else {
      return 0LL;
    }
  }

  return result;
}

uint64_t data_archive_entry_set_format_entry( uint64_t a1, int a2, int a3, _DWORD *a4, void *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1 || *(_DWORD *)a1 != 1684369012 || *(_DWORD *)(a1 + 120) != 1953391972)
  {
    uint64_t v30 = "Invalid data archive entry";
    char v31 = a5;
    int v32 = 214;
LABEL_27:
    capture_error( v31,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_entry.c",  v32,  (uint64_t)"data_archive_entry_set_format_entry",  v30,  a6,  a7,  a8,  v136);
    return 0xFFFFFFFFLL;
  }

  if (!a2)
  {
    uint64_t v30 = "Unknown format type";
    char v31 = a5;
    int v32 = 220;
    goto LABEL_27;
  }

  if (!a4)
  {
    uint64_t v30 = "Invalid format entry";
    char v31 = a5;
    int v32 = 226;
    goto LABEL_27;
  }

  if (!darc_format_entry_get_type(a4))
  {
    uint64_t v30 = "Unknown data entry type";
    char v31 = a5;
    int v32 = 235;
    goto LABEL_27;
  }

  if (a2 == 9)
  {
    unsigned int type = darc_format_entry_get_type(a4);
    switch(type)
    {
      case 1u:
        goto LABEL_45;
      case 6u:
        uint64_t attribute = darc_format_entry_get_attribute((uint64_t)a4, "name", 0LL);
        if (attribute <= 0)
        {
          capture_error( a5,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_entry.c",  948,  (uint64_t)"populate_pkzip_entry_local_header",  "PKZip local header format entry is missing %s attribute",  v38,  v39,  v40,  (char)"name");
          return 0xFFFFFFFFLL;
        }

        char v41 = attribute + 1;
        __int16 v42 = platform_calloc(*(void *)(a1 + 8), attribute + 1, 1uLL);
        if (!v42)
        {
          char v111 = __error();
          strerror(*v111);
          capture_error( a5,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_entry.c",  956,  (uint64_t)"populate_pkzip_entry_local_header",  "Could not allocate %ld bytes for name buffer: %s",  v112,  v113,  v114,  v41);
          return 0xFFFFFFFFLL;
        }

        unsigned int v43 = v42;
        if (darc_format_entry_get_attribute((uint64_t)a4, "name", v42) == -1)
        {
          capture_error( a5,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_entry.c",  963,  (uint64_t)"populate_pkzip_entry_local_header",  "Could not get %s attribute",  v44,  v45,  v46,  (char)"name");
          return 0xFFFFFFFFLL;
        }

        *(void *)(a1 + 24) = v43;
        if (darc_format_entry_get_attribute((uint64_t)a4, "pkzip local header", 0LL) <= 0)
        {
          capture_error( a5,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_entry.c",  978,  (uint64_t)"populate_pkzip_entry_local_header",  "PKZip local header format entry is missing %s attribute",  v47,  v48,  v49,  (char)"pkzip local header");
          return 0xFFFFFFFFLL;
        }

        if (darc_format_entry_get_attribute((uint64_t)a4, "pkzip local header", &v142) == -1)
        {
          capture_error( a5,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_entry.c",  987,  (uint64_t)"populate_pkzip_entry_local_header",  "Could not get %s attribute",  v50,  v51,  v52,  (char)"pkzip local header");
          return 0xFFFFFFFFLL;
        }

        uint64_t v53 = v145;
        *(void *)(a1 + 80) = v146;
        *(void *)(a1 + 112) = v53;
        uint64_t v54 = convert_dos_to_unix_time(a1, WORD1(v143), WORD2(v143));
        *(void *)(a1 + 88) = v54;
        *(void *)(a1 + 72) = v54;
        char v55 = BYTE6(v142);
        if ((v142 & 0x1000000000000LL) != 0) {
          *(_BYTE *)(a1 + 104) = 1;
        }
        if ((v55 & 8) != 0)
        {
          *(_BYTE *)(a1 + 105) = 1;
          BOOL v56 = (_DWORD *)(a1 + 108);
        }

        else
        {
          *(_DWORD *)(a1 + 108) = v144;
          BOOL v56 = (_DWORD *)(a1 + 108);
          if (!*(_BYTE *)(a1 + 105)) {
            goto LABEL_103;
          }
        }

        _DWORD *v56 = WORD1(v143);
LABEL_103:
        if (darc_format_entry_get_attribute((uint64_t)a4, "pkzip extra field extended timestamp", v137) == -1)
        {
          capture_error( a5,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_entry.c",  1041,  (uint64_t)"populate_pkzip_entry_local_header",  "Could not get %s attribute",  v119,  v120,  v121,  (char)"pkzip extra field extended timestamp");
          return 0xFFFFFFFFLL;
        }

        *(void *)(a1 + 72) = *(void *)v137;
        *(_OWORD *)(a1 + 88) = *(_OWORD *)&v137[8];
LABEL_106:
        if (darc_format_entry_get_attribute((uint64_t)a4, "pkzip extra field InfoZIP UNIX v1", v137) == -1)
        {
          capture_error( a5,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_entry.c",  1064,  (uint64_t)"populate_pkzip_entry_local_header",  "Could not get %s attribute",  v122,  v123,  v124,  (char)"pkzip extra field InfoZIP UNIX v1");
          return 0xFFFFFFFFLL;
        }

        uint64_t v125 = *(void *)&v137[8];
        *(void *)(a1 + 88) = *(void *)v137;
        *(void *)(a1 + 72) = v125;
        if (v137[16]) {
          *(_DWORD *)(a1 + 52) = *(_DWORD *)&v137[20];
        }
        if (v137[24]) {
          *(_DWORD *)(a1 + 56) = *(_DWORD *)&v137[28];
        }
LABEL_112:
        if (darc_format_entry_get_attribute((uint64_t)a4, "pkzip extra field InfoZIP UNIX v3", v137) == -1)
        {
          capture_error( a5,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_entry.c",  1096,  (uint64_t)"populate_pkzip_entry_local_header",  "Could not get %s attribute",  v126,  v127,  v128,  (char)"pkzip extra field InfoZIP UNIX v3");
          return 0xFFFFFFFFLL;
        }

        *(void *)(a1 + 52) = *(void *)&v137[4];
LABEL_115:
        if (darc_format_entry_get_attribute((uint64_t)a4, "pkzip extra field ZIP64", v137) == -1)
        {
          capture_error( a5,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_entry.c",  1118,  (uint64_t)"populate_pkzip_entry_local_header",  "Could not get %s attribute",  v129,  v130,  v131,  (char)"pkzip extra field ZIP64");
          return 0xFFFFFFFFLL;
        }

        if (v137[0]) {
          *(void *)(a1 + 80) = *(void *)&v137[8];
        }
        if (v137[1]) {
          *(void *)(a1 + 112) = *(void *)&v137[16];
        }
LABEL_121:
        uint64_t v132 = platform_strlen(*(void *)(a1 + 8), *(char **)(a1 + 24));
        uint64_t v133 = *(void *)(a1 + 24);
        __int16 v134 = *(_WORD *)(a1 + 48);
        if (*(_BYTE *)(v133 + v132 - 1) == 47)
        {
          *(_WORD *)(a1 + 48) = v134 | 0x41C0;
          *(_BYTE *)(v133 + v132 - 1) = 0;
        }

        else
        {
          *(_WORD *)(a1 + 48) = v134 | 0x8180;
        }

        *(_DWORD *)(a1 + 16) = 2;
        if (*(_BYTE *)(a1 + 104))
        {
          int v135 = *(unsigned __int8 *)(a1 + 105);
          if (*(_BYTE *)(a1 + 105)) {
            int v29 = 7;
          }
          else {
            int v29 = 4;
          }
          if (!(_WORD)v143) {
            goto LABEL_138;
          }
        }

        else
        {
          int v135 = *(unsigned __int8 *)(a1 + 105);
          if (!(_WORD)v143)
          {
            if (*(_BYTE *)(a1 + 105))
            {
              int v29 = 5;
            }

            else if (*(void *)(a1 + 80))
            {
              int v29 = 2;
            }

            else
            {
              int v29 = 1;
            }

            goto LABEL_138;
          }
        }

        if (v135) {
          int v29 = 6;
        }
        else {
          int v29 = 3;
        }
LABEL_138:
        uint64_t result = 0LL;
        goto LABEL_25;
      case 7u:
      case 0xCu:
      case 0xDu:
      case 0xEu:
        goto LABEL_47;
      case 0xAu:
        *(void *)(a1 + 16) = 0x100000003LL;
        uint64_t v77 = darc_format_entry_get_attribute((uint64_t)a4, "name", 0LL);
        if (v77 <= 0)
        {
          capture_error( a5,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_entry.c",  1300,  (uint64_t)"populate_pkzip_entry_central_directory_header",  "PKZip local header format entry is missing %s attribute",  v78,  v79,  v80,  (char)"name");
          return 0xFFFFFFFFLL;
        }

        char v81 = v77 + 1;
        int v82 = (char *)platform_calloc(*(void *)(a1 + 8), v77 + 1, 1uLL);
        if (!v82)
        {
          uint64_t v115 = __error();
          strerror(*v115);
          capture_error( a5,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_entry.c",  1308,  (uint64_t)"populate_pkzip_entry_central_directory_header",  "Could not allocate %ld bytes for name buffer: %s",  v116,  v117,  v118,  v81);
          return 0xFFFFFFFFLL;
        }

        AAFieldKey v83 = v82;
        if (darc_format_entry_get_attribute((uint64_t)a4, "name", v82) == -1)
        {
          capture_error( a5,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_entry.c",  1315,  (uint64_t)"populate_pkzip_entry_central_directory_header",  "Could not get %s attribute",  v84,  v85,  v86,  (char)"name");
          return 0xFFFFFFFFLL;
        }

        *(void *)(a1 + 24) = v83;
        uint64_t v87 = platform_strlen(*(void *)(a1 + 8), v83) - 1;
        uint64_t v88 = *(void *)(a1 + 24);
        int v89 = *(unsigned __int8 *)(v88 + v87);
        if (v89 == 47) {
          *(_BYTE *)(v88 + v87) = 0;
        }
        if (darc_format_entry_get_attribute((uint64_t)a4, "pkzip central directory header", 0LL) <= 0)
        {
          capture_error( a5,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_entry.c",  1341,  (uint64_t)"populate_pkzip_entry_central_directory_header",  "PKZip local header format entry is missing %s attribute",  v90,  v91,  v92,  (char)"pkzip central directory header");
          return 0xFFFFFFFFLL;
        }

        if (darc_format_entry_get_attribute((uint64_t)a4, "pkzip central directory header", v137) == -1)
        {
          capture_error( a5,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_entry.c",  1350,  (uint64_t)"populate_pkzip_entry_central_directory_header",  "Could not get %s attribute",  v93,  v94,  v95,  (char)"pkzip central directory header");
          return 0xFFFFFFFFLL;
        }

        *(void *)(a1 + 80) = *(unsigned int *)&v137[24];
        uint64_t v96 = convert_dos_to_unix_time(a1, *(unsigned __int16 *)&v137[12], *(unsigned __int16 *)&v137[14]);
        *(void *)(a1 + 88) = v96;
        *(void *)(a1 + 72) = v96;
        int v97 = (v139 >> 4) & 1;
        if (v89 == 47) {
          int v97 = 1;
        }
        if (v97) {
          __int16 v98 = 16832;
        }
        else {
          __int16 v98 = -32384;
        }
        if (v139 >> 28) {
          __int16 v98 = HIWORD(v139);
        }
        *(_WORD *)(a1 + 48) = v98;
        if (darc_format_entry_get_attribute((uint64_t)a4, "pkzip extra field InfoZIP UNIX v1", &v142) == -1)
        {
          capture_error( a5,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_entry.c",  1393,  (uint64_t)"populate_pkzip_entry_central_directory_header",  "Could not get %s attribute",  v99,  v100,  v101,  (char)"pkzip extra field InfoZIP UNIX v1");
          return 0xFFFFFFFFLL;
        }

        uint64_t v102 = v143;
        *(void *)(a1 + 88) = v142;
        *(void *)(a1 + 72) = v102;
        if ((_BYTE)v144) {
          *(_DWORD *)(a1 + 52) = v145;
        }
        if ((_BYTE)v146) {
          *(_DWORD *)(a1 + 56) = v147;
        }
        return 0LL;
      default:
        capture_error( a5,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_entry.c",  909,  (uint64_t)"populate_pkzip_entry",  "Unsupported format entry type: %d",  v34,  v35,  v36,  type);
        return 0xFFFFFFFFLL;
    }
  }

  if (a2 != 3)
  {
    if (a2 != 2)
    {
      capture_error( a5,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_entry.c",  258,  (uint64_t)"data_archive_entry_set_format_entry",  "Unsupported format: %d",  a6,  a7,  a8,  a2);
      return 0xFFFFFFFFLL;
    }

    unsigned int v13 = darc_format_entry_get_type(a4);
    if (v13 != 1 && (a3 != 3 || v13 != 3))
    {
      if (v13 != 3)
      {
        uint64_t v14 = darc_format_entry_get_attribute((uint64_t)a4, "name", 0LL);
        if (v14 >= 1)
        {
          char v15 = v14 + 1;
          uint64_t v16 = platform_calloc(*(void *)(a1 + 8), v14 + 1, 1uLL);
          if (!v16)
          {
            __int16 v107 = __error();
            strerror(*v107);
            capture_error( a5,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_entry.c",  647,  (uint64_t)"populate_posix_ustar_entry",  "Could not allocate %ld bytes for name buffer: %s",  v108,  v109,  v110,  v15);
            return 0xFFFFFFFFLL;
          }

          unsigned int v17 = v16;
          if (darc_format_entry_get_attribute((uint64_t)a4, "name", v16) == -1)
          {
            capture_error( a5,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_entry.c",  654,  (uint64_t)"populate_posix_ustar_entry",  "Could not get %s attribute",  v18,  v19,  v20,  (char)"name");
            return 0xFFFFFFFFLL;
          }

          *(void *)(a1 + 24) = v17;
        }

        if (darc_format_entry_get_attribute((uint64_t)a4, "POSIX ustar header", 0LL) <= 0)
        {
          capture_error( a5,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_entry.c",  670,  (uint64_t)"populate_posix_ustar_entry",  "POSIX ustar format entry is missing %s attribute",  v21,  v22,  v23,  (char)"POSIX ustar header");
        }

        else
        {
          if (darc_format_entry_get_attribute((uint64_t)a4, "POSIX ustar header", v137) != -1)
          {
            *(_WORD *)(a1 + 48) = *(_WORD *)&v137[4];
            *(void *)(a1 + 52) = *(void *)&v137[8];
            uint64_t v27 = *(void *)&v137[16];
            *(int8x16_t *)(a1 + 72) = vextq_s8(*(int8x16_t *)&v137[16], *(int8x16_t *)&v137[16], 8uLL);
            if (*(_DWORD *)v137 <= 4u) {
              *(_DWORD *)(a1 + 16) = dword_18635AF30[*(int *)v137];
            }
            uint64_t result = 0LL;
            if (v27 <= 0) {
              int v29 = 1;
            }
            else {
              int v29 = 2;
            }
LABEL_25:
            *(_DWORD *)(a1 + 20) = v29;
            return result;
          }

          capture_error( a5,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_entry.c",  679,  (uint64_t)"populate_posix_ustar_entry",  "Could not get %s attribute",  v24,  v25,  v26,  (char)"POSIX ustar header");
        }

        return 0xFFFFFFFFLL;
      }

      goto LABEL_47;
    }

    goto LABEL_45;
  }

  unsigned int v57 = darc_format_entry_get_type(a4);
  if (v57 == 5)
  {
LABEL_47:
    uint64_t result = 0LL;
    uint64_t v58 = 0x100000004LL;
    goto LABEL_48;
  }

  if (v57 == 1)
  {
LABEL_45:
    uint64_t result = 0LL;
    uint64_t v58 = 0x100000001LL;
LABEL_48:
    *(void *)(a1 + 16) = v58;
    return result;
  }

  uint64_t v59 = darc_format_entry_get_attribute((uint64_t)a4, "name", 0LL);
  if (v59 <= 0)
  {
    capture_error( a5,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_entry.c",  768,  (uint64_t)"populate_cpio_entry",  "CPIO format entry is missing %s attribute",  v60,  v61,  v62,  (char)"name");
    return 0xFFFFFFFFLL;
  }

  char v63 = v59 + 1;
  unsigned __int16 v64 = platform_calloc(*(void *)(a1 + 8), v59 + 1, 1uLL);
  if (!v64)
  {
    int v103 = __error();
    strerror(*v103);
    capture_error( a5,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_entry.c",  776,  (uint64_t)"populate_cpio_entry",  "Could not allocate %ld bytes for name buffer: %s",  v104,  v105,  v106,  v63);
    return 0xFFFFFFFFLL;
  }

  uint64_t v65 = v64;
  if (darc_format_entry_get_attribute((uint64_t)a4, "name", v64) == -1)
  {
    capture_error( a5,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_entry.c",  783,  (uint64_t)"populate_cpio_entry",  "Could not get %s attribute",  v66,  v67,  v68,  (char)"name");
    return 0xFFFFFFFFLL;
  }

  *(void *)(a1 + 24) = v65;
  if (darc_format_entry_get_attribute((uint64_t)a4, "cpio header", 0LL) <= 0)
  {
    capture_error( a5,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_entry.c",  798,  (uint64_t)"populate_cpio_entry",  "CPIO format entry is missing %s attribute",  v69,  v70,  v71,  (char)"cpio header");
    return 0xFFFFFFFFLL;
  }

  if (darc_format_entry_get_attribute((uint64_t)a4, "cpio header", v137) == -1)
  {
    capture_error( a5,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_entry.c",  807,  (uint64_t)"populate_cpio_entry",  "Could not get %s attribute",  v72,  v73,  v74,  (char)"cpio header");
    return 0xFFFFFFFFLL;
  }

  *(_DWORD *)(a1 + 32) = *(_DWORD *)&v137[8];
  *(void *)(a1 + 40) = *(void *)&v137[16];
  *(_WORD *)(a1 + 48) = *(_WORD *)&v137[24];
  *(void *)(a1 + 52) = *(void *)&v137[28];
  *(_WORD *)(a1 + 60) = v138;
  *(_DWORD *)(a1 + 64) = v139;
  uint64_t v75 = v141;
  *(void *)(a1 + 72) = v140;
  *(void *)(a1 + 80) = v75;
  if (platform_strlen(*(void *)(a1 + 8), *(char **)(a1 + 24)) == 10)
  {
    uint64_t result = platform_strncmp(*(void *)(a1 + 8), "TRAILER!!!", *(char **)(a1 + 24), 0xAuLL);
    *(_DWORD *)(a1 + 20) = 1;
    uint64_t v76 = (_DWORD *)(a1 + 20);
    if (!(_DWORD)result)
    {
      *(_DWORD *)(a1 + 16) = 4;
      return result;
    }
  }

  else
  {
    *(_DWORD *)(a1 + 20) = 1;
    uint64_t v76 = (_DWORD *)(a1 + 20);
  }

  *(_DWORD *)(a1 + 16) = 2;
  uint64_t result = 0LL;
  *uint64_t v76 = 2;
  return result;
}

_DWORD *data_archive_entry_get_data_type(_DWORD *result)
{
  if (result)
  {
    if (*result == 1684369012 && result[30] == 1953391972) {
      return (_DWORD *)result[5];
    }
    else {
      return 0LL;
    }
  }

  return result;
}

uint64_t data_archive_entry_path(uint64_t result)
{
  if (result)
  {
    if (*(_DWORD *)result == 1684369012 && *(_DWORD *)(result + 120) == 1953391972) {
      return *(void *)(result + 24);
    }
    else {
      return 0LL;
    }
  }

  return result;
}

uint64_t data_archive_entry_dev(_DWORD *a1)
{
  if (a1 && *a1 == 1684369012 && a1[30] == 1953391972) {
    return a1[8];
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

uint64_t data_archive_entry_inode(uint64_t a1)
{
  if (a1 && *(_DWORD *)a1 == 1684369012 && *(_DWORD *)(a1 + 120) == 1953391972) {
    return *(void *)(a1 + 40);
  }
  else {
    return -1LL;
  }
}

uint64_t data_archive_entry_nlink(uint64_t a1)
{
  if (a1 && *(_DWORD *)a1 == 1684369012 && *(_DWORD *)(a1 + 120) == 1953391972) {
    return *(unsigned __int16 *)(a1 + 60);
  }
  else {
    return 0xFFFFLL;
  }
}

uint64_t data_archive_entry_mode(uint64_t a1)
{
  if (a1 && *(_DWORD *)a1 == 1684369012 && *(_DWORD *)(a1 + 120) == 1953391972) {
    return *(unsigned __int16 *)(a1 + 48);
  }
  else {
    return 0xFFFFLL;
  }
}

uint64_t data_archive_entry_uid(_DWORD *a1)
{
  if (a1 && *a1 == 1684369012 && a1[30] == 1953391972) {
    return a1[13];
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

uint64_t data_archive_entry_gid(_DWORD *a1)
{
  if (a1 && *a1 == 1684369012 && a1[30] == 1953391972) {
    return a1[14];
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

uint64_t data_archive_entry_size(uint64_t a1)
{
  if (a1 && *(_DWORD *)a1 == 1684369012 && *(_DWORD *)(a1 + 120) == 1953391972) {
    return *(void *)(a1 + 80);
  }
  else {
    return -1LL;
  }
}

uint64_t data_archive_entry_atime(uint64_t a1)
{
  if (a1 && *(_DWORD *)a1 == 1684369012 && *(_DWORD *)(a1 + 120) == 1953391972) {
    return *(void *)(a1 + 88);
  }
  else {
    return -1LL;
  }
}

uint64_t data_archive_entry_atime_nsec(_DWORD *a1)
{
  if (!a1 || *a1 != 1684369012) {
    return -1LL;
  }
  if (a1[30] == 1953391972) {
    return 0LL;
  }
  return -1LL;
}

uint64_t data_archive_entry_mtime(uint64_t a1)
{
  if (a1 && *(_DWORD *)a1 == 1684369012 && *(_DWORD *)(a1 + 120) == 1953391972) {
    return *(void *)(a1 + 72);
  }
  else {
    return -1LL;
  }
}

uint64_t data_archive_entry_ctime(uint64_t a1)
{
  if (a1 && *(_DWORD *)a1 == 1684369012 && *(_DWORD *)(a1 + 120) == 1953391972) {
    return *(void *)(a1 + 96);
  }
  else {
    return -1LL;
  }
}

uint64_t data_archive_entry_compressed_size(uint64_t a1)
{
  if (a1 && *(_DWORD *)a1 == 1684369012 && *(_DWORD *)(a1 + 120) == 1953391972) {
    return *(void *)(a1 + 112);
  }
  else {
    return -1LL;
  }
}

uint64_t data_archive_entry_crc32(_DWORD *a1)
{
  if (a1 && *a1 == 1684369012 && a1[30] == 1953391972) {
    return a1[27];
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

BOOL data_archive_entry_is_streamed(BOOL result)
{
  if (result) {
    return *(_DWORD *)result == 1684369012 && *(_DWORD *)(result + 120) == 1953391972 && *(_BYTE *)(result + 105) != 0;
  }
  return result;
}

uint64_t convert_dos_to_unix_time(uint64_t a1, unsigned int a2, unsigned int a3)
{
  __b.tm_mon = ((a2 >> 5) & 0xF) - 1;
  __b.tm_year = (a2 >> 9) + 80;
  __b.tm_hour = a3 >> 11;
  __b.tm_mday = a2 & 0x1F;
  __b.tm_sec = 2 * (a3 & 0x1F);
  __b.tm_min = (a3 >> 5) & 0x3F;
  __b.tm_isdst = -1;
  return platform_mktime(*(void *)(a1 + 8), &__b);
}

uint64_t BOMStreamWithBlockID(uint64_t a1, unsigned int a2, unint64_t a3, int a4)
{
  if (a3 > 0xE8D4A51000LL)
  {
    fprintf((FILE *)*MEMORY[0x1895F89D0], "stream maximum size exceeded: %lu > %lu");
    return 0LL;
  }

  uint64_t v8 = BOMStorageSizeOfBlock(a1, a2);
  if (!(a3 | v8)) {
    return 0LL;
  }
  size_t v9 = v8;
  unsigned int v10 = BOM_malloczero(0x58uLL);
  if (!v10)
  {
    uint64_t v16 = (FILE *)*MEMORY[0x1895F89D0];
    unsigned int v17 = __error();
    strerror(*v17);
    fprintf(v16, "malloc: %s\n");
    return 0LL;
  }

  uint64_t v11 = (uint64_t)v10;
  v10[1] = 1;
  *((void *)v10 + 10) = BOMStorageGetSys(a1);
  *(_DWORD *)uint64_t v11 = 0;
  *(void *)(v11 + 8) = a1;
  *(_DWORD *)(v11 + 16) = a2;
  if (a3) {
    unint64_t v12 = a3;
  }
  else {
    unint64_t v12 = v9;
  }
  *(void *)(v11 + 32) = v12;
  *(_DWORD *)(v11 + 40) = a4;
  if (v9 <= a3) {
    size_t v13 = a3;
  }
  else {
    size_t v13 = v9;
  }
  uint64_t v14 = (char *)BOM_malloczero(v13);
  *(void *)(v11 + 48) = v14;
  if (!v14)
  {
    uint64_t v18 = (FILE *)*MEMORY[0x1895F89D0];
    uint64_t v19 = __error();
    uint64_t v20 = strerror(*v19);
    fprintf(v18, "malloc: %s\n", v20);
LABEL_17:
    BOMStreamFree(v11);
    return 0LL;
  }

  *(_BYTE *)(v11 + 72) = 1;
  char v15 = &v14[*(void *)(v11 + 32)];
  *(void *)(v11 + 56) = v14;
  *(void *)(v11 + 64) = v15;
  return v11;
}

uint64_t BOMStreamFree(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = result;
    if (*(_BYTE *)(result + 73) && BOMStreamFlush((int *)result))
    {
      return 1LL;
    }

    else
    {
      size_t v2 = *(void **)(v1 + 48);
      if (v2)
      {
        if (*(_BYTE *)(v1 + 72)) {
          free(v2);
        }
      }

      free((void *)v1);
      return 0LL;
    }
  }

  return result;
}

uint64_t BOMStreamWithFile(int a1, uint64_t a2, unint64_t a3, int a4, char *a5)
{
  return BOMStreamWithFileAndSys(a1, a2, a3, a4, a5, 0LL);
}

uint64_t BOMStreamWithFileAndSys(int a1, uint64_t a2, unint64_t a3, int a4, char *a5, void *a6)
{
  size_t v6 = a3;
  if (a3 > 0xE8D4A51000LL)
  {
    fprintf((FILE *)*MEMORY[0x1895F89D0], "stream maximum size exceeded: %lu > %lu");
    return 0LL;
  }

  if (!a3) {
    return 0LL;
  }
  unint64_t v12 = BOM_malloczero(0x58uLL);
  if (!v12)
  {
    uint64_t v14 = (FILE *)*MEMORY[0x1895F89D0];
    char v15 = __error();
    strerror(*v15);
    fprintf(v14, "malloc: %s\n");
    return 0LL;
  }

  uint64_t v13 = (uint64_t)v12;
  if (!a6) {
    a6 = BomSys_default();
  }
  *(void *)(v13 + 80) = a6;
  *(void *)uint64_t v13 = 0x100000001LL;
  *(_DWORD *)(v13 + 20) = a1;
  *(void *)(v13 + 24) = a2;
  *(void *)(v13 + 32) = v6;
  *(_DWORD *)(v13 + 40) = a4;
  if (a5)
  {
    *(void *)(v13 + 48) = a5;
    *(_BYTE *)(v13 + 72) = 0;
  }

  else
  {
    uint64_t v16 = (char *)BOM_malloczero(v6);
    *(void *)(v13 + 48) = v16;
    if (!v16)
    {
      unsigned int v17 = "malloc: %s\n";
      goto LABEL_19;
    }

    a5 = v16;
    *(_BYTE *)(v13 + 72) = 1;
    size_t v6 = *(void *)(v13 + 32);
    a4 = *(_DWORD *)(v13 + 40);
  }

  *(void *)(v13 + 56) = a5;
  *(void *)(v13 + 64) = &a5[v6];
  if ((a4 | 2) == 2)
  {
    if ((*((uint64_t (**)(void, void, void, void))a6 + 8))( *((void *)a6 + 1),  *(unsigned int *)(v13 + 20),  *(void *)(v13 + 24),  0LL) == -1)
    {
      unsigned int v17 = "lseek: %s\n";
      goto LABEL_19;
    }

    if ((*((uint64_t (**)(void, void, void, void))a6 + 6))( *((void *)a6 + 1),  *(unsigned int *)(v13 + 20),  *(void *)(v13 + 48),  *(void *)(v13 + 32)) != *(void *)(v13 + 32))
    {
      unsigned int v17 = "read: %s\n";
LABEL_19:
      uint64_t v18 = (FILE *)*MEMORY[0x1895F89D0];
      uint64_t v19 = __error();
      uint64_t v20 = strerror(*v19);
      fprintf(v18, v17, v20);
      BOMStreamFree(v13);
      return 0LL;
    }
  }

  return v13;
}

void *BOMStreamWithAddress(uint64_t a1, unint64_t a2, int a3)
{
  if (a2 <= 0xE8D4A51000LL)
  {
    if (a2)
    {
      uint64_t result = BOM_malloczero(0x58uLL);
      if (result)
      {
        *uint64_t result = 0x100000002LL;
        result[4] = a2;
        *((_DWORD *)result + 10) = a3;
        *((_BYTE *)result + 72) = 0;
        result[6] = a1;
        result[7] = a1;
        result[8] = a1 + a2;
        return result;
      }

      BOOL v7 = (FILE *)*MEMORY[0x1895F89D0];
      uint64_t v8 = __error();
      strerror(*v8);
      fprintf(v7, "malloc: %s\n");
    }
  }

  else
  {
    fprintf((FILE *)*MEMORY[0x1895F89D0], "stream maximum size exceeded: %lu > %lu");
  }

  return 0LL;
}

uint64_t BOMStreamFlush(int *a1)
{
  if (a1)
  {
    if (!a1[10]) {
      goto LABEL_12;
    }
    int v2 = *a1;
    if (*a1 == 2) {
      goto LABEL_12;
    }
    if (v2 != 1)
    {
      if (!v2)
      {
        uint64_t v3 = BOMStorageSetBlockData(*((void *)a1 + 1), a1[4], *((void *)a1 + 6), *((void *)a1 + 4));
LABEL_13:
        *((_BYTE *)a1 + 73) = 0;
        return v3;
      }

      fprintf((FILE *)*MEMORY[0x1895F89D0], "unknown stream type: %d\n", *a1);
LABEL_12:
      uint64_t v3 = 0LL;
      goto LABEL_13;
    }

    if ((*(uint64_t (**)(void, void, void, void))(*((void *)a1 + 10) + 64LL))( *(void *)(*((void *)a1 + 10) + 8LL),  a1[5],  *((void *)a1 + 3),  0LL) == -1)
    {
      BOOL v7 = (FILE *)*MEMORY[0x1895F89D0];
      uint64_t v8 = __error();
      strerror(*v8);
      fprintf(v7, "lseek: %s\n");
    }

    else
    {
      if ((*(uint64_t (**)(void, void, void, void))(*((void *)a1 + 10) + 56LL))( *(void *)(*((void *)a1 + 10) + 8LL),  a1[5],  *((void *)a1 + 6),  *((void *)a1 + 4)) == *((void *)a1 + 4)) {
        goto LABEL_12;
      }
      uint64_t v4 = (FILE *)*MEMORY[0x1895F89D0];
      unsigned int v5 = __error();
      strerror(*v5);
      fprintf(v4, "write: %s\n");
    }

    return 1LL;
  }

  uint64_t v3 = 1LL;
  fwrite("bad stream!\n", 0xCuLL, 1uLL, (FILE *)*MEMORY[0x1895F89D0]);
  return v3;
}

uint64_t BOMStreamGetSys(uint64_t result)
{
  if (result) {
    return *(void *)(result + 80);
  }
  return result;
}

uint64_t BOMStreamSetByteOrder(uint64_t a1, unsigned int a2)
{
  uint64_t result = 1LL;
  if (a1)
  {
    if (a2 <= 2)
    {
      uint64_t result = 0LL;
      *(_DWORD *)(a1 + 4) = a2;
    }
  }

  return result;
}

uint64_t BOMStreamGetByteOrder(uint64_t result)
{
  if (result) {
    return *(unsigned int *)(result + 4);
  }
  return result;
}

unint64_t BOMStreamReadUInt64(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 40) == 1)
  {
    int v2 = *__error();
    uint64_t v3 = "read called on write-only buffer!\n";
    char v4 = 0;
    int v5 = 356;
LABEL_5:
    _BOMExceptionHandlerCall((uint64_t)v3, v4, "/Library/Caches/com.apple.xbs/Sources/Bom/Storage/BOMStream.c", v5, v2);
    unint64_t v8 = 0LL;
    goto LABEL_7;
  }

  size_t v6 = *(unint64_t **)(a1 + 56);
  BOOL v7 = v6 + 1;
  if ((unint64_t)(v6 + 1) > *(void *)(a1 + 64))
  {
    int v2 = *__error();
    uint64_t v3 = "buffer overflow!";
    char v4 = 1;
    int v5 = 604;
    goto LABEL_5;
  }

  unint64_t v8 = *v6;
  *(void *)(a1 + 56) = v7;
LABEL_7:
  unint64_t v9 = bswap64(v8);
  if (*(_DWORD *)(a1 + 4) == 2) {
    return v8;
  }
  else {
    return v9;
  }
}

uint64_t BOMStreamReadUInt32(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 40) == 1)
  {
    int v2 = *__error();
    uint64_t v3 = "read called on write-only buffer!\n";
    char v4 = 0;
    int v5 = 378;
LABEL_5:
    _BOMExceptionHandlerCall((uint64_t)v3, v4, "/Library/Caches/com.apple.xbs/Sources/Bom/Storage/BOMStream.c", v5, v2);
    unsigned int v8 = 0;
    goto LABEL_7;
  }

  size_t v6 = *(unsigned int **)(a1 + 56);
  BOOL v7 = v6 + 1;
  if ((unint64_t)(v6 + 1) > *(void *)(a1 + 64))
  {
    int v2 = *__error();
    uint64_t v3 = "buffer overflow!";
    char v4 = 1;
    int v5 = 604;
    goto LABEL_5;
  }

  unsigned int v8 = *v6;
  *(void *)(a1 + 56) = v7;
LABEL_7:
  unsigned int v9 = bswap32(v8);
  if (*(_DWORD *)(a1 + 4) == 2) {
    return v8;
  }
  else {
    return v9;
  }
}

uint64_t BOMStreamReadUInt16(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 40) == 1)
  {
    int v2 = *__error();
    uint64_t v3 = "read called on write-only buffer!\n";
    char v4 = 0;
    int v5 = 400;
LABEL_5:
    _BOMExceptionHandlerCall((uint64_t)v3, v4, "/Library/Caches/com.apple.xbs/Sources/Bom/Storage/BOMStream.c", v5, v2);
    unsigned int v8 = 0;
    goto LABEL_7;
  }

  size_t v6 = *(unsigned __int16 **)(a1 + 56);
  BOOL v7 = v6 + 1;
  if ((unint64_t)(v6 + 1) > *(void *)(a1 + 64))
  {
    int v2 = *__error();
    uint64_t v3 = "buffer overflow!";
    char v4 = 1;
    int v5 = 604;
    goto LABEL_5;
  }

  unsigned int v8 = *v6;
  *(void *)(a1 + 56) = v7;
LABEL_7:
  unsigned int v9 = __rev16(v8);
  if (*(_DWORD *)(a1 + 4) == 2) {
    return v8;
  }
  else {
    return v9;
  }
}

uint64_t BOMStreamReadUInt8(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 40) == 1)
  {
    int v1 = *__error();
    int v2 = "read called on write-only buffer!\n";
    char v3 = 0;
    int v4 = 422;
  }

  else
  {
    int v5 = *(unsigned __int8 **)(a1 + 56);
    size_t v6 = v5 + 1;
    if ((unint64_t)(v5 + 1) <= *(void *)(a1 + 64))
    {
      uint64_t v7 = *v5;
      *(void *)(a1 + 56) = v6;
      return v7;
    }

    int v1 = *__error();
    int v2 = "buffer overflow!";
    char v3 = 1;
    int v4 = 604;
  }

  _BOMExceptionHandlerCall((uint64_t)v2, v3, "/Library/Caches/com.apple.xbs/Sources/Bom/Storage/BOMStream.c", v4, v1);
  return 0LL;
}

void *BOMStreamReadBuffer(uint64_t a1, void *__dst, size_t __len)
{
  if (*(_DWORD *)(a1 + 40) == 1)
  {
    int v3 = *__error();
    int v4 = "read called on write-only buffer!\n";
    char v5 = 0;
    int v6 = 441;
    return (void *)_BOMExceptionHandlerCall( (uint64_t)v4,  v5,  "/Library/Caches/com.apple.xbs/Sources/Bom/Storage/BOMStream.c",  v6,  v3);
  }

  if (__len >= 0xE8D4A51001LL)
  {
    int v3 = *__error();
    int v4 = "buffer overflow!";
    char v5 = 1;
    int v6 = 599;
    return (void *)_BOMExceptionHandlerCall( (uint64_t)v4,  v5,  "/Library/Caches/com.apple.xbs/Sources/Bom/Storage/BOMStream.c",  v6,  v3);
  }

  unsigned int v9 = *(const void **)(a1 + 56);
  if ((unint64_t)v9 + __len > *(void *)(a1 + 64))
  {
    int v3 = *__error();
    int v4 = "buffer overflow!";
    char v5 = 1;
    int v6 = 604;
    return (void *)_BOMExceptionHandlerCall( (uint64_t)v4,  v5,  "/Library/Caches/com.apple.xbs/Sources/Bom/Storage/BOMStream.c",  v6,  v3);
  }

  uint64_t result = memmove(__dst, v9, __len);
  *(void *)(a1 + 56) += __len;
  return result;
}

uint64_t BOMStreamReadAddress(uint64_t a1, unint64_t a2)
{
  if (*(_DWORD *)(a1 + 40) == 1)
  {
    int v2 = *__error();
    int v3 = "read called on write-only buffer!\n";
    char v4 = 0;
    int v5 = 464;
  }

  else if (*(_DWORD *)a1 == 2)
  {
    if (a2 < 0xE8D4A51001LL)
    {
      uint64_t v6 = *(void *)(a1 + 56);
      if (v6 + a2 <= *(void *)(a1 + 64))
      {
        *(void *)(a1 + 56) = v6 + a2;
        return v6;
      }

      int v2 = *__error();
      int v3 = "buffer overflow!";
      char v4 = 1;
      int v5 = 604;
    }

    else
    {
      int v2 = *__error();
      int v3 = "buffer overflow!";
      char v4 = 1;
      int v5 = 599;
    }
  }

  else
  {
    int v2 = *__error();
    int v3 = "BOMStreamReadAddress: bad buffer type!\n";
    char v4 = 0;
    int v5 = 468;
  }

  _BOMExceptionHandlerCall((uint64_t)v3, v4, "/Library/Caches/com.apple.xbs/Sources/Bom/Storage/BOMStream.c", v5, v2);
  return 0LL;
}

uint64_t BOMStreamWriteUInt32(uint64_t result, unsigned int a2)
{
  unsigned int v2 = bswap32(a2);
  if (*(_DWORD *)(result + 4) == 2) {
    unsigned int v3 = a2;
  }
  else {
    unsigned int v3 = v2;
  }
  if (*(_DWORD *)(result + 40))
  {
    char v4 = *(unsigned int **)(result + 56);
    if ((unint64_t)(v4 + 1) <= *(void *)(result + 64))
    {
      *char v4 = v3;
      *(void *)(result + 56) += 4LL;
      *(_BYTE *)(result + 73) = 1;
    }

    else
    {
      int v5 = __error();
      return _BOMExceptionHandlerCall( (uint64_t)"buffer overflow!",  1,  "/Library/Caches/com.apple.xbs/Sources/Bom/Storage/BOMStream.c",  614,  *v5);
    }
  }

  else
  {
    uint64_t v6 = __error();
    return _BOMExceptionHandlerCall( (uint64_t)"write called on read-only buffer!\n",  0,  "/Library/Caches/com.apple.xbs/Sources/Bom/Storage/BOMStream.c",  500,  *v6);
  }

  return result;
}

uint64_t BOMStreamWriteUInt16(uint64_t result, __int16 a2)
{
  __int16 v2 = __rev16(a2);
  if (*(_DWORD *)(result + 4) == 2) {
    __int16 v3 = a2;
  }
  else {
    __int16 v3 = v2;
  }
  if (*(_DWORD *)(result + 40))
  {
    char v4 = *(_WORD **)(result + 56);
    if ((unint64_t)(v4 + 1) <= *(void *)(result + 64))
    {
      *char v4 = v3;
      *(void *)(result + 56) += 2LL;
      *(_BYTE *)(result + 73) = 1;
    }

    else
    {
      int v5 = __error();
      return _BOMExceptionHandlerCall( (uint64_t)"buffer overflow!",  1,  "/Library/Caches/com.apple.xbs/Sources/Bom/Storage/BOMStream.c",  614,  *v5);
    }
  }

  else
  {
    uint64_t v6 = __error();
    return _BOMExceptionHandlerCall( (uint64_t)"write called on read-only buffer!\n",  0,  "/Library/Caches/com.apple.xbs/Sources/Bom/Storage/BOMStream.c",  527,  *v6);
  }

  return result;
}

uint64_t BOMStreamWriteUInt8(uint64_t result, char a2)
{
  if (*(_DWORD *)(result + 40))
  {
    __int16 v2 = *(_BYTE **)(result + 56);
    if ((unint64_t)(v2 + 1) <= *(void *)(result + 64))
    {
      *__int16 v2 = a2;
      ++*(void *)(result + 56);
      *(_BYTE *)(result + 73) = 1;
    }

    else
    {
      __int16 v3 = __error();
      return _BOMExceptionHandlerCall( (uint64_t)"buffer overflow!",  1,  "/Library/Caches/com.apple.xbs/Sources/Bom/Storage/BOMStream.c",  614,  *v3);
    }
  }

  else
  {
    char v4 = __error();
    return _BOMExceptionHandlerCall( (uint64_t)"write called on read-only buffer!\n",  0,  "/Library/Caches/com.apple.xbs/Sources/Bom/Storage/BOMStream.c",  545,  *v4);
  }

  return result;
}

void *BOMStreamWriteBuffer(uint64_t a1, const void *a2, size_t __len)
{
  if (!*(_DWORD *)(a1 + 40))
  {
    int v4 = *__error();
    int v5 = "write called on read-only buffer!\n";
    char v6 = 0;
    int v7 = 563;
    return (void *)_BOMExceptionHandlerCall( (uint64_t)v5,  v6,  "/Library/Caches/com.apple.xbs/Sources/Bom/Storage/BOMStream.c",  v7,  v4);
  }

  if (__len >= 0xE8D4A51001LL)
  {
    int v4 = *__error();
    int v5 = "buffer overflow!";
    char v6 = 1;
    int v7 = 609;
    return (void *)_BOMExceptionHandlerCall( (uint64_t)v5,  v6,  "/Library/Caches/com.apple.xbs/Sources/Bom/Storage/BOMStream.c",  v7,  v4);
  }

  unsigned int v9 = *(void **)(a1 + 56);
  if ((unint64_t)v9 + __len > *(void *)(a1 + 64))
  {
    int v4 = *__error();
    int v5 = "buffer overflow!";
    char v6 = 1;
    int v7 = 614;
    return (void *)_BOMExceptionHandlerCall( (uint64_t)v5,  v6,  "/Library/Caches/com.apple.xbs/Sources/Bom/Storage/BOMStream.c",  v7,  v4);
  }

  uint64_t result = memmove(v9, a2, __len);
  *(void *)(a1 + 56) += __len;
  *(_BYTE *)(a1 + 73) = 1;
  return result;
}

uint64_t BOMStreamAdvance(uint64_t result, unint64_t a2)
{
  if (a2 < 0xE8D4A51001LL)
  {
    unint64_t v3 = *(void *)(result + 56) + a2;
    if (v3 <= *(void *)(result + 64))
    {
      *(void *)(result + 56) = v3;
    }

    else
    {
      int v4 = __error();
      return _BOMExceptionHandlerCall( (uint64_t)"buffer overflow!",  1,  "/Library/Caches/com.apple.xbs/Sources/Bom/Storage/BOMStream.c",  614,  *v4);
    }
  }

  else
  {
    __int16 v2 = __error();
    return _BOMExceptionHandlerCall( (uint64_t)"buffer overflow!",  1,  "/Library/Caches/com.apple.xbs/Sources/Bom/Storage/BOMStream.c",  609,  *v2);
  }

  return result;
}

char *BOMBomEnumeratorNew(uint64_t a1, unsigned int *a2)
{
  return BOMBomEnumeratorNewWithOptions(a1, a2, 1);
}

char *BOMBomEnumeratorNewWithOptions(uint64_t a1, unsigned int *a2, int a3)
{
  unint64_t v3 = 0LL;
  if (a1)
  {
    if (a3)
    {
      int v7 = (char *)BOM_malloczero(0x440uLL);
      unint64_t v3 = v7;
      if (v7)
      {
        *((_DWORD *)v7 + 11) = a3;
        *(void *)int v7 = a1;
        *((void *)v7 + 1) = BOMBomPathsTree(a1);
        *((void *)v3 + 2) = BOMStackNew();
        *((void *)v3 + 3) = BOMStackNew();
        unsigned int v8 = BOMStackNew();
        *((void *)v3 + 4) = v8;
        if (!*((void *)v3 + 2) || !*((void *)v3 + 3) || !v8) {
          goto LABEL_20;
        }
        RootFSObject = a2;
        if (!a2)
        {
          RootFSObject = (unsigned int *)BOMBomGetRootFSObject(a1);
          if (!RootFSObject)
          {
            v3[49] = 1;
            return v3;
          }
        }

        signed int v10 = BOMFSObjectParentPathID((uint64_t)RootFSObject);
        uint64_t v11 = (char *)BOMFSObjectShortName((uint64_t)RootFSObject);
        unint64_t v12 = (const char *)BOMFSObjectPathName((uint64_t)RootFSObject);
        v3[48] = BOMFSObjectType(RootFSObject) == 2;
        int v13 = strlen(v12);
        memmove(v3 + 50, v12, v13);
        *((void *)v3 + 135) = &v3[v13 + 50];
        uint64_t v14 = BOMNewPathKey(v10, v11, &v21);
        if ((a3 & 4) != 0)
        {
          unint64_t Value = (unsigned int *)BOMTreeGetValue(*((void *)v3 + 1), v14, v21);
          free(v14);
          signed int v10 = BOMPathIDFromPathKey(Value);
          uint64_t v14 = BOMNewPathKey(v10, "", &v21);
        }

        if (!a2) {
          BOMFSObjectFree((uint64_t)RootFSObject);
        }
        uint64_t v16 = BOMTreeIteratorNew(*((void *)v3 + 1), v14, v21, 0LL);
        free(v14);
        if (v16)
        {
          BOMStackPush(*((char **)v3 + 3), (uint64_t)v16);
          BOMStackPush(*((char **)v3 + 2), v10);
          BOMStackPush(*((char **)v3 + 4), 0LL);
          *((_DWORD *)v3 + 10) = v10;
          if ((a3 & 4) == 0)
          {
            unsigned int v17 = (unsigned __int8 *)(*((void *)v3 + 135) - 1LL);
            while (1)
            {
              uint64_t v18 = v17 + 1;
              *((void *)v3 + 135) = v17;
              int v19 = *v17--;
              if (v19 == 47)
              {
                uint64_t v18 = v17 + 1;
                break;
              }
            }

            *uint64_t v18 = 0;
          }
        }

        else
        {
LABEL_20:
          BOMBomEnumeratorFree(v3);
          return 0LL;
        }
      }
    }
  }

  return v3;
}

void BOMBomEnumeratorFree(void *a1)
{
  if (a1)
  {
    __int16 v2 = (void **)*((void *)a1 + 2);
    if (v2) {
      BOMStackFree(v2);
    }
    uint64_t v3 = *((void *)a1 + 3);
    if (v3)
    {
      while (!BOMStackIsEmpty(v3))
      {
        int v4 = BOMStackPop(*((uint64_t **)a1 + 3));
        BOMTreeIteratorFree((char *)v4);
        uint64_t v3 = *((void *)a1 + 3);
      }

      BOMStackFree(*((void ***)a1 + 3));
    }

    int v5 = (void **)*((void *)a1 + 4);
    if (v5) {
      BOMStackFree(v5);
    }
    free(a1);
  }

_DWORD *BOMBomEnumeratorNext(uint64_t a1)
{
  uint64_t v54 = *MEMORY[0x1895F89C0];
  if (!a1 || *(_BYTE *)(a1 + 49)) {
    return 0LL;
  }
  unsigned int v4 = 0;
  unsigned int v5 = 0;
  int v6 = 0;
  unint64_t v7 = a1 + 50;
  int v8 = 1;
  while (2)
  {
    unsigned int v9 = BOMStackPeek(*(void **)(a1 + 24));
    if (!v9)
    {
      FSObjectWithBlockID = 0LL;
      *(_BYTE *)(a1 + 49) = 1;
      return FSObjectWithBlockID;
    }

    uint64_t v10 = (uint64_t)v9;
    int v11 = 0;
    switch(BOMStackPeek(*(void **)(a1 + 32)))
    {
      case 0u:
        unint64_t v12 = (unsigned int *)BOMTreeIteratorKey(v10);
        int v6 = BOMPathIDFromPathKey(v12);
        int v11 = *(_DWORD *)(a1 + 44) & 1;
        if (v11) {
          int v8 = 1;
        }
        int v13 = (const char *)BOMShortNameFromPathKey((uint64_t)v12);
        size_t v14 = strlen(v13);
        size_t v15 = v14;
        uint64_t v16 = *(_BYTE **)(a1 + 1080);
        if ((uint64_t)&v16[v14 - v7] >= 1024)
        {
          uint64_t v48 = BOMExceptionHandlerMessage("%lu + %p - %p > %d", v14, v16, (const void *)(a1 + 50), 1024);
          uint64_t v49 = __error();
          _BOMFatalException((uint64_t)v48, "/Library/Caches/com.apple.xbs/Sources/Bom/Bom/BOMBomEnumerator.c", 75, *v49);
        }

        if (v16 != (_BYTE *)v7)
        {
          *(void *)(a1 + 1080) = v16 + 1;
          *uint64_t v16 = 47;
          **(_BYTE **)(a1 + 1080) = 0;
        }

        if ((unint64_t)__strlcat_chk() >= 0x401)
        {
          uint64_t v50 = BOMExceptionHandlerMessage("strlcat(%p, %s, %lu) >= %lu)", (const void *)(a1 + 50), v13, 1025LL, 1025LL);
          uint64_t v51 = __error();
          _BOMFatalException((uint64_t)v50, "/Library/Caches/com.apple.xbs/Sources/Bom/Bom/BOMBomEnumerator.c", 83, *v51);
        }

        *(void *)(a1 + 1080) += v15;
        if (v11) {
          __strlcpy_chk();
        }
        unsigned int v17 = (unsigned int *)BOMTreeIteratorValue(v10);
        unsigned int v5 = BOMPathIDFromPathKey(v17);
        unsigned int v4 = BOMBlockIDFromPathValue((uint64_t)v17);
        uint64_t v18 = BOMTreeStorage(*(void *)(a1 + 8));
        int v19 = BOMStorageSizeOfBlock(v18, v4);
        uint64_t v20 = BOM_malloc(v19);
        uint64_t v21 = BOMTreeStorage(*(void *)(a1 + 8));
        unsigned int v22 = BOMFSObjectTypeFromRawData((unsigned __int8 *)v20);
        free(v20);
        if (v22 != 2 || (*(_BYTE *)(a1 + 44) & 4) != 0) {
          goto LABEL_39;
        }
        uint64_t v23 = *(void **)(a1 + 32);
        uint64_t v24 = 1LL;
        goto LABEL_40;
      case 1u:
        if (BOMTreeIteratorIsAtEnd(v10))
        {
          uint64_t v25 = (unsigned __int8 *)(*(void *)(a1 + 1080) - 1LL);
          while (1)
          {
            uint64_t v26 = v25 + 1;
            *(void *)(a1 + 1080) = v25;
            int v27 = *v25--;
            if (v27 == 47) {
              goto LABEL_58;
            }
          }
        }

        uint64_t v35 = (unsigned int *)BOMTreeIteratorKey(v10);
        int v6 = BOMPathIDFromPathKey(v35);
        if (v6 == BOMStackPeek(*(void **)(a1 + 16)))
        {
          uint64_t v36 = strrchr((const char *)(a1 + 50), 47);
          if (v36)
          {
            if (*v36)
            {
              unsigned int v37 = v36 + 1;
              uint64_t v38 = (const char *)BOMShortNameFromPathKey((uint64_t)v35);
              if (strcmp(v37, v38))
              {
                uint64_t v25 = (unsigned __int8 *)(*(void *)(a1 + 1080) - 1LL);
                while (1)
                {
                  uint64_t v26 = v25 + 1;
                  *(void *)(a1 + 1080) = v25;
                  int v39 = *v25--;
                  if (v39 == 47) {
                    goto LABEL_58;
                  }
                }
              }
            }
          }

          char v41 = (unsigned int *)BOMTreeIteratorValue(v10);
          unsigned int v5 = BOMPathIDFromPathKey(v41);
          __int16 v42 = BOMNewPathKey(v5, "", &v52);
          unsigned int v43 = BOMTreeIteratorNew(*(void *)(a1 + 8), v42, v52, 0LL);
          free(v42);
          BOMStackPush(*(char **)(a1 + 16), v5);
          BOMStackPush(*(char **)(a1 + 24), (uint64_t)v43);
          BOMStackPush(*(char **)(a1 + 32), 0LL);
          continue;
        }

        uint64_t v25 = (unsigned __int8 *)(*(void *)(a1 + 1080) - 1LL);
        while (1)
        {
          uint64_t v26 = v25 + 1;
          *(void *)(a1 + 1080) = v25;
          int v40 = *v25--;
          if (v40 == 47)
          {
LABEL_58:
            uint64_t v26 = v25 + 1;
            break;
          }
        }

void *BOMBomEnumeratorSkip(void *result)
{
  if (result)
  {
    int v1 = result;
    if (!*((_BYTE *)result + 49))
    {
      uint64_t result = BOMStackPeek((void *)result[4]);
      if ((_DWORD)result == 1) {
        return BOMStackPoke((void *)v1[4], 2LL);
      }
    }
  }

  return result;
}

uint64_t BOMBomEnumeratorSkipAll(uint64_t result)
{
  if (result)
  {
    if (!*(_BYTE *)(result + 49)) {
      *(_DWORD *)(result + 44) |= 4u;
    }
  }

  return result;
}

uint64_t BOMAppleDoublePathToADPath(char *__s, char *a2)
{
  uint64_t result = 0xFFFFFFFFLL;
  if (__s && a2)
  {
    unsigned int v5 = __s;
    if (__s == a2)
    {
      size_t v6 = strlen(__s) + 1;
      unint64_t v7 = (char *)BOM_malloc(v6);
      if (!v7) {
        return 0xFFFFFFFFLL;
      }
      unsigned int v5 = v7;
      strlcpy(v7, __s, v6);
    }

    int v8 = rindex(v5, 47);
    if (v8) {
      unsigned int v9 = v8 + 1;
    }
    else {
      unsigned int v9 = v5;
    }
    *a2 = 0;
    if (v8)
    {
      size_t v10 = v8 - v5 + 1;
      memmove(a2, v5, v10);
      a2[v10] = 0;
    }

    strlcat(a2, "._", 0x400uLL);
    strlcat(a2, v9, 0x400uLL);
    if (__s == a2) {
      free(v5);
    }
    return 0LL;
  }

  return result;
}

uint64_t BOMAppleDoubleADPathToPath(char *a1, void *a2)
{
  uint64_t result = 0xFFFFFFFFLL;
  if (a1 && a2)
  {
    unsigned int v5 = rindex(a1, 47);
    size_t v6 = v5;
    if (v5) {
      unint64_t v7 = v5 + 1;
    }
    else {
      unint64_t v7 = a1;
    }
    int v8 = &v7[2 * (strncmp("._", v7, 2uLL) == 0)];
    if (v6)
    {
      size_t v9 = v6 - a1 + 1;
      memmove(a2, a1, v9);
      *((_BYTE *)a2 + v9) = 0;
    }

    strlcat((char *)a2, v8, 0x400uLL);
    return 0LL;
  }

  return result;
}

uint64_t BOMAppleDoubleIsADFile(const char *a1)
{
  if (!a1) {
    return 255LL;
  }
  __int16 v2 = rindex(a1, 47);
  if (v2) {
    uint64_t v3 = v2 + 1;
  }
  else {
    uint64_t v3 = a1;
  }
  return strncmp(v3, "._", 2uLL) == 0;
}

uint64_t BOMAppleDoubleSize(int a1, int a2)
{
  return (a1 + a2 + 50);
}

uint64_t BOMAppleDoubleCopyHeader(unsigned int a1, unsigned int a2, void *a3, void *a4)
{
  int v8 = (char *)BOM_malloc(0x32uLL);
  if (!v8) {
    return 0xFFFFFFFFLL;
  }
  size_t v9 = v8;
  uint64_t result = 0LL;
  *(void *)size_t v9 = 0x20007160500LL;
  *(_OWORD *)(v9 + 8) = 0uLL;
  *((_WORD *)v9 + 12) = 512;
  *(void *)(v9 + 26) = 0x3200000009000000LL;
  *(_DWORD *)(v9 + 34) = bswap32(a1);
  LODWORD(v11) = 0x2000000;
  HIDWORD(v11) = bswap32(a1 + 50);
  *(void *)(v9 + 38) = v11;
  *(_DWORD *)(v9 + 46) = bswap32(a2);
  *a3 = v9;
  *a4 = 50LL;
  return result;
}

uint64_t BOMAppleDoubleWriteHeader(uint64_t a1, unsigned int a2, unsigned int a3)
{
  CFIndex v5 = v6;
  if (BOMFileWrite(a1, v7, v6) == v5) {
    return 0LL;
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

uint64_t BOMAppleDoubleReadHeader(int *a1, unsigned int *a2, unsigned int *a3)
{
  return BOMAppleDoubleReadHeaderWithOffsets(a1, a2, 0LL, a3, 0LL);
}

uint64_t BOMAppleDoubleReadHeaderWithOffsets( int *a1, unsigned int *a2, unsigned int *a3, unsigned int *a4, unsigned int *a5)
{
  uint64_t v24 = *MEMORY[0x1895F89C0];
  uint64_t result = 0xFFFFFFFFLL;
  if (a2 && a4)
  {
    *a2 = 0;
    *a4 = 0;
    memset(v22, 0, sizeof(v22));
    unsigned __int16 v23 = 0;
    if (BOMFileRead(a1, (char *)v22, 0x1AuLL) == 26)
    {
      int v12 = v22[0];
      int v11 = HIDWORD(v22[0]);
      v22[0] = _byteswap_uint64(__PAIR64__(v22[0], HIDWORD(v22[0])));
      int v13 = v23;
      unsigned __int16 v23 = __rev16(v23);
      uint64_t result = 0xFFFFFFFFLL;
      if (v12 == 118883584 && v11 == 512)
      {
        if (v13)
        {
          int v14 = 0;
          while (1)
          {
            unsigned int v15 = bswap32(v19);
            unsigned int v16 = bswap32(v20);
            unsigned int v19 = v15;
            unsigned int v20 = v16;
            unsigned int v17 = bswap32(v21);
            unsigned int v21 = v17;
            if (v15 != 2) {
              break;
            }
            *a4 = v17;
            uint64_t v18 = a5;
            if (a5) {
              goto LABEL_14;
            }
LABEL_15:
          }

          if (v15 != 9) {
            goto LABEL_15;
          }
          *a2 = v17;
          uint64_t v18 = a3;
          if (!a3) {
            goto LABEL_15;
          }
LABEL_14:
          *uint64_t v18 = v16;
          goto LABEL_15;
        }

        return 0LL;
      }
    }

    else
    {
      return 0xFFFFFFFFLL;
    }
  }

  return result;
}

uint64_t BOMCPIONew(uint64_t **a1, uint64_t a2, char a3, int a4)
{
  int v8 = (uint64_t *)BOM_malloc(0x468uLL);
  if (v8)
  {
    size_t v9 = v8;
    *int v8 = a2;
    *((_BYTE *)v8 + 8) = a3;
    *((_DWORD *)v8 + 3) = a4;
    *((_BYTE *)v8 + 24) = 0;
    size_t v10 = BOMHardLinkTableNew();
    _DWORD v9[2] = (uint64_t)v10;
    if (v10)
    {
      uint64_t result = 0LL;
      *a1 = v9;
      return result;
    }

    BOMCPIOFree(v9);
  }

  return 0xFFFFFFFFLL;
}

void BOMCPIOFree(uint64_t *a1)
{
  if (a1)
  {
    __int16 v2 = (const void **)a1[2];
    if (v2) {
      BOMHardLinkTableFree(v2);
    }
    if (*((_BYTE *)a1 + 8)) {
      BOMFileClose(*a1);
    }
    free(a1);
  }

uint64_t BOMCPIOWriteHeader(uint64_t a1, char *__s, uint64_t a3)
{
  int v6 = strlen(__s) + 1;
  return BOMCPIOWriteHeaderAndData(a1, a3, __s, v6, 0LL, 0);
}

uint64_t BOMCPIOWriteHeaderAndData(uint64_t a1, uint64_t a2, void *a3, int a4, void *a5, int a6)
{
  if ((*(_WORD *)(a2 + 4) & 0xF000) == 0x8000 && *(unsigned __int16 *)(a2 + 6) >= 2u)
  {
    int v12 = BOMHardLinkTableGet(*(CFDictionaryRef **)(a1 + 16), *(_DWORD *)a2, *(void *)(a2 + 8));
    if (v12)
    {
      uint64_t v13 = *(void *)v12;
    }

    else
    {
      uint64_t v19 = *(unsigned int *)(a1 + 12);
      *(_DWORD *)(a1 + 12) = v19 + 1;
      *(void *)bytes = v19;
      BOMHardLinkTableSet(*(CFDictionaryRef **)(a1 + 16), *(_DWORD *)a2, *(void *)(a2 + 8), bytes, 8LL);
      LODWORD(v13) = *(_DWORD *)bytes;
    }
  }

  else
  {
    LODWORD(v13) = *(_DWORD *)(a1 + 12);
    *(_DWORD *)(a1 + 12) = v13 + 1;
  }

  *(void *)bytes = (unsigned __int16)v13;
  int v14 = *(unsigned __int16 *)(a2 + 4);
  if ((v14 & 0xD000 | 0x2000) == 0xA000)
  {
    unint64_t v15 = *(void *)(a2 + 96);
    if (v15 >> 33)
    {
      *__error() = 27;
      return 0xFFFFFFFFLL;
    }
  }

  else
  {
    unint64_t v15 = 0LL;
  }

  snprintf( (char *)(a1 + 25),  0x4DuLL,  "%s%06ho%06ho%06ho%06ho%06ho%06ho%06ho%011o%06ho%011llo",  "070707",  WORD1(v13),  (unsigned __int16)v13,  v14,  *(unsigned __int16 *)(a2 + 16),  *(unsigned __int16 *)(a2 + 20),  *(unsigned __int16 *)(a2 + 6),  *(unsigned __int16 *)(a2 + 24),  *(void *)(a2 + 48),  (unsigned __int16)a4,  v15);
  int v16 = a4 + a6 + 76;
  if (v16 < 0x44D)
  {
    CFIndex v18 = v16;
    memcpy((void *)(a1 + 101), a3, a4);
    if (a5) {
      memcpy((void *)(a1 + 101 + a4), a5, a6);
    }
    if (BOMFileWrite(*(void *)a1, (UInt8 *)(a1 + 25), v18) != v18) {
      return 0xFFFFFFFFLL;
    }
  }

  else if (BOMFileWrite(*(void *)a1, (UInt8 *)(a1 + 25), 76LL) != 76 {
         || BOMFileWrite(*(void *)a1, (UInt8 *)a3, a4) != a4
  }
         || a5 && BOMFileWrite(*(void *)a1, (UInt8 *)a5, a6) != a6)
  {
    return 0xFFFFFFFFLL;
  }

  return 0LL;
}

uint64_t BOMCPIOWriteDirectory(uint64_t a1, char *__s, uint64_t a3)
{
  int v6 = strlen(__s) + 1;
  return BOMCPIOWriteHeaderAndData(a1, a3, __s, v6, 0LL, 0);
}

uint64_t BOMCPIOWriteDevice(uint64_t a1, char *__s, uint64_t a3)
{
  int v6 = strlen(__s) + 1;
  return BOMCPIOWriteHeaderAndData(a1, a3, __s, v6, 0LL, 0);
}

uint64_t BOMCPIOWriteSymlink(uint64_t a1, char *__s, uint64_t a3, char *a4)
{
  int v8 = strlen(__s);
  uint64_t v9 = *(void *)(a3 + 96);
  size_t v10 = strlen(a4);
  *(void *)(a3 + 96) = v10;
  uint64_t result = BOMCPIOWriteHeaderAndData(a1, a3, __s, v8 + 1, a4, v10);
  *(void *)(a3 + 96) = v9;
  return result;
}

uint64_t BOMCPIOWriteTerminator(uint64_t *a1)
{
  WORD3(v8[0]) = 1;
  BOOL v2 = 1LL;
  uint64_t v3 = (UInt8 *)BOM_calloc(0x200uLL, 1uLL);
  if (v3)
  {
    unsigned int v4 = v3;
    uint64_t v5 = BOMFileUncompressedOffset(*a1);
    if (v5 <= 0) {
      uint64_t v6 = -(-v5 & 0x1FF);
    }
    else {
      uint64_t v6 = v5 & 0x1FF;
    }
    BOOL v2 = BOMFileWrite(*a1, v4, 512 - v6) != 512 - v6;
    free(v4);
  }

  return v2;
}

uint64_t BOMCPIOReadHeader(uint64_t a1, char *a2, uint64_t a3)
{
  uint64_t v27 = *MEMORY[0x1895F89C0];
  if (*(_BYTE *)(a1 + 24)) {
    return 4LL;
  }
  v26[76] = 0;
  if (sscanf( v26,  "%06s%06ho%06ho%06ho%06ho%06ho%06ho%06ho%011o%06ho%011llo",  v25,  &v23,  &v22,  a3 + 4,  &v21,  &v20,  a3 + 6,  &v19,  &v18,  &v24,  &v17) != 11) {
    return 3LL;
  }
  *(_DWORD *)a3 = v23;
  *(void *)(a3 + 8) = v22;
  int v7 = v20;
  *(_DWORD *)(a3 + 16) = v21;
  *(_DWORD *)(a3 + 20) = v7;
  *(_DWORD *)(a3 + 24) = v19;
  BOOL v8 = v25[0] == 925906736 && *(_DWORD *)((char *)v25 + 3) == 3616823;
  uint64_t v9 = v18;
  *(void *)(a3 + 96) = v17;
  *(_DWORD *)(a3 + 116) = 0;
  *(void *)(a3 + 32) = v9;
  *(void *)(a3 + 40) = 0LL;
  *(void *)(a3 + 48) = v9;
  *(void *)(a3 + 56) = 0LL;
  if (!v8 || v24 > 0x400uLL) {
    return 3LL;
  }
  unint64_t v10 = BOMFileRead(*(int **)a1, a2, v24);
  int v11 = v24;
  if ((v10 & 0x8000000000000000LL) != 0 || (uint64_t v12 = v10, v10 != v24))
  {
    int v14 = (FILE *)*MEMORY[0x1895F89D0];
    unint64_t v15 = __error();
    int v16 = strerror(*v15);
    fprintf(v14, "can't read path of size %d: %s\n", v11, v16);
    return 0xFFFFFFFFLL;
  }

  uint64_t v13 = 0LL;
  if (v24)
  {
    uint64_t result = 3LL;
    while (a2[v13])
    {
      if (v12 == ++v13) {
        return result;
      }
    }
  }

  if (v13 == v12 || a2[v13]) {
    return 3LL;
  }
  if (!strcmp(a2, "TRAILER!!!"))
  {
    *(_BYTE *)(a1 + 24) = 1;
    return 4LL;
  }

  return _sanitizePath(a2, v12);
}

uint64_t BOMCPIOGetFile(uint64_t a1)
{
  return *(void *)a1;
}

unint64_t BOMCPIORead(int **a1, char *a2, unint64_t a3)
{
  return BOMFileRead(*a1, a2, a3);
}

CFIndex BOMCPIOWrite(uint64_t *a1, UInt8 *a2, CFIndex a3)
{
  return BOMFileWrite(*a1, a2, a3);
}

unint64_t BOMCPIOSeek()
{
  uint64_t v0 = MEMORY[0x1895F8858]();
  uint64_t v2 = v1;
  uint64_t v3 = (int **)v0;
  uint64_t v8 = *MEMORY[0x1895F89C0];
  if (v4 != 1) {
    return BOMFileSeek();
  }
  if (!v1) {
    return 1LL;
  }
  while (1)
  {
    unint64_t v5 = v2 >= 0x20000 ? 0x20000LL : v2;
    unint64_t result = BOMFileRead(*v3, v7, v5);
    if (result == -1LL) {
      break;
    }
    if (result)
    {
      v2 -= result;
      if (v2) {
        continue;
      }
    }

    return 1LL;
  }

  return result;
}

uint64_t BOMPKZipNew(void *a1, uint64_t a2, char a3)
{
  uint64_t v6 = BOM_malloczero(0x58uLL);
  if (!v6) {
    return 0xFFFFFFFFLL;
  }
  int v7 = v6;
  *(void *)uint64_t v6 = a2;
  v6[8] = a3;
  *((_DWORD *)v6 + 12) = 16;
  uint64_t v8 = BOM_calloc(0x10uLL, 0x40uLL);
  *((void *)v7 + 5) = v8;
  if (!v8) {
    return 1LL;
  }
  uint64_t result = 0LL;
  *a1 = v7;
  return result;
}

void BOMPKZipFree(void *a1)
{
  if (*((_DWORD *)a1 + 13))
  {
    unint64_t v2 = 0LL;
    uint64_t v3 = 40LL;
    do
    {
      free(*(void **)(a1[5] + v3));
      ++v2;
      v3 += 64LL;
    }

    while (v2 < *((unsigned int *)a1 + 13));
  }

  int v4 = (void *)a1[5];
  if (v4) {
    free(v4);
  }
  if (*((_BYTE *)a1 + 8)) {
    BOMFileClose(*a1);
  }
  if (*((_DWORD *)a1 + 16))
  {
    uint64_t v5 = 0LL;
    unint64_t v6 = 0LL;
    do
    {
      free(*(void **)(a1[7] + v5));
      ++v6;
      v5 += 16LL;
    }

    while (v6 < *((unsigned int *)a1 + 16));
  }

  int v7 = (void *)a1[7];
  if (v7) {
    free(v7);
  }
  uint64_t v8 = (void *)a1[10];
  if (v8) {
    free(v8);
  }
  free(a1);
}

uint64_t BOMPKZipGetFile(uint64_t result)
{
  if (result) {
    return *(void *)result;
  }
  return result;
}

uint64_t BOMPKZipReadNextSignature(uint64_t a1, int *a2)
{
  uint64_t result = 1LL;
  if (a1 && a2)
  {
    while (1)
    {
      if (v9 <= 101010255)
      {
        switch(v9)
        {
          case 33639248:
            uint64_t result = 0LL;
            int v7 = 2;
            goto LABEL_29;
          case 67324752:
            goto LABEL_25;
          case 84233040:
            uint64_t result = 0LL;
            int v7 = 3;
            goto LABEL_29;
        }
      }

      else if (v9 > 117853007)
      {
        if (v9 == 117853008)
        {
          uint64_t result = 0LL;
          int v7 = 5;
          goto LABEL_29;
        }

        if (v9 == 808471376) {
          return BOMPKZipReadNextSignature(a1, a2);
        }
      }

      else
      {
        if (v9 == 101010256)
        {
          uint64_t result = 0LL;
          int v7 = 6;
          goto LABEL_29;
        }

        if (v9 == 101075792)
        {
          uint64_t result = 0LL;
          int v7 = 4;
LABEL_29:
          *a2 = v7;
          return result;
        }
      }

      __int16 v8 = 19280;
      if ((unsigned __int16)v9 == 19280)
      {
        if (v8 == 1027)
        {
LABEL_25:
          uint64_t result = 0LL;
          int v7 = 1;
          goto LABEL_29;
        }
      }

      uint64_t v5 = *(void *)(a1 + 80);
      if (v5)
      {
        unsigned int v6 = *(_DWORD *)(a1 + 12) - 1;
        if (*(_DWORD *)(a1 + 72) <= v6) {
          LODWORD(v5) = 0;
        }
        else {
          LODWORD(v5) = *(_DWORD *)(v5 + 12LL * v6);
        }
      }

      if ((_DWORD)v5 != v9)
      {
        *a2 = 0;
        return 1LL;
      }
    }
  }

  return result;
}

uint64_t BOMPKZipGetNumLocalHeaders(uint64_t a1)
{
  if (a1) {
    return *(unsigned int *)(a1 + 12);
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

uint64_t BOMPKZipReadLocalHeader( uint64_t a1, char *a2, uint64_t a3, unint64_t *a4, _DWORD *a5, _BYTE *a6, int *a7, unsigned int *a8, _BYTE *a9)
{
  uint64_t v45 = *MEMORY[0x1895F89C0];
  uint64_t result = 1LL;
  if (a1 && a2 && a3 && a4)
  {
    *(_OWORD *)(a3 + 112) = 0u;
    *(_OWORD *)(a3 + 128) = 0u;
    *(_OWORD *)(a3 + 80) = 0u;
    *(_OWORD *)(a3 + 96) = 0u;
    *(_OWORD *)(a3 + 48) = 0u;
    *(_OWORD *)(a3 + 64) = 0u;
    *(_OWORD *)(a3 + 16) = 0u;
    *(_OWORD *)(a3 + 32) = 0u;
    *(_OWORD *)a3 = 0u;
    unsigned int v18 = BOMStreamWithAddress((uint64_t)v44, 0x1AuLL, 0);
    if (!v18) {
      return 1LL;
    }
    uint64_t v19 = (uint64_t)v18;
    if (BOMStreamSetByteOrder((uint64_t)v18, 2u))
    {
      uint64_t v20 = v19;
LABEL_9:
      BOMStreamFree(v20);
      return 1LL;
    }

    BOMStreamReadUInt16(v19);
    unsigned int UInt16 = BOMStreamReadUInt16(v19);
    *a5 = BOMStreamReadUInt16(v19);
    int v21 = BOMStreamReadUInt16(v19);
    int v22 = BOMStreamReadUInt16(v19);
    unsigned int UInt32 = BOMStreamReadUInt32(v19);
    *a4 = BOMStreamReadUInt32(v19);
    *(void *)(a3 + 96) = BOMStreamReadUInt32(v19);
    unsigned int v43 = BOMStreamReadUInt16(v19);
    unsigned int v41 = BOMStreamReadUInt16(v19);
    time_t v23 = _dos2unixtime(v21 | (v22 << 16));
    *(_DWORD *)(a3 + 116) = 0;
    *(void *)(a3 + 32) = v23;
    *(void *)(a3 + 40) = 0LL;
    *(void *)(a3 + 48) = v23;
    *(void *)(a3 + 56) = 0LL;
    if (a6) {
      *a6 = UInt16 & 1;
    }
    if (a7) {
      *a7 = (UInt16 >> 3) & 1;
    }
    *a9 = 0;
    if (a8)
    {
      unsigned int v24 = (v21 << 16) & 0xFF000000;
      if ((UInt16 & 8) == 0) {
        unsigned int v24 = UInt32;
      }
      *a8 = v24;
    }

    BOMStreamFree(v19);
    if (v43)
    {
      if (v43 > 0x3FF) {
        return 1LL;
      }
      uint64_t v25 = v43;
      __int16 v26 = *(_WORD *)(a3 + 4);
      if (a2[v43 - 1] == 47)
      {
        *(_WORD *)(a3 + 4) = v26 | 0x41C0;
        uint64_t v25 = (unsigned __int16)(v43 - 1);
      }

      else
      {
        *(_WORD *)(a3 + 4) = v26 | 0x8180;
      }

      a2[v25] = 0;
      BOOL v32 = _sanitizePath(a2, v25);
      unsigned int v27 = v41;
      if (v32) {
        return 1LL;
      }
    }

    else
    {
      *a2 = 0;
      unsigned int v27 = v41;
    }

    if (!v27)
    {
LABEL_62:
      uint64_t result = 0LL;
      ++*(_DWORD *)(a1 + 12);
      return result;
    }

    unint64_t v28 = v27;
    if (v27 < 0x1B)
    {
      int v29 = v44;
    }

    else
    {
      int v29 = (char *)BOM_malloc(v27);
      if (!v29) {
        return 1LL;
      }
    }

    if (BOMFileRead(*(int **)a1, v29, v28) != v28)
    {
      if (v29 != v44) {
        free(v29);
      }
      return 1LL;
    }

    uint64_t v30 = BOMStreamWithAddress((uint64_t)v29, v28, 0);
    if (!v30) {
      return 1LL;
    }
    uint64_t v31 = (uint64_t)v30;
    if (BOMStreamSetByteOrder((uint64_t)v30, 2u))
    {
LABEL_34:
      uint64_t v20 = v31;
      goto LABEL_9;
    }

    int v33 = 0;
    unsigned int v34 = v41;
    while (1)
    {
      int v35 = BOMStreamReadUInt16(v31);
      unsigned int v36 = BOMStreamReadUInt16(v31);
      int v37 = v33 + 4;
      unsigned int v38 = v36;
      if (v35 == 1)
      {
        if (*(void *)(a3 + 96) == 0xFFFFFFFFLL)
        {
          *(void *)(a3 + 96) = BOMStreamReadUInt64(v31);
          int v39 = 8;
        }

        else
        {
          int v39 = 0;
        }

        if (*a4 == 0xFFFFFFFF)
        {
          *a4 = BOMStreamReadUInt64(v31);
          v39 += 8;
        }

        *a9 = 1;
        goto LABEL_55;
      }

      if (v35 != 22613)
      {
        int v39 = 0;
        goto LABEL_55;
      }

      *(void *)(a3 + 32) = BOMStreamReadUInt32(v31);
      *(void *)(a3 + 48) = BOMStreamReadUInt32(v31);
      if (v38 < 0xA) {
        break;
      }
      *(_DWORD *)(a3 + 16) = BOMStreamReadUInt16(v31);
      if (v38 != 12)
      {
        int v39 = 10;
LABEL_55:
        if (v38 != v39) {
          BOMStreamAdvance(v31, (unsigned __int16)(v38 - v39));
        }
        goto LABEL_57;
      }

      *(_DWORD *)(a3 + 20) = BOMStreamReadUInt16(v31);
LABEL_57:
      int v33 = v38 + v37;
      unsigned int v34 = v41;
      if (v41 == (unsigned __int16)v33)
      {
        BOMStreamFree(v31);
        if (v29 != v44) {
          free(v29);
        }
        goto LABEL_62;
      }
    }

    int v39 = 8;
    goto LABEL_55;
  }

  return result;
}

time_t _dos2unixtime(unsigned int a1)
{
  time_t v6 = time(0LL);
  unint64_t v2 = localtime(&v6);
  v3.i32[0] = a1;
  int8x16_t v4 = (int8x16_t)vshlq_u32((uint32x4_t)vdupq_n_s32(a1), (uint32x4_t)xmmword_18635AF80);
  v4.i32[0] = vshlq_u32(v3, (uint32x4_t)xmmword_18635AF70).u32[0];
  *(int8x16_t *)&v2->tm_sec = vandq_s8(v4, (int8x16_t)xmmword_18635AF90);
  v2->tm_mon = ((a1 >> 21) & 0xF) - 1;
  v2->tm_year = (a1 >> 25) + 80;
  return mktime(v2);
}

uint64_t BOMPKZipWriteLocalHeader(uint64_t a1, char *__s, uint64_t a3, int a4, int a5)
{
  uint64_t v41 = *MEMORY[0x1895F89C0];
  uint64_t v5 = 1LL;
  if (a1)
  {
    time_t v6 = __s;
    if (__s)
    {
      if (a3)
      {
        __int16 v11 = strlen(__s);
        int v12 = *v6;
        if (v12 != 46 || v11 != 1LL)
        {
          if (v12 == 46)
          {
            if (v6[1] == 47)
            {
              int v13 = v6[2];
              v6 += 2;
              int v12 = v13;
              v11 -= 2;
            }

            else
            {
              int v12 = 46;
            }
          }

          BOOL v14 = v12 == 47;
          __int16 v15 = v12 == 47;
          if (v14) {
            int v16 = v6 + 1;
          }
          else {
            int v16 = v6;
          }
          unsigned __int16 v17 = v11 - v15;
          int v18 = (unsigned __int16)(v11 - v15);
          int v19 = *(_WORD *)(a3 + 4) & 0xF000;
          if (v19 == 0x4000)
          {
            __memcpy_chk();
            v39[0] = 0;
            __int16 v21 = 0;
            __int16 v38 = 0;
            v40[v17++] = 47;
            v40[v17] = 0;
            unsigned int v20 = v18 + 47;
            __int16 v22 = 10;
            __src = v40;
          }

          else
          {
            unsigned int v20 = v18 + 46;
            __src = v16;
            if (v19 == 40960)
            {
              __int16 v21 = 0;
              __int16 v38 = 0;
              v39[0] = *(_DWORD *)(a3 + 96);
              __int16 v22 = 10;
            }

            else if (v19 == 0x8000)
            {
              *(void *)int v39 = *(void *)(a3 + 96);
              __int16 v21 = 8 * (*(void *)v39 != 0LL);
              if (*(void *)v39) {
                __int16 v22 = 20;
              }
              else {
                __int16 v22 = 10;
              }
              __int16 v38 = 8 * (*(void *)v39 != 0LL);
            }

            else
            {
              v39[0] = 0;
              __int16 v38 = 0;
              __int16 v22 = 20;
              __int16 v21 = 8;
            }
          }

          unint64_t v23 = v20;
          unsigned int v24 = BOM_malloc(v20);
          if (v24)
          {
            uint64_t v25 = v24;
            __int16 v36 = v22;
            uint64_t v5 = 1LL;
            __int16 v26 = BOMStreamWithAddress((uint64_t)v24, v23, 1);
            if (!v26) {
              return v5;
            }
            uint64_t v27 = (uint64_t)v26;
            if (BOMStreamSetByteOrder((uint64_t)v26, 2u))
            {
              BOMStreamFree(v27);
              free(v25);
              return v5;
            }

            BOMStreamWriteUInt32(v27, 0x4034B50u);
            BOMStreamWriteUInt16(v27, v36);
            BOMStreamWriteUInt16(v27, v21);
            BOMStreamWriteUInt16(v27, v38);
            unsigned int v28 = _unix2dostime((void *)(a3 + 48));
            BOMStreamWriteUInt32(v27, v28);
            int v29 = *(_WORD *)(a3 + 4) & 0xF000;
            if (v29 == 40960) {
              unsigned int v30 = a4;
            }
            else {
              unsigned int v30 = 0;
            }
            if (v29 == 40960) {
              unsigned int v31 = a5;
            }
            else {
              unsigned int v31 = 0;
            }
            if (v29 == 40960) {
              unsigned int v32 = v39[0];
            }
            else {
              unsigned int v32 = 0;
            }
            BOMStreamWriteUInt32(v27, v30);
            BOMStreamWriteUInt32(v27, v31);
            BOMStreamWriteUInt32(v27, v32);
            BOMStreamWriteUInt16(v27, v17);
            BOMStreamWriteUInt16(v27, 16 * ((*(_WORD *)(a3 + 4) & 0xF000) != 40960));
            BOMStreamWriteBuffer(v27, __src, v17);
            if ((*(_WORD *)(a3 + 4) & 0xF000) == 0xA000)
            {
              unint64_t v23 = (v23 - 16);
            }

            else
            {
              BOMStreamWriteUInt16(v27, 22613);
              BOMStreamWriteUInt16(v27, 12);
              BOMStreamWriteUInt32(v27, *(_DWORD *)(a3 + 32));
              BOMStreamWriteUInt32(v27, *(_DWORD *)(a3 + 48));
              BOMStreamWriteUInt16(v27, *(_WORD *)(a3 + 16));
              BOMStreamWriteUInt16(v27, *(_WORD *)(a3 + 20));
            }

            BOMStreamFree(v27);
            int v33 = BOMFileOffset(*(void *)a1);
            CFIndex v34 = BOMFileWrite(*(void *)a1, (UInt8 *)v25, v23);
            free(v25);
            if (v34 == v23 && !_squirrelAwayInfo(a1, v33, v36, v38, a3, a4, a5, v39[0], v17, __src))
            {
              uint64_t v5 = 0LL;
              ++*(_DWORD *)(a1 + 12);
              return v5;
            }
          }

          return 1LL;
        }

        return 0LL;
      }
    }
  }

  return v5;
}

uint64_t _unix2dostime(void *a1)
{
  time_t v4 = (*a1 + 1LL) & 0xFFFFFFFFFFFFFFFELL;
  uint64_t v1 = localtime(&v4);
  int tm_year = v1->tm_year;
  if (tm_year >= 80) {
    return ((tm_year << 25) + 1610612736) | (v1->tm_sec >> 1) | (32 * v1->tm_min) | (v1->tm_hour << 11) | (v1->tm_mday << 16) | ((v1->tm_mon << 21) + 0x200000);
  }
  else {
    return 2162688LL;
  }
}

uint64_t _squirrelAwayInfo( uint64_t a1, int a2, __int16 a3, __int16 a4, uint64_t a5, int a6, int a7, int a8, unsigned __int16 a9, void *__src)
{
  unsigned int v18 = *(_DWORD *)(a1 + 52);
  if (v18 == *(_DWORD *)(a1 + 48))
  {
    unsigned int v19 = 2 * v18;
    if (v18 > 0x4000) {
      unsigned int v19 = v18 + 0x4000;
    }
    *(_DWORD *)(a1 + 48) = v19;
    unsigned int v20 = BOM_realloc(*(void **)(a1 + 40), (unint64_t)v19 << 6);
    *(void *)(a1 + 40) = v20;
    if (!v20) {
      return 1LL;
    }
    unsigned int v18 = *(_DWORD *)(a1 + 52);
  }

  *(_DWORD *)(a1 + 52) = v18 + 1;
  __int16 v21 = BOM_malloc(a9);
  if (!v21) {
    return 1LL;
  }
  __int16 v22 = v21;
  memcpy(v21, __src, a9);
  unint64_t v23 = *(void *)(a1 + 40) + ((unint64_t)v18 << 6);
  *(_WORD *)unint64_t v23 = a3;
  *(_WORD *)(v23 + 2) = a4;
  uint64_t v24 = *(void *)(a5 + 48);
  *(void *)(v23 + 8) = *(void *)(a5 + 32);
  *(void *)(v23 + 16) = v24;
  *(_DWORD *)(v23 + 24) = a6;
  *(_DWORD *)(v23 + 28) = a7;
  *(_DWORD *)(v23 + 32) = a8;
  *(_WORD *)(v23 + 36) = a9;
  *(void *)(v23 + 40) = v22;
  int v25 = *(unsigned __int16 *)(a5 + 4);
  *(_DWORD *)(v23 + 48) = (v25 << 16) | 0x4000;
  *(_DWORD *)(v23 + 52) = a2;
  if ((v25 & 0xF000) == 0xA000)
  {
    char v26 = 1;
  }

  else
  {
    char v26 = 0;
    *(_DWORD *)(a1 + 36) += 12;
  }

  uint64_t result = 0LL;
  *(_BYTE *)(v23 + 56) = v26;
  *(_DWORD *)(a1 + 36) += a9 + 46;
  return result;
}

uint64_t BOMPKZipReadDataDescriptor(int **a1, int a2, _DWORD *a3, unint64_t *a4, unint64_t *a5)
{
  uint64_t v16 = *MEMORY[0x1895F89C0];
  uint64_t v5 = 1LL;
  if (a1 && a3 && a4 && a5)
  {
    unint64_t v10 = a2 ? 20LL : 12LL;
    if (BOMFileRead(*a1, v15, v10) == v10)
    {
      __int16 v11 = BOMStreamWithAddress((uint64_t)v15, v10, 0);
      if (v11)
      {
        uint64_t v12 = (uint64_t)v11;
        if (!BOMStreamSetByteOrder((uint64_t)v11, 2u))
        {
          *a3 = BOMStreamReadUInt32(v12);
          if (a2)
          {
            *a4 = BOMStreamReadUInt64(v12);
            unint64_t UInt64 = BOMStreamReadUInt64(v12);
          }

          else
          {
            *a4 = BOMStreamReadUInt32(v12);
            unint64_t UInt64 = BOMStreamReadUInt32(v12);
          }

          uint64_t v5 = 0LL;
          *a5 = UInt64;
        }

        BOMStreamFree(v12);
      }
    }
  }

  return v5;
}

BOOL BOMPKZipWriteDataDescriptor(uint64_t a1, unsigned int a2, unsigned int a3, unsigned int a4)
{
  uint64_t v14 = *MEMORY[0x1895F89C0];
  if (!a1) {
    return 1LL;
  }
  __int16 v8 = (_DWORD *)(*(void *)(a1 + 40) + ((unint64_t)(*(_DWORD *)(a1 + 52) - 1) << 6));
  v8[6] = a2;
  v8[7] = a3;
  v8[8] = a4;
  uint64_t v9 = 1LL;
  unint64_t v10 = BOMStreamWithAddress((uint64_t)v13, 0xCuLL, 1);
  if (v10)
  {
    uint64_t v11 = (uint64_t)v10;
    if (BOMStreamSetByteOrder((uint64_t)v10, 2u))
    {
      BOMStreamFree(v11);
    }

    else
    {
      BOMStreamWriteUInt32(v11, a2);
      BOMStreamWriteUInt32(v11, a3);
      BOMStreamWriteUInt32(v11, a4);
      BOMStreamFree(v11);
      return BOMFileWrite(*(void *)a1, v13, 12LL) != 12;
    }
  }

  return v9;
}

uint64_t BOMPKZipReadCentralHeader(int **a1, char *a2, uint64_t a3, void *a4)
{
  uint64_t v23 = *MEMORY[0x1895F89C0];
  uint64_t result = 1LL;
  if (a1 && a2 && a3)
  {
    *(_OWORD *)(a3 + 112) = 0u;
    *(_OWORD *)(a3 + 128) = 0u;
    *(_OWORD *)(a3 + 80) = 0u;
    *(_OWORD *)(a3 + 96) = 0u;
    *(_OWORD *)(a3 + 48) = 0u;
    *(_OWORD *)(a3 + 64) = 0u;
    *(_OWORD *)(a3 + 16) = 0u;
    *(_OWORD *)(a3 + 32) = 0u;
    *(_OWORD *)a3 = 0u;
    if (BOMFileRead(*a1, v22, 0x2AuLL) != 42) {
      return 1LL;
    }
    uint64_t v9 = BOMStreamWithAddress((uint64_t)v22, 0x2AuLL, 0);
    if (!v9) {
      return 1LL;
    }
    uint64_t v10 = (uint64_t)v9;
    if (BOMStreamSetByteOrder((uint64_t)v9, 2u))
    {
      BOMStreamFree(v10);
      return 1LL;
    }

    BOMStreamReadUInt16(v10);
    BOMStreamReadUInt16(v10);
    BOMStreamReadUInt16(v10);
    BOMStreamReadUInt16(v10);
    unsigned int UInt32 = BOMStreamReadUInt32(v10);
    *(void *)(a3 + 48) = _dos2unixtime(UInt32);
    BOMStreamReadUInt32(v10);
    *a4 = BOMStreamReadUInt32(v10);
    *(void *)(a3 + 96) = BOMStreamReadUInt32(v10);
    unsigned int UInt16 = BOMStreamReadUInt16(v10);
    unsigned int v13 = BOMStreamReadUInt16(v10);
    *(_DWORD *)(a3 + 116) = 0;
    unsigned int v14 = BOMStreamReadUInt16(v10);
    BOMStreamReadUInt16(v10);
    BOMStreamReadUInt16(v10);
    uint64_t v15 = BOMStreamReadUInt32(v10);
    char v16 = v15;
    *(_WORD *)(a3 + 4) = WORD1(v15);
    BOMStreamReadUInt32(v10);
    BOMStreamFree(v10);
    if (UInt16)
    {
      __int16 v17 = UInt16;
      if (UInt16 > 0x3FF) {
        return 1LL;
      }
      if (BOMFileRead(*a1, a2, UInt16) != UInt16) {
        return 1LL;
      }
      unsigned int UInt16 = a2[UInt16 - 1] == 47;
      uint64_t v18 = (unsigned __int16)(v17 - UInt16);
      a2[v18] = 0;
      if (_sanitizePath(a2, v18)) {
        return 1LL;
      }
    }

    if (*(unsigned __int16 *)(a3 + 4) <= 0xFFFu)
    {
      else {
        __int16 v19 = 0x8000;
      }
      *(_WORD *)(a3 + 4) = v19;
    }

    if (v13)
    {
      if (v13 < 0x2B)
      {
        unsigned int v20 = v22;
      }

      else
      {
        unsigned int v20 = (char *)BOM_malloc(v13);
        if (!v20) {
          return 1LL;
        }
      }

      if (BOMFileRead(*a1, v20, v13) != v13) {
        return 1LL;
      }
      if (v20 != v22) {
        free(v20);
      }
    }

    if (!v14) {
      return 0LL;
    }
    if (v14 < 0x2B)
    {
      __int16 v21 = v22;
    }

    else
    {
      __int16 v21 = (char *)BOM_malloc(v14);
      if (!v21) {
        return 1LL;
      }
    }

    if (BOMFileRead(*a1, v21, v14) == v14)
    {
      if (v21 != v22) {
        free(v21);
      }
      return 0LL;
    }

    return 1LL;
  }

  return result;
}

uint64_t BOMPKZipWriteCentralDirectory(uint64_t a1)
{
  if (!a1) {
    return 1LL;
  }
  int v2 = *(_DWORD *)(a1 + 36);
  if (!v2) {
    return 1LL;
  }
  size_t v3 = (v2 + 22);
  time_t v4 = BOM_malloc(v3);
  if (!v4) {
    return 1LL;
  }
  uint64_t v5 = v4;
  time_t v6 = BOMStreamWithAddress((uint64_t)v4, v3, 1);
  if (!v6)
  {
LABEL_7:
    free(v5);
    return 1LL;
  }

  uint64_t v7 = (uint64_t)v6;
  if (BOMStreamSetByteOrder((uint64_t)v6, 2u))
  {
    BOMStreamFree(v7);
    goto LABEL_7;
  }

  if (*(_DWORD *)(a1 + 52))
  {
    uint64_t v10 = 0LL;
    unint64_t v11 = 0LL;
    do
    {
      BOMStreamWriteUInt32(v7, 0x2014B50u);
      BOMStreamWriteUInt16(v7, 789);
      BOMStreamWriteUInt16(v7, *(_WORD *)(*(void *)(a1 + 40) + v10));
      uint64_t v12 = *(void *)(a1 + 40) + v10;
      if (*(_BYTE *)(v12 + 56)) {
        __int16 v13 = 0;
      }
      else {
        __int16 v13 = 8 * (*(_DWORD *)(v12 + 32) != 0);
      }
      BOMStreamWriteUInt16(v7, v13);
      BOMStreamWriteUInt16(v7, *(_WORD *)(*(void *)(a1 + 40) + v10 + 2));
      unsigned int v14 = _unix2dostime((void *)(*(void *)(a1 + 40) + v10 + 16));
      BOMStreamWriteUInt32(v7, v14);
      BOMStreamWriteUInt32(v7, *(_DWORD *)(*(void *)(a1 + 40) + v10 + 24));
      BOMStreamWriteUInt32(v7, *(_DWORD *)(*(void *)(a1 + 40) + v10 + 28));
      BOMStreamWriteUInt32(v7, *(_DWORD *)(*(void *)(a1 + 40) + v10 + 32));
      BOMStreamWriteUInt16(v7, *(_WORD *)(*(void *)(a1 + 40) + v10 + 36));
      if (*(_BYTE *)(*(void *)(a1 + 40) + v10 + 56)) {
        __int16 v15 = 0;
      }
      else {
        __int16 v15 = 12;
      }
      BOMStreamWriteUInt16(v7, v15);
      BOMStreamWriteUInt16(v7, 0);
      BOMStreamWriteUInt16(v7, 0);
      BOMStreamWriteUInt16(v7, 0);
      BOMStreamWriteUInt32(v7, *(_DWORD *)(*(void *)(a1 + 40) + v10 + 48));
      BOMStreamWriteUInt32(v7, *(_DWORD *)(*(void *)(a1 + 40) + v10 + 52));
      BOMStreamWriteBuffer( v7,  *(const void **)(*(void *)(a1 + 40) + v10 + 40),  *(unsigned __int16 *)(*(void *)(a1 + 40) + v10 + 36));
      if (!*(_BYTE *)(*(void *)(a1 + 40) + v10 + 56))
      {
        BOMStreamWriteUInt16(v7, 22613);
        BOMStreamWriteUInt16(v7, 8);
        BOMStreamWriteUInt32(v7, *(_DWORD *)(*(void *)(a1 + 40) + v10 + 8));
        BOMStreamWriteUInt32(v7, *(_DWORD *)(*(void *)(a1 + 40) + v10 + 16));
      }

      ++v11;
      v10 += 64LL;
    }

    while (v11 < *(unsigned int *)(a1 + 52));
  }

  BOMStreamWriteUInt32(v7, 0x6054B50u);
  BOMStreamWriteUInt16(v7, 0);
  BOMStreamWriteUInt16(v7, 0);
  BOMStreamWriteUInt16(v7, *(_WORD *)(a1 + 52));
  BOMStreamWriteUInt16(v7, *(_WORD *)(a1 + 52));
  BOMStreamWriteUInt32(v7, *(_DWORD *)(a1 + 36));
  unsigned int v16 = BOMFileOffset(*(void *)a1);
  BOMStreamWriteUInt32(v7, v16);
  BOMStreamWriteUInt16(v7, 0);
  BOMStreamFree(v7);
  BOOL v8 = BOMFileWrite(*(void *)a1, (UInt8 *)v5, v3) != v3;
  free(v5);
  return v8;
}

uint64_t BOMPKZipSkipDigitalSignature(int **a1)
{
  if (!v7) {
    return 0LL;
  }
  int v2 = (char *)BOM_malloc(v7);
  if (!v2) {
    return 1LL;
  }
  size_t v3 = v2;
  unint64_t v4 = BOMFileRead(*a1, v2, v7);
  BOOL v5 = v4 != v7;
  free(v3);
  return v5;
}

uint64_t BOMPKZipSkipZIP64CentralDirectoryRecord(int **a1)
{
  if (!v6) {
    return 0LL;
  }
  int v2 = (char *)BOM_malloc(0x2CuLL);
  if (!v2) {
    return 1LL;
  }
  size_t v3 = v2;
  BOOL v4 = BOMFileRead(*a1, v2, 0x2CuLL) != 44;
  free(v3);
  return v4;
}

BOOL BOMPKZipSkipZIP64CentralDirectoryLocation(int **a1)
{
  uint64_t v3 = *MEMORY[0x1895F89C0];
  return !a1 || BOMFileRead(*a1, v2, 0x10uLL) != 16;
}

uint64_t BOMPKZipSkipEndOfCentralDirectoryRecord(int **a1)
{
  uint64_t v10 = *MEMORY[0x1895F89C0];
  unint64_t v4 = v6;
  if (!v6) {
    return 0LL;
  }
  BOOL v5 = v9;
  if (v6 >= 0x13u)
  {
    BOOL v5 = (char *)BOM_malloc(v6);
    if (!v5) {
      return 1LL;
    }
  }

  BOOL v2 = BOMFileRead(*a1, v5, v4) != v4;
  if (v5 != v9) {
    free(v5);
  }
  return v2;
}

uint64_t _readEOCDRecord(uint64_t a1, _WORD *a2, _DWORD *a3, _WORD *a4)
{
  int v7 = BOMStreamWithAddress(a1, 0x12uLL, 0);
  if (!v7) {
    return 1LL;
  }
  uint64_t v8 = (uint64_t)v7;
  if (BOMStreamSetByteOrder((uint64_t)v7, 2u))
  {
    uint64_t v9 = 1LL;
  }

  else
  {
    BOMStreamReadUInt16(v8);
    BOMStreamReadUInt16(v8);
    BOMStreamReadUInt16(v8);
    *a2 = BOMStreamReadUInt16(v8);
    BOMStreamReadUInt32(v8);
    *a3 = BOMStreamReadUInt32(v8);
    uint64_t v9 = 0LL;
    *a4 = BOMStreamReadUInt16(v8);
  }

  BOMStreamFree(v8);
  return v9;
}

uint64_t BOMPKZipGetFileCompressedSize(uint64_t result, unsigned int a2)
{
  if (result)
  {
    uint64_t v2 = *(void *)(result + 80);
    if (v2 && *(_DWORD *)(result + 72) > a2) {
      return *(unsigned int *)(v2 + 12LL * a2 + 4);
    }
    else {
      return 0LL;
    }
  }

  return result;
}

uint64_t BOMPKZipGetFileUncompressedSize(uint64_t result, unsigned int a2)
{
  if (result)
  {
    uint64_t v2 = *(void *)(result + 80);
    if (v2 && *(_DWORD *)(result + 72) > a2) {
      return *(unsigned int *)(v2 + 12LL * a2 + 8);
    }
    else {
      return 0LL;
    }
  }

  return result;
}

uint64_t BOMPKZipLoadCentralDirectory(uint64_t a1)
{
  uint64_t v17 = *MEMORY[0x1895F89C0];
  BOMFileOffset(*(void *)a1);
  if (BOMPKZipSeekToCentralDirectory() || BOMPKZipReadNextSignature(a1, &v15))
  {
LABEL_3:
    uint64_t v2 = 0xFFFFFFFFLL;
    goto LABEL_4;
  }

  while (v15 == 2)
  {
    unint64_t v4 = *(void **)(a1 + 80);
    if (v4)
    {
      unsigned int v5 = *(_DWORD *)(a1 + 68);
      if (*(_DWORD *)(a1 + 72) + 1 <= v5) {
        goto LABEL_12;
      }
      unsigned int v6 = v5 + 32;
      *(_DWORD *)(a1 + 68) = v6;
      int v7 = BOM_realloc(v4, 12LL * v6);
    }

    else
    {
      *(void *)(a1 + 68) = 32LL;
      int v7 = BOM_malloczero(0x180uLL);
    }

    *(void *)(a1 + 80) = v7;
    if (!v7)
    {
      *(_DWORD *)(a1 + 68) = 0;
      *(_DWORD *)(a1 + 72) = 0;
      goto LABEL_3;
    }

uint64_t BOMPKZipSeekToCentralDirectory()
{
  uint64_t v0 = MEMORY[0x1895F8858]();
  uint64_t v2 = v1;
  uint64_t v3 = (int **)v0;
  uint64_t v25 = *MEMORY[0x1895F89C0];
  unint64_t v4 = BOMFileSeek();
  if ((v4 & 0x8000000000000000LL) != 0) {
    return 0xFFFFFFFFLL;
  }
  int64_t v5 = v4;
  unint64_t v6 = v4 >= 0x10016 ? 65558LL : v4;
  int v7 = &v24[(v6 - 22)];
  if (*(_DWORD *)v7 != 101010256)
  {
    unint64_t v8 = v6 & 0x3FF | 0x400;
    if (v6 < v8) {
      LODWORD(v8) = v6;
    }
    uint64_t v9 = &v24[(int)v6 - (int)v8];
    if (v9 < v24) {
      return 0xFFFFFFFFLL;
    }
    unsigned int v10 = v8 - 18;
    do
    {
      int v7 = 0LL;
      int v11 = v9;
LABEL_14:
      size_t v12 = (int)v10 - 3LL;
      if (v10 != 3LL)
      {
        unsigned int v13 = v11;
        do
        {
          unsigned int v14 = (char *)memchr(v13, 80, v12);
          if (!v14) {
            break;
          }
          if (*(_DWORD *)v14 == 101010256)
          {
            int v16 = (_DWORD)v14 - (_DWORD)v11 + 4;
            v10 -= v16;
            v11 += v16;
            int v7 = v14;
            if (v10 > 3) {
              goto LABEL_14;
            }
            goto LABEL_25;
          }

          int64_t v15 = v14 - v13;
          unsigned int v13 = v14 + 1;
          v12 += ~v15;
        }

        while (v12);
      }

      v9 -= 1024;
      if (v7) {
        break;
      }
      unsigned int v10 = 1027;
    }

    while (v9 >= v24);
  }

  unsigned int v14 = v7;
  if (!v7) {
    return 0xFFFFFFFFLL;
  }
LABEL_25:
  int64_t v18 = v23;
  unint64_t v19 = v5 - v23;
  do
  {
    if (v18 >= v5) {
      break;
    }
    v18 += 0x100000000LL;
    unint64_t v20 = HIDWORD(v19);
    v19 -= 0x100000000LL;
  }

  while (v20);
  if (v2) {
    *uint64_t v2 = v22;
  }
  return BOMFileSeek() >> 63;
}

uint64_t BOMPKZipStoreQuarantinePath(uint64_t a1, char *__s)
{
  uint64_t result = 1LL;
  if (a1 && __s)
  {
    unsigned __int8 v5 = strlen(__s);
    unsigned __int8 v6 = v5;
    int v7 = *(_DWORD *)(a1 + 64);
    if (v7)
    {
      char v19 = 0;
      _search(a1, 0, v7 - 1, __s, v5, &v20, &v19);
      if (v19) {
        return 1LL;
      }
      unint64_t v8 = (char *)BOM_realloc(*(void **)(a1 + 56), 16LL * (v7 + 1));
      *(void *)(a1 + 56) = v8;
      if (!v8) {
        return 1LL;
      }
      uint64_t v9 = *(unsigned int *)(a1 + 64);
      uint64_t v10 = v20;
      if (v9 > v20)
      {
        int v11 = &v8[16 * v9 + 8];
        size_t v12 = &v8[16 * (v9 - 1) + 8];
        unsigned int v13 = *(_DWORD *)(a1 + 64);
        do
        {
          *((void *)v11 - 1) = *((void *)v12 - 1);
          char v14 = *v12;
          v12 -= 16;
          *int v11 = v14;
          v11 -= 16;
          --v13;
        }

        while (v10 < v13);
      }

      *(_DWORD *)(a1 + 64) = v9 + 1;
      int64_t v15 = BOM_malloc(v6);
      int v16 = *(void **)(a1 + 56);
      v16[2 * v10] = v15;
      if (v15)
      {
        memcpy(v15, __s, v6);
        uint64_t result = 0LL;
        *(_BYTE *)(*(void *)(a1 + 56) + 16 * v10 + 8) = v6;
        return result;
      }
    }

    else
    {
      uint64_t v17 = BOM_malloc(0x10uLL);
      *(void *)(a1 + 56) = v17;
      if (!v17) {
        return 1LL;
      }
      int64_t v18 = BOM_malloc(v6);
      int v16 = *(void **)(a1 + 56);
      *int v16 = v18;
      if (v18)
      {
        memcpy(v18, __s, v6);
        uint64_t result = 0LL;
        *(_BYTE *)(*(void *)(a1 + 56) + 8LL) = v6;
        ++*(_DWORD *)(a1 + 64);
        return result;
      }
    }

    free(v16);
    return 1LL;
  }

  return result;
}

uint64_t _search( uint64_t a1, unsigned int a2, unsigned int a3, void *__s1, unsigned int a5, unsigned int *a6, _BYTE *a7)
{
  uint64_t v13 = *(void *)(a1 + 56);
  while (1)
  {
    while (1)
    {
      unsigned int v14 = a2 + ((a3 - a2) >> 1);
      uint64_t v15 = v13 + 16LL * v14;
      unsigned int v16 = *(unsigned __int8 *)(v15 + 8);
      size_t v17 = v16 >= a5 ? a5 : *(unsigned __int8 *)(v15 + 8);
      uint64_t result = memcmp(__s1, *(const void **)v15, v17);
      if ((result & 0x80000000) == 0) {
        break;
      }
      if (a3 == a2)
      {
        BOOL v20 = 0;
LABEL_21:
        *a6 = v14 + v20;
        return result;
      }

uint64_t BOMPKZipLookupQuarantinePath(uint64_t a1, char *__s, _BYTE *a3)
{
  uint64_t result = 1LL;
  if (a1 && __s && a3)
  {
    int v7 = *(_DWORD *)(a1 + 64);
    *a3 = 0;
    if (v7)
    {
      unsigned __int8 v8 = strlen(__s);
      _search(a1, 0, *(_DWORD *)(a1 + 64) - 1, __s, v8, &v9, a3);
    }

    return 0LL;
  }

  return result;
}

uint64_t BOMPKZipQuarantinePathCount(uint64_t a1)
{
  if (a1) {
    return *(unsigned int *)(a1 + 64);
  }
  else {
    return 1LL;
  }
}

uint64_t BOMPKZipCopyQuarantinePath(uint64_t a1, unsigned int a2, void *__dst)
{
  if (!a1) {
    return 1LL;
  }
  if (*(_DWORD *)(a1 + 64) < a2) {
    return 1LL;
  }
  uint64_t v7 = *(void *)(a1 + 56) + 16LL * a2;
  memcpy(__dst, *(const void **)v7, *(unsigned __int8 *)(v7 + 8));
  uint64_t result = 0LL;
  *((_BYTE *)__dst + *(unsigned __int8 *)(*(void *)(a1 + 56) + 16LL * a2 + 8)) = 0;
  return result;
}

uint64_t decrypt_byte(uint64_t a1)
{
  return ((unsigned __int16)((*(_WORD *)(a1 + 8) & 0xFFFD ^ 3) * (*(_WORD *)(a1 + 8) | 2)) >> 8);
}

uint64_t update_keys(int *a1, uint64_t a2)
{
  int v2 = PKZip_crctab_0[(*a1 ^ a2)] ^ (*a1 >> 8);
  unsigned int v3 = 134775813 * (a1[1] + v2) + 1;
  *a1 = v2;
  a1[1] = v3;
  a1[2] = PKZip_crctab_0[a1[2] ^ HIBYTE(v3)] ^ (a1[2] >> 8);
  return a2;
}

uint64_t init_keys(uint64_t result, _BYTE *a2)
{
  *(void *)uint64_t result = 0x2345678912345678LL;
  *(_DWORD *)(result + 8) = 878082192;
  char v2 = *a2;
  if (*a2)
  {
    unsigned int v3 = (int *)result;
    unint64_t v4 = a2 + 1;
    do
    {
      uint64_t result = update_keys(v3, v2);
      int v5 = *v4++;
      char v2 = v5;
    }

    while (v5);
  }

  return result;
}

uint64_t *BOMCopierDataAnalyzerNew(int a1, void *a2)
{
  if (!a1)
  {
    BOMCopierErrorCapture( a2,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDataAnalyzer.c",  90,  (uint64_t)"BOMCopierDataAnalyzerNew",  "No flag is set.");
    return 0LL;
  }

  __int16 v3 = a1;
  unint64_t v4 = (uint64_t *)calloc(1uLL, 0x90uLL);
  if (!v4)
  {
    int v7 = *__error();
    unsigned __int8 v8 = __error();
    strerror(*v8);
    BOMCopierErrorCapture( a2,  v7,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDataAnalyzer.c",  103,  (uint64_t)"BOMCopierDataAnalyzerNew",  "Could not allocate BOMCopierDataAnalyzer: %s");
    return 0LL;
  }

  int v5 = v4;
  if ((v3 & 1) != 0)
  {
    *v4 |= 1uLL;
    if ((v3 & 2) == 0)
    {
LABEL_5:
      if ((v3 & 8) == 0) {
        goto LABEL_6;
      }
      goto LABEL_20;
    }
  }

  else if ((v3 & 2) == 0)
  {
    goto LABEL_5;
  }

  *v4 |= 2uLL;
  if ((v3 & 8) == 0)
  {
LABEL_6:
    if ((v3 & 0x10) == 0) {
      goto LABEL_7;
    }
    goto LABEL_21;
  }

uint64_t init_data_analyzer(uint64_t *a1, void *a2)
{
  uint64_t v4 = *a1;
  if ((*a1 & 1) != 0)
  {
    unsigned __int8 v6 = a1 + 1;
    if (a1[1])
    {
      CNCRCRelease();
      void *v6 = 0LL;
    }

    if (CNCRCInit())
    {
      int v7 = *__error();
      unsigned __int8 v8 = __error();
      strerror(*v8);
      BOMCopierErrorCapture( a2,  v7,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDataAnalyzer.c",  474,  (uint64_t)"init_data_analyzer",  "Could not allocate CRC_32 context: %s");
      return 1LL;
    }

    *((_DWORD *)a1 + 4) = 0;
    uint64_t v4 = *a1;
    int v5 = 1;
    if ((*a1 & 2) == 0)
    {
LABEL_3:
      if ((v4 & 8) == 0) {
        goto LABEL_4;
      }
      goto LABEL_21;
    }
  }

  else
  {
    int v5 = 0;
    if ((v4 & 2) == 0) {
      goto LABEL_3;
    }
  }

  if (a1[3])
  {
    CNCRCRelease();
    a1[3] = 0LL;
  }

  if (CNCRCInit())
  {
    int v9 = *__error();
    uint64_t v10 = __error();
    strerror(*v10);
    BOMCopierErrorCapture( a2,  v9,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDataAnalyzer.c",  498,  (uint64_t)"init_data_analyzer",  "Could not allocate CRC_32 POSIX context: %s");
    return 1LL;
  }

  *((_DWORD *)a1 + 10) = 0;
  a1[4] = 0LL;
  ++v5;
  uint64_t v4 = *a1;
  if ((*a1 & 8) == 0)
  {
LABEL_4:
    if ((v4 & 0x10) == 0) {
      goto LABEL_5;
    }
    goto LABEL_26;
  }

void BOMCopierDataAnalyzerFree(void *a1)
{
  if (a1)
  {
    if (a1[1]) {
      CNCRCRelease();
    }
    if (a1[3]) {
      CNCRCRelease();
    }
    char v2 = (void *)a1[6];
    if (v2) {
      free(v2);
    }
    __int16 v3 = (void *)a1[7];
    if (v3) {
      free(v3);
    }
    uint64_t v4 = (void *)a1[8];
    if (v4) {
      free(v4);
    }
    int v5 = (void *)a1[9];
    if (v5) {
      free(v5);
    }
    unsigned __int8 v6 = (void *)a1[10];
    if (v6) {
      free(v6);
    }
    int v7 = (void *)a1[11];
    if (v7) {
      free(v7);
    }
    unsigned __int8 v8 = (void *)a1[12];
    if (v8) {
      free(v8);
    }
    int v9 = (void *)a1[13];
    if (v9) {
      free(v9);
    }
    uint64_t v10 = (void *)a1[14];
    if (v10) {
      free(v10);
    }
    uint64_t v11 = (void *)a1[15];
    if (v11) {
      free(v11);
    }
    size_t v12 = (void *)a1[16];
    if (v12) {
      free(v12);
    }
    uint64_t v13 = (void *)a1[17];
    if (v13) {
      free(v13);
    }
    free(a1);
  }

uint64_t *BOMCopierDataAnalyzerReset(uint64_t *result)
{
  if (result)
  {
    uint64_t v1 = 0LL;
    uint64_t result = (uint64_t *)init_data_analyzer(result, &v1);
    if ((_DWORD)result) {
      return BOMCopierErrorCapture( &v1,  (int)result,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDataAnalyzer.c",  219,  (uint64_t)"BOMCopierDataAnalyzerReset",  "Could not initialize BOMCopierDataAnalyzer");
    }
  }

  return result;
}

uint64_t BOMCopierDataAnalyzerUpdate(uint64_t *a1, void *data, uint64_t len, void *a4)
{
  if (a1)
  {
    if (data)
    {
      if (len)
      {
        uint64_t v8 = *a1;
        if ((*a1 & 1) != 0)
        {
          if (CNCRCUpdate())
          {
            int v9 = *__error();
            uint64_t v10 = __error();
            strerror(*v10);
            BOMCopierErrorCapture( a4,  v9,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDataAnalyzer.c",  723,  (uint64_t)"update_data_analyzer",  "Could not update CRC_32 context: %s");
            return 1LL;
          }

          uint64_t v8 = *a1;
        }

        if ((v8 & 2) != 0)
        {
          if (CNCRCUpdate())
          {
            int v13 = *__error();
            unsigned int v14 = __error();
            strerror(*v14);
            BOMCopierErrorCapture( a4,  v13,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDataAnalyzer.c",  737,  (uint64_t)"update_data_analyzer",  "Could not update CRC_32 POSIX context: %s");
            return 1LL;
          }

          a1[4] += len;
          uint64_t v8 = *a1;
        }

        if ((v8 & 8) != 0)
        {
          CC_MD5_Update((CC_MD5_CTX *)a1[6], data, len);
          uint64_t v8 = *a1;
          if ((*a1 & 0x10) == 0)
          {
LABEL_19:
            if ((v8 & 0x20) == 0) {
              goto LABEL_20;
            }
            goto LABEL_27;
          }
        }

        else if ((v8 & 0x10) == 0)
        {
          goto LABEL_19;
        }

        CC_SHA1_Update((CC_SHA1_CTX *)a1[7], data, len);
        uint64_t v8 = *a1;
        if ((*a1 & 0x20) == 0)
        {
LABEL_20:
          if ((v8 & 0x40) == 0) {
            goto LABEL_21;
          }
          goto LABEL_28;
        }

uint64_t BOMCopierDataAnalyzerFinalize(uint64_t *a1, void *a2)
{
  if (a1)
  {
    uint64_t v4 = *a1;
    if ((*a1 & 1) != 0)
    {
      if (CNCRCFinal())
      {
        int v5 = *__error();
        unsigned __int8 v6 = __error();
        strerror(*v6);
        BOMCopierErrorCapture( a2,  v5,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDataAnalyzer.c",  820,  (uint64_t)"finalize_data_analyzer",  "Could not finalize CRC_32 context: %s");
        return 1LL;
      }

      *((_DWORD *)a1 + 4) = 0;
      uint64_t v4 = *a1;
    }

    if ((v4 & 2) != 0)
    {
      uint64_t v8 = a1[4];
      if (v8)
      {
        while (!CNCRCUpdate())
        {
          BOOL v9 = (unint64_t)v8 > 0xFF;
          v8 >>= 8;
          if (!v9) {
            goto LABEL_11;
          }
        }

        int v12 = *__error();
        int v13 = __error();
        strerror(*v13);
        BOMCopierErrorCapture( a2,  v12,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDataAnalyzer.c",  842,  (uint64_t)"finalize_data_analyzer",  "Could not update length for CRC_32 POSIX context: %s");
        return 1LL;
      }

uint64_t BOMCopierDataAnalyzerGetDigest(uint64_t a1, int a2, uint64_t a3, void *a4)
{
  if (a1)
  {
    if (a3)
    {
      switch(a2)
      {
        case 1:
          if ((*(_BYTE *)a1 & 1) == 0)
          {
            BOMCopierErrorCapture( a4,  45,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDataAnalyzer.c",  303,  (uint64_t)"BOMCopierDataAnalyzerGetDigest",  "CRC32 is not supported");
            goto LABEL_23;
          }

          uint64_t v4 = 0LL;
          int v5 = *(_DWORD *)(a1 + 16);
          goto LABEL_27;
        case 2:
          if ((*(_BYTE *)a1 & 2) == 0)
          {
            BOMCopierErrorCapture( a4,  45,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDataAnalyzer.c",  314,  (uint64_t)"BOMCopierDataAnalyzerGetDigest",  "CRC32 POSIX is not supported");
            goto LABEL_23;
          }

          uint64_t v4 = 0LL;
          int v5 = *(_DWORD *)(a1 + 40);
LABEL_27:
          *(_DWORD *)a3 = v5;
          return v4;
        case 3:
          if ((*(_BYTE *)a1 & 8) == 0)
          {
            BOMCopierErrorCapture( a4,  45,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDataAnalyzer.c",  325,  (uint64_t)"BOMCopierDataAnalyzerGetDigest",  "MD5 is not supported");
            goto LABEL_23;
          }

          uint64_t v4 = 0LL;
          __int128 v6 = *(_OWORD *)*(void *)(a1 + 96);
          goto LABEL_31;
        case 4:
          if ((*(_BYTE *)a1 & 0x10) == 0)
          {
            BOMCopierErrorCapture( a4,  45,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDataAnalyzer.c",  336,  (uint64_t)"BOMCopierDataAnalyzerGetDigest",  "SHA1 is not supported");
            goto LABEL_23;
          }

          uint64_t v4 = 0LL;
          uint64_t v7 = *(__int128 **)(a1 + 104);
          __int128 v6 = *v7;
          *(_DWORD *)(a3 + 16) = *((_DWORD *)v7 + 4);
          goto LABEL_31;
        case 5:
          if ((*(_BYTE *)a1 & 0x20) == 0)
          {
            BOMCopierErrorCapture( a4,  45,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDataAnalyzer.c",  347,  (uint64_t)"BOMCopierDataAnalyzerGetDigest",  "SHA224 is not supported");
            goto LABEL_23;
          }

          uint64_t v4 = 0LL;
          uint64_t v8 = *(__int128 **)(a1 + 112);
          __int128 v6 = *v8;
          *(_OWORD *)(a3 + 12) = *(__int128 *)((char *)v8 + 12);
LABEL_31:
          *(_OWORD *)a3 = v6;
          return v4;
        case 6:
          if ((*(_BYTE *)a1 & 0x40) == 0)
          {
            BOMCopierErrorCapture( a4,  45,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDataAnalyzer.c",  358,  (uint64_t)"BOMCopierDataAnalyzerGetDigest",  "SHA256 is not supported");
            goto LABEL_23;
          }

          uint64_t v4 = 0LL;
          BOOL v9 = *(__int128 **)(a1 + 120);
          __int128 v10 = *v9;
          __int128 v11 = v9[1];
          goto LABEL_36;
        case 7:
          if ((*(_BYTE *)a1 & 0x80) == 0)
          {
            BOMCopierErrorCapture( a4,  45,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDataAnalyzer.c",  369,  (uint64_t)"BOMCopierDataAnalyzerGetDigest",  "SHA384 is not supported");
            goto LABEL_23;
          }

          uint64_t v4 = 0LL;
          int v12 = *(__int128 **)(a1 + 128);
          __int128 v10 = *v12;
          __int128 v11 = v12[1];
          __int128 v13 = v12[2];
          goto LABEL_35;
        case 8:
          if ((*(_BYTE *)(a1 + 1) & 1) != 0)
          {
            uint64_t v4 = 0LL;
            unsigned int v14 = *(__int128 **)(a1 + 136);
            __int128 v10 = *v14;
            __int128 v11 = v14[1];
            __int128 v13 = v14[2];
            *(_OWORD *)(a3 + 48) = v14[3];
LABEL_35:
            *(_OWORD *)(a3 + 32) = v13;
LABEL_36:
            *(_OWORD *)a3 = v10;
            *(_OWORD *)(a3 + 16) = v11;
          }

          else
          {
            BOMCopierErrorCapture( a4,  45,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDataAnalyzer.c",  380,  (uint64_t)"BOMCopierDataAnalyzerGetDigest",  "SHA512 is not supported");
LABEL_23:
            uint64_t v4 = 22LL;
          }

          break;
        default:
          uint64_t v4 = 22LL;
          BOMCopierErrorCapture( a4,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDataAnalyzer.c",  389,  (uint64_t)"BOMCopierDataAnalyzerGetDigest",  "Unknown digest_type: %d");
          return v4;
      }
    }

    else
    {
      uint64_t v4 = 22LL;
      BOMCopierErrorCapture( a4,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDataAnalyzer.c",  293,  (uint64_t)"BOMCopierDataAnalyzerGetDigest",  "message_digest is NULL");
    }
  }

  else
  {
    uint64_t v4 = 22LL;
    BOMCopierErrorCapture( a4,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDataAnalyzer.c",  287,  (uint64_t)"BOMCopierDataAnalyzerGetDigest",  "data_analyzer is NULL");
  }

  return v4;
}

uint64_t BOMCopierMultiCopy()
{
  return 22LL;
}

uint64_t BOMCopierMultiCopyWithOptions()
{
  return 22LL;
}

uint64_t volume_has_data_protection(const char *a1)
{
  uint64_t v7 = *MEMORY[0x1895F89C0];
  if (!statfs(a1, &v6)) {
    return LOBYTE(v6.f_flags) >> 7;
  }
  char v2 = (FILE *)*MEMORY[0x1895F89D0];
  __int16 v3 = __error();
  uint64_t v4 = strerror(*v3);
  fprintf(v2, "Could not statfs %s: %s\n", a1, v4);
  return 0LL;
}

BOOL set_timestamps_0(const char *a1, __int128 *a2, _OWORD *a3)
{
  uint64_t v7 = 0LL;
  __int128 v3 = *a2;
  v5[0] = *a3;
  v5[1] = v3;
  __int128 v6 = xmmword_18635B3C8;
  return setattrlist(a1, &v6, v5, 0x20uLL, 1u) != 0;
}

uint64_t _mkdirs_parent(uint64_t a1)
{
  uint64_t v5 = *MEMORY[0x1895F89C0];
  __strlcpy_chk();
  char v2 = strrchr(__s, 47);
  uint64_t result = 0LL;
  if (v2)
  {
    if (__s != v2)
    {
      *char v2 = 0;
      return _mkdirs(a1, (uint64_t)__s);
    }
  }

  return result;
}

uint64_t _mkdirs(uint64_t a1, uint64_t a2)
{
  uint64_t v10 = *MEMORY[0x1895F89C0];
  if (!a2) {
    return 0xFFFFFFFFLL;
  }
  if (!(*(unsigned int (**)(void))(*(void *)(a1 + 12832) + 80LL))(*(void *)(*(void *)(a1 + 12832)
                                                                                            + 8LL)))
  {
    if ((v8 & 0xF000) == 0x4000) {
      return 0LL;
    }
    *__error() = 20;
    return 0xFFFFFFFFLL;
  }

  if (*__error() != 2) {
    return 0xFFFFFFFFLL;
  }
  __strlcpy_chk();
  __int128 v3 = rindex(v9, 47);
  if (!v3 || v3 == v9) {
    return (*(uint64_t (**)(void, char *, uint64_t))(*(void *)(a1 + 12832) + 168LL))( *(void *)(*(void *)(a1 + 12832) + 8LL),  v9,  511LL);
  }
  uint64_t v4 = v3;
  char *v3 = 0;
  uint64_t result = _mkdirs(a1, v9);
  *uint64_t v4 = 47;
  if ((_DWORD)result == -1) {
    return result;
  }
  int v7 = v4[1];
  __int128 v6 = v4 + 1;
  if (!v7) {
    return 0LL;
  }
  uint64_t result = strcmp(v6, ".");
  if ((_DWORD)result)
  {
    uint64_t result = strcmp(v6, "..");
    if ((_DWORD)result) {
      return (*(uint64_t (**)(void, char *, uint64_t))(*(void *)(a1 + 12832) + 168LL))( *(void *)(*(void *)(a1 + 12832) + 8LL),  v9,  511LL);
    }
  }

  return result;
}

uint64_t _initGroupList(uint64_t a1)
{
  int v2 = getgroups(16, (gid_t *)(a1 + 10500));
  *(_DWORD *)(a1 + 10564) = v2;
  if (v2 == -1) {
    return 0xFFFFFFFFLL;
  }
  else {
    return 0LL;
  }
}

uint64_t _chPerms(uint64_t a1, char *a2, uint64_t a3, _BYTE *a4, int a5)
{
  int v8 = *(_DWORD *)(a3 + 20);
  int v9 = *(unsigned __int16 *)(a3 + 4);
  if ((v9 & 0xF000) == 0x4000) {
    unsigned int v10 = 448;
  }
  else {
    unsigned int v10 = 0;
  }
  if (*(_DWORD *)(a1 + 10496))
  {
    uint64_t v11 = *(unsigned int *)(a1 + 10564);
    if ((int)v11 >= 1)
    {
      int v12 = (int *)(a1 + 10500);
      while (1)
      {
        int v13 = *v12++;
        if (v13 == v8) {
          break;
        }
        if (!--v11) {
          goto LABEL_9;
        }
      }

      uint64_t v15 = 0xFFFFFFFFLL;
      goto LABEL_16;
    }

uint64_t _makeDestDir(uint64_t a1, char *a2, int a3, uint64_t a4, _BYTE *a5)
{
  uint64_t v12 = *MEMORY[0x1895F89C0];
  if (a3)
  {
    uint64_t result = _mkdirs(a1, (uint64_t)a2);
    if ((_DWORD)result) {
      return result;
    }
    return _chPerms(a1, a2, a4, a5, 1);
  }

  unsigned int v10 = rindex(a2, 47);
  if (!v10
    || strcmp(v10, "/.")
    || (__strlcpy_chk(),
        __s[strlen(__s) - 2] = 0,
        uint64_t result = (*(uint64_t (**)(void, char *, uint64_t))(*(void *)(a1 + 12832) + 168LL))( *(void *)(*(void *)(a1 + 12832) + 8LL),  __s,  511LL),  !(_DWORD)result))
  {
    uint64_t result = (*(uint64_t (**)(void, char *, uint64_t))(*(void *)(a1 + 12832) + 168LL))( *(void *)(*(void *)(a1 + 12832) + 8LL),  a2,  511LL);
    if (!(_DWORD)result) {
      return _chPerms(a1, a2, a4, a5, 1);
    }
  }

  return result;
}

uint64_t _filterFatArchs(uint64_t a1, unsigned int a2, _DWORD *a3, void *a4)
{
  int v8 = 0LL;
  uint64_t v9 = 0LL;
  *a4 = 0LL;
  unsigned int v10 = 0LL;
  if (a1 && a2)
  {
    unint64_t v11 = 0LL;
    uint64_t v12 = 0LL;
    int v8 = 0LL;
    uint64_t v13 = 0LL;
    do
    {
      int v14 = 0;
      unsigned int v10 = (_DWORD *)(a1 + 20 * v11);
      while (1)
      {
        int v15 = a3[8 * v14];
        if (v15 == -1) {
          break;
        }
        if (!v15)
        {
          uint64_t v9 = v13;
          unsigned int v10 = v12;
          goto LABEL_17;
        }

        if (*v10 == v15)
        {
          uint64_t v16 = &a3[8 * v14];
          if (*((_BYTE *)v16 + 4) || ((v16[2] ^ v10[1]) & 0xFFFFFF) == 0) {
            break;
          }
        }

        ++v14;
      }

      if ((_DWORD)v13)
      {
        uint64_t v9 = (v13 + 1);
        int v8 = BOM_realloc(v8, 8LL * (int)v9);
        if (!v8) {
          goto LABEL_41;
        }
      }

      else
      {
        int v8 = BOM_malloczero(8uLL);
        uint64_t v9 = 1LL;
        if (!v8) {
          goto LABEL_41;
        }
      }

      *((void *)v8 + (int)v13) = v10;
      uint64_t v12 = (_DWORD *)(a1 + 20 * v11);
      uint64_t v13 = v9;
LABEL_17:
      ++v11;
    }

    while (v11 < a2);
  }

  if (a2 && !v10 && a1)
  {
    unint64_t v17 = 0LL;
    unint64_t v18 = a2;
    do
    {
      if (*a3)
      {
        uint64_t v19 = 0LL;
        int v20 = 0;
        uint64_t v21 = a1 + 20 * v17;
        while (1)
        {
          unsigned __int16 v22 = &a3[8 * v19];
          unsigned int v23 = (int *)*((void *)v22 + 2);
          if (v23 && v22[6] && (int v24 = *v23) != 0)
          {
            unsigned int v25 = 1;
            while (*(_DWORD *)(v21 + 4) != v24)
            {
              int v24 = v23[v25++];
              if (!v24) {
                goto LABEL_30;
              }
            }

            if ((_DWORD)v9)
            {
              uint64_t v26 = (v9 + 1);
              int v8 = BOM_realloc(v8, 8LL * (int)v26);
              if (!v8) {
                goto LABEL_42;
              }
            }

            else
            {
              int v8 = BOM_malloczero(8uLL);
              uint64_t v26 = 1LL;
              if (!v8) {
                goto LABEL_42;
              }
            }

            *((void *)v8 + (int)v9) = v21;
          }

          else
          {
LABEL_30:
            uint64_t v26 = v9;
          }

          uint64_t v19 = ++v20;
          uint64_t v9 = v26;
          if (!a3[8 * v19]) {
            goto LABEL_39;
          }
        }
      }

      uint64_t v26 = v9;
LABEL_39:
      ++v17;
      uint64_t v9 = v26;
    }

    while (v17 < v18);
  }

  else
  {
LABEL_41:
    uint64_t v26 = v9;
  }

uint64_t _determine_thin_type_and_archs( uint64_t a1, unsigned int a2, _DWORD *a3, void *a4, _DWORD *a5, _DWORD *a6, int a7)
{
  uint64_t v15 = *MEMORY[0x1895F89C0];
  memset(v14, 0, sizeof(v14));
  LODWORD(v14[0]) = -1;
  BYTE4(v14[0]) = 1;
  *a4 = 0LL;
  *a5 = 0;
  if (!a1 || !a2) {
    goto LABEL_9;
  }
  if (a3) {
    goto LABEL_6;
  }
  if (!a7)
  {
LABEL_9:
    uint64_t result = 0LL;
    *a6 = 0;
    return result;
  }

  a3 = v14;
LABEL_6:
  int v11 = _filterFatArchs(a1, a2, a3, a4);
  if (!v11) {
    return 1LL;
  }
  int v12 = v11;
  if (!a7 && v11 == a2) {
    goto LABEL_9;
  }
  if (v11 == 1)
  {
    uint64_t result = 0LL;
    *a6 = 1;
  }

  else
  {
    uint64_t result = 0LL;
    *a6 = 2;
  }

  *a5 = v12;
  return result;
}

void *_sortFatArchsByOffset(void *result, int a2)
{
  if (result)
  {
    if (a2) {
      return (void *)mergesort(result, a2, 8uLL, (int (__cdecl *)(const void *, const void *))_compareFatArchsByOffset);
    }
  }

  return result;
}

uint64_t _compareFatArchsByOffset(uint64_t a1, uint64_t a2)
{
  unsigned int v2 = *(_DWORD *)(*(void *)a1 + 8LL);
  unsigned int v3 = *(_DWORD *)(*(void *)a2 + 8LL);
  BOOL v4 = v2 >= v3;
  BOOL v5 = v2 > v3;
  if (v4) {
    return v5;
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

double _createNewFatArchArray(uint64_t *a1, int a2, uint64_t a3, uint64_t a4)
{
  if (a2 >= 1)
  {
    BOOL v4 = (double *)(a3 + 12);
    uint64_t v5 = a2;
    do
    {
      uint64_t v6 = *a1++;
      *(double *)((char *)v4 - 12) = *(double *)v6;
      double result = *(double *)(v6 + 12);
      *BOOL v4 = result;
      uint64_t v8 = *(unsigned int *)(v6 + 12);
      uint64_t v9 = (a4 + (1LL << *(_DWORD *)(v6 + 16)) - 1) & (0xFFFFFFFFLL << *(_DWORD *)(v6 + 16));
      *((_DWORD *)v4 - 1) = v9;
      a4 = v9 + v8;
      BOOL v4 = (double *)((char *)v4 + 20);
      --v5;
    }

    while (v5);
  }

  return result;
}

size_t _normalizeBomCopySpecification(uint64_t a1, unsigned int a2, unsigned int a3, size_t *a4)
{
  uint64_t v6 = *(unsigned int *)(a1 + 48);
  uint64_t v7 = a3;
  uint64_t v8 = a2;
  if ((int)v6 < 1)
  {
    int v9 = 0;
  }

  else
  {
    int v9 = 0;
    unsigned int v10 = (void *)(a1 + 64);
    do
    {
      switch(*((_DWORD *)v10 - 2))
      {
        case 0:
          uint64_t v12 = *v10 % (uint64_t)a2;
          BOOL v13 = *v10 < (uint64_t)a2;
          goto LABEL_8;
        case 1:
        case 3:
        case 4:
          int v11 = 1;
          break;
        case 2:
          uint64_t v12 = *v10 % (uint64_t)a3;
          BOOL v13 = *v10 < (uint64_t)a3;
LABEL_8:
          int v11 = !v13;
          if (v13) {
            int v14 = 1;
          }
          else {
            int v14 = 2;
          }
          if (v12) {
            int v11 = v14;
          }
          break;
        default:
          int v11 = 0;
          break;
      }

      v10 += 7;
      v9 += v11;
      --v6;
    }

    while (v6);
  }

  size_t result = (size_t)BOM_calloc(56 * v9 + 56, 1uLL);
  size_t v16 = result;
  *(void *)size_t result = *(void *)a1;
  *(void *)(result + 8) = *(void *)(a1 + 8);
  *(void *)(result + 16) = *(void *)(a1 + 16);
  uint64_t v17 = *(void *)(a1 + 32);
  *(void *)(result + 24) = *(void *)(a1 + 24);
  *(void *)(result + 32) = v17;
  *(void *)(result + 40) = *(void *)(a1 + 40);
  *(_DWORD *)(result + 48) = v9;
  if (*(int *)(a1 + 48) >= 1)
  {
    uint64_t v18 = 0LL;
    int v19 = 0;
    uint64_t v20 = *(void *)(a1 + 16);
    uint64_t v21 = (void *)(a1 + 96);
    while (2)
    {
      if (*((_DWORD *)v21 - 6) <= 1u) {
        int v22 = 1;
      }
      else {
        int v22 = *((_DWORD *)v21 - 6);
      }
      int v23 = *((_DWORD *)v21 - 10);
      uint64_t v24 = 0LL;
      size_t result = 0LL;
      uint64_t v25 = *(v21 - 2);
      uint64_t v26 = *v21;
      uint64_t v27 = *(v21 - 4) * v22;
      switch(v23)
      {
        case 0:
          size_t result = v27 / v8;
          uint64_t v24 = v27 % v8;
          if (v27 != v27 % v8)
          {
            size_t v28 = v16 + 56LL * v19;
            *(_DWORD *)(v28 + 56) = 0;
            *(void *)(v28 + 64) = v8;
            *(_DWORD *)(v28 + 72) = result;
            *(void *)(v28 + 80) = v25;
            *(void *)(v28 + 88) = 0LL;
            *(void *)(v28 + 96) = v26;
            *(void *)(v28 + 104) = v20;
            ++v19;
          }

          if (v24)
          {
            size_t result = 0LL;
            uint64_t v26 = v27 + v26 - v24;
            goto LABEL_34;
          }

          goto LABEL_35;
        case 1:
          size_t result = *(v21 - 1);
          uint64_t v24 = v27;
          goto LABEL_34;
        case 2:
          size_t result = v27 / v7;
          uint64_t v24 = v27 % v7;
          uint64_t v29 = v27 - v27 % v7;
          if (v29)
          {
            size_t v30 = v16 + 56LL * v19;
            *(_DWORD *)(v30 + 56) = 2;
            *(void *)(v30 + 64) = v7;
            *(_DWORD *)(v30 + 72) = result;
            *(void *)(v30 + 80) = v25;
            *(void *)(v30 + 88) = 0LL;
            *(void *)(v30 + 96) = v26;
            *(void *)(v30 + 104) = v20;
            ++v19;
          }

          if (!v24) {
            goto LABEL_35;
          }
          size_t result = 0LL;
          v25 += v29;
          v26 += v29;
LABEL_34:
          size_t v31 = v16 + 56LL * v19;
          *(_DWORD *)(v31 + 56) = v23;
          *(void *)(v31 + 64) = v24;
          *(_DWORD *)(v31 + 72) = 1;
          *(void *)(v31 + 80) = v25;
          *(void *)(v31 + 88) = result;
          *(void *)(v31 + 96) = v26;
          *(void *)(v31 + 104) = v20;
          ++v19;
LABEL_35:
          v21 += 7;
          continue;
        case 3:
        case 4:
          goto LABEL_34;
        default:
          goto LABEL_35;
      }
    }
  }

  int v19 = 0;
LABEL_38:
  if (v19 != v9) {
    size_t result = fwrite("BOMCopier: Inconsistency while preflighting copy\n", 0x31uLL, 1uLL, (FILE *)*MEMORY[0x1895F89D0]);
  }
  *a4 = v16;
  return result;
}

uint64_t _printBomCopySpecification(const void **a1)
{
  uint64_t result = puts("-------------------");
  if (*((int *)a1 + 12) >= 1)
  {
    uint64_t v3 = 0LL;
    BOOL v4 = a1 + 11;
    do
    {
      uint64_t result = printf("Step %d:\n", v3);
      switch(*((_DWORD *)v4 - 8))
      {
        case 0:
          uint64_t v5 = "_BOMCopyStepZero";
          goto LABEL_7;
        case 1:
          printf("\ttype:\t%s\n", "_BOMCopyStepBuffer");
          printf("\tsize:\t%lld\n", *(v4 - 3));
          printf("\tbuffer:\t%p\n");
          goto LABEL_9;
        case 2:
          uint64_t v5 = "_BOMCopyStepCopy";
LABEL_7:
          printf("\ttype:\t%s\n", v5);
          printf("\tsize:\t%lld\n", *(v4 - 3));
          printf("\titerationCount:\t%d\n");
          goto LABEL_9;
        case 3:
          printf("\ttype:\t%s\n");
LABEL_9:
          printf("\tsourceOffset:\t%lld\n", *(v4 - 1));
          uint64_t result = printf("\tdestOffset:\t%lld\n");
          break;
        case 4:
          printf("\ttype:\t%s\n", "_BOMCopyStepSeekToEndOfSource");
          uint64_t result = printf("\tsourceOffset:\t%lld\n");
          break;
        default:
          break;
      }

      v4 += 7;
      ++v3;
    }

    while (v3 < *((int *)a1 + 12));
  }

  return result;
}

uint64_t _executeBomCopySpecification( int *a1, unsigned int a2, unsigned int a3, unsigned int *a4, uint64_t a5, uint64_t a6)
{
  uint64_t v8 = a4;
  if (a4) {
    uLong v11 = *a4;
  }
  else {
    uLong v11 = 0LL;
  }
  if (!a1)
  {
    uint64_t v14 = 22LL;
    goto LABEL_124;
  }

  uint64_t v84 = (UInt8 *)BOM_calloc(a2, 1uLL);
  if (!v84)
  {
    uint64_t v14 = 12LL;
    goto LABEL_124;
  }

  uint64_t v12 = *(void *)a1;
  if (*(_BYTE *)(*(void *)a1 + 3328LL)) {
    uint64_t v13 = v12 + 3328;
  }
  else {
    uint64_t v13 = *(void *)(v12 + 2296);
  }
  uint64_t v81 = *(void *)a1;
  int v82 = v8;
  statfs buf = *(char **)(v12 + 8);
  uint64_t v15 = (int *)*((void *)a1 + 1);
  uLong crc = v11;
  if (a5)
  {
    uint64_t v16 = CNCRCInit();
    if ((_DWORD)v16)
    {
      uint64_t v14 = v16;
      goto LABEL_123;
    }
  }

  if (a1[12] < 1)
  {
    uint64_t v14 = 0LL;
    goto LABEL_123;
  }

  uint64_t v77 = v13;
  uint64_t v17 = 0LL;
  uint64_t v18 = 0LL;
  uint64_t v19 = 0LL;
  int64_t v79 = a3;
  uint64_t v80 = a5;
  while (2)
  {
    uint64_t v20 = (uint64_t *)&a1[14 * v17];
    uint64_t v21 = v20[13];
    if (!v21) {
      uint64_t v21 = *((void *)a1 + 2);
    }
    switch(*((_DWORD *)v20 + 14))
    {
      case 0:
        int v22 = (uint64_t *)&a1[14 * v17];
        int v24 = *((_DWORD *)v22 + 18);
        int v23 = v22 + 9;
        if (v24 >= 1)
        {
          int v25 = 0;
          uint64_t v26 = (uint64_t *)&a1[14 * v17];
          CFIndex v29 = v26[8];
          size_t v28 = v26 + 8;
          CFIndex v27 = v29;
          do
          {
            CFIndex v30 = BOMFileWrite(v21, v84, v27);
            if (v30 != *v28) {
              goto LABEL_114;
            }
            CFIndex v27 = v30;
            if (v82)
            {
              uLong crc = crc32(crc, v84, v30);
              CFIndex v27 = *v28;
            }

            if (a5)
            {
              CNCRCUpdate();
              CFIndex v27 = *v28;
            }

            v19 += v27;
            ++v25;
          }

          while (v25 < *v23);
        }

        size_t v31 = *(void (**)(uint64_t, void, uint64_t))(v81 + 104);
        if (!v31) {
          goto LABEL_37;
        }
        v31(v81, *((void *)a1 + 3), v19);
        if (!*(_BYTE *)(v81 + 168)) {
          goto LABEL_37;
        }
        goto LABEL_127;
      case 1:
        unsigned int v32 = (uint64_t *)&a1[14 * v17];
        CFIndex v34 = v32[8];
        int v33 = v32 + 8;
        CFIndex v35 = BOMFileWrite(v21, (UInt8 *)v33[3], v34);
        if (v35 != *v33) {
          goto LABEL_114;
        }
        CFIndex v36 = v35;
        if (v82)
        {
          uLong crc = crc32(crc, (const Bytef *)v33[3], v35);
          CFIndex v36 = *v33;
        }

        if (a5)
        {
          CNCRCUpdate();
          CFIndex v36 = *v33;
        }

        v19 += v36;
        int v37 = *(void (**)(uint64_t, void, uint64_t))(v81 + 104);
        if (v37)
        {
          v37(v81, *((void *)a1 + 3), v19);
          if (*(_BYTE *)(v81 + 168)) {
            goto LABEL_127;
          }
        }

LABEL_127:
        uint64_t v14 = 2LL;
LABEL_123:
        free(v84);
        uint64_t v8 = v82;
        LODWORD(v11) = crc;
LABEL_124:
        if (v8) {
          *uint64_t v8 = v11;
        }
        return v14;
      case 4:
        uint64_t v59 = *((void *)a1 + 4);
        if (v59 == -1)
        {
          uint64_t v43 = v81;
          if (!BOMFileEndOfCompressionStream((BOOL)v15))
          {
            while (1)
            {
              unint64_t v60 = BOMFileRead(v15, buf, v79);
              if ((v60 & 0x8000000000000000LL) != 0) {
                break;
              }
              a6 += v60;
              if (BOMFileEndOfCompressionStream((BOOL)v15)) {
                goto LABEL_96;
              }
            }

LABEL_111:
            uint64_t v69 = __error();
LABEL_112:
            uint64_t v70 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v43 + 72);
            if (v70)
            {
              uint64_t v71 = *v69;
              uint64_t v72 = v43;
              uint64_t v73 = v81 + 248;
              goto LABEL_116;
            }

LABEL_118:
            unsigned int v75 = 1;
            goto LABEL_120;
          }
        }

        else if (v59 > a6)
        {
          if (BOMFileSeek() < 0)
          {
            uint64_t v69 = __error();
            uint64_t v43 = v81;
            goto LABEL_112;
          }

          a6 = *((void *)a1 + 4);
        }

LABEL_96:
        uint64_t v14 = v18;
LABEL_97:
        ++v17;
        uint64_t v18 = v14;
        a5 = v80;
        if (v17 >= a1[12]) {
          goto LABEL_123;
        }
        continue;
      default:
        goto LABEL_96;
    }
  }

uint64_t _checkCopyFileError(uint64_t a1)
{
  unsigned int v2 = *(uint64_t (**)(uint64_t))(a1 + 72);
  if (!v2)
  {
LABEL_4:
    LODWORD(result) = 1;
    goto LABEL_6;
  }

  LODWORD(result) = v2(a1);
  if ((_DWORD)result != 1)
  {
    if ((_DWORD)result) {
      goto LABEL_6;
    }
    goto LABEL_4;
  }

  LODWORD(result) = 0;
LABEL_6:
  if (*(_BYTE *)(a1 + 168)) {
    return 2LL;
  }
  else {
    return result;
  }
}

uint64_t _checkCopyFileConflictError(uint64_t a1)
{
  uint64_t v1 = *(uint64_t (**)(void))(a1 + 80);
  if (v1) {
    return v1();
  }
  else {
    return 0LL;
  }
}

uint64_t _ignore_readdir_entry(uint64_t a1)
{
  unsigned int v1 = *(unsigned __int16 *)(a1 + 18);
  if (v1 == 2)
  {
    unsigned int v2 = (const char *)(a1 + 21);
    uint64_t v3 = "..";
    size_t v4 = 2LL;
    return !strncmp(v3, v2, v4);
  }

  if (v1 == 1) {
    return *(_BYTE *)(a1 + 21) == 46;
  }
  if (v1 < 4) {
    return 0LL;
  }
  uint64_t v5 = (const char *)(a1 + 21);
  if (strncmp(".nfs", (const char *)(a1 + 21), 4uLL))
  {
    if (v1 < 0xB) {
      return 0LL;
    }
    uint64_t v3 = ".afpDeleted";
    unsigned int v2 = v5;
    size_t v4 = 11LL;
    return !strncmp(v3, v2, v4);
  }

  return 1LL;
}

BOOL _sanitizePath(char *cStr, uint64_t a2)
{
  uint64_t v3 = 0LL;
  int v4 = 0;
  int v5 = 0;
  int v6 = 0;
  do
  {
    int v7 = cStr[v3];
    switch(v6)
    {
      case 0:
        if (v7 == 47) {
          int v6 = 0;
        }
        else {
          int v6 = 3;
        }
        if (v7 == 46) {
          int v6 = 1;
        }
        break;
      case 1:
        if (v7 == 47) {
          int v6 = 0;
        }
        else {
          int v6 = 3;
        }
        if (v7 == 46) {
          int v6 = 2;
        }
        break;
      case 2:
        if (v7 == 47) {
          int v6 = 0;
        }
        else {
          int v6 = 3;
        }
        if (v7 == 47) {
          int v8 = 1;
        }
        else {
          int v8 = v5;
        }
        if (cStr[v3])
        {
          int v5 = v8;
        }

        else
        {
          int v6 = 0;
          int v5 = 1;
        }

        break;
      case 3:
        if (v7 == 47) {
          int v6 = 0;
        }
        else {
          int v6 = 3;
        }
        break;
      default:
        break;
    }

    v4 |= cStr[v3++] < 0;
  }

  while (a2 + 1 != v3);
  if (((v4 | v5) & 1) == 0) {
    return 0LL;
  }
  CFStringEncoding v9 = 134217984;
  unsigned int v10 = (const __CFAllocator *)*MEMORY[0x189604DB0];
  CFStringRef v11 = CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x189604DB0], cStr, 0x8000100u);
  if (v11)
  {
    uint64_t v12 = v11;
    if ((v5 & 1) == 0) {
      goto LABEL_51;
    }
    goto LABEL_35;
  }

  CFStringEncoding SystemEncoding = CFStringGetSystemEncoding();
  uint64_t v12 = CFStringCreateWithCString(v10, cStr, SystemEncoding);
  if (v12)
  {
    if ((v5 & 1) == 0)
    {
LABEL_51:
      int CString = CFStringGetCString(v12, cStr, 1024LL, v9);
      CFRelease(v12);
      return CString == 0;
    }

char *_parse_arch_list(uint64_t a1, CFArrayRef theArray, const __CFDictionary *a3, _DWORD *a4, void **a5)
{
  uint64_t v65 = *MEMORY[0x1895F89C0];
  CFIndex Count = CFArrayGetCount(theArray);
  int v11 = Count;
  if (!(_DWORD)Count)
  {
    unint64_t v52 = *(void (**)(uint64_t, char *))(a1 + 56);
    if (v52)
    {
      strcpy(__str, "archs array is empty");
      v52(a1, __str);
    }

    return 0LL;
  }

  *a4 = Count;
  uint64_t v12 = (Count << 32) + 0x100000000LL;
  uint64_t v13 = (char *)BOM_malloczero(v12 >> 27);
  if (!v13) {
    return v13;
  }
  uint64_t v14 = BOM_malloczero(v12 >> 29);
  *a5 = v14;
  if (!v14)
  {
    free(v13);
    return 0LL;
  }

  if (v11 < 1) {
    return v13;
  }
  uint64_t v58 = a1;
  uint64_t v62 = v13;
  char v63 = a5;
  CFIndex v15 = 0LL;
  uint64_t v61 = v11;
  while (1)
  {
    ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(theArray, v15);
    if (!ValueAtIndex || (uint64_t v17 = ValueAtIndex, TypeID = CFStringGetTypeID(), TypeID != CFGetTypeID(v17)))
    {
      uint64_t v54 = v58;
      if (*(void *)(v58 + 56))
      {
        snprintf(__str, 0x800uLL, "can't read arch #%d from archs list");
LABEL_65:
        (*(void (**)(uint64_t, char *))(v54 + 56))(v54, __str);
      }

LABEL_66:
      free(*v63);
      free(v13);
      uint64_t v13 = 0LL;
      *a4 = 0;
      return v13;
    }

    UTF8String = (char *)BOMCFStringGetUTF8String(v17);
    if (!UTF8String)
    {
      uint64_t v54 = v58;
      if (*(void *)(v58 + 56))
      {
        snprintf(__str, 0x800uLL, "can't convert arch #%d from archs listinto UTF8 encoded C string");
        goto LABEL_65;
      }

      goto LABEL_66;
    }

    CFIndex v20 = UTF8String;
    uint64_t v21 = BOMGetArchInfoFromName(UTF8String);
    if (!v21 || (v22 = *((_DWORD *)v21 + 3), (int v23 = BOMGetArchInfoFromCpuType(*((_DWORD *)v21 + 2), -1)) == 0LL))
    {
      if (*(void *)(v58 + 56))
      {
        snprintf(__str, 0x800uLL, "can't get arch info for '%s'", v20);
        (*(void (**)(uint64_t, char *))(v58 + 56))(v58, __str);
      }

      free(v20);
      goto LABEL_66;
    }

    int v25 = *((_DWORD *)v23 + 2);
    int v24 = *((_DWORD *)v23 + 3);
    BOOL v26 = v25 == 16777228 && v22 == 0;
    if (v26) {
      int v27 = 16777228;
    }
    else {
      int v27 = *((_DWORD *)v23 + 2);
    }
    char v28 = !v26;
    if (v26) {
      int v29 = v22;
    }
    else {
      int v29 = -1;
    }
    if (v25 == 16777223 && v22 == 3)
    {
      int v27 = 16777223;
      char v28 = 0;
      int v29 = v22;
    }

    BOOL v31 = v22 == v24;
    int v32 = v22 == v24 ? v27 : *((_DWORD *)v23 + 2);
    char v33 = v31 ? v28 : 0;
    int v34 = v31 ? v29 : v22;
    CFIndex v35 = &v13[32 * v15];
    *(_DWORD *)CFIndex v35 = v32;
    v35[4] = v33;
    *((void *)v35 + 2) = 0LL;
    CFIndex v36 = v35 + 16;
    *((_DWORD *)v35 + 2) = v34;
    *((_DWORD *)v35 + 6) = 0;
    int v37 = (unsigned int *)(v35 + 24);
    *((void *)*v63 + v15) = v20;
    __int16 v38 = a3;
    if (a3)
    {
      unint64_t Value = (const __CFArray *)CFDictionaryGetValue(a3, v17);
      if (Value)
      {
        uint64_t v40 = Value;
        CFTypeID v41 = CFArrayGetTypeID();
        if (v41 == CFGetTypeID(v40))
        {
          CFIndex v42 = CFArrayGetCount(v40);
          unsigned int v43 = v42;
          if ((_DWORD)v42) {
            break;
          }
        }
      }
    }

_DWORD *_BOMFreeListAllocate(const __CFDictionary *a1)
{
  uint64_t v18 = *MEMORY[0x1895F89C0];
  if (a1 && (unint64_t Value = (const __CFString *)CFDictionaryGetValue(a1, @"Implementation")) != 0LL)
  {
    unsigned int v2 = Value;
    CFTypeID v3 = CFGetTypeID(Value);
    if (v3 == CFStringGetTypeID()) {
      int v4 = v2;
    }
    else {
      int v4 = 0LL;
    }
  }

  else
  {
    int v4 = 0LL;
  }

  if (v4) {
    int v5 = v4;
  }
  else {
    int v5 = @"dense";
  }
  if (CFEqual(v5, @"dense")) {
    return _BOMFreeListAllocateDense();
  }
  if (!CFEqual(v5, @"dense+trace")) {
    _BOMFreeListAllocate_cold_1();
  }
  int v7 = BOM_malloc(0x48uLL);
  if (!v7) {
    _BOMFreeListAllocate_cold_2(0LL);
  }
  int v8 = v7;
  v7[2] = _densetrace_initialize;
  v7[3] = _densetrace_serialize;
  v7[4] = _densetrace_deallocate;
  v7[5] = _densetrace_addFreeRange;
  v7[6] = _densetrace_allocateRange;
  v7[7] = _densetrace_clear;
  v7[8] = _densetrace_print;
  CFStringEncoding v9 = getenv("TMPDIR");
  if (v9) {
    unsigned int v10 = v9;
  }
  else {
    unsigned int v10 = "/tmp";
  }
  pid_t v11 = getpid();
  int v12 = _BOMFreeListAllocateDenseTrace_objnumber++;
  snprintf(__str, 0x400uLL, "%s/bomfreelist.trace.%d.%d.txt", v10, v11, v12);
  uint64_t v13 = fopen(__str, "w");
  if (!v13) {
    _BOMFreeListAllocate_cold_3(0LL);
  }
  uint64_t v14 = v13;
  CFIndex v15 = BOM_malloc(0x18uLL);
  if (!v15) {
    _BOMFreeListAllocate_cold_4(0LL);
  }
  uint64_t v16 = v15;
  *CFIndex v15 = _BOMFreeListAllocateDense();
  *((_DWORD *)v16 + 2) = 1;
  v16[2] = v14;
  *int v8 = v16;
  *((_DWORD *)v8 + 2) = 0;
  return v8;
}

_DWORD *_BOMFreeListAllocateDense()
{
  uint64_t v0 = BOM_malloc(0x48uLL);
  unsigned int v1 = v0;
  if (v0)
  {
    v0[2] = _dense_initialize;
    v0[3] = _dense_serialize;
    v0[4] = _dense_deallocate;
    v0[5] = _dense_addFreeRange;
    v0[6] = _dense_allocateRange;
    v0[7] = _dense_clear;
    v0[8] = _dense_print;
    unsigned int v2 = BOM_malloc(0x18uLL);
    if (v2)
    {
      CFTypeID v3 = v2;
      int v4 = BOM_calloc(0x20uLL, 8uLL);
      void *v3 = v4;
      if (v4)
      {
        v3[1] = 0LL;
        *((_DWORD *)v3 + 4) = 32;
        *(void *)unsigned int v1 = v3;
        v1[2] = 0;
        return v1;
      }

      free(v1);
      int v5 = v3;
    }

    else
    {
      int v5 = v1;
    }

    free(v5);
    return 0LL;
  }

  return v1;
}

uint64_t _dense_initialize(uint64_t result, uint64_t a2, unint64_t a3, int a4)
{
  if ((a3 & 7) == 0 && (int)(a3 >> 3) >= 1)
  {
    uint64_t v5 = result;
    uint64_t v6 = (a3 >> 3);
    int v7 = (unsigned int *)(a2 + 4);
    do
    {
      unsigned int v8 = *(v7 - 1);
      unsigned int v9 = bswap32(v8);
      unsigned int v10 = bswap32(*v7);
      if (a4) {
        uint64_t v11 = v9;
      }
      else {
        uint64_t v11 = v8;
      }
      if (a4) {
        uint64_t v12 = v10;
      }
      else {
        uint64_t v12 = *v7;
      }
      uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v5 + 40))(v5, v11, v12);
      v7 += 2;
      --v6;
    }

    while (v6);
  }

  return result;
}

_DWORD *_dense_serialize(uint64_t **a1, int a2, size_t *a3)
{
  int v4 = *a1;
  size_t v5 = 8LL * *((int *)a1 + 2);
  *a3 = v5;
  uint64_t result = BOM_malloc(v5);
  if (result)
  {
    int v7 = *((_DWORD *)v4 + 4);
    if (v7 < 1)
    {
      int v9 = 0;
    }

    else
    {
      uint64_t v8 = 0LL;
      int v9 = 0;
      uint64_t v10 = *v4;
      do
      {
        uint64_t v11 = *(uint64_t **)(v10 + 8 * v8);
        if (v11)
        {
          int v12 = 2 * v9;
          do
          {
            unsigned int v13 = *((_DWORD *)v11 + 2);
            unsigned int v14 = *((_DWORD *)v11 + 3);
            unsigned int v15 = bswap32(v13);
            unsigned int v16 = bswap32(v14);
            if (a2)
            {
              unsigned int v13 = v15;
              unsigned int v14 = v16;
            }

            result[v12] = v13;
            result[v12 + 1] = v14;
            uint64_t v11 = (uint64_t *)*v11;
            v12 += 2;
            ++v9;
          }

          while (v11);
          int v7 = *((_DWORD *)v4 + 4);
        }

        ++v8;
      }

      while (v8 < v7);
    }

    uint64_t v17 = (uint64_t *)v4[1];
    if (v17)
    {
      int v18 = 2 * v9;
      do
      {
        unsigned int v19 = *((_DWORD *)v17 + 2);
        unsigned int v20 = *((_DWORD *)v17 + 3);
        unsigned int v21 = bswap32(v19);
        unsigned int v22 = bswap32(v20);
        if (a2) {
          unsigned int v19 = v21;
        }
        result[v18] = v19;
        if (a2) {
          unsigned int v23 = v22;
        }
        else {
          unsigned int v23 = v20;
        }
        result[v18 + 1] = v23;
        uint64_t v17 = (uint64_t *)*v17;
        v18 += 2;
      }

      while (v17);
    }
  }

  return result;
}

void _dense_deallocate(uint64_t a1)
{
  unsigned int v2 = *(void ***)a1;
  (*(void (**)(void))(a1 + 56))();
  free(*v2);
  free(v2);
  *(void *)a1 = 0LL;
}

void *_dense_clear(uint64_t *a1)
{
  uint64_t v1 = *a1;
  int v2 = *(_DWORD *)(*a1 + 16);
  if (v2 >= 1)
  {
    for (uint64_t i = 0LL; i < v2; ++i)
    {
      int v4 = *(void **)(*(void *)v1 + 8 * i);
      *(void *)(*(void *)v1 + 8 * i) = 0LL;
      if (v4)
      {
        do
        {
          size_t v5 = (void *)*v4;
          free(v4);
          int v4 = v5;
        }

        while (v5);
        int v2 = *(_DWORD *)(v1 + 16);
      }
    }
  }

  uint64_t result = *(void **)(v1 + 8);
  *(void *)(v1 + 8) = 0LL;
  if (result)
  {
    do
    {
      int v7 = (void *)*result;
      free(result);
      uint64_t result = v7;
    }

    while (v7);
  }

  return result;
}

_DWORD *_dense_addFreeRange(_DWORD *result, int a2, unint64_t a3)
{
  if (a3)
  {
    size_t v5 = result;
    uint64_t v6 = *(void *)result;
    if (a3 < 0x10000)
    {
      unint64_t v8 = *(int *)(v6 + 16);
      if (v8 <= a3)
      {
        int v9 = a3 + 1;
        uint64_t v10 = (char *)BOM_realloc(*(void **)v6, (8 * (a3 + 1)));
        *(void *)uint64_t v6 = v10;
        *(_DWORD *)(v6 + 16) = v9;
        uint64_t v6 = *(void *)v5;
      }

      uint64_t v11 = *(void *)(*(void *)v6 + 8 * a3);
      uint64_t result = BOM_malloc(0x10uLL);
      result[2] = a2;
      result[3] = a3;
      *(void *)uint64_t result = v11;
      *(void *)(*(void *)v6 + 8 * a3) = result;
    }

    else
    {
      uint64_t v7 = *(void *)(v6 + 8);
      uint64_t result = BOM_malloc(0x10uLL);
      result[2] = a2;
      result[3] = a3;
      *(void *)uint64_t result = v7;
      *(void *)(v6 + 8) = result;
    }

    ++v5[2];
  }

  return result;
}

uint64_t _dense_allocateRange(uint64_t a1, unint64_t a2)
{
  int v4 = *(void **)a1;
  unint64_t v5 = *(int *)(*(void *)a1 + 16LL);
  if (v5 > a2)
  {
    uint64_t v6 = *(unsigned int **)(*v4 + 8 * a2);
    if (v6)
    {
      uint64_t v7 = v6[2];
      uint64_t v8 = *(void *)v6;
      free(v6);
      *(void *)(*v4 + 8 * a2) = v8;
      --*(_DWORD *)(a1 + 8);
      return v7;
    }
  }

  LODWORD(v9) = 0;
  while (1)
  {
    uint64_t v10 = (a2 + 1 + v9);
    uint64_t v11 = *(unsigned int **)(*v4 + 8LL * v10);
    uint64_t v9 = (v9 + 1);
    if (v11)
    {
      uint64_t v7 = v11[2];
      uint64_t v12 = *(void *)v11;
      free(v11);
      *(void *)(*v4 + 8 * v10) = v12;
      --*(_DWORD *)(a1 + 8);
      (*(void (**)(uint64_t, void, uint64_t))(a1 + 40))(a1, (v7 + a2), v9);
      return v7;
    }
  }

  unsigned int v15 = (void **)v4[1];
  unsigned int v14 = v4 + 1;
  unsigned int v13 = v15;
  if (!v15) {
    return 0LL;
  }
  unint64_t v16 = *((unsigned int *)v13 + 3);
  if (v16 < a2)
  {
    while (1)
    {
      uint64_t v17 = v13;
      unsigned int v13 = (void **)*v13;
      if (!v13) {
        return 0LL;
      }
      unint64_t v16 = *((unsigned int *)v13 + 3);
      if (v16 >= a2) {
        goto LABEL_15;
      }
    }
  }

  uint64_t v17 = 0LL;
LABEL_15:
  int v18 = (void **)*v13;
  uint64_t v7 = *((unsigned int *)v13 + 2);
  uint64_t v19 = (v7 + a2);
  uint64_t v20 = (v16 - a2);
  free(v13);
  if (v17) {
    unsigned int v21 = v17;
  }
  else {
    unsigned int v21 = v14;
  }
  *unsigned int v21 = v18;
  --*(_DWORD *)(a1 + 8);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(a1 + 40))(a1, v19, v20);
  return v7;
}

uint64_t _dense_print(uint64_t result, FILE *__stream, int a3)
{
  uint64_t v5 = *(void *)result;
  int v6 = *(_DWORD *)(*(void *)result + 16LL);
  if (v6 >= 1)
  {
    for (uint64_t i = 0LL; i < v6; ++i)
    {
      uint64_t v8 = *(void **)(*(void *)v5 + 8 * i);
      if (v8)
      {
        int v9 = 0;
        do
        {
          ++v9;
          uint64_t v8 = (void *)*v8;
        }

        while (v8);
        if (v9 == 1) {
          uint64_t v10 = "y";
        }
        else {
          uint64_t v10 = "ies";
        }
        uint64_t result = fprintf(__stream, "Size %d: %d entr%s\n", i, v9, v10);
        int v6 = *(_DWORD *)(v5 + 16);
      }
    }
  }

  uint64_t v11 = *(uint64_t **)(v5 + 8);
  if (v11)
  {
    if (a3) {
      fwrite("Large sizes:\n\t", 0xEuLL, 1uLL, __stream);
    }
    int v12 = 1;
    if (!a3) {
      goto LABEL_17;
    }
    while (1)
    {
      fprintf(__stream, "%d ", *((_DWORD *)v11 + 3));
      uint64_t v11 = (uint64_t *)*v11;
      if (!v11) {
        break;
      }
      while (1)
      {
        ++v12;
        if (a3) {
          break;
        }
LABEL_17:
        uint64_t v11 = (uint64_t *)*v11;
        if (!v11)
        {
          unsigned int v13 = "ies";
          if (v12 == 1) {
            unsigned int v13 = "y";
          }
          return fprintf(__stream, "Large sizes: %d entr%s\n", v12, v13);
        }
      }
    }

    return fputc(10, __stream);
  }

  return result;
}

uint64_t _densetrace_initialize(_DWORD *a1)
{
  uint64_t v2 = *(void *)a1;
  uint64_t result = (*(uint64_t (**)(void))(**(void **)a1 + 16LL))();
  a1[2] = *(_DWORD *)(*(void *)v2 + 8LL);
  return result;
}

uint64_t _densetrace_serialize(_DWORD *a1)
{
  uint64_t v2 = *(void *)a1;
  uint64_t result = (*(uint64_t (**)(void))(**(void **)a1 + 24LL))();
  a1[2] = *(_DWORD *)(*(void *)v2 + 8LL);
  return result;
}

void _densetrace_deallocate(uint64_t *a1)
{
  uint64_t v2 = *a1;
  (*(void (**)(void))(*(void *)*a1 + 32LL))();
  free(*(void **)v2);
  fclose(*(FILE **)(v2 + 16));
  free((void *)v2);
  *a1 = 0LL;
}

uint64_t _densetrace_clear(_DWORD *a1)
{
  uint64_t v2 = *(void *)a1;
  uint64_t result = (*(uint64_t (**)(void))(**(void **)a1 + 56LL))();
  a1[2] = *(_DWORD *)(*(void *)v2 + 8LL);
  return result;
}

uint64_t _densetrace_addFreeRange(_DWORD *a1, uint64_t a2, uint64_t a3)
{
  int v4 = *(FILE ***)a1;
  if (*(_DWORD *)(*(void *)a1 + 8LL)) {
    fprintf(v4[2], "Add\t\t%#zx\n", a3);
  }
  uint64_t result = (*(uint64_t (**)(void))&(*v4)->_lbfsize)();
  a1[2] = (*v4)->_r;
  return result;
}

uint64_t _densetrace_allocateRange(_DWORD *a1, uint64_t a2)
{
  CFTypeID v3 = *(FILE ***)a1;
  if (*(_DWORD *)(*(void *)a1 + 8LL)) {
    fprintf(v3[2], "Remove\t\t%#zx\n", a2);
  }
  uint64_t result = ((uint64_t (*)(void))(*v3)->_cookie)();
  a1[2] = (*v3)->_r;
  return result;
}

uint64_t _densetrace_print(_DWORD *a1)
{
  uint64_t v2 = *(void *)a1;
  uint64_t result = (*(uint64_t (**)(void))(**(void **)a1 + 64LL))();
  a1[2] = *(_DWORD *)(*(void *)v2 + 8LL);
  return result;
}

void OUTLINED_FUNCTION_0(uint64_t a1, const char *a2)
{
}

void **BOMFilesystemInfoCreate(int a1)
{
  uint64_t v16 = *MEMORY[0x1895F89C0];
  size_t v13 = 100LL;
  *(void *)unsigned int v14 = 0x200000001LL;
  if (sysctl(v14, 2u, __str, &v13, 0LL, 0LL))
  {
    fwrite("Could not determine kernel version\n", 0x23uLL, 1uLL, (FILE *)*MEMORY[0x1895F89D0]);
LABEL_3:
    int v2 = -1;
    goto LABEL_10;
  }

  int v3 = strtol(__str, &__endptr, 0);
  int v4 = *__endptr;
  if (v4 != 46 && v4 != 0) {
    goto LABEL_3;
  }
  int v2 = v3;
LABEL_10:
  int v6 = (char *)BOM_calloc(0x328uLL, 1uLL);
  uint64_t v7 = (void **)v6;
  if (v6)
  {
    if (v2 == -1) {
      int v8 = 7;
    }
    else {
      int v8 = v2;
    }
    *((_DWORD *)v6 + 2) = v8;
    *((_DWORD *)v6 + 3) = a1;
    if (pthread_mutex_init((pthread_mutex_t *)(v6 + 16), 0LL))
    {
      free(v7);
      return 0LL;
    }

    else
    {
      for (uint64_t i = 0LL; i != 91; i += 13LL)
      {
        uint64_t v10 = &v7[i];
        v7[i + 12] = 0LL;
        __strlcpy_chk();
        *(_OWORD *)(v10 + 13) = 0u;
        *(_OWORD *)(v10 + 15) = 0u;
        *(_OWORD *)(v10 + 17) = 0u;
        *(_OWORD *)(v10 + 19) = 0u;
        *(_OWORD *)(v10 + 21) = 0u;
      }

      *uint64_t v7 = BomSys_default();
    }
  }

  return v7;
}

void BOMFilesystemInfoDestroy(uint64_t a1)
{
}

uint64_t BOMFilesystemInfoQuery(uint64_t a1, _BYTE *a2, _DWORD *a3, int a4, int a5)
{
  uint64_t v23 = *MEMORY[0x1895F89C0];
  if (a3 == (_DWORD *)&DEVICE_ARCHIVE)
  {
    uint64_t v10 = (__int128 *)&archive;
  }

  else if (a3 {
         && (int v8 = *a3 % 7, *(_DWORD *)(a1 + 104LL * v8 + 96))
  }
         && (uint64_t v9 = a1 + 104LL * v8, *(_DWORD *)(v9 + 100) == *a3))
  {
    uint64_t v10 = (__int128 *)(v9 + 104);
  }

  else
  {
    int v19 = 0;
    if (v21 == 7562856)
    {
      uint64_t v10 = &hfs7;
    }

    else if (v21 == 1718642273 && v22 == 115)
    {
      uint64_t v10 = &afp;
    }

    else if ((v20[65] & 0x10) != 0)
    {
      uint64_t v10 = (__int128 *)&flatlocal;
    }

    else
    {
      uint64_t v10 = (__int128 *)&flatnetwork;
    }

    int v12 = v19;
    uint64_t v13 = a1 + 104LL * (v19 % 7);
    *(_DWORD *)(v13 + 96) = 1;
    *(_DWORD *)(v13 + 100) = v12;
    __strlcpy_chk();
    *(_OWORD *)(v13 + 120) = v10[1];
    *(_OWORD *)(v13 + 136) = v10[2];
    *(_OWORD *)(v13 + 152) = v10[3];
    *(_OWORD *)(v13 + 168) = v10[4];
    *(_OWORD *)(v13 + 104) = *v10;
  }

  uint64_t result = 0xFFFFFFFFLL;
  if (a4 <= 1819173228)
  {
    if (a4 == 1633905696)
    {
      unsigned int v15 = (unsigned int *)v10 + 13;
      uint64_t v16 = (unsigned int *)v10 + 14;
      uint64_t v17 = (unsigned int *)v10 + 15;
      v10 += 3;
    }

    else
    {
      if (a4 != 1718511215) {
        return result;
      }
      unsigned int v15 = (unsigned int *)v10 + 5;
      uint64_t v16 = (unsigned int *)v10 + 6;
      uint64_t v17 = (unsigned int *)v10++ + 7;
    }
  }

  else
  {
    switch(a4)
    {
      case 1819173229:
        unsigned int v15 = (unsigned int *)v10 + 17;
        uint64_t v16 = (unsigned int *)v10 + 18;
        uint64_t v17 = (unsigned int *)v10 + 19;
        v10 += 4;
        break;
      case 2020897906:
        unsigned int v15 = (unsigned int *)v10 + 9;
        uint64_t v16 = (unsigned int *)v10 + 10;
        uint64_t v17 = (unsigned int *)v10 + 11;
        v10 += 2;
        break;
      case 1920168547:
        unsigned int v15 = (unsigned int *)v10 + 1;
        uint64_t v16 = (unsigned int *)v10 + 2;
        uint64_t v17 = (unsigned int *)v10 + 3;
        break;
      default:
        return result;
    }
  }

  if (*(_DWORD *)v10 <= 1u) {
    unsigned int v18 = 1;
  }
  else {
    unsigned int v18 = *(_DWORD *)v10;
  }
  if (a4 != 1819173229 && *(_DWORD *)(a1 + 12) != 0) {
    uint64_t result = v18;
  }
  else {
    uint64_t result = *(unsigned int *)v10;
  }
  if (a5 > 1919905651)
  {
    if (a5 == 1919905652) {
      return *v17;
    }
    if (a5 != 1936749172) {
      return 0xFFFFFFFFLL;
    }
  }

  else
  {
    if (a5 != 1634756896)
    {
      if (a5 == 1853126245) {
        return *v15;
      }
      return 0xFFFFFFFFLL;
    }

    if (a4 != 1819173229 && *(_DWORD *)(a1 + 12) != 0) {
      return 1633968748LL;
    }
    else {
      return *v16;
    }
  }

  return result;
}

uint64_t _recursive_statfs(_BYTE *a1, void *a2, _DWORD *a3, uint64_t a4)
{
  uint64_t v17 = *MEMORY[0x1895F89C0];
  bzero(v15, 0x3FEuLL);
  *(_WORD *)__s = 12078;
  if (*a1 == 47) {
    __strlcpy_chk();
  }
  else {
    __strlcat_chk();
  }
  uint64_t v8 = (*(uint64_t (**)(void, char *, _BYTE *))(a4 + 104))(*(void *)(a4 + 8), __s, __src);
  if ((_DWORD)v8)
  {
    uint64_t v9 = v8;
    if (*__error() != 2) {
      return v9;
    }
    uint64_t v10 = strrchr(__s, 47);
    if (!v10) {
      return v9;
    }
    while (1)
    {
      if (v10 == __s) {
        __strlcpy_chk();
      }
      else {
        *uint64_t v10 = 0;
      }
      uint64_t v11 = (*(uint64_t (**)(void, char *, _BYTE *))(a4 + 104))(*(void *)(a4 + 8), __s, __src);
      if (!(_DWORD)v11) {
        break;
      }
      uint64_t v9 = v11;
      uint64_t v10 = strrchr(__s, 47);
      if (!v10) {
        return v9;
      }
    }
  }

  memcpy(a2, __src, 0x878uLL);
  uint64_t v9 = (*(uint64_t (**)(void, char *, _DWORD *))(a4 + 80))(*(void *)(a4 + 8), __s, v13);
  if (!(_DWORD)v9) {
    *a3 = v13[0];
  }
  return v9;
}

uint64_t BOMArchFlagForHeader(int *a1, unint64_t a2)
{
  uint64_t result = 0LL;
  if (a1 && a2 >= 8)
  {
    int v4 = *a1;
    BOOL v5 = *a1 == -889275714 || v4 == -1095041334;
    if (!v5 || ((v6 = bswap32(a1[1]), v8 = v6 > 0x2A, unint64_t v7 = 20LL * v6 + 8, !v8) ? (v8 = v7 > a2) : (v8 = 1), v8))
    {
      if (a2 >= 0x1C)
      {
        uint64_t result = 1LL;
        if (v4 != -822415874 && v4 != -17958194)
        {
          BOOL v10 = v4 == -17958193 || v4 == -805638658;
          return a2 >= 0x20 && v10;
        }
      }

      else
      {
        return 0LL;
      }
    }

    else
    {
      return 2LL;
    }
  }

  return result;
}

uint64_t BOMArchFlagForFile(uint64_t a1)
{
  return BOMArchFlagForFileWithSys(a1, 0LL);
}

uint64_t BOMArchFlagForFileWithSys(uint64_t a1, void *a2)
{
  int v2 = a2;
  uint64_t v9 = *MEMORY[0x1895F89C0];
  if (!a2) {
    int v2 = BomSys_default();
  }
  uint64_t v4 = (*((uint64_t (**)(void, uint64_t, void, void))v2 + 2))(*((void *)v2 + 1), a1, 0LL, 0LL);
  if ((_DWORD)v4 == -1) {
    return 0LL;
  }
  uint64_t v5 = v4;
  unint64_t v6 = (*((uint64_t (**)(void, uint64_t, int *, uint64_t))v2 + 6))(*((void *)v2 + 1), v4, v8, 32LL);
  (*((void (**)(void, uint64_t))v2 + 4))(*((void *)v2 + 1), v5);
  if (v6 == -1LL) {
    return 0LL;
  }
  else {
    return BOMArchFlagForHeader(v8, v6);
  }
}

uint64_t _fat_header_big_to_host(unsigned int *a1, unint64_t a2)
{
  if (a2 < 8) {
    return 0LL;
  }
  unsigned int v2 = a1[1];
  uint64_t v3 = bswap32(v2);
  *a1 = bswap32(*a1);
  a1[1] = v3;
  if (v2)
  {
    uint64_t v5 = a1 + 6;
    do
    {
      *((int8x16_t *)v5 - 1) = vrev32q_s8(*((int8x16_t *)v5 - 1));
      unsigned int *v5 = bswap32(*v5);
      v5 += 5;
      --v3;
    }

    while (v3);
  }

  return 1LL;
}

uint64_t _fat_header_host_to_big(unsigned int *a1, unint64_t a2)
{
  if (a2 < 8) {
    return 0LL;
  }
  uint64_t v2 = a1[1];
  *a1 = bswap32(*a1);
  a1[1] = bswap32(v2);
  if ((_DWORD)v2)
  {
    uint64_t v4 = a1 + 6;
    do
    {
      *((int8x16_t *)v4 - 1) = vrev32q_s8(*((int8x16_t *)v4 - 1));
      *uint64_t v4 = bswap32(*v4);
      v4 += 5;
      --v2;
    }

    while (v2);
  }

  return 1LL;
}

uint64_t BOMHostByteOrder()
{
  return 1LL;
}

char **BOMGetArchInfoFromName(char *__s2)
{
  if (!__s2) {
    return 0LL;
  }
  uint64_t v2 = &BOMArchInfoTable;
  uint64_t v3 = "hppa";
  while (strcmp(v3, __s2))
  {
    uint64_t v4 = v2[4];
    v2 += 4;
    uint64_t v3 = v4;
    if (!v4) {
      return 0LL;
    }
  }

  return v2;
}

char **BOMGetArchInfoFromCpuType(int a1, int a2)
{
  uint64_t v3 = &BOMArchInfoTable;
  while (*((_DWORD *)v3 + 2) != a1 || a2 != -1 && ((*((_DWORD *)v3 + 3) ^ a2) & 0xFFFFFF) != 0)
  {
    uint64_t v4 = v3[4];
    v3 += 4;
    if (!v4)
    {
      if (a1 == 18)
      {
        unint64_t v6 = (char **)malloc(0x20uLL);
        uint64_t v3 = v6;
        if (!v6) {
          return v3;
        }
        *(_OWORD *)unint64_t v6 = xmmword_189E3F9D0;
        *((_OWORD *)v6 + 1) = unk_189E3F9E0;
        *((_DWORD *)v6 + 3) = a2;
        BOOL v8 = 0LL;
        asprintf(&v8, "PowerPC cpusubtype %u");
LABEL_12:
        if (v8)
        {
          v3[3] = v8;
          return v3;
        }

        free(v3);
      }

      else if (a1 == 7)
      {
        uint64_t v5 = (char **)malloc(0x20uLL);
        uint64_t v3 = v5;
        if (!v5) {
          return v3;
        }
        *(_OWORD *)uint64_t v5 = xmmword_189E3F910;
        *((_OWORD *)v5 + 1) = unk_189E3F920;
        *((_DWORD *)v5 + 3) = a2;
        BOOL v8 = 0LL;
        asprintf(&v8, "Intel family %u model %u");
        goto LABEL_12;
      }

      return 0LL;
    }
  }

  return v3;
}

int8x8_t BOMSwapFatHeader(int8x8_t *a1, int a2)
{
  if (a1)
  {
    if (a2)
    {
      int8x8_t result = vrev32_s8(*a1);
      *a1 = result;
    }
  }

  return result;
}

uint64_t BOMSwapFatArch(uint64_t a1, unsigned int a2, int a3)
{
  uint64_t result = 0xFFFFFFFFLL;
  if (a1 && a2 && a3)
  {
    uint64_t v5 = a2;
    unint64_t v6 = (unsigned int *)(a1 + 16);
    do
    {
      *((int8x16_t *)v6 - 1) = vrev32q_s8(*((int8x16_t *)v6 - 1));
      unsigned int *v6 = bswap32(*v6);
      v6 += 5;
      --v5;
    }

    while (v5);
    return 0LL;
  }

  return result;
}

uint64_t BOMSwapFatArch64(uint64_t a1, unsigned int a2, int a3)
{
  uint64_t v3 = 0xFFFFFFFFLL;
  if (a1 && a2 && a3)
  {
    uint64_t v3 = a2;
    do
    {
      *(int8x8_t *)a1 = vrev32_s8(*(int8x8_t *)a1);
      *(int8x16_t *)(a1 + 8) = vrev64q_s8(*(int8x16_t *)(a1 + 8));
      *(int8x8_t *)(a1 + 24) = vrev32_s8(*(int8x8_t *)(a1 + 24));
      a1 += 32LL;
      --v3;
    }

    while (v3);
  }

  return v3;
}

int8x8_t BOMSwapMachHeader(uint64_t a1, int a2)
{
  if (a1)
  {
    if (a2)
    {
      *(int8x16_t *)a1 = vrev32q_s8(*(int8x16_t *)a1);
      int8x8_t result = vrev32_s8(*(int8x8_t *)(a1 + 16));
      *(int8x8_t *)(a1 + 16) = result;
      *(_DWORD *)(a1 + 24) = bswap32(*(_DWORD *)(a1 + 24));
    }
  }

  return result;
}

int8x16_t BOMSwapMachHeader64(int8x16_t *a1, int a2)
{
  if (a1)
  {
    if (a2)
    {
      int8x16_t result = vrev32q_s8(*a1);
      int8x16_t v3 = vrev32q_s8(a1[1]);
      *a1 = result;
      a1[1] = v3;
    }
  }

  return result;
}

void *BOMBufferAllocate(size_t a1)
{
  uint64_t v2 = BOM_malloczero(0x48uLL);
  int8x16_t v3 = valloc(a1);
  v2[3] = v3;
  *uint64_t v2 = a1;
  if (!v3)
  {
    free(v2);
    return 0LL;
  }

  return v2;
}

void BOMBufferDeallocate(void **a1)
{
  if (a1)
  {
    free(a1[3]);
    a1[8] = 0LL;
    *((_OWORD *)a1 + 2) = 0u;
    *((_OWORD *)a1 + 3) = 0u;
    *(_OWORD *)a1 = 0u;
    *((_OWORD *)a1 + 1) = 0u;
    free(a1);
  }

void *BOMBufferPoolAllocate(size_t a1, unint64_t a2)
{
  uint64_t v4 = BOM_malloczero(0xA0uLL);
  if (pthread_cond_init((pthread_cond_t *)v4 + 1, 0LL)) {
    goto LABEL_4;
  }
  if (pthread_mutex_init((pthread_mutex_t *)(v4 + 12), 0LL))
  {
    pthread_cond_destroy((pthread_cond_t *)v4 + 1);
LABEL_4:
    free(v4);
    return 0LL;
  }

  *uint64_t v4 = 0LL;
  v4[1] = 0LL;
  v4[2] = a2;
  v4[3] = a1;
  _BYTE v4[4] = 0LL;
  v4[5] = v4 + 4;
  if (a2 >= 0x40) {
    a2 = 64LL;
  }
  if (a2)
  {
    while (1)
    {
      unint64_t v6 = BOMBufferAllocate(a1);
      if (!v6) {
        break;
      }
      --v4[2];
      BOMBufferPoolAddBuffer((uint64_t)v4, (uint64_t)v6);
      if (!--a2) {
        return v4;
      }
    }

    BOMBufferPoolDeallocate((uint64_t)v4);
    return 0LL;
  }

  return v4;
}

void BOMBufferPoolDeallocate(uint64_t a1)
{
  if (a1)
  {
    uint64_t v2 = (pthread_mutex_t *)(a1 + 96);
    if (!pthread_mutex_lock((pthread_mutex_t *)(a1 + 96)) && !pthread_mutex_unlock(v2))
    {
      pthread_cond_destroy((pthread_cond_t *)(a1 + 48));
      pthread_mutex_destroy(v2);
      while (1)
      {
        uint64_t v3 = *(void *)(a1 + 32);
        if (!v3) {
          break;
        }
        uint64_t v4 = *(void *)(v3 + 56);
        uint64_t v5 = *(void **)(v3 + 64);
        if (v4)
        {
          *(void *)(v4 + 64) = v5;
          uint64_t v5 = *(void **)(v3 + 64);
        }

        else
        {
          *(void *)(a1 + 40) = v5;
        }

        void *v5 = v4;
        BOMBufferDeallocate((void **)v3);
      }

      *(void *)(a1 + 64) = 0LL;
      *(_OWORD *)(a1 + 32) = 0u;
      *(_OWORD *)(a1 + 48) = 0u;
      *(_OWORD *)a1 = 0u;
      *(_OWORD *)(a1 + 16) = 0u;
      free((void *)a1);
    }
  }

uint64_t BOMBufferPoolAddBuffer(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (pthread_mutex_t *)(a1 + 96);
  uint64_t result = pthread_mutex_lock((pthread_mutex_t *)(a1 + 96));
  if (!(_DWORD)result)
  {
    unint64_t v6 = (void *)(a1 + 32);
    uint64_t v7 = *(void *)(a1 + 32);
    *(void *)(a2 + 56) = v7;
    if (v7) {
      BOOL v8 = (void *)(v7 + 64);
    }
    else {
      BOOL v8 = (void *)(a1 + 40);
    }
    *BOOL v8 = a2 + 56;
    void *v6 = a2;
    *(void *)(a2 + 64) = v6;
    *(int64x2_t *)a1 = vaddq_s64(*(int64x2_t *)a1, vdupq_n_s64(1uLL));
    pthread_mutex_unlock(v4);
    return pthread_cond_signal((pthread_cond_t *)(a1 + 48));
  }

  return result;
}

void *BOMBufferPoolRequestBuffer(uint64_t a1)
{
  uint64_t v2 = (pthread_mutex_t *)(a1 + 96);
  if (pthread_mutex_lock((pthread_mutex_t *)(a1 + 96))) {
    return 0LL;
  }
  while (1)
  {
    uint64_t v5 = *(void *)(a1 + 8);
    if (v5) {
      break;
    }
    uint64_t v6 = *(void *)(a1 + 16);
    if (v6)
    {
      *(void *)(a1 + 16) = v6 - 1;
      ++*(void *)a1;
      pthread_mutex_unlock(v2);
      uint64_t v7 = BOMBufferAllocate(*(void *)(a1 + 24));
      if (v7) {
        return v7;
      }
      if (pthread_mutex_lock(v2)) {
        return 0LL;
      }
      ++*(void *)(a1 + 16);
      --*(void *)a1;
    }

    else if (pthread_cond_wait((pthread_cond_t *)(a1 + 48), v2))
    {
      return 0LL;
    }
  }

  uint64_t v3 = *(void *)(a1 + 32);
  uint64_t v8 = *(void *)(v3 + 56);
  uint64_t v9 = *(void **)(v3 + 64);
  if (v8)
  {
    *(void *)(v8 + 64) = v9;
    uint64_t v9 = *(void **)(v3 + 64);
  }

  else
  {
    *(void *)(a1 + 40) = v9;
  }

  *uint64_t v9 = v8;
  *(void *)(a1 + 8) = v5 - 1;
  pthread_mutex_unlock(v2);
  pthread_cond_signal((pthread_cond_t *)(a1 + 48));
  return (void *)v3;
}

uint64_t BOMBufferPoolReturnBuffer(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (pthread_mutex_t *)(a1 + 96);
  uint64_t result = pthread_mutex_lock((pthread_mutex_t *)(a1 + 96));
  if (!(_DWORD)result)
  {
    uint64_t v7 = *(void *)(a1 + 32);
    uint64_t v6 = a1 + 32;
    *(void *)(a2 + 56) = v7;
    uint64_t v8 = (void *)(v7 + 64);
    if (v7) {
      uint64_t v9 = v8;
    }
    else {
      uint64_t v9 = (void *)(v6 + 8);
    }
    *uint64_t v9 = a2 + 56;
    *(void *)uint64_t v6 = a2;
    *(void *)(a2 + 64) = v6;
    ++*(void *)(v6 - 24);
    pthread_mutex_unlock(v4);
    return pthread_cond_signal((pthread_cond_t *)(v6 + 16));
  }

  return result;
}

char *BOMBufferFIFOCreate()
{
  uint64_t v0 = (char *)BOM_malloczero(0x88uLL);
  if (!pthread_cond_init((pthread_cond_t *)(v0 + 24), 0LL))
  {
    if (!pthread_mutex_init((pthread_mutex_t *)(v0 + 72), 0LL))
    {
      *(void *)uint64_t v0 = 0LL;
      *((void *)v0 + 1) = 0LL;
      *((void *)v0 + 2) = v0 + 8;
      return v0;
    }

    pthread_cond_destroy((pthread_cond_t *)(v0 + 24));
  }

  free(v0);
  return 0LL;
}

void BOMBufferFIFODestroy(uint64_t a1)
{
  if (a1)
  {
    uint64_t v2 = (pthread_mutex_t *)(a1 + 72);
    if (!pthread_mutex_lock((pthread_mutex_t *)(a1 + 72)))
    {
      if (*(void *)a1)
      {
        uint64_t v3 = BOMExceptionHandlerMessage("Attempting to destroy a non-empty FIFO!");
        uint64_t v4 = __error();
        _BOMFatalException((uint64_t)v3, "/Library/Caches/com.apple.xbs/Sources/Bom/Common/BOMBufferManager.c", 308, *v4);
      }

      if (!pthread_mutex_unlock(v2))
      {
        pthread_cond_destroy((pthread_cond_t *)(a1 + 24));
        pthread_mutex_destroy(v2);
        free((void *)a1);
      }
    }
  }

uint64_t BOMBufferFIFOEnqueue(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (pthread_mutex_t *)(a1 + 72);
  uint64_t result = pthread_mutex_lock((pthread_mutex_t *)(a1 + 72));
  if (!(_DWORD)result)
  {
    *(void *)(a2 + 56) = 0LL;
    uint64_t v6 = *(void **)(a1 + 16);
    *(void *)(a2 + 64) = v6;
    void *v6 = a2;
    *(void *)(a1 + 16) = a2 + 56;
    ++*(void *)a1;
    pthread_mutex_unlock(v4);
    return pthread_cond_broadcast((pthread_cond_t *)(a1 + 24));
  }

  return result;
}

uint64_t BOMBufferFIFODequeue(uint64_t *a1)
{
  uint64_t v2 = (pthread_mutex_t *)(a1 + 9);
  if (pthread_mutex_lock((pthread_mutex_t *)(a1 + 9))) {
    return 0LL;
  }
  while (1)
  {
    uint64_t v3 = *a1;
    if (*a1) {
      break;
    }
    if (pthread_cond_wait((pthread_cond_t *)(a1 + 3), v2)) {
      return 0LL;
    }
  }

  uint64_t v4 = a1[1];
  uint64_t v6 = *(void *)(v4 + 56);
  uint64_t v7 = *(void **)(v4 + 64);
  if (v6)
  {
    *(void *)(v6 + 64) = v7;
    uint64_t v7 = *(void **)(v4 + 64);
  }

  else
  {
    a1[2] = (uint64_t)v7;
  }

  *uint64_t v7 = v6;
  uint64_t v8 = v3 - 1;
  *a1 = v3 - 1;
  pthread_mutex_unlock(v2);
  uint64_t v9 = (pthread_cond_t *)(a1 + 3);
  if (v8) {
    pthread_cond_signal(v9);
  }
  else {
    pthread_cond_broadcast(v9);
  }
  return v4;
}

uint64_t BOMBufferFIFOCount(uint64_t *a1)
{
  uint64_t v2 = (pthread_mutex_t *)(a1 + 9);
  if (pthread_mutex_lock((pthread_mutex_t *)(a1 + 9))) {
    return 0LL;
  }
  uint64_t v3 = *a1;
  pthread_mutex_unlock(v2);
  return v3;
}

uint64_t BomSys_init(void *a1, uint64_t a2)
{
  return BomSys_clone(a1, &gDefaultSys, a2);
}

uint64_t BomSys_clone(void *a1, const void *a2, uint64_t a3)
{
  if (!a1) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v6 = BOM_malloc(0x160uLL);
  if (!v6) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v7 = v6;
  memcpy(v6, a2, 0x160uLL);
  uint64_t result = 0LL;
  v7[1] = a3;
  *a1 = v7;
  return result;
}

void BomSys_free(void *a1)
{
  if (a1)
  {
    if (a1 != &gDefaultSys) {
      free(a1);
    }
  }

uint64_t BomSys_set_open(uint64_t result, uint64_t (*a2)(int a1, char *a2, int a3, unsigned int a4))
{
  if (result && (_UNKNOWN *)result != &gDefaultSys && !*(void *)result)
  {
    uint64_t v2 = BomSys_open;
    if (a2) {
      uint64_t v2 = a2;
    }
    *(void *)(result + 16) = v2;
  }

  return result;
}

uint64_t BomSys_open(int a1, char *a2, int a3, unsigned int a4)
{
  return open(a2, a3, a4);
}

uint64_t BomSys_set_close(uint64_t result, uint64_t (*a2)(int a1, int a2))
{
  if (result && (_UNKNOWN *)result != &gDefaultSys && !*(void *)result)
  {
    uint64_t v2 = BomSys_close;
    if (a2) {
      uint64_t v2 = a2;
    }
    *(void *)(result + 32) = v2;
  }

  return result;
}

uint64_t BomSys_close(int a1, int a2)
{
  return close(a2);
}

uint64_t BomSys_set_read(uint64_t result, ssize_t (*a2)(int a1, int a2, void *a3, size_t a4))
{
  if (result && (_UNKNOWN *)result != &gDefaultSys && !*(void *)result)
  {
    uint64_t v2 = BomSys_read;
    if (a2) {
      uint64_t v2 = a2;
    }
    *(void *)(result + 48) = v2;
  }

  return result;
}

ssize_t BomSys_read(int a1, int a2, void *a3, size_t a4)
{
  return read(a2, a3, a4);
}

uint64_t BomSys_set_lchown(uint64_t result, uint64_t (*a2)(int a1, char *a2, uid_t a3, gid_t a4))
{
  if (result && (_UNKNOWN *)result != &gDefaultSys && !*(void *)result)
  {
    uint64_t v2 = BomSys_lchown;
    if (a2) {
      uint64_t v2 = a2;
    }
    *(void *)(result + 192) = v2;
  }

  return result;
}

uint64_t BomSys_lchown(int a1, char *a2, uid_t a3, gid_t a4)
{
  return lchown(a2, a3, a4);
}

uint64_t BomSys_set_chmod(uint64_t result, uint64_t (*a2)(int a1, char *a2, mode_t a3))
{
  if (result && (_UNKNOWN *)result != &gDefaultSys && !*(void *)result)
  {
    uint64_t v2 = BomSys_chmod;
    if (a2) {
      uint64_t v2 = a2;
    }
    *(void *)(result + 200) = v2;
  }

  return result;
}

uint64_t BomSys_chmod(int a1, char *a2, mode_t a3)
{
  return chmod(a2, a3);
}

uint64_t BomSys_set_symlink(uint64_t result, uint64_t (*a2)(int a1, char *a2, char *a3))
{
  if (result && (_UNKNOWN *)result != &gDefaultSys && !*(void *)result)
  {
    uint64_t v2 = BomSys_symlink;
    if (a2) {
      uint64_t v2 = a2;
    }
    *(void *)(result + 248) = v2;
  }

  return result;
}

uint64_t BomSys_symlink(int a1, char *a2, char *a3)
{
  return symlink(a2, a3);
}

uint64_t BomSys_set_opendir(uint64_t result, DIR *(*a2)(int a1, char *a2))
{
  if (result && (_UNKNOWN *)result != &gDefaultSys && !*(void *)result)
  {
    uint64_t v2 = BomSys_opendir;
    if (a2) {
      uint64_t v2 = a2;
    }
    *(void *)(result + 272) = v2;
  }

  return result;
}

DIR *BomSys_opendir(int a1, char *a2)
{
  return opendir(a2);
}

uint64_t BomSys_set_closedir(uint64_t result, uint64_t (*a2)(int a1, DIR *a2))
{
  if (result && (_UNKNOWN *)result != &gDefaultSys && !*(void *)result)
  {
    uint64_t v2 = BomSys_closedir;
    if (a2) {
      uint64_t v2 = a2;
    }
    *(void *)(result + 280) = v2;
  }

  return result;
}

uint64_t BomSys_closedir(int a1, DIR *a2)
{
  return closedir(a2);
}

uint64_t BomSys_set_readdir(uint64_t result, dirent *(*a2)(int a1, DIR *a2))
{
  if (result && (_UNKNOWN *)result != &gDefaultSys && !*(void *)result)
  {
    uint64_t v2 = BomSys_readdir;
    if (a2) {
      uint64_t v2 = a2;
    }
    *(void *)(result + 288) = v2;
  }

  return result;
}

dirent *BomSys_readdir(int a1, DIR *a2)
{
  return readdir(a2);
}

uint64_t BomSys_set_readdir_r( uint64_t result, uint64_t (*a2)(int a1, DIR *a2, dirent *a3, dirent **a4))
{
  if (result && (_UNKNOWN *)result != &gDefaultSys && !*(void *)result)
  {
    uint64_t v2 = BomSys_readdir_r;
    if (a2) {
      uint64_t v2 = a2;
    }
    *(void *)(result + 296) = v2;
  }

  return result;
}

uint64_t BomSys_readdir_r(int a1, DIR *a2, dirent *a3, dirent **a4)
{
  return readdir_r(a2, a3, a4);
}

uint64_t BomSys_set_copyfile( uint64_t result, uint64_t (*a2)(int a1, char *from, char *to, copyfile_state_t state, copyfile_flags_t flags))
{
  if (result && (_UNKNOWN *)result != &gDefaultSys && !*(void *)result)
  {
    uint64_t v2 = BomSys_copyfile;
    if (a2) {
      uint64_t v2 = a2;
    }
    *(void *)(result + 344) = v2;
  }

  return result;
}

uint64_t BomSys_copyfile(int a1, char *from, char *to, copyfile_state_t state, copyfile_flags_t flags)
{
  return copyfile(from, to, state, flags);
}

uint64_t BomSys_set_access(uint64_t result, uint64_t (*a2)(int a1, char *a2, int a3))
{
  if (result && (_UNKNOWN *)result != &gDefaultSys && !*(void *)result)
  {
    uint64_t v2 = BomSys_access;
    if (a2) {
      uint64_t v2 = a2;
    }
    *(void *)(result + 184) = v2;
  }

  return result;
}

uint64_t BomSys_access(int a1, char *a2, int a3)
{
  return access(a2, a3);
}

uint64_t BomSys_set_fstat(uint64_t result, uint64_t (*a2)(int a1, int a2, stat *a3))
{
  if (result && (_UNKNOWN *)result != &gDefaultSys && !*(void *)result)
  {
    uint64_t v2 = BomSys_fstat;
    if (a2) {
      uint64_t v2 = a2;
    }
    *(void *)(result + 88) = v2;
  }

  return result;
}

uint64_t BomSys_fstat(int a1, int a2, stat *a3)
{
  return fstat(a2, a3);
}

uint64_t BomSys_set_lseek(uint64_t result, off_t (*a2)(int a1, int a2, off_t a3, int a4))
{
  if (result && (_UNKNOWN *)result != &gDefaultSys && !*(void *)result)
  {
    uint64_t v2 = BomSys_lseek;
    if (a2) {
      uint64_t v2 = a2;
    }
    *(void *)(result + 64) = v2;
  }

  return result;
}

off_t BomSys_lseek(int a1, int a2, off_t a3, int a4)
{
  return lseek(a2, a3, a4);
}

uint64_t BomSys_set_mmap( uint64_t result, void *(*a2)(int a1, void *a2, size_t a3, int a4, int a5, int a6, off_t a7))
{
  if (result && (_UNKNOWN *)result != &gDefaultSys && !*(void *)result)
  {
    uint64_t v2 = BomSys_mmap;
    if (a2) {
      uint64_t v2 = a2;
    }
    *(void *)(result + 320) = v2;
  }

  return result;
}

void *BomSys_mmap(int a1, void *a2, size_t a3, int a4, int a5, int a6, off_t a7)
{
  return mmap(a2, a3, a4, a5, a6, a7);
}

uint64_t BomSys_set_munmap(uint64_t result, uint64_t (*a2)(int a1, void *a2, size_t a3))
{
  if (result && (_UNKNOWN *)result != &gDefaultSys && !*(void *)result)
  {
    uint64_t v2 = BomSys_munmap;
    if (a2) {
      uint64_t v2 = a2;
    }
    *(void *)(result + 328) = v2;
  }

  return result;
}

uint64_t BomSys_munmap(int a1, void *a2, size_t a3)
{
  return munmap(a2, a3);
}

void *BomSys_default()
{
  return &gDefaultSys;
}

uint64_t BomSys_openFor(int a1, char *a2, int a3, unsigned int a4)
{
  return open(a2, a3, a4);
}

uint64_t BomSys_fcntl(int a1, int a2, int a3, uint64_t a4)
{
  return fcntl(a2, a3, a4);
}

ssize_t BomSys_write(int a1, int __fd, void *__buf, size_t __nbyte)
{
  return write(__fd, __buf, __nbyte);
}

uint64_t BomSys_fsync(int a1, int a2)
{
  return fsync(a2);
}

uint64_t BomSys_stat(int a1, char *a2, stat *a3)
{
  return stat(a2, a3);
}

uint64_t BomSys_lstat(int a1, char *a2, stat *a3)
{
  return lstat(a2, a3);
}

uint64_t BomSys_statfs(int a1, char *a2, statfs *a3)
{
  return statfs(a2, a3);
}

uint64_t BomSys_fstatfs(int a1, int a2, statfs *a3)
{
  return fstatfs(a2, a3);
}

uint64_t BomSys_getattrlist(int a1, char *a2, void *a3, void *a4, size_t a5, unsigned int a6)
{
  return getattrlist(a2, a3, a4, a5, a6);
}

ssize_t BomSys_getxattr( int a1, char *path, char *name, void *value, size_t size, u_int32_t position, int options)
{
  return getxattr(path, name, value, size, position, options);
}

uint64_t BomSys_setxattr( int a1, char *path, char *name, void *value, size_t size, u_int32_t position, int options)
{
  return setxattr(path, name, value, size, position, options);
}

ssize_t BomSys_listxattr(int a1, char *path, char *namebuff, size_t size, int options)
{
  return listxattr(path, namebuff, size, options);
}

uint64_t BomSys_removexattr(int a1, char *path, char *name, int options)
{
  return removexattr(path, name, options);
}

char *BomSys_realpath(int a1, char *a2, char *a3)
{
  return realpath_DARWIN_EXTSN(a2, a3);
}

uint64_t BomSys_mkdir(int a1, char *a2, mode_t a3)
{
  return mkdir(a2, a3);
}

uint64_t BomSys_mknod(int a1, char *a2, mode_t a3, dev_t a4)
{
  return mknod(a2, a3, a4);
}

uint64_t BomSys_chflags(int a1, char *a2, __uint32_t a3)
{
  return chflags(a2, a3);
}

uint64_t BomSys_utimes(int a1, char *a2, timeval *a3)
{
  return utimes(a2, a3);
}

uint64_t BomSys_unlink(int a1, char *a2)
{
  return unlink(a2);
}

uint64_t BomSys_rmdir(int a1, char *a2)
{
  return rmdir(a2);
}

uint64_t BomSys_link(int a1, char *a2, char *a3)
{
  return link(a2, a3);
}

ssize_t BomSys_readlink(int a1, char *a2, char *a3, size_t a4)
{
  return readlink(a2, a3, a4);
}

uint64_t BomSys_rename(int a1, char *__old, char *__new)
{
  return rename(__old, __new);
}

char *BomSys_getcwd(int a1, char *a2, size_t a3)
{
  return getcwd(a2, a3);
}

uint64_t BomSys_chdir(int a1, char *a2)
{
  return chdir(a2);
}

char *BomSys_mktemp(int a1, char *a2)
{
  return mktemp(a2);
}

uint64_t BomSys_log_attached(uint64_t result)
{
  if (result)
  {
    if (*(void *)result) {
      return *(void *)(*(void *)result + 352LL);
    }
    else {
      return 0LL;
    }
  }

  return result;
}

void *BomSys_log_attach(void **a1, int a2, int a3, uint64_t a4, char a5)
{
  uint64_t v9 = a1;
  if (!a1) {
    uint64_t v9 = (void **)BomSys_default();
  }
  BOOL v10 = *v9;
  if (!*v9) {
    BOOL v10 = BOM_malloczero(0x1A8uLL);
  }
  memcpy(v10, &gLogSysSTDIO, 0x160uLL);
  *BOOL v10 = v10;
  v10[1] = v10;
  v10[44] = v9;
  v10[45] = a4;
  *((_BYTE *)v10 + 368) = a5;
  *((_DWORD *)v10 + 93) = a3;
  if ((a3 & 0x100) != 0)
  {
    *((_BYTE *)v10 + 394) = a2;
    if ((a3 & 0x10000) == 0)
    {
LABEL_7:
      if ((a3 & 0x2000) == 0) {
        goto LABEL_8;
      }
      goto LABEL_18;
    }
  }

  else if ((a3 & 0x10000) == 0)
  {
    goto LABEL_7;
  }

  *((_DWORD *)v10 + 95) = 16843009 * a2;
  if ((a3 & 0x2000) == 0)
  {
LABEL_8:
    if ((a3 & 0x8000) == 0) {
      goto LABEL_9;
    }
    goto LABEL_19;
  }

uint64_t BomSys_log_detach(void **a1)
{
  if (!a1) {
    return 0LL;
  }
  uint64_t v1 = *a1;
  if (!v1) {
    return 0LL;
  }
  uint64_t v2 = v1[44];
  free(v1);
  return v2;
}

uint64_t BomSys_log_config(uint64_t result, char *__s2, char a3)
{
  if (result)
  {
    if (__s2)
    {
      uint64_t v4 = *(_BYTE **)result;
      if (*(void *)result)
      {
        uint64_t result = strcmp("realpath", __s2);
        if ((_DWORD)result)
        {
          uint64_t result = strcmp("mkdir", __s2);
          if ((_DWORD)result)
          {
            uint64_t result = strcmp("read", __s2);
            if ((_DWORD)result)
            {
              uint64_t result = strcmp("write", __s2);
              if ((_DWORD)result)
              {
                uint64_t result = strcmp("lseek", __s2);
                if ((_DWORD)result)
                {
                  uint64_t result = strcmp("fsync", __s2);
                  if ((_DWORD)result)
                  {
                    uint64_t result = strcmp("stat", __s2);
                    if ((_DWORD)result)
                    {
                      uint64_t result = strcmp("fstat", __s2);
                      if ((_DWORD)result)
                      {
                        uint64_t result = strcmp("lstat", __s2);
                        if ((_DWORD)result)
                        {
                          uint64_t result = strcmp("statfs", __s2);
                          if ((_DWORD)result)
                          {
                            uint64_t result = strcmp("fstatfs", __s2);
                            if ((_DWORD)result)
                            {
                              uint64_t result = strcmp("getattrlist", __s2);
                              if ((_DWORD)result)
                              {
                                uint64_t result = strcmp("getxattr", __s2);
                                if ((_DWORD)result)
                                {
                                  uint64_t result = strcmp("setxattr", __s2);
                                  if ((_DWORD)result)
                                  {
                                    uint64_t result = strcmp("listxattr", __s2);
                                    if ((_DWORD)result)
                                    {
                                      uint64_t result = strcmp("removexattr", __s2);
                                      if ((_DWORD)result)
                                      {
                                        uint64_t result = strcmp("open", __s2);
                                        if ((_DWORD)result)
                                        {
                                          uint64_t result = strcmp("openFor", __s2);
                                          if ((_DWORD)result)
                                          {
                                            uint64_t result = strcmp("close", __s2);
                                            if ((_DWORD)result)
                                            {
                                              uint64_t result = strcmp("fcntl", __s2);
                                              if ((_DWORD)result)
                                              {
                                                uint64_t result = strcmp("unlink", __s2);
                                                if ((_DWORD)result)
                                                {
                                                  uint64_t result = strcmp("rename", __s2);
                                                  if ((_DWORD)result)
                                                  {
                                                    uint64_t result = strcmp("opendir", __s2);
                                                    if ((_DWORD)result)
                                                    {
                                                      uint64_t result = strcmp("closedir", __s2);
                                                      if ((_DWORD)result)
                                                      {
                                                        uint64_t result = strcmp("readdir", __s2);
                                                        if ((_DWORD)result)
                                                        {
                                                          uint64_t result = strcmp("readdir_r", __s2);
                                                          if ((_DWORD)result)
                                                          {
                                                            uint64_t result = strcmp("getcwd", __s2);
                                                            if ((_DWORD)result)
                                                            {
                                                              uint64_t result = strcmp("chdir", __s2);
                                                              if ((_DWORD)result)
                                                              {
                                                                uint64_t result = strcmp("rmdir", __s2);
                                                                if ((_DWORD)result)
                                                                {
                                                                  uint64_t result = strcmp("mknod", __s2);
                                                                  if ((_DWORD)result)
                                                                  {
                                                                    uint64_t result = strcmp("link", __s2);
                                                                    if ((_DWORD)result)
                                                                    {
                                                                      uint64_t result = strcmp("symlink", __s2);
                                                                      if ((_DWORD)result)
                                                                      {
                                                                        uint64_t result = strcmp("readlink", __s2);
                                                                        if ((_DWORD)result)
                                                                        {
                                                                          uint64_t result = strcmp("access", __s2);
                                                                          if ((_DWORD)result)
                                                                          {
                                                                            uint64_t result = strcmp("lchown", __s2);
                                                                            if ((_DWORD)result)
                                                                            {
                                                                              uint64_t result = strcmp("chmod", __s2);
                                                                              if ((_DWORD)result)
                                                                              {
                                                                                uint64_t result = strcmp("chflags", __s2);
                                                                                if ((_DWORD)result)
                                                                                {
                                                                                  uint64_t result = strcmp("utimes", __s2);
                                                                                  if ((_DWORD)result)
                                                                                  {
                                                                                    uint64_t result = strcmp("mmap", __s2);
                                                                                    if ((_DWORD)result)
                                                                                    {
                                                                                      uint64_t result = strcmp("munmap", __s2);
                                                                                      if ((_DWORD)result)
                                                                                      {
                                                                                        uint64_t result = strcmp("mktemp", __s2);
                                                                                        if (!(_DWORD)result) {
                                                                                          v4[416] = a3;
                                                                                        }
                                                                                      }

                                                                                      else
                                                                                      {
                                                                                        v4[415] = a3;
                                                                                      }
                                                                                    }

                                                                                    else
                                                                                    {
                                                                                      v4[414] = a3;
                                                                                    }
                                                                                  }

                                                                                  else
                                                                                  {
                                                                                    v4[401] = a3;
                                                                                  }
                                                                                }

                                                                                else
                                                                                {
                                                                                  v4[400] = a3;
                                                                                }
                                                                              }

                                                                              else
                                                                              {
                                                                                v4[399] = a3;
                                                                              }
                                                                            }

                                                                            else
                                                                            {
                                                                              v4[398] = a3;
                                                                            }
                                                                          }

                                                                          else
                                                                          {
                                                                            v4[397] = a3;
                                                                          }
                                                                        }

                                                                        else
                                                                        {
                                                                          v4[406] = a3;
                                                                        }
                                                                      }

                                                                      else
                                                                      {
                                                                        v4[405] = a3;
                                                                      }
                                                                    }

                                                                    else
                                                                    {
                                                                      v4[404] = a3;
                                                                    }
                                                                  }

                                                                  else
                                                                  {
                                                                    v4[396] = a3;
                                                                  }
                                                                }

                                                                else
                                                                {
                                                                  v4[403] = a3;
                                                                }
                                                              }

                                                              else
                                                              {
                                                                v4[413] = a3;
                                                              }
                                                            }

                                                            else
                                                            {
                                                              v4[412] = a3;
                                                            }
                                                          }

                                                          else
                                                          {
                                                            v4[411] = a3;
                                                          }
                                                        }

                                                        else
                                                        {
                                                          v4[410] = a3;
                                                        }
                                                      }

                                                      else
                                                      {
                                                        v4[409] = a3;
                                                      }
                                                    }

                                                    else
                                                    {
                                                      v4[408] = a3;
                                                    }
                                                  }

                                                  else
                                                  {
                                                    v4[407] = a3;
                                                  }
                                                }

                                                else
                                                {
                                                  v4[402] = a3;
                                                }
                                              }

                                              else
                                              {
                                                v4[379] = a3;
                                              }
                                            }

                                            else
                                            {
                                              v4[378] = a3;
                                            }
                                          }

                                          else
                                          {
                                            v4[377] = a3;
                                          }
                                        }

                                        else
                                        {
                                          v4[376] = a3;
                                        }
                                      }

                                      else
                                      {
                                        v4[393] = a3;
                                      }
                                    }

                                    else
                                    {
                                      v4[392] = a3;
                                    }
                                  }

                                  else
                                  {
                                    v4[391] = a3;
                                  }
                                }

                                else
                                {
                                  v4[390] = a3;
                                }
                              }

                              else
                              {
                                v4[389] = a3;
                              }
                            }

                            else
                            {
                              v4[388] = a3;
                            }
                          }

                          else
                          {
                            v4[387] = a3;
                          }
                        }

                        else
                        {
                          v4[386] = a3;
                        }
                      }

                      else
                      {
                        v4[385] = a3;
                      }
                    }

                    else
                    {
                      v4[384] = a3;
                    }
                  }

                  else
                  {
                    v4[383] = a3;
                  }
                }

                else
                {
                  v4[382] = a3;
                }
              }

              else
              {
                v4[381] = a3;
              }
            }

            else
            {
              v4[380] = a3;
            }
          }

          else
          {
            v4[395] = a3;
          }
        }

        else
        {
          v4[394] = a3;
        }
      }
    }
  }

  return result;
}

uint64_t BomSys_log_resume(uint64_t result)
{
  if (result)
  {
    if (*(void *)result) {
      *(_BYTE *)(*(void *)result + 368LL) = 1;
    }
  }

  return result;
}

uint64_t BomSys_log_pause(uint64_t result)
{
  if (result)
  {
    if (*(void *)result) {
      *(_BYTE *)(*(void *)result + 368LL) = 0;
    }
  }

  return result;
}

uint64_t BomSysLog_open(uint64_t a1, const char *a2, int a3, int a4)
{
  uint64_t v8 = (*(uint64_t (**)(void))(*(void *)(a1 + 352) + 16LL))(*(void *)(*(void *)(a1 + 352) + 8LL));
  if (*(_BYTE *)(a1 + 368) && *(_BYTE *)(a1 + 376)) {
    fprintf(*(FILE **)(a1 + 360), "open(%s, %d, %d) => %d\n", a2, a3, a4, v8);
  }
  return v8;
}

uint64_t BomSysLog_openFor(uint64_t a1, const char *a2, int a3, int a4, const char *a5)
{
  uint64_t v10 = (*(uint64_t (**)(void))(*(void *)(a1 + 352) + 24LL))(*(void *)(*(void *)(a1 + 352) + 8LL));
  if (*(_BYTE *)(a1 + 368) && *(_BYTE *)(a1 + 377)) {
    fprintf(*(FILE **)(a1 + 360), "openFor(%s, %d, %d, %s) => %d\n", a2, a3, a4, a5, v10);
  }
  return v10;
}

uint64_t BomSysLog_close(uint64_t a1, int a2)
{
  uint64_t v4 = (*(uint64_t (**)(void))(*(void *)(a1 + 352) + 32LL))(*(void *)(*(void *)(a1 + 352) + 8LL));
  if (*(_BYTE *)(a1 + 368) && *(_BYTE *)(a1 + 378)) {
    fprintf(*(FILE **)(a1 + 360), "close(%d) => %d\n", a2, v4);
  }
  return v4;
}

uint64_t BomSysLog_fcntl(uint64_t a1, int a2, int a3, const void *a4)
{
  uint64_t v8 = (*(uint64_t (**)(void))(*(void *)(a1 + 352) + 40LL))(*(void *)(*(void *)(a1 + 352) + 8LL));
  if (*(_BYTE *)(a1 + 368) && *(_BYTE *)(a1 + 379)) {
    fprintf(*(FILE **)(a1 + 360), "fcntl(%d, %d, %p) => %d\n", a2, a3, a4, v8);
  }
  return v8;
}

uint64_t BomSysLog_read(uint64_t a1, int a2, const void *a3, uint64_t a4)
{
  uint64_t v8 = (*(uint64_t (**)(void))(*(void *)(a1 + 352) + 48LL))(*(void *)(*(void *)(a1 + 352) + 8LL));
  if (*(_BYTE *)(a1 + 368) && *(_BYTE *)(a1 + 380)) {
    fprintf(*(FILE **)(a1 + 360), "read(%d, %p, %zu) => %zd\n", a2, a3, a4, v8);
  }
  return v8;
}

uint64_t BomSysLog_write(uint64_t a1, int a2, const void *a3, uint64_t a4)
{
  uint64_t v8 = (*(uint64_t (**)(void))(*(void *)(a1 + 352) + 56LL))(*(void *)(*(void *)(a1 + 352) + 8LL));
  if (*(_BYTE *)(a1 + 368) && *(_BYTE *)(a1 + 381)) {
    fprintf(*(FILE **)(a1 + 360), "write(%d, %p, %zu) => %zd\n", a2, a3, a4, v8);
  }
  return v8;
}

uint64_t BomSysLog_lseek(uint64_t a1, int a2, uint64_t a3, int a4)
{
  uint64_t v8 = (*(uint64_t (**)(void))(*(void *)(a1 + 352) + 64LL))(*(void *)(*(void *)(a1 + 352) + 8LL));
  if (*(_BYTE *)(a1 + 368) && *(_BYTE *)(a1 + 382)) {
    fprintf(*(FILE **)(a1 + 360), "lseek(%d, %lld, %d) => %lld\n", a2, a3, a4, v8);
  }
  return v8;
}

uint64_t BomSysLog_fsync(uint64_t a1, int a2)
{
  uint64_t v4 = (*(uint64_t (**)(void))(*(void *)(a1 + 352) + 72LL))(*(void *)(*(void *)(a1 + 352) + 8LL));
  if (*(_BYTE *)(a1 + 368) && *(_BYTE *)(a1 + 383)) {
    fprintf(*(FILE **)(a1 + 360), "fsync(%d) => %d\n", a2, v4);
  }
  return v4;
}

uint64_t BomSysLog_stat(uint64_t a1, const char *a2, const void *a3)
{
  uint64_t v6 = (*(uint64_t (**)(void))(*(void *)(a1 + 352) + 80LL))(*(void *)(*(void *)(a1 + 352) + 8LL));
  if (*(_BYTE *)(a1 + 368) && *(_BYTE *)(a1 + 384)) {
    fprintf(*(FILE **)(a1 + 360), "stat(%s, %p) => %d\n", a2, a3, v6);
  }
  return v6;
}

uint64_t BomSysLog_fstat(uint64_t a1, int a2, const void *a3)
{
  uint64_t v6 = (*(uint64_t (**)(void))(*(void *)(a1 + 352) + 88LL))(*(void *)(*(void *)(a1 + 352) + 8LL));
  if (*(_BYTE *)(a1 + 368) && *(_BYTE *)(a1 + 385)) {
    fprintf(*(FILE **)(a1 + 360), "fstat(%d, %p) => %d\n", a2, a3, v6);
  }
  return v6;
}

uint64_t BomSysLog_lstat(uint64_t a1, const char *a2, const void *a3)
{
  uint64_t v6 = (*(uint64_t (**)(void))(*(void *)(a1 + 352) + 96LL))(*(void *)(*(void *)(a1 + 352) + 8LL));
  if (*(_BYTE *)(a1 + 368) && *(_BYTE *)(a1 + 386)) {
    fprintf(*(FILE **)(a1 + 360), "lstat(%s, %p) => %d\n", a2, a3, v6);
  }
  return v6;
}

uint64_t BomSysLog_statfs(uint64_t a1, const char *a2, const void *a3)
{
  uint64_t v6 = (*(uint64_t (**)(void))(*(void *)(a1 + 352) + 104LL))(*(void *)(*(void *)(a1 + 352) + 8LL));
  if (*(_BYTE *)(a1 + 368) && *(_BYTE *)(a1 + 387)) {
    fprintf(*(FILE **)(a1 + 360), "statfs(%s, %p) => %d\n", a2, a3, v6);
  }
  return v6;
}

uint64_t BomSysLog_fstatfs(uint64_t a1, int a2, const void *a3)
{
  uint64_t v6 = (*(uint64_t (**)(void))(*(void *)(a1 + 352) + 112LL))(*(void *)(*(void *)(a1 + 352) + 8LL));
  if (*(_BYTE *)(a1 + 368) && *(_BYTE *)(a1 + 388)) {
    fprintf(*(FILE **)(a1 + 360), "fstatfs(%d, %p) => %d\n", a2, a3, v6);
  }
  return v6;
}

uint64_t BomSysLog_getattrlist( uint64_t a1, const char *a2, const void *a3, const void *a4, uint64_t a5, uint64_t a6)
{
  uint64_t v12 = (*(uint64_t (**)(void))(*(void *)(a1 + 352) + 120LL))(*(void *)(*(void *)(a1 + 352) + 8LL));
  if (*(_BYTE *)(a1 + 368) && *(_BYTE *)(a1 + 389)) {
    fprintf(*(FILE **)(a1 + 360), "getattrlist(%s, %p, %p, %zu, %lu) => %d\n", a2, a3, a4, a5, a6, v12);
  }
  return v12;
}

uint64_t BomSysLog_getxattr( uint64_t a1, const char *a2, const char *a3, const void *a4, uint64_t a5, int a6, int a7)
{
  uint64_t v14 = (*(uint64_t (**)(void))(*(void *)(a1 + 352) + 128LL))(*(void *)(*(void *)(a1 + 352) + 8LL));
  if (*(_BYTE *)(a1 + 368) && *(_BYTE *)(a1 + 390)) {
    fprintf(*(FILE **)(a1 + 360), "getxattr(%s, %s, %p, %zu, %u, %d) => %zd\n", a2, a3, a4, a5, a6, a7, v14);
  }
  return v14;
}

uint64_t BomSysLog_setxattr( uint64_t a1, const char *a2, const char *a3, const void *a4, uint64_t a5, int a6, int a7)
{
  uint64_t v14 = (*(uint64_t (**)(void))(*(void *)(a1 + 352) + 136LL))(*(void *)(*(void *)(a1 + 352) + 8LL));
  if (*(_BYTE *)(a1 + 368) && *(_BYTE *)(a1 + 391)) {
    fprintf(*(FILE **)(a1 + 360), "setxattr(%s, %s, %p, %zu, %u, %d) => %d\n", a2, a3, a4, a5, a6, a7, v14);
  }
  return v14;
}

uint64_t BomSysLog_listxattr(uint64_t a1, const char *a2, const char *a3, uint64_t a4, int a5)
{
  uint64_t v10 = (*(uint64_t (**)(void))(*(void *)(a1 + 352) + 144LL))(*(void *)(*(void *)(a1 + 352) + 8LL));
  if (*(_BYTE *)(a1 + 368) && *(_BYTE *)(a1 + 392)) {
    fprintf(*(FILE **)(a1 + 360), "listxattr(%s, %s, %zu, %d) => %zd\n", a2, a3, a4, a5, v10);
  }
  return v10;
}

uint64_t BomSysLog_removexattr(uint64_t a1, const char *a2, const char *a3, int a4)
{
  uint64_t v8 = (*(uint64_t (**)(void))(*(void *)(a1 + 352) + 152LL))(*(void *)(*(void *)(a1 + 352) + 8LL));
  if (*(_BYTE *)(a1 + 368) && *(_BYTE *)(a1 + 393)) {
    fprintf(*(FILE **)(a1 + 360), "removexattr(%s, %s, %d) => %d\n", a2, a3, a4, v8);
  }
  return v8;
}

uint64_t BomSysLog_realpath(uint64_t a1, const char *a2, const char *a3)
{
  uint64_t v6 = (*(uint64_t (**)(void))(*(void *)(a1 + 352) + 160LL))(*(void *)(*(void *)(a1 + 352) + 8LL));
  if (*(_BYTE *)(a1 + 368) && *(_BYTE *)(a1 + 394))
  {
    uint64_t v7 = "(null)";
    if (a2) {
      uint64_t v8 = a2;
    }
    else {
      uint64_t v8 = "(null)";
    }
    if (a3) {
      uint64_t v9 = a3;
    }
    else {
      uint64_t v9 = "(null)";
    }
    if (v6) {
      uint64_t v7 = (const char *)v6;
    }
    fprintf(*(FILE **)(a1 + 360), "realpath(%s, %s) => %s\n", v8, v9, v7);
  }

  return v6;
}

uint64_t BomSysLog_mkdir(uint64_t a1, const char *a2, int a3)
{
  uint64_t v6 = (*(uint64_t (**)(void))(*(void *)(a1 + 352) + 168LL))(*(void *)(*(void *)(a1 + 352) + 8LL));
  if (*(_BYTE *)(a1 + 368) && *(_BYTE *)(a1 + 395)) {
    fprintf(*(FILE **)(a1 + 360), "mkdir(%s, %d) => %d\n", a2, a3, v6);
  }
  return v6;
}

uint64_t BomSysLog_mknod(uint64_t a1, const char *a2, int a3, int a4)
{
  uint64_t v8 = (*(uint64_t (**)(void))(*(void *)(a1 + 352) + 176LL))(*(void *)(*(void *)(a1 + 352) + 8LL));
  if (*(_BYTE *)(a1 + 368) && *(_BYTE *)(a1 + 396)) {
    fprintf(*(FILE **)(a1 + 360), "mknod(%s, %d, %d) => %d\n", a2, a3, a4, v8);
  }
  return v8;
}

uint64_t BomSysLog_access(uint64_t a1, const char *a2, int a3)
{
  uint64_t v6 = (*(uint64_t (**)(void))(*(void *)(a1 + 352) + 184LL))(*(void *)(*(void *)(a1 + 352) + 8LL));
  if (*(_BYTE *)(a1 + 368) && *(_BYTE *)(a1 + 397)) {
    fprintf(*(FILE **)(a1 + 360), "access(%s, %d) => %d\n", a2, a3, v6);
  }
  return v6;
}

uint64_t BomSysLog_lchown(uint64_t a1, const char *a2, int a3, int a4)
{
  uint64_t v8 = (*(uint64_t (**)(void))(*(void *)(a1 + 352) + 192LL))(*(void *)(*(void *)(a1 + 352) + 8LL));
  if (*(_BYTE *)(a1 + 368) && *(_BYTE *)(a1 + 398)) {
    fprintf(*(FILE **)(a1 + 360), "chown(%s, %d, %d) => %d\n", a2, a3, a4, v8);
  }
  return v8;
}

uint64_t BomSysLog_chmod(uint64_t a1, const char *a2, int a3)
{
  uint64_t v6 = (*(uint64_t (**)(void))(*(void *)(a1 + 352) + 200LL))(*(void *)(*(void *)(a1 + 352) + 8LL));
  if (*(_BYTE *)(a1 + 368) && *(_BYTE *)(a1 + 399)) {
    fprintf(*(FILE **)(a1 + 360), "chmod(%s, %d) => %d\n", a2, a3, v6);
  }
  return v6;
}

uint64_t BomSysLog_chflags(uint64_t a1, const char *a2, int a3)
{
  uint64_t v6 = (*(uint64_t (**)(void))(*(void *)(a1 + 352) + 208LL))(*(void *)(*(void *)(a1 + 352) + 8LL));
  if (*(_BYTE *)(a1 + 368) && *(_BYTE *)(a1 + 400)) {
    fprintf(*(FILE **)(a1 + 360), "chflags(%s, %u) => %d\n", a2, a3, v6);
  }
  return v6;
}

uint64_t BomSysLog_utimes(uint64_t a1, const char *a2)
{
  uint64_t v4 = (*(uint64_t (**)(void))(*(void *)(a1 + 352) + 216LL))(*(void *)(*(void *)(a1 + 352) + 8LL));
  if (*(_BYTE *)(a1 + 368) && *(_BYTE *)(a1 + 401)) {
    fprintf(*(FILE **)(a1 + 360), "utimes(%s) => %d\n", a2, v4);
  }
  return v4;
}

uint64_t BomSysLog_unlink(uint64_t a1, const char *a2)
{
  uint64_t v4 = (*(uint64_t (**)(void))(*(void *)(a1 + 352) + 224LL))(*(void *)(*(void *)(a1 + 352) + 8LL));
  if (*(_BYTE *)(a1 + 368) && *(_BYTE *)(a1 + 402)) {
    fprintf(*(FILE **)(a1 + 360), "unlink(%s) => %d\n", a2, v4);
  }
  return v4;
}

uint64_t BomSysLog_rmdir(uint64_t a1, const char *a2)
{
  uint64_t v4 = (*(uint64_t (**)(void))(*(void *)(a1 + 352) + 232LL))(*(void *)(*(void *)(a1 + 352) + 8LL));
  if (*(_BYTE *)(a1 + 368) && *(_BYTE *)(a1 + 403)) {
    fprintf(*(FILE **)(a1 + 360), "rmdir(%s) => %d\n", a2, v4);
  }
  return v4;
}

uint64_t BomSysLog_link(uint64_t a1, const char *a2, const char *a3)
{
  uint64_t v6 = (*(uint64_t (**)(void))(*(void *)(a1 + 352) + 240LL))(*(void *)(*(void *)(a1 + 352) + 8LL));
  if (*(_BYTE *)(a1 + 368) && *(_BYTE *)(a1 + 404))
  {
    uint64_t v7 = "(null)";
    if (a2) {
      uint64_t v8 = a2;
    }
    else {
      uint64_t v8 = "(null)";
    }
    if (a3) {
      uint64_t v7 = a3;
    }
    fprintf(*(FILE **)(a1 + 360), "link(%s, %s) => %d\n", v8, v7, v6);
  }

  return v6;
}

uint64_t BomSysLog_symlink(uint64_t a1, const char *a2, const char *a3)
{
  uint64_t v6 = (*(uint64_t (**)(void))(*(void *)(a1 + 352) + 248LL))(*(void *)(*(void *)(a1 + 352) + 8LL));
  if (*(_BYTE *)(a1 + 368) && *(_BYTE *)(a1 + 405))
  {
    uint64_t v7 = "(null)";
    if (a2) {
      uint64_t v8 = a2;
    }
    else {
      uint64_t v8 = "(null)";
    }
    if (a3) {
      uint64_t v7 = a3;
    }
    fprintf(*(FILE **)(a1 + 360), "symlink(%s, %s) => %d\n", v8, v7, v6);
  }

  return v6;
}

uint64_t BomSysLog_readlink(uint64_t a1, const char *a2, const void *a3, uint64_t a4)
{
  uint64_t v8 = (*(uint64_t (**)(void))(*(void *)(a1 + 352) + 256LL))(*(void *)(*(void *)(a1 + 352) + 8LL));
  if (*(_BYTE *)(a1 + 368) && *(_BYTE *)(a1 + 406)) {
    fprintf(*(FILE **)(a1 + 360), "readlink(%s, %p, %zu) => %zd\n", a2, a3, a4, v8);
  }
  return v8;
}

uint64_t BomSysLog_rename(uint64_t a1, const char *a2, const char *a3)
{
  uint64_t v6 = (*(uint64_t (**)(void))(*(void *)(a1 + 352) + 264LL))(*(void *)(*(void *)(a1 + 352) + 8LL));
  if (*(_BYTE *)(a1 + 368) && *(_BYTE *)(a1 + 407))
  {
    uint64_t v7 = "(null)";
    if (a2) {
      uint64_t v8 = a2;
    }
    else {
      uint64_t v8 = "(null)";
    }
    if (a3) {
      uint64_t v7 = a3;
    }
    fprintf(*(FILE **)(a1 + 360), "rename(%s, %s) => %d\n", v8, v7, v6);
  }

  return v6;
}

uint64_t BomSysLog_opendir(uint64_t a1, const char *a2)
{
  uint64_t v7 = *MEMORY[0x1895F89C0];
  uint64_t v4 = (*(uint64_t (**)(void))(*(void *)(a1 + 352) + 272LL))(*(void *)(*(void *)(a1 + 352) + 8LL));
  if (*(_BYTE *)(a1 + 368) && *(_BYTE *)(a1 + 408))
  {
    BomSysLog_DIR(v6, v4);
    fprintf(*(FILE **)(a1 + 360), "opendir(%s) => %s\n", a2, v6);
  }

  return v4;
}

uint64_t BomSysLog_closedir(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x1895F89C0];
  if (*(_BYTE *)(a1 + 368) && *(_BYTE *)(a1 + 409)) {
    BomSysLog_DIR(v6, a2);
  }
  uint64_t v4 = (*(uint64_t (**)(void, uint64_t))(*(void *)(a1 + 352) + 280LL))( *(void *)(*(void *)(a1 + 352) + 8LL),  a2);
  if (*(_BYTE *)(a1 + 368) && *(_BYTE *)(a1 + 409)) {
    fprintf(*(FILE **)(a1 + 360), "closedir(%s) => %d\n", v6, v4);
  }
  return v4;
}

uint64_t BomSysLog_readdir(uint64_t a1, uint64_t a2)
{
  uint64_t v8 = *MEMORY[0x1895F89C0];
  uint64_t v4 = (*(uint64_t (**)(void))(*(void *)(a1 + 352) + 288LL))(*(void *)(*(void *)(a1 + 352) + 8LL));
  if (*(_BYTE *)(a1 + 368) && *(_BYTE *)(a1 + 410))
  {
    BomSysLog_DIR(v7, a2);
    BomSysLog_DIRENT(v6, v4);
    fprintf(*(FILE **)(a1 + 360), "readdir(%s) => %s\n", v7, v6);
  }

  return v4;
}

uint64_t BomSysLog_readdir_r(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v14 = *MEMORY[0x1895F89C0];
  uint64_t v8 = (*(uint64_t (**)(void))(*(void *)(a1 + 352) + 296LL))(*(void *)(*(void *)(a1 + 352) + 8LL));
  if (*(_BYTE *)(a1 + 368) && *(_BYTE *)(a1 + 411))
  {
    BomSysLog_DIR(v13, a2);
    BomSysLog_DIRENT(v12, a3);
    if (a4)
    {
      uint64_t v9 = *a4;
      if (*a4 == a3)
      {
        strcpy(v11, "<same>");
LABEL_8:
        fprintf(*(FILE **)(a1 + 360), "readdir_r(%s, %s, %s) => %d\n", v13, v12, v11, v8);
        return v8;
      }
    }

    else
    {
      uint64_t v9 = 0LL;
    }

    BomSysLog_DIRENT(v11, v9);
    goto LABEL_8;
  }

  return v8;
}

uint64_t BomSysLog_getcwd(uint64_t a1, const void *a2, uint64_t a3)
{
  uint64_t v6 = (*(uint64_t (**)(void))(*(void *)(a1 + 352) + 304LL))(*(void *)(*(void *)(a1 + 352) + 8LL));
  if (*(_BYTE *)(a1 + 368) && *(_BYTE *)(a1 + 412))
  {
    uint64_t v7 = "(null)";
    if (v6) {
      uint64_t v7 = (const char *)v6;
    }
    fprintf(*(FILE **)(a1 + 360), "getcwd(%p, %zu) => %s\n", a2, a3, v7);
  }

  return v6;
}

uint64_t BomSysLog_chdir(uint64_t a1, const char *a2)
{
  uint64_t v4 = (*(uint64_t (**)(void))(*(void *)(a1 + 352) + 312LL))(*(void *)(*(void *)(a1 + 352) + 8LL));
  if (*(_BYTE *)(a1 + 368) && *(_BYTE *)(a1 + 413)) {
    fprintf(*(FILE **)(a1 + 360), "chdir(%s) => %d\n", a2, v4);
  }
  return v4;
}

const void *BomSysLog_mmap(uint64_t a1, const void *a2, uint64_t a3, int a4, int a5, int a6, uint64_t a7)
{
  uint64_t v14 = (const void *)(*(uint64_t (**)(void))(*(void *)(a1 + 352) + 320LL))(*(void *)(*(void *)(a1 + 352) + 8LL));
  if (*(_BYTE *)(a1 + 368) && *(_BYTE *)(a1 + 414)) {
    fprintf(*(FILE **)(a1 + 360), "mmap(%p, %zu, %d, %d, %d, %lld) => %p\n", a2, a3, a4, a5, a6, a7, v14);
  }
  return v14;
}

uint64_t BomSysLog_munmap(uint64_t a1, const void *a2, uint64_t a3)
{
  uint64_t v6 = (*(uint64_t (**)(void))(*(void *)(a1 + 352) + 328LL))(*(void *)(*(void *)(a1 + 352) + 8LL));
  if (*(_BYTE *)(a1 + 368) && *(_BYTE *)(a1 + 415)) {
    fprintf(*(FILE **)(a1 + 360), "munmap(%p, %zd) => %d\n", a2, a3, v6);
  }
  return v6;
}

uint64_t BomSysLog_mktemp(uint64_t a1, const char *a2)
{
  uint64_t v4 = (*(uint64_t (**)(void))(*(void *)(a1 + 352) + 336LL))(*(void *)(*(void *)(a1 + 352) + 8LL));
  if (*(_BYTE *)(a1 + 368) && *(_BYTE *)(a1 + 416))
  {
    uint64_t v5 = "(null)";
    if (a2) {
      uint64_t v6 = a2;
    }
    else {
      uint64_t v6 = "(null)";
    }
    if (v4) {
      uint64_t v5 = (const char *)v4;
    }
    fprintf(*(FILE **)(a1 + 360), "mktemp(%s) => %s\n", v6, v5);
  }

  return v4;
}

uint64_t BomSysLog_copyfile(uint64_t a1, const char *a2, const char *a3)
{
  uint64_t v6 = (*(uint64_t (**)(void))(*(void *)(a1 + 352) + 344LL))(*(void *)(*(void *)(a1 + 352) + 8LL));
  if (*(_BYTE *)(a1 + 368) && *(_BYTE *)(a1 + 417)) {
    fprintf(*(FILE **)(a1 + 360), "copyfile(%s, %s)\n", a2, a3);
  }
  return v6;
}

uint64_t BomSysLog_DIR(char *a1, uint64_t a2)
{
  if (a2) {
    return snprintf(a1, 0x40uLL, "%p {%d}");
  }
  else {
    return snprintf(a1, 0x40uLL, "%p");
  }
}

uint64_t BomSysLog_DIRENT(char *a1, uint64_t a2)
{
  if (a2) {
    return snprintf(a1, 0x440uLL, "%p {%llu, %d, %s}");
  }
  else {
    return snprintf(a1, 0x440uLL, "%p");
  }
}

void BOMCopierErrorFree(void *a1)
{
  if (a1)
  {
    uint64_t v2 = (void *)a1[4];
    if (v2) {
      free(v2);
    }
    free(a1);
  }

uint64_t BOMCopierErrorGetFileName(uint64_t result)
{
  if (result) {
    return *(void *)result;
  }
  return result;
}

uint64_t BOMCopierErrorGetLineNumber(uint64_t result)
{
  if (result) {
    return *(unsigned int *)(result + 8);
  }
  return result;
}

uint64_t BOMCopierErrorGetCompilationDate(uint64_t result)
{
  if (result) {
    return *(void *)(result + 16);
  }
  return result;
}

uint64_t BOMCopierErrorGetFunctionName(uint64_t result)
{
  if (result) {
    return *(void *)(result + 24);
  }
  return result;
}

uint64_t BOMCopierErrorGetMessage(uint64_t result)
{
  if (result) {
    return *(void *)(result + 32);
  }
  return result;
}

uint64_t BOMCopierErrorGetCode(uint64_t result)
{
  if (result) {
    return *(unsigned int *)(result + 40);
  }
  return result;
}

void *BOMCopierErrorCapture(void *result, int a2, uint64_t a3, int a4, uint64_t a5, char *a6, ...)
{
  v17[0] = 0LL;
  if (result)
  {
    uint64_t v6 = result;
    if (!*result)
    {
      va_copy((va_list)&v17[1], va);
      if (vasprintf(v17, a6, va) < 0)
      {
        uint64_t v11 = (FILE *)*MEMORY[0x1895F89D0];
        uint64_t v12 = __error();
        uint64_t v13 = strerror(*v12);
        return (void *)fprintf(v11, "Could not create error message: %s\n", v13);
      }

      else
      {
        if (v17[0])
        {
          uint64_t result = calloc(1uLL, 0x30uLL);
          if (result)
          {
            *uint64_t result = a3;
            *((_DWORD *)result + 2) = a4;
            result[2] = "Nov 10 2024";
            result[3] = a5;
            result[4] = v17[0];
            *((_DWORD *)result + 10) = a2;
            void *v6 = result;
            return result;
          }

          uint64_t v14 = (FILE *)*MEMORY[0x1895F89D0];
          unsigned int v15 = "Could not allocate empty _BOMCopierError\n";
          size_t v16 = 41LL;
        }

        else
        {
          uint64_t v14 = (FILE *)*MEMORY[0x1895F89D0];
          unsigned int v15 = "Error message is NULL\n";
          size_t v16 = 22LL;
        }

        return (void *)fwrite(v15, v16, 1uLL, v14);
      }
    }
  }

  return result;
}

uint64_t BOMCopierCopyWithOptions2(uint64_t a1, char *a2, char *a3, const void *a4)
{
  uint64_t v116 = *MEMORY[0x1895F89C0];
  if (!a1) {
    return 22LL;
  }
  uint64_t v8 = (_BYTE *)(a1 + 11616);
  uint64_t v108 = 0LL;
  if ((os_variant_has_internal_content() & 1) != 0)
  {
    getenv("BOMCOPIER_LOGGING");
    goto LABEL_4;
  }

  int v15 = v8[1442];
  size_t v16 = getenv("BOMCOPIER_LOGGING");
  if (v16)
  {
    int v17 = strcmp(v16, "1");
    if (!v15 && v17) {
      goto LABEL_5;
    }
    goto LABEL_4;
  }

  if (v15) {
LABEL_4:
  }
    *(void *)(a1 + 13000) = os_log_create("com.apple.Bom", "BOMCopier");
LABEL_5:
  uint64_t v9 = *(os_log_s **)(a1 + 13000);
  if (v9)
  {
    if (!os_log_type_enabled(*(os_log_t *)(a1 + 13000), OS_LOG_TYPE_DEFAULT)
      || (*(_DWORD *)statfs buf = 136315138,
          *(void *)&uint8_t buf[4] = a2,
          _os_log_impl(&dword_1862F3000, v9, OS_LOG_TYPE_DEFAULT, "fromObj: %s", buf, 0xCu),
          (uint64_t v9 = *(os_log_s **)(a1 + 13000)) != 0LL))
    {
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)statfs buf = 136315138;
        *(void *)&uint8_t buf[4] = a3;
        _os_log_impl(&dword_1862F3000, v9, OS_LOG_TYPE_DEFAULT, "toObj: %s", buf, 0xCu);
      }
    }
  }

  uint64_t v10 = (const __CFAllocator *)*MEMORY[0x189604DB0];
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable( (CFAllocatorRef)*MEMORY[0x189604DB0],  0LL,  MEMORY[0x189605240],  MEMORY[0x189605250]);
  *(void *)(a1 + 13008) = Mutable;
  if (!Mutable)
  {
    BOMCopierErrorCapture( &v108,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c",  720,  (uint64_t)"prepare_copy_state",  "Could not create source options");
    goto LABEL_225;
  }

  CFMutableDictionaryRef v12 = CFDictionaryCreateMutable(v10, 0LL, MEMORY[0x189605240], MEMORY[0x189605250]);
  *(void *)(a1 + 13024) = v12;
  if (!v12)
  {
    BOMCopierErrorCapture( &v108,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c",  727,  (uint64_t)"prepare_copy_state",  "Could not create destination options");
    goto LABEL_225;
  }

  if (!a4) {
    goto LABEL_85;
  }
  CFTypeID TypeID = CFDictionaryGetTypeID();
  if (TypeID != CFGetTypeID(a4))
  {
    BOMCopierErrorCapture( &v108,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c",  735,  (uint64_t)"prepare_copy_state",  "The options dictionary is not a CFDictionary");
    goto LABEL_225;
  }

  if (parse_copier_options(a1, (const __CFDictionary *)a4, &v108))
  {
    BOMCopierErrorCapture( &v108,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c",  742,  (uint64_t)"prepare_copy_state",  "Could not create parse copier options");
LABEL_225:
    uint64_t v14 = 1LL;
    BOMCopierErrorCapture( &v108,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c",  188,  (uint64_t)"BOMCopierCopyWithOptions2",  "Could not parse the client options",  v103);
    goto LABEL_226;
  }

  if (CFDictionaryContainsKey((CFDictionaryRef)a4, @"compressCPIO")
    && *(_DWORD *)(a1 + 12712) != 1
    && *(_DWORD *)(a1 + 12716) != 4)
  {
    BOMCopierErrorCapture( &v108,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c",  3560,  (uint64_t)"verify_copier_options",  "Compression is only used for CPIO archives");
    goto LABEL_224;
  }

  if (CFDictionaryContainsKey((CFDictionaryRef)a4, @"skipCPIOTerminator") && *(_DWORD *)(a1 + 12716) != 4)
  {
    BOMCopierErrorCapture( &v108,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c",  3569,  (uint64_t)"verify_copier_options",  "SkipTerminator is only used for CPIO archives");
    goto LABEL_224;
  }

  if (CFDictionaryContainsKey((CFDictionaryRef)a4, @"skipCPIORoot") && *(_DWORD *)(a1 + 12716) != 4)
  {
    BOMCopierErrorCapture( &v108,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c",  3578,  (uint64_t)"verify_copier_options",  "SkipRoot is only used for CPIO archives");
    goto LABEL_224;
  }

  if (*(_DWORD *)(a1 + 12712) == 2 && *(_DWORD *)(a1 + 12716) != 3)
  {
    BOMCopierErrorCapture( &v108,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c",  3589,  (uint64_t)"verify_copier_options",  "PKZip archives can only be extracted to filesystem destinations");
    goto LABEL_224;
  }

  if (CFDictionaryContainsKey((CFDictionaryRef)a4, @"sequesterResources")
    && *(_DWORD *)(a1 + 12716) != 5
    && *(_DWORD *)(a1 + 12712) != 2)
  {
    BOMCopierErrorCapture( &v108,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c",  3597,  (uint64_t)"verify_copier_options",  "sequesterResources is only for PKZip archives");
    goto LABEL_224;
  }

  if (CFDictionaryContainsKey((CFDictionaryRef)a4, @"keepParent") && *(_DWORD *)(a1 + 12716) == 3)
  {
    BOMCopierErrorCapture( &v108,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c",  3610,  (uint64_t)"verify_copier_options",  "keepParent is only for archives");
    goto LABEL_224;
  }

  int v18 = CFDictionaryContainsKey((CFDictionaryRef)a4, @"inputFD");
  if (a2 && v18)
  {
    BOMCopierErrorCapture( &v108,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c",  3623,  (uint64_t)"verify_copier_options",  "Cannot specify a fromObj with kBOMCopierOptionInputFileDescriptorKey");
    goto LABEL_224;
  }

  int v19 = CFDictionaryContainsKey((CFDictionaryRef)a4, @"outputFD");
  if (a3 && v19)
  {
    BOMCopierErrorCapture( &v108,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c",  3632,  (uint64_t)"verify_copier_options",  "Cannot specify a toObj with kBOMCopierOptionOutputFileDescriptorKey");
    goto LABEL_224;
  }

  if (CFDictionaryContainsKey((CFDictionaryRef)a4, @"inputStream"))
  {
    if (a2 || CFDictionaryContainsKey((CFDictionaryRef)a4, @"inputFD"))
    {
      BOMCopierErrorCapture( &v108,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c",  3645,  (uint64_t)"verify_copier_options",  "Cannot specify fromObj or kBOMCopierOptionInputFileDescriptorKey with kBOMCopierOptionInputCFReadStreamKey");
      goto LABEL_224;
    }

    unint64_t Value = (__CFReadStream *)CFDictionaryGetValue((CFDictionaryRef)a4, @"inputStream");
    for (int i = 30; ; --i)
    {
      CFStreamStatus Status = CFReadStreamGetStatus(Value);
      if (Status != kCFStreamStatusOpening) {
        break;
      }
      if (!i)
      {
        BOMCopierErrorCapture( &v108,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c",  3669,  (uint64_t)"verify_copier_options",  "Timed out waiting for the read stream to open");
        goto LABEL_224;
      }

      *(_OWORD *)statfs buf = xmmword_18635AD90;
      nanosleep((const timespec *)buf, 0LL);
    }

    if (Status != kCFStreamStatusOpen)
    {
      BOMCopierErrorCapture( &v108,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c",  3685,  (uint64_t)"verify_copier_options",  "CFReadStream is not open: %u");
      goto LABEL_224;
    }
  }

  if (CFDictionaryContainsKey((CFDictionaryRef)a4, @"outputStream"))
  {
    if (a3 || CFDictionaryContainsKey((CFDictionaryRef)a4, @"outputFD"))
    {
      BOMCopierErrorCapture( &v108,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c",  3694,  (uint64_t)"verify_copier_options",  "Cannot specify toObj or kBOMCopierOptionOutputFileDescriptorKey with kBOMCopierOptionOutputCFWriteStreamKey");
      goto LABEL_224;
    }

    uint64_t v23 = (__CFWriteStream *)CFDictionaryGetValue((CFDictionaryRef)a4, @"outputStream");
    for (int j = 30; ; --j)
    {
      CFStreamStatus v25 = CFWriteStreamGetStatus(v23);
      if (v25 != kCFStreamStatusOpening) {
        break;
      }
      if (!j)
      {
        BOMCopierErrorCapture( &v108,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c",  3718,  (uint64_t)"verify_copier_options",  "Timed out waiting for the write stream to open");
        goto LABEL_224;
      }

      *(_OWORD *)statfs buf = xmmword_18635AD90;
      nanosleep((const timespec *)buf, 0LL);
    }

    if (v25 != kCFStreamStatusOpen)
    {
      BOMCopierErrorCapture( &v108,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c",  3734,  (uint64_t)"verify_copier_options",  "CFWriteStream is not open: %u");
      goto LABEL_224;
    }
  }

  int v26 = CFDictionaryContainsKey((CFDictionaryRef)a4, @"output2Nowhere");
  if (a3 && v26)
  {
    BOMCopierErrorCapture( &v108,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c",  3743,  (uint64_t)"verify_copier_options",  "Cannot specify a toObj with kBOMCopierOptionOutputNowhereKey");
    goto LABEL_224;
  }

  if (CFDictionaryContainsKey((CFDictionaryRef)a4, @"setStaticContent") && *(_DWORD *)(a1 + 12716) != 3)
  {
    BOMCopierErrorCapture( &v108,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c",  3756,  (uint64_t)"verify_copier_options",  "setStaticContent is only for filesystem destinations");
    goto LABEL_224;
  }

  if (CFDictionaryContainsKey((CFDictionaryRef)a4, @"setSingleWriter") && *(_DWORD *)(a1 + 12716) != 3)
  {
    BOMCopierErrorCapture( &v108,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c",  3765,  (uint64_t)"verify_copier_options",  "setSingleWriter is only for filesystem destinations");
    goto LABEL_224;
  }

  if (CFDictionaryContainsKey((CFDictionaryRef)a4, @"applyProvenance"))
  {
    if (*(_DWORD *)(a1 + 12712))
    {
      if (*(_DWORD *)(a1 + 12716) == 3) {
        goto LABEL_82;
      }
      BOMCopierErrorCapture( &v108,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c",  3780,  (uint64_t)"verify_copier_options",  "applyProvenance is only applicable when extracting from archives");
    }

    else
    {
      BOMCopierErrorCapture( &v108,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c",  3774,  (uint64_t)"verify_copier_options",  "applyProvenance is only for extracting from archives");
    }

LABEL_224:
    BOMCopierErrorCapture( &v108,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c",  749,  (uint64_t)"prepare_copy_state",  "Could not verify copier options");
    goto LABEL_225;
  }

LABEL_82:
  int v27 = *(os_log_s **)(a1 + 13000);
  if (v27 && os_log_type_enabled(*(os_log_t *)(a1 + 13000), OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)statfs buf = 138412290;
    *(void *)&uint8_t buf[4] = a4;
    _os_log_impl(&dword_1862F3000, v27, OS_LOG_TYPE_DEFAULT, "options: %@", buf, 0xCu);
  }

LABEL_274:
      uint64_t v14 = 2LL;
      goto LABEL_227;
    }

    if (v53 && os_log_type_enabled(*(os_log_t *)(a1 + 13000), OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t v109 = 0;
      _os_log_impl(&dword_1862F3000, v53, OS_LOG_TYPE_DEFAULT, "Retrieving the next source entry", v109, 2u);
    }

    uint64_t v54 = BOMCopierSourceNext(*(void *)(a1 + 13016), &v108, v44, v45, v46, v47, v48, v49);
    uint64_t v55 = (unsigned int *)v54;
    if (v108)
    {
      if (v54) {
        BOMCopierSourceEntryFree((unsigned int *)v54);
      }
      uint64_t v14 = 1LL;
      BOMCopierErrorCapture( &v108,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c",  249,  (uint64_t)"BOMCopierCopyWithOptions2",  "Could not copy from %s to %s: %s",  a2);
      goto LABEL_226;
    }

    if (!v54) {
      break;
    }
    unsigned int Type = BOMCopierSourceEntryGetType((uint64_t)v54);
    if (Type == 6)
    {
      __int16 Mode = BOMCopierSourceEntryGetMode((uint64_t)v55);
      if ((Mode & 0x80) == 0) {
        BOMCopierSourceEntrySetMode((uint64_t)v55, Mode | 0x80);
      }
      goto LABEL_163;
    }

    if (Type == 8)
    {
      uint64_t Path = (const char *)BOMCopierSourceEntryGetPath((uint64_t)v55);
      __int16 v107 = 0LL;
      asprintf(&v107, "%s/%s", a2, Path);
      uint64_t v90 = v107;
      if (!v107)
      {
        int v93 = *__error();
        uint64_t v94 = __error();
        uint64_t v105 = strerror(*v94);
        BOMCopierErrorCapture( &v108,  v93,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c",  358,  (uint64_t)"BOMCopierCopyWithOptions2",  "Could not create error path: %s",  v105);
        goto LABEL_208;
      }

      v8[1443] = 1;
      uint64_t v91 = __error();
      int v92 = notify_file_error(a1, (uint64_t)v90, *v91);
      free(v107);
      if (v92 != 1)
      {
LABEL_214:
        BOMCopierSourceEntryFree(v55);
        release_copy_state_0(a1);
        uint64_t v14 = 2LL;
        int v61 = 1;
        goto LABEL_215;
      }

      unint64_t v60 = *(os_log_s **)(a1 + 13000);
      if (!v60 || !os_log_type_enabled(*(os_log_t *)(a1 + 13000), OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_158;
      }
LABEL_157:
      *(_DWORD *)uint64_t v109 = 136315138;
      uint64_t v110 = Path;
      _os_log_impl(&dword_1862F3000, v60, OS_LOG_TYPE_DEFAULT, "Skipping %s", v109, 0xCu);
LABEL_158:
      BOMCopierSourceEntryFree(v55);
      int v61 = 2;
LABEL_215:
      if (v61 != 2) {
        return v14;
      }
    }

    else
    {
      if (Type <= 2)
      {
        uint64_t Path = (const char *)BOMCopierSourceEntryGetPath((uint64_t)v55);
        __int16 v107 = 0LL;
        asprintf(&v107, "%s/%s", a2, Path);
        uint64_t v58 = v107;
        if (v107)
        {
          v8[1443] = 1;
          int v59 = notify_file_error(a1, (uint64_t)v58, 13LL);
          free(v107);
          if (v59 != 1) {
            goto LABEL_214;
          }
          unint64_t v60 = *(os_log_s **)(a1 + 13000);
          if (!v60 || !os_log_type_enabled(*(os_log_t *)(a1 + 13000), OS_LOG_TYPE_DEFAULT)) {
            goto LABEL_158;
          }
          goto LABEL_157;
        }

        int v88 = *__error();
        int v89 = __error();
        uint64_t v104 = strerror(*v89);
        BOMCopierErrorCapture( &v108,  v88,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c",  290,  (uint64_t)"BOMCopierCopyWithOptions2",  "Could not create error path: %s",  v104);
LABEL_208:
        int v61 = 1;
        uint64_t v14 = 1LL;
        goto LABEL_215;
      }

LABEL_163:
      *uint64_t v8 = 0;
      v8[1025] = 0;
      if (!*(void *)(a1 + 88)) {
        goto LABEL_169;
      }
      uint64_t v63 = BOMCopierSourceEntryGetPath((uint64_t)v55);
      int v64 = BOMCopierSourceEntryGetType((uint64_t)v55);
      uint64_t Size = BOMCopierSourceEntryGetSize((uint64_t)v55);
      else {
        uint64_t v66 = dword_18635B598[v64 - 5];
      }
      int v67 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(a1 + 88))(a1, v63, v66, Size);
      if (v67 == 1)
      {
        uint64_t v85 = *(os_log_s **)(a1 + 13000);
        if (v85 && os_log_type_enabled(*(os_log_t *)(a1 + 13000), OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)uint64_t v109 = 0;
          _os_log_impl(&dword_1862F3000, v85, OS_LOG_TYPE_DEFAULT, "Client skipped source entry", v109, 2u);
        }

        BOMCopierSourceEntryFree(v55);
      }

      else
      {
        if (v67 == 2)
        {
          uint64_t v99 = *(os_log_s **)(a1 + 13000);
          if (v99 && os_log_type_enabled(*(os_log_t *)(a1 + 13000), OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)uint64_t v109 = 0;
            uint64_t v100 = "Client cancelled";
LABEL_272:
            _os_log_impl(&dword_1862F3000, v99, OS_LOG_TYPE_DEFAULT, v100, v109, 2u);
          }

LABEL_273:
          BOMCopierSourceEntryFree(v55);
          goto LABEL_274;
        }

LABEL_258:
  uint64_t v102 = *(os_log_s **)(a1 + 13000);
  if (v8[1443])
  {
    if (v102 && os_log_type_enabled(*(os_log_t *)(a1 + 13000), OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t v109 = 0;
      _os_log_impl(&dword_1862F3000, v102, OS_LOG_TYPE_DEFAULT, "Copy complete but a file error occurred", v109, 2u);
    }

    uint64_t v14 = 1LL;
  }

  else
  {
    if (v102)
    {
      uint64_t v14 = 0LL;
      if (!os_log_type_enabled(*(os_log_t *)(a1 + 13000), OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_227;
      }
      *(_WORD *)uint64_t v109 = 0;
      _os_log_impl(&dword_1862F3000, v102, OS_LOG_TYPE_DEFAULT, "Copy successful", v109, 2u);
    }

    uint64_t v14 = 0LL;
  }

LABEL_227:
  release_copy_state_0(a1);
  return v14;
}

void notify_fatal_error(uint64_t a1, void *a2)
{
  uint64_t v10 = *MEMORY[0x1895F89C0];
  if (a2)
  {
    uint64_t Message = BOMCopierErrorGetMessage((uint64_t)a2);
    if (Message)
    {
      uint64_t v5 = Message;
      uint64_t v6 = *(void (**)(uint64_t, uint64_t))(a1 + 56);
      if (v6) {
        v6(a1, Message);
      }
      uint64_t v7 = *(os_log_s **)(a1 + 13000);
      if (v7)
      {
        if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
        {
          int v8 = 136315138;
          uint64_t v9 = v5;
          _os_log_impl(&dword_1862F3000, v7, OS_LOG_TYPE_DEFAULT, "fatal error: %s", (uint8_t *)&v8, 0xCu);
        }
      }
    }

    BOMCopierErrorFree(a2);
  }

void release_copy_state_0(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 13048);
  if (v2)
  {
    BOMBomFree(v2);
    *(void *)(a1 + 13048) = 0LL;
  }

  uint64_t v3 = *(void *)(a1 + 13040);
  if (v3)
  {
    BOMBomFree(v3);
    *(void *)(a1 + 13040) = 0LL;
  }

  uint64_t v4 = *(unsigned int **)(a1 + 13032);
  if (v4)
  {
    BOMCopierDestinationFree(v4);
    *(void *)(a1 + 13032) = 0LL;
  }

  uint64_t v5 = *(const void **)(a1 + 13024);
  if (v5)
  {
    CFRelease(v5);
    *(void *)(a1 + 13024) = 0LL;
  }

  uint64_t v6 = *(void **)(a1 + 13016);
  if (v6)
  {
    BOMCopierSourceFree(v6);
    *(void *)(a1 + 13016) = 0LL;
  }

  uint64_t v7 = *(const void **)(a1 + 13008);
  if (v7)
  {
    CFRelease(v7);
    *(void *)(a1 + 13008) = 0LL;
  }

  *(_BYTE *)(a1 + 13059) = 0;
}

uint64_t notify_file_error(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v20 = *MEMORY[0x1895F89C0];
  if (!a1) {
    return 1LL;
  }
  int v3 = a3;
  uint64_t v6 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1 + 72);
  if (v6)
  {
    unsigned int v7 = v6(a1, a2, a3);
    if (v7 == 1) {
      unsigned int v8 = 0;
    }
    else {
      unsigned int v8 = v7;
    }
    if (v7) {
      uint64_t v9 = v8;
    }
    else {
      uint64_t v9 = 1LL;
    }
  }

  else
  {
    uint64_t v9 = 1LL;
  }

  uint64_t v10 = *(os_log_s **)(a1 + 13000);
  if (v10 && os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
  {
    int v12 = 136315906;
    uint64_t v13 = a2;
    __int16 v14 = 1024;
    int v15 = v3;
    __int16 v16 = 2080;
    int v17 = strerror(v3);
    __int16 v18 = 1024;
    int v19 = v9;
    _os_log_impl(&dword_1862F3000, v10, OS_LOG_TYPE_DEFAULT, "file error: %s %d (%s) [%u]", (uint8_t *)&v12, 0x22u);
  }

  return v9;
}

void source_redirection_callback(uint64_t a1, char **a2, uint64_t a3)
{
  if (a3)
  {
    uint64_t v4 = strdup((const char *)(a3 + 11617));
    if (v4) {
      *a2 = v4;
    }
  }

void destination_redirection_callback(uint64_t a1, char **a2, uint64_t a3)
{
  if (a3)
  {
    uint64_t v4 = strdup((const char *)(a3 + 10592));
    if (v4) {
      *a2 = v4;
    }
  }

void notify_fatal_file_error(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v18 = *MEMORY[0x1895F89C0];
  if (a3)
  {
    Actualuint64_t Path = BOMCopierSourceEntryGetActualPath(a2);
    uint64_t Code = BOMCopierErrorGetCode((uint64_t)a3);
    uint64_t Message = BOMCopierErrorGetMessage((uint64_t)a3);
    unsigned int v8 = *(void (**)(uint64_t, uint64_t, uint64_t))(a1 + 64);
    if (v8) {
      v8(a1, ActualPath, Code);
    }
    uint64_t v9 = *(os_log_s **)(a1 + 13000);
    if (v9)
    {
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
      {
        int v10 = 136315906;
        uint64_t v11 = ActualPath;
        __int16 v12 = 1024;
        int v13 = Code;
        __int16 v14 = 2080;
        int v15 = strerror(Code);
        __int16 v16 = 2080;
        uint64_t v17 = Message;
        _os_log_impl( &dword_1862F3000,  v9,  OS_LOG_TYPE_DEFAULT,  "fatal file error: %s %d (%s) [%s]",  (uint8_t *)&v10,  0x26u);
      }
    }

    BOMCopierErrorFree(a3);
  }

uint64_t parse_copier_options(uint64_t a1, const __CFDictionary *a2, void *a3)
{
  uint64_t v218 = *MEMORY[0x1895F89C0];
  CFTypeID TypeID = CFBooleanGetTypeID();
  CFTypeID v7 = CFStringGetTypeID();
  CFTypeID v216 = CFDictionaryGetTypeID();
  CFTypeID v8 = CFNumberGetTypeID();
  CFTypeID v9 = CFWriteStreamGetTypeID();
  CFTypeID v10 = CFReadStreamGetTypeID();
  CFTypeID v215 = CFArrayGetTypeID();
  CFTypeID v11 = CFDataGetTypeID();
  *(void *)(a1 + 12712) = 0x300000000LL;
  unint64_t Value = CFDictionaryGetValue(a2, @"inputFD");
  if (Value)
  {
    int v13 = Value;
    if (v8 != CFGetTypeID(Value))
    {
      uint64_t v24 = 22LL;
      BOMCopierErrorCapture( a3,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c",  972,  (uint64_t)"parse_copier_options",  "kBOMCopierOptionInputFileDescriptorKey must be a CFNumberRef");
      return v24;
    }

    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13008), @"inputFD", v13);
  }

  __int16 v14 = CFDictionaryGetValue(a2, @"zipFileEncryptionKey");
  if (v14)
  {
    int v15 = v14;
    if (v7 != CFGetTypeID(v14))
    {
      uint64_t v24 = 22LL;
      BOMCopierErrorCapture( a3,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c",  1005,  (uint64_t)"parse_copier_options",  "kBOMCopierOptionEncryptionKey must be a CFStringRef");
      return v24;
    }

    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13008), @"passphrase", v15);
  }

  CFTypeID v214 = v11;
  __int16 v16 = CFDictionaryGetValue(a2, @"extractCPIO");
  if (v16)
  {
    uint64_t v17 = v16;
    if (TypeID != CFGetTypeID(v16))
    {
      uint64_t v24 = 22LL;
      BOMCopierErrorCapture( a3,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c",  1063,  (uint64_t)"parse_copier_options",  "kBOMCopierOptionExtractCPIOKey must be a CFBooleanRef");
      return v24;
    }

    uint64_t v18 = (const void *)*MEMORY[0x189604DE8];
    if (CFEqual(v17, (CFTypeRef)*MEMORY[0x189604DE8]) == 1)
    {
      *(_DWORD *)(a1 + 12712) = 1;
      CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13008), @"extractLibarchive", v18);
      CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13008), @"replaySymlinks", v18);
      CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13008), @"replayDirectories", v18);
    }
  }

  int v19 = CFDictionaryGetValue(a2, @"createCPIO");
  if (v19)
  {
    uint64_t v20 = v19;
    if (TypeID != CFGetTypeID(v19))
    {
      uint64_t v24 = 22LL;
      BOMCopierErrorCapture( a3,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c",  1125,  (uint64_t)"parse_copier_options",  "kBOMCopierOptionCreateCPIOKey must be a CFBooleanRef");
      return v24;
    }

    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13024), @"createArchive", v20);
    if (CFEqual(v20, (CFTypeRef)*MEMORY[0x189604DE8]) == 1) {
      *(_DWORD *)(a1 + 12716) = 4;
    }
  }

  int v21 = CFDictionaryGetValue(a2, @"compressCPIO");
  if (v21)
  {
    __int16 v22 = v21;
    if (TypeID == CFGetTypeID(v21))
    {
      if (CFEqual(v22, (CFTypeRef)*MEMORY[0x189604DE8]) != 1 || *(_DWORD *)(a1 + 12716) != 4) {
        goto LABEL_34;
      }
      *(_DWORD *)unsigned int valuePtr = 1;
      CFNumberRef v23 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x189604DB0], kCFNumberIntType, valuePtr);
      if (!v23)
      {
        uint64_t v24 = 1LL;
        BOMCopierErrorCapture( a3,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c",  1184,  (uint64_t)"parse_copier_options",  "Could not create CFNumber from %d");
        return v24;
      }

      goto LABEL_33;
    }

    if (v7 != CFGetTypeID(v22))
    {
      uint64_t v24 = 22LL;
      BOMCopierErrorCapture( a3,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c",  1227,  (uint64_t)"parse_copier_options",  "kBOMCopierOptionCompressCPIOKey must be a CFBooleanRef or CFStringRef");
      return v24;
    }

    if (CFEqual(v22, @"auto")) {
      goto LABEL_27;
    }
    if (CFEqual(v22, @"none"))
    {
      *(_DWORD *)unsigned int valuePtr = 0;
LABEL_32:
      CFNumberRef v23 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x189604DB0], kCFNumberIntType, valuePtr);
      if (!v23)
      {
        uint64_t v24 = 1LL;
        BOMCopierErrorCapture( a3,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c",  1219,  (uint64_t)"parse_copier_options",  "Could not create CFNumber from %d");
        return v24;
      }

LABEL_33:
      CFNumberRef v26 = v23;
      CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13024), @"libarchiveFilter", v23);
      CFRelease(v26);
      goto LABEL_34;
    }

    if (CFEqual(v22, @"gzip"))
    {
LABEL_27:
      int v25 = 1;
    }

    else
    {
      if (!CFEqual(v22, @"bzip2"))
      {
        uint64_t v24 = 22LL;
        BOMCopierErrorCapture( a3,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c",  1212,  (uint64_t)"parse_copier_options",  "Unknown compression type");
        return v24;
      }

      int v25 = 2;
    }

    *(_DWORD *)unsigned int valuePtr = v25;
    goto LABEL_32;
  }

LABEL_122:
  if (v210) {
    CFDictionarySetValue( *(CFMutableDictionaryRef *)(a1 + 13008),  @"discoverResourceAttribute",  (const void *)*MEMORY[0x189604DE8]);
  }
  if (HIDWORD(v209)) {
    CFDictionarySetValue( *(CFMutableDictionaryRef *)(a1 + 13008),  @"discoverExtendedAttributes",  (const void *)*MEMORY[0x189604DE8]);
  }
  if (DWORD2(v209)) {
    CFDictionarySetValue( *(CFMutableDictionaryRef *)(a1 + 13008),  @"discoverACLs",  (const void *)*MEMORY[0x189604DE8]);
  }
  if (DWORD1(v209)) {
    CFDictionarySetValue( *(CFMutableDictionaryRef *)(a1 + 13008),  @"synthesizeAppleDoubles",  (const void *)*MEMORY[0x189604DE8]);
  }
  if ((_DWORD)v209) {
    CFDictionarySetValue( *(CFMutableDictionaryRef *)(a1 + 13008),  @"appleDoublesCaptureResourceAttributes",  (const void *)*MEMORY[0x189604DE8]);
  }
  if (HIDWORD(v208)) {
    CFDictionarySetValue( *(CFMutableDictionaryRef *)(a1 + 13008),  @"appleDoublesCaptureExtendedAttributes",  (const void *)*MEMORY[0x189604DE8]);
  }
  if ((_DWORD)v208) {
    CFDictionarySetValue( *(CFMutableDictionaryRef *)(a1 + 13008),  @"appleDoublesCaptureACLs",  (const void *)*MEMORY[0x189604DE8]);
  }
  if (HIDWORD(v207)) {
    CFDictionarySetValue( *(CFMutableDictionaryRef *)(a1 + 13008),  @"deferAppleDoubles",  (const void *)*MEMORY[0x189604DE8]);
  }
  if ((_DWORD)v207) {
    CFDictionarySetValue( *(CFMutableDictionaryRef *)(a1 + 13008),  @"replayAppleDoubles",  (const void *)*MEMORY[0x189604DE8]);
  }
  if (HIDWORD(v206)) {
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13008), @"appleDoubleSuffix", @"__");
  }
  if (DWORD2(v206)) {
    CFDictionarySetValue( *(CFMutableDictionaryRef *)(a1 + 13024),  @"appleDoubleMergeACLs",  (const void *)*MEMORY[0x189604DE8]);
  }
  if (DWORD1(v206)) {
    CFDictionarySetValue( *(CFMutableDictionaryRef *)(a1 + 13008),  @"ignoreAppleDoubles",  (const void *)*MEMORY[0x189604DE8]);
  }
  if ((_DWORD)v206) {
    CFDictionarySetValue( *(CFMutableDictionaryRef *)(a1 + 13008),  @"sequesterAppleDoubles",  (const void *)*MEMORY[0x189604DE8]);
  }
  if ((_DWORD)v54) {
    CFDictionarySetValue( *(CFMutableDictionaryRef *)(a1 + 13008),  @"unsequesterAppleDoubles",  (const void *)*MEMORY[0x189604DE8]);
  }
  if (HIDWORD(v205)) {
    CFDictionarySetValue( *(CFMutableDictionaryRef *)(a1 + 13008),  @"reorderExtraEntries",  (const void *)*MEMORY[0x189604DE8]);
  }
  if ((_DWORD)v205) {
    CFDictionarySetValue( *(CFMutableDictionaryRef *)(a1 + 13008),  @"replayExtraAppleDoubles",  (const void *)*MEMORY[0x189604DE8]);
  }
  int v59 = CFDictionaryGetValue(a2, @"copyQuarantine");
  if (v59)
  {
    unint64_t v60 = v59;
    if (TypeID != CFGetTypeID(v59))
    {
      uint64_t v24 = 22LL;
      BOMCopierErrorCapture( a3,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c",  2048,  (uint64_t)"parse_copier_options",  "kBOMCopierOptionCopyQuarantineKey must be a CFBooleanRef");
      return v24;
    }

    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13008), @"discoverQuarantine", v60);
  }

  int v61 = CFDictionaryGetValue(a2, @"quarantineFilePath");
  if (v61)
  {
    uint64_t v62 = v61;
    if (v7 != CFGetTypeID(v61))
    {
      uint64_t v24 = 22LL;
      BOMCopierErrorCapture( a3,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c",  2089,  (uint64_t)"parse_copier_options",  "kBOMCopierOptionCopyQuarantineKey must be a CFStringRef");
      return v24;
    }

    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13008), @"replayQuarantineFromPath", v62);
  }

  uint64_t v63 = CFDictionaryGetValue(a2, @"useHFSPlusCompression");
  if (v63)
  {
    int v64 = v63;
    if (TypeID != CFGetTypeID(v63))
    {
      uint64_t v24 = 22LL;
      BOMCopierErrorCapture( a3,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c",  2121,  (uint64_t)"parse_copier_options",  "kBOMCopierOptionUseHFSPlusCompressionKey must be a CFBooleanRef");
      return v24;
    }

    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13024), @"useAppleFSCompression", v64);
  }

  uint64_t v65 = CFDictionaryGetValue(a2, @"preserveHFSPlusCompression");
  if (v65)
  {
    uint64_t v66 = v65;
    if (TypeID != CFGetTypeID(v65))
    {
      uint64_t v24 = 22LL;
      BOMCopierErrorCapture( a3,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c",  2152,  (uint64_t)"parse_copier_options",  "kBOMCopierOptionPreserveHFSPlusCompressionKey must be a CFBooleanRef");
      return v24;
    }

    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13008), @"discoverCompressionAttributes", v66);
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13024), @"preserveAppleFSCompression", v66);
  }

  int v67 = (const __CFDictionary *)CFDictionaryGetValue(a2, @"hfsPlusCompressionOptions");
  if (v67)
  {
    unsigned int v68 = v67;
    if (v216 != CFGetTypeID(v67))
    {
      uint64_t v24 = 22LL;
      BOMCopierErrorCapture( a3,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c",  2185,  (uint64_t)"parse_copier_options",  "kBOMCopierOptionPreserveHFSPlusCompressionKey must be a CFBooleanRef");
      return v24;
    }

    uint64_t v69 = CFDictionaryGetValue(v68, @"CompressionTypes");
    if (v69)
    {
      uint64_t v70 = v69;
      if (v8 != CFGetTypeID(v69))
      {
        uint64_t v24 = 22LL;
        BOMCopierErrorCapture( a3,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c",  2206,  (uint64_t)"parse_copier_options",  "CompressionTypes must be a CFNumberRef");
        return v24;
      }

      CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13024), @"AppleFSCompressionType", v70);
    }
  }

  uint64_t v71 = (const __CFString *)CFDictionaryGetValue(a2, @"indexbom");
  if (v71)
  {
    uint64_t v72 = v71;
    if (v7 != CFGetTypeID(v71))
    {
      uint64_t v24 = 22LL;
      BOMCopierErrorCapture( a3,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c",  2252,  (uint64_t)"parse_copier_options",  "kBOMCopierOptionIndexBomKey must be a CFStringRef");
      return v24;
    }

    CFIndex v73 = CFStringGetLength(v72) + 1;
    buffera = (char *)calloc(1uLL, v73);
    if (!buffera)
    {
      int v127 = *__error();
      BOMCopierErrorCapture( a3,  v127,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c",  2267,  (uint64_t)"parse_copier_options",  "Could not allocate %ld bytes for kBOMCopierOptionIndexBomKey");
      return 1LL;
    }

    if (!CFStringGetCString(v72, buffera, v73, 0x8000100u))
    {
      uint64_t v24 = 1LL;
      BOMCopierErrorCapture( a3,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c",  2274,  (uint64_t)"parse_copier_options",  "Could not convert kBOMCopierOptionIndexBomKey to UTF8 C string");
      goto LABEL_331;
    }

    uint64_t v74 = BOMBomOpenWithSys(buffera, 0, 0LL);
    *(void *)(a1 + 13040) = v74;
    if (!v74)
    {
      unsigned int v139 = buffera;
      uint64_t v24 = 1LL;
      BOMCopierErrorCapture( a3,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c",  2282,  (uint64_t)"parse_copier_options",  "Could not open allow bom at %s");
LABEL_347:
      uint64_t v142 = v139;
      goto LABEL_348;
    }

    free(buffera);
  }

  uint64_t v75 = (const __CFString *)CFDictionaryGetValue(a2, @"skipbom");
  if (v75)
  {
    uint64_t v76 = v75;
    if (v7 != CFGetTypeID(v75))
    {
      uint64_t v24 = 22LL;
      BOMCopierErrorCapture( a3,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c",  2319,  (uint64_t)"parse_copier_options",  "kBOMCopierOptionSkipBomKey must be a CFStringRef");
      return v24;
    }

    CFIndex v77 = CFStringGetLength(v76) + 1;
    buffera = (char *)calloc(1uLL, v77);
    if (buffera)
    {
      if (CFStringGetCString(v76, buffera, v77, 0x8000100u))
      {
        uint64_t v78 = BOMBomOpenWithSys(buffera, 0, 0LL);
        *(void *)(a1 + 13048) = v78;
        if (v78)
        {
          free(buffera);
          goto LABEL_183;
        }

        unsigned int v139 = buffera;
        uint64_t v24 = 1LL;
        BOMCopierErrorCapture( a3,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c",  2349,  (uint64_t)"parse_copier_options",  "Could not open deny bom at %s");
        goto LABEL_347;
      }

      uint64_t v24 = 1LL;
      BOMCopierErrorCapture( a3,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c",  2341,  (uint64_t)"parse_copier_options",  "Could not convert kBOMCopierOptionIndexBomKey to UTF8 C string");
LABEL_331:
      uint64_t v142 = buffera;
LABEL_348:
      free(v142);
      return v24;
    }

    int v136 = *__error();
    BOMCopierErrorCapture( a3,  v136,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c",  2334,  (uint64_t)"parse_copier_options",  "Could not allocate %ld bytes for kBOMCopierOptionIndexBomKey");
    return 1LL;
  }

LABEL_183:
  uint64_t v79 = (BOOL *)(a1 + 13056);
  uint64_t v80 = CFDictionaryGetValue(a2, @"verifyFileDataPerIndexBom");
  if (v80)
  {
    uint64_t v81 = v80;
    if (TypeID != CFGetTypeID(v80))
    {
      uint64_t v24 = 22LL;
      BOMCopierErrorCapture( a3,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c",  2381,  (uint64_t)"parse_copier_options",  "kBOMCopierOptionVerifyFileDataPerIndexBomKey must be a CFStringRef");
      return v24;
    }

    *(_BYTE *)(a1 + 13057) = CFEqual(v81, (CFTypeRef)*MEMORY[0x189604DE8]) != 0;
  }

  int v82 = CFDictionaryGetValue(a2, @"outputFD");
  if (v82)
  {
    AAFieldKey v83 = v82;
    if (v8 != CFGetTypeID(v82))
    {
      uint64_t v24 = 22LL;
      BOMCopierErrorCapture( a3,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c",  2416,  (uint64_t)"parse_copier_options",  "kBOMCopierOptionOutputFileDescriptorKey must be a CFNumberRef");
      return v24;
    }

    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13024), @"outputFD", v83);
  }

  uint64_t v84 = CFDictionaryGetValue(a2, @"outputStream");
  if (v84)
  {
    uint64_t v85 = v84;
    if (v9 != CFGetTypeID(v84))
    {
      uint64_t v24 = 22LL;
      BOMCopierErrorCapture( a3,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c",  2446,  (uint64_t)"parse_copier_options",  "kBOMCopierOptionOutputCFWriteStreamKey must be a CFWriteStream");
      return v24;
    }

    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13024), @"outputStream", v85);
  }

  uint64_t v86 = CFDictionaryGetValue(a2, @"inputStream");
  if (v86)
  {
    uint64_t v87 = v86;
    if (v10 != CFGetTypeID(v86))
    {
      uint64_t v24 = 22LL;
      BOMCopierErrorCapture( a3,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c",  2477,  (uint64_t)"parse_copier_options",  "kBOMCopierOptionInputCFReadStreamKey must be a CFReadStream");
      return v24;
    }

    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13008), @"inputStream", v87);
  }

  int v88 = (const __CFArray *)CFDictionaryGetValue(a2, @"archs");
  if (v88)
  {
    int v89 = v88;
    if (v215 != CFGetTypeID(v88))
    {
      uint64_t v24 = 22LL;
      BOMCopierErrorCapture( a3,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c",  2552,  (uint64_t)"parse_copier_options",  "kBOMCopierOptionArchitectureArrayKey must be a CFArrayRef");
      return v24;
    }

    if (!CFArrayGetCount(v89))
    {
      uint64_t v24 = 22LL;
      BOMCopierErrorCapture( a3,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c",  2560,  (uint64_t)"parse_copier_options",  "kBOMCopierOptionArchitectureArrayKey is empty");
      return v24;
    }

    CFDictionarySetValue( *(CFMutableDictionaryRef *)(a1 + 13008),  @"discoverBinaries",  (const void *)*MEMORY[0x189604DE8]);
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13024), @"archs", v89);
  }

  uint64_t v90 = CFDictionaryGetValue(a2, @"fallbackForSubtype");
  if (v90)
  {
    uint64_t v91 = v90;
    if (v216 != CFGetTypeID(v90))
    {
      uint64_t v24 = 22LL;
      BOMCopierErrorCapture( a3,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c",  2599,  (uint64_t)"parse_copier_options",  "kBOMCopierOptionArchitectureFallbackKey must be a CFDictionaryRef");
      return v24;
    }

    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13024), @"fallbackForSubtype", v91);
  }

  int v92 = CFDictionaryGetValue(a2, @"keepBinaries");
  if (v92)
  {
    int v93 = v92;
    if (TypeID != CFGetTypeID(v92))
    {
      uint64_t v24 = 22LL;
      BOMCopierErrorCapture( a3,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c",  2638,  (uint64_t)"parse_copier_options",  "kBOMCopierOptionKeepBinariesKey must be a CFBooleanRef");
      return v24;
    }

    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13008), @"discoverBinaries", v93);
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13024), @"keepBinaries", v93);
  }

  uint64_t v94 = CFDictionaryGetValue(a2, @"keepBinariesList");
  if (v94)
  {
    uint64_t v95 = v94;
    if (v7 != CFGetTypeID(v94))
    {
      uint64_t v24 = 22LL;
      BOMCopierErrorCapture( a3,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c",  2670,  (uint64_t)"parse_copier_options",  "kBOMCopierOptionKeepBinariesListKey must be a CFStringRef");
      return v24;
    }

    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13024), @"keptFileList", v95);
  }

  uint64_t v96 = CFDictionaryGetValue(a2, @"keepBinariesPattern");
  if (v96)
  {
    int v97 = v96;
    if (v7 != CFGetTypeID(v96))
    {
      uint64_t v24 = 22LL;
      BOMCopierErrorCapture( a3,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c",  2701,  (uint64_t)"parse_copier_options",  "kBOMCopierOptionKeepBinariesPatternKey must be a CFStringRef");
      return v24;
    }

    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13024), @"keepFilePattern", v97);
  }

  __int16 v98 = CFDictionaryGetValue(a2, @"keepBinariesDir");
  if (v98)
  {
    uint64_t v99 = v98;
    if (v7 != CFGetTypeID(v98))
    {
      uint64_t v24 = 22LL;
      BOMCopierErrorCapture( a3,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c",  2721,  (uint64_t)"parse_copier_options",  "kBOMCopierOptionKeepBinariesDirKey must be a CFStringRef");
      return v24;
    }

    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13024), @"keptFileDirectory", v99);
    CFDictionarySetValue( *(CFMutableDictionaryRef *)(a1 + 13024),  @"balanceKeptFiles",  (const void *)*MEMORY[0x189604DE8]);
    *(_DWORD *)unsigned int valuePtr = 50;
    CFNumberRef v100 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x189604DB0], kCFNumberIntType, valuePtr);
    if (!v100)
    {
      uint64_t v24 = 1LL;
      BOMCopierErrorCapture( a3,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c",  2734,  (uint64_t)"parse_copier_options",  "Could not create CFNumber from %d");
      return v24;
    }

    CFNumberRef v101 = v100;
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13024), @"keptFileBalanceLimit", v100);
    CFRelease(v101);
  }

  uint64_t v102 = CFDictionaryGetValue(a2, @"keepParent");
  if (v102)
  {
    uint64_t v103 = v102;
    if (TypeID != CFGetTypeID(v102))
    {
      uint64_t v24 = 22LL;
      BOMCopierErrorCapture( a3,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c",  2787,  (uint64_t)"parse_copier_options",  "kBOMCopierOptionKeepParentKey must be a CFBooleanRef");
      return v24;
    }

    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13008), @"keepParent", v103);
  }

  uint64_t v104 = CFDictionaryGetValue(a2, @"zlibCompressionLevel");
  if (v104)
  {
    uint64_t v105 = v104;
    if (v8 != CFGetTypeID(v104))
    {
      uint64_t v24 = 22LL;
      BOMCopierErrorCapture( a3,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c",  2822,  (uint64_t)"parse_copier_options",  "kBOMCopierOptionZlibCompressionLevel must be a CFNumberRef");
      return v24;
    }

    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13024), @"zlibCompressionLevel", v105);
  }

  uint64_t v106 = CFDictionaryGetValue(a2, @"compress");
  if (v106)
  {
    __int16 v107 = v106;
    if (v7 != CFGetTypeID(v106))
    {
      uint64_t v24 = 22LL;
      BOMCopierErrorCapture( a3,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c",  2851,  (uint64_t)"parse_copier_options",  "kBOMCopierOptionCompressDeprecatedKey must be a CFStringRef");
      return v24;
    }

    *(_DWORD *)unsigned int valuePtr = 1;
    if (CFEqual(v107, @"none") == 1)
    {
      *(_DWORD *)unsigned int valuePtr = 0;
    }

    else
    {
      if (CFEqual(v107, @"auto") == 1 || CFEqual(v107, @"gzip") == 1)
      {
        int v153 = 1;
      }

      else
      {
        if (CFEqual(v107, @"bzip2") != 1)
        {
          uint64_t v24 = 22LL;
          BOMCopierErrorCapture( a3,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c",  2871,  (uint64_t)"parse_copier_options",  "Unknown deprecated compression option");
          return v24;
        }

        int v153 = 2;
      }

      *(_DWORD *)unsigned int valuePtr = v153;
    }

    CFNumberRef v154 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x189604DB0], kCFNumberIntType, valuePtr);
    if (!v154)
    {
      uint64_t v24 = 1LL;
      BOMCopierErrorCapture( a3,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c",  2878,  (uint64_t)"parse_copier_options",  "Could not create CFNumber from %d");
      return v24;
    }

    CFNumberRef v155 = v154;
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13024), @"libarchiveFilter", v154);
    CFRelease(v155);
  }

  AAArchiveStream v156 = CFDictionaryGetValue(a2, @"symlinkTreatment");
  if (v156)
  {
    int v157 = v156;
    if (v7 != CFGetTypeID(v156))
    {
      uint64_t v24 = 22LL;
      BOMCopierErrorCapture( a3,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c",  2925,  (uint64_t)"parse_copier_options",  "kBOMCopierOptionSymlinkTreatmentKey must be a CFStringRef");
      return v24;
    }

    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13024), @"symlinkTreatment", v157);
  }

  uint64_t v158 = CFDictionaryGetValue(a2, @"enforceDestinationEncapsulation");
  if (v158)
  {
    int64_t v159 = v158;
    if (TypeID != CFGetTypeID(v158))
    {
      uint64_t v24 = 22LL;
      BOMCopierErrorCapture( a3,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c",  2964,  (uint64_t)"parse_copier_options",  "kBOMCopierOptionEnforceDestinationEncapsulationKey must be a CFBooleanRef");
      return v24;
    }

    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13024), @"enforceDestinationEncapsulation", v159);
  }

  uint64_t v160 = CFDictionaryGetValue(a2, @"enforceDestinationLocation");
  if (v160)
  {
    uint64_t v161 = v160;
    if (TypeID != CFGetTypeID(v160))
    {
      uint64_t v24 = 22LL;
      BOMCopierErrorCapture( a3,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c",  2988,  (uint64_t)"parse_copier_options",  "kBOMCopierOptionEnforceDestinationLocationKey must be a CFBooleanRef");
      return v24;
    }

    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13024), @"enforceDestinationLocation", v161);
  }

  BOOL v162 = CFDictionaryGetValue(a2, @"nonatomicCopy");
  if (v162)
  {
    uint64_t v163 = v162;
    if (TypeID != CFGetTypeID(v162))
    {
      uint64_t v24 = 22LL;
      BOMCopierErrorCapture( a3,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c",  3037,  (uint64_t)"parse_copier_options",  "kBOMCopierOptionNonAtomicCopyKey must be a CFBooleanRef");
      return v24;
    }

    uint64_t v164 = (const void *)*MEMORY[0x189604DE8];
    if (CFEqual(v163, (CFTypeRef)*MEMORY[0x189604DE8]) == 1)
    {
      CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13008), @"replaySymlinks", v164);
      CFDictionarySetValue( *(CFMutableDictionaryRef *)(a1 + 13024),  @"enableAtomicCopies",  (const void *)*MEMORY[0x189604DE0]);
    }
  }

  uint64_t v165 = CFDictionaryGetValue(a2, @"applyIndexBomOwnership");
  if (v165)
  {
    uint64_t v166 = v165;
    if (TypeID != CFGetTypeID(v165))
    {
      uint64_t v24 = 22LL;
      BOMCopierErrorCapture( a3,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c",  3076,  (uint64_t)"parse_copier_options",  "kBOMCopierOptionApplyIndexBomOwnershipKey must be a CFBooleanRef");
      return v24;
    }

    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13008), @"applyBomOwnership", v166);
    if (*(void *)(a1 + 13040))
    {
      CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13008), @"useEnumerationBom", v166);
      CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13008), @"allowAccessFailures", v166);
      *uint64_t v79 = CFEqual(v166, (CFTypeRef)*MEMORY[0x189604DE8]) != 0;
    }
  }

  uint64_t v167 = CFDictionaryGetValue(a2, @"sourceIsAppSandboxed");
  if (v167)
  {
    uint64_t v168 = v167;
    if (TypeID != CFGetTypeID(v167))
    {
      uint64_t v24 = 22LL;
      BOMCopierErrorCapture( a3,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c",  3124,  (uint64_t)"parse_copier_options",  "kBOMCopierOptionSourceIsAppSandboxed must be a CFBooleanRef");
      return v24;
    }

    if (*(void *)(a1 + 13040))
    {
      CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13008), @"useEnumerationBom", v168);
      CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13008), @"allowAccessFailures", v168);
      *uint64_t v79 = CFEqual(v168, (CFTypeRef)*MEMORY[0x189604DE8]) != 0;
    }
  }

  uint64_t v169 = CFDictionaryGetValue(a2, @"persistRestrictedFlags");
  if (v169)
  {
    uint64_t v170 = v169;
    if (TypeID != CFGetTypeID(v169))
    {
      uint64_t v24 = 22LL;
      BOMCopierErrorCapture( a3,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c",  3169,  (uint64_t)"parse_copier_options",  "kBOMCopierOptionPersistRestrictedFlagsKey must be a CFBooleanRef");
      return v24;
    }

    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13024), @"persistRestrictedFlags", v170);
  }

  uint64_t v171 = CFDictionaryGetValue(a2, @"preserveRestrictedFlags");
  if (v171)
  {
    int v172 = v171;
    if (TypeID != CFGetTypeID(v171))
    {
      uint64_t v24 = 22LL;
      BOMCopierErrorCapture( a3,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c",  3200,  (uint64_t)"parse_copier_options",  "kBOMCopierOptionPreserveRestrictedFlagsKey must be a CFBooleanRef");
      return v24;
    }

    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13024), @"preserveRestrictedFlags", v172);
  }

  uint64_t v173 = CFDictionaryGetValue(a2, @"persistRootlessEAs");
  if (v173)
  {
    uint64_t v174 = v173;
    if (TypeID != CFGetTypeID(v173))
    {
      uint64_t v24 = 22LL;
      BOMCopierErrorCapture( a3,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c",  3233,  (uint64_t)"parse_copier_options",  "kBOMCopierOptionPersistRootlessExtendedAttributesKey must be a CFBooleanRef");
      return v24;
    }

    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13024), @"persistRootless", v174);
  }

  size_t v175 = CFDictionaryGetValue(a2, @"initialCPIOInode");
  if (v175)
  {
    stat v176 = v175;
    if (v8 != CFGetTypeID(v175))
    {
      uint64_t v24 = 22LL;
      BOMCopierErrorCapture( a3,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c",  3266,  (uint64_t)"parse_copier_options",  "kBOMCopierOptionInitialCPIOInodeRootKey must be a CFNumberRef");
      return v24;
    }

    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13024), @"initialInode", v176);
  }

  char v177 = CFDictionaryGetValue(a2, @"skipCPIORoot");
  if (v177)
  {
    uint64_t v178 = v177;
    if (TypeID != CFGetTypeID(v177))
    {
      uint64_t v24 = 22LL;
      BOMCopierErrorCapture( a3,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c",  3298,  (uint64_t)"parse_copier_options",  "kBOMCopierOptionSkipCPIORootKey must be a CFBooleanRef");
      return v24;
    }

    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13008), @"skipRootDirectory", v178);
  }

  uint64_t v179 = CFDictionaryGetValue(a2, @"skipCPIOTerminator");
  if (v179)
  {
    uint64_t v180 = v179;
    if (TypeID != CFGetTypeID(v179))
    {
      uint64_t v24 = 22LL;
      BOMCopierErrorCapture( a3,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c",  3326,  (uint64_t)"parse_copier_options",  "kBOMCopierOptionSkipCPIOTerminatorKey must be a CFBooleanRef");
      return v24;
    }

    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13024), @"skipTerminator", v180);
  }

  uint64_t v181 = CFDictionaryGetValue(a2, @"segmentLargeFiles");
  if (v181)
  {
    uint64_t v182 = v181;
    if (TypeID != CFGetTypeID(v181))
    {
      uint64_t v24 = 22LL;
      BOMCopierErrorCapture( a3,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c",  3364,  (uint64_t)"parse_copier_options",  "kBOMCopierOptionSegmentLargeFilesKey must be a CFBooleanRef");
      return v24;
    }

    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13008), @"discoverSegmentedFiles", v182);
    if (CFEqual(v182, (CFTypeRef)*MEMORY[0x189604DE8]) == 1)
    {
      *(void *)unsigned int valuePtr = 0x40000000LL;
      CFNumberRef v183 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x189604DB0], kCFNumberLongLongType, valuePtr);
      if (!v183)
      {
        BOMCopierErrorCapture( a3,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c",  3377,  (uint64_t)"parse_copier_options",  "Could not create number for %lld",  *(void *)valuePtr);
        return 22LL;
      }

      CFNumberRef v184 = v183;
      CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13024), @"segmentFileSize", v183);
      CFRelease(v184);
    }
  }

  __int128 v185 = CFDictionaryGetValue(a2, @"enableLogging");
  if (v185)
  {
    __int128 v186 = v185;
    if (TypeID != CFGetTypeID(v185))
    {
      uint64_t v24 = 22LL;
      BOMCopierErrorCapture( a3,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c",  3391,  (uint64_t)"parse_copier_options",  "kBOMCopierOptionEnableLogging must be a CFBooleanRef");
      return v24;
    }

    *(_BYTE *)(a1 + 13058) = CFEqual((CFTypeRef)*MEMORY[0x189604DE8], v186) != 0;
  }

  uint64_t v187 = CFDictionaryGetValue(a2, @"output2Nowhere");
  if (v187)
  {
    __int128 v188 = v187;
    if (TypeID != CFGetTypeID(v187))
    {
      uint64_t v24 = 22LL;
      BOMCopierErrorCapture( a3,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c",  3403,  (uint64_t)"parse_copier_options",  "kBOMCopierOptionOutputNowhereKey must be a CFBooleanRef");
      return v24;
    }

    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13024), @"output2Nowhere", v188);
  }

  __int128 v189 = CFDictionaryGetValue(a2, @"cloneFiles");
  if (v189)
  {
    __int128 v190 = v189;
    if (TypeID != CFGetTypeID(v189))
    {
      uint64_t v24 = 22LL;
      BOMCopierErrorCapture( a3,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c",  3415,  (uint64_t)"parse_copier_options",  "kBOMCopierOptionCloneFiles must be a CFBooleanRef");
      return v24;
    }

    if (CFEqual(v190, (CFTypeRef)*MEMORY[0x189604DE8]) == 1)
    {
      if (*(_DWORD *)(a1 + 12712))
      {
        uint64_t v24 = 22LL;
        BOMCopierErrorCapture( a3,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c",  3423,  (uint64_t)"parse_copier_options",  "kBOMCopierOptionCloneFiles requires the source to be a filesystem");
        return v24;
      }

      if (*(_DWORD *)(a1 + 12716) != 3)
      {
        uint64_t v24 = 22LL;
        BOMCopierErrorCapture( a3,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c",  3429,  (uint64_t)"parse_copier_options",  "kBOMCopierOptionCloneFiles requires the destination to be a filesystem");
        return v24;
      }

      CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13024), @"cloneFiles", v190);
    }
  }

  uint64_t v191 = CFDictionaryGetValue(a2, @"removeSetuidPermissions");
  if (v191)
  {
    uint64_t v192 = v191;
    if (TypeID != CFGetTypeID(v191))
    {
      uint64_t v24 = 22LL;
      BOMCopierErrorCapture( a3,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c",  3442,  (uint64_t)"parse_copier_options",  "kBOMCopierOptionRemoveSetuidPermissionsKey must be a CFBooleanRef");
      return v24;
    }

    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13024), @"removeSetuidPermissions", v192);
  }

  uint64_t v193 = CFDictionaryGetValue(a2, @"removeExecutablePermissions");
  if (v193)
  {
    uint64_t v194 = v193;
    if (TypeID != CFGetTypeID(v193))
    {
      uint64_t v24 = 22LL;
      BOMCopierErrorCapture( a3,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c",  3454,  (uint64_t)"parse_copier_options",  "kBOMCopierOptionRemoveSetuidPermissionsKey must be a CFBooleanRef");
      return v24;
    }

    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13024), @"removeExecutablePermissions", v194);
  }

  uint64_t v195 = CFDictionaryGetValue(a2, @"setStaticContent");
  if (v195)
  {
    uint64_t v196 = v195;
    if (TypeID != CFGetTypeID(v195))
    {
      uint64_t v24 = 22LL;
      BOMCopierErrorCapture( a3,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c",  3466,  (uint64_t)"parse_copier_options",  "kBOMCopierOptionSetStaticContentKey must be a CFBooleanRef");
      return v24;
    }

    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13024), @"setStaticContent", v196);
  }

  char v197 = CFDictionaryGetValue(a2, @"setSingleWriter");
  if (v197)
  {
    uint64_t v198 = v197;
    if (TypeID != CFGetTypeID(v197))
    {
      uint64_t v24 = 22LL;
      BOMCopierErrorCapture( a3,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c",  3478,  (uint64_t)"parse_copier_options",  "kBOMCopierOptionSetSingleWriterKey must be a CFBooleanRef");
      return v24;
    }

    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13024), @"setSingleWriter", v198);
  }

  v199 = CFDictionaryGetValue(a2, @"setDataProtectionClass");
  if (v199)
  {
    int v200 = v199;
    if (v7 != CFGetTypeID(v199))
    {
      uint64_t v24 = 22LL;
      BOMCopierErrorCapture( a3,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c",  3490,  (uint64_t)"parse_copier_options",  "kBOMCopierOptionSetDataProtectionClassKey must be a CFStringRef");
      return v24;
    }

    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13024), @"setDataProtectionClass", v200);
  }

  v201 = (const __CFData *)CFDictionaryGetValue(a2, @"applyProvenance");
  if (v201)
  {
    uint64_t v202 = v201;
    if (v214 != CFGetTypeID(v201))
    {
      uint64_t v24 = 22LL;
      BOMCopierErrorCapture( a3,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c",  3502,  (uint64_t)"parse_copier_options",  "kBOMCopierOptionApplyProvenanceKey must be a CFDataRef");
      return v24;
    }

    if (!CFDataGetLength(v202))
    {
      uint64_t v24 = 22LL;
      BOMCopierErrorCapture( a3,  22,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c",  3510,  (uint64_t)"parse_copier_options",  "kBOMCopierOptionApplyProvenanceKey has an invalid size");
      return v24;
    }

    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13024), @"applyProvenance", v202);
  }

  return 0LL;
}

uint64_t source_error_handler(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v18 = *MEMORY[0x1895F89C0];
  *(_BYTE *)(a2 + 13059) = 1;
  uint64_t v5 = notify_file_error(a2, *(void *)(a3 + 8), *(unsigned int *)(a3 + 16));
  uint64_t v6 = *(os_log_s **)(a2 + 13000);
  if (v6 && os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v7 = *(void *)(a3 + 8);
    int v8 = *(_DWORD *)(a3 + 16);
    int v10 = 136315906;
    uint64_t v11 = v7;
    __int16 v12 = 1024;
    int v13 = v8;
    __int16 v14 = 2080;
    int v15 = strerror(v8);
    __int16 v16 = 1024;
    int v17 = v5;
    _os_log_impl(&dword_1862F3000, v6, OS_LOG_TYPE_DEFAULT, "file error: %s %d (%s) [%d]", (uint8_t *)&v10, 0x22u);
  }

  return v5;
}

uint64_t passphrase_callback(int a1, uint64_t a2, void *a3)
{
  uint64_t result = *(void *)(a2 + 12800);
  if (!result)
  {
    uint64_t v5 = *(unsigned int (**)(uint64_t, const char *, uint64_t))(a2 + 128);
    if (!v5)
    {
      BOMCopierErrorCapture( a3,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c",  3847,  (uint64_t)"passphrase_callback",  "Client did not register password request callback");
      return 0LL;
    }

    uint64_t v6 = a2 + 12800;
    if (v5(a2, "", a2 + 12800))
    {
      BOMCopierErrorCapture( a3,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c",  3856,  (uint64_t)"passphrase_callback",  "Could not request password from client");
      return 0LL;
    }

    return *(void *)v6;
  }

  return result;
}

uint64_t conflict_resolver(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void *a5)
{
  if (a4 && *(void *)(a4 + 80))
  {
    int Type = BOMCopierSourceEntryGetType(a2);
    int v9 = BOMCopierDestinationEntryGetType(a3, a5);
    else {
      uint64_t v10 = dword_18635B598[Type - 5];
    }
    else {
      uint64_t v11 = dword_18635B598[v9 - 5];
    }
    uint64_t Path = BOMCopierDestinationEntryGetPath(a3, a5);
    if (Path) {
      return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(a4 + 80))(a4, Path, v10, v11);
    }
    BOMCopierErrorCapture( a5,  1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c",  4056,  (uint64_t)"conflict_resolver",  "Could not get destination path");
  }

  return 2LL;
}

void data_written_callback(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a4)
  {
    if (*(void *)(a4 + 104))
    {
      uint64_t Path = BOMCopierSourceEntryGetPath(a2);
      uint64_t TotalWritten = BOMCopierDestinationEntryGetTotalWritten(a3, 0LL);
      (*(void (**)(uint64_t, uint64_t, uint64_t))(a4 + 104))(a4, Path, TotalWritten);
    }
  }

void finalization_callback(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  if (a5 && *(void *)(a5 + 96))
  {
    uint64_t Path = BOMCopierSourceEntryGetPath(a2);
    unsigned int v10 = BOMCopierSourceEntryGetType(a2) - 5;
    if (v10 > 5) {
      uint64_t v11 = 0LL;
    }
    else {
      uint64_t v11 = dword_18635B598[v10];
    }
    uint64_t TotalWritten = BOMCopierDestinationEntryGetTotalWritten(a3, 0LL);
    (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(a5 + 96))(a5, Path, v11, TotalWritten, a4);
  }

void BOMCopierSandbox_boxup(uint64_t a1, const char *a2, uint64_t a3)
{
  if (a1)
  {
    if (a2)
    {
      if (a3)
      {
        uint64_t v6 = BOM_malloczero(0x400uLL);
        if (v6)
        {
          uint64_t v7 = v6;
          uint64_t v8 = (*(uint64_t (**)(void, const char *, void *))(*(void *)(a1 + 12832) + 160LL))( *(void *)(*(void *)(a1 + 12832) + 8LL),  a2,  v6);
          if (v8)
          {
            int v9 = (const char *)v8;
            unsigned int v10 = BOM_malloczero(0x100uLL);
            if (v10)
            {
              uint64_t v11 = v10;
              __int16 v12 = v10 + 8;
              BomSys_clone(v10 + 8, *(const void **)(a1 + 12832), (uint64_t)v10);
              BomSys_set_opendir(v11[8], (DIR *(*)(int, char *))BOMCopierSandbox_opendir);
              BomSys_set_closedir(v11[8], (uint64_t (*)(int, DIR *))BOMCopierSandbox_closedir);
              BomSys_set_readdir(v11[8], (dirent *(*)(int, DIR *))BOMCopierSandbox_readdir);
              BomSys_set_readdir_r( v11[8],  (uint64_t (*)(int, DIR *, dirent *, dirent **))BOMCopierSandbox_readdir_r);
              uint64_t v13 = *(void *)(a1 + 12832);
              *(_OWORD *)(v11 + 1) = *(_OWORD *)(v13 + 272);
              *(_OWORD *)(v11 + 3) = *(_OWORD *)(v13 + 288);
              v11[9] = v7;
              v11[10] = strlen(v9);
              v11[14] = v11;
              v11[28] = a3;
              v11[29] = BOMBomGetRootFSObject(a3);
              __int16 v14 = BOMStackNew();
              v11[31] = v14;
              if (v14)
              {
                *uint64_t v11 = a1;
                v11[5] = *(void *)(a1 + 12832);
                *(void *)(a1 + 12840) = v11;
                uint64_t v15 = v11[6];
                if (!v15) {
                  uint64_t v15 = *v12;
                }
                *(void *)(a1 + 12832) = v15;
              }
            }

            else
            {
              free(v7);
            }
          }

          else
          {
            __int16 v16 = (FILE *)*MEMORY[0x1895F89D0];
            int v17 = __error();
            uint64_t v18 = strerror(*v17);
            fprintf(v16, "Cannot get the real path for %s: %s", a2, v18);
          }
        }
      }
    }
  }

unsigned int *BOMCopierSandbox_opendir(uint64_t a1, char *__s)
{
  uint64_t v11 = *MEMORY[0x1895F89C0];
  if (strlen(__s) <= *(void *)(a1 + 80) || strncmp(__s, *(const char **)(a1 + 72), *(void *)(a1 + 80))) {
    return (unsigned int *)(*(uint64_t (**)(void, char *))(a1 + 8))( *(void *)(*(void *)(a1 + 64) + 8LL),  __s);
  }
  __strlcpy_chk();
  size_t v5 = strlen(__sa) - 1;
  if (__sa[v5] == 47) {
    __sa[v5] = 0;
  }
  uint64_t FSObjectAtPath = (unsigned int *)BOMBomGetFSObjectAtPath(*(void *)(a1 + 224), __sa);
  uint64_t v7 = FSObjectAtPath;
  if (!FSObjectAtPath)
  {
    fprintf((FILE *)*MEMORY[0x1895F89D0], "Could not lookup %s in sandbox bom\n", __sa);
    return v7;
  }

  if (BOMFSObjectType(FSObjectAtPath) != 2)
  {
    fprintf((FILE *)*MEMORY[0x1895F89D0], "%s is not a directory in the sandbox bom\n", __sa);
    goto LABEL_13;
  }

  uint64_t v8 = BOMBomEnumeratorNewWithOptions(*(void *)(a1 + 224), v7, 5);
  BOMFSObjectFree((uint64_t)v7);
  if (!v8) {
    return 0LL;
  }
  int v9 = BOM_malloczero(0x90uLL);
  if (!v9)
  {
LABEL_13:
    BOMFSObjectFree((uint64_t)v7);
    return 0LL;
  }

  *int v9 = v8;
  uint64_t v7 = (unsigned int *)(v9 + 1);
  BOMStackPush(*(char **)(a1 + 248), (uint64_t)v9);
  return v7;
}

uint64_t BOMCopierSandbox_closedir(uint64_t a1, void **a2)
{
  uint64_t v4 = (void **)BOMStackPeek(*(void **)(a1 + 248));
  if (v4 + 1 != a2) {
    return (*(uint64_t (**)(void, void **))(a1 + 16))(*(void *)(*(void *)(a1 + 64) + 8LL), a2);
  }
  uint64_t v6 = v4;
  BOMStackPop(*(uint64_t **)(a1 + 248));
  BOMBomEnumeratorFree(*v6);
  free(v6);
  return 0LL;
}

uint64_t BOMCopierSandbox_readdir(uint64_t a1, void *a2)
{
  if (BOMStackPeek(*(void **)(a1 + 248)) + 1 == a2) {
    return 0LL;
  }
  else {
    return (*(uint64_t (**)(void, void *))(a1 + 24))(*(void *)(*(void *)(a1 + 64) + 8LL), a2);
  }
}

uint64_t BOMCopierSandbox_readdir_r(uint64_t a1, uint64_t *a2, uint64_t a3, void *a4)
{
  uint64_t v8 = BOMStackPeek(*(void **)(a1 + 248));
  if (v8 + 1 != a2) {
    return (*(uint64_t (**)(void, uint64_t *, uint64_t, void *))(a1 + 32))( *(void *)(*(void *)(a1 + 64) + 8LL),  a2,  a3,  a4);
  }
  unsigned int v10 = BOMBomEnumeratorNext(*v8);
  if (v10)
  {
    uint64_t v11 = (uint64_t)v10;
    bzero((void *)a3, 0x418uLL);
    __int16 v12 = (const char *)BOMFSObjectShortName(v11);
    uint64_t v13 = strcpy((char *)(a3 + 21), v12);
    *(_WORD *)(a3 + 18) = strlen(v13);
    *a4 = a3;
    BOMFSObjectFree(v11);
  }

  else
  {
    *a4 = 0LL;
  }

  return 0LL;
}

void BOMCopierSandbox_unbox(uint64_t a1)
{
  if (a1)
  {
    uint64_t v2 = *(void **)(a1 + 12840);
    if (v2)
    {
      int v3 = BOMStackPop(*((uint64_t **)v2 + 31));
      if (v3)
      {
        uint64_t v4 = v3;
        do
        {
          BOMBomEnumeratorFree((void *)*v4);
          *((_OWORD *)v4 + 7) = 0u;
          *((_OWORD *)v4 + 8) = 0u;
          *((_OWORD *)v4 + 5) = 0u;
          *((_OWORD *)v4 + 6) = 0u;
          *((_OWORD *)v4 + 3) = 0u;
          *((_OWORD *)v4 + 4) = 0u;
          *((_OWORD *)v4 + 1) = 0u;
          *((_OWORD *)v4 + 2) = 0u;
          *(_OWORD *)uint64_t v4 = 0u;
          free(v4);
          uint64_t v4 = BOMStackPop(*((uint64_t **)v2 + 31));
        }

        while (v4);
      }

      BOMStackFree(*((void ***)v2 + 31));
      *(void *)(a1 + 12832) = *((void *)v2 + 5);
      *(void *)(a1 + 12840) = 0LL;
      *((void *)v2 + 5) = 0LL;
      *(void *)uint64_t v2 = 0LL;
      size_t v5 = (void *)*((void *)v2 + 30);
      if (v5)
      {
        BOMBomEnumeratorFree(v5);
        *((void *)v2 + 30) = 0LL;
      }

      uint64_t v6 = (void *)*((void *)v2 + 9);
      if (v6)
      {
        free(v6);
        *((void *)v2 + 9) = 0LL;
      }

      uint64_t v7 = *((void *)v2 + 29);
      if (v7)
      {
        BOMFSObjectFree(v7);
        *((void *)v2 + 29) = 0LL;
      }

      uint64_t v8 = (void **)*((void *)v2 + 6);
      if (v8)
      {
        BomSys_log_detach(v8);
        *((void *)v2 + 6) = 0LL;
      }

      int v9 = (void *)*((void *)v2 + 8);
      if (v9) {
        BomSys_free(v9);
      }
      free(v2);
    }
  }

void _BOMFreeListAllocate_cold_1()
{
}

void _BOMFreeListAllocate_cold_2(uint64_t a1)
{
}

void _BOMFreeListAllocate_cold_3(uint64_t a1)
{
}

void _BOMFreeListAllocate_cold_4(uint64_t a1)
{
}

int AAArchiveStreamClose(AAArchiveStream s)
{
  return MEMORY[0x189613058](s);
}

int AAArchiveStreamReadBlob(AAArchiveStream s, AAFieldKey key, void *buf, size_t nbyte)
{
  return MEMORY[0x189613068](s, *(void *)key.skey, buf, nbyte);
}

int AAArchiveStreamReadHeader(AAArchiveStream s, AAHeader *header)
{
  return MEMORY[0x189613070](s, header);
}

int AAArchiveStreamWriteBlob(AAArchiveStream s, AAFieldKey key, const void *buf, size_t nbyte)
{
  return MEMORY[0x189613078](s, *(void *)key.skey, buf, nbyte);
}

int AAArchiveStreamWriteHeader(AAArchiveStream s, AAHeader header)
{
  return MEMORY[0x189613080](s, header);
}

int AAByteStreamClose(AAByteStream s)
{
  return MEMORY[0x1896130A0](s);
}

AAByteStream AACompressionOutputStreamOpen( AAByteStream compressed_stream, AACompressionAlgorithm compression_algorithm, size_t block_size, AAFlagSet flags, int n_threads)
{
  return (AAByteStream)MEMORY[0x189613100]( compressed_stream,  *(void *)&compression_algorithm,  block_size,  flags,  *(void *)&n_threads);
}

AAByteStream AACustomByteStreamOpen(void)
{
  return (AAByteStream)MEMORY[0x189613150]();
}

void AACustomByteStreamSetCloseProc(AAByteStream s, AAByteStreamCloseProc proc)
{
}

void AACustomByteStreamSetData(AAByteStream s, void *data)
{
}

void AACustomByteStreamSetReadProc(AAByteStream s, AAByteStreamReadProc proc)
{
}

void AACustomByteStreamSetWriteProc(AAByteStream s, AAByteStreamWriteProc proc)
{
}

AAArchiveStream AADecodeArchiveInputStreamOpen( AAByteStream stream, void *msg_data, AAEntryMessageProc msg_proc, AAFlagSet flags, int n_threads)
{
  return (AAArchiveStream)MEMORY[0x1896131C0](stream, msg_data, msg_proc, flags, *(void *)&n_threads);
}

AAByteStream AADecompressionInputStreamOpen(AAByteStream compressed_stream, AAFlagSet flags, int n_threads)
{
  return (AAByteStream)MEMORY[0x1896131C8](compressed_stream, flags, *(void *)&n_threads);
}

AAArchiveStream AAEncodeArchiveOutputStreamOpen( AAByteStream stream, void *msg_data, AAEntryMessageProc msg_proc, AAFlagSet flags, int n_threads)
{
  return (AAArchiveStream)MEMORY[0x1896131D8](stream, msg_data, msg_proc, flags, *(void *)&n_threads);
}

int AAEntryACLBlobApplyToPath(AAEntryACLBlob acl, const char *dir, const char *path, AAFlagSet flags)
{
  return MEMORY[0x1896131E0](acl, dir, path, flags);
}

int AAEntryACLBlobClear(AAEntryACLBlob acl)
{
  return MEMORY[0x1896131E8](acl);
}

AAEntryACLBlob AAEntryACLBlobCreateWithEncodedData(const uint8_t *data, size_t data_size)
{
  return (AAEntryACLBlob)MEMORY[0x1896131F0](data, data_size);
}

AAEntryACLBlob AAEntryACLBlobCreateWithPath(const char *dir, const char *path, AAFlagSet flags)
{
  return (AAEntryACLBlob)MEMORY[0x1896131F8](dir, path, flags);
}

void AAEntryACLBlobDestroy(AAEntryACLBlob acl)
{
}

const uint8_t *__cdecl AAEntryACLBlobGetEncodedData(AAEntryACLBlob acl)
{
  return (const uint8_t *)MEMORY[0x189613208](acl);
}

size_t AAEntryACLBlobGetEncodedSize(AAEntryACLBlob acl)
{
  return MEMORY[0x189613210](acl);
}

int AAEntryXATBlobAppendEntry(AAEntryXATBlob xat, const char *key, const uint8_t *data, size_t data_size)
{
  return MEMORY[0x189613218](xat, key, data, data_size);
}

int AAEntryXATBlobClear(AAEntryXATBlob xat)
{
  return MEMORY[0x189613228](xat);
}

AAEntryXATBlob AAEntryXATBlobCreate(void)
{
  return (AAEntryXATBlob)MEMORY[0x189613230]();
}

AAEntryXATBlob AAEntryXATBlobCreateWithEncodedData(const uint8_t *data, size_t data_size)
{
  return (AAEntryXATBlob)MEMORY[0x189613238](data, data_size);
}

void AAEntryXATBlobDestroy(AAEntryXATBlob xat)
{
}

const uint8_t *__cdecl AAEntryXATBlobGetEncodedData(AAEntryXATBlob xat)
{
  return (const uint8_t *)MEMORY[0x189613250](xat);
}

size_t AAEntryXATBlobGetEncodedSize(AAEntryXATBlob xat)
{
  return MEMORY[0x189613258](xat);
}

int AAEntryXATBlobGetEntry( AAEntryXATBlob xat, uint32_t i, size_t key_capacity, char *key, size_t *key_length, size_t data_capacity, uint8_t *data, size_t *data_size)
{
  return MEMORY[0x189613260](xat, *(void *)&i, key_capacity, key, key_length, data_capacity, data, data_size);
}

uint32_t AAEntryXATBlobGetEntryCount(AAEntryXATBlob xat)
{
  return MEMORY[0x189613268](xat);
}

AAByteStream AAFileStreamOpenWithFD(int fd, int automatic_close)
{
  return (AAByteStream)MEMORY[0x1896132F0](*(void *)&fd, *(void *)&automatic_close);
}

AAByteStream AAFileStreamOpenWithPath(const char *path, int open_flags, mode_t open_mode)
{
  return (AAByteStream)MEMORY[0x189613300](path, *(void *)&open_flags, open_mode);
}

AAHeader AAHeaderCreate(void)
{
  return (AAHeader)MEMORY[0x189613320]();
}

void AAHeaderDestroy(AAHeader header)
{
}

int AAHeaderGetFieldBlob(AAHeader header, uint32_t i, uint64_t *size, uint64_t *offset)
{
  return MEMORY[0x189613350](header, *(void *)&i, size, offset);
}

uint32_t AAHeaderGetFieldCount(AAHeader header)
{
  return MEMORY[0x189613358](header);
}

AAFieldKey AAHeaderGetFieldKey(AAHeader header, uint32_t i)
{
  return (AAFieldKey)MEMORY[0x189613368](header, *(void *)&i);
}

int AAHeaderGetFieldString(AAHeader header, uint32_t i, size_t capacity, char *value, size_t *length)
{
  return MEMORY[0x189613370](header, *(void *)&i, capacity, value, length);
}

int AAHeaderGetFieldTimespec(AAHeader header, uint32_t i, timespec *value)
{
  return MEMORY[0x189613378](header, *(void *)&i, value);
}

int AAHeaderGetFieldType(AAHeader header, uint32_t i)
{
  return MEMORY[0x189613380](header, *(void *)&i);
}

int AAHeaderGetFieldUInt(AAHeader header, uint32_t i, uint64_t *value)
{
  return MEMORY[0x189613388](header, *(void *)&i, value);
}

int AAHeaderGetKeyIndex(AAHeader header, AAFieldKey key)
{
  return MEMORY[0x189613390](header, *(void *)key.skey);
}

int AAHeaderSetFieldBlob(AAHeader header, uint32_t i, AAFieldKey key, uint64_t size)
{
  return MEMORY[0x1896133A0](header, *(void *)&i, *(void *)key.skey, size);
}

int AAHeaderSetFieldString(AAHeader header, uint32_t i, AAFieldKey key, const char *value, size_t length)
{
  return MEMORY[0x1896133B8](header, *(void *)&i, *(void *)key.skey, value, length);
}

int AAHeaderSetFieldTimespec(AAHeader header, uint32_t i, AAFieldKey key, const timespec *value)
{
  return MEMORY[0x1896133C0](header, *(void *)&i, *(void *)key.skey, value);
}

int AAHeaderSetFieldUInt(AAHeader header, uint32_t i, AAFieldKey key, uint64_t value)
{
  return MEMORY[0x1896133C8](header, *(void *)&i, *(void *)key.skey, value);
}

uint64_t AFSCLockFilePath()
{
  return MEMORY[0x18960D0E0]();
}

uint64_t AFSCUnlockFile()
{
  return MEMORY[0x18960D0E8]();
}

int BZ2_bzCompress(bz_stream *strm, int action)
{
  return MEMORY[0x189614130](strm, *(void *)&action);
}

int BZ2_bzCompressEnd(bz_stream *strm)
{
  return MEMORY[0x189614138](strm);
}

int BZ2_bzCompressInit(bz_stream *strm, int blockSize100k, int verbosity, int workFactor)
{
  return MEMORY[0x189614140](strm, *(void *)&blockSize100k, *(void *)&verbosity, *(void *)&workFactor);
}

int BZ2_bzDecompress(bz_stream *strm)
{
  return MEMORY[0x189614148](strm);
}

int BZ2_bzDecompressEnd(bz_stream *strm)
{
  return MEMORY[0x189614150](strm);
}

int BZ2_bzDecompressInit(bz_stream *strm, int verbosity, int small)
{
  return MEMORY[0x189614158](strm, *(void *)&verbosity, *(void *)&small);
}

int CC_MD5_Final(unsigned __int8 *md, CC_MD5_CTX *c)
{
  return MEMORY[0x1895F8278](md, c);
}

int CC_MD5_Init(CC_MD5_CTX *c)
{
  return MEMORY[0x1895F8280](c);
}

int CC_MD5_Update(CC_MD5_CTX *c, const void *data, CC_LONG len)
{
  return MEMORY[0x1895F8288](c, data, *(void *)&len);
}

int CC_SHA1_Final(unsigned __int8 *md, CC_SHA1_CTX *c)
{
  return MEMORY[0x1895F8298](md, c);
}

int CC_SHA1_Init(CC_SHA1_CTX *c)
{
  return MEMORY[0x1895F82A0](c);
}

int CC_SHA1_Update(CC_SHA1_CTX *c, const void *data, CC_LONG len)
{
  return MEMORY[0x1895F82A8](c, data, *(void *)&len);
}

int CC_SHA224_Final(unsigned __int8 *md, CC_SHA256_CTX *c)
{
  return MEMORY[0x1895F82B8](md, c);
}

int CC_SHA224_Init(CC_SHA256_CTX *c)
{
  return MEMORY[0x1895F82C0](c);
}

int CC_SHA224_Update(CC_SHA256_CTX *c, const void *data, CC_LONG len)
{
  return MEMORY[0x1895F82C8](c, data, *(void *)&len);
}

int CC_SHA256_Final(unsigned __int8 *md, CC_SHA256_CTX *c)
{
  return MEMORY[0x1895F82D8](md, c);
}

int CC_SHA256_Init(CC_SHA256_CTX *c)
{
  return MEMORY[0x1895F82E0](c);
}

int CC_SHA256_Update(CC_SHA256_CTX *c, const void *data, CC_LONG len)
{
  return MEMORY[0x1895F82E8](c, data, *(void *)&len);
}

int CC_SHA384_Final(unsigned __int8 *md, CC_SHA512_CTX *c)
{
  return MEMORY[0x1895F82F8](md, c);
}

int CC_SHA384_Init(CC_SHA512_CTX *c)
{
  return MEMORY[0x1895F8300](c);
}

int CC_SHA384_Update(CC_SHA512_CTX *c, const void *data, CC_LONG len)
{
  return MEMORY[0x1895F8308](c, data, *(void *)&len);
}

int CC_SHA512_Final(unsigned __int8 *md, CC_SHA512_CTX *c)
{
  return MEMORY[0x1895F8318](md, c);
}

int CC_SHA512_Init(CC_SHA512_CTX *c)
{
  return MEMORY[0x1895F8320](c);
}

int CC_SHA512_Update(CC_SHA512_CTX *c, const void *data, CC_LONG len)
{
  return MEMORY[0x1895F8328](c, data, *(void *)&len);
}

void CFArrayAppendArray(CFMutableArrayRef theArray, CFArrayRef otherArray, CFRange otherRange)
{
}

void CFArrayAppendValue(CFMutableArrayRef theArray, const void *value)
{
}

void CFArrayApplyFunction(CFArrayRef theArray, CFRange range, CFArrayApplierFunction applier, void *context)
{
}

Boolean CFArrayContainsValue(CFArrayRef theArray, CFRange range, const void *value)
{
  return MEMORY[0x189602630](theArray, range.location, range.length, value);
}

CFMutableArrayRef CFArrayCreateMutable( CFAllocatorRef allocator, CFIndex capacity, const CFArrayCallBacks *callBacks)
{
  return (CFMutableArrayRef)MEMORY[0x189602648](allocator, capacity, callBacks);
}

CFMutableArrayRef CFArrayCreateMutableCopy(CFAllocatorRef allocator, CFIndex capacity, CFArrayRef theArray)
{
  return (CFMutableArrayRef)MEMORY[0x189602658](allocator, capacity, theArray);
}

CFIndex CFArrayGetCount(CFArrayRef theArray)
{
  return MEMORY[0x189602660](theArray);
}

CFIndex CFArrayGetFirstIndexOfValue(CFArrayRef theArray, CFRange range, const void *value)
{
  return MEMORY[0x189602678](theArray, range.location, range.length, value);
}

CFTypeID CFArrayGetTypeID(void)
{
  return MEMORY[0x189602690]();
}

const void *__cdecl CFArrayGetValueAtIndex(CFArrayRef theArray, CFIndex idx)
{
  return (const void *)MEMORY[0x189602698](theArray, idx);
}

void CFArrayRemoveValueAtIndex(CFMutableArrayRef theArray, CFIndex idx)
{
}

void CFArraySetValueAtIndex(CFMutableArrayRef theArray, CFIndex idx, const void *value)
{
}

CFTypeID CFBooleanGetTypeID(void)
{
  return MEMORY[0x1896027C8]();
}

Boolean CFBooleanGetValue(CFBooleanRef BOOLean)
{
  return MEMORY[0x1896027D0](BOOLean);
}

CFDataRef CFDataCreate(CFAllocatorRef allocator, const UInt8 *bytes, CFIndex length)
{
  return (CFDataRef)MEMORY[0x189602A58](allocator, bytes, length);
}

CFDataRef CFDataCreateWithBytesNoCopy( CFAllocatorRef allocator, const UInt8 *bytes, CFIndex length, CFAllocatorRef bytesDeallocator)
{
  return (CFDataRef)MEMORY[0x189602A80](allocator, bytes, length, bytesDeallocator);
}

const UInt8 *__cdecl CFDataGetBytePtr(CFDataRef theData)
{
  return (const UInt8 *)MEMORY[0x189602A98](theData);
}

CFIndex CFDataGetLength(CFDataRef theData)
{
  return MEMORY[0x189602AB0](theData);
}

CFTypeID CFDataGetTypeID(void)
{
  return MEMORY[0x189602AC8]();
}

void CFDictionaryAddValue(CFMutableDictionaryRef theDict, const void *key, const void *value)
{
}

Boolean CFDictionaryContainsKey(CFDictionaryRef theDict, const void *key)
{
  return MEMORY[0x189602B90](theDict, key);
}

CFDictionaryRef CFDictionaryCreate( CFAllocatorRef allocator, const void **keys, const void **values, CFIndex numValues, const CFDictionaryKeyCallBacks *keyCallBacks, const CFDictionaryValueCallBacks *valueCallBacks)
{
  return (CFDictionaryRef)MEMORY[0x189602BA8](allocator, keys, values, numValues, keyCallBacks, valueCallBacks);
}

CFMutableDictionaryRef CFDictionaryCreateMutable( CFAllocatorRef allocator, CFIndex capacity, const CFDictionaryKeyCallBacks *keyCallBacks, const CFDictionaryValueCallBacks *valueCallBacks)
{
  return (CFMutableDictionaryRef)MEMORY[0x189602BB8](allocator, capacity, keyCallBacks, valueCallBacks);
}

CFIndex CFDictionaryGetCount(CFDictionaryRef theDict)
{
  return MEMORY[0x189602BD0](theDict);
}

void CFDictionaryGetKeysAndValues(CFDictionaryRef theDict, const void **keys, const void **values)
{
}

CFTypeID CFDictionaryGetTypeID(void)
{
  return MEMORY[0x189602BF0]();
}

const void *__cdecl CFDictionaryGetValue(CFDictionaryRef theDict, const void *key)
{
  return (const void *)MEMORY[0x189602C00](theDict, key);
}

Boolean CFDictionaryGetValueIfPresent(CFDictionaryRef theDict, const void *key, const void **value)
{
  return MEMORY[0x189602C08](theDict, key, value);
}

void CFDictionaryRemoveValue(CFMutableDictionaryRef theDict, const void *key)
{
}

void CFDictionarySetValue(CFMutableDictionaryRef theDict, const void *key, const void *value)
{
}

Boolean CFEqual(CFTypeRef cf1, CFTypeRef cf2)
{
  return MEMORY[0x189602C38](cf1, cf2);
}

CFTypeID CFGetTypeID(CFTypeRef cf)
{
  return MEMORY[0x189602D30](cf);
}

CFNumberRef CFNumberCreate(CFAllocatorRef allocator, CFNumberType theType, const void *valuePtr)
{
  return (CFNumberRef)MEMORY[0x189602EA0](allocator, theType, valuePtr);
}

CFTypeID CFNumberGetTypeID(void)
{
  return MEMORY[0x189602F08]();
}

Boolean CFNumberGetValue(CFNumberRef number, CFNumberType theType, void *valuePtr)
{
  return MEMORY[0x189602F10](number, theType, valuePtr);
}

CFDataRef CFPropertyListCreateData( CFAllocatorRef allocator, CFPropertyListRef propertyList, CFPropertyListFormat format, CFOptionFlags options, CFErrorRef *error)
{
  return (CFDataRef)MEMORY[0x189602FD0](allocator, propertyList, format, options, error);
}

CFPropertyListRef CFPropertyListCreateWithData( CFAllocatorRef allocator, CFDataRef data, CFOptionFlags options, CFPropertyListFormat *format, CFErrorRef *error)
{
  return (CFPropertyListRef)MEMORY[0x189602FF0](allocator, data, options, format, error);
}

void CFReadStreamClose(CFReadStreamRef stream)
{
}

CFStreamStatus CFReadStreamGetStatus(CFReadStreamRef stream)
{
  return MEMORY[0x189603080](stream);
}

CFTypeID CFReadStreamGetTypeID(void)
{
  return MEMORY[0x189603088]();
}

CFIndex CFReadStreamRead(CFReadStreamRef stream, UInt8 *buffer, CFIndex bufferLength)
{
  return MEMORY[0x1896030A0](stream, buffer, bufferLength);
}

void CFRelease(CFTypeRef cf)
{
}

CFTypeRef CFRetain(CFTypeRef cf)
{
  return (CFTypeRef)MEMORY[0x1896030F0](cf);
}

CFArrayRef CFStringCreateArrayBySeparatingStrings( CFAllocatorRef alloc, CFStringRef theString, CFStringRef separatorString)
{
  return (CFArrayRef)MEMORY[0x189603400](alloc, theString, separatorString);
}

CFStringRef CFStringCreateByCombiningStrings( CFAllocatorRef alloc, CFArrayRef theArray, CFStringRef separatorString)
{
  return (CFStringRef)MEMORY[0x189603410](alloc, theArray, separatorString);
}

CFStringRef CFStringCreateWithCString(CFAllocatorRef alloc, const char *cStr, CFStringEncoding encoding)
{
  return (CFStringRef)MEMORY[0x189603468](alloc, cStr, *(void *)&encoding);
}

Boolean CFStringGetCString(CFStringRef theString, char *buffer, CFIndex bufferSize, CFStringEncoding encoding)
{
  return MEMORY[0x1896034F8](theString, buffer, bufferSize, *(void *)&encoding);
}

const char *__cdecl CFStringGetCStringPtr(CFStringRef theString, CFStringEncoding encoding)
{
  return (const char *)MEMORY[0x189603500](theString, *(void *)&encoding);
}

CFIndex CFStringGetLength(CFStringRef theString)
{
  return MEMORY[0x189603548](theString);
}

CFStringEncoding CFStringGetSystemEncoding(void)
{
  return MEMORY[0x189603588]();
}

CFTypeID CFStringGetTypeID(void)
{
  return MEMORY[0x189603590]();
}

void CFWriteStreamClose(CFWriteStreamRef stream)
{
}

CFStreamStatus CFWriteStreamGetStatus(CFWriteStreamRef stream)
{
  return MEMORY[0x189603950](stream);
}

CFTypeID CFWriteStreamGetTypeID(void)
{
  return MEMORY[0x189603958]();
}

CFIndex CFWriteStreamWrite(CFWriteStreamRef stream, const UInt8 *buffer, CFIndex bufferLength)
{
  return MEMORY[0x189603998](stream, buffer, bufferLength);
}

uint64_t CNCRCFinal()
{
  return MEMORY[0x1895F8348]();
}

uint64_t CNCRCInit()
{
  return MEMORY[0x1895F8350]();
}

uint64_t CNCRCRelease()
{
  return MEMORY[0x1895F8358]();
}

uint64_t CNCRCUpdate()
{
  return MEMORY[0x1895F8360]();
}

uint64_t CloseStreamCompressor()
{
  return MEMORY[0x18960D0F0]();
}

uint64_t CreateStreamCompressor()
{
  return MEMORY[0x18960D0F8]();
}

uint64_t CreateStreamCompressorQueueWithOptions()
{
  return MEMORY[0x18960D100]();
}

uint64_t FinishStreamCompressorQueue()
{
  return MEMORY[0x18960D108]();
}

uint64_t ParallelCompressionAFSCStreamClose()
{
  return MEMORY[0x189613790]();
}

uint64_t ParallelCompressionAFSCStreamOpen()
{
  return MEMORY[0x189613798]();
}

uint64_t ParallelCompressionAFSCStreamWrite()
{
  return MEMORY[0x1896137A0]();
}

uint64_t VolumeSupportsCompression()
{
  return MEMORY[0x18960D110]();
}

uint64_t WriteToStreamCompressor()
{
  return MEMORY[0x18960D118]();
}

void _Block_object_dispose(const void *a1, const int a2)
{
}

int *__error(void)
{
  return (int *)MEMORY[0x1895F8898]();
}

int __maskrune(__darwin_ct_rune_t a1, unint64_t a2)
{
  return MEMORY[0x1895F8918](*(void *)&a1, a2);
}

uint64_t __memcpy_chk()
{
  return MEMORY[0x1895F8930]();
}

uint64_t __strlcat_chk()
{
  return MEMORY[0x1895F8A00]();
}

uint64_t __strlcpy_chk()
{
  return MEMORY[0x1895F8A08]();
}

__darwin_ct_rune_t __tolower(__darwin_ct_rune_t a1)
{
  return MEMORY[0x1895F8A28](*(void *)&a1);
}

void _os_log_impl(void *dso, os_log_t log, os_log_type_t type, const char *format, uint8_t *buf, uint32_t size)
{
}

void abort(void)
{
}

int access(const char *a1, int a2)
{
  return MEMORY[0x1895F9328](a1, *(void *)&a2);
}

int acl_copy_entry(acl_entry_t dest_d, acl_entry_t src_d)
{
  return MEMORY[0x1895F9358](dest_d, src_d);
}

int acl_create_entry(acl_t *acl_p, acl_entry_t *entry_p)
{
  return MEMORY[0x1895F9378](acl_p, entry_p);
}

int acl_free(void *obj_p)
{
  return MEMORY[0x1895F9390](obj_p);
}

acl_t acl_from_text(const char *buf_p)
{
  return (acl_t)MEMORY[0x1895F9398](buf_p);
}

int acl_get_entry(acl_t acl, int entry_id, acl_entry_t *entry_p)
{
  return MEMORY[0x1895F93A0](acl, *(void *)&entry_id, entry_p);
}

acl_t acl_get_file(const char *path_p, acl_type_t type)
{
  return (acl_t)MEMORY[0x1895F93B8](path_p, *(void *)&type);
}

int acl_get_flag_np(acl_flagset_t flagset_d, acl_flag_t flag)
{
  return MEMORY[0x1895F93C0](flagset_d, *(void *)&flag);
}

int acl_get_flagset_np(void *obj_p, acl_flagset_t *flagset_p)
{
  return MEMORY[0x1895F93C8](obj_p, flagset_p);
}

acl_t acl_get_link_np(const char *path_p, acl_type_t type)
{
  return (acl_t)MEMORY[0x1895F93D0](path_p, *(void *)&type);
}

acl_t acl_init(int count)
{
  return (acl_t)MEMORY[0x1895F9400](*(void *)&count);
}

int acl_set_fd_np(int fd, acl_t acl, acl_type_t acl_type)
{
  return MEMORY[0x1895F9410](*(void *)&fd, acl, *(void *)&acl_type);
}

int acl_set_file(const char *path_p, acl_type_t type, acl_t acl)
{
  return MEMORY[0x1895F9418](path_p, *(void *)&type, acl);
}

int acl_set_link_np(const char *path_p, acl_type_t type, acl_t acl)
{
  return MEMORY[0x1895F9428](path_p, *(void *)&type, acl);
}

char *__cdecl acl_to_text(acl_t acl, ssize_t *len_p)
{
  return (char *)MEMORY[0x1895F9458](acl, len_p);
}

uint64_t archive_entry_atime()
{
  return MEMORY[0x189613D18]();
}

uint64_t archive_entry_atime_nsec()
{
  return MEMORY[0x189613D20]();
}

uint64_t archive_entry_ctime()
{
  return MEMORY[0x189613D28]();
}

uint64_t archive_entry_ctime_nsec()
{
  return MEMORY[0x189613D30]();
}

uint64_t archive_entry_dev()
{
  return MEMORY[0x189613D38]();
}

uint64_t archive_entry_free()
{
  return MEMORY[0x189613D40]();
}

uint64_t archive_entry_gid()
{
  return MEMORY[0x189613D48]();
}

uint64_t archive_entry_ino()
{
  return MEMORY[0x189613D50]();
}

uint64_t archive_entry_mode()
{
  return MEMORY[0x189613D58]();
}

uint64_t archive_entry_mtime()
{
  return MEMORY[0x189613D60]();
}

uint64_t archive_entry_mtime_nsec()
{
  return MEMORY[0x189613D68]();
}

uint64_t archive_entry_new()
{
  return MEMORY[0x189613D70]();
}

uint64_t archive_entry_nlink()
{
  return MEMORY[0x189613D78]();
}

uint64_t archive_entry_pathname()
{
  return MEMORY[0x189613D80]();
}

uint64_t archive_entry_set_atime()
{
  return MEMORY[0x189613D88]();
}

uint64_t archive_entry_set_ctime()
{
  return MEMORY[0x189613D90]();
}

uint64_t archive_entry_set_dev()
{
  return MEMORY[0x189613D98]();
}

uint64_t archive_entry_set_filetype()
{
  return MEMORY[0x189613DA0]();
}

uint64_t archive_entry_set_gid()
{
  return MEMORY[0x189613DA8]();
}

uint64_t archive_entry_set_ino64()
{
  return MEMORY[0x189613DB0]();
}

uint64_t archive_entry_set_mode()
{
  return MEMORY[0x189613DB8]();
}

uint64_t archive_entry_set_mtime()
{
  return MEMORY[0x189613DC0]();
}

uint64_t archive_entry_set_nlink()
{
  return MEMORY[0x189613DC8]();
}

uint64_t archive_entry_set_pathname()
{
  return MEMORY[0x189613DD0]();
}

uint64_t archive_entry_set_perm()
{
  return MEMORY[0x189613DD8]();
}

uint64_t archive_entry_set_size()
{
  return MEMORY[0x189613DE0]();
}

uint64_t archive_entry_set_symlink()
{
  return MEMORY[0x189613DE8]();
}

uint64_t archive_entry_set_uid()
{
  return MEMORY[0x189613DF0]();
}

uint64_t archive_entry_size()
{
  return MEMORY[0x189613DF8]();
}

uint64_t archive_entry_symlink()
{
  return MEMORY[0x189613E00]();
}

uint64_t archive_entry_uid()
{
  return MEMORY[0x189613E08]();
}

uint64_t archive_errno()
{
  return MEMORY[0x189613E10]();
}

uint64_t archive_error_string()
{
  return MEMORY[0x189613E18]();
}

uint64_t archive_read_add_passphrase()
{
  return MEMORY[0x189613E20]();
}

uint64_t archive_read_data()
{
  return MEMORY[0x189613E28]();
}

uint64_t archive_read_free()
{
  return MEMORY[0x189613E48]();
}

uint64_t archive_read_has_encrypted_entries()
{
  return MEMORY[0x189613E50]();
}

uint64_t archive_read_new()
{
  return MEMORY[0x189613E58]();
}

uint64_t archive_read_next_header()
{
  return MEMORY[0x189613E60]();
}

uint64_t archive_read_open()
{
  return MEMORY[0x189613E68]();
}

uint64_t archive_read_open_fd()
{
  return MEMORY[0x189613E70]();
}

uint64_t archive_read_open_filename()
{
  return MEMORY[0x189613E78]();
}

uint64_t archive_read_set_options()
{
  return MEMORY[0x189613E80]();
}

uint64_t archive_read_set_passphrase_callback()
{
  return MEMORY[0x189613E88]();
}

uint64_t archive_read_support_filter_all()
{
  return MEMORY[0x189613E90]();
}

uint64_t archive_read_support_format_all()
{
  return MEMORY[0x189613E98]();
}

uint64_t archive_set_error()
{
  return MEMORY[0x189613EA0]();
}

uint64_t archive_write_add_filter()
{
  return MEMORY[0x189613EA8]();
}

uint64_t archive_write_close()
{
  return MEMORY[0x189613EB0]();
}

uint64_t archive_write_data()
{
  return MEMORY[0x189613EB8]();
}

uint64_t archive_write_free()
{
  return MEMORY[0x189613EC0]();
}

uint64_t archive_write_header()
{
  return MEMORY[0x189613EC8]();
}

uint64_t archive_write_new()
{
  return MEMORY[0x189613ED0]();
}

uint64_t archive_write_open2()
{
  return MEMORY[0x189613ED8]();
}

uint64_t archive_write_open_fd()
{
  return MEMORY[0x189613EE0]();
}

uint64_t archive_write_open_filename()
{
  return MEMORY[0x189613EE8]();
}

uint64_t archive_write_set_filter_option()
{
  return MEMORY[0x189613EF0]();
}

uint64_t archive_write_set_format()
{
  return MEMORY[0x189613EF8]();
}

uint64_t archive_write_set_format_option()
{
  return MEMORY[0x189613F00]();
}

int asprintf(char **a1, const char *a2, ...)
{
  return MEMORY[0x1895F9540](a1, a2);
}

char *__cdecl basename_r(const char *a1, char *a2)
{
  return (char *)MEMORY[0x1895F95F8](a1, a2);
}

void bzero(void *a1, size_t a2)
{
}

void *__cdecl calloc(size_t __count, size_t __size)
{
  return (void *)MEMORY[0x1895F9710](__count, __size);
}

int chdir(const char *a1)
{
  return MEMORY[0x1895FA528](a1);
}

int chflags(const char *a1, __uint32_t a2)
{
  return MEMORY[0x1895FA530](a1, *(void *)&a2);
}

int chmod(const char *a1, mode_t a2)
{
  return MEMORY[0x1895FA538](a1, a2);
}

int chown(const char *a1, uid_t a2, gid_t a3)
{
  return MEMORY[0x1895FA540](a1, *(void *)&a2, *(void *)&a3);
}

int close(int a1)
{
  return MEMORY[0x1895FA590](*(void *)&a1);
}

int closedir(DIR *a1)
{
  return MEMORY[0x1895FA5A8](a1);
}

int copyfile(const char *from, const char *to, copyfile_state_t state, copyfile_flags_t flags)
{
  return MEMORY[0x1895FAA60](from, to, state, *(void *)&flags);
}

uLong crc32(uLong crc, const Bytef *buf, uInt len)
{
  return MEMORY[0x189617578](crc, buf, *(void *)&len);
}

char *__cdecl ctime_r(const time_t *a1, char *a2)
{
  return (char *)MEMORY[0x1895FAAC0](a1, a2);
}

int deflate(z_streamp strm, int flush)
{
  return MEMORY[0x189617580](strm, *(void *)&flush);
}

int deflateEnd(z_streamp strm)
{
  return MEMORY[0x189617590](strm);
}

int deflateInit2_( z_streamp strm, int level, int method, int windowBits, int memLevel, int strategy, const char *version, int stream_size)
{
  return MEMORY[0x189617598]( strm,  *(void *)&level,  *(void *)&method,  *(void *)&windowBits,  *(void *)&memLevel,  *(void *)&strategy,  version,  *(void *)&stream_size);
}

char *__cdecl dirname_r(const char *a1, char *a2)
{
  return (char *)MEMORY[0x1895FAAE0](a1, a2);
}

dispatch_queue_global_t dispatch_get_global_queue(uint64_t identifier, unint64_t flags)
{
  return (dispatch_queue_global_t)MEMORY[0x1895FAC40](identifier, flags);
}

void dispatch_group_async(dispatch_group_t group, dispatch_queue_t queue, dispatch_block_t block)
{
}

dispatch_group_t dispatch_group_create(void)
{
  return (dispatch_group_t)MEMORY[0x1895FAC60]();
}

void dispatch_group_enter(dispatch_group_t group)
{
}

void dispatch_group_leave(dispatch_group_t group)
{
}

uint64_t dispatch_group_wait(dispatch_group_t group, dispatch_time_t timeout)
{
  return MEMORY[0x1895FAC80](group, timeout);
}

void dispatch_once(dispatch_once_t *predicate, dispatch_block_t block)
{
}

void dispatch_release(dispatch_object_t object)
{
}

void err(int a1, const char *a2, ...)
{
}

void errx(int a1, const char *a2, ...)
{
}

int faccessat(int a1, const char *a2, int a3, int a4)
{
  return MEMORY[0x1895FB1C8](*(void *)&a1, a2, *(void *)&a3, *(void *)&a4);
}

int fclose(FILE *a1)
{
  return MEMORY[0x1895FB208](a1);
}

int fcntl(int a1, int a2, ...)
{
  return MEMORY[0x1895FB210](*(void *)&a1, *(void *)&a2);
}

char *__cdecl fgets(char *a1, int a2, FILE *a3)
{
  return (char *)MEMORY[0x1895FB290](a1, *(void *)&a2, a3);
}

FILE *__cdecl fopen(const char *__filename, const char *__mode)
{
  return (FILE *)MEMORY[0x1895FB348](__filename, __mode);
}

int fprintf(FILE *a1, const char *a2, ...)
{
  return MEMORY[0x1895FB360](a1, a2);
}

int fputc(int a1, FILE *a2)
{
  return MEMORY[0x1895FB370](*(void *)&a1, a2);
}

void free(void *a1)
{
}

int fsctl(const char *a1, unint64_t a2, void *a3, unsigned int a4)
{
  return MEMORY[0x1895FB418](a1, a2, a3, *(void *)&a4);
}

int fstat(int a1, stat *a2)
{
  return MEMORY[0x1895FB448](*(void *)&a1, a2);
}

int fstatfs(int a1, statfs *a2)
{
  return MEMORY[0x1895FB460](*(void *)&a1, a2);
}

int fsync(int a1)
{
  return MEMORY[0x1895FB468](*(void *)&a1);
}

int fts_close(FTS *a1)
{
  return MEMORY[0x1895FB490](a1);
}

FTS *__cdecl fts_open(char *const *a1, int a2, int (__cdecl *a3)(const FTSENT **, const FTSENT **))
{
  return (FTS *)MEMORY[0x1895FB498](a1, *(void *)&a2, a3);
}

FTSENT *__cdecl fts_read(FTS *a1)
{
  return (FTSENT *)MEMORY[0x1895FB4A0](a1);
}

size_t fwrite(const void *__ptr, size_t __size, size_t __nitems, FILE *__stream)
{
  return MEMORY[0x1895FB4C8](__ptr, __size, __nitems, __stream);
}

int getattrlist(const char *a1, void *a2, void *a3, size_t a4, unsigned int a5)
{
  return MEMORY[0x1895FB4F8](a1, a2, a3, a4, *(void *)&a5);
}

char *__cdecl getcwd(char *a1, size_t a2)
{
  return (char *)MEMORY[0x1895FB520](a1, a2);
}

gid_t getegid(void)
{
  return MEMORY[0x1895FB530]();
}

char *__cdecl getenv(const char *a1)
{
  return (char *)MEMORY[0x1895FB538](a1);
}

uid_t geteuid(void)
{
  return MEMORY[0x1895FB540]();
}

group *__cdecl getgrgid(gid_t a1)
{
  return (group *)MEMORY[0x1895FB558](*(void *)&a1);
}

int getgroups(int a1, gid_t a2[])
{
  return MEMORY[0x1895FB578](*(void *)&a1, a2);
}

int getpagesize(void)
{
  return MEMORY[0x1895FB608]();
}

pid_t getpid(void)
{
  return MEMORY[0x1895FB628]();
}

passwd *__cdecl getpwuid(uid_t a1)
{
  return (passwd *)MEMORY[0x1895FB670](*(void *)&a1);
}

int getrlimit(int a1, rlimit *a2)
{
  return MEMORY[0x1895FB680](*(void *)&a1, a2);
}

int gettimeofday(timeval *a1, void *a2)
{
  return MEMORY[0x1895FB6E0](a1, a2);
}

ssize_t getxattr(const char *path, const char *name, void *value, size_t size, u_int32_t position, int options)
{
  return MEMORY[0x1895FB708](path, name, value, size, *(void *)&position, *(void *)&options);
}

int inflate(z_streamp strm, int flush)
{
  return MEMORY[0x189617608](strm, *(void *)&flush);
}

int inflateEnd(z_streamp strm)
{
  return MEMORY[0x189617610](strm);
}

int inflateInit2_(z_streamp strm, int windowBits, const char *version, int stream_size)
{
  return MEMORY[0x189617618](strm, *(void *)&windowBits, version, *(void *)&stream_size);
}

int issetugid(void)
{
  return MEMORY[0x1895FB870]();
}

int lchmod(const char *a1, mode_t a2)
{
  return MEMORY[0x1895FB9B0](a1, a2);
}

int lchown(const char *a1, uid_t a2, gid_t a3)
{
  return MEMORY[0x1895FB9B8](a1, *(void *)&a2, *(void *)&a3);
}

int link(const char *a1, const char *a2)
{
  return MEMORY[0x1895FB9E8](a1, a2);
}

ssize_t listxattr(const char *path, char *namebuff, size_t size, int options)
{
  return MEMORY[0x1895FBA00](path, namebuff, size, *(void *)&options);
}

tm *__cdecl localtime(const time_t *a1)
{
  return (tm *)MEMORY[0x1895FBA18](a1);
}

off_t lseek(int a1, off_t a2, int a3)
{
  return MEMORY[0x1895FBA80](*(void *)&a1, a2, *(void *)&a3);
}

int lstat(const char *a1, stat *a2)
{
  return MEMORY[0x1895FBA88](a1, a2);
}

void *__cdecl malloc(size_t __size)
{
  return (void *)MEMORY[0x1895FBC88](__size);
}

void *__cdecl memchr(const void *__s, int __c, size_t __n)
{
  return (void *)MEMORY[0x1895FBE00](__s, *(void *)&__c, __n);
}

int memcmp(const void *__s1, const void *__s2, size_t __n)
{
  return MEMORY[0x1895FBE08](__s1, __s2, __n);
}

void *__cdecl memcpy(void *__dst, const void *__src, size_t __n)
{
  return (void *)MEMORY[0x1895FBE18](__dst, __src, __n);
}

void *__cdecl memmove(void *__dst, const void *__src, size_t __len)
{
  return (void *)MEMORY[0x1895FBE30](__dst, __src, __len);
}

void *__cdecl memset(void *__b, int __c, size_t __len)
{
  return (void *)MEMORY[0x1895FBE48](__b, *(void *)&__c, __len);
}

int mergesort(void *__base, size_t __nel, size_t __width, int (__cdecl *__compar)(const void *, const void *))
{
  return MEMORY[0x1895FBE70](__base, __nel, __width, __compar);
}

int mkdir(const char *a1, mode_t a2)
{
  return MEMORY[0x1895FBEF0](a1, a2);
}

int mknod(const char *a1, mode_t a2, dev_t a3)
{
  return MEMORY[0x1895FBF18](a1, a2, *(void *)&a3);
}

int mkstemp(char *a1)
{
  return MEMORY[0x1895FBF38](a1);
}

char *__cdecl mktemp(char *a1)
{
  return (char *)MEMORY[0x1895FBF58](a1);
}

time_t mktime(tm *a1)
{
  return MEMORY[0x1895FBF60](a1);
}

void *__cdecl mmap(void *a1, size_t a2, int a3, int a4, int a5, off_t a6)
{
  return (void *)MEMORY[0x1895FBF70](a1, a2, *(void *)&a3, *(void *)&a4, *(void *)&a5, a6);
}

int munmap(void *a1, size_t a2)
{
  return MEMORY[0x1895FBF98](a1, a2);
}

int nanosleep(const timespec *__rqtp, timespec *__rmtp)
{
  return MEMORY[0x1895FBFB0](__rqtp, __rmtp);
}

int open(const char *a1, int a2, ...)
{
  return MEMORY[0x1895FC248](a1, *(void *)&a2);
}

int open_dprotected_np(const char *a1, int a2, int a3, int a4, ...)
{
  return MEMORY[0x1895FC250](a1, *(void *)&a2, *(void *)&a3, *(void *)&a4);
}

DIR *__cdecl opendir(const char *a1)
{
  return (DIR *)MEMORY[0x1895FC278](a1);
}

os_log_t os_log_create(const char *subsystem, const char *category)
{
  return (os_log_t)MEMORY[0x1895FC440](subsystem, category);
}

BOOL os_log_type_enabled(os_log_t oslog, os_log_type_t type)
{
  return MEMORY[0x1895FC470](oslog, type);
}

uint64_t os_variant_has_internal_content()
{
  return MEMORY[0x1895FC6C0]();
}

void perror(const char *a1)
{
}

int printf(const char *a1, ...)
{
  return MEMORY[0x1895FC890](a1);
}

int pthread_attr_init(pthread_attr_t *a1)
{
  return MEMORY[0x1895FC958](a1);
}

int pthread_attr_set_qos_class_np(pthread_attr_t *__attr, qos_class_t __qos_class, int __relative_priority)
{
  return MEMORY[0x1895FC960](__attr, *(void *)&__qos_class, *(void *)&__relative_priority);
}

int pthread_cond_broadcast(pthread_cond_t *a1)
{
  return MEMORY[0x1895FC998](a1);
}

int pthread_cond_destroy(pthread_cond_t *a1)
{
  return MEMORY[0x1895FC9A0](a1);
}

int pthread_cond_init(pthread_cond_t *a1, const pthread_condattr_t *a2)
{
  return MEMORY[0x1895FC9A8](a1, a2);
}

int pthread_cond_signal(pthread_cond_t *a1)
{
  return MEMORY[0x1895FC9B0](a1);
}

int pthread_cond_wait(pthread_cond_t *a1, pthread_mutex_t *a2)
{
  return MEMORY[0x1895FC9C8](a1, a2);
}

int pthread_create(pthread_t *a1, const pthread_attr_t *a2, void *(__cdecl *a3)(void *), void *a4)
{
  return MEMORY[0x1895FC9D8](a1, a2, a3, a4);
}

int pthread_join(pthread_t a1, void **a2)
{
  return MEMORY[0x1895FCA58](a1, a2);
}

int pthread_mutex_destroy(pthread_mutex_t *a1)
{
  return MEMORY[0x1895FCA88](a1);
}

int pthread_mutex_init(pthread_mutex_t *a1, const pthread_mutexattr_t *a2)
{
  return MEMORY[0x1895FCA90](a1, a2);
}

int pthread_mutex_lock(pthread_mutex_t *a1)
{
  return MEMORY[0x1895FCA98](a1);
}

int pthread_mutex_unlock(pthread_mutex_t *a1)
{
  return MEMORY[0x1895FCAA8](a1);
}

int pthread_once(pthread_once_t *a1, void (*a2)(void))
{
  return MEMORY[0x1895FCAC8](a1, a2);
}

int puts(const char *a1)
{
  return MEMORY[0x1895FCB98](a1);
}

qos_class_t qos_class_self(void)
{
  return MEMORY[0x1895FCBB8]();
}

void qsort(void *__base, size_t __nel, size_t __width, int (__cdecl *__compar)(const void *, const void *))
{
}

ssize_t read(int a1, void *a2, size_t a3)
{
  return MEMORY[0x1895FCC38](*(void *)&a1, a2, a3);
}

dirent *__cdecl readdir(DIR *a1)
{
  return (dirent *)MEMORY[0x1895FCC40](a1);
}

int readdir_r(DIR *a1, dirent *a2, dirent **a3)
{
  return MEMORY[0x1895FCC48](a1, a2, a3);
}

ssize_t readlink(const char *a1, char *a2, size_t a3)
{
  return MEMORY[0x1895FCC50](a1, a2, a3);
}

void *__cdecl realloc(void *__ptr, size_t __size)
{
  return (void *)MEMORY[0x1895FCC68](__ptr, __size);
}

void *__cdecl reallocf(void *__ptr, size_t __size)
{
  return (void *)MEMORY[0x1895FCC70](__ptr, __size);
}

char *__cdecl realpath_DARWIN_EXTSN(const char *a1, char *a2)
{
  return (char *)MEMORY[0x1895FCC80](a1, a2);
}

int regcomp(regex_t *a1, const char *a2, int a3)
{
  return MEMORY[0x1895FCCC8](a1, a2, *(void *)&a3);
}

int regexec(const regex_t *a1, const char *a2, size_t a3, regmatch_t __pmatch[], int a5)
{
  return MEMORY[0x1895FCCD8](a1, a2, a3, __pmatch, *(void *)&a5);
}

void regfree(regex_t *a1)
{
}

int removexattr(const char *path, const char *name, int options)
{
  return MEMORY[0x1895FCD38](path, name, *(void *)&options);
}

int rename(const char *__old, const char *__new)
{
  return MEMORY[0x1895FCD50](__old, __new);
}

char *__cdecl rindex(const char *a1, int a2)
{
  return (char *)MEMORY[0x1895FCD78](a1, *(void *)&a2);
}

int rmdir(const char *a1)
{
  return MEMORY[0x1895FCD80](a1);
}

int setattrlist(const char *a1, void *a2, void *a3, size_t a4, unsigned int a5)
{
  return MEMORY[0x1895FCE50](a1, a2, a3, a4, *(void *)&a5);
}

int setrlimit(int a1, const rlimit *a2)
{
  return MEMORY[0x1895FCEB8](*(void *)&a1, a2);
}

int setxattr( const char *path, const char *name, const void *value, size_t size, u_int32_t position, int options)
{
  return MEMORY[0x1895FCEE0](path, name, value, size, *(void *)&position, *(void *)&options);
}

int snprintf(char *__str, size_t __size, const char *__format, ...)
{
  return MEMORY[0x1895FCF90](__str, __size, __format);
}

int sscanf(const char *a1, const char *a2, ...)
{
  return MEMORY[0x1895FCFD0](a1, a2);
}

int stat(const char *a1, stat *a2)
{
  return MEMORY[0x1895FD010](a1, a2);
}

int statfs(const char *a1, statfs *a2)
{
  return MEMORY[0x1895FD018](a1, a2);
}

char *__cdecl strchr(const char *__s, int __c)
{
  return (char *)MEMORY[0x1895FD048](__s, *(void *)&__c);
}

int strcmp(const char *__s1, const char *__s2)
{
  return MEMORY[0x1895FD050](__s1, __s2);
}

char *__cdecl strcpy(char *__dst, const char *__src)
{
  return (char *)MEMORY[0x1895FD068](__dst, __src);
}

char *__cdecl strdup(const char *__s1)
{
  return (char *)MEMORY[0x1895FD078](__s1);
}

char *__cdecl strerror(int __errnum)
{
  return (char *)MEMORY[0x1895FD080](*(void *)&__errnum);
}

size_t strlcat(char *__dst, const char *__source, size_t __size)
{
  return MEMORY[0x1895FD0A0](__dst, __source, __size);
}

size_t strlcpy(char *__dst, const char *__source, size_t __size)
{
  return MEMORY[0x1895FD0B0](__dst, __source, __size);
}

size_t strlen(const char *__s)
{
  return MEMORY[0x1895FD0B8](__s);
}

void strmode(int __mode, char *__bp)
{
}

char *__cdecl strncat(char *__s1, const char *__s2, size_t __n)
{
  return (char *)MEMORY[0x1895FD0E0](__s1, __s2, __n);
}

int strncmp(const char *__s1, const char *__s2, size_t __n)
{
  return MEMORY[0x1895FD0E8](__s1, __s2, __n);
}

char *__cdecl strncpy(char *__dst, const char *__src, size_t __n)
{
  return (char *)MEMORY[0x1895FD0F0](__dst, __src, __n);
}

size_t strnlen(const char *__s1, size_t __n)
{
  return MEMORY[0x1895FD100](__s1, __n);
}

char *__cdecl strrchr(const char *__s, int __c)
{
  return (char *)MEMORY[0x1895FD120](__s, *(void *)&__c);
}

char *__cdecl strsep(char **__stringp, const char *__delim)
{
  return (char *)MEMORY[0x1895FD128](__stringp, __delim);
}

uint64_t strtol(const char *__str, char **__endptr, int __base)
{
  return MEMORY[0x1895FD180](__str, __endptr, *(void *)&__base);
}

uint64_t strtoll(const char *__str, char **__endptr, int __base)
{
  return MEMORY[0x1895FD1A0](__str, __endptr, *(void *)&__base);
}

uint64_t strtoq(const char *__str, char **__endptr, int __base)
{
  return MEMORY[0x1895FD1B0](__str, __endptr, *(void *)&__base);
}

unint64_t strtoul(const char *__str, char **__endptr, int __base)
{
  return MEMORY[0x1895FD1B8](__str, __endptr, *(void *)&__base);
}

int symlink(const char *a1, const char *a2)
{
  return MEMORY[0x1895FD240](a1, a2);
}

int sysctl(int *a1, u_int a2, void *a3, size_t *a4, void *a5, size_t a6)
{
  return MEMORY[0x1895FD2B0](a1, *(void *)&a2, a3, a4, a5, a6);
}

time_t time(time_t *a1)
{
  return MEMORY[0x1895FD400](a1);
}

int unlink(const char *a1)
{
  return MEMORY[0x1895FD468](a1);
}

int utimes(const char *a1, const timeval *a2)
{
  return MEMORY[0x1895FD4A8](a1, a2);
}

void uuid_generate(uuid_t out)
{
}

void uuid_generate_random(uuid_t out)
{
}

void uuid_unparse(const uuid_t uu, uuid_string_t out)
{
}

void *__cdecl valloc(size_t a1)
{
  return (void *)MEMORY[0x1895FD508](a1);
}

int vasprintf(char **a1, const char *a2, va_list a3)
{
  return MEMORY[0x1895FD510](a1, a2, a3);
}

kern_return_t vm_allocate(vm_map_t target_task, vm_address_t *address, vm_size_t size, int flags)
{
  return MEMORY[0x1895FD548](*(void *)&target_task, address, size, *(void *)&flags);
}

kern_return_t vm_copy( vm_map_t target_task, vm_address_t source_address, vm_size_t size, vm_address_t dest_address)
{
  return MEMORY[0x1895FD550](*(void *)&target_task, source_address, size, dest_address);
}

kern_return_t vm_deallocate(vm_map_t target_task, vm_address_t address, vm_size_t size)
{
  return MEMORY[0x1895FD558](*(void *)&target_task, address, size);
}

int vsnprintf(char *__str, size_t __size, const char *__format, va_list a4)
{
  return MEMORY[0x1895FD610](__str, __size, __format, a4);
}

void warnx(const char *a1, ...)
{
}