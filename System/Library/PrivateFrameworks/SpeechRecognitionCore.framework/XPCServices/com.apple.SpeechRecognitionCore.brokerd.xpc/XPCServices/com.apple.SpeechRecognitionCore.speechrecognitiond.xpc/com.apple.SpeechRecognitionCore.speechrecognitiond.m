void sub_100005C1C(id a1)
{
  uint64_t v1;
  os_log_s *v2;
  uint8_t v3[16];
  v1 = RXOSLog();
  v2 = (os_log_s *)objc_claimAutoreleasedReturnValue(v1);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)v3 = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "SpeechAnalyzerObjC initialized", v3, 2u);
  }
}
}

void sub_100006530( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
}

void sub_100006550(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = RXOSLog();
  v5 = (os_log_s *)objc_claimAutoreleasedReturnValue(v4);
  v6 = v5;
  if (v3)
  {
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
    {
      LOWORD(v11) = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEBUG,  "Attached transcriber to SpeechAnalyzer",  (uint8_t *)&v11,  2u);
    }

    [*(id *)(a1 + 32) setCurrentTask:*(void *)(a1 + 40)];
    [*(id *)(a1 + 32) startRecognition:v3];
    uint64_t v7 = RXOSLog();
    v8 = (os_log_s *)objc_claimAutoreleasedReturnValue(v7);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v9 = *(void *)(a1 + 40);
      int v11 = 138412290;
      uint64_t v12 = v9;
      _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEFAULT,  "SpeechAnalyzerObjC recognition started with task %@",  (uint8_t *)&v11,  0xCu);
    }
  }

  else
  {
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v10 = *(void *)(a1 + 40);
      int v11 = 138412290;
      uint64_t v12 = v10;
      _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "SpeechAnalyzerObjC recognition failed with task %@",  (uint8_t *)&v11,  0xCu);
    }

    *(_BYTE *)(*(void *)(*(void *)(a1 + 56) + 8LL) + 24LL) = 0;
  }

  dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 48));
}

void sub_10000688C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, id location, char a19)
{
}

void sub_1000068DC(uint64_t a1, void *a2)
{
  id v3 = a2;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 48));
  uint64_t v5 = RXOSLog();
  v6 = (os_log_s *)objc_claimAutoreleasedReturnValue(v5);
  uint64_t v7 = v6;
  if (v3)
  {
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
    {
      int v8 = *(unsigned __int8 *)(a1 + 56);
      int v13 = 67109120;
      int v14 = v8;
      _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEBUG,  "Attached transcriber to SpeechAnalyzer for recognition replacements %d",  (uint8_t *)&v13,  8u);
    }

    [WeakRetained setUseRecognitionReplacements:*(unsigned __int8 *)(a1 + 56)];
    [WeakRetained startRecognition:v3];
    uint64_t v9 = RXOSLog();
    uint64_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue(v9);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      int v11 = *(unsigned __int8 *)(a1 + 56);
      int v13 = 67109120;
      int v14 = v11;
      _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEFAULT,  "SpeechAnalyzerObjC recognition started for recognition replacements %d",  (uint8_t *)&v13,  8u);
    }
  }

  else
  {
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      int v12 = *(unsigned __int8 *)(a1 + 56);
      int v13 = 67109120;
      int v14 = v12;
      _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEFAULT,  "SpeechAnalyzerObjC recognition failed for recognition replacements %d",  (uint8_t *)&v13,  8u);
    }

    *(_BYTE *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL) = 0;
  }

  dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 32));
}

id RDEARCSpeechRecognizerCreate(uint64_t a1, int a2)
{
  if (!a2) {
    return _[[_EARSpeechRecognizer alloc] initWithConfiguration:a1];
  }
  BOOL v3 = CFPreferencesGetAppBooleanValue( @"UseAssetSupportForEmojiNameRecogition",  @"com.apple.SpeechRecognitionCore",  0LL) != 0;
  id v4 = objc_alloc(&OBJC_CLASS____EARSpeechRecognizer);
  uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue( +[_EARSpeechRecognitionActiveConfiguration activeConfigurationForEverything]( &OBJC_CLASS____EARSpeechRecognitionActiveConfiguration,  "activeConfigurationForEverything"));
  LOBYTE(v9) = 1;
  BYTE1(v_Block_object_dispose(va, 8) = v3;
  LOBYTE(v_Block_object_dispose(va, 8) = 0;
  id v6 = objc_msgSend( v4,  "initWithConfiguration:overrides:overrideConfigFiles:language:activeConfiguration:modelLoadingOptions:enableSpea kerCodeTraining:supportEmojiRecognition:voiceCommandActiveSet:modelContextDelegate:enableItn:",  a1,  0,  0,  0,  v5,  0,  v8,  0,  0,  v9);

  return v6;
}

CFTypeRef RDEARCSpeechRecognizerCopyUserProfileData(void *a1)
{
  return CFRetain([a1 userProfileData]);
}

id RDEARCSpeechRecognizerSetUserProfileData(void *a1, uint64_t a2)
{
  return _[a1 setUserProfileData:a2];
}

id RDEARCSpeechRecognizerUpdateUserProfileData(void *a1, uint64_t a2)
{
  return _[a1 updateUserProfileData:a2];
}

id RDEARCSpeechRecognizerSetJitProfileData(void *a1, uint64_t a2)
{
  return _[a1 setJitProfileData:a2];
}

id RDEARCSpeechRecognizerUpdateJitProfileData(void *a1, uint64_t a2)
{
  return _[a1 updateJitProfileData:a2];
}

CFTypeRef RDEARCSpeechRecognizerCopyJitProfileData(void *a1)
{
  return CFRetain([a1 jitProfileData]);
}

id RDEARCSpeechRecognizerSetLeftContext(void *a1, uint64_t a2)
{
  return _[a1 setLeftContext:a2];
}

id RDEARCSpeechRecognizerSetLeftContextText(void *a1, uint64_t a2)
{
  return _[a1 setLeftContextText:a2];
}

id RDEARCSpeechRecognizerSetDetectUtterances(void *a1, int a2)
{
  return _[a1 setDetectUtterances:a2 != 0];
}

id RDEARCSpeechRecognitionTokenGetTokenName(void *a1)
{
  return _[a1 tokenName];
}

id RDEARCSpeechRecognitionTokenGetStart(void *a1)
{
  return _[a1 start];
}

id RDEARCSpeechRecognitionTokenGetEnd(void *a1)
{
  return _[a1 end];
}

id RDEARCSpeechRecognitionTokenGetSilenceStart(void *a1)
{
  return _[a1 silenceStart];
}

id RDEARCSpeechRecognitionTokenGetConfidence(void *a1)
{
  return _[a1 confidence];
}

id RDEARCSpeechRecognitionTokenHasSpaceAfter(void *a1)
{
  return [a1 hasSpaceAfter];
}

uint64_t RDEARCSpeechRecognizerCreateRecognitionBuffer( void *a1, uint64_t a2, uint64_t a3, unsigned int a4, uint64_t a5)
{
  uint64_t v9 = -[RDEARCSpeechRecognitionResultStreamGlue initWithStream:]( objc_alloc(&OBJC_CLASS___RDEARCSpeechRecognitionResultStreamGlue),  "initWithStream:",  a5);
  if (CFPreferencesGetAppBooleanValue( @"UseAssetSupportForEmojiNameRecogition",  @"com.apple.SpeechRecognitionCore",  0LL))
  {
    [a1 setRecognizeEmoji:1];
  }

  uint64_t v10 = objc_claimAutoreleasedReturnValue([a1 runRecognitionWithResultStream:v9 language:a2 task:a3 samplingRate:a4]);

  return v10;
}

id RDEARCSpeechRecognizerSetConcatenateUtterances(void *a1, int a2)
{
  return _[a1 setConcatenateUtterances:a2 != 0];
}

id RDEARCSpeechRecognizerSetEndpointStart(void *a1)
{
  return _objc_msgSend(a1, "setEndpointStart:");
}

id RDEARCSpeechRecognizerSetRecognizeEagerCandidates(void *a1, int a2)
{
  return _[a1 setRecognizeEagerCandidates:a2 != 0];
}

id RDEARCSpeechRecognizerSetFarField(void *a1, int a2)
{
  return _[a1 setFarField:a2 != 0];
}

id RDEARCSpeechRecognizerSetHighPriority(void *a1, int a2)
{
  return _[a1 setHighPriority:a2 != 0];
}

id RDEARCSpeechRecognizerSetMaximumRecognitionDuration(void *a1)
{
  return _objc_msgSend(a1, "setMaximumRecognitionDuration:");
}

id RDEARCSpeechRecognizerSetRecognitionReplacements(void *a1, const char *a2)
{
  return [a1 setRecognitionReplacements:a2];
}

id PREARCSpeechRecognizerSetRecognitionConfidenceSubtraction(void *a1, uint64_t a2)
{
  return _[a1 setRecognitionConfidenceSubtraction:a2];
}

id RDEARCSpeechRecognizerSetInputOrigin(void *a1, uint64_t a2)
{
  return _[a1 setInputOrigin:a2];
}

id RDEARCSpeechRecognizerSetDeviceId(void *a1, uint64_t a2)
{
  return _[a1 setDeviceId:a2];
}

id RDEARCSpeechRecognizerSetRefTranscriptForErrorBlaming(void *a1, uint64_t a2)
{
  return _[a1 setRefTranscriptForErrorBlaming:a2];
}

id RDEARCSpeechRecognizerSetBluetoothDeviceId(void *a1, uint64_t a2)
{
  return _[a1 setBluetoothDeviceId:a2];
}

id RDEARCSpeechRecognizerSetUserId(void *a1, uint64_t a2)
{
  return _[a1 setUserId:a2];
}

id RDEARCSpeechRecognizerSetSessionId(void *a1, uint64_t a2)
{
  return _[a1 setSessionId:a2];
}

id RDEARCSpeechRecognitionAudioBufferAddAudioSampleData(void *a1, uint64_t a2)
{
  return _[a1 addAudioSampleData:a2];
}

id RDEARCSpeechRecognitionAudioBufferAddAudioSamples(void *a1, uint64_t a2, uint64_t a3)
{
  return _[a1 addAudioSamples:a2 count:a3];
}

id RDEARCWordPartCreate(uint64_t a1, uint64_t a2, uint64_t a3, unsigned int a4)
{
  return [[_EARWordPart alloc] initWithOrthography:a1 pronunciations:a2 tagName:a3 frequency:a4];
}

id RDEARCWordPartGetOrthography(void *a1)
{
  return _[a1 orthography];
}

id RDEARCWordPartGetTagName(void *a1)
{
  return _[a1 tagName];
}

id RDEARCWordPartGetFrequency(void *a1)
{
  return [a1 frequency];
}

id RDEARCWordPartGetPronunciations(void *a1)
{
  return _[a1 pronunciations];
}

id RDEARCUserProfileCreate( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  return [[_EARUserProfileBuilder alloc] initWithConfiguration:a1 language:a2 sdapiOverrides:a3 generalVoc:a4 emptyVoc:a5 pgVoc:a6 lexiconEnh:a7 tokenEnh:a8 paramsetHolder:a9];
}

id RDEARCUserProfileAddWord(void *a1, const char *a2, uint64_t a3)
{
  return [a1 addWordWithParts:a2 templateName:a3];
}

id RDEARCUserProfileRemoveAllWords(void *a1)
{
  return _[a1 removeAllWords];
}

uint64_t RDEARCUserProfileCopyDataProfile(void *a1)
{
  return objc_claimAutoreleasedReturnValue([a1 dataProfile]);
}

uint64_t RDEARCUserProfileCopyPronunciationsForOrthography(void *a1, uint64_t a2)
{
  return objc_claimAutoreleasedReturnValue([a1 pronunciationsForOrthography:a2]);
}

id RDEARCUserProfileReadDataProfile(void *a1, const char *a2)
{
  return [a1 readUserProfile:a2];
}

uint64_t RDEARCUserProfileCopySanitizedString(void *a1, uint64_t a2)
{
  return objc_claimAutoreleasedReturnValue([a1 sanitizedStringWithString:a2]);
}

id RDEARCUserProfileSignalEndOfUserData(void *a1)
{
  return _[a1 signalEndOfUserData];
}

id RDEARCCommandTaggerCreate(uint64_t a1, uint64_t a2)
{
  return _[[_EARCommandTagger alloc] initWithConfiguration:a1 usage:a2];
}

id RDEARCCommandTaggingGetCommandId(void *a1)
{
  return _[a1 commandId];
}

id RDEARCCommandTaggingGetTagSequence(void *a1)
{
  return _[a1 tagSequence];
}

id RDEARCCommandTaggingTokensForTag(void *a1, uint64_t a2)
{
  return _[a1 tokensForTag:a2];
}

id RDEARCCCommandTaggingResultGetCommandTaggings(void *a1)
{
  return _[a1 commandTaggings];
}

uint64_t RDEARCCommandTaggerCreateCommandTaggingResults(void *a1, uint64_t a2, uint64_t a3)
{
  return objc_claimAutoreleasedReturnValue([a1 commandTaggingFromRecognitionResult:a2 activeCommands:a3]);
}

id RDEARCCommandTaggerGetParameterTagForIndex(void *a1, unsigned int a2)
{
  return _[a1 parameterTagForIndex:a2];
}

id RDEARCCommandTaggerGetCommandPhraseForIndex(void *a1, unsigned int a2)
{
  return _[a1 commandPhraseTagForIndex:a2];
}

id RDEARCCommandTaggerIsParameterTag(void *a1, uint64_t a2)
{
  return [a1 isParameterTag:a2];
}

id RDEARCCommandTaggerIsCommandPhraseTag(void *a1, uint64_t a2)
{
  return [a1 isCommandPhraseTag:a2];
}

void RDTimer::RDTimer(RDTimer *this)
{
  *((void *)this + 1) = 0LL;
  *(void *)this = dispatch_queue_create("RDTimer", 0LL);
}

{
  *((void *)this + 1) = 0LL;
  *(void *)this = dispatch_queue_create("RDTimer", 0LL);
}

void RDTimer::~RDTimer(dispatch_object_t *this)
{
  if (this[1])
  {
    v2 = (dispatch_queue_s *)*this;
    block[0] = _NSConcreteStackBlock;
    block[1] = 0x40000000LL;
    block[2] = sub_100007B0C;
    block[3] = &unk_1000CDB38;
    block[4] = this;
    dispatch_async(v2, block);
    dispatch_release(this[1]);
  }

void RDTimer::cancelTimer(dispatch_queue_s **this)
{
  v1 = *this;
  block[0] = _NSConcreteStackBlock;
  block[1] = 0x40000000LL;
  block[2] = sub_100007B0C;
  block[3] = &unk_1000CDB38;
  block[4] = this;
  dispatch_async(v1, block);
}

void *RDTimer::setTimerForNumMilliSecs(dispatch_queue_s **a1, __int16 a2, __int16 a3, uint64_t a4)
{
  id v4 = *a1;
  block[0] = _NSConcreteStackBlock;
  block[1] = 1174405120LL;
  block[2] = sub_1000078C8;
  block[3] = &unk_1000CDB08;
  block[4] = a1;
  __int16 v10 = a2;
  __int16 v11 = a3;
  sub_100007B8C((uint64_t)v8, a4);
  dispatch_async(v4, block);
  result = v9;
  if (v9 == v8)
  {
    uint64_t v6 = 4LL;
    result = v8;
  }

  else
  {
    if (!v9) {
      return result;
    }
    uint64_t v6 = 5LL;
  }

  return (void *)(*(uint64_t (**)(void))(*result + 8 * v6))();
}

void sub_1000078C8(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  if (*(void *)(v1 + 8))
  {
    v2 = (os_log_s *)RXOSLog();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)uint64_t v9 = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_INFO,  "Timer already running. Cannot schedule another task",  v9,  2u);
    }
  }

  else
  {
    id v4 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_timer, 0LL, 0LL, *(dispatch_queue_t *)v1);
    *(void *)(v1 + _Block_object_dispose(va, 8) = v4;
    dispatch_time_t v5 = dispatch_time(0LL, 1000000LL * *(unsigned __int16 *)(a1 + 72));
    dispatch_source_set_timer(v4, v5, 0xFFFFFFFFFFFFFFFFLL, 1000000LL * *(unsigned __int16 *)(a1 + 74));
    uint64_t v6 = *(dispatch_source_s **)(v1 + 8);
    handler[0] = _NSConcreteStackBlock;
    handler[1] = 1174405120LL;
    handler[2] = sub_100007A44;
    handler[3] = &unk_1000CDAD8;
    handler[4] = v1;
    sub_100007B8C((uint64_t)v11, a1 + 40);
    dispatch_source_set_event_handler(v6, handler);
    dispatch_resume(*(dispatch_object_t *)(v1 + 8));
    uint64_t v7 = v12;
    if (v12 == v11)
    {
      uint64_t v8 = 4LL;
      uint64_t v7 = v11;
    }

    else
    {
      if (!v12) {
        return;
      }
      uint64_t v8 = 5LL;
    }

    (*(void (**)(void))(*v7 + 8 * v8))();
  }

uint64_t sub_100007A44(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  BOOL v3 = (os_log_s *)RXOSLog();
  if (os_log_type_enabled(v3, OS_LOG_TYPE_INFO))
  {
    *(_WORD *)uint64_t v6 = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_INFO, "RDTimer fired: event-handler called", v6, 2u);
  }

  uint64_t v4 = *(void *)(a1 + 64);
  if (!v4) {
    sub_100007B40();
  }
  uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)v4 + 48LL))(v4);
  *(void *)(v2 + _Block_object_dispose(va, 8) = 0LL;
  return result;
}

uint64_t sub_100007ACC(uint64_t a1, uint64_t a2)
{
  return sub_100007B8C(a1 + 40, a2 + 40);
}

void *sub_100007AD8(uint64_t a1)
{
  uint64_t v1 = (void *)(a1 + 40);
  uint64_t result = *(void **)(a1 + 64);
  if (result == v1)
  {
    uint64_t v3 = 4LL;
    uint64_t result = v1;
  }

  else
  {
    if (!result) {
      return result;
    }
    uint64_t v3 = 5LL;
  }

  return (void *)(*(uint64_t (**)(void))(*result + 8 * v3))();
}

void sub_100007B0C(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  uint64_t v2 = *(dispatch_source_s **)(v1 + 8);
  if (v2)
  {
    dispatch_source_cancel(v2);
    dispatch_release(*(dispatch_object_t *)(v1 + 8));
    *(void *)(v1 + _Block_object_dispose(va, 8) = 0LL;
  }

void sub_100007B40()
{
  exception = __cxa_allocate_exception(8uLL);
  void *exception = &off_1000CDB80;
}

void sub_100007B78(std::exception *a1)
{
}

uint64_t sub_100007B8C(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(**(void **)(a2 + 24) + 24LL))(*(void *)(a2 + 24), a1);
    }

    else
    {
      *(void *)(a1 + 24) = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 16LL))(v3);
    }
  }

  else
  {
    *(void *)(a1 + 24) = 0LL;
  }

  return a1;
}

uint64_t sub_100007F48(uint64_t a1, char a2, uint64_t a3)
{
  if (a3 || (a2 & 1) == 0)
  {
    uint64_t v6 = (os_log_s *)RXOSLog();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      int v8 = 138412290;
      uint64_t v9 = a3;
      _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_ERROR,  "Error while starting CS engine %@",  (uint8_t *)&v8,  0xCu);
    }

    char v5 = 0;
  }

  else
  {
    char v5 = 1;
  }

  *(_BYTE *)(*(void *)(a1 + 32) + 8LL) = v5;
  return dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 40));
}

uint64_t sub_10000815C(uint64_t a1, char a2, uint64_t a3)
{
  if (a3 || (a2 & 1) == 0)
  {
    char v5 = (os_log_s *)RXOSLog();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      int v7 = 138412290;
      uint64_t v8 = a3;
      _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_ERROR,  "Error while stopping CS engine %@",  (uint8_t *)&v7,  0xCu);
    }
  }

  else
  {
    *(_BYTE *)(*(void *)(a1 + 32) + 8LL) = 0;
  }

  return dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 40));
}

id sub_10000835C(uint64_t a1)
{
  int v2 = 3;
  while (1)
  {
    id result = [*(id *)(a1 + 32) startRecording];
    usleep(0xC350u);
    if (!--v2) {
      return +[AudioNotification sendLiveRecordingOffNotificationWithInterrupt:]( &OBJC_CLASS___AudioNotification,  "sendLiveRecordingOffNotificationWithInterrupt:",  1LL);
    }
  }

  return result;
}

RDQSRFileSoundSource *RDQSRSoundSource::CreateFileSource( RDQSRSoundSource *this, const __CFURL *a2, void (*a3)(RDQSRSoundSource *, const __int16 *, uint64_t), void (*a4)(RDQSRSoundSource *, const __int16 *, uint64_t))
{
  if (RXLogSound())
  {
    int v7 = (os_log_s *)RXOSLog();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)__int16 v10 = 0;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "QSR : CreateFileSource\n", v10, 2u);
    }
  }

  uint64_t v8 = (RDQSRFileSoundSource *)operator new(0x30uLL);
  RDQSRFileSoundSource::RDQSRFileSoundSource(v8, this, (void (*)(RDQSRSoundSource *))a2, a3);
  if (((*(uint64_t (**)(RDQSRFileSoundSource *))(*(void *)v8 + 56LL))(v8) & 1) == 0)
  {
    (*(void (**)(RDQSRFileSoundSource *))(*(void *)v8 + 48LL))(v8);
    uint64_t v8 = (RDQSRFileSoundSource *)operator new(0x18uLL);
    *(void *)uint64_t v8 = off_1000CDBF8;
    *((_BYTE *)v8 + _Block_object_dispose(va, 8) = 0;
    *((void *)v8 + 2) = a3;
    if (qword_1000DDCA8 != -1) {
      dispatch_once(&qword_1000DDCA8, &stru_1000CDC58);
    }
  }

  return v8;
}

void sub_10000881C(_Unwind_Exception *a1)
{
}

uint64_t RDQSRSoundSource::RDQSRSoundSource(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = off_1000CDBF8;
  *(_BYTE *)(a1 + _Block_object_dispose(va, 8) = 0;
  *(void *)(a1 + 16) = a2;
  if (qword_1000DDCA8 != -1) {
    dispatch_once(&qword_1000DDCA8, &stru_1000CDC58);
  }
  return a1;
}

RDQSRMixedSoundSource *RDQSRSoundSource::CreateMixedSource( RDQSRSoundSource *this, void (*a2)(RDQSRSoundSource *), void (*a3)(RDQSRSoundSource *))
{
  char v3 = (char)a3;
  if (RXLogSound())
  {
    uint64_t v6 = (os_log_s *)RXOSLog();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t v9 = 0;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "QSR : CreateMixedSource\n", v9, 2u);
    }
  }

  int v7 = (RDQSRMixedSoundSource *)operator new(0x48uLL);
  RDQSRMixedSoundSource::RDQSRMixedSoundSource( v7,  (void (*)(RDQSRSoundSource *, const __int16 *, uint64_t))this,  a2,  v3);
  return v7;
}

void sub_100008928(_Unwind_Exception *a1)
{
}

_BYTE *RDQSRSoundSource::CreateCannedSource( RDQSRSoundSource *this, void *a2, void (*a3)(RDQSRSoundSource *, const __int16 *, uint64_t))
{
  if (RXLogSound())
  {
    uint64_t v4 = (os_log_s *)RXOSLog();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)int v7 = 0;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "QSR : CreateCannedSource\n", v7, 2u);
    }
  }

  char v5 = operator new(0x18uLL);
  v5[8] = 0;
  *((void *)v5 + 2) = a2;
  if (qword_1000DDCA8 != -1) {
    dispatch_once(&qword_1000DDCA8, &stru_1000CDC58);
  }
  *(void *)char v5 = off_1000CDC88;
  return v5;
}

uint64_t RDQSRCannedSoundSource::RDQSRCannedSoundSource(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(void *)a1 = off_1000CDBF8;
  *(_BYTE *)(a1 + _Block_object_dispose(va, 8) = 0;
  *(void *)(a1 + 16) = a3;
  if (qword_1000DDCA8 != -1) {
    dispatch_once(&qword_1000DDCA8, &stru_1000CDC58);
  }
  *(void *)a1 = off_1000CDC88;
  return a1;
}

RDQSRLiveSoundSource *RDQSRSoundSource::CreateLiveSource( RDQSRSoundSource *this, RDAudioObject *a2, void (*a3)(RDQSRSoundSource *, const __int16 *, uint64_t))
{
  if (RXLogSound())
  {
    char v5 = (os_log_s *)RXOSLog();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t v8 = 0;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "QSR : CreateLiveSource\n", v8, 2u);
    }
  }

  uint64_t v6 = (RDQSRLiveSoundSource *)operator new(0x28uLL);
  RDQSRLiveSoundSource::RDQSRLiveSoundSource( v6,  this,  (void (*)(RDQSRSoundSource *, const __int16 *, uint64_t))a2);
  if (((*(uint64_t (**)(RDQSRLiveSoundSource *))(*(void *)v6 + 56LL))(v6) & 1) == 0)
  {
    (*(void (**)(RDQSRLiveSoundSource *))(*(void *)v6 + 48LL))(v6);
    uint64_t v6 = (RDQSRLiveSoundSource *)operator new(0x18uLL);
    *(void *)uint64_t v6 = off_1000CDBF8;
    *((_BYTE *)v6 + _Block_object_dispose(va, 8) = 0;
    *((void *)v6 + 2) = a2;
    if (qword_1000DDCA8 != -1) {
      dispatch_once(&qword_1000DDCA8, &stru_1000CDC58);
    }
  }

  return v6;
}

void sub_100008B60(_Unwind_Exception *a1)
{
}

uint64_t RDQSRSoundSource::AllowedFileTypes(RDQSRSoundSource *this)
{
  uint64_t outPropertyData = 0LL;
  UInt32 ioDataSize = 8;
  AudioFileGetGlobalInfo(0x61757469u, 0, 0LL, &ioDataSize, &outPropertyData);
  return outPropertyData;
}

void RDQSRSoundSource::RDQSRSoundSource( RDQSRSoundSource *this, void (*a2)(RDQSRSoundSource *, const __int16 *, uint64_t))
{
  *(void *)this = off_1000CDBF8;
  *((_BYTE *)this + _Block_object_dispose(va, 8) = 0;
  *((void *)this + 2) = a2;
  if (qword_1000DDCA8 != -1) {
    dispatch_once(&qword_1000DDCA8, &stru_1000CDC58);
  }
}

void sub_100008C18(id a1)
{
  uint64_t v1 = dispatch_queue_attr_make_with_qos_class(0LL, QOS_CLASS_USER_INTERACTIVE, 0);
  if (!v1) {
    sub_1000A4D38();
  }
  qword_1000DDCB0 = (uint64_t)dispatch_queue_create("RDAudioQueue", v1);
}

void RDQSRSoundSource::~RDQSRSoundSource(RDQSRSoundSource *this)
{
  *(void *)this = off_1000CDBF8;
  *((void *)this + 2) = 0LL;
}

{
  *(void *)this = off_1000CDBF8;
  *((void *)this + 2) = 0LL;
}

uint64_t RDQSRSoundSource::OK(RDQSRSoundSource *this)
{
  return 1LL;
}

void RDQSRSoundSource::EndOfUtterance(RDQSRSoundSource *this)
{
  if (RXLogSound())
  {
    uint64_t v1 = (os_log_s *)RXOSLog();
    if (os_log_type_enabled(v1, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)int v2 = 0;
      _os_log_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_DEFAULT, "SoundSource: EndOfUtterance", v2, 2u);
    }
  }

double RDQSRSoundSource::ClientFormat@<D0>(uint64_t a1@<X8>)
{
  double result = 16000.0;
  *(_OWORD *)a1 = xmmword_1000AB5B0;
  *(_OWORD *)(a1 + 16) = unk_1000AB5C0;
  *(void *)(a1 + 32) = 16LL;
  return result;
}

void RDQSRCannedSoundSource::RDQSRCannedSoundSource( RDQSRCannedSoundSource *this, void *a2, void (*a3)(RDQSRSoundSource *, const __int16 *, uint64_t))
{
  *(void *)this = off_1000CDBF8;
  *((_BYTE *)this + _Block_object_dispose(va, 8) = 0;
  *((void *)this + 2) = a3;
  if (qword_1000DDCA8 != -1) {
    dispatch_once(&qword_1000DDCA8, &stru_1000CDC58);
  }
  *(void *)this = off_1000CDC88;
}

void RDQSRMixedSoundSource::RDQSRMixedSoundSource( RDQSRMixedSoundSource *this, void (*a2)(RDQSRSoundSource *, const __int16 *, uint64_t), void (*a3)(RDQSRSoundSource *), char a4)
{
  *(void *)this = off_1000CDBF8;
  *((_BYTE *)this + _Block_object_dispose(va, 8) = 0;
  *((void *)this + 2) = a2;
  if (qword_1000DDCA8 != -1) {
    dispatch_once(&qword_1000DDCA8, &stru_1000CDC58);
  }
  *(void *)this = off_1000CDCD8;
  *((_WORD *)this + 16) = 0;
  *((void *)this + 5) = a3;
  *((_WORD *)this + 24) = 257;
  *((_BYTE *)this + 50) = a4;
  if ((a4 & 1) == 0) {
    atomic_store(0, (unsigned __int8 *)this + 48);
  }
  int v7 = RDCopyCacheURL();
  if (v7)
  {
    *((void *)this + 7) = CFURLCreateCopyAppendingPathComponent(0LL, v7, @"synthesizedText.caf", 0);
    CFRelease(v7);
  }

void sub_100008E50(_Unwind_Exception *a1)
{
  void *v1 = v2;
  v1[2] = 0LL;
  _Unwind_Resume(a1);
}

void RDQSRMixedSoundSource::SynthesizeText( RDQSRMixedSoundSource *this, const __CFString *a2, const __CFString *a3)
{
  if (*((_BYTE *)this + 64))
  {
    RDString::RDString((RDString *)__p, a2, 0);
    uint64_t v6 = (os_log_s *)RXOSLog();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      int v7 = __p;
      if (v10 < 0) {
        int v7 = (void **)__p[0];
      }
      LODWORD(buf) = 136315138;
      *(void *)((char *)&buf + 4) = v7;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "Synthesizing text %s", (uint8_t *)&buf, 0xCu);
    }

    *(void *)&__int128 buf = this;
    *((void *)&buf + 1) = RDQSRMixedSoundSource::DidFinishSpeakingCallback;
    CFMutableStringRef MutableCopy = CFStringCreateMutableCopy(0LL, 0LL, a3);
    v12.length = CFStringGetLength(MutableCopy);
    v12.location = 0LL;
    CFStringFindAndReplace(MutableCopy, @"_", @"-", v12, 0LL);
    RDSpeakStringToURL((uint64_t)a2, (uint64_t)MutableCopy, *((void *)this + 7), (uint64_t)&buf);
    CFRelease(MutableCopy);
    if (v10 < 0) {
      operator delete(__p[0]);
    }
  }

void sub_100008FA0( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void RDQSRMixedSoundSource::DidFinishSpeakingCallback(CFURLRef *this, void *a2)
{
  char v3 = (os_log_s *)RXOSLog();
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v4 = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_DEFAULT,  "Finished Synthesizing, sending the audio samples",  v4,  2u);
  }

  RDQSRMixedSoundSource::DidFinishSpeaking((RDQSRMixedSoundSource *)this, this[7]);
}

void RDQSRMixedSoundSource::ReadAudioFile(RDQSRMixedSoundSource *this, const __CFString *a2)
{
  uint64_t v4 = RDCopyCacheURL();
  if (v4)
  {
    char v5 = v4;
    CFURLRef v6 = CFURLCreateCopyAppendingPathComponent(0LL, v4, a2, 0);
    if (v6)
    {
      int v7 = v6;
      uint64_t v8 = (os_log_s *)RXOSLog();
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
      {
        int v9 = 138412290;
        char v10 = a2;
        _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEFAULT,  "Reading audio file %@",  (uint8_t *)&v9,  0xCu);
      }

      RDQSRMixedSoundSource::DidFinishSpeaking(this, v7);
      CFRelease(v7);
    }

    CFRelease(v5);
  }

void RDQSRMixedSoundSource::DidFinishSpeaking(RDQSRMixedSoundSource *this, CFURLRef inURL)
{
  if (ExtAudioFileOpenURL(inURL, (ExtAudioFileRef *)this + 3))
  {
    atomic_store(0, (unsigned __int8 *)this + 32);
  }

  else
  {
    v3[0] = xmmword_1000AB5B0;
    v3[1] = unk_1000AB5C0;
    uint64_t v4 = 16LL;
    ExtAudioFileSetProperty(*((ExtAudioFileRef *)this + 3), 0x63666D74u, 0x28u, v3);
    atomic_store(1u, (unsigned __int8 *)this + 49);
    atomic_store(1u, (unsigned __int8 *)this + 32);
    RDQSRMixedSoundSource::ReadAudio(this);
  }

void RDQSRMixedSoundSource::ReadAudio(RDQSRMixedSoundSource *this)
{
  dispatch_queue_global_t global_queue = dispatch_get_global_queue(0LL, 0LL);
  block[0] = _NSConcreteStackBlock;
  block[1] = 0x40000000LL;
  block[2] = sub_100009574;
  block[3] = &unk_1000CDD78;
  block[4] = this;
  dispatch_async(global_queue, block);
}

void RDQSRMixedSoundSource::SendNoise(RDQSRMixedSoundSource *this)
{
  dispatch_time_t v2 = dispatch_time(0LL, 100000000LL);
  dispatch_queue_global_t global_queue = dispatch_get_global_queue(0LL, 0LL);
  block[0] = _NSConcreteStackBlock;
  block[1] = 0x40000000LL;
  block[2] = sub_1000092A0;
  block[3] = &unk_1000CDD38;
  block[4] = this;
  dispatch_after(v2, global_queue, block);
}

void sub_1000092A0(uint64_t a1)
{
  uint64_t v1 = *(unsigned __int8 **)(a1 + 32);
  unsigned __int8 v2 = atomic_load(v1 + 49);
  if ((v2 & 1) != 0)
  {
    atomic_store(0, v1 + 48);
  }

  else
  {
    sub_10000947C(&v12);
    std::random_device::result_type v3 = std::random_device::operator()(&v12);
    v10[0] = v3;
    for (uint64_t i = 1LL; i != 624; ++i)
    {
      std::random_device::result_type v3 = i + 1812433253 * (v3 ^ (v3 >> 30));
      v10[i] = v3;
    }

    uint64_t v5 = 0LL;
    uint64_t v11 = 0LL;
    __int128 v8 = xmmword_1000AB5A0;
    char v9 = 0;
    do
    {
      *(_WORD *)&v15[v5] = (int)(sub_10000A414((uint64_t)&v8, (uint64_t)v10, (double *)&v8) * 32765.0);
      v5 += 2LL;
    }

    while (v5 != 1024);
    if (RXLogSound() && RXVeryVerbose())
    {
      CFURLRef v6 = (os_log_s *)RXOSLog();
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)__int128 buf = 134217984;
        uint64_t v14 = 512LL;
        _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "Queueing %zu frames\n", buf, 0xCu);
      }
    }

    v7[0] = _NSConcreteStackBlock;
    v7[1] = 0x40000000LL;
    v7[2] = sub_1000094EC;
    v7[3] = &unk_1000CDD18;
    v7[4] = v1;
    v7[5] = v15;
    dispatch_sync((dispatch_queue_t)qword_1000DDCB0, v7);
    RDQSRMixedSoundSource::SendNoise((RDQSRMixedSoundSource *)v1);
    std::random_device::~random_device(&v12);
  }

void sub_100009454(_Unwind_Exception *a1)
{
}

std::random_device *sub_10000947C(std::random_device *a1)
{
  return a1;
}

void sub_1000094D0( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1000094EC(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 32);
  if (*(void *)(v1 + 16))
  {
    uint64_t v2 = result;
    std::random_device::result_type v3 = (os_log_s *)RXOSLog();
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)uint64_t v4 = 0;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEBUG, "noise samples", v4, 2u);
    }

    return (*(uint64_t (**)(uint64_t, void, uint64_t))(v1 + 16))(v1, *(void *)(v2 + 40), 512LL);
  }

  return result;
}

void sub_100009574(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  UInt32 ioNumberFrames = 2048;
  ioData.mNumberBuffers = 1;
  *(void *)&ioData.mBuffers[0].mNumberChannels = 0x100000000001LL;
  ioData.mBuffers[0].mData = v15;
  unsigned __int8 v2 = atomic_load((unsigned __int8 *)(v1 + 33));
  if ((v2 & 1) != 0 || ExtAudioFileRead(*(ExtAudioFileRef *)(v1 + 24), &ioNumberFrames, &ioData)) {
    UInt32 ioNumberFrames = 0;
  }
  if (RXLogSound())
  {
    if (RXVeryVerbose())
    {
      std::random_device::result_type v3 = (os_log_s *)RXOSLog();
      if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)__int128 buf = 134218240;
        uint64_t v12 = v1;
        __int16 v13 = 1024;
        UInt32 v14 = ioNumberFrames;
        _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "%p Queueing %u frames\n", buf, 0x12u);
      }
    }
  }

  if (ioNumberFrames)
  {
    block[0] = _NSConcreteStackBlock;
    block[1] = 0x40000000LL;
    block[2] = sub_10000974C;
    block[3] = &unk_1000CDD58;
    block[4] = v1;
    void block[5] = v15;
    UInt32 v8 = ioNumberFrames;
    dispatch_sync((dispatch_queue_t)qword_1000DDCB0, block);
    RDQSRMixedSoundSource::ReadAudio((RDQSRMixedSoundSource *)v1);
  }

  else
  {
    unsigned __int8 v4 = atomic_load((unsigned __int8 *)(v1 + 32));
    if ((v4 & 1) != 0)
    {
      ExtAudioFileDispose(*(ExtAudioFileRef *)(v1 + 24));
      atomic_store(0, (unsigned __int8 *)(v1 + 32));
      if (!*(_BYTE *)(v1 + 50))
      {
        uint64_t v5 = *(void (**)(uint64_t))(v1 + 40);
        if (v5) {
          v5(v1);
        }
      }
    }

    if (*(_BYTE *)(v1 + 50))
    {
      atomic_store(0, (unsigned __int8 *)(v1 + 49));
      unsigned __int8 v6 = atomic_load((unsigned __int8 *)(v1 + 48));
      if ((v6 & 1) == 0)
      {
        atomic_store(1u, (unsigned __int8 *)(v1 + 48));
        RDQSRMixedSoundSource::SendNoise((RDQSRMixedSoundSource *)v1);
      }
    }
  }

uint64_t sub_10000974C(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 32);
  if (*(void *)(v1 + 16))
  {
    uint64_t v2 = result;
    std::random_device::result_type v3 = (os_log_s *)RXOSLog();
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)unsigned __int8 v4 = 0;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEBUG, "audio samples", v4, 2u);
    }

    return (*(uint64_t (**)(uint64_t, void, void))(v1 + 16))( v1,  *(void *)(v2 + 40),  *(unsigned int *)(v2 + 48));
  }

  return result;
}

void RDQSRMixedSoundSource::SetMicOn(RDQSRMixedSoundSource *this)
{
  if (RXLogSound())
  {
    uint64_t v2 = (os_log_s *)RXOSLog();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)unsigned __int8 v4 = 0;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Mixed : SetMicOn\n", v4, 2u);
    }
  }

  *((_BYTE *)this + 64) = 1;
  unsigned __int8 v3 = atomic_load((unsigned __int8 *)this + 32);
  if ((v3 & 1) == 0)
  {
    atomic_store(0, (unsigned __int8 *)this + 33);
    if (*((_BYTE *)this + 50))
    {
      atomic_store(0, (unsigned __int8 *)this + 49);
      RDQSRMixedSoundSource::SendNoise(this);
    }
  }

void RDQSRMixedSoundSource::SetMicOff(RDQSRMixedSoundSource *this)
{
  if (RXLogSound())
  {
    uint64_t v2 = (os_log_s *)RXOSLog();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)unsigned __int8 v3 = 0;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Mixed : SetMicOff\n", v3, 2u);
    }
  }

  if (*((_BYTE *)this + 64))
  {
    atomic_store(1u, (unsigned __int8 *)this + 49);
    atomic_store(1u, (unsigned __int8 *)this + 33);
    *((_BYTE *)this + 64) = 0;
  }

void RDQSRMixedSoundSource::~RDQSRMixedSoundSource(RDQSRMixedSoundSource *this)
{
  *(void *)this = off_1000CDCD8;
  uint64_t v2 = (const void *)*((void *)this + 7);
  if (v2) {
    CFRelease(v2);
  }
  uint64_t v5 = 0LL;
  unsigned __int8 v6 = &v5;
  uint64_t v7 = 0x2000000000LL;
  char v8 = 0;
  do
  {
    block[0] = _NSConcreteStackBlock;
    block[1] = 0x40000000LL;
    block[2] = sub_100009A68;
    block[3] = &unk_1000CDDA0;
    block[4] = &v5;
    void block[5] = this;
    dispatch_sync((dispatch_queue_t)qword_1000DDCB0, block);
    if (*((_BYTE *)v6 + 24)) {
      break;
    }
    usleep(0x1388u);
  }

  while (!*((_BYTE *)v6 + 24));
  _Block_object_dispose(&v5, 8);
  uint64_t v5 = 0LL;
  unsigned __int8 v6 = &v5;
  uint64_t v7 = 0x2000000000LL;
  char v8 = 0;
  do
  {
    v3[0] = _NSConcreteStackBlock;
    v3[1] = 0x40000000LL;
    _OWORD v3[2] = sub_100009A94;
    v3[3] = &unk_1000CDDC8;
    v3[4] = &v5;
    v3[5] = this;
    dispatch_sync((dispatch_queue_t)qword_1000DDCB0, v3);
    if (*((_BYTE *)v6 + 24)) {
      break;
    }
    usleep(0x1388u);
  }

  while (!*((_BYTE *)v6 + 24));
  _Block_object_dispose(&v5, 8);
  *(void *)this = off_1000CDBF8;
  *((void *)this + 2) = 0LL;
}

{
  void *v1;
  RDQSRMixedSoundSource::~RDQSRMixedSoundSource(this);
  operator delete(v1);
}

void sub_100009A58(void *a1)
{
}

uint64_t sub_100009A68(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 40);
  atomic_store(1u, (unsigned __int8 *)(v1 + 49));
  LOBYTE(v1) = atomic_load((unsigned __int8 *)(v1 + 48));
  if ((v1 & 1) == 0) {
    *(_BYTE *)(*(void *)(*(void *)(result + 32) + 8LL) + 24LL) = 1;
  }
  return result;
}

uint64_t sub_100009A94(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 40);
  atomic_store(1u, (unsigned __int8 *)(v1 + 33));
  LOBYTE(v1) = atomic_load((unsigned __int8 *)(v1 + 32));
  if ((v1 & 1) == 0) {
    *(_BYTE *)(*(void *)(*(void *)(result + 32) + 8LL) + 24LL) = 1;
  }
  return result;
}

void RDQSRFileSoundSource::RDQSRFileSoundSource( RDQSRFileSoundSource *this, CFURLRef inURL, void (*a3)(RDQSRSoundSource *), void (*a4)(RDQSRSoundSource *, const __int16 *, uint64_t))
{
  *(void *)this = off_1000CDBF8;
  *((_BYTE *)this + _Block_object_dispose(va, 8) = 0;
  *((void *)this + 2) = a4;
  if (qword_1000DDCA8 != -1) {
    dispatch_once(&qword_1000DDCA8, &stru_1000CDC58);
  }
  *(void *)this = off_1000CDDF8;
  *((_WORD *)this + 16) = 1;
  *((void *)this + 5) = a3;
  if (ExtAudioFileOpenURL(inURL, (ExtAudioFileRef *)this + 3))
  {
    *((_BYTE *)this + 32) = 0;
  }

  else
  {
    v7[0] = xmmword_1000AB5B0;
    v7[1] = unk_1000AB5C0;
    uint64_t v8 = 16LL;
    ExtAudioFileSetProperty(*((ExtAudioFileRef *)this + 3), 0x63666D74u, 0x28u, v7);
  }

void sub_100009BB0(_Unwind_Exception *a1)
{
  void *v1 = v2;
  v1[2] = 0LL;
  _Unwind_Resume(a1);
}

void RDQSRFileSoundSource::~RDQSRFileSoundSource(RDQSRFileSoundSource *this)
{
  *(void *)this = off_1000CDDF8;
  uint64_t v3 = 0LL;
  unsigned __int8 v4 = &v3;
  uint64_t v5 = 0x2000000000LL;
  char v6 = 0;
  do
  {
    v2[0] = _NSConcreteStackBlock;
    v2[1] = 0x40000000LL;
    v2[2] = sub_100009CA4;
    v2[3] = &unk_1000CDE40;
    v2[4] = &v3;
    v2[5] = this;
    dispatch_sync((dispatch_queue_t)qword_1000DDCB0, v2);
    if (*((_BYTE *)v4 + 24)) {
      break;
    }
    usleep(0x1388u);
  }

  while (!*((_BYTE *)v4 + 24));
  _Block_object_dispose(&v3, 8);
  *(void *)this = off_1000CDBF8;
  *((void *)this + 2) = 0LL;
}

{
  void *v1;
  RDQSRFileSoundSource::~RDQSRFileSoundSource(this);
  operator delete(v1);
}

uint64_t sub_100009CA4(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 40);
  *(_BYTE *)(v1 + 33) = 1;
  if (!*(_BYTE *)(v1 + 32)) {
    *(_BYTE *)(*(void *)(*(void *)(result + 32) + 8LL) + 24LL) = 1;
  }
  return result;
}

BOOL RDQSRFileSoundSource::OK(RDQSRFileSoundSource *this)
{
  return *((void *)this + 3) != 0LL;
}

void RDQSRFileSoundSource::SetMicOn(RDQSRFileSoundSource *this)
{
  dispatch_queue_global_t global_queue = dispatch_get_global_queue(0LL, 0LL);
  block[0] = _NSConcreteStackBlock;
  block[1] = 0x40000000LL;
  block[2] = sub_100009D5C;
  block[3] = &unk_1000CDE80;
  block[4] = this;
  dispatch_async(global_queue, block);
}

void sub_100009D5C(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  UInt32 ioNumberFrames = 2048;
  ioData.mNumberBuffers = 1;
  *(void *)&ioData.mBuffers[0].mNumberChannels = 0x100000000001LL;
  ioData.mBuffers[0].mData = v12;
  if (*(_BYTE *)(v1 + 33) || ExtAudioFileRead(*(ExtAudioFileRef *)(v1 + 24), &ioNumberFrames, &ioData)) {
    UInt32 ioNumberFrames = 0;
  }
  if (RXLogSound())
  {
    if (RXVeryVerbose())
    {
      uint64_t v2 = (os_log_s *)RXOSLog();
      if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)__int128 buf = 134218240;
        uint64_t v9 = v1;
        __int16 v10 = 1024;
        UInt32 v11 = ioNumberFrames;
        _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "%p Queueing %u frames\n", buf, 0x12u);
      }
    }
  }

  if (ioNumberFrames)
  {
    block[0] = _NSConcreteStackBlock;
    block[1] = 0x40000000LL;
    block[2] = sub_100009EF0;
    block[3] = &unk_1000CDE60;
    block[4] = v1;
    void block[5] = v12;
    UInt32 v5 = ioNumberFrames;
    dispatch_sync((dispatch_queue_t)qword_1000DDCB0, block);
    (**(void (***)(uint64_t))v1)(v1);
  }

  else if (*(_BYTE *)(v1 + 32))
  {
    ExtAudioFileDispose(*(ExtAudioFileRef *)(v1 + 24));
    uint64_t v3 = *(void (**)(uint64_t))(v1 + 40);
    if (v3) {
      v3(v1);
    }
    *(_BYTE *)(v1 + 32) = 0;
  }

uint64_t sub_100009EF0(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 32);
  uint64_t v2 = *(uint64_t (**)(void))(result + 16);
  if (v2) {
    return v2();
  }
  return result;
}

void RDQSRFileSoundSource::SetMicOff(RDQSRFileSoundSource *this)
{
  if (RXLogSound())
  {
    uint64_t v1 = (os_log_s *)RXOSLog();
    if (os_log_type_enabled(v1, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t v2 = 0;
      _os_log_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_DEFAULT, "AudioFile : SetMicOff", v2, 2u);
    }
  }

void RDQSRLiveSoundSource::RDQSRLiveSoundSource( RDQSRLiveSoundSource *this, RDAudioObject *a2, void (*a3)(RDQSRSoundSource *, const __int16 *, uint64_t))
{
  *(void *)this = off_1000CDBF8;
  *((_BYTE *)this + _Block_object_dispose(va, 8) = 0;
  *((void *)this + 2) = a3;
  if (qword_1000DDCA8 != -1) {
    dispatch_once(&qword_1000DDCA8, &stru_1000CDC58);
  }
  *(void *)this = off_1000CDEB0;
  v7[1] = 0x40000000LL;
  _OWORD v7[2] = sub_10000A058;
  v7[3] = &unk_1000CDEF0;
  v7[4] = this;
  v5[0] = xmmword_1000AB5B0;
  v5[1] = unk_1000AB5C0;
  uint64_t v6 = 16LL;
  v7[0] = _NSConcreteStackBlock;
  *((void *)this + 3) = RDSoundInput::CreateSoundInput((uint64_t)a2, 1LL, (uint64_t)v5, (uint64_t)v7);
}

void sub_10000A04C(_Unwind_Exception *a1)
{
  void *v1 = v2;
  v1[2] = 0LL;
  _Unwind_Resume(a1);
}

uint64_t sub_10000A058(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 32);
  uint64_t v2 = *(uint64_t (**)(void))(result + 16);
  if (v2) {
    return v2();
  }
  return result;
}

void RDQSRLiveSoundSource::~RDQSRLiveSoundSource(RDQSRLiveSoundSource *this)
{
  *(void *)this = off_1000CDEB0;
  uint64_t v2 = *((void *)this + 3);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8LL))(v2);
  }
  *(void *)this = off_1000CDBF8;
  *((void *)this + 2) = 0LL;
  *((void *)this + 3) = 0LL;
}

{
  uint64_t v2;
  *(void *)this = off_1000CDEB0;
  uint64_t v2 = *((void *)this + 3);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8LL))(v2);
  }
  *(void *)this = off_1000CDBF8;
  *((void *)this + 2) = 0LL;
  *((void *)this + 3) = 0LL;
}

{
  uint64_t v2;
  *(void *)this = off_1000CDEB0;
  uint64_t v2 = *((void *)this + 3);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8LL))(v2);
  }
  operator delete(this);
}

BOOL RDQSRLiveSoundSource::OK(RDQSRLiveSoundSource *this)
{
  return *((void *)this + 3) != 0LL;
}

uint64_t RDQSRLiveSoundSource::SetMicOn(RDQSRLiveSoundSource *this)
{
  if (RXLogSound())
  {
    uint64_t v2 = (os_log_s *)RXOSLog();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)unsigned __int8 v4 = 0;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Live : SetMicOn", v4, 2u);
    }
  }

  uint64_t result = *((void *)this + 3);
  if (result)
  {
    uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)result + 32LL))(result);
    if ((result & 1) == 0)
    {
      uint64_t result = (*(uint64_t (**)(void))(**((void **)this + 3) + 16LL))(*((void *)this + 3));
      *((_BYTE *)this + 32) = result;
    }
  }

  return result;
}

uint64_t RDQSRLiveSoundSource::SetMicOff(RDQSRLiveSoundSource *this)
{
  if (RXLogSound())
  {
    uint64_t v2 = (os_log_s *)RXOSLog();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)unsigned __int8 v4 = 0;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Live : SetMicOff", v4, 2u);
    }
  }

  uint64_t result = (*(uint64_t (**)(void))(**((void **)this + 3) + 32LL))(*((void *)this + 3));
  if ((_DWORD)result) {
    return (*(uint64_t (**)(void))(**((void **)this + 3) + 24LL))(*((void *)this + 3));
  }
  return result;
}

uint64_t RDQSRLiveSoundSource::EndOfUtterance(RDQSRLiveSoundSource *this)
{
  uint64_t result = (*(uint64_t (**)(void))(**((void **)this + 3) + 32LL))(*((void *)this + 3));
  if ((_DWORD)result) {
    return (*(uint64_t (**)(void))(**((void **)this + 3) + 24LL))(*((void *)this + 3));
  }
  return result;
}

void *sub_10000A2C4(void *result)
{
  void *result = off_1000CDBF8;
  result[2] = 0LL;
  return result;
}

void *sub_10000A2DC(void *a1, char *__s)
{
  size_t v4 = strlen(__s);
  if (v4 >= 0x7FFFFFFFFFFFFFF8LL) {
    sub_10000A38C();
  }
  size_t v5 = v4;
  if (v4 >= 0x17)
  {
    uint64_t v7 = (v4 & 0xFFFFFFFFFFFFFFF8LL) + 8;
    if ((v4 | 7) != 0x17) {
      uint64_t v7 = v4 | 7;
    }
    uint64_t v8 = v7 + 1;
    uint64_t v6 = operator new(v7 + 1);
    a1[1] = v5;
    a1[2] = v8 | 0x8000000000000000LL;
    *a1 = v6;
  }

  else
  {
    *((_BYTE *)a1 + 23) = v4;
    uint64_t v6 = a1;
    if (!v4) {
      goto LABEL_9;
    }
  }

  memmove(v6, __s, v5);
LABEL_9:
  *((_BYTE *)v6 + v5) = 0;
  return a1;
}

void sub_10000A38C()
{
}

void sub_10000A3A0(const char *a1)
{
  exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
  sub_10000A3F0(exception, a1);
}

void sub_10000A3DC(_Unwind_Exception *a1)
{
}

std::logic_error *sub_10000A3F0(std::logic_error *a1, const char *a2)
{
  uint64_t result = std::logic_error::logic_error(a1, a2);
  return result;
}

double sub_10000A414(uint64_t a1, uint64_t a2, double *a3)
{
  if (*(_BYTE *)(a1 + 24))
  {
    *(_BYTE *)(a1 + 24) = 0;
    double v5 = *(double *)(a1 + 16);
  }

  else
  {
    do
    {
      do
      {
        double v7 = (double)sub_10000A52C(a2);
        double v8 = (v7 + (double)sub_10000A52C(a2) * 4294967300.0) * 5.42101086e-20 * 2.0 + -1.0;
        double v9 = (double)sub_10000A52C(a2);
        double v10 = (v9 + (double)sub_10000A52C(a2) * 4294967300.0) * 5.42101086e-20 * 2.0 + -1.0;
        double v11 = v10 * v10 + v8 * v8;
      }

      while (v11 > 1.0);
    }

    while (v11 == 0.0);
    double v12 = sqrt(log(v10 * v10 + v8 * v8) * -2.0 / v11);
    *(double *)(a1 + 16) = v10 * v12;
    *(_BYTE *)(a1 + 24) = 1;
    double v5 = v8 * v12;
  }

  return *a3 + v5 * a3[1];
}

uint64_t sub_10000A52C(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 2496);
  unint64_t v2 = (v1 + 1) % 0x270uLL;
  unsigned int v3 = *(_DWORD *)(a1 + 4 * ((v1 + 397) % 0x270uLL)) ^ ((*(_DWORD *)(a1 + 4 * v2) & 0x7FFFFFFE | *(_DWORD *)(a1 + 4 * v1) & 0x80000000) >> 1) ^ ((int)(*(_DWORD *)(a1 + 4 * v2) << 31) >> 31) & 0x9908B0DF;
  *(_DWORD *)(a1 + 4 * v1) = v3;
  *(void *)(a1 + 2496) = v2;
  LODWORD(v1) = ((v3 ^ (v3 >> 11)) << 7) & 0x9D2C5680 ^ v3 ^ (v3 >> 11);
  return ((_DWORD)v1 << 15) & 0xEFC60000 ^ v1 ^ ((((_DWORD)v1 << 15) & 0xEFC60000 ^ v1) >> 18);
}

void RDAudioObject::RDAudioObject(RDAudioObject *this, xpc_object_t object)
{
  *(void *)this = 0LL;
  *((_DWORD *)this + 2) = 0;
  if (object)
  {
    if (xpc_get_type(object) == (xpc_type_t)&_xpc_type_string)
    {
      *(void *)this = _CFXPCCreateCFObjectFromXPCObject(object);
    }

    else if (xpc_get_type(object) == (xpc_type_t)&_xpc_type_uint64)
    {
      *((_DWORD *)this + 2) = xpc_uint64_get_value(object);
    }
  }

uint64_t RDAudioObject::RDAudioObject(uint64_t a1, uint64_t a2)
{
  unsigned int v3 = *(const void **)a2;
  *(void *)a1 = *(void *)a2;
  *(_DWORD *)(a1 + _Block_object_dispose(va, 8) = *(_DWORD *)(a2 + 8);
  if (v3) {
    CFRetain(v3);
  }
  return a1;
}

{
  const void *v3;
  unsigned int v3 = *(const void **)a2;
  *(void *)a1 = *(void *)a2;
  *(_DWORD *)(a1 + _Block_object_dispose(va, 8) = *(_DWORD *)(a2 + 8);
  if (v3) {
    CFRetain(v3);
  }
  return a1;
}

void RDAudioObject::~RDAudioObject(const void **this)
{
  uint64_t v1 = *this;
  if (v1) {
    CFRelease(v1);
  }
}

uint64_t RDAudioObject::ObjectID(RDAudioObject *this)
{
  return 0LL;
}

void *RDSoundInput::CreateSoundInput(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  double v7 = operator new(0x28uLL);
  RDSoundInputiOS::RDSoundInputiOS(v7, a1, a3, a4);
  return v7;
}

void sub_10000A744(_Unwind_Exception *a1)
{
}

uint64_t RDSoundInput::RDSoundInput(uint64_t a1, uint64_t a2, char a3, int a4)
{
  double v7 = *(const void **)a2;
  *(void *)a1 = off_1000CDF90;
  *(void *)(a1 + _Block_object_dispose(va, 8) = v7;
  *(_DWORD *)(a1 + 16) = *(_DWORD *)(a2 + 8);
  if (v7) {
    CFRetain(v7);
  }
  *(_BYTE *)(a1 + 24) = a3;
  *(_DWORD *)(a1 + 2_Block_object_dispose(va, 8) = a4;
  return a1;
}

void sub_10000A7F4(id a1)
{
  qword_1000DDCC0 = objc_alloc_init(&OBJC_CLASS___RDSpeechSynthesis);
}

void sub_10000A9C8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

void sub_10000A9E0(uint64_t a1, uint64_t a2)
{
}

void sub_10000A9F0(uint64_t a1)
{
}

void sub_10000A9FC(uint64_t a1, void *a2)
{
  if (a2)
  {
    if ([a2 frameLength])
    {
      size_t v4 = *(void **)(*(void *)(*(void *)(a1 + 40) + 8LL) + 40LL);
      if (!v4)
      {
        *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 40) = -[AVAudioFile initForWriting:settings:commonFormat:interleaved:error:]( [AVAudioFile alloc],  "initForWriting:settings:commonFormat:interleaved:error:",  *(void *)(a1 + 32),  objc_msgSend( objc_msgSend(a2, "format"),  "settings"),  objc_msgSend( objc_msgSend(a2, "format"),  "commonFormat"),  objc_msgSend( objc_msgSend(a2, "format"),  "isInterleaved"),  0);
        size_t v4 = *(void **)(*(void *)(*(void *)(a1 + 40) + 8LL) + 40LL);
      }

      _[v4 writeFromBuffer:a2 error:0];
    }
  }

  else
  {
    NSLog(@"TTS Error initializing buffer");
  }

id RDSpeakStringToURL(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return _objc_msgSend( +[RDSpeechSynthesis sharedManager](RDSpeechSynthesis, "sharedManager"),  "speakString:toURL:withLanguageCode:withCallback:",  a1,  a3,  a2,  a4);
}

void sub_10000AC60( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

void sub_10000AC78(uint64_t a1, uint64_t a2)
{
}

void sub_10000AC88(uint64_t a1)
{
}

Class sub_10000AC94(uint64_t a1)
{
  unsigned int v3 = 0LL;
  if (!qword_1000DDCD0)
  {
    __int128 v4 = off_1000CE038;
    uint64_t v5 = 0LL;
    qword_1000DDCD0 = _sl_dlopen(&v4, &v3);
  }

  if (!qword_1000DDCD0) {
    sub_1000A4D68(&v3);
  }
  if (v3) {
    free(v3);
  }
  Class result = objc_getClass("AXSystemAppServer");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 40LL) = result;
  if (!*(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 40LL)) {
    sub_1000A4DCC();
  }
  qword_1000DDCC8 = *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 40LL);
  return result;
}

id sub_10000B588(uint64_t a1)
{
  return [*(id *)(a1 + 32) startRecording:0];
}

LABEL_19:
    LOBYTE(v7) = 1;
    return v7;
  }

  if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)__int128 buf = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_ERROR,  "AVI:Could not start recording from AV, deactivating the audio session",  buf,  2u);
  }

  v19 = -[AVAudioSession setActive:withOptions:error:]( +[AVAudioSession sharedInstance](&OBJC_CLASS___AVAudioSession, "sharedInstance"),  "setActive:withOptions:error:",  0LL,  1LL,  &v27);
  v20 = (os_log_s *)RXOSLog();
  uint64_t v5 = v20;
  if ((v19 & 1) == 0)
  {
    double v7 = os_log_type_enabled(v20, OS_LOG_TYPE_ERROR);
    if (!v7) {
      return v7;
    }
    v24 = v27;
    v25 = [v27 localizedDescription];
    *(_DWORD *)__int128 buf = 138412546;
    v29 = v24;
    v30 = 2112;
    v31 = v25;
    double v8 = "AVI:AVAudioSession could not deactivate, error code:{%@}, error message: {%@}";
    double v9 = v5;
LABEL_30:
    double v10 = OS_LOG_TYPE_ERROR;
    double v11 = 22;
    goto LABEL_7;
  }

  v21 = os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT);
  LOBYTE(v7) = 0;
  if (!v21) {
    return v7;
  }
  *(_WORD *)__int128 buf = 0;
  double v8 = "AVI:Could not start recording from AV, Audio Session deactivated";
LABEL_6:
  double v9 = v5;
  double v10 = OS_LOG_TYPE_DEFAULT;
  double v11 = 2;
LABEL_7:
  _os_log_impl((void *)&_mh_execute_header, v9, v10, v8, buf, v11);
  LOBYTE(v7) = 0;
  return v7;
}

void sub_10000BAC4(uint64_t a1, uint64_t a2)
{
  __int128 v4 = *(dispatch_queue_s **)(*(void *)(a1 + 32) + 16LL);
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472LL;
  block[2] = sub_10000BB68;
  block[3] = &unk_1000CE058;
  objc_copyWeak(&v6, &location);
  block[4] = a2;
  dispatch_async(v4, block);
  objc_destroyWeak(&v6);
  objc_destroyWeak(&location);
}

id sub_10000BB68(uint64_t a1)
{
  id Weak = objc_loadWeak((id *)(a1 + 40));
  return _[Weak _appendPCMBuffer:*(void *)(a1 + 32)];
}

id sub_10000BD70(uint64_t a1)
{
  return [*(id *)(a1 + 32) _drainAndClearAudioConverter];
}

void sub_10000C184( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
}

uint64_t sub_10000C1A8(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v3 = *(void *)(*(void *)(a1 + 40) + 8LL);
  if (*(_BYTE *)(v3 + 24))
  {
    uint64_t result = 0LL;
    *a3 = 1LL;
  }

  else
  {
    *(_BYTE *)(v3 + 24) = 1;
    *a3 = 0LL;
    return *(void *)(a1 + 32);
  }

  return result;
}

AVAudioBuffer *__cdecl sub_10000C3A0(id a1, unsigned int a2, int64_t *a3)
{
  *a3 = 2LL;
  return 0LL;
}

LABEL_16:
        LOBYTE(v7) = 1;
        return v7;
      }

      -[AVSoundInput stopRecording](self, "stopRecording");
      -[AVSoundInput activateNotifications](self, "activateNotifications");
    }

    v32 = 0LL;
    v15 = -[AVSoundInput setupAudioSession](self, "setupAudioSession");
    v16 = (os_log_s *)RXOSLog();
    v17 = v16;
    if ((v15 & 1) == 0)
    {
      double v7 = os_log_type_enabled(v16, OS_LOG_TYPE_ERROR);
      if (v7)
      {
        *(_WORD *)__int128 buf = 0;
        double v8 = "AVAudioSession setup failed";
        double v9 = v17;
        double v10 = OS_LOG_TYPE_ERROR;
        goto LABEL_27;
      }

      return v7;
    }

    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
    {
      isUsingTelephonyVAD = self->_isUsingTelephonyVAD;
      *(_DWORD *)__int128 buf = 67109120;
      LODWORD(v34) = isUsingTelephonyVAD;
      _os_log_impl( (void *)&_mh_execute_header,  v17,  OS_LOG_TYPE_DEFAULT,  "Starting to record from AV and isUsingTelephonyVAD = %d",  buf,  8u);
    }

    if (-[AVAudioSession setActive:error:]( +[AVAudioSession sharedInstance](&OBJC_CLASS___AVAudioSession, "sharedInstance"),  "setActive:error:",  1LL,  &v32))
    {
      v19 = -[AVSoundInput startRunningAudioEngine](self, "startRunningAudioEngine");
      v20 = (os_log_s *)RXOSLog();
      v21 = v20;
      if (v19)
      {
        if (!os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_16;
        }
        v22 = self->_isUsingTelephonyVAD;
        *(_DWORD *)__int128 buf = 67109120;
        LODWORD(v34) = v22;
        double v12 = "Started Recording from AV and isUsingTelephonyVAD = %d";
        __int16 v13 = v21;
        UInt32 v14 = 8;
        goto LABEL_15;
      }

      if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)__int128 buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v21,  OS_LOG_TYPE_ERROR,  "Could not start recording from AV, deactivating the audio session",  buf,  2u);
      }

      v26 = -[AVAudioSession setActive:withOptions:error:]( +[AVAudioSession sharedInstance](&OBJC_CLASS___AVAudioSession, "sharedInstance"),  "setActive:withOptions:error:",  0LL,  1LL,  &v32);
      v27 = (os_log_s *)RXOSLog();
      uint64_t v5 = v27;
      if ((v26 & 1) != 0)
      {
        v28 = os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT);
        LOBYTE(v7) = 0;
        if (!v28) {
          return v7;
        }
        *(_WORD *)__int128 buf = 0;
        double v8 = "Could not start recording from AV, Audio Session deactivated";
        goto LABEL_4;
      }

      double v7 = os_log_type_enabled(v27, OS_LOG_TYPE_ERROR);
      if (!v7) {
        return v7;
      }
      v29 = v32;
      v30 = [v32 localizedDescription];
      *(_DWORD *)__int128 buf = 138412546;
      v34 = v29;
      v35 = 2112;
      v36 = v30;
      double v8 = "AVAudioSession could not deactivate, error code:{%@}, error message: {%@}";
    }

    else
    {
      uint64_t v5 = (os_log_s *)RXOSLog();
      double v7 = os_log_type_enabled(v5, OS_LOG_TYPE_ERROR);
      if (!v7) {
        return v7;
      }
      v24 = v32;
      v25 = [v32 localizedDescription];
      *(_DWORD *)__int128 buf = 138412546;
      v34 = v24;
      v35 = 2112;
      v36 = v25;
      double v8 = "AVAudioSession set active failed with error code:{%@}, error message: {%@}";
    }

    double v9 = v5;
    double v10 = OS_LOG_TYPE_ERROR;
    v23 = 22;
    goto LABEL_28;
  }

  uint64_t v5 = (os_log_s *)RXOSLog();
  id v6 = os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT);
  LOBYTE(v7) = 0;
  if (v6)
  {
    *(_WORD *)__int128 buf = 0;
    double v8 = "System is sleeping, so don't start recording";
LABEL_4:
    double v9 = v5;
    double v10 = OS_LOG_TYPE_DEFAULT;
LABEL_27:
    v23 = 2;
LABEL_28:
    _os_log_impl((void *)&_mh_execute_header, v9, v10, v8, buf, v23);
    LOBYTE(v7) = 0;
  }

  return v7;
}

  if (v14 == a3
    || (v15 = *v14, v15 == 93)
    || (v16 = v14 + 1, v14 + 1 == a3)
    || v15 != 45
    || *v16 == 93)
  {
    if ((char)v26.__r_.__value_.__s.__size_ < 0)
    {
      if (v26.__r_.__value_.__l.__size_)
      {
        if (v26.__r_.__value_.__l.__size_ != 1)
        {
          v17 = (std::string *)v26.__r_.__value_.__r.__words[0];
LABEL_36:
          sub_100020D38( v6,  v17->__r_.__value_.__s.__data_[0],  v17->__r_.__value_.__s.__data_[1]);
          goto LABEL_37;
        }

        v17 = (std::string *)v26.__r_.__value_.__r.__words[0];
        goto LABEL_28;
      }
    }

    else if (v26.__r_.__value_.__s.__size_)
    {
      v17 = &v26;
      if (v26.__r_.__value_.__s.__size_ != 1) {
        goto LABEL_36;
      }
LABEL_28:
      sub_10001ECBC(v6, v17->__r_.__value_.__s.__data_[0]);
    }

  if (*((void *)&v15 + 1)) {
    --**((_DWORD **)&v15 + 1);
  }
LABEL_18:
  double v10 = (uint64_t *)a1[2];
  double v11 = (uint64_t *)a1[3];
  double v12 = 126 - 2 * __clz(((char *)v11 - (char *)v10) >> 4);
  if (v11 == v10) {
    __int16 v13 = 0LL;
  }
  else {
    __int16 v13 = v12;
  }
  sub_100062FA8(v10, v11, (uint64_t)&v14, v13, 1);
}

  if (*((void *)&v15 + 1)) {
    --**((_DWORD **)&v15 + 1);
  }
LABEL_18:
  double v10 = (uint64_t *)a1[2];
  double v11 = (uint64_t *)a1[3];
  double v12 = 126 - 2 * __clz(((char *)v11 - (char *)v10) >> 4);
  if (v11 == v10) {
    __int16 v13 = 0LL;
  }
  else {
    __int16 v13 = v12;
  }
  sub_100064304(v10, v11, (uint64_t)&v14, v13, 1);
}

void sub_10000D074(uint64_t a1, uint64_t a2)
{
  __int128 v4 = *(dispatch_queue_s **)(*(void *)(a1 + 32) + 16LL);
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472LL;
  block[2] = sub_10000D118;
  block[3] = &unk_1000CE058;
  objc_copyWeak(&v6, &location);
  block[4] = a2;
  dispatch_async(v4, block);
  objc_destroyWeak(&v6);
  objc_destroyWeak(&location);
}

id sub_10000D118(uint64_t a1)
{
  id Weak = objc_loadWeak((id *)(a1 + 40));
  return _[Weak _appendPCMBuffer:*(void *)(a1 + 32)];
}

id sub_10000D2B0(uint64_t a1)
{
  return [*(id *)(a1 + 32) _drainAndClearAudioConverter];
}

void sub_10000D400(id a1)
{
  uint64_t v1 = (os_log_s *)RXOSLog();
  if (os_log_type_enabled(v1, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)unint64_t v2 = 0;
    _os_log_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_DEFAULT, "wait for the async blocks", v2, 2u);
  }

void sub_10000D74C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
}

uint64_t sub_10000D770(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v3 = *(void *)(*(void *)(a1 + 40) + 8LL);
  if (*(_BYTE *)(v3 + 24))
  {
    uint64_t result = 0LL;
    *a3 = 1LL;
  }

  else
  {
    *(_BYTE *)(v3 + 24) = 1;
    *a3 = 0LL;
    return *(void *)(a1 + 32);
  }

  return result;
}

AVAudioBuffer *__cdecl sub_10000D968(id a1, unsigned int a2, int64_t *a3)
{
  *a3 = 2LL;
  return 0LL;
}

void sub_10000DB7C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, id location)
{
}

void sub_10000DB98(uint64_t a1, void *a2)
{
  if (a2)
  {
    int v3 = AFPreferencesAssistantEnabled();
    __int128 v4 = (os_log_s *)RXOSLog();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v5 = @"Disabled";
      if (v3) {
        uint64_t v5 = @"Enabled";
      }
      int v6 = 138543362;
      double v7 = v5;
      _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEFAULT,  "Siri Enabled = %{public}@",  (uint8_t *)&v6,  0xCu);
    }

    [a2 _didReceiveSiriSettingChanged:v3 != 0];
  }

id sub_10000E018(uint64_t a1)
{
  return [*(id *)(a1 + 32) stopRecording];
}

id sub_10000E1A8(uint64_t a1)
{
  return +[AudioNotification sendLiveRecordingOffNotificationWithInterrupt:]( &OBJC_CLASS___AudioNotification,  "sendLiveRecordingOffNotificationWithInterrupt:",  1LL);
}

id sub_10000E1CC(uint64_t a1)
{
  return +[AudioNotification sendLiveRecordingOnNotification]( &OBJC_CLASS___AudioNotification,  "sendLiveRecordingOnNotification");
}

id sub_10000E3B4(uint64_t a1)
{
  id result = [*(id *)(a1 + 32) isRecording];
  if ((_DWORD)result) {
    return [*(id *)(a1 + 32) stopRecording];
  }
  return result;
}

id sub_10000E4D4(uint64_t a1)
{
  return [*(id *)(a1 + 32) startRecording:0];
}

id sub_10000E798(uint64_t a1)
{
  return [*(id *)(a1 + 32) stopRecording];
}

id sub_10000E7A0(uint64_t a1)
{
  unint64_t v2 = (os_log_s *)RXOSLog();
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)__int128 v4 = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "No one listening, start AV", v4, 2u);
  }

  id result = [*(id *)(a1 + 32) startRecording:0];
  if ((result & 1) == 0) {
    return +[AudioNotification sendLiveRecordingOffNotificationWithInterrupt:]( &OBJC_CLASS___AudioNotification,  "sendLiveRecordingOffNotificationWithInterrupt:",  1LL);
  }
  return result;
}

uint64_t RDQSRAudioFileLogger::openAudioFile( ExtAudioFileRef *outExtAudioFile, CFURLRef inURL, AudioStreamBasicDescription *a3, AudioFileTypeID inFileType)
{
  OSStatus v7 = ExtAudioFileCreateWithURL(inURL, inFileType, a3, 0LL, 1u, outExtAudioFile);
  uint64_t v8 = (__int16)v7;
  if (v7 << 16)
  {
    double v9 = (os_log_s *)RXOSLog();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      int v11 = 138543618;
      CFURLRef v12 = inURL;
      __int16 v13 = 1024;
      int v14 = v8;
      _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_ERROR,  "Error creating output file %{public}@, err: %{errno}d",  (uint8_t *)&v11,  0x12u);
    }
  }

  else
  {
    ExtAudioFileSetProperty(*outExtAudioFile, 0x63666D74u, 0x28u, a3);
    CFURLSetResourcePropertyForKey( inURL,  kCFURLFileProtectionKey,  kCFURLFileProtectionCompleteUntilFirstUserAuthentication,  0LL);
  }

  return v8;
}

uint64_t RDQSRAudioFileLogger::addSamples(ExtAudioFileRef *this, __int16 *a2, uint64_t inNumberFrames)
{
  if (inNumberFrames < 1)
  {
    LOWORD(v3) = 0;
  }

  else
  {
    ioData.mNumberBuffers = 1;
    ioData.mBuffers[0].mNumberChannels = 1;
    ioData.mBuffers[0].mDataByteSize = 2 * inNumberFrames;
    ioData.mBuffers[0].mData = a2;
    OSStatus v3 = ExtAudioFileWrite(*this, inNumberFrames, &ioData);
    if (v3)
    {
      __int128 v4 = (os_log_s *)RXOSLog();
      if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)__int128 buf = 67109120;
        OSStatus v8 = v3;
        _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_ERROR,  "RDQSRAudioFileLogger::addSamples Error writing to output wav file,err: %{errno}d",  buf,  8u);
      }
    }
  }

  return (__int16)v3;
}

void RDQSRAudioFileLogger::~RDQSRAudioFileLogger(OpaqueExtAudioFile **this)
{
  uint64_t v1 = *this;
  if (v1) {
    ExtAudioFileDispose(v1);
  }
}

uint64_t RDQSRAudioFileLogger::audioFileLoggerQueue(RDQSRAudioFileLogger *this)
{
  if (qword_1000DDCD8 != -1) {
    dispatch_once(&qword_1000DDCD8, &stru_1000CE188);
  }
  return qword_1000DDCE0;
}

void sub_10000EAB8(id a1)
{
  qword_1000DDCE0 = (uint64_t)dispatch_queue_create("RDQSRLoggerQueue", 0LL);
}

const __CFURL *RDQSRAudioFileLogger::createCacheURLWithFilename( const __CFString *this, const __CFString *a2)
{
  id result = RDCopyCacheURL();
  if (result)
  {
    __int128 v4 = result;
    CFURLRef v5 = CFURLCreateCopyAppendingPathComponent(0LL, result, this, 1u);
    CFRelease(v4);
    return v5;
  }

  return result;
}

double RDQSRAudioFileLogger::aiffFormat@<D0>(uint64_t a1@<X8>)
{
  double result = 16000.0;
  *(_OWORD *)a1 = xmmword_1000AB680;
  *(_OWORD *)(a1 + 16) = unk_1000AB690;
  *(void *)(a1 + 32) = 16LL;
  return result;
}

double RDQSRAudioFileLogger::wavFormat@<D0>(uint64_t a1@<X8>)
{
  double result = 16000.0;
  *(_OWORD *)a1 = xmmword_1000AB6A8;
  *(_OWORD *)(a1 + 16) = unk_1000AB6B8;
  *(void *)(a1 + 32) = 16LL;
  return result;
}

uint64_t RDQSRCircularBuffer<short>::RDQSRCircularBuffer(uint64_t a1, unsigned int a2)
{
  *(_DWORD *)(a1 + _Block_object_dispose(va, 8) = a2;
  *(void *)a1 = operator new[](2LL * a2);
  *(void *)(a1 + 20) = 0LL;
  *(void *)(a1 + 12) = 0LL;
  return a1;
}

{
  *(_DWORD *)(a1 + _Block_object_dispose(va, 8) = a2;
  *(void *)a1 = operator new[](2LL * a2);
  *(void *)(a1 + 20) = 0LL;
  *(void *)(a1 + 12) = 0LL;
  return a1;
}

uint64_t RDQSRCircularBuffer<short>::reset(uint64_t result)
{
  *(void *)(result + 20) = 0LL;
  *(void *)(result + 12) = 0LL;
  return result;
}

void *RDQSRCircularBuffer<short>::write(uint64_t a1, char *__src, unsigned int a3)
{
  __int128 v4 = __src;
  size_t v6 = 2 * a3;
  uint64_t v7 = *(unsigned int *)(a1 + 12);
  unsigned int v8 = *(_DWORD *)(a1 + 8) - v7;
  if (v8 >= a3)
  {
    double v10 = (void *)(*(void *)a1 + 2 * v7);
  }

  else
  {
    size_t v9 = v6 - 2 * v8;
    memcpy((void *)(*(void *)a1 + 2 * v7), __src, 2 * v8);
    double v10 = *(void **)a1;
    __src = &v4[2 * v8];
    size_t v6 = v9;
  }

  double result = memcpy(v10, __src, v6);
  int v12 = *(_DWORD *)(a1 + 24);
  unsigned int v13 = (*(_DWORD *)(a1 + 12) + a3) % *(_DWORD *)(a1 + 8);
  *(_DWORD *)(a1 + 12) = v13;
  *(void *)(a1 + 16) = v13;
  *(_DWORD *)(a1 + 24) = v12 + a3;
  return result;
}

{
  return __ZN19RDQSRCircularBufferIsE5writeEPKsj(a1, __src, a3);
}

unint64_t RDQSRCircularBuffer<short>::read(uint64_t a1, unint64_t a2, char *__dst)
{
  int v5 = *(_DWORD *)(a1 + 8);
  uint64_t v6 = *(unsigned int *)(a1 + 16);
  else {
    unint64_t v7 = (v5 - *(_DWORD *)(a1 + 20));
  }
  size_t v8 = (2 * v7);
  unint64_t v9 = (v5 - v6);
  if (v7 <= v9)
  {
    int v12 = (const void *)(*(void *)a1 + 2 * v6);
    int v11 = __dst;
  }

  else
  {
    size_t v10 = (v8 - 2 * v9);
    memcpy(__dst, (const void *)(*(void *)a1 + 2 * v6), (2 * v9));
    int v11 = &__dst[2 * v9];
    int v12 = *(const void **)a1;
    size_t v8 = v10;
  }

  memcpy(v11, v12, v8);
  unint64_t v13 = *(unsigned int *)(a1 + 8);
  unsigned int v14 = *(_DWORD *)(a1 + 20) + v7;
  *(_DWORD *)(a1 + 16) = (v7 + *(unsigned int *)(a1 + 16)) % v13;
  *(_DWORD *)(a1 + 20) = v14;
  return v7;
}

{
  return __ZN19RDQSRCircularBufferIsE4readEmPs(a1, a2, __dst);
}

void **RDQSRCircularBuffer<short>::~RDQSRCircularBuffer(void **a1)
{
  unint64_t v2 = *a1;
  if (v2) {
    operator delete[](v2);
  }
  *a1 = 0LL;
  return a1;
}

{
  void *v2;
  unint64_t v2 = *a1;
  if (v2) {
    operator delete[](v2);
  }
  *a1 = 0LL;
  return a1;
}

RDSAPIObjCSpeechAnalyzer *RDSAPICSpeechAnalyzerCreate(uint64_t a1)
{
  uint64_t v1 = -[RDSAPIObjCSpeechAnalyzer initWithLocale:]( objc_alloc(&OBJC_CLASS___RDSAPIObjCSpeechAnalyzer),  "initWithLocale:",  a1);
  uint64_t v2 = RXOSLog();
  OSStatus v3 = (os_log_s *)objc_claimAutoreleasedReturnValue(v2);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)int v5 = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "SpeechAnalyzerC initialized", v5, 2u);
  }

  return v1;
}

id RDSAPICSpeechAnalyzerCreateRecognitionBuffer(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  id v5 = [a1 createRecognitionBufferWithDelegate:a5 task:a3];
  uint64_t v6 = RXOSLog();
  unint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue(v6);
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)unint64_t v9 = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEFAULT,  "SpeechAnalyzerC AudioBuffer initialized",  v9,  2u);
  }

  return v5;
}

id RDSAPICSpeechAnalyzerAddAudioSamples(void *a1, uint64_t a2, uint64_t a3)
{
  return _[a1 addAudioSamples:a2 count:a3];
}

id RDSAPICSpeechAnalyzerTranscriptionTokenGetTokenName(void *a1)
{
  return _[a1 tokenName];
}

id RDSAPICSpeechAnalyzerTranscriptionTokenGetStart(void *a1)
{
  return _[a1 start];
}

id RDSAPICSpeechAnalyzerTranscriptionTokenGetEnd(void *a1)
{
  return _[a1 end];
}

id RDSAPICSpeechAnalyzerTranscriptionTokenGetSilenceStart(void *a1)
{
  return _[a1 silenceStart];
}

id RDSAPICSpeechAnalyzerTranscriptionTokenGetConfidence(void *a1)
{
  return _[a1 confidence];
}

id RDSAPICSpeechAnalyzerTranscriptionTokenHasSpaceAfter(void *a1)
{
  return [a1 hasSpaceAfter];
}

CFTypeRef RDSAPICSpeechAnalyzerCopyUserProfileData(void *a1)
{
  return CFRetain([a1 getUserProfileData]);
}

id RDSAPICSpeechAnalyzerUpdateUserProfileData(void *a1, uint64_t a2)
{
  return _[a1 setUserProfileData:a2];
}

id RDSAPICSpeechAnalyzerSetUserProfileData(void *a1, uint64_t a2)
{
  return _[a1 setUserProfileData:a2];
}

CFTypeRef RDSAPICSpeechAnalyzerCopyJitProfileData(void *a1)
{
  return CFRetain([a1 getJitProfileData]);
}

id RDSAPICSpeechAnalyzerSetJitProfileData(void *a1, uint64_t a2)
{
  return _[a1 setJitProfileData:a2];
}

id RDSAPICSpeechAnalyzerUpdateJitProfileData(void *a1, uint64_t a2)
{
  return _[a1 setJitProfileData:a2];
}

id RDSAPICSpeechAnalyzerSetLeftContextText(void *a1, uint64_t a2)
{
  return _[a1 setLeftContextText:a2];
}

id RDSAPICSpeechAnalyzerSetRecognitionReplacements(void *a1, const char *a2)
{
  return [a1 setRecognitionReplacements:a2];
}

void sub_10000F2A0(id a1)
{
  byte_1000DDCE9 = MGGetBoolAnswer(@"ExclaveCapability");
}

LABEL_30:
  +[AudioNotification sendLiveRecordingOffNotificationWithInterrupt:]( &OBJC_CLASS___AudioNotification,  "sendLiveRecordingOffNotificationWithInterrupt:",  1LL);
  return 0;
}

      v43 = (char *)*a1;
      *a1 = v34;
      a1[1] = v35;
      a1[2] = v8;
      a1[3] = v37;
      if (v43)
      {
        operator delete(v43);
        size_t v8 = (char *)a1[2];
      }

      goto LABEL_33;
    }

    goto LABEL_5;
  }

  if (v23 == *a1) {
    v25 = 1LL;
  }
  else {
    v25 = v24 >> 2;
  }
  v56 = a1 + 3;
  *(void *)&v54 = sub_100018788((uint64_t)(a1 + 3), v25);
  *((void *)&v54 + 1) = v54 + 8 * v22;
  *(void *)&v55 = *((void *)&v54 + 1);
  *((void *)&v55 + 1) = v54 + 8 * v26;
  v53 = operator new(0xFC0uLL);
  sub_1000247E0(&v54, &v53);
  v27 = (void *)a1[2];
  v28 = -7LL - (void)v27;
  while (v27 != (void *)a1[1])
  {
    --v27;
    v28 += 8LL;
    sub_1000248F4((uint64_t)&v54, v27);
  }

  v29 = (char *)*a1;
  v30 = v54;
  v31 = v55;
  *(void *)&v54 = *a1;
  *((void *)&v54 + 1) = v27;
  v32 = *((_OWORD *)a1 + 1);
  *(_OWORD *)a1 = v30;
  *((_OWORD *)a1 + 1) = v31;
  v55 = v32;
  if (v27 != (void *)v32) {
    *(void *)&v55 = v32 + (-(v32 + v28) & 0xFFFFFFFFFFFFFFF8LL);
  }
  if (v29) {
    operator delete(v29);
  }
}

      v43 = (char *)*a1;
      *a1 = v34;
      a1[1] = v35;
      a1[2] = v8;
      a1[3] = v37;
      if (v43)
      {
        operator delete(v43);
        size_t v8 = (char *)a1[2];
      }

      goto LABEL_33;
    }

    goto LABEL_5;
  }

  if (v23 == *a1) {
    v25 = 1LL;
  }
  else {
    v25 = v24 >> 2;
  }
  v56 = a1 + 3;
  *(void *)&v54 = sub_100018788((uint64_t)(a1 + 3), v25);
  *((void *)&v54 + 1) = v54 + 8 * v22;
  *(void *)&v55 = *((void *)&v54 + 1);
  *((void *)&v55 + 1) = v54 + 8 * v26;
  v53 = operator new(0x1000uLL);
  sub_1000247E0(&v54, &v53);
  v27 = (void *)a1[2];
  v28 = -7LL - (void)v27;
  while (v27 != (void *)a1[1])
  {
    --v27;
    v28 += 8LL;
    sub_1000248F4((uint64_t)&v54, v27);
  }

  v29 = (char *)*a1;
  v30 = v54;
  v31 = v55;
  *(void *)&v54 = *a1;
  *((void *)&v54 + 1) = v27;
  v32 = *((_OWORD *)a1 + 1);
  *(_OWORD *)a1 = v30;
  *((_OWORD *)a1 + 1) = v31;
  v55 = v32;
  if (v27 != (void *)v32) {
    *(void *)&v55 = v32 + (-(v32 + v28) & 0xFFFFFFFFFFFFFFF8LL);
  }
  if (v29) {
    operator delete(v29);
  }
}

  return v4;
}

  double result = _fatalErrorMessage(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  "UnsafeMutablePointer.initialize overlapping range",  49LL,  2LL,  "Swift/UnsafePointer.swift",  25LL,  2,  1092LL,  0);
  __break(1u);
  return result;
}

        v26 = v59;
LABEL_31:
        v27 = v45;
        if (*v5)
        {
          ++*(_DWORD *)(*(void *)(a1 + 224) + 80LL * v60);
          (*(void (**)(float *__return_ptr, uint64_t, uint64_t))(*(void *)v45 + 24LL))(&v56, v45, v26);
          v28 = sub_10002ADB0();
          *(float *)&v46 = v56;
          LODWORD(v53) = *v28;
          v27 = v45;
          if (v56 != *(float *)&v53)
          {
            v29 = *(void *)(a1 + 224) + 80LL * v60;
            ++*(_DWORD *)(v29 + 4);
          }
        }

        v48 = 0LL;
        v46 = 0u;
        v47 = 0u;
        (*(void (**)(uint64_t, uint64_t, __int128 *))(*(void *)v27 + 120LL))(v27, v26, &v46);
        while (1)
        {
          if ((void)v46)
          {
            if ((*(unsigned int (**)(void))(*(void *)v46 + 16LL))(v46))
            {
              if ((void)v46)
              {
                (*(void (**)(void))(*(void *)v46 + 8LL))(v46);
                goto LABEL_54;
              }

      v43 = (char *)*a1;
      *a1 = v34;
      a1[1] = v35;
      a1[2] = v8;
      a1[3] = v37;
      if (v43)
      {
        operator delete(v43);
        size_t v8 = (char *)a1[2];
      }

      goto LABEL_33;
    }

    goto LABEL_5;
  }

  if (v23 == *a1) {
    v25 = 1LL;
  }
  else {
    v25 = v24 >> 2;
  }
  v56 = a1 + 3;
  *(void *)&v54 = sub_100018788((uint64_t)(a1 + 3), v25);
  *((void *)&v54 + 1) = v54 + 8 * v22;
  *(void *)&v55 = *((void *)&v54 + 1);
  *((void *)&v55 + 1) = v54 + 8 * v26;
  v53 = operator new(0x1000uLL);
  sub_1000247E0(&v54, &v53);
  v27 = (void *)a1[2];
  v28 = -7LL - (void)v27;
  while (v27 != (void *)a1[1])
  {
    --v27;
    v28 += 8LL;
    sub_1000248F4((uint64_t)&v54, v27);
  }

  v29 = (char *)*a1;
  v30 = v54;
  v31 = v55;
  *(void *)&v54 = *a1;
  *((void *)&v54 + 1) = v27;
  v32 = *((_OWORD *)a1 + 1);
  *(_OWORD *)a1 = v30;
  *((_OWORD *)a1 + 1) = v31;
  v55 = v32;
  if (v27 != (void *)v32) {
    *(void *)&v55 = v32 + (-(v32 + v28) & 0xFFFFFFFFFFFFFFF8LL);
  }
  if (v29) {
    operator delete(v29);
  }
}

      v43 = (char *)*a1;
      *a1 = v34;
      a1[1] = v35;
      a1[2] = v8;
      a1[3] = v37;
      if (v43)
      {
        operator delete(v43);
        size_t v8 = (char *)a1[2];
      }

      goto LABEL_33;
    }

    goto LABEL_5;
  }

  if (v23 == *a1) {
    v25 = 1LL;
  }
  else {
    v25 = v24 >> 2;
  }
  v56 = a1 + 3;
  *(void *)&v54 = sub_100018788((uint64_t)(a1 + 3), v25);
  *((void *)&v54 + 1) = v54 + 8 * v22;
  *(void *)&v55 = *((void *)&v54 + 1);
  *((void *)&v55 + 1) = v54 + 8 * v26;
  v53 = operator new(0x1000uLL);
  sub_1000247E0(&v54, &v53);
  v27 = (void *)a1[2];
  v28 = -7LL - (void)v27;
  while (v27 != (void *)a1[1])
  {
    --v27;
    v28 += 8LL;
    sub_1000248F4((uint64_t)&v54, v27);
  }

  v29 = (char *)*a1;
  v30 = v54;
  v31 = v55;
  *(void *)&v54 = *a1;
  *((void *)&v54 + 1) = v27;
  v32 = *((_OWORD *)a1 + 1);
  *(_OWORD *)a1 = v30;
  *((_OWORD *)a1 + 1) = v31;
  v55 = v32;
  if (v27 != (void *)v32) {
    *(void *)&v55 = v32 + (-(v32 + v28) & 0xFFFFFFFFFFFFFFF8LL);
  }
  if (v29) {
    operator delete(v29);
  }
}

      v43 = (char *)*a1;
      *a1 = v34;
      a1[1] = v35;
      a1[2] = v8;
      a1[3] = v37;
      if (v43)
      {
        operator delete(v43);
        size_t v8 = (char *)a1[2];
      }

      goto LABEL_33;
    }

    goto LABEL_5;
  }

  if (v23 == *a1) {
    v25 = 1LL;
  }
  else {
    v25 = v24 >> 2;
  }
  v56 = a1 + 3;
  *(void *)&v54 = sub_100018788((uint64_t)(a1 + 3), v25);
  *((void *)&v54 + 1) = v54 + 8 * v22;
  *(void *)&v55 = *((void *)&v54 + 1);
  *((void *)&v55 + 1) = v54 + 8 * v26;
  v53 = operator new(0x1000uLL);
  sub_1000247E0(&v54, &v53);
  v27 = (void *)a1[2];
  v28 = -7LL - (void)v27;
  while (v27 != (void *)a1[1])
  {
    --v27;
    v28 += 8LL;
    sub_1000248F4((uint64_t)&v54, v27);
  }

  v29 = (char *)*a1;
  v30 = v54;
  v31 = v55;
  *(void *)&v54 = *a1;
  *((void *)&v54 + 1) = v27;
  v32 = *((_OWORD *)a1 + 1);
  *(_OWORD *)a1 = v30;
  *((_OWORD *)a1 + 1) = v31;
  v55 = v32;
  if (v27 != (void *)v32) {
    *(void *)&v55 = v32 + (-(v32 + v28) & 0xFFFFFFFFFFFFFFF8LL);
  }
  if (v29) {
    operator delete(v29);
  }
}

    *a3 = v19 & 1;
    goto LABEL_31;
  }

  memset(&v46, 0, sizeof(v46));
  v25 = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 120LL))(a2);
  v26 = (*(uint64_t (**)(uint64_t, void))(*(void *)a2 + 64LL))(a2, 0LL);
  if (v25)
  {
    v27 = v26;
    v28 = 0LL;
    v29 = 1;
    while (1)
    {
      (*(void (**)(void **__return_ptr, uint64_t, uint64_t))(*(void *)a2 + 72LL))(__p, a2, v27);
      v30 = (*(uint64_t (**)(void *, void **))(*v6 + 80LL))(v6, __p);
      if (SHIBYTE(cap) < 0) {
        operator delete(__p[0]);
      }
      if (v30 == -1) {
        break;
      }
      v19 |= v30 != v27;
LABEL_60:
      if (++v28 < v25) {
        v27 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a2 + 64LL))(a2, v28);
      }
      if (v25 == v28) {
        goto LABEL_65;
      }
    }

    (*(void (**)(void **__return_ptr, void *, uint64_t))(*v6 + 72LL))(__p, v6, v27);
    if (SHIBYTE(cap) < 0)
    {
      v33 = __p[1];
      operator delete(__p[0]);
      if (!v33) {
        goto LABEL_45;
      }
LABEL_42:
      (*(void (**)(std::string *__return_ptr, uint64_t, uint64_t))(*(void *)a2 + 72LL))(&v45, a2, v27);
      size = (_OWORD *)v46.__r_.__value_.__l.__size_;
      if (v46.__r_.__value_.__l.__size_ >= v46.__r_.__value_.__l.__cap_)
      {
        v35 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v46.__r_.__value_.__l.__size_ - v46.__r_.__value_.__r.__words[0]) >> 3);
        v36 = v35 + 1;
        if (v35 + 1 > 0xAAAAAAAAAAAAAAALL) {
          sub_100018774();
        }
        else {
          v37 = v36;
        }
        p_cap = &v46.__r_.__value_.__l.__cap_;
        if (v37) {
          v38 = (char *)sub_100018F00((uint64_t)&v46.__r_.__value_.__l.__cap_, v37);
        }
        else {
          v38 = 0LL;
        }
        v39 = &v38[24 * v35];
        __p[0] = v38;
        __p[1] = v39;
        v49 = &v38[24 * v37];
        v40 = *(_OWORD *)&v45.__r_.__value_.__l.__data_;
        *((void *)v39 + 2) = v45.__r_.__value_.__l.__cap_;
        *(_OWORD *)v39 = v40;
        memset(&v45, 0, sizeof(v45));
        cap = v39 + 24;
        sub_100021168((uint64_t *)&v46, __p);
        v41 = v46.__r_.__value_.__l.__size_;
        sub_1000212F0((uint64_t)__p);
        v46.__r_.__value_.__l.__size_ = v41;
        if ((char)v45.__r_.__value_.__s.__size_ < 0)
        {
          v34 = (void *)v45.__r_.__value_.__r.__words[0];
LABEL_58:
          operator delete(v34);
        }
      }

      else
      {
        v32 = *(_OWORD *)&v45.__r_.__value_.__l.__data_;
        *(void *)(v46.__r_.__value_.__l.__size_ + 16) = v45.__r_.__value_.__l.__cap_;
        *size = v32;
        v46.__r_.__value_.__l.__size_ = (std::string::size_type)size + 24;
      }
    }

    else
    {
      if (HIBYTE(cap)) {
        goto LABEL_42;
      }
LABEL_45:
      (*(void (**)(void **__return_ptr, uint64_t, uint64_t))(*(void *)a2 + 72LL))(__p, a2, v27);
      (*(void (**)(void *, void **, uint64_t))(*v6 + 24LL))(v6, __p, v27);
      if (SHIBYTE(cap) < 0)
      {
        v34 = __p[0];
        goto LABEL_58;
      }
    }

    v29 = 0;
    goto LABEL_60;
  }

  v29 = 1;
LABEL_65:
  if (v44) {
    *v44 = v19 & 1;
  }
  if ((v29 & 1) != 0)
  {
    v23 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 16LL))(a1);
    __p[0] = &v46;
    sub_10001FAA8((void ***)__p);
LABEL_32:
    (*(void (**)(void *))(*v6 + 8LL))(v6);
    return (void *)v23;
  }

  else
  {
    v43 = v46.__r_.__value_.__l.__size_;
    for (uint64_t i = v46.__r_.__value_.__r.__words[0]; i != v43; i += 24LL)
      (*(void (**)(void *, std::string::size_type))(*v6 + 32LL))(v6, i);
    __p[0] = &v46;
    sub_10001FAA8((void ***)__p);
  }

  return v6;
}

id sub_10000FB2C(uint64_t a1)
{
  return [*(id *)(a1 + 32) startRecording:0];
}

id sub_10000FB98(uint64_t a1)
{
  uint64_t v2 = (os_log_s *)RXOSLog();
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = *(void *)(a1 + 32);
    int v5 = 138412290;
    uint64_t v6 = v3;
    _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEFAULT,  "Some client active did change  = %@",  (uint8_t *)&v5,  0xCu);
  }

  return [*(id *)(a1 + 40) startRecording:0];
}

id sub_10000FDB0(uint64_t a1)
{
  uint64_t v2 = (os_log_s *)RXOSLog();
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = *(void *)(a1 + 32);
    int v5 = 138412290;
    uint64_t v6 = v3;
    _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEFAULT,  "RDSoundInputImpl:Call started ringing = %@",  (uint8_t *)&v5,  0xCu);
  }

  return [*(id *)(a1 + 40) startRecording:1];
}

id sub_10000FE58(uint64_t a1)
{
  uint64_t v2 = (os_log_s *)RXOSLog();
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = *(void *)(a1 + 32);
    int v5 = 138412290;
    uint64_t v6 = v3;
    _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEFAULT,  "RDSoundInputImpl:Call disconnected = %@",  (uint8_t *)&v5,  0xCu);
  }

  return [*(id *)(a1 + 40) startRecording:0];
}

BOOL rd_userprofile_util::doesSupportCategory(void *__s)
{
  uint64_t v1 = __s;
  if (*((char *)__s + 23) < 0)
  {
    uint64_t v2 = __s[1];
    if (!v2) {
      return 0LL;
    }
    uint64_t v1 = (void *)*__s;
  }

  else
  {
    uint64_t v2 = *((unsigned __int8 *)__s + 23);
    if (!*((_BYTE *)__s + 23)) {
      return 0LL;
    }
  }

  if (v2 >= 10)
  {
    uint64_t v3 = (char *)v1 + v2;
    __int128 v4 = v1;
    do
    {
      int v5 = (char *)memchr(v4, 66, v2 - 9);
      if (!v5) {
        break;
      }
      if (*(void *)v5 == 0x4C6E49746C697542LL && *((_WORD *)v5 + 4) == 11853) {
        return v5 != v3 && v5 - (char *)v1 != -1;
      }
      __int128 v4 = v5 + 1;
      uint64_t v2 = v3 - (_BYTE *)v4;
    }

    while (v3 - (_BYTE *)v4 >= 10);
  }

  return 0LL;
}

uint64_t rd_userprofile_util::doesSupportProfile(void *a1)
{
  if (*((char *)a1 + 23) < 0)
  {
    uint64_t v5 = a1[1];
    if (v5 == 20)
    {
      if (*(void *)*a1 != 0x4C6E49746C697542LL
        || *(void *)(*a1 + 8LL) != 0x776F646E69572E4DLL
        || *(_DWORD *)(*a1 + 16LL) != 1835365449)
      {
        uint64_t v5 = a1[1];
LABEL_35:
        if (v5 != 23) {
          return 0LL;
        }
        a1 = (void *)*a1;
        return *a1 == 0x4C6E49746C697542LL
            && a1[1] == 0x6D6F747375432E4DLL
            && *(void *)((char *)a1 + 15) == 0x646E616D6D6F436DLL;
      }
    }

    else
    {
      if (v5 != 31) {
        goto LABEL_35;
      }
      BOOL v6 = *(void *)*a1 == 0x4C6E49746C697542LL && *(void *)(*a1 + 8LL) == 0x6863746977532E4DLL;
      BOOL v7 = v6 && *(void *)(*a1 + 16LL) == 0x6C707041656C6261LL;
      if (!v7 || *(void *)(*a1 + 23LL) != 0x6E6F69746163696CLL) {
        goto LABEL_35;
      }
    }

    return 1LL;
  }

  int v1 = *((unsigned __int8 *)a1 + 23);
  if (v1 == 20) {
    return *a1 == 0x4C6E49746C697542LL && a1[1] == 0x776F646E69572E4DLL && *((_DWORD *)a1 + 4) == 1835365449;
  }
  if (v1 == 23) {
    return *a1 == 0x4C6E49746C697542LL
  }
        && a1[1] == 0x6D6F747375432E4DLL
        && *(void *)((char *)a1 + 15) == 0x646E616D6D6F436DLL;
  if (v1 != 31) {
    return 0LL;
  }
  return *a1 == 0x4C6E49746C697542LL
      && a1[1] == 0x6863746977532E4DLL
      && a1[2] == 0x6C707041656C6261LL
      && *(void *)((char *)a1 + 23) == 0x6E6F69746163696CLL;
}

__CFString *rd_userprofile_util::nonTerminalForProfile(unint64_t *a1)
{
  if (*((char *)a1 + 23) < 0)
  {
    unint64_t v5 = a1[1];
    if (v5 == 20)
    {
      if (*(void *)*a1 == 0x4C6E49746C697542LL
        && *(void *)(*a1 + 8) == 0x776F646E69572E4DLL
        && *(_DWORD *)(*a1 + 16) == 1835365449)
      {
        return kRDProfileNonTerminalInline[0];
      }

      unint64_t v5 = a1[1];
    }

    else if (v5 == 31)
    {
      BOOL v6 = *(void *)*a1 == 0x4C6E49746C697542LL && *(void *)(*a1 + 8) == 0x6863746977532E4DLL;
      BOOL v7 = v6 && *(void *)(*a1 + 16) == 0x6C707041656C6261LL;
      if (v7 && *(void *)(*a1 + 23) == 0x6E6F69746163696CLL) {
        return kRDProfileNonTerminalAppName[0];
      }
    }

    if (v5 != 23) {
      return 0LL;
    }
    a1 = (unint64_t *)*a1;
    goto LABEL_40;
  }

  int v1 = *((unsigned __int8 *)a1 + 23);
  if (v1 == 20)
  {
    if (*a1 != 0x4C6E49746C697542LL || a1[1] != 0x776F646E69572E4DLL || *((_DWORD *)a1 + 4) != 1835365449) {
      return 0LL;
    }
    return kRDProfileNonTerminalInline[0];
  }

  if (v1 != 23)
  {
    if (v1 != 31) {
      return 0LL;
    }
    BOOL v2 = *a1 == 0x4C6E49746C697542LL && a1[1] == 0x6863746977532E4DLL;
    BOOL v3 = v2 && a1[2] == 0x6C707041656C6261LL;
    return kRDProfileNonTerminalAppName[0];
  }

LABEL_40:
  unint64_t v11 = 0x4275696C74496E4CLL;
  unint64_t v12 = bswap64(*a1);
  if (v12 == 0x4275696C74496E4CLL
    && (unint64_t v11 = 0x4D2E437573746F6DLL, v12 = bswap64(a1[1]), v12 == 0x4D2E437573746F6DLL)
    && (unint64_t v11 = 0x6D436F6D6D616E64LL, v12 = bswap64(*(unint64_t *)((char *)a1 + 15)), v12 == 0x6D436F6D6D616E64LL))
  {
    int v13 = 0;
  }

  else if (v12 < v11)
  {
    int v13 = -1;
  }

  else
  {
    int v13 = 1;
  }

  if (v13) {
    return 0LL;
  }
  else {
    return kRDProfileNonTerminalUnknown[0];
  }
}

  unint64_t v11 = 0x4275696C74496E4CLL;
  unint64_t v12 = bswap64(*a1);
  if (v12 == 0x4275696C74496E4CLL
    && (unint64_t v11 = 0x4D2E437573746F6DLL, v12 = bswap64(a1[1]), v12 == 0x4D2E437573746F6DLL)
    && (unint64_t v11 = 0x6D436F6D6D616E64LL, v12 = bswap64(*(unint64_t *)((char *)a1 + 15)), v12 == 0x6D436F6D6D616E64LL))
  {
    int v13 = 0;
  }

  else if (v12 < v11)
  {
    int v13 = -1;
  }

  else
  {
    int v13 = 1;
  }

  if (v13) {
    return 0LL;
  }
  else {
    return kRDProfileWordTagUnknownFirst;
  }
}

  swift_bridgeObjectRelease(v80, v81);
  v330 = [objc_allocWithZone(NSMutableArray) init];
  v189 = Transcriber.MultisegmentResult.transcriptionTokens.getter();
  v191 = v189;
  v327 = *(id *)(v189 + 16);
  if (v327)
  {
    v192 = 0LL;
    v340 = (CMTime *)(v27 + 32);
    v344 = (CMTime *)(v27 + 29);
    v337 = (CMTime *)(v27 + 44);
    v321 = v189;
    v324 = v189 + 32;
    while (v192 < *(void *)(v191 + 16))
    {
      v194 = *(void *)(v324 + 8 * v192);
      v195 = objc_allocWithZone(&OBJC_CLASS___NSMutableArray);
      swift_bridgeObjectRetain(v194);
      v360 = [v195 init];
      v197 = *(void *)(v194 + 16);
      if (v197)
      {
        v333 = v194;
        v335 = v192;
        v198 = v27[84];
        v199 = v194 + ((*(unsigned __int8 *)(v198 + 80) + 32LL) & ~(unint64_t)*(unsigned __int8 *)(v198 + 80));
        v348 = *(void *)(v198 + 72);
        v353 = *(uint64_t (**)(void, uint64_t, void))(v198 + 16);
        while (1)
        {
          v367 = v197;
          v200 = v27[105];
          v201 = v353(v27[85], v199, v27[83]);
          v202 = TranscriptionToken.tokenName.getter(v201);
          v204 = v203;
          v27[58] = v202;
          v27[59] = v203;
          v205 = sub_1000587BC();
          StringProtocol.trimmingCharacters(in:)(v200, &type metadata for String, v205);
          v376 = v206;
          v207 = swift_bridgeObjectRelease(v204, v206);
          v27[44] = TranscriptionToken.start.getter(v207);
          *((_DWORD *)v27 + 90) = v208;
          *((_DWORD *)v27 + 91) = v209;
          v27[46] = v210;
          v211 = CMTimeGetSeconds(v337);
          v27[32] = TranscriptionToken.end.getter();
          *((_DWORD *)v27 + 66) = v212;
          *((_DWORD *)v27 + 67) = v213;
          v27[34] = v214;
          v215 = CMTimeGetSeconds(v340);
          v27[29] = TranscriptionToken.silenceStart.getter();
          *((_DWORD *)v27 + 60) = v216;
          *((_DWORD *)v27 + 61) = v217;
          v27[31] = v218;
          v219 = CMTimeGetSeconds(v344);
          v220 = TranscriptionToken.confidence.getter();
          v373 = TranscriptionToken.hasSpaceAfter.getter();
          LOBYTE(v204) = TranscriptionToken.hasSpaceBefore.getter();
          TranscriptionToken.phoneSequence.getter();
          v221 = v27;
          v223 = v222;
          TranscriptionToken.ipaPhoneSequence.getter();
          v225 = v224;
          v226 = objc_allocWithZone((Class)&OBJC_CLASS___RDSAPIObjCSpeechAnalyzerTranscriptionToken);
          v227 = String._bridgeToObjectiveC()();
          swift_bridgeObjectRelease(v376, v228);
          v229 = String._bridgeToObjectiveC()();
          swift_bridgeObjectRelease(v223, v230);
          v231 = String._bridgeToObjectiveC()();
          swift_bridgeObjectRelease(v225, v232);
          v233 = [v226 initWithTokenName:v227 start:v373 & 1 end:v204 & 1 silenceStart:v229 confidence:v231 hasSpaceAfter:v211 hasSpaceBefore:v215 phoneSequence:v219 ipaPhoneSequence:v220];

          if (!v233) {
            goto LABEL_76;
          }
          v234 = v221[85];
          v235 = v221[84];
          v236 = v221[83];
          [v360 addObject:v233];

          (*(void (**)(uint64_t, uint64_t))(v235 + 8))(v234, v236);
          v199 += v348;
          v197 = v367 - 1;
          v27 = v221;
          if (v367 == 1)
          {
            v193 = swift_bridgeObjectRelease(v333, v237).n128_u64[0];
            v191 = v321;
            v192 = v335;
            goto LABEL_43;
          }
        }
      }

      v193 = swift_bridgeObjectRelease(v194, v196).n128_u64[0];
LABEL_43:
      ++v192;
      objc_msgSend(v330, "addObject:", v360, *(double *)&v193, v309);

      if ((id)v192 == v327) {
        goto LABEL_50;
      }
    }

    goto LABEL_69;
  }

  ++*(void *)(a1 + 24);
  return v13;
}

__CFString *rd_userprofile_util::wordTagForProfile(unint64_t *a1)
{
  if (*((char *)a1 + 23) < 0)
  {
    unint64_t v5 = a1[1];
    if (v5 == 20)
    {
      if (*(void *)*a1 == 0x4C6E49746C697542LL
        && *(void *)(*a1 + 8) == 0x776F646E69572E4DLL
        && *(_DWORD *)(*a1 + 16) == 1835365449)
      {
        return kRDProfileWordTagJustInTime[0];
      }

      unint64_t v5 = a1[1];
    }

    else if (v5 == 31)
    {
      BOOL v6 = *(void *)*a1 == 0x4C6E49746C697542LL && *(void *)(*a1 + 8) == 0x6863746977532E4DLL;
      BOOL v7 = v6 && *(void *)(*a1 + 16) == 0x6C707041656C6261LL;
      if (v7 && *(void *)(*a1 + 23) == 0x6E6F69746163696CLL) {
        return kRDProfileWordTagAppName[0];
      }
    }

    if (v5 != 23) {
      return 0LL;
    }
    a1 = (unint64_t *)*a1;
    goto LABEL_40;
  }

  int v1 = *((unsigned __int8 *)a1 + 23);
  if (v1 == 20)
  {
    if (*a1 != 0x4C6E49746C697542LL || a1[1] != 0x776F646E69572E4DLL || *((_DWORD *)a1 + 4) != 1835365449) {
      return 0LL;
    }
    return kRDProfileWordTagJustInTime[0];
  }

  if (v1 != 23)
  {
    if (v1 != 31) {
      return 0LL;
    }
    BOOL v2 = *a1 == 0x4C6E49746C697542LL && a1[1] == 0x6863746977532E4DLL;
    BOOL v3 = v2 && a1[2] == 0x6C707041656C6261LL;
    return kRDProfileWordTagAppName[0];
  }

void RDQSRResultObject::RDQSRResultObject(RDQSRResultObject *this, int a2, void *a3)
{
  *(_DWORD *)this = a2;
  *((void *)this + 1) = a3;
}

{
  *(_DWORD *)this = a2;
  *((void *)this + 1) = a3;
}

void RDQSRResultObject::RDQSRResultObject(RDQSRResultObject *this, const RDQSRResultObject *a2)
{
  *(_DWORD *)this = *(_DWORD *)a2;
  BOOL v3 = (void *)*((void *)a2 + 1);
  *((void *)this + 1) = v3;
  if (v3) {
    xpc_retain(v3);
  }
}

{
  void *v3;
  *(_DWORD *)this = *(_DWORD *)a2;
  BOOL v3 = (void *)*((void *)a2 + 1);
  *((void *)this + 1) = v3;
  if (v3) {
    xpc_retain(v3);
  }
}

uint64_t RDQSRResultObject::operator=(uint64_t a1, uint64_t a2)
{
  __int128 v4 = *(void **)(a2 + 8);
  if (v4) {
    xpc_retain(v4);
  }
  unint64_t v5 = *(void **)(a1 + 8);
  if (v5) {
    xpc_release(v5);
  }
  *(_DWORD *)a1 = *(_DWORD *)a2;
  *(void *)(a1 + _Block_object_dispose(va, 8) = *(void *)(a2 + 8);
  return a1;
}

void RDQSRResultObject::~RDQSRResultObject(RDQSRResultObject *this)
{
  int v1 = (void *)*((void *)this + 1);
  if (v1) {
    xpc_release(v1);
  }
}

uint64_t RDQSRResultObject::getGrammarIndex(RDQSRResultObject *this)
{
  return *(unsigned int *)this;
}

uint64_t RDQSRResultObject::getResultModel(RDQSRResultObject *this)
{
  return *((void *)this + 1);
}

uint64_t RDQSRResult::RDQSRResult( uint64_t a1, uint64_t a2, CFStringRef theString, int a4, uint64_t a5, CFLocaleRef *a6)
{
  *(void *)a1 = &off_1000CE200;
  *(void *)(a1 + _Block_object_dispose(va, 8) = 0LL;
  CFStringRef Copy = CFStringCreateCopy(0LL, theString);
  *(_OWORD *)(a1 + 32) = 0u;
  *(void *)(a1 + 24) = Copy;
  *(_OWORD *)(a1 + 4_Block_object_dispose(va, 8) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(void *)(a1 + 96) = a6;
  *(void *)(a1 + 104) = a5;
  if (a4 >= 15) {
    int v13 = 15;
  }
  else {
    int v13 = a4;
  }
  *(_DWORD *)(a1 + 112) = v13;
  *(void *)(a1 + 120) = a2;
  RDQSRResult::tokenSausageVecFromCFString(a2, theString, a6, v30);
  char v14 = RXIsLocaleWithNoSpaceInPostITN(*(void *)(a1 + 120));
  v29[0] = 0LL;
  v29[1] = 0LL;
  v28 = (uint64_t *)v29;
  v15 = *(CFLocaleRef **)(a1 + 96);
  v31[0] = &off_1000CE288;
  v31[1] = a1;
  v32 = v31;
  sub_10009AC00(v30, v15, &v28, (uint64_t)v31, v14, &v27);
  uint64_t v16 = v27;
  uint64_t v27 = 0LL;
  uint64_t v17 = *(void *)(a1 + 56);
  *(void *)(a1 + 56) = v16;
  if (v17)
  {
    (*(void (**)(uint64_t))(*(void *)v17 + 8LL))(v17);
    uint64_t v18 = v27;
    uint64_t v27 = 0LL;
    if (v18) {
      (*(void (**)(uint64_t))(*(void *)v18 + 8LL))(v18);
    }
  }

  v19 = v32;
  if (v32 == v31)
  {
    uint64_t v20 = 4LL;
    v19 = v31;
    goto LABEL_13;
  }

  if (v32)
  {
    uint64_t v20 = 5LL;
LABEL_13:
    (*(void (**)(void))(*v19 + 8 * v20))();
  }

  sub_100058C38(&v28, &v27);
  sub_10005E72C(*(void *)(a1 + 56), v27, 1, &v26);
  uint64_t v21 = v26;
  uint64_t v26 = 0LL;
  uint64_t v22 = *(void *)(a1 + 64);
  *(void *)(a1 + 64) = v21;
  if (v22)
  {
    (*(void (**)(uint64_t))(*(void *)v22 + 8LL))(v22);
    uint64_t v23 = v26;
    uint64_t v26 = 0LL;
    if (v23) {
      (*(void (**)(uint64_t))(*(void *)v23 + 8LL))(v23);
    }
  }

  uint64_t v24 = v27;
  uint64_t v27 = 0LL;
  if (v24) {
    (*(void (**)(uint64_t))(*(void *)v24 + 8LL))(v24);
  }
  sub_100018678((uint64_t)&v28, v29[0]);
  v28 = v30;
  sub_100018608((void ***)&v28);
  return a1;
}

void sub_100010D54( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void ***a12, char *a13, uint64_t a14, void **a15)
{
  if (a11) {
    (*(void (**)(uint64_t))(*(void *)a11 + 8LL))(a11);
  }
  sub_100018678((uint64_t)&a12, a13);
  a12 = &a15;
  sub_100018608((void ***)&a12);
  a15 = v16 + 5;
  sub_100018568(&a15);
  uint64_t v18 = *(void *)(v15 + 64);
  *(void *)(v15 + 64) = 0LL;
  if (v18) {
    (*(void (**)(uint64_t))(*(void *)v18 + 8LL))(v18);
  }
  uint64_t v19 = *(void *)(v15 + 56);
  *(void *)(v15 + 56) = 0LL;
  if (v19) {
    (*(void (**)(uint64_t))(*(void *)v19 + 8LL))(v19);
  }
  a15 = v16;
  sub_100018568(&a15);
  _Unwind_Resume(a1);
}

void RDQSRResult::tokenSausageVecFromCFString( uint64_t a1@<X0>, const __CFString *a2@<X1>, CFLocaleRef *a3@<X2>, uint64_t *a4@<X8>)
{
  *a4 = 0LL;
  a4[1] = 0LL;
  a4[2] = 0LL;
  else {
    BOOL v7 = sub_100098914(a3, a2);
  }
  size_t v8 = v7;
  for (CFIndex i = 0LL; CFArrayGetCount(v8) > i; ++i)
  {
    memset(v29, 0, sizeof(v29));
    uint64_t v26 = 0LL;
    uint64_t v27 = 0LL;
    unint64_t v28 = 0LL;
    ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(v8, i);
    sub_100097D98(ValueAtIndex, 0, v24);
    if (i) {
      char v11 = i != CFArrayGetCount(v8) - 1;
    }
    else {
      char v11 = 1;
    }
    unint64_t v12 = (double *)operator new(0x40uLL);
    if (SHIBYTE(v25) < 0)
    {
      sub_10005AA70(__p, v24[0], (unint64_t)v24[1]);
    }

    else
    {
      *(_OWORD *)__p = *(_OWORD *)v24;
      v31 = v25;
    }

    sub_100099710(v12, (__int128 *)__p, v11, i != 0, 0.0, 0.0, 0.0, 0.0);
    uint64_t v23 = v12;
    if (SHIBYTE(v31) < 0) {
      operator delete(__p[0]);
    }
    int v13 = v27;
    if ((unint64_t)v27 >= v28)
    {
      uint64_t v16 = ((uint64_t)v27 - v26) >> 3;
      unint64_t v17 = (uint64_t)(v28 - v26) >> 2;
      if (v17 <= v16 + 1) {
        unint64_t v17 = v16 + 1;
      }
      if (v28 - v26 >= 0x7FFFFFFFFFFFFFF8LL) {
        unint64_t v18 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v18 = v17;
      }
      v33 = &v28;
      if (v18) {
        uint64_t v19 = (char *)sub_100018788((uint64_t)&v28, v18);
      }
      else {
        uint64_t v19 = 0LL;
      }
      uint64_t v20 = &v19[8 * v16];
      __p[0] = v19;
      __p[1] = v20;
      v32 = &v19[8 * v18];
      uint64_t v21 = v23;
      uint64_t v23 = 0LL;
      *(void *)uint64_t v20 = v21;
      v31 = v20 + 8;
      sub_100018700(&v26, __p);
      uint64_t v15 = v27;
      sub_1000188CC((uint64_t)__p);
    }

    else
    {
      char v14 = v23;
      uint64_t v23 = 0LL;
      *uint64_t v27 = v14;
      uint64_t v15 = v13 + 1;
    }

    uint64_t v27 = v15;
    sub_100012888(v29, (uint64_t)&v26);
    sub_1000129C4(a4, (uint64_t)v29);
    uint64_t v22 = (void **)v23;
    uint64_t v23 = 0LL;
    if (v22) {
      sub_1000186C8((int)&v23, v22);
    }
    if (SHIBYTE(v25) < 0) {
      operator delete(v24[0]);
    }
    __p[0] = &v26;
    sub_100018568((void ***)__p);
    __p[0] = v29;
    sub_100018E1C((void ***)__p);
  }

  if (v8) {
    CFRelease(v8);
  }
}

void sub_1000110A0( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, void *a22, uint64_t a23, int a24, __int16 a25, char a26, char a27)
{
}

uint64_t RDQSRResult::RDQSRResult( uint64_t a1, uint64_t a2, const __CFArray *a3, uint64_t a4, uint64_t a5, int a6, uint64_t a7, uint64_t a8, unsigned __int8 a9)
{
  *(void *)a1 = &off_1000CE200;
  *(void *)(a1 + _Block_object_dispose(va, 8) = a4;
  *(_OWORD *)(a1 + 72) = 0u;
  *(void *)(a1 + 16) = a5;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(void *)(a1 + 8_Block_object_dispose(va, 8) = 0LL;
  *(void *)(a1 + 96) = a8;
  *(void *)(a1 + 104) = a7;
  if (a6 >= 15) {
    int v10 = 15;
  }
  else {
    int v10 = a6;
  }
  *(_DWORD *)(a1 + 112) = v10;
  *(void *)(a1 + 120) = a2;
  RDQSRResult::tokenSausageVecFromCFTokenSausage(a2, a3, a9, v27);
  char v11 = RXIsLocaleWithNoSpaceInPostITN(*(void *)(a1 + 120));
  v26[0] = 0LL;
  v26[1] = 0LL;
  v25 = (uint64_t *)v26;
  unint64_t v12 = *(CFLocaleRef **)(a1 + 96);
  v28[0] = &off_1000CE318;
  v28[1] = a1;
  v29 = v28;
  sub_10009AC00(v27, v12, &v25, (uint64_t)v28, v11, &v24);
  uint64_t v13 = v24;
  uint64_t v24 = 0LL;
  uint64_t v14 = *(void *)(a1 + 56);
  *(void *)(a1 + 56) = v13;
  if (v14)
  {
    (*(void (**)(uint64_t))(*(void *)v14 + 8LL))(v14);
    uint64_t v15 = v24;
    uint64_t v24 = 0LL;
    if (v15) {
      (*(void (**)(uint64_t))(*(void *)v15 + 8LL))(v15);
    }
  }

  uint64_t v16 = v29;
  if (v29 == v28)
  {
    uint64_t v17 = 4LL;
    uint64_t v16 = v28;
    goto LABEL_13;
  }

  if (v29)
  {
    uint64_t v17 = 5LL;
LABEL_13:
    (*(void (**)(void))(*v16 + 8 * v17))();
  }

  sub_100058C38(&v25, &v24);
  sub_10005E72C(*(void *)(a1 + 56), v24, 1, &v23);
  uint64_t v18 = v23;
  uint64_t v23 = 0LL;
  uint64_t v19 = *(void *)(a1 + 64);
  *(void *)(a1 + 64) = v18;
  if (v19)
  {
    (*(void (**)(uint64_t))(*(void *)v19 + 8LL))(v19);
    uint64_t v20 = v23;
    uint64_t v23 = 0LL;
    if (v20) {
      (*(void (**)(uint64_t))(*(void *)v20 + 8LL))(v20);
    }
  }

  if (RXLogServerGrammar())
  {
    sub_1000610A0(*(void **)(a1 + 56), "result.fst");
    sub_1000610A0(*(void **)(a1 + 64), "result_edit.fst");
  }

  uint64_t v21 = v24;
  uint64_t v24 = 0LL;
  if (v21) {
    (*(void (**)(uint64_t))(*(void *)v21 + 8LL))(v21);
  }
  sub_100018678((uint64_t)&v25, v26[0]);
  v25 = v27;
  sub_100018608((void ***)&v25);
  return a1;
}

{
  return RDQSRResult::RDQSRResult(a1, a2, a3, a4, a5, a6, a7, a8, a9);
}

void sub_100011390( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void ***a12, char *a13, uint64_t a14, void **a15)
{
  if (a11) {
    (*(void (**)(uint64_t))(*(void *)a11 + 8LL))(a11);
  }
  sub_100018678((uint64_t)&a12, a13);
  a12 = &a15;
  sub_100018608((void ***)&a12);
  sub_100018568(&a15);
  uint64_t v17 = *(void *)(v15 + 64);
  *(void *)(v15 + 64) = 0LL;
  if (v17) {
    (*(void (**)(uint64_t))(*(void *)v17 + 8LL))(v17);
  }
  uint64_t v18 = *(void *)(v15 + 56);
  *(void *)(v15 + 56) = 0LL;
  if (v18) {
    (*(void (**)(uint64_t))(*(void *)v18 + 8LL))(v18);
  }
  a15 = (void **)(v15 + 32);
  sub_100018568(&a15);
  _Unwind_Resume(a1);
}

CFIndex RDQSRResult::tokenSausageVecFromCFTokenSausage@<X0>( uint64_t a1@<X0>, const __CFArray *a2@<X1>, int a3@<W3>, uint64_t *a4@<X8>)
{
  CFIndex idx = 0LL;
  *a4 = 0LL;
  a4[1] = 0LL;
  a4[2] = 0LL;
  while (1)
  {
    CFIndex result = CFArrayGetCount(a2);
    if (result <= idx) {
      return result;
    }
    memset(v90, 0, sizeof(v90));
    ValueAtIndex = (const __CFArray *)CFArrayGetValueAtIndex(a2, idx);
    CFIndex Count = CFArrayGetCount(ValueAtIndex);
    if (Count >= 1) {
      uint64_t v6 = 1LL;
    }
    else {
      uint64_t v6 = Count;
    }
    if (!a3) {
      uint64_t v6 = Count;
    }
    uint64_t v76 = v6;
    if (v6 >= 1)
    {
      CFIndex v7 = 0LL;
      do
      {
        CFIndex v78 = v7;
        v79 = (const __CFArray *)CFArrayGetValueAtIndex(ValueAtIndex, v7);
        CFIndex v81 = 0LL;
        uint64_t v87 = 0LL;
        v88 = 0LL;
        unint64_t v89 = 0LL;
        while (v81 < CFArrayGetCount(v79))
        {
          size_t v8 = (void *)CFArrayGetValueAtIndex(v79, v81);
          TokenName = (const __CFString *)RDASRWSpeechRecognitionTokenGetTokenName(v8);
          sub_100097D98(TokenName, 0, &v86);
          int v10 = (const __CFString *)RXLocalizedStringForSpacebar(a1);
          if (v10 && !v81 && CFStringCompare(TokenName, v10, 0LL) == kCFCompareEqualTo) {
            std::string::assign(&v86, " ");
          }
          char v11 = (RXIsLocaleWithNoSpaceInPostITN(a1) & 1) != 0
             || RDASRWSpeechRecognitionTokenHasSpaceAfter(v8) != 0;
          if (!RXIsLocaleWithNoSpaceInPostITN(a1))
          {
            RDASRWSpeechRecognitionTokenGetStart(v8);
            double v25 = v24;
            RDASRWSpeechRecognitionTokenGetEnd(v8);
            double v27 = v26;
            RDASRWSpeechRecognitionTokenGetSilenceStart(v8);
            double v29 = v28;
            RDASRWSpeechRecognitionTokenGetConfidence(v8);
            double v31 = v30;
            uint64_t v23 = (double *)operator new(0x40uLL);
            else {
              std::string buf = v86;
            }
            sub_100099710(v23, (__int128 *)&buf, v11, 1, v25, v27, v29, v31);
            v83.__r_.__value_.__r.__words[0] = (std::string::size_type)v23;
            if (((char)buf.__r_.__value_.__s.__size_ & 0x80000000) == 0
              || (operator delete(buf.__r_.__value_.__l.__data_),
                  (uint64_t v23 = (double *)v83.__r_.__value_.__r.__words[0]) != 0LL))
            {
              v62 = v88;
              if ((unint64_t)v88 >= v89)
              {
                uint64_t v63 = ((uint64_t)v88 - v87) >> 3;
                unint64_t v64 = (uint64_t)(v89 - v87) >> 2;
                if (v64 <= v63 + 1) {
                  unint64_t v64 = v63 + 1;
                }
                if (v89 - v87 >= 0x7FFFFFFFFFFFFFF8LL) {
                  unint64_t v65 = 0x1FFFFFFFFFFFFFFFLL;
                }
                else {
                  unint64_t v65 = v64;
                }
                v93 = &v89;
                if (v65)
                {
LABEL_83:
                  v68 = (char *)sub_100018788((uint64_t)&v89, v65);
                  uint64_t v23 = (double *)v83.__r_.__value_.__r.__words[0];
                }

                else
                {
                  v68 = 0LL;
                }

LABEL_88:
                v70 = (double **)&v68[8 * v63];
                buf.__r_.__value_.__r.__words[0] = (std::string::size_type)v68;
                buf.__r_.__value_.__l.__size_ = (std::string::size_type)v70;
                v92 = &v68[8 * v65];
                v83.__r_.__value_.__r.__words[0] = 0LL;
                *v70 = v23;
                buf.__r_.__value_.__l.__cap_ = (std::string::size_type)(v70 + 1);
                sub_100018700(&v87, &buf);
                v66 = v88;
                sub_1000188CC((uint64_t)&buf);
LABEL_89:
                v88 = v66;
LABEL_90:
                v71 = (void **)v83.__r_.__value_.__r.__words[0];
                v83.__r_.__value_.__r.__words[0] = 0LL;
                if (v71) {
                  sub_1000186C8((int)&v83, v71);
                }
                goto LABEL_92;
              }

LABEL_75:
              v83.__r_.__value_.__r.__words[0] = 0LL;
              *v62 = v23;
              v66 = v62 + 1;
              goto LABEL_89;
            }

            v69 = (os_log_s *)RXOSLog();
            if (!os_log_type_enabled(v69, OS_LOG_TYPE_ERROR)) {
              goto LABEL_90;
            }
LABEL_96:
            LOWORD(buf.__r_.__value_.__l.__data_) = 0;
            _os_log_impl( (void *)&_mh_execute_header,  v69,  OS_LOG_TYPE_ERROR,  "Null token recieved from engine",  (uint8_t *)&buf,  2u);
            goto LABEL_90;
          }

          unint64_t v12 = (const __CFString *)RDASRWSpeechRecognitionTokenGetTokenName(v8);
          sub_100097D98(v12, 0, __p);
          char v13 = sub_100098DD4((char *)__p);
          char v14 = v13;
          if (v85 < 0)
          {
            operator delete(__p[0]);
            if ((v14 & 1) != 0)
            {
LABEL_22:
              RDASRWSpeechRecognitionTokenGetStart(v8);
              double v16 = v15;
              RDASRWSpeechRecognitionTokenGetEnd(v8);
              double v18 = v17;
              RDASRWSpeechRecognitionTokenGetSilenceStart(v8);
              double v20 = v19;
              RDASRWSpeechRecognitionTokenGetConfidence(v8);
              double v22 = v21;
              uint64_t v23 = (double *)operator new(0x40uLL);
              else {
                std::string buf = v86;
              }
              sub_100099710(v23, (__int128 *)&buf, v11, 1, v16, v18, v20, v22);
              v83.__r_.__value_.__r.__words[0] = (std::string::size_type)v23;
              if (((char)buf.__r_.__value_.__s.__size_ & 0x80000000) == 0
                || (operator delete(buf.__r_.__value_.__l.__data_),
                    (uint64_t v23 = (double *)v83.__r_.__value_.__r.__words[0]) != 0LL))
              {
                v62 = v88;
                if ((unint64_t)v88 >= v89)
                {
                  uint64_t v63 = ((uint64_t)v88 - v87) >> 3;
                  unint64_t v67 = (uint64_t)(v89 - v87) >> 2;
                  if (v67 <= v63 + 1) {
                    unint64_t v67 = v63 + 1;
                  }
                  if (v89 - v87 >= 0x7FFFFFFFFFFFFFF8LL) {
                    unint64_t v65 = 0x1FFFFFFFFFFFFFFFLL;
                  }
                  else {
                    unint64_t v65 = v67;
                  }
                  v93 = &v89;
                  if (v65) {
                    goto LABEL_83;
                  }
                  v68 = 0LL;
                  goto LABEL_88;
                }

                goto LABEL_75;
              }

              v69 = (os_log_s *)RXOSLog();
              if (!os_log_type_enabled(v69, OS_LOG_TYPE_ERROR)) {
                goto LABEL_90;
              }
              goto LABEL_96;
            }
          }

          else if ((v13 & 1) != 0)
          {
            goto LABEL_22;
          }

          RDASRWSpeechRecognitionTokenGetEnd(v8);
          double v33 = v32;
          RDASRWSpeechRecognitionTokenGetStart(v8);
          uint64_t v34 = 0LL;
          double v36 = v33 - v35;
          uint64_t v37 = -1LL;
          while (v34 < CFStringGetLength(v12))
          {
            v94.id location = v34;
            v94.length = 1LL;
            v38 = CFStringCreateWithSubstring(0LL, v12, v94);
            sub_100097D98(v38, 0, &v83);
            if (RXVeryVerbose())
            {
              v39 = (os_log_s *)RXOSLog();
              if (os_log_type_enabled(v39, OS_LOG_TYPE_INFO))
              {
                v40 = &v83;
                if ((v83.__r_.__value_.__s.__size_ & 0x80u) != 0) {
                  v40 = (std::string *)v83.__r_.__value_.__r.__words[0];
                }
                LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
                *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v40;
                _os_log_impl( (void *)&_mh_execute_header,  v39,  OS_LOG_TYPE_INFO,  "result phrase tokens = %s",  (uint8_t *)&buf,  0xCu);
              }
            }

            RDASRWSpeechRecognitionTokenGetStart(v8);
            double v42 = v41;
            CFIndex Length = CFStringGetLength(v12);
            RDASRWSpeechRecognitionTokenGetEnd(v8);
            double v45 = v44;
            CFIndex v46 = CFStringGetLength(v12);
            CFIndex v47 = CFStringGetLength(v12);
            RDASRWSpeechRecognitionTokenGetSilenceStart(v8);
            double v49 = v48;
            RDASRWSpeechRecognitionTokenGetConfidence(v8);
            double v51 = v50;
            v52 = (double *)operator new(0x40uLL);
            else {
              std::string buf = v83;
            }
            sub_100099710( v52,  (__int128 *)&buf,  v11,  1,  v42 + (double)v34 * (v36 / (double)Length),  v45 - (double)(v37 + v46) * (v36 / (double)v47),  v49,  v51);
            v82 = v52;
            if ((char)buf.__r_.__value_.__s.__size_ < 0
              && (operator delete(buf.__r_.__value_.__l.__data_), (v52 = (double *)v82) == 0LL))
            {
              v61 = (os_log_s *)RXOSLog();
              if (os_log_type_enabled(v61, OS_LOG_TYPE_ERROR))
              {
                LOWORD(buf.__r_.__value_.__l.__data_) = 0;
                _os_log_impl( (void *)&_mh_execute_header,  v61,  OS_LOG_TYPE_ERROR,  "Null token recieved from engine",  (uint8_t *)&buf,  2u);
              }
            }

            else
            {
              v53 = v88;
              if ((unint64_t)v88 >= v89)
              {
                uint64_t v55 = ((uint64_t)v88 - v87) >> 3;
                unint64_t v56 = (uint64_t)(v89 - v87) >> 2;
                if (v56 <= v55 + 1) {
                  unint64_t v56 = v55 + 1;
                }
                if (v89 - v87 >= 0x7FFFFFFFFFFFFFF8LL) {
                  unint64_t v57 = 0x1FFFFFFFFFFFFFFFLL;
                }
                else {
                  unint64_t v57 = v56;
                }
                v93 = &v89;
                if (v57)
                {
                  v58 = (char *)sub_100018788((uint64_t)&v89, v57);
                  v52 = (double *)v82;
                }

                else
                {
                  v58 = 0LL;
                }

                v59 = (double **)&v58[8 * v55];
                buf.__r_.__value_.__r.__words[0] = (std::string::size_type)v58;
                buf.__r_.__value_.__l.__size_ = (std::string::size_type)v59;
                v92 = &v58[8 * v57];
                v82 = 0LL;
                *v59 = v52;
                buf.__r_.__value_.__l.__cap_ = (std::string::size_type)(v59 + 1);
                sub_100018700(&v87, &buf);
                v54 = v88;
                sub_1000188CC((uint64_t)&buf);
              }

              else
              {
                v82 = 0LL;
                *v88 = v52;
                v54 = v53 + 1;
              }

              v88 = v54;
            }

            v60 = (void **)v82;
            v82 = 0LL;
            if (v60) {
              sub_1000186C8((int)&v82, v60);
            }
            --v37;
            ++v34;
          }

    double v26 = v70;
LABEL_76:
    if (a3 == 1)
    {
      double v27 = sub_10002ADB0();
      (*(void (**)(uint64_t *__return_ptr, uint64_t *, uint64_t))(*a1 + 24))(&v64, a1, v26);
      double v28 = *(float *)v27;
      if (*(float *)v27 == -INFINITY || *(float *)&v64 >= -INFINITY && *(float *)&v64 <= -INFINITY)
      {
        double v29 = *(float *)sub_1000606CC();
      }

      else
      {
        double v30 = *(float *)&v64 == INFINITY || v28 == INFINITY;
        double v29 = v28 + *(float *)&v64;
        if (v30) {
          double v29 = INFINITY;
        }
      }

      v61 = v29;
      (*(void (**)(uint64_t *, uint64_t, float *))(*a1 + 160))(a1, v26, &v61);
    }

    if (v68) {
      (*(void (**)(uint64_t))(*(void *)v68 + 32LL))(v68);
    }
    else {
      ++v70;
    }
  }

  else {
    double v31 = (int *)(*a2 + 4LL * (*(int (**)(uint64_t *))(*a1 + 16))(a1));
  }
  double v32 = *(float *)v31;
  double v33 = sub_10002AD60();
  *(float *)&unint64_t v64 = v32;
  LODWORD(v67) = *v33;
  v34.n128_f32[0] = v32;
  double v35 = sub_10002ADB0();
  *(float *)&unint64_t v64 = v32;
  LODWORD(v67) = *v35;
  v34.n128_f32[0] = v32;
  double v36 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t, float))(*a1 + 56))(a1, 0x2000000000LL, 1LL, v32);
  uint64_t v37 = *a1;
  if ((v36 & 0x2000000000LL) == 0)
  {
    v38 = (*(uint64_t (**)(uint64_t *))(v37 + 176))(a1);
    if (a3)
    {
      v39 = *(float *)sub_10002AD60();
      if (v39 == -INFINITY || v32 >= -INFINITY && v32 <= -INFINITY)
      {
        v40 = *(float *)sub_1000606CC();
      }

      else if (v32 == INFINITY)
      {
        v40 = NAN;
      }

      else
      {
        v40 = INFINITY;
        if (v39 != INFINITY) {
          v40 = v39 - v32;
        }
      }
    }

    else
    {
      v40 = v32;
    }

    unint64_t v56 = (*(uint64_t (**)(uint64_t *))(*a1 + 16))(a1);
    unint64_t v64 = 0LL;
    unint64_t v65 = v40;
    v66 = v56;
    (*(void (**)(uint64_t *, uint64_t, uint64_t *))(*a1 + 184))(a1, v38, &v64);
    (*(void (**)(uint64_t *, uint64_t))(*a1 + 152))(a1, v38);
    goto LABEL_171;
  }

  double v41 = (*(uint64_t (**)(uint64_t *))(v37 + 16))(a1);
  (*(void (**)(uint64_t *, uint64_t, uint64_t *))(*a1 + 272))(a1, v41, &v67);
  while (2)
  {
    if (!(*(unsigned int (**)(uint64_t))(*(void *)v67 + 16LL))(v67))
    {
      double v42 = (*(uint64_t (**)(uint64_t))(*(void *)v67 + 24LL))(v67);
      unint64_t v64 = *(void *)v42;
      v43 = *(float *)(v42 + 8);
      unint64_t v65 = v43;
      v66 = *(_DWORD *)(v42 + 12);
      if (a3)
      {
        double v44 = *(float *)sub_10002AD60();
        if (v44 == -INFINITY || v32 >= -INFINITY && v32 <= -INFINITY)
        {
          double v45 = *(float *)sub_1000606CC();
          goto LABEL_110;
        }

        if (v32 == INFINITY) {
          goto LABEL_117;
        }
        double v45 = INFINITY;
        if (v44 != INFINITY)
        {
          double v45 = v44 - v32;
LABEL_110:
          if (v45 == -INFINITY) {
            goto LABEL_117;
          }
        }

        if (v65 >= -INFINITY && v65 <= -INFINITY)
        {
LABEL_117:
          CFIndex v46 = *(float *)sub_1000606CC();
        }

        else
        {
          double v48 = v65 == INFINITY || v45 == INFINITY;
          CFIndex v46 = v45 + v65;
          if (v48) {
            CFIndex v46 = INFINITY;
          }
        }
      }

      else
      {
        if (v32 == -INFINITY || v43 >= -INFINITY && v43 <= -INFINITY) {
          goto LABEL_117;
        }
        CFIndex v47 = v43 == INFINITY || v32 == INFINITY;
        CFIndex v46 = v32 + v43;
        if (v47) {
          CFIndex v46 = INFINITY;
        }
      }

      unint64_t v65 = v46;
      (*(void (**)(uint64_t, uint64_t *))(*(void *)v67 + 80LL))(v67, &v64);
      (*(void (**)(uint64_t))(*(void *)v67 + 32LL))(v67);
      continue;
    }

    break;
  }

  if (v67) {
    (*(void (**)(uint64_t))(*(void *)v67 + 8LL))(v67);
  }
  if (a3)
  {
    double v49 = *(float *)sub_10002AD60();
    if (v49 == -INFINITY || v32 >= -INFINITY && v32 <= -INFINITY)
    {
      double v50 = *(float *)sub_1000606CC();
    }

    else
    {
      double v25 = v49 == INFINITY;
      v52 = v49 - v32;
      if (v25) {
        v52 = INFINITY;
      }
      if (v32 == INFINITY) {
        double v50 = NAN;
      }
      else {
        double v50 = v52;
      }
    }

    (*(void (**)(uint64_t *__return_ptr, uint64_t *, uint64_t))(*a1 + 24))(&v64, a1, v41);
    if (v50 == -INFINITY || *(float *)&v64 >= -INFINITY && *(float *)&v64 <= -INFINITY)
    {
      v53 = *(float *)sub_1000606CC();
    }

    else
    {
      v54 = *(float *)&v64 == INFINITY || v50 == INFINITY;
      v53 = v50 + *(float *)&v64;
      if (v54) {
        v53 = INFINITY;
      }
    }

    v59 = v53;
    (*(void (**)(uint64_t *, uint64_t, float *))(*a1 + 160))(a1, v41, &v59);
  }

  else
  {
    (*(void (**)(uint64_t *__return_ptr, uint64_t *, uint64_t))(*a1 + 24))(&v64, a1, v41);
    if (v32 == -INFINITY || *(float *)&v64 >= -INFINITY && *(float *)&v64 <= -INFINITY)
    {
      double v51 = *(float *)sub_1000606CC();
    }

    else
    {
      uint64_t v55 = *(float *)&v64 == INFINITY || v32 == INFINITY;
      double v51 = v32 + *(float *)&v64;
      if (v55) {
        double v51 = INFINITY;
      }
    }

    v60 = v51;
    (*(void (**)(uint64_t *, uint64_t, float *))(*a1 + 160))(a1, v41, &v60);
  }

LABEL_92:
          ++v81;
        }

        v83.__r_.__value_.__s.__data_[0] = 0;
        memset(&buf, 0, sizeof(buf));
        sub_100012888(v90, (uint64_t)&v87);
        if (v83.__r_.__value_.__s.__data_[0]) {
          sub_100012888(v90, (uint64_t)&buf);
        }
        v86.__r_.__value_.__r.__words[0] = (std::string::size_type)&buf;
        sub_100018568((void ***)&v86);
        buf.__r_.__value_.__r.__words[0] = (std::string::size_type)&v87;
        sub_100018568((void ***)&buf);
        CFIndex v7 = v78 + 1;
      }

      while (v78 + 1 != v76);
    }

    sub_1000129C4(a4, (uint64_t)v90);
    buf.__r_.__value_.__r.__words[0] = (std::string::size_type)v90;
    sub_100018E1C((void ***)&buf);
    ++idx;
  }

void sub_100011CFC( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, void *a23, void *a24, uint64_t a25, int a26, __int16 a27, char a28, char a29, uint64_t a30, uint64_t a31, int a32, __int16 a33, char a34, char a35, void *__p, uint64_t a37, int a38, __int16 a39, char a40, char a41, uint64_t *a42, uint64_t a43, uint64_t a44, uint64_t a45)
{
  a42 = &a45;
  sub_100018E1C((void ***)&a42);
  a45 = a11;
  sub_100018608((void ***)&a45);
  _Unwind_Resume(a1);
}

uint64_t RDQSRResult::firstBestResult(RDQSRResult *this)
{
  return *((void *)this + 2);
}

void RDQSRResult::~RDQSRResult(RDQSRResult *this)
{
  *(void *)this = &off_1000CE200;
  BOOL v2 = (const void *)*((void *)this + 3);
  if (v2) {
    CFRelease(v2);
  }
  unint64_t v5 = (void **)((char *)this + 72);
  sub_100018568(&v5);
  uint64_t v3 = *((void *)this + 8);
  *((void *)this + _Block_object_dispose(va, 8) = 0LL;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8LL))(v3);
  }
  uint64_t v4 = *((void *)this + 7);
  *((void *)this + 7) = 0LL;
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 8LL))(v4);
  }
  unint64_t v5 = (void **)((char *)this + 32);
  sub_100018568(&v5);
}

{
  void *v1;
  RDQSRResult::~RDQSRResult(this);
  operator delete(v1);
}

unint64_t RDQSRResult::TimeInMs(RDQSRResult *this, double a2)
{
  return *((void *)this + 13) + (unint64_t)(a2 * 1000.0);
}

uint64_t RDQSRResult::GetResultToken(uint64_t a1, const char *a2, int a3)
{
  size_t v6 = strlen("<eps>");
  size_t v7 = v6;
  uint64_t v8 = *((unsigned __int8 *)a2 + 23);
  if (a2[23] < 0)
  {
    if (v6 != *((void *)a2 + 1))
    {
      if (a3 == 2) {
        int v10 = (void *)(a1 + 32);
      }
      else {
        int v10 = (void *)(a1 + 72);
      }
      goto LABEL_21;
    }

    if (v6 == -1LL) {
      goto LABEL_23;
    }
    unint64_t v9 = *(const char **)a2;
  }

  else
  {
    if (v6 != v8)
    {
      if (a3 == 2) {
        int v10 = (void *)(a1 + 32);
      }
      else {
        int v10 = (void *)(a1 + 72);
      }
      return *(void *)(*v10 + 8LL * atoi(a2));
    }

    unint64_t v9 = a2;
    if (v7 == -1LL) {
LABEL_23:
    }
      sub_10001801C();
  }

  if (!memcmp(v9, "<eps>", v7)) {
    return 0LL;
  }
  if (a3 == 2)
  {
    int v10 = (void *)(a1 + 32);
    if ((v8 & 0x80) != 0) {
LABEL_21:
    }
      a2 = *(const char **)a2;
  }

  else
  {
    int v10 = (void *)(a1 + 72);
    if ((v8 & 0x80) != 0) {
      goto LABEL_21;
    }
  }

  return *(void *)(*v10 + 8LL * atoi(a2));
}

const __CFArray *RDQSRResult::hypothesesTokensVecFromCFTokenSausage(RDQSRResult *this, const __CFArray *a2)
{
  Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0LL, &kCFTypeArrayCallBacks);
  uint64_t v4 = CFArrayCreateMutable(kCFAllocatorDefault, 0LL, &kCFTypeArrayCallBacks);
  if (CFArrayGetCount(this) >= 1)
  {
    CFIndex v5 = 0LL;
    double v26 = this;
    do
    {
      ValueAtIndex = (const __CFArray *)CFArrayGetValueAtIndex(this, v5);
      CFMutableStringRef MutableCopy = CFArrayCreateMutableCopy(kCFAllocatorDefault, 0LL, Mutable);
      CFArrayRemoveAllValues(Mutable);
      v29.length = CFArrayGetCount(MutableCopy);
      v29.id location = 0LL;
      CFArrayAppendArray(v4, MutableCopy, v29);
      if (CFArrayGetCount(ValueAtIndex) >= 1)
      {
        CFIndex v8 = 0LL;
        theArray = ValueAtIndex;
        CFIndex v28 = v5;
        do
        {
          unint64_t v9 = (const __CFArray *)CFArrayGetValueAtIndex(ValueAtIndex, v8);
          int v10 = CFArrayCreateMutable(kCFAllocatorDefault, 0LL, &kCFTypeArrayCallBacks);
          if (CFArrayGetCount(v9) >= 1)
          {
            CFIndex v11 = 0LL;
            do
            {
              unint64_t v12 = CFArrayGetValueAtIndex(v9, v11);
              CFArrayAppendValue(v10, v12);
              ++v11;
            }

            while (v11 < CFArrayGetCount(v9));
          }

          if (v5)
          {
            char v13 = (void *)CFArrayGetValueAtIndex(v10, 0LL);
            if (CFArrayGetCount(MutableCopy) >= 1)
            {
              CFIndex v14 = 0LL;
              do
              {
                double v15 = (const __CFArray *)CFArrayGetValueAtIndex(MutableCopy, v14);
                CFIndex Count = CFArrayGetCount(v15);
                double v17 = (void *)CFArrayGetValueAtIndex(v15, Count - 1);
                RDASRWSpeechRecognitionTokenGetEnd(v17);
                double v19 = v18;
                RDASRWSpeechRecognitionTokenGetStart(v13);
                if (v19 == v20)
                {
                  double v21 = CFArrayCreateMutableCopy(kCFAllocatorDefault, 0LL, v15);
                  v30.length = CFArrayGetCount(v10);
                  v30.id location = 0LL;
                  CFArrayAppendArray(v21, v10, v30);
                  CFArrayAppendValue(Mutable, v21);
                  CFMutableArrayRef v22 = CFArrayCreateMutable(kCFAllocatorDefault, 0LL, &kCFTypeArrayCallBacks);
                  CFArraySetValueAtIndex(v4, v14, v22);
                  CFRelease(v21);
                }

                ++v14;
              }

              while (v14 < CFArrayGetCount(MutableCopy));
            }
          }

          else
          {
            CFArrayAppendValue(Mutable, v10);
          }

          CFRelease(v10);
          ++v8;
          ValueAtIndex = theArray;
          CFIndex v5 = v28;
        }

        while (CFArrayGetCount(theArray) > v8);
      }

      CFRelease(MutableCopy);
      if (CFArrayGetCount(v4) >= 1)
      {
        CFIndex v23 = 0LL;
        do
        {
          double v24 = CFArrayGetValueAtIndex(v4, v23);
          if (CFArrayGetCount((CFArrayRef)v24) >= 1) {
            CFArrayAppendValue(Mutable, v24);
          }
          ++v23;
        }

        while (v23 < CFArrayGetCount(v4));
      }

      CFArrayRemoveAllValues(v4);
      ++v5;
      this = v26;
    }

    while (CFArrayGetCount(v26) > v5);
  }

  CFRelease(v4);
  return Mutable;
}

void RDQSRResult::tokenSausageVecByCombiningAndRetokeninzing( RDQSRResult *this@<X1>, CFLocaleRef *a2@<X2>, uint64_t *a3@<X8>)
{
  CFArrayRef theArray = RDQSRResult::hypothesesTokensVecFromCFTokenSausage(this, this);
  CFIndex v7 = 0LL;
  a3[1] = 0LL;
  a3[2] = 0LL;
  *a3 = 0LL;
  double v42 = a3;
  memset(v51, 0, sizeof(v51));
  while (v7 < CFArrayGetCount(theArray))
  {
    CFMutableStringRef Mutable = CFStringCreateMutable(kCFAllocatorDefault, 0LL);
    ValueAtIndex = (const __CFArray *)CFArrayGetValueAtIndex(theArray, v7);
    CFIndex Count = CFArrayGetCount(ValueAtIndex);
    CFIndex v11 = Count;
    CFIndex v12 = Count - 1;
    if (Count < 1)
    {
      double v14 = 0.0;
      if (!Count) {
        goto LABEL_46;
      }
LABEL_16:
      CFIndex v22 = CFArrayGetCount(ValueAtIndex);
      CFIndex v23 = sub_100098914(a2, Mutable);
      CFRelease(Mutable);
      CFIndex v24 = 0LL;
      double v25 = v14 / (double)v22;
      double v26 = (v3 - v4) / (double)CFArrayGetCount(v23);
      uint64_t v48 = 0LL;
      double v49 = 0LL;
      unint64_t v50 = 0LL;
      while (CFArrayGetCount(v23) > v24)
      {
        double v27 = (const __CFString *)CFArrayGetValueAtIndex(v23, v24);
        sub_100097D98(v27, 0, v46);
        if (v24)
        {
          if (v24 == CFArrayGetCount(v23) - 1)
          {
            char v28 = 0;
            double v29 = v3;
            double v30 = v5;
          }

          else
          {
            double v29 = v26 + v5;
            char v28 = 1;
            double v30 = v5;
            double v5 = v26 + v5;
          }
        }

        else
        {
          char v28 = 1;
          double v29 = v4 + v26;
          double v30 = v4;
          double v5 = v4 + v26;
        }

        double v31 = (double *)operator new(0x40uLL);
        if (SHIBYTE(v47) < 0)
        {
          sub_10005AA70(__p, v46[0], (unint64_t)v46[1]);
        }

        else
        {
          *(_OWORD *)__p = *(_OWORD *)v46;
          v53 = v47;
        }

        sub_100099710(v31, (__int128 *)__p, v28, v24 != 0, v30, v29, 0.0, v25);
        double v45 = v31;
        if (SHIBYTE(v53) < 0) {
          operator delete(__p[0]);
        }
        double v32 = v49;
        if ((unint64_t)v49 >= v50)
        {
          uint64_t v35 = ((uint64_t)v49 - v48) >> 3;
          unint64_t v36 = (uint64_t)(v50 - v48) >> 2;
          if (v36 <= v35 + 1) {
            unint64_t v36 = v35 + 1;
          }
          if (v50 - v48 >= 0x7FFFFFFFFFFFFFF8LL) {
            unint64_t v37 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v37 = v36;
          }
          uint64_t v55 = &v50;
          if (v37) {
            v38 = (char *)sub_100018788((uint64_t)&v50, v37);
          }
          else {
            v38 = 0LL;
          }
          v39 = &v38[8 * v35];
          __p[0] = v38;
          __p[1] = v39;
          v54 = &v38[8 * v37];
          v40 = v45;
          double v45 = 0LL;
          *(void *)v39 = v40;
          v53 = v39 + 8;
          sub_100018700(&v48, __p);
          uint64_t v34 = v49;
          sub_1000188CC((uint64_t)__p);
        }

        else
        {
          double v33 = v45;
          double v45 = 0LL;
          *double v49 = v33;
          uint64_t v34 = v32 + 1;
        }

        double v49 = v34;
        double v41 = (void **)v45;
        double v45 = 0LL;
        if (v41) {
          sub_1000186C8((int)&v45, v41);
        }
        if (SHIBYTE(v47) < 0) {
          operator delete(v46[0]);
        }
        ++v24;
      }

      sub_100012888(v51, (uint64_t)&v48);
      CFRelease(v23);
      __p[0] = &v48;
      sub_100018568((void ***)__p);
      goto LABEL_46;
    }

    CFIndex v13 = 0LL;
    double v14 = 0.0;
    do
    {
      double v15 = (void *)CFArrayGetValueAtIndex(ValueAtIndex, v13);
      double v16 = v15;
      if (!v13)
      {
        RDASRWSpeechRecognitionTokenGetStart(v15);
        double v4 = v17;
        RDASRWSpeechRecognitionTokenGetSilenceStart(v16);
      }

      if (v12 == v13)
      {
        RDASRWSpeechRecognitionTokenGetEnd(v16);
        double v3 = v18;
      }

      RDASRWSpeechRecognitionTokenGetConfidence(v16);
      double v20 = v19;
      TokenName = (const __CFString *)RDASRWSpeechRecognitionTokenGetTokenName(v16);
      CFStringAppend(Mutable, TokenName);
      double v14 = v14 + v20;
      ++v13;
    }

    while (v11 != v13);
    if (v11) {
      goto LABEL_16;
    }
LABEL_46:
    ++v7;
  }

  sub_1000129C4(v42, (uint64_t)v51);
  CFRelease(theArray);
  __p[0] = v51;
  sub_100018E1C((void ***)__p);
}

void sub_1000127A4( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19, uint64_t *a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, void *a26, uint64_t a27, int a28, __int16 a29, char a30, char a31)
{
  a20 = &a23;
  sub_100018E1C((void ***)&a20);
  a23 = a9;
  sub_100018608((void ***)&a23);
  _Unwind_Resume(a1);
}

void **sub_100012888(uint64_t *a1, uint64_t a2)
{
  unint64_t v6 = a1[2];
  CFIndex result = (void **)(a1 + 2);
  unint64_t v5 = v6;
  CFIndex v7 = *(result - 1);
  if ((unint64_t)v7 >= v6)
  {
    unint64_t v9 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v7 - *a1) >> 3);
    unint64_t v10 = v9 + 1;
    if (v9 + 1 > 0xAAAAAAAAAAAAAAALL) {
      sub_100018774();
    }
    unint64_t v11 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v5 - *a1) >> 3);
    if (2 * v11 > v10) {
      unint64_t v10 = 2 * v11;
    }
    if (v11 >= 0x555555555555555LL) {
      unint64_t v12 = 0xAAAAAAAAAAAAAAALL;
    }
    else {
      unint64_t v12 = v10;
    }
    v16[4] = result;
    CFIndex v13 = (char *)sub_100018F00((uint64_t)result, v12);
    double v14 = &v13[24 * v9];
    v16[0] = v13;
    v16[1] = v14;
    v16[3] = &v13[24 * v15];
    *((void *)v14 + 1) = 0LL;
    *((void *)v14 + 2) = 0LL;
    *(void *)double v14 = 0LL;
    *(_OWORD *)double v14 = *(_OWORD *)a2;
    *((void *)v14 + 2) = *(void *)(a2 + 16);
    *(void *)a2 = 0LL;
    *(void *)(a2 + _Block_object_dispose(va, 8) = 0LL;
    *(void *)(a2 + 16) = 0LL;
    v16[2] = v14 + 24;
    sub_100018E8C(a1, v16);
    CFIndex v8 = (void *)a1[1];
    CFIndex result = sub_100019060(v16);
  }

  else
  {
    *CFIndex v7 = 0LL;
    v7[1] = 0LL;
    _OWORD v7[2] = 0LL;
    *(_OWORD *)CFIndex v7 = *(_OWORD *)a2;
    _OWORD v7[2] = *(void *)(a2 + 16);
    *(void *)a2 = 0LL;
    *(void *)(a2 + _Block_object_dispose(va, 8) = 0LL;
    *(void *)(a2 + 16) = 0LL;
    CFIndex v8 = v7 + 3;
    a1[1] = (uint64_t)(v7 + 3);
  }

  a1[1] = (uint64_t)v8;
  return result;
}

void sub_1000129B0(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

void **sub_1000129C4(uint64_t *a1, uint64_t a2)
{
  unint64_t v6 = a1[2];
  CFIndex result = (void **)(a1 + 2);
  unint64_t v5 = v6;
  CFIndex v7 = *(result - 1);
  if ((unint64_t)v7 >= v6)
  {
    unint64_t v9 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v7 - *a1) >> 3);
    unint64_t v10 = v9 + 1;
    if (v9 + 1 > 0xAAAAAAAAAAAAAAALL) {
      sub_100018774();
    }
    unint64_t v11 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v5 - *a1) >> 3);
    if (2 * v11 > v10) {
      unint64_t v10 = 2 * v11;
    }
    if (v11 >= 0x555555555555555LL) {
      unint64_t v12 = 0xAAAAAAAAAAAAAAALL;
    }
    else {
      unint64_t v12 = v10;
    }
    v16[4] = result;
    CFIndex v13 = (char *)sub_100018F00((uint64_t)result, v12);
    double v14 = &v13[24 * v9];
    v16[0] = v13;
    v16[1] = v14;
    v16[3] = &v13[24 * v15];
    *((void *)v14 + 1) = 0LL;
    *((void *)v14 + 2) = 0LL;
    *(void *)double v14 = 0LL;
    *(_OWORD *)double v14 = *(_OWORD *)a2;
    *((void *)v14 + 2) = *(void *)(a2 + 16);
    *(void *)a2 = 0LL;
    *(void *)(a2 + _Block_object_dispose(va, 8) = 0LL;
    *(void *)(a2 + 16) = 0LL;
    v16[2] = v14 + 24;
    sub_1000190E0(a1, v16);
    CFIndex v8 = (void *)a1[1];
    CFIndex result = sub_100019270(v16);
  }

  else
  {
    *CFIndex v7 = 0LL;
    v7[1] = 0LL;
    _OWORD v7[2] = 0LL;
    *(_OWORD *)CFIndex v7 = *(_OWORD *)a2;
    _OWORD v7[2] = *(void *)(a2 + 16);
    *(void *)a2 = 0LL;
    *(void *)(a2 + _Block_object_dispose(va, 8) = 0LL;
    *(void *)(a2 + 16) = 0LL;
    CFIndex v8 = v7 + 3;
    a1[1] = (uint64_t)(v7 + 3);
  }

  a1[1] = (uint64_t)v8;
  return result;
}

void sub_100012AEC(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

void RDQSRResult::fillAlternativeTokenVec(uint64_t *a1, uint64_t *a2, _BYTE *a3)
{
  uint64_t v3 = *a1;
  if (a1[1] != *a1)
  {
    unint64_t v7 = 0LL;
    uint64_t v8 = (uint64_t)(a2 + 2);
    do
    {
      unint64_t v9 = *(__int128 **)(v3 + 8 * v7);
      if (*((char *)v9 + 23) < 0)
      {
        sub_10005AA70(__dst, *(void **)v9, *((void *)v9 + 1));
      }

      else
      {
        __int128 v10 = *v9;
        uint64_t v40 = *((void *)v9 + 2);
        *(_OWORD *)__dst = v10;
      }

      if (v40 >= 0) {
        unint64_t v11 = __dst;
      }
      else {
        unint64_t v11 = (void **)__dst[0];
      }
      unint64_t v12 = CFStringCreateWithCString(0LL, (const char *)v11, 0x8000100u);
      CFMutableStringRef MutableCopy = CFStringCreateMutableCopy(0LL, 0LL, v12);
      int v38 = 0;
      double v14 = (const __CFString *)RXReplaceHyphensWithSpace(MutableCopy, &v38);
      sub_100097D98(v14, 0, v36);
      if (v38 >= 1) {
        *a3 = 1;
      }
      uint64_t v15 = *(void *)(v3 + 8 * v7);
      double v16 = *(double *)(v15 + 24);
      double v17 = *(double *)(v15 + 32);
      double v19 = *(double *)(v15 + 40);
      double v18 = *(double *)(v15 + 48);
      int v20 = *(unsigned __int8 *)(v15 + 56);
      int v21 = *(unsigned __int8 *)(v15 + 57);
      CFIndex v22 = (double *)operator new(0x40uLL);
      if (SHIBYTE(v37) < 0)
      {
        sub_10005AA70(__p, v36[0], (unint64_t)v36[1]);
      }

      else
      {
        *(_OWORD *)__p = *(_OWORD *)v36;
        double v42 = v37;
      }

      sub_100099710(v22, (__int128 *)__p, v20 != 0, v21 != 0, v16, v17, v19, v18);
      uint64_t v35 = v22;
      if (SHIBYTE(v42) < 0) {
        operator delete(__p[0]);
      }
      CFIndex v24 = (void *)a2[1];
      unint64_t v23 = a2[2];
      if ((unint64_t)v24 >= v23)
      {
        uint64_t v27 = ((uint64_t)v24 - *a2) >> 3;
        uint64_t v28 = v23 - *a2;
        uint64_t v29 = v28 >> 2;
        else {
          unint64_t v30 = v29;
        }
        uint64_t v44 = v8;
        if (v30) {
          double v31 = (char *)sub_100018788(v8, v30);
        }
        else {
          double v31 = 0LL;
        }
        double v32 = &v31[8 * v27];
        __p[0] = v31;
        __p[1] = v32;
        v43 = &v31[8 * v30];
        double v33 = v35;
        uint64_t v35 = 0LL;
        *(void *)double v32 = v33;
        double v42 = v32 + 8;
        sub_100018700(a2, __p);
        double v26 = (void *)a2[1];
        sub_1000188CC((uint64_t)__p);
      }

      else
      {
        double v25 = v35;
        uint64_t v35 = 0LL;
        *CFIndex v24 = v25;
        double v26 = v24 + 1;
        a2[1] = (uint64_t)v26;
      }

      a2[1] = (uint64_t)v26;
      uint64_t v34 = (void **)v35;
      uint64_t v35 = 0LL;
      if (v34) {
        sub_1000186C8((int)&v35, v34);
      }
      if (SHIBYTE(v37) < 0) {
        operator delete(v36[0]);
      }
      if (SHIBYTE(v40) < 0) {
        operator delete(__dst[0]);
      }
      ++v7;
      uint64_t v3 = *a1;
    }

    while (v7 < (a1[1] - *a1) >> 3);
  }

void sub_100012D84( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void **a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, void *a18, uint64_t a19, int a20, __int16 a21, char a22, char a23, uint64_t a24, void *a25, uint64_t a26, int a27, __int16 a28, char a29, char a30)
{
  double v31 = a10;
  a10 = 0LL;
  if (v31) {
    sub_1000186C8((int)&a10, v31);
  }
  if (a16 < 0) {
    operator delete(__p);
  }
  if (a23 < 0) {
    operator delete(a18);
  }
  _Unwind_Resume(exception_object);
}

uint64_t RDQSRResult::Match@<X0>(uint64_t a1@<X0>, uint64_t *a2@<X1>, uint64_t *a3@<X8>)
{
  int v81 = 1065353216;
  unsigned __int8 v6 = atomic_load((unsigned __int8 *)&qword_1000DDCF8);
  if ((v6 & 1) == 0 && __cxa_guard_acquire(&qword_1000DDCF8))
  {
    __cxa_atexit((void (*)(void *))&std::mutex::~mutex, &stru_1000DD308, (void *)&_mh_execute_header);
    __cxa_guard_release(&qword_1000DDCF8);
  }

  uint64_t v8 = *a2;
  uint64_t v7 = a2[1];
  unint64_t v9 = operator new(0x20uLL);
  *unint64_t v9 = &off_1000CE398;
  v9[1] = a2;
  v9[2] = v80;
  v9[3] = a1;
  v84 = v9;
  multithread_forloop(4uLL, (v7 - v8) >> 5, (uint64_t)v83);
  __int128 v10 = v84;
  if (v84 == v83)
  {
    uint64_t v11 = 4LL;
    __int128 v10 = v83;
  }

  else
  {
    if (!v84) {
      goto LABEL_7;
    }
    uint64_t v11 = 5LL;
  }

  (*(void (**)(void))(*v10 + 8 * v11))();
LABEL_7:
  *a3 = 0LL;
  a3[1] = 0LL;
  a3[2] = 0LL;
  __int128 v78 = 0uLL;
  v79 = 0LL;
  uint64_t v12 = *a2;
  uint64_t v13 = a2[1];
  if (*a2 == v13)
  {
    __int128 v76 = 0uLL;
    v77 = 0LL;
  }

  else
  {
    uint64_t v14 = 0LL;
    v73 = a3;
    v68 = a2;
    uint64_t v69 = (uint64_t)(a3 + 2);
    int v72 = 2;
    int v71 = -1;
    float v15 = 3.4028e38;
    int v70 = 3;
    do
    {
      *(void *)&__int128 v76 = v14;
      *(void *)std::string buf = &v76;
      double v16 = (void *)sub_100019528((uint64_t)v80, (unint64_t *)&v76, (uint64_t)&unk_1000AB73F, (void **)buf)[3];
      if (!sub_1000604B4((uint64_t)v16))
      {
        if (RXLogServerGrammar())
        {
          sub_1000610A0(v16, "composed.fst");
          double v17 = (void *)RDQSRGrammarBuilder::grammarFST(*(RDQSRGrammarBuilder **)v12);
          sub_1000610A0(v17, "grammar.fst");
        }

        float v18 = sub_1000604E4((uint64_t)v16);
        sub_100060720((uint64_t)v16, *(_DWORD *)(a1 + 112), (uint64_t *)&v76);
        LOBYTE(v82) = 0;
        unsigned __int8 v75 = 0;
        int v19 = RDQSRResult::calculateMode(a1, (void *)v76, v12, &v82, &v75);
        if (v19 == 1)
        {
          float v20 = sub_100059C28( (-85 * ((*(_DWORD *)(v76 + 8) - *(_DWORD *)v76) >> 4)),  v82,  v75,  v18);
          if (v20 <= 0.5)
          {
            int v21 = (os_log_s *)RXOSLog();
            if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
            {
              *(_WORD *)std::string buf = 0;
              _os_log_impl( (void *)&_mh_execute_header,  v21,  OS_LOG_TYPE_DEFAULT,  "Recognized text is a close command",  buf,  2u);
            }

            CFIndex v22 = (os_log_s *)RXOSLog();
            if (os_log_type_enabled(v22, OS_LOG_TYPE_INFO))
            {
              *(_DWORD *)std::string buf = 134217984;
              *(double *)&uint8_t buf[4] = v20;
              _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_INFO, "Edit distance = %f", buf, 0xCu);
            }

            else {
              unint64_t v23 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*((void *)&v76 + 1) - v76) >> 3);
            }
            if (v23 < 2)
            {
              LODWORD(v25) = 1;
            }

            else
            {
              uint64_t v24 = 32LL;
              uint64_t v25 = 1LL;
              while (RDQSRResult::calculateMode(a1, (void *)(v76 + v24 - 8), v12, &v82, &v75) == 1)
              {
                float v26 = sub_100059C28( (-85 * ((*(_DWORD *)(v76 + v24) - *(_DWORD *)(v76 + v24 - 8)) >> 4)),  v82,  v75,  v18);
                if (v26 > 0.5) {
                  break;
                }
                uint64_t v27 = (os_log_s *)RXOSLog();
                if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
                {
                  *(_WORD *)std::string buf = 0;
                  _os_log_impl( (void *)&_mh_execute_header,  v27,  OS_LOG_TYPE_DEFAULT,  "Recognized text is a close command",  buf,  2u);
                }

                uint64_t v28 = (os_log_s *)RXOSLog();
                if (os_log_type_enabled(v28, OS_LOG_TYPE_INFO))
                {
                  *(_DWORD *)std::string buf = 134217984;
                  *(double *)&uint8_t buf[4] = v26;
                  _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_INFO, "Edit distance = %f", buf, 0xCu);
                }

                ++v25;
                v24 += 24LL;
                if (v23 == v25)
                {
                  LODWORD(v25) = v23;
                  break;
                }
              }
            }

            unint64_t v30 = (RDQSRResultModelBuilder *)operator new(0xF0uLL);
            RDQSRResultModelBuilder::RDQSRResultModelBuilder((uint64_t)v30, a1, (__int128 *)v12, (uint64_t)&v76, 1, 2);
            double v31 = RDQSRResultModelBuilder::buildResult(v30, v25);
            double v32 = v31;
            double v33 = v73;
            unint64_t v35 = v73[1];
            unint64_t v34 = v73[2];
            if (v35 >= v34)
            {
              uint64_t v37 = (uint64_t)(v35 - *v73) >> 4;
              unint64_t v38 = v37 + 1;
              uint64_t v39 = v34 - *v73;
              if (v39 >> 3 > v38) {
                unint64_t v38 = v39 >> 3;
              }
              else {
                unint64_t v40 = v38;
              }
              uint64_t v88 = v69;
              double v41 = (char *)sub_1000198A8(v69, v40);
              double v42 = &v41[16 * v37];
              *(void *)std::string buf = v41;
              *(void *)&buf[8] = v42;
              uint64_t v87 = &v41[16 * v43];
              *(_DWORD *)double v42 = v14;
              *((void *)v42 + 1) = v32;
              std::string v86 = v42 + 16;
              double v33 = v73;
              sub_100019834(v73, buf);
              uint64_t v36 = v73[1];
              sub_10001997C((uint64_t)buf);
            }

            else
            {
              *(_DWORD *)unint64_t v35 = v14;
              *(void *)(v35 + _Block_object_dispose(va, 8) = v31;
              uint64_t v36 = v35 + 16;
              v73[1] = v35 + 16;
            }

            v33[1] = v36;
            RDQSRResultModelBuilder::~RDQSRResultModelBuilder(v30);
            operator delete(v44);
          }
        }

        else if (v18 < v15)
        {
          uint64_t v29 = (os_log_s *)RXOSLog();
          if (os_log_type_enabled(v29, OS_LOG_TYPE_INFO))
          {
            *(_DWORD *)std::string buf = 134217984;
            *(double *)&uint8_t buf[4] = v18;
            _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_INFO, "Shortest distance = %f", buf, 0xCu);
          }

          sub_1000199C8((void ***)&v78);
          __int128 v78 = v76;
          v79 = v77;
          v77 = 0LL;
          __int128 v76 = 0uLL;
          if (*(_BYTE *)(v12 + 25))
          {
            int v72 = 0;
          }

          else
          {
            int v45 = v72;
            if (*(_BYTE *)(v12 + 26)) {
              int v45 = 1;
            }
            int v72 = v45;
          }

          int v70 = v19;
          int v71 = v14;
          float v15 = v18;
        }

        *(void *)std::string buf = &v76;
        sub_1000180A4((void ***)buf);
      }

      ++v14;
      v12 += 32LL;
    }

    while (v12 != v13);
    __int128 v76 = 0uLL;
    v77 = 0LL;
    if ((void)v78 != *((void *)&v78 + 1) && v71 != -1)
    {
      if (v70 == 2)
      {
        CFIndex v46 = v73;
        CFIndex v47 = v68;
        double v51 = (os_log_s *)RXOSLog();
        if (os_log_type_enabled(v51, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)std::string buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v51, OS_LOG_TYPE_DEFAULT, "Recognized text is an adlib", buf, 2u);
        }

        memset(v74, 0, sizeof(v74));
        sub_100019A38( v74,  (__int128 **)v78,  *((__int128 ***)&v78 + 1),  0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*((void *)&v78 + 1) - v78) >> 3));
        RDQSRResult::constructPathVectorFromNBestForAdlib(a1, (uint64_t)v74, (uint64_t *)buf);
        sub_1000199C8((void ***)&v76);
        __int128 v76 = *(_OWORD *)buf;
        v77 = v86;
        std::string v86 = 0LL;
        memset(buf, 0, sizeof(buf));
        v82 = buf;
        sub_1000180A4((void ***)&v82);
        v82 = (uint8_t *)v74;
        sub_1000180A4((void ***)&v82);
      }

      else
      {
        CFIndex v46 = v73;
        CFIndex v47 = v68;
        if (!v70)
        {
          uint64_t v48 = (os_log_s *)RXOSLog();
          if (os_log_type_enabled(v48, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)std::string buf = 0;
            _os_log_impl((void *)&_mh_execute_header, v48, OS_LOG_TYPE_DEFAULT, "Recognized text is a command", buf, 2u);
          }

          uint64_t v50 = *v73;
          for (uint64_t i = v73[1]; i != v50; RDQSRResultObject::~RDQSRResultObject((RDQSRResultObject *)(i - 16)))
            ;
          v73[1] = v50;
          sub_1000199C8((void ***)&v76);
          __int128 v76 = v78;
          v77 = v79;
          v79 = 0LL;
          __int128 v78 = 0uLL;
        }
      }

      uint64_t v52 = *v47;
      v53 = (RDQSRResultModelBuilder *)operator new(0xF0uLL);
      RDQSRResultModelBuilder::RDQSRResultModelBuilder( (uint64_t)v53,  a1,  (__int128 *)(v52 + 32LL * v71),  (uint64_t)&v76,  v70,  v72);
      v54 = RDQSRResultModelBuilder::buildResult(v53, 1);
      uint64_t v55 = v54;
      unint64_t v57 = v46[1];
      unint64_t v56 = v46[2];
      if (v57 >= v56)
      {
        uint64_t v59 = (uint64_t)(v57 - *v46) >> 4;
        unint64_t v60 = v59 + 1;
        uint64_t v61 = v56 - *v46;
        if (v61 >> 3 > v60) {
          unint64_t v60 = v61 >> 3;
        }
        else {
          unint64_t v62 = v60;
        }
        uint64_t v88 = v69;
        uint64_t v63 = (char *)sub_1000198A8(v69, v62);
        unint64_t v64 = &v63[16 * v59];
        *(void *)std::string buf = v63;
        *(void *)&buf[8] = v64;
        uint64_t v87 = &v63[16 * v65];
        *(_DWORD *)unint64_t v64 = v71;
        *((void *)v64 + 1) = v55;
        std::string v86 = v64 + 16;
        sub_100019834(v46, buf);
        uint64_t v58 = v46[1];
        sub_10001997C((uint64_t)buf);
      }

      else
      {
        *(_DWORD *)unint64_t v57 = v71;
        *(void *)(v57 + _Block_object_dispose(va, 8) = v54;
        uint64_t v58 = v57 + 16;
        v46[1] = v57 + 16;
      }

      v46[1] = v58;
      RDQSRResultModelBuilder::~RDQSRResultModelBuilder(v53);
      operator delete(v66);
    }
  }

  *(void *)std::string buf = &v76;
  sub_1000180A4((void ***)buf);
  *(void *)std::string buf = &v78;
  sub_1000180A4((void ***)buf);
  return sub_1000192F0((uint64_t)v80);
}

void sub_1000136FC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void **a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, void ***a21, uint64_t a22, uint64_t a23, uint64_t a24, void **a25, uint64_t a26, uint64_t a27, uint64_t a28, char a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, void ***a34)
{
  a34 = (void ***)&a21;
  sub_1000180A4((void ***)&a34);
  a21 = &a25;
  sub_1000180A4((void ***)&a21);
  a25 = a14;
  sub_1000197C4(&a25);
  sub_1000192F0((uint64_t)&a29);
  _Unwind_Resume(a1);
}

uint64_t RDQSRResult::calculateMode(uint64_t a1, void *a2, uint64_t a3, _BYTE *a4, _BYTE *a5)
{
  *a4 = 0;
  *a5 = 0;
  uint64_t v6 = *a2;
  if (!*(_BYTE *)(a3 + 24))
  {
    uint64_t v55 = 2LL;
LABEL_125:
    uint64_t v59 = (char *)a2[1];
    unsigned int v73 = v55;
    for (uint64_t i = (char *)(v6 + 24); ; i += 48)
    {
      uint64_t v61 = i;
      if (i[23] < 0) {
        uint64_t v61 = *(char **)i;
      }
      unint64_t v62 = *(uint64_t ***)(a3 + 16);
      uint64_t v63 = (const std::string *)sub_10000A2DC(buf, v61);
      __dst.__r_.__value_.__r.__words[0] = std::stoull(v63, 0LL, 10);
      *(void *)__p = &__dst;
      unint64_t v64 = (void *)sub_100019C58(v62, (unint64_t *)&__dst, (uint64_t)&unk_1000AB73F, (uint64_t **)__p)[5];
      if (SHIBYTE(v78) < 0) {
        operator delete(*(void **)buf);
      }
      xpc_type_t type = xpc_get_type(v64);
      if (type == (xpc_type_t)&_xpc_type_dictionary)
      {
      }

      else
      {
        v66 = (os_log_s *)RXOSLog();
        if (os_log_type_enabled(v66, OS_LOG_TYPE_FAULT))
        {
          *(_DWORD *)std::string buf = 138412290;
          *(void *)&uint8_t buf[4] = type;
          _os_log_impl( (void *)&_mh_execute_header,  v66,  OS_LOG_TYPE_FAULT,  "API misuse while calculating mode: XPC_TYPE_DICTIONARY expected, passed %@ ",  buf,  0xCu);
        }
      }

      unint64_t v67 = i + 24;
      if (v67 == v59) {
        return v73;
      }
    }
  }

  int v70 = a2;
  uint64_t v74 = a2[1];
  if (v6 == v74)
  {
    int v8 = 0;
    int v71 = 1;
    int v56 = 2;
    goto LABEL_121;
  }

  int v8 = 0;
  int v9 = 0;
  int v71 = 1;
  unsigned int v72 = 2;
  while (1)
  {
    v8 &= v9 ^ 1;
    size_t v10 = strlen("<eps>");
    size_t v11 = v10;
    uint64_t v12 = *(unsigned __int8 *)(v6 + 23);
    if (*(char *)(v6 + 23) < 0)
    {
      if (v10 != *(void *)(v6 + 8)) {
        goto LABEL_12;
      }
      if (v10 == -1LL) {
LABEL_140:
      }
        sub_10001801C();
      uint64_t v13 = *(const void **)v6;
    }

    else
    {
      if (v10 != v12) {
        goto LABEL_12;
      }
      uint64_t v13 = (const void *)v6;
      if (v11 == -1LL) {
        goto LABEL_140;
      }
    }

    if (!memcmp(v13, "<eps>", v11))
    {
      unint64_t v57 = a4;
      goto LABEL_120;
    }

LABEL_12:
    uint64_t v14 = (char *)(v6 + 24);
    uint64_t v15 = *(unsigned __int8 *)(v6 + 47);
    if (*(char *)(v6 + 47) < 0)
    {
      if (v11 != *(void *)(v6 + 32)) {
        goto LABEL_20;
      }
      if (v11 == -1LL) {
LABEL_141:
      }
        sub_10001801C();
      double v16 = *(char **)v14;
    }

    else
    {
      if (v11 != v15) {
        goto LABEL_20;
      }
      double v16 = (char *)(v6 + 24);
      if (v11 == -1LL) {
        goto LABEL_141;
      }
    }

    if (!memcmp(v16, "<eps>", v11)) {
      break;
    }
LABEL_20:
    double v17 = (const char *)v6;
    if ((v12 & 0x80) != 0) {
      double v17 = *(const char **)v6;
    }
    int v18 = atoi(v17);
    if ((v15 & 0x80) != 0) {
      uint64_t v14 = *(char **)v14;
    }
    int v19 = *(__int128 **)(*(void *)(a1 + 72) + 8LL * v18);
    float v20 = *(uint64_t ***)(a3 + 16);
    int v21 = (const std::string *)sub_10000A2DC(buf, v14);
    __dst.__r_.__value_.__r.__words[0] = std::stoull(v21, 0LL, 10);
    *(void *)__p = &__dst;
    CFIndex v22 = (void *)sub_100019C58(v20, (unint64_t *)&__dst, (uint64_t)&unk_1000AB73F, (uint64_t **)__p)[5];
    if (SHIBYTE(v78) < 0) {
      operator delete(*(void **)buf);
    }
    xpc_type_t v23 = xpc_get_type(v22);
    if (v23 != (xpc_type_t)&_xpc_type_dictionary)
    {
      uint64_t v24 = (os_log_s *)RXOSLog();
      if (os_log_type_enabled(v24, OS_LOG_TYPE_FAULT))
      {
        if (*((char *)v19 + 23) < 0)
        {
          sub_10005AA70(buf, *(void **)v19, *((void *)v19 + 1));
        }

        else
        {
          __int128 v25 = *v19;
          uint64_t v78 = *((void *)v19 + 2);
          *(_OWORD *)std::string buf = v25;
        }

        double v32 = buf;
        if (v78 < 0) {
          double v32 = *(uint8_t **)buf;
        }
        *(_DWORD *)__p = 136315394;
        *(void *)&__p[4] = v32;
        *(_WORD *)&__p[12] = 2112;
        *(void *)&__p[14] = v23;
        _os_log_impl( (void *)&_mh_execute_header,  v24,  OS_LOG_TYPE_FAULT,  "API misuse for token %s : XPC_TYPE_DICTIONARY expected, passed %@ ",  __p,  0x16u);
        if (SHIBYTE(v78) < 0) {
          operator delete(*(void **)buf);
        }
      }

      goto LABEL_112;
    }

    int64_t int64 = xpc_dictionary_get_int64(v22, kRDKeyObjectType);
    if (int64 != 12)
    {
      if (int64 == 13 && *(_BYTE *)(a3 + 25))
      {
        if (*((char *)v19 + 23) < 0)
        {
          sub_10005AA70(buf, *(void **)v19, *((void *)v19 + 1));
        }

        else
        {
          __int128 v31 = *v19;
          uint64_t v78 = *((void *)v19 + 2);
          *(_OWORD *)std::string buf = v31;
        }

        if ((sub_100098CFC((uint64_t)buf) & 1) != 0)
        {
          BOOL v39 = 1;
        }

        else
        {
          if (*((char *)v19 + 23) < 0)
          {
            sub_10005AA70(__p, *(void **)v19, *((void *)v19 + 1));
          }

          else
          {
            __int128 v40 = *v19;
            *(void *)&__p[16] = *((void *)v19 + 2);
            *(_OWORD *)__p = v40;
          }

          BOOL v39 = sub_100098D68((uint64_t)__p);
          if ((__p[23] & 0x80000000) != 0) {
            operator delete(*(void **)__p);
          }
        }

        if (SHIBYTE(v78) < 0) {
          operator delete(*(void **)buf);
        }
        int v9 = 0;
        int v71 = 0;
        v8 |= v39;
      }

      goto LABEL_112;
    }

    uint64_t v27 = *(CFLocaleRef **)(a1 + 96);
    string = (char *)xpc_dictionary_get_string(v22, kRDKeyText);
    sub_10000A2DC(__p, string);
    sub_100097CB8(v27, __p, buf);
    if ((__p[23] & 0x80000000) != 0) {
      operator delete(*(void **)__p);
    }
    uint64_t v29 = *(CFLocaleRef **)(a1 + 96);
    if (*((char *)v19 + 23) < 0)
    {
      sub_10005AA70(&__dst, *(void **)v19, *((void *)v19 + 1));
    }

    else
    {
      __int128 v30 = *v19;
      __dst.__r_.__value_.__l.__cap_ = *((void *)v19 + 2);
      *(_OWORD *)&__dst.__r_.__value_.__l.__data_ = v30;
    }

    sub_100097CB8(v29, (const char *)&__dst, __p);
    uint64_t v33 = HIBYTE(v78);
    if (v78 >= 0) {
      uint64_t v34 = HIBYTE(v78);
    }
    else {
      uint64_t v34 = *(void *)&buf[8];
    }
    uint64_t v35 = __p[23];
    char v36 = __p[23];
    if (__p[23] < 0) {
      uint64_t v35 = *(void *)&__p[8];
    }
    if (v34 == v35)
    {
      if (__p[23] >= 0) {
        uint64_t v37 = __p;
      }
      else {
        uint64_t v37 = *(unsigned __int8 **)__p;
      }
      if (v78 < 0)
      {
        if (!memcmp(*(const void **)buf, v37, *(size_t *)&buf[8]))
        {
LABEL_102:
          LOBYTE(v50) = 0;
          int v52 = 0;
          int v9 = 1;
          if (v36 < 0) {
            goto LABEL_92;
          }
          goto LABEL_93;
        }
      }

      else
      {
        if (!HIBYTE(v78)) {
          goto LABEL_102;
        }
        unint64_t v38 = buf;
        while (*v38 == *v37)
        {
          ++v38;
          ++v37;
          if (!--v33) {
            goto LABEL_102;
          }
        }
      }
    }

    sub_100097F38((const void **)__p, &__dst);
    if (v78 >= 0) {
      uint64_t v41 = HIBYTE(v78);
    }
    else {
      uint64_t v41 = *(void *)&buf[8];
    }
    std::string::size_type size = __dst.__r_.__value_.__s.__size_;
    int v43 = (char)__dst.__r_.__value_.__s.__size_;
    if ((__dst.__r_.__value_.__s.__size_ & 0x80u) != 0) {
      std::string::size_type size = __dst.__r_.__value_.__l.__size_;
    }
    if (v41 != size)
    {
      BOOL v50 = 1;
LABEL_101:
      operator delete(__dst.__r_.__value_.__l.__data_);
      goto LABEL_86;
    }

    if ((__dst.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      p_dst = &__dst;
    }
    else {
      p_dst = (std::string *)__dst.__r_.__value_.__r.__words[0];
    }
    if (v78 < 0)
    {
      BOOL v50 = memcmp(*(const void **)buf, p_dst, *(size_t *)&buf[8]) != 0;
      if (v43 < 0) {
        goto LABEL_101;
      }
    }

    else if (HIBYTE(v78))
    {
      uint64_t v45 = HIBYTE(v78) - 1LL;
      CFIndex v46 = buf;
      do
      {
        int v48 = *v46++;
        int v47 = v48;
        int v49 = p_dst->__r_.__value_.__s.__data_[0];
        p_dst = (std::string *)((char *)p_dst + 1);
        BOOL v50 = v47 != v49;
      }

      while (v47 == v49 && v45-- != 0);
    }

    else
    {
      BOOL v50 = 0;
    }

      if (*((void *)this + 11) == (void)v27)
      {
        size_t v11 = *((void *)this + 5);
        uint64_t v12 = *((unsigned int *)this + 36);
        uint64_t v13 = (unint64_t *)*((void *)this + 4);
        if ((unint64_t)v13 >= v11)
        {
          uint64_t v15 = *((void *)this + 3);
          double v16 = ((uint64_t)v13 - v15) >> 3;
          double v17 = v11 - v15;
          int v18 = v17 >> 2;
          else {
            int v19 = v18;
          }
          if (v19) {
            float v20 = (char *)sub_100018788((uint64_t)this + 40, v19);
          }
          else {
            float v20 = 0LL;
          }
          int v21 = &v20[8 * v16];
          CFIndex v22 = &v20[8 * v19];
          *(void *)int v21 = a2 | (unint64_t)(v12 << 32);
          uint64_t v14 = v21 + 8;
          uint64_t v24 = (char *)*((void *)this + 3);
          xpc_type_t v23 = (char *)*((void *)this + 4);
          if (v23 != v24)
          {
            do
            {
              __int128 v25 = *((void *)v23 - 1);
              v23 -= 8;
              *((void *)v21 - 1) = v25;
              v21 -= 8;
            }

            while (v23 != v24);
            xpc_type_t v23 = (char *)*((void *)this + 3);
          }

          *((void *)this + 3) = v21;
          *((void *)this + 4) = v14;
          *((void *)this + 5) = v22;
          if (v23) {
            operator delete(v23);
          }
        }

        else
        {
          *uint64_t v13 = a2 | (unint64_t)(v12 << 32);
          uint64_t v14 = v13 + 1;
        }

        *((void *)this + 4) = v14;
      }

      break;
    default:
      break;
  }

  if ((v26[0] & 0x400) != 0) {
LABEL_31:
  }
    RDQSRResultLMNodeBuilder::EvaluateParentLMNode(this, *(unsigned int *)&v26[4], v26[3]);
}

  xpc_type_t v23 = v30;
  uint64_t v24 = *v29;
  *(void *)(*v29 + 8 * (a2 >> 6) + 56) |= 1LL << a2;
  uint64_t result = (*(uint64_t (**)(unint64_t, uint64_t, uint64_t))(v7 + 32))( *(void *)(v24 + 48) + *(void *)(v7 + 72) * a2,  v23,  v6);
  float v26 = *(void *)(v24 + 16);
  uint64_t v27 = __OFADD__(v26, 1LL);
  uint64_t v28 = v26 + 1;
  if (!v27)
  {
    *(void *)(v24 + 16) = v28;
    return result;
  }

  __break(1u);
LABEL_15:
  uint64_t result = ELEMENT_TYPE_OF_SET_VIOLATES_HASHABLE_REQUIREMENTS(_:)(v6);
  __break(1u);
  return result;
}

LABEL_86:
    if (v50) {
      int v52 = 2;
    }
    else {
      int v52 = 0;
    }
    v9 |= !v50;
    int v53 = v72;
    if (v50) {
      int v53 = 1;
    }
    unsigned int v72 = v53;
    if ((__p[23] & 0x80) != 0) {
LABEL_92:
    }
      operator delete(*(void **)__p);
LABEL_93:
    if (SHIBYTE(v78) < 0) {
      operator delete(*(void **)buf);
    }
    if (v52) {
      BOOL v54 = v50;
    }
    else {
      BOOL v54 = 0;
    }
    if (v54) {
      goto LABEL_122;
    }
LABEL_112:
    v6 += 48LL;
    if (v6 == v74) {
      goto LABEL_122;
    }
  }

  unint64_t v57 = a5;
LABEL_120:
  ++*v57;
  int v56 = 1;
LABEL_121:
  unsigned int v72 = v56;
LABEL_122:
  uint64_t result = 1LL;
  if ((*(_BYTE *)(a3 + 25) == 0) | (v71 | v8) & 1)
  {
    uint64_t v55 = v72;
    if (v72 != 1)
    {
      a2 = v70;
      uint64_t v6 = *v70;
      goto LABEL_125;
    }
  }

  return result;
}

void sub_100013FA4( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, int a21, __int16 a22, char a23, char a24, uint64_t a25, void *__p, uint64_t a27, int a28, __int16 a29, char a30, char a31)
{
}

void *RDQSRResultModelBuilder::buildResult(RDQSRResultModelBuilder *this, int a2)
{
  xpc_object_t v4 = xpc_array_create(0LL, 0LL);
  *((_DWORD *)this + 5_Block_object_dispose(va, 8) = 0;
  if (a2 < 1)
  {
LABEL_7:
    xpc_object_t v9 = xpc_dictionary_create(0LL, 0LL, 0LL);
    size_t v10 = v9;
    if (*((_DWORD *)this + 12) == 1) {
      int64_t v11 = 15LL;
    }
    else {
      int64_t v11 = 14LL;
    }
    xpc_dictionary_set_int64(v9, kRDKeyObjectType, v11);
    xpc_dictionary_set_uint64(v10, kRDKeyResultID, (uint64_t)v4);
    xpc_dictionary_set_value(v10, kRDKeyChildren, v4);
    xpc_release(v4);
  }

  else
  {
    while (1)
    {
      *((_BYTE *)this + 56) = 0;
      *((void *)this + 9) = 0LL;
      uint64_t v6 = *((void *)this + 10);
      for (uint64_t i = *((void *)this + 11); i != v6; uint64_t i = sub_10001AB5C(i - 24))
        ;
      *((void *)this + 11) = v6;
      std::string::assign((std::string *)((char *)this + 104), "");
      std::string::assign((std::string *)((char *)this + 128), "");
      *((void *)this + 20) = *((void *)this + 19);
      *((void *)this + 23) = *((void *)this + 22);
      sub_100018678((uint64_t)this + 200, *((char **)this + 26));
      *((void *)this + 25) = (char *)this + 208;
      *((void *)this + 26) = 0LL;
      *((void *)this + 27) = 0LL;
      *((void *)this + 2_Block_object_dispose(va, 8) = 0LL;
      sub_10001AAC0((RDQSRResultLMNodeBuilder **)this + 8, 0LL);
      RDQSRResultModelBuilder::AddResultNodeForCurrentResult(this);
      uint64_t v7 = (void *)*((void *)this + 9);
      if (!v7) {
        return 0LL;
      }
      xpc_array_append_value(v4, v7);
      int v8 = *((_DWORD *)this + 58) + 1;
      *((_DWORD *)this + 5_Block_object_dispose(va, 8) = v8;
      if (v8 >= a2) {
        goto LABEL_7;
      }
    }
  }

  return v10;
}

void RDQSRResult::constructPathVectorFromNBestForAdlib(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t *a3@<X8>)
{
  xpc_object_t v4 = *(__int128 ***)a2;
  if (*(void *)a2 == *(void *)(a2 + 8))
  {
    *a3 = (uint64_t)v4;
    a3[1] = (uint64_t)v4;
    a3[2] = *(void *)(a2 + 16);
    *(void *)a2 = 0LL;
    *(void *)(a2 + _Block_object_dispose(va, 8) = 0LL;
    *(void *)(a2 + 16) = 0LL;
    return;
  }

  uint64_t v78 = 0LL;
  uint64_t v79 = 0LL;
  uint64_t v80 = 0LL;
  sub_100019F00((char *)&v78, *v4, v4[1], 0xAAAAAAAAAAAAAAABLL * (v4[1] - *v4));
  memset(&__s1, 0, sizeof(__s1));
  uint64_t v6 = v79;
  if (v78 == v79)
  {
    int size = 0;
  }

  else
  {
    uint64_t v7 = v78 + 48;
    do
    {
      std::string::operator=(&__s1, (const std::string *)(v7 - 24));
      size_t v8 = strlen("<eps>");
      size_t v9 = v8;
      int size = __s1.__r_.__value_.__s.__size_;
      if ((__s1.__r_.__value_.__s.__size_ & 0x80) != 0)
      {
        if (v8 != __s1.__r_.__value_.__l.__size_) {
          goto LABEL_15;
        }
        if (v8 == -1LL) {
LABEL_102:
        }
          sub_10001801C();
        p_s1 = (std::string *)__s1.__r_.__value_.__r.__words[0];
      }

      else
      {
        if (v8 != __s1.__r_.__value_.__s.__size_) {
          goto LABEL_21;
        }
        if (v8 == -1LL) {
          goto LABEL_102;
        }
        p_s1 = &__s1;
      }

      if (memcmp(p_s1, "<eps>", v9)) {
        break;
      }
      BOOL v12 = v7 == v6;
      v7 += 48LL;
    }

    while (!v12);
    if ((size & 0x80) != 0)
    {
LABEL_15:
      size_t v13 = __s1.__r_.__value_.__l.__size_;
      if (__s1.__r_.__value_.__l.__size_)
      {
        if (strlen("<eps>") != __s1.__r_.__value_.__l.__size_) {
          goto LABEL_26;
        }
        if (__s1.__r_.__value_.__l.__size_ != -1LL)
        {
          uint64_t v14 = (std::string *)__s1.__r_.__value_.__r.__words[0];
          goto LABEL_25;
        }

LABEL_104:
        sub_10001801C();
      }

LABEL_57:
      uint64_t v34 = (os_log_s *)RXOSLog();
      if (os_log_type_enabled(v34, OS_LOG_TYPE_ERROR))
      {
        LOWORD(__p[0]) = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v34,  OS_LOG_TYPE_ERROR,  "constructPathVectorFromNBestForAdlib: <eps> grammar found for adlib",  (uint8_t *)__p,  2u);
      }

      *(_OWORD *)a3 = *(_OWORD *)a2;
      a3[2] = *(void *)(a2 + 16);
      *(void *)(a2 + _Block_object_dispose(va, 8) = 0LL;
      *(void *)(a2 + 16) = 0LL;
      *(void *)a2 = 0LL;
      goto LABEL_98;
    }
  }

LABEL_21:
  if (!size) {
    goto LABEL_57;
  }
  size_t v15 = strlen("<eps>");
  if (v15 != size) {
    goto LABEL_26;
  }
  size_t v13 = v15;
  if (v15 == -1LL) {
    goto LABEL_104;
  }
  uint64_t v14 = &__s1;
LABEL_25:
  if (!memcmp(v14, "<eps>", v13)) {
    goto LABEL_57;
  }
LABEL_26:
  *a3 = 0LL;
  a3[1] = 0LL;
  a3[2] = 0LL;
  if (RXAutomationModeResult())
  {
    double v16 = sub_100098914(*(CFLocaleRef **)(a1 + 96), *(const __CFString **)(a1 + 24));
    CFIndex v17 = 0LL;
    uint64_t v74 = 0LL;
    uint64_t v75 = 0LL;
    int v18 = (void *)(a1 + 32);
    uint64_t v76 = 0LL;
    while (v17 < CFArrayGetCount(v16))
    {
      ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(v16, v17);
      sub_100097D98(ValueAtIndex, 0, v72);
      CFIndex Count = CFArrayGetCount(v16);
      int v21 = (double *)operator new(0x40uLL);
      if (SHIBYTE(v73) < 0)
      {
        sub_10005AA70(__p, v72[0], (unint64_t)v72[1]);
      }

      else
      {
        *(_OWORD *)__p = *(_OWORD *)v72;
        v66 = v73;
      }

      sub_100099710(v21, (__int128 *)__p, v17 != Count - 1, v17 != 0, 0.0, 0.0, 0.0, 0.0);
      int v71 = v21;
      if (SHIBYTE(v66) < 0) {
        operator delete(__p[0]);
      }
      xpc_type_t v23 = *(void **)(a1 + 40);
      unint64_t v22 = *(void *)(a1 + 48);
      if ((unint64_t)v23 >= v22)
      {
        uint64_t v26 = ((uint64_t)v23 - *v18) >> 3;
        uint64_t v27 = v22 - *v18;
        uint64_t v28 = v27 >> 2;
        else {
          unint64_t v29 = v28;
        }
        uint64_t v68 = a1 + 48;
        if (v29) {
          __int128 v30 = (char *)sub_100018788(a1 + 48, v29);
        }
        else {
          __int128 v30 = 0LL;
        }
        uint64_t v31 = &v30[8 * v26];
        __p[0] = v30;
        __p[1] = v31;
        unint64_t v67 = &v30[8 * v29];
        double v32 = v71;
        int v71 = 0LL;
        *(void *)uint64_t v31 = v32;
        v66 = v31 + 8;
        sub_100018700((uint64_t *)(a1 + 32), __p);
        __int128 v25 = *(void **)(a1 + 40);
        sub_1000188CC((uint64_t)__p);
      }

      else
      {
        uint64_t v24 = v71;
        int v71 = 0LL;
        *xpc_type_t v23 = v24;
        __int128 v25 = v23 + 1;
        *(void *)(a1 + 40) = v25;
      }

      *(void *)(a1 + 40) = v25;
      std::to_string(&v70, (((uint64_t)v25 - *(void *)(a1 + 32)) >> 3) - 1);
      sub_100017F30((char *)__p, (__int128 *)&v70, (__int128 *)&__s1);
      sub_100014A4C(&v74, (__int128 *)__p);
      if (v69 < 0) {
        operator delete(v67);
      }
      if (SHIBYTE(v66) < 0) {
        operator delete(__p[0]);
      }
      uint64_t v33 = (void **)v71;
      int v71 = 0LL;
      if (v33) {
        sub_1000186C8((int)&v71, v33);
      }
      if (SHIBYTE(v73) < 0) {
        operator delete(v72[0]);
      }
      ++v17;
    }

    sub_100014BF4(a3, (uint64_t)&v74);
    if (v16) {
      CFRelease(v16);
    }
    __p[0] = &v74;
    sub_10001A214((void ***)__p);
  }

  else
  {
    CFIndex v35 = 0LL;
    char v36 = (void *)(a1 + 32);
    while (v35 < CFArrayGetCount(*(CFArrayRef *)(a1 + 8)))
    {
      uint64_t v37 = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 8), v35);
      if (v37)
      {
        Tokens = (const __CFArray *)RDASRWSpeechRecognitionGetTokens((uint64_t)v37);
        CFIndex v39 = 0LL;
        uint64_t v74 = 0LL;
        uint64_t v75 = 0LL;
        uint64_t v76 = 0LL;
        while (v39 < CFArrayGetCount(Tokens))
        {
          __int128 v40 = (void *)CFArrayGetValueAtIndex(Tokens, v39);
          TokenName = (const __CFString *)RDASRWSpeechRecognitionTokenGetTokenName(v40);
          sub_100097D98(TokenName, 0, v72);
          RDASRWSpeechRecognitionTokenGetStart(v40);
          double v43 = v42;
          RDASRWSpeechRecognitionTokenGetEnd(v40);
          double v45 = v44;
          RDASRWSpeechRecognitionTokenGetSilenceStart(v40);
          double v47 = v46;
          RDASRWSpeechRecognitionTokenGetConfidence(v40);
          double v49 = v48;
          unsigned int v50 = RDASRWSpeechRecognitionTokenHasSpaceAfter(v40);
          double v51 = (double *)operator new(0x40uLL);
          if (SHIBYTE(v73) < 0)
          {
            sub_10005AA70(__p, v72[0], (unint64_t)v72[1]);
          }

          else
          {
            *(_OWORD *)__p = *(_OWORD *)v72;
            v66 = v73;
          }

          sub_100099710(v51, (__int128 *)__p, v50 != 0, 1, v43, v45, v47, v49);
          int v71 = v51;
          if (SHIBYTE(v66) < 0) {
            operator delete(__p[0]);
          }
          int v53 = *(void **)(a1 + 40);
          unint64_t v52 = *(void *)(a1 + 48);
          if ((unint64_t)v53 >= v52)
          {
            uint64_t v56 = ((uint64_t)v53 - *v36) >> 3;
            uint64_t v57 = v52 - *v36;
            uint64_t v58 = v57 >> 2;
            else {
              unint64_t v59 = v58;
            }
            uint64_t v68 = a1 + 48;
            if (v59) {
              unint64_t v60 = (char *)sub_100018788(a1 + 48, v59);
            }
            else {
              unint64_t v60 = 0LL;
            }
            uint64_t v61 = &v60[8 * v56];
            __p[0] = v60;
            __p[1] = v61;
            unint64_t v67 = &v60[8 * v59];
            unint64_t v62 = v71;
            int v71 = 0LL;
            *(void *)uint64_t v61 = v62;
            v66 = v61 + 8;
            sub_100018700((uint64_t *)(a1 + 32), __p);
            uint64_t v55 = *(void **)(a1 + 40);
            sub_1000188CC((uint64_t)__p);
          }

          else
          {
            BOOL v54 = v71;
            int v71 = 0LL;
            void *v53 = v54;
            uint64_t v55 = v53 + 1;
            *(void *)(a1 + 40) = v55;
          }

          *(void *)(a1 + 40) = v55;
          std::to_string(&v70, (((uint64_t)v55 - *(void *)(a1 + 32)) >> 3) - 1);
          sub_100017F30((char *)__p, (__int128 *)&v70, (__int128 *)&__s1);
          sub_100014A4C(&v74, (__int128 *)__p);
          if (v69 < 0) {
            operator delete(v67);
          }
          if (SHIBYTE(v66) < 0) {
            operator delete(__p[0]);
          }
          uint64_t v63 = (void **)v71;
          int v71 = 0LL;
          if (v63) {
            sub_1000186C8((int)&v71, v63);
          }
          if (SHIBYTE(v73) < 0) {
            operator delete(v72[0]);
          }
          ++v39;
        }

        sub_100014BF4(a3, (uint64_t)&v74);
        __p[0] = &v74;
        sub_10001A214((void ***)__p);
      }

      ++v35;
    }
  }

      *(void *)&v84 = swift_bridgeObjectRelease(v133, v132).n128_u64[0];
      char v85 = v27[82];
      std::string v86 = v27[81];
      uint64_t v87 = v27[80];
      objc_msgSend(v312, "addObject:", v326, v84);

      (*(void (**)(uint64_t, uint64_t))(v86 + 8))(v85, v87);
      v82 = v313 + 1;
      uint64_t v80 = v309;
      if (v313 + 1 == v311) {
        goto LABEL_40;
      }
    }

    goto LABEL_70;
  }

LABEL_98:
  __p[0] = &v78;
  sub_10001A214((void ***)__p);
}

  sub_10000A2DC(buf, v56.__r_.__value_.__l.__data_);
  sub_10000A2DC(&__p, v56.__r_.__value_.__l.__data_);
  sub_10005D67C(a3, v52, v51, (uint64_t)buf, (uint64_t)&__p, 0.0);
LABEL_99:
  if (SHIBYTE(cap) < 0) {
    operator delete(*(void **)buf);
  }
}

void sub_1000148C8( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, void *a21, uint64_t a22, int a23, __int16 a24, char a25, char a26, void *a27, void *a28, uint64_t a29, int a30, __int16 a31, char a32, char a33, uint64_t a34, uint64_t a35, uint64_t a36, void *__p, uint64_t a38, int a39, __int16 a40, char a41, char a42)
{
  a34 = a10;
  sub_1000180A4((void ***)&a34);
  if (a42 < 0) {
    operator delete(__p);
  }
  __p = (void *)(v42 - 144);
  sub_10001A214((void ***)&__p);
  _Unwind_Resume(a1);
}

void **sub_100014A4C(uint64_t *a1, __int128 *a2)
{
  unint64_t v6 = a1[2];
  uint64_t result = (void **)(a1 + 2);
  unint64_t v5 = v6;
  unint64_t v7 = (unint64_t)*(result - 1);
  if (v7 >= v6)
  {
    unint64_t v11 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v7 - *a1) >> 4);
    unint64_t v12 = v11 + 1;
    if (v11 + 1 > 0x555555555555555LL) {
      sub_100018774();
    }
    unint64_t v13 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v5 - *a1) >> 4);
    if (2 * v13 > v12) {
      unint64_t v12 = 2 * v13;
    }
    if (v13 >= 0x2AAAAAAAAAAAAAALL) {
      unint64_t v14 = 0x555555555555555LL;
    }
    else {
      unint64_t v14 = v12;
    }
    v19[4] = result;
    if (v14) {
      size_t v15 = (char *)sub_100019FD4((uint64_t)result, v14);
    }
    else {
      size_t v15 = 0LL;
    }
    double v16 = &v15[48 * v11];
    v19[0] = v15;
    v19[1] = v16;
    v19[3] = &v15[48 * v14];
    __int128 v17 = *a2;
    *((void *)v16 + 2) = *((void *)a2 + 2);
    *(_OWORD *)double v16 = v17;
    *((void *)a2 + 1) = 0LL;
    *((void *)a2 + 2) = 0LL;
    *(void *)a2 = 0LL;
    __int128 v18 = *(__int128 *)((char *)a2 + 24);
    *((void *)v16 + 5) = *((void *)a2 + 5);
    *(_OWORD *)(v16 + 24) = v18;
    *((void *)a2 + 4) = 0LL;
    *((void *)a2 + 5) = 0LL;
    *((void *)a2 + 3) = 0LL;
    v19[2] = v16 + 48;
    sub_10001A298(a1, v19);
    uint64_t v10 = a1[1];
    uint64_t result = sub_10001A444(v19);
  }

  else
  {
    __int128 v8 = *a2;
    *(void *)(v7 + 16) = *((void *)a2 + 2);
    *(_OWORD *)unint64_t v7 = v8;
    *((void *)a2 + 1) = 0LL;
    *((void *)a2 + 2) = 0LL;
    *(void *)a2 = 0LL;
    __int128 v9 = *(__int128 *)((char *)a2 + 24);
    *(void *)(v7 + 40) = *((void *)a2 + 5);
    *(_OWORD *)(v7 + 24) = v9;
    *((void *)a2 + 4) = 0LL;
    *((void *)a2 + 5) = 0LL;
    *((void *)a2 + 3) = 0LL;
    uint64_t v10 = v7 + 48;
    a1[1] = v7 + 48;
  }

  a1[1] = v10;
  return result;
}

void sub_100014BA0(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

uint64_t sub_100014BB4(uint64_t a1)
{
  return a1;
}

void **sub_100014BF4(uint64_t *a1, uint64_t a2)
{
  unint64_t v6 = a1[2];
  uint64_t result = (void **)(a1 + 2);
  unint64_t v5 = v6;
  unint64_t v7 = *(result - 1);
  if ((unint64_t)v7 >= v6)
  {
    unint64_t v9 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v7 - *a1) >> 3);
    unint64_t v10 = v9 + 1;
    if (v9 + 1 > 0xAAAAAAAAAAAAAAALL) {
      sub_100018774();
    }
    unint64_t v11 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v5 - *a1) >> 3);
    if (2 * v11 > v10) {
      unint64_t v10 = 2 * v11;
    }
    if (v11 >= 0x555555555555555LL) {
      unint64_t v12 = 0xAAAAAAAAAAAAAAALL;
    }
    else {
      unint64_t v12 = v10;
    }
    v16[4] = result;
    unint64_t v13 = (char *)sub_100018F00((uint64_t)result, v12);
    unint64_t v14 = &v13[24 * v9];
    v16[0] = v13;
    v16[1] = v14;
    v16[3] = &v13[24 * v15];
    *((void *)v14 + 1) = 0LL;
    *((void *)v14 + 2) = 0LL;
    *(void *)unint64_t v14 = 0LL;
    *(_OWORD *)unint64_t v14 = *(_OWORD *)a2;
    *((void *)v14 + 2) = *(void *)(a2 + 16);
    *(void *)a2 = 0LL;
    *(void *)(a2 + _Block_object_dispose(va, 8) = 0LL;
    *(void *)(a2 + 16) = 0LL;
    v16[2] = v14 + 24;
    sub_10001A4B8(a1, v16);
    __int128 v8 = (void *)a1[1];
    uint64_t result = sub_10001A648(v16);
  }

  else
  {
    *unint64_t v7 = 0LL;
    v7[1] = 0LL;
    _OWORD v7[2] = 0LL;
    *(_OWORD *)unint64_t v7 = *(_OWORD *)a2;
    _OWORD v7[2] = *(void *)(a2 + 16);
    *(void *)a2 = 0LL;
    *(void *)(a2 + _Block_object_dispose(va, 8) = 0LL;
    *(void *)(a2 + 16) = 0LL;
    __int128 v8 = v7 + 3;
    a1[1] = (uint64_t)(v7 + 3);
  }

  a1[1] = (uint64_t)v8;
  return result;
}

void sub_100014D1C(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

uint64_t RDQSRResultLMNodeBuilder::RDQSRResultLMNodeBuilder( uint64_t a1, std::string::size_type *a2, uint64_t a3, void *a4)
{
  __int128 v8 = sub_10001A6C8((void *)a1, 1uLL);
  *(_OWORD *)(v8 + 3) = 0u;
  unint64_t v9 = v8 + 3;
  v8[9] = 0LL;
  *(_OWORD *)(v8 + 7) = 0u;
  *(_OWORD *)(v8 + 5) = 0u;
  *((_DWORD *)v8 + 20) = 1065353216;
  v8[13] = 0LL;
  v8[12] = v8 + 13;
  v8[14] = 0LL;
  v8[15] = v8;
  uint8_t v8[16] = a3;
  v8[17] = a2;
  *((_DWORD *)v8 + 37) = 0;
  unint64_t v10 = (_OWORD *)*v8;
  v10[1] = 0u;
  v10[2] = 0u;
  *unint64_t v10 = 0u;
  *(_BYTE *)void *v8 = 10;
  *(void *)(*(void *)a1 + 32LL) = xpc_array_create(0LL, 0LL);
  uint64_t int64 = xpc_dictionary_get_uint64(a4, kRDKeyObjectID);
  xpc_object_t v12 = xpc_uint64_create(uint64);
  xpc_array_append_value(*(xpc_object_t *)(*(void *)a1 + 32LL), v12);
  xpc_release(v12);
  ++*(_WORD *)(*(void *)a1 + 4LL);
  unint64_t v13 = *(void **)(a1 + 32);
  unint64_t v14 = *(void *)(a1 + 40);
  if ((unint64_t)v13 >= v14)
  {
    uint64_t v16 = ((uint64_t)v13 - *v9) >> 3;
    uint64_t v17 = v14 - *v9;
    uint64_t v18 = v17 >> 2;
    else {
      unint64_t v19 = v18;
    }
    if (v19) {
      float v20 = (char *)sub_100018788(a1 + 40, v19);
    }
    else {
      float v20 = 0LL;
    }
    int v21 = &v20[8 * v16];
    unint64_t v22 = &v20[8 * v19];
    *(void *)int v21 = 0LL;
    uint64_t v15 = v21 + 8;
    uint64_t v24 = *(char **)(a1 + 24);
    xpc_type_t v23 = *(char **)(a1 + 32);
    if (v23 != v24)
    {
      do
      {
        uint64_t v25 = *((void *)v23 - 1);
        v23 -= 8;
        *((void *)v21 - 1) = v25;
        v21 -= 8;
      }

      while (v23 != v24);
      xpc_type_t v23 = (char *)*v9;
    }

    *(void *)(a1 + 24) = v21;
    *(void *)(a1 + 32) = v15;
    *(void *)(a1 + 40) = v22;
    if (v23) {
      operator delete(v23);
    }
  }

  else
  {
    *unint64_t v13 = 0LL;
    uint64_t v15 = v13 + 1;
  }

  *(void *)(a1 + 32) = v15;
  *(_DWORD *)(a1 + 144) = 0;
  std::string::size_type v27 = *a2;
  std::string::size_type v26 = a2[1];
  if (*a2 != v26)
  {
    uint64_t v42 = v9;
    unsigned int v28 = 1;
    char v29 = 1;
    while (1)
    {
      __int128 v30 = (void *)(v27 + 24);
      size_t v31 = strlen("<eps>");
      if (*(char *)(v27 + 47) < 0)
      {
        if (v31 != *(void *)(v27 + 32))
        {
          __int128 v30 = (void *)*v30;
          goto LABEL_32;
        }

        if (v31 == -1LL) {
LABEL_52:
        }
          sub_10001801C();
        __int128 v30 = (void *)*v30;
      }

      else
      {
        if (v31 == -1LL) {
          goto LABEL_52;
        }
      }

      if (!memcmp(v30, "<eps>", v31))
      {
        double v32 = (os_log_s *)RXOSLog();
        if (os_log_type_enabled(v32, OS_LOG_TYPE_INFO))
        {
          std::string::size_type v33 = v27;
          LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
          *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = v33;
          _os_log_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_INFO, "Word Inserted : %s", (uint8_t *)&buf, 0xCu);
        }

        goto LABEL_44;
      }

LABEL_32:
      sub_10000A2DC(&buf, (char *)v30);
      *(void *)(a1 + 8_Block_object_dispose(va, 8) = std::stoull(&buf, 0LL, 10);
      if ((char)buf.__r_.__value_.__s.__size_ < 0)
      {
        operator delete(buf.__r_.__value_.__l.__data_);
        if ((v29 & 1) == 0)
        {
LABEL_36:
          unint64_t v34 = *(void *)(a1 + 32) - *(void *)(a1 + 24);
          unint64_t v35 = v34 >> 3;
          if (v28 >= (v34 >> 3))
          {
            char v29 = 0;
          }

          else
          {
            uint64_t v36 = (v34 >> 3);
            uint64_t v37 = 8LL * v28;
            do
            {
              *(_DWORD *)(a1 + 144) = v28;
              RDQSRResultLMNodeBuilder::EvaluateNextLMNode( (RDQSRResultLMNodeBuilder *)a1,  *(_DWORD *)(*(void *)(a1 + 24) + v37));
              if (v36 == (uint64_t)(*(void *)(a1 + 32) - *(void *)(a1 + 24)) >> 3)
              {
                unint64_t v38 = (os_log_s *)RXOSLog();
                if (os_log_type_enabled(v38, OS_LOG_TYPE_ERROR))
                {
                  LOWORD(buf.__r_.__value_.__l.__data_) = 0;
                  _os_log_impl( (void *)&_mh_execute_header,  v38,  OS_LOG_TYPE_ERROR,  "Search failed!",  (uint8_t *)&buf,  2u);
                }
              }

              ++v28;
              v37 += 8LL;
            }

            while ((_DWORD)v35 != v28);
            char v29 = 0;
            unsigned int v28 = v35;
          }

          goto LABEL_44;
        }
      }

      else if ((v29 & 1) == 0)
      {
        goto LABEL_36;
      }

      RDQSRResultLMNodeBuilder::EvaluateLMNode((RDQSRResultLMNodeBuilder *)a1, 0);
      char v29 = 0;
      *(_DWORD *)(a1 + 144) = 0;
LABEL_44:
      v27 += 48LL;
      if (v27 == v26)
      {
        uint64_t v15 = *(void **)(a1 + 32);
        unint64_t v9 = v42;
        goto LABEL_47;
      }
    }
  }

  unsigned int v28 = 1;
LABEL_47:
  uint64_t v39 = v28;
  __int128 v40 = (char *)*v9;
  if (v28 < (unint64_t)(((uint64_t)v15 - *v9) >> 3))
  {
    do
    {
      if (RDQSRResultLMNodeBuilder::LMNodeIsTerminal( (RDQSRResultLMNodeBuilder *)a1,  *(_DWORD *)&v40[8 * v39])) {
        *(_DWORD *)(a1 + 14_Block_object_dispose(va, 8) = v28;
      }
      __int128 v40 = *(char **)(a1 + 24);
      uint64_t v39 = ++v28;
    }

    while (v28 < (unint64_t)((uint64_t)(*(void *)(a1 + 32) - (void)v40) >> 3));
  }

  return a1;
}

  __break(1u);
  return result;
}

  uint64_t result = _fatalErrorMessage(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  "UnsafeMutablePointer.initialize overlapping range",  49LL,  2LL,  "Swift/UnsafePointer.swift",  25LL,  2,  1092LL,  0);
  __break(1u);
  return result;
}

    if (*((void *)&v17 + 1)) {
      --**((_DWORD **)&v17 + 1);
    }
LABEL_34:
    if (v20) {
      (*(void (**)(uint64_t))(*(void *)v20 + 32LL))(v20);
    }
    else {
      ++v22;
    }
  }

  if (v20) {
    (*(void (**)(void))(*(void *)v20 + 8LL))();
  }
LABEL_39:
  *(void *)(a1 + _Block_object_dispose(va, 8) = (*(uint64_t (**)(uint64_t, uint64_t, void))(*(void *)a2 + 56LL))( a2,  0xFFFFFFFF0004LL,  0LL) | *(void *)(a1 + 8) & 4LL | 3;
  return a1;
}

  *a3 = v8;
  return result;
}

    if (*((void *)&v17 + 1)) {
      --**((_DWORD **)&v17 + 1);
    }
LABEL_34:
    if (v20) {
      (*(void (**)(uint64_t))(*(void *)v20 + 32LL))(v20);
    }
    else {
      ++v22;
    }
  }

  if (v20) {
    (*(void (**)(void))(*(void *)v20 + 8LL))();
  }
LABEL_39:
  *(void *)(a1 + _Block_object_dispose(va, 8) = (*(uint64_t (**)(uint64_t, uint64_t, void))(*(void *)a2 + 56LL))( a2,  0xFFFFFFFF0004LL,  0LL) | *(void *)(a1 + 8) & 4LL | 3;
  return a1;
}

void sub_100015160( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  uint64_t v25 = *v22;
  if (*v22)
  {
    *(void *)(v20 + 32) = v25;
    operator delete(v25);
  }

  std::string::size_type v26 = *(void **)v20;
  if (*(void *)v20)
  {
    *(void *)(v20 + _Block_object_dispose(va, 8) = v26;
    operator delete(v26);
  }

  _Unwind_Resume(a1);
}

void RDQSRResultLMNodeBuilder::EvaluateLMNode(RDQSRResultLMNodeBuilder *this, unsigned int a2)
{
  uint64_t v3 = (_OWORD *)(*(void *)this + 48LL * a2);
  __int128 v4 = v3[2];
  *(_OWORD *)std::string::size_type v26 = *v3;
  __int128 v27 = v3[1];
  *(_OWORD *)xarray = v4;
  switch(LOBYTE(v26[0]))
  {
    case 0xA:
      if (!xarray[0]) {
        goto LABEL_31;
      }
      if (v26[2])
      {
        size_t v6 = 0LL;
        do
        {
          uint64_t int64 = xpc_array_get_uint64(xarray[0], v6);
          unsigned int LMNode = RDQSRResultLMNodeBuilder::FindLMNode(this, a2, v6, 0, 0LL, uint64);
          RDQSRResultLMNodeBuilder::EvaluateLMNode(this, LMNode);
          ++v6;
        }

        while (v26[2] != v6);
      }

      break;
    case 0xB:
      if (!xarray[0] || !v26[2]) {
        goto LABEL_31;
      }
      uint64_t v9 = xpc_array_get_uint64(xarray[0], 0LL);
      unsigned int v10 = RDQSRResultLMNodeBuilder::FindLMNode(this, a2, 0, 0, 0LL, v9);
      RDQSRResultLMNodeBuilder::EvaluateLMNode(this, v10);
      break;
    case 0xC:
      goto LABEL_12;
    case 0xD:
      if (!sub_10001AA0C((void *)this + 6, (unint64_t *)&v27))
      {
        char v29 = &v27;
        *((_DWORD *)sub_100018114( (uint64_t)this + 48,  (unint64_t *)&v27,  (uint64_t)&unk_1000AB73F,  (void **)&v29)
        + 6) = a2;
      }

void RDQSRResultLMNodeBuilder::EvaluateNextLMNode(RDQSRResultLMNodeBuilder *this, unsigned int a2)
{
  uint64_t v3 = (unsigned __int8 *)(*(void *)this + 48LL * a2);
  int v4 = *v3;
  int v5 = *((unsigned __int16 *)v3 + 1);
  __int16 v6 = *((_WORD *)v3 + 3);
  unsigned int v7 = *((_DWORD *)v3 + 2);
  __int128 v8 = (void *)*((void *)v3 + 3);
  int v9 = (v3[1] >> 3) & 1;
  if (v5 == 0xFFFF) {
    int v9 = 0;
  }
  if (v4 == 13)
  {
    if (!v9) {
      goto LABEL_9;
    }
LABEL_8:
    unsigned int LMNode = RDQSRResultLMNodeBuilder::FindLMNode(this, v7, v6, (unsigned __int16)v5 + 1, v8, 0LL);
    RDQSRResultLMNodeBuilder::EvaluateLMNode(this, LMNode);
    goto LABEL_9;
  }

  if (v4 == 12 && (v9 & 1) != 0) {
    goto LABEL_8;
  }
LABEL_9:
  RDQSRResultLMNodeBuilder::EvaluateParentLMNode(this, v7, v6);
}

uint64_t RDQSRResultLMNodeBuilder::LMNodeIsTerminal(RDQSRResultLMNodeBuilder *this, unsigned int a2)
{
  uint64_t v2 = *(void *)this;
  uint64_t v3 = (unsigned __int8 *)(*(void *)this + 48LL * a2);
  for (unsigned int i = *((_DWORD *)v3 + 2); i; unsigned int i = *((_DWORD *)v3 + 2))
  {
    unsigned int v6 = i;
    int v7 = *(unsigned __int8 *)(v2 + 48LL * i);
    if (v7 != 10)
    {
      if (v7 == 11)
      {
        uint64_t v8 = v2 + 48LL * v6;
        int v9 = (unsigned __int16 *)(v8 + 4);
        unsigned int v10 = (xpc_object_t *)(v8 + 32);
        size_t v11 = *((unsigned __int16 *)v3 + 3) + 1LL;
        while (v11 < *v9)
        {
          uint64_t int64 = xpc_array_get_uint64(*v10, v11);
          unsigned int LMNode = RDQSRResultLMNodeBuilder::FindLMNode(this, v6, v11++, 0, 0LL, uint64);
          if ((RDQSRResultLMNodeBuilder::LMNodeIsOptional(this, LMNode) & 1) == 0) {
            return 0LL;
          }
        }
      }

      else
      {
        __RXAbort( 1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/SpeechRecognitionCore/Daemon/RDQSRResult.cc",  1313LL,  0LL,  @"LMNodeIsTerminal unexpected parent node type %d\n",  *v3);
      }
    }

    uint64_t v2 = *(void *)this;
    uint64_t v3 = (unsigned __int8 *)(*(void *)this + 48LL * v6);
  }

  return 1LL;
}

uint64_t RDQSRResultLMNodeBuilder::FindLMNode( RDQSRResultLMNodeBuilder *this, unsigned int a2, __int16 a3, __int16 a4, void *a5, unint64_t a6)
{
  uint64_t v12 = (char *)this + 104;
  uint64_t v11 = *(void *)this;
  unint64_t v39 = a6;
  *(_DWORD *)(v11 + _Block_object_dispose(va, 8) = a2;
  *(_WORD *)(v11 + 6) = a3;
  *(_WORD *)(v11 + 2) = a4;
  unint64_t v13 = (uint64_t **)((char *)this + 96);
  LODWORD(v40) = 0;
  uint64_t v14 = sub_10001A7E8((uint64_t)this + 96, (unsigned int *)&v40);
  if (a2) {
    uint64_t v16 = (uint64_t ***)(*(void *)this + 48LL * a2 + 40);
  }
  else {
    uint64_t v16 = (uint64_t ***)((char *)this + 128);
  }
  uint64_t v17 = *v16;
  unint64_t v38 = *v16;
  if (a5 || (__int128 v40 = &v39, (a5 = (void *)sub_100019C58(v17, &v39, (uint64_t)&unk_1000AB73F, (uint64_t **)&v40)[5]) != 0LL))
  {
    char int64 = xpc_dictionary_get_int64(a5, kRDKeyObjectType);
    uchar int64 = xpc_dictionary_get_uint64(a5, kRDKeyOptions);
    xpc_object_t value = xpc_dictionary_get_value(a5, kRDKeyChildren);
    uint64_t v12 = (char *)xpc_dictionary_get_uint64(a5, kRDKeyObjectID);
    char v36 = uint64;
    if (value) {
      __int16 count = xpc_array_get_count(value);
    }
    else {
      __int16 count = 0;
    }
  }

  else
  {
    xpc_object_t value = 0LL;
    __int16 count = 0;
    char v36 = 0;
    char int64 = 11;
  }

  uint64_t v22 = *(void *)this;
  unint64_t v21 = *((void *)this + 1);
  uint64_t v23 = (uint64_t)(v21 - *(void *)this) / 48;
  LODWORD(v40) = v23;
  unint64_t v24 = *((void *)this + 2);
  if (v21 >= v24)
  {
    unint64_t v26 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v24 - v22) >> 4);
    uint64_t v27 = 2 * v26;
    if (2 * v26 <= v23 + 1) {
      uint64_t v27 = v23 + 1;
    }
    if (v26 >= 0x2AAAAAAAAAAAAAALL) {
      unint64_t v28 = 0x555555555555555LL;
    }
    else {
      unint64_t v28 = v27;
    }
    if (v28) {
      char v29 = (char *)sub_100019FD4((uint64_t)this + 16, v28);
    }
    else {
      char v29 = 0LL;
    }
    __int128 v30 = &v29[48 * v23];
    size_t v31 = &v29[48 * v28];
    *__int128 v30 = int64;
    v30[1] = v36;
    *((_WORD *)v30 + 1) = a4;
    *((_WORD *)v30 + 2) = count;
    *((_WORD *)v30 + 3) = a3;
    *((_DWORD *)v30 + 2) = a2;
    *((void *)v30 + 2) = v12;
    *((void *)v30 + 3) = a5;
    *((void *)v30 + 4) = value;
    *((void *)v30 + 5) = v38;
    uint64_t v25 = v30 + 48;
    std::string::size_type v33 = *(char **)this;
    double v32 = (char *)*((void *)this + 1);
    if (v32 != *(char **)this)
    {
      do
      {
        __int128 v34 = *((_OWORD *)v32 - 3);
        __int128 v35 = *((_OWORD *)v32 - 1);
        *((_OWORD *)v30 - 2) = *((_OWORD *)v32 - 2);
        *((_OWORD *)v30 - 1) = v35;
        *((_OWORD *)v30 - 3) = v34;
        v30 -= 48;
        v32 -= 48;
      }

      while (v32 != v33);
      double v32 = *(char **)this;
    }

    *(void *)this = v30;
    *((void *)this + 1) = v25;
    *((void *)this + 2) = v31;
    if (v32) {
      operator delete(v32);
    }
  }

  else
  {
    *(_BYTE *)unint64_t v21 = int64;
    *(_BYTE *)(v21 + 1) = v36;
    *(_WORD *)(v21 + 2) = a4;
    *(_WORD *)(v21 + 4) = count;
    *(_WORD *)(v21 + 6) = a3;
    *(_DWORD *)(v21 + _Block_object_dispose(va, 8) = a2;
    *(void *)(v21 + 16) = v12;
    *(void *)(v21 + 24) = a5;
    uint64_t v25 = (char *)(v21 + 48);
    *(void *)(v21 + 32) = value;
    *(void *)(v21 + 40) = v38;
  }

  *((void *)this + 1) = v25;
  sub_10001A8F4(v13, (unsigned int *)&v40, &v40);
  return v40;
}

void RDQSRResultLMNodeBuilder::EvaluateParentLMNode( RDQSRResultLMNodeBuilder *this, unsigned int a2, __int16 a3)
{
  if (a2)
  {
    unsigned int v4 = a2;
    do
    {
      unsigned int v6 = v4;
      __int16 v7 = a3;
      uint64_t v8 = (unsigned __int8 *)(*(void *)this + 48LL * v4);
      int v9 = *v8;
      int v10 = *((unsigned __int16 *)v8 + 1);
      a3 = *((_WORD *)v8 + 3);
      unsigned int v4 = *((_DWORD *)v8 + 2);
      int v11 = (v8[1] >> 3) & 1;
      if (v10 == 0xFFFF) {
        int v11 = 0;
      }
      if (v9 == 10)
      {
        if ((v11 & 1) != 0) {
          goto LABEL_11;
        }
      }

      else
      {
        if (v9 != 11)
        {
          __RXAbort( 1,  (uint64_t)"/Library/Caches/com.apple.xbs/Sources/SpeechRecognitionCore/Daemon/RDQSRResult.cc",  1289LL,  0LL,  @"EvaluateParentLMNode unexpected node type %d\n",  *v8);
          return;
        }

        __int16 v12 = v7 + 1;
        if (*((unsigned __int16 *)v8 + 2) > (unsigned __int16)(v7 + 1))
        {
          uchar int64 = xpc_array_get_uint64(*((xpc_object_t *)v8 + 4), (unsigned __int16)(v7 + 1));
          unsigned int LMNode = RDQSRResultLMNodeBuilder::FindLMNode(this, v6, v12, v10, 0LL, uint64);
          RDQSRResultLMNodeBuilder::EvaluateLMNode(this, LMNode);
          return;
        }

        if (v11)
        {
LABEL_11:
          unsigned int v13 = RDQSRResultLMNodeBuilder::FindLMNode(this, v4, a3, (unsigned __int16)v10 + 1, *((void **)v8 + 3), 0LL);
          RDQSRResultLMNodeBuilder::EvaluateLMNode(this, v13);
        }
      }
    }

    while (v4);
  }

uint64_t RDQSRResultLMNodeBuilder::LMNodeIsOptional(RDQSRResultLMNodeBuilder *this, unsigned int a2)
{
  uint64_t v2 = (unsigned __int8 *)(*(void *)this + 48LL * a2);
  if ((v2[1] & 4) != 0) {
    return 1LL;
  }
  size_t v5 = *((unsigned __int16 *)v2 + 2);
  unsigned int v6 = (void *)*((void *)v2 + 4);
  int v7 = *v2;
  if (v7 == 10)
  {
    if ((_DWORD)v5)
    {
      size_t v17 = 0LL;
      size_t v18 = v5 - 1;
      do
      {
        uchar int64 = xpc_array_get_uint64(v6, v17);
        unsigned int LMNode = RDQSRResultLMNodeBuilder::FindLMNode(this, a2, v17, 0, 0LL, uint64);
        uint64_t result = RDQSRResultLMNodeBuilder::LMNodeIsOptional(this, LMNode);
        if ((result & 1) != 0) {
          break;
        }
      }

      while (v18 != v17++);
      return result;
    }

    return 1LL;
  }

  if (v7 != 11) {
    return 0LL;
  }
  if (!(_DWORD)v5) {
    return 1LL;
  }
  uint64_t v8 = xpc_array_get_uint64(v6, 0LL);
  unsigned int v9 = RDQSRResultLMNodeBuilder::FindLMNode(this, a2, 0, 0, 0LL, v8);
  int IsOptional = RDQSRResultLMNodeBuilder::LMNodeIsOptional(this, v9);
  uint64_t result = 0LL;
  if (IsOptional)
  {
    size_t v12 = 1LL;
    do
    {
      size_t v13 = v12;
      if (v5 == v12) {
        break;
      }
      uint64_t v14 = xpc_array_get_uint64(v6, v12);
      unsigned int v15 = RDQSRResultLMNodeBuilder::FindLMNode(this, a2, v13, 0, 0LL, v14);
      char v16 = RDQSRResultLMNodeBuilder::LMNodeIsOptional(this, v15);
      size_t v12 = v13 + 1;
    }

    while ((v16 & 1) != 0);
    return v13 >= v5;
  }

  return result;
}

void RDQSRResultLMNodeBuilder::~RDQSRResultLMNodeBuilder(RDQSRResultLMNodeBuilder *this)
{
  uint64_t v2 = (void *)*((void *)this + 3);
  if (v2)
  {
    *((void *)this + 4) = v2;
    operator delete(v2);
  }

  uint64_t v3 = *(void **)this;
  if (*(void *)this)
  {
    *((void *)this + 1) = v3;
    operator delete(v3);
  }

uint64_t RDQSRResultModelBuilder::RDQSRResultModelBuilder( uint64_t a1, uint64_t a2, __int128 *a3, uint64_t a4, int a5, int a6)
{
  *(void *)a1 = a2;
  __int128 v7 = *a3;
  __int128 v8 = a3[1];
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 24) = v8;
  *(_OWORD *)(a1 + _Block_object_dispose(va, 8) = v7;
  *(void *)(a1 + 40) = a4;
  *(_DWORD *)(a1 + 4_Block_object_dispose(va, 8) = a5;
  *(_DWORD *)(a1 + 52) = a6;
  *(_BYTE *)(a1 + 56) = 0;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  sub_10000A2DC((void *)(a1 + 128), "");
  *(void *)(a1 + 216) = 0LL;
  *(void *)(a1 + 20_Block_object_dispose(va, 8) = 0LL;
  *(_OWORD *)(a1 + 152) = 0u;
  *(_OWORD *)(a1 + 16_Block_object_dispose(va, 8) = 0u;
  *(_OWORD *)(a1 + 184) = 0u;
  *(void *)(a1 + 200) = a1 + 208;
  *(_DWORD *)(a1 + 232) = 0;
  return a1;
}

void sub_100015C84( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void **a10)
{
  a10 = (void **)(v10 + 80);
  sub_10001AAEC(&a10);
  sub_10001AAC0(v11, 0LL);
  _Unwind_Resume(a1);
}

BOOL RDQSRResultModelBuilder::spellMode(RDQSRResultModelBuilder *this)
{
  return *((_DWORD *)this + 13) < 2u;
}

void RDQSRResultModelBuilder::AddResultNodeForCurrentResult(RDQSRResultModelBuilder *this)
{
  unint64_t v2 = *((int *)this + 58);
  if ((int)v2 >= 1 && *((_DWORD *)this + 12) != 1)
  {
    __int128 v8 = (os_log_s *)RXOSLog();
    if (!os_log_type_enabled(v8, OS_LOG_TYPE_ERROR)) {
      return;
    }
    __int16 v12 = 0;
    unsigned int v9 = "ERROR: More than 1 result only allowed for close match results";
    uint64_t v10 = (uint8_t *)&v12;
    goto LABEL_10;
  }

  uint64_t v3 = (uint64_t *)*((void *)this + 5);
  uint64_t v4 = *v3;
  if (0xAAAAAAAAAAAAAAABLL * ((v3[1] - *v3) >> 3) <= v2) {
    sub_100019C44();
  }
  size_t v5 = (RDQSRResultLMNodeBuilder *)operator new(0x98uLL);
  RDQSRResultLMNodeBuilder::RDQSRResultLMNodeBuilder( (uint64_t)v5,  (std::string::size_type *)(v4 + 24LL * (int)v2),  *((void *)this + 3),  *((void **)this + 2));
  sub_10001AAC0((RDQSRResultLMNodeBuilder **)this + 8, v5);
  uint64_t v6 = *((void *)this + 8);
  uint64_t v7 = *(unsigned int *)(v6 + 148);
  if ((_DWORD)v7)
  {
    RDQSRResultModelBuilder::AddResultNode( this,  (unsigned int *)(*(void *)(v6 + 24) + 8 * v7),  -1431655765 * ((*(void *)(v4 + 24LL * (int)v2 + 8) - *(void *)(v4 + 24LL * (int)v2)) >> 4) - 1);
    RDQSRResultModelBuilder::EndOfResult(this);
    return;
  }

  __int128 v8 = (os_log_s *)RXOSLog();
  if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
  {
    __int16 v11 = 0;
    unsigned int v9 = "Discarding the result as the LMNode is not the terminal node. Grammar ojects have been updated but not the FST";
    uint64_t v10 = (uint8_t *)&v11;
LABEL_10:
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, v9, v10, 2u);
  }

void sub_100015E3C(_Unwind_Exception *a1)
{
}

uint64_t RDQSRResultModelBuilder::GetResulTokenForIndex(RDQSRResultModelBuilder *this, unsigned int a2)
{
  unint64_t v2 = (void *)*((void *)this + 5);
  unint64_t v3 = *((int *)this + 58);
  uint64_t v4 = (void *)(*v2 + 24LL * (int)v3);
  return RDQSRResult::GetResultToken(*(void *)this, (const char *)(*v4 + 48LL * a2), *((_DWORD *)this + 12));
}

void RDQSRResultModelBuilder::AddResultNode(RDQSRResultModelBuilder *a1, unsigned int *a2, unsigned int a3)
{
  uint64_t v6 = a2[1];
  if ((_DWORD)v6) {
    RDQSRResultModelBuilder::AddResultNode(a1, *(void *)(*((void *)a1 + 8) + 24LL) + 8 * v6, a3 - 1);
  }
  unsigned int v7 = *a2;
  uint64_t ResulTokenForIndex = RDQSRResultModelBuilder::GetResulTokenForIndex(a1, a3);
  RDQSRResultModelBuilder::AddResultNode((uint64_t)a1, v7, ResulTokenForIndex);
}

void RDQSRResultModelBuilder::EndOfResult(RDQSRResultModelBuilder *this)
{
  if (*((_BYTE *)this + 56)) {
    RDQSRResultModelBuilder::ProcessCurrentAdlib(this);
  }
  RDQSRResultModelBuilder::PropagateTimestamps(this, 0LL);
}

void RDQSRResultModelBuilder::AddResultNode(uint64_t a1, unsigned int a2, uint64_t a3)
{
  uint64_t v7 = **(void **)(a1 + 64);
  uint64_t v8 = v7 + 48LL * a2;
  if (!*(_BYTE *)(a1 + 56) || (*(_BYTE *)v8 == 13 ? (BOOL v9 = *(unsigned __int16 *)(v8 + 2) == 0) : (BOOL v9 = 1), v9))
  {
    uint64_t v10 = v7 + 48LL * a2;
    unsigned int v13 = *(_DWORD *)(v10 + 8);
    __int16 v12 = (unsigned int *)(v10 + 8);
    uint64_t v11 = v13;
    if (v13)
    {
      uint64_t v14 = *(void *)(a1 + 88);
      if (*(void *)(a1 + 80) == v14)
      {
        RDQSRResultModelBuilder::AddResultNode(a1, v11, 0LL);
      }

      else
      {
        if (*(_BYTE *)(a1 + 56))
        {
          RDQSRResultModelBuilder::ProcessCurrentAdlib((RDQSRResultModelBuilder *)a1);
          uint64_t v14 = *(void *)(a1 + 88);
          uint64_t v11 = *v12;
        }

        if (*(_DWORD *)(v14 - 24) != (_DWORD)v11) {
          RDQSRResultModelBuilder::PushAncestors((RDQSRResultModelBuilder *)a1, v11);
        }
      }
    }
  }

  if (*(_BYTE *)(a1 + 56)) {
    goto LABEL_56;
  }
  xpc_object_t v15 = xpc_dictionary_create(0LL, 0LL, 0LL);
  char v16 = kRDKeyObjectType;
  uint64_t v17 = v7 + 48LL * a2;
  int64_t int64 = xpc_dictionary_get_int64(*(xpc_object_t *)(v17 + 24), kRDKeyObjectType);
  xpc_dictionary_set_int64(v15, v16, int64);
  unint64_t v19 = kRDKeyObjectID;
  uint64_t int64 = xpc_dictionary_get_uint64(*(xpc_object_t *)(v17 + 24), kRDKeyObjectID);
  xpc_dictionary_set_uint64(v15, v19, uint64);
  if (a3)
  {
    xpc_dictionary_set_uint64( v15,  kRDKeyStartTime,  *(void *)(*(void *)a1 + 104LL) + (unint64_t)(*(double *)(a3 + 24) * 1000.0));
    xpc_dictionary_set_uint64( v15,  kRDKeyEndTime,  *(void *)(*(void *)a1 + 104LL) + (unint64_t)(*(double *)(a3 + 32) * 1000.0));
  }

  if ((*(_BYTE *)v8 & 0xFE) == 0xA)
  {
    xpc_object_t v21 = xpc_array_create(0LL, 0LL);
    xpc_dictionary_set_value(v15, kRDKeyChildren, v21);
  }

  else
  {
    xpc_object_t v21 = 0LL;
  }

  if (*(_DWORD *)(v7 + 48LL * a2 + 8))
  {
    xpc_array_append_value(*(xpc_object_t *)(*(void *)(a1 + 88) - 8LL), v15);
    if (v21)
    {
LABEL_22:
      unint64_t v22 = *(void *)(a1 + 96);
      unint64_t v23 = *(void *)(a1 + 88);
      if (v23 < v22)
      {
        *(_DWORD *)unint64_t v23 = a2;
        *(void *)(v23 + _Block_object_dispose(va, 8) = v15;
        *(void *)(v23 + 16) = v21;
LABEL_45:
        unint64_t v34 = v23 + 24;
        *(void *)(a1 + 8_Block_object_dispose(va, 8) = v23 + 24;
LABEL_54:
        *(void *)(a1 + 8_Block_object_dispose(va, 8) = v34;
        goto LABEL_55;
      }

      uint64_t v25 = *(void *)(a1 + 80);
      unint64_t v26 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v23 - v25) >> 3);
      unint64_t v27 = v26 + 1;
      if (v26 + 1 > 0xAAAAAAAAAAAAAAALL) {
        sub_100018774();
      }
      unint64_t v28 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v22 - v25) >> 3);
      if (2 * v28 > v27) {
        unint64_t v27 = 2 * v28;
      }
      if (v28 >= 0x555555555555555LL) {
        unint64_t v29 = 0xAAAAAAAAAAAAAAALL;
      }
      else {
        unint64_t v29 = v27;
      }
      uint64_t v80 = a1 + 96;
      __int128 v30 = (char *)sub_100018F00(a1 + 96, v29);
      size_t v31 = &v30[24 * v26];
      __p[0] = v30;
      __p[1] = v31;
      uint64_t v79 = &v30[24 * v32];
      *(_DWORD *)size_t v31 = a2;
      *((void *)v31 + 1) = v15;
      *((void *)v31 + 2) = v21;
      uint64_t v78 = v31 + 24;
      sub_10001AB98((uint64_t *)(a1 + 80), __p);
      goto LABEL_53;
    }
  }

  else
  {
    unint64_t v24 = *(void **)(a1 + 72);
    if (v24) {
      xpc_release(v24);
    }
    *(void *)(a1 + 72) = xpc_retain(v15);
    if (v21) {
      goto LABEL_22;
    }
  }

  if (*(_BYTE *)v8 == 13)
  {
    *(_BYTE *)(a1 + 56) = 1;
    if (*(char *)(a1 + 127) < 0)
    {
      **(_BYTE **)(a1 + 104) = 0;
      *(void *)(a1 + 112) = 0LL;
    }

    else
    {
      *(_BYTE *)(a1 + 104) = 0;
      *(_BYTE *)(a1 + 127) = 0;
    }

    *(void *)(a1 + 224) = 0LL;
    if (*(char *)(a1 + 151) < 0)
    {
      **(_BYTE **)(a1 + 12_Block_object_dispose(va, 8) = 0;
      *(void *)(a1 + 136) = 0LL;
    }

    else
    {
      *(_BYTE *)(a1 + 12_Block_object_dispose(va, 8) = 0;
      *(_BYTE *)(a1 + 151) = 0;
    }

    unint64_t v33 = *(void *)(a1 + 96);
    *(void *)(a1 + 160) = *(void *)(a1 + 152);
    *(void *)(a1 + 184) = *(void *)(a1 + 176);
    unint64_t v23 = *(void *)(a1 + 88);
    if (v23 < v33)
    {
      *(_DWORD *)unint64_t v23 = a2;
      *(void *)(v23 + _Block_object_dispose(va, 8) = v15;
      *(void *)(v23 + 16) = 0LL;
      goto LABEL_45;
    }

    uint64_t v35 = *(void *)(a1 + 80);
    unint64_t v36 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v23 - v35) >> 3);
    unint64_t v37 = v36 + 1;
    if (v36 + 1 > 0xAAAAAAAAAAAAAAALL) {
      sub_100018774();
    }
    unint64_t v38 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v33 - v35) >> 3);
    if (2 * v38 > v37) {
      unint64_t v37 = 2 * v38;
    }
    if (v38 >= 0x555555555555555LL) {
      unint64_t v39 = 0xAAAAAAAAAAAAAAALL;
    }
    else {
      unint64_t v39 = v37;
    }
    uint64_t v80 = a1 + 96;
    __int128 v40 = (char *)sub_100018F00(a1 + 96, v39);
    uint64_t v41 = &v40[24 * v36];
    __p[0] = v40;
    __p[1] = v41;
    uint64_t v79 = &v40[24 * v42];
    *(_DWORD *)uint64_t v41 = a2;
    *((void *)v41 + 1) = v15;
    *((void *)v41 + 2) = 0LL;
    uint64_t v78 = v41 + 24;
    sub_10001AB98((uint64_t *)(a1 + 80), __p);
LABEL_53:
    unint64_t v34 = *(void *)(a1 + 88);
    sub_10001ACE4((uint64_t)__p);
    goto LABEL_54;
  }

  if (v15) {
    xpc_release(v15);
  }
LABEL_55:
  if (!*(_BYTE *)(a1 + 56)) {
    return;
  }
LABEL_56:
  if (a3)
  {
    if (*(char *)(a3 + 23) < 0)
    {
      sub_10005AA70(__p, *(void **)a3, *(void *)(a3 + 8));
    }

    else
    {
      *(_OWORD *)__p = *(_OWORD *)a3;
      uint64_t v78 = *(void **)(a3 + 16);
    }

    if (SHIBYTE(v78) >= 0) {
      double v44 = __p;
    }
    else {
      double v44 = (void **)__p[0];
    }
    if (SHIBYTE(v78) >= 0) {
      std::string::size_type v45 = HIBYTE(v78);
    }
    else {
      std::string::size_type v45 = (std::string::size_type)__p[1];
    }
    std::string::append((std::string *)(a1 + 104), (const std::string::value_type *)v44, v45);
    if (SHIBYTE(v78) < 0) {
      operator delete(__p[0]);
    }
    if (*(char *)(a3 + 23) < 0)
    {
      sub_10005AA70(__p, *(void **)a3, *(void *)(a3 + 8));
    }

    else
    {
      *(_OWORD *)__p = *(_OWORD *)a3;
      uint64_t v78 = *(void **)(a3 + 16);
    }

    if (SHIBYTE(v78) >= 0) {
      double v46 = __p;
    }
    else {
      double v46 = (void **)__p[0];
    }
    if (SHIBYTE(v78) >= 0) {
      std::string::size_type v47 = HIBYTE(v78);
    }
    else {
      std::string::size_type v47 = (std::string::size_type)__p[1];
    }
    std::string::append((std::string *)(a1 + 128), (const std::string::value_type *)v46, v47);
    if (SHIBYTE(v78) < 0) {
      operator delete(__p[0]);
    }
    if (*(_BYTE *)(a3 + 56) && (RXIsLocaleWithNoSpaceInPostITN(*(void *)(*(void *)a1 + 120LL)) & 1) == 0) {
      std::string::push_back((std::string *)(a1 + 128), 32);
    }
    uint64_t v48 = *(void *)(a1 + 224);
    uint64_t v49 = *(void *)(v7 + 48LL * a2 + 16);
    if (!v48 || v48 == v49)
    {
      *(void *)(a1 + 224) = v49;
    }

    else
    {
      unsigned int v50 = (os_log_s *)RXOSLog();
      if (os_log_type_enabled(v50, OS_LOG_TYPE_ERROR))
      {
        LOWORD(__p[0]) = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v50,  OS_LOG_TYPE_ERROR,  "Multiple adlib IDs, some data will be lost",  (uint8_t *)__p,  2u);
      }
    }

    std::string::push_back((std::string *)(a1 + 104), 0);
    unint64_t v51 = *(void *)(*(void *)a1 + 104LL) + (unint64_t)(*(double *)(a3 + 24) * 1000.0);
    unint64_t v52 = *(unint64_t **)(a1 + 160);
    unint64_t v53 = *(void *)(a1 + 168);
    if ((unint64_t)v52 >= v53)
    {
      uint64_t v55 = *(unint64_t **)(a1 + 152);
      uint64_t v56 = v52 - v55;
      unint64_t v57 = v53 - (void)v55;
      unint64_t v58 = (uint64_t)(v53 - (void)v55) >> 2;
      if (v58 <= v56 + 1) {
        unint64_t v58 = v56 + 1;
      }
      if (v57 >= 0x7FFFFFFFFFFFFFF8LL) {
        unint64_t v59 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v59 = v58;
      }
      if (v59)
      {
        unint64_t v60 = (char *)sub_100018788(a1 + 168, v59);
        uint64_t v55 = *(unint64_t **)(a1 + 152);
        unint64_t v52 = *(unint64_t **)(a1 + 160);
      }

      else
      {
        unint64_t v60 = 0LL;
      }

      uint64_t v61 = (unint64_t *)&v60[8 * v56];
      unint64_t v62 = &v60[8 * v59];
      unint64_t *v61 = v51;
      BOOL v54 = v61 + 1;
      while (v52 != v55)
      {
        unint64_t v63 = *--v52;
        *--uint64_t v61 = v63;
      }

      *(void *)(a1 + 152) = v61;
      *(void *)(a1 + 160) = v54;
      *(void *)(a1 + 16_Block_object_dispose(va, 8) = v62;
      if (v55) {
        operator delete(v55);
      }
    }

    else
    {
      unint64_t *v52 = v51;
      BOOL v54 = v52 + 1;
    }

    *(void *)(a1 + 160) = v54;
    unint64_t v64 = *(void *)(*(void *)a1 + 104LL) + (unint64_t)(*(double *)(a3 + 32) * 1000.0);
    uint64_t v65 = *(unint64_t **)(a1 + 184);
    unint64_t v66 = *(void *)(a1 + 192);
    if ((unint64_t)v65 < v66)
    {
      *uint64_t v65 = v64;
      unint64_t v67 = v65 + 1;
LABEL_121:
      *(void *)(a1 + 184) = v67;
      return;
    }

    uint64_t v68 = *(unint64_t **)(a1 + 176);
    uint64_t v69 = v65 - v68;
    if (!((unint64_t)(v69 + 1) >> 61))
    {
      unint64_t v70 = v66 - (void)v68;
      unint64_t v71 = (uint64_t)(v66 - (void)v68) >> 2;
      if (v71 <= v69 + 1) {
        unint64_t v71 = v69 + 1;
      }
      if (v70 >= 0x7FFFFFFFFFFFFFF8LL) {
        unint64_t v72 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v72 = v71;
      }
      if (v72)
      {
        unsigned int v73 = (char *)sub_100018788(a1 + 192, v72);
        uint64_t v68 = *(unint64_t **)(a1 + 176);
        uint64_t v65 = *(unint64_t **)(a1 + 184);
      }

      else
      {
        unsigned int v73 = 0LL;
      }

      uint64_t v74 = (unint64_t *)&v73[8 * v69];
      uint64_t v75 = &v73[8 * v72];
      *uint64_t v74 = v64;
      unint64_t v67 = v74 + 1;
      while (v65 != v68)
      {
        unint64_t v76 = *--v65;
        *--uint64_t v74 = v76;
      }

      *(void *)(a1 + 176) = v74;
      *(void *)(a1 + 184) = v67;
      *(void *)(a1 + 192) = v75;
      if (v68) {
        operator delete(v68);
      }
      goto LABEL_121;
    }

LABEL_123:
    sub_100018774();
  }

  double v43 = (os_log_s *)RXOSLog();
  if (os_log_type_enabled(v43, OS_LOG_TYPE_ERROR))
  {
    LOWORD(__p[0]) = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v43,  OS_LOG_TYPE_ERROR,  "TokenPtr is NULL for adlib mode!",  (uint8_t *)__p,  2u);
  }

void sub_1000166DC( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
}

void RDQSRResultModelBuilder::ProcessCurrentAdlib(RDQSRResultModelBuilder *this)
{
  unint64_t v3 = (void **)((char *)this + 128);
  unint64_t v2 = (char *)*((void *)this + 16);
  memset(&v26, 0, sizeof(v26));
  int v4 = *((char *)this + 151);
  if (v4 >= 0) {
    size_t v5 = (char *)this + 128;
  }
  else {
    size_t v5 = v2;
  }
  if (v4 >= 0) {
    uint64_t v6 = *((unsigned __int8 *)this + 151);
  }
  else {
    uint64_t v6 = *((void *)this + 17);
  }
  sub_100022A90(&v26, (uint64_t)v5, (uint64_t)&v5[v6], (uint64_t)v24, "", 0);
  *(_OWORD *)unint64_t v3 = *(_OWORD *)&v26.__r_.__value_.__l.__data_;
  *((void *)this + 1_Block_object_dispose(va, 8) = v26.__r_.__value_.__l.__cap_;
  v26.__r_.__value_.__s.__size_ = 0;
  v26.__r_.__value_.__s.__data_[0] = 0;
  uint64_t v7 = v25;
  if (v25)
  {
    p_shared_owners = (unint64_t *)&v25->__shared_owners_;
    do
      unint64_t v9 = __ldaxr(p_shared_owners);
    while (__stlxr(v9 - 1, p_shared_owners));
    if (!v9)
    {
      ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
      std::__shared_weak_count::__release_weak(v7);
    }
  }

  std::locale::~locale((std::locale *)v24);
  *((_BYTE *)this + 56) = 0;
  uint64_t v10 = *((void *)this + 23);
  if (*((void *)this + 22) != v10)
  {
    unint64_t v11 = *((void *)this + 21);
    __int16 v12 = (char *)*((void *)this + 20);
    if ((unint64_t)v12 >= v11)
    {
      uint64_t v14 = (char *)*((void *)this + 19);
      uint64_t v15 = (v12 - v14) >> 3;
      unint64_t v16 = v11 - (void)v14;
      unint64_t v17 = (uint64_t)(v11 - (void)v14) >> 2;
      if (v17 <= v15 + 1) {
        unint64_t v17 = v15 + 1;
      }
      if (v16 >= 0x7FFFFFFFFFFFFFF8LL) {
        unint64_t v18 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v18 = v17;
      }
      if (v18)
      {
        unint64_t v19 = (char *)sub_100018788((uint64_t)this + 168, v18);
        uint64_t v14 = (char *)*((void *)this + 19);
        __int16 v12 = (char *)*((void *)this + 20);
      }

      else
      {
        unint64_t v19 = 0LL;
      }

      uint64_t v20 = &v19[8 * v15];
      xpc_object_t v21 = &v19[8 * v18];
      *(void *)uint64_t v20 = *(void *)(v10 - 8);
      unsigned int v13 = v20 + 8;
      while (v12 != v14)
      {
        uint64_t v22 = *((void *)v12 - 1);
        v12 -= 8;
        *((void *)v20 - 1) = v22;
        v20 -= 8;
      }

      *((void *)this + 19) = v20;
      *((void *)this + 2sub_10001AFB0((std::locale *)v24, " +$", 0) = v13;
      *((void *)this + 21) = v21;
      if (v14) {
        operator delete(v14);
      }
    }

    else
    {
      *(void *)__int16 v12 = *(void *)(v10 - 8);
      unsigned int v13 = v12 + 8;
    }

    *((void *)this + 2sub_10001AFB0((std::locale *)v24, " +$", 0) = v13;
    xpc_dictionary_set_uint64( *(xpc_object_t *)(*((void *)this + 11) - 16LL),  kRDKeyEndTime,  *(void *)(*((void *)this + 23) - 8LL));
  }

  memset(v24, 0, 24);
  if (*((_DWORD *)this + 13) <= 1u)
  {
    std::string::assign((std::string *)((char *)this + 128), "");
    RDQSRResultModelBuilder::spellTokenSausageVecFromNBestListForCurrentAdlib( (uint64_t)this,  (std::string *)((char *)this + 128),  (uint64_t *)&v26);
    sub_1000254F8((void ***)v24);
    v24[0] = v26;
    memset(&v26, 0, sizeof(v26));
    unint64_t v27 = &v26;
    sub_100018608((void ***)&v27);
  }

  if (*(int *)(*(void *)this + 112LL) < 2 || *((_DWORD *)this + 12) == 1)
  {
    xpc_dictionary_set_string(*(xpc_object_t *)(*((void *)this + 11) - 16LL), kRDKeyText, (const char *)v3);
  }

  else
  {
    if (*((_DWORD *)this + 13) > 1u)
    {
      RDQSRResultModelBuilder::tokenSausageVecFromNBestListForCurrentAdlib(this, (uint64_t *)&v26);
      xpc_object_t v23 = RDQSRResultModelBuilder::xpcObjectFromTokenSausageVec(this, (uint64_t *)&v26);
      unint64_t v27 = &v26;
      sub_100018608((void ***)&v27);
      if (!v23) {
        goto LABEL_39;
      }
    }

    else
    {
      xpc_object_t v23 = RDQSRResultModelBuilder::xpcObjectFromTokenSausageVec(this, (uint64_t *)v24);
      if (!v23) {
        goto LABEL_39;
      }
    }

    xpc_dictionary_set_string(*(xpc_object_t *)(*((void *)this + 11) - 16LL), kRDKeyText, (const char *)v3);
    xpc_dictionary_set_value(*(xpc_object_t *)(*((void *)this + 11) - 16LL), kRDKeyTextVariants, v23);
    xpc_release(v23);
  }

LABEL_39:
  v26.__r_.__value_.__r.__words[0] = (std::string::size_type)v24;
  sub_100018608((void ***)&v26);
}

  ++*(void *)(a1 + 24);
  return v11;
}

  ++*(void *)(a1 + 24);
  return i;
}

  ++*(void *)(a1 + 24);
  return i;
}

  ++*(void *)(a1 + 24);
  return i;
}

  __break(1u);
  return result;
}

  ++*(void *)(a1 + 24);
  return v10;
}

  ++*(void *)(a1 + 24);
  return v10;
}

  ++*(void *)(a1 + 24);
  return v11;
}

  ++*(void *)(a1 + 40);
  return i;
}

  ++*(void *)(a1 + 24);
  return v10;
}

    if (*((void *)&v30 + 1)) {
      --**((_DWORD **)&v30 + 1);
    }
LABEL_41:
    if (v32) {
      (*(void (**)(uint64_t))(*(void *)v32 + 32LL))(v32);
    }
    else {
      ++v34;
    }
  }

  if (v32) {
    return (*(uint64_t (**)(void))(*(void *)v32 + 8LL))();
  }
  return result;
}

      if ((void)v42) {
        (*(void (**)(void))(*(void *)v42 + 32LL))(v42);
      }
      else {
        ++v44;
      }
    }

    if ((void)v42)
    {
      (*(void (**)(void))(*(void *)v42 + 8LL))();
      goto LABEL_50;
    }

  ++*(void *)(a1 + 40);
  return i;
}

void sub_100016A48( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t *__p, uint64_t a18, int a19, __int16 a20, char a21, char a22)
{
  *(void *)(v23 - 4sub_10001AFB0((std::locale *)v24, " +$", 0) = v22;
  sub_100018608((void ***)(v23 - 40));
  __p = &a9;
  sub_100018608((void ***)&__p);
  _Unwind_Resume(a1);
}

uint64_t RDQSRResultModelBuilder::PushAncestors(RDQSRResultModelBuilder *this, uint64_t a2)
{
  int v4 = (int *)*((void *)this + 10);
  size_t v5 = (uint64_t *)((char *)this + 80);
  uint64_t v6 = *((void *)this + 11) - (void)v4;
  if (v6)
  {
    unint64_t v7 = 0LL;
    unint64_t v8 = v6 / 24;
    if (v8 <= 1) {
      unint64_t v8 = 1LL;
    }
    while (1)
    {
      int v9 = *v4;
      v4 += 6;
      ++v7;
      if (v9 == (_DWORD)a2) {
        break;
      }
      if (v8 == v7) {
        goto LABEL_6;
      }
    }

    RDQSRResultModelBuilder::PropagateTimestamps(this, v7);
    return sub_100016C94(v5, v7);
  }

  else
  {
LABEL_6:
    RDQSRResultModelBuilder::PushAncestors(this, *(_DWORD *)(**((void **)this + 8) + 48LL * a2 + 8));
    return RDQSRResultModelBuilder::AddResultNode(this, a2, 0LL);
  }

void RDQSRResultModelBuilder::PropagateTimestamps(RDQSRResultModelBuilder *this, unint64_t a2)
{
  unint64_t v2 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*((void *)this + 11) - *((void *)this + 10)) >> 3);
  if (v2 > a2)
  {
    uint64_t v5 = 8 * ((uint64_t)(*((void *)this + 11) - *((void *)this + 10)) >> 3);
    do
    {
      uint64_t v6 = *((void *)this + 10) + v5;
      unint64_t v7 = *(void **)(v6 - 8);
      if (v7)
      {
        size_t count = xpc_array_get_count(*(xpc_object_t *)(v6 - 8));
        if (count)
        {
          size_t v9 = count;
          uint64_t v10 = *(void **)(*((void *)this + 10) + v5 - 16);
          if (!xpc_dictionary_get_uint64(v10, kRDKeyStartTime))
          {
            unint64_t v11 = kRDKeyStartTime;
            xpc_object_t value = xpc_array_get_value(v7, 0LL);
            uint64_t int64 = xpc_dictionary_get_uint64(value, kRDKeyStartTime);
            xpc_dictionary_set_uint64(v10, v11, uint64);
          }

          if (!xpc_dictionary_get_uint64(v10, kRDKeyEndTime))
          {
            uint64_t v14 = kRDKeyEndTime;
            xpc_object_t v15 = xpc_array_get_value(v7, v9 - 1);
            uint64_t v16 = xpc_dictionary_get_uint64(v15, kRDKeyEndTime);
            xpc_dictionary_set_uint64(v10, v14, v16);
          }
        }
      }

      --v2;
      v5 -= 24LL;
    }

    while (v2 > a2);
  }

uint64_t sub_100016C94(uint64_t *a1, unint64_t a2)
{
  uint64_t result = a1[1];
  unint64_t v4 = 0xAAAAAAAAAAAAAAABLL * ((result - *a1) >> 3);
  BOOL v5 = a2 >= v4;
  unint64_t v6 = a2 - v4;
  if (v6 != 0 && v5) {
    return sub_10001AD30(a1, v6);
  }
  if (!v5)
  {
    uint64_t v7 = *a1 + 24 * a2;
    while (result != v7)
      uint64_t result = sub_10001AB5C(result - 24);
    a1[1] = v7;
  }

  return result;
}

xpc_object_t RDQSRResultModelBuilder::xpcObjectFromTokenSausageVec(_DWORD *a1, uint64_t *a2)
{
  if (*a2 == a2[1]) {
    return 0LL;
  }
  xpc_object_t result = xpc_array_create(0LL, 0LL);
  uint64_t v5 = *a2;
  if (a2[1] != *a2)
  {
    xpc_object_t v29 = result;
    uint64_t v6 = 0LL;
    unint64_t v28 = a2;
    do
    {
      v37[0] = 0LL;
      v37[1] = 0LL;
      unint64_t v36 = v37;
      xpc_object_t v7 = xpc_dictionary_create(0LL, 0LL, 0LL);
      xpc_object_t xarray = xpc_array_create(0LL, 0LL);
      uint64_t v30 = v6;
      size_t v31 = v7;
      unint64_t v8 = (uint64_t *)(v5 + 24 * v6);
      size_t v9 = v8 + 1;
      uint64_t v10 = *v8;
      if (v8[1] == *v8)
      {
        uint64_t v12 = 0LL;
        unint64_t value = 0LL;
      }

      else
      {
        unint64_t v11 = 0LL;
        unint64_t value = 0LL;
        uint64_t v12 = 0LL;
        do
        {
          sub_10000A2DC(&v35, "");
          unsigned int v13 = (uint64_t *)(v10 + 24 * v11);
          uint64_t v14 = v13 + 1;
          uint64_t v15 = *v13;
          if (v13[1] != *v13)
          {
            unint64_t v16 = 0LL;
            do
            {
              unint64_t v17 = *(__int128 **)(v15 + 8 * v16);
              if (*((char *)v17 + 23) < 0)
              {
                sub_10005AA70(&__p, *(void **)v17, *((void *)v17 + 1));
              }

              else
              {
                __int128 v18 = *v17;
                __p.__r_.__value_.__l.__cap_ = *((void *)v17 + 2);
                *(_OWORD *)&__p.__r_.__value_.__l.__data_ = v18;
              }

              if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
                p_p = &__p;
              }
              else {
                p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
              }
              if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
                std::string::size_type size = __p.__r_.__value_.__s.__size_;
              }
              else {
                std::string::size_type size = __p.__r_.__value_.__l.__size_;
              }
              std::string::append(&v35, (const std::string::value_type *)p_p, size);
              if (*(_BYTE *)(*(void *)(v15 + 8 * v16) + 56LL)
                && (a1[12] || v16 != ((*v14 - *v13) >> 3) - 1)
                && (RXIsLocaleWithNoSpaceInPostITN(*(void *)(*(void *)a1 + 120LL)) & 1) == 0)
              {
                std::string::append(&v35, " ");
              }

              if (!v11)
              {
                if (!v16) {
                  unint64_t value = *(void *)(*(void *)a1 + 104LL)
                }
                        + (unint64_t)(*(double *)(*(void *)v15 + 24LL) * 1000.0);
                if (v16 == -1 - 0x5555555555555555LL * ((*v9 - *v8) >> 3)) {
                  uint64_t v12 = *(void *)(*(void *)a1 + 104LL)
                }
                      + (unint64_t)(*(double *)(*(void *)(v15 + 8 * v16) + 32LL) * 1000.0);
              }

              ++v16;
              uint64_t v15 = *v13;
            }

            while (v16 < (*v14 - *v13) >> 3);
          }

          std::string::size_type v21 = v35.__r_.__value_.__s.__size_;
          if ((v35.__r_.__value_.__s.__size_ & 0x80u) != 0) {
            std::string::size_type v21 = v35.__r_.__value_.__l.__size_;
          }
          if (v21 && v37 == (char **)sub_10001AE70((uint64_t)&v36, (const void **)&v35.__r_.__value_.__l.__data_))
          {
            sub_10009B5D8((uint64_t **)&v36, (const void **)&v35.__r_.__value_.__l.__data_, (uint64_t)&v35);
            if ((v35.__r_.__value_.__s.__size_ & 0x80u) == 0) {
              uint64_t v22 = &v35;
            }
            else {
              uint64_t v22 = (std::string *)v35.__r_.__value_.__r.__words[0];
            }
            xpc_object_t v23 = xpc_string_create((const char *)v22);
            xpc_array_append_value(xarray, v23);
            xpc_release(v23);
            sub_100097F38((const void **)&v35.__r_.__value_.__l.__data_, &__p);
            std::string::size_type v24 = __p.__r_.__value_.__s.__size_;
            unsigned __int8 v25 = __p.__r_.__value_.__s.__size_;
            if ((__p.__r_.__value_.__s.__size_ & 0x80u) != 0) {
              std::string::size_type v24 = __p.__r_.__value_.__l.__size_;
            }
            if (v24)
            {
              sub_10009B5D8((uint64_t **)&v36, (const void **)&__p.__r_.__value_.__l.__data_, (uint64_t)&__p);
              if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
                std::string v26 = &__p;
              }
              else {
                std::string v26 = (std::string *)__p.__r_.__value_.__r.__words[0];
              }
              xpc_object_t v27 = xpc_string_create((const char *)v26);
              xpc_array_append_value(xarray, v27);
              xpc_release(v27);
              unsigned __int8 v25 = __p.__r_.__value_.__s.__size_;
            }

            if ((v25 & 0x80) != 0) {
              operator delete(__p.__r_.__value_.__l.__data_);
            }
          }

          ++v11;
          uint64_t v10 = *v8;
        }

        while (0xAAAAAAAAAAAAAAABLL * ((*v9 - *v8) >> 3) > v11);
      }

      xpc_dictionary_set_value(v31, kRDKeyText, xarray);
      xpc_dictionary_set_uint64(v31, kRDKeyStartTime, value);
      xpc_dictionary_set_uint64(v31, kRDKeyEndTime, v12);
      xpc_release(xarray);
      xpc_array_append_value(v29, v31);
      xpc_release(v31);
      sub_100018678((uint64_t)&v36, v37[0]);
      uint64_t v6 = v30 + 1;
      uint64_t v5 = *v28;
    }

    while (0xAAAAAAAAAAAAAAABLL * ((v28[1] - *v28) >> 3) > v30 + 1);
    return v29;
  }

  return result;
}

void sub_100017134( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, int a19, __int16 a20, char a21, char a22, void *a23, uint64_t a24, int a25, __int16 a26, char a27, char a28, char a29, char *a30)
{
}

void RDQSRResultModelBuilder::tokenSausageVecFromNBestListForCurrentAdlib( RDQSRResultModelBuilder *this@<X0>, uint64_t *a2@<X8>)
{
  *a2 = 0LL;
  a2[1] = 0LL;
  a2[2] = 0LL;
  uint64_t v40 = 0LL;
  uint64_t v41 = 0LL;
  uint64_t v42 = 0LL;
  uint64_t v2 = *((void *)this + 5);
  unint64_t v3 = *(void **)v2;
  unint64_t v36 = *(void **)(v2 + 8);
  if (*(void **)v2 == v36) {
    goto LABEL_55;
  }
  do
  {
    unint64_t v37 = 0LL;
    unint64_t v38 = 0LL;
    unint64_t v39 = 0LL;
    uint64_t v5 = v3[1];
    if (*v3 == v5) {
      goto LABEL_50;
    }
    uint64_t v6 = *v3 + 24LL;
    while (1)
    {
      size_t v7 = strlen("<eps>");
      if (*(char *)(v6 + 23) < 0)
      {
        if (v7 == *(void *)(v6 + 8))
        {
          if (v7 == -1LL) {
LABEL_56:
          }
            sub_10001801C();
          unint64_t v8 = *(char **)v6;
          if (!memcmp(*(const void **)v6, "<eps>", v7))
          {
LABEL_38:
            xpc_object_t v27 = (os_log_s *)RXOSLog();
            if (!os_log_type_enabled(v27, OS_LOG_TYPE_ERROR)) {
              goto LABEL_50;
            }
            LOWORD(__str.__r_.__value_.__l.__data_) = 0;
            unint64_t v28 = v27;
            xpc_object_t v29 = "getAlternativesForAdlibs: <eps> grammar found";
LABEL_42:
            _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_ERROR, v29, (uint8_t *)&__str, 2u);
            goto LABEL_50;
          }
        }

        else
        {
          unint64_t v8 = *(char **)v6;
        }
      }

      else
      {
        if (v7 == *(unsigned __int8 *)(v6 + 23))
        {
          if (v7 == -1LL) {
            goto LABEL_56;
          }
        }

        unint64_t v8 = (char *)v6;
      }

      sub_10000A2DC(&__str, v8);
      uint64_t v9 = std::stoll(&__str, 0LL, 10);
      if (v9 == *((void *)this + 28)) {
        break;
      }
LABEL_36:
      uint64_t v26 = v6 + 24;
      v6 += 48LL;
      if (v26 == v5) {
        goto LABEL_50;
      }
    }

    uint64_t v10 = *((void *)this + 8);
    unint64_t v43 = v9;
    __str.__r_.__value_.__r.__words[0] = (std::string::size_type)&v43;
    if (*(_BYTE *)(**((void **)this + 8)
                  + 48LL * *((unsigned int *)sub_100018114(v10 + 48, &v43, (uint64_t)&unk_1000AB73F, &__str) + 6)) != 13)
    {
      uint64_t v30 = (os_log_s *)RXOSLog();
      if (!os_log_type_enabled(v30, OS_LOG_TYPE_ERROR)) {
        goto LABEL_50;
      }
      LOWORD(__str.__r_.__value_.__l.__data_) = 0;
      unint64_t v28 = v30;
      xpc_object_t v29 = "getAlternativesForAdlibs: Non-adlib found in alternatives";
      goto LABEL_42;
    }

    uint64_t ResultToken = RDQSRResult::GetResultToken(*(void *)this, (const char *)(v6 - 24), *((_DWORD *)this + 12));
    if (ResultToken)
    {
      uint64_t v12 = ResultToken;
      unsigned int v13 = (void **)operator new(0x40uLL);
      uint64_t v14 = v13;
      if (*(char *)(v12 + 23) < 0)
      {
        sub_10005AA70(v13, *(void **)v12, *(void *)(v12 + 8));
      }

      else
      {
        __int128 v15 = *(_OWORD *)v12;
        v13[2] = *(void **)(v12 + 16);
        *(_OWORD *)unsigned int v13 = v15;
      }

      __int128 v16 = *(_OWORD *)(v12 + 24);
      __int128 v17 = *(_OWORD *)(v12 + 40);
      *((_WORD *)v14 + 2_Block_object_dispose(va, 8) = *(_WORD *)(v12 + 56);
      *(_OWORD *)(v14 + 5) = v17;
      *(_OWORD *)(v14 + 3) = v16;
      std::string::size_type v47 = v14;
      __int128 v18 = v38;
      if ((unint64_t)v38 >= v39)
      {
        uint64_t v20 = v38 - v37;
        unint64_t v21 = (uint64_t)(v39 - (void)v37) >> 2;
        if (v21 <= v20 + 1) {
          unint64_t v21 = v20 + 1;
        }
        else {
          unint64_t v22 = v21;
        }
        double v46 = &v39;
        if (v22)
        {
          xpc_object_t v23 = (char *)sub_100018788((uint64_t)&v39, v22);
          uint64_t v14 = v47;
        }

        else
        {
          xpc_object_t v23 = 0LL;
        }

        std::string::size_type v24 = &v23[8 * v20];
        __str.__r_.__value_.__r.__words[0] = (std::string::size_type)v23;
        __str.__r_.__value_.__l.__size_ = (std::string::size_type)v24;
        std::string::size_type v45 = &v23[8 * v22];
        std::string::size_type v47 = 0LL;
        *(void *)std::string::size_type v24 = v14;
        __str.__r_.__value_.__l.__cap_ = (std::string::size_type)(v24 + 8);
        sub_100018700((uint64_t *)&v37, &__str);
        unint64_t v19 = v38;
        sub_1000188CC((uint64_t)&__str);
      }

      else
      {
        std::string::size_type v47 = 0LL;
        void *v38 = v14;
        unint64_t v19 = v18 + 1;
      }

      unint64_t v38 = v19;
      unsigned __int8 v25 = v47;
      std::string::size_type v47 = 0LL;
      if (v25) {
        sub_1000186C8((int)&v47, v25);
      }
      goto LABEL_36;
    }

    uint64_t v31 = (uint64_t)v37;
    if (v38 != v37)
    {
      uint64_t v32 = (void ***)(v38 - 1);
      do
      {
        unint64_t v33 = *v32;
        char *v32 = 0LL;
        if (v33) {
          sub_1000186C8((int)v32, v33);
        }
      }

      while (v32-- != (void ***)v31);
    }

    unint64_t v38 = (void *)v31;
LABEL_50:
    if (v37 != v38) {
      sub_100012888(&v40, (uint64_t)&v37);
    }
    __str.__r_.__value_.__r.__words[0] = (std::string::size_type)&v37;
    sub_100018568((void ***)&__str);
    v3 += 3;
  }

  while (v3 != v36);
  if (v40 != v41) {
    sub_1000129C4(a2, (uint64_t)&v40);
  }
LABEL_55:
  __str.__r_.__value_.__r.__words[0] = (std::string::size_type)&v40;
  sub_100018E1C((void ***)&__str);
}

void sub_1000175D8(_Unwind_Exception *a1)
{
  *(void *)(v1 - 8_Block_object_dispose(va, 8) = v4;
  sub_100018568((void ***)(v1 - 88));
  v4[0] = (void **)v5;
  sub_100018E1C(v4);
  v5[0] = v3;
  sub_100018608(v5);
  _Unwind_Resume(a1);
}

void RDQSRResultModelBuilder::spellTokenSausageVecFromNBestListForCurrentAdlib( uint64_t a1@<X0>, std::string *a2@<X1>, uint64_t *a3@<X8>)
{
  *a3 = 0LL;
  a3[1] = 0LL;
  a3[2] = 0LL;
  uint64_t v58 = 0LL;
  uint64_t v59 = 0LL;
  uint64_t v60 = 0LL;
  unint64_t v3 = *(uint64_t ***)(a1 + 40);
  unint64_t v4 = *v3;
  uint64_t v49 = v3[1];
  if (*v3 != v49)
  {
    char v7 = 0;
    do
    {
      uint64_t v55 = 0LL;
      uint64_t v56 = 0LL;
      unint64_t v57 = 0LL;
      uint64_t v9 = *v4;
      uint64_t v8 = v4[1];
LABEL_4:
      if (v9 != v8)
      {
        do
        {
          uint64_t v10 = (char *)(v9 + 24);
          sub_10000A2DC(&__str, v10);
          uint64_t v11 = std::stoll(&__str, 0LL, 10);
          if (v11 != *(void *)(a1 + 224))
          {
            v9 += 48LL;
            goto LABEL_4;
          }

          uint64_t v12 = *(void *)(a1 + 64);
          __p.__r_.__value_.__r.__words[0] = v11;
          __str.__r_.__value_.__r.__words[0] = (std::string::size_type)&__p;
          if (*(_BYTE *)(**(void **)(a1 + 64)
                        + 48LL
                        * *((unsigned int *)sub_100018114( v12 + 48,  (unint64_t *)&__p,  (uint64_t)&unk_1000AB73F,  &__str)
                          + 6)) != 13)
          {
            std::string::size_type v45 = (os_log_s *)RXOSLog();
            if (os_log_type_enabled(v45, OS_LOG_TYPE_ERROR))
            {
              LOWORD(__str.__r_.__value_.__l.__data_) = 0;
              _os_log_impl( (void *)&_mh_execute_header,  v45,  OS_LOG_TYPE_ERROR,  "getAlternativesForAdlibs: Non-adlib found in alternatives",  (uint8_t *)&__str,  2u);
            }

            break;
          }

          uint64_t ResultToken = RDQSRResult::GetResultToken(*(void *)a1, (const char *)v9, *(_DWORD *)(a1 + 48));
          uint64_t v14 = (const __CFString *)RXLocalizedStringForSpacebar(*(void *)(*(void *)a1 + 120LL));
          sub_100097D98(v14, 0, v53);
          sub_10000A2DC(&__p, "");
          if (!ResultToken)
          {
LABEL_44:
            if ((v7 & 1) == 0)
            {
              if ((char)a2->__r_.__value_.__s.__size_ < 0)
              {
                *a2->__r_.__value_.__l.__data_ = 0;
                a2->__r_.__value_.__l.__size_ = 0LL;
              }

              else
              {
                a2->__r_.__value_.__s.__data_[0] = 0;
                a2->__r_.__value_.__s.__size_ = 0;
              }
            }

            uint64_t v36 = (uint64_t)v55;
            if (v56 != v55)
            {
              unint64_t v37 = (void ***)(v56 - 1);
              do
              {
                unint64_t v38 = *v37;
                *unint64_t v37 = 0LL;
                if (v38) {
                  sub_1000186C8((int)v37, v38);
                }
              }

              while (v37-- != (void ***)v36);
            }

            uint64_t v56 = (void *)v36;
            char v40 = 1;
            goto LABEL_82;
          }

          if (*(char *)(ResultToken + 23) < 0)
          {
            sub_10005AA70(__s1, *(void **)ResultToken, *(void *)(ResultToken + 8));
          }

          else
          {
            __int128 v15 = *(_OWORD *)ResultToken;
            uint64_t v51 = *(void *)(ResultToken + 16);
            *(_OWORD *)std::string __s1 = v15;
          }

          uint64_t v16 = HIBYTE(v51);
          if (v51 >= 0) {
            __int128 v17 = (void *)HIBYTE(v51);
          }
          else {
            __int128 v17 = __s1[1];
          }
          unint64_t v18 = v54;
          if ((v54 & 0x80u) != 0) {
            unint64_t v18 = (unint64_t)v53[1];
          }
          if (v17 == (void *)v18)
          {
            if ((v54 & 0x80u) == 0) {
              unint64_t v19 = v53;
            }
            else {
              unint64_t v19 = (void **)v53[0];
            }
            if (v51 < 0)
            {
              if (!memcmp(__s1[0], v19, (size_t)__s1[1]))
              {
LABEL_33:
                sub_10000A2DC(&__str, " ");
                goto LABEL_35;
              }
            }

            else
            {
              if (!HIBYTE(v51)) {
                goto LABEL_33;
              }
              uint64_t v20 = __s1;
              while (*(unsigned __int8 *)v20 == *(unsigned __int8 *)v19)
              {
                uint64_t v20 = (void **)((char *)v20 + 1);
                unint64_t v19 = (void **)((char *)v19 + 1);
                if (!--v16) {
                  goto LABEL_33;
                }
              }
            }
          }

          if (*(char *)(ResultToken + 23) < 0)
          {
            sub_10005AA70(&__str, *(void **)ResultToken, *(void *)(ResultToken + 8));
          }

          else
          {
            __int128 v21 = *(_OWORD *)ResultToken;
            __str.__r_.__value_.__l.__cap_ = *(void *)(ResultToken + 16);
            *(_OWORD *)&__str.__r_.__value_.__l.__data_ = v21;
          }

LABEL_35:
          std::string __p = __str;
          __str.__r_.__value_.__s.__size_ = 0;
          __str.__r_.__value_.__s.__data_[0] = 0;
          if (SHIBYTE(v51) < 0) {
            operator delete(__s1[0]);
          }
          if ((*(_DWORD *)(a1 + 52) || (sub_100098CFC((uint64_t)&__p) & 1) == 0)
            && !sub_100098D68((uint64_t)&__p))
          {
            goto LABEL_44;
          }

          double v22 = *(double *)(ResultToken + 24);
          double v23 = *(double *)(ResultToken + 32);
          double v25 = *(double *)(ResultToken + 40);
          double v24 = *(double *)(ResultToken + 48);
          uint64_t v26 = (double *)operator new(0x40uLL);
          else {
            std::string __str = __p;
          }
          sub_100099710(v26, (__int128 *)&__str, 0, 0, v22, v23, v25, v24);
          __s1[0] = v26;
          if ((char)__str.__r_.__value_.__s.__size_ < 0)
          {
            operator delete(__str.__r_.__value_.__l.__data_);
            if ((v7 & 1) == 0)
            {
LABEL_52:
              if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
                p_p = &__p;
              }
              else {
                p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
              }
              if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
                std::string::size_type size = __p.__r_.__value_.__s.__size_;
              }
              else {
                std::string::size_type size = __p.__r_.__value_.__l.__size_;
              }
              std::string::append(a2, (const std::string::value_type *)p_p, size);
            }
          }

          else if ((v7 & 1) == 0)
          {
            goto LABEL_52;
          }

          xpc_object_t v29 = v56;
          if ((unint64_t)v56 >= v57)
          {
            uint64_t v32 = v56 - v55;
            unint64_t v33 = (uint64_t)(v57 - (void)v55) >> 2;
            if (v33 <= v32 + 1) {
              unint64_t v33 = v32 + 1;
            }
            else {
              unint64_t v34 = v33;
            }
            unint64_t v63 = &v57;
            if (v34) {
              std::string v35 = (char *)sub_100018788((uint64_t)&v57, v34);
            }
            else {
              std::string v35 = 0LL;
            }
            uint64_t v41 = &v35[8 * v32];
            __str.__r_.__value_.__r.__words[0] = (std::string::size_type)v35;
            __str.__r_.__value_.__l.__size_ = (std::string::size_type)v41;
            unint64_t v62 = &v35[8 * v34];
            uint64_t v42 = __s1[0];
            __s1[0] = 0LL;
            *(void *)uint64_t v41 = v42;
            __str.__r_.__value_.__l.__cap_ = (std::string::size_type)(v41 + 8);
            sub_100018700((uint64_t *)&v55, &__str);
            uint64_t v31 = v56;
            sub_1000188CC((uint64_t)&__str);
          }

          else
          {
            uint64_t v30 = __s1[0];
            __s1[0] = 0LL;
            *uint64_t v56 = v30;
            uint64_t v31 = v29 + 1;
          }

          uint64_t v56 = v31;
          unint64_t v43 = (void **)__s1[0];
          __s1[0] = 0LL;
          if (v43) {
            sub_1000186C8((int)__s1, v43);
          }
          char v40 = 0;
LABEL_82:
          v9 += 48LL;
          if (v9 == v8) {
            char v44 = 1;
          }
          else {
            char v44 = v40;
          }
        }

        while ((v44 & 1) == 0);
      }

      std::string::size_type v46 = a2->__r_.__value_.__s.__size_;
      if ((v46 & 0x80u) != 0LL) {
        std::string::size_type v46 = a2->__r_.__value_.__l.__size_;
      }
      BOOL v47 = v46 != 0;
      if (v55 != v56) {
        sub_100012888(&v58, (uint64_t)&v55);
      }
      v7 |= v47;
      __str.__r_.__value_.__r.__words[0] = (std::string::size_type)&v55;
      sub_100018568((void ***)&__str);
      v4 += 3;
    }

    while (v4 != v49);
    if (v58 != v59) {
      sub_1000129C4(a3, (uint64_t)&v58);
    }
  }

  __str.__r_.__value_.__r.__words[0] = (std::string::size_type)&v58;
  sub_100018E1C((void ***)&__str);
}

  swift_release(v7);
  uint64_t v2 = v37;
  uint64_t v36 = 1LL << *(_BYTE *)(v7 + 32);
  if (v36 > 63) {
    bzero(v39, ((unint64_t)(v36 + 63) >> 3) & 0x1FFFFFFFFFFFFFF8LL);
  }
  else {
    char *v39 = -1LL << v36;
  }
  *(void *)(v7 + 16) = 0LL;
LABEL_39:
  xpc_object_t result = swift_release(v7);
  char *v2 = v9;
  return result;
}

      sub_100067BD4(*(void *)(a3 + 8));
    }
  }

  return result;
}

      if (a4)
      {
        if ((v8 & 1) != 0) {
          sub_10002A6A4(&std::cout, (uint64_t)"\n", 1LL);
        }
        double v22 = sub_10002A6A4(&std::cout, (uint64_t)"Flags from: ", 12LL);
        double v23 = *((char *)v5 + 55);
        if (v23 >= 0) {
          double v24 = (uint64_t)(v5 + 4);
        }
        else {
          double v24 = v5[4];
        }
        if (v23 >= 0) {
          double v25 = *((unsigned __int8 *)v5 + 55);
        }
        else {
          double v25 = v5[5];
        }
        uint64_t v26 = sub_10002A6A4(v22, v24, v25);
        uint64_t v8 = 1;
        sub_10002A6A4(v26, (uint64_t)"\n", 1LL);
      }

      std::string::operator=(&v35, (const std::string *)(v5 + 4));
    }

void sub_100017C30( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, void *__p, uint64_t a21, int a22, __int16 a23, char a24, char a25, void *a26, uint64_t a27, int a28, __int16 a29, char a30, char a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, void *a38, uint64_t a39, int a40, __int16 a41, char a42, char a43)
{
  std::string::size_type v45 = v46;
  sub_100018568((void ***)&v45);
  v46[0] = (void **)v47;
  sub_100018E1C(v46);
  v47[0] = v44;
  sub_100018608(v47);
  _Unwind_Resume(a1);
}

void RDQSRResultModelBuilder::~RDQSRResultModelBuilder(RDQSRResultModelBuilder *this)
{
  uint64_t v2 = (void *)*((void *)this + 9);
  if (v2) {
    xpc_release(v2);
  }
  sub_100018678((uint64_t)this + 200, *((char **)this + 26));
  unint64_t v3 = (void *)*((void *)this + 22);
  if (v3)
  {
    *((void *)this + 23) = v3;
    operator delete(v3);
  }

  unint64_t v4 = (void *)*((void *)this + 19);
  if (v4)
  {
    *((void *)this + 2sub_10001AFB0((std::locale *)v24, " +$", 0) = v4;
    operator delete(v4);
  }

  uint64_t v5 = (void **)((char *)this + 80);
  sub_10001AAEC(&v5);
  sub_10001AAC0((RDQSRResultLMNodeBuilder **)this + 8, 0LL);
}

uint64_t RDQSRResultMatcher::Create@<X0>( uint64_t a1@<X0>, const __CFArray *a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, int a5@<W4>, uint64_t a6@<X5>, uint64_t a7@<X6>, unsigned __int8 a8@<W7>, void *a9@<X8>)
{
  unint64_t v18 = operator new(0x80uLL);
  uint64_t result = RDQSRResult::RDQSRResult((uint64_t)v18, a1, a2, a3, a4, a5, a6, a7, a8);
  *a9 = v18;
  return result;
}

void sub_100017E68(_Unwind_Exception *a1)
{
}

uint64_t RDQSRResultMatcher::Create@<X0>( uint64_t a1@<X0>, const __CFString *a2@<X1>, int a3@<W2>, uint64_t a4@<X3>, CFLocaleRef *a5@<X4>, void *a6@<X8>)
{
  uint64_t v12 = operator new(0x80uLL);
  uint64_t result = RDQSRResult::RDQSRResult((uint64_t)v12, a1, a2, a3, a4, a5);
  *a6 = v12;
  return result;
}

void sub_100017EEC(_Unwind_Exception *a1)
{
}

void sub_100017F08()
{
  exception = (std::bad_array_new_length *)__cxa_allocate_exception(8uLL);
  uint64_t v1 = std::bad_array_new_length::bad_array_new_length(exception);
}

char *sub_100017F30(char *__dst, __int128 *a2, __int128 *a3)
{
  if (*((char *)a2 + 23) < 0)
  {
    sub_10005AA70(__dst, *(void **)a2, *((void *)a2 + 1));
  }

  else
  {
    __int128 v5 = *a2;
    *((void *)__dst + 2) = *((void *)a2 + 2);
    *(_OWORD *)std::string __dst = v5;
  }

  uint64_t v6 = __dst + 24;
  if (*((char *)a3 + 23) < 0)
  {
    sub_10005AA70(v6, *(void **)a3, *((void *)a3 + 1));
  }

  else
  {
    __int128 v7 = *a3;
    *((void *)__dst + 5) = *((void *)a3 + 2);
    *(_OWORD *)uint64_t v6 = v7;
  }

  return __dst;
}

void sub_100017FA8(_Unwind_Exception *exception_object)
{
}

uint64_t sub_100017FC4(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 8);
  if (v2)
  {
    p_shared_owners = (unint64_t *)&v2->__shared_owners_;
    do
      unint64_t v4 = __ldaxr(p_shared_owners);
    while (__stlxr(v4 - 1, p_shared_owners));
    if (!v4)
    {
      ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
      std::__shared_weak_count::__release_weak(v2);
    }
  }

  return a1;
}

void sub_10001801C()
{
}

void sub_100018030(const char *a1)
{
  exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
  sub_100018080(exception, a1);
}

void sub_10001806C(_Unwind_Exception *a1)
{
}

std::logic_error *sub_100018080(std::logic_error *a1, const char *a2)
{
  uint64_t result = std::logic_error::logic_error(a1, a2);
  return result;
}

void sub_1000180A4(void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = (void **)**a1;
  if (v2)
  {
    unint64_t v4 = (void **)v1[1];
    __int128 v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        v4 -= 3;
        uint64_t v6 = v4;
        sub_10001A214(&v6);
      }

      while (v4 != v2);
      __int128 v5 = **a1;
    }

    v1[1] = v2;
    operator delete(v5);
  }

void *sub_100018114(uint64_t a1, unint64_t *a2, uint64_t a3, void **a4)
{
  unint64_t v7 = *a2;
  unint64_t v8 = *(void *)(a1 + 8);
  if (v8)
  {
    uint8x8_t v9 = (uint8x8_t)vcnt_s8((int8x8_t)v8);
    v9.i16[0] = vaddlv_u8(v9);
    if (v9.u32[0] > 1uLL)
    {
      unint64_t v4 = *a2;
      if (v7 >= v8) {
        unint64_t v4 = v7 % v8;
      }
    }

    else
    {
      unint64_t v4 = (v8 - 1) & v7;
    }

    uint64_t v10 = *(void ***)(*(void *)a1 + 8 * v4);
    if (v10)
    {
      uint64_t v11 = *v10;
      if (*v10)
      {
        do
        {
          unint64_t v12 = v11[1];
          if (v12 == v7)
          {
            if (v11[2] == v7) {
              return v11;
            }
          }

          else
          {
            if (v9.u32[0] > 1uLL)
            {
              if (v12 >= v8) {
                v12 %= v8;
              }
            }

            else
            {
              v12 &= v8 - 1;
            }

            if (v12 != v4) {
              break;
            }
          }

          uint64_t v11 = (void *)*v11;
        }

        while (v11);
      }
    }
  }

  uint64_t v11 = operator new(0x20uLL);
  *uint64_t v11 = 0LL;
  v11[1] = v7;
  v11[2] = **a4;
  *((_DWORD *)v11 + 6) = 0;
  float v13 = (float)(unint64_t)(*(void *)(a1 + 24) + 1LL);
  float v14 = *(float *)(a1 + 32);
  if (!v8 || (float)(v14 * (float)v8) < v13)
  {
    BOOL v15 = 1LL;
    if (v8 >= 3) {
      BOOL v15 = (v8 & (v8 - 1)) != 0;
    }
    unint64_t v16 = v15 | (2 * v8);
    unint64_t v17 = vcvtps_u32_f32(v13 / v14);
    if (v16 <= v17) {
      size_t v18 = v17;
    }
    else {
      size_t v18 = v16;
    }
    sub_100018334(a1, v18);
    unint64_t v8 = *(void *)(a1 + 8);
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v7 >= v8) {
        unint64_t v4 = v7 % v8;
      }
      else {
        unint64_t v4 = v7;
      }
    }

    else
    {
      unint64_t v4 = (v8 - 1) & v7;
    }
  }

  uint64_t v19 = *(void *)a1;
  uint64_t v20 = *(void **)(*(void *)a1 + 8 * v4);
  if (v20)
  {
    *uint64_t v11 = *v20;
LABEL_38:
    *uint64_t v20 = v11;
    goto LABEL_39;
  }

  *uint64_t v11 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = v11;
  *(void *)(v19 + 8 * v4) = a1 + 16;
  if (*v11)
  {
    unint64_t v21 = *(void *)(*v11 + 8LL);
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v21 >= v8) {
        v21 %= v8;
      }
    }

    else
    {
      v21 &= v8 - 1;
    }

    uint64_t v20 = (void *)(*(void *)a1 + 8 * v21);
    goto LABEL_38;
  }

void sub_100018320(_Unwind_Exception *a1)
{
}

void sub_100018334(uint64_t a1, size_t __n)
{
  if (__n == 1)
  {
    size_t prime = 2LL;
  }

  else
  {
    size_t prime = __n;
    if ((__n & (__n - 1)) != 0) {
      size_t prime = std::__next_prime(__n);
    }
  }

  int8x8_t v4 = *(int8x8_t *)(a1 + 8);
  if (prime > *(void *)&v4) {
    goto LABEL_16;
  }
  if (prime < *(void *)&v4)
  {
    unint64_t v5 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 32));
    if (*(void *)&v4 < 3uLL || (uint8x8_t v6 = (uint8x8_t)vcnt_s8(v4), v6.i16[0] = vaddlv_u8(v6), v6.u32[0] > 1uLL))
    {
      unint64_t v5 = std::__next_prime(v5);
    }

    else
    {
      uint64_t v7 = 1LL << -(char)__clz(v5 - 1);
      if (v5 >= 2) {
        unint64_t v5 = v7;
      }
    }

    if (prime <= v5) {
      size_t prime = v5;
    }
    if (prime < *(void *)&v4) {
LABEL_16:
    }
      sub_100018410(a1, prime);
  }

void sub_100018410(uint64_t a1, unint64_t a2)
{
  if (a2)
  {
    if (a2 >> 61) {
      sub_100017F08();
    }
    int8x8_t v4 = operator new(8 * a2);
    unint64_t v5 = *(void **)a1;
    *(void *)a1 = v4;
    if (v5) {
      operator delete(v5);
    }
    uint64_t v6 = 0LL;
    *(void *)(a1 + _Block_object_dispose(va, 8) = a2;
    do
      *(void *)(*(void *)a1 + 8 * v6++) = 0LL;
    while (a2 != v6);
    uint64_t v7 = *(void **)(a1 + 16);
    if (v7)
    {
      unint64_t v8 = v7[1];
      uint8x8_t v9 = (uint8x8_t)vcnt_s8((int8x8_t)a2);
      v9.i16[0] = vaddlv_u8(v9);
      if (v9.u32[0] > 1uLL)
      {
        if (v8 >= a2) {
          v8 %= a2;
        }
      }

      else
      {
        v8 &= a2 - 1;
      }

      *(void *)(*(void *)a1 + 8 * v_Block_object_dispose(va, 8) = a1 + 16;
      uint64_t v11 = (void *)*v7;
      if (*v7)
      {
        do
        {
          unint64_t v12 = v11[1];
          if (v9.u32[0] > 1uLL)
          {
            if (v12 >= a2) {
              v12 %= a2;
            }
          }

          else
          {
            v12 &= a2 - 1;
          }

          if (v12 != v8)
          {
            if (!*(void *)(*(void *)a1 + 8 * v12))
            {
              *(void *)(*(void *)a1 + 8 * v12) = v7;
              goto LABEL_24;
            }

            *uint64_t v7 = *v11;
            *uint64_t v11 = **(void **)(*(void *)a1 + 8 * v12);
            **(void **)(*(void *)a1 + 8 * v12) = v11;
            uint64_t v11 = v7;
          }

          unint64_t v12 = v8;
LABEL_24:
          uint64_t v7 = v11;
          uint64_t v11 = (void *)*v11;
          unint64_t v8 = v12;
        }

        while (v11);
      }
    }
  }

  else
  {
    uint64_t v10 = *(void **)a1;
    *(void *)a1 = 0LL;
    if (v10) {
      operator delete(v10);
    }
    *(void *)(a1 + _Block_object_dispose(va, 8) = 0LL;
  }

void sub_100018568(void ***a1)
{
  uint64_t v2 = *a1;
  if (*v2)
  {
    sub_1000185A8((uint64_t)v2, (void ***)*v2);
    operator delete(**a1);
  }

void sub_1000185A8(uint64_t a1, void ***a2)
{
  int8x8_t v4 = *(void ****)(a1 + 8);
  if (v4 != a2)
  {
    unint64_t v5 = v4 - 1;
    do
    {
      uint64_t v6 = *v5;
      void *v5 = 0LL;
      if (v6) {
        sub_1000186C8((int)v5, v6);
      }
    }

    while (v5-- != a2);
  }

  *(void *)(a1 + _Block_object_dispose(va, 8) = a2;
}

void sub_100018608(void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = (void **)**a1;
  if (v2)
  {
    int8x8_t v4 = (void **)v1[1];
    unint64_t v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        v4 -= 3;
        uint64_t v6 = v4;
        sub_100018E1C(&v6);
      }

      while (v4 != v2);
      unint64_t v5 = **a1;
    }

    v1[1] = v2;
    operator delete(v5);
  }

void sub_100018678(uint64_t a1, char *a2)
{
  if (a2)
  {
    sub_100018678(a1, *(void *)a2);
    sub_100018678(a1, *((void *)a2 + 1));
    if (a2[55] < 0) {
      operator delete(*((void **)a2 + 4));
    }
    operator delete(a2);
  }

void sub_1000186C8(int a1, void **__p)
{
  if (__p)
  {
    operator delete(__p);
  }

uint64_t sub_100018700(uint64_t *a1, void *a2)
{
  uint64_t result = sub_1000187BC((uint64_t)(a1 + 2), a1[1], (void *)a1[1], *a1, (void *)*a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

void sub_100018774()
{
}

void *sub_100018788(uint64_t a1, unint64_t a2)
{
  if (a2 >> 61) {
    sub_100017F08();
  }
  return operator new(8 * a2);
}

uint64_t sub_1000187BC(uint64_t a1, uint64_t a2, void *a3, uint64_t a4, void *a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7 = a7;
  *(void *)&__int128 v16 = a6;
  *((void *)&v16 + 1) = a7;
  __int128 v15 = v16;
  v13[0] = a1;
  v13[1] = &v15;
  v13[2] = &v16;
  if (a3 == a5)
  {
    uint64_t v11 = a6;
  }

  else
  {
    uint64_t v8 = (void *)(a7 - 8);
    uint8x8_t v9 = (void *)(a7 - 8);
    do
    {
      uint64_t v10 = *--a3;
      *a3 = 0LL;
      *v9-- = v10;
      *((void *)&v16 + 1) = v8;
      v7 -= 8LL;
      uint64_t v8 = v9;
    }

    while (a3 != a5);
    uint64_t v11 = v16;
  }

  char v14 = 1;
  sub_100018850((uint64_t)v13);
  return v11;
}

uint64_t sub_100018850(uint64_t a1)
{
  if (!*(_BYTE *)(a1 + 24)) {
    sub_100018884(a1);
  }
  return a1;
}

void sub_100018884(uint64_t a1)
{
  uint64_t v1 = *(void ****)(*(void *)(a1 + 16) + 8LL);
  uint64_t v2 = *(void ****)(*(void *)(a1 + 8) + 8LL);
  while (v1 != v2)
  {
    unint64_t v3 = *v1;
    void *v1 = 0LL;
    if (v3) {
      sub_1000186C8((int)v1, v3);
    }
    ++v1;
  }

uint64_t sub_1000188CC(uint64_t a1)
{
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void sub_100018900(uint64_t a1, uint64_t a2)
{
  for (uint64_t i = *(void *)(a1 + 16); i != a2; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 8;
    uint64_t v5 = *(void ***)(i - 8);
    *(void *)(i - _Block_object_dispose(va, 8) = 0LL;
    if (v5) {
      sub_1000186C8(i - 8, v5);
    }
  }

void *sub_100018958(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &off_1000CE288;
  result[1] = v3;
  return result;
}

uint64_t sub_10001898C(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &off_1000CE288;
  a2[1] = v2;
  return result;
}

uint64_t sub_1000189A8(uint64_t a1, __int128 **a2)
{
  uint64_t v2 = *a2;
  uint64_t v3 = *(uint64_t **)(a1 + 8);
  int8x8_t v4 = (char *)operator new(0x40uLL);
  uint64_t v5 = v4;
  if (*((char *)v2 + 23) < 0)
  {
    sub_10005AA70(v4, *(void **)v2, *((void *)v2 + 1));
  }

  else
  {
    __int128 v6 = *v2;
    *((void *)v4 + 2) = *((void *)v2 + 2);
    *(_OWORD *)int8x8_t v4 = v6;
  }

  uint64_t v7 = v3 + 9;
  __int128 v8 = *(__int128 *)((char *)v2 + 24);
  __int128 v9 = *(__int128 *)((char *)v2 + 40);
  *((_WORD *)v5 + 2_Block_object_dispose(va, 8) = *((_WORD *)v2 + 28);
  *(_OWORD *)(v5 + 4sub_10001AFB0((std::locale *)v24, " +$", 0) = v9;
  *(_OWORD *)(v5 + 24) = v8;
  std::string __p = v5;
  unint64_t v10 = v3[11];
  uint64_t v11 = (void *)v3[10];
  if ((unint64_t)v11 >= v10)
  {
    uint64_t v13 = ((uint64_t)v11 - *v7) >> 3;
    uint64_t v14 = v10 - *v7;
    uint64_t v15 = v14 >> 2;
    else {
      unint64_t v16 = v15;
    }
    v22[4] = v3 + 11;
    if (v16)
    {
      unint64_t v17 = (char *)sub_100018788((uint64_t)(v3 + 11), v16);
      uint64_t v5 = (char *)__p;
    }

    else
    {
      unint64_t v17 = 0LL;
    }

    size_t v18 = &v17[8 * v13];
    v22[0] = v17;
    v22[1] = v18;
    v22[3] = &v17[8 * v16];
    std::string __p = 0LL;
    *(void *)size_t v18 = v5;
    v22[2] = v18 + 8;
    sub_100018700(v3 + 9, v22);
    unint64_t v12 = (void *)v3[10];
    sub_1000188CC((uint64_t)v22);
    uint64_t v19 = (void **)__p;
    v3[10] = (uint64_t)v12;
    std::string __p = 0LL;
    if (v19)
    {
      sub_1000186C8((int)&__p, v19);
      unint64_t v12 = (void *)v3[10];
    }
  }

  else
  {
    *uint64_t v11 = v5;
    unint64_t v12 = v11 + 1;
    v3[10] = (uint64_t)v12;
  }

  return (((unint64_t)v12 - *v7) >> 3) - 1;
}

void sub_100018B08( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, char a10)
{
}

uint64_t sub_100018B48(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0LL;
  }

_UNKNOWN **sub_100018B84()
{
}

BOOL sub_100018B90(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  uint64_t v3 = *(void *)(a2 + 8);
  if (v2 == v3) {
    return 1LL;
  }
  if ((v3 & v2) < 0 != __OFSUB__(v2, v3)) {
    return strcmp((const char *)(v2 & 0x7FFFFFFFFFFFFFFFLL), (const char *)(v3 & 0x7FFFFFFFFFFFFFFFLL)) == 0;
  }
  return 0LL;
}

void *sub_100018BE4(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &off_1000CE318;
  result[1] = v3;
  return result;
}

uint64_t sub_100018C18(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &off_1000CE318;
  a2[1] = v2;
  return result;
}

uint64_t sub_100018C34(uint64_t a1, __int128 **a2)
{
  uint64_t v2 = *a2;
  uint64_t v3 = *(uint64_t **)(a1 + 8);
  int8x8_t v4 = (char *)operator new(0x40uLL);
  uint64_t v5 = v4;
  if (*((char *)v2 + 23) < 0)
  {
    sub_10005AA70(v4, *(void **)v2, *((void *)v2 + 1));
  }

  else
  {
    __int128 v6 = *v2;
    *((void *)v4 + 2) = *((void *)v2 + 2);
    *(_OWORD *)int8x8_t v4 = v6;
  }

  uint64_t v7 = v3 + 9;
  __int128 v8 = *(__int128 *)((char *)v2 + 24);
  __int128 v9 = *(__int128 *)((char *)v2 + 40);
  *((_WORD *)v5 + 2_Block_object_dispose(va, 8) = *((_WORD *)v2 + 28);
  *(_OWORD *)(v5 + 4sub_10001AFB0((std::locale *)v24, " +$", 0) = v9;
  *(_OWORD *)(v5 + 24) = v8;
  std::string __p = v5;
  unint64_t v10 = v3[11];
  uint64_t v11 = (void *)v3[10];
  if ((unint64_t)v11 >= v10)
  {
    uint64_t v13 = ((uint64_t)v11 - *v7) >> 3;
    uint64_t v14 = v10 - *v7;
    uint64_t v15 = v14 >> 2;
    else {
      unint64_t v16 = v15;
    }
    v22[4] = v3 + 11;
    if (v16)
    {
      unint64_t v17 = (char *)sub_100018788((uint64_t)(v3 + 11), v16);
      uint64_t v5 = (char *)__p;
    }

    else
    {
      unint64_t v17 = 0LL;
    }

    size_t v18 = &v17[8 * v13];
    v22[0] = v17;
    v22[1] = v18;
    v22[3] = &v17[8 * v16];
    std::string __p = 0LL;
    *(void *)size_t v18 = v5;
    v22[2] = v18 + 8;
    sub_100018700(v3 + 9, v22);
    unint64_t v12 = (void *)v3[10];
    sub_1000188CC((uint64_t)v22);
    uint64_t v19 = (void **)__p;
    v3[10] = (uint64_t)v12;
    std::string __p = 0LL;
    if (v19)
    {
      sub_1000186C8((int)&__p, v19);
      unint64_t v12 = (void *)v3[10];
    }
  }

  else
  {
    *uint64_t v11 = v5;
    unint64_t v12 = v11 + 1;
    v3[10] = (uint64_t)v12;
  }

  return (((unint64_t)v12 - *v7) >> 3) - 1;
}

void sub_100018D94( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, char a10)
{
}

uint64_t sub_100018DD4(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }

  else
  {
    return 0LL;
  }

_UNKNOWN **sub_100018E10()
{
}

void sub_100018E1C(void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = (void **)**a1;
  if (v2)
  {
    int8x8_t v4 = (void **)v1[1];
    uint64_t v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        v4 -= 3;
        __int128 v6 = v4;
        sub_100018568(&v6);
      }

      while (v4 != v2);
      uint64_t v5 = **a1;
    }

    v1[1] = v2;
    operator delete(v5);
  }

uint64_t sub_100018E8C(uint64_t *a1, void *a2)
{
  uint64_t result = sub_100018F44((uint64_t)(a1 + 2), a1[1], (void *)a1[1], *a1, (void *)*a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

void *sub_100018F00(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0xAAAAAAAAAAAAAABLL) {
    sub_100017F08();
  }
  return operator new(24 * a2);
}

uint64_t sub_100018F44(uint64_t a1, uint64_t a2, void *a3, uint64_t a4, void *a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7 = a7;
  *(void *)&__int128 v14 = a6;
  *((void *)&v14 + 1) = a7;
  __int128 v13 = v14;
  v11[0] = a1;
  v11[1] = &v13;
  v11[2] = &v14;
  if (a3 == a5)
  {
    uint64_t v9 = a6;
  }

  else
  {
    do
    {
      *(void *)(v7 - 24) = 0LL;
      *(void *)(v7 - 16) = 0LL;
      *(void *)(v7 - _Block_object_dispose(va, 8) = 0LL;
      __int128 v8 = *(_OWORD *)(a3 - 3);
      a3 -= 3;
      *(_OWORD *)(v7 - 24) = v8;
      *(void *)(v7 - _Block_object_dispose(va, 8) = a3[2];
      *a3 = 0LL;
      a3[1] = 0LL;
      a3[2] = 0LL;
      uint64_t v7 = *((void *)&v14 + 1) - 24LL;
      *((void *)&v14 + 1) -= 24LL;
    }

    while (a3 != a5);
    uint64_t v9 = v14;
  }

  char v12 = 1;
  sub_100018FE4((uint64_t)v11);
  return v9;
}

uint64_t sub_100018FE4(uint64_t a1)
{
  if (!*(_BYTE *)(a1 + 24)) {
    sub_100019018(a1);
  }
  return a1;
}

void sub_100019018(uint64_t a1)
{
  uint64_t v1 = *(void ***)(*(void *)(a1 + 16) + 8LL);
  uint64_t v2 = *(void ***)(*(void *)(a1 + 8) + 8LL);
  while (v1 != v2)
  {
    uint64_t v3 = v1;
    sub_100018568(&v3);
    v1 += 3;
  }

void **sub_100019060(void **a1)
{
  if (*a1) {
    operator delete(*a1);
  }
  return a1;
}

void sub_100019090(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v2; uint64_t i = *(void *)(a1 + 16))
  {
    int8x8_t v4 = (void **)(i - 24);
    *(void *)(a1 + 16) = v4;
    uint64_t v5 = v4;
    sub_100018568(&v5);
  }

uint64_t sub_1000190E0(uint64_t *a1, void *a2)
{
  uint64_t result = sub_100019154((uint64_t)(a1 + 2), a1[1], (void *)a1[1], *a1, (void *)*a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t sub_100019154(uint64_t a1, uint64_t a2, void *a3, uint64_t a4, void *a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7 = a7;
  *(void *)&__int128 v14 = a6;
  *((void *)&v14 + 1) = a7;
  __int128 v13 = v14;
  v11[0] = a1;
  v11[1] = &v13;
  v11[2] = &v14;
  if (a3 == a5)
  {
    uint64_t v9 = a6;
  }

  else
  {
    do
    {
      *(void *)(v7 - 24) = 0LL;
      *(void *)(v7 - 16) = 0LL;
      *(void *)(v7 - _Block_object_dispose(va, 8) = 0LL;
      __int128 v8 = *(_OWORD *)(a3 - 3);
      a3 -= 3;
      *(_OWORD *)(v7 - 24) = v8;
      *(void *)(v7 - _Block_object_dispose(va, 8) = a3[2];
      *a3 = 0LL;
      a3[1] = 0LL;
      a3[2] = 0LL;
      uint64_t v7 = *((void *)&v14 + 1) - 24LL;
      *((void *)&v14 + 1) -= 24LL;
    }

    while (a3 != a5);
    uint64_t v9 = v14;
  }

  char v12 = 1;
  sub_1000191F4((uint64_t)v11);
  return v9;
}

uint64_t sub_1000191F4(uint64_t a1)
{
  if (!*(_BYTE *)(a1 + 24)) {
    sub_100019228(a1);
  }
  return a1;
}

void sub_100019228(uint64_t a1)
{
  uint64_t v1 = *(void ***)(*(void *)(a1 + 16) + 8LL);
  uint64_t v2 = *(void ***)(*(void *)(a1 + 8) + 8LL);
  while (v1 != v2)
  {
    uint64_t v3 = v1;
    sub_100018E1C(&v3);
    v1 += 3;
  }

void **sub_100019270(void **a1)
{
  if (*a1) {
    operator delete(*a1);
  }
  return a1;
}

void sub_1000192A0(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v2; uint64_t i = *(void *)(a1 + 16))
  {
    int8x8_t v4 = (void **)(i - 24);
    *(void *)(a1 + 16) = v4;
    uint64_t v5 = v4;
    sub_100018E1C(&v5);
  }

uint64_t sub_1000192F0(uint64_t a1)
{
  uint64_t v2 = *(void **)a1;
  *(void *)a1 = 0LL;
  if (v2) {
    operator delete(v2);
  }
  return a1;
}

void sub_100019328(int a1, void *__p)
{
  if (__p)
  {
    uint64_t v2 = __p;
    do
    {
      uint64_t v3 = (void *)*v2;
      uint64_t v4 = v2[3];
      v2[3] = 0LL;
      if (v4) {
        (*(void (**)(uint64_t))(*(void *)v4 + 8LL))(v4);
      }
      operator delete(v2);
      uint64_t v2 = v3;
    }

    while (v3);
  }

__n128 sub_10001937C(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = &off_1000CE398;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + _Block_object_dispose(va, 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 sub_1000193BC(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &off_1000CE398;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + _Block_object_dispose(va, 8) = result;
  return result;
}

void sub_1000193E4(uint64_t a1, unint64_t *a2)
{
  unint64_t v11 = *a2;
  uint64_t v3 = *(void *)(a1 + 24);
  unint64_t v4 = **(void **)(a1 + 8) + 32 * v11;
  if (*(_BYTE *)(v4 + 24)) {
    uint64_t v5 = *(void *)(v3 + 64);
  }
  else {
    uint64_t v5 = *(void *)(v3 + 56);
  }
  uint64_t v6 = RDQSRGrammarBuilder::grammarFST(*(RDQSRGrammarBuilder **)v4);
  sub_10005E72C(v5, v6, 1, &v12);
  uint64_t v7 = v12;
  std::mutex::lock(&stru_1000DD308);
  uint64_t v8 = *(void *)(a1 + 16);
  char v12 = &v11;
  uint64_t v9 = sub_100019528(v8, &v11, (uint64_t)&unk_1000AB73F, &v12);
  uint64_t v10 = v9[3];
  v9[3] = v7;
  if (v10) {
    (*(void (**)(uint64_t))(*(void *)v10 + 8LL))(v10);
  }
  std::mutex::unlock(&stru_1000DD308);
}

void sub_1000194AC(_Unwind_Exception *a1)
{
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8LL))(v1);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_1000194E0(uint64_t a1, uint64_t a2)
{
  else {
    return 0LL;
  }
}

_UNKNOWN **sub_10001951C()
{
}

void *sub_100019528(uint64_t a1, unint64_t *a2, uint64_t a3, void **a4)
{
  unint64_t v7 = *a2;
  unint64_t v8 = *(void *)(a1 + 8);
  if (v8)
  {
    uint8x8_t v9 = (uint8x8_t)vcnt_s8((int8x8_t)v8);
    v9.i16[0] = vaddlv_u8(v9);
    if (v9.u32[0] > 1uLL)
    {
      unint64_t v4 = *a2;
      if (v7 >= v8) {
        unint64_t v4 = v7 % v8;
      }
    }

    else
    {
      unint64_t v4 = (v8 - 1) & v7;
    }

    uint64_t v10 = *(void ***)(*(void *)a1 + 8 * v4);
    if (v10)
    {
      for (uint64_t i = *v10; i; uint64_t i = (void *)*i)
      {
        unint64_t v12 = i[1];
        if (v12 == v7)
        {
          if (i[2] == v7) {
            return i;
          }
        }

        else
        {
          if (v9.u32[0] > 1uLL)
          {
            if (v12 >= v8) {
              v12 %= v8;
            }
          }

          else
          {
            v12 &= v8 - 1;
          }

          if (v12 != v4) {
            break;
          }
        }
      }
    }
  }

  __int128 v13 = (void *)(a1 + 16);
  uint64_t i = operator new(0x20uLL);
  *uint64_t i = 0LL;
  i[1] = v7;
  i[2] = **a4;
  i[3] = 0LL;
  float v14 = (float)(unint64_t)(*(void *)(a1 + 24) + 1LL);
  float v15 = *(float *)(a1 + 32);
  if (!v8 || (float)(v15 * (float)v8) < v14)
  {
    BOOL v16 = 1LL;
    if (v8 >= 3) {
      BOOL v16 = (v8 & (v8 - 1)) != 0;
    }
    unint64_t v17 = v16 | (2 * v8);
    unint64_t v18 = vcvtps_u32_f32(v14 / v15);
    if (v17 <= v18) {
      size_t v19 = v18;
    }
    else {
      size_t v19 = v17;
    }
    sub_100018334(a1, v19);
    unint64_t v8 = *(void *)(a1 + 8);
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v7 >= v8) {
        unint64_t v4 = v7 % v8;
      }
      else {
        unint64_t v4 = v7;
      }
    }

    else
    {
      unint64_t v4 = (v8 - 1) & v7;
    }
  }

  uint64_t v20 = *(void *)a1;
  unint64_t v21 = *(void **)(*(void *)a1 + 8 * v4);
  if (v21)
  {
    *uint64_t i = *v21;
LABEL_38:
    *unint64_t v21 = i;
    goto LABEL_39;
  }

  *uint64_t i = *v13;
  *__int128 v13 = i;
  *(void *)(v20 + 8 * v4) = v13;
  if (*i)
  {
    unint64_t v22 = *(void *)(*i + 8LL);
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v22 >= v8) {
        v22 %= v8;
      }
    }

    else
    {
      v22 &= v8 - 1;
    }

    unint64_t v21 = (void *)(*(void *)a1 + 8 * v22);
    goto LABEL_38;
  }

void sub_100019754( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
}

void sub_100019770(uint64_t a1, void *__p)
{
  if (*(_BYTE *)(a1 + 8))
  {
    uint64_t v3 = __p[3];
    __p[3] = 0LL;
    if (v3) {
      (*(void (**)(uint64_t))(*(void *)v3 + 8LL))(v3);
    }
  }

  else if (!__p)
  {
    return;
  }

  operator delete(__p);
}

void sub_1000197C4(void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = (char *)**a1;
  if (v2)
  {
    unint64_t v4 = (char *)v1[1];
    uint64_t v5 = v2;
    if (v4 != v2)
    {
      do
        RDQSRResultObject::~RDQSRResultObject((RDQSRResultObject *)(v4 - 16));
      while (v4 != v2);
      uint64_t v5 = **a1;
    }

    v1[1] = v2;
    operator delete(v5);
  }

uint64_t sub_100019834(uint64_t *a1, void *a2)
{
  uint64_t result = sub_1000198DC((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

void *sub_1000198A8(uint64_t a1, unint64_t a2)
{
  if (a2 >> 60) {
    sub_100017F08();
  }
  return operator new(16 * a2);
}

uint64_t sub_1000198DC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  if (a3 != a5)
  {
    uint64_t v11 = 0LL;
    do
    {
      uint64_t v12 = a7 + v11;
      *(_DWORD *)(v12 - 16) = *(_DWORD *)(a3 + v11 - 16);
      __int128 v13 = *(void **)(a3 + v11 - 8);
      *(void *)(v12 - _Block_object_dispose(va, 8) = v13;
      if (v13) {
        xpc_retain(v13);
      }
      v11 -= 16LL;
    }

    while (a3 + v11 != a5);
  }

  return a6;
}

void sub_10001995C(_Unwind_Exception *exception_object)
{
  for (; v2; v2 += 16LL)
    RDQSRResultObject::~RDQSRResultObject((RDQSRResultObject *)(v1 + v2));
  _Unwind_Resume(exception_object);
}

uint64_t sub_10001997C(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 16;
    RDQSRResultObject::~RDQSRResultObject((RDQSRResultObject *)(i - 16));
  }

  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void sub_1000199C8(void ***a1)
{
  uint64_t v1 = *a1;
  if (*a1)
  {
    uint64_t v3 = a1[1];
    unint64_t v4 = *a1;
    if (v3 != v1)
    {
      do
      {
        v3 -= 3;
        uint64_t v5 = v3;
        sub_10001A214(&v5);
      }

      while (v3 != v1);
      unint64_t v4 = *a1;
    }

    a1[1] = v1;
    operator delete(v4);
    *a1 = 0LL;
    a1[1] = 0LL;
    a1[2] = 0LL;
  }

void *sub_100019A38(void *result, __int128 **a2, __int128 **a3, unint64_t a4)
{
  if (a4)
  {
    uint64_t v6 = result;
    sub_100019ABC(result, a4);
    uint64_t result = (void *)sub_100019B0C((uint64_t)(v6 + 2), a2, a3, v6[1]);
    v6[1] = result;
  }

  return result;
}

void sub_100019A9C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
  *(void *)(v9 + _Block_object_dispose(va, 8) = v10;
  sub_1000180A4(&a9);
  _Unwind_Resume(a1);
}

char *sub_100019ABC(void *a1, unint64_t a2)
{
  if (a2 >= 0xAAAAAAAAAAAAAABLL) {
    sub_100018774();
  }
  uint64_t result = (char *)sub_100018F00((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[24 * v4];
  return result;
}

uint64_t sub_100019B0C(uint64_t a1, __int128 **a2, __int128 **a3, uint64_t a4)
{
  uint64_t v4 = a4;
  uint64_t v10 = a4;
  uint64_t v11 = a4;
  v8[0] = a1;
  v8[1] = &v10;
  v8[2] = &v11;
  char v9 = 0;
  if (a2 != a3)
  {
    uint64_t v6 = a2;
    do
    {
      *(void *)uint64_t v4 = 0LL;
      *(void *)(v4 + _Block_object_dispose(va, 8) = 0LL;
      *(void *)(v4 + 16) = 0LL;
      sub_100019F00((char *)v4, *v6, v6[1], 0xAAAAAAAAAAAAAAABLL * (v6[1] - *v6));
      uint64_t v4 = v11 + 24;
      v11 += 24LL;
      v6 += 3;
    }

    while (v6 != a3);
  }

  char v9 = 1;
  sub_100019BC8((uint64_t)v8);
  return v4;
}

void sub_100019BB4( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_100019BC8(uint64_t a1)
{
  if (!*(_BYTE *)(a1 + 24)) {
    sub_100019BFC(a1);
  }
  return a1;
}

void sub_100019BFC(uint64_t a1)
{
  uint64_t v1 = **(void ****)(a1 + 16);
  uint64_t v2 = **(void ****)(a1 + 8);
  while (v1 != v2)
  {
    v1 -= 3;
    uint64_t v3 = v1;
    sub_10001A214(&v3);
  }

void sub_100019C44()
{
}

uint64_t *sub_100019C58(uint64_t **a1, unint64_t *a2, uint64_t a3, uint64_t **a4)
{
  uint64_t v7 = a1 + 1;
  uint64_t v6 = a1[1];
  if (v6)
  {
    unint64_t v8 = *a2;
    while (1)
    {
      while (1)
      {
        char v9 = (uint64_t **)v6;
        unint64_t v10 = v6[4];
        if (v8 >= v10) {
          break;
        }
        uint64_t v6 = *v9;
        uint64_t v7 = v9;
        if (!*v9) {
          goto LABEL_10;
        }
      }

      if (v10 >= v8) {
        break;
      }
      uint64_t v6 = v9[1];
      if (!v6)
      {
        uint64_t v7 = v9 + 1;
        goto LABEL_10;
      }
    }
  }

  else
  {
    char v9 = a1 + 1;
LABEL_10:
    uint64_t v11 = (uint64_t *)operator new(0x30uLL);
    v11[4] = **a4;
    v11[5] = 0LL;
    sub_100019D14(a1, (uint64_t)v9, v7, v11);
    return v11;
  }

  return (uint64_t *)v9;
}

uint64_t *sub_100019D14(uint64_t **a1, uint64_t a2, uint64_t **a3, uint64_t *a4)
{
  *a4 = 0LL;
  a4[1] = 0LL;
  a4[2] = a2;
  *a3 = a4;
  uint64_t v5 = (uint64_t *)**a1;
  if (v5)
  {
    *a1 = v5;
    a4 = *a3;
  }

  uint64_t result = sub_100019D68(a1[1], a4);
  a1[2] = (uint64_t *)((char *)a1[2] + 1);
  return result;
}

uint64_t *sub_100019D68(uint64_t *result, uint64_t *a2)
{
  *((_BYTE *)a2 + 24) = a2 == result;
  if (a2 != result)
  {
    do
    {
      uint64_t v2 = (uint64_t *)a2[2];
      if (*((_BYTE *)v2 + 24)) {
        return result;
      }
      uint64_t v3 = (uint64_t *)v2[2];
      uint64_t v4 = (uint64_t *)*v3;
      if ((uint64_t *)*v3 == v2)
      {
        uint64_t v7 = v3[1];
        if (!v7 || (v8 = *(unsigned __int8 *)(v7 + 24), uint64_t v5 = (_BYTE *)(v7 + 24), v8))
        {
          if ((uint64_t *)*v2 == a2)
          {
            char v9 = (uint64_t **)a2[2];
          }

          else
          {
            char v9 = (uint64_t **)v2[1];
            unint64_t v10 = *v9;
            v2[1] = (uint64_t)*v9;
            if (v10)
            {
              v10[2] = (uint64_t)v2;
              uint64_t v3 = (uint64_t *)v2[2];
            }

            v9[2] = v3;
            *(void *)(v2[2] + 8LL * (*(void *)v2[2] != (void)v2)) = v9;
            *char v9 = v2;
            v2[2] = (uint64_t)v9;
            uint64_t v3 = v9[2];
            uint64_t v2 = (uint64_t *)*v3;
          }

          *((_BYTE *)v9 + 24) = 1;
          *((_BYTE *)v3 + 24) = 0;
          uint64_t v13 = v2[1];
          *uint64_t v3 = v13;
          if (v13) {
            *(void *)(v13 + 16) = v3;
          }
          v2[2] = v3[2];
          *(void *)(v3[2] + 8LL * (*(void *)v3[2] != (void)v3)) = v2;
          v2[1] = (uint64_t)v3;
          goto LABEL_27;
        }
      }

      else if (!v4 || (v6 = *((unsigned __int8 *)v4 + 24), uint64_t v5 = v4 + 3, v6))
      {
        if ((uint64_t *)*v2 == a2)
        {
          uint64_t v11 = a2[1];
          uint64_t *v2 = v11;
          if (v11)
          {
            *(void *)(v11 + 16) = v2;
            uint64_t v3 = (uint64_t *)v2[2];
          }

          a2[2] = (uint64_t)v3;
          *(void *)(v2[2] + 8LL * (*(void *)v2[2] != (void)v2)) = a2;
          a2[1] = (uint64_t)v2;
          v2[2] = (uint64_t)a2;
          uint64_t v3 = (uint64_t *)a2[2];
        }

        else
        {
          a2 = (uint64_t *)a2[2];
        }

        *((_BYTE *)a2 + 24) = 1;
        *((_BYTE *)v3 + 24) = 0;
        uint64_t v2 = (uint64_t *)v3[1];
        uint64_t v12 = *v2;
        v3[1] = *v2;
        if (v12) {
          *(void *)(v12 + 16) = v3;
        }
        v2[2] = v3[2];
        *(void *)(v3[2] + 8LL * (*(void *)v3[2] != (void)v3)) = v2;
        uint64_t *v2 = (uint64_t)v3;
LABEL_27:
        _OWORD v3[2] = (uint64_t)v2;
        return result;
      }

      *((_BYTE *)v2 + 24) = 1;
      a2 = v3;
      *((_BYTE *)v3 + 24) = v3 == result;
      _BYTE *v5 = 1;
    }

    while (v3 != result);
  }

  return result;
}

char *sub_100019F00(char *result, __int128 *a2, __int128 *a3, unint64_t a4)
{
  if (a4)
  {
    int v6 = result;
    sub_100019F84(result, a4);
    uint64_t result = sub_10001A018((uint64_t)(v6 + 16), a2, a3, *((char **)v6 + 1));
    *((void *)v6 + 1) = result;
  }

  return result;
}

void sub_100019F64( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
  *(void *)(v9 + _Block_object_dispose(va, 8) = v10;
  sub_10001A214(&a9);
  _Unwind_Resume(a1);
}

char *sub_100019F84(void *a1, unint64_t a2)
{
  if (a2 >= 0x555555555555556LL) {
    sub_100018774();
  }
  uint64_t result = (char *)sub_100019FD4((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[48 * v4];
  return result;
}

void *sub_100019FD4(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x555555555555556LL) {
    sub_100017F08();
  }
  return operator new(48 * a2);
}

char *sub_10001A018(uint64_t a1, __int128 *a2, __int128 *a3, char *__dst)
{
  uint64_t v4 = __dst;
  uint64_t v10 = __dst;
  uint64_t v11 = __dst;
  v8[0] = a1;
  v8[1] = &v10;
  v8[2] = &v11;
  char v9 = 0;
  if (a2 != a3)
  {
    int v6 = a2;
    do
    {
      sub_10001A0B8(v4, v6);
      v6 += 3;
      uint64_t v4 = v11 + 48;
      v11 += 48;
    }

    while (v6 != a3);
  }

  char v9 = 1;
  sub_10001A14C((uint64_t)v8);
  return v4;
}

void sub_10001A0A4( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

char *sub_10001A0B8(char *__dst, __int128 *a2)
{
  if (*((char *)a2 + 23) < 0)
  {
    sub_10005AA70(__dst, *(void **)a2, *((void *)a2 + 1));
  }

  else
  {
    __int128 v4 = *a2;
    *((void *)__dst + 2) = *((void *)a2 + 2);
    *(_OWORD *)std::string __dst = v4;
  }

  uint64_t v5 = __dst + 24;
  if (*((char *)a2 + 47) < 0)
  {
    sub_10005AA70(v5, *((void **)a2 + 3), *((void *)a2 + 4));
  }

  else
  {
    __int128 v6 = *(__int128 *)((char *)a2 + 24);
    *((void *)__dst + 5) = *((void *)a2 + 5);
    *(_OWORD *)uint64_t v5 = v6;
  }

  return __dst;
}

void sub_10001A130(_Unwind_Exception *exception_object)
{
}

uint64_t sub_10001A14C(uint64_t a1)
{
  if (!*(_BYTE *)(a1 + 24)) {
    sub_10001A180((uint64_t *)a1);
  }
  return a1;
}

void sub_10001A180(uint64_t *a1)
{
  uint64_t v2 = (uint64_t *)a1[1];
  uint64_t v1 = (uint64_t *)a1[2];
  uint64_t v3 = *v1;
  uint64_t v4 = *v2;
  if (*v1 != *v2)
  {
    uint64_t v5 = *a1;
    do
    {
      v3 -= 48LL;
      sub_10001A1D0(v5, v3);
    }

    while (v3 != v4);
  }

void sub_10001A1D0(uint64_t a1, uint64_t a2)
{
}

void sub_10001A214(void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = **a1;
  if (v2)
  {
    uint64_t v4 = (uint64_t)v1[1];
    uint64_t v5 = **a1;
    if ((void *)v4 != v2)
    {
      do
      {
        v4 -= 48LL;
        sub_10001A1D0((uint64_t)(v1 + 2), v4);
      }

      while ((void *)v4 != v2);
      uint64_t v5 = **a1;
    }

    v1[1] = v2;
    operator delete(v5);
  }

uint64_t sub_10001A298(uint64_t *a1, void *a2)
{
  uint64_t result = sub_10001A30C((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t sub_10001A30C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7 = a7;
  *(void *)&__int128 v16 = a6;
  *((void *)&v16 + 1) = a7;
  __int128 v15 = v16;
  v13[0] = a1;
  v13[1] = &v15;
  v13[2] = &v16;
  if (a3 != a5)
  {
    uint64_t v9 = a7;
    do
    {
      __int128 v10 = *(_OWORD *)(a3 - 48);
      *(void *)(v9 - 32) = *(void *)(a3 - 32);
      *(_OWORD *)(v9 - 4_Block_object_dispose(va, 8) = v10;
      *(void *)(a3 - 4sub_10001AFB0((std::locale *)v24, " +$", 0) = 0LL;
      *(void *)(a3 - 32) = 0LL;
      *(void *)(a3 - 4_Block_object_dispose(va, 8) = 0LL;
      __int128 v11 = *(_OWORD *)(a3 - 24);
      *(void *)(v9 - _Block_object_dispose(va, 8) = *(void *)(a3 - 8);
      *(_OWORD *)(v9 - 24) = v11;
      v9 -= 48LL;
      *(void *)(a3 - 16) = 0LL;
      *(void *)(a3 - _Block_object_dispose(va, 8) = 0LL;
      *(void *)(a3 - 24) = 0LL;
      v7 -= 48LL;
      a3 -= 48LL;
    }

    while (a3 != a5);
    *((void *)&v16 + 1) = v9;
  }

  char v14 = 1;
  sub_10001A3C0((uint64_t)v13);
  return a6;
}

uint64_t sub_10001A3C0(uint64_t a1)
{
  if (!*(_BYTE *)(a1 + 24)) {
    sub_10001A3F4((uint64_t *)a1);
  }
  return a1;
}

void sub_10001A3F4(uint64_t *a1)
{
  uint64_t v1 = *(void *)(a1[2] + 8);
  uint64_t v2 = *(void *)(a1[1] + 8);
  if (v1 != v2)
  {
    uint64_t v3 = *a1;
    do
    {
      sub_10001A1D0(v3, v1);
      v1 += 48LL;
    }

    while (v1 != v2);
  }

void **sub_10001A444(void **a1)
{
  if (*a1) {
    operator delete(*a1);
  }
  return a1;
}

void sub_10001A474(void *a1)
{
  uint64_t v2 = a1[1];
  for (uint64_t i = a1[2]; i != v2; uint64_t i = a1[2])
  {
    uint64_t v4 = a1[4];
    a1[2] = i - 48;
    sub_10001A1D0(v4, i - 48);
  }

uint64_t sub_10001A4B8(uint64_t *a1, void *a2)
{
  uint64_t result = sub_10001A52C((uint64_t)(a1 + 2), a1[1], (void *)a1[1], *a1, (void *)*a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t sub_10001A52C(uint64_t a1, uint64_t a2, void *a3, uint64_t a4, void *a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7 = a7;
  *(void *)&__int128 v14 = a6;
  *((void *)&v14 + 1) = a7;
  __int128 v13 = v14;
  v11[0] = a1;
  v11[1] = &v13;
  v11[2] = &v14;
  if (a3 == a5)
  {
    uint64_t v9 = a6;
  }

  else
  {
    do
    {
      *(void *)(v7 - 24) = 0LL;
      *(void *)(v7 - 16) = 0LL;
      *(void *)(v7 - _Block_object_dispose(va, 8) = 0LL;
      __int128 v8 = *(_OWORD *)(a3 - 3);
      a3 -= 3;
      *(_OWORD *)(v7 - 24) = v8;
      *(void *)(v7 - _Block_object_dispose(va, 8) = a3[2];
      *a3 = 0LL;
      a3[1] = 0LL;
      a3[2] = 0LL;
      uint64_t v7 = *((void *)&v14 + 1) - 24LL;
      *((void *)&v14 + 1) -= 24LL;
    }

    while (a3 != a5);
    uint64_t v9 = v14;
  }

  char v12 = 1;
  sub_10001A5CC((uint64_t)v11);
  return v9;
}

uint64_t sub_10001A5CC(uint64_t a1)
{
  if (!*(_BYTE *)(a1 + 24)) {
    sub_10001A600(a1);
  }
  return a1;
}

void sub_10001A600(uint64_t a1)
{
  uint64_t v1 = *(void ***)(*(void *)(a1 + 16) + 8LL);
  uint64_t v2 = *(void ***)(*(void *)(a1 + 8) + 8LL);
  while (v1 != v2)
  {
    uint64_t v3 = v1;
    sub_10001A214(&v3);
    v1 += 3;
  }

void **sub_10001A648(void **a1)
{
  if (*a1) {
    operator delete(*a1);
  }
  return a1;
}

void sub_10001A678(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v2; uint64_t i = *(void *)(a1 + 16))
  {
    uint64_t v4 = (void **)(i - 24);
    *(void *)(a1 + 16) = v4;
    uint64_t v5 = v4;
    sub_10001A214(&v5);
  }

void *sub_10001A6C8(void *a1, unint64_t a2)
{
  *a1 = 0LL;
  a1[1] = 0LL;
  a1[2] = 0LL;
  if (a2)
  {
    sub_100019F84(a1, a2);
    uint64_t v4 = (char *)a1[1];
    size_t v5 = 48 * ((48 * a2 - 48) / 0x30) + 48;
    bzero(v4, v5);
    a1[1] = &v4[v5];
  }

  return a1;
}

void sub_10001A744(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + _Block_object_dispose(va, 8) = v3;
    operator delete(v3);
  }

  _Unwind_Resume(exception_object);
}

uint64_t sub_10001A760(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 16);
  if (v2)
  {
    do
    {
      uint64_t v3 = (void *)*v2;
      operator delete(v2);
      uint64_t v2 = v3;
    }

    while (v3);
  }

  uint64_t v4 = *(void **)a1;
  *(void *)a1 = 0LL;
  if (v4) {
    operator delete(v4);
  }
  return a1;
}

void sub_10001A7A8(uint64_t a1, void *a2)
{
  if (a2)
  {
    sub_10001A7A8(a1, *a2);
    sub_10001A7A8(a1, a2[1]);
    operator delete(a2);
  }

uint64_t sub_10001A7E8(uint64_t a1, unsigned int *a2)
{
  uint64_t v2 = a1 + 8;
  uint64_t v3 = *(void *)(a1 + 8);
  if (!v3) {
    return v2;
  }
  size_t v5 = (uint64_t **)(a1 + 24);
  uint64_t v6 = a1 + 8;
  do
  {
    BOOL v7 = sub_10001A874(v5, *(_DWORD *)(v3 + 28), *a2);
    __int128 v8 = (uint64_t *)(v3 + 8);
    if (!v7)
    {
      __int128 v8 = (uint64_t *)v3;
      uint64_t v6 = v3;
    }

    uint64_t v3 = *v8;
  }

  while (*v8);
  if (v6 == v2 || sub_10001A874(v5, *a2, *(_DWORD *)(v6 + 28))) {
    return v2;
  }
  return v6;
}

BOOL sub_10001A874(uint64_t **a1, unsigned int a2, unsigned int a3)
{
  uint64_t v3 = **a1;
  unsigned int v4 = *(_DWORD *)(v3 + 48LL * a2 + 8);
  unsigned int v5 = *(_DWORD *)(v3 + 48LL * a3 + 8);
  if (v4 < v5) {
    return 1LL;
  }
  if (v4 > v5) {
    return 0LL;
  }
  unsigned int v6 = *(unsigned __int16 *)(v3 + 48LL * a2 + 6);
  unsigned int v7 = *(unsigned __int16 *)(v3 + 48LL * a3 + 6);
  if (v6 < v7) {
    return 1LL;
  }
  return v6 <= v7 && *(unsigned __int16 *)(v3 + 48LL * a2 + 2) < *(unsigned __int16 *)(v3 + 48LL * a3 + 2);
}

uint64_t *sub_10001A8F4(uint64_t **a1, unsigned int *a2, _DWORD *a3)
{
  unsigned int v5 = sub_10001A974((uint64_t)a1, &v9, a2);
  unsigned int v6 = (uint64_t *)*v5;
  if (!*v5)
  {
    unsigned int v7 = (uint64_t **)v5;
    unsigned int v6 = (uint64_t *)operator new(0x20uLL);
    *((_DWORD *)v6 + 7) = *a3;
    sub_100019D14(a1, v9, v7, v6);
  }

  return v6;
}

uint64_t *sub_10001A974(uint64_t a1, void *a2, unsigned int *a3)
{
  unsigned int v5 = (uint64_t *)(a1 + 8);
  unsigned int v4 = *(uint64_t **)(a1 + 8);
  if (v4)
  {
    unsigned int v7 = (uint64_t **)(a1 + 24);
    do
    {
      while (1)
      {
        __int128 v8 = v4;
        if (!sub_10001A874(v7, *a3, *((_DWORD *)v4 + 7))) {
          break;
        }
        unsigned int v4 = (uint64_t *)*v8;
        unsigned int v5 = v8;
        if (!*v8) {
          goto LABEL_10;
        }
      }

      if (!sub_10001A874(v7, *((_DWORD *)v8 + 7), *a3)) {
        break;
      }
      unsigned int v5 = v8 + 1;
      unsigned int v4 = (uint64_t *)v8[1];
    }

    while (v4);
  }

  else
  {
    __int128 v8 = (uint64_t *)(a1 + 8);
  }

LABEL_10:
  *a2 = v8;
  return v5;
}

      __int128 v10 = (char *)*((void *)v2 + 1);
      if (v10)
      {
        do
        {
          __int128 v11 = v10;
          __int128 v10 = *(char **)v10;
        }

        while (v10);
      }

      else
      {
        do
        {
          __int128 v11 = (char *)*((void *)v2 + 2);
          char v12 = *(void *)v11 == (void)v2;
          uint64_t v2 = v11;
        }

        while (!v12);
      }

      uint64_t v2 = v11;
      if (v11 == v3) {
        return;
      }
    }

    __int128 v8 = count;
    uint64_t v9 = 0LL;
    while (xpc_array_get_uint64(v6, v9) != a2)
    {
      if (v8 == ++v9) {
        goto LABEL_10;
      }
    }

  if (v161)
  {
    v162 = v161;
    operator delete(v161);
  }

  *a2 = v8;
  return v5;
}

  *a2 = v8;
  return v5;
}

void *sub_10001AA0C(void *a1, unint64_t *a2)
{
  int8x8_t v2 = (int8x8_t)a1[1];
  if (!*(void *)&v2) {
    return 0LL;
  }
  unint64_t v3 = *a2;
  uint8x8_t v4 = (uint8x8_t)vcnt_s8(v2);
  v4.i16[0] = vaddlv_u8(v4);
  if (v4.u32[0] > 1uLL)
  {
    unint64_t v5 = *a2;
    if (v3 >= *(void *)&v2) {
      unint64_t v5 = v3 % *(void *)&v2;
    }
  }

  else
  {
    unint64_t v5 = (*(void *)&v2 - 1LL) & v3;
  }

  unsigned int v6 = *(void **)(*a1 + 8 * v5);
  if (!v6) {
    return 0LL;
  }
  uint64_t result = (void *)*v6;
  if (*v6)
  {
    do
    {
      unint64_t v8 = result[1];
      if (v8 == v3)
      {
        if (result[2] == v3) {
          return result;
        }
      }

      else
      {
        if (v4.u32[0] > 1uLL)
        {
          if (v8 >= *(void *)&v2) {
            v8 %= *(void *)&v2;
          }
        }

        else
        {
          v8 &= *(void *)&v2 - 1LL;
        }

        if (v8 != v5) {
          return 0LL;
        }
      }

      uint64_t result = (void *)*result;
    }

    while (result);
  }

  return result;
}

void sub_10001AAC0(RDQSRResultLMNodeBuilder **a1, RDQSRResultLMNodeBuilder *a2)
{
  unint64_t v3 = *a1;
  *a1 = a2;
  if (v3)
  {
    RDQSRResultLMNodeBuilder::~RDQSRResultLMNodeBuilder(v3);
    operator delete(v4);
  }

void sub_10001AAEC(void ***a1)
{
  uint64_t v1 = *a1;
  int8x8_t v2 = **a1;
  if (v2)
  {
    uint64_t v4 = (uint64_t)v1[1];
    unint64_t v5 = v2;
    if ((void *)v4 != v2)
    {
      do
        uint64_t v4 = sub_10001AB5C(v4 - 24);
      while ((void *)v4 != v2);
      unint64_t v5 = **a1;
    }

    v1[1] = v2;
    operator delete(v5);
  }

uint64_t sub_10001AB5C(uint64_t a1)
{
  int8x8_t v2 = *(void **)(a1 + 8);
  if (v2) {
    xpc_release(v2);
  }
  unint64_t v3 = *(void **)(a1 + 16);
  if (v3) {
    xpc_release(v3);
  }
  return a1;
}

uint64_t sub_10001AB98(uint64_t *a1, void *a2)
{
  uint64_t result = sub_10001AC0C((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t sub_10001AC0C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v10 = 0LL;
  uint64_t v11 = a7 - 24;
  while (a3 + v10 != a5)
  {
    uint64_t v12 = v11 + v10;
    v10 -= 24LL;
    sub_10001AC9C(v12, v10 + a3);
  }

  return a6;
}

uint64_t sub_10001AC9C(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)a1 = *(_DWORD *)a2;
  uint64_t v4 = *(void **)(a2 + 8);
  unint64_t v3 = *(void **)(a2 + 16);
  *(void *)(a1 + _Block_object_dispose(va, 8) = v4;
  *(void *)(a1 + 16) = v3;
  if (v4)
  {
    xpc_retain(v4);
    unint64_t v3 = *(void **)(a1 + 16);
  }

  if (v3) {
    xpc_retain(v3);
  }
  return a1;
}

uint64_t sub_10001ACE4(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 24;
    sub_10001AB5C(i - 24);
  }

  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

uint64_t sub_10001AD30(uint64_t *a1, unint64_t a2)
{
  uint64_t v6 = a1[2];
  uint64_t result = (uint64_t)(a1 + 2);
  uint64_t v5 = v6;
  uint64_t v7 = *(void *)(result - 8);
  if (0xAAAAAAAAAAAAAAABLL * ((v6 - v7) >> 3) >= a2)
  {
    if (a2)
    {
      uint64_t v13 = v7 + 24 * a2;
      do
      {
        *(_DWORD *)uint64_t v7 = 0;
        *(void *)(v7 + _Block_object_dispose(va, 8) = 0LL;
        *(void *)(v7 + 16) = 0LL;
        v7 += 24LL;
      }

      while (v7 != v13);
      uint64_t v7 = v13;
    }

    a1[1] = v7;
  }

  else
  {
    unint64_t v8 = 0xAAAAAAAAAAAAAAABLL * ((v7 - *a1) >> 3);
    unint64_t v9 = v8 + a2;
    if (v8 + a2 > 0xAAAAAAAAAAAAAAALL) {
      sub_100018774();
    }
    unint64_t v10 = 0xAAAAAAAAAAAAAAABLL * ((v5 - *a1) >> 3);
    if (2 * v10 > v9) {
      unint64_t v9 = 2 * v10;
    }
    if (v10 >= 0x555555555555555LL) {
      unint64_t v11 = 0xAAAAAAAAAAAAAAALL;
    }
    else {
      unint64_t v11 = v9;
    }
    v16[4] = result;
    if (v11) {
      uint64_t v12 = (char *)sub_100018F00(result, v11);
    }
    else {
      uint64_t v12 = 0LL;
    }
    __int128 v14 = &v12[24 * v8];
    v16[0] = v12;
    v16[1] = v14;
    v16[3] = &v12[24 * v11];
    __int128 v15 = &v14[24 * a2];
    do
    {
      *(_DWORD *)__int128 v14 = 0;
      *((void *)v14 + 1) = 0LL;
      *((void *)v14 + 2) = 0LL;
      v14 += 24;
    }

    while (v14 != v15);
    v16[2] = v15;
    sub_10001AB98(a1, v16);
    return sub_10001ACE4((uint64_t)v16);
  }

  return result;
}

void sub_10001AE5C(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

uint64_t sub_10001AE70(uint64_t a1, const void **a2)
{
  uint64_t v2 = a1 + 8;
  uint64_t v3 = *(void *)(a1 + 8);
  if (!v3) {
    return v2;
  }
  uint64_t v5 = a1 + 16;
  uint64_t v6 = a1 + 8;
  do
  {
    BOOL v7 = sub_10001AEFC(v5, (const void **)(v3 + 32), a2);
    unint64_t v8 = (uint64_t *)(v3 + 8);
    if (!v7)
    {
      unint64_t v8 = (uint64_t *)v3;
      uint64_t v6 = v3;
    }

    uint64_t v3 = *v8;
  }

  while (*v8);
  return v6;
}

BOOL sub_10001AEFC(uint64_t a1, const void **a2, const void **a3)
{
  int v3 = *((char *)a3 + 23);
  int v4 = *((char *)a2 + 23);
  if (v4 >= 0) {
    size_t v5 = *((unsigned __int8 *)a2 + 23);
  }
  else {
    size_t v5 = (size_t)a2[1];
  }
  if (v4 >= 0) {
    uint64_t v6 = a2;
  }
  else {
    uint64_t v6 = *a2;
  }
  if (v3 >= 0) {
    size_t v7 = *((unsigned __int8 *)a3 + 23);
  }
  else {
    size_t v7 = (size_t)a3[1];
  }
  if (v3 >= 0) {
    unint64_t v8 = a3;
  }
  else {
    unint64_t v8 = *a3;
  }
  if (v7 >= v5) {
    size_t v9 = v5;
  }
  else {
    size_t v9 = v7;
  }
  int v10 = memcmp(v6, v8, v9);
  if (v10) {
    return v10 < 0;
  }
  else {
    return v5 < v7;
  }
}

void sub_10001AF64(uint64_t a1, void **__p)
{
  if (*(_BYTE *)(a1 + 8))
  {
  }

  else if (!__p)
  {
    return;
  }

  operator delete(__p);
}

std::locale *sub_10001AFB0(std::locale *a1, char *a2, int a3)
{
  uint64_t v6 = sub_10001B040(a1);
  LODWORD(v6[3].__locale_) = a3;
  *(_OWORD *)((char *)&v6[3].__locale_ + 4) = 0u;
  *(_OWORD *)((char *)&v6[5].__locale_ + 4) = 0u;
  HIDWORD(v6[7].__locale_) = 0;
  size_t v7 = strlen(a2);
  return a1;
}

void sub_10001B024(_Unwind_Exception *a1)
{
}

std::locale *sub_10001B040(std::locale *a1)
{
  uint64_t v2 = std::locale::locale(a1);
  a1[1].__locale_ = (std::locale::__imp *)std::locale::use_facet(v2, &std::ctype<char>::id);
  a1[2].__locale_ = (std::locale::__imp *)std::locale::use_facet(a1, &std::collate<char>::id);
  return a1;
}

void sub_10001B088(_Unwind_Exception *a1)
{
}

char *sub_10001B09C(uint64_t a1, char *a2, char *a3)
{
  uint64_t v6 = operator new(8uLL);
  void *v6 = &off_1000CE428;
  size_t v7 = operator new(0x10uLL);
  *size_t v7 = &off_1000CE4F8;
  v7[1] = v6;
  sub_10001B238((void *)(a1 + 40), (uint64_t)v7);
  *(void *)(a1 + 56) = *(void *)(a1 + 40);
  unsigned int v8 = *(_DWORD *)(a1 + 24) & 0x1F0;
  if (v8 > 0x3F)
  {
    switch(v8)
    {
      case 0x40u:
        return sub_10001B4FC(a1, a2, a3);
      case 0x80u:
        return (char *)sub_10001B59C(a1, (unsigned __int8 *)a2, (unsigned __int8 *)a3);
      case 0x100u:
        return sub_10001B6CC(a1, a2, a3);
      default:
        goto LABEL_14;
    }
  }

  else if (v8)
  {
    if (v8 != 16)
    {
      if (v8 != 32) {
LABEL_14:
      }
        sub_10001B7FC();
      return sub_10001B4FC(a1, a2, a3);
    }

    return sub_10001B3D0(a1, (unsigned __int8 *)a2, (unsigned __int8 *)a3);
  }

  else
  {
    return sub_10001B2A8(a1, (unsigned __int8 *)a2, a3);
  }

void sub_10001B1D0(_Unwind_Exception *a1)
{
}

void sub_10001B1EC()
{
  exception = (std::regex_error *)__cxa_allocate_exception(0x18uLL);
  std::regex_error::regex_error(exception, __re_err_parse);
}

void sub_10001B224(_Unwind_Exception *a1)
{
}

void sub_10001B238(void *a1, uint64_t a2)
{
  int v3 = (std::__shared_weak_count *)a1[1];
  __int128 v4 = v7;
  *(void *)&__int128 v7 = *a1;
  *((void *)&v7 + 1) = v3;
  *(_OWORD *)a1 = v4;
  if (v3)
  {
    p_shared_owners = (unint64_t *)&v3->__shared_owners_;
    do
      unint64_t v6 = __ldaxr(p_shared_owners);
    while (__stlxr(v6 - 1, p_shared_owners));
    if (!v6)
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }

char *sub_10001B2A8(uint64_t a1, unsigned __int8 *a2, char *a3)
{
  uint64_t v6 = *(void *)(a1 + 56);
  __int128 v7 = a2;
  do
  {
    unsigned int v8 = v7;
    __int128 v7 = sub_10001BB10(a1, (char *)v7, a3);
  }

  while (v7 != v8);
  if (v8 == a2)
  {
    size_t v9 = operator new(0x10uLL);
    uint64_t v10 = *(void *)(a1 + 56);
    uint64_t v11 = *(void *)(v10 + 8);
    *size_t v9 = &off_1000CE4F8;
    v9[1] = v11;
    *(void *)(v10 + _Block_object_dispose(va, 8) = v9;
    *(void *)(a1 + 56) = *(void *)(*(void *)(a1 + 56) + 8LL);
  }

  if (v8 != (unsigned __int8 *)a3)
  {
    while (*v8 == 124)
    {
      uint64_t v12 = *(void *)(a1 + 56);
      uint64_t v13 = v8 + 1;
      __int128 v14 = v8 + 1;
      do
      {
        unsigned int v8 = v14;
        __int128 v14 = sub_10001BB10(a1, (char *)v14, a3);
      }

      while (v14 != v8);
      if (v8 == v13)
      {
        __int128 v15 = operator new(0x10uLL);
        uint64_t v16 = *(void *)(a1 + 56);
        uint64_t v17 = *(void *)(v16 + 8);
        void *v15 = &off_1000CE4F8;
        v15[1] = v17;
        *(void *)(v16 + _Block_object_dispose(va, 8) = v15;
        *(void *)(a1 + 56) = *(void *)(*(void *)(a1 + 56) + 8LL);
      }

      sub_10001BA60(a1, v6, v12);
    }

    return (char *)v8;
  }

  return a3;
}

char *sub_10001B3D0(uint64_t a1, unsigned __int8 *a2, unsigned __int8 *a3)
{
  int v3 = a2;
  if (a2 == a3) {
    return (char *)a2;
  }
  __int128 v4 = (char *)a3;
  if (*a2 == 94)
  {
    uint64_t v6 = operator new(0x18uLL);
    BOOL v7 = (*(_DWORD *)(a1 + 24) & 0x5F0) == 1024;
    uint64_t v8 = *(void *)(a1 + 56);
    uint64_t v9 = *(void *)(v8 + 8);
    void *v6 = &off_1000CE5A0;
    v6[1] = v9;
    *((_BYTE *)v6 + 16) = v7;
    *(void *)(v8 + _Block_object_dispose(va, 8) = v6;
    *(void *)(a1 + 56) = *(void *)(*(void *)(a1 + 56) + 8LL);
    ++v3;
  }

  if (v3 != (unsigned __int8 *)v4)
  {
    do
    {
      uint64_t v10 = v3;
      int v3 = sub_1000220C8(a1, (char *)v3, v4);
    }

    while (v3 != v10);
    if (v10 != (unsigned __int8 *)v4)
    {
      uint64_t v11 = operator new(0x18uLL);
      BOOL v12 = (*(_DWORD *)(a1 + 24) & 0x5F0) == 1024;
      uint64_t v13 = *(void *)(a1 + 56);
      uint64_t v14 = *(void *)(v13 + 8);
      *uint64_t v11 = &off_1000CE5E8;
      v11[1] = v14;
      *((_BYTE *)v11 + 16) = v12;
      *(void *)(v13 + _Block_object_dispose(va, 8) = v11;
      *(void *)(a1 + 56) = *(void *)(*(void *)(a1 + 56) + 8LL);
    }
  }

  return v4;
}

char *sub_10001B4FC(uint64_t a1, char *a2, char *a3)
{
  int v3 = a3;
  uint64_t v6 = *(void *)(a1 + 56);
  BOOL v7 = sub_1000226A0(a1, a2, a3);
  if (v7 == (unsigned __int8 *)a2) {
LABEL_9:
  }
    sub_10002207C();
  uint64_t v8 = v7;
  while (v8 != (unsigned __int8 *)v3)
  {
    if (*v8 != 124) {
      return (char *)v8;
    }
    uint64_t v9 = *(void *)(a1 + 56);
    uint64_t v10 = sub_1000226A0(a1, (char *)v8 + 1, v3);
    if (v10 == v8 + 1) {
      goto LABEL_9;
    }
    uint64_t v8 = v10;
    sub_10001BA60(a1, v6, v9);
  }

  return v3;
}

unsigned __int8 *sub_10001B59C(uint64_t a1, unsigned __int8 *__s, unsigned __int8 *a3)
{
  uint64_t v6 = *(void *)(a1 + 56);
  BOOL v7 = (unsigned __int8 *)memchr(__s, 10, a3 - __s);
  if (v7) {
    uint64_t v8 = v7;
  }
  else {
    uint64_t v8 = a3;
  }
  if (v8 == __s)
  {
    uint64_t v9 = operator new(0x10uLL);
    uint64_t v10 = *(void *)(v6 + 8);
    *uint64_t v9 = &off_1000CE4F8;
    v9[1] = v10;
    *(void *)(v6 + _Block_object_dispose(va, 8) = v9;
    *(void *)(a1 + 56) = *(void *)(*(void *)(a1 + 56) + 8LL);
  }

  else
  {
    sub_10001B3D0(a1, __s, v8);
  }

  if (v8 != a3) {
    ++v8;
  }
  while (v8 != a3)
  {
    uint64_t v11 = (unsigned __int8 *)memchr(v8, 10, a3 - v8);
    if (v11) {
      BOOL v12 = v11;
    }
    else {
      BOOL v12 = a3;
    }
    uint64_t v13 = *(void *)(a1 + 56);
    if (v12 == v8)
    {
      uint64_t v14 = operator new(0x10uLL);
      uint64_t v15 = *(void *)(v13 + 8);
      *uint64_t v14 = &off_1000CE4F8;
      v14[1] = v15;
      *(void *)(v13 + _Block_object_dispose(va, 8) = v14;
      *(void *)(a1 + 56) = *(void *)(*(void *)(a1 + 56) + 8LL);
    }

    else
    {
      sub_10001B3D0(a1, v8, v12);
    }

    sub_10001BA60(a1, v6, v13);
    if (v12 == a3) {
      uint64_t v8 = v12;
    }
    else {
      uint64_t v8 = v12 + 1;
    }
  }

  return a3;
}

char *sub_10001B6CC(uint64_t a1, char *__s, char *a3)
{
  uint64_t v6 = *(void *)(a1 + 56);
  BOOL v7 = (char *)memchr(__s, 10, a3 - __s);
  if (v7) {
    uint64_t v8 = v7;
  }
  else {
    uint64_t v8 = a3;
  }
  if (v8 == __s)
  {
    uint64_t v9 = operator new(0x10uLL);
    uint64_t v10 = *(void *)(v6 + 8);
    *uint64_t v9 = &off_1000CE4F8;
    v9[1] = v10;
    *(void *)(v6 + _Block_object_dispose(va, 8) = v9;
    *(void *)(a1 + 56) = *(void *)(*(void *)(a1 + 56) + 8LL);
  }

  else
  {
    sub_10001B4FC(a1, __s, v8);
  }

  if (v8 != a3) {
    ++v8;
  }
  while (v8 != a3)
  {
    uint64_t v11 = (char *)memchr(v8, 10, a3 - v8);
    if (v11) {
      BOOL v12 = v11;
    }
    else {
      BOOL v12 = a3;
    }
    uint64_t v13 = *(void *)(a1 + 56);
    if (v12 == v8)
    {
      uint64_t v14 = operator new(0x10uLL);
      uint64_t v15 = *(void *)(v13 + 8);
      *uint64_t v14 = &off_1000CE4F8;
      v14[1] = v15;
      *(void *)(v13 + _Block_object_dispose(va, 8) = v14;
      *(void *)(a1 + 56) = *(void *)(*(void *)(a1 + 56) + 8LL);
    }

    else
    {
      sub_10001B4FC(a1, v8, v12);
    }

    sub_10001BA60(a1, v6, v13);
    if (v12 == a3) {
      uint64_t v8 = v12;
    }
    else {
      uint64_t v8 = v12 + 1;
    }
  }

  return a3;
}

void sub_10001B7FC()
{
  exception = (std::regex_error *)__cxa_allocate_exception(0x18uLL);
  std::regex_error::regex_error(exception, __re_err_grammar);
}

void sub_10001B834(_Unwind_Exception *a1)
{
}

void sub_10001B850(uint64_t a1, _DWORD *a2)
{
  *a2 = -1000;
}

void *sub_10001B864(void *a1, uint64_t a2)
{
  *a1 = a2;
  __int128 v4 = operator new(0x20uLL);
  *__int128 v4 = &off_1000CE480;
  v4[1] = 0LL;
  v4[2] = 0LL;
  v4[3] = a2;
  a1[1] = v4;
  return a1;
}

void sub_10001B8AC(_Unwind_Exception *exception_object)
{
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8LL))(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_10001B8D0(std::__shared_weak_count *a1)
{
}

uint64_t sub_10001B8E4(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(uint64_t))(*(void *)result + 8LL))(result);
  }
  return result;
}

uint64_t sub_10001B8FC(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }

  else
  {
    return 0LL;
  }

void *sub_10001B93C(void *a1)
{
  *a1 = &off_1000CE570;
  uint64_t v2 = a1[1];
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8LL))(v2);
  }
  return a1;
}

void sub_10001B980(void *__p)
{
  *std::string __p = &off_1000CE570;
  uint64_t v2 = __p[1];
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8LL))(v2);
  }
  operator delete(__p);
}

uint64_t sub_10001B9C4(uint64_t result, uint64_t a2)
{
  *(_DWORD *)a2 = -994;
  *(void *)(a2 + 8sub_10001AFB0((std::locale *)v24, " +$", 0) = *(void *)(result + 8);
  return result;
}

void *sub_10001B9D8(void *a1)
{
  *a1 = &off_1000CE570;
  uint64_t v2 = a1[1];
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8LL))(v2);
  }
  return a1;
}

void sub_10001BA1C(void *__p)
{
  *std::string __p = &off_1000CE570;
  uint64_t v2 = __p[1];
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8LL))(v2);
  }
  operator delete(__p);
}

void *sub_10001BA60(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = operator new(0x18uLL);
  uint64_t v7 = *(void *)(a3 + 8);
  v6[1] = *(void *)(a2 + 8);
  v6[2] = v7;
  void *v6 = &off_1000CEA68;
  *(void *)(a2 + _Block_object_dispose(va, 8) = v6;
  *(void *)(a3 + _Block_object_dispose(va, 8) = 0LL;
  uint64_t v8 = operator new(0x10uLL);
  uint64_t v9 = *(void *)(*(void *)(a1 + 56) + 8LL);
  void *v8 = &off_1000CE4F8;
  v8[1] = v9;
  *(void *)(a3 + _Block_object_dispose(va, 8) = v8;
  *(void *)(*(void *)(a1 + 56) + 8LL) = 0LL;
  uint64_t result = operator new(0x10uLL);
  uint64_t v11 = *(void *)(a3 + 8);
  void *result = &off_1000CEAB0;
  result[1] = v11;
  *(void *)(*(void *)(a1 + 56) + 8LL) = result;
  *(void *)(a1 + 56) = *(void *)(a3 + 8);
  return result;
}

unsigned __int8 *sub_10001BB10(uint64_t a1, char *a2, char *a3)
{
  uint64_t result = (unsigned __int8 *)sub_10001BBA4(a1, a2, a3);
  if (result == (unsigned __int8 *)a2)
  {
    uint64_t v7 = *(void *)(a1 + 56);
    int v8 = *(_DWORD *)(a1 + 28);
    uint64_t v9 = sub_10001BE2C(a1, (unsigned __int8 *)a2, (unsigned __int8 *)a3);
    uint64_t result = (unsigned __int8 *)a2;
  }

  return result;
}

char *sub_10001BBA4(uint64_t a1, char *a2, char *a3)
{
  int v3 = a2;
  if (a2 == a3) {
    return v3;
  }
  int v6 = *a2;
  if (v6 <= 91)
  {
    if (v6 != 36)
    {
      BOOL v8 = v6 == 40;
      uint64_t v7 = a2 + 1;
      BOOL v8 = !v8 || v7 == a3;
      if (!v8)
      {
        BOOL v8 = *v7 == 63;
        uint64_t v9 = a2 + 2;
        if (v8 && v9 != a3)
        {
          int v11 = *v9;
          if (v11 == 33)
          {
            sub_10001B040(v23);
            __int128 v24 = 0u;
            uint64_t v26 = 0LL;
            __int128 v25 = 0u;
            LODWORD(v24) = *(_DWORD *)(a1 + 24);
            BOOL v12 = (char *)sub_10001B09C(v23, v3 + 3, a3);
            int v22 = DWORD1(v24);
            sub_10001C398(a1, (uint64_t)v23, 1, *(_DWORD *)(a1 + 28));
            *(_DWORD *)(a1 + 28) += v22;
            if (v12 == a3 || *v12 != 41) {
              sub_10001C41C();
            }
            goto LABEL_31;
          }

          if (v11 == 61)
          {
            sub_10001B040(v23);
            __int128 v24 = 0u;
            uint64_t v26 = 0LL;
            __int128 v25 = 0u;
            LODWORD(v24) = *(_DWORD *)(a1 + 24);
            BOOL v12 = (char *)sub_10001B09C(v23, v3 + 3, a3);
            int v13 = DWORD1(v24);
            sub_10001C398(a1, (uint64_t)v23, 0, *(_DWORD *)(a1 + 28));
            *(_DWORD *)(a1 + 28) += v13;
            if (v12 == a3 || *v12 != 41) {
              sub_10001C41C();
            }
LABEL_31:
            int v3 = v12 + 1;
            sub_100017FC4((uint64_t)&v25);
            std::locale::~locale(v23);
            return v3;
          }
        }
      }

      return v3;
    }

    uint64_t v14 = operator new(0x18uLL);
    BOOL v15 = (*(_DWORD *)(a1 + 24) & 0x5F0) == 1024;
    uint64_t v16 = *(void *)(a1 + 56);
    uint64_t v17 = *(void *)(v16 + 8);
LABEL_21:
    *uint64_t v14 = v18 + 2;
    v14[1] = v17;
    *((_BYTE *)v14 + 16) = v15;
    *(void *)(v16 + _Block_object_dispose(va, 8) = v14;
    *(void *)(a1 + 56) = *(void *)(*(void *)(a1 + 56) + 8LL);
    return ++v3;
  }

  if (v6 != 92)
  {
    if (v6 != 94) {
      return v3;
    }
    uint64_t v14 = operator new(0x18uLL);
    BOOL v15 = (*(_DWORD *)(a1 + 24) & 0x5F0) == 1024;
    uint64_t v16 = *(void *)(a1 + 56);
    uint64_t v17 = *(void *)(v16 + 8);
    goto LABEL_21;
  }

  if (a2 + 1 != a3)
  {
    int v20 = a2[1];
    if (v20 == 66)
    {
      char v21 = 1;
    }

    else
    {
      if (v20 != 98) {
        return v3;
      }
      char v21 = 0;
    }

    sub_10001C324(a1, v21);
    v3 += 2;
  }

  return v3;
}

void sub_10001BE00( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, std::locale a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14)
{
}

unsigned __int8 *sub_10001BE2C(uint64_t a1, unsigned __int8 *a2, unsigned __int8 *a3)
{
  int v3 = a2;
  if (a2 == a3) {
    return v3;
  }
  int v6 = (char)*a2;
  if (v6 > 62)
  {
    if (v6 > 91)
    {
      if (v6 == 92) {
        return sub_10001DA48(a1, a2, a3);
      }
      if (v6 != 123) {
        return sub_10001DD04(a1, a2, a3);
      }
    }

    else
    {
      if (v6 == 91) {
        return (unsigned __int8 *)sub_10001DAE8(a1, (char *)a2, (char *)a3);
      }
      if (v6 != 63) {
        return sub_10001DD04(a1, a2, a3);
      }
    }

LABEL_29:
    sub_10001DCB8();
  }

  if (v6 == 40)
  {
    if (a2 + 1 == a3) {
      goto LABEL_30;
    }
    if (a2 + 2 != a3 && a2[1] == 63 && a2[2] == 58)
    {
      int v11 = (_DWORD *)(a1 + 36);
      ++*(_DWORD *)(a1 + 36);
      BOOL v12 = (unsigned __int8 *)sub_10001B2A8(a1, a2 + 3, a3);
      if (v12 == a3) {
        goto LABEL_30;
      }
      int v3 = v12;
      if (*v12 != 41) {
        goto LABEL_30;
      }
    }

    else
    {
      sub_10001DBF8((void *)a1);
      int v13 = *(_DWORD *)(a1 + 28);
      int v11 = (_DWORD *)(a1 + 36);
      ++*(_DWORD *)(a1 + 36);
      uint64_t v14 = (unsigned __int8 *)sub_10001B2A8(a1, v3 + 1, a3);
      if (v14 == a3 || (int v3 = v14, *v14 != 41)) {
LABEL_30:
      }
        sub_10001C41C();
      sub_10001DC5C((void *)a1, v13);
    }

    --*v11;
    return ++v3;
  }

  if (v6 == 46)
  {
    uint64_t v7 = operator new(0x10uLL);
    uint64_t v8 = *(void *)(a1 + 56);
    uint64_t v9 = *(void *)(v8 + 8);
    *uint64_t v7 = &off_1000CE6C0;
    v7[1] = v9;
    *(void *)(v8 + _Block_object_dispose(va, 8) = v7;
    *(void *)(a1 + 56) = *(void *)(*(void *)(a1 + 56) + 8LL);
    return ++v3;
  }

  return sub_10001DD04(a1, a2, a3);
}

        uint64_t v17 = (os_log_s *)RXOSLog();
        if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)std::string buf = 67109376;
          pid = xpc_connection_get_pid(a1);
          __int128 v25 = 2048;
          uint64_t v26 = v6;
          uint64_t v8 = "peer(%d) unknown or unimplemented message %lld";
          uint64_t v10 = v17;
          int v11 = OS_LOG_TYPE_ERROR;
          BOOL v12 = 18;
          goto LABEL_24;
        }

        return;
      }

      reply = xpc_dictionary_create_reply(object);
      xpc_dictionary_set_int64(reply, kRDKeyMessage, 201LL);
      if (xpc_dictionary_get_BOOL(object, kRDKeyLiveAudio))
      {
        BOOL v15 = (RDAudioObject *)operator new(0x10uLL);
        unint64_t value = xpc_dictionary_get_value(object, kRDKeyAudioDevice);
        RDAudioObject::RDAudioObject(v15, value);
      }

      else
      {
        BOOL v15 = 0LL;
      }

      unint64_t v18 = (_xpc_connection_s *)xpc_dictionary_get_value(object, kRDKeyLocale);
      size_t v19 = xpc_dictionary_get_uint64(object, kRDKeyOptions);
      Peer = RDPeer::CreatePeer(a1, v18, v19, v15, v20);
      sub_10002EB0C(a1, (uint64_t)Peer);
      v22[0] = _NSConcreteStackBlock;
      v22[1] = 0x40000000LL;
      v22[2] = sub_10002EBEC;
      v22[3] = &unk_1000CED38;
      v22[4] = a1;
      void v22[5] = Peer;
      xpc_connection_set_event_handler(a1, v22);
      (*(void (**)(RDQSRPeer *, xpc_object_t))(*(void *)Peer + 16LL))(Peer, object);
LABEL_33:
      if (reply)
      {
        xpc_connection_send_message(a1, reply);
        xpc_release(reply);
      }

      return;
    }

    reply = xpc_dictionary_create(0LL, 0LL, 0LL);
    xpc_dictionary_set_int64(reply, kRDKeyMessage, 202LL);
    goto LABEL_33;
  }

  if (object == &_xpc_error_connection_invalid)
  {
    uint64_t v7 = (os_log_s *)RXOSLog();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)std::string buf = 67109120;
      pid = xpc_connection_get_pid(a1);
      uint64_t v8 = "peer(%d) XPC_ERROR_CONNECTION_INVALID";
      goto LABEL_23;
    }
  }

  else if (object == &_xpc_error_connection_interrupted)
  {
    uint64_t v7 = (os_log_s *)RXOSLog();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)std::string buf = 67109120;
      pid = xpc_connection_get_pid(a1);
      uint64_t v8 = "peer(%d) XPC_ERROR_CONNECTION_INTERRUPTED";
      goto LABEL_23;
    }
  }

  else if (object == &_xpc_error_termination_imminent)
  {
    uint64_t v7 = (os_log_s *)RXOSLog();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)std::string buf = 67109120;
      pid = xpc_connection_get_pid(a1);
      uint64_t v8 = "peer(%d) XPC_ERROR_TERMINATION_IMMINENT";
      goto LABEL_23;
    }
  }

    *a3 = v17;
    return v5;
  }

  if (v7 >= v6)
  {
    *a3 = a2;
    *a4 = a2;
    return a4;
  }

  int v11 = a2[1];
  if (v11)
  {
    BOOL v12 = (void *)a2[1];
    do
    {
      a4 = v12;
      BOOL v12 = (void *)*v12;
    }

    while (v12);
  }

  else
  {
    size_t v19 = a2;
    do
    {
      a4 = (void *)v19[2];
      uint64_t v14 = *a4 == (void)v19;
      size_t v19 = a4;
    }

    while (!v14);
  }

  if (a4 != v5 && v6 >= a4[4])
  {
    int v20 = (void *)*v5;
    if (*v5)
    {
      do
      {
        while (1)
        {
          char v21 = v20;
          int v22 = v20[4];
          if (v6 >= v22) {
            break;
          }
          int v20 = (void *)*v21;
          size_t v5 = v21;
          if (!*v21) {
            goto LABEL_48;
          }
        }

        if (v22 >= v6) {
          break;
        }
        size_t v5 = v21 + 1;
        int v20 = (void *)v21[1];
      }

      while (v20);
    }

    else
    {
      char v21 = a1 + 1;
    }

    *a3 = v17;
    return v5;
  }

  if (v7 >= v6)
  {
    *a3 = a2;
    *a4 = (uint64_t)a2;
    return a4;
  }

  int v11 = a2[1];
  if (v11)
  {
    BOOL v12 = (uint64_t *)a2[1];
    do
    {
      a4 = v12;
      BOOL v12 = (uint64_t *)*v12;
    }

    while (v12);
  }

  else
  {
    size_t v19 = a2;
    do
    {
      a4 = (uint64_t *)v19[2];
      uint64_t v14 = *a4 == (void)v19;
      size_t v19 = a4;
    }

    while (!v14);
  }

  if (a4 != v5 && v6 >= *((_DWORD *)a4 + 7))
  {
    int v20 = *v5;
    if (*v5)
    {
      do
      {
        while (1)
        {
          char v21 = (uint64_t *)v20;
          int v22 = *(_DWORD *)(v20 + 28);
          if (v6 >= v22) {
            break;
          }
          int v20 = *v21;
          size_t v5 = v21;
          if (!*v21) {
            goto LABEL_48;
          }
        }

        if (v22 >= v6) {
          break;
        }
        size_t v5 = v21 + 1;
        int v20 = v21[1];
      }

      while (v20);
    }

    else
    {
      char v21 = a1 + 1;
    }

        BOOL v15 = *((void *)v10 + 2) + 16LL * *((void *)v10 + 5);
LABEL_30:
        uint64_t v16 = *(int *)(v15 + 12);
        uint64_t v17 = v56 - v55;
        if (v56 - v55 <= v16)
        {
          size_t v5 = v16 + 1;
          if (v16 + 1 <= v17)
          {
            if (v16 + 1 < v17) {
              uint64_t v56 = &v55[v5];
            }
          }

          else
          {
            sub_10002BA28(&v55, v16 + 1 - v17, &unk_1000AF61E);
          }
        }

        if (*(void *)v15)
        {
          int v22 = *((void *)v10 + 1);
          if (v22) {
            goto LABEL_53;
          }
          goto LABEL_54;
        }

        double v23 = *(int *)(v15 + 12);
        __int128 v24 = v55[v23];
        if (v24 == 1)
        {
          uint64_t v9 = sub_10002B5F0((uint64_t)a2, v11, v15);
          int v22 = *((void *)v10 + 1);
          if (v22) {
            goto LABEL_53;
          }
          goto LABEL_54;
        }

        if (v24 != 2)
        {
          v55[v23] = 1;
          __int128 v25 = v52;
          if (v52)
          {
            unint64_t v52 = (char *)*((void *)v52 + 6);
          }

          else
          {
            __int128 v25 = sub_10002BED8(v50, 1LL);
            *((void *)v25 + 6) = 0LL;
          }

          *(_DWORD *)__int128 v25 = *(_DWORD *)(v15 + 12);
          *(_OWORD *)(v25 + 24) = 0u;
          *((void *)v25 + 5) = 0LL;
          *(_OWORD *)(v25 + _Block_object_dispose(va, 8) = 0u;
          (*(void (**)(uint64_t))(*(void *)a1 + 120LL))(a1);
          std::string::size_type v45 = v25;
          sub_10002BB40(v53, &v45);
          uint64_t v8 = sub_10002B010(a2, *(_DWORD *)(v15 + 12), v6);
          goto LABEL_16;
        }

        uint64_t v9 = sub_10002B684((void **)a2, v11, v15);
        int v22 = *((void *)v10 + 1);
        if (!v22) {
          goto LABEL_54;
        }
LABEL_53:
        (*(void (**)(uint64_t))(*(void *)v22 + 32LL))(v22);
      }

      else
      {
        if (*((void *)v10 + 5) < *((void *)v10 + 3)) {
          goto LABEL_29;
        }
LABEL_33:
        v55[v11] = 2;
        unint64_t v18 = *((void *)v10 + 1);
        if (v18)
        {
          (*(void (**)(uint64_t))(*(void *)v18 + 8LL))(v18);
        }

        else
        {
          size_t v19 = (_DWORD *)*((void *)v10 + 4);
          if (v19) {
            --*v19;
          }
        }

        *((void *)v10 + 6) = v52;
        unint64_t v52 = (char *)v10;
        --*((void *)&v54 + 1);
        sub_10002C2E0(v53, 1);
        if (*((void *)&v54 + 1))
        {
          uint64_t v10 = *(int **)(*(void *)(*((void *)&v53[0] + 1)
          int v20 = *v10;
          char v21 = *((void *)v10 + 1);
          if (v21) {
            (*(void (**)(uint64_t))(*(void *)v21 + 24LL))(v21);
          }
          sub_10002B410((uint64_t)a2, v11, v20);
          int v22 = *((void *)v10 + 1);
          if (v22) {
            goto LABEL_53;
          }
LABEL_54:
          ++*((void *)v10 + 5);
        }

        else
        {
          sub_10002B410((uint64_t)a2, v11, -1);
        }
      }
    }

    if ((a3 & 1) != 0) {
      break;
    }
    if ((_DWORD)v6 == v44) {
      int v6 = 0LL;
    }
    else {
      int v6 = (v6 + 1);
    }
    if ((int)v6 < (int)v5)
    {
      uint64_t v26 = &v55[(int)v6];
      xpc_object_t v27 = (int)v5 - (uint64_t)(int)v6;
      while (*v26++)
      {
        int v6 = (v6 + 1);
        if (!--v27)
        {
          int v6 = v5;
          break;
        }
      }
    }

    if (v43 || (_DWORD)v6 != (_DWORD)v5) {
      continue;
    }
LABEL_70:
    if (v46)
    {
      if (v46)
      {
        xpc_object_t v29 = (*(uint64_t (**)(uint64_t))(*(void *)v46 + 24LL))(v46);
        goto LABEL_76;
      }
    }

    else if (v48 >= v47)
    {
      continue;
    }

    xpc_object_t v29 = v48;
LABEL_76:
    if (v29 != (_DWORD)v5)
    {
      if (v46) {
        (*(void (**)(uint64_t))(*(void *)v46 + 32LL))(v46);
      }
      else {
        ++v48;
      }
      goto LABEL_70;
    }

    uint64_t v30 = v56;
    if (v56 >= v57)
    {
      uint64_t v32 = (unint64_t)v55;
      unint64_t v33 = v56 - v55;
      unint64_t v34 = v56 - v55 + 1;
      if (v34 < 0) {
        sub_100018774();
      }
      std::string v35 = v57 - v55;
      if (v35 >= 0x3FFFFFFFFFFFFFFFLL) {
        uint64_t v36 = 0x7FFFFFFFFFFFFFFFLL;
      }
      else {
        uint64_t v36 = v34;
      }
      if (v36) {
        unint64_t v37 = (char *)operator new(v36);
      }
      else {
        unint64_t v37 = 0LL;
      }
      unint64_t v38 = &v37[v33];
      unint64_t v39 = &v37[v33];
      char *v39 = 0;
      uint64_t v31 = v39 + 1;
      if (v30 != (char *)v32)
      {
        char v40 = &v30[~v32];
        do
        {
          uint64_t v41 = *--v30;
          (v40--)[(void)v37] = v41;
        }

        while (v30 != (char *)v32);
        uint64_t v30 = v55;
        unint64_t v38 = v37;
      }

      uint64_t v55 = v38;
      uint64_t v56 = v31;
      unint64_t v57 = &v37[v36];
      if (v30) {
        operator delete(v30);
      }
    }

    else
    {
      *uint64_t v56 = 0;
      uint64_t v31 = v30 + 1;
    }

    size_t v5 = (v5 + 1);
    uint64_t v56 = v31;
  }

  while ((v9 & 1) != 0 && (int)v6 < (int)v5);
LABEL_100:
  sub_10002AF44((uint64_t)a2);
  if (v46) {
    (*(void (**)(uint64_t))(*(void *)v46 + 8LL))(v46);
  }
  uint64_t v49 = off_1000D0BA0;
  v50[0] = off_1000D0BC8;
  sub_10002B998(v51);
  sub_10002C34C(v53);
  if (v55)
  {
    uint64_t v56 = v55;
    operator delete(v55);
  }

      if ((void)v29) {
        (*(void (**)(void, __n128))(*(void *)v29 + 32LL))(v29, v16);
      }
      else {
        ++v31;
      }
    }

    if ((void)v29)
    {
      (*(void (**)(void))(*(void *)v29 + 8LL))();
      goto LABEL_41;
    }

        BOOL v15 = *((void *)v10 + 2) + 16LL * *((void *)v10 + 5);
LABEL_30:
        uint64_t v16 = *(int *)(v15 + 12);
        uint64_t v17 = v56 - v55;
        if (v56 - v55 <= v16)
        {
          size_t v5 = v16 + 1;
          if (v16 + 1 <= v17)
          {
            if (v16 + 1 < v17) {
              uint64_t v56 = &v55[v5];
            }
          }

          else
          {
            sub_10002BA28(&v55, v16 + 1 - v17, &unk_1000AF732);
          }
        }

        if (*(void *)v15)
        {
          int v22 = *((void *)v10 + 1);
          if (v22) {
            goto LABEL_53;
          }
          goto LABEL_54;
        }

        double v23 = *(int *)(v15 + 12);
        __int128 v24 = v55[v23];
        if (v24 == 1)
        {
          uint64_t v9 = sub_10002B5F0((uint64_t)a2, v11, v15);
          int v22 = *((void *)v10 + 1);
          if (v22) {
            goto LABEL_53;
          }
          goto LABEL_54;
        }

        if (v24 != 2)
        {
          v55[v23] = 1;
          __int128 v25 = v52;
          if (v52)
          {
            unint64_t v52 = (char *)*((void *)v52 + 6);
          }

          else
          {
            __int128 v25 = sub_10002BED8(v50, 1LL);
            *((void *)v25 + 6) = 0LL;
          }

          *(_DWORD *)__int128 v25 = *(_DWORD *)(v15 + 12);
          *(_OWORD *)(v25 + 24) = 0u;
          *((void *)v25 + 5) = 0LL;
          *(_OWORD *)(v25 + _Block_object_dispose(va, 8) = 0u;
          (*(void (**)(uint64_t))(*(void *)a1 + 120LL))(a1);
          std::string::size_type v45 = v25;
          sub_100081AF0(v53, &v45);
          uint64_t v8 = sub_10002B010(a2, *(_DWORD *)(v15 + 12), v6);
          goto LABEL_16;
        }

        uint64_t v9 = sub_10002B684((void **)a2, v11, v15);
        int v22 = *((void *)v10 + 1);
        if (!v22) {
          goto LABEL_54;
        }
LABEL_53:
        (*(void (**)(uint64_t))(*(void *)v22 + 32LL))(v22);
      }

      else
      {
        if (*((void *)v10 + 5) < *((void *)v10 + 3)) {
          goto LABEL_29;
        }
LABEL_33:
        v55[v11] = 2;
        unint64_t v18 = *((void *)v10 + 1);
        if (v18)
        {
          (*(void (**)(uint64_t))(*(void *)v18 + 8LL))(v18);
        }

        else
        {
          size_t v19 = (_DWORD *)*((void *)v10 + 4);
          if (v19) {
            --*v19;
          }
        }

        *((void *)v10 + 6) = v52;
        unint64_t v52 = (char *)v10;
        --*((void *)&v54 + 1);
        sub_10002C2E0(v53, 1);
        if (*((void *)&v54 + 1))
        {
          uint64_t v10 = *(int **)(*(void *)(*((void *)&v53[0] + 1)
          int v20 = *v10;
          char v21 = *((void *)v10 + 1);
          if (v21) {
            (*(void (**)(uint64_t))(*(void *)v21 + 24LL))(v21);
          }
          sub_10002B410((uint64_t)a2, v11, v20);
          int v22 = *((void *)v10 + 1);
          if (v22) {
            goto LABEL_53;
          }
LABEL_54:
          ++*((void *)v10 + 5);
        }

        else
        {
          sub_10002B410((uint64_t)a2, v11, -1);
        }
      }
    }

    if ((a3 & 1) != 0) {
      break;
    }
    if ((_DWORD)v6 == v44) {
      int v6 = 0LL;
    }
    else {
      int v6 = (v6 + 1);
    }
    if ((int)v6 < (int)v5)
    {
      uint64_t v26 = &v55[(int)v6];
      xpc_object_t v27 = (int)v5 - (uint64_t)(int)v6;
      while (*v26++)
      {
        int v6 = (v6 + 1);
        if (!--v27)
        {
          int v6 = v5;
          break;
        }
      }
    }

    if (v43 || (_DWORD)v6 != (_DWORD)v5) {
      continue;
    }
LABEL_70:
    if (v46)
    {
      if (v46)
      {
        xpc_object_t v29 = (*(uint64_t (**)(uint64_t))(*(void *)v46 + 24LL))(v46);
        goto LABEL_76;
      }
    }

    else if (v48 >= v47)
    {
      continue;
    }

    xpc_object_t v29 = v48;
LABEL_76:
    if (v29 != (_DWORD)v5)
    {
      if (v46) {
        (*(void (**)(uint64_t))(*(void *)v46 + 32LL))(v46);
      }
      else {
        ++v48;
      }
      goto LABEL_70;
    }

    uint64_t v30 = v56;
    if (v56 >= v57)
    {
      uint64_t v32 = (unint64_t)v55;
      unint64_t v33 = v56 - v55;
      unint64_t v34 = v56 - v55 + 1;
      if (v34 < 0) {
        sub_100018774();
      }
      std::string v35 = v57 - v55;
      if (v35 >= 0x3FFFFFFFFFFFFFFFLL) {
        uint64_t v36 = 0x7FFFFFFFFFFFFFFFLL;
      }
      else {
        uint64_t v36 = v34;
      }
      if (v36) {
        unint64_t v37 = (char *)operator new(v36);
      }
      else {
        unint64_t v37 = 0LL;
      }
      unint64_t v38 = &v37[v33];
      unint64_t v39 = &v37[v33];
      char *v39 = 0;
      uint64_t v31 = v39 + 1;
      if (v30 != (char *)v32)
      {
        char v40 = &v30[~v32];
        do
        {
          uint64_t v41 = *--v30;
          (v40--)[(void)v37] = v41;
        }

        while (v30 != (char *)v32);
        uint64_t v30 = v55;
        unint64_t v38 = v37;
      }

      uint64_t v55 = v38;
      uint64_t v56 = v31;
      unint64_t v57 = &v37[v36];
      if (v30) {
        operator delete(v30);
      }
    }

    else
    {
      *uint64_t v56 = 0;
      uint64_t v31 = v30 + 1;
    }

    size_t v5 = (v5 + 1);
    uint64_t v56 = v31;
  }

  while ((v9 & 1) != 0 && (int)v6 < (int)v5);
LABEL_100:
  sub_10002AF44((uint64_t)a2);
  if (v46) {
    (*(void (**)(uint64_t))(*(void *)v46 + 8LL))(v46);
  }
  uint64_t v49 = off_1000D0BA0;
  v50[0] = off_1000D0BC8;
  sub_10002B998(v51);
  sub_10002C34C(v53);
  if (v55)
  {
    uint64_t v56 = v55;
    operator delete(v55);
  }

    *a3 = v17;
    return v5;
  }

  if (v7 >= v6)
  {
    *a3 = a2;
    *a4 = a2;
    return a4;
  }

  int v11 = a2[1];
  if (v11)
  {
    BOOL v12 = (void *)a2[1];
    do
    {
      a4 = v12;
      BOOL v12 = (void *)*v12;
    }

    while (v12);
  }

  else
  {
    size_t v19 = a2;
    do
    {
      a4 = (void *)v19[2];
      uint64_t v14 = *a4 == (void)v19;
      size_t v19 = a4;
    }

    while (!v14);
  }

  if (a4 != v5 && v6 >= a4[4])
  {
    int v20 = (void *)*v5;
    if (*v5)
    {
      do
      {
        while (1)
        {
          char v21 = v20;
          int v22 = v20[4];
          if (v6 >= v22) {
            break;
          }
          int v20 = (void *)*v21;
          size_t v5 = v21;
          if (!*v21) {
            goto LABEL_48;
          }
        }

        if (v22 >= v6) {
          break;
        }
        size_t v5 = v21 + 1;
        int v20 = (void *)v21[1];
      }

      while (v20);
    }

    else
    {
      char v21 = a1 + 1;
    }

unsigned __int8 *sub_10001C024( uint64_t a1, unsigned __int8 *a2, unsigned __int8 *a3, uint64_t a4, int a5, int a6)
{
  if (a2 == a3) {
    return a2;
  }
  int v6 = a6;
  int v7 = a5;
  uint64_t v10 = a1;
  int v11 = *(_DWORD *)(a1 + 24) & 0x1F0;
  int v12 = (char)*a2;
  if (v12 > 62)
  {
    if (v12 == 63)
    {
      int v13 = a2 + 1;
      if (v11) {
        BOOL v20 = 1;
      }
      else {
        BOOL v20 = v13 == a3;
      }
      if (!v20 && *v13 == 63)
      {
        int v13 = a2 + 2;
        uint64_t v14 = 0LL;
        uint64_t v18 = 1LL;
        goto LABEL_33;
      }

      uint64_t v14 = 0LL;
      uint64_t v18 = 1LL;
      goto LABEL_45;
    }

    if (v12 != 123) {
      return a2;
    }
    BOOL v15 = a2 + 1;
    uint64_t v16 = sub_100021B38(a1, a2 + 1, a3, &v28);
    if (v16 != v15)
    {
      if (v16 != a3)
      {
        int v17 = (char)*v16;
        if (v17 != 44)
        {
          if (v17 == 125)
          {
            int v13 = v16 + 1;
            if (!v11 && v13 != a3 && *v13 == 63)
            {
              int v13 = v16 + 2;
              uint64_t v14 = v28;
              a5 = v7;
              a6 = v6;
              a1 = v10;
              uint64_t v18 = v28;
LABEL_33:
              uint64_t v21 = a4;
              char v22 = 0;
LABEL_46:
              sub_100021A04(a1, v14, v18, v21, a5, a6, v22);
              return v13;
            }

            uint64_t v14 = v28;
            a5 = v7;
            a6 = v6;
            a1 = v10;
            uint64_t v18 = v28;
LABEL_45:
            uint64_t v21 = a4;
            char v22 = 1;
            goto LABEL_46;
          }

          goto LABEL_58;
        }

        double v23 = v16 + 1;
        if (v16 + 1 == a3) {
          goto LABEL_58;
        }
        if (*v23 == 125)
        {
          int v13 = v16 + 2;
          if (!v11 && v13 != a3 && *v13 == 63)
          {
            int v13 = v16 + 3;
            uint64_t v14 = v28;
            a5 = v7;
            a6 = v6;
            a1 = v10;
            goto LABEL_26;
          }

          uint64_t v14 = v28;
          a5 = v7;
          a6 = v6;
          a1 = v10;
LABEL_36:
          uint64_t v18 = -1LL;
          goto LABEL_45;
        }

        int v27 = -1;
        __int128 v25 = sub_100021B38(v10, v23, a3, &v27);
        if (v25 != v23 && v25 != a3 && *v25 == 125)
        {
          uint64_t v18 = v27;
          uint64_t v14 = v28;
          if (v27 >= v28)
          {
            int v13 = v25 + 1;
            char v22 = 1;
            if (!v11 && v13 != a3)
            {
              int v26 = v25[1];
              char v22 = v26 != 63;
              if (v26 == 63) {
                int v13 = v25 + 2;
              }
            }

            a5 = v7;
            a6 = v6;
            a1 = v10;
            uint64_t v21 = a4;
            goto LABEL_46;
          }

          goto LABEL_58;
        }
      }

      sub_100021C20();
    }

LABEL_58:
    sub_100021BD4();
  }

  if (v12 == 42)
  {
    int v13 = a2 + 1;
    if (v11) {
      BOOL v19 = 1;
    }
    else {
      BOOL v19 = v13 == a3;
    }
    if (!v19 && *v13 == 63)
    {
      int v13 = a2 + 2;
      uint64_t v14 = 0LL;
      goto LABEL_26;
    }

    uint64_t v14 = 0LL;
    goto LABEL_36;
  }

  if (v12 == 43)
  {
    int v13 = a2 + 1;
    if (!v11 && v13 != a3 && *v13 == 63)
    {
      int v13 = a2 + 2;
      uint64_t v14 = 1LL;
LABEL_26:
      uint64_t v18 = -1LL;
      goto LABEL_33;
    }

    uint64_t v14 = 1LL;
    goto LABEL_36;
  }

  return a2;
}

      uint64_t v9 = *((void *)&v57 + 1);
    }

    while (*((void *)&v57 + 1));
    if ((a3 & 1) != 0) {
      break;
    }
LABEL_62:
    if ((_DWORD)v7 == v47) {
      int v7 = 0LL;
    }
    else {
      int v7 = (v7 + 1);
    }
    if ((int)v7 < (int)v6)
    {
      xpc_object_t v29 = &v58[(int)v7];
      uint64_t v30 = (int)v6 - (uint64_t)(int)v7;
      while (*v29++)
      {
        int v7 = (v7 + 1);
        if (!--v30)
        {
          int v7 = v6;
          break;
        }
      }
    }

    if (v46 || (_DWORD)v7 != (_DWORD)v6) {
      continue;
    }
LABEL_72:
    if (v49)
    {
      if (v49)
      {
        uint64_t v32 = (*(uint64_t (**)(uint64_t))(*(void *)v49 + 24LL))(v49);
        goto LABEL_78;
      }
    }

    else if (v51 >= v50)
    {
      continue;
    }

    uint64_t v32 = v51;
LABEL_78:
    if (v32 != (_DWORD)v6)
    {
      if (v49) {
        (*(void (**)(uint64_t))(*(void *)v49 + 32LL))(v49);
      }
      else {
        ++v51;
      }
      goto LABEL_72;
    }

    unint64_t v33 = v59;
    if (v59 >= v60)
    {
      std::string v35 = (unint64_t)v58;
      uint64_t v36 = v59 - v58;
      unint64_t v37 = v59 - v58 + 1;
      if (v37 < 0) {
        sub_100018774();
      }
      unint64_t v38 = v60 - v58;
      if (v38 >= 0x3FFFFFFFFFFFFFFFLL) {
        unint64_t v39 = 0x7FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v39 = v37;
      }
      if (v39) {
        char v40 = operator new(v39);
      }
      else {
        char v40 = 0LL;
      }
      uint64_t v41 = &v40[v36];
      uint64_t v42 = &v40[v36];
      *uint64_t v42 = 0;
      unint64_t v34 = v42 + 1;
      if (v33 != (char *)v35)
      {
        unint64_t v43 = &v33[~v35];
        do
        {
          char v44 = *--v33;
          (v43--)[(void)v40] = v44;
        }

        while (v33 != (char *)v35);
        unint64_t v33 = v58;
        uint64_t v41 = v40;
      }

      uint64_t v58 = v41;
      uint64_t v59 = v34;
      uint64_t v60 = &v40[v39];
      if (v33) {
        operator delete(v33);
      }
    }

    else
    {
      *uint64_t v59 = 0;
      unint64_t v34 = v33 + 1;
    }

    int v6 = (v6 + 1);
    uint64_t v59 = v34;
    a3 = v45;
  }

  while ((v10 & 1) != 0 && (int)v7 < (int)v6);
LABEL_102:
  sub_10007ED84((char ***)a2);
  if (v49) {
    (*(void (**)(uint64_t))(*(void *)v49 + 8LL))(v49);
  }
  unint64_t v52 = off_1000D0BA0;
  v53[0] = off_1000D0BC8;
  sub_10002B998(v54);
  sub_10002C34C(v56);
  if (v58)
  {
    uint64_t v59 = v58;
    operator delete(v58);
  }

      uint64_t v9 = *((void *)&v57 + 1);
    }

    while (*((void *)&v57 + 1));
    if ((a3 & 1) != 0) {
      break;
    }
LABEL_62:
    if ((_DWORD)v7 == v47) {
      int v7 = 0LL;
    }
    else {
      int v7 = (v7 + 1);
    }
    if ((int)v7 < (int)v6)
    {
      xpc_object_t v29 = &v58[(int)v7];
      uint64_t v30 = (int)v6 - (uint64_t)(int)v7;
      while (*v29++)
      {
        int v7 = (v7 + 1);
        if (!--v30)
        {
          int v7 = v6;
          break;
        }
      }
    }

    if (v46 || (_DWORD)v7 != (_DWORD)v6) {
      continue;
    }
LABEL_72:
    if (v49)
    {
      if (v49)
      {
        uint64_t v32 = (*(uint64_t (**)(uint64_t))(*(void *)v49 + 24LL))(v49);
        goto LABEL_78;
      }
    }

    else if (v51 >= v50)
    {
      continue;
    }

    uint64_t v32 = v51;
LABEL_78:
    if (v32 != (_DWORD)v6)
    {
      if (v49) {
        (*(void (**)(uint64_t))(*(void *)v49 + 32LL))(v49);
      }
      else {
        ++v51;
      }
      goto LABEL_72;
    }

    unint64_t v33 = v59;
    if (v59 >= v60)
    {
      std::string v35 = (unint64_t)v58;
      uint64_t v36 = v59 - v58;
      unint64_t v37 = v59 - v58 + 1;
      if (v37 < 0) {
        sub_100018774();
      }
      unint64_t v38 = v60 - v58;
      if (v38 >= 0x3FFFFFFFFFFFFFFFLL) {
        unint64_t v39 = 0x7FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v39 = v37;
      }
      if (v39) {
        char v40 = operator new(v39);
      }
      else {
        char v40 = 0LL;
      }
      uint64_t v41 = &v40[v36];
      uint64_t v42 = &v40[v36];
      *uint64_t v42 = 0;
      unint64_t v34 = v42 + 1;
      if (v33 != (char *)v35)
      {
        unint64_t v43 = &v33[~v35];
        do
        {
          char v44 = *--v33;
          (v43--)[(void)v40] = v44;
        }

        while (v33 != (char *)v35);
        unint64_t v33 = v58;
        uint64_t v41 = v40;
      }

      uint64_t v58 = v41;
      uint64_t v59 = v34;
      uint64_t v60 = &v40[v39];
      if (v33) {
        operator delete(v33);
      }
    }

    else
    {
      *uint64_t v59 = 0;
      unint64_t v34 = v33 + 1;
    }

    int v6 = (v6 + 1);
    uint64_t v59 = v34;
    a3 = v45;
  }

  while ((v10 & 1) != 0 && (int)v7 < (int)v6);
LABEL_102:
  sub_10007ED84((char ***)a2);
  if (v49) {
    (*(void (**)(uint64_t))(*(void *)v49 + 8LL))(v49);
  }
  unint64_t v52 = off_1000D0BA0;
  v53[0] = off_1000D0BC8;
  sub_10002B998(v54);
  sub_10002C34C(v56);
  if (v58)
  {
    uint64_t v59 = v58;
    operator delete(v58);
  }

__n128 sub_10001C324(uint64_t a1, char a2)
{
  __int128 v4 = (char *)operator new(0x30uLL);
  uint64_t v5 = *(void *)(*(void *)(a1 + 56) + 8LL);
  *(void *)__int128 v4 = off_1000CE630;
  *((void *)v4 + 1) = v5;
  std::locale::locale((std::locale *)v4 + 2, (const std::locale *)a1);
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v4 + 24) = result;
  v4[40] = a2;
  *(void *)(*(void *)(a1 + 56) + 8LL) = v4;
  *(void *)(a1 + 56) = *(void *)(*(void *)(a1 + 56) + 8LL);
  return result;
}

uint64_t sub_10001C398(uint64_t a1, uint64_t a2, char a3, int a4)
{
  uint64_t v8 = operator new(0x58uLL);
  uint64_t result = sub_10001C7EC((uint64_t)v8, a2, a3, *(void *)(*(void *)(a1 + 56) + 8LL), a4);
  *(void *)(*(void *)(a1 + 56) + 8LL) = v8;
  *(void *)(a1 + 56) = *(void *)(*(void *)(a1 + 56) + 8LL);
  return result;
}

void sub_10001C408(_Unwind_Exception *a1)
{
}

void sub_10001C41C()
{
  exception = (std::regex_error *)__cxa_allocate_exception(0x18uLL);
  std::regex_error::regex_error(exception, error_paren);
}

void sub_10001C454(_Unwind_Exception *a1)
{
}

void *sub_10001C468(void *a1)
{
  *a1 = &off_1000CE570;
  uint64_t v2 = a1[1];
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8LL))(v2);
  }
  return a1;
}

void sub_10001C4AC(void *__p)
{
  *std::string __p = &off_1000CE570;
  uint64_t v2 = __p[1];
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8LL))(v2);
  }
  operator delete(__p);
}

uint64_t sub_10001C4F0(uint64_t result, uint64_t a2)
{
  if (*(_BYTE *)(a2 + 92))
  {
    if (*(void *)(a2 + 16) != *(void *)(a2 + 8) || (*(_BYTE *)(a2 + 88) & 1) != 0)
    {
LABEL_12:
      uint64_t v4 = 0LL;
      *(_DWORD *)a2 = -993;
      goto LABEL_13;
    }
  }

  else
  {
    if (!*(_BYTE *)(result + 16)) {
      goto LABEL_12;
    }
    int v2 = *(unsigned __int8 *)(*(void *)(a2 + 16) - 1LL);
    if (v2 != 13 && v2 != 10) {
      goto LABEL_12;
    }
  }

  *(_DWORD *)a2 = -994;
  uint64_t v4 = *(void *)(result + 8);
LABEL_13:
  *(void *)(a2 + 8sub_10001AFB0((std::locale *)v24, " +$", 0) = v4;
  return result;
}

void *sub_10001C550(void *a1)
{
  *a1 = &off_1000CE570;
  uint64_t v2 = a1[1];
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8LL))(v2);
  }
  return a1;
}

void sub_10001C594(void *__p)
{
  *std::string __p = &off_1000CE570;
  uint64_t v2 = __p[1];
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8LL))(v2);
  }
  operator delete(__p);
}

uint64_t sub_10001C5D8(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(unsigned __int8 **)(a2 + 16);
  if (v2 == *(unsigned __int8 **)(a2 + 24) && (*(_BYTE *)(a2 + 88) & 2) == 0
    || *(_BYTE *)(result + 16) && ((int v3 = *v2, v3 != 13) ? (v4 = v3 == 10) : (v4 = 1), v4))
  {
    *(_DWORD *)a2 = -994;
    uint64_t v5 = *(void *)(result + 8);
  }

  else
  {
    uint64_t v5 = 0LL;
    *(_DWORD *)a2 = -993;
  }

  *(void *)(a2 + 8sub_10001AFB0((std::locale *)v24, " +$", 0) = v5;
  return result;
}

std::locale *sub_10001C628(std::locale *a1)
{
  a1->__locale_ = (std::locale::__imp *)off_1000CE630;
  std::locale::~locale(a1 + 2);
  a1->__locale_ = (std::locale::__imp *)&off_1000CE570;
  locale = a1[1].__locale_;
  if (locale) {
    (*(void (**)(std::locale::__imp *))(*(void *)locale + 8LL))(locale);
  }
  return a1;
}

void sub_10001C680(std::locale *a1)
{
  a1->__locale_ = (std::locale::__imp *)off_1000CE630;
  std::locale::~locale(a1 + 2);
  a1->__locale_ = (std::locale::__imp *)&off_1000CE570;
  locale = a1[1].__locale_;
  if (locale) {
    (*(void (**)(std::locale::__imp *))(*(void *)locale + 8LL))(locale);
  }
  operator delete(a1);
}

uint64_t sub_10001C6D8(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(unsigned __int8 **)(a2 + 8);
  int v3 = *(unsigned __int8 **)(a2 + 24);
  if (v2 == v3) {
    goto LABEL_17;
  }
  BOOL v4 = *(unsigned __int8 **)(a2 + 16);
  if (v4 == v3)
  {
    if ((*(_BYTE *)(a2 + 88) & 8) == 0)
    {
      uint64_t v6 = *(v3 - 1);
      goto LABEL_13;
    }

LABEL_17:
    int v10 = 0;
    goto LABEL_25;
  }

  if (v4 == v2)
  {
    int v5 = *(_DWORD *)(a2 + 88);
    if ((v5 & 0x80) == 0)
    {
      if ((v5 & 4) == 0)
      {
        uint64_t v6 = *v2;
LABEL_13:
        if (v6 == 95
          || (v6 & 0x80) == 0 && (*(_DWORD *)(*(void *)(*(void *)(result + 24) + 16LL) + 4 * v6) & 0x500) != 0)
        {
          int v10 = 1;
          goto LABEL_25;
        }

        goto LABEL_17;
      }

      goto LABEL_17;
    }
  }

  uint64_t v7 = *(v4 - 1);
  uint64_t v8 = *v4;
  int v9 = v7 == 95 || (v7 & 0x80) == 0 && (*(_DWORD *)(*(void *)(*(void *)(result + 24) + 16LL) + 4 * v7) & 0x500) != 0;
  int v11 = (_DWORD)v8 == 95
     || (v8 & 0x80) == 0 && (*(_DWORD *)(*(void *)(*(void *)(result + 24) + 16LL) + 4 * v8) & 0x500) != 0;
  int v10 = v9 != v11;
LABEL_25:
  if (*(unsigned __int8 *)(result + 40) == v10)
  {
    uint64_t v12 = 0LL;
    int v13 = -993;
  }

  else
  {
    uint64_t v12 = *(void *)(result + 8);
    int v13 = -994;
  }

  *(_DWORD *)a2 = v13;
  *(void *)(a2 + 8sub_10001AFB0((std::locale *)v24, " +$", 0) = v12;
  return result;
}

    v11 += 32LL;
  }

  while (v11 != v12);
  if ((v13 & 1) != 0)
  {
    *(_BYTE *)(a1 + 56) = 1;
    goto LABEL_22;
  }

        int v13 = 0LL;
        int v11 = 0;
        break;
    }

    if (a5) {
      *a5 = v13;
    }
    BOOL v20 = (os_log_s *)RXOSLog();
    if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v21 = [a3 state];
      *(_DWORD *)std::string buf = 134218498;
      if (v11) {
        char v22 = 0LL;
      }
      else {
        char v22 = v13;
      }
      unint64_t v33 = v21;
      unint64_t v34 = 1024;
      std::string v35 = v11;
      uint64_t v36 = 2112;
      unint64_t v37 = v22;
      _os_log_impl( (void *)&_mh_execute_header,  v20,  OS_LOG_TYPE_DEFAULT,  "Asset download state=%ld, success=%d, error=%@",  buf,  0x1Cu);
    }
  }

  return v11;
}

    int v13 = (os_log_s *)RXOSLog();
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
    {
      uint64_t v14 = 134217984;
      BOOL v15 = a2;
      _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_ERROR,  "Deleting live object %llu\n",  (uint8_t *)&v14,  0xCu);
    }
  }

    return 0LL;
  }

  BOOL v4 = -[NSData initWithContentsOfFile:options:error:]( objc_alloc(&OBJC_CLASS___NSData),  "initWithContentsOfFile:options:error:",  v3,  0LL,  &v17);
  if (!v4)
  {
    int v13 = (os_log_s *)RXOSLog();
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)std::string buf = 138412290;
      BOOL v19 = v17;
      uint64_t v14 = "No SpeechProfile cached for SRC : %@";
      goto LABEL_16;
    }

    goto LABEL_17;
  }

  int v5 = v4;
  uint64_t v6 = +[NSPropertyListSerialization propertyListWithData:options:format:error:]( &OBJC_CLASS___NSPropertyListSerialization,  "propertyListWithData:options:format:error:",  v4,  0LL,  0LL,  &v17);

  if (!v6) {
    goto LABEL_17;
  }
  uint64_t v7 = objc_opt_class(&OBJC_CLASS___NSDictionary);
  if ((objc_opt_isKindOfClass(v6, v7) & 1) == 0) {
    goto LABEL_17;
  }
  if ((objc_msgSend(objc_msgSend(v6, "valueForKey:", @"language"), "isEqual:", v2) & 1) == 0)
  {
    uint64_t v8 = (os_log_s *)RXOSLog();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEFAULT,  "readUserProfileFromCache: Mismatch in speech profile language in content and filename",  buf,  2u);
    }
  }

  int v9 = [v6 valueForKey:@"version"];
  if (([v9 isEqual:@"4.0"] & 1) == 0)
  {
    uint64_t v16 = (os_log_s *)RXOSLog();
    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)std::string buf = 138412546;
      BOOL v19 = v9;
      BOOL v20 = 2112;
      uint64_t v21 = @"4.0";
      _os_log_impl( (void *)&_mh_execute_header,  v16,  OS_LOG_TYPE_DEFAULT,  "readUserProfileFromCache: Profile version on disk (%@) does not match the expected version (%@)",  buf,  0x16u);
    }

    return 0LL;
  }

  int v10 = [v6 valueForKey:@"data"];
  if (v10)
  {
    int v11 = (os_log_s *)RXOSLog();
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v12 = [v10 length];
      *(_DWORD *)std::string buf = 134217984;
      BOOL v19 = v12;
      _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_DEFAULT,  "Deserialization of user profile done with size=%lu",  buf,  0xCu);
    }
  }

  return v10;
}

uint64_t sub_10001C7EC(uint64_t a1, uint64_t a2, char a3, uint64_t a4, int a5)
{
  *(void *)a1 = off_1000CE678;
  *(void *)(a1 + _Block_object_dispose(va, 8) = a4;
  std::locale::locale((std::locale *)(a1 + 16), (const std::locale *)a2);
  *(_OWORD *)(a1 + 24) = *(_OWORD *)(a2 + 8);
  *(_OWORD *)(a1 + 4sub_10001AFB0((std::locale *)v24, " +$", 0) = *(_OWORD *)(a2 + 24);
  uint64_t v9 = *(void *)(a2 + 48);
  *(void *)(a1 + 56) = *(void *)(a2 + 40);
  *(void *)(a1 + 64) = v9;
  if (v9)
  {
    int v10 = (unint64_t *)(v9 + 8);
    do
      unint64_t v11 = __ldxr(v10);
    while (__stxr(v11 + 1, v10));
  }

  *(void *)(a1 + 72) = *(void *)(a2 + 56);
  *(_DWORD *)(a1 + 8sub_10001AFB0((std::locale *)v24, " +$", 0) = a5;
  *(_BYTE *)(a1 + 84) = a3;
  return a1;
}

std::locale *sub_10001C878(std::locale *a1)
{
  a1->__locale_ = (std::locale::__imp *)off_1000CE678;
  uint64_t v2 = a1 + 2;
  sub_100017FC4((uint64_t)&a1[7]);
  std::locale::~locale(v2);
  a1->__locale_ = (std::locale::__imp *)&off_1000CE570;
  locale = a1[1].__locale_;
  if (locale) {
    (*(void (**)(std::locale::__imp *))(*(void *)locale + 8LL))(locale);
  }
  return a1;
}

void sub_10001C8E0(std::locale *a1)
{
  a1->__locale_ = (std::locale::__imp *)off_1000CE678;
  uint64_t v2 = a1 + 2;
  sub_100017FC4((uint64_t)&a1[7]);
  std::locale::~locale(v2);
  a1->__locale_ = (std::locale::__imp *)&off_1000CE570;
  locale = a1[1].__locale_;
  if (locale) {
    (*(void (**)(std::locale::__imp *))(*(void *)locale + 8LL))(locale);
  }
  operator delete(a1);
}

void sub_10001C948(uint64_t a1, uint64_t a2)
{
  uint64_t v23 = 0LL;
  uint64_t v24 = 0LL;
  char v25 = 0;
  __int128 v26 = 0uLL;
  char v27 = 0;
  char v28 = 0;
  uint64_t v29 = 0LL;
  std::string __p = 0LL;
  BOOL v19 = 0LL;
  unint64_t v4 = (*(_DWORD *)(a1 + 44) + 1);
  uint64_t v6 = *(void *)(a2 + 16);
  uint64_t v5 = *(void *)(a2 + 24);
  uint64_t v20 = 0LL;
  *(void *)&__int128 v21 = v5;
  *((void *)&v21 + 1) = v5;
  char v22 = 0;
  sub_10001CF40((char **)&__p, v4, &v21);
  uint64_t v23 = v6;
  uint64_t v24 = v6;
  char v25 = 0;
  __int128 v26 = v21;
  char v27 = v22;
  uint64_t v29 = v6;
  char v28 = 1;
  uint64_t v7 = *(void *)(a2 + 16);
  if (*(_BYTE *)(a2 + 92)) {
    BOOL v8 = v7 == *(void *)(a2 + 8);
  }
  else {
    BOOL v8 = 0;
  }
  char v9 = v8;
  if (*(unsigned __int8 *)(a1 + 84) == sub_10001CB40( a1 + 16,  v7,  *(void *)(a2 + 24),  (uint64_t *)&__p,  *(_DWORD *)(a2 + 88) & 0xFBF | 0x40u,  v9))
  {
    *(_DWORD *)a2 = -993;
    *(void *)(a2 + 8sub_10001AFB0((std::locale *)v24, " +$", 0) = 0LL;
    int v10 = (char *)__p;
    goto LABEL_13;
  }

  *(_DWORD *)a2 = -994;
  *(void *)(a2 + 8sub_10001AFB0((std::locale *)v24, " +$", 0) = *(void *)(a1 + 8);
  int v10 = (char *)__p;
  unint64_t v11 = 0xAAAAAAAAAAAAAAABLL * ((v19 - (_BYTE *)__p) >> 3);
  if (v11 < 2)
  {
LABEL_13:
    if (!v10) {
      return;
    }
    goto LABEL_14;
  }

  int v12 = 0;
  int v13 = *(_DWORD *)(a1 + 80);
  uint64_t v14 = *(void *)(a2 + 32);
  unint64_t v15 = 1LL;
  do
  {
    uint64_t v16 = &v10[24 * v15];
    uint64_t v17 = v14 + 24LL * (v13 + v12);
    *(_OWORD *)uint64_t v17 = *(_OWORD *)v16;
    *(_BYTE *)(v17 + 16) = v16[16];
    unint64_t v15 = (v12 + 2);
    ++v12;
  }

  while (v11 > v15);
LABEL_14:
  BOOL v19 = v10;
  operator delete(v10);
}

void sub_10001CAB0( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

char *sub_10001CAD0(uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4, char a5)
{
  *(void *)(a1 + 24) = a4;
  BOOL v8 = (_OWORD *)(a1 + 24);
  *(void *)(a1 + 32) = a4;
  *(_BYTE *)(a1 + 4sub_10001AFB0((std::locale *)v24, " +$", 0) = 0;
  uint64_t result = sub_10001CF40((char **)a1, a2, (__int128 *)(a1 + 24));
  *(void *)(a1 + 4_Block_object_dispose(va, 8) = a3;
  *(void *)(a1 + 56) = a3;
  *(_BYTE *)(a1 + 64) = 0;
  *(_OWORD *)(a1 + 72) = *v8;
  *(_BYTE *)(a1 + 8_Block_object_dispose(va, 8) = *(_BYTE *)(a1 + 40);
  if ((a5 & 1) == 0) {
    *(void *)(a1 + 104) = a3;
  }
  *(_BYTE *)(a1 + 96) = 1;
  return result;
}

uint64_t sub_10001CB40(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4, int a5, char a6)
{
  uint64_t v42 = 0LL;
  unint64_t v43 = 0LL;
  unint64_t v44 = 0LL;
  uint64_t v6 = *(void *)(a1 + 40);
  if (v6)
  {
    *(void *)&__int128 v40 = a3;
    *((void *)&v40 + 1) = a3;
    char v41 = 0;
    *(_DWORD *)unint64_t v37 = 0;
    memset(&v37[8], 0, 48);
    *(_OWORD *)std::string __p = 0u;
    memset(v39, 0, 21);
    unint64_t v43 = (_OWORD *)sub_10001D1F8((uint64_t *)&v42, (uint64_t)v37);
    if (__p[0])
    {
      __p[1] = __p[0];
      operator delete(__p[0]);
    }

    if (*(void *)&v37[32])
    {
      *(void *)&v37[40] = *(void *)&v37[32];
      operator delete(*(void **)&v37[32]);
    }

    unint64_t v34 = a4;
    unint64_t v11 = v43;
    *((_DWORD *)v43 - 24) = 0;
    *((void *)v11 - 11) = a2;
    *((void *)v11 - 1sub_10001AFB0((std::locale *)v24, " +$", 0) = a2;
    *((void *)v11 - 9) = a3;
    sub_10001D0F4((uint64_t)(v11 - 4), *(unsigned int *)(a1 + 28), &v40);
    sub_10001D130((uint64_t)v43 - 40, *(unsigned int *)(a1 + 32));
    int v12 = v43;
    *((void *)v43 - 2) = v6;
    *((_DWORD *)v12 - 2) = a5;
    *((_BYTE *)v12 - 4) = a6;
    unsigned int v13 = 1;
    while (2)
    {
      unint64_t v15 = v12 - 1;
      uint64_t v14 = *((void *)v12 - 2);
      uint64_t v16 = v12 - 6;
      if (v14) {
        (*(void (**)(uint64_t, _OWORD *))(*(void *)v14 + 16LL))(v14, v12 - 6);
      }
      switch(*(_DWORD *)v16)
      {
        case 0xFFFFFC18:
          uint64_t v17 = *((void *)v12 - 10);
          if ((a5 & 0x20) != 0 && v17 == a2 || (a5 & 0x1000) != 0 && v17 != a3) {
            goto LABEL_16;
          }
          uint64_t v25 = *v34;
          *(void *)uint64_t v25 = a2;
          *(void *)(v25 + _Block_object_dispose(va, 8) = v17;
          *(_BYTE *)(v25 + 16) = 1;
          uint64_t v26 = *((void *)v12 - 8);
          uint64_t v27 = *((void *)v12 - 7) - v26;
          if (v27)
          {
            unint64_t v28 = 0xAAAAAAAAAAAAAAABLL * (v27 >> 3);
            uint64_t v29 = (_BYTE *)(v26 + 16);
            unsigned int v30 = 1;
            do
            {
              uint64_t v31 = v25 + 24LL * v30;
              *(_OWORD *)uint64_t v31 = *((_OWORD *)v29 - 1);
              char v32 = *v29;
              v29 += 24;
              *(_BYTE *)(v31 + 16) = v32;
            }

            while (v28 > v30++);
          }

          uint64_t v6 = 1LL;
          break;
        case 0xFFFFFC1D:
        case 0xFFFFFC1E:
        case 0xFFFFFC21:
          goto LABEL_23;
        case 0xFFFFFC1F:
LABEL_16:
          uint64_t v18 = v43 - 6;
          sub_10001D560((uint64_t)&v44, (void *)v43 - 12);
          unint64_t v43 = v18;
          goto LABEL_23;
        case 0xFFFFFC20:
          __int128 v19 = *(v12 - 5);
          *(_OWORD *)unint64_t v37 = *v16;
          *(_OWORD *)&v37[16] = v19;
          memset(&v37[32], 0, 24);
          sub_10001D898( &v37[32],  *((__int128 **)v12 - 8),  *((__int128 **)v12 - 7),  0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*((void *)v12 - 7) - *((void *)v12 - 8)) >> 3));
          __p[0] = 0LL;
          __p[1] = 0LL;
          v39[0] = 0LL;
          sub_10001D914( (char *)__p,  *((__int128 **)v12 - 5),  *((__int128 **)v12 - 4),  (uint64_t)(*((void *)v12 - 4) - *((void *)v12 - 5)) >> 4);
          uint64_t v20 = *v15;
          *(void *)((char *)&v39[1] + 5) = *(void *)((char *)v12 - 11);
          v39[1] = v20;
          (*(void (**)(void, uint64_t, _OWORD *))(*(void *)*v15 + 24LL))(*v15, 1LL, v12 - 6);
          (*(void (**)(void, void, _BYTE *))(*(void *)v39[1] + 24LL))(v39[1], 0LL, v37);
          __int128 v21 = v43;
          if ((unint64_t)v43 >= v44)
          {
            unint64_t v43 = (_OWORD *)sub_10001D1F8((uint64_t *)&v42, (uint64_t)v37);
            if (__p[0])
            {
              __p[1] = __p[0];
              operator delete(__p[0]);
            }
          }

          else
          {
            __int128 v22 = *(_OWORD *)&v37[16];
            _OWORD *v43 = *(_OWORD *)v37;
            v21[1] = v22;
            *((void *)v21 + 4) = 0LL;
            *((void *)v21 + 5) = 0LL;
            *((void *)v21 + 6) = 0LL;
            *((void *)v21 + 7) = 0LL;
            v21[2] = *(_OWORD *)&v37[32];
            *((void *)v21 + 6) = *(void *)&v37[48];
            memset(&v37[32], 0, 24);
            *((void *)v21 + _Block_object_dispose(va, 8) = 0LL;
            *((void *)v21 + 9) = 0LL;
            *(_OWORD *)((char *)v21 + 56) = *(_OWORD *)__p;
            *((void *)v21 + 9) = v39[0];
            __p[0] = 0LL;
            __p[1] = 0LL;
            v39[0] = 0LL;
            uint64_t v23 = v39[1];
            *(void *)((char *)v21 + 85) = *(void *)((char *)&v39[1] + 5);
            *((void *)v21 + 1sub_10001AFB0((std::locale *)v24, " +$", 0) = v23;
            unint64_t v43 = v21 + 6;
          }

          if (*(void *)&v37[32])
          {
            *(void *)&v37[40] = *(void *)&v37[32];
            operator delete(*(void **)&v37[32]);
          }

LABEL_23:
          int v12 = v43;
          ++v13;
          if (v42 != v43) {
            continue;
          }
          uint64_t v6 = 0LL;
          break;
        default:
          sub_10001D1AC();
      }

      break;
    }
  }

  *(void *)unint64_t v37 = &v42;
  sub_10001D9C4((void ***)v37);
  return v6;
}

    *(_DWORD *)a2 = -992;
    return result;
  }

  *(_DWORD *)a2 = -994;
LABEL_25:
  a2[10] = *((void *)result + 2);
  return result;
}

    uint64_t v16 = (v25 - 1) & v25;
    __int128 v22 = __clz(__rbit64(v25)) + (v19 << 6);
LABEL_24:
    uint64_t v27 = *(void *)(v7 + 72);
    unint64_t v28 = *(void *)(v10 + 48) + v27 * v22;
    if ((v45 & 1) != 0)
    {
      (*(void (**)(char *, unint64_t, uint64_t))(v7 + 32))(v9, v28, v6);
      uint64_t v29 = *(void *)(*(void *)(v10 + 56) + 8 * v22);
    }

    else
    {
      (*(void (**)(char *, unint64_t, uint64_t))(v7 + 16))(v9, v28, v6);
      uint64_t v29 = *(void *)(*(void *)(v10 + 56) + 8 * v22);
      swift_bridgeObjectRetain(v29);
    }

    unsigned int v30 = *(void *)(v12 + 40);
    uint64_t v31 = sub_100058894( &qword_1000DDA48,  (uint64_t (*)(uint64_t))&type metadata accessor for AnalysisContext.ContextualStringsTag,  (uint64_t)&protocol conformance descriptor for AnalysisContext.ContextualStringsTag);
    uint64_t result = dispatch thunk of Hashable._rawHashValue(seed:)(v30, v6, v31);
    char v32 = -1LL << *(_BYTE *)(v12 + 32);
    unint64_t v33 = result & ~v32;
    unint64_t v34 = v33 >> 6;
    if (((-1LL << v33) & ~*(void *)(v17 + 8 * (v33 >> 6))) != 0)
    {
      uint64_t v20 = __clz(__rbit64((-1LL << v33) & ~*(void *)(v17 + 8 * (v33 >> 6)))) | v33 & 0x7FFFFFFFFFFFFFC0LL;
    }

    else
    {
      std::string v35 = 0;
      uint64_t v36 = (unint64_t)(63 - v32) >> 6;
      do
      {
        if (++v34 == v36 && (v35 & 1) != 0)
        {
          __break(1u);
          goto LABEL_44;
        }

        unint64_t v37 = v34 == v36;
        if (v34 == v36) {
          unint64_t v34 = 0LL;
        }
        v35 |= v37;
        unint64_t v38 = *(void *)(v17 + 8 * v34);
      }

      while (v38 == -1);
      uint64_t v20 = __clz(__rbit64(~v38)) + (v34 << 6);
    }

    *(void *)(v17 + ((v20 >> 3) & 0x1FFFFFFFFFFFFFF8LL)) |= 1LL << v20;
    uint64_t result = (*(uint64_t (**)(unint64_t, char *, uint64_t))(v7 + 32))( *(void *)(v12 + 48) + v27 * v20,  v9,  v6);
    *(void *)(*(void *)(v12 + 56) + 8 * v2sub_10001AFB0((std::locale *)v24, " +$", 0) = v29;
    ++*(void *)(v12 + 16);
  }

  swift_release(v10);
  int v3 = v41;
  uint64_t v24 = v43;
  if ((v45 & 1) == 0) {
    goto LABEL_43;
  }
LABEL_39:
  unint64_t v39 = 1LL << *(_BYTE *)(v10 + 32);
  if (v39 >= 64) {
    bzero(v24, ((unint64_t)(v39 + 63) >> 3) & 0x1FFFFFFFFFFFFFF8LL);
  }
  else {
    *uint64_t v24 = -1LL << v39;
  }
  *(void *)(v10 + 16) = 0LL;
LABEL_43:
  uint64_t result = swift_release(v10);
  *int v3 = v12;
  return result;
}

    if (*((void *)&v21 + 1)) {
      --**((_DWORD **)&v21 + 1);
    }
LABEL_25:
    uint64_t v5 = *(float **)v5;
  }

  while (v5);
LABEL_26:
  uint64_t v16 = (void *)*a3;
  uint64_t v14 = a3 + 1;
  unint64_t v15 = v16;
  if (v16 != v14)
  {
    do
    {
      sub_1000951B8((uint64_t)a1, (uint64_t)(v15 + 5));
      uint64_t v17 = (void *)v15[1];
      if (v17)
      {
        do
        {
          uint64_t v18 = v17;
          uint64_t v17 = (void *)*v17;
        }

        while (v17);
      }

      else
      {
        do
        {
          uint64_t v18 = (void *)v15[2];
          unsigned int v13 = *v18 == (void)v15;
          unint64_t v15 = v18;
        }

        while (!v13);
      }

      unint64_t v15 = v18;
    }

    while (v18 != v14);
  }

    if (SHIBYTE(v13) < 0)
    {
      operator delete(__p[0]);
      if ((v8 & 1) != 0) {
        return 0LL;
      }
    }

    else if (v8)
    {
      return 0LL;
    }
  }

  else if (*(_BYTE *)(a1 + 56) && *(_BYTE *)(a2 + 57))
  {
    return 0LL;
  }

  return 1LL;
}

void sub_10001CEE8( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18)
{
  a13 = v18 - 112;
  sub_10001D9C4((void ***)&a13);
  _Unwind_Resume(a1);
}

char *sub_10001CF40(char **a1, unint64_t a2, __int128 *a3)
{
  uint64_t v6 = (uint64_t)a1[2];
  uint64_t result = *a1;
  if (0xAAAAAAAAAAAAAAABLL * ((v6 - (uint64_t)result) >> 3) >= a2)
  {
    unint64_t v15 = a1[1];
    unint64_t v16 = (v15 - result) / 24;
    if (v16 >= a2) {
      uint64_t v17 = a2;
    }
    else {
      uint64_t v17 = (v15 - result) / 24;
    }
    if (v17)
    {
      uint64_t v18 = result;
      do
      {
        *(_OWORD *)uint64_t v18 = *a3;
        v18[16] = *((_BYTE *)a3 + 16);
        v18 += 24;
        --v17;
      }

      while (v17);
    }

    if (a2 <= v16)
    {
      a1[1] = &result[24 * a2];
    }

    else
    {
      __int128 v19 = &v15[24 * (a2 - v16)];
      uint64_t v20 = 24 * a2 - 24 * v16;
      do
      {
        __int128 v21 = *a3;
        *((void *)v15 + 2) = *((void *)a3 + 2);
        *(_OWORD *)unint64_t v15 = v21;
        v15 += 24;
        v20 -= 24LL;
      }

      while (v20);
      a1[1] = v19;
    }
  }

  else
  {
    if (result)
    {
      a1[1] = result;
      operator delete(result);
      uint64_t v6 = 0LL;
      *a1 = 0LL;
      a1[1] = 0LL;
      a1[2] = 0LL;
    }

    if (a2 > 0xAAAAAAAAAAAAAAALL) {
      sub_100018774();
    }
    unint64_t v8 = 0xAAAAAAAAAAAAAAABLL * (v6 >> 3);
    uint64_t v9 = 2 * v8;
    if (2 * v8 <= a2) {
      uint64_t v9 = a2;
    }
    if (v8 >= 0x555555555555555LL) {
      unint64_t v10 = 0xAAAAAAAAAAAAAAALL;
    }
    else {
      unint64_t v10 = v9;
    }
    uint64_t result = sub_100019ABC(a1, v10);
    unint64_t v11 = a1[1];
    int v12 = &v11[24 * a2];
    uint64_t v13 = 24 * a2;
    do
    {
      __int128 v14 = *a3;
      *((void *)v11 + 2) = *((void *)a3 + 2);
      *(_OWORD *)unint64_t v11 = v14;
      v11 += 24;
      v13 -= 24LL;
    }

    while (v13);
    a1[1] = v12;
  }

  return result;
}

void *sub_10001D0B4(void *a1)
{
  uint64_t v2 = (void *)a1[7];
  if (v2)
  {
    a1[8] = v2;
    operator delete(v2);
  }

  int v3 = (void *)a1[4];
  if (v3)
  {
    a1[5] = v3;
    operator delete(v3);
  }

  return a1;
}

void sub_10001D0F4(uint64_t a1, unint64_t a2, __int128 *a3)
{
  unint64_t v3 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a1 + 8) - *(void *)a1) >> 3);
  BOOL v4 = a2 >= v3;
  unint64_t v5 = a2 - v3;
  if (v5 != 0 && v4)
  {
    sub_10001D618((void **)a1, v5, a3);
  }

  else if (!v4)
  {
    *(void *)(a1 + _Block_object_dispose(va, 8) = *(void *)a1 + 24 * a2;
  }

void sub_10001D130(uint64_t a1, unint64_t a2)
{
  unint64_t v2 = (uint64_t)(*(void *)(a1 + 8) - *(void *)a1) >> 4;
  if (a2 <= v2)
  {
    if (a2 < v2) {
      *(void *)(a1 + _Block_object_dispose(va, 8) = *(void *)a1 + 16 * a2;
    }
  }

  else
  {
    sub_10001D78C((void **)a1, a2 - v2);
  }

void sub_10001D160()
{
  exception = (std::regex_error *)__cxa_allocate_exception(0x18uLL);
  std::regex_error::regex_error(exception, error_complexity);
}

void sub_10001D198(_Unwind_Exception *a1)
{
}

void sub_10001D1AC()
{
  exception = (std::regex_error *)__cxa_allocate_exception(0x18uLL);
  std::regex_error::regex_error(exception, __re_err_unknown);
}

void sub_10001D1E4(_Unwind_Exception *a1)
{
}

uint64_t sub_10001D1F8(uint64_t *a1, uint64_t a2)
{
  uint64_t v3 = *a1;
  unint64_t v4 = 0xAAAAAAAAAAAAAAABLL * ((a1[1] - *a1) >> 5);
  unint64_t v5 = v4 + 1;
  if (v4 + 1 > 0x2AAAAAAAAAAAAAALL) {
    sub_100018774();
  }
  uint64_t v7 = (uint64_t)(a1 + 2);
  unint64_t v8 = 0xAAAAAAAAAAAAAAABLL * ((a1[2] - v3) >> 5);
  if (2 * v8 > v5) {
    unint64_t v5 = 2 * v8;
  }
  if (v8 >= 0x155555555555555LL) {
    unint64_t v9 = 0x2AAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v9 = v5;
  }
  v16[4] = a1 + 2;
  if (v9) {
    unint64_t v10 = (char *)sub_10001D3B8(v7, v9);
  }
  else {
    unint64_t v10 = 0LL;
  }
  unint64_t v11 = &v10[96 * v4];
  v16[0] = v10;
  v16[1] = v11;
  v16[3] = &v10[96 * v9];
  __int128 v12 = *(_OWORD *)(a2 + 16);
  *(_OWORD *)unint64_t v11 = *(_OWORD *)a2;
  *((_OWORD *)v11 + 1) = v12;
  *((void *)v11 + 5) = 0LL;
  *((void *)v11 + 6) = 0LL;
  *((void *)v11 + 4) = 0LL;
  *((_OWORD *)v11 + 2) = *(_OWORD *)(a2 + 32);
  *((void *)v11 + 6) = *(void *)(a2 + 48);
  *(void *)(a2 + 32) = 0LL;
  *(void *)(a2 + 4sub_10001AFB0((std::locale *)v24, " +$", 0) = 0LL;
  *(void *)(a2 + 4_Block_object_dispose(va, 8) = 0LL;
  *((void *)v11 + 7) = 0LL;
  *((void *)v11 + _Block_object_dispose(va, 8) = 0LL;
  *((void *)v11 + 9) = 0LL;
  *(_OWORD *)(v11 + 56) = *(_OWORD *)(a2 + 56);
  *((void *)v11 + 9) = *(void *)(a2 + 72);
  *(void *)(a2 + 56) = 0LL;
  *(void *)(a2 + 64) = 0LL;
  *(void *)(a2 + 72) = 0LL;
  uint64_t v13 = *(void *)(a2 + 80);
  *(void *)(v11 + 85) = *(void *)(a2 + 85);
  *((void *)v11 + 1sub_10001AFB0((std::locale *)v24, " +$", 0) = v13;
  v16[2] = v11 + 96;
  sub_10001D344(a1, v16);
  uint64_t v14 = a1[1];
  sub_10001D5A4(v16);
  return v14;
}

void sub_10001D330(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

uint64_t sub_10001D344(uint64_t *a1, void *a2)
{
  uint64_t result = sub_10001D3FC((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

void *sub_10001D3B8(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x2AAAAAAAAAAAAABLL) {
    sub_100017F08();
  }
  return operator new(96 * a2);
}

uint64_t sub_10001D3FC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7 = a7;
  *(void *)&__int128 v15 = a6;
  *((void *)&v15 + 1) = a7;
  __int128 v14 = v15;
  v12[0] = a1;
  v12[1] = &v14;
  v12[2] = &v15;
  if (a3 == a5)
  {
    uint64_t v10 = a6;
  }

  else
  {
    do
    {
      __int128 v8 = *(_OWORD *)(a3 - 80);
      *(_OWORD *)(v7 - 96) = *(_OWORD *)(a3 - 96);
      *(_OWORD *)(v7 - 8sub_10001AFB0((std::locale *)v24, " +$", 0) = v8;
      *(void *)(v7 - 56) = 0LL;
      *(void *)(v7 - 4_Block_object_dispose(va, 8) = 0LL;
      *(void *)(v7 - 64) = 0LL;
      *(_OWORD *)(v7 - 64) = *(_OWORD *)(a3 - 64);
      *(void *)(v7 - 4_Block_object_dispose(va, 8) = *(void *)(a3 - 48);
      *(void *)(a3 - 64) = 0LL;
      *(void *)(a3 - 56) = 0LL;
      *(void *)(a3 - 4_Block_object_dispose(va, 8) = 0LL;
      *(void *)(v7 - 4sub_10001AFB0((std::locale *)v24, " +$", 0) = 0LL;
      *(void *)(v7 - 32) = 0LL;
      *(void *)(v7 - 24) = 0LL;
      *(_OWORD *)(v7 - 4sub_10001AFB0((std::locale *)v24, " +$", 0) = *(_OWORD *)(a3 - 40);
      *(void *)(v7 - 24) = *(void *)(a3 - 24);
      *(void *)(a3 - 4sub_10001AFB0((std::locale *)v24, " +$", 0) = 0LL;
      *(void *)(a3 - 32) = 0LL;
      *(void *)(a3 - 24) = 0LL;
      uint64_t v9 = *(void *)(a3 - 16);
      *(void *)(v7 - 11) = *(void *)(a3 - 11);
      *(void *)(v7 - 16) = v9;
      uint64_t v7 = *((void *)&v15 + 1) - 96LL;
      *((void *)&v15 + 1) -= 96LL;
      a3 -= 96LL;
    }

    while (a3 != a5);
    uint64_t v10 = v15;
  }

  char v13 = 1;
  sub_10001D4DC((uint64_t)v12);
  return v10;
}

uint64_t sub_10001D4DC(uint64_t a1)
{
  if (!*(_BYTE *)(a1 + 24)) {
    sub_10001D510((uint64_t *)a1);
  }
  return a1;
}

void sub_10001D510(uint64_t *a1)
{
  uint64_t v1 = *(void **)(a1[2] + 8);
  unint64_t v2 = *(void **)(a1[1] + 8);
  if (v1 != v2)
  {
    uint64_t v3 = *a1;
    do
    {
      sub_10001D560(v3, v1);
      v1 += 12;
    }

    while (v1 != v2);
  }

void sub_10001D560(uint64_t a1, void *a2)
{
  uint64_t v3 = (void *)a2[7];
  if (v3)
  {
    a2[8] = v3;
    operator delete(v3);
  }

  unint64_t v4 = (void *)a2[4];
  if (v4)
  {
    a2[5] = v4;
    operator delete(v4);
  }

void **sub_10001D5A4(void **a1)
{
  if (*a1) {
    operator delete(*a1);
  }
  return a1;
}

void sub_10001D5D4(void *a1)
{
  uint64_t v2 = a1[1];
  for (uint64_t i = a1[2]; i != v2; uint64_t i = a1[2])
  {
    uint64_t v4 = a1[4];
    a1[2] = i - 96;
    sub_10001D560(v4, (void *)(i - 96));
  }

void sub_10001D618(void **a1, unint64_t a2, __int128 *a3)
{
  __int128 v8 = a1[2];
  uint64_t v6 = (uint64_t)(a1 + 2);
  uint64_t v7 = v8;
  uint64_t v9 = *(void **)(v6 - 8);
  if (0xAAAAAAAAAAAAAAABLL * ((v8 - (_BYTE *)v9) >> 3) >= a2)
  {
    if (a2)
    {
      __int128 v15 = &v9[3 * a2];
      uint64_t v16 = 24 * a2;
      do
      {
        __int128 v17 = *a3;
        v9[2] = *((void *)a3 + 2);
        *(_OWORD *)uint64_t v9 = v17;
        v9 += 3;
        v16 -= 24LL;
      }

      while (v16);
      uint64_t v9 = v15;
    }

    a1[1] = v9;
  }

  else
  {
    unint64_t v10 = 0xAAAAAAAAAAAAAAABLL * (((char *)v9 - (_BYTE *)*a1) >> 3);
    unint64_t v11 = v10 + a2;
    if (v10 + a2 > 0xAAAAAAAAAAAAAAALL) {
      sub_100018774();
    }
    unint64_t v12 = 0xAAAAAAAAAAAAAAABLL * ((v7 - (_BYTE *)*a1) >> 3);
    if (2 * v12 > v11) {
      unint64_t v11 = 2 * v12;
    }
    if (v12 >= 0x555555555555555LL) {
      unint64_t v13 = 0xAAAAAAAAAAAAAAALL;
    }
    else {
      unint64_t v13 = v11;
    }
    if (v13) {
      __int128 v14 = (char *)sub_100018F00(v6, v13);
    }
    else {
      __int128 v14 = 0LL;
    }
    uint64_t v18 = &v14[24 * v10];
    __int128 v19 = &v18[24 * a2];
    uint64_t v20 = 24 * a2;
    __int128 v21 = v18;
    do
    {
      __int128 v22 = *a3;
      *((void *)v21 + 2) = *((void *)a3 + 2);
      *(_OWORD *)__int128 v21 = v22;
      v21 += 24;
      v20 -= 24LL;
    }

    while (v20);
    uint64_t v23 = &v14[24 * v13];
    uint64_t v25 = (char *)*a1;
    uint64_t v24 = (char *)a1[1];
    if (v24 != *a1)
    {
      do
      {
        __int128 v26 = *(_OWORD *)(v24 - 24);
        *((void *)v18 - 1) = *((void *)v24 - 1);
        *(_OWORD *)(v18 - 24) = v26;
        v18 -= 24;
        v24 -= 24;
      }

      while (v24 != v25);
      uint64_t v24 = (char *)*a1;
    }

    *a1 = v18;
    a1[1] = v19;
    a1[2] = v23;
    if (v24) {
      operator delete(v24);
    }
  }

void sub_10001D78C(void **a1, unint64_t a2)
{
  uint64_t v6 = a1[2];
  uint64_t v4 = (uint64_t)(a1 + 2);
  uint64_t v5 = v6;
  uint64_t v7 = *(char **)(v4 - 8);
  if (a2 <= (v6 - v7) >> 4)
  {
    if (a2)
    {
      bzero(*(void **)(v4 - 8), 16 * a2);
      v7 += 16 * a2;
    }

    a1[1] = v7;
  }

  else
  {
    uint64_t v8 = v7 - (_BYTE *)*a1;
    unint64_t v9 = a2 + (v8 >> 4);
    if (v9 >> 60) {
      sub_100018774();
    }
    uint64_t v10 = v8 >> 4;
    uint64_t v11 = v5 - (_BYTE *)*a1;
    if (v11 >> 3 > v9) {
      unint64_t v9 = v11 >> 3;
    }
    else {
      unint64_t v12 = v9;
    }
    if (v12) {
      unint64_t v13 = (char *)sub_1000198A8(v4, v12);
    }
    else {
      unint64_t v13 = 0LL;
    }
    __int128 v14 = &v13[16 * v10];
    __int128 v15 = &v13[16 * v12];
    bzero(v14, 16 * a2);
    uint64_t v16 = &v14[16 * a2];
    uint64_t v18 = (char *)*a1;
    __int128 v17 = (char *)a1[1];
    if (v17 != *a1)
    {
      do
      {
        *((_OWORD *)v14 - 1) = *((_OWORD *)v17 - 1);
        v14 -= 16;
        v17 -= 16;
      }

      while (v17 != v18);
      __int128 v17 = (char *)*a1;
    }

    *a1 = v14;
    a1[1] = v16;
    a1[2] = v15;
    if (v17) {
      operator delete(v17);
    }
  }

char *sub_10001D898(char *result, __int128 *a2, __int128 *a3, unint64_t a4)
{
  if (a4)
  {
    uint64_t v6 = result;
    uint64_t result = sub_100019ABC(result, a4);
    uint64_t v7 = *((void *)v6 + 1);
    while (a2 != a3)
    {
      __int128 v8 = *a2;
      *(void *)(v7 + 16) = *((void *)a2 + 2);
      *(_OWORD *)uint64_t v7 = v8;
      v7 += 24LL;
      a2 = (__int128 *)((char *)a2 + 24);
    }

    *((void *)v6 + 1) = v7;
  }

  return result;
}

void sub_10001D8F8(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + _Block_object_dispose(va, 8) = v3;
    operator delete(v3);
  }

  _Unwind_Resume(exception_object);
}

char *sub_10001D914(char *result, __int128 *a2, __int128 *a3, unint64_t a4)
{
  if (a4)
  {
    uint64_t v6 = result;
    uint64_t result = sub_10001D984(result, a4);
    uint64_t v7 = (_OWORD *)*((void *)v6 + 1);
    while (a2 != a3)
    {
      __int128 v8 = *a2++;
      *v7++ = v8;
    }

    *((void *)v6 + 1) = v7;
  }

  return result;
}

void sub_10001D968(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + _Block_object_dispose(va, 8) = v3;
    operator delete(v3);
  }

  _Unwind_Resume(exception_object);
}

char *sub_10001D984(void *a1, unint64_t a2)
{
  if (a2 >> 60) {
    sub_100018774();
  }
  uint64_t result = (char *)sub_1000198A8((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[16 * v4];
  return result;
}

void sub_10001D9C4(void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = **a1;
  if (v2)
  {
    uint64_t v4 = v1[1];
    uint64_t v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        v4 -= 12;
        sub_10001D560((uint64_t)(v1 + 2), v4);
      }

      while (v4 != v2);
      uint64_t v5 = **a1;
    }

    v1[1] = v2;
    operator delete(v5);
  }

unsigned __int8 *sub_10001DA48(uint64_t a1, unsigned __int8 *a2, unsigned __int8 *a3)
{
  if (a2 == a3 || *a2 != 92) {
    return a2;
  }
  uint64_t v5 = a2 + 1;
  if (a2 + 1 == a3) {
    sub_10001DDFC();
  }
  uint64_t result = sub_10001DE48(a1, a2 + 1, a3);
  if (result == v5)
  {
    uint64_t result = (unsigned __int8 *)sub_10001DF04(a1, (char *)a2 + 1, (char *)a3);
    if (result == v5)
    {
      uint64_t result = sub_10001DFD0(a1, a2 + 1, (char *)a3, 0LL);
      if (result == v5) {
        return a2;
      }
    }
  }

  return result;
}

char *sub_10001DAE8(uint64_t a1, char *a2, char *a3)
{
  if (a2 != a3 && *a2 == 91)
  {
    if (a2 + 1 == a3) {
      goto LABEL_20;
    }
    uint64_t v5 = a2[1] == 94 ? a2 + 2 : a2 + 1;
    uint64_t v6 = (uint64_t *)sub_10001EC44(a1, a2[1] == 94);
    if (v5 == a3) {
      goto LABEL_20;
    }
    uint64_t v7 = v6;
    if ((*(_WORD *)(a1 + 24) & 0x1F0) != 0 && *v5 == 93)
    {
      sub_10001ECBC((uint64_t)v6, 93LL);
      ++v5;
    }

    if (v5 == a3) {
      goto LABEL_20;
    }
    do
    {
      __int128 v8 = v5;
      uint64_t v5 = sub_10001FF48(a1, v5, a3, v7);
    }

    while (v5 != v8);
    if (v8 == a3) {
      goto LABEL_20;
    }
    if (*v8 == 45)
    {
      sub_10001ECBC((uint64_t)v7, 45LL);
      ++v8;
    }

    if (v8 == a3 || *v8 != 93) {
LABEL_20:
    }
      sub_10001FEFC();
    return v8 + 1;
  }

  return a2;
}

void *sub_10001DBF8(void *result)
{
  if ((result[3] & 2) == 0)
  {
    uint64_t v1 = result;
    uint64_t result = operator new(0x18uLL);
    int v2 = *((_DWORD *)v1 + 7) + 1;
    *((_DWORD *)v1 + 7) = v2;
    uint64_t v3 = v1[7];
    uint64_t v4 = *(void *)(v3 + 8);
    unsigned __int8 *result = &off_1000CE900;
    result[1] = v4;
    *((_DWORD *)result + 4) = v2;
    *(void *)(v3 + _Block_object_dispose(va, 8) = result;
    v1[7] = *(void *)(v1[7] + 8LL);
  }

  return result;
}

void *sub_10001DC5C(void *result, int a2)
{
  if ((result[3] & 2) == 0)
  {
    uint64_t v3 = result;
    uint64_t result = operator new(0x18uLL);
    uint64_t v4 = v3[7];
    uint64_t v5 = *(void *)(v4 + 8);
    unsigned __int8 *result = &off_1000CE948;
    result[1] = v5;
    *((_DWORD *)result + 4) = a2;
    *(void *)(v4 + _Block_object_dispose(va, 8) = result;
    v3[7] = *(void *)(v3[7] + 8LL);
  }

  return result;
}

void sub_10001DCB8()
{
  exception = (std::regex_error *)__cxa_allocate_exception(0x18uLL);
  std::regex_error::regex_error(exception, error_badrepeat);
}

void sub_10001DCF0(_Unwind_Exception *a1)
{
}

_BYTE *sub_10001DD04(uint64_t a1, _BYTE *a2, _BYTE *a3)
{
  uint64_t v3 = a2;
  if (a2 != a3)
  {
    int v4 = (char)*a2;
    BOOL v5 = (v4 - 36) > 0x3A || ((1LL << (*a2 - 36)) & 0x7800000080004F1LL) == 0;
    if (v5 && (v4 - 123) >= 3)
    {
      sub_10001E29C(a1, (char)v4);
      ++v3;
    }
  }

  return v3;
}

void *sub_10001DD74(void *a1)
{
  *a1 = &off_1000CE570;
  uint64_t v2 = a1[1];
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8LL))(v2);
  }
  return a1;
}

void sub_10001DDB8(void *__p)
{
  *std::string __p = &off_1000CE570;
  uint64_t v2 = __p[1];
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8LL))(v2);
  }
  operator delete(__p);
}

void sub_10001DDFC()
{
  exception = (std::regex_error *)__cxa_allocate_exception(0x18uLL);
  std::regex_error::regex_error(exception, error_escape);
}

void sub_10001DE34(_Unwind_Exception *a1)
{
}

unsigned __int8 *sub_10001DE48(uint64_t a1, unsigned __int8 *a2, unsigned __int8 *a3)
{
  if (a2 == a3) {
    return a2;
  }
  int v4 = *a2;
  uint64_t v5 = (v4 - 48);
  if (v4 == 48)
  {
    sub_10001E29C(a1, v5);
    return a2 + 1;
  }

  uint64_t v6 = a3;
  uint64_t v7 = a2 + 1;
  if (a2 + 1 != a3)
  {
    while (1)
    {
      int v8 = *v7;
      ++v7;
      LODWORD(v5) = v8 + 10 * v5 - 48;
      if (v7 == a3) {
        goto LABEL_12;
      }
    }

    uint64_t v6 = v7;
LABEL_12:
    if (!(_DWORD)v5) {
      goto LABEL_16;
    }
  }

  if (v5 > *(_DWORD *)(a1 + 28)) {
LABEL_16:
  }
    sub_10001E380();
  sub_10001E3CC(a1, v5);
  return v6;
}

char *sub_10001DF04(uint64_t a1, char *a2, char *a3)
{
  uint64_t v3 = a2;
  if (a2 == a3) {
    return v3;
  }
  int v4 = *a2;
  if (v4 > 99)
  {
    if (v4 == 119)
    {
      char v5 = 0;
      goto LABEL_15;
    }

    if (v4 == 115)
    {
      char v9 = 0;
      goto LABEL_17;
    }

    if (v4 != 100) {
      return v3;
    }
    char v6 = 0;
LABEL_12:
    uint64_t v7 = sub_10001EC44(a1, v6);
    int v8 = v7[40] | 0x400;
LABEL_18:
    v7[40] = v8;
    goto LABEL_19;
  }

  switch(v4)
  {
    case 'D':
      char v6 = 1;
      goto LABEL_12;
    case 'S':
      char v9 = 1;
LABEL_17:
      uint64_t v7 = sub_10001EC44(a1, v9);
      int v8 = v7[40] | 0x4000;
      goto LABEL_18;
    case 'W':
      char v5 = 1;
LABEL_15:
      uint64_t v10 = sub_10001EC44(a1, v5);
      v10[40] |= 0x500u;
      sub_10001ECBC((uint64_t)v10, 95LL);
LABEL_19:
      ++v3;
      break;
  }

  return v3;
}

unsigned __int8 *sub_10001DFD0(uint64_t a1, unsigned __int8 *a2, char *a3, std::string *this)
{
  int v4 = a2;
  if (a2 != (unsigned __int8 *)a3)
  {
    int v5 = (char)*a2;
    if (v5 > 109)
    {
      char v6 = 0;
      switch(*a2)
      {
        case 'n':
          if (this)
          {
            uint64_t v7 = this;
            LOBYTE(v_Block_object_dispose(va, 8) = 10;
            goto LABEL_50;
          }

          uint64_t v8 = 10LL;
          goto LABEL_59;
        case 'r':
          if (this)
          {
            uint64_t v7 = this;
            LOBYTE(v_Block_object_dispose(va, 8) = 13;
            goto LABEL_50;
          }

          uint64_t v8 = 13LL;
          goto LABEL_59;
        case 't':
          if (this)
          {
            uint64_t v7 = this;
            LOBYTE(v_Block_object_dispose(va, 8) = 9;
            goto LABEL_50;
          }

          uint64_t v8 = 9LL;
          goto LABEL_59;
        case 'u':
          int v9 = a2[1];
          if ((v9 & 0xF8) != 0x30 && (v9 & 0xFE) != 0x38 && (v9 | 0x20u) - 97 >= 6) {
            goto LABEL_64;
          }
          int v4 = a2 + 2;
          int v10 = *v4;
          char v11 = -48;
          if ((v10 & 0xF8) == 0x30 || (v10 & 0xFE) == 0x38) {
            goto LABEL_24;
          }
          v10 |= 0x20u;
          char v11 = -87;
LABEL_24:
          char v6 = 16 * (v11 + v10);
LABEL_25:
          int v12 = v4[1];
          char v13 = -48;
          if ((v12 & 0xF8) == 0x30 || (v12 & 0xFE) == 0x38) {
            goto LABEL_30;
          }
          v12 |= 0x20u;
          char v13 = -87;
LABEL_30:
          int v14 = v4[2];
          char v15 = -48;
          if ((v14 & 0xF8) == 0x30 || (v14 & 0xFE) == 0x38) {
            goto LABEL_35;
          }
          v14 |= 0x20u;
          char v15 = -87;
LABEL_35:
          if (this) {
            std::string::operator=(this, v15 + v14 + 16 * (v13 + v12 + v6));
          }
          else {
            sub_10001E29C(a1, (char)(v15 + v14 + 16 * (v13 + v12 + v6)));
          }
          v4 += 3;
          return v4;
        case 'v':
          if (this)
          {
            uint64_t v7 = this;
            LOBYTE(v_Block_object_dispose(va, 8) = 11;
            goto LABEL_50;
          }

          uint64_t v8 = 11LL;
          break;
        case 'x':
          goto LABEL_25;
        default:
          goto LABEL_45;
      }

      goto LABEL_59;
    }

    if (v5 == 48)
    {
      if (this)
      {
        uint64_t v7 = this;
        LOBYTE(v_Block_object_dispose(va, 8) = 0;
        goto LABEL_50;
      }

      uint64_t v8 = 0LL;
LABEL_59:
      sub_10001E29C(a1, v8);
      return ++v4;
    }

    if (v5 != 99)
    {
      if (v5 == 102)
      {
        if (this)
        {
          uint64_t v7 = this;
          LOBYTE(v_Block_object_dispose(va, 8) = 12;
LABEL_50:
          std::string::operator=(v7, v8);
          return ++v4;
        }

        uint64_t v8 = 12LL;
        goto LABEL_59;
      }

LABEL_45:
      if (*a2 != 95
        && ((v5 & 0x80) != 0 || (*(_DWORD *)(*(void *)(*(void *)(a1 + 8) + 16LL) + 4LL * *a2) & 0x500) == 0))
      {
        uint64_t v8 = (char)v5;
        if (this)
        {
          uint64_t v7 = this;
          goto LABEL_50;
        }

        goto LABEL_59;
      }

  if (sub_100030734(Mutable))
  {
    *((void *)this + 24) = CFRetain(Mutable);
  }

  else
  {
    *((void *)this + 24) = 0LL;
    if (Mutable) {
      CFRelease(Mutable);
    }
  }

  ++*(void *)(a1 + 40);
  return i;
}

  ++*(void *)(a1 + 40);
  return i;
}

      (*(void (**)(uint64_t))(*(void *)v67 + 32LL))(v67);
    }

    if (a3)
    {
      if (a3 != 1)
      {
LABEL_44:
        (*(void (**)(uint64_t, uint64_t *))(*(void *)v67 + 80LL))(v67, &v64);
        goto LABEL_45;
      }

      uint64_t v16 = *(float *)(v9 + 4 * v8);
      if (v16 == -INFINITY || v65 >= -INFINITY && v65 <= -INFINITY)
      {
        __int128 v17 = *(float *)sub_1000606CC();
      }

      else
      {
        __int128 v17 = INFINITY;
        if (v16 == INFINITY || v65 == INFINITY)
        {
LABEL_36:
          __int128 v19 = *(float *)(v14 + 4 * v13);
          if (v19 >= -INFINITY && v19 <= -INFINITY) {
            goto LABEL_38;
          }
LABEL_39:
          if (v19 == INFINITY)
          {
            uint64_t v20 = NAN;
          }

          else
          {
            uint64_t v20 = INFINITY;
            if (v17 != INFINITY) {
              uint64_t v20 = v17 - v19;
            }
          }

          goto LABEL_43;
        }

        __int128 v17 = v16 + v65;
      }

      if (v17 != -INFINITY) {
        goto LABEL_36;
      }
LABEL_38:
      uint64_t v20 = *(float *)sub_1000606CC();
LABEL_43:
      uint64_t v65 = v20;
      goto LABEL_44;
    }

    if (v65 == -INFINITY || (uint64_t v18 = *(float *)(v14 + 4 * v13), v18 >= -INFINITY) && v18 <= -INFINITY)
    {
      __int128 v17 = *(float *)sub_1000606CC();
    }

    else
    {
      __int128 v17 = INFINITY;
      if (v65 == INFINITY || v18 == INFINITY) {
        goto LABEL_29;
      }
      __int128 v17 = v65 + v18;
    }

    if (v17 == -INFINITY) {
      goto LABEL_38;
    }
LABEL_29:
    __int128 v19 = *(float *)(v9 + 4 * v8);
    if (v19 >= -INFINITY && v19 <= -INFINITY) {
      goto LABEL_38;
    }
    goto LABEL_39;
  }

  while (1)
  {
LABEL_90:
    if (!v68)
    {
      if (v70 >= v69) {
        break;
      }
      goto LABEL_75;
    }

    if (v68)
    {
      __int128 v26 = (*(uint64_t (**)(uint64_t))(*(void *)v68 + 24LL))(v68);
      goto LABEL_76;
    }

LABEL_64:
      sub_10001DDFC();
    }

    uint64_t v16 = a2[1] & 0x1F;
    if (this) {
      std::string::operator=(this, v16);
    }
    else {
      sub_10001E29C(a1, v16);
    }
    v4 += 2;
  }

  return v4;
}

uint64_t sub_10001E29C(uint64_t a1, uint64_t a2)
{
  int v4 = *(_DWORD *)(a1 + 24);
  if ((v4 & 1) != 0)
  {
    uint64_t v8 = (char *)operator new(0x30uLL);
    uint64_t result = sub_10001E498((uint64_t)v8, a1, a2, *(void *)(*(void *)(a1 + 56) + 8LL));
LABEL_6:
    *(void *)(*(void *)(a1 + 56) + 8LL) = v8;
    goto LABEL_7;
  }

  if ((v4 & 8) != 0)
  {
    uint64_t v8 = (char *)operator new(0x30uLL);
    uint64_t v9 = *(void *)(*(void *)(a1 + 56) + 8LL);
    *(void *)uint64_t v8 = off_1000CE750;
    *((void *)v8 + 1) = v9;
    uint64_t result = (uint64_t)std::locale::locale((std::locale *)v8 + 2, (const std::locale *)a1);
    *(_OWORD *)(v8 + 24) = *(_OWORD *)(a1 + 8);
    v8[40] = a2;
    goto LABEL_6;
  }

  uint64_t result = (uint64_t)operator new(0x18uLL);
  uint64_t v6 = *(void *)(a1 + 56);
  uint64_t v7 = *(void *)(v6 + 8);
  *(void *)uint64_t result = &off_1000CE798;
  *(void *)(result + _Block_object_dispose(va, 8) = v7;
  *(_BYTE *)(result + 16) = a2;
  *(void *)(v6 + _Block_object_dispose(va, 8) = result;
LABEL_7:
  *(void *)(a1 + 56) = *(void *)(*(void *)(a1 + 56) + 8LL);
  return result;
}

void sub_10001E36C(_Unwind_Exception *a1)
{
}

void sub_10001E380()
{
  exception = (std::regex_error *)__cxa_allocate_exception(0x18uLL);
  std::regex_error::regex_error(exception, error_backref);
}

void sub_10001E3B8(_Unwind_Exception *a1)
{
}

void *sub_10001E3CC(uint64_t a1, int a2)
{
  int v4 = *(_DWORD *)(a1 + 24);
  if ((v4 & 1) != 0)
  {
    uint64_t v8 = (std::locale *)operator new(0x30uLL);
    uint64_t v9 = v8;
    int v10 = *(std::locale::__imp **)(*(void *)(a1 + 56) + 8LL);
LABEL_6:
    v8->__locale_ = (std::locale::__imp *)(v11 + 2);
    v8[1].__locale_ = v10;
    uint64_t result = std::locale::locale(v8 + 2, (const std::locale *)a1);
    *(_OWORD *)&v9[3].__locale_ = *(_OWORD *)(a1 + 8);
    LODWORD(v9[5].__locale_) = a2;
    *(void *)(*(void *)(a1 + 56) + 8LL) = v9;
    goto LABEL_7;
  }

  if ((v4 & 8) != 0)
  {
    uint64_t v8 = (std::locale *)operator new(0x30uLL);
    uint64_t v9 = v8;
    int v10 = *(std::locale::__imp **)(*(void *)(a1 + 56) + 8LL);
    goto LABEL_6;
  }

  uint64_t result = operator new(0x18uLL);
  uint64_t v6 = *(void *)(a1 + 56);
  uint64_t v7 = *(void *)(v6 + 8);
  void *result = &off_1000CE870;
  result[1] = v7;
  *((_DWORD *)result + 4) = a2;
  *(void *)(v6 + _Block_object_dispose(va, 8) = result;
LABEL_7:
  *(void *)(a1 + 56) = *(void *)(*(void *)(a1 + 56) + 8LL);
  return result;
}

uint64_t sub_10001E498(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  *(void *)a1 = off_1000CE708;
  *(void *)(a1 + _Block_object_dispose(va, 8) = a4;
  std::locale::locale((std::locale *)(a1 + 16), (const std::locale *)a2);
  *(_OWORD *)(a1 + 24) = *(_OWORD *)(a2 + 8);
  *(_BYTE *)(a1 + 4sub_10001AFB0((std::locale *)v24, " +$", 0) = (*(uint64_t (**)(void, uint64_t))(**(void **)(a2 + 8) + 40LL))( *(void *)(a2 + 8),  a3);
  return a1;
}

void sub_10001E504(_Unwind_Exception *a1)
{
  void *v1 = &off_1000CE570;
  uint64_t v4 = v1[1];
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 8LL))(v4);
  }
  _Unwind_Resume(a1);
}

std::locale *sub_10001E53C(std::locale *a1)
{
  a1->__locale_ = (std::locale::__imp *)off_1000CE708;
  std::locale::~locale(a1 + 2);
  a1->__locale_ = (std::locale::__imp *)&off_1000CE570;
  locale = a1[1].__locale_;
  if (locale) {
    (*(void (**)(std::locale::__imp *))(*(void *)locale + 8LL))(locale);
  }
  return a1;
}

void sub_10001E594(std::locale *a1)
{
  a1->__locale_ = (std::locale::__imp *)off_1000CE708;
  std::locale::~locale(a1 + 2);
  a1->__locale_ = (std::locale::__imp *)&off_1000CE570;
  locale = a1[1].__locale_;
  if (locale) {
    (*(void (**)(std::locale::__imp *))(*(void *)locale + 8LL))(locale);
  }
  operator delete(a1);
}

uint64_t sub_10001E5EC(uint64_t result, uint64_t a2)
{
  uint64_t v3 = *(char **)(a2 + 16);
  if (v3 == *(char **)(a2 + 24)
    || (uint64_t v4 = result,
        uint64_t result = (*(uint64_t (**)(void, void))(**(void **)(result + 24) + 40LL))( *(void *)(result + 24),  *v3),  *(unsigned __int8 *)(v4 + 40) != result))
  {
    uint64_t v5 = 0LL;
    *(_DWORD *)a2 = -993;
  }

  else
  {
    *(_DWORD *)a2 = -995;
    ++*(void *)(a2 + 16);
    uint64_t v5 = *(void *)(v4 + 8);
  }

  *(void *)(a2 + 8sub_10001AFB0((std::locale *)v24, " +$", 0) = v5;
  return result;
}

std::locale *sub_10001E664(std::locale *a1)
{
  a1->__locale_ = (std::locale::__imp *)off_1000CE750;
  std::locale::~locale(a1 + 2);
  a1->__locale_ = (std::locale::__imp *)&off_1000CE570;
  locale = a1[1].__locale_;
  if (locale) {
    (*(void (**)(std::locale::__imp *))(*(void *)locale + 8LL))(locale);
  }
  return a1;
}

void sub_10001E6BC(std::locale *a1)
{
  a1->__locale_ = (std::locale::__imp *)off_1000CE750;
  std::locale::~locale(a1 + 2);
  a1->__locale_ = (std::locale::__imp *)&off_1000CE570;
  locale = a1[1].__locale_;
  if (locale) {
    (*(void (**)(std::locale::__imp *))(*(void *)locale + 8LL))(locale);
  }
  operator delete(a1);
}

uint64_t sub_10001E714(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(unsigned __int8 **)(a2 + 16);
  if (v2 == *(unsigned __int8 **)(a2 + 24) || *v2 != *(unsigned __int8 *)(result + 40))
  {
    uint64_t v3 = 0LL;
    *(_DWORD *)a2 = -993;
  }

  else
  {
    *(_DWORD *)a2 = -995;
    *(void *)(a2 + 16) = v2 + 1;
    uint64_t v3 = *(void *)(result + 8);
  }

  *(void *)(a2 + 8sub_10001AFB0((std::locale *)v24, " +$", 0) = v3;
  return result;
}

void *sub_10001E75C(void *a1)
{
  *a1 = &off_1000CE570;
  uint64_t v2 = a1[1];
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8LL))(v2);
  }
  return a1;
}

void sub_10001E7A0(void *__p)
{
  *std::string __p = &off_1000CE570;
  uint64_t v2 = __p[1];
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8LL))(v2);
  }
  operator delete(__p);
}

uint64_t sub_10001E7E4(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(unsigned __int8 **)(a2 + 16);
  if (v2 == *(unsigned __int8 **)(a2 + 24) || *v2 != *(unsigned __int8 *)(result + 16))
  {
    uint64_t v3 = 0LL;
    *(_DWORD *)a2 = -993;
  }

  else
  {
    *(_DWORD *)a2 = -995;
    *(void *)(a2 + 16) = v2 + 1;
    uint64_t v3 = *(void *)(result + 8);
  }

  *(void *)(a2 + 8sub_10001AFB0((std::locale *)v24, " +$", 0) = v3;
  return result;
}

std::locale *sub_10001E82C(std::locale *a1)
{
  a1->__locale_ = (std::locale::__imp *)off_1000CE7E0;
  std::locale::~locale(a1 + 2);
  a1->__locale_ = (std::locale::__imp *)&off_1000CE570;
  locale = a1[1].__locale_;
  if (locale) {
    (*(void (**)(std::locale::__imp *))(*(void *)locale + 8LL))(locale);
  }
  return a1;
}

void sub_10001E884(std::locale *a1)
{
  a1->__locale_ = (std::locale::__imp *)off_1000CE7E0;
  std::locale::~locale(a1 + 2);
  a1->__locale_ = (std::locale::__imp *)&off_1000CE570;
  locale = a1[1].__locale_;
  if (locale) {
    (*(void (**)(std::locale::__imp *))(*(void *)locale + 8LL))(locale);
  }
  operator delete(a1);
}

uint64_t sub_10001E8DC(uint64_t result, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 32) + 24LL * (*(_DWORD *)(result + 40) - 1);
  if (*(_BYTE *)(v3 + 16))
  {
    uint64_t v4 = *(void *)(v3 + 8) - *(void *)v3;
    uint64_t v5 = *(void *)(a2 + 16);
    if (*(void *)(a2 + 24) - v5 >= v4)
    {
      uint64_t v7 = result;
      if (v4 < 1)
      {
LABEL_9:
        *(_DWORD *)a2 = -994;
        *(void *)(a2 + 16) = v5 + v4;
        uint64_t v6 = *(void *)(v7 + 8);
        goto LABEL_10;
      }

      uint64_t v8 = 0LL;
      while (1)
      {
        int v9 = (*(uint64_t (**)(void, void))(**(void **)(v7 + 24) + 40LL))( *(void *)(v7 + 24),  *(char *)(*(void *)v3 + v8));
        uint64_t result = (*(uint64_t (**)(void, void))(**(void **)(v7 + 24) + 40LL))( *(void *)(v7 + 24),  *(char *)(*(void *)(a2 + 16) + v8));
        if (v9 != (_DWORD)result) {
          break;
        }
        if (v4 == ++v8)
        {
          uint64_t v5 = *(void *)(a2 + 16);
          goto LABEL_9;
        }
      }
    }
  }

  uint64_t v6 = 0LL;
  *(_DWORD *)a2 = -993;
LABEL_10:
  *(void *)(a2 + 8sub_10001AFB0((std::locale *)v24, " +$", 0) = v6;
  return result;
}

std::locale *sub_10001E9C0(std::locale *a1)
{
  a1->__locale_ = (std::locale::__imp *)off_1000CE828;
  std::locale::~locale(a1 + 2);
  a1->__locale_ = (std::locale::__imp *)&off_1000CE570;
  locale = a1[1].__locale_;
  if (locale) {
    (*(void (**)(std::locale::__imp *))(*(void *)locale + 8LL))(locale);
  }
  return a1;
}

void sub_10001EA18(std::locale *a1)
{
  a1->__locale_ = (std::locale::__imp *)off_1000CE828;
  std::locale::~locale(a1 + 2);
  a1->__locale_ = (std::locale::__imp *)&off_1000CE570;
  locale = a1[1].__locale_;
  if (locale) {
    (*(void (**)(std::locale::__imp *))(*(void *)locale + 8LL))(locale);
  }
  operator delete(a1);
}

uint64_t sub_10001EA70(uint64_t result, uint64_t a2)
{
  unsigned int v2 = *(_DWORD *)(result + 40) - 1;
  uint64_t v3 = *(void *)(a2 + 32);
  if (*(_BYTE *)(v3 + 24LL * v2 + 16))
  {
    uint64_t v4 = (unsigned __int8 **)(v3 + 24LL * v2);
    uint64_t v5 = *v4;
    uint64_t v6 = v4[1] - *v4;
    uint64_t v7 = *(void *)(a2 + 16);
    if (*(void *)(a2 + 24) - v7 >= v6)
    {
      if (v6 < 1)
      {
LABEL_8:
        *(_DWORD *)a2 = -994;
        *(void *)(a2 + 16) = v7 + v6;
        uint64_t v8 = *(void *)(result + 8);
        goto LABEL_9;
      }

      int v9 = *(unsigned __int8 **)(a2 + 16);
      uint64_t v10 = v6;
      while (1)
      {
        int v12 = *v5++;
        int v11 = v12;
        int v13 = *v9++;
        if (v11 != v13) {
          break;
        }
        if (!--v10) {
          goto LABEL_8;
        }
      }
    }
  }

  uint64_t v8 = 0LL;
  *(_DWORD *)a2 = -993;
LABEL_9:
  *(void *)(a2 + 8sub_10001AFB0((std::locale *)v24, " +$", 0) = v8;
  return result;
}

void *sub_10001EB00(void *a1)
{
  *a1 = &off_1000CE570;
  uint64_t v2 = a1[1];
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8LL))(v2);
  }
  return a1;
}

void sub_10001EB44(void *__p)
{
  *std::string __p = &off_1000CE570;
  uint64_t v2 = __p[1];
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8LL))(v2);
  }
  operator delete(__p);
}

unsigned int *sub_10001EB88(unsigned int *result, uint64_t a2)
{
  unint64_t v2 = result[4];
  uint64_t v3 = *(void *)(a2 + 32);
  if (0xAAAAAAAAAAAAAAABLL * ((*(void *)(a2 + 40) - v3) >> 3) < v2) {
    sub_10001E380();
  }
  unsigned int v5 = v2 - 1;
  if (*(_BYTE *)(v3 + 24LL * v5 + 16)
    && (uint64_t v6 = result,
        uint64_t v7 = v3 + 24LL * v5,
        uint64_t result = *(unsigned int **)v7,
        int64_t v8 = *(void *)(v7 + 8) - *(void *)v7,
        uint64_t v9 = *(void *)(a2 + 16),
        *(void *)(a2 + 24) - v9 >= v8)
    && (uint64_t result = (unsigned int *)memcmp(result, *(const void **)(a2 + 16), v8), !(_DWORD)result))
  {
    *(_DWORD *)a2 = -994;
    *(void *)(a2 + 16) = v9 + v8;
    uint64_t v10 = *((void *)v6 + 1);
  }

  else
  {
    uint64_t v10 = 0LL;
    *(_DWORD *)a2 = -993;
  }

  *(void *)(a2 + 8sub_10001AFB0((std::locale *)v24, " +$", 0) = v10;
  return result;
}

void *sub_10001EC44(uint64_t a1, char a2)
{
  uint64_t v4 = operator new(0xB0uLL);
  sub_10001EEE8( (uint64_t)v4,  a1,  *(void *)(*(void *)(a1 + 56) + 8LL),  a2,  *(_DWORD *)(a1 + 24) & 1,  (*(_DWORD *)(a1 + 24) & 8) != 0);
  *(void *)(*(void *)(a1 + 56) + 8LL) = v4;
  *(void *)(a1 + 56) = v4;
  return v4;
}

void sub_10001ECA8(_Unwind_Exception *a1)
{
}

void sub_10001ECBC(uint64_t a1, uint64_t a2)
{
  char v2 = a2;
  if (*(_BYTE *)(a1 + 169))
  {
    char v2 = (*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 24) + 40LL))(*(void *)(a1 + 24), a2);
    unsigned int v5 = *(_BYTE **)(a1 + 48);
    unint64_t v4 = *(void *)(a1 + 56);
    if ((unint64_t)v5 >= v4)
    {
      uint64_t v6 = (unint64_t *)(a1 + 40);
      unint64_t v7 = *(void *)(a1 + 40);
      int64_t v8 = &v5[-v7];
      uint64_t v9 = (uint64_t)&v5[-v7 + 1];
      if (v9 >= 0)
      {
        unint64_t v10 = v4 - v7;
        if (2 * v10 > v9) {
          uint64_t v9 = 2 * v10;
        }
        if (v10 >= 0x3FFFFFFFFFFFFFFFLL) {
          size_t v11 = 0x7FFFFFFFFFFFFFFFLL;
        }
        else {
          size_t v11 = v9;
        }
        if (v11) {
          int v12 = operator new(v11);
        }
        else {
          int v12 = 0LL;
        }
        uint64_t v20 = &v8[(void)v12];
        __int128 v21 = (char *)v12 + v11;
        v8[(void)v12] = v2;
        uint64_t v19 = (uint64_t)&v8[(void)v12 + 1];
        if (v5 != (_BYTE *)v7)
        {
          __int128 v22 = &v5[~v7];
          do
          {
            char v23 = *--v5;
            (v22--)[(void)v12] = v23;
          }

          while (v5 != (_BYTE *)v7);
LABEL_45:
          unsigned int v5 = (_BYTE *)*v6;
          goto LABEL_47;
        }

        goto LABEL_46;
      }

LABEL_50:
      sub_100018774();
    }

    goto LABEL_22;
  }

  uint64_t v6 = (unint64_t *)(a1 + 40);
  unsigned int v5 = *(_BYTE **)(a1 + 48);
  unint64_t v13 = *(void *)(a1 + 56);
  if (!*(_BYTE *)(a1 + 170))
  {
    if ((unint64_t)v5 >= v13)
    {
      unint64_t v24 = *v6;
      uint64_t v25 = &v5[-*v6];
      unint64_t v26 = (unint64_t)(v25 + 1);
      if ((uint64_t)(v25 + 1) >= 0)
      {
        unint64_t v27 = v13 - v24;
        if (2 * v27 > v26) {
          unint64_t v26 = 2 * v27;
        }
        if (v27 >= 0x3FFFFFFFFFFFFFFFLL) {
          size_t v28 = 0x7FFFFFFFFFFFFFFFLL;
        }
        else {
          size_t v28 = v26;
        }
        if (v28) {
          int v12 = operator new(v28);
        }
        else {
          int v12 = 0LL;
        }
        uint64_t v20 = &v25[(void)v12];
        __int128 v21 = (char *)v12 + v28;
        v25[(void)v12] = v2;
        uint64_t v19 = (uint64_t)&v25[(void)v12 + 1];
        if (v5 != (_BYTE *)v24)
        {
          uint64_t v31 = &v5[~v24];
          do
          {
            char v32 = *--v5;
            (v31--)[(void)v12] = v32;
          }

          while (v5 != (_BYTE *)v24);
          goto LABEL_45;
        }

        goto LABEL_46;
      }

      goto LABEL_50;
    }

      sub_100018774();
    }

    goto LABEL_22;
  }

  uint64_t v6 = (unint64_t *)(a1 + 64);
  unsigned int v5 = *(_BYTE **)(a1 + 72);
  unint64_t v13 = *(void *)(a1 + 80);
  if (!*(_BYTE *)(a1 + 170))
  {
    if ((unint64_t)v5 >= v13)
    {
      unint64_t v24 = *v6;
      uint64_t v25 = &v5[-*v6];
      unint64_t v26 = (unint64_t)(v25 + 1);
      if ((uint64_t)(v25 + 1) >= 0)
      {
        unint64_t v27 = v13 - v24;
        if (2 * v27 > v26) {
          unint64_t v26 = 2 * v27;
        }
        if (v27 >= 0x3FFFFFFFFFFFFFFFLL) {
          size_t v28 = 0x7FFFFFFFFFFFFFFFLL;
        }
        else {
          size_t v28 = v26;
        }
        if (v28) {
          int v12 = operator new(v28);
        }
        else {
          int v12 = 0LL;
        }
        uint64_t v20 = &v25[(void)v12];
        __int128 v21 = (char *)v12 + v28;
        v25[(void)v12] = v2;
        uint64_t v19 = (uint64_t)&v25[(void)v12 + 1];
        if (v5 != (_BYTE *)v24)
        {
          uint64_t v31 = &v5[~v24];
          do
          {
            char v32 = *--v5;
            (v31--)[(void)v12] = v32;
          }

          while (v5 != (_BYTE *)v24);
          goto LABEL_45;
        }

        goto LABEL_46;
      }

      goto LABEL_50;
    }

  v238 = swift_bridgeObjectRelease(v191, v190);
  v239 = v27[96];
  v240 = v27[95];
  v241 = v27[94];
  v242 = v27[93];
  v243 = v27[92];
  v244 = (void *)v27[73];
  v245 = Transcriber.MultisegmentResult.range.getter(v238);
  CMTimeRange.end.getter(v245);
  Transcriber.MultisegmentResult.range.getter(v246);
  v247 = *(void (**)(uint64_t, uint64_t, uint64_t))(v242 + 16);
  v247(v240, v239, v243);
  v247(v241, v239, v243);
  v248 = (os_log_s *)Logger.logObject.getter(v244);
  v249 = static os_log_type_t.debug.getter();
  if (os_log_type_enabled(v248, v249))
  {
    v250 = v27[110];
    v251 = v27[109];
    v361 = v249;
    v252 = v27[95];
    v354 = v27[94];
    v338 = (CMTime *)v27[93];
    v341 = (CMTime *)v27[92];
    v253 = (char *)v27[73];
    v254 = swift_slowAlloc(42LL, -1LL);
    *(_DWORD *)v254 = 134218752;
    v27[65] = *(void *)&v253[v251];
    UnsafeMutableRawBufferPointer.copyMemory(from:)(v27 + 65, v27 + 66, v254 + 4);
    *(_WORD *)(v254 + 12) = 2048;
    v255 = *(void *)&v253[v250];

    v27[66] = v255;
    UnsafeMutableRawBufferPointer.copyMemory(from:)(v27 + 66, v27 + 67, v254 + 14);

    *(_WORD *)(v254 + 22) = 2048;
    Transcriber.MultisegmentResult.range.getter(v256);
    v257 = v27[8];
    v258 = *(void (**)(uint64_t, CMTime *))&v338->timescale;
    v258(v252, v341);
    v27[67] = v257;
    UnsafeMutableRawBufferPointer.copyMemory(from:)(v27 + 67, v27 + 68, v254 + 24);
    *(_WORD *)(v254 + 32) = 2048;
    v260 = Transcriber.MultisegmentResult.range.getter(v259);
    v261 = CMTimeRange.end.getter(v260);
    v258(v354, v341);
    v27[68] = v261;
    UnsafeMutableRawBufferPointer.copyMemory(from:)(v27 + 68, v27 + 69, v254 + 34);
    _os_log_impl( (void *)&_mh_execute_header,  v248,  v361,  "SpeechDonation ::totalSamplesSent =%lld ::newUtteranceBeginSampleNumber = %lld:: start = %lld :: end = %lld",  (uint8_t *)v254,  0x2Au);
    swift_slowDealloc(v254, -1LL, -1LL);
  }

  else
  {
    v262 = v27[95];
    v263 = (CMTime *)v27[92];
    v264 = (void *)v27[73];
    v258 = *(void (**)(uint64_t, CMTime *))(v27[93] + 8LL);
    v258(v27[94], v263);
    v258(v262, v263);
  }

  v265 = v27[110];
  v266 = v27[73];

  Transcriber.MultisegmentResult.range.getter(v267);
  v269 = v27[2];
  v270 = *(void *)(v266 + v265);
  v271 = v269 - v270;
  if (!__OFSUB__(v269, v270))
  {
    v272 = v27[110];
    v273 = v27[73];
    v274 = Transcriber.MultisegmentResult.range.getter(v268);
    v275 = CMTimeRange.end.getter(v274);
    v276 = *(void *)(v273 + v272);
    v277 = v275 - v276;
    if (__OFSUB__(v275, v276)) {
      goto LABEL_74;
    }
    v278 = (void *)(*(uint64_t (**)(void))((swift_isaMask & *(void *)v27[73]) + 0xC8LL))();
    [v278 didGetUtteranceBoundary:v271 utteranceEndSampleNumber:v277];

    v279 = Transcriber.MultisegmentResult.transcriptions.getter();
    v281 = v279;
    v282 = *(void *)(v279 + 16);
    if (v282)
    {
      v362 = v258;
      v283 = v27[78];
      v27[64] = _swiftEmptyArrayStorage;
      v368 = v27 + 64;
      sub_100056764(0, v282, 0);
      v355 = v281;
      v284 = v281 + ((*(unsigned __int8 *)(v283 + 80) + 32LL) & ~(unint64_t)*(unsigned __int8 *)(v283 + 80));
      v374 = *(void *)(v283 + 72);
      v285 = *(uint64_t (**)(uint64_t, unint64_t, uint64_t))(v283 + 16);
      do
      {
        v286 = v27[79];
        v287 = v27[78];
        v288 = v27[77];
        v289 = v27[76];
        v290 = v27[75];
        v291 = v285(v286, v284, v288);
        AttributedString.characters.getter(v291);
        v292 = sub_100058894( &qword_1000DDA20,  (uint64_t (*)(uint64_t))&type metadata accessor for AttributedString.CharacterView,  (uint64_t)&protocol conformance descriptor for AttributedString.CharacterView);
        v293 = String.init<A>(_:)(v289, v290, v292);
        v295 = v294;
        (*(void (**)(uint64_t, uint64_t))(v287 + 8))(v286, v288);
        v296 = (void *)v27[64];
        if ((swift_isUniquelyReferenced_nonNull_native(v296) & 1) == 0)
        {
          sub_100056764(0, v296[2] + 1LL, 1);
          v296 = (void *)*v368;
        }

        v299 = v296[2];
        v298 = v296[3];
        if (v299 >= v298 >> 1)
        {
          sub_100056764(v298 > 1, v299 + 1, 1);
          v296 = (void *)*v368;
        }

        v296[2] = v299 + 1;
        v300 = &v296[2 * v299];
        v300[4] = v293;
        v300[5] = v295;
        v284 += v374;
        --v282;
      }

      while (v282);
      swift_bridgeObjectRelease(v355, v297);
      v258 = v362;
      if (v296[2]) {
        goto LABEL_63;
      }
    }

    else
    {
      swift_bridgeObjectRelease(v279, v280);
      v296 = _swiftEmptyArrayStorage;
      if (_swiftEmptyArrayStorage[2])
      {
LABEL_63:
        v301 = v27[96];
        v302 = (CMTime *)v27[92];
        v303 = v296[5];
        swift_bridgeObjectRetain(v303);
        swift_bridgeObjectRelease(v296, v304);
        v305 = String._bridgeToObjectiveC()();
        swift_bridgeObjectRelease(v303, v306);
        sub_100051CC8(v312, (uint64_t)v330, (uint64_t)v305);

        v258(v301, v302);
        goto LABEL_64;
      }
    }

    __break(1u);
LABEL_67:
    __break(1u);
    goto LABEL_68;
  }

              if (*((void *)&v51 + 1)) {
                --**((_DWORD **)&v51 + 1);
              }
LABEL_52:
              if ((_DWORD)v11 != -1)
              {
                unint64_t v10 = 0x2000000000LL;
                goto LABEL_55;
              }

LABEL_22:
    _BYTE *v5 = v2;
    uint64_t v19 = (uint64_t)(v5 + 1);
    goto LABEL_49;
  }

  unint64_t v14 = *v6;
  char v15 = &v5[-*v6];
  unint64_t v16 = (unint64_t)(v15 + 1);
  unint64_t v17 = v13 - v14;
  if (2 * v17 > v16) {
    unint64_t v16 = 2 * v17;
  }
  if (v17 >= 0x3FFFFFFFFFFFFFFFLL) {
    size_t v18 = 0x7FFFFFFFFFFFFFFFLL;
  }
  else {
    size_t v18 = v16;
  }
  if (v18) {
    int v12 = operator new(v18);
  }
  else {
    int v12 = 0LL;
  }
  uint64_t v20 = &v15[(void)v12];
  __int128 v21 = (char *)v12 + v18;
  v15[(void)v12] = v2;
  uint64_t v19 = (uint64_t)&v15[(void)v12 + 1];
  if (v5 != (_BYTE *)v14)
  {
    uint64_t v29 = &v5[~v14];
    do
    {
      char v30 = *--v5;
      (v29--)[(void)v12] = v30;
    }

    while (v5 != (_BYTE *)v14);
    goto LABEL_45;
  }

    _BYTE *v5 = v2;
    uint64_t v19 = (uint64_t)(v5 + 1);
    goto LABEL_49;
  }

  unint64_t v14 = *v6;
  char v15 = &v5[-*v6];
  unint64_t v16 = (unint64_t)(v15 + 1);
  unint64_t v17 = v13 - v14;
  if (2 * v17 > v16) {
    unint64_t v16 = 2 * v17;
  }
  if (v17 >= 0x3FFFFFFFFFFFFFFFLL) {
    size_t v18 = 0x7FFFFFFFFFFFFFFFLL;
  }
  else {
    size_t v18 = v16;
  }
  if (v18) {
    int v12 = operator new(v18);
  }
  else {
    int v12 = 0LL;
  }
  uint64_t v20 = &v15[(void)v12];
  __int128 v21 = (char *)v12 + v18;
  v15[(void)v12] = v2;
  uint64_t v19 = (uint64_t)&v15[(void)v12 + 1];
  if (v5 != (_BYTE *)v14)
  {
    uint64_t v29 = &v5[~v14];
    do
    {
      char v30 = *--v5;
      (v29--)[(void)v12] = v30;
    }

    while (v5 != (_BYTE *)v14);
    goto LABEL_45;
  }

  if (v7) {
    (*(void (**)(void *))(*v7 + 8LL))(v7);
  }
}

      int64_t v8 = 1;
    }

    else
    {
      unint64_t v4 = (char *)HIBYTE(v13);
      if (!HIBYTE(v13)) {
        return 0LL;
      }
      unsigned int v5 = __p;
      do
      {
LABEL_13:
        unsigned int v5 = (void **)((char *)v5 + 1);
        --v4;
      }

      while (v4);
      if (*(char *)(a2 + 23) < 0)
      {
        sub_10005AA70(v10, *(void **)a2, *(void *)(a2 + 8));
      }

      else
      {
        *(_OWORD *)unint64_t v10 = *(_OWORD *)a2;
        size_t v11 = *(void *)(a2 + 16);
      }

      if (SHIBYTE(v11) < 0)
      {
        unint64_t v7 = (char *)v10[1];
        if (v10[1])
        {
          uint64_t v6 = (void **)v10[0];
          goto LABEL_31;
        }

        int64_t v8 = 1;
LABEL_39:
        operator delete(v10[0]);
        goto LABEL_23;
      }

      if (!HIBYTE(v11)) {
        goto LABEL_22;
      }
      uint64_t v6 = v10;
      unint64_t v7 = (char *)HIBYTE(v11);
LABEL_31:
      while ((*(char *)v6 & 0x80000000) == 0 && (_DefaultRuneLocale.__runetype[*(unsigned __int8 *)v6] & 0x400) != 0)
      {
        uint64_t v6 = (void **)((char *)v6 + 1);
        if (!--v7)
        {
          int64_t v8 = 0;
          goto LABEL_36;
        }
      }

      int64_t v8 = 1;
LABEL_36:
      if (v11 < 0) {
        goto LABEL_39;
      }
    }

      if (**(_DWORD **)a2 == 1936482662 && *(_BYTE *)(*(void *)a2 + 4LL) == 101)
      {
LABEL_32:
        unint64_t v4 = 0;
        goto LABEL_33;
      }

      if (*((void *)a2 + 1) != 1LL) {
        return 0LL;
      }
LABEL_27:
      a2 = *(unsigned __int8 **)a2;
LABEL_28:
      unsigned int v5 = *a2;
LABEL_29:
      unint64_t v4 = 0;
      uint64_t result = 0LL;
      if (v5 == 48) {
        goto LABEL_33;
      }
      return result;
    case 5LL:
      goto LABEL_22;
    default:
      return result;
  }

LABEL_46:
  int v12 = v20;
LABEL_47:
  *(void *)(a1 + 4sub_10001AFB0((std::locale *)v24, " +$", 0) = v12;
  *(void *)(a1 + 4_Block_object_dispose(va, 8) = v19;
  *(void *)(a1 + 56) = v21;
  if (v5) {
    operator delete(v5);
  }
LABEL_49:
  *(void *)(a1 + 4_Block_object_dispose(va, 8) = v19;
}

  int v12 = v20;
LABEL_47:
  *(void *)(a1 + 64) = v12;
  *(void *)(a1 + 72) = v19;
  *(void *)(a1 + 8sub_10001AFB0((std::locale *)v24, " +$", 0) = v21;
  if (v5) {
    operator delete(v5);
  }
LABEL_49:
  *(void *)(a1 + 72) = v19;
}

    unint64_t v27 = *((char *)v5 + 79);
    if (v27 >= 0) {
      size_t v28 = (uint64_t)(v5 + 7);
    }
    else {
      size_t v28 = v5[7];
    }
    if (v27 >= 0) {
      uint64_t v29 = *((unsigned __int8 *)v5 + 79);
    }
    else {
      uint64_t v29 = v5[8];
    }
    char v30 = sub_10002A6A4(&std::cout, v28, v29);
    uint64_t v9 = 1;
    sub_10002A6A4(v30, (uint64_t)"\n", 1LL);
LABEL_53:
    uint64_t v31 = (void *)v5[1];
    if (v31)
    {
      do
      {
        char v32 = v31;
        uint64_t v31 = (void *)*v31;
      }

      while (v31);
    }

    else
    {
      do
      {
        char v32 = (void *)v5[2];
        unint64_t v33 = *v32 == (void)v5;
        unsigned int v5 = v32;
      }

      while (!v33);
    }

    unsigned int v5 = v32;
  }

  while (v32 != v4);
  if ((v9 & 1) != 0) {
    sub_10002A6A4(&std::cout, (uint64_t)"\n", 1LL);
  }
LABEL_61:
}

uint64_t sub_10001EEE8(uint64_t a1, uint64_t a2, uint64_t a3, char a4, char a5, char a6)
{
  *(void *)a1 = off_1000CE8B8;
  *(void *)(a1 + _Block_object_dispose(va, 8) = a3;
  size_t v11 = (const std::locale *)(a1 + 16);
  std::locale::locale((std::locale *)(a1 + 16), (const std::locale *)a2);
  __int128 v12 = *(_OWORD *)(a2 + 8);
  *(_OWORD *)(a1 + 8_Block_object_dispose(va, 8) = 0u;
  *(_OWORD *)(a1 + 24) = v12;
  *(_OWORD *)(a1 + 4sub_10001AFB0((std::locale *)v24, " +$", 0) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_OWORD *)(a1 + 104) = 0u;
  *(_OWORD *)(a1 + 12sub_10001AFB0((std::locale *)v24, " +$", 0) = 0u;
  *(_OWORD *)(a1 + 136) = 0u;
  *(_OWORD *)(a1 + 152) = 0u;
  *(_BYTE *)(a1 + 16_Block_object_dispose(va, 8) = a4;
  *(_BYTE *)(a1 + 169) = a5;
  *(_BYTE *)(a1 + 17sub_10001AFB0((std::locale *)v24, " +$", 0) = a6;
  std::locale::locale(&v15, v11);
  std::locale::name(&v16, &v15);
  if ((char)v16.__r_.__value_.__s.__size_ < 0)
  {
    BOOL v13 = v16.__r_.__value_.__l.__size_ != 1 || *v16.__r_.__value_.__l.__data_ != 67;
    operator delete(v16.__r_.__value_.__l.__data_);
  }

  else
  {
    BOOL v13 = v16.__r_.__value_.__s.__size_ != 1 || v16.__r_.__value_.__s.__data_[0] != 67;
  }

  std::locale::~locale(&v15);
  *(_BYTE *)(a1 + 171) = v13;
  return a1;
}

void sub_10001EFF8( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10)
{
  a10 = v10 + 17;
  sub_10001FAA8((void ***)&a10);
  unint64_t v14 = (void *)v10[14];
  if (v14)
  {
    v10[15] = v14;
    operator delete(v14);
  }

  sub_10001A214((void ***)&a10);
  std::locale v15 = (void *)v10[8];
  if (v15)
  {
    v10[9] = v15;
    operator delete(v15);
  }

  std::string v16 = *v12;
  if (*v12)
  {
    v10[6] = v16;
    operator delete(v16);
  }

  std::locale::~locale(v11);
  *unint64_t v10 = &off_1000CE570;
  uint64_t v17 = v10[1];
  if (v17) {
    (*(void (**)(uint64_t))(*(void *)v17 + 8LL))(v17);
  }
  _Unwind_Resume(a1);
}

std::locale *sub_10001F084(std::locale *a1)
{
  a1->__locale_ = (std::locale::__imp *)off_1000CE8B8;
  unint64_t v7 = a1 + 17;
  sub_10001FAA8((void ***)&v7);
  locale = a1[14].__locale_;
  if (locale)
  {
    a1[15].__locale_ = locale;
    operator delete(locale);
  }

  unint64_t v7 = a1 + 11;
  sub_10001A214((void ***)&v7);
  uint64_t v3 = a1[8].__locale_;
  if (v3)
  {
    a1[9].__locale_ = v3;
    operator delete(v3);
  }

  unint64_t v4 = a1[5].__locale_;
  if (v4)
  {
    a1[6].__locale_ = v4;
    operator delete(v4);
  }

  std::locale::~locale(a1 + 2);
  a1->__locale_ = (std::locale::__imp *)&off_1000CE570;
  unsigned int v5 = a1[1].__locale_;
  if (v5) {
    (*(void (**)(std::locale::__imp *))(*(void *)v5 + 8LL))(v5);
  }
  return a1;
}

void sub_10001F138(std::locale *a1)
{
  a1->__locale_ = (std::locale::__imp *)off_1000CE8B8;
  uint64_t v6 = a1 + 17;
  sub_10001FAA8((void ***)&v6);
  locale = a1[14].__locale_;
  if (locale)
  {
    a1[15].__locale_ = locale;
    operator delete(locale);
  }

  uint64_t v6 = a1 + 11;
  sub_10001A214((void ***)&v6);
  uint64_t v3 = a1[8].__locale_;
  if (v3)
  {
    a1[9].__locale_ = v3;
    operator delete(v3);
  }

  unint64_t v4 = a1[5].__locale_;
  if (v4)
  {
    a1[6].__locale_ = v4;
    operator delete(v4);
  }

  std::locale::~locale(a1 + 2);
  a1->__locale_ = (std::locale::__imp *)&off_1000CE570;
  unsigned int v5 = a1[1].__locale_;
  if (v5) {
    (*(void (**)(std::locale::__imp *))(*(void *)v5 + 8LL))(v5);
  }
  operator delete(a1);
}

void sub_10001F1F0(uint64_t a1, uint64_t a2)
{
  unint64_t v4 = *(signed __int8 **)(a2 + 16);
  unsigned int v5 = *(signed __int8 **)(a2 + 24);
  if (v4 == v5)
  {
    uint64_t v37 = 0LL;
    int v36 = *(unsigned __int8 *)(a1 + 168);
    goto LABEL_221;
  }

  if (!*(_BYTE *)(a1 + 171) || v4 + 1 == v5) {
    goto LABEL_58;
  }
  signed __int8 v6 = *v4;
  unsigned __int8 v121 = *v4;
  signed __int8 v7 = v4[1];
  unsigned __int8 v122 = v7;
  if (*(_BYTE *)(a1 + 169))
  {
    unsigned __int8 v121 = (*(uint64_t (**)(void, void))(**(void **)(a1 + 24) + 40LL))( *(void *)(a1 + 24),  v6);
    unsigned __int8 v122 = (*(uint64_t (**)(void, void))(**(void **)(a1 + 24) + 40LL))( *(void *)(a1 + 24),  v7);
  }

  uint64_t v8 = a1 + 16;
  sub_10001FBD0(a1 + 16, (char *)&v121, (char *)&v123, &__p);
  if (((char)__p.__r_.__value_.__s.__size_ & 0x80000000) == 0)
  {
    if (__p.__r_.__value_.__s.__size_) {
      goto LABEL_8;
    }
LABEL_58:
    int v36 = 0;
    uint64_t v37 = 1LL;
    goto LABEL_59;
  }

  std::string::size_type size = __p.__r_.__value_.__l.__size_;
  operator delete(__p.__r_.__value_.__l.__data_);
  if (!size) {
    goto LABEL_58;
  }
LABEL_8:
  uint64_t v9 = *(void *)(a1 + 112);
  uint64_t v10 = *(void *)(a1 + 120) - v9;
  if (v10)
  {
    uint64_t v11 = v10 >> 1;
    __int128 v12 = (_BYTE *)(v9 + 1);
    do
    {
      v12 += 2;
      --v11;
    }

    while (v11);
  }

  if (!*(_BYTE *)(a1 + 170) || *(void *)(a1 + 88) == *(void *)(a1 + 96))
  {
    int v36 = 0;
  }

  else
  {
    sub_10001FB34(a1 + 16, (char *)&v121, (char *)&v123);
    uint64_t v14 = *(void *)(a1 + 88);
    unsigned __int8 v15 = __p.__r_.__value_.__s.__size_;
    uint64_t v16 = *(void *)(a1 + 96) - v14;
    if (v16)
    {
      uint64_t v17 = 0LL;
      unint64_t v18 = v16 / 48;
      unsigned __int8 v111 = __p.__r_.__value_.__s.__size_;
      if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
        std::string::size_type v19 = __p.__r_.__value_.__s.__size_;
      }
      else {
        std::string::size_type v19 = __p.__r_.__value_.__l.__size_;
      }
      if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
        p_p = &__p;
      }
      else {
        p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      if (v18 <= 1) {
        uint64_t v21 = 1LL;
      }
      else {
        uint64_t v21 = v16 / 48;
      }
      BOOL v22 = 1;
      while (1)
      {
        int v23 = *(char *)(v14 + 23);
        if (v23 >= 0) {
          size_t v24 = *(unsigned __int8 *)(v14 + 23);
        }
        else {
          size_t v24 = *(void *)(v14 + 8);
        }
        if (v23 >= 0) {
          uint64_t v25 = (const void *)v14;
        }
        else {
          uint64_t v25 = *(const void **)v14;
        }
        if (v24 >= v19) {
          size_t v26 = v19;
        }
        else {
          size_t v26 = v24;
        }
        int v27 = memcmp(p_p, v25, v26);
        BOOL v28 = v19 >= v24;
        if (v27) {
          BOOL v28 = v27 >= 0;
        }
        if (v28)
        {
          int v29 = *(char *)(v14 + 47);
          if (v29 >= 0) {
            size_t v30 = *(unsigned __int8 *)(v14 + 47);
          }
          else {
            size_t v30 = *(void *)(v14 + 32);
          }
          if (v29 >= 0) {
            uint64_t v31 = (const void *)(v14 + 24);
          }
          else {
            uint64_t v31 = *(const void **)(v14 + 24);
          }
          if (v19 >= v30) {
            size_t v32 = v30;
          }
          else {
            size_t v32 = v19;
          }
          int v33 = memcmp(v31, p_p, v32);
          BOOL v34 = v30 >= v19;
          if (v33) {
            BOOL v34 = v33 >= 0;
          }
          if (v34) {
            break;
          }
        }

        BOOL v22 = ++v17 < v18;
        v14 += 48LL;
        if (v21 == v17)
        {
          int v35 = 0;
          int v36 = 0;
          goto LABEL_162;
        }
      }

      int v36 = 1;
      int v35 = 5;
LABEL_162:
      uint64_t v8 = a1 + 16;
      unsigned __int8 v15 = v111;
    }

    else
    {
      BOOL v22 = 0;
      int v35 = 0;
      int v36 = 0;
    }

    if ((v15 & 0x80) != 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
    if (v22) {
      goto LABEL_195;
    }
  }

  if (*(void *)(a1 + 136) == *(void *)(a1 + 144)) {
    goto LABEL_200;
  }
  sub_10001FE08(v8, (char *)&v121, (char *)&v123, (uint64_t)&__p);
  uint64_t v88 = *(void *)(a1 + 136);
  uint64_t v89 = __p.__r_.__value_.__s.__size_;
  uint64_t v90 = *(void *)(a1 + 144) - v88;
  if (v90)
  {
    uint64_t v91 = 0LL;
    unint64_t v92 = v90 / 24;
    __int128 v93 = *(_OWORD *)&__p.__r_.__value_.__l.__data_;
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      std::string::size_type v94 = __p.__r_.__value_.__s.__size_;
    }
    else {
      std::string::size_type v94 = __p.__r_.__value_.__l.__size_;
    }
    if (v92 <= 1) {
      uint64_t v95 = 1LL;
    }
    else {
      uint64_t v95 = v90 / 24;
    }
    BOOL v96 = 1;
    while (1)
    {
      v97 = (unsigned __int8 **)(v88 + 24 * v91);
      v98 = (unsigned __int8 *)*((unsigned __int8 *)v97 + 23);
      int v99 = (char)v98;
      if ((unsigned __int8 *)v94 == v98)
      {
        if (v99 >= 0) {
          v100 = (unsigned __int8 *)(v88 + 24 * v91);
        }
        else {
          v100 = *v97;
        }
        if ((v89 & 0x80) == 0)
        {
          if ((_DWORD)v89)
          {
            v101 = &__p;
            uint64_t v102 = v89;
            do
            {
              v101 = (std::string *)((char *)v101 + 1);
              ++v100;
              --v102;
            }

            while (v102);
            int v36 = 1;
            int v35 = 5;
            goto LABEL_192;
          }

          int v36 = 1;
          if (v96) {
            goto LABEL_220;
          }
LABEL_200:
          if ((char)v121 < 0)
          {
            int v107 = *(_DWORD *)(a1 + 164);
            goto LABEL_213;
          }

          int v104 = *(_DWORD *)(a1 + 160);
          uint64_t v105 = *(void *)(*(void *)(a1 + 24) + 16LL);
          int v106 = *(_DWORD *)(v105 + 4LL * v121);
          if ((v106 & v104) == 0 && (v121 != 95 || (v104 & 0x80) == 0)
            || (char)v122 < 0
            || (*(_DWORD *)(v105 + 4LL * v122) & v104) == 0 && ((v104 & 0x80) == 0 || v122 != 95))
          {
            int v107 = *(_DWORD *)(a1 + 164);
            if ((v106 & v107) != 0 || v121 == 95 && (v107 & 0x80) != 0)
            {
LABEL_217:
              int v108 = v36;
              goto LABEL_219;
            }

LABEL_213:
            if (((char)v122 & 0x80000000) == 0)
            {
              if ((*(_DWORD *)(*(void *)(*(void *)(a1 + 24) + 16LL) + 4LL * v122) & v107) != 0) {
                goto LABEL_217;
              }
              int v108 = 1;
              if (v122 == 95 && (v107 & 0x80) != 0) {
                goto LABEL_217;
              }
LABEL_219:
              int v36 = v108;
LABEL_220:
              uint64_t v37 = 2LL;
              goto LABEL_221;
            }
          }

LABEL_218:
          int v108 = 1;
          goto LABEL_219;
        }

        unint64_t v116 = v92;
        uint64_t v119 = v89;
        int v103 = memcmp((const void *)v93, v100, *((size_t *)&v93 + 1));
        unint64_t v92 = v116;
        uint64_t v89 = v119;
        if (!v103) {
          break;
        }
      }

LABEL_188:
      BOOL v96 = ++v91 < v92;
      if (v91 == v95) {
        goto LABEL_191;
      }
    }

    int v35 = 5;
    int v36 = 1;
    goto LABEL_193;
  }

  BOOL v96 = 0;
LABEL_191:
  int v35 = 0;
LABEL_192:
  if ((v89 & 0x80) != 0) {
LABEL_193:
  }
    operator delete(__p.__r_.__value_.__l.__data_);
  if (!v96) {
    goto LABEL_200;
  }
LABEL_195:
  if (v35) {
    goto LABEL_220;
  }
  uint64_t v37 = 2LL;
LABEL_59:
  unsigned __int8 v39 = **(_BYTE **)(a2 + 16);
  unsigned __int8 v121 = v39;
  if (*(_BYTE *)(a1 + 169))
  {
    unsigned __int8 v39 = (*(uint64_t (**)(void, void))(**(void **)(a1 + 24) + 40LL))( *(void *)(a1 + 24),  (char)v39);
    unsigned __int8 v121 = v39;
  }

  __int128 v40 = *(unsigned __int8 **)(a1 + 40);
  unint64_t v41 = *(void *)(a1 + 48) - (void)v40;
  if (v41)
  {
    if (v41 <= 1) {
      unint64_t v41 = 1LL;
    }
    while (1)
    {
      int v42 = *v40++;
      if (v42 == v39) {
        break;
      }
      if (!--v41) {
        goto LABEL_66;
      }
    }

LABEL_77:
    int v36 = 1;
    goto LABEL_221;
  }

    ++v4;
    char v2 = *(void *)(v1 + 112);
    v3 += 16LL;
  }

  while (v4 < (*(void *)(v1 + 120) - v2) >> 4);
  if (v5) {
    (*(void (**)(void *))(*v5 + 8LL))(v5);
  }
LABEL_82:
}

      ++v30;
      int v29 = *a2;
      if (v30 >= (a2[1] - *a2) >> 4) {
        goto LABEL_78;
      }
    }

    unint64_t v52 = byte_1000DDAF8;
    if (byte_1000DDAF8)
    {
      sub_10000A2DC(v86, "FATAL");
      sub_10002A9EC(&v88, (uint64_t)v86);
    }

    else
    {
      sub_10000A2DC(__p, "ERROR");
      sub_10002A9EC(&v85, (uint64_t)__p);
    }

    std::string::size_type v53 = sub_10002A6A4(&std::cerr, (uint64_t)"ReplaceFstImpl: Input symbols of FST ", 37LL);
    unsigned __int8 v54 = (void *)std::ostream::operator<<(v53, v30);
    sub_10002A6A4(v54, (uint64_t)" do not match input symbols of base FST (0th FST)", 49LL);
    if (v52)
    {
      sub_10002AA94(&v88);
      if (v87 < 0)
      {
        uint64_t v55 = (void *)v86[0];
LABEL_64:
        operator delete(v55);
      }
    }

    else
    {
      sub_10002AA94(&v85);
      if (v84 < 0)
      {
        uint64_t v55 = __p[0];
        goto LABEL_64;
      }
    }

    *(void *)(a1 + 8) |= 4uLL;
    goto LABEL_66;
  }

LABEL_66:
  unsigned int v43 = *(_DWORD *)(a1 + 164);
  if (v43 || *(void *)(a1 + 64) != *(void *)(a1 + 72))
  {
    if ((v39 & 0x80) != 0 || (*(_DWORD *)(*(void *)(*(void *)(a1 + 24) + 16LL) + 4LL * v39) & v43) == 0) {
      int v44 = (v39 == 95) & (v43 >> 7);
    }
    else {
      LOBYTE(v44) = 1;
    }
    std::string::size_type v45 = *(void **)(a1 + 72);
    std::string::size_type v46 = memchr(*(const void **)(a1 + 64), (char)v39, (size_t)v45 - *(void *)(a1 + 64));
    BOOL v47 = v46 ? v46 : v45;
    if ((v44 & 1) == 0 && v47 == v45) {
      goto LABEL_77;
    }
  }

  uint64_t v49 = *(void *)(a1 + 88);
  uint64_t v48 = *(void *)(a1 + 96);
  if (v49 != v48)
  {
    if (*(_BYTE *)(a1 + 170))
    {
      sub_10001FB34(a1 + 16, (char *)&v121, (char *)&v122);
      uint64_t v49 = *(void *)(a1 + 88);
      uint64_t v48 = *(void *)(a1 + 96);
    }

    else
    {
      __p.__r_.__value_.__s.__size_ = 1;
      LOWORD(__p.__r_.__value_.__l.__data_) = v39;
    }

    uint64_t v50 = v48 - v49;
    if (v50)
    {
      uint64_t v117 = v37;
      int v114 = v36;
      uint64_t v51 = 0LL;
      unint64_t v52 = v50 / 48;
      unsigned __int8 v112 = __p.__r_.__value_.__s.__size_;
      if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
        std::string::size_type v53 = __p.__r_.__value_.__s.__size_;
      }
      else {
        std::string::size_type v53 = __p.__r_.__value_.__l.__size_;
      }
      if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
        unsigned __int8 v54 = &__p;
      }
      else {
        unsigned __int8 v54 = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      if (v52 <= 1) {
        uint64_t v55 = 1LL;
      }
      else {
        uint64_t v55 = v50 / 48;
      }
      BOOL v56 = 1;
      while (1)
      {
        int v57 = *(char *)(v49 + 23);
        if (v57 >= 0) {
          size_t v58 = *(unsigned __int8 *)(v49 + 23);
        }
        else {
          size_t v58 = *(void *)(v49 + 8);
        }
        if (v57 >= 0) {
          uint64_t v59 = (const void *)v49;
        }
        else {
          uint64_t v59 = *(const void **)v49;
        }
        if (v58 >= v53) {
          size_t v60 = v53;
        }
        else {
          size_t v60 = v58;
        }
        int v61 = memcmp(v54, v59, v60);
        BOOL v62 = v53 >= v58;
        if (v61) {
          BOOL v62 = v61 >= 0;
        }
        if (v62)
        {
          int v63 = *(char *)(v49 + 47);
          if (v63 >= 0) {
            size_t v64 = *(unsigned __int8 *)(v49 + 47);
          }
          else {
            size_t v64 = *(void *)(v49 + 32);
          }
          if (v63 >= 0) {
            uint64_t v65 = (const void *)(v49 + 24);
          }
          else {
            uint64_t v65 = *(const void **)(v49 + 24);
          }
          if (v53 >= v64) {
            size_t v66 = v64;
          }
          else {
            size_t v66 = v53;
          }
          int v67 = memcmp(v65, v54, v66);
          BOOL v68 = v64 >= v53;
          if (v67) {
            BOOL v68 = v67 >= 0;
          }
          if (v68) {
            break;
          }
        }

        BOOL v56 = ++v51 < v52;
        v49 += 48LL;
        if (v55 == v51)
        {
          int v36 = v114;
          goto LABEL_123;
        }
      }

      int v36 = 1;
LABEL_123:
      uint64_t v37 = v117;
      if ((v112 & 0x80) == 0) {
        goto LABEL_125;
      }
    }

    else
    {
      BOOL v56 = 0;
      if ((__p.__r_.__value_.__s.__size_ & 0x80) == 0) {
        goto LABEL_125;
      }
    }

    operator delete(__p.__r_.__value_.__l.__data_);
LABEL_125:
    if (v56) {
      goto LABEL_221;
    }
  }

  if (*(void *)(a1 + 136) == *(void *)(a1 + 144)) {
    goto LABEL_154;
  }
  sub_10001FE08(a1 + 16, (char *)&v121, (char *)&v122, (uint64_t)&__p);
  uint64_t v69 = *(void *)(a1 + 136);
  uint64_t v70 = __p.__r_.__value_.__s.__size_;
  uint64_t v71 = *(void *)(a1 + 144) - v69;
  if (v71)
  {
    uint64_t v118 = v37;
    uint64_t v72 = 0LL;
    unint64_t v73 = v71 / 24;
    __int128 v74 = *(_OWORD *)&__p.__r_.__value_.__l.__data_;
    if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      std::string::size_type v75 = __p.__r_.__value_.__s.__size_;
    }
    else {
      std::string::size_type v75 = __p.__r_.__value_.__l.__size_;
    }
    if (v73 <= 1) {
      uint64_t v76 = 1LL;
    }
    else {
      uint64_t v76 = v71 / 24;
    }
    BOOL v77 = 1;
    while (1)
    {
      uint64_t v78 = (unsigned __int8 **)(v69 + 24 * v72);
      uint64_t v79 = (unsigned __int8 *)*((unsigned __int8 *)v78 + 23);
      int v80 = (char)v79;
      if ((unsigned __int8 *)v75 == v79)
      {
        if (v80 >= 0) {
          int v81 = (unsigned __int8 *)(v69 + 24 * v72);
        }
        else {
          int v81 = *v78;
        }
        if ((v70 & 0x80) != 0)
        {
          int v115 = v36;
          unint64_t v84 = v73;
          uint64_t v113 = v76;
          int v85 = memcmp((const void *)v74, v81, *((size_t *)&v74 + 1));
          uint64_t v76 = v113;
          unint64_t v73 = v84;
          int v36 = v115;
          if (!v85)
          {
            int v36 = 1;
            uint64_t v37 = v118;
            goto LABEL_152;
          }
        }

        else
        {
          if (!(_DWORD)v70)
          {
            int v36 = 1;
            uint64_t v37 = v118;
            if (!v77) {
              goto LABEL_154;
            }
            goto LABEL_221;
          }

          v82 = &__p;
          uint64_t v83 = v70;
          while (v82->__r_.__value_.__s.__data_[0] == *v81)
          {
            v82 = (std::string *)((char *)v82 + 1);
            ++v81;
            if (!--v83)
            {
              int v36 = 1;
              goto LABEL_149;
            }
          }
        }
      }

      BOOL v77 = ++v72 < v73;
      if (v72 == v76)
      {
LABEL_149:
        uint64_t v37 = v118;
        if ((v70 & 0x80) == 0) {
          goto LABEL_153;
        }
        goto LABEL_152;
      }
    }
  }

  BOOL v77 = 0;
  if ((__p.__r_.__value_.__s.__size_ & 0x80) != 0) {
LABEL_152:
  }
    operator delete(__p.__r_.__value_.__l.__data_);
LABEL_153:
  if (!v77)
  {
LABEL_154:
    unsigned int v86 = *(_DWORD *)(a1 + 160);
    if ((*(_DWORD *)(*(void *)(*(void *)(a1 + 24) + 16LL) + 4LL * v121) & v86) == 0)
    {
      int v87 = (v86 >> 7) & 1;
      if (v121 != 95) {
        int v87 = 0;
      }
      if (v87 != 1) {
        goto LABEL_221;
      }
    }

    goto LABEL_77;
  }

      if (!--v32) {
        return;
      }
    }

    int v35 = (*(uint64_t (**)(void *, __n128))(*a1 + 96LL))(a1, v24);
    int v36 = (*(uint64_t (**)(void *))(*a1 + 104LL))(a1);
    (*(void (**)(uint8_t *__return_ptr, uint64_t, void))(*(void *)v35 + 72LL))(buf, v35, *(i - 3));
    (*(void (**)(void **__return_ptr, uint64_t, void))(*(void *)v36 + 72LL))(v63, v36, *(i - 2));
    if (v66 < 0)
    {
      if (*(void *)&buf[8] != 5LL) {
        goto LABEL_42;
      }
      uint64_t v37 = *(uint8_t **)buf;
    }

    else
    {
      if (v66 != 5) {
        goto LABEL_42;
      }
      uint64_t v37 = buf;
    }

    unint64_t v38 = *(_DWORD *)v37;
    unsigned __int8 v39 = v37[4];
    if (v38 != 1936745788 || v39 != 62) {
      goto LABEL_42;
    }
    if (v64 < 0)
    {
      unint64_t v52 = (void **)v63[0];
    }

    else
    {
      if (v64 != 5) {
        goto LABEL_42;
      }
      unint64_t v52 = v63;
    }

    unsigned __int8 v54 = *(_DWORD *)v52;
    uint64_t v55 = *((unsigned __int8 *)v52 + 4);
    if (v54 == 1936745788 && v55 == 62)
    {
LABEL_46:
      unsigned int v43 = *(void *)(a2 + 8);
      int v44 = wmemchr(*(const __int32 **)a2, *i, (v43 - *(void *)a2) >> 2);
      if (v44) {
        std::string::size_type v45 = (uint64_t)v44;
      }
      else {
        std::string::size_type v45 = v43;
      }
      if (v45 == *(void *)(a2 + 8))
      {
        std::string __p = 0LL;
        int v61 = 0LL;
        BOOL v62 = 0LL;
        sub_10008F49C(&__p, *(const void **)a2, v45, (v45 - *(void *)a2) >> 2);
        sub_100060B20(a1, &__p, *i, a4, a5);
        if (__p)
        {
          int v61 = __p;
          operator delete(__p);
        }
      }

      if (v66 < 0)
      {
        if (*(void *)&buf[8] != 5LL) {
          goto LABEL_61;
        }
        std::string::size_type v46 = *(uint8_t **)buf;
      }

      else
      {
        if (v66 != 5) {
          goto LABEL_61;
        }
        std::string::size_type v46 = buf;
      }

      BOOL v47 = *(_DWORD *)v46;
      uint64_t v48 = v46[4];
      if (v47 != 1936745788 || v48 != 62) {
        goto LABEL_61;
      }
      uint64_t v51 = v64;
      if (v64 < 0)
      {
        if (v63[1] == (void *)5)
        {
          std::string::size_type v53 = (void **)v63[0];
LABEL_84:
          int v57 = *(_DWORD *)v53;
          size_t v58 = *((unsigned __int8 *)v53 + 4);
          if (v57 == 1936745788 && v58 == 62) {
            goto LABEL_62;
          }
        }
      }

      else if (v64 == 5)
      {
        std::string::size_type v53 = v63;
        goto LABEL_84;
      }

LABEL_221:
  if (v36 == *(unsigned __int8 *)(a1 + 168))
  {
    uint64_t v109 = 0LL;
    int v110 = -993;
  }

  else
  {
    *(void *)(a2 + 16) += v37;
    uint64_t v109 = *(void *)(a1 + 8);
    int v110 = -995;
  }

  *(_DWORD *)a2 = v110;
  *(void *)(a2 + 8sub_10001AFB0((std::locale *)v24, " +$", 0) = v109;
}

void sub_10001FAA8(void ***a1)
{
  char v2 = *a1;
  if (*v2)
  {
    sub_10001FAE8((uint64_t *)v2);
    operator delete(**a1);
  }

void sub_10001FAE8(uint64_t *a1)
{
  uint64_t v2 = *a1;
  for (uint64_t i = a1[1]; i != v2; i -= 24LL)
  {
  }

  a1[1] = v2;
}

void sub_10001FB34(uint64_t a1, char *a2, char *a3)
{
  unint64_t v4 = v7;
  if ((v7 & 0x80u) == 0) {
    unsigned int v5 = __p;
  }
  else {
    unsigned int v5 = (void **)__p[0];
  }
  if ((v7 & 0x80u) != 0) {
    unint64_t v4 = (unint64_t)__p[1];
  }
  (*(void (**)(void, void **, char *))(**(void **)(a1 + 16) + 32LL))( *(void *)(a1 + 16),  v5,  (char *)v5 + v4);
}

void sub_10001FBB4( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_10001FBD0(uint64_t a1@<X0>, char *a2@<X1>, char *a3@<X2>, std::string *a4@<X8>)
{
  a4->__r_.__value_.__r.__words[0] = 0LL;
  a4->__r_.__value_.__l.__size_ = 0LL;
  a4->__r_.__value_.__l.__cap_ = 0LL;
  if ((char)__s.__r_.__value_.__s.__size_ < 0)
  {
    if (!__s.__r_.__value_.__l.__size_) {
      goto LABEL_9;
    }
    p_s = (std::string *)__s.__r_.__value_.__r.__words[0];
  }

  else
  {
    if (!__s.__r_.__value_.__s.__size_) {
      return;
    }
    p_s = &__s;
  }

  std::__get_collation_name(&v13, (const char *)p_s);
  *(_OWORD *)&a4->__r_.__value_.__l.__data_ = *(_OWORD *)&v13.__r_.__value_.__l.__data_;
  std::string::size_type cap = v13.__r_.__value_.__l.__cap_;
  a4->__r_.__value_.__l.__cap_ = v13.__r_.__value_.__l.__cap_;
  std::string::size_type size = HIBYTE(cap);
  if ((size & 0x80u) != 0LL) {
    std::string::size_type size = a4->__r_.__value_.__l.__size_;
  }
  if (size) {
    goto LABEL_9;
  }
  if ((char)__s.__r_.__value_.__s.__size_ < 0)
  {
    std::string::size_type v9 = __s.__r_.__value_.__l.__size_;
    if (__s.__r_.__value_.__l.__size_ >= 3) {
      goto LABEL_9;
    }
    uint64_t v10 = (std::string *)__s.__r_.__value_.__r.__words[0];
  }

  else
  {
    std::string::size_type v9 = __s.__r_.__value_.__s.__size_;
    if (__s.__r_.__value_.__s.__size_ >= 3u) {
      return;
    }
    uint64_t v10 = &__s;
  }

  (*(void (**)(std::string *__return_ptr, void, std::string *, char *))(**(void **)(a1 + 16) + 32LL))( &v13,  *(void *)(a1 + 16),  v10,  (char *)v10 + v9);
  *a4 = v13;
  if (((char)a4->__r_.__value_.__s.__size_ & 0x80000000) == 0)
  {
    int v11 = a4->__r_.__value_.__s.__size_;
    if (v11 != 12 && v11 != 1)
    {
      a4->__r_.__value_.__s.__data_[0] = 0;
      a4->__r_.__value_.__s.__size_ = 0;
      goto LABEL_9;
    }

    goto LABEL_25;
  }

  std::string::size_type v12 = a4->__r_.__value_.__l.__size_;
  if (v12 == 1 || v12 == 12)
  {
LABEL_25:
    std::string::operator=(a4, &__s);
    goto LABEL_9;
  }

  *a4->__r_.__value_.__l.__data_ = 0;
  a4->__r_.__value_.__l.__size_ = 0LL;
LABEL_9:
}

void sub_10001FD30( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void *sub_10001FD64(void *result, char *a2, char *a3, unint64_t a4)
{
  unint64_t v4 = result;
  if (a4 >= 0x7FFFFFFFFFFFFFF8LL) {
    sub_10000A38C();
  }
  if (a4 > 0x16)
  {
    uint64_t v8 = (a4 & 0xFFFFFFFFFFFFFFF8LL) + 8;
    if ((a4 | 7) != 0x17) {
      uint64_t v8 = a4 | 7;
    }
    uint64_t v9 = v8 + 1;
    uint64_t result = operator new(v8 + 1);
    v4[1] = a4;
    v4[2] = v9 | 0x8000000000000000LL;
    *unint64_t v4 = result;
    unint64_t v4 = result;
  }

  else
  {
    *((_BYTE *)result + 23) = a4;
  }

  while (a2 != a3)
  {
    char v10 = *a2++;
    *(_BYTE *)unint64_t v4 = v10;
    unint64_t v4 = (void *)((char *)v4 + 1);
  }

  *(_BYTE *)unint64_t v4 = 0;
  return result;
}

void sub_10001FE08(uint64_t a1@<X0>, char *a2@<X1>, char *a3@<X2>, uint64_t a4@<X8>)
{
  unint64_t v6 = v12;
  if ((v12 & 0x80u) == 0) {
    unsigned __int8 v7 = __p;
  }
  else {
    unsigned __int8 v7 = (void **)__p[0];
  }
  if ((v12 & 0x80u) != 0) {
    unint64_t v6 = (unint64_t)__p[1];
  }
  (*(void (**)(void, void **, char *))(**(void **)(a1 + 16) + 32LL))( *(void *)(a1 + 16),  v7,  (char *)v7 + v6);
  uint64_t v8 = *(unsigned __int8 *)(a4 + 23);
  int v9 = (char)v8;
  if ((v8 & 0x80u) != 0LL) {
    uint64_t v8 = *(void *)(a4 + 8);
  }
  if (v8 != 1)
  {
    if (v8 == 12)
    {
      if (v9 >= 0) {
        char v10 = (_BYTE *)a4;
      }
      else {
        char v10 = *(_BYTE **)a4;
      }
      v10[11] = v10[3];
    }

    else if (v9 < 0)
    {
      **(_BYTE **)a4 = 0;
      *(void *)(a4 + _Block_object_dispose(va, 8) = 0LL;
    }

    else
    {
      *(_BYTE *)a4 = 0;
      *(_BYTE *)(a4 + 23) = 0;
    }
  }

void sub_10001FEE0( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_10001FEFC()
{
  exception = (std::regex_error *)__cxa_allocate_exception(0x18uLL);
  std::regex_error::regex_error(exception, error_brack);
}

void sub_10001FF34(_Unwind_Exception *a1)
{
}

_BYTE *sub_10001FF48(uint64_t a1, char *a2, char *a3, uint64_t *a4)
{
  unint64_t v4 = a2;
  if (a2 == a3) {
    return v4;
  }
  int v5 = *a2;
  if (v5 == 93) {
    return v4;
  }
  uint64_t v6 = (uint64_t)a4;
  memset(&v26, 0, sizeof(v26));
  if (a2 + 1 == a3 || v5 != 91)
  {
LABEL_9:
    int v11 = *(_DWORD *)(a1 + 24) & 0x1F0;
    goto LABEL_10;
  }

  int v9 = a2[1];
  if (v9 != 46)
  {
    if (v9 == 58)
    {
      uint64_t v10 = sub_1000204D0(a1, a2 + 2, a3, (uint64_t)a4);
      goto LABEL_34;
    }

    if (v9 == 61)
    {
      uint64_t v10 = sub_1000202F4(a1, a2 + 2, a3, a4);
LABEL_34:
      uint64_t v6 = v10;
      char v20 = 0;
      goto LABEL_38;
    }

    goto LABEL_9;
  }

  uint64_t v18 = sub_100020588(a1, a2 + 2, a3, (uint64_t)&v26);
  unint64_t v4 = (_BYTE *)v18;
  int v11 = *(_DWORD *)(a1 + 24) & 0x1F0;
  std::string::size_type size = v26.__r_.__value_.__s.__size_;
  if ((v26.__r_.__value_.__s.__size_ & 0x80u) != 0) {
    std::string::size_type size = v26.__r_.__value_.__l.__size_;
  }
  uint64_t v14 = (char *)v18;
  if (!size)
  {
LABEL_10:
    if ((v11 | 0x40) == 0x40)
    {
      int v12 = *v4;
      if (v12 == 92)
      {
        std::string v13 = v4 + 1;
        if (v11)
        {
          uint64_t v14 = sub_10002079C(a1, v13, a3, &v26);
        }

        else
        {
          uint64_t v14 = (char *)sub_100020674(a1, (unsigned __int8 *)v13, a3, &v26, v6);
          int v11 = 0;
        }

        goto LABEL_16;
      }
    }

    else
    {
      LOBYTE(v12) = *v4;
    }

    std::string::operator=(&v26, v12);
    uint64_t v14 = v4 + 1;
  }

LABEL_37:
    char v20 = 1;
    unint64_t v4 = v14;
    goto LABEL_38;
  }

  memset(&v25, 0, sizeof(v25));
  unint64_t v4 = v14 + 2;
  if (v14 + 2 != a3 && *v16 == 91 && *v4 == 46)
  {
    uint64_t v22 = sub_100020588(a1, v14 + 3, a3, (uint64_t)&v25);
LABEL_55:
    unint64_t v4 = (_BYTE *)v22;
    goto LABEL_56;
  }

  if ((v11 | 0x40) == 0x40)
  {
    LODWORD(v16) = *v16;
    if ((_DWORD)v16 == 92)
    {
      if (v11) {
        uint64_t v22 = (uint64_t)sub_10002079C(a1, v14 + 2, a3, &v25);
      }
      else {
        uint64_t v22 = (uint64_t)sub_100020674(a1, (unsigned __int8 *)v14 + 2, a3, &v25, v6);
      }
      goto LABEL_55;
    }
  }

  else
  {
    LOBYTE(v16) = *v16;
  }

  std::string::operator=(&v25, (std::string::value_type)v16);
LABEL_56:
  std::string v24 = v26;
  memset(&v26, 0, sizeof(v26));
  std::string __p = v25;
  memset(&v25, 0, sizeof(v25));
  sub_100020974(v6, (char *)&v24, (char *)&__p);
  char v20 = 1;
LABEL_38:
  if ((v20 & 1) != 0) {
    return v4;
  }
  return (_BYTE *)v6;
}

  std::string v25 = *(const void ***)(a1 + 8);
  std::string v24 = *(const void ***)(a1 + 16);
  if (v25 == v24)
  {
LABEL_48:
    if (RXLogServerGrammar())
    {
      if (RXVeryVerbose())
      {
        int v29 = (os_log_s *)RXOSLog();
        if (os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)std::string buf = 136315138;
          *(void *)&uint8_t buf[4] = v56.__r_.__value_.__r.__words[0];
          _os_log_impl( (void *)&_mh_execute_header,  v29,  OS_LOG_TYPE_DEFAULT,  "Grammar: Building CategoryID -> %s",  buf,  0xCu);
        }
      }
    }

    size_t v30 = operator new(0x38uLL);
    uint64_t v31 = *(void *)(a1 + 40);
    *size_t v30 = 0LL;
    v30[1] = v31;
    v30[5] = 0LL;
    v30[4] = 0LL;
    uint64_t v30[3] = v30 + 4;
    __p.__r_.__value_.__r.__words[0] = (std::string::size_type)v30;
    RDQSRCategoryFst::Build((uint64_t)v30, xdict, *(void *)(a1 + 48));
    size_t v32 = (uint64_t *)__p.__r_.__value_.__r.__words[0];
    int v33 = *(void *)(a1 + 16);
    if (v33 >= *(void *)(a1 + 24))
    {
      int v35 = sub_100029468((uint64_t *)(a1 + 8), &v56.__r_.__value_.__l.__data_, (uint64_t *)__p.__r_.__value_.__l.__data_);
    }

    else
    {
      sub_10000A2DC(*(void **)(a1 + 16), v56.__r_.__value_.__l.__data_);
      BOOL v34 = *v32;
      char *v32 = 0LL;
      *(void *)(v33 + 24) = v34;
      int v35 = v33 + 32;
      *(void *)(a1 + 16) = v33 + 32;
    }

    *(void *)(a1 + 16) = v35;
    sub_10000A2DC(buf, v56.__r_.__value_.__l.__data_);
    sub_1000297F4((uint64_t **)(a1 + 112), (const void **)buf, (uint64_t)buf);
    if (SHIBYTE(cap) < 0) {
      operator delete(*(void **)buf);
    }
    uint64_t v48 = (void **)__p.__r_.__value_.__r.__words[0];
    __p.__r_.__value_.__r.__words[0] = 0LL;
    if (v48) {
      sub_10002941C((uint64_t)&__p, v48);
    }
    goto LABEL_98;
  }

  std::string v26 = (const void *)v56.__r_.__value_.__r.__words[0];
  int v27 = strlen(v56.__r_.__value_.__l.__data_);
  while ((*((char *)v25 + 23) & 0x80000000) == 0)
  {
    if (v27 == *((unsigned __int8 *)v25 + 23))
    {
      BOOL v28 = v25;
      if (v27 == -1LL) {
        goto LABEL_108;
      }
      goto LABEL_46;
    }

  CFRelease(Mutable);
LABEL_38:
  CFRelease(v16);
LABEL_39:
  std::string v26 = (const __CFString *)RDLanguageAssets::InstallAndCopyQuasarModelPathForLanguage( *((const __CFString **)this + 19),  v14);
  int v27 = v26;
  if (v26)
  {
    CFIndex Length = CFStringGetLength(v26);
    CFMutableStringRef MutableCopy = CFStringCreateMutableCopy(0LL, Length, v27);
    CFMutableStringRef Mutable = (CFMutableStringRef)MutableCopy;
    if (MutableCopy)
    {
      size_t v30 = CFStringGetLength(MutableCopy);
      if (CFStringGetCharacterAtIndex(Mutable, v30 - 1) != 47) {
        CFStringAppend(Mutable, @"/");
      }
    }

    CFRelease(v27);
  }

  else
  {
    CFMutableStringRef Mutable = 0LL;
  }

  if (SHIBYTE(v30) < 0) {
    operator delete(v29[1]);
  }
  if (SHIBYTE(v29[0]) < 0) {
    operator delete((void *)v28);
  }
LABEL_41:
  std::filebuf::~filebuf(v36);
  std::ios::~ios(&v37);
  return v8;
}

void sub_100020294( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20, char a21, uint64_t a22, void *a23, uint64_t a24, int a25, __int16 a26, char a27, char a28)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if (a21 < 0) {
    operator delete(a16);
  }
  if (a28 < 0) {
    operator delete(a23);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1000202F4(uint64_t a1, char *a2, char *a3, uint64_t *a4)
{
  if (a3 - a2 < 2 || a3 - 1 == a2) {
    goto LABEL_33;
  }
  for (uint64_t i = 0LL; a2[i] != 61 || a2[i + 1] != 93; ++i)
  {
    if (a3 - a2 - 2 == i) {
      goto LABEL_33;
    }
  }

  if (&a2[i] == a3) {
LABEL_33:
  }
    sub_10001FEFC();
  sub_10001FBD0(a1, a2, &a2[i], &v17);
  if (((char)v17.__r_.__value_.__s.__size_ & 0x80000000) == 0)
  {
    std::string::size_type size = v17.__r_.__value_.__s.__size_;
    if (v17.__r_.__value_.__s.__size_)
    {
      int v9 = &v17;
      goto LABEL_14;
    }

LABEL_34:
    sub_100020F60();
  }

  std::string::size_type size = v17.__r_.__value_.__l.__size_;
  if (!v17.__r_.__value_.__l.__size_) {
    goto LABEL_34;
  }
  int v9 = (std::string *)v17.__r_.__value_.__r.__words[0];
LABEL_14:
  sub_10001FE08(a1, (char *)v9, (char *)v9 + size, (uint64_t)__p);
  unint64_t v10 = v16;
  if ((v16 & 0x80u) != 0) {
    unint64_t v10 = (unint64_t)__p[1];
  }
  if (v10)
  {
    sub_100020FAC(a4, (__int128 *)__p);
  }

  else
  {
    std::string::size_type v11 = v17.__r_.__value_.__s.__size_;
    if ((v17.__r_.__value_.__s.__size_ & 0x80u) != 0) {
      std::string::size_type v11 = v17.__r_.__value_.__l.__size_;
    }
    if (v11 == 2)
    {
      std::string v13 = &v17;
      if ((v17.__r_.__value_.__s.__size_ & 0x80u) != 0) {
        std::string v13 = (std::string *)v17.__r_.__value_.__r.__words[0];
      }
      sub_100020D38( (uint64_t)a4,  v13->__r_.__value_.__s.__data_[0],  v13->__r_.__value_.__s.__data_[1]);
    }

    else
    {
      if (v11 != 1) {
        sub_100020F60();
      }
      int v12 = &v17;
      if ((v17.__r_.__value_.__s.__size_ & 0x80u) != 0) {
        int v12 = (std::string *)v17.__r_.__value_.__r.__words[0];
      }
      sub_10001ECBC((uint64_t)a4, v12->__r_.__value_.__s.__data_[0]);
    }
  }

  return (uint64_t)&a2[i + 2];
}

void sub_100020498( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a20 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1000204D0(uint64_t a1, char *a2, char *a3, uint64_t a4)
{
  if (a3 - a2 < 2 || a3 - 1 == a2) {
    goto LABEL_11;
  }
  for (uint64_t i = 0LL; a2[i] != 58 || a2[i + 1] != 93; ++i)
  {
    if (a3 - a2 - 2 == i) {
      goto LABEL_11;
    }
  }

  if (&a2[i] == a3) {
LABEL_11:
  }
    sub_10001FEFC();
  int v7 = sub_1000213C4(a1, a2, &a2[i], *(_BYTE *)(a1 + 24) & 1);
  if (!v7) {
    sub_100021378();
  }
  *(_DWORD *)(a4 + 160) |= v7;
  return (uint64_t)&a2[i + 2];
}

uint64_t sub_100020588(uint64_t a1, char *a2, char *a3, uint64_t a4)
{
  if (a3 - a2 < 2 || a3 - 1 == a2) {
    goto LABEL_15;
  }
  for (uint64_t i = 0LL; a2[i] != 46 || a2[i + 1] != 93; ++i)
  {
    if (a3 - a2 - 2 == i) {
      goto LABEL_15;
    }
  }

  if (&a2[i] == a3) {
LABEL_15:
  }
    sub_10001FEFC();
  sub_10001FBD0(a1, a2, &a2[i], &v10);
  *(_OWORD *)a4 = *(_OWORD *)&v10.__r_.__value_.__l.__data_;
  std::string::size_type cap = v10.__r_.__value_.__l.__cap_;
  *(void *)(a4 + 16) = v10.__r_.__value_.__l.__cap_;
  std::string::size_type v8 = HIBYTE(cap);
  if ((v8 & 0x80u) != 0LL) {
    std::string::size_type v8 = *(void *)(a4 + 8);
  }
  if (v8 - 1 >= 2) {
    sub_100020F60();
  }
  return (uint64_t)&a2[i + 2];
}

unsigned __int8 *sub_100020674(uint64_t a1, unsigned __int8 *a2, char *a3, std::string *this, uint64_t a5)
{
  int v6 = (char)*a2;
  if (v6 > 97)
  {
    if (v6 > 114)
    {
      if (v6 != 115)
      {
        if (v6 != 119) {
          return sub_10001DFD0(a1, a2, a3, this);
        }
        *(_DWORD *)(a5 + 160) |= 0x500u;
        sub_10001ECBC(a5, 95LL);
        return a2 + 1;
      }

      int v8 = *(_DWORD *)(a5 + 160) | 0x4000;
    }

    else
    {
      if (v6 == 98)
      {
        std::string v10 = this;
        std::string::value_type v9 = 8;
LABEL_19:
        std::string::operator=(v10, v9);
        return a2 + 1;
      }

      if (v6 != 100) {
        return sub_10001DFD0(a1, a2, a3, this);
      }
      int v8 = *(_DWORD *)(a5 + 160) | 0x400;
    }

    *(_DWORD *)(a5 + 16sub_10001AFB0((std::locale *)v24, " +$", 0) = v8;
    return a2 + 1;
  }

  if (v6 <= 82)
  {
    if (*a2)
    {
      if (v6 == 68)
      {
        int v7 = *(_DWORD *)(a5 + 164) | 0x400;
LABEL_21:
        *(_DWORD *)(a5 + 164) = v7;
        return a2 + 1;
      }

      return sub_10001DFD0(a1, a2, a3, this);
    }

    std::string::value_type v9 = 0;
    std::string v10 = this;
    goto LABEL_19;
  }

  if (v6 == 83)
  {
    int v7 = *(_DWORD *)(a5 + 164) | 0x4000;
    goto LABEL_21;
  }

  if (v6 == 87)
  {
    *(_DWORD *)(a5 + 164) |= 0x500u;
    sub_10002147C(a5, 95LL);
    return a2 + 1;
  }

  return sub_10001DFD0(a1, a2, a3, this);
}

char *sub_10002079C(uint64_t a1, char *a2, char *a3, std::string *this)
{
  if (a2 == a3) {
LABEL_52:
  }
    sub_10001DDFC();
  uint64_t v5 = *a2;
  if ((int)v5 > 97)
  {
    switch((int)v5)
    {
      case 'n':
        if (this)
        {
          int v6 = this;
          LOBYTE(v5) = 10;
          goto LABEL_16;
        }

        uint64_t v5 = 10LL;
        goto LABEL_49;
      case 'o':
      case 'p':
      case 'q':
      case 's':
      case 'u':
        goto LABEL_21;
      case 'r':
        if (this)
        {
          int v6 = this;
          LOBYTE(v5) = 13;
          goto LABEL_16;
        }

        uint64_t v5 = 13LL;
        goto LABEL_49;
      case 't':
        if (this)
        {
          int v6 = this;
          LOBYTE(v5) = 9;
          goto LABEL_16;
        }

        uint64_t v5 = 9LL;
        goto LABEL_49;
      case 'v':
        if (this)
        {
          int v6 = this;
          LOBYTE(v5) = 11;
          goto LABEL_16;
        }

        uint64_t v5 = 11LL;
        goto LABEL_49;
      default:
        if ((_DWORD)v5 == 98)
        {
          if (this)
          {
            int v6 = this;
            LOBYTE(v5) = 8;
            goto LABEL_16;
          }

          uint64_t v5 = 8LL;
        }

        else
        {
          if ((_DWORD)v5 != 102) {
            goto LABEL_21;
          }
          if (this)
          {
            int v6 = this;
            LOBYTE(v5) = 12;
            goto LABEL_16;
          }

          uint64_t v5 = 12LL;
        }

        break;
    }

    goto LABEL_49;
  }

  if ((int)v5 > 91)
  {
    if ((_DWORD)v5 != 92)
    {
      if ((_DWORD)v5 != 97) {
        goto LABEL_21;
      }
      if (this)
      {
        int v6 = this;
        LOBYTE(v5) = 7;
LABEL_16:
        std::string::operator=(v6, v5);
        return a2 + 1;
      }

      uint64_t v5 = 7LL;
LABEL_49:
      sub_10001E29C(a1, v5);
      return a2 + 1;
    }

LABEL_14:
    if (this)
    {
      int v6 = this;
      goto LABEL_16;
    }

    goto LABEL_49;
  }

  if ((_DWORD)v5 == 34 || (_DWORD)v5 == 47) {
    goto LABEL_14;
  }
LABEL_21:
  if ((v5 & 0xFFFFFFF8) != 0x30) {
    goto LABEL_52;
  }
  std::string::value_type v7 = v5 - 48;
  int v8 = a2 + 1;
  if (a2 + 1 != a3)
  {
    if ((*v8 & 0xF8) != 0x30) {
      goto LABEL_39;
    }
    std::string::value_type v7 = *v8 + 8 * v7 - 48;
    if (a2 + 2 != a3)
    {
      char v9 = a2[2];
      int v10 = v9 & 0xF8;
      std::string::value_type v11 = v9 + 8 * v7 - 48;
      if (v10 == 48) {
        int v8 = a2 + 3;
      }
      else {
        int v8 = a2 + 2;
      }
      if (v10 == 48) {
        std::string::value_type v7 = v11;
      }
      goto LABEL_39;
    }
  }

  int v8 = a3;
LABEL_39:
  if (this) {
    std::string::operator=(this, v7);
  }
  else {
    sub_10001E29C(a1, v7);
  }
  return v8;
}

    sub_10001CF40( (char **)a4,  0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a4 + 8) - *(void *)a4) >> 3),  (__int128 *)(a4 + 24));
    if (sub_10002356C(a1, a3, a3, (uint64_t *)a4, v14, 0))
    {
      if (*(void *)(a4 + 8) == *(void *)a4) {
        int v10 = (uint64_t *)(a4 + 24);
      }
      else {
        int v10 = *(uint64_t **)a4;
      }
      goto LABEL_8;
    }
  }

  uint64_t result = 0LL;
  *(void *)(a4 + _Block_object_dispose(va, 8) = *(void *)a4;
  return result;
}

        std::string::value_type v11 = v22;
        uint64_t v22 = 0LL;
        if (v11) {
          sub_100034D1C((uint64_t)&v22, v11);
        }
        int v12 = (void *)v5[1];
        if (v12)
        {
          do
          {
            std::string v13 = v12;
            int v12 = (void *)*v12;
          }

          while (v12);
        }

        else
        {
          do
          {
            std::string v13 = (void *)v5[2];
            uint64_t v14 = *v13 == (void)v5;
            uint64_t v5 = v13;
          }

          while (!v14);
        }

        uint64_t v5 = v13;
      }

      while (v13 != v3 + 4);
    }

    RDQSRPeer::updateLMCache((uint64_t)this, xdict, (uint64_t)(v3 + 3));
  }

  else
  {
    int v15 = (os_log_s *)RXOSLog();
    if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)char v20 = 134217984;
      *(void *)&v20[4] = uint64;
      _os_log_impl( (void *)&_mh_execute_header,  v15,  OS_LOG_TYPE_ERROR,  "LMCache: Language ID %llu was not stored in cache and is updated",  v20,  0xCu);
    }
  }

void sub_100020974(uint64_t a1, char *a2, char *a3)
{
  uint64_t v3 = a3;
  unint64_t v4 = a2;
  if (*(_BYTE *)(a1 + 170))
  {
    if (*(_BYTE *)(a1 + 169))
    {
      for (unint64_t i = 0LL; ; ++i)
      {
        unint64_t v7 = v4[23] < 0 ? *((void *)v4 + 1) : v4[23];
        if (i >= v7) {
          break;
        }
        int v8 = v4;
        if (v4[23] < 0) {
          int v8 = *(char **)v4;
        }
        char v9 = (*(uint64_t (**)(void, void))(**(void **)(a1 + 24) + 40LL))( *(void *)(a1 + 24),  v8[i]);
        int v10 = v4;
        if (v4[23] < 0) {
          int v10 = *(char **)v4;
        }
        v10[i] = v9;
      }

      for (unint64_t j = 0LL; ; ++j)
      {
        unint64_t v12 = v3[23] < 0 ? *((void *)v3 + 1) : v3[23];
        if (j >= v12) {
          break;
        }
        std::string v13 = v3;
        if (v3[23] < 0) {
          std::string v13 = *(char **)v3;
        }
        char v14 = (*(uint64_t (**)(void, void))(**(void **)(a1 + 24) + 40LL))( *(void *)(a1 + 24),  v13[j]);
        int v15 = v3;
        if (v3[23] < 0) {
          int v15 = *(char **)v3;
        }
        v15[j] = v14;
      }
    }

    else
    {
      for (unint64_t k = 0LL; ; ++k)
      {
        unint64_t v18 = a2[23] < 0 ? *((void *)a2 + 1) : a2[23];
        if (k >= v18) {
          break;
        }
        std::string::size_type v19 = a2;
        if (a2[23] < 0) {
          std::string::size_type v19 = *(char **)a2;
        }
        char v20 = a2;
        if (a2[23] < 0) {
          char v20 = *(char **)a2;
        }
        v20[k] = v19[k];
      }

      for (unint64_t m = 0LL; ; ++m)
      {
        unint64_t v22 = a3[23] < 0 ? *((void *)a3 + 1) : a3[23];
        if (m >= v22) {
          break;
        }
        int v23 = a3;
        if (a3[23] < 0) {
          int v23 = *(char **)a3;
        }
        std::string v24 = a3;
        if (a3[23] < 0) {
          std::string v24 = *(char **)a3;
        }
        v24[m] = v23[m];
      }
    }

    if (v4[23] < 0)
    {
      std::string v26 = v4;
      unint64_t v4 = *(char **)v4;
      uint64_t v25 = *((void *)v26 + 1);
    }

    else
    {
      uint64_t v25 = v4[23];
    }

    sub_10001FB34(a1 + 16, v4, &v4[v25]);
    if (v3[23] < 0)
    {
      uint64_t v28 = v3;
      uint64_t v3 = *(char **)v3;
      uint64_t v27 = *((void *)v28 + 1);
    }

    else
    {
      uint64_t v27 = v3[23];
    }

    sub_10001FB34(a1 + 16, v3, &v3[v27]);
    *(_OWORD *)__int128 v40 = v38;
    uint64_t v41 = v39;
    *(_OWORD *)std::string __p = *(_OWORD *)v36;
    uint64_t v43 = v37;
    sub_1000216A8((uint64_t *)(a1 + 88), (__int128 *)v40);
    if (SHIBYTE(v43) < 0) {
      operator delete(__p[0]);
    }
    if (SHIBYTE(v41) < 0) {
      operator delete(v40[0]);
    }
  }

  else
  {
    if (a2[23] < 0) {
      uint64_t v16 = *((void *)a2 + 1);
    }
    else {
      uint64_t v16 = a2[23];
    }
    if (*(_BYTE *)(a1 + 169))
    {
      size_t v30 = a2;
      if (a2[23] < 0) {
        size_t v30 = *(char **)a2;
      }
      char v31 = (*(uint64_t (**)(void, void))(**(void **)(a1 + 24) + 40LL))( *(void *)(a1 + 24),  *v30);
      size_t v32 = v4;
      if (v4[23] < 0) {
        size_t v32 = *(_BYTE **)v4;
      }
      _BYTE *v32 = v31;
      int v33 = v3;
      if (v3[23] < 0) {
        int v33 = *(char **)v3;
      }
      char v34 = (*(uint64_t (**)(void, void))(**(void **)(a1 + 24) + 40LL))( *(void *)(a1 + 24),  *v33);
      int v35 = v3;
      if (v3[23] < 0) {
        int v35 = *(_BYTE **)v3;
      }
      *int v35 = v34;
    }

    *(_OWORD *)__int128 v40 = *(_OWORD *)v4;
    uint64_t v41 = *((void *)v4 + 2);
    *((void *)v4 + 1) = 0LL;
    *((void *)v4 + 2) = 0LL;
    *(void *)unint64_t v4 = 0LL;
    *(_OWORD *)std::string __p = *(_OWORD *)v3;
    uint64_t v43 = *((void *)v3 + 2);
    *(void *)uint64_t v3 = 0LL;
    *((void *)v3 + 1) = 0LL;
    *((void *)v3 + 2) = 0LL;
    sub_1000216A8((uint64_t *)(a1 + 88), (__int128 *)v40);
    if (SHIBYTE(v43) < 0) {
      operator delete(__p[0]);
    }
    if (SHIBYTE(v41) < 0) {
      operator delete(v40[0]);
    }
  }

void sub_100020CEC( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20, char a21)
{
}

void sub_100020D38(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (!*(_BYTE *)(a1 + 169))
  {
    uint64_t v18 = a1 + 128;
    unint64_t v19 = *(void *)(a1 + 128);
    int v10 = (char **)(a1 + 112);
    __int16 v8 = a2 | (unsigned __int16)((_WORD)a3 << 8);
    char v9 = *(_WORD **)(a1 + 120);
    if (*(_BYTE *)(a1 + 170))
    {
      uint64_t v20 = (char *)v9 - *v10;
      if (v20 > -3)
      {
        uint64_t v21 = v20 >> 1;
        unint64_t v22 = v19 - (void)*v10;
        if (v22 <= (v20 >> 1) + 1) {
          unint64_t v23 = v21 + 1;
        }
        else {
          unint64_t v23 = v22;
        }
        if (v22 >= 0x7FFFFFFFFFFFFFFELL) {
          uint64_t v24 = 0x7FFFFFFFFFFFFFFFLL;
        }
        else {
          uint64_t v24 = v23;
        }
        if (v24) {
          uint64_t v25 = (char *)sub_10002185C(v18, v24);
        }
        else {
          uint64_t v25 = 0LL;
        }
        uint64_t v27 = &v25[2 * v21];
        uint64_t v28 = &v25[2 * v24];
        *(_WORD *)uint64_t v27 = v8;
        std::string v26 = v27 + 2;
        __int128 v38 = *(char **)(a1 + 112);
        uint64_t v29 = *(char **)(a1 + 120);
        if (v29 == v38) {
          goto LABEL_46;
        }
        do
        {
          __int16 v39 = *((_WORD *)v29 - 1);
          v29 -= 2;
          *((_WORD *)v27 - 1) = v39;
          v27 -= 2;
        }

        while (v29 != v38);
        goto LABEL_45;
      }
    }

    else
    {
      uint64_t v32 = (char *)v9 - *v10;
      if (v32 > -3)
      {
        uint64_t v33 = v32 >> 1;
        unint64_t v34 = v19 - (void)*v10;
        if (v34 <= (v32 >> 1) + 1) {
          unint64_t v35 = v33 + 1;
        }
        else {
          unint64_t v35 = v34;
        }
        if (v34 >= 0x7FFFFFFFFFFFFFFELL) {
          uint64_t v36 = 0x7FFFFFFFFFFFFFFFLL;
        }
        else {
          uint64_t v36 = v35;
        }
        if (v36) {
          uint64_t v37 = (char *)sub_10002185C(v18, v36);
        }
        else {
          uint64_t v37 = 0LL;
        }
        uint64_t v27 = &v37[2 * v33];
        uint64_t v28 = &v37[2 * v36];
        *(_WORD *)uint64_t v27 = v8;
        std::string v26 = v27 + 2;
        __int128 v40 = *(char **)(a1 + 112);
        uint64_t v29 = *(char **)(a1 + 120);
        if (v29 == v40) {
          goto LABEL_46;
        }
        do
        {
          __int16 v41 = *((_WORD *)v29 - 1);
          v29 -= 2;
          *((_WORD *)v27 - 1) = v41;
          v27 -= 2;
        }

        while (v29 != v40);
        goto LABEL_45;
      }
    }

LABEL_49:
    sub_100018774();
  }

  unsigned __int8 v5 = (*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 24) + 40LL))(*(void *)(a1 + 24), a2);
  __int16 v6 = (*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 24) + 40LL))(*(void *)(a1 + 24), a3);
  unint64_t v7 = *(void *)(a1 + 128);
  __int16 v8 = v5 | (unsigned __int16)(v6 << 8);
  char v9 = *(_WORD **)(a1 + 120);
  if ((unint64_t)v9 < v7)
  {
LABEL_24:
    *char v9 = v8;
    std::string v26 = v9 + 1;
    goto LABEL_48;
  }

  int v10 = (char **)(a1 + 112);
  uint64_t v11 = *(void *)(a1 + 112);
  uint64_t v12 = (uint64_t)v9 - v11;
  uint64_t v13 = v12 >> 1;
  unint64_t v14 = v7 - v11;
  if (v14 <= (v12 >> 1) + 1) {
    unint64_t v15 = v13 + 1;
  }
  else {
    unint64_t v15 = v14;
  }
  if (v14 >= 0x7FFFFFFFFFFFFFFELL) {
    uint64_t v16 = 0x7FFFFFFFFFFFFFFFLL;
  }
  else {
    uint64_t v16 = v15;
  }
  if (v16) {
    std::string v17 = (char *)sub_10002185C(a1 + 128, v16);
  }
  else {
    std::string v17 = 0LL;
  }
  uint64_t v27 = &v17[2 * v13];
  uint64_t v28 = &v17[2 * v16];
  *(_WORD *)uint64_t v27 = v8;
  std::string v26 = v27 + 2;
  size_t v30 = *(char **)(a1 + 112);
  uint64_t v29 = *(char **)(a1 + 120);
  if (v29 == v30) {
    goto LABEL_46;
  }
  do
  {
    __int16 v31 = *((_WORD *)v29 - 1);
    v29 -= 2;
    *((_WORD *)v27 - 1) = v31;
    v27 -= 2;
  }

  while (v29 != v30);
LABEL_45:
  uint64_t v29 = *v10;
LABEL_46:
  *(void *)(a1 + 112) = v27;
  *(void *)(a1 + 12sub_10001AFB0((std::locale *)v24, " +$", 0) = v26;
  *(void *)(a1 + 12_Block_object_dispose(va, 8) = v28;
  if (v29) {
    operator delete(v29);
  }
LABEL_48:
  *(void *)(a1 + 12sub_10001AFB0((std::locale *)v24, " +$", 0) = v26;
}

void sub_100020F60()
{
  exception = (std::regex_error *)__cxa_allocate_exception(0x18uLL);
  std::regex_error::regex_error(exception, error_collate);
}

void sub_100020F98(_Unwind_Exception *a1)
{
}

uint64_t sub_100020FAC(uint64_t *a1, __int128 *a2)
{
  uint64_t v3 = a1 + 17;
  unint64_t v4 = a1[18];
  if (v4 >= a1[19])
  {
    uint64_t result = sub_100021048(v3, a2);
  }

  else
  {
    sub_100020FEC(v3, a2);
    uint64_t result = v4 + 24;
  }

  a1[18] = result;
  return result;
}

void *sub_100020FEC(void *result, __int128 *a2)
{
  uint64_t v2 = result;
  uint64_t v3 = result[1];
  if (*((char *)a2 + 23) < 0)
  {
    uint64_t result = sub_10005AA70((_BYTE *)result[1], *(void **)a2, *((void *)a2 + 1));
  }

  else
  {
    __int128 v4 = *a2;
    *(void *)(v3 + 16) = *((void *)a2 + 2);
    *(_OWORD *)uint64_t v3 = v4;
  }

  v2[1] = v3 + 24;
  return result;
}

void sub_100021040(_Unwind_Exception *a1)
{
  *(void *)(v1 + _Block_object_dispose(va, 8) = v2;
  _Unwind_Resume(a1);
}

uint64_t sub_100021048(uint64_t *a1, __int128 *a2)
{
  uint64_t v3 = *a1;
  unint64_t v4 = 0xAAAAAAAAAAAAAAABLL * ((a1[1] - *a1) >> 3);
  unint64_t v5 = v4 + 1;
  if (v4 + 1 > 0xAAAAAAAAAAAAAAALL) {
    sub_100018774();
  }
  uint64_t v7 = (uint64_t)(a1 + 2);
  unint64_t v8 = 0xAAAAAAAAAAAAAAABLL * ((a1[2] - v3) >> 3);
  if (2 * v8 > v5) {
    unint64_t v5 = 2 * v8;
  }
  if (v8 >= 0x555555555555555LL) {
    unint64_t v9 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v9 = v5;
  }
  uint64_t v18 = a1 + 2;
  if (v9) {
    int v10 = (char *)sub_100018F00(v7, v9);
  }
  else {
    int v10 = 0LL;
  }
  uint64_t v11 = &v10[24 * v4];
  v15[0] = v10;
  v15[1] = v11;
  uint64_t v16 = v11;
  std::string v17 = &v10[24 * v9];
  if (*((char *)a2 + 23) < 0)
  {
    sub_10005AA70(v11, *(void **)a2, *((void *)a2 + 1));
    uint64_t v11 = v16;
  }

  else
  {
    __int128 v12 = *a2;
    *((void *)v11 + 2) = *((void *)a2 + 2);
    *(_OWORD *)uint64_t v11 = v12;
  }

  uint64_t v16 = v11 + 24;
  sub_100021168(a1, v15);
  uint64_t v13 = a1[1];
  sub_1000212F0((uint64_t)v15);
  return v13;
}

void sub_100021154(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

uint64_t sub_100021168(uint64_t *a1, void *a2)
{
  uint64_t result = sub_1000211DC((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t sub_1000211DC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7 = a7;
  *(void *)&__int128 v15 = a6;
  *((void *)&v15 + 1) = a7;
  __int128 v14 = v15;
  v12[0] = a1;
  v12[1] = &v14;
  v12[2] = &v15;
  if (a3 != a5)
  {
    uint64_t v9 = a7;
    do
    {
      __int128 v10 = *(_OWORD *)(a3 - 24);
      *(void *)(v9 - _Block_object_dispose(va, 8) = *(void *)(a3 - 8);
      *(_OWORD *)(v9 - 24) = v10;
      v9 -= 24LL;
      *(void *)(a3 - 16) = 0LL;
      *(void *)(a3 - _Block_object_dispose(va, 8) = 0LL;
      *(void *)(a3 - 24) = 0LL;
      v7 -= 24LL;
      a3 -= 24LL;
    }

    while (a3 != a5);
    *((void *)&v15 + 1) = v9;
  }

  char v13 = 1;
  sub_100021278((uint64_t)v12);
  return a6;
}

uint64_t sub_100021278(uint64_t a1)
{
  if (!*(_BYTE *)(a1 + 24)) {
    sub_1000212AC(a1);
  }
  return a1;
}

void sub_1000212AC(uint64_t a1)
{
  uint64_t v1 = *(void *)(*(void *)(a1 + 16) + 8LL);
  uint64_t v2 = *(void *)(*(void *)(a1 + 8) + 8LL);
  while (v1 != v2)
  {
    v1 += 24LL;
  }

uint64_t sub_1000212F0(uint64_t a1)
{
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void sub_100021324(uint64_t a1, void **a2)
{
  uint64_t v2 = *(void ***)(a1 + 16);
  if (v2 != a2)
  {
    do
    {
      uint64_t v5 = v2 - 3;
      *(void *)(a1 + 16) = v2 - 3;
      if (*((char *)v2 - 1) < 0)
      {
        operator delete(*v5);
        uint64_t v5 = *(void ***)(a1 + 16);
      }

      uint64_t v2 = v5;
    }

    while (v5 != a2);
  }

void sub_100021378()
{
  exception = (std::regex_error *)__cxa_allocate_exception(0x18uLL);
  std::regex_error::regex_error(exception, error_ctype);
}

void sub_1000213B0(_Unwind_Exception *a1)
{
}

uint64_t sub_1000213C4(uint64_t a1, char *a2, char *a3, BOOL a4)
{
  unint64_t v6 = v12;
  if ((v12 & 0x80u) == 0) {
    uint64_t v7 = __p;
  }
  else {
    uint64_t v7 = (void **)__p[0];
  }
  if ((v12 & 0x80u) != 0) {
    unint64_t v6 = (unint64_t)__p[1];
  }
  (*(void (**)(void, void **, char *))(**(void **)(a1 + 8) + 48LL))( *(void *)(a1 + 8),  v7,  (char *)v7 + v6);
  if ((v12 & 0x80u) == 0) {
    uint64_t v8 = __p;
  }
  else {
    uint64_t v8 = (void **)__p[0];
  }
  uint64_t classname = std::__get_classname((const char *)v8, a4);
  return classname;
}

void sub_100021460( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_10002147C(uint64_t a1, uint64_t a2)
{
  char v2 = a2;
  if (*(_BYTE *)(a1 + 169))
  {
    char v2 = (*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 24) + 40LL))(*(void *)(a1 + 24), a2);
    uint64_t v5 = *(_BYTE **)(a1 + 72);
    unint64_t v4 = *(void *)(a1 + 80);
    if ((unint64_t)v5 >= v4)
    {
      unint64_t v6 = (unint64_t *)(a1 + 64);
      unint64_t v7 = *(void *)(a1 + 64);
      uint64_t v8 = &v5[-v7];
      uint64_t v9 = (uint64_t)&v5[-v7 + 1];
      if (v9 >= 0)
      {
        unint64_t v10 = v4 - v7;
        if (2 * v10 > v9) {
          uint64_t v9 = 2 * v10;
        }
        if (v10 >= 0x3FFFFFFFFFFFFFFFLL) {
          size_t v11 = 0x7FFFFFFFFFFFFFFFLL;
        }
        else {
          size_t v11 = v9;
        }
        if (v11) {
          unsigned __int8 v12 = operator new(v11);
        }
        else {
          unsigned __int8 v12 = 0LL;
        }
        uint64_t v20 = &v8[(void)v12];
        uint64_t v21 = (char *)v12 + v11;
        v8[(void)v12] = v2;
        uint64_t v19 = (uint64_t)&v8[(void)v12 + 1];
        if (v5 != (_BYTE *)v7)
        {
          unint64_t v22 = &v5[~v7];
          do
          {
            char v23 = *--v5;
            (v22--)[(void)v12] = v23;
          }

          while (v5 != (_BYTE *)v7);
LABEL_45:
          uint64_t v5 = (_BYTE *)*v6;
          goto LABEL_47;
        }

        goto LABEL_46;
      }

void **sub_1000216A8(uint64_t *a1, __int128 *a2)
{
  unint64_t v6 = a1[2];
  uint64_t result = (void **)(a1 + 2);
  unint64_t v5 = v6;
  unint64_t v7 = (unint64_t)*(result - 1);
  if (v7 >= v6)
  {
    unint64_t v11 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v7 - *a1) >> 4);
    unint64_t v12 = v11 + 1;
    if (v11 + 1 > 0x555555555555555LL) {
      sub_100018774();
    }
    unint64_t v13 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v5 - *a1) >> 4);
    if (2 * v13 > v12) {
      unint64_t v12 = 2 * v13;
    }
    if (v13 >= 0x2AAAAAAAAAAAAAALL) {
      unint64_t v14 = 0x555555555555555LL;
    }
    else {
      unint64_t v14 = v12;
    }
    v19[4] = result;
    if (v14) {
      __int128 v15 = (char *)sub_100019FD4((uint64_t)result, v14);
    }
    else {
      __int128 v15 = 0LL;
    }
    unint64_t v16 = &v15[48 * v11];
    v19[0] = v15;
    v19[1] = v16;
    v19[3] = &v15[48 * v14];
    __int128 v17 = *a2;
    *((void *)v16 + 2) = *((void *)a2 + 2);
    *(_OWORD *)unint64_t v16 = v17;
    *((void *)a2 + 1) = 0LL;
    *((void *)a2 + 2) = 0LL;
    *(void *)a2 = 0LL;
    __int128 v18 = *(__int128 *)((char *)a2 + 24);
    *((void *)v16 + 5) = *((void *)a2 + 5);
    *(_OWORD *)(v16 + 24) = v18;
    *((void *)a2 + 4) = 0LL;
    *((void *)a2 + 5) = 0LL;
    *((void *)a2 + 3) = 0LL;
    v19[2] = v16 + 48;
    sub_10001A298(a1, v19);
    uint64_t v10 = a1[1];
    uint64_t result = sub_10001A444(v19);
  }

  else
  {
    __int128 v8 = *a2;
    *(void *)(v7 + 16) = *((void *)a2 + 2);
    *(_OWORD *)unint64_t v7 = v8;
    *((void *)a2 + 1) = 0LL;
    *((void *)a2 + 2) = 0LL;
    *(void *)a2 = 0LL;
    __int128 v9 = *(__int128 *)((char *)a2 + 24);
    *(void *)(v7 + 4sub_10001AFB0((std::locale *)v24, " +$", 0) = *((void *)a2 + 5);
    *(_OWORD *)(v7 + 24) = v9;
    *((void *)a2 + 4) = 0LL;
    *((void *)a2 + 5) = 0LL;
    *((void *)a2 + 3) = 0LL;
    uint64_t v10 = v7 + 48;
    a1[1] = v7 + 48;
  }

  a1[1] = v10;
  return result;
}

void sub_1000217FC(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

void sub_100021810()
{
  exception = (std::regex_error *)__cxa_allocate_exception(0x18uLL);
  std::regex_error::regex_error(exception, error_range);
}

void sub_100021848(_Unwind_Exception *a1)
{
}

void *sub_10002185C(uint64_t a1, uint64_t a2)
{
  if (a2 < 0) {
    sub_100017F08();
  }
  return operator new(2 * a2);
}

void *sub_10002188C(void *a1)
{
  *a1 = &off_1000CE570;
  uint64_t v2 = a1[1];
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8LL))(v2);
  }
  return a1;
}

void sub_1000218D0(void *__p)
{
  *std::string __p = &off_1000CE570;
  uint64_t v2 = __p[1];
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8LL))(v2);
  }
  operator delete(__p);
}

uint64_t sub_100021914(uint64_t result, uint64_t a2)
{
  *(_DWORD *)a2 = -994;
  *(void *)(*(void *)(a2 + 32) + 24LL * (*(_DWORD *)(result + 16) - 1)) = *(void *)(a2 + 16);
  *(void *)(a2 + 8sub_10001AFB0((std::locale *)v24, " +$", 0) = *(void *)(result + 8);
  return result;
}

void *sub_100021944(void *a1)
{
  *a1 = &off_1000CE570;
  uint64_t v2 = a1[1];
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8LL))(v2);
  }
  return a1;
}

void sub_100021988(void *__p)
{
  *std::string __p = &off_1000CE570;
  uint64_t v2 = __p[1];
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8LL))(v2);
  }
  operator delete(__p);
}

uint64_t sub_1000219CC(uint64_t result, uint64_t a2)
{
  *(_DWORD *)a2 = -994;
  uint64_t v2 = *(void *)(a2 + 32) + 24LL * (*(_DWORD *)(result + 16) - 1);
  *(void *)(v2 + _Block_object_dispose(va, 8) = *(void *)(a2 + 16);
  *(_BYTE *)(v2 + 16) = 1;
  *(void *)(a2 + 8sub_10001AFB0((std::locale *)v24, " +$", 0) = *(void *)(result + 8);
  return result;
}

void *sub_100021A04(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5, int a6, char a7)
{
  unint64_t v14 = operator new(0x10uLL);
  uint64_t v15 = *(void *)(a1 + 56);
  uint64_t v16 = *(void *)(v15 + 8);
  *unint64_t v14 = &off_1000CE4F8;
  v14[1] = v16;
  *(void *)(v15 + _Block_object_dispose(va, 8) = 0LL;
  __int128 v17 = operator new(0x38uLL);
  LODWORD(v16) = *(_DWORD *)(a1 + 32);
  uint64_t v18 = *(void *)(a4 + 8);
  *__int128 v17 = &off_1000CE990;
  v17[1] = v18;
  v17[2] = v14;
  v17[3] = a2;
  v17[4] = a3;
  *((_DWORD *)v17 + 1sub_10001AFB0((std::locale *)v24, " +$", 0) = v16;
  *((_DWORD *)v17 + 11) = a5;
  *((_DWORD *)v17 + 12) = a6;
  *((_BYTE *)v17 + 52) = a7;
  *(void *)(a4 + _Block_object_dispose(va, 8) = 0LL;
  uint64_t result = operator new(0x10uLL);
  void *result = &off_1000CEA20;
  result[1] = v17;
  *(void *)(*(void *)(a1 + 56) + 8LL) = result;
  *(void *)(a1 + 56) = v17[2];
  *(void *)(a4 + _Block_object_dispose(va, 8) = v17;
  *(_DWORD *)(a1 + 32) = v16 + 1;
  return result;
}

void sub_100021AF0(_Unwind_Exception *a1)
{
}

unsigned __int8 *sub_100021B38(uint64_t a1, unsigned __int8 *a2, unsigned __int8 *a3, int *a4)
{
  if (a2 != a3)
  {
    int v4 = *a2;
    if ((v4 & 0xF8) == 0x30 || (v4 & 0xFE) == 0x38)
    {
      int v5 = v4 - 48;
      *a4 = v5;
      if (++a2 == a3)
      {
        return a3;
      }

      else
      {
        while (1)
        {
          int v6 = *a2;
          if ((v6 & 0xF8) != 0x30 && (v6 & 0xFE) != 0x38) {
            break;
          }
          if (v5 >= 214748364) {
            sub_100021BD4();
          }
          int v5 = v6 + 10 * v5 - 48;
          *a4 = v5;
          if (++a2 == a3) {
            return a3;
          }
        }
      }
    }
  }

  return a2;
}

void sub_100021BD4()
{
  exception = (std::regex_error *)__cxa_allocate_exception(0x18uLL);
  std::regex_error::regex_error(exception, error_badbrace);
}

void sub_100021C0C(_Unwind_Exception *a1)
{
}

void sub_100021C20()
{
  exception = (std::regex_error *)__cxa_allocate_exception(0x18uLL);
  std::regex_error::regex_error(exception, error_brace);
}

void sub_100021C58(_Unwind_Exception *a1)
{
}

void *sub_100021C6C(void *a1)
{
  *a1 = &off_1000CE9F0;
  uint64_t v2 = a1[2];
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8LL))(v2);
  }
  *a1 = &off_1000CE570;
  uint64_t v3 = a1[1];
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8LL))(v3);
  }
  return a1;
}

void sub_100021CD4(void *__p)
{
  *std::string __p = &off_1000CE9F0;
  uint64_t v2 = __p[2];
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8LL))(v2);
  }
  *std::string __p = &off_1000CE570;
  uint64_t v3 = __p[1];
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8LL))(v3);
  }
  operator delete(__p);
}

unsigned int *sub_100021D3C(unsigned int *result, void *a2)
{
  uint64_t v2 = result[10];
  uint64_t v3 = a2[7];
  int v4 = (unint64_t *)(v3 + 16 * v2);
  if (*(_DWORD *)a2 == -991)
  {
    unint64_t v5 = *v4 + 1;
    *int v4 = v5;
    unint64_t v6 = *((void *)result + 3);
    unint64_t v7 = *((void *)result + 4);
    BOOL v8 = v5 < v7;
    if (v5 < v7 && v5 >= v6)
    {
      uint64_t v10 = *(void *)(v3 + 16 * v2 + 8);
      BOOL v8 = v5 < v7 && v10 != a2[2];
    }

    if (!v8 || v5 < v6)
    {
      *(_DWORD *)a2 = -994;
      if (!v8) {
        goto LABEL_25;
      }
LABEL_22:
      a2[10] = *((void *)result + 1);
      return sub_100021EF0(result, a2);
    }

    goto LABEL_23;
  }

  *int v4 = 0LL;
  if (*((void *)result + 4))
  {
    if (*((void *)result + 3))
    {
      *(_DWORD *)a2 = -994;
      goto LABEL_22;
    }

unsigned int *sub_100021DF0(unsigned int *result, int a2, void *a3)
{
  *(_DWORD *)a3 = -994;
  if (*((unsigned __int8 *)result + 52) == a2)
  {
    a3[10] = *((void *)result + 2);
  }

  else
  {
    a3[10] = *((void *)result + 1);
    return sub_100021EF0(result, a3);
  }

  return result;
}

void *sub_100021E20(void *a1)
{
  *a1 = &off_1000CE9F0;
  uint64_t v2 = a1[2];
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8LL))(v2);
  }
  *a1 = &off_1000CE570;
  uint64_t v3 = a1[1];
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8LL))(v3);
  }
  return a1;
}

void sub_100021E88(void *__p)
{
  *std::string __p = &off_1000CE9F0;
  uint64_t v2 = __p[2];
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8LL))(v2);
  }
  *std::string __p = &off_1000CE570;
  uint64_t v3 = __p[1];
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8LL))(v3);
  }
  operator delete(__p);
}

unsigned int *sub_100021EF0(unsigned int *result, void *a2)
{
  unsigned int v2 = result[11];
  *(void *)(a2[7] + 16LL * result[10] + _Block_object_dispose(va, 8) = a2[2];
  unsigned int v3 = result[12];
  if (v2 != v3)
  {
    uint64_t v4 = v2 - 1;
    uint64_t v5 = a2[3];
    uint64_t v6 = v3 - 1 - v4;
    uint64_t v7 = a2[4] + 24LL * v4 + 8;
    do
    {
      *(void *)(v7 - _Block_object_dispose(va, 8) = v5;
      *(void *)uint64_t v7 = v5;
      *(_BYTE *)(v7 + _Block_object_dispose(va, 8) = 0;
      v7 += 24LL;
      --v6;
    }

    while (v6);
  }

  return result;
}

uint64_t sub_100021F4C(uint64_t result, uint64_t a2)
{
  *(_DWORD *)a2 = -991;
  *(void *)(a2 + 8sub_10001AFB0((std::locale *)v24, " +$", 0) = *(void *)(result + 8);
  return result;
}

void *sub_100021F60(void *a1)
{
  *a1 = &off_1000CE9F0;
  uint64_t v2 = a1[2];
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8LL))(v2);
  }
  *a1 = &off_1000CE570;
  uint64_t v3 = a1[1];
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8LL))(v3);
  }
  return a1;
}

void sub_100021FC8(void *__p)
{
  *std::string __p = &off_1000CE9F0;
  uint64_t v2 = __p[2];
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8LL))(v2);
  }
  *std::string __p = &off_1000CE570;
  uint64_t v3 = __p[1];
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8LL))(v3);
  }
  operator delete(__p);
}

void sub_100022030(uint64_t a1, _DWORD *a2)
{
  *a2 = -992;
}

uint64_t sub_10002203C(uint64_t result, int a2, uint64_t a3)
{
  *(_DWORD *)a3 = -994;
  uint64_t v3 = 8LL;
  if (a2) {
    uint64_t v3 = 16LL;
  }
  *(void *)(a3 + 8sub_10001AFB0((std::locale *)v24, " +$", 0) = *(void *)(result + v3);
  return result;
}

uint64_t sub_100022068(uint64_t result, uint64_t a2)
{
  *(_DWORD *)a2 = -994;
  *(void *)(a2 + 8sub_10001AFB0((std::locale *)v24, " +$", 0) = *(void *)(result + 8);
  return result;
}

void sub_10002207C()
{
  exception = (std::regex_error *)__cxa_allocate_exception(0x18uLL);
  std::regex_error::regex_error(exception, __re_err_empty);
}

void sub_1000220B4(_Unwind_Exception *a1)
{
}

unsigned __int8 *sub_1000220C8(uint64_t a1, char *a2, char *a3)
{
  if (a2 == a3) {
    return (unsigned __int8 *)a2;
  }
  uint64_t v6 = *(void *)(a1 + 56);
  int v7 = *(_DWORD *)(a1 + 28);
  BOOL v8 = (unsigned __int8 *)sub_100022150(a1, a2, a3);
  else {
    return sub_10002225C(a1, v8, (unsigned __int8 *)a3, v6, v7 + 1, *(_DWORD *)(a1 + 28) + 1);
  }
}

char *sub_100022150(uint64_t a1, char *a2, char *a3)
{
  uint64_t v6 = sub_1000223FC(a1, a2, a3);
  int v7 = v6;
  if (v6 == a2 && v6 != a3)
  {
    if (a2 + 1 == a3 || *a2 != 92)
    {
      return a2;
    }

    else
    {
      int v8 = a2[1];
      if (v8 == 40)
      {
        uint64_t v9 = (uint64_t)(a2 + 2);
        sub_10001DBF8((void *)a1);
        int v10 = *(_DWORD *)(a1 + 28);
        do
        {
          unint64_t v11 = (char *)v9;
          uint64_t v9 = sub_1000220C8(a1, v9, a3);
        }

        while ((char *)v9 != v11);
        if (v11 == a3 || v11 + 1 == a3 || *v11 != 92 || v11[1] != 41) {
          sub_10001C41C();
        }
        int v7 = v11 + 2;
        sub_10001DC5C((void *)a1, v10);
      }

      else
      {
        int v13 = sub_100022644(a1, v8);
        uint64_t v14 = 2LL;
        if (!v13) {
          uint64_t v14 = 0LL;
        }
        return &a2[v14];
      }
    }
  }

  return v7;
}

unsigned __int8 *sub_10002225C( uint64_t a1, unsigned __int8 *a2, unsigned __int8 *a3, uint64_t a4, int a5, int a6)
{
  uint64_t v6 = a2;
  if (a2 != a3)
  {
    int v11 = *a2;
    if (v11 == 42)
    {
      sub_100021A04(a1, 0LL, -1LL, a4, a5, a6, 1);
      return ++v6;
    }

    if (a2 + 1 != a3 && v11 == 92 && a2[1] == 123)
    {
      int v13 = a2 + 2;
      int v25 = 0;
      uint64_t v14 = sub_100021B38(a1, a2 + 2, a3, &v25);
      if (v14 == v13) {
        goto LABEL_16;
      }
      if (v14 != a3)
      {
        uint64_t v15 = v14 + 1;
        int v16 = *v14;
        if (v16 == 44)
        {
          int v24 = -1;
          __int128 v17 = sub_100021B38(a1, v15, a3, &v24);
          if (v17 != a3 && v17 + 1 != a3 && *v17 == 92 && v17[1] == 125)
          {
            uint64_t v19 = v24;
            uint64_t v18 = v25;
            if (v24 == -1)
            {
              uint64_t v19 = -1LL;
            }

            else if (v24 < v25)
            {
LABEL_16:
              sub_100021BD4();
            }

            uint64_t v6 = &v17[2 * (v17[1] == 125)];
            int v20 = a5;
            int v21 = a6;
            uint64_t v22 = a1;
LABEL_23:
            sub_100021A04(v22, v18, v19, a4, v20, v21, 1);
            return v6;
          }
        }

        else if (v15 != a3 && v16 == 92 && *v15 == 125)
        {
          uint64_t v6 = v14 + 2;
          uint64_t v18 = v25;
          int v20 = a5;
          int v21 = a6;
          uint64_t v22 = a1;
          uint64_t v19 = v25;
          goto LABEL_23;
        }
      }

      sub_100021C20();
    }
  }

  return v6;
}

char *sub_1000223FC(uint64_t a1, char *a2, char *a3)
{
  if (a2 == a3)
  {
    uint64_t result = sub_100022504(a1, a2, a3);
    if (result != a2) {
      return result;
    }
    return sub_10001DAE8(a1, a2, a3);
  }

  int v6 = *a2;
  if ((a2 + 1 != a3 || v6 != 36)
    && ((v6 - 46) > 0x2E || ((1LL << (v6 - 46)) & 0x600000000001LL) == 0))
  {
    sub_10001E29C(a1, (char)v6);
    return a2 + 1;
  }

  uint64_t result = sub_100022504(a1, a2, a3);
  if (result != a2) {
    return result;
  }
  if (*a2 != 46) {
    return sub_10001DAE8(a1, a2, a3);
  }
  uint64_t v9 = operator new(0x10uLL);
  uint64_t v10 = *(void *)(a1 + 56);
  uint64_t v11 = *(void *)(v10 + 8);
  *uint64_t v9 = &off_1000CEAF8;
  v9[1] = v11;
  *(void *)(v10 + _Block_object_dispose(va, 8) = v9;
  *(void *)(a1 + 56) = *(void *)(*(void *)(a1 + 56) + 8LL);
  return a2 + 1;
}

_BYTE *sub_100022504(uint64_t a1, _BYTE *a2, _BYTE *a3)
{
  uint64_t v3 = a2;
  if (a2 != a3 && a2 + 1 != a3 && *a2 == 92)
  {
    int v4 = (char)a2[1];
    if ((v4 - 36) <= 0x3A && ((1LL << (a2[1] - 36)) & 0x580000000000441LL) != 0)
    {
      sub_10001E29C(a1, (char)v4);
      v3 += 2;
    }
  }

  return v3;
}

void *sub_10002257C(void *a1)
{
  *a1 = &off_1000CE570;
  uint64_t v2 = a1[1];
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8LL))(v2);
  }
  return a1;
}

void sub_1000225C0(void *__p)
{
  *std::string __p = &off_1000CE570;
  uint64_t v2 = __p[1];
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8LL))(v2);
  }
  operator delete(__p);
}

uint64_t sub_100022604(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(_BYTE **)(a2 + 16);
  if (v2 == *(_BYTE **)(a2 + 24) || !*v2)
  {
    uint64_t v3 = 0LL;
    *(_DWORD *)a2 = -993;
  }

  else
  {
    *(_DWORD *)a2 = -995;
    *(void *)(a2 + 16) = v2 + 1;
    uint64_t v3 = *(void *)(result + 8);
  }

  *(void *)(a2 + 8sub_10001AFB0((std::locale *)v24, " +$", 0) = v3;
  return result;
}

uint64_t sub_100022644(uint64_t a1, unsigned __int8 a2)
{
  return 1LL;
}

unsigned __int8 *sub_1000226A0(uint64_t a1, char *a2, char *a3)
{
  int v6 = sub_1000226FC(a1, a2, a3);
  do
  {
    int v7 = v6;
    int v6 = sub_1000226FC(a1, (char *)v6, a3);
  }

  while (v6 != v7);
  return v7;
}

unsigned __int8 *sub_1000226FC(uint64_t a1, char *a2, char *a3)
{
  uint64_t v6 = *(void *)(a1 + 56);
  int v7 = *(_DWORD *)(a1 + 28);
  int v8 = sub_10002288C(a1, a2, a3);
  uint64_t v9 = (unsigned __int8 *)v8;
  if (v8 != a2 || v8 == a3) {
    goto LABEL_12;
  }
  int v10 = *a2;
  switch(v10)
  {
    case '$':
      uint64_t v11 = operator new(0x18uLL);
      BOOL v12 = (*(_DWORD *)(a1 + 24) & 0x5F0) == 1024;
      uint64_t v13 = *(void *)(a1 + 56);
      goto LABEL_8;
    case '(':
      sub_10001DBF8((void *)a1);
      int v16 = *(_DWORD *)(a1 + 28);
      ++*(_DWORD *)(a1 + 36);
      __int128 v17 = (char *)sub_10001B4FC(a1, a2 + 1, a3);
      if (v17 == a3 || (uint64_t v18 = v17, *v17 != 41)) {
        sub_10001C41C();
      }
      sub_10001DC5C((void *)a1, v16);
      --*(_DWORD *)(a1 + 36);
      uint64_t v9 = (unsigned __int8 *)(v18 + 1);
LABEL_12:
      return (unsigned __int8 *)a2;
    case '^':
      uint64_t v11 = operator new(0x18uLL);
      BOOL v12 = (*(_DWORD *)(a1 + 24) & 0x5F0) == 1024;
      uint64_t v13 = *(void *)(a1 + 56);
LABEL_8:
      uint64_t v15 = *(void *)(v13 + 8);
      *uint64_t v11 = v14 + 2;
      v11[1] = v15;
      *((_BYTE *)v11 + 16) = v12;
      *(void *)(v13 + _Block_object_dispose(va, 8) = v11;
      *(void *)(a1 + 56) = *(void *)(*(void *)(a1 + 56) + 8LL);
      uint64_t v9 = (unsigned __int8 *)(a2 + 1);
      return sub_10001C024(a1, v9, (unsigned __int8 *)a3, v6, v7 + 1, *(_DWORD *)(a1 + 28) + 1);
  }

  return (unsigned __int8 *)a2;
}

char *sub_10002288C(uint64_t a1, char *a2, char *a3)
{
  uint64_t result = sub_100022944(a1, a2, a3);
  if (result == a2)
  {
    uint64_t result = sub_1000229CC(a1, a2, a3);
    if (result == a2)
    {
      if (a2 == a3 || *a2 != 46)
      {
        return sub_10001DAE8(a1, a2, a3);
      }

      else
      {
        int v7 = operator new(0x10uLL);
        uint64_t v8 = *(void *)(a1 + 56);
        uint64_t v9 = *(void *)(v8 + 8);
        *int v7 = &off_1000CEAF8;
        v7[1] = v9;
        *(void *)(v8 + _Block_object_dispose(va, 8) = v7;
        *(void *)(a1 + 56) = *(void *)(*(void *)(a1 + 56) + 8LL);
        return a2 + 1;
      }
    }
  }

  return result;
}

char *sub_100022944(uint64_t a1, char *a2, char *a3)
{
  uint64_t v3 = a2;
  if (a2 != a3)
  {
    int v4 = *a2;
    uint64_t v5 = (v4 - 36);
    if (v5 == 5)
    {
      if (*(_DWORD *)(a1 + 36)) {
        return v3;
      }
    }

    else
    {
LABEL_8:
    }

    sub_10001E29C(a1, *a2);
    ++v3;
  }

  return v3;
}

char *sub_1000229CC(uint64_t a1, char *a2, char *a3)
{
  uint64_t v3 = a2;
  if (a2 == a3) {
    return v3;
  }
  int v4 = a2 + 1;
  if (v3 + 1 == a3 || *v3 != 92) {
    return v3;
  }
  int v5 = *v4;
  signed __int8 v6 = *v4;
  BOOL v7 = (v5 - 36) > 0x3A || ((1LL << (*v4 - 36)) & 0x5800000080004F1LL) == 0;
  if (!v7 || (v5 - 123) < 3)
  {
    sub_10001E29C(a1, v6);
    v3 += 2;
    return v3;
  }

  if ((*(_DWORD *)(a1 + 24) & 0x1F0) != 0x40)
  {
    int v9 = sub_100022644(a1, v6);
    uint64_t v10 = 2LL;
    if (!v9) {
      uint64_t v10 = 0LL;
    }
    v3 += v10;
    return v3;
  }

  return sub_10002079C(a1, v4, a3, 0LL);
}

std::string *sub_100022A90(std::string *a1, uint64_t a2, uint64_t a3, uint64_t a4, char *a5, int a6)
{
  __int16 v6 = a6;
  int v9 = (std::string::value_type *)a2;
  sub_100023108((uint64_t)v29, a2, a3, a4, a6);
  uint64_t v21 = 0LL;
  uint64_t v22 = 0LL;
  char v23 = 0;
  uint64_t v24 = 0LL;
  uint64_t v25 = 0LL;
  char v26 = 0;
  char v27 = 0;
  uint64_t v28 = 0LL;
  *(_OWORD *)std::string __p = 0u;
  memset(v20, 0, sizeof(v20));
  memset(v17, 0, sizeof(v17));
  int v18 = 0;
  if (sub_100022C4C((uint64_t)v29, (uint64_t)v17))
  {
    if ((v6 & 0x200) == 0)
    {
      while (v9 != (std::string::value_type *)a3)
        std::string::push_back(a1, *v9++);
    }
  }

  else
  {
    uint64_t v11 = 0LL;
    BOOL v12 = 0LL;
    uint64_t v13 = (unsigned __int8 *)&a5[strlen(a5)];
    while (!sub_100022C4C((uint64_t)v29, (uint64_t)v17))
    {
      if ((v6 & 0x200) == 0)
      {
        uint64_t v14 = (std::string::value_type *)v30[6];
        uint64_t v15 = (std::string::value_type *)v30[7];
        while (v14 != v15)
          std::string::push_back(a1, *v14++);
      }

      a1 = sub_100022CE0((std::string::value_type ***)v30, a1, (unsigned __int8 *)a5, v13, v6);
      BOOL v12 = (std::string::value_type *)v30[9];
      uint64_t v11 = (std::string::value_type *)v30[10];
      if ((v6 & 0x400) != 0) {
        break;
      }
      sub_100022F48((uint64_t)v29);
    }

    if ((v6 & 0x200) == 0)
    {
      while (v12 != v11)
        std::string::push_back(a1, *v12++);
    }
  }

  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }

  if (v30[0])
  {
    v30[1] = v30[0];
    operator delete(v30[0]);
  }

  return a1;
}

void sub_100022C0C( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, void *a31, uint64_t a32)
{
  if (__p) {
    operator delete(__p);
  }
  if (a31) {
    operator delete(a31);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_100022C4C(uint64_t a1, uint64_t a2)
{
  uint64_t v6 = a1 + 32;
  uint64_t v4 = *(void *)(a1 + 32);
  uint64_t v5 = *(void *)(v6 + 8);
  uint64_t v9 = a2 + 32;
  uint64_t v7 = *(void *)(a2 + 32);
  uint64_t v8 = *(void *)(v9 + 8);
  BOOL v10 = v8 == v7 && v5 == v4;
  if (v5 != v4 && v8 != v7) {
    return *(void *)a1 == *(void *)a2
  }
        && *(void *)(a1 + 8) == *(void *)(a2 + 8)
        && *(void *)(a1 + 16) == *(void *)(a2 + 16)
        && *(_DWORD *)(a1 + 24) == *(_DWORD *)(a2 + 24)
        && sub_1000253CC(v4, v7) == 0;
  return v10;
}

std::string *sub_100022CE0( std::string::value_type ***a1, std::string *this, unsigned __int8 *a3, unsigned __int8 *a4, __int16 a5)
{
  uint64_t v6 = a3;
  if ((a5 & 0x100) != 0)
  {
    if (a3 == a4) {
      return this;
    }
    while (1)
    {
      int v30 = *v6;
      if (v30 == 92)
      {
        unint64_t v34 = v6 + 1;
        if (v6 + 1 != a4)
        {
          int v30 = *v34;
          if ((v30 - 48) <= 9u)
          {
            unint64_t v35 = (v30 - 48);
            if (0xAAAAAAAAAAAAAAABLL * (a1[1] - *a1) <= v35) {
              uint64_t v36 = (uint64_t)(a1 + 3);
            }
            else {
              uint64_t v36 = (uint64_t)&(*a1)[3 * v35];
            }
            uint64_t v37 = *(std::string::value_type **)v36;
            __int128 v38 = *(std::string::value_type **)(v36 + 8);
            while (v37 != v38)
            {
              std::string::value_type v39 = *v37++;
              std::string::push_back(this, v39);
            }

            goto LABEL_55;
          }

          ++v6;
        }
      }

      else if (v30 == 38)
      {
        __int16 v31 = **a1;
        char v32 = (*a1)[1];
        while (v31 != v32)
        {
          std::string::value_type v33 = *v31++;
          std::string::push_back(this, v33);
        }

        goto LABEL_54;
      }

      std::string::push_back(this, v30);
LABEL_54:
      unint64_t v34 = v6;
LABEL_55:
      uint64_t v6 = v34 + 1;
      if (v34 + 1 == a4) {
        return this;
      }
    }
  }

  if (a3 != a4)
  {
    do
    {
      int v9 = *v6;
      BOOL v10 = v6 + 1;
      if (v9 == 36 && v10 != a4)
      {
        int v12 = (char)*v10;
        int v9 = *v10;
        if (v12 > 38)
        {
          if (v12 == 39)
          {
            uint64_t v19 = (std::string::value_type *)a1[9];
            int v20 = (std::string::value_type *)a1[10];
            while (v19 != v20)
            {
              std::string::value_type v21 = *v19++;
              std::string::push_back(this, v21);
            }

            goto LABEL_10;
          }

          if (v12 == 96)
          {
            int v16 = (std::string::value_type *)a1[6];
            __int128 v17 = (std::string::value_type *)a1[7];
            while (v16 != v17)
            {
              std::string::value_type v18 = *v16++;
              std::string::push_back(this, v18);
            }

            goto LABEL_10;
          }
        }

        else
        {
          if (v12 == 36) {
            goto LABEL_9;
          }
          if (v12 == 38)
          {
            uint64_t v13 = **a1;
            uint64_t v14 = (*a1)[1];
            while (v13 != v14)
            {
              std::string::value_type v15 = *v13++;
              std::string::push_back(this, v15);
            }

            goto LABEL_10;
          }
        }

        if ((v9 - 48) <= 9)
        {
          unint64_t v22 = *v10 - 48LL;
          if (v6 + 2 != a4)
          {
            uint64_t v23 = v6[2];
            unsigned int v24 = v23 - 48;
            uint64_t v25 = v23 + 10LL * (int)v22 - 48;
            if (v24 > 9)
            {
              BOOL v10 = v6 + 1;
            }

            else
            {
              unint64_t v22 = v25;
              BOOL v10 = v6 + 2;
            }
          }

          if (0xAAAAAAAAAAAAAAABLL * (a1[1] - *a1) <= v22) {
            uint64_t v26 = (uint64_t)(a1 + 3);
          }
          else {
            uint64_t v26 = (uint64_t)&(*a1)[3 * (int)v22];
          }
          char v27 = *(std::string::value_type **)v26;
          uint64_t v28 = *(std::string::value_type **)(v26 + 8);
          while (v27 != v28)
          {
            std::string::value_type v29 = *v27++;
            std::string::push_back(this, v29);
          }

          goto LABEL_10;
        }

        LOBYTE(v9) = 36;
      }

      BOOL v10 = v6;
LABEL_9:
      std::string::push_back(this, v9);
LABEL_10:
      uint64_t v6 = v10 + 1;
    }

    while (v10 + 1 != a4);
  }

  return this;
}

uint64_t sub_100022F48(uint64_t a1)
{
  uint64_t v3 = a1 + 32;
  uint64_t v2 = *(void **)(a1 + 32);
  int v4 = *(_DWORD *)(v3 - 8);
  int v5 = v4 | 0x800;
  *(_DWORD *)(v3 - _Block_object_dispose(va, 8) = v4 | 0x800;
  if (*(void **)(v3 + 8) == v2) {
    uint64_t v6 = (void *)(v3 + 24);
  }
  else {
    uint64_t v6 = v2;
  }
  uint64_t v7 = v6[1];
  if (*v6 != v7)
  {
LABEL_5:
    *(_DWORD *)(a1 + 24) = v5 | 0x80;
    uint64_t v9 = *(void *)(a1 + 8);
    uint64_t v8 = *(void *)(a1 + 16);
    uint64_t v17 = 0LL;
    uint64_t v18 = 0LL;
    char v19 = 0;
    uint64_t v20 = 0LL;
    uint64_t v21 = 0LL;
    char v22 = 0;
    char v23 = 0;
    uint64_t v24 = 0LL;
    *(_OWORD *)std::string __p = 0u;
    memset(v16, 0, sizeof(v16));
    char v10 = sub_100023208(v8, v7, v9, (uint64_t)__p, v5 | 0x80u);
    sub_1000233E0(v3, v7, v9, (uint64_t *)__p, (v5 & 0x800) != 0);
    if (__p[0])
    {
      __p[1] = __p[0];
      operator delete(__p[0]);
    }

    if ((v10 & 1) == 0)
    {
      uint64_t v2 = *(void **)v3;
LABEL_14:
      if (v2)
      {
        *(void *)(a1 + 4sub_10001AFB0((std::locale *)v24, " +$", 0) = v2;
        operator delete(v2);
        *(void *)uint64_t v3 = 0LL;
        *(void *)(v3 + _Block_object_dispose(va, 8) = 0LL;
        *(void *)(v3 + 16) = 0LL;
      }

      *(_BYTE *)(a1 + 12_Block_object_dispose(va, 8) = 0;
      *(_OWORD *)uint64_t v3 = 0u;
      *(_OWORD *)(v3 + 16) = 0u;
      *(_OWORD *)(v3 + 25) = 0u;
      *(void *)(a1 + 8sub_10001AFB0((std::locale *)v24, " +$", 0) = 0LL;
      *(void *)(a1 + 8_Block_object_dispose(va, 8) = 0LL;
      *(_BYTE *)(a1 + 96) = 0;
      *(void *)(a1 + 104) = 0LL;
      *(void *)(a1 + 112) = 0LL;
      *(_BYTE *)(a1 + 12sub_10001AFB0((std::locale *)v24, " +$", 0) = 0;
      *(void *)(a1 + 136) = 0LL;
      return a1;
    }

    return a1;
  }

  uint64_t v11 = *(void *)(a1 + 8);
  if (v11 == v7) {
    goto LABEL_14;
  }
  uint64_t v12 = *(void *)(a1 + 16);
  uint64_t v17 = 0LL;
  uint64_t v18 = 0LL;
  char v19 = 0;
  uint64_t v20 = 0LL;
  uint64_t v21 = 0LL;
  char v22 = 0;
  char v23 = 0;
  uint64_t v24 = 0LL;
  *(_OWORD *)std::string __p = 0u;
  memset(v16, 0, sizeof(v16));
  char v13 = sub_100023208(v12, v7, v11, (uint64_t)__p, v4 | 0x860u);
  sub_1000233E0(v3, v7, v11, (uint64_t *)__p, 1);
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }

  if ((v13 & 1) == 0)
  {
    ++v7;
    int v5 = *(_DWORD *)(a1 + 24);
    goto LABEL_5;
  }

  return a1;
}

void sub_1000230E8( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100023108(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5)
{
  __int16 v5 = a5;
  *(void *)a1 = a2;
  *(void *)(a1 + _Block_object_dispose(va, 8) = a3;
  *(void *)(a1 + 16) = a4;
  *(_DWORD *)(a1 + 24) = a5;
  *(_OWORD *)(a1 + 32) = 0u;
  uint64_t v9 = a1 + 32;
  *(void *)(a1 + 8sub_10001AFB0((std::locale *)v24, " +$", 0) = 0LL;
  *(void *)(a1 + 8_Block_object_dispose(va, 8) = 0LL;
  *(_BYTE *)(a1 + 96) = 0;
  *(void *)(a1 + 104) = 0LL;
  *(void *)(a1 + 112) = 0LL;
  *(_BYTE *)(a1 + 12sub_10001AFB0((std::locale *)v24, " +$", 0) = 0;
  *(_BYTE *)(a1 + 12_Block_object_dispose(va, 8) = 0;
  *(void *)(a1 + 136) = 0LL;
  *(_OWORD *)(a1 + 4_Block_object_dispose(va, 8) = 0u;
  *(_OWORD *)(a1 + 57) = 0u;
  uint64_t v13 = 0LL;
  uint64_t v14 = 0LL;
  char v15 = 0;
  uint64_t v16 = 0LL;
  uint64_t v17 = 0LL;
  char v18 = 0;
  char v19 = 0;
  uint64_t v20 = 0LL;
  *(_OWORD *)std::string __p = 0u;
  memset(v12, 0, sizeof(v12));
  sub_100023208(a4, a2, a3, (uint64_t)__p, a5);
  sub_1000233E0(v9, a2, a3, (uint64_t *)__p, (v5 & 0x800) != 0);
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }

  return a1;
}

void sub_1000231DC( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10)
{
  if (__p) {
    operator delete(__p);
  }
  uint64_t v13 = *v11;
  if (*v11)
  {
    *(void *)(v10 + 4sub_10001AFB0((std::locale *)v24, " +$", 0) = v13;
    operator delete(v13);
  }

  _Unwind_Resume(exception_object);
}

uint64_t sub_100023208(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5)
{
  if ((a5 & 0x80) != 0) {
    int v9 = a5 & 0xFFA;
  }
  else {
    int v9 = a5;
  }
  sub_10001CAD0(a4, *(_DWORD *)(a1 + 28) + 1, a2, a3, (unsigned __int16)(v9 & 0x800) >> 11);
  if (sub_10002356C(a1, a2, a3, (uint64_t *)a4, v9, (v9 & 0x800) == 0))
  {
    if (*(void *)(a4 + 8) == *(void *)a4) {
      uint64_t v10 = (uint64_t *)(a4 + 24);
    }
    else {
      uint64_t v10 = *(uint64_t **)a4;
    }
LABEL_8:
    uint64_t v11 = *v10;
    *(void *)(a4 + 56) = *v10;
    *(_BYTE *)(a4 + 64) = *(void *)(a4 + 48) != v11;
    uint64_t v12 = v10[1];
    *(void *)(a4 + 72) = v12;
    *(_BYTE *)(a4 + 8_Block_object_dispose(va, 8) = v12 != *(void *)(a4 + 80);
    return 1LL;
  }

  if (a2 != a3 && (v9 & 0x40) == 0)
  {
    int v14 = v9 | 0x80;
    uint64_t v15 = a2 + 1;
    if (v15 != a3)
    {
      while (1)
      {
        sub_10001CF40( (char **)a4,  0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a4 + 8) - *(void *)a4) >> 3),  (__int128 *)(a4 + 24));
        int v16 = sub_10002356C(a1, v15, a3, (uint64_t *)a4, v14, 0);
        uint64_t v18 = *(void *)a4;
        uint64_t v17 = *(void *)(a4 + 8);
        if (v16) {
          break;
        }
        sub_10001CF40((char **)a4, 0xAAAAAAAAAAAAAAABLL * ((v17 - v18) >> 3), (__int128 *)(a4 + 24));
        if (++v15 == a3) {
          goto LABEL_14;
        }
      }

      if (v17 == v18) {
        uint64_t v10 = (uint64_t *)(a4 + 24);
      }
      else {
        uint64_t v10 = *(uint64_t **)a4;
      }
      goto LABEL_8;
    }

void sub_1000233E0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4, char a5)
{
  uint64_t v10 = a4[6];
  sub_100025228(a1, 0xAAAAAAAAAAAAAAABLL * ((a4[1] - *a4) >> 3));
  uint64_t v11 = *(void *)a1;
  if (*(void *)(a1 + 8) != *(void *)a1)
  {
    uint64_t v12 = 0LL;
    unint64_t v13 = 0LL;
    uint64_t v15 = *a4;
    uint64_t v14 = a4[1];
    do
    {
      unint64_t v16 = 0xAAAAAAAAAAAAAAABLL * ((v14 - v15) >> 3);
      uint64_t v17 = (void *)(v15 + v12);
      if (v16 <= v13) {
        uint64_t v18 = a4 + 3;
      }
      else {
        uint64_t v18 = v17;
      }
      *(void *)(v11 + v12) = a2 + *v18 - v10;
      if (0xAAAAAAAAAAAAAAABLL * ((a4[1] - *a4) >> 3) <= v13) {
        char v19 = a4 + 3;
      }
      else {
        char v19 = (uint64_t *)(*a4 + v12);
      }
      *(void *)(*(void *)a1 + v12 + _Block_object_dispose(va, 8) = a2 + v19[1] - v10;
      uint64_t v15 = *a4;
      uint64_t v14 = a4[1];
      if (0xAAAAAAAAAAAAAAABLL * ((v14 - *a4) >> 3) <= v13) {
        uint64_t v20 = a4 + 3;
      }
      else {
        uint64_t v20 = (uint64_t *)(*a4 + v12);
      }
      char v21 = *((_BYTE *)v20 + 16);
      uint64_t v11 = *(void *)a1;
      uint64_t v22 = *(void *)(a1 + 8);
      *(_BYTE *)(*(void *)a1 + v12 + 16) = v21;
      ++v13;
      v12 += 24LL;
    }

    while (v13 < 0xAAAAAAAAAAAAAAABLL * ((v22 - v11) >> 3));
  }

  *(void *)(a1 + 24) = a3;
  *(void *)(a1 + 32) = a3;
  *(_BYTE *)(a1 + 4sub_10001AFB0((std::locale *)v24, " +$", 0) = 0;
  uint64_t v23 = a2 + a4[6] - v10;
  *(void *)(a1 + 4_Block_object_dispose(va, 8) = v23;
  *(void *)(a1 + 56) = a2 + a4[7] - v10;
  *(_BYTE *)(a1 + 64) = *((_BYTE *)a4 + 64);
  *(void *)(a1 + 72) = a2 + a4[9] - v10;
  *(void *)(a1 + 8sub_10001AFB0((std::locale *)v24, " +$", 0) = a2 + a4[10] - v10;
  *(_BYTE *)(a1 + 8_Block_object_dispose(va, 8) = *((_BYTE *)a4 + 88);
  if ((a5 & 1) == 0) {
    *(void *)(a1 + 104) = v23;
  }
  *(_BYTE *)(a1 + 96) = *((_BYTE *)a4 + 96);
}

uint64_t sub_10002356C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4, int a5, char a6)
{
  if ((*(_WORD *)(a1 + 24) & 0x1F0) == 0) {
    return sub_10001CB40(a1, a2, a3, a4, a5, a6);
  }
  if (*(_DWORD *)(a1 + 28)) {
    return sub_100023AC4(a1, a2, a3, a4, a5, a6);
  }
  return sub_10002358C(a1, a2, a3, a4, a5, a6);
}

uint64_t sub_10002358C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4, int a5, char a6)
{
  __int128 v60 = 0u;
  __int128 v61 = 0u;
  __int128 v59 = 0u;
  uint64_t v6 = *(void *)(a1 + 40);
  if (v6)
  {
    *(_DWORD *)uint64_t v55 = 0;
    memset(&v55[8], 0, 32);
    __int128 v56 = 0uLL;
    *(_OWORD *)std::string __p = 0uLL;
    memset(v58, 0, 21);
    sub_10002402C(&v59, (uint64_t)v55);
    if (__p[0])
    {
      __p[1] = __p[0];
      operator delete(__p[0]);
    }

    if (*(void *)&v55[32])
    {
      *(void *)&__int128 v56 = *(void *)&v55[32];
      operator delete(*(void **)&v55[32]);
    }

    uint64_t v12 = *((void *)&v59 + 1);
    unint64_t v13 = *((void *)&v61 + 1) + v61 - 1;
    unint64_t v14 = v13 / 0x2A;
    uint64_t v15 = *(void *)(*((void *)&v59 + 1) + 8 * (v13 / 0x2A));
    unint64_t v16 = 3 * (v13 % 0x2A);
    uint64_t v17 = v15 + 32 * v16;
    *(_DWORD *)uint64_t v17 = 0;
    *(void *)(v17 + _Block_object_dispose(va, 8) = a2;
    *(void *)(*(void *)(v12 + 8 * v14) + 32 * v16 + 16) = a2;
    *(void *)(*(void *)(v12 + 8 * v14) + 32 * v16 + 24) = a3;
    sub_10001D130(*(void *)(v12 + 8 * v14) + 32 * v16 + 56, *(unsigned int *)(a1 + 32));
    char v53 = 0;
    unsigned int v18 = 0;
    uint64_t v51 = 0LL;
    uint64_t v52 = a2;
    uint64_t v19 = a3 - a2;
    uint64_t v20 = *((void *)&v61 + 1);
    uint64_t v21 = *((void *)&v59 + 1);
    unint64_t v22 = *((void *)&v61 + 1) + v61 - 1;
    unint64_t v23 = v22 / 0x2A;
    unint64_t v24 = 3 * (v22 % 0x2A);
    *(void *)(*(void *)(*((void *)&v59 + 1) + 8 * v23) + 32 * v24 + 8sub_10001AFB0((std::locale *)v24, " +$", 0) = v6;
    uint64_t v25 = *(void *)(v21 + 8 * v23) + 32 * v24;
    *(_DWORD *)(v25 + 8_Block_object_dispose(va, 8) = a5;
    *(_BYTE *)(v25 + 92) = a6;
    while (2)
    {
      unint64_t v27 = v20 + v61 - 1;
      uint64_t v28 = *(void *)(*((void *)&v59 + 1) + 8 * (v27 / 0x2A));
      unint64_t v29 = v27 % 0x2A;
      uint64_t v30 = v28 + 96 * (v27 % 0x2A);
      char v32 = (void *)(v30 + 80);
      uint64_t v31 = *(void *)(v30 + 80);
      if (v31) {
        (*(void (**)(uint64_t, unint64_t))(*(void *)v31 + 16LL))(v31, v28 + 96 * v29);
      }
      switch(*(_DWORD *)v30)
      {
        case 0xFFFFFC18:
          uint64_t v33 = *(void *)(v28 + 96 * v29 + 16);
          BOOL v35 = (a5 & 0x1000) == 0 || v33 == a3;
          BOOL v36 = v33 != v52 || (a5 & 0x20) == 0;
          if (!v36 || !v35) {
            goto LABEL_37;
          }
          uint64_t v37 = v33 - *(void *)(v28 + 96 * v29 + 8);
          uint64_t v38 = v51;
          if (v38 != v19)
          {
            uint64_t v51 = v38;
            sub_10002412C(&v59);
            char v53 = 1;
            goto LABEL_38;
          }

          std::string::value_type v39 = (void **)*((void *)&v59 + 1);
          uint64_t v40 = v60;
          if ((void)v60 == *((void *)&v59 + 1))
          {
            uint64_t v40 = *((void *)&v59 + 1);
          }

          else
          {
            __int16 v41 = (void *)(*((void *)&v59 + 1) + 8 * ((unint64_t)v61 / 0x2A));
            int v42 = (void *)(*v41 + 96 * ((unint64_t)v61 % 0x2A));
            unint64_t v43 = *(void *)(*((void *)&v59 + 1) + 8 * ((*((void *)&v61 + 1) + (void)v61) / 0x2AuLL))
                + 96 * ((*((void *)&v61 + 1) + (void)v61) % 0x2AuLL);
            if (v42 != (void *)v43)
            {
              do
              {
                sub_10001D560((uint64_t)&v61 + 8, v42);
                v42 += 12;
                if ((void *)((char *)v42 - *v41) == (void *)4032)
                {
                  int v44 = (void *)v41[1];
                  ++v41;
                  int v42 = v44;
                }
              }

              while (v42 != (void *)v43);
              std::string::value_type v39 = (void **)*((void *)&v59 + 1);
              uint64_t v40 = v60;
            }
          }

          *((void *)&v61 + 1) = 0LL;
          unint64_t v47 = v40 - (void)v39;
          if (v47 >= 0x11)
          {
            do
            {
              operator delete(*v39);
              std::string::value_type v39 = (void **)(*((void *)&v59 + 1) + 8LL);
              *((void *)&v59 + 1) = v39;
              unint64_t v47 = v60 - (void)v39;
            }

            while ((void)v60 - (void)v39 > 0x10uLL);
          }

          if (v47 >> 3 == 1)
          {
            uint64_t v48 = 21LL;
          }

          else
          {
            if (v47 >> 3 != 2) {
              goto LABEL_53;
            }
            uint64_t v48 = 42LL;
          }

          *(void *)&__int128 v61 = v48;
LABEL_53:
          char v53 = 1;
          uint64_t v51 = v19;
LABEL_38:
          uint64_t v20 = *((void *)&v61 + 1);
          if (*((void *)&v61 + 1)) {
            continue;
          }
          if ((v53 & 1) != 0)
          {
            uint64_t v49 = *a4;
            *(void *)uint64_t v49 = v52;
            *(void *)(v49 + _Block_object_dispose(va, 8) = v52 + v51;
            uint64_t v6 = 1LL;
            *(_BYTE *)(v49 + 16) = 1;
          }

          else
          {
            uint64_t v6 = 0LL;
          }

          break;
        case 0xFFFFFC19:
        case 0xFFFFFC1E:
        case 0xFFFFFC21:
          goto LABEL_38;
        case 0xFFFFFC1D:
          sub_1000241AC((uint64_t)&v59, v28 + 96 * v29);
          goto LABEL_37;
        case 0xFFFFFC1F:
LABEL_37:
          sub_10002412C(&v59);
          goto LABEL_38;
        case 0xFFFFFC20:
          __int128 v45 = *(_OWORD *)(v30 + 16);
          *(_OWORD *)uint64_t v55 = *(_OWORD *)v30;
          *(_OWORD *)&v55[16] = v45;
          __int128 v56 = 0uLL;
          *(void *)&v55[32] = 0LL;
          sub_10001D898( &v55[32],  *(__int128 **)(v28 + 96 * v29 + 32),  *(__int128 **)(v28 + 96 * v29 + 40),  0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(v28 + 96 * v29 + 40) - *(void *)(v28 + 96 * v29 + 32)) >> 3));
          __p[0] = 0LL;
          __p[1] = 0LL;
          v58[0] = 0LL;
          sub_10001D914( (char *)__p,  *(__int128 **)(v28 + 96 * v29 + 56),  *(__int128 **)(v28 + 96 * v29 + 64),  (uint64_t)(*(void *)(v28 + 96 * v29 + 64) - *(void *)(v28 + 96 * v29 + 56)) >> 4);
          uint64_t v46 = *v32;
          *(void *)((char *)&v58[1] + 5) = *(void *)(v30 + 85);
          v58[1] = v46;
          (*(void (**)(void, uint64_t, unint64_t))(*(void *)*v32 + 24LL))( *v32,  1LL,  v28 + 96 * v29);
          (*(void (**)(void, void, _BYTE *))(*(void *)v58[1] + 24LL))(v58[1], 0LL, v55);
          sub_10002402C(&v59, (uint64_t)v55);
          if (__p[0])
          {
            __p[1] = __p[0];
            operator delete(__p[0]);
          }

          if (*(void *)&v55[32])
          {
            *(void *)&__int128 v56 = *(void *)&v55[32];
            operator delete(*(void **)&v55[32]);
          }

          goto LABEL_38;
        default:
          sub_10001D1AC();
      }

      break;
    }
  }

  sub_100024D98(&v59);
  return v6;
}

void sub_100023A74( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20, void *__p, uint64_t a22)
{
}

uint64_t sub_100023AC4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4, int a5, char a6)
{
  unsigned __int8 v54 = 0LL;
  uint64_t v55 = 0LL;
  v56[0] = 0LL;
  *(_DWORD *)uint64_t v51 = 0;
  memset(&v51[8], 0, 32);
  __int128 v52 = 0u;
  memset(v53, 0, 37);
  uint64_t v6 = *(void *)(a1 + 40);
  if (!v6) {
    goto LABEL_43;
  }
  *(void *)&__int128 v49 = a3;
  *((void *)&v49 + 1) = a3;
  char v50 = 0;
  *(_DWORD *)uint64_t v46 = 0;
  memset(&v46[8], 0, 48);
  *(_OWORD *)std::string __p = 0uLL;
  memset(v48, 0, 21);
  uint64_t v55 = (_OWORD *)sub_10001D1F8((uint64_t *)&v54, (uint64_t)v46);
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }

  if (*(void *)&v46[32])
  {
    *(void *)&v46[40] = *(void *)&v46[32];
    operator delete(*(void **)&v46[32]);
  }

  __int16 v41 = a4;
  uint64_t v11 = v55;
  *((_DWORD *)v55 - 24) = 0;
  *((void *)v11 - 11) = a2;
  *((void *)v11 - 1sub_10001AFB0((std::locale *)v24, " +$", 0) = a2;
  *((void *)v11 - 9) = a3;
  sub_10001D0F4((uint64_t)(v11 - 4), *(unsigned int *)(a1 + 28), &v49);
  sub_10001D130((uint64_t)v55 - 40, *(unsigned int *)(a1 + 32));
  uint64_t v42 = 0LL;
  char v43 = 0;
  unsigned int v12 = 0;
  uint64_t v13 = a3 - a2;
  unint64_t v14 = v55;
  *((void *)v55 - 2) = v6;
  *((_DWORD *)v14 - 2) = a5;
  *((_BYTE *)v14 - 4) = a6;
  do
  {
    BOOL v15 = (++v12 & 0xFFF) != 0 || (int)(v12 >> 12) < (int)v13;
    if (!v15) {
      sub_10001D160();
    }
    uint64_t v17 = v14 - 1;
    uint64_t v16 = *((void *)v14 - 2);
    unsigned int v18 = v14 - 6;
    if (v16) {
      (*(void (**)(uint64_t, _OWORD *))(*(void *)v16 + 16LL))(v16, v14 - 6);
    }
    switch(*(_DWORD *)v18)
    {
      case 0xFFFFFC18:
        uint64_t v19 = *((void *)v14 - 10);
        if ((a5 & 0x20) != 0 && v19 == a2 || (a5 & 0x1000) != 0 && v19 != a3) {
          goto LABEL_19;
        }
        uint64_t v26 = v19 - *((void *)v14 - 11);
        uint64_t v27 = v42;
        if ((v43 & (v42 >= v26)) == 0)
        {
          __int128 v28 = *(v14 - 5);
          *(_OWORD *)uint64_t v51 = *(_OWORD *)v18;
          *(_OWORD *)&v51[16] = v28;
          if (v51 != v18)
          {
            sub_100024F28( &v51[32],  *((__int128 **)v14 - 8),  *((__int128 **)v14 - 7),  0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*((void *)v14 - 7) - *((void *)v14 - 8)) >> 3));
            sub_1000250DC( v53,  *((uint64_t **)v14 - 5),  *((uint64_t **)v14 - 4),  (uint64_t)(*((void *)v14 - 4) - *((void *)v14 - 5)) >> 4);
          }

          unint64_t v29 = (void *)*v17;
          *(void **)((char *)&v53[3] + 5) = *(void **)((char *)v14 - 11);
          v53[3] = v29;
          uint64_t v27 = v26;
        }

        uint64_t v30 = v55;
        if (v27 == v13)
        {
          uint64_t v31 = (uint64_t)v54;
          while (v30 != (void *)v31)
          {
            v30 -= 12;
            sub_10001D560((uint64_t)v56, v30);
          }

          uint64_t v55 = (_OWORD *)v31;
          char v43 = 1;
          uint64_t v42 = a3 - a2;
        }

        else
        {
          uint64_t v42 = v27;
          char v32 = v55 - 6;
          sub_10001D560((uint64_t)v56, (void *)v55 - 12);
          uint64_t v55 = v32;
          char v43 = 1;
        }

        break;
      case 0xFFFFFC1D:
      case 0xFFFFFC1E:
      case 0xFFFFFC21:
        break;
      case 0xFFFFFC1F:
LABEL_19:
        uint64_t v20 = v55 - 6;
        sub_10001D560((uint64_t)v56, (void *)v55 - 12);
        uint64_t v55 = v20;
        break;
      case 0xFFFFFC20:
        __int128 v21 = *(v14 - 5);
        *(_OWORD *)uint64_t v46 = *(_OWORD *)v18;
        *(_OWORD *)&v46[16] = v21;
        memset(&v46[32], 0, 24);
        sub_10001D898( &v46[32],  *((__int128 **)v14 - 8),  *((__int128 **)v14 - 7),  0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*((void *)v14 - 7) - *((void *)v14 - 8)) >> 3));
        __p[0] = 0LL;
        __p[1] = 0LL;
        v48[0] = 0LL;
        sub_10001D914( (char *)__p,  *((__int128 **)v14 - 5),  *((__int128 **)v14 - 4),  (uint64_t)(*((void *)v14 - 4) - *((void *)v14 - 5)) >> 4);
        uint64_t v22 = (void *)*v17;
        *(void *)((char *)&v48[1] + 5) = *(void *)((char *)v14 - 11);
        v48[1] = v22;
        (*(void (**)(void, uint64_t, _OWORD *))(*(void *)*v17 + 24LL))(*v17, 1LL, v14 - 6);
        (*(void (**)(void, void, _BYTE *))(*(void *)v48[1] + 24LL))(v48[1], 0LL, v46);
        unint64_t v23 = v55;
        if ((unint64_t)v55 >= v56[0])
        {
          uint64_t v55 = (_OWORD *)sub_10001D1F8((uint64_t *)&v54, (uint64_t)v46);
          if (__p[0])
          {
            __p[1] = __p[0];
            operator delete(__p[0]);
          }
        }

        else
        {
          __int128 v24 = *(_OWORD *)&v46[16];
          *uint64_t v55 = *(_OWORD *)v46;
          v23[1] = v24;
          *((void *)v23 + 4) = 0LL;
          *((void *)v23 + 5) = 0LL;
          *((void *)v23 + 6) = 0LL;
          *((void *)v23 + 7) = 0LL;
          v23[2] = *(_OWORD *)&v46[32];
          *((void *)v23 + 6) = *(void *)&v46[48];
          memset(&v46[32], 0, 24);
          *((void *)v23 + _Block_object_dispose(va, 8) = 0LL;
          *((void *)v23 + 9) = 0LL;
          *(_OWORD *)((char *)v23 + 56) = *(_OWORD *)__p;
          *((void *)v23 + 9) = v48[0];
          __p[0] = 0LL;
          __p[1] = 0LL;
          v48[0] = 0LL;
          uint64_t v25 = v48[1];
          *(void *)((char *)v23 + 85) = *(void *)((char *)&v48[1] + 5);
          *((void *)v23 + 1sub_10001AFB0((std::locale *)v24, " +$", 0) = v25;
          uint64_t v55 = v23 + 6;
        }

        if (*(void *)&v46[32])
        {
          *(void *)&v46[40] = *(void *)&v46[32];
          operator delete(*(void **)&v46[32]);
        }

        break;
      default:
        sub_10001D1AC();
    }

    unint64_t v14 = v55;
  }

  while (v54 != v55);
  if ((v43 & 1) != 0)
  {
    uint64_t v33 = *v41;
    *(void *)uint64_t v33 = a2;
    *(void *)(v33 + _Block_object_dispose(va, 8) = a2 + v42;
    *(_BYTE *)(v33 + 16) = 1;
    if ((void)v52 != *(void *)&v51[32])
    {
      unint64_t v34 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v52 - *(void *)&v51[32]) >> 3);
      BOOL v35 = (_BYTE *)(*(void *)&v51[32] + 16LL);
      unsigned int v36 = 1;
      do
      {
        uint64_t v37 = v33 + 24LL * v36;
        *(_OWORD *)uint64_t v37 = *((_OWORD *)v35 - 1);
        char v38 = *v35;
        v35 += 24;
        *(_BYTE *)(v37 + 16) = v38;
        BOOL v15 = v34 > v36++;
      }

      while (v15);
    }

    uint64_t v39 = 1LL;
  }

  else
  {
LABEL_43:
    uint64_t v39 = 0LL;
  }

  if (v53[0])
  {
    v53[1] = v53[0];
    operator delete(v53[0]);
  }

  if (*(void *)&v51[32])
  {
    *(void *)&__int128 v52 = *(void *)&v51[32];
    operator delete(*(void **)&v51[32]);
  }

  *(void *)uint64_t v51 = &v54;
  sub_10001D9C4((void ***)v51);
  return v39;
}

void sub_100023FCC( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, void *__p, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35)
{
  a35 = v35 - 120;
  sub_10001D9C4((void ***)&a35);
  _Unwind_Resume(a1);
}

__n128 sub_10002402C(void *a1, uint64_t a2)
{
  uint64_t v4 = a1[2];
  uint64_t v5 = a1[1];
  uint64_t v6 = 42 * ((v4 - v5) >> 3) - 1;
  if (v4 == v5) {
    uint64_t v6 = 0LL;
  }
  unint64_t v7 = a1[5] + a1[4];
  if (v6 == v7)
  {
    sub_10002429C(a1);
    uint64_t v5 = a1[1];
    unint64_t v7 = a1[5] + a1[4];
  }

  unint64_t v8 = *(void *)(v5 + 8 * (v7 / 0x2A)) + 96 * (v7 % 0x2A);
  __int128 v9 = *(_OWORD *)(a2 + 16);
  *(_OWORD *)unint64_t v8 = *(_OWORD *)a2;
  *(_OWORD *)(v8 + 16) = v9;
  *(void *)(v8 + 4sub_10001AFB0((std::locale *)v24, " +$", 0) = 0LL;
  *(void *)(v8 + 4_Block_object_dispose(va, 8) = 0LL;
  *(void *)(v8 + 32) = 0LL;
  *(_OWORD *)(v8 + 32) = *(_OWORD *)(a2 + 32);
  *(void *)(v8 + 4_Block_object_dispose(va, 8) = *(void *)(a2 + 48);
  *(void *)(a2 + 32) = 0LL;
  *(void *)(a2 + 4sub_10001AFB0((std::locale *)v24, " +$", 0) = 0LL;
  *(void *)(a2 + 4_Block_object_dispose(va, 8) = 0LL;
  *(void *)(v8 + 56) = 0LL;
  *(void *)(v8 + 64) = 0LL;
  *(void *)(v8 + 72) = 0LL;
  __n128 result = *(__n128 *)(a2 + 56);
  *(__n128 *)(v8 + 56) = result;
  *(void *)(v8 + 72) = *(void *)(a2 + 72);
  *(void *)(a2 + 56) = 0LL;
  *(void *)(a2 + 64) = 0LL;
  *(void *)(a2 + 72) = 0LL;
  uint64_t v11 = *(void *)(a2 + 80);
  *(void *)(v8 + 85) = *(void *)(a2 + 85);
  *(void *)(v8 + 8sub_10001AFB0((std::locale *)v24, " +$", 0) = v11;
  ++a1[5];
  return result;
}

uint64_t sub_10002412C(void *a1)
{
  uint64_t v2 = a1 + 5;
  unint64_t v3 = a1[5] + a1[4] - 1LL;
  sub_10001D560((uint64_t)(a1 + 5), (void *)(*(void *)(a1[1] + 8 * (v3 / 0x2A)) + 96 * (v3 % 0x2A)));
  --*v2;
  return sub_100024A0C(a1, 1);
}

int64x2_t sub_1000241AC(uint64_t a1, uint64_t a2)
{
  unint64_t v4 = *(void *)(a1 + 32);
  if (!v4)
  {
    sub_100024A80((void **)a1);
    unint64_t v4 = *(void *)(a1 + 32);
  }

  uint64_t v5 = *(void *)(a1 + 8);
  uint64_t v6 = (void *)(v5 + 8 * (v4 / 0x2A));
  uint64_t v7 = *v6 + 96 * (v4 % 0x2A);
  if (*(void *)(a1 + 16) == v5) {
    uint64_t v7 = 0LL;
  }
  if (v7 == *v6) {
    uint64_t v7 = *(v6 - 1) + 4032LL;
  }
  __int128 v8 = *(_OWORD *)(a2 + 16);
  *(_OWORD *)(v7 - 96) = *(_OWORD *)a2;
  *(_OWORD *)(v7 - 8sub_10001AFB0((std::locale *)v24, " +$", 0) = v8;
  *(void *)(v7 - 56) = 0LL;
  *(void *)(v7 - 4_Block_object_dispose(va, 8) = 0LL;
  *(void *)(v7 - 64) = 0LL;
  *(_OWORD *)(v7 - 64) = *(_OWORD *)(a2 + 32);
  *(void *)(v7 - 4_Block_object_dispose(va, 8) = *(void *)(a2 + 48);
  *(void *)(a2 + 32) = 0LL;
  *(void *)(a2 + 4sub_10001AFB0((std::locale *)v24, " +$", 0) = 0LL;
  *(void *)(a2 + 4_Block_object_dispose(va, 8) = 0LL;
  *(void *)(v7 - 4sub_10001AFB0((std::locale *)v24, " +$", 0) = 0LL;
  *(void *)(v7 - 32) = 0LL;
  *(void *)(v7 - 24) = 0LL;
  *(_OWORD *)(v7 - 4sub_10001AFB0((std::locale *)v24, " +$", 0) = *(_OWORD *)(a2 + 56);
  *(void *)(v7 - 24) = *(void *)(a2 + 72);
  *(void *)(a2 + 56) = 0LL;
  *(void *)(a2 + 64) = 0LL;
  *(void *)(a2 + 72) = 0LL;
  uint64_t v9 = *(void *)(a2 + 80);
  *(void *)(v7 - 11) = *(void *)(a2 + 85);
  *(void *)(v7 - 16) = v9;
  int64x2_t result = vaddq_s64(*(int64x2_t *)(a1 + 32), (int64x2_t)xmmword_1000ABE80);
  *(int64x2_t *)(a1 + 32) = result;
  return result;
}

void sub_10002429C(void *a1)
{
  unint64_t v2 = a1[4];
  BOOL v3 = v2 >= 0x2A;
  unint64_t v4 = v2 - 42;
  if (v3)
  {
    uint64_t v5 = (uint64_t)(a1 + 3);
    uint64_t v6 = (char *)a1[3];
    a1[4] = v4;
    uint64_t v7 = (void *)a1[1];
    __int128 v8 = (char *)a1[2];
    uint64_t v11 = *v7;
    uint64_t v9 = (char *)(v7 + 1);
    uint64_t v10 = v11;
    a1[1] = v9;
    if (v8 != v6)
    {
LABEL_33:
      *(void *)__int128 v8 = v10;
      a1[2] += 8LL;
      return;
    }

    uint64_t v12 = (uint64_t)&v9[-*a1];
    if ((unint64_t)v9 <= *a1)
    {
      else {
        unint64_t v33 = (uint64_t)&v8[-*a1] >> 2;
      }
      unint64_t v34 = (char *)sub_100018788(v5, v33);
      uint64_t v35 = &v34[8 * (v33 >> 2)];
      uint64_t v37 = &v34[8 * v36];
      char v38 = (uint64_t *)a1[1];
      __int128 v8 = v35;
      uint64_t v39 = a1[2] - (void)v38;
      if (v39)
      {
        __int128 v8 = &v35[v39 & 0xFFFFFFFFFFFFFFF8LL];
        uint64_t v40 = 8 * (v39 >> 3);
        __int16 v41 = &v34[8 * (v33 >> 2)];
        do
        {
          uint64_t v42 = *v38++;
          *(void *)__int16 v41 = v42;
          v41 += 8;
          v40 -= 8LL;
        }

        while (v40);
      }

      goto LABEL_30;
    }

LABEL_5:
    uint64_t v13 = v12 >> 3;
    BOOL v14 = v12 >> 3 < -1;
    uint64_t v15 = (v12 >> 3) + 2;
    if (v14) {
      uint64_t v16 = v15;
    }
    else {
      uint64_t v16 = v13 + 1;
    }
    uint64_t v17 = -(v16 >> 1);
    uint64_t v18 = v16 >> 1;
    uint64_t v19 = &v9[-8 * v18];
    int64_t v20 = v8 - v9;
    if (v8 != v9)
    {
      memmove(&v9[-8 * v18], v9, v8 - v9);
      uint64_t v9 = (char *)a1[1];
    }

    __int128 v8 = &v19[v20];
    a1[1] = &v9[8 * v17];
    a1[2] = &v19[v20];
    goto LABEL_33;
  }

  uint64_t v21 = a1[2];
  unint64_t v22 = (v21 - a1[1]) >> 3;
  uint64_t v23 = a1[3];
  uint64_t v24 = v23 - *a1;
  if (v22 < v24 >> 3)
  {
    if (v23 != v21)
    {
      *(void *)&__int128 v54 = operator new(0xFC0uLL);
      sub_1000245B0(a1, &v54);
      return;
    }

    *(void *)&__int128 v54 = operator new(0xFC0uLL);
    sub_1000246C4((uint64_t)a1, &v54);
    int v44 = (void *)a1[1];
    __int128 v8 = (char *)a1[2];
    uint64_t v45 = *v44;
    uint64_t v9 = (char *)(v44 + 1);
    uint64_t v10 = v45;
    a1[1] = v9;
    uint64_t v12 = (uint64_t)&v9[-*a1];
    if ((unint64_t)v9 <= *a1)
    {
      else {
        unint64_t v46 = (uint64_t)&v8[-*a1] >> 2;
      }
      unint64_t v34 = (char *)sub_100018788((uint64_t)(a1 + 3), v46);
      uint64_t v35 = &v34[8 * (v46 >> 2)];
      uint64_t v37 = &v34[8 * v47];
      uint64_t v48 = (uint64_t *)a1[1];
      __int128 v8 = v35;
      uint64_t v49 = a1[2] - (void)v48;
      if (v49)
      {
        __int128 v8 = &v35[v49 & 0xFFFFFFFFFFFFFFF8LL];
        uint64_t v50 = 8 * (v49 >> 3);
        uint64_t v51 = &v34[8 * (v46 >> 2)];
        do
        {
          uint64_t v52 = *v48++;
          *(void *)uint64_t v51 = v52;
          v51 += 8;
          v50 -= 8LL;
        }

        while (v50);
      }

    uint64_t v13 = v12 >> 3;
    BOOL v14 = v12 >> 3 < -1;
    uint64_t v15 = (v12 >> 3) + 2;
    if (v14) {
      uint64_t v16 = v15;
    }
    else {
      uint64_t v16 = v13 + 1;
    }
    uint64_t v17 = -(v16 >> 1);
    uint64_t v18 = v16 >> 1;
    uint64_t v19 = &v9[-8 * v18];
    int64_t v20 = v8 - v9;
    if (v8 != v9)
    {
      memmove(&v9[-8 * v18], v9, v8 - v9);
      uint64_t v9 = (char *)a1[1];
    }

    __int128 v8 = &v19[v20];
    a1[1] = &v9[8 * v17];
    a1[2] = &v19[v20];
    goto LABEL_33;
  }

  uint64_t v21 = a1[2];
  unint64_t v22 = (v21 - a1[1]) >> 3;
  uint64_t v23 = a1[3];
  uint64_t v24 = v23 - *a1;
  if (v22 < v24 >> 3)
  {
    if (v23 != v21)
    {
      *(void *)&__int128 v54 = operator new(0x1000uLL);
      sub_1000245B0(a1, &v54);
      return;
    }

    *(void *)&__int128 v54 = operator new(0x1000uLL);
    sub_1000246C4((uint64_t)a1, &v54);
    int v44 = (void *)a1[1];
    __int128 v8 = (char *)a1[2];
    uint64_t v45 = *v44;
    uint64_t v9 = (char *)(v44 + 1);
    uint64_t v10 = v45;
    a1[1] = v9;
    uint64_t v12 = (uint64_t)&v9[-*a1];
    if ((unint64_t)v9 <= *a1)
    {
      else {
        unint64_t v46 = (uint64_t)&v8[-*a1] >> 2;
      }
      unint64_t v34 = (char *)sub_100018788((uint64_t)(a1 + 3), v46);
      uint64_t v35 = &v34[8 * (v46 >> 2)];
      uint64_t v37 = &v34[8 * v47];
      uint64_t v48 = (uint64_t *)a1[1];
      __int128 v8 = v35;
      uint64_t v49 = a1[2] - (void)v48;
      if (v49)
      {
        __int128 v8 = &v35[v49 & 0xFFFFFFFFFFFFFFF8LL];
        uint64_t v50 = 8 * (v49 >> 3);
        uint64_t v51 = &v34[8 * (v46 >> 2)];
        do
        {
          uint64_t v52 = *v48++;
          *(void *)uint64_t v51 = v52;
          v51 += 8;
          v50 -= 8LL;
        }

        while (v50);
      }

  *a1 = v8;
  if ((a6 & 0x8000000000000000LL) != 0) {
    return 0LL;
  }
  else {
    return swift_unknownObjectRetain(a6 & 0xFFFFFFFFFFFFFFFLL);
  }
}

    uint64_t v13 = v12 >> 3;
    BOOL v14 = v12 >> 3 < -1;
    uint64_t v15 = (v12 >> 3) + 2;
    if (v14) {
      uint64_t v16 = v15;
    }
    else {
      uint64_t v16 = v13 + 1;
    }
    uint64_t v17 = -(v16 >> 1);
    uint64_t v18 = v16 >> 1;
    uint64_t v19 = &v9[-8 * v18];
    int64_t v20 = v8 - v9;
    if (v8 != v9)
    {
      memmove(&v9[-8 * v18], v9, v8 - v9);
      uint64_t v9 = (char *)a1[1];
    }

    __int128 v8 = &v19[v20];
    a1[1] = &v9[8 * v17];
    a1[2] = &v19[v20];
    goto LABEL_33;
  }

  uint64_t v21 = a1[2];
  unint64_t v22 = (v21 - a1[1]) >> 3;
  uint64_t v23 = a1[3];
  uint64_t v24 = v23 - *a1;
  if (v22 < v24 >> 3)
  {
    if (v23 != v21)
    {
      *(void *)&__int128 v54 = operator new(0x1000uLL);
      sub_1000245B0(a1, &v54);
      return;
    }

    *(void *)&__int128 v54 = operator new(0x1000uLL);
    sub_1000246C4((uint64_t)a1, &v54);
    int v44 = (void *)a1[1];
    __int128 v8 = (char *)a1[2];
    uint64_t v45 = *v44;
    uint64_t v9 = (char *)(v44 + 1);
    uint64_t v10 = v45;
    a1[1] = v9;
    uint64_t v12 = (uint64_t)&v9[-*a1];
    if ((unint64_t)v9 <= *a1)
    {
      else {
        unint64_t v46 = (uint64_t)&v8[-*a1] >> 2;
      }
      unint64_t v34 = (char *)sub_100018788((uint64_t)(a1 + 3), v46);
      uint64_t v35 = &v34[8 * (v46 >> 2)];
      uint64_t v37 = &v34[8 * v47];
      uint64_t v48 = (uint64_t *)a1[1];
      __int128 v8 = v35;
      uint64_t v49 = a1[2] - (void)v48;
      if (v49)
      {
        __int128 v8 = &v35[v49 & 0xFFFFFFFFFFFFFFF8LL];
        uint64_t v50 = 8 * (v49 >> 3);
        uint64_t v51 = &v34[8 * (v46 >> 2)];
        do
        {
          uint64_t v52 = *v48++;
          *(void *)uint64_t v51 = v52;
          v51 += 8;
          v50 -= 8LL;
        }

        while (v50);
      }

    uint64_t v13 = v12 >> 3;
    BOOL v14 = v12 >> 3 < -1;
    uint64_t v15 = (v12 >> 3) + 2;
    if (v14) {
      uint64_t v16 = v15;
    }
    else {
      uint64_t v16 = v13 + 1;
    }
    uint64_t v17 = -(v16 >> 1);
    uint64_t v18 = v16 >> 1;
    uint64_t v19 = &v9[-8 * v18];
    int64_t v20 = v8 - v9;
    if (v8 != v9)
    {
      memmove(&v9[-8 * v18], v9, v8 - v9);
      uint64_t v9 = (char *)a1[1];
    }

    __int128 v8 = &v19[v20];
    a1[1] = &v9[8 * v17];
    a1[2] = &v19[v20];
    goto LABEL_33;
  }

  uint64_t v21 = a1[2];
  unint64_t v22 = (v21 - a1[1]) >> 3;
  uint64_t v23 = a1[3];
  uint64_t v24 = v23 - *a1;
  if (v22 < v24 >> 3)
  {
    if (v23 != v21)
    {
      *(void *)&__int128 v54 = operator new(0x1000uLL);
      sub_1000245B0(a1, &v54);
      return;
    }

    *(void *)&__int128 v54 = operator new(0x1000uLL);
    sub_1000246C4((uint64_t)a1, &v54);
    int v44 = (void *)a1[1];
    __int128 v8 = (char *)a1[2];
    uint64_t v45 = *v44;
    uint64_t v9 = (char *)(v44 + 1);
    uint64_t v10 = v45;
    a1[1] = v9;
    uint64_t v12 = (uint64_t)&v9[-*a1];
    if ((unint64_t)v9 <= *a1)
    {
      else {
        unint64_t v46 = (uint64_t)&v8[-*a1] >> 2;
      }
      unint64_t v34 = (char *)sub_100018788((uint64_t)(a1 + 3), v46);
      uint64_t v35 = &v34[8 * (v46 >> 2)];
      uint64_t v37 = &v34[8 * v47];
      uint64_t v48 = (uint64_t *)a1[1];
      __int128 v8 = v35;
      uint64_t v49 = a1[2] - (void)v48;
      if (v49)
      {
        __int128 v8 = &v35[v49 & 0xFFFFFFFFFFFFFFF8LL];
        uint64_t v50 = 8 * (v49 >> 3);
        uint64_t v51 = &v34[8 * (v46 >> 2)];
        do
        {
          uint64_t v52 = *v48++;
          *(void *)uint64_t v51 = v52;
          v51 += 8;
          v50 -= 8LL;
        }

        while (v50);
      }

    uint64_t v13 = v12 >> 3;
    BOOL v14 = v12 >> 3 < -1;
    uint64_t v15 = (v12 >> 3) + 2;
    if (v14) {
      uint64_t v16 = v15;
    }
    else {
      uint64_t v16 = v13 + 1;
    }
    uint64_t v17 = -(v16 >> 1);
    uint64_t v18 = v16 >> 1;
    uint64_t v19 = &v9[-8 * v18];
    int64_t v20 = v8 - v9;
    if (v8 != v9)
    {
      memmove(&v9[-8 * v18], v9, v8 - v9);
      uint64_t v9 = (char *)a1[1];
    }

    __int128 v8 = &v19[v20];
    a1[1] = &v9[8 * v17];
    a1[2] = &v19[v20];
    goto LABEL_33;
  }

  uint64_t v21 = a1[2];
  unint64_t v22 = (v21 - a1[1]) >> 3;
  uint64_t v23 = a1[3];
  uint64_t v24 = v23 - *a1;
  if (v22 < v24 >> 3)
  {
    if (v23 != v21)
    {
      *(void *)&__int128 v54 = operator new(0x1000uLL);
      sub_1000245B0(a1, &v54);
      return;
    }

    *(void *)&__int128 v54 = operator new(0x1000uLL);
    sub_1000246C4((uint64_t)a1, &v54);
    int v44 = (void *)a1[1];
    __int128 v8 = (char *)a1[2];
    uint64_t v45 = *v44;
    uint64_t v9 = (char *)(v44 + 1);
    uint64_t v10 = v45;
    a1[1] = v9;
    uint64_t v12 = (uint64_t)&v9[-*a1];
    if ((unint64_t)v9 <= *a1)
    {
      else {
        unint64_t v46 = (uint64_t)&v8[-*a1] >> 2;
      }
      unint64_t v34 = (char *)sub_100018788((uint64_t)(a1 + 3), v46);
      uint64_t v35 = &v34[8 * (v46 >> 2)];
      uint64_t v37 = &v34[8 * v47];
      uint64_t v48 = (uint64_t *)a1[1];
      __int128 v8 = v35;
      uint64_t v49 = a1[2] - (void)v48;
      if (v49)
      {
        __int128 v8 = &v35[v49 & 0xFFFFFFFFFFFFFFF8LL];
        uint64_t v50 = 8 * (v49 >> 3);
        uint64_t v51 = &v34[8 * (v46 >> 2)];
        do
        {
          uint64_t v52 = *v48++;
          *(void *)uint64_t v51 = v52;
          v51 += 8;
          v50 -= 8LL;
        }

        while (v50);
      }

void sub_100024564( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void sub_1000245B0(void *a1, void *a2)
{
  uint64_t v5 = (char *)a1[3];
  uint64_t v4 = (uint64_t)(a1 + 3);
  uint64_t v6 = *(char **)(v4 - 8);
  if (v6 == v5)
  {
    uint64_t v7 = (char *)a1[1];
    uint64_t v8 = (uint64_t)&v7[-*a1];
    if ((unint64_t)v7 <= *a1)
    {
      else {
        unint64_t v18 = (uint64_t)&v6[-*a1] >> 2;
      }
      uint64_t v19 = (char *)sub_100018788(v4, v18);
      uint64_t v21 = &v19[8 * (v18 >> 2)];
      unint64_t v22 = (uint64_t *)a1[1];
      uint64_t v6 = v21;
      uint64_t v23 = a1[2] - (void)v22;
      if (v23)
      {
        uint64_t v6 = &v21[v23 & 0xFFFFFFFFFFFFFFF8LL];
        uint64_t v24 = 8 * (v23 >> 3);
        unint64_t v25 = &v19[8 * (v18 >> 2)];
        do
        {
          uint64_t v26 = *v22++;
          *(void *)unint64_t v25 = v26;
          v25 += 8;
          v24 -= 8LL;
        }

        while (v24);
      }

      uint64_t v27 = (char *)*a1;
      *a1 = v19;
      a1[1] = v21;
      a1[2] = v6;
      a1[3] = &v19[8 * v20];
      if (v27)
      {
        operator delete(v27);
        uint64_t v6 = (char *)a1[2];
      }
    }

    else
    {
      uint64_t v9 = v8 >> 3;
      BOOL v10 = v8 >> 3 < -1;
      uint64_t v11 = (v8 >> 3) + 2;
      if (v10) {
        uint64_t v12 = v11;
      }
      else {
        uint64_t v12 = v9 + 1;
      }
      uint64_t v13 = -(v12 >> 1);
      uint64_t v14 = v12 >> 1;
      uint64_t v15 = &v7[-8 * v14];
      int64_t v16 = v6 - v7;
      if (v6 != v7)
      {
        memmove(&v7[-8 * v14], v7, v6 - v7);
        uint64_t v6 = (char *)a1[1];
      }

      uint64_t v17 = &v6[8 * v13];
      uint64_t v6 = &v15[v16];
      a1[1] = v17;
      a1[2] = &v15[v16];
    }
  }

  *(void *)uint64_t v6 = *a2;
  a1[2] += 8LL;
}

void sub_1000246C4(uint64_t a1, void *a2)
{
  uint64_t v4 = *(char **)(a1 + 8);
  if (v4 == *(char **)a1)
  {
    uint64_t v6 = a1 + 24;
    uint64_t v7 = *(_BYTE **)(a1 + 24);
    uint64_t v8 = *(_BYTE **)(a1 + 16);
    if (v8 >= v7)
    {
      if (v7 == v4) {
        unint64_t v12 = 1LL;
      }
      else {
        unint64_t v12 = (v7 - v4) >> 2;
      }
      uint64_t v13 = 2 * v12;
      uint64_t v14 = (char *)sub_100018788(v6, v12);
      uint64_t v5 = &v14[(v13 + 6) & 0xFFFFFFFFFFFFFFF8LL];
      int64_t v16 = *(uint64_t **)(a1 + 8);
      uint64_t v17 = v5;
      uint64_t v18 = *(void *)(a1 + 16) - (void)v16;
      if (v18)
      {
        uint64_t v17 = &v5[v18 & 0xFFFFFFFFFFFFFFF8LL];
        uint64_t v19 = 8 * (v18 >> 3);
        uint64_t v20 = v5;
        do
        {
          uint64_t v21 = *v16++;
          *(void *)uint64_t v20 = v21;
          v20 += 8;
          v19 -= 8LL;
        }

        while (v19);
      }

      unint64_t v22 = *(char **)a1;
      *(void *)a1 = v14;
      *(void *)(a1 + _Block_object_dispose(va, 8) = v5;
      *(void *)(a1 + 16) = v17;
      *(void *)(a1 + 24) = &v14[8 * v15];
      if (v22)
      {
        operator delete(v22);
        uint64_t v5 = *(char **)(a1 + 8);
      }
    }

    else
    {
      uint64_t v9 = (v7 - v8) >> 3;
      if (v9 >= -1) {
        uint64_t v10 = v9 + 1;
      }
      else {
        uint64_t v10 = v9 + 2;
      }
      uint64_t v11 = v10 >> 1;
      uint64_t v5 = &v4[8 * (v10 >> 1)];
      if (v8 != v4)
      {
        memmove(&v4[8 * (v10 >> 1)], v4, v8 - v4);
        uint64_t v4 = *(char **)(a1 + 16);
      }

      *(void *)(a1 + _Block_object_dispose(va, 8) = v5;
      *(void *)(a1 + 16) = &v4[8 * v11];
    }
  }

  else
  {
    uint64_t v5 = *(char **)(a1 + 8);
  }

  *((void *)v5 - 1) = *a2;
  *(void *)(a1 + 8) -= 8LL;
}

void sub_1000247E0(void *a1, void *a2)
{
  uint64_t v4 = (char *)a1[2];
  if (v4 == (char *)a1[3])
  {
    uint64_t v5 = (char *)a1[1];
    uint64_t v6 = (uint64_t)&v5[-*a1];
    if ((unint64_t)v5 <= *a1)
    {
      else {
        unint64_t v16 = (uint64_t)&v4[-*a1] >> 2;
      }
      uint64_t v17 = (char *)sub_100018788(a1[4], v16);
      uint64_t v19 = &v17[8 * (v16 >> 2)];
      uint64_t v20 = (uint64_t *)a1[1];
      uint64_t v4 = v19;
      uint64_t v21 = a1[2] - (void)v20;
      if (v21)
      {
        uint64_t v4 = &v19[v21 & 0xFFFFFFFFFFFFFFF8LL];
        uint64_t v22 = 8 * (v21 >> 3);
        uint64_t v23 = &v17[8 * (v16 >> 2)];
        do
        {
          uint64_t v24 = *v20++;
          *(void *)uint64_t v23 = v24;
          v23 += 8;
          v22 -= 8LL;
        }

        while (v22);
      }

      unint64_t v25 = (char *)*a1;
      *a1 = v17;
      a1[1] = v19;
      a1[2] = v4;
      a1[3] = &v17[8 * v18];
      if (v25)
      {
        operator delete(v25);
        uint64_t v4 = (char *)a1[2];
      }
    }

    else
    {
      uint64_t v7 = v6 >> 3;
      BOOL v8 = v6 >> 3 < -1;
      uint64_t v9 = (v6 >> 3) + 2;
      if (v8) {
        uint64_t v10 = v9;
      }
      else {
        uint64_t v10 = v7 + 1;
      }
      uint64_t v11 = -(v10 >> 1);
      uint64_t v12 = v10 >> 1;
      uint64_t v13 = &v5[-8 * v12];
      int64_t v14 = v4 - v5;
      if (v4 != v5)
      {
        memmove(&v5[-8 * v12], v5, v4 - v5);
        uint64_t v4 = (char *)a1[1];
      }

      uint64_t v15 = &v4[8 * v11];
      uint64_t v4 = &v13[v14];
      a1[1] = v15;
      a1[2] = &v13[v14];
    }
  }

  *(void *)uint64_t v4 = *a2;
  a1[2] += 8LL;
}

void sub_1000248F4(uint64_t a1, void *a2)
{
  uint64_t v4 = *(char **)(a1 + 8);
  if (v4 == *(char **)a1)
  {
    uint64_t v6 = *(_BYTE **)(a1 + 16);
    uint64_t v7 = *(_BYTE **)(a1 + 24);
    if (v6 >= v7)
    {
      if (v7 == v4) {
        unint64_t v11 = 1LL;
      }
      else {
        unint64_t v11 = (v7 - v4) >> 2;
      }
      uint64_t v12 = 2 * v11;
      uint64_t v13 = (char *)sub_100018788(*(void *)(a1 + 32), v11);
      uint64_t v5 = &v13[(v12 + 6) & 0xFFFFFFFFFFFFFFF8LL];
      uint64_t v15 = *(uint64_t **)(a1 + 8);
      unint64_t v16 = v5;
      uint64_t v17 = *(void *)(a1 + 16) - (void)v15;
      if (v17)
      {
        unint64_t v16 = &v5[v17 & 0xFFFFFFFFFFFFFFF8LL];
        uint64_t v18 = 8 * (v17 >> 3);
        uint64_t v19 = v5;
        do
        {
          uint64_t v20 = *v15++;
          *(void *)uint64_t v19 = v20;
          v19 += 8;
          v18 -= 8LL;
        }

        while (v18);
      }

      uint64_t v21 = *(char **)a1;
      *(void *)a1 = v13;
      *(void *)(a1 + _Block_object_dispose(va, 8) = v5;
      *(void *)(a1 + 16) = v16;
      *(void *)(a1 + 24) = &v13[8 * v14];
      if (v21)
      {
        operator delete(v21);
        uint64_t v5 = *(char **)(a1 + 8);
      }
    }

    else
    {
      uint64_t v8 = (v7 - v6) >> 3;
      if (v8 >= -1) {
        uint64_t v9 = v8 + 1;
      }
      else {
        uint64_t v9 = v8 + 2;
      }
      uint64_t v10 = v9 >> 1;
      uint64_t v5 = &v4[8 * (v9 >> 1)];
      if (v6 != v4)
      {
        memmove(&v4[8 * (v9 >> 1)], v4, v6 - v4);
        uint64_t v4 = *(char **)(a1 + 16);
      }

      *(void *)(a1 + _Block_object_dispose(va, 8) = v5;
      *(void *)(a1 + 16) = &v4[8 * v10];
    }
  }

  else
  {
    uint64_t v5 = *(char **)(a1 + 8);
  }

  *((void *)v5 - 1) = *a2;
  *(void *)(a1 + 8) -= 8LL;
}

uint64_t sub_100024A0C(void *a1, int a2)
{
  uint64_t v3 = a1[1];
  uint64_t v2 = a1[2];
  if (v2 == v3) {
    uint64_t v4 = 0LL;
  }
  else {
    uint64_t v4 = 42 * ((v2 - v3) >> 3) - 1;
  }
  unint64_t v5 = v4 - (a1[5] + a1[4]);
  if (v5 < 0x2A) {
    a2 = 1;
  }
  if (v5 < 0x54) {
    int v7 = a2;
  }
  else {
    int v7 = 0;
  }
  if ((v7 & 1) == 0)
  {
    operator delete(*(void **)(v2 - 8));
    a1[2] -= 8LL;
  }

  return v7 ^ 1u;
}

void sub_100024A80(void **a1)
{
  uint64_t v2 = a1[1];
  uint64_t v3 = a1[2];
  unint64_t v4 = (v3 - v2) >> 3;
  if (v3 == v2) {
    uint64_t v5 = 0LL;
  }
  else {
    uint64_t v5 = 42 * v4 - 1;
  }
  uint64_t v6 = (char *)a1[4];
  if (v5 - (unint64_t)&v6[(void)a1[5]] < 0x2A)
  {
    uint64_t v7 = (uint64_t)(a1 + 3);
    uint64_t v8 = a1[3];
    uint64_t v9 = *a1;
    uint64_t v10 = v8 - (_BYTE *)*a1;
    if (v4 >= v10 >> 3)
    {
      if (v8 == v9) {
        unint64_t v11 = 1LL;
      }
      else {
        unint64_t v11 = v10 >> 2;
      }
      unint64_t v46 = a1 + 3;
      std::string __p = sub_100018788(v7, v11);
      char v43 = (char *)__p;
      int v44 = (char *)__p;
      uint64_t v45 = (char *)__p + 8 * v12;
      __int16 v41 = operator new(0xFC0uLL);
      sub_1000247E0(&__p, &v41);
      uint64_t v13 = (char *)a1[1];
      uint64_t v14 = v44;
      if (v13 == a1[2])
      {
        unint64_t v33 = (char *)a1[1];
      }

      else
      {
        do
        {
          if (v14 == v45)
          {
            int64_t v15 = v43 - (_BYTE *)__p;
            if (v43 <= __p)
            {
              if (v14 == __p) {
                unint64_t v23 = 1LL;
              }
              else {
                unint64_t v23 = (v14 - (_BYTE *)__p) >> 2;
              }
              uint64_t v24 = (char *)sub_100018788((uint64_t)v46, v23);
              uint64_t v26 = v43;
              uint64_t v14 = &v24[8 * (v23 >> 2)];
              uint64_t v27 = v44 - v43;
              if (v44 != v43)
              {
                uint64_t v14 = &v24[8 * (v23 >> 2) + (v27 & 0xFFFFFFFFFFFFFFF8LL)];
                uint64_t v28 = 8 * (v27 >> 3);
                unint64_t v29 = &v24[8 * (v23 >> 2)];
                do
                {
                  uint64_t v30 = *(void *)v26;
                  v26 += 8;
                  *(void *)unint64_t v29 = v30;
                  v29 += 8;
                  v28 -= 8LL;
                }

                while (v28);
              }

              __int128 v31 = __p;
              std::string __p = v24;
              char v43 = &v24[8 * (v23 >> 2)];
              int v44 = v14;
              uint64_t v45 = &v24[8 * v25];
              if (v31)
              {
                operator delete(v31);
                uint64_t v14 = v44;
              }
            }

            else
            {
              uint64_t v16 = v15 >> 3;
              BOOL v17 = v15 >> 3 < -1;
              uint64_t v18 = (v15 >> 3) + 2;
              if (v17) {
                uint64_t v19 = v18;
              }
              else {
                uint64_t v19 = v16 + 1;
              }
              uint64_t v20 = &v43[-8 * (v19 >> 1)];
              int64_t v21 = v14 - v43;
              if (v14 != v43)
              {
                memmove(&v43[-8 * (v19 >> 1)], v43, v14 - v43);
                uint64_t v14 = v43;
              }

              uint64_t v22 = &v14[-8 * (v19 >> 1)];
              uint64_t v14 = &v20[v21];
              char v43 = v22;
              int v44 = &v20[v21];
            }
          }

          uint64_t v32 = *(void *)v13;
          v13 += 8;
          *(void *)uint64_t v14 = v32;
          uint64_t v14 = v44 + 8;
          v44 += 8;
        }

        while (v13 != a1[2]);
        unint64_t v33 = (char *)a1[1];
      }

      uint64_t v36 = *a1;
      uint64_t v37 = v43;
      *a1 = __p;
      a1[1] = v37;
      std::string __p = v36;
      char v43 = v33;
      char v38 = (char *)a1[3];
      uint64_t v39 = v45;
      a1[2] = v14;
      a1[3] = v39;
      int v44 = v13;
      uint64_t v45 = v38;
      if (v14 - v37 == 8) {
        uint64_t v40 = 21LL;
      }
      else {
        uint64_t v40 = (uint64_t)a1[4] + 42;
      }
      a1[4] = (void *)v40;
      if (v13 != v33) {
        int v44 = &v13[(v33 - v13 + 7) & 0xFFFFFFFFFFFFFFF8LL];
      }
      if (v36) {
        operator delete(v36);
      }
    }

    else
    {
      if (v2 == v9)
      {
        std::string __p = operator new(0xFC0uLL);
        sub_1000245B0(a1, &__p);
        unint64_t v34 = a1[2];
        std::string __p = (void *)*(v34 - 1);
        a1[2] = v34 - 1;
      }

      else
      {
        std::string __p = operator new(0xFC0uLL);
      }

      sub_1000246C4((uint64_t)a1, &__p);
      if ((_BYTE *)a1[2] - (_BYTE *)a1[1] == 8) {
        uint64_t v35 = 21LL;
      }
      else {
        uint64_t v35 = (uint64_t)a1[4] + 42;
      }
      a1[4] = (void *)v35;
    }
  }

  else
  {
    a1[4] = v6 + 42;
    std::string __p = (void *)*((void *)v3 - 1);
    a1[2] = v3 - 8;
    sub_1000246C4((uint64_t)a1, &__p);
  }

void sub_100024D4C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_100024D98(void *a1)
{
  uint64_t v2 = a1 + 5;
  uint64_t v3 = (void **)a1[1];
  unint64_t v4 = (void **)a1[2];
  if (v4 == v3)
  {
    unint64_t v4 = (void **)a1[1];
  }

  else
  {
    unint64_t v5 = a1[4];
    uint64_t v6 = &v3[v5 / 0x2A];
    uint64_t v7 = (char *)*v6 + 96 * (v5 % 0x2A);
    unint64_t v8 = (unint64_t)v3[(a1[5] + v5) / 0x2A] + 96 * ((a1[5] + v5) % 0x2A);
    if (v7 != (char *)v8)
    {
      do
      {
        sub_10001D560((uint64_t)v2, v7);
        v7 += 96;
        if (v7 - (_BYTE *)*v6 == 4032)
        {
          uint64_t v9 = (char *)v6[1];
          ++v6;
          uint64_t v7 = v9;
        }
      }

      while (v7 != (char *)v8);
      uint64_t v3 = (void **)a1[1];
      unint64_t v4 = (void **)a1[2];
    }
  }

  void *v2 = 0LL;
  unint64_t v10 = (char *)v4 - (char *)v3;
  if ((unint64_t)((char *)v4 - (char *)v3) >= 0x11)
  {
    do
    {
      operator delete(*v3);
      unint64_t v4 = (void **)a1[2];
      uint64_t v3 = (void **)(a1[1] + 8LL);
      a1[1] = v3;
      unint64_t v10 = (char *)v4 - (char *)v3;
    }

    while ((unint64_t)((char *)v4 - (char *)v3) > 0x10);
  }

  unint64_t v11 = v10 >> 3;
  if (v11 == 1)
  {
    uint64_t v12 = 21LL;
  }

  else
  {
    if (v11 != 2) {
      goto LABEL_16;
    }
    uint64_t v12 = 42LL;
  }

  a1[4] = v12;
LABEL_16:
  while (v3 != v4)
  {
    uint64_t v13 = *v3++;
    operator delete(v13);
  }

  return sub_100024EDC((uint64_t)a1);
}

uint64_t sub_100024EDC(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  uint64_t v2 = *(void *)(a1 + 16);
  if (v2 != v3) {
    *(void *)(a1 + 16) = v2 + ((v3 - v2 + 7) & 0xFFFFFFFFFFFFFFF8LL);
  }
  unint64_t v4 = *(void **)a1;
  if (*(void *)a1) {
    operator delete(v4);
  }
  return a1;
}

char *sub_100024F28(void *a1, __int128 *a2, __int128 *a3, unint64_t a4)
{
  uint64_t v6 = a2;
  uint64_t v8 = a1[2];
  int64x2_t result = (char *)*a1;
  if (0xAAAAAAAAAAAAAAABLL * ((v8 - (uint64_t)result) >> 3) >= a4)
  {
    uint64_t v19 = (char *)a1[1];
    uint64_t v14 = a1 + 1;
    uint64_t v13 = v19;
    unint64_t v20 = 0xAAAAAAAAAAAAAAABLL * ((v19 - result) >> 3);
    if (v20 >= a4)
    {
      uint64_t v25 = result;
      if (a2 != a3)
      {
        uint64_t v26 = result;
        do
        {
          *(_OWORD *)uint64_t v26 = *v6;
          v26[16] = *((_BYTE *)v6 + 16);
          v25 += 24;
          uint64_t v6 = (__int128 *)((char *)v6 + 24);
          v26 += 24;
        }

        while (v6 != a3);
      }

      int64_t v18 = v25 - result;
      uint64_t v13 = result;
    }

    else
    {
      int64_t v21 = (__int128 *)((char *)a2 + 24 * v20);
      if (v13 != result)
      {
        do
        {
          *(_OWORD *)int64x2_t result = *v6;
          result[16] = *((_BYTE *)v6 + 16);
          uint64_t v6 = (__int128 *)((char *)v6 + 24);
          result += 24;
        }

        while (v6 != v21);
      }

      uint64_t v22 = v13;
      if (v21 != a3)
      {
        unint64_t v23 = v13;
        do
        {
          __int128 v24 = *v21;
          *((void *)v23 + 2) = *((void *)v21 + 2);
          *(_OWORD *)unint64_t v23 = v24;
          v23 += 24;
          int64_t v21 = (__int128 *)((char *)v21 + 24);
          v22 += 24;
        }

        while (v21 != a3);
      }

      int64_t v18 = v22 - v13;
    }
  }

  else
  {
    if (result)
    {
      a1[1] = result;
      operator delete(result);
      uint64_t v8 = 0LL;
      *a1 = 0LL;
      a1[1] = 0LL;
      a1[2] = 0LL;
    }

    if (a4 > 0xAAAAAAAAAAAAAAALL) {
      sub_100018774();
    }
    unint64_t v10 = 0xAAAAAAAAAAAAAAABLL * (v8 >> 3);
    uint64_t v11 = 2 * v10;
    if (2 * v10 <= a4) {
      uint64_t v11 = a4;
    }
    if (v10 >= 0x555555555555555LL) {
      unint64_t v12 = 0xAAAAAAAAAAAAAAALL;
    }
    else {
      unint64_t v12 = v11;
    }
    int64x2_t result = sub_100019ABC(a1, v12);
    int64_t v15 = (char *)a1[1];
    uint64_t v14 = a1 + 1;
    uint64_t v13 = v15;
    uint64_t v16 = v15;
    if (v6 != a3)
    {
      uint64_t v16 = v13;
      do
      {
        __int128 v17 = *v6;
        *((void *)v16 + 2) = *((void *)v6 + 2);
        *(_OWORD *)uint64_t v16 = v17;
        v16 += 24;
        uint64_t v6 = (__int128 *)((char *)v6 + 24);
      }

      while (v6 != a3);
    }

    int64_t v18 = v16 - v13;
  }

  *uint64_t v14 = &v13[v18];
  return result;
}

char *sub_1000250DC(void *a1, uint64_t *a2, uint64_t *a3, unint64_t a4)
{
  uint64_t v6 = a2;
  uint64_t v8 = a1[2];
  int64x2_t result = (char *)*a1;
  if (a4 <= (v8 - (uint64_t)result) >> 4)
  {
    int64_t v18 = (char *)a1[1];
    uint64_t v13 = a1 + 1;
    unint64_t v12 = v18;
    unint64_t v19 = (v18 - result) >> 4;
    if (v19 >= a4)
    {
      uint64_t v26 = result;
      if (a2 != a3)
      {
        uint64_t v27 = result;
        do
        {
          uint64_t v28 = *v6;
          uint64_t v29 = v6[1];
          v6 += 2;
          *(void *)uint64_t v27 = v28;
          *((void *)v27 + 1) = v29;
          v27 += 16;
          v26 += 16;
        }

        while (v6 != a3);
      }

      __int128 v17 = (char *)(v26 - result);
      unint64_t v12 = result;
    }

    else
    {
      unint64_t v20 = (__int128 *)&a2[2 * v19];
      if (v12 != result)
      {
        do
        {
          uint64_t v21 = *v6;
          uint64_t v22 = v6[1];
          v6 += 2;
          *(void *)int64x2_t result = v21;
          *((void *)result + 1) = v22;
          result += 16;
        }

        while (v6 != (uint64_t *)v20);
      }

      unint64_t v23 = v12;
      if (v20 != (__int128 *)a3)
      {
        __int128 v24 = v12;
        do
        {
          __int128 v25 = *v20++;
          *(_OWORD *)__int128 v24 = v25;
          v24 += 16;
          v23 += 16;
        }

        while (v20 != (__int128 *)a3);
      }

      __int128 v17 = (char *)(v23 - v12);
    }
  }

  else
  {
    if (result)
    {
      a1[1] = result;
      operator delete(result);
      uint64_t v8 = 0LL;
      *a1 = 0LL;
      a1[1] = 0LL;
      a1[2] = 0LL;
    }

    if (a4 >> 60) {
      sub_100018774();
    }
    uint64_t v10 = v8 >> 3;
    if (v8 >> 3 <= a4) {
      uint64_t v10 = a4;
    }
    else {
      unint64_t v11 = v10;
    }
    int64x2_t result = sub_10001D984(a1, v11);
    uint64_t v14 = (char *)a1[1];
    uint64_t v13 = a1 + 1;
    unint64_t v12 = v14;
    int64_t v15 = v14;
    if (v6 != a3)
    {
      int64_t v15 = v12;
      do
      {
        __int128 v16 = *(_OWORD *)v6;
        v6 += 2;
        *(_OWORD *)int64_t v15 = v16;
        v15 += 16;
      }

      while (v6 != a3);
    }

    __int128 v17 = (char *)(v15 - v12);
  }

  *uint64_t v13 = &v17[(void)v12];
  return result;
}

void sub_100025228(uint64_t a1, unint64_t a2)
{
  unint64_t v2 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a1 + 8) - *(void *)a1) >> 3);
  BOOL v3 = a2 >= v2;
  unint64_t v4 = a2 - v2;
  if (v4 != 0 && v3)
  {
    sub_100025264((void **)a1, v4);
  }

  else if (!v3)
  {
    *(void *)(a1 + _Block_object_dispose(va, 8) = *(void *)a1 + 24 * a2;
  }

void sub_100025264(void **a1, unint64_t a2)
{
  uint64_t v6 = a1[2];
  uint64_t v4 = (uint64_t)(a1 + 2);
  unint64_t v5 = v6;
  uint64_t v7 = *(void **)(v4 - 8);
  if (0xAAAAAAAAAAAAAAABLL * ((v6 - (_BYTE *)v7) >> 3) >= a2)
  {
    if (a2)
    {
      uint64_t v13 = &v7[3 * a2];
      uint64_t v14 = 24 * a2;
      do
      {
        *uint64_t v7 = 0LL;
        v7[1] = 0LL;
        *((_BYTE *)v7 + 16) = 0;
        v7 += 3;
        v14 -= 24LL;
      }

      while (v14);
      uint64_t v7 = v13;
    }

    a1[1] = v7;
  }

  else
  {
    unint64_t v8 = 0xAAAAAAAAAAAAAAABLL * (((char *)v7 - (_BYTE *)*a1) >> 3);
    unint64_t v9 = v8 + a2;
    if (v8 + a2 > 0xAAAAAAAAAAAAAAALL) {
      sub_100018774();
    }
    unint64_t v10 = 0xAAAAAAAAAAAAAAABLL * ((v5 - (_BYTE *)*a1) >> 3);
    if (2 * v10 > v9) {
      unint64_t v9 = 2 * v10;
    }
    if (v10 >= 0x555555555555555LL) {
      unint64_t v11 = 0xAAAAAAAAAAAAAAALL;
    }
    else {
      unint64_t v11 = v9;
    }
    if (v11) {
      unint64_t v12 = (char *)sub_100018F00(v4, v11);
    }
    else {
      unint64_t v12 = 0LL;
    }
    int64_t v15 = &v12[24 * v8];
    __int128 v16 = &v15[24 * a2];
    uint64_t v17 = 24 * a2;
    int64_t v18 = v15;
    do
    {
      *(void *)int64_t v18 = 0LL;
      *((void *)v18 + 1) = 0LL;
      v18[16] = 0;
      v18 += 24;
      v17 -= 24LL;
    }

    while (v17);
    unint64_t v19 = &v12[24 * v11];
    uint64_t v21 = (char *)*a1;
    unint64_t v20 = (char *)a1[1];
    if (v20 != *a1)
    {
      do
      {
        __int128 v22 = *(_OWORD *)(v20 - 24);
        *((void *)v15 - 1) = *((void *)v20 - 1);
        *(_OWORD *)(v15 - 24) = v22;
        v15 -= 24;
        v20 -= 24;
      }

      while (v20 != v21);
      unint64_t v20 = (char *)*a1;
    }

    *a1 = v15;
    a1[1] = v16;
    a1[2] = v19;
    if (v20) {
      operator delete(v20);
    }
  }

uint64_t sub_1000253CC(uint64_t a1, uint64_t a2)
{
  if (*(_BYTE *)(a1 + 16))
  {
    sub_10001FD64(&__p, *(char **)a1, *(char **)(a1 + 8), *(void *)(a1 + 8) - *(void *)a1);
  }

  else
  {
    std::string __p = 0LL;
    size_t v19 = 0LL;
    uint64_t v20 = 0LL;
  }

  if (*(_BYTE *)(a2 + 16))
  {
    sub_10001FD64(&v15, *(char **)a2, *(char **)(a2 + 8), *(void *)(a2 + 8) - *(void *)a2);
    unsigned int v3 = HIBYTE(v17);
    unint64_t v5 = v15;
    size_t v4 = v16;
  }

  else
  {
    size_t v4 = 0LL;
    unint64_t v5 = 0LL;
    unsigned int v3 = 0;
    int64_t v15 = 0LL;
    size_t v16 = 0LL;
    uint64_t v17 = 0LL;
  }

  char v6 = HIBYTE(v20);
  if (v20 >= 0) {
    size_t v7 = HIBYTE(v20);
  }
  else {
    size_t v7 = v19;
  }
  if (v20 >= 0) {
    p_p = &__p;
  }
  else {
    p_p = __p;
  }
  if ((v3 & 0x80u) == 0) {
    size_t v9 = v3;
  }
  else {
    size_t v9 = v4;
  }
  if ((v3 & 0x80u) == 0) {
    unint64_t v10 = (void **)&v15;
  }
  else {
    unint64_t v10 = v5;
  }
  if (v9 >= v7) {
    size_t v11 = v7;
  }
  else {
    size_t v11 = v9;
  }
  unsigned int v12 = memcmp(p_p, v10, v11);
  if ((v3 & 0x80) != 0)
  {
    operator delete(v5);
    if ((v20 & 0x8000000000000000LL) == 0) {
      goto LABEL_24;
    }
  }

  else if ((v6 & 0x80) == 0)
  {
    goto LABEL_24;
  }

  operator delete(__p);
LABEL_24:
  unsigned int v13 = v9 < v7;
  if (v7 < v9) {
    unsigned int v13 = -1;
  }
  if (v12) {
    return v12;
  }
  else {
    return v13;
  }
}

void sub_1000254DC( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1000254F8(void ***a1)
{
  uint64_t v1 = *a1;
  if (*a1)
  {
    unsigned int v3 = a1[1];
    size_t v4 = *a1;
    if (v3 != v1)
    {
      do
      {
        v3 -= 3;
        unint64_t v5 = v3;
        sub_100018E1C(&v5);
      }

      while (v3 != v1);
      size_t v4 = *a1;
    }

    a1[1] = v1;
    operator delete(v4);
    *a1 = 0LL;
    a1[1] = 0LL;
    a1[2] = 0LL;
  }

id RDQSRReplacementDictationaryWithEtiquettes(const __CFString *a1)
{
  unint64_t v2 = +[NSData dataWithContentsOfFile:options:error:]( &OBJC_CLASS___NSData,  "dataWithContentsOfFile:options:error:",  a1,  0LL,  &v13);
  if (!v2)
  {
    char v6 = (os_log_s *)RXOSLog();
    if (!os_log_type_enabled(v6, OS_LOG_TYPE_ERROR)) {
      return 0LL;
    }
    *(_DWORD *)std::string buf = 138412546;
    *(void *)&uint8_t buf[4] = a1;
    *(_WORD *)&buf[12] = 2112;
    *(void *)&buf[14] = v13;
    size_t v7 = "Could not read %@: %@";
LABEL_10:
    unint64_t v8 = v6;
LABEL_13:
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, v7, buf, 0x16u);
    return 0LL;
  }

  id v3 = +[NSJSONSerialization JSONObjectWithData:options:error:]( &OBJC_CLASS___NSJSONSerialization,  "JSONObjectWithData:options:error:",  v2,  0LL,  &v13);
  if (!v3)
  {
    char v6 = (os_log_s *)RXOSLog();
    if (!os_log_type_enabled(v6, OS_LOG_TYPE_ERROR)) {
      return 0LL;
    }
    *(_DWORD *)std::string buf = 138412546;
    *(void *)&uint8_t buf[4] = a1;
    *(_WORD *)&buf[12] = 2112;
    *(void *)&buf[14] = v13;
    size_t v7 = "Could not parse %@: %@";
    goto LABEL_10;
  }

  uint64_t v4 = objc_opt_class(&OBJC_CLASS___NSDictionary);
  if ((objc_opt_isKindOfClass(v3, v4) & 1) == 0)
  {
    size_t v9 = (os_log_s *)RXOSLog();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      uint64_t v10 = objc_opt_class(v3);
      *(_DWORD *)std::string buf = 138412546;
      *(void *)&uint8_t buf[4] = a1;
      *(_WORD *)&buf[12] = 2112;
      *(void *)&buf[14] = v10;
      size_t v7 = "%@ is wrong type: %@";
      unint64_t v8 = v9;
      goto LABEL_13;
    }

    return 0LL;
  }

  *(void *)std::string buf = 0LL;
  *(void *)&buf[8] = buf;
  *(void *)&uint8_t buf[16] = 0x2020000000LL;
  char v15 = 1;
  v12[0] = _NSConcreteStackBlock;
  v12[1] = 3221225472LL;
  v12[2] = sub_1000257B8;
  void v12[3] = &unk_1000CEB38;
  v12[4] = a1;
  v12[5] = buf;
  [v3 enumerateKeysAndObjectsUsingBlock:v12];
  if (*(_BYTE *)(*(void *)&buf[8] + 24LL)) {
    id v5 = v3;
  }
  else {
    id v5 = 0LL;
  }
  _Block_object_dispose(buf, 8);
  return v5;
}

void sub_100025798( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
}

void sub_1000257B8(uint64_t a1, uint64_t a2, uint64_t a3, _BYTE *a4)
{
  uint64_t v8 = objc_opt_class(&OBJC_CLASS___NSString);
  if ((objc_opt_isKindOfClass(a2, v8) & 1) == 0
    || (uint64_t v9 = objc_opt_class(&OBJC_CLASS___NSString), (objc_opt_isKindOfClass(a3, v9) & 1) == 0))
  {
    uint64_t v10 = (os_log_s *)RXOSLog();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      uint64_t v11 = *(void *)(a1 + 32);
      int v12 = 138412802;
      uint64_t v13 = v11;
      __int16 v14 = 2112;
      uint64_t v15 = a2;
      __int16 v16 = 2112;
      uint64_t v17 = a3;
      _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_ERROR,  "%@ contains bogus key/value pair: %@ => %@",  (uint8_t *)&v12,  0x20u);
    }

    *a4 = 1;
    *(_BYTE *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL) = 0;
  }

CFMutableStringRef RDLanguageAssets::createLanguageFromLocaleID(CFStringRef theString, const __CFString *a2)
{
  CFMutableStringRef MutableCopy = CFStringCreateMutableCopy(0LL, 0LL, theString);
  v4.length = CFStringGetLength(MutableCopy);
  v4.id location = 0LL;
  CFStringFindAndReplace(MutableCopy, @"_", @"-", v4, 0LL);
  return MutableCopy;
}

CFMutableStringRef RDLanguageAssets::createLocaleIDFromLanguage(CFStringRef theString, const __CFString *a2)
{
  CFMutableStringRef MutableCopy = CFStringCreateMutableCopy(0LL, 0LL, theString);
  v4.length = CFStringGetLength(MutableCopy);
  v4.id location = 0LL;
  CFStringFindAndReplace(MutableCopy, @"-", @"_", v4, 0LL);
  return MutableCopy;
}

const __CFDictionary *RDLanguageAssets::CopyInstallationStatus(RDLanguageAssets *this)
{
  uint64_t v8 = 0LL;
  if (qword_1000DDD08 != -1) {
    dispatch_once(&qword_1000DDD08, &stru_1000CEB58);
  }
  uint64_t v1 = (const __CFDictionary *)[(id)qword_1000DDD00 copyInstallationStatusForLangaugesWithError:&v8];
  unint64_t v2 = (os_log_s *)RXOSLog();
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)std::string buf = 138412290;
    uint64_t v10 = v1;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "InstallationStatus resultStatus=%@", buf, 0xCu);
  }

  if (v8)
  {
    id v3 = (os_log_s *)RXOSLog();
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)std::string buf = 138412290;
      uint64_t v10 = v8;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_ERROR, "InstallationStatus failed with: %@", buf, 0xCu);
    }
  }

  if (!v1) {
    return 0LL;
  }
  CFMutableStringRef MutableCopy = CFDictionaryCreateMutableCopy(kCFAllocatorDefault, 0LL, v1);
  id v5 = (RDLanguageAssets *)RXGetAssetFallbackLocales();
  if (v5) {
    RDLanguageAssets::addAliasLocalesToResultStatus(v5, MutableCopy, v6);
  }
  CFRelease(v1);
  return MutableCopy;
}

void RDLanguageAssets::addAliasLocalesToResultStatus( RDLanguageAssets *this, const __CFDictionary *a2, __CFDictionary *a3)
{
  CFIndex Count = CFDictionaryGetCount(this);
  if (Count >= 1)
  {
    CFIndex v6 = Count;
    size_t v7 = (const void **)malloc(8 * Count);
    CFDictionaryGetKeysAndValues(this, v7, 0LL);
    for (uint64_t i = 0LL; i != v6; ++i)
    {
      CFMutableStringRef LanguageFromLocaleID = RDLanguageAssets::createLanguageFromLocaleID((CFStringRef)v7[i], v8);
      Value = (const __CFString *)CFDictionaryGetValue(this, v7[i]);
      if (Value)
      {
        CFMutableStringRef v13 = RDLanguageAssets::createLanguageFromLocaleID(Value, v12);
        __int16 v14 = CFDictionaryGetValue(a2, v13);
        if (v14)
        {
          uint64_t v15 = v14;
          if (!CFDictionaryGetValue(a2, LanguageFromLocaleID)) {
            CFDictionaryAddValue(a2, LanguageFromLocaleID, v15);
          }
        }

        CFRelease(v13);
      }

      CFRelease(LanguageFromLocaleID);
    }

    free(v7);
  }

id RDLanguageAssets::InstallAndCopyQuasarModelPathForLanguage(const __CFString *this, const __CFString *a2)
{
  CFMutableStringRef LocaleIDFromLanguage = RDLanguageAssets::createLocaleIDFromLanguage(this, a2);
  uint64_t v4 = RXGetAssetFallbackLocaleIdentifier();
  CFRelease(LocaleIDFromLanguage);
  uint64_t v10 = 0LL;
  if (qword_1000DDD08 != -1) {
    dispatch_once(&qword_1000DDD08, &stru_1000CEB58);
  }
  if (v4) {
    id v5 = (const __CFString *)v4;
  }
  else {
    id v5 = this;
  }
  id v6 = [(id)qword_1000DDD00 copyInstalledQuasarModelPathForLanguage:v5 error:&v10];
  size_t v7 = (os_log_s *)RXOSLog();
  if (os_log_type_enabled(v7, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)std::string buf = 138412546;
    int v12 = this;
    __int16 v13 = 2112;
    id v14 = v6;
    _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_INFO,  "InstallAndCopyQuasarModelPathForLanguage language=%@ resultPath=%@",  buf,  0x16u);
  }

  if (v10)
  {
    uint64_t v8 = (os_log_s *)RXOSLog();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)std::string buf = 138412290;
      int v12 = v10;
      _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_ERROR,  "InstallAndCopyQuasarModelPathForLanguage failed with: %@",  buf,  0xCu);
    }
  }

  return v6;
}

id RDLanguageAssets::CopyInstalledAssetPathForLanguage(const __CFString *this, const __CFString *a2)
{
  CFMutableStringRef LocaleIDFromLanguage = RDLanguageAssets::createLocaleIDFromLanguage(this, a2);
  id v3 = (const __CFString *)RXGetAssetFallbackLocaleIdentifier();
  if (!v3) {
    id v3 = LocaleIDFromLanguage;
  }
  CFMutableStringRef LanguageFromLocaleID = RDLanguageAssets::createLanguageFromLocaleID(v3, v4);
  uint64_t v9 = 0LL;
  if (qword_1000DDD08 != -1) {
    dispatch_once(&qword_1000DDD08, &stru_1000CEB58);
  }
  id v6 = [(id)qword_1000DDD00 copyInstalledAssetPathForLangaugeWithError:LanguageFromLocaleID error:&v9];
  if (v9)
  {
    size_t v7 = (os_log_s *)RXOSLog();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)std::string buf = 138412290;
      uint64_t v11 = v9;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, "CopyAssetPath failed with: %@", buf, 0xCu);
    }
  }

  return v6;
}

id RDLanguageAssets::CopyInstalledAssetSupportedTasksForLanguage( const __CFString *this, const __CFString *a2)
{
  CFMutableStringRef LocaleIDFromLanguage = RDLanguageAssets::createLocaleIDFromLanguage(this, a2);
  id v3 = (const __CFString *)RXGetAssetFallbackLocaleIdentifier();
  if (!v3) {
    id v3 = LocaleIDFromLanguage;
  }
  CFMutableStringRef LanguageFromLocaleID = RDLanguageAssets::createLanguageFromLocaleID(v3, v4);
  uint64_t v10 = 0LL;
  if (qword_1000DDD08 != -1) {
    dispatch_once(&qword_1000DDD08, &stru_1000CEB58);
  }
  id v6 = [(id)qword_1000DDD00 copyInstalledAssetSupportedTasksForLangaugeWithError:LanguageFromLocaleID error:&v10];
  if (v10)
  {
    size_t v7 = (os_log_s *)RXOSLog();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)std::string buf = 138412290;
      id v12 = v10;
      _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_ERROR,  "CopyAssetSupportedTasks failed with: %@",  buf,  0xCu);
    }
  }

  uint64_t v8 = (os_log_s *)RXOSLog();
  if (os_log_type_enabled(v8, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)std::string buf = 138412290;
    id v12 = v6;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_INFO, "RDLanguageAssets: supportedTasks:%@", buf, 0xCu);
  }

  return v6;
}

void RDLanguageAssets::CancelDownloadForLanguage(RDLanguageAssets *this, const __CFString *a2)
{
  id v3 = (os_log_s *)RXOSLog();
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)std::string buf = 138412290;
    size_t v7 = this;
    _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_DEFAULT,  "CancelDownloadForLanguage language=%@",  buf,  0xCu);
  }

  id v5 = 0LL;
  if (qword_1000DDD08 != -1) {
    dispatch_once(&qword_1000DDD08, &stru_1000CEB58);
  }
  [(id)qword_1000DDD00 cancelDownloadForLanguage:this error:&v5];
  if (v5)
  {
    uint64_t v4 = (os_log_s *)RXOSLog();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)std::string buf = 138412290;
      size_t v7 = v5;
      _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_ERROR,  "CancelDownloadForLanguage failed with: %@",  buf,  0xCu);
    }
  }

id RDLanguageAssets::PurgeInstalledQuasarAssets(RDLanguageAssets *this)
{
  id v5 = 0LL;
  if (qword_1000DDD08 != -1) {
    dispatch_once(&qword_1000DDD08, &stru_1000CEB58);
  }
  id v1 = [(id)qword_1000DDD00 purgeInstalledAssetsWithError:&v5];
  unint64_t v2 = (os_log_s *)RXOSLog();
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)std::string buf = 138412290;
    id v7 = v1;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Assets purged %@", buf, 0xCu);
  }

  if (v5)
  {
    id v3 = (os_log_s *)RXOSLog();
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)std::string buf = 138412290;
      id v7 = v5;
      _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_ERROR,  "PurgeInstalledQuasarAssets failed with: %@",  buf,  0xCu);
    }
  }

  return [v1 intValue];
}

void RDLanguageAssets::SetPurgeabilityForLanguages(RDLanguageAssets *this, const __CFArray *a2)
{
  uint64_t v4 = (os_log_s *)RXOSLog();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)std::string buf = 138412546;
    uint64_t v8 = this;
    __int16 v9 = 1024;
    int v10 = (int)a2;
    _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_INFO,  "SetPurgeabilityForLanguages languages=%@%d",  buf,  0x12u);
  }

  id v6 = 0LL;
  if (qword_1000DDD08 != -1) {
    dispatch_once(&qword_1000DDD08, &stru_1000CEB58);
  }
  [(id)qword_1000DDD00 setPurgeabilityForLanguages:this withPurgeability:a2 error:&v6];
  if (v6)
  {
    id v5 = (os_log_s *)RXOSLog();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)std::string buf = 138412290;
      uint64_t v8 = v6;
      _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_ERROR,  "SetPurgeabilityForLanguages failed with: %@",  buf,  0xCu);
    }
  }

id RDLanguageAssets::RemovePeerForProgressCallback(_xpc_connection_s *a1)
{
  unint64_t v2 = (os_log_s *)RXOSLog();
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    v4[0] = 67109120;
    v4[1] = xpc_connection_get_pid(a1);
    _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEFAULT,  "Removing Peer %d for callback",  (uint8_t *)v4,  8u);
  }

  if (qword_1000DDD08 != -1) {
    dispatch_once(&qword_1000DDD08, &stru_1000CEB58);
  }
  return [(id)qword_1000DDD00 removePeerFromCallback:a1];
}

id RDLanguageAssets::AddPeerForProgressCallback(_xpc_connection_s *a1)
{
  unint64_t v2 = (os_log_s *)RXOSLog();
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    v4[0] = 67109120;
    v4[1] = xpc_connection_get_pid(a1);
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Adding Peer %d for callback", (uint8_t *)v4, 8u);
  }

  if (qword_1000DDD08 != -1) {
    dispatch_once(&qword_1000DDD08, &stru_1000CEB58);
  }
  return [(id)qword_1000DDD00 addPeerForCallback:a1];
}

void sub_1000264E8(id a1)
{
  int v1 = _os_feature_enabled_impl("VoiceControl", "new_asset_manager");
  unint64_t v2 = (os_log_s *)RXOSLog();
  BOOL v3 = os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT);
  if (v1)
  {
    if (v3)
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Using RDAssetManager2", buf, 2u);
    }

    uint64_t v4 = &off_1000CCC98;
  }

  else
  {
    if (v3)
    {
      *(_WORD *)id v5 = 0;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Using original RDAssetManager", v5, 2u);
    }

    uint64_t v4 = off_1000CCC90;
  }

  qword_1000DDD00 = -[__objc2_class sharedInstance](*v4, "sharedInstance");
}

void RDQSRGrammarFst::Build(uint64_t a1, uint64_t a2, xpc_object_t xdict, uint64_t a4)
{
  uint64_t int64 = xpc_dictionary_get_uint64(xdict, kRDKeyObjectID);
  id v7 = operator new(0x28uLL);
  sub_10005D1F4(v7, 1LL);
  sub_10005D498((uint64_t)v7, 0);
  *(_DWORD *)(a1 + 8sub_10001AFB0((std::locale *)v24, " +$", 0) = 2;
  *(void *)std::string buf = &uint64;
  sub_100029360((uint64_t **)(a1 + 56), &uint64, (uint64_t)&unk_1000ABEA0, (uint64_t **)buf)[5] = (uint64_t)&_mh_execute_header;
  *(void *)(a1 + 4_Block_object_dispose(va, 8) = a4;
  else {
    v8.__d_.__rep_ = 0LL;
  }
  RDQSRGrammarFst::Build(a1, uint64, (uint64_t)v7);
  if (RXLogPerformance())
  {
    double v9 = rd_time_util::durationInMilliSec(v8.__d_.__rep_);
    int v10 = (os_log_s *)RXOSLog();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)std::string buf = 134217984;
      *(double *)&uint8_t buf[4] = v9;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "Building base grammar FST - %f", buf, 0xCu);
    }
  }

  if (!*(void *)(a1 + 104))
  {
    uint64_t v11 = (os_log_s *)RXOSLog();
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "Empty symbol set", buf, 2u);
    }
  }

  sub_10005D554((uint64_t)v7, 1, 0.0);
  sub_10005D628((uint64_t)v7);
  uint64_t v12 = v7[1];
  v7[1] = 0LL;
  uint64_t v13 = *(void *)a1;
  *(void *)a1 = v12;
  if (v13) {
    (*(void (**)(uint64_t))(*(void *)v13 + 8LL))(v13);
  }
  if (*(_BYTE *)(a1 + 33) && *(void *)(a1 + 104))
  {
    sub_100058C94((void *)(a1 + 88), (void *)(a1 + 112), (void *)(a1 + 136), &v41);
    if (RXLogPerformance())
    {
      double v14 = rd_time_util::durationInMilliSec(v8.__d_.__rep_);
      uint64_t v15 = (os_log_s *)RXOSLog();
      if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)std::string buf = 134217984;
        *(double *)&uint8_t buf[4] = v14;
        _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "Building edit FST - %f", buf, 0xCu);
      }
    }

    sub_10005E72C(v41, *(void *)a1, 1, &v40);
    if (RXLogPerformance())
    {
      double v16 = rd_time_util::durationInMilliSec(v8.__d_.__rep_);
      uint64_t v17 = (os_log_s *)RXOSLog();
      if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)std::string buf = 134217984;
        *(double *)&uint8_t buf[4] = v16;
        _os_log_impl( (void *)&_mh_execute_header,  v17,  OS_LOG_TYPE_DEFAULT,  "Composing Edit with grammar FST - %f",  buf,  0xCu);
      }
    }

    sub_100059084(a2, (void *)(a1 + 88), (void *)(a1 + 112), (void *)(a1 + 136), &v39);
    if (RXLogPerformance())
    {
      double v18 = rd_time_util::durationInMilliSec(v8.__d_.__rep_);
      size_t v19 = (os_log_s *)RXOSLog();
      if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)std::string buf = 134217984;
        *(double *)&uint8_t buf[4] = v18;
        _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "Synonym FST - %f", buf, 0xCu);
      }
    }

    sub_10005E72C(v39, v40, 1, &v38);
    if (RXLogPerformance())
    {
      double v20 = rd_time_util::durationInMilliSec(v8.__d_.__rep_);
      uint64_t v21 = (os_log_s *)RXOSLog();
      if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)std::string buf = 134217984;
        *(double *)&uint8_t buf[4] = v20;
        _os_log_impl( (void *)&_mh_execute_header,  v21,  OS_LOG_TYPE_DEFAULT,  "Composing Synonym with edit_right - %f",  buf,  0xCu);
      }
    }

    if (*(void *)(a1 + 160) == *(void *)(a1 + 168))
    {
      uint64_t v37 = v38;
      uint64_t v38 = 0LL;
      uint64_t v24 = *(void *)a1;
      *(void *)a1 = v37;
      if (!v24)
      {
LABEL_40:
        if (RXLogPerformance())
        {
          double v25 = rd_time_util::durationInMilliSec(v8.__d_.__rep_);
          uint64_t v26 = (os_log_s *)RXOSLog();
          if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)std::string buf = 134217984;
            *(double *)&uint8_t buf[4] = v25;
            _os_log_impl( (void *)&_mh_execute_header,  v26,  OS_LOG_TYPE_DEFAULT,  "Replacing with label FSTs - %f",  buf,  0xCu);
          }
        }

        uint64_t v27 = v38;
        uint64_t v38 = 0LL;
        if (v27) {
          (*(void (**)(uint64_t))(*(void *)v27 + 8LL))(v27);
        }
        uint64_t v28 = v39;
        uint64_t v39 = 0LL;
        if (v28) {
          (*(void (**)(uint64_t))(*(void *)v28 + 8LL))(v28);
        }
        uint64_t v29 = v40;
        uint64_t v40 = 0LL;
        if (v29) {
          (*(void (**)(uint64_t))(*(void *)v29 + 8LL))(v29);
        }
        uint64_t v30 = v41;
        uint64_t v41 = 0LL;
        if (v30) {
          (*(void (**)(uint64_t))(*(void *)v30 + 8LL))(v30);
        }
        goto LABEL_61;
      }
    }

    else
    {
      sub_10005EED4(v38, (uint64_t *)(a1 + 160), buf);
      uint64_t v22 = *(void *)buf;
      *(void *)std::string buf = 0LL;
      uint64_t v23 = *(void *)a1;
      *(void *)a1 = v22;
      if (!v23) {
        goto LABEL_40;
      }
      (*(void (**)(uint64_t))(*(void *)v23 + 8LL))(v23);
      uint64_t v24 = *(void *)buf;
      *(void *)std::string buf = 0LL;
      if (!v24) {
        goto LABEL_40;
      }
    }

    (*(void (**)(uint64_t))(*(void *)v24 + 8LL))(v24);
    goto LABEL_40;
  }

  if (*(void *)(a1 + 160) == *(void *)(a1 + 168))
  {
    sub_10005F3EC(*(void **)a1);
  }

  else
  {
    sub_10005EED4(*(void *)a1, (uint64_t *)(a1 + 160), buf);
    uint64_t v31 = *(void *)buf;
    *(void *)std::string buf = 0LL;
    uint64_t v32 = *(void *)a1;
    *(void *)a1 = v31;
    if (v32)
    {
      (*(void (**)(uint64_t))(*(void *)v32 + 8LL))(v32);
      uint64_t v33 = *(void *)buf;
      *(void *)std::string buf = 0LL;
      if (v33) {
        (*(void (**)(uint64_t))(*(void *)v33 + 8LL))(v33);
      }
    }
  }

  if (RXLogPerformance())
  {
    double v34 = rd_time_util::durationInMilliSec(v8.__d_.__rep_);
    uint64_t v35 = (os_log_s *)RXOSLog();
    if (os_log_type_enabled(v35, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)std::string buf = 134217984;
      *(double *)&uint8_t buf[4] = v34;
      _os_log_impl((void *)&_mh_execute_header, v35, OS_LOG_TYPE_DEFAULT, "Replacing with label FSTs - %f", buf, 0xCu);
    }
  }

LABEL_61:
  uint64_t v36 = sub_1000292E0(v7);
  operator delete(v36);
}

      uint64_t v50 = *(void *)(a4 + 8) - 48LL;
      sub_10001A1D0(a4 + 16, v50);
      *(void *)(a4 + _Block_object_dispose(va, 8) = v50;
      uint64_t v51 = v64;
LABEL_62:
      if (v51 < 0) {
        operator delete(v63[0]);
      }
      if (v66 < 0) {
        operator delete(*(void **)buf);
      }
      goto LABEL_66;
    }

  *(void *)&unint64_t v46 = a1 + 160;
  *((void *)&v46 + 1) = a1 + 184;
  *(void *)&uint64_t v47 = 0LL;
  *((void *)&v47 + 1) = a1 + 208;
  *(_OWORD *)uint64_t v51 = 0u;
  *(_OWORD *)std::string __p = 0u;
  sub_10005B86C(v4, (uint64_t *)&v46, 0);
  uint64_t v42 = (void **)__p[1];
  __p[1] = 0LL;
  if (v42) {
    sub_10002B7A4((int)&__p[1], v42);
  }
  sub_10002B764((void ***)__p, 0LL);
  char v43 = (void **)v51[1];
  v51[1] = 0LL;
  if (v43) {
    sub_10002B7A4((int)&v51[1], v43);
  }
  int v44 = (void **)v51[0];
  v51[0] = 0LL;
  if (v44) {
    sub_10002B7A4((int)v51, v44);
  }
}

void sub_100026BCC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13)
{
  if (a10) {
    (*(void (**)(uint64_t))(*(void *)a10 + 8LL))(a10);
  }
  if (a11) {
    (*(void (**)(uint64_t))(*(void *)a11 + 8LL))(a11);
  }
  if (a12) {
    (*(void (**)(uint64_t))(*(void *)a12 + 8LL))(a12);
  }
  if (a13) {
    (*(void (**)(uint64_t))(*(void *)a13 + 8LL))(a13);
  }
  uint64_t v15 = sub_1000292E0(v13);
  operator delete(v15);
  _Unwind_Resume(a1);
}

void RDQSRGrammarFst::Build(uint64_t a1, unint64_t a2, uint64_t a3)
{
  unint64_t __val = a2;
  uint64_t v4 = *(uint64_t ***)(a1 + 48);
  *(void *)std::string buf = &__val;
  id v5 = (void *)sub_100019C58(v4, &__val, (uint64_t)&unk_1000ABEA0, (uint64_t **)buf)[5];
  if (!v5)
  {
    uint64_t v13 = (os_log_s *)RXOSLog();
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)std::string buf = 134217984;
      *(void *)&uint8_t buf[4] = __val;
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, "NULL LM Object for id %llu", buf, 0xCu);
    }

    return;
  }

  xpc_object_t xdict = v5;
  int64_t int64 = xpc_dictionary_get_int64(v5, kRDKeyObjectType);
  *(void *)std::string buf = &__val;
  id v7 = sub_100029360((uint64_t **)(a1 + 56), &__val, (uint64_t)&unk_1000ABEA0, (uint64_t **)buf);
  uint64_t v52 = *((unsigned int *)v7 + 10);
  uint64_t v51 = *((unsigned int *)v7 + 11);
  if ((unint64_t)(int64 - 10) >= 2)
  {
    if (int64 == 13)
    {
      int v17 = *(_DWORD *)(a1 + 184);
      *(_DWORD *)(a1 + 184) = v17 + 1;
      std::to_string(&__p, v17);
      double v18 = std::string::insert(&__p, 0LL, "$$ADLIB");
      __int128 v19 = *(_OWORD *)&v18->__r_.__value_.__l.__data_;
      int64_t cap = v18->__r_.__value_.__l.__cap_;
      *(_OWORD *)std::string buf = v19;
      v18->__r_.__value_.__l.__size_ = 0LL;
      v18->__r_.__value_.__l.__cap_ = 0LL;
      v18->__r_.__value_.__r.__words[0] = 0LL;
      RDQSRGrammarFst::addAdlibFstWithLabel(a1, (const void **)buf, __val);
      sub_10005D67C(a3, v52, v51, (uint64_t)buf, (uint64_t)buf, 0.0);
      if (RXLogServerGrammar())
      {
        if (RXVeryVerbose())
        {
          double v20 = (os_log_s *)RXOSLog();
          if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
          {
            LOWORD(__p.__r_.__value_.__l.__data_) = 0;
            _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "Grammar: Adlib", (uint8_t *)&__p, 2u);
          }
        }
      }

      *(_BYTE *)(a1 + 32) = 1;
      if (SHIBYTE(cap) < 0) {
        goto LABEL_32;
      }
    }

    else if (int64 == 12)
    {
      string = (char *)xpc_dictionary_get_string(xdict, kRDKeyText);
      sub_10000A2DC(buf, string);
      uint64_t v9 = HIBYTE(cap);
      char v10 = HIBYTE(cap);
      if (cap < 0) {
        uint64_t v9 = *(void *)&buf[8];
      }
      if (v9)
      {
        sub_100097CB8(*(CFLocaleRef **)(a1 + 40), (const char *)buf, &__p);
        std::to_string(&v56, __val);
        sub_10005D67C(a3, v52, v51, (uint64_t)&__p, (uint64_t)&v56, 0.0);
        sub_10009B5D8((uint64_t **)(a1 + 88), (const void **)&__p.__r_.__value_.__l.__data_, (uint64_t)&__p);
        if (RXLogServerGrammar())
        {
          if (RXVeryVerbose())
          {
            uint64_t v11 = (os_log_s *)RXOSLog();
            if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
            {
              p_p = &__p;
              if ((__p.__r_.__value_.__s.__size_ & 0x80u) != 0) {
                p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
              }
              LODWORD(v56.__r_.__value_.__l.__data_) = 136315138;
              *(std::string::size_type *)((char *)v56.__r_.__value_.__r.__words + 4) = (std::string::size_type)p_p;
              _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_DEFAULT,  "Grammar: Word -> %s",  (uint8_t *)&v56,  0xCu);
            }
          }
        }

        char v10 = HIBYTE(cap);
      }

      if (v10 < 0) {
LABEL_32:
      }
        operator delete(*(void **)buf);
    }

LABEL_89:
    if ((xpc_dictionary_get_uint64(xdict, kRDKeyOptions) & 4) != 0)
    {
      if (*(_BYTE *)(a1 + 188))
      {
        RDQSRGrammarFst::addOptionalFst((RDQSRGrammarFst *)a1);
        *(_BYTE *)(a1 + 18_Block_object_dispose(va, 8) = 0;
      }

      sub_10000A2DC(buf, off_1000DD350);
      sub_10000A2DC(&__p, off_1000DD350);
      sub_10005D67C(a3, v52, v51, (uint64_t)buf, (uint64_t)&__p, 0.0);
      goto LABEL_99;
    }

    return;
  }

  xpc_object_t value = xpc_dictionary_get_value(xdict, kRDKeyChildren);
  uint64_t v15 = value;
  if (value) {
    unsigned __int16 count = xpc_array_get_count(value);
  }
  else {
    unsigned __int16 count = 0;
  }
  if (!xpc_dictionary_get_string(xdict, kRDKeyCategoryID)) {
    goto LABEL_57;
  }
  v56.__r_.__value_.__r.__words[0] = (std::string::size_type)xpc_dictionary_get_string(xdict, kRDKeyCategoryID);
  uint64_t v21 = sub_10000A2DC(buf, v56.__r_.__value_.__l.__data_);
  BOOL doesSupportCategory = rd_userprofile_util::doesSupportCategory(v21);
  BOOL v23 = doesSupportCategory;
  if (SHIBYTE(cap) < 0)
  {
    operator delete(*(void **)buf);
    if (v23) {
      goto LABEL_37;
    }
    goto LABEL_57;
  }

  if (!doesSupportCategory)
  {
LABEL_57:
    if (RXLogServerGrammar()
      && RXVeryVerbose()
      && xpc_dictionary_get_string(xdict, kRDKeyCommandID))
    {
      uint64_t v36 = (char *)xpc_dictionary_get_string(xdict, kRDKeyCommandID);
      sub_10000A2DC(buf, v36);
      uint64_t v37 = (os_log_s *)RXOSLog();
      if (os_log_type_enabled(v37, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v38 = buf;
        if (cap < 0) {
          uint64_t v38 = *(uint8_t **)buf;
        }
        LODWORD(__p.__r_.__value_.__l.__data_) = 136315138;
        *(std::string::size_type *)((char *)__p.__r_.__value_.__r.__words + 4) = (std::string::size_type)v38;
        _os_log_impl( (void *)&_mh_execute_header,  v37,  OS_LOG_TYPE_DEFAULT,  "Grammar: CommandID -> %s",  (uint8_t *)&__p,  0xCu);
      }

      if (SHIBYTE(cap) < 0) {
        operator delete(*(void **)buf);
      }
    }

    int v50 = count;
    if (!count)
    {
      if (*(_BYTE *)(a1 + 189))
      {
        RDQSRGrammarFst::addBogusFst((RDQSRGrammarFst *)a1);
        *(_BYTE *)(a1 + 189) = 0;
      }

      sub_10000A2DC(buf, off_1000DD348[0]);
      sub_10000A2DC(&__p, off_1000DD348[0]);
      sub_10005D67C(a3, v52, v51, (uint64_t)buf, (uint64_t)&__p, 0.0);
      if (SHIBYTE(cap) < 0) {
        operator delete(*(void **)buf);
      }
    }

    uint64_t v39 = count;
    if (!count) {
      goto LABEL_89;
    }
    size_t v40 = 0LL;
    while (1)
    {
      __p.__r_.__value_.__r.__words[0] = xpc_array_get_uint64(v15, v40);
      uint64_t v41 = *(uint64_t ***)(a1 + 48);
      *(void *)std::string buf = &__p;
LABEL_88:
      if (v39 == ++v40) {
        goto LABEL_89;
      }
    }

    if (int64 == 11)
    {
      if (v40)
      {
        if (v39 - 1 == v40)
        {
          v56.__r_.__value_.__r.__words[0] = xpc_array_get_uint64(v15, v50 - 1 - 1LL);
          *(void *)std::string buf = &v56;
          uint64_t v44 = *((unsigned int *)sub_100029360( (uint64_t **)(a1 + 56),  (unint64_t *)&v56,  (uint64_t)&unk_1000ABEA0,  (uint64_t **)buf)
                + 11);
          *(void *)std::string buf = &__p;
          uint64_t v42 = sub_100029360((uint64_t **)(a1 + 56), (unint64_t *)&__p, (uint64_t)&unk_1000ABEA0, (uint64_t **)buf);
          unint64_t v43 = (v51 << 32) | v44;
        }

        else
        {
          v56.__r_.__value_.__r.__words[0] = xpc_array_get_uint64(v15, v40 - 1);
          *(void *)std::string buf = &v56;
          uint64_t v45 = *((unsigned int *)sub_100029360( (uint64_t **)(a1 + 56),  (unint64_t *)&v56,  (uint64_t)&unk_1000ABEA0,  (uint64_t **)buf)
                + 11);
          uint64_t v46 = *(unsigned int *)(a1 + 80);
          *(_DWORD *)(a1 + 8sub_10001AFB0((std::locale *)v24, " +$", 0) = v46 + 1;
          *(void *)std::string buf = &__p;
          uint64_t v42 = sub_100029360((uint64_t **)(a1 + 56), (unint64_t *)&__p, (uint64_t)&unk_1000ABEA0, (uint64_t **)buf);
          unint64_t v43 = v45 | (v46 << 32);
        }

        goto LABEL_86;
      }

      if (v50 != 1)
      {
        uint64_t v47 = *(unsigned int *)(a1 + 80);
        *(_DWORD *)(a1 + 8sub_10001AFB0((std::locale *)v24, " +$", 0) = v47 + 1;
        *(void *)std::string buf = &__p;
        uint64_t v42 = sub_100029360((uint64_t **)(a1 + 56), (unint64_t *)&__p, (uint64_t)&unk_1000ABEA0, (uint64_t **)buf);
        unint64_t v43 = v52 | (v47 << 32);
        goto LABEL_86;
      }
    }

    else if (int64 != 10)
    {
LABEL_87:
      RDQSRGrammarFst::Build(a1, __p.__r_.__value_.__r.__words[0], a3);
      goto LABEL_88;
    }

    *(void *)std::string buf = &__p;
    uint64_t v42 = sub_100029360((uint64_t **)(a1 + 56), (unint64_t *)&__p, (uint64_t)&unk_1000ABEA0, (uint64_t **)buf);
    unint64_t v43 = v52 | ((unint64_t)v51 << 32);
LABEL_86:
    v42[5] = v43;
    goto LABEL_87;
  }

LABEL_47:
    v25 += 4;
    if (v25 == v24) {
      goto LABEL_48;
    }
  }

  if (v27 == -1LL) {
LABEL_108:
  }
    sub_10001801C();
  uint64_t v28 = *v25;
LABEL_46:
  if (memcmp(v28, v26, v27)) {
    goto LABEL_47;
  }
  if (RXLogServerGrammar())
  {
    if (RXVeryVerbose())
    {
      uint64_t v49 = (os_log_s *)RXOSLog();
      if (os_log_type_enabled(v49, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)std::string buf = 136315138;
        *(void *)&uint8_t buf[4] = v56.__r_.__value_.__r.__words[0];
        _os_log_impl((void *)&_mh_execute_header, v49, OS_LOG_TYPE_DEFAULT, "Grammar: CategoryID -> %s", buf, 0xCu);
      }
    }
  }

void sub_1000276A4( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, void *a21, uint64_t a22, int a23, __int16 a24, char a25, char a26, uint64_t a27, void *__p, uint64_t a29, int a30, __int16 a31, char a32, char a33)
{
  if (a33 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void RDQSRGrammarFst::addAdlibFstWithLabel(uint64_t a1, const void **a2, unint64_t a3)
{
  id v6 = operator new(0x28uLL);
  sub_10005D1F4(v6, 1LL);
  sub_10005D498((uint64_t)v6, 0);
  sub_10000A2DC(v14, "<sigma>");
  std::to_string(&__p, a3);
  sub_10005D67C((uint64_t)v6, 0, 1, (uint64_t)v14, (uint64_t)&__p, 110.0);
  if (v15 < 0) {
    operator delete(v14[0]);
  }
  sub_10000A2DC(v14, "<sigma>");
  std::to_string(&__p, a3);
  sub_10005D67C((uint64_t)v6, 1, 1, (uint64_t)v14, (uint64_t)&__p, 110.0);
  if (v15 < 0) {
    operator delete(v14[0]);
  }
  sub_10005D554((uint64_t)v6, 1, 0.0);
  sub_10005D628((uint64_t)v6);
  sub_10009B5D8((uint64_t **)(a1 + 136), a2, (uint64_t)a2);
  id v7 = (uint64_t *)(a1 + 160);
  std::chrono::steady_clock::time_point v8 = (void *)v6[1];
  v6[1] = 0LL;
  v14[0] = v8;
  unint64_t v9 = *(void *)(a1 + 168);
  if (v9 >= *(void *)(a1 + 176))
  {
    uint64_t v10 = sub_1000298F8(v7, (__int128 *)a2, (uint64_t *)v14);
  }

  else
  {
    sub_100029884(v7, (__int128 *)a2, (uint64_t *)v14);
    uint64_t v10 = v9 + 32;
  }

  *(void *)(a1 + 16_Block_object_dispose(va, 8) = v10;
  uint64_t v11 = v14[0];
  v14[0] = 0LL;
  if (v11) {
    (*(void (**)(void *))(*(void *)v11 + 8LL))(v11);
  }
  uint64_t v12 = sub_1000292E0(v6);
  operator delete(v12);
}

void sub_10002793C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a15) {
    (*(void (**)(void *))(*(void *)a15 + 8LL))(a15);
  }
  uint64_t v22 = sub_1000292E0(v20);
  operator delete(v22);
  _Unwind_Resume(a1);
}

void RDQSRCategoryFst::Build(uint64_t a1, xpc_object_t xdict, uint64_t a3)
{
  uint64_t int64 = xpc_dictionary_get_uint64(xdict, kRDKeyObjectID);
  id v5 = operator new(0x28uLL);
  sub_10005D1F4(v5, 1LL);
  sub_10005D498((uint64_t)v5, 0);
  *(_DWORD *)(a1 + 4_Block_object_dispose(va, 8) = 2;
  *(void *)std::string buf = &uint64;
  sub_100029360((uint64_t **)(a1 + 24), &uint64, (uint64_t)&unk_1000ABEA0, (uint64_t **)buf)[5] = (uint64_t)&_mh_execute_header;
  *(void *)(a1 + 16) = a3;
  else {
    v6.__d_.__rep_ = 0LL;
  }
  RDQSRCategoryFst::Build(a1, uint64, (uint64_t)v5);
  if (RXLogPerformance())
  {
    double v7 = rd_time_util::durationInMilliSec(v6.__d_.__rep_);
    std::chrono::steady_clock::time_point v8 = (os_log_s *)RXOSLog();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)std::string buf = 134217984;
      *(double *)&uint8_t buf[4] = v7;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "Building category FST - %f", buf, 0xCu);
    }
  }

  sub_10005D554((uint64_t)v5, 1, 0.0);
  sub_10005D628((uint64_t)v5);
  uint64_t v9 = v5[1];
  v5[1] = 0LL;
  uint64_t v10 = *(void *)a1;
  *(void *)a1 = v9;
  if (v10) {
    (*(void (**)(uint64_t))(*(void *)v10 + 8LL))(v10);
  }
  uint64_t v11 = sub_1000292E0(v5);
  operator delete(v11);
}

void sub_100027B60(_Unwind_Exception *a1)
{
  BOOL v3 = sub_1000292E0(v1);
  operator delete(v3);
  _Unwind_Resume(a1);
}

void RDQSRGrammarFst::addBogusFst(RDQSRGrammarFst *this)
{
  unint64_t v2 = operator new(0x28uLL);
  sub_10005D1F4(v2, 1LL);
  sub_10005D498((uint64_t)v2, 0);
  sub_10000A2DC(v10, "<eps>");
  sub_10000A2DC(__p, "<eps>");
  sub_10005D67C((uint64_t)v2, 0, 1, (uint64_t)v10, (uint64_t)__p, 0.0);
  if (v9 < 0) {
    operator delete(__p[0]);
  }
  if (v11 < 0) {
    operator delete(v10[0]);
  }
  sub_10005D554((uint64_t)v2, 1, 0.0);
  sub_10005D628((uint64_t)v2);
  sub_10000A2DC(v10, off_1000DD348[0]);
  sub_1000297F4((uint64_t **)this + 14, (const void **)v10, (uint64_t)v10);
  if (v11 < 0) {
    operator delete(v10[0]);
  }
  BOOL v3 = (void *)v2[1];
  v2[1] = 0LL;
  v10[0] = v3;
  unint64_t v4 = *((void *)this + 21);
  if (v4 >= *((void *)this + 22))
  {
    uint64_t v5 = sub_100029468((uint64_t *)this + 20, off_1000DD348, (uint64_t *)v10);
    std::chrono::steady_clock::time_point v6 = v10[0];
    *((void *)this + 21) = v5;
    v10[0] = 0LL;
    if (v6) {
      (*(void (**)(void *))(*(void *)v6 + 8LL))(v6);
    }
  }

  else
  {
    sub_10000A2DC(*((void **)this + 21), off_1000DD348[0]);
    *(void *)(v4 + 24) = v3;
    *((void *)this + 21) = v4 + 32;
  }

  double v7 = sub_1000292E0(v2);
  operator delete(v7);
}

void sub_100027D08( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (__p) {
    (*(void (**)(void *))(*(void *)__p + 8LL))(__p);
  }
  uint64_t v22 = sub_1000292E0(v20);
  operator delete(v22);
  _Unwind_Resume(a1);
}

void RDQSRGrammarFst::addOptionalFst(RDQSRGrammarFst *this)
{
  unint64_t v2 = operator new(0x28uLL);
  sub_10005D1F4(v2, 1LL);
  sub_10005D498((uint64_t)v2, 0);
  sub_10000A2DC(v10, "<eps>");
  sub_10000A2DC(__p, "<eps>");
  sub_10005D67C((uint64_t)v2, 0, 1, (uint64_t)v10, (uint64_t)__p, 0.0);
  if (v9 < 0) {
    operator delete(__p[0]);
  }
  if (v11 < 0) {
    operator delete(v10[0]);
  }
  sub_10005D554((uint64_t)v2, 1, 0.0);
  sub_10005D628((uint64_t)v2);
  sub_10000A2DC(v10, off_1000DD350);
  sub_1000297F4((uint64_t **)this + 14, (const void **)v10, (uint64_t)v10);
  if (v11 < 0) {
    operator delete(v10[0]);
  }
  BOOL v3 = (void *)v2[1];
  v2[1] = 0LL;
  v10[0] = v3;
  unint64_t v4 = *((void *)this + 21);
  if (v4 >= *((void *)this + 22))
  {
    uint64_t v5 = sub_100029468((uint64_t *)this + 20, &off_1000DD350, (uint64_t *)v10);
    std::chrono::steady_clock::time_point v6 = v10[0];
    *((void *)this + 21) = v5;
    v10[0] = 0LL;
    if (v6) {
      (*(void (**)(void *))(*(void *)v6 + 8LL))(v6);
    }
  }

  else
  {
    sub_10000A2DC(*((void **)this + 21), off_1000DD350);
    *(void *)(v4 + 24) = v3;
    *((void *)this + 21) = v4 + 32;
  }

  double v7 = sub_1000292E0(v2);
  operator delete(v7);
}

void sub_100027F0C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (__p) {
    (*(void (**)(void *))(*(void *)__p + 8LL))(__p);
  }
  uint64_t v22 = sub_1000292E0(v20);
  operator delete(v22);
  _Unwind_Resume(a1);
}

void RDQSRCategoryFst::Build(uint64_t a1, unint64_t a2, uint64_t a3)
{
  unint64_t __val = a2;
  unint64_t v4 = *(uint64_t ***)(a1 + 16);
  *(void *)&__int128 buf = &__val;
  uint64_t v5 = (void *)sub_100019C58(v4, &__val, (uint64_t)&unk_1000ABEA0, (uint64_t **)&buf)[5];
  if (v5)
  {
    xpc_object_t xdict = v5;
    int64_t int64 = xpc_dictionary_get_int64(v5, kRDKeyObjectType);
    *(void *)&__int128 buf = &__val;
    double v7 = sub_100029360((uint64_t **)(a1 + 24), &__val, (uint64_t)&unk_1000ABEA0, (uint64_t **)&buf);
    *(void *)uint64_t v31 = *((unsigned int *)v7 + 10);
    uint64_t v30 = *((unsigned int *)v7 + 11);
    if ((unint64_t)(int64 - 10) >= 2)
    {
      if (int64 == 13)
      {
        double v18 = (os_log_s *)RXOSLog();
        if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
        {
          LOWORD(buf) = 0;
          _os_log_impl( (void *)&_mh_execute_header,  v18,  OS_LOG_TYPE_ERROR,  "Grammar: Adlibs can't be a part of category in LM",  (uint8_t *)&buf,  2u);
        }
      }

      else if (int64 == 12)
      {
        string = (char *)xpc_dictionary_get_string(xdict, kRDKeyText);
        sub_10000A2DC(&buf, string);
        uint64_t v9 = v39;
        unsigned __int8 v10 = v39;
        if ((v39 & 0x80u) != 0) {
          uint64_t v9 = *((void *)&buf + 1);
        }
        if (v9)
        {
          sub_100097CB8(*(CFLocaleRef **)(a1 + 8), (const char *)&buf, __p);
          unint64_t v11 = v35;
          if ((v35 & 0x80u) != 0) {
            unint64_t v11 = (unint64_t)__p[1];
          }
          if (v11)
          {
            std::to_string(&v37, __val);
            sub_10005D67C(a3, v31[0], v30, (uint64_t)__p, (uint64_t)&v37, 0.0);
          }

          if (RXLogServerGrammar())
          {
            if (RXVeryVerbose())
            {
              uint64_t v12 = (os_log_s *)RXOSLog();
              if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
              {
                uint64_t v13 = __p;
                if ((v35 & 0x80u) != 0) {
                  uint64_t v13 = (void **)__p[0];
                }
                LODWORD(v37.__r_.__value_.__l.__data_) = 136315138;
                *(std::string::size_type *)((char *)v37.__r_.__value_.__r.__words + 4) = (std::string::size_type)v13;
                _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_DEFAULT,  "Grammar: Word -> %s",  (uint8_t *)&v37,  0xCu);
              }
            }
          }

          unsigned __int8 v10 = v39;
        }

        if ((v10 & 0x80) != 0) {
          operator delete((void *)buf);
        }
      }

      goto LABEL_53;
    }

    xpc_object_t value = xpc_dictionary_get_value(xdict, kRDKeyChildren);
    double v16 = value;
    if (value)
    {
      unsigned __int16 count = xpc_array_get_count(value);
      int v29 = count;
      if (count)
      {
LABEL_37:
        uint64_t v19 = count;
        if (!count)
        {
LABEL_53:
          if ((xpc_dictionary_get_uint64(xdict, kRDKeyOptions) & 4) != 0)
          {
            sub_10000A2DC(&buf, "<eps>");
            sub_10000A2DC(__p, "<eps>");
            sub_10005D67C(a3, v31[0], v30, (uint64_t)&buf, (uint64_t)__p, 0.0);
          }

          return;
        }

        size_t v20 = 0LL;
        uint64_t v28 = v29 - 1;
        while (1)
        {
          __p[0] = (void *)xpc_array_get_uint64(v16, v20);
          uint64_t v21 = *(uint64_t ***)(a1 + 16);
          *(void *)&__int128 buf = __p;
LABEL_52:
          if (v19 == ++v20) {
            goto LABEL_53;
          }
        }

        if (int64 == 11)
        {
          if (v20)
          {
            if (v28 == v20)
            {
              v37.__r_.__value_.__r.__words[0] = xpc_array_get_uint64(v16, v28 - 1);
              *(void *)&__int128 buf = &v37;
              uint64_t v24 = *((unsigned int *)sub_100029360( (uint64_t **)(a1 + 24),  (unint64_t *)&v37,  (uint64_t)&unk_1000ABEA0,  (uint64_t **)&buf)
                    + 11);
              *(void *)&__int128 buf = __p;
              uint64_t v22 = sub_100029360( (uint64_t **)(a1 + 24),  (unint64_t *)__p,  (uint64_t)&unk_1000ABEA0,  (uint64_t **)&buf);
              unint64_t v23 = (v30 << 32) | v24;
            }

            else
            {
              v37.__r_.__value_.__r.__words[0] = xpc_array_get_uint64(v16, v20 - 1);
              *(void *)&__int128 buf = &v37;
              uint64_t v25 = *((unsigned int *)sub_100029360( (uint64_t **)(a1 + 24),  (unint64_t *)&v37,  (uint64_t)&unk_1000ABEA0,  (uint64_t **)&buf)
                    + 11);
              uint64_t v26 = *(unsigned int *)(a1 + 48);
              *(_DWORD *)(a1 + 4_Block_object_dispose(va, 8) = v26 + 1;
              *(void *)&__int128 buf = __p;
              uint64_t v22 = sub_100029360( (uint64_t **)(a1 + 24),  (unint64_t *)__p,  (uint64_t)&unk_1000ABEA0,  (uint64_t **)&buf);
              unint64_t v23 = v25 | (v26 << 32);
            }

            goto LABEL_50;
          }

          if (v29 != 1)
          {
            uint64_t v27 = *(unsigned int *)(a1 + 48);
            *(_DWORD *)(a1 + 4_Block_object_dispose(va, 8) = v27 + 1;
            *(void *)&__int128 buf = __p;
            uint64_t v22 = sub_100029360( (uint64_t **)(a1 + 24),  (unint64_t *)__p,  (uint64_t)&unk_1000ABEA0,  (uint64_t **)&buf);
            unint64_t v23 = *(void *)v31 | (v27 << 32);
            goto LABEL_50;
          }
        }

        else if (int64 != 10)
        {
LABEL_51:
          RDQSRCategoryFst::Build(a1, __p[0], a3);
          goto LABEL_52;
        }

        *(void *)&__int128 buf = __p;
        uint64_t v22 = sub_100029360((uint64_t **)(a1 + 24), (unint64_t *)__p, (uint64_t)&unk_1000ABEA0, (uint64_t **)&buf);
        unint64_t v23 = v31[0] | ((unint64_t)v30 << 32);
LABEL_50:
        void v22[5] = v23;
        goto LABEL_51;
      }
    }

    else
    {
      unsigned __int16 count = 0;
    }

    sub_10000A2DC(&buf, "<eps>");
    sub_10000A2DC(__p, "<eps>");
    sub_10005D67C(a3, v31[0], v30, (uint64_t)&buf, (uint64_t)__p, 0.0);
    int v29 = 0;
    goto LABEL_37;
  }

  double v14 = (os_log_s *)RXOSLog();
  if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
  {
    LODWORD(buf) = 134217984;
    *(void *)((char *)&buf + 4) = __val;
    _os_log_impl( (void *)&_mh_execute_header,  v14,  OS_LOG_TYPE_ERROR,  "NULL LM Object for id %llu",  (uint8_t *)&buf,  0xCu);
  }

void sub_100028574( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19, int a20, __int16 a21, char a22, char a23, uint64_t a24, uint64_t a25, void *a26, uint64_t a27, int a28, __int16 a29, char a30, char a31)
{
  if (a23 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void RDQSRGrammarBuilder::BuildGrammar(uint64_t a1, const __CFString *a2, void *a3, uint64_t a4)
{
  std::chrono::steady_clock::time_point v8 = (char *)operator new(0xC0uLL);
  char v9 = *(_BYTE *)a1;
  uint64_t v10 = *(void *)(a1 + 8);
  *(_OWORD *)std::chrono::steady_clock::time_point v8 = 0u;
  *((_OWORD *)v8 + 1) = 0u;
  v8[32] = 0;
  v8[33] = v9;
  *((void *)v8 + 5) = v10;
  *((void *)v8 + 9) = 0LL;
  *((void *)v8 + _Block_object_dispose(va, 8) = 0LL;
  *((void *)v8 + 7) = v8 + 64;
  *((void *)v8 + 12) = 0LL;
  *((void *)v8 + 11) = v8 + 96;
  *((void *)v8 + 15) = 0LL;
  *((void *)v8 + 1_Block_object_dispose(va, 8) = 0LL;
  *((void *)v8 + 13) = 0LL;
  *((void *)v8 + 14) = v8 + 120;
  *((void *)v8 + 16) = 0LL;
  *((void *)v8 + 17) = v8 + 144;
  *((void *)v8 + 19) = 0LL;
  *((void *)v8 + 2sub_10001AFB0((std::locale *)v24, " +$", 0) = 0LL;
  *((void *)v8 + 21) = 0LL;
  *((void *)v8 + 22) = 0LL;
  *((_DWORD *)v8 + 46) = 1;
  *((_WORD *)v8 + 94) = 257;
  double v18 = v8;
  CFIndex Length = CFStringGetLength(a2);
  CFStringGetMaximumSizeForEncoding(Length, 0x8000100u);
  uint64_t v12 = (char *)&v18 - ((__chkstk_darwin() + 16) & 0xFFFFFFFFFFFFFFF0LL);
  CFStringGetCString(a2, v12, v13, 0x8000100u);
  RDQSRGrammarFst::Build((uint64_t)v18, (uint64_t)v12, a3, a4);
  uint64_t v14 = *(void *)v18;
  *(void *)double v18 = 0LL;
  uint64_t v15 = *(void *)(a1 + 24);
  *(void *)(a1 + 24) = v14;
  if (v15) {
    (*(void (**)(uint64_t))(*(void *)v15 + 8LL))(v15);
  }
  uint64_t v16 = (uint64_t)v18;
  sub_100029B30((void **)(a1 + 32));
  *(_OWORD *)(a1 + 32) = *(_OWORD *)(v16 + 8);
  *(void *)(a1 + 4_Block_object_dispose(va, 8) = *(void *)(v16 + 24);
  *(void *)(v16 + _Block_object_dispose(va, 8) = 0LL;
  *(void *)(v16 + 16) = 0LL;
  *(void *)(v16 + 24) = 0LL;
  *(_BYTE *)(a1 + 57) = v18[32];
  *(_BYTE *)(a1 + 56) = 1;
  int v17 = v18;
  double v18 = 0LL;
  if (v17) {
    sub_100029A14((uint64_t)&v18, v17);
  }
}

void sub_1000287B4(_Unwind_Exception *exception_object)
{
  BOOL v3 = *(char **)(v1 - 64);
  *(void *)(v1 - 64) = 0LL;
  if (v3) {
    sub_100029A14(v1 - 64, v3);
  }
  _Unwind_Resume(exception_object);
}

void RDQSRGrammarBuilder::buildCategoryFst(void *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, void *a4@<X8>)
{
  std::chrono::steady_clock::time_point v8 = operator new(0x38uLL);
  void *v8 = 0LL;
  v8[1] = a3;
  v8[5] = 0LL;
  v8[4] = 0LL;
  void v8[3] = v8 + 4;
  unint64_t v11 = v8;
  RDQSRCategoryFst::Build((uint64_t)v8, a1, a2);
  char v9 = (void *)*v11;
  *unint64_t v11 = 0LL;
  *a4 = v9;
  uint64_t v10 = (void **)v11;
  unint64_t v11 = 0LL;
  if (v10) {
    sub_10002941C((uint64_t)&v11, v10);
  }
}

void sub_10002885C( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void **a10)
{
  unint64_t v11 = a10;
  a10 = 0LL;
  if (v11) {
    sub_10002941C((uint64_t)&a10, v11);
  }
  _Unwind_Resume(exception_object);
}

void RDQSRGrammarBuilder::UpdateCategory(uint64_t a1, const char *a2, uint64_t a3)
{
  std::chrono::steady_clock::time_point v6 = operator new(0x18uLL);
  double v7 = v6;
  uint64_t v8 = *(void *)(a3 + 16);
  v6[1] = *(void *)(a3 + 8);
  v6[2] = v8;
  if (v8)
  {
    char v9 = (unint64_t *)(v8 + 8);
    do
      unint64_t v10 = __ldxr(v9);
    while (__stxr(v10 + 1, v9));
  }

  void *v6 = off_1000D06D8;
  uint64_t v11 = *(void *)(a1 + 32);
  uint64_t v12 = *(void *)(a1 + 40);
  if (v11 == v12) {
    goto LABEL_20;
  }
  char v13 = 0;
  do
  {
    size_t v14 = strlen(a2);
    size_t v15 = v14;
    if (*(char *)(v11 + 23) < 0)
    {
      if (v14 != *(void *)(v11 + 8)) {
        goto LABEL_17;
      }
      if (v14 == -1LL) {
LABEL_25:
      }
        sub_10001801C();
      uint64_t v16 = *(const void **)v11;
    }

    else
    {
      uint64_t v16 = (const void *)v11;
      if (v15 == -1LL) {
        goto LABEL_25;
      }
    }

    if (!memcmp(v16, a2, v15))
    {
      uint64_t v17 = *(void *)(v11 + 24);
      *(void *)(v11 + 24) = v7;
      if (v17) {
        (*(void (**)(uint64_t))(*(void *)v17 + 8LL))(v17);
      }
      double v7 = 0LL;
      char v13 = 1;
    }

LABEL_20:
  double v18 = (os_log_s *)RXOSLog();
  if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)uint64_t v19 = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v18,  OS_LOG_TYPE_ERROR,  "Updating the category which is not a part of the original LM",  v19,  2u);
  }

  int64x2_t result = 0LL;
LABEL_22:
  if (a3)
  {
    sub_10000A2DC(__p, "WARNING");
    sub_10002A9EC(&v22, (uint64_t)__p);
    size_t v14 = sub_10002A6A4(&std::cerr, (uint64_t)"CompatSymbols: Symbol table checksums do not match. ", 52LL);
    size_t v15 = sub_10002A6A4(v14, (uint64_t)"Table sizes are ", 16LL);
    uint64_t v16 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 120LL))(a1);
    uint64_t v17 = (void *)std::ostream::operator<<(v15, v16);
    double v18 = sub_10002A6A4(v17, (uint64_t)" and ", 5LL);
    uint64_t v19 = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 120LL))(a2);
    std::ostream::operator<<(v18, v19);
    sub_10002AA94(&v22);
    if (v21 < 0) {
      operator delete(__p[0]);
    }
    return 0LL;
  }

  return result;
}

void sub_1000289F0(_Unwind_Exception *exception_object)
{
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8LL))(v1);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_100028A14(void *a1, char *__s)
{
  size_t v4 = strlen(__s);
  if (*((char *)a1 + 23) < 0)
  {
    if (v4 == a1[1])
    {
      if (v4 == -1LL) {
        goto LABEL_10;
      }
      a1 = (void *)*a1;
      return memcmp(a1, __s, v4) == 0;
    }
  }

  else if (v4 == *((unsigned __int8 *)a1 + 23))
  {
    if (v4 == -1LL) {
LABEL_10:
    }
      sub_10001801C();
    return memcmp(a1, __s, v4) == 0;
  }

  return 0LL;
}

uint64_t RDQSRGrammarBuilder::grammarFST(RDQSRGrammarBuilder *this)
{
  if (!*((_BYTE *)this + 56)) {
    return *((void *)this + 2);
  }
  else {
    v2.__d_.__rep_ = 0LL;
  }
  uint64_t v3 = *((void *)this + 3);
  if (v3 && !sub_1000604B4(v3))
  {
    if (*((void *)this + 4) == *((void *)this + 5))
    {
      uint64_t v8 = *((void *)this + 2);
      *((void *)this + 2) = *((void *)this + 3);
      *((void *)this + 3) = 0LL;
      if (!v8) {
        goto LABEL_14;
      }
    }

    else
    {
      sub_10005EED4(*((void *)this + 3), (uint64_t *)this + 4, v11);
      uint64_t v6 = *(void *)v11;
      *(void *)uint64_t v11 = 0LL;
      uint64_t v7 = *((void *)this + 2);
      *((void *)this + 2) = v6;
      if (!v7
        || ((*(void (**)(uint64_t))(*(void *)v7 + 8LL))(v7), v8 = *(void *)v11, *(void *)uint64_t v11 = 0LL, !v8))
      {
LABEL_14:
        *((_BYTE *)this + 56) = 0;
        if (RXLogPerformance())
        {
          double v9 = rd_time_util::durationInMilliSec(v2.__d_.__rep_);
          unint64_t v10 = (os_log_s *)RXOSLog();
          if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)uint64_t v11 = 134217984;
            *(double *)&v11[4] = v9;
            _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "Re-building grammar - %f", v11, 0xCu);
          }
        }

        return *((void *)this + 2);
      }
    }

    (*(void (**)(uint64_t))(*(void *)v8 + 8LL))(v8);
    goto LABEL_14;
  }

  size_t v4 = (os_log_s *)RXOSLog();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)uint64_t v11 = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_ERROR,  "Empty FST, try calling BuildGrammar first",  v11,  2u);
  }

  return 0LL;
}

void RDQSRGrammarBuilder::grammarProfile(RDQSRGrammarBuilder *this@<X0>, uint64_t *a2@<X8>)
{
  *a2 = 0LL;
  a2[1] = 0LL;
  a2[2] = 0LL;
  uint64_t v2 = *((void *)this + 4);
  uint64_t v3 = *((void *)this + 5);
  if (v2 != v3)
  {
    uint64_t v5 = a2 + 2;
    do
    {
      if (rd_userprofile_util::doesSupportProfile((void *)v2))
      {
        sub_100060FC4(*(void **)(v2 + 24), (uint64_t *)&v19);
        uint64_t v6 = rd_userprofile_util::nonTerminalForProfile((unint64_t *)v2);
        uint64_t v7 = rd_userprofile_util::wordTagForProfile((unint64_t *)v2);
        uint64_t v8 = v7;
        unint64_t v9 = a2[1];
        unint64_t v10 = a2[2];
        if (v9 >= v10)
        {
          unint64_t v12 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v9 - *a2) >> 3);
          unint64_t v13 = v12 + 1;
          if (v12 + 1 > 0x666666666666666LL) {
            sub_100018774();
          }
          unint64_t v14 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v10 - *a2) >> 3);
          if (2 * v14 > v13) {
            unint64_t v13 = 2 * v14;
          }
          if (v14 >= 0x333333333333333LL) {
            unint64_t v15 = 0x666666666666666LL;
          }
          else {
            unint64_t v15 = v13;
          }
          v21[4] = v5;
          uint64_t v16 = (char *)sub_10002E344((uint64_t)v5, v15);
          uint64_t v17 = (__CFString **)&v16[40 * v12];
          v21[0] = v16;
          v21[1] = v17;
          v21[3] = &v16[40 * v18];
          *uint64_t v17 = v6;
          v17[1] = v8;
          void v17[3] = 0LL;
          v17[4] = 0LL;
          v17[2] = 0LL;
          *((_OWORD *)v17 + 1) = v19;
          v17[4] = v20;
          __int128 v19 = 0uLL;
          size_t v20 = 0LL;
          v21[2] = v17 + 5;
          sub_10002E2D0(a2, v21);
          uint64_t v11 = a2[1];
          sub_10002E4B8(v21);
        }

        else
        {
          *(void *)unint64_t v9 = v6;
          *(void *)(v9 + _Block_object_dispose(va, 8) = v7;
          *(_OWORD *)(v9 + 16) = v19;
          *(void *)(v9 + 32) = v20;
          __int128 v19 = 0uLL;
          size_t v20 = 0LL;
          uint64_t v11 = v9 + 40;
        }

        a2[1] = v11;
        v21[0] = &v19;
        sub_1000180A4((void ***)v21);
      }

      v2 += 32LL;
    }

    while (v2 != v3);
  }

void sub_100028DDC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9, uint64_t a10, uint64_t a11, uint64_t a12, void ***a13)
{
  a13 = &a9;
  sub_1000180A4((void ***)&a13);
  sub_10002E258(&a9);
  _Unwind_Resume(a1);
}

void RDQSRGrammarBuilder::categoryProfile(char *__s@<X0>, void *a2@<X1>, uint64_t *a3@<X8>)
{
  *a3 = 0LL;
  a3[1] = 0LL;
  a3[2] = 0LL;
  sub_10000A2DC(__p, __s);
  int doesSupportProfile = rd_userprofile_util::doesSupportProfile(__p);
  int v7 = doesSupportProfile;
  if (SHIBYTE(v23) < 0)
  {
    operator delete(__p[0]);
    if (!v7) {
      return;
    }
  }

  else if (!doesSupportProfile)
  {
    return;
  }

  sub_100060FC4(a2, (uint64_t *)&v20);
  sub_10000A2DC(__p, __s);
  uint64_t v8 = rd_userprofile_util::nonTerminalForProfile((unint64_t *)__p);
  if (SHIBYTE(v23) < 0) {
    operator delete(__p[0]);
  }
  sub_10000A2DC(__p, __s);
  unint64_t v9 = rd_userprofile_util::wordTagForProfile((unint64_t *)__p);
  if (SHIBYTE(v23) < 0) {
    operator delete(__p[0]);
  }
  unint64_t v10 = a3[2];
  unint64_t v11 = a3[1];
  if (v11 >= v10)
  {
    unint64_t v13 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v11 - *a3) >> 3);
    unint64_t v14 = v13 + 1;
    if (v13 + 1 > 0x666666666666666LL) {
      sub_100018774();
    }
    unint64_t v15 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v10 - *a3) >> 3);
    if (2 * v15 > v14) {
      unint64_t v14 = 2 * v15;
    }
    if (v15 >= 0x333333333333333LL) {
      unint64_t v16 = 0x666666666666666LL;
    }
    else {
      unint64_t v16 = v14;
    }
    uint64_t v25 = a3 + 2;
    uint64_t v17 = (char *)sub_10002E344((uint64_t)(a3 + 2), v16);
    uint64_t v18 = (__CFString **)&v17[40 * v13];
    __p[0] = v17;
    __p[1] = v18;
    uint64_t v24 = &v17[40 * v19];
    *uint64_t v18 = v8;
    v18[1] = v9;
    v18[3] = 0LL;
    v18[4] = 0LL;
    v18[2] = 0LL;
    *((_OWORD *)v18 + 1) = v20;
    v18[4] = v21;
    __int128 v20 = 0uLL;
    uint64_t v21 = 0LL;
    unint64_t v23 = v18 + 5;
    sub_10002E2D0(a3, __p);
    uint64_t v12 = a3[1];
    sub_10002E4B8(__p);
  }

  else
  {
    *(void *)unint64_t v11 = v8;
    *(void *)(v11 + _Block_object_dispose(va, 8) = v9;
    *(_OWORD *)(v11 + 16) = v20;
    *(void *)(v11 + 32) = v21;
    __int128 v20 = 0uLL;
    uint64_t v21 = 0LL;
    uint64_t v12 = v11 + 40;
  }

  a3[1] = v12;
  __p[0] = &v20;
  sub_1000180A4((void ***)__p);
}

void sub_100029000( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t *a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19)
{
  a13 = &a9;
  sub_1000180A4((void ***)&a13);
  sub_10002E258((void ***)&a9);
  _Unwind_Resume(a1);
}

void RDQSRGrammarBuilder::fullGrammarProfile(RDQSRGrammarBuilder *this@<X0>, uint64_t *a2@<X8>)
{
  *a2 = 0LL;
  a2[1] = 0LL;
  a2[2] = 0LL;
  if (*((_BYTE *)this + 57))
  {
    uint64_t v3 = (os_log_s *)RXOSLog();
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_DEFAULT,  "3rd party grammar contains adlibs, so not adding them to profile",  buf,  2u);
    }
  }

  else
  {
    uint64_t v4 = RDQSRGrammarBuilder::grammarFST(this);
    if (v4)
    {
      sub_100060720(v4, 300, (uint64_t *)&v17);
      sub_10000A2DC(buf, "BuiltInLM.CustomCommand");
      uint64_t v5 = rd_userprofile_util::nonTerminalForProfile((unint64_t *)buf);
      if (SHIBYTE(v21) < 0) {
        operator delete(*(void **)buf);
      }
      sub_10000A2DC(buf, "BuiltInLM.CustomCommand");
      uint64_t v6 = rd_userprofile_util::wordTagForProfile((unint64_t *)buf);
      if (SHIBYTE(v21) < 0) {
        operator delete(*(void **)buf);
      }
      unint64_t v7 = a2[2];
      unint64_t v8 = a2[1];
      if (v8 >= v7)
      {
        unint64_t v10 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v8 - *a2) >> 3);
        unint64_t v11 = v10 + 1;
        if (v10 + 1 > 0x666666666666666LL) {
          sub_100018774();
        }
        unint64_t v12 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v7 - *a2) >> 3);
        if (2 * v12 > v11) {
          unint64_t v11 = 2 * v12;
        }
        if (v12 >= 0x333333333333333LL) {
          unint64_t v13 = 0x666666666666666LL;
        }
        else {
          unint64_t v13 = v11;
        }
        unint64_t v23 = a2 + 2;
        unint64_t v14 = (char *)sub_10002E344((uint64_t)(a2 + 2), v13);
        unint64_t v15 = (__CFString **)&v14[40 * v10];
        *(void *)__int128 buf = v14;
        __int128 v20 = v15;
        uint64_t v22 = &v14[40 * v16];
        void *v15 = v5;
        v15[1] = v6;
        v15[3] = 0LL;
        v15[4] = 0LL;
        void v15[2] = 0LL;
        *((_OWORD *)v15 + 1) = v17;
        v15[4] = v18;
        __int128 v17 = 0uLL;
        uint64_t v18 = 0LL;
        uint64_t v21 = v15 + 5;
        sub_10002E2D0(a2, buf);
        uint64_t v9 = a2[1];
        sub_10002E4B8((void **)buf);
      }

      else
      {
        *(void *)unint64_t v8 = v5;
        *(void *)(v8 + _Block_object_dispose(va, 8) = v6;
        *(_OWORD *)(v8 + 16) = v17;
        *(void *)(v8 + 32) = v18;
        __int128 v17 = 0uLL;
        uint64_t v18 = 0LL;
        uint64_t v9 = v8 + 40;
      }

      a2[1] = v9;
      *(void *)__int128 buf = &v17;
      sub_1000180A4((void ***)buf);
    }
  }

void sub_100029274( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t *a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  a12 = &a9;
  sub_1000180A4((void ***)&a12);
  sub_10002E258((void ***)&a9);
  _Unwind_Resume(a1);
}

void *sub_1000292E0(void *a1)
{
  uint64_t v2 = a1[4];
  a1[4] = 0LL;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8LL))(v2);
  }
  uint64_t v3 = a1[3];
  a1[3] = 0LL;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8LL))(v3);
  }
  uint64_t v4 = a1[2];
  a1[2] = 0LL;
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 8LL))(v4);
  }
  uint64_t v5 = a1[1];
  a1[1] = 0LL;
  if (v5) {
    (*(void (**)(uint64_t))(*(void *)v5 + 8LL))(v5);
  }
  return a1;
}

uint64_t *sub_100029360(uint64_t **a1, unint64_t *a2, uint64_t a3, uint64_t **a4)
{
  unint64_t v7 = a1 + 1;
  uint64_t v6 = a1[1];
  if (v6)
  {
    unint64_t v8 = *a2;
    while (1)
    {
      while (1)
      {
        uint64_t v9 = (uint64_t **)v6;
        unint64_t v10 = v6[4];
        if (v8 >= v10) {
          break;
        }
        uint64_t v6 = *v9;
        unint64_t v7 = v9;
        if (!*v9) {
          goto LABEL_10;
        }
      }

      if (v10 >= v8) {
        break;
      }
      uint64_t v6 = v9[1];
      if (!v6)
      {
        unint64_t v7 = v9 + 1;
        goto LABEL_10;
      }
    }
  }

  else
  {
    uint64_t v9 = a1 + 1;
LABEL_10:
    unint64_t v11 = (uint64_t *)operator new(0x30uLL);
    v11[4] = **a4;
    sub_100019D14(a1, (uint64_t)v9, v7, v11);
    return v11;
  }

  return (uint64_t *)v9;
}

void sub_10002941C(uint64_t a1, void **a2)
{
  if (a2)
  {
    sub_10001A7A8((uint64_t)(a2 + 3), a2[4]);
    uint64_t v3 = *a2;
    *a2 = 0LL;
    if (v3) {
      (*(void (**)(void *))(*v3 + 8LL))(v3);
    }
    operator delete(a2);
  }

uint64_t sub_100029468(uint64_t *a1, char **a2, uint64_t *a3)
{
  uint64_t v4 = *a1;
  uint64_t v5 = (a1[1] - *a1) >> 5;
  unint64_t v6 = v5 + 1;
  uint64_t v9 = (uint64_t)(a1 + 2);
  uint64_t v10 = a1[2] - v4;
  if (v10 >> 4 > v6) {
    unint64_t v6 = v10 >> 4;
  }
  else {
    unint64_t v11 = v6;
  }
  uint64_t v21 = a1 + 2;
  if (v11) {
    unint64_t v12 = (char *)sub_1000295D0(v9, v11);
  }
  else {
    unint64_t v12 = 0LL;
  }
  __int128 v17 = v12;
  uint64_t v18 = &v12[32 * v5];
  uint64_t v19 = v18;
  __int128 v20 = &v12[32 * v11];
  unint64_t v13 = sub_10000A2DC(v18, *a2);
  uint64_t v14 = *a3;
  *a3 = 0LL;
  void v13[3] = v14;
  v19 += 32;
  sub_10002955C(a1, &v17);
  uint64_t v15 = a1[1];
  sub_100029780(&v17);
  return v15;
}

void sub_100029548(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

uint64_t sub_10002955C(uint64_t *a1, void *a2)
{
  uint64_t result = sub_100029604((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

void *sub_1000295D0(uint64_t a1, unint64_t a2)
{
  if (a2 >> 59) {
    sub_100017F08();
  }
  return operator new(32 * a2);
}

uint64_t sub_100029604(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7 = a7;
  *(void *)&__int128 v16 = a6;
  *((void *)&v16 + 1) = a7;
  __int128 v15 = v16;
  v13[0] = a1;
  v13[1] = &v15;
  v13[2] = &v16;
  if (a3 == a5)
  {
    uint64_t v11 = a6;
  }

  else
  {
    uint64_t v8 = a7 - 32;
    do
    {
      __int128 v9 = *(_OWORD *)(a3 - 32);
      *(void *)(v8 + 16) = *(void *)(a3 - 16);
      *(_OWORD *)uint64_t v8 = v9;
      *(void *)(a3 - 32) = 0LL;
      *(void *)(a3 - 24) = 0LL;
      uint64_t v10 = *(void *)(a3 - 8);
      *(void *)(a3 - 16) = 0LL;
      *(void *)(a3 - _Block_object_dispose(va, 8) = 0LL;
      *(void *)(v8 + 24) = v10;
      *((void *)&v16 + 1) = v8;
      v7 -= 32LL;
      v8 -= 32LL;
      a3 -= 32LL;
    }

    while (a3 != a5);
    uint64_t v11 = v16;
  }

  char v14 = 1;
  sub_1000296B0((uint64_t)v13);
  return v11;
}

uint64_t sub_1000296B0(uint64_t a1)
{
  if (!*(_BYTE *)(a1 + 24)) {
    sub_1000296E4((uint64_t *)a1);
  }
  return a1;
}

void sub_1000296E4(uint64_t *a1)
{
  uint64_t v1 = *(void *)(a1[2] + 8);
  uint64_t v2 = *(void *)(a1[1] + 8);
  if (v1 != v2)
  {
    uint64_t v3 = *a1;
    do
    {
      sub_100029734(v3, v1);
      v1 += 32LL;
    }

    while (v1 != v2);
  }

void sub_100029734(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 24);
  *(void *)(a2 + 24) = 0LL;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8LL))(v3);
  }
}

void **sub_100029780(void **a1)
{
  if (*a1) {
    operator delete(*a1);
  }
  return a1;
}

void sub_1000297B0(void *a1)
{
  uint64_t v2 = a1[1];
  for (uint64_t i = a1[2]; i != v2; uint64_t i = a1[2])
  {
    uint64_t v4 = a1[4];
    a1[2] = i - 32;
    sub_100029734(v4, i - 32);
  }

_OWORD *sub_1000297F4(uint64_t **a1, const void **a2, uint64_t a3)
{
  uint64_t v5 = (void **)sub_100099510((uint64_t)a1, &v9, a2);
  uint64_t v6 = *v5;
  if (!*v5)
  {
    uint64_t v7 = (uint64_t **)v5;
    uint64_t v6 = operator new(0x38uLL);
    v6[2] = *(_OWORD *)a3;
    *((void *)v6 + 6) = *(void *)(a3 + 16);
    *(void *)a3 = 0LL;
    *(void *)(a3 + _Block_object_dispose(va, 8) = 0LL;
    *(void *)(a3 + 16) = 0LL;
    sub_100019D14(a1, v9, v7, (uint64_t *)v6);
  }

  return v6;
}

void *sub_100029884(void *result, __int128 *a2, uint64_t *a3)
{
  uint64_t v4 = result;
  uint64_t v5 = result[1];
  if (*((char *)a2 + 23) < 0)
  {
    uint64_t result = sub_10005AA70((_BYTE *)result[1], *(void **)a2, *((void *)a2 + 1));
  }

  else
  {
    __int128 v6 = *a2;
    *(void *)(v5 + 16) = *((void *)a2 + 2);
    *(_OWORD *)uint64_t v5 = v6;
  }

  uint64_t v7 = *a3;
  *a3 = 0LL;
  *(void *)(v5 + 24) = v7;
  v4[1] = v5 + 32;
  return result;
}

void sub_1000298F0(_Unwind_Exception *a1)
{
  *(void *)(v1 + _Block_object_dispose(va, 8) = v2;
  _Unwind_Resume(a1);
}

uint64_t sub_1000298F8(uint64_t *a1, __int128 *a2, uint64_t *a3)
{
  uint64_t v4 = *a1;
  uint64_t v5 = (a1[1] - *a1) >> 5;
  unint64_t v6 = v5 + 1;
  uint64_t v9 = (uint64_t)(a1 + 2);
  uint64_t v10 = a1[2] - v4;
  if (v10 >> 4 > v6) {
    unint64_t v6 = v10 >> 4;
  }
  else {
    unint64_t v11 = v6;
  }
  uint64_t v21 = a1 + 2;
  if (v11) {
    unint64_t v12 = (char *)sub_1000295D0(v9, v11);
  }
  else {
    unint64_t v12 = 0LL;
  }
  unint64_t v13 = &v12[32 * v5];
  v18[0] = v12;
  v18[1] = v13;
  uint64_t v19 = v13;
  __int128 v20 = &v12[32 * v11];
  if (*((char *)a2 + 23) < 0)
  {
    sub_10005AA70(v13, *(void **)a2, *((void *)a2 + 1));
    unint64_t v13 = v19;
  }

  else
  {
    __int128 v14 = *a2;
    *((void *)v13 + 2) = *((void *)a2 + 2);
    *(_OWORD *)unint64_t v13 = v14;
  }

  uint64_t v15 = *a3;
  *a3 = 0LL;
  *(void *)&v12[32 * v5 + 24] = v15;
  uint64_t v19 = v13 + 32;
  sub_10002955C(a1, v18);
  uint64_t v16 = a1[1];
  sub_100029780(v18);
  return v16;
}

void sub_100029A00(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

void sub_100029A14(uint64_t a1, char *a2)
{
  if (a2)
  {
    uint64_t v4 = (void **)(a2 + 160);
    sub_100029AAC(&v4);
    sub_100018678((uint64_t)(a2 + 136), *((char **)a2 + 18));
    sub_100018678((uint64_t)(a2 + 112), *((char **)a2 + 15));
    sub_100018678((uint64_t)(a2 + 88), *((char **)a2 + 12));
    sub_10001A7A8((uint64_t)(a2 + 56), *((void **)a2 + 8));
    uint64_t v4 = (void **)(a2 + 8);
    sub_100029AAC(&v4);
    uint64_t v3 = *(char **)a2;
    *(void *)a2 = 0LL;
    if (v3) {
      (*(void (**)(char *))(*(void *)v3 + 8LL))(v3);
    }
    operator delete(a2);
  }

void sub_100029AAC(void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = **a1;
  if (v2)
  {
    uint64_t v4 = (uint64_t)v1[1];
    uint64_t v5 = **a1;
    if ((void *)v4 != v2)
    {
      do
      {
        v4 -= 32LL;
        sub_100029734((uint64_t)(v1 + 2), v4);
      }

      while ((void *)v4 != v2);
      uint64_t v5 = **a1;
    }

    v1[1] = v2;
    operator delete(v5);
  }

void sub_100029B30(void **a1)
{
  uint64_t v1 = *a1;
  if (*a1)
  {
    uint64_t v3 = (uint64_t)a1[1];
    uint64_t v4 = *a1;
    if ((void *)v3 != v1)
    {
      do
      {
        v3 -= 32LL;
        sub_100029734((uint64_t)(a1 + 2), v3);
      }

      while ((void *)v3 != v1);
      uint64_t v4 = *a1;
    }

    a1[1] = v1;
    operator delete(v4);
    *a1 = 0LL;
    a1[1] = 0LL;
    a1[2] = 0LL;
  }

void *sub_100029B9C(void *a1)
{
  *a1 = off_1000D0A50;
  sub_100017FC4((uint64_t)(a1 + 1));
  return a1;
}

void sub_100029BD0(void *a1)
{
  *a1 = off_1000D0A50;
  sub_100017FC4((uint64_t)(a1 + 1));
  operator delete(a1);
}

uint64_t sub_100029C04(uint64_t a1)
{
  return *(unsigned int *)(*(void *)(a1 + 8) + 80LL);
}

float sub_100029C10@<S0>(uint64_t a1@<X0>, int a2@<W1>, _DWORD *a3@<X8>)
{
  uint64_t v3 = *(float **)(*(void *)(*(void *)(a1 + 8) + 56LL) + 8LL * a2);
  float result = *v3;
  *a3 = *(_DWORD *)v3;
  return result;
}

uint64_t sub_100029C28(uint64_t a1, int a2)
{
}

uint64_t sub_100029C44(uint64_t a1, int a2)
{
  return *(void *)(*(void *)(*(void *)(*(void *)(a1 + 8) + 56LL) + 8LL * a2) + 8LL);
}

uint64_t sub_100029C58(uint64_t a1, int a2)
{
  return *(void *)(*(void *)(*(void *)(*(void *)(a1 + 8) + 56LL) + 8LL * a2) + 16LL);
}

uint64_t sub_100029C6C(uint64_t a1, uint64_t a2, int a3)
{
  if (!a3) {
    return (*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 8) + 24LL))(*(void *)(a1 + 8), a2);
  }
  unint64_t v5 = sub_10005AF40(a1, a2, &v7);
  *(void *)(*(void *)(a1 + 8) + 8LL) = *(void *)(*(void *)(a1 + 8) + 8LL) & (~v7 | 4) | v7 & v5;
  return v5 & a2;
}

uint64_t sub_100029CF0(uint64_t a1)
{
  return *(void *)(a1 + 8) + 16LL;
}

void *sub_100029CFC(uint64_t a1)
{
  float result = operator new(0x18uLL);
  uint64_t v3 = *(void *)(a1 + 16);
  result[1] = *(void *)(a1 + 8);
  result[2] = v3;
  if (v3)
  {
    uint64_t v4 = (unint64_t *)(v3 + 8);
    do
      unint64_t v5 = __ldxr(v4);
    while (__stxr(v5 + 1, v4));
  }

  void *result = off_1000D06D8;
  return result;
}

uint64_t sub_100029D58(uint64_t a1)
{
  return *(void *)(*(void *)(a1 + 8) + 40LL);
}

uint64_t sub_100029D64(uint64_t a1)
{
  return *(void *)(*(void *)(a1 + 8) + 48LL);
}

uint64_t sub_100029D70(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *(void *)a2 = 0LL;
  *(_DWORD *)(a2 + _Block_object_dispose(va, 8) = (*(void *)(v2 + 64) - *(void *)(v2 + 56)) >> 3;
  return result;
}

uint64_t sub_100029D8C(uint64_t result, int a2, void *a3)
{
  uint64_t v3 = *(void *)(result + 8);
  *a3 = 0LL;
  unint64_t v5 = (uint64_t *)(*(void *)(*(void *)(v3 + 56) + 8LL * a2) + 24LL);
  uint64_t v4 = *v5;
  uint64_t v6 = (v5[1] - *v5) >> 4;
  if (v5[1] == *v5) {
    uint64_t v4 = 0LL;
  }
  a3[1] = v4;
  a3[2] = v6;
  a3[3] = 0LL;
  return result;
}

uint64_t sub_100029DB8(uint64_t a1)
{
  return (*(void *)(*(void *)(a1 + 8) + 64LL) - *(void *)(*(void *)(a1 + 8) + 56LL)) >> 3;
}

uint64_t sub_100029DCC(uint64_t a1, uint64_t a2)
{
  if (a1 != a2)
  {
    sub_10002CFFC(a2, &v7);
    sub_10002CF84((void *)(a1 + 8), &v7);
    uint64_t v3 = v8;
    if (v8)
    {
      p_shared_owners = (unint64_t *)&v8->__shared_owners_;
      do
        unint64_t v5 = __ldaxr(p_shared_owners);
      while (__stlxr(v5 - 1, p_shared_owners));
      if (!v5)
      {
        ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
        std::__shared_weak_count::__release_weak(v3);
      }
    }
  }

  return a1;
}

unint64_t sub_100029E4C(uint64_t a1, int a2)
{
  uint64_t v4 = *(void *)(a1 + 8);
  *(_DWORD *)(v4 + 8sub_10001AFB0((std::locale *)v24, " +$", 0) = a2;
  unint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)v4 + 16LL))(v4);
  *(void *)(v4 + _Block_object_dispose(va, 8) = result & 0xCCCFFFFF0007LL | (((result >> 35) & 1) << 37) | *(void *)(v4 + 8) & 4LL;
  return result;
}

float sub_100029EB0(uint64_t a1, int a2, int *a3)
{
  uint64_t v6 = *(void **)(a1 + 8);
  int v8 = *a3;
  return sub_10002D840(v6, a2, (float *)&v8);
}

void sub_100029F00(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(void *)(*(void *)(a1 + 8) + 8LL) = *(void *)(*(void *)(a1 + 8) + 8LL) & (~a3 | 4) | a3 & a2;
}

uint64_t sub_100029F78(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 8);
  uint64_t v3 = sub_10002D0E8(v2);
  v2[1] = v2[1] & 4LL | (*(uint64_t (**)(void *))(*v2 + 16LL))(v2) & 0xEAFFFFFF0007LL;
  return v3;
}

uint64_t sub_100029FDC(uint64_t a1, int a2, float *a3)
{
  return sub_10002D8BC(*(void **)(a1 + 8), a2, a3);
}

uint64_t sub_10002A018(uint64_t a1, char **a2)
{
  uint64_t v4 = *(void **)(a1 + 8);
  sub_10002D938((uint64_t)v4, a2);
  uint64_t result = (*(uint64_t (**)(void *))(*v4 + 16LL))(v4);
  v4[1] = v4[1] & 4LL | result & 0x806A5A950007LL;
  return result;
}

uint64_t sub_10002A07C(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 16);
  if (v1 && !*(void *)(v1 + 8))
  {
    uint64_t v15 = *(void **)(a1 + 8);
    sub_10002DF28((uint64_t)v15);
    uint64_t result = (*(uint64_t (**)(void *))(*v15 + 16LL))(v15);
    v15[1] = (*((_DWORD *)v15 + 2) | result) & 4 | 0x956A5A950003LL;
  }

  else
  {
    uint64_t v3 = *(void *)(a1 + 8);
    uint64_t v2 = (uint64_t *)(a1 + 8);
    uint64_t v5 = *(void *)(v3 + 40);
    uint64_t v4 = *(void *)(v3 + 48);
    sub_10002DDB0(&v16);
    sub_10002CF84(v2, &v16);
    uint64_t v6 = v17;
    if (v17)
    {
      p_shared_owners = (unint64_t *)&v17->__shared_owners_;
      do
        unint64_t v8 = __ldaxr(p_shared_owners);
      while (__stlxr(v8 - 1, p_shared_owners));
      if (!v8)
      {
        ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
        std::__shared_weak_count::__release_weak(v6);
      }
    }

    uint64_t v9 = *v2;
    if (v5) {
      uint64_t v10 = (*(uint64_t (**)(uint64_t))(*(void *)v5 + 16LL))(v5);
    }
    else {
      uint64_t v10 = 0LL;
    }
    uint64_t v11 = *(void *)(v9 + 40);
    *(void *)(v9 + 4sub_10001AFB0((std::locale *)v24, " +$", 0) = v10;
    if (v11) {
      (*(void (**)(uint64_t))(*(void *)v11 + 8LL))(v11);
    }
    uint64_t v12 = *v2;
    if (v4) {
      uint64_t v13 = (*(uint64_t (**)(uint64_t))(*(void *)v4 + 16LL))(v4);
    }
    else {
      uint64_t v13 = 0LL;
    }
    uint64_t result = *(void *)(v12 + 48);
    *(void *)(v12 + 4_Block_object_dispose(va, 8) = v13;
    if (result) {
      return (*(uint64_t (**)(uint64_t))(*(void *)result + 8LL))(result);
    }
  }

  return result;
}

uint64_t sub_10002A1C8(uint64_t a1, int a2, uint64_t a3)
{
  uint64_t v6 = *(void **)(a1 + 8);
  sub_10002DB9C(*(void **)(v6[7] + 8LL * a2), a3);
  uint64_t result = (*(uint64_t (**)(void *))(*v6 + 16LL))(v6);
  v6[1] = v6[1] & 4LL | result & 0x8A6A5A950007LL;
  return result;
}

uint64_t sub_10002A23C(uint64_t a1, int a2)
{
  uint64_t v4 = *(void **)(a1 + 8);
  uint64_t v5 = *(void **)(v4[7] + 8LL * a2);
  v5[1] = 0LL;
  _OWORD v5[2] = 0LL;
  v5[4] = v5[3];
  uint64_t result = (*(uint64_t (**)(void *))(*v4 + 16LL))(v4);
  v4[1] = v4[1] & 4LL | result & 0x8A6A5A950007LL;
  return result;
}

void sub_10002A2A8(uint64_t a1, int a2)
{
}

void sub_10002A2D8(uint64_t a1, int a2, unint64_t a3)
{
}

uint64_t sub_10002A31C(uint64_t a1)
{
  return *(void *)(*(void *)(a1 + 8) + 40LL);
}

uint64_t sub_10002A344(uint64_t a1)
{
  return *(void *)(*(void *)(a1 + 8) + 48LL);
}

uint64_t sub_10002A36C(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a1 + 8);
  if (a2) {
    uint64_t v5 = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 16LL))(a2);
  }
  else {
    uint64_t v5 = 0LL;
  }
  uint64_t result = *(void *)(v4 + 40);
  *(void *)(v4 + 4sub_10001AFB0((std::locale *)v24, " +$", 0) = v5;
  if (result) {
    return (*(uint64_t (**)(uint64_t))(*(void *)result + 8LL))(result);
  }
  return result;
}

uint64_t sub_10002A3D4(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a1 + 8);
  if (a2) {
    uint64_t v5 = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 16LL))(a2);
  }
  else {
    uint64_t v5 = 0LL;
  }
  uint64_t result = *(void *)(v4 + 48);
  *(void *)(v4 + 4_Block_object_dispose(va, 8) = v5;
  if (result) {
    return (*(uint64_t (**)(uint64_t))(*(void *)result + 8LL))(result);
  }
  return result;
}

void sub_10002A43C(uint64_t a1, int a2, void *a3)
{
  uint64_t v6 = operator new(0x20uLL);
  void *v6 = &off_1000D0C28;
  v6[3] = 0LL;
  sub_10002D714(a1);
  uint64_t v7 = *(void *)(a1 + 8);
  v6[1] = *(void *)(*(void *)(v7 + 56) + 8LL * a2);
  v6[2] = v7 + 8;
  *a3 = v6;
}

void sub_10002A4A8(_Unwind_Exception *a1)
{
}

uint64_t sub_10002A4BC(uint64_t a1)
{
  uint64_t v2 = sub_10002A6A4(&std::cerr, (uint64_t)"Fst::Write: No write stream method for ", 39LL);
  uint64_t v3 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 64LL))(a1);
  int v4 = *(char *)(v3 + 23);
  if (v4 >= 0) {
    uint64_t v5 = v3;
  }
  else {
    uint64_t v5 = *(void *)v3;
  }
  if (v4 >= 0) {
    uint64_t v6 = *(unsigned __int8 *)(v3 + 23);
  }
  else {
    uint64_t v6 = *(void *)(v3 + 8);
  }
  uint64_t v7 = sub_10002A6A4(v2, v5, v6);
  sub_10002A6A4(v7, (uint64_t)" FST type", 9LL);
  sub_10002AA94(&v11);
  if (v10 < 0) {
    operator delete(__p[0]);
  }
  return 0LL;
}

void sub_10002A574( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10002A5A0(uint64_t a1)
{
  uint64_t v2 = sub_10002A6A4(&std::cerr, (uint64_t)"Fst::Write: No write filename method for ", 41LL);
  uint64_t v3 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 64LL))(a1);
  int v4 = *(char *)(v3 + 23);
  if (v4 >= 0) {
    uint64_t v5 = v3;
  }
  else {
    uint64_t v5 = *(void *)v3;
  }
  if (v4 >= 0) {
    uint64_t v6 = *(unsigned __int8 *)(v3 + 23);
  }
  else {
    uint64_t v6 = *(void *)(v3 + 8);
  }
  uint64_t v7 = sub_10002A6A4(v2, v5, v6);
  sub_10002A6A4(v7, (uint64_t)" FST type", 9LL);
  sub_10002AA94(&v11);
  if (v10 < 0) {
    operator delete(__p[0]);
  }
  return 0LL;
}

void sub_10002A658( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10002A684(uint64_t a1)
{
  return *(void *)(*(void *)(a1 + 8) + 40LL);
}

uint64_t sub_10002A690(uint64_t a1)
{
  return *(void *)(*(void *)(a1 + 8) + 48LL);
}

void *sub_10002A6A4(void *a1, uint64_t a2, uint64_t a3)
{
  if (v13[0])
  {
    uint64_t v6 = (uint64_t)a1 + *(void *)(*a1 - 24LL);
    uint64_t v7 = *(void *)(v6 + 40);
    int v8 = *(_DWORD *)(v6 + 8);
    int v9 = *(_DWORD *)(v6 + 144);
    if (v9 == -1)
    {
      std::ios_base::getloc((const std::ios_base *)((char *)a1 + *(void *)(*a1 - 24LL)));
      char v10 = std::locale::use_facet(&v14, &std::ctype<char>::id);
      int v9 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v10->__vftable[2].~facet_0)(v10, 32LL);
      std::locale::~locale(&v14);
      *(_DWORD *)(v6 + 144) = v9;
    }

    if ((v8 & 0xB0) == 0x20) {
      uint64_t v11 = a2 + a3;
    }
    else {
      uint64_t v11 = a2;
    }
    if (!sub_10002A808(v7, a2, v11, a2 + a3, v6, (char)v9)) {
      std::ios_base::clear( (std::ios_base *)((char *)a1 + *(void *)(*a1 - 24LL)),  *(_DWORD *)((char *)a1 + *(void *)(*a1 - 24LL) + 32) | 5);
    }
  }

  std::ostream::sentry::~sentry(v13);
  return a1;
}

void sub_10002A7AC( void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, std::locale a12)
{
}

void sub_10002A7F4(_Unwind_Exception *a1)
{
}

uint64_t sub_10002A808(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int __c)
{
  uint64_t v6 = a1;
  if (a1)
  {
    uint64_t v11 = *(void *)(a5 + 24);
    if (v11 <= a4 - a2) {
      int64_t v12 = 0LL;
    }
    else {
      int64_t v12 = v11 - (a4 - a2);
    }
    if (v12 >= 1)
    {
      sub_10002A944(__p, v12, __c);
      uint64_t v13 = v18 >= 0 ? __p : (void **)__p[0];
      uint64_t v14 = (*(uint64_t (**)(uint64_t, void **, int64_t))(*(void *)v6 + 96LL))(v6, v13, v12);
      if (v18 < 0) {
        operator delete(__p[0]);
      }
      if (v14 != v12) {
        return 0LL;
      }
    }

    uint64_t v15 = a4 - a3;
    else {
      return 0LL;
    }
  }

  return v6;
}

void sub_10002A928( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void *sub_10002A944(void *__b, size_t __len, int __c)
{
  if (__len >= 0x7FFFFFFFFFFFFFF8LL) {
    sub_10000A38C();
  }
  if (__len >= 0x17)
  {
    size_t v7 = (__len & 0xFFFFFFFFFFFFFFF8LL) + 8;
    if ((__len | 7) != 0x17) {
      size_t v7 = __len | 7;
    }
    size_t v8 = v7 + 1;
    uint64_t v6 = operator new(v7 + 1);
    __b[1] = __len;
    __b[2] = v8 | 0x8000000000000000LL;
    *__b = v6;
  }

  else
  {
    *((_BYTE *)__b + 23) = __len;
    uint64_t v6 = __b;
    if (!__len) {
      goto LABEL_9;
    }
  }

  memset(v6, __c, __len);
LABEL_9:
  *((_BYTE *)v6 + __len) = 0;
  return __b;
}

BOOL *sub_10002A9EC(BOOL *a1, uint64_t a2)
{
  int v3 = *(char *)(a2 + 23);
  if (v3 < 0)
  {
    if (*(void *)(a2 + 8) != 5LL)
    {
LABEL_12:
      BOOL v8 = 0;
      goto LABEL_13;
    }

    uint64_t v4 = *(void *)a2;
  }

  else
  {
    uint64_t v4 = a2;
    if (v3 != 5) {
      goto LABEL_12;
    }
  }

  int v5 = *(_DWORD *)v4;
  int v6 = *(unsigned __int8 *)(v4 + 4);
  BOOL v8 = v5 == 1096040774 && v6 == 76;
LABEL_13:
  *a1 = v8;
  uint64_t v9 = *(void *)(a2 + 8);
  if (*(char *)(a2 + 23) >= 0)
  {
    uint64_t v10 = *(unsigned __int8 *)(a2 + 23);
  }

  else
  {
    a2 = *(void *)a2;
    uint64_t v10 = v9;
  }

  uint64_t v11 = sub_10002A6A4(&std::cerr, a2, v10);
  sub_10002A6A4(v11, (uint64_t)": ", 2LL);
  return a1;
}

_BYTE *sub_10002AA94(_BYTE *a1)
{
  std::ios_base::getloc((const std::ios_base *)((char *)&std::cerr
                                              + (unint64_t)std::cerr.__vftable[-2].~basic_ostream_0));
  uint64_t v2 = std::locale::use_facet(&v5, &std::ctype<char>::id);
  uint64_t v3 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v2->__vftable[2].~facet_0)(v2, 10LL);
  std::locale::~locale(&v5);
  std::ostream::put(&std::cerr, v3);
  std::ostream::flush(&std::cerr);
  if (*a1) {
    exit(1);
  }
  return a1;
}

void sub_10002AB34( void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::locale a10)
{
}

BOOL sub_10002AB50(unint64_t a1, unint64_t a2)
{
  uint64_t v2 = (((2 * a2) & 0xAAAAAAAA0000LL | a2 & 0xFFFFFFFF0000LL | (a2 >> 1) & 0x555555550000LL) & ((a1 >> 1) & 0x555555550000LL | (2 * a1) & 0xAAAAAAAA0000LL | a1) | 7) & (a2 ^ a1);
  if (v2)
  {
    uint64_t v5 = 0LL;
    uint64_t v6 = 1LL;
    do
    {
      if ((v6 & v2) != 0)
      {
        sub_10000A2DC(__p, "ERROR");
        sub_10002A9EC(&v20, (uint64_t)__p);
        size_t v7 = sub_10002A6A4(&std::cerr, (uint64_t)"CompatProperties: Mismatch: ", 28LL);
        size_t v8 = strlen(off_1000DDB28[v5]);
        uint64_t v9 = sub_10002A6A4(v7, (uint64_t)off_1000DDB28[v5], v8);
        uint64_t v10 = sub_10002A6A4(v9, (uint64_t)": props1 = ", 11LL);
        if ((v6 & a1) != 0) {
          uint64_t v11 = "true";
        }
        else {
          uint64_t v11 = "false";
        }
        if ((v6 & a1) != 0) {
          uint64_t v12 = 4LL;
        }
        else {
          uint64_t v12 = 5LL;
        }
        uint64_t v13 = sub_10002A6A4(v10, (uint64_t)v11, v12);
        uint64_t v14 = sub_10002A6A4(v13, (uint64_t)", props2 = ", 11LL);
        if ((v6 & a2) != 0) {
          uint64_t v15 = "true";
        }
        else {
          uint64_t v15 = "false";
        }
        if ((v6 & a2) != 0) {
          uint64_t v16 = 4LL;
        }
        else {
          uint64_t v16 = 5LL;
        }
        sub_10002A6A4(v14, (uint64_t)v15, v16);
        sub_10002AA94(&v20);
        if (v19 < 0) {
          operator delete(__p[0]);
        }
      }

      v6 *= 2LL;
      ++v5;
    }

    while (v5 != 64);
  }

  return v2 == 0;
}

void sub_10002ACD0( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, int a15, __int16 a16, char a17, char a18)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void ***sub_10002ACFC(void ***a1)
{
  uint64_t v4 = a1[10];
  uint64_t v2 = a1 + 10;
  uint64_t v3 = v4;
  void *v2 = 0LL;
  if (v4) {
    sub_10002B7A4((int)v2, v3);
  }
  sub_10002B764(a1 + 9, 0LL);
  uint64_t v5 = a1[8];
  a1[8] = 0LL;
  if (v5) {
    sub_10002B7A4((_DWORD)a1 + 64, v5);
  }
  uint64_t v6 = a1[7];
  a1[7] = 0LL;
  if (v6) {
    sub_10002B7A4((_DWORD)a1 + 56, v6);
  }
  return a1;
}

int *sub_10002AD60()
{
  unsigned __int8 v0 = atomic_load((unsigned __int8 *)&qword_1000DD360);
  if ((v0 & 1) == 0 && __cxa_guard_acquire(&qword_1000DD360))
  {
    dword_1000DD358 = 0;
    __cxa_guard_release(&qword_1000DD360);
  }

  return &dword_1000DD358;
}

int *sub_10002ADB0()
{
  unsigned __int8 v0 = atomic_load((unsigned __int8 *)&qword_1000DD370);
  if ((v0 & 1) == 0 && __cxa_guard_acquire(&qword_1000DD370))
  {
    dword_1000DD368 = 2139095040;
    __cxa_guard_release(&qword_1000DD370);
  }

  return &dword_1000DD368;
}

void sub_10002AE04(uint64_t a1, uint64_t a2)
{
  if (*(void *)a1) {
    *(void *)(*(void *)a1 + 8LL) = **(void **)a1;
  }
  uint64_t v4 = *(void *)(a1 + 8);
  if (v4) {
    *(void *)(v4 + _Block_object_dispose(va, 8) = 0LL;
  }
  uint64_t v5 = *(void *)(a1 + 16);
  if (v5)
  {
    char v6 = 0;
    *(void *)(v5 + _Block_object_dispose(va, 8) = 0LL;
  }

  else
  {
    size_t v7 = operator new(0x18uLL);
    v7[1] = 0LL;
    _OWORD v7[2] = 0LL;
    *size_t v7 = 0LL;
    *(void *)(a1 + 16) = v7;
    char v6 = 1;
  }

  *(_BYTE *)(a1 + 52) = v6;
  **(void **)(a1 + 24) = **(void **)(a1 + 24) & 0xFFFFF0C3FFFFFFFFLL | 0x52800000000LL;
  *(void *)(a1 + 32) = a2;
  int v8 = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 16LL))(a2);
  *(_DWORD *)(a1 + 44) = 0;
  *(_DWORD *)(a1 + 4_Block_object_dispose(va, 8) = 0;
  *(_DWORD *)(a1 + 4sub_10001AFB0((std::locale *)v24, " +$", 0) = v8;
  uint64_t v9 = operator new(0x18uLL);
  uint64_t v10 = *(void ***)(a1 + 56);
  v9[1] = 0LL;
  v9[2] = 0LL;
  *uint64_t v9 = 0LL;
  *(void *)(a1 + 56) = v9;
  if (v10) {
    sub_10002B7A4(a1 + 56, v10);
  }
  uint64_t v11 = operator new(0x18uLL);
  uint64_t v12 = *(void ***)(a1 + 64);
  v11[1] = 0LL;
  v11[2] = 0LL;
  *uint64_t v11 = 0LL;
  *(void *)(a1 + 64) = v11;
  if (v12) {
    sub_10002B7A4(a1 + 64, v12);
  }
  uint64_t v13 = (void **)operator new(0x18uLL);
  v13[1] = 0LL;
  v13[2] = 0LL;
  *uint64_t v13 = 0LL;
  sub_10002B764((void ***)(a1 + 72), v13);
  uint64_t v14 = operator new(0x18uLL);
  __int128 v17 = *(void ***)(a1 + 80);
  uint64_t v16 = (void *)(a1 + 80);
  uint64_t v15 = v17;
  v14[1] = 0LL;
  v14[2] = 0LL;
  *uint64_t v14 = 0LL;
  *uint64_t v16 = v14;
  if (v17) {
    sub_10002B7A4((int)v16, v15);
  }
}

void sub_10002AF44(uint64_t a1)
{
  if (*(void *)a1)
  {
    uint64_t v2 = **(_DWORD ***)a1;
    uint64_t v3 = *(void *)(*(void *)a1 + 8LL) - (void)v2;
    if (v3)
    {
      unint64_t v4 = v3 >> 2;
      if (v4 <= 1) {
        unint64_t v4 = 1LL;
      }
      do
      {
        _DWORD *v2 = *(_DWORD *)(a1 + 48) + ~*v2;
        ++v2;
        --v4;
      }

      while (v4);
    }
  }

  if (*(_BYTE *)(a1 + 52))
  {
    uint64_t v5 = *(void ***)(a1 + 16);
    if (v5)
    {
      if (*v5) {
        operator delete(*v5);
      }
      operator delete(v5);
    }
  }

  char v6 = *(void ***)(a1 + 56);
  *(void *)(a1 + 56) = 0LL;
  if (v6) {
    sub_10002B7A4(a1 + 56, v6);
  }
  size_t v7 = *(void ***)(a1 + 64);
  *(void *)(a1 + 64) = 0LL;
  if (v7) {
    sub_10002B7A4(a1 + 64, v7);
  }
  sub_10002B764((void ***)(a1 + 72), 0LL);
  uint64_t v10 = *(void ***)(a1 + 80);
  uint64_t v9 = (void *)(a1 + 80);
  int v8 = v10;
  *uint64_t v9 = 0LL;
  if (v10) {
    sub_10002B7A4((int)v9, v8);
  }
}

uint64_t sub_10002B010(uint64_t *a1, int a2, int a3)
{
  uint64_t v6 = a1[10];
  size_t v7 = *(_DWORD **)(v6 + 8);
  unint64_t v8 = *(void *)(v6 + 16);
  if ((unint64_t)v7 >= v8)
  {
    uint64_t v10 = *(_DWORD **)v6;
    uint64_t v11 = ((uint64_t)v7 - *(void *)v6) >> 2;
    unint64_t v12 = v11 + 1;
    uint64_t v13 = v8 - (void)v10;
    if (v13 >> 1 > v12) {
      unint64_t v12 = v13 >> 1;
    }
    else {
      unint64_t v14 = v12;
    }
    if (v14)
    {
      uint64_t v15 = (char *)sub_10002C050(v6 + 16, v14);
      uint64_t v10 = *(_DWORD **)v6;
      size_t v7 = *(_DWORD **)(v6 + 8);
    }

    else
    {
      uint64_t v15 = 0LL;
    }

    uint64_t v16 = &v15[4 * v11];
    __int128 v17 = &v15[4 * v14];
    *(_DWORD *)uint64_t v16 = a2;
    uint64_t v9 = v16 + 4;
    while (v7 != v10)
    {
      int v18 = *--v7;
      *((_DWORD *)v16 - 1) = v18;
      v16 -= 4;
    }

    *(void *)uint64_t v6 = v16;
    *(void *)(v6 + _Block_object_dispose(va, 8) = v9;
    *(void *)(v6 + 16) = v17;
    if (v10) {
      operator delete(v10);
    }
  }

  else
  {
    *size_t v7 = a2;
    uint64_t v9 = v7 + 1;
  }

  *(void *)(v6 + _Block_object_dispose(va, 8) = v9;
  unint64_t v19 = a2;
  uint64_t v20 = *(void *)a1[7];
  if (a2 >= (unint64_t)((*(void *)(a1[7] + 8) - v20) >> 2))
  {
    do
    {
      uint64_t v21 = *a1;
      if (*a1)
      {
        unint64_t v22 = *(void *)(v21 + 16);
        unint64_t v23 = *(_DWORD **)(v21 + 8);
        if ((unint64_t)v23 >= v22)
        {
          uint64_t v25 = *(_DWORD **)v21;
          uint64_t v26 = ((uint64_t)v23 - *(void *)v21) >> 2;
          unint64_t v27 = v26 + 1;
          uint64_t v28 = v22 - (void)v25;
          if (v28 >> 1 > v27) {
            unint64_t v27 = v28 >> 1;
          }
          else {
            unint64_t v29 = v27;
          }
          if (v29)
          {
            uint64_t v30 = (char *)sub_10002C050(v21 + 16, v29);
            uint64_t v25 = *(_DWORD **)v21;
            unint64_t v23 = *(_DWORD **)(v21 + 8);
          }

          else
          {
            uint64_t v30 = 0LL;
          }

          uint64_t v31 = &v30[4 * v26];
          *(_DWORD *)uint64_t v31 = -1;
          uint64_t v24 = v31 + 4;
          while (v23 != v25)
          {
            int v32 = *--v23;
            *((_DWORD *)v31 - 1) = v32;
            v31 -= 4;
          }

          *(void *)uint64_t v21 = v31;
          *(void *)(v21 + _Block_object_dispose(va, 8) = v24;
          *(void *)(v21 + 16) = &v30[4 * v29];
          if (v25) {
            operator delete(v25);
          }
        }

        else
        {
          *unint64_t v23 = -1;
          uint64_t v24 = v23 + 1;
        }

        *(void *)(v21 + _Block_object_dispose(va, 8) = v24;
      }

      uint64_t v33 = a1[1];
      if (v33)
      {
        char v67 = 0;
        sub_10002BFAC(v33, &v67);
      }

      uint64_t v34 = a1[2];
      char v66 = 0;
      sub_10002BFAC(v34, &v66);
      uint64_t v35 = a1[7];
      uint64_t v36 = *(_DWORD **)(v35 + 8);
      unint64_t v37 = *(void *)(v35 + 16);
      if ((unint64_t)v36 >= v37)
      {
        unsigned __int8 v39 = *(_DWORD **)v35;
        uint64_t v40 = ((uint64_t)v36 - *(void *)v35) >> 2;
        unint64_t v41 = v40 + 1;
        uint64_t v42 = v37 - (void)v39;
        if (v42 >> 1 > v41) {
          unint64_t v41 = v42 >> 1;
        }
        else {
          unint64_t v43 = v41;
        }
        if (v43)
        {
          uint64_t v44 = (char *)sub_10002C050(v35 + 16, v43);
          unsigned __int8 v39 = *(_DWORD **)v35;
          uint64_t v36 = *(_DWORD **)(v35 + 8);
        }

        else
        {
          uint64_t v44 = 0LL;
        }

        uint64_t v45 = &v44[4 * v40];
        *(_DWORD *)uint64_t v45 = -1;
        uint64_t v38 = v45 + 4;
        while (v36 != v39)
        {
          int v46 = *--v36;
          *((_DWORD *)v45 - 1) = v46;
          v45 -= 4;
        }

        *(void *)uint64_t v35 = v45;
        *(void *)(v35 + _Block_object_dispose(va, 8) = v38;
        *(void *)(v35 + 16) = &v44[4 * v43];
        if (v39) {
          operator delete(v39);
        }
      }

      else
      {
        *uint64_t v36 = -1;
        uint64_t v38 = v36 + 1;
      }

      *(void *)(v35 + _Block_object_dispose(va, 8) = v38;
      uint64_t v47 = a1[8];
      uint64_t v48 = *(_DWORD **)(v47 + 8);
      unint64_t v49 = *(void *)(v47 + 16);
      if ((unint64_t)v48 >= v49)
      {
        uint64_t v51 = *(_DWORD **)v47;
        uint64_t v52 = ((uint64_t)v48 - *(void *)v47) >> 2;
        unint64_t v53 = v52 + 1;
        if ((unint64_t)(v52 + 1) >> 62) {
LABEL_78:
        }
          sub_100018774();
        uint64_t v54 = v49 - (void)v51;
        if (v54 >> 1 > v53) {
          unint64_t v53 = v54 >> 1;
        }
        else {
          unint64_t v55 = v53;
        }
        if (v55)
        {
          std::string v56 = (char *)sub_10002C050(v47 + 16, v55);
          uint64_t v51 = *(_DWORD **)v47;
          uint64_t v48 = *(_DWORD **)(v47 + 8);
        }

        else
        {
          std::string v56 = 0LL;
        }

        int v57 = &v56[4 * v52];
        *(_DWORD *)int v57 = -1;
        int v50 = v57 + 4;
        while (v48 != v51)
        {
          int v58 = *--v48;
          *((_DWORD *)v57 - 1) = v58;
          v57 -= 4;
        }

        *(void *)uint64_t v47 = v57;
        *(void *)(v47 + _Block_object_dispose(va, 8) = v50;
        *(void *)(v47 + 16) = &v56[4 * v55];
        if (v51) {
          operator delete(v51);
        }
      }

      else
      {
        *uint64_t v48 = -1;
        int v50 = v48 + 1;
      }

      *(void *)(v47 + _Block_object_dispose(va, 8) = v50;
      uint64_t v59 = a1[9];
      char v65 = 0;
      sub_10002BFAC(v59, &v65);
      uint64_t v20 = *(void *)a1[7];
    }

    while (v19 >= (*(void *)(a1[7] + 8) - v20) >> 2);
  }

  *(_DWORD *)(v20 + 4 * v19) = *((_DWORD *)a1 + 11);
  __int128 v60 = (void *)a1[9];
  *(_DWORD *)(*(void *)a1[8] + 4 * v19) = *((_DWORD *)a1 + 11);
  unint64_t v61 = v19 >> 6;
  uint64_t v62 = 1LL << v19;
  *(void *)(*v60 + 8 * (v19 >> 6)) |= 1LL << v19;
  int v63 = (void *)a1[1];
  if (*((_DWORD *)a1 + 10) == a3)
  {
    if (v63) {
      *(void *)(*v63 + 8 * v61) |= v62;
    }
  }

  else
  {
    if (v63) {
      *(void *)(*v63 + 8 * v61) &= ~v62;
    }
    *(void *)a1[3] = *(void *)a1[3] & 0xFFFFFCFFFFFFFFFFLL | 0x20000000000LL;
  }

  ++*((_DWORD *)a1 + 11);
  return 1LL;
}

int *sub_10002B410(uint64_t a1, int a2, int a3)
{
  (*(void (**)(uint64_t *__return_ptr))(**(void **)(a1 + 32) + 24LL))(&v25);
  uint64_t result = sub_10002ADB0();
  int v26 = v25;
  HIDWORD(v25) = *result;
  if (*(_DWORD *)(**(void **)(a1 + 56) + 4LL * a2) == *(_DWORD *)(**(void **)(a1 + 64) + 4LL * a2))
  {
    char v7 = 0;
    unint64_t v8 = *(uint64_t **)(a1 + 80);
    uint64_t v9 = *v8;
    uint64_t v10 = v8[1] - *v8;
    uint64_t v11 = **(void **)(a1 + 16);
    unint64_t v12 = (int *)((v10 & 0xFFFFFFFFFFFFFFFCLL) + v9 - 4);
    do
    {
      unint64_t v13 = *v12--;
      v7 |= *(void *)(v11 + ((v13 >> 3) & 0x1FFFFFFFFFFFFFF8LL)) >> v13;
    }

    while ((_DWORD)v13 != a2);
    unint64_t v14 = *(void **)a1;
    do
    {
      uint64_t v15 = *(void *)(a1 + 80);
      uint64_t v16 = *(void *)(v15 + 8);
      unint64_t v19 = *(int *)(v16 - 4);
      uint64_t v17 = v16 - 4;
      unint64_t v18 = v19;
      if (v14) {
        *(_DWORD *)(*v14 + 4 * v1_Block_object_dispose(va, 8) = *(_DWORD *)(a1 + 48);
      }
      unint64_t v20 = v18 >> 6;
      uint64_t v21 = 1LL << v18;
      if ((v7 & 1) != 0) {
        *(void *)(v11 + 8 * v20) |= v21;
      }
      uint64_t result = **(int ***)(a1 + 72);
      *(void *)&result[2 * v20] &= ~v21;
      *(void *)(v15 + _Block_object_dispose(va, 8) = v17;
    }

    while ((_DWORD)v18 != a2);
    if ((v7 & 1) == 0) {
      **(void **)(a1 + 24) = **(void **)(a1 + 24) & 0xFFFFF3FFFFFFFFFFLL | 0x80000000000LL;
    }
    ++*(_DWORD *)(a1 + 48);
  }

  if (a3 != -1)
  {
    uint64_t v22 = **(void **)(a1 + 16);
    uint64_t v23 = **(void **)(a1 + 64);
    int v24 = *(_DWORD *)(v23 + 4LL * a2);
    if (v24 < *(_DWORD *)(v23 + 4LL * a3)) {
      *(_DWORD *)(v23 + 4LL * a3) = v24;
    }
  }

  return result;
}

uint64_t sub_10002B5F0(uint64_t a1, int a2, uint64_t a3)
{
  unint64_t v3 = *(int *)(a3 + 12);
  int v4 = *(_DWORD *)(**(void **)(a1 + 56) + 4 * v3);
  uint64_t v5 = **(void **)(a1 + 64);
  if (v4 < *(_DWORD *)(v5 + 4LL * a2)) {
    *(_DWORD *)(v5 + 4LL * a2) = v4;
  }
  uint64_t v6 = **(void **)(a1 + 16);
  if (((*(void *)(v6 + ((v3 >> 3) & 0x1FFFFFFFFFFFFFF8LL)) >> v3) & 1) != 0) {
    *(void *)(v6 + (((unint64_t)a2 >> 3) & 0x1FFFFFFFFFFFFFF8LL)) |= 1LL << a2;
  }
  char v7 = *(unint64_t **)(a1 + 24);
  unint64_t v8 = *v7 & 0xFFFFFFF3FFFFFFFFLL | 0x400000000LL;
  *char v7 = v8;
  if ((_DWORD)v3 == *(_DWORD *)(a1 + 40)) {
    *char v7 = v8 & 0xFFFFFFC7FFFFFFFFLL | 0x1000000000LL;
  }
  return 1LL;
}

uint64_t sub_10002B684(void **a1, int a2, uint64_t a3)
{
  unint64_t v3 = *(int *)(a3 + 12);
  uint64_t v4 = *a1[7];
  int v5 = *(_DWORD *)(v4 + 4 * v3);
  if (v5 >= *(_DWORD *)(v4 + 4LL * a2))
  {
    unint64_t v6 = v3 >> 6;
    uint64_t v7 = 1LL << v3;
  }

  else
  {
    unint64_t v6 = v3 >> 6;
    uint64_t v7 = 1LL << v3;
    if ((*(void *)(*a1[9] + 8 * v6) & v7) != 0)
    {
      uint64_t v8 = *a1[8];
      if (v5 < *(_DWORD *)(v8 + 4LL * a2)) {
        *(_DWORD *)(v8 + 4LL * a2) = v5;
      }
    }
  }

  uint64_t v9 = *a1[2];
  if ((*(void *)(v9 + 8 * v6) & v7) != 0) {
    *(void *)(v9 + (((unint64_t)a2 >> 3) & 0x1FFFFFFFFFFFFFF8LL)) |= 1LL << a2;
  }
  return 1LL;
}

void *sub_10002B724(void *a1)
{
  *a1 = off_1000D0BA0;
  a1[1] = off_1000D0BC8;
  sub_10002B998(a1 + 4);
  return a1;
}

void sub_10002B764(void ***a1, void **a2)
{
  uint64_t v2 = *a1;
  *a1 = a2;
  if (v2)
  {
    if (*v2) {
      operator delete(*v2);
    }
    operator delete(v2);
  }

void sub_10002B7A4(int a1, void **__p)
{
  if (__p)
  {
    unint64_t v3 = *__p;
    if (*__p)
    {
      __p[1] = v3;
      operator delete(v3);
    }

    operator delete(__p);
  }

void sub_10002B7DC(uint64_t *a1)
{
  *a1 = (uint64_t)off_1000D0BA0;
  a1[1] = (uint64_t)off_1000D0BC8;
  sub_10002B998(a1 + 4);
  operator delete(a1);
}

uint64_t sub_10002B81C()
{
  return 48LL;
}

void *sub_10002B824(void *a1)
{
  *a1 = off_1000D0BA0;
  a1[1] = off_1000D0BC8;
  sub_10002B998(a1 + 4);
  return a1;
}

void sub_10002B864(uint64_t *a1)
{
  *a1 = (uint64_t)off_1000D0BA0;
  a1[1] = (uint64_t)off_1000D0BC8;
  sub_10002B998(a1 + 4);
  operator delete(a1);
}

void *sub_10002B8A4(void *a1, uint64_t a2)
{
  *a1 = off_1000D0BC8;
  a1[1] = 56 * a2;
  unint64_t v3 = a1 + 3;
  a1[2] = 0LL;
  a1[3] = a1 + 3;
  a1[4] = a1 + 3;
  a1[5] = 0LL;
  uint64_t v4 = operator new[](56 * a2);
  int v5 = operator new(0x18uLL);
  v5[1] = v3;
  _OWORD v5[2] = v4;
  void *v5 = v3;
  a1[3] = v5;
  a1[4] = v5;
  a1[5] = 1LL;
  return a1;
}

void sub_10002B914(_Unwind_Exception *a1)
{
}

void *sub_10002B928(void *a1)
{
  *a1 = off_1000D0BC8;
  sub_10002B998(a1 + 3);
  return a1;
}

void sub_10002B95C(uint64_t *a1)
{
  *a1 = (uint64_t)off_1000D0BC8;
  sub_10002B998(a1 + 3);
  operator delete(a1);
}

uint64_t sub_10002B990()
{
  return 56LL;
}

void sub_10002B998(uint64_t *a1)
{
  if (a1[2])
  {
    uint64_t v3 = *a1;
    uint64_t v2 = (uint64_t *)a1[1];
    uint64_t v4 = *v2;
    *(void *)(v4 + _Block_object_dispose(va, 8) = *(void *)(*a1 + 8);
    **(void **)(v3 + _Block_object_dispose(va, 8) = v4;
    a1[2] = 0LL;
    while (v2 != a1)
    {
      int v5 = (uint64_t *)v2[1];
      sub_10002B9F8((int)a1, v2);
      uint64_t v2 = v5;
    }
  }

void sub_10002B9F8(int a1, void *__p)
{
  uint64_t v3 = (void *)__p[2];
  __p[2] = 0LL;
  if (v3) {
    operator delete[](v3);
  }
  operator delete(__p);
}

void sub_10002BA28(void *a1, unint64_t a2, _BYTE *a3)
{
  unint64_t v4 = a2;
  uint64_t v7 = (_BYTE *)a1[1];
  uint64_t v6 = a1[2];
  if (v6 - (uint64_t)v7 >= a2)
  {
    if (a2)
    {
      unint64_t v13 = &v7[a2];
      do
      {
        *v7++ = *a3;
        --v4;
      }

      while (v4);
      uint64_t v7 = v13;
    }

    a1[1] = v7;
  }

  else
  {
    uint64_t v8 = &v7[-*a1];
    unint64_t v9 = (unint64_t)&v8[a2];
    unint64_t v10 = v6 - *a1;
    if (2 * v10 > v9) {
      unint64_t v9 = 2 * v10;
    }
    if (v10 >= 0x3FFFFFFFFFFFFFFFLL) {
      size_t v11 = 0x7FFFFFFFFFFFFFFFLL;
    }
    else {
      size_t v11 = v9;
    }
    if (v11) {
      unint64_t v12 = operator new(v11);
    }
    else {
      unint64_t v12 = 0LL;
    }
    unint64_t v14 = &v8[(void)v12];
    uint64_t v15 = &v8[(void)v12 + v4];
    uint64_t v16 = &v8[(void)v12];
    do
    {
      *v16++ = *a3;
      --v4;
    }

    while (v4);
    uint64_t v17 = (_BYTE *)*a1;
    if (v7 != (_BYTE *)*a1)
    {
      do
      {
        char v18 = *--v7;
        *--unint64_t v14 = v18;
      }

      while (v7 != v17);
      uint64_t v7 = (_BYTE *)*a1;
    }

    *a1 = v14;
    a1[1] = v15;
    a1[2] = (char *)v12 + v11;
    if (v7) {
      operator delete(v7);
    }
  }

void sub_10002BB40(void *a1, void *a2)
{
  uint64_t v4 = a1[2];
  uint64_t v5 = a1[1];
  if (v4 == v5) {
    uint64_t v6 = 0LL;
  }
  else {
    uint64_t v6 = ((v4 - v5) << 6) - 1;
  }
  uint64_t v7 = a1[5];
  unint64_t v8 = v7 + a1[4];
  if (v6 == v8)
  {
    sub_10002BBC4(a1);
    uint64_t v5 = a1[1];
    uint64_t v7 = a1[5];
    unint64_t v8 = a1[4] + v7;
  }

  *(void *)(*(void *)(v5 + ((v8 >> 6) & 0x3FFFFFFFFFFFFF8LL)) + 8 * (v8 & 0x1FF)) = *a2;
  a1[5] = v7 + 1;
}

void sub_10002BBC4(void *a1)
{
  unint64_t v2 = a1[4];
  BOOL v3 = v2 >= 0x200;
  unint64_t v4 = v2 - 512;
  if (v3)
  {
    uint64_t v5 = (uint64_t)(a1 + 3);
    uint64_t v6 = (char *)a1[3];
    a1[4] = v4;
    uint64_t v7 = (void *)a1[1];
    unint64_t v8 = (char *)a1[2];
    uint64_t v11 = *v7;
    unint64_t v9 = (char *)(v7 + 1);
    uint64_t v10 = v11;
    a1[1] = v9;
    if (v8 != v6)
    {
LABEL_33:
      *(void *)unint64_t v8 = v10;
      a1[2] += 8LL;
      return;
    }

    uint64_t v12 = (uint64_t)&v9[-*a1];
    if ((unint64_t)v9 <= *a1)
    {
      else {
        unint64_t v33 = (uint64_t)&v8[-*a1] >> 2;
      }
      uint64_t v34 = (char *)sub_100018788(v5, v33);
      uint64_t v35 = &v34[8 * (v33 >> 2)];
      unint64_t v37 = &v34[8 * v36];
      uint64_t v38 = (uint64_t *)a1[1];
      unint64_t v8 = v35;
      uint64_t v39 = a1[2] - (void)v38;
      if (v39)
      {
        unint64_t v8 = &v35[v39 & 0xFFFFFFFFFFFFFFF8LL];
        uint64_t v40 = 8 * (v39 >> 3);
        unint64_t v41 = &v34[8 * (v33 >> 2)];
        do
        {
          uint64_t v42 = *v38++;
          *(void *)unint64_t v41 = v42;
          v41 += 8;
          v40 -= 8LL;
        }

        while (v40);
      }

      goto LABEL_30;
    }

void sub_10002BE8C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

char *sub_10002BED8(void *a1, uint64_t a2)
{
  unint64_t v2 = a1;
  uint64_t v3 = 56 * a2;
  size_t v4 = a1[1];
  if (224 * a2 <= v4)
  {
    uint64_t v9 = v2[2];
    if (v9 + v3 <= v4)
    {
      uint64_t v10 = *(char **)(v2[4] + 16LL);
    }

    else
    {
      uint64_t v10 = (char *)operator new[](v4);
      v2[2] = 0LL;
      uint64_t v11 = operator new(0x18uLL);
      uint64_t v9 = 0LL;
      uint64_t v12 = (void *)v2[4];
      uint64_t v13 = v2[5];
      *uint64_t v11 = v2 + 3;
      v11[1] = v12;
      v11[2] = v10;
      *uint64_t v12 = v11;
      v2[4] = v11;
      v2[5] = v13 + 1;
    }

    uint64_t v5 = &v10[v9];
    uint64_t v8 = v9 + v3;
  }

  else
  {
    uint64_t v5 = (char *)operator new[](56 * a2);
    uint64_t v6 = operator new(0x18uLL);
    uint64_t v7 = v2[3];
    v2 += 3;
    v6[1] = v2;
    v6[2] = v5;
    void *v6 = v7;
    *(void *)(v7 + _Block_object_dispose(va, 8) = v6;
    void *v2 = v6;
    uint64_t v8 = v2[2] + 1LL;
  }

  v2[2] = v8;
  return v5;
}

void sub_10002BFAC(uint64_t a1, _BYTE *a2)
{
  unint64_t v4 = *(void *)(a1 + 8);
  uint64_t v5 = *(void *)(a1 + 16);
  if (v4 == v5 << 6)
  {
    unint64_t v6 = v5 << 7;
    if (v6 <= (v4 & 0xFFFFFFFFFFFFFFC0LL) + 64) {
      unint64_t v6 = (v4 & 0xFFFFFFFFFFFFFFC0LL) + 64;
    }
    if (v4 <= 0x3FFFFFFFFFFFFFFELL) {
      unint64_t v7 = v6;
    }
    else {
      unint64_t v7 = 0x7FFFFFFFFFFFFFFFLL;
    }
    sub_10002C084((char **)a1, v7);
    unint64_t v4 = *(void *)(a1 + 8);
  }

  *(void *)(a1 + _Block_object_dispose(va, 8) = v4 + 1;
  uint64_t v8 = *(char **)a1;
  unint64_t v9 = v4 >> 6;
  uint64_t v10 = 1LL << v4;
  if (*a2) {
    uint64_t v11 = *(void *)&v8[8 * v9] | v10;
  }
  else {
    uint64_t v11 = *(void *)&v8[8 * v9] & ~v10;
  }
  *(void *)&v8[8 * v9] = v11;
}

void *sub_10002C050(uint64_t a1, unint64_t a2)
{
  if (a2 >> 62) {
    sub_100017F08();
  }
  return operator new(4 * a2);
}

void sub_10002C084(char **a1, unint64_t a2)
{
  if (a2 > (void)a1[2] << 6)
  {
    if ((a2 & 0x8000000000000000LL) != 0) {
      sub_100018774();
    }
    uint64_t v10 = 0LL;
    __int128 v11 = 0uLL;
    sub_10002C140(&v10, a2);
    unint64_t v3 = (unint64_t)a1[1];
    uint64_t v8 = *a1;
    int v9 = 0;
    unint64_t v6 = &v8[8 * (v3 >> 6)];
    int v7 = v3 & 0x3F;
    sub_10005C108(&v10, (uint64_t)&v8, (uint64_t)&v6, v3);
    unint64_t v4 = *a1;
    *a1 = v10;
    uint64_t v10 = v4;
    __int128 v5 = *(_OWORD *)(a1 + 1);
    *(_OWORD *)(a1 + 1) = v11;
    __int128 v11 = v5;
    if (v4) {
      operator delete(v4);
    }
  }

void sub_10002C128( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void *sub_10002C140(void *a1, uint64_t a2)
{
  if (a2 < 0) {
    sub_100018774();
  }
  uint64_t result = sub_100018788((uint64_t)(a1 + 2), ((unint64_t)(a2 - 1) >> 6) + 1);
  *a1 = result;
  a1[1] = 0LL;
  a1[2] = v4;
  return result;
}

void sub_10002C184(uint64_t *a1@<X0>, uint64_t *a2@<X1>, uint64_t *a3@<X2>, uint64_t a4@<X8>)
{
  int v5 = *((_DWORD *)a1 + 2);
  uint64_t v6 = *a2;
  int v7 = *((_DWORD *)a2 + 2);
  uint64_t v16 = *a1;
  int v17 = v5;
  uint64_t v14 = v6;
  int v15 = v7;
  int v8 = *((_DWORD *)a3 + 2);
  uint64_t v12 = *a3;
  int v13 = v8;
  sub_10002C210((uint64_t)&v16, (uint64_t)&v14, (uint64_t)&v12, (uint64_t)&v18);
  int v9 = v19;
  uint64_t v10 = v20;
  int v11 = v21;
  *(void *)a4 = v18;
  *(_DWORD *)(a4 + _Block_object_dispose(va, 8) = v9;
  *(void *)(a4 + 16) = v10;
  *(_DWORD *)(a4 + 24) = v11;
}

void sub_10002C210(uint64_t a1@<X1>, uint64_t a2@<X2>, uint64_t a3@<X3>, uint64_t a4@<X8>)
{
  uint64_t v4 = *(void **)a1;
  int v5 = *(_DWORD *)(a1 + 8);
  for (i = *(_DWORD *)(a3 + 8); *(void *)a1 != *(void *)a2 || v5 != *(_DWORD *)(a2 + 8); int v5 = *(_DWORD *)(a1 + 8))
  {
    int v8 = *(uint64_t **)a3;
    uint64_t v9 = 1LL << i;
    if (((*v4 >> v5) & 1) != 0) {
      uint64_t v10 = *v8 | v9;
    }
    else {
      uint64_t v10 = *v8 & ~v9;
    }
    uint64_t *v8 = v10;
    if (v5 == 63)
    {
      int v11 = 0;
      *(void *)a1 = v4 + 1;
    }

    else
    {
      int v11 = v5 + 1;
    }

    *(_DWORD *)(a1 + _Block_object_dispose(va, 8) = v11;
    int v12 = *(_DWORD *)(a3 + 8);
    if (v12 == 63)
    {
      int i = 0;
      *(void *)a3 += 8LL;
    }

    else
    {
      int i = v12 + 1;
    }

    *(_DWORD *)(a3 + _Block_object_dispose(va, 8) = i;
    uint64_t v4 = *(void **)a1;
  }

  *(void *)a4 = v4;
  *(_DWORD *)(a4 + _Block_object_dispose(va, 8) = v5;
  *(void *)(a4 + 16) = *(void *)a3;
  *(_DWORD *)(a4 + 24) = i;
}

uint64_t sub_10002C2E0(void *a1, int a2)
{
  uint64_t v3 = a1[1];
  uint64_t v2 = a1[2];
  if (v2 == v3) {
    uint64_t v4 = 0LL;
  }
  else {
    uint64_t v4 = ((v2 - v3) << 6) - 1;
  }
  unint64_t v5 = v4 - (a1[5] + a1[4]);
  if (v5 < 0x200) {
    a2 = 1;
  }
  if (v5 < 0x400) {
    int v7 = a2;
  }
  else {
    int v7 = 0;
  }
  if ((v7 & 1) == 0)
  {
    operator delete(*(void **)(v2 - 8));
    a1[2] -= 8LL;
  }

  return v7 ^ 1u;
}

uint64_t sub_10002C34C(void *a1)
{
  uint64_t v2 = (void **)a1[1];
  uint64_t v3 = (void **)a1[2];
  a1[5] = 0LL;
  unint64_t v4 = (char *)v3 - (char *)v2;
  if ((unint64_t)((char *)v3 - (char *)v2) >= 0x11)
  {
    do
    {
      operator delete(*v2);
      uint64_t v3 = (void **)a1[2];
      uint64_t v2 = (void **)(a1[1] + 8LL);
      a1[1] = v2;
      unint64_t v4 = (char *)v3 - (char *)v2;
    }

    while ((unint64_t)((char *)v3 - (char *)v2) > 0x10);
  }

  unint64_t v5 = v4 >> 3;
  if (v5 == 1)
  {
    uint64_t v6 = 256LL;
  }

  else
  {
    if (v5 != 2) {
      goto LABEL_9;
    }
    uint64_t v6 = 512LL;
  }

  a1[4] = v6;
LABEL_9:
  while (v2 != v3)
  {
    int v7 = *v2++;
    operator delete(v7);
  }

  return sub_100024EDC((uint64_t)a1);
}

uint64_t sub_10002C3E0(uint64_t a1, uint64_t a2, _BYTE *a3, int a4, std::string *__str, uint64_t a6, uint64_t a7)
{
  if (a3[24])
  {
    std::string::operator=((std::string *)(a7 + 8), __str);
    int v13 = (const std::string *)sub_10002C8FC();
    std::string::operator=((std::string *)(a7 + 32), v13);
    *(_DWORD *)(a7 + 56) = a4;
    *(void *)(a7 + 64) = a6;
    else {
      BOOL v14 = 1;
    }
    int v15 = !v14;
    uint64_t v16 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 104LL))(a1);
    if (a3[26]) {
      BOOL v17 = v16 == 0;
    }
    else {
      BOOL v17 = 1;
    }
    int v18 = v15 | 2;
    if (v17) {
      int v18 = v15;
    }
    if (a3[27]) {
      v18 |= 4u;
    }
    *(_DWORD *)(a7 + 6sub_10001AFB0((std::locale *)v24, " +$", 0) = v18;
    sub_1000A3E5C(a7, a2);
  }

  else {
    BOOL v19 = 1;
  }
  if (!v19)
  {
    uint64_t v20 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 96LL))(a1);
    (*(void (**)(uint64_t, uint64_t))(*(void *)v20 + 144LL))(v20, a2);
  }

  uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 104LL))(a1);
  if (result) {
    BOOL v22 = a3[26] == 0;
  }
  else {
    BOOL v22 = 1;
  }
  if (!v22)
  {
    uint64_t v23 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 104LL))(a1);
    return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v23 + 144LL))(v23, a2);
  }

  return result;
}

uint64_t sub_10002C544( uint64_t a1, void *a2, uint64_t a3, int a4, std::string *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v16 = (char *)a2 + *(void *)(*a2 - 24LL);
  if ((v16[32] & 5) == 0)
  {
    uint64_t v17 = *((void *)v16 + 5);
    __int128 v34 = 0u;
    __int128 v35 = 0u;
    __int128 v32 = 0u;
    __int128 v33 = 0u;
    __int128 v30 = 0u;
    __int128 v31 = 0u;
    __int128 __p = 0u;
    __int128 v29 = 0u;
    uint64_t v36 = a8;
    (*(void (**)(void *__return_ptr, uint64_t, __int128 *, uint64_t))(*(void *)v17 + 40LL))( v27,  v17,  &__p,  16LL);
    if (v27[16] == -1LL) {
      std::ios_base::clear( (std::ios_base *)((char *)a2 + *(void *)(*a2 - 24LL)),  *(_DWORD *)((char *)a2 + *(void *)(*a2 - 24LL) + 32) | 4);
    }
  }

  std::ostream::sentry::~sentry(v26);
  if ((*((_BYTE *)a2 + *(void *)(*a2 - 24LL) + 32) & 5) != 0)
  {
    sub_10000A2DC(&__p, "ERROR");
    sub_10002A9EC((BOOL *)v27, (uint64_t)&__p);
    int v18 = sub_10002A6A4(&std::cerr, (uint64_t)"Fst::UpdateFstHeader: Write failed: ", 36LL);
    int v19 = *(char *)(a3 + 23);
    if (v19 >= 0) {
      uint64_t v20 = a3;
    }
    else {
      uint64_t v20 = *(void *)a3;
    }
    if (v19 >= 0) {
      uint64_t v21 = *(unsigned __int8 *)(a3 + 23);
    }
    else {
      uint64_t v21 = *(void *)(a3 + 8);
    }
  }

  else
  {
    sub_10002C3E0(a1, (uint64_t)a2, (_BYTE *)a3, a4, a5, a6, a7);
    if ((*((_BYTE *)a2 + *(void *)(*a2 - 24LL) + 32) & 5) != 0)
    {
      sub_10000A2DC(&__p, "ERROR");
      sub_10002A9EC((BOOL *)v27, (uint64_t)&__p);
      int v18 = sub_10002A6A4(&std::cerr, (uint64_t)"Fst::UpdateFstHeader: Write failed: ", 36LL);
      int v22 = *(char *)(a3 + 23);
      if (v22 >= 0) {
        uint64_t v20 = a3;
      }
      else {
        uint64_t v20 = *(void *)a3;
      }
      if (v22 >= 0) {
        uint64_t v21 = *(unsigned __int8 *)(a3 + 23);
      }
      else {
        uint64_t v21 = *(void *)(a3 + 8);
      }
    }

    else
    {
      std::ostream::sentry::sentry(v27, a2);
      uint64_t v23 = (char *)a2 + *(void *)(*a2 - 24LL);
      if ((v23[32] & 5) == 0)
      {
        (*(void (**)(__int128 *__return_ptr, void, void, uint64_t, uint64_t))(**((void **)v23 + 5) + 32LL))( &__p,  *((void *)v23 + 5),  0LL,  2LL,  16LL);
        if (v36 == -1) {
          std::ios_base::clear( (std::ios_base *)((char *)a2 + *(void *)(*a2 - 24LL)),  *(_DWORD *)((char *)a2 + *(void *)(*a2 - 24LL) + 32) | 4);
        }
      }

      std::ostream::sentry::~sentry(v27);
      if ((*((_BYTE *)a2 + *(void *)(*a2 - 24LL) + 32) & 5) == 0) {
        return 1LL;
      }
      sub_10000A2DC(&__p, "ERROR");
      sub_10002A9EC((BOOL *)v27, (uint64_t)&__p);
      int v18 = sub_10002A6A4(&std::cerr, (uint64_t)"Fst::UpdateFstHeader: Write failed: ", 36LL);
      int v24 = *(char *)(a3 + 23);
      if (v24 >= 0) {
        uint64_t v20 = a3;
      }
      else {
        uint64_t v20 = *(void *)a3;
      }
      if (v24 >= 0) {
        uint64_t v21 = *(unsigned __int8 *)(a3 + 23);
      }
      else {
        uint64_t v21 = *(void *)(a3 + 8);
      }
    }
  }

  sub_10002A6A4(v18, v20, v21);
  sub_10002AA94(v27);
  if (SBYTE7(v29) < 0) {
    operator delete((void *)__p);
  }
  return 0LL;
}

void sub_10002C854( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, char a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, void *__p, uint64_t a30, int a31, __int16 a32, char a33, char a34)
{
}

uint64_t sub_10002C8BC(uint64_t a1)
{
  return a1;
}

uint64_t sub_10002C8FC()
{
  unsigned __int8 v0 = atomic_load((unsigned __int8 *)&qword_1000DD380);
  if ((v0 & 1) == 0 && __cxa_guard_acquire(&qword_1000DD380))
  {
    uint64_t v2 = operator new(0x18uLL);
    uint64_t v3 = (void *)sub_10002C9D8();
    if (sub_100028A14(v3, "tropical"))
    {
      sub_10000A2DC(v2, "standard");
    }

    else
    {
      uint64_t v4 = sub_10002C9D8();
      if (*(char *)(v4 + 23) < 0)
      {
        sub_10005AA70(v2, *(void **)v4, *(void *)(v4 + 8));
      }

      else
      {
        __int128 v5 = *(_OWORD *)v4;
        v2[2] = *(void *)(v4 + 16);
        *(_OWORD *)uint64_t v2 = v5;
      }
    }

    qword_1000DD378 = (uint64_t)v2;
    __cxa_guard_release(&qword_1000DD380);
  }

  return qword_1000DD378;
}

void sub_10002C9B0(_Unwind_Exception *a1)
{
}

uint64_t sub_10002C9D8()
{
  unsigned __int8 v0 = atomic_load((unsigned __int8 *)&qword_1000DD390);
  if ((v0 & 1) == 0 && __cxa_guard_acquire(&qword_1000DD390))
  {
    uint64_t v2 = operator new(0x18uLL);
    sub_10000A2DC(&v5, "tropical");
    uint64_t v3 = std::string::append(&v5, "");
    __int128 v4 = *(_OWORD *)&v3->__r_.__value_.__l.__data_;
    v2[2] = v3->__r_.__value_.__l.__cap_;
    *(_OWORD *)uint64_t v2 = v4;
    v3->__r_.__value_.__l.__size_ = 0LL;
    v3->__r_.__value_.__l.__cap_ = 0LL;
    v3->__r_.__value_.__r.__words[0] = 0LL;
    qword_1000DD388 = (uint64_t)v2;
    __cxa_guard_release(&qword_1000DD390);
  }

  return qword_1000DD388;
}

void sub_10002CA88( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  operator delete(v15);
  __cxa_guard_abort(&qword_1000DD390);
  _Unwind_Resume(a1);
}

uint64_t sub_10002CAC8(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(unsigned __int8 *)(a2 + 23);
  if ((v3 & 0x80u) != 0LL) {
    uint64_t v3 = *(void *)(a2 + 8);
  }
  if (v3)
  {
    sub_10002CE18((void (__cdecl ***)(std::ofstream *__hidden))__p, (uint64_t *)a2, 20);
    if ((v29[*((void *)__p[0] - 3)] & 5) != 0)
    {
      sub_10000A2DC(v16, "ERROR");
      sub_10002A9EC(&v22, (uint64_t)v16);
      std::string v5 = sub_10002A6A4(&std::cerr, (uint64_t)"Fst::Write: Can't open file: ", 29LL);
      int v6 = *(char *)(a2 + 23);
      if (v6 >= 0) {
        uint64_t v7 = a2;
      }
      else {
        uint64_t v7 = *(void *)a2;
      }
      if (v6 >= 0) {
        uint64_t v8 = *(unsigned __int8 *)(a2 + 23);
      }
      else {
        uint64_t v8 = *(void *)(a2 + 8);
      }
      goto LABEL_31;
    }

    char v10 = byte_1000DE7EF;
    if (*(char *)(a2 + 23) < 0)
    {
      sub_10005AA70(v16, *(void **)a2, *(void *)(a2 + 8));
    }

    else
    {
      *(_OWORD *)uint64_t v16 = *(_OWORD *)a2;
      uint64_t v17 = *(void *)(a2 + 16);
    }

    __int16 v18 = 257;
    char v19 = 1;
    char v20 = v10;
    char v21 = 0;
    char v12 = (*(uint64_t (**)(uint64_t, void **, void **))(*(void *)a1 + 80LL))(a1, __p, v16);
    char v13 = v12;
    if (SHIBYTE(v17) < 0)
    {
      operator delete(v16[0]);
      if ((v13 & 1) != 0) {
        goto LABEL_23;
      }
    }

    else if ((v12 & 1) != 0)
    {
LABEL_23:
      uint64_t v11 = 1LL;
LABEL_34:
      std::filebuf::~filebuf(&__p[1]);
      std::ios::~ios(&v30);
      return v11;
    }

    sub_10000A2DC(v16, "ERROR");
    sub_10002A9EC(&v22, (uint64_t)v16);
    std::string v5 = sub_10002A6A4(&std::cerr, (uint64_t)"Fst::Write failed: ", 19LL);
    int v14 = *(char *)(a2 + 23);
    if (v14 >= 0) {
      uint64_t v7 = a2;
    }
    else {
      uint64_t v7 = *(void *)a2;
    }
    if (v14 >= 0) {
      uint64_t v8 = *(unsigned __int8 *)(a2 + 23);
    }
    else {
      uint64_t v8 = *(void *)(a2 + 8);
    }
LABEL_31:
    sub_10002A6A4(v5, v7, v8);
    sub_10002AA94(&v22);
    if (SHIBYTE(v17) < 0) {
      operator delete(v16[0]);
    }
    uint64_t v11 = 0LL;
    goto LABEL_34;
  }

  sub_10000A2DC(v16, "standard output");
  char v9 = byte_1000DE7EF;
  if (SHIBYTE(v17) < 0)
  {
    sub_10005AA70(__p, v16[0], (unint64_t)v16[1]);
  }

  else
  {
    *(_OWORD *)__int128 __p = *(_OWORD *)v16;
    uint64_t v24 = v17;
  }

  __int16 v25 = 257;
  char v26 = 1;
  char v27 = v9;
  char v28 = 0;
  uint64_t v11 = (*(uint64_t (**)(uint64_t, std::ostream *, void **))(*(void *)a1 + 80LL))(a1, &std::cout, __p);
  if (SHIBYTE(v24) < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v17) < 0) {
    operator delete(v16[0]);
  }
  return v11;
}

void sub_10002CD90( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, int a17, __int16 a18, char a19, char a20, void *a21, uint64_t a22, int a23, __int16 a24, char a25, char a26)
{
}

void (__cdecl ***sub_10002CE18( void (__cdecl ***a1)(std::ofstream *__hidden this), uint64_t *a2, int a3))(std::ofstream *__hidden this)
{
  int v6 = a1 + 1;
  *a1 = v7;
  *(void *)((char *)*(v7 - 3) + (void)a1) = v8;
  char v9 = (std::ios_base *)((char *)*(*a1 - 3) + (void)a1);
  std::ios_base::init(v9, a1 + 1);
  v9[1].__vftable = 0LL;
  v9[1].__fmtflags_ = -1;
  std::filebuf::basic_filebuf(v6);
  else {
    char v10 = (uint64_t *)*a2;
  }
  if (!std::filebuf::open(v6, v10, a3 | 0x10u)) {
    std::ios_base::clear( (std::ios_base *)((char *)*(*a1 - 3) + (void)a1),  *(_DWORD *)((char *)*(*a1 - 3) + (void)a1 + 32) | 4);
  }
  return a1;
}

void sub_10002CEF4(_Unwind_Exception *a1)
{
}

void *sub_10002CF2C(void *a1)
{
  return a1;
}

void *sub_10002CF84(void *a1, uint64_t *a2)
{
  uint64_t v4 = *a2;
  uint64_t v3 = a2[1];
  if (v3)
  {
    std::string v5 = (unint64_t *)(v3 + 8);
    do
      unint64_t v6 = __ldxr(v5);
    while (__stxr(v6 + 1, v5));
  }

  uint64_t v7 = (std::__shared_weak_count *)a1[1];
  *a1 = v4;
  a1[1] = v3;
  if (v7)
  {
    p_shared_owners = (unint64_t *)&v7->__shared_owners_;
    do
      unint64_t v9 = __ldaxr(p_shared_owners);
    while (__stlxr(v9 - 1, p_shared_owners));
    if (!v9)
    {
      ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
      std::__shared_weak_count::__release_weak(v7);
    }
  }

  return a1;
}

void *sub_10002CFFC@<X0>(uint64_t a1@<X1>, void *a2@<X8>)
{
  uint64_t v4 = operator new(0x70uLL);
  uint64_t result = sub_10002D054(v4, a1);
  *a2 = v4 + 3;
  a2[1] = v4;
  return result;
}

void sub_10002D040(_Unwind_Exception *a1)
{
}

void *sub_10002D054(void *a1, uint64_t a2)
{
  a1[2] = 0LL;
  *a1 = off_1000D0BF0;
  a1[1] = 0LL;
  sub_10005C920((uint64_t)(a1 + 3), a2);
  return a1;
}

void sub_10002D08C(_Unwind_Exception *a1)
{
}

void sub_10002D0A0(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_1000D0BF0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_10002D0B4(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_1000D0BF0;
  std::__shared_weak_count::~__shared_weak_count(a1);
  operator delete(v1);
}

uint64_t sub_10002D0D8(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 24))(a1 + 24);
}

uint64_t sub_10002D0E8(void *a1)
{
  uint64_t v2 = (char *)operator new(0x30uLL);
  uint64_t v3 = sub_10002ADB0();
  unint64_t v4 = a1[9];
  *(_DWORD *)uint64_t v2 = *v3;
  *((void *)v2 + 5) = 0LL;
  *(_OWORD *)(v2 + 24) = 0u;
  *(_OWORD *)(v2 + std::ostream::~ostream(v1, v2 + 8) = 0u;
  std::string v5 = (void *)a1[8];
  if ((unint64_t)v5 >= v4)
  {
    uint64_t v7 = a1[7];
    uint64_t v8 = ((uint64_t)v5 - v7) >> 3;
    uint64_t v9 = v4 - v7;
    uint64_t v10 = v9 >> 2;
    else {
      unint64_t v11 = v10;
    }
    if (v11) {
      char v12 = (char *)sub_100018788((uint64_t)(a1 + 9), v11);
    }
    else {
      char v12 = 0LL;
    }
    char v13 = &v12[8 * v8];
    int v14 = &v12[8 * v11];
    *(void *)char v13 = v2;
    unint64_t v6 = v13 + 8;
    uint64_t v16 = (char *)a1[7];
    int v15 = (char *)a1[8];
    if (v15 != v16)
    {
      do
      {
        uint64_t v17 = *((void *)v15 - 1);
        v15 -= 8;
        *((void *)v13 - 1) = v17;
        v13 -= 8;
      }

      while (v15 != v16);
      int v15 = (char *)a1[7];
    }

    a1[7] = v13;
    a1[8] = v6;
    a1[9] = v14;
    if (v15) {
      operator delete(v15);
    }
  }

  else
  {
    void *v5 = v2;
    unint64_t v6 = v5 + 1;
  }

  a1[8] = v6;
  return (((unint64_t)v6 - a1[7]) >> 3) - 1;
}

uint64_t sub_10002D1FC(void *a1)
{
  *a1 = off_1000D0588;
  uint64_t v2 = (void **)a1[8];
  if (v2 != (void **)a1[7])
  {
    unint64_t v3 = 0LL;
    uint64_t v2 = (void **)a1[7];
    do
    {
      sub_10002D6DC(v2[v3++]);
      uint64_t v2 = (void **)a1[7];
    }

    while (v3 < (uint64_t)(a1[8] - (void)v2) >> 3);
  }

  if (v2)
  {
    a1[8] = v2;
    operator delete(v2);
  }

  return sub_10002D2D8((uint64_t)a1);
}

void sub_10002D280(void *a1)
{
  uint64_t v1 = (void *)sub_10002D1FC(a1);
  operator delete(v1);
}

uint64_t sub_10002D294(uint64_t a1)
{
  return *(void *)(a1 + 8);
}

uint64_t sub_10002D29C(uint64_t a1, uint64_t a2)
{
  return *(void *)(a1 + 8) & a2;
}

void sub_10002D2AC(void *a1)
{
  uint64_t v1 = (void *)sub_10002D1FC(a1);
  operator delete(v1);
}

void sub_10002D2C4(uint64_t a1)
{
  uint64_t v1 = (void *)sub_10002D2D8(a1);
  operator delete(v1);
}

uint64_t sub_10002D2D8(uint64_t a1)
{
  *(void *)a1 = off_1000D05B8;
  uint64_t v2 = *(void *)(a1 + 48);
  *(void *)(a1 + 4std::ostream::~ostream(v1, v2 + 8) = 0LL;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8LL))(v2);
  }
  uint64_t v3 = *(void *)(a1 + 40);
  *(void *)(a1 + 4sub_10001AFB0((std::locale *)v24, " +$", 0) = 0LL;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8LL))(v3);
  }
  return a1;
}

void sub_10002D348(void **a1, unint64_t a2)
{
  unint64_t v4 = a1[2];
  uint64_t v3 = (uint64_t)(a1 + 2);
  if (a2 > (v4 - (_BYTE *)*a1) >> 3)
  {
    if (a2 >> 61) {
      sub_100018774();
    }
    int64_t v5 = (_BYTE *)a1[1] - (_BYTE *)*a1;
    unint64_t v6 = (char *)sub_100018788(v3, a2);
    uint64_t v7 = &v6[v5 & 0xFFFFFFFFFFFFFFF8LL];
    uint64_t v9 = &v6[8 * v8];
    unint64_t v11 = (char *)*a1;
    uint64_t v10 = (char *)a1[1];
    char v12 = v7;
    if (v10 != *a1)
    {
      do
      {
        uint64_t v13 = *((void *)v10 - 1);
        v10 -= 8;
        *((void *)v12 - 1) = v13;
        v12 -= 8;
      }

      while (v10 != v11);
      uint64_t v10 = (char *)*a1;
    }

    *a1 = v12;
    a1[1] = v7;
    a1[2] = v9;
    if (v10) {
      operator delete(v10);
    }
  }

void sub_10002D3DC(uint64_t *a1, unint64_t a2)
{
  uint64_t v4 = a1[2];
  uint64_t v3 = (uint64_t)(a1 + 2);
  if (a2 > (v4 - *a1) >> 4)
  {
    if (a2 >> 60) {
      sub_100018774();
    }
    uint64_t v5 = a1[1] - *a1;
    uint64_t v11 = v3;
    __int128 __p = sub_1000198A8(v3, a2);
    uint64_t v8 = (char *)__p + v5;
    uint64_t v9 = (char *)__p + v5;
    uint64_t v10 = (char *)__p + 16 * v6;
    sub_10002D4B4(a1, &__p);
    if (v9 != v8) {
      v9 += (v8 - v9 + 15) & 0xFFFFFFFFFFFFFFF0LL;
    }
    if (__p) {
      operator delete(__p);
    }
  }

void sub_10002D47C( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t *sub_10002D4B4(uint64_t *result, void *a2)
{
  uint64_t v3 = *result;
  uint64_t v2 = result[1];
  uint64_t v4 = a2[1];
  if (v2 != *result)
  {
    uint64_t v5 = 0LL;
    do
    {
      uint64_t v6 = v4 + v5;
      *(void *)(v6 - 16) = *(void *)(v2 + v5 - 16);
      *(_DWORD *)(v6 - std::ostream::~ostream(v1, v2 + 8) = *(_DWORD *)(v2 + v5 - 8);
      *(_DWORD *)(v6 - 4) = *(_DWORD *)(v2 + v5 - 4);
      v5 -= 16LL;
    }

    while (v2 + v5 != v3);
    v4 += v5;
  }

  a2[1] = v4;
  uint64_t v7 = *result;
  void *result = v4;
  a2[1] = v7;
  uint64_t v8 = result[1];
  result[1] = a2[2];
  a2[2] = v8;
  uint64_t v9 = result[2];
  result[2] = a2[3];
  a2[3] = v9;
  *a2 = a2[1];
  return result;
}

uint64_t sub_10002D538(void *a1, _DWORD *a2)
{
  if (!*a2) {
    ++a1[1];
  }
  if (!a2[1]) {
    ++a1[2];
  }
  unint64_t v3 = a1[4];
  if (v3 >= a1[5])
  {
    uint64_t result = sub_10002D5B4(a1 + 3, (uint64_t)a2);
  }

  else
  {
    *(void *)unint64_t v3 = *(void *)a2;
    *(_DWORD *)(v3 + std::ostream::~ostream(v1, v2 + 8) = a2[2];
    *(_DWORD *)(v3 + 12) = a2[3];
    uint64_t result = v3 + 16;
  }

  a1[4] = result;
  return result;
}

uint64_t sub_10002D5B4(uint64_t *a1, uint64_t a2)
{
  uint64_t v3 = *a1;
  uint64_t v4 = (a1[1] - *a1) >> 4;
  unint64_t v5 = v4 + 1;
  uint64_t v7 = (uint64_t)(a1 + 2);
  uint64_t v8 = a1[2] - v3;
  if (v8 >> 3 > v5) {
    unint64_t v5 = v8 >> 3;
  }
  else {
    unint64_t v9 = v5;
  }
  char v19 = a1 + 2;
  uint64_t v10 = (char *)sub_1000198A8(v7, v9);
  uint64_t v11 = &v10[16 * v4];
  __int128 __p = v10;
  uint64_t v16 = v11;
  __int16 v18 = &v10[16 * v12];
  *(void *)uint64_t v11 = *(void *)a2;
  *((_DWORD *)v11 + 2) = *(_DWORD *)(a2 + 8);
  *((_DWORD *)v11 + 3) = *(_DWORD *)(a2 + 12);
  uint64_t v17 = v11 + 16;
  sub_10002D4B4(a1, &__p);
  uint64_t v13 = a1[1];
  if (v17 != v16) {
    v17 += (v16 - v17 + 15) & 0xFFFFFFFFFFFFFFF0LL;
  }
  if (__p) {
    operator delete(__p);
  }
  return v13;
}

void sub_10002D6A4( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_10002D6DC(void *__p)
{
  if (__p)
  {
    uint64_t v2 = (void *)__p[3];
    if (v2)
    {
      __p[4] = v2;
      operator delete(v2);
    }

    operator delete(__p);
  }

void sub_10002D714(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 16);
  if (!v2 || *(void *)(v2 + 8))
  {
    sub_10002D79C(a1, &v6);
    sub_10002CF84((void *)(a1 + 8), &v6);
    uint64_t v3 = v7;
    if (v7)
    {
      p_shared_owners = (unint64_t *)&v7->__shared_owners_;
      do
        unint64_t v5 = __ldaxr(p_shared_owners);
      while (__stlxr(v5 - 1, p_shared_owners));
      if (!v5)
      {
        ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
        std::__shared_weak_count::__release_weak(v3);
      }
    }
  }

void *sub_10002D79C@<X0>(uint64_t a1@<X1>, void *a2@<X8>)
{
  uint64_t v4 = operator new(0x70uLL);
  uint64_t result = sub_10002D7F4(v4, a1);
  *a2 = v4 + 3;
  a2[1] = v4;
  return result;
}

void sub_10002D7E0(_Unwind_Exception *a1)
{
}

void *sub_10002D7F4(void *a1, uint64_t a2)
{
  a1[2] = 0LL;
  *a1 = off_1000D0BF0;
  a1[1] = 0LL;
  sub_10005C920((uint64_t)(a1 + 3), a2);
  return a1;
}

void sub_10002D82C(_Unwind_Exception *a1)
{
}

float sub_10002D840(void *a1, int a2, float *a3)
{
  int v9 = **(_DWORD **)(a1[7] + 8LL * a2);
  unint64_t v6 = (*(uint64_t (**)(void *))(*a1 + 16LL))(a1);
  uint64_t v7 = sub_10005CD24(v6, (float *)&v9, a3);
  float result = *a3;
  **(float **)(a1[7] + 8LL * a2) = *a3;
  a1[1] = a1[1] & 4LL | v7;
  return result;
}

uint64_t sub_10002D8BC(void *a1, int a2, float *a3)
{
  uint64_t v6 = *(void *)(*(void *)(a1[7] + 8LL * a2) + 32LL);
  if (v6 == *(void *)(*(void *)(a1[7] + 8LL * a2) + 24LL)) {
    uint64_t v7 = 0LL;
  }
  else {
    uint64_t v7 = (_DWORD *)(v6 - 16);
  }
  unint64_t v8 = (*(uint64_t (**)(void *))(*a1 + 16LL))(a1);
  a1[1] = a1[1] & 4LL | sub_10005CE04(v8, a2, a3, v7);
  return sub_10002D538(*(void **)(a1[7] + 8LL * a2), a3);
}

void sub_10002D938(uint64_t a1, char **a2)
{
  uint64_t v4 = (uint64_t *)(a1 + 56);
  unint64_t v5 = (uint64_t)(*(void *)(a1 + 64) - *(void *)(a1 + 56)) >> 3;
  int v35 = 0;
  sub_10002DBF0(__p, v5, &v35);
  uint64_t v6 = *a2;
  uint64_t v7 = a2[1] - *a2;
  if (v7)
  {
    unint64_t v8 = v7 >> 2;
    int v9 = __p[0];
    if (v8 <= 1) {
      unint64_t v8 = 1LL;
    }
    do
    {
      uint64_t v10 = *(int *)v6;
      v6 += 4;
      v9[v10] = -1;
      --v8;
    }

    while (v8);
  }

  uint64_t v11 = *(void *)(a1 + 56);
  if (*(void *)(a1 + 64) == v11)
  {
    int v13 = 0;
  }

  else
  {
    unint64_t v12 = 0LL;
    int v13 = 0;
    do
    {
      if (*((_DWORD *)__p[0] + v12) == -1)
      {
        sub_10002D6DC(*(void **)(v11 + 8 * v12));
      }

      else
      {
        *((_DWORD *)__p[0] + v12) = v13;
        if (v12 != v13) {
          *(void *)(v11 + 8LL * v13) = *(void *)(v11 + 8 * v12);
        }
        ++v13;
      }

      ++v12;
      uint64_t v11 = *(void *)(a1 + 56);
    }

    while (v12 < (*(void *)(a1 + 64) - v11) >> 3);
  }

  sub_10002DB6C((uint64_t)v4, v13);
  uint64_t v14 = *(void *)(a1 + 56);
  if (*(void *)(a1 + 64) != v14)
  {
    unint64_t v15 = 0LL;
    do
    {
      uint64_t v16 = *(void *)(v14 + 8 * v15);
      uint64_t v17 = *(void *)(v16 + 24);
      uint64_t v18 = *(void *)(v16 + 32);
      int64x2_t v19 = *(int64x2_t *)(v16 + 8);
      uint64_t v21 = v18 - v17;
      BOOL v20 = v18 == v17;
      if (v18 == v17) {
        uint64_t v22 = 0LL;
      }
      else {
        uint64_t v22 = *(void *)(v16 + 24);
      }
      if (v20)
      {
        int64x2_t v34 = *(int64x2_t *)(v16 + 8);
        uint64_t v24 = 0LL;
        uint64_t v31 = v21 >> 4;
      }

      else
      {
        unint64_t v23 = 0LL;
        uint64_t v24 = 0LL;
        __int16 v25 = (int *)(v22 + 12);
        do
        {
          int v26 = *((_DWORD *)__p[0] + *v25);
          if (v26 == -1)
          {
            uint64_t v28 = *(void *)(v25 - 3);
            v29.i64[0] = v28;
            v29.i64[1] = HIDWORD(v28);
            int64x2_t v19 = vaddq_s64(v19, vceqzq_s64(v29));
          }

          else
          {
            int *v25 = v26;
            if (v23 != v24)
            {
              uint64_t v27 = v22 + 16 * v24;
              *(void *)uint64_t v27 = *(void *)(v25 - 3);
              *(_DWORD *)(v27 + std::ostream::~ostream(v1, v2 + 8) = *(v25 - 1);
              *(_DWORD *)(v27 + 12) = v26;
              uint64_t v14 = *v4;
            }

            ++v24;
          }

          uint64_t v16 = *(void *)(v14 + 8 * v15);
          ++v23;
          uint64_t v30 = *(void *)(v16 + 32) - *(void *)(v16 + 24);
          v25 += 4;
        }

        while (v23 < v30 >> 4);
        int64x2_t v34 = v19;
        uint64_t v31 = v30 >> 4;
      }

      sub_10002DB9C((void *)v16, v31 - v24);
      uint64_t v14 = *(void *)(a1 + 56);
      *(int64x2_t *)(*(void *)(v14 + 8 * v15++) + 8LL) = v34;
    }

    while (v15 < (*(void *)(a1 + 64) - v14) >> 3);
  }

  uint64_t v32 = *(int *)(a1 + 80);
  if ((_DWORD)v32 == -1)
  {
    __int128 v33 = __p[0];
    if (!__p[0]) {
      return;
    }
  }

  else
  {
    __int128 v33 = __p[0];
    *(_DWORD *)(a1 + 8sub_10001AFB0((std::locale *)v24, " +$", 0) = *((_DWORD *)__p[0] + v32);
  }

  __p[1] = v33;
  operator delete(v33);
}

void sub_10002DB4C( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_10002DB6C(uint64_t a1, unint64_t a2)
{
  unint64_t v2 = (uint64_t)(*(void *)(a1 + 8) - *(void *)a1) >> 3;
  if (a2 <= v2)
  {
    if (a2 < v2) {
      *(void *)(a1 + std::ostream::~ostream(v1, v2 + 8) = *(void *)a1 + 8 * a2;
    }
  }

  else
  {
    sub_10002DCB0((void **)a1, a2 - v2);
  }

void *sub_10002DB9C(void *result, uint64_t a2)
{
  if (a2)
  {
    uint64_t v2 = result[4];
    uint64_t v3 = -16 * a2;
    uint64_t v4 = (_DWORD *)(v2 - 16);
    unint64_t v5 = (_DWORD *)(v2 - 16);
    do
    {
      int v6 = *v5;
      v5 -= 4;
      if (!v6) {
        --result[1];
      }
      if (!v4[1]) {
        --result[2];
      }
      uint64_t v4 = v5;
      --a2;
    }

    while (a2);
    result[4] = v2 + v3;
  }

  return result;
}

void *sub_10002DBF0(void *a1, unint64_t a2, _DWORD *a3)
{
  *a1 = 0LL;
  a1[1] = 0LL;
  a1[2] = 0LL;
  if (a2)
  {
    sub_10002DC70(a1, a2);
    int v6 = (_DWORD *)a1[1];
    uint64_t v7 = &v6[a2];
    uint64_t v8 = 4 * a2;
    do
    {
      *v6++ = *a3;
      v8 -= 4LL;
    }

    while (v8);
    a1[1] = v7;
  }

  return a1;
}

void sub_10002DC54(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + std::ostream::~ostream(v1, v2 + 8) = v3;
    operator delete(v3);
  }

  _Unwind_Resume(exception_object);
}

char *sub_10002DC70(void *a1, unint64_t a2)
{
  if (a2 >> 62) {
    sub_100018774();
  }
  float result = (char *)sub_10002C050((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[4 * v4];
  return result;
}

void sub_10002DCB0(void **a1, unint64_t a2)
{
  int v6 = a1[2];
  uint64_t v4 = (uint64_t)(a1 + 2);
  unint64_t v5 = v6;
  uint64_t v7 = *(char **)(v4 - 8);
  if (a2 <= (v6 - v7) >> 3)
  {
    if (a2)
    {
      bzero(*(void **)(v4 - 8), 8 * a2);
      v7 += 8 * a2;
    }

    a1[1] = v7;
  }

  else
  {
    uint64_t v8 = v7 - (_BYTE *)*a1;
    unint64_t v9 = a2 + (v8 >> 3);
    if (v9 >> 61) {
      sub_100018774();
    }
    uint64_t v10 = v8 >> 3;
    uint64_t v11 = v5 - (_BYTE *)*a1;
    if (v11 >> 2 > v9) {
      unint64_t v9 = v11 >> 2;
    }
    else {
      unint64_t v12 = v9;
    }
    if (v12) {
      int v13 = (char *)sub_100018788(v4, v12);
    }
    else {
      int v13 = 0LL;
    }
    uint64_t v14 = &v13[8 * v10];
    unint64_t v15 = &v13[8 * v12];
    bzero(v14, 8 * a2);
    uint64_t v16 = &v14[8 * a2];
    uint64_t v18 = (char *)*a1;
    uint64_t v17 = (char *)a1[1];
    if (v17 != *a1)
    {
      do
      {
        uint64_t v19 = *((void *)v17 - 1);
        v17 -= 8;
        *((void *)v14 - 1) = v19;
        v14 -= 8;
      }

      while (v17 != v18);
      uint64_t v17 = (char *)*a1;
    }

    *a1 = v14;
    a1[1] = v16;
    a1[2] = v15;
    if (v17) {
      operator delete(v17);
    }
  }

void *sub_10002DDB0@<X0>(void *a1@<X8>)
{
  uint64_t v2 = operator new(0x70uLL);
  float result = sub_10002DDF8(v2);
  *a1 = v2 + 3;
  a1[1] = v2;
  return result;
}

void sub_10002DDE4(_Unwind_Exception *a1)
{
}

void *sub_10002DDF8(void *a1)
{
  a1[2] = 0LL;
  *a1 = off_1000D0BF0;
  a1[1] = 0LL;
  sub_10002DE44((uint64_t)(a1 + 3));
  return a1;
}

void sub_10002DE30(_Unwind_Exception *a1)
{
}

uint64_t sub_10002DE44(uint64_t a1)
{
  *(void *)a1 = off_1000D05B8;
  *(void *)(a1 + std::ostream::~ostream(v1, v2 + 8) = 0LL;
  uint64_t v2 = (std::string *)(a1 + 16);
  sub_10000A2DC((void *)(a1 + 16), "null");
  *(void *)(a1 + 4sub_10001AFB0((std::locale *)v24, " +$", 0) = 0LL;
  *(void *)(a1 + 4std::ostream::~ostream(v1, v2 + 8) = 0LL;
  *(void *)(a1 + 64) = 0LL;
  *(void *)(a1 + 72) = 0LL;
  *(void *)(a1 + 56) = 0LL;
  *(_DWORD *)(a1 + 8sub_10001AFB0((std::locale *)v24, " +$", 0) = -1;
  *(void *)a1 = off_1000D0558;
  sub_10000A2DC(&__str, "vector");
  std::string::operator=(v2, &__str);
  *(void *)(a1 + std::ostream::~ostream(v1, v2 + 8) = *(void *)(a1 + 8) & 4LL | 0x956A5A950003LL;
  return a1;
}

void sub_10002DEFC( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  sub_10002D1FC(v15);
  _Unwind_Resume(a1);
}

void sub_10002DF28(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 64);
  if (v2 != *(void *)(a1 + 56))
  {
    unint64_t v3 = 0LL;
    uint64_t v2 = *(void *)(a1 + 56);
    do
    {
      sub_10002D6DC(*(void **)(v2 + 8 * v3++));
      uint64_t v2 = *(void *)(a1 + 56);
    }

    while (v3 < (*(void *)(a1 + 64) - v2) >> 3);
  }

  *(void *)(a1 + 64) = v2;
  *(_DWORD *)(a1 + 8sub_10001AFB0((std::locale *)v24, " +$", 0) = -1;
}

BOOL sub_10002DF98(uint64_t a1)
{
}

uint64_t sub_10002DFB4(uint64_t a1)
{
  return *(void *)(*(void *)(a1 + 8) + 24LL) + 16LL * *(void *)(a1 + 24);
}

uint64_t sub_10002DFC8(uint64_t result)
{
  return result;
}

uint64_t sub_10002DFD8(uint64_t a1)
{
  return *(void *)(a1 + 24);
}

uint64_t sub_10002DFE0(uint64_t result)
{
  *(void *)(result + ++*(void *)(result + 24) = 0LL;
  return result;
}

uint64_t sub_10002DFE8(uint64_t result, uint64_t a2)
{
  *(void *)(result + ++*(void *)(result + 24) = a2;
  return result;
}

uint64_t sub_10002DFF0()
{
  return 15LL;
}

int *sub_10002DFFC(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a1 + 24);
  uint64_t v5 = *(void *)(*(void *)(a1 + 8) + 24LL);
  int v6 = (int *)(v5 + 16 * v4);
  int v7 = *v6;
  int v8 = v6[1];
  if (v7 != v8) {
    **(void **)(a1 + 16) &= ~0x20000uLL;
  }
  if (v7)
  {
    if (!v8)
    {
      unint64_t v9 = *(unint64_t **)(a1 + 16);
      unint64_t v10 = *v9;
LABEL_8:
      *unint64_t v9 = v10 & 0xFFFFFFFFFBFFFFFFLL;
    }
  }

  else
  {
    unint64_t v9 = *(unint64_t **)(a1 + 16);
    unint64_t v11 = *v9;
    *v9 &= ~0x1000000uLL;
    if (!v8)
    {
      unint64_t v10 = v11 & 0xFFFFFFFFFEBFFFFFLL;
      *unint64_t v9 = v11 & 0xFFFFFFFFFEBFFFFFLL;
      goto LABEL_8;
    }
  }

  uint64_t v12 = v5 + 16 * v4;
  int v13 = sub_10002ADB0();
  float v15 = *(float *)(v12 + 8);
  uint64_t v14 = (float *)(v12 + 8);
  sub_10002E1E0(*(void **)(a1 + 8), a2, *(void *)(a1 + 24));
  int v16 = *(_DWORD *)a2;
  int v17 = *(_DWORD *)(a2 + 4);
  if (*(_DWORD *)a2 != v17) {
    **(void **)(a1 + 16) = **(void **)(a1 + 16) & 0xFFFFFFFFFFFCFFFFLL | 0x20000;
  }
  if (v16)
  {
    if (!v17)
    {
      uint64_t v18 = *(unint64_t **)(a1 + 16);
      unint64_t v19 = *v18;
LABEL_19:
      *uint64_t v18 = v19 & 0xFFFFFFFFF3FFFFFFLL | 0x4000000;
    }
  }

  else
  {
    uint64_t v18 = *(unint64_t **)(a1 + 16);
    unint64_t v20 = *v18 & 0xFFFFFFFFFCFFFFFFLL | 0x1000000;
    *uint64_t v18 = v20;
    if (!v17)
    {
      unint64_t v19 = v20 & 0xFFFFFFFFFD3FFFFFLL | 0x400000;
      *uint64_t v18 = v19;
      goto LABEL_19;
    }
  }

  float result = sub_10002ADB0();
  if (*(float *)(a2 + 8) != *(float *)result)
  {
    float result = sub_10002AD60();
  }

  **(void **)(a1 + 16) &= 0x30FC30007uLL;
  return result;
}

float sub_10002E1E0(void *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = a1[3];
  uint64_t v4 = (_DWORD *)(v3 + 16 * a3);
  if (!*v4) {
    --a1[1];
  }
  if (!v4[1]) {
    --a1[2];
  }
  if (!*(_DWORD *)a2) {
    ++a1[1];
  }
  if (!*(_DWORD *)(a2 + 4)) {
    ++a1[2];
  }
  *(void *)uint64_t v4 = *(void *)a2;
  uint64_t v5 = v3 + 16 * a3;
  float result = *(float *)(a2 + 8);
  *(float *)(v5 + std::ostream::~ostream(v1, v2 + 8) = result;
  *(_DWORD *)(v5 + 12) = *(_DWORD *)(a2 + 12);
  return result;
}

void sub_10002E258(void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = (char *)**a1;
  if (v2)
  {
    uint64_t v4 = (char *)v1[1];
    uint64_t v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        int v6 = v4 - 40;
        int v7 = (void **)(v4 - 24);
        sub_1000180A4(&v7);
        uint64_t v4 = v6;
      }

      while (v6 != v2);
      uint64_t v5 = **a1;
    }

    v1[1] = v2;
    operator delete(v5);
  }

uint64_t sub_10002E2D0(uint64_t *a1, void *a2)
{
  uint64_t result = sub_10002E388((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

void *sub_10002E344(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x666666666666667LL) {
    sub_100017F08();
  }
  return operator new(40 * a2);
}

uint64_t sub_10002E388(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7 = a7;
  *(void *)&__int128 v13 = a6;
  *((void *)&v13 + 1) = a7;
  __int128 v12 = v13;
  v10[0] = a1;
  v10[1] = &v12;
  v10[2] = &v13;
  if (a3 == a5)
  {
    uint64_t v8 = a6;
  }

  else
  {
    do
    {
      *(_OWORD *)(v7 - 4sub_10001AFB0((std::locale *)v24, " +$", 0) = *(_OWORD *)(a3 - 40);
      *(void *)(v7 - 16) = 0LL;
      *(void *)(v7 - std::ostream::~ostream(v1, v2 + 8) = 0LL;
      *(void *)(v7 - ++*(void *)(result + 24) = 0LL;
      *(_OWORD *)(v7 - ++*(void *)(result + 24) = *(_OWORD *)(a3 - 24);
      *(void *)(v7 - std::ostream::~ostream(v1, v2 + 8) = *(void *)(a3 - 8);
      *(void *)(a3 - ++*(void *)(result + 24) = 0LL;
      *(void *)(a3 - 16) = 0LL;
      *(void *)(a3 - std::ostream::~ostream(v1, v2 + 8) = 0LL;
      uint64_t v7 = *((void *)&v13 + 1) - 40LL;
      *((void *)&v13 + 1) -= 40LL;
      a3 -= 40LL;
    }

    while (a3 != a5);
    uint64_t v8 = v13;
  }

  char v11 = 1;
  sub_10002E438((uint64_t)v10);
  return v8;
}

uint64_t sub_10002E438(uint64_t a1)
{
  if (!*(_BYTE *)(a1 + 24)) {
    sub_10002E46C(a1);
  }
  return a1;
}

void sub_10002E46C(uint64_t a1)
{
  uint64_t v1 = *(void *)(*(void *)(a1 + 16) + 8LL);
  uint64_t v2 = *(void *)(*(void *)(a1 + 8) + 8LL);
  while (v1 != v2)
  {
    uint64_t v3 = (void **)(v1 + 16);
    sub_1000180A4(&v3);
    v1 += 40LL;
  }

void **sub_10002E4B8(void **a1)
{
  if (*a1) {
    operator delete(*a1);
  }
  return a1;
}

void sub_10002E4E8(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v2; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 40;
    uint64_t v4 = (void **)(i - 24);
    sub_1000180A4(&v4);
  }

uint64_t sub_10002E53C(uint64_t a1)
{
  return a1;
}

int main(int argc, const char **argv, const char **envp)
{
  dispatch_workloop_t inactive = dispatch_workloop_create_inactive("RDMainWorkloop");
  dispatch_workloop_set_scheduler_priority(inactive, 45LL, 0LL);
  dispatch_set_qos_class_fallback(inactive, 33LL);
  dispatch_activate(inactive);
  initially_dispatch_workloop_t inactive = dispatch_queue_attr_make_initially_inactive(0LL);
  dispatch_queue_t v5 = dispatch_queue_create("RDMainQueue", initially_inactive);
  dispatch_set_target_queue(v5, inactive);
  dispatch_set_qos_class_floor(v5, QOS_CLASS_USER_INTERACTIVE, 0);
  dispatch_activate(v5);
  dispatch_release(inactive);
  gRDServerQueue = (uint64_t)v5;
  do
    int v6 = open("/dev/null", 2);
  while (v6 < 3);
  uint64_t v7 = close(v6);
  xpc_track_activity(v7);
  xpc_main((xpc_connection_handler_t)sub_10002E61C);
}

void sub_10002E61C(_xpc_connection_s *a1)
{
  handler[0] = _NSConcreteStackBlock;
  handler[1] = 0x40000000LL;
  handler[2] = sub_10002E690;
  handler[3] = &unk_1000CED18;
  handler[4] = a1;
  xpc_connection_set_event_handler(a1, handler);
  xpc_connection_resume(a1);
}

void sub_10002E690(uint64_t a1, void *a2)
{
}

void sub_10002E698(_xpc_connection_s *a1, xpc_object_t object)
{
  xpc_type_t type = xpc_get_type(object);
  if (type != (xpc_type_t)&_xpc_type_error)
  {
    if (type == (xpc_type_t)&_xpc_type_connection)
    {
      sub_10002E61C(object);
      return;
    }

    if (type != (xpc_type_t)&_xpc_type_dictionary) {
      sub_1000A4EB8();
    }
    int64_t int64 = xpc_dictionary_get_int64(object, kRDKeyMessage);
    int64_t v6 = int64;
    if (int64 > 899)
    {
      if (int64 == 900)
      {
        xpc_object_t reply = xpc_dictionary_create_reply(object);
        __int128 v13 = kRDKeyObjectID;
        uint64_t int64 = xpc_dictionary_get_uint64(object, kRDKeyObjectID);
        xpc_dictionary_set_uint64(reply, v13, uint64);
        goto LABEL_33;
      }

      if (int64 != 911)
      {
        goto LABEL_29;
      }
    }

    else if (int64 != 100)
    {
      if (int64 != 101)
      {
        if (int64 == 300)
        {
          RDPeer::sBroker = (uint64_t)a1;
          uint64_t v7 = (os_log_s *)RXOSLog();
          if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)__int128 buf = 67109120;
            pid_t pid = xpc_connection_get_pid(a1);
            uint64_t v8 = "broker(%d) introduced itself";
LABEL_23:
            unint64_t v10 = v7;
            os_log_type_t v11 = OS_LOG_TYPE_DEFAULT;
            uint32_t v12 = 8;
LABEL_24:
            _os_log_impl((void *)&_mh_execute_header, v10, v11, v8, buf, v12);
            return;
          }

          return;
        }

void sub_10002EAF0(_Unwind_Exception *a1)
{
}

void sub_10002EB0C(_xpc_connection_s *a1, uint64_t a2)
{
  uint64_t v5 = a2;
  sub_10002F044((uint64_t **)&qword_1000DDD10, (unint64_t *)&v5, &v5);
  if ((byte_1000DDD28 & 1) == 0)
  {
    byte_1000DDD28 = 1;
    qword_1000DDD30 = os_transaction_create("com.apple.SpeechRecognitionCore.speechrecognitiond");
    uint64_t v3 = (os_log_s *)RXOSLog();
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      pid_t pid = xpc_connection_get_pid(a1);
      *(_DWORD *)__int128 buf = 67109120;
      pid_t v7 = pid;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "peer(%d) is first peer alive", buf, 8u);
    }
  }

void sub_10002EBEC(uint64_t a1, xpc_object_t object)
{
  uint64_t v4 = *(_xpc_connection_s **)(a1 + 32);
  uint64_t v3 = *(void **)(a1 + 40);
  xpc_type_t type = xpc_get_type(object);
  if (type == (xpc_type_t)&_xpc_type_error)
  {
    if (object == &_xpc_error_connection_invalid)
    {
      sub_10002F0FC(v4, (unint64_t)v3);
      (*(void (**)(void *))*v3)(v3);
      pid_t v7 = (os_log_s *)RXOSLog();
      if (!os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT)) {
        return;
      }
      int v11 = 67109120;
      pid_t pid = xpc_connection_get_pid(v4);
      uint64_t v8 = "peer(%d) XPC_ERROR_CONNECTION_INVALID";
    }

    else if (object == &_xpc_error_connection_interrupted)
    {
      sub_10002F0FC(v4, (unint64_t)v3);
      (*(void (**)(void *))*v3)(v3);
      pid_t v7 = (os_log_s *)RXOSLog();
      if (!os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT)) {
        return;
      }
      int v11 = 67109120;
      pid_t pid = xpc_connection_get_pid(v4);
      uint64_t v8 = "peer(%d) XPC_ERROR_CONNECTION_INTERRUPTED";
    }

    else
    {
      if (object != &_xpc_error_termination_imminent) {
        return;
      }
      pid_t v7 = (os_log_s *)RXOSLog();
      if (!os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT)) {
        return;
      }
      int v11 = 67109120;
      pid_t pid = xpc_connection_get_pid(v4);
      uint64_t v8 = "peer(%d) XPC_ERROR_TERMINATION_IMMINENT";
    }

    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, v8, (uint8_t *)&v11, 8u);
    return;
  }

  if (type != (xpc_type_t)&_xpc_type_dictionary) {
    sub_1000A4EE0();
  }
  int64_t int64 = xpc_dictionary_get_int64(object, kRDKeyMessage);
  switch(int64)
  {
    case 'd':
      else {
        sub_10002F0FC(v4, (unint64_t)v3);
      }
      return;
    case 'e':
      goto LABEL_19;
    case 'f':
      xpc_object_t reply = xpc_dictionary_create_reply(object);
      (*(void (**)(void *, xpc_object_t, xpc_object_t))(*v3 + 32LL))(v3, object, reply);
      goto LABEL_30;
    case 'g':
      unint64_t v10 = *(void (**)(void *, xpc_object_t))(*v3 + 40LL);
      goto LABEL_32;
    case 'h':
      unint64_t v10 = *(void (**)(void *, xpc_object_t))(*v3 + 48LL);
      goto LABEL_32;
    case 'i':
      v3[4] = object;
      xpc_retain(object);
      return;
    case 'j':
      unint64_t v10 = *(void (**)(void *, xpc_object_t))(*v3 + 64LL);
      goto LABEL_32;
    case 'k':
      unint64_t v10 = *(void (**)(void *, xpc_object_t))(*v3 + 72LL);
      goto LABEL_32;
    case 'l':
      (*(void (**)(void *))(*v3 + 80LL))(v3);
      return;
    case 'm':
      unint64_t v10 = *(void (**)(void *, xpc_object_t))(*v3 + 88LL);
      goto LABEL_32;
    case 'n':
      unint64_t v10 = *(void (**)(void *, xpc_object_t))(*v3 + 96LL);
      goto LABEL_32;
    case 'o':
      xpc_object_t reply = xpc_dictionary_create_reply(object);
      (*(void (**)(void *, xpc_object_t, xpc_object_t))(*v3 + 104LL))(v3, object, reply);
LABEL_30:
      xpc_connection_send_message(v4, reply);
      xpc_release(reply);
      break;
    case 'p':
      unint64_t v10 = *(void (**)(void *, xpc_object_t))(*v3 + 56LL);
LABEL_32:
      v10(v3, object);
      break;
    default:
      else {
LABEL_19:
      }
        sub_10002E698((int)v4, object);
      break;
  }

uint64_t *sub_10002F044(uint64_t **a1, unint64_t *a2, uint64_t *a3)
{
  int64_t v6 = a1 + 1;
  uint64_t v5 = a1[1];
  if (v5)
  {
    unint64_t v7 = *a2;
    while (1)
    {
      while (1)
      {
        uint64_t v8 = (uint64_t **)v5;
        unint64_t v9 = v5[4];
        if (v7 >= v9) {
          break;
        }
        uint64_t v5 = *v8;
        int64_t v6 = v8;
        if (!*v8) {
          goto LABEL_10;
        }
      }

      if (v9 >= v7) {
        break;
      }
      uint64_t v5 = v8[1];
      if (!v5)
      {
        int64_t v6 = v8 + 1;
        goto LABEL_10;
      }
    }
  }

  else
  {
    uint64_t v8 = a1 + 1;
LABEL_10:
    unint64_t v10 = (uint64_t *)operator new(0x28uLL);
    v10[4] = *a3;
    sub_100019D14(a1, (uint64_t)v8, v6, v10);
    return v10;
  }

  return (uint64_t *)v8;
}

void sub_10002F0FC(_xpc_connection_s *a1, unint64_t a2)
{
  unint64_t v5 = a2;
  sub_10002F1DC((uint64_t)&qword_1000DDD10, &v5);
  if (!qword_1000DDD20 && byte_1000DDD28 == 1)
  {
    byte_1000DDD28 = 0;
    os_release((void *)qword_1000DDD30);
    uint64_t v3 = (os_log_s *)RXOSLog();
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      pid_t pid = xpc_connection_get_pid(a1);
      *(_DWORD *)__int128 buf = 67109120;
      pid_t v7 = pid;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "peer(%d) was last peer alive", buf, 8u);
    }
  }

uint64_t sub_10002F1DC(uint64_t a1, unint64_t *a2)
{
  uint64_t v2 = *(void **)(a1 + 8);
  if (!v2) {
    return 0LL;
  }
  unint64_t v3 = *a2;
  uint64_t v4 = (uint64_t *)(a1 + 8);
  do
  {
    unint64_t v5 = v2[4];
    BOOL v6 = v5 >= v3;
    if (v5 >= v3) {
      pid_t v7 = v2;
    }
    else {
      pid_t v7 = v2 + 1;
    }
    if (v6) {
      uint64_t v4 = v2;
    }
    uint64_t v2 = (void *)*v7;
  }

  while (*v7);
  sub_10002F254((uint64_t **)a1, v4);
  operator delete(v4);
  return 1LL;
}

uint64_t *sub_10002F254(uint64_t **a1, uint64_t *a2)
{
  uint64_t v2 = (uint64_t *)a2[1];
  if (v2)
  {
    do
    {
      unint64_t v3 = v2;
      uint64_t v2 = (uint64_t *)*v2;
    }

    while (v2);
  }

  else
  {
    uint64_t v4 = a2;
    do
    {
      unint64_t v3 = (uint64_t *)v4[2];
      BOOL v5 = *v3 == (void)v4;
      uint64_t v4 = v3;
    }

    while (!v5);
  }

  if (*a1 == a2) {
    *a1 = v3;
  }
  BOOL v6 = a1[1];
  a1[2] = (uint64_t *)((char *)a1[2] - 1);
  sub_10002F2C4(v6, a2);
  return v3;
}

uint64_t *sub_10002F2C4(uint64_t *result, uint64_t *a2)
{
  uint64_t v2 = *a2;
  unint64_t v3 = a2;
  if (*a2)
  {
    uint64_t v4 = (uint64_t *)a2[1];
    if (!v4)
    {
      unint64_t v3 = a2;
      goto LABEL_7;
    }

    do
    {
      unint64_t v3 = v4;
      uint64_t v4 = (uint64_t *)*v4;
    }

    while (v4);
  }

  uint64_t v2 = v3[1];
  if (v2)
  {
LABEL_7:
    int v5 = 0;
    *(void *)(v2 + 16) = v3[2];
    goto LABEL_8;
  }

  int v5 = 1;
LABEL_8:
  BOOL v6 = (uint64_t **)v3[2];
  pid_t v7 = *v6;
  if (*v6 == v3)
  {
    uint64_t *v6 = (uint64_t *)v2;
    if (v3 == result)
    {
      pid_t v7 = 0LL;
      uint64_t result = (uint64_t *)v2;
    }

    else
    {
      pid_t v7 = v6[1];
    }
  }

  else
  {
    v6[1] = (uint64_t *)v2;
  }

  int v8 = *((unsigned __int8 *)v3 + 24);
  if (v3 != a2)
  {
    uint64_t v9 = a2[2];
    _OWORD v3[2] = v9;
    *(void *)(v9 + 8LL * (*(void *)a2[2] != (void)a2)) = v3;
    uint64_t v11 = *a2;
    uint64_t v10 = a2[1];
    *(void *)(v11 + 16) = v3;
    *unint64_t v3 = v11;
    v3[1] = v10;
    if (v10) {
      *(void *)(v10 + 16) = v3;
    }
    *((_BYTE *)v3 + ++*(void *)(result + 24) = *((_BYTE *)a2 + 24);
    if (result == a2) {
      uint64_t result = v3;
    }
  }

  if (!v8 || !result) {
    return result;
  }
  if (!v5)
  {
    *(_BYTE *)(v2 + ++*(void *)(result + 24) = 1;
    return result;
  }

  while (1)
  {
    uint64_t v12 = v7[2];
    if (!*((_BYTE *)v7 + 24))
    {
      *((_BYTE *)v7 + ++*(void *)(result + 24) = 1;
      *(_BYTE *)(v12 + ++*(void *)(result + 24) = 0;
      __int128 v13 = *(uint64_t **)(v12 + 8);
      uint64_t v14 = *v13;
      *(void *)(v12 + std::ostream::~ostream(v1, v2 + 8) = *v13;
      if (v14) {
        *(void *)(v14 + 16) = v12;
      }
      v13[2] = *(void *)(v12 + 16);
      *(void *)(*(void *)(v12 + 16) + 8LL * (**(void **)(v12 + 16) != v12)) = v13;
      *__int128 v13 = v12;
      *(void *)(v12 + 16) = v13;
      pid_t v7 = *(uint64_t **)(*v7 + 8);
    }

    float v15 = (void *)*v7;
    if (*v7 && !*((_BYTE *)v15 + 24))
    {
      int v16 = (uint64_t *)v7[1];
      if (!v16) {
        goto LABEL_56;
      }
LABEL_55:
      if (*((_BYTE *)v16 + 24))
      {
LABEL_56:
        *((_BYTE *)v15 + ++*(void *)(result + 24) = 1;
        *((_BYTE *)v7 + ++*(void *)(result + 24) = 0;
        uint64_t v22 = v15[1];
        *pid_t v7 = v22;
        if (v22) {
          *(void *)(v22 + 16) = v7;
        }
        void v15[2] = v7[2];
        *(void *)(v7[2] + 8LL * (*(void *)v7[2] != (void)v7)) = v15;
        v15[1] = v7;
        _OWORD v7[2] = (uint64_t)v15;
        int v16 = v7;
      }

      else
      {
        float v15 = v7;
      }

      uint64_t v23 = v15[2];
      *((_BYTE *)v15 + ++*(void *)(result + 24) = *(_BYTE *)(v23 + 24);
      *(_BYTE *)(v23 + ++*(void *)(result + 24) = 1;
      *((_BYTE *)v16 + ++*(void *)(result + 24) = 1;
      uint64_t v24 = *(uint64_t **)(v23 + 8);
      uint64_t v25 = *v24;
      *(void *)(v23 + std::ostream::~ostream(v1, v2 + 8) = *v24;
      if (v25) {
        *(void *)(v25 + 16) = v23;
      }
      std::string v24[2] = *(void *)(v23 + 16);
      *(void *)(*(void *)(v23 + 16) + 8LL * (**(void **)(v23 + 16) != v23)) = v24;
      *uint64_t v24 = v23;
      goto LABEL_72;
    }

    int v16 = (uint64_t *)v7[1];
    if (v16 && !*((_BYTE *)v16 + 24)) {
      goto LABEL_55;
    }
    *((_BYTE *)v7 + ++*(void *)(result + 24) = 0;
    int v17 = (uint64_t *)v7[2];
    if (v17 == result)
    {
      int v17 = result;
LABEL_53:
      *((_BYTE *)v17 + ++*(void *)(result + 24) = 1;
      return result;
    }

    if (!*((_BYTE *)v17 + 24)) {
      goto LABEL_53;
    }
LABEL_49:
    pid_t v7 = *(uint64_t **)(v17[2] + 8LL * (*(void *)v17[2] == (void)v17));
  }

  if (!*((_BYTE *)v7 + 24))
  {
    *((_BYTE *)v7 + ++*(void *)(result + 24) = 1;
    *(_BYTE *)(v12 + ++*(void *)(result + 24) = 0;
    uint64_t v18 = v7[1];
    *(void *)uint64_t v12 = v18;
    if (v18) {
      *(void *)(v18 + 16) = v12;
    }
    _OWORD v7[2] = *(void *)(v12 + 16);
    *(void *)(*(void *)(v12 + 16) + 8LL * (**(void **)(v12 + 16) != v12)) = v7;
    v7[1] = v12;
    *(void *)(v12 + 16) = v7;
    pid_t v7 = *(uint64_t **)v12;
  }

  uint64_t v19 = (void *)*v7;
  if (*v7 && !*((_BYTE *)v19 + 24)) {
    goto LABEL_68;
  }
  unint64_t v20 = (uint64_t *)v7[1];
  if (!v20 || *((_BYTE *)v20 + 24))
  {
    *((_BYTE *)v7 + ++*(void *)(result + 24) = 0;
    int v17 = (uint64_t *)v7[2];
    if (*((_BYTE *)v17 + 24)) {
      BOOL v21 = v17 == result;
    }
    else {
      BOOL v21 = 1;
    }
    if (v21) {
      goto LABEL_53;
    }
    goto LABEL_49;
  }

  if (v19 && !*((_BYTE *)v19 + 24))
  {
LABEL_68:
    unint64_t v20 = v7;
  }

  else
  {
    *((_BYTE *)v20 + ++*(void *)(result + 24) = 1;
    *((_BYTE *)v7 + ++*(void *)(result + 24) = 0;
    uint64_t v26 = *v20;
    v7[1] = *v20;
    if (v26) {
      *(void *)(v26 + 16) = v7;
    }
    v20[2] = v7[2];
    *(void *)(v7[2] + 8LL * (*(void *)v7[2] != (void)v7)) = v20;
    *unint64_t v20 = (uint64_t)v7;
    _OWORD v7[2] = (uint64_t)v20;
    uint64_t v19 = v7;
  }

  uint64_t v23 = v20[2];
  *((_BYTE *)v20 + ++*(void *)(result + 24) = *(_BYTE *)(v23 + 24);
  *(_BYTE *)(v23 + ++*(void *)(result + 24) = 1;
  *((_BYTE *)v19 + ++*(void *)(result + 24) = 1;
  uint64_t v24 = *(uint64_t **)v23;
  uint64_t v27 = *(void *)(*(void *)v23 + 8LL);
  *(void *)uint64_t v23 = v27;
  if (v27) {
    *(void *)(v27 + 16) = v23;
  }
  std::string v24[2] = *(void *)(v23 + 16);
  *(void *)(*(void *)(v23 + 16) + 8LL * (**(void **)(v23 + 16) != v23)) = v24;
  v24[1] = v23;
LABEL_72:
  *(void *)(v23 + 16) = v24;
  return result;
}

uint64_t sub_10002F648()
{
  qword_1000DDD20 = 0LL;
  qword_1000DDD18 = 0LL;
  qword_1000DDD10 = (uint64_t)&qword_1000DDD18;
  return __cxa_atexit((void (*)(void *))sub_10002E53C, &qword_1000DDD10, (void *)&_mh_execute_header);
}

CFIndex RXDebugFlagsUpdate()
{
  dword_1000DDD38 = CFPreferencesGetAppIntegerValue( @"RXDebugFlag",  @"com.apple.SpeechRecognitionCore.speechrecognitiond",  0LL);
  byte_1000DDD3C = CFPreferencesGetAppBooleanValue( @"RXVeryVerbose",  @"com.apple.SpeechRecognitionCore.speechrecognitiond",  0LL) != 0;
  byte_1000DDD3D = CFPreferencesGetAppIntegerValue( @"RXDebugAutomationMode",  @"com.apple.SpeechRecognitionCore.speechrecognitiond",  0LL);
  Boolean keyExistsAndHasValidFormat = 0;
  int AppBooleanValue = CFPreferencesGetAppBooleanValue( @"RXDebugAutomationSimulateOpenMic",  @"com.apple.SpeechRecognitionCore.speechrecognitiond",  &keyExistsAndHasValidFormat);
  if (keyExistsAndHasValidFormat) {
    BOOL v1 = AppBooleanValue == 0;
  }
  else {
    BOOL v1 = 0;
  }
  char v2 = !v1;
  byte_1000DD398 = v2;
  Boolean keyExistsAndHasValidFormat = 0;
  char AppIntegerValue = CFPreferencesGetAppIntegerValue( @"RXRecognitionResetTimeInSec",  @"com.apple.SpeechRecognitionCore.speechrecognitiond",  &keyExistsAndHasValidFormat);
  if (keyExistsAndHasValidFormat) {
    char v4 = AppIntegerValue;
  }
  else {
    char v4 = 5;
  }
  byte_1000DD399 = v4;
  CFIndex result = CFPreferencesGetAppIntegerValue( @"RXDebugAutomationSaveKeywordsAudio",  @"com.apple.SpeechRecognitionCore.speechrecognitiond",  0LL);
  byte_1000DDD3E = result != 0LL;
  return result;
}

uint64_t RXLogServerResults()
{
  return dword_1000DDD38 >> 7;
}

uint64_t RXLogServerGrammar()
{
  return BYTE1(dword_1000DDD38) & 1;
}

uint64_t RXLogSound()
{
  return (BYTE1(dword_1000DDD38) >> 1) & 1;
}

uint64_t RXLogClientUpdates()
{
  return (BYTE1(dword_1000DDD38) >> 2) & 1;
}

uint64_t RXLogPerformance()
{
  return (BYTE1(dword_1000DDD38) >> 3) & 1;
}

uint64_t RXVeryVerbose()
{
  return byte_1000DDD3C;
}

BOOL RXAutomationModeSynthesis()
{
  return byte_1000DDD3D == 1;
}

BOOL RXAutomationModeResult()
{
  return byte_1000DDD3D == 2;
}

BOOL RXAutomationModeFileName()
{
  return byte_1000DDD3D == 3;
}

uint64_t RXAutomationSimulateOpenMic()
{
  return byte_1000DD398;
}

uint64_t RXResetTimeInSec()
{
  return byte_1000DD399;
}

uint64_t RXAutomationSaveKeywordsAudio()
{
  return byte_1000DDD3E;
}

void __RXAbort(int a1, uint64_t a2, uint64_t a3, uint64_t a4, CFStringRef format, ...)
{
  CFStringRef v9 = CFStringCreateWithFormatAndArguments(0LL, 0LL, format, va);
  CFStringRef v10 = v9;
  if (a4) {
  else
  }
    CFStringRef v11 = CFStringCreateWithFormat(0LL, 0LL, @"%s:%u: %@\n", a2, a3, v9);
  uint64_t v12 = v11;
  if (v10) {
    CFRelease(v10);
  }
  ExternalRepresentation = CFStringCreateExternalRepresentation(0LL, v12, 0x8000100u, 0);
  if (v12) {
    CFRelease(v12);
  }
  if (ExternalRepresentation)
  {
    BytePtr = CFDataGetBytePtr(ExternalRepresentation);
    size_t Length = CFDataGetLength(ExternalRepresentation);
    write(1, BytePtr, Length);
    CFRelease(ExternalRepresentation);
  }

  if (a1) {
    abort();
  }
}

uint64_t RXIsAppleInternal()
{
  if (qword_1000DDD40 != -1) {
    dispatch_once(&qword_1000DDD40, &stru_1000CED78);
  }
  return byte_1000DDD3F;
}

void sub_10002F97C(id a1)
{
  byte_1000DDD3F = os_variant_has_internal_diagnostics("com.apple.SpeechRecognitionCore.speechrecognitiond");
}

void reportBacktrace()
{
  int v0 = backtrace(&v13, 33);
  uint64_t v1 = (v0 - 2);
  char v2 = backtrace_symbols(v14, v1);
  if (v2)
  {
    unint64_t v3 = v2;
    if (v0 >= 3)
    {
      for (uint64_t i = 0LL; v1 != i; ++i)
      {
        int v5 = v3[i];
        if (v5)
        {
          if (qword_1000DDD60 != -1) {
            dispatch_once(&qword_1000DDD60, &stru_1000CEDF8);
          }
          uint64_t v6 = qword_1000DDD58;
          if (!os_log_type_enabled((os_log_t)qword_1000DDD58, OS_LOG_TYPE_ERROR)) {
            continue;
          }
          pid_t v7 = v14[i];
          *(_DWORD *)__int128 buf = 67109634;
          int v16 = i + 1;
          __int16 v17 = 2048;
          uint64_t v18 = v7;
          __int16 v19 = 2080;
          unint64_t v20 = v5;
          int v8 = (os_log_s *)v6;
          CFStringRef v9 = "BACKTRACE: %-3d %p %s\n";
          uint32_t v10 = 28;
        }

        else
        {
          if (qword_1000DDD60 != -1) {
            dispatch_once(&qword_1000DDD60, &stru_1000CEDF8);
          }
          uint64_t v11 = qword_1000DDD58;
          if (!os_log_type_enabled((os_log_t)qword_1000DDD58, OS_LOG_TYPE_ERROR)) {
            continue;
          }
          uint64_t v12 = v14[i];
          *(_DWORD *)__int128 buf = 67109376;
          int v16 = i + 1;
          __int16 v17 = 2048;
          uint64_t v18 = v12;
          int v8 = (os_log_s *)v11;
          CFStringRef v9 = "BACKTRACE: %-3d %p\n";
          uint32_t v10 = 18;
        }

        _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, v9, buf, v10);
      }
    }

    free(v3);
  }

uint64_t RXSignpostLog()
{
  if (qword_1000DDD50 != -1) {
    dispatch_once(&qword_1000DDD50, &stru_1000CEDB8);
  }
  return qword_1000DDD48;
}

void sub_10002FBC4(id a1)
{
  qword_1000DDD48 = (uint64_t)os_log_create("com.apple.SpeechRecognitionCore", "SRCSignposts");
}

uint64_t RXOSLog()
{
  if (qword_1000DDD60 != -1) {
    dispatch_once(&qword_1000DDD60, &stru_1000CEDF8);
  }
  return qword_1000DDD58;
}

void sub_10002FC30(id a1)
{
  qword_1000DDD58 = (uint64_t)os_log_create("com.apple.SpeechRecognitionCore", "SRCLogs");
}

uint64_t RDQSREngine::Instantiate(RDQSREngine *this, void *a2)
{
  if (RDQSREngine::sInstance) {
    return 1LL;
  }
  unint64_t v3 = (RDQSREngine *)operator new(0x1A0uLL);
  RDQSREngine::RDQSREngine(v3, this);
  RDQSREngine::sInstance = (uint64_t)v3;
  char v4 = (os_log_s *)RXOSLog();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)int v8 = 0;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Start ASR Engine", v8, 2u);
  }

  RDQSREngine::StartASREngine(RDQSREngine::sInstance);
  uint64_t v5 = RDQSREngine::sInstance;
  if (*(_BYTE *)(RDQSREngine::sInstance + 82)) {
    return 1LL;
  }
  sub_100031898((void ***)(RDQSREngine::sInstance + 208), 0LL);
  sub_100031898((void ***)(v5 + 200), 0LL);
  sub_100034DB8((CFTypeRef **)(v5 + 160), 0LL);
  pid_t v7 = *(void **)(v5 + 112);
  if (v7)
  {
    *(void *)(v5 + 12sub_10001AFB0((std::locale *)v24, " +$", 0) = v7;
    operator delete(v7);
  }

  sub_100034D8C((RDUserProfile **)(v5 + 32), 0LL);
  sub_100034D8C((RDUserProfile **)(v5 + 24), 0LL);
  operator delete((void *)v5);
  uint64_t result = 0LL;
  RDQSREngine::sInstance = 0LL;
  return result;
}

void sub_10002FD64(_Unwind_Exception *a1)
{
}

uint64_t RDQSREngine::StartASREngine(uint64_t this)
{
  uint64_t v1 = *(const __CFString **)(this + 192);
  if (v1)
  {
    uint64_t v2 = this;
    CFMutableStringRef MutableCopy = CFStringCreateMutableCopy(kCFAllocatorSystemDefault, 0LL, v1);
    char v4 = CFStringCreateMutableCopy(kCFAllocatorSystemDefault, 0LL, *(CFStringRef *)(v2 + 192));
    CFStringAppend(MutableCopy, @"mini.json");
    CFStringAppend(v4, @"etiquette.json");
    if (sub_100030734(MutableCopy))
    {
      CFLocaleRef v5 = CFLocaleCreate(0LL, *(CFLocaleIdentifier *)(v2 + 152));
      uint64_t v6 = RDASRWSpeechRecognizerCreate((uint64_t)MutableCopy, 1, (uint64_t)v5);
      *(void *)(v2 + 16) = v6;
      RDASRWSpeechRecognizerSetDetectUtterances(v6, 1LL);
      id v7 = RDASRWSpeechRecognizerSetHighPriority(*(void **)(v2 + 16), 1LL);
      int v8 = (const __CFArray *)RXLocalesSupportingSpellingMode(v7);
      if (v8)
      {
        uint32_t v10 = v8;
        v21.length = CFArrayGetCount(v8);
        v21.id location = 0LL;
        *(_BYTE *)(v2 + 40sub_10001AFB0((std::locale *)v24, " +$", 0) = CFArrayContainsValue(v10, v21, *(const void **)(v2 + 152)) != 0;
        CFRelease(v10);
      }

      uint64_t v11 = (const __CFArray *)RDLanguageAssets::CopyInstalledAssetSupportedTasksForLanguage( *(const __CFString **)(v2 + 152),  v9);
      if (v11)
      {
        uint64_t v12 = v11;
        v22.length = CFArrayGetCount(v11);
        v22.id location = 0LL;
        *(_BYTE *)(v2 + 401) = CFArrayContainsValue(v12, v22, @"SpellCC") != 0;
        CFRelease(v12);
      }

      __int128 v13 = (RDUserProfile *)operator new(0x10uLL);
      RDUserProfile::RDUserProfile(v13, *(void *)(v2 + 192), *(void *)(v2 + 152), 0LL);
      sub_100034D8C((RDUserProfile **)(v2 + 24), v13);
      dispatch_time_t v14 = dispatch_time(0LL, 5000000000LL);
      block[0] = _NSConcreteStackBlock;
      block[1] = 0x40000000LL;
      block[2] = sub_10003084C;
      block[3] = &unk_1000CEE18;
      block[4] = v2;
      dispatch_after(v14, (dispatch_queue_t)gRDServerQueue, block);
      float v15 = (RDUserProfile *)operator new(0x10uLL);
      RDUserProfile::RDUserProfile(v15, *(void *)(v2 + 192), *(void *)(v2 + 152), 1LL);
      sub_100034D8C((RDUserProfile **)(v2 + 32), v15);
      RDQSREngine::LoadCustomVocabulary((id ***)v2, 1);
      if (sub_100030734(v4)) {
        *(void *)(v2 + 376) = CFRetain(v4);
      }
      int v16 = (const __CFBoolean *)CFPreferencesCopyAppValue( @"SaveUtteranceToFile",  @"com.apple.SpeechRecognitionCore.speechrecognitiond");
      if (v16)
      {
        __int16 v17 = v16;
        CFTypeID v18 = CFGetTypeID(v16);
        if (v18 == CFBooleanGetTypeID()) {
          *(_BYTE *)(v2 + 216) = CFBooleanGetValue(v17) != 0;
        }
        CFRelease(v17);
      }

      DarwinNotifyCenter = CFNotificationCenterGetDarwinNotifyCenter();
      CFNotificationCenterAddObserver( DarwinNotifyCenter,  (const void *)v2,  (CFNotificationCallback)sub_100030DC8,  @"NotificationVocabularyEntriesSettingsChanged",  0LL,  CFNotificationSuspensionBehaviorDeliverImmediately);
      if (v5) {
        CFRelease(v5);
      }
    }

    if (MutableCopy) {
      CFRelease(MutableCopy);
    }
    if (v4) {
      CFRelease(v4);
    }
    if (!*(void *)(v2 + 16)) {
      sub_1000A4F08();
    }
    *(_BYTE *)(v2 + 1sub_10001AFB0((std::locale *)v24, " +$", 0) = RXIsAudioDonationSupported();
    *(_WORD *)(v2 + std::ostream::~ostream(v1, v2 + 8) = 10;
    this = (uint64_t)CFPreferencesCopyAppValue( @"SpeechDonationConfig",  @"com.apple.SpeechRecognitionCore.speechrecognitiond");
    if (this)
    {
      this = (uint64_t)CFDictionaryGetValue((CFDictionaryRef)this, @"SpeechDonationSamplingPercent");
      if (this)
      {
        this = CFStringGetIntValue((CFStringRef)this);
        *(_WORD *)(v2 + std::ostream::~ostream(v1, v2 + 8) = this;
      }
    }

    *(_BYTE *)(v2 + 82) = 1;
  }

  return this;
}

void sub_100030078(_Unwind_Exception *a1)
{
}

void RDQSREngine::RDQSREngine(RDQSREngine *this, xpc_object_t xstring)
{
  *((void *)this + 3) = 0LL;
  *((void *)this + 4) = 0LL;
  *((void *)this + 5) = 0LL;
  *((_BYTE *)this + 4std::ostream::~ostream(v1, v2 + 8) = 1;
  *((void *)this + std::ostream::~ostream(v1, v2 + 8) = 0LL;
  *((void *)this + 9) = 0LL;
  *((void *)this + 7) = 0LL;
  *((_WORD *)this + 4sub_10001AFB0((std::locale *)v24, " +$", 0) = 22863;
  *(_DWORD *)((char *)this + 82) = 0;
  *((_WORD *)this + 43) = 1;
  *((_BYTE *)this + 8std::ostream::~ostream(v1, v2 + 8) = 1;
  *((void *)this + 14) = 0LL;
  *((void *)this + 1std::ostream::~ostream(v1, v2 + 8) = 0LL;
  *((void *)this + 15) = 0LL;
  *((void *)this + 16) = 0LL;
  *((_BYTE *)this + 136) = 0;
  string_ptr = xpc_string_get_string_ptr(xstring);
  CFStringRef v4 = CFStringCreateWithCStringNoCopy(0LL, string_ptr, 0x8000100u, kCFAllocatorNull);
  *((void *)this + 2sub_10001AFB0((std::locale *)v24, " +$", 0) = 0LL;
  *((void *)this + 19) = v4;
  *((void *)this + 23) = 0LL;
  CFLocaleRef v5 = (char *)operator new(0x20uLL);
  *((_DWORD *)v5 + 2) = 48000;
  *(void *)CFLocaleRef v5 = operator new[](0x17700uLL);
  *(void *)(v5 + 2sub_10001AFB0((std::locale *)v24, " +$", 0) = 0LL;
  *(void *)(v5 + 12) = 0LL;
  *((void *)this + 25) = v5;
  uint64_t v6 = (char *)operator new(0x20uLL);
  *((_DWORD *)v6 + 2) = 80000;
  *(void *)uint64_t v6 = operator new[](0x27100uLL);
  *(void *)(v6 + 2sub_10001AFB0((std::locale *)v24, " +$", 0) = 0LL;
  *(void *)(v6 + 12) = 0LL;
  *((void *)this + 26) = v6;
  *((_WORD *)this + 10std::ostream::~ostream(v1, v2 + 8) = 0;
  *((void *)this + 2std::ostream::~ostream(v1, v2 + 8) = 0LL;
  *((void *)this + 46) = 0LL;
  *((void *)this + 47) = 0LL;
  *((void *)this + 4std::ostream::~ostream(v1, v2 + 8) = 0LL;
  *((void *)this + 49) = @"DictationCC";
  *((_WORD *)this + 20sub_10001AFB0((std::locale *)v24, " +$", 0) = 0;
  *((_BYTE *)this + 402) = 0;
  gettimeofday(&v35, 0LL);
  *((void *)this + 23) = 1000 * v35.tv_sec + v35.tv_usec / 0x3E8uLL;
  pthread_mutex_init((pthread_mutex_t *)((char *)this + 232), 0LL);
  pthread_mutex_init((pthread_mutex_t *)((char *)this + 296), 0LL);
  *((void *)this + 12) = 0LL;
  *((void *)this + 13) = 0LL;
  RXDebugFlagsUpdate();
  char v7 = RXResetTimeInSec();
  *((_BYTE *)this + 137) = v7;
  if ((v7 - 21) > 0xECu)
  {
    CFStringRef v9 = (os_log_s *)RXOSLog();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      int v10 = *((unsigned __int8 *)this + 137);
      *(_DWORD *)__int128 buf = 67109120;
      int v37 = v10;
      _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEFAULT,  "Recognition reset time set to %d seconds",  buf,  8u);
    }
  }

  else
  {
    int v8 = (os_log_s *)RXOSLog();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_ERROR,  "fRecognitionResetTime should be set in the range of 5 to 20. Defaulting to 7 sec",  buf,  2u);
    }

    *((_BYTE *)this + 137) = 5;
  }

  uint64_t v11 = CFLocaleCreate(0LL, *((CFLocaleIdentifier *)this + 19));
  uint64_t v12 = (CFLocaleRef *)operator new(8uLL);
  sub_100097C34(v12, v11);
  sub_100034DB8((CFTypeRef **)this + 20, (CFTypeRef *)v12);
  if (v11) {
    CFRelease(v11);
  }
  __int128 v13 = (const __CFString *)*((void *)this + 19);
  CFMutableStringRef Mutable = CFStringCreateMutable(0LL, 0LL);
  if (!Mutable) {
    goto LABEL_39;
  }
  int v16 = RDCopyModelPath();
  if (!v16)
  {
    CFRange v22 = (os_log_s *)RXOSLog();
    if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_ERROR, "Couldn't determine root model path", buf, 2u);
    }

    int v16 = Mutable;
    goto LABEL_38;
  }

  CFStringAppend(Mutable, v16);
  CFStringAppend(Mutable, @"/");
  if (v13)
  {
    CFStringAppend(Mutable, v13);
    CFStringAppend(Mutable, @".SpeechRecognition");
    __int16 v17 = CFURLCreateWithFileSystemPath(0LL, Mutable, kCFURLPOSIXPathStyle, 1u);
    if (v17)
    {
      CFTypeID v18 = CFURLCreateCopyAppendingPathComponent(0LL, v17, @"/Contents/", 1u);
      __int16 v19 = v18;
      if (v18)
      {
        unint64_t v20 = RDCopyInfoDict(v18);
        CFRange v21 = v20;
        if (v20)
        {
          CFTypeRef cf = CFDictionaryGetValue(v20, @"RXConfig");
          if (cf) {
            CFRetain(cf);
          }
          Value = (const __CFString *)CFDictionaryGetValue(v21, @"CFBundleShortVersionString");
          if (Value)
          {
            __int128 v33 = (const __CFString *)RDCopyCacheVersion(v13);
            if (v33)
            {
              CFTypeID v31 = CFGetTypeID(v33);
              if (v31 != CFStringGetTypeID() || CFStringCompare(Value, v33, 0LL)) {
                RDNukeCache(v13);
              }
              CFRelease(v33);
            }
          }

          CFRelease(v21);
        }

        else
        {
          CFTypeRef cf = 0LL;
        }

        CFRelease(v19);
        CFRelease(v17);
        if (cf)
        {
          CFStringAppend(Mutable, @"/Contents/Resources/");
          uint64_t v25 = (const __CFString *)CFDictionaryGetValue((CFDictionaryRef)cf, @"QuasarConfig");
          if (v25)
          {
            CFStringAppend(Mutable, v25);
            CFRelease(cf);
            CFRelease(v16);
            goto LABEL_45;
          }

          uint64_t v23 = (os_log_s *)RXOSLog();
          if (!os_log_type_enabled(v23, OS_LOG_TYPE_ERROR)) {
            goto LABEL_37;
          }
          *(_WORD *)__int128 buf = 0;
          uint64_t v24 = "Couldn't obtain Quasar model path from Info.plist.";
          goto LABEL_36;
        }
      }

      else
      {
        CFRelease(v17);
      }
    }

    uint64_t v23 = (os_log_s *)RXOSLog();
    if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)__int128 buf = 0;
      uint64_t v24 = "Inexistent or obsolete data for desired locale.";
      goto LABEL_36;
    }
  }

  else
  {
    uint64_t v23 = (os_log_s *)RXOSLog();
    if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)__int128 buf = 0;
      uint64_t v24 = "Couldn't determine locale";
LABEL_36:
      _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_ERROR, v24, buf, 2u);
    }
  }

void sub_10003067C(_Unwind_Exception *a1)
{
  uint64_t v6 = *v4;
  if (*v4)
  {
    *(void *)(v1 + 12sub_10001AFB0((std::locale *)v24, " +$", 0) = v6;
    operator delete(v6);
  }

  sub_100034D8C((RDUserProfile **)(v1 + 32), 0LL);
  sub_100034D8C(v2, 0LL);
  _Unwind_Resume(a1);
}

BOOL sub_100030734(__CFString *a1)
{
  if (v7 >= 0) {
    uint64_t v1 = __p;
  }
  else {
    uint64_t v1 = (void **)__p[0];
  }
  int v2 = access((const char *)v1, 4);
  if (v2)
  {
    uint64_t v3 = (os_log_s *)RXOSLog();
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
    {
      CFStringRef v4 = __p;
      if (v7 < 0) {
        CFStringRef v4 = (void **)__p[0];
      }
      *(_DWORD *)__int128 buf = 136315138;
      CFStringRef v9 = v4;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_ERROR, "Unable to acess %s!!!", buf, 0xCu);
    }
  }

  if (v7 < 0) {
    operator delete(__p[0]);
  }
  return v2 == 0;
}

void sub_100030828( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void *sub_10003084C(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  uint64_t v2 = *(void *)(v1 + 24);
  v5[0] = &off_1000CF080;
  v5[1] = v1;
  uint64_t v6 = v5;
  RDUserProfile::updateUserProfileWithPersonalData(v2, (uint64_t)v5);
  uint64_t result = v6;
  if (v6 == v5)
  {
    uint64_t v4 = 4LL;
    uint64_t result = v5;
  }

  else
  {
    if (!v6) {
      return result;
    }
    uint64_t v4 = 5LL;
  }

  return (void *)(*(uint64_t (**)(void))(*result + 8 * v4))();
}

void sub_1000308E8( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char *a13)
{
  dispatch_time_t v14 = a13;
  if (a13 == &a10)
  {
    uint64_t v15 = 4LL;
    dispatch_time_t v14 = &a10;
  }

  else
  {
    if (!a13) {
      goto LABEL_6;
    }
    uint64_t v15 = 5LL;
  }

  (*(void (**)(void))(*(void *)v14 + 8 * v15))();
LABEL_6:
  _Unwind_Resume(exception_object);
}

void RDQSREngine::LoadCustomVocabulary(id ***this, int a2)
{
  CFIndex AppIntegerValue = CFPreferencesGetAppIntegerValue( @"PhoneticVocabularyMode",  @"com.apple.SpeechRecognitionCore.Vocabulary",  0LL);
  CFLocaleRef v5 = (os_log_s *)RXOSLog();
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)__int128 buf = 134217984;
    CFIndex v37 = AppIntegerValue;
    _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEFAULT,  "LoadCustomVocabulary phoneticVocabularyMode: %ld",  buf,  0xCu);
  }

  uint64_t v6 = (const __CFArray *)CFPreferencesCopyAppValue( @"CACVocabularyEntries",  @"com.apple.SpeechRecognitionCore.Vocabulary");
  if (v6)
  {
    char v7 = v6;
    CFTypeID v8 = CFGetTypeID(v6);
    if (v8 == CFArrayGetTypeID())
    {
      unint64_t v33 = AppIntegerValue;
      int v31 = a2;
      RDUserProfile::removeLmeDataForTemplateName(this[3], kRDProfileNonTerminalUnknown[0]);
      int64x2_t v34 = this;
      CFMutableStringRef MutableCopy = CFStringCreateMutableCopy(0LL, 0LL, (CFStringRef)this[19]);
      v42.length = CFStringGetLength(MutableCopy);
      v42.id location = 0LL;
      CFStringFindAndReplace(MutableCopy, @"-", @"_", v42, 0LL);
      if (CFArrayGetCount(v7) >= 1)
      {
        CFIndex v10 = 0LL;
        unint64_t v32 = AppIntegerValue & 0xFFFFFFFFFFFFFFFDLL;
        timeval v35 = v7;
        do
        {
          ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(v7, v10);
          if (ValueAtIndex)
          {
            uint64_t v12 = ValueAtIndex;
            Value = (const __CFString *)CFDictionaryGetValue(ValueAtIndex, @"LocaleIdentifier");
            if (Value) {
              dispatch_time_t v14 = Value;
            }
            else {
              dispatch_time_t v14 = @"en_US";
            }
            CFMutableStringRef v15 = CFStringCreateMutableCopy(0LL, 0LL, v14);
            v43.length = CFStringGetLength(v15);
            v43.id location = 0LL;
            CFStringFindAndReplace(v15, @"-", @"_", v43, 0LL);
            if (CFStringCompare(MutableCopy, v15, 0LL) == kCFCompareEqualTo)
            {
              int v16 = (const __CFString *)CFDictionaryGetValue(v12, @"Text");
              __int16 v17 = (const __CFArray *)CFDictionaryGetValue(v12, @"TextIPAs");
              CFMutableStringRef Mutable = CFArrayCreateMutable(0LL, 0LL, &kCFTypeArrayCallBacks);
              if (v17)
              {
                CFIndex Count = CFArrayGetCount(v17);
                if (Count >= 1)
                {
                  CFIndex v20 = Count;
                  for (CFIndex i = 0LL; i != v20; ++i)
                  {
                    CFRange v22 = CFArrayGetValueAtIndex(v17, i);
                    uint64_t v23 = (const __CFString *)SRSSCopyNvasrFromIPA(v22, MutableCopy, @".");
                    if (CFStringCompare(v23, &stru_1000D4C58, 0LL))
                    {
                      uint64_t v24 = (os_log_s *)RXOSLog();
                      if (os_log_type_enabled(v24, OS_LOG_TYPE_DEBUG))
                      {
                        uint64_t v25 = CFArrayGetValueAtIndex(v17, i);
                        *(_DWORD *)__int128 buf = 138412802;
                        CFIndex v37 = (CFIndex)v16;
                        __int16 v38 = 2112;
                        uint64_t v39 = v25;
                        __int16 v40 = 2112;
                        unint64_t v41 = v23;
                        _os_log_impl( (void *)&_mh_execute_header,  v24,  OS_LOG_TYPE_DEBUG,  "LoadCustomVocabulary text: %@, textIPA: %@, prons: %@",  buf,  0x20u);
                      }

                      CFArrayAppendValue(Mutable, v23);
                    }

                    if (v23) {
                      CFRelease(v23);
                    }
                  }
                }
              }

              char v7 = v35;
              if (v16)
              {
                if (CFArrayGetCount(Mutable) >= 1 && v33 <= 1)
                {
                  CFMutableStringRef v26 = CFStringCreateMutable(0LL, 0LL);
                  CFStringAppend(v26, v16);
                  CFStringAppend(v26, @"±");
                  RDUserProfile::addPhraseAndPronsToUserProfile( v34[3],  v26,  Mutable,  kRDProfileNonTerminalUnknown[0],  kRDProfileWordTagUnknownFirst);
                  if (v26) {
                    CFRelease(v26);
                  }
                }

                if (!v32)
                {
                  uint64_t v27 = CFArrayCreate(0LL, 0LL, 0LL, &kCFTypeArrayCallBacks);
                  RDUserProfile::addPhraseAndPronsToUserProfile( v34[3],  v16,  v27,  kRDProfileNonTerminalUnknown[0],  kRDProfileWordTagUnknownFirst);
                  if (v27) {
                    CFRelease(v27);
                  }
                }
              }

              if (Mutable) {
                CFRelease(Mutable);
              }
            }

            CFRelease(v15);
          }

          ++v10;
        }

        while (v10 < CFArrayGetCount(v7));
      }

      CFRelease(MutableCopy);
      a2 = v31;
      this = v34;
    }

    CFRelease(v7);
  }

  id v28 = RDUserProfile::copyDataProfile(this[3]);
  if (v28)
  {
    int64x2_t v29 = v28;
    CFIndex v30 = this[2];
    if (a2) {
      RDASRWSpeechRecognizerSetUserProfileData(v30, (uint64_t)v29);
    }
    else {
      RDASRWSpeechRecognizerUpdateUserProfileData(v30, (uint64_t)v29);
    }
    CFRelease(v29);
  }

void sub_100030DC8(uint64_t a1, uint64_t a2)
{
  v3[0] = 0LL;
  v3[1] = v3;
  _OWORD v3[2] = 0x2000000000LL;
  v3[3] = a2;
  block[0] = _NSConcreteStackBlock;
  block[1] = 0x40000000LL;
  block[2] = sub_100034CAC;
  block[3] = &unk_1000CF050;
  block[4] = v3;
  dispatch_async((dispatch_queue_t)gRDServerQueue, block);
  _Block_object_dispose(v3, 8);
}

std::chrono::duration<long long, std::ratio<1, 1000000000>>::rep RDQSREngine::RestartASREngine( CFTypeRef *this, const __CFString *a2)
{
  this[2] = 0LL;
  *((_BYTE *)this + 82) = 0;
  uint64_t v4 = (os_log_s *)RXOSLog();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    int v6 = 138543362;
    char v7 = a2;
    _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEFAULT,  "Restarting ASR Engine(%{public}@)",  (uint8_t *)&v6,  0xCu);
  }

  RDQSREngine::StartASREngine((uint64_t)this);
  return RDQSREngine::ResetRecognition((RDQSREngine *)this);
}

std::chrono::duration<long long, std::ratio<1, 1000000000>>::rep RDQSREngine::ResetRecognition( RDQSREngine *this)
{
  uint64_t v2 = (pthread_mutex_t *)((char *)this + 232);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 232));
  uint64_t v3 = *((void *)this + 28);
  uint64_t v4 = (os_log_s *)RXOSLog();
  BOOL v5 = os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT);
  if (v3)
  {
    if (v5)
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Resetting recognition system....", buf, 2u);
    }

    RDASRWSpeechRecognitionAudioBufferCancelRecognition(*((void *)this + 28));
    CFRelease(*((CFTypeRef *)this + 28));
    int v6 = (os_log_s *)RXOSLog();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)CFStringRef v9 = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "AudioBuffer released after recognition cancellation",  v9,  2u);
    }

    *((void *)this + 2std::ostream::~ostream(v1, v2 + 8) = 0LL;
  }

  else if (v5)
  {
    *(_WORD *)CFTypeID v8 = 0;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "AudioBuffer was Nil", v8, 2u);
  }

  pthread_mutex_unlock(v2);
  RDQSREngine::SetupRecognition(this);
  std::chrono::duration<long long, std::ratio<1, 1000000000>>::rep result = rd_time_util::now().__d_.__rep_;
  *((void *)this + 46) = result;
  return result;
}

void RDQSREngine::UseAudioSource(RDQSREngine *this, RDQSRSoundSource *a2)
{
  uint64_t v4 = *((void *)this + 5);
  if (v4)
  {
    (*(void (**)(uint64_t))(*(void *)v4 + 48LL))(v4);
    *((void *)this + 5) = a2;
    if (a2)
    {
      if (!*((_BYTE *)this + 48)) {
        RDQSREngine::SetMicState(this, 1, "New Audio file");
      }
    }
  }

  else
  {
    *((void *)this + 5) = a2;
    if (a2)
    {
      if (*((_BYTE *)this + 83))
      {
        RDQSREngine::EAREngine_SetMicState((uint64_t)this, 0);
        BOOL v5 = (os_log_s *)RXOSLog();
        if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)int v6 = 0;
          _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "Mic is finally ON", v6, 2u);
        }
      }
    }
  }

void RDQSREngine::EAREngine_SetMicState(uint64_t a1, int a2)
{
  if (!*(void *)(a1 + 40))
  {
    uint64_t v4 = (os_log_s *)RXOSLog();
    if (!os_log_type_enabled(v4, OS_LOG_TYPE_ERROR)) {
      return;
    }
    *(_WORD *)__int128 buf = 0;
    BOOL v5 = "Set the sound source first before setting EAREngine_MicState";
    goto LABEL_21;
  }

  if (a2 != 1)
  {
    if (!a2)
    {
      pthread_mutex_lock((pthread_mutex_t *)(a1 + 232));
      if (!*(void *)(a1 + 224))
      {
        uint64_t v3 = (os_log_s *)RXOSLog();
        if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)__int128 buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Creating Audio buffer", buf, 2u);
        }

        RDQSREngine::SetupRecognition((RDQSREngine *)a1);
        *(std::chrono::steady_clock::time_point *)(a1 + 36std::ostream::~ostream(v1, v2 + 8) = rd_time_util::now();
      }

      pthread_mutex_unlock((pthread_mutex_t *)(a1 + 232));
      (***(void (****)(void))(a1 + 40))(*(void *)(a1 + 40));
      return;
    }

    uint64_t v4 = (os_log_s *)RXOSLog();
    if (!os_log_type_enabled(v4, OS_LOG_TYPE_ERROR)) {
      return;
    }
    *(_WORD *)__int128 buf = 0;
    BOOL v5 = "Unknown EAR Mic state";
LABEL_21:
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_ERROR, v5, buf, 2u);
    return;
  }

  pthread_mutex_lock((pthread_mutex_t *)(a1 + 232));
  if (*(void *)(a1 + 224))
  {
    int v6 = (os_log_s *)RXOSLog();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "Ending Audio buffer", buf, 2u);
    }

    RDASRWSpeechRecognitionAudioBufferEndAudio(*(void *)(a1 + 224));
    CFRelease(*(CFTypeRef *)(a1 + 224));
    char v7 = (os_log_s *)RXOSLog();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEFAULT,  "AudioBuffer released after mic went off",  buf,  2u);
    }

    *(void *)(a1 + 2++*(void *)(result + 24) = 0LL;
  }

  pthread_mutex_unlock((pthread_mutex_t *)(a1 + 232));
  (*(void (**)(void))(**(void **)(a1 + 40) + 8LL))(*(void *)(a1 + 40));
  block[0] = _NSConcreteStackBlock;
  block[1] = 0x40000000LL;
  block[2] = sub_100032170;
  block[3] = &unk_1000CEF08;
  block[4] = a1;
  if (qword_1000DDD80 != -1) {
    dispatch_once(&qword_1000DDD80, block);
  }
}

void RDQSREngine::SetMicState(RDQSREngine *this, int a2, const char *a3)
{
  if (a2 && *((_BYTE *)this + 84) && *((_BYTE *)this + 83)) {
    RDQSREngine::SetMicState(this, 0, "Deferred toggle");
  }
  *((_BYTE *)this + 84) = 0;
  int v6 = *((unsigned __int8 *)this + 83);
  if (v6 != a2)
  {
    if (*((void *)this + 5)) {
      RDQSREngine::EAREngine_SetMicState((uint64_t)this, a2 ^ 1);
    }
    *((_BYTE *)this + 83) = a2;
  }

  char v7 = (os_log_s *)RXOSLog();
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    if (v6 == a2)
    {
      CFTypeID v8 = "was already";
    }

    else if (*((void *)this + 5))
    {
      CFTypeID v8 = "is now";
    }

    else
    {
      CFTypeID v8 = "eventually will be";
    }

    CFStringRef v9 = "OFF";
    int v10 = 136315650;
    uint64_t v11 = a3;
    __int16 v12 = 2080;
    if (a2) {
      CFStringRef v9 = "ON";
    }
    __int128 v13 = v8;
    __int16 v14 = 2080;
    CFMutableStringRef v15 = v9;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "Mic [%s] %s %s\n", (uint8_t *)&v10, 0x20u);
  }

void RDQSREngine::UseLiveAudio( RDQSREngine *this, RDAudioObject *a2, void (*a3)(RDQSRSoundSource *, const __int16 *, uint64_t))
{
  if (!*((void *)this + 5))
  {
    *((_BYTE *)this + 4std::ostream::~ostream(v1, v2 + 8) = 1;
    LiveSource = RDQSRSoundSource::CreateLiveSource(a2, (RDAudioObject *)RDQSREngine::RequestSamplesCallback, a3);
    RDQSREngine::UseAudioSource(this, LiveSource);
  }

uint64_t RDQSREngine::RequestSamplesCallback(RDQSREngine *this, RDQSRSoundSource *a2, const __int16 *a3)
{
  return RDQSREngine::RequestSamples((RDQSREngine *)RDQSREngine::sInstance, a2, (__int16 *)a2, (uint64_t)a3);
}

void RDQSREngine::UseFileAudio( RDQSREngine *this, const __CFURL *a2, uint64_t a3, void (*a4)(RDQSRSoundSource *, const __int16 *, uint64_t))
{
  *((_BYTE *)this + 4std::ostream::~ostream(v1, v2 + 8) = 0;
  FileSource = RDQSRSoundSource::CreateFileSource( a2,  (const __CFURL *)RDQSREngine::EndOfFileCallback,  (void (*)(RDQSRSoundSource *, const __int16 *, uint64_t))RDQSREngine::RequestSamplesCallback,  a4);
  RDQSREngine::UseAudioSource(this, FileSource);
}

void RDQSREngine::EndOfFileCallback(RDQSREngine *this, RDQSRSoundSource *a2)
{
}

void RDQSREngine::UseMixedAudio(RDQSREngine *this, void (*a2)(RDQSRSoundSource *))
{
  if (!*((void *)this + 5))
  {
    *((_BYTE *)this + 4std::ostream::~ostream(v1, v2 + 8) = 1;
    MixedSource = RDQSRSoundSource::CreateMixedSource( (RDQSRSoundSource *)RDQSREngine::RequestSamplesCallback,  (void (*)(RDQSRSoundSource *))RDQSREngine::EndOfAudioCallback,  a2);
    RDQSREngine::UseAudioSource(this, MixedSource);
  }

uint64_t RDQSREngine::EndOfAudioCallback(RDQSREngine *this, RDQSRSoundSource *a2)
{
  return RDQSREngine::EndOfAudio((RDQSREngine *)RDQSREngine::sInstance, a2);
}

void RDQSREngine::UseCannedAudio( RDQSREngine *this, RDQSRSoundSource *a2, void (*a3)(RDQSRSoundSource *, const __int16 *, uint64_t))
{
  *((_BYTE *)this + 4std::ostream::~ostream(v1, v2 + 8) = 0;
  CannedSource = (RDQSRSoundSource *)RDQSRSoundSource::CreateCannedSource(a2, RDQSREngine::RequestSamplesCallback, a3);
  RDQSREngine::UseAudioSource(this, CannedSource);
}

void RDQSREngine::EndOfFile(RDQSREngine *this, RDQSRSoundSource *a2)
{
}

uint64_t RDQSREngine::EndOfAudio(RDQSREngine *this, RDQSRSoundSource *a2)
{
  uint64_t v3 = (pthread_mutex_t *)((char *)this + 232);
  uint64_t result = pthread_mutex_lock((pthread_mutex_t *)((char *)this + 232));
  if (*((void *)this + 28))
  {
    if (RXAutomationModeResult() || RXAutomationModeSynthesis() || RXAutomationModeFileName())
    {
      BOOL v5 = (os_log_s *)RXOSLog();
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)__int128 buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "Ending audio", buf, 2u);
      }

      RDASRWSpeechRecognitionAudioBufferEndAudio(*((void *)this + 28));
      if (*((_BYTE *)this + 216))
      {
        if (RXAutomationModeSynthesis() || RXAutomationModeFileName())
        {
          uint64_t v6 = RXAutomationSimulateOpenMic();
          if ((v6 & 1) == 0)
          {
            char v7 = (dispatch_queue_s *)RDQSRAudioFileLogger::audioFileLoggerQueue((RDQSRAudioFileLogger *)v6);
            block[0] = _NSConcreteStackBlock;
            block[1] = 0x40000000LL;
            block[2] = sub_100031734;
            block[3] = &unk_1000CEE38;
            block[4] = this;
            dispatch_async(v7, block);
          }
        }

        RDQSREngine::logAudioSamples(this, 0LL, 0LL);
        CFStringRef v9 = (dispatch_queue_s *)RDQSRAudioFileLogger::audioFileLoggerQueue(v8);
        v10[0] = _NSConcreteStackBlock;
        v10[1] = 0x40000000LL;
        v10[2] = sub_100031834;
        void v10[3] = &unk_1000CEE58;
        v10[4] = this;
        dispatch_async(v9, v10);
      }
    }

    return pthread_mutex_unlock(v3);
  }

  return result;
}

uint64_t sub_100031734(uint64_t result)
{
  *(_BYTE *)(*(void *)(result + 32) + 85LL) = 0;
  return result;
}

void RDQSREngine::logAudioSamples(RDQSREngine *this, const __int16 *a2, uint64_t a3)
{
  uint64_t v6 = (RDQSRAudioFileLogger *)sub_100034EC4(&v13, a3);
  if (a3) {
    uint64_t v6 = (RDQSRAudioFileLogger *)memmove(v13, a2, 2 * a3);
  }
  char v7 = (dispatch_queue_s *)RDQSRAudioFileLogger::audioFileLoggerQueue(v6);
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 1174405120LL;
  v8[2] = sub_1000319E0;
  void v8[3] = &unk_1000CEE78;
  v8[4] = this;
  __int128 __p = 0LL;
  int v10 = 0LL;
  uint64_t v11 = 0LL;
  sub_100034FA0(&__p, v13, (uint64_t)v14, (v14 - (_BYTE *)v13) >> 1);
  uint64_t v12 = a3;
  dispatch_async(v7, v8);
  if (__p)
  {
    int v10 = __p;
    operator delete(__p);
  }

  if (v13)
  {
    __int16 v14 = v13;
    operator delete(v13);
  }

void sub_100031818(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)(v1 - 56);
  if (v3)
  {
    *(void *)(v1 - 4std::ostream::~ostream(v1, v2 + 8) = v3;
    operator delete(v3);
  }

  _Unwind_Resume(exception_object);
}

void sub_100031834(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  uint64_t v2 = (char *)operator new(0x20uLL);
  *((_DWORD *)v2 + 2) = 48000;
  *(void *)uint64_t v2 = operator new[](0x17700uLL);
  *(void *)(v2 + 2sub_10001AFB0((std::locale *)v24, " +$", 0) = 0LL;
  *(void *)(v2 + 12) = 0LL;
  sub_100031898((void ***)(v1 + 200), (void **)v2);
}

void sub_100031884(_Unwind_Exception *a1)
{
}

void sub_100031898(void ***a1, void **a2)
{
  uint64_t v2 = *a1;
  *a1 = a2;
  if (v2)
  {
    if (*v2) {
      operator delete[](*v2);
    }
    operator delete(v2);
  }

uint64_t RDQSREngine::RequestSamples(RDQSREngine *this, RDQSRSoundSource *a2, __int16 *a3, uint64_t a4)
{
  char v7 = (pthread_mutex_t *)((char *)this + 232);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 232));
  CFTypeID v8 = (void *)*((void *)this + 28);
  if (v8)
  {
    id v9 = RDASRWSpeechRecognitionAudioBufferAddAudioSamples(v8, (uint64_t)a3, a4);
    if (*((_BYTE *)this + 216))
    {
      if ((RXAutomationSimulateOpenMic() & 1) == 0) {
        *((_BYTE *)this + 85) = 1;
      }
      RDQSREngine::logAudioSamples(this, a3, a4);
    }

    if (*((_BYTE *)this + 10) && RXIsAudioDonationOptedIn(v9) && *((_BYTE *)this + 86))
    {
      pthread_mutex_lock((pthread_mutex_t *)((char *)this + 296));
      RDQSRCircularBuffer<short>::write(*((void *)this + 26), (char *)a3, a4);
      pthread_mutex_unlock((pthread_mutex_t *)((char *)this + 296));
    }
  }

  else
  {
    int v10 = (os_log_s *)RXOSLog();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t v12 = 0;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "AudioBuffer is nil.", v12, 2u);
    }
  }

  return pthread_mutex_unlock(v7);
}

void *sub_1000319E0(uint64_t a1, const __CFString *a2)
{
  uint64_t v3 = *(void *)(a1 + 32);
  unsigned __int8 v4 = atomic_load((unsigned __int8 *)&qword_1000DDD70);
  if ((v4 & 1) == 0 && __cxa_guard_acquire(&qword_1000DDD70))
  {
    qword_1000DDD68 = 0LL;
    __cxa_atexit((void (*)(void *))sub_100031BC0, &qword_1000DDD68, (void *)&_mh_execute_header);
    __cxa_guard_release(&qword_1000DDD70);
  }

  if (*(_BYTE *)(v3 + 85))
  {
    if (!qword_1000DDD68)
    {
      CacheURLWithFilename = RDQSRAudioFileLogger::createCacheURLWithFilename(@"srcLogAudioFile.wav", a2);
      *(_BYTE *)(v3 + 217) = 1;
      uint64_t v6 = (RDQSRAudioFileLogger *)operator new(8uLL);
      *(void *)uint64_t v6 = 0LL;
      sub_100034F74((RDQSRAudioFileLogger **)&qword_1000DDD68, v6);
      char v7 = (ExtAudioFileRef *)qword_1000DDD68;
      RDQSRAudioFileLogger::wavFormat((uint64_t)&v11);
      word_1000DDD78 = RDQSRAudioFileLogger::openAudioFile(v7, CacheURLWithFilename, &v11, 0x57415645u);
      if (CacheURLWithFilename) {
        CFRelease(CacheURLWithFilename);
      }
      do
      {
        unint64_t v8 = RDQSRCircularBuffer<short>::read(*(void *)(v3 + 200), 0x800uLL, (char *)__dst);
        if (!word_1000DDD78) {
          RDQSRAudioFileLogger::addSamples((ExtAudioFileRef *)qword_1000DDD68, __dst, v8);
        }
      }

      while (v8 > 0x7FF);
    }

    if (!word_1000DDD78) {
      RDQSRAudioFileLogger::addSamples((ExtAudioFileRef *)qword_1000DDD68, *(__int16 **)(a1 + 40), *(void *)(a1 + 64));
    }
  }

  else
  {
    if (qword_1000DDD68) {
      BOOL v9 = word_1000DDD78 == 0;
    }
    else {
      BOOL v9 = 0;
    }
    if (v9) {
      sub_100034F74((RDQSRAudioFileLogger **)&qword_1000DDD68, 0LL);
    }
  }

  return RDQSRCircularBuffer<short>::write(*(void *)(v3 + 200), *(char **)(a1 + 40), *(_DWORD *)(a1 + 64));
}

RDQSRAudioFileLogger **sub_100031BC0(RDQSRAudioFileLogger **a1)
{
  return a1;
}

void *sub_100031BE8(uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + 4sub_10001AFB0((std::locale *)v24, " +$", 0) = 0LL;
  *(void *)(a1 + 4std::ostream::~ostream(v1, v2 + 8) = 0LL;
  uint64_t v2 = (void *)(a1 + 40);
  v2[2] = 0LL;
  return sub_100034FA0( v2,  *(const void **)(a2 + 40),  *(void *)(a2 + 48),  (uint64_t)(*(void *)(a2 + 48) - *(void *)(a2 + 40)) >> 1);
}

void sub_100031C04(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 40);
  if (v2)
  {
    *(void *)(a1 + 4std::ostream::~ostream(v1, v2 + 8) = v2;
    operator delete(v2);
  }

void RDQSREngine::removeLogAudioFile(RDQSREngine *this)
{
  if (*((_BYTE *)this + 217))
  {
    uint64_t v1 = (dispatch_queue_s *)RDQSRAudioFileLogger::audioFileLoggerQueue(this);
    dispatch_sync(v1, &stru_1000CEEC8);
  }

void sub_100031C48(id a1)
{
  CacheURLWithFilename = RDQSRAudioFileLogger::createCacheURLWithFilename(@"srcLogAudioFile.wav", v1);
  RDURL::RDURL((RDURL *)__p, CacheURLWithFilename, 1);
  if (v5 >= 0) {
    uint64_t v3 = __p;
  }
  else {
    uint64_t v3 = (void **)__p[0];
  }
  removefile((const char *)v3, 0LL, 2u);
  if (v5 < 0) {
    operator delete(__p[0]);
  }
}

void sub_100031CB4( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t RDQSREngine::fullModelDir(RDQSREngine *this)
{
  return *((void *)this + 24);
}

uint64_t RDQSREngine::AddPeer(uint64_t result, uint64_t a2)
{
  *(void *)(a2 + 232) = *(void *)(result + 144);
  *(void *)(result + 144) = a2;
  return result;
}

void *RDQSREngine::RemovePeer(void *result, uint64_t a2)
{
  uint64_t v3 = result;
  uint64_t v4 = result[7] - 1LL;
  result[7] = v4;
  if (!v4)
  {
    uint64_t result = (void *)result[5];
    if (result)
    {
      uint64_t result = (void *)(*(uint64_t (**)(void *))(*result + 48LL))(result);
      v3[5] = 0LL;
      *((_BYTE *)v3 + 83) = 0;
    }
  }

  uint64_t v7 = v3[18];
  uint64_t v6 = v3 + 18;
  uint64_t v5 = v7;
  if (v7)
  {
    if (v5 == a2)
    {
LABEL_9:
      void *v6 = *(void *)(a2 + 232);
    }

    else
    {
      while (1)
      {
        uint64_t v8 = v5;
        uint64_t v5 = *(void *)(v5 + 232);
        if (!v5) {
          break;
        }
        if (v5 == a2)
        {
          uint64_t v6 = (void *)(v8 + 232);
          goto LABEL_9;
        }
      }
    }
  }

  return result;
}

BOOL RDQSREngine::PeerExists(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = (void *)(a1 + 144);
  do
  {
    uint64_t v3 = *v2;
    uint64_t v2 = (void *)(*v2 + 232LL);
  }

  while (v3 != a2 && v3 != 0);
  return v3 != 0;
}

uint64_t RDQSREngine::AddGrammar(uint64_t a1, uint64_t a2)
{
  uint64_t v5 = (void **)(a1 + 112);
  uint64_t v4 = *(void *)(a1 + 112);
  int v6 = *(unsigned __int16 *)(a1 + 80);
  *(_WORD *)(a1 + 8sub_10001AFB0((std::locale *)v24, " +$", 0) = v6 + 1;
  unint64_t v7 = *(void *)(a1 + 64);
  unint64_t v8 = *(void *)(a1 + 120);
  if (v7 >= (uint64_t)(v8 - v4) >> 4)
  {
    uint64_t v10 = (uint64_t)(v8 - v4) >> 4;
    uint64_t v12 = a1 + 128;
    unint64_t v13 = *(void *)(a1 + 128);
    if (v8 >= v13)
    {
      uint64_t v15 = v13 - v4;
      uint64_t v16 = v15 >> 3;
      else {
        unint64_t v17 = v16;
      }
      if (v17) {
        CFTypeID v18 = (char *)sub_1000198A8(v12, v17);
      }
      else {
        CFTypeID v18 = 0LL;
      }
      __int16 v19 = &v18[16 * v10];
      CFIndex v20 = &v18[16 * v17];
      *(void *)__int16 v19 = a2;
      *((_WORD *)v19 + 4) = 256;
      *((_WORD *)v19 + 5) = v6;
      __int16 v14 = v19 + 16;
      CFRange v22 = *(char **)(a1 + 112);
      CFRange v21 = *(char **)(a1 + 120);
      if (v21 != v22)
      {
        do
        {
          *((_OWORD *)v19 - 1) = *((_OWORD *)v21 - 1);
          v19 -= 16;
          v21 -= 16;
        }

        while (v21 != v22);
        CFRange v21 = (char *)*v5;
      }

      *(void *)(a1 + 112) = v19;
      *(void *)(a1 + 12sub_10001AFB0((std::locale *)v24, " +$", 0) = v14;
      *(void *)(a1 + 12std::ostream::~ostream(v1, v2 + 8) = v20;
      if (v21) {
        operator delete(v21);
      }
    }

    else
    {
      *(void *)unint64_t v8 = a2;
      *(_WORD *)(v8 + std::ostream::~ostream(v1, v2 + 8) = 256;
      *(_WORD *)(v8 + 1sub_10001AFB0((std::locale *)v24, " +$", 0) = v6;
      __int16 v14 = (char *)(v8 + 16);
    }

    *(void *)(a1 + 12sub_10001AFB0((std::locale *)v24, " +$", 0) = v14;
    unint64_t v7 = *(void *)(a1 + 64);
  }

  else
  {
    uint64_t v9 = v4 - 8;
    uint64_t v10 = -1LL;
    do
    {
      uint64_t v11 = *(void *)(v9 + 8);
      ++v10;
      v9 += 16LL;
    }

    while (v11);
    *(void *)(v9 - std::ostream::~ostream(v1, v2 + 8) = a2;
    *(_WORD *)uint64_t v9 = 256;
    *(_WORD *)(v9 + 2) = v6;
  }

  *(void *)(a1 + 64) = v7 + 1;
  return v10 | (v6 << 16);
}

uint64_t RDQSREngine::SynthesizeText(RDQSREngine *this, const __CFString *a2)
{
  return (*(uint64_t (**)(void, const __CFString *, void))(**((void **)this + 5) + 24LL))( *((void *)this + 5),  a2,  *((void *)this + 19));
}

uint64_t RDQSREngine::RecognizeAudioFile(RDQSREngine *this, const __CFString *a2)
{
  return (*(uint64_t (**)(void, const __CFString *))(**((void **)this + 5) + 32LL))( *((void *)this + 5),  a2);
}

void RDQSREngine::RecognizeText(RDQSREngine *this, CFTypeRef cf)
{
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 0x40000000LL;
  _DWORD v4[2] = sub_100031F98;
  v4[3] = &unk_1000CEEE8;
  v4[4] = this;
  v4[5] = cf;
  dispatch_async((dispatch_queue_t)gRDServerQueue, v4);
}

void sub_100031F98(uint64_t a1)
{
  uint64_t v2 = *(const void **)(a1 + 40);
  if (v2) {
    CFRelease(v2);
  }
}

RDQSRResultMatcher *RDQSREngine::DidRecognizeFinalResults(RDQSREngine *this, const __CFString *a2)
{
  uint64_t result = v4;
  uint64_t v4 = 0LL;
  if (result) {
    return (RDQSRResultMatcher *)(*(uint64_t (**)(RDQSRResultMatcher *))(*(void *)result + 24LL))(result);
  }
  return result;
}

void sub_100032034( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10) {
    (*(void (**)(uint64_t))(*(void *)a10 + 24LL))(a10);
  }
  _Unwind_Resume(exception_object);
}

id RDQSREngine::SetupRecognition(RDQSREngine *this)
{
  v7[0] = this;
  v7[1] = RDQSREngine::DisposeContextCallback;
  _OWORD v7[2] = RDQSREngine::DidRecognizePartialResultTokensCallback;
  v7[3] = RDQSREngine::DidFinishRecognitionWithErrorCallback;
  v7[4] = 0LL;
  void v7[5] = RDQSREngine::DidRecognizeFinalResultsWithPreITNCallback;
  void v7[6] = RDQSREngine::DidGetUtteranceBoundaryCallback;
  v7[7] = RDQSREngine::DidProcessAudioDurationCallback;
  if (*((_BYTE *)this + 400) && *((_BYTE *)this + 401) && (uint64_t v2 = *((void *)this + 18)) != 0)
  {
    uint64_t v3 = @"DictationCC";
    while (!*(_BYTE *)(v2 + 207))
    {
      uint64_t v2 = *(void *)(v2 + 232);
      if (!v2) {
        goto LABEL_9;
      }
    }

    uint64_t v3 = @"SpellCC";
  }

  else
  {
    uint64_t v3 = @"DictationCC";
  }

LABEL_9:
  *((void *)this + 49) = v3;
  id result = RDASRWSpeechRecognizerCreateRecognitionBuffer( *((void **)this + 2),  *((void *)this + 19),  (uint64_t)v3,  16000LL,  (uint64_t)v7);
  *((void *)this + 2std::ostream::~ostream(v1, v2 + 8) = result;
  if (!result)
  {
    uint64_t v5 = (os_log_s *)RXOSLog();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)int v6 = 0;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "Could not initialize audio buffer", v6, 2u);
    }

    sub_100033288((uint64_t)@"Could not initialize audio buffer");
  }

  return result;
}

  *a2 = v5;
  return result;
}

  *a2 = v5;
  return result;
}

  uint64_t v10 = (*(uint64_t (**)(void *, uint64_t, void))(*a1 + 56LL))(a1, 0xFFFFFFFF0004LL, 0LL);
  sub_10000A2DC(__p, "vector");
  uint64_t v11 = v10 | 3;
  sub_10002C3E0((uint64_t)a1, (uint64_t)a2, (_BYTE *)a3, 2, __p, v11, (uint64_t)&v31 + 4);
  CFIndex v30 = v7;
  uint64_t v12 = *(void *)(a1[1] + 64LL) - *(void *)(a1[1] + 56LL);
  unint64_t v13 = v12 >> 3;
  if ((int)(v12 >> 3) < 1)
  {
    LODWORD(v13) = 0;
  }

  else
  {
    __int16 v14 = v8;
    uint64_t v15 = 0LL;
    uint64_t v16 = (v12 >> 3);
    do
    {
      (*(void (**)(void **__return_ptr, void *, uint64_t))(*a1 + 24LL))(&v31, a1, v15);
      LODWORD(__p[0].__r_.__value_.__l.__data_) = (_DWORD)v31;
      std::ostream::write(a2, __p, 4LL);
      __p[0].__r_.__value_.__r.__words[0] = (*(uint64_t (**)(void *, uint64_t))(*a1 + 32LL))(a1, v15);
      std::ostream::write(a2, __p, 8LL);
      unint64_t v17 = *(void *)(*(void *)(a1[1] + 56LL) + 8 * v15);
      CFTypeID v18 = *(void *)(v17 + 24);
      __int16 v19 = *(void *)(v17 + 32);
      if (v18 == v19) {
        CFIndex v20 = 0LL;
      }
      else {
        CFIndex v20 = *(void *)(v17 + 24);
      }
      if (v18 != v19)
      {
        CFRange v21 = (v19 - v18) >> 4;
        if (v21 <= 1) {
          CFRange v22 = 1LL;
        }
        else {
          CFRange v22 = v21;
        }
        uint64_t v23 = (_DWORD *)(v20 + 8);
        do
        {
          LODWORD(__p[0].__r_.__value_.__l.__data_) = *(v23 - 2);
          std::ostream::write(a2, __p, 4LL);
          LODWORD(__p[0].__r_.__value_.__l.__data_) = *(v23 - 1);
          std::ostream::write(a2, __p, 4LL);
          LODWORD(__p[0].__r_.__value_.__l.__data_) = *v23;
          std::ostream::write(a2, __p, 4LL);
          LODWORD(__p[0].__r_.__value_.__l.__data_) = v23[1];
          std::ostream::write(a2, __p, 4LL);
          v23 += 4;
          --v22;
        }

        while (v22);
      }

      ++v15;
    }

    while (v15 != v16);
    unint64_t v8 = v14;
  }

  std::ostream::flush(a2);
  if ((*((_BYTE *)a2 + *(void *)(*a2 - 24LL) + 32) & 5) != 0)
  {
    sub_10000A2DC(__p, "ERROR");
    sub_10002A9EC((BOOL *)&v31, (uint64_t)__p);
    uint64_t v24 = sub_10002A6A4(&std::cerr, (uint64_t)"VectorFst::Write: Write failed: ", 32LL);
    uint64_t v25 = *(char *)(a3 + 23);
    if (v25 >= 0) {
      CFMutableStringRef v26 = a3;
    }
    else {
      CFMutableStringRef v26 = *(void *)a3;
    }
    if (v25 >= 0) {
      uint64_t v27 = *(unsigned __int8 *)(a3 + 23);
    }
    else {
      uint64_t v27 = *(void *)(a3 + 8);
    }
    sub_10002A6A4(v24, v26, v27);
LABEL_33:
    sub_10002AA94(&v31);
    id v28 = 0LL;
    goto LABEL_36;
  }

  if (!v8)
  {
    if (v37 == v13)
    {
      id v28 = 1LL;
      goto LABEL_36;
    }

    sub_10000A2DC(__p, "ERROR");
    sub_10002A9EC((BOOL *)&v31, (uint64_t)__p);
    sub_10002A6A4(&std::cerr, (uint64_t)"Inconsistent number of states observed during write", 51LL);
    goto LABEL_33;
  }

  CFIndex v37 = v13;
  sub_10000A2DC(__p, "vector");
  id v28 = sub_10002C544((uint64_t)a1, a2, a3, 2, __p, v11, (uint64_t)&v31 + 4, v30);
LABEL_36:
  if (SHIBYTE(v34) < 0) {
    operator delete(v33[1]);
  }
  if (SHIBYTE(v33[0]) < 0) {
    operator delete(v32[0]);
  }
  return v28;
}

  uint64_t v12 = v8;
  if ((unint64_t)v8 < v9)
  {
    unint64_t v13 = v9;
    do
    {
      __int16 v14 = *v12;
      uint64_t v15 = *((_DWORD *)v12 + 2);
      uint64_t v16 = *((_DWORD *)v12 + 3);
      *uint64_t v12 = *(void *)v13;
      *((_DWORD *)v12 + 2) = *(_DWORD *)(v13 + 8);
      *((_DWORD *)v12 + 3) = *(_DWORD *)(v13 + 12);
      *(void *)unint64_t v13 = v14;
      *(_DWORD *)(v13 + std::ostream::~ostream(v1, v2 + 8) = v15;
      *(_DWORD *)(v13 + 12) = v16;
      do
      {
        unint64_t v17 = *((_DWORD *)v12 + 5);
        v12 += 2;
      }

      while (v17 < (int)v6);
      do
      {
        CFTypeID v18 = *(_DWORD *)(v13 - 12);
        v13 -= 16LL;
      }

      while (v18 >= (int)v6);
    }

    while ((unint64_t)v12 < v13);
  }

  if (v12 - 2 != a1)
  {
    *a1 = *(v12 - 2);
    *((_DWORD *)a1 + 2) = *((_DWORD *)v12 - 2);
    *((_DWORD *)a1 + 3) = *((_DWORD *)v12 - 1);
  }

  *(v12 - 2) = v3;
  *((_DWORD *)v12 - 2) = v4;
  *((_DWORD *)v12 - 1) = v5;
  return v12 - 2;
}

  uint64_t v10 = (*(uint64_t (**)(void *, uint64_t, void))(*a1 + 56LL))(a1, 0xFFFFFFFF0004LL, 0LL);
  sub_10000A2DC(__p, "vector");
  uint64_t v11 = v10 | 3;
  sub_10008A14C((uint64_t)a1, (uint64_t)a2, (_BYTE *)a3, 2, __p, v11, (uint64_t)&v31 + 4);
  CFIndex v30 = v7;
  uint64_t v12 = *(void *)(a1[1] + 64LL) - *(void *)(a1[1] + 56LL);
  unint64_t v13 = v12 >> 3;
  if ((int)(v12 >> 3) < 1)
  {
    LODWORD(v13) = 0;
  }

  else
  {
    __int16 v14 = v8;
    uint64_t v15 = 0LL;
    uint64_t v16 = (v12 >> 3);
    do
    {
      (*(void (**)(void **__return_ptr, void *, uint64_t))(*a1 + 24LL))(&v31, a1, v15);
      LODWORD(__p[0].__r_.__value_.__l.__data_) = (_DWORD)v31;
      std::ostream::write(a2, __p, 4LL);
      __p[0].__r_.__value_.__r.__words[0] = (*(uint64_t (**)(void *, uint64_t))(*a1 + 32LL))(a1, v15);
      std::ostream::write(a2, __p, 8LL);
      unint64_t v17 = *(void *)(*(void *)(a1[1] + 56LL) + 8 * v15);
      CFTypeID v18 = *(void *)(v17 + 24);
      __int16 v19 = *(void *)(v17 + 32);
      if (v18 == v19) {
        CFIndex v20 = 0LL;
      }
      else {
        CFIndex v20 = *(void *)(v17 + 24);
      }
      if (v18 != v19)
      {
        CFRange v21 = (v19 - v18) >> 4;
        if (v21 <= 1) {
          CFRange v22 = 1LL;
        }
        else {
          CFRange v22 = v21;
        }
        uint64_t v23 = (_DWORD *)(v20 + 8);
        do
        {
          LODWORD(__p[0].__r_.__value_.__l.__data_) = *(v23 - 2);
          std::ostream::write(a2, __p, 4LL);
          LODWORD(__p[0].__r_.__value_.__l.__data_) = *(v23 - 1);
          std::ostream::write(a2, __p, 4LL);
          LODWORD(__p[0].__r_.__value_.__l.__data_) = *v23;
          std::ostream::write(a2, __p, 4LL);
          LODWORD(__p[0].__r_.__value_.__l.__data_) = v23[1];
          std::ostream::write(a2, __p, 4LL);
          v23 += 4;
          --v22;
        }

        while (v22);
      }

      ++v15;
    }

    while (v15 != v16);
    unint64_t v8 = v14;
  }

  std::ostream::flush(a2);
  if ((*((_BYTE *)a2 + *(void *)(*a2 - 24LL) + 32) & 5) != 0)
  {
    sub_10000A2DC(__p, "ERROR");
    sub_10002A9EC((BOOL *)&v31, (uint64_t)__p);
    uint64_t v24 = sub_10002A6A4(&std::cerr, (uint64_t)"VectorFst::Write: Write failed: ", 32LL);
    uint64_t v25 = *(char *)(a3 + 23);
    if (v25 >= 0) {
      CFMutableStringRef v26 = a3;
    }
    else {
      CFMutableStringRef v26 = *(void *)a3;
    }
    if (v25 >= 0) {
      uint64_t v27 = *(unsigned __int8 *)(a3 + 23);
    }
    else {
      uint64_t v27 = *(void *)(a3 + 8);
    }
    sub_10002A6A4(v24, v26, v27);
LABEL_33:
    sub_10002AA94(&v31);
    id v28 = 0LL;
    goto LABEL_36;
  }

  if (!v8)
  {
    if (v37 == v13)
    {
      id v28 = 1LL;
      goto LABEL_36;
    }

    sub_10000A2DC(__p, "ERROR");
    sub_10002A9EC((BOOL *)&v31, (uint64_t)__p);
    sub_10002A6A4(&std::cerr, (uint64_t)"Inconsistent number of states observed during write", 51LL);
    goto LABEL_33;
  }

  CFIndex v37 = v13;
  sub_10000A2DC(__p, "vector");
  id v28 = sub_10008A2B0((uint64_t)a1, a2, a3, 2, __p, v11, (uint64_t)&v31 + 4, v30);
LABEL_36:
  if (SHIBYTE(v34) < 0) {
    operator delete(v33[1]);
  }
  if (SHIBYTE(v33[0]) < 0) {
    operator delete(v32[0]);
  }
  return v28;
}

void sub_100032170(uint64_t a1)
{
}

void RDQSREngine::RemoveGrammar(RDQSREngine *this, unsigned __int16 a2)
{
  uint64_t v2 = *((void *)this + 14) + 16LL * a2;
  *(void *)uint64_t v2 = 0LL;
  int v3 = *(unsigned __int8 *)(v2 + 8);
  int v4 = *(unsigned __int8 *)(v2 + 9);
  if (v3) {
    BOOL v5 = v4 == 0;
  }
  else {
    BOOL v5 = 1;
  }
  if (!v5)
  {
    uint64_t v6 = *((void *)this + 9) - 1LL;
    *((void *)this + 9) = v6;
    if (!v6) {
      RDQSREngine::SetMicState(this, 0, "Last live grammar removed");
    }
  }

uint64_t RDQSREngine::FindGrammar(RDQSREngine *this, unint64_t a2)
{
  uint64_t v2 = *((void *)this + 14);
  if ((unsigned __int16)a2 < (unint64_t)((*((void *)this + 15) - v2) >> 4)
    && *(unsigned __int16 *)(v2 + 16LL * (unsigned __int16)a2 + 10) == a2 >> 16)
  {
    return *(void *)(v2 + 16LL * (unsigned __int16)a2);
  }

  else
  {
    return 0LL;
  }

RDQSREngine *RDQSREngine::GrammarIsLive(RDQSREngine *this, unsigned __int16 a2, int a3)
{
  uint64_t v3 = *((void *)this + 14);
  uint64_t v4 = v3 + 16LL * a2;
  int v6 = *(unsigned __int8 *)(v4 + 8);
  BOOL v5 = (_BYTE *)(v4 + 8);
  if (v6 != a3)
  {
    _BYTE *v5 = a3;
    if (*(_BYTE *)(v3 + 16LL * a2 + 9))
    {
      uint64_t v7 = *((void *)this + 9);
      if (a3)
      {
        *((void *)this + 9) = v7 + 1;
        if (!v7)
        {
          unint64_t v8 = "First grammar went live";
          BOOL v9 = 1;
          return (RDQSREngine *)RDQSREngine::SetMicState(this, v9, v8);
        }
      }

      else
      {
        uint64_t v10 = v7 - 1;
        *((void *)this + 9) = v10;
        if (!v10)
        {
          unint64_t v8 = "Last grammar went dead";
          BOOL v9 = 0;
          return (RDQSREngine *)RDQSREngine::SetMicState(this, v9, v8);
        }
      }
    }
  }

  return this;
}

void RDQSREngine::CanListen(RDQSREngine *this, RDQSRPeer *a2, char a3)
{
  uint64_t v5 = *((void *)this + 14);
  uint64_t v6 = *((void *)this + 15);
  if ((a3 & 1) != 0)
  {
    if (v6 != v5)
    {
      uint64_t v7 = 0LL;
      unint64_t v8 = 0LL;
      do
      {
        uint64_t v9 = *(void *)(v5 + v7);
        if (v9)
        {
          if (*(RDQSRPeer **)(v9 + 24) == a2)
          {
            uint64_t v10 = v5 + v7;
            if (!*(_BYTE *)(v5 + v7 + 9))
            {
              *(_BYTE *)(v10 + 9) = 1;
              if (*(_BYTE *)(v10 + 8))
              {
                uint64_t v11 = *((void *)this + 9);
                *((void *)this + 9) = v11 + 1;
                if (!v11)
                {
                  RDQSREngine::SetMicState(this, 1, "First grammar is listening");
                  uint64_t v5 = *((void *)this + 14);
                  uint64_t v6 = *((void *)this + 15);
                }
              }
            }
          }
        }

        ++v8;
        v7 += 16LL;
      }

      while (v8 < (v6 - v5) >> 4);
    }
  }

  else
  {
    uint64_t v12 = v6 - v5;
    if (v6 != v5)
    {
      uint64_t v13 = 0LL;
      char v14 = 0;
      unint64_t v15 = v12 >> 4;
      if (v15 <= 1) {
        unint64_t v15 = 1LL;
      }
      uint64_t v16 = -(uint64_t)v15;
      uint64_t v17 = v5 + 9;
LABEL_16:
      CFTypeID v18 = (_BYTE *)(v17 + 16 * v13++);
      do
      {
        uint64_t v19 = *(void *)(v18 - 9);
        if (v19)
        {
          if (*(RDQSRPeer **)(v19 + 24) == a2)
          {
            if (*v18)
            {
              *CFTypeID v18 = 0;
              if (*(v18 - 1))
              {
                --*((void *)this + 9);
                char v14 = 1;
                if (v16 + v13) {
                  goto LABEL_16;
                }
                goto LABEL_26;
              }
            }
          }
        }

        ++v13;
        v18 += 16;
      }

      while (v16 + v13 != 1);
      if ((v14 & 1) == 0) {
        return;
      }
LABEL_26:
      *((_BYTE *)this + 84) = 1;
      (*(void (**)(void))(**((void **)this + 5) + 16LL))(*((void *)this + 5));
    }
  }

void RDQSREngine::FilterProfanity(void **this, int a2)
{
  if (!a2)
  {
    CFMutableStringRef Mutable = (const char *)CFDictionaryCreateMutable(0LL, 0LL, 0LL, 0LL);
    RDASRWSpeechRecognizerSetRecognitionReplacements(this[2], Mutable);
    CFRelease(Mutable);
    uint64_t v4 = (os_log_s *)RXOSLog();
    if (!os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT)) {
      return;
    }
    *(_WORD *)uint64_t v10 = 0;
    uint64_t v5 = "No profanity filter set";
    goto LABEL_9;
  }

  block[0] = _NSConcreteStackBlock;
  block[1] = 0x40000000LL;
  block[2] = sub_100032530;
  block[3] = &unk_1000CEF28;
  block[4] = this;
  if (qword_1000DDD88 != -1) {
    dispatch_once(&qword_1000DDD88, block);
  }
  uint64_t v3 = (const char *)this[48];
  if (v3)
  {
    RDASRWSpeechRecognizerSetRecognitionReplacements(this[2], v3);
    uint64_t v4 = (os_log_s *)RXOSLog();
    if (!os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT)) {
      return;
    }
    *(_WORD *)uint64_t v10 = 0;
    uint64_t v5 = "Successfully filtering profanity";
LABEL_9:
    uint64_t v7 = v4;
    os_log_type_t v8 = OS_LOG_TYPE_DEFAULT;
LABEL_10:
    _os_log_impl((void *)&_mh_execute_header, v7, v8, v5, v10, 2u);
    return;
  }

  uint64_t v9 = (os_log_s *)RXOSLog();
  if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)uint64_t v10 = 0;
    uint64_t v5 = "Error in filtering profanity";
    uint64_t v7 = v9;
    os_log_type_t v8 = OS_LOG_TYPE_ERROR;
    goto LABEL_10;
  }

void sub_100032530(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  uint64_t v2 = *(const __CFString **)(v1 + 376);
  if (v2)
  {
    *(void *)(v1 + 384) = RDQSRReplacementDictationaryWithEtiquettes(v2);
  }

  else
  {
    uint64_t v3 = (os_log_s *)RXOSLog();
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)uint64_t v4 = 0;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_ERROR, "Error in reading etiquettes file", v4, 2u);
    }
  }

void RDQSREngine::BuildCombinedGrammar(RDQSREngine *this)
{
  *((_BYTE *)this + 87) = 1;
  block[0] = _NSConcreteStackBlock;
  block[1] = 0x40000000LL;
  block[2] = sub_10003260C;
  block[3] = &unk_1000CEF48;
  block[4] = this;
  dispatch_async((dispatch_queue_t)gRDServerQueue, block);
}

void sub_10003260C(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  if (!*(_BYTE *)(v1 + 87)) {
    return;
  }
  *(_BYTE *)(v1 + 87) = 0;
  *(void *)(v1 + 176) = 1LL;
  sub_10000A2DC(&v42, "");
  uint64_t v2 = *(void *)(v1 + 112);
  if (*(void *)(v1 + 120) == v2) {
    goto LABEL_82;
  }
  uint64_t v3 = 0LL;
  unint64_t v4 = 0LL;
  uint64_t v5 = 0LL;
  do
  {
    uint64_t v6 = *(void *)(v2 + v3);
    if (!v6) {
      goto LABEL_77;
    }
    BOOL v7 = !*(void *)(v6 + 32) || *(_BYTE *)(v2 + v3 + 8) == 0;
    if (v7 || *(_BYTE *)(v2 + v3 + 9) == 0) {
      goto LABEL_77;
    }
    unint64_t v9 = *(void *)(v1 + 176);
    if (v9 <= *(void *)(v6 + 56)) {
      unint64_t v9 = *(void *)(v6 + 56);
    }
    *(void *)(v1 + 176) = v9;
    uint64_t v10 = *(void **)(v6 + 64);
    if (v10)
    {
      string = (char *)xpc_dictionary_get_string(v10, kRDKeyCategoryID);
      sub_10000A2DC(&__str, string);
      if ((v42.__r_.__value_.__s.__size_ & 0x80u) == 0) {
        std::string::size_type size = v42.__r_.__value_.__s.__size_;
      }
      else {
        std::string::size_type size = v42.__r_.__value_.__l.__size_;
      }
      if ((v42.__r_.__value_.__s.__size_ & 0x80u) == 0) {
        uint64_t v13 = &v42;
      }
      else {
        uint64_t v13 = (std::string *)v42.__r_.__value_.__r.__words[0];
      }
      if ((__str.__r_.__value_.__s.__size_ & 0x80u) == 0) {
        std::string::size_type v14 = __str.__r_.__value_.__s.__size_;
      }
      else {
        std::string::size_type v14 = __str.__r_.__value_.__l.__size_;
      }
      if ((__str.__r_.__value_.__s.__size_ & 0x80u) == 0) {
        p_str = &__str;
      }
      else {
        p_str = (std::string *)__str.__r_.__value_.__r.__words[0];
      }
      if (v14 >= size) {
        size_t v16 = size;
      }
      else {
        size_t v16 = v14;
      }
      if (!memcmp(v13, p_str, v16) && v14 == size)
      {
        CFTypeID v18 = v5;
        if (!v5) {
          goto LABEL_65;
        }
      }

      else
      {
        std::string::operator=(&v42, &__str);
        RDQSRGrammarBuilder::buildCategoryFst( *(void **)(*(void *)(v2 + v3) + 64LL),  *(void *)(*(void *)(v2 + v3) + 24LL) + 40LL,  *(void *)(v1 + 160),  &buf);
        CFTypeID v18 = (void *)buf.__r_.__value_.__r.__words[0];
        buf.__r_.__value_.__r.__words[0] = 0LL;
        if (v5)
        {
          (*(void (**)(void *))(*v5 + 8LL))(v5);
          std::string::size_type v19 = buf.__r_.__value_.__r.__words[0];
          buf.__r_.__value_.__r.__words[0] = 0LL;
          if (v19) {
            (*(void (**)(std::string::size_type))(*(void *)v19 + 8LL))(v19);
          }
        }

        if ((__str.__r_.__value_.__s.__size_ & 0x80u) == 0) {
          CFIndex v20 = &__str;
        }
        else {
          CFIndex v20 = (std::string *)__str.__r_.__value_.__r.__words[0];
        }
        RDQSRGrammarBuilder::categoryProfile((char *)v20, v18, (uint64_t *)&buf);
        else {
          v21.__d_.__rep_ = 0LL;
        }
        RDQSREngine::AddTemplatesToUserProfile(v1, (uint64_t *)&buf);
        if (RXLogPerformance())
        {
          double v36 = rd_time_util::durationInMilliSec(v21.__d_.__rep_);
          CFIndex v37 = (os_log_s *)RXOSLog();
          if (os_log_type_enabled(v37, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)CFRange v43 = 134217984;
            *(double *)&v43[4] = v36;
            _os_log_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_DEFAULT, "Adding to profile - %f", v43, 0xCu);
          }
        }

        *(void *)CFRange v43 = &buf;
        sub_10002E258((void ***)v43);
        if (!v18) {
          goto LABEL_65;
        }
      }

      RDQSRGrammarBuilder::UpdateCategory(*(void *)(*(void *)(v2 + v3) + 40LL), string, (uint64_t)v18);
LABEL_65:
      *(void *)(*(void *)(v2 + v3) + 64LL) = 0LL;
      uint64_t v5 = v18;
      goto LABEL_77;
    }

    if (*(_BYTE *)(v6 + 48))
    {
      CFRange v22 = (os_log_s *)RXSignpostLog();
      if (os_signpost_enabled(v22))
      {
        LOWORD(__str.__r_.__value_.__l.__data_) = 0;
        _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v22,  OS_SIGNPOST_INTERVAL_BEGIN,  0xEEEEB0B5B2B2EEEELL,  "Grammar",  "Building Grammar",  (uint8_t *)&__str,  2u);
      }

      uint64_t v23 = (os_log_s *)RXOSLog();
      if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
      {
        std::string::size_type v24 = *(void *)(*(void *)(v2 + v3) + 16LL);
        LODWORD(__str.__r_.__value_.__l.__data_) = 134217984;
        *(std::string::size_type *)((char *)__str.__r_.__value_.__r.__words + 4) = v24;
        _os_log_impl( (void *)&_mh_execute_header,  v23,  OS_LOG_TYPE_DEFAULT,  "Building Grammar %zu",  (uint8_t *)&__str,  0xCu);
      }

      uint64_t v25 = *(void *)(v2 + v3);
      uint64_t v26 = *(void *)(v1 + 160);
      uint64_t v27 = operator new(0x40uLL);
      *(_BYTE *)uint64_t v27 = *(_BYTE *)(v25 + 50);
      v27[1] = v26;
      *((_BYTE *)v27 + 57) = 0;
      *((_OWORD *)v27 + 1) = 0u;
      *((_OWORD *)v27 + 2) = 0u;
      v27[6] = 0LL;
      uint64_t v28 = *(void *)(v2 + v3);
      uint64_t v31 = *(void *)(v28 + 40);
      CFIndex v30 = (void *)(v28 + 40);
      uint64_t v29 = v31;
      __str.__r_.__value_.__r.__words[0] = 0LL;
      *CFIndex v30 = v27;
      if (v31)
      {
        sub_100034D1C((uint64_t)v30, v29);
        uint64_t v32 = __str.__r_.__value_.__r.__words[0];
        __str.__r_.__value_.__r.__words[0] = 0LL;
        if (v32) {
          sub_100034D1C((uint64_t)&__str, v32);
        }
      }

      RDQSRGrammarBuilder::BuildGrammar( *(void *)(*(void *)(v2 + v3) + 40LL),  *(const __CFString **)(v1 + 152),  *(void **)(*(void *)(v2 + v3) + 32LL),  *(void *)(*(void *)(v2 + v3) + 24LL) + 40LL);
      memset(&__str, 0, sizeof(__str));
      uint64_t v33 = *(void *)(v2 + v3);
      if (*(_BYTE *)(*(void *)(v33 + 24) + 206LL) || *(_BYTE *)(v33 + 50)) {
        RDQSRGrammarBuilder::grammarProfile(*(RDQSRGrammarBuilder **)(v33 + 40), (uint64_t *)&buf);
      }
      else {
        RDQSRGrammarBuilder::fullGrammarProfile(*(RDQSRGrammarBuilder **)(v33 + 40), (uint64_t *)&buf);
      }
      sub_100035018((void **)&__str.__r_.__value_.__l.__data_);
      std::string __str = buf;
      memset(&buf, 0, sizeof(buf));
      *(void *)CFRange v43 = &buf;
      sub_10002E258((void ***)v43);
      *(_BYTE *)(*(void *)(v2 + v3) + 48LL) = 0;
      int64x2_t v34 = (os_log_s *)RXSignpostLog();
      if (os_signpost_enabled(v34))
      {
        LOWORD(buf.__r_.__value_.__l.__data_) = 0;
        _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v34,  OS_SIGNPOST_INTERVAL_BEGIN,  0xEEEEB0B5B2B2EEEELL,  "GrammarTemplates",  "Adding templates",  (uint8_t *)&buf,  2u);
      }

      else {
        v35.__d_.__rep_ = 0LL;
      }
      RDQSREngine::AddTemplatesToUserProfile(v1, (uint64_t *)&__str);
      if (RXLogPerformance())
      {
        double v38 = rd_time_util::durationInMilliSec(v35.__d_.__rep_);
        uint64_t v39 = (os_log_s *)RXOSLog();
        if (os_log_type_enabled(v39, OS_LOG_TYPE_DEFAULT))
        {
          LODWORD(buf.__r_.__value_.__l.__data_) = 134217984;
          *(double *)((char *)buf.__r_.__value_.__r.__words + 4) = v38;
          _os_log_impl( (void *)&_mh_execute_header,  v39,  OS_LOG_TYPE_DEFAULT,  "Adding to profile - %f",  (uint8_t *)&buf,  0xCu);
        }
      }

      __int16 v40 = (os_log_s *)RXSignpostLog();
      if (os_signpost_enabled(v40))
      {
        LOWORD(buf.__r_.__value_.__l.__data_) = 0;
        _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v40,  OS_SIGNPOST_INTERVAL_END,  0xEEEEB0B5B2B2EEEELL,  "GrammarTemplates",  "Adding templates",  (uint8_t *)&buf,  2u);
      }

      unint64_t v41 = (os_log_s *)RXSignpostLog();
      if (os_signpost_enabled(v41))
      {
        LOWORD(buf.__r_.__value_.__l.__data_) = 0;
        _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v41,  OS_SIGNPOST_INTERVAL_END,  0xEEEEB0B5B2B2EEEELL,  "Grammar",  "Done Building grammar",  (uint8_t *)&buf,  2u);
      }

      buf.__r_.__value_.__r.__words[0] = (std::string::size_type)&__str;
      sub_10002E258((void ***)&buf);
    }

void sub_100032BEC( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, uint64_t a18, uint64_t a19, void **a20, uint64_t a21, uint64_t a22, uint64_t a23, void *a24, uint64_t a25, int a26, __int16 a27, char a28, char a29)
{
  a20 = &a24;
  sub_10002E258(&a20);
  if (v29) {
    (*(void (**)(uint64_t))(*(void *)v29 + 8LL))(v29);
  }
  if (a17 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void RDQSREngine::AddTemplatesToUserProfile(uint64_t a1, uint64_t *a2)
{
  uint64_t v2 = *a2;
  uint64_t v3 = a2[1];
  if (*a2 != v3)
  {
    uint64_t v20 = 0LL;
    do
    {
      if (*(__CFString **)v2 == kRDProfileNonTerminalInline[0])
      {
        unint64_t v4 = *(id ***)(a1 + 32);
        RDUserProfile::removeAllWords(v4);
        LOBYTE(v2sub_10001AFB0((std::locale *)v24, " +$", 0) = 1;
      }

      else
      {
        unint64_t v4 = *(id ***)(a1 + 24);
        BYTE4(v2sub_10001AFB0((std::locale *)v24, " +$", 0) = 1;
      }

      uint64_t v6 = *(uint64_t **)(v2 + 16);
      uint64_t v5 = *(uint64_t **)(v2 + 24);
      while (v6 != v5)
      {
        CFMutableStringRef Mutable = CFArrayCreateMutable(0LL, 0LL, &kCFTypeArrayCallBacks);
        uint64_t v8 = *v6;
        uint64_t v9 = v6[1];
        while (v8 != v9)
        {
          uint64_t v10 = (const char *)v8;
          CFStringRef v11 = CFStringCreateWithCString(0LL, v10, 0x8000100u);
          if (v11)
          {
            CFStringRef v12 = v11;
            CFArrayAppendValue(Mutable, v11);
            CFRelease(v12);
          }

          v8 += 48LL;
        }

        if (Mutable)
        {
          RDUserProfile::addPhraseToUserProfile(v4, Mutable, *(const __CFString **)v2, *(const __CFString **)(v2 + 8));
          CFRelease(Mutable);
        }

        v6 += 3;
      }

      v2 += 40LL;
    }

    while (v2 != v3);
    if (*a2 != a2[1])
    {
      if ((v20 & 0x100000000LL) != 0)
      {
        id v13 = RDUserProfile::copyDataProfile(*(id ***)(a1 + 24));
        if (v13)
        {
          std::string::size_type v14 = v13;
          unint64_t v15 = (os_log_s *)RXOSLog();
          if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)std::string buf = 0;
            _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "Updating AOT LME", buf, 2u);
          }

          RDASRWSpeechRecognizerUpdateUserProfileData(*(void **)(a1 + 16), (uint64_t)v14);
          CFRelease(v14);
        }
      }

      if ((v20 & 1) != 0)
      {
        id v16 = RDUserProfile::copyDataProfile(*(id ***)(a1 + 32));
        if (v16)
        {
          uint64_t v17 = v16;
          CFTypeID v18 = (os_log_s *)RXOSLog();
          if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)CFRange v22 = 0;
            _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "Updating Inline LME", v22, 2u);
          }

          RDASRWSpeechRecognizerUpdateJitProfileData(*(void **)(a1 + 16), (uint64_t)v17);
          CFRelease(v17);
        }
      }
    }
  }

void RDQSREngine::DidRecognizePartialResultTokensCallback( RDQSREngine *this, CFTypeRef cf, const __CFArray *a3)
{
  if (cf) {
    CFRetain(cf);
  }
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 0x40000000LL;
  _OWORD v5[2] = sub_100032F6C;
  void v5[3] = &unk_1000CEF68;
  v5[4] = this;
  v5[5] = cf;
  dispatch_async((dispatch_queue_t)gRDServerQueue, v5);
}

void sub_100032F6C(uint64_t a1)
{
}

void RDQSREngine::DidRecognizePartialResultTokens(RDQSREngine *this, const __CFArray *a2)
{
  if (*((_BYTE *)this + 88))
  {
    RDQSREngine::BeginUtt(this);
    *((_BYTE *)this + 8std::ostream::~ostream(v1, v2 + 8) = 0;
  }

  if (RXLogServerResults())
  {
    int v4 = RXVeryVerbose();
    if (a2)
    {
      if (v4)
      {
        if (CFArrayGetCount(a2) >= 1)
        {
          CFIndex v5 = 0LL;
          do
          {
            ValueAtIndex = (void *)CFArrayGetValueAtIndex(a2, v5);
            if (ValueAtIndex)
            {
              TokenName = (const __CFString *)RDASRWSpeechRecognitionTokenGetTokenName(ValueAtIndex);
              RDString::RDString((RDString *)__p, TokenName, 0);
              uint64_t v8 = (os_log_s *)RXOSLog();
              if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
              {
                if (v12 >= 0) {
                  uint64_t v9 = __p;
                }
                else {
                  uint64_t v9 = (void **)__p[0];
                }
                *(_DWORD *)std::string buf = 136315138;
                std::string::size_type v14 = v9;
                _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "Partial Token: %s\n", buf, 0xCu);
              }

              if (v12 < 0) {
                operator delete(__p[0]);
              }
            }

            ++v5;
          }

          while (v5 < CFArrayGetCount(a2));
        }

        uint64_t v10 = (os_log_s *)RXOSLog();
        if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
        {
          LOWORD(__p[0]) = 0;
          _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "------ ", (uint8_t *)__p, 2u);
        }
      }
    }
  }

  if (a2) {
    CFRelease(a2);
  }
}

void sub_100033110( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void RDQSREngine::DidFinishRecognitionWithErrorCallback(RDQSREngine *this, CFErrorRef err, __CFError *a3)
{
  if (err)
  {
    Domain = CFErrorGetDomain(err);
    if (Domain)
    {
      uint64_t v6 = Domain;
      if (CFStringCompare(Domain, @"EARErrorDomain", 0LL) == kCFCompareEqualTo && !CFErrorGetCode(err))
      {
        BOOL v7 = (os_log_s *)RXOSLog();
        if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)std::string buf = 0;
          _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_ERROR,  "EAR recognition failed with error that can cause a hang",  buf,  2u);
        }

        sub_100033288((uint64_t)@"EAR recognition failed with error that can cause a hang");
      }

      if (CFStringCompare(v6, @"SpeechAPIErrorDomain", 0LL) == kCFCompareEqualTo && !CFErrorGetCode(err))
      {
        block[0] = _NSConcreteStackBlock;
        block[1] = 0x40000000LL;
        block[2] = sub_1000332FC;
        block[3] = &unk_1000CEF88;
        block[4] = this;
        dispatch_async((dispatch_queue_t)gRDServerQueue, block);
      }
    }

    CFRetain(err);
  }

  v8[0] = _NSConcreteStackBlock;
  v8[1] = 0x40000000LL;
  v8[2] = sub_10003330C;
  void v8[3] = &unk_1000CEFA8;
  v8[4] = this;
  void v8[5] = err;
  dispatch_async((dispatch_queue_t)gRDServerQueue, v8);
}

void sub_100033288(uint64_t a1)
{
  uint64_t v2 = (os_log_s *)RXOSLog();
  if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
  {
    int v3 = 138543362;
    uint64_t v4 = a1;
    _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_ERROR,  "Terminating to restart EAR (%{public}@)",  (uint8_t *)&v3,  0xCu);
  }

  exit(0);
}

std::chrono::duration<long long, std::ratio<1, 1000000000>>::rep sub_1000332FC(uint64_t a1)
{
  return RDQSREngine::RestartASREngine(*(CFTypeRef **)(a1 + 32), @"Exception thrown in recognition");
}

void sub_10003330C(uint64_t a1)
{
}

void RDQSREngine::DidFinishRecognitionWithError(RDQSREngine *this, CFStringRef cf)
{
  if (cf) {
    CFTypeRef cf = CFCopyDescription(cf);
  }
  RDString::RDString((RDString *)__p, cf, 1);
  int v3 = (os_log_s *)RXOSLog();
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v4 = __p;
    if (v7 < 0) {
      uint64_t v4 = (void **)__p[0];
    }
    *(_DWORD *)std::string buf = 136315138;
    uint64_t v9 = v4;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "DidFinishRecognitionWithError: %s\n", buf, 0xCu);
  }

  *((_BYTE *)this + 8std::ostream::~ostream(v1, v2 + 8) = 1;
  if (!*((_BYTE *)this + 48))
  {
    for (CFIndex i = (RDQSRPeer *)*((void *)this + 18); i; CFIndex i = (RDQSRPeer *)*((void *)i + 29))
      RDQSRPeer::ReachedEndofAudioFile(i);
  }

  RDQSREngine::EndUtt(this);
  if (v7 < 0) {
    operator delete(__p[0]);
  }
}

void sub_100033420( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void RDQSREngine::DidRecognizeFinalResultsWithPreITNCallback( RDQSREngine *this, CFTypeRef cf, CFTypeRef a3, CFTypeRef a4, CFTypeRef a5, CFTypeRef a6, CFTypeRef a7, const __CFString *a8)
{
  if (cf) {
    CFRetain(cf);
  }
  if (a3) {
    CFRetain(a3);
  }
  if (a4) {
    CFRetain(a4);
  }
  if (a5) {
    CFRetain(a5);
  }
  if (a6) {
    CFRetain(a6);
  }
  if (a7) {
    CFRetain(a7);
  }
  unint64_t v15 = (os_log_s *)RXOSLog();
  if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "Got the result", buf, 2u);
  }

  id v16 = (os_log_s *)RXSignpostLog();
  if (os_signpost_enabled(v16))
  {
    *(_WORD *)std::string buf = 0;
    _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v16,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "Got the result",  "",  buf,  2u);
  }

  block[0] = _NSConcreteStackBlock;
  block[1] = 0x40000000LL;
  block[2] = sub_1000335C0;
  block[3] = &unk_1000CEFC8;
  block[4] = this;
  void block[5] = cf;
  void block[6] = a3;
  block[7] = a4;
  block[8] = a7;
  block[9] = a5;
  block[10] = a6;
  dispatch_async((dispatch_queue_t)gRDServerQueue, block);
}

void sub_1000335C0(uint64_t a1, uint64_t a2, const __CFArray *a3)
{
  uint64_t v4 = *(const void **)(a1 + 40);
  if (v4) {
    CFRelease(v4);
  }
  CFIndex v5 = *(const void **)(a1 + 48);
  if (v5) {
    CFRelease(v5);
  }
  uint64_t v6 = *(const void **)(a1 + 56);
  if (v6) {
    CFRelease(v6);
  }
  char v7 = *(const void **)(a1 + 72);
  if (v7) {
    CFRelease(v7);
  }
  uint64_t v8 = *(const void **)(a1 + 80);
  if (v8) {
    CFRelease(v8);
  }
  uint64_t v9 = *(const void **)(a1 + 64);
  if (v9) {
    CFRelease(v9);
  }
}

RDQSRResultMatcher *RDQSREngine::DidRecognizeFinalResults( RDQSREngine *this, const __CFArray *a2, const __CFArray *a3, const __CFArray *a4, const __CFString *a5)
{
  *((_BYTE *)this + 86) = 0;
  if (RXAutomationModeResult() || RXAutomationModeSynthesis() || RXAutomationModeFileName()) {
    RDQSREngine::ResetRecognition(this);
  }
  RDQSRResultMatcher::Create( *((void *)this + 19),  a2,  (uint64_t)a4,  (uint64_t)a5,  *((_DWORD *)this + 44),  *((void *)this + 23),  *((void *)this + 20),  *((void *)this + 49) == (void)@"SpellCC",  &v10);
  RDQSREngine::MatchResult(this, v10);
  id result = v10;
  uint64_t v10 = 0LL;
  if (result) {
    return (RDQSRResultMatcher *)(*(uint64_t (**)(RDQSRResultMatcher *))(*(void *)result + 24LL))(result);
  }
  return result;
}

void sub_1000336F0( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10) {
    (*(void (**)(uint64_t))(*(void *)a10 + 24LL))(a10);
  }
  _Unwind_Resume(exception_object);
}

void RDQSREngine::DidGetUtteranceBoundaryCallback(RDQSREngine *this, void *a2, uint64_t a3)
{
  block[0] = _NSConcreteStackBlock;
  block[1] = 0x40000000LL;
  block[2] = sub_100033778;
  block[3] = &unk_1000CEFE8;
  block[4] = this;
  void block[5] = a2;
  void block[6] = a3;
  dispatch_async((dispatch_queue_t)gRDServerQueue, block);
}

__n128 sub_100033778(uint64_t a1)
{
  __n128 result = *(__n128 *)(a1 + 40);
  *(__n128 *)(*(void *)(a1 + 32) + 96LL) = result;
  return result;
}

uint64_t RDQSREngine::DidGetUtteranceBoundary(uint64_t this, uint64_t a2, uint64_t a3)
{
  *(void *)(this + 96) = a2;
  *(void *)(this + 104) = a3;
  return this;
}

void RDQSREngine::DidRecognizeFinalResultsCallback( RDQSREngine *this, CFTypeRef cf, CFTypeRef a3, CFTypeRef a4, CFTypeRef a5, const __CFString *a6)
{
  if (cf) {
    CFRetain(cf);
  }
  if (a3) {
    CFRetain(a3);
  }
  if (a4) {
    CFRetain(a4);
  }
  if (a5) {
    CFRetain(a5);
  }
  CFStringRef v11 = (os_log_s *)RXOSLog();
  if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "Got the result", buf, 2u);
  }

  char v12 = (os_log_s *)RXSignpostLog();
  if (os_signpost_enabled(v12))
  {
    *(_WORD *)std::string buf = 0;
    _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v12,  OS_SIGNPOST_EVENT,  0xEEEEB0B5B2B2EEEELL,  "Got the result",  "",  buf,  2u);
  }

  block[0] = _NSConcreteStackBlock;
  block[1] = 0x40000000LL;
  block[2] = sub_1000338D8;
  block[3] = &unk_1000CF008;
  block[4] = this;
  void block[5] = cf;
  void block[6] = a3;
  void block[7] = a4;
  block[8] = a5;
  dispatch_async((dispatch_queue_t)gRDServerQueue, block);
}

void sub_1000338D8(uint64_t a1, uint64_t a2, const __CFArray *a3)
{
  uint64_t v4 = *(const void **)(a1 + 40);
  if (v4) {
    CFRelease(v4);
  }
  CFIndex v5 = *(const void **)(a1 + 48);
  if (v5) {
    CFRelease(v5);
  }
  uint64_t v6 = *(const void **)(a1 + 56);
  if (v6) {
    CFRelease(v6);
  }
  char v7 = *(const void **)(a1 + 64);
  if (v7) {
    CFRelease(v7);
  }
}

void RDQSREngine::DidProcessAudioDurationCallback(RDQSREngine *this, void *a2, double a3)
{
  if (!RXAutomationModeResult() && !RXAutomationModeSynthesis() && !RXAutomationModeFileName())
  {
    v5[0] = _NSConcreteStackBlock;
    v5[1] = 0x40000000LL;
    _OWORD v5[2] = sub_1000339CC;
    void v5[3] = &unk_1000CF028;
    v5[4] = this;
    *(double *)&v5[5] = a3;
    dispatch_async((dispatch_queue_t)gRDServerQueue, v5);
  }

void sub_1000339CC(uint64_t a1)
{
}

void RDQSREngine::DidProcessAudioDuration(RDQSREngine *this, double a2)
{
  double v4 = rd_time_util::durationInMilliSec(*((void *)this + 46));
  LOBYTE(v5) = *((_BYTE *)this + 137);
  if ((double)((uint64_t)v4 / 1000) - a2 > (double)v5)
  {
    DarwinNotifyCenter = CFNotificationCenterGetDarwinNotifyCenter();
    CFNotificationCenterPostNotification( DarwinNotifyCenter,  @"com.apple.SpeechRecognitionCore.RecognitionReset",  0LL,  0LL,  0);
  }

void RDQSREngine::BeginUtt(RDQSREngine *this)
{
  uint64_t v2 = (os_log_s *)RXOSLog();
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)double v4 = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "BeginUtt\n", v4, 2u);
  }

  *((_BYTE *)this + 85) = 1;
  *((void *)this + 21) = dispatch_time(0LL, 0LL);
  for (CFIndex i = (RDQSRPeer *)*((void *)this + 18); i; CFIndex i = (RDQSRPeer *)*((void *)i + 29))
    RDQSRPeer::BeginUtt(i);
}

void RDQSREngine::EndUtt(RDQSREngine *this)
{
  uint64_t v2 = (os_log_s *)RXOSLog();
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = *((void *)this + 9);
    v6[0] = 67109120;
    v6[1] = v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "EndUtt (%u live)\n", (uint8_t *)v6, 8u);
  }

  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 232));
  uint64_t v4 = *((void *)this + 28);
  if (v4) {
    RDASRWSpeechRecognitionAudioBufferNewUtteranceBegins(v4);
  }
  pthread_mutex_unlock((pthread_mutex_t *)((char *)this + 232));
  *(_WORD *)((char *)this + 85) = 256;
  for (CFIndex i = (RDQSRPeer *)*((void *)this + 18); i; CFIndex i = (RDQSRPeer *)*((void *)i + 29))
    RDQSRPeer::EndUtt(i);
  if (*((_BYTE *)this + 84)) {
    RDQSREngine::SetMicState(this, 0, "Deferred off");
  }
}

void RDQSREngine::MatchResult(RDQSREngine *this, RDQSRResultMatcher *a2)
{
  uint64_t v3 = (os_log_s *)RXSignpostLog();
  if (os_signpost_enabled(v3))
  {
    *(_WORD *)std::string buf = 0;
    _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v3,  OS_SIGNPOST_INTERVAL_BEGIN,  0xEEEEB0B5B2B2EEEELL,  "Result",  "Started Result processing",  buf,  2u);
  }

  *(void *)std::string buf = 0LL;
  char v66 = 0LL;
  char v67 = 0LL;
  __int128 __p = 0LL;
  int v63 = 0LL;
  size_t v64 = 0LL;
  uint64_t v4 = (_BYTE *)*((void *)this + 14);
  for (CFIndex i = (_BYTE *)*((void *)this + 15); v4 != i; v4 += 16)
  {
    uint64_t v6 = *(void *)v4;
    if (*(void *)v4 && *(void *)(v6 + 32))
    {
      BOOL v7 = !*(void *)(v6 + 40) || v4[8] == 0;
      if (!v7 && v4[9] != 0)
      {
        uint64_t v9 = v66;
        if (v66 >= v67)
        {
          uint64_t v11 = ((uint64_t)v66 - *(void *)buf) >> 3;
          unint64_t v12 = ((uint64_t)v67 - *(void *)buf) >> 2;
          if (v12 <= v11 + 1) {
            unint64_t v12 = v11 + 1;
          }
          else {
            unint64_t v13 = v12;
          }
          if (v13)
          {
            std::string::size_type v14 = (char *)sub_100018788((uint64_t)&v67, v13);
            uint64_t v6 = *(void *)v4;
          }

          else
          {
            std::string::size_type v14 = 0LL;
          }

          unint64_t v15 = &v14[8 * v11];
          *(void *)unint64_t v15 = v6;
          uint64_t v10 = (uint64_t *)(v15 + 8);
          uint64_t v17 = *(uint64_t **)buf;
          id v16 = v66;
          if (v66 != *(uint64_t **)buf)
          {
            do
            {
              uint64_t v18 = *--v16;
              *((void *)v15 - 1) = v18;
              v15 -= 8;
            }

            while (v16 != v17);
            id v16 = *(uint64_t **)buf;
          }

          *(void *)std::string buf = v15;
          char v66 = v10;
          char v67 = (uint64_t *)&v14[8 * v13];
          if (v16) {
            operator delete(v16);
          }
        }

        else
        {
          uint64_t *v66 = v6;
          uint64_t v10 = v9 + 1;
        }

        std::string::size_type v19 = this;
        char v66 = v10;
        uint64_t v21 = *(void *)(*(void *)v4 + 32LL);
        uint64_t v20 = *(void *)(*(void *)v4 + 40LL);
        uint64_t v22 = *(void *)(*(void *)v4 + 24LL) + 40LL;
        char v23 = *(_BYTE *)(*(void *)v4 + 50LL);
        char v24 = *(_BYTE *)(*(void *)v4 + 51LL);
        char v25 = *(_BYTE *)(*(void *)v4 + 52LL);
        uint64_t v26 = v63;
        if (v63 >= v64)
        {
          uint64_t v28 = (v63 - (_BYTE *)__p) >> 5;
          unint64_t v29 = v28 + 1;
          uint64_t v30 = v64 - (_BYTE *)__p;
          if ((v64 - (_BYTE *)__p) >> 4 > v29) {
            unint64_t v29 = v30 >> 4;
          }
          else {
            unint64_t v31 = v29;
          }
          if (v31) {
            uint64_t v32 = (char *)sub_1000295D0((uint64_t)&v64, v31);
          }
          else {
            uint64_t v32 = 0LL;
          }
          uint64_t v33 = &v32[32 * v28];
          *(void *)uint64_t v33 = v20;
          *((void *)v33 + 1) = v21;
          *((void *)v33 + 2) = v22;
          v33[24] = v23;
          v33[25] = v24;
          v33[26] = v25;
          std::chrono::steady_clock::time_point v35 = (char *)__p;
          int64x2_t v34 = v63;
          double v36 = v33;
          if (v63 != __p)
          {
            do
            {
              __int128 v37 = *((_OWORD *)v34 - 2);
              *(_OWORD *)(v36 - 21) = *(_OWORD *)(v34 - 21);
              *((_OWORD *)v36 - 2) = v37;
              v36 -= 32;
              v34 -= 32;
            }

            while (v34 != v35);
            int64x2_t v34 = v35;
          }

          uint64_t v27 = v33 + 32;
          __int128 __p = v36;
          int v63 = v33 + 32;
          size_t v64 = &v32[32 * v31];
          if (v34) {
            operator delete(v34);
          }
        }

        else
        {
          *(void *)int v63 = v20;
          *((void *)v26 + 1) = v21;
          *((void *)v26 + 2) = v22;
          v26[24] = v23;
          v26[25] = v24;
          uint64_t v27 = v26 + 32;
          v26[26] = v25;
        }

        int v63 = v27;
        this = v19;
      }
    }
  }

  (**(void (***)(RDQSRResultObject **__return_ptr, RDQSRResultMatcher *, void **))a2)(&v60, a2, &__p);
  unint64_t v38 = 126 - 2 * __clz((v61 - v60) >> 4);
  if (v61 == v60) {
    uint64_t v39 = 0LL;
  }
  else {
    uint64_t v39 = v38;
  }
  sub_100035090(v60, v61, v39, 1);
  __int16 v40 = v60;
  if (v60 != v61)
  {
    char v41 = 0;
    while (1)
    {
      int GrammarIndex = RDQSRResultObject::getGrammarIndex(v40);
      if (RDQSRResultObject::getResultModel(v40))
      {
        ResultModel = (void *)RDQSRResultObject::getResultModel(v40);
        xpc_object_t v44 = xpc_retain(ResultModel);
        if (GrammarIndex != -1)
        {
          uint64_t v45 = GrammarIndex;
          uint64_t v46 = *(void *)(*(void *)buf + 8LL * GrammarIndex);
          if (v44)
          {
            RDQSRPeer::EndPhrase(*(uint64_t ***)(v46 + 24), 0, v46, v44);
            *((void *)this + 51) = (*(uint64_t (**)(RDQSRResultMatcher *))(*(void *)a2 + 8LL))(a2);
            uint64_t v47 = (os_log_s *)RXOSLog();
            if (os_log_type_enabled(v47, OS_LOG_TYPE_DEFAULT))
            {
              uint64_t v48 = *(void *)(v46 + 16);
              *(_DWORD *)BOOL v68 = 134217984;
              *(void *)&v68[4] = v48;
              _os_log_impl( (void *)&_mh_execute_header,  v47,  OS_LOG_TYPE_DEFAULT,  "Sending message to client %zu",  v68,  0xCu);
            }

            char v41 = 1;
          }

          else
          {
LABEL_60:
            RDQSRPeer::ServerResponse(*(void *)(v46 + 24), 0LL, v46);
            uint64_t v49 = (os_log_s *)RXOSLog();
            if (os_log_type_enabled(v49, OS_LOG_TYPE_DEFAULT))
            {
              *(_WORD *)BOOL v68 = 0;
              _os_log_impl( (void *)&_mh_execute_header,  v49,  OS_LOG_TYPE_DEFAULT,  "Even with the winner, we have no response - sending null to client\n",  v68,  2u);
            }
          }

          uint64_t v50 = *(void *)buf + 8 * v45;
          uint64_t v51 = (char *)v66 - v50 - 8;
          char v66 = (uint64_t *)&v51[v50];
        }
      }

      else if (GrammarIndex != -1)
      {
        uint64_t v45 = GrammarIndex;
        uint64_t v46 = *(void *)(*(void *)buf + 8LL * GrammarIndex);
        goto LABEL_60;
      }

      __int16 v40 = (RDQSRResultObject *)((char *)v40 + 16);
      if (v40 == v61) {
        goto LABEL_68;
      }
    }
  }

  char v41 = 0;
LABEL_68:
  uint64_t v52 = *(uint64_t **)buf;
  for (unint64_t j = v66; v52 != j; ++v52)
  {
    uint64_t v54 = *v52;
    RDQSRPeer::ServerResponse(*(void *)(*v52 + 24), 0LL, *v52);
    __int128 v55 = (os_log_s *)RXOSLog();
    if (os_log_type_enabled(v55, OS_LOG_TYPE_INFO))
    {
      uint64_t v56 = *(void *)(v54 + 16);
      *(_DWORD *)BOOL v68 = 134217984;
      *(void *)&v68[4] = v56;
      _os_log_impl((void *)&_mh_execute_header, v55, OS_LOG_TYPE_INFO, "Sending null to client %zu", v68, 0xCu);
    }
  }

  int v57 = (os_log_s *)RXSignpostLog();
  if (os_signpost_enabled(v57))
  {
    *(_WORD *)BOOL v68 = 0;
    _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v57,  OS_SIGNPOST_INTERVAL_END,  0xEEEEB0B5B2B2EEEELL,  "Result",  "Done Result processing",  v68,  2u);
  }

  if ((v41 & 1) != 0)
  {
    if (RDQSREngine::ShouldDonateSpeech(this)) {
      RDQSREngine::DonateSpeech(this);
    }
  }

  else
  {
    int v58 = (os_log_s *)RXOSLog();
    if (os_log_type_enabled(v58, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)BOOL v68 = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v58,  OS_LOG_TYPE_DEFAULT,  "EndPhrase did not match any grammars\n",  v68,  2u);
    }
  }

  *((_BYTE *)this + 8std::ostream::~ostream(v1, v2 + 8) = 1;
  RDQSREngine::EndUtt(this);
  *(void *)BOOL v68 = &v60;
  sub_1000197C4((void ***)v68);
  if (__p)
  {
    int v63 = (char *)__p;
    operator delete(__p);
  }

  if (*(void *)buf)
  {
    char v66 = *(uint64_t **)buf;
    operator delete(*(void **)buf);
  }

void sub_100034228( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19, uint64_t a20, void *a21, uint64_t a22)
{
  *(void *)(v22 - 112) = &a15;
  sub_1000197C4((void ***)(v22 - 112));
  if (__p)
  {
    a19 = (uint64_t)__p;
    operator delete(__p);
  }

  if (a21)
  {
    a22 = (uint64_t)a21;
    operator delete(a21);
  }

  _Unwind_Resume(a1);
}

std::chrono::duration<long long, std::ratio<1, 1000000000>>::rep RDQSREngine::SetResetRecognitionMode( RDQSREngine *this, xpc_object_t xdict)
{
  int v3 = *((unsigned __int8 *)this + 136);
  uint64_t int64 = xpc_dictionary_get_uint64(xdict, kRDKeyRecognitionResetMode);
  *((_BYTE *)this + 136) = uint64;
  switch(uint64)
  {
    case 0:
      unint64_t v5 = (os_log_s *)RXOSLog();
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
      {
        __int16 v15 = 0;
        uint64_t v6 = "Setting recognition reset mode to default...";
        BOOL v7 = (uint8_t *)&v15;
        goto LABEL_10;
      }

      break;
    case 1:
      unint64_t v5 = (os_log_s *)RXOSLog();
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
      {
        __int16 v14 = 0;
        uint64_t v6 = "Setting recognition reset mode to dictation...";
        BOOL v7 = (uint8_t *)&v14;
        goto LABEL_10;
      }

      break;
    case 2:
      unint64_t v5 = (os_log_s *)RXOSLog();
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
      {
        __int16 v13 = 0;
        uint64_t v6 = "Setting recognition reset mode to commands...";
        BOOL v7 = (uint8_t *)&v13;
        goto LABEL_10;
      }

      break;
    case 3:
      unint64_t v5 = (os_log_s *)RXOSLog();
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)std::string buf = 0;
        uint64_t v6 = "Setting recognition reset mode to sleep...";
        BOOL v7 = buf;
LABEL_10:
        _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, v6, v7, 2u);
      }

      break;
    default:
      uint64_t v8 = (os_log_s *)RXOSLog();
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)uint64_t v11 = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEFAULT,  "Incorrect reset mode..Switching to default",  v11,  2u);
      }

      *((_BYTE *)this + 136) = 0;
      break;
  }

  if (RXIsKeywordSpotterEnabled()
    && (std::chrono::duration<long long, std::ratio<1, 1000000000>>::rep result = RXIsLocaleSupportingKeywordSpotter(*((void *)this + 19)), (_DWORD)result)
    || (std::chrono::duration<long long, std::ratio<1, 1000000000>>::rep result = RXIsSpeechDetectorEnabled(), (_DWORD)result)
    && (std::chrono::duration<long long, std::ratio<1, 1000000000>>::rep result = RXIsLocaleSupportingOndeviceSpeechDetection(*((void *)this + 19)), (_DWORD)result))
  {
    int v10 = *((unsigned __int8 *)this + 136);
    if (v3 != v10 && (v3 == 3 || v10 == 3)) {
      return RDQSREngine::ResetRecognition(this);
    }
  }

  return result;
}

void RDQSREngine::SaveUserProfileToFile(void **this, xpc_object_t xdict)
{
  string = xpc_dictionary_get_string(xdict, kRDKeyUserProfileSavePath);
  if (*string)
  {
    uint64_t v4 = string;
    size_t v5 = strlen(string);
    uint64_t v6 = (char *)&v19 - ((__chkstk_darwin() + 115) & 0xFFFFFFFFFFFFFFF0LL);
    bzero(v6, v5 + 100);
    BOOL v7 = strncpy(v6, v4, v5);
    strcpy(&v6[strlen(v7)], "EngineUserProfile");
    uint64_t v8 = (const __CFData *)RDASRWSpeechRecognizerCopyUserProfileData(this[2]);
    if (v8)
    {
      uint64_t v9 = v8;
      int v10 = fopen(v6, "w");
      BytePtr = CFDataGetBytePtr(v9);
      size_t Length = CFDataGetLength(v9);
      fwrite(BytePtr, 1uLL, Length, v10);
      fclose(v10);
      CFRelease(v9);
    }

    __chkstk_darwin();
    bzero((char *)&v19 - ((v5 + 115) & 0xFFFFFFFFFFFFFFF0LL), v5 + 100);
    __int16 v13 = strncpy((char *)&v19 - ((v5 + 115) & 0xFFFFFFFFFFFFFFF0LL), v4, v5);
    strcpy((char *)&v19 + strlen(v13) - ((v5 + 115) & 0xFFFFFFFFFFFFFFF0LL), "EngineJitProfile");
    __int16 v14 = (const __CFData *)RDASRWSpeechRecognizerCopyJitProfileData(this[2]);
    if (v14)
    {
      __int16 v15 = v14;
      id v16 = fopen((const char *)&v19 - ((v5 + 115) & 0xFFFFFFFFFFFFFFF0LL), "w");
      uint64_t v17 = CFDataGetBytePtr(v15);
      size_t v18 = CFDataGetLength(v15);
      fwrite(v17, 1uLL, v18, v16);
      fclose(v16);
      CFRelease(v15);
    }
  }

BOOL RDQSREngine::ShouldDonateSpeech(RDQSREngine *this)
{
  return RXIsAudioDonationOptedIn()
      && *((_BYTE *)this + 10)
      && !*((_BYTE *)this + 402)
      && rand() % 100 < *((unsigned __int16 *)this + 4);
}

void RDQSREngine::DonateSpeech(RDQSREngine *this)
{
  uint64_t v2 = (os_log_s *)RXOSLog();
  if (os_log_type_enabled(v2, OS_LOG_TYPE_INFO))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_INFO, "VoiceControl::SpeechDonation", buf, 2u);
  }

  if (*((_BYTE *)this + 10) && RXIsAudioDonationOptedIn()) {
    *(void *)this = RDSpeechDonationInit( (uint64_t)@"VoiceControl",  (uint64_t)@"somethingunique",  *((void *)this + 19),  *((void *)this + 49));
  }
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 296));
  int v3 = (os_log_s *)RXOSLog();
  if (os_log_type_enabled(v3, OS_LOG_TYPE_INFO))
  {
    unint64_t v4 = *((void *)this + 12);
    unint64_t v5 = *((void *)this + 13);
    *(_DWORD *)std::string buf = 134218240;
    unint64_t v21 = v4;
    __int16 v22 = 2048;
    unint64_t v23 = v5;
    _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_INFO,  "SpeechDonation: Start Sample Number = %lld, end Sample number = %lld",  buf,  0x16u);
  }

  uint64_t v6 = *((void *)this + 12);
  BOOL v7 = (uint64_t *)((char *)this + 96);
  if (*((void *)this + 13) - v6 >= 80000) {
    unint64_t v8 = 80000LL;
  }
  else {
    unint64_t v8 = *((void *)this + 13) - v6;
  }
  *BOOL v7 = v6 % 80000;
  uint64_t v9 = (os_log_s *)RXOSLog();
  if (os_log_type_enabled(v9, OS_LOG_TYPE_INFO))
  {
    unint64_t v10 = *v7;
    *(_DWORD *)std::string buf = 134218240;
    unint64_t v21 = v10;
    __int16 v22 = 2048;
    unint64_t v23 = v8;
    _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_INFO,  "SpeechDonation: Adjusted Start Sample Number = %lld, total samples to be read = %lld",  buf,  0x16u);
  }

  __chkstk_darwin();
  unint64_t v13 = RDQSRCircularBuffer<short>::read( *((void *)this + 26),  v12,  (char *)&buf[-((v11 + 15) & 0xFFFFFFFFFFFFFFF0LL)]);
  __int16 v14 = (os_log_s *)RXOSLog();
  if (os_log_type_enabled(v14, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)std::string buf = 134217984;
    unint64_t v21 = v13;
    _os_log_impl( (void *)&_mh_execute_header,  v14,  OS_LOG_TYPE_INFO,  "SpeechDonation: Samples discarded = %zu",  buf,  0xCu);
  }

  __chkstk_darwin();
  id v16 = (char *)&buf[-((v15 + 15) & 0xFFFFFFFFFFFFFFF0LL)];
  unint64_t v17 = RDQSRCircularBuffer<short>::read(*((void *)this + 26), v8, v16);
  size_t v18 = (os_log_s *)RXOSLog();
  if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)std::string buf = 134217984;
    unint64_t v21 = v17;
    _os_log_impl( (void *)&_mh_execute_header,  v18,  OS_LOG_TYPE_DEFAULT,  "SpeechDonation: Samples donated = %zu",  buf,  0xCu);
  }

  if (*(void *)this) {
    RDspeechDonationAddAudioSamples(*(void **)this, (uint64_t)v16, v8);
  }
  uint64_t v19 = (char *)operator new(0x20uLL);
  *((_DWORD *)v19 + 2) = 80000;
  *(void *)uint64_t v19 = operator new[](0x27100uLL);
  *(void *)(v19 + 2sub_10001AFB0((std::locale *)v24, " +$", 0) = 0LL;
  *(void *)(v19 + 12) = 0LL;
  sub_100031898((void ***)this + 26, (void **)v19);
  *BOOL v7 = 0LL;
  *((void *)this + 13) = 0LL;
  pthread_mutex_unlock((pthread_mutex_t *)((char *)this + 296));
  RDspeechDonationDonateAudioForTranscription(*(void **)this, *((void *)this + 51), *((unsigned __int8 *)this + 216));
  if (*(void *)this)
  {
    CFRelease(*(CFTypeRef *)this);
    *(void *)this = 0LL;
  }

void sub_100034A50(_Unwind_Exception *a1)
{
}

void RDQSREngine::AddTrainingData(RDQSREngine *this, void *a2)
{
  uint64_t v2 = (os_log_s *)RXOSLog();
  if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)int v3 = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_ERROR,  "Training mode is not supported for Quasar",  v3,  2u);
  }

BOOL RDQSREngine::SetSecureFieldFocused(RDQSREngine *this, xpc_object_t xdict)
{
  BOOL result = xpc_dictionary_get_BOOL(xdict, kRDKeyFocusOnSecureField);
  *((_BYTE *)this + 402) = result;
  return result;
}

void RDQSREngine::AddOtherContextData(RDQSREngine *this, xpc_object_t xdict)
{
  xpc_object_t value = xpc_dictionary_get_value(xdict, kRDKeyText);
  unint64_t v4 = (os_log_s *)RXOSLog();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_INFO, "Adding other context", buf, 2u);
  }

  if (xpc_get_type(value) == (xpc_type_t)&_xpc_type_array)
  {
    if (xpc_array_get_count(value))
    {
      size_t v6 = 0LL;
      do
      {
        string = xpc_array_get_string(value, v6);
        unint64_t v8 = CFStringCreateWithCString(0LL, string, 0x8000100u);
        if (v8)
        {
          uint64_t v9 = v8;
          unint64_t v10 = sub_100098914(*((CFLocaleRef **)this + 20), v8);
          if (v10)
          {
            uint64_t v11 = v10;
            RDUserProfile::addWordCombinations( *((id ***)this + 4),  v10,  kRDProfileNonTerminalInline[0],  kRDProfileWordTagJustInTime[0]);
            CFRelease(v11);
          }

          CFRelease(v9);
        }

        ++v6;
      }

      while (v6 < xpc_array_get_count(value));
    }
  }

  else
  {
    unint64_t v5 = (os_log_s *)RXOSLog();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)__int16 v14 = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_ERROR,  "Other context data can only be CFArray",  v14,  2u);
    }
  }

  id v12 = RDUserProfile::copyDataProfile(*((id ***)this + 4));
  if (v12)
  {
    unint64_t v13 = v12;
    RDASRWSpeechRecognizerUpdateJitProfileData(*((void **)this + 2), (uint64_t)v12);
    CFRelease(v13);
  }

void sub_100034CAC(uint64_t a1)
{
  uint64_t v1 = (os_log_s *)RXOSLog();
  if (os_log_type_enabled(v1, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v2 = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v1,  OS_LOG_TYPE_DEFAULT,  "Custom vocabulary changed...Updating it",  v2,  2u);
  }

void sub_100034D1C(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    unint64_t v5 = (void **)(a2 + 32);
    sub_100029AAC(&v5);
    uint64_t v3 = *(void *)(a2 + 24);
    *(void *)(a2 + ++*(void *)(result + 24) = 0LL;
    if (v3) {
      (*(void (**)(uint64_t))(*(void *)v3 + 8LL))(v3);
    }
    uint64_t v4 = *(void *)(a2 + 16);
    *(void *)(a2 + 16) = 0LL;
    if (v4) {
      (*(void (**)(uint64_t))(*(void *)v4 + 8LL))(v4);
    }
    operator delete((void *)a2);
  }

void sub_100034D8C(RDUserProfile **a1, RDUserProfile *a2)
{
  uint64_t v3 = *a1;
  *a1 = a2;
  if (v3)
  {
    RDUserProfile::~RDUserProfile(v3);
    operator delete(v4);
  }

void sub_100034DB8(CFTypeRef **a1, CFTypeRef *a2)
{
  uint64_t v3 = *a1;
  *a1 = a2;
  if (v3)
  {
    uint64_t v4 = sub_100097C8C(v3);
    operator delete(v4);
  }

void *sub_100034DEC(uint64_t a1)
{
  BOOL result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &off_1000CF080;
  result[1] = v3;
  return result;
}

uint64_t sub_100034E20(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &off_1000CF080;
  a2[1] = v2;
  return result;
}

void *sub_100034E3C(void *result, _BYTE *a2)
{
  if (*a2)
  {
    uint64_t v2 = result[1];
    uint64_t v3 = *(void **)(v2 + 16);
    id v4 = RDUserProfile::copyDataProfile(*(id ***)(v2 + 24));
    return RDASRWSpeechRecognizerUpdateUserProfileData(v3, (uint64_t)v4);
  }

  return result;
}

uint64_t sub_100034E7C(uint64_t a1, uint64_t a2)
{
  else {
    return 0LL;
  }
}

_UNKNOWN **sub_100034EB8()
{
  return &off_1000CF0F0;
}

void *sub_100034EC4(void *a1, uint64_t a2)
{
  *a1 = 0LL;
  a1[1] = 0LL;
  a1[2] = 0LL;
  if (a2)
  {
    sub_100034F38(a1, a2);
    id v4 = (char *)a1[1];
    bzero(v4, 2 * a2);
    a1[1] = &v4[2 * a2];
  }

  return a1;
}

void sub_100034F1C(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + std::ostream::~ostream(v1, v2 + 8) = v3;
    operator delete(v3);
  }

  _Unwind_Resume(exception_object);
}

char *sub_100034F38(void *a1, uint64_t a2)
{
  if (a2 < 0) {
    sub_100018774();
  }
  BOOL result = (char *)sub_10002185C((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[2 * v4];
  return result;
}

void sub_100034F74(RDQSRAudioFileLogger **a1, RDQSRAudioFileLogger *a2)
{
  uint64_t v3 = *a1;
  *a1 = a2;
  if (v3)
  {
    RDQSRAudioFileLogger::~RDQSRAudioFileLogger(v3);
    operator delete(v4);
  }

void *sub_100034FA0(void *result, const void *a2, uint64_t a3, uint64_t a4)
{
  if (a4)
  {
    size_t v6 = result;
    BOOL result = sub_100034F38(result, a4);
    uint64_t v7 = v6[1];
    size_t v8 = a3 - (void)a2;
    if (v8) {
      BOOL result = memmove((void *)v6[1], a2, v8);
    }
    v6[1] = v7 + v8;
  }

  return result;
}

void sub_100034FFC(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + std::ostream::~ostream(v1, v2 + 8) = v3;
    operator delete(v3);
  }

  _Unwind_Resume(exception_object);
}

void sub_100035018(void **a1)
{
  uint64_t v1 = (char *)*a1;
  if (*a1)
  {
    uint64_t v3 = (char *)a1[1];
    uint64_t v4 = *a1;
    if (v3 != v1)
    {
      do
      {
        unint64_t v5 = v3 - 40;
        size_t v6 = (void **)(v3 - 24);
        sub_1000180A4(&v6);
        uint64_t v3 = v5;
      }

      while (v5 != v1);
      uint64_t v4 = *a1;
    }

    a1[1] = v1;
    operator delete(v4);
    *a1 = 0LL;
    a1[1] = 0LL;
    a1[2] = 0LL;
  }

void sub_100035090(RDQSRResultObject *a1, RDQSRResultObject *a2, uint64_t a3, char a4)
{
  size_t v6 = a2;
  uint64_t v7 = a1;
  unsigned int v86 = a2;
  int v87 = a1;
  while (2)
  {
    uint64_t v8 = v6 - v7;
    unint64_t v9 = (v6 - v7) >> 4;
    switch(v9)
    {
      case 0uLL:
      case 1uLL:
        return;
      case 2uLL:
        unsigned int v86 = (RDQSRResultObject *)((char *)v6 - 16);
        int GrammarIndex = RDQSRResultObject::getGrammarIndex((RDQSRResultObject *)((char *)v6 - 16));
        return;
      case 3uLL:
        unsigned int v86 = (RDQSRResultObject *)((char *)v6 - 16);
        sub_100035B40(v7, (RDQSRResultObject *)((char *)v7 + 16), (RDQSRResultObject *)((char *)v6 - 16));
        return;
      case 4uLL:
        unsigned int v86 = (RDQSRResultObject *)((char *)v6 - 16);
        sub_100035E74( v7,  (RDQSRResultObject *)((char *)v7 + 16),  (RDQSRResultObject *)((char *)v7 + 32),  (uint64_t)v6 - 16);
        return;
      case 5uLL:
        unsigned int v86 = (RDQSRResultObject *)((char *)v6 - 16);
        sub_100035A4C( v7,  (RDQSRResultObject *)((char *)v7 + 16),  (RDQSRResultObject *)((char *)v7 + 32),  (RDQSRResultObject *)((char *)v7 + 48),  (uint64_t)v6 - 16);
        return;
      default:
        if (v8 <= 383)
        {
          xpc_object_t v44 = (RDQSRResultObject *)((char *)v7 + 16);
          BOOL v46 = v7 == v6 || v44 == v6;
          if ((a4 & 1) != 0)
          {
            if (!v46)
            {
              uint64_t v47 = 0LL;
              uint64_t v48 = v7;
              do
              {
                uint64_t v49 = v48;
                uint64_t v48 = v44;
                int v50 = RDQSRResultObject::getGrammarIndex(v44);
                if (v50 > (int)RDQSRResultObject::getGrammarIndex(v49))
                {
                  RDQSRResultObject::RDQSRResultObject((RDQSRResultObject *)v90, v48);
                  uint64_t v51 = v47;
                  while (1)
                  {
                    RDQSRResultObject::operator=((uint64_t)v7 + v51 + 16, (uint64_t)v7 + v51);
                    if (!v51) {
                      break;
                    }
                    int v52 = RDQSRResultObject::getGrammarIndex((RDQSRResultObject *)v90);
                    int v53 = RDQSRResultObject::getGrammarIndex((RDQSRResultObject *)((char *)v7 + v51 - 16));
                    v51 -= 16LL;
                    if (v52 <= v53)
                    {
                      uint64_t v54 = (uint64_t)v7 + v51 + 16;
                      goto LABEL_76;
                    }
                  }

                  uint64_t v54 = (uint64_t)v7;
LABEL_76:
                  RDQSRResultObject::operator=(v54, (uint64_t)v90);
                  RDQSRResultObject::~RDQSRResultObject((RDQSRResultObject *)v90);
                }

                xpc_object_t v44 = (const RDQSRResultObject *)((char *)v48 + 16);
                v47 += 16LL;
              }

              while ((const RDQSRResultObject *)((char *)v48 + 16) != v6);
            }
          }

          else if (!v46)
          {
            do
            {
              int v81 = v44;
              int v82 = RDQSRResultObject::getGrammarIndex(v44);
              if (v82 > (int)RDQSRResultObject::getGrammarIndex(v7))
              {
                RDQSRResultObject::RDQSRResultObject((RDQSRResultObject *)v90, v81);
                do
                {
                  RDQSRResultObject::operator=((uint64_t)v7 + 16, (uint64_t)v7);
                  int v83 = RDQSRResultObject::getGrammarIndex((RDQSRResultObject *)v90);
                  uint64_t v7 = (RDQSRResultObject *)((char *)v7 - 16);
                }

                while (v83 > (int)RDQSRResultObject::getGrammarIndex(v7));
                RDQSRResultObject::operator=((uint64_t)v7 + 16, (uint64_t)v90);
                RDQSRResultObject::~RDQSRResultObject((RDQSRResultObject *)v90);
              }

              xpc_object_t v44 = (const RDQSRResultObject *)((char *)v81 + 16);
              uint64_t v7 = v81;
            }

            while ((const RDQSRResultObject *)((char *)v81 + 16) != v6);
          }
        }

        else if (a3)
        {
          unint64_t v10 = v9 >> 1;
          uint64_t v11 = (RDQSRResultObject *)((char *)v6 - 16);
          if ((unint64_t)v8 < 0x801)
          {
            sub_100035B40((RDQSRResultObject *)((char *)v7 + 16 * (v9 >> 1)), v7, v11);
          }

          else
          {
            sub_100035B40(v7, (RDQSRResultObject *)((char *)v7 + 16 * (v9 >> 1)), v11);
            uint64_t v12 = 16 * v10 - 16;
            sub_100035B40( (RDQSRResultObject *)((char *)v87 + 16),  (RDQSRResultObject *)((char *)v87 + v12),  (RDQSRResultObject *)((char *)v86 - 32));
            uint64_t v13 = 16 * v10 + 16;
            sub_100035B40( (RDQSRResultObject *)((char *)v87 + 32),  (RDQSRResultObject *)((char *)v87 + v13),  (RDQSRResultObject *)((char *)v86 - 48));
            sub_100035B40( (RDQSRResultObject *)((char *)v87 + v12),  (RDQSRResultObject *)((char *)v87 + 16 * v10),  (RDQSRResultObject *)((char *)v87 + v13));
            v90[0] = (uint64_t)v87 + 16 * v10;
            sub_100035C30(&v87, v90);
          }

          --a3;
          if ((a4 & 1) != 0)
          {
            __int16 v14 = v86;
          }

          else
          {
            uint64_t v15 = v87;
            int v16 = RDQSRResultObject::getGrammarIndex((RDQSRResultObject *)((char *)v87 - 16));
            __int16 v14 = v86;
            if (v16 <= (int)RDQSRResultObject::getGrammarIndex(v15))
            {
              unint64_t v29 = v87;
              v88[0] = v87;
              uint64_t v89 = v86;
              RDQSRResultObject::RDQSRResultObject((RDQSRResultObject *)v90, v87);
              int v30 = RDQSRResultObject::getGrammarIndex((RDQSRResultObject *)v90);
              if (v30 <= (int)RDQSRResultObject::getGrammarIndex((RDQSRResultObject *)((char *)v86 - 16)))
              {
                uint64_t v33 = (RDQSRResultObject *)((char *)v29 + 16);
                do
                {
                  unint64_t v31 = v33;
                  v88[0] = v33;
                  if (v33 >= v89) {
                    break;
                  }
                  int v34 = RDQSRResultObject::getGrammarIndex((RDQSRResultObject *)v90);
                  int v35 = RDQSRResultObject::getGrammarIndex(v31);
                  uint64_t v33 = (RDQSRResultObject *)((char *)v31 + 16);
                }

                while (v34 <= v35);
              }

              else
              {
                unint64_t v31 = v29;
                do
                {
                  unint64_t v31 = (RDQSRResultObject *)((char *)v31 + 16);
                  v88[0] = v31;
                  int v32 = RDQSRResultObject::getGrammarIndex((RDQSRResultObject *)v90);
                }

                while (v32 <= (int)RDQSRResultObject::getGrammarIndex(v31));
              }

              double v36 = v89;
              if (v31 < v89)
              {
                do
                {
                  double v36 = (RDQSRResultObject *)((char *)v36 - 16);
                  uint64_t v89 = v36;
                  int v37 = RDQSRResultObject::getGrammarIndex((RDQSRResultObject *)v90);
                }

                while (v37 > (int)RDQSRResultObject::getGrammarIndex(v36));
                unint64_t v31 = v88[0];
              }

              if (v31 < v36)
              {
                do
                {
                  sub_1000359E4(v88, (uint64_t *)&v89);
                  do
                  {
                    v88[0] = (const RDQSRResultObject *)((char *)v88[0] + 16);
                    unint64_t v38 = v88[0];
                    int v39 = RDQSRResultObject::getGrammarIndex((RDQSRResultObject *)v90);
                  }

                  while (v39 <= (int)RDQSRResultObject::getGrammarIndex(v38));
                  do
                  {
                    uint64_t v89 = (RDQSRResultObject *)((char *)v89 - 16);
                    __int16 v40 = v89;
                    int v41 = RDQSRResultObject::getGrammarIndex((RDQSRResultObject *)v90);
                  }

                  while (v41 > (int)RDQSRResultObject::getGrammarIndex(v40));
                  unint64_t v31 = v88[0];
                }

                while (v88[0] < v89);
              }

              uint64_t v42 = (uint64_t)v31 - 16;
              if ((RDQSRResultObject *)v42 != v29) {
                RDQSRResultObject::operator=((uint64_t)v29, v42);
              }
              RDQSRResultObject::operator=(v42, (uint64_t)v90);
              uint64_t v7 = v88[0];
              RDQSRResultObject::~RDQSRResultObject((RDQSRResultObject *)v90);
              goto LABEL_52;
            }
          }

          unint64_t v17 = v87;
          uint64_t v89 = v14;
          RDQSRResultObject::RDQSRResultObject((RDQSRResultObject *)v90, v87);
          uint64_t v18 = 0LL;
          do
          {
            v88[0] = (RDQSRResultObject *)((char *)v17 + v18 + 16);
            int v19 = RDQSRResultObject::getGrammarIndex(v88[0]);
            v18 += 16LL;
          }

          while (v19 > (int)RDQSRResultObject::getGrammarIndex((RDQSRResultObject *)v90));
          uint64_t v20 = v89;
          if (v18 == 16)
          {
            unint64_t v23 = (RDQSRResultObject *)((char *)v17 + 16);
            do
            {
              if (v23 >= v20) {
                break;
              }
              uint64_t v20 = (RDQSRResultObject *)((char *)v20 - 16);
              uint64_t v89 = v20;
              int v24 = RDQSRResultObject::getGrammarIndex(v20);
            }

            while (v24 <= (int)RDQSRResultObject::getGrammarIndex((RDQSRResultObject *)v90));
          }

          else
          {
            unint64_t v21 = (RDQSRResultObject *)((char *)v89 - 16);
            do
            {
              uint64_t v89 = v21;
              int v22 = RDQSRResultObject::getGrammarIndex(v21);
              unint64_t v21 = (RDQSRResultObject *)((char *)v21 - 16);
            }

            while (v22 <= (int)RDQSRResultObject::getGrammarIndex((RDQSRResultObject *)v90));
            unint64_t v23 = v88[0];
          }

          char v25 = v89;
          uint64_t v7 = v23;
          if (v23 < v89)
          {
            do
            {
              sub_1000359E4(v88, (uint64_t *)&v89);
              do
              {
                v88[0] = (const RDQSRResultObject *)((char *)v88[0] + 16);
                int v26 = RDQSRResultObject::getGrammarIndex(v88[0]);
              }

              while (v26 > (int)RDQSRResultObject::getGrammarIndex((RDQSRResultObject *)v90));
              do
              {
                uint64_t v89 = (RDQSRResultObject *)((char *)v89 - 16);
                int v27 = RDQSRResultObject::getGrammarIndex(v89);
              }

              while (v27 <= (int)RDQSRResultObject::getGrammarIndex((RDQSRResultObject *)v90));
              uint64_t v7 = v88[0];
            }

            while (v88[0] < v89);
          }

          RDQSRResultObject::operator=((uint64_t)v7 - 16, (uint64_t)v90);
          RDQSRResultObject::~RDQSRResultObject((RDQSRResultObject *)v90);
          if (v23 < v25)
          {
LABEL_28:
            sub_100035090(v87, (char *)v7 - 16, a3, a4 & 1);
LABEL_52:
            a4 = 0;
LABEL_53:
            int v87 = v7;
            goto LABEL_54;
          }

          BOOL v28 = sub_100035C98((uint64_t)v87, (uint64_t)v7 - 16);
          if (!sub_100035C98((uint64_t)v7, (uint64_t)v86))
          {
            if (v28) {
              goto LABEL_53;
            }
            goto LABEL_28;
          }

          if (!v28)
          {
            unsigned int v86 = (RDQSRResultObject *)((char *)v7 - 16);
            uint64_t v7 = v87;
LABEL_54:
            size_t v6 = v86;
            continue;
          }
        }

        else if (v7 != v6)
        {
          int64_t v55 = (v9 - 2) >> 1;
          unint64_t v84 = v6;
          int64_t v85 = v55;
          do
          {
            int64_t v56 = v55;
            if (v85 >= v55)
            {
              uint64_t v57 = (2 * v55) | 1;
              uint64_t v58 = (uint64_t)v7 + 16 * v57;
              if (2 * v55 + 2 < (uint64_t)v9)
              {
                int v59 = RDQSRResultObject::getGrammarIndex((RDQSRResultObject *)((char *)v7 + 16 * v57));
                if (v59 > (int)RDQSRResultObject::getGrammarIndex((RDQSRResultObject *)(v58 + 16)))
                {
                  v58 += 16LL;
                  uint64_t v57 = 2 * v56 + 2;
                }
              }

              __int128 v60 = (RDQSRResultObject *)((char *)v7 + 16 * v56);
              int v61 = RDQSRResultObject::getGrammarIndex((RDQSRResultObject *)v58);
              if (v61 <= (int)RDQSRResultObject::getGrammarIndex(v60))
              {
                RDQSRResultObject::RDQSRResultObject( (RDQSRResultObject *)v90,  (RDQSRResultObject *)((char *)v7 + 16 * v56));
                do
                {
                  uint64_t v62 = v58;
                  RDQSRResultObject::operator=((uint64_t)v60, v58);
                  if (v85 < v57) {
                    break;
                  }
                  uint64_t v63 = (2 * v57) | 1;
                  uint64_t v58 = (uint64_t)v7 + 16 * v63;
                  uint64_t v57 = 2 * v57 + 2;
                  if (v57 >= (uint64_t)v9)
                  {
                    uint64_t v57 = v63;
                  }

                  else
                  {
                    int v64 = RDQSRResultObject::getGrammarIndex((RDQSRResultObject *)((char *)v7 + 16 * v63));
                    else {
                      v58 += 16LL;
                    }
                  }

                  int v65 = RDQSRResultObject::getGrammarIndex((RDQSRResultObject *)v58);
                  __int128 v60 = (RDQSRResultObject *)v62;
                }

                while (v65 <= (int)RDQSRResultObject::getGrammarIndex((RDQSRResultObject *)v90));
                RDQSRResultObject::operator=(v62, (uint64_t)v90);
                RDQSRResultObject::~RDQSRResultObject((RDQSRResultObject *)v90);
              }
            }

            int64_t v55 = v56 - 1;
          }

          while (v56);
          uint64_t v66 = (unint64_t)v8 >> 4;
          uint64_t v67 = (uint64_t)v84;
          do
          {
            RDQSRResultObject::RDQSRResultObject((RDQSRResultObject *)v88, v7);
            uint64_t v68 = 0LL;
            uint64_t v69 = (uint64_t)v7;
            do
            {
              uint64_t v70 = v69 + 16 * v68 + 16;
              uint64_t v71 = 2 * v68;
              uint64_t v68 = (2 * v68) | 1;
              uint64_t v72 = v71 + 2;
              if (v71 + 2 < v66)
              {
                int v73 = RDQSRResultObject::getGrammarIndex((RDQSRResultObject *)v70);
                if (v73 > (int)RDQSRResultObject::getGrammarIndex((RDQSRResultObject *)(v70 + 16)))
                {
                  v70 += 16LL;
                  uint64_t v68 = v72;
                }
              }

              RDQSRResultObject::operator=(v69, v70);
              uint64_t v69 = v70;
            }

            while (v68 <= (uint64_t)((unint64_t)(v66 - 2) >> 1));
            v67 -= 16LL;
            if (v70 == v67)
            {
              RDQSRResultObject::operator=(v70, (uint64_t)v88);
            }

            else
            {
              RDQSRResultObject::operator=(v70, v67);
              RDQSRResultObject::operator=(v67, (uint64_t)v88);
              uint64_t v74 = v70 - (void)v7 + 16;
              if (v74 >= 17)
              {
                unint64_t v75 = (((unint64_t)v74 >> 4) - 2) >> 1;
                uint64_t v76 = (RDQSRResultObject *)((char *)v7 + 16 * v75);
                int v77 = RDQSRResultObject::getGrammarIndex(v76);
                if (v77 > (int)RDQSRResultObject::getGrammarIndex((RDQSRResultObject *)v70))
                {
                  RDQSRResultObject::RDQSRResultObject((RDQSRResultObject *)v90, (const RDQSRResultObject *)v70);
                  do
                  {
                    uint64_t v78 = (uint64_t)v76;
                    RDQSRResultObject::operator=(v70, (uint64_t)v76);
                    if (!v75) {
                      break;
                    }
                    unint64_t v75 = (v75 - 1) >> 1;
                    uint64_t v76 = (RDQSRResultObject *)((char *)v7 + 16 * v75);
                    int v79 = RDQSRResultObject::getGrammarIndex(v76);
                    uint64_t v70 = v78;
                  }

                  while (v79 > (int)RDQSRResultObject::getGrammarIndex((RDQSRResultObject *)v90));
                  RDQSRResultObject::operator=(v78, (uint64_t)v90);
                  RDQSRResultObject::~RDQSRResultObject((RDQSRResultObject *)v90);
                }
              }
            }

            RDQSRResultObject::~RDQSRResultObject((RDQSRResultObject *)v88);
          }

          while (v66-- > 2);
        }

        return;
    }
  }

void sub_10003595C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  uint64_t v7 = va_arg(va1, void);
  uint64_t v9 = va_arg(va1, void);
  uint64_t v10 = va_arg(va1, void);
  RDQSRResultObject::~RDQSRResultObject((RDQSRResultObject *)va1);
  RDQSRResultObject::~RDQSRResultObject((RDQSRResultObject *)va);
  _Unwind_Resume(a1);
}

void sub_1000359E4(const RDQSRResultObject **a1, uint64_t *a2)
{
  uint64_t v2 = *a1;
  uint64_t v3 = *a2;
  RDQSRResultObject::RDQSRResultObject((RDQSRResultObject *)v4, *a1);
  RDQSRResultObject::operator=((uint64_t)v2, v3);
  RDQSRResultObject::operator=(v3, (uint64_t)v4);
  RDQSRResultObject::~RDQSRResultObject((RDQSRResultObject *)v4);
}

void sub_100035A38( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_100035A4C( const RDQSRResultObject *a1, RDQSRResultObject *a2, RDQSRResultObject *a3, RDQSRResultObject *a4, uint64_t a5)
{
  unint64_t v5 = (RDQSRResultObject *)a5;
  int v16 = a2;
  unint64_t v17 = a1;
  __int16 v14 = a4;
  uint64_t v15 = a3;
  uint64_t v13 = a5;
  sub_100035E74(a1, a2, a3, (uint64_t)a4);
  LODWORD(v5) = RDQSRResultObject::getGrammarIndex(v5);
  if ((int)v5 > (int)RDQSRResultObject::getGrammarIndex(a4))
  {
    sub_1000359E4(&v14, &v13);
    int GrammarIndex = RDQSRResultObject::getGrammarIndex(v14);
    if (GrammarIndex > (int)RDQSRResultObject::getGrammarIndex(a3))
    {
      sub_1000359E4(&v15, (uint64_t *)&v14);
      int v11 = RDQSRResultObject::getGrammarIndex(v15);
      if (v11 > (int)RDQSRResultObject::getGrammarIndex(a2))
      {
        sub_1000359E4(&v16, (uint64_t *)&v15);
        int v12 = RDQSRResultObject::getGrammarIndex(v16);
      }
    }
  }

void sub_100035B40(const RDQSRResultObject *a1, RDQSRResultObject *this, RDQSRResultObject *a3)
{
  unint64_t v5 = a1;
  int v16 = this;
  unint64_t v17 = a1;
  uint64_t v15 = a3;
  int GrammarIndex = RDQSRResultObject::getGrammarIndex(this);
  LODWORD(v5) = RDQSRResultObject::getGrammarIndex(v5);
  int v7 = RDQSRResultObject::getGrammarIndex(a3);
  int v8 = RDQSRResultObject::getGrammarIndex(this);
  if (GrammarIndex > (int)v5)
  {
    if (v7 <= v8)
    {
      sub_1000359E4(&v17, (uint64_t *)&v16);
      uint64_t v13 = v16;
      int v14 = RDQSRResultObject::getGrammarIndex(v15);
      uint64_t v9 = &v16;
    }

    else
    {
      uint64_t v9 = &v17;
    }

    int v12 = &v15;
    goto LABEL_10;
  }

  if (v7 > v8)
  {
    sub_1000359E4(&v16, (uint64_t *)&v15);
    uint64_t v10 = v17;
    int v11 = RDQSRResultObject::getGrammarIndex(v16);
    if (v11 > (int)RDQSRResultObject::getGrammarIndex(v10))
    {
      uint64_t v9 = &v17;
      int v12 = &v16;
LABEL_10:
      sub_1000359E4(v9, (uint64_t *)v12);
    }
  }

void sub_100035C30(const RDQSRResultObject **a1, uint64_t *a2)
{
  uint64_t v2 = *a1;
  uint64_t v3 = *a2;
  RDQSRResultObject::RDQSRResultObject((RDQSRResultObject *)v4, *a1);
  RDQSRResultObject::operator=((uint64_t)v2, v3);
  RDQSRResultObject::operator=(v3, (uint64_t)v4);
  RDQSRResultObject::~RDQSRResultObject((RDQSRResultObject *)v4);
}

void sub_100035C84( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

BOOL sub_100035C98(uint64_t a1, uint64_t a2)
{
  int v14 = (RDQSRResultObject *)a2;
  uint64_t v15 = (const RDQSRResultObject *)a1;
  BOOL v4 = 1LL;
  switch((a2 - a1) >> 4)
  {
    case 0LL:
    case 1LL:
      return v4;
    case 2LL:
      int v14 = (RDQSRResultObject *)(a2 - 16);
      int GrammarIndex = RDQSRResultObject::getGrammarIndex((RDQSRResultObject *)(a2 - 16));
      return 1LL;
    case 3LL:
      sub_100035B40((const RDQSRResultObject *)a1, (RDQSRResultObject *)(a1 + 16), (RDQSRResultObject *)(a2 - 16));
      return v4;
    case 4LL:
      sub_100035E74( (const RDQSRResultObject *)a1,  (RDQSRResultObject *)(a1 + 16),  (RDQSRResultObject *)(a1 + 32),  a2 - 16);
      return v4;
    case 5LL:
      sub_100035A4C( (const RDQSRResultObject *)a1,  (RDQSRResultObject *)(a1 + 16),  (RDQSRResultObject *)(a1 + 32),  (RDQSRResultObject *)(a1 + 48),  a2 - 16);
      return v4;
    default:
      size_t v6 = (RDQSRResultObject *)(a1 + 32);
      sub_100035B40((const RDQSRResultObject *)a1, (RDQSRResultObject *)(a1 + 16), (RDQSRResultObject *)(a1 + 32));
      int v7 = (RDQSRResultObject *)(a1 + 48);
      if (v7 == (RDQSRResultObject *)a2) {
        return 1LL;
      }
      int v8 = 0;
      break;
  }

  while (1)
  {
    int v9 = RDQSRResultObject::getGrammarIndex(v7);
LABEL_12:
    size_t v6 = v7;
    int v7 = (RDQSRResultObject *)((char *)v7 + 16);
    if (v7 == v14) {
      return 1LL;
    }
  }

  RDQSRResultObject::RDQSRResultObject((RDQSRResultObject *)v13, v7);
  do
  {
    uint64_t v10 = (uint64_t)v6;
    RDQSRResultObject::operator=((uint64_t)v6 + 16, (uint64_t)v6);
    if (v6 == v15) {
      break;
    }
    int v11 = RDQSRResultObject::getGrammarIndex((RDQSRResultObject *)v13);
    size_t v6 = (RDQSRResultObject *)((char *)v6 - 16);
  }

  while (v11 > (int)RDQSRResultObject::getGrammarIndex((RDQSRResultObject *)(v10 - 16)));
  RDQSRResultObject::operator=(v10, (uint64_t)v13);
  if (++v8 != 8)
  {
    RDQSRResultObject::~RDQSRResultObject((RDQSRResultObject *)v13);
    goto LABEL_12;
  }

  BOOL v4 = (RDQSRResultObject *)((char *)v7 + 16) == v14;
  RDQSRResultObject::~RDQSRResultObject((RDQSRResultObject *)v13);
  return v4;
}

void sub_100035E5C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_100035E74(const RDQSRResultObject *a1, RDQSRResultObject *a2, RDQSRResultObject *a3, uint64_t a4)
{
  BOOL v4 = (RDQSRResultObject *)a4;
  int v12 = a2;
  uint64_t v13 = a1;
  uint64_t v10 = a4;
  int v11 = a3;
  sub_100035B40(a1, a2, a3);
  LODWORD(RDQSREngine::MatchResult(this, v4) = RDQSRResultObject::getGrammarIndex(v4);
  if ((int)v4 > (int)RDQSRResultObject::getGrammarIndex(a3))
  {
    sub_1000359E4(&v11, &v10);
    int GrammarIndex = RDQSRResultObject::getGrammarIndex(v11);
    if (GrammarIndex > (int)RDQSRResultObject::getGrammarIndex(a2))
    {
      sub_1000359E4(&v12, (uint64_t *)&v11);
      int v9 = RDQSRResultObject::getGrammarIndex(v12);
    }
  }

CFStringRef RDCopyModelPath(void)
{
  int v0 = (const __CFArray *)CFCopySearchPathForDirectoriesInDomains(5LL, 8LL, 1LL);
  ValueAtIndex = (const __CFURL *)CFArrayGetValueAtIndex(v0, 0LL);
  CFStringRef v2 = CFURLCopyFileSystemPath(ValueAtIndex, kCFURLPOSIXPathStyle);
  CFStringRef v3 = CFStringCreateWithFormat(0LL, 0LL, @"%@/Speech/Recognizers/SpeechRecognitionCoreLanguages", v2);
  CFRelease(v2);
  CFRelease(v0);
  return v3;
}

CFURLRef RDCopyCacheURL(void)
{
  int v0 = (const __CFArray *)CFCopySearchPathForDirectoriesInDomains(13LL, 1LL, 1LL);
  ValueAtIndex = (const __CFURL *)CFArrayGetValueAtIndex(v0, 0LL);
  CFStringRef v2 = CFURLCreateCopyAppendingPathComponent(0LL, ValueAtIndex, @"com.apple.SpeechRecognitionCore", 1u);
  CFRelease(v0);
  CFStringRef v3 = CFURLCopyPath(v2);
  if (v3)
  {
    BOOL v4 = v3;
    CFStringGetCString(v3, buffer, 2000LL, 0x8000100u);
    unint64_t v5 = opendir(buffer);
    if (v5)
    {
      closedir(v5);
    }

    else if (mkdir(buffer, 0x1EDu))
    {
      int v7 = (os_log_s *)RXOSLog();
      if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
      {
        int v8 = 138412290;
        int v9 = v2;
        _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, "Error creating %@", (uint8_t *)&v8, 0xCu);
      }
    }

    CFRelease(v4);
  }

  return v2;
}

CFDictionaryRef RDCopyInfoDict(CFURLRef url)
{
  uint64_t v1 = CFURLCreateCopyAppendingPathComponent(0LL, url, @"Info.plist", 0);
  return sub_100036108(v1);
}

CFDictionaryRef sub_100036108(CFURLRef fileURL)
{
  if (!fileURL) {
    return 0LL;
  }
  CFStringRef v2 = CFReadStreamCreateWithFile(0LL, fileURL);
  if (v2)
  {
    CFStringRef v3 = v2;
    CFReadStreamOpen(v2);
    CFErrorRef error = 0LL;
    BOOL v4 = (const __CFDictionary *)CFPropertyListCreateWithStream(0LL, v3, 0LL, 0LL, 0LL, &error);
    unint64_t v5 = v4;
    if (v4)
    {
      Value = (const __CFString *)CFDictionaryGetValue(v4, @"CFBundleShortVersionString");
      if (CFStringGetCharacterAtIndex(Value, 0LL) <= 0x31u)
      {
        CFRelease(v5);
        unint64_t v5 = 0LL;
      }
    }

    CFReadStreamClose(v3);
    CFRelease(v3);
  }

  else
  {
    unint64_t v5 = 0LL;
  }

  CFRelease(fileURL);
  return v5;
}

CFBooleanRef RDCopyCacheVersion(const __CFString *a1)
{
  uint64_t v1 = sub_1000362D4(a1);
  if (v1)
  {
    CFStringRef v2 = v1;
    CFStringRef v3 = CFURLCreateCopyAppendingPathComponent(0LL, v1, @"Info.plist", 0);
    BOOL v4 = sub_100036108(v3);
    if (v4)
    {
      unint64_t v5 = v4;
      Value = (const __CFBoolean *)CFDictionaryGetValue(v4, @"CFBundleShortVersionString");
      if (Value)
      {
        CFBooleanRef v7 = Value;
        CFRetain(Value);
        CFRelease(v5);
LABEL_15:
        CFRelease(v2);
        return v7;
      }

      CFRelease(v5);
    }

    RDURL::RDURL((RDURL *)__p, v2, 0);
    if (v11 >= 0) {
      int v8 = __p;
    }
    else {
      int v8 = (void **)__p[0];
    }
    else {
      CFBooleanRef v7 = kCFBooleanTrue;
    }
    if (v11 < 0) {
      operator delete(__p[0]);
    }
    goto LABEL_15;
  }

  return 0LL;
}

void sub_1000362B8( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

CFURLRef sub_1000362D4(const __CFString *a1)
{
  CFStringRef v1 = RDCopyBestNashvilleLocaleIdentifier(a1);
  if (!v1) {
    return 0LL;
  }
  CFStringRef v2 = v1;
  CFStringRef v3 = RDCopyCacheURL();
  if (v3)
  {
    BOOL v4 = v3;
    unint64_t v5 = CFURLCreateCopyAppendingPathComponent(0LL, v3, @"Users", 1u);
    if (v5)
    {
      size_t v6 = v5;
      CFURLRef v7 = CFURLCreateCopyAppendingPathComponent(0LL, v5, v2, 1u);
      CFRelease(v6);
    }

    else
    {
      CFURLRef v7 = 0LL;
    }

    CFRelease(v4);
  }

  else
  {
    CFURLRef v7 = 0LL;
  }

  CFRelease(v2);
  return v7;
}

void RDNukeCache(const __CFString *a1)
{
  if (a1)
  {
    CFStringRef v1 = sub_1000362D4(a1);
    if (!v1) {
      return;
    }
    RDURL::RDURL((RDURL *)__p, v1, 1);
    if (v5 >= 0) {
      CFStringRef v2 = __p;
    }
    else {
      CFStringRef v2 = (void **)__p[0];
    }
  }

  else
  {
    CFStringRef v3 = RDCopyCacheURL();
    if (!v3) {
      return;
    }
    RDURL::RDURL((RDURL *)__p, v3, 1);
    if (v5 >= 0) {
      CFStringRef v2 = __p;
    }
    else {
      CFStringRef v2 = (void **)__p[0];
    }
  }

  removefile((const char *)v2, 0LL, 1u);
  if (v5 < 0) {
    operator delete(__p[0]);
  }
}

void sub_100036424( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

__CFSet *RDCopyNashvilleModelLanguages(void)
{
  int v0 = RDCopyModelPath();
  RDString::RDString((RDString *)v22, v0, 1);
  if ((v23 & 0x80u) == 0) {
    CFStringRef v1 = v22;
  }
  else {
    CFStringRef v1 = (void **)v22[0];
  }
  CFStringRef v2 = opendir((const char *)v1);
  CFMutableSetRef Mutable = CFSetCreateMutable(0LL, 0LL, &kCFTypeSetCallBacks);
  BOOL v4 = Mutable;
  if (v2) {
    BOOL v5 = Mutable == 0LL;
  }
  else {
    BOOL v5 = 1;
  }
  if (!v5)
  {
    while (1)
    {
      while (1)
      {
        do
        {
          size_t v6 = readdir(v2);
          if (!v6)
          {
            closedir(v2);
            goto LABEL_30;
          }

          d_name = v6->d_name;
          int v8 = strstr(v6->d_name, ".SpeechRecognition");
        }

        while (!v8);
        int v9 = v8;
        if ((v23 & 0x80u) == 0) {
          size_t v10 = v23;
        }
        else {
          size_t v10 = (size_t)v22[1];
        }
        sub_100037608((uint64_t)&v20, v10 + 1);
        if ((v20.__r_.__value_.__s.__size_ & 0x80u) == 0) {
          char v11 = &v20;
        }
        else {
          char v11 = (std::string *)v20.__r_.__value_.__r.__words[0];
        }
        if (v10)
        {
          if ((v23 & 0x80u) == 0) {
            stat v12 = v22;
          }
          else {
            stat v12 = (void **)v22[0];
          }
          memmove(v11, v12, v10);
        }

        *(_WORD *)((char *)&v11->__r_.__value_.__l.__data_ + v1sub_10001AFB0((std::locale *)v24, " +$", 0) = 47;
        uint64_t v13 = std::string::append(&v20, d_name);
        __int128 v14 = *(_OWORD *)&v13->__r_.__value_.__l.__data_;
        __p.__r_.__value_.__l.__cap_ = v13->__r_.__value_.__l.__cap_;
        *(_OWORD *)&__p.__r_.__value_.__l.__data_ = v14;
        v13->__r_.__value_.__l.__size_ = 0LL;
        v13->__r_.__value_.__l.__cap_ = 0LL;
        v13->__r_.__value_.__r.__words[0] = 0LL;
        BOOL v15 = sub_1000366BC(&__p);
        if (v15) {
          goto LABEL_27;
        }
      }

      operator delete(v20.__r_.__value_.__l.__data_);
      if (v15)
      {
LABEL_27:
        CFStringRef v16 = CFStringCreateWithBytes(0LL, (const UInt8 *)d_name, v9 - d_name, 0x8000100u, 0);
        CFSetAddValue(v4, v16);
        CFRelease(v16);
        unint64_t v17 = strchr(d_name, 95);
        if (v17)
        {
          CFStringRef v18 = CFStringCreateWithBytes(0LL, (const UInt8 *)d_name, v17 - d_name, 0x8000100u, 0);
          CFSetAddValue(v4, v18);
          CFRelease(v18);
        }
      }
    }
  }

void sub_10003665C( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20, char a21, uint64_t a22, void *__p, uint64_t a24, int a25, __int16 a26, char a27, char a28)
{
  if (a28 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_1000366BC(std::string *a1)
{
  CFStringRef v1 = a1;
  std::string::append(a1, "/Contents/Info.plist");
  CFStringRef v2 = (const char *)v1;
  if (stat(v2, &v9)) {
    return 0LL;
  }
  BOOL v4 = CFStringCreateWithCStringNoCopy(0LL, (const char *)v1, 0x8000100u, kCFAllocatorNull);
  if (!v4) {
    return 0LL;
  }
  BOOL v5 = v4;
  size_t v6 = CFURLCreateWithFileSystemPath(0LL, v4, kCFURLPOSIXPathStyle, 0);
  CFURLRef v7 = sub_100036108(v6);
  BOOL v3 = v7 != 0LL;
  if (v7) {
    CFRelease(v7);
  }
  CFRelease(v5);
  return v3;
}

CFStringRef RDCopyBestNashvilleLocaleIdentifier(CFStringRef theString)
{
  std::string v67 = v66;
  memset(&v66, 0, sizeof(v66));
  CFStringRef v1 = RDCopyModelPath();
  if (!v1)
  {
    sub_10000A2DC(&cStr, "");
    goto LABEL_169;
  }

  RDString::RDString((RDString *)v80, v1, 1);
  std::string::push_back(v2, 47);
  sub_10000A2DC(&v77, ".SpeechRecognition");
  sub_100037468(v80, (const void **)&v67.__r_.__value_.__l.__data_, (uint64_t)&v75);
  if ((v79 & 0x80u) == 0) {
    BOOL v3 = (const std::string::value_type *)&v77;
  }
  else {
    BOOL v3 = (const std::string::value_type *)v77;
  }
  if ((v79 & 0x80u) == 0) {
    std::string::size_type v4 = v79;
  }
  else {
    std::string::size_type v4 = v78;
  }
  BOOL v5 = std::string::append(&v75, v3, v4);
  __int128 v6 = *(_OWORD *)&v5->__r_.__value_.__l.__data_;
  v76.__r_.__value_.__l.__cap_ = v5->__r_.__value_.__l.__cap_;
  *(_OWORD *)&v76.__r_.__value_.__l.__data_ = v6;
  v5->__r_.__value_.__l.__size_ = 0LL;
  v5->__r_.__value_.__l.__cap_ = 0LL;
  v5->__r_.__value_.__r.__words[0] = 0LL;
  BOOL v7 = sub_1000366BC(&v76);
  if ((char)v75.__r_.__value_.__s.__size_ < 0)
  {
    operator delete(v75.__r_.__value_.__l.__data_);
    if (v7) {
      goto LABEL_59;
    }
  }

  else if (v7)
  {
    goto LABEL_59;
  }

  std::string::size_type v8 = std::string::find(&v67, 46, 0LL);
  if (v8 != -1LL)
  {
    stat v9 = (char *)&v67 + v67.__r_.__value_.__s.__size_;
    if ((v67.__r_.__value_.__s.__size_ & 0x80u) == 0)
    {
      size_t v10 = &v67;
    }

    else
    {
      stat v9 = (char *)(v67.__r_.__value_.__r.__words[0] + v67.__r_.__value_.__l.__size_);
      size_t v10 = (std::string *)v67.__r_.__value_.__r.__words[0];
    }

    std::string::erase(&v67, v8, v9 - ((char *)v10 + v8));
    sub_100037468(v80, (const void **)&v67.__r_.__value_.__l.__data_, (uint64_t)&v74);
    if ((v79 & 0x80u) == 0) {
      char v11 = (const std::string::value_type *)&v77;
    }
    else {
      char v11 = (const std::string::value_type *)v77;
    }
    if ((v79 & 0x80u) == 0) {
      std::string::size_type v12 = v79;
    }
    else {
      std::string::size_type v12 = v78;
    }
    uint64_t v13 = std::string::append(&v74, v11, v12);
    __int128 v14 = *(_OWORD *)&v13->__r_.__value_.__l.__data_;
    v75.__r_.__value_.__l.__cap_ = v13->__r_.__value_.__l.__cap_;
    *(_OWORD *)&v75.__r_.__value_.__l.__data_ = v14;
    v13->__r_.__value_.__l.__size_ = 0LL;
    v13->__r_.__value_.__l.__cap_ = 0LL;
    v13->__r_.__value_.__r.__words[0] = 0LL;
    BOOL v15 = sub_1000366BC(&v75);
    if ((char)v74.__r_.__value_.__s.__size_ < 0)
    {
      operator delete(v74.__r_.__value_.__l.__data_);
      if (v15) {
        goto LABEL_59;
      }
    }

    else if (v15)
    {
      goto LABEL_59;
    }
  }

  if ((v67.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    CFStringRef v16 = &v67;
  }
  else {
    CFStringRef v16 = (std::string *)v67.__r_.__value_.__r.__words[0];
  }
  if ((v67.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    std::string::size_type size = v67.__r_.__value_.__s.__size_;
  }
  else {
    std::string::size_type size = v67.__r_.__value_.__l.__size_;
  }
  if (size)
  {
    CFStringRef v18 = (unsigned __int8 *)v16 + size;
    int v19 = v16;
LABEL_39:
    uint64_t v20 = 0LL;
    while (v19->__r_.__value_.__s.__data_[0] != asc_1000BE49F[v20])
    {
      if (++v20 == 2)
      {
        int v19 = (std::string *)((char *)v19 + 1);
        if (v19 == (std::string *)v18) {
          goto LABEL_60;
        }
        goto LABEL_39;
      }
    }

    if (v19 != (std::string *)v18 && (char *)v19 - (char *)v16 != -1)
    {
      unint64_t v21 = (char *)&v67 + v67.__r_.__value_.__s.__size_;
      if ((v67.__r_.__value_.__s.__size_ & 0x80u) != 0) {
        unint64_t v21 = (char *)(v67.__r_.__value_.__r.__words[0] + v67.__r_.__value_.__l.__size_);
      }
      std::string::erase(&v67, (char *)v19 - (char *)v16, v21 - (char *)v19);
      sub_100037468(v80, (const void **)&v67.__r_.__value_.__l.__data_, (uint64_t)&v73);
      if ((v79 & 0x80u) == 0) {
        int v22 = (const std::string::value_type *)&v77;
      }
      else {
        int v22 = (const std::string::value_type *)v77;
      }
      if ((v79 & 0x80u) == 0) {
        std::string::size_type v23 = v79;
      }
      else {
        std::string::size_type v23 = v78;
      }
      int v24 = std::string::append(&v73, v22, v23);
      __int128 v25 = *(_OWORD *)&v24->__r_.__value_.__l.__data_;
      v74.__r_.__value_.__l.__cap_ = v24->__r_.__value_.__l.__cap_;
      *(_OWORD *)&v74.__r_.__value_.__l.__data_ = v25;
      v24->__r_.__value_.__l.__size_ = 0LL;
      v24->__r_.__value_.__l.__cap_ = 0LL;
      v24->__r_.__value_.__r.__words[0] = 0LL;
      BOOL v26 = sub_1000366BC(&v74);
      if (v26)
      {
LABEL_59:
        std::string cStr = v67;
        memset(&v67, 0, sizeof(v67));
        goto LABEL_165;
      }
    }
  }

LABEL_60:
  sub_10000A2DC(&v73, "");
  if (((char)v67.__r_.__value_.__s.__size_ & 0x80000000) == 0)
  {
    if (v67.__r_.__value_.__s.__size_ != 2) {
      goto LABEL_76;
    }
    if (LOWORD(v67.__r_.__value_.__l.__data_) != 28261)
    {
      if (LOWORD(v67.__r_.__value_.__l.__data_) != 29286)
      {
        if (LOWORD(v67.__r_.__value_.__l.__data_) != 29541)
        {
          int v27 = &v67;
          goto LABEL_70;
        }

LABEL_74:
        BOOL v28 = "es_US";
        goto LABEL_75;
      }

LABEL_73:
      BOOL v28 = "fr_FR";
      goto LABEL_75;
    }

  __break(1u);
LABEL_74:
  __break(1u);
LABEL_75:
  __break(1u);
LABEL_76:
  __break(1u);
}

LABEL_72:
    BOOL v28 = "en_US";
    goto LABEL_75;
  }

  if (v67.__r_.__value_.__l.__size_ != 2) {
    goto LABEL_76;
  }
  int v27 = (std::string *)v67.__r_.__value_.__r.__words[0];
  switch(*(_WORD *)v67.__r_.__value_.__l.__data_)
  {
    case 0x6E65:
      goto LABEL_72;
    case 0x7266:
      goto LABEL_73;
    case 0x7365:
      goto LABEL_74;
  }

      int v30 = v51;
      goto LABEL_73;
    }

    break;
  }

  if ((void)v50) {
    (*(void (**)(void))(*(void *)v50 + 8LL))();
  }
LABEL_118:
  (*(void (**)(uint64_t *, uint64_t))(*a2 + 152))(a2, v11);
  if ((_DWORD)v11 == (_DWORD)v9) {
    int v41 = v26;
  }
  else {
    int v41 = 1;
  }
  if ((v41 & 1) == 0)
  {
    (*(void (**)(__int128 *__return_ptr, uint64_t, uint64_t))(*(void *)a1 + 24LL))(&v53, a1, v9);
    int64_t v48 = v53;
    (*(void (**)(uint64_t *, uint64_t, int *))(*a2 + 160))(a2, v9, &v48);
  }

  uint64_t v42 = (*(uint64_t (**)(uint64_t, uint64_t, void))(*(void *)a1 + 56LL))(a1, 0xFFFFFFFF0004LL, 0LL);
  CFRange v43 = v62 | v42;
  int64_t v44 = (*(uint64_t (**)(uint64_t *, uint64_t, void))(*a2 + 56))(a2, 0xFFFFFFFF0007LL, 0LL) | v47;
  uint64_t v45 = sub_1000A4BD4(v43, v26);
  return (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*a2 + 168))(a2, v44 | v45, 0xFFFFFFFF0007LL);
}

LABEL_70:
  if (LOWORD(v27->__r_.__value_.__l.__data_) == 25956)
  {
    BOOL v28 = "de_DE";
LABEL_75:
    std::string::assign(&v73, v28);
  }

              int v32 = v38;
            }

            while (v38 != v14);
          }
        }

        sub_100039A0C((uint64_t *)a1, v49, v50);
        sub_10001A760((uint64_t)&v43);
        sub_10001A760((uint64_t)&v46);
        sub_10003A2C8((uint64_t)&v49, v50[0]);
      }
    }
  }

LABEL_76:
  std::string::size_type v29 = v73.__r_.__value_.__s.__size_;
  if ((v73.__r_.__value_.__s.__size_ & 0x80u) != 0) {
    std::string::size_type v29 = v73.__r_.__value_.__l.__size_;
  }
  if (v29)
  {
    sub_100037468(v80, (const void **)&v73.__r_.__value_.__l.__data_, (uint64_t)&__s1);
    if ((v79 & 0x80u) == 0) {
      int v30 = (const std::string::value_type *)&v77;
    }
    else {
      int v30 = (const std::string::value_type *)v77;
    }
    if ((v79 & 0x80u) == 0) {
      std::string::size_type v31 = v79;
    }
    else {
      std::string::size_type v31 = v78;
    }
    int v32 = std::string::append(&__s1, v30, v31);
    __int128 v33 = *(_OWORD *)&v32->__r_.__value_.__l.__data_;
    __p.__r_.__value_.__l.__cap_ = v32->__r_.__value_.__l.__cap_;
    *(_OWORD *)&__p.__r_.__value_.__l.__data_ = v33;
    v32->__r_.__value_.__l.__size_ = 0LL;
    v32->__r_.__value_.__l.__cap_ = 0LL;
    v32->__r_.__value_.__r.__words[0] = 0LL;
    BOOL v34 = sub_1000366BC(&__p);
    if ((char)__s1.__r_.__value_.__s.__size_ < 0)
    {
      operator delete(__s1.__r_.__value_.__l.__data_);
      if (v34) {
        goto LABEL_89;
      }
    }

    else if (v34)
    {
LABEL_89:
      std::string cStr = v73;
      memset(&v73, 0, sizeof(v73));
      goto LABEL_163;
    }
  }

  if ((v81 & 0x80u) == 0) {
    int v35 = (const char *)v80;
  }
  else {
    int v35 = (const char *)v80[0];
  }
  double v36 = opendir(v35);
  if (!v36)
  {
LABEL_162:
    sub_10000A2DC(&cStr, "");
    goto LABEL_163;
  }

  while (1)
  {
    int v37 = readdir(v36);
    if (!v37)
    {
      closedir(v36);
      goto LABEL_162;
    }

    d_name = v37->d_name;
    sub_10000A2DC(&__s1, v37->d_name);
    int64_t v39 = __s1.__r_.__value_.__s.__size_;
    int v40 = (char)__s1.__r_.__value_.__s.__size_;
    p_s1 = (std::string *)__s1.__r_.__value_.__r.__words[0];
    uint64_t v42 = (__s1.__r_.__value_.__s.__size_ & 0x80u) == 0 ? &__s1 : (std::string *)__s1.__r_.__value_.__r.__words[0];
    CFRange v43 = (v79 & 0x80u) == 0 ? (void **)&v77 : v77;
    int64_t v44 = (v79 & 0x80u) == 0 ? v79 : v78;
    if (!v44) {
      goto LABEL_140;
    }
    if ((__s1.__r_.__value_.__s.__size_ & 0x80u) != 0) {
      int64_t v39 = __s1.__r_.__value_.__l.__size_;
    }
    if (v39 >= v44)
    {
      uint64_t v45 = (char *)v42 + v39;
      int v46 = *(char *)v43;
      uint64_t v47 = v42;
      while (1)
      {
        int64_t v48 = v39 - v44;
        if (v48 == -1) {
          goto LABEL_159;
        }
        uint64_t v49 = (char *)memchr(v47, v46, v48 + 1);
        if (!v49) {
          goto LABEL_159;
        }
        int v50 = v49;
        if (!memcmp(v49, v43, v44)) {
          break;
        }
        uint64_t v47 = (std::string *)(v50 + 1);
        int64_t v39 = v45 - (v50 + 1);
        if (v39 < v44) {
          goto LABEL_159;
        }
      }

      if (v50 != v45 && v50 - (char *)v42 != -1)
      {
LABEL_140:
        std::string::size_type v51 = (v67.__r_.__value_.__s.__size_ & 0x80u) == 0
            ? v67.__r_.__value_.__s.__size_
            : v67.__r_.__value_.__l.__size_;
        if (v40 < 0)
        {
          if (v51 == -1LL) {
LABEL_186:
          }
            sub_10001801C();
          unint64_t v52 = __s1.__r_.__value_.__l.__size_ >= 2 ? 2LL : __s1.__r_.__value_.__l.__size_;
        }

        else
        {
          if (v51 == -1LL) {
            goto LABEL_186;
          }
          unint64_t v52 = (v40 & 0xFE) != 0 ? 2LL : v40;
          p_s1 = &__s1;
        }

        int v53 = (v67.__r_.__value_.__s.__size_ & 0x80u) == 0 ? &v67 : (std::string *)v67.__r_.__value_.__r.__words[0];
        size_t v54 = v52 >= v51 ? v51 : v52;
        if (!memcmp(p_s1, v53, v54) && v52 == v51) {
          break;
        }
      }
    }

LABEL_159:
    if ((v40 & 0x80) != 0) {
      operator delete(__s1.__r_.__value_.__l.__data_);
    }
  }

  if ((v81 & 0x80u) == 0) {
    size_t v56 = v81;
  }
  else {
    size_t v56 = (size_t)v80[1];
  }
  sub_100037608((uint64_t)&v69, v56 + 1);
  if ((v69.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    uint64_t v57 = &v69;
  }
  else {
    uint64_t v57 = (std::string *)v69.__r_.__value_.__r.__words[0];
  }
  if (v56)
  {
    if ((v81 & 0x80u) == 0) {
      uint64_t v58 = v80;
    }
    else {
      uint64_t v58 = (const void **)v80[0];
    }
    memmove(v57, v58, v56);
  }

  *(_WORD *)((char *)&v57->__r_.__value_.__l.__data_ + v++*(void *)(result + 56) = 47;
  int v59 = std::string::append(&v69, d_name);
  __int128 v60 = *(_OWORD *)&v59->__r_.__value_.__l.__data_;
  v70.__r_.__value_.__l.__cap_ = v59->__r_.__value_.__l.__cap_;
  *(_OWORD *)&v70.__r_.__value_.__l.__data_ = v60;
  v59->__r_.__value_.__l.__size_ = 0LL;
  v59->__r_.__value_.__l.__cap_ = 0LL;
  v59->__r_.__value_.__r.__words[0] = 0LL;
  BOOL v61 = sub_1000366BC(&v70);
  if (!v61)
  {
    LOBYTE(v4RDString::RDString((RDString *)&v66, theString, 0) = __s1.__r_.__value_.__s.__size_;
    goto LABEL_159;
  }

  closedir(v36);
  std::string::size_type v65 = sub_100037530((uint64_t *)&__s1, (char *)&v77, 0LL);
  std::string::basic_string(&cStr, &__s1, 0LL, v65, (std::allocator<char> *)&v69);
LABEL_163:
LABEL_165:
LABEL_169:
  if ((char)cStr.__r_.__value_.__s.__size_ < 0)
  {
    if (cStr.__r_.__value_.__l.__size_)
    {
      p_std::string cStr = (std::string *)cStr.__r_.__value_.__r.__words[0];
LABEL_178:
      CFStringRef v63 = CFStringCreateWithCString(0LL, (const char *)p_cStr, 0x8000100u);
    }

    else
    {
      CFStringRef v63 = 0LL;
    }

    operator delete(cStr.__r_.__value_.__l.__data_);
    return v63;
  }

  if (cStr.__r_.__value_.__s.__size_)
  {
    p_std::string cStr = &cStr;
    goto LABEL_178;
  }

  return 0LL;
}

void sub_100036F8C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20, char a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, void *a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, void *a35, uint64_t a36, uint64_t a37, void *a38, uint64_t a39, int a40, __int16 a41, char a42, char a43, void *__p, uint64_t a45, int a46, __int16 a47, char a48, char a49)
{
  if (a49 < 0) {
    operator delete(__p);
  }
  if (a43 < 0) {
    operator delete(a38);
  }
  if (a21 < 0) {
    operator delete(a16);
  }
  if (a15 < 0) {
    operator delete(a10);
  }
  _Unwind_Resume(a1);
}

uint64_t RDDoLocaleIdentifiersMatch(CFLocaleIdentifier localeIdentifier, const __CFString *a2)
{
  BOOL v3 = CFLocaleCreate(0LL, localeIdentifier);
  CFLocaleRef v4 = CFLocaleCreate(0LL, a2);
  if (v3)
  {
    BOOL v5 = v4;
    if (!v4)
    {
      uint64_t v12 = 0LL;
      goto LABEL_12;
    }

    Value = (const __CFString *)CFLocaleGetValue(v3, kCFLocaleLanguageCode);
    BOOL v7 = (const __CFString *)CFLocaleGetValue(v3, kCFLocaleCountryCode);
    std::string::size_type v8 = (const __CFString *)CFLocaleGetValue(v5, kCFLocaleLanguageCode);
    stat v9 = (const __CFString *)CFLocaleGetValue(v5, kCFLocaleCountryCode);
    if (Value) {
      BOOL v10 = v8 == 0LL;
    }
    else {
      BOOL v10 = 1;
    }
    if (v10) {
      goto LABEL_8;
    }
    char v11 = v9;
    if (CFStringCompare(Value, v8, 0LL)) {
      goto LABEL_8;
    }
    if (v7) {
      BOOL v14 = v11 == 0LL;
    }
    else {
      BOOL v14 = 1;
    }
    if (v14)
    {
    }

    else if (CFStringCompare(v7, v11, 0LL) == kCFCompareEqualTo)
    {
LABEL_22:
      uint64_t v12 = 1LL;
      goto LABEL_9;
    }

LABEL_8:
    uint64_t v12 = 0LL;
LABEL_9:
    CFRelease(v5);
LABEL_12:
    CFRelease(v3);
    return v12;
  }

  return 0LL;
}

void RDString::RDString(RDString *this, CFStringRef theString, int a3)
{
  *(void *)this = 0LL;
  *((void *)this + 1) = 0LL;
  *((void *)this + 2) = 0LL;
  if (theString)
  {
    CStringPtr = CFStringGetCStringPtr(theString, 0x8000100u);
    if (CStringPtr)
    {
      std::string::assign((std::string *)this, CStringPtr);
    }

    else
    {
      CFIndex Length = CFStringGetLength(theString);
      CFIndex MaximumSizeForEncoding = CFStringGetMaximumSizeForEncoding(Length, 0x8000100u);
      std::string::resize((std::string *)this, MaximumSizeForEncoding + 2, 0);
      stat v9 = (char *)this;
      CFStringGetCString(theString, v9, MaximumSizeForEncoding + 1, 0x8000100u);
      BOOL v10 = (const char *)this;
      size_t v11 = strlen(v10);
      std::string::resize((std::string *)this, v11, 0);
    }

    if (a3) {
      CFRelease(theString);
    }
  }

void sub_10003731C(_Unwind_Exception *exception_object)
{
}

void RDInt::RDInt(RDInt *this, CFNumberRef number, int a3)
{
  if (number)
  {
    CFNumberGetValue(number, kCFNumberIntType, this);
    if (a3) {
      CFRelease(number);
    }
  }

  else
  {
    *(_DWORD *)this = 0;
  }

void RDURL::RDURL(RDURL *this, CFURLRef anURL, int a3)
{
  if (anURL)
  {
    __int128 v6 = CFURLCopyFileSystemPath(anURL, kCFURLPOSIXPathStyle);
    RDString::RDString(this, v6, 1);
    if (a3) {
      CFRelease(anURL);
    }
  }

  else
  {
    *(void *)this = 0LL;
    *((void *)this + 1) = 0LL;
    *((void *)this + 2) = 0LL;
  }

void sub_100037404(_Unwind_Exception *exception_object)
{
}

std::string *RDURL::DirName(std::string *this)
{
  BOOL result = (std::string *)std::string::rfind(this, 47, 0xFFFFFFFFFFFFFFFFLL);
  if (result != (std::string *)-1LL) {
    return std::string::erase(this, (std::string::size_type)result, 0xFFFFFFFFFFFFFFFFLL);
  }
  return result;
}

uint64_t sub_100037468@<X0>(const void **a1@<X0>, const void **a2@<X1>, uint64_t a3@<X8>)
{
  else {
    size_t v5 = (size_t)a1[1];
  }
  else {
    size_t v6 = (size_t)a2[1];
  }
  uint64_t result = sub_100037608(a3, v6 + v5);
  else {
    std::string::size_type v8 = *(char **)result;
  }
  if (v5)
  {
    else {
      stat v9 = *a1;
    }
    uint64_t result = (uint64_t)memmove(v8, v9, v5);
  }

  BOOL v10 = &v8[v5];
  if (v6)
  {
    else {
      size_t v11 = *a2;
    }
    uint64_t result = (uint64_t)memmove(v10, v11, v6);
  }

  v10[v6] = 0;
  return result;
}

uint64_t sub_100037530(uint64_t *a1, char *a2, unint64_t a3)
{
  uint64_t v3 = (uint64_t)a1;
  if (*((char *)a1 + 23) < 0)
  {
    uint64_t v3 = *a1;
    unint64_t v4 = a1[1];
  }

  else
  {
    unint64_t v4 = *((unsigned __int8 *)a1 + 23);
  }

  int v5 = a2[23];
  if (v5 >= 0) {
    size_t v6 = a2;
  }
  else {
    size_t v6 = *(char **)a2;
  }
  if (v5 >= 0) {
    int64_t v7 = a2[23];
  }
  else {
    int64_t v7 = *((void *)a2 + 1);
  }
  if (v4 < a3) {
    return -1LL;
  }
  if (v7)
  {
    std::string::size_type v8 = (const void *)(v3 + a3);
    stat v9 = (char *)(v3 + v4);
    int64_t v10 = v4 - a3;
    if (v10 >= v7)
    {
      int v13 = *v6;
      do
      {
        uint64_t v14 = v10 - v7;
        if (v14 == -1) {
          break;
        }
        BOOL v15 = (char *)memchr(v8, v13, v14 + 1);
        if (!v15) {
          break;
        }
        size_t v11 = v15;
        if (!memcmp(v15, v6, v7)) {
          goto LABEL_15;
        }
        std::string::size_type v8 = v11 + 1;
        int64_t v10 = v9 - (v11 + 1);
      }

      while (v10 >= v7);
    }

    size_t v11 = v9;
LABEL_15:
    if (v11 == v9) {
      return -1LL;
    }
    else {
      return (uint64_t)&v11[-v3];
    }
  }

  return a3;
}

uint64_t sub_100037608(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x7FFFFFFFFFFFFFF8LL) {
    sub_10000A38C();
  }
  if (a2 > 0x16)
  {
    uint64_t v4 = (a2 & 0xFFFFFFFFFFFFFFF8LL) + 8;
    if ((a2 | 7) != 0x17) {
      uint64_t v4 = a2 | 7;
    }
    uint64_t v5 = v4 + 1;
    size_t v6 = operator new(v4 + 1);
    *(void *)(a1 + std::ostream::~ostream(v1, v2 + 8) = a2;
    *(void *)(a1 + 16) = v5 | 0x8000000000000000LL;
    *(void *)a1 = v6;
  }

  else
  {
    *(void *)(a1 + std::ostream::~ostream(v1, v2 + 8) = 0LL;
    *(void *)(a1 + 16) = 0LL;
    *(void *)a1 = 0LL;
    *(_BYTE *)(a1 + 23) = a2;
  }

  return a1;
}

void sub_100037A78( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, char a18, uint64_t a19, uint64_t a20, uint64_t a21, char a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, char a35)
{
}

void sub_100037AD8(id a1, BOOL a2, NSError *a3)
{
  if (!a2)
  {
    uint64_t v4 = (os_log_s *)RXOSLog();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v6) = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_ERROR,  "Access to Contacts db not granted.",  (uint8_t *)&v6,  2u);
    }
  }

  if (a3)
  {
    uint64_t v5 = (os_log_s *)RXOSLog();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      int v6 = 138412290;
      int64_t v7 = a3;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "%@", (uint8_t *)&v6, 0xCu);
    }
  }

void sub_100037BB4(uint64_t a1, void *a2, _BYTE *a3)
{
  int v6 = objc_autoreleasePoolPush();
  if ((*(unsigned int (**)(void))(*(void *)(a1 + 40) + 16LL))())
  {
    if (*(void *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 24LL) < 0x3E8uLL)
    {
      int64_t v7 = objc_alloc_init(&OBJC_CLASS___NSMutableDictionary);
      if (objc_msgSend(objc_msgSend(a2, "givenName"), "length")) {
        -[NSMutableDictionary setValue:forKey:]( v7,  "setValue:forKey:",  [a2 givenName],  @"\\contact-first");
      }
      if (objc_msgSend(objc_msgSend(a2, "familyName"), "length")) {
        -[NSMutableDictionary setValue:forKey:]( v7,  "setValue:forKey:",  [a2 familyName],  @"\\contact-last");
      }
      if (objc_msgSend(objc_msgSend(a2, "middleName"), "length")) {
        -[NSMutableDictionary setValue:forKey:]( v7,  "setValue:forKey:",  [a2 middleName],  @"\\contact-middle");
      }
      if (objc_msgSend(objc_msgSend(a2, "nickname"), "length")) {
        -[NSMutableDictionary setValue:forKey:]( v7,  "setValue:forKey:",  [a2 nickname],  @"\\contact-nickname");
      }
      if (-[NSMutableDictionary count](v7, "count"))
      {
        [*(id *)(a1 + 32) addObject:v7];
        ++*(void *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 24LL);
      }

      ++*(void *)(*(void *)(*(void *)(a1 + 56) + 8LL) + 24LL);
    }

    else
    {
      *a3 = 1;
    }
  }

  objc_autoreleasePoolPop(v6);
}

void sub_100037D20(uint64_t a1, uint64_t a2, uint64_t a3, void *a4, _BYTE *a5)
{
  context = objc_autoreleasePoolPush();
  if (a3 == 2)
  {
    __int128 v26 = 0u;
    __int128 v27 = 0u;
    __int128 v24 = 0u;
    __int128 v25 = 0u;
    id v17 = [a4 countByEnumeratingWithState:&v24 objects:v34 count:16];
    if (v17)
    {
      id v18 = v17;
      uint64_t v19 = *(void *)v25;
      do
      {
        for (CFIndex i = 0LL; i != v18; CFIndex i = (char *)i + 1)
        {
          if (*(void *)v25 != v19) {
            objc_enumerationMutation(a4);
          }
          uint64_t v21 = *(void *)(*((void *)&v24 + 1) + 8LL * (void)i);
          ++*(void *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 24LL);
          int v32 = @"\\contact-nickname";
          uint64_t v33 = v21;
          int v22 = +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v33,  &v32,  1LL);
          if (*(void *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 24LL)
             + *(void *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL) < 0x3E8uLL)
          {
            [*(id *)(a1 + 32) addObject:v22];
            ++*(void *)(*(void *)(*(void *)(a1 + 56) + 8LL) + 24LL);
          }

          else
          {
            *a5 = 1;
          }
        }

        id v18 = [a4 countByEnumeratingWithState:&v24 objects:v34 count:16];
      }

      while (v18);
    }
  }

  else if (a3 == 1)
  {
    __int128 v30 = 0u;
    __int128 v31 = 0u;
    __int128 v28 = 0u;
    __int128 v29 = 0u;
    id v9 = [a4 countByEnumeratingWithState:&v28 objects:v35 count:16];
    if (v9)
    {
      id v10 = v9;
      uint64_t v11 = *(void *)v29;
      do
      {
        for (unint64_t j = 0LL; j != v10; unint64_t j = (char *)j + 1)
        {
          if (*(void *)v29 != v11) {
            objc_enumerationMutation(a4);
          }
          if (*(void *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 24LL)
             + *(void *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL) < 0x3E8uLL)
          {
            uint64_t v13 = *(void *)(*((void *)&v28 + 1) + 8LL * (void)j);
            uint64_t v14 = objc_alloc_init(&OBJC_CLASS___NSPersonNameComponentsFormatter);
            BOOL v15 = -[NSPersonNameComponentsFormatter personNameComponentsFromString:]( v14,  "personNameComponentsFromString:",  v13);
            CFStringRef v16 = objc_alloc_init(&OBJC_CLASS___NSMutableDictionary);
            if (-[NSString length](-[NSPersonNameComponents givenName](v15, "givenName"), "length")) {
              -[NSMutableDictionary setValue:forKey:]( v16,  "setValue:forKey:",  -[NSPersonNameComponents givenName](v15, "givenName"),  @"\\contact-first");
            }
            if (-[NSString length](-[NSPersonNameComponents middleName](v15, "middleName"), "length")) {
              -[NSMutableDictionary setValue:forKey:]( v16,  "setValue:forKey:",  -[NSPersonNameComponents middleName](v15, "middleName"),  @"\\contact-middle");
            }
            if (-[NSString length](-[NSPersonNameComponents familyName](v15, "familyName"), "length")) {
              -[NSMutableDictionary setValue:forKey:]( v16,  "setValue:forKey:",  -[NSPersonNameComponents familyName](v15, "familyName"),  @"\\contact-last");
            }
            ++*(void *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 24LL);
            [*(id *)(a1 + 32) addObject:v16];
            ++*(void *)(*(void *)(*(void *)(a1 + 56) + 8LL) + 24LL);
          }

          else
          {
            *a5 = 1;
          }
        }

        id v10 = [a4 countByEnumeratingWithState:&v28 objects:v35 count:16];
      }

      while (v10);
    }
  }

  objc_autoreleasePoolPop(context);
}

BOOL sub_100038064(id a1)
{
  return 1;
}

void sub_100038370(_Unwind_Exception *a1)
{
}

uint64_t sub_10003839C(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t))(a2 + 16))(a2);
}

uint64_t sub_1000383CC(void *a1)
{
  uint64_t v2 = a1[5];
  else {
    uint64_t v3 = 0LL;
  }
  return (*(uint64_t (**)(uint64_t, uint64_t))(v2 + 16))(v2, v3);
}

LABEL_7:
    LOBYTE(v7) = 1;
  }

  return v7;
}

  if (v7 == v6) {
    uint64_t v4 = (uint64_t **)(a1 + 16);
  }
  std::string::size_type v8 = *(void **)(a1 + 40);
  if (v8 != (void *)(a1 + 48))
  {
    do
    {
      if (v8[5] == *(void *)this)
      {
        Concat((const RDQSRSnippet *)(v8 + 4), this, (uint64_t)&v12);
        sub_10003AAB4(v4, &v12);
        sub_10003A1E0((uint64_t)&v12);
      }

      id v9 = (void *)v8[1];
      if (v9)
      {
        do
        {
          id v10 = v9;
          id v9 = (void *)*v9;
        }

        while (v9);
      }

      else
      {
        do
        {
          id v10 = (void *)v8[2];
          uint64_t v11 = *v10 == (void)v8;
          std::string::size_type v8 = v10;
        }

        while (!v11);
      }

      std::string::size_type v8 = v10;
    }

    while (v10 != (void *)(a1 + 48));
  }

  RDQSRSnippetToXPC::Dump((RDQSRSnippetToXPC *)a1);
}

    int64_t v7 = *((void *)&v14 + 1) + 16 * v16;
LABEL_8:
    std::string::size_type v8 = a1[3];
    if (v8 >= a1[4])
    {
      id v9 = sub_10002D5B4(v4, v7);
    }

    else
    {
      *(void *)std::string::size_type v8 = *(void *)v7;
      *(_DWORD *)(v8 + _Block_object_dispose((const void *)(v1 - 224), 8) = *(_DWORD *)(v7 + 8);
      *(_DWORD *)(v8 + 12) = *(_DWORD *)(v7 + 12);
      id v9 = v8 + 16;
    }

    a1[3] = v9;
    if ((void)v14) {
      (*(void (**)(void))(*(void *)v14 + 32LL))(v14);
    }
    else {
      ++v16;
    }
  }

  if ((void)v14)
  {
    (*(void (**)(void))(*(void *)v14 + 8LL))();
    goto LABEL_18;
  }

    int64_t v7 = *((void *)&v14 + 1) + 16 * v16;
LABEL_8:
    std::string::size_type v8 = a1[3];
    if (v8 >= a1[4])
    {
      id v9 = sub_10002D5B4(v4, v7);
    }

    else
    {
      *(void *)std::string::size_type v8 = *(void *)v7;
      *(_DWORD *)(v8 + _Block_object_dispose((const void *)(v1 - 224), 8) = *(_DWORD *)(v7 + 8);
      *(_DWORD *)(v8 + 12) = *(_DWORD *)(v7 + 12);
      id v9 = v8 + 16;
    }

    a1[3] = v9;
    if ((void)v14) {
      (*(void (**)(void))(*(void *)v14 + 32LL))(v14);
    }
    else {
      ++v16;
    }
  }

  if ((void)v14)
  {
    (*(void (**)(void))(*(void *)v14 + 8LL))();
    goto LABEL_18;
  }

    int v6 = (unsigned int *)(*((void *)&v9 + 1) + 16 * v11);
LABEL_8:
    if (sub_100077BD4((uint64_t)a1, (uint64_t)&v12, v6, (uint64_t)v8, 15))
    {
      int64_t v7 = sub_100071228(a1[15], a2);
      sub_10007192C((void *)v7 + 3, (uint64_t)v8);
    }

    if ((void)v9) {
      (*(void (**)(void))(*(void *)v9 + 32LL))(v9);
    }
    else {
      ++v11;
    }
  }

  sub_100070E04((uint64_t)a1, a2);
  if ((void)v9)
  {
    (*(void (**)(void))(*(void *)v9 + 8LL))(v9);
  }

  else if (*((void *)&v10 + 1))
  {
    --**((_DWORD **)&v10 + 1);
  }

  *(_DWORD *)(*(void *)(result + 48) + 4LL * *(int *)(v4 + 4LL * a2)) = a2;
  return result;
}

  id v9 = *(int *)(v7 + 4LL * (int)a2);
  id v10 = *(void *)(**(void **)(a1 + 16) + 8 * v9);
  if (v10) {
    return (char *)(*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v10 + 24LL))(v10, a2);
  }
  uint64_t result = *(char **)(a1 + 40);
  uint64_t v12 = *(char **)(a1 + 48);
  uint64_t v13 = (v12 - result) >> 2;
  if (v13 <= v9)
  {
    uint64_t v14 = (void *)(a1 + 56);
    do
    {
      if ((unint64_t)v12 >= *v14)
      {
        CFStringRef v16 = v13 + 1;
        if ((v13 + 1) >> 62) {
          sub_100018774();
        }
        id v17 = *v14 - (void)result;
        if (v17 >> 1 > v16) {
          CFStringRef v16 = v17 >> 1;
        }
        else {
          id v18 = v16;
        }
        if (v18)
        {
          uint64_t v19 = (char *)sub_10002C050(a1 + 56, v18);
          uint64_t result = *(char **)(a1 + 40);
          uint64_t v12 = *(char **)(a1 + 48);
        }

        else
        {
          uint64_t v19 = 0LL;
        }

        uint64_t v20 = &v19[4 * v13];
        *(_DWORD *)uint64_t v20 = -1;
        BOOL v15 = v20 + 4;
        while (v12 != result)
        {
          uint64_t v21 = *((_DWORD *)v12 - 1);
          v12 -= 4;
          *((_DWORD *)v20 - 1) = v21;
          v20 -= 4;
        }

        *(void *)(a1 + 4RDString::RDString((RDString *)&v66, theString, 0) = v20;
        *(void *)(a1 + 4_Block_object_dispose((const void *)(v1 - 224), 8) = v15;
        *(void *)(a1 + ++*(void *)(result + 56) = &v19[4 * v18];
        if (result)
        {
          operator delete(result);
          uint64_t result = *(char **)(a1 + 40);
        }

        else
        {
          uint64_t result = v20;
        }
      }

      else
      {
        *(_DWORD *)uint64_t v12 = -1;
        BOOL v15 = v12 + 4;
      }

      *(void *)(a1 + 4_Block_object_dispose((const void *)(v1 - 224), 8) = v15;
      uint64_t v13 = (v15 - result) >> 2;
      id v9 = *(int *)(**(void **)(a1 + 24) + 4 * v6);
      uint64_t v12 = v15;
    }

    while (v13 <= v9);
  }

  *(_DWORD *)&result[4 * v9] = v2;
  return result;
}

void sub_100038774( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

void sub_1000387F0(id a1)
{
  qword_1000DDD98 = (uint64_t)dispatch_queue_create("com.apple.embeddedspeech.FetchSerializer", 0LL);
  qword_1000DDDA0 = objc_alloc_init(&OBJC_CLASS___NSMutableSet);
}

id sub_10003882C(uint64_t a1)
{
  id result = [(id)qword_1000DDDA0 containsObject:*(void *)(a1 + 32)];
  if (!(_DWORD)result) {
    return [(id)qword_1000DDDA0 addObject:*(void *)(a1 + 32)];
  }
  *(_BYTE *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL) = 1;
  return result;
}

void sub_100038880(uint64_t a1)
{
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472LL;
  block[2] = sub_1000388E0;
  block[3] = &unk_1000CDBC8;
  block[4] = *(void *)(a1 + 32);
  dispatch_async((dispatch_queue_t)qword_1000DDD98, block);
}

id sub_1000388E0(uint64_t a1)
{
  uint64_t v2 = (os_log_s *)RXOSLog();
  if (os_log_type_enabled(v2, OS_LOG_TYPE_INFO))
  {
    uint64_t v3 = *(void *)(a1 + 32);
    int v5 = 138412290;
    uint64_t v6 = v3;
    _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_INFO,  "Marking fetch available for %@",  (uint8_t *)&v5,  0xCu);
  }

  id result = [(id)qword_1000DDDA0 containsObject:*(void *)(a1 + 32)];
  if ((_DWORD)result) {
    return [(id)qword_1000DDDA0 removeObject:*(void *)(a1 + 32)];
  }
  return result;
}

void sub_10003899C(uint64_t a1)
{
  if (!*(_BYTE *)(*(void *)(*(void *)(a1 + 56) + 8LL) + 24LL))
  {
    (*(void (**)(void))(*(void *)(a1 + 48) + 16LL))();
    uint64_t v2 = (os_log_s *)RXOSLog();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_INFO))
    {
      uint64_t v3 = *(void *)(a1 + 32);
      int v4 = 138412290;
      uint64_t v5 = v3;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_INFO, "Timed out waiting on %@", (uint8_t *)&v4, 0xCu);
    }

    dispatch_group_leave(*(dispatch_group_t *)(a1 + 40));
    *(_BYTE *)(*(void *)(*(void *)(a1 + 56) + 8LL) + 24LL) = 1;
  }

uint64_t sub_100038A74(uint64_t a1)
{
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 3221225472LL;
  _OWORD v3[2] = sub_100038AE8;
  v3[3] = &unk_1000CF2C0;
  uint64_t v7 = *(void *)(a1 + 80);
  __int128 v6 = *(_OWORD *)(a1 + 64);
  __int128 v4 = *(_OWORD *)(a1 + 32);
  uint64_t v1 = *(void *)(a1 + 56);
  uint64_t v5 = *(void *)(a1 + 48);
  return (*(uint64_t (**)(uint64_t, void *))(v1 + 16))(v1, v3);
}

void sub_100038AE8(uint64_t a1)
{
  uint64_t v2 = *(dispatch_queue_s **)(a1 + 32);
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 3221225472LL;
  _OWORD v3[2] = sub_100038B68;
  v3[3] = &unk_1000CF298;
  uint64_t v6 = *(void *)(a1 + 72);
  uint64_t v5 = *(void *)(a1 + 64);
  __int128 v4 = *(_OWORD *)(a1 + 40);
  dispatch_async(v2, v3);
}

void sub_100038B68(uint64_t a1)
{
  double v3 = v2 - *(double *)(a1 + 56);
  int v4 = *(unsigned __int8 *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 24LL);
  uint64_t v5 = (os_log_s *)RXOSLog();
  BOOL v6 = os_log_type_enabled(v5, OS_LOG_TYPE_INFO);
  if (v4)
  {
    if (v6)
    {
      double v7 = *(double *)(a1 + 32);
      int v9 = 134218242;
      double v10 = v3 * 1000.0;
      __int16 v11 = 2112;
      double v12 = v7;
      _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_INFO,  "Fetch completed too late (%.2fsms) for %@",  (uint8_t *)&v9,  0x16u);
    }
  }

  else
  {
    if (v6)
    {
      double v8 = *(double *)(a1 + 32);
      int v9 = 138412546;
      double v10 = v8;
      __int16 v11 = 2048;
      double v12 = v3 * 1000.0;
      _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_INFO,  "Fetch completed for %@ in %.2fms",  (uint8_t *)&v9,  0x16u);
    }

    dispatch_group_leave(*(dispatch_group_t *)(a1 + 40));
    *(_BYTE *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 24LL) = 1;
  }

uint64_t sub_100038CC4(uint64_t a1, uint64_t a2, uint64_t a3, _BYTE *a4)
{
  uint64_t v8 = objc_opt_class(&OBJC_CLASS___NSString);
  uint64_t result = objc_opt_isKindOfClass(a2, v8);
  if ((result & 1) == 0
    || (uint64_t v10 = objc_opt_class(&OBJC_CLASS___NSString), result = objc_opt_isKindOfClass(a3, v10), (result & 1) == 0))
  {
    *a4 = 1;
    *(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = 1;
  }

  return result;
}

uint64_t RDSoundInputiOS::RDSoundInputiOS(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  *(void *)RDSoundInput::RDSoundInput(a1, a2, 0, RDString::RDString((RDString *)&v66, theString, 0) = off_1000CF340;
  double v7 = operator new(8uLL);
  *double v7 = 0LL;
  *(void *)(a1 + 32) = v7;
  uint64_t v8 = (os_log_s *)RXOSLog();
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v10 = 0;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "RDSoundInputiOS::Init", v10, 2u);
  }

  **(void **)(a1 + 32) = -[RDSoundInputImpl initWithExpectedFormat:deliverSamples:]( objc_alloc(&OBJC_CLASS___RDSoundInputImpl),  "initWithExpectedFormat:deliverSamples:",  a3,  a4);
  return a1;
}

void sub_100038E00(_Unwind_Exception *a1)
{
  double v3 = (void *)v1[4];
  v1[4] = 0LL;
  if (v3) {
    operator delete(v3);
  }
  void *v1 = off_1000CDF90;
  RDAudioObject::~RDAudioObject((RDAudioObject *)(v1 + 1));
  _Unwind_Resume(a1);
}

id RDSoundInputiOS::StartRecording(id **this)
{
  double v2 = (os_log_s *)RXOSLog();
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)int v4 = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "RDSoundInputiOS::StartRecording", v4, 2u);
  }

  return [*this[4] startRecording];
}

id RDSoundInputiOS::StopRecording(id **this)
{
  double v2 = (os_log_s *)RXOSLog();
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)int v4 = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "RDSoundInputiOS::StopRecording", v4, 2u);
  }

  return [*this[4] stopRecording];
}

id RDSoundInputiOS::IsRecording(id **this)
{
  return [*this[4] isRecording];
}

void RDSoundInputiOS::~RDSoundInputiOS(id **this)
{
  *this = (id *)off_1000CF340;
  double v2 = (os_log_s *)RXOSLog();
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v5 = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "RDSoundInputiOS::Dealloc", v5, 2u);
  }

  [*this[4] stopRecording];

  double v3 = this[4];
  this[4] = 0LL;
  if (v3)
  {
    operator delete(v3);
    int v4 = this[4];
    this[4] = 0LL;
    if (v4) {
      operator delete(v4);
    }
  }

  *this = (id *)off_1000CDF90;
  RDAudioObject::~RDAudioObject((RDAudioObject *)(this + 1));
}

{
  void *v1;
  RDSoundInputiOS::~RDSoundInputiOS(this);
  operator delete(v1);
}

void RDQSRSnippet::Dump(RDQSRSnippet *this, int a2, const char *a3)
{
  BOOL v6 = (os_log_s *)RXOSLog();
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v8 = *(void *)this;
    uint64_t v7 = *((void *)this + 1);
    int v9 = (void *)((char *)this + 40);
    int v10 = *((_DWORD *)this + 4);
    int v11 = *((_DWORD *)this + 5);
    int v12 = *((_DWORD *)this + 6);
    v13[0] = 68159746;
    v13[1] = a2;
    __int16 v14 = 2080;
    BOOL v15 = "";
    __int16 v16 = 2080;
    id v17 = a3;
    __int16 v18 = 2048;
    uint64_t v19 = v8;
    __int16 v20 = 2048;
    uint64_t v21 = v7;
    __int16 v22 = 2080;
    std::string::size_type v23 = v9;
    __int16 v24 = 1024;
    int v25 = v10;
    __int16 v26 = 1024;
    int v27 = v11;
    __int16 v28 = 1024;
    int v29 = v12;
    _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "%.*s%s[%llu:%llu] %s {%u;%u;%d}\n",
      (uint8_t *)v13,
      0x4Cu);
  }

void RDQSRSnippet::Dump(RDQSRSnippet *this, const char *a2, const RDQSRSnippet *a3)
{
  BOOL v6 = (os_log_s *)RXOSLog();
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v8 = *(void *)this;
    uint64_t v7 = *((void *)this + 1);
    uint64_t v10 = *(void *)a3;
    uint64_t v9 = *((void *)a3 + 1);
    int v11 = (void *)((char *)this + 40);
    int v12 = 136316418;
    uint64_t v13 = a2;
    __int16 v14 = 2048;
    uint64_t v15 = v8;
    __int16 v16 = 2048;
    uint64_t v17 = v7;
    __int16 v18 = 2048;
    uint64_t v19 = v10;
    __int16 v20 = 2048;
    uint64_t v21 = v9;
    __int16 v22 = 2080;
    std::string::size_type v23 = v11;
    _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "%s [%llu:%llu]->[%llu:%llu] %s\n",  (uint8_t *)&v12,  0x3Eu);
  }

double Concat@<D0>(const RDQSRSnippet *a1@<X0>, const RDQSRSnippet *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v4 = *(void *)a1;
  *(_DWORD *)(a3 + 2RDString::RDString((RDString *)&v66, theString, 0) = 0;
  *(_DWORD *)(a3 + ++*(void *)(result + 24) = 0;
  *(_OWORD *)(a3 + 32) = 0u;
  *(_OWORD *)(a3 + 4_Block_object_dispose(va, 8) = 0u;
  uint64_t v5 = *((void *)a2 + 1);
  *(void *)a3 = v4;
  *(void *)(a3 + _Block_object_dispose(va, 8) = v5;
  *(_DWORD *)(a3 + 16) = *((_DWORD *)a2 + 5) + *((_DWORD *)a1 + 4);
  sub_100037468((const void **)a1 + 5, (const void **)a2 + 5, (uint64_t)&v7);
  double result = *(double *)&v7;
  *(_OWORD *)(a3 + 4RDString::RDString((RDString *)&v66, theString, 0) = v7;
  *(void *)(a3 + ++*(void *)(result + 56) = v8;
  return result;
}

void sub_100039278(_Unwind_Exception *a1)
{
}

uint64_t RDQSRSnippetSet::AddSnippet( uint64_t **this, uint64_t a2, uint64_t a3, UInt8 *bytes, std::string::size_type numBytes, int a6, int a7)
{
  v20[0] = a2;
  v20[1] = a3;
  uint64_t v21 = 0LL;
  int v22 = a7;
  CFStringRef theString1 = CFStringCreateWithBytes(0LL, bytes, numBytes, 0x8000100u, 0);
  memset(&v24, 0, sizeof(v24));
  sub_10003A220((uint64_t)v19, (uint64_t)v20);
  RDQSRSnippetSet::FixupSnippets(this, (uint64_t)v19);
  sub_10003A1E0((uint64_t)v19);
  int v11 = sub_10003A310((uint64_t)this, (uint64_t)v20);
  uint64_t v13 = v12;
  if (v11 == v12) {
    goto LABEL_10;
  }
  if (a6 && CFStringCompare(theString1, (CFStringRef)v11[8], 0x100uLL))
  {
    __int16 v14 = (void *)*v13;
    if (*v13)
    {
      do
      {
        uint64_t v15 = v14;
        __int16 v14 = (void *)v14[1];
      }

      while (v14);
    }

    else
    {
      __int16 v16 = v13;
      do
      {
        uint64_t v15 = (void *)v16[2];
        BOOL v17 = *v15 == (void)v16;
        __int16 v16 = v15;
      }

      while (v17);
    }

    if (v15 == v11)
    {
LABEL_10:
      std::string::assign(&v24, (const std::string::value_type *)bytes, numBytes);
      HIDWORD(v21) = this[2];
      if (v11 != v13) {
        RDQSRSnippet::Dump((RDQSRSnippet *)(v11 + 4), 0, "Existing: ");
      }
      RDQSRSnippet::Dump((RDQSRSnippet *)v20, 0, "Insert:   ");
      sub_10003A47C(this, (uint64_t)v20);
    }
  }

  return sub_10003A1E0((uint64_t)v20);
}

void sub_1000393F0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
}

void RDQSRSnippetSet::FixupSnippets(uint64_t **a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 24) != 1)
  {
    if (*(void *)(a2 + 32))
    {
      unint64_t v3 = *(void *)(a2 + 8);
      if (v3 - *(void *)a2 != 10)
      {
        *(void *)(a2 + _Block_object_dispose(va, 8) = *(void *)a2 + 10LL;
        uint64_t v5 = sub_10003A310((uint64_t)a1, a2);
        BOOL v6 = v5;
        uint64_t v8 = v7;
        v50[0] = 0LL;
        v50[1] = 0LL;
        uint64_t v49 = (uint64_t *)v50;
        __int128 v46 = 0u;
        __int128 v47 = 0u;
        int v48 = 1065353216;
        __int128 v43 = 0u;
        __int128 v44 = 0u;
        int v45 = 1065353216;
        if (v5 != v7)
        {
          uint64_t v9 = v5;
          do
          {
            sub_10003A220((uint64_t)&v40, (uint64_t)(v9 + 4));
            unint64_t v41 = v3;
            int v42 = -1;
            sub_10003A47C(&v49, (uint64_t)&v40);
            RDQSRSnippet::Dump((RDQSRSnippet *)(v9 + 4), "Fixup:  ", (const RDQSRSnippet *)&v40);
            v51[0] = v9 + 5;
            sub_10003A620((uint64_t)&v46, (unint64_t *)v9 + 5, (uint64_t)&unk_1000AC330, v51)[3] = v3;
            sub_10003A1E0((uint64_t)&v40);
            uint64_t v10 = (uint64_t *)v9[1];
            if (v10)
            {
              do
              {
                int v11 = v10;
                uint64_t v10 = (uint64_t *)*v10;
              }

              while (v10);
            }

            else
            {
              do
              {
                int v11 = (uint64_t *)v9[2];
                BOOL v12 = *v11 == (void)v9;
                uint64_t v9 = v11;
              }

              while (!v12);
            }

            uint64_t v9 = v11;
          }

          while (v11 != v8);
        }

        sub_10003A83C(a1, v6, v8);
        __int16 v14 = (uint64_t *)(a1 + 1);
        uint64_t v13 = *a1;
        if (*a1 != (uint64_t *)(a1 + 1))
        {
          unint64_t v15 = *(void *)a2 + 10LL;
          char v16 = 1;
          do
          {
            unint64_t v17 = v13[4];
            if (v17 >= v15) {
              break;
            }
            if (*((_DWORD *)v13 + 14) == 1)
            {
              unint64_t v18 = v17 + 40;
              if ((v16 & 1) != 0) {
                unint64_t v15 = v18;
              }
              uint64_t v19 = (const __CFString *)v13[8];
              if (v19 && CFStringCompare(v19, *(CFStringRef *)(a2 + 32), 0x101uLL) == kCFCompareEqualTo)
              {
                sub_10003A220((uint64_t)&v40, (uint64_t)(v13 + 4));
                unint64_t v22 = v40;
                if (v40 <= *(void *)a2) {
                  unint64_t v22 = *(void *)a2;
                }
                unint64_t v40 = v22;
                unint64_t v41 = v3;
                int v42 = -1;
                sub_10003A47C(&v49, (uint64_t)&v40);
                RDQSRSnippet::Dump((RDQSRSnippet *)(v13 + 4), "SkipFix: ", (const RDQSRSnippet *)&v40);
                v51[0] = v13 + 5;
                sub_10003A620((uint64_t)&v46, (unint64_t *)v13 + 5, (uint64_t)&unk_1000AC330, v51)[3] = v3;
                unint64_t v23 = v40;
                v51[0] = v13 + 4;
                sub_10003A620((uint64_t)&v43, (unint64_t *)v13 + 4, (uint64_t)&unk_1000AC330, v51)[3] = v23;
                std::string v24 = (uint64_t *)v13[1];
                int v25 = v13;
                if (v24)
                {
                  do
                  {
                    __int16 v26 = v24;
                    std::string v24 = (uint64_t *)*v24;
                  }

                  while (v24);
                }

                else
                {
                  do
                  {
                    __int16 v26 = (uint64_t *)v25[2];
                    BOOL v12 = *v26 == (void)v25;
                    int v25 = v26;
                  }

                  while (!v12);
                }

                sub_10002F254(a1, v13);
                sub_10003A1E0((uint64_t)(v13 + 4));
                operator delete(v13);
                sub_10003A1E0((uint64_t)&v40);
                char v16 = 0;
                uint64_t v13 = v26;
                continue;
              }

              char v16 = 0;
            }

            __int16 v20 = (uint64_t *)v13[1];
            if (v20)
            {
              do
              {
                uint64_t v13 = v20;
                __int16 v20 = (uint64_t *)*v20;
              }

              while (v20);
            }

            else
            {
              do
              {
                uint64_t v21 = v13;
                uint64_t v13 = (uint64_t *)v13[2];
              }

              while ((uint64_t *)*v13 != v21);
            }
          }

          while (v13 != v14);
        }

        if (*((void *)&v44 + 1))
        {
          int v27 = *a1;
          if (*a1 != v14)
          {
            do
            {
              if (*((_DWORD *)v27 + 14) == 1 && sub_10001AA0C(&v43, (unint64_t *)v27 + 5))
              {
                sub_10003A220((uint64_t)&v40, (uint64_t)(v27 + 4));
                unint64_t v41 = *(void *)a2;
                sub_10003A47C(&v49, (uint64_t)&v40);
                RDQSRSnippet::Dump((RDQSRSnippet *)(v27 + 4), "Predecessor: ", (const RDQSRSnippet *)&v40);
                __int16 v28 = (uint64_t *)v27[1];
                int v29 = v27;
                if (v28)
                {
                  do
                  {
                    __int128 v30 = v28;
                    __int16 v28 = (uint64_t *)*v28;
                  }

                  while (v28);
                }

                else
                {
                  do
                  {
                    __int128 v30 = (uint64_t *)v29[2];
                    BOOL v12 = *v30 == (void)v29;
                    int v29 = v30;
                  }

                  while (!v12);
                }

                sub_10002F254(a1, v27);
                sub_10003A1E0((uint64_t)(v27 + 4));
                operator delete(v27);
                sub_10003A1E0((uint64_t)&v40);
              }

              else
              {
                __int128 v31 = (uint64_t *)v27[1];
                if (v31)
                {
                  do
                  {
                    __int128 v30 = v31;
                    __int128 v31 = (uint64_t *)*v31;
                  }

                  while (v31);
                }

                else
                {
                  do
                  {
                    __int128 v30 = (uint64_t *)v27[2];
                    BOOL v12 = *v30 == (void)v27;
                    int v27 = v30;
                  }

                  while (!v12);
                }
              }

              int v27 = v30;
            }

            while (v30 != v14);
          }
        }

        if (*((void *)&v47 + 1))
        {
          int v32 = *a1;
          if (*a1 != v14)
          {
            do
            {
              if (*((_DWORD *)v32 + 14) == 1)
              {
                uint64_t v33 = sub_10001AA0C(&v46, (unint64_t *)v32 + 4);
                if (v33)
                {
                  sub_10003A220((uint64_t)&v40, (uint64_t)(v32 + 4));
                  unint64_t v34 = v33[3] + 10LL;
                  if (v41 > v34) {
                    unint64_t v34 = v41;
                  }
                  unint64_t v40 = v33[3];
                  unint64_t v41 = v34;
                  sub_10003A47C(&v49, (uint64_t)&v40);
                  RDQSRSnippet::Dump((RDQSRSnippet *)(v32 + 4), "Followup: ", (const RDQSRSnippet *)&v40);
                  unint64_t v35 = v41;
                  v51[0] = v32 + 5;
                  sub_10003A620((uint64_t)&v46, (unint64_t *)v32 + 5, (uint64_t)&unk_1000AC330, v51)[3] = v35;
                  double v36 = (uint64_t *)v32[1];
                  int v37 = v32;
                  if (v36)
                  {
                    do
                    {
                      unint64_t v38 = v36;
                      double v36 = (uint64_t *)*v36;
                    }

                    while (v36);
                  }

                  else
                  {
                    do
                    {
                      unint64_t v38 = (uint64_t *)v37[2];
                      BOOL v12 = *v38 == (void)v37;
                      int v37 = v38;
                    }

                    while (!v12);
                  }

                  sub_10002F254(a1, v32);
                  sub_10003A1E0((uint64_t)(v32 + 4));
                  operator delete(v32);
                  sub_10003A1E0((uint64_t)&v40);
                  goto LABEL_70;
                }

                RDQSRSnippet::Dump((RDQSRSnippet *)(v32 + 4), 0, "Ignore:   ");
              }

              int64_t v39 = (uint64_t *)v32[1];
              if (v39)
              {
                do
                {
                  unint64_t v38 = v39;
                  int64_t v39 = (uint64_t *)*v39;
                }

                while (v39);
              }

              else
              {
                do
                {
                  unint64_t v38 = (uint64_t *)v32[2];
                  BOOL v12 = *v38 == (void)v32;
                  int v32 = v38;
                }

                while (!v12);
              }

void sub_1000399A8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  uint64_t v13 = va_arg(va1, void);
  uint64_t v15 = va_arg(va1, void);
  uint64_t v16 = va_arg(va1, void);
  uint64_t v17 = va_arg(va1, void);
  uint64_t v18 = va_arg(va1, void);
  uint64_t v19 = va_arg(va1, void);
  sub_10001A760((uint64_t)va);
  sub_10001A760((uint64_t)va1);
  sub_10003A2C8(v11 - 128, *(void **)(v11 - 120));
  _Unwind_Resume(a1);
}

uint64_t *sub_100039A0C(uint64_t *result, void *a2, void *a3)
{
  if (a2 != a3)
  {
    uint64_t v4 = a2;
    uint64_t v5 = (uint64_t **)result;
    BOOL v6 = result + 1;
    do
    {
      double result = sub_10003A8A0(v5, v6, (uint64_t)(v4 + 4));
      __int128 v7 = (void *)v4[1];
      if (v7)
      {
        do
        {
          uint64_t v8 = v7;
          __int128 v7 = (void *)*v7;
        }

        while (v7);
      }

      else
      {
        do
        {
          uint64_t v8 = (void *)v4[2];
          BOOL v9 = *v8 == (void)v4;
          uint64_t v4 = v8;
        }

        while (!v9);
      }

      uint64_t v4 = v8;
    }

    while (v8 != a3);
  }

  return result;
}

void RDQSRSnippetToXPC::Dump(RDQSRSnippetToXPC *this)
{
  double v2 = (os_log_s *)RXOSLog();
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Partial\n", buf, 2u);
  }

  unint64_t v3 = (RDQSRSnippetToXPC *)*((void *)this + 5);
  if (v3 != (RDQSRSnippetToXPC *)((char *)this + 48))
  {
    do
    {
      RDQSRSnippet::Dump((RDQSRSnippetToXPC *)((char *)v3 + 32), 2, "");
      uint64_t v4 = (RDQSRSnippetToXPC *)*((void *)v3 + 1);
      if (v4)
      {
        do
        {
          uint64_t v5 = v4;
          uint64_t v4 = *(RDQSRSnippetToXPC **)v4;
        }

        while (v4);
      }

      else
      {
        do
        {
          uint64_t v5 = (RDQSRSnippetToXPC *)*((void *)v3 + 2);
          BOOL v6 = *(void *)v5 == (void)v3;
          unint64_t v3 = v5;
        }

        while (!v6);
      }

      unint64_t v3 = v5;
    }

    while (v5 != (RDQSRSnippetToXPC *)((char *)this + 48));
  }

  __int128 v7 = (os_log_s *)RXOSLog();
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v11 = 0;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "Complete\n", v11, 2u);
  }

  uint64_t v8 = (RDQSRSnippetToXPC *)*((void *)this + 2);
  if (v8 != (RDQSRSnippetToXPC *)((char *)this + 24))
  {
    do
    {
      RDQSRSnippet::Dump((RDQSRSnippetToXPC *)((char *)v8 + 32), 2, "");
      BOOL v9 = (RDQSRSnippetToXPC *)*((void *)v8 + 1);
      if (v9)
      {
        do
        {
          uint64_t v10 = v9;
          BOOL v9 = *(RDQSRSnippetToXPC **)v9;
        }

        while (v9);
      }

      else
      {
        do
        {
          uint64_t v10 = (RDQSRSnippetToXPC *)*((void *)v8 + 2);
          BOOL v6 = *(void *)v10 == (void)v8;
          uint64_t v8 = v10;
        }

        while (!v6);
      }

      uint64_t v8 = v10;
    }

    while (v10 != (RDQSRSnippetToXPC *)((char *)this + 24));
  }

void RDQSRSnippetToXPC::operator()(uint64_t a1, RDQSRSnippet *this)
{
  uint64_t v4 = (uint64_t **)(a1 + 40);
  while (1)
  {
    if (!*(void *)(a1 + 56))
    {
      RDQSRSnippetToXPC::PushSnippets((RDQSRSnippetToXPC *)a1);
      *(void *)&__int128 v12 = *(void *)this;
      *((void *)&v12 + 1) = v12;
      uint64_t v13 = 0LL;
      int v14 = 0;
      __int128 v15 = 0u;
      __int128 v16 = 0u;
      sub_10003AAB4((uint64_t **)(a1 + 40), &v12);
      sub_10003A1E0((uint64_t)&v12);
      unint64_t v6 = *((void *)this + 1);
      *(void *)(a1 + _Block_object_dispose(va, 8) = v6;
LABEL_6:
      unint64_t v7 = v6;
      goto LABEL_7;
    }

    uint64_t v5 = *v4;
    sub_10002F254((uint64_t **)(a1 + 40), *v4);
    sub_10003A1E0((uint64_t)(v5 + 4));
    operator delete(v5);
  }

  unint64_t v7 = *((void *)this + 1);
  unint64_t v6 = *(void *)(a1 + 8);
  if (v7 > v6)
  {
    sub_100039A0C((uint64_t *)(a1 + 40), *(void **)(a1 + 16), (void *)(a1 + 24));
    sub_10003A2C8(a1 + 16, *(void **)(a1 + 24));
    *(void *)(a1 + ++*(void *)(result + 24) = 0LL;
    *(void *)(a1 + 32) = 0LL;
    *(void *)(a1 + 16) = a1 + 24;
    unint64_t v6 = *((void *)this + 1);
    *(void *)(a1 + _Block_object_dispose(va, 8) = v6;
    goto LABEL_6;
  }

void sub_100039D98( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void RDQSRSnippetToXPC::PushSnippets(RDQSRSnippetToXPC *this)
{
  uint64_t v1 = *((void *)this + 4);
  if (v1)
  {
    unint64_t v3 = (uint64_t **)((char *)this + 16);
    if (v1 != 1)
    {
      uint64_t v4 = *v3;
      uint64_t v5 = (uint64_t *)(*v3)[1];
      if (v5)
      {
        do
        {
          unint64_t v6 = v5;
          uint64_t v5 = (uint64_t *)*v5;
        }

        while (v5);
      }

      else
      {
        do
        {
          unint64_t v6 = (uint64_t *)v4[2];
          BOOL v7 = *v6 == (void)v4;
          uint64_t v4 = v6;
        }

        while (!v7);
      }

      uint64_t v8 = (char *)this + 24;
      if (v6 != (uint64_t *)((char *)this + 24))
      {
        while (1)
        {
          BOOL v9 = *v3;
          if (*v3 == v6) {
            goto LABEL_42;
          }
          uint64_t v10 = *((unsigned __int8 *)v6 + 95);
          size_t v11 = v6[10];
          if ((v10 & 0x80u) == 0LL) {
            uint64_t v12 = *((unsigned __int8 *)v6 + 95);
          }
          else {
            uint64_t v12 = v6[10];
          }
          while (1)
          {
            uint64_t v13 = *((unsigned __int8 *)v9 + 95);
            int v14 = (char)v13;
            if ((v13 & 0x80u) != 0LL) {
              uint64_t v13 = v9[10];
            }
            if (v12 != v13) {
              goto LABEL_26;
            }
            __int128 v15 = v14 >= 0 ? v9 + 9 : (uint64_t *)v9[9];
            if ((v10 & 0x80) != 0) {
              break;
            }
            if (!(_DWORD)v10) {
              goto LABEL_33;
            }
            __int128 v16 = (unsigned __int8 *)(v6 + 9);
            uint64_t v17 = v10;
            while (*v16 == *(unsigned __int8 *)v15)
            {
              ++v16;
              __int128 v15 = (uint64_t *)((char *)v15 + 1);
              if (!--v17) {
                goto LABEL_33;
              }
            }

LABEL_26:
            uint64_t v18 = (uint64_t *)v9[1];
            if (v18)
            {
              do
              {
                uint64_t v19 = v18;
                uint64_t v18 = (uint64_t *)*v18;
              }

              while (v18);
            }

            else
            {
              do
              {
                uint64_t v19 = (uint64_t *)v9[2];
                BOOL v7 = *v19 == (void)v9;
                BOOL v9 = v19;
              }

              while (!v7);
            }

            BOOL v9 = v19;
            if (v19 == v6) {
              goto LABEL_42;
            }
          }

LABEL_33:
          __int16 v20 = (uint64_t *)v6[1];
          uint64_t v21 = v6;
          if (v20)
          {
            do
            {
              unint64_t v22 = v20;
              __int16 v20 = (uint64_t *)*v20;
            }

            while (v20);
          }

          else
          {
            do
            {
              unint64_t v22 = (uint64_t *)v21[2];
              BOOL v7 = *v22 == (void)v21;
              uint64_t v21 = v22;
            }

            while (!v7);
          }

          sub_10002F254(v3, v6);
          sub_10003A1E0((uint64_t)(v6 + 4));
          operator delete(v6);
          unint64_t v23 = (uint64_t *)*v22;
          if (*v22)
          {
            do
            {
              unint64_t v6 = v23;
              unint64_t v23 = (uint64_t *)v23[1];
            }

            while (v23);
          }

          else
          {
            do
            {
              unint64_t v6 = (uint64_t *)v22[2];
              BOOL v7 = *v6 == (void)v22;
              unint64_t v22 = v6;
            }

            while (v7);
          }

        v56[v11] = 2;
        uint64_t v19 = *((void *)v10 + 1);
        if (v19)
        {
          (*(void (**)(uint64_t))(*(void *)v19 + 8LL))(v19);
        }

        else
        {
          __int16 v20 = (_DWORD *)*((void *)v10 + 4);
          if (v20) {
            --*v20;
          }
        }

        *((void *)v10 + 6) = v53;
        int v53 = v10;
        --*((void *)&v55 + 1);
        sub_10002C2E0(v54, 1);
        if (*((void *)&v55 + 1))
        {
          uint64_t v21 = *(void *)(*(void *)(*((void *)&v54[0] + 1)
          unint64_t v22 = *(_DWORD *)v21;
          unint64_t v23 = *(void *)(v21 + 8);
          if (v23) {
            (*(void (**)(uint64_t))(*(void *)v23 + 24LL))(v23);
          }
          sub_10002B410((uint64_t)a2, v11, v22);
          std::string v24 = *(void *)(v21 + 8);
          if (v24) {
            goto LABEL_50;
          }
          ++*(void *)(v21 + 40);
        }

        else
        {
          sub_10002B410((uint64_t)a2, v11, -1);
        }
      }
    }

    if ((a3 & 1) != 0) {
      break;
    }
    if ((_DWORD)v6 == v45) {
      unint64_t v6 = 0LL;
    }
    else {
      unint64_t v6 = (v6 + 1);
    }
    if ((int)v6 < (int)v5)
    {
      int v27 = &v56[(int)v6];
      xpc_object_t v28 = (int)v5 - (uint64_t)(int)v6;
      while (*v27++)
      {
        unint64_t v6 = (v6 + 1);
        if (!--v28)
        {
          unint64_t v6 = v5;
          break;
        }
      }
    }

    if (v44 || (_DWORD)v6 != (_DWORD)v5) {
      continue;
    }
LABEL_67:
    if (v47)
    {
      if (v47)
      {
        __int128 v30 = (*(uint64_t (**)(uint64_t))(*(void *)v47 + 24LL))(v47);
        goto LABEL_73;
      }
    }

    else if (v49 >= v48)
    {
      continue;
    }

    __int128 v30 = v49;
LABEL_73:
    if (v30 != (_DWORD)v5)
    {
      if (v47) {
        (*(void (**)(uint64_t))(*(void *)v47 + 32LL))(v47);
      }
      else {
        ++v49;
      }
      goto LABEL_67;
    }

    __int128 v31 = v57;
    if (v57 >= v58)
    {
      xpc_object_t v33 = (unint64_t)v56;
      xpc_object_t v34 = v57 - v56;
      unint64_t v35 = v57 - v56 + 1;
      if (v35 < 0) {
        sub_100018774();
      }
      double v36 = v58 - v56;
      if (v36 >= 0x3FFFFFFFFFFFFFFFLL) {
        int v37 = 0x7FFFFFFFFFFFFFFFLL;
      }
      else {
        int v37 = v35;
      }
      if (v37) {
        xpc_object_t v38 = operator new(v37);
      }
      else {
        xpc_object_t v38 = 0LL;
      }
      int64_t v39 = &v38[v34];
      unint64_t v40 = &v38[v34];
      char *v40 = 0;
      int v32 = v40 + 1;
      if (v31 != (char *)v33)
      {
        unint64_t v41 = &v31[~v33];
        do
        {
          char v42 = *--v31;
          (v41--)[(void)v38] = v42;
        }

        while (v31 != (char *)v33);
        __int128 v31 = v56;
        int64_t v39 = v38;
      }

      size_t v56 = v39;
      uint64_t v57 = v32;
      uint64_t v58 = &v38[v37];
      if (v31) {
        operator delete(v31);
      }
    }

    else
    {
      *uint64_t v57 = 0;
      int v32 = v31 + 1;
    }

    uint64_t v5 = (v5 + 1);
    uint64_t v57 = v32;
  }

  while ((v9 & 1) != 0 && (int)v6 < (int)v5);
LABEL_97:
  sub_10002AF44((uint64_t)a2);
  if (v47) {
    (*(void (**)(uint64_t))(*(void *)v47 + 8LL))(v47);
  }
  int v50 = off_1000D0BA0;
  v51[0] = off_1000D0BC8;
  sub_10002B998(v52);
  sub_10002C34C(v54);
  if (v56)
  {
    uint64_t v57 = v56;
    operator delete(v56);
  }

          std::string v24 = (float *)&v31;
          int v25 = (uint64_t *)&v28;
          goto LABEL_34;
        }

        if (!v20[33])
        {
          int v27 = v20[34] ^ 1;
          goto LABEL_33;
        }
      }

        v56[v11] = 2;
        uint64_t v19 = *((void *)v10 + 1);
        if (v19)
        {
          (*(void (**)(uint64_t))(*(void *)v19 + 8LL))(v19);
        }

        else
        {
          __int16 v20 = (_DWORD *)*((void *)v10 + 4);
          if (v20) {
            --*v20;
          }
        }

        *((void *)v10 + 6) = v53;
        int v53 = v10;
        --*((void *)&v55 + 1);
        sub_10002C2E0(v54, 1);
        if (*((void *)&v55 + 1))
        {
          uint64_t v21 = *(void *)(*(void *)(*((void *)&v54[0] + 1)
          unint64_t v22 = *(_DWORD *)v21;
          unint64_t v23 = *(void *)(v21 + 8);
          if (v23) {
            (*(void (**)(uint64_t))(*(void *)v23 + 24LL))(v23);
          }
          sub_10002B410((uint64_t)a2, v11, v22);
          std::string v24 = *(void *)(v21 + 8);
          if (v24) {
            goto LABEL_50;
          }
          ++*(void *)(v21 + 40);
        }

        else
        {
          sub_10002B410((uint64_t)a2, v11, -1);
        }
      }
    }

    if ((a3 & 1) != 0) {
      break;
    }
    if ((_DWORD)v6 == v45) {
      unint64_t v6 = 0LL;
    }
    else {
      unint64_t v6 = (v6 + 1);
    }
    if ((int)v6 < (int)v5)
    {
      int v27 = &v56[(int)v6];
      xpc_object_t v28 = (int)v5 - (uint64_t)(int)v6;
      while (*v27++)
      {
        unint64_t v6 = (v6 + 1);
        if (!--v28)
        {
          unint64_t v6 = v5;
          break;
        }
      }
    }

    if (v44 || (_DWORD)v6 != (_DWORD)v5) {
      continue;
    }
LABEL_67:
    if (v47)
    {
      if (v47)
      {
        __int128 v30 = (*(uint64_t (**)(uint64_t))(*(void *)v47 + 24LL))(v47);
        goto LABEL_73;
      }
    }

    else if (v49 >= v48)
    {
      continue;
    }

    __int128 v30 = v49;
LABEL_73:
    if (v30 != (_DWORD)v5)
    {
      if (v47) {
        (*(void (**)(uint64_t))(*(void *)v47 + 32LL))(v47);
      }
      else {
        ++v49;
      }
      goto LABEL_67;
    }

    __int128 v31 = v57;
    if (v57 >= v58)
    {
      xpc_object_t v33 = (unint64_t)v56;
      xpc_object_t v34 = v57 - v56;
      unint64_t v35 = v57 - v56 + 1;
      if (v35 < 0) {
        sub_100018774();
      }
      double v36 = v58 - v56;
      if (v36 >= 0x3FFFFFFFFFFFFFFFLL) {
        int v37 = 0x7FFFFFFFFFFFFFFFLL;
      }
      else {
        int v37 = v35;
      }
      if (v37) {
        xpc_object_t v38 = operator new(v37);
      }
      else {
        xpc_object_t v38 = 0LL;
      }
      int64_t v39 = &v38[v34];
      unint64_t v40 = &v38[v34];
      char *v40 = 0;
      int v32 = v40 + 1;
      if (v31 != (char *)v33)
      {
        unint64_t v41 = &v31[~v33];
        do
        {
          char v42 = *--v31;
          (v41--)[(void)v38] = v42;
        }

        while (v31 != (char *)v33);
        __int128 v31 = v56;
        int64_t v39 = v38;
      }

      size_t v56 = v39;
      uint64_t v57 = v32;
      uint64_t v58 = &v38[v37];
      if (v31) {
        operator delete(v31);
      }
    }

    else
    {
      *uint64_t v57 = 0;
      int v32 = v31 + 1;
    }

    uint64_t v5 = (v5 + 1);
    uint64_t v57 = v32;
  }

  while ((v9 & 1) != 0 && (int)v6 < (int)v5);
LABEL_97:
  sub_10002AF44((uint64_t)a2);
  if (v47) {
    (*(void (**)(uint64_t))(*(void *)v47 + 8LL))(v47);
  }
  int v50 = off_1000D0BA0;
  v51[0] = off_1000D0BC8;
  sub_10002B998(v52);
  sub_10002C34C(v54);
  if (v56)
  {
    uint64_t v57 = v56;
    operator delete(v56);
  }

LABEL_42:
          std::string v24 = (uint64_t *)v6[1];
          if (v24)
          {
            do
            {
              int v25 = v24;
              std::string v24 = (uint64_t *)*v24;
            }

            while (v24);
          }

          else
          {
            do
            {
              int v25 = (uint64_t *)v6[2];
              BOOL v7 = *v25 == (void)v6;
              unint64_t v6 = v25;
            }

            while (!v7);
          }

          unint64_t v6 = v25;
          if (v25 == (uint64_t *)v8)
          {
            uint64_t v1 = *((void *)this + 4);
            break;
          }
        }
      }

      if (v1 != 1) {
        goto LABEL_57;
      }
    }

    size_t count = xpc_array_get_count(*(xpc_object_t *)this);
    if (count
      && (xpc_object_t value = xpc_array_get_value(*(xpc_object_t *)this, count - 1),
          xpc_object_t v28 = xpc_dictionary_get_value(value, kRDKeyText),
          xpc_array_get_count(v28) == 1))
    {
      xpc_dictionary_set_uint64(value, kRDKeyEndTime, (*v3)[5]);
      string = xpc_array_get_string(v28, 0LL);
      std::operator+<char>(__p, string, *v3 + 9);
      if (v42 >= 0) {
        __int128 v30 = __p;
      }
      else {
        __int128 v30 = (void **)__p[0];
      }
      xpc_array_set_string(v28, 0LL, (const char *)v30);
      int v32 = (void *)*((void *)this + 3);
      __int128 v31 = (void *)((char *)this + 24);
      sub_10003A2C8((uint64_t)v3, v32);
      *(v31 - 1) = v31;
      void *v31 = 0LL;
      v31[1] = 0LL;
      if (v42 < 0) {
        operator delete(__p[0]);
      }
    }

    else
    {
LABEL_57:
      xpc_object_t v33 = xpc_dictionary_create(0LL, 0LL, 0LL);
      xpc_dictionary_set_uint64(v33, kRDKeyStartTime, *(void *)(*((void *)this + 2) + 32LL));
      xpc_dictionary_set_uint64(v33, kRDKeyEndTime, *(void *)(*((void *)this + 2) + 40LL));
      xpc_object_t v34 = xpc_array_create(0LL, 0LL);
      unint64_t v35 = (void *)*((void *)this + 2);
      double v36 = (char *)this + 24;
      if (v35 != (void *)((char *)this + 24))
      {
        do
        {
          int v37 = (const char *)(v35 + 9);
          xpc_object_t v38 = xpc_string_create(v37);
          xpc_array_append_value(v34, v38);
          xpc_release(v38);
          int64_t v39 = (char *)v35[1];
          if (v39)
          {
            do
            {
              unint64_t v40 = v39;
              int64_t v39 = *(char **)v39;
            }

            while (v39);
          }

          else
          {
            do
            {
              unint64_t v40 = (char *)v35[2];
              BOOL v7 = *(void *)v40 == (void)v35;
              unint64_t v35 = v40;
            }

            while (!v7);
          }

          unint64_t v35 = v40;
        }

        while (v40 != v36);
      }

      xpc_dictionary_set_value(v33, kRDKeyText, v34);
      xpc_release(v34);
      xpc_array_append_value(*(xpc_object_t *)this, v33);
      xpc_release(v33);
      sub_10003A2C8((uint64_t)v3, *((void **)this + 3));
      *((void *)this + 3) = 0LL;
      *((void *)this + 4) = 0LL;
      *((void *)this + 2) = v36;
    }
  }

    unint64_t v41 = *(void *)(a4 + 8);
    if (v41 >= *(void *)(a4 + 16))
    {
      char v42 = sub_1000614E0((uint64_t *)a4, (__int128 *)buf, (__int128 *)v63);
    }

    else
    {
      sub_100017F30(*(char **)(a4 + 8), (__int128 *)buf, (__int128 *)v63);
      char v42 = v41 + 48;
      *(void *)(a4 + _Block_object_dispose(va, 8) = v41 + 48;
    }

    *(void *)(a4 + _Block_object_dispose(va, 8) = v42;
    goto LABEL_46;
  }

void sub_10003A1A0( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t RDQSRSnippetToXPC::Result(RDQSRSnippetToXPC *this)
{
  return *(void *)this;
}

uint64_t sub_10003A1E0(uint64_t a1)
{
  double v2 = *(const void **)(a1 + 32);
  if (v2) {
    CFRelease(v2);
  }
  return a1;
}

uint64_t sub_10003A220(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)a1 = *(_OWORD *)a2;
  *(void *)(a1 + 16) = *(void *)(a2 + 16);
  *(_DWORD *)(a1 + ++*(void *)(result + 24) = *(_DWORD *)(a2 + 24);
  unint64_t v3 = *(const void **)(a2 + 32);
  *(void *)(a1 + 32) = v3;
  if ((*(char *)(a2 + 63) & 0x80000000) == 0)
  {
    __int128 v4 = *(_OWORD *)(a2 + 40);
    *(void *)(a1 + ++*(void *)(result + 56) = *(void *)(a2 + 56);
    *(_OWORD *)(a1 + 4RDString::RDString((RDString *)&v66, theString, 0) = v4;
    if (!v3) {
      return a1;
    }
    goto LABEL_5;
  }

  sub_10005AA70((_BYTE *)(a1 + 40), *(void **)(a2 + 40), *(void *)(a2 + 48));
  unint64_t v3 = *(const void **)(a1 + 32);
  if (v3) {
LABEL_5:
  }
    CFRetain(v3);
  return a1;
}

void sub_10003A2AC(_Unwind_Exception *exception_object)
{
}

void sub_10003A2C8(uint64_t a1, void *a2)
{
  if (a2)
  {
    sub_10003A2C8(a1, *a2);
    sub_10003A2C8(a1, a2[1]);
    sub_10003A1E0((uint64_t)(a2 + 4));
    operator delete(a2);
  }

void *sub_10003A310(uint64_t a1, uint64_t a2)
{
  double v2 = (void *)(a1 + 8);
  unint64_t v3 = *(void **)(a1 + 8);
  if (!v3) {
    return v2;
  }
  uint64_t v5 = a1 + 16;
  while ((sub_10003A404(v5, a2, (uint64_t)(v3 + 4)) & 1) != 0)
  {
    double v2 = v3;
LABEL_7:
    unint64_t v3 = (void *)*v3;
    if (!v3) {
      return v2;
    }
  }

  if (sub_10003A404(v5, (uint64_t)(v3 + 4), a2))
  {
    ++v3;
    goto LABEL_7;
  }

  uint64_t v8 = (void *)*v3;
  unint64_t v6 = v3;
  if (*v3)
  {
    unint64_t v6 = v3;
    do
    {
      int v9 = sub_10003A404(v5, (uint64_t)(v8 + 4), a2);
      uint64_t v10 = v8 + 1;
      if (!v9)
      {
        uint64_t v10 = v8;
        unint64_t v6 = v8;
      }

      uint64_t v8 = (void *)*v10;
    }

    while (*v10);
  }

  size_t v11 = (void *)v3[1];
  if (v11)
  {
    do
    {
      int v12 = sub_10003A404(v5, a2, (uint64_t)(v11 + 4));
      uint64_t v13 = v11 + 1;
      if (v12) {
        uint64_t v13 = v11;
      }
      size_t v11 = (void *)*v13;
    }

    while (*v13);
  }

  return v6;
}

unint64_t sub_10003A404(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(void *)a2 < *(void *)a3) {
    return 1LL;
  }
  if (*(void *)a2 > *(void *)a3) {
    return 0LL;
  }
  unint64_t v4 = *(void *)(a2 + 8);
  unint64_t v5 = *(void *)(a3 + 8);
  if (v4 < v5) {
    return 1LL;
  }
  if (v4 > v5) {
    return 0LL;
  }
  unsigned int v6 = *(_DWORD *)(a2 + 16);
  unsigned int v7 = *(_DWORD *)(a3 + 16);
  if (v6 < v7) {
    return 1LL;
  }
  if (v6 > v7) {
    return 0LL;
  }
  unint64_t result = *(void *)(a2 + 32);
  if (result)
  {
    uint64_t v8 = *(const __CFString **)(a3 + 32);
    if (v8) {
      return (unint64_t)CFStringCompare((CFStringRef)result, v8, 0x101uLL) >> 63;
    }
    return 0LL;
  }

  return result;
}

uint64_t *sub_10003A47C(uint64_t **a1, uint64_t a2)
{
  unint64_t v3 = (uint64_t **)sub_10003A564((uint64_t)a1, &v6, (uint64_t)(v7[0] + 4));
  sub_100019D14(a1, v6, v3, v7[0]);
  unint64_t v4 = v7[0];
  v7[0] = 0LL;
  sub_10003A5DC((uint64_t)v7, 0LL);
  return v4;
}

void sub_10003A4E4(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

uint64_t sub_10003A4FC@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v5 = a1 + 8;
  uint64_t v6 = operator new(0x60uLL);
  *(void *)a3 = v6;
  *(void *)(a3 + _Block_object_dispose(va, 8) = v5;
  *(_BYTE *)(a3 + 16) = 0;
  uint64_t result = sub_10003A220((uint64_t)v6 + 32, a2);
  *(_BYTE *)(a3 + 16) = 1;
  return result;
}

void sub_10003A54C(_Unwind_Exception *a1)
{
}

void *sub_10003A564(uint64_t a1, void *a2, uint64_t a3)
{
  uint64_t v5 = (void *)(a1 + 8);
  unint64_t v4 = *(void **)(a1 + 8);
  if (v4)
  {
    uint64_t v7 = a1 + 16;
    do
    {
      while (1)
      {
        uint64_t v5 = v4;
        unint64_t v4 = (void *)*v5;
        uint64_t result = v5;
        if (!*v5) {
          goto LABEL_9;
        }
      }

      unint64_t v4 = (void *)v5[1];
    }

    while (v4);
    uint64_t result = v5 + 1;
  }

  else
  {
    uint64_t result = (void *)(a1 + 8);
  }

void sub_10003A5DC(uint64_t a1, uint64_t a2)
{
  double v2 = *(void **)a1;
  *(void *)a1 = a2;
  if (v2)
  {
    if (*(_BYTE *)(a1 + 16)) {
      sub_10003A1E0((uint64_t)v2 + 32);
    }
    operator delete(v2);
  }

void *sub_10003A620(uint64_t a1, unint64_t *a2, uint64_t a3, void **a4)
{
  unint64_t v7 = *a2;
  unint64_t v8 = *(void *)(a1 + 8);
  if (v8)
  {
    uint8x8_t v9 = (uint8x8_t)vcnt_s8((int8x8_t)v8);
    v9.i16[0] = vaddlv_u8(v9);
    if (v9.u32[0] > 1uLL)
    {
      unint64_t v4 = *a2;
      if (v7 >= v8) {
        unint64_t v4 = v7 % v8;
      }
    }

    else
    {
      unint64_t v4 = (v8 - 1) & v7;
    }

    uint64_t v10 = *(void ***)(*(void *)a1 + 8 * v4);
    if (v10)
    {
      for (CFIndex i = *v10; i; CFIndex i = (void *)*i)
      {
        unint64_t v12 = i[1];
        if (v12 == v7)
        {
          if (i[2] == v7) {
            return i;
          }
        }

        else
        {
          if (v9.u32[0] > 1uLL)
          {
            if (v12 >= v8) {
              v12 %= v8;
            }
          }

          else
          {
            v12 &= v8 - 1;
          }

          if (v12 != v4) {
            break;
          }
        }
      }
    }
  }

  CFIndex i = operator new(0x20uLL);
  *CFIndex i = 0LL;
  i[1] = v7;
  i[2] = **a4;
  i[3] = 0LL;
  float v13 = (float)(unint64_t)(*(void *)(a1 + 24) + 1LL);
  float v14 = *(float *)(a1 + 32);
  if (!v8 || (float)(v14 * (float)v8) < v13)
  {
    BOOL v15 = 1LL;
    if (v8 >= 3) {
      BOOL v15 = (v8 & (v8 - 1)) != 0;
    }
    unint64_t v16 = v15 | (2 * v8);
    unint64_t v17 = vcvtps_u32_f32(v13 / v14);
    if (v16 <= v17) {
      size_t v18 = v17;
    }
    else {
      size_t v18 = v16;
    }
    sub_100018334(a1, v18);
    unint64_t v8 = *(void *)(a1 + 8);
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v7 >= v8) {
        unint64_t v4 = v7 % v8;
      }
      else {
        unint64_t v4 = v7;
      }
    }

    else
    {
      unint64_t v4 = (v8 - 1) & v7;
    }
  }

  uint64_t v19 = *(void *)a1;
  __int16 v20 = *(void **)(*(void *)a1 + 8 * v4);
  if (v20)
  {
    *CFIndex i = *v20;
LABEL_38:
    *__int16 v20 = i;
    goto LABEL_39;
  }

  *CFIndex i = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = i;
  *(void *)(v19 + 8 * RDQSREngine::MatchResult(this, v4) = a1 + 16;
  if (*i)
  {
    unint64_t v21 = *(void *)(*i + 8LL);
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v21 >= v8) {
        v21 %= v8;
      }
    }

    else
    {
      v21 &= v8 - 1;
    }

    __int16 v20 = (void *)(*(void *)a1 + 8 * v21);
    goto LABEL_38;
  }

void sub_10003A828(_Unwind_Exception *a1)
{
}

uint64_t *sub_10003A83C(uint64_t **a1, uint64_t *a2, uint64_t *a3)
{
  if (a2 != a3)
  {
    unint64_t v4 = a2;
    do
    {
      uint64_t v6 = sub_10002F254(a1, v4);
      sub_10003A1E0((uint64_t)(v4 + 4));
      operator delete(v4);
      unint64_t v4 = v6;
    }

    while (v6 != a3);
  }

  return a3;
}

uint64_t *sub_10003A8A0(uint64_t **a1, void *a2, uint64_t a3)
{
  uint64_t v5 = (uint64_t **)sub_10003A92C(a1, a2, &v8, (uint64_t)(v9[0] + 4));
  sub_100019D14(a1, v8, v5, v9[0]);
  uint64_t v6 = v9[0];
  v9[0] = 0LL;
  sub_10003A5DC((uint64_t)v9, 0LL);
  return v6;
}

void sub_10003A914(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

void *sub_10003A92C(void *a1, void *a2, void *a3, uint64_t a4)
{
  uint64_t v6 = a2;
  if ((void *)*a1 == v6)
  {
    uint64_t v10 = v6;
  }

  else
  {
    uint8x8_t v9 = (void *)*v6;
    if (*v6)
    {
      do
      {
        uint64_t v10 = v9;
        uint8x8_t v9 = (void *)v9[1];
      }

      while (v9);
    }

    else
    {
      size_t v11 = v6;
      do
      {
        uint64_t v10 = (void *)v11[2];
        BOOL v12 = *v10 == (void)v11;
        size_t v11 = v10;
      }

      while (v12);
    }
  }

  if (*v6)
  {
    *a3 = v10;
    return v10 + 1;
  }

  else
  {
    *a3 = v6;
  }

  return v6;
}

void *sub_10003AA38(uint64_t a1, void *a2, uint64_t a3)
{
  uint64_t v5 = (void *)(a1 + 8);
  unint64_t v4 = *(void **)(a1 + 8);
  if (v4)
  {
    uint64_t v7 = a1 + 16;
    do
    {
      while (1)
      {
        uint64_t v5 = v4;
        unint64_t v4 = (void *)*v5;
        uint64_t result = v5;
        if (!*v5) {
          goto LABEL_9;
        }
      }

      unint64_t v4 = (void *)v5[1];
    }

    while (v4);
    uint64_t result = v5 + 1;
  }

  else
  {
    uint64_t result = (void *)(a1 + 8);
  }

uint64_t *sub_10003AAB4(uint64_t **a1, __int128 *a2)
{
  unint64_t v4 = (uint64_t *)(a1 + 1);
  uint64_t v5 = (char *)operator new(0x60uLL);
  *((void *)v5 + 6) = *((void *)a2 + 2);
  *(_OWORD *)(v5 + 72) = *(__int128 *)((char *)a2 + 40);
  __int128 v6 = *a2;
  *((_DWORD *)v5 + 14) = *((_DWORD *)a2 + 6);
  *((void *)v5 + _Block_object_dispose(va, 8) = *((void *)a2 + 4);
  *((void *)v5 + 11) = *((void *)a2 + 7);
  *((_OWORD *)v5 + 2) = v6;
  v11[0] = (uint64_t *)v5;
  v11[1] = v4;
  a2[2] = 0u;
  a2[3] = 0u;
  char v12 = 1;
  uint64_t v7 = (uint64_t **)sub_10003A564((uint64_t)a1, &v10, (uint64_t)(v5 + 32));
  sub_100019D14(a1, v10, v7, v11[0]);
  uint64_t v8 = v11[0];
  v11[0] = 0LL;
  sub_10003A5DC((uint64_t)v11, 0LL);
  return v8;
}

void sub_10003AB6C(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

uint64_t RDUserProfile::RDUserProfile(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  *(_DWORD *)a1 = a4;
  uint64_t v7 = operator new(8uLL);
  *uint64_t v7 = 0LL;
  *(void *)(a1 + _Block_object_dispose(va, 8) = v7;
  **(void **)(a1 + _Block_object_dispose(va, 8) = -[RDUserProfileImpl initWithLanguage:assetPath:]( objc_alloc(&OBJC_CLASS___RDUserProfileImpl),  "initWithLanguage:assetPath:",  a3,  a2);
  return a1;
}

void sub_10003B054(_Unwind_Exception *exception_object)
{
  unint64_t v3 = *(void **)(v1 + 8);
  *(void *)(v1 + _Block_object_dispose(va, 8) = 0LL;
  if (v3) {
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void RDUserProfile::updateUserProfileWithPersonalData(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)a1 == 1)
  {
    double v2 = (os_log_s *)RXOSLog();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)__int128 v6 = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_ERROR,  "preHeatUserProfile not allowed for inline mode",  v6,  2u);
    }
  }

  else
  {
    unint64_t v3 = **(void ***)(a1 + 8);
    v7[0] = _NSConcreteStackBlock;
    v7[1] = 3321888768LL;
    _OWORD v7[2] = sub_10003B1D0;
    v7[3] = &unk_1000CF380;
    unint64_t v4 = v8;
    sub_100007B8C((uint64_t)v8, a2);
    [v3 updateUserProfileWithPersonalData:v7];
    if (v9 == v8)
    {
      uint64_t v5 = 4LL;
    }

    else
    {
      if (!v9) {
        return;
      }
      uint64_t v5 = 5LL;
      unint64_t v4 = v9;
    }

    (*(void (**)(void *))(*v4 + 8 * v5))(v4);
  }

void sub_10003B18C( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17)
{
  if (a17 == v17)
  {
    uint64_t v19 = 4LL;
  }

  else
  {
    if (!a17) {
      goto LABEL_6;
    }
    uint64_t v19 = 5LL;
    unint64_t v17 = a17;
  }

  (*(void (**)(void *))(*v17 + 8 * v19))(v17);
LABEL_6:
  _Unwind_Resume(exception_object);
}

uint64_t sub_10003B1D0(uint64_t a1, char a2)
{
  char v4 = a2;
  uint64_t v2 = *(void *)(a1 + 56);
  if (!v2) {
    sub_100007B40();
  }
  return (*(uint64_t (**)(uint64_t, char *))(*(void *)v2 + 48LL))(v2, &v4);
}

uint64_t sub_10003B208(uint64_t a1, uint64_t a2)
{
  return sub_100007B8C(a1 + 32, a2 + 32);
}

void *sub_10003B214(uint64_t a1)
{
  uint64_t v1 = (void *)(a1 + 32);
  uint64_t result = *(void **)(a1 + 56);
  if (result == v1)
  {
    uint64_t v3 = 4LL;
    uint64_t result = v1;
  }

  else
  {
    if (!result) {
      return result;
    }
    uint64_t v3 = 5LL;
  }

  return (void *)(*(uint64_t (**)(void))(*result + 8 * v3))();
}

void RDUserProfile::writeUserProfileToCache(id **this)
{
  if (*(_DWORD *)this == 1)
  {
    uint64_t v1 = (os_log_s *)RXOSLog();
    if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)uint64_t v2 = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v1,  OS_LOG_TYPE_ERROR,  "writeUserProfileToCache not allowed for inline mode",  v2,  2u);
    }
  }

  else
  {
    _[*this[1] writeUserProfileToCache];
  }

void RDUserProfile::~RDUserProfile(id **this)
{
  uint64_t v2 = this[1];
  this[1] = 0LL;
  if (v2) {
    operator delete(v2);
  }
}

void RDUserProfile::addPhraseToUserProfile( id **this, const __CFArray *a2, const __CFString *a3, const __CFString *a4)
{
  if (!a2 && CFArrayGetCount(0LL) <= 0)
  {
    uint64_t v8 = (os_log_s *)RXOSLog();
    if (!os_log_type_enabled(v8, OS_LOG_TYPE_ERROR)) {
      return;
    }
    *(_WORD *)std::string buf = 0;
    uint8x8_t v9 = "addPhraseToUserProfile: Null phrase being added to profile. Ignoring..";
    uint64_t v10 = buf;
    goto LABEL_10;
  }

  if (a3 && a4)
  {
    [*this[1] addPhraseToUserProfileWithTemplateName:a3 wordTag:a4 phrase:a2];
    return;
  }

  uint64_t v8 = (os_log_s *)RXOSLog();
  if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
  {
    __int16 v11 = 0;
    uint8x8_t v9 = "addPhraseToUserProfile: NULL NTString or WordTag when adding to profile. Ignoring..";
    uint64_t v10 = (uint8_t *)&v11;
LABEL_10:
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, v9, v10, 2u);
  }

void RDUserProfile::addPhraseAndPronsToUserProfile( id **this, const __CFString *a2, const __CFArray *a3, const __CFString *a4, const __CFString *a5)
{
  if (!a2)
  {
    uint64_t v5 = (os_log_s *)RXOSLog();
    if (!os_log_type_enabled(v5, OS_LOG_TYPE_ERROR)) {
      return;
    }
    __int16 v9 = 0;
    __int128 v6 = "addPhraseToUserProfile: Null phrase being added to profile. Ignoring..";
    uint64_t v7 = (uint8_t *)&v9;
    goto LABEL_9;
  }

  if (a4 && a5)
  {
    _[*this[1] addPhraseToUserProfileWithIPAprons:a4 wordTag:a5 phrase:a2 pronsArray:a3];
    return;
  }

  uint64_t v5 = (os_log_s *)RXOSLog();
  if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
  {
    __int16 v8 = 0;
    __int128 v6 = "addPhraseToUserProfile: NULL NTString or WordTag when adding to profile. Ignoring..";
    uint64_t v7 = (uint8_t *)&v8;
LABEL_9:
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, v6, v7, 2u);
  }

void RDUserProfile::addWordCombinations( id **this, const __CFArray *a2, const __CFString *a3, const __CFString *a4)
{
  if (!a2 && CFArrayGetCount(0LL) <= 0)
  {
    uint64_t v10 = (os_log_s *)RXOSLog();
    if (!os_log_type_enabled(v10, OS_LOG_TYPE_ERROR)) {
      return;
    }
    *(_WORD *)std::string buf = 0;
    __int16 v11 = "addWordCombinations: Null phrase being added to profile. Ignoring..";
    char v12 = buf;
    goto LABEL_15;
  }

  if (!a3 || !a4)
  {
    uint64_t v10 = (os_log_s *)RXOSLog();
    if (!os_log_type_enabled(v10, OS_LOG_TYPE_ERROR)) {
      return;
    }
    __int16 v13 = 0;
    __int16 v11 = "addWordCombinations: NULL NTString or WordTag when adding to profile. Ignoring..";
    char v12 = (uint8_t *)&v13;
LABEL_15:
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, v11, v12, 2u);
    return;
  }

  for (uint64_t i = 1LL; i != 4; ++i)
  {
    if ((uint64_t)((uint64_t)&_mh_execute_header
                 + ((unint64_t)(-[__CFArray count](a2, "count") - i) << 32)) >= 1)
    {
      uint64_t v9 = 0LL;
      do
        objc_msgSend( *this[1],  "addPhraseToUserProfileWithTemplateName:wordTag:phrase:",  a3,  a4,  -[__CFArray subarrayWithRange:](a2, "subarrayWithRange:", v9++, i));
      while (v9 < (int)(-[__CFArray count](a2, "count") - i + 1));
    }
  }

id RDUserProfile::removeAllWords(id **this)
{
  return _[*this[1] removeAllWords];
}

id RDUserProfile::removeLmeDataForTemplateName(id **this, const __CFString *a2)
{
  return _[*this[1] removeLmeDataForTemplateName:a2];
}

id RDUserProfile::copyDataProfile(id **this)
{
  id result = [*this[1] dataProfile];
  if (result) {
    return result;
  }
  return result;
}

RDASRWrapper *RDASRWSpeechRecognizerCreate(uint64_t a1, int a2, uint64_t a3)
{
  __int128 v6 = objc_alloc_init(&OBJC_CLASS___RDASRWrapper);
  else {
    uint64_t v7 = RDEARCSpeechRecognizerCreate(a1, a2);
  }
  -[RDASRWrapper setRecognizer:](v6, "setRecognizer:", v7);
  uint64_t v8 = RXOSLog();
  uint64_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue(v8);
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
  {
    *(_WORD *)__int16 v11 = 0;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEBUG, "ASRWrapper created recognizer", v11, 2u);
  }

  return v6;
}

id RDASRWSpeechRecognizerCreateRecognitionBuffer(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  id v9 = a1;
  int v10 = RXIsSpeechSPIEnabled([v9 mapDelegate:a5]);
  id v11 = [v9 recognizer];
  id v12 = [v9 recognitionDelegate];
  if (v10) {
    uint64_t RecognitionBuffer = (uint64_t)RDSAPICSpeechAnalyzerCreateRecognitionBuffer(v11, a2, a3, a4, (uint64_t)v12);
  }
  else {
    uint64_t RecognitionBuffer = RDEARCSpeechRecognizerCreateRecognitionBuffer(v11, a2, a3, a4, (uint64_t)v12);
  }
  [v9 setRecognitionBuffer:RecognitionBuffer];
  uint64_t v14 = RXOSLog();
  BOOL v15 = (os_log_s *)objc_claimAutoreleasedReturnValue(v14);
  if (os_log_type_enabled(v15, OS_LOG_TYPE_DEBUG))
  {
    *(_WORD *)size_t v18 = 0;
    _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEBUG, "ASRWrapper created audio buffer", v18, 2u);
  }

  id v16 = [v9 recognitionBuffer];
  return v16;
}

uint64_t RDASRWSpeechRecognitionAudioBufferNewUtteranceBegins(uint64_t a1)
{
  uint64_t result = RXIsSpeechSPIEnabled();
  if ((_DWORD)result) {
    return RDSAPICSpeechAnalyzerNewUtteranceBegins(a1);
  }
  return result;
}

id RDASRWSpeechRecognitionAudioBufferAddAudioSamples(void *a1, uint64_t a2, uint64_t a3)
{
  else {
    return RDEARCSpeechRecognitionAudioBufferAddAudioSamples(a1, a2, a3);
  }
}

void RDASRWSpeechRecognitionAudioBufferEndAudio(uint64_t a1)
{
  else {
    RDEARCSpeechRecognitionAudioBufferEndAudio(a1);
  }
  uint64_t v2 = RXOSLog();
  uint64_t v3 = (os_log_s *)objc_claimAutoreleasedReturnValue(v2);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEBUG))
  {
    *(_WORD *)char v4 = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEBUG, "ASRWrapper end audio", v4, 2u);
  }
}

void RDASRWSpeechRecognitionAudioBufferCancelRecognition(uint64_t a1)
{
  else {
    RDEARCSpeechRecognitionAudioBufferCancelRecognition(a1);
  }
  uint64_t v2 = RXOSLog();
  uint64_t v3 = (os_log_s *)objc_claimAutoreleasedReturnValue(v2);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEBUG))
  {
    *(_WORD *)char v4 = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEBUG, "ASRWrapper cancel audio", v4, 2u);
  }
}

id RDASRWSpeechRecognizerSetDetectUtterances(void *a1, uint64_t a2)
{
  int v4 = RXIsSpeechSPIEnabled();
  id v5 = [a1 recognizer];
  if (v4) {
    return (id)RDSAPICSpeechAnalyzerSetDetectUtterances(v5, a2);
  }
  else {
    return RDEARCSpeechRecognizerSetDetectUtterances(v5, a2);
  }
}

id RDASRWSpeechRecognizerSetHighPriority(void *a1, uint64_t a2)
{
  int v4 = RXIsSpeechSPIEnabled();
  id v5 = [a1 recognizer];
  if (v4) {
    return (id)RDSAPICSpeechAnalyzerSetHighPriority(v5, a2);
  }
  else {
    return RDEARCSpeechRecognizerSetHighPriority(v5, a2);
  }
}

id RDASRWSpeechRecognizerSetFarField(void *a1, uint64_t a2)
{
  int v4 = RXIsSpeechSPIEnabled(a1);
  id v5 = [a1 recognizer];
  if (v4) {
    return (id)RDSAPICSpeechAnalyzerSetFarField(v5, a2);
  }
  else {
    return RDEARCSpeechRecognizerSetFarField(v5, a2);
  }
}

id RDASRWSpeechRecognizerUpdateUserProfileData(void *a1, uint64_t a2)
{
  int v4 = RXIsSpeechSPIEnabled();
  id v5 = [a1 recognizer];
  if (v4) {
    return RDSAPICSpeechAnalyzerUpdateUserProfileData(v5, a2);
  }
  else {
    return RDEARCSpeechRecognizerUpdateUserProfileData(v5, a2);
  }
}

CFTypeRef RDASRWSpeechRecognizerCopyUserProfileData(void *a1)
{
  int v2 = RXIsSpeechSPIEnabled(a1);
  id v3 = [a1 recognizer];
  if (v2) {
    return RDSAPICSpeechAnalyzerCopyUserProfileData(v3);
  }
  else {
    return RDEARCSpeechRecognizerCopyUserProfileData(v3);
  }
}

id RDASRWSpeechRecognizerSetUserProfileData(void *a1, uint64_t a2)
{
  int v4 = RXIsSpeechSPIEnabled();
  id v5 = [a1 recognizer];
  if (v4) {
    return RDSAPICSpeechAnalyzerSetUserProfileData(v5, a2);
  }
  else {
    return RDEARCSpeechRecognizerSetUserProfileData(v5, a2);
  }
}

CFTypeRef RDASRWSpeechRecognizerCopyJitProfileData(void *a1)
{
  int v2 = RXIsSpeechSPIEnabled(a1);
  id v3 = [a1 recognizer];
  if (v2) {
    return RDSAPICSpeechAnalyzerCopyJitProfileData(v3);
  }
  else {
    return RDEARCSpeechRecognizerCopyJitProfileData(v3);
  }
}

id RDASRWSpeechRecognizerSetJitProfileData(void *a1, uint64_t a2)
{
  int v4 = RXIsSpeechSPIEnabled(a1);
  id v5 = [a1 recognizer];
  if (v4) {
    return RDSAPICSpeechAnalyzerSetJitProfileData(v5, a2);
  }
  else {
    return RDEARCSpeechRecognizerSetJitProfileData(v5, a2);
  }
}

id RDASRWSpeechRecognizerUpdateJitProfileData(void *a1, uint64_t a2)
{
  int v4 = RXIsSpeechSPIEnabled();
  id v5 = [a1 recognizer];
  if (v4) {
    return RDSAPICSpeechAnalyzerUpdateJitProfileData(v5, a2);
  }
  else {
    return RDEARCSpeechRecognizerUpdateJitProfileData(v5, a2);
  }
}

id RDASRWSpeechRecognizerSetLeftContextText(void *a1, uint64_t a2)
{
  int v4 = RXIsSpeechSPIEnabled(a1);
  id v5 = [a1 recognizer];
  if (v4) {
    return RDSAPICSpeechAnalyzerSetLeftContextText(v5, a2);
  }
  else {
    return RDEARCSpeechRecognizerSetLeftContextText(v5, a2);
  }
}

id RDASRWSpeechRecognizerSetRecognitionReplacements(void *a1, const char *a2)
{
  if (a2 && CFDictionaryGetCount((CFDictionaryRef)a2) >= 1)
  {
    id v4 = [a1 recognizer];
    uint64_t v5 = 1LL;
  }

  else
  {
    id v4 = [a1 recognizer];
    uint64_t v5 = 0LL;
  }

  return RDSAPICSpeechAnalyzerSetRecognitionReplacements(v4, (const char *)v5);
}

id RDASRWSpeechRecognitionTokenGetTokenName(void *a1)
{
  else {
    return RDEARCSpeechRecognitionTokenGetTokenName(a1);
  }
}

id RDASRWSpeechRecognitionTokenGetStart(void *a1)
{
  else {
    return RDEARCSpeechRecognitionTokenGetStart(a1);
  }
}

id RDASRWSpeechRecognitionTokenGetEnd(void *a1)
{
  else {
    return RDEARCSpeechRecognitionTokenGetEnd(a1);
  }
}

id RDASRWSpeechRecognitionTokenGetSilenceStart(void *a1)
{
  else {
    return RDEARCSpeechRecognitionTokenGetSilenceStart(a1);
  }
}

id RDASRWSpeechRecognitionTokenGetConfidence(void *a1)
{
  else {
    return RDEARCSpeechRecognitionTokenGetConfidence(a1);
  }
}

id RDASRWSpeechRecognitionTokenHasSpaceAfter(void *a1)
{
  else {
    return RDEARCSpeechRecognitionTokenHasSpaceAfter(a1);
  }
}

uint64_t RDASRWSpeechRecognitionGetTokens(uint64_t a1)
{
  else {
    return RDEARCSpeechRecognitionGetTokens(a1);
  }
}

void RDPeer::RDPeer(RDPeer *this, _xpc_connection_s *a2)
{
  *(void *)this = off_1000CF3C0;
  *((void *)this + 1) = a2;
  *((_BYTE *)this + 16) = 0;
  *((void *)this + 3) = 0LL;
  *((void *)this + 4) = 0LL;
}

{
  *(void *)this = off_1000CF3C0;
  *((void *)this + 1) = a2;
  *((_BYTE *)this + 16) = 0;
  *((void *)this + 3) = 0LL;
  *((void *)this + 4) = 0LL;
}

void RDPeer::~RDPeer(RDPeer *this)
{
  *(void *)this = off_1000CF3C0;
  *((void *)this + 1) = 0LL;
  uint64_t v1 = (void *)*((void *)this + 4);
  if (v1) {
    xpc_release(v1);
  }
}

{
  void *v1;
  RDPeer::~RDPeer(this);
  operator delete(v1);
}

char *RDPeer::ClientHello(RDPeer *this, xpc_object_t object)
{
  uint64_t result = xpc_copy_description(object);
  *((void *)this + 3) = result;
  return result;
}

uint64_t RDPeer::ClientUpdate(RDPeer *this, xpc_object_t object)
{
  if (*((_BYTE *)this + 16))
  {
    if (*((void *)this + 3))
    {
      id v4 = (os_log_s *)RXOSLog();
      if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v5 = (char *)*((void *)this + 3);
        int v10 = 136315138;
        id v11 = v5;
        _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Client Hello %s", (uint8_t *)&v10, 0xCu);
      }
    }

    __int128 v6 = xpc_copy_description(object);
    uint64_t v7 = (os_log_s *)RXOSLog();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      int v10 = 136315138;
      id v11 = v6;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "Client Update %s", (uint8_t *)&v10, 0xCu);
    }

    free(v6);
  }

  uint64_t v8 = (void *)*((void *)this + 3);
  if (v8)
  {
    free(v8);
    *((void *)this + 3) = 0LL;
  }

  return 0LL;
}

void RDPeer::GetAudio(RDPeer *this, void *a2, xpc_object_t xdict)
{
  if (*((_BYTE *)this + 16))
  {
    xpc_dictionary_get_data(xdict, kRDKeyAudioData, &length);
    id v4 = (os_log_s *)RXOSLog();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t int64 = xpc_dictionary_get_uint64(a2, kRDKeyResultID);
      uint64_t v6 = xpc_dictionary_get_uint64(a2, kRDKeyStartTime);
      uint64_t v7 = xpc_dictionary_get_uint64(a2, kRDKeyEndTime);
      *(_DWORD *)std::string buf = 134218752;
      uint64_t v10 = uint64;
      __int16 v11 = 2048;
      uint64_t v12 = v6;
      __int16 v13 = 2048;
      uint64_t v14 = v7;
      __int16 v15 = 2048;
      size_t v16 = length;
      _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEFAULT,  "Get Audio %llx[%llu, %llu] -> %lu samples\n",  buf,  0x2Au);
    }
  }

void RDPeer::ReleaseResult(RDPeer *this, void *a2)
{
  if (*((_BYTE *)this + 16))
  {
    id v3 = (os_log_s *)RXOSLog();
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      int v4 = 134217984;
      uint64_t int64 = xpc_dictionary_get_uint64(a2, kRDKeyResultID);
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Release Result %llx\n", (uint8_t *)&v4, 0xCu);
    }
  }

void RDPeer::AddTraining(RDPeer *this, xpc_object_t object)
{
  if (*((_BYTE *)this + 16))
  {
    int v2 = xpc_copy_description(object);
    id v3 = (os_log_s *)RXOSLog();
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      int v4 = 136315138;
      uint64_t v5 = v2;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Training Data %s", (uint8_t *)&v4, 0xCu);
    }

    free(v2);
  }

void RDPeer::SetSecureFieldFocused(RDPeer *this, xpc_object_t object)
{
  if (*((_BYTE *)this + 16))
  {
    int v2 = xpc_copy_description(object);
    id v3 = (os_log_s *)RXOSLog();
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      int v4 = 136315138;
      uint64_t v5 = v2;
      _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_DEFAULT,  "Focus on secure field %s",  (uint8_t *)&v4,  0xCu);
    }

    free(v2);
  }

void RDPeer::AddLeadingContext(RDPeer *this, xpc_object_t object)
{
  if (*((_BYTE *)this + 16))
  {
    int v2 = xpc_copy_description(object);
    id v3 = (os_log_s *)RXOSLog();
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      int v4 = 136315138;
      uint64_t v5 = v2;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Leading context %s", (uint8_t *)&v4, 0xCu);
    }

    free(v2);
  }

void RDPeer::AddOtherContext(RDPeer *this, xpc_object_t object)
{
  if (*((_BYTE *)this + 16))
  {
    int v2 = xpc_copy_description(object);
    id v3 = (os_log_s *)RXOSLog();
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      int v4 = 136315138;
      uint64_t v5 = v2;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Other context %s", (uint8_t *)&v4, 0xCu);
    }

    free(v2);
  }

void RDPeer::ResetRecognition(RDPeer *this)
{
  if (*((_BYTE *)this + 16))
  {
    uint64_t v1 = (os_log_s *)RXOSLog();
    if (os_log_type_enabled(v1, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)int v2 = 0;
      _os_log_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_DEFAULT, "Resetting recogition", v2, 2u);
    }
  }

void RDPeer::SetResetRecognitionMode(RDPeer *this, void *a2)
{
  if (*((_BYTE *)this + 16))
  {
    int v2 = (os_log_s *)RXOSLog();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)id v3 = 0;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Setting recognition reset mode", v3, 2u);
    }
  }

void RDPeer::SaveUserProfileToFile(RDPeer *this, void *a2)
{
  if (*((_BYTE *)this + 16))
  {
    int v2 = (os_log_s *)RXOSLog();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)id v3 = 0;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Saving user profile to file", v3, 2u);
    }
  }

void RDPeer::PhoneticNeighborsForText(RDPeer *this, xpc_object_t xdict, void *a3)
{
  if (*((_BYTE *)this + 16))
  {
    string = xpc_dictionary_get_string(xdict, kRDKeyText);
    uint64_t v5 = (os_log_s *)RXOSLog();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      int v7 = 136315138;
      uint64_t v8 = string;
      _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEFAULT,  "PhoneticNeighborsForText %s",  (uint8_t *)&v7,  0xCu);
    }
  }

  xpc_object_t empty = xpc_array_create_empty();
  xpc_dictionary_set_value(a3, kRDKeyText, empty);
}

void RDPeer::ServerIsRunning(RDPeer *this, char a2)
{
  v2[0] = _NSConcreteStackBlock;
  v2[1] = 0x40000000LL;
  v2[2] = sub_10003C880;
  v2[3] = &unk_1000CF440;
  v2[4] = this;
  char v3 = a2;
  dispatch_async((dispatch_queue_t)gRDServerQueue, v2);
}

void sub_10003C880(uint64_t a1)
{
  int v2 = *(RDPeer **)(a1 + 32);
  RDPeer::UnlockConfig((RDPeer *)a1);
  xpc_object_t v3 = xpc_dictionary_create(0LL, 0LL, 0LL);
  int v4 = v3;
  if (*(_BYTE *)(a1 + 40)) {
    int64_t v5 = 204LL;
  }
  else {
    int64_t v5 = 203LL;
  }
  xpc_dictionary_set_int64(v3, kRDKeyMessage, v5);
  if (*((_BYTE *)v2 + 16))
  {
    uint64_t v6 = xpc_copy_description(v4);
    int v7 = (os_log_s *)RXOSLog();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      int v8 = 136315138;
      id v9 = v6;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "Server Response %s", (uint8_t *)&v8, 0xCu);
    }

    free(v6);
  }

  RDPeer::SendClientMessage(v2, v4);
}

void RDPeer::UnlockConfig(RDPeer *this)
{
  if (RDPeer::sBroker)
  {
    xpc_object_t v1 = xpc_dictionary_create(0LL, 0LL, 0LL);
    xpc_dictionary_set_int64(v1, kRDKeyMessage, 401LL);
    if (xpc_get_type(v1) == (xpc_type_t)&_xpc_type_dictionary)
    {
      xpc_connection_send_message((xpc_connection_t)RDPeer::sBroker, v1);
    }

    else
    {
      int v2 = (os_log_s *)RXOSLog();
      if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      {
        int v3 = 136315394;
        int v4 = kRDKeyMessage;
        __int16 v5 = 2112;
        xpc_object_t v6 = v1;
        _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_FAULT,  "API misuse for message %s : XPC_TYPE_DICTIONARY expected, passed %@ ",  (uint8_t *)&v3,  0x16u);
      }
    }

    xpc_release(v1);
  }

void RDPeer::SendClientMessage(RDPeer *this, xpc_object_t object)
{
  if (object)
  {
    int v4 = (void *)*((void *)this + 1);
    if (v4)
    {
      if (xpc_get_type(v4) == (xpc_type_t)&_xpc_type_connection) {
        xpc_connection_send_message(*((xpc_connection_t *)this + 1), object);
      }
    }

    xpc_release(object);
  }

RDQSRPeer *RDPeer::CreatePeer( RDPeer *this, _xpc_connection_s *a2, uint64_t a3, RDAudioObject *a4, RDAudioObject *a5)
{
  id v9 = (os_log_s *)RXOSLog();
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
  {
    int v15 = 134218752;
    size_t v16 = this;
    __int16 v17 = 2048;
    size_t v18 = a2;
    __int16 v19 = 2048;
    uint64_t v20 = a3;
    __int16 v21 = 2048;
    unint64_t v22 = a4;
    _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEFAULT,  "CreatePeer, %p, %p, %llx, %p",  (uint8_t *)&v15,  0x2Au);
  }

  if (a4)
  {
    string_ptr = (RDKeyword *)xpc_string_get_string_ptr(a2);
    RDKeyword::SetLocale(string_ptr, v11);
  }

  uint64_t v12 = xpc_string_get_string_ptr(a2);
  CFStringCreateWithCString(0LL, v12, 0x8000100u);
  __int16 v13 = (os_log_s *)RXOSLog();
  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v15) = 0;
    _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "Creating QSR peer", (uint8_t *)&v15, 2u);
  }

  return RDCreateQSRPeer(this, a2, a3, a4);
}

void RDPeer::LockConfig(RDPeer *this)
{
  if (RDPeer::sBroker)
  {
    xpc_object_t v1 = xpc_dictionary_create(0LL, 0LL, 0LL);
    xpc_dictionary_set_int64(v1, kRDKeyMessage, 400LL);
    xpc_object_t v2 = xpc_connection_send_message_with_reply_sync((xpc_connection_t)RDPeer::sBroker, v1);
    xpc_release(v1);
    if (xpc_get_type(v2) == (xpc_type_t)&_xpc_type_dictionary) {
      xpc_release(v2);
    }
  }

uint64_t RDPeer::KeepSystemAwake(RDPeer *this)
{
  return IOPMAssertionDeclareUserActivity(@"Speech Recognition Successful", kIOPMUserActiveLocal, dword_1000DDDA8);
}

uint64_t sub_10003CCDC(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(uint64_t))(*(void *)result + 120LL))(result);
  }
  return result;
}

uint64_t sub_10003CCF0(uint64_t result, char a2)
{
  *(_BYTE *)(result + 16) = a2;
  return result;
}

void sub_10003CD38(id a1)
{
  qword_1000DDDB0 = objc_alloc_init(&OBJC_CLASS___RDAssetManager2);
}

void sub_10003D510(uint64_t a1, uint64_t a2)
{
}

void sub_10003D520(uint64_t a1)
{
}

id sub_10003D52C(uint64_t a1)
{
  uint64_t v3 = 0LL;
  *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 4sub_10003A5DC((uint64_t)va, 0) =  [*(id *)(a1 + 32) _queryAndCopyInstallationStatusForLanguagesWithError:&v3];
  id result = *(id *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 40LL);
  if (!result || (id result = [result count]) == 0) {
    *(void *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 4sub_10003A5DC((uint64_t)va, 0LL) = v3;
  }
  return result;
}

void sub_10003DBA8(_Unwind_Exception *a1)
{
}

uint64_t sub_10003DBF8(uint64_t a1, void *a2)
{
  *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 4sub_10003A5DC((uint64_t)va, 0) = [a2 copy];
  return dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 32));
}

id sub_10003DFB0(uint64_t a1)
{
  uint64_t v3 = 0LL;
  id result = [*(id *)(a1 + 32) _cancelDownloadForLanguageWithError:*(void *)(a1 + 40) withError:&v3];
  *(void *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 4sub_10003A5DC((uint64_t)va, 0LL) = v3;
  return result;
}

void sub_10003E3EC(uint64_t a1)
{
  uint64_t v5 = 0LL;
  +[SFSpeechAssetManager setAssetsPurgeability:forLanguages:error:]( &OBJC_CLASS___SFSpeechAssetManager,  "setAssetsPurgeability:forLanguages:error:",  *(unsigned __int8 *)(a1 + 56),  *(void *)(a1 + 32),  &v5);
  xpc_object_t v2 = (os_log_s *)RXOSLog();
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = *(void *)(a1 + 40);
    int v4 = *(unsigned __int8 *)(a1 + 56);
    *(_DWORD *)std::string buf = 138412802;
    uint64_t v7 = v3;
    __int16 v8 = 1024;
    int v9 = v4;
    __int16 v10 = 2112;
    uint64_t v11 = v5;
    _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEFAULT,  "setPurgeabilityForLanguages, languages=%@  purgeability= %d error=%@",  buf,  0x1Cu);
  }

  *(void *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 4sub_10003A5DC((uint64_t)va, 0LL) = v5;
}

void sub_10003E6C4( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
}

id sub_10003E6E8(uint64_t a1)
{
  uint64_t v3 = 0LL;
  id result = objc_msgSend( objc_msgSend(*(id *)(a1 + 32), "_installedAssetForLanguage:error:", *(void *)(a1 + 40), &v3),  "copy");
  *(void *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 4sub_10003A5DC((uint64_t)va, 0LL) = result;
  if (!*(void *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 40LL)) {
    *(void *)(*(void *)(*(void *)(a1 + 56) + 8LL) + 4sub_10003A5DC((uint64_t)va, 0LL) = v3;
  }
  return result;
}

void sub_10003EB10( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
}

uint64_t sub_10003EB38(uint64_t a1, void *a2, uint64_t a3)
{
  *(void *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 4sub_10003A5DC((uint64_t)va, 0LL) = a3;
  if (!a3) {
    *(void *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 4sub_10003A5DC((uint64_t)va, 0LL) = a2;
  }
  return dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 32));
}

__n128 sub_10003EF68(uint64_t a1, uint64_t a2, char a3)
{
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 3221225472LL;
  __int128 v3 = *(_OWORD *)(a1 + 32);
  int v4 = *(dispatch_queue_s **)(*(void *)(a1 + 32) + 16LL);
  _DWORD v6[2] = sub_10003EFE4;
  v6[3] = &unk_1000CF5C8;
  __int128 v7 = v3;
  int v10 = *(_DWORD *)(a1 + 56);
  uint64_t v8 = *(void *)(a1 + 48);
  uint64_t v9 = a2;
  int v11 = *(_DWORD *)(a1 + 60);
  char v12 = a3;
  dispatch_async(v4, v6);
  return result;
}

void sub_10003EFE4(uint64_t a1)
{
  if ([*(id *)(a1 + 32) _isActiveDownloadForLanguage:*(void *)(a1 + 40) downloadId:*(unsigned int *)(a1 + 64)])
  {
    float v2 = fmin((double)*(unint64_t *)(a1 + 56) / 100.0, 1.0);
    -[NSDate timeIntervalSinceDate:]( +[NSDate date](&OBJC_CLASS___NSDate, "date"),  "timeIntervalSinceDate:",  *(void *)(a1 + 48));
    float v4 = -1.0;
    if (v2 > 0.0)
    {
      if (v3 < 0.0) {
        double v3 = 0.0;
      }
      float v5 = v3;
      float v4 = (1.0 - v2) * v5 / v2;
    }

    float v6 = *(float *)(a1 + 68) * v2;
    __int128 v7 = *(void **)(a1 + 32);
    uint64_t v8 = *(void *)(a1 + 40);
    if (*(_BYTE *)(a1 + 72))
    {
      [v7 _stalledDownloadForLanguage:v8];
      uint64_t v9 = (os_log_s *)RXOSLog();
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
      {
        double v10 = (float)(v6 / *(float *)(a1 + 68));
        int v11 = *(_DWORD *)(a1 + 64);
        id v12 = [*(id *)(a1 + 32) _downloadStatusDescription];
        int v26 = 134218754;
        *(double *)int v27 = v10;
        *(_WORD *)&v27[8] = 2048;
        *(double *)&v27[10] = v4;
        __int16 v28 = 1024;
        int v29 = v11;
        __int16 v30 = 2112;
        id v31 = v12;
        _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEFAULT,  "Asset Download Progress stalled at : %.2f ratio , ~%.2f seconds remaining, downloadId=%d, %@",  (uint8_t *)&v26,  0x26u);
      }

      if ([*(id *)(a1 + 32) _sendCallback])
      {
        size_t v16 = *(void **)(a1 + 32);
        uint64_t v17 = *(void *)(a1 + 40);
        LODWORD(v15) = *(_DWORD *)(a1 + 68);
        size_t v18 = @"Stalled";
        LODWORD(v13) = -1.0;
LABEL_19:
        *(float *)&double v14 = v6;
        [v16 _sendDownloadCallbackDictionaryWithLanguage:v17 downloadPhase:v18 timeRemaining:0 bytesWritten:v13 bytesTotal:v14 error:v15];
      }
    }

    else
    {
      unint64_t v22 = (os_log_s *)RXOSLog();
      if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
      {
        double v23 = (float)(v6 / *(float *)(a1 + 68));
        int v24 = *(_DWORD *)(a1 + 64);
        id v25 = [*(id *)(a1 + 32) _downloadStatusDescription];
        int v26 = 134218754;
        *(double *)int v27 = v23;
        *(_WORD *)&v27[8] = 2048;
        *(double *)&v27[10] = v4;
        __int16 v28 = 1024;
        int v29 = v24;
        __int16 v30 = 2112;
        id v31 = v25;
        _os_log_impl( (void *)&_mh_execute_header,  v22,  OS_LOG_TYPE_DEFAULT,  "Asset Download progress: %.2f ratio , ~%.2f seconds remaining, downloadId=%d, %@",  (uint8_t *)&v26,  0x26u);
      }

      if ([*(id *)(a1 + 32) _sendCallback])
      {
        size_t v16 = *(void **)(a1 + 32);
        uint64_t v17 = *(void *)(a1 + 40);
        LODWORD(v15) = *(_DWORD *)(a1 + 68);
        size_t v18 = @"Downloading";
        *(float *)&double v13 = v4;
        goto LABEL_19;
      }
    }
  }

  else
  {
    __int16 v19 = (os_log_s *)RXOSLog();
    if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
    {
      int v20 = *(_DWORD *)(a1 + 64);
      id v21 = [*(id *)(a1 + 32) _downloadStatusDescription];
      int v26 = 67109378;
      *(_DWORD *)int v27 = v20;
      *(_WORD *)&v27[4] = 2112;
      *(void *)&v27[6] = v21;
      _os_log_impl( (void *)&_mh_execute_header,  v19,  OS_LOG_TYPE_DEFAULT,  "Ignoring non-active asset download progress downloadId=%d, %@",  (uint8_t *)&v26,  0x12u);
    }
  }

__n128 sub_10003F2B4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472LL;
  __int128 v3 = *(_OWORD *)(a1 + 32);
  float v4 = *(dispatch_queue_s **)(*(void *)(a1 + 32) + 16LL);
  block[2] = sub_10003F328;
  block[3] = &unk_1000CF618;
  __int128 v7 = v3;
  int v10 = *(_DWORD *)(a1 + 48);
  uint64_t v8 = a3;
  uint64_t v9 = a2;
  int v11 = *(_DWORD *)(a1 + 52);
  dispatch_async(v4, block);
  return result;
}

void sub_10003F328(uint64_t a1)
{
  if ([*(id *)(a1 + 32) _isActiveDownloadForLanguage:*(void *)(a1 + 40) downloadId:*(unsigned int *)(a1 + 64)])
  {
    [*(id *)(a1 + 32) _endAllDownloadsForLanguage:*(void *)(a1 + 40)];
    float v2 = *(NSError **)(a1 + 48);
    if ([*(id *)(a1 + 56) length]) {
      unsigned int v3 = sub_10003FCC8(*(void **)(a1 + 56), 0LL, (uint64_t)@"DictationCC");
    }
    else {
      unsigned int v3 = 0;
    }
    if ([*(id *)(a1 + 56) length] && (v3 & 1) == 0)
    {
      NSErrorUserInfoKey v34 = NSLocalizedFailureReasonErrorKey;
      unint64_t v35 = @"Asset is incompatible";
      float v2 = +[NSError errorWithDomain:code:userInfo:]( &OBJC_CLASS___NSError,  "errorWithDomain:code:userInfo:",  @"kRXAssetDownloadErrorDomain",  101LL,  +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v35,  &v34,  1LL));
    }

    __int128 v7 = (os_log_s *)RXOSLog();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v8 = *(void *)(a1 + 56);
      int v9 = *(_DWORD *)(a1 + 64);
      id v10 = [*(id *)(a1 + 32) _downloadStatusDescription];
      int v26 = 138413314;
      *(void *)int v27 = v8;
      *(_WORD *)&v27[8] = 2112;
      *(void *)&v27[10] = v2;
      __int16 v28 = 1024;
      unsigned int v29 = v3;
      __int16 v30 = 1024;
      int v31 = v9;
      __int16 v32 = 2112;
      id v33 = v10;
      _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEFAULT,  "Asset downloaded, assetPath=%@, error=%@, isCompatibleAsset=%d, downloadId=%d, %@",  (uint8_t *)&v26,  0x2Cu);
    }

    int v11 = (os_log_s *)RXOSLog();
    id v12 = v11;
    if (v3)
    {
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(v26) = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_DEFAULT,  "Asset download successful",  (uint8_t *)&v26,  2u);
      }

      int v13 = *(_DWORD *)(a1 + 68);
      if ([*(id *)(a1 + 32) _sendCallback])
      {
        LODWORD(v16) = *(_DWORD *)(a1 + 68);
        LODWORD(v14) = 0;
        LODWORD(v15) = v13;
        [*(id *)(a1 + 32) _sendDownloadCallbackDictionaryWithLanguage:*(void *)(a1 + 40) downloadPhase:@"Downloading" timeRemaining:0 bytesWritten:v14 bytesTotal:v15 error:v16];
        uint64_t v17 = *(void **)(a1 + 32);
        uint64_t v18 = *(void *)(a1 + 40);
        LODWORD(v19) = *(_DWORD *)(a1 + 68);
        int v20 = @"Downloaded";
        LODWORD(v21) = 0;
        LODWORD(v22) = v13;
        id v23 = 0LL;
LABEL_21:
        [v17 _sendDownloadCallbackDictionaryWithLanguage:v18 downloadPhase:v20 timeRemaining:v23 bytesWritten:v21 bytesTotal:v22 error:v19];
      }
    }

    else
    {
      if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
      {
        LOWORD(v26) = 0;
        _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, "Asset download failed", (uint8_t *)&v26, 2u);
      }

      if ([*(id *)(a1 + 32) _sendCallback])
      {
        id v25 = *(void **)(a1 + 32);
        uint64_t v24 = *(void *)(a1 + 40);
        id v23 = -[NSError description](v2, "description");
        int v20 = @"DownloadFailed";
        LODWORD(v21) = -1.0;
        LODWORD(v22) = -1.0;
        LODWORD(v19) = -1.0;
        uint64_t v17 = v25;
        uint64_t v18 = v24;
        goto LABEL_21;
      }
    }
  }

  else
  {
    float v4 = (os_log_s *)RXOSLog();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      int v5 = *(_DWORD *)(a1 + 64);
      id v6 = [*(id *)(a1 + 32) _downloadStatusDescription];
      int v26 = 67109378;
      *(_DWORD *)int v27 = v5;
      *(_WORD *)&v27[4] = 2112;
      *(void *)&v27[6] = v6;
      _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEFAULT,  "Ignoring non-active asset download downloadId=%d, %@",  (uint8_t *)&v26,  0x12u);
    }
  }

void sub_10003F670(_Unwind_Exception *a1)
{
}

void sub_10003F6CC(_Unwind_Exception *a1)
{
}

void sub_10003F728(_Unwind_Exception *a1)
{
}

void sub_10003FC34(_Unwind_Exception *exception_object)
{
}

id sub_10003FCC8(void *a1, void *a2, uint64_t a3)
{
  if (![a1 length])
  {
    int v13 = (os_log_s *)RXOSLog();
    id result = (id)os_log_type_enabled(v13, OS_LOG_TYPE_ERROR);
    if (!(_DWORD)result) {
      return result;
    }
    *(_WORD *)std::string buf = 0;
    id v12 = "empty quasarModelPath";
    double v14 = v13;
    os_log_type_t v15 = OS_LOG_TYPE_ERROR;
    uint32_t v16 = 2;
    goto LABEL_14;
  }

  id v6 = (const __CFString *)[a1 stringByAppendingPathComponent:@"mini.json"];
  if (!-[NSFileManager fileExistsAtPath:]( +[NSFileManager defaultManager](&OBJC_CLASS___NSFileManager, "defaultManager"),  "fileExistsAtPath:",  v6))
  {
    uint64_t v17 = (os_log_s *)RXOSLog();
    BOOL v18 = os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT);
    id result = 0LL;
    if (!v18) {
      return result;
    }
    *(_DWORD *)std::string buf = 138412546;
    int64_t v39 = @"mini.json";
    __int16 v40 = 2112;
    unint64_t v41 = v6;
    id v12 = "%@ does not exist at: %@ ";
    double v14 = v17;
    os_log_type_t v15 = OS_LOG_TYPE_DEFAULT;
    uint32_t v16 = 22;
    goto LABEL_14;
  }

  __int128 v7 = +[NSData dataWithContentsOfFile:](&OBJC_CLASS___NSData, "dataWithContentsOfFile:", v6);
  if (!v7)
  {
    int v9 = (os_log_s *)RXOSLog();
    BOOL v19 = os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT);
    id result = 0LL;
    if (!v19) {
      return result;
    }
    *(_DWORD *)std::string buf = 138412290;
    int64_t v39 = v6;
    id v12 = "could not read contents from : %@";
    goto LABEL_13;
  }

  uint64_t v37 = 0LL;
  id v8 = +[NSJSONSerialization JSONObjectWithData:options:error:]( &OBJC_CLASS___NSJSONSerialization,  "JSONObjectWithData:options:error:",  v7,  0LL,  &v37);
  if (v37)
  {
    int v9 = (os_log_s *)RXOSLog();
    BOOL v10 = os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT);
    id result = 0LL;
    if (!v10) {
      return result;
    }
    *(_DWORD *)std::string buf = 138412290;
    int64_t v39 = v6;
    id v12 = "%@ : not a valid json";
LABEL_13:
    double v14 = v9;
    os_log_type_t v15 = OS_LOG_TYPE_DEFAULT;
    uint32_t v16 = 12;
LABEL_14:
    _os_log_impl((void *)&_mh_execute_header, v14, v15, v12, buf, v16);
    return 0LL;
  }

  int v20 = v8;
  uint64_t v21 = objc_opt_class(&OBJC_CLASS___NSDictionary);
  if ((objc_opt_isKindOfClass(v20, v21) & 1) == 0) {
    return 0LL;
  }
  objc_msgSend( +[_EARSpeechRecognizer minimumSupportedConfigurationVersion]( _EARSpeechRecognizer,  "minimumSupportedConfigurationVersion"),  "floatValue");
  float v23 = v22;
  objc_msgSend( +[_EARSpeechRecognizer maximumSupportedConfigurationVersion]( _EARSpeechRecognizer,  "maximumSupportedConfigurationVersion"),  "floatValue");
  float v25 = v24;
  id v26 = [v20 objectForKey:@"version-major"];
  uint64_t v27 = objc_opt_class(&OBJC_CLASS___NSNumber);
  if ((objc_opt_isKindOfClass(v26, v27) & 1) == 0) {
    return 0LL;
  }
  [v26 floatValue];
  if (v28 < v23) {
    return 0LL;
  }
  [v26 floatValue];
  if (v29 > v25) {
    return 0LL;
  }
  id v30 = [v20 objectForKey:@"model-info"];
  uint64_t v31 = objc_opt_class(&OBJC_CLASS___NSDictionary);
  if ((objc_opt_isKindOfClass(v30, v31) & 1) == 0) {
    return 0LL;
  }
  id v32 = [v30 objectForKey:@"version"];
  uint64_t v33 = objc_opt_class(&OBJC_CLASS___NSString);
  char isKindOfClass = objc_opt_isKindOfClass(v32, v33);
  if (a2)
  {
    if ((isKindOfClass & 1) != 0) {
      *a2 = v32;
    }
  }

  id v35 = [v30 objectForKey:@"tasks"];
  id result = [v32 length];
  if (result)
  {
    uint64_t v36 = objc_opt_class(&OBJC_CLASS___NSArray);
    if ((objc_opt_isKindOfClass(v35, v36) & 1) != 0) {
      return [v35 containsObject:a3];
    }
    return 0LL;
  }

  return result;
}

void sub_1000404A4(id a1)
{
  qword_1000DDDC0 = objc_alloc_init(&OBJC_CLASS___RDAssetManager);
}

void sub_100040624(uint64_t a1)
{
  float v2 = (os_log_s *)RXOSLog();
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    if (*(_BYTE *)(a1 + 40)) {
      unsigned int v3 = @"with";
    }
    else {
      unsigned int v3 = @"without";
    }
    *(_DWORD *)std::string buf = 138412290;
    int v11 = v3;
    _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEFAULT,  "Kicking off catalog download %@ urgency",  buf,  0xCu);
  }

  if (([*(id *)(a1 + 32) catalogDownloadInProgress] & 1) == 0)
  {
    if (*(_BYTE *)(a1 + 40))
    {
      float v4 = *(double **)(a1 + 32);
LABEL_12:
      [v4 setCatalogDownloadInProgress:1];
      __int128 v7 = (os_log_s *)RXOSLog();
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)std::string buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEFAULT,  "Downloading EmbeddedSpeech catalog",  buf,  2u);
      }

      id v8 = sub_100040800(*(unsigned __int8 *)(a1 + 40));
      v9[0] = _NSConcreteStackBlock;
      v9[1] = 3221225472LL;
      v9[2] = sub_100040850;
      v9[3] = &unk_1000CF688;
      v9[4] = *(void *)(a1 + 32);
      +[MAAsset startCatalogDownload:options:then:]( &OBJC_CLASS___MAAsset,  "startCatalogDownload:options:then:",  @"com.apple.MobileAsset.EmbeddedSpeech",  v8,  v9);
      return;
    }

    -[NSDate timeIntervalSinceReferenceDate]( +[NSDate date](&OBJC_CLASS___NSDate, "date"),  "timeIntervalSinceReferenceDate");
    float v4 = *(double **)(a1 + 32);
    if (v5 - v4[1] >= 86400.0) {
      goto LABEL_12;
    }
    id v6 = (os_log_s *)RXOSLog();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "Too early since last catalog download. Returning.",  buf,  2u);
    }
  }

id sub_100040800(int a1)
{
  id v2 = objc_alloc_init(&OBJC_CLASS___MADownloadOptions);
  [v2 setAllowsCellularAccess:0];
  [v2 setDiscretionary:a1 ^ 1u];
  [v2 setRequiresPowerPluggedIn:0];
  return v2;
}

id sub_100040850(uint64_t a1, uint64_t a2)
{
  float v4 = (os_log_s *)RXOSLog();
  double v5 = v4;
  if (a2)
  {
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      id v6 = [*(id *)(a1 + 32) _errorStringForDownloadResult:a2];
      *(_DWORD *)std::string buf = 138412290;
      id v27 = v6;
      _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_ERROR,  "The MobileAsset catalog download failed: CFErrorRef error = %@",  buf,  0xCu);
    }

    id result = [*(id *)(a1 + 32) sendCallback];
    if ((_DWORD)result)
    {
      id v8 = *(void **)(a1 + 32);
      id v9 = [v8 _errorStringForDownloadResult:a2];
      LODWORD(v1RDString::RDString((RDString *)&v66, theString, 0) = -1.0;
      LODWORD(v11) = -1.0;
      LODWORD(v12) = -1.0;
      return [v8 _sendDownloadCallbackDictionaryWithLanguage:0 downloadPhase:@"DownloadFailed" timeRemaining:v9 bytesWritten:v10 bytesTotal:v11 error:v12];
    }
  }

  else
  {
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "Sucessfully downloaded the catalog", buf, 2u);
    }

    -[NSDate timeIntervalSinceReferenceDate]( +[NSDate date](&OBJC_CLASS___NSDate, "date"),  "timeIntervalSinceReferenceDate");
    *(void *)(*(void *)(a1 + 32) + 8LL) = v13;
    __int128 v24 = 0u;
    __int128 v25 = 0u;
    __int128 v22 = 0u;
    __int128 v23 = 0u;
    id v14 = [*(id *)(a1 + 32) requestedLanguagesForDownload];
    id result = [v14 countByEnumeratingWithState:&v22 objects:v28 count:16];
    if (result)
    {
      id v15 = result;
      uint64_t v16 = *(void *)v23;
      do
      {
        uint64_t v17 = 0LL;
        do
        {
          if (*(void *)v23 != v16) {
            objc_enumerationMutation(v14);
          }
          uint64_t v18 = *(void *)(*((void *)&v22 + 1) + 8LL * (void)v17);
          uint64_t v19 = *(void *)(a1 + 32);
          int v20 = *(dispatch_queue_s **)(v19 + 24);
          v21[0] = _NSConcreteStackBlock;
          v21[1] = 3221225472LL;
          v21[2] = sub_100040A84;
          v21[3] = &unk_1000CE1D0;
          v21[4] = v19;
          v21[5] = v18;
          dispatch_async(v20, v21);
          uint64_t v17 = (char *)v17 + 1;
        }

        while (v15 != v17);
        id result = [v14 countByEnumeratingWithState:&v22 objects:v28 count:16];
        id v15 = result;
      }

      while (result);
    }
  }

  return result;
}

id sub_100040A84(uint64_t a1)
{
  return _[*(id *)(a1 + 32) _fetchRemoteAssetForLanguage:*(void *)(a1 + 40)];
}

void sub_100040B6C(uint64_t a1, uint64_t a2)
{
}

void sub_100040B7C(uint64_t a1)
{
}

id sub_100040B88(uint64_t a1)
{
  uint64_t v3 = 0LL;
  *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 4sub_10003A5DC((uint64_t)va, 0) =  [*(id *)(a1 + 32) queryAndCopyInstallationStatusForLangaugesWithError:&v3];
  id result = *(id *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 40LL);
  if (!result || (id result = [result count]) == 0) {
    *(void *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 4sub_10003A5DC((uint64_t)va, 0LL) = v3;
  }
  return result;
}

id sub_1000411A4(void *a1)
{
  uint64_t v1 = (const __CFString *)[a1 stringByAppendingPathComponent:@"mini.json"];
  if (-[NSFileManager fileExistsAtPath:]( +[NSFileManager defaultManager](&OBJC_CLASS___NSFileManager, "defaultManager"),  "fileExistsAtPath:",  v1))
  {
    id v2 = +[NSData dataWithContentsOfFile:](&OBJC_CLASS___NSData, "dataWithContentsOfFile:", v1);
    if (v2)
    {
      uint64_t v19 = 0LL;
      id v3 = +[NSJSONSerialization JSONObjectWithData:options:error:]( &OBJC_CLASS___NSJSONSerialization,  "JSONObjectWithData:options:error:",  v2,  0LL,  &v19);
      if (!v19)
      {
        uint64_t v13 = v3;
        uint64_t v14 = objc_opt_class(&OBJC_CLASS___NSDictionary);
        if ((objc_opt_isKindOfClass(v13, v14) & 1) != 0)
        {
          id v15 = [v13 objectForKey:@"model-info"];
          uint64_t v16 = objc_opt_class(&OBJC_CLASS___NSDictionary);
          if ((objc_opt_isKindOfClass(v15, v16) & 1) != 0)
          {
            id v17 = [v15 objectForKey:@"tasks"];
            uint64_t v18 = objc_opt_class(&OBJC_CLASS___NSArray);
            if ((objc_opt_isKindOfClass(v17, v18) & 1) != 0) {
              return [v17 containsObject:@"DictationCC"];
            }
          }
        }

        return 0LL;
      }

      float v4 = (os_log_s *)RXOSLog();
      BOOL v5 = os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT);
      id result = 0LL;
      if (!v5) {
        return result;
      }
      *(_DWORD *)std::string buf = 138412290;
      uint64_t v21 = v1;
      __int128 v7 = "%@ : not a valid json";
    }

    else
    {
      float v4 = (os_log_s *)RXOSLog();
      BOOL v12 = os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT);
      id result = 0LL;
      if (!v12) {
        return result;
      }
      *(_DWORD *)std::string buf = 138412290;
      uint64_t v21 = v1;
      __int128 v7 = "could not read contents from : %@";
    }

    double v10 = v4;
    uint32_t v11 = 12;
  }

  else
  {
    id v8 = (os_log_s *)RXOSLog();
    BOOL v9 = os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT);
    id result = 0LL;
    if (!v9) {
      return result;
    }
    *(_DWORD *)std::string buf = 138412546;
    uint64_t v21 = @"mini.json";
    __int16 v22 = 2112;
    __int128 v23 = v1;
    __int128 v7 = "%@ does not exist at: %@ ";
    double v10 = v8;
    uint32_t v11 = 22;
  }

  _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, v7, buf, v11);
  return 0LL;
}

void sub_1000417BC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
}

id sub_1000417D4(uint64_t a1)
{
  uint64_t v3 = 0LL;
  id result = [*(id *)(a1 + 32) _cancelDownloadForLangaugeWithError:*(void *)(a1 + 40) withError:&v3];
  *(void *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 4sub_10003A5DC((uint64_t)va, 0LL) = v3;
  return result;
}

void sub_100041CB8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
}

NSError *sub_100041CDC(uint64_t a1)
{
  if ([*(id *)(a1 + 32) catalogDownloadInProgress])
  {
    id result = (NSError *)objc_msgSend( objc_msgSend(*(id *)(a1 + 32), "requestedLanguagesForDownload"),  "containsObject:",  *(void *)(a1 + 40));
    if ((result & 1) == 0)
    {
      uint64_t v3 = (os_log_s *)RXOSLog();
      if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v4 = *(void *)(a1 + 40);
        *(_DWORD *)std::string buf = 138412290;
        *(void *)&uint8_t buf[4] = v4;
        _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_DEFAULT,  "Catalog download is in progress, caching %@",  buf,  0xCu);
      }

      objc_msgSend(objc_msgSend(*(id *)(a1 + 32), "requestedLanguagesForDownload"), "addObject:", *(void *)(a1 + 40));
      *(void *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 4sub_10003A5DC((uint64_t)va, 0LL) = 0LL;
      NSErrorUserInfoKey v5 = NSLocalizedFailureReasonErrorKey;
      id v6 = @"Catalog download in progress";
      id result = +[NSError errorWithDomain:code:userInfo:]( &OBJC_CLASS___NSError,  "errorWithDomain:code:userInfo:",  @"kRXAssetDownloadErrorDomain",  100LL,  +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v6,  &v5,  1LL));
      *(void *)(*(void *)(*(void *)(a1 + 56) + 8LL) + 4sub_10003A5DC((uint64_t)va, 0LL) = result;
    }
  }

  else
  {
    *(void *)std::string buf = 0LL;
    id result = (NSError *)objc_msgSend( objc_msgSend( objc_msgSend( *(id *)(a1 + 32),  "_installedAssetForLanguage:error:",  *(void *)(a1 + 40),  buf),  "_es_quasarModelPath"),  "copy");
    *(void *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 4sub_10003A5DC((uint64_t)va, 0LL) = result;
    if (!*(void *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 40LL)) {
      *(void *)(*(void *)(*(void *)(a1 + 56) + 8LL) + 4sub_10003A5DC((uint64_t)va, 0LL) = *(void *)buf;
    }
  }

  return result;
}

void sub_100041EF0(int8x16_t *a1, uint64_t a2)
{
  v5[1] = 3221225472LL;
  int8x16_t v2 = vextq_s8(a1[2], a1[2], 8uLL);
  uint64_t v3 = a1[2].i64[0];
  v5[0] = _NSConcreteStackBlock;
  uint64_t v4 = *(dispatch_queue_s **)(v3 + 24);
  _OWORD v5[2] = sub_100041F5C;
  void v5[3] = &unk_1000CF700;
  int8x16_t v6 = v2;
  uint64_t v7 = a1[3].i64[0];
  uint64_t v8 = a2;
  dispatch_async(v4, v5);
}

void sub_100041F5C(uint64_t a1)
{
  if (*(void *)(a1 + 56))
  {
    int8x16_t v2 = (os_log_s *)RXOSLog();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
    {
      uint64_t v3 = *(void *)(a1 + 32);
      id v4 = [*(id *)(a1 + 40) _errorStringForQueryResult:*(void *)(a1 + 56)];
      *(_DWORD *)std::string buf = 138412546;
      uint64_t v12 = v3;
      __int16 v13 = 2112;
      id v14 = v4;
      NSErrorUserInfoKey v5 = "Async asset query failed for query=%@, error=%@";
      int8x16_t v6 = v2;
      os_log_type_t v7 = OS_LOG_TYPE_ERROR;
      uint32_t v8 = 22;
LABEL_4:
      _os_log_impl((void *)&_mh_execute_header, v6, v7, v5, buf, v8);
    }
  }

  else
  {
    uint64_t v10 = 0LL;
    if (!objc_msgSend( *(id *)(a1 + 40),  "_installedAssetFromFoundAssets:language:error:",  objc_msgSend(*(id *)(a1 + 32), "results"),  *(void *)(a1 + 48),  &v10))
    {
      uint64_t v9 = (os_log_s *)RXOSLog();
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)std::string buf = 138412290;
        uint64_t v12 = v10;
        NSErrorUserInfoKey v5 = "Remote fetch asset fetch got assets but none have been installed yet: %@";
        int8x16_t v6 = v9;
        os_log_type_t v7 = OS_LOG_TYPE_DEFAULT;
        uint32_t v8 = 12;
        goto LABEL_4;
      }
    }
  }
}

id sub_100042FA4(uint64_t a1, void *a2)
{
  unsigned __int8 v4 = [a2 isStalled];
  NSErrorUserInfoKey v5 = (os_log_s *)RXOSLog();
  BOOL v6 = os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT);
  if ((v4 & 1) != 0)
  {
    if (v6)
    {
      int v25 = 134218240;
      double v26 = COERCE_DOUBLE([a2 totalWritten]);
      __int16 v27 = 2048;
      id v28 = [a2 totalExpected];
      _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEFAULT,  "Asset Download Progress stalled at %lld of %lld bytes",  (uint8_t *)&v25,  0x16u);
    }

    id result = [*(id *)(a1 + 32) sendCallback];
    if ((_DWORD)result)
    {
      uint32_t v8 = *(void **)(a1 + 32);
      id v9 = objc_msgSend(*(id *)(a1 + 40), "_es_language");
      float v10 = (float)(uint64_t)[a2 totalWritten];
      *(float *)&double v11 = (float)(uint64_t)[a2 totalExpected];
      uint64_t v12 = @"Stalled";
      LODWORD(v13) = -1.0;
      id v14 = v8;
      id v15 = v9;
      *(float *)&double v16 = v10;
      return [v14 _sendDownloadCallbackDictionaryWithLanguage:v15 downloadPhase:v12 timeRemaining:0 bytesWritten:v13 bytesTotal:v16 error:v11];
    }
  }

  else
  {
    if (v6)
    {
      float v17 = (float)(uint64_t)[a2 totalWritten];
      double v18 = (float)(v17 / (float)(uint64_t)[a2 totalExpected]);
      [a2 expectedTimeRemaining];
      int v25 = 134218240;
      double v26 = v18;
      __int16 v27 = 2048;
      id v28 = v19;
      _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEFAULT,  "Asset Download progress: %.2f percent , ~%.2f seconds remaining",  (uint8_t *)&v25,  0x16u);
    }

    id result = [*(id *)(a1 + 32) sendCallback];
    if ((_DWORD)result)
    {
      int v20 = *(void **)(a1 + 32);
      id v21 = objc_msgSend(*(id *)(a1 + 40), "_es_language");
      [a2 expectedTimeRemaining];
      float v23 = v22;
      float v24 = (float)(uint64_t)[a2 totalWritten];
      *(float *)&double v11 = (float)(uint64_t)[a2 totalExpected];
      uint64_t v12 = @"Downloading";
      id v14 = v20;
      id v15 = v21;
      *(float *)&double v13 = v23;
      *(float *)&double v16 = v24;
      return [v14 _sendDownloadCallbackDictionaryWithLanguage:v15 downloadPhase:v12 timeRemaining:0 bytesWritten:v13 bytesTotal:v16 error:v11];
    }
  }

  return result;
}

void sub_100043194(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    if ([*(id *)(a1 + 32) sendCallback])
    {
      unsigned __int8 v4 = *(void **)(a1 + 32);
      id v5 = objc_msgSend(*(id *)(a1 + 40), "_es_language");
      id v6 = [*(id *)(a1 + 32) _errorStringForDownloadResult:a2];
      LODWORD(v7) = -1.0;
      LODWORD(v_Block_object_dispose((const void *)(v9 - 96), 8) = -1.0;
      LODWORD(v9) = -1.0;
      [v4 _sendDownloadCallbackDictionaryWithLanguage:v5 downloadPhase:@"DownloadFailed" timeRemaining:v6 bytesWritten:v7 bytesTotal:v8 error:v9];
    }

    float v10 = (os_log_s *)RXOSLog();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      id v11 = [*(id *)(a1 + 32) _errorStringForDownloadResult:a2];
      int v18 = 138412290;
      id v19 = v11;
      _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_ERROR,  "Asset download failed: %@",  (uint8_t *)&v18,  0xCu);
    }
  }

  else
  {
    uint64_t v12 = (os_log_s *)RXOSLog();
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v1_Block_object_dispose((const void *)(v9 - 96), 8) = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_DEFAULT,  "Asset download successful",  (uint8_t *)&v18,  2u);
    }

    if ([*(id *)(a1 + 32) sendCallback])
    {
      double v13 = *(void **)(a1 + 32);
      id v14 = objc_msgSend(*(id *)(a1 + 40), "_es_language");
      LODWORD(v15) = -1.0;
      LODWORD(v16) = -1.0;
      LODWORD(v17) = -1.0;
      [v13 _sendDownloadCallbackDictionaryWithLanguage:v14 downloadPhase:@"Downloaded" timeRemaining:0 bytesWritten:v15 bytesTotal:v16 error:v17];
    }
  }

void sub_100043308(uint64_t a1, uint64_t a2)
{
  unsigned __int8 v4 = (os_log_s *)RXOSLog();
  id v5 = v4;
  if (a2)
  {
    if (!os_log_type_enabled(v4, OS_LOG_TYPE_ERROR)) {
      return;
    }
    uint64_t v6 = *(void *)(a1 + 32);
    id v7 = [*(id *)(a1 + 40) _errorStringForPurgeResult:a2];
    int v13 = 138412546;
    uint64_t v14 = v6;
    __int16 v15 = 2112;
    id v16 = v7;
    double v8 = "Failed to purge %@: %@";
    double v9 = v5;
    os_log_type_t v10 = OS_LOG_TYPE_ERROR;
    uint32_t v11 = 22;
  }

  else
  {
    if (!os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT)) {
      return;
    }
    uint64_t v12 = *(void *)(a1 + 32);
    int v13 = 138412290;
    uint64_t v14 = v12;
    double v8 = "Purged %@";
    double v9 = v5;
    os_log_type_t v10 = OS_LOG_TYPE_DEFAULT;
    uint32_t v11 = 12;
  }

  _os_log_impl((void *)&_mh_execute_header, v9, v10, v8, (uint8_t *)&v13, v11);
}

NSNumber *sub_10004341C(void *a1, uint64_t a2)
{
  id v4 = [[MAAssetQuery alloc] initWithType:@"com.apple.MobileAsset.EmbeddedSpeech"];
  id v5 = [v4 queryMetaDataSync];
  if (v5)
  {
    id v6 = v5;
    id v7 = (os_log_s *)RXOSLog();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)std::string buf = 134217984;
      id v25 = v6;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, "MobileAsset is sad: %ld", buf, 0xCu);
    }

    if (a1)
    {
      double v22 = @"MAQueryResult";
      float v23 = +[NSNumber numberWithInteger:](&OBJC_CLASS___NSNumber, "numberWithInteger:", v6);
      *a1 = +[NSError errorWithDomain:code:userInfo:]( &OBJC_CLASS___NSError,  "errorWithDomain:code:userInfo:",  @"kRXAssetDownloadErrorDomain",  101LL,  +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v23,  &v22,  1LL));
    }

    return 0LL;
  }

  else
  {
    id v9 = [v4 results];

    __int128 v19 = 0u;
    __int128 v20 = 0u;
    __int128 v17 = 0u;
    __int128 v18 = 0u;
    id v10 = [v9 countByEnumeratingWithState:&v17 objects:v21 count:16];
    if (v10)
    {
      id v11 = v10;
      uint64_t v12 = 0LL;
      uint64_t v13 = *(void *)v18;
      uint64_t v14 = ASAttributeUnarchivedSize;
      do
      {
        for (uint64_t i = 0LL; i != v11; uint64_t i = (char *)i + 1)
        {
          if (*(void *)v18 != v13) {
            objc_enumerationMutation(v9);
          }
          id v16 = *(void **)(*((void *)&v17 + 1) + 8LL * (void)i);
          if (objc_msgSend(v16, "_es_isInstalled"))
          {
            buf[0] = 0;
            (*(void (**)(uint64_t, void *, uint8_t *))(a2 + 16))(a2, v16, buf);
            if (buf[0]) {
              return +[NSNumber numberWithLongLong:](&OBJC_CLASS___NSNumber, "numberWithLongLong:", v12);
            }
            v12 += (uint64_t)objc_msgSend( objc_msgSend(objc_msgSend(v16, "attributes"), "objectForKey:", v14),  "longLongValue");
          }
        }

        id v11 = [v9 countByEnumeratingWithState:&v17 objects:v21 count:16];
      }

      while (v11);
    }

    else
    {
      uint64_t v12 = 0LL;
    }

    return +[NSNumber numberWithLongLong:](&OBJC_CLASS___NSNumber, "numberWithLongLong:", v12);
  }

void sub_10004371C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

void sub_100043734(uint64_t a1, void *a2, _BYTE *a3)
{
  id v6 = (os_log_s *)RXOSLog();
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)std::string buf = 138412290;
    uint64_t v13 = a2;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "Purging asset for CacheDelete: %@", buf, 0xCu);
  }

  id v7 = [a2 purgeSync];
  if (v7)
  {
    id v11 = +[NSNumber numberWithInteger:](&OBJC_CLASS___NSNumber, "numberWithInteger:", v7, @"MAPurgeResult");
    *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 4sub_10003A5DC((uint64_t)va, 0LL) = +[NSError errorWithDomain:code:userInfo:]( &OBJC_CLASS___NSError,  "errorWithDomain:code:userInfo:",  @"kRXAssetDownloadErrorDomain",  102LL,  +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v11,  &v10,  1LL));
    double v8 = (os_log_s *)RXOSLog();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      id v9 = *(void **)(*(void *)(*(void *)(a1 + 32) + 8LL) + 40LL);
      *(_DWORD *)std::string buf = 138412290;
      uint64_t v13 = v9;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "Purging failed: %@", buf, 0xCu);
    }

    *a3 = 1;
  }

void sub_1000438F0(_Unwind_Exception *a1)
{
}

void sub_10004394C(_Unwind_Exception *a1)
{
}

void sub_1000439A8(_Unwind_Exception *a1)
{
}

void sub_100043EB4(_Unwind_Exception *exception_object)
{
}

void RDDummyPeer::RDDummyPeer(RDDummyPeer *this, _xpc_connection_s *a2)
{
  *uint64_t v3 = off_1000CFA98;
  void v3[6] = 0LL;
  v3[5] = v3 + 6;
  v3[8] = 0LL;
  v3[7] = 0LL;
  v3[9] = 0LL;
  v3[10] = 0LL;
  id v4 = dispatch_source_create( (dispatch_source_type_t)&_dispatch_source_type_timer,  0LL,  0LL,  (dispatch_queue_t)gRDServerQueue);
  *((void *)this + 12) = v4;
  handler[0] = _NSConcreteStackBlock;
  handler[1] = 0x40000000LL;
  handler[2] = sub_1000441E4;
  handler[3] = &unk_1000CFB18;
  handler[4] = this;
  dispatch_source_set_event_handler(v4, handler);
  dispatch_source_set_timer(*((dispatch_source_t *)this + 12), 0xFFFFFFFFFFFFFFFFLL, 0LL, 0LL);
  dispatch_resume(*((dispatch_object_t *)this + 12));
  RDPeer::ServerIsRunning(this, 1);
}

void sub_1000441B0(_Unwind_Exception *a1)
{
  id v4 = v3;
  id v6 = *v4;
  if (*v4)
  {
    *(void *)(v1 + 72) = v6;
    operator delete(v6);
  }

  sub_10001A7A8(v2, *(void **)(v1 + 48));
  RDPeer::~RDPeer((RDPeer *)v1);
  _Unwind_Resume(a1);
}

void sub_1000441E4(uint64_t a1)
{
}

void RDDummyPeer::SimulateRecognition(RDDummyPeer *this)
{
  if (*((void *)this + 9) != *((void *)this + 8))
  {
    unint64_t v9 = *(void *)(*((void *)this + 8)
                   + 8 * (random() % (unint64_t)((uint64_t)(*((void *)this + 9) - *((void *)this + 8)) >> 3)));
    p_uint64_t int64 = &v9;
    uint64_t v2 = sub_100019C58((uint64_t **)this + 5, &v9, (uint64_t)&unk_1000AC3E6, (uint64_t **)&p_uint64);
    uint64_t v3 = (void *)v2[5];
    if (v3)
    {
      uint64_t int64 = xpc_dictionary_get_uint64((xpc_object_t)v2[5], kRDKeyLanguageModel);
      p_uint64_t int64 = &uint64;
      id v4 = (void *)sub_100019C58((uint64_t **)this + 5, &uint64, (uint64_t)&unk_1000AC3E6, (uint64_t **)&p_uint64)[5];
      if (v4)
      {
        xpc_object_t v5 = xpc_dictionary_create(0LL, 0LL, 0LL);
        xpc_dictionary_set_int64(v5, kRDKeyMessage, 200LL);
        xpc_dictionary_set_uint64(v5, kRDKeyEpoch, *((void *)this + 11));
        xpc_object_t v6 = xpc_copy(v3);
        xpc_object_t v7 = RDDummyPeer::PickLanguageModel((uint64_t **)this, v4);
        xpc_dictionary_set_value(v6, kRDKeyLanguageModel, v7);
        xpc_release(v7);
        xpc_dictionary_set_value(v5, kRDKeyRecognizer, v6);
        xpc_release(v6);
        RDPeer::SendClientMessage(this, v5);
      }
    }

    RDDummyPeer::StartRecognition((dispatch_object_t *)this);
  }

void RDDummyPeer::~RDDummyPeer(dispatch_object_t *this)
{
  *this = (dispatch_object_t)off_1000CFA98;
  dispatch_release(this[12]);
  uint64_t v2 = this[8];
  if (v2)
  {
    this[9] = v2;
    operator delete(v2);
  }

  sub_10001A7A8((uint64_t)(this + 5), this[6]);
  RDPeer::~RDPeer((RDPeer *)this);
}

{
  void *v1;
  RDDummyPeer::~RDDummyPeer(this);
  operator delete(v1);
}

uint64_t RDDummyPeer::ClientUpdate(RDDummyPeer *this, void *a2)
{
  *((void *)this + 11) = xpc_dictionary_get_uint64(a2, kRDKeyEpoch);
  xpc_object_t value = xpc_dictionary_get_value(a2, kRDKeyObjects);
  if (value)
  {
    applier[0] = _NSConcreteStackBlock;
    applier[1] = 0x40000000LL;
    applier[2] = sub_100044558;
    applier[3] = &unk_1000CFB38;
    applier[4] = this;
    xpc_array_apply(value, applier);
  }

  xpc_object_t v5 = xpc_dictionary_get_value(a2, kRDKeyDead);
  if (v5)
  {
    xpc_object_t v6 = v5;
    size_t count = xpc_array_get_count(v5);
    if (count)
    {
      size_t v8 = count;
      size_t v9 = 0LL;
      uint64_t v10 = (xpc_object_t *)((char *)this + 48);
      do
      {
        uint64_t int64 = xpc_array_get_uint64(v6, v9);
        uint64_t v12 = *v10;
        if (*v10)
        {
          uint64_t v13 = (xpc_object_t *)((char *)this + 48);
          do
          {
            uint64_t v14 = v12[4];
            BOOL v15 = v14 >= uint64;
            else {
              id v16 = v12 + 1;
            }
            if (v15) {
              uint64_t v13 = (xpc_object_t *)v12;
            }
            uint64_t v12 = (void *)*v16;
          }

          while (*v16);
          if (v13 != v10 && uint64 >= (unint64_t)v13[4])
          {
            RDDummyPeer::CheckObjectInUse(this, uint64);
            xpc_release(v13[5]);
            sub_10002F254((uint64_t **)this + 5, (uint64_t *)v13);
            operator delete(v13);
          }
        }

        ++v9;
      }

      while (v9 != v8);
    }
  }

  dispatch_suspend(*((dispatch_object_t *)this + 12));
  uint64_t v17 = RDDummyPeer::ScanRecognizers(this);
  RDDummyPeer::StartRecognition((dispatch_object_t *)this);
  dispatch_resume(*((dispatch_object_t *)this + 12));
  return v17;
}

uint64_t sub_100044558(uint64_t a1, int a2, xpc_object_t xdict)
{
  uint64_t v4 = *(void *)(a1 + 32);
  uint64_t int64 = xpc_dictionary_get_uint64(xdict, kRDKeyObjectID);
  uint64_t v13 = uint64;
  xpc_object_t v6 = *(void **)(v4 + 48);
  if (v6)
  {
    xpc_object_t v7 = (void *)(v4 + 48);
    do
    {
      uint64_t v8 = v6[4];
      BOOL v9 = v8 >= uint64;
      else {
        uint64_t v10 = v6 + 1;
      }
      if (v9) {
        xpc_object_t v7 = v6;
      }
      xpc_object_t v6 = (void *)*v10;
    }

    while (*v10);
  }

  xpc_object_t v11 = xpc_retain(xdict);
  uint64_t v14 = &v13;
  sub_100019C58((uint64_t **)(v4 + 40), &v13, (uint64_t)&unk_1000AC3E6, (uint64_t **)&v14)[5] = (uint64_t)v11;
  return 1LL;
}

void RDDummyPeer::CheckObjectInUse(RDDummyPeer *this, uint64_t a2)
{
  uint64_t v2 = (char *)*((void *)this + 5);
  uint64_t v3 = (char *)this + 48;
  if (v2 != (char *)this + 48)
  {
    while (1)
    {
      if (*((void *)v2 + 4) != a2)
      {
        if (xpc_dictionary_get_uint64(*((xpc_object_t *)v2 + 5), kRDKeyLanguageModel) == a2
          || xpc_dictionary_get_uint64(*((xpc_object_t *)v2 + 5), kRDKeyVocabulary) == a2)
        {
          goto LABEL_17;
        }

        xpc_object_t value = xpc_dictionary_get_value(*((xpc_object_t *)v2 + 5), kRDKeyChildren);
        if (value)
        {
          xpc_object_t v6 = value;
          size_t count = xpc_array_get_count(value);
          if (count) {
            break;
          }
        }
      }

uint64_t RDDummyPeer::ScanRecognizers(RDDummyPeer *this)
{
  uint64_t v1 = (void **)((char *)this + 64);
  *((void *)this + 9) = *((void *)this + 8);
  uint64_t v2 = (char *)*((void *)this + 5);
  uint64_t v3 = (char *)this + 48;
  if (v2 == (char *)this + 48)
  {
    char v5 = 0;
  }

  else
  {
    char v5 = 0;
    xpc_object_t v6 = (char *)this + 80;
    do
    {
      if (xpc_dictionary_get_int64(*((xpc_object_t *)v2 + 5), kRDKeyObjectType) == 1)
      {
        if (xpc_dictionary_get_BOOL(*((xpc_object_t *)v2 + 5), kRDKeyIsListening))
        {
          size_t v8 = (char *)*((void *)this + 9);
          unint64_t v7 = *((void *)this + 10);
          if ((unint64_t)v8 >= v7)
          {
            uint64_t v10 = (char *)*v1;
            uint64_t v11 = (v8 - (_BYTE *)*v1) >> 3;
            unint64_t v12 = v11 + 1;
            uint64_t v13 = v7 - (void)v10;
            if (v13 >> 2 > v12) {
              unint64_t v12 = v13 >> 2;
            }
            else {
              unint64_t v14 = v12;
            }
            if (v14)
            {
              uint64_t v15 = (char *)sub_100018788((uint64_t)v6, v14);
              uint64_t v10 = (char *)*((void *)this + 8);
              size_t v8 = (char *)*((void *)this + 9);
            }

            else
            {
              uint64_t v15 = 0LL;
            }

            id v16 = &v15[8 * v11];
            *(void *)id v16 = *((void *)v2 + 4);
            size_t v9 = v16 + 8;
            while (v8 != v10)
            {
              uint64_t v17 = *((void *)v8 - 1);
              v8 -= 8;
              *((void *)v16 - 1) = v17;
              v16 -= 8;
            }

            *((void *)this + _Block_object_dispose(va, 8) = v16;
            *((void *)this + 9) = v9;
            *((void *)this + 1RDString::RDString((RDString *)&v66, theString, 0) = &v15[8 * v14];
            if (v10) {
              operator delete(v10);
            }
          }

          else
          {
            *(void *)size_t v8 = *((void *)v2 + 4);
            size_t v9 = v8 + 8;
          }

          *((void *)this + 9) = v9;
        }

        char v5 = 1;
      }

      __int128 v18 = (char *)*((void *)v2 + 1);
      if (v18)
      {
        do
        {
          __int128 v19 = v18;
          __int128 v18 = *(char **)v18;
        }

        while (v18);
      }

      else
      {
        do
        {
          __int128 v19 = (char *)*((void *)v2 + 2);
          BOOL v20 = *(void *)v19 == (void)v2;
          uint64_t v2 = v19;
        }

        while (!v20);
      }

      uint64_t v2 = v19;
    }

    while (v19 != v3);
  }

  return v5 & 1;
}

void RDDummyPeer::StartRecognition(dispatch_object_t *this)
{
  if (this[9] == this[8])
  {
    dispatch_time_t v4 = -1LL;
  }

  else
  {
    uint64_t v2 = random();
    uint64_t v3 = ((unint64_t)(1000000000 * v2) * (unsigned __int128)0x200000005uLL) >> 64;
    dispatch_time_t v4 = dispatch_time(0LL, ((v3 + ((unint64_t)(1000000000 * v2 - v3) >> 1)) >> 30) + 200000000);
  }

  dispatch_source_set_timer((dispatch_source_t)this[12], v4, 0x7FFFFFFFFFFFFFFFuLL, 0xF4240uLL);
  dispatch_resume(this[12]);
}

xpc_object_t RDDummyPeer::PickLanguageModel(uint64_t **this, void *a2)
{
  xpc_object_t v4 = xpc_dictionary_create(0LL, 0LL, 0LL);
  char v5 = kRDKeyObjectType;
  xpc_object_t value = xpc_dictionary_get_value(a2, kRDKeyObjectType);
  xpc_dictionary_set_value(v4, v5, value);
  unint64_t v7 = kRDKeyObjectID;
  xpc_object_t v8 = xpc_dictionary_get_value(a2, kRDKeyObjectID);
  xpc_dictionary_set_value(v4, v7, v8);
  int64_t int64 = xpc_dictionary_get_int64(a2, kRDKeyObjectType);
  switch(int64)
  {
    case 10LL:
      xpc_object_t v17 = xpc_dictionary_get_value(a2, kRDKeyChildren);
      xpc_object_t v18 = xpc_copy(v17);
      size_t count = xpc_array_get_count(v18);
      unint64_t v20 = random();
      __str.__r_.__value_.__r.__words[0] = xpc_array_get_uint64(v18, v20 % count);
      v35.__r_.__value_.__r.__words[0] = (std::string::size_type)&__str;
      id v21 = sub_100019C58(this + 5, (unint64_t *)&__str, (uint64_t)&unk_1000AC3E6, (uint64_t **)&v35);
      double v22 = (void *)RDDummyPeer::PickLanguageModel((RDDummyPeer *)this, (void *)v21[5]);
      v35.__r_.__value_.__r.__words[0] = (std::string::size_type)v22;
      if (v18)
      {
        xpc_release(v18);
        xpc_object_t v23 = xpc_array_create((xpc_object_t *)&v35.__r_.__value_.__l.__data_, 1uLL);
        double v22 = (void *)v35.__r_.__value_.__r.__words[0];
      }

      else
      {
        xpc_object_t v23 = 0LL;
      }

      xpc_release(v22);
      xpc_dictionary_set_value(v4, kRDKeyChildren, v23);
      uint64_t v31 = v23;
LABEL_33:
      xpc_release(v31);
      return v4;
    case 11LL:
      xpc_object_t v24 = xpc_dictionary_get_value(a2, kRDKeyChildren);
      xpc_object_t v25 = xpc_copy(v24);
      size_t v26 = xpc_array_get_count(v25);
      if (v26)
      {
        size_t v27 = v26;
        for (size_t i = 0LL; i != v27; ++i)
        {
          __str.__r_.__value_.__r.__words[0] = xpc_array_get_uint64(v25, i);
          v35.__r_.__value_.__r.__words[0] = (std::string::size_type)&__str;
          float v29 = sub_100019C58(this + 5, (unint64_t *)&__str, (uint64_t)&unk_1000AC3E6, (uint64_t **)&v35);
          id v30 = (void *)RDDummyPeer::PickLanguageModel((RDDummyPeer *)this, (void *)v29[5]);
          xpc_array_set_value(v25, i, v30);
          xpc_release(v30);
        }
      }

      xpc_dictionary_set_value(v4, kRDKeyChildren, v25);
      uint64_t v31 = v25;
      goto LABEL_33;
    case 13LL:
      memset(&v35, 0, sizeof(v35));
      unsigned int v10 = random();
      if ((v10 & 1) != 0) {
        uint64_t v11 = "yada";
      }
      else {
        uint64_t v11 = "blah";
      }
      sub_10000A2DC(&__str, v11);
      std::string::operator=(&v35, &__str);
      sub_100044D3C(32, (const void **)&__str.__r_.__value_.__l.__data_, (uint64_t)&v33);
      std::string __str = v33;
      int v12 = (v10 >> 1) & 7;
      if (v12)
      {
        int v13 = v12 + 1;
        do
        {
          if ((__str.__r_.__value_.__s.__size_ & 0x80u) == 0) {
            p_str = &__str;
          }
          else {
            p_str = (std::string *)__str.__r_.__value_.__r.__words[0];
          }
          if ((__str.__r_.__value_.__s.__size_ & 0x80u) == 0) {
            std::string::size_type size = __str.__r_.__value_.__s.__size_;
          }
          else {
            std::string::size_type size = __str.__r_.__value_.__l.__size_;
          }
          std::string::append(&v35, (const std::string::value_type *)p_str, size);
          --v13;
        }

        while (v13 > 1);
      }

      if ((v35.__r_.__value_.__s.__size_ & 0x80u) == 0) {
        id v16 = &v35;
      }
      else {
        id v16 = (std::string *)v35.__r_.__value_.__r.__words[0];
      }
      xpc_dictionary_set_string(v4, kRDKeyText, (const char *)v16);
      break;
  }

  return v4;
}

void sub_100044D00( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, void *a19, uint64_t a20, int a21, __int16 a22, char a23, char a24)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  if (a24 < 0) {
    operator delete(a19);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100044D3C@<X0>(char a1@<W0>, const void **a2@<X1>, uint64_t a3@<X8>)
{
  else {
    size_t v5 = (size_t)a2[1];
  }
  uint64_t result = sub_100037608(a3, v5 + 1);
  else {
    unint64_t v7 = *(_BYTE **)result;
  }
  *unint64_t v7 = a1;
  xpc_object_t v8 = v7 + 1;
  if (v5)
  {
    else {
      size_t v9 = *a2;
    }
    uint64_t result = (uint64_t)memmove(v8, v9, v5);
  }

  *((_BYTE *)v8 + v5) = 0;
  return result;
}

RDDummyPeer *RDCreateDummyPeer(_xpc_connection_s *a1)
{
  uint64_t v2 = (RDDummyPeer *)operator new(0x68uLL);
  RDDummyPeer::RDDummyPeer(v2, a1);
  return v2;
}

void sub_100044DFC(_Unwind_Exception *a1)
{
}

RDSpeechDonation *RDSpeechDonationInit(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t v7 = -[NSLocale initWithLocaleIdentifier:](objc_alloc(&OBJC_CLASS___NSLocale), "initWithLocaleIdentifier:", a3);
  xpc_object_t v8 = -[RDSpeechDonation initWithBundleID:donorReferenceID:locale:taskHint:]( objc_alloc(&OBJC_CLASS___RDSpeechDonation),  "initWithBundleID:donorReferenceID:locale:taskHint:",  a1,  a2,  v7,  a4);

  return v8;
}

id RDspeechDonationAddAudioSamples(void *a1, uint64_t a2, uint64_t a3)
{
  return _[a1 addAudioSamples:a2 count:a3];
}

id RDspeechDonationDonateAudioForTranscription(void *a1, uint64_t a2, uint64_t a3)
{
  return _[a1 donateAudioFor:a2 logAudioFile:a3];
}

void RDQSRKeywordChanged(void)
{
  if (RDQSREngine::sInstance) {
    RDQSREngine::BuildCombinedGrammar((RDQSREngine *)RDQSREngine::sInstance);
  }
}

void RDQSRPeer::RDQSRPeer(RDQSRPeer *this, _xpc_connection_s *a2, void *a3, uint64_t a4, RDAudioObject *a5)
{
  *(void *)(v9 + 4_Block_object_dispose(va, 8) = 0LL;
  *(void *)(v9 + 4RDString::RDString((RDString *)&v66, theString, 0) = v9 + 48;
  *(void *)uint64_t v9 = &off_1000CFB80;
  *(void *)(v9 + ++*(void *)(result + 56) = 0LL;
  *(void *)(v9 + 72) = 0LL;
  *(void *)(v9 + 64) = v9 + 72;
  *(void *)(v9 + 8RDString::RDString((RDString *)&v66, theString, 0) = 0LL;
  *(void *)(v9 + 96) = 0LL;
  *(void *)(v9 + 8_Block_object_dispose(va, 8) = v9 + 96;
  *(void *)(v9 + 12RDString::RDString((RDString *)&v66, theString, 0) = 0LL;
  *(void *)(v9 + 104) = 0LL;
  *(void *)(v9 + 112) = v9 + 120;
  *(void *)(v9 + 12_Block_object_dispose(va, 8) = 0LL;
  *(_OWORD *)(v9 + 136) = 0u;
  *(_OWORD *)(v9 + 152) = 0u;
  *(_DWORD *)(v9 + 16_Block_object_dispose(va, 8) = 1065353216;
  *(void *)(v9 + 176) = 0LL;
  *(_BYTE *)(v9 + 20RDString::RDString((RDString *)&v66, theString, 0) = 0;
  *(_BYTE *)(v9 + 201) = a5 != 0LL;
  *(_DWORD *)(v9 + 202) = 256;
  *(_BYTE *)(v9 + 206) = 0;
  *(void *)(v9 + 216) = a3;
  *(void *)(v9 + 2++*(void *)(result + 24) = a5;
  *(void *)(v9 + 232) = 0LL;
  *(void *)(v9 + 24RDString::RDString((RDString *)&v66, theString, 0) = 0LL;
  xpc_retain(a3);
  block[0] = _NSConcreteStackBlock;
  block[1] = 0x40000000LL;
  block[2] = sub_10004504C;
  block[3] = &unk_1000CFC00;
  void block[4] = this;
  void block[5] = a3;
  void block[6] = a4;
  dispatch_async((dispatch_queue_t)gRDServerQueue, block);
  if ((a4 & 8) != 0) {
    *((_BYTE *)this + 206) = 1;
  }
}

void sub_100045000(_Unwind_Exception *a1)
{
}

void sub_10004504C(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (RDQSREngine::Instantiate(*(RDQSREngine **)(a1 + 40), *(void **)(a1 + 48)))
  {
    RDPeer::ServerIsRunning((RDPeer *)v2, 1);
    if (_os_feature_enabled_impl("VoiceControl", "use_phonetic_corrections"))
    {
      if ((*(_BYTE *)(a1 + 48) & 8) != 0)
      {
        string_ptr = xpc_string_get_string_ptr(*(xpc_object_t *)(v2 + 216));
        uint64_t v4 = (const __CFString *)RDQSREngine::fullModelDir((RDQSREngine *)RDQSREngine::sInstance);
        CStringPtr = CFStringGetCStringPtr(v4, 0x8000100u);
        *(void *)(v2 + 24RDString::RDString((RDString *)&v66, theString, 0) = SRSSPhoneticCheckerCreate(string_ptr, CStringPtr);
      }
    }
  }

  else
  {
    RDPeer::ServerIsRunning((RDPeer *)v2, 0);
    uint64_t v6 = *(_xpc_connection_s **)(v2 + 8);
    if (v6) {
      xpc_connection_cancel(v6);
    }
  }

void RDQSRPeer::Terminate(RDQSRPeer *this)
{
  if (*((_BYTE *)this + 204))
  {
    dispatch_queue_global_t global_queue = dispatch_get_global_queue(0LL, 0LL);
    dispatch_async(global_queue, &stru_1000CFC40);
  }

  else
  {
    *((void *)this + 1) = 0LL;
    block[0] = _NSConcreteStackBlock;
    block[1] = 0x40000000LL;
    block[2] = sub_1000451C8;
    block[3] = &unk_1000CFCA0;
    void block[4] = this;
    dispatch_async((dispatch_queue_t)gRDServerQueue, block);
  }

void sub_10004518C(id a1)
{
}

void sub_1000451B4(id a1)
{
}

uint64_t sub_1000451C8(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 32);
  if (result) {
    return (*(uint64_t (**)(uint64_t))(*(void *)result + 120LL))(result);
  }
  return result;
}

void RDQSRPeer::~RDQSRPeer(xpc_object_t *this)
{
  *this = &off_1000CFB80;
  xpc_release(this[27]);
  uint64_t v2 = (RDQSREngine *)RDQSREngine::sInstance;
  uint64_t v3 = (RDQSRPeer *)this[14];
  if (v3 != (RDQSRPeer *)(this + 15))
  {
    do
    {
      RDQSREngine::RemoveGrammar(v2, *(void *)(*((void *)v3 + 4) + 16LL));
      uint64_t v4 = (void *)*((void *)v3 + 4);
      if (v4)
      {
        uint64_t v5 = v4[5];
        v4[5] = 0LL;
        if (v5) {
          sub_100034D1C((uint64_t)(v4 + 5), v5);
        }
        operator delete(v4);
      }

      uint64_t v6 = (RDQSRPeer *)*((void *)v3 + 1);
      if (v6)
      {
        do
        {
          unint64_t v7 = v6;
          uint64_t v6 = *(RDQSRPeer **)v6;
        }

        while (v6);
      }

      else
      {
        do
        {
          unint64_t v7 = (RDQSRPeer *)*((void *)v3 + 2);
          BOOL v8 = *(void *)v7 == (void)v3;
          uint64_t v3 = v7;
        }

        while (!v8);
      }

      uint64_t v3 = v7;
    }

    while (v7 != (RDQSRPeer *)(this + 15));
  }

  uint64_t v9 = (RDAudioObject *)this[28];
  if (v9)
  {
    RDAudioObject::~RDAudioObject(v9);
    operator delete(v10);
  }

  if (*((_BYTE *)this + 206) && v2) {
    RDQSREngine::removeLogAudioFile(v2);
  }
  xpc_object_t v11 = this[30];
  if (v11)
  {
    CFRelease(v11);
    this[30] = 0LL;
  }

  if (*((_BYTE *)this + 200)) {
    RDQSREngine::RemovePeer(v2, (uint64_t)this);
  }
  sub_10004750C((uint64_t)(this + 17));
  sub_10001A7A8((uint64_t)(this + 14), this[15]);
  sub_10001A7A8((uint64_t)(this + 11), this[12]);
  sub_10001A7A8((uint64_t)(this + 8), this[9]);
  sub_10001A7A8((uint64_t)(this + 5), this[6]);
  RDPeer::~RDPeer((RDPeer *)this);
}

{
  void *v1;
  RDQSRPeer::~RDQSRPeer(this);
  operator delete(v1);
}

void RDQSRPeer::UpdateOrReleaseObject(RDQSRPeer *this, unint64_t *a2, xpc_object_t xdict)
{
  __int128 v60 = a2;
  if (!*((void *)this + 1)) {
    return;
  }
  uint64_t v6 = (void *)*((void *)this + 6);
  unint64_t v7 = (uint64_t **)((char *)this + 40);
  if (v6)
  {
    BOOL v8 = (char *)this + 48;
    do
    {
      unint64_t v9 = v6[4];
      BOOL v10 = v9 >= (unint64_t)a2;
      else {
        xpc_object_t v11 = v6 + 1;
      }
      if (v10) {
        BOOL v8 = (char *)v6;
      }
      uint64_t v6 = (void *)*v11;
    }

    while (*v11);
    if (v8 != (char *)this + 48 && *((void *)v8 + 4) <= (unint64_t)a2)
    {
      int v12 = (void *)*((void *)v8 + 5);
      if (v12)
      {
        xpc_type_t type = xpc_get_type(v12);
        if (type != (xpc_type_t)&_xpc_type_dictionary)
        {
          xpc_type_t v14 = type;
          uint64_t v15 = (os_log_s *)RXOSLog();
          if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)std::string buf = 138412290;
            *(void *)&uint8_t buf[4] = v14;
            _os_log_impl( (void *)&_mh_execute_header,  v15,  OS_LOG_TYPE_ERROR,  "API misuse while updating objects : XPC_TYPE_DICTIONARY expected, passed %@ ",  buf,  0xCu);
          }

          return;
        }

        if (xpc_dictionary_get_int64(*((xpc_object_t *)v8 + 5), kRDKeyObjectType) == 1)
        {
          if (xdict)
          {
            if (xpc_dictionary_get_BOOL(xdict, kRDKeyIsListening))
            {
              std::string v33 = (os_log_s *)RXOSLog();
              if (os_log_type_enabled(v33, OS_LOG_TYPE_DEBUG))
              {
                *(_DWORD *)std::string buf = 134217984;
                *(void *)&uint8_t buf[4] = a2;
                _os_log_impl( (void *)&_mh_execute_header,  v33,  OS_LOG_TYPE_DEBUG,  "Activating recognizer %llu",  buf,  0xCu);
              }
            }

LABEL_69:
            xpc_release(*((xpc_object_t *)v8 + 5));
LABEL_82:
            *((void *)v8 + 5) = xpc_retain(xdict);
            return;
          }

          sub_10002F1DC((uint64_t)this + 64, (unint64_t *)&v60);
        }

        else
        {
          if (xpc_dictionary_get_BOOL(*((xpc_object_t *)v8 + 5), kRDKeyTopLevelLM))
          {
            *(_OWORD *)std::string buf = (unint64_t)a2;
            uint64_t v64 = 0LL;
            uint64_t v65 = 0LL;
            char v66 = 1;
            uint64_t v67 = 0LL;
            v59[0] = (unint64_t *)buf;
            __int16 v40 = (uint64_t *)sub_100047584((uint64_t)this + 112, v59);
            unint64_t v41 = v40;
            if ((uint64_t *)((char *)this + 120) == v40)
            {
              if (xdict)
              {
                std::string::size_type v51 = operator new(0x48uLL);
                *std::string::size_type v51 = v60;
                v51[1] = 0LL;
                uint64_t v51[3] = this;
                v51[5] = 0LL;
                *((_BYTE *)v51 + 4_Block_object_dispose(va, 8) = 1;
                v51[8] = 0LL;
                uint64_t v62 = v51;
                sub_1000475DC((uint64_t **)this + 14, &v62, (uint64_t *)&v62);
                uint64_t v52 = RDQSREngine::AddGrammar(RDQSREngine::sInstance, (uint64_t)v62);
                v62[2] = v52;
                BOOL v61 = v60;
                sub_10004769C((uint64_t)v59, (unint64_t *)&v61, 1LL);
                RDQSRPeer::updateLMCache((uint64_t)this, xdict, (uint64_t)v59);
                sub_10001A7A8((uint64_t)v59, v59[1]);
              }
            }

            else if (xdict)
            {
              *(_BYTE *)(v40[4] + 4_Block_object_dispose(va, 8) = 1;
            }

            else
            {
              RDQSREngine::RemoveGrammar((RDQSREngine *)RDQSREngine::sInstance, *(void *)(v40[4] + 16));
              int v53 = (void *)v41[4];
              if (v53)
              {
                uint64_t v54 = v53[5];
                v53[5] = 0LL;
                if (v54) {
                  sub_100034D1C((uint64_t)(v53 + 5), v54);
                }
                operator delete(v53);
              }

              sub_10002F254((uint64_t **)this + 14, v41);
              operator delete(v41);
            }

            uint64_t v55 = v65;
            uint64_t v65 = 0LL;
            if (v55) {
              sub_100034D1C((uint64_t)&v65, v55);
            }
            xpc_release(*((xpc_object_t *)v8 + 5));
            if (xdict) {
              goto LABEL_82;
            }
            goto LABEL_83;
          }

          if (xdict)
          {
            unint64_t int64 = xpc_dictionary_get_int64(xdict, kRDKeyObjectType);
            goto LABEL_69;
          }
        }

        xpc_release(*((xpc_object_t *)v8 + 5));
LABEL_83:
        size_t v56 = (void *)((char *)this + 136);
        uint64_t v57 = sub_10001AA0C(v56, (unint64_t *)&v60);
        if (v57) {
          sub_100047944(v56, v57);
        }
        sub_10002F254(v7, (uint64_t *)v8);
        operator delete(v8);
        return;
      }
    }
  }

  if (xdict)
  {
    int64_t v16 = xpc_dictionary_get_int64(xdict, kRDKeyObjectType);
    if (v16)
    {
      int64_t v17 = v16;
      *(void *)std::string buf = a2;
      *(void *)&uint8_t buf[8] = xpc_retain(xdict);
      sub_100047B08(v7, (unint64_t *)buf, (uint64_t *)buf);
      if (v17 == 1)
      {
        xpc_object_t v18 = (os_log_s *)RXOSLog();
        if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)std::string buf = 134217984;
          *(void *)&uint8_t buf[4] = v60;
          _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEBUG, "Adding new recognizer %llu", buf, 0xCu);
        }

        sub_10002F044((uint64_t **)this + 8, (unint64_t *)&v60, (uint64_t *)&v60);
      }

      else if (xpc_dictionary_get_BOOL(xdict, kRDKeyTopLevelLM))
      {
        float v29 = operator new(0x48uLL);
        void *v29 = v60;
        v29[1] = 0LL;
        uint64_t v29[3] = this;
        v29[5] = 0LL;
        *((_BYTE *)v29 + 4_Block_object_dispose(va, 8) = 1;
        v29[8] = 0LL;
        v59[0] = v29;
        sub_1000475DC((uint64_t **)this + 14, v59, (uint64_t *)v59);
        uint64_t v30 = RDQSREngine::AddGrammar(RDQSREngine::sInstance, (uint64_t)v59[0]);
        v59[0][2] = v30;
        uint64_t v62 = v60;
        sub_10004769C((uint64_t)buf, (unint64_t *)&v62, 1LL);
        RDQSRPeer::updateLMCache((uint64_t)this, xdict, (uint64_t)buf);
        sub_10001A7A8((uint64_t)buf, *(void **)&buf[8]);
      }
    }

    else
    {
      xpc_object_t value = xpc_dictionary_get_value(xdict, kRDKeyURL);
      if (value)
      {
        unint64_t v20 = value;
        bytes_ptr = (const UInt8 *)xpc_data_get_bytes_ptr(value);
        size_t length = xpc_data_get_length(v20);
        xpc_object_t v23 = CFDataCreateWithBytesNoCopy(kCFAllocatorDefault, bytes_ptr, length, kCFAllocatorNull);
        if (v23)
        {
          xpc_object_t v24 = v23;
          xpc_object_t v25 = CFURLCreateByResolvingBookmarkData(kCFAllocatorDefault, v23, 0x100uLL, 0LL, 0LL, 0LL, 0LL);
          if (v25)
          {
            id v28 = v25;
            RDQSREngine::UseFileAudio((RDQSREngine *)RDQSREngine::sInstance, v25, v26, v27);
            CFURLStopAccessingSecurityScopedResource(v28);
            CFRelease(v28);
          }

          CFRelease(v24);
        }
      }

      else
      {
        uint64_t v31 = (RDQSRSoundSource *)xpc_dictionary_get_value(xdict, kRDKeyAudioData);
        if (v31)
        {
          RDQSREngine::UseCannedAudio((RDQSREngine *)RDQSREngine::sInstance, v31, v32);
        }

        else if (*((void *)this + 28))
        {
          if (RXAutomationModeResult() || RXAutomationModeSynthesis() || RXAutomationModeFileName())
          {
            std::string v35 = (RDQSREngine *)RDQSREngine::sInstance;
            uint64_t v36 = (void (*)(RDQSRSoundSource *))RXAutomationSimulateOpenMic();
            RDQSREngine::UseMixedAudio(v35, v36);
          }

          else
          {
            RDQSREngine::UseLiveAudio((RDQSREngine *)RDQSREngine::sInstance, *((RDAudioObject **)this + 28), v34);
          }
        }
      }

      xpc_object_t v37 = xpc_dictionary_get_value(xdict, kRDKeyTextToBeRecognized);
      if (v37)
      {
        string_ptr = xpc_string_get_string_ptr(v37);
        CFStringRef v39 = CFStringCreateWithCString(0LL, string_ptr, 0x8000100u);
        if (RXAutomationModeResult())
        {
          RDQSREngine::RecognizeText((RDQSREngine *)RDQSREngine::sInstance, v39);
        }

        else if (RXAutomationModeSynthesis())
        {
          RDQSREngine::SynthesizeText((RDQSREngine *)RDQSREngine::sInstance, v39);
        }

        else if (RXAutomationModeFileName())
        {
          RDQSREngine::RecognizeAudioFile((RDQSREngine *)RDQSREngine::sInstance, v39);
        }

        else
        {
          char v42 = (os_log_s *)RXOSLog();
          if (os_log_type_enabled(v42, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)std::string buf = 0;
            _os_log_impl((void *)&_mh_execute_header, v42, OS_LOG_TYPE_ERROR, "Unknown Audio mode specified", buf, 2u);
          }
        }

        if (v39) {
          CFRelease(v39);
        }
      }

      xpc_object_t v43 = xpc_dictionary_get_value(xdict, kRDKeyFilterProfanity);
      if (v43)
      {
        int v44 = *((unsigned __int8 *)this + 205);
        if (v44 != xpc_BOOL_get_value(v43))
        {
          int v45 = *((unsigned __int8 *)this + 205) ^ 1;
          *((_BYTE *)this + 205) ^= 1u;
          RDQSREngine::FilterProfanity((void **)RDQSREngine::sInstance, v45);
        }
      }

      xpc_object_t v46 = xpc_dictionary_get_value(xdict, kRDKeyIsListening);
      if (v46)
      {
        *((_BYTE *)this + 202) = 1;
        int v47 = *((unsigned __int8 *)this + 203);
        if (v47 != xpc_BOOL_get_value(v46))
        {
          char v48 = *((_BYTE *)this + 203) ^ 1;
          *((_BYTE *)this + 203) = v48;
          RDQSREngine::CanListen((RDQSREngine *)RDQSREngine::sInstance, this, v48);
          dispatch_time_t v49 = dispatch_time(0LL, 1000000000LL);
          v58[0] = _NSConcreteStackBlock;
          v58[1] = 0x40000000LL;
          v58[2] = sub_10004613C;
          void v58[3] = &unk_1000CFCC0;
          v58[4] = this;
          dispatch_after(v49, (dispatch_queue_t)gRDServerQueue, v58);
        }
      }

      *((void *)this + 23) = xpc_dictionary_get_uint64(xdict, kRDKeyObjectID);
      *((void *)this + ++*(void *)(result + 24) = xpc_dictionary_get_uint64(xdict, kRDKeyCallbacks);
    }
  }

void sub_100045B6C( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, char a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26)
{
  if (a26) {
    sub_100034D1C(v26, a26);
  }
  _Unwind_Resume(exception_object);
}

void RDQSRPeer::updateLMCache(uint64_t a1, void *a2, uint64_t a3)
{
  xpc_type_t type = xpc_get_type(a2);
  if (type != (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_type_t v7 = type;
    BOOL v8 = (os_log_s *)RXOSLog();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)std::string buf = 138412290;
      *(void *)&uint8_t buf[4] = v7;
      _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_FAULT,  "API misuse while updating LM : XPC_TYPE_DICTIONARY expected, passed %@ ",  buf,  0xCu);
    }

    return;
  }

  if ((xpc_dictionary_get_int64(a2, kRDKeyObjectType) & 0xFFFFFFFFFFFFFFFELL) == 0xA)
  {
    xpc_object_t value = xpc_dictionary_get_value(a2, kRDKeyChildren);
    size_t count = xpc_array_get_count(value);
    if (count)
    {
      size_t v11 = count;
      size_t v12 = 0LL;
      while (1)
      {
        uunint64_t int64 = xpc_array_get_uint64(value, v12);
        *(void *)std::string buf = &uint64;
        uint64_t v13 = sub_100019C58((uint64_t **)(a1 + 40), &uint64, (uint64_t)&unk_1000AC40B, (uint64_t **)buf)[5];
        xpc_type_t v14 = sub_10001AA0C((void *)(a1 + 136), &uint64);
        if (!v14 || v14[5] != *(void *)(a3 + 16)) {
          goto LABEL_24;
        }
        uint64_t v15 = (void *)v14[3];
        if (v15 != v14 + 4) {
          break;
        }
LABEL_25:
        if (++v12 == v11) {
          return;
        }
      }

      int64_t v16 = *(void **)a3;
      while (v15[4] == v16[4])
      {
        int64_t v17 = (void *)v15[1];
        xpc_object_t v18 = v15;
        if (v17)
        {
          do
          {
            uint64_t v15 = v17;
            int64_t v17 = (void *)*v17;
          }

          while (v17);
        }

        else
        {
          do
          {
            uint64_t v15 = (void *)v18[2];
            BOOL v19 = *v15 == (void)v18;
            xpc_object_t v18 = v15;
          }

          while (!v19);
        }

        unint64_t v20 = (void *)v16[1];
        if (v20)
        {
          do
          {
            id v21 = v20;
            unint64_t v20 = (void *)*v20;
          }

          while (v20);
        }

        else
        {
          do
          {
            id v21 = (void *)v16[2];
            BOOL v19 = *v21 == (void)v16;
            int64_t v16 = v21;
          }

          while (!v19);
        }

        int64_t v16 = v21;
        if (v15 == v14 + 4) {
          goto LABEL_25;
        }
      }

LABEL_24:
      *(void *)std::string buf = &uint64;
      double v22 = sub_100047BC0(a1 + 136, &uint64, (uint64_t)&unk_1000AC40B, (uint64_t **)buf);
      sub_1000463E4(v22 + 3, *(void **)a3, (void *)(a3 + 8));
      RDQSRPeer::updateLMCache(a1, v13, a3);
      goto LABEL_25;
    }
  }

void RDQSRPeer::checkAndUpdateLMCache(RDQSRPeer *this, xpc_object_t xdict)
{
  uunint64_t int64 = xpc_dictionary_get_uint64(xdict, kRDKeyObjectID);
  if (sub_10001AA0C((void *)this + 17, &uint64))
  {
    *(void *)unint64_t v20 = &uint64;
    uint64_t v3 = sub_100047BC0((uint64_t)this + 136, &uint64, (uint64_t)&unk_1000AC40B, (uint64_t **)v20);
    string = xpc_dictionary_get_string(xdict, kRDKeyCategoryID);
    uint64_t v5 = (void *)v3[3];
    if (v5 != v3 + 4)
    {
      uint64_t v6 = (char *)string;
      do
      {
        *(_OWORD *)unint64_t v20 = (unint64_t)v5[4];
        uint64_t v21 = 0LL;
        uint64_t v22 = 0LL;
        char v23 = 1;
        uint64_t v24 = 0LL;
        *(void *)std::string buf = v20;
        xpc_type_t v7 = (void *)sub_100047584((uint64_t)this + 112, (unint64_t **)buf);
        if ((void *)((char *)this + 120) != v7)
        {
          if (v6)
          {
            sub_10000A2DC(buf, v6);
            BOOL doesSupportCategory = rd_userprofile_util::doesSupportCategory(buf);
            BOOL v9 = doesSupportCategory;
            if (v19 < 0)
            {
              operator delete(*(void **)buf);
              if (v9)
              {
LABEL_8:
                if (RXLogServerGrammar())
                {
                  BOOL v10 = (os_log_s *)RXOSLog();
                  if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
                  {
                    *(_DWORD *)std::string buf = 136315138;
                    *(void *)&uint8_t buf[4] = v6;
                    _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEFAULT,  "Updating category -> %s",  buf,  0xCu);
                  }
                }

                *(void *)(v7[4] + 64LL) = xdict;
                goto LABEL_14;
              }
            }

            else if (doesSupportCategory)
            {
              goto LABEL_8;
            }
          }

          *(_BYTE *)(v7[4] + 48LL) = 1;
        }

void sub_1000460F0( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27)
{
  if (a27) {
    sub_100034D1C(v27, a27);
  }
  _Unwind_Resume(exception_object);
}

void sub_10004613C(uint64_t a1)
{
  uint64_t v1 = *(RDQSRPeer **)(a1 + 32);
}

void RDQSRPeer::EndUtt(RDQSRPeer *this)
{
  if (*((_BYTE *)this + 202) && !*((_BYTE *)this + 203))
  {
    uint64_t v2 = (RDQSREngine *)RDQSREngine::sInstance;
    uint64_t v3 = (char *)*((void *)this + 11);
    uint64_t v15 = (char *)this + 88;
    uint64_t v4 = (char *)this + 96;
    if (v3 != (char *)this + 96)
    {
      uint64_t v5 = (char *)this + 120;
      do
      {
        v18[0] = *((void *)v3 + 4);
        v18[1] = 0LL;
        v18[3] = 0LL;
        uint64_t v19 = 0LL;
        char v20 = 1;
        uint64_t v21 = 0LL;
        __p[0] = v18;
        uint64_t v6 = sub_100047584((uint64_t)this + 112, (unint64_t **)__p);
        uint64_t v7 = v6;
        if (v5 != (char *)v6
          && xpc_dictionary_get_string(*(xpc_object_t *)(*(void *)(v6 + 32) + 32LL), kRDKeyCommandID))
        {
          string = (char *)xpc_dictionary_get_string(*(xpc_object_t *)(*(void *)(v7 + 32) + 32LL), kRDKeyCommandID);
          sub_10000A2DC(__p, string);
          BOOL v9 = (os_log_s *)RXOSLog();
          if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
          {
            BOOL v10 = __p;
            if (v17 < 0) {
              BOOL v10 = (void **)__p[0];
            }
            *(_DWORD *)std::string buf = 136315138;
            char v23 = v10;
            _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEBUG,  "Deactivate Grammar after End of utterance: CommandID -> %s",  buf,  0xCu);
          }

          if (v17 < 0) {
            operator delete(__p[0]);
          }
        }

        RDQSREngine::GrammarIsLive(v2, *(void *)(*(void *)(v7 + 32) + 16LL), 0);
        uint64_t v11 = v19;
        uint64_t v19 = 0LL;
        if (v11) {
          sub_100034D1C((uint64_t)&v19, v11);
        }
        size_t v12 = (char *)*((void *)v3 + 1);
        if (v12)
        {
          do
          {
            uint64_t v13 = v12;
            size_t v12 = *(char **)v12;
          }

          while (v12);
        }

        else
        {
          do
          {
            uint64_t v13 = (char *)*((void *)v3 + 2);
            BOOL v14 = *(void *)v13 == (void)v3;
            uint64_t v3 = v13;
          }

          while (!v14);
        }

        uint64_t v3 = v13;
      }

      while (v13 != v4);
    }

    sub_10001A7A8((uint64_t)v15, *((void **)this + 12));
    *((void *)this + 12) = 0LL;
    *((void *)this + 13) = 0LL;
    *((void *)this + 11) = v4;
    RDQSREngine::BuildCombinedGrammar(v2);
  }

void sub_10004639C( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24)
{
}

uint64_t *sub_1000463E4(uint64_t *result, void *a2, void *a3)
{
  if (a2 != a3)
  {
    uint64_t v4 = a2;
    uint64_t v5 = (uint64_t **)result;
    uint64_t v6 = result + 1;
    do
    {
      uint64_t result = sub_100047718(v5, v6, v4 + 4, v4 + 4);
      uint64_t v7 = (void *)v4[1];
      if (v7)
      {
        do
        {
          BOOL v8 = v7;
          uint64_t v7 = (void *)*v7;
        }

        while (v7);
      }

      else
      {
        do
        {
          BOOL v8 = (void *)v4[2];
          BOOL v9 = *v8 == (void)v4;
          uint64_t v4 = v8;
        }

        while (!v9);
      }

      uint64_t v4 = v8;
    }

    while (v8 != a3);
  }

  return result;
}

uint64_t RDQSRPeer::EngineIsRunning(RDQSRPeer *this)
{
  if (!*((_BYTE *)this + 200))
  {
    RDQSREngine::AddPeer(RDQSREngine::sInstance, (uint64_t)this);
    *((_BYTE *)this + 20RDString::RDString((RDString *)&v66, theString, 0) = 1;
  }

  return 1LL;
}

uint64_t RDQSRPeer::ClientUpdate(RDQSRPeer *this, xpc_object_t object)
{
  if (!*((_BYTE *)this + 200))
  {
    RDQSREngine::AddPeer(RDQSREngine::sInstance, (uint64_t)this);
    *((_BYTE *)this + 20RDString::RDString((RDString *)&v66, theString, 0) = 1;
  }

  RDPeer::ClientUpdate(this, object);
  *((void *)this + 22) = xpc_dictionary_get_uint64(object, kRDKeyEpoch);
  xpc_object_t value = xpc_dictionary_get_value(object, kRDKeyObjects);
  if (value)
  {
    applier[0] = _NSConcreteStackBlock;
    applier[1] = 0x40000000LL;
    applier[2] = sub_1000465B4;
    applier[3] = &unk_1000CFCE0;
    applier[4] = this;
    xpc_array_apply(value, applier);
  }

  xpc_object_t v5 = xpc_dictionary_get_value(object, kRDKeyDead);
  if (v5)
  {
    v7[0] = _NSConcreteStackBlock;
    v7[1] = 0x40000000LL;
    _OWORD v7[2] = sub_1000465FC;
    v7[3] = &unk_1000CFD00;
    void v7[4] = this;
    xpc_array_apply(v5, v7);
  }

  return RDQSRPeer::ScanRecognizers(this);
}

uint64_t sub_1000465B4(uint64_t a1, int a2, xpc_object_t xdict)
{
  uint64_t v4 = *(RDQSRPeer **)(a1 + 32);
  uunint64_t int64 = (unint64_t *)xpc_dictionary_get_uint64(xdict, kRDKeyObjectID);
  RDQSRPeer::UpdateOrReleaseObject(v4, uint64, xdict);
  return 1LL;
}

uint64_t sub_1000465FC(uint64_t a1, int a2, xpc_object_t xuint)
{
  uint64_t v3 = *(RDQSRPeer **)(a1 + 32);
  xpc_object_t value = (unint64_t *)xpc_uint64_get_value(xuint);
  RDQSRPeer::UpdateOrReleaseObject(v3, value, 0LL);
  return 1LL;
}

uint64_t RDQSRPeer::ScanRecognizers(RDQSRPeer *this)
{
  *(_WORD *)((char *)this + 207) = 0;
  CFStringRef v39 = (RDQSREngine *)RDQSREngine::sInstance;
  v48[0] = 0LL;
  v48[1] = 0LL;
  int v47 = (uint64_t *)v48;
  uint64_t v2 = (char *)*((void *)this + 8);
  uint64_t v3 = (char *)this + 72;
  BOOL v4 = v2 != (char *)this + 72;
  if (v2 == (char *)this + 72)
  {
LABEL_23:
    char v17 = (char *)*((void *)this + 11);
    uint64_t v36 = (uint64_t *)((char *)this + 88);
    xpc_object_t v18 = (char *)this + 96;
    if (v17 != (char *)this + 96)
    {
      uint64_t v19 = (char *)this + 112;
      char v20 = (char *)this + 120;
      do
      {
        uint64_t v21 = v48[0];
        unint64_t v22 = *((void *)v17 + 4);
        if (!v48[0]) {
          goto LABEL_34;
        }
        char v23 = v48;
        do
        {
          uint64_t v24 = v21;
          xpc_object_t v25 = v23;
          unint64_t v26 = v21[4];
          uint64_t v27 = v21 + 1;
          if (v26 >= v22)
          {
            uint64_t v27 = v24;
            char v23 = (void **)v24;
          }

          uint64_t v21 = (void *)*v27;
        }

        while (v21);
        if (v23 == v48) {
          goto LABEL_34;
        }
        if (v26 < v22) {
          uint64_t v24 = v25;
        }
        if (v22 < v24[4])
        {
LABEL_34:
          __int16 v40 = (uint64_t *)*((void *)v17 + 4);
          uint64_t v41 = 0LL;
          uint64_t v42 = 0LL;
          uint64_t v43 = 0LL;
          char v44 = 1;
          uint64_t v45 = 0LL;
          *(void *)std::string buf = &v40;
          uint64_t v28 = sub_100047584((uint64_t)v19, (unint64_t **)buf);
          if (v20 != (char *)v28)
          {
            float v29 = (os_log_s *)RXOSLog();
            if (os_log_type_enabled(v29, OS_LOG_TYPE_DEBUG))
            {
              uint64_t v30 = *(void *)(*(void *)(v28 + 32) + 16LL);
              *(_DWORD *)std::string buf = 134217984;
              *(void *)&uint8_t buf[4] = v30;
              _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEBUG, "Deactivate grammar %zu\n", buf, 0xCu);
            }

            RDQSREngine::GrammarIsLive(v39, *(void *)(*(void *)(v28 + 32) + 16LL), 0);
          }

          uint64_t v31 = v43;
          uint64_t v43 = 0LL;
          if (v31) {
            sub_100034D1C((uint64_t)&v43, v31);
          }
        }

        id v32 = (char *)*((void *)v17 + 1);
        if (v32)
        {
          do
          {
            std::string v33 = v32;
            id v32 = *(char **)v32;
          }

          while (v32);
        }

        else
        {
          do
          {
            std::string v33 = (char *)*((void *)v17 + 2);
            BOOL v16 = *(void *)v33 == (void)v17;
            char v17 = v33;
          }

          while (!v16);
        }

        char v17 = v33;
      }

      while (v33 != v18);
    }

    sub_100047E14(v36, (uint64_t)&v47);
    RDQSREngine::BuildCombinedGrammar(v39);
    uint64_t v34 = v4;
  }

  else
  {
    xpc_object_t v38 = (char *)this + 112;
    xpc_object_t v37 = (char *)this + 120;
    while (*((_BYTE *)this + 203))
    {
      __int16 v40 = (uint64_t *)(v2 + 32);
      xpc_object_t v5 = sub_100019C58((uint64_t **)this + 5, (unint64_t *)v2 + 4, (uint64_t)&unk_1000AC40B, &v40);
      uint64_t v6 = (void *)v5[5];
      if (v6)
      {
        if (xpc_dictionary_get_BOOL((xpc_object_t)v5[5], kRDKeyIsListening))
        {
          uunint64_t int64 = (uint64_t *)xpc_dictionary_get_uint64(v6, kRDKeyLanguageModel);
          xpc_object_t v46 = uint64;
          if (uint64)
          {
            __int16 v40 = uint64;
            uint64_t v41 = 0LL;
            uint64_t v42 = 0LL;
            uint64_t v43 = 0LL;
            char v44 = 1;
            uint64_t v45 = 0LL;
            *(void *)std::string buf = &v40;
            uint64_t v8 = sub_100047584((uint64_t)v38, (unint64_t **)buf);
            if (v37 == (char *)v8)
            {
              size_t v12 = (os_log_s *)RXOSLog();
              if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
              {
                *(_DWORD *)std::string buf = 134217984;
                *(void *)&uint8_t buf[4] = v46;
                _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_ERROR,  "ScanRecognizers:: Gram entry not found for lmID %llu",  buf,  0xCu);
              }
            }

            else
            {
              *(void *)std::string buf = &v46;
              *(void *)(*(void *)(v8 + 32) + 32LL) = sub_100019C58( (uint64_t **)this + 5,  (unint64_t *)&v46,  (uint64_t)&unk_1000AC40B,  (uint64_t **)buf)[5];
              *(void *)(*(void *)(v8 + 32) + 8LL) = xpc_dictionary_get_uint64(v6, kRDKeyObjectID);
              *(void *)(*(void *)(v8 + 32) + 56LL) = xpc_dictionary_get_uint64(v6, kRDKeyMaxResults);
              *(_BYTE *)(*(void *)(v8 + 32) + 49LL) = xpc_dictionary_get_BOOL(v6, kRDKeyUseStreaming);
              *(_BYTE *)(*(void *)(v8 + 32) + 5sub_10003A5DC((uint64_t)va, 0LL) = xpc_dictionary_get_BOOL(v6, kRDKeyAllowCloseMatch);
              *(_BYTE *)(*(void *)(v8 + 32) + 51LL) = xpc_dictionary_get_BOOL(v6, kRDKeySpellingMode);
              BOOL v9 = xpc_dictionary_get_BOOL(v6, kRDKeyNumberMode);
              uint64_t v10 = *(void *)(v8 + 32);
              *(_BYTE *)(v10 + 52) = v9;
              RDQSREngine::GrammarIsLive(v39, *(void *)(v10 + 16), 1);
              uint64_t v11 = *(void *)(v8 + 32);
              if (*(_BYTE *)(v11 + 51)) {
                *((_BYTE *)this + 207) = 1;
              }
              if (*(_BYTE *)(v11 + 52)) {
                *((_BYTE *)this + 20_Block_object_dispose(va, 8) = 1;
              }
              sub_10002F044(&v47, (unint64_t *)&v46, (uint64_t *)&v46);
            }

            uint64_t v13 = v43;
            uint64_t v43 = 0LL;
            if (v13) {
              sub_100034D1C((uint64_t)&v43, v13);
            }
          }
        }
      }

      BOOL v14 = (char *)*((void *)v2 + 1);
      if (v14)
      {
        do
        {
          uint64_t v15 = v14;
          BOOL v14 = *(char **)v14;
        }

        while (v14);
      }

      else
      {
        do
        {
          uint64_t v15 = (char *)*((void *)v2 + 2);
          BOOL v16 = *(void *)v15 == (void)v2;
          uint64_t v2 = v15;
        }

        while (!v16);
      }

      uint64_t v2 = v15;
      if (v15 == v3) {
        goto LABEL_23;
      }
    }

    uint64_t v34 = 1LL;
  }

  sub_10001A7A8((uint64_t)&v47, v48[0]);
  return v34;
}

void sub_100046AF0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, char a27, void *a28)
{
}

void RDQSRPeer::AddTraining(RDQSRPeer *this, void *a2)
{
  if (!*((_BYTE *)this + 204))
  {
    if (!*((_BYTE *)this + 200))
    {
      RDQSREngine::AddPeer(RDQSREngine::sInstance, (uint64_t)this);
      *((_BYTE *)this + 20RDString::RDString((RDString *)&v66, theString, 0) = 1;
    }

    *((_BYTE *)this + 204) = 1;
  }

  RDQSREngine::AddTrainingData((RDQSREngine *)RDQSREngine::sInstance, a2);
}

BOOL RDQSRPeer::SetSecureFieldFocused(RDQSRPeer *this, xpc_object_t xdict)
{
  if (!*((_BYTE *)this + 200))
  {
    RDQSREngine::AddPeer(RDQSREngine::sInstance, (uint64_t)this);
    *((_BYTE *)this + 20RDString::RDString((RDString *)&v66, theString, 0) = 1;
  }

  return RDQSREngine::SetSecureFieldFocused((RDQSREngine *)RDQSREngine::sInstance, xdict);
}

uint64_t RDQSRPeer::AddLeadingContext(RDQSRPeer *this, void *a2)
{
  if (!*((_BYTE *)this + 200))
  {
    RDQSREngine::AddPeer(RDQSREngine::sInstance, (uint64_t)this);
    *((_BYTE *)this + 20RDString::RDString((RDString *)&v66, theString, 0) = 1;
  }

  return RDQSREngine::AddLeadingContextData((RDQSREngine *)RDQSREngine::sInstance, a2);
}

void RDQSRPeer::AddOtherContext(RDQSRPeer *this, xpc_object_t xdict)
{
  if (!*((_BYTE *)this + 200))
  {
    RDQSREngine::AddPeer(RDQSREngine::sInstance, (uint64_t)this);
    *((_BYTE *)this + 20RDString::RDString((RDString *)&v66, theString, 0) = 1;
  }

  RDQSREngine::AddOtherContextData((RDQSREngine *)RDQSREngine::sInstance, xdict);
}

std::chrono::duration<long long, std::ratio<1, 1000000000>>::rep RDQSRPeer::ResetRecognition( RDQSRPeer *this)
{
  if (!*((_BYTE *)this + 200))
  {
    RDQSREngine::AddPeer(RDQSREngine::sInstance, (uint64_t)this);
    *((_BYTE *)this + 20RDString::RDString((RDString *)&v66, theString, 0) = 1;
  }

  return RDQSREngine::ResetRecognition((RDQSREngine *)RDQSREngine::sInstance);
}

std::chrono::duration<long long, std::ratio<1, 1000000000>>::rep RDQSRPeer::SetResetRecognitionMode( RDQSRPeer *this, xpc_object_t xdict)
{
  if (!*((_BYTE *)this + 200))
  {
    RDQSREngine::AddPeer(RDQSREngine::sInstance, (uint64_t)this);
    *((_BYTE *)this + 20RDString::RDString((RDString *)&v66, theString, 0) = 1;
  }

  return RDQSREngine::SetResetRecognitionMode((RDQSREngine *)RDQSREngine::sInstance, xdict);
}

void RDQSRPeer::SaveUserProfileToFile(RDQSRPeer *this, xpc_object_t xdict)
{
  if (!*((_BYTE *)this + 200))
  {
    RDQSREngine::AddPeer(RDQSREngine::sInstance, (uint64_t)this);
    *((_BYTE *)this + 20RDString::RDString((RDString *)&v66, theString, 0) = 1;
  }

  RDQSREngine::SaveUserProfileToFile((void **)RDQSREngine::sInstance, xdict);
}

void RDQSRPeer::PhoneticNeighborsForText(RDQSRPeer *this, xpc_object_t xdict, void *a3)
{
  if (!*((_BYTE *)this + 200))
  {
    RDQSREngine::AddPeer(RDQSREngine::sInstance, (uint64_t)this);
    *((_BYTE *)this + 20RDString::RDString((RDString *)&v66, theString, 0) = 1;
  }

  if (*((void *)this + 30))
  {
    string = xpc_dictionary_get_string(xdict, kRDKeyText);
    uint64_t v7 = (const __CFArray *)SRSSPhoneticCheckerCopyGuesses(*((void *)this + 30), string, 10LL, 0.8, 0.2);
    if (v7)
    {
      uint64_t v8 = v7;
      if (CFArrayGetCount(v7) >= 1)
      {
        xpc_object_t empty = xpc_array_create_empty();
        if (CFArrayGetCount(v8) >= 1)
        {
          CFIndex v10 = 0LL;
          do
          {
            ValueAtIndex = CFArrayGetValueAtIndex(v8, v10);
            size_t v12 = (const __CFString *)SRSSPhoneticCheckerResultCopyText(ValueAtIndex);
            if (v12)
            {
              uint64_t v13 = v12;
              memset(v15, 0, sizeof(v15));
              if (CFStringGetCString(v12, (char *)v15, 512LL, 0x8000100u))
              {
                xpc_object_t v14 = xpc_string_create((const char *)v15);
                xpc_array_append_value(empty, v14);
                CFRelease(v13);
                xpc_release(v14);
              }
            }

            ++v10;
          }

          while (CFArrayGetCount(v8) > v10);
        }

        if (a3) {
          xpc_dictionary_set_value(a3, kRDKeyText, empty);
        }
      }

      CFRelease(v8);
    }
  }

void RDQSRPeer::LogMatchedCommandID(uint64_t **this, void *a2)
{
  xpc_object_t value = xpc_dictionary_get_value(a2, kRDKeyChildren);
  if (value)
  {
    BOOL v4 = value;
    uint64_t count = (unsigned __int16)xpc_array_get_count(value);
    if (count)
    {
      size_t v6 = 0LL;
      while (1)
      {
        xpc_object_t v7 = xpc_array_get_value(v4, v6);
        uunint64_t int64 = xpc_dictionary_get_uint64(v7, kRDKeyObjectID);
        __p[0] = &uint64;
        uint64_t v8 = sub_100019C58(this + 5, &uint64, (uint64_t)&unk_1000AC40B, (uint64_t **)__p);
        BOOL v9 = (void *)v8[5];
        if (v9)
        {
          if (xpc_dictionary_get_string((xpc_object_t)v8[5], kRDKeyCommandID))
          {
            string = (char *)xpc_dictionary_get_string(v9, kRDKeyCommandID);
            sub_10000A2DC(__p, string);
            uint64_t v11 = (os_log_s *)RXOSLog();
            if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
            {
              size_t v12 = __p;
              if (v14 < 0) {
                size_t v12 = (void **)__p[0];
              }
              *(_DWORD *)std::string buf = 136446210;
              char v17 = v12;
              _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_DEFAULT,  "Matched Grammar: CommandID -> %{public}s",  buf,  0xCu);
            }

            if (v14 < 0) {
              break;
            }
          }
        }

        if (v7) {
          goto LABEL_12;
        }
LABEL_13:
        if (count == ++v6) {
          return;
        }
      }

      operator delete(__p[0]);
      if (!v7) {
        goto LABEL_13;
      }
LABEL_12:
      RDQSRPeer::LogMatchedCommandID((RDQSRPeer *)this, v7);
      goto LABEL_13;
    }
  }

void sub_100047118( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void RDQSRPeer::ServerResponse(uint64_t a1, void *a2, uint64_t a3)
{
  BOOL v6 = *(_BYTE *)(RDQSREngine::sInstance + 48) == 0;
  xpc_object_t v7 = xpc_dictionary_create(0LL, 0LL, 0LL);
  xpc_dictionary_set_int64(v7, kRDKeyMessage, 200LL);
  xpc_dictionary_set_uint64(v7, kRDKeyEpoch, *(void *)(a1 + 176));
  if (a2) {
    xpc_dictionary_set_uint64(a2, kRDKeyUtteranceID, *(void *)(RDQSREngine::sInstance + 168));
  }
  if (a3)
  {
    *(void *)std::string buf = a3 + 8;
    uint64_t v8 = sub_100019C58((uint64_t **)(a1 + 40), (unint64_t *)(a3 + 8), (uint64_t)&unk_1000AC40B, (uint64_t **)buf);
    xpc_object_t v9 = xpc_copy((xpc_object_t)v8[5]);
    xpc_dictionary_set_value(v9, kRDKeyLanguageModel, a2);
    if (a2)
    {
      if (*(void *)(a1 + 224)) {
        RDPeer::KeepSystemAwake((RDPeer *)a1);
      }
      xpc_release(a2);
      BOOL v6 = 0;
    }

    xpc_dictionary_set_value(v7, kRDKeyRecognizer, v9);
    xpc_release(v9);
  }

  if (*(_BYTE *)(a1 + 16))
  {
    CFIndex v10 = xpc_copy_description(v7);
    uint64_t v11 = (os_log_s *)RXOSLog();
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)std::string buf = 136315138;
      *(void *)&uint8_t buf[4] = v10;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "Server Response %s", buf, 0xCu);
    }

    free(v10);
  }

  if (a2) {
    char v12 = v6;
  }
  else {
    char v12 = 1;
  }
  if ((v12 & 1) != 0) {
    xpc_release(v7);
  }
  else {
    RDPeer::SendClientMessage((RDPeer *)a1, v7);
  }
}

void RDQSRPeer::EndPhrase(uint64_t **a1, int a2, uint64_t a3, void *a4)
{
}

void RDQSRPeer::ReachedEndofAudioFile(RDQSRPeer *this)
{
  xpc_object_t v2 = xpc_dictionary_create(0LL, 0LL, 0LL);
  xpc_dictionary_set_int64(v2, kRDKeyMessage, 205LL);
  xpc_dictionary_set_uint64(v2, kRDKeyCallbacks, 2uLL);
  xpc_dictionary_set_uint64(v2, kRDKeyObjectID, *((void *)this + 23));
  RDPeer::SendClientMessage(this, v2);
}

void RDQSRPeer::BeginUtt(RDQSRPeer *this)
{
  if ((*((_BYTE *)this + 192) & 1) != 0)
  {
    xpc_object_t v2 = xpc_dictionary_create(0LL, 0LL, 0LL);
    xpc_dictionary_set_int64(v2, kRDKeyMessage, 205LL);
    xpc_dictionary_set_uint64(v2, kRDKeyUtteranceID, *(void *)(RDQSREngine::sInstance + 168));
    xpc_dictionary_set_uint64(v2, kRDKeyCallbacks, 1uLL);
    xpc_dictionary_set_uint64(v2, kRDKeyObjectID, *((void *)this + 23));
    RDPeer::SendClientMessage(this, v2);
  }

RDQSRPeer *RDCreateQSRPeer(_xpc_connection_s *a1, void *a2, uint64_t a3, RDAudioObject *a4)
{
  uint64_t v8 = (RDQSRPeer *)operator new(0xF8uLL);
  RDQSRPeer::RDQSRPeer(v8, a1, a2, a3, a4);
  return v8;
}

void sub_1000474F8(_Unwind_Exception *a1)
{
}

uint64_t sub_10004750C(uint64_t a1)
{
  xpc_object_t v2 = *(void **)a1;
  *(void *)a1 = 0LL;
  if (v2) {
    operator delete(v2);
  }
  return a1;
}

void sub_100047544(uint64_t a1, void **a2)
{
  if (a2)
  {
    xpc_object_t v2 = a2;
    do
    {
      uint64_t v3 = *v2;
      sub_10001A7A8((uint64_t)(v2 + 3), v2[4]);
      operator delete(v2);
      xpc_object_t v2 = (void **)v3;
    }

    while (v3);
  }

uint64_t sub_100047584(uint64_t a1, unint64_t **a2)
{
  uint64_t v4 = *(void *)(a1 + 8);
  uint64_t v2 = a1 + 8;
  uint64_t v3 = v4;
  if (!v4) {
    return v2;
  }
  unint64_t v5 = **a2;
  uint64_t v6 = v2;
  do
  {
    unint64_t v7 = **(void **)(v3 + 32);
    BOOL v8 = v7 >= v5;
    if (v7 >= v5) {
      xpc_object_t v9 = (uint64_t *)v3;
    }
    else {
      xpc_object_t v9 = (uint64_t *)(v3 + 8);
    }
    if (v8) {
      uint64_t v6 = v3;
    }
    uint64_t v3 = *v9;
  }

  while (*v9);
  if (v6 == v2 || v5 < **(void **)(v6 + 32)) {
    return v2;
  }
  return v6;
}

uint64_t *sub_1000475DC(uint64_t **a1, unint64_t **a2, uint64_t *a3)
{
  uint64_t v6 = a1 + 1;
  unint64_t v5 = a1[1];
  if (v5)
  {
    unint64_t v7 = **a2;
    while (1)
    {
      while (1)
      {
        BOOL v8 = (uint64_t **)v5;
        unint64_t v9 = *(void *)v5[4];
        if (v7 >= v9) {
          break;
        }
        unint64_t v5 = *v8;
        uint64_t v6 = v8;
        if (!*v8) {
          goto LABEL_10;
        }
      }

      if (v9 >= v7) {
        break;
      }
      unint64_t v5 = v8[1];
      if (!v5)
      {
        uint64_t v6 = v8 + 1;
        goto LABEL_10;
      }
    }
  }

  else
  {
    BOOL v8 = a1 + 1;
LABEL_10:
    CFIndex v10 = (uint64_t *)operator new(0x28uLL);
    v10[4] = *a3;
    sub_100019D14(a1, (uint64_t)v8, v6, v10);
    return v10;
  }

  return (uint64_t *)v8;
}

uint64_t sub_10004769C(uint64_t a1, unint64_t *a2, uint64_t a3)
{
  *(void *)(a1 + _Block_object_dispose(va, 8) = 0LL;
  uint64_t v4 = (void *)(a1 + 8);
  *(void *)(a1 + 16) = 0LL;
  *(void *)a1 = a1 + 8;
  if (a3)
  {
    uint64_t v6 = 8 * a3;
    do
    {
      sub_100047718((uint64_t **)a1, v4, a2, (uint64_t *)a2);
      ++a2;
      v6 -= 8LL;
    }

    while (v6);
  }

  return a1;
}

void sub_100047700(_Unwind_Exception *a1)
{
}

uint64_t *sub_100047718(uint64_t **a1, void *a2, unint64_t *a3, uint64_t *a4)
{
  uint64_t v6 = (uint64_t **)sub_10004779C(a1, a2, &v11, &v10, a3);
  unint64_t v7 = *v6;
  if (!*v6)
  {
    BOOL v8 = v6;
    unint64_t v7 = (uint64_t *)operator new(0x28uLL);
    void v7[4] = *a4;
    sub_100019D14(a1, v11, v8, v7);
  }

  return v7;
}

void *sub_10004779C(void *a1, void *a2, void *a3, void *a4, unint64_t *a5)
{
  unint64_t v5 = a1 + 1;
  if (a1 + 1 == a2 || (v6 = *a5, unint64_t v7 = a2[4], *a5 < v7))
  {
    uint64_t v8 = *a2;
    if ((void *)*a1 == a2)
    {
      uint64_t v10 = a2;
LABEL_17:
      if (v8)
      {
        *a3 = v10;
        return v10 + 1;
      }

      else
      {
        *a3 = a2;
        return a2;
      }
    }

    if (v8)
    {
      unint64_t v9 = (void *)*a2;
      do
      {
        uint64_t v10 = v9;
        unint64_t v9 = (void *)v9[1];
      }

      while (v9);
    }

    else
    {
      uint64_t v13 = a2;
      do
      {
        uint64_t v10 = (void *)v13[2];
        BOOL v14 = *v10 == (void)v13;
        uint64_t v13 = v10;
      }

      while (v14);
    }

    unint64_t v15 = *a5;
    if (v10[4] < *a5) {
      goto LABEL_17;
    }
    BOOL v16 = (void *)*v5;
    if (*v5)
    {
      do
      {
        while (1)
        {
          char v17 = v16;
          unint64_t v18 = v16[4];
          if (v15 >= v18) {
            break;
          }
          BOOL v16 = (void *)*v17;
          unint64_t v5 = v17;
          if (!*v17) {
            goto LABEL_29;
          }
        }

        if (v18 >= v15) {
          break;
        }
        unint64_t v5 = v17 + 1;
        BOOL v16 = (void *)v17[1];
      }

      while (v16);
    }

    else
    {
      char v17 = a1 + 1;
    }

LABEL_48:
    *a3 = v21;
    return v5;
  }

  if (v11)
  {
    *a3 = a4;
  }

  else
  {
    *a3 = a2;
    return a2 + 1;
  }

  return a4;
}

    *a3 = v21;
    return v5;
  }

  if (v11)
  {
    *a3 = a4;
  }

  else
  {
    *a3 = a2;
    return a2 + 1;
  }

  return a4;
}

    if (*((void *)&v43 + 1)) {
      --**((_DWORD **)&v43 + 1);
    }
LABEL_50:
    uint64_t v31 = *(void *)a1[1];
    (*(void (**)(__int128 *__return_ptr, void, uint64_t))(*(void *)*a1 + 24LL))(&v42, *a1, v8);
    id v32 = *(float *)(v31 + 4LL * (int)v8);
    if (v32 == -INFINITY || *(float *)&v42 >= -INFINITY && *(float *)&v42 <= -INFINITY)
    {
      std::string v33 = *(float *)sub_1000606CC();
    }

    else
    {
      uint64_t v34 = *(float *)&v42 == INFINITY || v32 == INFINITY;
      std::string v33 = v32 + *(float *)&v42;
      if (v34) {
        std::string v33 = INFINITY;
      }
    }

    std::string v35 = *((float *)a1 + 78);
    if (v35 == -INFINITY || v33 >= -INFINITY && v33 <= -INFINITY)
    {
      std::string v33 = *(float *)sub_1000606CC();
    }

    else if (v35 < v33)
    {
      std::string v33 = *((float *)a1 + 78);
    }

    *((float *)a1 + 7_Block_object_dispose(va, 8) = v33;
LABEL_66:
    unint64_t v5 = a1[31];
  }

  while (v5);
LABEL_67:
  for (uint64_t result = (int *)a1[35]; result; uint64_t result = (int *)a1[35])
  {
    *(void *)(a1[32] + (((unint64_t)result[2] >> 3) & 0x1FFFFFFFFFFFFFF8LL)) &= ~(1LL << result[2]);
    a1[35] = *(void *)result;
    operator delete(result);
  }

  ++*((_DWORD *)a1 + 79);
  return result;
}

    *a3 = v21;
    return v5;
  }

  if (v11)
  {
    *a3 = a4;
  }

  else
  {
    *a3 = a2;
    return a2 + 1;
  }

  return a4;
}

uint64_t sub_100047944(void *a1, uint64_t *a2)
{
  uint64_t v2 = *a2;
  sub_10004798C(a1, a2, (uint64_t)&v5);
  uint64_t v3 = v5;
  unint64_t v5 = 0LL;
  if (v3) {
    sub_100047AC0((uint64_t)&v6, v3);
  }
  return v2;
}

void *sub_10004798C@<X0>(void *result@<X0>, void *a2@<X1>, uint64_t a3@<X8>)
{
  int8x8_t v3 = (int8x8_t)result[1];
  unint64_t v4 = a2[1];
  uint8x8_t v5 = (uint8x8_t)vcnt_s8(v3);
  v5.i16[0] = vaddlv_u8(v5);
  if (v5.u32[0] > 1uLL)
  {
    if (v4 >= *(void *)&v3) {
      v4 %= *(void *)&v3;
    }
  }

  else
  {
    v4 &= *(void *)&v3 - 1LL;
  }

  uint64_t v6 = *(void **)(*result + 8 * v4);
  do
  {
    unint64_t v7 = v6;
    uint64_t v6 = (void *)*v6;
  }

  while (v6 != a2);
  if (v7 == result + 2) {
    goto LABEL_18;
  }
  unint64_t v8 = v7[1];
  if (v5.u32[0] > 1uLL)
  {
    if (v8 >= *(void *)&v3) {
      v8 %= *(void *)&v3;
    }
  }

  else
  {
    v8 &= *(void *)&v3 - 1LL;
  }

  if (v8 != v4)
  {
LABEL_18:
    if (!*a2) {
      goto LABEL_19;
    }
    unint64_t v9 = *(void *)(*a2 + 8LL);
    if (v5.u32[0] > 1uLL)
    {
      if (v9 >= *(void *)&v3) {
        v9 %= *(void *)&v3;
      }
    }

    else
    {
      v9 &= *(void *)&v3 - 1LL;
    }

    if (v9 != v4) {
LABEL_19:
    }
      *(void *)(*result + 8 * RDQSREngine::MatchResult(this, v4) = 0LL;
  }

  uint64_t v10 = *a2;
  if (*a2)
  {
    unint64_t v11 = *(void *)(v10 + 8);
    if (v5.u32[0] > 1uLL)
    {
      if (v11 >= *(void *)&v3) {
        v11 %= *(void *)&v3;
      }
    }

    else
    {
      v11 &= *(void *)&v3 - 1LL;
    }

    if (v11 != v4)
    {
      *(void *)(*result + 8 * v11) = v7;
      uint64_t v10 = *a2;
    }
  }

  *unint64_t v7 = v10;
  *a2 = 0LL;
  --result[3];
  *(void *)a3 = a2;
  *(void *)(a3 + _Block_object_dispose(va, 8) = result + 2;
  *(_BYTE *)(a3 + 16) = 1;
  return result;
}

void sub_100047AC0(uint64_t a1, void **a2)
{
  if (*(_BYTE *)(a1 + 8))
  {
    sub_10001A7A8((uint64_t)(a2 + 3), a2[4]);
  }

  else if (!a2)
  {
    return;
  }

  operator delete(a2);
}

uint64_t *sub_100047B08(uint64_t **a1, unint64_t *a2, uint64_t *a3)
{
  uint64_t v6 = a1 + 1;
  uint8x8_t v5 = a1[1];
  if (v5)
  {
    unint64_t v7 = *a2;
    while (1)
    {
      while (1)
      {
        unint64_t v8 = (uint64_t **)v5;
        unint64_t v9 = v5[4];
        if (v7 >= v9) {
          break;
        }
        uint8x8_t v5 = *v8;
        uint64_t v6 = v8;
        if (!*v8) {
          goto LABEL_10;
        }
      }

      if (v9 >= v7) {
        break;
      }
      uint8x8_t v5 = v8[1];
      if (!v5)
      {
        uint64_t v6 = v8 + 1;
        goto LABEL_10;
      }
    }
  }

  else
  {
    unint64_t v8 = a1 + 1;
LABEL_10:
    uint64_t v10 = (uint64_t *)operator new(0x30uLL);
    uint64_t v11 = a3[1];
    v10[4] = *a3;
    void v10[5] = v11;
    sub_100019D14(a1, (uint64_t)v8, v6, v10);
    return v10;
  }

  return (uint64_t *)v8;
}

void *sub_100047BC0(uint64_t a1, unint64_t *a2, uint64_t a3, uint64_t **a4)
{
  unint64_t v7 = *a2;
  unint64_t v8 = *(void *)(a1 + 8);
  if (v8)
  {
    uint8x8_t v9 = (uint8x8_t)vcnt_s8((int8x8_t)v8);
    v9.i16[0] = vaddlv_u8(v9);
    if (v9.u32[0] > 1uLL)
    {
      unint64_t v4 = *a2;
      if (v7 >= v8) {
        unint64_t v4 = v7 % v8;
      }
    }

    else
    {
      unint64_t v4 = (v8 - 1) & v7;
    }

    uint64_t v10 = *(void ***)(*(void *)a1 + 8 * v4);
    if (v10)
    {
      for (size_t i = *v10; i; size_t i = (void *)*i)
      {
        unint64_t v12 = i[1];
        if (v12 == v7)
        {
          if (i[2] == v7) {
            return i;
          }
        }

        else
        {
          if (v9.u32[0] > 1uLL)
          {
            if (v12 >= v8) {
              v12 %= v8;
            }
          }

          else
          {
            v12 &= v8 - 1;
          }

          if (v12 != v4) {
            break;
          }
        }
      }
    }
  }

  uint64_t v13 = (void *)(a1 + 16);
  size_t i = operator new(0x30uLL);
  *size_t i = 0LL;
  i[1] = v7;
  uint64_t v14 = **a4;
  i[5] = 0LL;
  i[4] = 0LL;
  i[2] = v14;
  i[3] = i + 4;
  float v15 = (float)(unint64_t)(*(void *)(a1 + 24) + 1LL);
  float v16 = *(float *)(a1 + 32);
  if (!v8 || (float)(v16 * (float)v8) < v15)
  {
    BOOL v17 = 1LL;
    if (v8 >= 3) {
      BOOL v17 = (v8 & (v8 - 1)) != 0;
    }
    unint64_t v18 = v17 | (2 * v8);
    unint64_t v19 = vcvtps_u32_f32(v15 / v16);
    if (v18 <= v19) {
      size_t v20 = v19;
    }
    else {
      size_t v20 = v18;
    }
    sub_100018334(a1, v20);
    unint64_t v8 = *(void *)(a1 + 8);
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v7 >= v8) {
        unint64_t v4 = v7 % v8;
      }
      else {
        unint64_t v4 = v7;
      }
    }

    else
    {
      unint64_t v4 = (v8 - 1) & v7;
    }
  }

  uint64_t v21 = *(void *)a1;
  unint64_t v22 = *(void **)(*(void *)a1 + 8 * v4);
  if (v22)
  {
    *size_t i = *v22;
LABEL_38:
    *unint64_t v22 = i;
    goto LABEL_39;
  }

  *size_t i = *v13;
  *uint64_t v13 = i;
  *(void *)(v21 + 8 * RDQSREngine::MatchResult(this, v4) = v13;
  if (*i)
  {
    unint64_t v23 = *(void *)(*i + 8LL);
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v23 >= v8) {
        v23 %= v8;
      }
    }

    else
    {
      v23 &= v8 - 1;
    }

    unint64_t v22 = (void *)(*(void *)a1 + 8 * v23);
    goto LABEL_38;
  }

void sub_100047DF8(_Unwind_Exception *a1)
{
}

uint64_t *sub_100047E14(uint64_t *result, uint64_t a2)
{
  uint64_t v2 = *result;
  NSError *result = *(void *)a2;
  *(void *)a2 = v2;
  uint64_t v5 = result[1];
  uint64_t v4 = result[2];
  int8x8_t v3 = result + 1;
  *(_OWORD *)(result + 1) = *(_OWORD *)(a2 + 8);
  *(void *)(a2 + _Block_object_dispose(va, 8) = v5;
  *(void *)(a2 + 16) = v4;
  if (result[2]) {
    uint64_t result = (uint64_t *)(*v3 + 16LL);
  }
  NSError *result = (uint64_t)v3;
  uint64_t v6 = (void *)(*(void *)(a2 + 8) + 16LL);
  if (!v4) {
    uint64_t v6 = (void *)a2;
  }
  void *v6 = a2 + 8;
  return result;
}

void RDKeyword::SetLocale(RDKeyword *this, const char *a2)
{
  if (qword_1000DDDF8 != -1) {
    dispatch_once(&qword_1000DDDF8, &stru_1000CFE60);
  }
  block[0] = _NSConcreteStackBlock;
  block[1] = 0x40000000LL;
  block[2] = sub_100047EF8;
  block[3] = &unk_1000CFD38;
  void block[4] = this;
  dispatch_sync((dispatch_queue_t)qword_1000DDDF0, block);
}

CFStringRef sub_100047EF8(CFStringRef result)
{
  if (!qword_1000DDDD0)
  {
    uint64_t result = CFStringCreateWithCString(0LL, (const char *)result[1].isa, 0x8000100u);
    qword_1000DDDD0 = (uint64_t)result;
  }

  return result;
}

void RDKeyword::Text(uint64_t a1@<X8>)
{
  uint64_t v5 = 0LL;
  uint64_t v6 = &v5;
  uint64_t v7 = 0x4002000000LL;
  unint64_t v8 = sub_100048064;
  uint8x8_t v9 = sub_100048080;
  uint64_t v11 = 0LL;
  uint64_t v12 = 0LL;
  std::string __p = 0LL;
  if (qword_1000DDDF8 != -1) {
    dispatch_once(&qword_1000DDDF8, &stru_1000CFE60);
  }
  block[0] = _NSConcreteStackBlock;
  block[1] = 0x40000000LL;
  block[2] = sub_100048094;
  block[3] = &unk_1000CFD60;
  void block[4] = &v5;
  dispatch_sync((dispatch_queue_t)qword_1000DDDF0, block);
  if (*((char *)v6 + 63) < 0)
  {
    sub_10005AA70((_BYTE *)a1, (void *)v6[5], v6[6]);
  }

  else
  {
    __int128 v3 = *(_OWORD *)(v6 + 5);
    *(void *)(a1 + 16) = v6[7];
    *(_OWORD *)a1 = v3;
  }

  _Block_object_dispose(&v5, 8);
  if (SHIBYTE(v12) < 0) {
    operator delete(__p);
  }
}

void sub_10004803C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p, uint64_t a21, int a22, __int16 a23, char a24, char a25)
{
  if (a25 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

__n128 sub_100048064(uint64_t a1, uint64_t a2)
{
  __n128 result = *(__n128 *)(a2 + 40);
  *(void *)(a1 + ++*(void *)(result + 56) = *(void *)(a2 + 56);
  *(__n128 *)(a1 + 4RDString::RDString((RDString *)&v66, theString, 0) = result;
  *(void *)(a2 + 4_Block_object_dispose(va, 8) = 0LL;
  *(void *)(a2 + ++*(void *)(result + 56) = 0LL;
  *(void *)(a2 + 4RDString::RDString((RDString *)&v66, theString, 0) = 0LL;
  return result;
}

void sub_100048080(uint64_t a1)
{
}

void sub_100048094(uint64_t a1)
{
  if (qword_1000DDDD8) {
    std::string::assign( (std::string *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 40LL),  (const std::string::value_type *)qword_1000DDDD8);
  }
}

void sub_1000480D8()
{
  if ((byte_1000DDE00 & 1) == 0 && qword_1000DDDD0)
  {
    int v0 = CFStringCreateWithFormat(0LL, 0LL, @"%@.%@", @"KeywordText", qword_1000DDDD0);
    uint64_t v1 = (const __CFString *)CFPreferencesCopyAppValue( v0,  @"com.apple.speech.recognition.AppleSpeechRecognition.prefs");
    CFRelease(v0);
    if (v1)
    {
      CStringPtr = CFStringGetCStringPtr(v1, 0x8000100u);
      if (CStringPtr)
      {
        qword_1000DDDD8 = (uint64_t)strdup(CStringPtr);
      }

      else
      {
        CFIndex Length = CFStringGetLength(v1);
        CFIndex v4 = CFStringGetMaximumSizeForEncoding(Length, 0x8000100u) + 1;
        sub_10002A944(__p, v4, 32);
        if (v13 >= 0) {
          uint64_t v5 = (char *)__p;
        }
        else {
          uint64_t v5 = (char *)__p[0];
        }
        int CString = CFStringGetCString(v1, v5, v4, 0x8000100u);
        int v7 = v13;
        if (CString)
        {
          if (v13 >= 0) {
            unint64_t v8 = __p;
          }
          else {
            unint64_t v8 = (void **)__p[0];
          }
          qword_1000DDDD8 = (uint64_t)strdup((const char *)v8);
        }

        if (v7 < 0) {
          operator delete(__p[0]);
        }
      }

      CFRelease(v1);
    }

    uint8x8_t v9 = (const __CFNumber *)CFPreferencesCopyAppValue( @"KeywordOptional",  @"com.apple.speech.recognition.AppleSpeechRecognition.prefs");
    if (v9)
    {
      uint64_t v10 = v9;
      if (!CFNumberGetValue(v9, kCFNumberIntType, &dword_1000DDDE4)) {
        dword_1000DDDE4 = 0;
      }
      CFRelease(v10);
      unsigned int v11 = dword_1000DDDE4 >> 31;
    }

    else
    {
      LOBYTE(v11) = 0;
      dword_1000DDDE4 = 0;
      qword_1000DDDD8 = 0LL;
    }

    byte_1000DDDE0 = v11;
    byte_1000DDE00 = 1;
  }

void sub_100048274( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t RDKeyword::IsOptional(RDKeyword *this)
{
  if (qword_1000DDDF8 != -1) {
    dispatch_once(&qword_1000DDDF8, &stru_1000CFE60);
  }
  dispatch_sync((dispatch_queue_t)qword_1000DDDF0, &stru_1000CFDA0);
  return byte_1000DDDE0;
}

void RDKeyword::ResetTimer(RDKeyword *this)
{
  if (qword_1000DDDF8 != -1) {
    dispatch_once(&qword_1000DDDF8, &stru_1000CFE60);
  }
  dispatch_sync((dispatch_queue_t)qword_1000DDDF0, &stru_1000CFDE0);
}

void sub_100048330(id a1)
{
  int v2 = dword_1000DDDE4;
  if (byte_1000DDDE0 != (dword_1000DDDE4 != 0))
  {
    byte_1000DDDE0 = dword_1000DDDE4 != 0;
    RDPeer::KeywordChanged(v1);
    int v2 = dword_1000DDDE4;
  }

  if (v2 >= 1)
  {
    qword_1000DDDE8 = time(0LL) + dword_1000DDDE4;
    dispatch_time_t v3 = dispatch_time(0LL, 1000000000LL * dword_1000DDDE4 + 1000000000);
    if (qword_1000DDDF8 != -1) {
      dispatch_once(&qword_1000DDDF8, &stru_1000CFE60);
    }
    dispatch_after(v3, (dispatch_queue_t)qword_1000DDDF0, &stru_1000CFE20);
  }

void sub_1000483F8(id a1)
{
  uint64_t v1 = qword_1000DDDE8;
  int v2 = (RDPeer *)time(0LL);
  if (v1 <= (uint64_t)v2 && byte_1000DDDE0 != dword_1000DDDE4 >> 31)
  {
    byte_1000DDDE0 = dword_1000DDDE4 < 0;
    RDPeer::KeywordChanged(v2);
  }

void sub_100048454(id a1)
{
  qword_1000DDDF0 = (uint64_t)dispatch_queue_create("RDKeyword", 0LL);
  DarwinNotifyCenter = CFNotificationCenterGetDarwinNotifyCenter();
  CFNotificationCenterAddObserver( DarwinNotifyCenter,  0LL,  (CFNotificationCallback)sub_10004849C,  @"com.apple.speech.recognition.AppleSpeechRecognition.KeywordChanged",  0LL,  CFNotificationSuspensionBehaviorDeliverImmediately);
}

uint64_t sub_10004849C()
{
  if (qword_1000DDDF8 != -1) {
    dispatch_once(&qword_1000DDDF8, &stru_1000CFE60);
  }
  dispatch_sync((dispatch_queue_t)qword_1000DDDF0, &stru_1000CFEA0);
  return RDPeer::KeywordChanged(v0);
}

void sub_1000484E8(id a1)
{
  qword_1000DDDD8 = 0LL;
  byte_1000DDE00 = 0;
  CFPreferencesAppSynchronize(@"com.apple.speech.recognition.AppleSpeechRecognition.prefs");
}

void sub_100048890( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, id location)
{
}

BOOL sub_1000488B4(uint64_t a1)
{
  return objc_loadWeak((id *)(a1 + 32)) != 0LL;
}

void sub_1000488D4(uint64_t a1, uint64_t a2)
{
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472LL;
  block[2] = sub_10004893C;
  block[3] = &unk_1000CFEF0;
  void block[4] = a2;
  __int128 v3 = *(_OWORD *)(a1 + 32);
  dispatch_async((dispatch_queue_t)gRDServerQueue, block);
}

void sub_10004893C(uint64_t a1)
{
  if (qword_1000DDE08 && [(id)qword_1000DDE08 isEqual:*(void *)(a1 + 32)])
  {
    int v2 = (os_log_s *)RXOSLog();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      double v3 = *(double *)(*(void *)(a1 + 40) + 16LL);
      int v9 = 138412290;
      double v10 = v3;
      _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEFAULT,  "Skipping profile update for %@ because user data has not actually changed",  (uint8_t *)&v9,  0xCu);
    }
  }

  else
  {
    qword_1000DDE08 = *(void *)(a1 + 32);
    -[NSProcessInfo systemUptime]( +[NSProcessInfo processInfo](&OBJC_CLASS___NSProcessInfo, "processInfo"),  "systemUptime");
    double v5 = v4;
    [*(id *)(a1 + 40) adaptUserProfileWithUserData:*(void *)(a1 + 32)];
    -[NSProcessInfo systemUptime]( +[NSProcessInfo processInfo](&OBJC_CLASS___NSProcessInfo, "processInfo"),  "systemUptime");
    double v7 = v6;
    unint64_t v8 = (os_log_s *)RXOSLog();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      int v9 = 134217984;
      double v10 = (v7 - v5) * 1000.0;
      _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEFAULT,  "Contacts added to profile in %.2fms",  (uint8_t *)&v9,  0xCu);
    }

    (*(void (**)(void))(*(void *)(a1 + 48) + 16LL))();
  }

id sub_10004905C(void *a1, void *a2)
{
  id v4 = -[NSArray firstObject](NSSearchPathForDirectoriesInDomains(NSLibraryDirectory, 1uLL, 1), "firstObject");
  if (v4)
  {
    id v5 = [v4 stringByAppendingPathComponent:@"/SpeechRecognitionCore"];
    if (-[NSFileManager createDirectoryAtPath:withIntermediateDirectories:attributes:error:]( +[NSFileManager defaultManager](&OBJC_CLASS___NSFileManager, "defaultManager"),  "createDirectoryAtPath:withIntermediateDirectories:attributes:error:",  v5,  1LL,  0LL,  a2))
    {
      BOOL v6 = v5 == 0LL;
    }

    else
    {
      BOOL v6 = 1;
    }

    if (!v6) {
      return objc_msgSend( objc_msgSend( objc_msgSend(v5, "stringByAppendingPathComponent:", @"SpeechProfile"),  "stringByAppendingString:",  @"_"),  "stringByAppendingString:",  objc_msgSend(a1, "stringByReplacingOccurrencesOfString:withString:", @"-", @"_"));
    }
  }

  else if (a2)
  {
    *a2 = +[NSError errorWithDomain:code:userInfo:]( &OBJC_CLASS___NSError,  "errorWithDomain:code:userInfo:",  NSPOSIXErrorDomain,  2LL,  0LL);
  }

  return 0LL;
}

void sub_1000492AC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  id v4 = objc_msgSend( [_EARWordPart alloc],  "initWithOrthography:pronunciations:tag:",  a3,  +[NSSet set](NSSet, "set"),  sub_100049338(a2));
  [*(id *)(a1 + 32) addObject:v4];
}

id sub_100049338(uint64_t a1)
{
  if (qword_1000DDE18 != -1) {
    dispatch_once(&qword_1000DDE18, &stru_1000CFF60);
  }
  return _objc_msgSend(objc_msgSend((id)qword_1000DDE10, "objectForKeyedSubscript:", a1), "integerValue");
}

void sub_1000496B0(id a1)
{
  qword_1000DDE10 = &off_1000D6170;
}

double rd_time_util::durationInMilliSec(uint64_t a1)
{
  return (double)((std::chrono::steady_clock::now().__d_.__rep_ - a1) / 1000000);
}

void *multithread_forloop(size_t a1, uint64_t a2)
{
  block[0] = _NSConcreteStackBlock;
  block[1] = 1174405120LL;
  block[2] = sub_1000497E4;
  block[3] = &unk_1000CFF80;
  sub_100007B8C((uint64_t)v6, a2);
  dispatch_apply(a1, 0LL, block);
  __n128 result = v7;
  if (v7 == v6)
  {
    uint64_t v4 = 4LL;
    __n128 result = v6;
  }

  else
  {
    if (!v7) {
      return result;
    }
    uint64_t v4 = 5LL;
  }

  return (void *)(*(uint64_t (**)(void))(*result + 8 * v4))();
}

uint64_t sub_1000497E4(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = a2;
  uint64_t v2 = *(void *)(a1 + 56);
  if (!v2) {
    sub_100007B40();
  }
  return (*(uint64_t (**)(uint64_t, uint64_t *))(*(void *)v2 + 48LL))(v2, &v4);
}

uint64_t sub_10004981C(uint64_t a1, uint64_t a2)
{
  return sub_100007B8C(a1 + 32, a2 + 32);
}

void *sub_100049828(uint64_t a1)
{
  uint64_t v1 = (void *)(a1 + 32);
  __n128 result = *(void **)(a1 + 56);
  if (result == v1)
  {
    uint64_t v3 = 4LL;
    __n128 result = v1;
  }

  else
  {
    if (!result) {
      return result;
    }
    uint64_t v3 = 5LL;
  }

  return (void *)(*(uint64_t (**)(void))(*result + 8 * v3))();
}

void *multithread_forloop(size_t a1, unint64_t a2, uint64_t a3)
{
  size_t v5 = a1;
  if (!a1)
  {
    BOOL v6 = (os_log_s *)RXOSLog();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)double v10 = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_ERROR,  "multithread_forloop: 0 threads are specified, defaulting to 1",  v10,  2u);
    }

    size_t v5 = 1LL;
  }

  unint64_t v7 = vcvtps_u32_f32((float)a2 / (float)v5);
  if (v7 >= a2) {
    unint64_t v7 = a2;
  }
  block[0] = _NSConcreteStackBlock;
  block[1] = 1174405120LL;
  block[2] = sub_100049998;
  block[3] = &unk_1000CFFB0;
  void block[4] = v7;
  void block[5] = a2;
  sub_100007B8C((uint64_t)v12, a3);
  dispatch_apply(v5, 0LL, block);
  __n128 result = v13;
  if (v13 == v12)
  {
    uint64_t v9 = 4LL;
    __n128 result = v12;
  }

  else
  {
    if (!v13) {
      return result;
    }
    uint64_t v9 = 5LL;
  }

  return (void *)(*(uint64_t (**)(void))(*result + 8 * v9))();
}

uint64_t sub_100049998(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(result + 32);
  unint64_t v3 = v2 * a2;
  unint64_t v4 = v2 * a2 + v2;
  if (*(void *)(result + 40) >= v4) {
    unint64_t v5 = v4;
  }
  else {
    unint64_t v5 = *(void *)(result + 40);
  }
  if (v3 < v5)
  {
    uint64_t v7 = result + 48;
    do
      __n128 result = sub_1000499F8(v7, v3++, a2);
    while (v5 != v3);
  }

  return result;
}

uint64_t sub_1000499F8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = a3;
  uint64_t v6 = a2;
  uint64_t v3 = *(void *)(a1 + 24);
  if (!v3) {
    sub_100007B40();
  }
  return (*(uint64_t (**)(uint64_t, uint64_t *, uint64_t *))(*(void *)v3 + 48LL))(v3, &v6, &v5);
}

uint64_t sub_100049A34(uint64_t a1, uint64_t a2)
{
  return sub_100007B8C(a1 + 48, a2 + 48);
}

void *sub_100049A40(uint64_t a1)
{
  uint64_t v1 = (void *)(a1 + 48);
  __n128 result = *(void **)(a1 + 72);
  if (result == v1)
  {
    uint64_t v3 = 4LL;
    __n128 result = v1;
  }

  else
  {
    if (!result) {
      return result;
    }
    uint64_t v3 = 5LL;
  }

  return (void *)(*(uint64_t (**)(void))(*result + 8 * v3))();
}

id sub_100049B18(uint64_t a1)
{
  return [*(id *)(a1 + 32) createCaesuraSPG];
}

void sub_100049CC8(uint64_t a1)
{
  id v2 = (id)objc_claimAutoreleasedReturnValue( +[NSData dataWithBytes:length:]( &OBJC_CLASS___NSData,  "dataWithBytes:length:",  *(void *)(a1 + 40),  2LL * *(int *)(a1 + 48)));
  [*(id *)(*(void *)(a1 + 32) + 32) addAudio:v2 numSamples:*(int *)(a1 + 48)];
}

id RDOSDInit(uint64_t a1)
{
  return -[EARCaesuraSPGHelper initWithDelegate:]( objc_alloc(&OBJC_CLASS___EARCaesuraSPGHelper),  "initWithDelegate:",  a1);
}

id RDOSDAddAudioSamples(void *a1, uint64_t a2, uint64_t a3)
{
  return _[a1 addAudio:a2 count:a3];
}

uint64_t variable initialization expression of RDSwiftSpeechDonation.taskHint()
{
  return 0LL;
}

uint64_t variable initialization expression of RDSwiftSpeechDonation.file()
{
  return 0LL;
}

uint64_t variable initialization expression of RDSwiftSpeechDonation.logger()
{
  int v0 = (uint64_t *)sub_10004C1C8();
  uint64_t v1 = *v0;
  uint64_t v2 = v0[1];
  swift_bridgeObjectRetain(v2);
  uint64_t v3 = sub_10004C1FC();
  uint64_t v4 = *v3;
  uint64_t v5 = v3[1];
  swift_bridgeObjectRetain(v5);
  return Logger.init(subsystem:category:)(v1, v2, v4, v5);
}

id RDSwiftSpeechDonation.__allocating_init(donorBundleID:donorReferenceID:recordingDate:locale:taskHint:transcription:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  id v18 = objc_allocWithZone(v10);
  return RDSwiftSpeechDonation.init(donorBundleID:donorReferenceID:recordingDate:locale:taskHint:transcription:)( a1,  a2,  a3,  a4,  a5,  a6,  a7,  a8,  a9,  a10);
}

id RDSwiftSpeechDonation.init(donorBundleID:donorReferenceID:recordingDate:locale:taskHint:transcription:)( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  uint64_t v14 = &v10[OBJC_IVAR____TtC50com_apple_SpeechRecognitionCore_speechrecognitiond21RDSwiftSpeechDonation_taskHint];
  *(void *)uint64_t v14 = 0LL;
  v14[8] = 1;
  *(void *)&v10[OBJC_IVAR____TtC50com_apple_SpeechRecognitionCore_speechrecognitiond21RDSwiftSpeechDonation_audioFormat] = 0LL;
  *(void *)&v10[OBJC_IVAR____TtC50com_apple_SpeechRecognitionCore_speechrecognitiond21RDSwiftSpeechDonation_file] = 0LL;
  float v15 = v10;
  float v16 = (uint64_t *)sub_10004C1C8();
  uint64_t v17 = *v16;
  uint64_t v18 = v16[1];
  swift_bridgeObjectRetain(v18);
  unint64_t v19 = sub_10004C1FC();
  uint64_t v21 = *v19;
  uint64_t v20 = v19[1];
  swift_bridgeObjectRetain(v20);
  uint64_t v22 = v18;
  uint64_t v23 = a8;
  Logger.init(subsystem:category:)(v17, v22, v21, v20);
  uint64_t v24 = &v15[OBJC_IVAR____TtC50com_apple_SpeechRecognitionCore_speechrecognitiond21RDSwiftSpeechDonation_donorReferenceID];
  *(void *)uint64_t v24 = a3;
  *((void *)v24 + 1) = a4;
  xpc_object_t v25 = &v15[OBJC_IVAR____TtC50com_apple_SpeechRecognitionCore_speechrecognitiond21RDSwiftSpeechDonation_donorBundleID];
  *(void *)xpc_object_t v25 = a1;
  *((void *)v25 + 1) = a2;
  unint64_t v26 = &v15[OBJC_IVAR____TtC50com_apple_SpeechRecognitionCore_speechrecognitiond21RDSwiftSpeechDonation_recordingDate];
  uint64_t v27 = type metadata accessor for Date(0LL);
  uint64_t v28 = *(void *)(v27 - 8);
  (*(void (**)(char *, uint64_t, uint64_t))(v28 + 16))(v26, a5, v27);
  float v29 = &v15[OBJC_IVAR____TtC50com_apple_SpeechRecognitionCore_speechrecognitiond21RDSwiftSpeechDonation_locale];
  uint64_t v30 = type metadata accessor for Locale(0LL);
  uint64_t v31 = *(void *)(v30 - 8);
  (*(void (**)(char *, uint64_t, uint64_t))(v31 + 16))(v29, a6, v30);
  std::string v33 = &v15[OBJC_IVAR____TtC50com_apple_SpeechRecognitionCore_speechrecognitiond21RDSwiftSpeechDonation_transcription];
  *(void *)std::string v33 = a9;
  *((void *)v33 + 1) = a10;
  uint64_t v34 = &v15[OBJC_IVAR____TtC50com_apple_SpeechRecognitionCore_speechrecognitiond21RDSwiftSpeechDonation_audioPath];
  *(void *)uint64_t v34 = 0xD000000000000015LL;
  *((void *)v34 + 1) = 0x80000001000BF120LL;
  if (a7 == 0x6F69746174636944LL && v23 == 0xEB0000000043436ELL
    || (_stringCompareWithSmolCheck(_:_:expecting:)(0x6F69746174636944LL, 0xEB0000000043436ELL, a7, v23, 0LL) & 1) != 0)
  {
    swift_bridgeObjectRelease(v23, v32);
    uint64_t v35 = 1005LL;
  }

  else if (a7 == 0x43436C6C657053LL && v23 == 0xE700000000000000LL)
  {
    swift_bridgeObjectRelease(0xE700000000000000LL, v32);
    uint64_t v35 = 1006LL;
  }

  else
  {
    char v38 = _stringCompareWithSmolCheck(_:_:expecting:)(0x43436C6C657053LL, 0xE700000000000000LL, a7, v23, 0LL);
    swift_bridgeObjectRelease(v23, v39);
    uint64_t v35 = 1005LL;
    if ((v38 & 1) != 0) {
      uint64_t v35 = 1006LL;
    }
  }

  *(void *)uint64_t v14 = v35;
  v14[8] = 0;

  v45.receiver = v15;
  v45.super_class = (Class)type metadata accessor for RDSwiftSpeechDonation(0LL);
  id v36 = objc_msgSendSuper2(&v45, "init");
  (*(void (**)(uint64_t, uint64_t))(v31 + 8))(a6, v30);
  (*(void (**)(uint64_t, uint64_t))(v28 + 8))(a5, v27);
  return v36;
}

Swift::Void __swiftcall RDSwiftSpeechDonation.donate(audioBuffers:logAudioFile:)( Swift::OpaquePointer audioBuffers, Swift::Bool logAudioFile)
{
  BOOL v59 = logAudioFile;
  rawValue = audioBuffers._rawValue;
  sub_10004B5C0(&qword_1000DD628);
  ((void (*)(void))__chkstk_darwin)();
  uint64_t v57 = (char *)&v46 - ((v3 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  sub_10004B5C0(&qword_1000DD630);
  ((void (*)(void))__chkstk_darwin)();
  uint64_t v58 = (char *)&v46 - ((v4 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  sub_10004B5C0(&qword_1000DD638);
  ((void (*)(void))__chkstk_darwin)();
  uint64_t v6 = (char *)&v46 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  int v47 = v6;
  uint64_t v7 = type metadata accessor for Locale(0LL);
  uint64_t v8 = *(void *)(v7 - 8);
  ((void (*)(void))__chkstk_darwin)();
  double v10 = (char *)&v46 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  int v50 = v10;
  uint64_t v11 = type metadata accessor for Date(0LL);
  uint64_t v12 = *(void *)(v11 - 8);
  ((void (*)(void))__chkstk_darwin)();
  uint64_t v14 = (char *)&v46 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  std::string::size_type v51 = v14;
  uint64_t v15 = type metadata accessor for SpeechDonation(0LL);
  uint64_t v53 = *(void *)(v15 - 8);
  uint64_t v54 = v15;
  uint64_t v16 = *(void *)(v53 + 64);
  uint64_t v17 = ((uint64_t (*)(void))__chkstk_darwin)();
  uint64_t v55 = (char *)&v46 - ((v16 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  __chkstk_darwin(v17);
  unint64_t v19 = (char *)&v46 - v18;
  uint64_t v20 = *(void *)&v2[OBJC_IVAR____TtC50com_apple_SpeechRecognitionCore_speechrecognitiond21RDSwiftSpeechDonation_donorBundleID
                     + 8];
  uint64_t v52 = *(void *)&v2[OBJC_IVAR____TtC50com_apple_SpeechRecognitionCore_speechrecognitiond21RDSwiftSpeechDonation_donorBundleID];
  uint64_t v48 = v20;
  (*(void (**)(char *, _BYTE *, uint64_t))(v12 + 16))( v14,  &v2[OBJC_IVAR____TtC50com_apple_SpeechRecognitionCore_speechrecognitiond21RDSwiftSpeechDonation_recordingDate],  v11);
  (*(void (**)(char *, _BYTE *, uint64_t))(v8 + 16))( v10,  &v2[OBJC_IVAR____TtC50com_apple_SpeechRecognitionCore_speechrecognitiond21RDSwiftSpeechDonation_locale],  v7);
  uint64_t v21 = *(void *)&v2[OBJC_IVAR____TtC50com_apple_SpeechRecognitionCore_speechrecognitiond21RDSwiftSpeechDonation_transcription
                     + 8];
  uint64_t v49 = *(void *)&v2[OBJC_IVAR____TtC50com_apple_SpeechRecognitionCore_speechrecognitiond21RDSwiftSpeechDonation_transcription];
  uint64_t v22 = type metadata accessor for SpeechDonation.TranscriptionEvaluation(0LL);
  (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(*(void *)(v22 - 8) + 56LL))(v6, 1LL, 1LL, v22);
  uint64_t v23 = *(void *)&v2[OBJC_IVAR____TtC50com_apple_SpeechRecognitionCore_speechrecognitiond21RDSwiftSpeechDonation_taskHint];
  LOBYTE(v12) = v2[OBJC_IVAR____TtC50com_apple_SpeechRecognitionCore_speechrecognitiond21RDSwiftSpeechDonation_taskHint
                 + 8];
  uint64_t v24 = type metadata accessor for SpeechDonation.AudioSource(0LL);
  xpc_object_t v25 = v58;
  (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(*(void *)(v24 - 8) + 56LL))(v58, 1LL, 1LL, v24);
  uint64_t v26 = v48;
  swift_bridgeObjectRetain(v48);
  uint64_t v27 = rawValue;
  swift_bridgeObjectRetain(rawValue);
  swift_bridgeObjectRetain(v21);
  uint64_t v28 = v54;
  uint64_t v45 = v23;
  uint64_t v29 = v53;
  SpeechDonation.init(donorBundleID:recordingDate:audioBuffers:locale:transcription:evaluation:speechAttributes:taskHint:audioSource:donorReferenceID:)( v52,  v26,  v51,  v27,  v50,  v49,  v21,  v47,  &_swiftEmptySetSingleton,  v45,  (_BYTE)v12,  v25,  0LL,  0LL);
  uint64_t v30 = type metadata accessor for TaskPriority(0LL);
  uint64_t v31 = (uint64_t)v57;
  (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(*(void *)(v30 - 8) + 56LL))(v57, 1LL, 1LL, v30);
  uint64_t v32 = *(void (**)(char *, char *, uint64_t))(v29 + 16);
  std::string v33 = v55;
  uint64_t v58 = v19;
  v32(v55, v19, v28);
  uint64_t v34 = *(unsigned __int8 *)(v29 + 80);
  uint64_t v35 = (v34 + 32) & ~v34;
  unint64_t v36 = (v35 + v16 + 7) & 0xFFFFFFFFFFFFFFF8LL;
  unint64_t v37 = (v35 + v16 + 23) & 0xFFFFFFFFFFFFFFF8LL;
  uint64_t v38 = swift_allocObject(&unk_1000D0040, v37 + 8, v34 | 7);
  *(void *)(v38 + 16) = 0LL;
  *(void *)(v38 + ++*(void *)(result + 24) = 0LL;
  (*(void (**)(uint64_t, char *, uint64_t))(v29 + 32))(v38 + v35, v33, v28);
  unint64_t v39 = v38 + v36;
  *(void *)unint64_t v39 = v2;
  *(_BYTE *)(v39 + _Block_object_dispose(va, 8) = v59;
  *(void *)(v38 + v37) = v27;
  swift_bridgeObjectRetain(v27);
  v2;
  uint64_t v40 = sub_10004ABD0(v31, (uint64_t)&unk_1000DD648, v38);
  uint64_t v41 = swift_release(v40);
  uint64_t v42 = (os_log_s *)Logger.logObject.getter(v41);
  os_log_type_t v43 = static os_log_type_t.debug.getter();
  if (os_log_type_enabled(v42, v43))
  {
    char v44 = (uint8_t *)swift_slowAlloc(2LL, -1LL);
    *(_WORD *)char v44 = 0;
    _os_log_impl((void *)&_mh_execute_header, v42, v43, "donated speech buffers", v44, 2u);
    swift_slowDealloc(v44, -1LL, -1LL);
  }

  (*(void (**)(char *, uint64_t))(v29 + 8))(v58, v28);
}

uint64_t sub_10004A820(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, char a6, uint64_t a7)
{
  *(_BYTE *)(v7 + 72) = a6;
  *(void *)(v7 + ++*(void *)(result + 24) = a5;
  *(void *)(v7 + 32) = a7;
  unint64_t v8 = (*(void *)(*(void *)(sub_10004B5C0(&qword_1000DD698) - 8) + 64LL) + 15LL) & 0xFFFFFFFFFFFFFFF0LL;
  *(void *)(v7 + 4RDString::RDString((RDString *)&v66, theString, 0) = swift_task_alloc(v8);
  *(void *)(v7 + 4_Block_object_dispose(va, 8) = swift_task_alloc(v8);
  uint64_t v9 = swift_task_alloc(v8);
  *(void *)(v7 + ++*(void *)(result + 56) = v9;
  double v10 = (void *)swift_task_alloc(async function pointer to SpeechDonation.donate()[1]);
  *(void *)(v7 + 64) = v10;
  *double v10 = v7;
  v10[1] = sub_10004A8C0;
  return SpeechDonation.donate()(v9);
}

uint64_t sub_10004A8C0()
{
  return swift_task_switch(sub_10004A914, 0LL, 0LL);
}

uint64_t sub_10004A914()
{
  uint64_t v1 = *(void *)(v0 + 56);
  uint64_t v2 = type metadata accessor for UUID(0LL);
  uint64_t v3 = *(void *)(v2 - 8);
  uint64_t v4 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v3 + 48);
  uint64_t v5 = v4(v1, 1LL, v2);
  if ((_DWORD)v5 == 1)
  {
    uint64_t v6 = (os_log_s *)Logger.logObject.getter(v5);
    os_log_type_t v7 = static os_log_type_t.default.getter();
    if (os_log_type_enabled(v6, v7))
    {
      unint64_t v8 = (uint8_t *)swift_slowAlloc(2LL, -1LL);
      *(_WORD *)unint64_t v8 = 0;
      _os_log_impl((void *)&_mh_execute_header, v6, v7, "VoiceControl::SpeechDonation::DonationID is nil", v8, 2u);
      swift_slowDealloc(v8, -1LL, -1LL);
    }

LABEL_11:
    uint64_t v22 = *(void *)(v0 + 48);
    uint64_t v23 = *(void *)(v0 + 56);
    uint64_t v24 = *(void *)(v0 + 40);
    sub_10004BA28(v23, &qword_1000DD698);
    swift_task_dealloc(v23);
    swift_task_dealloc(v22);
    swift_task_dealloc(v24);
    return (*(uint64_t (**)(void))(v0 + 8))();
  }

  uint64_t v9 = sub_10004BA64(v1, *(void *)(v0 + 48));
  double v10 = (os_log_s *)Logger.logObject.getter(v9);
  os_log_type_t v11 = static os_log_type_t.default.getter();
  BOOL v12 = os_log_type_enabled(v10, v11);
  uint64_t v13 = *(void *)(v0 + 48);
  if (!v12)
  {

    sub_10004BA28(v13, &qword_1000DD698);
LABEL_9:
    if (*(_BYTE *)(v0 + 72) == 1) {
      sub_10004AD7C(*(void *)(v0 + 32));
    }
    goto LABEL_11;
  }

  os_log_type_t v27 = v11;
  uint64_t v14 = *(void *)(v0 + 40);
  uint64_t v15 = (uint8_t *)swift_slowAlloc(12LL, -1LL);
  uint64_t v26 = swift_slowAlloc(32LL, -1LL);
  uint64_t v28 = v26;
  *(_DWORD *)uint64_t v15 = 136315138;
  sub_10004BA64(v13, v14);
  uint64_t result = v4(v14, 1LL, v2);
  if ((_DWORD)result != 1)
  {
    uint64_t v17 = *(void *)(v0 + 40);
    uint64_t v25 = *(void *)(v0 + 48);
    uint64_t v18 = UUID.uuidString.getter();
    unint64_t v20 = v19;
    (*(void (**)(uint64_t, uint64_t))(v3 + 8))(v17, v2);
    *(void *)(v0 + 16) = sub_10004BAAC(v18, v20, &v28);
    UnsafeMutableRawBufferPointer.copyMemory(from:)(v0 + 16, v0 + 24, v15 + 4);
    swift_bridgeObjectRelease(v20, v21);
    sub_10004BA28(v25, &qword_1000DD698);
    _os_log_impl((void *)&_mh_execute_header, v10, v27, "VoiceControl::SpeechDonation::DonationID=%s", v15, 0xCu);
    swift_arrayDestroy(v26, 1LL, (char *)&type metadata for Any + 8);
    swift_slowDealloc(v26, -1LL, -1LL);
    swift_slowDealloc(v15, -1LL, -1LL);

    goto LABEL_9;
  }

  __break(1u);
  return result;
}

uint64_t sub_10004ABD0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = type metadata accessor for TaskPriority(0LL);
  uint64_t v7 = *(void *)(v6 - 8);
  if ((*(unsigned int (**)(uint64_t, uint64_t, uint64_t))(v7 + 48))(a1, 1LL, v6) == 1)
  {
    sub_10004BA28(a1, &qword_1000DD628);
    uint64_t v8 = 7168LL;
    uint64_t v9 = *(void *)(a3 + 16);
    if (v9)
    {
LABEL_3:
      uint64_t v10 = *(void *)(a3 + 24);
      uint64_t ObjectType = swift_getObjectType(v9);
      swift_unknownObjectRetain(v9);
      uint64_t v12 = dispatch thunk of Actor.unownedExecutor.getter(ObjectType, v10);
      uint64_t v14 = v13;
      swift_unknownObjectRelease(v9);
      goto LABEL_6;
    }
  }

  else
  {
    unsigned __int8 v15 = TaskPriority.rawValue.getter();
    (*(void (**)(uint64_t, uint64_t))(v7 + 8))(a1, v6);
    uint64_t v8 = v15 | 0x1C00LL;
    uint64_t v9 = *(void *)(a3 + 16);
    if (v9) {
      goto LABEL_3;
    }
  }

  uint64_t v12 = 0LL;
  uint64_t v14 = 0LL;
LABEL_6:
  uint64_t v16 = swift_allocObject(&unk_1000D0140, 32LL, 7LL);
  *(void *)(v16 + 16) = a2;
  *(void *)(v16 + ++*(void *)(result + 24) = a3;
  if (v14 | v12)
  {
    v19[0] = 0LL;
    v19[1] = 0LL;
    uint64_t v17 = v19;
    v19[2] = v12;
    v19[3] = v14;
  }

  else
  {
    uint64_t v17 = 0LL;
  }

  return swift_task_create(v8, v17, (char *)&type metadata for () + 8, &unk_1000DD690, v16);
}

id sub_10004AD7C(uint64_t a1)
{
  uint64_t v3 = v1;
  uint64_t v5 = type metadata accessor for URL(0LL);
  unint64_t v6 = *(void *)(v5 - 8);
  uint64_t v7 = __chkstk_darwin(v5);
  uint64_t v9 = (char *)&v55 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v10 = __chkstk_darwin(v7);
  uint64_t v12 = (char *)&v55 - v11;
  __chkstk_darwin(v10);
  uint64_t v14 = (char *)&v55 - v13;
  uint64_t v15 = OBJC_IVAR____TtC50com_apple_SpeechRecognitionCore_speechrecognitiond21RDSwiftSpeechDonation_file;
  uint64_t v16 = *(void *)(v3 + OBJC_IVAR____TtC50com_apple_SpeechRecognitionCore_speechrecognitiond21RDSwiftSpeechDonation_file);
  uint64_t v55 = v3;
  uint64_t v56 = OBJC_IVAR____TtC50com_apple_SpeechRecognitionCore_speechrecognitiond21RDSwiftSpeechDonation_file;
  uint64_t v57 = a1;
  if (v16) {
    goto LABEL_12;
  }
  uint64_t v17 = *(void *)(v3
                  + OBJC_IVAR____TtC50com_apple_SpeechRecognitionCore_speechrecognitiond21RDSwiftSpeechDonation_audioPath);
  uint64_t v18 = *(void *)(v3
                  + OBJC_IVAR____TtC50com_apple_SpeechRecognitionCore_speechrecognitiond21RDSwiftSpeechDonation_audioPath
                  + 8);
  swift_bridgeObjectRetain(v18);
  URL.init(fileURLWithPath:isDirectory:)(v17, v18, 0LL);
  uint64_t v20 = swift_bridgeObjectRelease(v18, v19);
  URL.absoluteURL.getter(v20);
  uint64_t v2 = a1;
  a1 = *(void *)(v6 + 8);
  ((void (*)(char *, uint64_t))a1)(v12, v5);
  (*(void (**)(char *, char *, uint64_t))(v6 + 16))(v9, v14, v5);
  unint64_t v6 = v2 & 0xC000000000000001LL;
  if ((v2 & 0xC000000000000001LL) != 0) {
    goto LABEL_32;
  }
  if (!*(void *)((v2 & 0xFFFFFFFFFFFFF8LL) + 0x10)) {
    __break(1u);
  }
  for (id i = *(id *)(v2 + 32); ; id i = (id)specialized _ArrayBuffer._getElementSlowPath(_:)(0LL, v2))
  {
    uint64_t v22 = i;
    id v23 = objc_msgSend(i, "format", v55);

    id v24 = [v23 settings];
    uint64_t v25 = static Dictionary._unconditionallyBridgeFromObjectiveC(_:)( v24,  &type metadata for String,  (char *)&type metadata for Any + 8,  &protocol witness table for String);

    id v26 = v6 ? (id)specialized _ArrayBuffer._getElementSlowPath(_:)(0LL, v57) : *(id *)(v57 + 32);
    os_log_type_t v27 = v26;
    id v28 = [v26 format];

    id v29 = [v28 commonFormat];
    id v30 = v6 ? (id)specialized _ArrayBuffer._getElementSlowPath(_:)(0LL, v57) : *(id *)(v57 + 32);
    uint64_t v31 = v30;
    id v32 = [v30 format];

    LOBYTE(v31) = [v32 isInterleaved];
    id v33 = objc_allocWithZone(&OBJC_CLASS___AVAudioFile);
    uint64_t v34 = (uint64_t)v9;
    uint64_t v9 = 0LL;
    id v35 = sub_10004B428(v34, v25, (uint64_t)v29, (char)v31);
    uint64_t v3 = v55;
    uint64_t v15 = v56;
    unint64_t v36 = *(void **)(v55 + v56);
    *(void *)(v55 + v++*(void *)(result + 56) = v35;

    ((void (*)(char *, uint64_t))a1)(v14, v5);
    a1 = v57;
LABEL_12:
    if ((unint64_t)a1 >> 62)
    {
      if (a1 < 0) {
        uint64_t v53 = a1;
      }
      else {
        uint64_t v53 = a1 & 0xFFFFFFFFFFFFFF8LL;
      }
      swift_bridgeObjectRetain(a1);
      uint64_t v5 = _CocoaArrayWrapper.endIndex.getter(v53);
      if (!v5) {
        goto LABEL_30;
      }
    }

    else
    {
      uint64_t v5 = *(void *)((a1 & 0xFFFFFFFFFFFFF8LL) + 0x10);
      swift_bridgeObjectRetain(a1);
      if (!v5) {
        goto LABEL_30;
      }
    }

    if (v5 >= 1) {
      break;
    }
    __break(1u);
LABEL_32:
    ;
  }

  uint64_t v38 = 0LL;
  unint64_t v39 = a1 & 0xC000000000000001LL;
  do
  {
    if (v39) {
      uint64_t v41 = (os_log_s *)specialized _ArrayBuffer._getElementSlowPath(_:)(v38, a1);
    }
    else {
      uint64_t v41 = (os_log_s *)*(id *)(a1 + 8 * v38 + 32);
    }
    uint64_t v42 = v41;
    os_log_type_t v43 = *(void **)(v3 + v15);
    if (v43)
    {
      id v58 = 0LL;
      unsigned int v44 = [v43 writeFromBuffer:v42 error:&v58];
      id v45 = v58;
      if (v44)
      {
        id v40 = v58;
      }

      else
      {
        id v46 = v58;
        uint64_t v47 = _convertNSErrorToError(_:)(v45);

        uint64_t v48 = swift_willThrow();
        uint64_t v49 = (os_log_s *)Logger.logObject.getter(v48);
        os_log_type_t v50 = static os_log_type_t.default.getter();
        if (os_log_type_enabled(v49, v50))
        {
          std::string::size_type v51 = (uint8_t *)swift_slowAlloc(2LL, -1LL);
          *(_WORD *)std::string::size_type v51 = 0;
          _os_log_impl( (void *)&_mh_execute_header,  v49,  v50,  "VoiceControl::SpeechDonation::DonationID, error writing to file",  v51,  2u);
          uint64_t v52 = v51;
          uint64_t v3 = v55;
          swift_slowDealloc(v52, -1LL, -1LL);
        }

        swift_errorRelease(v47);
        uint64_t v42 = v49;
        uint64_t v15 = v56;
        a1 = v57;
      }
    }

    ++v38;
  }

  while (v5 != v38);
LABEL_30:
  swift_bridgeObjectRelease(a1, v37);
  return [*(id *)(v3 + v15) close];
}

id RDSwiftSpeechDonation.__allocating_init()()
{
  return [objc_allocWithZone(v0) init];
}

void RDSwiftSpeechDonation.init()()
{
}

id RDSwiftSpeechDonation.__deallocating_deinit()
{
  v2.receiver = v0;
  v2.super_class = (Class)type metadata accessor for RDSwiftSpeechDonation(0LL);
  return objc_msgSendSuper2(&v2, "dealloc");
}

id sub_10004B428(uint64_t a1, uint64_t a2, uint64_t a3, char a4)
{
  uint64_t v5 = v4;
  URL._bridgeToObjectiveC()(__stack_chk_guard);
  uint64_t v11 = v10;
  Class isa = Dictionary._bridgeToObjectiveC()().super.isa;
  swift_bridgeObjectRelease(a2, v13);
  id v22 = 0LL;
  id v14 = [v5 initForWriting:v11 settings:isa commonFormat:a3 interleaved:a4 & 1 error:&v22];

  id v15 = v22;
  if (v14)
  {
    uint64_t v16 = type metadata accessor for URL(0LL);
    uint64_t v17 = *(void (**)(uint64_t, uint64_t))(*(void *)(v16 - 8) + 8LL);
    id v18 = v15;
    v17(a1, v16);
  }

  else
  {
    id v19 = v22;
    _convertNSErrorToError(_:)(v15);

    swift_willThrow();
    uint64_t v20 = type metadata accessor for URL(0LL);
    (*(void (**)(uint64_t, uint64_t))(*(void *)(v20 - 8) + 8LL))(a1, v20);
  }

  return v14;
}

uint64_t type metadata accessor for RDSwiftSpeechDonation(uint64_t a1)
{
  uint64_t result = qword_1000DDE60;
  if (!qword_1000DDE60) {
    return swift_getSingletonMetadata(a1, &nominal type descriptor for RDSwiftSpeechDonation);
  }
  return result;
}

uint64_t sub_10004B5C0(uint64_t *a1)
{
  uint64_t result = *a1;
  if (result < 0)
  {
    uint64_t result = swift_getTypeByMangledNameInContext2((char *)a1 + (int)result, -(result >> 32), 0LL, 0LL);
    *a1 = result;
  }

  return result;
}

uint64_t sub_10004B600()
{
  uint64_t v1 = type metadata accessor for SpeechDonation(0LL);
  uint64_t v2 = *(void *)(v1 - 8);
  uint64_t v3 = *(unsigned __int8 *)(v2 + 80);
  uint64_t v4 = (v3 + 32) & ~v3;
  uint64_t v5 = v4 + *(void *)(v2 + 64);
  uint64_t v6 = v3 | 7;
  uint64_t v7 = (v5 + 7) & 0xFFFFFFFFFFFFF8LL;
  unint64_t v8 = (v5 + 23) & 0xFFFFFFFFFFFFFFF8LL;
  swift_unknownObjectRelease(*(void *)(v0 + 16));
  (*(void (**)(uint64_t, uint64_t))(v2 + 8))(v0 + v4, v1);

  swift_bridgeObjectRelease(*(void *)(v0 + v8), v9);
  return swift_deallocObject(v0, v8 + 8, v6);
}

uint64_t sub_10004B6A0()
{
  uint64_t v2 = *(void *)(type metadata accessor for SpeechDonation(0LL) - 8);
  unint64_t v3 = (*(unsigned __int8 *)(v2 + 80) + 32LL) & ~(unint64_t)*(unsigned __int8 *)(v2 + 80);
  unint64_t v4 = v3 + *(void *)(v2 + 64);
  unint64_t v5 = (v4 + 7) & 0xFFFFFFFFFFFFFFF8LL;
  uint64_t v6 = v0 + v3;
  uint64_t v7 = *(void *)(v0 + v5);
  char v8 = *(_BYTE *)(v0 + v5 + 8);
  uint64_t v9 = *(void *)(v0 + ((v4 + 23) & 0xFFFFFFFFFFFFF8LL));
  uint64_t v10 = (void *)swift_task_alloc(dword_1000DD644);
  *(void *)(v1 + 16) = v10;
  *uint64_t v10 = v1;
  v10[1] = sub_10004B740;
  return sub_10004A820((uint64_t)v10, v11, v12, v6, v7, v8, v9);
}

uint64_t sub_10004B740()
{
  uint64_t v4 = *v0;
  uint64_t v1 = *(void *)(v4 + 16);
  uint64_t v2 = *v0;
  uint64_t v4 = v2;
  swift_task_dealloc(v1);
  return (*(uint64_t (**)(void))(v2 + 8))();
}

uint64_t sub_10004B788()
{
  return type metadata accessor for RDSwiftSpeechDonation(0LL);
}

uint64_t sub_10004B790(uint64_t a1)
{
  v6[0] = &unk_1000AC498;
  v6[1] = &unk_1000AC498;
  uint64_t result = type metadata accessor for Date(319LL);
  if (v3 <= 0x3F)
  {
    _DWORD v6[2] = *(void *)(result - 8) + 64LL;
    uint64_t result = type metadata accessor for Locale(319LL);
    if (v4 <= 0x3F)
    {
      v6[3] = *(void *)(result - 8) + 64LL;
      void v6[4] = &unk_1000AC4B0;
      v6[5] = &unk_1000AC4C8;
      v6[6] = &unk_1000AC498;
      v6[7] = &unk_1000AC4C8;
      uint8_t v6[8] = &unk_1000AC498;
      uint64_t result = type metadata accessor for Logger(319LL);
      if (v5 <= 0x3F)
      {
        v6[9] = *(void *)(result - 8) + 64LL;
        return swift_updateClassMetadata2(a1, 256LL, 10LL, v6, a1 + 80);
      }
    }
  }

  return result;
}

void type metadata accessor for SFSpeechRecognitionTaskHint()
{
  if (!qword_1000DD678)
  {
    unint64_t ForeignTypeMetadata = swift_getForeignTypeMetadata(0LL, &unk_1000D0120);
    if (!v1) {
      atomic_store(ForeignTypeMetadata, (unint64_t *)&qword_1000DD678);
    }
  }

unint64_t sub_10004B8A8()
{
  unint64_t result = qword_1000DD680;
  if (!qword_1000DD680)
  {
    uint64_t v1 = objc_opt_self(&OBJC_CLASS___AVAudioPCMBuffer);
    unint64_t result = swift_getObjCClassMetadata(v1);
    atomic_store(result, (unint64_t *)&qword_1000DD680);
  }

  return result;
}

uint64_t sub_10004B8E4(uint64_t a1, int *a2)
{
  uint64_t v6 = (uint64_t (*)(uint64_t))((char *)a2 + *a2);
  unint64_t v4 = (void *)swift_task_alloc(a2[1]);
  *(void *)(v2 + 16) = v4;
  *unint64_t v4 = v2;
  v4[1] = sub_10004B948;
  return v6(a1);
}

uint64_t sub_10004B948()
{
  uint64_t v2 = *v0;
  swift_task_dealloc(*(void *)(*v0 + 16));
  return (*(uint64_t (**)(void))(v2 + 8))();
}

uint64_t sub_10004B994()
{
  return swift_deallocObject(v0, 32LL, 7LL);
}

uint64_t sub_10004B9B8(uint64_t a1)
{
  unint64_t v4 = *(int **)(v1 + 16);
  unint64_t v5 = (void *)swift_task_alloc(dword_1000DD68C);
  *(void *)(v2 + 16) = v5;
  void *v5 = v2;
  v5[1] = sub_10004B740;
  return ((uint64_t (*)(uint64_t, int *))((char *)&dword_1000DD688 + dword_1000DD688))(a1, v4);
}

uint64_t sub_10004BA28(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = sub_10004B5C0(a2);
  (*(void (**)(uint64_t, uint64_t))(*(void *)(v3 - 8) + 8LL))(a1, v3);
  return a1;
}

uint64_t sub_10004BA64(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = sub_10004B5C0(&qword_1000DD698);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v4 - 8) + 16LL))(a2, a1, v4);
  return a2;
}

uint64_t sub_10004BAAC(uint64_t a1, unint64_t a2, uint64_t *a3)
{
  uint64_t v6 = sub_10004BB7C(v12, 0LL, 0LL, 1, a1, a2);
  uint64_t v7 = v12[0];
  if (v6)
  {
    uint64_t v8 = v6;
    uint64_t ObjectType = (void *)swift_getObjectType(v6);
    v12[0] = v8;
    uint64_t v9 = *a3;
    if (*a3)
    {
      sub_10004C10C((uint64_t)v12, *a3);
      *a3 = v9 + 32;
    }
  }

  else
  {
    uint64_t ObjectType = &type metadata for _StringGuts;
    v12[0] = a1;
    v12[1] = a2;
    uint64_t v10 = *a3;
    if (*a3)
    {
      sub_10004C10C((uint64_t)v12, *a3);
      *a3 = v10 + 32;
    }

    swift_bridgeObjectRetain(a2);
  }

  sub_10004C0EC(v12);
  return v7;
}

uint64_t sub_10004BB7C(uint64_t *a1, char *__dst, uint64_t a3, char a4, uint64_t a5, unint64_t a6)
{
  if ((a6 & 0x2000000000000000LL) != 0)
  {
    if ((a4 & 1) == 0)
    {
      if (__dst)
      {
        uint64_t v12 = HIBYTE(a6) & 0xF;
        if (a3 - (uint64_t)__dst > v12)
        {
          __src[0] = a5;
          __src[1] = a6 & 0xFFFFFFFFFFFFFFLL;
          if (__src >= (void *)&__dst[v12] || (char *)__src + v12 <= __dst)
          {
            memcpy(__dst, __src, HIBYTE(a6) & 0xF);
            UnsafeMutableRawBufferPointer.subscript.setter(0LL, HIBYTE(a6) & 0xF, __dst, a3);
            uint64_t result = 0LL;
            *a1 = (uint64_t)__dst;
            return result;
          }

          goto LABEL_17;
        }
      }
    }

LABEL_13:
    uint64_t result = sub_10004BD34(a5, a6);
    *a1 = v13;
    return result;
  }

  if ((a6 & 0x1000000000000000LL) != 0) {
    goto LABEL_13;
  }
  if ((a5 & 0x1000000000000000LL) != 0)
  {
    uint64_t v8 = (a6 & 0xFFFFFFFFFFFFFFFLL) + 32;
    goto LABEL_5;
  }

  uint64_t v8 = _StringObject.sharedUTF8.getter(a5, a6);
  if (!v8)
  {
    _assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  "Unexpectedly found nil while unwrapping an Optional value",  57LL,  2LL,  "Swift/StringTesting.swift",  25LL,  2,  151LL,  0);
    __break(1u);
LABEL_17:
    LOBYTE(v14) = 2;
    uint64_t result = _fatalErrorMessage(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  "UnsafeMutableRawPointer.initializeMemory overlapping range",  58LL,  2LL,  "Swift/UnsafeRawPointer.swift",  28LL,  v14,  1173LL,  0);
    __break(1u);
    return result;
  }

uint64_t sub_10004BD34(uint64_t a1, unint64_t a2)
{
  uint64_t v2 = (uint64_t)sub_10004BDC8(a1, a2);
  if ((swift_isUniquelyReferenced_nonNull_native() & 1) == 0) {
    uint64_t v2 = sub_10004BFA0(0, *(void *)(v2 + 16) + 1LL, 1, (char *)v2);
  }
  unint64_t v4 = *(void *)(v2 + 16);
  unint64_t v3 = *(void *)(v2 + 24);
  if (v4 >= v3 >> 1) {
    uint64_t v2 = sub_10004BFA0(v3 > 1, v4 + 1, 1, (char *)v2);
  }
  *(void *)(v2 + 16) = v4 + 1;
  *(_BYTE *)(v2 + 32 + RDQSREngine::MatchResult(this, v4) = 0;
  return v2;
}

void *sub_10004BDC8(uint64_t a1, unint64_t a2)
{
  if ((a2 & 0x1000000000000000LL) != 0) {
    goto LABEL_10;
  }
  if ((a2 & 0x2000000000000000LL) != 0) {
    uint64_t v4 = HIBYTE(a2) & 0xF;
  }
  else {
    uint64_t v4 = a1 & 0xFFFFFFFFFFFFLL;
  }
  if (v4)
  {
    while (1)
    {
      unint64_t v5 = sub_10004BF3C(v4, 0LL);
      if (v4 < 0) {
        break;
      }
      uint64_t v6 = v5;
      uint64_t v7 = _StringGuts.copyUTF8(into:)(v5 + 4, v4, a1, a2);
      if ((v8 & 1) != 0) {
        goto LABEL_14;
      }
      if (v7 == v4) {
        return v6;
      }
      LOBYTE(v1RDString::RDString((RDString *)&v66, theString, 0) = 2;
      _assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  "invalid Collection: less than 'count' elements in collection",  60LL,  2LL,  "Swift/ContiguousArrayBuffer.swift",  33LL,  v10,  1122LL,  0);
      __break(1u);
LABEL_10:
      uint64_t v4 = String.UTF8View._foreignCount()();
      if (!v4) {
        return &_swiftEmptyArrayStorage;
      }
    }

    LOBYTE(v1RDString::RDString((RDString *)&v66, theString, 0) = 2;
    _fatalErrorMessage(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  "UnsafeMutableBufferPointer with negative count",  46LL,  2LL,  "Swift/UnsafeBufferPointer.swift",  31LL,  v10,  71LL,  0);
    __break(1u);
LABEL_14:
    LOBYTE(v1RDString::RDString((RDString *)&v66, theString, 0) = 2;
    uint64_t result = (void *)_assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  "Insufficient space allocated to copy string contents",  52LL,  2LL,  "Swift/StringUTF8View.swift",  26LL,  v10,  430LL,  0);
    __break(1u);
  }

  else
  {
    return &_swiftEmptyArrayStorage;
  }

  return result;
}

void *sub_10004BF3C(uint64_t a1, uint64_t a2)
{
  if (a2 <= a1) {
    uint64_t v2 = a1;
  }
  else {
    uint64_t v2 = a2;
  }
  if (!v2) {
    return &_swiftEmptyArrayStorage;
  }
  uint64_t v4 = sub_10004B5C0(&qword_1000DD6A0);
  unint64_t v5 = (void *)swift_allocObject(v4, v2 + 32, 7LL);
  size_t v6 = j__malloc_size(v5);
  _OWORD v5[2] = a1;
  void v5[3] = 2 * v6 - 64;
  return v5;
}

uint64_t sub_10004BFA0(char a1, int64_t a2, char a3, char *a4)
{
  if ((a3 & 1) != 0)
  {
    unint64_t v6 = *((void *)a4 + 3);
    int64_t v7 = v6 >> 1;
    if ((uint64_t)(v6 >> 1) < a2)
    {
      if (v7 + 0x4000000000000000LL < 0)
      {
        __break(1u);
        goto LABEL_30;
      }

      int64_t v7 = v6 & 0xFFFFFFFFFFFFFFFELL;
    }
  }

  else
  {
    int64_t v7 = a2;
  }

  int64_t v8 = *((void *)a4 + 2);
  if (v7 <= v8) {
    int64_t v9 = *((void *)a4 + 2);
  }
  else {
    int64_t v9 = v7;
  }
  if (v9)
  {
    uint64_t v10 = sub_10004B5C0(&qword_1000DD6A0);
    uint64_t v11 = (char *)swift_allocObject(v10, v9 + 32, 7LL);
    size_t v12 = j__malloc_size(v11);
    *((void *)v11 + 2) = v8;
    *((void *)v11 + 3) = 2 * v12 - 64;
  }

  else
  {
    uint64_t v11 = (char *)&_swiftEmptyArrayStorage;
  }

  uint64_t v13 = v11 + 32;
  int v14 = a4 + 32;
  if ((a1 & 1) != 0)
  {
    if (v11 != a4 || v13 >= &v14[v8]) {
      memmove(v13, v14, v8);
    }
    *((void *)a4 + 2) = 0LL;
    goto LABEL_28;
  }

  if (v14 >= &v13[v8] || v13 >= &v14[v8])
  {
    memcpy(v13, v14, v8);
LABEL_28:
    swift_bridgeObjectRelease(a4, v14);
    return (uint64_t)v11;
  }

uint64_t sub_10004C0EC(void *a1)
{
  uint64_t v1 = *(void *)(a1[3] - 8LL);
  if ((*(_BYTE *)(v1 + 82) & 2) != 0) {
    return swift_release(*a1);
  }
  else {
    return (*(uint64_t (**)(void))(v1 + 8))();
  }
}

uint64_t sub_10004C10C(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a1 + 24);
  *(void *)(a2 + ++*(void *)(result + 24) = v3;
  (**(void (***)(uint64_t, uint64_t))(v3 - 8))(a2, a1);
  return a2;
}

void sub_10004C14C()
{
}

void sub_10004C15C()
{
  algn_1000DE798[5] = 0;
  *(_WORD *)&algn_1000DE798[6] = -5120;
}

uint64_t *sub_10004C188()
{
  if (qword_1000DDE70 != -1) {
    swift_once(&qword_1000DDE70, sub_10004C15C);
  }
  return &qword_1000DE790;
}

void *sub_10004C1C8()
{
  return &unk_1000D0158;
}

void sub_10004C1D4()
{
  qword_1000DE7A0 = 0x5041686365657053LL;
  *(void *)algn_1000DE7A8 = 0xE900000000000049LL;
}

uint64_t *sub_10004C1FC()
{
  if (qword_1000DDE78 != -1) {
    swift_once(&qword_1000DDE78, sub_10004C1D4);
  }
  return &qword_1000DE7A0;
}

id sub_10004C23C()
{
  id result = [objc_allocWithZone(AVAudioFormat) initWithCommonFormat:3 sampleRate:1 channels:0 interleaved:16000.0];
  if (result) {
    qword_1000DE7B0 = (uint64_t)result;
  }
  else {
    __break(1u);
  }
  return result;
}

uint64_t *sub_10004C28C()
{
  if (qword_1000DDE80 != -1) {
    swift_once(&qword_1000DDE80, sub_10004C23C);
  }
  return &qword_1000DE7B0;
}

uint64_t sub_10004C2CC()
{
  uint64_t v1 = (void *)(v0
                + OBJC_IVAR____TtC50com_apple_SpeechRecognitionCore_speechrecognitiond28RDSAPISwiftTranscriberModule__transcriberModule);
  swift_beginAccess( v0 + OBJC_IVAR____TtC50com_apple_SpeechRecognitionCore_speechrecognitiond28RDSAPISwiftTranscriberModule__transcriberModule,  v3,  0LL,  0LL);
  return swift_retain(*v1);
}

uint64_t sub_10004C314(uint64_t a1)
{
  uint64_t v3 = (uint64_t *)(v1
                 + OBJC_IVAR____TtC50com_apple_SpeechRecognitionCore_speechrecognitiond28RDSAPISwiftTranscriberModule__transcriberModule);
  swift_beginAccess(v3, v6, 1LL, 0LL);
  uint64_t v4 = *v3;
  *uint64_t v3 = a1;
  return swift_release(v4);
}

id sub_10004C364(uint64_t a1)
{
  uint64_t v3 = (char *)objc_allocWithZone(v1);
  *(void *)&v3[OBJC_IVAR____TtC50com_apple_SpeechRecognitionCore_speechrecognitiond28RDSAPISwiftTranscriberModule__transcriberModule] = a1;
  v5.receiver = v3;
  v5.super_class = v1;
  return objc_msgSendSuper2(&v5, "init");
}

id sub_10004C3B0(uint64_t a1)
{
  *(void *)&v1[OBJC_IVAR____TtC50com_apple_SpeechRecognitionCore_speechrecognitiond28RDSAPISwiftTranscriberModule__transcriberModule] = a1;
  v3.receiver = v1;
  v3.super_class = (Class)type metadata accessor for RDSAPISwiftTranscriberModule();
  return objc_msgSendSuper2(&v3, "init");
}

uint64_t type metadata accessor for RDSAPISwiftTranscriberModule()
{
  return objc_opt_self(&OBJC_CLASS____TtC50com_apple_SpeechRecognitionCore_speechrecognitiond28RDSAPISwiftTranscriberModule);
}

void RDSAPISwiftTranscriberModule.init()()
{
}

id RDSAPISwiftTranscriberModule.__deallocating_deinit()
{
  v2.receiver = v0;
  v2.super_class = (Class)type metadata accessor for RDSAPISwiftTranscriberModule();
  return objc_msgSendSuper2(&v2, "dealloc");
}

uint64_t variable initialization expression of RDSAPISwiftSpeechAnalyzer._logger()
{
  if (qword_1000DDE78 != -1) {
    swift_once(&qword_1000DDE78, sub_10004C1D4);
  }
  uint64_t v0 = qword_1000DE7A0;
  uint64_t v1 = *(void *)algn_1000DE7A8;
  swift_bridgeObjectRetain(*(void *)algn_1000DE7A8);
  return Logger.init(subsystem:category:)(0xD00000000000001FLL, 0x80000001000BF4D0LL, v0, v1);
}

uint64_t sub_10004C528@<X0>(uint64_t a1@<X8>)
{
  uint64_t v3 = v1 + OBJC_IVAR____TtC50com_apple_SpeechRecognitionCore_speechrecognitiond25RDSAPISwiftSpeechAnalyzer__logger;
  uint64_t v4 = type metadata accessor for Logger(0LL);
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v4 - 8) + 16LL))(a1, v3, v4);
}

void *sub_10004C56C()
{
  uint64_t v1 = (void **)(v0
               + OBJC_IVAR____TtC50com_apple_SpeechRecognitionCore_speechrecognitiond25RDSAPISwiftSpeechAnalyzer__delegate);
  swift_beginAccess( v0 + OBJC_IVAR____TtC50com_apple_SpeechRecognitionCore_speechrecognitiond25RDSAPISwiftSpeechAnalyzer__delegate,  v5,  0LL,  0LL);
  objc_super v2 = *v1;
  id v3 = v2;
  return v2;
}

void sub_10004C5B8(void *a1)
{
  id v3 = (void **)(v1
               + OBJC_IVAR____TtC50com_apple_SpeechRecognitionCore_speechrecognitiond25RDSAPISwiftSpeechAnalyzer__delegate);
  swift_beginAccess(v3, v5, 1LL, 0LL);
  uint64_t v4 = *v3;
  *id v3 = a1;
}

void *sub_10004C608(uint64_t a1)
{
  return &j__swift_endAccess;
}

uint64_t variable initialization expression of RDSAPISwiftSpeechAnalyzer._taskHint@<X0>(uint64_t a1@<X8>)
{
  return sub_10004C668((uint64_t (*)(void))&type metadata accessor for TaskHint, a1);
}

uint64_t variable initialization expression of RDSAPISwiftSpeechAnalyzer._analysisOptions@<X0>( uint64_t a1@<X8>)
{
  return sub_10004C668((uint64_t (*)(void))&type metadata accessor for AnalysisOptions, a1);
}

uint64_t sub_10004C668@<X0>(uint64_t (*a1)(void)@<X0>, uint64_t a2@<X8>)
{
  uint64_t v3 = a1(0LL);
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(v3 - 8) + 56LL))(a2, 1LL, 1LL, v3);
}

id RDSAPISwiftSpeechAnalyzer.__allocating_init(delegate:locale:highPriority:farField:supportEmojiRecognition:)( void *a1, void *a2, int a3, int a4, int a5)
{
  id v11 = objc_allocWithZone(v5);
  id v12 = sub_100056EBC(a1, (uint64_t)a2, a3, a4, a5);

  return v12;
}

id RDSAPISwiftSpeechAnalyzer.init(delegate:locale:highPriority:farField:supportEmojiRecognition:)( void *a1, void *a2, int a3, int a4, int a5)
{
  id v7 = sub_100056EBC(a1, (uint64_t)a2, a3, a4, a5);

  return v7;
}

id RDSAPISwiftSpeechAnalyzer.__deallocating_deinit(uint64_t a1)
{
  objc_super v2 = v1;
  uint64_t v3 = (os_log_s *)Logger.logObject.getter(a1);
  os_log_type_t v4 = static os_log_type_t.default.getter();
  if (os_log_type_enabled(v3, v4))
  {
    objc_super v5 = (uint8_t *)swift_slowAlloc(2LL, -1LL);
    *(_WORD *)objc_super v5 = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, v4, "SpeechAnalyzer deinit", v5, 2u);
    swift_slowDealloc(v5, -1LL, -1LL);
  }

  v7.receiver = v2;
  v7.super_class = (Class)type metadata accessor for RDSAPISwiftSpeechAnalyzer(0LL);
  return objc_msgSendSuper2(&v7, "dealloc");
}

uint64_t RDSAPISwiftSpeechAnalyzer.attachAnalysisContext()()
{
  *(void *)(v1 + ++*(void *)(result + 24) = v0;
  return swift_task_switch(sub_10004CAE0, 0LL, 0LL);
}

uint64_t sub_10004CAE0()
{
  uint64_t v1 = v0[3];
  uint64_t v2 = *(void *)(v1
                 + OBJC_IVAR____TtC50com_apple_SpeechRecognitionCore_speechrecognitiond25RDSAPISwiftSpeechAnalyzer__speechAnalyzer);
  v0[4] = v2;
  uint64_t v3 = *(void **)(v1
                + OBJC_IVAR____TtC50com_apple_SpeechRecognitionCore_speechrecognitiond25RDSAPISwiftSpeechAnalyzer__analysisContext);
  v0[5] = v3;
  uint64_t v4 = async function pointer to SpeechAnalyzer.setContext(_:)[1];
  swift_retain(v2);
  id v5 = v3;
  unint64_t v6 = (void *)swift_task_alloc(v4);
  v0[6] = v6;
  void *v6 = v0;
  v6[1] = sub_10004CB6C;
  return SpeechAnalyzer.setContext(_:)(v5);
}

uint64_t sub_10004CB6C()
{
  uint64_t v2 = *(void *)(*v1 + 48);
  uint64_t v3 = *v1;
  *(void *)(v3 + ++*(void *)(result + 56) = v0;
  swift_task_dealloc(v2);
  if (v0) {
    return swift_task_switch(sub_10004CBE8, 0LL, 0LL);
  }
  uint64_t v5 = *(void *)(v3 + 32);

  swift_release(v5);
  return (*(uint64_t (**)(void))(v3 + 8))();
}

uint64_t sub_10004CBE8()
{
  uint64_t v1 = *(void *)(v0 + 56);
  uint64_t v2 = *(void *)(v0 + 32);

  swift_release(v2);
  swift_errorRetain(v1);
  uint64_t v3 = swift_errorRetain(v1);
  uint64_t v4 = (os_log_s *)Logger.logObject.getter(v3);
  os_log_type_t v5 = static os_log_type_t.error.getter();
  if (os_log_type_enabled(v4, v5))
  {
    uint64_t v6 = *(void *)(v0 + 56);
    objc_super v7 = (uint8_t *)swift_slowAlloc(12LL, -1LL);
    int64_t v8 = (uint64_t *)swift_slowAlloc(8LL, -1LL);
    *(_DWORD *)objc_super v7 = 138412290;
    swift_errorRetain(v6);
    uint64_t v9 = _swift_stdlib_bridgeErrorToNSError(v6);
    *(void *)(v0 + 16) = v9;
    UnsafeMutableRawBufferPointer.copyMemory(from:)(v0 + 16, v0 + 24, v7 + 4);
    uint64_t *v8 = v9;
    swift_errorRelease(v6);
    swift_errorRelease(v6);
    _os_log_impl( (void *)&_mh_execute_header,  v4,  v5,  "Could not attach analysis context to SpeechAnalyzer = %@",  v7,  0xCu);
    uint64_t v10 = sub_10004B5C0(&qword_1000DD6D8);
    swift_arrayDestroy(v8, 1LL, v10);
    swift_slowDealloc(v8, -1LL, -1LL);
    swift_slowDealloc(v7, -1LL, -1LL);
    swift_errorRelease(v6);
  }

  else
  {
    uint64_t v11 = *(void *)(v0 + 56);
    swift_errorRelease(v11);

    swift_errorRelease(v11);
    swift_errorRelease(v11);
  }

  return (*(uint64_t (**)(void))(v0 + 8))();
}

uint64_t sub_10004CEB0(const void *a1, void *a2)
{
  v2[2] = a2;
  v2[3] = _Block_copy(a1);
  uint64_t v4 = dword_1000DD6D4;
  id v5 = a2;
  uint64_t v6 = (void *)swift_task_alloc(v4);
  v2[4] = v6;
  void *v6 = v2;
  v6[1] = sub_10004CF28;
  v6[3] = v5;
  return swift_task_switch(sub_10004CAE0, 0LL, 0LL);
}

uint64_t sub_10004CF28()
{
  uint64_t v1 = *(void (***)(void))(*v0 + 24);
  uint64_t v2 = *(void **)(*v0 + 16);
  uint64_t v4 = *v0;
  swift_task_dealloc(*(void *)(*v0 + 32));

  v1[2](v1);
  _Block_release(v1);
  return (*(uint64_t (**)(void))(v4 + 8))();
}

uint64_t sub_10004CF8C(uint64_t a1, uint64_t a2)
{
  v3[8] = a2;
  v3[9] = v2;
  v3[7] = a1;
  return swift_task_switch(sub_10004CFA8, 0LL, 0LL);
}

uint64_t sub_10004CFA8()
{
  Class super_class = v0[4].super_class;
  uint64_t v2 = *(uint64_t *)((char *)&super_class->isa
                  + OBJC_IVAR____TtC50com_apple_SpeechRecognitionCore_speechrecognitiond25RDSAPISwiftSpeechAnalyzer__recognitionTask);
  if (v2)
  {
    swift_retain(*(Class *)((char *)&super_class->isa
                          + OBJC_IVAR____TtC50com_apple_SpeechRecognitionCore_speechrecognitiond25RDSAPISwiftSpeechAnalyzer__recognitionTask));
    Task.cancel()();
    swift_release(v2);
  }

  id receiver = v0[4].receiver;
  v0[5].id receiver = (id)OBJC_IVAR____TtC50com_apple_SpeechRecognitionCore_speechrecognitiond25RDSAPISwiftSpeechAnalyzer__logger;
  uint64_t v4 = (os_log_s *)Logger.logObject.getter(receiver);
  os_log_type_t v5 = static os_log_type_t.default.getter();
  BOOL v6 = os_log_type_enabled(v4, v5);
  id v7 = v0[4].receiver;
  if (v6)
  {
    int64_t v8 = (uint8_t *)swift_slowAlloc(12LL, -1LL);
    uint64_t v9 = (void *)swift_slowAlloc(8LL, -1LL);
    *(_DWORD *)int64_t v8 = 138412290;
    v0[3].id receiver = v7;
    id v10 = v7;
    UnsafeMutableRawBufferPointer.copyMemory(from:)(&v0[3], &v0[3].super_class, v8 + 4);
    *uint64_t v9 = v7;

    _os_log_impl( (void *)&_mh_execute_header,  v4,  v5,  "SpeechAnalyzer previous recognition task cancelled for %@",  v8,  0xCu);
    uint64_t v11 = sub_10004B5C0(&qword_1000DD6D8);
    swift_arrayDestroy(v9, 1LL, v11);
    swift_slowDealloc(v9, -1LL, -1LL);
    swift_slowDealloc(v8, -1LL, -1LL);
  }

  else
  {

    uint64_t v4 = (os_log_s *)v7;
  }

  Class v12 = v0[4].super_class;
  Class v13 = v0[3].super_class;
  int v14 = (objc_class *)type metadata accessor for RDSAPISwiftTranscriberModule();
  id v15 = (char *)objc_allocWithZone(v14);
  *(void *)&v15[OBJC_IVAR____TtC50com_apple_SpeechRecognitionCore_speechrecognitiond28RDSAPISwiftTranscriberModule__transcriberModule] = v13;
  v0[1].id receiver = v15;
  v0[1].Class super_class = v14;
  swift_retain(v13);
  uint64_t v16 = (objc_class *)objc_msgSendSuper2(v0 + 1, "init");
  v0[5].Class super_class = v16;
  uint64_t v17 = (*(uint64_t (**)(void))((swift_isaMask & (uint64_t)v16->isa) + 0x58))();
  v0[6].id receiver = (id)v17;
  id v18 = *(Class *)((char *)&v12->isa
                 + OBJC_IVAR____TtC50com_apple_SpeechRecognitionCore_speechrecognitiond25RDSAPISwiftSpeechAnalyzer__speechAnalyzer);
  v0[6].Class super_class = v18;
  uint64_t v19 = sub_10004B5C0(&qword_1000DD780);
  uint64_t v20 = swift_allocObject(v19, 48LL, 7LL);
  v0[7].id receiver = (id)v20;
  *(_OWORD *)(v20 + 16) = xmmword_1000AC520;
  uint64_t v21 = sub_100058894( &qword_1000DD788,  (uint64_t (*)(uint64_t))&type metadata accessor for Transcriber,  (uint64_t)&protocol conformance descriptor for Transcriber);
  *(void *)(v20 + 32) = v17;
  *(void *)(v20 + 4RDString::RDString((RDString *)&v66, theString, 0) = v21;
  uint64_t v22 = async function pointer to SpeechAnalyzer.setModules(_:)[1];
  swift_retain(v18);
  swift_retain(v17);
  id v23 = (objc_super **)swift_task_alloc(v22);
  v0[7].Class super_class = (Class)v23;
  *id v23 = v0;
  v23[1] = (objc_super *)sub_10004D268;
  return SpeechAnalyzer.setModules(_:)(v20);
}

uint64_t sub_10004D268()
{
  uint64_t v2 = *v1;
  uint64_t v3 = *(void *)(*v1 + 120);
  *(void *)(*v1 + 12_Block_object_dispose(va, 8) = v0;
  swift_task_dealloc(v3);
  if (v0)
  {
    os_log_type_t v5 = sub_10004D310;
  }

  else
  {
    uint64_t v6 = *(void *)(v2 + 104);
    swift_bridgeObjectRelease(*(void *)(v2 + 112), v4);
    swift_release(v6);
    os_log_type_t v5 = sub_10004D2DC;
  }

  return swift_task_switch(v5, 0LL, 0LL);
}

uint64_t sub_10004D2DC()
{
  uint64_t v1 = *(void *)(v0 + 88);
  swift_release(*(void *)(v0 + 96));
  return (*(uint64_t (**)(uint64_t))(v0 + 8))(v1);
}

uint64_t sub_10004D310(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(v2 + 128);
  uint64_t v4 = *(void *)(v2 + 104);
  uint64_t v5 = *(void *)(v2 + 96);
  uint64_t v6 = *(void **)(v2 + 64);
  swift_bridgeObjectRelease(*(void *)(v2 + 112), a2);
  swift_release(v4);
  swift_release(v5);
  id v7 = v6;
  swift_errorRetain(v3);
  id v8 = v7;
  uint64_t v9 = swift_errorRetain(v3);
  id v10 = (os_log_s *)Logger.logObject.getter(v9);
  os_log_type_t v11 = static os_log_type_t.error.getter();
  if (os_log_type_enabled(v10, v11))
  {
    uint64_t v21 = *(void *)(v2 + 128);
    id v23 = *(void **)(v2 + 88);
    Class v12 = *(void **)(v2 + 64);
    log = v10;
    uint64_t v13 = swift_slowAlloc(22LL, -1LL);
    int v14 = (void *)swift_slowAlloc(16LL, -1LL);
    *(void *)(v2 + 32) = v12;
    *(_DWORD *)uint64_t v13 = 138412546;
    id v15 = v12;
    UnsafeMutableRawBufferPointer.copyMemory(from:)(v2 + 32, v2 + 40, v13 + 4);
    *int v14 = v12;

    *(_WORD *)(v13 + 12) = 2112;
    swift_errorRetain(v21);
    uint64_t v16 = _swift_stdlib_bridgeErrorToNSError(v21);
    *(void *)(v2 + 4RDString::RDString((RDString *)&v66, theString, 0) = v16;
    UnsafeMutableRawBufferPointer.copyMemory(from:)(v2 + 40, v2 + 48, v13 + 14);
    v14[1] = v16;
    swift_errorRelease(v21);
    swift_errorRelease(v21);
    _os_log_impl( (void *)&_mh_execute_header,  log,  v11,  "Could not attach Transcriber to SpeechAnalyzer for %@ due to %@",  (uint8_t *)v13,  0x16u);
    uint64_t v17 = sub_10004B5C0(&qword_1000DD6D8);
    swift_arrayDestroy(v14, 2LL, v17);
    swift_slowDealloc(v14, -1LL, -1LL);
    swift_slowDealloc(v13, -1LL, -1LL);

    swift_errorRelease(v21);
  }

  else
  {
    uint64_t v18 = *(void *)(v2 + 128);
    uint64_t v19 = *(void **)(v2 + 64);

    swift_errorRelease(v18);
    swift_errorRelease(v18);
    swift_errorRelease(v18);
  }

  return (*(uint64_t (**)(void))(v2 + 8))(0LL);
}

uint64_t RDSAPISwiftSpeechAnalyzer.attachTranscriber(task:)(uint64_t a1)
{
  v2[8] = a1;
  v2[9] = v1;
  uint64_t v3 = sub_10004B5C0(&qword_1000DD6E8);
  v2[10] = swift_task_alloc((*(void *)(*(void *)(v3 - 8) + 64LL) + 15LL) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v4 = type metadata accessor for Locale(0LL);
  v2[11] = v4;
  uint64_t v5 = *(void *)(v4 - 8);
  v2[12] = v5;
  v2[13] = swift_task_alloc((*(void *)(v5 + 64) + 15LL) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v6 = type metadata accessor for TaskHint(0LL);
  v2[14] = v6;
  uint64_t v7 = *(void *)(v6 - 8);
  v2[15] = v7;
  uint8_t v2[16] = swift_task_alloc((*(void *)(v7 + 64) + 15LL) & 0xFFFFFFFFFFFFFFF0LL);
  unint64_t v8 = (*(void *)(*(void *)(sub_10004B5C0(&qword_1000DD6B0) - 8) + 64LL) + 15LL) & 0xFFFFFFFFFFFFFFF0LL;
  v2[17] = swift_task_alloc(v8);
  v2[18] = swift_task_alloc(v8);
  return swift_task_switch(sub_10004D624, 0LL, 0LL);
}

uint64_t sub_10004D624()
{
  uint64_t v1 = v0[8];
  sub_100057B38();
  uint64_t v2 = (void *)NSString.init(stringLiteral:)("DictationCC", 11LL, 2LL);
  LOBYTE(sub_100047AC0(v2, v1) = static NSObject.== infix(_:_:)(v2, v1);

  uint64_t v3 = v0[15];
  uint64_t v4 = (unsigned int *)&enum case for TaskHint.dictationCC(_:);
  uint64_t v5 = v3;
  if ((v1 & 1) == 0)
  {
    uint64_t v6 = v0[8];
    uint64_t v7 = (void *)NSString.init(stringLiteral:)("SpellCC", 7LL, 2LL);
    char v8 = static NSObject.== infix(_:_:)(v7, v6);

    if ((v8 & 1) != 0) {
      uint64_t v4 = (unsigned int *)&enum case for TaskHint.spellCC(_:);
    }
    uint64_t v5 = v0[15];
  }

  uint64_t v9 = *(void (**)(uint64_t, void, uint64_t))(v3 + 104);
  uint64_t v10 = v0[18];
  uint64_t v39 = v0[17];
  uint64_t v11 = v0[16];
  uint64_t v12 = v0[14];
  uint64_t v13 = v0[12];
  uint64_t v37 = v0[13];
  uint64_t v38 = v0[11];
  uint64_t v15 = v0[9];
  uint64_t v14 = v0[10];
  id v40 = (id)v0[8];
  v9(v11, *v4, v12);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(v5 + 32))(v10, v11, v12);
  (*(void (**)(uint64_t, void, uint64_t, uint64_t))(v5 + 56))(v10, 0LL, 1LL, v12);
  uint64_t v16 = v15 + OBJC_IVAR____TtC50com_apple_SpeechRecognitionCore_speechrecognitiond25RDSAPISwiftSpeechAnalyzer__taskHint;
  swift_beginAccess( v15 + OBJC_IVAR____TtC50com_apple_SpeechRecognitionCore_speechrecognitiond25RDSAPISwiftSpeechAnalyzer__taskHint,  v0 + 2,  33LL,  0LL);
  sub_1000588D4(v10, v16, &qword_1000DD6B0);
  swift_endAccess(v0 + 2);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(v13 + 16))( v37,  v15 + OBJC_IVAR____TtC50com_apple_SpeechRecognitionCore_speechrecognitiond25RDSAPISwiftSpeechAnalyzer__locale,  v38);
  sub_100058918(v16, v39, &qword_1000DD6B0);
  uint64_t v17 = v15
      + OBJC_IVAR____TtC50com_apple_SpeechRecognitionCore_speechrecognitiond25RDSAPISwiftSpeechAnalyzer__modelOptions;
  uint64_t v18 = type metadata accessor for Transcriber.ModelOptions(0LL);
  uint64_t v19 = *(void *)(v18 - 8);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(v19 + 16))(v14, v17, v18);
  (*(void (**)(uint64_t, void, uint64_t, uint64_t))(v19 + 56))(v14, 0LL, 1LL, v18);
  uint64_t v20 = (uint64_t *)(v15
                  + OBJC_IVAR____TtC50com_apple_SpeechRecognitionCore_speechrecognitiond25RDSAPISwiftSpeechAnalyzer__transcriptionOptions);
  swift_beginAccess( v15 + OBJC_IVAR____TtC50com_apple_SpeechRecognitionCore_speechrecognitiond25RDSAPISwiftSpeechAnalyzer__transcriptionOptions,  v0 + 5,  0LL,  0LL);
  uint64_t v21 = *v20;
  uint64_t v22 = *(void *)(v15
                  + OBJC_IVAR____TtC50com_apple_SpeechRecognitionCore_speechrecognitiond25RDSAPISwiftSpeechAnalyzer__reportingOptions);
  uint64_t v23 = type metadata accessor for Transcriber(0LL);
  swift_allocObject(v23, *(unsigned int *)(v23 + 48), *(unsigned __int16 *)(v23 + 52));
  swift_bridgeObjectRetain(v21);
  swift_bridgeObjectRetain(v22);
  uint64_t v24 = Transcriber.init(locale:taskHint:modelOptions:transcriptionOptions:reportingOptions:attributeOptions:)( v37,  v39,  v14,  v21,  v22,  &_swiftEmptySetSingleton);
  v0[19] = v24;
  _StringGuts.grow(_:)(23LL);
  id v26 = objc_msgSend(v40, "description", swift_bridgeObjectRelease( 0xE000000000000000,  v25).n128_f64[0]);
  uint64_t v27 = static String._unconditionallyBridgeFromObjectiveC(_:)(v26);
  id v29 = v28;

  v30._countAndFlagsBits = v27;
  v30._object = v29;
  String.append(_:)(v30);
  swift_bridgeObjectRelease(v29, v31);
  NSString v32 = String._bridgeToObjectiveC()();
  v0[20] = v32;
  swift_bridgeObjectRelease(0x80000001000BF550LL, v33);
  uint64_t v34 = (void *)swift_task_alloc(dword_1000DD6FC);
  v0[21] = v34;
  *uint64_t v34 = v0;
  v34[1] = sub_10004D974;
  uint64_t v35 = v0[9];
  v34[8] = v32;
  v34[9] = v35;
  v34[7] = v24;
  return swift_task_switch(sub_10004CFA8, 0LL, 0LL);
}

uint64_t sub_10004D974(uint64_t a1)
{
  uint64_t v3 = *(void **)(*(void *)v1 + 160LL);
  uint64_t v2 = *(void *)(*(void *)v1 + 168LL);
  *(void *)(*(void *)v1 + 176LL) = a1;
  swift_task_dealloc(v2);

  return swift_task_switch(sub_10004D9D4, 0LL, 0LL);
}

uint64_t sub_10004D9D4()
{
  uint64_t v1 = *(void *)(v0 + 144);
  uint64_t v3 = *(void *)(v0 + 128);
  uint64_t v2 = *(void *)(v0 + 136);
  uint64_t v4 = *(void *)(v0 + 104);
  uint64_t v5 = *(void *)(v0 + 80);
  swift_release(*(void *)(v0 + 152));
  swift_task_dealloc(v1);
  swift_task_dealloc(v2);
  swift_task_dealloc(v3);
  swift_task_dealloc(v4);
  swift_task_dealloc(v5);
  return (*(uint64_t (**)(void))(v0 + 8))(*(void *)(v0 + 176));
}

uint64_t sub_10004DB7C(void *a1, void *aBlock, void *a3)
{
  _OWORD v3[2] = a1;
  v3[3] = a3;
  void v3[4] = _Block_copy(aBlock);
  uint64_t v6 = dword_1000DD6E4;
  id v7 = a1;
  a3;
  char v8 = (void *)swift_task_alloc(v6);
  v3[5] = v8;
  void *v8 = v3;
  v8[1] = sub_10004DBF8;
  return RDSAPISwiftSpeechAnalyzer.attachTranscriber(task:)((uint64_t)v7);
}

uint64_t sub_10004DBF8(void *a1)
{
  uint64_t v3 = *(void (***)(void, void))(*v1 + 32);
  uint64_t v5 = *(void **)(*v1 + 16);
  uint64_t v4 = *(void **)(*v1 + 24);
  uint64_t v7 = *v1;
  swift_task_dealloc(*(void *)(*v1 + 40));

  ((void (**)(void, void *))v3)[2](v3, a1);
  _Block_release(v3);

  return (*(uint64_t (**)(void))(v7 + 8))();
}

uint64_t RDSAPISwiftSpeechAnalyzer.setRecognitionReplacements(useRecognitionReplacements:)(char a1)
{
  *(void *)(v2 + 112) = v1;
  *(_BYTE *)(v2 + 2++*(void *)(result + 24) = a1;
  uint64_t v3 = sub_10004B5C0(&qword_1000DD6E8);
  *(void *)(v2 + 12RDString::RDString((RDString *)&v66, theString, 0) = swift_task_alloc((*(void *)(*(void *)(v3 - 8) + 64LL) + 15LL) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v4 = sub_10004B5C0(&qword_1000DD6B0);
  *(void *)(v2 + 12_Block_object_dispose(va, 8) = swift_task_alloc((*(void *)(*(void *)(v4 - 8) + 64LL) + 15LL) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v5 = type metadata accessor for Locale(0LL);
  *(void *)(v2 + 136) = v5;
  uint64_t v6 = *(void *)(v5 - 8);
  *(void *)(v2 + 144) = v6;
  *(void *)(v2 + 152) = swift_task_alloc((*(void *)(v6 + 64) + 15LL) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v7 = type metadata accessor for Transcriber.TranscriptionOption(0LL);
  *(void *)(v2 + 16RDString::RDString((RDString *)&v66, theString, 0) = v7;
  uint64_t v8 = *(void *)(v7 - 8);
  *(void *)(v2 + 16_Block_object_dispose(va, 8) = v8;
  *(void *)(v2 + 176) = swift_task_alloc((*(void *)(v8 + 64) + 15LL) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v9 = sub_10004B5C0(&qword_1000DD708);
  *(void *)(v2 + 184) = swift_task_alloc((*(void *)(*(void *)(v9 - 8) + 64LL) + 15LL) & 0xFFFFFFFFFFFFFFF0LL);
  return swift_task_switch(sub_10004DD6C, 0LL, 0LL);
}

uint64_t sub_10004DD6C()
{
  if (*(_BYTE *)(v0 + 224) == 1)
  {
    uint64_t v1 = *(void *)(v0 + 160);
    uint64_t v2 = *(void *)(v0 + 168);
    swift_beginAccess(v3, v0 + 88, 1LL, 0LL);
    uint64_t v4 = *v3;
    uint64_t v5 = sub_10004B5C0(&qword_1000DD710);
    uint64_t v6 = *(unsigned __int8 *)(v2 + 80);
    uint64_t v7 = (v6 + 32) & ~v6;
    uint64_t v8 = swift_allocObject(v5, v7 + *(void *)(v2 + 72), v6 | 7);
    *(_OWORD *)(v8 + 16) = xmmword_1000AC520;
    uint64_t v9 = v8 + v7;
    (*(void (**)(uint64_t, void, uint64_t))(v2 + 104))( v9,  enum case for Transcriber.TranscriptionOption.etiquetteReplacements(_:),  v1);
    swift_bridgeObjectRetain(v4);
    uint64_t v10 = sub_100056DB8(v8, v4);
    swift_setDeallocating(v8);
    swift_arrayDestroy(v9, 1LL, v1);
    swift_deallocClassInstance(v8, 32LL, 7LL);
    uint64_t v11 = *v3;
    *uint64_t v3 = v10;
    __n128 v13 = swift_bridgeObjectRelease(v11, v12);
    uint64_t v14 = (void *)0xE400000000000000LL;
    uint64_t v41 = 1702195828LL;
  }

  else
  {
    uint64_t v16 = *(void *)(v0 + 176);
    uint64_t v15 = *(void *)(v0 + 184);
    uint64_t v17 = *(void *)(v0 + 160);
    uint64_t v18 = *(void *)(v0 + 168);
    uint64_t v19 = *(void *)(v0 + 112);
    (*(void (**)(uint64_t, void, uint64_t))(v18 + 104))( v16,  enum case for Transcriber.TranscriptionOption.etiquetteReplacements(_:),  v17);
    swift_beginAccess( v19 + OBJC_IVAR____TtC50com_apple_SpeechRecognitionCore_speechrecognitiond25RDSAPISwiftSpeechAnalyzer__transcriptionOptions,  v0 + 16,  33LL,  0LL);
    sub_100055948(v16, v15);
    (*(void (**)(uint64_t, uint64_t))(v18 + 8))(v16, v17);
    sub_10004BA28(v15, &qword_1000DD708);
    swift_endAccess(v0 + 16);
    uint64_t v41 = 0x65736C6166LL;
    uint64_t v14 = (void *)0xE500000000000000LL;
  }

  uint64_t v20 = *(void *)(v0 + 152);
  uint64_t v21 = *(void *)(v0 + 128);
  uint64_t v23 = *(void *)(v0 + 112);
  uint64_t v22 = *(void *)(v0 + 120);
  (*(void (**)(uint64_t, uint64_t, void, __n128))(*(void *)(v0 + 144) + 16LL))( v20,  v23 + OBJC_IVAR____TtC50com_apple_SpeechRecognitionCore_speechrecognitiond25RDSAPISwiftSpeechAnalyzer__locale,  *(void *)(v0 + 136),  v13);
  uint64_t v24 = v23 + OBJC_IVAR____TtC50com_apple_SpeechRecognitionCore_speechrecognitiond25RDSAPISwiftSpeechAnalyzer__taskHint;
  swift_beginAccess( v23 + OBJC_IVAR____TtC50com_apple_SpeechRecognitionCore_speechrecognitiond25RDSAPISwiftSpeechAnalyzer__taskHint,  v0 + 40,  0LL,  0LL);
  sub_100058918(v24, v21, &qword_1000DD6B0);
  uint64_t v25 = v23
      + OBJC_IVAR____TtC50com_apple_SpeechRecognitionCore_speechrecognitiond25RDSAPISwiftSpeechAnalyzer__modelOptions;
  uint64_t v26 = type metadata accessor for Transcriber.ModelOptions(0LL);
  uint64_t v27 = *(void *)(v26 - 8);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(v27 + 16))(v22, v25, v26);
  (*(void (**)(uint64_t, void, uint64_t, uint64_t))(v27 + 56))(v22, 0LL, 1LL, v26);
  id v28 = (uint64_t *)(v23
                  + OBJC_IVAR____TtC50com_apple_SpeechRecognitionCore_speechrecognitiond25RDSAPISwiftSpeechAnalyzer__transcriptionOptions);
  swift_beginAccess( v23 + OBJC_IVAR____TtC50com_apple_SpeechRecognitionCore_speechrecognitiond25RDSAPISwiftSpeechAnalyzer__transcriptionOptions,  v0 + 64,  0LL,  0LL);
  uint64_t v29 = *v28;
  uint64_t v30 = *(void *)(v23
                  + OBJC_IVAR____TtC50com_apple_SpeechRecognitionCore_speechrecognitiond25RDSAPISwiftSpeechAnalyzer__reportingOptions);
  uint64_t v31 = type metadata accessor for Transcriber(0LL);
  swift_allocObject(v31, *(unsigned int *)(v31 + 48), *(unsigned __int16 *)(v31 + 52));
  swift_bridgeObjectRetain(v29);
  swift_bridgeObjectRetain(v30);
  uint64_t v32 = Transcriber.init(locale:taskHint:modelOptions:transcriptionOptions:reportingOptions:attributeOptions:)( v20,  v21,  v22,  v29,  v30,  &_swiftEmptySetSingleton);
  *(void *)(v0 + 192) = v32;
  _StringGuts.grow(_:)(33LL);
  swift_bridgeObjectRelease(0xE000000000000000LL, v33);
  v34._countAndFlagsBits = v41;
  v34._object = v14;
  String.append(_:)(v34);
  swift_bridgeObjectRelease(v14, v35);
  NSString v36 = String._bridgeToObjectiveC()();
  *(void *)(v0 + 20RDString::RDString((RDString *)&v66, theString, 0) = v36;
  swift_bridgeObjectRelease(0x80000001000BF570LL, v37);
  uint64_t v38 = (void *)swift_task_alloc(dword_1000DD6FC);
  *(void *)(v0 + 20_Block_object_dispose(va, 8) = v38;
  void *v38 = v0;
  v38[1] = sub_10004E108;
  uint64_t v39 = *(void *)(v0 + 112);
  v38[8] = v36;
  v38[9] = v39;
  v38[7] = v32;
  return swift_task_switch(sub_10004CFA8, 0LL, 0LL);
}

uint64_t sub_10004E108(uint64_t a1)
{
  uint64_t v3 = *(void **)(*(void *)v1 + 200LL);
  uint64_t v2 = *(void *)(*(void *)v1 + 208LL);
  *(void *)(*(void *)v1 + 216LL) = a1;
  swift_task_dealloc(v2);

  return swift_task_switch(sub_10004E168, 0LL, 0LL);
}

uint64_t sub_10004E168()
{
  uint64_t v1 = *(void *)(v0 + 184);
  uint64_t v2 = *(void *)(v0 + 176);
  uint64_t v3 = *(void *)(v0 + 152);
  uint64_t v5 = *(void *)(v0 + 120);
  uint64_t v4 = *(void *)(v0 + 128);
  swift_release(*(void *)(v0 + 192));
  swift_task_dealloc(v1);
  swift_task_dealloc(v2);
  swift_task_dealloc(v3);
  swift_task_dealloc(v4);
  swift_task_dealloc(v5);
  return (*(uint64_t (**)(void))(v0 + 8))(*(void *)(v0 + 216));
}

uint64_t sub_10004E30C(char a1, void *aBlock, void *a3)
{
  _OWORD v3[2] = a3;
  v3[3] = _Block_copy(aBlock);
  uint64_t v6 = dword_1000DD704;
  a3;
  uint64_t v7 = (void *)swift_task_alloc(v6);
  void v3[4] = v7;
  *uint64_t v7 = v3;
  v7[1] = sub_10004E380;
  return RDSAPISwiftSpeechAnalyzer.setRecognitionReplacements(useRecognitionReplacements:)(a1);
}

uint64_t sub_10004E380(void *a1)
{
  uint64_t v3 = *(void (***)(void, void))(*v1 + 24);
  uint64_t v4 = *(void **)(*v1 + 16);
  uint64_t v6 = *v1;
  swift_task_dealloc(*(void *)(*v1 + 32));

  ((void (**)(void, void *))v3)[2](v3, a1);
  _Block_release(v3);

  return (*(uint64_t (**)(void))(v6 + 8))();
}

Swift::Void __swiftcall RDSAPISwiftSpeechAnalyzer.cancelRecognition()()
{
}

Swift::Void __swiftcall RDSAPISwiftSpeechAnalyzer.setText(leftContextText:)(NSString leftContextText)
{
  uint64_t v3 = sub_10004B5C0(&qword_1000DD628);
  __chkstk_darwin(v3);
  uint64_t v5 = (char *)&v13 - ((v4 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v6 = static String._unconditionallyBridgeFromObjectiveC(_:)(leftContextText);
  uint64_t v8 = v7;
  uint64_t v9 = type metadata accessor for TaskPriority(0LL);
  (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(*(void *)(v9 - 8) + 56LL))(v5, 1LL, 1LL, v9);
  uint64_t v10 = (void *)swift_allocObject(&unk_1000D0178, 56LL, 7LL);
  v10[2] = 0LL;
  void v10[3] = 0LL;
  v10[4] = v1;
  void v10[5] = v6;
  v10[6] = v8;
  id v11 = v1;
  uint64_t v12 = sub_10004ABD0((uint64_t)v5, (uint64_t)&unk_1000DD720, (uint64_t)v10);
  swift_release(v12);
}

uint64_t sub_10004E4EC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  v6[7] = a5;
  uint8_t v6[8] = a6;
  v6[6] = a4;
  uint64_t v7 = type metadata accessor for AnalysisContext.ContextualStringsTag(0LL);
  v6[9] = v7;
  uint64_t v8 = *(void *)(v7 - 8);
  void v6[10] = v8;
  v6[11] = swift_task_alloc((*(void *)(v8 + 64) + 15LL) & 0xFFFFFFFFFFFFFFF0LL);
  return swift_task_switch(sub_10004E550, 0LL, 0LL);
}

uint64_t sub_10004E550()
{
  uint64_t v1 = v0[11];
  uint64_t v2 = v0[8];
  uint64_t v20 = v0[10];
  uint64_t v21 = v0[9];
  uint64_t v4 = v0[6];
  uint64_t v3 = v0[7];
  uint64_t v5 = OBJC_IVAR____TtC50com_apple_SpeechRecognitionCore_speechrecognitiond25RDSAPISwiftSpeechAnalyzer__analysisContext;
  id v6 = objc_retain(*(id *)(v4
                         + OBJC_IVAR____TtC50com_apple_SpeechRecognitionCore_speechrecognitiond25RDSAPISwiftSpeechAnalyzer__analysisContext));
  static AnalysisContext.ContextualStringsTag.leftContext.getter();
  uint64_t v7 = sub_10004B5C0(&qword_1000DDA28);
  uint64_t v8 = swift_allocObject(v7, 48LL, 7LL);
  *(_OWORD *)(v8 + 16) = xmmword_1000AC520;
  *(void *)(v8 + 32) = v3;
  *(void *)(v8 + 4RDString::RDString((RDString *)&v66, theString, 0) = v2;
  swift_bridgeObjectRetain(v2);
  uint64_t v9 = (void (*)(void *, void))dispatch thunk of AnalysisContext.contextualStrings.modify(v0 + 2);
  id v11 = v10;
  char isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native(*v10);
  uint64_t v23 = *v11;
  *id v11 = 0x8000000000000000LL;
  sub_100056200(v8, v1, isUniquelyReferenced_nonNull_native);
  uint64_t v13 = *v11;
  *id v11 = v23;
  swift_bridgeObjectRelease(v13, v14);
  (*(void (**)(uint64_t, uint64_t))(v20 + 8))(v1, v21);
  v9(v0 + 2, 0LL);

  uint64_t v15 = *(void **)(v4 + v5);
  v0[12] = v15;
  v15;
  uint64_t v16 = dispatch thunk of AnalysisContext.userData.getter();
  v0[13] = v16;
  v0[14] = v17;
  uint64_t v18 = sub_10004B5C0((uint64_t *)&unk_1000DDA30);
  *uint64_t v17 = v0;
  v17[1] = sub_10004E6D0;
  return v22(v16, v18);
}

uint64_t sub_10004E6D0()
{
  uint64_t v1 = *(void *)(*v0 + 104);
  uint64_t v2 = *(void *)(*v0 + 88);
  uint64_t v3 = *(void **)(*v0 + 96);
  uint64_t v6 = *v0;
  swift_task_dealloc(*(void *)(*v0 + 112));
  swift_bridgeObjectRelease(v1, v4);

  swift_task_dealloc(v2);
  return (*(uint64_t (**)(void))(v6 + 8))();
}

void RDSAPISwiftSpeechAnalyzer.getJitProfileData()()
{
}

uint64_t RDSAPISwiftSpeechAnalyzer.setContext(jitProfileData:)(uint64_t a1, unint64_t a2)
{
  return sub_10004EADC(a1, a2, (uint64_t)&unk_1000D01A0, (uint64_t)&unk_1000DD730);
}

uint64_t sub_10004E864(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  v6[3] = a5;
  void v6[4] = a6;
  _DWORD v6[2] = a4;
  return swift_task_switch(sub_10004E880, 0LL, 0LL);
}

uint64_t sub_10004E880()
{
  uint64_t v1 = v0[3];
  unint64_t v2 = v0[4];
  uint64_t v3 = v0[2];
  uint64_t v4 = OBJC_IVAR____TtC50com_apple_SpeechRecognitionCore_speechrecognitiond25RDSAPISwiftSpeechAnalyzer__analysisContext;
  id v5 = objc_retain(*(id *)(v3
                         + OBJC_IVAR____TtC50com_apple_SpeechRecognitionCore_speechrecognitiond25RDSAPISwiftSpeechAnalyzer__analysisContext));
  sub_100057C90(v1, v2);
  dispatch thunk of AnalysisContext.jitProfileData.setter(v1, v2);

  uint64_t v6 = *(void **)(v3 + v4);
  v0[5] = v6;
  v6;
  uint64_t v7 = dispatch thunk of AnalysisContext.userData.getter();
  v0[6] = v7;
  v0[7] = v8;
  uint64_t v9 = sub_10004B5C0((uint64_t *)&unk_1000DDA30);
  void *v8 = v0;
  v8[1] = sub_10004E958;
  return v11(v7, v9);
}

uint64_t sub_10004E958()
{
  uint64_t v1 = *(void *)(*v0 + 48);
  unint64_t v2 = *(void **)(*v0 + 40);
  uint64_t v5 = *v0;
  swift_task_dealloc(*(void *)(*v0 + 56));
  swift_bridgeObjectRelease(v1, v3);

  return (*(uint64_t (**)(void))(v5 + 8))();
}

void RDSAPISwiftSpeechAnalyzer.getUserProfileData()()
{
}

void sub_10004E9D0(void (*a1)(void))
{
  id v3 = objc_retain(*(id *)(v1
                         + OBJC_IVAR____TtC50com_apple_SpeechRecognitionCore_speechrecognitiond25RDSAPISwiftSpeechAnalyzer__analysisContext));
  a1();
  unint64_t v5 = v4;

  if (v5 >> 60 == 15) {
    __break(1u);
  }
}

void sub_10004EA40(char *a1, uint64_t a2, uint64_t (*a3)(void))
{
  unint64_t v4 = *(void **)&a1[OBJC_IVAR____TtC50com_apple_SpeechRecognitionCore_speechrecognitiond25RDSAPISwiftSpeechAnalyzer__analysisContext];
  unint64_t v5 = a1;
  id v6 = v4;
  uint64_t v7 = a3();
  unint64_t v9 = v8;

  if (v9 >> 60 == 15)
  {
    __break(1u);
  }

  else
  {

    Class isa = Data._bridgeToObjectiveC()().super.isa;
    sub_1000583C0(v7, v9);
    id v11 = isa;
  }

uint64_t RDSAPISwiftSpeechAnalyzer.setContext(userProfileData:)(uint64_t a1, unint64_t a2)
{
  return sub_10004EADC(a1, a2, (uint64_t)&unk_1000D01C8, (uint64_t)&unk_1000DD740);
}

uint64_t sub_10004EADC(uint64_t a1, unint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v9 = sub_10004B5C0(&qword_1000DD628);
  __chkstk_darwin(v9);
  id v11 = (char *)&v17 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v12 = type metadata accessor for TaskPriority(0LL);
  (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(*(void *)(v12 - 8) + 56LL))(v11, 1LL, 1LL, v12);
  uint64_t v13 = (void *)swift_allocObject(a3, 56LL, 7LL);
  _DWORD v13[2] = 0LL;
  void v13[3] = 0LL;
  v13[4] = v4;
  v13[5] = a1;
  v13[6] = a2;
  id v14 = v4;
  sub_100057C90(a1, a2);
  uint64_t v15 = sub_10004ABD0((uint64_t)v11, a4, (uint64_t)v13);
  return swift_release(v15);
}

uint64_t sub_10004EBB8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  v6[3] = a5;
  void v6[4] = a6;
  _DWORD v6[2] = a4;
  return swift_task_switch(sub_10004EBD4, 0LL, 0LL);
}

uint64_t sub_10004EBD4()
{
  uint64_t v1 = v0[3];
  unint64_t v2 = v0[4];
  uint64_t v3 = v0[2];
  uint64_t v4 = OBJC_IVAR____TtC50com_apple_SpeechRecognitionCore_speechrecognitiond25RDSAPISwiftSpeechAnalyzer__analysisContext;
  id v5 = objc_retain(*(id *)(v3
                         + OBJC_IVAR____TtC50com_apple_SpeechRecognitionCore_speechrecognitiond25RDSAPISwiftSpeechAnalyzer__analysisContext));
  sub_100057C90(v1, v2);
  dispatch thunk of AnalysisContext.profileData.setter(v1, v2);

  id v6 = *(void **)(v3 + v4);
  v0[5] = v6;
  v6;
  uint64_t v7 = dispatch thunk of AnalysisContext.userData.getter();
  v0[6] = v7;
  v0[7] = v8;
  uint64_t v9 = sub_10004B5C0((uint64_t *)&unk_1000DDA30);
  void *v8 = v0;
  v8[1] = sub_10005895C;
  return v11(v7, v9);
}

void sub_10004ECC0(void *a1, uint64_t a2, void *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v9 = sub_10004B5C0(&qword_1000DD628);
  __chkstk_darwin(v9);
  id v11 = (char *)&v21 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  id v12 = a3;
  id v13 = a1;
  uint64_t v14 = static Data._unconditionallyBridgeFromObjectiveC(_:)(a3);
  unint64_t v16 = v15;

  uint64_t v17 = type metadata accessor for TaskPriority(0LL);
  (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(*(void *)(v17 - 8) + 56LL))(v11, 1LL, 1LL, v17);
  uint64_t v18 = (void *)swift_allocObject(a4, 56LL, 7LL);
  v18[2] = 0LL;
  v18[3] = 0LL;
  v18[4] = v13;
  void v18[5] = v14;
  v18[6] = v16;
  id v19 = v13;
  sub_100057C90(v14, v16);
  uint64_t v20 = sub_10004ABD0((uint64_t)v11, a5, (uint64_t)v18);
  swift_release(v20);
  sub_100057BDC(v14, v16);
}

Swift::Void __swiftcall RDSAPISwiftSpeechAnalyzer.useRecognitionReplacements()()
{
  uint64_t v1 = v0;
  uint64_t v2 = sub_10004B5C0(&qword_1000DD628);
  __chkstk_darwin(v2);
  id v46 = (char *)&v43 - ((v3 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v4 = sub_10004B5C0(&qword_1000DD6E8);
  __chkstk_darwin(v4);
  id v6 = (char *)&v43 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v7 = sub_10004B5C0(&qword_1000DD6B0);
  __chkstk_darwin(v7);
  uint64_t v45 = (uint64_t)&v43 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v9 = type metadata accessor for Locale(0LL);
  uint64_t v10 = *(void *)(v9 - 8);
  __chkstk_darwin(v9);
  unsigned int v44 = (char *)&v43 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  id v12 = (uint64_t *)&v1[OBJC_IVAR____TtC50com_apple_SpeechRecognitionCore_speechrecognitiond25RDSAPISwiftSpeechAnalyzer__transcriptionOptions];
  swift_beginAccess( &v1[OBJC_IVAR____TtC50com_apple_SpeechRecognitionCore_speechrecognitiond25RDSAPISwiftSpeechAnalyzer__transcriptionOptions],  v49,  1LL,  0LL);
  uint64_t v13 = *v12;
  uint64_t v14 = sub_10004B5C0(&qword_1000DD710);
  uint64_t v15 = type metadata accessor for Transcriber.TranscriptionOption(0LL);
  uint64_t v16 = *(void *)(v15 - 8);
  uint64_t v17 = *(unsigned __int8 *)(v16 + 80);
  uint64_t v18 = (v17 + 32) & ~v17;
  uint64_t v19 = swift_allocObject(v14, v18 + *(void *)(v16 + 72), v17 | 7);
  *(_OWORD *)(v19 + 16) = xmmword_1000AC520;
  uint64_t v20 = v19 + v18;
  (*(void (**)(uint64_t, void, uint64_t))(v16 + 104))( v20,  enum case for Transcriber.TranscriptionOption.etiquetteReplacements(_:),  v15);
  swift_bridgeObjectRetain(v13);
  uint64_t v21 = sub_100056DB8(v19, v13);
  swift_setDeallocating(v19);
  swift_arrayDestroy(v20, 1LL, v15);
  swift_deallocClassInstance(v19, 32LL, 7LL);
  uint64_t v22 = *v12;
  *id v12 = v21;
  swift_bridgeObjectRelease(v22, v23);
  uint64_t v24 = v44;
  (*(void (**)(char *, char *, uint64_t))(v10 + 16))( v44,  &v1[OBJC_IVAR____TtC50com_apple_SpeechRecognitionCore_speechrecognitiond25RDSAPISwiftSpeechAnalyzer__locale],  v9);
  uint64_t v25 = (uint64_t)&v1[OBJC_IVAR____TtC50com_apple_SpeechRecognitionCore_speechrecognitiond25RDSAPISwiftSpeechAnalyzer__taskHint];
  swift_beginAccess( &v1[OBJC_IVAR____TtC50com_apple_SpeechRecognitionCore_speechrecognitiond25RDSAPISwiftSpeechAnalyzer__taskHint],  v48,  0LL,  0LL);
  uint64_t v26 = v45;
  sub_100058918(v25, v45, &qword_1000DD6B0);
  uint64_t v27 = &v1[OBJC_IVAR____TtC50com_apple_SpeechRecognitionCore_speechrecognitiond25RDSAPISwiftSpeechAnalyzer__modelOptions];
  uint64_t v28 = type metadata accessor for Transcriber.ModelOptions(0LL);
  uint64_t v29 = *(void *)(v28 - 8);
  (*(void (**)(char *, char *, uint64_t))(v29 + 16))(v6, v27, v28);
  (*(void (**)(char *, void, uint64_t, uint64_t))(v29 + 56))(v6, 0LL, 1LL, v28);
  uint64_t v30 = *v12;
  uint64_t v31 = *(void *)&v1[OBJC_IVAR____TtC50com_apple_SpeechRecognitionCore_speechrecognitiond25RDSAPISwiftSpeechAnalyzer__reportingOptions];
  uint64_t v32 = type metadata accessor for Transcriber(0LL);
  swift_allocObject(v32, *(unsigned int *)(v32 + 48), *(unsigned __int16 *)(v32 + 52));
  swift_bridgeObjectRetain(v30);
  swift_bridgeObjectRetain(v31);
  uint64_t v33 = Transcriber.init(locale:taskHint:modelOptions:transcriptionOptions:reportingOptions:attributeOptions:)( v24,  v26,  v6,  v30,  v31,  &_swiftEmptySetSingleton);
  Swift::String v34 = (objc_class *)type metadata accessor for RDSAPISwiftTranscriberModule();
  uint64_t v35 = (char *)objc_allocWithZone(v34);
  *(void *)&v35[OBJC_IVAR____TtC50com_apple_SpeechRecognitionCore_speechrecognitiond28RDSAPISwiftTranscriberModule__transcriberModule] = v33;
  v47.id receiver = v35;
  v47.Class super_class = v34;
  swift_retain(v33);
  id v36 = objc_msgSendSuper2(&v47, "init");
  uint64_t v37 = type metadata accessor for TaskPriority(0LL);
  uint64_t v38 = (uint64_t)v46;
  (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(*(void *)(v37 - 8) + 56LL))(v46, 1LL, 1LL, v37);
  uint64_t v39 = (void *)swift_allocObject(&unk_1000D01F0, 48LL, 7LL);
  v39[2] = 0LL;
  v39[3] = 0LL;
  void v39[4] = v36;
  v39[5] = v1;
  id v40 = v36;
  uint64_t v41 = v1;
  uint64_t v42 = sub_10004ABD0(v38, (uint64_t)&unk_1000DD750, (uint64_t)v39);
  swift_release(v42);

  swift_release(v33);
}

uint64_t sub_10004F1A0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  *(void *)(v5 + ++*(void *)(result + 24) = a4;
  *(void *)(v5 + 32) = a5;
  return swift_task_switch(sub_10004F1B8, 0LL, 0LL);
}

uint64_t sub_10004F1B8()
{
  uint64_t v1 = *(void *)(v0 + 32);
  uint64_t v2 = (*(uint64_t (**)(void))((swift_isaMask & **(void **)(v0 + 24)) + 0x58LL))();
  *(void *)(v0 + 4RDString::RDString((RDString *)&v66, theString, 0) = v2;
  uint64_t v3 = *(void *)(v1
                 + OBJC_IVAR____TtC50com_apple_SpeechRecognitionCore_speechrecognitiond25RDSAPISwiftSpeechAnalyzer__speechAnalyzer);
  *(void *)(v0 + 4_Block_object_dispose(va, 8) = v3;
  uint64_t v4 = sub_10004B5C0(&qword_1000DD780);
  uint64_t v5 = swift_allocObject(v4, 48LL, 7LL);
  *(void *)(v0 + ++*(void *)(result + 56) = v5;
  *(_OWORD *)(v5 + 16) = xmmword_1000AC520;
  uint64_t v6 = sub_100058894( &qword_1000DD788,  (uint64_t (*)(uint64_t))&type metadata accessor for Transcriber,  (uint64_t)&protocol conformance descriptor for Transcriber);
  *(void *)(v5 + 32) = v2;
  *(void *)(v5 + 4RDString::RDString((RDString *)&v66, theString, 0) = v6;
  uint64_t v7 = async function pointer to SpeechAnalyzer.setModules(_:)[1];
  swift_retain(v3);
  swift_retain(v2);
  uint64_t v8 = (void *)swift_task_alloc(v7);
  *(void *)(v0 + 64) = v8;
  void *v8 = v0;
  v8[1] = sub_10004F2A8;
  return SpeechAnalyzer.setModules(_:)(v5);
}

uint64_t sub_10004F2A8()
{
  uint64_t v2 = *v1;
  uint64_t v3 = *(void *)(*v1 + 64);
  *(void *)(*v1 + 72) = v0;
  swift_task_dealloc(v3);
  if (v0)
  {
    uint64_t v5 = sub_10004F34C;
  }

  else
  {
    uint64_t v6 = *(void *)(v2 + 48);
    swift_bridgeObjectRelease(*(void *)(v2 + 56), v4);
    swift_release(v6);
    uint64_t v5 = sub_10004F31C;
  }

  return swift_task_switch(v5, 0LL, 0LL);
}

uint64_t sub_10004F31C()
{
  return (*(uint64_t (**)(void))(v0 + 8))();
}

uint64_t sub_10004F34C(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(v2 + 72);
  uint64_t v4 = *(void *)(v2 + 48);
  uint64_t v5 = *(void *)(v2 + 40);
  swift_bridgeObjectRelease(*(void *)(v2 + 56), a2);
  swift_release(v4);
  swift_release(v5);
  swift_errorRetain(v3);
  uint64_t v6 = swift_errorRetain(v3);
  uint64_t v7 = (os_log_s *)Logger.logObject.getter(v6);
  os_log_type_t v8 = static os_log_type_t.error.getter();
  if (os_log_type_enabled(v7, v8))
  {
    uint64_t v9 = *(void *)(v2 + 72);
    uint64_t v10 = (uint8_t *)swift_slowAlloc(12LL, -1LL);
    uint64_t v11 = (uint64_t *)swift_slowAlloc(8LL, -1LL);
    *(_DWORD *)uint64_t v10 = 138412290;
    swift_errorRetain(v9);
    uint64_t v12 = _swift_stdlib_bridgeErrorToNSError(v9);
    *(void *)(v2 + 16) = v12;
    UnsafeMutableRawBufferPointer.copyMemory(from:)(v2 + 16, v2 + 24, v10 + 4);
    *uint64_t v11 = v12;
    swift_errorRelease(v9);
    swift_errorRelease(v9);
    _os_log_impl((void *)&_mh_execute_header, v7, v8, "Could not set recognition replacements = %@", v10, 0xCu);
    uint64_t v13 = sub_10004B5C0(&qword_1000DD6D8);
    swift_arrayDestroy(v11, 1LL, v13);
    swift_slowDealloc(v11, -1LL, -1LL);
    swift_slowDealloc(v10, -1LL, -1LL);
    swift_errorRelease(v9);
  }

  else
  {
    uint64_t v14 = *(void *)(v2 + 72);
    swift_errorRelease(v14);

    swift_errorRelease(v14);
    swift_errorRelease(v14);
  }

  return (*(uint64_t (**)(void))(v2 + 8))();
}

Swift::Void __swiftcall RDSAPISwiftSpeechAnalyzer.newUtteranceBegins()()
{
  uint64_t v1 = v0;
  uint64_t v2 = OBJC_IVAR____TtC50com_apple_SpeechRecognitionCore_speechrecognitiond25RDSAPISwiftSpeechAnalyzer__newUtteranceBeginSampleNumber;
  *(void *)&v0[OBJC_IVAR____TtC50com_apple_SpeechRecognitionCore_speechrecognitiond25RDSAPISwiftSpeechAnalyzer__newUtteranceBeginSampleNumber] = *(void *)&v0[OBJC_IVAR____TtC50com_apple_SpeechRecognitionCore_speechrecognitiond25RDSAPISwiftSpeechAnalyzer__totalSamplesSent];
  uint64_t v3 = v0;
  oslog = (os_log_s *)Logger.logObject.getter();
  os_log_type_t v4 = static os_log_type_t.info.getter();
  if (os_log_type_enabled(oslog, v4))
  {
    uint64_t v5 = (uint8_t *)swift_slowAlloc(12LL, -1LL);
    *(_DWORD *)uint64_t v5 = 134217984;
    uint64_t v7 = *(void *)&v1[v2];
    UnsafeMutableRawBufferPointer.copyMemory(from:)(&v7, &v8, v5 + 4);

    _os_log_impl((void *)&_mh_execute_header, oslog, v4, "SpeechDonation : new utterance boundary = %lld", v5, 0xCu);
    swift_slowDealloc(v5, -1LL, -1LL);
  }

  else
  {
  }

Swift::Void __swiftcall RDSAPISwiftSpeechAnalyzer.addAudioSamples(audio:)(Swift::OpaquePointer audio)
{
  uint64_t v3 = type metadata accessor for AnalyzerInput(0LL);
  __chkstk_darwin(v3);
  uint64_t v5 = (char *)&v19 - ((v4 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v6 = sub_10004B5C0(&qword_1000DD6C8);
  uint64_t v7 = *(void *)(v6 - 8);
  __chkstk_darwin(v6);
  uint64_t v9 = (char *)&v19 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v10 = sub_10004B5C0(&qword_1000DD758);
  uint64_t v11 = *(void *)(v10 - 8);
  __chkstk_darwin(v10);
  uint64_t v13 = (char *)&v19 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v14 = *((void *)audio._rawValue + 2);
  uint64_t v15 = *(void *)((char *)v1
                  + OBJC_IVAR____TtC50com_apple_SpeechRecognitionCore_speechrecognitiond25RDSAPISwiftSpeechAnalyzer__totalSamplesSent);
  BOOL v16 = __OFADD__(v15, v14);
  uint64_t v17 = v15 + v14;
  if (v16)
  {
    __break(1u);
  }

  else
  {
    *(void *)((char *)v1
              + OBJC_IVAR____TtC50com_apple_SpeechRecognitionCore_speechrecognitiond25RDSAPISwiftSpeechAnalyzer__totalSamplesSent) = v17;
    (*(void (**)(char *, uint64_t, uint64_t))(v7 + 16))( v9,  (uint64_t)v1 + OBJC_IVAR____TtC50com_apple_SpeechRecognitionCore_speechrecognitiond25RDSAPISwiftSpeechAnalyzer__inputStreamBuilder,  v6);
    uint64_t v18 = (*(uint64_t (**)(void *))((swift_isaMask & *v1) + 0x2A0LL))(audio._rawValue);
    AnalyzerInput.init(buffer:bufferStartTime:)(v18, 0LL, 0LL, 0LL, 1LL);
    AsyncStream.Continuation.yield(_:)(v5, v6);
    (*(void (**)(char *, uint64_t))(v7 + 8))(v9, v6);
    (*(void (**)(char *, uint64_t))(v11 + 8))(v13, v10);
  }

Swift::Void __swiftcall RDSAPISwiftSpeechAnalyzer.endAudio()()
{
}

void sub_10004F86C(const char *a1)
{
  oslog = (os_log_s *)Logger.logObject.getter();
  os_log_type_t v2 = static os_log_type_t.debug.getter();
  if (os_log_type_enabled(oslog, v2))
  {
    uint64_t v3 = (uint8_t *)swift_slowAlloc(2LL, -1LL);
    *(_WORD *)uint64_t v3 = 0;
    _os_log_impl((void *)&_mh_execute_header, oslog, v2, a1, v3, 2u);
    swift_slowDealloc(v3, -1LL, -1LL);
  }
}

void sub_10004F918(void *a1, uint64_t a2, const char *a3)
{
  id v4 = a1;
  oslog = (os_log_s *)Logger.logObject.getter();
  os_log_type_t v5 = static os_log_type_t.debug.getter();
  if (os_log_type_enabled(oslog, v5))
  {
    uint64_t v6 = (uint8_t *)swift_slowAlloc(2LL, -1LL);
    *(_WORD *)uint64_t v6 = 0;
    _os_log_impl((void *)&_mh_execute_header, oslog, v5, a3, v6, 2u);
    swift_slowDealloc(v6, -1LL, -1LL);
  }
}

Swift::Void __swiftcall RDSAPISwiftSpeechAnalyzer.addAudioSamplesPCM(audio:)(AVAudioPCMBuffer audio)
{
  Class isa = audio.super.super.isa;
  uint64_t v3 = type metadata accessor for AnalyzerInput(0LL);
  __chkstk_darwin(v3);
  os_log_type_t v5 = (char *)&v15 - ((v4 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v6 = sub_10004B5C0(&qword_1000DD6C8);
  uint64_t v7 = *(void *)(v6 - 8);
  __chkstk_darwin(v6);
  uint64_t v9 = (char *)&v15 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v10 = sub_10004B5C0(&qword_1000DD758);
  uint64_t v11 = *(void *)(v10 - 8);
  __chkstk_darwin(v10);
  uint64_t v13 = (char *)&v15 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  (*(void (**)(char *, uint64_t, uint64_t))(v7 + 16))( v9,  v1 + OBJC_IVAR____TtC50com_apple_SpeechRecognitionCore_speechrecognitiond25RDSAPISwiftSpeechAnalyzer__inputStreamBuilder,  v6);
  uint64_t v14 = isa;
  CMTimeMake(&v16, 0LL, 1);
  AnalyzerInput.init(buffer:bufferStartTime:)(v14, v16.value, *(void *)&v16.timescale, v16.epoch, 0LL);
  AsyncStream.Continuation.yield(_:)(v5, v6);
  (*(void (**)(char *, uint64_t))(v7 + 8))(v9, v6);
  (*(void (**)(char *, uint64_t))(v11 + 8))(v13, v10);
}

uint64_t sub_10004FCB8(uint64_t a1)
{
  uint64_t v9 = 0x40CF400000000000LL;
  __int128 v10 = xmmword_1000AC530;
  __int128 v11 = xmmword_1000AC540;
  id v2 = [objc_allocWithZone(AVAudioFormat) initWithStreamDescription:&v9];
  if (!v2)
  {
    __break(1u);
    goto LABEL_8;
  }

  unint64_t v3 = *(void *)(a1 + 16);
  if (HIDWORD(v3))
  {
    uint64_t result = _assertionFailure(_:_:file:line:flags:)( "Fatal error",  11LL,  2LL,  "Not enough bits to represent the passed value",  45LL,  2LL,  "Swift/Integers.swift",  20LL,  2,  3455LL,  0);
    __break(1u);
    return result;
  }

  uint64_t v4 = v2;
  id v5 = [objc_allocWithZone(AVAudioPCMBuffer) initWithPCMFormat:v2 frameCapacity:v3];
  if (!v5) {
LABEL_8:
  }
    __break(1u);
  uint64_t v6 = v5;
  uint64_t v7 = [v5 int16ChannelData];
  if (v7) {
    uint64_t v7 = (void *)*v7;
  }
  memcpy(v7, (const void *)(a1 + 32), 2 * v3);
  [v6 setFrameLength:v3];

  return (uint64_t)v6;
}

uint64_t RDSAPISwiftSpeechAnalyzer.startRecognition(transcriberModuleWrapper:)(void *a1)
{
  uint64_t v3 = sub_10004B5C0(&qword_1000DD628);
  __chkstk_darwin(v3);
  id v5 = (char *)&v13 - ((v4 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v6 = type metadata accessor for TaskPriority(0LL);
  (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(*(void *)(v6 - 8) + 56LL))(v5, 1LL, 1LL, v6);
  uint64_t v7 = (void *)swift_allocObject(&unk_1000D0218, 48LL, 7LL);
  _OWORD v7[2] = 0LL;
  v7[3] = 0LL;
  void v7[4] = v1;
  void v7[5] = a1;
  uint64_t v8 = v1;
  id v9 = a1;
  uint64_t v10 = sub_10004ABD0((uint64_t)v5, (uint64_t)&unk_1000DD768, (uint64_t)v7);
  uint64_t v11 = *(void *)&v8[OBJC_IVAR____TtC50com_apple_SpeechRecognitionCore_speechrecognitiond25RDSAPISwiftSpeechAnalyzer__recognitionTask];
  *(void *)&v8[OBJC_IVAR____TtC50com_apple_SpeechRecognitionCore_speechrecognitiond25RDSAPISwiftSpeechAnalyzer__recognitionTask] = v10;
  return swift_release(v11);
}

uint64_t sub_10004FEF4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  v5[74] = a5;
  v5[73] = a4;
  uint64_t v6 = type metadata accessor for AttributedString.CharacterView(0LL);
  v5[75] = v6;
  v5[76] = swift_task_alloc((*(void *)(*(void *)(v6 - 8) + 64LL) + 15LL) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v7 = type metadata accessor for AttributedString(0LL);
  v5[77] = v7;
  uint64_t v8 = *(void *)(v7 - 8);
  v5[78] = v8;
  v5[79] = swift_task_alloc((*(void *)(v8 + 64) + 15LL) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v9 = type metadata accessor for TranscriptionSegment(0LL);
  v5[80] = v9;
  uint64_t v10 = *(void *)(v9 - 8);
  v5[81] = v10;
  v5[82] = swift_task_alloc((*(void *)(v10 + 64) + 15LL) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v11 = type metadata accessor for TranscriptionToken(0LL);
  v5[83] = v11;
  uint64_t v12 = *(void *)(v11 - 8);
  v5[84] = v12;
  unint64_t v13 = (*(void *)(v12 + 64) + 15LL) & 0xFFFFFFFFFFFFFFF0LL;
  v5[85] = swift_task_alloc(v13);
  v5[86] = swift_task_alloc(v13);
  v5[87] = swift_task_alloc(v13);
  v5[88] = swift_task_alloc(v13);
  uint64_t v14 = type metadata accessor for EARResultType(0LL);
  v5[89] = v14;
  uint64_t v15 = *(void *)(v14 - 8);
  v5[90] = v15;
  v5[91] = swift_task_alloc((*(void *)(v15 + 64) + 15LL) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v16 = type metadata accessor for Transcriber.MultisegmentResult(0LL);
  v5[92] = v16;
  uint64_t v17 = *(void *)(v16 - 8);
  v5[93] = v17;
  unint64_t v18 = (*(void *)(v17 + 64) + 15LL) & 0xFFFFFFFFFFFFFFF0LL;
  v5[94] = swift_task_alloc(v18);
  v5[95] = swift_task_alloc(v18);
  v5[96] = swift_task_alloc(v18);
  uint64_t v19 = sub_10004B5C0(&qword_1000DD9C8);
  v5[97] = swift_task_alloc((*(void *)(*(void *)(v19 - 8) + 64LL) + 15LL) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v20 = sub_10004B5C0(&qword_1000DD9D0);
  v5[98] = v20;
  v5[99] = swift_task_alloc((*(void *)(*(void *)(v20 - 8) + 64LL) + 15LL) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v21 = sub_10004B5C0(&qword_1000DD9D8);
  v5[100] = v21;
  uint64_t v22 = *(void *)(v21 - 8);
  v5[101] = v22;
  v5[102] = swift_task_alloc((*(void *)(v22 + 64) + 15LL) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v23 = type metadata accessor for CharacterSet(0LL);
  v5[103] = v23;
  uint64_t v24 = *(void *)(v23 - 8);
  v5[104] = v24;
  v5[105] = swift_task_alloc((*(void *)(v24 + 64) + 15LL) & 0xFFFFFFFFFFFFFFF0LL);
  return swift_task_switch(sub_100050100, 0LL, 0LL);
}

uint64_t sub_100050100(uint64_t a1)
{
  *(void *)(v1 + 84_Block_object_dispose(va, 8) = OBJC_IVAR____TtC50com_apple_SpeechRecognitionCore_speechrecognitiond25RDSAPISwiftSpeechAnalyzer__logger;
  id v2 = (os_log_s *)Logger.logObject.getter(a1);
  os_log_type_t v3 = static os_log_type_t.debug.getter();
  if (os_log_type_enabled(v2, v3))
  {
    uint64_t v4 = (uint8_t *)swift_slowAlloc(2LL, -1LL);
    *(_WORD *)uint64_t v4 = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, v3, "SpeechAnalyzer new recognition task started", v4, 2u);
    swift_slowDealloc(v4, -1LL, -1LL);
  }

  uint64_t v5 = *(void *)(v1 + 784);
  uint64_t v6 = *(void **)(v1 + 592);

  uint64_t v7 = CharacterSet.init(charactersIn:)(45506LL, 0xA200000000000000LL);
  *(void *)(v1 + 8++*(void *)(result + 56) = (*(uint64_t (**)(uint64_t))((swift_isaMask & *v6) + 0x58LL))(v7);
  uint64_t v8 = Transcriber.multisegmentResults.getter();
  uint64_t OpaqueTypeConformance2 = swift_getOpaqueTypeConformance2( v8,  &opaque type descriptor for <<opaque return type of Transcriber.multisegmentResults>>,  1LL);
  *(void *)(v1 + 864) = OpaqueTypeConformance2;
  dispatch thunk of AsyncSequence.makeAsyncIterator()(v5, OpaqueTypeConformance2);
  *(void *)(v1 + 872) = OBJC_IVAR____TtC50com_apple_SpeechRecognitionCore_speechrecognitiond25RDSAPISwiftSpeechAnalyzer__totalSamplesSent;
  *(void *)(v1 + 88RDString::RDString((RDString *)&v66, theString, 0) = OBJC_IVAR____TtC50com_apple_SpeechRecognitionCore_speechrecognitiond25RDSAPISwiftSpeechAnalyzer__newUtteranceBeginSampleNumber;
  *(_DWORD *)(v1 + 108_Block_object_dispose(va, 8) = enum case for EARResultType.partial(_:);
  *(_DWORD *)(v1 + 1092) = enum case for EARResultType.final(_:);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( *(void *)(v1 + 864),  *(void *)(v1 + 784),  *(void *)(v1 + 800),  &protocol requirements base descriptor for AsyncSequence,  &associated conformance descriptor for AsyncSequence.AsyncSequence.AsyncIterator: AsyncIteratorProtocol);
  uint64_t v11 = (void *)swift_task_alloc(_sScI4next9isolation7ElementQzSgScA_pSgYi_tYa7FailureQzYKFTjTu[1]);
  *(void *)(v1 + 88_Block_object_dispose(va, 8) = v11;
  *uint64_t v11 = v1;
  v11[1] = sub_1000502D8;
  return _sScI4next9isolation7ElementQzSgScA_pSgYi_tYa7FailureQzYKFTj( *(void *)(v1 + 776),  0LL,  0LL,  v1 + 568,  *(void *)(v1 + 800),  AssociatedConformanceWitness);
}

uint64_t sub_1000502D8()
{
  if (v0) {
    id v2 = sub_100051840;
  }
  else {
    id v2 = sub_10005033C;
  }
  return swift_task_switch(v2, 0LL, 0LL);
}

void sub_10005033C()
{
  uint64_t v1 = *(void *)(v0 + 776);
  uint64_t v2 = *(void *)(v0 + 744);
  uint64_t v3 = *(void *)(v0 + 736);
  if ((*(unsigned int (**)(uint64_t, uint64_t, uint64_t))(v2 + 48))(v1, 1LL, v3) == 1)
  {
    uint64_t v4 = *(void *)(v0 + 840);
    uint64_t v5 = *(void *)(v0 + 832);
    uint64_t v6 = *(void *)(v0 + 824);
    uint64_t v7 = *(void *)(v0 + 816);
    uint64_t v8 = *(void *)(v0 + 808);
    uint64_t v9 = *(void *)(v0 + 800);
    swift_release(*(void *)(v0 + 856));
    (*(void (**)(uint64_t, uint64_t))(v8 + 8))(v7, v9);
    (*(void (**)(uint64_t, uint64_t))(v5 + 8))(v4, v6);
    uint64_t v10 = *(void *)(v0 + 816);
    uint64_t v11 = *(void *)(v0 + 792);
    uint64_t v12 = *(void *)(v0 + 776);
    uint64_t v13 = *(void *)(v0 + 768);
    uint64_t v14 = *(void *)(v0 + 760);
    uint64_t v15 = *(void *)(v0 + 752);
    uint64_t v16 = *(void *)(v0 + 728);
    uint64_t v17 = *(void *)(v0 + 704);
    uint64_t v18 = *(void *)(v0 + 696);
    uint64_t v349 = *(void *)(v0 + 688);
    uint64_t v356 = *(void *)(v0 + 680);
    uint64_t v363 = *(void *)(v0 + 656);
    uint64_t v369 = *(void *)(v0 + 632);
    uint64_t v375 = *(void *)(v0 + 608);
    swift_task_dealloc(*(void *)(v0 + 840));
    swift_task_dealloc(v10);
    swift_task_dealloc(v11);
    swift_task_dealloc(v12);
    swift_task_dealloc(v13);
    swift_task_dealloc(v14);
    swift_task_dealloc(v15);
    swift_task_dealloc(v16);
    swift_task_dealloc(v17);
    swift_task_dealloc(v18);
    swift_task_dealloc(v349);
    swift_task_dealloc(v356);
    swift_task_dealloc(v363);
    swift_task_dealloc(v369);
    swift_task_dealloc(v375);
    (*(void (**)(void))(v0 + 8))();
    return;
  }

  int v19 = *(_DWORD *)(v0 + 1088);
  uint64_t v20 = *(void *)(v0 + 728);
  uint64_t v21 = *(void *)(v0 + 720);
  uint64_t v22 = *(void *)(v0 + 712);
  uint64_t v23 = (*(uint64_t (**)(void, uint64_t, uint64_t))(v2 + 32))(*(void *)(v0 + 768), v1, v3);
  Transcriber.MultisegmentResult.earResultType.getter(v23);
  uint64_t v24 = (*(uint64_t (**)(uint64_t, uint64_t))(v21 + 88))(v20, v22);
  if ((_DWORD)v24 == v19)
  {
    uint64_t v25 = (os_log_s *)Logger.logObject.getter(v24);
    os_log_type_t v26 = static os_log_type_t.debug.getter();
    uint64_t v27 = (void *)v0;
    if (os_log_type_enabled(v25, v26))
    {
      uint64_t v28 = (uint8_t *)swift_slowAlloc(2LL, -1LL);
      *(_WORD *)uint64_t v28 = 0;
      _os_log_impl((void *)&_mh_execute_header, v25, v26, "SpeechAnalyzer partial results", v28, 2u);
      swift_slowDealloc(v28, -1LL, -1LL);
    }

    id v325 = [objc_allocWithZone(NSMutableArray) init];
    uint64_t v29 = Transcriber.MultisegmentResult.transcriptionTokens.getter();
    uint64_t v31 = v29;
    uint64_t v322 = *(void *)(v29 + 16);
    if (v322)
    {
      unint64_t v32 = 0LL;
      v317 = (CMTime *)v29;
      uint64_t v319 = v29 + 32;
      while (v32 < *(void *)(v31 + 16))
      {
        uint64_t v33 = *(void **)(v319 + 8 * v32);
        id v34 = objc_allocWithZone(&OBJC_CLASS___NSMutableArray);
        swift_bridgeObjectRetain(v33);
        id v350 = [v34 init];
        uint64_t v36 = v33[2];
        if (v36)
        {
          id v328 = v33;
          unint64_t v331 = v32;
          uint64_t v37 = v27[84];
          uint64_t v38 = (char *)v33
              + ((*(unsigned __int8 *)(v37 + 80) + 32LL) & ~(unint64_t)*(unsigned __int8 *)(v37 + 80));
          v342 = *(CMTime **)(v37 + 72);
          v345 = *(uint64_t (**)(void, char *, void))(v37 + 16);
          while (1)
          {
            uint64_t v357 = v36;
            uint64_t v39 = v27[105];
            uint64_t v40 = v345(v27[88], v38, v27[83]);
            uint64_t v41 = TranscriptionToken.tokenName.getter(v40);
            uint64_t v43 = v42;
            v27[62] = v41;
            v27[63] = v42;
            unint64_t v44 = sub_1000587BC();
            StringProtocol.trimmingCharacters(in:)(v39, &type metadata for String, v44);
            uint64_t v370 = v45;
            swift_bridgeObjectRelease(v43, v45);
            v27[23] = TranscriptionToken.start.getter(v46);
            *((_DWORD *)v27 + 4_Block_object_dispose(va, 8) = v47;
            *((_DWORD *)v27 + 49) = v48;
            v27[25] = v49;
            double Seconds = CMTimeGetSeconds((CMTime *)(v27 + 23));
            void v27[17] = TranscriptionToken.end.getter();
            *((_DWORD *)v27 + 36) = v51;
            *((_DWORD *)v27 + 37) = v52;
            v27[19] = v53;
            double v54 = CMTimeGetSeconds((CMTime *)(v27 + 17));
            v27[14] = TranscriptionToken.silenceStart.getter();
            *((_DWORD *)v27 + 3RDString::RDString((RDString *)&v66, theString, 0) = v55;
            *((_DWORD *)v27 + 31) = v56;
            v27[16] = v57;
            double v58 = CMTimeGetSeconds((CMTime *)(v27 + 14));
            double v59 = TranscriptionToken.confidence.getter();
            char v364 = TranscriptionToken.hasSpaceAfter.getter();
            char v60 = TranscriptionToken.hasSpaceBefore.getter();
            TranscriptionToken.phoneSequence.getter();
            uint64_t v62 = v61;
            TranscriptionToken.ipaPhoneSequence.getter();
            uint64_t v64 = v63;
            id v65 = objc_allocWithZone((Class)&OBJC_CLASS___RDSAPIObjCSpeechAnalyzerTranscriptionToken);
            NSString v66 = String._bridgeToObjectiveC()();
            swift_bridgeObjectRelease(v370, v67);
            NSString v68 = String._bridgeToObjectiveC()();
            swift_bridgeObjectRelease(v62, v69);
            NSString v70 = String._bridgeToObjectiveC()();
            swift_bridgeObjectRelease(v64, v71);
            id v72 = [v65 initWithTokenName:v66 start:v364 & 1 end:v60 & 1 silenceStart:v68 confidence:v70 hasSpaceAfter:Seconds hasSpaceBefore:v54 phoneSequence:v58 ipaPhoneSequence:v59];

            if (!v72) {
              goto LABEL_72;
            }
            uint64_t v73 = v27[88];
            uint64_t v74 = v27[84];
            uint64_t v75 = v27[83];
            [v350 addObject:v72];

            (*(void (**)(uint64_t, uint64_t))(v74 + 8))(v73, v75);
            uint64_t v38 = (char *)v342 + (void)v38;
            uint64_t v36 = v357 - 1;
            if (v357 == 1)
            {
              swift_bridgeObjectRelease(v328, v76);
              uint64_t v31 = (uint64_t)v317;
              unint64_t v32 = v331;
              goto LABEL_9;
            }
          }
        }

        swift_bridgeObjectRelease(v33, v35);
LABEL_9:
        ++v32;
        [v325 addObject:v350];

        if (v32 == v322) {
          goto LABEL_38;
        }
      }

LABEL_68:
      __break(1u);
LABEL_69:
      __break(1u);
LABEL_70:
      __break(1u);
LABEL_71:
      __break(1u);
LABEL_72:
      __break(1u);
      goto LABEL_73;
    }

LABEL_38:
    swift_bridgeObjectRelease(v31, v30);
    uint64_t v181 = v27[96];
    uint64_t v182 = v27[93];
    uint64_t v183 = v27[92];
    sub_100051F0C(v325);

    (*(void (**)(uint64_t, uint64_t))(v182 + 8))(v181, v183);
LABEL_64:
    uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v27[108],  v27[98],  v27[100],  &protocol requirements base descriptor for AsyncSequence,  &associated conformance descriptor for AsyncSequence.AsyncSequence.AsyncIterator: AsyncIteratorProtocol);
    v308 = (void *)swift_task_alloc(_sScI4next9isolation7ElementQzSgScA_pSgYi_tYa7FailureQzYKFTjTu[1]);
    v27[111] = v308;
    void *v308 = v27;
    v308[1] = sub_1000502D8;
    _sScI4next9isolation7ElementQzSgScA_pSgYi_tYa7FailureQzYKFTj( v27[97],  0LL,  0LL,  v27 + 71,  v27[100],  AssociatedConformanceWitness);
    return;
  }

  uint64_t v27 = (void *)v0;
  if ((_DWORD)v24 != *(_DWORD *)(v0 + 1092))
  {
    uint64_t v184 = *(void *)(v0 + 768);
    uint64_t v185 = *(void *)(v0 + 736);
    uint64_t v186 = *(void *)(v0 + 728);
    uint64_t v187 = *(void *)(v0 + 720);
    uint64_t v188 = *(void *)(v0 + 712);
    (*(void (**)(uint64_t, uint64_t))(v27[93] + 8LL))(v184, v185);
    (*(void (**)(uint64_t, uint64_t))(v187 + 8))(v186, v188);
    goto LABEL_64;
  }

  int v77 = (os_log_s *)Logger.logObject.getter(v24);
  os_log_type_t v78 = static os_log_type_t.debug.getter();
  if (os_log_type_enabled(v77, v78))
  {
    unsigned __int8 v79 = (uint8_t *)swift_slowAlloc(2LL, -1LL);
    *(_WORD *)unsigned __int8 v79 = 0;
    _os_log_impl((void *)&_mh_execute_header, v77, v78, "SpeechAnalyzer finalAndTerminal results", v79, 2u);
    swift_slowDealloc(v79, -1LL, -1LL);
  }

  id v312 = [objc_allocWithZone(NSMutableArray) init];
  uint64_t v80 = Transcriber.MultisegmentResult.segments.getter();
  uint64_t v311 = *(void *)(v80 + 16);
  if (v311)
  {
    unint64_t v82 = 0LL;
    v316 = (CMTime *)(v0 + 304);
    v318 = (CMTime *)(v0 + 280);
    v339 = (CMTime *)(v0 + 400);
    v343 = (CMTime *)(v0 + 376);
    v336 = (CMTime *)(v0 + 424);
    v315 = (CMTime *)(v0 + 328);
    uint64_t v83 = *(unsigned __int8 *)(*(void *)(v0 + 648) + 80LL);
    uint64_t v309 = v80;
    uint64_t v310 = v80 + ((v83 + 32) & ~v83);
    while (v82 < *(void *)(v80 + 16))
    {
      unint64_t v313 = v82;
      (*(void (**)(void, unint64_t, void))(v27[81] + 16LL))( v27[82],  v310 + *(void *)(v27[81] + 72LL) * v82,  v27[80]);
      id v326 = [objc_allocWithZone(NSMutableArray) init];
      id v329 = [objc_allocWithZone(NSMutableArray) init];
      uint64_t v88 = TranscriptionSegment.tokens.getter();
      uint64_t v90 = *(void *)(v88 + 16);
      if (v90)
      {
        uint64_t v91 = v27[84];
        uint64_t v346 = v88;
        unint64_t v92 = v88 + ((*(unsigned __int8 *)(v91 + 80) + 32LL) & ~(unint64_t)*(unsigned __int8 *)(v91 + 80));
        uint64_t v351 = *(void *)(v91 + 72);
        v358 = *(uint64_t (**)(void, unint64_t, void))(v91 + 16);
        while (1)
        {
          uint64_t v93 = v27[105];
          uint64_t v94 = v358(v27[87], v92, v27[83]);
          uint64_t v95 = TranscriptionToken.tokenName.getter(v94);
          uint64_t v97 = v96;
          v27[60] = v95;
          v27[61] = v96;
          unint64_t v98 = sub_1000587BC();
          StringProtocol.trimmingCharacters(in:)(v93, &type metadata for String, v98);
          uint64_t v100 = v99;
          __n128 v101 = swift_bridgeObjectRelease(v97, v99);
          v27[35] = TranscriptionToken.start.getter(v101);
          *((_DWORD *)v27 + 72) = v102;
          *((_DWORD *)v27 + 73) = v103;
          v27[37] = v104;
          double v105 = CMTimeGetSeconds(v318);
          v27[38] = TranscriptionToken.end.getter();
          *((_DWORD *)v27 + 7_Block_object_dispose(va, 8) = v106;
          *((_DWORD *)v27 + 79) = v107;
          v27[40] = v108;
          double v109 = CMTimeGetSeconds(v316);
          v27[41] = TranscriptionToken.silenceStart.getter();
          *((_DWORD *)v27 + 84) = v110;
          *((_DWORD *)v27 + 85) = v111;
          v27[43] = v112;
          double v113 = CMTimeGetSeconds(v315);
          double v114 = TranscriptionToken.confidence.getter();
          char v371 = TranscriptionToken.hasSpaceAfter.getter();
          char v365 = TranscriptionToken.hasSpaceBefore.getter();
          TranscriptionToken.phoneSequence.getter();
          uint64_t v116 = v115;
          TranscriptionToken.ipaPhoneSequence.getter();
          uint64_t v118 = v117;
          id v119 = objc_allocWithZone((Class)&OBJC_CLASS___RDSAPIObjCSpeechAnalyzerTranscriptionToken);
          NSString v120 = String._bridgeToObjectiveC()();
          swift_bridgeObjectRelease(v100, v121);
          NSString v122 = String._bridgeToObjectiveC()();
          swift_bridgeObjectRelease(v116, v123);
          NSString v124 = String._bridgeToObjectiveC()();
          swift_bridgeObjectRelease(v118, v125);
          id v126 = [v119 initWithTokenName:v120 start:v371 & 1 end:v365 & 1 silenceStart:v122 confidence:v124 hasSpaceAfter:v105 hasSpaceBefore:v109 phoneSequence:v113 ipaPhoneSequence:v114];

          if (!v126) {
            goto LABEL_75;
          }
          uint64_t v127 = v27[87];
          uint64_t v128 = v27[84];
          uint64_t v129 = v27[83];
          [v329 addObject:v126];

          (*(void (**)(uint64_t, uint64_t))(v128 + 8))(v127, v129);
          v92 += v351;
          if (!--v90)
          {
            uint64_t v88 = v346;
            break;
          }
        }
      }

      *(void *)&double v130 = swift_bridgeObjectRelease(v88, v89).n128_u64[0];
      uint64_t v131 = TranscriptionSegment.alternativeTokens.getter(objc_msgSend(v326, "addObject:", v329, v130));
      uint64_t v133 = v131;
      uint64_t v323 = *(void *)(v131 + 16);
      if (v323)
      {
        unint64_t v134 = 0LL;
        uint64_t v320 = v131 + 32;
        uint64_t v314 = v131;
        while (v134 < *(void *)(v133 + 16))
        {
          uint64_t v136 = *(void *)(v320 + 8 * v134);
          id v137 = objc_allocWithZone(&OBJC_CLASS___NSMutableArray);
          swift_bridgeObjectRetain(v136);
          id v359 = [v137 init];
          uint64_t v139 = *(void *)(v136 + 16);
          if (v139)
          {
            uint64_t v332 = v136;
            unint64_t v334 = v134;
            uint64_t v140 = v27[84];
            uint64_t v141 = v136
                 + ((*(unsigned __int8 *)(v140 + 80) + 32LL) & ~(unint64_t)*(unsigned __int8 *)(v140 + 80));
            uint64_t v347 = *(void *)(v140 + 72);
            v352 = *(uint64_t (**)(void, uint64_t, void))(v140 + 16);
            while (1)
            {
              uint64_t v366 = v139;
              uint64_t v142 = v27[105];
              uint64_t v143 = v352(v27[86], v141, v27[83]);
              uint64_t v144 = TranscriptionToken.tokenName.getter(v143);
              uint64_t v146 = v145;
              v27[56] = v144;
              v27[57] = v145;
              unint64_t v147 = sub_1000587BC();
              StringProtocol.trimmingCharacters(in:)(v142, &type metadata for String, v147);
              uint64_t v149 = v148;
              __n128 v150 = swift_bridgeObjectRelease(v146, v148);
              v27[47] = TranscriptionToken.start.getter(v150);
              *((_DWORD *)v27 + 96) = v151;
              *((_DWORD *)v27 + 97) = v152;
              v27[49] = v153;
              double v154 = CMTimeGetSeconds(v343);
              v27[50] = TranscriptionToken.end.getter();
              *((_DWORD *)v27 + 102) = v155;
              *((_DWORD *)v27 + 103) = v156;
              v27[52] = v157;
              double v158 = CMTimeGetSeconds(v339);
              v27[53] = TranscriptionToken.silenceStart.getter();
              *((_DWORD *)v27 + 10_Block_object_dispose(va, 8) = v159;
              *((_DWORD *)v27 + 109) = v160;
              v27[55] = v161;
              double v162 = CMTimeGetSeconds(v336);
              double v163 = TranscriptionToken.confidence.getter();
              char v372 = TranscriptionToken.hasSpaceAfter.getter();
              char v164 = TranscriptionToken.hasSpaceBefore.getter();
              TranscriptionToken.phoneSequence.getter();
              uint64_t v166 = v165;
              TranscriptionToken.ipaPhoneSequence.getter();
              uint64_t v168 = v167;
              id v169 = objc_allocWithZone((Class)&OBJC_CLASS___RDSAPIObjCSpeechAnalyzerTranscriptionToken);
              NSString v170 = String._bridgeToObjectiveC()();
              swift_bridgeObjectRelease(v149, v171);
              NSString v172 = String._bridgeToObjectiveC()();
              swift_bridgeObjectRelease(v166, v173);
              NSString v174 = String._bridgeToObjectiveC()();
              swift_bridgeObjectRelease(v168, v175);
              id v176 = [v169 initWithTokenName:v170 start:v372 & 1 end:v164 & 1 silenceStart:v172 confidence:v174 hasSpaceAfter:v154 hasSpaceBefore:v158 phoneSequence:v162 ipaPhoneSequence:v163];

              if (!v176) {
                goto LABEL_71;
              }
              uint64_t v177 = v27[86];
              uint64_t v178 = v27[84];
              uint64_t v179 = v27[83];
              [v359 addObject:v176];

              (*(void (**)(uint64_t, uint64_t))(v178 + 8))(v177, v179);
              v141 += v347;
              uint64_t v139 = v366 - 1;
              if (v366 == 1)
              {
                unint64_t v135 = swift_bridgeObjectRelease(v332, v180).n128_u64[0];
                uint64_t v133 = v314;
                unint64_t v134 = v334;
                goto LABEL_31;
              }
            }
          }

          unint64_t v135 = swift_bridgeObjectRelease(v136, v138).n128_u64[0];
LABEL_31:
          ++v134;
          objc_msgSend(v326, "addObject:", v359, *(double *)&v135, v309);

          if (v134 == v323) {
            goto LABEL_21;
          }
        }

        goto LABEL_67;
      }

    if (*((void *)&v30 + 1)) {
      --**((_DWORD **)&v30 + 1);
    }
LABEL_40:
    if (v32) {
      (*(void (**)(uint64_t))(*(void *)v32 + 32LL))(v32);
    }
    else {
      ++v34;
    }
  }

  if (v32) {
    return (*(uint64_t (**)(void))(*(void *)v32 + 8LL))();
  }
  return result;
}

    if (*((void *)&v30 + 1)) {
      --**((_DWORD **)&v30 + 1);
    }
LABEL_40:
    if (v32) {
      (*(void (**)(uint64_t))(*(void *)v32 + 32LL))(v32);
    }
    else {
      ++v34;
    }
  }

  if (v32) {
    return (*(uint64_t (**)(void))(*(void *)v32 + 8LL))();
  }
  return result;
}

uint64_t sub_100051840()
{
  uint64_t v36 = v0 + 560;
  uint64_t v1 = v0 + 576;
  uint64_t v2 = *(void *)(v0 + 816);
  uint64_t v3 = *(void *)(v0 + 808);
  uint64_t v4 = *(void *)(v0 + 800);
  swift_release(*(void *)(v0 + 856));
  (*(void (**)(uint64_t, uint64_t))(v3 + 8))(v2, v4);
  uint64_t v5 = *(void *)(v0 + 568);
  swift_errorRetain(v5);
  uint64_t v6 = swift_errorRetain(v5);
  uint64_t v7 = (os_log_s *)Logger.logObject.getter(v6);
  os_log_type_t v8 = static os_log_type_t.error.getter();
  if (os_log_type_enabled(v7, v8))
  {
    uint64_t v9 = (uint8_t *)swift_slowAlloc(12LL, -1LL);
    uint64_t v10 = (uint64_t *)swift_slowAlloc(8LL, -1LL);
    *(_DWORD *)uint64_t v9 = 138412290;
    swift_errorRetain(v5);
    uint64_t v11 = _swift_stdlib_bridgeErrorToNSError(v5);
    *(void *)(v0 + 552) = v11;
    UnsafeMutableRawBufferPointer.copyMemory(from:)(v0 + 552, v36, v9 + 4);
    *uint64_t v10 = v11;
    swift_errorRelease(v5);
    swift_errorRelease(v5);
    _os_log_impl((void *)&_mh_execute_header, v7, v8, "Speech API Recognition Error = %@", v9, 0xCu);
    uint64_t v12 = sub_10004B5C0(&qword_1000DD6D8);
    swift_arrayDestroy(v10, 1LL, v12);
    uint64_t v13 = v10;
    uint64_t v1 = v0 + 576;
    swift_slowDealloc(v13, -1LL, -1LL);
    swift_slowDealloc(v9, -1LL, -1LL);
  }

  else
  {

    swift_errorRelease(v5);
    swift_errorRelease(v5);
  }

  swift_getErrorValue(v5, v1, v0 + 160);
  uint64_t v14 = dispatch thunk of Error._domain.getter(*(void *)(v0 + 168), *(void *)(v0 + 176));
  uint64_t v16 = v15;
  if (v14 == 0x726F727245524145LL && v15 == 0xEE006E69616D6F44LL)
  {
    swift_bridgeObjectRelease(0xEE006E69616D6F44LL, 0xEE006E69616D6F44LL);
  }

  else
  {
    char v17 = _stringCompareWithSmolCheck(_:_:expecting:)(v14, v15, 0x726F727245524145LL, 0xEE006E69616D6F44LL, 0LL);
    swift_bridgeObjectRelease(v16, v18);
    if ((v17 & 1) == 0)
    {
LABEL_10:
      uint64_t v19 = *(void *)(v0 + 840);
      uint64_t v20 = *(void *)(v0 + 832);
      uint64_t v21 = *(void *)(v0 + 824);
      sub_1000520EC(v5);
      swift_errorRelease(v5);
      (*(void (**)(uint64_t, uint64_t))(v20 + 8))(v19, v21);
      goto LABEL_11;
    }
  }

  swift_getErrorValue(v5, v36, v0 + 208);
  if (!dispatch thunk of Error._code.getter(*(void *)(v0 + 216), *(void *)(v0 + 224))) {
    goto LABEL_10;
  }
  (*(void (**)(void, void))(*(void *)(v0 + 832) + 8LL))(*(void *)(v0 + 840), *(void *)(v0 + 824));
  swift_errorRelease(v5);
LABEL_11:
  uint64_t v22 = *(void *)(v0 + 816);
  uint64_t v23 = *(void *)(v0 + 792);
  uint64_t v24 = *(void *)(v0 + 776);
  uint64_t v25 = *(void *)(v0 + 768);
  uint64_t v26 = *(void *)(v0 + 760);
  uint64_t v27 = *(void *)(v0 + 752);
  uint64_t v28 = *(void *)(v0 + 728);
  uint64_t v29 = *(void *)(v0 + 704);
  uint64_t v30 = *(void *)(v0 + 696);
  uint64_t v32 = *(void *)(v0 + 688);
  uint64_t v33 = *(void *)(v0 + 680);
  uint64_t v34 = *(void *)(v0 + 656);
  uint64_t v35 = *(void *)(v0 + 632);
  uint64_t v37 = *(void *)(v0 + 608);
  swift_task_dealloc(*(void *)(v0 + 840));
  swift_task_dealloc(v22);
  swift_task_dealloc(v23);
  swift_task_dealloc(v24);
  swift_task_dealloc(v25);
  swift_task_dealloc(v26);
  swift_task_dealloc(v27);
  swift_task_dealloc(v28);
  swift_task_dealloc(v29);
  swift_task_dealloc(v30);
  swift_task_dealloc(v32);
  swift_task_dealloc(v33);
  swift_task_dealloc(v34);
  swift_task_dealloc(v35);
  swift_task_dealloc(v37);
  return (*(uint64_t (**)(void))(v0 + 8))();
}

void sub_100051CC8(void *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = v3;
  id v7 = a1;
  os_log_type_t v8 = (os_log_s *)Logger.logObject.getter(v7);
  os_log_type_t v9 = static os_log_type_t.debug.getter();
  if (os_log_type_enabled(v8, v9))
  {
    uint64_t v10 = (uint8_t *)swift_slowAlloc(12LL, -1LL);
    uint64_t v24 = a3;
    id v25 = v7;
    uint64_t v11 = (void *)swift_slowAlloc(8LL, -1LL);
    *(_DWORD *)uint64_t v10 = 138412290;
    uint64_t v12 = a2;
    id v13 = v7;
    UnsafeMutableRawBufferPointer.copyMemory(from:)(&v25, &v26, v10 + 4);
    *uint64_t v11 = v7;

    a2 = v12;
    _os_log_impl((void *)&_mh_execute_header, v8, v9, "Called the callback with final results = %@", v10, 0xCu);
    uint64_t v14 = sub_10004B5C0(&qword_1000DD6D8);
    swift_arrayDestroy(v11, 1LL, v14);
    uint64_t v15 = v11;
    a3 = v24;
    swift_slowDealloc(v15, -1LL, -1LL);
    swift_slowDealloc(v10, -1LL, -1LL);
  }

  else
  {
  }

  uint64_t v16 = (*(uint64_t (**)(void))((swift_isaMask & *v4) + 0xC8LL))();
  if (v16)
  {
    char v17 = (void *)v16;
    id v25 = 0LL;
    static Array._conditionallyBridgeFromObjectiveC(_:result:)(v7, &v25, (char *)&type metadata for Any + 8);
    id v18 = v25;
    if (v25)
    {
      v19.super.Class isa = Array._bridgeToObjectiveC()().super.isa;
      swift_bridgeObjectRelease(v18, v20);
    }

    else
    {
      v19.super.Class isa = 0LL;
    }

    id v25 = 0LL;
    static Array._forceBridgeFromObjectiveC(_:result:)(a2, &v25, (char *)&type metadata for Any + 8);
    id v21 = v25;
    if (v25)
    {
      Class isa = Array._bridgeToObjectiveC()().super.isa;
      swift_bridgeObjectRelease(v21, v23);
      [v17 didRecognizeFinalResults:v19.super.isa nBestResults:isa firstBestResult:a3];
    }

    else
    {
      __break(1u);
    }
  }

void sub_100051F0C(void *a1)
{
  uint64_t v2 = v1;
  id v3 = a1;
  uint64_t v4 = (os_log_s *)Logger.logObject.getter(v3);
  os_log_type_t v5 = static os_log_type_t.debug.getter();
  if (os_log_type_enabled(v4, v5))
  {
    uint64_t v6 = (uint8_t *)swift_slowAlloc(12LL, -1LL);
    id v7 = (void *)swift_slowAlloc(8LL, -1LL);
    *(_DWORD *)uint64_t v6 = 138412290;
    id v15 = v3;
    id v8 = v3;
    UnsafeMutableRawBufferPointer.copyMemory(from:)(&v15, &v16, v6 + 4);
    *id v7 = v3;

    _os_log_impl((void *)&_mh_execute_header, v4, v5, "Called the callback with partial results = %@", v6, 0xCu);
    uint64_t v9 = sub_10004B5C0(&qword_1000DD6D8);
    swift_arrayDestroy(v7, 1LL, v9);
    swift_slowDealloc(v7, -1LL, -1LL);
    swift_slowDealloc(v6, -1LL, -1LL);
  }

  else
  {
  }

  uint64_t v10 = (*(uint64_t (**)(void))((swift_isaMask & *v2) + 0xC8LL))();
  if (v10)
  {
    uint64_t v11 = (void *)v10;
    id v15 = 0LL;
    static Array._forceBridgeFromObjectiveC(_:result:)(v3, &v15, (char *)&type metadata for Any + 8);
    id v12 = v15;
    if (v15)
    {
      Class isa = Array._bridgeToObjectiveC()().super.isa;
      swift_bridgeObjectRelease(v12, v14);
      [v11 didRecognizePartialResultTokens:isa];
    }

    else
    {
      __break(1u);
    }
  }

void sub_1000520EC(uint64_t a1)
{
  uint64_t v2 = v1;
  uint64_t v4 = (os_log_s *)Logger.logObject.getter();
  os_log_type_t v5 = static os_log_type_t.default.getter();
  if (os_log_type_enabled(v4, v5))
  {
    uint64_t v6 = (uint8_t *)swift_slowAlloc(2LL, -1LL);
    *(_WORD *)uint64_t v6 = 0;
    _os_log_impl((void *)&_mh_execute_header, v4, v5, "SpeechAPI Recognition Error", v6, 2u);
    swift_slowDealloc(v6, -1LL, -1LL);
  }

  uint64_t v7 = (*(uint64_t (**)(void))((swift_isaMask & *v2) + 0xC8LL))();
  if (v7)
  {
    id v8 = (void *)v7;
    id v9 = (id)_convertErrorToNSError(_:)(a1);
    [v8 didFinishRecognitionWithError:v9];
  }

Swift::Void __swiftcall RDSAPISwiftSpeechAnalyzer.startRecognitionFromFile()()
{
  uint64_t v0 = sub_10004B5C0(&qword_1000DD628);
  __chkstk_darwin(v0);
  os_log_type_t v78 = (char *)&v77 - ((v1 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v2 = sub_10004B5C0(&qword_1000DD6B8);
  __chkstk_darwin(v2);
  uint64_t v80 = (char *)&v77 - ((v3 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v4 = type metadata accessor for ClientInfo(0LL);
  uint64_t v83 = *(void *)(v4 - 8);
  uint64_t v84 = v4;
  uint64_t v5 = __chkstk_darwin(v4);
  unint64_t v82 = (char *)&v77 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  __chkstk_darwin(v5);
  uint64_t v81 = (char *)&v77 - v7;
  uint64_t v92 = sub_10004B5C0(&qword_1000DD770);
  uint64_t v90 = *(void *)(v92 - 8);
  __chkstk_darwin(v92);
  uint64_t v88 = (char *)&v77 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v93 = sub_10004B5C0(&qword_1000DD6C8);
  uint64_t v91 = *(void *)(v93 - 8);
  __chkstk_darwin(v93);
  uint64_t v89 = (char *)&v77 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v96 = sub_10004B5C0(&qword_1000DD6C0);
  uint64_t v94 = *(void *)(v96 - 8);
  __chkstk_darwin(v96);
  uint64_t v95 = (char *)&v77 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v11 = type metadata accessor for URL(0LL);
  uint64_t v86 = *(void *)(v11 - 8);
  uint64_t v87 = v11;
  __chkstk_darwin(v11);
  uint64_t v97 = (uint64_t)&v77 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v13 = type metadata accessor for Locale(0LL);
  __chkstk_darwin(v13);
  id v15 = (char *)&v77 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v16 = sub_10004B5C0(&qword_1000DD6E8);
  __chkstk_darwin(v16);
  id v18 = (char *)&v77 - ((v17 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v19 = sub_10004B5C0(&qword_1000DD6B0);
  __chkstk_darwin(v19);
  id v21 = (char *)&v77 - ((v20 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v22 = type metadata accessor for TaskHint(0LL);
  (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(*(void *)(v22 - 8) + 56LL))(v21, 1LL, 1LL, v22);
  uint64_t v23 = type metadata accessor for Transcriber.ModelOptions(0LL);
  (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(*(void *)(v23 - 8) + 56LL))(v18, 1LL, 1LL, v23);
  uint64_t v24 = sub_10004B5C0(&qword_1000DD778);
  uint64_t v25 = type metadata accessor for Transcriber.ReportingOption(0LL);
  uint64_t v26 = *(void *)(v25 - 8);
  uint64_t v27 = *(unsigned __int8 *)(v26 + 80);
  uint64_t v28 = (v27 + 32) & ~v27;
  uint64_t v29 = swift_allocObject(v24, v28 + *(void *)(v26 + 72), v27 | 7);
  __int128 v79 = xmmword_1000AC520;
  *(_OWORD *)(v29 + 16) = xmmword_1000AC520;
  uint64_t v30 = v29 + v28;
  (*(void (**)(uint64_t, void, uint64_t))(v26 + 104))( v30,  enum case for Transcriber.ReportingOption.multisegmentResults(_:),  v25);
  uint64_t v31 = sub_1000568E8(v29);
  swift_setDeallocating(v29);
  swift_arrayDestroy(v30, 1LL, v25);
  uint64_t v32 = swift_deallocClassInstance(v29, 32LL, 7LL);
  static Locale.current.getter(v32);
  uint64_t v33 = sub_10004B5C0(&qword_1000DD710);
  uint64_t v34 = type metadata accessor for Transcriber.TranscriptionOption(0LL);
  uint64_t v35 = *(void *)(v34 - 8);
  uint64_t v36 = *(void *)(v35 + 72);
  uint64_t v37 = *(unsigned __int8 *)(v35 + 80);
  uint64_t v38 = (v37 + 32) & ~v37;
  uint64_t v39 = swift_allocObject(v33, v38 + 3 * v36, v37 | 7);
  *(_OWORD *)(v39 + 16) = xmmword_1000AC550;
  uint64_t v40 = v39 + v38;
  uint64_t v41 = *(void (**)(uint64_t, void, uint64_t))(v35 + 104);
  v41(v40, enum case for Transcriber.TranscriptionOption.contextualizedTranscription(_:), v34);
  v41(v40 + v36, enum case for Transcriber.TranscriptionOption.punctuation(_:), v34);
  v41(v40 + 2 * v36, enum case for Transcriber.TranscriptionOption.emoji(_:), v34);
  uint64_t v42 = sub_100056B50(v39);
  swift_setDeallocating(v39);
  swift_arrayDestroy(v40, 3LL, v34);
  swift_deallocClassInstance(v39, 32LL, 7LL);
  uint64_t v43 = type metadata accessor for Transcriber(0LL);
  swift_allocObject(v43, *(unsigned int *)(v43 + 48), *(unsigned __int16 *)(v43 + 52));
  uint64_t v44 = Transcriber.init(locale:taskHint:modelOptions:transcriptionOptions:reportingOptions:attributeOptions:)( v15,  v21,  v18,  v42,  v31,  &_swiftEmptySetSingleton);
  type metadata accessor for RDSAPISwiftSpeechAnalyzer(0LL);
  sub_100052B60(v97);
  id v45 = [objc_allocWithZone(AVAudioFormat) initWithCommonFormat:3 sampleRate:1 channels:0 interleaved:16000.0];
  if (v45)
  {
    __n128 v46 = v45;
    uint64_t v47 = type metadata accessor for AudioStream(0LL);
    uint64_t v48 = swift_allocObject(v47, *(unsigned int *)(v47 + 48), *(unsigned __int16 *)(v47 + 52));
    *(void *)(v48 + OBJC_IVAR____TtC50com_apple_SpeechRecognitionCore_speechrecognitiond11AudioStream_avFile) = 0LL;
    *(void *)(v48 + OBJC_IVAR____TtC50com_apple_SpeechRecognitionCore_speechrecognitiond11AudioStream_avConverter) = 0LL;
    uint64_t v49 = type metadata accessor for AnalyzerInput(0LL);
    uint64_t v50 = v90;
    int v51 = v88;
    uint64_t v52 = v92;
    (*(void (**)(char *, void, uint64_t))(v90 + 104))( v88,  enum case for AsyncStream.Continuation.BufferingPolicy.unbounded<A>(_:),  v92);
    id v53 = v46;
    double v54 = v95;
    int v55 = v89;
    static AsyncStream.makeStream(of:bufferingPolicy:)(v95, v89, v49, v51, v49);
    (*(void (**)(char *, uint64_t))(v50 + 8))(v51, v52);
    uint64_t v56 = v94;
    (*(void (**)(uint64_t, char *, uint64_t))(v94 + 32))( v48 + OBJC_IVAR____TtC50com_apple_SpeechRecognitionCore_speechrecognitiond11AudioStream_audioStream,  v54,  v96);
    (*(void (**)(uint64_t, char *, uint64_t))(v91 + 32))( v48 + OBJC_IVAR____TtC50com_apple_SpeechRecognitionCore_speechrecognitiond11AudioStream_audioStreamGenerator,  v55,  v93);
    sub_100054010(v97, (uint64_t)v53);
    uint64_t v57 = v82;
    ClientInfo.init(identifier:)(0x75706E49656C6946LL, 0xE900000000000074LL);
    uint64_t v93 = type metadata accessor for SpeechAnalyzer(0LL);
    (*(void (**)(char *, char *, uint64_t))(v83 + 16))(v81, v57, v84);
    double v59 = v95;
    uint64_t v58 = v96;
    (*(void (**)(char *, uint64_t, uint64_t))(v56 + 16))( v95,  v48 + OBJC_IVAR____TtC50com_apple_SpeechRecognitionCore_speechrecognitiond11AudioStream_audioStream,  v96);
    uint64_t v60 = sub_10004B5C0(&qword_1000DD780);
    uint64_t v61 = swift_allocObject(v60, 48LL, 7LL);
    *(_OWORD *)(v61 + 16) = v79;
    uint64_t v62 = sub_100058894( &qword_1000DD788,  (uint64_t (*)(uint64_t))&type metadata accessor for Transcriber,  (uint64_t)&protocol conformance descriptor for Transcriber);
    *(void *)(v61 + 32) = v44;
    *(void *)(v61 + 4RDString::RDString((RDString *)&v66, theString, 0) = v62;
    uint64_t v63 = type metadata accessor for AnalysisOptions(0LL);
    uint64_t v64 = v80;
    (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(*(void *)(v63 - 8) + 56LL))(v80, 1LL, 1LL, v63);
    id v65 = objc_allocWithZone((Class)type metadata accessor for AnalysisContext(0LL));
    id v66 = v53;
    uint64_t v94 = v44;
    swift_retain(v44);
    id v67 = [v65 init];
    unint64_t v68 = sub_100057E48();
    uint64_t v69 = SpeechAnalyzer.__allocating_init<A>(client:inputSequence:audioFormat:modules:options:restrictedLogging:analysisContext:didChangeVolatileRange:)( v81,  v59,  v66,  v61,  v64,  1LL,  v67,  0LL,  0LL,  v58,  v68);
    sub_100054278((void (*)(id, void *))sub_100057ED8, v48, sub_100057EE0);
    uint64_t v70 = type metadata accessor for TaskPriority(0LL);
    uint64_t v71 = (uint64_t)v78;
    (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(*(void *)(v70 - 8) + 56LL))(v78, 1LL, 1LL, v70);
    id v72 = (void *)swift_allocObject(&unk_1000D0240, 56LL, 7LL);
    v72[2] = 0LL;
    v72[3] = 0LL;
    uint64_t v73 = v94;
    v72[4] = v69;
    v72[5] = v73;
    uint64_t v74 = v85;
    v72[6] = v85;
    swift_retain(v73);
    swift_retain(v69);
    id v75 = v74;
    uint64_t v76 = sub_100053498(v71, (uint64_t)&unk_1000DD7A0, (uint64_t)v72);

    swift_release(v73);
    swift_release(v69);
    swift_release(v48);
    swift_release(v76);
    (*(void (**)(char *, uint64_t))(v83 + 8))(v82, v84);
    (*(void (**)(uint64_t, uint64_t))(v86 + 8))(v97, v87);
  }

  else
  {
    __break(1u);
  }

uint64_t sub_100052B60@<X0>(uint64_t a1@<X8>)
{
  uint64_t v2 = type metadata accessor for URL(0LL);
  uint64_t v3 = *(void *)(v2 - 8);
  __chkstk_darwin(v2);
  uint64_t v5 = (char *)&v17 - ((v4 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v6 = sub_10004B5C0(&qword_1000DD7A8);
  __chkstk_darwin(v6);
  uint64_t v8 = (char *)&v17 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v9 = type metadata accessor for AudioStream(0LL);
  uint64_t ObjCClassFromMetadata = swift_getObjCClassFromMetadata(v9);
  id v11 = [(id)objc_opt_self(NSBundle) bundleForClass:ObjCClassFromMetadata];
  NSString v12 = String._bridgeToObjectiveC()();
  NSString v13 = String._bridgeToObjectiveC()();
  id v14 = [v11 URLForResource:v12 withExtension:v13];

  if (v14)
  {
    static URL._unconditionallyBridgeFromObjectiveC(_:)(v14);

    id v15 = *(void (**)(char *, char *, uint64_t))(v3 + 32);
    v15(v8, v5, v2);
    (*(void (**)(char *, void, uint64_t, uint64_t))(v3 + 56))(v8, 0LL, 1LL, v2);
    uint64_t result = (*(uint64_t (**)(char *, uint64_t, uint64_t))(v3 + 48))(v8, 1LL, v2);
    if ((_DWORD)result != 1) {
      return ((uint64_t (*)(uint64_t, char *, uint64_t))v15)(a1, v8, v2);
    }
  }

  else
  {
    uint64_t result = (*(uint64_t (**)(char *, uint64_t, uint64_t, uint64_t))(v3 + 56))(v8, 1LL, 1LL, v2);
  }

  __break(1u);
  return result;
}

uint64_t sub_100052D30()
{
  uint64_t v1 = v0;
  uint64_t v2 = sub_10004B5C0(&qword_1000DD770);
  uint64_t v3 = *(void *)(v2 - 8);
  __chkstk_darwin(v2);
  uint64_t v5 = (char *)&v16 - ((v4 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v17 = sub_10004B5C0(&qword_1000DD6C8);
  uint64_t v6 = *(void *)(v17 - 8);
  __chkstk_darwin(v17);
  uint64_t v8 = (char *)&v16 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v9 = sub_10004B5C0(&qword_1000DD6C0);
  uint64_t v10 = *(void *)(v9 - 8);
  __chkstk_darwin(v9);
  NSString v12 = (char *)&v16 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v13 = swift_allocObject(v1, *(unsigned int *)(v1 + 48), *(unsigned __int16 *)(v1 + 52));
  *(void *)(v13 + OBJC_IVAR____TtC50com_apple_SpeechRecognitionCore_speechrecognitiond11AudioStream_avFile) = 0LL;
  *(void *)(v13 + OBJC_IVAR____TtC50com_apple_SpeechRecognitionCore_speechrecognitiond11AudioStream_avConverter) = 0LL;
  uint64_t v14 = type metadata accessor for AnalyzerInput(0LL);
  (*(void (**)(char *, void, uint64_t))(v3 + 104))( v5,  enum case for AsyncStream.Continuation.BufferingPolicy.unbounded<A>(_:),  v2);
  static AsyncStream.makeStream(of:bufferingPolicy:)(v12, v8, v14, v5, v14);
  (*(void (**)(char *, uint64_t))(v3 + 8))(v5, v2);
  (*(void (**)(uint64_t, char *, uint64_t))(v10 + 32))( v13 + OBJC_IVAR____TtC50com_apple_SpeechRecognitionCore_speechrecognitiond11AudioStream_audioStream,  v12,  v9);
  (*(void (**)(uint64_t, char *, uint64_t))(v6 + 32))( v13 + OBJC_IVAR____TtC50com_apple_SpeechRecognitionCore_speechrecognitiond11AudioStream_audioStreamGenerator,  v8,  v17);
  return v13;
}

uint64_t sub_100052EE0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  v6[3] = a5;
  void v6[4] = a6;
  uint64_t v7 = type metadata accessor for Transcriber.MultisegmentResult(0LL);
  v6[5] = v7;
  uint64_t v8 = *(void *)(v7 - 8);
  v6[6] = v8;
  v6[7] = swift_task_alloc((*(void *)(v8 + 64) + 15LL) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v9 = sub_10004B5C0(&qword_1000DD9C8);
  uint8_t v6[8] = swift_task_alloc((*(void *)(*(void *)(v9 - 8) + 64LL) + 15LL) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v10 = sub_10004B5C0(&qword_1000DD9D0);
  v6[9] = v10;
  void v6[10] = swift_task_alloc((*(void *)(*(void *)(v10 - 8) + 64LL) + 15LL) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v11 = sub_10004B5C0(&qword_1000DD9D8);
  v6[11] = v11;
  uint64_t v12 = *(void *)(v11 - 8);
  v6[12] = v12;
  v6[13] = swift_task_alloc((*(void *)(v12 + 64) + 15LL) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v13 = (void *)swift_task_alloc(async function pointer to SpeechAnalyzer.finalizeAndFinishThroughEndOfInput()[1]);
  v6[14] = v13;
  *uint64_t v13 = v6;
  v13[1] = sub_100052FD0;
  return SpeechAnalyzer.finalizeAndFinishThroughEndOfInput()();
}

uint64_t sub_100052FD0()
{
  uint64_t v2 = (void *)*v1;
  uint64_t v3 = *(void *)(*v1 + 112);
  uint64_t v4 = *v1;
  swift_task_dealloc(v3);
  if (!v0) {
    return swift_task_switch(sub_10005306C, 0LL, 0LL);
  }
  uint64_t v5 = v2[13];
  uint64_t v6 = v2[10];
  uint64_t v9 = v2 + 7;
  uint64_t v8 = v2[7];
  uint64_t v7 = v9[1];
  swift_task_dealloc(v5);
  swift_task_dealloc(v6);
  swift_task_dealloc(v7);
  swift_task_dealloc(v8);
  return (*(uint64_t (**)(void))(v4 + 8))();
}

uint64_t sub_10005306C()
{
  uint64_t v1 = v0[9];
  uint64_t v2 = Transcriber.multisegmentResults.getter();
  uint64_t OpaqueTypeConformance2 = swift_getOpaqueTypeConformance2( v2,  &opaque type descriptor for <<opaque return type of Transcriber.multisegmentResults>>,  1LL);
  v0[15] = OpaqueTypeConformance2;
  dispatch thunk of AsyncSequence.makeAsyncIterator()(v1, OpaqueTypeConformance2);
  v0[16] = OBJC_IVAR____TtC50com_apple_SpeechRecognitionCore_speechrecognitiond25RDSAPISwiftSpeechAnalyzer__logger;
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v0[15],  v0[9],  v0[11],  &protocol requirements base descriptor for AsyncSequence,  &associated conformance descriptor for AsyncSequence.AsyncSequence.AsyncIterator: AsyncIteratorProtocol);
  uint64_t v5 = (void *)swift_task_alloc(_sScI4next9isolation7ElementQzSgScA_pSgYi_tYa7FailureQzYKFTjTu[1]);
  v0[17] = v5;
  void *v5 = v0;
  v5[1] = sub_100053154;
  return _sScI4next9isolation7ElementQzSgScA_pSgYi_tYa7FailureQzYKFTj( v0[8],  0LL,  0LL,  v0 + 2,  v0[11],  AssociatedConformanceWitness);
}

uint64_t sub_100053154()
{
  if (v0) {
    uint64_t v2 = sub_10005342C;
  }
  else {
    uint64_t v2 = sub_1000531B8;
  }
  return swift_task_switch(v2, 0LL, 0LL);
}

uint64_t sub_1000531B8()
{
  uint64_t v1 = *(void *)(v0 + 64);
  uint64_t v2 = *(void *)(v0 + 40);
  uint64_t v3 = *(void *)(v0 + 48);
  if ((*(unsigned int (**)(uint64_t, uint64_t, uint64_t))(v3 + 48))(v1, 1LL, v2) == 1)
  {
    uint64_t v4 = *(void *)(v0 + 104);
    uint64_t v5 = *(void *)(v0 + 80);
    uint64_t v6 = *(void *)(v0 + 56);
    (*(void (**)(uint64_t, void))(*(void *)(v0 + 96) + 8LL))(v4, *(void *)(v0 + 88));
    swift_task_dealloc(v4);
    swift_task_dealloc(v5);
    swift_task_dealloc(v1);
    swift_task_dealloc(v6);
    return (*(uint64_t (**)(void))(v0 + 8))();
  }

  else
  {
    uint64_t v8 = (*(uint64_t (**)(void, uint64_t, uint64_t))(v3 + 32))(*(void *)(v0 + 56), v1, v2);
    uint64_t v9 = (os_log_s *)Logger.logObject.getter(v8);
    os_log_type_t v10 = static os_log_type_t.debug.getter();
    BOOL v11 = os_log_type_enabled(v9, v10);
    uint64_t v13 = *(void *)(v0 + 48);
    uint64_t v12 = *(void *)(v0 + 56);
    uint64_t v14 = *(void *)(v0 + 40);
    if (v11)
    {
      uint64_t v15 = swift_slowAlloc(12LL, -1LL);
      uint64_t v16 = swift_slowAlloc(32LL, -1LL);
      uint64_t v25 = v16;
      *(_DWORD *)uint64_t v15 = 136315138;
      uint64_t v17 = sub_100058894( &qword_1000DD9E0,  (uint64_t (*)(uint64_t))&type metadata accessor for Transcriber.MultisegmentResult,  (uint64_t)&protocol conformance descriptor for Transcriber.MultisegmentResult);
      uint64_t v18 = dispatch thunk of CustomStringConvertible.description.getter(v14, v17);
      unint64_t v20 = v19;
      *(void *)(v15 + 4) = sub_10004BAAC(v18, v19, &v25);
      __n128 v22 = swift_bridgeObjectRelease(v20, v21);
      (*(void (**)(uint64_t, uint64_t, __n128))(v13 + 8))(v12, v14, v22);
      _os_log_impl( (void *)&_mh_execute_header,  v9,  v10,  "Got recognition results from audio file %s",  (uint8_t *)v15,  0xCu);
      swift_arrayDestroy(v16, 1LL, (char *)&type metadata for Any + 8);
      swift_slowDealloc(v16, -1LL, -1LL);
      swift_slowDealloc(v15, -1LL, -1LL);
    }

    else
    {

      (*(void (**)(uint64_t, uint64_t))(v13 + 8))(v12, v14);
    }

    uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( *(void *)(v0 + 120),  *(void *)(v0 + 72),  *(void *)(v0 + 88),  &protocol requirements base descriptor for AsyncSequence,  &associated conformance descriptor for AsyncSequence.AsyncSequence.AsyncIterator: AsyncIteratorProtocol);
    uint64_t v24 = (void *)swift_task_alloc(_sScI4next9isolation7ElementQzSgScA_pSgYi_tYa7FailureQzYKFTjTu[1]);
    *(void *)(v0 + 136) = v24;
    *uint64_t v24 = v0;
    v24[1] = sub_100053154;
    return _sScI4next9isolation7ElementQzSgScA_pSgYi_tYa7FailureQzYKFTj( *(void *)(v0 + 64),  0LL,  0LL,  v0 + 16,  *(void *)(v0 + 88),  AssociatedConformanceWitness);
  }

uint64_t sub_10005342C()
{
  uint64_t v1 = *(void *)(v0 + 80);
  uint64_t v3 = *(void *)(v0 + 56);
  uint64_t v2 = *(void *)(v0 + 64);
  swift_task_dealloc(*(void *)(v0 + 104));
  swift_task_dealloc(v1);
  swift_task_dealloc(v2);
  swift_task_dealloc(v3);
  return (*(uint64_t (**)(void))(v0 + 8))();
}

uint64_t sub_100053498(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = type metadata accessor for TaskPriority(0LL);
  uint64_t v7 = *(void *)(v6 - 8);
  if ((*(unsigned int (**)(uint64_t, uint64_t, uint64_t))(v7 + 48))(a1, 1LL, v6) == 1)
  {
    sub_10004BA28(a1, &qword_1000DD628);
    uint64_t v8 = 7168LL;
    uint64_t v9 = *(void *)(a3 + 16);
    if (!v9)
    {
LABEL_6:
      uint64_t v15 = 0LL;
      return swift_task_create(v8, v15, (char *)&type metadata for () + 8, a2, a3);
    }
  }

  else
  {
    unsigned __int8 v16 = TaskPriority.rawValue.getter();
    (*(void (**)(uint64_t, uint64_t))(v7 + 8))(a1, v6);
    uint64_t v8 = v16 | 0x1C00LL;
    uint64_t v9 = *(void *)(a3 + 16);
    if (!v9) {
      goto LABEL_6;
    }
  }

  uint64_t v10 = *(void *)(a3 + 24);
  uint64_t ObjectType = swift_getObjectType(v9);
  swift_unknownObjectRetain(v9);
  uint64_t v12 = dispatch thunk of Actor.unownedExecutor.getter(ObjectType, v10);
  uint64_t v14 = v13;
  swift_unknownObjectRelease(v9);
  if (!(v14 | v12)) {
    goto LABEL_6;
  }
  v18[0] = 0LL;
  v18[1] = 0LL;
  uint64_t v15 = v18;
  v18[2] = v12;
  v18[3] = v14;
  return swift_task_create(v8, v15, (char *)&type metadata for () + 8, a2, a3);
}

uint64_t sub_100053600(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  v5[5] = a4;
  void v5[6] = a5;
  void v5[3] = a1;
  void v5[4] = a3;
  uint64_t v9 = *(void *)(a3 - 8);
  v5[7] = v9;
  v5[8] = swift_task_alloc((*(void *)(v9 + 64) + 15LL) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v10 = type metadata accessor for Optional(0LL, a3);
  v5[9] = v10;
  uint64_t v11 = *(void *)(v10 - 8);
  v5[10] = v11;
  v5[11] = swift_task_alloc((*(void *)(v11 + 64) + 15LL) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness( 0LL,  a5,  a4,  &protocol requirements base descriptor for AsyncSequence,  &associated type descriptor for AsyncSequence.Failure);
  v5[12] = AssociatedTypeWitness;
  uint64_t v13 = *(void *)(AssociatedTypeWitness - 8);
  v5[13] = v13;
  unint64_t v14 = (*(void *)(v13 + 64) + 15LL) & 0xFFFFFFFFFFFFFFF0LL;
  v5[14] = swift_task_alloc(v14);
  v5[15] = swift_task_alloc(v14);
  uint64_t v15 = swift_getAssociatedTypeWitness( 255LL,  a5,  a4,  &protocol requirements base descriptor for AsyncSequence,  &associated type descriptor for AsyncSequence.Element);
  uint8_t v5[16] = v15;
  uint64_t v16 = type metadata accessor for Optional(0LL, v15);
  v5[17] = swift_task_alloc((*(void *)(*(void *)(v16 - 8) + 64LL) + 15LL) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v17 = *(void *)(a4 - 8);
  v5[18] = v17;
  v5[19] = swift_task_alloc((*(void *)(v17 + 64) + 15LL) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v18 = swift_getAssociatedTypeWitness( 0LL,  a5,  a4,  &protocol requirements base descriptor for AsyncSequence,  &associated type descriptor for AsyncSequence.AsyncIterator);
  v5[20] = v18;
  uint64_t v19 = *(void *)(v18 - 8);
  v5[21] = v19;
  v5[22] = swift_task_alloc((*(void *)(v19 + 64) + 15LL) & 0xFFFFFFFFFFFFFFF0LL);
  return swift_task_switch(sub_100053788, 0LL, 0LL);
}

uint64_t sub_100053788()
{
  uint64_t v2 = v0[18];
  uint64_t v1 = v0[19];
  uint64_t v4 = v0[5];
  uint64_t v3 = v0[6];
  uint64_t v5 = v0[3];
  v0[2] = static Array._allocateUninitialized(_:)(0LL, v0[4]);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(v2 + 16))(v1, v5, v4);
  dispatch thunk of AsyncSequence.makeAsyncIterator()(v4, v3);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v0[6],  v0[5],  v0[20],  &protocol requirements base descriptor for AsyncSequence,  &associated conformance descriptor for AsyncSequence.AsyncSequence.AsyncIterator: AsyncIteratorProtocol);
  v0[23] = AssociatedConformanceWitness;
  uint64_t v7 = (void *)swift_task_alloc(_sScI4next9isolation7ElementQzSgScA_pSgYi_tYa7FailureQzYKFTjTu[1]);
  v0[24] = v7;
  *uint64_t v7 = v0;
  v7[1] = sub_100053868;
  return _sScI4next9isolation7ElementQzSgScA_pSgYi_tYa7FailureQzYKFTj( v0[17],  0LL,  0LL,  v0[15],  v0[20],  AssociatedConformanceWitness);
}

uint64_t sub_100053868()
{
  uint64_t v2 = *v1;
  swift_task_dealloc(*(void *)(*v1 + 192));
  if (v0)
  {
    swift_bridgeObjectRelease(*(void *)(v2 + 16), v3);
    uint64_t v4 = sub_100053ABC;
  }

  else
  {
    uint64_t v4 = sub_1000538D0;
  }

  return swift_task_switch(v4, 0LL, 0LL);
}

uint64_t sub_1000538D0()
{
  uint64_t v1 = *(void *)(v0 + 128);
  uint64_t v2 = *(void *)(v0 + 136);
  if ((*(unsigned int (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v1 - 8) + 48LL))(v2, 1LL, v1) == 1)
  {
    uint64_t v3 = *(void *)(v0 + 176);
    uint64_t v4 = *(void *)(v0 + 152);
    uint64_t v6 = *(void *)(v0 + 112);
    uint64_t v5 = *(void *)(v0 + 120);
    uint64_t v7 = *(void *)(v0 + 88);
    uint64_t v8 = *(void *)(v0 + 64);
    (*(void (**)(uint64_t, void))(*(void *)(v0 + 168) + 8LL))(v3, *(void *)(v0 + 160));
    uint64_t v9 = *(void *)(v0 + 16);
    swift_task_dealloc(v3);
    swift_task_dealloc(v4);
    swift_task_dealloc(v2);
    swift_task_dealloc(v5);
    swift_task_dealloc(v6);
    swift_task_dealloc(v7);
    swift_task_dealloc(v8);
    return (*(uint64_t (**)(uint64_t))(v0 + 8))(v9);
  }

  else
  {
    uint64_t v11 = *(void *)(v0 + 56);
    char v12 = swift_dynamicCast(*(void *)(v0 + 88), v2, v1, *(void *)(v0 + 32), 6LL);
    uint64_t v13 = *(void (**)(void, uint64_t, uint64_t, uint64_t))(v11 + 56);
    uint64_t v14 = *(void *)(v0 + 88);
    if ((v12 & 1) != 0)
    {
      uint64_t v16 = *(void *)(v0 + 56);
      uint64_t v15 = *(void *)(v0 + 64);
      uint64_t v17 = *(void *)(v0 + 32);
      v13(*(void *)(v0 + 88), 0LL, 1LL, v17);
      (*(void (**)(uint64_t, uint64_t, uint64_t))(v16 + 32))(v15, v14, v17);
      uint64_t v18 = type metadata accessor for Array(0LL, v17);
      Array.append(_:)(v15, v18);
    }

    else
    {
      uint64_t v19 = *(void *)(v0 + 72);
      uint64_t v20 = *(void *)(v0 + 80);
      v13(*(void *)(v0 + 88), 1LL, 1LL, *(void *)(v0 + 32));
      (*(void (**)(uint64_t, uint64_t))(v20 + 8))(v14, v19);
    }

    uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( *(void *)(v0 + 48),  *(void *)(v0 + 40),  *(void *)(v0 + 160),  &protocol requirements base descriptor for AsyncSequence,  &associated conformance descriptor for AsyncSequence.AsyncSequence.AsyncIterator: AsyncIteratorProtocol);
    *(void *)(v0 + 184) = AssociatedConformanceWitness;
    __n128 v22 = (void *)swift_task_alloc(_sScI4next9isolation7ElementQzSgScA_pSgYi_tYa7FailureQzYKFTjTu[1]);
    *(void *)(v0 + 192) = v22;
    *__n128 v22 = v0;
    v22[1] = sub_100053868;
    return _sScI4next9isolation7ElementQzSgScA_pSgYi_tYa7FailureQzYKFTj( *(void *)(v0 + 136),  0LL,  0LL,  *(void *)(v0 + 120),  *(void *)(v0 + 160),  AssociatedConformanceWitness);
  }

uint64_t sub_100053ABC()
{
  uint64_t v1 = *(void *)(v0 + 184);
  uint64_t v2 = *(void *)(v0 + 160);
  uint64_t v3 = *(void *)(v0 + 112);
  uint64_t v4 = *(void *)(v0 + 96);
  uint64_t v5 = *(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v0 + 104) + 32LL);
  v5(v3, *(void *)(v0 + 120), v4);
  uint64_t AssociatedConformanceWitness = swift_getAssociatedConformanceWitness( v1,  v2,  v4,  &protocol requirements base descriptor for AsyncIteratorProtocol,  &associated conformance descriptor for AsyncIteratorProtocol.AsyncIteratorProtocol.Failure: Error);
  uint64_t v7 = _getErrorEmbeddedNSError<A>(_:)(v3, v4, AssociatedConformanceWitness);
  uint64_t v8 = *(void *)(v0 + 112);
  if (v7)
  {
    (*(void (**)(void, void))(*(void *)(v0 + 104) + 8LL))(*(void *)(v0 + 112), *(void *)(v0 + 96));
  }

  else
  {
    uint64_t v9 = *(void *)(v0 + 96);
    swift_allocError(v9, AssociatedConformanceWitness, 0LL, 0LL);
    v5(v10, v8, v9);
  }

  uint64_t v11 = *(void *)(v0 + 176);
  uint64_t v12 = *(void *)(v0 + 152);
  uint64_t v13 = *(void *)(v0 + 136);
  uint64_t v15 = *(void *)(v0 + 112);
  uint64_t v14 = *(void *)(v0 + 120);
  uint64_t v16 = *(void *)(v0 + 88);
  uint64_t v17 = *(void *)(v0 + 64);
  (*(void (**)(uint64_t, void))(*(void *)(v0 + 168) + 8LL))(v11, *(void *)(v0 + 160));
  swift_task_dealloc(v11);
  swift_task_dealloc(v12);
  swift_task_dealloc(v13);
  swift_task_dealloc(v14);
  swift_task_dealloc(v15);
  swift_task_dealloc(v16);
  swift_task_dealloc(v17);
  return (*(uint64_t (**)(void))(v0 + 8))();
}

void RDSAPISwiftSpeechAnalyzer.init()()
{
}

uint64_t sub_100053C50@<X0>(uint64_t a1@<X8>)
{
  return sub_100053C78( &OBJC_IVAR____TtC50com_apple_SpeechRecognitionCore_speechrecognitiond11AudioStream_audioStream,  &qword_1000DD6C0,  a1);
}

uint64_t sub_100053C64@<X0>(uint64_t a1@<X8>)
{
  return sub_100053C78( &OBJC_IVAR____TtC50com_apple_SpeechRecognitionCore_speechrecognitiond11AudioStream_audioStreamGenerator,  &qword_1000DD6C8,  a1);
}

uint64_t sub_100053C78@<X0>(void *a1@<X0>, uint64_t *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v5 = v3 + *a1;
  uint64_t v6 = sub_10004B5C0(a2);
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v6 - 8) + 16LL))(a3, v5, v6);
}

void *sub_100053CB8()
{
  uint64_t v1 = (void **)(v0 + OBJC_IVAR____TtC50com_apple_SpeechRecognitionCore_speechrecognitiond11AudioStream_avFile);
  swift_beginAccess( v0 + OBJC_IVAR____TtC50com_apple_SpeechRecognitionCore_speechrecognitiond11AudioStream_avFile,  v5,  0LL,  0LL);
  uint64_t v2 = *v1;
  id v3 = v2;
  return v2;
}

void sub_100053D04(void *a1)
{
  id v3 = (void **)(v1 + OBJC_IVAR____TtC50com_apple_SpeechRecognitionCore_speechrecognitiond11AudioStream_avFile);
  swift_beginAccess(v3, v5, 1LL, 0LL);
  uint64_t v4 = *v3;
  *id v3 = a1;
}

void *sub_100053D54(uint64_t a1)
{
  return &j_j__swift_endAccess;
}

void *sub_100053D98()
{
  uint64_t v1 = (void **)(v0 + OBJC_IVAR____TtC50com_apple_SpeechRecognitionCore_speechrecognitiond11AudioStream_avConverter);
  swift_beginAccess( v0 + OBJC_IVAR____TtC50com_apple_SpeechRecognitionCore_speechrecognitiond11AudioStream_avConverter,  v5,  0LL,  0LL);
  uint64_t v2 = *v1;
  id v3 = v2;
  return v2;
}

void sub_100053DE4(void *a1)
{
  id v3 = (void **)(v1 + OBJC_IVAR____TtC50com_apple_SpeechRecognitionCore_speechrecognitiond11AudioStream_avConverter);
  swift_beginAccess(v3, v5, 1LL, 0LL);
  uint64_t v4 = *v3;
  *id v3 = a1;
}

void *sub_100053E34(uint64_t a1)
{
  return &j_j__swift_endAccess;
}

uint64_t sub_100053E78()
{
  uint64_t v1 = sub_10004B5C0(&qword_1000DD770);
  uint64_t v2 = *(void *)(v1 - 8);
  __chkstk_darwin(v1);
  uint64_t v4 = (char *)&v14 - ((v3 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v15 = sub_10004B5C0(&qword_1000DD6C8);
  uint64_t v5 = *(void *)(v15 - 8);
  __chkstk_darwin(v15);
  uint64_t v7 = (char *)&v14 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v8 = sub_10004B5C0(&qword_1000DD6C0);
  uint64_t v9 = *(void *)(v8 - 8);
  __chkstk_darwin(v8);
  uint64_t v11 = (char *)&v14 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  *(void *)(v0 + OBJC_IVAR____TtC50com_apple_SpeechRecognitionCore_speechrecognitiond11AudioStream_avFile) = 0LL;
  *(void *)(v0 + OBJC_IVAR____TtC50com_apple_SpeechRecognitionCore_speechrecognitiond11AudioStream_avConverter) = 0LL;
  uint64_t v12 = type metadata accessor for AnalyzerInput(0LL);
  (*(void (**)(char *, void, uint64_t))(v2 + 104))( v4,  enum case for AsyncStream.Continuation.BufferingPolicy.unbounded<A>(_:),  v1);
  static AsyncStream.makeStream(of:bufferingPolicy:)(v11, v7, v12, v4, v12);
  (*(void (**)(char *, uint64_t))(v2 + 8))(v4, v1);
  (*(void (**)(uint64_t, char *, uint64_t))(v9 + 32))( v0 + OBJC_IVAR____TtC50com_apple_SpeechRecognitionCore_speechrecognitiond11AudioStream_audioStream,  v11,  v8);
  (*(void (**)(uint64_t, char *, uint64_t))(v5 + 32))( v0 + OBJC_IVAR____TtC50com_apple_SpeechRecognitionCore_speechrecognitiond11AudioStream_audioStreamGenerator,  v7,  v15);
  return v0;
}

void sub_100054010(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = v2;
  uint64_t v7 = type metadata accessor for URL(0LL);
  __chkstk_darwin(v7);
  uint64_t v9 = (char *)&v18 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  (*(void (**)(char *, uint64_t))(v10 + 16))(v9, a1);
  id v11 = objc_allocWithZone(&OBJC_CLASS___AVAudioFile);
  id v12 = sub_1000548D0((uint64_t)v9);
  if (!v3)
  {
    uint64_t v13 = (*(uint64_t (**)(id))(*(void *)v4 + 120LL))(v12);
    uint64_t v14 = (void *)(*(uint64_t (**)(uint64_t))(*(void *)v4 + 112LL))(v13);
    if (v14)
    {
      uint64_t v15 = v14;
      id v16 = [v14 processingFormat];

      id v17 = [objc_allocWithZone(AVAudioConverter) initFromFormat:v16 toFormat:a2];
      if (v17)
      {
        (*(void (**)(id))(*(void *)v4 + 144LL))(v17);
        return;
      }
    }

    else
    {
      __break(1u);
    }

    __break(1u);
  }

uint64_t sub_100054144()
{
  return (*(uint64_t (**)(uint64_t (*)(void *), uint64_t, void (*)(), uint64_t))(*(void *)v0 + 184LL))( sub_100057ED8,  v0,  sub_100058974,  v0);
}

uint64_t sub_100054178(void *a1)
{
  uint64_t v2 = type metadata accessor for AnalyzerInput(0LL);
  __chkstk_darwin(v2);
  uint64_t v4 = (char *)&v11 - ((v3 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v5 = sub_10004B5C0(&qword_1000DD758);
  uint64_t v6 = *(void *)(v5 - 8);
  __chkstk_darwin(v5);
  uint64_t v8 = (char *)&v11 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  AnalyzerInput.init(buffer:bufferStartTime:)(a1, 0LL, 0LL, 0LL, 1LL);
  uint64_t v9 = sub_10004B5C0(&qword_1000DD6C8);
  AsyncStream.Continuation.yield(_:)(v4, v9);
  return (*(uint64_t (**)(char *, uint64_t))(v6 + 8))(v8, v5);
}

void sub_100054278(void (*a1)(id, void *), uint64_t a2, void (*a3)(void))
{
  uint64_t v5 = *(uint64_t (**)(void))(*(void *)v3 + 112LL);
  uint64_t v6 = (void *)v5();
  if (!v6) {
    goto LABEL_39;
  }
  uint64_t v7 = v6;
  uint64_t v8 = &selRef_tokenName;
  id v9 = [v6 processingFormat];

  [v9 sampleRate];
  double v11 = v10;

  double v12 = v11 * 0.5;
  if ((~COERCE__INT64(v11 * 0.5) & 0x7FF0000000000000LL) == 0)
  {
    __break(1u);
    goto LABEL_27;
  }

  if (v12 <= -1.0)
  {
LABEL_27:
    __break(1u);
LABEL_28:
    __break(1u);
LABEL_29:
    __break(1u);
LABEL_30:
    __break(1u);
LABEL_31:
    __break(1u);
LABEL_32:
    __break(1u);
LABEL_33:
    __break(1u);
LABEL_34:
    __break(1u);
LABEL_35:
    __break(1u);
LABEL_36:
    __break(1u);
LABEL_37:
    __break(1u);
LABEL_38:
    __break(1u);
LABEL_39:
    __break(1u);
  }

  if (v12 >= 4294967300.0) {
    goto LABEL_28;
  }
  uint64_t v58 = a3;
  uint64_t v13 = 0LL;
  uint64_t v14 = v12;
  unsigned int v59 = v12;
  do
  {
    uint64_t v15 = (void *)v5();
    if (!v15) {
      goto LABEL_29;
    }
    id v16 = v15;
    id v17 = [v15 length];

    uint64_t v18 = (void *)v5();
    if (!v18) {
      goto LABEL_30;
    }
    uint64_t v19 = v18;
    id v20 = [v18 v8[105]];

    [v20 sampleRate];
    double v22 = v21;

    id v23 = [objc_allocWithZone(AVAudioTime) initWithSampleTime:v13 atRate:v22];
    uint64_t v24 = (void *)v5();
    if (!v24) {
      goto LABEL_31;
    }
    uint64_t v25 = v24;
    uint64_t v62 = v23;
    id v26 = [v24 v8[105]];

    id v27 = [objc_allocWithZone(AVAudioPCMBuffer) initWithPCMFormat:v26 frameCapacity:v14];
    if (!v27) {
      goto LABEL_32;
    }
    uint64_t v28 = *(uint64_t (**)(void))(*(void *)v61 + 136LL);
    uint64_t v29 = (void *)v28();
    if (!v29) {
      goto LABEL_33;
    }
    uint64_t v30 = v29;
    id v31 = [v29 outputFormat];

    id v32 = [objc_allocWithZone(AVAudioPCMBuffer) initWithPCMFormat:v31 frameCapacity:v14];
    if (!v32) {
      goto LABEL_34;
    }
    uint64_t v33 = (void *)v5();
    if (!v33) {
      goto LABEL_35;
    }
    uint64_t v34 = v33;
    aBlock[0] = 0LL;
    unsigned int v35 = [v33 readIntoBuffer:v27 error:aBlock];

    id v36 = aBlock[0];
    if (!v35)
    {
      id v55 = aBlock[0];
      _convertNSErrorToError(_:)(v36);

      swift_willThrow();
      uint64_t v56 = v32;
      id v51 = v62;
      id v32 = v27;
LABEL_25:

      return;
    }

    uint64_t v37 = v13;
    uint64_t v38 = (void *)((uint64_t (*)(id))v5)(aBlock[0]);
    if (!v38) {
      goto LABEL_36;
    }
    uint64_t v39 = v38;
    id v40 = [v38 framePosition];

    uint64_t v41 = v5;
    uint64_t v42 = (void *)v5();
    if (!v42) {
      goto LABEL_37;
    }
    uint64_t v43 = v42;
    id v44 = [v42 length];

    uint64_t v45 = swift_allocObject(&unk_1000D0268, 17LL, 7LL);
    *(_BYTE *)(v45 + 16) = 0;
    uint64_t v46 = v28();
    if (!v46) {
      goto LABEL_38;
    }
    uint64_t v47 = (void *)v46;
    uint64_t v48 = swift_allocObject(&unk_1000D0290, 40LL, 7LL);
    *(void *)(v48 + 16) = v45;
    *(_BYTE *)(v48 + ++*(void *)(result + 24) = (uint64_t)v40 >= (uint64_t)v44;
    *(void *)(v48 + 32) = v27;
    aBlock[4] = sub_100057FEC;
    uint64_t v64 = v48;
    aBlock[0] = _NSConcreteStackBlock;
    aBlock[1] = (id)1107296256;
    aBlock[2] = sub_100054748;
    aBlock[3] = &unk_1000D02A8;
    uint64_t v49 = _Block_copy(aBlock);
    uint64_t v50 = v64;
    swift_retain(v45);
    id v51 = v27;
    swift_release(v50);
    aBlock[0] = 0LL;
    [v47 convertToBuffer:v32 error:aBlock withInputFromBlock:v49];
    _Block_release(v49);

    id v52 = aBlock[0];
    if (v52)
    {
      id v57 = v52;
      swift_willThrow();

      swift_release(v45);
      [v51 frameLength];
      uint64_t v56 = v62;
      goto LABEL_25;
    }

    a1(v32, v62);
    swift_release(v45);
    unsigned int v53 = [v51 frameLength];

    BOOL v54 = __OFADD__(v37, v53);
    uint64_t v13 = v37 + v53;
    uint64_t v5 = v41;
    uint64_t v8 = &selRef_tokenName;
    uint64_t v14 = v59;
  }

  while (!v54);
  __break(1u);
LABEL_22:
  v58();
}

id sub_100054748(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = *(uint64_t (**)(uint64_t, uint64_t))(a1 + 32);
  uint64_t v5 = *(void *)(a1 + 40);
  swift_retain(v5);
  uint64_t v7 = (void *)v6(a2, a3);
  swift_release(v5);
  return v7;
}

uint64_t sub_10005479C()
{
  uint64_t v1 = v0 + OBJC_IVAR____TtC50com_apple_SpeechRecognitionCore_speechrecognitiond11AudioStream_audioStream;
  uint64_t v2 = sub_10004B5C0(&qword_1000DD6C0);
  (*(void (**)(uint64_t, uint64_t))(*(void *)(v2 - 8) + 8LL))(v1, v2);
  uint64_t v3 = v0 + OBJC_IVAR____TtC50com_apple_SpeechRecognitionCore_speechrecognitiond11AudioStream_audioStreamGenerator;
  uint64_t v4 = sub_10004B5C0(&qword_1000DD6C8);
  (*(void (**)(uint64_t, uint64_t))(*(void *)(v4 - 8) + 8LL))(v3, v4);

  return v0;
}

uint64_t sub_100054830()
{
  uint64_t v1 = v0 + OBJC_IVAR____TtC50com_apple_SpeechRecognitionCore_speechrecognitiond11AudioStream_audioStream;
  uint64_t v2 = sub_10004B5C0(&qword_1000DD6C0);
  (*(void (**)(uint64_t, uint64_t))(*(void *)(v2 - 8) + 8LL))(v1, v2);
  uint64_t v3 = v0 + OBJC_IVAR____TtC50com_apple_SpeechRecognitionCore_speechrecognitiond11AudioStream_audioStreamGenerator;
  uint64_t v4 = sub_10004B5C0(&qword_1000DD6C8);
  (*(void (**)(uint64_t, uint64_t))(*(void *)(v4 - 8) + 8LL))(v3, v4);

  return swift_deallocClassInstance( v0,  *(unsigned int *)(*(void *)v0 + 48LL),  *(unsigned __int16 *)(*(void *)v0 + 52LL));
}

id sub_1000548D0(uint64_t a1)
{
  uint64_t v2 = v1;
  URL._bridgeToObjectiveC()(__stack_chk_guard);
  uint64_t v5 = v4;
  id v14 = 0LL;
  id v6 = [v2 initForReading:v4 error:&v14];

  id v7 = v14;
  if (v6)
  {
    uint64_t v8 = type metadata accessor for URL(0LL);
    id v9 = *(void (**)(uint64_t, uint64_t))(*(void *)(v8 - 8) + 8LL);
    id v10 = v7;
    v9(a1, v8);
  }

  else
  {
    id v11 = v14;
    _convertNSErrorToError(_:)(v7);

    swift_willThrow();
    uint64_t v12 = type metadata accessor for URL(0LL);
    (*(void (**)(uint64_t, uint64_t))(*(void *)(v12 - 8) + 8LL))(a1, v12);
  }

  return v6;
}

uint64_t sub_1000549D8(uint64_t a1, uint64_t a2, int *a3)
{
  id v6 = (uint64_t (*)(void))((char *)a3 + *a3);
  uint64_t v4 = (void *)swift_task_alloc(a3[1]);
  *(void *)(v3 + 16) = v4;
  *uint64_t v4 = v3;
  v4[1] = sub_100058960;
  return v6();
}

uint64_t sub_100054A2C(uint64_t a1, uint64_t a2, uint64_t a3, int *a4)
{
  id v7 = (uint64_t (*)(void))((char *)a4 + *a4);
  uint64_t v5 = (void *)swift_task_alloc(a4[1]);
  *(void *)(v4 + 16) = v5;
  void *v5 = v4;
  v5[1] = sub_100058960;
  return v7();
}

uint64_t sub_100054A80(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = type metadata accessor for TaskPriority(0LL);
  uint64_t v7 = *(void *)(v6 - 8);
  if ((*(unsigned int (**)(uint64_t, uint64_t, uint64_t))(v7 + 48))(a1, 1LL, v6) == 1)
  {
    sub_10004BA28(a1, &qword_1000DD628);
    uint64_t v8 = 7168LL;
    uint64_t v9 = *(void *)(a3 + 16);
    if (v9)
    {
LABEL_3:
      uint64_t v10 = *(void *)(a3 + 24);
      uint64_t ObjectType = swift_getObjectType(v9);
      swift_unknownObjectRetain(v9);
      uint64_t v12 = dispatch thunk of Actor.unownedExecutor.getter(ObjectType, v10);
      uint64_t v14 = v13;
      swift_unknownObjectRelease(v9);
      goto LABEL_6;
    }
  }

  else
  {
    unsigned __int8 v15 = TaskPriority.rawValue.getter();
    (*(void (**)(uint64_t, uint64_t))(v7 + 8))(a1, v6);
    uint64_t v8 = v15 | 0x1C00LL;
    uint64_t v9 = *(void *)(a3 + 16);
    if (v9) {
      goto LABEL_3;
    }
  }

  uint64_t v12 = 0LL;
  uint64_t v14 = 0LL;
LABEL_6:
  uint64_t v16 = swift_allocObject(&unk_1000D03F8, 32LL, 7LL);
  *(void *)(v16 + 16) = a2;
  *(void *)(v16 + ++*(void *)(result + 24) = a3;
  if (v14 | v12)
  {
    v19[0] = 0LL;
    v19[1] = 0LL;
    id v17 = v19;
    v19[2] = v12;
    v19[3] = v14;
  }

  else
  {
    id v17 = 0LL;
  }

  return swift_task_create(v8, v17, (char *)&type metadata for () + 8, &unk_1000DD980, v16);
}

uint64_t sub_100054BCC(uint64_t a1, int *a2)
{
  uint64_t v6 = (uint64_t (*)(uint64_t))((char *)a2 + *a2);
  uint64_t v4 = (void *)swift_task_alloc(a2[1]);
  *(void *)(v2 + 16) = v4;
  *uint64_t v4 = v2;
  v4[1] = sub_100058964;
  return v6(a1);
}

uint64_t sub_100054C30(uint64_t a1, char *a2)
{
  uint64_t v3 = v2;
  uint64_t v6 = type metadata accessor for Transcriber.TranscriptionOption(0LL);
  uint64_t v7 = *(void *)(v6 - 8);
  __chkstk_darwin(v6);
  uint64_t v9 = (char *)&v34 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v10 = *v3;
  uint64_t v11 = *(void *)(*v3 + 40LL);
  uint64_t v13 = sub_100058894( &qword_1000DD9F0,  v12,  (uint64_t)&protocol conformance descriptor for Transcriber.TranscriptionOption);
  swift_bridgeObjectRetain(v10);
  uint64_t v38 = a2;
  uint64_t v14 = dispatch thunk of Hashable._rawHashValue(seed:)(v11, v6, v13);
  uint64_t v16 = -1LL << *(_BYTE *)(v10 + 32);
  unint64_t v17 = v14 & ~v16;
  uint64_t v18 = v10;
  uint64_t v19 = v10 + 56;
  if (((*(void *)(v10 + 56 + ((v17 >> 3) & 0xFFFFFFFFFFFFF8LL)) >> v17) & 1) != 0)
  {
    uint64_t v34 = v3;
    uint64_t v35 = a1;
    uint64_t v36 = ~v16;
    uint64_t v37 = v7;
    uint64_t v20 = *(void *)(v7 + 72);
    double v21 = *(void (**)(void, void, void))(v7 + 16);
    while (1)
    {
      uint64_t v22 = v18;
      id v23 = v21;
      v21(v9, *(void *)(v18 + 48) + v20 * v17, v6);
      uint64_t v24 = sub_100058894( &qword_1000DD9F8,  (uint64_t (*)(uint64_t))&type metadata accessor for Transcriber.TranscriptionOption,  (uint64_t)&protocol conformance descriptor for Transcriber.TranscriptionOption);
      char v25 = dispatch thunk of static Equatable.== infix(_:_:)(v9, v38, v6, v24);
      id v26 = *(void (**)(char *, uint64_t))(v37 + 8);
      v26(v9, v6);
      if ((v25 & 1) != 0) {
        break;
      }
      unint64_t v17 = (v17 + 1) & v36;
      uint64_t v18 = v22;
      double v21 = v23;
      if (((*(void *)(v19 + ((v17 >> 3) & 0xFFFFFFFFFFFFF8LL)) >> v17) & 1) == 0)
      {
        swift_bridgeObjectRelease(v22, v27);
        uint64_t v3 = v34;
        a1 = v35;
        uint64_t v28 = v37;
        goto LABEL_7;
      }
    }

    swift_bridgeObjectRelease(v22, v27);
    v26(v38, v6);
    v23(v35, *(void *)(*v34 + 48LL) + v20 * v17, v6);
    return 0LL;
  }

  else
  {
    swift_bridgeObjectRelease(v10, v15);
    double v21 = *(void (**)(void, void, void))(v7 + 16);
    uint64_t v28 = v7;
LABEL_7:
    char isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native(*v3);
    uint64_t v30 = v38;
    v21(v9, v38, v6);
    uint64_t v39 = *v3;
    *uint64_t v3 = 0x8000000000000000LL;
    sub_1000551F8((uint64_t)v9, v17, isUniquelyReferenced_nonNull_native);
    uint64_t v31 = *v3;
    *uint64_t v3 = v39;
    swift_bridgeObjectRelease(v31, v32);
    (*(void (**)(uint64_t, char *, uint64_t))(v28 + 32))(a1, v30, v6);
    return 1LL;
  }

uint64_t sub_100054E8C(uint64_t a1)
{
  uint64_t v2 = v1;
  uint64_t v4 = type metadata accessor for Transcriber.TranscriptionOption(0LL);
  uint64_t v40 = *(void *)(v4 - 8);
  __chkstk_darwin(v4);
  uint64_t v6 = (char *)&v37 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v7 = *v2;
  if (*(void *)(*v2 + 24) > a1) {
    a1 = *(void *)(*v2 + 24);
  }
  sub_10004B5C0(&qword_1000DD9E8);
  uint64_t v8 = static _SetStorage.resize(original:capacity:move:)(v7, a1, 1LL);
  uint64_t v9 = v8;
  if (!*(void *)(v7 + 16)) {
    goto LABEL_39;
  }
  uint64_t v10 = 1LL << *(_BYTE *)(v7 + 32);
  uint64_t v11 = *(void *)(v7 + 56);
  uint64_t v39 = (void *)(v7 + 56);
  if (v10 < 64) {
    uint64_t v12 = ~(-1LL << v10);
  }
  else {
    uint64_t v12 = -1LL;
  }
  unint64_t v13 = v12 & v11;
  uint64_t v37 = v2;
  int64_t v38 = (unint64_t)(v10 + 63) >> 6;
  uint64_t v14 = v8 + 56;
  uint64_t result = swift_retain(v7);
  int64_t v16 = 0LL;
  while (1)
  {
    if (v13)
    {
      unint64_t v18 = __clz(__rbit64(v13));
      v13 &= v13 - 1;
      unint64_t v19 = v18 | (v16 << 6);
      goto LABEL_26;
    }

    int64_t v20 = v16 + 1;
    if (__OFADD__(v16, 1LL))
    {
LABEL_40:
      __break(1u);
LABEL_41:
      __break(1u);
      return result;
    }

    if (v20 >= v38) {
      goto LABEL_35;
    }
    unint64_t v21 = v39[v20];
    ++v16;
    if (!v21)
    {
      int64_t v16 = v20 + 1;
      if (v20 + 1 >= v38) {
        goto LABEL_35;
      }
      unint64_t v21 = v39[v16];
      if (!v21)
      {
        int64_t v16 = v20 + 2;
        if (v20 + 2 >= v38) {
          goto LABEL_35;
        }
        unint64_t v21 = v39[v16];
        if (!v21) {
          break;
        }
      }
    }

LABEL_25:
    unint64_t v13 = (v21 - 1) & v21;
    unint64_t v19 = __clz(__rbit64(v21)) + (v16 << 6);
LABEL_26:
    uint64_t v23 = v7;
    uint64_t v24 = *(void *)(v7 + 48);
    uint64_t v25 = *(void *)(v40 + 72);
    id v26 = *(void (**)(char *, unint64_t, uint64_t))(v40 + 32);
    v26(v6, v24 + v25 * v19, v4);
    uint64_t v27 = *(void *)(v9 + 40);
    uint64_t v28 = sub_100058894( &qword_1000DD9F0,  (uint64_t (*)(uint64_t))&type metadata accessor for Transcriber.TranscriptionOption,  (uint64_t)&protocol conformance descriptor for Transcriber.TranscriptionOption);
    uint64_t result = dispatch thunk of Hashable._rawHashValue(seed:)(v27, v4, v28);
    uint64_t v29 = -1LL << *(_BYTE *)(v9 + 32);
    unint64_t v30 = result & ~v29;
    unint64_t v31 = v30 >> 6;
    if (((-1LL << v30) & ~*(void *)(v14 + 8 * (v30 >> 6))) != 0)
    {
      unint64_t v17 = __clz(__rbit64((-1LL << v30) & ~*(void *)(v14 + 8 * (v30 >> 6)))) | v30 & 0x7FFFFFFFFFFFFFC0LL;
    }

    else
    {
      char v32 = 0;
      unint64_t v33 = (unint64_t)(63 - v29) >> 6;
      do
      {
        if (++v31 == v33 && (v32 & 1) != 0)
        {
          __break(1u);
          goto LABEL_40;
        }

        BOOL v34 = v31 == v33;
        if (v31 == v33) {
          unint64_t v31 = 0LL;
        }
        v32 |= v34;
        uint64_t v35 = *(void *)(v14 + 8 * v31);
      }

      while (v35 == -1);
      unint64_t v17 = __clz(__rbit64(~v35)) + (v31 << 6);
    }

    *(void *)(v14 + ((v17 >> 3) & 0x1FFFFFFFFFFFFFF8LL)) |= 1LL << v17;
    uint64_t result = ((uint64_t (*)(unint64_t, char *, uint64_t))v26)(*(void *)(v9 + 48) + v17 * v25, v6, v4);
    ++*(void *)(v9 + 16);
    uint64_t v7 = v23;
  }

  int64_t v22 = v20 + 3;
  if (v22 < v38)
  {
    unint64_t v21 = v39[v22];
    if (!v21)
    {
      while (1)
      {
        int64_t v16 = v22 + 1;
        if (__OFADD__(v22, 1LL)) {
          goto LABEL_41;
        }
        if (v16 >= v38) {
          goto LABEL_35;
        }
        unint64_t v21 = v39[v16];
        ++v22;
        if (v21) {
          goto LABEL_25;
        }
      }
    }

    int64_t v16 = v22;
    goto LABEL_25;
  }

    uint64_t v14 = (v22 - 1) & v22;
    int64_t v20 = __clz(__rbit64(v22)) + (v17 << 6);
LABEL_26:
    uint64_t v24 = *(void *)(v5 + 72);
    (*(void (**)(char *, unint64_t, uint64_t))(v5 + 16))(v7, *(void *)(v8 + 48) + v24 * v20, v4);
    uint64_t v25 = *(void *)(v10 + 40);
    id v26 = sub_100058894( &qword_1000DD9F0,  (uint64_t (*)(uint64_t))&type metadata accessor for Transcriber.TranscriptionOption,  (uint64_t)&protocol conformance descriptor for Transcriber.TranscriptionOption);
    uint64_t result = dispatch thunk of Hashable._rawHashValue(seed:)(v25, v4, v26);
    uint64_t v27 = -1LL << *(_BYTE *)(v10 + 32);
    uint64_t v28 = result & ~v27;
    uint64_t v29 = v28 >> 6;
    if (((-1LL << v28) & ~*(void *)(v15 + 8 * (v28 >> 6))) != 0)
    {
      unint64_t v18 = __clz(__rbit64((-1LL << v28) & ~*(void *)(v15 + 8 * (v28 >> 6)))) | v28 & 0x7FFFFFFFFFFFFFC0LL;
    }

    else
    {
      unint64_t v30 = 0;
      unint64_t v31 = (unint64_t)(63 - v27) >> 6;
      do
      {
        if (++v29 == v31 && (v30 & 1) != 0)
        {
          __break(1u);
          goto LABEL_38;
        }

        char v32 = v29 == v31;
        if (v29 == v31) {
          uint64_t v29 = 0LL;
        }
        v30 |= v32;
        unint64_t v33 = *(void *)(v15 + 8 * v29);
      }

      while (v33 == -1);
      unint64_t v18 = __clz(__rbit64(~v33)) + (v29 << 6);
    }

    *(void *)(v15 + ((v18 >> 3) & 0x1FFFFFFFFFFFFFF8LL)) |= 1LL << v18;
    uint64_t result = (*(uint64_t (**)(unint64_t, char *, uint64_t))(v5 + 32))( *(void *)(v10 + 48) + v18 * v24,  v7,  v4);
    ++*(void *)(v10 + 16);
  }

  uint64_t v23 = v21 + 3;
  if (v23 >= v37)
  {
LABEL_35:
    uint64_t result = swift_release_n(v8, 2LL);
    uint64_t v2 = v35;
    goto LABEL_37;
  }

  int64_t v22 = *(void *)(v36 + 8 * v23);
  if (v22)
  {
    unint64_t v17 = v23;
    goto LABEL_25;
  }

  while (1)
  {
    unint64_t v17 = v23 + 1;
    if (__OFADD__(v23, 1LL)) {
      break;
    }
    if (v17 >= v37) {
      goto LABEL_35;
    }
    int64_t v22 = *(void *)(v36 + 8 * v17);
    ++v23;
    if (v22) {
      goto LABEL_25;
    }
  }

    uint64_t v14 = (v21 - 1) & v21;
    int64_t v16 = __clz(__rbit64(v21)) + (v11 << 6);
LABEL_12:
    unint64_t v17 = *(void *)(v2 + 72) * v16;
    (*(void (**)(char *, unint64_t, uint64_t))(v2 + 16))(v4, *(void *)(v5 + 48) + v17, v1);
    unint64_t v18 = 8 * v16;
    unint64_t v19 = *(void *)(*(void *)(v5 + 56) + 8 * v16);
    (*(void (**)(unint64_t, char *, uint64_t))(v2 + 32))(*(void *)(v7 + 48) + v17, v4, v1);
    *(void *)(*(void *)(v7 + 56) + v1_Block_object_dispose(va, 8) = v19;
    uint64_t result = (void *)swift_bridgeObjectRetain(v19);
  }

  int64_t v22 = v20 + 2;
  if (v22 >= v26) {
    goto LABEL_26;
  }
  unint64_t v21 = *(void *)(v25 + 8 * v22);
  if (v21)
  {
    uint64_t v11 = v22;
    goto LABEL_25;
  }

  while (1)
  {
    uint64_t v11 = v22 + 1;
    if (__OFADD__(v22, 1LL)) {
      break;
    }
    if (v11 >= v26) {
      goto LABEL_26;
    }
    unint64_t v21 = *(void *)(v25 + 8 * v11);
    ++v22;
    if (v21) {
      goto LABEL_25;
    }
  }

    int64_t v20 = v48;
    goto LABEL_26;
  }

  if (v46) {
    (*(void (**)(void))(*(void *)v46 + 8LL))();
  }
LABEL_95:
  a3 = v42;
  if ((*(unsigned int (**)(uint64_t))(*(void *)v8 + 16LL))(v8) != -1
    && (*(unsigned int (**)(uint64_t))(*(void *)v8 + 16LL))(v8))
  {
    id v57 = v57 & 0xFFFFCFFFFFFFFFFFLL | 0x200000000000LL;
  }

  if (v17)
  {
    uint64_t v39 = (void *)sub_10001A760((uint64_t)v17);
    operator delete(v39);
  }

  if (v18)
  {
    uint64_t v40 = (void *)sub_10001A760((uint64_t)v18);
    operator delete(v40);
  }

    int64_t v20 = v48;
    goto LABEL_26;
  }

  if (v46) {
    (*(void (**)(void))(*(void *)v46 + 8LL))();
  }
LABEL_95:
  a3 = v42;
  if ((*(unsigned int (**)(uint64_t))(*(void *)v8 + 16LL))(v8) != -1
    && (*(unsigned int (**)(uint64_t))(*(void *)v8 + 16LL))(v8))
  {
    id v57 = v57 & 0xFFFFCFFFFFFFFFFFLL | 0x200000000000LL;
  }

  if (v17)
  {
    uint64_t v39 = (void *)sub_10001A760((uint64_t)v17);
    operator delete(v39);
  }

  if (v18)
  {
    uint64_t v40 = (void *)sub_10001A760((uint64_t)v18);
    operator delete(v40);
  }

uint64_t sub_1000551F8(uint64_t a1, unint64_t a2, char a3)
{
  uint64_t v30 = a1;
  uint64_t v6 = type metadata accessor for Transcriber.TranscriptionOption(0LL);
  uint64_t v7 = *(void *)(v6 - 8);
  __chkstk_darwin(v6);
  uint64_t v9 = (char *)&v29 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  unint64_t v10 = *(void *)(*v3 + 16);
  unint64_t v11 = *(void *)(*v3 + 24);
  uint64_t v29 = v3;
  if (v11 > v10 && (a3 & 1) != 0) {
    goto LABEL_12;
  }
  uint64_t v12 = v10 + 1;
  if ((a3 & 1) != 0)
  {
    sub_100054E8C(v12);
  }

  else
  {
    if (v11 > v10)
    {
      sub_1000553FC();
      goto LABEL_12;
    }

    sub_100055620(v12);
  }

  uint64_t v13 = *v3;
  uint64_t v14 = *(void *)(*v3 + 40);
  uint64_t v15 = sub_100058894( &qword_1000DD9F0,  (uint64_t (*)(uint64_t))&type metadata accessor for Transcriber.TranscriptionOption,  (uint64_t)&protocol conformance descriptor for Transcriber.TranscriptionOption);
  uint64_t v16 = dispatch thunk of Hashable._rawHashValue(seed:)(v14, v6, v15);
  uint64_t v17 = -1LL << *(_BYTE *)(v13 + 32);
  a2 = v16 & ~v17;
  if (((*(void *)(v13 + 56 + ((a2 >> 3) & 0xFFFFFFFFFFFFF8LL)) >> a2) & 1) != 0)
  {
    uint64_t v18 = ~v17;
    uint64_t v19 = *(void *)(v7 + 72);
    int64_t v20 = *(void (**)(char *, unint64_t, uint64_t))(v7 + 16);
    do
    {
      v20(v9, *(void *)(v13 + 48) + v19 * a2, v6);
      uint64_t v21 = sub_100058894( &qword_1000DD9F8,  (uint64_t (*)(uint64_t))&type metadata accessor for Transcriber.TranscriptionOption,  (uint64_t)&protocol conformance descriptor for Transcriber.TranscriptionOption);
      char v22 = dispatch thunk of static Equatable.== infix(_:_:)(v9, v30, v6, v21);
      (*(void (**)(char *, uint64_t))(v7 + 8))(v9, v6);
      if ((v22 & 1) != 0) {
        goto LABEL_15;
      }
      a2 = (a2 + 1) & v18;
    }

    while (((*(void *)(v13 + 56 + ((a2 >> 3) & 0xFFFFFFFFFFFFF8LL)) >> a2) & 1) != 0);
  }

void *sub_1000553FC()
{
  uint64_t v1 = v0;
  uint64_t v2 = type metadata accessor for Transcriber.TranscriptionOption(0LL);
  uint64_t v3 = *(void *)(v2 - 8);
  __chkstk_darwin(v2);
  uint64_t v5 = (char *)&v24 - ((v4 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  sub_10004B5C0(&qword_1000DD9E8);
  uint64_t v6 = *v0;
  uint64_t v7 = static _SetStorage.copy(original:)(*v0);
  uint64_t v8 = v7;
  if (!*(void *)(v6 + 16))
  {
    uint64_t result = (void *)swift_release(v6);
LABEL_30:
    uint64_t *v1 = v8;
    return result;
  }

  uint64_t v25 = v1;
  uint64_t result = (void *)(v7 + 56);
  uint64_t v10 = v6 + 56;
  unint64_t v11 = (unint64_t)((1LL << *(_BYTE *)(v8 + 32)) + 63) >> 6;
  int64_t v13 = 0LL;
  *(void *)(v8 + 16) = *(void *)(v6 + 16);
  uint64_t v14 = 1LL << *(_BYTE *)(v6 + 32);
  uint64_t v15 = -1LL;
  if (v14 < 64) {
    uint64_t v15 = ~(-1LL << v14);
  }
  unint64_t v16 = v15 & *(void *)(v6 + 56);
  int64_t v17 = (unint64_t)(v14 + 63) >> 6;
  while (1)
  {
    if (v16)
    {
      unint64_t v18 = __clz(__rbit64(v16));
      v16 &= v16 - 1;
      unint64_t v19 = v18 | (v13 << 6);
      goto LABEL_12;
    }

    int64_t v21 = v13 + 1;
    if (__OFADD__(v13, 1LL))
    {
      __break(1u);
      goto LABEL_32;
    }

    if (v21 >= v17) {
      goto LABEL_28;
    }
    unint64_t v22 = *(void *)(v10 + 8 * v21);
    ++v13;
    if (!v22)
    {
      int64_t v13 = v21 + 1;
      if (v21 + 1 >= v17) {
        goto LABEL_28;
      }
      unint64_t v22 = *(void *)(v10 + 8 * v13);
      if (!v22)
      {
        int64_t v13 = v21 + 2;
        if (v21 + 2 >= v17) {
          goto LABEL_28;
        }
        unint64_t v22 = *(void *)(v10 + 8 * v13);
        if (!v22) {
          break;
        }
      }
    }

LABEL_27:
    unint64_t v16 = (v22 - 1) & v22;
    unint64_t v19 = __clz(__rbit64(v22)) + (v13 << 6);
LABEL_12:
    unint64_t v20 = *(void *)(v3 + 72) * v19;
    (*(void (**)(char *, unint64_t, uint64_t))(v3 + 16))(v5, *(void *)(v6 + 48) + v20, v2);
    uint64_t result = (void *)(*(uint64_t (**)(unint64_t, char *, uint64_t))(v3 + 32))( *(void *)(v8 + 48) + v20,  v5,  v2);
  }

  int64_t v23 = v21 + 3;
  if (v23 >= v17)
  {
LABEL_28:
    uint64_t result = (void *)swift_release(v6);
    uint64_t v1 = v25;
    goto LABEL_30;
  }

  unint64_t v22 = *(void *)(v10 + 8 * v23);
  if (v22)
  {
    int64_t v13 = v23;
    goto LABEL_27;
  }

  while (1)
  {
    int64_t v13 = v23 + 1;
    if (__OFADD__(v23, 1LL)) {
      break;
    }
    if (v13 >= v17) {
      goto LABEL_28;
    }
    unint64_t v22 = *(void *)(v10 + 8 * v13);
    ++v23;
    if (v22) {
      goto LABEL_27;
    }
  }

uint64_t sub_100055620(uint64_t a1)
{
  uint64_t v2 = v1;
  uint64_t v4 = type metadata accessor for Transcriber.TranscriptionOption(0LL);
  uint64_t v5 = *(void *)(v4 - 8);
  __chkstk_darwin(v4);
  uint64_t v7 = (char *)&v34 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v8 = *v2;
  if (*(void *)(*v2 + 24) > a1) {
    a1 = *(void *)(*v2 + 24);
  }
  sub_10004B5C0(&qword_1000DD9E8);
  uint64_t v9 = static _SetStorage.resize(original:capacity:move:)(v8, a1, 0LL);
  uint64_t v10 = v9;
  if (!*(void *)(v8 + 16))
  {
    uint64_t result = swift_release(v8);
LABEL_37:
    uint64_t *v2 = v10;
    return result;
  }

  uint64_t v11 = 1LL << *(_BYTE *)(v8 + 32);
  uint64_t v12 = *(void *)(v8 + 56);
  uint64_t v35 = v2;
  uint64_t v36 = v8 + 56;
  if (v11 < 64) {
    uint64_t v13 = ~(-1LL << v11);
  }
  else {
    uint64_t v13 = -1LL;
  }
  unint64_t v14 = v13 & v12;
  int64_t v37 = (unint64_t)(v11 + 63) >> 6;
  uint64_t v15 = v9 + 56;
  uint64_t result = swift_retain(v8);
  int64_t v17 = 0LL;
  while (1)
  {
    if (v14)
    {
      unint64_t v19 = __clz(__rbit64(v14));
      v14 &= v14 - 1;
      unint64_t v20 = v19 | (v17 << 6);
      goto LABEL_26;
    }

    int64_t v21 = v17 + 1;
    if (__OFADD__(v17, 1LL))
    {
LABEL_38:
      __break(1u);
      goto LABEL_39;
    }

    if (v21 >= v37) {
      goto LABEL_35;
    }
    unint64_t v22 = *(void *)(v36 + 8 * v21);
    ++v17;
    if (!v22)
    {
      int64_t v17 = v21 + 1;
      if (v21 + 1 >= v37) {
        goto LABEL_35;
      }
      unint64_t v22 = *(void *)(v36 + 8 * v17);
      if (!v22)
      {
        int64_t v17 = v21 + 2;
        if (v21 + 2 >= v37) {
          goto LABEL_35;
        }
        unint64_t v22 = *(void *)(v36 + 8 * v17);
        if (!v22) {
          break;
        }
      }
    }

uint64_t sub_100055948@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v3 = v2;
  uint64_t v6 = type metadata accessor for Transcriber.TranscriptionOption(0LL);
  uint64_t v7 = *(void *)(v6 - 8);
  __chkstk_darwin(v6);
  uint64_t v9 = (char *)&v34 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v10 = *v3;
  uint64_t v11 = *(void *)(*v3 + 40);
  uint64_t v13 = sub_100058894( &qword_1000DD9F0,  v12,  (uint64_t)&protocol conformance descriptor for Transcriber.TranscriptionOption);
  swift_bridgeObjectRetain(v10);
  uint64_t v37 = a1;
  uint64_t v14 = dispatch thunk of Hashable._rawHashValue(seed:)(v11, v6, v13);
  uint64_t v16 = -1LL << *(_BYTE *)(v10 + 32);
  unint64_t v17 = v14 & ~v16;
  if (((*(void *)(v10 + 56 + ((v17 >> 3) & 0xFFFFFFFFFFFFF8LL)) >> v17) & 1) != 0)
  {
    uint64_t v35 = v3;
    uint64_t v36 = a2;
    uint64_t v18 = ~v16;
    uint64_t v19 = *(void *)(v7 + 72);
    uint64_t v38 = v7;
    unint64_t v20 = *(void (**)(char *, unint64_t, uint64_t))(v7 + 16);
    while (1)
    {
      unint64_t v21 = v19 * v17;
      v20(v9, *(void *)(v10 + 48) + v19 * v17, v6);
      uint64_t v22 = sub_100058894( &qword_1000DD9F8,  (uint64_t (*)(uint64_t))&type metadata accessor for Transcriber.TranscriptionOption,  (uint64_t)&protocol conformance descriptor for Transcriber.TranscriptionOption);
      char v23 = dispatch thunk of static Equatable.== infix(_:_:)(v9, v37, v6, v22);
      (*(void (**)(char *, uint64_t))(v38 + 8))(v9, v6);
      if ((v23 & 1) != 0) {
        break;
      }
      unint64_t v17 = (v17 + 1) & v18;
      if (((*(void *)(v10 + 56 + ((v17 >> 3) & 0xFFFFFFFFFFFFF8LL)) >> v17) & 1) == 0)
      {
        __n128 v25 = swift_bridgeObjectRelease(v10, v24);
        uint64_t v26 = 1LL;
        a2 = v36;
        uint64_t v7 = v38;
        return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, __n128))(v7 + 56))(a2, v26, 1LL, v6, v25);
      }
    }

    swift_bridgeObjectRelease(v10, v24);
    uint64_t v27 = v35;
    char isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native(*v35);
    uint64_t v29 = *v27;
    uint64_t v39 = *v27;
    *uint64_t v27 = 0x8000000000000000LL;
    if ((isUniquelyReferenced_nonNull_native & 1) == 0)
    {
      sub_1000553FC();
      uint64_t v29 = v39;
    }

    unint64_t v30 = *(void *)(v29 + 48) + v21;
    uint64_t v7 = v38;
    a2 = v36;
    (*(void (**)(uint64_t, unint64_t, uint64_t))(v38 + 32))(v36, v30, v6);
    sub_100055B84(v17);
    uint64_t v31 = *v27;
    *uint64_t v27 = v39;
    __n128 v25 = swift_bridgeObjectRelease(v31, v32);
    uint64_t v26 = 0LL;
  }

  else
  {
    __n128 v25 = swift_bridgeObjectRelease(v10, v15);
    uint64_t v26 = 1LL;
  }

  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, __n128))(v7 + 56))(a2, v26, 1LL, v6, v25);
}

uint64_t sub_100055B84(int64_t a1)
{
  uint64_t v3 = type metadata accessor for Transcriber.TranscriptionOption(0LL);
  uint64_t v30 = *(void *)(v3 - 8);
  uint64_t result = __chkstk_darwin(v3);
  uint64_t v6 = (char *)&v27 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v7 = *v1;
  uint64_t v8 = *v1 + 56;
  uint64_t v9 = -1LL << *(_BYTE *)(*v1 + 32);
  unint64_t v10 = (a1 + 1) & ~v9;
  if (((1LL << v10) & *(void *)(v8 + 8 * (v10 >> 6))) != 0)
  {
    uint64_t v27 = v1;
    uint64_t v11 = ~v9;
    swift_retain(v7);
    uint64_t v12 = _HashTable.previousHole(before:)(a1, v8, v11);
    uint64_t v29 = v8;
    if ((*(void *)(v8 + 8 * (v10 >> 6)) & (1LL << v10)) != 0)
    {
      unint64_t v13 = (v12 + 1) & v11;
      uint64_t v14 = *(void *)(v30 + 72);
      unint64_t v28 = *(void (**)(char *, unint64_t, uint64_t))(v30 + 16);
      do
      {
        int64_t v15 = v14 * v10;
        v28(v6, *(void *)(v7 + 48) + v14 * v10, v3);
        uint64_t v16 = *(void *)(v7 + 40);
        uint64_t v17 = sub_100058894( &qword_1000DD9F0,  (uint64_t (*)(uint64_t))&type metadata accessor for Transcriber.TranscriptionOption,  (uint64_t)&protocol conformance descriptor for Transcriber.TranscriptionOption);
        uint64_t v18 = dispatch thunk of Hashable._rawHashValue(seed:)(v16, v3, v17);
        (*(void (**)(char *, uint64_t))(v30 + 8))(v6, v3);
        unint64_t v19 = v18 & v11;
        if (a1 >= (uint64_t)v13)
        {
        }

        else if (v19 < v13 && a1 < (uint64_t)v19)
        {
          goto LABEL_6;
        }

        int64_t v22 = v14 * a1;
        if (v14 * a1 < v15 || *(void *)(v7 + 48) + v14 * a1 >= (unint64_t)(*(void *)(v7 + 48) + v15 + v14))
        {
          swift_arrayInitWithTakeFrontToBack();
        }

        else
        {
          a1 = v10;
          if (v22 == v15) {
            goto LABEL_6;
          }
          swift_arrayInitWithTakeBackToFront();
        }

        a1 = v10;
LABEL_6:
        unint64_t v10 = (v10 + 1) & v11;
      }

      while (((*(void *)(v29 + ((v10 >> 3) & 0xFFFFFFFFFFFFF8LL)) >> v10) & 1) != 0);
    }

    *(void *)(v29 + (((unint64_t)a1 >> 3) & 0x1FFFFFFFFFFFFFF8LL)) &= (-1LL << a1) - 1;
    uint64_t result = swift_release(v7);
    uint64_t v1 = v27;
  }

  else
  {
    *(void *)(v8 + (((unint64_t)a1 >> 3) & 0x1FFFFFFFFFFFFFF8LL)) &= (-1LL << a1) - 1;
  }

  uint64_t v23 = *v1;
  uint64_t v24 = *(void *)(*v1 + 16);
  BOOL v25 = __OFSUB__(v24, 1LL);
  uint64_t v26 = v24 - 1;
  if (v25)
  {
    __break(1u);
  }

  else
  {
    *(void *)(v23 + 16) = v26;
    ++*(_DWORD *)(v23 + 36);
  }

  return result;
}

unint64_t sub_100055E00(uint64_t a1)
{
  uint64_t v2 = v1;
  uint64_t v4 = *(void *)(v2 + 40);
  uint64_t v5 = type metadata accessor for AnalysisContext.ContextualStringsTag(0LL);
  uint64_t v6 = sub_100058894( &qword_1000DDA48,  (uint64_t (*)(uint64_t))&type metadata accessor for AnalysisContext.ContextualStringsTag,  (uint64_t)&protocol conformance descriptor for AnalysisContext.ContextualStringsTag);
  uint64_t v7 = dispatch thunk of Hashable._rawHashValue(seed:)(v4, v5, v6);
  return sub_1000563F4(a1, v7);
}

uint64_t sub_100055E6C(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = v2;
  uint64_t v6 = type metadata accessor for AnalysisContext.ContextualStringsTag(0LL);
  uint64_t v7 = *(void *)(v6 - 8);
  __chkstk_darwin(v6);
  uint64_t v9 = (char *)&v40 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v10 = *v2;
  if (*(void *)(*v2 + 24) > a1) {
    a1 = *(void *)(*v2 + 24);
  }
  sub_10004B5C0(&qword_1000DDA40);
  int v45 = a2;
  uint64_t v11 = static _DictionaryStorage.resize(original:capacity:move:)(v10, a1, a2);
  uint64_t v12 = v11;
  if (!*(void *)(v10 + 16)) {
    goto LABEL_43;
  }
  uint64_t v13 = 1LL << *(_BYTE *)(v10 + 32);
  uint64_t v14 = *(void *)(v10 + 64);
  uint64_t v43 = (void *)(v10 + 64);
  if (v13 < 64) {
    uint64_t v15 = ~(-1LL << v13);
  }
  else {
    uint64_t v15 = -1LL;
  }
  unint64_t v16 = v15 & v14;
  uint64_t v41 = v2;
  int64_t v42 = (unint64_t)(v13 + 63) >> 6;
  uint64_t v17 = v11 + 64;
  uint64_t result = swift_retain(v10);
  int64_t v19 = 0LL;
  for (i = v10; ; uint64_t v10 = i)
  {
    if (v16)
    {
      unint64_t v21 = __clz(__rbit64(v16));
      v16 &= v16 - 1;
      unint64_t v22 = v21 | (v19 << 6);
      goto LABEL_24;
    }

    int64_t v23 = v19 + 1;
    if (__OFADD__(v19, 1LL))
    {
LABEL_44:
      __break(1u);
LABEL_45:
      __break(1u);
      return result;
    }

    if (v23 >= v42) {
      break;
    }
    uint64_t v24 = v43;
    unint64_t v25 = v43[v23];
    ++v19;
    if (!v25)
    {
      int64_t v19 = v23 + 1;
      if (v23 + 1 >= v42) {
        goto LABEL_36;
      }
      unint64_t v25 = v43[v19];
      if (!v25)
      {
        int64_t v26 = v23 + 2;
        if (v26 >= v42)
        {
LABEL_36:
          swift_release(v10);
          uint64_t v3 = v41;
          if ((v45 & 1) == 0) {
            goto LABEL_43;
          }
          goto LABEL_39;
        }

        unint64_t v25 = v43[v26];
        if (!v25)
        {
          while (1)
          {
            int64_t v19 = v26 + 1;
            if (__OFADD__(v26, 1LL)) {
              goto LABEL_45;
            }
            if (v19 >= v42) {
              goto LABEL_36;
            }
            unint64_t v25 = v43[v19];
            ++v26;
            if (v25) {
              goto LABEL_23;
            }
          }
        }

        int64_t v19 = v26;
      }
    }

uint64_t sub_100056200(uint64_t a1, uint64_t a2, char a3)
{
  uint64_t v4 = (void **)v3;
  uint64_t v8 = type metadata accessor for AnalysisContext.ContextualStringsTag(0LL);
  uint64_t v9 = *(void *)(v8 - 8);
  __chkstk_darwin(v8);
  uint64_t v11 = (char *)&v24 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v12 = (void *)*v3;
  unint64_t v14 = sub_100055E00(a2);
  uint64_t v15 = v12[2];
  BOOL v16 = (v13 & 1) == 0;
  uint64_t v17 = v15 + v16;
  if (__OFADD__(v15, v16))
  {
    __break(1u);
    goto LABEL_14;
  }

  char v18 = v13;
  uint64_t v19 = v12[3];
  if (v19 >= v17 && (a3 & 1) != 0)
  {
LABEL_7:
    unint64_t v20 = *v4;
    if ((v18 & 1) != 0)
    {
LABEL_8:
      uint64_t v21 = v20[7];
      uint64_t result = swift_bridgeObjectRelease(*(void *)(v21 + 8 * v14), v13);
      *(void *)(v21 + 8 * v14) = a1;
      return result;
    }

    goto LABEL_11;
  }

  if (v19 >= v17 && (a3 & 1) == 0)
  {
    sub_100056534();
    goto LABEL_7;
  }

  sub_100055E6C(v17, a3 & 1);
  unint64_t v23 = sub_100055E00(a2);
  if ((v18 & 1) != (v13 & 1))
  {
LABEL_14:
    uint64_t result = KEY_TYPE_OF_DICTIONARY_VIOLATES_HASHABLE_REQUIREMENTS(_:)(v8);
    __break(1u);
    return result;
  }

  unint64_t v14 = v23;
  unint64_t v20 = *v4;
  if ((v18 & 1) != 0) {
    goto LABEL_8;
  }
LABEL_11:
  (*(void (**)(char *, uint64_t, uint64_t))(v9 + 16))(v11, a2, v8);
  return sub_10005635C(v14, (uint64_t)v11, a1, v20);
}

uint64_t sub_10005635C(unint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  a4[(a1 >> 6) + 8] |= 1LL << a1;
  uint64_t v8 = a4[6];
  uint64_t v9 = type metadata accessor for AnalysisContext.ContextualStringsTag(0LL);
  uint64_t result = (*(uint64_t (**)(unint64_t, uint64_t, uint64_t))(*(void *)(v9 - 8) + 32LL))( v8 + *(void *)(*(void *)(v9 - 8) + 72LL) * a1,  a2,  v9);
  *(void *)(a4[7] + 8 * a1) = a3;
  uint64_t v11 = a4[2];
  BOOL v12 = __OFADD__(v11, 1LL);
  uint64_t v13 = v11 + 1;
  if (v12) {
    __break(1u);
  }
  else {
    a4[2] = v13;
  }
  return result;
}

unint64_t sub_1000563F4(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = v2;
  uint64_t v18 = a1;
  uint64_t v5 = type metadata accessor for AnalysisContext.ContextualStringsTag(0LL);
  uint64_t v6 = *(void *)(v5 - 8);
  __chkstk_darwin(v5);
  uint64_t v8 = (char *)&v17 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v9 = -1LL << *(_BYTE *)(v3 + 32);
  unint64_t v10 = a2 & ~v9;
  if (((*(void *)(v3 + 64 + ((v10 >> 3) & 0xFFFFFFFFFFFFF8LL)) >> v10) & 1) != 0)
  {
    uint64_t v11 = ~v9;
    uint64_t v12 = *(void *)(v6 + 72);
    uint64_t v13 = *(void (**)(char *, unint64_t, uint64_t))(v6 + 16);
    do
    {
      v13(v8, *(void *)(v3 + 48) + v12 * v10, v5);
      uint64_t v14 = sub_100058894( &qword_1000DDA50,  (uint64_t (*)(uint64_t))&type metadata accessor for AnalysisContext.ContextualStringsTag,  (uint64_t)&protocol conformance descriptor for AnalysisContext.ContextualStringsTag);
      char v15 = dispatch thunk of static Equatable.== infix(_:_:)(v8, v18, v5, v14);
      (*(void (**)(char *, uint64_t))(v6 + 8))(v8, v5);
      if ((v15 & 1) != 0) {
        break;
      }
      unint64_t v10 = (v10 + 1) & v11;
    }

    while (((*(void *)(v3 + 64 + ((v10 >> 3) & 0xFFFFFFFFFFFFF8LL)) >> v10) & 1) != 0);
  }

  return v10;
}

void *sub_100056534()
{
  uint64_t v1 = type metadata accessor for AnalysisContext.ContextualStringsTag(0LL);
  uint64_t v2 = *(void *)(v1 - 8);
  __chkstk_darwin(v1);
  uint64_t v4 = (char *)&v23 - ((v3 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  sub_10004B5C0(&qword_1000DDA40);
  uint64_t v24 = v0;
  uint64_t v5 = *v0;
  uint64_t v6 = static _DictionaryStorage.copy(original:)(*v0);
  uint64_t v7 = v6;
  if (!*(void *)(v5 + 16))
  {
LABEL_26:
    uint64_t result = (void *)swift_release(v5);
    *uint64_t v24 = v7;
    return result;
  }

  uint64_t result = (void *)(v6 + 64);
  unint64_t v9 = (unint64_t)((1LL << *(_BYTE *)(v7 + 32)) + 63) >> 6;
  uint64_t v25 = v5 + 64;
  int64_t v11 = 0LL;
  *(void *)(v7 + 16) = *(void *)(v5 + 16);
  uint64_t v12 = 1LL << *(_BYTE *)(v5 + 32);
  uint64_t v13 = -1LL;
  if (v12 < 64) {
    uint64_t v13 = ~(-1LL << v12);
  }
  unint64_t v14 = v13 & *(void *)(v5 + 64);
  int64_t v26 = (unint64_t)(v12 + 63) >> 6;
  while (1)
  {
    if (v14)
    {
      unint64_t v15 = __clz(__rbit64(v14));
      v14 &= v14 - 1;
      unint64_t v16 = v15 | (v11 << 6);
      goto LABEL_12;
    }

    int64_t v20 = v11 + 1;
    if (__OFADD__(v11, 1LL))
    {
      __break(1u);
      goto LABEL_28;
    }

    if (v20 >= v26) {
      goto LABEL_26;
    }
    unint64_t v21 = *(void *)(v25 + 8 * v20);
    ++v11;
    if (!v21)
    {
      int64_t v11 = v20 + 1;
      if (v20 + 1 >= v26) {
        goto LABEL_26;
      }
      unint64_t v21 = *(void *)(v25 + 8 * v11);
      if (!v21) {
        break;
      }
    }

LABEL_28:
  __break(1u);
  return result;
}

          uint64_t v24 = (float *)&v28;
          uint64_t v25 = (uint64_t *)&v31;
LABEL_34:
          sub_100070E9C(a1, a2, v24, (uint64_t)v25, &v27);
          goto LABEL_35;
        }

        if (!v16[33])
        {
          uint64_t v27 = v16[34] ^ 1;
          goto LABEL_28;
        }
      }

      else
      {
        uint64_t v19 = HIDWORD(v13);
        int64_t v20 = *(unsigned __int8 **)(a1 + 136);
        if ((_DWORD)v19 != -1)
        {
          if ((_DWORD)v14 == -1)
          {
            unint64_t v21 = v20[32];
            if (v21) {
              int64_t v22 = -1;
            }
            else {
              int64_t v22 = 0;
            }
            uint64_t v27 = v22;
            if (v21) {
              goto LABEL_35;
            }
          }

          else
          {
            if ((_DWORD)v19) {
              int64_t v26 = 0;
            }
            else {
              int64_t v26 = -1;
            }
            uint64_t v27 = v26;
            if (!(_DWORD)v19) {
              goto LABEL_35;
            }
          }

          uint64_t v25 = sub_10002D5B4(a1 + 36, (uint64_t)&v39);
LABEL_38:
          a1[37] = v25;
          goto LABEL_39;
        }

        uint64_t v27 = a1[36] + 16LL * v22[5];
        uint64_t v29 = *(float *)(v27 + 8);
        unint64_t v28 = (float *)(v27 + 8);
        uint64_t v30 = v29;
        if (v29 == -INFINITY || v40 >= -INFINITY && v40 <= -INFINITY)
        {
          uint64_t v30 = *(float *)sub_1000606CC();
        }

        else if (v30 >= v40)
        {
          uint64_t v30 = v40;
        }

        uint8_t *v28 = v30;
      }

      else
      {
        while (a1[33] <= (unint64_t)v41)
        {
          LOBYTE(v36[0]) = 0;
          sub_10002BFAC((uint64_t)(a1 + 32), v36);
        }
      }

uint64_t sub_100056764(char a1, int64_t a2, char a3)
{
  uint64_t result = sub_100056780(a1, a2, a3, *v3);
  *uint64_t v3 = (char *)result;
  return result;
}

uint64_t sub_100056780(char a1, int64_t a2, char a3, char *a4)
{
  if ((a3 & 1) != 0)
  {
    unint64_t v6 = *((void *)a4 + 3);
    int64_t v7 = v6 >> 1;
    if ((uint64_t)(v6 >> 1) < a2)
    {
      if (v7 + 0x4000000000000000LL < 0)
      {
        __break(1u);
        goto LABEL_32;
      }

      int64_t v7 = v6 & 0xFFFFFFFFFFFFFFFELL;
    }
  }

  else
  {
    int64_t v7 = a2;
  }

  uint64_t v8 = *((void *)a4 + 2);
  if (v7 <= v8) {
    uint64_t v9 = *((void *)a4 + 2);
  }
  else {
    uint64_t v9 = v7;
  }
  if (v9)
  {
    uint64_t v10 = sub_10004B5C0(&qword_1000DDA28);
    int64_t v11 = (char *)swift_allocObject(v10, 16 * v9 + 32, 7LL);
    int64_t v12 = j__malloc_size(v11);
    uint64_t v13 = v12 - 32;
    if (v12 < 32) {
      uint64_t v13 = v12 - 17;
    }
    *((void *)v11 + 2) = v8;
    *((void *)v11 + 3) = 2 * (v13 >> 4);
  }

  else
  {
    int64_t v11 = (char *)&_swiftEmptyArrayStorage;
  }

  unint64_t v14 = v11 + 32;
  unint64_t v15 = a4 + 32;
  if ((a1 & 1) != 0)
  {
    if (v11 != a4 || v14 >= &v15[16 * v8]) {
      memmove(v14, v15, 16 * v8);
    }
    *((void *)a4 + 2) = 0LL;
    goto LABEL_30;
  }

  if (v15 >= &v14[16 * v8] || v14 >= &v15[16 * v8])
  {
    swift_arrayInitWithCopy();
LABEL_30:
    swift_release(a4);
    return (uint64_t)v11;
  }

void *sub_1000568E8(uint64_t a1)
{
  uint64_t v2 = type metadata accessor for Transcriber.ReportingOption(0LL);
  uint64_t v3 = *(void *)(v2 - 8);
  uint64_t v4 = __chkstk_darwin(v2);
  unint64_t v6 = (char *)&v30 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  __chkstk_darwin(v4);
  uint64_t v8 = (char *)&v30 - v7;
  uint64_t v9 = *(void *)(a1 + 16);
  if (v9)
  {
    sub_10004B5C0(&qword_1000DDA00);
    uint64_t v10 = static _SetStorage.allocate(capacity:)(v9);
    uint64_t v11 = 0LL;
    uint64_t v12 = *(unsigned __int8 *)(v3 + 80);
    uint64_t v31 = v9;
    uint64_t v32 = a1 + ((v12 + 32) & ~v12);
    uint64_t v13 = *(void *)(v3 + 72);
    unint64_t v34 = *(void (**)(char *, uint64_t, uint64_t))(v3 + 16);
    uint64_t v35 = v10 + 56;
    while (1)
    {
      uint64_t v33 = v11;
      v34(v8, v32 + v13 * v11, v2);
      uint64_t v14 = *(void *)(v10 + 40);
      uint64_t v15 = sub_100058894( &qword_1000DDA08,  (uint64_t (*)(uint64_t))&type metadata accessor for Transcriber.ReportingOption,  (uint64_t)&protocol conformance descriptor for Transcriber.ReportingOption);
      uint64_t v16 = dispatch thunk of Hashable._rawHashValue(seed:)(v14, v2, v15);
      uint64_t v17 = ~(-1LL << *(_BYTE *)(v10 + 32));
      unint64_t v18 = v16 & v17;
      unint64_t v19 = (v16 & (unint64_t)v17) >> 6;
      uint64_t v20 = *(void *)(v35 + 8 * v19);
      uint64_t v21 = 1LL << (v16 & v17);
      if ((v21 & v20) != 0)
      {
        do
        {
          v34(v6, *(void *)(v10 + 48) + v18 * v13, v2);
          uint64_t v22 = sub_100058894( &qword_1000DDA10,  (uint64_t (*)(uint64_t))&type metadata accessor for Transcriber.ReportingOption,  (uint64_t)&protocol conformance descriptor for Transcriber.ReportingOption);
          char v23 = dispatch thunk of static Equatable.== infix(_:_:)(v6, v8, v2, v22);
          uint64_t v24 = v3;
          uint64_t v25 = *(void (**)(char *, uint64_t))(v3 + 8);
          v25(v6, v2);
          if ((v23 & 1) != 0)
          {
            v25(v8, v2);
            uint64_t v3 = v24;
            uint64_t v9 = v31;
            goto LABEL_4;
          }

          unint64_t v18 = (v18 + 1) & v17;
          unint64_t v19 = v18 >> 6;
          uint64_t v20 = *(void *)(v35 + 8 * (v18 >> 6));
          uint64_t v21 = 1LL << v18;
          uint64_t v3 = v24;
        }

        while ((v20 & (1LL << v18)) != 0);
        uint64_t v9 = v31;
      }

      *(void *)(v35 + 8 * v19) = v21 | v20;
      uint64_t result = (void *)(*(uint64_t (**)(unint64_t, char *, uint64_t))(v3 + 32))( *(void *)(v10 + 48) + v18 * v13,  v8,  v2);
      uint64_t v27 = *(void *)(v10 + 16);
      BOOL v28 = __OFADD__(v27, 1LL);
      uint64_t v29 = v27 + 1;
      if (v28) {
        break;
      }
      *(void *)(v10 + 16) = v29;
LABEL_4:
      uint64_t v11 = v33 + 1;
      if (v33 + 1 == v9) {
        return (void *)v10;
      }
    }

    __break(1u);
  }

  else
  {
    return &_swiftEmptySetSingleton;
  }

  return result;
}

void *sub_100056B50(uint64_t a1)
{
  uint64_t v2 = type metadata accessor for Transcriber.TranscriptionOption(0LL);
  uint64_t v3 = *(void *)(v2 - 8);
  uint64_t v4 = __chkstk_darwin(v2);
  unint64_t v6 = (char *)&v30 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  __chkstk_darwin(v4);
  uint64_t v8 = (char *)&v30 - v7;
  uint64_t v9 = *(void *)(a1 + 16);
  if (v9)
  {
    sub_10004B5C0(&qword_1000DD9E8);
    uint64_t v10 = static _SetStorage.allocate(capacity:)(v9);
    uint64_t v11 = 0LL;
    uint64_t v12 = *(unsigned __int8 *)(v3 + 80);
    uint64_t v31 = v9;
    uint64_t v32 = a1 + ((v12 + 32) & ~v12);
    uint64_t v13 = *(void *)(v3 + 72);
    unint64_t v34 = *(void (**)(char *, uint64_t, uint64_t))(v3 + 16);
    uint64_t v35 = v10 + 56;
    while (1)
    {
      uint64_t v33 = v11;
      v34(v8, v32 + v13 * v11, v2);
      uint64_t v14 = *(void *)(v10 + 40);
      uint64_t v15 = sub_100058894( &qword_1000DD9F0,  (uint64_t (*)(uint64_t))&type metadata accessor for Transcriber.TranscriptionOption,  (uint64_t)&protocol conformance descriptor for Transcriber.TranscriptionOption);
      uint64_t v16 = dispatch thunk of Hashable._rawHashValue(seed:)(v14, v2, v15);
      uint64_t v17 = ~(-1LL << *(_BYTE *)(v10 + 32));
      unint64_t v18 = v16 & v17;
      unint64_t v19 = (v16 & (unint64_t)v17) >> 6;
      uint64_t v20 = *(void *)(v35 + 8 * v19);
      uint64_t v21 = 1LL << (v16 & v17);
      if ((v21 & v20) != 0)
      {
        do
        {
          v34(v6, *(void *)(v10 + 48) + v18 * v13, v2);
          uint64_t v22 = sub_100058894( &qword_1000DD9F8,  (uint64_t (*)(uint64_t))&type metadata accessor for Transcriber.TranscriptionOption,  (uint64_t)&protocol conformance descriptor for Transcriber.TranscriptionOption);
          char v23 = dispatch thunk of static Equatable.== infix(_:_:)(v6, v8, v2, v22);
          uint64_t v24 = v3;
          uint64_t v25 = *(void (**)(char *, uint64_t))(v3 + 8);
          v25(v6, v2);
          if ((v23 & 1) != 0)
          {
            v25(v8, v2);
            uint64_t v3 = v24;
            uint64_t v9 = v31;
            goto LABEL_4;
          }

          unint64_t v18 = (v18 + 1) & v17;
          unint64_t v19 = v18 >> 6;
          uint64_t v20 = *(void *)(v35 + 8 * (v18 >> 6));
          uint64_t v21 = 1LL << v18;
          uint64_t v3 = v24;
        }

        while ((v20 & (1LL << v18)) != 0);
        uint64_t v9 = v31;
      }

      *(void *)(v35 + 8 * v19) = v21 | v20;
      uint64_t result = (void *)(*(uint64_t (**)(unint64_t, char *, uint64_t))(v3 + 32))( *(void *)(v10 + 48) + v18 * v13,  v8,  v2);
      uint64_t v27 = *(void *)(v10 + 16);
      BOOL v28 = __OFADD__(v27, 1LL);
      uint64_t v29 = v27 + 1;
      if (v28) {
        break;
      }
      *(void *)(v10 + 16) = v29;
LABEL_4:
      uint64_t v11 = v33 + 1;
      if (v33 + 1 == v9) {
        return (void *)v10;
      }
    }

    __break(1u);
  }

  else
  {
    return &_swiftEmptySetSingleton;
  }

  return result;
}

uint64_t sub_100056DB8(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = type metadata accessor for Transcriber.TranscriptionOption(0LL);
  uint64_t v5 = *(void *)(v4 - 8);
  uint64_t v6 = __chkstk_darwin(v4);
  uint64_t v8 = (char *)&v16 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  __chkstk_darwin(v6);
  uint64_t v10 = (char *)&v16 - v9;
  uint64_t v17 = a2;
  uint64_t v11 = *(void *)(a1 + 16);
  if (v11)
  {
    uint64_t v12 = a1 + ((*(unsigned __int8 *)(v5 + 80) + 32LL) & ~(unint64_t)*(unsigned __int8 *)(v5 + 80));
    uint64_t v13 = *(void *)(v5 + 72);
    uint64_t v14 = *(void (**)(char *, uint64_t, uint64_t))(v5 + 16);
    do
    {
      v14(v8, v12, v4);
      sub_100054C30((uint64_t)v10, v8);
      (*(void (**)(char *, uint64_t))(v5 + 8))(v10, v4);
      v12 += v13;
      --v11;
    }

    while (v11);
    return v17;
  }

  return a2;
}

id sub_100056EBC(void *a1, uint64_t a2, int a3, int a4, int a5)
{
  int v125 = a5;
  LODWORD(v1++*(void *)(result + 24) = a4;
  LODWORD(v134) = a3;
  uint64_t v123 = a2;
  NSString v122 = a1;
  uint64_t v6 = sub_10004B5C0(&qword_1000DDA58);
  __chkstk_darwin(v6);
  id v119 = (char *)&v114 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v117 = type metadata accessor for AnalysisOptions.ModelRetention(0LL);
  uint64_t v115 = *(void *)(v117 - 8);
  __chkstk_darwin(v117);
  uint64_t v118 = (char *)&v114 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v9 = type metadata accessor for TaskPriority(0LL);
  __chkstk_darwin(v9);
  uint64_t v116 = (char *)&v114 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v11 = sub_10004B5C0(&qword_1000DD6B8);
  __chkstk_darwin(v11);
  id v137 = (char *)&v114 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v132 = sub_10004B5C0(&qword_1000DD770);
  uint64_t v130 = *(void *)(v132 - 8);
  __chkstk_darwin(v132);
  uint64_t v128 = (char *)&v114 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  Class v133 = (Class)sub_10004B5C0(&qword_1000DD6C8);
  Class isa = v133[-1].isa;
  __chkstk_darwin(v133);
  uint64_t v129 = (char *)&v114 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v142 = sub_10004B5C0(&qword_1000DD6C0);
  uint64_t v139 = *(void *)(v142 - 8);
  __chkstk_darwin(v142);
  uint64_t v141 = (char *)&v114 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v138 = type metadata accessor for ClientInfo(0LL);
  uint64_t v143 = *(void *)(v138 - 8);
  uint64_t v16 = __chkstk_darwin(v138);
  uint64_t v140 = (char *)&v114 - ((v17 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  __chkstk_darwin(v16);
  uint64_t v136 = (char *)&v114 - v18;
  uint64_t v19 = sub_10004B5C0(&qword_1000DD7A8);
  uint64_t v20 = __chkstk_darwin(v19);
  uint64_t v22 = (char *)&v114 - ((v21 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  __chkstk_darwin(v20);
  uint64_t v24 = (char *)&v114 - v23;
  uint64_t v121 = type metadata accessor for Transcriber.ModelOptions(0LL);
  uint64_t v120 = *(void *)(v121 - 8);
  __chkstk_darwin(v121);
  int64_t v26 = (char *)&v114 - ((v25 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v27 = type metadata accessor for Locale(0LL);
  uint64_t v28 = *(void *)(v27 - 8);
  __chkstk_darwin(v27);
  uint64_t v30 = (char *)&v114 - ((v29 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v31 = &v5[OBJC_IVAR____TtC50com_apple_SpeechRecognitionCore_speechrecognitiond25RDSAPISwiftSpeechAnalyzer__logger];
  uint64_t v32 = qword_1000DDE78;
  uint64_t v33 = v5;
  if (v32 != -1) {
    swift_once(&qword_1000DDE78, sub_10004C1D4);
  }
  uint64_t v35 = qword_1000DE7A0;
  uint64_t v34 = *(void *)algn_1000DE7A8;
  swift_bridgeObjectRetain(*(void *)algn_1000DE7A8);
  unint64_t v135 = v31;
  Logger.init(subsystem:category:)(0xD00000000000001FLL, 0x80000001000BF4D0LL, v35, v34);
  unint64_t v36 = (void **)&v33[OBJC_IVAR____TtC50com_apple_SpeechRecognitionCore_speechrecognitiond25RDSAPISwiftSpeechAnalyzer__delegate];
  *(void *)&v33[OBJC_IVAR____TtC50com_apple_SpeechRecognitionCore_speechrecognitiond25RDSAPISwiftSpeechAnalyzer__delegate] = 0LL;
  BOOL v37 = &v33[OBJC_IVAR____TtC50com_apple_SpeechRecognitionCore_speechrecognitiond25RDSAPISwiftSpeechAnalyzer__taskHint];
  uint64_t v38 = type metadata accessor for TaskHint(0LL);
  (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(*(void *)(v38 - 8) + 56LL))(v37, 1LL, 1LL, v38);
  uint64_t v39 = &v33[OBJC_IVAR____TtC50com_apple_SpeechRecognitionCore_speechrecognitiond25RDSAPISwiftSpeechAnalyzer__analysisOptions];
  uint64_t v40 = type metadata accessor for AnalysisOptions(0LL);
  uint64_t v41 = *(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(v40 - 8) + 56LL);
  uint64_t v114 = (uint64_t)v39;
  uint64_t v127 = v40;
  id v126 = v41;
  ((void (*)(char *, uint64_t, uint64_t))v41)(v39, 1LL, 1LL);
  *(void *)&v33[OBJC_IVAR____TtC50com_apple_SpeechRecognitionCore_speechrecognitiond25RDSAPISwiftSpeechAnalyzer__recognitionTask] = 0LL;
  swift_beginAccess(v36, v147, 1LL, 0LL);
  int64_t v42 = *v36;
  uint64_t v43 = v122;
  *unint64_t v36 = v122;
  id v44 = v43;

  *(void *)&v33[OBJC_IVAR____TtC50com_apple_SpeechRecognitionCore_speechrecognitiond25RDSAPISwiftSpeechAnalyzer__totalSamplesSent] = 0LL;
  *(void *)&v33[OBJC_IVAR____TtC50com_apple_SpeechRecognitionCore_speechrecognitiond25RDSAPISwiftSpeechAnalyzer__newUtteranceBeginSampleNumber] = 0LL;
  static Locale._unconditionallyBridgeFromObjectiveC(_:)(v123);
  (*(void (**)(char *, char *, uint64_t))(v28 + 32))( &v33[OBJC_IVAR____TtC50com_apple_SpeechRecognitionCore_speechrecognitiond25RDSAPISwiftSpeechAnalyzer__locale],  v30,  v27);
  uint64_t v45 = type metadata accessor for URL(0LL);
  uint64_t v46 = *(void (**)(char *, uint64_t, uint64_t, uint64_t))(*(void *)(v45 - 8) + 56LL);
  v46(v24, 1LL, 1LL, v45);
  v46(v22, 1LL, 1LL, v45);
  Transcriber.ModelOptions.init(supplementalModelURL:farField:modelOverrideURL:speechProfiles:userIdMask:taskForMemoryLock:atypicalSpeech:enableParallelLoading:speechProfileContainers:)( v24,  v124 & 1,  v22,  &_swiftEmptyArrayStorage,  0LL,  0LL,  0LL,  0LL,  0,  0LL);
  (*(void (**)(char *, char *, uint64_t))(v120 + 32))( &v33[OBJC_IVAR____TtC50com_apple_SpeechRecognitionCore_speechrecognitiond25RDSAPISwiftSpeechAnalyzer__modelOptions],  v26,  v121);
  uint64_t v47 = sub_10004B5C0(&qword_1000DD778);
  uint64_t v48 = type metadata accessor for Transcriber.ReportingOption(0LL);
  uint64_t v49 = *(void *)(v48 - 8);
  uint64_t v50 = *(void *)(v49 + 72);
  uint64_t v51 = *(unsigned __int8 *)(v49 + 80);
  uint64_t v52 = (v51 + 32) & ~v51;
  uint64_t v53 = swift_allocObject(v47, v52 + 3 * v50, v51 | 7);
  *(_OWORD *)(v53 + 16) = xmmword_1000AC550;
  uint64_t v54 = v53 + v52;
  id v55 = *(void (**)(uint64_t, void, uint64_t))(v49 + 104);
  v55(v54, enum case for Transcriber.ReportingOption.multisegmentResults(_:), v48);
  v55(v54 + v50, enum case for Transcriber.ReportingOption.alternativeTranscriptions(_:), v48);
  v55(v54 + 2 * v50, enum case for Transcriber.ReportingOption.volatileResults(_:), v48);
  uint64_t v56 = sub_1000568E8(v53);
  swift_setDeallocating(v53);
  swift_arrayDestroy(v54, 3LL, v48);
  swift_deallocClassInstance(v53, 32LL, 7LL);
  *(void *)&v33[OBJC_IVAR____TtC50com_apple_SpeechRecognitionCore_speechrecognitiond25RDSAPISwiftSpeechAnalyzer__reportingOptions] = v56;
  uint64_t v57 = sub_10004B5C0(&qword_1000DD710);
  uint64_t v58 = type metadata accessor for Transcriber.TranscriptionOption(0LL);
  uint64_t v59 = *(void *)(v58 - 8);
  uint64_t v60 = *(unsigned __int8 *)(v59 + 80);
  uint64_t v61 = (v60 + 32) & ~v60;
  uint64_t v62 = v61 + *(void *)(v59 + 72);
  uint64_t v63 = v60 | 7;
  uint64_t v64 = swift_allocObject(v57, v62, v60 | 7);
  __int128 v124 = xmmword_1000AC520;
  *(_OWORD *)(v64 + 16) = xmmword_1000AC520;
  id v65 = *(void (**)(uint64_t, void, uint64_t))(v59 + 104);
  v65(v64 + v61, enum case for Transcriber.TranscriptionOption.contextualizedTranscription(_:), v58);
  id v66 = sub_100056B50(v64);
  swift_setDeallocating(v64);
  swift_arrayDestroy(v64 + v61, 1LL, v58);
  swift_deallocClassInstance(v64, 32LL, 7LL);
  id v67 = (uint64_t *)&v33[OBJC_IVAR____TtC50com_apple_SpeechRecognitionCore_speechrecognitiond25RDSAPISwiftSpeechAnalyzer__transcriptionOptions];
  *(void *)&v33[OBJC_IVAR____TtC50com_apple_SpeechRecognitionCore_speechrecognitiond25RDSAPISwiftSpeechAnalyzer__transcriptionOptions] = v66;
  if ((v125 & 1) != 0)
  {
    uint64_t v68 = swift_allocObject(v57, v62, v63);
    *(_OWORD *)(v68 + 16) = v124;
    v65(v68 + v61, enum case for Transcriber.TranscriptionOption.emoji(_:), v58);
    swift_bridgeObjectRetain(v66);
    uint64_t v69 = sub_100056DB8(v68, (uint64_t)v66);
    swift_setDeallocating(v68);
    swift_arrayDestroy(v68 + v61, 1LL, v58);
    swift_deallocClassInstance(v68, 32LL, 7LL);
    swift_beginAccess(v67, v144, 1LL, 0LL);
    uint64_t v70 = *v67;
    *id v67 = v69;
    swift_bridgeObjectRelease(v70, v71);
  }

  if (qword_1000DDE70 != -1) {
    swift_once(&qword_1000DDE70, sub_10004C15C);
  }
  uint64_t v72 = qword_1000DE790;
  uint64_t v73 = *(void *)algn_1000DE798;
  swift_bridgeObjectRetain(*(void *)algn_1000DE798);
  uint64_t v74 = v136;
  ClientInfo.init(identifier:)(v72, v73);
  uint64_t v75 = type metadata accessor for AnalyzerInput(0LL);
  uint64_t v76 = v130;
  uint64_t v77 = v128;
  uint64_t v78 = v132;
  (*(void (**)(char *, void, uint64_t))(v130 + 104))( v128,  enum case for AsyncStream.Continuation.BufferingPolicy.unbounded<A>(_:),  v132);
  __int128 v79 = v141;
  uint64_t v80 = v129;
  static AsyncStream.makeStream(of:bufferingPolicy:)(v141, v129, v75, v77, v75);
  (*(void (**)(char *, uint64_t))(v76 + 8))(v77, v78);
  uint64_t v81 = &v33[OBJC_IVAR____TtC50com_apple_SpeechRecognitionCore_speechrecognitiond25RDSAPISwiftSpeechAnalyzer__inputStream];
  uint64_t v82 = v139;
  uint64_t v83 = v142;
  (*(void (**)(char *, char *, uint64_t))(v139 + 32))( &v33[OBJC_IVAR____TtC50com_apple_SpeechRecognitionCore_speechrecognitiond25RDSAPISwiftSpeechAnalyzer__inputStream],  v79,  v142);
  ((void (*)(char *, char *, Class))isa[4].isa)( &v33[OBJC_IVAR____TtC50com_apple_SpeechRecognitionCore_speechrecognitiond25RDSAPISwiftSpeechAnalyzer__inputStreamBuilder],  v80,  v133);
  Class v133 = (Class)type metadata accessor for AnalysisContext(0LL);
  p_name = &RDSAPISwiftSpeechAnalyzer.name;
  id v85 = [objc_allocWithZone(v133) init];
  *(void *)&v33[OBJC_IVAR____TtC50com_apple_SpeechRecognitionCore_speechrecognitiond25RDSAPISwiftSpeechAnalyzer__analysisContext] = v85;
  uint64_t v87 = (uint64_t)v137;
  uint64_t v86 = v138;
  uint64_t v88 = v143;
  if ((v134 & 1) != 0)
  {
    uint64_t v89 = v74;
    uint64_t v90 = v116;
    static TaskPriority.high.getter();
    uint64_t v91 = v118;
    (*(void (**)(char *, void, uint64_t))(v115 + 104))( v118,  enum case for AnalysisOptions.ModelRetention.whileInUse(_:),  v117);
    uint64_t v92 = type metadata accessor for AnalysisOptions.PowerContext(0LL);
    uint64_t v93 = *(void (**)(char *, uint64_t, uint64_t, uint64_t))(*(void *)(v92 - 8) + 56LL);
    uint64_t v132 = (uint64_t)v81;
    uint64_t v94 = v88;
    uint64_t v95 = v119;
    v93(v119, 1LL, 1LL, v92);
    uint64_t v96 = v90;
    uint64_t v74 = v89;
    AnalysisOptions.init(priority:modelRetention:powerContext:)(v96, v91, v95);
    v126(v87, 0LL, 1LL, v127);
    uint64_t v97 = v114;
    swift_beginAccess(v114, v145, 33LL, 0LL);
    sub_1000588D4(v87, v97, &qword_1000DD6B8);
    swift_endAccess(v145);
    uint64_t v134 = type metadata accessor for SpeechAnalyzer(0LL);
    uint64_t v98 = v86;
    (*(void (**)(char *, char *, uint64_t))(v94 + 16))(v140, v89, v86);
    (*(void (**)(char *, uint64_t, uint64_t))(v139 + 16))(v79, v132, v83);
    if (qword_1000DDE80 != -1) {
      swift_once(&qword_1000DDE80, sub_10004C23C);
    }
    uint64_t v99 = (void *)qword_1000DE7B0;
    sub_100058918(v97, v87, &qword_1000DD6B8);
    p_name = (char **)(&RDSAPISwiftSpeechAnalyzer + 24);
  }

  else
  {
    uint64_t v134 = type metadata accessor for SpeechAnalyzer(0LL);
    uint64_t v100 = *(void (**)(char *, char *, uint64_t))(v88 + 16);
    uint64_t v98 = v86;
    v100(v140, v74, v86);
    (*(void (**)(char *, char *, uint64_t))(v82 + 16))(v79, v81, v83);
    if (qword_1000DDE80 != -1) {
      swift_once(&qword_1000DDE80, sub_10004C23C);
    }
    uint64_t v99 = (void *)qword_1000DE7B0;
    v126(v87, 1LL, 1LL, v127);
  }

  uint64_t v101 = v98;
  id v102 = objc_allocWithZone(v133);
  id v103 = v99;
  id v104 = objc_msgSend(v102, p_name[264]);
  unint64_t v105 = sub_100057E48();
  uint64_t v106 = SpeechAnalyzer.__allocating_init<A>(client:inputSequence:audioFormat:modules:options:restrictedLogging:analysisContext:didChangeVolatileRange:)( v140,  v141,  v103,  &_swiftEmptyArrayStorage,  v87,  1LL,  v104,  0LL,  0LL,  v142,  v105);
  *(void *)&v33[OBJC_IVAR____TtC50com_apple_SpeechRecognitionCore_speechrecognitiond25RDSAPISwiftSpeechAnalyzer__speechAnalyzer] = v106;
  int v107 = (os_log_s *)Logger.logObject.getter(v106);
  os_log_type_t v108 = static os_log_type_t.default.getter();
  BOOL v109 = os_log_type_enabled(v107, v108);
  uint64_t v110 = v143;
  if (v109)
  {
    int v111 = (uint8_t *)swift_slowAlloc(2LL, -1LL);
    *(_WORD *)int v111 = 0;
    _os_log_impl((void *)&_mh_execute_header, v107, v108, "SpeechAnalyzer initialized", v111, 2u);
    swift_slowDealloc(v111, -1LL, -1LL);
  }

  (*(void (**)(char *, uint64_t))(v110 + 8))(v74, v101);
  uint64_t v112 = (objc_class *)type metadata accessor for RDSAPISwiftSpeechAnalyzer(0LL);
  v146.id receiver = v33;
  v146.Class super_class = v112;
  return objc_msgSendSuper2(&v146, p_name[264]);
}

uint64_t type metadata accessor for RDSAPISwiftSpeechAnalyzer(uint64_t a1)
{
  return sub_100057E14(a1, (uint64_t *)&unk_1000DDEF0, (uint64_t)&nominal type descriptor for RDSAPISwiftSpeechAnalyzer);
}

unint64_t sub_100057B38()
{
  unint64_t result = qword_1000DD6F0;
  if (!qword_1000DD6F0)
  {
    uint64_t v1 = objc_opt_self(&OBJC_CLASS___NSString);
    unint64_t result = swift_getObjCClassMetadata(v1);
    atomic_store(result, (unint64_t *)&qword_1000DD6F0);
  }

  return result;
}

uint64_t sub_100057B78()
{
  uint64_t v2 = v0[4];
  uint64_t v3 = v0[5];
  uint64_t v4 = v0[6];
  uint64_t v5 = (void *)swift_task_alloc(dword_1000DD71C);
  *(void *)(v1 + 16) = v5;
  void *v5 = v1;
  v5[1] = sub_100058960;
  return sub_10004E4EC((uint64_t)v5, v6, v7, v2, v3, v4);
}

uint64_t sub_100057BDC(uint64_t result, unint64_t a2)
{
  if (a2 >> 62 != 1)
  {
    if (a2 >> 62 != 2) {
      return result;
    }
    swift_release(result);
  }

  return swift_release(a2 & 0x3FFFFFFFFFFFFFFFLL);
}

uint64_t sub_100057C20()
{
  __int128 v5 = *(_OWORD *)(v0 + 32);
  uint64_t v2 = *(void *)(v0 + 48);
  uint64_t v3 = swift_task_alloc(dword_1000DD72C);
  *(void *)(v1 + 16) = v3;
  *(void *)uint64_t v3 = v1;
  *(void *)(v3 + _Block_object_dispose(va, 8) = sub_100058960;
  *(void *)(v3 + 32) = v2;
  *(_OWORD *)(v3 + 16) = v5;
  return swift_task_switch(sub_10004E880, 0LL, 0LL);
}

uint64_t sub_100057C90(uint64_t result, unint64_t a2)
{
  if (a2 >> 62 != 1)
  {
    if (a2 >> 62 != 2) {
      return result;
    }
    swift_retain(result);
  }

  return swift_retain(a2 & 0x3FFFFFFFFFFFFFFFLL);
}

uint64_t sub_100057CD8()
{
  __int128 v5 = *(_OWORD *)(v0 + 32);
  uint64_t v2 = *(void *)(v0 + 48);
  uint64_t v3 = swift_task_alloc(dword_1000DD73C);
  *(void *)(v1 + 16) = v3;
  *(void *)uint64_t v3 = v1;
  *(void *)(v3 + _Block_object_dispose(va, 8) = sub_100058960;
  *(void *)(v3 + 32) = v2;
  *(_OWORD *)(v3 + 16) = v5;
  return swift_task_switch(sub_10004EBD4, 0LL, 0LL);
}

uint64_t sub_100057D4C()
{
  uint64_t v2 = swift_task_alloc(dword_1000DD74C);
  __int128 v3 = *(_OWORD *)(v0 + 32);
  *(void *)(v1 + 16) = v2;
  *(void *)uint64_t v2 = v1;
  *(void *)(v2 + _Block_object_dispose(va, 8) = sub_100058960;
  *(_OWORD *)(v2 + ++*(void *)(result + 24) = v3;
  return swift_task_switch(sub_10004F1B8, 0LL, 0LL);
}

uint64_t sub_100057DB0()
{
  uint64_t v2 = *(void *)(v0 + 32);
  uint64_t v3 = *(void *)(v0 + 40);
  uint64_t v4 = (void *)swift_task_alloc(dword_1000DD764);
  *(void *)(v1 + 16) = v4;
  *uint64_t v4 = v1;
  v4[1] = sub_100058960;
  return sub_10004FEF4((uint64_t)v4, v5, v6, v2, v3);
}

uint64_t type metadata accessor for AudioStream(uint64_t a1)
{
  return sub_100057E14(a1, (uint64_t *)&unk_1000DDF00, (uint64_t)&nominal type descriptor for AudioStream);
}

uint64_t sub_100057E14(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  uint64_t result = *a2;
  if (!*a2) {
    return swift_getSingletonMetadata(a1, a3);
  }
  return result;
}

unint64_t sub_100057E48()
{
  unint64_t result = qword_1000DD790;
  if (!qword_1000DD790)
  {
    uint64_t v1 = sub_100057E94(&qword_1000DD6C0);
    unint64_t result = swift_getWitnessTable(&protocol conformance descriptor for AsyncStream<A>, v1);
    atomic_store(result, &qword_1000DD790);
  }

  return result;
}

uint64_t sub_100057E94(uint64_t *a1)
{
  uint64_t result = *a1;
  if (result < 0)
  {
    uint64_t result = swift_getTypeByMangledNameInContextInMetadataState2( 255LL,  (char *)a1 + (int)result,  -(result >> 32),  0LL,  0LL);
    *a1 = result;
  }

  return result;
}

uint64_t sub_100057ED8(void *a1)
{
  return sub_100054178(a1);
}

void sub_100057EE0()
{
}

uint64_t sub_100057F14()
{
  return swift_deallocObject(v0, 56LL, 7LL);
}

uint64_t sub_100057F50()
{
  uint64_t v2 = v0[4];
  uint64_t v3 = v0[5];
  uint64_t v4 = v0[6];
  uint64_t v5 = (void *)swift_task_alloc(dword_1000DD79C);
  *(void *)(v1 + 16) = v5;
  void *v5 = v1;
  v5[1] = sub_10004B740;
  return sub_100052EE0((uint64_t)v5, v6, v7, v2, v3, v4);
}

uint64_t sub_100057FB0()
{
  return swift_deallocObject(v0, 17LL, 7LL);
}

uint64_t sub_100057FC0()
{
  return swift_deallocObject(v0, 40LL, 7LL);
}

void *sub_100057FEC(uint64_t a1, uint64_t *a2)
{
  uint64_t v4 = *(void *)(v2 + 16);
  int v5 = *(unsigned __int8 *)(v2 + 24);
  uint64_t v6 = *(void **)(v2 + 32);
  swift_beginAccess(v4 + 16, v11, 0LL, 0LL);
  if ((*(_BYTE *)(v4 + 16) & 1) != 0)
  {
    uint64_t v6 = 0LL;
    uint64_t v7 = 1LL;
    if (v5) {
      uint64_t v7 = 2LL;
    }
  }

  else
  {
    swift_beginAccess(v4 + 16, &v10, 1LL, 0LL);
    *(_BYTE *)(v4 + 16) = 1;
    id v8 = v6;
    uint64_t v7 = 0LL;
  }

  *a2 = v7;
  return v6;
}

uint64_t sub_10005808C(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(a1 + 32) = *(void *)(a2 + 32);
  *(void *)(a1 + 4RDString::RDString((RDString *)&v66, theString, 0) = v2;
  return swift_retain(v2);
}

uint64_t sub_10005809C(uint64_t a1)
{
  return swift_release(*(void *)(a1 + 40));
}

uint64_t sub_1000580A4()
{
  return type metadata accessor for RDSAPISwiftSpeechAnalyzer(0LL);
}

void sub_1000580AC(uint64_t a1)
{
  uint64_t v2 = type metadata accessor for Logger(319LL);
  if (v3 <= 0x3F)
  {
    v16[0] = *(void *)(v2 - 8) + 64LL;
    v16[1] = "\b";
    uint64_t v4 = type metadata accessor for Locale(319LL);
    if (v5 <= 0x3F)
    {
      v16[2] = *(void *)(v4 - 8) + 64LL;
      v16[3] = (char *)&value witness table for Builtin.NativeObject + 64;
      sub_100058260( 319LL,  &qword_1000DD808,  (uint64_t (*)(uint64_t))&type metadata accessor for TaskHint,  (uint64_t (*)(uint64_t, uint64_t))&type metadata accessor for Optional);
      if (v7 <= 0x3F)
      {
        v16[4] = *(void *)(v6 - 8) + 64LL;
        uint64_t v8 = type metadata accessor for Transcriber.ModelOptions(319LL);
        if (v9 <= 0x3F)
        {
          void v16[5] = *(void *)(v8 - 8) + 64LL;
          v16[6] = (char *)&value witness table for Builtin.BridgeObject + 64;
          v16[7] = (char *)&value witness table for Builtin.BridgeObject + 64;
          sub_100058260( 319LL,  &qword_1000DD810,  (uint64_t (*)(uint64_t))&type metadata accessor for AnalysisOptions,  (uint64_t (*)(uint64_t, uint64_t))&type metadata accessor for Optional);
          if (v11 <= 0x3F)
          {
            v16[8] = *(void *)(v10 - 8) + 64LL;
            v16[9] = (char *)&value witness table for Builtin.UnknownObject + 64;
            v16[10] = "\b";
            sub_100058260( 319LL,  &qword_1000DD818,  (uint64_t (*)(uint64_t))&type metadata accessor for AnalyzerInput,  (uint64_t (*)(uint64_t, uint64_t))&type metadata accessor for AsyncStream);
            if (v13 <= 0x3F)
            {
              v16[11] = *(void *)(v12 - 8) + 64LL;
              sub_100058260( 319LL,  &qword_1000DD820,  (uint64_t (*)(uint64_t))&type metadata accessor for AnalyzerInput,  (uint64_t (*)(uint64_t, uint64_t))&type metadata accessor for AsyncStream.Continuation);
              if (v15 <= 0x3F)
              {
                v16[12] = *(void *)(v14 - 8) + 64LL;
                v16[13] = (char *)&value witness table for Builtin.Int64 + 64;
                v16[14] = (char *)&value witness table for Builtin.Int64 + 64;
                swift_updateClassMetadata2(a1, 256LL, 15LL, v16, a1 + 80);
              }
            }
          }
        }
      }
    }
  }

void sub_100058260( uint64_t a1, unint64_t *a2, uint64_t (*a3)(uint64_t), uint64_t (*a4)(uint64_t, uint64_t))
{
  if (!*a2)
  {
    uint64_t v7 = a3(255LL);
    unint64_t v8 = a4(a1, v7);
    if (!v9) {
      atomic_store(v8, a2);
    }
  }

uint64_t sub_1000582B8()
{
  return type metadata accessor for AudioStream(0LL);
}

void sub_1000582C0(uint64_t a1)
{
  if (v3 <= 0x3F)
  {
    v6[0] = *(void *)(v2 - 8) + 64LL;
    sub_100058260( 319LL,  &qword_1000DD820,  (uint64_t (*)(uint64_t))&type metadata accessor for AnalyzerInput,  (uint64_t (*)(uint64_t, uint64_t))&type metadata accessor for AsyncStream.Continuation);
    if (v5 <= 0x3F)
    {
      v6[1] = *(void *)(v4 - 8) + 64LL;
      _DWORD v6[2] = "\b";
      v6[3] = "\b";
      swift_updateClassMetadata2(a1, 256LL, 4LL, v6, a1 + 80);
    }
  }

uint64_t sub_100058388()
{
  return swift_deallocObject(v0, 48LL, 7LL);
}

uint64_t sub_1000583C0(uint64_t result, unint64_t a2)
{
  if (a2 >> 60 != 15) {
    return sub_100057BDC(result, a2);
  }
  return result;
}

uint64_t sub_1000583D8()
{
  sub_100057BDC(*(void *)(v0 + 40), *(void *)(v0 + 48));
  return swift_deallocObject(v0, 56LL, 7LL);
}

uint64_t sub_100058410()
{
  swift_bridgeObjectRelease(*(void *)(v0 + 48), v1);
  return swift_deallocObject(v0, 56LL, 7LL);
}

uint64_t sub_100058444()
{
  return swift_deallocObject(v0, 40LL, 7LL);
}

uint64_t sub_100058470()
{
  char v2 = *(_BYTE *)(v0 + 16);
  uint64_t v4 = *(void **)(v0 + 24);
  unint64_t v3 = *(void **)(v0 + 32);
  unint64_t v5 = (void *)swift_task_alloc(dword_1000DD94C);
  *(void *)(v1 + 16) = v5;
  void *v5 = v1;
  v5[1] = sub_10004B740;
  return ((uint64_t (*)(char, void *, void *))((char *)&dword_1000DD948 + dword_1000DD948))(v2, v4, v3);
}

uint64_t sub_1000584E0()
{
  uint64_t v2 = v0[2];
  uint64_t v3 = v0[3];
  uint64_t v4 = (int *)v0[4];
  unint64_t v5 = (void *)swift_task_alloc(dword_1000DD95C);
  *(void *)(v1 + 16) = v5;
  void *v5 = v1;
  v5[1] = sub_100058960;
  return ((uint64_t (*)(uint64_t, uint64_t, int *))((char *)&dword_1000DD958 + dword_1000DD958))(v2, v3, v4);
}

uint64_t sub_10005855C(uint64_t a1)
{
  uint64_t v4 = v1[2];
  uint64_t v5 = v1[3];
  uint64_t v6 = (int *)v1[4];
  uint64_t v7 = (void *)swift_task_alloc(dword_1000DD96C);
  *(void *)(v2 + 16) = v7;
  *uint64_t v7 = v2;
  v7[1] = sub_100058960;
  return ((uint64_t (*)(uint64_t, uint64_t, uint64_t, int *))((char *)&dword_1000DD968 + dword_1000DD968))( a1,  v4,  v5,  v6);
}

uint64_t sub_1000585E0(uint64_t a1)
{
  uint64_t v4 = *(int **)(v1 + 16);
  uint64_t v5 = (void *)swift_task_alloc(dword_1000DD97C);
  *(void *)(v2 + 16) = v5;
  void *v5 = v2;
  v5[1] = sub_100058960;
  return ((uint64_t (*)(uint64_t, int *))((char *)&dword_1000DD978 + dword_1000DD978))(a1, v4);
}

uint64_t sub_100058650()
{
  _Block_release(*(const void **)(v0 + 24));
  return swift_deallocObject(v0, 40LL, 7LL);
}

uint64_t sub_100058684()
{
  uint64_t v2 = (void *)v0[2];
  uint64_t v3 = (void *)v0[3];
  uint64_t v4 = (void *)v0[4];
  uint64_t v5 = (void *)swift_task_alloc(dword_1000DD98C);
  *(void *)(v1 + 16) = v5;
  void *v5 = v1;
  v5[1] = sub_100058960;
  return ((uint64_t (*)(void *, void *, void *))((char *)&dword_1000DD988 + dword_1000DD988))(v2, v3, v4);
}

uint64_t sub_1000586F8()
{
  return swift_deallocObject(v0, 32LL, 7LL);
}

uint64_t sub_100058724()
{
  uint64_t v2 = *(const void **)(v0 + 16);
  uint64_t v3 = *(void **)(v0 + 24);
  uint64_t v4 = (void *)swift_task_alloc(dword_1000DD9AC);
  *(void *)(v1 + 16) = v4;
  *uint64_t v4 = v1;
  v4[1] = sub_100058960;
  return ((uint64_t (*)(const void *, void *))((char *)&dword_1000DD9A8 + dword_1000DD9A8))(v2, v3);
}

uint64_t sub_100058790()
{
  return swift_deallocObject(v0, 48LL, 7LL);
}

unint64_t sub_1000587BC()
{
  unint64_t result = qword_1000DDA18;
  if (!qword_1000DDA18)
  {
    unint64_t result = swift_getWitnessTable(&protocol conformance descriptor for String, &type metadata for String);
    atomic_store(result, (unint64_t *)&qword_1000DDA18);
  }

  return result;
}

uint64_t sub_100058800()
{
  return swift_deallocObject(v0, 32LL, 7LL);
}

uint64_t sub_100058824(uint64_t a1)
{
  uint64_t v4 = *(int **)(v1 + 16);
  uint64_t v5 = (void *)swift_task_alloc(dword_1000DD68C);
  *(void *)(v2 + 16) = v5;
  void *v5 = v2;
  v5[1] = sub_100058960;
  return ((uint64_t (*)(uint64_t, int *))((char *)&dword_1000DD688 + dword_1000DD688))(a1, v4);
}

uint64_t sub_100058894(unint64_t *a1, uint64_t (*a2)(uint64_t), uint64_t a3)
{
  uint64_t result = *a1;
  if (!result)
  {
    uint64_t v6 = a2(255LL);
    uint64_t result = swift_getWitnessTable(a3, v6);
    atomic_store(result, a1);
  }

  return result;
}

uint64_t sub_1000588D4(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v5 = sub_10004B5C0(a3);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v5 - 8) + 40LL))(a2, a1, v5);
  return a2;
}

uint64_t sub_100058918(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v5 = sub_10004B5C0(a3);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v5 - 8) + 16LL))(a2, a1, v5);
  return a2;
}

void sub_100058978(void *a1@<X0>, void *a2@<X1>, void *a3@<X8>)
{
  if (a1[2] | a2[2])
  {
    uint64_t v7 = operator new(0x28uLL);
    sub_10005D1F4(v7, 1LL);
    sub_10005D498((uint64_t)v7, 0);
    sub_10005D554((uint64_t)v7, 0, 0.0);
    sub_10000A2DC(buf, "<eps>");
    sub_10000A2DC(__p, off_1000DDA60[0]);
    sub_10005D67C((uint64_t)v7, 0, 0, (uint64_t)buf, (uint64_t)__p, 105.0);
    if (v22 < 0) {
      operator delete(__p[0]);
    }
    if (v24 < 0) {
      operator delete(*(void **)buf);
    }
    uint64_t v10 = (void *)*a1;
    unint64_t v8 = a1 + 1;
    uint64_t v9 = v10;
    if (v10 != v8)
    {
      do
      {
        sub_10005D67C((uint64_t)v7, 0, 0, (uint64_t)(v9 + 4), (uint64_t)(v9 + 4), 0.0);
        sub_10000A2DC(buf, off_1000DDA68);
        sub_10005D67C((uint64_t)v7, 0, 0, (uint64_t)(v9 + 4), (uint64_t)buf, 105.0);
        if (v24 < 0) {
          operator delete(*(void **)buf);
        }
        unint64_t v11 = (void *)v9[1];
        if (v11)
        {
          do
          {
            uint64_t v12 = v11;
            unint64_t v11 = (void *)*v11;
          }

          while (v11);
        }

        else
        {
          do
          {
            uint64_t v12 = (void *)v9[2];
            BOOL v13 = *v12 == (void)v9;
            uint64_t v9 = v12;
          }

          while (!v13);
        }

        uint64_t v9 = v12;
      }

      while (v12 != v8);
    }

    uint64_t v16 = (void *)*a2;
    uint64_t v14 = a2 + 1;
    unint64_t v15 = v16;
    if (v16 != v14)
    {
      do
      {
        sub_10005D67C((uint64_t)v7, 0, 0, (uint64_t)(v15 + 4), (uint64_t)(v15 + 4), 0.0);
        uint64_t v17 = (void *)v15[1];
        if (v17)
        {
          do
          {
            uint64_t v18 = v17;
            uint64_t v17 = (void *)*v17;
          }

          while (v17);
        }

        else
        {
          do
          {
            uint64_t v18 = (void *)v15[2];
            BOOL v13 = *v18 == (void)v15;
            unint64_t v15 = v18;
          }

          while (!v13);
        }

        unint64_t v15 = v18;
      }

      while (v18 != v14);
    }

    sub_10005D628((uint64_t)v7);
    uint64_t v19 = v7[1];
    v7[1] = 0LL;
    *a3 = v19;
    uint64_t v20 = sub_1000292E0(v7);
    operator delete(v20);
  }

  else
  {
    uint64_t v4 = (os_log_s *)sub_1000A39A8();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_ERROR,  "cmdp_edit_distance::editfst1 : EMPTY Symbol set",  buf,  2u);
    }

    *a3 = 0LL;
  }

void sub_100058BD0( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20, char a21)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  if (a21 < 0) {
    operator delete(a16);
  }
  uint64_t v23 = sub_1000292E0(v21);
  operator delete(v23);
  _Unwind_Resume(a1);
}

void sub_100058C38(void *a1@<X0>, void *a2@<X8>)
{
  v3[0] = 0LL;
  v3[1] = 0LL;
  uint64_t v2 = v3;
  sub_100058978(a1, &v2, a2);
  sub_100018678((uint64_t)&v2, v3[0]);
}

void sub_100058C7C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, char *a11)
{
}

void sub_100058C94(void *a1@<X0>, void *a2@<X1>, void *a3@<X2>, void *a4@<X8>)
{
  if (a1[2])
  {
    unint64_t v8 = operator new(0x28uLL);
    sub_10005D1F4(v8, 1LL);
    sub_10005D498((uint64_t)v8, 0);
    sub_10005D554((uint64_t)v8, 0, 0.0);
    sub_10005D554((uint64_t)v8, 1, 0.0);
    sub_10000A2DC(buf, off_1000DDA68);
    sub_10000A2DC(__p, "<eps>");
    sub_10005D67C((uint64_t)v8, 0, 1, (uint64_t)buf, (uint64_t)__p, 105.0);
    if (v29 < 0) {
      operator delete(__p[0]);
    }
    if (v31 < 0) {
      operator delete(*(void **)buf);
    }
    unint64_t v11 = (void *)*a1;
    uint64_t v9 = a1 + 1;
    uint64_t v10 = v11;
    if (v11 != v9)
    {
      do
      {
        sub_10005D67C((uint64_t)v8, 0, 0, (uint64_t)(v10 + 4), (uint64_t)(v10 + 4), 0.0);
        sub_10005D67C((uint64_t)v8, 1, 0, (uint64_t)(v10 + 4), (uint64_t)(v10 + 4), 0.0);
        sub_10000A2DC(buf, off_1000DDA60[0]);
        sub_10005D67C((uint64_t)v8, 0, 1, (uint64_t)buf, (uint64_t)(v10 + 4), 105.0);
        if (v31 < 0) {
          operator delete(*(void **)buf);
        }
        uint64_t v12 = (void *)v10[1];
        if (v12)
        {
          do
          {
            BOOL v13 = v12;
            uint64_t v12 = (void *)*v12;
          }

          while (v12);
        }

        else
        {
          do
          {
            BOOL v13 = (void *)v10[2];
            BOOL v14 = *v13 == (void)v10;
            uint64_t v10 = v13;
          }

          while (!v14);
        }

        uint64_t v10 = v13;
      }

      while (v13 != v9);
    }

    uint64_t v17 = (void *)*a2;
    unint64_t v15 = a2 + 1;
    uint64_t v16 = v17;
    if (v17 != v15)
    {
      do
      {
        sub_10005D67C((uint64_t)v8, 0, 0, (uint64_t)(v16 + 4), (uint64_t)(v16 + 4), 0.0);
        sub_10005D67C((uint64_t)v8, 1, 0, (uint64_t)(v16 + 4), (uint64_t)(v16 + 4), 0.0);
        uint64_t v18 = (void *)v16[1];
        if (v18)
        {
          do
          {
            uint64_t v19 = v18;
            uint64_t v18 = (void *)*v18;
          }

          while (v18);
        }

        else
        {
          do
          {
            uint64_t v19 = (void *)v16[2];
            BOOL v14 = *v19 == (void)v16;
            uint64_t v16 = v19;
          }

          while (!v14);
        }

        uint64_t v16 = v19;
      }

      while (v19 != v15);
    }

    char v22 = (void *)*a3;
    uint64_t v20 = a3 + 1;
    uint64_t v21 = v22;
    if (v22 != v20)
    {
      do
      {
        sub_10005D67C((uint64_t)v8, 0, 0, (uint64_t)(v21 + 4), (uint64_t)(v21 + 4), 0.0);
        uint64_t v23 = (void *)v21[1];
        if (v23)
        {
          do
          {
            char v24 = v23;
            uint64_t v23 = (void *)*v23;
          }

          while (v23);
        }

        else
        {
          do
          {
            char v24 = (void *)v21[2];
            BOOL v14 = *v24 == (void)v21;
            uint64_t v21 = v24;
          }

          while (!v14);
        }

        uint64_t v21 = v24;
      }

      while (v24 != v20);
    }

    sub_10005D628((uint64_t)v8);
    uint64_t v25 = v8[1];
    v8[1] = 0LL;
    *a4 = v25;
    int64_t v26 = sub_1000292E0(v8);
    operator delete(v26);
  }

  else
  {
    uint64_t v27 = (os_log_s *)sub_1000A39A8();
    if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v27,  OS_LOG_TYPE_ERROR,  "cmdp_edit_distance::editfst2 : EMPTY Symbol set",  buf,  2u);
    }

    *a4 = 0LL;
  }

void sub_100058F94( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20, char a21)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  if (a21 < 0) {
    operator delete(a16);
  }
  uint64_t v23 = sub_1000292E0(v21);
  operator delete(v23);
  _Unwind_Resume(a1);
}

void sub_100059000(void *a1@<X0>, void *a2@<X8>)
{
  v5[0] = 0LL;
  v5[1] = 0LL;
  v3[1] = 0LL;
  uint64_t v4 = v5;
  uint64_t v2 = v3;
  v3[0] = 0LL;
  sub_100058C94(a1, &v4, &v2, a2);
  sub_100018678((uint64_t)&v2, v3[0]);
  sub_100018678((uint64_t)&v4, v5[0]);
}

void sub_100059060( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char *a10, uint64_t a11, char a12, char *a13)
{
}

void sub_100059084(uint64_t a1@<X0>, void *a2@<X1>, void *a3@<X2>, void *a4@<X3>, uint64_t *a5@<X8>)
{
  block[0] = _NSConcreteStackBlock;
  block[1] = 0x40000000LL;
  block[2] = sub_100059860;
  block[3] = &unk_1000D0528;
  void block[4] = a1;
  if (qword_1000DDF18 != -1) {
    dispatch_once(&qword_1000DDF18, block);
  }
  if (qword_1000DDF10)
  {
    uint64_t v10 = (*(uint64_t (**)(uint64_t, void))(*(void *)qword_1000DDF10 + 72LL))(qword_1000DDF10, 0LL);
    *a5 = v10;
    uint64_t v11 = (*(uint64_t (**)(uint64_t))(*(void *)v10 + 16LL))(v10);
    uint64_t v12 = (*(uint64_t (**)(uint64_t))(*(void *)v10 + 96LL))(v10);
    uint64_t v13 = (*(uint64_t (**)(uint64_t))(*(void *)v12 + 16LL))(v12);
    uint64_t v14 = (*(uint64_t (**)(uint64_t))(*(void *)v10 + 104LL))(v10);
    uint64_t v15 = (*(uint64_t (**)(uint64_t))(*(void *)v14 + 16LL))(v14);
    uint64_t v18 = (void *)*a2;
    uint64_t v16 = a2 + 1;
    uint64_t v17 = v18;
    if (v18 != v16)
    {
      do
      {
        int v19 = (*(uint64_t (**)(uint64_t, void *))(*(void *)v13 + 32LL))(v13, v17 + 4);
        int v20 = (*(uint64_t (**)(uint64_t, void *))(*(void *)v15 + 32LL))(v15, v17 + 4);
        uint64_t v10 = *a5;
        *(_DWORD *)std::string __p = v19;
        *(_DWORD *)&__p[4] = v20;
        *(_DWORD *)&__p[8] = 0;
        int v65 = v11;
        (*(void (**)(uint64_t, uint64_t, _BYTE *))(*(void *)v10 + 184LL))(v10, v11, __p);
        uint64_t v21 = (void *)v17[1];
        if (v21)
        {
          do
          {
            char v22 = v21;
            uint64_t v21 = (void *)*v21;
          }

          while (v21);
        }

        else
        {
          do
          {
            char v22 = (void *)v17[2];
            BOOL v23 = *v22 == (void)v17;
            uint64_t v17 = v22;
          }

          while (!v23);
        }

        uint64_t v17 = v22;
      }

      while (v22 != v16);
    }

    int64_t v26 = (void *)*a3;
    char v24 = a3 + 1;
    uint64_t v25 = v26;
    if (v26 != v24)
    {
      do
      {
        int v27 = (*(uint64_t (**)(uint64_t, void *))(*(void *)v13 + 32LL))(v13, v25 + 4);
        int v28 = (*(uint64_t (**)(uint64_t, void *))(*(void *)v15 + 32LL))(v15, v25 + 4);
        uint64_t v10 = *a5;
        *(_DWORD *)std::string __p = v27;
        *(_DWORD *)&__p[4] = v28;
        *(_DWORD *)&__p[8] = 0;
        int v65 = v11;
        (*(void (**)(uint64_t, uint64_t, _BYTE *))(*(void *)v10 + 184LL))(v10, v11, __p);
        char v29 = (void *)v25[1];
        if (v29)
        {
          do
          {
            uint64_t v30 = v29;
            char v29 = (void *)*v29;
          }

          while (v29);
        }

        else
        {
          do
          {
            uint64_t v30 = (void *)v25[2];
            BOOL v23 = *v30 == (void)v25;
            uint64_t v25 = v30;
          }

          while (!v23);
        }

        uint64_t v25 = v30;
      }

      while (v30 != v24);
    }

    uint64_t v33 = (void *)*a4;
    char v31 = a4 + 1;
    uint64_t v32 = v33;
    if (v33 != v31)
    {
      do
      {
        int v34 = (*(uint64_t (**)(uint64_t, void *))(*(void *)v13 + 32LL))(v13, v32 + 4);
        int v35 = (*(uint64_t (**)(uint64_t, void *))(*(void *)v15 + 32LL))(v15, v32 + 4);
        uint64_t v10 = *a5;
        *(_DWORD *)std::string __p = v34;
        *(_DWORD *)&__p[4] = v35;
        *(_DWORD *)&__p[8] = 0;
        int v65 = v11;
        (*(void (**)(uint64_t, uint64_t, _BYTE *))(*(void *)v10 + 184LL))(v10, v11, __p);
        unint64_t v36 = (void *)v32[1];
        if (v36)
        {
          do
          {
            BOOL v37 = v36;
            unint64_t v36 = (void *)*v36;
          }

          while (v36);
        }

        else
        {
          do
          {
            BOOL v37 = (void *)v32[2];
            BOOL v23 = *v37 == (void)v32;
            uint64_t v32 = v37;
          }

          while (!v23);
        }

        uint64_t v32 = v37;
      }

      while (v37 != v31);
    }

    sub_10000A2DC(__p, off_1000DDA68);
    int v38 = (*(uint64_t (**)(uint64_t, _BYTE *))(*(void *)v13 + 32LL))(v13, __p);
    if (v66 < 0) {
      operator delete(*(void **)__p);
    }
    sub_10000A2DC(__p, off_1000DDA68);
    int v39 = (*(uint64_t (**)(uint64_t, _BYTE *))(*(void *)v15 + 32LL))(v15, __p);
    if (v66 < 0) {
      operator delete(*(void **)__p);
    }
    *(_DWORD *)std::string __p = v38;
    *(_DWORD *)&__p[4] = v39;
    *(_DWORD *)&__p[8] = 0;
    int v65 = v11;
    (*(void (**)(uint64_t, uint64_t, _BYTE *))(*(void *)v10 + 184LL))(v10, v11, __p);
    sub_10000A2DC(__p, off_1000DDA60[0]);
    int v40 = (*(uint64_t (**)(uint64_t, _BYTE *))(*(void *)v13 + 32LL))(v13, __p);
    if (v66 < 0) {
      operator delete(*(void **)__p);
    }
    sub_10000A2DC(__p, off_1000DDA60[0]);
    int v41 = (*(uint64_t (**)(uint64_t, _BYTE *))(*(void *)v15 + 32LL))(v15, __p);
    if (v66 < 0) {
      operator delete(*(void **)__p);
    }
    *(_DWORD *)std::string __p = v40;
    *(_DWORD *)&__p[4] = v41;
    *(_DWORD *)&__p[8] = 0;
    int v65 = v11;
    (*(void (**)(uint64_t, uint64_t, _BYTE *))(*(void *)v10 + 184LL))(v10, v11, __p);
    (*(void (**)(uint64_t, uint64_t))(*(void *)v10 + 256LL))(v10, v13);
    (*(void (**)(uint64_t, uint64_t))(*(void *)v10 + 264LL))(v10, v15);
    (*(void (**)(uint64_t))(*(void *)v13 + 8LL))(v13);
    (*(void (**)(uint64_t))(*(void *)v15 + 8LL))(v15);
  }

  else
  {
    int64_t v42 = (os_log_s *)sub_1000A39A8();
    if (os_log_type_enabled(v42, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)std::string __p = 136315138;
      *(void *)&__p[4] = a1;
      _os_log_impl((void *)&_mh_execute_header, v42, OS_LOG_TYPE_ERROR, "Unable to read synonyms FST for %s", __p, 0xCu);
    }

    uint64_t v43 = operator new(0x28uLL);
    sub_10005D1F4(v43, 1LL);
    sub_10005D498((uint64_t)v43, 0);
    sub_10005D554((uint64_t)v43, 0, 0.0);
    uint64_t v46 = (void *)*a2;
    uint64_t v45 = a2 + 1;
    id v44 = v46;
    if (v46 != v45)
    {
      do
      {
        sub_10005D67C((uint64_t)v43, 0, 0, (uint64_t)(v44 + 4), (uint64_t)(v44 + 4), 0.0);
        uint64_t v47 = (void *)v44[1];
        if (v47)
        {
          do
          {
            uint64_t v48 = v47;
            uint64_t v47 = (void *)*v47;
          }

          while (v47);
        }

        else
        {
          do
          {
            uint64_t v48 = (void *)v44[2];
            BOOL v23 = *v48 == (void)v44;
            id v44 = v48;
          }

          while (!v23);
        }

        id v44 = v48;
      }

      while (v48 != v45);
    }

    uint64_t v51 = (void *)*a3;
    uint64_t v50 = a3 + 1;
    uint64_t v49 = v51;
    if (v51 != v50)
    {
      do
      {
        sub_10005D67C((uint64_t)v43, 0, 0, (uint64_t)(v49 + 4), (uint64_t)(v49 + 4), 0.0);
        uint64_t v52 = (void *)v49[1];
        if (v52)
        {
          do
          {
            uint64_t v53 = v52;
            uint64_t v52 = (void *)*v52;
          }

          while (v52);
        }

        else
        {
          do
          {
            uint64_t v53 = (void *)v49[2];
            BOOL v23 = *v53 == (void)v49;
            uint64_t v49 = v53;
          }

          while (!v23);
        }

        uint64_t v49 = v53;
      }

      while (v53 != v50);
    }

    uint64_t v56 = (void *)*a4;
    uint64_t v54 = a4 + 1;
    id v55 = v56;
    if (v56 != v54)
    {
      do
      {
        sub_10005D67C((uint64_t)v43, 0, 0, (uint64_t)(v55 + 4), (uint64_t)(v55 + 4), 0.0);
        uint64_t v57 = (void *)v55[1];
        if (v57)
        {
          do
          {
            uint64_t v58 = v57;
            uint64_t v57 = (void *)*v57;
          }

          while (v57);
        }

        else
        {
          do
          {
            uint64_t v58 = (void *)v55[2];
            BOOL v23 = *v58 == (void)v55;
            id v55 = v58;
          }

          while (!v23);
        }

        id v55 = v58;
      }

      while (v58 != v54);
    }

    sub_10000A2DC(__p, off_1000DDA68);
    sub_10000A2DC(v61, off_1000DDA68);
    sub_10005D67C((uint64_t)v43, 0, 0, (uint64_t)__p, (uint64_t)v61, 0.0);
    if (v62 < 0) {
      operator delete(v61[0]);
    }
    if (v66 < 0) {
      operator delete(*(void **)__p);
    }
    sub_10000A2DC(__p, off_1000DDA60[0]);
    sub_10000A2DC(v61, off_1000DDA60[0]);
    sub_10005D67C((uint64_t)v43, 0, 0, (uint64_t)__p, (uint64_t)v61, 0.0);
    if (v62 < 0) {
      operator delete(v61[0]);
    }
    if (v66 < 0) {
      operator delete(*(void **)__p);
    }
    sub_10005D628((uint64_t)v43);
    uint64_t v59 = v43[1];
    v43[1] = 0LL;
    *a5 = v59;
    uint64_t v60 = sub_1000292E0(v43);
    operator delete(v60);
  }

void sub_100059760( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *a20, uint64_t a21, int a22, __int16 a23, char a24, char a25)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if (a25 < 0) {
    operator delete(a20);
  }
  int v27 = sub_1000292E0(v25);
  operator delete(v27);
  _Unwind_Resume(a1);
}

void sub_100059860(uint64_t a1)
{
  uint64_t v1 = *(const char **)(a1 + 32);
  MainBundle = CFBundleGetMainBundle();
  uint64_t v3 = CFBundleCopyResourceURL(MainBundle, @"CommandProcessingResources.bundle", 0LL, 0LL);
  if (v3)
  {
    uint64_t v4 = v3;
    uint64_t v5 = CFBundleCreate(kCFAllocatorDefault, v3);
    CFRelease(v4);
    uint64_t v6 = CFStringCreateWithCString(0LL, v1, 0x8000100u);
    CanonicalLocaleIdentifierFromString = CFLocaleCreateCanonicalLocaleIdentifierFromString(0LL, v6);
    CFRelease(v6);
    if (CFStringHasPrefix(CanonicalLocaleIdentifierFromString, @"en")) {
      unint64_t v8 = @"en";
    }
    else {
      unint64_t v8 = CanonicalLocaleIdentifierFromString;
    }
    CFMutableStringRef MutableCopy = CFStringCreateMutableCopy(0LL, 0LL, v8);
    CFStringAppend(MutableCopy, @"_");
    CFStringAppend(MutableCopy, @"synonym.fst");
    uint64_t v12 = CFBundleCopyResourceURL(v5, MutableCopy, 0LL, 0LL);
    CFRelease(CanonicalLocaleIdentifierFromString);
    CFRelease(MutableCopy);
    CFRelease(v5);
    if (v12)
    {
      uint64_t v13 = CFURLGetString(v12);
      CFMutableStringRef v14 = CFStringCreateMutableCopy(0LL, 0LL, v13);
      CFRelease(v12);
      v20.id location = 0LL;
      v20.size_t length = 7LL;
      CFStringDelete(v14, v20);
      sub_100097D98(v14, 0, __p);
      CFRelease(v14);
      goto LABEL_13;
    }

    uint64_t v9 = (os_log_s *)sub_1000A39A8();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)std::string buf = 0;
      uint64_t v10 = "cmdp_edit_distance::synonymDictionary : Unable to access synonym URL";
      goto LABEL_11;
    }
  }

  else
  {
    uint64_t v9 = (os_log_s *)sub_1000A39A8();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)std::string buf = 0;
      uint64_t v10 = "cmdp_edit_distance::synonymDictionary : Unable to access resource URL";
LABEL_11:
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, v10, buf, 2u);
    }
  }

  sub_10000A2DC(__p, "");
LABEL_13:
  unint64_t v15 = v18;
  if ((v18 & 0x80u) != 0) {
    unint64_t v15 = (unint64_t)__p[1];
  }
  if (v15)
  {
    qword_1000DDF10 = (uint64_t)sub_100059AEC((uint64_t)__p);
  }

  else
  {
    uint64_t v16 = (os_log_s *)sub_1000A39A8();
    if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_ERROR, "Empty synonym Plist FST", buf, 2u);
    }
  }

void sub_100059AC8( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void *sub_100059AEC(uint64_t a1)
{
  uint64_t v1 = sub_100059C54(a1);
  if (!v1) {
    return 0LL;
  }
  uint64_t v2 = (uint64_t)v1;
  uint64_t v3 = operator new(0x18uLL);
  sub_10005AD1C(&v8, v2);
  sub_10005ADF0(v3, &v8);
  uint64_t v4 = v9;
  if (v9)
  {
    p_shared_owners = (unint64_t *)&v9->__shared_owners_;
    do
      unint64_t v6 = __ldaxr(p_shared_owners);
    while (__stlxr(v6 - 1, p_shared_owners));
    if (!v6)
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }

  return v3;
}

void sub_100059B80( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_100059BA4(uint64_t a1@<X0>, void *a2@<X1>, uint64_t *a3@<X8>)
{
  v6[0] = 0LL;
  v6[1] = 0LL;
  v4[1] = 0LL;
  uint64_t v5 = v6;
  uint64_t v3 = v4;
  v4[0] = 0LL;
  sub_100059084(a1, a2, &v5, &v3, a3);
  sub_100018678((uint64_t)&v3, v4[0]);
  sub_100018678((uint64_t)&v5, v6[0]);
}

void sub_100059C04( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char *a10, uint64_t a11, char a12, char *a13)
{
}

float sub_100059C28(int a1, int a2, int a3, float a4)
{
  return (float)(a4 - (float)(-100 * (a1 - a2))) / (float)(210 * (a1 - a3));
}

void *sub_100059C54(uint64_t a1)
{
  uint64_t v1 = *(unsigned __int8 *)(a1 + 23);
  if ((v1 & 0x80u) != 0LL) {
    uint64_t v1 = *(void *)(a1 + 8);
  }
  if (v1)
  {
    sub_100059EB8((void (__cdecl ***)(std::ifstream *__hidden))__dst, (uint64_t *)a1, 12);
    if ((__dst[1].__r_.__value_.__s.__data_[*(void *)(__dst[0].__r_.__value_.__r.__words[0] - 24) + 8] & 5) != 0)
    {
      sub_10000A2DC(__p, "ERROR");
      sub_10002A9EC(&v10, (uint64_t)__p);
      uint64_t v3 = sub_10002A6A4(&std::cerr, (uint64_t)"ExpandedFst::Read: Can't open file: ", 36LL);
      int v4 = *(char *)(a1 + 23);
      if (v4 >= 0) {
        uint64_t v5 = a1;
      }
      else {
        uint64_t v5 = *(void *)a1;
      }
      if (v4 >= 0) {
        uint64_t v6 = *(unsigned __int8 *)(a1 + 23);
      }
      else {
        uint64_t v6 = *(void *)(a1 + 8);
      }
      sub_10002A6A4(v3, v5, v6);
      sub_10002AA94(&v10);
      uint64_t v7 = 0LL;
    }

    else
    {
      sub_1000A43B0(__p);
      uint64_t v7 = sub_100059FD0(__dst, __p);
    }

    *(std::string::size_type *)((char *)__dst[0].__r_.__value_.__r.__words
    std::filebuf::~filebuf(&__dst[0].__r_.__value_.__r.__words[2]);
    std::ios::~ios(&v12);
  }

  else
  {
    sub_10000A2DC(__p, "standard input");
    sub_1000A43B0(__dst);
    uint64_t v7 = sub_100059FD0(&std::cin, __dst);
  }

  return v7;
}

void sub_100059E3C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, int a20, __int16 a21, char a22, char a23, void *a24, uint64_t a25, int a26, __int16 a27, char a28, char a29)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  sub_10005A3D8(&a24);
  _Unwind_Resume(a1);
}

void (__cdecl ***sub_100059EB8( void (__cdecl ***a1)(std::ifstream *__hidden this), uint64_t *a2, int a3))(std::ifstream *__hidden this)
{
  uint64_t v6 = a1 + 2;
  *a1 = v7;
  *(void *)((char *)*(v7 - 3) + (void)a1) = v8;
  a1[1] = 0LL;
  uint64_t v9 = (std::ios_base *)((char *)*(*a1 - 3) + (void)a1);
  std::ios_base::init(v9, a1 + 2);
  v9[1].__vftable = 0LL;
  v9[1].__fmtflags_ = -1;
  std::filebuf::basic_filebuf(v6);
  else {
    BOOL v10 = (uint64_t *)*a2;
  }
  if (!std::filebuf::open(v6, v10, a3 | 8u)) {
    std::ios_base::clear( (std::ios_base *)((char *)*(*a1 - 3) + (void)a1),  *(_DWORD *)((char *)*(*a1 - 3) + (void)a1 + 32) | 4);
  }
  return a1;
}

void sub_100059F98(_Unwind_Exception *a1)
{
}

void *sub_100059FD0(void *a1, const std::string *a2)
{
  int v4 = operator new(0x58uLL);
  sub_10002DE44((uint64_t)v4);
  __int128 v35 = 0u;
  __int128 v36 = 0u;
  *(_OWORD *)uint64_t v33 = 0u;
  *(_OWORD *)int v34 = 0u;
  uint64_t v38 = 0LL;
  uint64_t v39 = 0LL;
  uint64_t v37 = -1LL;
  if ((sub_10005A430((uint64_t)v4, a1, a2, 2, (uint64_t)v32) & 1) != 0)
  {
    uint64_t v5 = v38;
    *((_DWORD *)v4 + 2RDString::RDString((RDString *)&v66, theString, 0) = v37;
    BOOL v23 = a2;
    if (v5 == -1 || (sub_10002D348((void **)v4 + 7, (int)v5), uint64_t v6 = v38, v38 == -1) || v38 >= 1)
    {
      uint64_t v7 = 0LL;
      uint64_t v9 = a1 + 4;
      while (1)
      {
        BOOL v10 = (void *)std::istream::read(a1, &v31, 4LL);
        if ((*((_BYTE *)v10 + *(void *)(*v10 - 24LL) + 32) & 5) != 0) {
          break;
        }
        sub_10002D0E8(v4);
        **(_DWORD **)(v4[7] + 8 * v7) = v31;
        std::istream::read(a1, &v30, 8LL);
        if ((*((_BYTE *)v9 + *(void *)(*a1 - 24LL)) & 5) != 0)
        {
          sub_10000A2DC(__p, "ERROR");
          sub_10002A9EC((BOOL *)&v25, (uint64_t)__p);
          uint64_t v17 = sub_10002A6A4(&std::cerr, (uint64_t)"VectorFst::Read: Read failed: ", 30LL);
          int size = (char)v23->__r_.__value_.__s.__size_;
          if (size >= 0) {
            uint64_t v19 = (uint64_t)v23;
          }
          else {
            uint64_t v19 = v23->__r_.__value_.__r.__words[0];
          }
          if (size >= 0) {
            uint64_t v20 = v23->__r_.__value_.__s.__size_;
          }
          else {
            uint64_t v20 = v23->__r_.__value_.__l.__size_;
          }
          goto LABEL_39;
        }

        sub_10002D3DC((uint64_t *)(*(void *)(v4[7] + 8 * v7) + 24LL), v30);
        if (v30 >= 1)
        {
          uint64_t v11 = 0LL;
          while (1)
          {
            std::istream::read(a1, &v25, 4LL);
            std::istream::read(a1, &v26, 4LL);
            std::istream::read(a1, &v27, 4LL);
            std::istream::read(a1, (char *)&v27 + 4, 4LL);
            if ((*((_BYTE *)v9 + *(void *)(*a1 - 24LL)) & 5) != 0) {
              break;
            }
            sub_10002D538(*(void **)(v4[7] + 8 * v7), &v25);
            if (++v11 >= v30) {
              goto LABEL_15;
            }
          }

          sub_10000A2DC(__p, "ERROR");
          sub_10002A9EC(&v24, (uint64_t)__p);
          uint64_t v12 = sub_10002A6A4(&std::cerr, (uint64_t)"VectorFst::Read: Read failed: ", 30LL);
          int v13 = (char)v23->__r_.__value_.__s.__size_;
          if (v13 >= 0) {
            uint64_t v14 = (uint64_t)v23;
          }
          else {
            uint64_t v14 = v23->__r_.__value_.__r.__words[0];
          }
          if (v13 >= 0) {
            uint64_t v15 = v23->__r_.__value_.__s.__size_;
          }
          else {
            uint64_t v15 = v23->__r_.__value_.__l.__size_;
          }
          sub_10002A6A4(v12, v14, v15);
          uint64_t v16 = &v24;
          goto LABEL_40;
        }

LABEL_15:
        ++v7;
        uint64_t v6 = v38;
        if (v38 != -1 && v38 <= v7) {
          goto LABEL_6;
        }
      }

      uint64_t v6 = v38;
      if (v38 != -1) {
        goto LABEL_6;
      }
      goto LABEL_7;
    }

    LODWORD(v7) = 0;
LABEL_6:
    if (v6 == v7)
    {
LABEL_7:
      uint64_t v8 = 0LL;
      goto LABEL_43;
    }

    sub_10000A2DC(__p, "ERROR");
    sub_10002A9EC((BOOL *)&v25, (uint64_t)__p);
    uint64_t v17 = sub_10002A6A4(&std::cerr, (uint64_t)"VectorFst::Read: Unexpected end of file: ", 41LL);
    int v18 = (char)v23->__r_.__value_.__s.__size_;
    if (v18 >= 0) {
      uint64_t v19 = (uint64_t)v23;
    }
    else {
      uint64_t v19 = v23->__r_.__value_.__r.__words[0];
    }
    if (v18 >= 0) {
      uint64_t v20 = v23->__r_.__value_.__s.__size_;
    }
    else {
      uint64_t v20 = v23->__r_.__value_.__l.__size_;
    }
LABEL_39:
    sub_10002A6A4(v17, v19, v20);
    uint64_t v16 = (BOOL *)&v25;
LABEL_40:
    sub_10002AA94(v16);
    if (v29 < 0) {
      operator delete(__p[0]);
    }
  }

  uint64_t v8 = v4;
  int v4 = 0LL;
LABEL_43:
  if (SHIBYTE(v35) < 0) {
    operator delete(v34[1]);
  }
  if (SHIBYTE(v34[0]) < 0) {
    operator delete(v33[0]);
  }
  if (v8) {
    (*(void (**)(void *))(*v8 + 8LL))(v8);
  }
  return v4;
}

  if (*((void *)&v17 + 1)) {
    --**((_DWORD **)&v17 + 1);
  }
LABEL_17:
  sub_100070E04(a1, a2);
}

void sub_10005A34C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, int a10, __int16 a11, char a12, char a13, char a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20, char a21, uint64_t a22, uint64_t a23, char a24)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  sub_10002C8BC((uint64_t)&a24);
  (*(void (**)(uint64_t))(*(void *)v24 + 8LL))(v24);
  _Unwind_Resume(a1);
}

void *sub_10005A3D8(void *a1)
{
  return a1;
}

uint64_t sub_10005A430(uint64_t a1, void *a2, const std::string *a3, int a4, uint64_t a5)
{
  std::string::pointer data = a3[1].__r_.__value_.__l.__data_;
  if (data)
  {
    *(_DWORD *)a5 = *(_DWORD *)data;
    std::string::operator=((std::string *)(a5 + 8), (const std::string *)(data + 8));
    std::string::operator=((std::string *)(a5 + 32), (const std::string *)(data + 32));
    uint64_t v11 = *((void *)data + 11);
    __int128 v12 = *(_OWORD *)(data + 72);
    *(_OWORD *)(a5 + ++*(void *)(result + 56) = *(_OWORD *)(data + 56);
    *(_OWORD *)(a5 + 72) = v12;
    *(void *)(a5 + 8std::istream::~istream(v1, v2 + 8) = v11;
  }

  else
  {
    int v13 = sub_1000A3AC8(a5, a2, (uint64_t)a3, 0);
    uint64_t result = 0LL;
    if (!v13) {
      return result;
    }
  }

  if (dword_1000DE7E8 >= 2)
  {
    sub_10000A2DC(__p, "INFO");
    sub_10002A9EC(&v83, (uint64_t)__p);
    uint64_t v15 = sub_10002A6A4(&std::cerr, (uint64_t)"FstImpl::ReadHeader: source: ", 29LL);
    int size = (char)a3->__r_.__value_.__s.__size_;
    uint64_t v17 = size >= 0 ? (uint64_t)a3 : a3->__r_.__value_.__r.__words[0];
    uint64_t v18 = size >= 0 ? a3->__r_.__value_.__s.__size_ : a3->__r_.__value_.__l.__size_;
    uint64_t v19 = sub_10002A6A4(v15, v17, v18);
    uint64_t v20 = sub_10002A6A4(v19, (uint64_t)", fst_type: ", 12LL);
    int v21 = *(char *)(a5 + 31);
    uint64_t v22 = v21 >= 0 ? a5 + 8 : *(void *)(a5 + 8);
    uint64_t v23 = v21 >= 0 ? *(unsigned __int8 *)(a5 + 31) : *(void *)(a5 + 16);
    uint64_t v24 = sub_10002A6A4(v20, v22, v23);
    int v25 = sub_10002A6A4(v24, (uint64_t)", arc_type: ", 12LL);
    uint64_t v26 = sub_10002C8FC();
    int v27 = *(char *)(v26 + 23);
    uint64_t v28 = v27 >= 0 ? v26 : *(void *)v26;
    uint64_t v29 = v27 >= 0 ? *(unsigned __int8 *)(v26 + 23) : *(void *)(v26 + 8);
    uint64_t v30 = sub_10002A6A4(v25, v28, v29);
    int v31 = sub_10002A6A4(v30, (uint64_t)", version: ", 11LL);
    uint64_t v32 = (void *)std::ostream::operator<<(v31, *(unsigned int *)(a5 + 56));
    uint64_t v33 = sub_10002A6A4(v32, (uint64_t)", flags: ", 9LL);
    std::ostream::operator<<(v33, *(unsigned int *)(a5 + 60));
    sub_10002AA94(&v83);
    if (v82 < 0) {
      operator delete(__p[0]);
    }
  }

  uint64_t v34 = *(unsigned __int8 *)(a5 + 31);
  if ((v34 & 0x80u) == 0LL) {
    uint64_t v35 = *(unsigned __int8 *)(a5 + 31);
  }
  else {
    uint64_t v35 = *(void *)(a5 + 16);
  }
  uint64_t v36 = *(unsigned __int8 *)(a1 + 39);
  int v37 = (char)v36;
  if ((v36 & 0x80u) != 0LL) {
    uint64_t v36 = *(void *)(a1 + 24);
  }
  if (v35 != v36) {
    goto LABEL_40;
  }
  uint64_t v38 = (const void **)(a5 + 8);
  if (v37 >= 0) {
    uint64_t v39 = (unsigned __int8 *)(a1 + 16);
  }
  else {
    uint64_t v39 = *(unsigned __int8 **)(a1 + 16);
  }
  if ((v34 & 0x80) != 0)
  {
    if (memcmp(*v38, v39, *(void *)(a5 + 16)))
    {
LABEL_40:
      sub_10000A2DC(__p, "ERROR");
      sub_10002A9EC(&v83, (uint64_t)__p);
      int v40 = sub_10002A6A4(&std::cerr, (uint64_t)"FstImpl::ReadHeader: FST not of type ", 37LL);
      int v41 = *(char *)(a1 + 39);
      if (v41 >= 0) {
        uint64_t v42 = a1 + 16;
      }
      else {
        uint64_t v42 = *(void *)(a1 + 16);
      }
      if (v41 >= 0) {
        uint64_t v43 = *(unsigned __int8 *)(a1 + 39);
      }
      else {
        uint64_t v43 = *(void *)(a1 + 24);
      }
      id v44 = sub_10002A6A4(v40, v42, v43);
      uint64_t v45 = sub_10002A6A4(v44, (uint64_t)": ", 2LL);
      int v46 = (char)a3->__r_.__value_.__s.__size_;
      if (v46 >= 0) {
        uint64_t v47 = (uint64_t)a3;
      }
      else {
        uint64_t v47 = a3->__r_.__value_.__r.__words[0];
      }
      if (v46 >= 0) {
        uint64_t v48 = a3->__r_.__value_.__s.__size_;
      }
      else {
        uint64_t v48 = a3->__r_.__value_.__l.__size_;
      }
      goto LABEL_79;
    }
  }

  else if (*(_BYTE *)(a5 + 31))
  {
    while (*(unsigned __int8 *)v38 == *v39)
    {
      uint64_t v38 = (const void **)((char *)v38 + 1);
      ++v39;
      if (!--v34) {
        goto LABEL_52;
      }
    }

    goto LABEL_40;
  }

LABEL_52:
  uint64_t v49 = sub_10002C8FC();
  uint64_t v50 = *(unsigned __int8 *)(a5 + 55);
  if ((v50 & 0x80u) == 0LL) {
    uint64_t v51 = *(unsigned __int8 *)(a5 + 55);
  }
  else {
    uint64_t v51 = *(void *)(a5 + 40);
  }
  uint64_t v52 = *(unsigned __int8 *)(v49 + 23);
  int v53 = (char)v52;
  if ((v52 & 0x80u) != 0LL) {
    uint64_t v52 = *(void *)(v49 + 8);
  }
  if (v51 != v52) {
    goto LABEL_67;
  }
  uint64_t v54 = (const void **)(a5 + 32);
  if (v53 >= 0) {
    id v55 = (unsigned __int8 *)v49;
  }
  else {
    id v55 = *(unsigned __int8 **)v49;
  }
  if ((v50 & 0x80) != 0)
  {
    if (memcmp(*v54, v55, *(void *)(a5 + 40)))
    {
LABEL_67:
      sub_10000A2DC(__p, "ERROR");
      sub_10002A9EC(&v83, (uint64_t)__p);
      uint64_t v56 = sub_10002A6A4(&std::cerr, (uint64_t)"FstImpl::ReadHeader: Arc not of type ", 37LL);
      uint64_t v57 = sub_10002C8FC();
      int v58 = *(char *)(v57 + 23);
      if (v58 >= 0) {
        uint64_t v59 = v57;
      }
      else {
        uint64_t v59 = *(void *)v57;
      }
      if (v58 >= 0) {
        uint64_t v60 = *(unsigned __int8 *)(v57 + 23);
      }
      else {
        uint64_t v60 = *(void *)(v57 + 8);
      }
      uint64_t v61 = sub_10002A6A4(v56, v59, v60);
      uint64_t v45 = sub_10002A6A4(v61, (uint64_t)": ", 2LL);
      int v62 = (char)a3->__r_.__value_.__s.__size_;
      if (v62 >= 0) {
        uint64_t v47 = (uint64_t)a3;
      }
      else {
        uint64_t v47 = a3->__r_.__value_.__r.__words[0];
      }
      if (v62 >= 0) {
        uint64_t v48 = a3->__r_.__value_.__s.__size_;
      }
      else {
        uint64_t v48 = a3->__r_.__value_.__l.__size_;
      }
      goto LABEL_79;
    }
  }

  else if (*(_BYTE *)(a5 + 55))
  {
    while (*(unsigned __int8 *)v54 == *v55)
    {
      uint64_t v54 = (const void **)((char *)v54 + 1);
      ++v55;
      if (!--v50) {
        goto LABEL_83;
      }
    }

    goto LABEL_67;
  }

              if (*((void *)&v47 + 1)) {
                --**((_DWORD **)&v47 + 1);
              }
LABEL_54:
              if (v57) {
                (*(void (**)(uint64_t))(*(void *)v57 + 32LL))(v57);
              }
              else {
                ++v59;
              }
              goto LABEL_25;
            }
          }

          else if (v48 >= (unint64_t)v47)
          {
            goto LABEL_52;
          }

          if (*v5)
          {
            uint64_t v30 = *(void *)(a1 + 224) + 80LL * v60;
            ++*(void *)(v30 + 8);
          }

          if ((void)v46) {
            int v31 = (*(uint64_t (**)(void))(*(void *)v46 + 24LL))(v46);
          }
          else {
            int v31 = *((void *)&v46 + 1) + 16 * v48;
          }
          uint64_t v32 = (int *)(v31 + 4);
          uint64_t v33 = sub_10005C1A8((void *)(a1 + 96), (int *)(v31 + 4));
          if (v33)
          {
            uint64_t v56 = *((float *)v33 + 5);
            uint64_t v34 = v60;
            uint64_t v35 = *v32;
            uint64_t v36 = *sub_10002AD60();
            LODWORD(v53) = v35;
            HIDWORD(v53) = v35;
            uint64_t v54 = v36;
            id v55 = v56;
            sub_10002D714(v4);
            sub_10002D8BC(*(void **)(a1 + 144), v34, (float *)&v53);
            if (*v5)
            {
              int v37 = *(void *)(a1 + 224);
              ++*(_DWORD *)(v37 + 80LL * v60 + 16);
              uint64_t v38 = v37 + 80LL * SLODWORD(v56);
              ++*(void *)(v38 + 24);
              int v53 = &v60;
              uint64_t v39 = sub_10007BAF4((uint64_t **)(v38 + 32), &v60, (uint64_t)&unk_1000AF371, &v53);
              v39[5] = (uint64_t *)((char *)v39[5] + 1);
              int v40 = (uint64_t **)(*(void *)(a1 + 224) + 80LL * v60 + 56);
              int v53 = (int *)&v56;
              int v41 = sub_10007BAF4(v40, (int *)&v56, (uint64_t)&unk_1000AF371, &v53);
              v41[5] = (uint64_t *)((char *)v41[5] + 1);
            }
          }

          if ((void)v46) {
            (*(void (**)(void))(*(void *)v46 + 32LL))(v46);
          }
          else {
            ++v48;
          }
        }
      }

      if (v57) {
        (*(void (**)(void))(*(void *)v57 + 8LL))();
      }
LABEL_59:
      uint64_t v23 = v60;
      uint64_t v22 = *(void *)(a1 + 24);
      int v21 = *(void *)(a1 + 32);
LABEL_60:
      uint64_t v60 = ++v23;
      uint64_t v24 = v23;
    }

    goto LABEL_30;
  }

LABEL_83:
  if (*(_DWORD *)(a5 + 56) < a4)
  {
    sub_10000A2DC(__p, "ERROR");
    sub_10002A9EC(&v83, (uint64_t)__p);
    uint64_t v63 = sub_10002A6A4(&std::cerr, (uint64_t)"FstImpl::ReadHeader: Obsolete ", 30LL);
    int v64 = *(char *)(a1 + 39);
    if (v64 >= 0) {
      uint64_t v65 = a1 + 16;
    }
    else {
      uint64_t v65 = *(void *)(a1 + 16);
    }
    if (v64 >= 0) {
      uint64_t v66 = *(unsigned __int8 *)(a1 + 39);
    }
    else {
      uint64_t v66 = *(void *)(a1 + 24);
    }
    id v67 = sub_10002A6A4(v63, v65, v66);
    uint64_t v45 = sub_10002A6A4(v67, (uint64_t)" FST version: ", 14LL);
    int v68 = (char)a3->__r_.__value_.__s.__size_;
    if (v68 >= 0) {
      uint64_t v47 = (uint64_t)a3;
    }
    else {
      uint64_t v47 = a3->__r_.__value_.__r.__words[0];
    }
    if (v68 >= 0) {
      uint64_t v48 = a3->__r_.__value_.__s.__size_;
    }
    else {
      uint64_t v48 = a3->__r_.__value_.__l.__size_;
    }
LABEL_79:
    sub_10002A6A4(v45, v47, v48);
    sub_10002AA94(&v83);
    if (v82 < 0) {
      operator delete(__p[0]);
    }
    return 0LL;
  }

  *(void *)(a1 + std::istream::~istream(v1, v2 + 8) = *(void *)(a5 + 64);
  if ((*(_BYTE *)(a5 + 60) & 1) != 0)
  {
    uint64_t v69 = sub_10005A9EC(a2, a3);
    uint64_t v70 = *(void *)(a1 + 40);
    *(void *)(a1 + 4RDString::RDString((RDString *)&v66, theString, 0) = v69;
    if (v70) {
      (*(void (**)(uint64_t))(*(void *)v70 + 8LL))(v70);
    }
  }

  if (!a3[2].__r_.__value_.__s.__data_[4])
  {
    uint64_t v71 = *(void *)(a1 + 40);
    *(void *)(a1 + 4RDString::RDString((RDString *)&v66, theString, 0) = 0LL;
    if (v71) {
      (*(void (**)(uint64_t, unsigned __int8 *))(*(void *)v71 + 8LL))(v71, v55);
    }
  }

  if ((*(_BYTE *)(a5 + 60) & 2) != 0)
  {
    uint64_t v72 = sub_10005A9EC(a2, a3);
    uint64_t v73 = *(void *)(a1 + 48);
    *(void *)(a1 + 4std::istream::~istream(v1, v2 + 8) = v72;
    if (v73) {
      (*(void (**)(uint64_t))(*(void *)v73 + 8LL))(v73);
    }
  }

  if (!a3[2].__r_.__value_.__s.__data_[5])
  {
    uint64_t v74 = *(void *)(a1 + 48);
    *(void *)(a1 + 4std::istream::~istream(v1, v2 + 8) = 0LL;
    if (v74) {
      (*(void (**)(uint64_t, unsigned __int8 *))(*(void *)v74 + 8LL))(v74, v55);
    }
  }

  std::string::size_type v75 = a3[1].__r_.__value_.__l.__size_;
  if (v75)
  {
    uint64_t v76 = (*(uint64_t (**)(std::string::size_type, unsigned __int8 *))(*(void *)v75 + 16LL))(v75, v55);
    uint64_t v77 = *(void *)(a1 + 40);
    *(void *)(a1 + 4RDString::RDString((RDString *)&v66, theString, 0) = v76;
    if (v77) {
      (*(void (**)(uint64_t))(*(void *)v77 + 8LL))(v77);
    }
  }

  std::string::size_type cap = a3[1].__r_.__value_.__l.__cap_;
  if (cap)
  {
    uint64_t v79 = (*(uint64_t (**)(std::string::size_type, unsigned __int8 *))(*(void *)cap + 16LL))(cap, v55);
    uint64_t v80 = *(void *)(a1 + 48);
    *(void *)(a1 + 4std::istream::~istream(v1, v2 + 8) = v79;
    if (v80) {
      (*(void (**)(uint64_t))(*(void *)v80 + 8LL))(v80);
    }
  }

  return 1LL;
}

void sub_10005A9A8( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, int a15, __int16 a16, char a17, char a18)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void *sub_10005A9EC(void *a1, const std::string *a2)
{
  *(_OWORD *)std::string __p = 0u;
  __int128 v6 = 0u;
  std::string::operator=((std::string *)&__p[1], a2);
  uint64_t v3 = sub_10005AAFC(a1);
  if (SHIBYTE(v6) < 0) {
    operator delete(__p[1]);
  }
  return v3;
}

void sub_10005AA5C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void *sub_10005AA70(_BYTE *__dst, void *__src, unint64_t a3)
{
  uint64_t v5 = __dst;
  if (a3 > 0x16)
  {
    if (a3 >= 0x7FFFFFFFFFFFFFF8LL) {
      sub_10000A38C();
    }
    uint64_t v6 = (a3 & 0xFFFFFFFFFFFFFFF8LL) + 8;
    if ((a3 | 7) != 0x17) {
      uint64_t v6 = a3 | 7;
    }
    uint64_t v7 = v6 + 1;
    uint64_t v8 = operator new(v6 + 1);
    v5[1] = a3;
    _OWORD v5[2] = v7 | 0x8000000000000000LL;
    void *v5 = v8;
    uint64_t v5 = v8;
  }

  else
  {
    __dst[23] = a3;
  }

  return memmove(v5, __src, a3 + 1);
}

void *sub_10005AAFC(void *a1)
{
  uint64_t v1 = sub_10009E578(a1);
  if (!v1) {
    return 0LL;
  }
  uint64_t v2 = (uint64_t)v1;
  uint64_t v3 = operator new(0x18uLL);
  *uint64_t v3 = off_1000D4218;
  sub_10005ABA4(v3 + 1, v2);
  return v3;
}

void sub_10005AB50(_Unwind_Exception *a1)
{
}

uint64_t sub_10005AB64(uint64_t a1)
{
  uint64_t v2 = *(void **)a1;
  if (*(void *)a1)
  {
    *(void *)(a1 + std::istream::~istream(v1, v2 + 8) = v2;
    operator delete(v2);
  }

  return a1;
}

void *sub_10005ABA4(void *a1, uint64_t a2)
{
  *a1 = a2;
  int v4 = operator new(0x20uLL);
  *int v4 = &off_1000D05E8;
  v4[1] = 0LL;
  _DWORD v4[2] = 0LL;
  v4[3] = a2;
  a1[1] = v4;
  return a1;
}

void sub_10005ABE8(_Unwind_Exception *exception_object)
{
  if (v1)
  {
    uint64_t v3 = (void *)sub_10005AC80(v1);
    operator delete(v3);
  }

  _Unwind_Resume(exception_object);
}

void sub_10005AC08(std::__shared_weak_count *a1)
{
}

void sub_10005AC1C(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 24);
  if (v1)
  {
    uint64_t v2 = (void *)sub_10005AC80(v1);
    operator delete(v2);
  }

uint64_t sub_10005AC40(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }

  else
  {
    return 0LL;
  }

uint64_t sub_10005AC80(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 112);
  if (v2)
  {
    *(void *)(a1 + 12RDString::RDString((RDString *)&v66, theString, 0) = v2;
    operator delete(v2);
  }

  uint64_t v3 = *(void **)(a1 + 80);
  if (v3)
  {
    *(void *)(a1 + 8std::istream::~istream(v1, v2 + 8) = v3;
    operator delete(v3);
  }

  uint64_t v5 = (void **)(a1 + 48);
  sub_10001FAA8(&v5);
  return a1;
}

void *sub_10005AD1C(void *a1, uint64_t a2)
{
  *a1 = a2;
  int v4 = operator new(0x20uLL);
  *int v4 = &off_1000D0660;
  v4[1] = 0LL;
  _DWORD v4[2] = 0LL;
  v4[3] = a2;
  a1[1] = v4;
  return a1;
}

void sub_10005AD60(_Unwind_Exception *exception_object)
{
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8LL))(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_10005AD84(std::__shared_weak_count *a1)
{
}

uint64_t sub_10005AD98(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(uint64_t))(*(void *)result + 8LL))(result);
  }
  return result;
}

uint64_t sub_10005ADB0(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }

  else
  {
    return 0LL;
  }

void *sub_10005ADF0(void *a1, uint64_t *a2)
{
  uint64_t v3 = a2[1];
  uint64_t v10 = *a2;
  uint64_t v11 = (std::__shared_weak_count *)v3;
  if (v3)
  {
    int v4 = (unint64_t *)(v3 + 8);
    do
      unint64_t v5 = __ldxr(v4);
    while (__stxr(v5 + 1, v4));
  }

  sub_10005AE9C(a1, &v10);
  uint64_t v6 = v11;
  if (v11)
  {
    p_shared_owners = (unint64_t *)&v11->__shared_owners_;
    do
      unint64_t v8 = __ldaxr(p_shared_owners);
    while (__stlxr(v8 - 1, p_shared_owners));
    if (!v8)
    {
      ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
      std::__shared_weak_count::__release_weak(v6);
    }
  }

  *a1 = off_1000D06D8;
  return a1;
}

void sub_10005AE88( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void *sub_10005AE9C(void *a1, uint64_t *a2)
{
  uint64_t v3 = *a2;
  int v4 = (std::__shared_weak_count *)a2[1];
  if (v4)
  {
    p_shared_owners = (unint64_t *)&v4->__shared_owners_;
    do
      unint64_t v6 = __ldxr(p_shared_owners);
    while (__stxr(v6 + 1, p_shared_owners));
    do
      unint64_t v7 = __ldxr(p_shared_owners);
    while (__stxr(v7 + 1, p_shared_owners));
    a1[1] = v3;
    a1[2] = v4;
    *a1 = off_1000D0928;
    do
      unint64_t v8 = __ldaxr(p_shared_owners);
    while (__stlxr(v8 - 1, p_shared_owners));
    if (!v8)
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }

  else
  {
    a1[1] = v3;
    a1[2] = 0LL;
  }

  *a1 = off_1000D0800;
  return a1;
}

uint64_t sub_10005AF38()
{
  return 0LL;
}

unint64_t sub_10005AF40(uint64_t a1, uint64_t a2, void *a3)
{
  if (!byte_1000DE7EE) {
    return sub_10005B0B8(a1, a2, a3, 1);
  }
  unint64_t v6 = (*(uint64_t (**)(uint64_t, uint64_t, void))(*(void *)a1 + 56LL))(a1, 0xFFFFFFFF0007LL, 0LL);
  unint64_t v7 = sub_10005B0B8(a1, a2, a3, 0);
  if (!sub_10002AB50(v6, v7))
  {
    if (byte_1000DDAF8) {
      sub_10000A2DC(__p, "FATAL");
    }
    else {
      sub_10000A2DC(__p, "ERROR");
    }
    sub_10002A9EC(&v12, (uint64_t)__p);
    uint64_t v9 = sub_10002A6A4(&std::cerr, (uint64_t)"TestProperties: stored FST properties incorrect", 47LL);
    sub_10002A6A4(v9, (uint64_t)" (stored: props1, computed: props2)", 35LL);
    sub_10002AA94(&v12);
    if (v11 < 0) {
      operator delete(__p[0]);
    }
  }

  return v7;
}

void sub_10005B080( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, int a15, __int16 a16, char a17, char a18)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

unint64_t sub_10005B0B8(uint64_t a1, uint64_t a2, void *a3, int a4)
{
  uint64_t v8 = a1;
  unint64_t v9 = (*(uint64_t (**)(uint64_t, uint64_t, void))(*(void *)a1 + 56LL))(a1, 0xFFFFFFFF0007LL, 0LL);
  unint64_t v10 = v9;
  if (a4)
  {
    uint64_t v11 = v9 & 0xFFFFFFFF0000LL | (2 * v9) & 0xAAAAAAAA0000LL | (v9 >> 1) & 0x555555550000LL | 7;
    if ((a2 & ~v11) == 0)
    {
      if (a3) {
        *a3 = v11;
      }
      return v10;
    }
  }

  uint64_t v56 = 0LL;
  unint64_t v57 = v9 & 7;
  uint64_t v54 = 0LL;
  id v55 = 0LL;
  if ((a2 & 0xCF3C00000000LL) != 0)
  {
    __int128 v49 = (unint64_t)&v54;
    *(void *)&__int128 v50 = 0LL;
    *((void *)&v50 + 1) = &v57;
    *(_OWORD *)uint64_t v52 = 0u;
    *(_OWORD *)std::string __p = 0u;
    sub_10005B86C(v8, (uint64_t *)&v49, 0);
    BOOL v12 = (void **)__p[1];
    __p[1] = 0LL;
    if (v12) {
      sub_10002B7A4((int)&__p[1], v12);
    }
    sub_10002B764((void ***)__p, 0LL);
    int v13 = (void **)v52[1];
    v52[1] = 0LL;
    if (v13) {
      sub_10002B7A4((int)&v52[1], v13);
    }
    uint64_t v14 = (void **)v52[0];
    v52[0] = 0LL;
    if (v14) {
      sub_10002B7A4((int)v52, v14);
    }
  }

  if ((a2 & 0xFFFFF0C3FFFFFFF8LL) == 0) {
    goto LABEL_102;
  }
  uint64_t v42 = a3;
  uint64_t v15 = 0x10425A810000LL;
  if ((a2 & 0xC0000) != 0) {
    uint64_t v15 = 0x10425A850000LL;
  }
  unint64_t v16 = v57 | v15;
  uint64_t v44 = a2 & 0x300000;
  uint64_t v45 = a2 & 0xC0000;
  if ((a2 & 0x300000) != 0) {
    v16 |= 0x100000uLL;
  }
  if ((a2 & 0xCF3C00000000LL) != 0) {
    v16 |= 0x800000000000uLL;
  }
  unint64_t v57 = v16;
  uint64_t v46 = 0LL;
  int v47 = 0;
  unsigned int v48 = 0;
  (*(void (**)(uint64_t, uint64_t *))(*(void *)v8 + 112LL))(v8, &v46);
  uint64_t v17 = 0LL;
  uint64_t v18 = 0LL;
  int v19 = 0;
  uint64_t v43 = v8;
LABEL_20:
  if (!v46)
  {
    goto LABEL_25;
  }

  if (!(*(unsigned int (**)(uint64_t))(*(void *)v46 + 16LL))(v46))
  {
    if (v46)
    {
      uint64_t v20 = (*(uint64_t (**)(void))(*(void *)v46 + 24LL))();
LABEL_26:
      if (v45)
      {
        int v21 = operator new(0x28uLL);
        *int v21 = 0u;
        v21[1] = 0u;
        *((_DWORD *)v21 + std::istream::~istream(v1, v2 + 8) = 1065353216;
        if (v18)
        {
          uint64_t v22 = (void *)sub_10001A760((uint64_t)v18);
          operator delete(v22);
        }

        uint64_t v18 = v21;
      }

      if (v44)
      {
        uint64_t v23 = operator new(0x28uLL);
        *uint64_t v23 = 0u;
        v23[1] = 0u;
        *((_DWORD *)v23 + std::istream::~istream(v1, v2 + 8) = 1065353216;
        if (v17)
        {
          uint64_t v24 = (void *)sub_10001A760((uint64_t)v17);
          operator delete(v24);
        }

        uint64_t v17 = v23;
      }

      unint64_t v51 = 0LL;
      __int128 v49 = 0u;
      __int128 v50 = 0u;
      (*(void (**)(uint64_t, uint64_t, __int128 *))(*(void *)v8 + 120LL))(v8, v20, &v49);
      char v25 = 1;
      while ((void)v49)
      {
        if ((*(unsigned int (**)(void))(*(void *)v49 + 16LL))(v49))
        {
          if ((void)v49)
          {
            (*(void (**)(void))(*(void *)v49 + 8LL))();
            goto LABEL_82;
          }

LABEL_80:
          if (*((void *)&v50 + 1)) {
            --**((_DWORD **)&v50 + 1);
          }
LABEL_82:
          uint64_t v8 = v43;
          if (v19 > 0) {
            unint64_t v57 = v57 & 0xFFFFCFFFFFFFFFFFLL | 0x200000000000LL;
          }
          (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(*(void *)v43 + 24LL))(&v58, v43, v20);
          uint64_t v36 = sub_10002ADB0();
          LODWORD(v49) = v58;
          HIDWORD(v5std::istream::~istream(v1, v2 + 8) = *v36;
          if (*(float *)&v58 == *((float *)&v58 + 1))
          {
          }

          else
          {
            int v37 = sub_10002AD60();
            LODWORD(v49) = v58;
            HIDWORD(v5std::istream::~istream(v1, v2 + 8) = *v37;
            v38.n128_u32[0] = v58;
            ++v19;
          }

          if (v46) {
            (*(void (**)(uint64_t, __n128))(*(void *)v46 + 32LL))(v46, v38);
          }
          else {
            ++v48;
          }
          goto LABEL_20;
        }

        if (!(void)v49) {
          goto LABEL_41;
        }
        uint64_t v26 = (int *)(*(uint64_t (**)(void))(*(void *)v49 + 24LL))();
        if (!v18) {
          goto LABEL_44;
        }
LABEL_42:
        if (sub_10005C1A8(v18, v26)) {
          unint64_t v57 = v57 & 0xFFFFFFFFFFF3FFFFLL | 0x80000;
        }
LABEL_44:
        if (v17 && sub_10005C1A8(v17, v26 + 1)) {
          unint64_t v57 = v57 & 0xFFFFFFFFFFCFFFFFLL | 0x200000;
        }
        int v27 = *v26;
        int v28 = *v26;
        if (*v26 != v26[1])
        {
          unint64_t v57 = v57 & 0xFFFFFFFFFFFCFFFFLL | 0x20000;
          int v28 = v26[1];
        }

        if (v27 | v28)
        {
          if (v27)
          {
            if (!v28) {
              goto LABEL_57;
            }
            goto LABEL_53;
          }

          unint64_t v29 = v57;
        }

        else
        {
          unint64_t v29 = v57 & 0xFFFFFFFFFF3FFFFFLL | 0x400000;
        }

        unint64_t v57 = v29 & 0xFFFFFFFFFCFFFFFFLL | 0x1000000;
        if (!v28)
        {
LABEL_57:
          unint64_t v57 = v57 & 0xFFFFFFFFF3FFFFFFLL | 0x4000000;
          if ((v25 & 1) != 0) {
            goto LABEL_62;
          }
          goto LABEL_58;
        }

          if (*((void *)&v50 + 1)) {
            --**((_DWORD **)&v50 + 1);
          }
LABEL_82:
          uint64_t v8 = v43;
          if (v19 > 0) {
            unint64_t v57 = v57 & 0xFFFFCFFFFFFFFFFFLL | 0x200000000000LL;
          }
          (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(*(void *)v43 + 24LL))(&v58, v43, v20);
          uint64_t v36 = sub_10002ADB0();
          LODWORD(v49) = v58;
          HIDWORD(v5std::istream::~istream(v1, v2 + 8) = *v36;
          if (*(float *)&v58 == *((float *)&v58 + 1))
          {
          }

          else
          {
            int v37 = sub_10002AD60();
            LODWORD(v49) = v58;
            HIDWORD(v5std::istream::~istream(v1, v2 + 8) = *v37;
            v38.n128_u32[0] = v58;
            ++v19;
          }

          if (v46) {
            (*(void (**)(uint64_t, __n128))(*(void *)v46 + 32LL))(v46, v38);
          }
          else {
            ++v48;
          }
          goto LABEL_20;
        }

        if (!(void)v49) {
          goto LABEL_41;
        }
        uint64_t v26 = (int *)(*(uint64_t (**)(void))(*(void *)v49 + 24LL))();
        if (!v18) {
          goto LABEL_44;
        }
LABEL_42:
        if (sub_10005C1A8(v18, v26)) {
          unint64_t v57 = v57 & 0xFFFFFFFFFFF3FFFFLL | 0x80000;
        }
LABEL_44:
        if (v17 && sub_10005C1A8(v17, v26 + 1)) {
          unint64_t v57 = v57 & 0xFFFFFFFFFFCFFFFFLL | 0x200000;
        }
        int v27 = *v26;
        int v28 = *v26;
        if (*v26 != v26[1])
        {
          unint64_t v57 = v57 & 0xFFFFFFFFFFFCFFFFLL | 0x20000;
          int v28 = v26[1];
        }

        if (v27 | v28)
        {
          if (v27)
          {
            if (!v28) {
              goto LABEL_57;
            }
            goto LABEL_53;
          }

          unint64_t v29 = v57;
        }

        else
        {
          unint64_t v29 = v57 & 0xFFFFFFFFFF3FFFFFLL | 0x400000;
        }

        unint64_t v57 = v29 & 0xFFFFFFFFFCFFFFFFLL | 0x1000000;
        if (!v28)
        {
LABEL_57:
          unint64_t v57 = v57 & 0xFFFFFFFFF3FFFFFFLL | 0x4000000;
          if ((v25 & 1) != 0) {
            goto LABEL_62;
          }
          goto LABEL_58;
        }

LABEL_53:
        if ((v25 & 1) != 0) {
          goto LABEL_62;
        }
LABEL_58:
        if (v28 < SHIDWORD(v4)) {
          unint64_t v57 = v57 & 0xFFFFFFFF3FFFFFFFLL | 0x80000000;
        }
LABEL_62:
        uint64_t v30 = sub_10002AD60();
        HIDWORD(v5std::istream::~istream(v1, v2 + 8) = v26[2];
        LODWORD(v5std::istream::~istream(v1, v2 + 8) = *v30;
        v31.n128_u32[0] = HIDWORD(v58);
        if (*((float *)&v58 + 1) != *(float *)&v58)
        {
          uint64_t v32 = sub_10002ADB0();
          HIDWORD(v5std::istream::~istream(v1, v2 + 8) = v26[2];
          LODWORD(v5std::istream::~istream(v1, v2 + 8) = *v32;
          v31.n128_u32[0] = HIDWORD(v58);
          if (*((float *)&v58 + 1) != *(float *)&v58)
          {
            unint64_t v33 = v57;
            unint64_t v34 = v57 & 0xFFFFFFFCFFFFFFFFLL | (unint64_t)&_mh_execute_header;
            unint64_t v57 = v34;
          }
        }

        int v35 = v26[3];
        if (v35 != (_DWORD)v20 + 1) {
          unint64_t v57 = v57 & 0xFFFFCFFFFFFFFFFFLL | 0x200000000000LL;
        }
        uint64_t v4 = *(void *)v26;
        if (v18) {
          sub_10005C25C((uint64_t)v18, v26, v26);
        }
        if (v17) {
          sub_10005C25C((uint64_t)v17, v26 + 1, v26 + 1);
        }
        if ((void)v49)
        {
          (*(void (**)(void, __n128))(*(void *)v49 + 32LL))(v49, v31);
          char v25 = 0;
        }

        else
        {
          char v25 = 0;
          ++v51;
        }
      }

    sub_100018774();
  }

  v4[v6] = *a2;
  *(_DWORD *)(*(void *)(a1 + 16) + 4LL * *(int *)(*(void *)(a1 + 40) + 4LL * *(int *)(a1 + 88))) = *(_DWORD *)(a1 + 88);
LABEL_52:
  uint64_t v42 = *(_DWORD *)(a1 + 88);
  *(_DWORD *)(a1 + 8std::istream::~istream(v1, v2 + 8) = v42 + 1;
  return sub_10007FC6C(a1, a2, v42);
}

    sub_100018774();
  }

  v4[v6] = *a2;
  *(_DWORD *)(*(void *)(a1 + 24) + 4LL * *(int *)(*(void *)(a1 + 48) + 4LL * *(int *)(a1 + 96))) = *(_DWORD *)(a1 + 96);
LABEL_52:
  uint64_t v42 = *(_DWORD *)(a1 + 96);
  *(_DWORD *)(a1 + 96) = v42 + 1;
  return sub_10008DF10(a1, a2, v42);
}

        if ((v25 & 1) != 0) {
          goto LABEL_62;
        }
LABEL_58:
        if (v28 < SHIDWORD(v4)) {
          unint64_t v57 = v57 & 0xFFFFFFFF3FFFFFFFLL | 0x80000000;
        }
LABEL_62:
        uint64_t v30 = sub_10002AD60();
        HIDWORD(v5std::istream::~istream(v1, v2 + 8) = v26[2];
        LODWORD(v5std::istream::~istream(v1, v2 + 8) = *v30;
        v31.n128_u32[0] = HIDWORD(v58);
        if (*((float *)&v58 + 1) != *(float *)&v58)
        {
          uint64_t v32 = sub_10002ADB0();
          HIDWORD(v5std::istream::~istream(v1, v2 + 8) = v26[2];
          LODWORD(v5std::istream::~istream(v1, v2 + 8) = *v32;
          v31.n128_u32[0] = HIDWORD(v58);
          if (*((float *)&v58 + 1) != *(float *)&v58)
          {
            unint64_t v33 = v57;
            unint64_t v34 = v57 & 0xFFFFFFFCFFFFFFFFLL | (unint64_t)&_mh_execute_header;
            unint64_t v57 = v34;
          }
        }

        int v35 = v26[3];
        if (v35 != (_DWORD)v20 + 1) {
          unint64_t v57 = v57 & 0xFFFFCFFFFFFFFFFFLL | 0x200000000000LL;
        }
        uint64_t v4 = *(void *)v26;
        if (v18) {
          sub_10005C25C((uint64_t)v18, v26, v26);
        }
        if (v17) {
          sub_10005C25C((uint64_t)v17, v26 + 1, v26 + 1);
        }
        if ((void)v49)
        {
          (*(void (**)(void, __n128))(*(void *)v49 + 32LL))(v49, v31);
          char v25 = 0;
        }

        else
        {
          char v25 = 0;
          ++v51;
        }
      }

LABEL_41:
      uint64_t v26 = (int *)(*((void *)&v49 + 1) + 16 * v51);
      if (!v18) {
        goto LABEL_44;
      }
      goto LABEL_42;
    }

      uint64_t v26 = (int *)(*((void *)&v49 + 1) + 16 * v51);
      if (!v18) {
        goto LABEL_44;
      }
      goto LABEL_42;
    }

LABEL_102:
  unint64_t v10 = v57;
  if (a3) {
    *a3 = v57 & 0xFFFFFFFF0000LL | (2 * v57) & 0xAAAAAAAA0000LL | (v57 >> 1) & 0x555555550000LL | 7;
  }
  if (v54)
  {
    id v55 = v54;
    operator delete(v54);
  }

  return v10;
}

  unint64_t v10 = v57;
  if (a3) {
    *a3 = v57 & 0xFFFFFFFF0000LL | (2 * v57) & 0xAAAAAAAA0000LL | (v57 >> 1) & 0x555555550000LL | 7;
  }
  if (v54)
  {
    id v55 = v54;
    operator delete(v54);
  }

  return v10;
}

void sub_10005B790( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20)
{
  uint64_t v22 = *(void **)(v20 - 128);
  if (v22)
  {
    *(void *)(v20 - 12RDString::RDString((RDString *)&v66, theString, 0) = v22;
    operator delete(v22);
  }

  _Unwind_Resume(exception_object);
}

void sub_10005B86C(uint64_t a1, uint64_t *a2, char a3)
{
  int v45 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 16LL))(a1);
  if (v45 == -1)
  {
    sub_10002AF44((uint64_t)a2);
    return;
  }

  uint64_t v56 = 0LL;
  unint64_t v57 = 0LL;
  uint64_t v58 = 0LL;
  __int128 v55 = 0u;
  memset(v54, 0, sizeof(v54));
  sub_10002B8A4(v51, 64LL);
  int v53 = 0LL;
  __int128 v50 = off_1000D0B78;
  uint64_t v44 = (*(uint64_t (**)(uint64_t, uint64_t, void))(*(void *)a1 + 56LL))(a1, 1LL, 0LL);
  if (v44) {
    uint64_t v5 = sub_10005BFFC(a1);
  }
  else {
    uint64_t v5 = (v45 + 1);
  }
  if ((int)v5 <= (unint64_t)(v57 - v56))
  {
  }

  else
  {
    sub_10002BA28( &v56,  (int)v5 - (v57 - v56),  &fst::DfsVisit<fst::Fst<fst::ArcTpl<fst::TropicalWeightTpl<float>>>,fst::SccVisitor<fst::ArcTpl<fst::TropicalWeightTpl<float>>>,fst::AnyArcFilter<fst::ArcTpl<fst::TropicalWeightTpl<float>>>>(fst::Fst<fst::ArcTpl<fst::TropicalWeightTpl<float>>> const&,fst::SccVisitor<fst::ArcTpl<fst::TropicalWeightTpl<float>>> *,fst::AnyArcFilter<fst::ArcTpl<fst::TropicalWeightTpl<float>>>,BOOL)::kDfsWhite);
  }

  uint64_t v47 = 0LL;
  int v48 = 0;
  int v49 = 0;
  (*(void (**)(uint64_t, uint64_t *))(*(void *)a1 + 112LL))(a1, &v47);
  uint64_t v6 = v45;
  do
  {
    v56[(int)v6] = 1;
    unint64_t v7 = v53;
    if (v53)
    {
      int v53 = (char *)*((void *)v53 + 6);
    }

    else
    {
      unint64_t v7 = sub_10002BED8(v51, 1LL);
      *((void *)v7 + 6) = 0LL;
    }

    *(_DWORD *)unint64_t v7 = v6;
    *(_OWORD *)(v7 + ++*(void *)(result + 24) = 0u;
    *((void *)v7 + 5) = 0LL;
    *(_OWORD *)(v7 + std::istream::~istream(v1, v2 + 8) = 0u;
    (*(void (**)(uint64_t, uint64_t, char *))(*(void *)a1 + 120LL))(a1, v6, v7 + 8);
    uint64_t v46 = v7;
    sub_10002BB40(v54, &v46);
    char v8 = sub_10002B010(a2, v6, v6);
LABEL_16:
    char v9 = v8;
    while (*((void *)&v55 + 1))
    {
      unint64_t v10 = *(char **)(*(void *)(*((void *)&v54[0] + 1)
      unint64_t v11 = *(int *)v10;
      unint64_t v12 = v57 - v56;
      if (v57 - v56 <= v11)
      {
        uint64_t v5 = (v11 + 1);
        if ((int)v5 <= v12)
        {
        }

        else
        {
          sub_10002BA28( &v56,  (int)v5 - v12,  &fst::DfsVisit<fst::Fst<fst::ArcTpl<fst::TropicalWeightTpl<float>>>,fst::SccVisitor<fst::ArcTpl<fst::TropicalWeightTpl<float>>>,fst::AnyArcFilter<fst::ArcTpl<fst::TropicalWeightTpl<float>>>>(fst::Fst<fst::ArcTpl<fst::TropicalWeightTpl<float>>> const&,fst::SccVisitor<fst::ArcTpl<fst::TropicalWeightTpl<float>>> *,fst::AnyArcFilter<fst::ArcTpl<fst::TropicalWeightTpl<float>>>,BOOL)::kDfsWhite);
        }
      }

      if ((v9 & 1) == 0) {
        goto LABEL_33;
      }
      uint64_t v13 = *((void *)v10 + 1);
      if (v13)
      {
        uint64_t v14 = *((void *)v10 + 1);
        if (!v14) {
          goto LABEL_29;
        }
        uint64_t v15 = (*(uint64_t (**)(uint64_t))(*(void *)v14 + 24LL))(v14);
LABEL_30:
        unint64_t v16 = *(int *)(v15 + 12);
        uint64_t v17 = v56;
        unint64_t v18 = v57 - v56;
        if (v57 - v56 <= v16)
        {
          uint64_t v5 = (v16 + 1);
          if ((int)v5 <= v18)
          {
          }

          else
          {
            sub_10002BA28( &v56,  (int)v5 - v18,  &fst::DfsVisit<fst::Fst<fst::ArcTpl<fst::TropicalWeightTpl<float>>>,fst::SccVisitor<fst::ArcTpl<fst::TropicalWeightTpl<float>>>,fst::AnyArcFilter<fst::ArcTpl<fst::TropicalWeightTpl<float>>>>(fst::Fst<fst::ArcTpl<fst::TropicalWeightTpl<float>>> const&,fst::SccVisitor<fst::ArcTpl<fst::TropicalWeightTpl<float>>> *,fst::AnyArcFilter<fst::ArcTpl<fst::TropicalWeightTpl<float>>>,BOOL)::kDfsWhite);
            unint64_t v16 = *(int *)(v15 + 12);
            uint64_t v17 = v56;
          }
        }

        int v25 = v17[v16];
        if (v25 == 1)
        {
          char v9 = sub_10002B5F0((uint64_t)a2, v11, v15);
          uint64_t v24 = *((void *)v10 + 1);
          if (v24) {
            goto LABEL_50;
          }
LABEL_51:
          ++*((void *)v10 + 5);
        }

        else
        {
          if (v25 != 2)
          {
            v17[v16] = 1;
            uint64_t v26 = v53;
            if (v53)
            {
              int v53 = (char *)*((void *)v53 + 6);
            }

            else
            {
              uint64_t v26 = sub_10002BED8(v51, 1LL);
              *((void *)v26 + 6) = 0LL;
            }

            *(_DWORD *)uint64_t v26 = *(_DWORD *)(v15 + 12);
            *(_OWORD *)(v26 + ++*(void *)(result + 24) = 0u;
            *((void *)v26 + 5) = 0LL;
            *(_OWORD *)(v26 + std::istream::~istream(v1, v2 + 8) = 0u;
            (*(void (**)(uint64_t))(*(void *)a1 + 120LL))(a1);
            uint64_t v46 = v26;
            sub_10002BB40(v54, &v46);
            char v8 = sub_10002B010(a2, *(_DWORD *)(v15 + 12), v6);
            goto LABEL_16;
          }

          char v9 = sub_10002B684((void **)a2, v11, v15);
          uint64_t v24 = *((void *)v10 + 1);
          if (!v24) {
            goto LABEL_51;
          }
LABEL_50:
          (*(void (**)(uint64_t))(*(void *)v24 + 32LL))(v24);
        }
      }

      else
      {
        if (*((void *)v10 + 5) < *((void *)v10 + 3))
        {
LABEL_29:
          uint64_t v15 = *((void *)v10 + 2) + 16LL * *((void *)v10 + 5);
          goto LABEL_30;
        }

void sub_10005BF6C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  uint64_t v16 = va_arg(va1, void);
  uint64_t v18 = va_arg(va1, void);
  uint64_t v19 = va_arg(va1, void);
  uint64_t v20 = va_arg(va1, void);
  if (a7) {
    (*(void (**)(uint64_t))(*(void *)a7 + 8LL))(a7);
  }
  sub_10002B998((uint64_t *)va);
  sub_10002C34C((uint64_t *)va1);
  uint64_t v15 = *(void **)(v13 - 112);
  if (v15)
  {
    *(void *)(v13 - 104) = v15;
    operator delete(v15);
  }

  _Unwind_Resume(a1);
}

uint64_t sub_10005BFFC(uint64_t a1)
{
  uint64_t v4 = 0LL;
  int v5 = 0;
  int v6 = 0;
  (*(void (**)(uint64_t, uint64_t *))(*(void *)a1 + 112LL))(a1, &v4);
  uint64_t v3 = 0LL;
  while (1)
  {
    while (!v4)
    {
      if (v6 >= v5) {
        return v3;
      }
      uint64_t v3 = (v3 + 1);
LABEL_10:
      ++v6;
    }

    uint64_t v3 = (v3 + 1);
    if (!v4) {
      goto LABEL_10;
    }
    (*(void (**)(void))(*(void *)v4 + 32LL))();
  }

  if (v4) {
    (*(void (**)(void))(*(void *)v4 + 8LL))();
  }
  return v3;
}

void sub_10005C0E8( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10) {
    (*(void (**)(uint64_t))(*(void *)a10 + 8LL))(a10);
  }
  _Unwind_Resume(exception_object);
}

void sub_10005C108(void *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t v4 = a1[1];
  unint64_t v5 = v4 + a4;
  a1[1] = v4 + a4;
  if (!v4 || ((v5 - 1) ^ (v4 - 1)) >= 0x40)
  {
    if (v5 >= 0x41) {
      unint64_t v6 = (v5 - 1) >> 6;
    }
    else {
      unint64_t v6 = 0LL;
    }
    *(void *)(*a1 + 8 * v6) = 0LL;
  }

  int v7 = *(_DWORD *)(a2 + 8);
  uint64_t v8 = *(void *)a3;
  int v9 = *(_DWORD *)(a3 + 8);
  uint64_t v10 = *a1 + 8 * (v4 >> 6);
  uint64_t v16 = *(void *)a2;
  int v17 = v7;
  uint64_t v14 = v8;
  int v15 = v9;
  uint64_t v12 = v10;
  int v13 = v4 & 0x3F;
  sub_10002C184(&v16, &v14, &v12, (uint64_t)&v11);
}

uint64_t *sub_10005C1A8(void *a1, int *a2)
{
  int8x8_t v2 = (int8x8_t)a1[1];
  if (!*(void *)&v2) {
    return 0LL;
  }
  unint64_t v3 = *a2;
  uint8x8_t v4 = (uint8x8_t)vcnt_s8(v2);
  v4.i16[0] = vaddlv_u8(v4);
  if (v4.u32[0] > 1uLL)
  {
    unint64_t v5 = *a2;
    if (*(void *)&v2 <= v3) {
      unint64_t v5 = v3 % *(void *)&v2;
    }
  }

  else
  {
    unint64_t v5 = (*(void *)&v2 - 1LL) & v3;
  }

  unint64_t v6 = *(uint64_t ***)(*a1 + 8 * v5);
  if (!v6) {
    return 0LL;
  }
  for (uint64_t result = *v6; result; uint64_t result = (uint64_t *)*result)
  {
    unint64_t v8 = result[1];
    if (v8 == v3)
    {
      if (*((_DWORD *)result + 4) == (_DWORD)v3) {
        return result;
      }
    }

    else
    {
      if (v4.u32[0] > 1uLL)
      {
        if (v8 >= *(void *)&v2) {
          v8 %= *(void *)&v2;
        }
      }

      else
      {
        v8 &= *(void *)&v2 - 1LL;
      }

      if (v8 != v5) {
        return 0LL;
      }
    }
  }

  return result;
}

void *sub_10005C25C(uint64_t a1, int *a2, _DWORD *a3)
{
  unint64_t v6 = *a2;
  unint64_t v7 = *(void *)(a1 + 8);
  if (v7)
  {
    uint8x8_t v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      unint64_t v3 = *a2;
      if (v7 <= v6) {
        unint64_t v3 = v6 % v7;
      }
    }

    else
    {
      unint64_t v3 = (v7 - 1) & v6;
    }

    int v9 = *(void ***)(*(void *)a1 + 8 * v3);
    if (v9)
    {
      uint64_t v10 = *v9;
      if (*v9)
      {
        do
        {
          unint64_t v11 = v10[1];
          if (v11 == v6)
          {
            if (*((_DWORD *)v10 + 4) == (_DWORD)v6) {
              return v10;
            }
          }

          else
          {
            if (v8.u32[0] > 1uLL)
            {
              if (v11 >= v7) {
                v11 %= v7;
              }
            }

            else
            {
              v11 &= v7 - 1;
            }

            if (v11 != v3) {
              break;
            }
          }

          uint64_t v10 = (void *)*v10;
        }

        while (v10);
      }
    }
  }

  uint64_t v10 = operator new(0x18uLL);
  *uint64_t v10 = 0LL;
  v10[1] = v6;
  *((_DWORD *)v10 + 4) = *a3;
  float v12 = (float)(unint64_t)(*(void *)(a1 + 24) + 1LL);
  float v13 = *(float *)(a1 + 32);
  if (!v7 || (float)(v13 * (float)v7) < v12)
  {
    BOOL v14 = 1LL;
    if (v7 >= 3) {
      BOOL v14 = (v7 & (v7 - 1)) != 0;
    }
    unint64_t v15 = v14 | (2 * v7);
    unint64_t v16 = vcvtps_u32_f32(v12 / v13);
    if (v15 <= v16) {
      size_t v17 = v16;
    }
    else {
      size_t v17 = v15;
    }
    sub_100018334(a1, v17);
    unint64_t v7 = *(void *)(a1 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v7 <= v6) {
        unint64_t v3 = v6 % v7;
      }
      else {
        unint64_t v3 = v6;
      }
    }

    else
    {
      unint64_t v3 = (v7 - 1) & v6;
    }
  }

  uint64_t v18 = *(void *)a1;
  uint64_t v19 = *(void **)(*(void *)a1 + 8 * v3);
  if (v19)
  {
    *uint64_t v10 = *v19;
LABEL_38:
    void *v19 = v10;
    goto LABEL_39;
  }

  *uint64_t v10 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = v10;
  *(void *)(v18 + 8 * v3) = a1 + 16;
  if (*v10)
  {
    unint64_t v20 = *(void *)(*v10 + 8LL);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v20 >= v7) {
        v20 %= v7;
      }
    }

    else
    {
      v20 &= v7 - 1;
    }

    uint64_t v19 = (void *)(*(void *)a1 + 8 * v20);
    goto LABEL_38;
  }

void sub_10005C460(_Unwind_Exception *a1)
{
}

uint64_t sub_10005C474(void *a1, void *a2, uint64_t a3)
{
  __int128 v34 = 0u;
  __int128 v35 = 0u;
  *(_OWORD *)uint64_t v32 = 0u;
  *(_OWORD *)unint64_t v33 = 0u;
  uint64_t v37 = 0LL;
  uint64_t v38 = 0LL;
  uint64_t v36 = -1LL;
  uint64_t v36 = (*(int (**)(void *))(*a1 + 16LL))(a1);
  uint64_t v37 = -1LL;
  else {
    BOOL v6 = *(_BYTE *)(a3 + 28) == 0;
  }
  if (!v6)
  {
    uint64_t v7 = 0LL;
LABEL_6:
    int v8 = 0;
    uint64_t v37 = (int)sub_10005BFFC((uint64_t)a1);
    goto LABEL_9;
  }

  int v9 = (char *)a2 + *(void *)(*a2 - 24LL);
  if ((v9[32] & 5) != 0)
  {
    int v8 = 1;
    uint64_t v7 = -1LL;
  }

  else
  {
    (*(void (**)(std::string *__return_ptr, void, void, uint64_t, uint64_t))(**((void **)v9 + 5) + 32LL))( __p,  *((void *)v9 + 5),  0LL,  1LL,  16LL);
    uint64_t v7 = v40;
    if (v40 != -1) {
      goto LABEL_6;
    }
    int v8 = 1;
  }

void sub_10005C8A8( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, int a11, char a12, __int16 a13, char a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, void *__p, uint64_t a28, int a29, __int16 a30, char a31, char a32)
{
  if (a32 < 0) {
    operator delete(__p);
  }
  sub_10002C8BC((uint64_t)&a14);
  _Unwind_Resume(a1);
}

uint64_t sub_10005C920(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = off_1000D05B8;
  *(void *)(a1 + std::istream::~istream(v1, v2 + 8) = 0LL;
  uint8x8_t v4 = (std::string *)(a1 + 16);
  sub_10000A2DC((void *)(a1 + 16), "null");
  *(void *)(a1 + 4RDString::RDString((RDString *)&v66, theString, 0) = 0LL;
  unint64_t v5 = (uint64_t *)(a1 + 40);
  *(void *)(a1 + 4std::istream::~istream(v1, v2 + 8) = 0LL;
  *(void *)(a1 + ++*(void *)(result + 56) = 0LL;
  BOOL v6 = (void *)(a1 + 56);
  *(void *)(a1 + 64) = 0LL;
  *(void *)(a1 + 72) = 0LL;
  *(_DWORD *)(a1 + 8RDString::RDString((RDString *)&v66, theString, 0) = -1;
  *(void *)a1 = off_1000D0558;
  sub_10000A2DC(__p, "vector");
  std::string::operator=(v4, (const std::string *)__p);
  if (SBYTE7(v17) < 0) {
    operator delete(__p[0]);
  }
  uint64_t v7 = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 96LL))(a2);
  if (v7) {
    uint64_t v7 = (*(uint64_t (**)(uint64_t))(*(void *)v7 + 16LL))(v7);
  }
  uint64_t v8 = *v5;
  uint64_t *v5 = v7;
  if (v8) {
    (*(void (**)(uint64_t))(*(void *)v8 + 8LL))(v8);
  }
  uint64_t v9 = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 104LL))(a2);
  if (v9) {
    uint64_t v9 = (*(uint64_t (**)(uint64_t))(*(void *)v9 + 16LL))(v9);
  }
  uint64_t v10 = *(void *)(a1 + 48);
  *(void *)(a1 + 4std::istream::~istream(v1, v2 + 8) = v9;
  if (v10) {
    (*(void (**)(uint64_t))(*(void *)v10 + 8LL))(v10);
  }
  *(_DWORD *)(a1 + 8RDString::RDString((RDString *)&v66, theString, 0) = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 16LL))(a2);
  if ((*(uint64_t (**)(uint64_t, uint64_t, void))(*(void *)a2 + 56LL))(a2, 1LL, 0LL))
  {
    int v11 = sub_10005BFFC(a2);
    sub_10002D348((void **)(a1 + 56), v11);
  }

  uint64_t v20 = 0LL;
  int v21 = 0;
  unsigned int v22 = 0;
  (*(void (**)(uint64_t, uint64_t *))(*(void *)a2 + 112LL))(a2, &v20);
  while (1)
  {
    if (!v20)
    {
LABEL_19:
      uint64_t v12 = v22;
      goto LABEL_20;
    }

    if (!v20) {
      goto LABEL_19;
    }
    uint64_t v12 = (*(uint64_t (**)(void))(*(void *)v20 + 24LL))();
LABEL_20:
    sub_10002D0E8((void *)a1);
    (*(void (**)(int *__return_ptr, uint64_t, uint64_t))(*(void *)a2 + 24LL))(&v19, a2, v12);
    **(_DWORD **)(*v6 + 8LL * (int)v12) = v19;
    unint64_t v13 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a2 + 32LL))(a2, v12);
    sub_10002D3DC((uint64_t *)(*(void *)(*v6 + 8LL * (int)v12) + 24LL), v13);
    unint64_t v18 = 0LL;
    *(_OWORD *)std::string __p = 0u;
    __int128 v17 = 0u;
    (*(void (**)(uint64_t, uint64_t, void **))(*(void *)a2 + 120LL))(a2, v12, __p);
    while (1)
    {
      if (!__p[0])
      {
LABEL_26:
        int v14 = (char *)__p[1] + 16 * v18;
        goto LABEL_27;
      }

      if (!__p[0]) {
        goto LABEL_26;
      }
      int v14 = (_DWORD *)(*(uint64_t (**)(void))(*(void *)__p[0] + 24LL))();
LABEL_27:
      sub_10002D538(*(void **)(*v6 + 8LL * (int)v12), v14);
      if (__p[0]) {
        (*(void (**)(void *))(*(void *)__p[0] + 32LL))(__p[0]);
      }
      else {
        ++v18;
      }
    }

    if (__p[0])
    {
      (*(void (**)(void))(*(void *)__p[0] + 8LL))();
      goto LABEL_34;
    }

void sub_10005CC94( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19)
{
}

uint64_t sub_10005CD24(unint64_t a1, float *a2, float *a3)
{
  return a1 & 0xC3FFFFFF0007LL;
}

uint64_t sub_10005CE04(unint64_t a1, int a2, float *a3, _DWORD *a4)
{
  float v6 = *a3;
  int v7 = *((_DWORD *)a3 + 1);
  unint64_t v8 = a1 & 0xFFFFFFFFFFFCFFFFLL | 0x20000;
  if (*(_DWORD *)a3 == v7) {
    unint64_t v8 = a1;
  }
  unint64_t v9 = v8 & 0xFFFFFFFFFCFFFFFFLL | 0x1000000;
  if (!v7) {
    unint64_t v9 = v8 & 0xFFFFFFFFFC3FFFFFLL | 0x1400000;
  }
  if (v6 == 0.0) {
    unint64_t v8 = v9;
  }
  if (v7) {
    unint64_t v10 = v8;
  }
  else {
    unint64_t v10 = v8 & 0xFFFFFFFFF3FFFFFFLL | 0x4000000;
  }
  if (a4)
  {
    if (*a4 <= SLODWORD(v6)) {
      unint64_t v11 = v10;
    }
    else {
      unint64_t v11 = v10 & 0xFFFFFFFFCFFFFFFFLL | 0x20000000;
    }
    if (a4[1] > v7) {
      unint64_t v10 = v11 & 0xFFFFFFFF3FFFFFFFLL | 0x80000000;
    }
    else {
      unint64_t v10 = v11;
    }
  }

  if (*((_DWORD *)a3 + 3) <= a2) {
    unint64_t v12 = v10 & 0xFFFFFF3FFFFFFFFFLL | 0x8000000000LL;
  }
  else {
    unint64_t v12 = v10;
  }
  if ((v12 & 0x4000000000LL) != 0) {
    return v12 & 0x45D7FFEB0007LL | 0x2800000000LL;
  }
  else {
    return v12 & 0x45D7FFEB0007LL;
  }
}

uint64_t sub_10005CF28(uint64_t a1, char a2)
{
  *(_BYTE *)a1 = a2;
  unint64_t v3 = operator new(0x18uLL);
  sub_10008F514(v3);
  *(void *)(a1 + std::istream::~istream(v1, v2 + 8) = v3;
  uint8x8_t v4 = operator new(0x18uLL);
  sub_10000A2DC(__p, "isyms");
  *uint8x8_t v4 = off_1000D4218;
  sub_1000615EC((__int128 *)__p, v4 + 1);
  *(void *)(a1 + 16) = v4;
  if (v11 < 0) {
    operator delete(__p[0]);
  }
  unint64_t v5 = operator new(0x18uLL);
  sub_10000A2DC(__p, "osyms");
  void *v5 = off_1000D4218;
  sub_1000615EC((__int128 *)__p, v5 + 1);
  *(void *)(a1 + ++*(void *)(result + 24) = v5;
  if (v11 < 0) {
    operator delete(__p[0]);
  }
  float v6 = operator new(0x18uLL);
  sub_10000A2DC(__p, "states");
  void *v6 = off_1000D4218;
  sub_1000615EC((__int128 *)__p, v6 + 1);
  *(void *)(a1 + 32) = v6;
  if (v11 < 0) {
    operator delete(__p[0]);
  }
  uint64_t v7 = *(void *)(a1 + 16);
  sub_10000A2DC(__p, "<eps>");
  (*(void (**)(uint64_t, void **))(*(void *)v7 + 32LL))(v7, __p);
  if (v11 < 0) {
    operator delete(__p[0]);
  }
  uint64_t v8 = *(void *)(a1 + 24);
  sub_10000A2DC(__p, "<eps>");
  (*(void (**)(uint64_t, void **))(*(void *)v8 + 32LL))(v8, __p);
  if (v11 < 0) {
    operator delete(__p[0]);
  }
  return a1;
}

void sub_10005D0C0( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  uint64_t v16 = v14[4];
  v14[4] = 0LL;
  if (v16) {
    (*(void (**)(uint64_t))(*(void *)v16 + 8LL))(v16);
  }
  uint64_t v17 = v14[3];
  v14[3] = 0LL;
  if (v17) {
    (*(void (**)(uint64_t))(*(void *)v17 + 8LL))(v17);
  }
  uint64_t v18 = v14[2];
  v14[2] = 0LL;
  if (v18) {
    (*(void (**)(uint64_t))(*(void *)v18 + 8LL))(v18);
  }
  uint64_t v19 = v14[1];
  v14[1] = 0LL;
  if (v19) {
    (*(void (**)(uint64_t))(*(void *)v19 + 8LL))(v19);
  }
  _Unwind_Resume(exception_object);
}

void sub_10005D1D8()
{
  *(void *)(v0 + std::istream::~istream(v1, v2 + 8) = 0LL;
  JUMPOUT(0x10005D1C0LL);
}

void sub_10005D1E4()
{
}

uint64_t sub_10005D1F8(uint64_t a1, uint64_t a2)
{
  *(_BYTE *)a1 = *(_BYTE *)a2;
  uint64_t v4 = *(void *)(a2 + 8);
  unint64_t v5 = operator new(0x18uLL);
  uint64_t v6 = *(void *)(v4 + 16);
  v5[1] = *(void *)(v4 + 8);
  _OWORD v5[2] = v6;
  if (v6)
  {
    uint64_t v7 = (unint64_t *)(v6 + 8);
    do
      unint64_t v8 = __ldxr(v7);
    while (__stxr(v8 + 1, v7));
  }

  void *v5 = off_1000D06D8;
  *(void *)(a1 + std::istream::~istream(v1, v2 + 8) = v5;
  uint64_t v9 = *(void *)(a2 + 16);
  unint64_t v10 = operator new(0x18uLL);
  uint64_t v12 = *(void *)(v9 + 8);
  uint64_t v11 = *(void *)(v9 + 16);
  *unint64_t v10 = off_1000D4218;
  v10[1] = v12;
  v10[2] = v11;
  if (v11)
  {
    unint64_t v13 = (unint64_t *)(v11 + 8);
    do
      unint64_t v14 = __ldxr(v13);
    while (__stxr(v14 + 1, v13));
  }

  *(void *)(a1 + 16) = v10;
  uint64_t v15 = *(void *)(a2 + 24);
  uint64_t v16 = operator new(0x18uLL);
  uint64_t v18 = *(void *)(v15 + 8);
  uint64_t v17 = *(void *)(v15 + 16);
  *uint64_t v16 = off_1000D4218;
  v16[1] = v18;
  v16[2] = v17;
  if (v17)
  {
    uint64_t v19 = (unint64_t *)(v17 + 8);
    do
      unint64_t v20 = __ldxr(v19);
    while (__stxr(v20 + 1, v19));
  }

  *(void *)(a1 + ++*(void *)(result + 24) = v16;
  uint64_t v21 = *(void *)(a2 + 32);
  unsigned int v22 = operator new(0x18uLL);
  uint64_t v24 = *(void *)(v21 + 8);
  uint64_t v23 = *(void *)(v21 + 16);
  *unsigned int v22 = off_1000D4218;
  v22[1] = v24;
  v22[2] = v23;
  if (v23)
  {
    int v25 = (unint64_t *)(v23 + 8);
    do
      unint64_t v26 = __ldxr(v25);
    while (__stxr(v26 + 1, v25));
  }

  *(void *)(a1 + 32) = v22;
  return a1;
}

void sub_10005D328(_Unwind_Exception *a1)
{
  v1[3] = 0LL;
  (*(void (**)(uint64_t))(v3 + 24))(v2);
  uint64_t v5 = v1[2];
  v1[2] = 0LL;
  if (v5) {
    (*(void (**)(uint64_t))(*(void *)v5 + 8LL))(v5);
  }
  uint64_t v6 = v1[1];
  v1[1] = 0LL;
  if (v6) {
    (*(void (**)(uint64_t))(*(void *)v6 + 8LL))(v6);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_10005D390(uint64_t a1, uint64_t a2)
{
  if (a2 != a1)
  {
    sub_10005D40C(*(void *)(a1 + 8), *(void *)(a2 + 8));
    sub_10002CF84((void *)(*(void *)(a1 + 16) + 8LL), (uint64_t *)(*(void *)(a2 + 16) + 8LL));
    sub_10002CF84((void *)(*(void *)(a1 + 24) + 8LL), (uint64_t *)(*(void *)(a2 + 24) + 8LL));
    sub_10002CF84((void *)(*(void *)(a1 + 32) + 8LL), (uint64_t *)(*(void *)(a2 + 32) + 8LL));
    *(_BYTE *)a1 = *(_BYTE *)a2;
  }

  return a1;
}

uint64_t sub_10005D40C(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(std::__shared_weak_count **)(a2 + 16);
  uint64_t v10 = *(void *)(a2 + 8);
  uint64_t v11 = v3;
  if (v3)
  {
    p_shared_owners = (unint64_t *)&v3->__shared_owners_;
    do
      unint64_t v5 = __ldxr(p_shared_owners);
    while (__stxr(v5 + 1, p_shared_owners));
  }

  sub_10002CF84((void *)(a1 + 8), &v10);
  uint64_t v6 = v11;
  if (v11)
  {
    uint64_t v7 = (unint64_t *)&v11->__shared_owners_;
    do
      unint64_t v8 = __ldaxr(v7);
    while (__stlxr(v8 - 1, v7));
    if (!v8)
    {
      ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
      std::__shared_weak_count::__release_weak(v6);
    }
  }

  return a1;
}

void sub_10005D498(uint64_t a1, int __val)
{
  uint64_t v3 = (*(uint64_t (**)(void, std::string *))(**(void **)(a1 + 32) + 80LL))(*(void *)(a1 + 32), &v4);
  if (v3 == -1)
  {
    uint64_t v3 = (*(int (**)(void))(**(void **)(a1 + 8) + 176LL))(*(void *)(a1 + 8));
    (*(void (**)(void, std::string *, uint64_t))(**(void **)(a1 + 32) + 24LL))( *(void *)(a1 + 32),  &v4,  v3);
  }

  (*(void (**)(void, uint64_t))(**(void **)(a1 + 8) + 152LL))(*(void *)(a1 + 8), v3);
}

void sub_10005D538( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_10005D554(uint64_t a1, int __val, double a3)
{
  uint64_t v5 = (*(uint64_t (**)(void, std::string *))(**(void **)(a1 + 32) + 80LL))(*(void *)(a1 + 32), &v9);
  if (v5 == -1)
  {
    uint64_t v5 = (*(int (**)(void))(**(void **)(a1 + 8) + 176LL))(*(void *)(a1 + 8));
    (*(void (**)(void, std::string *, uint64_t))(**(void **)(a1 + 32) + 24LL))( *(void *)(a1 + 32),  &v9,  v5);
  }

  uint64_t v6 = *(void *)(a1 + 8);
  float v7 = a3;
  float v8 = v7;
  (*(void (**)(uint64_t, uint64_t, float *))(*(void *)v6 + 160LL))(v6, v5, &v8);
}

void sub_10005D60C( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10005D628(uint64_t a1)
{
  uint64_t v2 = 24LL;
  if (!*(_BYTE *)a1) {
    uint64_t v2 = 16LL;
  }
  return (*(uint64_t (**)(void, void))(**(void **)(a1 + 8) + 264LL))( *(void *)(a1 + 8),  *(void *)(a1 + v2));
}

void sub_10005D67C(uint64_t a1, int __val, int a3, uint64_t a4, uint64_t a5, double a6)
{
  uint64_t v11 = (*(uint64_t (**)(void, std::string *))(**(void **)(a1 + 32) + 80LL))(*(void *)(a1 + 32), &v20);
  if (v11 == -1)
  {
    uint64_t v11 = (*(int (**)(void))(**(void **)(a1 + 8) + 176LL))(*(void *)(a1 + 8));
    (*(void (**)(void, std::string *, uint64_t))(**(void **)(a1 + 32) + 24LL))( *(void *)(a1 + 32),  &v20,  v11);
  }

  std::to_string(&v19, a3);
  uint64_t v12 = (*(uint64_t (**)(void, std::string *))(**(void **)(a1 + 32) + 80LL))(*(void *)(a1 + 32), &v19);
  LODWORD(v13) = v12;
  if (v12 == -1)
  {
    uint64_t v13 = (*(int (**)(void))(**(void **)(a1 + 8) + 176LL))(*(void *)(a1 + 8));
    (*(void (**)(void, std::string *, uint64_t))(**(void **)(a1 + 32) + 24LL))( *(void *)(a1 + 32),  &v19,  v13);
  }

  int v14 = (*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 16) + 32LL))(*(void *)(a1 + 16), a4);
  int v15 = v14;
  if (*(_BYTE *)a1) {
    int v14 = (*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 24) + 32LL))(*(void *)(a1 + 24), a5);
  }
  uint64_t v16 = *(void *)(a1 + 8);
  float v17 = a6;
  v18[0] = v15;
  v18[1] = v14;
  *(float *)&v18[2] = v17;
  v18[3] = v13;
  (*(void (**)(uint64_t, uint64_t, _DWORD *))(*(void *)v16 + 184LL))(v16, v11, v18);
}

void sub_10005D7F8( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, void *a17, uint64_t a18, int a19, __int16 a20, char a21, char a22)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  if (a22 < 0) {
    operator delete(a17);
  }
  _Unwind_Resume(exception_object);
}

void sub_10005D83C(uint64_t a1, int a2, int a3, int __val, uint64_t a5, double a6)
{
}

void sub_10005D8B8( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_10005D8D4(uint64_t a1, int a2, int a3, uint64_t a4, int __val, double a6)
{
}

void sub_10005D950( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_10005D96C(uint64_t a1, int a2, int a3, int __val, int a5, double a6)
{
}

void sub_10005DA04( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if (a20 < 0) {
    operator delete(a15);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10005DA38(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 8) + 208LL))(*(void *)(a1 + 8));
}

void sub_10005DA48(uint64_t *a1@<X0>, int a2@<W1>, void *a3@<X8>)
{
  uint64_t v38 = (void **)operator new(0x28uLL);
  sub_10005CF28((uint64_t)v38, a2);
  sub_100059EB8(v56, a1, 8);
  int v6 = 0;
  memset(&v51, 0, sizeof(v51));
  while (1)
  {
    std::ios_base::getloc((const std::ios_base *)((char *)v56 + (unint64_t)*(v56[0] - 3)));
    std::string v9 = std::locale::use_facet(&v47, &std::ctype<char>::id);
    unsigned __int8 v10 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v9->__vftable[2].~facet_0)(v9, 10LL);
    std::locale::~locale(&v47);
    std::string v11 = sub_10006177C(v56, &v51, v10);
    if ((*((_BYTE *)v11 + *(void *)(*v11 - 24LL) + 32) & 5) != 0) {
      break;
    }
    sub_10005E398((void (__cdecl ***)(std::istringstream *__hidden))&v47, &v51, 8);
    std::string __str = 0LL;
    int v45 = 0LL;
    unint64_t v46 = 0LL;
    sub_10005E398((void (__cdecl ***)(std::istringstream *__hidden))v40, &v51, 8);
    ++v6;
    do
    {
      while (1)
      {
        memset(__p, 0, 24);
        std::string v12 = sub_10005E47C((uint64_t *)v40, __p);
        int v13 = *(_DWORD *)((_BYTE *)v12 + *(void *)(*v12 - 24) + 32) & 5;
        if (!v13)
        {
          int v14 = v45;
          if ((unint64_t)v45 >= v46)
          {
            uint64_t v16 = (std::string *)sub_100021048((uint64_t *)&__str, (__int128 *)__p);
          }

          else
          {
            if ((char)__p[0].__r_.__value_.__s.__size_ < 0)
            {
              sub_10005AA70(v45, __p[0].__r_.__value_.__l.__data_, __p[0].__r_.__value_.__l.__size_);
            }

            else
            {
              __int128 v15 = *(_OWORD *)&__p[0].__r_.__value_.__l.__data_;
              v45->__r_.__value_.__l.__cap_ = __p[0].__r_.__value_.__l.__cap_;
              *(_OWORD *)&v14->__r_.__value_.__l.__data_ = v15;
            }

            uint64_t v16 = v14 + 1;
          }

          int v45 = v16;
        }

        if (v13) {
          goto LABEL_16;
        }
      }

      operator delete(__p[0].__r_.__value_.__l.__data_);
    }

    while (!v13);
LABEL_16:
    double v39 = 0.0;
    uint64_t v17 = (char *)v45 - (char *)__str;
    if (v45 == __str)
    {
      unsigned int v22 = (os_log_s *)sub_1000A39A8();
      if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
      {
        LODWORD(__p[0].__r_.__value_.__l.__data_) = 67109120;
        HIDWORD(__p[0].__r_.__value_.__r.__words[0]) = v6;
        _os_log_impl( (void *)&_mh_execute_header,  v22,  OS_LOG_TYPE_ERROR,  "cmdp_fst_util::compileFstFromFile : empty line in automaton, line %d",  (uint8_t *)__p,  8u);
      }
    }

    else
    {
      unint64_t v18 = 0xAAAAAAAAAAAAAAABLL * (v17 >> 3);
      if (v18 > 2)
      {
        if (a2)
        {
          if (v18 <= 3)
          {
            uint64_t v23 = (os_log_s *)sub_1000A39A8();
            if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
            {
              LODWORD(__p[0].__r_.__value_.__l.__data_) = 67109120;
              HIDWORD(__p[0].__r_.__value_.__r.__words[0]) = v6;
              _os_log_impl( (void *)&_mh_execute_header,  v23,  OS_LOG_TYPE_ERROR,  "cmdp_fst_util::compileFstFromFile : missing output symbol in transducer, line %d",  (uint8_t *)__p,  8u);
            }
          }

          if ((char *)v45 - (char *)__str == 120)
          {
            sub_10005E398((void (__cdecl ***)(std::istringstream *__hidden))__p, __str + 4, 8);
            std::istream::operator>>(__p, &v39);
            int v24 = *(_DWORD *)((char *)&__p[1].__r_.__value_.__r.__words[1]
                            + *(void *)(__p[0].__r_.__value_.__r.__words[0] - 24));
            __p[0].__r_.__value_.__r.__words[0] = (std::string::size_type)v7;
            *(std::string::size_type *)((char *)__p[0].__r_.__value_.__r.__words + (void)*(v7 - 3)) = (std::string::size_type)v8;
            if (v54 < 0) {
              operator delete(v53);
            }
            std::streambuf::~streambuf(&__p[0].__r_.__value_.__r.__words[2]);
            std::ios::~ios(v55);
            if ((v24 & 5) != 0)
            {
              int v25 = (os_log_s *)sub_1000A39A8();
              if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
              {
                LODWORD(__p[0].__r_.__value_.__l.__data_) = 67109120;
                HIDWORD(__p[0].__r_.__value_.__r.__words[0]) = v6;
                _os_log_impl( (void *)&_mh_execute_header,  v25,  OS_LOG_TYPE_ERROR,  "cmdp_fst_util::compileFstFromFile : weight not a valid number, line %d",  (uint8_t *)__p,  8u);
              }
            }
          }

          if (0xAAAAAAAAAAAAAAABLL * (((char *)v45 - (char *)__str) >> 3) >= 6)
          {
            unint64_t v26 = (os_log_s *)sub_1000A39A8();
            if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
            {
              LODWORD(__p[0].__r_.__value_.__l.__data_) = 67109120;
              HIDWORD(__p[0].__r_.__value_.__r.__words[0]) = v6;
              _os_log_impl( (void *)&_mh_execute_header,  v26,  OS_LOG_TYPE_ERROR,  "cmdp_fst_util::compileFstFromFile : too many fields in transudcer, line %d",  (uint8_t *)__p,  8u);
            }
          }

          int v27 = std::stoi(__str, 0LL, 10);
          int v28 = std::stoi(__str + 1, 0LL, 10);
          unint64_t v29 = __str + 2;
          uint64_t v30 = __str + 3;
          double v31 = v39;
        }

        else
        {
          if (v17 == 96)
          {
            sub_10005E398((void (__cdecl ***)(std::istringstream *__hidden))__p, __str + 3, 8);
            std::istream::operator>>(__p, &v39);
            int v32 = *(_DWORD *)((char *)&__p[1].__r_.__value_.__r.__words[1]
                            + *(void *)(__p[0].__r_.__value_.__r.__words[0] - 24));
            __p[0].__r_.__value_.__r.__words[0] = (std::string::size_type)v7;
            *(std::string::size_type *)((char *)__p[0].__r_.__value_.__r.__words + (void)*(v7 - 3)) = (std::string::size_type)v8;
            if (v54 < 0) {
              operator delete(v53);
            }
            std::streambuf::~streambuf(&__p[0].__r_.__value_.__r.__words[2]);
            std::ios::~ios(v55);
            if ((v32 & 5) != 0)
            {
              unint64_t v33 = (os_log_s *)sub_1000A39A8();
              if (os_log_type_enabled(v33, OS_LOG_TYPE_ERROR))
              {
                LODWORD(__p[0].__r_.__value_.__l.__data_) = 67109120;
                HIDWORD(__p[0].__r_.__value_.__r.__words[0]) = v6;
                _os_log_impl( (void *)&_mh_execute_header,  v33,  OS_LOG_TYPE_ERROR,  "cmdp_fst_util::compileFstFromFile :  weight not a valid number, line %d",  (uint8_t *)__p,  8u);
              }
            }
          }

          if (0xAAAAAAAAAAAAAAABLL * (((char *)v45 - (char *)__str) >> 3) >= 5)
          {
            __int128 v34 = (os_log_s *)sub_1000A39A8();
            if (os_log_type_enabled(v34, OS_LOG_TYPE_ERROR))
            {
              LODWORD(__p[0].__r_.__value_.__l.__data_) = 67109120;
              HIDWORD(__p[0].__r_.__value_.__r.__words[0]) = v6;
              _os_log_impl( (void *)&_mh_execute_header,  v34,  OS_LOG_TYPE_ERROR,  "cmdp_fst_util::compileFstFromFile : too many fields in acceptor, line %d",  (uint8_t *)__p,  8u);
            }
          }

          int v27 = std::stoi(__str, 0LL, 10);
          int v28 = std::stoi(__str + 1, 0LL, 10);
          unint64_t v29 = __str + 2;
          double v31 = 0.0;
          uint64_t v30 = __str + 2;
        }

        sub_10005D67C((uint64_t)v38, v27, v28, (uint64_t)v29, (uint64_t)v30, v31);
      }

      else
      {
        if (v17 == 48)
        {
          sub_10005E398((void (__cdecl ***)(std::istringstream *__hidden))__p, __str + 1, 8);
          std::istream::operator>>(__p, &v39);
          int v19 = *(_DWORD *)((char *)&__p[1].__r_.__value_.__r.__words[1]
                          + *(void *)(__p[0].__r_.__value_.__r.__words[0] - 24));
          __p[0].__r_.__value_.__r.__words[0] = (std::string::size_type)v7;
          *(std::string::size_type *)((char *)__p[0].__r_.__value_.__r.__words + (void)*(v7 - 3)) = (std::string::size_type)v8;
          if (v54 < 0) {
            operator delete(v53);
          }
          std::streambuf::~streambuf(&__p[0].__r_.__value_.__r.__words[2]);
          std::ios::~ios(v55);
          if ((v19 & 5) != 0)
          {
            std::string v20 = (os_log_s *)sub_1000A39A8();
            if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
            {
              LODWORD(__p[0].__r_.__value_.__l.__data_) = 67109120;
              HIDWORD(__p[0].__r_.__value_.__r.__words[0]) = v6;
              _os_log_impl( (void *)&_mh_execute_header,  v20,  OS_LOG_TYPE_ERROR,  "cmdp_fst_util::compileFstFromFile : weight not a valid number, line %d",  (uint8_t *)__p,  8u);
            }
          }
        }

        int v21 = std::stoi(__str, 0LL, 10);
        sub_10005D554((uint64_t)v38, v21, v39);
      }
    }

    v40[0] = v7;
    *(void ***)((char *)v40 + (void)*(v7 - 3)) = v8;
    if (v42 < 0) {
      operator delete((void *)v41[8]);
    }
    std::streambuf::~streambuf(v41);
    std::ios::~ios(&v43);
    v40[0] = (void **)&__str;
    sub_10001FAA8(v40);
    v47.__locale_ = (std::locale::__imp *)v7;
    *(std::locale::__imp **)((char *)&v47.__locale_ + (void)*(v7 - 3)) = (std::locale::__imp *)v8;
    if (v49 < 0) {
      operator delete((void *)v48[8]);
    }
    std::streambuf::~streambuf(v48);
    std::ios::~ios(&v50);
  }

  sub_10005D498((uint64_t)v38, 0);
  (*(void (**)(void *, void *))(*v38[1] + 256LL))(v38[1], v38[2]);
  uint64_t v35 = 3LL;
  if (!*(_BYTE *)v38) {
    uint64_t v35 = 2LL;
  }
  (*(void (**)(void *, void *))(*v38[1] + 264LL))(v38[1], v38[v35]);
  uint64_t v36 = v38[1];
  v38[1] = 0LL;
  *a3 = v36;
  std::filebuf::~filebuf(&v57);
  std::ios::~ios(&v58);
  uint64_t v37 = sub_1000292E0(v38);
  operator delete(v37);
}

void sub_10005E2A8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18)
{
  int v19 = sub_1000292E0(a18);
  operator delete(v19);
  _Unwind_Resume(a1);
}

void (__cdecl ***sub_10005E398( void (__cdecl ***a1)(std::istringstream *__hidden this), const std::string *a2, int a3))(std::istringstream *__hidden this)
{
  uint64_t v6 = (uint64_t)(a1 + 2);
  *a1 = v7;
  *(void *)((char *)*(v7 - 3) + (void)a1) = v8;
  a1[1] = 0LL;
  std::string v9 = (std::ios_base *)((char *)*(*a1 - 3) + (void)a1);
  std::ios_base::init(v9, a1 + 2);
  v9[1].__vftable = 0LL;
  v9[1].__fmtflags_ = -1;
  sub_100061900(v6, a2, a3 | 8);
  return a1;
}

void sub_10005E454(_Unwind_Exception *a1)
{
}

uint64_t *sub_10005E47C(uint64_t *a1, std::string *a2)
{
  if (!v20) {
    return a1;
  }
  if ((char)a2->__r_.__value_.__s.__size_ < 0)
  {
    *a2->__r_.__value_.__l.__data_ = 0;
    a2->__r_.__value_.__l.__size_ = 0LL;
  }

  else
  {
    a2->__r_.__value_.__s.__data_[0] = 0;
    a2->__r_.__value_.__s.__size_ = 0;
  }

  uint64_t v4 = *(void *)(*a1 - 24);
  uint64_t v5 = *(uint64_t *)((char *)a1 + v4 + 24);
  if (v5 <= 1) {
    uint64_t v6 = 1LL;
  }
  else {
    uint64_t v6 = *(uint64_t *)((char *)a1 + v4 + 24);
  }
  std::ios_base::getloc((const std::ios_base *)((char *)a1 + v4));
  float v7 = std::locale::use_facet(&v19, &std::ctype<char>::id);
  std::locale::~locale(&v19);
  uint64_t v8 = 0LL;
  std::string v9 = a1 + 5;
  if (v5 >= 1) {
    uint64_t v10 = v6;
  }
  else {
    uint64_t v10 = 0x7FFFFFFFFFFFFFF7LL;
  }
  while (1)
  {
    std::string v11 = *(void **)((char *)v9 + *(void *)(*a1 - 24));
    std::string v12 = (_BYTE *)v11[3];
    if (v12 == (_BYTE *)v11[4]) {
      break;
    }
    LOBYTE(v13) = *v12;
LABEL_14:
    if ((v13 & 0x80) == 0 && (*((_DWORD *)&v7[1].~facet + v13) & 0x4000) != 0)
    {
      int v16 = 0;
      goto LABEL_23;
    }

    std::string::push_back(a2, v13);
    int v14 = *(void **)((char *)v9 + *(void *)(*a1 - 24));
    uint64_t v15 = v14[3];
    if (v15 == v14[4]) {
      (*(void (**)(void *))(*v14 + 80LL))(v14);
    }
    else {
      v14[3] = v15 + 1;
    }
    if (v10 == ++v8)
    {
      int v16 = 0;
      uint64_t v17 = *a1;
      *(uint64_t *)((char *)a1 + *(void *)(*a1 - 24) + ++*(void *)(result + 24) = 0LL;
      goto LABEL_25;
    }
  }

  int v13 = (*(uint64_t (**)(void *))(*v11 + 72LL))(v11);
  if (v13 != -1) {
    goto LABEL_14;
  }
  int v16 = 2;
LABEL_23:
  uint64_t v17 = *a1;
  *(uint64_t *)((char *)a1 + *(void *)(*a1 - 24) + ++*(void *)(result + 24) = 0LL;
  if (!v8) {
    v16 |= 4u;
  }
LABEL_25:
  std::ios_base::clear( (std::ios_base *)((char *)a1 + *(void *)(v17 - 24)),  *(_DWORD *)((char *)a1 + *(void *)(v17 - 24) + 32) | v16);
  return a1;
}

void sub_10005E630( void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, std::locale a9)
{
  uint64_t v11 = *v9;
  *(_DWORD *)((char *)v9 + *(void *)(*v9 - 24LL) + 32) |= 1u;
  if ((*((_BYTE *)v9 + *(void *)(v11 - 24) + 36) & 1) == 0)
  {
    __cxa_end_catch();
    JUMPOUT(0x10005E5FCLL);
  }

  __cxa_rethrow();
}

void sub_10005E694(_Unwind_Exception *a1)
{
}

uint64_t sub_10005E6A8(uint64_t a1)
{
  uint64_t v3 = a1 + 16;
  std::streambuf::~streambuf(v3);
  std::ios::~ios(a1 + 120);
  return a1;
}

void sub_10005E72C(uint64_t a1@<X0>, uint64_t a2@<X1>, int a3@<W2>, void *a4@<X8>)
{
  if (a1 && a2)
  {
    uint64_t v7 = (*(uint64_t (**)(uint64_t, void))(*(void *)a1 + 72LL))(a1, 0LL);
    uint64_t v8 = (*(uint64_t (**)(uint64_t, void))(*(void *)a2 + 72LL))(a2, 0LL);
    uint64_t v9 = (*(uint64_t (**)(uint64_t))(*(void *)v7 + 104LL))(v7);
    uint64_t v10 = (*(uint64_t (**)(uint64_t))(*(void *)v8 + 96LL))(v8);
    uint64_t v11 = sub_10009BCB0(v9, v10, &v29);
    sub_10000A2DC(__p, "<rho>");
    int v12 = (*(uint64_t (**)(void *, void **))(*v11 + 80LL))(v11, __p);
    if (SHIBYTE(v25) < 0) {
      operator delete(__p[0]);
    }
    sub_10000A2DC(__p, "<sigma>");
    int v13 = (*(uint64_t (**)(void *, void **))(*v11 + 80LL))(v11, __p);
    if (SHIBYTE(v25) < 0) {
      operator delete(__p[0]);
    }
    sub_10000A2DC(__p, "<phi>");
    int v14 = (*(uint64_t (**)(void *, void **))(*v11 + 80LL))(v11, __p);
    if (SHIBYTE(v25) < 0) {
      operator delete(__p[0]);
    }
    uint64_t v15 = (*(uint64_t (**)(uint64_t))(*(void *)v7 + 96LL))(v7);
    uint64_t v16 = (*(uint64_t (**)(uint64_t))(*(void *)v7 + 104LL))(v7);
    sub_100061AA0(v7, v15, 0LL, 1, v16, (uint64_t)v11, 1);
    uint64_t v17 = (*(uint64_t (**)(uint64_t))(*(void *)v8 + 96LL))(v8);
    uint64_t v18 = (*(uint64_t (**)(uint64_t))(*(void *)v8 + 104LL))(v8);
    sub_100061AA0(v8, v17, (uint64_t)v11, 1, v18, 0LL, 1);
    if (a3)
    {
      sub_10005EB80(v7);
      sub_10005EBE8(v8);
    }

    LOBYTE(__p[0]) = byte_1000DDB00;
    uint64_t v27 = 0LL;
    uint64_t v28 = 0LL;
    __p[1] = (void *)qword_1000DDB08;
    std::locale v19 = operator new(0x48uLL);
    sub_100065248(v19, v7, 2, v12, v13, v14, 0LL);
    int v25 = v19;
    char v20 = operator new(0x48uLL);
    sub_100065248(v20, v8, 1, v12, v13, v14, 0LL);
    unint64_t v26 = v20;
    int v21 = (char *)operator new(0x18uLL);
    sub_100068238(v7, v8, (uint64_t)__p, &v30);
    *(_OWORD *)(v21 + std::istream::~istream(v2, v3 + 8) = v30;
    *(void *)int v21 = off_1000D10C8;
    *a4 = 0LL;
    unsigned int v22 = operator new(0x18uLL);
    sub_1000730D0(v22, (uint64_t)v21);
    *a4 = v22;
    sub_10005EC50((uint64_t)v22);
    (*(void (**)(char *))(*(void *)v21 + 8LL))(v21);
    (*(void (**)(void *))(*v11 + 8LL))(v11);
    (*(void (**)(uint64_t))(*(void *)v8 + 8LL))(v8);
    (*(void (**)(uint64_t))(*(void *)v7 + 8LL))(v7);
  }

  else
  {
    uint64_t v23 = (os_log_s *)sub_1000A39A8();
    if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
    {
      LOWORD(__p[0]) = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v23,  OS_LOG_TYPE_ERROR,  "cmdp_fst_util::composeFst : null FSTs",  (uint8_t *)__p,  2u);
    }

    *a4 = 0LL;
  }

void sub_10005EA80( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  *uint64_t v17 = 0LL;
  (*(void (**)(uint64_t))(*(void *)v19 + 8LL))(v19);
  (*(void (**)(uint64_t))(*(void *)v18 + 8LL))(v18);
  (*(void (**)(uint64_t))(*(void *)v16 + 8LL))(v16);
  (*(void (**)(uint64_t))(*(void *)v15 + 8LL))(v15);
  (*(void (**)(uint64_t))(*(void *)v14 + 8LL))(v14);
  _Unwind_Resume(a1);
}

void sub_10005EB80(uint64_t a1)
{
  v1[0] = a1;
  v1[1] = (uint64_t)&v4;
  *(_OWORD *)std::string __p = 0u;
  __int128 v3 = 0u;
  sub_100062BE0(a1, v1);
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }

void sub_10005EBCC( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_10005EBE8(uint64_t a1)
{
  v1[0] = a1;
  v1[1] = (uint64_t)&v4;
  *(_OWORD *)std::string __p = 0u;
  __int128 v3 = 0u;
  sub_100063F3C(a1, v1);
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }

void sub_10005EC34( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_10005EC50(uint64_t a1)
{
  int v25 = 0LL;
  unint64_t v26 = 0LL;
  uint64_t v27 = 0LL;
  memset(v24, 0, sizeof(v24));
  uint64_t v23 = 0LL;
  v20[0] = 0LL;
  v20[1] = (uint64_t)&v25;
  void v20[2] = (uint64_t)v24;
  v20[3] = (uint64_t)&v23;
  *(_OWORD *)int v21 = 0u;
  *(_OWORD *)unsigned int v22 = 0u;
  sub_10005B86C(a1, v20, 0);
  std::string __p = 0LL;
  uint64_t v18 = 0LL;
  uint64_t v19 = 0LL;
  unint64_t v2 = v26;
  if (v26)
  {
    __int128 v3 = 0LL;
    unint64_t v4 = 0LL;
    do
    {
      if ((v25[v4 >> 6] & (1LL << v4)) == 0 || (*((void *)v24[0] + (v4 >> 6)) & (1LL << v4)) == 0)
      {
        if (v3 >= v19)
        {
          uint64_t v6 = (char *)__p;
          uint64_t v7 = (v3 - (_BYTE *)__p) >> 2;
          unint64_t v8 = v7 + 1;
          uint64_t v9 = v19 - (_BYTE *)__p;
          if ((v19 - (_BYTE *)__p) >> 1 > v8) {
            unint64_t v8 = v9 >> 1;
          }
          else {
            unint64_t v10 = v8;
          }
          if (v10)
          {
            uint64_t v11 = (char *)sub_10002C050((uint64_t)&v19, v10);
            uint64_t v6 = (char *)__p;
            __int128 v3 = v18;
          }

          else
          {
            uint64_t v11 = 0LL;
          }

          int v12 = &v11[4 * v7];
          *(_DWORD *)int v12 = v4;
          uint64_t v5 = v12 + 4;
          while (v3 != v6)
          {
            int v13 = *((_DWORD *)v3 - 1);
            v3 -= 4;
            *((_DWORD *)v12 - 1) = v13;
            v12 -= 4;
          }

          std::string __p = v12;
          uint64_t v18 = v5;
          uint64_t v19 = &v11[4 * v10];
          if (v6) {
            operator delete(v6);
          }
        }

        else
        {
          *(_DWORD *)__int128 v3 = v4;
          uint64_t v5 = v3 + 4;
        }

        uint64_t v18 = v5;
        unint64_t v2 = v26;
        __int128 v3 = v5;
      }

      ++v4;
    }

    while (v2 > v4);
  }

  (*(void (**)(uint64_t, void **))(*(void *)a1 + 192LL))(a1, &__p);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)a1 + 168LL))(a1, 0x50000000000LL, 0x50000000000LL);
  if (__p)
  {
    uint64_t v18 = (char *)__p;
    operator delete(__p);
  }

  uint64_t v14 = (void **)v22[1];
  v22[1] = 0LL;
  if (v14) {
    sub_10002B7A4((int)&v22[1], v14);
  }
  sub_10002B764((void ***)v22, 0LL);
  uint64_t v15 = (void **)v21[1];
  v21[1] = 0LL;
  if (v15) {
    sub_10002B7A4((int)&v21[1], v15);
  }
  uint64_t v16 = (void **)v21[0];
  v21[0] = 0LL;
  if (v16) {
    sub_10002B7A4((int)v21, v16);
  }
  if (v24[0]) {
    operator delete(v24[0]);
  }
  if (v25) {
    operator delete(v25);
  }
}

void sub_10005EE88( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, void **a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, void *__p)
{
  if (__p) {
    operator delete(__p);
  }
  uint64_t v27 = *(void **)(v25 - 104);
  if (v27) {
    operator delete(v27);
  }
  _Unwind_Resume(a1);
}

void sub_10005EED4(uint64_t a1@<X0>, uint64_t *a2@<X1>, void *a3@<X8>)
{
  uint64_t v6 = *a2;
  uint64_t v7 = a2[1];
  if (*a2 == v7)
  {
    int v12 = 0LL;
  }

  else
  {
    uint64_t v8 = 0LL;
    do
    {
      uint64_t v9 = *(void *)(v6 + 24);
      uint64_t v10 = (*(uint64_t (**)(uint64_t))(*(void *)v9 + 96LL))(v9);
      uint64_t v11 = (*(uint64_t (**)(uint64_t))(*(void *)v9 + 104LL))(v9);
      int v12 = sub_10009BCB0(v10, v11, &v58);
      if (v8)
      {
        int v13 = sub_10009BCB0(v8, (uint64_t)v12, &v58);
        (*(void (**)(uint64_t))(*(void *)v8 + 8LL))(v8);
        (*(void (**)(void *))(*v12 + 8LL))(v12);
        int v12 = v13;
      }

      v6 += 32LL;
      uint64_t v8 = (uint64_t)v12;
    }

    while (v6 != v7);
  }

  uint64_t v14 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 96LL))(a1);
  uint64_t v15 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 104LL))(a1);
  uint64_t v16 = sub_10009BCB0(v14, v15, &v58);
  uint64_t v17 = sub_10009BCB0((uint64_t)v12, (uint64_t)v16, &v58);
  (*(void (**)(void *))(*v12 + 8LL))(v12);
  (*(void (**)(void *))(*v16 + 8LL))(v16);
  uint64_t v18 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 96LL))(a1);
  uint64_t v19 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 104LL))(a1);
  sub_100061AA0(a1, v18, (uint64_t)v17, 1, v19, (uint64_t)v17, 1);
  std::string __p = 0LL;
  uint64_t v56 = 0LL;
  uint64_t v57 = 0LL;
  char v20 = (char *)sub_1000198A8((uint64_t)&v57, 1uLL);
  unsigned int v22 = &v20[16 * v21];
  *(_DWORD *)char v20 = -1;
  *((void *)v20 + 1) = a1;
  uint64_t v23 = v20 + 16;
  uint64_t v25 = (char *)__p;
  int v24 = v56;
  if (v56 != __p)
  {
    do
    {
      *((_OWORD *)v20 - 1) = *((_OWORD *)v24 - 1);
      v20 -= 16;
      v24 -= 16;
    }

    while (v24 != v25);
    int v24 = (char *)__p;
  }

  std::string __p = v20;
  uint64_t v56 = v23;
  uint64_t v57 = v22;
  if (v24) {
    operator delete(v24);
  }
  uint64_t v56 = v23;
  uint64_t v26 = *a2;
  uint64_t v27 = a2[1];
  if (*a2 != v27)
  {
    do
    {
      int v28 = (*(uint64_t (**)(void *, uint64_t))(*v17 + 80LL))(v17, v26);
      uint64_t v29 = *(void *)(v26 + 24);
      uint64_t v30 = (*(uint64_t (**)(uint64_t))(*(void *)v29 + 96LL))(v29);
      uint64_t v31 = (*(uint64_t (**)(uint64_t))(*(void *)v29 + 104LL))(v29);
      sub_100061AA0(v29, v30, (uint64_t)v17, 1, v31, (uint64_t)v17, 1);
      int v32 = v56;
      if (v56 >= v57)
      {
        uint64_t v34 = (v56 - (_BYTE *)__p) >> 4;
        unint64_t v35 = v34 + 1;
        uint64_t v36 = v57 - (_BYTE *)__p;
        if ((v57 - (_BYTE *)__p) >> 3 > v35) {
          unint64_t v35 = v36 >> 3;
        }
        else {
          unint64_t v37 = v35;
        }
        uint64_t v38 = (char *)sub_1000198A8((uint64_t)&v57, v37);
        uint64_t v40 = &v38[16 * v34];
        *(_DWORD *)uint64_t v40 = v28;
        *((void *)v40 + 1) = v29;
        char v42 = (char *)__p;
        int v41 = v56;
        uint64_t v43 = v40;
        if (v56 != __p)
        {
          do
          {
            *((_OWORD *)v43 - 1) = *((_OWORD *)v41 - 1);
            v43 -= 16;
            v41 -= 16;
          }

          while (v41 != v42);
          int v41 = (char *)__p;
        }

        unint64_t v33 = v40 + 16;
        std::string __p = v43;
        uint64_t v56 = v40 + 16;
        uint64_t v57 = &v38[16 * v39];
        if (v41) {
          operator delete(v41);
        }
      }

      else
      {
        *(_DWORD *)uint64_t v56 = v28;
        *((void *)v32 + 1) = v29;
        unint64_t v33 = v32 + 16;
      }

      uint64_t v56 = v33;
      v26 += 32LL;
    }

    while (v26 != v27);
  }

  v47[0] = byte_1000DDB00;
  uint64_t v48 = qword_1000DDB08;
  uint64_t v49 = 0LL;
  char v50 = 1;
  __int128 v51 = xmmword_1000AC960;
  int v52 = 0;
  char v53 = 0;
  uint64_t v54 = 0LL;
  uint64_t v44 = (char *)operator new(0x18uLL);
  sub_1000734B8((uint64_t *)&__p, (uint64_t)v47, &v59);
  uint64_t v45 = v59;
  *(_OWORD *)(v44 + std::istream::~istream(v2, v3 + 8) = v59;
  *(void *)uint64_t v44 = off_1000D2630;
  *a3 = 0LL;
  if ((sub_10007A9E0(v45) & 1) == 0)
  {
    unint64_t v46 = operator new(0x18uLL);
    sub_1000730D0(v46, (uint64_t)v44);
    *a3 = v46;
    sub_10005EC50((uint64_t)v46);
    sub_10005F3EC(v46);
  }

  (*(void (**)(char *))(*(void *)v44 + 8LL))(v44);
  if (__p)
  {
    uint64_t v56 = (char *)__p;
    operator delete(__p);
  }

  if (v17) {
    (*(void (**)(void *))(*v17 + 8LL))(v17);
  }
}

void sub_10005F300( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18)
{
  void *v19 = 0LL;
  (*(void (**)(uint64_t))(*(void *)v20 + 8LL))(v20);
  if (__p) {
    operator delete(__p);
  }
  if (v18) {
    (*(void (**)(uint64_t))(*(void *)v18 + 8LL))(v18);
  }
  _Unwind_Resume(a1);
}

void sub_10005F3EC(void *a1)
{
  if (a1)
  {
    int v2 = *sub_10002ADB0();
    sub_10005F4CC(a1, 1, &v2, -1, 0.000001);
  }

void sub_10005F43C(uint64_t a1)
{
  if (!a1)
  {
    int v5 = 1;
    uint64_t v2 = 0x100000001LL;
    sub_10007BC9C(&v5, &v3);
    char v4 = 0;
    int v1 = *sub_10002ADB0();
    sub_10005F4CC(0LL, 1, &v1, -1, 0.000001);
    __break(1u);
  }

void sub_10005F4B8(_Unwind_Exception *a1)
{
}

void sub_10005F4CC(void *a1, char a2, int *a3, int a4, float a5)
{
  uint64_t v19 = 0LL;
  uint64_t v20 = 0LL;
  uint64_t v21 = 0LL;
  sub_10007CB0C((uint64_t)v18, (uint64_t)a1, (uint64_t)&v19);
  int v10 = *a3;
  uint64_t v11 = v18;
  int v12 = -1;
  float v13 = a5;
  char v14 = 0;
  char v15 = a2;
  int v16 = v10;
  int v17 = a4;
  sub_10007C024(a1, &v19, (uint64_t)&v11);
  sub_10008E2A4((uint64_t)v18);
  if (v19)
  {
    uint64_t v20 = v19;
    operator delete(v19);
  }

void sub_10005F580(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  uint64_t v7 = *(void **)(v5 - 88);
  if (v7)
  {
    *(void *)(v5 - 8RDString::RDString((RDString *)&v66, theString, 0) = v7;
    operator delete(v7);
  }

  _Unwind_Resume(a1);
}

uint64_t sub_10005F5AC@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  __int16 v19 = 0;
  uint64_t v6 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 96LL))(a1);
  uint64_t v7 = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 96LL))(a2);
  uint64_t v8 = sub_10009BCB0(v6, v7, (_BYTE *)&v19 + 1);
  uint64_t v9 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 104LL))(a1);
  uint64_t v10 = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 104LL))(a2);
  uint64_t v11 = sub_10009BCB0(v9, v10, &v19);
  uint64_t v12 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 96LL))(a1);
  uint64_t v13 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 104LL))(a1);
  sub_100061AA0(a1, v12, (uint64_t)v8, 1, v13, (uint64_t)v11, 1);
  uint64_t v14 = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 96LL))(a2);
  uint64_t v15 = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 104LL))(a2);
  sub_100061AA0(a2, v14, (uint64_t)v8, 1, v15, (uint64_t)v11, 1);
  int v16 = operator new(0x18uLL);
  sub_10008E310((uint64_t)v16, a1, a2);
  *a3 = 0LL;
  int v17 = operator new(0x18uLL);
  sub_1000730D0(v17, (uint64_t)v16);
  *a3 = v17;
  uint64_t result = (*(uint64_t (**)(void *))(*(void *)v16 + 8LL))(v16);
  if (v11) {
    uint64_t result = (*(uint64_t (**)(void *))(*v11 + 8LL))(v11);
  }
  if (v8) {
    return (*(uint64_t (**)(void *))(*v8 + 8LL))(v8);
  }
  return result;
}

void sub_10005F74C(_Unwind_Exception *a1)
{
  void *v2 = 0LL;
  (*(void (**)(uint64_t))(*(void *)v5 + 8LL))(v5);
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8LL))(v3);
  }
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8LL))(v1);
  }
  _Unwind_Resume(a1);
}

void *sub_10005F7C8@<X0>(uint64_t **a1@<X0>, uint64_t *a2@<X8>)
{
  if ((unint64_t)((char *)a1[1] - (char *)*a1) > 0xF)
  {
    uint64_t result = (void *)sub_10005F5AC(**a1, (*a1)[1], a2);
    uint64_t v11 = *a1;
    uint64_t v10 = (char *)a1[1];
    uint64_t v12 = v10 - (char *)*a1;
    if ((unint64_t)v12 >= 0x11)
    {
      unint64_t v13 = v12 >> 3;
      uint64_t v14 = *a2;
      unint64_t v15 = 2LL;
      do
      {
        if (v15 != v13 - 1)
        {
          uint64_t result = (void *)sub_10005F5AC(v14, v11[v15], &v17);
          uint64_t v16 = v17;
          *a2 = v17;
          if (v14) {
            uint64_t result = (void *)(*(uint64_t (**)(uint64_t))(*(void *)v14 + 8LL))(v14);
          }
          uint64_t v11 = *a1;
          uint64_t v10 = (char *)a1[1];
          uint64_t v14 = v16;
        }

        ++v15;
        unint64_t v13 = (v10 - (char *)v11) >> 3;
      }

      while (v13 > v15);
    }
  }

  else
  {
    char v4 = (os_log_s *)sub_1000A39A8();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_INFO,  "cmdp_fst_util::unionFst : Need more than 1 FST for union. Returning 1st FST",  buf,  2u);
    }

    if (a1[1] == *a1) {
      sub_100019C44();
    }
    uint64_t v5 = **a1;
    uint64_t result = operator new(0x18uLL);
    uint64_t v7 = *(void *)(v5 + 16);
    result[1] = *(void *)(v5 + 8);
    result[2] = v7;
    if (v7)
    {
      uint64_t v8 = (unint64_t *)(v7 + 8);
      do
        unint64_t v9 = __ldxr(v8);
      while (__stxr(v9 + 1, v8));
    }

    void *result = off_1000D06D8;
    *a2 = (uint64_t)result;
  }

  return result;
}

void sub_10005F91C(_Unwind_Exception *exception_object)
{
  void *v1 = 0LL;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8LL))(v2);
  }
  _Unwind_Resume(exception_object);
}

void sub_10005F940(uint64_t a1, int a2)
{
  if (a2) {
    sub_10005EBE8(a1);
  }
  else {
    sub_10005EB80(a1);
  }
}

uint64_t sub_10005F94C(void *a1)
{
  uint64_t v5 = 0LL;
  uint64_t v6 = 0LL;
  std::string __p = 0LL;
  uint64_t v2 = (*(uint64_t (**)(void *))(*a1 + 16LL))(a1);
  sub_10005F9C4(a1, v2, (uint64_t)&__p);
  if (__p)
  {
    uint64_t v5 = __p;
    operator delete(__p);
  }

  return 0LL;
}

void sub_10005F9A8( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_10005F9C4(void *a1, uint64_t a2, uint64_t a3)
{
  if ((_DWORD)a2 != -1)
  {
    uint64_t v6 = *(__int32 **)(a3 + 8);
    uint64_t v7 = wmemchr(*(const __int32 **)a3, a2, ((uint64_t)v6 - *(void *)a3) >> 2);
    uint64_t v8 = v7 ? v7 : v6;
    unint64_t v9 = *(__int32 **)(a3 + 8);
    if (v8 == v9)
    {
      unint64_t v10 = *(void *)(a3 + 16);
      if ((unint64_t)v8 >= v10)
      {
        uint64_t v12 = *(__int32 **)a3;
        uint64_t v13 = ((uint64_t)v9 - *(void *)a3) >> 2;
        unint64_t v14 = v13 + 1;
        uint64_t v15 = v10 - (void)v12;
        if (v15 >> 1 > v14) {
          unint64_t v14 = v15 >> 1;
        }
        else {
          unint64_t v16 = v14;
        }
        if (v16)
        {
          uint64_t v17 = (char *)sub_10002C050(a3 + 16, v16);
          uint64_t v12 = *(__int32 **)a3;
          uint64_t v8 = *(__int32 **)(a3 + 8);
        }

        else
        {
          uint64_t v17 = 0LL;
        }

        uint64_t v18 = &v17[4 * v13];
        __int16 v19 = &v17[4 * v16];
        *(_DWORD *)uint64_t v18 = a2;
        uint64_t v11 = v18 + 4;
        while (v8 != v12)
        {
          int v20 = *--v8;
          *((_DWORD *)v18 - 1) = v20;
          v18 -= 4;
        }

        *(void *)a3 = v18;
        *(void *)(a3 + std::istream::~istream(v2, v3 + 8) = v11;
        *(void *)(a3 + 16) = v19;
        if (v12) {
          operator delete(v12);
        }
      }

      else
      {
        __int32 *v8 = a2;
        uint64_t v11 = v8 + 1;
      }

      *(void *)(a3 + std::istream::~istream(v2, v3 + 8) = v11;
      (*(void (**)(uint64_t *__return_ptr, void *, uint64_t))(*a1 + 24LL))(&v43, a1, a2);
      HIDWORD(v43) = *sub_10002ADB0();
      if (*(float *)&v43 == *((float *)&v43 + 1))
      {
        (*(void (**)(void *, float))(*a1 + 104LL))(a1, *(float *)&v43);
        (*(void (**)(void *))(*a1 + 96LL))(a1);
        std::string __p = 0LL;
        int v41 = 0LL;
        char v42 = 0LL;
        uint64_t v21 = *(void *)(*(void *)(a1[1] + 56LL) + 8LL * (int)a2);
        uint64_t v22 = *(void *)(v21 + 24);
        uint64_t v23 = *(void *)(v21 + 32);
        uint64_t v24 = v22 == v23 ? 0LL : v22;
        if (v22 != v23)
        {
          uint64_t v25 = 0LL;
          uint64_t v26 = 0LL;
          unint64_t v27 = (v23 - v22) >> 4;
          if (v27 <= 1) {
            uint64_t v28 = 1LL;
          }
          else {
            uint64_t v28 = v27;
          }
          do
          {
            uint64_t v29 = (_DWORD *)(v24 + 16 * v26 + 12);
            if (v25 >= v42)
            {
              uint64_t v30 = __p;
              uint64_t v31 = (v25 - __p) >> 2;
              unint64_t v32 = v31 + 1;
              uint64_t v33 = v42 - __p;
              if ((v42 - __p) >> 1 > v32) {
                unint64_t v32 = v33 >> 1;
              }
              else {
                unint64_t v34 = v32;
              }
              if (v34)
              {
                unint64_t v35 = (char *)sub_10002C050((uint64_t)&v42, v34);
                uint64_t v30 = __p;
                uint64_t v25 = v41;
              }

              else
              {
                unint64_t v35 = 0LL;
              }

              uint64_t v36 = &v35[4 * v31];
              *(_DWORD *)uint64_t v36 = *v29;
              unint64_t v37 = v36 + 4;
              while (v25 != v30)
              {
                int v38 = *((_DWORD *)v25 - 1);
                v25 -= 4;
                *((_DWORD *)v36 - 1) = v38;
                v36 -= 4;
              }

              std::string __p = v36;
              char v42 = &v35[4 * v34];
              if (v30) {
                operator delete(v30);
              }
              uint64_t v25 = v37;
            }

            else
            {
              *(_DWORD *)uint64_t v25 = *v29;
              v25 += 4;
            }

            int v41 = v25;
            ++v26;
          }

          while (v26 != v28);
          uint64_t v39 = __p;
          if (__p == v25) {
            goto LABEL_52;
          }
          do
          {
            sub_10005F9C4(a1, *(unsigned int *)v39, a3);
            v39 += 4;
          }

          while (v39 != v25);
          uint64_t v25 = __p;
          if (__p) {
LABEL_52:
          }
            operator delete(v25);
        }
      }
    }
  }

void sub_10005FC98( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_10005FCBC(void *a1, uint64_t a2)
{
  uint64_t v12 = v4;
  *(void *)&v13[(void)*(v4 - 3) - 8] = v5;
  uint64_t v6 = (std::ios_base *)&v13[(void)*(v12 - 3) - 8];
  std::ios_base::init(v6, v13);
  v6[1].__vftable = 0LL;
  v6[1].__fmtflags_ = -1;
  std::filebuf::basic_filebuf(v13);
  std::ofstream::open(&v12, a2, 16LL);
  unint64_t v10 = 0LL;
  uint64_t v11 = 0LL;
  std::string __p = 0LL;
  uint64_t v7 = (*(uint64_t (**)(void *))(*a1 + 16LL))(a1);
  sub_10005FE94(a1, v7, (uint64_t)&__p, (uint64_t)&v12);
  if (!std::filebuf::close(v13)) {
    std::ios_base::clear((std::ios_base *)&v13[(void)*(v12 - 3) - 8], *(_DWORD *)&v13[(void)*(v12 - 3) + 24] | 4);
  }
  if (__p)
  {
    unint64_t v10 = __p;
    operator delete(__p);
  }

  std::filebuf::~filebuf(v13);
  return std::ios::~ios(&v14);
}

void sub_10005FE44( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12, uint64_t a13)
{
}

void sub_10005FE94(void *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if ((_DWORD)a2 == -1) {
    return;
  }
  uint64_t v8 = *(__int32 **)(a3 + 8);
  unint64_t v9 = wmemchr(*(const __int32 **)a3, a2, ((uint64_t)v8 - *(void *)a3) >> 2);
  unint64_t v10 = v9 ? v9 : v8;
  uint64_t v11 = *(__int32 **)(a3 + 8);
  if (v10 != v11) {
    return;
  }
  unint64_t v12 = *(void *)(a3 + 16);
  if ((unint64_t)v10 >= v12)
  {
    unint64_t v14 = *(__int32 **)a3;
    uint64_t v15 = ((uint64_t)v11 - *(void *)a3) >> 2;
    unint64_t v16 = v15 + 1;
    uint64_t v17 = v12 - (void)v14;
    if (v17 >> 1 > v16) {
      unint64_t v16 = v17 >> 1;
    }
    else {
      unint64_t v18 = v16;
    }
    if (v18)
    {
      __int16 v19 = (char *)sub_10002C050(a3 + 16, v18);
      unint64_t v14 = *(__int32 **)a3;
      unint64_t v10 = *(__int32 **)(a3 + 8);
    }

    else
    {
      __int16 v19 = 0LL;
    }

    int v20 = &v19[4 * v15];
    uint64_t v21 = &v19[4 * v18];
    *(_DWORD *)int v20 = a2;
    uint64_t v13 = v20 + 4;
    while (v10 != v14)
    {
      int v22 = *--v10;
      *((_DWORD *)v20 - 1) = v22;
      v20 -= 4;
    }

    *(void *)a3 = v20;
    *(void *)(a3 + std::istream::~istream(v2, v3 + 8) = v13;
    *(void *)(a3 + 16) = v21;
    if (v14) {
      operator delete(v14);
    }
  }

  else
  {
    *unint64_t v10 = a2;
    uint64_t v13 = v10 + 1;
  }

  *(void *)(a3 + std::istream::~istream(v2, v3 + 8) = v13;
  (*(void (**)(void **__return_ptr, void *, uint64_t))(*a1 + 24LL))(__p, a1, a2);
  uint64_t v23 = sub_10002ADB0();
  LODWORD(v82.__locale_) = __p[0];
  LODWORD(v80[0]) = *v23;
  if (*(float *)__p != *(float *)v80)
  {
    uint64_t v66 = (void *)std::ostream::operator<<(a4, a2);
    id v67 = sub_10002A6A4(v66, (uint64_t)"\t", 1LL);
    (*(void (**)(void **__return_ptr, void *, uint64_t))(*a1 + 24LL))(v80, a1, a2);
    if (*(float *)v80 == INFINITY)
    {
      int v68 = "Infinity";
      uint64_t v69 = v67;
      uint64_t v70 = 8LL;
    }

    else
    {
      if (*(float *)v80 != -INFINITY)
      {
        uint64_t v71 = (void *)std::ostream::operator<<(v67, *(float *)v80);
        goto LABEL_80;
      }

      int v68 = "-Infinity";
      uint64_t v69 = v67;
      uint64_t v70 = 9LL;
    }

    uint64_t v71 = sub_10002A6A4(v69, (uint64_t)v68, v70);
LABEL_80:
    uint64_t v72 = v71;
    std::ios_base::getloc((const std::ios_base *)((char *)v71 + *(void *)(*v71 - 24LL)));
    uint64_t v73 = std::locale::use_facet(&v82, &std::ctype<char>::id);
    uint64_t v74 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v73->__vftable[2].~facet_0)(v73, 10LL);
    std::locale::~locale(&v82);
    std::ostream::put(v72, v74);
    std::ostream::flush(v72);
    return;
  }

  uint64_t v24 = (*(uint64_t (**)(void *, float))(*a1 + 104LL))(a1, *(float *)__p);
  uint64_t v25 = (*(uint64_t (**)(void *))(*a1 + 96LL))(a1);
  v82.__locale_ = 0LL;
  BOOL v83 = 0LL;
  uint64_t v84 = 0LL;
  uint64_t v26 = *(void *)(*(void *)(a1[1] + 56LL) + 8LL * (int)a2);
  uint64_t v27 = *(void *)(v26 + 24);
  uint64_t v28 = *(void *)(v26 + 32);
  if (v27 == v28) {
    uint64_t v29 = 0LL;
  }
  else {
    uint64_t v29 = v27;
  }
  if (v27 == v28) {
    return;
  }
  uint64_t v30 = v25;
  std::string::size_type v75 = a1;
  uint64_t v76 = a3;
  uint64_t v31 = 0LL;
  unint64_t v32 = (v28 - v27) >> 4;
  if (v32 <= 1) {
    unint64_t v32 = 1LL;
  }
  unint64_t v77 = v32;
  do
  {
    uint64_t v33 = (void *)std::ostream::operator<<(a4, a2);
    unint64_t v34 = sub_10002A6A4(v33, (uint64_t)"\t", 1LL);
    uint64_t v35 = v29 + 16 * v31;
    unsigned int v37 = *(_DWORD *)(v35 + 12);
    uint64_t v36 = (_DWORD *)(v35 + 12);
    int v38 = (void *)std::ostream::operator<<(v34, v37);
    uint64_t v39 = sub_10002A6A4(v38, (uint64_t)"\t", 1LL);
    (*(void (**)(void **__return_ptr, uint64_t, void))(*(void *)v30 + 72LL))( v80,  v30,  *(int *)(v29 + 16 * v31));
    if ((v81 & 0x80u) == 0) {
      uint64_t v40 = v80;
    }
    else {
      uint64_t v40 = (void **)v80[0];
    }
    if ((v81 & 0x80u) == 0) {
      uint64_t v41 = v81;
    }
    else {
      uint64_t v41 = (uint64_t)v80[1];
    }
    char v42 = sub_10002A6A4(v39, (uint64_t)v40, v41);
    uint64_t v43 = sub_10002A6A4(v42, (uint64_t)"\t", 1LL);
    (*(void (**)(void **__return_ptr, uint64_t, void))(*(void *)v24 + 72LL))( __p,  v24,  *(int *)(v29 + 16 * v31 + 4));
    if ((v79 & 0x80u) == 0) {
      uint64_t v44 = __p;
    }
    else {
      uint64_t v44 = (void **)__p[0];
    }
    if ((v79 & 0x80u) == 0) {
      uint64_t v45 = v79;
    }
    else {
      uint64_t v45 = (uint64_t)__p[1];
    }
    unint64_t v46 = sub_10002A6A4(v43, (uint64_t)v44, v45);
    std::locale v47 = sub_10002A6A4(v46, (uint64_t)"\t", 1LL);
    float v48 = *(float *)(v29 + 16 * v31 + 8);
    if (v48 == INFINITY)
    {
      uint64_t v49 = "Infinity";
      uint64_t v50 = 8LL;
LABEL_47:
      __int128 v51 = sub_10002A6A4(v47, (uint64_t)v49, v50);
      goto LABEL_48;
    }

    if (v48 == -INFINITY)
    {
      uint64_t v49 = "-Infinity";
      uint64_t v50 = 9LL;
      goto LABEL_47;
    }

    __int128 v51 = (void *)std::ostream::operator<<(v47, v48);
LABEL_48:
    int v52 = v51;
    std::ios_base::getloc((const std::ios_base *)((char *)v51 + *(void *)(*v51 - 24LL)));
    char v53 = std::locale::use_facet(&v85, &std::ctype<char>::id);
    uint64_t v54 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v53->__vftable[2].~facet_0)(v53, 10LL);
    std::locale::~locale(&v85);
    std::ostream::put(v52, v54);
    std::ostream::flush(v52);
    __int128 v55 = v83;
    if (v83 >= v84)
    {
      locale = v82.__locale_;
      uint64_t v58 = (v83 - (char *)v82.__locale_) >> 2;
      unint64_t v59 = v58 + 1;
      uint64_t v60 = v84 - (char *)v82.__locale_;
      else {
        unint64_t v61 = v59;
      }
      if (v61)
      {
        int v62 = (char *)sub_10002C050((uint64_t)&v84, v61);
        locale = v82.__locale_;
        __int128 v55 = v83;
      }

      else
      {
        int v62 = 0LL;
      }

      uint64_t v63 = (std::locale::__imp *)&v62[4 * v58];
      *(_DWORD *)uint64_t v63 = *v36;
      uint64_t v56 = (std::locale::__imp *)((char *)v63 + 4);
      while (v55 != (char *)locale)
      {
        int v64 = *((_DWORD *)v55 - 1);
        v55 -= 4;
        *((_DWORD *)v63 - 1) = v64;
        uint64_t v63 = (std::locale::__imp *)((char *)v63 - 4);
      }

      v82.__locale_ = v63;
      BOOL v83 = (char *)v56;
      uint64_t v84 = &v62[4 * v61];
      if (locale) {
        operator delete(locale);
      }
    }

    else
    {
      *(_DWORD *)BOOL v83 = *v36;
      uint64_t v56 = (std::locale::__imp *)(v55 + 4);
    }

    BOOL v83 = (char *)v56;
    ++v31;
  }

  while (v31 != v77);
  uint64_t v65 = v82.__locale_;
  if (v82.__locale_ == v56) {
    goto LABEL_74;
  }
  do
  {
    sub_10005FE94(v75, *(unsigned int *)v65, v76, a4);
    uint64_t v65 = (std::locale::__imp *)((char *)v65 + 4);
  }

  while (v65 != v56);
  uint64_t v56 = v82.__locale_;
  if (v82.__locale_)
  {
LABEL_74:
    BOOL v83 = (char *)v56;
    operator delete(v56);
  }

void sub_100060438( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, int a15, __int16 a16, char a17, char a18, void *__p, uint64_t a20, int a21, __int16 a22, char a23, char a24, std::locale a25, uint64_t a26)
{
}

BOOL sub_1000604B4(uint64_t a1)
{
  return !a1 || (*(unsigned int (**)(uint64_t))(*(void *)a1 + 16LL))(a1) == -1;
}

float sub_1000604E4(uint64_t a1)
{
  uint64_t v1 = sub_1000606CC();
  float result = v3;
  float v5 = v3;
  float v4 = *(float *)v1;
  if (v3 == v4) {
    return 3.4028e38;
  }
  return result;
}

void sub_100060538(uint64_t a1@<X0>, float *a2@<X8>, float a3@<S0>)
{
  std::string __p = 0LL;
  uint64_t v13 = 0LL;
  uint64_t v14 = 0LL;
  sub_100083EF0(a1, (char **)&__p, 0, a3);
  if ((char *)v13 - (_BYTE *)__p == 4 && *(float *)__p >= -INFINITY && *(float *)__p <= -INFINITY)
  {
    float v5 = *(float *)sub_1000606CC();
    uint64_t v6 = (float *)__p;
  }

  else
  {
    float v5 = *(float *)sub_10002ADB0();
    uint64_t v6 = v13;
    if (v13 != __p)
    {
      unint64_t v7 = 0LL;
      uint64_t v6 = (float *)__p;
      do
      {
        (*(void (**)(float *__return_ptr, uint64_t, unint64_t))(*(void *)a1 + 24LL))(&v11, a1, v7);
        float v8 = v6[v7];
        if (v8 == -INFINITY || v11 >= -INFINITY && v11 <= -INFINITY)
        {
          float v9 = *(float *)sub_1000606CC();
        }

        else
        {
          BOOL v10 = v11 == INFINITY || v8 == INFINITY;
          float v9 = v8 + v11;
          if (v10) {
            float v9 = INFINITY;
          }
        }

        if (v5 == -INFINITY || v9 >= -INFINITY && v9 <= -INFINITY)
        {
          float v5 = *(float *)sub_1000606CC();
        }

        else if (v5 >= v9)
        {
          float v5 = v9;
        }

        ++v7;
        uint64_t v6 = (float *)__p;
      }

      while (v7 < ((char *)v13 - (_BYTE *)__p) >> 2);
    }
  }

  *a2 = v5;
  if (v6)
  {
    uint64_t v13 = v6;
    operator delete(v6);
  }

void sub_1000606A4( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

int *sub_1000606CC()
{
  unsigned __int8 v0 = atomic_load((unsigned __int8 *)&qword_1000DDA78);
  if ((v0 & 1) == 0 && __cxa_guard_acquire(&qword_1000DDA78))
  {
    dword_1000DDA70 = 2143289344;
    __cxa_guard_release(&qword_1000DDA78);
  }

  return &dword_1000DDA70;
}

void sub_100060720(uint64_t a1@<X0>, int a2@<W1>, uint64_t *a3@<X8>)
{
  if (a2 <= 0)
  {
    float v9 = (os_log_s *)sub_1000A39A8();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)std::string buf = 67109120;
      *(_DWORD *)&uint8_t buf[4] = a2;
      _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_ERROR,  "RXFstOp::copyNBestStrings : invalid n = %d, n should be > 0",  buf,  8u);
    }

    *a3 = 0LL;
    a3[1] = 0LL;
    a3[2] = 0LL;
  }

  else
  {
    sub_10008F514(buf);
    int v14 = *sub_10002ADB0();
    sub_100060944(a1, (uint64_t)buf, a2, 0, 0, &v14, -1, 0.000001);
    sub_100060A48((uint64_t *)buf, 0, 0, 0.00097656);
    *a3 = 0LL;
    a3[1] = 0LL;
    a3[2] = 0LL;
    memset(v13, 0, sizeof(v13));
    float v11 = 0LL;
    uint64_t v12 = 0LL;
    std::string __p = 0LL;
    sub_10008F49C(&__p, 0LL, 0LL, 0LL);
    sub_100060B20(buf, (uint64_t)&__p, *(unsigned int *)(v17 + 80), (uint64_t)v13, a3);
    if (__p)
    {
      float v11 = __p;
      operator delete(__p);
    }

    uint64_t v15 = (void **)v13;
    sub_10001A214(&v15);
    *(void *)std::string buf = off_1000D0A50;
    uint64_t v6 = v18;
    if (v18)
    {
      p_shared_owners = (unint64_t *)&v18->__shared_owners_;
      do
        unint64_t v8 = __ldaxr(p_shared_owners);
      while (__stlxr(v8 - 1, p_shared_owners));
      if (!v8)
      {
        ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
        std::__shared_weak_count::__release_weak(v6);
      }
    }
  }

void sub_1000608DC( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t *a16, void (**a17)(), uint64_t a18)
{
  if (__p) {
    operator delete(__p);
  }
  a16 = &a12;
  sub_10001A214((void ***)&a16);
  sub_1000180A4((void ***)&a12);
  a17 = off_1000D0A50;
  sub_100017FC4((uint64_t)&a18);
  _Unwind_Resume(a1);
}

void sub_100060944(uint64_t a1, uint64_t a2, int a3, char a4, char a5, int *a6, int a7, float a8)
{
  uint64_t v28 = 0LL;
  uint64_t v29 = 0LL;
  uint64_t v30 = 0LL;
  sub_100085160((uint64_t)v27, a1, (uint64_t)&v28);
  int v16 = *a6;
  uint64_t v17 = v27;
  int v18 = -1;
  float v19 = a8;
  char v20 = 0;
  int v21 = a3;
  char v22 = a4;
  char v23 = 0;
  char v24 = a5;
  int v25 = v16;
  int v26 = a7;
  sub_10008F5AC(a1, a2, (uint64_t)&v28, (uint64_t)&v17);
  sub_10008E2A4((uint64_t)v27);
  if (v28)
  {
    uint64_t v29 = v28;
    operator delete(v28);
  }

void sub_100060A1C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  float v9 = *(void **)(v7 - 104);
  if (v9)
  {
    *(void *)(v7 - 96) = v9;
    operator delete(v9);
  }

  _Unwind_Resume(a1);
}

void sub_100060A48(uint64_t *a1, int a2, int a3, float a4)
{
  std::string __p = 0LL;
  BOOL v10 = 0LL;
  uint64_t v11 = 0LL;
  sub_100083EF0((uint64_t)a1, (char **)&__p, a2 == 0, a4);
  int v8 = *sub_10002AD60();
  if (a3)
  {
    sub_100096C54((uint64_t)a1, (uint64_t *)&__p, a2 == 0, &v7);
    int v8 = v7;
  }

  sub_100096DC4(a1, (uint64_t *)&__p, a2);
  if (a3) {
    sub_100097860((uint64_t)a1, &v8, a2 == 1);
  }
  if (__p)
  {
    BOOL v10 = __p;
    operator delete(__p);
  }

void sub_100060AFC( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100060B20(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t *a5)
{
  uint64_t v10 = a2 + 16;
  unint64_t v11 = *(void *)(a2 + 16);
  uint64_t v12 = *(__int32 **)(a2 + 8);
  if ((unint64_t)v12 >= v11)
  {
    int v14 = *(__int32 **)a2;
    uint64_t v15 = ((uint64_t)v12 - *(void *)a2) >> 2;
    unint64_t v16 = v15 + 1;
    uint64_t v17 = v11 - (void)v14;
    if (v17 >> 1 > v16) {
      unint64_t v16 = v17 >> 1;
    }
    else {
      unint64_t v18 = v16;
    }
    if (v18)
    {
      float v19 = (char *)sub_10002C050(v10, v18);
      int v14 = *(__int32 **)a2;
      uint64_t v12 = *(__int32 **)(a2 + 8);
    }

    else
    {
      float v19 = 0LL;
    }

    char v20 = &v19[4 * v15];
    int v21 = &v19[4 * v18];
    *(_DWORD *)char v20 = a3;
    uint64_t v13 = v20 + 4;
    while (v12 != v14)
    {
      int v22 = *--v12;
      *((_DWORD *)v20 - 1) = v22;
      v20 -= 4;
    }

    *(void *)a2 = v20;
    *(void *)(a2 + std::istream::~istream(v2, v3 + 8) = v13;
    *(void *)(a2 + 16) = v21;
    if (v14) {
      operator delete(v14);
    }
  }

  else
  {
    *uint64_t v12 = a3;
    uint64_t v13 = v12 + 1;
  }

  *(void *)(a2 + std::istream::~istream(v2, v3 + 8) = v13;
  (*(void (**)(uint64_t *__return_ptr, void *, uint64_t))(*a1 + 24LL))(&v67, a1, a3);
  char v23 = sub_10002ADB0();
  *(_DWORD *)std::string buf = v67;
  LODWORD(v63[0]) = *v23;
  v24.n128_u32[0] = v67;
  if (*(float *)&v67 != *(float *)v63)
  {
    unint64_t v25 = a5[1];
    if (v25 >= a5[2])
    {
      uint64_t v26 = sub_1000613C0(a5, (__int128 **)a4);
    }

    else
    {
      sub_100061364((uint64_t)a5, (__int128 **)a4);
      uint64_t v26 = v25 + 24;
    }

    a5[1] = v26;
  }

  uint64_t v27 = *(void *)(*(void *)(a1[1] + 56LL) + 8LL * (int)a3);
  uint64_t v28 = *(void *)(v27 + 24);
  uint64_t v29 = *(void *)(v27 + 32);
  if (v28 == v29) {
    uint64_t v30 = 0LL;
  }
  else {
    uint64_t v30 = *(void *)(v27 + 24);
  }
  if (v28 != v29)
  {
    unint64_t v31 = (v29 - v28) >> 4;
    if (v31 <= 1) {
      uint64_t v32 = 1LL;
    }
    else {
      uint64_t v32 = v31;
    }
    for (uint64_t i = (__int32 *)(v30 + 12); *i == (_DWORD)a3; i += 4)
    {
      unint64_t v34 = (os_log_s *)sub_1000A39A8();
      if (os_log_type_enabled(v34, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)std::string buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v34,  OS_LOG_TYPE_ERROR,  "cmdp_fst_util::unionFst : Loop detected while computing paths",  buf,  2u);
      }

void sub_100060F6C( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13, void *a14, uint64_t a15, int a16, __int16 a17, char a18, char a19, void *a20, uint64_t a21, int a22, __int16 a23, char a24, char a25)
{
  if (__p) {
    operator delete(__p);
  }
  if (a19 < 0) {
    operator delete(a14);
  }
  if (a25 < 0) {
    operator delete(a20);
  }
  _Unwind_Resume(exception_object);
}

void sub_100060FC4(void *a1@<X0>, uint64_t *a2@<X8>)
{
  *a2 = 0LL;
  a2[1] = 0LL;
  a2[2] = 0LL;
  memset(v8, 0, sizeof(v8));
  uint64_t v6 = 0LL;
  uint64_t v7 = 0LL;
  std::string __p = 0LL;
  sub_10008F49C(&__p, 0LL, 0LL, 0LL);
  uint64_t v4 = (*(uint64_t (**)(void *))(*a1 + 16LL))(a1);
  sub_100060B20(a1, (uint64_t)&__p, v4, (uint64_t)v8, a2);
  if (__p)
  {
    uint64_t v6 = __p;
    operator delete(__p);
  }

  float v9 = (void **)v8;
  sub_10001A214(&v9);
}

void sub_100061060( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12, uint64_t a13)
{
  *(void *)(v13 - ++*(void *)(result + 24) = &a13;
  sub_10001A214((void ***)(v13 - 24));
  sub_1000180A4((void ***)&a13);
  _Unwind_Resume(a1);
}

void sub_1000610A0(void *a1, char *a2)
{
  size_t v4 = confstr(65537, __s, 0x400uLL);
  if (v4)
  {
    sub_10000A2DC(&v20, __s);
    if ((v20.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      float v5 = &v20;
    }
    else {
      float v5 = (std::string *)v20.__r_.__value_.__r.__words[0];
    }
    if (v5->__r_.__value_.__s.__data_[v4 - 1] != 47)
    {
      sub_10000A2DC(__p, "/");
      uint64_t v6 = cap >= 0 ? (const std::string::value_type *)__p : (const std::string::value_type *)__p[0];
      uint64_t v7 = cap >= 0 ? (void *)HIBYTE(cap) : __p[1];
      std::string::append(&v20, v6, (std::string::size_type)v7);
      if (SHIBYTE(cap) < 0) {
        operator delete(__p[0]);
      }
    }

    sub_10000A2DC(&v19, a2);
    int v8 = dword_1000DDF20++;
    std::to_string(&v18, v8);
    if ((v18.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      float v9 = &v18;
    }
    else {
      float v9 = (std::string *)v18.__r_.__value_.__r.__words[0];
    }
    if ((v18.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      std::string::size_type size = v18.__r_.__value_.__s.__size_;
    }
    else {
      std::string::size_type size = v18.__r_.__value_.__l.__size_;
    }
    unint64_t v11 = std::string::append(&v19, (const std::string::value_type *)v9, size);
    __int128 v12 = *(_OWORD *)&v11->__r_.__value_.__l.__data_;
    int64_t cap = v11->__r_.__value_.__l.__cap_;
    *(_OWORD *)std::string __p = v12;
    v11->__r_.__value_.__l.__size_ = 0LL;
    v11->__r_.__value_.__l.__cap_ = 0LL;
    v11->__r_.__value_.__r.__words[0] = 0LL;
    if (cap >= 0) {
      uint64_t v13 = __p;
    }
    else {
      uint64_t v13 = (void **)__p[0];
    }
    if (cap >= 0) {
      std::string::size_type v14 = HIBYTE(cap);
    }
    else {
      std::string::size_type v14 = (std::string::size_type)__p[1];
    }
    std::string::append(&v20, (const std::string::value_type *)v13, v14);
    if (SHIBYTE(cap) < 0) {
      operator delete(__p[0]);
    }
    if ((v20.__r_.__value_.__s.__size_ & 0x80u) == 0) {
      uint64_t v15 = &v20;
    }
    else {
      uint64_t v15 = (std::string *)v20.__r_.__value_.__r.__words[0];
    }
    sub_10005FCBC(a1, (uint64_t)v15);
    unint64_t v16 = (os_log_s *)sub_1000A39A8();
    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v17 = &v20;
      if ((v20.__r_.__value_.__s.__size_ & 0x80u) != 0) {
        uint64_t v17 = (std::string *)v20.__r_.__value_.__r.__words[0];
      }
      LODWORD(__p[0]) = 136315138;
      *(void **)((char *)__p + 4) = v17;
      _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "FST Grammar log %s\n", (uint8_t *)__p, 0xCu);
    }
  }

void sub_1000612D8( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, uint64_t a17, int a18, __int16 a19, char a20, char a21, void *a22, uint64_t a23, int a24, __int16 a25, char a26, char a27, void *__p, uint64_t a29, int a30, __int16 a31, char a32, char a33)
{
  if (a33 < 0) {
    operator delete(__p);
  }
  if (a27 < 0) {
    operator delete(a22);
  }
  _Unwind_Resume(exception_object);
}

char *sub_100061364(uint64_t a1, __int128 **a2)
{
  uint64_t v3 = *(void *)(a1 + 8);
  *(void *)uint64_t v3 = 0LL;
  *(void *)(v3 + std::istream::~istream(v2, v3 + 8) = 0LL;
  *(void *)(v3 + 16) = 0LL;
  float result = sub_100019F00((char *)v3, *a2, a2[1], 0xAAAAAAAAAAAAAAABLL * (a2[1] - *a2));
  *(void *)(a1 + std::istream::~istream(v2, v3 + 8) = v3 + 24;
  return result;
}

void sub_1000613B8(_Unwind_Exception *a1)
{
  *(void *)(v1 + std::istream::~istream(v2, v3 + 8) = v2;
  _Unwind_Resume(a1);
}

uint64_t sub_1000613C0(uint64_t *a1, __int128 **a2)
{
  uint64_t v3 = *a1;
  unint64_t v4 = 0xAAAAAAAAAAAAAAABLL * ((a1[1] - *a1) >> 3);
  unint64_t v5 = v4 + 1;
  if (v4 + 1 > 0xAAAAAAAAAAAAAAALL) {
    sub_100018774();
  }
  uint64_t v7 = (uint64_t)(a1 + 2);
  unint64_t v8 = 0xAAAAAAAAAAAAAAABLL * ((a1[2] - v3) >> 3);
  if (2 * v8 > v5) {
    unint64_t v5 = 2 * v8;
  }
  if (v8 >= 0x555555555555555LL) {
    unint64_t v9 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v9 = v5;
  }
  uint64_t v17 = a1 + 2;
  if (v9) {
    uint64_t v10 = (char *)sub_100018F00(v7, v9);
  }
  else {
    uint64_t v10 = 0LL;
  }
  unint64_t v11 = &v10[24 * v4];
  v14[0] = v10;
  v14[1] = v11;
  uint64_t v15 = v11;
  unint64_t v16 = &v10[24 * v9];
  *(void *)unint64_t v11 = 0LL;
  *((void *)v11 + 1) = 0LL;
  *((void *)v11 + 2) = 0LL;
  sub_100019F00(v11, *a2, a2[1], 0xAAAAAAAAAAAAAAABLL * (a2[1] - *a2));
  v15 += 24;
  sub_10001A4B8(a1, v14);
  uint64_t v12 = a1[1];
  sub_10001A648(v14);
  return v12;
}

void sub_1000614CC(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

uint64_t sub_1000614E0(uint64_t *a1, __int128 *a2, __int128 *a3)
{
  uint64_t v4 = *a1;
  unint64_t v5 = 0xAAAAAAAAAAAAAAABLL * ((a1[1] - *a1) >> 4);
  unint64_t v6 = v5 + 1;
  if (v5 + 1 > 0x555555555555555LL) {
    sub_100018774();
  }
  uint64_t v9 = (uint64_t)(a1 + 2);
  unint64_t v10 = 0xAAAAAAAAAAAAAAABLL * ((a1[2] - v4) >> 4);
  if (2 * v10 > v6) {
    unint64_t v6 = 2 * v10;
  }
  if (v10 >= 0x2AAAAAAAAAAAAAALL) {
    unint64_t v11 = 0x555555555555555LL;
  }
  else {
    unint64_t v11 = v6;
  }
  std::string v19 = a1 + 2;
  if (v11) {
    uint64_t v12 = (char *)sub_100019FD4(v9, v11);
  }
  else {
    uint64_t v12 = 0LL;
  }
  uint64_t v15 = v12;
  unint64_t v16 = &v12[48 * v5];
  std::string v18 = &v12[48 * v11];
  sub_100017F30(v16, a2, a3);
  uint64_t v17 = v16 + 48;
  sub_10001A298(a1, &v15);
  uint64_t v13 = a1[1];
  sub_10001A444(&v15);
  return v13;
}

void sub_1000615D8(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

uint64_t sub_1000615EC@<X0>(__int128 *a1@<X1>, void *a2@<X8>)
{
  uint64_t v4 = (char *)operator new(0x130uLL);
  uint64_t result = sub_100061644((uint64_t)v4, a1);
  *a2 = v4 + 24;
  a2[1] = v4;
  return result;
}

void sub_100061630(_Unwind_Exception *a1)
{
}

uint64_t sub_100061644(uint64_t a1, __int128 *a2)
{
  *(void *)(a1 + std::istream::~istream(v2, v3 + 8) = 0LL;
  *(void *)(a1 + 16) = 0LL;
  *(void *)a1 = off_1000D0CB0;
  sub_1000616C8((char *)(a1 + 24), a2);
  return a1;
}

void sub_100061678(_Unwind_Exception *a1)
{
}

void sub_10006168C(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_1000D0CB0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_10006169C(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_1000D0CB0;
  std::__shared_weak_count::~__shared_weak_count(a1);
  operator delete(v1);
}

uint64_t sub_1000616BC(uint64_t a1)
{
  return sub_10005AC80(a1 + 24);
}

char *sub_1000616C8(char *__dst, __int128 *a2)
{
  if (*((char *)a2 + 23) < 0)
  {
    sub_10005AA70(__dst, *(void **)a2, *((void *)a2 + 1));
  }

  else
  {
    __int128 v3 = *a2;
    *((void *)__dst + 2) = *((void *)a2 + 2);
    *(_OWORD *)std::string __dst = v3;
  }

  *((void *)__dst + 3) = 0LL;
  *((void *)__dst + 4) = 0LL;
  sub_10009CDB4(__dst + 40);
  *((void *)__dst + 14) = 0LL;
  *((void *)__dst + 15) = 0LL;
  *((void *)__dst + 19) = 0LL;
  *((void *)__dst + 1std::istream::~istream(v2, v3 + 8) = 0LL;
  *((void *)__dst + 16) = 0LL;
  *((void *)__dst + 17) = __dst + 144;
  __dst[160] = 0;
  *(_OWORD *)(__dst + 16std::istream::~istream(v2, v3 + 8) = 0u;
  *(_OWORD *)(__dst + 184) = 0u;
  *(_OWORD *)(__dst + 20RDString::RDString((RDString *)&v66, theString, 0) = 0u;
  *((void *)__dst + 27) = 850045863LL;
  *((_OWORD *)__dst + 14) = 0u;
  *((_OWORD *)__dst + 15) = 0u;
  *((_OWORD *)__dst + 16) = 0u;
  *((void *)__dst + 34) = 0LL;
  return __dst;
}

void sub_100061760(_Unwind_Exception *exception_object)
{
}

void *sub_10006177C(void *a1, std::string *a2, unsigned __int8 a3)
{
  if (!v11) {
    return a1;
  }
  if ((char)a2->__r_.__value_.__s.__size_ < 0)
  {
    *a2->__r_.__value_.__l.__data_ = 0;
    a2->__r_.__value_.__l.__size_ = 0LL;
  }

  else
  {
    a2->__r_.__value_.__s.__data_[0] = 0;
    a2->__r_.__value_.__s.__size_ = 0;
  }

  uint64_t v6 = 0LL;
  while (1)
  {
    uint64_t v7 = *(void **)((char *)a1 + *(void *)(*a1 - 24LL) + 40);
    unint64_t v8 = (_BYTE *)v7[3];
    if (v8 != (_BYTE *)v7[4])
    {
      v7[3] = v8 + 1;
      LOBYTE(v7) = *v8;
      goto LABEL_9;
    }

    LODWORD(v7) = (*(uint64_t (**)(void *))(*v7 + 80LL))(v7);
    if ((_DWORD)v7 == -1) {
      break;
    }
LABEL_9:
    if (v7 == a3)
    {
      int v9 = 0;
      goto LABEL_17;
    }

    std::string::push_back(a2, (std::string::value_type)v7);
    --v6;
    if ((char)a2->__r_.__value_.__s.__size_ < 0 && a2->__r_.__value_.__l.__size_ == 0x7FFFFFFFFFFFFFF7LL)
    {
      int v9 = 4;
      goto LABEL_17;
    }
  }

  if (v6) {
    int v9 = 2;
  }
  else {
    int v9 = 6;
  }
LABEL_17:
  std::ios_base::clear( (std::ios_base *)((char *)a1 + *(void *)(*a1 - 24LL)),  *(_DWORD *)((char *)a1 + *(void *)(*a1 - 24LL) + 32) | v9);
  return a1;
}

void sub_1000618A8(void *a1)
{
  uint64_t v2 = *v1;
  *(_DWORD *)((char *)v1 + *(void *)(*v1 - 24LL) + 32) |= 1u;
  if ((*((_BYTE *)v1 + *(void *)(v2 - 24) + 36) & 1) == 0)
  {
    __cxa_end_catch();
    JUMPOUT(0x100061874LL);
  }

  __cxa_rethrow();
}

void sub_1000618EC(_Unwind_Exception *a1)
{
}

uint64_t sub_100061900(uint64_t a1, const std::string *a2, int a3)
{
  uint64_t v6 = std::streambuf::basic_streambuf(a1);
  *(_OWORD *)(v6 + 64) = 0u;
  *(_OWORD *)(v6 + 8RDString::RDString((RDString *)&v66, theString, 0) = 0u;
  *(_DWORD *)(v6 + 96) = a3;
  std::string::operator=((std::string *)(v6 + 64), a2);
  sub_100061990(a1);
  return a1;
}

void sub_10006196C(_Unwind_Exception *a1)
{
}

void sub_100061990(uint64_t a1)
{
  *(void *)(a1 + 8std::istream::~istream(v2, v3 + 8) = 0LL;
  uint64_t v2 = (std::string *)(a1 + 64);
  char v3 = *(_BYTE *)(a1 + 87);
  if (v3 < 0)
  {
    uint64_t v4 = *(std::string **)(a1 + 64);
    unint64_t v5 = *(void *)(a1 + 72);
  }

  else
  {
    uint64_t v4 = v2;
    unint64_t v5 = *(unsigned __int8 *)(a1 + 87);
  }

  int v6 = *(_DWORD *)(a1 + 96);
  if ((v6 & 8) != 0)
  {
    *(void *)(a1 + 8std::istream::~istream(v2, v3 + 8) = (char *)v4 + v5;
    *(void *)(a1 + 16) = v4;
    *(void *)(a1 + ++*(void *)(result + 24) = v4;
    *(void *)(a1 + 32) = (char *)v4 + v5;
  }

  if ((v6 & 0x10) != 0)
  {
    *(void *)(a1 + 8std::istream::~istream(v2, v3 + 8) = (char *)v4 + v5;
    std::string::size_type v7 = v3 < 0 ? (*(void *)(a1 + 80) & 0x7FFFFFFFFFFFFFFFLL) - 1 : 22LL;
    std::string::resize(v2, v7, 0);
    uint64_t v8 = *(char *)(a1 + 87) < 0 ? *(void *)(a1 + 72) : *(unsigned __int8 *)(a1 + 87);
    *(void *)(a1 + 4RDString::RDString((RDString *)&v66, theString, 0) = v4;
    *(void *)(a1 + 4std::istream::~istream(v2, v3 + 8) = v4;
    *(void *)(a1 + ++*(void *)(result + 56) = (char *)v4 + v8;
    if ((*(_BYTE *)(a1 + 96) & 3) != 0)
    {
      if (v5 >> 31)
      {
        uint64_t v9 = ((v5 - 0x80000000) * (unsigned __int128)0x200000005uLL) >> 64;
        unint64_t v10 = 0x7FFFFFFF * ((v9 + ((v5 - 0x80000000 - v9) >> 1)) >> 30);
        uint64_t v4 = (std::string *)((char *)v4 + v10 + 0x7FFFFFFF);
        unint64_t v5 = v5 - v10 - 0x7FFFFFFF;
        *(void *)(a1 + 4std::istream::~istream(v2, v3 + 8) = v4;
      }

      if (v5) {
        *(void *)(a1 + 4std::istream::~istream(v2, v3 + 8) = (char *)v4 + v5;
      }
    }
  }

void sub_100061AA0(uint64_t a1, uint64_t a2, uint64_t a3, int a4, uint64_t a5, uint64_t a6, char a7)
{
  if (v15 < 0) {
    operator delete(__p[0]);
  }
  if (v17 < 0) {
    operator delete(v16[0]);
  }
}

void sub_100061B5C( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, void *a17, uint64_t a18, int a19, __int16 a20, char a21, char a22)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  if (a22 < 0) {
    operator delete(a17);
  }
  _Unwind_Resume(exception_object);
}

void sub_100061B90( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  uint64_t v9 = a8;
  uint64_t v11 = a1;
  uint64_t v95 = 0LL;
  uint64_t v96 = 0LL;
  uint64_t v97 = 0LL;
  if (a2 && a3)
  {
    uint64_t v15 = *(unsigned __int8 *)(a4 + 23);
    if ((v15 & 0x80u) != 0LL) {
      uint64_t v15 = *(void *)(a4 + 8);
    }
    if (v15)
    {
      int v16 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a3 + 80LL))(a3, a4);
      if (v16 == -1)
      {
        if (dword_1000DE7E8 >= 1)
        {
          sub_10000A2DC(&__p, "INFO");
          sub_10002A9EC((BOOL *)v90, (uint64_t)&__p);
          char v17 = sub_10002A6A4(&std::cerr, (uint64_t)"Input symbol '", 14LL);
          int v18 = *(char *)(a4 + 23);
          uint64_t v19 = v18 >= 0 ? a4 : *(void *)a4;
          uint64_t v20 = v18 >= 0 ? *(unsigned __int8 *)(a4 + 23) : *(void *)(a4 + 8);
          int v21 = sub_10002A6A4(v17, v19, v20);
          sub_10002A6A4(v21, (uint64_t)"' missing from target symbol table", 34LL);
          sub_10002AA94(v90);
          if (SHIBYTE(v94) < 0) {
            operator delete(__p);
          }
        }

        int v16 = -1;
        uint64_t v85 = 1LL;
      }

      else
      {
        uint64_t v85 = 0LL;
      }
    }

    else
    {
      uint64_t v85 = 0LL;
      int v16 = -1;
    }

    unint64_t v22 = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 120LL))(a2);
    uint64_t v23 = (*(uint64_t (**)(uint64_t, void))(*(void *)a2 + 64LL))(a2, 0LL);
    if (v22)
    {
      uint64_t v24 = v23;
      unint64_t v25 = 0LL;
      int v26 = v16;
      int v27 = v16;
      do
      {
        (*(void (**)(void **__return_ptr, uint64_t, uint64_t))(*(void *)a2 + 72LL))(&__p, a2, v24);
        (*(void (**)(void **__return_ptr, uint64_t, uint64_t))(*(void *)a2 + 72LL))(v90, a2, v24);
        uint64_t v28 = (*(uint64_t (**)(uint64_t, void **))(*(void *)a3 + 80LL))(a3, v90);
        BOOL v29 = v28 == -1;
        if (v28 == -1) {
          LODWORD(v2std::istream::~istream(v2, v3 + 8) = v26;
        }
        if (v29 && v16 == -1)
        {
          if (dword_1000DE7E8 >= 1)
          {
            sub_10000A2DC(v90, "INFO");
            sub_10002A9EC((BOOL *)v88, (uint64_t)v90);
            unint64_t v31 = sub_10002A6A4(&std::cerr, (uint64_t)"Input symbol ID ", 16LL);
            uint64_t v32 = (void *)std::ostream::operator<<(v31, v24);
            uint64_t v33 = sub_10002A6A4(v32, (uint64_t)" symbol '", 9LL);
            unint64_t v34 = SHIBYTE(v94) >= 0 ? &__p : (void **)__p;
            uint64_t v35 = SHIBYTE(v94) >= 0 ? HIBYTE(v94) : (uint64_t)v93;
            uint64_t v36 = sub_10002A6A4(v33, (uint64_t)v34, v35);
            sub_10002A6A4(v36, (uint64_t)"' missing from target symbol table", 34LL);
            sub_10002AA94(v88);
          }

          ++v85;
          LODWORD(v2std::istream::~istream(v2, v3 + 8) = -1;
        }

        unsigned int v37 = v96;
        if (v96 >= v97)
        {
          uint64_t v39 = ((char *)v96 - (char *)v95) >> 3;
          unint64_t v40 = v97 - v95;
          if (v40 <= v39 + 1) {
            unint64_t v40 = v39 + 1;
          }
          else {
            unint64_t v41 = v40;
          }
          if (v41) {
            uint64_t v42 = (char *)sub_100018788((uint64_t)&v97, v41);
          }
          else {
            uint64_t v42 = 0LL;
          }
          uint64_t v43 = (int *)&v42[8 * v39];
          *(void *)uint64_t v43 = v24 | ((unint64_t)v28 << 32);
          int v38 = v43 + 2;
          uint64_t v45 = v95;
          uint64_t v44 = v96;
          if (v96 != v95)
          {
            do
            {
              uint64_t v46 = *((void *)v44 - 1);
              v44 -= 2;
              *((void *)v43 - 1) = v46;
              v43 -= 2;
            }

            while (v44 != v45);
            uint64_t v44 = v95;
          }

          uint64_t v95 = v43;
          uint64_t v96 = v38;
          uint64_t v97 = (int *)&v42[8 * v41];
          if (v44) {
            operator delete(v44);
          }
        }

        else
        {
          *(void *)uint64_t v96 = v24 | ((unint64_t)v28 << 32);
          int v38 = v37 + 2;
        }

        uint64_t v96 = v38;
        if (SHIBYTE(v94) < 0) {
          operator delete(__p);
        }
        ++v25;
        int v16 = v27;
        if (v25 < v22) {
          uint64_t v24 = (*(uint64_t (**)(uint64_t, unint64_t))(*(void *)a2 + 64LL))(a2, v25);
        }
      }

      while (v25 != v22);
    }

    uint64_t v9 = a8;
    uint64_t v11 = a1;
    if (v85)
    {
      sub_10000A2DC(&__p, "WARNING");
      sub_10002A9EC((BOOL *)v90, (uint64_t)&__p);
      int v47 = sub_10002A6A4(&std::cerr, (uint64_t)"Target symbol table missing: ", 29LL);
      int v48 = (void *)std::ostream::operator<<(v47, v85);
      sub_10002A6A4(v48, (uint64_t)" input symbols", 14LL);
      sub_10002AA94(v90);
      if (SHIBYTE(v94) < 0)
      {
        operator delete(__p);
        if (!a5) {
          goto LABEL_65;
        }
        goto LABEL_64;
      }
    }

    if (a5) {
LABEL_64:
    }
      (*(void (**)(uint64_t, uint64_t))(*(void *)a1 + 256LL))(a1, a3);
  }

LABEL_65:
  std::string __p = 0LL;
  uint64_t v93 = 0LL;
  uint64_t v94 = 0LL;
  if (a6 && a7)
  {
    uint64_t v49 = *(unsigned __int8 *)(v9 + 23);
    if ((v49 & 0x80u) != 0LL) {
      uint64_t v49 = *(void *)(v9 + 8);
    }
    if (v49)
    {
      int v50 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a7 + 80LL))(a7, v9);
      if (v50 == -1)
      {
        if (dword_1000DE7E8 >= 1)
        {
          sub_10000A2DC(v90, "INFO");
          sub_10002A9EC((BOOL *)v88, (uint64_t)v90);
          int v52 = sub_10002A6A4(&std::cerr, (uint64_t)"Output symbol '", 15LL);
          int v53 = *(char *)(v9 + 23);
          uint64_t v54 = v53 >= 0 ? v9 : *(void *)v9;
          uint64_t v55 = v53 >= 0 ? *(unsigned __int8 *)(v9 + 23) : *(void *)(v9 + 8);
          uint64_t v56 = sub_10002A6A4(v52, v54, v55);
          sub_10002A6A4(v56, (uint64_t)"' missing from target symbol table", 34LL);
          sub_10002AA94(v88);
        }

        int v50 = -1;
        uint64_t v51 = 1LL;
      }

      else
      {
        uint64_t v51 = 0LL;
      }
    }

    else
    {
      uint64_t v51 = 0LL;
      int v50 = -1;
    }

    unint64_t v57 = (*(uint64_t (**)(uint64_t))(*(void *)a6 + 120LL))(a6);
    uint64_t v58 = (*(uint64_t (**)(uint64_t, void))(*(void *)a6 + 64LL))(a6, 0LL);
    if (v57)
    {
      uint64_t v59 = v58;
      uint64_t v60 = 0LL;
      do
      {
        (*(void (**)(void **__return_ptr, uint64_t, uint64_t))(*(void *)a6 + 72LL))(v90, a6, v59);
        (*(void (**)(void **__return_ptr, uint64_t, uint64_t))(*(void *)a6 + 72LL))(v88, a6, v59);
        uint64_t v61 = (*(uint64_t (**)(uint64_t, void **))(*(void *)a7 + 80LL))(a7, v88);
        if (v89 < 0) {
          operator delete(v88[0]);
        }
        BOOL v62 = v61 == -1;
        if (v61 == -1) {
          LODWORD(v61) = v50;
        }
        if (v62 && v50 == -1)
        {
          if (dword_1000DE7E8 >= 1)
          {
            sub_10000A2DC(v88, "INFO");
            sub_10002A9EC(&v87, (uint64_t)v88);
            char v64 = sub_10002A6A4(&std::cerr, (uint64_t)"Output symbol ID ", 17LL);
            uint64_t v65 = (void *)std::ostream::operator<<(v64, v59);
            char v66 = sub_10002A6A4(v65, (uint64_t)" symbol '", 9LL);
            uint64_t v67 = (v91 & 0x80u) == 0 ? v90 : (void **)v90[0];
            int v68 = (v91 & 0x80u) == 0 ? (void *)v91 : v90[1];
            uint64_t v69 = sub_10002A6A4(v66, (uint64_t)v67, (uint64_t)v68);
            sub_10002A6A4(v69, (uint64_t)"' missing from target symbol table", 34LL);
            sub_10002AA94(&v87);
            if (v89 < 0) {
              operator delete(v88[0]);
            }
          }

          ++v51;
          LODWORD(v61) = -1;
        }

        uint64_t v70 = v93;
        if (v93 >= v94)
        {
          uint64_t v72 = ((char *)v93 - (_BYTE *)__p) >> 3;
          unint64_t v73 = ((char *)v94 - (_BYTE *)__p) >> 2;
          if (v73 <= v72 + 1) {
            unint64_t v73 = v72 + 1;
          }
          else {
            unint64_t v74 = v73;
          }
          if (v74) {
            std::string::size_type v75 = (char *)sub_100018788((uint64_t)&v94, v74);
          }
          else {
            std::string::size_type v75 = 0LL;
          }
          uint64_t v76 = (unint64_t *)&v75[8 * v72];
          *uint64_t v76 = v59 | ((unint64_t)v61 << 32);
          uint64_t v71 = v76 + 1;
          uint64_t v78 = (char *)__p;
          unint64_t v77 = (char *)v93;
          if (v93 != __p)
          {
            do
            {
              unint64_t v79 = *((void *)v77 - 1);
              v77 -= 8;
              *--uint64_t v76 = v79;
            }

            while (v77 != v78);
            unint64_t v77 = (char *)__p;
          }

          std::string __p = v76;
          uint64_t v93 = v71;
          uint64_t v94 = (unint64_t *)&v75[8 * v74];
          if (v77) {
            operator delete(v77);
          }
        }

        else
        {
          unint64_t *v93 = v59 | ((unint64_t)v61 << 32);
          uint64_t v71 = v70 + 1;
        }

        uint64_t v93 = v71;
        if (++v60 < v57) {
          uint64_t v59 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a6 + 64LL))(a6, v60);
        }
      }

      while (v60 != v57);
    }

    uint64_t v11 = a1;
    if (v51)
    {
      sub_10000A2DC(v90, "WARNING");
      sub_10002A9EC((BOOL *)v88, (uint64_t)v90);
      uint64_t v80 = sub_10002A6A4(&std::cerr, (uint64_t)"Target symbol table missing: ", 29LL);
      unsigned __int8 v81 = (void *)std::ostream::operator<<(v80, v51);
      sub_10002A6A4(v81, (uint64_t)" output symbols", 15LL);
      sub_10002AA94(v88);
    }

    if (a9) {
      (*(void (**)(uint64_t, uint64_t))(*(void *)a1 + 264LL))(a1, a7);
    }
  }

  sub_100062528(v11, &v95, (int **)&__p);
  if (__p)
  {
    uint64_t v93 = (unint64_t *)__p;
    operator delete(__p);
  }

  if (v95)
  {
    uint64_t v96 = v95;
    operator delete(v95);
  }

void sub_1000623F4( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, int a15, __int16 a16, char a17, char a18, void *a19, uint64_t a20, int a21, __int16 a22, char a23, char a24, void *__p, uint64_t a26, int a27, __int16 a28, char a29, char a30, void *a31, uint64_t a32, int a33, __int16 a34, char a35, char a36)
{
  if (a30 < 0) {
    operator delete(__p);
  }
  if (a31) {
    operator delete(a31);
  }
  int v38 = *(void **)(v36 - 112);
  if (v38)
  {
    *(void *)(v36 - 104) = v38;
    operator delete(v38);
  }

  _Unwind_Resume(exception_object);
}

uint64_t sub_100062528(uint64_t a1, int **a2, int **a3)
{
  uint64_t v6 = (*(uint64_t (**)(uint64_t, uint64_t, void))(*(void *)a1 + 56LL))(a1, 0xFFFFFFFF0007LL, 0LL);
  sub_100062950((uint64_t)v28, *a2, a2[1]);
  sub_100062950((uint64_t)v27, *a3, a3[1]);
  uint64_t v24 = 0LL;
  int v25 = 0;
  unsigned int v26 = 0;
  (*(void (**)(uint64_t, uint64_t *))(*(void *)a1 + 112LL))(a1, &v24);
  while (1)
  {
    if (!v24)
    {
LABEL_7:
      uint64_t v7 = v26;
      goto LABEL_8;
    }

    if (!v24) {
      goto LABEL_7;
    }
    uint64_t v7 = (*(uint64_t (**)(void))(*(void *)v24 + 24LL))();
LABEL_8:
    (*(void (**)(uint64_t, uint64_t, uint64_t *))(*(void *)a1 + 272LL))(a1, v7, &v23);
    while (((*(uint64_t (**)(uint64_t))(*(void *)v23 + 16LL))(v23) & 1) == 0)
    {
      uint64_t v8 = (*(uint64_t (**)(uint64_t))(*(void *)v23 + 24LL))(v23);
      uint64_t v20 = *(void *)v8;
      int v21 = *(_DWORD *)(v8 + 8);
      int v22 = *(_DWORD *)(v8 + 12);
      uint64_t v9 = sub_10005C1A8(v28, (int *)&v20);
      if (v9)
      {
        if (*((_DWORD *)v9 + 5) == -1)
        {
          if (byte_1000DDAF8) {
            sub_10000A2DC(__p, "FATAL");
          }
          else {
            sub_10000A2DC(__p, "ERROR");
          }
          sub_10002A9EC(&v19, (uint64_t)__p);
          uint64_t v11 = sub_10002A6A4(&std::cerr, (uint64_t)"Input symbol ID ", 16LL);
          uint64_t v12 = (void *)std::ostream::operator<<(v11, v20);
          sub_10002A6A4(v12, (uint64_t)" missing from target vocabulary", 31LL);
          goto LABEL_30;
        }

        LODWORD(v2RDString::RDString((RDString *)&v66, theString, 0) = *((_DWORD *)v9 + 5);
      }

      unint64_t v10 = sub_10005C1A8(v27, (int *)&v20 + 1);
      if (v10)
      {
        if (*((_DWORD *)v10 + 5) == -1)
        {
          if (byte_1000DDAF8) {
            sub_10000A2DC(__p, "FATAL");
          }
          else {
            sub_10000A2DC(__p, "ERROR");
          }
          sub_10002A9EC(&v19, (uint64_t)__p);
          uint64_t v13 = sub_10002A6A4(&std::cerr, (uint64_t)"Output symbol id ", 17LL);
          std::string::size_type v14 = (void *)std::ostream::operator<<(v13, HIDWORD(v20));
          sub_10002A6A4(v14, (uint64_t)" missing from target vocabulary", 31LL);
LABEL_30:
          sub_10002AA94(&v19);
          if (v18 < 0) {
            operator delete(__p[0]);
          }
          (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)a1 + 168LL))(a1, 4LL, 4LL);
          if (v23) {
            (*(void (**)(uint64_t))(*(void *)v23 + 8LL))(v23);
          }
          if (v24) {
            (*(void (**)(uint64_t))(*(void *)v24 + 8LL))(v24);
          }
          goto LABEL_36;
        }

        HIDWORD(v2RDString::RDString((RDString *)&v66, theString, 0) = *((_DWORD *)v10 + 5);
      }

      (*(void (**)(uint64_t, uint64_t *))(*(void *)v23 + 80LL))(v23, &v20);
      (*(void (**)(uint64_t))(*(void *)v23 + 32LL))(v23);
    }

    if (v23) {
      (*(void (**)(uint64_t))(*(void *)v23 + 8LL))(v23);
    }
    if (v24) {
      (*(void (**)(uint64_t))(*(void *)v24 + 32LL))(v24);
    }
    else {
      ++v26;
    }
  }

  if (v24) {
    (*(void (**)(void))(*(void *)v24 + 8LL))();
  }
LABEL_39:
  uint64_t v16 = sub_1000A4BC8(v6);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)a1 + 168LL))(a1, v16, 0xFFFFFFFF0007LL);
LABEL_36:
  sub_10001A760((uint64_t)v27);
  return sub_10001A760((uint64_t)v28);
}

void sub_100062894( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, char a25)
{
}

uint64_t sub_100062950(uint64_t a1, int *a2, int *a3)
{
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_DWORD *)(a1 + 32) = 1065353216;
  if (a2 != a3)
  {
    unint64_t v5 = a2;
    do
    {
      sub_1000629C8(a1, v5, v5);
      v5 += 2;
    }

    while (v5 != a3);
  }

  return a1;
}

void sub_1000629B4(_Unwind_Exception *a1)
{
}

void *sub_1000629C8(uint64_t a1, int *a2, void *a3)
{
  unint64_t v6 = *a2;
  unint64_t v7 = *(void *)(a1 + 8);
  if (v7)
  {
    uint8x8_t v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      unint64_t v3 = *a2;
      if (v7 <= v6) {
        unint64_t v3 = v6 % v7;
      }
    }

    else
    {
      unint64_t v3 = (v7 - 1) & v6;
    }

    uint64_t v9 = *(void ***)(*(void *)a1 + 8 * v3);
    if (v9)
    {
      unint64_t v10 = *v9;
      if (*v9)
      {
        do
        {
          unint64_t v11 = v10[1];
          if (v11 == v6)
          {
            if (*((_DWORD *)v10 + 4) == (_DWORD)v6) {
              return v10;
            }
          }

          else
          {
            if (v8.u32[0] > 1uLL)
            {
              if (v11 >= v7) {
                v11 %= v7;
              }
            }

            else
            {
              v11 &= v7 - 1;
            }

            if (v11 != v3) {
              break;
            }
          }

          unint64_t v10 = (void *)*v10;
        }

        while (v10);
      }
    }
  }

  unint64_t v10 = operator new(0x18uLL);
  *unint64_t v10 = 0LL;
  v10[1] = v6;
  v10[2] = *a3;
  float v12 = (float)(unint64_t)(*(void *)(a1 + 24) + 1LL);
  float v13 = *(float *)(a1 + 32);
  if (!v7 || (float)(v13 * (float)v7) < v12)
  {
    BOOL v14 = 1LL;
    if (v7 >= 3) {
      BOOL v14 = (v7 & (v7 - 1)) != 0;
    }
    unint64_t v15 = v14 | (2 * v7);
    unint64_t v16 = vcvtps_u32_f32(v12 / v13);
    if (v15 <= v16) {
      size_t v17 = v16;
    }
    else {
      size_t v17 = v15;
    }
    sub_100018334(a1, v17);
    unint64_t v7 = *(void *)(a1 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v7 <= v6) {
        unint64_t v3 = v6 % v7;
      }
      else {
        unint64_t v3 = v6;
      }
    }

    else
    {
      unint64_t v3 = (v7 - 1) & v6;
    }
  }

  uint64_t v18 = *(void *)a1;
  BOOL v19 = *(void **)(*(void *)a1 + 8 * v3);
  if (v19)
  {
    *unint64_t v10 = *v19;
LABEL_38:
    void *v19 = v10;
    goto LABEL_39;
  }

  *unint64_t v10 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = v10;
  *(void *)(v18 + 8 * v3) = a1 + 16;
  if (*v10)
  {
    unint64_t v20 = *(void *)(*v10 + 8LL);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v20 >= v7) {
        v20 %= v7;
      }
    }

    else
    {
      v20 &= v7 - 1;
    }

    BOOL v19 = (void *)(*(void *)a1 + 8 * v20);
    goto LABEL_38;
  }

void sub_100062BCC(_Unwind_Exception *a1)
{
}

uint64_t sub_100062BE0(uint64_t a1, uint64_t *a2)
{
  uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 16LL))(a1);
  if ((_DWORD)result == -1) {
    return result;
  }
  unint64_t v5 = (*(uint64_t (**)(uint64_t, uint64_t, void))(*(void *)a1 + 56LL))(a1, 0xFFFFFFFF0007LL, 0LL);
  uint64_t v6 = (*(uint64_t (**)(uint64_t))(*(void *)*a2 + 16LL))(*a2);
  (*(void (**)(uint64_t, uint64_t))(*(void *)a1 + 152LL))(a1, v6);
  uint64_t v11 = 0LL;
  int v12 = 0;
  unsigned int v13 = 0;
  (*(void (**)(uint64_t, uint64_t *))(*(void *)a1 + 112LL))(a1, &v11);
  while (1)
  {
    if (!v11)
    {
      if ((int)v13 >= v12) {
        return (*(uint64_t (**)(uint64_t, unint64_t, uint64_t))(*(void *)a1 + 168LL))( a1,  v5 & 0xFFFF0FFF0007LL | (((v5 >> 16) & 1) << 28) | 0x40000000,  0xFFFFFFFF0007LL);
      }
LABEL_8:
      uint64_t v7 = v13;
      goto LABEL_9;
    }

    if (!v11) {
      goto LABEL_8;
    }
    uint64_t v7 = (*(uint64_t (**)(void))(*(void *)v11 + 24LL))();
LABEL_9:
    sub_100062DF4(a2, v7);
    (*(void (**)(uint64_t, uint64_t))(*(void *)a1 + 216LL))(a1, v7);
    for (unint64_t i = a2[5]; ; a2[5] = i)
    {
      uint64_t v9 = a2[2];
      if (i >= (a2[3] - v9) >> 4) {
        break;
      }
      (*(void (**)(uint64_t, uint64_t, unint64_t))(*(void *)a1 + 184LL))(a1, v7, v9 + 16 * i);
      unint64_t i = a2[5] + 1;
    }

    (*(void (**)(_BYTE *__return_ptr, uint64_t, uint64_t))(*(void *)*a2 + 24LL))(v10, *a2, v7);
    (*(void (**)(uint64_t, uint64_t, _BYTE *))(*(void *)a1 + 160LL))(a1, v7, v10);
    if (v11) {
      (*(void (**)(uint64_t))(*(void *)v11 + 32LL))(v11);
    }
    else {
      ++v13;
    }
  }

  if (v11) {
    (*(void (**)(void))(*(void *)v11 + 8LL))();
  }
  return (*(uint64_t (**)(uint64_t, unint64_t, uint64_t))(*(void *)a1 + 168LL))( a1,  v5 & 0xFFFF0FFF0007LL | (((v5 >> 16) & 1) << 28) | 0x40000000,  0xFFFFFFFF0007LL);
}

void sub_100062DCC( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10) {
    (*(void (**)(uint64_t))(*(void *)a10 + 8LL))(a10);
  }
  _Unwind_Resume(exception_object);
}

void sub_100062DF4(uint64_t *a1, uint64_t a2)
{
  a1[5] = 0LL;
  uint64_t v4 = a1 + 2;
  a1[3] = a1[2];
  unint64_t v5 = (*(uint64_t (**)(uint64_t))(*(void *)*a1 + 32LL))(*a1);
  sub_10002D3DC(v4, v5);
  uint64_t v6 = *a1;
  __int128 v14 = 0u;
  __int128 v15 = 0u;
  unint64_t v16 = 0LL;
  (*(void (**)(uint64_t, uint64_t, __int128 *))(*(void *)v6 + 120LL))(v6, a2, &v14);
  while (1)
  {
    if (!(void)v14)
    {
      goto LABEL_7;
    }

    if ((void)v14)
    {
      uint64_t v7 = (*(uint64_t (**)(void))(*(void *)v14 + 24LL))();
      goto LABEL_8;
    }

void sub_100062F7C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  if (a9) {
    (*(void (**)(uint64_t))(*(void *)a9 + 8LL))(a9);
  }
  else {
    sub_100097C1C((uint64_t)&a9);
  }
  _Unwind_Resume(a1);
}

void sub_100062FA8(uint64_t *a1, uint64_t *a2, uint64_t a3, uint64_t a4, char a5)
{
LABEL_1:
  uint64_t v9 = a1;
LABEL_2:
  uint64_t v10 = 1 - a4;
  while (2)
  {
    a1 = v9;
    uint64_t v11 = v10;
    uint64_t v12 = (char *)a2 - (char *)v9;
    unint64_t v13 = ((char *)a2 - (char *)v9) >> 4;
    switch(v13)
    {
      case 0uLL:
      case 1uLL:
        return;
      case 2uLL:
        if (*((_DWORD *)a2 - 3) < *((_DWORD *)v9 + 1))
        {
          uint64_t v22 = *v9;
          int v23 = *((_DWORD *)v9 + 2);
          int v24 = *((_DWORD *)v9 + 3);
          *uint64_t v9 = *(a2 - 2);
          *((_DWORD *)v9 + 2) = *((_DWORD *)a2 - 2);
          *((_DWORD *)v9 + 3) = *((_DWORD *)a2 - 1);
          *(a2 - 2) = v22;
          *((_DWORD *)a2 - 2) = v23;
          *((_DWORD *)a2 - 1) = v24;
        }

        return;
      case 3uLL:
        sub_100063458(v9, v9 + 2, a2 - 2);
        return;
      case 4uLL:
        sub_10006397C((uint64_t)v9, (uint64_t)(v9 + 2), (uint64_t)(v9 + 4), (uint64_t)(a2 - 2));
        return;
      case 5uLL:
        sub_100063A74((uint64_t)v9, (uint64_t)(v9 + 2), (uint64_t)(v9 + 4), (uint64_t)(v9 + 6), (uint64_t)(a2 - 2));
        return;
      default:
        if (v12 <= 383)
        {
          if ((a5 & 1) != 0) {
            sub_100063324((uint64_t)v9, a2);
          }
          else {
            sub_1000633CC(v9, a2);
          }
          return;
        }

        if (v11 != 1)
        {
          unint64_t v14 = v13 >> 1;
          __int128 v15 = &v9[2 * (v13 >> 1)];
          if ((unint64_t)v12 < 0x801)
          {
            sub_100063458(&v9[2 * (v13 >> 1)], v9, a2 - 2);
            if ((a5 & 1) != 0) {
              goto LABEL_11;
            }
          }

          else
          {
            sub_100063458(v9, &v9[2 * (v13 >> 1)], a2 - 2);
            sub_100063458(v9 + 2, v15 - 2, a2 - 4);
            sub_100063458(v9 + 4, &v9[2 * v14 + 2], a2 - 6);
            sub_100063458(v15 - 2, v15, &v9[2 * v14 + 2]);
            uint64_t v16 = *v9;
            int v17 = *((_DWORD *)v9 + 2);
            int v18 = *((_DWORD *)v9 + 3);
            *uint64_t v9 = *v15;
            *((_DWORD *)v9 + 2) = *((_DWORD *)v15 + 2);
            *((_DWORD *)v9 + 3) = *((_DWORD *)v15 + 3);
            uint64_t *v15 = v16;
            *((_DWORD *)v15 + 2) = v17;
            *((_DWORD *)v15 + 3) = v18;
            if ((a5 & 1) != 0) {
              goto LABEL_11;
            }
          }

          if (*((_DWORD *)v9 - 3) >= *((_DWORD *)v9 + 1))
          {
            uint64_t v9 = sub_100063594(v9, (unint64_t)a2);
            goto LABEL_16;
          }

LABEL_11:
          BOOL v19 = sub_1000636A4(v9, (unint64_t)a2);
          if ((v20 & 1) == 0) {
            goto LABEL_14;
          }
          BOOL v21 = sub_1000637B8((uint64_t)v9, (uint64_t)v19);
          uint64_t v9 = v19 + 2;
          if (!sub_1000637B8((uint64_t)(v19 + 2), (uint64_t)a2))
          {
            uint64_t v10 = v11 + 1;
            if (v21) {
              continue;
            }
LABEL_14:
            sub_100062FA8(a1, v19, a3, -v11, a5 & 1);
            uint64_t v9 = v19 + 2;
LABEL_16:
            a5 = 0;
            a4 = -v11;
            goto LABEL_2;
          }

          a4 = -v11;
          a2 = v19;
          if (v21) {
            return;
          }
          goto LABEL_1;
        }

        if (v9 != a2) {
          sub_100063BB8((uint64_t)v9, a2, a2, a3);
        }
        return;
    }
  }

          BOOL v19 = sub_1000649D0(v9, (unint64_t)a2);
          if ((v20 & 1) == 0) {
            goto LABEL_14;
          }
          BOOL v21 = sub_100064AC4((uint64_t)v9, v19);
          uint64_t v9 = v19 + 2;
          if (!sub_100064AC4((uint64_t)(v19 + 2), a2))
          {
            uint64_t v10 = v11 + 1;
            if (v21) {
              continue;
            }
LABEL_14:
            sub_100064304(a1, v19, a3, -v11, a5 & 1);
            uint64_t v9 = v19 + 2;
LABEL_16:
            a5 = 0;
            a4 = -v11;
            goto LABEL_2;
          }

          a4 = -v11;
          a2 = v19;
          if (v21) {
            return;
          }
          goto LABEL_1;
        }

        if (v9 != a2) {
          sub_100064EC0((int *)v9, (int *)a2, (int *)a2, a3);
        }
        return;
    }
  }

    uint64_t v9 = v26;
    uint64_t v10 = v26;
    goto LABEL_12;
  }

  unint64_t v13 = (*(uint64_t (**)(uint64_t, float))(*(void *)a1 + 16LL))(a1, *(float *)&v23);
  (*(void (**)(uint64_t, uint64_t, uint64_t *))(*(void *)a1 + 272LL))(a1, v13, &v21);
  while (!(*(unsigned int (**)(uint64_t))(*(void *)v21 + 16LL))(v21))
  {
    unint64_t v14 = (*(uint64_t (**)(uint64_t))(*(void *)v21 + 24LL))(v21);
    int v23 = *(int **)v14;
    __int128 v15 = *(float *)(v14 + 8);
    int v24 = v15;
    uint64_t v25 = *(_DWORD *)(v14 + 12);
    if (v15 == -INFINITY || (uint64_t v16 = *(float *)a2, *(float *)a2 >= -INFINITY) && *(float *)a2 <= -INFINITY)
    {
      int v17 = *(float *)sub_1000606CC();
    }

    else if (v16 == INFINITY)
    {
      int v17 = NAN;
    }

    else
    {
      int v17 = INFINITY;
      if (v15 != INFINITY) {
        int v17 = v15 - v16;
      }
    }

    int v24 = v17;
    (*(void (**)(uint64_t, int **))(*(void *)v21 + 80LL))(v21, &v23);
    (*(void (**)(uint64_t))(*(void *)v21 + 32LL))(v21);
  }

  if (v21) {
    (*(void (**)(uint64_t))(*(void *)v21 + 8LL))(v21);
  }
  (*(void (**)(int **__return_ptr, uint64_t, uint64_t))(*(void *)a1 + 24LL))(&v23, a1, v13);
  if (*(float *)&v23 == -INFINITY || (int v18 = *(float *)a2, *(float *)a2 >= -INFINITY) && *(float *)a2 <= -INFINITY)
  {
    BOOL v19 = *(float *)sub_1000606CC();
  }

  else
  {
    BOOL v19 = *(float *)&v23 - v18;
    if (v18 == INFINITY) {
      BOOL v19 = NAN;
    }
  }

  char v20 = v19;
  return (int *)(*(uint64_t (**)(uint64_t, uint64_t, float *))(*(void *)a1 + 160LL))(a1, v13, &v20);
}

uint64_t sub_100063324(uint64_t result, void *a2)
{
  if ((void *)result != a2)
  {
    uint64_t v2 = (void *)(result + 16);
    if ((void *)(result + 16) != a2)
    {
      uint64_t v3 = 0LL;
      uint64_t v4 = (_DWORD *)result;
      do
      {
        unint64_t v5 = v2;
        if (v4[5] < v4[1])
        {
          uint64_t v6 = *v2;
          int v7 = v4[6];
          int v8 = v4[7];
          uint64_t v9 = HIDWORD(*v5);
          uint64_t v10 = v3;
          while (1)
          {
            uint64_t v11 = result + v10;
            *(void *)(v11 + 16) = *(void *)(result + v10);
            *(_DWORD *)(v11 + ++*(void *)(result + 24) = *(_DWORD *)(result + v10 + 8);
            *(_DWORD *)(v11 + 2std::istream::~istream(v2, v3 + 8) = *(_DWORD *)(result + v10 + 12);
            if (!v10) {
              break;
            }
            v10 -= 16LL;
            if (*(_DWORD *)(v11 - 12) <= (int)v9)
            {
              uint64_t v12 = result + v10 + 16;
              goto LABEL_10;
            }
          }

          uint64_t v12 = result;
LABEL_10:
          *(void *)uint64_t v12 = v6;
          *(_DWORD *)(v12 + std::istream::~istream(v2, v3 + 8) = v7;
          *(_DWORD *)(v12 + 12) = v8;
        }

        uint64_t v2 = v5 + 2;
        v3 += 16LL;
        uint64_t v4 = v5;
      }

      while (v5 + 2 != a2);
    }
  }

  return result;
}

_DWORD *sub_1000633CC(_DWORD *result, void *a2)
{
  if (result != (_DWORD *)a2)
  {
    uint64_t v2 = result + 4;
    if (result + 4 != (_DWORD *)a2)
    {
      uint64_t v3 = result + 7;
      do
      {
        uint64_t v4 = v2;
        if (result[5] < result[1])
        {
          uint64_t v5 = *v2;
          int v6 = result[6];
          int v7 = result[7];
          uint64_t v8 = HIDWORD(*v4);
          uint64_t v9 = v3;
          do
          {
            uint64_t v10 = v9;
            *(void *)(v9 - 3) = *(void *)(v9 - 7);
            *(v9 - 1) = *(v9 - 5);
            int v11 = *(v9 - 4);
            v9 -= 4;
            *uint64_t v10 = v11;
          }

          while (*(v10 - 10) > (int)v8);
          *(void *)(v9 - 3) = v5;
          *(v9 - 1) = v6;
          *uint64_t v9 = v7;
        }

        uint64_t v2 = v4 + 2;
        v3 += 4;
        uint64_t result = v4;
      }

      while (v4 + 2 != a2);
    }
  }

  return result;
}

uint64_t sub_100063458(uint64_t *a1, uint64_t *a2, uint64_t *a3)
{
  int v3 = *((_DWORD *)a2 + 1);
  int v4 = *((_DWORD *)a3 + 1);
  if (v3 < *((_DWORD *)a1 + 1))
  {
    uint64_t v5 = *a1;
    int v6 = *((_DWORD *)a1 + 2);
    int v7 = *((_DWORD *)a1 + 3);
    if (v4 < v3)
    {
      *a1 = *a3;
      *((_DWORD *)a1 + 2) = *((_DWORD *)a3 + 2);
      *((_DWORD *)a1 + 3) = *((_DWORD *)a3 + 3);
      *a3 = v5;
      *((_DWORD *)a3 + 2) = v6;
      *((_DWORD *)a3 + 3) = v7;
      return 1LL;
    }

    *a1 = *a2;
    *((_DWORD *)a1 + 2) = *((_DWORD *)a2 + 2);
    *((_DWORD *)a1 + 3) = *((_DWORD *)a2 + 3);
    *a2 = v5;
    *((_DWORD *)a2 + 2) = v6;
    *((_DWORD *)a2 + 3) = v7;
    if (*((_DWORD *)a3 + 1) >= SHIDWORD(v5)) {
      return 1LL;
    }
    *a2 = *a3;
    *((_DWORD *)a2 + 2) = *((_DWORD *)a3 + 2);
    *((_DWORD *)a2 + 3) = *((_DWORD *)a3 + 3);
    *a3 = v5;
    *((_DWORD *)a3 + 2) = v6;
    *((_DWORD *)a3 + 3) = v7;
    return 2LL;
  }

  if (v4 < v3)
  {
    uint64_t v8 = *a2;
    int v9 = *((_DWORD *)a2 + 2);
    int v10 = *((_DWORD *)a2 + 3);
    *a2 = *a3;
    *((_DWORD *)a2 + 2) = *((_DWORD *)a3 + 2);
    *((_DWORD *)a2 + 3) = *((_DWORD *)a3 + 3);
    *a3 = v8;
    *((_DWORD *)a3 + 2) = v9;
    *((_DWORD *)a3 + 3) = v10;
    if (*((_DWORD *)a2 + 1) >= *((_DWORD *)a1 + 1)) {
      return 1LL;
    }
    uint64_t v11 = *a1;
    int v12 = *((_DWORD *)a1 + 2);
    int v13 = *((_DWORD *)a1 + 3);
    *a1 = *a2;
    *((_DWORD *)a1 + 2) = *((_DWORD *)a2 + 2);
    *((_DWORD *)a1 + 3) = *((_DWORD *)a2 + 3);
    *a2 = v11;
    *((_DWORD *)a2 + 2) = v12;
    *((_DWORD *)a2 + 3) = v13;
    return 2LL;
  }

  return 0LL;
}

uint64_t *sub_100063594(uint64_t *a1, unint64_t a2)
{
  unint64_t v2 = *a1;
  unint64_t v3 = HIDWORD(*a1);
  if (*(_DWORD *)(a2 - 12) <= (int)v3)
  {
    int v7 = a1 + 2;
    do
    {
      uint64_t v5 = v7;
      int v8 = *((_DWORD *)v7 + 1);
      v7 += 2;
    }

    while (v8 <= (int)v3);
  }

  else
  {
    int v4 = a1;
    do
    {
      uint64_t v5 = v4 + 2;
      int v6 = *((_DWORD *)v4 + 5);
      v4 += 2;
    }

    while (v6 <= (int)v3);
  }

  if ((unint64_t)v5 >= a2)
  {
    unint64_t v9 = a2;
  }

  else
  {
    do
    {
      unint64_t v9 = a2 - 16;
      int v10 = *(_DWORD *)(a2 - 12);
      a2 -= 16LL;
    }

    while (v10 > (int)v3);
  }

  int v11 = *((_DWORD *)a1 + 2);
  int v12 = *((_DWORD *)a1 + 3);
  while ((unint64_t)v5 < v9)
  {
    uint64_t v13 = *v5;
    int v14 = *((_DWORD *)v5 + 2);
    int v15 = *((_DWORD *)v5 + 3);
    uint64_t *v5 = *(void *)v9;
    *((_DWORD *)v5 + 2) = *(_DWORD *)(v9 + 8);
    *((_DWORD *)v5 + 3) = *(_DWORD *)(v9 + 12);
    *(void *)unint64_t v9 = v13;
    *(_DWORD *)(v9 + std::istream::~istream(v2, v3 + 8) = v14;
    *(_DWORD *)(v9 + 12) = v15;
    do
    {
      int v16 = *((_DWORD *)v5 + 5);
      v5 += 2;
    }

    while (v16 <= (int)v3);
    do
    {
      int v17 = *(_DWORD *)(v9 - 12);
      v9 -= 16LL;
    }

    while (v17 > (int)v3);
  }

  if (v5 - 2 != a1)
  {
    *a1 = *(v5 - 2);
    *((_DWORD *)a1 + 2) = *((_DWORD *)v5 - 2);
    *((_DWORD *)a1 + 3) = *((_DWORD *)v5 - 1);
  }

  *(v5 - 2) = v2;
  *((_DWORD *)v5 - 2) = v11;
  *((_DWORD *)v5 - 1) = v12;
  return v5;
}

uint64_t *sub_1000636A4(uint64_t *a1, unint64_t a2)
{
  uint64_t v2 = 0LL;
  uint64_t v3 = *a1;
  int v4 = *((_DWORD *)a1 + 2);
  int v5 = *((_DWORD *)a1 + 3);
  unint64_t v6 = HIDWORD(*a1);
  do
  {
    int v7 = HIDWORD(a1[v2 + 2]);
    v2 += 2LL;
  }

  while (v7 < (int)v6);
  int v8 = &a1[v2];
  if (v2 == 2)
  {
    while ((unint64_t)v8 < a2)
    {
      unint64_t v9 = a2 - 16;
      int v11 = *(_DWORD *)(a2 - 12);
      a2 -= 16LL;
    }

    unint64_t v9 = a2;
  }

  else
  {
    do
    {
      unint64_t v9 = a2 - 16;
      int v10 = *(_DWORD *)(a2 - 12);
      a2 -= 16LL;
    }

    while (v10 >= (int)v6);
  }

BOOL sub_1000637B8(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (a2 - a1) >> 4;
  BOOL result = 1LL;
  switch(v4)
  {
    case 0LL:
    case 1LL:
      return result;
    case 2LL:
      if (*(_DWORD *)(a2 - 12) < *(_DWORD *)(a1 + 4))
      {
        uint64_t v6 = *(void *)a1;
        int v7 = *(_DWORD *)(a1 + 8);
        int v8 = *(_DWORD *)(a1 + 12);
        *(void *)a1 = *(void *)(a2 - 16);
        *(_DWORD *)(a1 + std::istream::~istream(v2, v3 + 8) = *(_DWORD *)(a2 - 8);
        *(_DWORD *)(a1 + 12) = *(_DWORD *)(a2 - 4);
        *(void *)(a2 - 16) = v6;
        *(_DWORD *)(a2 - std::istream::~istream(v2, v3 + 8) = v7;
        *(_DWORD *)(a2 - 4) = v8;
      }

      return result;
    case 3LL:
      sub_100063458((uint64_t *)a1, (uint64_t *)(a1 + 16), (uint64_t *)(a2 - 16));
      return 1LL;
    case 4LL:
      sub_10006397C(a1, a1 + 16, a1 + 32, a2 - 16);
      return 1LL;
    case 5LL:
      sub_100063A74(a1, a1 + 16, a1 + 32, a1 + 48, a2 - 16);
      return 1LL;
    default:
      uint64_t v9 = a1 + 32;
      sub_100063458((uint64_t *)a1, (uint64_t *)(a1 + 16), (uint64_t *)(a1 + 32));
      uint64_t v10 = a1 + 48;
      if (a1 + 48 == a2) {
        return 1LL;
      }
      uint64_t v11 = 0LL;
      int v12 = 0;
      break;
  }

  while (1)
  {
    if (*(_DWORD *)(v10 + 4) < *(_DWORD *)(v9 + 4))
    {
      uint64_t v13 = *(void *)v10;
      int v14 = *(_DWORD *)(v10 + 8);
      int v15 = *(_DWORD *)(v10 + 12);
      uint64_t v16 = HIDWORD(*(void *)v10);
      uint64_t v17 = v11;
      while (1)
      {
        uint64_t v18 = a1 + v17;
        *(void *)(v18 + 4std::istream::~istream(v2, v3 + 8) = *(void *)(a1 + v17 + 32);
        *(_DWORD *)(v18 + ++*(void *)(result + 56) = *(_DWORD *)(a1 + v17 + 40);
        *(_DWORD *)(v18 + 6RDString::RDString((RDString *)&v66, theString, 0) = *(_DWORD *)(a1 + v17 + 44);
        if (v17 == -32) {
          break;
        }
        v17 -= 16LL;
        if (*(_DWORD *)(v18 + 20) <= (int)v16)
        {
          uint64_t v19 = a1 + v17 + 48;
          goto LABEL_12;
        }
      }

      uint64_t v19 = a1;
LABEL_12:
      *(void *)uint64_t v19 = v13;
      *(_DWORD *)(v19 + std::istream::~istream(v2, v3 + 8) = v14;
      *(_DWORD *)(v19 + 12) = v15;
      if (++v12 == 8) {
        return v10 + 16 == a2;
      }
    }

    uint64_t v9 = v10;
    v11 += 16LL;
    v10 += 16LL;
    if (v10 == a2) {
      return 1LL;
    }
  }

float sub_10006397C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (*(_DWORD *)(a4 + 4) < *(_DWORD *)(a3 + 4))
  {
    uint64_t v9 = *(void *)a3;
    float result = *(float *)(a3 + 8);
    int v10 = *(_DWORD *)(a3 + 12);
    *(void *)a3 = *(void *)a4;
    *(_DWORD *)(a3 + std::istream::~istream(v2, v3 + 8) = *(_DWORD *)(a4 + 8);
    *(_DWORD *)(a3 + 12) = *(_DWORD *)(a4 + 12);
    *(void *)a4 = v9;
    *(float *)(a4 + std::istream::~istream(v2, v3 + 8) = result;
    *(_DWORD *)(a4 + 12) = v10;
    if (*(_DWORD *)(a3 + 4) < *(_DWORD *)(a2 + 4))
    {
      uint64_t v11 = *(void *)a2;
      float result = *(float *)(a2 + 8);
      int v12 = *(_DWORD *)(a2 + 12);
      *(void *)a2 = *(void *)a3;
      *(_DWORD *)(a2 + std::istream::~istream(v2, v3 + 8) = *(_DWORD *)(a3 + 8);
      *(_DWORD *)(a2 + 12) = *(_DWORD *)(a3 + 12);
      *(void *)a3 = v11;
      *(float *)(a3 + std::istream::~istream(v2, v3 + 8) = result;
      *(_DWORD *)(a3 + 12) = v12;
      if (*(_DWORD *)(a2 + 4) < *(_DWORD *)(a1 + 4))
      {
        uint64_t v13 = *(void *)a1;
        float result = *(float *)(a1 + 8);
        int v14 = *(_DWORD *)(a1 + 12);
        *(void *)a1 = *(void *)a2;
        *(_DWORD *)(a1 + std::istream::~istream(v2, v3 + 8) = *(_DWORD *)(a2 + 8);
        *(_DWORD *)(a1 + 12) = *(_DWORD *)(a2 + 12);
        *(void *)a2 = v13;
        *(float *)(a2 + std::istream::~istream(v2, v3 + 8) = result;
        *(_DWORD *)(a2 + 12) = v14;
      }
    }
  }

  return result;
}

float sub_100063A74(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  float result = sub_10006397C(a1, a2, a3, a4);
  if (*(_DWORD *)(a5 + 4) < *(_DWORD *)(a4 + 4))
  {
    uint64_t v11 = *(void *)a4;
    float result = *(float *)(a4 + 8);
    int v12 = *(_DWORD *)(a4 + 12);
    *(void *)a4 = *(void *)a5;
    *(_DWORD *)(a4 + std::istream::~istream(v2, v3 + 8) = *(_DWORD *)(a5 + 8);
    *(_DWORD *)(a4 + 12) = *(_DWORD *)(a5 + 12);
    *(void *)a5 = v11;
    *(float *)(a5 + std::istream::~istream(v2, v3 + 8) = result;
    *(_DWORD *)(a5 + 12) = v12;
    if (*(_DWORD *)(a4 + 4) < *(_DWORD *)(a3 + 4))
    {
      uint64_t v13 = *(void *)a3;
      float result = *(float *)(a3 + 8);
      int v14 = *(_DWORD *)(a3 + 12);
      *(void *)a3 = *(void *)a4;
      *(_DWORD *)(a3 + std::istream::~istream(v2, v3 + 8) = *(_DWORD *)(a4 + 8);
      *(_DWORD *)(a3 + 12) = *(_DWORD *)(a4 + 12);
      *(void *)a4 = v13;
      *(float *)(a4 + std::istream::~istream(v2, v3 + 8) = result;
      *(_DWORD *)(a4 + 12) = v14;
      if (*(_DWORD *)(a3 + 4) < *(_DWORD *)(a2 + 4))
      {
        uint64_t v15 = *(void *)a2;
        float result = *(float *)(a2 + 8);
        int v16 = *(_DWORD *)(a2 + 12);
        *(void *)a2 = *(void *)a3;
        *(_DWORD *)(a2 + std::istream::~istream(v2, v3 + 8) = *(_DWORD *)(a3 + 8);
        *(_DWORD *)(a2 + 12) = *(_DWORD *)(a3 + 12);
        *(void *)a3 = v15;
        *(float *)(a3 + std::istream::~istream(v2, v3 + 8) = result;
        *(_DWORD *)(a3 + 12) = v16;
        if (*(_DWORD *)(a2 + 4) < *(_DWORD *)(a1 + 4))
        {
          uint64_t v17 = *(void *)a1;
          float result = *(float *)(a1 + 8);
          int v18 = *(_DWORD *)(a1 + 12);
          *(void *)a1 = *(void *)a2;
          *(_DWORD *)(a1 + std::istream::~istream(v2, v3 + 8) = *(_DWORD *)(a2 + 8);
          *(_DWORD *)(a1 + 12) = *(_DWORD *)(a2 + 12);
          *(void *)a2 = v17;
          *(float *)(a2 + std::istream::~istream(v2, v3 + 8) = result;
          *(_DWORD *)(a2 + 12) = v18;
        }
      }
    }
  }

  return result;
}

uint64_t *sub_100063BB8(uint64_t a1, uint64_t *a2, uint64_t *a3, uint64_t a4)
{
  if ((uint64_t *)a1 != a2)
  {
    uint64_t v8 = (uint64_t)a2 - a1;
    uint64_t v9 = ((uint64_t)a2 - a1) >> 4;
    if ((uint64_t)a2 - a1 >= 17)
    {
      unint64_t v10 = (unint64_t)(v9 - 2) >> 1;
      unint64_t v11 = v10 + 1;
      int v12 = (uint64_t *)(a1 + 16 * v10);
      do
      {
        sub_100063D58(a1, a4, v9, v12);
        v12 -= 2;
        --v11;
      }

      while (v11);
    }

    uint64_t v13 = a2;
    if (a2 != a3)
    {
      int v14 = a2;
      do
      {
        if (*((_DWORD *)v14 + 1) < *(_DWORD *)(a1 + 4))
        {
          uint64_t v15 = *v14;
          int v16 = *((_DWORD *)v14 + 2);
          int v17 = *((_DWORD *)v14 + 3);
          *int v14 = *(void *)a1;
          *((_DWORD *)v14 + 2) = *(_DWORD *)(a1 + 8);
          *((_DWORD *)v14 + 3) = *(_DWORD *)(a1 + 12);
          *(void *)a1 = v15;
          *(_DWORD *)(a1 + std::istream::~istream(v2, v3 + 8) = v16;
          *(_DWORD *)(a1 + 12) = v17;
          sub_100063D58(a1, a4, v9, (uint64_t *)a1);
        }

        v14 += 2;
      }

      while (v14 != a3);
      uint64_t v13 = a3;
    }

    if (v8 >= 17)
    {
      uint64_t v18 = (unint64_t)v8 >> 4;
      uint64_t v19 = a2 - 2;
      do
      {
        uint64_t v20 = *(void *)a1;
        int v21 = *(_DWORD *)(a1 + 8);
        int v22 = *(_DWORD *)(a1 + 12);
        uint64_t v23 = sub_100063E3C(a1, a4, v18);
        if (v19 == (uint64_t *)v23)
        {
          *(void *)uint64_t v23 = v20;
          *(_DWORD *)(v23 + std::istream::~istream(v2, v3 + 8) = v21;
          *(_DWORD *)(v23 + 12) = v22;
        }

        else
        {
          *(void *)uint64_t v23 = *v19;
          *(_DWORD *)(v23 + std::istream::~istream(v2, v3 + 8) = *((_DWORD *)v19 + 2);
          *(_DWORD *)(v23 + 12) = *((_DWORD *)v19 + 3);
          uint64_t *v19 = v20;
          *((_DWORD *)v19 + 2) = v21;
          *((_DWORD *)v19 + 3) = v22;
          sub_100063EB8(a1, v23 + 16, a4, (v23 + 16 - a1) >> 4);
        }

        v19 -= 2;
      }

      while (v18-- > 2);
    }

    return v13;
  }

  return a3;
}

uint64_t sub_100063D58(uint64_t result, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  if (a3 >= 2)
  {
    uint64_t v4 = (uint64_t)a4 - result;
    int64_t v5 = (unint64_t)(a3 - 2) >> 1;
    if (v5 >= ((uint64_t)a4 - result) >> 4)
    {
      uint64_t v6 = v4 >> 3;
      uint64_t v7 = (v4 >> 3) + 1;
      uint64_t v8 = (uint64_t *)(result + 16 * v7);
      uint64_t v9 = v6 + 2;
      if (v9 < a3)
      {
        int v10 = *((_DWORD *)v8 + 1);
        int v11 = *((_DWORD *)v8 + 5);
        v8 += 2 * (v10 < v11);
        if (v10 < v11) {
          uint64_t v7 = v9;
        }
      }

      if (*((_DWORD *)v8 + 1) >= *((_DWORD *)a4 + 1))
      {
        uint64_t v12 = *a4;
        int v13 = *((_DWORD *)a4 + 2);
        int v14 = *((_DWORD *)a4 + 3);
        unint64_t v15 = HIDWORD(*a4);
        do
        {
          int v16 = a4;
          a4 = v8;
          *int v16 = *v8;
          *((_DWORD *)v16 + 2) = *((_DWORD *)v8 + 2);
          *((_DWORD *)v16 + 3) = *((_DWORD *)v8 + 3);
          if (v5 < v7) {
            break;
          }
          uint64_t v17 = (2 * v7) | 1;
          uint64_t v8 = (uint64_t *)(result + 16 * v17);
          uint64_t v18 = 2 * v7 + 2;
          if (v18 < a3)
          {
            int v19 = *((_DWORD *)v8 + 1);
            int v20 = *((_DWORD *)v8 + 5);
            v8 += 2 * (v19 < v20);
            if (v19 < v20) {
              uint64_t v17 = v18;
            }
          }

          uint64_t v7 = v17;
        }

        while (*((_DWORD *)v8 + 1) >= (int)v15);
        *a4 = v12;
        *((_DWORD *)a4 + 2) = v13;
        *((_DWORD *)a4 + 3) = v14;
      }
    }
  }

  return result;
}

uint64_t sub_100063E3C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = 0LL;
  uint64_t v4 = a3 - 2;
  if (a3 < 2) {
    uint64_t v4 = a3 - 1;
  }
  uint64_t v5 = v4 >> 1;
  do
  {
    uint64_t v6 = a1 + 16 * (v3 + 1);
    uint64_t v7 = (2 * v3) | 1;
    uint64_t v8 = 2 * v3 + 2;
    if (v8 < a3)
    {
      int v9 = *(_DWORD *)(v6 + 4);
      int v10 = *(_DWORD *)(v6 + 20);
      v6 += 16LL * (v9 < v10);
      if (v9 < v10) {
        uint64_t v7 = v8;
      }
    }

    *(void *)a1 = *(void *)v6;
    *(_DWORD *)(a1 + std::istream::~istream(v2, v3 + 8) = *(_DWORD *)(v6 + 8);
    *(_DWORD *)(a1 + 12) = *(_DWORD *)(v6 + 12);
    a1 = v6;
    uint64_t v3 = v7;
  }

  while (v7 <= v5);
  return v6;
}

uint64_t sub_100063EB8(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a4 >= 2)
  {
    unint64_t v4 = (unint64_t)(a4 - 2) >> 1;
    if (*(_DWORD *)(result + 16 * v4 + 4) < *(_DWORD *)(a2 - 12))
    {
      unint64_t v7 = *(void *)(a2 - 16);
      uint64_t v5 = a2 - 16;
      unint64_t v6 = v7;
      int v8 = *(_DWORD *)(v5 + 8);
      int v9 = *(_DWORD *)(v5 + 12);
      unint64_t v10 = HIDWORD(v7);
      do
      {
        uint64_t v11 = v5;
        uint64_t v5 = result + 16 * v4;
        *(void *)uint64_t v11 = *(void *)v5;
        *(_DWORD *)(v11 + std::istream::~istream(v2, v3 + 8) = *(_DWORD *)(v5 + 8);
        *(_DWORD *)(v11 + 12) = *(_DWORD *)(v5 + 12);
        if (!v4) {
          break;
        }
        unint64_t v4 = (v4 - 1) >> 1;
      }

      while (*(_DWORD *)(result + 16 * v4 + 4) < (int)v10);
      *(void *)uint64_t v5 = v6;
      *(_DWORD *)(v5 + std::istream::~istream(v2, v3 + 8) = v8;
      *(_DWORD *)(v5 + 12) = v9;
    }
  }

  return result;
}

uint64_t sub_100063F3C(uint64_t a1, uint64_t *a2)
{
  uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 16LL))(a1);
  if ((_DWORD)result == -1) {
    return result;
  }
  unint64_t v5 = (*(uint64_t (**)(uint64_t, uint64_t, void))(*(void *)a1 + 56LL))(a1, 0xFFFFFFFF0007LL, 0LL);
  uint64_t v6 = (*(uint64_t (**)(uint64_t))(*(void *)*a2 + 16LL))(*a2);
  (*(void (**)(uint64_t, uint64_t))(*(void *)a1 + 152LL))(a1, v6);
  uint64_t v11 = 0LL;
  int v12 = 0;
  unsigned int v13 = 0;
  (*(void (**)(uint64_t, uint64_t *))(*(void *)a1 + 112LL))(a1, &v11);
  while (1)
  {
    if (!v11)
    {
      if ((int)v13 >= v12) {
        return (*(uint64_t (**)(uint64_t, unint64_t, uint64_t))(*(void *)a1 + 168LL))( a1,  v5 & 0xFFFF0FFF0007LL | (((v5 >> 16) & 1) << 30) | 0x10000000,  0xFFFFFFFF0007LL);
      }
LABEL_8:
      uint64_t v7 = v13;
      goto LABEL_9;
    }

    if (!v11) {
      goto LABEL_8;
    }
    uint64_t v7 = (*(uint64_t (**)(void))(*(void *)v11 + 24LL))();
LABEL_9:
    sub_100064150(a2, v7);
    (*(void (**)(uint64_t, uint64_t))(*(void *)a1 + 216LL))(a1, v7);
    for (unint64_t i = a2[5]; ; a2[5] = i)
    {
      uint64_t v9 = a2[2];
      if (i >= (a2[3] - v9) >> 4) {
        break;
      }
      (*(void (**)(uint64_t, uint64_t, unint64_t))(*(void *)a1 + 184LL))(a1, v7, v9 + 16 * i);
      unint64_t i = a2[5] + 1;
    }

    (*(void (**)(_BYTE *__return_ptr, uint64_t, uint64_t))(*(void *)*a2 + 24LL))(v10, *a2, v7);
    (*(void (**)(uint64_t, uint64_t, _BYTE *))(*(void *)a1 + 160LL))(a1, v7, v10);
    if (v11) {
      (*(void (**)(uint64_t))(*(void *)v11 + 32LL))(v11);
    }
    else {
      ++v13;
    }
  }

  if (v11) {
    (*(void (**)(void))(*(void *)v11 + 8LL))();
  }
  return (*(uint64_t (**)(uint64_t, unint64_t, uint64_t))(*(void *)a1 + 168LL))( a1,  v5 & 0xFFFF0FFF0007LL | (((v5 >> 16) & 1) << 30) | 0x10000000,  0xFFFFFFFF0007LL);
}

void sub_100064128( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10) {
    (*(void (**)(uint64_t))(*(void *)a10 + 8LL))(a10);
  }
  _Unwind_Resume(exception_object);
}

void sub_100064150(uint64_t *a1, uint64_t a2)
{
  a1[5] = 0LL;
  unint64_t v4 = a1 + 2;
  a1[3] = a1[2];
  unint64_t v5 = (*(uint64_t (**)(uint64_t))(*(void *)*a1 + 32LL))(*a1);
  sub_10002D3DC(v4, v5);
  uint64_t v6 = *a1;
  __int128 v14 = 0u;
  __int128 v15 = 0u;
  unint64_t v16 = 0LL;
  (*(void (**)(uint64_t, uint64_t, __int128 *))(*(void *)v6 + 120LL))(v6, a2, &v14);
  while (1)
  {
    if (!(void)v14)
    {
      goto LABEL_7;
    }

    if ((void)v14)
    {
      uint64_t v7 = (*(uint64_t (**)(void))(*(void *)v14 + 24LL))();
      goto LABEL_8;
    }

void sub_1000642D8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  if (a9) {
    (*(void (**)(uint64_t))(*(void *)a9 + 8LL))(a9);
  }
  else {
    sub_100097C1C((uint64_t)&a9);
  }
  _Unwind_Resume(a1);
}

void sub_100064304(uint64_t *a1, uint64_t *a2, uint64_t a3, uint64_t a4, char a5)
{
LABEL_1:
  uint64_t v9 = a1;
LABEL_2:
  uint64_t v10 = 1 - a4;
  while (2)
  {
    a1 = v9;
    uint64_t v11 = v10;
    uint64_t v12 = (char *)a2 - (char *)v9;
    unint64_t v13 = ((char *)a2 - (char *)v9) >> 4;
    switch(v13)
    {
      case 0uLL:
      case 1uLL:
        return;
      case 2uLL:
        if (*((_DWORD *)a2 - 4) < *(_DWORD *)v9)
        {
          uint64_t v22 = *v9;
          int v23 = *((_DWORD *)v9 + 2);
          int v24 = *((_DWORD *)v9 + 3);
          *uint64_t v9 = *(a2 - 2);
          *((_DWORD *)v9 + 2) = *((_DWORD *)a2 - 2);
          *((_DWORD *)v9 + 3) = *((_DWORD *)a2 - 1);
          *(a2 - 2) = v22;
          *((_DWORD *)a2 - 2) = v23;
          *((_DWORD *)a2 - 1) = v24;
        }

        return;
      case 3uLL:
        sub_1000647AC(v9, (int *)v9 + 4, (int *)a2 - 4);
        return;
      case 4uLL:
        sub_100064C84((uint64_t)v9, v9 + 2, (int *)v9 + 8, a2 - 2);
        return;
      case 5uLL:
        sub_100064D7C((uint64_t)v9, (uint64_t)(v9 + 2), v9 + 4, v9 + 6, a2 - 2);
        return;
      default:
        if (v12 <= 383)
        {
          if ((a5 & 1) != 0) {
            sub_100064680((uint64_t)v9, a2);
          }
          else {
            sub_100064724(v9, a2);
          }
          return;
        }

        if (v11 != 1)
        {
          unint64_t v14 = v13 >> 1;
          __int128 v15 = (int *)&v9[2 * (v13 >> 1)];
          if ((unint64_t)v12 < 0x801)
          {
            sub_1000647AC(&v9[2 * (v13 >> 1)], (int *)v9, (int *)a2 - 4);
            if ((a5 & 1) != 0) {
              goto LABEL_11;
            }
          }

          else
          {
            sub_1000647AC(v9, (int *)&v9[2 * (v13 >> 1)], (int *)a2 - 4);
            sub_1000647AC(v9 + 2, v15 - 4, (int *)a2 - 8);
            sub_1000647AC(v9 + 4, (int *)&v9[2 * v14 + 2], (int *)a2 - 12);
            sub_1000647AC((uint64_t *)v15 - 2, v15, (int *)&v9[2 * v14 + 2]);
            uint64_t v16 = *v9;
            int v17 = *((_DWORD *)v9 + 2);
            int v18 = *((_DWORD *)v9 + 3);
            *uint64_t v9 = *(void *)v15;
            *((_DWORD *)v9 + 2) = v15[2];
            *((_DWORD *)v9 + 3) = v15[3];
            *(void *)__int128 v15 = v16;
            void v15[2] = v17;
            v15[3] = v18;
            if ((a5 & 1) != 0) {
              goto LABEL_11;
            }
          }

          if (*((_DWORD *)v9 - 4) >= *(_DWORD *)v9)
          {
            uint64_t v9 = (uint64_t *)sub_1000648E4(v9, (unint64_t)a2);
            goto LABEL_16;
          }

uint64_t sub_100064680(uint64_t result, void *a2)
{
  if ((void *)result != a2)
  {
    uint64_t v2 = (void *)(result + 16);
    if ((void *)(result + 16) != a2)
    {
      uint64_t v3 = 0LL;
      unint64_t v4 = (_DWORD *)result;
      do
      {
        unint64_t v5 = v2;
        if (v4[4] < *v4)
        {
          uint64_t v6 = *v2;
          int v7 = v4[6];
          uint64_t v8 = v3;
          int v9 = v4[7];
          while (1)
          {
            uint64_t v10 = result + v8;
            *(void *)(v10 + 16) = *(void *)(result + v8);
            *(_DWORD *)(v10 + ++*(void *)(result + 24) = *(_DWORD *)(result + v8 + 8);
            *(_DWORD *)(v10 + 2std::istream::~istream(v2, v3 + 8) = *(_DWORD *)(result + v8 + 12);
            if (!v8) {
              break;
            }
            v8 -= 16LL;
            if (*(_DWORD *)(v10 - 16) <= (int)v6)
            {
              uint64_t v11 = result + v8 + 16;
              goto LABEL_10;
            }
          }

          uint64_t v11 = result;
LABEL_10:
          *(void *)uint64_t v11 = v6;
          *(_DWORD *)(v11 + std::istream::~istream(v2, v3 + 8) = v7;
          *(_DWORD *)(v11 + 12) = v9;
        }

        uint64_t v2 = v5 + 2;
        v3 += 16LL;
        unint64_t v4 = v5;
      }

      while (v5 + 2 != a2);
    }
  }

  return result;
}

_DWORD *sub_100064724(_DWORD *result, _DWORD *a2)
{
  if (result != a2)
  {
    uint64_t v2 = result + 4;
    if (result + 4 != a2)
    {
      uint64_t v3 = result + 7;
      do
      {
        unint64_t v4 = v2;
        if (result[4] < *result)
        {
          uint64_t v5 = *v2;
          int v6 = result[6];
          int v7 = v3;
          int v8 = result[7];
          do
          {
            int v9 = v7;
            *(void *)(v7 - 3) = *(void *)(v7 - 7);
            *(v7 - 1) = *(v7 - 5);
            int v10 = *(v7 - 4);
            v7 -= 4;
            *int v9 = v10;
          }

          while (*(v9 - 11) > (int)v5);
          *(void *)(v7 - 3) = v5;
          *(v7 - 1) = v6;
          *int v7 = v8;
        }

        uint64_t v2 = v4 + 2;
        v3 += 4;
        uint64_t result = v4;
      }

      while (v4 + 2 != (void *)a2);
    }
  }

  return result;
}

uint64_t sub_1000647AC(uint64_t *a1, int *a2, int *a3)
{
  int v3 = *a2;
  int v4 = *a3;
  if (*a2 < *(_DWORD *)a1)
  {
    uint64_t v5 = *a1;
    int v6 = *((_DWORD *)a1 + 2);
    int v7 = *((_DWORD *)a1 + 3);
    if (v4 < v3)
    {
      *a1 = *(void *)a3;
      *((_DWORD *)a1 + 2) = a3[2];
      *((_DWORD *)a1 + 3) = a3[3];
      *(void *)a3 = v5;
      a3[2] = v6;
      a3[3] = v7;
      return 1LL;
    }

    *a1 = *(void *)a2;
    *((_DWORD *)a1 + 2) = a2[2];
    *((_DWORD *)a1 + 3) = a2[3];
    *(void *)a2 = v5;
    a2[2] = v6;
    a2[3] = v7;
    *(void *)a2 = *(void *)a3;
    a2[2] = a3[2];
    a2[3] = a3[3];
    *(void *)a3 = v5;
    a3[2] = v6;
    a3[3] = v7;
    return 2LL;
  }

  if (v4 < v3)
  {
    uint64_t v8 = *(void *)a2;
    int v9 = a2[2];
    int v10 = a2[3];
    *(void *)a2 = *(void *)a3;
    a2[2] = a3[2];
    a2[3] = a3[3];
    *(void *)a3 = v8;
    a3[2] = v9;
    a3[3] = v10;
    if (*a2 >= *(_DWORD *)a1) {
      return 1LL;
    }
    uint64_t v11 = *a1;
    int v12 = *((_DWORD *)a1 + 2);
    int v13 = *((_DWORD *)a1 + 3);
    *a1 = *(void *)a2;
    *((_DWORD *)a1 + 2) = a2[2];
    *((_DWORD *)a1 + 3) = a2[3];
    *(void *)a2 = v11;
    a2[2] = v12;
    a2[3] = v13;
    return 2LL;
  }

  return 0LL;
}

_DWORD *sub_1000648E4(_DWORD *a1, unint64_t a2)
{
  uint64_t v2 = *(void *)a1;
  if (*(_DWORD *)(a2 - 16) <= (int)*(void *)a1)
  {
    uint64_t v5 = a1 + 4;
    do
    {
      int v3 = v5;
      v5 += 4;
    }

    while (*v3 <= (int)v2);
  }

  else
  {
    int v3 = a1;
    do
    {
      int v4 = v3[4];
      v3 += 4;
    }

    while (v4 <= (int)v2);
  }

  if ((unint64_t)v3 < a2)
  {
    do
    {
      int v6 = *(_DWORD *)(a2 - 16);
      a2 -= 16LL;
    }

    while (v6 > (int)v2);
  }

  int v7 = a1[2];
  int v8 = a1[3];
  while ((unint64_t)v3 < a2)
  {
    uint64_t v9 = *(void *)v3;
    int v10 = v3[2];
    int v11 = v3[3];
    *(void *)int v3 = *(void *)a2;
    _OWORD v3[2] = *(_DWORD *)(a2 + 8);
    v3[3] = *(_DWORD *)(a2 + 12);
    *(void *)a2 = v9;
    *(_DWORD *)(a2 + std::istream::~istream(v2, v3 + 8) = v10;
    *(_DWORD *)(a2 + 12) = v11;
    do
    {
      int v12 = v3[4];
      v3 += 4;
    }

    while (v12 <= (int)v2);
    do
    {
      int v13 = *(_DWORD *)(a2 - 16);
      a2 -= 16LL;
    }

    while (v13 > (int)v2);
  }

  if (v3 - 4 != a1)
  {
    *(void *)a1 = *((void *)v3 - 2);
    a1[2] = *(v3 - 2);
    a1[3] = *(v3 - 1);
  }

  *((void *)v3 - 2) = v2;
  *(v3 - 2) = v7;
  *(v3 - 1) = v8;
  return v3;
}

uint64_t *sub_1000649D0(uint64_t *a1, unint64_t a2)
{
  uint64_t v2 = 0LL;
  uint64_t v3 = *a1;
  int v4 = *((_DWORD *)a1 + 2);
  int v5 = *((_DWORD *)a1 + 3);
  do
  {
    int v6 = a1[v2 + 2];
    v2 += 2LL;
  }

  while (v6 < (int)v3);
  unint64_t v7 = (unint64_t)&a1[v2];
  if (v2 == 2)
  {
    do
    {
      if (v7 >= a2) {
        break;
      }
      int v9 = *(_DWORD *)(a2 - 16);
      a2 -= 16LL;
    }

    while (v9 >= (int)v3);
  }

  else
  {
    do
    {
      int v8 = *(_DWORD *)(a2 - 16);
      a2 -= 16LL;
    }

    while (v8 >= (int)v3);
  }

  int v10 = &a1[v2];
  if (v7 < a2)
  {
    unint64_t v11 = a2;
    do
    {
      uint64_t v12 = *v10;
      int v13 = *((_DWORD *)v10 + 2);
      int v14 = *((_DWORD *)v10 + 3);
      *int v10 = *(void *)v11;
      *((_DWORD *)v10 + 2) = *(_DWORD *)(v11 + 8);
      *((_DWORD *)v10 + 3) = *(_DWORD *)(v11 + 12);
      *(void *)unint64_t v11 = v12;
      *(_DWORD *)(v11 + std::istream::~istream(v2, v3 + 8) = v13;
      *(_DWORD *)(v11 + 12) = v14;
      do
      {
        int v15 = *((_DWORD *)v10 + 4);
        v10 += 2;
      }

      while (v15 < (int)v3);
      do
      {
        int v16 = *(_DWORD *)(v11 - 16);
        v11 -= 16LL;
      }

      while (v16 >= (int)v3);
    }

    while ((unint64_t)v10 < v11);
  }

  if (v10 - 2 != a1)
  {
    *a1 = *(v10 - 2);
    *((_DWORD *)a1 + 2) = *((_DWORD *)v10 - 2);
    *((_DWORD *)a1 + 3) = *((_DWORD *)v10 - 1);
  }

  *(v10 - 2) = v3;
  *((_DWORD *)v10 - 2) = v4;
  *((_DWORD *)v10 - 1) = v5;
  return v10 - 2;
}

BOOL sub_100064AC4(uint64_t a1, _DWORD *a2)
{
  uint64_t v4 = ((uint64_t)a2 - a1) >> 4;
  BOOL result = 1LL;
  switch(v4)
  {
    case 0LL:
    case 1LL:
      return result;
    case 2LL:
      if (*(a2 - 4) < *(_DWORD *)a1)
      {
        uint64_t v6 = *(void *)a1;
        int v7 = *(_DWORD *)(a1 + 8);
        int v8 = *(_DWORD *)(a1 + 12);
        *(void *)a1 = *((void *)a2 - 2);
        *(_DWORD *)(a1 + std::istream::~istream(v2, v3 + 8) = *(a2 - 2);
        *(_DWORD *)(a1 + 12) = *(a2 - 1);
        *((void *)a2 - 2) = v6;
        *(a2 - 2) = v7;
        *(a2 - 1) = v8;
      }

      return result;
    case 3LL:
      sub_1000647AC((uint64_t *)a1, (int *)(a1 + 16), a2 - 4);
      return 1LL;
    case 4LL:
      sub_100064C84(a1, (uint64_t *)(a1 + 16), (int *)(a1 + 32), (uint64_t *)a2 - 2);
      return 1LL;
    case 5LL:
      sub_100064D7C(a1, a1 + 16, (uint64_t *)(a1 + 32), (uint64_t *)(a1 + 48), (uint64_t *)a2 - 2);
      return 1LL;
    default:
      int v9 = (_DWORD *)(a1 + 32);
      sub_1000647AC((uint64_t *)a1, (int *)(a1 + 16), (int *)(a1 + 32));
      int v10 = (_DWORD *)(a1 + 48);
      if ((_DWORD *)(a1 + 48) == a2) {
        return 1LL;
      }
      uint64_t v11 = 0LL;
      int v12 = 0;
      break;
  }

  while (1)
  {
    if (*v10 < *v9)
    {
      uint64_t v13 = *(void *)v10;
      int v14 = v10[2];
      uint64_t v15 = v11;
      int v16 = v10[3];
      while (1)
      {
        uint64_t v17 = a1 + v15;
        *(void *)(v17 + 4std::istream::~istream(v2, v3 + 8) = *(void *)(a1 + v15 + 32);
        *(_DWORD *)(v17 + ++*(void *)(result + 56) = *(_DWORD *)(a1 + v15 + 40);
        *(_DWORD *)(v17 + 6RDString::RDString((RDString *)&v66, theString, 0) = *(_DWORD *)(a1 + v15 + 44);
        if (v15 == -32) {
          break;
        }
        v15 -= 16LL;
        if (*(_DWORD *)(v17 + 16) <= (int)v13)
        {
          uint64_t v18 = a1 + v15 + 48;
          goto LABEL_12;
        }
      }

      uint64_t v18 = a1;
LABEL_12:
      *(void *)uint64_t v18 = v13;
      *(_DWORD *)(v18 + std::istream::~istream(v2, v3 + 8) = v14;
      *(_DWORD *)(v18 + 12) = v16;
      if (++v12 == 8) {
        return v10 + 4 == a2;
      }
    }

    int v9 = v10;
    v11 += 16LL;
    v10 += 4;
    if (v10 == a2) {
      return 1LL;
    }
  }

float sub_100064C84(uint64_t a1, uint64_t *a2, int *a3, uint64_t *a4)
{
  if (*(_DWORD *)a4 < *a3)
  {
    uint64_t v9 = *(void *)a3;
    float result = *((float *)a3 + 2);
    int v10 = a3[3];
    *(void *)a3 = *a4;
    a3[2] = *((_DWORD *)a4 + 2);
    a3[3] = *((_DWORD *)a4 + 3);
    *a4 = v9;
    *((float *)a4 + 2) = result;
    *((_DWORD *)a4 + 3) = v10;
    if (*a3 < *(_DWORD *)a2)
    {
      uint64_t v11 = *a2;
      float result = *((float *)a2 + 2);
      int v12 = *((_DWORD *)a2 + 3);
      *a2 = *(void *)a3;
      *((_DWORD *)a2 + 2) = a3[2];
      *((_DWORD *)a2 + 3) = a3[3];
      *(void *)a3 = v11;
      *((float *)a3 + 2) = result;
      a3[3] = v12;
      if (*(_DWORD *)a2 < *(_DWORD *)a1)
      {
        uint64_t v13 = *(void *)a1;
        float result = *(float *)(a1 + 8);
        int v14 = *(_DWORD *)(a1 + 12);
        *(void *)a1 = *a2;
        *(_DWORD *)(a1 + std::istream::~istream(v2, v3 + 8) = *((_DWORD *)a2 + 2);
        *(_DWORD *)(a1 + 12) = *((_DWORD *)a2 + 3);
        *a2 = v13;
        *((float *)a2 + 2) = result;
        *((_DWORD *)a2 + 3) = v14;
      }
    }
  }

  return result;
}

float sub_100064D7C(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t *a5)
{
  float result = sub_100064C84(a1, (uint64_t *)a2, (int *)a3, a4);
  if (*(_DWORD *)a5 < *(_DWORD *)a4)
  {
    uint64_t v11 = *a4;
    float result = *((float *)a4 + 2);
    int v12 = *((_DWORD *)a4 + 3);
    *a4 = *a5;
    *((_DWORD *)a4 + 2) = *((_DWORD *)a5 + 2);
    *((_DWORD *)a4 + 3) = *((_DWORD *)a5 + 3);
    *a5 = v11;
    *((float *)a5 + 2) = result;
    *((_DWORD *)a5 + 3) = v12;
    if (*(_DWORD *)a4 < *(_DWORD *)a3)
    {
      uint64_t v13 = *a3;
      float result = *((float *)a3 + 2);
      int v14 = *((_DWORD *)a3 + 3);
      *a3 = *a4;
      *((_DWORD *)a3 + 2) = *((_DWORD *)a4 + 2);
      *((_DWORD *)a3 + 3) = *((_DWORD *)a4 + 3);
      *a4 = v13;
      *((float *)a4 + 2) = result;
      *((_DWORD *)a4 + 3) = v14;
      if (*(_DWORD *)a3 < *(_DWORD *)a2)
      {
        uint64_t v15 = *(void *)a2;
        float result = *(float *)(a2 + 8);
        int v16 = *(_DWORD *)(a2 + 12);
        *(void *)a2 = *a3;
        *(_DWORD *)(a2 + std::istream::~istream(v2, v3 + 8) = *((_DWORD *)a3 + 2);
        *(_DWORD *)(a2 + 12) = *((_DWORD *)a3 + 3);
        *a3 = v15;
        *((float *)a3 + 2) = result;
        *((_DWORD *)a3 + 3) = v16;
        if (*(_DWORD *)a2 < *(_DWORD *)a1)
        {
          uint64_t v17 = *(void *)a1;
          float result = *(float *)(a1 + 8);
          int v18 = *(_DWORD *)(a1 + 12);
          *(void *)a1 = *(void *)a2;
          *(_DWORD *)(a1 + std::istream::~istream(v2, v3 + 8) = *(_DWORD *)(a2 + 8);
          *(_DWORD *)(a1 + 12) = *(_DWORD *)(a2 + 12);
          *(void *)a2 = v17;
          *(float *)(a2 + std::istream::~istream(v2, v3 + 8) = result;
          *(_DWORD *)(a2 + 12) = v18;
        }
      }
    }
  }

  return result;
}

int *sub_100064EC0(int *a1, int *a2, int *a3, uint64_t a4)
{
  if (a1 != a2)
  {
    uint64_t v8 = (char *)a2 - (char *)a1;
    uint64_t v9 = ((char *)a2 - (char *)a1) >> 4;
    if ((char *)a2 - (char *)a1 >= 17)
    {
      unint64_t v10 = (unint64_t)(v9 - 2) >> 1;
      unint64_t v11 = v10 + 1;
      int v12 = &a1[4 * v10];
      do
      {
        sub_100065060((uint64_t)a1, a4, v9, v12);
        v12 -= 4;
        --v11;
      }

      while (v11);
    }

    uint64_t v13 = a2;
    if (a2 != a3)
    {
      int v14 = a2;
      do
      {
        if (*v14 < *a1)
        {
          uint64_t v15 = *(void *)v14;
          int v16 = v14[2];
          int v17 = v14[3];
          *(void *)int v14 = *(void *)a1;
          v14[2] = a1[2];
          v14[3] = a1[3];
          *(void *)a1 = v15;
          a1[2] = v16;
          a1[3] = v17;
          sub_100065060((uint64_t)a1, a4, v9, a1);
        }

        v14 += 4;
      }

      while (v14 != a3);
      uint64_t v13 = a3;
    }

    if (v8 >= 17)
    {
      uint64_t v18 = (unint64_t)v8 >> 4;
      int v19 = a2 - 4;
      do
      {
        uint64_t v20 = *(void *)a1;
        int v21 = a1[2];
        int v22 = a1[3];
        int v23 = sub_100065150(a1, a4, v18);
        if (v19 == v23)
        {
          *(void *)int v23 = v20;
          v23[2] = v21;
          std::locale v23[3] = v22;
        }

        else
        {
          *(void *)int v23 = *(void *)v19;
          v23[2] = v19[2];
          std::locale v23[3] = v19[3];
          *(void *)int v19 = v20;
          v19[2] = v21;
          v19[3] = v22;
          sub_1000651CC((uint64_t)a1, (uint64_t)(v23 + 4), a4, ((char *)(v23 + 4) - (char *)a1) >> 4);
        }

        v19 -= 4;
      }

      while (v18-- > 2);
    }

    return v13;
  }

  return a3;
}

uint64_t sub_100065060(uint64_t result, uint64_t a2, uint64_t a3, int *a4)
{
  if (a3 >= 2)
  {
    uint64_t v4 = (uint64_t)a4 - result;
    int64_t v5 = (unint64_t)(a3 - 2) >> 1;
    if (v5 >= ((uint64_t)a4 - result) >> 4)
    {
      uint64_t v6 = v4 >> 3;
      uint64_t v7 = (v4 >> 3) + 1;
      uint64_t v8 = (int *)(result + 16 * v7);
      uint64_t v9 = v6 + 2;
      if (v6 + 2 >= a3)
      {
        int v10 = *v8;
      }

      else
      {
        int v10 = *v8;
        int v11 = v8[4];
        if (*v8 <= v11) {
          int v10 = v8[4];
        }
        if (*v8 < v11)
        {
          v8 += 4;
          uint64_t v7 = v9;
        }
      }

      if (v10 >= *a4)
      {
        uint64_t v12 = *(void *)a4;
        int v13 = a4[2];
        int v14 = a4[3];
        do
        {
          uint64_t v15 = a4;
          a4 = v8;
          *(void *)uint64_t v15 = *(void *)v8;
          void v15[2] = v8[2];
          v15[3] = v8[3];
          if (v5 < v7) {
            break;
          }
          uint64_t v16 = (2 * v7) | 1;
          uint64_t v8 = (int *)(result + 16 * v16);
          uint64_t v7 = 2 * v7 + 2;
          if (v7 >= a3)
          {
            int v17 = *v8;
            uint64_t v7 = v16;
          }

          else
          {
            int v17 = *v8;
            int v18 = v8[4];
            if (*v8 <= v18) {
              int v17 = v8[4];
            }
            if (*v8 >= v18) {
              uint64_t v7 = v16;
            }
            else {
              v8 += 4;
            }
          }
        }

        while (v17 >= (int)v12);
        *(void *)a4 = v12;
        a4[2] = v13;
        a4[3] = v14;
      }
    }
  }

  return result;
}

_DWORD *sub_100065150(_DWORD *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = 0LL;
  uint64_t v4 = a3 - 2;
  if (a3 < 2) {
    uint64_t v4 = a3 - 1;
  }
  uint64_t v5 = v4 >> 1;
  do
  {
    uint64_t v6 = &a1[4 * v3 + 4];
    uint64_t v7 = (2 * v3) | 1;
    uint64_t v8 = 2 * v3 + 2;
    if (v8 < a3)
    {
      int v9 = *v6;
      int v10 = v6[4];
      if (*v6 < v10) {
        v6 += 4;
      }
      if (v9 < v10) {
        uint64_t v7 = v8;
      }
    }

    *(void *)a1 = *(void *)v6;
    a1[2] = v6[2];
    a1[3] = v6[3];
    a1 = v6;
    uint64_t v3 = v7;
  }

  while (v7 <= v5);
  return v6;
}

uint64_t sub_1000651CC(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t v4 = a4 - 2;
  if (a4 >= 2)
  {
    unint64_t v5 = v4 >> 1;
    uint64_t v6 = result + 16 * (v4 >> 1);
    uint64_t v7 = a2 - 16;
    if (*(_DWORD *)v6 < *(_DWORD *)(a2 - 16))
    {
      uint64_t v8 = *(void *)(a2 - 16);
      int v9 = *(_DWORD *)(a2 - 8);
      int v10 = *(_DWORD *)(a2 - 4);
      do
      {
        uint64_t v11 = v7;
        uint64_t v7 = v6;
        *(void *)uint64_t v11 = *(void *)v6;
        *(_DWORD *)(v11 + std::istream::~istream(v2, v3 + 8) = *(_DWORD *)(v6 + 8);
        *(_DWORD *)(v11 + 12) = *(_DWORD *)(v6 + 12);
        if (!v5) {
          break;
        }
        unint64_t v5 = (v5 - 1) >> 1;
        uint64_t v6 = result + 16 * v5;
      }

      while (*(_DWORD *)v6 < (int)v8);
      *(void *)uint64_t v7 = v8;
      *(_DWORD *)(v7 + std::istream::~istream(v2, v3 + 8) = v9;
      *(_DWORD *)(v7 + 12) = v10;
    }
  }

  return result;
}

void *sub_100065248(void *a1, uint64_t a2, __int32 a3, int a4, int a5, int a6, int32x2_t *a7)
{
  int v14 = operator new(0x40uLL);
  uint64_t v15 = operator new(0x40uLL);
  sub_100065C4C((uint64_t)v15, a2, a3, a6, 0, 0, 0LL);
  sub_1000675DC((uint64_t)v14, a2, a3, a5, 0, v15);
  sub_100065398((uint64_t)a1, a2, a3, a4, 0, v14);
  *a1 = &off_1000D0D00;
  if (!a7)
  {
    a7 = (int32x2_t *)operator new(0x98uLL);
    sub_10006562C(a7, a2, a3, 1);
  }

  a1[8] = a7;
  return a1;
}

void sub_10006533C(_Unwind_Exception *a1)
{
  uint64_t v4 = v1[1];
  void *v1 = &off_1000D1048;
  v1[1] = 0LL;
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 8LL))(v4);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_100065398(uint64_t a1, uint64_t a2, __int32 a3, int a4, int a5, void *a6)
{
  uint64_t v6 = a6;
  *(void *)a1 = &off_1000D1048;
  if (!a6)
  {
    uint64_t v6 = operator new(0x40uLL);
    sub_1000675DC((uint64_t)v6, a2, a3, -1, 0, 0LL);
  }

  *(void *)(a1 + std::istream::~istream(v2, v3 + 8) = v6;
  *(_DWORD *)(a1 + 16) = a3;
  *(_DWORD *)(a1 + 2RDString::RDString((RDString *)&v66, theString, 0) = a4;
  *(_BYTE *)(a1 + 4std::istream::~istream(v2, v3 + 8) = 0;
  *(_DWORD *)(a1 + 52) = -1;
  *(_BYTE *)(a1 + ++*(void *)(result + 56) = 0;
  if (a3 == 3)
  {
    if (byte_1000DDAF8) {
      sub_10000A2DC(__p, "FATAL");
    }
    else {
      sub_10000A2DC(__p, "ERROR");
    }
    sub_10002A9EC(&v19, (uint64_t)__p);
    sub_10002A6A4(&std::cerr, (uint64_t)"RhoMatcher: Bad match type", 26LL);
    sub_10002AA94(&v19);
    if (v18 < 0) {
      operator delete(__p[0]);
    }
    *(_DWORD *)(a1 + 16) = 4;
    *(_BYTE *)(a1 + 4std::istream::~istream(v2, v3 + 8) = 1;
  }

  if (!a4)
  {
    if (byte_1000DDAF8) {
      sub_10000A2DC(v14, "FATAL");
    }
    else {
      sub_10000A2DC(v14, "ERROR");
    }
    sub_10002A9EC(&v16, (uint64_t)v14);
    sub_10002A6A4(&std::cerr, (uint64_t)"RhoMatcher: 0 cannot be used as rho_label", 41LL);
    sub_10002AA94(&v16);
    if (v15 < 0) {
      operator delete(v14[0]);
    }
    *(_DWORD *)(a1 + 2RDString::RDString((RDString *)&v66, theString, 0) = -1;
    *(_BYTE *)(a1 + 4std::istream::~istream(v2, v3 + 8) = 1;
  }

  if (a5 == 1)
  {
    BOOL v12 = 1;
  }

  else
  {
    if (a5)
    {
      *(_BYTE *)(a1 + ++*(void *)(result + 24) = 0;
      return a1;
    }

    BOOL v12 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)a2 + 56LL))(a2, 0x10000LL, 1LL) != 0;
  }

  *(_BYTE *)(a1 + ++*(void *)(result + 24) = v12;
  return a1;
}

void sub_100065594( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20, int a21, __int16 a22, char a23, char a24)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  uint64_t v26 = *(void *)(v24 + 8);
  *(void *)(v24 + std::istream::~istream(v2, v3 + 8) = 0LL;
  if (v26) {
    (*(void (**)(uint64_t))(*(void *)v26 + 8LL))(v26);
  }
  _Unwind_Resume(exception_object);
}

int32x2_t *sub_10006562C(int32x2_t *a1, uint64_t a2, __int32 a3, __int32 a4)
{
  uint64_t v7 = (*(uint64_t (**)(uint64_t, void))(*(void *)a2 + 72LL))(a2, 0LL);
  sub_100068074(a1, v7, a3, a4);
  int32x2_t v8 = a1[1];
  a1[1] = a1[2];
  if (v8) {
    (*(void (**)(int32x2_t))(**(void **)&v8 + 8LL))(v8);
  }
  return a1;
}

void *sub_10006569C(void *a1)
{
  *a1 = &off_1000D0D00;
  uint64_t v2 = a1[8];
  a1[8] = 0LL;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8LL))(v2);
  }
  uint64_t v3 = a1[1];
  *a1 = &off_1000D1048;
  a1[1] = 0LL;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8LL))(v3);
  }
  return a1;
}

void sub_100065700(void *__p)
{
  *std::string __p = &off_1000D0D00;
  uint64_t v2 = __p[8];
  __p[8] = 0LL;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8LL))(v2);
  }
  uint64_t v3 = __p[1];
  *std::string __p = &off_1000D1048;
  __p[1] = 0LL;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8LL))(v3);
  }
  operator delete(__p);
}

void *sub_100065764(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = operator new(0x48uLL);
  sub_100067FE4((uint64_t)v4, a1, a2);
  *uint64_t v4 = &off_1000D0D00;
  v4[8] = 0LL;
  return v4;
}

void sub_1000657B8(_Unwind_Exception *a1)
{
}

uint64_t sub_1000657CC(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 8) + 24LL))(*(void *)(a1 + 8));
}

uint64_t sub_1000657DC(uint64_t result, uint64_t a2)
{
  if (*(_DWORD *)(result + 52) != (_DWORD)a2)
  {
    uint64_t v2 = result;
    *(_DWORD *)(result + 52) = a2;
    float result = sub_100067958(*(void *)(result + 8), a2);
    *(_BYTE *)(v2 + ++*(void *)(result + 56) = *(_DWORD *)(v2 + 20) != -1;
  }

  return result;
}

BOOL sub_100065820(uint64_t a1, int a2)
{
  int v3 = *(_DWORD *)(a1 + 20);
  if (v3 != a2 || v3 == -1)
  {
    BOOL result = sub_1000679E0(*(void *)(a1 + 8), a2);
    if (result)
    {
      *(_DWORD *)(a1 + 2std::istream::~istream(v2, v3 + 8) = -1;
    }

    else
    {
      if (!*(_BYTE *)(a1 + 56)) {
        return result;
      }
      BOOL result = sub_1000679E0(*(void *)(a1 + 8), *(_DWORD *)(a1 + 20));
      *(_BYTE *)(a1 + ++*(void *)(result + 56) = result;
      if (!result) {
        return result;
      }
      *(_DWORD *)(a1 + 2std::istream::~istream(v2, v3 + 8) = a2;
    }

    return 1LL;
  }

  if (byte_1000DDAF8) {
    sub_10000A2DC(__p, "FATAL");
  }
  else {
    sub_10000A2DC(__p, "ERROR");
  }
  sub_10002A9EC(&v9, (uint64_t)__p);
  sub_10002A6A4(&std::cerr, (uint64_t)"RhoMatcher::Find: bad label (rho)", 33LL);
  sub_10002AA94(&v9);
  if (v8 < 0) {
    operator delete(__p[0]);
  }
  BOOL result = 0LL;
  *(_BYTE *)(a1 + 4std::istream::~istream(v2, v3 + 8) = 1;
  return result;
}

void sub_10006592C( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_100065964(uint64_t a1)
{
  return sub_100066E0C(*(void *)(*(void *)(*(void *)(a1 + 8) + 8LL) + 8LL));
}

void *sub_100065974(uint64_t a1)
{
  int v2 = *(_DWORD *)(a1 + 28);
  BOOL result = sub_100067B30(*(void *)(a1 + 8));
  uint64_t v4 = result;
  if (v2 != -1)
  {
    uint64_t v5 = *result;
    *(void *)(a1 + 32) = *result;
    BOOL result = (void *)(a1 + 32);
    *(_DWORD *)(a1 + 4RDString::RDString((RDString *)&v66, theString, 0) = *((_DWORD *)v4 + 2);
    *(_DWORD *)(a1 + 44) = *((_DWORD *)v4 + 3);
    if (!*(_BYTE *)(a1 + 24))
    {
      int v7 = *(_DWORD *)(a1 + 28);
      if (*(_DWORD *)(a1 + 16) == 1)
      {
        *(_DWORD *)BOOL result = v7;
        return result;
      }

      goto LABEL_10;
    }

    int v6 = *(_DWORD *)(a1 + 20);
    if (v6 == (_DWORD)v5) {
      *(_DWORD *)(a1 + 32) = *(_DWORD *)(a1 + 28);
    }
    if (v6 == HIDWORD(v5))
    {
      int v7 = *(_DWORD *)(a1 + 28);
LABEL_10:
      *(_DWORD *)(a1 + 36) = v7;
    }
  }

  return result;
}

BOOL sub_100065A18(uint64_t a1)
{
  return sub_100067BD4(*(void *)(a1 + 8));
}

uint64_t sub_100065A20(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 8) + 72LL))(*(void *)(a1 + 8));
}

uint64_t sub_100065A30(uint64_t a1)
{
  uint64_t result = (*(uint64_t (**)(void))(**(void **)(a1 + 8) + 80LL))(*(void *)(a1 + 8));
  if (*(_BYTE *)(a1 + 48)) {
    result |= 4uLL;
  }
  int v3 = *(_DWORD *)(a1 + 16);
  if (v3 != 4)
  {
    if (v3 == 2)
    {
      int v4 = *(unsigned __int8 *)(a1 + 24);
      unint64_t v5 = result & 0xFFFFEFFF3FFAFFFFLL;
      unint64_t v6 = 0xFFFFEFFF0FF3FFFFLL;
LABEL_8:
      unint64_t v7 = result & v6;
      if (v4) {
        return v7;
      }
      else {
        return v5;
      }
    }

    if (v3 == 1)
    {
      int v4 = *(unsigned __int8 *)(a1 + 24);
      unint64_t v5 = result & 0xFFFFEFFFCFEEFFFFLL;
      unint64_t v6 = 0xFFFFEFFF0FCFFFFFLL;
      goto LABEL_8;
    }

    if (byte_1000DDAF8) {
      sub_10000A2DC(__p, "FATAL");
    }
    else {
      sub_10000A2DC(__p, "ERROR");
    }
    sub_10002A9EC(&v11, (uint64_t)__p);
    char v8 = sub_10002A6A4(&std::cerr, (uint64_t)"RhoMatcher: Bad match type: ", 28LL);
    std::ostream::operator<<(v8, *(unsigned int *)(a1 + 16));
    sub_10002AA94(&v11);
    if (v10 < 0) {
      operator delete(__p[0]);
    }
    return 0LL;
  }

  return result;
}

void sub_100065B60( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100065B98(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 20) == -1 || *(_DWORD *)(a1 + 16) == 4) {
    return (*(uint64_t (**)(void))(**(void **)(a1 + 8) + 88LL))(*(void *)(a1 + 8));
  }
  else {
    return (*(unsigned int (**)(void))(**(void **)(a1 + 8) + 88LL))(*(void *)(a1 + 8)) | 1;
  }
}

int *sub_100065BE8@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, float *a3@<X8>)
{
  return sub_1000666C8(*(void *)(*(void *)(a1 + 8) + 8LL), a2, a3);
}

uint64_t sub_100065BF4(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(a1 + 52) = a2;
  sub_100067958(*(void *)(a1 + 8), a2);
  BOOL v4 = sub_1000679E0(*(void *)(a1 + 8), *(_DWORD *)(a1 + 20));
  *(_BYTE *)(a1 + ++*(void *)(result + 56) = v4;
  if (v4) {
    return -1LL;
  }
  else {
    return sub_100067E28(*(void *)(a1 + 8), a2);
  }
}

uint64_t sub_100065C4C(uint64_t a1, uint64_t a2, __int32 a3, int a4, char a5, int a6, int32x2_t *a7)
{
  unint64_t v7 = a7;
  *(void *)a1 = &off_1000D0DC0;
  if (!a7)
  {
    unint64_t v7 = (int32x2_t *)operator new(0x98uLL);
    sub_10006562C(v7, a2, a3, 1);
  }

  *(void *)(a1 + std::istream::~istream(v2, v3 + 8) = v7;
  *(_DWORD *)(a1 + 16) = a3;
  *(_DWORD *)(a1 + 2RDString::RDString((RDString *)&v66, theString, 0) = a4;
  *(_DWORD *)(a1 + 4std::istream::~istream(v2, v3 + 8) = -1;
  *(_BYTE *)(a1 + ++*(void *)(result + 56) = a5;
  *(_BYTE *)(a1 + 57) = 0;
  if (a3 == 3)
  {
    if (byte_1000DDAF8) {
      sub_10000A2DC(__p, "FATAL");
    }
    else {
      sub_10000A2DC(__p, "ERROR");
    }
    sub_10002A9EC(&v18, (uint64_t)__p);
    sub_10002A6A4(&std::cerr, (uint64_t)"PhiMatcher: Bad match type", 26LL);
    sub_10002AA94(&v18);
    if (v17 < 0) {
      operator delete(__p[0]);
    }
    *(_DWORD *)(a1 + 16) = 4;
    *(_BYTE *)(a1 + 57) = 1;
  }

  if (a6 == 1)
  {
    BOOL v14 = 1;
  }

  else
  {
    if (a6)
    {
      *(_BYTE *)(a1 + ++*(void *)(result + 24) = 0;
      return a1;
    }

    BOOL v14 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)a2 + 56LL))(a2, 0x10000LL, 1LL) != 0;
  }

  *(_BYTE *)(a1 + ++*(void *)(result + 24) = v14;
  return a1;
}

void sub_100065DBC( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, int a15, __int16 a16, char a17, char a18)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  uint64_t v20 = *(void *)(v18 + 8);
  *(void *)(v18 + std::istream::~istream(v2, v3 + 8) = 0LL;
  if (v20) {
    (*(void (**)(uint64_t))(*(void *)v20 + 8LL))(v20);
  }
  _Unwind_Resume(exception_object);
}

void *sub_100065E24(void *a1)
{
  uint64_t v2 = a1[1];
  *a1 = &off_1000D0DC0;
  a1[1] = 0LL;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8LL))(v2);
  }
  return a1;
}

void sub_100065E64(void *__p)
{
  uint64_t v2 = __p[1];
  *std::string __p = &off_1000D0DC0;
  __p[1] = 0LL;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8LL))(v2);
  }
  operator delete(__p);
}

void *sub_100065EA4(uint64_t a1, uint64_t a2)
{
  BOOL v4 = operator new(0x40uLL);
  sub_100066998((uint64_t)v4, a1, a2);
  return v4;
}

void sub_100065EE8(_Unwind_Exception *a1)
{
}

uint64_t sub_100065EFC(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 8) + 24LL))(*(void *)(a1 + 8));
}

uint64_t sub_100065F0C(uint64_t result, uint64_t a2)
{
  if (*(_DWORD *)(result + 48) != (_DWORD)a2)
  {
    int v2 = a2;
    uint64_t v3 = result;
    uint64_t result = sub_100066BF8(*(void *)(result + 8), a2);
    *(_DWORD *)(v3 + 4std::istream::~istream(v2, v3 + 8) = v2;
    *(_BYTE *)(v3 + 25) = *(_DWORD *)(v3 + 20) != -1;
  }

  return result;
}

BOOL sub_100065F54(uint64_t a1, int a2)
{
  if (*(_DWORD *)(a1 + 20) == a2 && (a2 + 1) >= 2)
  {
    if (byte_1000DDAF8) {
      sub_10000A2DC(v23, "FATAL");
    }
    else {
      sub_10000A2DC(v23, "ERROR");
    }
    sub_10002A9EC((BOOL *)__p, (uint64_t)v23);
    uint64_t v18 = sub_10002A6A4(&std::cerr, (uint64_t)"PhiMatcher::Find: bad label (phi): ", 35LL);
    std::ostream::operator<<(v18, *(unsigned int *)(a1 + 20));
    sub_10002AA94(__p);
    if (v24 < 0) {
      operator delete(v23[0]);
    }
    BOOL v6 = 0LL;
    *(_BYTE *)(a1 + 57) = 1;
  }

  else
  {
    sub_100066BF8(*(void *)(a1 + 8), *(unsigned int *)(a1 + 48));
    *(_DWORD *)(a1 + 2std::istream::~istream(v2, v3 + 8) = -1;
    *(_DWORD *)(a1 + 52) = *sub_10002AD60();
    if (*(_DWORD *)(a1 + 20)) {
      goto LABEL_6;
    }
    if (a2 == -1)
    {
      return 0LL;
    }

    else
    {
      if (a2)
      {
LABEL_6:
        LODWORD(v5) = *(_DWORD *)(a1 + 48);
        BOOL v6 = 1LL;
        if (!sub_100066D94(*(void *)(a1 + 8), a2))
        {
          while (1)
          {
            if (*(_DWORD *)(a1 + 20)) {
              int v7 = *(_DWORD *)(a1 + 20);
            }
            else {
              int v7 = -1;
            }
            BOOL v6 = sub_100066D94(*(void *)(a1 + 8), v7);
            if (!v6) {
              return v6;
            }
            if (*(_BYTE *)(a1 + 56) && *(_DWORD *)(sub_100066EE8(*(void *)(a1 + 8)) + 12) == (_DWORD)v5)
            {
              *(_DWORD *)(a1 + 2std::istream::~istream(v2, v3 + 8) = a2;
              return 1LL;
            }

            uint64_t v8 = sub_100066EE8(*(void *)(a1 + 8));
            float v9 = *(float *)(a1 + 52);
            if (v9 == -INFINITY || (float v10 = *(float *)(v8 + 8), v10 >= -INFINITY) && v10 <= -INFINITY)
            {
              float v11 = *(float *)sub_1000606CC();
            }

            else
            {
              BOOL v12 = v10 == INFINITY || v9 == INFINITY;
              float v11 = v9 + v10;
              if (v12) {
                float v11 = INFINITY;
              }
            }

            *(float *)(a1 + 52) = v11;
            uint64_t v5 = *(unsigned int *)(sub_100066EE8(*(void *)(a1 + 8)) + 12);
            uint64_t v13 = *(void *)(a1 + 8);
            if (*(_BYTE *)(v13 + 80))
            {
              *(_BYTE *)(v13 + 8RDString::RDString((RDString *)&v66, theString, 0) = 0;
            }

            else
            {
              BOOL v14 = *(void **)(v13 + 32);
              if (*v14)
              {
                (*(void (**)(void))(*(void *)*v14 + 32LL))(*v14);
                uint64_t v13 = *(void *)(a1 + 8);
              }

              else
              {
                ++v14[4];
              }
            }

            if (!sub_100066E0C(v13)) {
              break;
            }
LABEL_40:
            sub_100066BF8(*(void *)(a1 + 8), v5);
            if (sub_100066D94(*(void *)(a1 + 8), a2)) {
              return v6;
            }
          }

          int v15 = byte_1000DDAF8;
          if (byte_1000DDAF8)
          {
            sub_10000A2DC(v23, "FATAL");
            sub_10002A9EC(&v22, (uint64_t)v23);
          }

          else
          {
            sub_10000A2DC(__p, "ERROR");
            sub_10002A9EC(&v21, (uint64_t)__p);
          }

          sub_10002A6A4(&std::cerr, (uint64_t)"PhiMatcher: Phi non-determinism not supported", 45LL);
          if (v15)
          {
            sub_10002AA94(&v22);
            if (v24 < 0)
            {
              BOOL v16 = v23[0];
LABEL_38:
              operator delete(v16);
            }
          }

          else
          {
            sub_10002AA94(&v21);
            if (v20 < 0)
            {
              BOOL v16 = __p[0];
              goto LABEL_38;
            }
          }

          *(_BYTE *)(a1 + 57) = 1;
          goto LABEL_40;
        }

        return v6;
      }

      if (!sub_100066D94(*(void *)(a1 + 8), -1)) {
        return sub_100066D94(*(void *)(a1 + 8), 0);
      }
      *(_DWORD *)(a1 + 2std::istream::~istream(v2, v3 + 8) = 0;
      return 1LL;
    }
  }

  return v6;
}

void sub_1000662B8( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, int a16, __int16 a17, char a18, char a19, void *__p, uint64_t a21, int a22, __int16 a23, char a24, char a25)
{
  if (a25 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_100066328(uint64_t a1)
{
  return sub_100066E0C(*(void *)(a1 + 8));
}

uint64_t sub_100066330(uint64_t a1)
{
  int v2 = *(_DWORD *)(a1 + 28);
  if (v2 != -1)
  {
    if (v2) {
      goto LABEL_3;
    }
LABEL_21:
    int v12 = *sub_10002AD60();
    *(void *)(a1 + 32) = 0xFFFFFFFFLL;
    uint64_t v13 = (_DWORD *)(a1 + 32);
    int v14 = v13[4];
    BOOL v4 = v13;
    _DWORD v13[2] = v12;
    void v13[3] = v14;
    if (*(v13 - 4) == 2) {
      *(void *)uint64_t v13 = 0xFFFFFFFF00000000LL;
    }
    return (uint64_t)v4;
  }

  if (!*(_DWORD *)(a1 + 28)) {
    goto LABEL_21;
  }
LABEL_3:
  uint64_t v3 = sub_100066EE8(*(void *)(a1 + 8));
  *(void *)(a1 + 32) = *(void *)v3;
  BOOL v4 = (_DWORD *)(a1 + 32);
  float v5 = *(float *)(v3 + 8);
  *(float *)(a1 + 4RDString::RDString((RDString *)&v66, theString, 0) = v5;
  *(_DWORD *)(a1 + 44) = *(_DWORD *)(v3 + 12);
  float v6 = *(float *)(a1 + 52);
  if (v6 == -INFINITY || v5 >= -INFINITY && v5 <= -INFINITY)
  {
    float v7 = *(float *)sub_1000606CC();
  }

  else
  {
    BOOL v9 = v5 == INFINITY || v6 == INFINITY;
    float v7 = v6 + v5;
    if (v9) {
      float v7 = INFINITY;
    }
  }

  *(float *)(a1 + 4RDString::RDString((RDString *)&v66, theString, 0) = v7;
  int v10 = *(_DWORD *)(a1 + 28);
  if (v10 == -1) {
    return (uint64_t)v4;
  }
  if (*(_BYTE *)(a1 + 24))
  {
    int v11 = *(_DWORD *)(a1 + 20);
    if (*(_DWORD *)(a1 + 32) == v11) {
      *BOOL v4 = v10;
    }
    if (*(_DWORD *)(a1 + 36) != v11) {
      return (uint64_t)v4;
    }
    goto LABEL_25;
  }

  if (*(_DWORD *)(a1 + 16) != 1)
  {
LABEL_25:
    *(_DWORD *)(a1 + 36) = v10;
    return (uint64_t)v4;
  }

  *BOOL v4 = v10;
  return (uint64_t)v4;
}

void *sub_1000664A4(void *result)
{
  uint64_t v1 = result[1];
  if (*(_BYTE *)(v1 + 80))
  {
    *(_BYTE *)(v1 + 8RDString::RDString((RDString *)&v66, theString, 0) = 0;
  }

  else
  {
    uint64_t v2 = *(void *)(v1 + 32);
    uint64_t result = *(void **)v2;
    if (*(void *)v2) {
      return (void *)(*(uint64_t (**)(void *))(*result + 32LL))(result);
    }
    else {
      ++*(void *)(v2 + 32);
    }
  }

  return result;
}

uint64_t sub_1000664E0(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 8) + 72LL))(*(void *)(a1 + 8));
}

uint64_t sub_1000664F0(uint64_t a1)
{
  uint64_t result = (*(uint64_t (**)(void))(**(void **)(a1 + 8) + 80LL))(*(void *)(a1 + 8));
  if (*(_BYTE *)(a1 + 57)) {
    result |= 4uLL;
  }
  int v3 = *(_DWORD *)(a1 + 16);
  if (v3 != 4)
  {
    if (v3 == 2)
    {
      if (*(_DWORD *)(a1 + 20)) {
        uint64_t v5 = result;
      }
      else {
        uint64_t v5 = result | 0x8800000;
      }
      int v6 = *(unsigned __int8 *)(a1 + 24);
      unint64_t v7 = v5 & 0xFFFFEFFF0FFAFFFFLL;
      unint64_t v4 = 0xFFFFEFFF0FF3FFFFLL;
      goto LABEL_14;
    }

    if (v3 == 1)
    {
      unint64_t v4 = 0xFFFFEFFF0FCFFFFFLL;
      if (*(_DWORD *)(a1 + 20)) {
        uint64_t v5 = result;
      }
      else {
        uint64_t v5 = result | 0x2800000;
      }
      int v6 = *(unsigned __int8 *)(a1 + 24);
      unint64_t v7 = v5 & 0xFFFFEFFF0FEEFFFFLL;
LABEL_14:
      unint64_t v8 = v5 & v4;
      if (v6) {
        return v8;
      }
      else {
        return v7;
      }
    }

    if (byte_1000DDAF8) {
      sub_10000A2DC(__p, "FATAL");
    }
    else {
      sub_10000A2DC(__p, "ERROR");
    }
    sub_10002A9EC(&v12, (uint64_t)__p);
    BOOL v9 = sub_10002A6A4(&std::cerr, (uint64_t)"PhiMatcher: Bad match type: ", 28LL);
    std::ostream::operator<<(v9, *(unsigned int *)(a1 + 16));
    sub_10002AA94(&v12);
    if (v11 < 0) {
      operator delete(__p[0]);
    }
    return 0LL;
  }

  return result;
}

void sub_100066640( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100066678(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 20) == -1 || *(_DWORD *)(a1 + 16) == 4) {
    return (*(uint64_t (**)(void))(**(void **)(a1 + 8) + 88LL))(*(void *)(a1 + 8));
  }
  else {
    return (*(unsigned int (**)(void))(**(void **)(a1 + 8) + 88LL))(*(void *)(a1 + 8)) | 1;
  }
}

int *sub_1000666C8@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, float *a3@<X8>)
{
  uint64_t v6 = (*(uint64_t (**)(void))(**(void **)(a1 + 8) + 72LL))(*(void *)(a1 + 8));
  uint64_t result = (int *)(*(void *(**)(char *__return_ptr, uint64_t, uint64_t))(*(void *)v6 + 24LL))( (char *)&v19 + 4,  v6,  a2);
  if (*(_DWORD *)(a1 + 20) == -1)
  {
    float v8 = *((float *)&v19 + 1);
  }

  else
  {
    uint64_t result = sub_10002ADB0();
    float v8 = *((float *)&v19 + 1);
    LODWORD(v21) = HIDWORD(v19);
    float v20 = *(float *)result;
    if (*((float *)&v19 + 1) == v20)
    {
      HIDWORD(v19) = *sub_10002AD60();
      while (1)
      {
        sub_100066BF8(*(void *)(a1 + 8), a2);
        uint64_t v9 = (*(uint64_t (**)(void))(**(void **)(a1 + 8) + 72LL))(*(void *)(a1 + 8));
        (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(*(void *)v9 + 24LL))(&v19, v9, a2);
        int v10 = sub_10002ADB0();
        LODWORD(v21) = v19;
        float v20 = *(float *)v10;
        v11.n128_u32[0] = v19;
        int v12 = *(_DWORD *)(a1 + 20) ? *(_DWORD *)(a1 + 20) : -1;
        if (!sub_100066D94(*(void *)(a1 + 8), v12)) {
          break;
        }
        uint64_t v13 = sub_100066EE8(*(void *)(a1 + 8));
        if (*((float *)&v19 + 1) == -INFINITY || (float v14 = *(float *)(v13 + 8), v14 >= -INFINITY) && v14 <= -INFINITY)
        {
          float v15 = *(float *)sub_1000606CC();
        }

        else
        {
          BOOL v16 = v14 == INFINITY || *((float *)&v19 + 1) == INFINITY;
          float v15 = *((float *)&v19 + 1) + v14;
          if (v16) {
            float v15 = INFINITY;
          }
        }

        *((float *)&v19 + 1) = v15;
        if ((_DWORD)a2 == *(_DWORD *)(sub_100066EE8(*(void *)(a1 + 8)) + 12))
        {
          uint64_t result = sub_10002ADB0();
          goto LABEL_26;
        }

        a2 = *(unsigned int *)(sub_100066EE8(*(void *)(a1 + 8)) + 12);
      }

      uint64_t v17 = (*(uint64_t (**)(void, __n128))(**(void **)(a1 + 8) + 72LL))(*(void *)(a1 + 8), v11);
      uint64_t result = (int *)(*(void *(**)(uint64_t *__return_ptr, uint64_t, uint64_t))(*(void *)v17 + 24LL))( &v21,  v17,  a2);
      if (*((float *)&v19 + 1) == -INFINITY || *(float *)&v21 >= -INFINITY && *(float *)&v21 <= -INFINITY)
      {
        uint64_t result = sub_1000606CC();
LABEL_26:
        float v8 = *(float *)result;
        goto LABEL_32;
      }

      BOOL v18 = *(float *)&v21 == INFINITY || *((float *)&v19 + 1) == INFINITY;
      float v8 = *((float *)&v19 + 1) + *(float *)&v21;
      if (v18) {
        float v8 = INFINITY;
      }
    }
  }

uint64_t sub_1000668D8(uint64_t a1, uint64_t a2)
{
  int v4 = *(_DWORD *)(a1 + 20);
  uint64_t v5 = *(void *)(a1 + 8);
  if (v4 != -1)
  {
    sub_100066BF8(v5, a2);
    if (*(_DWORD *)(a1 + 20)) {
      int v6 = *(_DWORD *)(a1 + 20);
    }
    else {
      int v6 = -1;
    }
    if (sub_100066D94(*(void *)(a1 + 8), v6)) {
      return -1LL;
    }
    uint64_t v5 = *(void *)(a1 + 8);
  }

  uint64_t v8 = (*(uint64_t (**)(uint64_t))(*(void *)v5 + 72LL))(v5);
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v8 + 32LL))(v8, a2);
}

uint64_t sub_100066954()
{
  return 0LL;
}

uint64_t sub_10006695C(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 72LL))(a1);
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v3 + 24LL))(v3, a2);
}

uint64_t sub_100066998(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(void *)a1 = &off_1000D0DC0;
  int v6 = operator new(0x98uLL);
  sub_100066A24((uint64_t)v6, *(void *)(a2 + 8), a3);
  *(void *)(a1 + std::istream::~istream(v2, v3 + 8) = v6;
  *(void *)(a1 + 16) = *(void *)(a2 + 16);
  *(_BYTE *)(a1 + ++*(void *)(result + 24) = *(_BYTE *)(a2 + 24);
  *(_DWORD *)(a1 + 4std::istream::~istream(v2, v3 + 8) = -1;
  *(_WORD *)(a1 + ++*(void *)(result + 56) = *(_WORD *)(a2 + 56);
  return a1;
}

void sub_100066A10(_Unwind_Exception *a1)
{
}

uint64_t sub_100066A24(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(void *)a1 = off_1000D0E58;
  uint64_t v5 = (*(uint64_t (**)(void, uint64_t))(**(void **)(a2 + 16) + 72LL))(*(void *)(a2 + 16), a3);
  *(void *)(a1 + std::istream::~istream(v2, v3 + 8) = v5;
  *(void *)(a1 + 16) = v5;
  *(_DWORD *)(a1 + ++*(void *)(result + 24) = -1;
  *(void *)(a1 + 32) = 0LL;
  *(void *)(a1 + 4RDString::RDString((RDString *)&v66, theString, 0) = *(void *)(a2 + 40);
  *(_DWORD *)(a1 + 4std::istream::~istream(v2, v3 + 8) = -1;
  *(void *)(a1 + ++*(void *)(result + 56) = 0LL;
  *(void *)(a1 + 64) = *(void *)(a2 + 64);
  *(_DWORD *)(a1 + sub_10001A760(v25 - 72) = *(_DWORD *)(a2 + 72);
  *(_DWORD *)(a1 + 76) = *(_DWORD *)(a2 + 76);
  *(_BYTE *)(a1 + 82) = *(_BYTE *)(a2 + 82);
  *(void *)(a1 + 8std::istream::~istream(v2, v3 + 8) = off_1000D0F48;
  sub_100067104((void *)(a1 + 96), 1LL);
  *(void *)(a1 + 144) = 0LL;
  *(void *)(a1 + 8std::istream::~istream(v2, v3 + 8) = off_1000D0EF0;
  return a1;
}

void sub_100066AD0(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void *)(v1 + 8);
  *(void *)(v1 + std::istream::~istream(v2, v3 + 8) = 0LL;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8LL))(v3);
  }
  _Unwind_Resume(exception_object);
}

void sub_100066AF8(void *a1)
{
  uint64_t v1 = sub_1000671EC(a1);
  operator delete(v1);
}

void *sub_100066B0C(uint64_t a1, uint64_t a2)
{
  int v4 = operator new(0x98uLL);
  sub_100066A24((uint64_t)v4, a1, a2);
  return v4;
}

void sub_100066B50(_Unwind_Exception *a1)
{
}

uint64_t sub_100066B64(uint64_t a1, uint64_t a2)
{
  int v2 = *(_DWORD *)(a1 + 40);
  if (v2 == 4) {
    return 4LL;
  }
  if (v2 == 1) {
    uint64_t v6 = 0x10000000LL;
  }
  else {
    uint64_t v6 = 0x40000000LL;
  }
  uint64_t v7 = *(void *)(a1 + 16);
  if (v2 == 1) {
    uint64_t v8 = 805306368LL;
  }
  else {
    uint64_t v8 = 3221225472LL;
  }
  uint64_t v9 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v7 + 56LL))(v7, v8, a2);
  if ((v9 & v6) != 0) {
    return *(unsigned int *)(a1 + 40);
  }
  uint64_t v10 = 0x80000000LL;
  if (v2 == 1) {
    uint64_t v10 = 0x20000000LL;
  }
  if ((v9 & v10) != 0) {
    return 4LL;
  }
  else {
    return 5LL;
  }
}

uint64_t sub_100066BF8(uint64_t result, uint64_t a2)
{
  if (*(_DWORD *)(result + 24) != (_DWORD)a2)
  {
    uint64_t v3 = result;
    *(_DWORD *)(result + ++*(void *)(result + 24) = a2;
    if (*(_DWORD *)(result + 40) == 4)
    {
      if (byte_1000DDAF8) {
        sub_10000A2DC(__p, "FATAL");
      }
      else {
        sub_10000A2DC(__p, "ERROR");
      }
      sub_10002A9EC(&v8, (uint64_t)__p);
      sub_10002A6A4(&std::cerr, (uint64_t)"SortedMatcher: Bad match type", 29LL);
      sub_10002AA94(&v8);
      if (v7 < 0) {
        operator delete(__p[0]);
      }
      *(_BYTE *)(v3 + 82) = 1;
    }

    sub_10006725C(*(void *)(v3 + 32), v3 + 88);
    int v4 = *(char **)(v3 + 144);
    if (v4)
    {
      *(void *)(v3 + 144) = *((void *)v4 + 5);
    }

    else
    {
      int v4 = sub_1000672B8((void *)(v3 + 96), 1LL);
      *((void *)v4 + 5) = 0LL;
    }

    uint64_t v5 = *(void *)(v3 + 16);
    *((void *)v4 + 4) = 0LL;
    *(_OWORD *)int v4 = 0u;
    *((_OWORD *)v4 + 1) = 0u;
    (*(void (**)(uint64_t, uint64_t, char *))(*(void *)v5 + 120LL))(v5, a2, v4);
    *(void *)(v3 + 32) = v4;
    if (*(void *)v4) {
      (*(void (**)(void, uint64_t, uint64_t))(**(void **)v4 + 72LL))(*(void *)v4, 16LL, 16LL);
    }
    uint64_t result = (*(uint64_t (**)(void, uint64_t))(**(void **)(v3 + 16) + 32LL))(*(void *)(v3 + 16), a2);
    *(void *)(v3 + ++*(void *)(result + 56) = result;
    *(_DWORD *)(v3 + 76) = a2;
  }

  return result;
}

void sub_100066D5C( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, int a15, __int16 a16, char a17, char a18)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_100066D94(uint64_t a1, int a2)
{
  *(_BYTE *)(a1 + 81) = 1;
  if (*(_BYTE *)(a1 + 82))
  {
    BOOL result = 0LL;
    *(_BYTE *)(a1 + 8RDString::RDString((RDString *)&v66, theString, 0) = 0;
    *(_DWORD *)(a1 + 4std::istream::~istream(v2, v3 + 8) = -1;
  }

  else
  {
    *(_BYTE *)(a1 + 8RDString::RDString((RDString *)&v66, theString, 0) = a2 == 0;
    if (a2 == -1) {
      int v4 = 0;
    }
    else {
      int v4 = a2;
    }
    *(_DWORD *)(a1 + 4std::istream::~istream(v2, v3 + 8) = v4;
    return sub_100067388(a1) || *(_BYTE *)(a1 + 80) != 0;
  }

  return result;
}

BOOL sub_100066E0C(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 80)) {
    return 0LL;
  }
  uint64_t v3 = *(void **)(a1 + 32);
  if (*v3)
  {
  }

  else if (v3[4] >= v3[2])
  {
    return 1LL;
  }

  if (!*(_BYTE *)(a1 + 81)) {
    return 0LL;
  }
  int v4 = *(void **)(a1 + 32);
  if (*v4
    && (*(_DWORD *)(a1 + 40) == 1 ? (uint64_t v5 = 1LL) : (uint64_t v5 = 2LL),
        (*(void (**)(void, uint64_t, uint64_t))(*(void *)*v4 + 72LL))(*v4, v5, 15LL),
        int v4 = *(void **)(a1 + 32),
        *v4))
  {
    uint64_t v6 = (*(uint64_t (**)(void))(*(void *)*v4 + 24LL))(*v4);
  }

  else
  {
    uint64_t v6 = v4[1] + 16LL * v4[4];
  }

  if (*(_DWORD *)(a1 + 40) == 1) {
    char v7 = (_DWORD *)v6;
  }
  else {
    char v7 = (_DWORD *)(v6 + 4);
  }
  return *v7 != *(_DWORD *)(a1 + 48);
}

uint64_t sub_100066EE8(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 80)) {
    return a1 + 64;
  }
  uint64_t v3 = *(void **)(a1 + 32);
  if (*v3
    && ((*(void (**)(void, uint64_t, uint64_t))(*(void *)*v3 + 72LL))(*v3, 15LL, 15LL),
        uint64_t v3 = *(void **)(a1 + 32),
        *v3))
  {
    return (*(uint64_t (**)(void))(*(void *)*v3 + 24LL))(*v3);
  }

  else
  {
    return v3[1] + 16LL * v3[4];
  }

uint64_t sub_100066F60(uint64_t result)
{
  if (*(_BYTE *)(result + 80))
  {
    *(_BYTE *)(result + 8RDString::RDString((RDString *)&v66, theString, 0) = 0;
  }

  else
  {
    uint64_t v1 = *(uint64_t **)(result + 32);
    BOOL result = *v1;
    if (*v1) {
      return (*(uint64_t (**)(uint64_t))(*(void *)result + 32LL))(result);
    }
    else {
      ++v1[4];
    }
  }

  return result;
}

uint64_t sub_100066F98(uint64_t a1)
{
  return *(void *)(a1 + 16);
}

uint64_t sub_100066FA0(uint64_t a1, uint64_t a2)
{
  return a2 | (4LL * *(unsigned __int8 *)(a1 + 82));
}

uint64_t sub_100066FAC(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 72LL))(a1);
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v3 + 24LL))(v3, a2);
}

uint64_t sub_100066FE8(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 72LL))(a1);
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v3 + 32LL))(v3, a2);
}

void *sub_10006701C(void *a1)
{
  *a1 = off_1000D0F48;
  a1[1] = off_1000D0F70;
  sub_10002B998(a1 + 4);
  return a1;
}

void sub_100067054(uint64_t *a1)
{
  *a1 = (uint64_t)off_1000D0F48;
  a1[1] = (uint64_t)off_1000D0F70;
  sub_10002B998(a1 + 4);
  operator delete(a1);
}

uint64_t sub_10006708C()
{
  return 40LL;
}

void *sub_100067094(void *a1)
{
  *a1 = off_1000D0F48;
  a1[1] = off_1000D0F70;
  sub_10002B998(a1 + 4);
  return a1;
}

void sub_1000670CC(uint64_t *a1)
{
  *a1 = (uint64_t)off_1000D0F48;
  a1[1] = (uint64_t)off_1000D0F70;
  sub_10002B998(a1 + 4);
  operator delete(a1);
}

void *sub_100067104(void *a1, uint64_t a2)
{
  *a1 = off_1000D0F70;
  a1[1] = 48 * a2;
  uint64_t v3 = a1 + 3;
  a1[2] = 0LL;
  a1[3] = a1 + 3;
  a1[4] = a1 + 3;
  a1[5] = 0LL;
  int v4 = operator new[](48 * a2);
  uint64_t v5 = operator new(0x18uLL);
  v5[1] = v3;
  _OWORD v5[2] = v4;
  void *v5 = v3;
  a1[3] = v5;
  a1[4] = v5;
  a1[5] = 1LL;
  return a1;
}

void sub_100067170(_Unwind_Exception *a1)
{
}

void *sub_100067184(void *a1)
{
  *a1 = off_1000D0F70;
  sub_10002B998(a1 + 3);
  return a1;
}

void sub_1000671B4(uint64_t *a1)
{
  *a1 = (uint64_t)off_1000D0F70;
  sub_10002B998(a1 + 3);
  operator delete(a1);
}

uint64_t sub_1000671E4()
{
  return 48LL;
}

void *sub_1000671EC(void *a1)
{
  *a1 = off_1000D0E58;
  sub_10006725C(a1[4], (uint64_t)(a1 + 11));
  a1[11] = off_1000D0F48;
  a1[12] = off_1000D0F70;
  sub_10002B998(a1 + 15);
  uint64_t v2 = a1[1];
  a1[1] = 0LL;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8LL))(v2);
  }
  return a1;
}

uint64_t sub_10006725C(uint64_t result, uint64_t a2)
{
  if (result)
  {
    uint64_t v3 = result;
    BOOL result = *(void *)result;
    if (result)
    {
      BOOL result = (*(uint64_t (**)(uint64_t))(*(void *)result + 8LL))(result);
    }

    else
    {
      int v4 = *(_DWORD **)(v3 + 24);
      if (v4) {
        --*v4;
      }
    }

    *(void *)(v3 + 4RDString::RDString((RDString *)&v66, theString, 0) = *(void *)(a2 + 56);
    *(void *)(a2 + ++*(void *)(result + 56) = v3;
  }

  return result;
}

char *sub_1000672B8(void *a1, uint64_t a2)
{
  uint64_t v2 = a1;
  uint64_t v3 = 48 * a2;
  size_t v4 = a1[1];
  if (192 * a2 <= v4)
  {
    uint64_t v9 = v2[2];
    if (v9 + v3 <= v4)
    {
      uint64_t v10 = *(char **)(v2[4] + 16LL);
    }

    else
    {
      uint64_t v10 = (char *)operator new[](v4);
      v2[2] = 0LL;
      __n128 v11 = operator new(0x18uLL);
      uint64_t v9 = 0LL;
      int v12 = (void *)v2[4];
      uint64_t v13 = v2[5];
      *__n128 v11 = v2 + 3;
      v11[1] = v12;
      v11[2] = v10;
      *int v12 = v11;
      v2[4] = v11;
      void v2[5] = v13 + 1;
    }

    uint64_t v5 = &v10[v9];
    uint64_t v8 = v9 + v3;
  }

  else
  {
    uint64_t v5 = (char *)operator new[](48 * a2);
    uint64_t v6 = operator new(0x18uLL);
    uint64_t v7 = v2[3];
    v2 += 3;
    v6[1] = v2;
    _DWORD v6[2] = v5;
    void *v6 = v7;
    *(void *)(v7 + std::istream::~istream(v2, v3 + 8) = v6;
    void *v2 = v6;
    uint64_t v8 = v2[2] + 1LL;
  }

  v2[2] = v8;
  return v5;
}

BOOL sub_100067388(uint64_t a1)
{
  uint64_t v2 = **(void **)(a1 + 32);
  if (v2)
  {
    if (*(_DWORD *)(a1 + 40) == 1) {
      uint64_t v3 = 1LL;
    }
    else {
      uint64_t v3 = 2LL;
    }
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v2 + 72LL))(v2, v3, 15LL);
  }

  if (*(_DWORD *)(a1 + 48) < *(_DWORD *)(a1 + 44))
  {
    size_t v4 = *(void **)(a1 + 32);
    if (*v4) {
      (*(void (**)(void))(*(void *)*v4 + 48LL))(*v4);
    }
    else {
      v4[4] = 0LL;
    }
    while (1)
    {
      uint64_t v13 = *(void **)(a1 + 32);
      if (*v13)
      {
        uint64_t v13 = *(void **)(a1 + 32);
        if (*v13)
        {
          uint64_t v14 = (*(uint64_t (**)(void))(*(void *)*v13 + 24LL))(*v13);
          goto LABEL_37;
        }

        unint64_t v15 = v13[4];
      }

      else
      {
        unint64_t v15 = v13[4];
        if (v15 >= v13[2]) {
          return 0LL;
        }
      }

      uint64_t v14 = v13[1] + 16 * v15;
LABEL_37:
      if (*(_DWORD *)(a1 + 40) == 1) {
        BOOL v16 = (int *)v14;
      }
      else {
        BOOL v16 = (int *)(v14 + 4);
      }
      int v17 = *v16;
      int v18 = *(_DWORD *)(a1 + 48);
      BOOL v19 = v17 == v18;
      int v20 = 2 * (v17 > v18);
      if (v19) {
        int v20 = 1;
      }
      if (v20) {
        return v20 == 1;
      }
      int v12 = *(void **)(a1 + 32);
      if (*v12) {
        (*(void (**)(void))(*(void *)*v12 + 32LL))(*v12);
      }
      else {
        ++v12[4];
      }
    }
  }

  unint64_t v5 = *(void *)(a1 + 56);
  if (v5)
  {
    unint64_t v6 = 0LL;
    while (1)
    {
      unint64_t v7 = v6 + ((v5 - v6) >> 1);
      uint64_t v8 = *(void **)(a1 + 32);
      if (!*v8) {
        break;
      }
      (*(void (**)(void, unint64_t))(*(void *)*v8 + 56LL))(*v8, v6 + ((v5 - v6) >> 1));
      uint64_t v8 = *(void **)(a1 + 32);
      if (!*v8)
      {
        unint64_t v10 = v8[4];
        goto LABEL_16;
      }

      uint64_t v9 = (*(uint64_t (**)(void))(*(void *)*v8 + 24LL))(*v8);
LABEL_17:
      if (*(_DWORD *)(a1 + 40) == 1) {
        __n128 v11 = (_DWORD *)v9;
      }
      else {
        __n128 v11 = (_DWORD *)(v9 + 4);
      }
      if (*v11 < *(_DWORD *)(a1 + 48)) {
        unint64_t v6 = v7 + 1;
      }
      else {
        unint64_t v5 = v6 + ((v5 - v6) >> 1);
      }
      if (v6 >= v5) {
        goto LABEL_47;
      }
    }

    v8[4] = v7;
    unint64_t v10 = v6 + ((v5 - v6) >> 1);
LABEL_16:
    uint64_t v9 = v8[1] + 16 * v10;
    goto LABEL_17;
  }

  unint64_t v6 = 0LL;
LABEL_47:
  BOOL v22 = *(void **)(a1 + 32);
  if (*v22) {
    (*(void (**)(void, unint64_t))(*(void *)*v22 + 56LL))(*v22, v6);
  }
  else {
    v22[4] = v6;
  }
  if (v6 >= *(void *)(a1 + 56)) {
    return 0LL;
  }
  int v23 = *(void **)(a1 + 32);
  if (*v23) {
    uint64_t v24 = (*(uint64_t (**)(void))(*(void *)*v23 + 24LL))(*v23);
  }
  else {
    uint64_t v24 = v23[1] + 16LL * v23[4];
  }
  if (*(_DWORD *)(a1 + 40) == 1) {
    uint64_t v25 = (_DWORD *)v24;
  }
  else {
    uint64_t v25 = (_DWORD *)(v24 + 4);
  }
  return *v25 == *(_DWORD *)(a1 + 48);
}

uint64_t sub_1000675DC(uint64_t a1, uint64_t a2, __int32 a3, int a4, int a5, void *a6)
{
  unint64_t v6 = a6;
  *(void *)a1 = &off_1000D0FB0;
  if (!a6)
  {
    unint64_t v6 = operator new(0x40uLL);
    sub_100065C4C((uint64_t)v6, a2, a3, -1, 1, 0, 0LL);
  }

  *(void *)(a1 + std::istream::~istream(v2, v3 + 8) = v6;
  *(_DWORD *)(a1 + 16) = a3;
  *(_DWORD *)(a1 + 2RDString::RDString((RDString *)&v66, theString, 0) = a4;
  *(_BYTE *)(a1 + 52) = 0;
  *(_DWORD *)(a1 + ++*(void *)(result + 56) = -1;
  if (a3 == 3)
  {
    if (byte_1000DDAF8) {
      sub_10000A2DC(__p, "FATAL");
    }
    else {
      sub_10000A2DC(__p, "ERROR");
    }
    sub_10002A9EC(&v19, (uint64_t)__p);
    sub_10002A6A4(&std::cerr, (uint64_t)"SigmaMatcher: Bad match type", 28LL);
    sub_10002AA94(&v19);
    if (v18 < 0) {
      operator delete(__p[0]);
    }
    *(_DWORD *)(a1 + 16) = 4;
    *(_BYTE *)(a1 + 52) = 1;
  }

  if (!a4)
  {
    if (byte_1000DDAF8) {
      sub_10000A2DC(v14, "FATAL");
    }
    else {
      sub_10000A2DC(v14, "ERROR");
    }
    sub_10002A9EC(&v16, (uint64_t)v14);
    sub_10002A6A4(&std::cerr, (uint64_t)"SigmaMatcher: 0 cannot be used as sigma_label", 45LL);
    sub_10002AA94(&v16);
    if (v15 < 0) {
      operator delete(v14[0]);
    }
    *(_DWORD *)(a1 + 2RDString::RDString((RDString *)&v66, theString, 0) = -1;
    *(_BYTE *)(a1 + 52) = 1;
  }

  if (a5 == 1)
  {
    BOOL v12 = 1;
  }

  else
  {
    if (a5)
    {
      *(_BYTE *)(a1 + ++*(void *)(result + 24) = 0;
      return a1;
    }

    BOOL v12 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)a2 + 56LL))(a2, 0x10000LL, 1LL) != 0;
  }

  *(_BYTE *)(a1 + ++*(void *)(result + 24) = v12;
  return a1;
}

void sub_1000677D8( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20, int a21, __int16 a22, char a23, char a24)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  uint64_t v26 = *(void *)(v24 + 8);
  *(void *)(v24 + std::istream::~istream(v2, v3 + 8) = 0LL;
  if (v26) {
    (*(void (**)(uint64_t))(*(void *)v26 + 8LL))(v26);
  }
  _Unwind_Resume(exception_object);
}

void *sub_100067870(void *a1)
{
  uint64_t v2 = a1[1];
  *a1 = &off_1000D0FB0;
  a1[1] = 0LL;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8LL))(v2);
  }
  return a1;
}

void sub_1000678B0(void *__p)
{
  uint64_t v2 = __p[1];
  *std::string __p = &off_1000D0FB0;
  __p[1] = 0LL;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8LL))(v2);
  }
  operator delete(__p);
}

void *sub_1000678F0(uint64_t a1, uint64_t a2)
{
  size_t v4 = operator new(0x40uLL);
  sub_100067E80((uint64_t)v4, a1, a2);
  return v4;
}

void sub_100067934(_Unwind_Exception *a1)
{
}

uint64_t sub_100067948(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 8) + 24LL))(*(void *)(a1 + 8));
}

uint64_t sub_100067958(uint64_t result, uint64_t a2)
{
  if (*(_DWORD *)(result + 56) != (_DWORD)a2)
  {
    int v2 = a2;
    uint64_t v3 = result;
    *(_DWORD *)(result + ++*(void *)(result + 56) = a2;
    uint64_t v4 = *(void *)(result + 8);
    if (*(_DWORD *)(v4 + 48) != (_DWORD)a2)
    {
      sub_100066BF8(*(void *)(v4 + 8), a2);
      *(_DWORD *)(v4 + 4std::istream::~istream(v2, v3 + 8) = v2;
      *(_BYTE *)(v4 + 25) = *(_DWORD *)(v4 + 20) != -1;
    }

    int v5 = *(_DWORD *)(v3 + 20);
    BOOL result = v5 != -1 && sub_100065F54(*(void *)(v3 + 8), v5);
    *(_BYTE *)(v3 + 25) = result;
  }

  return result;
}

BOOL sub_1000679E0(uint64_t a1, int a2)
{
  *(_DWORD *)(a1 + 4std::istream::~istream(v2, v3 + 8) = a2;
  int v3 = *(_DWORD *)(a1 + 20);
  if (v3 != a2 || v3 == -1)
  {
    BOOL result = sub_100065F54(*(void *)(a1 + 8), a2);
    if (result)
    {
      *(_DWORD *)(a1 + 2std::istream::~istream(v2, v3 + 8) = -1;
    }

    else
    {
      if (!*(_BYTE *)(a1 + 25)) {
        return result;
      }
      BOOL result = sub_100065F54(*(void *)(a1 + 8), *(_DWORD *)(a1 + 20));
      if (!result) {
        return result;
      }
      *(_DWORD *)(a1 + 2std::istream::~istream(v2, v3 + 8) = a2;
    }

    return 1LL;
  }

  if (byte_1000DDAF8) {
    sub_10000A2DC(__p, "FATAL");
  }
  else {
    sub_10000A2DC(__p, "ERROR");
  }
  sub_10002A9EC(&v9, (uint64_t)__p);
  sub_10002A6A4(&std::cerr, (uint64_t)"SigmaMatcher::Find: bad label (sigma)", 37LL);
  sub_10002AA94(&v9);
  if (v8 < 0) {
    operator delete(__p[0]);
  }
  BOOL result = 0LL;
  *(_BYTE *)(a1 + 52) = 1;
  return result;
}

void sub_100067AEC( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_100067B24(uint64_t a1)
{
  return sub_100066E0C(*(void *)(*(void *)(a1 + 8) + 8LL));
}

void *sub_100067B30(uint64_t a1)
{
  int v2 = *(_DWORD *)(a1 + 28);
  BOOL result = (void *)sub_100066330(*(void *)(a1 + 8));
  uint64_t v4 = result;
  if (v2 != -1)
  {
    uint64_t v5 = *result;
    *(void *)(a1 + 32) = *result;
    BOOL result = (void *)(a1 + 32);
    *(_DWORD *)(a1 + 4RDString::RDString((RDString *)&v66, theString, 0) = *((_DWORD *)v4 + 2);
    *(_DWORD *)(a1 + 44) = *((_DWORD *)v4 + 3);
    if (!*(_BYTE *)(a1 + 24))
    {
      int v7 = *(_DWORD *)(a1 + 28);
      if (*(_DWORD *)(a1 + 16) == 1)
      {
        *(_DWORD *)BOOL result = v7;
        return result;
      }

      goto LABEL_10;
    }

    int v6 = *(_DWORD *)(a1 + 20);
    if (v6 == (_DWORD)v5) {
      *(_DWORD *)(a1 + 32) = *(_DWORD *)(a1 + 28);
    }
    if (v6 == HIDWORD(v5))
    {
      int v7 = *(_DWORD *)(a1 + 28);
LABEL_10:
      *(_DWORD *)(a1 + 36) = v7;
    }
  }

  return result;
}

BOOL sub_100067BD4(uint64_t a1)
{
  uint64_t v2 = *(void *)(*(void *)(a1 + 8) + 8LL);
  if (*(_BYTE *)(v2 + 80))
  {
    *(_BYTE *)(v2 + 8RDString::RDString((RDString *)&v66, theString, 0) = 0;
  }

  else
  {
    int v3 = *(void **)(v2 + 32);
    if (*v3)
    {
      (*(void (**)(void))(*(void *)*v3 + 32LL))(*v3);
      uint64_t v2 = *(void *)(*(void *)(a1 + 8) + 8LL);
    }

    else
    {
      ++v3[4];
    }
  }

  BOOL result = sub_100066E0C(v2);
  if (result && *(_BYTE *)(a1 + 25) && *(_DWORD *)(a1 + 28) == -1 && *(int *)(a1 + 48) >= 1)
  {
    BOOL result = sub_100065F54(*(void *)(a1 + 8), *(_DWORD *)(a1 + 20));
    *(_DWORD *)(a1 + 2std::istream::~istream(v2, v3 + 8) = *(_DWORD *)(a1 + 48);
  }

  return result;
}

uint64_t sub_100067C78(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 8) + 72LL))(*(void *)(a1 + 8));
}

uint64_t sub_100067C88(uint64_t a1)
{
  uint64_t result = (*(uint64_t (**)(void))(**(void **)(a1 + 8) + 80LL))(*(void *)(a1 + 8));
  if (*(_BYTE *)(a1 + 52)) {
    result |= 4uLL;
  }
  int v3 = *(_DWORD *)(a1 + 16);
  if (v3 != 4)
  {
    if (*(_BYTE *)(a1 + 24))
    {
      uint64_t v4 = -4030464001LL;
      return result & (v4 & 0xFFFF0000FFFFFFFFLL | 0xEFFF00000000LL);
    }

    if (v3 == 2)
    {
      uint64_t v4 = -3225223169LL;
      return result & (v4 & 0xFFFF0000FFFFFFFFLL | 0xEFFF00000000LL);
    }

    if (v3 == 1)
    {
      uint64_t v4 = -809304065LL;
      return result & (v4 & 0xFFFF0000FFFFFFFFLL | 0xEFFF00000000LL);
    }

    if (byte_1000DDAF8) {
      sub_10000A2DC(__p, "FATAL");
    }
    else {
      sub_10000A2DC(__p, "ERROR");
    }
    sub_10002A9EC(&v8, (uint64_t)__p);
    uint64_t v5 = sub_10002A6A4(&std::cerr, (uint64_t)"SigmaMatcher: Bad match type: ", 30LL);
    std::ostream::operator<<(v5, *(unsigned int *)(a1 + 16));
    sub_10002AA94(&v8);
    if (v7 < 0) {
      operator delete(__p[0]);
    }
    return 0LL;
  }

  return result;
}

void sub_100067D98( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100067DD0(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 20) == -1 || *(_DWORD *)(a1 + 16) == 4) {
    return (*(uint64_t (**)(void))(**(void **)(a1 + 8) + 88LL))(*(void *)(a1 + 8));
  }
  else {
    return (*(unsigned int (**)(void))(**(void **)(a1 + 8) + 88LL))(*(void *)(a1 + 8)) | 1;
  }
}

int *sub_100067E20@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, float *a3@<X8>)
{
  return sub_1000666C8(*(void *)(a1 + 8), a2, a3);
}

uint64_t sub_100067E28(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a1 + 20) == -1) {
    return sub_1000668D8(*(void *)(a1 + 8), a2);
  }
  sub_100067958(a1, a2);
  if (!*(_BYTE *)(a1 + 25)) {
    return sub_1000668D8(*(void *)(a1 + 8), a2);
  }
  else {
    return -1LL;
  }
}

uint64_t sub_100067E80(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(void *)a1 = &off_1000D0FB0;
  int v6 = operator new(0x40uLL);
  sub_100066998((uint64_t)v6, *(void *)(a2 + 8), a3);
  *(void *)(a1 + std::istream::~istream(v2, v3 + 8) = v6;
  *(void *)(a1 + 16) = *(void *)(a2 + 16);
  *(_BYTE *)(a1 + ++*(void *)(result + 24) = *(_BYTE *)(a2 + 24);
  *(_BYTE *)(a1 + 52) = *(_BYTE *)(a2 + 52);
  *(_DWORD *)(a1 + ++*(void *)(result + 56) = -1;
  return a1;
}

void sub_100067EF8(_Unwind_Exception *a1)
{
}

void *sub_100067F0C(void *a1)
{
  uint64_t v2 = a1[1];
  *a1 = &off_1000D1048;
  a1[1] = 0LL;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8LL))(v2);
  }
  return a1;
}

void sub_100067F4C(void *__p)
{
  uint64_t v2 = __p[1];
  *std::string __p = &off_1000D1048;
  __p[1] = 0LL;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8LL))(v2);
  }
  operator delete(__p);
}

void *sub_100067F8C(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = operator new(0x40uLL);
  sub_100067FE4((uint64_t)v4, a1, a2);
  return v4;
}

void sub_100067FD0(_Unwind_Exception *a1)
{
}

uint64_t sub_100067FE4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(void *)a1 = &off_1000D1048;
  int v6 = operator new(0x40uLL);
  sub_100067E80((uint64_t)v6, *(void *)(a2 + 8), a3);
  *(void *)(a1 + std::istream::~istream(v2, v3 + 8) = v6;
  *(void *)(a1 + 16) = *(void *)(a2 + 16);
  *(_BYTE *)(a1 + ++*(void *)(result + 24) = *(_BYTE *)(a2 + 24);
  *(_BYTE *)(a1 + 4std::istream::~istream(v2, v3 + 8) = *(_BYTE *)(a2 + 48);
  *(_DWORD *)(a1 + 52) = -1;
  *(_BYTE *)(a1 + ++*(void *)(result + 56) = 0;
  return a1;
}

void sub_100068060(_Unwind_Exception *a1)
{
}

int32x2_t *sub_100068074(int32x2_t *a1, uint64_t a2, __int32 a3, __int32 a4)
{
  *a1 = (int32x2_t)off_1000D0E58;
  a1[1] = 0LL;
  a1[2] = (int32x2_t)a2;
  a1[3].i32[0] = -1;
  a1[4] = 0LL;
  a1[5].i32[0] = a3;
  a1[5].i32[1] = a4;
  a1[6].i32[0] = -1;
  a1[7] = 0LL;
  int v5 = *sub_10002AD60();
  a1[8] = (int32x2_t)0xFFFFFFFFLL;
  a1[9].i32[0] = v5;
  a1[9].i32[1] = -1;
  a1[10].i8[2] = 0;
  a1[11] = (int32x2_t)off_1000D0F48;
  sub_100067104(&a1[12], 1LL);
  a1[18] = 0LL;
  a1[11] = (int32x2_t)off_1000D0EF0;
  __int32 v6 = a1[5].i32[0];
  if (v6 != 1)
  {
    if (v6 == 2)
    {
      a1[8] = vrev64_s32(a1[8]);
    }

    else if (v6 != 4)
    {
      if (byte_1000DDAF8) {
        sub_10000A2DC(__p, "FATAL");
      }
      else {
        sub_10000A2DC(__p, "ERROR");
      }
      sub_10002A9EC(&v10, (uint64_t)__p);
      sub_10002A6A4(&std::cerr, (uint64_t)"SortedMatcher: Bad match type", 29LL);
      sub_10002AA94(&v10);
      if (v9 < 0) {
        operator delete(__p[0]);
      }
      a1[5].i32[0] = 4;
      a1[10].i8[2] = 1;
    }
  }

  return a1;
}

void sub_1000681C8( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, int a15, __int16 a16, char a17, char a18)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  v18[11] = v19;
  v18[12] = off_1000D0F70;
  sub_10002B998(v18 + 15);
  uint64_t v21 = v18[1];
  v18[1] = 0LL;
  if (v21) {
    (*(void (**)(uint64_t))(*(void *)v21 + 8LL))(v21);
  }
  _Unwind_Resume(a1);
}

double sub_100068238@<D0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, _OWORD *a4@<X8>)
{
  v7[0] = *(_BYTE *)a3;
  uint64_t v8 = *(void *)(a3 + 8);
  uint64_t v9 = 0LL;
  char v10 = 1;
  __int128 v5 = *(_OWORD *)(a3 + 32);
  __int128 v11 = *(_OWORD *)(a3 + 16);
  __int128 v12 = v5;
  __int16 v13 = 1;
  sub_1000684CC(a1, a2, (uint64_t)v7, v14);
  double result = v14[0];
  *a4 = *(_OWORD *)v14;
  return result;
}

void *sub_1000682A8(void *a1)
{
  *a1 = off_1000D2460;
  sub_100017FC4((uint64_t)(a1 + 1));
  return a1;
}

void sub_1000682D8(void *a1)
{
  *a1 = off_1000D2460;
  sub_100017FC4((uint64_t)(a1 + 1));
  operator delete(a1);
}

uint64_t sub_100068308(uint64_t a1)
{
  return sub_1000728EC(*(void *)(a1 + 8));
}

float sub_100068310@<S0>(uint64_t a1@<X0>, uint64_t a2@<X1>, _DWORD *a3@<X8>)
{
  return sub_10007297C(*(uint64_t **)(a1 + 8), a2, a3);
}

uint64_t sub_100068318(uint64_t a1, uint64_t a2)
{
  return sub_100072A80(*(void **)(a1 + 8), a2);
}

uint64_t sub_100068320(uint64_t a1, uint64_t a2)
{
  return sub_100072B4C(*(void **)(a1 + 8), a2);
}

uint64_t sub_100068328(uint64_t a1, uint64_t a2)
{
  return sub_100072BB4(*(void **)(a1 + 8), a2);
}

uint64_t sub_100068330(uint64_t a1, uint64_t a2, int a3)
{
  if (!a3) {
    return (*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 8) + 24LL))(*(void *)(a1 + 8), a2);
  }
  unint64_t v5 = sub_10005AF40(a1, a2, &v7);
  *(void *)(*(void *)(a1 + 8) + 8LL) = *(void *)(*(void *)(a1 + 8) + 8LL) & (~v7 | 4) | v7 & v5;
  return v5 & a2;
}

uint64_t sub_1000683B4(uint64_t a1)
{
  return *(void *)(a1 + 8) + 16LL;
}

void *sub_1000683C0(uint64_t a1, int a2)
{
  uint64_t v4 = operator new(0x18uLL);
  sub_100072C1C(v4, a1, a2);
  return v4;
}

void sub_100068404(_Unwind_Exception *a1)
{
}

uint64_t sub_100068418(uint64_t a1)
{
  return *(void *)(*(void *)(a1 + 8) + 40LL);
}

uint64_t sub_100068424(uint64_t a1)
{
  return *(void *)(*(void *)(a1 + 8) + 48LL);
}

uint64_t sub_100068430(uint64_t *a1, void *a2)
{
  uint64_t v4 = operator new(0x20uLL);
  *uint64_t v4 = &off_1000D25F0;
  v4[1] = a1;
  uint64_t v5 = *a1;
  _DWORD v4[2] = a1[1];
  *((_DWORD *)v4 + 6) = 0;
  uint64_t result = (*(uint64_t (**)(uint64_t *))(v5 + 16))(a1);
  *uint64_t v4 = &off_1000D2570;
  *a2 = v4;
  return result;
}

void sub_100068498(_Unwind_Exception *a1)
{
}

uint64_t sub_1000684AC(uint64_t a1, uint64_t a2, void *a3)
{
  return sub_100073028(*(void *)(a1 + 8), a2, a3);
}

uint64_t sub_1000684B4(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 8) + 48LL))( *(void *)(a1 + 8),  a1,  a2);
}

void *sub_1000684CC@<X0>(uint64_t a1@<X1>, uint64_t a2@<X2>, uint64_t a3@<X3>, void *a4@<X8>)
{
  uint64_t v8 = operator new(0xD8uLL);
  uint64_t result = sub_10006853C(v8, a1, a2, a3);
  *a4 = v8 + 3;
  a4[1] = v8;
  return result;
}

void sub_100068528(_Unwind_Exception *a1)
{
}

void *sub_10006853C(void *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  a1[1] = 0LL;
  a1[2] = 0LL;
  *a1 = off_1000D1190;
  sub_1000685C4((uint64_t)(a1 + 3), a2, a3, a4);
  return a1;
}

void sub_100068570(_Unwind_Exception *a1)
{
}

void sub_100068584(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_1000D1190;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100068594(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_1000D1190;
  std::__shared_weak_count::~__shared_weak_count(a1);
  operator delete(v1);
}

uint64_t sub_1000685B4(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 24))(a1 + 24);
}

uint64_t sub_1000685C4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  *(void *)sub_10006911C(a1, (char *)a4) = off_1000D11E0;
  uint64_t v8 = *(uint64_t **)(a4 + 48);
  if (!v8)
  {
    uint64_t v8 = (uint64_t *)operator new(0x28uLL);
    sub_10006C780((uint64_t)v8, a2, a3, *(void **)(a4 + 32), *(void **)(a4 + 40));
  }

  *(void *)(a1 + 136) = v8;
  uint64_t v9 = *v8;
  *(void *)(a1 + 144) = *v8;
  *(void *)(a1 + 152) = v8[1];
  *(void *)(a1 + 16RDString::RDString((RDString *)&v66, theString, 0) = (*(uint64_t (**)(uint64_t))(*(void *)v9 + 72LL))(v9);
  *(void *)(a1 + 16std::istream::~istream(v2, v3 + 8) = (*(uint64_t (**)(void))(**(void **)(a1 + 152) + 72LL))(*(void *)(a1 + 152));
  char v10 = *(void **)(a4 + 56);
  __int128 v11 = v10;
  if (!v10)
  {
    __int128 v11 = operator new(0x88uLL);
    sub_10006C8A4((uint64_t)v11, 0LL, 0LL, 0LL);
    char v10 = *(void **)(a4 + 56);
  }

  *(void *)(a1 + 176) = v11;
  if (v10) {
    BOOL v12 = *(_BYTE *)(a4 + 64) == 0;
  }
  else {
    BOOL v12 = 0;
  }
  char v13 = !v12;
  *(_BYTE *)(a1 + 184) = v13;
  sub_10000A2DC(&__str, "compose");
  std::string::operator=((std::string *)(a1 + 16), &__str);
  uint64_t v14 = (*(uint64_t (**)(uint64_t))(*(void *)a3 + 96LL))(a3);
  uint64_t v15 = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 104LL))(a2);
  if (!sub_10009F090(v14, v15, 1))
  {
    if (byte_1000DDAF8) {
      sub_10000A2DC(&__str, "FATAL");
    }
    else {
      sub_10000A2DC(&__str, "ERROR");
    }
    sub_10002A9EC(&v30, (uint64_t)&__str);
    BOOL v16 = sub_10002A6A4(&std::cerr, (uint64_t)"ComposeFst: Output symbol table of 1st argument ", 48LL);
    sub_10002A6A4(v16, (uint64_t)"does not match input symbol table of 2nd argument", 49LL);
    sub_10002AA94(&v30);
    *(void *)(a1 + 8) |= 4uLL;
  }

  uint64_t v17 = (*(uint64_t (**)(void))(**(void **)(a1 + 160) + 96LL))(*(void *)(a1 + 160));
  if (v17) {
    uint64_t v17 = (*(uint64_t (**)(uint64_t))(*(void *)v17 + 16LL))(v17);
  }
  uint64_t v18 = *(void *)(a1 + 40);
  *(void *)(a1 + 4RDString::RDString((RDString *)&v66, theString, 0) = v17;
  if (v18) {
    (*(void (**)(uint64_t))(*(void *)v18 + 8LL))(v18);
  }
  uint64_t v19 = (*(uint64_t (**)(void))(**(void **)(a1 + 168) + 104LL))(*(void *)(a1 + 168));
  if (v19) {
    uint64_t v19 = (*(uint64_t (**)(uint64_t))(*(void *)v19 + 16LL))(v19);
  }
  uint64_t v20 = *(void *)(a1 + 48);
  *(void *)(a1 + 4std::istream::~istream(v2, v3 + 8) = v19;
  if (v20) {
    (*(void (**)(uint64_t))(*(void *)v20 + 8LL))(v20);
  }
  sub_100068A10(a1);
  if (dword_1000DE7E8 >= 2)
  {
    sub_10000A2DC(__p, "INFO");
    sub_10002A9EC(&v29, (uint64_t)__p);
    uint64_t v21 = sub_10002A6A4(&std::cerr, (uint64_t)"ComposeFstImpl: Match type: ", 28LL);
    std::ostream::operator<<(v21, *(unsigned int *)(a1 + 188));
    sub_10002AA94(&v29);
    if (v28 < 0) {
      operator delete(__p[0]);
    }
  }

  if (*(_DWORD *)(a1 + 188) == 4) {
    *(void *)(a1 + 8) |= 4uLL;
  }
  uint64_t v22 = (*(uint64_t (**)(uint64_t, uint64_t, void))(*(void *)a2 + 56LL))(a2, 0xFFFFFFFF0007LL, 0LL);
  uint64_t v23 = (*(uint64_t (**)(uint64_t, uint64_t, void))(*(void *)a3 + 56LL))(a3, 0xFFFFFFFF0007LL, 0LL);
  uint64_t v24 = (*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 144) + 80LL))(*(void *)(a1 + 144), v22);
  uint64_t v25 = (*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 152) + 80LL))(*(void *)(a1 + 152), v23);
  *(void *)(a1 + std::istream::~istream(v2, v3 + 8) = *(void *)(a1 + 8) & 0xFFFF00000000FFFFLL | sub_1000A4740(v24, v25) & 0xFFFFFFFF0004LL;
  return a1;
}

void sub_10006894C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, int a16, __int16 a17, char a18, char a19, void *__p, uint64_t a21, int a22, __int16 a23, char a24, char a25)
{
  if (a25 < 0) {
    operator delete(__p);
  }
  char v28 = *v26;
  *uint64_t v26 = 0LL;
  if (v28) {
    sub_10006E85C((int)v26, v28);
  }
  sub_10006C6D8(v25);
  _Unwind_Resume(a1);
}

void sub_100068A10(uint64_t a1)
{
  if (((*(uint64_t (**)(void))(**(void **)(a1 + 144) + 88LL))(*(void *)(a1 + 144)) & 1) != 0
    && (*(unsigned int (**)(void, uint64_t))(**(void **)(a1 + 144) + 24LL))(*(void *)(a1 + 144), 1LL) != 2)
  {
    if (byte_1000DDAF8) {
      sub_10000A2DC(__p, "FATAL");
    }
    else {
      sub_10000A2DC(__p, "ERROR");
    }
    sub_10002A9EC(&v14, (uint64_t)__p);
    uint64_t v9 = sub_10002A6A4(&std::cerr, (uint64_t)"ComposeFst: 1st argument cannot perform required matching ", 58LL);
    sub_10002A6A4(v9, (uint64_t)"(sort?).", 8LL);
  }

  else if (((*(uint64_t (**)(void))(**(void **)(a1 + 152) + 88LL))(*(void *)(a1 + 152)) & 1) != 0 {
         && (*(unsigned int (**)(void, uint64_t))(**(void **)(a1 + 152) + 24LL))( *(void *)(a1 + 152),  1LL) != 1)
  }
  {
    if (byte_1000DDAF8) {
      sub_10000A2DC(__p, "FATAL");
    }
    else {
      sub_10000A2DC(__p, "ERROR");
    }
    sub_10002A9EC(&v14, (uint64_t)__p);
    char v10 = sub_10002A6A4(&std::cerr, (uint64_t)"ComposeFst: 2nd argument cannot perform required matching ", 58LL);
    sub_10002A6A4(v10, (uint64_t)"(sort?).", 8LL);
  }

  else
  {
    int v2 = (*(uint64_t (**)(void, void))(**(void **)(a1 + 144) + 24LL))(*(void *)(a1 + 144), 0LL);
    int v3 = (*(uint64_t (**)(void, void))(**(void **)(a1 + 152) + 24LL))(*(void *)(a1 + 152), 0LL);
    if (v3 == 1 && v2 == 2) {
      int v5 = 3;
    }
    else {
      int v5 = 2;
    }
    BOOL v6 = v2 == 2;
    if (v2 == 2) {
      int v7 = v5;
    }
    else {
      int v7 = 1;
    }
    if (v6 || v3 == 1) {
      goto LABEL_36;
    }
    if ((*(unsigned int (**)(void, uint64_t))(**(void **)(a1 + 144) + 24LL))(*(void *)(a1 + 144), 1LL) == 2)
    {
      int v7 = 2;
      goto LABEL_36;
    }

    int v7 = 1;
    if (byte_1000DDAF8) {
      sub_10000A2DC(__p, "FATAL");
    }
    else {
      sub_10000A2DC(__p, "ERROR");
    }
    sub_10002A9EC(&v14, (uint64_t)__p);
    __int128 v11 = sub_10002A6A4(&std::cerr, (uint64_t)"ComposeFst: 1st argument cannot match on output labels ", 55LL);
    sub_10002A6A4(v11, (uint64_t)"and 2nd argument cannot match on input labels (sort?).", 54LL);
  }

  sub_10002AA94(&v14);
  if (v13 < 0) {
    operator delete(__p[0]);
  }
  int v7 = 4;
LABEL_36:
  *(_DWORD *)(a1 + 18std::istream::~istream(v2, v3 + 8) = v7;
}

void sub_100068CA8( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100068D04(uint64_t a1)
{
  uint64_t v1 = (void *)sub_10006E8B4(a1);
  operator delete(v1);
}

uint64_t sub_100068D18(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a1 + 24LL))(a1, 0xFFFFFFFF0007LL);
}

uint64_t sub_100068D2C(uint64_t a1, uint64_t a2)
{
  if ((a2 & 4) != 0
    && ((*(uint64_t (**)(void, uint64_t, void))(**(void **)(a1 + 160) + 56LL))( *(void *)(a1 + 160),  4LL,  0LL)
     || (*(uint64_t (**)(void, uint64_t, void))(**(void **)(a1 + 168) + 56LL))( *(void *)(a1 + 168),  4LL,  0LL)
     || ((*(uint64_t (**)(void, void))(**(void **)(a1 + 144) + 80LL))(*(void *)(a1 + 144), 0LL) & 4) != 0
     || ((*(uint64_t (**)(void, void))(**(void **)(a1 + 152) + 80LL))(*(void *)(a1 + 152), 0LL) & 4) != 0))
  {
    *(void *)(a1 + 8) |= 4uLL;
  }

  return *(void *)(a1 + 8) & a2;
}

void *sub_100068DCC(uint64_t a1)
{
  int v2 = operator new(0xC0uLL);
  sub_10006E944((uint64_t)v2, a1);
  return v2;
}

void sub_100068E00(_Unwind_Exception *a1)
{
}

void sub_100068E14(void *a1, int a2)
{
  uint64_t v4 = (unsigned int *)(*(void *)(a1[22] + 104LL) + 12LL * a2);
  uint64_t v5 = *v4;
  uint64_t v6 = v4[1];
  int v7 = (int *)a1[17];
  char v16 = *((_BYTE *)v4 + 8);
  sub_100070870(v7, v5, v6, &v16);
  if (sub_100070954((uint64_t)a1, v5, v6))
  {
    uint64_t v9 = a1[20];
    uint64_t v8 = a1[21];
    uint64_t v10 = a1[19];
    uint64_t v11 = (uint64_t)a1;
    int v12 = a2;
    uint64_t v13 = v6;
    uint64_t v14 = v5;
    int v15 = 1;
  }

  else
  {
    uint64_t v8 = a1[20];
    uint64_t v9 = a1[21];
    uint64_t v10 = a1[18];
    uint64_t v11 = (uint64_t)a1;
    int v12 = a2;
    uint64_t v13 = v5;
    uint64_t v14 = v6;
    int v15 = 0;
  }

  sub_100070AA0(v11, v12, v8, v13, v9, v14, v10, v15);
}

void *sub_100068EC8(uint64_t a1, uint64_t a2, int a3)
{
  if ((*(unsigned int (**)(void, void))(**(void **)(a1 + 144) + 24LL))(*(void *)(a1 + 144), 0LL) != a3
    || (*(unsigned int (**)(void, void))(**(void **)(a1 + 152) + 24LL))(*(void *)(a1 + 152), 0LL) != a3)
  {
    return 0LL;
  }

  uint64_t v6 = operator new(0x60uLL);
  sub_100071F9C((uint64_t)v6, a2, a3);
  return v6;
}

void sub_100068F50(_Unwind_Exception *a1)
{
}

uint64_t sub_100068F64(void **a1)
{
  uint64_t result = (*(uint64_t (**)(void *))(*a1[20] + 16LL))(a1[20]);
  if ((_DWORD)result != -1)
  {
    unsigned int v3 = result;
    uint64_t result = (*(uint64_t (**)(void *))(*a1[21] + 16LL))(a1[21]);
    if ((_DWORD)result != -1)
    {
      unint64_t v4 = __PAIR64__(result, v3);
      char v5 = 0;
      return sub_100070F74(a1[22], (uint64_t *)&v4, 1);
    }
  }

  return result;
}

int *sub_100068FD4@<X0>(void *a1@<X0>, int a2@<W1>, float *a3@<X8>)
{
  uint64_t v6 = *(void *)(a1[22] + 104LL);
  int v7 = (unsigned int *)(v6 + 12LL * a2);
  uint64_t v8 = *v7;
  sub_1000666C8(*(void *)(*(void *)(a1[18] + 8LL) + 8LL), v8, &v15);
  uint64_t result = sub_10002ADB0();
  float v10 = v15;
  float v17 = v15;
  float v16 = *(float *)result;
  if (v15 != v16)
  {
    uint64_t v11 = v7[1];
    sub_1000666C8(*(void *)(*(void *)(a1[19] + 8LL) + 8LL), v11, &v14);
    uint64_t result = sub_10002ADB0();
    float v10 = v14;
    float v17 = v14;
    float v16 = *(float *)result;
    if (v14 != v16)
    {
      int v12 = (int *)a1[17];
      LOBYTE(v17) = *(_BYTE *)(v6 + 12LL * a2 + 8);
      uint64_t result = sub_100070870(v12, v8, v11, &v17);
      if (v15 == -INFINITY || v14 >= -INFINITY && v14 <= -INFINITY)
      {
        uint64_t result = sub_1000606CC();
        float v10 = *(float *)result;
      }

      else
      {
        BOOL v13 = v14 == INFINITY || v15 == INFINITY;
        float v10 = v15 + v14;
        if (v13) {
          float v10 = INFINITY;
        }
      }
    }
  }

  *a3 = v10;
  return result;
}

uint64_t sub_10006911C(uint64_t a1, char *a2)
{
  *(void *)a1 = off_1000D05B8;
  *(void *)(a1 + std::istream::~istream(v2, v3 + 8) = 0LL;
  sub_10000A2DC((void *)(a1 + 16), "null");
  *(void *)(a1 + 4RDString::RDString((RDString *)&v66, theString, 0) = 0LL;
  *(void *)(a1 + 4std::istream::~istream(v2, v3 + 8) = 0LL;
  *(void *)a1 = off_1000D12D8;
  *(_BYTE *)(a1 + ++*(void *)(result + 56) = 0;
  *(void *)(a1 + 6RDString::RDString((RDString *)&v66, theString, 0) = 0xFFFFFFFFLL;
  *(void *)(a1 + sub_10001A760(v25 - 72) = 0LL;
  *(void *)(a1 + 8RDString::RDString((RDString *)&v66, theString, 0) = 0LL;
  *(void *)(a1 + 8std::istream::~istream(v2, v3 + 8) = 0LL;
  *(void *)(a1 + 96) = 0xFFFFFFFF00000000LL;
  char v4 = *a2;
  *(_BYTE *)(a1 + 104) = *a2;
  unint64_t v5 = *((void *)a2 + 1);
  *(void *)(a1 + 112) = v5;
  uint64_t v6 = (_BYTE *)*((void *)a2 + 2);
  int v7 = v6;
  if (!v6)
  {
    int v7 = operator new(0x88uLL);
    v11[0] = v4;
    unint64_t v12 = v5;
    sub_100069288((uint64_t)v7, v11);
    unint64_t v8 = v12;
    v7[88] = v12 == 0;
    *((_DWORD *)v7 + 23) = -1;
    *((void *)v7 + 12) = 0LL;
    v7[104] = v11[0];
    if (v8 <= 0x1FA0) {
      unint64_t v8 = 8096LL;
    }
    *((void *)v7 + 14) = v8;
    v7[120] = 0;
    *((void *)v7 + 16) = 0LL;
    uint64_t v6 = (_BYTE *)*((void *)a2 + 2);
  }

  *(void *)(a1 + 12RDString::RDString((RDString *)&v66, theString, 0) = v7;
  BOOL v9 = v6 == 0LL;
  *(_BYTE *)(a1 + 12std::istream::~istream(v2, v3 + 8) = v9;
  if (a2[24]) {
    BOOL v9 = 1;
  }
  *(_BYTE *)(a1 + 129) = v9;
  return a1;
}

void sub_100069238(_Unwind_Exception *a1)
{
  if (*v3) {
    operator delete(*v3);
  }
  sub_10002D2D8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100069268()
{
  return 0LL;
}

void sub_100069274(uint64_t a1)
{
  uint64_t v1 = (void *)sub_10006C6D8(a1);
  operator delete(v1);
}

uint64_t sub_100069288(uint64_t a1, _BYTE *a2)
{
  *(_BYTE *)a1 = *a2;
  *(void *)(a1 + std::istream::~istream(v2, v3 + 8) = 0LL;
  *(void *)(a1 + 16) = 0LL;
  *(void *)(a1 + ++*(void *)(result + 24) = 0LL;
  *(void *)(a1 + 32) = a1 + 32;
  *(void *)(a1 + 4RDString::RDString((RDString *)&v66, theString, 0) = a1 + 32;
  *(void *)(a1 + 4std::istream::~istream(v2, v3 + 8) = 0LL;
  unsigned int v3 = operator new(0x28uLL);
  *(void *)(a1 + ++*(void *)(result + 56) = v3;
  *(void *)(a1 + 64) = 0LL;
  *(_OWORD *)unsigned int v3 = xmmword_1000AC970;
  v3[3] = 0LL;
  void v3[4] = 0LL;
  _OWORD v3[2] = 0LL;
  char v4 = operator new(0x28uLL);
  *(_OWORD *)char v4 = xmmword_1000AC970;
  v4[3] = 0LL;
  v4[4] = 0LL;
  _DWORD v4[2] = 0LL;
  *(void *)(a1 + sub_10001A760(v25 - 72) = v4;
  unint64_t v5 = operator new(0x28uLL);
  *(_OWORD *)unint64_t v5 = xmmword_1000AC970;
  void v5[3] = 0LL;
  void v5[4] = 0LL;
  _OWORD v5[2] = 0LL;
  *(void *)(a1 + 8RDString::RDString((RDString *)&v66, theString, 0) = v5;
  sub_1000693A4(a1);
  *(void *)(a1 + 64) = *(void *)(a1 + 40);
  return a1;
}

void sub_100069354(_Unwind_Exception *a1)
{
  uint64_t v6 = v4;
  sub_10006C608(v6);
  sub_10006C608(v3 + 2);
  sub_10006B424(v2);
  sub_10006C608(v3);
  unint64_t v8 = *v5;
  if (*v5)
  {
    *(void *)(v1 + 16) = v8;
    operator delete(v8);
  }

  _Unwind_Resume(a1);
}

void *sub_1000693A4(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 16);
  if (v2 != *(void *)(a1 + 8))
  {
    unint64_t v3 = 0LL;
    uint64_t v2 = *(void *)(a1 + 8);
    do
    {
      sub_100069408(*(void **)(v2 + 8 * v3++), (uint64_t **)(a1 + 72));
      uint64_t v2 = *(void *)(a1 + 8);
    }

    while (v3 < (*(void *)(a1 + 16) - v2) >> 3);
  }

  *(void *)(a1 + 16) = v2;
  return sub_10006B424((void *)(a1 + 32));
}

void *sub_100069408(void *result, uint64_t **a2)
{
  if (result)
  {
    unint64_t v3 = (void ***)result;
    char v4 = (void **)(result + 3);
    sub_100069460(&v4);
    sub_10006C608(v3 + 6);
    uint64_t result = sub_10006A950(*a2);
    v3[8] = (void **)result[7];
    result[7] = v3;
  }

  return result;
}

void sub_100069460(void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = **a1;
  if (v2)
  {
    v1[1] = v2;
    sub_100069498(v1 + 3, v2, ((char *)v1[2] - (char *)v2) >> 4);
  }

void sub_100069498(uint64_t **a1, void *__p, unint64_t a3)
{
  if (a3 == 2)
  {
    char v4 = sub_100069A30(*a1);
    if (!__p) {
      return;
    }
    __p[4] = v4[7];
    goto LABEL_22;
  }

  if (a3 == 1)
  {
    char v4 = sub_1000695A4(*a1);
    if (!__p) {
      return;
    }
    std::string __p[2] = v4[7];
    goto LABEL_22;
  }

  if (a3 <= 4)
  {
    char v4 = sub_100069CB4(*a1);
    if (!__p) {
      return;
    }
    __p[8] = v4[7];
    goto LABEL_22;
  }

  if (a3 <= 8)
  {
    char v4 = sub_100069F38(*a1);
    if (!__p) {
      return;
    }
    __p[16] = v4[7];
    goto LABEL_22;
  }

  if (a3 <= 0x10)
  {
    char v4 = sub_10006A1BC(*a1);
    if (!__p) {
      return;
    }
    __p[32] = v4[7];
    goto LABEL_22;
  }

  if (a3 <= 0x20)
  {
    char v4 = sub_10006A440(*a1);
    if (!__p) {
      return;
    }
    __p[64] = v4[7];
    goto LABEL_22;
  }

  if (a3 > 0x40)
  {
    operator delete(__p);
    return;
  }

  char v4 = sub_10006A6C8(*a1);
  if (__p)
  {
    __p[128] = v4[7];
LABEL_22:
    v4[7] = __p;
  }

void *sub_1000695A4(uint64_t *a1)
{
  uint64_t v2 = a1[2];
  unint64_t v3 = a1 + 2;
  if ((unint64_t)(a1[3] - v2) <= 0x87)
  {
    sub_100069658((uint64_t)(a1 + 2), 0x11uLL);
    uint64_t v2 = *v3;
  }

  char v4 = *(void **)(v2 + 128);
  if (!v4)
  {
    char v4 = operator new(0x40uLL);
    uint64_t v5 = *a1;
    *char v4 = off_1000D1360;
    sub_100069948(v4 + 1, v5);
    v4[7] = 0LL;
    *char v4 = off_1000D1308;
    uint64_t v6 = *(void *)(*v3 + 128);
    *(void *)(*v3 + 12std::istream::~istream(v2, v3 + 8) = v4;
    if (v6) {
      (*(void (**)(uint64_t))(*(void *)v6 + 8LL))(v6);
    }
  }

  return v4;
}

void sub_100069644(_Unwind_Exception *a1)
{
}

void sub_100069658(uint64_t a1, unint64_t a2)
{
  unint64_t v3 = *(void **)(a1 + 8);
  unint64_t v4 = ((uint64_t)v3 - *(void *)a1) >> 3;
  if (a2 <= v4)
  {
    if (a2 < v4)
    {
      uint64_t v5 = *(void *)a1 + 8 * a2;
      while (v3 != (void *)v5)
      {
        uint64_t v7 = *--v3;
        uint64_t v6 = v7;
        *unint64_t v3 = 0LL;
        if (v7) {
          (*(void (**)(uint64_t))(*(void *)v6 + 8LL))(v6);
        }
      }

      *(void *)(a1 + std::istream::~istream(v2, v3 + 8) = v5;
    }
  }

  else
  {
    sub_1000696DC((char **)a1, a2 - v4);
  }

void sub_1000696DC(char **a1, unint64_t a2)
{
  uint64_t v6 = a1[2];
  uint64_t v4 = (uint64_t)(a1 + 2);
  uint64_t v5 = v6;
  uint64_t v7 = *(char **)(v4 - 8);
  if (a2 <= (v6 - v7) >> 3)
  {
    if (a2)
    {
      bzero(*(void **)(v4 - 8), 8 * a2);
      v7 += 8 * a2;
    }

    a1[1] = v7;
  }

  else
  {
    unint64_t v8 = *a1;
    uint64_t v9 = v7 - *a1;
    unint64_t v10 = a2 + (v9 >> 3);
    if (v10 >> 61) {
      sub_100018774();
    }
    uint64_t v11 = v9 >> 3;
    uint64_t v12 = v5 - v8;
    if (v12 >> 2 > v10) {
      unint64_t v10 = v12 >> 2;
    }
    else {
      unint64_t v13 = v10;
    }
    uint64_t v24 = v4;
    if (v13)
    {
      float v14 = (char *)sub_100018788(v4, v13);
      unint64_t v8 = *a1;
      uint64_t v7 = a1[1];
    }

    else
    {
      float v14 = 0LL;
    }

    float v15 = &v14[8 * v11];
    float v16 = &v14[8 * v13];
    uint64_t v23 = v16;
    bzero(v15, 8 * a2);
    float v17 = &v15[8 * a2];
    *((void *)&v22 + 1) = v17;
    if (v7 != v8)
    {
      do
      {
        uint64_t v18 = *((void *)v7 - 1);
        v7 -= 8;
        *(void *)uint64_t v7 = 0LL;
        *((void *)v15 - 1) = v18;
        v15 -= 8;
      }

      while (v7 != v8);
      float v17 = (char *)*((void *)&v22 + 1);
      float v16 = v23;
    }

    __int128 v19 = *(_OWORD *)a1;
    *a1 = v15;
    a1[1] = v17;
    __int128 v22 = v19;
    uint64_t v20 = a1[2];
    a1[2] = v16;
    uint64_t v23 = v20;
    uint64_t v21 = v19;
    sub_100069800((uint64_t)&v21);
  }

uint64_t sub_100069800(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 8;
    uint64_t v4 = *(void *)(i - 8);
    *(void *)(i - std::istream::~istream(v2, v3 + 8) = 0LL;
    if (v4) {
      (*(void (**)(uint64_t))(*(void *)v4 + 8LL))(v4);
    }
  }

  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void *sub_100069860(void *a1)
{
  *a1 = off_1000D1360;
  a1[1] = off_1000D1388;
  sub_10002B998(a1 + 4);
  return a1;
}

void sub_100069898(uint64_t *a1)
{
  *a1 = (uint64_t)off_1000D1360;
  a1[1] = (uint64_t)off_1000D1388;
  sub_10002B998(a1 + 4);
  operator delete(a1);
}

uint64_t sub_1000698D0()
{
  return 16LL;
}

void *sub_1000698D8(void *a1)
{
  *a1 = off_1000D1360;
  a1[1] = off_1000D1388;
  sub_10002B998(a1 + 4);
  return a1;
}

void sub_100069910(uint64_t *a1)
{
  *a1 = (uint64_t)off_1000D1360;
  a1[1] = (uint64_t)off_1000D1388;
  sub_10002B998(a1 + 4);
  operator delete(a1);
}

void *sub_100069948(void *a1, uint64_t a2)
{
  *a1 = off_1000D1388;
  a1[1] = 24 * a2;
  uint64_t v3 = a1 + 3;
  a1[2] = 0LL;
  a1[3] = a1 + 3;
  a1[4] = a1 + 3;
  a1[5] = 0LL;
  uint64_t v4 = operator new[](24 * a2);
  uint64_t v5 = operator new(0x18uLL);
  v5[1] = v3;
  _OWORD v5[2] = v4;
  void *v5 = v3;
  a1[3] = v5;
  a1[4] = v5;
  a1[5] = 1LL;
  return a1;
}

void sub_1000699B4(_Unwind_Exception *a1)
{
}

void *sub_1000699C8(void *a1)
{
  *a1 = off_1000D1388;
  sub_10002B998(a1 + 3);
  return a1;
}

void sub_1000699F8(uint64_t *a1)
{
  *a1 = (uint64_t)off_1000D1388;
  sub_10002B998(a1 + 3);
  operator delete(a1);
}

uint64_t sub_100069A28()
{
  return 24LL;
}

void *sub_100069A30(uint64_t *a1)
{
  uint64_t v2 = a1[2];
  uint64_t v3 = a1 + 2;
  if ((unint64_t)(a1[3] - v2) <= 0x107)
  {
    sub_100069658((uint64_t)(a1 + 2), 0x21uLL);
    uint64_t v2 = *v3;
  }

  uint64_t v4 = *(void **)(v2 + 256);
  if (!v4)
  {
    uint64_t v4 = operator new(0x40uLL);
    uint64_t v5 = *a1;
    *uint64_t v4 = off_1000D1420;
    sub_100069BCC(v4 + 1, v5);
    v4[7] = 0LL;
    *uint64_t v4 = off_1000D13C8;
    uint64_t v6 = *(void *)(*v3 + 256);
    *(void *)(*v3 + 2++*(void *)(result + 56) = v4;
    if (v6) {
      (*(void (**)(uint64_t))(*(void *)v6 + 8LL))(v6);
    }
  }

  return v4;
}

void sub_100069AD0(_Unwind_Exception *a1)
{
}

void *sub_100069AE4(void *a1)
{
  *a1 = off_1000D1420;
  a1[1] = off_1000D1448;
  sub_10002B998(a1 + 4);
  return a1;
}

void sub_100069B1C(uint64_t *a1)
{
  *a1 = (uint64_t)off_1000D1420;
  a1[1] = (uint64_t)off_1000D1448;
  sub_10002B998(a1 + 4);
  operator delete(a1);
}

uint64_t sub_100069B54()
{
  return 32LL;
}

void *sub_100069B5C(void *a1)
{
  *a1 = off_1000D1420;
  a1[1] = off_1000D1448;
  sub_10002B998(a1 + 4);
  return a1;
}

void sub_100069B94(uint64_t *a1)
{
  *a1 = (uint64_t)off_1000D1420;
  a1[1] = (uint64_t)off_1000D1448;
  sub_10002B998(a1 + 4);
  operator delete(a1);
}

void *sub_100069BCC(void *a1, uint64_t a2)
{
  *a1 = off_1000D1448;
  a1[1] = 40 * a2;
  uint64_t v3 = a1 + 3;
  a1[2] = 0LL;
  a1[3] = a1 + 3;
  a1[4] = a1 + 3;
  a1[5] = 0LL;
  uint64_t v4 = operator new[](40 * a2);
  uint64_t v5 = operator new(0x18uLL);
  v5[1] = v3;
  _OWORD v5[2] = v4;
  void *v5 = v3;
  a1[3] = v5;
  a1[4] = v5;
  a1[5] = 1LL;
  return a1;
}

void sub_100069C38(_Unwind_Exception *a1)
{
}

void *sub_100069C4C(void *a1)
{
  *a1 = off_1000D1448;
  sub_10002B998(a1 + 3);
  return a1;
}

void sub_100069C7C(uint64_t *a1)
{
  *a1 = (uint64_t)off_1000D1448;
  sub_10002B998(a1 + 3);
  operator delete(a1);
}

uint64_t sub_100069CAC()
{
  return 40LL;
}

void *sub_100069CB4(uint64_t *a1)
{
  uint64_t v2 = a1[2];
  uint64_t v3 = a1 + 2;
  if ((unint64_t)(a1[3] - v2) <= 0x207)
  {
    sub_100069658((uint64_t)(a1 + 2), 0x41uLL);
    uint64_t v2 = *v3;
  }

  uint64_t v4 = *(void **)(v2 + 512);
  if (!v4)
  {
    uint64_t v4 = operator new(0x40uLL);
    uint64_t v5 = *a1;
    *uint64_t v4 = off_1000D14E0;
    sub_100069E50(v4 + 1, v5);
    v4[7] = 0LL;
    *uint64_t v4 = off_1000D1488;
    uint64_t v6 = *(void *)(*v3 + 512);
    *(void *)(*v3 + 512) = v4;
    if (v6) {
      (*(void (**)(uint64_t))(*(void *)v6 + 8LL))(v6);
    }
  }

  return v4;
}

void sub_100069D54(_Unwind_Exception *a1)
{
}

void *sub_100069D68(void *a1)
{
  *a1 = off_1000D14E0;
  a1[1] = off_1000D1508;
  sub_10002B998(a1 + 4);
  return a1;
}

void sub_100069DA0(uint64_t *a1)
{
  *a1 = (uint64_t)off_1000D14E0;
  a1[1] = (uint64_t)off_1000D1508;
  sub_10002B998(a1 + 4);
  operator delete(a1);
}

uint64_t sub_100069DD8()
{
  return 64LL;
}

void *sub_100069DE0(void *a1)
{
  *a1 = off_1000D14E0;
  a1[1] = off_1000D1508;
  sub_10002B998(a1 + 4);
  return a1;
}

void sub_100069E18(uint64_t *a1)
{
  *a1 = (uint64_t)off_1000D14E0;
  a1[1] = (uint64_t)off_1000D1508;
  sub_10002B998(a1 + 4);
  operator delete(a1);
}

void *sub_100069E50(void *a1, uint64_t a2)
{
  *a1 = off_1000D1508;
  a1[1] = 72 * a2;
  uint64_t v3 = a1 + 3;
  a1[2] = 0LL;
  a1[3] = a1 + 3;
  a1[4] = a1 + 3;
  a1[5] = 0LL;
  uint64_t v4 = operator new[](72 * a2);
  uint64_t v5 = operator new(0x18uLL);
  v5[1] = v3;
  _OWORD v5[2] = v4;
  void *v5 = v3;
  a1[3] = v5;
  a1[4] = v5;
  a1[5] = 1LL;
  return a1;
}

void sub_100069EBC(_Unwind_Exception *a1)
{
}

void *sub_100069ED0(void *a1)
{
  *a1 = off_1000D1508;
  sub_10002B998(a1 + 3);
  return a1;
}

void sub_100069F00(uint64_t *a1)
{
  *a1 = (uint64_t)off_1000D1508;
  sub_10002B998(a1 + 3);
  operator delete(a1);
}

uint64_t sub_100069F30()
{
  return 72LL;
}

void *sub_100069F38(uint64_t *a1)
{
  uint64_t v2 = a1[2];
  uint64_t v3 = a1 + 2;
  if ((unint64_t)(a1[3] - v2) <= 0x407)
  {
    sub_100069658((uint64_t)(a1 + 2), 0x81uLL);
    uint64_t v2 = *v3;
  }

  uint64_t v4 = *(void **)(v2 + 1024);
  if (!v4)
  {
    uint64_t v4 = operator new(0x40uLL);
    uint64_t v5 = *a1;
    *uint64_t v4 = off_1000D15A0;
    sub_10006A0D4(v4 + 1, v5);
    v4[7] = 0LL;
    *uint64_t v4 = off_1000D1548;
    uint64_t v6 = *(void *)(*v3 + 1024);
    *(void *)(*v3 + 10++*(void *)(result + 24) = v4;
    if (v6) {
      (*(void (**)(uint64_t))(*(void *)v6 + 8LL))(v6);
    }
  }

  return v4;
}

void sub_100069FD8(_Unwind_Exception *a1)
{
}

void *sub_100069FEC(void *a1)
{
  *a1 = off_1000D15A0;
  a1[1] = off_1000D15C8;
  sub_10002B998(a1 + 4);
  return a1;
}

void sub_10006A024(uint64_t *a1)
{
  *a1 = (uint64_t)off_1000D15A0;
  a1[1] = (uint64_t)off_1000D15C8;
  sub_10002B998(a1 + 4);
  operator delete(a1);
}

uint64_t sub_10006A05C()
{
  return 128LL;
}

void *sub_10006A064(void *a1)
{
  *a1 = off_1000D15A0;
  a1[1] = off_1000D15C8;
  sub_10002B998(a1 + 4);
  return a1;
}

void sub_10006A09C(uint64_t *a1)
{
  *a1 = (uint64_t)off_1000D15A0;
  a1[1] = (uint64_t)off_1000D15C8;
  sub_10002B998(a1 + 4);
  operator delete(a1);
}

void *sub_10006A0D4(void *a1, uint64_t a2)
{
  *a1 = off_1000D15C8;
  a1[1] = 136 * a2;
  uint64_t v3 = a1 + 3;
  a1[2] = 0LL;
  a1[3] = a1 + 3;
  a1[4] = a1 + 3;
  a1[5] = 0LL;
  uint64_t v4 = operator new[](136 * a2);
  uint64_t v5 = operator new(0x18uLL);
  v5[1] = v3;
  _OWORD v5[2] = v4;
  void *v5 = v3;
  a1[3] = v5;
  a1[4] = v5;
  a1[5] = 1LL;
  return a1;
}

void sub_10006A140(_Unwind_Exception *a1)
{
}

void *sub_10006A154(void *a1)
{
  *a1 = off_1000D15C8;
  sub_10002B998(a1 + 3);
  return a1;
}

void sub_10006A184(uint64_t *a1)
{
  *a1 = (uint64_t)off_1000D15C8;
  sub_10002B998(a1 + 3);
  operator delete(a1);
}

uint64_t sub_10006A1B4()
{
  return 136LL;
}

void *sub_10006A1BC(uint64_t *a1)
{
  uint64_t v2 = a1[2];
  uint64_t v3 = a1 + 2;
  if ((unint64_t)(a1[3] - v2) <= 0x807)
  {
    sub_100069658((uint64_t)(a1 + 2), 0x101uLL);
    uint64_t v2 = *v3;
  }

  uint64_t v4 = *(void **)(v2 + 2048);
  if (!v4)
  {
    uint64_t v4 = operator new(0x40uLL);
    uint64_t v5 = *a1;
    *uint64_t v4 = off_1000D1660;
    sub_10006A358(v4 + 1, v5);
    v4[7] = 0LL;
    *uint64_t v4 = off_1000D1608;
    uint64_t v6 = *(void *)(*v3 + 2048);
    *(void *)(*v3 + 204std::istream::~istream(v2, v3 + 8) = v4;
    if (v6) {
      (*(void (**)(uint64_t))(*(void *)v6 + 8LL))(v6);
    }
  }

  return v4;
}

void sub_10006A25C(_Unwind_Exception *a1)
{
}

void *sub_10006A270(void *a1)
{
  *a1 = off_1000D1660;
  a1[1] = off_1000D1688;
  sub_10002B998(a1 + 4);
  return a1;
}

void sub_10006A2A8(uint64_t *a1)
{
  *a1 = (uint64_t)off_1000D1660;
  a1[1] = (uint64_t)off_1000D1688;
  sub_10002B998(a1 + 4);
  operator delete(a1);
}

uint64_t sub_10006A2E0()
{
  return 256LL;
}

void *sub_10006A2E8(void *a1)
{
  *a1 = off_1000D1660;
  a1[1] = off_1000D1688;
  sub_10002B998(a1 + 4);
  return a1;
}

void sub_10006A320(uint64_t *a1)
{
  *a1 = (uint64_t)off_1000D1660;
  a1[1] = (uint64_t)off_1000D1688;
  sub_10002B998(a1 + 4);
  operator delete(a1);
}

void *sub_10006A358(void *a1, uint64_t a2)
{
  *a1 = off_1000D1688;
  a1[1] = 264 * a2;
  uint64_t v3 = a1 + 3;
  a1[2] = 0LL;
  a1[3] = a1 + 3;
  a1[4] = a1 + 3;
  a1[5] = 0LL;
  uint64_t v4 = operator new[](264 * a2);
  uint64_t v5 = operator new(0x18uLL);
  v5[1] = v3;
  _OWORD v5[2] = v4;
  void *v5 = v3;
  a1[3] = v5;
  a1[4] = v5;
  a1[5] = 1LL;
  return a1;
}

void sub_10006A3C4(_Unwind_Exception *a1)
{
}

void *sub_10006A3D8(void *a1)
{
  *a1 = off_1000D1688;
  sub_10002B998(a1 + 3);
  return a1;
}

void sub_10006A408(uint64_t *a1)
{
  *a1 = (uint64_t)off_1000D1688;
  sub_10002B998(a1 + 3);
  operator delete(a1);
}

uint64_t sub_10006A438()
{
  return 264LL;
}

void *sub_10006A440(uint64_t *a1)
{
  uint64_t v2 = a1[2];
  uint64_t v3 = a1 + 2;
  if ((unint64_t)(a1[3] - v2) >> 3 <= 0x200)
  {
    sub_100069658((uint64_t)(a1 + 2), 0x201uLL);
    uint64_t v2 = *v3;
  }

  uint64_t v4 = *(void **)(v2 + 4096);
  if (!v4)
  {
    uint64_t v4 = operator new(0x40uLL);
    uint64_t v5 = *a1;
    *uint64_t v4 = off_1000D1720;
    sub_10006A5E0(v4 + 1, v5);
    v4[7] = 0LL;
    *uint64_t v4 = off_1000D16C8;
    uint64_t v6 = *(void *)(*v3 + 4096);
    *(void *)(*v3 + 4096) = v4;
    if (v6) {
      (*(void (**)(uint64_t))(*(void *)v6 + 8LL))(v6);
    }
  }

  return v4;
}

void sub_10006A4E4(_Unwind_Exception *a1)
{
}

void *sub_10006A4F8(void *a1)
{
  *a1 = off_1000D1720;
  a1[1] = off_1000D1748;
  sub_10002B998(a1 + 4);
  return a1;
}

void sub_10006A530(uint64_t *a1)
{
  *a1 = (uint64_t)off_1000D1720;
  a1[1] = (uint64_t)off_1000D1748;
  sub_10002B998(a1 + 4);
  operator delete(a1);
}

uint64_t sub_10006A568()
{
  return 512LL;
}

void *sub_10006A570(void *a1)
{
  *a1 = off_1000D1720;
  a1[1] = off_1000D1748;
  sub_10002B998(a1 + 4);
  return a1;
}

void sub_10006A5A8(uint64_t *a1)
{
  *a1 = (uint64_t)off_1000D1720;
  a1[1] = (uint64_t)off_1000D1748;
  sub_10002B998(a1 + 4);
  operator delete(a1);
}

void *sub_10006A5E0(void *a1, uint64_t a2)
{
  *a1 = off_1000D1748;
  a1[1] = 520 * a2;
  uint64_t v3 = a1 + 3;
  a1[2] = 0LL;
  a1[3] = a1 + 3;
  a1[4] = a1 + 3;
  a1[5] = 0LL;
  uint64_t v4 = operator new[](520 * a2);
  uint64_t v5 = operator new(0x18uLL);
  v5[1] = v3;
  _OWORD v5[2] = v4;
  void *v5 = v3;
  a1[3] = v5;
  a1[4] = v5;
  a1[5] = 1LL;
  return a1;
}

void sub_10006A64C(_Unwind_Exception *a1)
{
}

void *sub_10006A660(void *a1)
{
  *a1 = off_1000D1748;
  sub_10002B998(a1 + 3);
  return a1;
}

void sub_10006A690(uint64_t *a1)
{
  *a1 = (uint64_t)off_1000D1748;
  sub_10002B998(a1 + 3);
  operator delete(a1);
}

uint64_t sub_10006A6C0()
{
  return 520LL;
}

void *sub_10006A6C8(uint64_t *a1)
{
  uint64_t v2 = a1[2];
  uint64_t v3 = a1 + 2;
  if ((unint64_t)(a1[3] - v2) >> 3 <= 0x400)
  {
    sub_100069658((uint64_t)(a1 + 2), 0x401uLL);
    uint64_t v2 = *v3;
  }

  uint64_t v4 = *(void **)(v2 + 0x2000);
  if (!v4)
  {
    uint64_t v4 = operator new(0x40uLL);
    uint64_t v5 = *a1;
    *uint64_t v4 = off_1000D17E0;
    sub_10006A868(v4 + 1, v5);
    v4[7] = 0LL;
    *uint64_t v4 = off_1000D1788;
    uint64_t v6 = *(void *)(*v3 + 0x2000);
    *(void *)(*v3 + 0x200RDString::RDString((RDString *)&v66, theString, 0) = v4;
    if (v6) {
      (*(void (**)(uint64_t))(*(void *)v6 + 8LL))(v6);
    }
  }

  return v4;
}

void sub_10006A76C(_Unwind_Exception *a1)
{
}

void *sub_10006A780(void *a1)
{
  *a1 = off_1000D17E0;
  a1[1] = off_1000D1808;
  sub_10002B998(a1 + 4);
  return a1;
}

void sub_10006A7B8(uint64_t *a1)
{
  *a1 = (uint64_t)off_1000D17E0;
  a1[1] = (uint64_t)off_1000D1808;
  sub_10002B998(a1 + 4);
  operator delete(a1);
}

uint64_t sub_10006A7F0()
{
  return 1024LL;
}

void *sub_10006A7F8(void *a1)
{
  *a1 = off_1000D17E0;
  a1[1] = off_1000D1808;
  sub_10002B998(a1 + 4);
  return a1;
}

void sub_10006A830(uint64_t *a1)
{
  *a1 = (uint64_t)off_1000D17E0;
  a1[1] = (uint64_t)off_1000D1808;
  sub_10002B998(a1 + 4);
  operator delete(a1);
}

void *sub_10006A868(void *a1, uint64_t a2)
{
  *a1 = off_1000D1808;
  a1[1] = 1032 * a2;
  uint64_t v3 = a1 + 3;
  a1[2] = 0LL;
  a1[3] = a1 + 3;
  a1[4] = a1 + 3;
  a1[5] = 0LL;
  uint64_t v4 = operator new[](1032 * a2);
  uint64_t v5 = operator new(0x18uLL);
  v5[1] = v3;
  _OWORD v5[2] = v4;
  void *v5 = v3;
  a1[3] = v5;
  a1[4] = v5;
  a1[5] = 1LL;
  return a1;
}

void sub_10006A8D4(_Unwind_Exception *a1)
{
}

void *sub_10006A8E8(void *a1)
{
  *a1 = off_1000D1808;
  sub_10002B998(a1 + 3);
  return a1;
}

void sub_10006A918(uint64_t *a1)
{
  *a1 = (uint64_t)off_1000D1808;
  sub_10002B998(a1 + 3);
  operator delete(a1);
}

uint64_t sub_10006A948()
{
  return 1032LL;
}

void *sub_10006A950(uint64_t *a1)
{
  uint64_t v2 = a1[2];
  uint64_t v3 = a1 + 2;
  if ((unint64_t)(a1[3] - v2) <= 0x207)
  {
    sub_100069658((uint64_t)(a1 + 2), 0x41uLL);
    uint64_t v2 = *v3;
  }

  uint64_t v4 = *(void **)(v2 + 512);
  if (!v4)
  {
    uint64_t v4 = operator new(0x40uLL);
    uint64_t v5 = *a1;
    *uint64_t v4 = off_1000D14E0;
    sub_100069E50(v4 + 1, v5);
    v4[7] = 0LL;
    *uint64_t v4 = off_1000D1848;
    uint64_t v6 = *(void *)(*v3 + 512);
    *(void *)(*v3 + 512) = v4;
    if (v6) {
      (*(void (**)(uint64_t))(*(void *)v6 + 8LL))(v6);
    }
  }

  return v4;
}

void sub_10006A9F0(_Unwind_Exception *a1)
{
}

void *sub_10006AA04(void *a1)
{
  *a1 = off_1000D14E0;
  a1[1] = off_1000D1508;
  sub_10002B998(a1 + 4);
  return a1;
}

void sub_10006AA3C(uint64_t *a1)
{
  *a1 = (uint64_t)off_1000D14E0;
  a1[1] = (uint64_t)off_1000D1508;
  sub_10002B998(a1 + 4);
  operator delete(a1);
}

void *sub_10006AA74(uint64_t *a1)
{
  uint64_t v2 = a1[2];
  uint64_t v3 = a1 + 2;
  if ((unint64_t)(a1[3] - v2) <= 0x407)
  {
    sub_100069658((uint64_t)(a1 + 2), 0x81uLL);
    uint64_t v2 = *v3;
  }

  uint64_t v4 = *(void **)(v2 + 1024);
  if (!v4)
  {
    uint64_t v4 = operator new(0x40uLL);
    uint64_t v5 = *a1;
    *uint64_t v4 = off_1000D15A0;
    sub_10006A0D4(v4 + 1, v5);
    v4[7] = 0LL;
    *uint64_t v4 = off_1000D1888;
    uint64_t v6 = *(void *)(*v3 + 1024);
    *(void *)(*v3 + 10++*(void *)(result + 24) = v4;
    if (v6) {
      (*(void (**)(uint64_t))(*(void *)v6 + 8LL))(v6);
    }
  }

  return v4;
}

void sub_10006AB14(_Unwind_Exception *a1)
{
}

void *sub_10006AB28(void *a1)
{
  *a1 = off_1000D15A0;
  a1[1] = off_1000D15C8;
  sub_10002B998(a1 + 4);
  return a1;
}

void sub_10006AB60(uint64_t *a1)
{
  *a1 = (uint64_t)off_1000D15A0;
  a1[1] = (uint64_t)off_1000D15C8;
  sub_10002B998(a1 + 4);
  operator delete(a1);
}

void *sub_10006AB98(uint64_t *a1)
{
  uint64_t v2 = a1[2];
  uint64_t v3 = a1 + 2;
  if ((unint64_t)(a1[3] - v2) <= 0x807)
  {
    sub_100069658((uint64_t)(a1 + 2), 0x101uLL);
    uint64_t v2 = *v3;
  }

  uint64_t v4 = *(void **)(v2 + 2048);
  if (!v4)
  {
    uint64_t v4 = operator new(0x40uLL);
    uint64_t v5 = *a1;
    *uint64_t v4 = off_1000D1660;
    sub_10006A358(v4 + 1, v5);
    v4[7] = 0LL;
    *uint64_t v4 = off_1000D18C8;
    uint64_t v6 = *(void *)(*v3 + 2048);
    *(void *)(*v3 + 204std::istream::~istream(v2, v3 + 8) = v4;
    if (v6) {
      (*(void (**)(uint64_t))(*(void *)v6 + 8LL))(v6);
    }
  }

  return v4;
}

void sub_10006AC38(_Unwind_Exception *a1)
{
}

void *sub_10006AC4C(void *a1)
{
  *a1 = off_1000D1660;
  a1[1] = off_1000D1688;
  sub_10002B998(a1 + 4);
  return a1;
}

void sub_10006AC84(uint64_t *a1)
{
  *a1 = (uint64_t)off_1000D1660;
  a1[1] = (uint64_t)off_1000D1688;
  sub_10002B998(a1 + 4);
  operator delete(a1);
}

void *sub_10006ACBC(uint64_t *a1)
{
  uint64_t v2 = a1[2];
  uint64_t v3 = a1 + 2;
  if ((unint64_t)(a1[3] - v2) >> 3 <= 0x200)
  {
    sub_100069658((uint64_t)(a1 + 2), 0x201uLL);
    uint64_t v2 = *v3;
  }

  uint64_t v4 = *(void **)(v2 + 4096);
  if (!v4)
  {
    uint64_t v4 = operator new(0x40uLL);
    uint64_t v5 = *a1;
    *uint64_t v4 = off_1000D1720;
    sub_10006A5E0(v4 + 1, v5);
    v4[7] = 0LL;
    *uint64_t v4 = off_1000D1908;
    uint64_t v6 = *(void *)(*v3 + 4096);
    *(void *)(*v3 + 4096) = v4;
    if (v6) {
      (*(void (**)(uint64_t))(*(void *)v6 + 8LL))(v6);
    }
  }

  return v4;
}

void sub_10006AD60(_Unwind_Exception *a1)
{
}

void *sub_10006AD74(void *a1)
{
  *a1 = off_1000D1720;
  a1[1] = off_1000D1748;
  sub_10002B998(a1 + 4);
  return a1;
}

void sub_10006ADAC(uint64_t *a1)
{
  *a1 = (uint64_t)off_1000D1720;
  a1[1] = (uint64_t)off_1000D1748;
  sub_10002B998(a1 + 4);
  operator delete(a1);
}

void *sub_10006ADE4(uint64_t *a1)
{
  uint64_t v2 = a1[2];
  uint64_t v3 = a1 + 2;
  if ((unint64_t)(a1[3] - v2) >> 3 <= 0x400)
  {
    sub_100069658((uint64_t)(a1 + 2), 0x401uLL);
    uint64_t v2 = *v3;
  }

  uint64_t v4 = *(void **)(v2 + 0x2000);
  if (!v4)
  {
    uint64_t v4 = operator new(0x40uLL);
    uint64_t v5 = *a1;
    *uint64_t v4 = off_1000D17E0;
    sub_10006A868(v4 + 1, v5);
    v4[7] = 0LL;
    *uint64_t v4 = off_1000D1948;
    uint64_t v6 = *(void *)(*v3 + 0x2000);
    *(void *)(*v3 + 0x200RDString::RDString((RDString *)&v66, theString, 0) = v4;
    if (v6) {
      (*(void (**)(uint64_t))(*(void *)v6 + 8LL))(v6);
    }
  }

  return v4;
}

void sub_10006AE88(_Unwind_Exception *a1)
{
}

void *sub_10006AE9C(void *a1)
{
  *a1 = off_1000D17E0;
  a1[1] = off_1000D1808;
  sub_10002B998(a1 + 4);
  return a1;
}

void sub_10006AED4(uint64_t *a1)
{
  *a1 = (uint64_t)off_1000D17E0;
  a1[1] = (uint64_t)off_1000D1808;
  sub_10002B998(a1 + 4);
  operator delete(a1);
}

void *sub_10006AF0C(uint64_t *a1)
{
  uint64_t v2 = a1[2];
  uint64_t v3 = a1 + 2;
  if ((unint64_t)(a1[3] - v2) >> 3 <= 0x800)
  {
    sub_100069658((uint64_t)(a1 + 2), 0x801uLL);
    uint64_t v2 = *v3;
  }

  uint64_t v4 = *(void **)(v2 + 0x4000);
  if (!v4)
  {
    uint64_t v4 = operator new(0x40uLL);
    uint64_t v5 = *a1;
    *uint64_t v4 = off_1000D19E0;
    sub_10006B0AC(v4 + 1, v5);
    v4[7] = 0LL;
    *uint64_t v4 = off_1000D1988;
    uint64_t v6 = *(void *)(*v3 + 0x4000);
    *(void *)(*v3 + 0x400RDString::RDString((RDString *)&v66, theString, 0) = v4;
    if (v6) {
      (*(void (**)(uint64_t))(*(void *)v6 + 8LL))(v6);
    }
  }

  return v4;
}

void sub_10006AFB0(_Unwind_Exception *a1)
{
}

void *sub_10006AFC4(void *a1)
{
  *a1 = off_1000D19E0;
  a1[1] = off_1000D1A08;
  sub_10002B998(a1 + 4);
  return a1;
}

void sub_10006AFFC(uint64_t *a1)
{
  *a1 = (uint64_t)off_1000D19E0;
  a1[1] = (uint64_t)off_1000D1A08;
  sub_10002B998(a1 + 4);
  operator delete(a1);
}

uint64_t sub_10006B034()
{
  return 2048LL;
}

void *sub_10006B03C(void *a1)
{
  *a1 = off_1000D19E0;
  a1[1] = off_1000D1A08;
  sub_10002B998(a1 + 4);
  return a1;
}

void sub_10006B074(uint64_t *a1)
{
  *a1 = (uint64_t)off_1000D19E0;
  a1[1] = (uint64_t)off_1000D1A08;
  sub_10002B998(a1 + 4);
  operator delete(a1);
}

void *sub_10006B0AC(void *a1, uint64_t a2)
{
  *a1 = off_1000D1A08;
  a1[1] = 2056 * a2;
  uint64_t v3 = a1 + 3;
  a1[2] = 0LL;
  a1[3] = a1 + 3;
  a1[4] = a1 + 3;
  a1[5] = 0LL;
  uint64_t v4 = operator new[](2056 * a2);
  uint64_t v5 = operator new(0x18uLL);
  v5[1] = v3;
  _OWORD v5[2] = v4;
  void *v5 = v3;
  a1[3] = v5;
  a1[4] = v5;
  a1[5] = 1LL;
  return a1;
}

void sub_10006B118(_Unwind_Exception *a1)
{
}

void *sub_10006B12C(void *a1)
{
  *a1 = off_1000D1A08;
  sub_10002B998(a1 + 3);
  return a1;
}

void sub_10006B15C(uint64_t *a1)
{
  *a1 = (uint64_t)off_1000D1A08;
  sub_10002B998(a1 + 3);
  operator delete(a1);
}

uint64_t sub_10006B18C()
{
  return 2056LL;
}

void *sub_10006B194(uint64_t *a1)
{
  uint64_t v2 = a1[2];
  uint64_t v3 = a1 + 2;
  if ((unint64_t)(a1[3] - v2) <= 0x8007)
  {
    sub_100069658((uint64_t)(a1 + 2), 0x1001uLL);
    uint64_t v2 = *v3;
  }

  uint64_t v4 = *(void **)(v2 + 0x8000);
  if (!v4)
  {
    uint64_t v4 = operator new(0x40uLL);
    uint64_t v5 = *a1;
    *uint64_t v4 = off_1000D1AA0;
    sub_10006B33C(v4 + 1, v5);
    v4[7] = 0LL;
    *uint64_t v4 = off_1000D1A48;
    uint64_t v6 = *(void *)(*v3 + 0x8000);
    *(void *)(*v3 + 0x800RDString::RDString((RDString *)&v66, theString, 0) = v4;
    if (v6) {
      (*(void (**)(uint64_t))(*(void *)v6 + 8LL))(v6);
    }
  }

  return v4;
}

void sub_10006B240(_Unwind_Exception *a1)
{
}

void *sub_10006B254(void *a1)
{
  *a1 = off_1000D1AA0;
  a1[1] = off_1000D1AC8;
  sub_10002B998(a1 + 4);
  return a1;
}

void sub_10006B28C(uint64_t *a1)
{
  *a1 = (uint64_t)off_1000D1AA0;
  a1[1] = (uint64_t)off_1000D1AC8;
  sub_10002B998(a1 + 4);
  operator delete(a1);
}

uint64_t sub_10006B2C4()
{
  return 4096LL;
}

void *sub_10006B2CC(void *a1)
{
  *a1 = off_1000D1AA0;
  a1[1] = off_1000D1AC8;
  sub_10002B998(a1 + 4);
  return a1;
}

void sub_10006B304(uint64_t *a1)
{
  *a1 = (uint64_t)off_1000D1AA0;
  a1[1] = (uint64_t)off_1000D1AC8;
  sub_10002B998(a1 + 4);
  operator delete(a1);
}

void *sub_10006B33C(void *a1, uint64_t a2)
{
  *a1 = off_1000D1AC8;
  a1[1] = 4104 * a2;
  uint64_t v3 = a1 + 3;
  a1[2] = 0LL;
  a1[3] = a1 + 3;
  a1[4] = a1 + 3;
  a1[5] = 0LL;
  uint64_t v4 = operator new[](4104 * a2);
  uint64_t v5 = operator new(0x18uLL);
  v5[1] = v3;
  _OWORD v5[2] = v4;
  void *v5 = v3;
  a1[3] = v5;
  a1[4] = v5;
  a1[5] = 1LL;
  return a1;
}

void sub_10006B3A8(_Unwind_Exception *a1)
{
}

void *sub_10006B3BC(void *a1)
{
  *a1 = off_1000D1AC8;
  sub_10002B998(a1 + 3);
  return a1;
}

void sub_10006B3EC(uint64_t *a1)
{
  *a1 = (uint64_t)off_1000D1AC8;
  sub_10002B998(a1 + 3);
  operator delete(a1);
}

uint64_t sub_10006B41C()
{
  return 4104LL;
}

void *sub_10006B424(void *result)
{
  if (result[2])
  {
    uint64_t v1 = (uint64_t)result;
    uint64_t v3 = *result;
    uint64_t v2 = (uint64_t *)result[1];
    uint64_t v4 = *v2;
    *(void *)(v4 + std::istream::~istream(v2, v3 + 8) = *(void *)(*result + 8LL);
    **(void **)(v3 + std::istream::~istream(v2, v3 + 8) = v4;
    result[2] = 0LL;
    while (v2 != (uint64_t *)v1)
    {
      uint64_t v5 = (uint64_t *)v2[1];
      uint64_t result = sub_10006B484(v1, (uint64_t)v2);
      uint64_t v2 = v5;
    }
  }

  return result;
}

void *sub_10006B484(uint64_t a1, uint64_t a2)
{
  uint64_t result = sub_10006B5C8(*(uint64_t **)(a1 + 24));
  if (a2)
  {
    *(void *)(a2 + ++*(void *)(result + 24) = result[7];
    result[7] = a2;
  }

  return result;
}

void sub_10006B4BC(uint64_t **a1, void *__p, unint64_t a3)
{
  if (a3 == 2)
  {
    uint64_t v4 = sub_10006B848(*a1);
    if (!__p) {
      return;
    }
    __p[6] = v4[7];
    goto LABEL_22;
  }

  if (a3 == 1)
  {
    uint64_t v4 = sub_10006B5C8(*a1);
    if (!__p) {
      return;
    }
    std::string __p[3] = v4[7];
    goto LABEL_22;
  }

  if (a3 <= 4)
  {
    uint64_t v4 = sub_10006B96C(*a1);
    if (!__p) {
      return;
    }
    _BYTE __p[12] = v4[7];
    goto LABEL_22;
  }

  if (a3 <= 8)
  {
    uint64_t v4 = sub_10006BBF0(*a1);
    if (!__p) {
      return;
    }
    _BYTE __p[24] = v4[7];
    goto LABEL_22;
  }

  if (a3 <= 0x10)
  {
    uint64_t v4 = sub_10006BE74(*a1);
    if (!__p) {
      return;
    }
    __p[48] = v4[7];
    goto LABEL_22;
  }

  if (a3 <= 0x20)
  {
    uint64_t v4 = sub_10006C0F8(*a1);
    if (!__p) {
      return;
    }
    __p[96] = v4[7];
    goto LABEL_22;
  }

  if (a3 > 0x40)
  {
    operator delete(__p);
    return;
  }

  uint64_t v4 = sub_10006C380(*a1);
  if (__p)
  {
    __p[192] = v4[7];
LABEL_22:
    v4[7] = __p;
  }

void *sub_10006B5C8(uint64_t *a1)
{
  uint64_t v2 = a1[2];
  uint64_t v3 = a1 + 2;
  if ((unint64_t)(a1[3] - v2) <= 0xC7)
  {
    sub_100069658((uint64_t)(a1 + 2), 0x19uLL);
    uint64_t v2 = *v3;
  }

  uint64_t v4 = *(void **)(v2 + 192);
  if (!v4)
  {
    uint64_t v4 = operator new(0x40uLL);
    uint64_t v5 = *a1;
    *uint64_t v4 = off_1000D1B60;
    sub_10006B764(v4 + 1, v5);
    v4[7] = 0LL;
    *uint64_t v4 = off_1000D1B08;
    uint64_t v6 = *(void *)(*v3 + 192);
    *(void *)(*v3 + 192) = v4;
    if (v6) {
      (*(void (**)(uint64_t))(*(void *)v6 + 8LL))(v6);
    }
  }

  return v4;
}

void sub_10006B668(_Unwind_Exception *a1)
{
}

void *sub_10006B67C(void *a1)
{
  *a1 = off_1000D1B60;
  a1[1] = off_1000D1B88;
  sub_10002B998(a1 + 4);
  return a1;
}

void sub_10006B6B4(uint64_t *a1)
{
  *a1 = (uint64_t)off_1000D1B60;
  a1[1] = (uint64_t)off_1000D1B88;
  sub_10002B998(a1 + 4);
  operator delete(a1);
}

uint64_t sub_10006B6EC()
{
  return 24LL;
}

void *sub_10006B6F4(void *a1)
{
  *a1 = off_1000D1B60;
  a1[1] = off_1000D1B88;
  sub_10002B998(a1 + 4);
  return a1;
}

void sub_10006B72C(uint64_t *a1)
{
  *a1 = (uint64_t)off_1000D1B60;
  a1[1] = (uint64_t)off_1000D1B88;
  sub_10002B998(a1 + 4);
  operator delete(a1);
}

void *sub_10006B764(void *a1, uint64_t a2)
{
  *a1 = off_1000D1B88;
  a1[1] = 32 * a2;
  uint64_t v3 = a1 + 3;
  a1[2] = 0LL;
  a1[3] = a1 + 3;
  a1[4] = a1 + 3;
  a1[5] = 0LL;
  uint64_t v4 = operator new[](32 * a2);
  uint64_t v5 = operator new(0x18uLL);
  v5[1] = v3;
  _OWORD v5[2] = v4;
  void *v5 = v3;
  a1[3] = v5;
  a1[4] = v5;
  a1[5] = 1LL;
  return a1;
}

void sub_10006B7CC(_Unwind_Exception *a1)
{
}

void *sub_10006B7E0(void *a1)
{
  *a1 = off_1000D1B88;
  sub_10002B998(a1 + 3);
  return a1;
}

void sub_10006B810(uint64_t *a1)
{
  *a1 = (uint64_t)off_1000D1B88;
  sub_10002B998(a1 + 3);
  operator delete(a1);
}

uint64_t sub_10006B840()
{
  return 32LL;
}

void *sub_10006B848(uint64_t *a1)
{
  uint64_t v2 = a1[2];
  uint64_t v3 = a1 + 2;
  if ((unint64_t)(a1[3] - v2) <= 0x187)
  {
    sub_100069658((uint64_t)(a1 + 2), 0x31uLL);
    uint64_t v2 = *v3;
  }

  uint64_t v4 = *(void **)(v2 + 384);
  if (!v4)
  {
    uint64_t v4 = operator new(0x40uLL);
    uint64_t v5 = *a1;
    *uint64_t v4 = off_1000D0BA0;
    sub_10002B8A4(v4 + 1, v5);
    v4[7] = 0LL;
    *uint64_t v4 = off_1000D1BC8;
    uint64_t v6 = *(void *)(*v3 + 384);
    *(void *)(*v3 + 384) = v4;
    if (v6) {
      (*(void (**)(uint64_t))(*(void *)v6 + 8LL))(v6);
    }
  }

  return v4;
}

void sub_10006B8E8(_Unwind_Exception *a1)
{
}

void *sub_10006B8FC(void *a1)
{
  *a1 = off_1000D0BA0;
  a1[1] = off_1000D0BC8;
  sub_10002B998(a1 + 4);
  return a1;
}

void sub_10006B934(uint64_t *a1)
{
  *a1 = (uint64_t)off_1000D0BA0;
  a1[1] = (uint64_t)off_1000D0BC8;
  sub_10002B998(a1 + 4);
  operator delete(a1);
}

void *sub_10006B96C(uint64_t *a1)
{
  uint64_t v2 = a1[2];
  uint64_t v3 = a1 + 2;
  if ((unint64_t)(a1[3] - v2) <= 0x307)
  {
    sub_100069658((uint64_t)(a1 + 2), 0x61uLL);
    uint64_t v2 = *v3;
  }

  uint64_t v4 = *(void **)(v2 + 768);
  if (!v4)
  {
    uint64_t v4 = operator new(0x40uLL);
    uint64_t v5 = *a1;
    *uint64_t v4 = off_1000D1C60;
    sub_10006BB08(v4 + 1, v5);
    v4[7] = 0LL;
    *uint64_t v4 = off_1000D1C08;
    uint64_t v6 = *(void *)(*v3 + 768);
    *(void *)(*v3 + 76std::istream::~istream(v2, v3 + 8) = v4;
    if (v6) {
      (*(void (**)(uint64_t))(*(void *)v6 + 8LL))(v6);
    }
  }

  return v4;
}

void sub_10006BA0C(_Unwind_Exception *a1)
{
}

void *sub_10006BA20(void *a1)
{
  *a1 = off_1000D1C60;
  a1[1] = off_1000D1C88;
  sub_10002B998(a1 + 4);
  return a1;
}

void sub_10006BA58(uint64_t *a1)
{
  *a1 = (uint64_t)off_1000D1C60;
  a1[1] = (uint64_t)off_1000D1C88;
  sub_10002B998(a1 + 4);
  operator delete(a1);
}

uint64_t sub_10006BA90()
{
  return 96LL;
}

void *sub_10006BA98(void *a1)
{
  *a1 = off_1000D1C60;
  a1[1] = off_1000D1C88;
  sub_10002B998(a1 + 4);
  return a1;
}

void sub_10006BAD0(uint64_t *a1)
{
  *a1 = (uint64_t)off_1000D1C60;
  a1[1] = (uint64_t)off_1000D1C88;
  sub_10002B998(a1 + 4);
  operator delete(a1);
}

void *sub_10006BB08(void *a1, uint64_t a2)
{
  *a1 = off_1000D1C88;
  a1[1] = 104 * a2;
  uint64_t v3 = a1 + 3;
  a1[2] = 0LL;
  a1[3] = a1 + 3;
  a1[4] = a1 + 3;
  a1[5] = 0LL;
  uint64_t v4 = operator new[](104 * a2);
  uint64_t v5 = operator new(0x18uLL);
  v5[1] = v3;
  _OWORD v5[2] = v4;
  void *v5 = v3;
  a1[3] = v5;
  a1[4] = v5;
  a1[5] = 1LL;
  return a1;
}

void sub_10006BB74(_Unwind_Exception *a1)
{
}

void *sub_10006BB88(void *a1)
{
  *a1 = off_1000D1C88;
  sub_10002B998(a1 + 3);
  return a1;
}

void sub_10006BBB8(uint64_t *a1)
{
  *a1 = (uint64_t)off_1000D1C88;
  sub_10002B998(a1 + 3);
  operator delete(a1);
}

uint64_t sub_10006BBE8()
{
  return 104LL;
}

void *sub_10006BBF0(uint64_t *a1)
{
  uint64_t v2 = a1[2];
  uint64_t v3 = a1 + 2;
  if ((unint64_t)(a1[3] - v2) <= 0x607)
  {
    sub_100069658((uint64_t)(a1 + 2), 0xC1uLL);
    uint64_t v2 = *v3;
  }

  uint64_t v4 = *(void **)(v2 + 1536);
  if (!v4)
  {
    uint64_t v4 = operator new(0x40uLL);
    uint64_t v5 = *a1;
    *uint64_t v4 = off_1000D1D20;
    sub_10006BD8C(v4 + 1, v5);
    v4[7] = 0LL;
    *uint64_t v4 = off_1000D1CC8;
    uint64_t v6 = *(void *)(*v3 + 1536);
    *(void *)(*v3 + 1536) = v4;
    if (v6) {
      (*(void (**)(uint64_t))(*(void *)v6 + 8LL))(v6);
    }
  }

  return v4;
}

void sub_10006BC90(_Unwind_Exception *a1)
{
}

void *sub_10006BCA4(void *a1)
{
  *a1 = off_1000D1D20;
  a1[1] = off_1000D1D48;
  sub_10002B998(a1 + 4);
  return a1;
}

void sub_10006BCDC(uint64_t *a1)
{
  *a1 = (uint64_t)off_1000D1D20;
  a1[1] = (uint64_t)off_1000D1D48;
  sub_10002B998(a1 + 4);
  operator delete(a1);
}

uint64_t sub_10006BD14()
{
  return 192LL;
}

void *sub_10006BD1C(void *a1)
{
  *a1 = off_1000D1D20;
  a1[1] = off_1000D1D48;
  sub_10002B998(a1 + 4);
  return a1;
}

void sub_10006BD54(uint64_t *a1)
{
  *a1 = (uint64_t)off_1000D1D20;
  a1[1] = (uint64_t)off_1000D1D48;
  sub_10002B998(a1 + 4);
  operator delete(a1);
}

void *sub_10006BD8C(void *a1, uint64_t a2)
{
  *a1 = off_1000D1D48;
  a1[1] = 200 * a2;
  uint64_t v3 = a1 + 3;
  a1[2] = 0LL;
  a1[3] = a1 + 3;
  a1[4] = a1 + 3;
  a1[5] = 0LL;
  uint64_t v4 = operator new[](200 * a2);
  uint64_t v5 = operator new(0x18uLL);
  v5[1] = v3;
  _OWORD v5[2] = v4;
  void *v5 = v3;
  a1[3] = v5;
  a1[4] = v5;
  a1[5] = 1LL;
  return a1;
}

void sub_10006BDF8(_Unwind_Exception *a1)
{
}

void *sub_10006BE0C(void *a1)
{
  *a1 = off_1000D1D48;
  sub_10002B998(a1 + 3);
  return a1;
}

void sub_10006BE3C(uint64_t *a1)
{
  *a1 = (uint64_t)off_1000D1D48;
  sub_10002B998(a1 + 3);
  operator delete(a1);
}

uint64_t sub_10006BE6C()
{
  return 200LL;
}

void *sub_10006BE74(uint64_t *a1)
{
  uint64_t v2 = a1[2];
  uint64_t v3 = a1 + 2;
  if ((unint64_t)(a1[3] - v2) <= 0xC07)
  {
    sub_100069658((uint64_t)(a1 + 2), 0x181uLL);
    uint64_t v2 = *v3;
  }

  uint64_t v4 = *(void **)(v2 + 3072);
  if (!v4)
  {
    uint64_t v4 = operator new(0x40uLL);
    uint64_t v5 = *a1;
    *uint64_t v4 = off_1000D1DE0;
    sub_10006C010(v4 + 1, v5);
    v4[7] = 0LL;
    *uint64_t v4 = off_1000D1D88;
    uint64_t v6 = *(void *)(*v3 + 3072);
    *(void *)(*v3 + 30sub_10001A760(v25 - 72) = v4;
    if (v6) {
      (*(void (**)(uint64_t))(*(void *)v6 + 8LL))(v6);
    }
  }

  return v4;
}

void sub_10006BF14(_Unwind_Exception *a1)
{
}

void *sub_10006BF28(void *a1)
{
  *a1 = off_1000D1DE0;
  a1[1] = off_1000D1E08;
  sub_10002B998(a1 + 4);
  return a1;
}

void sub_10006BF60(uint64_t *a1)
{
  *a1 = (uint64_t)off_1000D1DE0;
  a1[1] = (uint64_t)off_1000D1E08;
  sub_10002B998(a1 + 4);
  operator delete(a1);
}

uint64_t sub_10006BF98()
{
  return 384LL;
}

void *sub_10006BFA0(void *a1)
{
  *a1 = off_1000D1DE0;
  a1[1] = off_1000D1E08;
  sub_10002B998(a1 + 4);
  return a1;
}

void sub_10006BFD8(uint64_t *a1)
{
  *a1 = (uint64_t)off_1000D1DE0;
  a1[1] = (uint64_t)off_1000D1E08;
  sub_10002B998(a1 + 4);
  operator delete(a1);
}

void *sub_10006C010(void *a1, uint64_t a2)
{
  *a1 = off_1000D1E08;
  a1[1] = 392 * a2;
  uint64_t v3 = a1 + 3;
  a1[2] = 0LL;
  a1[3] = a1 + 3;
  a1[4] = a1 + 3;
  a1[5] = 0LL;
  uint64_t v4 = operator new[](392 * a2);
  uint64_t v5 = operator new(0x18uLL);
  v5[1] = v3;
  _OWORD v5[2] = v4;
  void *v5 = v3;
  a1[3] = v5;
  a1[4] = v5;
  a1[5] = 1LL;
  return a1;
}

void sub_10006C07C(_Unwind_Exception *a1)
{
}

void *sub_10006C090(void *a1)
{
  *a1 = off_1000D1E08;
  sub_10002B998(a1 + 3);
  return a1;
}

void sub_10006C0C0(uint64_t *a1)
{
  *a1 = (uint64_t)off_1000D1E08;
  sub_10002B998(a1 + 3);
  operator delete(a1);
}

uint64_t sub_10006C0F0()
{
  return 392LL;
}

void *sub_10006C0F8(uint64_t *a1)
{
  uint64_t v2 = a1[2];
  uint64_t v3 = a1 + 2;
  if ((unint64_t)(a1[3] - v2) >> 3 <= 0x300)
  {
    sub_100069658((uint64_t)(a1 + 2), 0x301uLL);
    uint64_t v2 = *v3;
  }

  uint64_t v4 = *(void **)(v2 + 6144);
  if (!v4)
  {
    uint64_t v4 = operator new(0x40uLL);
    uint64_t v5 = *a1;
    *uint64_t v4 = off_1000D1EA0;
    sub_10006C298(v4 + 1, v5);
    v4[7] = 0LL;
    *uint64_t v4 = off_1000D1E48;
    uint64_t v6 = *(void *)(*v3 + 6144);
    *(void *)(*v3 + 6144) = v4;
    if (v6) {
      (*(void (**)(uint64_t))(*(void *)v6 + 8LL))(v6);
    }
  }

  return v4;
}

void sub_10006C19C(_Unwind_Exception *a1)
{
}

void *sub_10006C1B0(void *a1)
{
  *a1 = off_1000D1EA0;
  a1[1] = off_1000D1EC8;
  sub_10002B998(a1 + 4);
  return a1;
}

void sub_10006C1E8(uint64_t *a1)
{
  *a1 = (uint64_t)off_1000D1EA0;
  a1[1] = (uint64_t)off_1000D1EC8;
  sub_10002B998(a1 + 4);
  operator delete(a1);
}

uint64_t sub_10006C220()
{
  return 768LL;
}

void *sub_10006C228(void *a1)
{
  *a1 = off_1000D1EA0;
  a1[1] = off_1000D1EC8;
  sub_10002B998(a1 + 4);
  return a1;
}

void sub_10006C260(uint64_t *a1)
{
  *a1 = (uint64_t)off_1000D1EA0;
  a1[1] = (uint64_t)off_1000D1EC8;
  sub_10002B998(a1 + 4);
  operator delete(a1);
}

void *sub_10006C298(void *a1, uint64_t a2)
{
  *a1 = off_1000D1EC8;
  a1[1] = 776 * a2;
  uint64_t v3 = a1 + 3;
  a1[2] = 0LL;
  a1[3] = a1 + 3;
  a1[4] = a1 + 3;
  a1[5] = 0LL;
  uint64_t v4 = operator new[](776 * a2);
  uint64_t v5 = operator new(0x18uLL);
  v5[1] = v3;
  _OWORD v5[2] = v4;
  void *v5 = v3;
  a1[3] = v5;
  a1[4] = v5;
  a1[5] = 1LL;
  return a1;
}

void sub_10006C304(_Unwind_Exception *a1)
{
}

void *sub_10006C318(void *a1)
{
  *a1 = off_1000D1EC8;
  sub_10002B998(a1 + 3);
  return a1;
}

void sub_10006C348(uint64_t *a1)
{
  *a1 = (uint64_t)off_1000D1EC8;
  sub_10002B998(a1 + 3);
  operator delete(a1);
}

uint64_t sub_10006C378()
{
  return 776LL;
}

void *sub_10006C380(uint64_t *a1)
{
  uint64_t v2 = a1[2];
  uint64_t v3 = a1 + 2;
  if ((unint64_t)(a1[3] - v2) >> 3 <= 0x600)
  {
    sub_100069658((uint64_t)(a1 + 2), 0x601uLL);
    uint64_t v2 = *v3;
  }

  uint64_t v4 = *(void **)(v2 + 12288);
  if (!v4)
  {
    uint64_t v4 = operator new(0x40uLL);
    uint64_t v5 = *a1;
    *uint64_t v4 = off_1000D1F60;
    sub_10006C520(v4 + 1, v5);
    v4[7] = 0LL;
    *uint64_t v4 = off_1000D1F08;
    uint64_t v6 = *(void *)(*v3 + 12288);
    *(void *)(*v3 + 1228std::istream::~istream(v2, v3 + 8) = v4;
    if (v6) {
      (*(void (**)(uint64_t))(*(void *)v6 + 8LL))(v6);
    }
  }

  return v4;
}

void sub_10006C424(_Unwind_Exception *a1)
{
}

void *sub_10006C438(void *a1)
{
  *a1 = off_1000D1F60;
  a1[1] = off_1000D1F88;
  sub_10002B998(a1 + 4);
  return a1;
}

void sub_10006C470(uint64_t *a1)
{
  *a1 = (uint64_t)off_1000D1F60;
  a1[1] = (uint64_t)off_1000D1F88;
  sub_10002B998(a1 + 4);
  operator delete(a1);
}

uint64_t sub_10006C4A8()
{
  return 1536LL;
}

void *sub_10006C4B0(void *a1)
{
  *a1 = off_1000D1F60;
  a1[1] = off_1000D1F88;
  sub_10002B998(a1 + 4);
  return a1;
}

void sub_10006C4E8(uint64_t *a1)
{
  *a1 = (uint64_t)off_1000D1F60;
  a1[1] = (uint64_t)off_1000D1F88;
  sub_10002B998(a1 + 4);
  operator delete(a1);
}

void *sub_10006C520(void *a1, uint64_t a2)
{
  *a1 = off_1000D1F88;
  a1[1] = 1544 * a2;
  uint64_t v3 = a1 + 3;
  a1[2] = 0LL;
  a1[3] = a1 + 3;
  a1[4] = a1 + 3;
  a1[5] = 0LL;
  uint64_t v4 = operator new[](1544 * a2);
  uint64_t v5 = operator new(0x18uLL);
  v5[1] = v3;
  _OWORD v5[2] = v4;
  void *v5 = v3;
  a1[3] = v5;
  a1[4] = v5;
  a1[5] = 1LL;
  return a1;
}

void sub_10006C58C(_Unwind_Exception *a1)
{
}

void *sub_10006C5A0(void *a1)
{
  *a1 = off_1000D1F88;
  sub_10002B998(a1 + 3);
  return a1;
}

void sub_10006C5D0(uint64_t *a1)
{
  *a1 = (uint64_t)off_1000D1F88;
  sub_10002B998(a1 + 3);
  operator delete(a1);
}

uint64_t sub_10006C600()
{
  return 1544LL;
}

void ***sub_10006C608(void ***a1)
{
  uint64_t v2 = *a1;
  uint64_t v3 = (uint64_t)(*a1)[1] - 1;
  (*a1)[1] = (void *)v3;
  if (!v3)
  {
    uint64_t v5 = v2 + 2;
    sub_10006C65C(&v5);
    operator delete(v2);
  }

  return a1;
}

void sub_10006C65C(void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = **a1;
  if (v2)
  {
    uint64_t v4 = v1[1];
    uint64_t v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        uint64_t v7 = *--v4;
        uint64_t v6 = v7;
        *uint64_t v4 = 0LL;
        if (v7) {
          (*(void (**)(uint64_t))(*(void *)v6 + 8LL))(v6);
        }
      }

      while (v4 != v2);
      uint64_t v5 = **a1;
    }

    v1[1] = v2;
    operator delete(v5);
  }

uint64_t sub_10006C6D8(uint64_t a1)
{
  *(void *)a1 = off_1000D12D8;
  if (*(_BYTE *)(a1 + 129))
  {
    uint64_t v2 = *(void *)(a1 + 120);
    if (v2)
    {
      uint64_t v3 = (void *)sub_10006C728(v2);
      operator delete(v3);
    }
  }

  uint64_t v4 = *(void **)(a1 + 72);
  if (v4) {
    operator delete(v4);
  }
  return sub_10002D2D8(a1);
}

uint64_t sub_10006C728(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 8);
  if (v2)
  {
    *(void *)(a1 + 16) = v2;
    operator delete(v2);
  }

  return a1;
}

uint64_t sub_10006C780(uint64_t a1, uint64_t a2, uint64_t a3, void *a4, void *a5)
{
  uint64_t v6 = a4;
  if (!a4)
  {
    uint64_t v6 = operator new(0x48uLL);
    sub_100065248(v6, a2, 2, -3, -2, -1, 0LL);
  }

  *(void *)a1 = v6;
  if (!a5)
  {
    a5 = operator new(0x48uLL);
    sub_100065248(a5, a3, 1, -3, -2, -1, 0LL);
    uint64_t v6 = *(void **)a1;
  }

  *(void *)(a1 + std::istream::~istream(v2, v3 + 8) = a5;
  *(void *)(a1 + 16) = (*(uint64_t (**)(void *))(*v6 + 72LL))(v6);
  *(void *)(a1 + ++*(void *)(result + 24) = -1LL;
  *(_BYTE *)(a1 + 32) = -1;
  return a1;
}

void sub_10006C840(_Unwind_Exception *a1)
{
  uint64_t v4 = *v1;
  uint64_t *v1 = 0LL;
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 8LL))(v4);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_10006C8A4(uint64_t a1, size_t a2, void *a3, void *a4)
{
  if (!a3) {
    a3 = operator new(1uLL);
  }
  *(void *)a1 = a3;
  if (!a4) {
    a4 = operator new(1uLL);
  }
  *(void *)(a1 + std::istream::~istream(v2, v3 + 8) = a4;
  *(void *)(a1 + 16) = a1;
  *(void *)(a1 + ++*(void *)(result + 24) = a1;
  sub_10006CA58(a1 + 32, a2, (void *)(a1 + 16), (void *)(a1 + 24));
  *(void *)(a1 + 104) = 0LL;
  *(void *)(a1 + 112) = 0LL;
  *(void *)(a1 + 12RDString::RDString((RDString *)&v66, theString, 0) = 0LL;
  if (a2) {
    sub_10006C988((char **)(a1 + 104), a2);
  }
  return a1;
}

void sub_10006C934(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *v1;
  uint64_t *v1 = 0LL;
  if (v3) {
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void sub_10006C988(char **a1, unint64_t a2)
{
  uint64_t v4 = a1[2];
  uint64_t v3 = (uint64_t)(a1 + 2);
  if (0xAAAAAAAAAAAAAAABLL * ((v4 - *a1) >> 2) < a2)
  {
    if (a2 >= 0x1555555555555556LL) {
      sub_100018774();
    }
    uint64_t v5 = (a1[1] - *a1) / 12;
    uint64_t v6 = (char *)sub_10006E818(v3, a2);
    uint64_t v7 = &v6[12 * v5];
    uint64_t v9 = &v6[12 * v8];
    uint64_t v11 = *a1;
    unint64_t v10 = a1[1];
    uint64_t v12 = v7;
    if (v10 != *a1)
    {
      do
      {
        uint64_t v13 = *(void *)(v10 - 12);
        v10 -= 12;
        int v14 = *((_DWORD *)v10 + 2);
        *(void *)(v12 - 12) = v13;
        v12 -= 12;
        *((_DWORD *)v12 + 2) = v14;
      }

      while (v10 != v11);
      unint64_t v10 = *a1;
    }

    *a1 = v12;
    a1[1] = v7;
    a1[2] = v9;
    if (v10) {
      operator delete(v10);
    }
  }

uint64_t sub_10006CA58(uint64_t a1, size_t a2, void *a3, void *a4)
{
  uint64_t v8 = (void **)operator new(0x28uLL);
  void v8[3] = 0LL;
  v8[4] = 0LL;
  v8[2] = 0LL;
  *(void *)a1 = 0LL;
  *(void *)(a1 + std::istream::~istream(v2, v3 + 8) = 0LL;
  *(void *)(a1 + 16) = v8;
  *(_OWORD *)uint64_t v8 = xmmword_1000AC980;
  uint64_t v11 = v8;
  sub_10006C608(&v11);
  *(void *)(a1 + ++*(void *)(result + 24) = 0LL;
  uint64_t v9 = operator new(0x28uLL);
  *(_OWORD *)uint64_t v9 = xmmword_1000AC970;
  v9[3] = 0LL;
  v9[4] = 0LL;
  v9[2] = 0LL;
  *(void *)(a1 + 32) = v9;
  *(void *)(a1 + 4RDString::RDString((RDString *)&v66, theString, 0) = 0LL;
  *(void *)(a1 + 4std::istream::~istream(v2, v3 + 8) = *a3;
  *(_DWORD *)(a1 + ++*(void *)(result + 56) = 1065353216;
  *(void *)(a1 + 64) = *a4;
  sub_10006D600(a1, a2);
  return a1;
}

void sub_10006CB1C(_Unwind_Exception *a1)
{
}

uint64_t sub_10006CB40(uint64_t a1)
{
  uint64_t v2 = *(void **)a1;
  *(void *)a1 = 0LL;
  if (v2) {
    sub_10006CB7C(a1 + 8, v2);
  }
  sub_10006C608((void ***)(a1 + 16));
  return a1;
}

void sub_10006CB7C(uint64_t a1, void *a2)
{
}

void sub_10006CB98(uint64_t **a1, void *__p, unint64_t a3)
{
  if (a3 == 2)
  {
    uint64_t v4 = sub_10006CF24(*a1);
    if (!__p) {
      return;
    }
    std::string __p[2] = v4[7];
    goto LABEL_22;
  }

  if (a3 == 1)
  {
    uint64_t v4 = sub_10006CCA4(*a1);
    if (!__p) {
      return;
    }
    __p[1] = v4[7];
    goto LABEL_22;
  }

  if (a3 <= 4)
  {
    uint64_t v4 = sub_10006D048(*a1);
    if (!__p) {
      return;
    }
    __p[4] = v4[7];
    goto LABEL_22;
  }

  if (a3 <= 8)
  {
    uint64_t v4 = sub_10006D16C(*a1);
    if (!__p) {
      return;
    }
    __p[8] = v4[7];
    goto LABEL_22;
  }

  if (a3 <= 0x10)
  {
    uint64_t v4 = sub_10006D290(*a1);
    if (!__p) {
      return;
    }
    __p[16] = v4[7];
    goto LABEL_22;
  }

  if (a3 <= 0x20)
  {
    uint64_t v4 = sub_10006D3B4(*a1);
    if (!__p) {
      return;
    }
    __p[32] = v4[7];
    goto LABEL_22;
  }

  if (a3 > 0x40)
  {
    operator delete(__p);
    return;
  }

  uint64_t v4 = sub_10006D4D8(*a1);
  if (__p)
  {
    __p[64] = v4[7];
LABEL_22:
    v4[7] = __p;
  }

void *sub_10006CCA4(uint64_t *a1)
{
  uint64_t v2 = a1[2];
  uint64_t v3 = a1 + 2;
  if ((unint64_t)(a1[3] - v2) <= 0x47)
  {
    sub_100069658((uint64_t)(a1 + 2), 9uLL);
    uint64_t v2 = *v3;
  }

  uint64_t v4 = *(void **)(v2 + 64);
  if (!v4)
  {
    uint64_t v4 = operator new(0x40uLL);
    uint64_t v5 = *a1;
    *uint64_t v4 = off_1000D2020;
    sub_10006CE40(v4 + 1, v5);
    v4[7] = 0LL;
    *uint64_t v4 = off_1000D1FC8;
    uint64_t v6 = *(void *)(*v3 + 64);
    *(void *)(*v3 + 64) = v4;
    if (v6) {
      (*(void (**)(uint64_t))(*(void *)v6 + 8LL))(v6);
    }
  }

  return v4;
}

void sub_10006CD44(_Unwind_Exception *a1)
{
}

void *sub_10006CD58(void *a1)
{
  *a1 = off_1000D2020;
  a1[1] = off_1000D2048;
  sub_10002B998(a1 + 4);
  return a1;
}

void sub_10006CD90(uint64_t *a1)
{
  *a1 = (uint64_t)off_1000D2020;
  a1[1] = (uint64_t)off_1000D2048;
  sub_10002B998(a1 + 4);
  operator delete(a1);
}

uint64_t sub_10006CDC8()
{
  return 8LL;
}

void *sub_10006CDD0(void *a1)
{
  *a1 = off_1000D2020;
  a1[1] = off_1000D2048;
  sub_10002B998(a1 + 4);
  return a1;
}

void sub_10006CE08(uint64_t *a1)
{
  *a1 = (uint64_t)off_1000D2020;
  a1[1] = (uint64_t)off_1000D2048;
  sub_10002B998(a1 + 4);
  operator delete(a1);
}

void *sub_10006CE40(void *a1, uint64_t a2)
{
  *a1 = off_1000D2048;
  a1[1] = 16 * a2;
  uint64_t v3 = a1 + 3;
  a1[2] = 0LL;
  a1[3] = a1 + 3;
  a1[4] = a1 + 3;
  a1[5] = 0LL;
  uint64_t v4 = operator new[](16 * a2);
  uint64_t v5 = operator new(0x18uLL);
  v5[1] = v3;
  _OWORD v5[2] = v4;
  void *v5 = v3;
  a1[3] = v5;
  a1[4] = v5;
  a1[5] = 1LL;
  return a1;
}

void sub_10006CEA8(_Unwind_Exception *a1)
{
}

void *sub_10006CEBC(void *a1)
{
  *a1 = off_1000D2048;
  sub_10002B998(a1 + 3);
  return a1;
}

void sub_10006CEEC(uint64_t *a1)
{
  *a1 = (uint64_t)off_1000D2048;
  sub_10002B998(a1 + 3);
  operator delete(a1);
}

uint64_t sub_10006CF1C()
{
  return 16LL;
}

void *sub_10006CF24(uint64_t *a1)
{
  uint64_t v2 = a1[2];
  uint64_t v3 = a1 + 2;
  if ((unint64_t)(a1[3] - v2) <= 0x87)
  {
    sub_100069658((uint64_t)(a1 + 2), 0x11uLL);
    uint64_t v2 = *v3;
  }

  uint64_t v4 = *(void **)(v2 + 128);
  if (!v4)
  {
    uint64_t v4 = operator new(0x40uLL);
    uint64_t v5 = *a1;
    *uint64_t v4 = off_1000D1360;
    sub_100069948(v4 + 1, v5);
    v4[7] = 0LL;
    *uint64_t v4 = off_1000D2088;
    uint64_t v6 = *(void *)(*v3 + 128);
    *(void *)(*v3 + 12std::istream::~istream(v2, v3 + 8) = v4;
    if (v6) {
      (*(void (**)(uint64_t))(*(void *)v6 + 8LL))(v6);
    }
  }

  return v4;
}

void sub_10006CFC4(_Unwind_Exception *a1)
{
}

void *sub_10006CFD8(void *a1)
{
  *a1 = off_1000D1360;
  a1[1] = off_1000D1388;
  sub_10002B998(a1 + 4);
  return a1;
}

void sub_10006D010(uint64_t *a1)
{
  *a1 = (uint64_t)off_1000D1360;
  a1[1] = (uint64_t)off_1000D1388;
  sub_10002B998(a1 + 4);
  operator delete(a1);
}

void *sub_10006D048(uint64_t *a1)
{
  uint64_t v2 = a1[2];
  uint64_t v3 = a1 + 2;
  if ((unint64_t)(a1[3] - v2) <= 0x107)
  {
    sub_100069658((uint64_t)(a1 + 2), 0x21uLL);
    uint64_t v2 = *v3;
  }

  uint64_t v4 = *(void **)(v2 + 256);
  if (!v4)
  {
    uint64_t v4 = operator new(0x40uLL);
    uint64_t v5 = *a1;
    *uint64_t v4 = off_1000D1420;
    sub_100069BCC(v4 + 1, v5);
    v4[7] = 0LL;
    *uint64_t v4 = off_1000D20C8;
    uint64_t v6 = *(void *)(*v3 + 256);
    *(void *)(*v3 + 2++*(void *)(result + 56) = v4;
    if (v6) {
      (*(void (**)(uint64_t))(*(void *)v6 + 8LL))(v6);
    }
  }

  return v4;
}

void sub_10006D0E8(_Unwind_Exception *a1)
{
}

void *sub_10006D0FC(void *a1)
{
  *a1 = off_1000D1420;
  a1[1] = off_1000D1448;
  sub_10002B998(a1 + 4);
  return a1;
}

void sub_10006D134(uint64_t *a1)
{
  *a1 = (uint64_t)off_1000D1420;
  a1[1] = (uint64_t)off_1000D1448;
  sub_10002B998(a1 + 4);
  operator delete(a1);
}

void *sub_10006D16C(uint64_t *a1)
{
  uint64_t v2 = a1[2];
  uint64_t v3 = a1 + 2;
  if ((unint64_t)(a1[3] - v2) <= 0x207)
  {
    sub_100069658((uint64_t)(a1 + 2), 0x41uLL);
    uint64_t v2 = *v3;
  }

  uint64_t v4 = *(void **)(v2 + 512);
  if (!v4)
  {
    uint64_t v4 = operator new(0x40uLL);
    uint64_t v5 = *a1;
    *uint64_t v4 = off_1000D14E0;
    sub_100069E50(v4 + 1, v5);
    v4[7] = 0LL;
    *uint64_t v4 = off_1000D2108;
    uint64_t v6 = *(void *)(*v3 + 512);
    *(void *)(*v3 + 512) = v4;
    if (v6) {
      (*(void (**)(uint64_t))(*(void *)v6 + 8LL))(v6);
    }
  }

  return v4;
}

void sub_10006D20C(_Unwind_Exception *a1)
{
}

void *sub_10006D220(void *a1)
{
  *a1 = off_1000D14E0;
  a1[1] = off_1000D1508;
  sub_10002B998(a1 + 4);
  return a1;
}

void sub_10006D258(uint64_t *a1)
{
  *a1 = (uint64_t)off_1000D14E0;
  a1[1] = (uint64_t)off_1000D1508;
  sub_10002B998(a1 + 4);
  operator delete(a1);
}

void *sub_10006D290(uint64_t *a1)
{
  uint64_t v2 = a1[2];
  uint64_t v3 = a1 + 2;
  if ((unint64_t)(a1[3] - v2) <= 0x407)
  {
    sub_100069658((uint64_t)(a1 + 2), 0x81uLL);
    uint64_t v2 = *v3;
  }

  uint64_t v4 = *(void **)(v2 + 1024);
  if (!v4)
  {
    uint64_t v4 = operator new(0x40uLL);
    uint64_t v5 = *a1;
    *uint64_t v4 = off_1000D15A0;
    sub_10006A0D4(v4 + 1, v5);
    v4[7] = 0LL;
    *uint64_t v4 = off_1000D2148;
    uint64_t v6 = *(void *)(*v3 + 1024);
    *(void *)(*v3 + 10++*(void *)(result + 24) = v4;
    if (v6) {
      (*(void (**)(uint64_t))(*(void *)v6 + 8LL))(v6);
    }
  }

  return v4;
}

void sub_10006D330(_Unwind_Exception *a1)
{
}

void *sub_10006D344(void *a1)
{
  *a1 = off_1000D15A0;
  a1[1] = off_1000D15C8;
  sub_10002B998(a1 + 4);
  return a1;
}

void sub_10006D37C(uint64_t *a1)
{
  *a1 = (uint64_t)off_1000D15A0;
  a1[1] = (uint64_t)off_1000D15C8;
  sub_10002B998(a1 + 4);
  operator delete(a1);
}

void *sub_10006D3B4(uint64_t *a1)
{
  uint64_t v2 = a1[2];
  uint64_t v3 = a1 + 2;
  if ((unint64_t)(a1[3] - v2) <= 0x807)
  {
    sub_100069658((uint64_t)(a1 + 2), 0x101uLL);
    uint64_t v2 = *v3;
  }

  uint64_t v4 = *(void **)(v2 + 2048);
  if (!v4)
  {
    uint64_t v4 = operator new(0x40uLL);
    uint64_t v5 = *a1;
    *uint64_t v4 = off_1000D1660;
    sub_10006A358(v4 + 1, v5);
    v4[7] = 0LL;
    *uint64_t v4 = off_1000D2188;
    uint64_t v6 = *(void *)(*v3 + 2048);
    *(void *)(*v3 + 204std::istream::~istream(v2, v3 + 8) = v4;
    if (v6) {
      (*(void (**)(uint64_t))(*(void *)v6 + 8LL))(v6);
    }
  }

  return v4;
}

void sub_10006D454(_Unwind_Exception *a1)
{
}

void *sub_10006D468(void *a1)
{
  *a1 = off_1000D1660;
  a1[1] = off_1000D1688;
  sub_10002B998(a1 + 4);
  return a1;
}

void sub_10006D4A0(uint64_t *a1)
{
  *a1 = (uint64_t)off_1000D1660;
  a1[1] = (uint64_t)off_1000D1688;
  sub_10002B998(a1 + 4);
  operator delete(a1);
}

void *sub_10006D4D8(uint64_t *a1)
{
  uint64_t v2 = a1[2];
  uint64_t v3 = a1 + 2;
  if ((unint64_t)(a1[3] - v2) >> 3 <= 0x200)
  {
    sub_100069658((uint64_t)(a1 + 2), 0x201uLL);
    uint64_t v2 = *v3;
  }

  uint64_t v4 = *(void **)(v2 + 4096);
  if (!v4)
  {
    uint64_t v4 = operator new(0x40uLL);
    uint64_t v5 = *a1;
    *uint64_t v4 = off_1000D1720;
    sub_10006A5E0(v4 + 1, v5);
    v4[7] = 0LL;
    *uint64_t v4 = off_1000D21C8;
    uint64_t v6 = *(void *)(*v3 + 4096);
    *(void *)(*v3 + 4096) = v4;
    if (v6) {
      (*(void (**)(uint64_t))(*(void *)v6 + 8LL))(v6);
    }
  }

  return v4;
}

void sub_10006D57C(_Unwind_Exception *a1)
{
}

void *sub_10006D590(void *a1)
{
  *a1 = off_1000D1720;
  a1[1] = off_1000D1748;
  sub_10002B998(a1 + 4);
  return a1;
}

void sub_10006D5C8(uint64_t *a1)
{
  *a1 = (uint64_t)off_1000D1720;
  a1[1] = (uint64_t)off_1000D1748;
  sub_10002B998(a1 + 4);
  operator delete(a1);
}

void sub_10006D600(uint64_t a1, size_t __n)
{
  if (__n == 1)
  {
    size_t prime = 2LL;
  }

  else
  {
    size_t prime = __n;
    if ((__n & (__n - 1)) != 0) {
      size_t prime = std::__next_prime(__n);
    }
  }

  int8x8_t v4 = *(int8x8_t *)(a1 + 8);
  if (prime > *(void *)&v4) {
    goto LABEL_16;
  }
  if (prime < *(void *)&v4)
  {
    unint64_t v5 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 40) / *(float *)(a1 + 56));
    if (*(void *)&v4 < 3uLL || (uint8x8_t v6 = (uint8x8_t)vcnt_s8(v4), v6.i16[0] = vaddlv_u8(v6), v6.u32[0] > 1uLL))
    {
      unint64_t v5 = std::__next_prime(v5);
    }

    else
    {
      uint64_t v7 = 1LL << -(char)__clz(v5 - 1);
      if (v5 >= 2) {
        unint64_t v5 = v7;
      }
    }

    if (prime <= v5) {
      size_t prime = v5;
    }
    if (prime < *(void *)&v4) {
LABEL_16:
    }
      sub_10006D6DC(a1, prime);
  }

void sub_10006D6DC(uint64_t a1, unint64_t a2)
{
  uint64_t v3 = (unint64_t *)(a1 + 8);
  if (a2)
  {
    unint64_t v5 = sub_10006D83C((uint64_t **)(a1 + 16), a2);
    uint8x8_t v6 = *(void **)a1;
    *(void *)a1 = v5;
    if (v6) {
      sub_10006CB7C((uint64_t)v3, v6);
    }
    uint64_t v7 = 0LL;
    *uint64_t v3 = a2;
    do
      *(void *)(*(void *)a1 + 8 * v7++) = 0LL;
    while (a2 != v7);
    uint64_t v8 = *(void **)(a1 + 24);
    if (v8)
    {
      unint64_t v9 = v8[1];
      uint8x8_t v10 = (uint8x8_t)vcnt_s8((int8x8_t)a2);
      v10.i16[0] = vaddlv_u8(v10);
      if (v10.u32[0] > 1uLL)
      {
        if (v9 >= a2) {
          v9 %= a2;
        }
      }

      else
      {
        v9 &= a2 - 1;
      }

      *(void *)(*(void *)a1 + 8 * v9) = a1 + 24;
      uint64_t v12 = (void *)*v8;
      if (*v8)
      {
        do
        {
          unint64_t v13 = v12[1];
          if (v10.u32[0] > 1uLL)
          {
            if (v13 >= a2) {
              v13 %= a2;
            }
          }

          else
          {
            v13 &= a2 - 1;
          }

          if (v13 != v9)
          {
            if (!*(void *)(*(void *)a1 + 8 * v13))
            {
              *(void *)(*(void *)a1 + 8 * v13) = v8;
              goto LABEL_23;
            }

            void *v8 = *v12;
            *uint64_t v12 = **(void **)(*(void *)a1 + 8 * v13);
            **(void **)(*(void *)a1 + 8 * v13) = v12;
            uint64_t v12 = v8;
          }

          unint64_t v13 = v9;
LABEL_23:
          uint64_t v8 = v12;
          uint64_t v12 = (void *)*v12;
          unint64_t v9 = v13;
        }

        while (v12);
      }
    }
  }

  else
  {
    uint64_t v11 = *(void **)a1;
    *(void *)a1 = 0LL;
    if (v11) {
      sub_10006CB7C(a1 + 8, v11);
    }
    *uint64_t v3 = 0LL;
  }

char *sub_10006D83C(uint64_t **a1, unint64_t a2)
{
  if (a2 == 2)
  {
    uint64_t v2 = sub_10006CF24(*a1);
    uint64_t result = (char *)v2[7];
    if (!result)
    {
      uint64_t result = sub_10006DAB4(v2 + 1, 1LL);
      *((void *)result + 2) = 0LL;
      return result;
    }

    uint64_t v4 = *((void *)result + 2);
    goto LABEL_26;
  }

  if (a2 == 1)
  {
    uint64_t v2 = sub_10006CCA4(*a1);
    uint64_t result = (char *)v2[7];
    if (!result)
    {
      uint64_t result = sub_10006D9EC(v2 + 1, 1LL);
      *((void *)result + 1) = 0LL;
      return result;
    }

    uint64_t v4 = *((void *)result + 1);
LABEL_26:
    v2[7] = v4;
    return result;
  }

  if (a2 <= 4)
  {
    uint64_t v2 = sub_10006D048(*a1);
    uint64_t result = (char *)v2[7];
    if (!result)
    {
      uint64_t result = sub_10006DB84(v2 + 1, 1LL);
      *((void *)result + 4) = 0LL;
      return result;
    }

    uint64_t v4 = *((void *)result + 4);
    goto LABEL_26;
  }

  if (a2 <= 8)
  {
    uint64_t v2 = sub_10006D16C(*a1);
    uint64_t result = (char *)v2[7];
    if (!result)
    {
      uint64_t result = sub_10006DC54(v2 + 1, 1LL);
      *((void *)result + std::istream::~istream(v2, v3 + 8) = 0LL;
      return result;
    }

    uint64_t v4 = *((void *)result + 8);
    goto LABEL_26;
  }

  if (a2 <= 0x10)
  {
    uint64_t v2 = sub_10006D290(*a1);
    uint64_t result = (char *)v2[7];
    if (!result)
    {
      uint64_t result = sub_10006DD24(v2 + 1, 1LL);
      *((void *)result + 16) = 0LL;
      return result;
    }

    uint64_t v4 = *((void *)result + 16);
    goto LABEL_26;
  }

  if (a2 <= 0x20)
  {
    uint64_t v2 = sub_10006D3B4(*a1);
    uint64_t result = (char *)v2[7];
    if (!result)
    {
      uint64_t result = sub_10006DDF4(v2 + 1, 1LL);
      *((void *)result + 32) = 0LL;
      return result;
    }

    uint64_t v4 = *((void *)result + 32);
    goto LABEL_26;
  }

  if (a2 <= 0x40)
  {
    uint64_t v2 = sub_10006D4D8(*a1);
    uint64_t result = (char *)v2[7];
    if (!result)
    {
      uint64_t result = sub_10006DEC4(v2 + 1, 1LL);
      *((void *)result + 64) = 0LL;
      return result;
    }

    uint64_t v4 = *((void *)result + 64);
    goto LABEL_26;
  }

  if (a2 >> 61) {
    sub_100017F08();
  }
  return (char *)operator new(8 * a2);
}

char *sub_10006D9EC(void *a1, uint64_t a2)
{
  uint64_t v2 = a1;
  uint64_t v3 = 16 * a2;
  size_t v4 = a1[1];
  if (v4 >= a2 << 6)
  {
    uint64_t v9 = v2[2];
    if (v9 + v3 <= v4)
    {
      uint8x8_t v10 = *(char **)(v2[4] + 16LL);
    }

    else
    {
      uint8x8_t v10 = (char *)operator new[](v4);
      v2[2] = 0LL;
      uint64_t v11 = operator new(0x18uLL);
      uint64_t v9 = 0LL;
      uint64_t v12 = (void *)v2[4];
      uint64_t v13 = v2[5];
      *uint64_t v11 = v2 + 3;
      v11[1] = v12;
      v11[2] = v10;
      *uint64_t v12 = v11;
      v2[4] = v11;
      void v2[5] = v13 + 1;
    }

    unint64_t v5 = &v10[v9];
    uint64_t v8 = v9 + v3;
  }

  else
  {
    unint64_t v5 = (char *)operator new[](16 * a2);
    uint8x8_t v6 = operator new(0x18uLL);
    uint64_t v7 = v2[3];
    v2 += 3;
    v6[1] = v2;
    _DWORD v6[2] = v5;
    void *v6 = v7;
    *(void *)(v7 + std::istream::~istream(v2, v3 + 8) = v6;
    void *v2 = v6;
    uint64_t v8 = v2[2] + 1LL;
  }

  v2[2] = v8;
  return v5;
}

char *sub_10006DAB4(void *a1, uint64_t a2)
{
  uint64_t v2 = a1;
  uint64_t v3 = 24 * a2;
  size_t v4 = a1[1];
  if (96 * a2 <= v4)
  {
    uint64_t v9 = v2[2];
    if (v9 + v3 <= v4)
    {
      uint8x8_t v10 = *(char **)(v2[4] + 16LL);
    }

    else
    {
      uint8x8_t v10 = (char *)operator new[](v4);
      v2[2] = 0LL;
      uint64_t v11 = operator new(0x18uLL);
      uint64_t v9 = 0LL;
      uint64_t v12 = (void *)v2[4];
      uint64_t v13 = v2[5];
      *uint64_t v11 = v2 + 3;
      v11[1] = v12;
      v11[2] = v10;
      *uint64_t v12 = v11;
      v2[4] = v11;
      void v2[5] = v13 + 1;
    }

    unint64_t v5 = &v10[v9];
    uint64_t v8 = v9 + v3;
  }

  else
  {
    unint64_t v5 = (char *)operator new[](24 * a2);
    uint8x8_t v6 = operator new(0x18uLL);
    uint64_t v7 = v2[3];
    v2 += 3;
    v6[1] = v2;
    _DWORD v6[2] = v5;
    void *v6 = v7;
    *(void *)(v7 + std::istream::~istream(v2, v3 + 8) = v6;
    void *v2 = v6;
    uint64_t v8 = v2[2] + 1LL;
  }

  v2[2] = v8;
  return v5;
}

char *sub_10006DB84(void *a1, uint64_t a2)
{
  uint64_t v2 = a1;
  uint64_t v3 = 40 * a2;
  size_t v4 = a1[1];
  if (160 * a2 <= v4)
  {
    uint64_t v9 = v2[2];
    if (v9 + v3 <= v4)
    {
      uint8x8_t v10 = *(char **)(v2[4] + 16LL);
    }

    else
    {
      uint8x8_t v10 = (char *)operator new[](v4);
      v2[2] = 0LL;
      uint64_t v11 = operator new(0x18uLL);
      uint64_t v9 = 0LL;
      uint64_t v12 = (void *)v2[4];
      uint64_t v13 = v2[5];
      *uint64_t v11 = v2 + 3;
      v11[1] = v12;
      v11[2] = v10;
      *uint64_t v12 = v11;
      v2[4] = v11;
      void v2[5] = v13 + 1;
    }

    unint64_t v5 = &v10[v9];
    uint64_t v8 = v9 + v3;
  }

  else
  {
    unint64_t v5 = (char *)operator new[](40 * a2);
    uint8x8_t v6 = operator new(0x18uLL);
    uint64_t v7 = v2[3];
    v2 += 3;
    v6[1] = v2;
    _DWORD v6[2] = v5;
    void *v6 = v7;
    *(void *)(v7 + std::istream::~istream(v2, v3 + 8) = v6;
    void *v2 = v6;
    uint64_t v8 = v2[2] + 1LL;
  }

  v2[2] = v8;
  return v5;
}

char *sub_10006DC54(void *a1, uint64_t a2)
{
  uint64_t v2 = a1;
  uint64_t v3 = 72 * a2;
  size_t v4 = a1[1];
  if (288 * a2 <= v4)
  {
    uint64_t v9 = v2[2];
    if (v9 + v3 <= v4)
    {
      uint8x8_t v10 = *(char **)(v2[4] + 16LL);
    }

    else
    {
      uint8x8_t v10 = (char *)operator new[](v4);
      v2[2] = 0LL;
      uint64_t v11 = operator new(0x18uLL);
      uint64_t v9 = 0LL;
      uint64_t v12 = (void *)v2[4];
      uint64_t v13 = v2[5];
      *uint64_t v11 = v2 + 3;
      v11[1] = v12;
      v11[2] = v10;
      *uint64_t v12 = v11;
      v2[4] = v11;
      void v2[5] = v13 + 1;
    }

    unint64_t v5 = &v10[v9];
    uint64_t v8 = v9 + v3;
  }

  else
  {
    unint64_t v5 = (char *)operator new[](72 * a2);
    uint8x8_t v6 = operator new(0x18uLL);
    uint64_t v7 = v2[3];
    v2 += 3;
    v6[1] = v2;
    _DWORD v6[2] = v5;
    void *v6 = v7;
    *(void *)(v7 + std::istream::~istream(v2, v3 + 8) = v6;
    void *v2 = v6;
    uint64_t v8 = v2[2] + 1LL;
  }

  v2[2] = v8;
  return v5;
}

char *sub_10006DD24(void *a1, uint64_t a2)
{
  uint64_t v2 = a1;
  uint64_t v3 = 136 * a2;
  size_t v4 = a1[1];
  if (544 * a2 <= v4)
  {
    uint64_t v9 = v2[2];
    if (v9 + v3 <= v4)
    {
      uint8x8_t v10 = *(char **)(v2[4] + 16LL);
    }

    else
    {
      uint8x8_t v10 = (char *)operator new[](v4);
      v2[2] = 0LL;
      uint64_t v11 = operator new(0x18uLL);
      uint64_t v9 = 0LL;
      uint64_t v12 = (void *)v2[4];
      uint64_t v13 = v2[5];
      *uint64_t v11 = v2 + 3;
      v11[1] = v12;
      v11[2] = v10;
      *uint64_t v12 = v11;
      v2[4] = v11;
      void v2[5] = v13 + 1;
    }

    unint64_t v5 = &v10[v9];
    uint64_t v8 = v9 + v3;
  }

  else
  {
    unint64_t v5 = (char *)operator new[](136 * a2);
    uint8x8_t v6 = operator new(0x18uLL);
    uint64_t v7 = v2[3];
    v2 += 3;
    v6[1] = v2;
    _DWORD v6[2] = v5;
    void *v6 = v7;
    *(void *)(v7 + std::istream::~istream(v2, v3 + 8) = v6;
    void *v2 = v6;
    uint64_t v8 = v2[2] + 1LL;
  }

  v2[2] = v8;
  return v5;
}

char *sub_10006DDF4(void *a1, uint64_t a2)
{
  uint64_t v2 = a1;
  uint64_t v3 = 264 * a2;
  size_t v4 = a1[1];
  if (1056 * a2 <= v4)
  {
    uint64_t v9 = v2[2];
    if (v9 + v3 <= v4)
    {
      uint8x8_t v10 = *(char **)(v2[4] + 16LL);
    }

    else
    {
      uint8x8_t v10 = (char *)operator new[](v4);
      v2[2] = 0LL;
      uint64_t v11 = operator new(0x18uLL);
      uint64_t v9 = 0LL;
      uint64_t v12 = (void *)v2[4];
      uint64_t v13 = v2[5];
      *uint64_t v11 = v2 + 3;
      v11[1] = v12;
      v11[2] = v10;
      *uint64_t v12 = v11;
      v2[4] = v11;
      void v2[5] = v13 + 1;
    }

    unint64_t v5 = &v10[v9];
    uint64_t v8 = v9 + v3;
  }

  else
  {
    unint64_t v5 = (char *)operator new[](264 * a2);
    uint8x8_t v6 = operator new(0x18uLL);
    uint64_t v7 = v2[3];
    v2 += 3;
    v6[1] = v2;
    _DWORD v6[2] = v5;
    void *v6 = v7;
    *(void *)(v7 + std::istream::~istream(v2, v3 + 8) = v6;
    void *v2 = v6;
    uint64_t v8 = v2[2] + 1LL;
  }

  v2[2] = v8;
  return v5;
}

char *sub_10006DEC4(void *a1, uint64_t a2)
{
  uint64_t v2 = a1;
  uint64_t v3 = 520 * a2;
  size_t v4 = a1[1];
  if (2080 * a2 <= v4)
  {
    uint64_t v9 = v2[2];
    if (v9 + v3 <= v4)
    {
      uint8x8_t v10 = *(char **)(v2[4] + 16LL);
    }

    else
    {
      uint8x8_t v10 = (char *)operator new[](v4);
      v2[2] = 0LL;
      uint64_t v11 = operator new(0x18uLL);
      uint64_t v9 = 0LL;
      uint64_t v12 = (void *)v2[4];
      uint64_t v13 = v2[5];
      *uint64_t v11 = v2 + 3;
      v11[1] = v12;
      v11[2] = v10;
      *uint64_t v12 = v11;
      v2[4] = v11;
      void v2[5] = v13 + 1;
    }

    unint64_t v5 = &v10[v9];
    uint64_t v8 = v9 + v3;
  }

  else
  {
    unint64_t v5 = (char *)operator new[](520 * a2);
    uint8x8_t v6 = operator new(0x18uLL);
    uint64_t v7 = v2[3];
    v2 += 3;
    v6[1] = v2;
    _DWORD v6[2] = v5;
    void *v6 = v7;
    *(void *)(v7 + std::istream::~istream(v2, v3 + 8) = v6;
    void *v2 = v6;
    uint64_t v8 = v2[2] + 1LL;
  }

  v2[2] = v8;
  return v5;
}

uint64_t sub_10006DF94(uint64_t a1)
{
  return sub_10006CB40(a1);
}

void *sub_10006DFC4(void *result, void *a2)
{
  if (a2)
  {
    uint64_t v2 = a2;
    uint64_t v3 = result;
    do
    {
      size_t v4 = (void *)*v2;
      uint64_t result = sub_10006E014((uint64_t *)v3[4]);
      v2[3] = result[7];
      result[7] = v2;
      uint64_t v2 = v4;
    }

    while (v4);
  }

  return result;
}

void *sub_10006E014(uint64_t *a1)
{
  uint64_t v2 = a1[2];
  uint64_t v3 = a1 + 2;
  if ((unint64_t)(a1[3] - v2) <= 0xC7)
  {
    sub_100069658((uint64_t)(a1 + 2), 0x19uLL);
    uint64_t v2 = *v3;
  }

  size_t v4 = *(void **)(v2 + 192);
  if (!v4)
  {
    size_t v4 = operator new(0x40uLL);
    uint64_t v5 = *a1;
    *size_t v4 = off_1000D1B60;
    sub_10006B764(v4 + 1, v5);
    v4[7] = 0LL;
    *size_t v4 = off_1000D2208;
    uint64_t v6 = *(void *)(*v3 + 192);
    *(void *)(*v3 + 192) = v4;
    if (v6) {
      (*(void (**)(uint64_t))(*(void *)v6 + 8LL))(v6);
    }
  }

  return v4;
}

void sub_10006E0B4(_Unwind_Exception *a1)
{
}

void *sub_10006E0C8(void *a1)
{
  *a1 = off_1000D1B60;
  a1[1] = off_1000D1B88;
  sub_10002B998(a1 + 4);
  return a1;
}

void sub_10006E100(uint64_t *a1)
{
  *a1 = (uint64_t)off_1000D1B60;
  a1[1] = (uint64_t)off_1000D1B88;
  sub_10002B998(a1 + 4);
  operator delete(a1);
}

void *sub_10006E138(uint64_t *a1)
{
  uint64_t v2 = a1[2];
  uint64_t v3 = a1 + 2;
  if ((unint64_t)(a1[3] - v2) <= 0x187)
  {
    sub_100069658((uint64_t)(a1 + 2), 0x31uLL);
    uint64_t v2 = *v3;
  }

  size_t v4 = *(void **)(v2 + 384);
  if (!v4)
  {
    size_t v4 = operator new(0x40uLL);
    uint64_t v5 = *a1;
    *size_t v4 = off_1000D0BA0;
    sub_10002B8A4(v4 + 1, v5);
    v4[7] = 0LL;
    *size_t v4 = off_1000D2248;
    uint64_t v6 = *(void *)(*v3 + 384);
    *(void *)(*v3 + 384) = v4;
    if (v6) {
      (*(void (**)(uint64_t))(*(void *)v6 + 8LL))(v6);
    }
  }

  return v4;
}

void sub_10006E1D8(_Unwind_Exception *a1)
{
}

void *sub_10006E1EC(void *a1)
{
  *a1 = off_1000D0BA0;
  a1[1] = off_1000D0BC8;
  sub_10002B998(a1 + 4);
  return a1;
}

void sub_10006E224(uint64_t *a1)
{
  *a1 = (uint64_t)off_1000D0BA0;
  a1[1] = (uint64_t)off_1000D0BC8;
  sub_10002B998(a1 + 4);
  operator delete(a1);
}

void *sub_10006E25C(uint64_t *a1)
{
  uint64_t v2 = a1[2];
  uint64_t v3 = a1 + 2;
  if ((unint64_t)(a1[3] - v2) <= 0x307)
  {
    sub_100069658((uint64_t)(a1 + 2), 0x61uLL);
    uint64_t v2 = *v3;
  }

  size_t v4 = *(void **)(v2 + 768);
  if (!v4)
  {
    size_t v4 = operator new(0x40uLL);
    uint64_t v5 = *a1;
    *size_t v4 = off_1000D1C60;
    sub_10006BB08(v4 + 1, v5);
    v4[7] = 0LL;
    *size_t v4 = off_1000D2288;
    uint64_t v6 = *(void *)(*v3 + 768);
    *(void *)(*v3 + 76std::istream::~istream(v2, v3 + 8) = v4;
    if (v6) {
      (*(void (**)(uint64_t))(*(void *)v6 + 8LL))(v6);
    }
  }

  return v4;
}

void sub_10006E2FC(_Unwind_Exception *a1)
{
}

void *sub_10006E310(void *a1)
{
  *a1 = off_1000D1C60;
  a1[1] = off_1000D1C88;
  sub_10002B998(a1 + 4);
  return a1;
}

void sub_10006E348(uint64_t *a1)
{
  *a1 = (uint64_t)off_1000D1C60;
  a1[1] = (uint64_t)off_1000D1C88;
  sub_10002B998(a1 + 4);
  operator delete(a1);
}

void *sub_10006E380(uint64_t *a1)
{
  uint64_t v2 = a1[2];
  uint64_t v3 = a1 + 2;
  if ((unint64_t)(a1[3] - v2) <= 0x607)
  {
    sub_100069658((uint64_t)(a1 + 2), 0xC1uLL);
    uint64_t v2 = *v3;
  }

  size_t v4 = *(void **)(v2 + 1536);
  if (!v4)
  {
    size_t v4 = operator new(0x40uLL);
    uint64_t v5 = *a1;
    *size_t v4 = off_1000D1D20;
    sub_10006BD8C(v4 + 1, v5);
    v4[7] = 0LL;
    *size_t v4 = off_1000D22C8;
    uint64_t v6 = *(void *)(*v3 + 1536);
    *(void *)(*v3 + 1536) = v4;
    if (v6) {
      (*(void (**)(uint64_t))(*(void *)v6 + 8LL))(v6);
    }
  }

  return v4;
}

void sub_10006E420(_Unwind_Exception *a1)
{
}

void *sub_10006E434(void *a1)
{
  *a1 = off_1000D1D20;
  a1[1] = off_1000D1D48;
  sub_10002B998(a1 + 4);
  return a1;
}

void sub_10006E46C(uint64_t *a1)
{
  *a1 = (uint64_t)off_1000D1D20;
  a1[1] = (uint64_t)off_1000D1D48;
  sub_10002B998(a1 + 4);
  operator delete(a1);
}

void *sub_10006E4A4(uint64_t *a1)
{
  uint64_t v2 = a1[2];
  uint64_t v3 = a1 + 2;
  if ((unint64_t)(a1[3] - v2) <= 0xC07)
  {
    sub_100069658((uint64_t)(a1 + 2), 0x181uLL);
    uint64_t v2 = *v3;
  }

  size_t v4 = *(void **)(v2 + 3072);
  if (!v4)
  {
    size_t v4 = operator new(0x40uLL);
    uint64_t v5 = *a1;
    *size_t v4 = off_1000D1DE0;
    sub_10006C010(v4 + 1, v5);
    v4[7] = 0LL;
    *size_t v4 = off_1000D2308;
    uint64_t v6 = *(void *)(*v3 + 3072);
    *(void *)(*v3 + 30sub_10001A760(v25 - 72) = v4;
    if (v6) {
      (*(void (**)(uint64_t))(*(void *)v6 + 8LL))(v6);
    }
  }

  return v4;
}

void sub_10006E544(_Unwind_Exception *a1)
{
}

void *sub_10006E558(void *a1)
{
  *a1 = off_1000D1DE0;
  a1[1] = off_1000D1E08;
  sub_10002B998(a1 + 4);
  return a1;
}

void sub_10006E590(uint64_t *a1)
{
  *a1 = (uint64_t)off_1000D1DE0;
  a1[1] = (uint64_t)off_1000D1E08;
  sub_10002B998(a1 + 4);
  operator delete(a1);
}

void *sub_10006E5C8(uint64_t *a1)
{
  uint64_t v2 = a1[2];
  uint64_t v3 = a1 + 2;
  if ((unint64_t)(a1[3] - v2) >> 3 <= 0x300)
  {
    sub_100069658((uint64_t)(a1 + 2), 0x301uLL);
    uint64_t v2 = *v3;
  }

  size_t v4 = *(void **)(v2 + 6144);
  if (!v4)
  {
    size_t v4 = operator new(0x40uLL);
    uint64_t v5 = *a1;
    *size_t v4 = off_1000D1EA0;
    sub_10006C298(v4 + 1, v5);
    v4[7] = 0LL;
    *size_t v4 = off_1000D2348;
    uint64_t v6 = *(void *)(*v3 + 6144);
    *(void *)(*v3 + 6144) = v4;
    if (v6) {
      (*(void (**)(uint64_t))(*(void *)v6 + 8LL))(v6);
    }
  }

  return v4;
}

void sub_10006E66C(_Unwind_Exception *a1)
{
}

void *sub_10006E680(void *a1)
{
  *a1 = off_1000D1EA0;
  a1[1] = off_1000D1EC8;
  sub_10002B998(a1 + 4);
  return a1;
}

void sub_10006E6B8(uint64_t *a1)
{
  *a1 = (uint64_t)off_1000D1EA0;
  a1[1] = (uint64_t)off_1000D1EC8;
  sub_10002B998(a1 + 4);
  operator delete(a1);
}

void *sub_10006E6F0(uint64_t *a1)
{
  uint64_t v2 = a1[2];
  uint64_t v3 = a1 + 2;
  if ((unint64_t)(a1[3] - v2) >> 3 <= 0x600)
  {
    sub_100069658((uint64_t)(a1 + 2), 0x601uLL);
    uint64_t v2 = *v3;
  }

  size_t v4 = *(void **)(v2 + 12288);
  if (!v4)
  {
    size_t v4 = operator new(0x40uLL);
    uint64_t v5 = *a1;
    *size_t v4 = off_1000D1F60;
    sub_10006C520(v4 + 1, v5);
    v4[7] = 0LL;
    *size_t v4 = off_1000D2388;
    uint64_t v6 = *(void *)(*v3 + 12288);
    *(void *)(*v3 + 1228std::istream::~istream(v2, v3 + 8) = v4;
    if (v6) {
      (*(void (**)(uint64_t))(*(void *)v6 + 8LL))(v6);
    }
  }

  return v4;
}

void sub_10006E794(_Unwind_Exception *a1)
{
}

void *sub_10006E7A8(void *a1)
{
  *a1 = off_1000D1F60;
  a1[1] = off_1000D1F88;
  sub_10002B998(a1 + 4);
  return a1;
}

void sub_10006E7E0(uint64_t *a1)
{
  *a1 = (uint64_t)off_1000D1F60;
  a1[1] = (uint64_t)off_1000D1F88;
  sub_10002B998(a1 + 4);
  operator delete(a1);
}

void *sub_10006E818(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x1555555555555556LL) {
    sub_100017F08();
  }
  return operator new(12 * a2);
}

void sub_10006E85C(int a1, uint64_t *__p)
{
  if (__p)
  {
    uint64_t v3 = __p[1];
    __p[1] = 0LL;
    if (v3) {
      (*(void (**)(uint64_t))(*(void *)v3 + 8LL))(v3);
    }
    uint64_t v4 = *__p;
    *std::string __p = 0LL;
    if (v4) {
      (*(void (**)(uint64_t))(*(void *)v4 + 8LL))(v4);
    }
    operator delete(__p);
  }

uint64_t sub_10006E8B4(uint64_t a1)
{
  *(void *)a1 = off_1000D11E0;
  if (*(_BYTE *)(a1 + 184))
  {
    uint64_t v2 = *(void ***)(a1 + 176);
    if (v2)
    {
      uint64_t v3 = v2[13];
      if (v3)
      {
        v2[14] = v3;
        operator delete(v3);
      }

      sub_10006DF94((uint64_t)(v2 + 4));
      uint64_t v4 = v2[1];
      v2[1] = 0LL;
      if (v4) {
        operator delete(v4);
      }
      uint64_t v5 = *v2;
      void *v2 = 0LL;
      if (v5) {
        operator delete(v5);
      }
      operator delete(v2);
    }
  }

  uint64_t v6 = *(uint64_t **)(a1 + 136);
  *(void *)(a1 + 136) = 0LL;
  if (v6) {
    sub_10006E85C(a1 + 136, v6);
  }
  return sub_10006C6D8(a1);
}

uint64_t sub_10006E944(uint64_t a1, uint64_t a2)
{
  *sub_10006EA48((void *)a1, a2) = off_1000D11E0;
  uint64_t v4 = (__n128 *)operator new(0x28uLL);
  sub_100070094(v4, *(uint64_t **)(a2 + 136), 1LL);
  *(void *)(a1 + 136) = v4;
  __n128 v5 = *v4;
  *(__n128 *)(a1 + 144) = *v4;
  *(void *)(a1 + 16RDString::RDString((RDString *)&v66, theString, 0) = (*(uint64_t (**)(unint64_t, __n128))(*(void *)v5.n128_u64[0] + 72LL))( v5.n128_u64[0],  v5);
  *(void *)(a1 + 16std::istream::~istream(v2, v3 + 8) = (*(uint64_t (**)(void))(**(void **)(a1 + 152) + 72LL))(*(void *)(a1 + 152));
  uint64_t v6 = operator new(0x88uLL);
  sub_100070144((uint64_t)v6, *(void *)(a2 + 176));
  *(void *)(a1 + 176) = v6;
  *(_BYTE *)(a1 + 184) = 1;
  *(_DWORD *)(a1 + 18std::istream::~istream(v2, v3 + 8) = *(_DWORD *)(a2 + 188);
  return a1;
}

void sub_10006E9F8(_Unwind_Exception *a1)
{
  __n128 v5 = *v2;
  void *v2 = 0LL;
  if (v5) {
    sub_10006E85C((int)v2, v5);
  }
  sub_10006C6D8(v1);
  _Unwind_Resume(a1);
}

void *sub_10006EA48(void *a1, uint64_t a2)
{
  uint64_t v4 = sub_10006EB24((uint64_t)a1, a2, 1u);
  *(void *)uint64_t v4 = off_1000D1280;
  std::string::operator=((std::string *)(v4 + 16), (const std::string *)(a2 + 16));
  a1[1] = a1[1] & 0xFFFF00000000FFFFLL | (*(uint64_t (**)(uint64_t))(*(void *)a2 + 16LL))(a2) & 0xFFFFFFFF0004LL;
  uint64_t v5 = *(void *)(a2 + 40);
  if (v5) {
    uint64_t v5 = (*(uint64_t (**)(uint64_t))(*(void *)v5 + 16LL))(v5);
  }
  uint64_t v6 = a1[5];
  a1[5] = v5;
  if (v6) {
    (*(void (**)(uint64_t))(*(void *)v6 + 8LL))(v6);
  }
  uint64_t v7 = *(void *)(a2 + 48);
  if (v7) {
    uint64_t v7 = (*(uint64_t (**)(uint64_t))(*(void *)v7 + 16LL))(v7);
  }
  uint64_t v8 = a1[6];
  a1[6] = v7;
  if (v8) {
    (*(void (**)(uint64_t))(*(void *)v8 + 8LL))(v8);
  }
  return a1;
}

void sub_10006EB10(_Unwind_Exception *a1)
{
}

uint64_t sub_10006EB24(uint64_t a1, uint64_t a2, unsigned __int8 a3)
{
  *(void *)a1 = off_1000D05B8;
  *(void *)(a1 + std::istream::~istream(v2, v3 + 8) = 0LL;
  sub_10000A2DC((void *)(a1 + 16), "null");
  *(void *)(a1 + 4RDString::RDString((RDString *)&v66, theString, 0) = 0LL;
  *(void *)(a1 + 4std::istream::~istream(v2, v3 + 8) = 0LL;
  *(void *)a1 = off_1000D12D8;
  *(_BYTE *)(a1 + ++*(void *)(result + 56) = 0;
  *(void *)(a1 + 6RDString::RDString((RDString *)&v66, theString, 0) = 0xFFFFFFFFLL;
  *(void *)(a1 + sub_10001A760(v25 - 72) = 0LL;
  *(void *)(a1 + 8RDString::RDString((RDString *)&v66, theString, 0) = 0LL;
  *(void *)(a1 + 8std::istream::~istream(v2, v3 + 8) = 0LL;
  *(void *)(a1 + 96) = 0xFFFFFFFF00000000LL;
  char v6 = *(_BYTE *)(a2 + 104);
  *(_BYTE *)(a1 + 104) = v6;
  unint64_t v7 = *(void *)(a2 + 112);
  *(void *)(a1 + 112) = v7;
  uint64_t v8 = (char *)operator new(0x88uLL);
  v14[0] = v6;
  unint64_t v15 = v7;
  sub_100069288((uint64_t)v8, v14);
  unint64_t v9 = v15;
  v8[88] = v15 == 0;
  *((_DWORD *)v8 + 23) = -1;
  *((void *)v8 + 12) = 0LL;
  v8[104] = v14[0];
  if (v9 <= 0x1FA0) {
    unint64_t v9 = 8096LL;
  }
  *((void *)v8 + 14) = v9;
  v8[120] = 0;
  *((void *)v8 + 16) = 0LL;
  *(void *)(a1 + 12RDString::RDString((RDString *)&v66, theString, 0) = v8;
  if (*(_BYTE *)(a2 + 128)) {
    char v10 = 1;
  }
  else {
    char v10 = a3 ^ 1;
  }
  *(_BYTE *)(a1 + 12std::istream::~istream(v2, v3 + 8) = v10;
  *(_BYTE *)(a1 + 129) = 1;
  if (((a3 ^ 1) & 1) == 0)
  {
    uint64_t v11 = *(void *)(a2 + 120);
    sub_10006ED44((uint64_t)v8, v11);
    __int128 v12 = *(_OWORD *)(v11 + 120);
    *(_OWORD *)(v8 + 104) = *(_OWORD *)(v11 + 104);
    *(_OWORD *)(v8 + 12RDString::RDString((RDString *)&v66, theString, 0) = v12;
    *(_BYTE *)(a1 + ++*(void *)(result + 56) = *(_BYTE *)(a2 + 56);
    *(void *)(a1 + 6RDString::RDString((RDString *)&v66, theString, 0) = *(void *)(a2 + 60);
    sub_10006ECB4((void **)(a1 + 72), a2 + 72);
    *(void *)(a1 + 96) = *(void *)(a2 + 96);
  }

  return a1;
}

void sub_10006EC84(_Unwind_Exception *a1)
{
  if (*v2) {
    operator delete(*v2);
  }
  sub_10002D2D8(v1);
  _Unwind_Resume(a1);
}

void **sub_10006ECB4(void **a1, uint64_t a2)
{
  if (a1 != (void **)a2)
  {
    unint64_t v4 = *(void *)(a2 + 8);
    if (v4)
    {
      if (v4 > (void)a1[2] << 6)
      {
        uint64_t v5 = *a1;
        if (*a1)
        {
          operator delete(v5);
          *a1 = 0LL;
          a1[1] = 0LL;
          a1[2] = 0LL;
          unint64_t v4 = *(void *)(a2 + 8);
        }

        sub_10002C140(a1, v4);
        unint64_t v4 = *(void *)(a2 + 8);
      }

      memmove(*a1, *(const void **)a2, (((v4 - 1) >> 3) & 0x1FFFFFFFFFFFFFF8LL) + 8);
      char v6 = *(void **)(a2 + 8);
    }

    else
    {
      char v6 = 0LL;
    }

    a1[1] = v6;
  }

  return a1;
}

uint64_t sub_10006ED44(uint64_t a1, uint64_t a2)
{
  if (a1 != a2)
  {
    sub_10006EEA8(a1, a2);
    *(void *)(a1 + 64) = *(void *)(a1 + 40);
    *(_BYTE *)(a1 + 8std::istream::~istream(v2, v3 + 8) = *(_BYTE *)(a2 + 88);
    *(_DWORD *)(a1 + 92) = *(_DWORD *)(a2 + 92);
    if (*(_DWORD *)(a2 + 92) == -1) {
      unint64_t v4 = 0LL;
    }
    else {
      unint64_t v4 = sub_10006EDB4(a1, 0);
    }
    *(void *)(a1 + 96) = v4;
  }

  return a1;
}

char *sub_10006EDB4(uint64_t a1, int a2)
{
  int v13 = a2;
  uint64_t v3 = a2;
  uint64_t v5 = *(void *)(a1 + 8);
  uint64_t v6 = *(void *)(a1 + 16);
  uint64_t v4 = a1 + 8;
  if (a2 >= (unint64_t)((v6 - v5) >> 3))
  {
    uint64_t v12 = 0LL;
    sub_10006FF4C(v4, a2 + 1, &v12);
  }

  else
  {
    unint64_t v7 = *(char **)(v5 + 8LL * a2);
    if (v7) {
      return v7;
    }
  }

  unint64_t v7 = sub_10006F080((uint64_t **)(a1 + 72), 1uLL);
  *(_DWORD *)unint64_t v7 = *sub_10002ADB0();
  *((void *)v7 + 5) = 0LL;
  *(_OWORD *)(v7 + ++*(void *)(result + 24) = 0u;
  *(_OWORD *)(v7 + std::istream::~istream(v2, v3 + 8) = 0u;
  uint64_t v8 = *(void *)(a1 + 80);
  *((void *)v7 + 6) = v8;
  ++*(void *)(v8 + 8);
  *((void *)v7 + 7) = 0LL;
  *(void *)(*(void *)(a1 + 8) + 8 * v3) = v7;
  if (*(_BYTE *)a1)
  {
    unint64_t v9 = sub_10006F788(a1 + 32, 0LL, 0LL, &v13);
    uint64_t v10 = *(void *)(a1 + 32);
    *unint64_t v9 = v10;
    v9[1] = a1 + 32;
    *(void *)(v10 + std::istream::~istream(v2, v3 + 8) = v9;
    *(void *)(a1 + 32) = v9;
    ++*(void *)(a1 + 48);
  }

  return v7;
}

void sub_10006EEA8(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (char **)(a1 + 8);
  sub_10002D348((void **)(a1 + 8), (uint64_t)(*(void *)(a2 + 16) - *(void *)(a2 + 8)) >> 3);
  int v23 = 0;
  uint64_t v5 = *(void *)(a2 + 8);
  if (*(void *)(a2 + 16) != v5)
  {
    unint64_t v6 = 0LL;
    do
    {
      uint64_t v7 = *(void *)(v5 + 8 * v6);
      if (v7)
      {
        uint64_t v8 = sub_10006F080((uint64_t **)(a1 + 72), 1uLL);
        *(_DWORD *)uint64_t v8 = *(_DWORD *)v7;
        *(_OWORD *)(v8 + std::istream::~istream(v2, v3 + 8) = *(_OWORD *)(v7 + 8);
        sub_10006F4A0((uint64_t)(v8 + 24), *(void *)(v7 + 24), *(void *)(v7 + 32), (uint64_t *)(a1 + 80));
        *((_DWORD *)v8 + 14) = *(_DWORD *)(v7 + 56);
        *((_DWORD *)v8 + 15) = 0;
        if (*(_BYTE *)a1)
        {
          unint64_t v9 = sub_10006F788(a1 + 32, 0LL, 0LL, &v23);
          uint64_t v10 = *(void *)(a1 + 32);
          *unint64_t v9 = v10;
          v9[1] = a1 + 32;
          *(void *)(v10 + std::istream::~istream(v2, v3 + 8) = v9;
          *(void *)(a1 + 32) = v9;
          ++*(void *)(a1 + 48);
        }
      }

      else
      {
        uint64_t v8 = 0LL;
      }

      uint64_t v12 = *(char ***)(a1 + 16);
      unint64_t v11 = *(void *)(a1 + 24);
      if ((unint64_t)v12 >= v11)
      {
        uint64_t v14 = ((char *)v12 - *v4) >> 3;
        uint64_t v15 = v11 - (void)*v4;
        uint64_t v16 = v15 >> 2;
        else {
          unint64_t v17 = v16;
        }
        if (v17) {
          uint64_t v18 = (char *)sub_100018788(a1 + 24, v17);
        }
        else {
          uint64_t v18 = 0LL;
        }
        __int128 v19 = (char **)&v18[8 * v14];
        int *v19 = v8;
        int v13 = v19 + 1;
        uint64_t v21 = *(char **)(a1 + 8);
        uint64_t v20 = *(char **)(a1 + 16);
        if (v20 != v21)
        {
          do
          {
            __int128 v22 = (char *)*((void *)v20 - 1);
            v20 -= 8;
            *--__int128 v19 = v22;
          }

          while (v20 != v21);
          uint64_t v20 = *v4;
        }

        *(void *)(a1 + std::istream::~istream(v2, v3 + 8) = v19;
        *(void *)(a1 + 16) = v13;
        *(void *)(a1 + ++*(void *)(result + 24) = &v18[8 * v17];
        if (v20) {
          operator delete(v20);
        }
      }

      else
      {
        *uint64_t v12 = v8;
        int v13 = v12 + 1;
      }

      *(void *)(a1 + 16) = v13;
      unint64_t v6 = ++v23;
      uint64_t v5 = *(void *)(a2 + 8);
    }

    while (v6 < (*(void *)(a2 + 16) - v5) >> 3);
  }

char *sub_10006F080(uint64_t **a1, unint64_t a2)
{
  if (a2 == 2)
  {
    uint64_t v2 = sub_10006AA74(*a1);
    uint64_t result = (char *)v2[7];
    if (!result)
    {
      uint64_t result = sub_10006DD24(v2 + 1, 1LL);
      *((void *)result + 16) = 0LL;
      return result;
    }

    uint64_t v4 = *((void *)result + 16);
    goto LABEL_26;
  }

  if (a2 == 1)
  {
    uint64_t v2 = sub_10006A950(*a1);
    uint64_t result = (char *)v2[7];
    if (!result)
    {
      uint64_t result = sub_10006DC54(v2 + 1, 1LL);
      *((void *)result + std::istream::~istream(v2, v3 + 8) = 0LL;
      return result;
    }

    uint64_t v4 = *((void *)result + 8);
LABEL_26:
    v2[7] = v4;
    return result;
  }

  if (a2 <= 4)
  {
    uint64_t v2 = sub_10006AB98(*a1);
    uint64_t result = (char *)v2[7];
    if (!result)
    {
      uint64_t result = sub_10006DDF4(v2 + 1, 1LL);
      *((void *)result + 32) = 0LL;
      return result;
    }

    uint64_t v4 = *((void *)result + 32);
    goto LABEL_26;
  }

  if (a2 <= 8)
  {
    uint64_t v2 = sub_10006ACBC(*a1);
    uint64_t result = (char *)v2[7];
    if (!result)
    {
      uint64_t result = sub_10006DEC4(v2 + 1, 1LL);
      *((void *)result + 64) = 0LL;
      return result;
    }

    uint64_t v4 = *((void *)result + 64);
    goto LABEL_26;
  }

  if (a2 <= 0x10)
  {
    uint64_t v2 = sub_10006ADE4(*a1);
    uint64_t result = (char *)v2[7];
    if (!result)
    {
      uint64_t result = sub_10006F230(v2 + 1, 1LL);
      *((void *)result + 12std::istream::~istream(v2, v3 + 8) = 0LL;
      return result;
    }

    uint64_t v4 = *((void *)result + 128);
    goto LABEL_26;
  }

  if (a2 <= 0x20)
  {
    uint64_t v2 = sub_10006AF0C(*a1);
    uint64_t result = (char *)v2[7];
    if (!result)
    {
      uint64_t result = sub_10006F300(v2 + 1, 1LL);
      *((void *)result + 2++*(void *)(result + 56) = 0LL;
      return result;
    }

    uint64_t v4 = *((void *)result + 256);
    goto LABEL_26;
  }

  if (a2 <= 0x40)
  {
    uint64_t v2 = sub_10006B194(*a1);
    uint64_t result = (char *)v2[7];
    if (!result)
    {
      uint64_t result = sub_10006F3D0(v2 + 1, 1LL);
      *((void *)result + 512) = 0LL;
      return result;
    }

    uint64_t v4 = *((void *)result + 512);
    goto LABEL_26;
  }

  if (a2 >> 58) {
    sub_100017F08();
  }
  return (char *)operator new(a2 << 6);
}

char *sub_10006F230(void *a1, uint64_t a2)
{
  uint64_t v2 = a1;
  uint64_t v3 = 1032 * a2;
  size_t v4 = a1[1];
  if (4128 * a2 <= v4)
  {
    uint64_t v9 = v2[2];
    if (v9 + v3 <= v4)
    {
      uint64_t v10 = *(char **)(v2[4] + 16LL);
    }

    else
    {
      uint64_t v10 = (char *)operator new[](v4);
      v2[2] = 0LL;
      unint64_t v11 = operator new(0x18uLL);
      uint64_t v9 = 0LL;
      uint64_t v12 = (void *)v2[4];
      uint64_t v13 = v2[5];
      *unint64_t v11 = v2 + 3;
      v11[1] = v12;
      v11[2] = v10;
      *uint64_t v12 = v11;
      v2[4] = v11;
      void v2[5] = v13 + 1;
    }

    uint64_t v5 = &v10[v9];
    uint64_t v8 = v9 + v3;
  }

  else
  {
    uint64_t v5 = (char *)operator new[](1032 * a2);
    unint64_t v6 = operator new(0x18uLL);
    uint64_t v7 = v2[3];
    v2 += 3;
    v6[1] = v2;
    _DWORD v6[2] = v5;
    void *v6 = v7;
    *(void *)(v7 + std::istream::~istream(v2, v3 + 8) = v6;
    void *v2 = v6;
    uint64_t v8 = v2[2] + 1LL;
  }

  v2[2] = v8;
  return v5;
}

char *sub_10006F300(void *a1, uint64_t a2)
{
  uint64_t v2 = a1;
  uint64_t v3 = 2056 * a2;
  size_t v4 = a1[1];
  if (8224 * a2 <= v4)
  {
    uint64_t v9 = v2[2];
    if (v9 + v3 <= v4)
    {
      uint64_t v10 = *(char **)(v2[4] + 16LL);
    }

    else
    {
      uint64_t v10 = (char *)operator new[](v4);
      v2[2] = 0LL;
      unint64_t v11 = operator new(0x18uLL);
      uint64_t v9 = 0LL;
      uint64_t v12 = (void *)v2[4];
      uint64_t v13 = v2[5];
      *unint64_t v11 = v2 + 3;
      v11[1] = v12;
      v11[2] = v10;
      *uint64_t v12 = v11;
      v2[4] = v11;
      void v2[5] = v13 + 1;
    }

    uint64_t v5 = &v10[v9];
    uint64_t v8 = v9 + v3;
  }

  else
  {
    uint64_t v5 = (char *)operator new[](2056 * a2);
    unint64_t v6 = operator new(0x18uLL);
    uint64_t v7 = v2[3];
    v2 += 3;
    v6[1] = v2;
    _DWORD v6[2] = v5;
    void *v6 = v7;
    *(void *)(v7 + std::istream::~istream(v2, v3 + 8) = v6;
    void *v2 = v6;
    uint64_t v8 = v2[2] + 1LL;
  }

  v2[2] = v8;
  return v5;
}

char *sub_10006F3D0(void *a1, uint64_t a2)
{
  uint64_t v2 = a1;
  uint64_t v3 = 4104 * a2;
  size_t v4 = a1[1];
  if (16416 * a2 <= v4)
  {
    uint64_t v9 = v2[2];
    if (v9 + v3 <= v4)
    {
      uint64_t v10 = *(char **)(v2[4] + 16LL);
    }

    else
    {
      uint64_t v10 = (char *)operator new[](v4);
      v2[2] = 0LL;
      unint64_t v11 = operator new(0x18uLL);
      uint64_t v9 = 0LL;
      uint64_t v12 = (void *)v2[4];
      uint64_t v13 = v2[5];
      *unint64_t v11 = v2 + 3;
      v11[1] = v12;
      v11[2] = v10;
      *uint64_t v12 = v11;
      v2[4] = v11;
      void v2[5] = v13 + 1;
    }

    uint64_t v5 = &v10[v9];
    uint64_t v8 = v9 + v3;
  }

  else
  {
    uint64_t v5 = (char *)operator new[](4104 * a2);
    unint64_t v6 = operator new(0x18uLL);
    uint64_t v7 = v2[3];
    v2 += 3;
    v6[1] = v2;
    _DWORD v6[2] = v5;
    void *v6 = v7;
    *(void *)(v7 + std::istream::~istream(v2, v3 + 8) = v6;
    void *v2 = v6;
    uint64_t v8 = v2[2] + 1LL;
  }

  v2[2] = v8;
  return v5;
}

uint64_t sub_10006F4A0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  *(void *)a1 = 0LL;
  *(void *)(a1 + std::istream::~istream(v2, v3 + 8) = 0LL;
  *(void *)(a1 + 16) = 0LL;
  uint64_t v5 = *a4;
  *(void *)(a1 + ++*(void *)(result + 24) = *a4;
  ++*(void *)(v5 + 8);
  sub_10006F500((char *)a1, a2, a3, (a3 - a2) >> 4);
  return a1;
}

void sub_10006F4EC(_Unwind_Exception *a1)
{
}

char *sub_10006F500(char *result, uint64_t a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    unint64_t v6 = result;
    uint64_t result = sub_10006F590((uint64_t)result, a4);
    uint64_t v7 = *((void *)v6 + 1);
    while (a2 != a3)
    {
      *(void *)uint64_t v7 = *(void *)a2;
      *(_DWORD *)(v7 + std::istream::~istream(v2, v3 + 8) = *(_DWORD *)(a2 + 8);
      *(_DWORD *)(v7 + 12) = *(_DWORD *)(a2 + 12);
      v7 += 16LL;
      a2 += 16LL;
    }

    *((void *)v6 + 1) = v7;
  }

  return result;
}

void sub_10006F57C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
}

char *sub_10006F590(uint64_t a1, unint64_t a2)
{
  if (a2 >> 60) {
    sub_100018774();
  }
  uint64_t result = sub_10006F5D8((uint64_t **)(a1 + 24), a2);
  *(void *)a1 = result;
  *(void *)(a1 + std::istream::~istream(v2, v3 + 8) = result;
  *(void *)(a1 + 16) = &result[16 * a2];
  return result;
}

char *sub_10006F5D8(uint64_t **a1, unint64_t a2)
{
  if (a2 == 2)
  {
    uint64_t v2 = sub_100069A30(*a1);
    uint64_t result = (char *)v2[7];
    if (!result)
    {
      uint64_t result = sub_10006DB84(v2 + 1, 1LL);
      *((void *)result + 4) = 0LL;
      return result;
    }

    uint64_t v4 = *((void *)result + 4);
    goto LABEL_26;
  }

  if (a2 == 1)
  {
    uint64_t v2 = sub_1000695A4(*a1);
    uint64_t result = (char *)v2[7];
    if (!result)
    {
      uint64_t result = sub_10006DAB4(v2 + 1, 1LL);
      *((void *)result + 2) = 0LL;
      return result;
    }

    uint64_t v4 = *((void *)result + 2);
LABEL_26:
    v2[7] = v4;
    return result;
  }

  if (a2 <= 4)
  {
    uint64_t v2 = sub_100069CB4(*a1);
    uint64_t result = (char *)v2[7];
    if (!result)
    {
      uint64_t result = sub_10006DC54(v2 + 1, 1LL);
      *((void *)result + std::istream::~istream(v2, v3 + 8) = 0LL;
      return result;
    }

    uint64_t v4 = *((void *)result + 8);
    goto LABEL_26;
  }

  if (a2 <= 8)
  {
    uint64_t v2 = sub_100069F38(*a1);
    uint64_t result = (char *)v2[7];
    if (!result)
    {
      uint64_t result = sub_10006DD24(v2 + 1, 1LL);
      *((void *)result + 16) = 0LL;
      return result;
    }

    uint64_t v4 = *((void *)result + 16);
    goto LABEL_26;
  }

  if (a2 <= 0x10)
  {
    uint64_t v2 = sub_10006A1BC(*a1);
    uint64_t result = (char *)v2[7];
    if (!result)
    {
      uint64_t result = sub_10006DDF4(v2 + 1, 1LL);
      *((void *)result + 32) = 0LL;
      return result;
    }

    uint64_t v4 = *((void *)result + 32);
    goto LABEL_26;
  }

  if (a2 <= 0x20)
  {
    uint64_t v2 = sub_10006A440(*a1);
    uint64_t result = (char *)v2[7];
    if (!result)
    {
      uint64_t result = sub_10006DEC4(v2 + 1, 1LL);
      *((void *)result + 64) = 0LL;
      return result;
    }

    uint64_t v4 = *((void *)result + 64);
    goto LABEL_26;
  }

  if (a2 <= 0x40)
  {
    uint64_t v2 = sub_10006A6C8(*a1);
    uint64_t result = (char *)v2[7];
    if (!result)
    {
      uint64_t result = sub_10006F230(v2 + 1, 1LL);
      *((void *)result + 12std::istream::~istream(v2, v3 + 8) = 0LL;
      return result;
    }

    uint64_t v4 = *((void *)result + 128);
    goto LABEL_26;
  }

  if (a2 >> 60) {
    sub_100017F08();
  }
  return (char *)operator new(16 * a2);
}

void *sub_10006F788(uint64_t a1, uint64_t a2, uint64_t a3, _DWORD *a4)
{
  uint64_t v9 = *(void ***)(a1 + 24);
  v9[1] = (char *)v9[1] + 1;
  sub_10006F824((uint64_t)v10, (uint64_t *)&v9, 1uLL);
  sub_10006C608(&v9);
  uint64_t v7 = v11;
  *unint64_t v11 = a2;
  v7[1] = a3;
  *((_DWORD *)v7 + 4) = *a4;
  unint64_t v11 = 0LL;
  sub_10006FF28((uint64_t)v10);
  sub_10006C608(v10);
  return v7;
}

void sub_10006F810( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
}

uint64_t sub_10006F824(uint64_t a1, uint64_t *a2, unint64_t a3)
{
  uint64_t v4 = *a2;
  *(void *)(v4 + std::istream::~istream(v2, v3 + 8) = *(void *)(*a2 + 8) + 1LL;
  *(void *)a1 = v4;
  *(void *)(a1 + std::istream::~istream(v2, v3 + 8) = a3;
  *(void *)(a1 + 16) = sub_10006F87C((uint64_t **)a1, a3);
  return a1;
}

void sub_10006F868(_Unwind_Exception *a1)
{
}

char *sub_10006F87C(uint64_t **a1, unint64_t a2)
{
  if (a2 == 2)
  {
    uint64_t v2 = sub_10006B848(*a1);
    uint64_t result = (char *)v2[7];
    if (!result)
    {
      uint64_t result = sub_10002BED8(v2 + 1, 1LL);
      *((void *)result + 6) = 0LL;
      return result;
    }

    uint64_t v4 = *((void *)result + 6);
    goto LABEL_26;
  }

  if (a2 == 1)
  {
    uint64_t v2 = sub_10006B5C8(*a1);
    uint64_t result = (char *)v2[7];
    if (!result)
    {
      uint64_t result = sub_10006FA3C(v2 + 1, 1LL);
      *((void *)result + 3) = 0LL;
      return result;
    }

    uint64_t v4 = *((void *)result + 3);
LABEL_26:
    v2[7] = v4;
    return result;
  }

  if (a2 <= 4)
  {
    uint64_t v2 = sub_10006B96C(*a1);
    uint64_t result = (char *)v2[7];
    if (!result)
    {
      uint64_t result = sub_10006FB04(v2 + 1, 1LL);
      *((void *)result + 12) = 0LL;
      return result;
    }

    uint64_t v4 = *((void *)result + 12);
    goto LABEL_26;
  }

  if (a2 <= 8)
  {
    uint64_t v2 = sub_10006BBF0(*a1);
    uint64_t result = (char *)v2[7];
    if (!result)
    {
      uint64_t result = sub_10006FBD8(v2 + 1, 1LL);
      *((void *)result + ++*(void *)(result + 24) = 0LL;
      return result;
    }

    uint64_t v4 = *((void *)result + 24);
    goto LABEL_26;
  }

  if (a2 <= 0x10)
  {
    uint64_t v2 = sub_10006BE74(*a1);
    uint64_t result = (char *)v2[7];
    if (!result)
    {
      uint64_t result = sub_10006FCAC(v2 + 1, 1LL);
      *((void *)result + 4std::istream::~istream(v2, v3 + 8) = 0LL;
      return result;
    }

    uint64_t v4 = *((void *)result + 48);
    goto LABEL_26;
  }

  if (a2 <= 0x20)
  {
    uint64_t v2 = sub_10006C0F8(*a1);
    uint64_t result = (char *)v2[7];
    if (!result)
    {
      uint64_t result = sub_10006FD80(v2 + 1, 1LL);
      *((void *)result + 96) = 0LL;
      return result;
    }

    uint64_t v4 = *((void *)result + 96);
    goto LABEL_26;
  }

  if (a2 <= 0x40)
  {
    uint64_t v2 = sub_10006C380(*a1);
    uint64_t result = (char *)v2[7];
    if (!result)
    {
      uint64_t result = sub_10006FE54(v2 + 1, 1LL);
      *((void *)result + 192) = 0LL;
      return result;
    }

    uint64_t v4 = *((void *)result + 192);
    goto LABEL_26;
  }

  if (a2 >= 0xAAAAAAAAAAAAAABLL) {
    sub_100017F08();
  }
  return (char *)operator new(24 * a2);
}

char *sub_10006FA3C(void *a1, uint64_t a2)
{
  uint64_t v2 = a1;
  uint64_t v3 = 32 * a2;
  size_t v4 = a1[1];
  if (v4 >= a2 << 7)
  {
    uint64_t v9 = v2[2];
    if (v9 + v3 <= v4)
    {
      uint64_t v10 = *(char **)(v2[4] + 16LL);
    }

    else
    {
      uint64_t v10 = (char *)operator new[](v4);
      v2[2] = 0LL;
      unint64_t v11 = operator new(0x18uLL);
      uint64_t v9 = 0LL;
      uint64_t v12 = (void *)v2[4];
      uint64_t v13 = v2[5];
      *unint64_t v11 = v2 + 3;
      v11[1] = v12;
      v11[2] = v10;
      *uint64_t v12 = v11;
      v2[4] = v11;
      void v2[5] = v13 + 1;
    }

    uint64_t v5 = &v10[v9];
    uint64_t v8 = v9 + v3;
  }

  else
  {
    uint64_t v5 = (char *)operator new[](32 * a2);
    unint64_t v6 = operator new(0x18uLL);
    uint64_t v7 = v2[3];
    v2 += 3;
    v6[1] = v2;
    _DWORD v6[2] = v5;
    void *v6 = v7;
    *(void *)(v7 + std::istream::~istream(v2, v3 + 8) = v6;
    void *v2 = v6;
    uint64_t v8 = v2[2] + 1LL;
  }

  v2[2] = v8;
  return v5;
}

char *sub_10006FB04(void *a1, uint64_t a2)
{
  uint64_t v2 = a1;
  uint64_t v3 = 104 * a2;
  size_t v4 = a1[1];
  if (416 * a2 <= v4)
  {
    uint64_t v9 = v2[2];
    if (v9 + v3 <= v4)
    {
      uint64_t v10 = *(char **)(v2[4] + 16LL);
    }

    else
    {
      uint64_t v10 = (char *)operator new[](v4);
      v2[2] = 0LL;
      unint64_t v11 = operator new(0x18uLL);
      uint64_t v9 = 0LL;
      uint64_t v12 = (void *)v2[4];
      uint64_t v13 = v2[5];
      *unint64_t v11 = v2 + 3;
      v11[1] = v12;
      v11[2] = v10;
      *uint64_t v12 = v11;
      v2[4] = v11;
      void v2[5] = v13 + 1;
    }

    uint64_t v5 = &v10[v9];
    uint64_t v8 = v9 + v3;
  }

  else
  {
    uint64_t v5 = (char *)operator new[](104 * a2);
    unint64_t v6 = operator new(0x18uLL);
    uint64_t v7 = v2[3];
    v2 += 3;
    v6[1] = v2;
    _DWORD v6[2] = v5;
    void *v6 = v7;
    *(void *)(v7 + std::istream::~istream(v2, v3 + 8) = v6;
    void *v2 = v6;
    uint64_t v8 = v2[2] + 1LL;
  }

  v2[2] = v8;
  return v5;
}

char *sub_10006FBD8(void *a1, uint64_t a2)
{
  uint64_t v2 = a1;
  uint64_t v3 = 200 * a2;
  size_t v4 = a1[1];
  if (800 * a2 <= v4)
  {
    uint64_t v9 = v2[2];
    if (v9 + v3 <= v4)
    {
      uint64_t v10 = *(char **)(v2[4] + 16LL);
    }

    else
    {
      uint64_t v10 = (char *)operator new[](v4);
      v2[2] = 0LL;
      unint64_t v11 = operator new(0x18uLL);
      uint64_t v9 = 0LL;
      uint64_t v12 = (void *)v2[4];
      uint64_t v13 = v2[5];
      *unint64_t v11 = v2 + 3;
      v11[1] = v12;
      v11[2] = v10;
      *uint64_t v12 = v11;
      v2[4] = v11;
      void v2[5] = v13 + 1;
    }

    uint64_t v5 = &v10[v9];
    uint64_t v8 = v9 + v3;
  }

  else
  {
    uint64_t v5 = (char *)operator new[](200 * a2);
    unint64_t v6 = operator new(0x18uLL);
    uint64_t v7 = v2[3];
    v2 += 3;
    v6[1] = v2;
    _DWORD v6[2] = v5;
    void *v6 = v7;
    *(void *)(v7 + std::istream::~istream(v2, v3 + 8) = v6;
    void *v2 = v6;
    uint64_t v8 = v2[2] + 1LL;
  }

  v2[2] = v8;
  return v5;
}

char *sub_10006FCAC(void *a1, uint64_t a2)
{
  uint64_t v2 = a1;
  uint64_t v3 = 392 * a2;
  size_t v4 = a1[1];
  if (1568 * a2 <= v4)
  {
    uint64_t v9 = v2[2];
    if (v9 + v3 <= v4)
    {
      uint64_t v10 = *(char **)(v2[4] + 16LL);
    }

    else
    {
      uint64_t v10 = (char *)operator new[](v4);
      v2[2] = 0LL;
      unint64_t v11 = operator new(0x18uLL);
      uint64_t v9 = 0LL;
      uint64_t v12 = (void *)v2[4];
      uint64_t v13 = v2[5];
      *unint64_t v11 = v2 + 3;
      v11[1] = v12;
      v11[2] = v10;
      *uint64_t v12 = v11;
      v2[4] = v11;
      void v2[5] = v13 + 1;
    }

    uint64_t v5 = &v10[v9];
    uint64_t v8 = v9 + v3;
  }

  else
  {
    uint64_t v5 = (char *)operator new[](392 * a2);
    unint64_t v6 = operator new(0x18uLL);
    uint64_t v7 = v2[3];
    v2 += 3;
    v6[1] = v2;
    _DWORD v6[2] = v5;
    void *v6 = v7;
    *(void *)(v7 + std::istream::~istream(v2, v3 + 8) = v6;
    void *v2 = v6;
    uint64_t v8 = v2[2] + 1LL;
  }

  v2[2] = v8;
  return v5;
}

char *sub_10006FD80(void *a1, uint64_t a2)
{
  uint64_t v2 = a1;
  uint64_t v3 = 776 * a2;
  size_t v4 = a1[1];
  if (3104 * a2 <= v4)
  {
    uint64_t v9 = v2[2];
    if (v9 + v3 <= v4)
    {
      uint64_t v10 = *(char **)(v2[4] + 16LL);
    }

    else
    {
      uint64_t v10 = (char *)operator new[](v4);
      v2[2] = 0LL;
      unint64_t v11 = operator new(0x18uLL);
      uint64_t v9 = 0LL;
      uint64_t v12 = (void *)v2[4];
      uint64_t v13 = v2[5];
      *unint64_t v11 = v2 + 3;
      v11[1] = v12;
      v11[2] = v10;
      *uint64_t v12 = v11;
      v2[4] = v11;
      void v2[5] = v13 + 1;
    }

    uint64_t v5 = &v10[v9];
    uint64_t v8 = v9 + v3;
  }

  else
  {
    uint64_t v5 = (char *)operator new[](776 * a2);
    unint64_t v6 = operator new(0x18uLL);
    uint64_t v7 = v2[3];
    v2 += 3;
    v6[1] = v2;
    _DWORD v6[2] = v5;
    void *v6 = v7;
    *(void *)(v7 + std::istream::~istream(v2, v3 + 8) = v6;
    void *v2 = v6;
    uint64_t v8 = v2[2] + 1LL;
  }

  v2[2] = v8;
  return v5;
}

char *sub_10006FE54(void *a1, uint64_t a2)
{
  uint64_t v2 = a1;
  uint64_t v3 = 1544 * a2;
  size_t v4 = a1[1];
  if (6176 * a2 <= v4)
  {
    uint64_t v9 = v2[2];
    if (v9 + v3 <= v4)
    {
      uint64_t v10 = *(char **)(v2[4] + 16LL);
    }

    else
    {
      uint64_t v10 = (char *)operator new[](v4);
      v2[2] = 0LL;
      unint64_t v11 = operator new(0x18uLL);
      uint64_t v9 = 0LL;
      uint64_t v12 = (void *)v2[4];
      uint64_t v13 = v2[5];
      *unint64_t v11 = v2 + 3;
      v11[1] = v12;
      v11[2] = v10;
      *uint64_t v12 = v11;
      v2[4] = v11;
      void v2[5] = v13 + 1;
    }

    uint64_t v5 = &v10[v9];
    uint64_t v8 = v9 + v3;
  }

  else
  {
    uint64_t v5 = (char *)operator new[](1544 * a2);
    unint64_t v6 = operator new(0x18uLL);
    uint64_t v7 = v2[3];
    v2 += 3;
    v6[1] = v2;
    _DWORD v6[2] = v5;
    void *v6 = v7;
    *(void *)(v7 + std::istream::~istream(v2, v3 + 8) = v6;
    void *v2 = v6;
    uint64_t v8 = v2[2] + 1LL;
  }

  v2[2] = v8;
  return v5;
}

void sub_10006FF28(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 16);
  if (v1) {
    sub_10006B4BC((uint64_t **)a1, v1, *(void *)(a1 + 8));
  }
}

void sub_10006FF4C(uint64_t a1, unint64_t a2, void *a3)
{
  unint64_t v3 = (uint64_t)(*(void *)(a1 + 8) - *(void *)a1) >> 3;
  if (a2 <= v3)
  {
    if (a2 < v3) {
      *(void *)(a1 + std::istream::~istream(v2, v3 + 8) = *(void *)a1 + 8 * a2;
    }
  }

  else
  {
    sub_10006FF7C((void **)a1, a2 - v3, a3);
  }

void sub_10006FF7C(void **a1, unint64_t a2, void *a3)
{
  uint64_t v8 = a1[2];
  uint64_t v6 = (uint64_t)(a1 + 2);
  uint64_t v7 = v8;
  uint64_t v9 = *(void **)(v6 - 8);
  if (a2 <= (v8 - (_BYTE *)v9) >> 3)
  {
    if (a2)
    {
      uint64_t v16 = 8 * a2;
      unint64_t v17 = &v9[a2];
      do
      {
        *v9++ = *a3;
        v16 -= 8LL;
      }

      while (v16);
      uint64_t v9 = v17;
    }

    a1[1] = v9;
  }

  else
  {
    uint64_t v10 = (char *)v9 - (_BYTE *)*a1;
    unint64_t v11 = a2 + (v10 >> 3);
    if (v11 >> 61) {
      sub_100018774();
    }
    uint64_t v12 = v10 >> 3;
    uint64_t v13 = v7 - (_BYTE *)*a1;
    if (v13 >> 2 > v11) {
      unint64_t v11 = v13 >> 2;
    }
    else {
      unint64_t v14 = v11;
    }
    if (v14) {
      uint64_t v15 = (char *)sub_100018788(v6, v14);
    }
    else {
      uint64_t v15 = 0LL;
    }
    uint64_t v18 = &v15[8 * v12];
    __int128 v19 = &v18[8 * a2];
    uint64_t v20 = 8 * a2;
    uint64_t v21 = v18;
    do
    {
      *(void *)uint64_t v21 = *a3;
      v21 += 8;
      v20 -= 8LL;
    }

    while (v20);
    __int128 v22 = &v15[8 * v14];
    uint64_t v24 = (char *)*a1;
    int v23 = (char *)a1[1];
    if (v23 != *a1)
    {
      do
      {
        uint64_t v25 = *((void *)v23 - 1);
        v23 -= 8;
        *((void *)v18 - 1) = v25;
        v18 -= 8;
      }

      while (v23 != v24);
      int v23 = (char *)*a1;
    }

    *a1 = v18;
    a1[1] = v19;
    a1[2] = v22;
    if (v23) {
      operator delete(v23);
    }
  }

void *sub_100070094(void *a1, uint64_t *a2, uint64_t a3)
{
  *a1 = sub_100065764(*a2, a3);
  a1[1] = sub_100065764(a2[1], a3);
  a1[2] = (*(uint64_t (**)(void))(*(void *)*a1 + 72LL))(*a1);
  a1[3] = -1LL;
  *((_BYTE *)a1 + 32) = -1;
  return a1;
}

void sub_100070100(_Unwind_Exception *exception_object)
{
  uint64_t v3 = v1[1];
  v1[1] = 0LL;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8LL))(v3);
  }
  uint64_t v4 = *v1;
  uint64_t *v1 = 0LL;
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 8LL))(v4);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100070144(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = operator new(1uLL);
  *(void *)(a1 + std::istream::~istream(v2, v3 + 8) = operator new(1uLL);
  *(void *)(a1 + 16) = a1;
  *(void *)(a1 + ++*(void *)(result + 24) = a1;
  sub_10006CA58(a1 + 32, *(void *)(a2 + 72), (void *)(a1 + 16), (void *)(a1 + 24));
  *(void *)(a1 + 104) = 0LL;
  *(void *)(a1 + 112) = 0LL;
  *(void *)(a1 + 12RDString::RDString((RDString *)&v66, theString, 0) = 0LL;
  sub_100070258( (char *)(a1 + 104),  *(uint64_t **)(a2 + 104),  *(uint64_t **)(a2 + 112),  0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a2 + 112) - *(void *)(a2 + 104)) >> 2));
  return a1;
}

void sub_1000701F4(_Unwind_Exception *a1)
{
  uint64_t v4 = *(void **)(v1 + 8);
  *(void *)(v1 + std::istream::~istream(v2, v3 + 8) = 0LL;
  if (v4) {
    operator delete(v4);
  }
  uint64_t v5 = *(void **)v1;
  *(void *)uint64_t v1 = 0LL;
  if (v5) {
    operator delete(v5);
  }
  _Unwind_Resume(a1);
}

char *sub_100070258(char *result, uint64_t *a2, uint64_t *a3, unint64_t a4)
{
  if (a4)
  {
    uint64_t v6 = result;
    uint64_t result = sub_1000702D4(result, a4);
    uint64_t v7 = *((void *)v6 + 1);
    while (a2 != a3)
    {
      uint64_t v8 = *a2;
      *(_DWORD *)(v7 + std::istream::~istream(v2, v3 + 8) = *((_DWORD *)a2 + 2);
      *(void *)uint64_t v7 = v8;
      v7 += 12LL;
      a2 = (uint64_t *)((char *)a2 + 12);
    }

    *((void *)v6 + 1) = v7;
  }

  return result;
}

void sub_1000702B8(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + std::istream::~istream(v2, v3 + 8) = v3;
    operator delete(v3);
  }

  _Unwind_Resume(exception_object);
}

char *sub_1000702D4(void *a1, unint64_t a2)
{
  if (a2 >= 0x1555555555555556LL) {
    sub_100018774();
  }
  uint64_t result = (char *)sub_10006E818((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[12 * v4];
  return result;
}

char *sub_100070324(uint64_t a1, int *a2, _DWORD *a3)
{
  unsigned int v7 = *a2;
  if (*a2 < -1)
  {
    unint64_t v10 = 0LL;
  }

  else
  {
    uint64_t v8 = *(void *)(a1 + 48);
    if (v7 == -1) {
      uint64_t v9 = *(int **)(v8 + 128);
    }
    else {
      uint64_t v9 = (int *)(*(void *)(v8 + 104) + 12LL * v7);
    }
    unint64_t v10 = *v9 + 7853LL * v9[1] + 7867LL * *((char *)v9 + 8);
  }

  unint64_t v11 = *(void *)(a1 + 8);
  if (v11)
  {
    uint8x8_t v12 = (uint8x8_t)vcnt_s8((int8x8_t)v11);
    v12.i16[0] = vaddlv_u8(v12);
    unint64_t v13 = v12.u32[0];
    if (v12.u32[0] > 1uLL)
    {
      unint64_t v3 = v10;
      if (v10 >= v11) {
        unint64_t v3 = v10 % v11;
      }
    }

    else
    {
      unint64_t v3 = (v11 - 1) & v10;
    }

    unint64_t v14 = *(char ***)(*(void *)a1 + 8 * v3);
    if (v14)
    {
      for (uint64_t i = *v14; i; uint64_t i = *(char **)i)
      {
        unint64_t v16 = *((void *)i + 1);
        if (v16 == v10)
        {
        }

        else
        {
          if (v13 > 1)
          {
            if (v16 >= v11) {
              v16 %= v11;
            }
          }

          else
          {
            v16 &= v11 - 1;
          }

          if (v16 != v3) {
            break;
          }
        }
      }
    }
  }

  uint64_t i = sub_100070674((uint64_t **)(a1 + 32), 1uLL);
  *(void *)uint64_t i = 0LL;
  *((void *)i + 1) = v10;
  *((_DWORD *)i + 4) = *a3;
  float v17 = (float)(unint64_t)(*(void *)(a1 + 40) + 1LL);
  float v18 = *(float *)(a1 + 56);
  if (!v11 || (float)(v18 * (float)v11) < v17)
  {
    BOOL v19 = 1LL;
    if (v11 >= 3) {
      BOOL v19 = (v11 & (v11 - 1)) != 0;
    }
    unint64_t v20 = v19 | (2 * v11);
    unint64_t v21 = vcvtps_u32_f32(v17 / v18);
    if (v20 <= v21) {
      size_t v22 = v21;
    }
    else {
      size_t v22 = v20;
    }
    sub_10006D600(a1, v22);
    unint64_t v11 = *(void *)(a1 + 8);
    if ((v11 & (v11 - 1)) != 0)
    {
      if (v10 >= v11) {
        unint64_t v3 = v10 % v11;
      }
      else {
        unint64_t v3 = v10;
      }
    }

    else
    {
      unint64_t v3 = (v11 - 1) & v10;
    }
  }

  int v23 = *(char ***)(*(void *)a1 + 8 * v3);
  if (v23)
  {
    *(void *)uint64_t i = *v23;
LABEL_44:
    *int v23 = i;
    goto LABEL_45;
  }

  *(void *)uint64_t i = *(void *)(a1 + 24);
  *(void *)(a1 + ++*(void *)(result + 24) = i;
  *(void *)(*(void *)a1 + 8 * v3) = a1 + 24;
  if (*(void *)i)
  {
    unint64_t v24 = *(void *)(*(void *)i + 8LL);
    if ((v11 & (v11 - 1)) != 0)
    {
      if (v24 >= v11) {
        v24 %= v11;
      }
    }

    else
    {
      v24 &= v11 - 1;
    }

    int v23 = (char **)(*(void *)a1 + 8 * v24);
    goto LABEL_44;
  }

void sub_1000705BC(_Unwind_Exception *a1)
{
}

BOOL sub_1000705D8(uint64_t *a1, int a2, int a3)
{
  if (a2 == a3) {
    return 1LL;
  }
  BOOL result = 0LL;
  if (a2 >= -1 && a3 >= -1)
  {
    uint64_t v5 = *a1;
    if (a2 == -1) {
      uint64_t v6 = *(void *)(v5 + 128);
    }
    else {
      uint64_t v6 = *(void *)(v5 + 104) + 12LL * a2;
    }
    if (a3 == -1) {
      uint64_t v7 = *(void *)(v5 + 128);
    }
    else {
      uint64_t v7 = *(void *)(v5 + 104) + 12LL * a3;
    }
    if (v6 == v7) {
      return 1LL;
    }
    return *(_DWORD *)v6 == *(_DWORD *)v7
        && *(_DWORD *)(v6 + 4) == *(_DWORD *)(v7 + 4)
        && *(unsigned __int8 *)(v6 + 8) == *(unsigned __int8 *)(v7 + 8);
  }

  return result;
}

char *sub_100070674(uint64_t **a1, unint64_t a2)
{
  if (a2 == 2)
  {
    uint64_t v2 = sub_10006E138(*a1);
    BOOL result = (char *)v2[7];
    if (!result)
    {
      BOOL result = sub_10002BED8(v2 + 1, 1LL);
      *((void *)result + 6) = 0LL;
      return result;
    }

    uint64_t v4 = *((void *)result + 6);
    goto LABEL_26;
  }

  if (a2 == 1)
  {
    uint64_t v2 = sub_10006E014(*a1);
    BOOL result = (char *)v2[7];
    if (!result)
    {
      BOOL result = sub_10006FA3C(v2 + 1, 1LL);
      *((void *)result + 3) = 0LL;
      return result;
    }

    uint64_t v4 = *((void *)result + 3);
LABEL_26:
    v2[7] = v4;
    return result;
  }

  if (a2 <= 4)
  {
    uint64_t v2 = sub_10006E25C(*a1);
    BOOL result = (char *)v2[7];
    if (!result)
    {
      BOOL result = sub_10006FB04(v2 + 1, 1LL);
      *((void *)result + 12) = 0LL;
      return result;
    }

    uint64_t v4 = *((void *)result + 12);
    goto LABEL_26;
  }

  if (a2 <= 8)
  {
    uint64_t v2 = sub_10006E380(*a1);
    BOOL result = (char *)v2[7];
    if (!result)
    {
      BOOL result = sub_10006FBD8(v2 + 1, 1LL);
      *((void *)result + ++*(void *)(result + 24) = 0LL;
      return result;
    }

    uint64_t v4 = *((void *)result + 24);
    goto LABEL_26;
  }

  if (a2 <= 0x10)
  {
    uint64_t v2 = sub_10006E4A4(*a1);
    BOOL result = (char *)v2[7];
    if (!result)
    {
      BOOL result = sub_10006FCAC(v2 + 1, 1LL);
      *((void *)result + 4std::istream::~istream(v2, v3 + 8) = 0LL;
      return result;
    }

    uint64_t v4 = *((void *)result + 48);
    goto LABEL_26;
  }

  if (a2 <= 0x20)
  {
    uint64_t v2 = sub_10006E5C8(*a1);
    BOOL result = (char *)v2[7];
    if (!result)
    {
      BOOL result = sub_10006FD80(v2 + 1, 1LL);
      *((void *)result + 96) = 0LL;
      return result;
    }

    uint64_t v4 = *((void *)result + 96);
    goto LABEL_26;
  }

  if (a2 <= 0x40)
  {
    uint64_t v2 = sub_10006E6F0(*a1);
    BOOL result = (char *)v2[7];
    if (!result)
    {
      BOOL result = sub_10006FE54(v2 + 1, 1LL);
      *((void *)result + 192) = 0LL;
      return result;
    }

    uint64_t v4 = *((void *)result + 192);
    goto LABEL_26;
  }

  if (a2 >= 0xAAAAAAAAAAAAAABLL) {
    sub_100017F08();
  }
  return (char *)operator new(24 * a2);
}

uint64_t ***sub_100070834(uint64_t ***result, uint64_t a2)
{
  if (a2)
  {
    BOOL result = (uint64_t ***)sub_10006E014(**result);
    *(void *)(a2 + ++*(void *)(result + 24) = result[7];
    result[7] = (uint64_t **)a2;
  }

  return result;
}

int *sub_100070870(int *result, uint64_t a2, int a3, _BYTE *a4)
{
  uint64_t v5 = result;
  if (result[6] != (_DWORD)a2 || result[7] != a3 || *a4 != *((_BYTE *)result + 32))
  {
    result[6] = a2;
    result[7] = a3;
    *((_BYTE *)result + 32) = *a4;
    uint64_t v6 = (*(uint64_t (**)(void, uint64_t))(**((void **)result + 2) + 32LL))(*((void *)result + 2), a2);
    uint64_t v7 = (*(uint64_t (**)(void, uint64_t))(**((void **)v5 + 2) + 48LL))(*((void *)v5 + 2), a2);
    (*(void (**)(uint64_t *__return_ptr, void, uint64_t))(**((void **)v5 + 2) + 24LL))( &v10,  *((void *)v5 + 2),  a2);
    BOOL result = sub_10002ADB0();
    int v11 = v10;
    HIDWORD(v1RDString::RDString((RDString *)&v66, theString, 0) = *result;
    BOOL v9 = *(float *)&v10 == *((float *)&v10 + 1) && v6 == v7;
    *((_BYTE *)v5 + 33) = v9;
    *((_BYTE *)v5 + 34) = v7 == 0;
  }

  return result;
}

uint64_t sub_100070954(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v3 = *(_DWORD *)(a1 + 188);
  if (v3 == 1) {
    return 1LL;
  }
  if (v3 == 2) {
    return 0LL;
  }
  uint64_t v7 = sub_100065BF4(*(void *)(a1 + 144), a2);
  uint64_t v8 = sub_100065BF4(*(void *)(a1 + 152), a3);
  if (v7 == -1 && v8 == -1)
  {
    if (byte_1000DDAF8) {
      sub_10000A2DC(__p, "FATAL");
    }
    else {
      sub_10000A2DC(__p, "ERROR");
    }
    sub_10002A9EC(&v14, (uint64_t)__p);
    sub_10002A6A4(&std::cerr, (uint64_t)"ComposeFst: Both sides can't require match", 42LL);
    sub_10002AA94(&v14);
    if (v13 < 0) {
      operator delete(__p[0]);
    }
    *(void *)(a1 + 8) |= 4uLL;
    return 1LL;
  }

  BOOL v11 = v8 == -1 || v7 <= v8;
  return v7 != -1 && v11;
}

void sub_100070A68( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, int a15, __int16 a16, char a17, char a18)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100070AA0(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, int a8)
{
  if (*(_DWORD *)(a7 + 52) != (_DWORD)a4)
  {
    *(_DWORD *)(a7 + 52) = a4;
    sub_100067958(*(void *)(a7 + 8), a4);
    *(_BYTE *)(a7 + ++*(void *)(result + 56) = *(_DWORD *)(a7 + 20) != -1;
  }

  int v14 = *sub_10002AD60();
  v19[0] = a8 - 1;
  v19[1] = a8 << 31 >> 31;
  v19[2] = v14;
  v19[3] = a6;
  sub_100070C64(a1, a2, a7, v19, a8);
  unint64_t v18 = 0LL;
  __int128 v16 = 0u;
  __int128 v17 = 0u;
  (*(void (**)(uint64_t, uint64_t, __int128 *))(*(void *)a5 + 120LL))(a5, a6, &v16);
  while (1)
  {
    if (!(void)v16)
    {
LABEL_9:
      uint64_t v15 = (int *)(*((void *)&v16 + 1) + 16 * v18);
      goto LABEL_10;
    }

    if (!(void)v16) {
      goto LABEL_9;
    }
    uint64_t v15 = (int *)(*(uint64_t (**)(void))(*(void *)v16 + 24LL))();
LABEL_10:
    sub_100070C64(a1, a2, a7, v15, a8);
    if ((void)v16) {
      (*(void (**)(void))(*(void *)v16 + 32LL))(v16);
    }
    else {
      ++v18;
    }
  }

  if ((void)v16)
  {
    (*(void (**)(void))(*(void *)v16 + 8LL))();
    goto LABEL_17;
  }

void sub_100070C38( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  if (a9) {
    (*(void (**)(uint64_t))(*(void *)a9 + 8LL))(a9);
  }
  else {
    sub_100097C1C((uint64_t)&a9);
  }
  _Unwind_Resume(a1);
}

BOOL sub_100070C64(uint64_t a1, int a2, uint64_t a3, int *a4, int a5)
{
  uint64_t v10 = a4 + 1;
  if (!a5) {
    uint64_t v10 = a4;
  }
  BOOL result = sub_100065820(a3, *v10);
  if (result)
  {
    for (BOOL result = sub_100066E0C(*(void *)(*(void *)(*(void *)(a3 + 8) + 8LL) + 8LL));
          !result;
          BOOL result = sub_100066E0C(*(void *)(*(void *)(*(void *)(a3 + 8) + 8LL) + 8LL)))
    {
      uint8x8_t v12 = sub_100065974(a3);
      unint64_t v13 = *v12;
      unint64_t v31 = *v12;
      int v32 = *((_DWORD *)v12 + 2);
      int v33 = *((_DWORD *)v12 + 3);
      unint64_t v14 = *(void *)a4;
      unint64_t v28 = *(void *)a4;
      int v29 = a4[2];
      int v30 = a4[3];
      if (a5)
      {
        unint64_t v15 = HIDWORD(v14);
        __int128 v16 = *(unsigned __int8 **)(a1 + 136);
        if ((_DWORD)v15 != -1)
        {
          if ((_DWORD)v13 == -1)
          {
            int v17 = v16[32];
            if (v16[32]) {
              char v18 = -1;
            }
            else {
              char v18 = 0;
            }
            char v27 = v18;
            if (v17) {
              goto LABEL_35;
            }
          }

          else
          {
            if ((_DWORD)v15) {
              char v23 = 0;
            }
            else {
              char v23 = -1;
            }
            char v27 = v23;
            if (!(_DWORD)v15) {
              goto LABEL_35;
            }
          }

void sub_100070E04(uint64_t a1, int a2)
{
  uint64_t v4 = sub_100071228(*(void *)(a1 + 120), a2);
  sub_100071A40(*(void *)(a1 + 120), (uint64_t)v4);
  uint64_t v5 = *((void *)v4 + 3);
  uint64_t v6 = *((void *)v4 + 4) - v5;
  if (v6)
  {
    unint64_t v7 = v6 >> 4;
    int v8 = *(_DWORD *)(a1 + 64);
    if (v7 <= 1) {
      unint64_t v7 = 1LL;
    }
    BOOL v9 = (int *)(v5 + 12);
    do
    {
      int v11 = *v9;
      v9 += 4;
      int v10 = v11;
      if (v11 >= v8)
      {
        int v8 = v10 + 1;
        *(_DWORD *)(a1 + 64) = v10 + 1;
      }

      --v7;
    }

    while (v7);
  }

  sub_100071AB8(a1, a2);
  *((_DWORD *)v4 + 14) |= 0xAu;
}

void *sub_100070E9C(uint64_t a1, int a2, float *a3, uint64_t a4, char *a5)
{
  int v7 = *(_DWORD *)(a4 + 12);
  *(float *)&uint64_t v19 = a3[3];
  HIDWORD(v19) = v7;
  char v20 = *a5;
  float v8 = *a3;
  int v9 = *(_DWORD *)(a4 + 4);
  float v10 = a3[2];
  if (v10 == -INFINITY || (float v11 = *(float *)(a4 + 8), v11 >= -INFINITY) && v11 <= -INFINITY)
  {
    float v12 = *(float *)sub_1000606CC();
  }

  else
  {
    BOOL v13 = v11 == INFINITY || v10 == INFINITY;
    float v14 = v10 + v11;
    if (v13) {
      float v12 = INFINITY;
    }
    else {
      float v12 = v14;
    }
  }

  int v15 = sub_100070F74(*(void **)(a1 + 176), &v19, 1);
  *(float *)char v18 = v8;
  v18[1] = v9;
  *(float *)&v18[2] = v12;
  v18[3] = v15;
  __int128 v16 = sub_100071228(*(void *)(a1 + 120), a2);
  return sub_10007192C((void *)v16 + 3, (uint64_t)v18);
}

uint64_t sub_100070F74(void *a1, uint64_t *a2, int a3)
{
  a1[16] = a2;
  uint64_t v4 = a1 + 4;
  if (!a3)
  {
    uint64_t v6 = sub_1000710EC(v4, &dword_1000AE73C);
    if (!v6) {
      return 0xFFFFFFFFLL;
    }
    return v6[4];
  }

  uint64_t v6 = sub_100070324((uint64_t)v4, &dword_1000AE73C, &dword_1000AE73C);
  if (!v7) {
    return v6[4];
  }
  uint64_t v8 = a1[13];
  unint64_t v9 = a1[14];
  uint64_t v10 = (uint64_t)(v9 - v8) / 12;
  void v6[4] = v10;
  unint64_t v11 = a1[15];
  if (v9 >= v11)
  {
    unint64_t v14 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v11 - v8) >> 2);
    uint64_t v15 = 2 * v14;
    if (2 * v14 <= v10 + 1) {
      uint64_t v15 = v10 + 1;
    }
    if (v14 >= 0xAAAAAAAAAAAAAAALL) {
      unint64_t v16 = 0x1555555555555555LL;
    }
    else {
      unint64_t v16 = v15;
    }
    if (v16) {
      int v17 = (char *)sub_10006E818((uint64_t)(a1 + 15), v16);
    }
    else {
      int v17 = 0LL;
    }
    char v18 = &v17[12 * v10];
    uint64_t v19 = &v17[12 * v16];
    uint64_t v20 = *a2;
    *((_DWORD *)v18 + 2) = *((_DWORD *)a2 + 2);
    *(void *)char v18 = v20;
    BOOL v13 = v18 + 12;
    char v22 = (_DWORD *)a1[13];
    int v21 = (_DWORD *)a1[14];
    if (v21 != v22)
    {
      do
      {
        uint64_t v23 = *(void *)(v21 - 3);
        v21 -= 3;
        int v24 = v21[2];
        *(void *)(v18 - 12) = v23;
        v18 -= 12;
        *((_DWORD *)v18 + 2) = v24;
      }

      while (v21 != v22);
      int v21 = (_DWORD *)a1[13];
    }

    a1[13] = v18;
    a1[14] = v13;
    a1[15] = v19;
    if (v21) {
      operator delete(v21);
    }
  }

  else
  {
    uint64_t v12 = *a2;
    *(_DWORD *)(v9 + std::istream::~istream(v2, v3 + 8) = *((_DWORD *)a2 + 2);
    *(void *)unint64_t v9 = v12;
    BOOL v13 = (char *)(v9 + 12);
  }

  a1[14] = v13;
  return v10;
}

uint64_t *sub_1000710EC(void *a1, int *a2)
{
  unsigned int v3 = *a2;
  if (*a2 < -1)
  {
    unint64_t v6 = 0LL;
  }

  else
  {
    uint64_t v4 = a1[6];
    if (v3 == -1) {
      uint64_t v5 = *(int **)(v4 + 128);
    }
    else {
      uint64_t v5 = (int *)(*(void *)(v4 + 104) + 12LL * v3);
    }
    unint64_t v6 = *v5 + 7853LL * v5[1] + 7867LL * *((char *)v5 + 8);
  }

  int8x8_t v7 = (int8x8_t)a1[1];
  if (!*(void *)&v7) {
    return 0LL;
  }
  uint8x8_t v8 = (uint8x8_t)vcnt_s8(v7);
  v8.i16[0] = vaddlv_u8(v8);
  unint64_t v9 = v8.u32[0];
  if (v8.u32[0] > 1uLL)
  {
    unint64_t v10 = v6;
    if (v6 >= *(void *)&v7) {
      unint64_t v10 = v6 % *(void *)&v7;
    }
  }

  else
  {
    unint64_t v10 = (*(void *)&v7 - 1LL) & v6;
  }

  unint64_t v11 = *(uint64_t ***)(*a1 + 8 * v10);
  if (!v11) {
    return 0LL;
  }
  uint64_t v12 = *v11;
  if (*v11)
  {
    BOOL v13 = a1 + 8;
    do
    {
      unint64_t v14 = v12[1];
      if (v14 == v6)
      {
        if (sub_1000705D8(v13, *((_DWORD *)v12 + 4), *a2)) {
          return v12;
        }
      }

      else
      {
        if (v9 > 1)
        {
          if (v14 >= *(void *)&v7) {
            v14 %= *(void *)&v7;
          }
        }

        else
        {
          v14 &= *(void *)&v7 - 1LL;
        }

        if (v14 != v10) {
          return 0LL;
        }
      }

      uint64_t v12 = (uint64_t *)*v12;
    }

    while (v12);
  }

  return v12;
}

char *sub_100071228(uint64_t a1, int a2)
{
  unsigned int v3 = sub_1000712AC(a1, a2);
  uint64_t v4 = v3;
  if (*(_BYTE *)(a1 + 104))
  {
    int v5 = *((_DWORD *)v3 + 14);
    if ((v5 & 4) == 0)
    {
      *((_DWORD *)v3 + 14) = v5 | 4;
      unint64_t v6 = *((void *)v3 + 4) - *((void *)v3 + 3) + *(void *)(a1 + 128) + 64LL;
      *(void *)(a1 + 12std::istream::~istream(v2, v3 + 8) = v6;
      *(_BYTE *)(a1 + 12RDString::RDString((RDString *)&v66, theString, 0) = 1;
      if (v6 > *(void *)(a1 + 112)) {
        sub_10007137C(a1, v3, 0LL, 0.666);
      }
    }
  }

  return v4;
}

char *sub_1000712AC(uint64_t a1, int a2)
{
  int v3 = *(_DWORD *)(a1 + 92);
  if (v3 == a2) {
    return *(char **)(a1 + 96);
  }
  if (!*(_BYTE *)(a1 + 88)) {
    return sub_10006EDB4(a1, a2 + 1);
  }
  if (v3 == -1)
  {
    *(_DWORD *)(a1 + 92) = a2;
    unint64_t v6 = sub_10006EDB4(a1, 0);
    *(void *)(a1 + 96) = v6;
    *((_DWORD *)v6 + 14) |= 4u;
    sub_100071790((uint64_t)(v6 + 24), 0x80uLL);
    return *(char **)(a1 + 96);
  }

  uint64_t v5 = *(void *)(a1 + 96);
  if (*(_DWORD *)(v5 + 60))
  {
    *(_DWORD *)(v5 + 56) &= ~4u;
    *(_BYTE *)(a1 + 8std::istream::~istream(v2, v3 + 8) = 0;
    return sub_10006EDB4(a1, a2 + 1);
  }

  *(_DWORD *)(a1 + 92) = a2;
  *(_DWORD *)uint64_t v5 = *sub_10002ADB0();
  *(void *)(v5 + ++*(void *)(result + 56) = 0LL;
  *(void *)(v5 + std::istream::~istream(v2, v3 + 8) = 0LL;
  *(void *)(v5 + 16) = 0LL;
  *(void *)(v5 + 32) = *(void *)(v5 + 24);
  BOOL result = *(char **)(a1 + 96);
  *((_DWORD *)result + 14) |= 4u;
  return result;
}

void sub_10007137C(uint64_t a1, char *a2, uint64_t a3, float a4)
{
  if (*(_BYTE *)(a1 + 120))
  {
    if (dword_1000DE7E8 >= 2)
    {
      sub_10000A2DC(__p, "INFO");
      sub_10002A9EC((BOOL *)v42, (uint64_t)__p);
      uint8x8_t v8 = sub_10002A6A4(&std::cerr, (uint64_t)"GCCacheStore: Enter GC: object = ", 33LL);
      unint64_t v9 = sub_10002A6A4(v8, (uint64_t)"(", 1LL);
      unint64_t v10 = (void *)std::ostream::operator<<(v9, a1);
      unint64_t v11 = sub_10002A6A4(v10, (uint64_t)"), free recently cached = ", 26LL);
      uint64_t v12 = (void *)std::ostream::operator<<(v11, a3);
      BOOL v13 = sub_10002A6A4(v12, (uint64_t)", cache size = ", 15LL);
      unint64_t v14 = (void *)std::ostream::operator<<(v13, *(void *)(a1 + 128));
      uint64_t v15 = sub_10002A6A4(v14, (uint64_t)", cache frac = ", 15LL);
      unint64_t v16 = (void *)std::ostream::operator<<(v15, a4);
      int v17 = sub_10002A6A4(v16, (uint64_t)", cache limit = ", 16LL);
      char v18 = (void *)std::ostream::operator<<(v17, *(void *)(a1 + 112));
      sub_10002A6A4(v18, (uint64_t)"\n", 1LL);
      sub_10002AA94(v42);
      if (v47 < 0) {
        operator delete(__p[0]);
      }
    }

    unint64_t v19 = (unint64_t)(float)((float)*(unint64_t *)(a1 + 112) * a4);
    uint64_t v20 = *(void *)(a1 + 40);
LABEL_6:
    *(void *)(a1 + 64) = v20;
    while (v20 != a1 + 32)
    {
      int v21 = *(_DWORD *)(v20 + 16);
      if (v21) {
        int v22 = v21 - 1;
      }
      else {
        int v22 = *(_DWORD *)(a1 + 92);
      }
      uint64_t v23 = sub_1000712AC(a1, v22);
      unint64_t v24 = *(void *)(a1 + 128);
      if (v24 <= v19 || *((_DWORD *)v23 + 15))
      {
LABEL_23:
        *((_DWORD *)v23 + 14) &= ~8u;
        uint64_t v20 = *(void *)(*(void *)(a1 + 64) + 8LL);
        goto LABEL_6;
      }

      if ((a3 & 1) != 0)
      {
        if (v23 == a2) {
          goto LABEL_23;
        }
        int v25 = *((_DWORD *)v23 + 14);
      }

      else
      {
        int v25 = *((_DWORD *)v23 + 14);
        if ((v25 & 8) != 0 || v23 == a2) {
          goto LABEL_23;
        }
      }

      if ((v25 & 4) != 0)
      {
        unint64_t v26 = *((void *)v23 + 4) - *((void *)v23 + 3) + 64LL;
        BOOL v27 = v24 > v26;
        unint64_t v28 = v24 - v26;
        if (v27) {
          *(void *)(a1 + 12std::istream::~istream(v2, v3 + 8) = v28;
        }
      }

      sub_100071894(a1);
      uint64_t v20 = *(void *)(a1 + 64);
    }

    if ((a3 & 1) != 0 || *(void *)(a1 + 128) <= v19)
    {
      unint64_t v29 = *(void *)(a1 + 128);
      if (v19)
      {
        if (v29 > v19)
        {
          uint64_t v30 = *(void *)(a1 + 112);
          do
          {
            v30 *= 2LL;
            BOOL v27 = v29 > 2 * v19;
            v19 *= 2LL;
          }

          while (v27);
          *(void *)(a1 + 112) = v30;
        }
      }

      else if (v29)
      {
        if (byte_1000DDAF8) {
          sub_10000A2DC(__p, "FATAL");
        }
        else {
          sub_10000A2DC(__p, "ERROR");
        }
        sub_10002A9EC(&v45, (uint64_t)__p);
        sub_10002A6A4(&std::cerr, (uint64_t)"GCCacheStore:GC: Unable to free all cached states", 49LL);
        sub_10002AA94(&v45);
        if (v47 < 0) {
          operator delete(__p[0]);
        }
      }
    }

    else
    {
      sub_10007137C(a1, a2, 1LL, a4);
    }

    if (dword_1000DE7E8 >= 2)
    {
      sub_10000A2DC(v42, "INFO");
      sub_10002A9EC(&v44, (uint64_t)v42);
      unint64_t v31 = sub_10002A6A4(&std::cerr, (uint64_t)"GCCacheStore: Exit GC: object = ", 32LL);
      int v32 = sub_10002A6A4(v31, (uint64_t)"(", 1LL);
      int v33 = (void *)std::ostream::operator<<(v32, a1);
      unint64_t v34 = sub_10002A6A4(v33, (uint64_t)"), free recently cached = ", 26LL);
      uint64_t v35 = (void *)std::ostream::operator<<(v34, a3);
      uint64_t v36 = sub_10002A6A4(v35, (uint64_t)", cache size = ", 15LL);
      unsigned int v37 = (void *)std::ostream::operator<<(v36, *(void *)(a1 + 128));
      int v38 = sub_10002A6A4(v37, (uint64_t)", cache frac = ", 15LL);
      uint64_t v39 = (void *)std::ostream::operator<<(v38, a4);
      unint64_t v40 = sub_10002A6A4(v39, (uint64_t)", cache limit = ", 16LL);
      unint64_t v41 = (void *)std::ostream::operator<<(v40, *(void *)(a1 + 112));
      sub_10002A6A4(v41, (uint64_t)"\n", 1LL);
      sub_10002AA94(&v44);
      if (v43 < 0) {
        operator delete(v42[0]);
      }
    }
  }

void sub_100071724( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, int a16, __int16 a17, char a18, char a19, void *__p, uint64_t a21, int a22, __int16 a23, char a24, char a25)
{
  if (a25 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100071790(uint64_t result, unint64_t a2)
{
  if (a2 > (uint64_t)(*(void *)(result + 16) - *(void *)result) >> 4)
  {
    int v3 = (uint64_t *)result;
    if (a2 >> 60) {
      sub_100018774();
    }
    uint64_t v4 = *(void *)(result + 8) - *(void *)result;
    void v5[4] = result + 24;
    v5[0] = sub_10006F5D8((uint64_t **)(result + 24), a2);
    v5[1] = v5[0] + v4;
    _OWORD v5[2] = v5[0] + v4;
    void v5[3] = v5[0] + 16 * a2;
    sub_10002D4B4(v3, v5);
    return sub_100071838((uint64_t)v5);
  }

  return result;
}

void sub_100071824(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

uint64_t sub_100071838(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  uint64_t v2 = *(void *)(a1 + 16);
  if (v2 != v3) {
    *(void *)(a1 + 16) = v2 + ((v3 - v2 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  }
  if (*(void *)a1) {
    sub_100069498(*(uint64_t ***)(a1 + 32), *(void **)a1, (uint64_t)(*(void *)(a1 + 24) - *(void *)a1) >> 4);
  }
  return a1;
}

void *sub_100071894(uint64_t a1)
{
  int v1 = *(_DWORD *)(*(void *)(a1 + 64) + 16LL);
  if (!v1 || v1 - 1 == *(_DWORD *)(a1 + 92))
  {
    *(_DWORD *)(a1 + 92) = -1;
    *(void *)(a1 + 96) = 0LL;
  }

  return sub_1000718C0(a1);
}

void *sub_1000718C0(uint64_t a1)
{
  *(void *)(*(void *)(a1 + 8) + 8LL * *(int *)(*(void *)(a1 + 64) + 16LL)) = 0LL;
  uint64_t v2 = *(uint64_t **)(a1 + 64);
  uint64_t v4 = *v2;
  uint64_t v3 = v2[1];
  *(void *)(a1 + 64) = v3;
  *(void *)(v4 + std::istream::~istream(v2, v3 + 8) = v3;
  *(void *)v2[1] = v4;
  --*(void *)(a1 + 48);
  return sub_10006B484(a1 + 32, (uint64_t)v2);
}

void *sub_10007192C(void *result, uint64_t a2)
{
  uint64_t v3 = result;
  unint64_t v4 = result[1];
  unint64_t v5 = result[2];
  if (v4 >= v5)
  {
    uint64_t v7 = (uint64_t)(v4 - *result) >> 4;
    unint64_t v8 = v7 + 1;
    unint64_t v9 = (uint64_t **)(result + 3);
    uint64_t v10 = v5 - *v3;
    if (v10 >> 3 > v8) {
      unint64_t v8 = v10 >> 3;
    }
    else {
      unint64_t v11 = v8;
    }
    v14[4] = v3 + 3;
    uint64_t v12 = sub_10006F5D8(v9, v11);
    BOOL v13 = &v12[16 * v7];
    v14[0] = v12;
    v14[1] = v13;
    double v14[3] = &v12[16 * v11];
    *(void *)BOOL v13 = *(void *)a2;
    *((_DWORD *)v13 + 2) = *(_DWORD *)(a2 + 8);
    *((_DWORD *)v13 + 3) = *(_DWORD *)(a2 + 12);
    v14[2] = v13 + 16;
    sub_10002D4B4(v3, v14);
    uint64_t v6 = v3[1];
    BOOL result = (void *)sub_100071838((uint64_t)v14);
  }

  else
  {
    *(void *)unint64_t v4 = *(void *)a2;
    *(_DWORD *)(v4 + std::istream::~istream(v2, v3 + 8) = *(_DWORD *)(a2 + 8);
    *(_DWORD *)(v4 + 12) = *(_DWORD *)(a2 + 12);
    uint64_t v6 = v4 + 16;
    result[1] = v4 + 16;
  }

  v3[1] = v6;
  return result;
}

void sub_100071A2C(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

void sub_100071A40(uint64_t a1, uint64_t a2)
{
  if (*(_BYTE *)(a1 + 120) && (*(_BYTE *)(a2 + 56) & 4) != 0)
  {
    unint64_t v4 = *(void *)(a2 + 32) - *(void *)(a2 + 24) + *(void *)(a1 + 128);
    *(void *)(a1 + 12std::istream::~istream(v2, v3 + 8) = v4;
    if (v4 > *(void *)(a1 + 112)) {
      sub_10007137C(a1, (char *)a2, 0LL, 0.666);
    }
  }

void sub_100071AB8(uint64_t a1, int a2)
{
  if (*(_DWORD *)(a1 + 100) < a2) {
    *(_DWORD *)(a1 + 10RDString::RDString((RDString *)&v66, theString, 0) = a2;
  }
  int v2 = *(_DWORD *)(a1 + 96);
  if (v2 <= a2)
  {
    if (v2 == a2) {
      *(_DWORD *)(a1 + 96) = a2 + 1;
    }
    if (*(_BYTE *)(a1 + 104) || !*(void *)(a1 + 112))
    {
      uint64_t v3 = (void *)(a1 + 72);
      unint64_t v4 = a2;
      *(void *)(*v3 + ((v4 >> 3) & 0x1FFFFFFFFFFFFFF8LL)) |= 1LL << v4;
    }
  }

void *sub_100071B50(void *result)
{
  int v1 = (_DWORD *)result[3];
  int v2 = (_DWORD *)result[4];
  while (v1 != v2)
  {
    if (!*v1) {
      ++result[1];
    }
    if (!v1[1]) {
      ++result[2];
    }
    v1 += 4;
  }

  return result;
}

void sub_100071B90(uint64_t a1, unint64_t a2, int a3)
{
  unint64_t v5 = *(void *)(a1 + 8);
  unint64_t v6 = a2 - v5;
  if (a2 <= v5)
  {
    *(void *)(a1 + std::istream::~istream(v2, v3 + 8) = a2;
  }

  else
  {
    uint64_t v8 = *(void *)(a1 + 16);
    unint64_t v9 = v8 << 6;
    if (v8 << 6 < v6 || v5 > (v8 << 6) - v6)
    {
      int v21 = 0LL;
      __int128 v22 = 0uLL;
      if ((a2 & 0x8000000000000000LL) != 0) {
        sub_100018774();
      }
      unint64_t v11 = v8 << 7;
      if (v11 <= ((a2 + 63) & 0xFFFFFFFFFFFFFFC0LL)) {
        unint64_t v11 = (a2 + 63) & 0xFFFFFFFFFFFFFFC0LL;
      }
      if (v9 <= 0x3FFFFFFFFFFFFFFELL) {
        unint64_t v12 = v11;
      }
      else {
        unint64_t v12 = 0x7FFFFFFFFFFFFFFFLL;
      }
      sub_10002C084(&v21, v12);
      BOOL v13 = *(unint64_t **)a1;
      unint64_t v14 = *(void *)(a1 + 8);
      *(void *)&__int128 v22 = v14 + v6;
      uint64_t v23 = v21;
      int v24 = 0;
      sub_100071D10(v13, 0, (uint64_t)&v13[v14 >> 6], v14 & 0x3F, (uint64_t)&v23, (uint64_t)&v19);
      int v17 = v19;
      LODWORD(v1std::istream::~istream(v2, v3 + 8) = v20;
      uint64_t v15 = *(char **)a1;
      *(void *)a1 = v21;
      int v21 = v15;
      __int128 v16 = *(_OWORD *)(a1 + 8);
      *(_OWORD *)(a1 + std::istream::~istream(v2, v3 + 8) = v22;
      __int128 v22 = v16;
      if (v15) {
        operator delete(v15);
      }
    }

    else
    {
      int v17 = (char *)(*(void *)a1 + 8 * (v5 >> 6));
      uint64_t v18 = *(void *)(a1 + 8) & 0x3FLL;
      *(void *)(a1 + std::istream::~istream(v2, v3 + 8) = a2;
    }

    if (a2 != v5)
    {
      if (a3)
      {
        int v21 = v17;
        LODWORD(v22) = v18;
        sub_100071E40(&v21, v6);
      }

      else
      {
        int v21 = v17;
        LODWORD(v22) = v18;
        sub_100071EF0((uint64_t)&v21, v6);
      }
    }
  }

void sub_100071CF4( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

unint64_t *sub_100071D10@<X0>( unint64_t *__src@<X0>, unsigned int a2@<W1>, uint64_t a3@<X2>, unsigned int a4@<W3>, uint64_t a5@<X4>, uint64_t a6@<X8>)
{
  int64_t v8 = a4 - (unint64_t)a2 + 8 * (a3 - (void)__src);
  if (v8 <= 0)
  {
    __int128 v16 = *(unint64_t **)a5;
  }

  else
  {
    unint64_t v9 = __src;
    __src = *(unint64_t **)a5;
    if (a2)
    {
      else {
        int64_t v10 = v8;
      }
      v8 -= v10;
      uint64_t v11 = *v9++;
      *__src = *__src & ~((0xFFFFFFFFFFFFFFFFLL >> (64 - a2 - v10)) & (-1LL << a2)) | v11 & (0xFFFFFFFFFFFFFFFFLL >> (64 - a2 - v10)) & (-1LL << a2);
      unint64_t v12 = v10 + *(unsigned int *)(a5 + 8);
      __src = (unint64_t *)((char *)__src + ((v12 >> 3) & 0x3FFFFFF8));
      *(void *)a5 = __src;
      *(_DWORD *)(a5 + std::istream::~istream(v2, v3 + 8) = v12 & 0x3F;
    }

    if (v8 >= 0) {
      uint64_t v13 = v8;
    }
    else {
      uint64_t v13 = v8 + 63;
    }
    uint64_t v14 = v13 >> 6;
    if ((unint64_t)(v8 + 63) >= 0x7F)
    {
      memmove(__src, v9, 8 * v14);
      __src = *(unint64_t **)a5;
    }

    uint64_t v15 = v8 - (v14 << 6);
    __int128 v16 = &__src[v14];
    *(void *)a5 = v16;
    if (v15 >= 1)
    {
      *__int128 v16 = *v16 & ~(0xFFFFFFFFFFFFFFFFLL >> (((_BYTE)v14 << 6) - v8)) | v9[v14] & (0xFFFFFFFFFFFFFFFFLL >> (((_BYTE)v14 << 6) - v8));
      *(_DWORD *)(a5 + std::istream::~istream(v2, v3 + 8) = v15;
    }
  }

  *(void *)a6 = v16;
  *(_DWORD *)(a6 + std::istream::~istream(v2, v3 + 8) = *(_DWORD *)(a5 + 8);
  return __src;
}

void *sub_100071E40(void *result, unint64_t a2)
{
  unint64_t v2 = a2;
  uint64_t v3 = result;
  int v4 = *((_DWORD *)result + 2);
  unint64_t v5 = (void *)*result;
  if (v4)
  {
    else {
      unint64_t v6 = (64 - v4);
    }
    *v5++ |= (0xFFFFFFFFFFFFFFFFLL >> (64 - v4 - v6)) & (-1LL << v4);
    unint64_t v2 = a2 - v6;
    char *result = v5;
  }

  unint64_t v7 = v2 >> 6;
  if (v2 >= 0x40) {
    BOOL result = memset(v5, 255, 8 * v7);
  }
  if ((v2 & 0x3F) != 0)
  {
    int64_t v8 = &v5[v7];
    *uint64_t v3 = v8;
    *v8 |= 0xFFFFFFFFFFFFFFFFLL >> -(v2 & 0x3F);
  }

  return result;
}

void sub_100071EF0(uint64_t a1, unint64_t a2)
{
  unint64_t v2 = a2;
  int v4 = *(_DWORD *)(a1 + 8);
  unint64_t v5 = *(void **)a1;
  if (v4)
  {
    else {
      unint64_t v6 = (64 - v4);
    }
    *v5++ &= ~((0xFFFFFFFFFFFFFFFFLL >> (64 - v4 - v6)) & (-1LL << v4));
    unint64_t v2 = a2 - v6;
    *(void *)a1 = v5;
  }

  unint64_t v7 = v2 >> 6;
  if (v2 >= 0x40) {
    bzero(v5, 8 * v7);
  }
  if ((v2 & 0x3F) != 0)
  {
    int64_t v8 = &v5[v7];
    *(void *)a1 = v8;
    *v8 &= ~(0xFFFFFFFFFFFFFFFFLL >> -(v2 & 0x3F));
  }

uint64_t sub_100071F9C(uint64_t a1, uint64_t a2, int a3)
{
  *(void *)a1 = &off_1000D23C8;
  *(void *)(a1 + std::istream::~istream(v2, v3 + 8) = 0LL;
  *(void *)(a1 + 16) = a2;
  uint64_t v4 = *(void *)(a2 + 8);
  *(void *)(a1 + ++*(void *)(result + 24) = v4;
  *(_DWORD *)(a1 + 32) = -1;
  *(_DWORD *)(a1 + 36) = a3;
  *(void *)(a1 + 4RDString::RDString((RDString *)&v66, theString, 0) = sub_100065764(*(void *)(v4 + 144), 0LL);
  *(void *)(a1 + 4std::istream::~istream(v2, v3 + 8) = sub_100065764(*(void *)(*(void *)(a1 + 24) + 152LL), 0LL);
  *(_BYTE *)(a1 + ++*(void *)(result + 56) = 0;
  int v5 = *sub_10002AD60();
  *(void *)(a1 + 6RDString::RDString((RDString *)&v66, theString, 0) = 0xFFFFFFFFLL;
  *(_DWORD *)(a1 + 6std::istream::~istream(v2, v3 + 8) = v5;
  *(_DWORD *)(a1 + sub_10001A760(v25 - 72) = -1;
  if (*(_DWORD *)(a1 + 36) == 2) {
    *(void *)(a1 + 6RDString::RDString((RDString *)&v66, theString, 0) = 0xFFFFFFFF00000000LL;
  }
  return a1;
}

void sub_100072034(_Unwind_Exception *exception_object)
{
  uint64_t v3 = v1[6];
  v1[6] = 0LL;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8LL))(v3);
  }
  uint64_t v4 = v1[5];
  v1[5] = 0LL;
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 8LL))(v4);
  }
  uint64_t v5 = v1[1];
  v1[1] = 0LL;
  if (v5) {
    (*(void (**)(uint64_t))(*(void *)v5 + 8LL))(v5);
  }
  _Unwind_Resume(exception_object);
}

void *sub_100072098(void *a1)
{
  *a1 = &off_1000D23C8;
  uint64_t v2 = a1[6];
  a1[6] = 0LL;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8LL))(v2);
  }
  uint64_t v3 = a1[5];
  a1[5] = 0LL;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8LL))(v3);
  }
  uint64_t v4 = a1[1];
  a1[1] = 0LL;
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 8LL))(v4);
  }
  return a1;
}

void sub_10007210C(void *__p)
{
  *std::string __p = &off_1000D23C8;
  uint64_t v2 = __p[6];
  __p[6] = 0LL;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8LL))(v2);
  }
  uint64_t v3 = __p[5];
  std::string __p[5] = 0LL;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8LL))(v3);
  }
  uint64_t v4 = __p[1];
  __p[1] = 0LL;
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 8LL))(v4);
  }
  operator delete(__p);
}

void *sub_100072180(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = operator new(0x60uLL);
  sub_1000724E0((uint64_t)v4, a1, a2);
  return v4;
}

void sub_1000721C4(_Unwind_Exception *a1)
{
}

uint64_t sub_1000721D8(uint64_t a1, uint64_t a2)
{
  uint64_t result = (*(uint64_t (**)(void))(**(void **)(a1 + 40) + 24LL))(*(void *)(a1 + 40));
  if ((_DWORD)result != 4)
  {
    uint64_t result = (*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 24LL))(*(void *)(a1 + 48), a2);
    if ((_DWORD)result != 4)
    {
      if ((*(unsigned int (**)(void, uint64_t))(**(void **)(a1 + 40) + 24LL))(*(void *)(a1 + 40), a2) != 5
        || (uint64_t result = (*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 24LL))( *(void *)(a1 + 48),  a2),  (_DWORD)result != 5))
      {
        if ((*(unsigned int (**)(void, uint64_t))(**(void **)(a1 + 40) + 24LL))(*(void *)(a1 + 40), a2) == 5
          && (*(unsigned int (**)(void, uint64_t))(**(void **)(a1 + 48) + 24LL))(*(void *)(a1 + 48), a2) == *(_DWORD *)(a1 + 36))
        {
          return 5LL;
        }

        else if ((*(unsigned int (**)(void, uint64_t))(**(void **)(a1 + 40) + 24LL))( *(void *)(a1 + 40),  a2) != *(_DWORD *)(a1 + 36) {
               || (uint64_t result = (*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 24LL))( *(void *)(a1 + 48),  a2),  (_DWORD)result != 5))
        }
        {
          if ((*(unsigned int (**)(void, uint64_t))(**(void **)(a1 + 40) + 24LL))( *(void *)(a1 + 40),  a2) != *(_DWORD *)(a1 + 36)) {
            return 4LL;
          }
          uint64_t result = (*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 24LL))( *(void *)(a1 + 48),  a2);
          if ((_DWORD)result != *(_DWORD *)(a1 + 36)) {
            return 4LL;
          }
        }
      }
    }
  }

  return result;
}

uint64_t sub_100072328(uint64_t result, int a2)
{
  if (*(_DWORD *)(result + 32) != a2)
  {
    uint64_t v2 = result;
    *(_DWORD *)(result + 32) = a2;
    uint64_t v3 = (unsigned int *)(*(void *)(*(void *)(*(void *)(result + 24) + 176LL) + 104LL) + 12LL * a2);
    uint64_t v4 = *(void *)(result + 40);
    uint64_t v5 = *v3;
    if (*(_DWORD *)(v4 + 52) != (_DWORD)v5)
    {
      *(_DWORD *)(v4 + 52) = v5;
      uint64_t result = sub_100067958(*(void *)(v4 + 8), v5);
      *(_BYTE *)(v4 + ++*(void *)(result + 56) = *(_DWORD *)(v4 + 20) != -1;
    }

    uint64_t v6 = *(void *)(v2 + 48);
    uint64_t v7 = v3[1];
    if (*(_DWORD *)(v6 + 52) != (_DWORD)v7)
    {
      *(_DWORD *)(v6 + 52) = v7;
      uint64_t result = sub_100067958(*(void *)(v6 + 8), v7);
      *(_BYTE *)(v6 + ++*(void *)(result + 56) = *(_DWORD *)(v6 + 20) != -1;
    }

    *(_DWORD *)(v2 + sub_10001A760(v25 - 72) = *(_DWORD *)(v2 + 32);
  }

  return result;
}

uint64_t sub_1000723D8(uint64_t a1, int a2)
{
  *(_BYTE *)(a1 + ++*(void *)(result + 56) = a2 == 0;
  if (*(_DWORD *)(a1 + 36) == 1)
  {
    if (a2)
    {
      uint64_t v2 = (uint64_t *)(a1 + 40);
      uint64_t v3 = (uint64_t *)(a1 + 48);
      return sub_100072600(a1, a2, *v2, *v3);
    }
  }

  else if (a2)
  {
    uint64_t v2 = (uint64_t *)(a1 + 48);
    uint64_t v3 = (uint64_t *)(a1 + 40);
    return sub_100072600(a1, a2, *v2, *v3);
  }

  return 1LL;
}

BOOL sub_100072420(uint64_t a1)
{
  return !*(_BYTE *)(a1 + 56)
      && sub_100066E0C(*(void *)(*(void *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 8LL) + 8LL))
      && sub_100066E0C(*(void *)(*(void *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 8LL) + 8LL));
}

uint64_t sub_10007247C(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 56)) {
    return a1 + 60;
  }
  else {
    return a1 + 76;
  }
}

uint64_t sub_100072494(uint64_t result)
{
  if (*(_BYTE *)(result + 56))
  {
    *(_BYTE *)(result + ++*(void *)(result + 56) = 0;
  }

  else
  {
    if (*(_DWORD *)(result + 36) == 1)
    {
      uint64_t v1 = *(void *)(result + 40);
      uint64_t v2 = *(void *)(result + 48);
    }

    else
    {
      uint64_t v2 = *(void *)(result + 40);
      uint64_t v1 = *(void *)(result + 48);
    }

    return sub_100072678(result, v1, v2);
  }

  return result;
}

uint64_t sub_1000724C0(uint64_t a1)
{
  return *(void *)(a1 + 16);
}

uint64_t sub_1000724C8(uint64_t a1, uint64_t a2)
{
  return a2;
}

uint64_t sub_1000724D0(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 16) + 32LL))(*(void *)(a1 + 16));
}

uint64_t sub_1000724E0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(void *)a1 = &off_1000D23C8;
  uint64_t v6 = (*(uint64_t (**)(void, uint64_t))(**(void **)(a2 + 16) + 72LL))(*(void *)(a2 + 16), a3);
  *(void *)(a1 + std::istream::~istream(v2, v3 + 8) = v6;
  *(void *)(a1 + 16) = v6;
  *(void *)(a1 + ++*(void *)(result + 24) = *(void *)(v6 + 8);
  int v7 = *(_DWORD *)(a2 + 36);
  *(_DWORD *)(a1 + 32) = -1;
  *(_DWORD *)(a1 + 36) = v7;
  *(void *)(a1 + 4RDString::RDString((RDString *)&v66, theString, 0) = sub_100065764(*(void *)(a2 + 40), a3);
  *(void *)(a1 + 4std::istream::~istream(v2, v3 + 8) = sub_100065764(*(void *)(a2 + 48), a3);
  *(_BYTE *)(a1 + ++*(void *)(result + 56) = 0;
  int v8 = *sub_10002AD60();
  *(void *)(a1 + 6RDString::RDString((RDString *)&v66, theString, 0) = 0xFFFFFFFFLL;
  *(_DWORD *)(a1 + 6std::istream::~istream(v2, v3 + 8) = v8;
  *(_DWORD *)(a1 + sub_10001A760(v25 - 72) = -1;
  if (*(_DWORD *)(a1 + 36) == 2) {
    *(void *)(a1 + 6RDString::RDString((RDString *)&v66, theString, 0) = 0xFFFFFFFF00000000LL;
  }
  return a1;
}

void sub_10007259C(_Unwind_Exception *exception_object)
{
  uint64_t v3 = v1[6];
  v1[6] = 0LL;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8LL))(v3);
  }
  uint64_t v4 = v1[5];
  v1[5] = 0LL;
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 8LL))(v4);
  }
  uint64_t v5 = v1[1];
  v1[1] = 0LL;
  if (v5) {
    (*(void (**)(uint64_t))(*(void *)v5 + 8LL))(v5);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100072600(uint64_t a1, int a2, uint64_t a3, uint64_t a4)
{
  uint64_t result = sub_100065820(a3, a2);
  if ((_DWORD)result)
  {
    int v8 = *(_DWORD *)(a1 + 36);
    unint64_t v9 = (int *)sub_100065974(a3);
    int64_t v10 = v9 + 1;
    if (v8 != 1) {
      int64_t v10 = v9;
    }
    sub_100065820(a4, *v10);
    return sub_100072678(a1, a3, a4);
  }

  return result;
}

uint64_t sub_100072678(uint64_t a1, uint64_t a2, uint64_t a3)
{
  while (!sub_100066E0C(*(void *)(*(void *)(*(void *)(a2 + 8) + 8LL) + 8LL))
       || !sub_100066E0C(*(void *)(*(void *)(*(void *)(a3 + 8) + 8LL) + 8LL)))
  {
    if (sub_100066E0C(*(void *)(*(void *)(*(void *)(a3 + 8) + 8LL) + 8LL)))
    {
      sub_100067BD4(*(void *)(a2 + 8));
      while (!sub_100066E0C(*(void *)(*(void *)(*(void *)(a2 + 8) + 8LL) + 8LL)))
      {
        int v6 = *(_DWORD *)(a1 + 36);
        int v7 = (int *)sub_100065974(a2);
        int v8 = v7 + 1;
        if (v6 != 1) {
          int v8 = v7;
        }
        if (sub_100065820(a3, *v8)) {
          break;
        }
        sub_100067BD4(*(void *)(a2 + 8));
      }
    }

    while (!sub_100066E0C(*(void *)(*(void *)(*(void *)(a3 + 8) + 8LL) + 8LL)))
    {
      unint64_t v9 = sub_100065974(a2);
      int64_t v10 = sub_100065974(a3);
      sub_100067BD4(*(void *)(a3 + 8));
      uint64_t v11 = *(unsigned int *)(a1 + 32);
      int v12 = *(_DWORD *)(a1 + 36);
      BOOL v13 = v12 == 1;
      if (v12 == 1) {
        uint64_t v14 = v9;
      }
      else {
        uint64_t v14 = v10;
      }
      uint64_t v20 = *v14;
      int v21 = *((_DWORD *)v14 + 2);
      int v22 = *((_DWORD *)v14 + 3);
      if (v13) {
        uint64_t v15 = v10;
      }
      else {
        uint64_t v15 = v9;
      }
      uint64_t v17 = *v15;
      int v18 = *((_DWORD *)v15 + 2);
      int v19 = *((_DWORD *)v15 + 3);
    }
  }

  return 0LL;
}

uint64_t sub_1000727E4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = *(void *)(a1 + 24);
  int v6 = *(unsigned __int8 **)(v5 + 136);
  int v7 = *(_DWORD *)(a3 + 4);
  if (v7 == -1)
  {
    if (v6[33]) {
      return 0LL;
    }
    LOBYTE(v6) = v6[34] ^ 1;
  }

  else if (*(_DWORD *)a4 == -1)
  {
    uint64_t v8 = 0LL;
    LODWORD(v6) = v6[32];
    if ((_DWORD)v6) {
      return v8;
    }
  }

  else
  {
    LOBYTE(v6) = 0;
    if (!v7) {
      return 0LL;
    }
  }

  int v9 = *(_DWORD *)(a4 + 12);
  LODWORD(v16) = *(_DWORD *)(a3 + 12);
  HIDWORD(v16) = v9;
  char v17 = (char)v6;
  int v10 = *(_DWORD *)(a4 + 4);
  *(_DWORD *)(a1 + 76) = *(_DWORD *)a3;
  *(_DWORD *)(a1 + 8RDString::RDString((RDString *)&v66, theString, 0) = v10;
  float v11 = *(float *)(a3 + 8);
  if (v11 == -INFINITY || (float v12 = *(float *)(a4 + 8), v12 >= -INFINITY) && v12 <= -INFINITY)
  {
    float v13 = *(float *)sub_1000606CC();
    uint64_t v5 = *(void *)(a1 + 24);
  }

  else
  {
    BOOL v14 = v12 == INFINITY || v11 == INFINITY;
    float v13 = v11 + v12;
    if (v14) {
      float v13 = INFINITY;
    }
  }

  *(float *)(a1 + 84) = v13;
  uint64_t v8 = 1LL;
  *(_DWORD *)(a1 + 8std::istream::~istream(v2, v3 + 8) = sub_100070F74(*(void **)(v5 + 176), &v16, 1);
  return v8;
}

uint64_t sub_1000728EC(uint64_t a1)
{
  if (!*(_BYTE *)(a1 + 56))
  {
    if ((*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a1 + 24LL))(a1, 4LL))
    {
      *(_BYTE *)(a1 + ++*(void *)(result + 56) = 1;
    }

    else if (!*(_BYTE *)(a1 + 56))
    {
      int v3 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 56LL))(a1);
      if (v3 != -1)
      {
        *(_DWORD *)(a1 + 6RDString::RDString((RDString *)&v66, theString, 0) = v3;
        *(_BYTE *)(a1 + ++*(void *)(result + 56) = 1;
        if (*(_DWORD *)(a1 + 64) <= v3) {
          *(_DWORD *)(a1 + 64) = v3 + 1;
        }
      }
    }
  }

  return *(unsigned int *)(a1 + 60);
}

float sub_10007297C@<S0>(uint64_t *a1@<X0>, uint64_t a2@<X1>, _DWORD *a3@<X8>)
{
  if ((sub_100072A24((uint64_t)a1, a2) & 1) == 0)
  {
    (*(void (**)(uint64_t *__return_ptr, uint64_t *, uint64_t))(*a1 + 64))(&v11, a1, a2);
    int v6 = sub_100071228(a1[15], a2);
    *(_DWORD *)int v6 = v11;
    *((_DWORD *)v6 + 14) |= 9u;
  }

  uint64_t v7 = a1[15];
  if (*(_DWORD *)(v7 + 92) == (_DWORD)a2) {
    uint64_t v8 = (float **)(v7 + 96);
  }
  else {
    uint64_t v8 = (float **)(*(void *)(v7 + 8) + 8LL * ((int)a2 + 1));
  }
  int v9 = *v8;
  float result = *v9;
  *a3 = *(_DWORD *)v9;
  return result;
}

uint64_t sub_100072A24(uint64_t a1, int a2)
{
  uint64_t v2 = *(void *)(a1 + 120);
  if (*(_DWORD *)(v2 + 92) == a2)
  {
    int v3 = (uint64_t *)(v2 + 96);
  }

  else
  {
    unint64_t v4 = a2 + 1;
    uint64_t v6 = v2 + 8;
    uint64_t v5 = *(void *)(v2 + 8);
    if (v4 >= (*(void *)(v6 + 8) - v5) >> 3) {
      return 0LL;
    }
    int v3 = (uint64_t *)(v5 + 8 * v4);
  }

  uint64_t v7 = *v3;
  if (!v7) {
    return 0LL;
  }
  int v8 = *(_DWORD *)(v7 + 56);
  if ((v8 & 1) == 0) {
    return 0LL;
  }
  *(_DWORD *)(v7 + ++*(void *)(result + 56) = v8 | 8;
  return 1LL;
}

uint64_t sub_100072A80(void *a1, uint64_t a2)
{
  uint64_t v4 = a1[15];
  if (*(_DWORD *)(v4 + 92) == (_DWORD)a2) {
    uint64_t v5 = v4 + 96;
  }
  else {
    uint64_t v5 = *(void *)(v4 + 8) + 8LL * ((int)a2 + 1);
  }
  return (uint64_t)(*(void *)(*(void *)v5 + 32LL) - *(void *)(*(void *)v5 + 24LL)) >> 4;
}

uint64_t sub_100072AF0(uint64_t a1, int a2)
{
  uint64_t v2 = *(void *)(a1 + 120);
  if (*(_DWORD *)(v2 + 92) == a2)
  {
    int v3 = (uint64_t *)(v2 + 96);
  }

  else
  {
    unint64_t v4 = a2 + 1;
    uint64_t v6 = v2 + 8;
    uint64_t v5 = *(void *)(v2 + 8);
    if (v4 >= (*(void *)(v6 + 8) - v5) >> 3) {
      return 0LL;
    }
    int v3 = (uint64_t *)(v5 + 8 * v4);
  }

  uint64_t v7 = *v3;
  if (!v7) {
    return 0LL;
  }
  int v8 = *(_DWORD *)(v7 + 56);
  if ((v8 & 2) == 0) {
    return 0LL;
  }
  *(_DWORD *)(v7 + ++*(void *)(result + 56) = v8 | 8;
  return 1LL;
}

uint64_t sub_100072B4C(void *a1, uint64_t a2)
{
  uint64_t v4 = a1[15];
  if (*(_DWORD *)(v4 + 92) == (_DWORD)a2) {
    uint64_t v5 = v4 + 96;
  }
  else {
    uint64_t v5 = *(void *)(v4 + 8) + 8LL * ((int)a2 + 1);
  }
  return *(void *)(*(void *)v5 + 8LL);
}

uint64_t sub_100072BB4(void *a1, uint64_t a2)
{
  uint64_t v4 = a1[15];
  if (*(_DWORD *)(v4 + 92) == (_DWORD)a2) {
    uint64_t v5 = v4 + 96;
  }
  else {
    uint64_t v5 = *(void *)(v4 + 8) + 8LL * ((int)a2 + 1);
  }
  return *(void *)(*(void *)v5 + 16LL);
}

void *sub_100072C1C(void *a1, uint64_t a2, int a3)
{
  uint64_t v4 = *(void *)(a2 + 8);
  if (a3)
  {
    uint64_t v5 = (*(uint64_t (**)(uint64_t))(*(void *)v4 + 32LL))(v4);
    sub_100072C98(v10, v5);
    uint64_t v4 = v10[0];
    uint64_t v6 = v10[1];
  }

  else
  {
    uint64_t v6 = *(void *)(a2 + 16);
    if (v6)
    {
      uint64_t v7 = (unint64_t *)(v6 + 8);
      do
        unint64_t v8 = __ldxr(v7);
      while (__stxr(v8 + 1, v7));
    }
  }

  a1[1] = v4;
  a1[2] = v6;
  *a1 = off_1000D10C8;
  return a1;
}

void *sub_100072C98(void *a1, uint64_t a2)
{
  *a1 = a2;
  uint64_t v4 = operator new(0x20uLL);
  *uint64_t v4 = &off_1000D24F8;
  v4[1] = 0LL;
  _DWORD v4[2] = 0LL;
  v4[3] = a2;
  a1[1] = v4;
  return a1;
}

void sub_100072CDC(_Unwind_Exception *exception_object)
{
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8LL))(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_100072D00(std::__shared_weak_count *a1)
{
}

uint64_t sub_100072D14(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(uint64_t))(*(void *)result + 8LL))(result);
  }
  return result;
}

uint64_t sub_100072D2C(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }

  else
  {
    return 0LL;
  }

uint64_t sub_100072D74(uint64_t a1)
{
  int v2 = *(_DWORD *)(a1 + 24);
  uint64_t v3 = *(void *)(a1 + 16);
  if (v2 < *(_DWORD *)(v3 + 64)) {
    return 0LL;
  }
  uint64_t v5 = sub_100072EC0(v3);
  uint64_t v6 = v5;
  do
  {
    sub_100072F9C(&v20, *(void *)(a1 + 8), v6);
    unint64_t v7 = v21;
    uint64_t v8 = *((void *)v20 + 3);
    uint64_t v9 = *((void *)v20 + 4) - v8;
    uint64_t v10 = *(void *)(a1 + 16);
    if (v21 < v9 >> 4)
    {
      uint64_t v11 = v9 >> 4;
      int v12 = *(_DWORD *)(v10 + 64);
      float v13 = (int *)(v8 + 16 * v21 + 12);
      do
      {
        int v15 = *v13;
        v13 += 4;
        int v14 = v15;
        if (v12 <= v15)
        {
          int v12 = v14 + 1;
          *(_DWORD *)(v10 + 64) = v14 + 1;
        }

        ++v7;
      }

      while (v11 != v7);
      unint64_t v21 = v11;
    }

    sub_100071AB8(v10, v6);
    int v16 = *(_DWORD *)(a1 + 24);
    uint64_t v17 = *(void *)(a1 + 16);
    int v18 = *(_DWORD *)(v17 + 64);
    --*((_DWORD *)v20 + 15);
    BOOL v4 = v16 >= v18;
    if (v16 < v18) {
      break;
    }
    uint64_t v6 = sub_100072EC0(v17);
  }

  while ((int)v6 < *(_DWORD *)(*(void *)(a1 + 16) + 64LL));
  return v4;
}

void sub_100072E84( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_100072E98(uint64_t a1)
{
  return *(unsigned int *)(a1 + 24);
}

uint64_t sub_100072EA0(uint64_t result)
{
  return result;
}

uint64_t sub_100072EB0(uint64_t result)
{
  *(_DWORD *)(result + ++*(_DWORD *)(result + 24) = 0;
  return result;
}

uint64_t sub_100072EC0(uint64_t a1)
{
  uint64_t v1 = *(unsigned int *)(a1 + 96);
  if ((int)v1 <= *(_DWORD *)(a1 + 100))
  {
    while (1)
    {
      int v3 = sub_100072F18(a1, v1);
      int v4 = *(_DWORD *)(a1 + 96);
      if (!v3) {
        break;
      }
      uint64_t v1 = (v4 + 1);
      *(_DWORD *)(a1 + 96) = v1;
      if (v4 >= *(_DWORD *)(a1 + 100)) {
        return v1;
      }
    }

    return *(unsigned int *)(a1 + 96);
  }

  return v1;
}

uint64_t sub_100072F18(uint64_t a1, int a2)
{
  if (*(_BYTE *)(a1 + 104) || !*(void *)(a1 + 112)) {
    return (*(void *)(*(void *)(a1 + 72) + (((unint64_t)a2 >> 3) & 0x1FFFFFFFFFFFFFF8LL)) >> a2) & 1LL;
  }
  if (*(_BYTE *)(a1 + 128))
  {
    uint64_t v3 = *(void *)(a1 + 120);
    if (*(_DWORD *)(v3 + 92) == a2)
    {
      int v4 = (void *)(v3 + 96);
      return *v4 != 0LL;
    }

    unint64_t v5 = a2 + 1;
    uint64_t v7 = v3 + 8;
    uint64_t v6 = *(void *)(v3 + 8);
    if (v5 < (*(void *)(v7 + 8) - v6) >> 3)
    {
      int v4 = (void *)(v6 + 8 * v5);
      return *v4 != 0LL;
    }
  }

  return 0LL;
}

char **sub_100072F9C(char **a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = *(void *)(a2 + 8);
  a1[1] = 0LL;
  uint64_t v7 = sub_100071228(*(void *)(v6 + 120), a3);
  *a1 = v7;
  ++*((_DWORD *)v7 + 15);
  if ((sub_100072AF0(*(void *)(a2 + 8), a3) & 1) == 0) {
    (*(void (**)(void, uint64_t))(**(void **)(a2 + 8) + 40LL))(*(void *)(a2 + 8), a3);
  }
  return a1;
}

void sub_100073014(_Unwind_Exception *a1)
{
}

uint64_t sub_100073028(uint64_t a1, uint64_t a2, void *a3)
{
  if ((sub_100072AF0(a1, a2) & 1) == 0) {
    (*(void (**)(uint64_t, uint64_t))(*(void *)a1 + 40LL))(a1, a2);
  }
  return sub_10007307C(a1, a2, a3);
}

uint64_t sub_10007307C(uint64_t result, int a2, void *a3)
{
  uint64_t v3 = *(void *)(result + 120);
  if (*(_DWORD *)(v3 + 92) == a2) {
    int v4 = (uint64_t *)(v3 + 96);
  }
  else {
    int v4 = (uint64_t *)(*(void *)(v3 + 8) + 8LL * (a2 + 1));
  }
  uint64_t v5 = *v4;
  int v8 = *(_DWORD *)(v5 + 60);
  uint64_t v6 = (_DWORD *)(v5 + 60);
  int v7 = v8;
  uint64_t v9 = *(void *)(v6 - 9);
  uint64_t v10 = (*(void *)(v6 - 7) - v9) >> 4;
  if (*(void *)(v6 - 7) == v9) {
    uint64_t v9 = 0LL;
  }
  *a3 = 0LL;
  a3[1] = v9;
  a3[2] = v10;
  a3[3] = v6;
  _DWORD *v6 = v7 + 1;
  return result;
}

void *sub_1000730D0(void *a1, uint64_t a2)
{
  uint64_t v3 = v8;
  if (v8)
  {
    p_shared_owners = (unint64_t *)&v8->__shared_owners_;
    do
      unint64_t v5 = __ldaxr(p_shared_owners);
    while (__stlxr(v5 - 1, p_shared_owners));
    if (!v5)
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }

  *a1 = off_1000D06D8;
  return a1;
}

void sub_100073154(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

void *sub_100073168(void *a1)
{
  *a1 = off_1000D2B10;
  sub_100017FC4((uint64_t)(a1 + 1));
  return a1;
}

void sub_100073198(void *a1)
{
  *a1 = off_1000D2B10;
  sub_100017FC4((uint64_t)(a1 + 1));
  operator delete(a1);
}

uint64_t sub_1000731C8(uint64_t a1)
{
  return sub_100076670(*(void *)(a1 + 8));
}

_DWORD *sub_1000731D0@<X0>(uint64_t a1@<X0>, int a2@<W1>, int *a3@<X8>)
{
  return sub_10007766C(*(void *)(a1 + 8), a2, a3);
}

uint64_t sub_1000731D8(uint64_t a1, int a2)
{
  return sub_100077774(*(void *)(a1 + 8), a2);
}

uint64_t sub_1000731E0(uint64_t a1, int a2)
{
  return sub_100077F08(*(uint64_t **)(a1 + 8), a2);
}

uint64_t sub_1000731E8(uint64_t a1, int a2)
{
  return sub_1000781E0(*(uint64_t **)(a1 + 8), a2);
}

uint64_t sub_1000731F0(uint64_t a1, uint64_t a2, int a3)
{
  if (!a3) {
    return (*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 8) + 24LL))(*(void *)(a1 + 8), a2);
  }
  unint64_t v5 = sub_10005AF40(a1, a2, &v7);
  *(void *)(*(void *)(a1 + 8) + 8LL) = *(void *)(*(void *)(a1 + 8) + 8LL) & (~v7 | 4) | v7 & v5;
  return v5 & a2;
}

uint64_t sub_100073274(uint64_t a1)
{
  return *(void *)(a1 + 8) + 16LL;
}

void *sub_100073280(uint64_t a1, int a2)
{
  int v4 = operator new(0x18uLL);
  sub_100078434(v4, a1, a2);
  *int v4 = off_1000D2630;
  return v4;
}

void sub_1000732D0(_Unwind_Exception *a1)
{
}

uint64_t sub_1000732E4(uint64_t a1)
{
  return *(void *)(*(void *)(a1 + 8) + 40LL);
}

uint64_t sub_1000732F0(uint64_t a1)
{
  return *(void *)(*(void *)(a1 + 8) + 48LL);
}

uint64_t sub_1000732FC(uint64_t *a1, void *a2)
{
  int v4 = operator new(0x20uLL);
  *int v4 = &off_1000D2C18;
  v4[1] = a1;
  uint64_t v5 = *a1;
  _DWORD v4[2] = a1[1];
  *((_DWORD *)v4 + 6) = 0;
  uint64_t result = (*(uint64_t (**)(uint64_t *))(v5 + 16))(a1);
  *int v4 = &off_1000D2BA8;
  *a2 = v4;
  return result;
}

void sub_100073364(_Unwind_Exception *a1)
{
}

uint64_t sub_100073378(uint64_t a1, int a2, void *a3)
{
  return sub_100079940(*(uint64_t **)(a1 + 8), a2, a3);
}

void *sub_100073380(void *a1, int a2)
{
  if (*(_BYTE *)(a1[1] + 160LL)) {
    goto LABEL_2;
  }
  if (a2 == 2)
  {
    uint64_t v6 = *(uint64_t (**)(void))(*a1 + 56LL);
  }

  else
  {
    if (a2 != 1) {
      goto LABEL_2;
    }
    uint64_t v6 = *(uint64_t (**)(void))(*a1 + 56LL);
  }

  if (v6())
  {
    int v2 = operator new(0x80uLL);
    sub_10007998C((uint64_t)v2, (uint64_t)a1, a2);
    return v2;
  }

LABEL_2:
  if (dword_1000DE7E8 >= 2)
  {
    sub_10000A2DC(__p, "INFO");
    sub_10002A9EC(&v9, (uint64_t)__p);
    sub_10002A6A4(&std::cerr, (uint64_t)"Not using replace matcher", 25LL);
    sub_10002AA94(&v9);
    if (v8 < 0) {
      operator delete(__p[0]);
    }
  }

  return 0LL;
}

void sub_100073480( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, int a15, __int16 a16, char a17, char a18)
{
}

void *sub_1000734B8@<X0>(uint64_t *a1@<X1>, uint64_t a2@<X2>, void *a3@<X8>)
{
  uint64_t v6 = operator new(0x128uLL);
  uint64_t result = sub_100073518(v6, a1, a2);
  *a3 = v6 + 3;
  a3[1] = v6;
  return result;
}

void sub_100073504(_Unwind_Exception *a1)
{
}

void *sub_100073518(void *a1, uint64_t *a2, uint64_t a3)
{
  a1[1] = 0LL;
  a1[2] = 0LL;
  *a1 = off_1000D26F8;
  sub_1000735A0((uint64_t)(a1 + 3), a2, a3);
  return a1;
}

void sub_10007354C(_Unwind_Exception *a1)
{
}

void sub_100073560(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_1000D26F8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_100073570(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)off_1000D26F8;
  std::__shared_weak_count::~__shared_weak_count(a1);
  operator delete(v1);
}

uint64_t sub_100073590(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 24))(a1 + 24);
}

uint64_t sub_1000735A0(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v6 = sub_10006911C(a1, (char *)a3);
  *(void *)uint64_t v6 = off_1000D2748;
  *(void *)(v6 + 132) = *(void *)(a3 + 32);
  uint64_t v7 = *(void *)(a3 + 40);
  *(void *)&__int128 v8 = (int)v7;
  *((void *)&v8 + 1) = SHIDWORD(v7);
  *(_OWORD *)(v6 + 144) = v8;
  BOOL v9 = *(void **)(a3 + 56);
  if (!v9)
  {
    BOOL v9 = operator new(0x110uLL);
    sub_100074360((uint64_t)v9);
  }

  *(void *)(a1 + 184) = 0LL;
  *(void *)(a1 + 176) = a1 + 184;
  *(void *)(a1 + 16std::istream::~istream(v2, v3 + 8) = v9;
  *(void *)(a1 + 192) = 0LL;
  *(_OWORD *)(a1 + 20RDString::RDString((RDString *)&v66, theString, 0) = 0u;
  uint64_t v72 = a1 + 200;
  *(_OWORD *)(a1 + 216) = 0u;
  *(_DWORD *)(a1 + 232) = 1065353216;
  *(void *)(a1 + 24RDString::RDString((RDString *)&v66, theString, 0) = 0LL;
  uint64_t v71 = (int64x2_t *)(a1 + 240);
  *(void *)(a1 + 24std::istream::~istream(v2, v3 + 8) = 0LL;
  *(void *)(a1 + 2++*(void *)(result + 56) = 0LL;
  sub_10000A2DC(&__str, "replace");
  std::string::operator=((std::string *)(a1 + 16), &__str);
  if (!*(void *)(a1 + 144)) {
    *(_DWORD *)(a1 + 132) = 1;
  }
  if (!*(void *)(a1 + 152)) {
    *(_DWORD *)(a1 + 136) = 1;
  }
  if (*a2 != a2[1])
  {
    uint64_t v10 = (*(uint64_t (**)(void))(**(void **)(*a2 + 8) + 96LL))(*(void *)(*a2 + 8));
    if (v10) {
      uint64_t v10 = (*(uint64_t (**)(uint64_t))(*(void *)v10 + 16LL))(v10);
    }
    uint64_t v11 = *(void *)(a1 + 40);
    *(void *)(a1 + 4RDString::RDString((RDString *)&v66, theString, 0) = v10;
    if (v11) {
      (*(void (**)(uint64_t))(*(void *)v11 + 8LL))(v11);
    }
    uint64_t v12 = (*(uint64_t (**)(void))(**(void **)(*a2 + 8) + 104LL))(*(void *)(*a2 + 8));
    if (v12) {
      uint64_t v12 = (*(uint64_t (**)(uint64_t))(*(void *)v12 + 16LL))(v12);
    }
    uint64_t v13 = *(void *)(a1 + 48);
    *(void *)(a1 + 4std::istream::~istream(v2, v3 + 8) = v12;
    if (v13) {
      (*(void (**)(uint64_t))(*(void *)v13 + 8LL))(v13);
    }
  }

  int v15 = *(void **)(a1 + 248);
  unint64_t v14 = *(void *)(a1 + 256);
  if ((unint64_t)v15 >= v14)
  {
    uint64_t v17 = ((uint64_t)v15 - v71->i64[0]) >> 3;
    uint64_t v18 = v14 - v71->i64[0];
    uint64_t v19 = v18 >> 2;
    else {
      unint64_t v20 = v19;
    }
    uint64_t v92 = a1 + 256;
    if (v20) {
      unint64_t v21 = (char *)sub_100018788(a1 + 256, v20);
    }
    else {
      unint64_t v21 = 0LL;
    }
    int v22 = &v21[8 * v17];
    uint64_t v23 = &v21[8 * v20];
    unsigned __int8 v91 = v23;
    *(void *)int v22 = 0LL;
    std::string::size_type cap = (std::string::size_type)(v22 + 8);
    __str.__r_.__value_.__l.__cap_ = (std::string::size_type)(v22 + 8);
    int v25 = *(void **)(a1 + 240);
    int v24 = *(void **)(a1 + 248);
    if (v24 == v25)
    {
      int64x2_t v27 = vdupq_n_s64((unint64_t)v24);
    }

    else
    {
      do
      {
        uint64_t v26 = *--v24;
        *int v24 = 0LL;
        *((void *)v22 - 1) = v26;
        v22 -= 8;
      }

      while (v24 != v25);
      int64x2_t v27 = *v71;
      std::string::size_type cap = __str.__r_.__value_.__l.__cap_;
      uint64_t v23 = v91;
    }

    *(void *)(a1 + 24RDString::RDString((RDString *)&v66, theString, 0) = v22;
    *(void *)(a1 + 24std::istream::~istream(v2, v3 + 8) = cap;
    *(int64x2_t *)&__str.__r_.__value_.__r.__words[1] = v27;
    unint64_t v28 = *(char **)(a1 + 256);
    *(void *)(a1 + 2++*(void *)(result + 56) = v23;
    unsigned __int8 v91 = v28;
    __str.__r_.__value_.__r.__words[0] = v27.i64[0];
    sub_100069800((uint64_t)&__str);
  }

  else
  {
    void *v15 = 0LL;
    std::string::size_type cap = (std::string::size_type)(v15 + 1);
  }

  *(void *)(a1 + 24std::istream::~istream(v2, v3 + 8) = cap;
  uint64_t v29 = *a2;
  if (a2[1] != *a2)
  {
    unint64_t v30 = 0LL;
    while (1)
    {
      unint64_t v31 = v29 + 16 * v30;
      LODWORD(v73[0]) = *(_DWORD *)v31;
      uint64_t v32 = *(void *)(v31 + 8);
      uint64_t v34 = *(void *)(a1 + 240);
      uint64_t v33 = *(void *)(a1 + 248);
      __str.__r_.__value_.__r.__words[0] = (std::string::size_type)v73;
      *((_DWORD *)sub_1000762D8(v72, (int *)v73, (uint64_t)&unk_1000AF371, &__str) + 5) = (unint64_t)(v33 - v34) >> 3;
      sub_1000764F4((uint64_t **)(a1 + 176), (int *)v73, v73);
      uint64_t v35 = v32;
      if (!*(_BYTE *)(a3 + 48)) {
        uint64_t v35 = (*(uint64_t (**)(uint64_t, void))(*(void *)v32 + 72LL))(v32, 0LL);
      }
      unsigned int v37 = *(uint64_t **)(a1 + 248);
      unint64_t v36 = *(void *)(a1 + 256);
      if ((unint64_t)v37 >= v36)
      {
        uint64_t v39 = (uint64_t *)v71->i64[0];
        uint64_t v40 = ((uint64_t)v37 - v71->i64[0]) >> 3;
        unint64_t v41 = v40 + 1;
        uint64_t v42 = v36 - (void)v39;
        if (v42 >> 2 > v41) {
          unint64_t v41 = v42 >> 2;
        }
        else {
          unint64_t v43 = v41;
        }
        uint64_t v92 = a1 + 256;
        if (v43)
        {
          BOOL v44 = (char *)sub_100018788(a1 + 256, v43);
          uint64_t v39 = *(uint64_t **)(a1 + 240);
          unsigned int v37 = *(uint64_t **)(a1 + 248);
        }

        else
        {
          BOOL v44 = 0LL;
        }

        BOOL v45 = (uint64_t *)&v44[8 * v40];
        uint64_t v46 = &v44[8 * v43];
        unsigned __int8 v91 = v46;
        *BOOL v45 = v35;
        __str.__r_.__value_.__l.__cap_ = (std::string::size_type)(v45 + 1);
        if (v37 == v39)
        {
          std::string::size_type v38 = (std::string::size_type)(v45 + 1);
        }

        else
        {
          do
          {
            uint64_t v47 = *--v37;
            *unsigned int v37 = 0LL;
            *--BOOL v45 = v47;
          }

          while (v37 != v39);
          std::string::size_type v38 = __str.__r_.__value_.__l.__cap_;
          uint64_t v46 = v91;
        }

        __int128 v48 = *(_OWORD *)(a1 + 240);
        *(void *)(a1 + 24RDString::RDString((RDString *)&v66, theString, 0) = v45;
        *(void *)(a1 + 24std::istream::~istream(v2, v3 + 8) = v38;
        *(_OWORD *)&__str.__r_.__value_.__r.__words[1] = v48;
        uint64_t v49 = *(char **)(a1 + 256);
        *(void *)(a1 + 2++*(void *)(result + 56) = v46;
        unsigned __int8 v91 = v49;
        __str.__r_.__value_.__r.__words[0] = v48;
        sub_100069800((uint64_t)&__str);
      }

      else
      {
        *unsigned int v37 = v35;
        std::string::size_type v38 = (std::string::size_type)(v37 + 1);
      }

      *(void *)(a1 + 24std::istream::~istream(v2, v3 + 8) = v38;
      if (!v30) {
        goto LABEL_77;
      }
      uint64_t v50 = *(void *)(a1 + 40);
      uint64_t v51 = (*(uint64_t (**)(uint64_t))(*(void *)v32 + 96LL))(v32);
      if (!sub_10009F090(v50, v51, 1)) {
        break;
      }
LABEL_66:
      uint64_t v56 = *(void *)(a1 + 48);
      uint64_t v57 = (*(uint64_t (**)(uint64_t))(*(void *)v32 + 104LL))(v32);
      if (!sub_10009F090(v56, v57, 1))
      {
        int v58 = byte_1000DDAF8;
        if (byte_1000DDAF8)
        {
          sub_10000A2DC(v80, "FATAL");
          sub_10002A9EC(&v82, (uint64_t)v80);
        }

        else
        {
          sub_10000A2DC(v77, "ERROR");
          sub_10002A9EC(&v79, (uint64_t)v77);
        }

        uint64_t v59 = sub_10002A6A4(&std::cerr, (uint64_t)"ReplaceFstImpl: Output symbols of FST ", 38LL);
        uint64_t v60 = (void *)std::ostream::operator<<(v59, v30);
        sub_10002A6A4(v60, (uint64_t)" do not match output symbols of base FST (0th FST)", 50LL);
        if (v58)
        {
          sub_10002AA94(&v82);
          if (v81 < 0)
          {
            uint64_t v61 = (void *)v80[0];
            goto LABEL_75;
          }
        }

        else
        {
          sub_10002AA94(&v79);
          if (v78 < 0)
          {
            uint64_t v61 = v77[0];
LABEL_75:
            operator delete(v61);
          }
        }

        *(void *)(a1 + 8) |= 4uLL;
      }

LABEL_78:
  BOOL v62 = (int *)(a3 + 28);
  __str.__r_.__value_.__r.__words[0] = a3 + 28;
  int v63 = *((_DWORD *)sub_1000762D8(v72, (int *)(a3 + 28), (uint64_t)&unk_1000AF371, &__str) + 5);
  if (!v63 && *(void *)(a1 + 248) - *(void *)(a1 + 240) >= 9uLL)
  {
    if (byte_1000DDAF8) {
      sub_10000A2DC(&__str, "FATAL");
    }
    else {
      sub_10000A2DC(&__str, "ERROR");
    }
    sub_10002A9EC(&v89, (uint64_t)&__str);
    char v64 = sub_10002A6A4(&std::cerr, (uint64_t)"ReplaceFstImpl: No FST corresponding to root label ", 51LL);
    uint64_t v65 = (void *)std::ostream::operator<<(v64, *v62);
    sub_10002A6A4(v65, (uint64_t)" in the input tuple vector", 26LL);
    sub_10002AA94(&v89);
    *(void *)(a1 + 8) |= 4uLL;
  }

  if (v63 <= 1) {
    int v66 = 1;
  }
  else {
    int v66 = v63;
  }
  *(_DWORD *)(a1 + 264) = v66;
  char v76 = 0;
  *(void *)(a1 + std::istream::~istream(v2, v3 + 8) = *(void *)(a1 + 8) & 4LL | sub_100073ECC( *v62,  a2,  *(_DWORD *)(a1 + 132),  *(_DWORD *)(a1 + 136),  *(_DWORD *)(a1 + 144),  &v76);
  *(_BYTE *)(a1 + 16RDString::RDString((RDString *)&v66, theString, 0) = v76 ^ 1;
  if (dword_1000DE7E8 >= 2)
  {
    sub_10000A2DC(v73, "INFO");
    sub_10002A9EC(&v75, (uint64_t)v73);
    uint64_t v67 = sub_10002A6A4(&std::cerr, (uint64_t)"ReplaceFstImpl::ReplaceFstImpl: always_cache = ", 47LL);
    if (*(_BYTE *)(a1 + 160)) {
      int v68 = "true";
    }
    else {
      int v68 = "false";
    }
    if (*(_BYTE *)(a1 + 160)) {
      uint64_t v69 = 4LL;
    }
    else {
      uint64_t v69 = 5LL;
    }
    sub_10002A6A4(v67, (uint64_t)v68, v69);
    sub_10002AA94(&v75);
    if (v74 < 0) {
      operator delete(v73[0]);
    }
  }

  return a1;
}

void sub_100073D34( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void **a10, void **a11, uint64_t a12, void **a13)
{
  a13 = a11;
  sub_10006C65C(&a13);
  sub_10001A760(a12);
  sub_10001A7A8(v14, *a10);
  sub_1000765AC((uint64_t *)(v13 + 168), 0LL);
  sub_10006C6D8(v13);
  _Unwind_Resume(a1);
}

uint64_t sub_100073ECC(int a1, uint64_t *a2, int a3, int a4, int a5, _BYTE *a6)
{
  uint64_t v6 = a6;
  std::string __p = 0LL;
  uint64_t v59 = 0LL;
  uint64_t v60 = 0LL;
  uint64_t v7 = *a2;
  uint64_t v8 = a2[1] - *a2;
  if (v8)
  {
    int v48 = a3;
    int v49 = a5;
    int v50 = a4;
    unint64_t v9 = 0LL;
    int v10 = 0;
    unint64_t v11 = v8 >> 4;
    int v12 = 1;
    int v13 = 1;
    int v14 = 1;
    char v15 = 1;
    char v16 = 1;
    do
    {
      int v56 = v13;
      int v57 = v12;
      int v17 = v14;
      uint64_t v18 = (int *)(v7 + 16 * v9);
      uint64_t v19 = *v18;
      BOOL v20 = v11 >= v19 && v19 > 0;
      BOOL v54 = v20;
      BOOL v55 = v19 < 0;
      if ((_DWORD)v19 == a1) {
        int v10 = v9;
      }
      uint64_t v21 = *((void *)v18 + 1);
      BOOL v22 = (*(uint64_t (**)(uint64_t))(*(void *)v21 + 16LL))(v21) != -1;
      BOOL v23 = (*(uint64_t (**)(uint64_t, uint64_t, void))(*(void *)v21 + 56LL))(v21, 0x10000000LL, 0LL) != 0;
      BOOL v24 = (*(uint64_t (**)(uint64_t, uint64_t, void))(*(void *)v21 + 56LL))(v21, 0x40000000LL, 0LL) != 0;
      uint64_t v25 = (*(uint64_t (**)(uint64_t, uint64_t, void))(*(void *)v21 + 56LL))(v21, 0xFFFFFFFF0004LL, 0LL);
      uint64_t v26 = v25;
      int64x2_t v27 = v59;
      if (v59 >= v60)
      {
        unint64_t v31 = (char *)__p;
        uint64_t v32 = (v59 - (_BYTE *)__p) >> 3;
        unint64_t v33 = v32 + 1;
        uint64_t v34 = v60 - (_BYTE *)__p;
        if ((v60 - (_BYTE *)__p) >> 2 > v33) {
          unint64_t v33 = v34 >> 2;
        }
        else {
          unint64_t v35 = v33;
        }
        if (v35)
        {
          unint64_t v36 = (char *)sub_100018788((uint64_t)&v60, v35);
          unint64_t v31 = (char *)__p;
          int64x2_t v27 = v59;
        }

        else
        {
          unint64_t v36 = 0LL;
        }

        unsigned int v37 = (uint64_t *)&v36[8 * v32];
        *unsigned int v37 = v26;
        unint64_t v28 = (char *)(v37 + 1);
        int v29 = v17;
        while (v27 != v31)
        {
          uint64_t v38 = *((void *)v27 - 1);
          v27 -= 8;
          *--unsigned int v37 = v38;
        }

        std::string __p = v37;
        uint64_t v59 = v28;
        uint64_t v60 = &v36[8 * v35];
        int v30 = v57;
        if (v31) {
          operator delete(v31);
        }
      }

      else
      {
        *(void *)uint64_t v59 = v25;
        unint64_t v28 = v27 + 8;
        int v29 = v17;
        int v30 = v57;
      }

      v15 &= v55;
      v16 &= v54;
      int v14 = v22 & v29;
      int v12 = v23 & v30;
      int v13 = v24 & v56;
      uint64_t v59 = v28;
      ++v9;
      uint64_t v7 = *a2;
      unint64_t v11 = (a2[1] - *a2) >> 4;
    }

    while (v11 > v9);
    uint64_t v39 = v10;
    unsigned __int8 v40 = v15 | v16;
    uint64_t v6 = a6;
    a5 = v49;
    a4 = v50;
    a3 = v48;
  }

  else
  {
    uint64_t v39 = 0LL;
    unsigned __int8 v40 = 1;
    int v14 = 1;
    LOBYTE(v13) = 1;
    LOBYTE(v12) = 1;
  }

  BOOL v43 = a3 == 4 && a5 != -1 || (a4 & 0xFFFFFFFE) == 2;
  int v44 = (a3 & 0xFFFFFFFE) == 2 || v43;
  uint64_t v45 = sub_1000A49F8( (uint64_t **)&__p,  v39,  (a3 & 0xFFFFFFFD) == 1,  (a4 & 0xFFFFFFFD) == 1,  (a3 - 1) < 2,  (a4 - 1) < 2,  v44,  v14,  v12,  v13,  v40);
  if ((v45 & 0x50000000) != 0) {
    char v46 = v14;
  }
  else {
    char v46 = 0;
  }
  _BYTE *v6 = v46;
  if (__p)
  {
    uint64_t v59 = (char *)__p;
    operator delete(__p);
  }

  return v45;
}

void sub_1000741CC( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1000741F4(uint64_t a1)
{
  *(void *)a1 = off_1000D2748;
  uint64_t v3 = (void **)(a1 + 240);
  sub_10006C65C(&v3);
  sub_10001A760(a1 + 200);
  sub_10001A7A8(a1 + 176, *(void **)(a1 + 184));
  sub_1000765AC((uint64_t *)(a1 + 168), 0LL);
  return sub_10006C6D8(a1);
}

void sub_10007425C(uint64_t a1)
{
  *(void *)a1 = off_1000D2748;
  uint64_t v3 = (void **)(a1 + 240);
  sub_10006C65C(&v3);
  sub_10001A760(a1 + 200);
  sub_10001A7A8(a1 + 176, *(void **)(a1 + 184));
  sub_1000765AC((uint64_t *)(a1 + 168), 0LL);
  int v2 = (void *)sub_10006C6D8(a1);
  operator delete(v2);
}

uint64_t sub_1000742C8(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a1 + 24LL))(a1, 0xFFFFFFFF0007LL);
}

uint64_t sub_1000742DC(void *a1, uint64_t a2)
{
  if ((a2 & 4) != 0)
  {
    uint64_t v4 = a1[30];
    if ((unint64_t)(a1[31] - v4) >= 9)
    {
      unint64_t v5 = 1LL;
      do
      {
        if ((*(uint64_t (**)(void, uint64_t, void))(**(void **)(v4 + 8 * v5) + 56LL))( *(void *)(v4 + 8 * v5),  4LL,  0LL))
        {
          a1[1] |= 4uLL;
        }

        ++v5;
        uint64_t v4 = a1[30];
      }

      while (v5 < (a1[31] - v4) >> 3);
    }
  }

  return a1[1] & a2;
}

uint64_t sub_100074360(uint64_t a1)
{
  uint64_t v2 = sub_100074410(a1, 0LL, 0LL, 0LL);
  sub_1000746FC((void *)(v2 + 136), 0LL, 0LL, 0LL);
  return a1;
}

void sub_1000743A4(_Unwind_Exception *a1)
{
}

uint64_t sub_1000743B8(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 104);
  if (v2)
  {
    *(void *)(a1 + 112) = v2;
    operator delete(v2);
  }

  sub_10007467C(a1 + 32);
  uint64_t v3 = *(void **)(a1 + 8);
  *(void *)(a1 + std::istream::~istream(v2, v3 + 8) = 0LL;
  if (v3) {
    operator delete(v3);
  }
  uint64_t v4 = *(void **)a1;
  *(void *)a1 = 0LL;
  if (v4) {
    operator delete(v4);
  }
  return a1;
}

uint64_t sub_100074410(uint64_t a1, size_t a2, void *a3, void *a4)
{
  if (!a3) {
    a3 = operator new(1uLL);
  }
  *(void *)a1 = a3;
  if (!a4) {
    a4 = operator new(1uLL);
  }
  *(void *)(a1 + std::istream::~istream(v2, v3 + 8) = a4;
  *(void *)(a1 + 16) = a1;
  *(void *)(a1 + ++*(_DWORD *)(result + 24) = a1;
  sub_100074594(a1 + 32, a2, (void *)(a1 + 16), (void *)(a1 + 24));
  *(void *)(a1 + 104) = 0LL;
  *(void *)(a1 + 112) = 0LL;
  *(void *)(a1 + 12RDString::RDString((RDString *)&v66, theString, 0) = 0LL;
  if (a2) {
    sub_1000744F4((void **)(a1 + 104), a2);
  }
  return a1;
}

void sub_1000744A0(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *v1;
  void *v1 = 0LL;
  if (v3) {
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void sub_1000744F4(void **a1, unint64_t a2)
{
  uint64_t v4 = a1[2];
  uint64_t v3 = (uint64_t)(a1 + 2);
  if (a2 > (v4 - (_BYTE *)*a1) >> 4)
  {
    if (a2 >> 60) {
      sub_100018774();
    }
    int64_t v5 = (_BYTE *)a1[1] - (_BYTE *)*a1;
    uint64_t v6 = (char *)sub_1000198A8(v3, a2);
    uint64_t v7 = &v6[v5 & 0xFFFFFFFFFFFFFFF0LL];
    unint64_t v9 = &v6[16 * v8];
    unint64_t v11 = (char *)*a1;
    int v10 = (char *)a1[1];
    int v12 = v7;
    if (v10 != *a1)
    {
      do
      {
        *((_OWORD *)v12 - 1) = *((_OWORD *)v10 - 1);
        v12 -= 16;
        v10 -= 16;
      }

      while (v10 != v11);
      int v10 = (char *)*a1;
    }

    *a1 = v12;
    a1[1] = v7;
    a1[2] = v9;
    if (v10) {
      operator delete(v10);
    }
  }

uint64_t sub_100074594(uint64_t a1, size_t a2, void *a3, void *a4)
{
  uint64_t v8 = (void **)operator new(0x28uLL);
  void v8[3] = 0LL;
  v8[4] = 0LL;
  v8[2] = 0LL;
  *(void *)a1 = 0LL;
  *(void *)(a1 + std::istream::~istream(v2, v3 + 8) = 0LL;
  *(void *)(a1 + 16) = v8;
  *(_OWORD *)uint64_t v8 = xmmword_1000AC980;
  unint64_t v11 = v8;
  sub_10006C608(&v11);
  *(void *)(a1 + ++*(_DWORD *)(result + 24) = 0LL;
  unint64_t v9 = operator new(0x28uLL);
  *(_OWORD *)unint64_t v9 = xmmword_1000AC970;
  v9[3] = 0LL;
  v9[4] = 0LL;
  v9[2] = 0LL;
  *(void *)(a1 + 32) = v9;
  *(void *)(a1 + 4RDString::RDString((RDString *)&v66, theString, 0) = 0LL;
  *(void *)(a1 + 4std::istream::~istream(v2, v3 + 8) = *a3;
  *(_DWORD *)(a1 + ++*(void *)(result + 56) = 1065353216;
  *(void *)(a1 + 64) = *a4;
  sub_10006D600(a1, a2);
  return a1;
}

void sub_100074658(_Unwind_Exception *a1)
{
}

uint64_t sub_10007467C(uint64_t a1)
{
  return sub_10006CB40(a1);
}

void *sub_1000746AC(void *result, void *a2)
{
  if (a2)
  {
    uint64_t v2 = a2;
    uint64_t v3 = result;
    do
    {
      uint64_t v4 = (void *)*v2;
      uint64_t result = sub_10006E014((uint64_t *)v3[4]);
      v2[3] = result[7];
      result[7] = v2;
      uint64_t v2 = v4;
    }

    while (v4);
  }

  return result;
}

void *sub_1000746FC(void *a1, size_t a2, void *a3, void *a4)
{
  if (!a3) {
    a3 = operator new(1uLL);
  }
  *a1 = a3;
  if (!a4) {
    a4 = operator new(1uLL);
  }
  a1[1] = a4;
  a1[2] = a1;
  a1[3] = a1;
  sub_100074894((uint64_t)(a1 + 4), a2, a1 + 2, a1 + 3);
  a1[13] = 0LL;
  a1[14] = 0LL;
  a1[15] = 0LL;
  if (a2) {
    sub_1000747E4(a1 + 13, a2);
  }
  return a1;
}

void sub_100074794( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  int v12 = *v10;
  *int v10 = 0LL;
  if (v12) {
    operator delete(v12);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1000747E4(uint64_t *a1, unint64_t a2)
{
  uint64_t v4 = a1[2];
  uint64_t result = (uint64_t)(a1 + 2);
  if (0xAAAAAAAAAAAAAAABLL * ((v4 - *a1) >> 3) < a2)
  {
    if (a2 >= 0xAAAAAAAAAAAAAABLL) {
      sub_100018774();
    }
    uint64_t v5 = a1[1] - *a1;
    void v7[4] = result;
    v7[0] = sub_100018F00(result, a2);
    v7[1] = v7[0] + v5;
    _OWORD v7[2] = v7[0] + v5;
    v7[3] = v7[0] + 24 * v6;
    sub_100075F50(a1, v7);
    return sub_1000761B8((uint64_t)v7);
  }

  return result;
}

void sub_100074880(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

uint64_t sub_100074894(uint64_t a1, size_t a2, void *a3, void *a4)
{
  uint64_t v8 = (void **)operator new(0x28uLL);
  void v8[3] = 0LL;
  v8[4] = 0LL;
  v8[2] = 0LL;
  *(void *)a1 = 0LL;
  *(void *)(a1 + std::istream::~istream(v2, v3 + 8) = 0LL;
  *(void *)(a1 + 16) = v8;
  *(_OWORD *)uint64_t v8 = xmmword_1000AC980;
  unint64_t v11 = v8;
  sub_10006C608(&v11);
  *(void *)(a1 + ++*(_DWORD *)(result + 24) = 0LL;
  unint64_t v9 = operator new(0x28uLL);
  *(_OWORD *)unint64_t v9 = xmmword_1000AC970;
  v9[3] = 0LL;
  v9[4] = 0LL;
  v9[2] = 0LL;
  *(void *)(a1 + 32) = v9;
  *(void *)(a1 + 4RDString::RDString((RDString *)&v66, theString, 0) = 0LL;
  *(void *)(a1 + 4std::istream::~istream(v2, v3 + 8) = *a3;
  *(_DWORD *)(a1 + ++*(void *)(result + 56) = 1065353216;
  *(void *)(a1 + 64) = *a4;
  sub_1000752E0(a1, a2);
  return a1;
}

void sub_100074958(_Unwind_Exception *a1)
{
}

uint64_t sub_10007497C(uint64_t a1)
{
  uint64_t v2 = *(void **)a1;
  *(void *)a1 = 0LL;
  if (v2) {
    sub_1000749B8(a1 + 8, v2);
  }
  sub_10006C608((void ***)(a1 + 16));
  return a1;
}

void sub_1000749B8(uint64_t a1, void *a2)
{
}

void sub_1000749D4(uint64_t **a1, void *__p, unint64_t a3)
{
  if (a3 == 2)
  {
    uint64_t v4 = sub_100074C04(*a1);
    if (!__p) {
      return;
    }
    std::string __p[2] = v4[7];
    goto LABEL_22;
  }

  if (a3 == 1)
  {
    uint64_t v4 = sub_100074AE0(*a1);
    if (!__p) {
      return;
    }
    __p[1] = v4[7];
    goto LABEL_22;
  }

  if (a3 <= 4)
  {
    uint64_t v4 = sub_100074D28(*a1);
    if (!__p) {
      return;
    }
    __p[4] = v4[7];
    goto LABEL_22;
  }

  if (a3 <= 8)
  {
    uint64_t v4 = sub_100074E4C(*a1);
    if (!__p) {
      return;
    }
    __p[8] = v4[7];
    goto LABEL_22;
  }

  if (a3 <= 0x10)
  {
    uint64_t v4 = sub_100074F70(*a1);
    if (!__p) {
      return;
    }
    __p[16] = v4[7];
    goto LABEL_22;
  }

  if (a3 <= 0x20)
  {
    uint64_t v4 = sub_100075094(*a1);
    if (!__p) {
      return;
    }
    __p[32] = v4[7];
    goto LABEL_22;
  }

  if (a3 > 0x40)
  {
    operator delete(__p);
    return;
  }

  uint64_t v4 = sub_1000751B8(*a1);
  if (__p)
  {
    __p[64] = v4[7];
LABEL_22:
    v4[7] = __p;
  }

void *sub_100074AE0(uint64_t *a1)
{
  uint64_t v2 = a1[2];
  uint64_t v3 = a1 + 2;
  if ((unint64_t)(a1[3] - v2) <= 0x47)
  {
    sub_100069658((uint64_t)(a1 + 2), 9uLL);
    uint64_t v2 = *v3;
  }

  uint64_t v4 = *(void **)(v2 + 64);
  if (!v4)
  {
    uint64_t v4 = operator new(0x40uLL);
    uint64_t v5 = *a1;
    *uint64_t v4 = off_1000D2020;
    sub_10006CE40(v4 + 1, v5);
    v4[7] = 0LL;
    *uint64_t v4 = off_1000D2790;
    uint64_t v6 = *(void *)(*v3 + 64);
    *(void *)(*v3 + 64) = v4;
    if (v6) {
      (*(void (**)(uint64_t))(*(void *)v6 + 8LL))(v6);
    }
  }

  return v4;
}

void sub_100074B80(_Unwind_Exception *a1)
{
}

void *sub_100074B94(void *a1)
{
  *a1 = off_1000D2020;
  a1[1] = off_1000D2048;
  sub_10002B998(a1 + 4);
  return a1;
}

void sub_100074BCC(uint64_t *a1)
{
  *a1 = (uint64_t)off_1000D2020;
  a1[1] = (uint64_t)off_1000D2048;
  sub_10002B998(a1 + 4);
  operator delete(a1);
}

void *sub_100074C04(uint64_t *a1)
{
  uint64_t v2 = a1[2];
  uint64_t v3 = a1 + 2;
  if ((unint64_t)(a1[3] - v2) <= 0x87)
  {
    sub_100069658((uint64_t)(a1 + 2), 0x11uLL);
    uint64_t v2 = *v3;
  }

  uint64_t v4 = *(void **)(v2 + 128);
  if (!v4)
  {
    uint64_t v4 = operator new(0x40uLL);
    uint64_t v5 = *a1;
    *uint64_t v4 = off_1000D1360;
    sub_100069948(v4 + 1, v5);
    v4[7] = 0LL;
    *uint64_t v4 = off_1000D27D0;
    uint64_t v6 = *(void *)(*v3 + 128);
    *(void *)(*v3 + 12std::istream::~istream(v2, v3 + 8) = v4;
    if (v6) {
      (*(void (**)(uint64_t))(*(void *)v6 + 8LL))(v6);
    }
  }

  return v4;
}

void sub_100074CA4(_Unwind_Exception *a1)
{
}

void *sub_100074CB8(void *a1)
{
  *a1 = off_1000D1360;
  a1[1] = off_1000D1388;
  sub_10002B998(a1 + 4);
  return a1;
}

void sub_100074CF0(uint64_t *a1)
{
  *a1 = (uint64_t)off_1000D1360;
  a1[1] = (uint64_t)off_1000D1388;
  sub_10002B998(a1 + 4);
  operator delete(a1);
}

void *sub_100074D28(uint64_t *a1)
{
  uint64_t v2 = a1[2];
  uint64_t v3 = a1 + 2;
  if ((unint64_t)(a1[3] - v2) <= 0x107)
  {
    sub_100069658((uint64_t)(a1 + 2), 0x21uLL);
    uint64_t v2 = *v3;
  }

  uint64_t v4 = *(void **)(v2 + 256);
  if (!v4)
  {
    uint64_t v4 = operator new(0x40uLL);
    uint64_t v5 = *a1;
    *uint64_t v4 = off_1000D1420;
    sub_100069BCC(v4 + 1, v5);
    v4[7] = 0LL;
    *uint64_t v4 = off_1000D2810;
    uint64_t v6 = *(void *)(*v3 + 256);
    *(void *)(*v3 + 2++*(void *)(result + 56) = v4;
    if (v6) {
      (*(void (**)(uint64_t))(*(void *)v6 + 8LL))(v6);
    }
  }

  return v4;
}

void sub_100074DC8(_Unwind_Exception *a1)
{
}

void *sub_100074DDC(void *a1)
{
  *a1 = off_1000D1420;
  a1[1] = off_1000D1448;
  sub_10002B998(a1 + 4);
  return a1;
}

void sub_100074E14(uint64_t *a1)
{
  *a1 = (uint64_t)off_1000D1420;
  a1[1] = (uint64_t)off_1000D1448;
  sub_10002B998(a1 + 4);
  operator delete(a1);
}

void *sub_100074E4C(uint64_t *a1)
{
  uint64_t v2 = a1[2];
  uint64_t v3 = a1 + 2;
  if ((unint64_t)(a1[3] - v2) <= 0x207)
  {
    sub_100069658((uint64_t)(a1 + 2), 0x41uLL);
    uint64_t v2 = *v3;
  }

  uint64_t v4 = *(void **)(v2 + 512);
  if (!v4)
  {
    uint64_t v4 = operator new(0x40uLL);
    uint64_t v5 = *a1;
    *uint64_t v4 = off_1000D14E0;
    sub_100069E50(v4 + 1, v5);
    v4[7] = 0LL;
    *uint64_t v4 = off_1000D2850;
    uint64_t v6 = *(void *)(*v3 + 512);
    *(void *)(*v3 + 512) = v4;
    if (v6) {
      (*(void (**)(uint64_t))(*(void *)v6 + 8LL))(v6);
    }
  }

  return v4;
}

void sub_100074EEC(_Unwind_Exception *a1)
{
}

void *sub_100074F00(void *a1)
{
  *a1 = off_1000D14E0;
  a1[1] = off_1000D1508;
  sub_10002B998(a1 + 4);
  return a1;
}

void sub_100074F38(uint64_t *a1)
{
  *a1 = (uint64_t)off_1000D14E0;
  a1[1] = (uint64_t)off_1000D1508;
  sub_10002B998(a1 + 4);
  operator delete(a1);
}

void *sub_100074F70(uint64_t *a1)
{
  uint64_t v2 = a1[2];
  uint64_t v3 = a1 + 2;
  if ((unint64_t)(a1[3] - v2) <= 0x407)
  {
    sub_100069658((uint64_t)(a1 + 2), 0x81uLL);
    uint64_t v2 = *v3;
  }

  uint64_t v4 = *(void **)(v2 + 1024);
  if (!v4)
  {
    uint64_t v4 = operator new(0x40uLL);
    uint64_t v5 = *a1;
    *uint64_t v4 = off_1000D15A0;
    sub_10006A0D4(v4 + 1, v5);
    v4[7] = 0LL;
    *uint64_t v4 = off_1000D2890;
    uint64_t v6 = *(void *)(*v3 + 1024);
    *(void *)(*v3 + 10++*(_DWORD *)(result + 24) = v4;
    if (v6) {
      (*(void (**)(uint64_t))(*(void *)v6 + 8LL))(v6);
    }
  }

  return v4;
}

void sub_100075010(_Unwind_Exception *a1)
{
}

void *sub_100075024(void *a1)
{
  *a1 = off_1000D15A0;
  a1[1] = off_1000D15C8;
  sub_10002B998(a1 + 4);
  return a1;
}

void sub_10007505C(uint64_t *a1)
{
  *a1 = (uint64_t)off_1000D15A0;
  a1[1] = (uint64_t)off_1000D15C8;
  sub_10002B998(a1 + 4);
  operator delete(a1);
}

void *sub_100075094(uint64_t *a1)
{
  uint64_t v2 = a1[2];
  uint64_t v3 = a1 + 2;
  if ((unint64_t)(a1[3] - v2) <= 0x807)
  {
    sub_100069658((uint64_t)(a1 + 2), 0x101uLL);
    uint64_t v2 = *v3;
  }

  uint64_t v4 = *(void **)(v2 + 2048);
  if (!v4)
  {
    uint64_t v4 = operator new(0x40uLL);
    uint64_t v5 = *a1;
    *uint64_t v4 = off_1000D1660;
    sub_10006A358(v4 + 1, v5);
    v4[7] = 0LL;
    *uint64_t v4 = off_1000D28D0;
    uint64_t v6 = *(void *)(*v3 + 2048);
    *(void *)(*v3 + 204std::istream::~istream(v2, v3 + 8) = v4;
    if (v6) {
      (*(void (**)(uint64_t))(*(void *)v6 + 8LL))(v6);
    }
  }

  return v4;
}

void sub_100075134(_Unwind_Exception *a1)
{
}

void *sub_100075148(void *a1)
{
  *a1 = off_1000D1660;
  a1[1] = off_1000D1688;
  sub_10002B998(a1 + 4);
  return a1;
}

void sub_100075180(uint64_t *a1)
{
  *a1 = (uint64_t)off_1000D1660;
  a1[1] = (uint64_t)off_1000D1688;
  sub_10002B998(a1 + 4);
  operator delete(a1);
}

void *sub_1000751B8(uint64_t *a1)
{
  uint64_t v2 = a1[2];
  uint64_t v3 = a1 + 2;
  if ((unint64_t)(a1[3] - v2) >> 3 <= 0x200)
  {
    sub_100069658((uint64_t)(a1 + 2), 0x201uLL);
    uint64_t v2 = *v3;
  }

  uint64_t v4 = *(void **)(v2 + 4096);
  if (!v4)
  {
    uint64_t v4 = operator new(0x40uLL);
    uint64_t v5 = *a1;
    *uint64_t v4 = off_1000D1720;
    sub_10006A5E0(v4 + 1, v5);
    v4[7] = 0LL;
    *uint64_t v4 = off_1000D2910;
    uint64_t v6 = *(void *)(*v3 + 4096);
    *(void *)(*v3 + 4096) = v4;
    if (v6) {
      (*(void (**)(uint64_t))(*(void *)v6 + 8LL))(v6);
    }
  }

  return v4;
}

void sub_10007525C(_Unwind_Exception *a1)
{
}

void *sub_100075270(void *a1)
{
  *a1 = off_1000D1720;
  a1[1] = off_1000D1748;
  sub_10002B998(a1 + 4);
  return a1;
}

void sub_1000752A8(uint64_t *a1)
{
  *a1 = (uint64_t)off_1000D1720;
  a1[1] = (uint64_t)off_1000D1748;
  sub_10002B998(a1 + 4);
  operator delete(a1);
}

void sub_1000752E0(uint64_t a1, size_t __n)
{
  if (__n == 1)
  {
    size_t prime = 2LL;
  }

  else
  {
    size_t prime = __n;
    if ((__n & (__n - 1)) != 0) {
      size_t prime = std::__next_prime(__n);
    }
  }

  int8x8_t v4 = *(int8x8_t *)(a1 + 8);
  if (prime > *(void *)&v4) {
    goto LABEL_16;
  }
  if (prime < *(void *)&v4)
  {
    unint64_t v5 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 40) / *(float *)(a1 + 56));
    if (*(void *)&v4 < 3uLL || (uint8x8_t v6 = (uint8x8_t)vcnt_s8(v4), v6.i16[0] = vaddlv_u8(v6), v6.u32[0] > 1uLL))
    {
      unint64_t v5 = std::__next_prime(v5);
    }

    else
    {
      uint64_t v7 = 1LL << -(char)__clz(v5 - 1);
      if (v5 >= 2) {
        unint64_t v5 = v7;
      }
    }

    if (prime <= v5) {
      size_t prime = v5;
    }
    if (prime < *(void *)&v4) {
LABEL_16:
    }
      sub_1000753BC(a1, prime);
  }

void sub_1000753BC(uint64_t a1, unint64_t a2)
{
  uint64_t v3 = (unint64_t *)(a1 + 8);
  if (a2)
  {
    unint64_t v5 = sub_10007551C((uint64_t **)(a1 + 16), a2);
    uint8x8_t v6 = *(void **)a1;
    *(void *)a1 = v5;
    if (v6) {
      sub_1000749B8((uint64_t)v3, v6);
    }
    uint64_t v7 = 0LL;
    *uint64_t v3 = a2;
    do
      *(void *)(*(void *)a1 + 8 * v7++) = 0LL;
    while (a2 != v7);
    uint64_t v8 = *(void **)(a1 + 24);
    if (v8)
    {
      unint64_t v9 = v8[1];
      uint8x8_t v10 = (uint8x8_t)vcnt_s8((int8x8_t)a2);
      v10.i16[0] = vaddlv_u8(v10);
      if (v10.u32[0] > 1uLL)
      {
        if (v9 >= a2) {
          v9 %= a2;
        }
      }

      else
      {
        v9 &= a2 - 1;
      }

      *(void *)(*(void *)a1 + 8 * v9) = a1 + 24;
      int v12 = (void *)*v8;
      if (*v8)
      {
        do
        {
          unint64_t v13 = v12[1];
          if (v10.u32[0] > 1uLL)
          {
            if (v13 >= a2) {
              v13 %= a2;
            }
          }

          else
          {
            v13 &= a2 - 1;
          }

          if (v13 != v9)
          {
            if (!*(void *)(*(void *)a1 + 8 * v13))
            {
              *(void *)(*(void *)a1 + 8 * v13) = v8;
              goto LABEL_23;
            }

            void *v8 = *v12;
            *int v12 = **(void **)(*(void *)a1 + 8 * v13);
            **(void **)(*(void *)a1 + 8 * v13) = v12;
            int v12 = v8;
          }

          unint64_t v13 = v9;
LABEL_23:
          uint64_t v8 = v12;
          int v12 = (void *)*v12;
          unint64_t v9 = v13;
        }

        while (v12);
      }
    }
  }

  else
  {
    unint64_t v11 = *(void **)a1;
    *(void *)a1 = 0LL;
    if (v11) {
      sub_1000749B8(a1 + 8, v11);
    }
    *uint64_t v3 = 0LL;
  }

char *sub_10007551C(uint64_t **a1, unint64_t a2)
{
  if (a2 == 2)
  {
    uint64_t v2 = sub_100074C04(*a1);
    uint64_t result = (char *)v2[7];
    if (!result)
    {
      uint64_t result = sub_10006DAB4(v2 + 1, 1LL);
      *((void *)result + 2) = 0LL;
      return result;
    }

    uint64_t v4 = *((void *)result + 2);
    goto LABEL_26;
  }

  if (a2 == 1)
  {
    uint64_t v2 = sub_100074AE0(*a1);
    uint64_t result = (char *)v2[7];
    if (!result)
    {
      uint64_t result = sub_10006D9EC(v2 + 1, 1LL);
      *((void *)result + 1) = 0LL;
      return result;
    }

    uint64_t v4 = *((void *)result + 1);
LABEL_26:
    v2[7] = v4;
    return result;
  }

  if (a2 <= 4)
  {
    uint64_t v2 = sub_100074D28(*a1);
    uint64_t result = (char *)v2[7];
    if (!result)
    {
      uint64_t result = sub_10006DB84(v2 + 1, 1LL);
      *((void *)result + 4) = 0LL;
      return result;
    }

    uint64_t v4 = *((void *)result + 4);
    goto LABEL_26;
  }

  if (a2 <= 8)
  {
    uint64_t v2 = sub_100074E4C(*a1);
    uint64_t result = (char *)v2[7];
    if (!result)
    {
      uint64_t result = sub_10006DC54(v2 + 1, 1LL);
      *((void *)result + std::istream::~istream(v2, v3 + 8) = 0LL;
      return result;
    }

    uint64_t v4 = *((void *)result + 8);
    goto LABEL_26;
  }

  if (a2 <= 0x10)
  {
    uint64_t v2 = sub_100074F70(*a1);
    uint64_t result = (char *)v2[7];
    if (!result)
    {
      uint64_t result = sub_10006DD24(v2 + 1, 1LL);
      *((void *)result + 16) = 0LL;
      return result;
    }

    uint64_t v4 = *((void *)result + 16);
    goto LABEL_26;
  }

  if (a2 <= 0x20)
  {
    uint64_t v2 = sub_100075094(*a1);
    uint64_t result = (char *)v2[7];
    if (!result)
    {
      uint64_t result = sub_10006DDF4(v2 + 1, 1LL);
      *((void *)result + 32) = 0LL;
      return result;
    }

    uint64_t v4 = *((void *)result + 32);
    goto LABEL_26;
  }

  if (a2 <= 0x40)
  {
    uint64_t v2 = sub_1000751B8(*a1);
    uint64_t result = (char *)v2[7];
    if (!result)
    {
      uint64_t result = sub_10006DEC4(v2 + 1, 1LL);
      *((void *)result + 64) = 0LL;
      return result;
    }

    uint64_t v4 = *((void *)result + 64);
    goto LABEL_26;
  }

  if (a2 >> 61) {
    sub_100017F08();
  }
  return (char *)operator new(8 * a2);
}

uint64_t sub_1000756CC(uint64_t a1)
{
  return sub_10007497C(a1);
}

void *sub_1000756FC(void *result, void *a2)
{
  if (a2)
  {
    uint64_t v2 = a2;
    uint64_t v3 = result;
    do
    {
      uint64_t v4 = (void *)*v2;
      uint64_t result = sub_10007574C((uint64_t *)v3[4]);
      v2[3] = result[7];
      result[7] = v2;
      uint64_t v2 = v4;
    }

    while (v4);
  }

  return result;
}

void *sub_10007574C(uint64_t *a1)
{
  uint64_t v2 = a1[2];
  uint64_t v3 = a1 + 2;
  if ((unint64_t)(a1[3] - v2) <= 0xC7)
  {
    sub_100069658((uint64_t)(a1 + 2), 0x19uLL);
    uint64_t v2 = *v3;
  }

  uint64_t v4 = *(void **)(v2 + 192);
  if (!v4)
  {
    uint64_t v4 = operator new(0x40uLL);
    uint64_t v5 = *a1;
    *uint64_t v4 = off_1000D1B60;
    sub_10006B764(v4 + 1, v5);
    v4[7] = 0LL;
    *uint64_t v4 = off_1000D2950;
    uint64_t v6 = *(void *)(*v3 + 192);
    *(void *)(*v3 + 192) = v4;
    if (v6) {
      (*(void (**)(uint64_t))(*(void *)v6 + 8LL))(v6);
    }
  }

  return v4;
}

void sub_1000757EC(_Unwind_Exception *a1)
{
}

void *sub_100075800(void *a1)
{
  *a1 = off_1000D1B60;
  a1[1] = off_1000D1B88;
  sub_10002B998(a1 + 4);
  return a1;
}

void sub_100075838(uint64_t *a1)
{
  *a1 = (uint64_t)off_1000D1B60;
  a1[1] = (uint64_t)off_1000D1B88;
  sub_10002B998(a1 + 4);
  operator delete(a1);
}

void *sub_100075870(uint64_t *a1)
{
  uint64_t v2 = a1[2];
  uint64_t v3 = a1 + 2;
  if ((unint64_t)(a1[3] - v2) <= 0x187)
  {
    sub_100069658((uint64_t)(a1 + 2), 0x31uLL);
    uint64_t v2 = *v3;
  }

  uint64_t v4 = *(void **)(v2 + 384);
  if (!v4)
  {
    uint64_t v4 = operator new(0x40uLL);
    uint64_t v5 = *a1;
    *uint64_t v4 = off_1000D0BA0;
    sub_10002B8A4(v4 + 1, v5);
    v4[7] = 0LL;
    *uint64_t v4 = off_1000D2990;
    uint64_t v6 = *(void *)(*v3 + 384);
    *(void *)(*v3 + 384) = v4;
    if (v6) {
      (*(void (**)(uint64_t))(*(void *)v6 + 8LL))(v6);
    }
  }

  return v4;
}

void sub_100075910(_Unwind_Exception *a1)
{
}

void *sub_100075924(void *a1)
{
  *a1 = off_1000D0BA0;
  a1[1] = off_1000D0BC8;
  sub_10002B998(a1 + 4);
  return a1;
}

void sub_10007595C(uint64_t *a1)
{
  *a1 = (uint64_t)off_1000D0BA0;
  a1[1] = (uint64_t)off_1000D0BC8;
  sub_10002B998(a1 + 4);
  operator delete(a1);
}

void *sub_100075994(uint64_t *a1)
{
  uint64_t v2 = a1[2];
  uint64_t v3 = a1 + 2;
  if ((unint64_t)(a1[3] - v2) <= 0x307)
  {
    sub_100069658((uint64_t)(a1 + 2), 0x61uLL);
    uint64_t v2 = *v3;
  }

  uint64_t v4 = *(void **)(v2 + 768);
  if (!v4)
  {
    uint64_t v4 = operator new(0x40uLL);
    uint64_t v5 = *a1;
    *uint64_t v4 = off_1000D1C60;
    sub_10006BB08(v4 + 1, v5);
    v4[7] = 0LL;
    *uint64_t v4 = off_1000D29D0;
    uint64_t v6 = *(void *)(*v3 + 768);
    *(void *)(*v3 + 76std::istream::~istream(v2, v3 + 8) = v4;
    if (v6) {
      (*(void (**)(uint64_t))(*(void *)v6 + 8LL))(v6);
    }
  }

  return v4;
}

void sub_100075A34(_Unwind_Exception *a1)
{
}

void *sub_100075A48(void *a1)
{
  *a1 = off_1000D1C60;
  a1[1] = off_1000D1C88;
  sub_10002B998(a1 + 4);
  return a1;
}

void sub_100075A80(uint64_t *a1)
{
  *a1 = (uint64_t)off_1000D1C60;
  a1[1] = (uint64_t)off_1000D1C88;
  sub_10002B998(a1 + 4);
  operator delete(a1);
}

void *sub_100075AB8(uint64_t *a1)
{
  uint64_t v2 = a1[2];
  uint64_t v3 = a1 + 2;
  if ((unint64_t)(a1[3] - v2) <= 0x607)
  {
    sub_100069658((uint64_t)(a1 + 2), 0xC1uLL);
    uint64_t v2 = *v3;
  }

  uint64_t v4 = *(void **)(v2 + 1536);
  if (!v4)
  {
    uint64_t v4 = operator new(0x40uLL);
    uint64_t v5 = *a1;
    *uint64_t v4 = off_1000D1D20;
    sub_10006BD8C(v4 + 1, v5);
    v4[7] = 0LL;
    *uint64_t v4 = off_1000D2A10;
    uint64_t v6 = *(void *)(*v3 + 1536);
    *(void *)(*v3 + 1536) = v4;
    if (v6) {
      (*(void (**)(uint64_t))(*(void *)v6 + 8LL))(v6);
    }
  }

  return v4;
}

void sub_100075B58(_Unwind_Exception *a1)
{
}

void *sub_100075B6C(void *a1)
{
  *a1 = off_1000D1D20;
  a1[1] = off_1000D1D48;
  sub_10002B998(a1 + 4);
  return a1;
}

void sub_100075BA4(uint64_t *a1)
{
  *a1 = (uint64_t)off_1000D1D20;
  a1[1] = (uint64_t)off_1000D1D48;
  sub_10002B998(a1 + 4);
  operator delete(a1);
}

void *sub_100075BDC(uint64_t *a1)
{
  uint64_t v2 = a1[2];
  uint64_t v3 = a1 + 2;
  if ((unint64_t)(a1[3] - v2) <= 0xC07)
  {
    sub_100069658((uint64_t)(a1 + 2), 0x181uLL);
    uint64_t v2 = *v3;
  }

  uint64_t v4 = *(void **)(v2 + 3072);
  if (!v4)
  {
    uint64_t v4 = operator new(0x40uLL);
    uint64_t v5 = *a1;
    *uint64_t v4 = off_1000D1DE0;
    sub_10006C010(v4 + 1, v5);
    v4[7] = 0LL;
    *uint64_t v4 = off_1000D2A50;
    uint64_t v6 = *(void *)(*v3 + 3072);
    *(void *)(*v3 + 30sub_10001A760(v25 - 72) = v4;
    if (v6) {
      (*(void (**)(uint64_t))(*(void *)v6 + 8LL))(v6);
    }
  }

  return v4;
}

void sub_100075C7C(_Unwind_Exception *a1)
{
}

void *sub_100075C90(void *a1)
{
  *a1 = off_1000D1DE0;
  a1[1] = off_1000D1E08;
  sub_10002B998(a1 + 4);
  return a1;
}

void sub_100075CC8(uint64_t *a1)
{
  *a1 = (uint64_t)off_1000D1DE0;
  a1[1] = (uint64_t)off_1000D1E08;
  sub_10002B998(a1 + 4);
  operator delete(a1);
}

void *sub_100075D00(uint64_t *a1)
{
  uint64_t v2 = a1[2];
  uint64_t v3 = a1 + 2;
  if ((unint64_t)(a1[3] - v2) >> 3 <= 0x300)
  {
    sub_100069658((uint64_t)(a1 + 2), 0x301uLL);
    uint64_t v2 = *v3;
  }

  uint64_t v4 = *(void **)(v2 + 6144);
  if (!v4)
  {
    uint64_t v4 = operator new(0x40uLL);
    uint64_t v5 = *a1;
    *uint64_t v4 = off_1000D1EA0;
    sub_10006C298(v4 + 1, v5);
    v4[7] = 0LL;
    *uint64_t v4 = off_1000D2A90;
    uint64_t v6 = *(void *)(*v3 + 6144);
    *(void *)(*v3 + 6144) = v4;
    if (v6) {
      (*(void (**)(uint64_t))(*(void *)v6 + 8LL))(v6);
    }
  }

  return v4;
}

void sub_100075DA4(_Unwind_Exception *a1)
{
}

void *sub_100075DB8(void *a1)
{
  *a1 = off_1000D1EA0;
  a1[1] = off_1000D1EC8;
  sub_10002B998(a1 + 4);
  return a1;
}

void sub_100075DF0(uint64_t *a1)
{
  *a1 = (uint64_t)off_1000D1EA0;
  a1[1] = (uint64_t)off_1000D1EC8;
  sub_10002B998(a1 + 4);
  operator delete(a1);
}

void *sub_100075E28(uint64_t *a1)
{
  uint64_t v2 = a1[2];
  uint64_t v3 = a1 + 2;
  if ((unint64_t)(a1[3] - v2) >> 3 <= 0x600)
  {
    sub_100069658((uint64_t)(a1 + 2), 0x601uLL);
    uint64_t v2 = *v3;
  }

  uint64_t v4 = *(void **)(v2 + 12288);
  if (!v4)
  {
    uint64_t v4 = operator new(0x40uLL);
    uint64_t v5 = *a1;
    *uint64_t v4 = off_1000D1F60;
    sub_10006C520(v4 + 1, v5);
    v4[7] = 0LL;
    *uint64_t v4 = off_1000D2AD0;
    uint64_t v6 = *(void *)(*v3 + 12288);
    *(void *)(*v3 + 1228std::istream::~istream(v2, v3 + 8) = v4;
    if (v6) {
      (*(void (**)(uint64_t))(*(void *)v6 + 8LL))(v6);
    }
  }

  return v4;
}

void sub_100075ECC(_Unwind_Exception *a1)
{
}

void *sub_100075EE0(void *a1)
{
  *a1 = off_1000D1F60;
  a1[1] = off_1000D1F88;
  sub_10002B998(a1 + 4);
  return a1;
}

void sub_100075F18(uint64_t *a1)
{
  *a1 = (uint64_t)off_1000D1F60;
  a1[1] = (uint64_t)off_1000D1F88;
  sub_10002B998(a1 + 4);
  operator delete(a1);
}

uint64_t sub_100075F50(uint64_t *a1, void *a2)
{
  uint64_t result = sub_100075FC4((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t sub_100075FC4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7 = a7;
  *(void *)&__int128 v18 = a6;
  *((void *)&v18 + 1) = a7;
  __int128 v17 = v18;
  v15[0] = a1;
  v15[1] = &v17;
  void v15[2] = &v18;
  char v16 = 0;
  if (a3 == a5)
  {
    uint64_t v13 = a6;
  }

  else
  {
    uint64_t v9 = a3;
    do
    {
      *(void *)(v7 - ++*(_DWORD *)(result + 24) = 0LL;
      *(void *)(v7 - 16) = 0LL;
      uint8x8_t v10 = (void *)(v7 - 24);
      void v10[2] = 0LL;
      unint64_t v11 = *(const void **)(v9 - 24);
      uint64_t v12 = *(void *)(v9 - 16);
      v9 -= 24LL;
      sub_100076088(v10, v11, v12, (v12 - (uint64_t)v11) >> 3);
      uint64_t v7 = *((void *)&v18 + 1) - 24LL;
      *((void *)&v18 + 1) -= 24LL;
    }

    while (v9 != a5);
    uint64_t v13 = v18;
  }

  char v16 = 1;
  sub_100076140((uint64_t)v15);
  return v13;
}

void sub_100076074( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void *sub_100076088(void *result, const void *a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    uint64_t v6 = result;
    uint64_t result = sub_100076100(result, a4);
    uint64_t v7 = v6[1];
    size_t v8 = a3 - (void)a2;
    if (v8) {
      uint64_t result = memmove((void *)v6[1], a2, v8);
    }
    v6[1] = v7 + v8;
  }

  return result;
}

void sub_1000760E4(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + std::istream::~istream(v2, v3 + 8) = v3;
    operator delete(v3);
  }

  _Unwind_Resume(exception_object);
}

char *sub_100076100(void *a1, unint64_t a2)
{
  if (a2 >> 61) {
    sub_100018774();
  }
  uint64_t result = (char *)sub_100018788((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[8 * v4];
  return result;
}

uint64_t sub_100076140(uint64_t a1)
{
  if (!*(_BYTE *)(a1 + 24)) {
    sub_100076174(a1);
  }
  return a1;
}

void sub_100076174(uint64_t a1)
{
  uint64_t v1 = *(void *)(*(void *)(a1 + 16) + 8LL);
  uint64_t v2 = *(void *)(*(void *)(a1 + 8) + 8LL);
  while (v1 != v2)
  {
    uint64_t v3 = *(void **)v1;
    if (*(void *)v1)
    {
      *(void *)(v1 + std::istream::~istream(v2, v3 + 8) = v3;
      operator delete(v3);
    }

    v1 += 24LL;
  }

uint64_t sub_1000761B8(uint64_t a1)
{
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void sub_1000761EC(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 16);
  while (v2 != a2)
  {
    uint64_t v5 = *(void **)(v2 - 24);
    *(void *)(a1 + 16) = v2 - 24;
    if (v5)
    {
      *(void *)(v2 - 16) = v5;
      operator delete(v5);
      uint64_t v2 = *(void *)(a1 + 16);
    }

    else
    {
      v2 -= 24LL;
    }
  }

void sub_100076244(void ***a1)
{
  uint64_t v2 = *a1;
  if (*v2)
  {
    sub_100076284((uint64_t *)v2);
    operator delete(**a1);
  }

void sub_100076284(uint64_t *a1)
{
  uint64_t v3 = *a1;
  uint64_t v2 = a1[1];
  if (v2 != *a1)
  {
    uint64_t v4 = a1[1];
    do
    {
      uint64_t v6 = *(void **)(v4 - 24);
      v4 -= 24LL;
      uint64_t v5 = v6;
      if (v6)
      {
        *(void *)(v2 - 16) = v5;
        operator delete(v5);
      }

      uint64_t v2 = v4;
    }

    while (v4 != v3);
  }

  a1[1] = v3;
}

void *sub_1000762D8(uint64_t a1, int *a2, uint64_t a3, _DWORD **a4)
{
  unint64_t v7 = *a2;
  unint64_t v8 = *(void *)(a1 + 8);
  if (v8)
  {
    uint8x8_t v9 = (uint8x8_t)vcnt_s8((int8x8_t)v8);
    v9.i16[0] = vaddlv_u8(v9);
    if (v9.u32[0] > 1uLL)
    {
      unint64_t v4 = *a2;
      if (v8 <= v7) {
        unint64_t v4 = v7 % v8;
      }
    }

    else
    {
      unint64_t v4 = (v8 - 1) & v7;
    }

    uint8x8_t v10 = *(void ***)(*(void *)a1 + 8 * v4);
    if (v10)
    {
      unint64_t v11 = *v10;
      if (*v10)
      {
        do
        {
          unint64_t v12 = v11[1];
          if (v12 == v7)
          {
            if (*((_DWORD *)v11 + 4) == (_DWORD)v7) {
              return v11;
            }
          }

          else
          {
            if (v9.u32[0] > 1uLL)
            {
              if (v12 >= v8) {
                v12 %= v8;
              }
            }

            else
            {
              v12 &= v8 - 1;
            }

            if (v12 != v4) {
              break;
            }
          }

          unint64_t v11 = (void *)*v11;
        }

        while (v11);
      }
    }
  }

  unint64_t v11 = operator new(0x18uLL);
  *unint64_t v11 = 0LL;
  v11[1] = v7;
  *((_DWORD *)v11 + 4) = **a4;
  *((_DWORD *)v11 + 5) = 0;
  float v13 = (float)(unint64_t)(*(void *)(a1 + 24) + 1LL);
  float v14 = *(float *)(a1 + 32);
  if (!v8 || (float)(v14 * (float)v8) < v13)
  {
    BOOL v15 = 1LL;
    if (v8 >= 3) {
      BOOL v15 = (v8 & (v8 - 1)) != 0;
    }
    unint64_t v16 = v15 | (2 * v8);
    unint64_t v17 = vcvtps_u32_f32(v13 / v14);
    if (v16 <= v17) {
      size_t v18 = v17;
    }
    else {
      size_t v18 = v16;
    }
    sub_100018334(a1, v18);
    unint64_t v8 = *(void *)(a1 + 8);
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v8 <= v7) {
        unint64_t v4 = v7 % v8;
      }
      else {
        unint64_t v4 = v7;
      }
    }

    else
    {
      unint64_t v4 = (v8 - 1) & v7;
    }
  }

  uint64_t v19 = *(void *)a1;
  BOOL v20 = *(void **)(*(void *)a1 + 8 * v4);
  if (v20)
  {
    *unint64_t v11 = *v20;
LABEL_38:
    *BOOL v20 = v11;
    goto LABEL_39;
  }

  *unint64_t v11 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = v11;
  *(void *)(v19 + 8 * RDQSREngine::MatchResult(this, v4) = a1 + 16;
  if (*v11)
  {
    unint64_t v21 = *(void *)(*v11 + 8LL);
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v21 >= v8) {
        v21 %= v8;
      }
    }

    else
    {
      v21 &= v8 - 1;
    }

    BOOL v20 = (void *)(*(void *)a1 + 8 * v21);
    goto LABEL_38;
  }

void sub_1000764E0(_Unwind_Exception *a1)
{
}

uint64_t **sub_1000764F4(uint64_t **a1, int *a2, _DWORD *a3)
{
  uint64_t v6 = a1 + 1;
  uint64_t v5 = a1[1];
  if (v5)
  {
    int v7 = *a2;
    while (1)
    {
      while (1)
      {
        unint64_t v8 = (uint64_t **)v5;
        int v9 = *((_DWORD *)v5 + 7);
        if (v7 >= v9) {
          break;
        }
        uint64_t v5 = *v8;
        uint64_t v6 = v8;
        if (!*v8) {
          goto LABEL_10;
        }
      }

      if (v9 >= v7) {
        break;
      }
      uint64_t v5 = v8[1];
      if (!v5)
      {
        uint64_t v6 = v8 + 1;
        goto LABEL_10;
      }
    }
  }

  else
  {
    unint64_t v8 = a1 + 1;
LABEL_10:
    uint8x8_t v10 = (uint64_t *)operator new(0x20uLL);
    *((_DWORD *)v10 + 7) = *a3;
    sub_100019D14(a1, (uint64_t)v8, v6, v10);
    return (uint64_t **)v10;
  }

  return v8;
}

void sub_1000765AC(uint64_t *a1, uint64_t a2)
{
  uint64_t v3 = *a1;
  *a1 = a2;
  if (v3)
  {
    unint64_t v4 = (void *)sub_1000765D8(v3);
    operator delete(v4);
  }

uint64_t sub_1000765D8(uint64_t a1)
{
  unint64_t v8 = (void **)(a1 + 240);
  sub_100076244(&v8);
  sub_1000756CC(a1 + 168);
  uint64_t v2 = *(void **)(a1 + 144);
  *(void *)(a1 + 144) = 0LL;
  if (v2) {
    operator delete(v2);
  }
  uint64_t v3 = *(void **)(a1 + 136);
  *(void *)(a1 + 136) = 0LL;
  if (v3) {
    operator delete(v3);
  }
  unint64_t v4 = *(void **)(a1 + 104);
  if (v4)
  {
    *(void *)(a1 + 112) = v4;
    operator delete(v4);
  }

  sub_10007467C(a1 + 32);
  uint64_t v5 = *(void **)(a1 + 8);
  *(void *)(a1 + std::istream::~istream(v2, v3 + 8) = 0LL;
  if (v5) {
    operator delete(v5);
  }
  uint64_t v6 = *(void **)a1;
  *(void *)a1 = 0LL;
  if (v6) {
    operator delete(v6);
  }
  return a1;
}

uint64_t sub_100076670(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 56)) {
    return *(unsigned int *)(a1 + 60);
  }
  if ((*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a1 + 24LL))(a1, 4LL))
  {
    *(_BYTE *)(a1 + ++*(void *)(result + 56) = 1;
    return *(unsigned int *)(a1 + 60);
  }

  if (*(_BYTE *)(a1 + 56)) {
    return *(unsigned int *)(a1 + 60);
  }
  uint64_t v3 = *(void *)(a1 + 240);
  if (*(void *)(a1 + 248) - v3 == 8)
  {
    uint64_t result = 0xFFFFFFFFLL;
    *(_DWORD *)(a1 + 6RDString::RDString((RDString *)&v66, theString, 0) = -1;
    *(_BYTE *)(a1 + ++*(void *)(result + 56) = 1;
    if ((*(_DWORD *)(a1 + 64) & 0x80000000) != 0) {
      *(_DWORD *)(a1 + 64) = 0;
    }
  }

  else
  {
    uint64_t v4 = *(void *)(v3 + 8LL * *(int *)(a1 + 264));
    uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)v4 + 16LL))(v4);
    if ((_DWORD)result != -1)
    {
      unsigned int v5 = result;
      memset(__p, 0, sizeof(__p));
      uint64_t v6 = (void *)sub_1000767B0((void *)(*(void *)(a1 + 168) + 136LL), (uint64_t)__p, 1);
      if (__p[0])
      {
        __p[1] = __p[0];
        operator delete(__p[0]);
      }

      int v7 = *(void **)(a1 + 168);
      unsigned int v8 = *(_DWORD *)(a1 + 264);
      __p[0] = v6;
      __p[1] = (void *)__PAIR64__(v5, v8);
      uint64_t result = sub_1000770AC(v7, __p, 1);
      *(_DWORD *)(a1 + 6RDString::RDString((RDString *)&v66, theString, 0) = result;
      *(_BYTE *)(a1 + ++*(void *)(result + 56) = 1;
    }
  }

  return result;
}

void sub_100076794( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1000767B0(void *a1, uint64_t a2, int a3)
{
  a1[16] = a2;
  uint64_t v4 = a1 + 4;
  if (!a3)
  {
    uint64_t v6 = sub_100076FA8(v4, &qword_1000AF378);
    if (!v6) {
      return -1LL;
    }
    return v6[2];
  }

  uint64_t v6 = sub_100076868((uint64_t)v4, &qword_1000AF378, &qword_1000AF378);
  if (!v7) {
    return v6[2];
  }
  unint64_t v8 = a1[14];
  unint64_t v9 = a1[15];
  unint64_t v10 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v8 - a1[13]) >> 3);
  _DWORD v6[2] = v10;
  unint64_t v11 = a1 + 13;
  if (v8 >= v9)
  {
    uint64_t v12 = sub_100076E94(v11, a2);
  }

  else
  {
    sub_100076E44((uint64_t)v11, a2);
    uint64_t v12 = v8 + 24;
  }

  a1[14] = v12;
  return v10;
}

char *sub_100076868(uint64_t a1, uint64_t *a2, void *a3)
{
  unint64_t v7 = sub_100076AE0((uint64_t *)(a1 + 48), *a2);
  unint64_t v8 = v7;
  unint64_t v9 = *(void *)(a1 + 8);
  if (v9)
  {
    uint8x8_t v10 = (uint8x8_t)vcnt_s8((int8x8_t)v9);
    v10.i16[0] = vaddlv_u8(v10);
    unint64_t v11 = v10.u32[0];
    if (v10.u32[0] > 1uLL)
    {
      unint64_t v3 = v7;
      if (v7 >= v9) {
        unint64_t v3 = v7 % v9;
      }
    }

    else
    {
      unint64_t v3 = (v9 - 1) & v7;
    }

    uint64_t v12 = *(char ***)(*(void *)a1 + 8 * v3);
    if (v12)
    {
      for (uint64_t i = *v12; i; uint64_t i = *(char **)i)
      {
        unint64_t v14 = *((void *)i + 1);
        if (v14 == v8)
        {
        }

        else
        {
          if (v11 > 1)
          {
            if (v14 >= v9) {
              v14 %= v9;
            }
          }

          else
          {
            v14 &= v9 - 1;
          }

          if (v14 != v3) {
            break;
          }
        }
      }
    }
  }

  uint64_t i = sub_100076C48((uint64_t **)(a1 + 32), 1uLL);
  *(void *)uint64_t i = 0LL;
  *((void *)i + 1) = v8;
  *((void *)i + 2) = *a3;
  float v15 = (float)(unint64_t)(*(void *)(a1 + 40) + 1LL);
  float v16 = *(float *)(a1 + 56);
  if (!v9 || (float)(v16 * (float)v9) < v15)
  {
    BOOL v17 = 1LL;
    if (v9 >= 3) {
      BOOL v17 = (v9 & (v9 - 1)) != 0;
    }
    unint64_t v18 = v17 | (2 * v9);
    unint64_t v19 = vcvtps_u32_f32(v15 / v16);
    if (v18 <= v19) {
      size_t v20 = v19;
    }
    else {
      size_t v20 = v18;
    }
    sub_1000752E0(a1, v20);
    unint64_t v9 = *(void *)(a1 + 8);
    if ((v9 & (v9 - 1)) != 0)
    {
      if (v8 >= v9) {
        unint64_t v3 = v8 % v9;
      }
      else {
        unint64_t v3 = v8;
      }
    }

    else
    {
      unint64_t v3 = (v9 - 1) & v8;
    }
  }

  unint64_t v21 = *(char ***)(*(void *)a1 + 8 * v3);
  if (v21)
  {
    *(void *)uint64_t i = *v21;
LABEL_38:
    *unint64_t v21 = i;
    goto LABEL_39;
  }

  *(void *)uint64_t i = *(void *)(a1 + 24);
  *(void *)(a1 + ++*(_DWORD *)(result + 24) = i;
  *(void *)(*(void *)a1 + 8 * v3) = a1 + 24;
  if (*(void *)i)
  {
    unint64_t v22 = *(void *)(*(void *)i + 8LL);
    if ((v9 & (v9 - 1)) != 0)
    {
      if (v22 >= v9) {
        v22 %= v9;
      }
    }

    else
    {
      v22 &= v9 - 1;
    }

    unint64_t v21 = (char **)(*(void *)a1 + 8 * v22);
    goto LABEL_38;
  }

void sub_100076AC4(_Unwind_Exception *a1)
{
}

uint64_t sub_100076AE0(uint64_t *a1, uint64_t a2)
{
  if (a2 < -1) {
    return 0LL;
  }
  uint64_t v2 = *a1;
  unint64_t v3 = a2 == -1 ? *(int ***)(v2 + 128) : (int **)(*(void *)(v2 + 104) + 24 * a2);
  uint64_t v4 = *v3;
  unsigned int v5 = v3[1];
  if (v4 == v5) {
    return 0LL;
  }
  uint64_t result = 0LL;
  do
  {
    uint64_t v7 = *v4;
    int v8 = v4[1];
    v4 += 2;
    result += v7 + 7863LL * v8;
  }

  while (v4 != v5);
  return result;
}

BOOL sub_100076B38(uint64_t **a1, uint64_t a2, uint64_t a3)
{
  if (a2 == a3) {
    return 1LL;
  }
  BOOL result = 0LL;
  if (a2 >= -1 && a3 >= -1)
  {
    unsigned int v5 = *a1;
    if (a2 == -1) {
      uint64_t v6 = v5[16];
    }
    else {
      uint64_t v6 = v5[13] + 24 * a2;
    }
    if (a3 == -1) {
      uint64_t v7 = v5[16];
    }
    else {
      uint64_t v7 = v5[13] + 24 * a3;
    }
    return sub_100076BA4(v5[1], v6, v7);
  }

  return result;
}

BOOL sub_100076BA4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = *(_DWORD **)a2;
  unint64_t v3 = *(_DWORD **)(a2 + 8);
  unint64_t v5 = ((uint64_t)v3 - *(void *)a2) >> 3;
  uint64_t v6 = *(_DWORD **)a3;
  if (v3 == v4) {
    return 1LL;
  }
  uint64_t v7 = v5 <= 1 ? 1LL : ((uint64_t)v3 - *(void *)a2) >> 3;
  if (*v4 != *v6 || v4[1] != v6[1]) {
    return 0LL;
  }
  int v8 = v6 + 3;
  unint64_t v9 = v4 + 3;
  uint64_t v10 = 1LL;
  do
  {
    unint64_t v11 = v10;
    if (v7 == v10) {
      break;
    }
    if (*(v9 - 1) != *(v8 - 1)) {
      break;
    }
    int v13 = *v9;
    v9 += 2;
    int v12 = v13;
    int v14 = *v8;
    v8 += 2;
    ++v10;
  }

  while (v12 == v14);
  return v11 >= v5;
}

char *sub_100076C48(uint64_t **a1, unint64_t a2)
{
  if (a2 == 2)
  {
    uint64_t v2 = sub_100075870(*a1);
    BOOL result = (char *)v2[7];
    if (!result)
    {
      BOOL result = sub_10002BED8(v2 + 1, 1LL);
      *((void *)result + 6) = 0LL;
      return result;
    }

    uint64_t v4 = *((void *)result + 6);
    goto LABEL_26;
  }

  if (a2 == 1)
  {
    uint64_t v2 = sub_10007574C(*a1);
    BOOL result = (char *)v2[7];
    if (!result)
    {
      BOOL result = sub_10006FA3C(v2 + 1, 1LL);
      *((void *)result + 3) = 0LL;
      return result;
    }

    uint64_t v4 = *((void *)result + 3);
LABEL_26:
    v2[7] = v4;
    return result;
  }

  if (a2 <= 4)
  {
    uint64_t v2 = sub_100075994(*a1);
    BOOL result = (char *)v2[7];
    if (!result)
    {
      BOOL result = sub_10006FB04(v2 + 1, 1LL);
      *((void *)result + 12) = 0LL;
      return result;
    }

    uint64_t v4 = *((void *)result + 12);
    goto LABEL_26;
  }

  if (a2 <= 8)
  {
    uint64_t v2 = sub_100075AB8(*a1);
    BOOL result = (char *)v2[7];
    if (!result)
    {
      BOOL result = sub_10006FBD8(v2 + 1, 1LL);
      *((void *)result + ++*(_DWORD *)(result + 24) = 0LL;
      return result;
    }

    uint64_t v4 = *((void *)result + 24);
    goto LABEL_26;
  }

  if (a2 <= 0x10)
  {
    uint64_t v2 = sub_100075BDC(*a1);
    BOOL result = (char *)v2[7];
    if (!result)
    {
      BOOL result = sub_10006FCAC(v2 + 1, 1LL);
      *((void *)result + 4std::istream::~istream(v2, v3 + 8) = 0LL;
      return result;
    }

    uint64_t v4 = *((void *)result + 48);
    goto LABEL_26;
  }

  if (a2 <= 0x20)
  {
    uint64_t v2 = sub_100075D00(*a1);
    BOOL result = (char *)v2[7];
    if (!result)
    {
      BOOL result = sub_10006FD80(v2 + 1, 1LL);
      *((void *)result + 96) = 0LL;
      return result;
    }

    uint64_t v4 = *((void *)result + 96);
    goto LABEL_26;
  }

  if (a2 <= 0x40)
  {
    uint64_t v2 = sub_100075E28(*a1);
    BOOL result = (char *)v2[7];
    if (!result)
    {
      BOOL result = sub_10006FE54(v2 + 1, 1LL);
      *((void *)result + 192) = 0LL;
      return result;
    }

    uint64_t v4 = *((void *)result + 192);
    goto LABEL_26;
  }

  if (a2 >= 0xAAAAAAAAAAAAAABLL) {
    sub_100017F08();
  }
  return (char *)operator new(24 * a2);
}

uint64_t ***sub_100076E08(uint64_t ***result, uint64_t a2)
{
  if (a2)
  {
    BOOL result = (uint64_t ***)sub_10007574C(**result);
    *(void *)(a2 + ++*(_DWORD *)(result + 24) = result[7];
    result[7] = (uint64_t **)a2;
  }

  return result;
}

void *sub_100076E44(uint64_t a1, uint64_t a2)
{
  unint64_t v3 = *(void **)(a1 + 8);
  *unint64_t v3 = 0LL;
  v3[1] = 0LL;
  _OWORD v3[2] = 0LL;
  BOOL result = sub_100076088( v3,  *(const void **)a2,  *(void *)(a2 + 8),  (uint64_t)(*(void *)(a2 + 8) - *(void *)a2) >> 3);
  *(void *)(a1 + std::istream::~istream(v2, v3 + 8) = v3 + 3;
  return result;
}

void sub_100076E8C(_Unwind_Exception *a1)
{
  *(void *)(v1 + std::istream::~istream(v2, v3 + 8) = v2;
  _Unwind_Resume(a1);
}

uint64_t sub_100076E94(uint64_t *a1, uint64_t a2)
{
  uint64_t v3 = *a1;
  unint64_t v4 = 0xAAAAAAAAAAAAAAABLL * ((a1[1] - *a1) >> 3);
  unint64_t v5 = v4 + 1;
  if (v4 + 1 > 0xAAAAAAAAAAAAAAALL) {
    sub_100018774();
  }
  uint64_t v7 = (uint64_t)(a1 + 2);
  unint64_t v8 = 0xAAAAAAAAAAAAAAABLL * ((a1[2] - v3) >> 3);
  if (2 * v8 > v5) {
    unint64_t v5 = 2 * v8;
  }
  if (v8 >= 0x555555555555555LL) {
    unint64_t v9 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v9 = v5;
  }
  BOOL v17 = a1 + 2;
  if (v9) {
    uint64_t v10 = (char *)sub_100018F00(v7, v9);
  }
  else {
    uint64_t v10 = 0LL;
  }
  unint64_t v11 = &v10[24 * v4];
  v14[0] = v10;
  v14[1] = v11;
  float v15 = v11;
  float v16 = &v10[24 * v9];
  *(void *)unint64_t v11 = 0LL;
  *((void *)v11 + 1) = 0LL;
  *((void *)v11 + 2) = 0LL;
  sub_100076088(v11, *(const void **)a2, *(void *)(a2 + 8), (uint64_t)(*(void *)(a2 + 8) - *(void *)a2) >> 3);
  v15 += 24;
  sub_100075F50(a1, v14);
  uint64_t v12 = a1[1];
  sub_1000761B8((uint64_t)v14);
  return v12;
}

void sub_100076F94(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

void *sub_100076FA8(void *a1, uint64_t *a2)
{
  unint64_t v4 = sub_100076AE0(a1 + 6, *a2);
  int8x8_t v5 = (int8x8_t)a1[1];
  if (!*(void *)&v5) {
    return 0LL;
  }
  unint64_t v6 = v4;
  uint8x8_t v7 = (uint8x8_t)vcnt_s8(v5);
  v7.i16[0] = vaddlv_u8(v7);
  unint64_t v8 = v7.u32[0];
  if (v7.u32[0] > 1uLL)
  {
    unint64_t v9 = v4;
    if (v4 >= *(void *)&v5) {
      unint64_t v9 = v4 % *(void *)&v5;
    }
  }

  else
  {
    unint64_t v9 = (*(void *)&v5 - 1LL) & v4;
  }

  uint64_t v10 = *(void **)(*a1 + 8 * v9);
  if (!v10) {
    return 0LL;
  }
  unint64_t v11 = (void *)*v10;
  if (*v10)
  {
    uint64_t v12 = (uint64_t **)(a1 + 8);
    do
    {
      unint64_t v13 = v11[1];
      if (v13 == v6)
      {
        if (sub_100076B38(v12, v11[2], *a2)) {
          return v11;
        }
      }

      else
      {
        if (v8 > 1)
        {
          if (v13 >= *(void *)&v5) {
            v13 %= *(void *)&v5;
          }
        }

        else
        {
          v13 &= *(void *)&v5 - 1LL;
        }

        if (v13 != v9) {
          return 0LL;
        }
      }

      unint64_t v11 = (void *)*v11;
    }

    while (v11);
  }

  return v11;
}

uint64_t sub_1000770AC(void *a1, _OWORD *a2, int a3)
{
  a1[16] = a2;
  unint64_t v4 = a1 + 4;
  if (!a3)
  {
    unint64_t v6 = sub_100077534(v4, &dword_1000AF380);
    if (!v6) {
      return 0xFFFFFFFFLL;
    }
    return v6[4];
  }

  unint64_t v6 = sub_1000771E8((uint64_t)v4, &dword_1000AF380, &dword_1000AF380);
  if (!v7) {
    return v6[4];
  }
  uint64_t v8 = a1[13];
  unint64_t v9 = (_OWORD *)a1[14];
  uint64_t v10 = ((uint64_t)v9 - v8) >> 4;
  void v6[4] = v10;
  unint64_t v11 = a1[15];
  if ((unint64_t)v9 >= v11)
  {
    unint64_t v13 = v10 + 1;
    uint64_t v14 = v11 - v8;
    if (v14 >> 3 > v13) {
      unint64_t v13 = v14 >> 3;
    }
    else {
      unint64_t v15 = v13;
    }
    if (v15) {
      float v16 = (char *)sub_1000198A8((uint64_t)(a1 + 15), v15);
    }
    else {
      float v16 = 0LL;
    }
    BOOL v17 = &v16[16 * v10];
    unint64_t v18 = &v16[16 * v15];
    *(_OWORD *)BOOL v17 = *a2;
    uint64_t v12 = v17 + 16;
    size_t v20 = (char *)a1[13];
    unint64_t v19 = (char *)a1[14];
    if (v19 != v20)
    {
      do
      {
        *((_OWORD *)v17 - 1) = *((_OWORD *)v19 - 1);
        v17 -= 16;
        v19 -= 16;
      }

      while (v19 != v20);
      unint64_t v19 = (char *)a1[13];
    }

    a1[13] = v17;
    a1[14] = v12;
    a1[15] = v18;
    if (v19) {
      operator delete(v19);
    }
  }

  else
  {
    *unint64_t v9 = *a2;
    uint64_t v12 = v9 + 1;
  }

  a1[14] = v12;
  return v10;
}

char *sub_1000771E8(uint64_t a1, int *a2, _DWORD *a3)
{
  uint64_t v7 = *a2;
  if ((int)v7 < -1)
  {
    unint64_t v10 = 0LL;
  }

  else
  {
    uint64_t v8 = *(void *)(a1 + 48);
    if ((_DWORD)v7 == -1) {
      uint64_t v9 = *(void *)(v8 + 128);
    }
    else {
      uint64_t v9 = *(void *)(v8 + 104) + 16 * v7;
    }
    unint64_t v10 = *(void *)v9 + 7853LL * *(int *)(v9 + 8) + 7867LL * *(int *)(v9 + 12);
  }

  unint64_t v11 = *(void *)(a1 + 8);
  if (v11)
  {
    uint8x8_t v12 = (uint8x8_t)vcnt_s8((int8x8_t)v11);
    v12.i16[0] = vaddlv_u8(v12);
    unint64_t v13 = v12.u32[0];
    if (v12.u32[0] > 1uLL)
    {
      unint64_t v3 = v10;
      if (v10 >= v11) {
        unint64_t v3 = v10 % v11;
      }
    }

    else
    {
      unint64_t v3 = (v11 - 1) & v10;
    }

    uint64_t v14 = *(char ***)(*(void *)a1 + 8 * v3);
    if (v14)
    {
      for (uint64_t i = *v14; i; uint64_t i = *(char **)i)
      {
        unint64_t v16 = *((void *)i + 1);
        if (v16 == v10)
        {
        }

        else
        {
          if (v13 > 1)
          {
            if (v16 >= v11) {
              v16 %= v11;
            }
          }

          else
          {
            v16 &= v11 - 1;
          }

          if (v16 != v3) {
            break;
          }
        }
      }
    }
  }

  uint64_t i = sub_100070674((uint64_t **)(a1 + 32), 1uLL);
  *(void *)uint64_t i = 0LL;
  *((void *)i + 1) = v10;
  *((_DWORD *)i + 4) = *a3;
  float v17 = (float)(unint64_t)(*(void *)(a1 + 40) + 1LL);
  float v18 = *(float *)(a1 + 56);
  if (!v11 || (float)(v18 * (float)v11) < v17)
  {
    BOOL v19 = 1LL;
    if (v11 >= 3) {
      BOOL v19 = (v11 & (v11 - 1)) != 0;
    }
    unint64_t v20 = v19 | (2 * v11);
    unint64_t v21 = vcvtps_u32_f32(v17 / v18);
    if (v20 <= v21) {
      size_t v22 = v21;
    }
    else {
      size_t v22 = v20;
    }
    sub_10006D600(a1, v22);
    unint64_t v11 = *(void *)(a1 + 8);
    if ((v11 & (v11 - 1)) != 0)
    {
      if (v10 >= v11) {
        unint64_t v3 = v10 % v11;
      }
      else {
        unint64_t v3 = v10;
      }
    }

    else
    {
      unint64_t v3 = (v11 - 1) & v10;
    }
  }

  BOOL v23 = *(char ***)(*(void *)a1 + 8 * v3);
  if (v23)
  {
    *(void *)uint64_t i = *v23;
LABEL_44:
    *BOOL v23 = i;
    goto LABEL_45;
  }

  *(void *)uint64_t i = *(void *)(a1 + 24);
  *(void *)(a1 + ++*(_DWORD *)(result + 24) = i;
  *(void *)(*(void *)a1 + 8 * v3) = a1 + 24;
  if (*(void *)i)
  {
    unint64_t v24 = *(void *)(*(void *)i + 8LL);
    if ((v11 & (v11 - 1)) != 0)
    {
      if (v24 >= v11) {
        v24 %= v11;
      }
    }

    else
    {
      v24 &= v11 - 1;
    }

    BOOL v23 = (char **)(*(void *)a1 + 8 * v24);
    goto LABEL_44;
  }

void sub_10007747C(_Unwind_Exception *a1)
{
}

BOOL sub_100077498(uint64_t *a1, int a2, int a3)
{
  if (a2 == a3) {
    return 1LL;
  }
  BOOL result = 0LL;
  if (a2 >= -1 && a3 >= -1)
  {
    uint64_t v5 = *a1;
    if (a2 == -1) {
      uint64_t v6 = *(void *)(v5 + 128);
    }
    else {
      uint64_t v6 = *(void *)(v5 + 104) + 16LL * a2;
    }
    if (a3 == -1) {
      uint64_t v7 = *(void *)(v5 + 128);
    }
    else {
      uint64_t v7 = *(void *)(v5 + 104) + 16LL * a3;
    }
    return *(void *)v6 == *(void *)v7
        && *(_DWORD *)(v6 + 8) == *(_DWORD *)(v7 + 8)
        && *(_DWORD *)(v6 + 12) == *(_DWORD *)(v7 + 12);
  }

  return result;
}

uint64_t *sub_100077534(void *a1, int *a2)
{
  uint64_t v3 = *a2;
  if ((int)v3 < -1)
  {
    unint64_t v6 = 0LL;
  }

  else
  {
    uint64_t v4 = a1[6];
    if ((_DWORD)v3 == -1) {
      uint64_t v5 = *(void *)(v4 + 128);
    }
    else {
      uint64_t v5 = *(void *)(v4 + 104) + 16 * v3;
    }
    unint64_t v6 = *(void *)v5 + 7853LL * *(int *)(v5 + 8) + 7867LL * *(int *)(v5 + 12);
  }

  int8x8_t v7 = (int8x8_t)a1[1];
  if (!*(void *)&v7) {
    return 0LL;
  }
  uint8x8_t v8 = (uint8x8_t)vcnt_s8(v7);
  v8.i16[0] = vaddlv_u8(v8);
  unint64_t v9 = v8.u32[0];
  if (v8.u32[0] > 1uLL)
  {
    unint64_t v10 = v6;
    if (v6 >= *(void *)&v7) {
      unint64_t v10 = v6 % *(void *)&v7;
    }
  }

  else
  {
    unint64_t v10 = (*(void *)&v7 - 1LL) & v6;
  }

  unint64_t v11 = *(uint64_t ***)(*a1 + 8 * v10);
  if (!v11) {
    return 0LL;
  }
  uint8x8_t v12 = *v11;
  if (*v11)
  {
    unint64_t v13 = a1 + 8;
    do
    {
      unint64_t v14 = v12[1];
      if (v14 == v6)
      {
        if (sub_100077498(v13, *((_DWORD *)v12 + 4), *a2)) {
          return v12;
        }
      }

      else
      {
        if (v9 > 1)
        {
          if (v14 >= *(void *)&v7) {
            v14 %= *(void *)&v7;
          }
        }

        else
        {
          v14 &= *(void *)&v7 - 1LL;
        }

        if (v14 != v10) {
          return 0LL;
        }
      }

      uint8x8_t v12 = (uint64_t *)*v12;
    }

    while (v12);
  }

  return v12;
}

_DWORD *sub_10007766C@<X0>(uint64_t a1@<X0>, int a2@<W1>, int *a3@<X8>)
{
  BOOL result = (_DWORD *)sub_100072A24(a1, a2);
  if ((_DWORD)result)
  {
    uint64_t v7 = *(void *)(a1 + 120);
    if (*(_DWORD *)(v7 + 92) == a2) {
      uint8x8_t v8 = (int **)(v7 + 96);
    }
    else {
      uint8x8_t v8 = (int **)(*(void *)(v7 + 8) + 8LL * a2 + 8);
    }
    *a3 = **v8;
  }

  else
  {
    uint64_t v9 = *(void *)(*(void *)(a1 + 168) + 104LL);
    unint64_t v10 = sub_10002ADB0();
    int v11 = *v10;
    *a3 = *v10;
    if (!*(void *)(v9 + 16LL * a2))
    {
      uint64_t v12 = *(void *)(*(void *)(a1 + 240) + 8LL * *(int *)(v9 + 16LL * a2 + 8));
      (*(void (**)(uint64_t *__return_ptr, uint64_t, void))(*(void *)v12 + 24LL))( &v13,  v12,  *(unsigned int *)(v9 + 16LL * a2 + 12));
      int v11 = v13;
      *a3 = v13;
    }

    if (*(_BYTE *)(a1 + 160) || (BOOL result = (_DWORD *)sub_100072AF0(a1, a2), (_DWORD)result))
    {
      BOOL result = sub_100071228(*(void *)(a1 + 120), a2);
      _DWORD *result = v11;
      result[14] |= 9u;
    }
  }

  return result;
}

uint64_t sub_100077774(uint64_t a1, int a2)
{
  if (!sub_100072AF0(a1, a2))
  {
    if (!*(_BYTE *)(a1 + 160))
    {
      __int128 v9 = *(_OWORD *)(*(void *)(*(void *)(a1 + 168) + 104LL) + 16LL * a2);
      if (HIDWORD(v9) == -1) {
        return 0LL;
      }
      uint64_t v7 = *(void *)(*(void *)(a1 + 240) + 8LL * SDWORD2(v9));
      uint64_t v8 = (*(uint64_t (**)(uint64_t))(*(void *)v7 + 32LL))(v7);
      return v8 + sub_100077A18(a1, (uint64_t *)&v9, 0LL, 15);
    }

    sub_100077848((uint64_t *)a1, a2);
  }

  uint64_t v4 = *(void *)(a1 + 120);
  if (*(_DWORD *)(v4 + 92) == a2) {
    uint64_t v5 = v4 + 96;
  }
  else {
    uint64_t v5 = *(void *)(v4 + 8) + 8LL * a2 + 8;
  }
  return (uint64_t)(*(void *)(*(void *)v5 + 32LL) - *(void *)(*(void *)v5 + 24LL)) >> 4;
}

void sub_100077848(uint64_t *a1, int a2)
{
  __int128 v12 = *(_OWORD *)(*(void *)(a1[21] + 104) + 16LL * a2);
  if (HIDWORD(v12) == -1)
  {
    sub_100070E04((uint64_t)a1, a2);
    return;
  }

  uint64_t v4 = *(void *)(a1[30] + 8LL * SDWORD2(v12));
  __int128 v9 = 0u;
  __int128 v10 = 0u;
  unint64_t v11 = 0LL;
  (*(void (**)(uint64_t))(*(void *)v4 + 120LL))(v4);
  if (sub_100077A18((uint64_t)a1, (uint64_t *)&v12, v8, 15))
  {
    uint64_t v5 = sub_100071228(a1[15], a2);
    sub_10007192C((void *)v5 + 3, (uint64_t)v8);
  }

  while (1)
  {
    if (!(void)v9)
    {
      goto LABEL_7;
    }

    if ((void)v9)
    {
      unint64_t v6 = (unsigned int *)(*(uint64_t (**)(void))(*(void *)v9 + 24LL))(v9);
      goto LABEL_8;
    }

void sub_1000779DC( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, _DWORD *a14)
{
  if (a11)
  {
    (*(void (**)(uint64_t))(*(void *)a11 + 8LL))(a11);
  }

  else if (a14)
  {
    --*a14;
  }

  _Unwind_Resume(exception_object);
}

uint64_t sub_100077A18(uint64_t a1, uint64_t *a2, _DWORD *a3, char a4)
{
  uint64_t v4 = *((unsigned int *)a2 + 3);
  if ((_DWORD)v4 == -1) {
    return 0LL;
  }
  uint64_t v9 = *(void *)(*(void *)(a1 + 240) + 8LL * *((int *)a2 + 2));
  (*(void (**)(uint64_t *__return_ptr, uint64_t, void))(*(void *)v9 + 24LL))( &v26,  v9,  *((unsigned int *)a2 + 3));
  __int128 v10 = sub_10002ADB0();
  LODWORD(v22) = v26;
  HIDWORD(v26) = *v10;
  v11.n128_u32[0] = v26;
  uint64_t v12 = *a2;
  if (!*a2) {
    return 0LL;
  }
  if (a3)
  {
    int v13 = *(_DWORD *)(a1 + 136);
    if ((v13 & 0xFFFFFFFD) == 1) {
      int v14 = 0;
    }
    else {
      int v14 = *(_DWORD *)(a1 + 152);
    }
    *a3 = v14;
    else {
      int v16 = 0;
    }
    a3[1] = v16;
    if ((a4 & 8) != 0)
    {
      uint64_t v17 = *(void *)(*(void *)(a1 + 168) + 240LL) + 24 * v12;
      unint64_t v24 = 0LL;
      uint64_t v25 = 0LL;
      std::string __p = 0LL;
      sub_100076088( &__p,  *(const void **)v17,  *(void *)(v17 + 8),  (uint64_t)(*(void *)(v17 + 8) - *(void *)v17) >> 3);
      v24 -= 8;
      uint64_t v18 = sub_1000767B0((void *)(*(void *)(a1 + 168) + 136LL), (uint64_t)&__p, 1);
      if (__p)
      {
        unint64_t v24 = (char *)__p;
        operator delete(__p);
      }

      uint64_t v19 = *(void *)(v17 + 8);
      unint64_t v20 = *(void **)(a1 + 168);
      *(void *)&__int128 v22 = v18;
      *((void *)&v22 + 1) = *(void *)(v19 - 8);
      a3[3] = sub_1000770AC(v20, &v22, 1);
    }

    if ((a4 & 4) != 0)
    {
      uint64_t v21 = *(void *)(*(void *)(a1 + 240) + 8LL * *((int *)a2 + 2));
      (*(void (**)(__int128 *__return_ptr, uint64_t, uint64_t, __n128))(*(void *)v21 + 24LL))( &v22,  v21,  v4,  v11);
      a3[2] = v22;
    }
  }

  return 1LL;
}

void sub_100077BB8( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_100077BD4(uint64_t a1, uint64_t a2, unsigned int *a3, uint64_t a4, int a5)
{
  BOOL v7 = (a5 & 0xFFFFFFFA) != 0 || (*(_DWORD *)(a1 + 132) & 0xFFFFFFFD) == 1;
  if (!v7)
  {
    *(void *)a4 = *(void *)a3;
    *(_DWORD *)(a4 + std::istream::~istream(v2, v3 + 8) = a3[2];
    int v22 = a3[3];
LABEL_24:
    *(_DWORD *)(a4 + 12) = v22;
    return 1LL;
  }

  char v8 = a5;
  uint64_t v12 = a3 + 1;
  signed int v11 = a3[1];
  if (!v11 || v11 < *(_DWORD *)(*(void *)(a1 + 176) + 28LL)) {
    goto LABEL_19;
  }
  uint64_t v13 = a1 + 184;
  uint64_t v14 = *(void *)(a1 + 184);
  if (v14)
  {
    do
    {
      uint64_t v15 = v14;
      uint64_t v14 = *(void *)(v14 + 8);
    }

    while (v14);
  }

  else
  {
    do
    {
      uint64_t v15 = *(void *)(v13 + 16);
      BOOL v7 = *(void *)v15 == v13;
      uint64_t v13 = v15;
    }

    while (v7);
  }

  if (v11 > *(_DWORD *)(v15 + 28) || (int v16 = sub_10005C1A8((void *)(a1 + 200), (int *)a3 + 1)) == 0LL)
  {
LABEL_19:
    if ((v8 & 8) != 0)
    {
      BOOL v23 = *(void **)(a1 + 168);
      unsigned int v24 = *(_DWORD *)(a2 + 8);
      unsigned int v25 = a3[3];
      *(void *)&__int128 v36 = *(void *)a2;
      *((void *)&v36 + 1) = __PAIR64__(v25, v24);
      int v22 = sub_1000770AC(v23, &v36, 1);
    }

    else
    {
      int v22 = -1;
    }

    uint64_t v26 = *(void *)a3;
    unsigned int v27 = a3[2];
    goto LABEL_23;
  }

  unsigned int v17 = *((_DWORD *)v16 + 5);
  uint64_t v18 = *(void *)(*(void *)(a1 + 168) + 240LL) + 24LL * *(void *)a2;
  std::string __p = 0LL;
  uint64_t v34 = 0LL;
  uint64_t v35 = 0LL;
  sub_100076088(&__p, *(const void **)v18, *(void *)(v18 + 8), (uint64_t)(*(void *)(v18 + 8) - *(void *)v18) >> 3);
  sub_100077E20(&__p, *(_DWORD *)(a2 + 8), a3[3]);
  uint64_t v19 = sub_1000767B0((void *)(*(void *)(a1 + 168) + 136LL), (uint64_t)&__p, 1);
  if (__p)
  {
    uint64_t v34 = __p;
    operator delete(__p);
  }

  uint64_t v20 = *(void *)(*(void *)(a1 + 240) + 8LL * (int)v17);
  unsigned int v21 = (*(uint64_t (**)(uint64_t))(*(void *)v20 + 16LL))(v20);
  if (v21 != -1)
  {
    if ((v8 & 8) != 0)
    {
      int v29 = *(void **)(a1 + 168);
      *(void *)&__int128 v36 = v19;
      *((void *)&v36 + 1) = __PAIR64__(v21, v17);
      int v22 = sub_1000770AC(v29, &v36, 1);
    }

    else
    {
      int v22 = -1;
    }

    uint64_t v30 = 0LL;
    int v31 = *(_DWORD *)(a1 + 132);
    if ((v31 & 0xFFFFFFFD) == 1) {
      uint64_t v32 = 0LL;
    }
    else {
      uint64_t v32 = *a3;
    }
    if ((v31 - 1) >= 2)
    {
      uint64_t v30 = *(void *)(a1 + 144);
      if (v30 == -1) {
        uint64_t v30 = *v12;
      }
    }

    unsigned int v27 = a3[2];
    uint64_t v26 = v32 | (v30 << 32);
LABEL_23:
    *(void *)a4 = v26;
    *(_DWORD *)(a4 + std::istream::~istream(v2, v3 + 8) = v27;
    goto LABEL_24;
  }

  return 0LL;
}

void sub_100077E04( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_100077E20(void **a1, unsigned int a2, uint64_t a3)
{
  unint64_t v8 = (unint64_t)a1[2];
  uint64_t v6 = (uint64_t)(a1 + 2);
  unint64_t v7 = v8;
  uint64_t v9 = *(unint64_t **)(v6 - 8);
  if ((unint64_t)v9 >= v8)
  {
    uint64_t v11 = ((char *)v9 - (_BYTE *)*a1) >> 3;
    uint64_t v12 = v7 - (void)*a1;
    uint64_t v13 = v12 >> 2;
    else {
      unint64_t v14 = v13;
    }
    if (v14) {
      uint64_t v15 = (char *)sub_100018788(v6, v14);
    }
    else {
      uint64_t v15 = 0LL;
    }
    int v16 = &v15[8 * v11];
    unsigned int v17 = &v15[8 * v14];
    *(void *)int v16 = a2 | (unint64_t)(a3 << 32);
    __int128 v10 = v16 + 8;
    uint64_t v19 = (char *)*a1;
    uint64_t v18 = (char *)a1[1];
    if (v18 != *a1)
    {
      do
      {
        uint64_t v20 = *((void *)v18 - 1);
        v18 -= 8;
        *((void *)v16 - 1) = v20;
        v16 -= 8;
      }

      while (v18 != v19);
      uint64_t v18 = (char *)*a1;
    }

    *a1 = v16;
    a1[1] = v10;
    a1[2] = v17;
    if (v18) {
      operator delete(v18);
    }
  }

  else
  {
    *uint64_t v9 = a2 | (unint64_t)(a3 << 32);
    __int128 v10 = v9 + 1;
  }

  a1[1] = v10;
}

uint64_t sub_100077F08(uint64_t *a1, int a2)
{
  if (!sub_100072AF0((uint64_t)a1, a2))
  {
    if (!*((_BYTE *)a1 + 160) && (*(uint64_t (**)(uint64_t *, uint64_t))(*a1 + 24))(a1, 0x10000000LL))
    {
      __int128 v9 = *(_OWORD *)(*(void *)(a1[21] + 104) + 16LL * a2);
      if (HIDWORD(v9) == -1) {
        return 0LL;
      }
      uint64_t v8 = *(void *)(a1[30] + 8LL * SDWORD2(v9));
      if ((*((_DWORD *)a1 + 33) & 0xFFFFFFFD) == 1)
      {
        (*(void (**)(uint64_t))(*(void *)v8 + 120LL))(v8);
        uint64_t v6 = 0LL;
      }

      else
      {
        uint64_t v6 = (*(uint64_t (**)(uint64_t))(*(void *)v8 + 40LL))(v8);
      }

      if ((a1[17] & 0xFFFFFFFD) == 1) {
        v6 += sub_100077A18((uint64_t)a1, (uint64_t *)&v9, 0LL, 15);
      }
      return v6;
    }

    sub_100077848(a1, a2);
  }

  uint64_t v4 = a1[15];
  if (*(_DWORD *)(v4 + 92) == a2) {
    uint64_t v5 = v4 + 96;
  }
  else {
    uint64_t v5 = *(void *)(v4 + 8) + 8LL * a2 + 8;
  }
  return *(void *)(*(void *)v5 + 8LL);
}

void sub_100078130( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  if (a9) {
    (*(void (**)(uint64_t))(*(void *)a9 + 8LL))(a9);
  }
  else {
    sub_100097C1C((uint64_t)&a9);
  }
  _Unwind_Resume(a1);
}

BOOL sub_10007815C(void *a1, int a2)
{
  int v7 = a2;
  if (*(_DWORD *)(a1[22] + 28LL) > a2) {
    return 0LL;
  }
  uint64_t v2 = a1 + 23;
  uint64_t v3 = a1[23];
  if (v3)
  {
    do
    {
      uint64_t v4 = v3;
      uint64_t v3 = *(void *)(v3 + 8);
    }

    while (v3);
  }

  else
  {
    do
    {
      uint64_t v4 = v2[2];
      BOOL v5 = *(void *)v4 == (void)v2;
      uint64_t v2 = (void *)v4;
    }

    while (v5);
  }

  return *(_DWORD *)(v4 + 28) >= a2 && sub_10005C1A8(a1 + 25, &v7) != 0LL;
}

uint64_t sub_1000781E0(uint64_t *a1, int a2)
{
  if (!sub_100072AF0((uint64_t)a1, a2))
  {
    if (!*((_BYTE *)a1 + 160) && (*(uint64_t (**)(uint64_t *, uint64_t))(*a1 + 24))(a1, 0x40000000LL))
    {
      __int128 v9 = *(_OWORD *)(*(void *)(a1[21] + 104) + 16LL * a2);
      if (HIDWORD(v9) == -1) {
        return 0LL;
      }
      uint64_t v8 = *(void *)(a1[30] + 8LL * SDWORD2(v9));
      if ((*((_DWORD *)a1 + 33) - 1) >= 2)
      {
        uint64_t v6 = (*(uint64_t (**)(uint64_t))(*(void *)v8 + 48LL))(v8);
      }

      else
      {
        (*(void (**)(uint64_t))(*(void *)v8 + 120LL))(v8);
        uint64_t v6 = 0LL;
      }

      return v6;
    }

    sub_100077848(a1, a2);
  }

  uint64_t v4 = a1[15];
  if (*(_DWORD *)(v4 + 92) == a2) {
    uint64_t v5 = v4 + 96;
  }
  else {
    uint64_t v5 = *(void *)(v4 + 8) + 8LL * a2 + 8;
  }
  return *(void *)(*(void *)v5 + 16LL);
}

void sub_100078408( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  if (a9) {
    (*(void (**)(uint64_t))(*(void *)a9 + 8LL))(a9);
  }
  else {
    sub_100097C1C((uint64_t)&a9);
  }
  _Unwind_Resume(a1);
}

void *sub_100078434(void *a1, uint64_t a2, int a3)
{
  *a1 = off_1000D2B10;
  a1[1] = 0LL;
  uint64_t v4 = (uint64_t)(a1 + 1);
  a1[2] = 0LL;
  if (a3)
  {
    sub_100078554(*(void *)(a2 + 8), &v9);
    sub_1000784F0(v4, &v9);
    uint64_t v5 = (std::__shared_weak_count *)*((void *)&v9 + 1);
    if (*((void *)&v9 + 1))
    {
      uint64_t v6 = (unint64_t *)(*((void *)&v9 + 1) + 8LL);
      do
        unint64_t v7 = __ldaxr(v6);
      while (__stlxr(v7 - 1, v6));
      if (!v7)
      {
        ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
        std::__shared_weak_count::__release_weak(v5);
      }
    }
  }

  else
  {
    sub_10002CF84(a1 + 1, (uint64_t *)(a2 + 8));
  }

  return a1;
}

void sub_1000784DC(_Unwind_Exception *a1)
{
}

uint64_t sub_1000784F0(uint64_t a1, __int128 *a2)
{
  __int128 v3 = *a2;
  *(void *)a2 = 0LL;
  *((void *)a2 + 1) = 0LL;
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 8);
  *(_OWORD *)a1 = v3;
  if (v4)
  {
    p_shared_owners = (unint64_t *)&v4->__shared_owners_;
    do
      unint64_t v6 = __ldaxr(p_shared_owners);
    while (__stlxr(v6 - 1, p_shared_owners));
    if (!v6)
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }

  return a1;
}

void *sub_100078554@<X0>(uint64_t a1@<X1>, void *a2@<X8>)
{
  uint64_t v4 = operator new(0x128uLL);
  BOOL result = sub_1000785AC(v4, a1);
  *a2 = v4 + 3;
  a2[1] = v4;
  return result;
}

void sub_100078598(_Unwind_Exception *a1)
{
}

void *sub_1000785AC(void *a1, uint64_t a2)
{
  a1[1] = 0LL;
  a1[2] = 0LL;
  *a1 = off_1000D26F8;
  sub_1000785F4((uint64_t)(a1 + 3), a2);
  return a1;
}

void sub_1000785E0(_Unwind_Exception *a1)
{
}

uint64_t sub_1000785F4(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = sub_10006EB24(a1, a2, 0);
  *(void *)uint64_t v4 = off_1000D2748;
  *(void *)(v4 + 132) = *(void *)(a2 + 132);
  *(_OWORD *)(v4 + 144) = *(_OWORD *)(a2 + 144);
  *(_BYTE *)(v4 + 16RDString::RDString((RDString *)&v66, theString, 0) = *(_BYTE *)(a2 + 160);
  uint64_t v5 = operator new(0x110uLL);
  sub_100078ACC((uint64_t)v5, *(void *)(a2 + 168));
  *(void *)(a1 + 16std::istream::~istream(v2, v3 + 8) = v5;
  sub_100078DEC((uint64_t *)(a1 + 176), a2 + 176);
  sub_1000790F0(a1 + 200, a2 + 200);
  *(void *)(a1 + 24RDString::RDString((RDString *)&v66, theString, 0) = 0LL;
  *(void *)(a1 + 24std::istream::~istream(v2, v3 + 8) = 0LL;
  unint64_t v6 = (uint64_t **)(a1 + 240);
  *(void *)(a1 + 2++*(void *)(result + 56) = 0LL;
  *(_DWORD *)(a1 + 264) = *(_DWORD *)(a2 + 264);
  sub_10000A2DC(&__str, "replace");
  std::string::operator=((std::string *)(a1 + 16), &__str);
  *(void *)(a1 + std::istream::~istream(v2, v3 + 8) = *(void *)(a1 + 8) & 0xFFFF00000000FFFFLL | (*(uint64_t (**)(uint64_t))(*(void *)a2 + 16LL))(a2) & 0xFFFFFFFF0004LL;
  uint64_t v7 = *(void *)(a2 + 40);
  if (v7) {
    uint64_t v7 = (*(uint64_t (**)(uint64_t))(*(void *)v7 + 16LL))(v7);
  }
  uint64_t v8 = *(void *)(a1 + 40);
  *(void *)(a1 + 4RDString::RDString((RDString *)&v66, theString, 0) = v7;
  if (v8) {
    (*(void (**)(uint64_t))(*(void *)v8 + 8LL))(v8);
  }
  uint64_t v9 = *(void *)(a2 + 48);
  if (v9) {
    uint64_t v9 = (*(uint64_t (**)(uint64_t))(*(void *)v9 + 16LL))(v9);
  }
  uint64_t v10 = *(void *)(a1 + 48);
  *(void *)(a1 + 4std::istream::~istream(v2, v3 + 8) = v9;
  if (v10) {
    (*(void (**)(uint64_t))(*(void *)v10 + 8LL))(v10);
  }
  sub_100078A14((char **)(a1 + 240), (uint64_t)(*(void *)(a2 + 248) - *(void *)(a2 + 240)) >> 3);
  uint64_t v12 = *(uint64_t **)(a1 + 248);
  unint64_t v11 = *(void *)(a1 + 256);
  if ((unint64_t)v12 >= v11)
  {
    unint64_t v14 = *v6;
    uint64_t v15 = v12 - *v6;
    unint64_t v16 = v15 + 1;
    uint64_t v17 = v11 - (void)v14;
    if (v17 >> 2 > v16) {
      unint64_t v16 = v17 >> 2;
    }
    else {
      unint64_t v18 = v16;
    }
    uint64_t v46 = a1 + 256;
    if (v18)
    {
      uint64_t v19 = (char *)sub_100018788(a1 + 256, v18);
      unint64_t v14 = *(uint64_t **)(a1 + 240);
      uint64_t v12 = *(uint64_t **)(a1 + 248);
    }

    else
    {
      uint64_t v19 = 0LL;
    }

    uint64_t v20 = &v19[8 * v15];
    unsigned int v21 = &v19[8 * v18];
    uint64_t v45 = v21;
    *(void *)uint64_t v20 = 0LL;
    __str.__r_.__value_.__l.__cap_ = (std::string::size_type)(v20 + 8);
    if (v12 == v14)
    {
      std::string::size_type cap = (std::string::size_type)(v20 + 8);
    }

    else
    {
      do
      {
        uint64_t v22 = *--v12;
        *uint64_t v12 = 0LL;
        *((void *)v20 - 1) = v22;
        v20 -= 8;
      }

      while (v12 != v14);
      std::string::size_type cap = __str.__r_.__value_.__l.__cap_;
      unsigned int v21 = v45;
    }

    __int128 v23 = *(_OWORD *)(a1 + 240);
    *(void *)(a1 + 24RDString::RDString((RDString *)&v66, theString, 0) = v20;
    *(void *)(a1 + 24std::istream::~istream(v2, v3 + 8) = cap;
    *(_OWORD *)&__str.__r_.__value_.__r.__words[1] = v23;
    unsigned int v24 = *(char **)(a1 + 256);
    *(void *)(a1 + 2++*(void *)(result + 56) = v21;
    uint64_t v45 = v24;
    __str.__r_.__value_.__r.__words[0] = v23;
    sub_100069800((uint64_t)&__str);
  }

  else
  {
    *uint64_t v12 = 0LL;
    std::string::size_type cap = (std::string::size_type)(v12 + 1);
  }

  *(void *)(a1 + 24std::istream::~istream(v2, v3 + 8) = cap;
  uint64_t v25 = *(void *)(a2 + 240);
  if ((unint64_t)(*(void *)(a2 + 248) - v25) >= 9)
  {
    unint64_t v26 = 1LL;
    do
    {
      uint64_t v27 = (*(uint64_t (**)(void, uint64_t))(**(void **)(v25 + 8 * v26) + 72LL))( *(void *)(v25 + 8 * v26),  1LL);
      uint64_t v28 = v27;
      uint64_t v30 = *(uint64_t **)(a1 + 248);
      unint64_t v29 = *(void *)(a1 + 256);
      if ((unint64_t)v30 >= v29)
      {
        uint64_t v32 = *v6;
        uint64_t v33 = v30 - *v6;
        unint64_t v34 = v33 + 1;
        uint64_t v35 = v29 - (void)v32;
        if (v35 >> 2 > v34) {
          unint64_t v34 = v35 >> 2;
        }
        else {
          unint64_t v36 = v34;
        }
        uint64_t v46 = a1 + 256;
        if (v36)
        {
          unsigned int v37 = (char *)sub_100018788(a1 + 256, v36);
          uint64_t v32 = *(uint64_t **)(a1 + 240);
          uint64_t v30 = *(uint64_t **)(a1 + 248);
        }

        else
        {
          unsigned int v37 = 0LL;
        }

        uint64_t v38 = (uint64_t *)&v37[8 * v33];
        uint64_t v39 = &v37[8 * v36];
        uint64_t v45 = v39;
        uint64_t *v38 = v28;
        __str.__r_.__value_.__l.__cap_ = (std::string::size_type)(v38 + 1);
        if (v30 == v32)
        {
          std::string::size_type v31 = (std::string::size_type)(v38 + 1);
        }

        else
        {
          do
          {
            uint64_t v40 = *--v30;
            *uint64_t v30 = 0LL;
            *--uint64_t v38 = v40;
          }

          while (v30 != v32);
          std::string::size_type v31 = __str.__r_.__value_.__l.__cap_;
          uint64_t v39 = v45;
        }

        __int128 v41 = *(_OWORD *)(a1 + 240);
        *(void *)(a1 + 24RDString::RDString((RDString *)&v66, theString, 0) = v38;
        *(void *)(a1 + 24std::istream::~istream(v2, v3 + 8) = v31;
        *(_OWORD *)&__str.__r_.__value_.__r.__words[1] = v41;
        uint64_t v42 = *(char **)(a1 + 256);
        *(void *)(a1 + 2++*(void *)(result + 56) = v39;
        uint64_t v45 = v42;
        __str.__r_.__value_.__r.__words[0] = v41;
        sub_100069800((uint64_t)&__str);
      }

      else
      {
        *uint64_t v30 = v27;
        std::string::size_type v31 = (std::string::size_type)(v30 + 1);
      }

      *(void *)(a1 + 24std::istream::~istream(v2, v3 + 8) = v31;
      ++v26;
      uint64_t v25 = *(void *)(a2 + 240);
    }

    while (v26 < (*(void *)(a2 + 248) - v25) >> 3);
  }

  return a1;
}

void sub_100078984( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19)
{
}

uint64_t sub_100078A14(char **a1, unint64_t a2)
{
  uint64_t v4 = a1[2];
  uint64_t result = (uint64_t)(a1 + 2);
  if (a2 > (v4 - *a1) >> 3)
  {
    if (a2 >> 61) {
      sub_100018774();
    }
    uint64_t v5 = a1[1] - *a1;
    uint64_t v17 = result;
    unint64_t v6 = (char *)sub_100018788(result, a2);
    uint64_t v9 = *a1;
    uint64_t v8 = a1[1];
    if (v8 == *a1)
    {
      int64x2_t v12 = vdupq_n_s64((unint64_t)v8);
      uint64_t v10 = &v6[v5 & 0xFFFFFFFFFFFFFFF8LL];
    }

    else
    {
      uint64_t v10 = &v6[v5 & 0xFFFFFFFFFFFFFFF8LL];
      do
      {
        uint64_t v11 = *((void *)v8 - 1);
        v8 -= 8;
        *(void *)uint64_t v8 = 0LL;
        *((void *)v10 - 1) = v11;
        v10 -= 8;
      }

      while (v8 != v9);
      int64x2_t v12 = *(int64x2_t *)a1;
    }

    *a1 = v10;
    a1[1] = &v6[v5 & 0xFFFFFFFFFFFFFFF8LL];
    int64x2_t v15 = v12;
    uint64_t v13 = a1[2];
    a1[2] = &v6[8 * v7];
    unint64_t v16 = v13;
    uint64_t v14 = v12.i64[0];
    return sub_100069800((uint64_t)&v14);
  }

  return result;
}

uint64_t sub_100078ACC(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = sub_100074410(a1, 0LL, 0LL, 0LL);
  sub_100078B20((void **)(v4 + 136), (void *)(a2 + 136));
  return a1;
}

void sub_100078B0C(_Unwind_Exception *a1)
{
}

void **sub_100078B20(void **a1, void *a2)
{
  *a1 = operator new(1uLL);
  a1[1] = operator new(1uLL);
  a1[2] = a1;
  a1[3] = a1;
  sub_100074894((uint64_t)(a1 + 4), a2[9], a1 + 2, a1 + 3);
  a1[13] = 0LL;
  a1[14] = 0LL;
  a1[15] = 0LL;
  sub_100078C38(a1 + 13, a2[13], a2[14], 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(a2[14] - a2[13]) >> 3));
  for (uint64_t i = (void *)a2[7]; i; uint64_t i = (void *)*i)
    sub_100076868((uint64_t)(a1 + 4), i + 2, i + 2);
  return a1;
}

void sub_100078BD8(_Unwind_Exception *a1)
{
  uint64_t v4 = *(void **)(v1 + 8);
  *(void *)(v1 + std::istream::~istream(v2, v3 + 8) = 0LL;
  if (v4) {
    operator delete(v4);
  }
  uint64_t v5 = *(void **)v1;
  *(void *)uint64_t v1 = 0LL;
  if (v5) {
    operator delete(v5);
  }
  _Unwind_Resume(a1);
}

void *sub_100078C38(void *result, uint64_t a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    unint64_t v6 = result;
    sub_100019ABC(result, a4);
    uint64_t result = sub_100078CBC((uint64_t)(v6 + 2), a2, a3, (void *)v6[1]);
    v6[1] = result;
  }

  return result;
}

void sub_100078C9C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
  *(void *)(v9 + std::istream::~istream(v2, v3 + 8) = v10;
  sub_100076244(&a9);
  _Unwind_Resume(a1);
}

void *sub_100078CBC(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  uint64_t v4 = a4;
  uint64_t v10 = a4;
  uint64_t v11 = a4;
  v8[0] = a1;
  v8[1] = &v10;
  v8[2] = &v11;
  char v9 = 0;
  if (a2 != a3)
  {
    uint64_t v6 = a2;
    do
    {
      *uint64_t v4 = 0LL;
      v4[1] = 0LL;
      _DWORD v4[2] = 0LL;
      sub_100076088(v4, *(const void **)v6, *(void *)(v6 + 8), (uint64_t)(*(void *)(v6 + 8) - *(void *)v6) >> 3);
      uint64_t v4 = v11 + 3;
      v11 += 3;
      v6 += 24LL;
    }

    while (v6 != a3);
  }

  char v9 = 1;
  sub_100078D6C((uint64_t)v8);
  return v4;
}

void sub_100078D58( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_100078D6C(uint64_t a1)
{
  if (!*(_BYTE *)(a1 + 24)) {
    sub_100078DA0(a1);
  }
  return a1;
}

void sub_100078DA0(uint64_t a1)
{
  uint64_t v1 = **(void **)(a1 + 16);
  uint64_t v2 = **(void **)(a1 + 8);
  if (v1 != v2)
  {
    uint64_t v3 = **(void **)(a1 + 16);
    do
    {
      uint64_t v5 = *(void **)(v3 - 24);
      v3 -= 24LL;
      uint64_t v4 = v5;
      if (v5)
      {
        *(void *)(v1 - 16) = v4;
        operator delete(v4);
      }

      uint64_t v1 = v3;
    }

    while (v3 != v2);
  }

uint64_t *sub_100078DEC(uint64_t *a1, uint64_t a2)
{
  a1[2] = 0LL;
  a1[1] = 0LL;
  *a1 = (uint64_t)(a1 + 1);
  sub_100078E40(a1, *(int **)a2, (int *)(a2 + 8));
  return a1;
}

void sub_100078E28(_Unwind_Exception *a1)
{
}

uint64_t *sub_100078E40(uint64_t *result, int *a2, int *a3)
{
  if (a2 != a3)
  {
    uint64_t v4 = a2;
    uint64_t v5 = (uint64_t **)result;
    uint64_t v6 = result + 1;
    do
    {
      uint64_t result = sub_100078EC4(v5, v6, v4 + 7, v4 + 7);
      uint64_t v7 = (int *)*((void *)v4 + 1);
      if (v7)
      {
        do
        {
          uint64_t v8 = v7;
          uint64_t v7 = *(int **)v7;
        }

        while (v7);
      }

      else
      {
        do
        {
          uint64_t v8 = (int *)*((void *)v4 + 2);
          BOOL v9 = *(void *)v8 == (void)v4;
          uint64_t v4 = v8;
        }

        while (!v9);
      }

      uint64_t v4 = v8;
    }

    while (v8 != a3);
  }

  return result;
}

uint64_t *sub_100078EC4(uint64_t **a1, uint64_t *a2, int *a3, _DWORD *a4)
{
  uint64_t v6 = sub_100078F48(a1, a2, &v11, &v10, a3);
  uint64_t v7 = (uint64_t *)*v6;
  if (!*v6)
  {
    uint64_t v8 = (uint64_t **)v6;
    uint64_t v7 = (uint64_t *)operator new(0x20uLL);
    *((_DWORD *)v7 + 7) = *a4;
    sub_100019D14(a1, (uint64_t)v11, v8, v7);
  }

  return v7;
}

uint64_t *sub_100078F48(void *a1, uint64_t *a2, uint64_t **a3, uint64_t *a4, int *a5)
{
  uint64_t v5 = a1 + 1;
  if (a1 + 1 == a2 || (v6 = *a5, int v7 = *((_DWORD *)a2 + 7), *a5 < v7))
  {
    uint64_t v8 = (uint64_t *)*a2;
    if ((uint64_t *)*a1 == a2)
    {
      uint64_t v10 = a2;
LABEL_17:
      if (v8)
      {
        *a3 = v10;
        return v10 + 1;
      }

      else
      {
        *a3 = a2;
        return a2;
      }
    }

    if (v8)
    {
      BOOL v9 = (uint64_t *)*a2;
      do
      {
        uint64_t v10 = v9;
        BOOL v9 = (uint64_t *)v9[1];
      }

      while (v9);
    }

    else
    {
      uint64_t v13 = a2;
      do
      {
        uint64_t v10 = (uint64_t *)v13[2];
        BOOL v14 = *v10 == (void)v13;
        uint64_t v13 = v10;
      }

      while (v14);
    }

    int v15 = *a5;
    if (*((_DWORD *)v10 + 7) < *a5) {
      goto LABEL_17;
    }
    uint64_t v16 = *v5;
    if (*v5)
    {
      do
      {
        while (1)
        {
          uint64_t v17 = (uint64_t *)v16;
          int v18 = *(_DWORD *)(v16 + 28);
          if (v15 >= v18) {
            break;
          }
          uint64_t v16 = *v17;
          uint64_t v5 = v17;
          if (!*v17) {
            goto LABEL_29;
          }
        }

        if (v18 >= v15) {
          break;
        }
        uint64_t v5 = v17 + 1;
        uint64_t v16 = v17[1];
      }

      while (v16);
    }

    else
    {
      uint64_t v17 = a1 + 1;
    }

uint64_t sub_1000790F0(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_DWORD *)(a1 + 32) = *(_DWORD *)(a2 + 32);
  sub_100018334(a1, *(void *)(a2 + 8));
  return a1;
}

void sub_10007914C(_Unwind_Exception *a1)
{
}

void *sub_100079164(uint64_t a1, int *a2, void *a3)
{
  unint64_t v6 = *a2;
  unint64_t v7 = *(void *)(a1 + 8);
  if (v7)
  {
    uint8x8_t v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      unint64_t v3 = *a2;
      if (v7 <= v6) {
        unint64_t v3 = v6 % v7;
      }
    }

    else
    {
      unint64_t v3 = (v7 - 1) & v6;
    }

    BOOL v9 = *(void ***)(*(void *)a1 + 8 * v3);
    if (v9)
    {
      uint64_t v10 = *v9;
      if (*v9)
      {
        do
        {
          unint64_t v11 = v10[1];
          if (v11 == v6)
          {
            if (*((_DWORD *)v10 + 4) == (_DWORD)v6) {
              return v10;
            }
          }

          else
          {
            if (v8.u32[0] > 1uLL)
            {
              if (v11 >= v7) {
                v11 %= v7;
              }
            }

            else
            {
              v11 &= v7 - 1;
            }

            if (v11 != v3) {
              break;
            }
          }

          uint64_t v10 = (void *)*v10;
        }

        while (v10);
      }
    }
  }

  uint64_t v10 = operator new(0x18uLL);
  *uint64_t v10 = 0LL;
  v10[1] = v6;
  void v10[2] = *a3;
  float v12 = (float)(unint64_t)(*(void *)(a1 + 24) + 1LL);
  float v13 = *(float *)(a1 + 32);
  if (!v7 || (float)(v13 * (float)v7) < v12)
  {
    BOOL v14 = 1LL;
    if (v7 >= 3) {
      BOOL v14 = (v7 & (v7 - 1)) != 0;
    }
    unint64_t v15 = v14 | (2 * v7);
    unint64_t v16 = vcvtps_u32_f32(v12 / v13);
    if (v15 <= v16) {
      size_t v17 = v16;
    }
    else {
      size_t v17 = v15;
    }
    sub_100018334(a1, v17);
    unint64_t v7 = *(void *)(a1 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v7 <= v6) {
        unint64_t v3 = v6 % v7;
      }
      else {
        unint64_t v3 = v6;
      }
    }

    else
    {
      unint64_t v3 = (v7 - 1) & v6;
    }
  }

  uint64_t v18 = *(void *)a1;
  uint64_t v19 = *(void **)(*(void *)a1 + 8 * v3);
  if (v19)
  {
    *uint64_t v10 = *v19;
LABEL_38:
    void *v19 = v10;
    goto LABEL_39;
  }

  *uint64_t v10 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = v10;
  *(void *)(v18 + 8 * v3) = a1 + 16;
  if (*v10)
  {
    unint64_t v20 = *(void *)(*v10 + 8LL);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v20 >= v7) {
        v20 %= v7;
      }
    }

    else
    {
      v20 &= v7 - 1;
    }

    uint64_t v19 = (void *)(*(void *)a1 + 8 * v20);
    goto LABEL_38;
  }

void sub_100079368(_Unwind_Exception *a1)
{
}

uint64_t sub_100079384(uint64_t a1)
{
  int v2 = *(_DWORD *)(a1 + 24);
  uint64_t v3 = *(void *)(a1 + 16);
  if (v2 < *(_DWORD *)(v3 + 64)) {
    return 0LL;
  }
  int v5 = sub_100072EC0(v3);
  if (v5 >= *(_DWORD *)(*(void *)(a1 + 16) + 64LL)) {
    return 1LL;
  }
  int v6 = v5;
  do
  {
    sub_10007974C(v15, *(void *)(a1 + 8), v6);
    sub_100079518((int *)v15, 15, 31);
    uint64_t v7 = v16;
    uint64_t v8 = v17;
    while (v7 < v8)
    {
      uint64_t v9 = *(void *)(a1 + 16);
      signed int v10 = sub_1000795A4(v15)[3];
      if (*(_DWORD *)(v9 + 64) <= v10) {
        *(_DWORD *)(v9 + 64) = v10 + 1;
      }
      uint64_t v8 = v17;
      uint64_t v7 = ++v16;
    }

    sub_100071AB8(*(void *)(a1 + 16), v6);
    int v11 = *(_DWORD *)(a1 + 24);
    uint64_t v12 = *(void *)(a1 + 16);
    int v13 = *(_DWORD *)(v12 + 64);
    BOOL v4 = v11 >= v13;
    if (v18) {
      --*v18;
    }
    if (v19) {
      --*v19;
    }
    if (v11 < v13) {
      break;
    }
    int v6 = sub_100072EC0(v12);
  }

  while (v6 < *(_DWORD *)(*(void *)(a1 + 16) + 64LL));
  return v4;
}

void sub_1000794C0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, _DWORD *a22, uint64_t a23, uint64_t a24, uint64_t a25, _DWORD *a26)
{
  if (a22) {
    --*a22;
  }
  if (a26) {
    --*a26;
  }
  _Unwind_Resume(a1);
}

uint64_t sub_1000794F0(uint64_t a1)
{
  return *(unsigned int *)(a1 + 24);
}

uint64_t sub_1000794F8(uint64_t result)
{
  return result;
}

uint64_t sub_100079508(uint64_t result)
{
  *(_DWORD *)(result + ++*(_DWORD *)(result + 24) = 0;
  return result;
}

uint64_t sub_100079518(int *a1, int a2, int a3)
{
  char v3 = a2;
  int v5 = a1[14] & ~a3;
  uint64_t result = *(void *)(*(void *)a1 + 8LL);
  if (*(_BYTE *)(result + 160)) {
    int v7 = 15;
  }
  else {
    int v7 = 31;
  }
  int v8 = v7 & a2 | v5;
  a1[14] = v8;
  if ((v8 & 0x10) == 0 && a1[38] != 15)
  {
    uint64_t result = sub_100072AF0(result, a1[2]);
    if ((result & 1) == 0) {
      a1[38] = 0;
    }
  }

  if ((v3 & 0x10) != 0 && !a1[38]) {
    return (uint64_t)sub_1000798B8(a1);
  }
  return result;
}

unsigned int *sub_1000795A4(void *a1)
{
  int v2 = *((_DWORD *)a1 + 38);
  if (v2)
  {
    uint64_t v3 = a1[5];
    int v4 = v2 ^ 0xF;
  }

  else
  {
    if ((a1[7] & 0x10) != 0)
    {
      if (byte_1000DDAF8) {
        sub_10000A2DC(__p, "FATAL");
      }
      else {
        sub_10000A2DC(__p, "ERROR");
      }
      sub_10002A9EC(&v15, (uint64_t)__p);
      sub_10002A6A4(&std::cerr, (uint64_t)"ReplaceFst: Inconsistent arc iterator flags", 43LL);
      sub_10002AA94(&v15);
      if (v14 < 0) {
        operator delete(__p[0]);
      }
    }

    (*(void (**)(void, void, void *))(*(void *)*a1 + 120LL))(*a1, *((unsigned int *)a1 + 2), a1 + 10);
    int v4 = 0;
    uint64_t v3 = 0LL;
    a1[18] = a1[11];
    *((_DWORD *)a1 + 3std::istream::~istream(v2, v3 + 8) = 15;
    a1[5] = 0LL;
  }

  uint64_t v5 = a1[4] - v3;
  if (v5 < 0)
  {
    int v11 = *((_DWORD *)a1 + 14);
    if (((*((_DWORD *)a1 + 43) ^ 0xF) & v11) != 0)
    {
      sub_100077A18(*(void *)(*a1 + 8LL), a1 + 2, (_DWORD *)a1 + 39, v11 & 0xF);
      *((_DWORD *)a1 + 43) = a1[7] & 0xF;
    }

    return (unsigned int *)a1 + 39;
  }

  else
  {
    int v6 = (unsigned int *)(a1[18] + 16 * v5);
    int v7 = *((_DWORD *)a1 + 14);
    if ((v4 & v7) != 0)
    {
      uint64_t v8 = (uint64_t)(a1 + 2);
      uint64_t v10 = *a1;
      uint64_t v9 = (uint64_t)a1 + 60;
      sub_100077BD4(*(void *)(v10 + 8), v8, v6, v9, v7 & 0xF);
      return (unsigned int *)v9;
    }
  }

  return v6;
}

void sub_100079714( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t *sub_10007974C(uint64_t *a1, uint64_t a2, int a3)
{
  *a1 = a2;
  *((_DWORD *)a1 + 2) = a3;
  a1[2] = -1LL;
  int v4 = a1 + 2;
  a1[4] = 0LL;
  a1[5] = 0LL;
  a1[3] = -1LL;
  *((_DWORD *)a1 + 14) = 15;
  *((_OWORD *)a1 + 5) = 0u;
  uint64_t v5 = a1 + 10;
  *((_OWORD *)a1 + 7) = 0u;
  int v6 = a1 + 14;
  *((_DWORD *)a1 + 43) = 0;
  *((_OWORD *)a1 + 6) = 0u;
  *((_OWORD *)a1 + std::istream::~istream(v2, v3 + 8) = 0u;
  *(_OWORD *)((char *)a1 + 14RDString::RDString((RDString *)&v66, theString, 0) = 0u;
  uint64_t v7 = *(void *)(a2 + 8);
  if (*(_BYTE *)(v7 + 160))
  {
    char v8 = sub_100072AF0(v7, a3);
    a2 = *a1;
    a3 = *((_DWORD *)a1 + 2);
    if ((v8 & 1) == 0)
    {
      sub_100077848(*(uint64_t **)(a2 + 8), *((_DWORD *)a1 + 2));
      a2 = *a1;
      a3 = *((_DWORD *)a1 + 2);
    }
  }

  int v9 = sub_100072AF0(*(void *)(a2 + 8), a3);
  uint64_t v10 = *a1;
  uint64_t v11 = *(void *)(*a1 + 8);
  if (v9)
  {
    sub_10007307C(v11, *((_DWORD *)a1 + 2), v5);
    uint64_t v12 = a1[11];
    a1[6] = a1[12];
    a1[18] = v12;
    *((_DWORD *)a1 + 3std::istream::~istream(v2, v3 + 8) = 15;
  }

  else
  {
    *(_OWORD *)int v4 = *(_OWORD *)(*(void *)(*(void *)(v11 + 168) + 104LL) + 16LL * *((int *)a1 + 2));
    uint64_t v13 = *((unsigned int *)a1 + 7);
    if ((_DWORD)v13 == -1)
    {
      a1[6] = 0LL;
    }

    else
    {
      uint64_t v14 = *(void *)(*(void *)(*(void *)(v10 + 8) + 240LL) + 8LL * *((int *)a1 + 6));
      (*(void (**)(uint64_t, uint64_t, uint64_t *))(*(void *)v14 + 120LL))(v14, v13, v6);
      a1[18] = a1[15];
      unsigned int v15 = sub_100077A18(*(void *)(*a1 + 8), v4, (_DWORD *)a1 + 39, 7);
      *((_DWORD *)a1 + 43) = 7;
      uint64_t v16 = a1[16] + v15;
      a1[5] = v15;
      a1[6] = v16;
      *((_DWORD *)a1 + 3std::istream::~istream(v2, v3 + 8) = 0;
    }
  }

  return a1;
}

_BYTE *sub_1000798B8(_BYTE *result)
{
  uint64_t v1 = result;
  if ((result[56] & 0x10) != 0)
  {
    uint64_t v3 = *((void *)result + 16);
    *((void *)result + 1std::istream::~istream(v2, v3 + 8) = *((void *)result + 15);
    if ((*(_DWORD *)(*(void *)(*(void *)result + 8LL) + 132LL) & 0xFFFFFFFD) == 1) {
      int v4 = 4;
    }
    else {
      int v4 = 5;
    }
    *((_DWORD *)result + 3std::istream::~istream(v2, v3 + 8) = v4;
    uint64_t v2 = *((void *)result + 6) - v3;
  }

  else
  {
    uint64_t result = (_BYTE *)(*(uint64_t (**)(void))(**(void **)result + 120LL))();
    uint64_t v2 = 0LL;
    *((void *)v1 + 1std::istream::~istream(v2, v3 + 8) = *((void *)v1 + 11);
    *((_DWORD *)v1 + 3std::istream::~istream(v2, v3 + 8) = 15;
  }

  *((void *)v1 + 5) = v2;
  return result;
}

uint64_t sub_100079940(uint64_t *a1, int a2, void *a3)
{
  return sub_10007307C((uint64_t)a1, a2, a3);
}

uint64_t sub_10007998C(uint64_t a1, uint64_t a2, int a3)
{
  *(void *)a1 = off_1000D2C58;
  *(void *)(a1 + std::istream::~istream(v2, v3 + 8) = 0LL;
  *(void *)(a1 + 16) = a2;
  *(void *)(a1 + ++*(_DWORD *)(result + 24) = *(void *)(a2 + 8);
  *(void *)(a1 + 4RDString::RDString((RDString *)&v66, theString, 0) = 0LL;
  *(void *)(a1 + 4std::istream::~istream(v2, v3 + 8) = 0LL;
  *(void *)(a1 + ++*(void *)(result + 56) = 0LL;
  *(_DWORD *)(a1 + 64) = -1;
  *(_DWORD *)(a1 + sub_10001A760(v25 - 72) = a3;
  *(_WORD *)(a1 + 77) = 0;
  *(void *)(a1 + 8RDString::RDString((RDString *)&v66, theString, 0) = -1LL;
  *(void *)(a1 + 8std::istream::~istream(v2, v3 + 8) = -1LL;
  int v4 = *sub_10002AD60();
  *(void *)(a1 + 112) = 0xFFFFFFFFLL;
  *(_DWORD *)(a1 + 12RDString::RDString((RDString *)&v66, theString, 0) = v4;
  *(_DWORD *)(a1 + 1++*(_DWORD *)(result + 24) = -1;
  if (*(_DWORD *)(a1 + 72) == 2) {
    *(void *)(a1 + 112) = 0xFFFFFFFF00000000LL;
  }
  sub_100079A60(a1);
  return a1;
}

void sub_100079A2C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void **a10)
{
  uint64_t v12 = v11;
  a10 = v12;
  sub_10007A5BC(&a10);
  uint64_t v14 = *(void *)(v10 + 8);
  *(void *)(v10 + std::istream::~istream(v2, v3 + 8) = 0LL;
  if (v14) {
    (*(void (**)(uint64_t))(*(void *)v14 + 8LL))(v14);
  }
  _Unwind_Resume(a1);
}

void sub_100079A60(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 24);
  uint64_t v3 = (void *)(a1 + 40);
  sub_10007A00C(a1 + 40, (uint64_t)(*(void *)(v2 + 248) - *(void *)(v2 + 240)) >> 3);
  uint64_t v4 = *(void *)(v2 + 240);
  if (*(void *)(v2 + 248) != v4)
  {
    unint64_t v5 = 0LL;
    do
    {
      if (*(void *)(v4 + 8 * v5))
      {
        uint64_t v6 = *(void *)(a1 + 40);
        uint64_t v7 = operator new(0x50uLL);
        sub_10007A388((uint64_t)v7, *(void *)(v4 + 8 * v5), *(unsigned int *)(a1 + 72), 1, 0LL, 1);
        sub_10007A088((uint64_t *)(v6 + 8 * v5), (uint64_t)v7);
        uint64_t v8 = *(void *)(a1 + 24);
        int v9 = *(void **)(v8 + 176);
        if (v9 != (void *)(v8 + 184))
        {
          do
          {
            sub_10007A0B4(*(void *)(*v3 + 8 * v5), *((_DWORD *)v9 + 7));
            uint64_t v10 = (void *)v9[1];
            if (v10)
            {
              do
              {
                uint64_t v11 = v10;
                uint64_t v10 = (void *)*v10;
              }

              while (v10);
            }

            else
            {
              do
              {
                uint64_t v11 = (void *)v9[2];
                BOOL v12 = *v11 == (void)v9;
                int v9 = v11;
              }

              while (!v12);
            }

            int v9 = v11;
          }

          while (v11 != (void *)(*(void *)(a1 + 24) + 184LL));
        }
      }

      ++v5;
      uint64_t v4 = *(void *)(v2 + 240);
    }

    while (v5 < (*(void *)(v2 + 248) - v4) >> 3);
  }

void sub_100079B74(_Unwind_Exception *a1)
{
}

uint64_t sub_100079B88(uint64_t a1)
{
  *(void *)a1 = off_1000D2C58;
  uint64_t v4 = (void **)(a1 + 40);
  sub_10007A5BC(&v4);
  uint64_t v2 = *(void *)(a1 + 8);
  *(void *)(a1 + std::istream::~istream(v2, v3 + 8) = 0LL;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8LL))(v2);
  }
  return a1;
}

void sub_100079BE4(char *a1)
{
  *(void *)a1 = off_1000D2C58;
  uint64_t v3 = (void **)(a1 + 40);
  sub_10007A5BC(&v3);
  uint64_t v2 = *((void *)a1 + 1);
  *((void *)a1 + 1) = 0LL;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8LL))(v2);
  }
  operator delete(a1);
}

void *sub_100079C44(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = operator new(0x80uLL);
  sub_10007A630((uint64_t)v4, a1, a2);
  return v4;
}

void sub_100079C88(_Unwind_Exception *a1)
{
}

uint64_t sub_100079C9C(uint64_t a1, uint64_t a2)
{
  int v2 = *(_DWORD *)(a1 + 72);
  if (v2 == 4) {
    return 4LL;
  }
  if (v2 == 1) {
    uint64_t v6 = 0x10000000LL;
  }
  else {
    uint64_t v6 = 0x40000000LL;
  }
  uint64_t v7 = *(void *)(a1 + 16);
  if (v2 == 1) {
    uint64_t v8 = 805306368LL;
  }
  else {
    uint64_t v8 = 3221225472LL;
  }
  uint64_t v9 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v7 + 56LL))(v7, v8, a2);
  if ((v9 & v6) != 0) {
    return *(unsigned int *)(a1 + 72);
  }
  uint64_t v10 = 0x80000000LL;
  if (v2 == 1) {
    uint64_t v10 = 0x20000000LL;
  }
  if ((v9 & v10) != 0) {
    return 4LL;
  }
  else {
    return 5LL;
  }
}

uint64_t sub_100079D30(uint64_t result, int a2)
{
  if (*(_DWORD *)(result + 64) != a2)
  {
    uint64_t v2 = result;
    *(_DWORD *)(result + 64) = a2;
    *(_OWORD *)(result + 8RDString::RDString((RDString *)&v66, theString, 0) = *(_OWORD *)(*(void *)(*(void *)(*(void *)(result + 24) + 168LL) + 104LL) + 16LL * a2);
    uint64_t v3 = *(unsigned int *)(result + 92);
    if ((_DWORD)v3 == -1)
    {
      *(_BYTE *)(result + 76) = 1;
    }

    else
    {
      uint64_t v4 = *(_DWORD **)(*(void *)(result + 40) + 8LL * *(int *)(result + 88));
      *(void *)(result + 32) = v4;
      uint64_t result = (*(uint64_t (**)(void, uint64_t))(**(void **)(*(void *)v4 + 8LL) + 32LL))( *(void *)(*(void *)v4 + 8LL),  v3);
      v4[18] = v3;
      *(_DWORD *)(v2 + 1++*(_DWORD *)(result + 24) = *(_DWORD *)(v2 + 64);
      *(_BYTE *)(v2 + 7std::istream::~istream(v2, v3 + 8) = 0;
    }
  }

  return result;
}

uint64_t sub_100079DC8(uint64_t a1, int a2)
{
  *(_DWORD *)(a1 + 6std::istream::~istream(v2, v3 + 8) = a2;
  if (!a2) {
    *(_BYTE *)(a1 + 77) = 1;
  }
  *(_BYTE *)(a1 + 7std::istream::~istream(v2, v3 + 8) = sub_100077A18(*(void *)(a1 + 24), (uint64_t *)(a1 + 80), 0LL, 15);
  uint64_t v4 = *(void *)(a1 + 32);
  unint64_t v5 = (void *)(v4 + 24);
  *(void *)(v4 + 4std::istream::~istream(v2, v3 + 8) = v4 + 24;
  *(_BYTE *)(v4 + ++*(void *)(result + 56) = 0;
  if ((*(_BYTE *)(v4 + 8) & 1) != 0)
  {
    uint64_t v8 = *(void **)(v4 + 16);
    while (1)
    {
      *(void *)(v4 + 4std::istream::~istream(v2, v3 + 8) = v8;
      if (v8 == v5) {
        break;
      }
      char v9 = (*(uint64_t (**)(void, void))(**(void **)(*(void *)v4 + 8LL) + 40LL))( *(void *)(*(void *)v4 + 8LL),  *((unsigned int *)v8 + 7));
      uint64_t v10 = *(void **)(v4 + 48);
      if ((v9 & 1) != 0)
      {
        if (v10 == v5) {
          break;
        }
        *(_BYTE *)(v4 + 76) = 0;
        return 1LL;
      }

      uint64_t v11 = (void *)v10[1];
      if (v11)
      {
        do
        {
          uint64_t v8 = v11;
          uint64_t v11 = (void *)*v11;
        }

        while (v11);
      }

      else
      {
        do
        {
          uint64_t v8 = (void *)v10[2];
          BOOL v12 = *v8 == (void)v10;
          uint64_t v10 = v8;
        }

        while (!v12);
      }
    }
  }

  char v6 = (*(uint64_t (**)(void, uint64_t))(**(void **)(*(void *)v4 + 8LL) + 40LL))( *(void *)(*(void *)v4 + 8LL),  0xFFFFFFFFLL);
  *(_BYTE *)(v4 + 76) = v6 ^ 1;
  if ((v6 & 1) != 0) {
    return 1LL;
  }
  if (a2) {
    BOOL v12 = *(_BYTE *)(a1 + 78) == 0;
  }
  else {
    BOOL v12 = 0;
  }
  return !v12;
}

BOOL sub_100079F00(uint64_t a1)
{
  return !*(_BYTE *)(a1 + 77) && !*(_BYTE *)(a1 + 78) && *(_BYTE *)(*(void *)(a1 + 32) + 76LL) != 0;
}

uint64_t sub_100079F2C(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 77)) {
    return a1 + 112;
  }
  if (*(_BYTE *)(a1 + 78))
  {
    uint64_t v2 = a1 + 96;
    sub_100077A18(*(void *)(a1 + 24), (uint64_t *)(a1 + 80), (_DWORD *)(a1 + 96), 15);
  }

  else
  {
    uint64_t v3 = *(unsigned int **)(a1 + 32);
    if (*((_BYTE *)v3 + 56)) {
      uint64_t v4 = v3 + 15;
    }
    else {
      uint64_t v4 = (unsigned int *)(*(uint64_t (**)(void))(**(void **)(*(void *)v3 + 8LL) + 56LL))(*(void *)(*(void *)v3 + 8LL));
    }
    uint64_t v5 = *(void *)(a1 + 24);
    uint64_t v6 = a1 + 80;
    uint64_t v2 = a1 + 96;
    sub_100077BD4(v5, v6, v4, v2, 15);
  }

  return v2;
}

uint64_t sub_100079FC4(uint64_t result)
{
  if (*(_BYTE *)(result + 77))
  {
    *(_BYTE *)(result + 77) = 0;
  }

  else if (*(_BYTE *)(result + 78))
  {
    *(_BYTE *)(result + 7std::istream::~istream(v2, v3 + 8) = 0;
  }

  else
  {
    return sub_10007A8BC(*(void *)(result + 32));
  }

  return result;
}

uint64_t sub_100079FEC(uint64_t a1)
{
  return *(void *)(a1 + 16);
}

uint64_t sub_100079FF4(uint64_t a1, uint64_t a2)
{
  return a2;
}

uint64_t sub_100079FFC(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 16) + 32LL))(*(void *)(a1 + 16));
}

void sub_10007A00C(uint64_t a1, unint64_t a2)
{
  uint64_t v3 = *(uint64_t **)(a1 + 8);
  unint64_t v4 = ((uint64_t)v3 - *(void *)a1) >> 3;
  if (a2 <= v4)
  {
    if (a2 < v4)
    {
      uint64_t v5 = *(void *)a1 + 8 * a2;
      *(void *)(a1 + std::istream::~istream(v2, v3 + 8) = v5;
    }
  }

  else
  {
    sub_10007A1A0((char **)a1, a2 - v4);
  }

void sub_10007A088(uint64_t *a1, uint64_t a2)
{
  uint64_t v3 = *a1;
  *a1 = a2;
  if (v3)
  {
    unint64_t v4 = (void *)sub_10007A314(v3);
    operator delete(v4);
  }

void sub_10007A0B4(uint64_t a1, int a2)
{
  if (a2)
  {
    sub_10007A55C(a1 + 16, a2);
  }

  else
  {
    if (byte_1000DDAF8) {
      sub_10000A2DC(__p, "FATAL");
    }
    else {
      sub_10000A2DC(__p, "ERROR");
    }
    sub_10002A9EC(&v4, (uint64_t)__p);
    sub_10002A6A4(&std::cerr, (uint64_t)"MultiEpsMatcher: Bad multi-eps label: 0", 39LL);
    sub_10002AA94(&v4);
    if (v3 < 0) {
      operator delete(__p[0]);
    }
  }

void sub_10007A168( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_10007A1A0(char **a1, unint64_t a2)
{
  uint64_t v6 = a1[2];
  uint64_t v4 = (uint64_t)(a1 + 2);
  uint64_t v5 = v6;
  uint64_t v7 = *(char **)(v4 - 8);
  if (a2 <= (v6 - v7) >> 3)
  {
    if (a2)
    {
      bzero(*(void **)(v4 - 8), 8 * a2);
      v7 += 8 * a2;
    }

    a1[1] = v7;
  }

  else
  {
    uint64_t v8 = *a1;
    uint64_t v9 = v7 - *a1;
    unint64_t v10 = a2 + (v9 >> 3);
    if (v10 >> 61) {
      sub_100018774();
    }
    uint64_t v11 = v9 >> 3;
    uint64_t v12 = v5 - v8;
    if (v12 >> 2 > v10) {
      unint64_t v10 = v12 >> 2;
    }
    else {
      unint64_t v13 = v10;
    }
    uint64_t v24 = v4;
    if (v13)
    {
      uint64_t v14 = (char *)sub_100018788(v4, v13);
      uint64_t v8 = *a1;
      uint64_t v7 = a1[1];
    }

    else
    {
      uint64_t v14 = 0LL;
    }

    unsigned int v15 = &v14[8 * v11];
    uint64_t v16 = &v14[8 * v13];
    __int128 v23 = v16;
    bzero(v15, 8 * a2);
    uint64_t v17 = &v15[8 * a2];
    *((void *)&v22 + 1) = v17;
    if (v7 != v8)
    {
      do
      {
        uint64_t v18 = *((void *)v7 - 1);
        v7 -= 8;
        *(void *)uint64_t v7 = 0LL;
        *((void *)v15 - 1) = v18;
        v15 -= 8;
      }

      while (v7 != v8);
      uint64_t v17 = (char *)*((void *)&v22 + 1);
      uint64_t v16 = v23;
    }

    __int128 v19 = *(_OWORD *)a1;
    *a1 = v15;
    a1[1] = v17;
    __int128 v22 = v19;
    unint64_t v20 = a1[2];
    a1[2] = v16;
    __int128 v23 = v20;
    uint64_t v21 = v19;
    sub_10007A2C4((uint64_t)&v21);
  }

uint64_t sub_10007A2C4(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 8;
    sub_10007A088((uint64_t *)(i - 8), 0LL);
  }

  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

uint64_t sub_10007A314(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 12))
  {
    uint64_t v2 = *(uint64_t **)a1;
    if (*(void *)a1)
    {
      uint64_t v3 = v2[1];
      v2[1] = 0LL;
      if (v3) {
        (*(void (**)(uint64_t))(*(void *)v3 + 8LL))(v3);
      }
      uint64_t v4 = *v2;
      uint64_t *v2 = 0LL;
      if (v4) {
        (*(void (**)(uint64_t))(*(void *)v4 + 8LL))(v4);
      }
      operator delete(v2);
    }
  }

  sub_10001A7A8(a1 + 16, *(void **)(a1 + 24));
  return a1;
}

uint64_t sub_10007A388(uint64_t a1, uint64_t a2, uint64_t a3, int a4, uint64_t *a5, char a6)
{
  uint64_t v11 = a5;
  if (!a5)
  {
    uint64_t v11 = (uint64_t *)operator new(0x10uLL);
    sub_10007A474(v11, a2, a3);
  }

  *(void *)a1 = v11;
  *(_DWORD *)(a1 + std::istream::~istream(v2, v3 + 8) = a4;
  if (a5) {
    char v13 = a6;
  }
  else {
    char v13 = 1;
  }
  *(_BYTE *)(a1 + 12) = v13;
  *(void *)(a1 + ++*(_DWORD *)(result + 24) = 0LL;
  *(void *)(a1 + 16) = a1 + 24;
  *(void *)(a1 + 32) = 0LL;
  *(void *)(a1 + 4RDString::RDString((RDString *)&v66, theString, 0) = -1LL;
  *(void *)(a1 + 4std::istream::~istream(v2, v3 + 8) = 0LL;
  if ((_DWORD)a3 == 1) {
    int v14 = -1;
  }
  else {
    int v14 = 0;
  }
  if ((_DWORD)a3 == 1) {
    int v15 = 0;
  }
  else {
    int v15 = -1;
  }
  *(_DWORD *)(a1 + 6RDString::RDString((RDString *)&v66, theString, 0) = v14;
  *(_DWORD *)(a1 + 64) = v15;
  *(_DWORD *)(a1 + 6std::istream::~istream(v2, v3 + 8) = *sub_10002AD60();
  *(_DWORD *)(a1 + sub_10001A760(v25 - 72) = -1;
  return a1;
}

void sub_10007A44C(_Unwind_Exception *a1)
{
}

uint64_t *sub_10007A474(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = (*(uint64_t (**)(uint64_t, void))(*(void *)a2 + 72LL))(a2, 0LL);
  *a1 = v5;
  uint64_t v6 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v5 + 128LL))(v5, a3);
  a1[1] = v6;
  if (!v6)
  {
    uint64_t v7 = (int32x2_t *)operator new(0x98uLL);
    sub_100068074(v7, *a1, a3, 1);
    uint64_t v8 = a1[1];
    a1[1] = (uint64_t)v7;
    if (v8) {
      (*(void (**)(uint64_t))(*(void *)v8 + 8LL))(v8);
    }
  }

  return a1;
}

void sub_10007A504(_Unwind_Exception *a1)
{
  uint64_t v4 = v1[1];
  v1[1] = 0LL;
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 8LL))(v4);
  }
  uint64_t v5 = *v1;
  uint64_t *v1 = 0LL;
  if (v5) {
    (*(void (**)(uint64_t))(*(void *)v5 + 8LL))(v5);
  }
  _Unwind_Resume(a1);
}

uint64_t **sub_10007A55C(uint64_t a1, int a2)
{
  int v9 = a2;
  uint64_t result = sub_1000764F4((uint64_t **)a1, &v9, &v9);
  int v4 = *(_DWORD *)(a1 + 24);
  int v5 = v9;
  if (v4 == -1 || v9 < v4) {
    *(_DWORD *)(a1 + ++*(_DWORD *)(result + 24) = v9;
  }
  int v7 = *(_DWORD *)(a1 + 28);
  if (v7 == -1 || v7 < v5) {
    *(_DWORD *)(a1 + 2std::istream::~istream(v2, v3 + 8) = v5;
  }
  return result;
}

void sub_10007A5BC(void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = (uint64_t *)**a1;
  if (v2)
  {
    int v4 = (uint64_t *)v1[1];
    int v5 = **a1;
    if (v4 != v2)
    {
      do
        sub_10007A088(--v4, 0LL);
      while (v4 != v2);
      int v5 = **a1;
    }

    v1[1] = v2;
    operator delete(v5);
  }

uint64_t sub_10007A630(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(void *)a1 = off_1000D2C58;
  uint64_t v5 = (*(uint64_t (**)(void, uint64_t))(**(void **)(a2 + 16) + 72LL))(*(void *)(a2 + 16), a3);
  *(void *)(a1 + 16) = v5;
  uint64_t v6 = *(void *)(v5 + 8);
  *(void *)(a1 + 4RDString::RDString((RDString *)&v66, theString, 0) = 0LL;
  *(void *)(a1 + std::istream::~istream(v2, v3 + 8) = v5;
  *(void *)(a1 + ++*(_DWORD *)(result + 24) = v6;
  *(void *)(a1 + 4std::istream::~istream(v2, v3 + 8) = 0LL;
  *(void *)(a1 + ++*(void *)(result + 56) = 0LL;
  *(_DWORD *)(a1 + 64) = -1;
  *(_DWORD *)(a1 + sub_10001A760(v25 - 72) = *(_DWORD *)(a2 + 72);
  *(_WORD *)(a1 + 77) = 0;
  *(void *)(a1 + 8RDString::RDString((RDString *)&v66, theString, 0) = -1LL;
  *(void *)(a1 + 8std::istream::~istream(v2, v3 + 8) = -1LL;
  int v7 = *sub_10002AD60();
  *(void *)(a1 + 112) = 0xFFFFFFFFLL;
  *(_DWORD *)(a1 + 12RDString::RDString((RDString *)&v66, theString, 0) = v7;
  *(_DWORD *)(a1 + 1++*(_DWORD *)(result + 24) = -1;
  if (*(_DWORD *)(a1 + 72) == 2) {
    *(void *)(a1 + 112) = 0xFFFFFFFF00000000LL;
  }
  sub_100079A60(a1);
  return a1;
}

void sub_10007A6F0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  uint64_t v4 = *(void *)(v2 + 8);
  *(void *)(v2 + std::istream::~istream(v2, v3 + 8) = 0LL;
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 8LL))(v4);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_10007A720(uint64_t a1, int a2)
{
  uint64_t v3 = (void *)(a1 + 24);
  *(void *)(a1 + 4std::istream::~istream(v2, v3 + 8) = a1 + 24;
  *(_BYTE *)(a1 + ++*(void *)(result + 56) = 0;
  if (a2 == -1)
  {
    if ((*(_BYTE *)(a1 + 8) & 1) != 0)
    {
      uint64_t v6 = *(void **)(a1 + 16);
      while (1)
      {
        *(void *)(a1 + 4std::istream::~istream(v2, v3 + 8) = v6;
        if (v6 == v3) {
          break;
        }
        char v7 = (*(uint64_t (**)(void, void))(**(void **)(*(void *)a1 + 8LL) + 40LL))( *(void *)(*(void *)a1 + 8LL),  *((unsigned int *)v6 + 7));
        uint64_t v8 = *(void **)(a1 + 48);
        if ((v7 & 1) != 0)
        {
          if (v8 == v3) {
            break;
          }
          uint64_t result = 1LL;
          goto LABEL_11;
        }

        int v9 = (void *)v8[1];
        if (v9)
        {
          do
          {
            uint64_t v6 = v9;
            int v9 = (void *)*v9;
          }

          while (v9);
        }

        else
        {
          do
          {
            uint64_t v6 = (void *)v8[2];
            BOOL v10 = *v6 == (void)v8;
            uint64_t v8 = v6;
          }

          while (!v10);
        }
      }
    }

    uint64_t v4 = *(uint64_t (**)(void))(**(void **)(*(void *)a1 + 8LL) + 40LL);
    goto LABEL_10;
  }

  if (!a2)
  {
    uint64_t v4 = *(uint64_t (**)(void))(**(void **)(*(void *)a1 + 8LL) + 40LL);
LABEL_10:
    uint64_t result = v4();
    goto LABEL_11;
  }

  if ((*(_BYTE *)(a1 + 8) & 2) == 0 || v3 == (void *)sub_10007A850(a1 + 16, a2))
  {
    uint64_t v4 = *(uint64_t (**)(void))(**(void **)(*(void *)a1 + 8LL) + 40LL);
    goto LABEL_10;
  }

  uint64_t result = 1LL;
  *(_BYTE *)(a1 + ++*(void *)(result + 56) = 1;
LABEL_11:
  *(_BYTE *)(a1 + 76) = result ^ 1;
  return result;
}

uint64_t sub_10007A850(uint64_t a1, int a2)
{
  int v2 = *(_DWORD *)(a1 + 24);
  BOOL v3 = v2 != -1 && v2 <= a2;
  if (!v3 || *(_DWORD *)(a1 + 28) < a2) {
    return a1 + 8;
  }
  uint64_t v7 = *(void *)(a1 + 8);
  uint64_t v5 = a1 + 8;
  uint64_t v6 = v7;
  if (!v7) {
    return v5;
  }
  uint64_t v4 = v5;
  do
  {
    int v8 = *(_DWORD *)(v6 + 28);
    BOOL v9 = v8 < a2;
    if (v8 >= a2) {
      BOOL v10 = (uint64_t *)v6;
    }
    else {
      BOOL v10 = (uint64_t *)(v6 + 8);
    }
    if (!v9) {
      uint64_t v4 = v6;
    }
    uint64_t v6 = *v10;
  }

  while (*v10);
  if (v4 == v5 || *(_DWORD *)(v4 + 28) > a2) {
    return v5;
  }
  return v4;
}

uint64_t sub_10007A8BC(uint64_t result)
{
  uint64_t v1 = (_BYTE *)result;
  if (*(_BYTE *)(result + 56))
  {
    char v2 = 1;
LABEL_3:
    v1[76] = v2;
  }

  else
  {
    (*(void (**)(void))(**(void **)(*(void *)result + 8LL) + 64LL))(*(void *)(*(void *)result + 8LL));
    uint64_t result = (*(uint64_t (**)(void))(**(void **)(*(void *)v1 + 8LL) + 48LL))(*(void *)(*(void *)v1 + 8LL));
    v1[76] = result;
    if ((_DWORD)result)
    {
      BOOL v3 = v1 + 24;
      uint64_t v4 = (void *)*((void *)v1 + 6);
      if (v4 != (void *)(v1 + 24))
      {
        uint64_t v5 = (void *)v4[1];
        if (v5)
        {
          do
          {
            uint64_t v6 = v5;
            uint64_t v5 = (void *)*v5;
          }

          while (v5);
        }

        else
        {
          do
          {
            uint64_t v6 = (void *)v4[2];
            BOOL v7 = *v6 == (void)v4;
            uint64_t v4 = v6;
          }

          while (!v7);
        }

        while (1)
        {
          *((void *)v1 + 6) = v6;
          if (v6 == (void *)v3) {
            goto LABEL_19;
          }
          uint64_t result = (*(uint64_t (**)(void, void))(**(void **)(*(void *)v1 + 8LL) + 40LL))( *(void *)(*(void *)v1 + 8LL),  *((unsigned int *)v6 + 7));
          int v8 = (void *)*((void *)v1 + 6);
          if ((result & 1) != 0) {
            break;
          }
          BOOL v9 = (void *)v8[1];
          if (v9)
          {
            do
            {
              uint64_t v6 = v9;
              BOOL v9 = (void *)*v9;
            }

            while (v9);
          }

          else
          {
            do
            {
              uint64_t v6 = (void *)v8[2];
              BOOL v7 = *v6 == (void)v8;
              int v8 = v6;
            }

            while (!v7);
          }
        }

        if (v8 == (void *)v3)
        {
LABEL_19:
          uint64_t result = (*(uint64_t (**)(void, uint64_t))(**(void **)(*(void *)v1 + 8LL) + 40LL))( *(void *)(*(void *)v1 + 8LL),  0xFFFFFFFFLL);
          char v2 = result ^ 1;
          goto LABEL_3;
        }

        v1[76] = 0;
      }
    }
  }

  return result;
}

uint64_t sub_10007A9E0(uint64_t a1)
{
  v5[0] = *(int *)(a1 + 264);
  v5[1] = 0x100000002LL;
  _OWORD v5[2] = 0LL;
  sub_10007AA60((uint64_t)v3, (uint64_t *)(a1 + 240), a1 + 200, v5);
  sub_10007AF1C((uint64_t)v3, 0);
  uint64_t v1 = (v4 >> 34) & 1;
  sub_10007BBB4((uint64_t)v3);
  return v1;
}

void sub_10007AA4C(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

uint64_t sub_10007AA60(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v7 = *a4;
  uint64_t v8 = a4[1];
  uint64_t v9 = a4[2];
  *(_OWORD *)(a1 + ++*(_DWORD *)(result + 24) = 0u;
  BOOL v10 = (char **)(a1 + 24);
  *(_DWORD *)(a1 + 4) = v7;
  *(void *)(a1 + std::istream::~istream(v2, v3 + 8) = v8;
  *(void *)(a1 + 16) = v9;
  uint64_t v11 = (uint64_t *)(a1 + 72);
  *(_OWORD *)(a1 + 4RDString::RDString((RDString *)&v66, theString, 0) = 0u;
  *(_OWORD *)(a1 + ++*(void *)(result + 56) = 0u;
  sub_10007ADCC((void *)(a1 + 72), (a2[1] - *a2) >> 3);
  int v44 = v11;
  sub_1000790F0(a1 + 96, a3);
  sub_10008F514((void *)(a1 + 136));
  *(_OWORD *)(a1 + 16RDString::RDString((RDString *)&v66, theString, 0) = 0u;
  *(_OWORD *)(a1 + 2++*(_DWORD *)(result + 24) = 0u;
  *(_OWORD *)(a1 + 201) = 0u;
  *(_OWORD *)(a1 + 176) = 0u;
  *(_OWORD *)(a1 + 192) = 0u;
  *(_OWORD *)(a1 + 24RDString::RDString((RDString *)&v66, theString, 0) = 0u;
  *(_OWORD *)(a1 + 2++*(void *)(result + 56) = 0u;
  uint64_t v12 = *(void **)(a1 + 32);
  unint64_t v13 = *(void *)(a1 + 40);
  if ((unint64_t)v12 >= v13)
  {
    uint64_t v15 = ((char *)v12 - *v10) >> 3;
    uint64_t v16 = v13 - (void)*v10;
    uint64_t v17 = v16 >> 2;
    else {
      unint64_t v18 = v17;
    }
    if (v18) {
      __int128 v19 = (char *)sub_100018788(a1 + 40, v18);
    }
    else {
      __int128 v19 = 0LL;
    }
    unint64_t v20 = &v19[8 * v15];
    uint64_t v21 = &v19[8 * v18];
    *(void *)unint64_t v20 = 0LL;
    int v14 = v20 + 8;
    __int128 v23 = *(char **)(a1 + 24);
    __int128 v22 = *(char **)(a1 + 32);
    if (v22 != v23)
    {
      do
      {
        uint64_t v24 = *((void *)v22 - 1);
        v22 -= 8;
        *((void *)v20 - 1) = v24;
        v20 -= 8;
      }

      while (v22 != v23);
      __int128 v22 = *v10;
    }

    *(void *)(a1 + ++*(_DWORD *)(result + 24) = v20;
    *(void *)(a1 + 32) = v14;
    *(void *)(a1 + 4RDString::RDString((RDString *)&v66, theString, 0) = v21;
    if (v22) {
      operator delete(v22);
    }
  }

  else
  {
    *uint64_t v12 = 0LL;
    int v14 = v12 + 1;
  }

  *(void *)(a1 + 32) = v14;
  uint64_t v25 = *a2;
  if ((unint64_t)(a2[1] - *a2) >= 9)
  {
    unint64_t v26 = 1LL;
    do
    {
      uint64_t v27 = (*(uint64_t (**)(void, void))(**(void **)(v25 + 8 * v26) + 72LL))( *(void *)(v25 + 8 * v26),  0LL);
      uint64_t v28 = v27;
      uint64_t v30 = *(uint64_t **)(a1 + 32);
      unint64_t v29 = *(void *)(a1 + 40);
      if ((unint64_t)v30 >= v29)
      {
        uint64_t v32 = ((char *)v30 - *v10) >> 3;
        uint64_t v33 = v29 - (void)*v10;
        uint64_t v34 = v33 >> 2;
        else {
          unint64_t v35 = v34;
        }
        if (v35) {
          unint64_t v36 = (char *)sub_100018788(a1 + 40, v35);
        }
        else {
          unint64_t v36 = 0LL;
        }
        unsigned int v37 = (uint64_t *)&v36[8 * v32];
        *unsigned int v37 = v28;
        std::string::size_type v31 = v37 + 1;
        uint64_t v39 = *(char **)(a1 + 24);
        uint64_t v38 = *(char **)(a1 + 32);
        if (v38 != v39)
        {
          do
          {
            uint64_t v40 = *((void *)v38 - 1);
            v38 -= 8;
            *--unsigned int v37 = v40;
          }

          while (v38 != v39);
          uint64_t v38 = *v10;
        }

        *(void *)(a1 + ++*(_DWORD *)(result + 24) = v37;
        *(void *)(a1 + 32) = v31;
        *(void *)(a1 + 4RDString::RDString((RDString *)&v66, theString, 0) = &v36[8 * v35];
        if (v38) {
          operator delete(v38);
        }
      }

      else
      {
        *uint64_t v30 = v27;
        std::string::size_type v31 = v30 + 1;
      }

      *(void *)(a1 + 32) = v31;
      ++v26;
      uint64_t v25 = *a2;
    }

    while (v26 < (a2[1] - *a2) >> 3);
  }

  __int128 v41 = *(uint64_t **)(a3 + 16);
  *(_DWORD *)a1 = *(_DWORD *)(i + 4LL * *(int *)(a1 + 4));
  return a1;
}

void sub_10007AD14( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void **a10, uint64_t a11, uint64_t a12, void **a13, void **a14)
{
  unint64_t v18 = (void *)v14[31];
  if (v18)
  {
    v14[32] = v18;
    operator delete(v18);
  }

  a14 = a10;
  sub_10007AE40(&a14);
  __int128 v19 = (void *)v14[23];
  if (v19) {
    operator delete(v19);
  }
  unint64_t v20 = *v16;
  if (*v16)
  {
    v14[21] = v20;
    operator delete(v20);
  }

  v14[17] = off_1000D0A50;
  sub_100017FC4((uint64_t)(v14 + 18));
  sub_10001A760(a11);
  uint64_t v21 = *a13;
  if (*a13)
  {
    v14[10] = v21;
    operator delete(v21);
  }

  __int128 v22 = (void *)v14[6];
  if (v22)
  {
    v14[7] = v22;
    operator delete(v22);
  }

  __int128 v23 = *v15;
  if (*v15)
  {
    v14[4] = v23;
    operator delete(v23);
  }

  _Unwind_Resume(a1);
}

void *sub_10007ADCC(void *a1, unint64_t a2)
{
  *a1 = 0LL;
  a1[1] = 0LL;
  a1[2] = 0LL;
  if (a2)
  {
    sub_10002DC70(a1, a2);
    unint64_t v4 = (char *)a1[1];
    bzero(v4, 4 * a2);
    a1[1] = &v4[4 * a2];
  }

  return a1;
}

void sub_10007AE24(_Unwind_Exception *exception_object)
{
  BOOL v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + std::istream::~istream(v2, v3 + 8) = v3;
    operator delete(v3);
  }

  _Unwind_Resume(exception_object);
}

void sub_10007AE40(void ***a1)
{
  char v2 = *a1;
  if (*v2)
  {
    sub_10007AE80((uint64_t)v2, (uint64_t)*v2);
    operator delete(**a1);
  }

void sub_10007AE80(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a1 + 8);
  if (v4 != a2)
  {
    uint64_t v5 = v4 - 24;
    do
    {
      sub_10001A7A8(v5, *(void **)(v5 + 8));
      sub_10001A7A8(v5 - 24, *(void **)(v5 - 16));
      uint64_t v6 = v5 - 56;
      v5 -= 80LL;
    }

    while (v6 != a2);
  }

  *(void *)(a1 + std::istream::~istream(v2, v3 + 8) = a2;
}

uint64_t sub_10007AEE4(uint64_t a1)
{
  return a1;
}

void sub_10007AF1C(uint64_t a1, int a2)
{
  char v2 = a2;
  uint64_t v4 = a1 + 136;
  if ((int)((*(void *)(*(void *)(a1 + 144) + 64LL) - *(void *)(*(void *)(a1 + 144) + 56LL)) >> 3) >= 1)
  {
    if (!a2) {
      return;
    }
    uint64_t v5 = (_BYTE *)(a1 + 216);
    if (*(_BYTE *)(a1 + 216)) {
      return;
    }
    sub_10002A07C(a1 + 136);
    sub_10007AE80(a1 + 224, *(void *)(a1 + 224));
    *(void *)(a1 + 20std::istream::~istream(v2, v3 + 8) = 0LL;
    *(void *)(a1 + 2++*(void *)(result + 56) = *(void *)(a1 + 248);
    *(_BYTE *)(a1 + 216) = v2;
    goto LABEL_6;
  }

  *(_BYTE *)(a1 + 216) = a2;
  uint64_t v5 = (_BYTE *)(a1 + 216);
  if (a2) {
LABEL_6:
  }
    sub_10007B5B0((uint64_t *)(a1 + 224), (uint64_t)(*(void *)(a1 + 32) - *(void *)(a1 + 24)) >> 3);
  if (*(void *)(a1 + 32) != *(void *)(a1 + 24))
  {
    unint64_t v6 = 0LL;
    do
    {
      sub_100029F78(v4);
      int v7 = *sub_10002AD60();
      sub_10002D714(v4);
      uint64_t v8 = *(void **)(a1 + 144);
      LODWORD(v46) = v7;
      sub_10002D840(v8, v6, (float *)&v46);
      if (*(_BYTE *)(a1 + 216))
      {
        int v49 = 0LL;
        uint64_t v50 = 0LL;
        __int128 v46 = 0uLL;
        LODWORD(v47) = 0;
        *((void *)&v47 + 1) = 0LL;
        unint64_t v48 = (unint64_t)&v49;
        v51[1] = 0LL;
        __p[0] = 0LL;
        v51[0] = &v51[1];
        unint64_t v9 = *(void *)(a1 + 232);
        if (v9 >= *(void *)(a1 + 240))
        {
          uint64_t v14 = sub_10007B9EC((uint64_t *)(a1 + 224), (uint64_t)&v46);
        }

        else
        {
          __int128 v10 = v47;
          *(_OWORD *)unint64_t v9 = v46;
          *(_OWORD *)(v9 + 16) = v10;
          *(void *)(v9 + 32) = v48;
          uint64_t v11 = v49;
          *(void *)(v9 + 4RDString::RDString((RDString *)&v66, theString, 0) = v49;
          unint64_t v12 = v9 + 40;
          uint64_t v13 = v50;
          *(void *)(v9 + 4std::istream::~istream(v2, v3 + 8) = v50;
          if (v13)
          {
            v11[2] = v12;
            unint64_t v48 = (unint64_t)&v49;
            int v49 = 0LL;
            uint64_t v50 = 0LL;
          }

          else
          {
            *(void *)(v9 + 32) = v12;
          }

          *(void **)(v9 + ++*(void *)(result + 56) = v51[0];
          uint64_t v15 = v51[1];
          *(void **)(v9 + 64) = v51[1];
          unint64_t v16 = v9 + 64;
          uint64_t v17 = __p[0];
          *(void **)(v9 + sub_10001A760(v25 - 72) = __p[0];
          if (v17)
          {
            void v15[2] = v16;
            v51[0] = &v51[1];
            v51[1] = 0LL;
            __p[0] = 0LL;
          }

          else
          {
            *(void *)(v9 + ++*(void *)(result + 56) = v16;
          }

          uint64_t v14 = v9 + 80;
        }

        *(void *)(a1 + 232) = v14;
        sub_10001A7A8((uint64_t)v51, (void *)v51[1]);
        sub_10001A7A8((uint64_t)&v48, v49);
      }

      ++v6;
    }

    while (v6 < (uint64_t)(*(void *)(a1 + 32) - *(void *)(a1 + 24)) >> 3);
  }

  int v18 = *(_DWORD *)(a1 + 4);
  sub_10002D714(v4);
  uint64_t v19 = *(void *)(a1 + 144);
  *(_DWORD *)(v19 + 8RDString::RDString((RDString *)&v66, theString, 0) = v18;
  unint64_t v20 = (*(uint64_t (**)(uint64_t))(*(void *)v19 + 16LL))(v19);
  *(void *)(v19 + std::istream::~istream(v2, v3 + 8) = v20 & 0xCCCFFFFF0007LL | (((v20 >> 35) & 1) << 37) | *(void *)(v19 + 8) & 4LL;
  int v60 = 0;
  uint64_t v22 = *(void *)(a1 + 24);
  uint64_t v21 = *(void *)(a1 + 32);
  if (v21 != v22)
  {
    int v23 = 0;
    uint64_t v24 = 0LL;
    while (1)
    {
      uint64_t v25 = *(void *)(v22 + 8 * v24);
      if (!v25) {
        goto LABEL_60;
      }
      uint64_t v57 = 0LL;
      int v58 = 0;
      unsigned int v59 = 0;
      uint64_t v45 = v25;
      (*(void (**)(uint64_t, uint64_t *))(*(void *)v25 + 112LL))(v25, &v57);
LABEL_25:
      if (!v57) {
        break;
      }
      if (!(*(unsigned int (**)(uint64_t))(*(void *)v57 + 16LL))(v57))
      {
        if (v57)
        {
          uint64_t v26 = (*(uint64_t (**)(void))(*(void *)v57 + 24LL))();
          goto LABEL_31;
        }

void sub_10007B520(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
}

uint64_t sub_10007B5B0(uint64_t *a1, unint64_t a2)
{
  uint64_t v4 = a1[2];
  uint64_t result = (uint64_t)(a1 + 2);
  if (0xCCCCCCCCCCCCCCCDLL * ((v4 - *a1) >> 4) < a2)
  {
    if (a2 >= 0x333333333333334LL) {
      sub_100018774();
    }
    uint64_t v5 = a1[1] - *a1;
    void v7[4] = result;
    v7[0] = sub_10007B6D4(result, a2);
    v7[1] = v7[0] + v5;
    _OWORD v7[2] = v7[0] + v5;
    v7[3] = v7[0] + 80 * v6;
    sub_10007B660(a1, v7);
    return sub_10007B958((uint64_t)v7);
  }

  return result;
}

void sub_10007B64C(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

uint64_t sub_10007B660(uint64_t *a1, void *a2)
{
  uint64_t result = sub_10007B718((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

void *sub_10007B6D4(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x333333333333334LL) {
    sub_100017F08();
  }
  return operator new(80 * a2);
}

uint64_t sub_10007B718(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7 = a7;
  *(void *)&__int128 v16 = a6;
  *((void *)&v16 + 1) = a7;
  __int128 v15 = v16;
  v13[0] = a1;
  v13[1] = &v15;
  _DWORD v13[2] = &v16;
  char v14 = 0;
  if (a3 == a5)
  {
    uint64_t v11 = a6;
  }

  else
  {
    uint64_t v9 = a3;
    do
    {
      v9 -= 80LL;
      sub_10007B7CC(a1, v7 - 80, v9);
      uint64_t v7 = *((void *)&v16 + 1) - 80LL;
      *((void *)&v16 + 1) -= 80LL;
    }

    while (v9 != a5);
    uint64_t v11 = v16;
  }

  char v14 = 1;
  sub_10007B848((uint64_t)v13);
  return v11;
}

void sub_10007B7CC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  __int128 v3 = *(_OWORD *)(a3 + 16);
  *(_OWORD *)a2 = *(_OWORD *)a3;
  *(_OWORD *)(a2 + 16) = v3;
  *(void *)(a2 + 32) = *(void *)(a3 + 32);
  uint64_t v4 = (void *)(a3 + 40);
  uint64_t v5 = *(void *)(a3 + 40);
  *(void *)(a2 + 4RDString::RDString((RDString *)&v66, theString, 0) = v5;
  uint64_t v6 = a2 + 40;
  uint64_t v7 = *(void *)(a3 + 48);
  *(void *)(a2 + 4std::istream::~istream(v2, v3 + 8) = v7;
  if (v7)
  {
    *(void *)(v5 + 16) = v6;
    *(void *)(a3 + 32) = v4;
    *uint64_t v4 = 0LL;
    *(void *)(a3 + 4std::istream::~istream(v2, v3 + 8) = 0LL;
  }

  else
  {
    *(void *)(a2 + 32) = v6;
  }

  *(void *)(a2 + ++*(void *)(result + 56) = *(void *)(a3 + 56);
  uint64_t v8 = (void *)(a3 + 64);
  uint64_t v9 = *(void *)(a3 + 64);
  *(void *)(a2 + 64) = v9;
  uint64_t v10 = a2 + 64;
  uint64_t v11 = *(void *)(a3 + 72);
  *(void *)(a2 + sub_10001A760(v25 - 72) = v11;
  if (v11)
  {
    *(void *)(v9 + 16) = v10;
    *(void *)(a3 + ++*(void *)(result + 56) = v8;
    void *v8 = 0LL;
    *(void *)(a3 + sub_10001A760(v25 - 72) = 0LL;
  }

  else
  {
    *(void *)(a2 + ++*(void *)(result + 56) = v10;
  }