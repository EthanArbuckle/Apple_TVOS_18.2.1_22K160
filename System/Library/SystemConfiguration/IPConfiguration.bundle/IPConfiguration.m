BOOL sub_33A4(uint64_t a1)
{
  return *(void *)(a1 + 24) != 0LL;
}

_OWORD *sub_33B4(uint64_t a1)
{
  v2 = sub_5524(a1);
  if (!v2) {
    return 0LL;
  }
  v3 = v2;
  uint64_t v4 = sub_34C4();
  v5 = malloc(0x118uLL);
  _OWORD *v5 = 0u;
  v5[1] = 0u;
  v5[2] = 0u;
  v5[3] = 0u;
  v5[4] = 0u;
  v5[5] = 0u;
  v5[6] = 0u;
  v5[7] = 0u;
  v5[8] = 0u;
  v5[9] = 0u;
  v5[10] = 0u;
  v5[11] = 0u;
  v5[12] = 0u;
  v5[13] = 0u;
  v5[14] = 0u;
  v5[15] = 0u;
  v5[16] = 0u;
  *((void *)v5 + 34) = 0LL;
  if (!sub_53DA4(v3 + 1, v5))
  {
    free(v5);
    return 0LL;
  }

  *((void *)v5 + 2) = v3;
  __int128 v6 = *(_OWORD *)(v4 + 8);
  *((void *)v5 + 30) = *(void *)(v4 + 24);
  v5[14] = v6;
  v7 = (const char *)nullsub_1(*v3);
  snprintf(__str, 0x20uLL, "arp-%s", v7);
  *((void *)v5 + 8) = timer_callout_init(__str);
  return v5;
}

uint64_t sub_34C4()
{
  uint64_t result = qword_6C110;
  if (!qword_6C110)
  {
    v1 = malloc(0x68uLL);
    qword_6C110 = (uint64_t)v1;
    _OWORD *v1 = 0u;
    v1[1] = 0u;
    v1[2] = 0u;
    v1[3] = 0u;
    v1[4] = 0u;
    v1[5] = 0u;
    *((void *)v1 + 12) = 0LL;
    sub_53D14((void *)v1 + 9, (uint64_t)sub_646C, 0LL);
    return qword_6C110;
  }

  return result;
}

void sub_3524(uint64_t **a1)
{
  if (a1)
  {
    v2 = *a1;
    if (*a1)
    {
      v3 = (void *)v2[2];
      v12 = (const char *)v3;
      unsigned int v4 = sub_53E84(v3 + 1, (uint64_t)v2);
      if (v4 == -1)
      {
        uint64_t v5 = sub_57538();
        uint64_t v6 = _SC_syslog_os_log_mapping(5LL);
        if (__SC_log_enabled(5LL, v5, v6))
        {
          uint64_t v7 = _os_log_pack_size(12LL);
          v8 = (char *)&v12 - ((__chkstk_darwin(v7) + 15) & 0xFFFFFFFFFFFFFFF0LL);
          v9 = __error();
          uint64_t v10 = _os_log_pack_fill(v8, v7, *v9, &dword_0, "arp_client_free(%s) not in list?", v12);
          uint64_t v11 = nullsub_1(*v3);
          *(_DWORD *)uint64_t v10 = 136315138;
          *(void *)(v10 + 4) = v11;
          __SC_log_send(5LL, v5, v6, v8);
        }
      }

      else
      {
        sub_53DA8(v3 + 1, v4, 0LL);
      }

      sub_4718((uint64_t)v2);
      timer_callout_free(v2 + 8);
      free(v2);
      *a1 = 0LL;
    }
  }
}

void sub_36B8(uint64_t *a1)
{
}

void sub_36E4(void **a1)
{
  if (a1)
  {
    v2 = *a1;
    if (*a1)
    {
      v3 = (uint64_t *)(sub_34C4() + 72);
      unsigned int v4 = sub_53E84(v3, (uint64_t)v2);
      if (v4 == -1)
      {
        uint64_t v5 = sub_57538();
        uint64_t v6 = _SC_syslog_os_log_mapping(5LL);
        if (__SC_log_enabled(5LL, v5, v6))
        {
          uint64_t v7 = _os_log_pack_size(12LL);
          v8 = (char *)&v12 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0LL);
          v9 = __error();
          uint64_t v10 = _os_log_pack_fill(v8, v7, *v9, &dword_0, "arp_if_session_free(%s) not in list?", v12);
          uint64_t v11 = nullsub_1(*v2);
          *(_DWORD *)uint64_t v10 = 136315138;
          *(void *)(v10 + 4) = v11;
          __SC_log_send(5LL, v5, v6, v8);
        }
      }

      else
      {
        sub_53DA8(v3, v4, 0LL);
      }

      DHCPLeaseListFree_0(v2 + 1);
      free(v2);
      *a1 = 0LL;
    }
  }

uint64_t sub_3850(uint64_t result, int a2)
{
  *(_DWORD *)(result + 248) = a2;
  return result;
}

void sub_3858(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5, int a6, int a7)
{
  v14 = *(uint64_t **)(a1 + 16);
  sub_4718(a1);
  sub_4764(v14);
  *(_DWORD *)(a1 + 48) = a5;
  *(_DWORD *)(a1 + 52) = a6;
  *(void *)(a1 + 24) = a2;
  *(void *)(a1 + 32) = a3;
  *(void *)(a1 + 40) = a4;
  *(_BYTE *)(a1 + 96) = 0;
  *(_DWORD *)(a1 + 240) = a7;
  *(void *)(a1 + 56) = *(unsigned int *)(a1 + 232);
  if (sub_3910(a1))
  {
    *(void *)a1 = 0x400000001LL;
    sub_4270(a1);
  }

  else
  {
    *(_DWORD *)(a1 + 4) = 3;
    sub_41D8(a1);
  }

uint64_t sub_3910(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 8)) {
    return 1LL;
  }
  v3 = *(void **)(a1 + 16);
  ++*((_DWORD *)v3 + 16);
  uint64_t v4 = sub_57538();
  uint64_t v5 = _SC_syslog_os_log_mapping(7LL);
  if (__SC_log_enabled(7LL, v4, v5))
  {
    uint64_t v6 = _os_log_pack_size(18LL);
    uint64_t v7 = (char *)&v81 - ((__chkstk_darwin(v6) + 15) & 0xFFFFFFFFFFFFFFF0LL);
    v8 = __error();
    uint64_t v9 = _os_log_pack_fill( v7,  v6,  *v8,  &dword_0,  "arp_client_open_fd (%s): refcount %d",  v81,  (_DWORD)v82);
    uint64_t v10 = nullsub_1(*v3);
    int v11 = *((_DWORD *)v3 + 16);
    *(_DWORD *)uint64_t v9 = 136315394;
    *(void *)(v9 + 4) = v10;
    *(_WORD *)(v9 + 12) = 1024;
    *(_DWORD *)(v9 + 14) = v11;
    __SC_log_send(7LL, v4, v5, v7);
  }

  uint64_t result = 1LL;
  *(_DWORD *)(a1 + 8) = 1;
  int v12 = sub_4F728();
  if (v12 < 0)
  {
    uint64_t v18 = sub_57538();
    uint64_t v19 = _SC_syslog_os_log_mapping(3LL);
    if (__SC_log_enabled(3LL, v18, v19))
    {
      uint64_t v20 = _os_log_pack_size(28LL);
      v21 = (char *)&v81 - ((__chkstk_darwin(v20) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      v22 = __error();
      uint64_t v23 = _os_log_pack_fill( v21,  v20,  *v22,  &dword_0,  "arp_client_open_fd: bpf_new(%s) failed, %s (%d)",  v81,  v82,  (_DWORD)v83);
      uint64_t v24 = nullsub_1(*v3);
      v25 = __error();
      v26 = strerror(*v25);
      int v27 = *__error();
      *(_DWORD *)uint64_t v23 = 136315650;
      *(void *)(v23 + 4) = v24;
      *(_WORD *)(v23 + 12) = 2080;
      *(void *)(v23 + 14) = v26;
      *(_WORD *)(v23 + 22) = 1024;
      *(_DWORD *)(v23 + 24) = v27;
      __SC_log_send(3LL, v18, v19, v21);
    }

    v28 = (const char *)nullsub_1(*v3);
    v29 = __error();
    v30 = strerror(*v29);
    v31 = __error();
    snprintf((char *)(a1 + 96), 0x80uLL, "arp_client_open_fd: bpf_new(%s) failed, %s (%d)", v28, v30, *v31);
    goto LABEL_32;
  }

  int v13 = v12;
  int v86 = 1;
  if (ioctl(v12, 0x8004667EuLL, &v86) < 0)
  {
    uint64_t v32 = sub_57538();
    uint64_t v33 = _SC_syslog_os_log_mapping(3LL);
    if (__SC_log_enabled(3LL, v32, v33))
    {
      uint64_t v34 = _os_log_pack_size(12LL);
      v35 = (char *)&v81 - ((__chkstk_darwin(v34) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      v36 = __error();
      uint64_t v37 = _os_log_pack_fill(v35, v34, *v36, &dword_0, "ioctl FIONBIO failed %s", v81);
      v38 = __error();
      v39 = strerror(*v38);
      *(_DWORD *)uint64_t v37 = 136315138;
      *(void *)(v37 + 4) = v39;
      __SC_log_send(3LL, v32, v33, v35);
    }

    goto LABEL_31;
  }

  uint64_t v14 = nullsub_1(*v3);
  if ((sub_4F830(v13, v14) & 0x80000000) != 0)
  {
    uint64_t v40 = sub_57538();
    uint64_t v41 = _SC_syslog_os_log_mapping(3LL);
    if (__SC_log_enabled(3LL, v40, v41))
    {
      uint64_t v42 = _os_log_pack_size(28LL);
      v43 = (char *)&v81 - ((__chkstk_darwin(v42) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      v44 = __error();
      uint64_t v45 = _os_log_pack_fill( v43,  v42,  *v44,  &dword_0,  "arp_client_open_fd: bpf_setif (%s) failed: %s (%d)",  v81,  v82,  (_DWORD)v83);
      uint64_t v46 = nullsub_1(*v3);
      v47 = __error();
      v48 = strerror(*v47);
      int v49 = *__error();
      *(_DWORD *)uint64_t v45 = 136315650;
      *(void *)(v45 + 4) = v46;
      *(_WORD *)(v45 + 12) = 2080;
      *(void *)(v45 + 14) = v48;
      *(_WORD *)(v45 + 22) = 1024;
      *(_DWORD *)(v45 + 24) = v49;
      __SC_log_send(3LL, v40, v41, v43);
    }

    nullsub_1(*v3);
    v50 = __error();
    strerror(*v50);
    __error();
    snprintf((char *)(a1 + 96), 0x80uLL, "arp_client_open_fd: bpf_setif (%s) failed: %s (%d)");
    goto LABEL_31;
  }

  sub_4F8A8(v13, 1);
  sub_4F8D8(v13, 1);
  if (sub_54E20(*v3) == 144)
  {
    int v15 = v13;
    int v16 = 16;
    int v17 = 50;
  }

  else
  {
    int v15 = v13;
    int v16 = 12;
    int v17 = 42;
  }

  if ((sub_4F978(v15, v16, 2054, v17) & 0x80000000) != 0)
  {
    uint64_t v59 = sub_57538();
    uint64_t v60 = _SC_syslog_os_log_mapping(3LL);
    if (__SC_log_enabled(3LL, v59, v60))
    {
      uint64_t v61 = _os_log_pack_size(28LL);
      v62 = (char *)&v81 - ((__chkstk_darwin(v61) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      v63 = __error();
      uint64_t v64 = _os_log_pack_fill( v62,  v61,  *v63,  &dword_0,  "arp_client_open_fd: bpf_arp_filter(%s) failed: %s (%d)",  v81,  v82,  (_DWORD)v83);
      uint64_t v65 = nullsub_1(*v3);
      v66 = __error();
      v67 = strerror(*v66);
      int v68 = *__error();
      *(_DWORD *)uint64_t v64 = 136315650;
      *(void *)(v64 + 4) = v65;
      *(_WORD *)(v64 + 12) = 2080;
      *(void *)(v64 + 14) = v67;
      *(_WORD *)(v64 + 22) = 1024;
      *(_DWORD *)(v64 + 24) = v68;
      __SC_log_send(3LL, v59, v60, v62);
    }

    nullsub_1(*v3);
    v69 = __error();
    strerror(*v69);
    __error();
    snprintf((char *)(a1 + 96), 0x80uLL, "arp_client_open_fd: bpf_arp_filter(%s) failed: %s (%d)");
    goto LABEL_31;
  }

  if ((sub_4F6F0(v13, (uint64_t)(v3 + 6)) & 0x80000000) != 0)
  {
    uint64_t v70 = sub_57538();
    uint64_t v71 = _SC_syslog_os_log_mapping(3LL);
    if (__SC_log_enabled(3LL, v70, v71))
    {
      uint64_t v72 = _os_log_pack_size(28LL);
      v73 = (char *)&v81 - ((__chkstk_darwin(v72) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      v74 = __error();
      uint64_t v75 = _os_log_pack_fill( v73,  v72,  *v74,  &dword_0,  "arp_client_open_fd: bpf_get_blen(%s) failed, %s (%d)",  v81,  v82,  (_DWORD)v83);
      uint64_t v76 = nullsub_1(*v3);
      v77 = __error();
      v78 = strerror(*v77);
      int v79 = *__error();
      *(_DWORD *)uint64_t v75 = 136315650;
      *(void *)(v75 + 4) = v76;
      *(_WORD *)(v75 + 12) = 2080;
      *(void *)(v75 + 14) = v78;
      *(_WORD *)(v75 + 22) = 1024;
      *(_DWORD *)(v75 + 24) = v79;
      __SC_log_send(3LL, v70, v71, v73);
    }

    nullsub_1(*v3);
    v80 = __error();
    strerror(*v80);
    __error();
    snprintf((char *)(a1 + 96), 0x80uLL, "arp_client_open_fd: bpf_get_blen(%s) failed, %s (%d)");
    goto LABEL_31;
  }

  v3[5] = malloc(*((int *)v3 + 12));
  v81 = (const char *)_NSConcreteStackBlock;
  v82 = (const char *)0x40000000;
  v83 = sub_589C;
  v84 = &unk_64B30;
  int v85 = v13;
  v51 = sub_141BC(v13, (uint64_t)sub_59B4, (uint64_t)v3, 0LL, &v81);
  v3[7] = v51;
  if (!v51)
  {
LABEL_31:
    close(v13);
LABEL_32:
    sub_4AE8(a1);
    return 0LL;
  }

  uint64_t v52 = sub_57538();
  uint64_t v53 = _SC_syslog_os_log_mapping(7LL);
  uint64_t v54 = _os_log_pack_size(18LL);
  v55 = (char *)&v81 - ((__chkstk_darwin(v54) + 15) & 0xFFFFFFFFFFFFFFF0LL);
  v56 = __error();
  uint64_t v57 = _os_log_pack_fill( v55,  v54,  *v56,  &dword_0,  "arp_client_open_fd (%s): opened bpf fd %d",  v81,  (_DWORD)v82);
  uint64_t v58 = nullsub_1(*v3);
  *(_DWORD *)uint64_t v57 = 136315394;
  *(void *)(v57 + 4) = v58;
  *(_WORD *)(v57 + 12) = 1024;
  *(_DWORD *)(v57 + 14) = v13;
  __SC_log_send(7LL, v52, v53, v55);
  return 1LL;
}

void sub_41D8(uint64_t a1)
{
  v2 = sub_2A814();
  v3 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_data_add, 0LL, 0LL, v2);
  handler[0] = _NSConcreteStackBlock;
  handler[1] = 0x40000000LL;
  handler[2] = sub_636C;
  handler[3] = &unk_64B50;
  handler[4] = a1;
  dispatch_source_set_event_handler(v3, handler);
  dispatch_activate(v3);
  dispatch_source_merge_data(v3, 1uLL);
  *(void *)(a1 + 272) = v3;
}

void sub_4270(uint64_t a1)
{
  int v2 = *(_DWORD *)(a1 + 236);
  int v3 = *(_DWORD *)(a1 + 56);
  int v4 = v2 + *(_DWORD *)(a1 + 232) - v3;
  if (v4 <= 0)
  {
    int v13 = 1;
  }

  else
  {
    uint64_t v5 = *(void **)(a1 + 16);
    *(_DWORD *)(a1 + 56) = v3 + 1;
    if (*(_DWORD *)(a1 + 240)) {
      goto LABEL_3;
    }
    if (sub_505C(a1, v4 <= v2, 0LL))
    {
      if (!*(_DWORD *)(a1 + 240))
      {
        int v14 = *(_DWORD *)(a1 + 236);
        uint64_t v6 = sub_57538();
        uint64_t v7 = _SC_syslog_os_log_mapping(6LL);
        int v15 = __SC_log_enabled(6LL, v6, v7);
        if (v4 <= v14)
        {
          if (!v15) {
            goto LABEL_6;
          }
          uint64_t v22 = _os_log_pack_size(24LL);
          uint64_t v9 = (char *)&v27 - ((__chkstk_darwin(v22) + 15) & 0xFFFFFFFFFFFFFFF0LL);
          uint64_t v23 = __error();
          uint64_t v24 = _os_log_pack_fill( v9,  v22,  *v23,  &dword_0,  "ARP (%s): sending (%d of %d) arp announcements ",  v27,  v28,  v29);
          uint64_t v25 = nullsub_1(*v5);
          int v26 = *(_DWORD *)(a1 + 236);
          *(_DWORD *)uint64_t v24 = 136315650;
          *(void *)(v24 + 4) = v25;
          *(_WORD *)(v24 + 12) = 1024;
          *(_DWORD *)(v24 + 14) = v26 - v4 + 1;
          *(_WORD *)(v24 + 18) = 1024;
          *(_DWORD *)(v24 + 20) = v26;
        }

        else
        {
          if (!v15) {
            goto LABEL_6;
          }
          uint64_t v16 = _os_log_pack_size(24LL);
          uint64_t v9 = (char *)&v27 - ((__chkstk_darwin(v16) + 15) & 0xFFFFFFFFFFFFFFF0LL);
          int v17 = __error();
          uint64_t v18 = _os_log_pack_fill( v9,  v16,  *v17,  &dword_0,  "ARP (%s): sending (%d of %d) arp probes ",  v27,  v28,  v29);
          uint64_t v19 = nullsub_1(*v5);
          int v20 = *(_DWORD *)(a1 + 56);
          int v21 = *(_DWORD *)(a1 + 232);
          *(_DWORD *)uint64_t v18 = 136315650;
          *(void *)(v18 + 4) = v19;
          *(_WORD *)(v18 + 12) = 1024;
          *(_DWORD *)(v18 + 14) = v20;
          *(_WORD *)(v18 + 18) = 1024;
          *(_DWORD *)(v18 + 20) = v21;
        }

        goto LABEL_5;
      }

LABEL_3:
      uint64_t v6 = sub_57538();
      uint64_t v7 = _SC_syslog_os_log_mapping(6LL);
      if (!__SC_log_enabled(6LL, v6, v7))
      {
LABEL_6:
        timer_callout_set(*(void *)(a1 + 64), (uint64_t)sub_4270, a1, 0LL, 0LL, *(double *)(a1 + 224));
        *(_DWORD *)(a1 + 240) = 0;
        return;
      }

      uint64_t v8 = _os_log_pack_size(12LL);
      uint64_t v9 = (char *)&v27 - ((__chkstk_darwin(v8) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v10 = __error();
      uint64_t v11 = _os_log_pack_fill( v9,  v8,  *v10,  &dword_0,  "ARP (%s): skipping the first arp announcement.",  v27);
      uint64_t v12 = nullsub_1(*v5);
      *(_DWORD *)uint64_t v11 = 136315138;
      *(void *)(v11 + 4) = v12;
LABEL_5:
      __SC_log_send(6LL, v6, v7, v9);
      goto LABEL_6;
    }

    int v13 = 3;
  }

  *(_DWORD *)(a1 + 4) = v13;
  sub_41D8(a1);
}

void sub_45A8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5, int a6)
{
  uint64_t v12 = *(uint64_t **)(a1 + 16);
  sub_4718(a1);
  sub_4764(v12);
  *(_DWORD *)(a1 + 48) = a5;
  *(_DWORD *)(a1 + 52) = a6;
  *(void *)(a1 + 24) = a2;
  *(void *)(a1 + 32) = a3;
  *(void *)(a1 + 40) = a4;
  *(_BYTE *)(a1 + 96) = 0;
  *(void *)(a1 + 56) = 0LL;
  *(_DWORD *)(a1 + 240) = 0;
  if (sub_3910(a1))
  {
    *(void *)a1 = 0x400000001LL;
    sub_4270(a1);
  }

  else
  {
    *(_DWORD *)(a1 + 4) = 3;
    sub_41D8(a1);
  }

void sub_4658(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5, int a6, int a7)
{
  int v14 = *(uint64_t **)(a1 + 16);
  sub_4718(a1);
  sub_4764(v14);
  *(_DWORD *)(a1 + 48) = a5;
  *(_DWORD *)(a1 + 52) = a6;
  *(void *)(a1 + 24) = a2;
  *(void *)(a1 + 32) = a3;
  *(void *)(a1 + 40) = a4;
  *(_BYTE *)(a1 + 96) = 0;
  *(void *)(a1 + 56) = 0LL;
  if (sub_3910(a1))
  {
    if (a7) {
      int v15 = a7;
    }
    else {
      int v15 = 16;
    }
    *(_DWORD *)(a1 + 252) = v15;
    *(void *)a1 = 0x400000002LL;
    sub_48A0(a1);
  }

  else
  {
    *(_DWORD *)(a1 + 4) = 3;
    sub_41D8(a1);
  }

void sub_4718(uint64_t a1)
{
  *(_BYTE *)(a1 + 96) = 0;
  *(_DWORD *)(a1 + 4) = 0;
  *(void *)(a1 + 32) = 0LL;
  *(void *)(a1 + 40) = 0LL;
  *(void *)(a1 + 24) = 0LL;
  sub_4AE8(a1);
  timer_cancel(*(void *)(a1 + 64));
  int v2 = *(void **)(a1 + 256);
  if (v2)
  {
    free(v2);
    *(void *)(a1 + 256) = 0LL;
  }

  sub_4DF8(a1);
}

uint64_t sub_4764(uint64_t *a1)
{
  uint64_t result = sub_54E20(*a1);
  if ((_DWORD)result == 144)
  {
    int v3 = (char *)nullsub_1(*a1);
    uint64_t result = sub_57DC(v3, (uint64_t)(a1 + 9));
    if (!(_DWORD)result)
    {
      uint64_t v4 = sub_57538();
      uint64_t v5 = _SC_syslog_os_log_mapping(5LL);
      uint64_t result = __SC_log_enabled(5LL, v4, v5);
      if ((_DWORD)result)
      {
        uint64_t v6 = _os_log_pack_size(12LL);
        uint64_t v7 = (char *)&v11 - ((__chkstk_darwin(v6) + 15) & 0xFFFFFFFFFFFFFFF0LL);
        uint64_t v8 = __error();
        uint64_t v9 = _os_log_pack_fill( v7,  v6,  *v8,  &dword_0,  "arp_if_session_update_hardware_address(%s):could not retrieve firewire address",  v11);
        uint64_t v10 = nullsub_1(*a1);
        *(_DWORD *)uint64_t v9 = 136315138;
        *(void *)(v9 + 4) = v10;
        return __SC_log_send(5LL, v4, v5, v7);
      }
    }
  }

  return result;
}

void sub_48A0(uint64_t a1)
{
  int v2 = *(_DWORD *)(a1 + 56);
  if (*(_DWORD *)(a1 + 252) - v2 <= 0)
  {
    int v3 = 1;
  }

  else
  {
    *(_DWORD *)(a1 + 56) = v2 + 1;
    if (sub_505C(a1, 0, 0LL))
    {
      timer_callout_set(*(void *)(a1 + 64), (uint64_t)sub_48A0, a1, 0LL, 0LL, 1.0);
      return;
    }

    int v3 = 3;
  }

  *(_DWORD *)(a1 + 4) = v3;
  sub_41D8(a1);
}

void sub_4928(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, const void *a5, int a6)
{
  uint64_t v12 = *(uint64_t **)(a1 + 16);
  sub_4718(a1);
  sub_4764(v12);
  *(void *)(a1 + 24) = a2;
  *(void *)(a1 + 32) = a3;
  *(void *)(a1 + 40) = a4;
  *(_BYTE *)(a1 + 96) = 0;
  *(void *)(a1 + 56) = 0LL;
  if (a6 && sub_3910(a1))
  {
    int v13 = malloc(24 * a6);
    *(void *)(a1 + 256) = v13;
    memmove(v13, a5, 24 * a6);
    *(_DWORD *)(a1 + 264) = a6;
    *(void *)a1 = 0x400000003LL;
    sub_49FC(a1);
  }

  else
  {
    *(_DWORD *)(a1 + 4) = 3;
    sub_41D8(a1);
  }

void sub_49FC(uint64_t a1)
{
  uint64_t v2 = sub_34C4();
  int v3 = *(_DWORD *)(a1 + 56);
  if (*(_DWORD *)(v2 + 32) <= v3)
  {
    int v9 = 1;
LABEL_12:
    *(_DWORD *)(a1 + 4) = v9;
    sub_41D8(a1);
    return;
  }

  uint64_t v4 = v2;
  int v5 = v3 + 1;
  *(_DWORD *)(a1 + 56) = v5;
  if (*(int *)(a1 + 264) >= 1)
  {
    uint64_t v6 = 0LL;
    uint64_t v7 = 0LL;
    while (sub_505C(a1, 0, *(void *)(a1 + 256) + v6))
    {
      ++v7;
      v6 += 24LL;
      if (v7 >= *(int *)(a1 + 264))
      {
        int v5 = *(_DWORD *)(a1 + 56);
        goto LABEL_7;
      }
    }

    int v9 = 3;
    goto LABEL_12;
  }

LABEL_7:
  double v8 = (double)(2 << (v5 - 2));
  if (v5 < 2) {
    double v8 = 1.0;
  }
  timer_callout_set(*(void *)(a1 + 64), (uint64_t)sub_49FC, a1, 0LL, 0LL, *(double *)(v4 + 40) * v8);
}

  if (v13) {
    CFRelease(v13);
  }
LABEL_9:
  if (a3) {
    vm_deallocate(mach_task_self_, (vm_address_t)a3, a4);
  }
  *a6 = v14;
  return 0LL;
}

  if (a3) {
    vm_deallocate(mach_task_self_, (vm_address_t)a3, a4);
  }
  *a6 = v13;
  return 0LL;
}

  if (a3) {
    vm_deallocate(mach_task_self_, (vm_address_t)a3, a4);
  }
  *a5 = v11;
  return 0LL;
}

  *a3 = v5;
  return v4;
}

uint64_t sub_4AE0(uint64_t a1)
{
  return a1 + 96;
}

void sub_4AE8(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 8))
  {
    uint64_t v2 = *(void **)(a1 + 16);
    int v3 = *((_DWORD *)v2 + 16);
    if (v3 <= 0)
    {
      uint64_t v21 = sub_57538();
      uint64_t v22 = _SC_syslog_os_log_mapping(5LL);
      if (__SC_log_enabled(5LL, v21, v22))
      {
        uint64_t v23 = _os_log_pack_size(18LL);
        uint64_t v24 = (char *)&v29 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0LL);
        uint64_t v25 = __error();
        uint64_t v26 = _os_log_pack_fill( v24,  v23,  *v25,  &dword_0,  "arp_client_close_fd(%s): bpf open fd count is %d",  v29,  v30);
        uint64_t v27 = nullsub_1(*v2);
        int v28 = *((_DWORD *)v2 + 16);
        *(_DWORD *)uint64_t v26 = 136315394;
        *(void *)(v26 + 4) = v27;
        *(_WORD *)(v26 + 12) = 1024;
        *(_DWORD *)(v26 + 14) = v28;
        __SC_log_send(5LL, v21, v22, v24);
      }
    }

    else
    {
      *((_DWORD *)v2 + 16) = v3 - 1;
      uint64_t v4 = sub_57538();
      uint64_t v5 = _SC_syslog_os_log_mapping(7LL);
      if (__SC_log_enabled(7LL, v4, v5))
      {
        uint64_t v6 = _os_log_pack_size(18LL);
        uint64_t v7 = (char *)&v29 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0LL);
        double v8 = __error();
        uint64_t v9 = _os_log_pack_fill( v7,  v6,  *v8,  &dword_0,  "arp_client_close_fd(%s): bpf open fd count is %d",  v29,  v30);
        uint64_t v10 = nullsub_1(*v2);
        int v11 = *((_DWORD *)v2 + 16);
        *(_DWORD *)uint64_t v9 = 136315394;
        *(void *)(v9 + 4) = v10;
        *(_WORD *)(v9 + 12) = 1024;
        *(_DWORD *)(v9 + 14) = v11;
        __SC_log_send(7LL, v4, v5, v7);
      }

      *(_DWORD *)(a1 + 8) = 0;
      if (!*((_DWORD *)v2 + 16))
      {
        if (v2[7])
        {
          uint64_t v12 = sub_57538();
          uint64_t v13 = _SC_syslog_os_log_mapping(7LL);
          if (__SC_log_enabled(7LL, v12, v13))
          {
            uint64_t v14 = _os_log_pack_size(18LL);
            int v15 = (char *)&v29 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0LL);
            uint64_t v16 = __error();
            uint64_t v17 = _os_log_pack_fill( v15,  v14,  *v16,  &dword_0,  "arp_client_close_fd(%s): closing bpf fd %d",  v29,  v30);
            uint64_t v18 = nullsub_1(*v2);
            int v19 = sub_14418((unsigned int *)v2[7]);
            *(_DWORD *)uint64_t v17 = 136315394;
            *(void *)(v17 + 4) = v18;
            *(_WORD *)(v17 + 12) = 1024;
            *(_DWORD *)(v17 + 14) = v19;
            __SC_log_send(7LL, v12, v13, v15);
          }

          sub_143D4((dispatch_object_t **)v2 + 7);
        }

        int v20 = (void *)v2[5];
        if (v20)
        {
          free(v20);
          v2[5] = 0LL;
        }
      }
    }
  }

void sub_4DF8(uint64_t a1)
{
  v1 = *(dispatch_source_s **)(a1 + 272);
  if (v1)
  {
    *(void *)(a1 + 272) = 0LL;
    dispatch_source_cancel(v1);
    dispatch_release(v1);
  }

uint64_t sub_4E34(uint64_t a1, int a2)
{
  uint64_t v4 = *(uint64_t **)(a1 + 16);
  sub_4718(a1);
  sub_4764(v4);
  if (sub_3910(a1))
  {
    *(_DWORD *)(a1 + 48) = a2;
    *(_DWORD *)(a1 + 52) = a2;
    if (sub_505C(a1, 0, 0LL))
    {
      uint64_t v5 = 1LL;
    }

    else
    {
      uint64_t v13 = sub_57538();
      uint64_t v14 = _SC_syslog_os_log_mapping(5LL);
      if (__SC_log_enabled(5LL, v13, v14))
      {
        uint64_t v15 = _os_log_pack_size(12LL);
        uint64_t v16 = (char *)&v21 - ((__chkstk_darwin(v15) + 15) & 0xFFFFFFFFFFFFFFF0LL);
        uint64_t v17 = __error();
        uint64_t v18 = _os_log_pack_fill(v16, v15, *v17, &dword_0, "arp_client_defend(%s): transmit failed", v21);
        uint64_t v19 = nullsub_1(*v4);
        *(_DWORD *)uint64_t v18 = 136315138;
        *(void *)(v18 + 4) = v19;
        __SC_log_send(5LL, v13, v14, v16);
      }

      uint64_t v5 = 0LL;
    }

    sub_4AE8(a1);
  }

  else
  {
    uint64_t v6 = sub_57538();
    uint64_t v7 = _SC_syslog_os_log_mapping(5LL);
    if (__SC_log_enabled(5LL, v6, v7))
    {
      uint64_t v8 = _os_log_pack_size(12LL);
      uint64_t v9 = (char *)&v21 - ((__chkstk_darwin(v8) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v10 = __error();
      uint64_t v11 = _os_log_pack_fill(v9, v8, *v10, &dword_0, "arp_client_defend(%s): open fd failed", v21);
      uint64_t v12 = nullsub_1(*v4);
      *(_DWORD *)uint64_t v11 = 136315138;
      *(void *)(v11 + 4) = v12;
      __SC_log_send(5LL, v6, v7, v9);
    }

    return 0LL;
  }

  return v5;
}

uint64_t sub_505C(uint64_t a1, int a2, uint64_t a3)
{
  uint64_t v6 = *(void **)(a1 + 16);
  memset(v36, 0, sizeof(v36));
  int v7 = sub_54E28(*v6);
  if (v7 == 24)
  {
    LOWORD(v36[1]) = 1544;
    uint64_t v11 = *(void *)sub_54E44(*v6);
    uint64_t v12 = (int *)(a3 + 8);
    if (!a3) {
      uint64_t v12 = &dword_592E0;
    }
    *(void *)&v36[0] = *(void *)v12;
    *((void *)&v36[0] + 1) = v11;
    *(void *)((char *)&v36[1] + 2) = 0x100041000081800LL;
    *(_OWORD *)((char *)&v36[1] + 10) = *(_OWORD *)(v6 + 9);
    if (a3)
    {
      *(void *)((char *)&v36[2] + 10) = *(void *)a3;
    }

    else
    {
      if (a2 != 1 || *(_DWORD *)(a1 + 48))
      {
        *(_DWORD *)((char *)&v36[2] + 10) = *(_DWORD *)(a1 + 48);
        int v17 = *(_DWORD *)(a1 + 52);
      }

      else
      {
        int v17 = *(_DWORD *)(a1 + 52);
        *(_DWORD *)((char *)&v36[2] + 10) = v17;
      }

      *(_DWORD *)((char *)&v36[2] + 14) = v17;
    }

    int v19 = 50;
  }

  else
  {
    if (v7 != 1)
    {
      uint64_t v13 = (const char *)nullsub_1(*v6);
      snprintf((char *)(a1 + 96), 0x80uLL, "arp_client_transmit(%s): interface hardware type not yet known", v13);
      return 0LL;
    }

    WORD6(v36[0]) = 1544;
    uint64_t v8 = sub_54E44(*v6);
    __int16 v9 = *(_WORD *)(v8 + 4);
    *(_DWORD *)((char *)v36 + 6) = *(_DWORD *)v8;
    WORD5(v36[0]) = v9;
    if (a3)
    {
      LODWORD(v36[0]) = *(_DWORD *)(a3 + 8);
      __int16 v10 = *(_WORD *)(a3 + 12);
    }

    else
    {
      LODWORD(v36[0]) = -1;
      __int16 v10 = -1;
    }

    WORD2(v36[0]) = v10;
    *(void *)((char *)v36 + 14) = 0x100040600080100LL;
    uint64_t v14 = sub_54E44(*v6);
    __int16 v15 = *(_WORD *)(v14 + 4);
    *(_DWORD *)((char *)&v36[1] + 6) = *(_DWORD *)v14;
    WORD5(v36[1]) = v15;
    if (a3)
    {
      int v16 = *(_DWORD *)(a3 + 4);
      HIDWORD(v36[1]) = *(_DWORD *)a3;
      *(_DWORD *)((char *)&v36[2] + 6) = v16;
    }

    else
    {
      if (a2 != 1 || *(_DWORD *)(a1 + 48))
      {
        HIDWORD(v36[1]) = *(_DWORD *)(a1 + 48);
        int v18 = *(_DWORD *)(a1 + 52);
      }

      else
      {
        int v18 = *(_DWORD *)(a1 + 52);
        HIDWORD(v36[1]) = v18;
      }

      *(_DWORD *)((char *)&v36[2] + 6) = v18;
    }

    int v19 = 42;
  }

  int v20 = sub_14418((unsigned int *)v6[7]);
  if ((sub_4FA00(v20, v36, v19) & 0x80000000) == 0) {
    return 1LL;
  }
  uint64_t v22 = sub_57538();
  uint64_t v23 = _SC_syslog_os_log_mapping(3LL);
  if (__SC_log_enabled(3LL, v22, v23))
  {
    uint64_t v24 = _os_log_pack_size(28LL);
    uint64_t v25 = (char *)v36 - ((__chkstk_darwin(v24) + 15) & 0xFFFFFFFFFFFFFFF0LL);
    uint64_t v26 = __error();
    uint64_t v27 = _os_log_pack_fill( v25,  v24,  *v26,  &dword_0,  "arp_client_transmit(%s) failed, %s (%d)",  *(const char **)&v36[0],  *((const char **)&v36[0] + 1),  LODWORD(v36[1]));
    uint64_t v28 = nullsub_1(*v6);
    uint64_t v29 = __error();
    uint64_t v30 = strerror(*v29);
    int v31 = *__error();
    *(_DWORD *)uint64_t v27 = 136315650;
    *(void *)(v27 + 4) = v28;
    *(_WORD *)(v27 + 12) = 2080;
    *(void *)(v27 + 14) = v30;
    *(_WORD *)(v27 + 22) = 1024;
    *(_DWORD *)(v27 + 24) = v31;
    __SC_log_send(3LL, v22, v23, v25);
  }

  uint64_t v32 = (const char *)nullsub_1(*v6);
  uint64_t v33 = __error();
  uint64_t v34 = strerror(*v33);
  v35 = __error();
  snprintf((char *)(a1 + 96), 0x80uLL, "arp_client_transmit(%s) failed, %s (%d)", v32, v34, *v35);
  return 0LL;
}

uint64_t sub_53C8(BOOL (*a1)(uint64_t a1, int a2, const void *a3, int a4), uint64_t a2)
{
  uint64_t result = sub_34C4();
  uint64_t v5 = sub_54B0;
  if (a1) {
    uint64_t v5 = a1;
  }
  *(void *)(result + 64) = v5;
  uint64_t v6 = *(uint64_t **)(a2 + 16);
  if (v6) {
    uint64_t v7 = *v6;
  }
  else {
    uint64_t v7 = 0x3FD47AE147AE147BLL;
  }
  *(void *)(result + 8) = v7;
  if (*(void *)a2) {
    int v8 = **(_DWORD **)a2;
  }
  else {
    int v8 = 3;
  }
  *(_DWORD *)(result + 16) = v8;
  __int16 v9 = *(int **)(a2 + 8);
  if (v9) {
    int v10 = *v9;
  }
  else {
    int v10 = 2;
  }
  *(_DWORD *)(result + 20) = v10;
  uint64_t v11 = *(int **)(a2 + 24);
  if (v11) {
    int v12 = *v11;
  }
  else {
    int v12 = 6;
  }
  *(_DWORD *)(result + 32) = v12;
  uint64_t v13 = *(uint64_t **)(a2 + 32);
  if (v13) {
    uint64_t v14 = *v13;
  }
  else {
    uint64_t v14 = 0x3F947AE147AE147BLL;
  }
  *(void *)(result + 40) = v14;
  __int16 v15 = *(int **)(a2 + 40);
  if (v15) {
    int v16 = *v15;
  }
  else {
    int v16 = 2;
  }
  *(_DWORD *)(result + 48) = v16;
  int v17 = *(double **)(a2 + 48);
  if (v17) {
    double v18 = *v17;
  }
  else {
    double v18 = 0.75;
  }
  *(double *)(result + 56) = v18;
  return result;
}

BOOL sub_54B0(uint64_t a1, int a2, const void *a3, int a4)
{
  int v8 = (const void *)sub_54E44(a1);
  return bcmp(a3, v8, a4) == 0;
}

_OWORD *sub_5524(uint64_t a1)
{
  uint64_t v2 = sub_34C4();
  int v3 = (const char *)nullsub_1(a1);
  uint64_t v4 = v2 + 72;
  int v5 = sub_50C94(v4);
  if (v5 < 1)
  {
LABEL_5:
    int v10 = sub_54E20(a1);
    if (v10 == 144)
    {
      uint64_t v11 = (char *)nullsub_1(a1);
      if (sub_57DC(v11, (uint64_t)&v26))
      {
LABEL_9:
        int v8 = malloc(0x58uLL);
        _OWORD *v8 = 0u;
        v8[1] = 0u;
        v8[2] = 0u;
        v8[3] = 0u;
        v8[4] = 0u;
        *((void *)v8 + 10) = 0LL;
        sub_53D14((void *)v8 + 1, (uint64_t)sub_36B8, 0LL);
        *(void *)int v8 = a1;
        sub_53DA4(v4, v8);
        return v8;
      }

      uint64_t v12 = sub_57538();
      uint64_t v13 = _SC_syslog_os_log_mapping(3LL);
      if (__SC_log_enabled(3LL, v12, v13))
      {
        uint64_t v20 = _os_log_pack_size(12LL);
        __int16 v15 = (char *)&v25 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0LL);
        uint64_t v21 = __error();
        uint64_t v22 = _os_log_pack_fill( v15,  v20,  *v21,  &dword_0,  "arp_client_init(%s): could not retrieve firewire address",  v25);
        uint64_t v23 = nullsub_1(a1);
        *(_DWORD *)uint64_t v22 = 136315138;
        *(void *)(v22 + 4) = v23;
        uint64_t v19 = 3LL;
        goto LABEL_16;
      }
    }

    else
    {
      uint64_t v12 = sub_57538();
      uint64_t v13 = _SC_syslog_os_log_mapping(5LL);
      if (__SC_log_enabled(5LL, v12, v13))
      {
        uint64_t v14 = _os_log_pack_size(12LL);
        __int16 v15 = (char *)&v25 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0LL);
        int v16 = __error();
        uint64_t v17 = _os_log_pack_fill( v15,  v14,  *v16,  &dword_0,  "arp_client_init(%s): unsupported network type",  v25);
        uint64_t v18 = nullsub_1(a1);
        *(_DWORD *)uint64_t v17 = 136315138;
        *(void *)(v17 + 4) = v18;
        uint64_t v19 = 5LL;
LABEL_16:
        __SC_log_send(v19, v12, v13, v15);
      }
    }

    return 0LL;
  }

  int v6 = v5;
  uint64_t v7 = 0LL;
  while (1)
  {
    int v8 = (_OWORD *)sub_50C98(v4, v7);
    __int16 v9 = (const char *)nullsub_1(*(void *)v8);
    if (!strcmp(v9, v3)) {
      return v8;
    }
    uint64_t v7 = (v7 + 1);
    if (v6 == (_DWORD)v7) {
      goto LABEL_5;
    }
  }

uint64_t sub_57DC(char *a1, uint64_t a2)
{
  int v3 = sub_554B0(a1, 1);
  if (!v3) {
    return 0LL;
  }
  uint64_t v4 = v3;
  Value = (const __CFData *)CFDictionaryGetValue(v3, @"IOFWHWAddr");
  CFTypeID TypeID = CFDataGetTypeID();
  if (Value && CFGetTypeID(Value) == TypeID && CFDataGetLength(Value) == 16)
  {
    v9.location = 0LL;
    v9.length = 16LL;
    CFDataGetBytes(Value, v9, (UInt8 *)a2);
    *(_WORD *)(a2 + 10) = bswap32(*(unsigned __int16 *)(a2 + 10)) >> 16;
    *(_DWORD *)(a2 + 12) = bswap32(*(_DWORD *)(a2 + 12));
    uint64_t v7 = 1LL;
  }

  else
  {
    uint64_t v7 = 0LL;
  }

  CFRelease(v4);
  return v7;
}

uint64_t sub_589C(uint64_t a1)
{
  uint64_t v2 = sub_57538();
  uint64_t v3 = _SC_syslog_os_log_mapping(7LL);
  if (__SC_log_enabled(7LL, v2, v3))
  {
    uint64_t v4 = _os_log_pack_size(18LL);
    int v5 = (char *)&v10 - ((v4 + 15) & 0xFFFFFFFFFFFFFFF0LL);
    int v6 = __error();
    uint64_t v7 = _os_log_pack_fill(v5, v4, *v6, &dword_0, "%s: close(%d)", v10, v11);
    int v8 = *(_DWORD *)(a1 + 32);
    *(_DWORD *)uint64_t v7 = 136315394;
    *(void *)(v7 + 4) = "arp_client_open_fd_block_invoke";
    *(_WORD *)(v7 + 12) = 1024;
    *(_DWORD *)(v7 + 14) = v8;
    __SC_log_send(7LL, v2, v3, v5);
  }

  return close(*(_DWORD *)(a1 + 32));
}

void sub_59B4(void *a1)
{
  __str[0] = 0;
  if (!*((_DWORD *)a1 + 16))
  {
    uint64_t v57 = sub_57538();
    uint64_t v58 = _SC_syslog_os_log_mapping(5LL);
    if (__SC_log_enabled(5LL, v57, v58))
    {
      uint64_t v59 = _os_log_pack_size(2LL);
      uint64_t v60 = (char *)&v80 - ((__chkstk_darwin(v59) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v61 = __error();
      *(_WORD *)_os_log_pack_fill(v60, v59, *v61, &dword_0, "arp_if_session_read: no pending clients?") = 0;
      __SC_log_send(5LL, v57, v58, v60);
    }

    return;
  }

  uint64_t v2 = (_DWORD *)sub_34C4();
  int v97 = *v2;
  uint64_t v3 = a1 + 1;
  int v4 = sub_50C94(a1 + 1);
  uint64_t v89 = sub_54230(*a1);
  unsigned int v5 = sub_54E28(*a1);
  unsigned int v92 = v5;
  if (v5 == 24) {
    uint64_t v6 = 18LL;
  }
  else {
    uint64_t v6 = 14LL;
  }
  if (v5 == 24) {
    int v7 = 16;
  }
  else {
    int v7 = 6;
  }
  int v95 = v7;
  int v8 = sub_14418((unsigned int *)a1[7]);
  ssize_t v9 = read(v8, (void *)a1[5], *((int *)a1 + 12));
  int v94 = v4;
  if (v9 < 0)
  {
    if (*__error() != 35)
    {
      uint64_t v62 = sub_57538();
      uint64_t v63 = _SC_syslog_os_log_mapping(3LL);
      if (__SC_log_enabled(3LL, v62, v63))
      {
        uint64_t v64 = _os_log_pack_size(28LL);
        uint64_t v65 = (char *)&v80 - ((__chkstk_darwin(v64) + 15) & 0xFFFFFFFFFFFFFFF0LL);
        v66 = __error();
        uint64_t v67 = _os_log_pack_fill( v65,  v64,  *v66,  &dword_0,  "arp_if_session_read: read(%s) failed, %s (%d)",  v80,  v81,  (_DWORD)v82);
        uint64_t v68 = nullsub_1(*a1);
        v69 = __error();
        uint64_t v70 = strerror(*v69);
        int v71 = *__error();
        *(_DWORD *)uint64_t v67 = 136315650;
        *(void *)(v67 + 4) = v68;
        *(_WORD *)(v67 + 12) = 2080;
        *(void *)(v67 + 14) = v70;
        *(_WORD *)(v67 + 22) = 1024;
        *(_DWORD *)(v67 + 24) = v71;
        __SC_log_send(3LL, v62, v63, v65);
      }

      uint64_t v72 = (const char *)nullsub_1(*a1);
      v73 = __error();
      v74 = strerror(*v73);
      uint64_t v75 = __error();
      snprintf(__str, 0x80uLL, "arp_if_session_read: read(%s) failed, %s (%d)", v72, v74, *v75);
      int v76 = v94;
      if (v94 >= 1)
      {
        uint64_t v77 = 0LL;
        do
        {
          uint64_t v78 = sub_50C98(v3, v77);
          if (*(void *)(v78 + 24))
          {
            uint64_t v79 = v78;
            strncpy((char *)(v78 + 96), __str, 0x80uLL);
            *(_DWORD *)(v79 + 4) = 3;
            sub_41D8(v79);
          }

          uint64_t v77 = (v77 + 1);
        }

        while (v76 != (_DWORD)v77);
      }
    }

    return;
  }

  uint64_t v11 = v9;
  int v86 = v2;
  if (!v9) {
    return;
  }
  uint64_t v12 = a1[5];
  if (v92 == 24) {
    int v13 = 50;
  }
  else {
    int v13 = 42;
  }
  unsigned int v96 = v13;
  size_t v88 = (int)v89;
  *(void *)&__int128 v10 = 67109376LL;
  __int128 v84 = v10;
  do
  {
    uint64_t v14 = (unsigned __int16 *)(v12 + v6 + *(unsigned __int16 *)(v12 + 16));
    if (!v97) {
      goto LABEL_27;
    }
    unsigned int v15 = *v14;
    putchar(10);
    unsigned int v16 = bswap32(v14[3]);
    int v17 = HIWORD(v16) - 1;
    unsigned int v18 = (unsigned __int16)(HIWORD(v16) - 1);
    uint64_t v19 = "<unknown>";
    if (v18 <= 3) {
      uint64_t v19 = (&off_64B70)[(__int16)v17];
    }
    unsigned int v20 = bswap32(v15) >> 16;
    printf("%s type=0x%x proto=0x%x\n", v19, v20, bswap32(v14[1]) >> 16);
    if (v20 == 24)
    {
      if (*((_BYTE *)v14 + 4) == 16) {
        printf( "Sender H/W\t%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x\n",  *((unsigned __int8 *)v14 + 8),  *((unsigned __int8 *)v14 + 9),  *((unsigned __int8 *)v14 + 10),  *((unsigned __int8 *)v14 + 11),  *((unsigned __int8 *)v14 + 12),  *((unsigned __int8 *)v14 + 13),  *((unsigned __int8 *)v14 + 14),  *((unsigned __int8 *)v14 + 15));
      }
      uint64_t v27 = inet_ntop(2, v14 + 12, (char *)&v102, 0x10u);
      printf("Sender IP\t%s\n", v27);
      __int128 v26 = (int *)(v14 + 14);
      goto LABEL_25;
    }

    if (v20 == 1)
    {
      if (*((_BYTE *)v14 + 4) == 6)
      {
        int v21 = *((_DWORD *)v14 + 2);
        *(_WORD *)&v102.octet[4] = v14[6];
        *(_DWORD *)v102.octet = v21;
        uint64_t v22 = ether_ntoa(&v102);
        printf("Sender H/W\t%s\n", v22);
        unsigned __int16 v23 = v14[11];
        *(_DWORD *)v102.octet = *(_DWORD *)(v14 + 9);
        *(_WORD *)&v102.octet[4] = v23;
        uint64_t v24 = ether_ntoa(&v102);
        printf("Target H/W\t%s\n", v24);
      }

      int v100 = *(_DWORD *)(v14 + 7);
      uint64_t v25 = inet_ntop(2, &v100, (char *)&v102, 0x10u);
      printf("Sender IP\t%s\n", v25);
      int v100 = *((_DWORD *)v14 + 6);
      __int128 v26 = &v100;
LABEL_25:
      uint64_t v28 = inet_ntop(2, v26, (char *)&v102, 0x10u);
      printf("Target IP\t%s\n", v28);
    }

    fflush(__stdoutp);
LABEL_27:
    if (*(_DWORD *)(v12 + 8) < v96) {
      goto LABEL_71;
    }
    unsigned int v91 = v14[3];
    unsigned int v29 = __rev16(v91) - 3;
    if (v92 == 24)
    {
      v90 = (int *)(v14 + 12);
      v93 = (int *)(v14 + 14);
      uint64_t v30 = v14 + 4;
    }

    else
    {
      int v31 = *(_DWORD *)(v14 + 7);
      int v98 = *((_DWORD *)v14 + 6);
      int v99 = v31;
      uint64_t v30 = v14 + 4;
      v90 = &v99;
      v93 = &v98;
    }

    uint64_t v32 = (uint64_t (*)(uint64_t, void))*((void *)v86 + 8);
    uint64_t v33 = *a1;
    v87 = v30;
    int v85 = v32(v33, v92);
    if (v4 < 1) {
      goto LABEL_71;
    }
    uint64_t v34 = 0LL;
    while (1)
    {
      uint64_t v35 = sub_50C98(a1 + 1, v34);
      if (!*(void *)(v35 + 24)) {
        goto LABEL_67;
      }
      uint64_t v36 = v35;
      if (*(_DWORD *)(v35 + 4) == 2) {
        goto LABEL_67;
      }
      int v37 = *(_DWORD *)v35;
      if (*(_DWORD *)v35 == 3) {
        break;
      }
      if (v37 == 2)
      {
        int v38 = *(_DWORD *)(v35 + 52);
        if (v38 == *v90 && v91 == 512)
        {
LABEL_60:
          *(_DWORD *)(v35 + 72) = *(_DWORD *)(v35 + 48);
          *(_DWORD *)(v35 + 76) = v38;
          memmove((void *)(v35 + 80), v87, v88);
          goto LABEL_61;
        }
      }

      else if (v37 == 1 && !v85)
      {
        int v38 = *(_DWORD *)(v35 + 52);
        if (v38 == *v90 || !*v90 && *(_DWORD *)(v35 + 248) && v91 == 256 && v38 == *v93) {
          goto LABEL_60;
        }
      }

LABEL_67:
      uint64_t v34 = (v34 + 1);
      if ((_DWORD)v34 == v4) {
        goto LABEL_71;
      }
    }

    if (v91 != 512) {
      goto LABEL_67;
    }
    int v39 = *(_DWORD *)(v35 + 264);
    if (v39 < 1) {
      goto LABEL_67;
    }
    uint64_t v40 = 0LL;
    uint64_t v41 = 0LL;
    while (1)
    {
      uint64_t v42 = *(void *)(v36 + 256);
      if (*(_DWORD *)(v42 + v40) != *v93 || *(_DWORD *)(v42 + v40 + 4) != *v90) {
        goto LABEL_56;
      }
      int v39 = *(_DWORD *)(v36 + 264);
LABEL_56:
      ++v41;
      v40 += 24LL;
      int v4 = v94;
      if (v41 >= v39) {
        goto LABEL_67;
      }
    }

    __int128 v55 = *(_OWORD *)(v42 + v40);
    *(void *)(v36 + 88) = *(void *)(v42 + v40 + 16);
    *(_OWORD *)(v36 + 72) = v55;
    int v4 = v94;
LABEL_61:
    *(_DWORD *)(v36 + 4) = 2;
    if (*(_DWORD *)v36 != 1 || *(_DWORD *)(v36 + 248)) {
      goto LABEL_66;
    }
    ++*(_DWORD *)(v36 + 60);
    v43 = (const char *)sub_57538();
    uint64_t v44 = _SC_syslog_os_log_mapping(6LL);
    unsigned int v83 = v44;
    int v45 = __SC_log_enabled(6LL, v43, v44);
    uint64_t v46 = v86;
    if (v45)
    {
      uint64_t v47 = _os_log_pack_size(14LL);
      v81 = v43;
      v82 = &v80;
      uint64_t v48 = v47;
      int v49 = (char *)&v80 - ((__chkstk_darwin(v47) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      v50 = __error();
      uint64_t v51 = v48;
      uint64_t v46 = v86;
      uint64_t v52 = _os_log_pack_fill( v49,  v51,  *v50,  &dword_0,  "arp_session: encountered conflict, trying again %d (of %d)",  (_DWORD)v80,  (_DWORD)v81);
      int v53 = *(_DWORD *)(v36 + 60);
      int v54 = v46[12] + 1;
      *(_DWORD *)uint64_t v52 = v84;
      *(_DWORD *)(v52 + 4) = v53;
      *(_WORD *)(v52 + 8) = 1024;
      *(_DWORD *)(v52 + 10) = v54;
      __SC_log_send(6LL, v81, v83, v49);
    }

    if (*(_DWORD *)(v36 + 60) > v46[12])
    {
LABEL_66:
      sub_41D8(v36);
      goto LABEL_67;
    }

    timer_callout_set(*(void *)(v36 + 64), (uint64_t)sub_635C, v36, 0LL, 0LL, *((double *)v86 + 7));
LABEL_71:
    signed int v56 = (*(_DWORD *)(v12 + 8) + *(unsigned __int16 *)(v12 + 16) + 3) & 0xFFFFFFFC;
    if (!v56) {
      break;
    }
    v12 += v56;
    v11 -= v56;
  }

  while (v11 > 0);
}

    uint64_t v59 = sub_57538();
    uint64_t v60 = _SC_syslog_os_log_mapping(5LL);
    uint64_t v61 = _os_log_pack_size(2LL);
    uint64_t v62 = &v87[-((__chkstk_darwin(v61) + 15) & 0xFFFFFFFFFFFFFFF0LL)];
    uint64_t v63 = __error();
    *(_WORD *)_os_log_pack_fill( v62,  v61,  *v63,  &dword_0,  "IPConfiguration: IPv6 ConfigMethod is missing/invalid") = 0;
    __SC_log_send(5LL, v59, v60, v62);
    return 3LL;
  }

  *(_DWORD *)a2 = 513;
  *(_DWORD *)&v87[4] = 0;
  int v7 = CFDictionaryGetValue(a1, kSCPropNetIPv6Addresses);
  int v8 = CFArrayGetTypeID();
  if (v7 && CFGetTypeID(v7) != v8) {
    int v7 = 0LL;
  }
  ssize_t v9 = (const __CFArray *)CFDictionaryGetValue(a1, kSCPropNetIPv6PrefixLength);
  __int128 v10 = CFArrayGetTypeID();
  if (v9)
  {
    if (CFGetTypeID(v9) == v10) {
      uint64_t v11 = v9;
    }
    else {
      uint64_t v11 = 0LL;
    }
    if (!v7)
    {
LABEL_32:
      uint64_t v25 = sub_57538();
      __int128 v26 = _SC_syslog_os_log_mapping(5LL);
      if (__SC_log_enabled(5LL, v25, v26))
      {
        uint64_t v27 = _os_log_pack_size(12LL);
        uint64_t v28 = &v87[-((__chkstk_darwin(v27) + 15) & 0xFFFFFFFFFFFFFFF0LL)];
        unsigned int v29 = *__error();
        uint64_t v30 = _os_log_pack_fill(v28, v27, v29, &dword_0, "IPConfiguration: %s Addresses missing/invalid\n");
LABEL_49:
        uint64_t v40 = v30;
        uint64_t v41 = sub_14420(*(_DWORD *)a2);
        *(_DWORD *)uint64_t v40 = 136315138;
        *(void *)(v40 + 4) = v41;
        uint64_t v42 = v25;
LABEL_50:
        v43 = v26;
LABEL_51:
        __SC_log_send(5LL, v42, v43, v28);
        return 3LL;
      }

      return 3LL;
    }
  }

  else
  {
    uint64_t v11 = 0LL;
    if (!v7) {
      goto LABEL_32;
    }
  }

  Count = CFArrayGetCount((CFArrayRef)v7);
  if (!Count) {
    goto LABEL_32;
  }
  uint64_t v14 = Count;
  ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex((CFArrayRef)v7, 0LL);
  if ((sub_4FD78(ValueAtIndex, v90) & 1) == 0)
  {
    uint64_t v25 = sub_57538();
    __int128 v26 = _SC_syslog_os_log_mapping(5LL);
    if (__SC_log_enabled(5LL, v25, v26))
    {
      int v31 = _os_log_pack_size(12LL);
      uint64_t v28 = &v87[-((__chkstk_darwin(v31) + 15) & 0xFFFFFFFFFFFFFFF0LL)];
      uint64_t v32 = *__error();
      uint64_t v30 = _os_log_pack_fill(v28, v31, v32, &dword_0, "IPConfiguration: %s Addresses invalid");
      goto LABEL_49;
    }

    return 3LL;
  }

  if (v11)
  {
    if (v14 != CFArrayGetCount(v11))
    {
      uint64_t v25 = sub_57538();
      __int128 v26 = _SC_syslog_os_log_mapping(5LL);
      if (__SC_log_enabled(5LL, v25, v26))
      {
        uint64_t v36 = _os_log_pack_size(12LL);
        uint64_t v28 = &v87[-((__chkstk_darwin(v36) + 15) & 0xFFFFFFFFFFFFFFF0LL)];
        int v37 = *__error();
        uint64_t v30 = _os_log_pack_fill( v28,  v36,  v37,  &dword_0,  "IPConfiguration: %s Addresses/PrefixLength are different sizes");
        goto LABEL_49;
      }

      return 3LL;
    }

    unsigned int v16 = CFArrayGetValueAtIndex(v11, 0LL);
    if (!sub_213F4(v16) || !CFNumberGetValue((CFNumberRef)v16, kCFNumberIntType, &v87[4]))
    {
      uint64_t v25 = sub_57538();
      __int128 v26 = _SC_syslog_os_log_mapping(5LL);
      if (__SC_log_enabled(5LL, v25, v26))
      {
        int v38 = _os_log_pack_size(12LL);
        uint64_t v28 = &v87[-((__chkstk_darwin(v38) + 15) & 0xFFFFFFFFFFFFFFF0LL)];
        int v39 = *__error();
        uint64_t v30 = _os_log_pack_fill(v28, v38, v39, &dword_0, "IPConfiguration: %s PrefixLength invalid");
        goto LABEL_49;
      }

      return 3LL;
    }
  }

  if (v14 >= 2)
  {
    int v17 = sub_57538();
    unsigned int v18 = _SC_syslog_os_log_mapping(5LL);
    if (__SC_log_enabled(5LL, v17, v18))
    {
      uint64_t v19 = _os_log_pack_size(12LL);
      unsigned int v20 = &v87[-((__chkstk_darwin(v19) + 15) & 0xFFFFFFFFFFFFFFF0LL)];
      int v21 = __error();
      uint64_t v22 = _os_log_pack_fill( v20,  v19,  *v21,  &dword_0,  "IPConfiguration: %s multiple addresses specified - ignoring all but first",  *(const char **)v87);
      unsigned __int16 v23 = sub_14420(*(_DWORD *)a2);
      *(_DWORD *)uint64_t v22 = 136315138;
      *(void *)(v22 + 4) = v23;
      __SC_log_send(5LL, v17, v18, v20);
    }
  }

  uint64_t v24 = 0LL;
  *(_OWORD *)(a2 + 8) = v90[0];
  *(_DWORD *)(a2 + 24) = *(_DWORD *)&v87[4];
  return (uint64_t)v24;
}

void sub_635C(uint64_t a1)
{
  *(_DWORD *)(a1 + 56) = 0;
  *(_DWORD *)(a1 + 4) = 4;
  sub_4270(a1);
}

uint64_t sub_636C(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  sub_4DF8(v1);
  uint64_t v3 = *(void *)(v1 + 32);
  uint64_t v2 = *(void *)(v1 + 40);
  int v4 = *(uint64_t (**)(uint64_t, uint64_t, void *))(v1 + 24);
  *(void *)(v1 + 32) = 0LL;
  *(void *)(v1 + 40) = 0LL;
  *(void *)(v1 + 24) = 0LL;
  sub_4AE8(v1);
  timer_cancel(*(void *)(v1 + 64));
  memset(&v8[1], 0, 32);
  int v5 = *(_DWORD *)(v1 + 4);
  if (v5 != 1)
  {
    if (v5 == 2)
    {
      HIDWORD(v8[1]) = 1;
      *(_OWORD *)&v8[2] = *(_OWORD *)(v1 + 72);
      v8[4] = *(void *)(v1 + 88);
    }

    else if (v5 == 3)
    {
      LODWORD(v8[1]) = 1;
    }

    else
    {
      uint64_t v6 = (const char *)nullsub_1(**(void **)(v1 + 16));
      printf("No result for %s?\n", v6);
    }
  }

  v8[0] = v1;
  return v4(v3, v2, v8);
}

void sub_646C(uint64_t *a1)
{
}

uint64_t sub_6494(int a1)
{
  if (qword_6C118 != -1) {
    dispatch_once(&qword_6C118, &stru_64BB0);
  }
  uint64_t result = qword_6C120;
  if (qword_6C120)
  {
    uint64_t result = symptom_new();
    if (result)
    {
      uint64_t v3 = result;
      symptom_set_qualifier(result, a1, 0LL);
      return symptom_send(v3) == 0;
    }
  }

  return result;
}

void sub_6520(id a1)
{
  qword_6C120 = symptom_framework_init(104LL, "com.apple.configd");
}

_OWORD *bootp_client_init(uint64_t a1)
{
  uint64_t v2 = sub_65B4();
  uint64_t v3 = malloc(0x28uLL);
  _OWORD *v3 = 0u;
  v3[1] = 0u;
  *((void *)v3 + 4) = 0LL;
  if (sub_53DA4(v2, v3))
  {
    *(void *)uint64_t v3 = a1;
  }

  else
  {
    free(v3);
    return 0LL;
  }

  return v3;
}

uint64_t sub_65B4()
{
  uint64_t result = qword_6C130;
  if (!qword_6C130)
  {
    uint64_t v1 = malloc(0x40uLL);
    qword_6C130 = (uint64_t)v1;
    _OWORD *v1 = 0u;
    v1[1] = 0u;
    v1[2] = 0u;
    v1[3] = 0u;
    sub_53D14(v1, (uint64_t)sub_6784, 0LL);
    uint64_t v2 = timer_callout_init("bootp_session");
    uint64_t result = qword_6C130;
    *(void *)(qword_6C130 + 48) = v2;
  }

  return result;
}

void bootp_client_free(void **a1)
{
  uint64_t v1 = *a1;
  if (*a1)
  {
    uint64_t v3 = (uint64_t *)sub_65B4();
    unsigned int v4 = sub_53E84(v3, (uint64_t)v1);
    if (v4 == -1)
    {
      uint64_t v5 = sub_57538();
      uint64_t v6 = _SC_syslog_os_log_mapping(3LL);
      if (__SC_log_enabled(3LL, v5, v6))
      {
        uint64_t v7 = _os_log_pack_size(12LL);
        int v8 = (char *)&v12 - ((__chkstk_darwin(v7) + 15) & 0xFFFFFFFFFFFFFFF0LL);
        ssize_t v9 = __error();
        uint64_t v10 = _os_log_pack_fill(v8, v7, *v9, &dword_0, "bootp_client_free(%s) not in list?", v12);
        uint64_t v11 = nullsub_1(*v1);
        *(_DWORD *)uint64_t v10 = 136315138;
        *(void *)(v10 + 4) = v11;
        __SC_log_send(3LL, v5, v6, v8);
      }
    }

    else
    {
      sub_53DA8(v3, v4, 0LL);
    }

    v1[2] = 0LL;
    v1[3] = 0LL;
    v1[4] = 0LL;
    sub_6BAC(v1);
    free(v1);
    *a1 = 0LL;
  }

void sub_6784(void *a1)
{
  a1[2] = 0LL;
  a1[3] = 0LL;
  a1[4] = 0LL;
  sub_6BAC(a1);
  free(a1);
}

uint64_t bootp_client_enable_receive(void *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  a1[2] = a2;
  a1[3] = a3;
  a1[4] = a4;
  uint64_t result = sub_68D4(a1);
  if (!(_DWORD)result)
  {
    uint64_t v6 = sub_57538();
    uint64_t v7 = _SC_syslog_os_log_mapping(3LL);
    uint64_t result = __SC_log_enabled(3LL, v6, v7);
    if ((_DWORD)result)
    {
      uint64_t v8 = _os_log_pack_size(12LL);
      ssize_t v9 = (char *)&v13 - ((__chkstk_darwin(v8) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v10 = __error();
      uint64_t v11 = _os_log_pack_fill(v9, v8, *v10, &dword_0, "bootp_client_enable_receive(%s): failed", v13);
      uint64_t v12 = nullsub_1(*a1);
      *(_DWORD *)uint64_t v11 = 136315138;
      *(void *)(v11 + 4) = v12;
      return __SC_log_send(3LL, v6, v7, v9);
    }
  }

  return result;
}

uint64_t sub_68D4(void *a1)
{
  uint64_t v2 = sub_65B4();
  if (*((_DWORD *)a1 + 2)) {
    return 1LL;
  }
  uint64_t v4 = v2;
  timer_cancel(*(void *)(v2 + 48));
  ++*(_DWORD *)(v4 + 40);
  uint64_t v5 = sub_57538();
  uint64_t v6 = _SC_syslog_os_log_mapping(7LL);
  if (__SC_log_enabled(7LL, v5, v6))
  {
    uint64_t v7 = _os_log_pack_size(18LL);
    uint64_t v8 = (char *)&v23 - ((__chkstk_darwin(v7) + 15) & 0xFFFFFFFFFFFFFFF0LL);
    ssize_t v9 = __error();
    uint64_t v10 = _os_log_pack_fill(v8, v7, *v9, &dword_0, "bootp_client_open_socket (%s): refcount %d", v23, v24);
    uint64_t v11 = nullsub_1(*a1);
    int v12 = *(_DWORD *)(v4 + 40);
    *(_DWORD *)uint64_t v10 = 136315394;
    *(void *)(v10 + 4) = v11;
    *(_WORD *)(v10 + 12) = 1024;
    *(_DWORD *)(v10 + 14) = v12;
    __SC_log_send(7LL, v5, v6, v8);
  }

  uint64_t result = 1LL;
  *((_DWORD *)a1 + 2) = 1;
  if (*(int *)(v4 + 40) <= 1)
  {
    if (*(void *)(v4 + 32))
    {
      uint64_t v13 = sub_57538();
      uint64_t v14 = _SC_syslog_os_log_mapping(7LL);
      if (__SC_log_enabled(7LL, v13, v14))
      {
        uint64_t v15 = _os_log_pack_size(2LL);
        unsigned int v16 = (char *)&v23 - ((__chkstk_darwin(v15) + 15) & 0xFFFFFFFFFFFFFFF0LL);
        int v17 = __error();
        *(_WORD *)_os_log_pack_fill( v16,  v15,  *v17,  &dword_0,  "bootp_client_open_socket(): socket is still open") = 0;
        __SC_log_send(7LL, v13, v14, v16);
        return 1LL;
      }

      return 1LL;
    }

    uint64_t v18 = sub_57538();
    uint64_t v19 = _SC_syslog_os_log_mapping(5LL);
    if (__SC_log_enabled(5LL, v18, v19))
    {
      uint64_t v20 = _os_log_pack_size(2LL);
      int v21 = (char *)&v23 - ((__chkstk_darwin(v20) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v22 = __error();
      *(_WORD *)_os_log_pack_fill(v21, v20, *v22, &dword_0, "bootp_session_open_socket failed") = 0;
      __SC_log_send(5LL, v18, v19, v21);
    }

    sub_6BAC(a1);
    return 0LL;
  }

  return result;
}

uint64_t bootp_client_disable_receive(void *a1)
{
  a1[2] = 0LL;
  a1[3] = 0LL;
  a1[4] = 0LL;
  return sub_6BAC(a1);
}

uint64_t sub_6BAC(void *a1)
{
  uint64_t result = sub_65B4();
  if (*((_DWORD *)a1 + 2))
  {
    uint64_t v3 = result;
    int v4 = *(_DWORD *)(result + 40);
    if (v4 <= 0)
    {
      uint64_t v18 = sub_57538();
      uint64_t v19 = _SC_syslog_os_log_mapping(5LL);
      uint64_t result = __SC_log_enabled(5LL, v18, v19);
      if ((_DWORD)result)
      {
        uint64_t v20 = _os_log_pack_size(18LL);
        int v21 = (char *)&v26 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0LL);
        uint64_t v22 = __error();
        uint64_t v23 = _os_log_pack_fill( v21,  v20,  *v22,  &dword_0,  "bootp_client_close_socket(%s): refcount %d",  v26,  v27);
        uint64_t v24 = nullsub_1(*a1);
        int v25 = *(_DWORD *)(v3 + 40);
        *(_DWORD *)uint64_t v23 = 136315394;
        *(void *)(v23 + 4) = v24;
        *(_WORD *)(v23 + 12) = 1024;
        *(_DWORD *)(v23 + 14) = v25;
        return __SC_log_send(5LL, v18, v19, v21);
      }
    }

    else
    {
      *(_DWORD *)(result + 40) = v4 - 1;
      uint64_t v5 = sub_57538();
      uint64_t v6 = _SC_syslog_os_log_mapping(7LL);
      uint64_t result = __SC_log_enabled(7LL, v5, v6);
      if ((_DWORD)result)
      {
        uint64_t v7 = _os_log_pack_size(18LL);
        uint64_t v8 = (char *)&v26 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0LL);
        ssize_t v9 = __error();
        uint64_t v10 = _os_log_pack_fill( v8,  v7,  *v9,  &dword_0,  "bootp_client_close_socket(%s): refcount %d",  v26,  v27);
        uint64_t v11 = nullsub_1(*a1);
        int v12 = *(_DWORD *)(v3 + 40);
        *(_DWORD *)uint64_t v10 = 136315394;
        *(void *)(v10 + 4) = v11;
        *(_WORD *)(v10 + 12) = 1024;
        *(_DWORD *)(v10 + 14) = v12;
        uint64_t result = __SC_log_send(7LL, v5, v6, v8);
      }

      *((_DWORD *)a1 + 2) = 0;
      if (!*(_DWORD *)(v3 + 40))
      {
        uint64_t v13 = sub_57538();
        uint64_t v14 = _SC_syslog_os_log_mapping(7LL);
        if (__SC_log_enabled(7LL, v13, v14))
        {
          uint64_t v15 = _os_log_pack_size(2LL);
          unsigned int v16 = (char *)&v26 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0LL);
          int v17 = __error();
          *(_WORD *)_os_log_pack_fill( v16,  v15,  *v17,  &dword_0,  "bootp_client_close_socket(): scheduling delayed close") = 0;
          __SC_log_send(7LL, v13, v14, v16);
        }

        return timer_set_relative(*(void *)(v3 + 48), 1LL, 0, (uint64_t)sub_8B58, v3, 0LL, 0LL);
      }
    }
  }

  return result;
}

ssize_t bootp_client_transmit( void *a1, unsigned int a2, uint64_t a3, unsigned int a4, int a5, void *a6, uint64_t a7)
{
  uint64_t v55 = a3;
  signed int v56 = a6;
  LODWORD(v8) = a5;
  unsigned int v12 = a2 >> 8;
  unsigned __int8 v13 = BYTE2(a2);
  uint64_t v53 = HIBYTE(a2);
  uint64_t v54 = sub_65B4();
  int v52 = a2;
  unsigned int v14 = a2 & 0xFF000000 | (v13 << 16) | (v12 << 8) | a2;
  if (v14 == -1)
  {
    int v15 = 0;
    int v16 = 0;
  }

  else
  {
    if (*((_DWORD *)a1 + 2))
    {
      int v15 = 0;
    }

    else
    {
      sub_68D4(a1);
      int v15 = 1;
    }

    int v16 = sub_54F6C(*a1);
    if (v16) {
      sub_7360(a1, v16);
    }
  }

  int v50 = BYTE1(a2);
  int v51 = BYTE2(a2);
  if (byte_6C128)
  {
    LODWORD(v48) = (_DWORD)v8;
    Mutable = CFStringCreateMutable(0LL, 0LL);
    sub_514F8(Mutable, (unsigned __int8 *)v56, a7);
    uint64_t v18 = sub_57538();
    uint64_t v19 = _SC_syslog_os_log_mapping(4294967289LL);
    int v20 = __SC_log_enabled(4294967289LL, v18, v19);
    if (v16)
    {
      if (v20)
      {
        HIDWORD(v47) = v15;
        unsigned int v49 = a4;
        uint64_t v21 = _os_log_pack_size(58LL);
        uint64_t v46 = &v45;
        uint64_t v22 = (char *)&v45 - ((__chkstk_darwin(v21) + 15) & 0xFFFFFFFFFFFFFFF0LL);
        uint64_t v23 = __error();
        uint64_t v24 = _os_log_pack_fill( v22,  v21,  *v23,  &dword_0,  "[%s] Transmit %d byte packet dest %d.%d.%d.%d scope %d\n%@");
        uint64_t v25 = nullsub_1(*a1);
        *(_DWORD *)uint64_t v24 = 136316930;
        *(void *)(v24 + 4) = v25;
        *(_WORD *)(v24 + 12) = 1024;
        *(_DWORD *)(v24 + 14) = a7;
        *(_WORD *)(v24 + 18) = 1024;
        *(_DWORD *)(v24 + 20) = v52;
        *(_WORD *)(v24 + 24) = 1024;
        *(_DWORD *)(v24 + 26) = v50;
        *(_WORD *)(v24 + 30) = 1024;
        *(_DWORD *)(v24 + 32) = v51;
        *(_WORD *)(v24 + 36) = 1024;
        *(_DWORD *)(v24 + 38) = v53;
        *(_WORD *)(v24 + 42) = 1024;
        *(_DWORD *)(v24 + 44) = v16;
        *(_WORD *)(v24 + 48) = 2112;
        *(void *)(v24 + 50) = Mutable;
LABEL_16:
        __SC_log_send(4294967289LL, v18, v19, v22);
        a4 = v49;
        int v15 = HIDWORD(v47);
      }
    }

    else if (v20)
    {
      HIDWORD(v47) = v15;
      unsigned int v49 = a4;
      uint64_t v35 = _os_log_pack_size(28LL);
      uint64_t v46 = &v45;
      uint64_t v22 = (char *)&v45 - ((__chkstk_darwin(v35) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v36 = __error();
      uint64_t v37 = _os_log_pack_fill(v22, v35, *v36, &dword_0, "[%s] Transmit %d byte packet\n%@");
      uint64_t v38 = nullsub_1(*a1);
      *(_DWORD *)uint64_t v37 = 136315650;
      *(void *)(v37 + 4) = v38;
      *(_WORD *)(v37 + 12) = 1024;
      *(_DWORD *)(v37 + 14) = a7;
      *(_WORD *)(v37 + 18) = 2112;
      *(void *)(v37 + 20) = Mutable;
      goto LABEL_16;
    }

    CFRelease(Mutable);
    LOWORD(v8) = (_WORD)v48;
    goto LABEL_18;
  }

  uint64_t v26 = sub_57538();
  uint64_t v27 = _SC_syslog_os_log_mapping(6LL);
  if (__SC_log_enabled(6LL, v26, v27))
  {
    HIDWORD(v47) = v15;
    uint64_t v28 = _os_log_pack_size(58LL);
    unsigned int v49 = a4;
    uint64_t v48 = &v45;
    __int16 v29 = (__int16)v8;
    uint64_t v8 = (char *)&v45 - ((__chkstk_darwin(v28) + 15) & 0xFFFFFFFFFFFFFFF0LL);
    uint64_t v30 = __error();
    uint64_t v31 = _os_log_pack_fill( v8,  v28,  *v30,  &dword_0,  "[%s] Transmit %d byte packet xid 0x%lx to %d.%d.%d.%d [scope=%d]",  v45,  (_DWORD)v46,  v47,  (_DWORD)v48,  v49,  v51,  v53,  v54);
    uint64_t v32 = nullsub_1(*a1);
    uint64_t v33 = bswap32(*((_DWORD *)v56 + 1));
    *(_DWORD *)uint64_t v31 = 136316930;
    *(void *)(v31 + 4) = v32;
    *(_WORD *)(v31 + 12) = 1024;
    *(_DWORD *)(v31 + 14) = a7;
    *(_WORD *)(v31 + 18) = 2048;
    *(void *)(v31 + 20) = v33;
    *(_WORD *)(v31 + 28) = 1024;
    *(_DWORD *)(v31 + 30) = v52;
    *(_WORD *)(v31 + 34) = 1024;
    *(_DWORD *)(v31 + 36) = v50;
    *(_WORD *)(v31 + 40) = 1024;
    *(_DWORD *)(v31 + 42) = v51;
    *(_WORD *)(v31 + 46) = 1024;
    *(_DWORD *)(v31 + 48) = v53;
    *(_WORD *)(v31 + 52) = 1024;
    *(_DWORD *)(v31 + 54) = v16;
    int v15 = HIDWORD(v47);
    uint64_t v34 = v8;
    LOWORD(v8) = v29;
    __SC_log_send(6LL, v26, v27, v34);
    a4 = v49;
  }

LABEL_18:
  int v39 = *(unsigned int **)(v54 + 32);
  if (v39) {
    int v40 = sub_14418(v39);
  }
  else {
    int v40 = -1;
  }
  uint64_t v41 = (const char *)nullsub_1(*a1);
  int v42 = sub_54E28(*a1);
  ssize_t v43 = sub_56E04(v40, v57, v41, v42, 0LL, v14, v55, a4, (unsigned __int16)v8, v56, a7);
  if (v15) {
    sub_6BAC(a1);
  }
  if (v16) {
    sub_7360(a1, 0);
  }
  return v43;
}

    CFArrayRemoveValueAtIndex((CFMutableArrayRef)*v2, v15);
    --v14;
LABEL_19:
    int v15 = v16;
    if (v14 <= v16) {
      goto LABEL_27;
    }
  }

  if (!sub_360E0(v70, &v72))
  {
    uint64_t v41 = sub_57538();
    int v42 = _SC_syslog_os_log_mapping(5LL);
    if (__SC_log_enabled(5LL, v41, v42))
    {
      ssize_t v43 = _os_log_pack_size(22LL);
      uint64_t v44 = (char *)&v65 - ((__chkstk_darwin(v43) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      int v45 = __error();
      uint64_t v46 = _os_log_pack_fill(v44, v43, *v45, &dword_0, "%@: address %@ not present/ready");
      uint64_t v47 = *(void *)(v71 + 16);
      *(_DWORD *)uint64_t v46 = v67;
      *(void *)(v46 + 4) = v47;
      *(_WORD *)(v46 + 12) = 2112;
      *(void *)(v46 + 14) = ValueAtIndex;
      __SC_log_send(5LL, v41, v42, v44);
      uint64_t v2 = v69;
    }

    ++v16;
    goto LABEL_19;
  }

  if ((v17 & 0x80000000) == 0 || (int v17 = sub_49398(0), (v17 & 0x80000000) == 0))
  {
    uint64_t v19 = v68;
    int v20 = sub_54F6C(v68);
    uint64_t v21 = sub_54E44(v19);
    uint64_t v22 = sub_54230(v19);
    uint64_t v23 = sub_4997C(v17, v20, v21, v22, &v72);
    if (v23)
    {
      uint64_t v24 = v23;
      uint64_t v25 = sub_57538();
      uint64_t v26 = _SC_syslog_os_log_mapping(3LL);
      if (__SC_log_enabled(3LL, v25, v26))
      {
        uint64_t v27 = _os_log_pack_size(22LL);
        v66 = &v65;
        uint64_t v28 = (char *)&v65 - ((__chkstk_darwin(v27) + 15) & 0xFFFFFFFFFFFFFFF0LL);
        __int16 v29 = __error();
        uint64_t v30 = _os_log_pack_fill( v28,  v27,  *v29,  &dword_0,  "%s: failed to send neighbor advertisement, %s",  (const char *)v65,  *((const char **)&v65 + 1));
        uint64_t v31 = v17;
        uint64_t v32 = nullsub_1(v68);
        uint64_t v33 = strerror(v24);
        *(_DWORD *)uint64_t v30 = v65;
        *(void *)(v30 + 4) = v32;
        int v17 = v31;
        uint64_t v2 = v69;
        *(_WORD *)(v30 + 12) = 2080;
        *(void *)(v30 + 14) = v33;
        __SC_log_send(3LL, v25, v26, v28);
      }

      goto LABEL_18;
    }

    uint64_t v48 = sub_57538();
    unsigned int v49 = _SC_syslog_os_log_mapping(6LL);
    if (__SC_log_enabled(6LL, v48, v49))
    {
      int v50 = v17;
      int v51 = _os_log_pack_size(22LL);
      int v52 = (char *)&v65 - ((__chkstk_darwin(v51) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v53 = __error();
      uint64_t v54 = _os_log_pack_fill( v52,  v51,  *v53,  &dword_0,  "%s: sent neighbor advertisement for %s",  (const char *)v65,  *((const char **)&v65 + 1));
      uint64_t v55 = nullsub_1(v68);
      signed int v56 = inet_ntop(30, &v72, v73, 0x2Eu);
      *(_DWORD *)uint64_t v54 = v65;
      *(void *)(v54 + 4) = v55;
      *(_WORD *)(v54 + 12) = 2080;
      *(void *)(v54 + 14) = v56;
      int v17 = v50;
      __SC_log_send(6LL, v48, v49, v52);
      goto LABEL_17;
    }

    goto LABEL_18;
  }

  uint64_t v57 = sub_57538();
  uint64_t v58 = _SC_syslog_os_log_mapping(3LL);
  if (__SC_log_enabled(3LL, v57, v58))
  {
    uint64_t v59 = _os_log_pack_size(12LL);
    uint64_t v60 = (char *)&v65 - ((__chkstk_darwin(v59) + 15) & 0xFFFFFFFFFFFFFFF0LL);
    uint64_t v61 = __error();
    uint64_t v62 = _os_log_pack_fill(v60, v59, *v61, &dword_0, "can't open socket, %s", (const char *)v65);
    uint64_t v63 = __error();
    uint64_t v64 = strerror(*v63);
    *(_DWORD *)uint64_t v62 = 136315138;
    *(void *)(v62 + 4) = v64;
    __SC_log_send(3LL, v57, v58, v60);
  }

    uint64_t v35 = sub_54F6C(v6);
    uint64_t v36 = sub_3494C(&v64, v35);
    if (v36) {
      uint64_t v37 = v36;
    }
    else {
      uint64_t v37 = 128;
    }
    inet_ntop(30, &v64, v66, 0x2Eu);
    uint64_t v38 = (const char *)nullsub_1(v6);
    HIDWORD(v63) = v7;
    int v39 = v7;
    int v40 = a2;
    uint64_t v41 = a3;
    int v42 = sub_34BBC(v39, v38, &v64, 0LL, v37, 256, a2, a3);
    ssize_t v43 = sub_57538();
    uint64_t v44 = _SC_syslog_os_log_mapping(5LL);
    int v45 = __SC_log_enabled(5LL, v43, v44);
    if (v42 < 0)
    {
      if (v45)
      {
        int v50 = _os_log_pack_size(48LL);
        uint64_t v47 = (char *)&v60 - ((__chkstk_darwin(v50) + 15) & 0xFFFFFFFFFFFFFFF0LL);
        int v51 = __error();
        int v52 = _os_log_pack_fill( v47,  v50,  *v51,  &dword_0,  "%s(%s): adding %s failed, %s (%d)",  v60,  v61,  v62,  v63,  v64.i32[0]);
        uint64_t v62 = (const char *)nullsub_1(v6);
        uint64_t v53 = __error();
        uint64_t v54 = strerror(*v53);
        uint64_t v55 = *__error();
        *(_DWORD *)int v52 = 136316162;
        *(void *)(v52 + 4) = "DHCPv6ClientBoundAddress";
        *(_WORD *)(v52 + 12) = 2080;
        *(void *)(v52 + 14) = v62;
        *(_WORD *)(v52 + 22) = 2080;
        *(void *)(v52 + 24) = v66;
        *(_WORD *)(v52 + 32) = 2080;
        *(void *)(v52 + 34) = v54;
        *(_WORD *)(v52 + 42) = 1024;
        *(_DWORD *)(v52 + 44) = v55;
        goto LABEL_26;
      }
    }

    else if (v45)
    {
      uint64_t v46 = _os_log_pack_size(40LL);
      uint64_t v62 = (const char *)&v60;
      uint64_t v47 = (char *)&v60 - ((__chkstk_darwin(v46) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v48 = __error();
      unsigned int v49 = _os_log_pack_fill( v47,  v46,  *v48,  &dword_0,  "%s: set address %s/%d valid %d preferred %d",  v60,  v61,  (_DWORD)v62,  (_DWORD)v63,  v64.i32[0]);
      *(_DWORD *)unsigned int v49 = 136316162;
      *(void *)(v49 + 4) = a1;
      *(_WORD *)(v49 + 12) = 2080;
      *(void *)(v49 + 14) = v66;
      *(_WORD *)(v49 + 22) = 1024;
      *(_DWORD *)(v49 + 24) = v37;
      *(_WORD *)(v49 + 28) = 1024;
      *(_DWORD *)(v49 + 30) = v40;
      *(_WORD *)(v49 + 34) = 1024;
      *(_DWORD *)(v49 + 36) = v41;
LABEL_26:
      __SC_log_send(5LL, v43, v44, v47);
    }

    signed int v56 = *(dispatch_source_s **)(a1 + 32);
    if (v56) {
      dispatch_source_merge_data(v56, 1uLL);
    }
    char *v8 = v64;
    *(_BYTE *)(a1 + 72) = v37;
    uint64_t v57 = sub_468A4(*(void *)(a1 + 128));
    uint64_t v58 = sub_54F6C(v57);
    sub_35A4C((uint64_t)v65, v58);
    sub_41178(a1, v65);
    sub_36090((uint64_t)v65);
    uint64_t v7 = HIDWORD(v63);
    close(SHIDWORD(v63));
    return v7 >= 0;
  }

  int v20 = sub_57538();
  uint64_t v21 = _SC_syslog_os_log_mapping(5LL);
  if (__SC_log_enabled(5LL, v20, v21))
  {
    uint64_t v22 = _os_log_pack_size(38LL);
    uint64_t v23 = (char *)&v60 - ((__chkstk_darwin(v22) + 15) & 0xFFFFFFFFFFFFFFF0LL);
    uint64_t v24 = __error();
    uint64_t v25 = _os_log_pack_fill( v23,  v22,  *v24,  &dword_0,  "%s(%s): socket() failed, %s (%d)",  v60,  v61,  v62,  (_DWORD)v63);
    uint64_t v26 = nullsub_1(v6);
    uint64_t v27 = __error();
    uint64_t v28 = strerror(*v27);
    __int16 v29 = *__error();
    *(_DWORD *)uint64_t v25 = 136315906;
    *(void *)(v25 + 4) = "DHCPv6ClientBoundAddress";
    *(_WORD *)(v25 + 12) = 2080;
    *(void *)(v25 + 14) = v26;
    *(_WORD *)(v25 + 22) = 2080;
    *(void *)(v25 + 24) = v28;
    *(_WORD *)(v25 + 32) = 1024;
    *(_DWORD *)(v25 + 34) = v29;
    __SC_log_send(5LL, v20, v21, v23);
  }

  return v7 >= 0;
}

      CFRelease(v8);
    }
  }

  else
  {
    int v15 = sub_57538();
    int v16 = _SC_syslog_os_log_mapping(5LL);
    if (__SC_log_enabled(5LL, v15, v16))
    {
      int v17 = _os_log_pack_size(22LL);
      uint64_t v18 = (char *)&v38 - ((__chkstk_darwin(v17) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v19 = __error();
      int v20 = _os_log_pack_fill(v18, v17, *v19, &dword_0, "6TO4 %s: can't resolve %s", v38, v39);
      uint64_t v21 = nullsub_1(v6);
      uint64_t v22 = *(void *)(v5 + 24);
      *(_DWORD *)int v20 = 136315394;
      *(void *)(v20 + 4) = v21;
      *(_WORD *)(v20 + 12) = 2080;
      *(void *)(v20 + 14) = v22;
      __SC_log_send(5LL, v15, v16, v18);
    }
  }

uint64_t sub_7360(void *a1, int a2)
{
  HIDWORD(v27) = a2;
  int v4 = *(unsigned int **)(sub_65B4() + 32);
  if (!v4 || (int v5 = sub_14418(v4), v5 < 0))
  {
    uint64_t v20 = sub_57538();
    uint64_t v21 = _SC_syslog_os_log_mapping(3LL);
    uint64_t result = __SC_log_enabled(3LL, v20, v21);
    if (!(_DWORD)result) {
      return result;
    }
    uint64_t v22 = _os_log_pack_size(18LL);
    uint64_t v23 = (char *)&v27 - ((__chkstk_darwin(v22) + 15) & 0xFFFFFFFFFFFFFFF0LL);
    uint64_t v24 = __error();
    uint64_t v25 = _os_log_pack_fill( v23,  v22,  *v24,  &dword_0,  "bootp_client_bind_socket_to_if (%s, %d): session socket isn't open",  v27,  v28);
    uint64_t v26 = nullsub_1(*a1);
    *(_DWORD *)uint64_t v25 = 136315394;
    *(void *)(v25 + 4) = v26;
    *(_WORD *)(v25 + 12) = 1024;
    *(_DWORD *)(v25 + 14) = a2;
    uint64_t v17 = v20;
    uint64_t v18 = v21;
    uint64_t v19 = v23;
    return __SC_log_send(3LL, v17, v18, v19);
  }

  uint64_t result = setsockopt(v5, 0, 25, (char *)&v27 + 4, 4u);
  if ((result & 0x80000000) != 0)
  {
    uint64_t v7 = sub_57538();
    uint64_t v8 = _SC_syslog_os_log_mapping(3LL);
    uint64_t result = __SC_log_enabled(3LL, v7, v8);
    if ((_DWORD)result)
    {
      uint64_t v9 = _os_log_pack_size(28LL);
      uint64_t v10 = (char *)&v27 - ((__chkstk_darwin(v9) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v11 = __error();
      uint64_t v12 = _os_log_pack_fill( v10,  v9,  *v11,  &dword_0,  "bootp_client_bind_socket_to_if (%s, %d): setsockopt IP_BOUND_IF failed %s",  v27,  v28,  v29);
      uint64_t v13 = nullsub_1(*a1);
      int v14 = HIDWORD(v27);
      int v15 = __error();
      int v16 = strerror(*v15);
      *(_DWORD *)uint64_t v12 = 136315650;
      *(void *)(v12 + 4) = v13;
      *(_WORD *)(v12 + 12) = 1024;
      *(_DWORD *)(v12 + 14) = v14;
      *(_WORD *)(v12 + 18) = 2080;
      *(void *)(v12 + 20) = v16;
      uint64_t v17 = v7;
      uint64_t v18 = v8;
      uint64_t v19 = v10;
      return __SC_log_send(3LL, v17, v18, v19);
    }
  }

  return result;
}

uint64_t bootp_session_init(int a1)
{
  uint64_t result = sub_65B4();
  if (*(_WORD *)(result + 44))
  {
    uint64_t v3 = sub_57538();
    uint64_t v4 = _SC_syslog_os_log_mapping(3LL);
    uint64_t result = __SC_log_enabled(3LL, v3, v4);
    if ((_DWORD)result)
    {
      uint64_t v5 = _os_log_pack_size(18LL);
      uint64_t v6 = (char *)&v9 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v7 = __error();
      uint64_t v8 = _os_log_pack_fill(v6, v5, *v7, &dword_0, "%s: called again with %d", v9, v10);
      *(_DWORD *)uint64_t v8 = 136315394;
      *(void *)(v8 + 4) = "bootp_session_init";
      *(_WORD *)(v8 + 12) = 1024;
      *(_DWORD *)(v8 + 14) = a1;
      return __SC_log_send(3LL, v3, v4, v6);
    }
  }

  else
  {
    *(_WORD *)(result + 44) = a1;
  }

  return result;
}

uint64_t bootp_session_set_verbose(uint64_t result)
{
  byte_6C128 = result;
  return result;
}

uint64_t sub_76D4(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 57))
  {
    uint64_t v1 = sub_57538();
    uint64_t v2 = _SC_syslog_os_log_mapping(7LL);
    if (__SC_log_enabled(7LL, v1, v2))
    {
      uint64_t v3 = _os_log_pack_size(12LL);
      uint64_t v4 = (char *)&v23 - ((__chkstk_darwin(v3) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v5 = __error();
      uint64_t v6 = _os_log_pack_fill(v4, v3, *v5, &dword_0, "%s: waiting for cancel to complete", v23);
      *(_DWORD *)uint64_t v6 = 136315138;
      *(void *)(v6 + 4) = "bootp_session_open_socket";
      __SC_log_send(7LL, v1, v2, v4);
      return 1LL;
    }

    return 1LL;
  }

  int v9 = sub_797C(*(unsigned __int16 *)(a1 + 44));
  uint64_t v10 = sub_57538();
  if ((v9 & 0x80000000) == 0)
  {
    uint64_t v11 = _SC_syslog_os_log_mapping(7LL);
    if (__SC_log_enabled(7LL, v10, v11))
    {
      uint64_t v12 = _os_log_pack_size(8LL);
      uint64_t v13 = (char *)&v23 - ((__chkstk_darwin(v12) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      int v14 = __error();
      int v15 = (_DWORD *)_os_log_pack_fill( v13,  v12,  *v14,  &dword_0,  "bootp_session_open_socket(): opened socket %d",  (_DWORD)v23);
      *int v15 = 67109120;
      v15[1] = v9;
      __SC_log_send(7LL, v10, v11, v13);
    }

    sub_8044(a1, v9);
    return 1LL;
  }

  uint64_t v16 = _SC_syslog_os_log_mapping(3LL);
  uint64_t result = __SC_log_enabled(3LL, v10, v16);
  if ((_DWORD)result)
  {
    uint64_t v17 = _os_log_pack_size(12LL);
    uint64_t v18 = (char *)&v23 - ((__chkstk_darwin(v17) + 15) & 0xFFFFFFFFFFFFFFF0LL);
    uint64_t v19 = __error();
    uint64_t v20 = _os_log_pack_fill( v18,  v17,  *v19,  &dword_0,  "bootp_session_open_socket: S_open_bootp_socket() failed, %s",  v23);
    uint64_t v21 = __error();
    uint64_t v22 = strerror(*v21);
    *(_DWORD *)uint64_t v20 = 136315138;
    *(void *)(v20 + 4) = v22;
    __SC_log_send(3LL, v10, v16, v18);
    return 0LL;
  }

  return result;
}

uint64_t sub_797C(unsigned int a1)
{
  uint64_t v2 = socket(2, 2, 0);
  if ((v2 & 0x80000000) == 0)
  {
    uint64_t v3 = v2;
    *(void *)&v62.sa_len = 512LL;
    *(void *)&v62.sa_data[6] = 0LL;
    *(_WORD *)v62.sa_data = __rev16(a1);
    if (bind(v2, &v62, 0x10u))
    {
      uint64_t v4 = sub_57538();
      uint64_t v5 = _SC_syslog_os_log_mapping(3LL);
      if (__SC_log_enabled(3LL, v4, v5))
      {
        uint64_t v6 = _os_log_pack_size(18LL);
        uint64_t v7 = (char *)&v61 - ((__chkstk_darwin(v6) + 15) & 0xFFFFFFFFFFFFFFF0LL);
        uint64_t v8 = __error();
        uint64_t v9 = _os_log_pack_fill( v7,  v6,  *v8,  &dword_0,  "bootp_session: bind port %d failed, %s",  (_DWORD)v61,  *(const char **)&v62.sa_len);
        uint64_t v10 = __error();
        uint64_t v11 = strerror(*v10);
        *(_DWORD *)uint64_t v9 = 67109378;
        *(_DWORD *)(v9 + 4) = a1;
        *(_WORD *)(v9 + 8) = 2080;
        *(void *)(v9 + 10) = v11;
        uint64_t v12 = v4;
        uint64_t v13 = v5;
        int v14 = v7;
LABEL_26:
        __SC_log_send(3LL, v12, v13, v14);
      }

LABEL_27:
      close(v3);
      return 0xFFFFFFFFLL;
    }

    HIDWORD(v61) = 1;
    if (setsockopt(v3, 0xFFFF, 32, (char *)&v61 + 4, 4u) < 0)
    {
      uint64_t v47 = sub_57538();
      uint64_t v48 = _SC_syslog_os_log_mapping(3LL);
      uint64_t v49 = _os_log_pack_size(12LL);
      int v50 = (char *)&v61 - ((__chkstk_darwin(v49) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v51 = *__error();
      uint64_t v52 = _os_log_pack_fill(v50, v49, v51, &dword_0, "setsockopt SO_BROADCAST failed, %s");
    }

    else if (ioctl(v3, 0x8004667EuLL, (char *)&v61 + 4) < 0)
    {
      uint64_t v47 = sub_57538();
      uint64_t v48 = _SC_syslog_os_log_mapping(3LL);
      uint64_t v53 = _os_log_pack_size(12LL);
      int v50 = (char *)&v61 - ((__chkstk_darwin(v53) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v54 = *__error();
      uint64_t v52 = _os_log_pack_fill(v50, v53, v54, &dword_0, "ioctl FIONBIO failed, %s");
    }

    else
    {
      if ((setsockopt(v3, 0, 20, (char *)&v61 + 4, 4u) & 0x80000000) == 0)
      {
        if (setsockopt(v3, 0xFFFF, 4356, (char *)&v61 + 4, 4u) < 0)
        {
          uint64_t v23 = sub_57538();
          uint64_t v24 = _SC_syslog_os_log_mapping(3LL);
          if (__SC_log_enabled(3LL, v23, v24))
          {
            uint64_t v25 = _os_log_pack_size(12LL);
            uint64_t v26 = (char *)&v61 - ((__chkstk_darwin(v25) + 15) & 0xFFFFFFFFFFFFFFF0LL);
            uint64_t v27 = __error();
            uint64_t v28 = _os_log_pack_fill(v26, v25, *v27, &dword_0, "setsockopt(SO_RECV_ANYIF) failed, %s", v61);
            __int16 v29 = __error();
            uint64_t v30 = strerror(*v29);
            *(_DWORD *)uint64_t v28 = 136315138;
            *(void *)(v28 + 4) = v30;
            __SC_log_send(3LL, v23, v24, v26);
          }
        }

        HIDWORD(v61) = 900;
        if (setsockopt(v3, 0xFFFF, 4230, (char *)&v61 + 4, 4u) < 0)
        {
          uint64_t v31 = sub_57538();
          uint64_t v32 = _SC_syslog_os_log_mapping(3LL);
          if (__SC_log_enabled(3LL, v31, v32))
          {
            uint64_t v33 = _os_log_pack_size(12LL);
            uint64_t v34 = (char *)&v61 - ((__chkstk_darwin(v33) + 15) & 0xFFFFFFFFFFFFFFF0LL);
            uint64_t v35 = __error();
            uint64_t v36 = _os_log_pack_fill( v34,  v33,  *v35,  &dword_0,  "setsockopt(SO_TRAFFIC_CLASS) failed, %s",  v61);
            uint64_t v37 = __error();
            uint64_t v38 = strerror(*v37);
            *(_DWORD *)uint64_t v36 = 136315138;
            *(void *)(v36 + 4) = v38;
            __SC_log_send(3LL, v31, v32, v34);
          }
        }

        HIDWORD(v61) = 0;
        if (setsockopt(v3, 0xFFFF, 4352, (char *)&v61 + 4, 4u) < 0)
        {
          uint64_t v39 = sub_57538();
          uint64_t v40 = _SC_syslog_os_log_mapping(3LL);
          if (__SC_log_enabled(3LL, v39, v40))
          {
            uint64_t v41 = _os_log_pack_size(12LL);
            int v42 = (char *)&v61 - ((__chkstk_darwin(v41) + 15) & 0xFFFFFFFFFFFFFFF0LL);
            ssize_t v43 = __error();
            uint64_t v44 = _os_log_pack_fill(v42, v41, *v43, &dword_0, "setsockopt(SO_DEFUNCTOK) failed, %s", v61);
            int v45 = __error();
            uint64_t v46 = strerror(*v45);
            *(_DWORD *)uint64_t v44 = 136315138;
            *(void *)(v44 + 4) = v46;
            __SC_log_send(3LL, v39, v40, v42);
          }
        }

        return v3;
      }

      uint64_t v47 = sub_57538();
      uint64_t v48 = _SC_syslog_os_log_mapping(3LL);
      uint64_t v55 = _os_log_pack_size(12LL);
      int v50 = (char *)&v61 - ((__chkstk_darwin(v55) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v56 = *__error();
      uint64_t v52 = _os_log_pack_fill(v50, v55, v56, &dword_0, "setsockopt IP_RECVIF failed, %s");
    }

    uint64_t v57 = v52;
    uint64_t v58 = __error();
    uint64_t v59 = strerror(*v58);
    *(_DWORD *)uint64_t v57 = 136315138;
    *(void *)(v57 + 4) = v59;
    uint64_t v12 = v47;
    uint64_t v13 = v48;
    int v14 = v50;
    goto LABEL_26;
  }

  uint64_t v15 = sub_57538();
  uint64_t v16 = _SC_syslog_os_log_mapping(3LL);
  uint64_t v17 = _os_log_pack_size(12LL);
  uint64_t v18 = (char *)&v61 - ((__chkstk_darwin(v17) + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v19 = __error();
  uint64_t v20 = _os_log_pack_fill(v18, v17, *v19, &dword_0, "socket failed, %s", v61);
  uint64_t v21 = __error();
  uint64_t v22 = strerror(*v21);
  *(_DWORD *)uint64_t v20 = 136315138;
  *(void *)(v20 + 4) = v22;
  __SC_log_send(3LL, v15, v16, v18);
  return 0xFFFFFFFFLL;
}

  if (!CFArrayGetCount((CFArrayRef)*v2)) {
    sub_4FA18(v2);
  }
  if ((v17 & 0x80000000) == 0) {
    close(v17);
  }
}

void *sub_8044(uint64_t a1, int a2)
{
  uint64_t v4 = sub_57538();
  uint64_t v5 = _SC_syslog_os_log_mapping(7LL);
  if (__SC_log_enabled(7LL, v4, v5))
  {
    uint64_t v6 = _os_log_pack_size(18LL);
    uint64_t v7 = (char *)&v12[-1] - ((__chkstk_darwin(v6) + 15) & 0xFFFFFFFFFFFFFFF0LL);
    uint64_t v8 = __error();
    uint64_t v9 = _os_log_pack_fill( v7,  v6,  *v8,  &dword_0,  "%s: enabling receive on socket %d",  v11,  LODWORD(v12[0]));
    *(_DWORD *)uint64_t v9 = 136315394;
    *(void *)(v9 + 4) = "bootp_session_enable_receive";
    *(_WORD *)(v9 + 12) = 1024;
    *(_DWORD *)(v9 + 14) = a2;
    __SC_log_send(7LL, v4, v5, v7);
  }

  v12[0] = _NSConcreteStackBlock;
  v12[1] = 0x40000000LL;
  v12[2] = sub_81C0;
  v12[3] = &unk_64BD0;
  v12[4] = a1;
  int v13 = a2;
  uint64_t result = sub_141BC(a2, (uint64_t)sub_8464, a1, 0LL, v12);
  *(void *)(a1 + 32) = result;
  return result;
}

uint64_t sub_81C0(uint64_t a1)
{
  return sub_81D0(*(void *)(a1 + 32), *(unsigned int *)(a1 + 40));
}

uint64_t sub_81D0(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = sub_57538();
  uint64_t v5 = _SC_syslog_os_log_mapping(7LL);
  if (__SC_log_enabled(7LL, v4, v5))
  {
    uint64_t v6 = _os_log_pack_size(18LL);
    uint64_t v7 = (char *)&v23 - ((__chkstk_darwin(v6) + 15) & 0xFFFFFFFFFFFFFFF0LL);
    uint64_t v8 = __error();
    uint64_t v9 = _os_log_pack_fill(v7, v6, *v8, &dword_0, "%s: socket %d complete", v23, v24);
    *(_DWORD *)uint64_t v9 = 136315394;
    *(void *)(v9 + 4) = "bootp_session_fd_complete";
    *(_WORD *)(v9 + 12) = 1024;
    *(_DWORD *)(v9 + 14) = a2;
    __SC_log_send(7LL, v4, v5, v7);
  }

  *(_BYTE *)(a1 + 57) = 0;
  int v10 = *(_DWORD *)(a1 + 40);
  uint64_t v11 = sub_57538();
  uint64_t v12 = _SC_syslog_os_log_mapping(7LL);
  int v13 = __SC_log_enabled(7LL, v11, v12);
  if (v10 < 1)
  {
    if (v13)
    {
      uint64_t v19 = _os_log_pack_size(18LL);
      uint64_t v20 = (char *)&v23 - ((__chkstk_darwin(v19) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v21 = __error();
      uint64_t v22 = _os_log_pack_fill(v20, v19, *v21, &dword_0, "%s: closing socket %d", v23, v24);
      *(_DWORD *)uint64_t v22 = 136315394;
      *(void *)(v22 + 4) = "bootp_session_fd_complete";
      *(_WORD *)(v22 + 12) = 1024;
      *(_DWORD *)(v22 + 14) = a2;
      __SC_log_send(7LL, v11, v12, v20);
    }

    return close(a2);
  }

  else
  {
    if (v13)
    {
      uint64_t v14 = _os_log_pack_size(18LL);
      uint64_t v15 = (char *)&v23 - ((__chkstk_darwin(v14) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v16 = __error();
      uint64_t v17 = _os_log_pack_fill(v15, v14, *v16, &dword_0, "%s: re-enabling socket %d", v23, v24);
      *(_DWORD *)uint64_t v17 = 136315394;
      *(void *)(v17 + 4) = "bootp_session_fd_complete";
      *(_WORD *)(v17 + 12) = 1024;
      *(_DWORD *)(v17 + 14) = a2;
      __SC_log_send(7LL, v11, v12, v15);
    }

    return sub_8044(a1, a2);
  }

void sub_8464(uint64_t a1)
{
  v16.msg_name = &v20;
  v16.msg_namelen = 16;
  v16.msg_iov = (iovec *)v17;
  v16.msg_iovlen = 1;
  v16.msg_control = &v21;
  *(void *)&v16.msg_controllen = 512LL;
  v17[0] = v18;
  v17[1] = 1500LL;
  int v2 = sub_14418(*(unsigned int **)(a1 + 32));
  ssize_t v3 = recvmsg(v2, &v16, 0);
  uint64_t v4 = v3;
  if (v3 < 1)
  {
    if (v3 < 0)
    {
      int v6 = *__error();
      if (v6 != 35)
      {
        uint64_t v7 = sub_57538();
        uint64_t v8 = _SC_syslog_os_log_mapping(3LL);
        if (__SC_log_enabled(3LL, v7, v8))
        {
          uint64_t v9 = _os_log_pack_size(18LL);
          int v10 = (char *)&v15 - ((__chkstk_darwin(v9) + 15) & 0xFFFFFFFFFFFFFFF0LL);
          uint64_t v11 = __error();
          uint64_t v12 = _os_log_pack_fill( v10,  v9,  *v11,  &dword_0,  "bootp_session_read(%d): recvmsg failed, %s",  v15,  (const char *)v16.msg_name);
          int v13 = sub_14418(*(unsigned int **)(a1 + 32));
          uint64_t v14 = strerror(v6);
          *(_DWORD *)uint64_t v12 = 67109378;
          *(_DWORD *)(v12 + 4) = v13;
          *(_WORD *)(v12 + 8) = 2080;
          *(void *)(v12 + 10) = v14;
          __SC_log_send(3LL, v7, v8, v10);
        }

        if (v6 == 57) {
          sub_8A08(a1);
        }
      }
    }
  }

  else if (v16.msg_controllen >= 0xC)
  {
    msg_control = (unsigned int *)v16.msg_control;
    if (v16.msg_control)
    {
      while (msg_control[1] || msg_control[2] != 20)
      {
        msg_control = (unsigned int *)((char *)msg_control + ((*msg_control + 3LL) & 0x1FFFFFFFCLL));
      }

      if (*msg_control >= 0xD && *((unsigned __int8 *)msg_control + 17) <= 0x10uLL)
      {
        __memmove_chk(v19, msg_control + 5);
        v19[*((unsigned __int8 *)msg_control + 17)] = 0;
        sub_86C8(a1, v19, (unsigned __int8 *)&v20 + 4, v18, v4);
      }
    }
  }

void sub_86C8(uint64_t a1, const char *a2, unsigned __int8 *a3, unsigned __int8 *a4, uint64_t a5)
{
  if (a5 >= 0xEC)
  {
    uint64_t v38 = 0LL;
    uint64_t v39 = 0LL;
    uint64_t v36 = a4;
    uint64_t v37 = a5;
    sub_50F80(&v38, (uint64_t)a4, a5, 0LL);
    if (byte_6C128)
    {
      Mutable = CFStringCreateMutable(0LL, 0LL);
      sub_51588(Mutable, v36, a5, (uint64_t)&v38);
      uint64_t v10 = sub_57538();
      uint64_t v11 = _SC_syslog_os_log_mapping(4294967289LL);
      if (__SC_log_enabled(4294967289LL, v10, v11))
      {
        uint64_t v12 = _os_log_pack_size(52LL);
        uint64_t v35 = (const char *)&v35;
        int v13 = (char *)&v35 - ((__chkstk_darwin(v12) + 15) & 0xFFFFFFFFFFFFFFF0LL);
        uint64_t v14 = __error();
        uint64_t v15 = _os_log_pack_fill( v13,  v12,  *v14,  &dword_0,  "[%s] Receive %d byte packet from %d.%d.%d.%d\n%@");
        int v16 = *a3;
        int v17 = a3[1];
        int v18 = a3[2];
        int v19 = a3[3];
        *(_DWORD *)uint64_t v15 = 136316674;
        *(void *)(v15 + 4) = a2;
        *(_WORD *)(v15 + 12) = 1024;
        *(_DWORD *)(v15 + 14) = a5;
        *(_WORD *)(v15 + 18) = 1024;
        *(_DWORD *)(v15 + 20) = v16;
        *(_WORD *)(v15 + 24) = 1024;
        *(_DWORD *)(v15 + 26) = v17;
        *(_WORD *)(v15 + 30) = 1024;
        *(_DWORD *)(v15 + 32) = v18;
        *(_WORD *)(v15 + 36) = 1024;
        *(_DWORD *)(v15 + 38) = v19;
        *(_WORD *)(v15 + 42) = 2112;
        *(void *)(v15 + 44) = Mutable;
        __SC_log_send(4294967289LL, v10, v11, v13);
      }

      CFRelease(Mutable);
    }

    else
    {
      uint64_t v20 = sub_57538();
      uint64_t v21 = _SC_syslog_os_log_mapping(6LL);
      if (__SC_log_enabled(6LL, v20, v21))
      {
        uint64_t v22 = _os_log_pack_size(52LL);
        uint64_t v23 = (char *)&v35 - ((__chkstk_darwin(v22) + 15) & 0xFFFFFFFFFFFFFFF0LL);
        uint64_t v24 = __error();
        uint64_t v25 = _os_log_pack_fill( v23,  v22,  *v24,  &dword_0,  "[%s] Receive %d byte packet xid 0x%lx from %d.%d.%d.%d",  v35,  (_DWORD)v36,  v37,  (_DWORD)v38,  v39,  v40,  v41);
        uint64_t v26 = bswap32(*((_DWORD *)v36 + 1));
        int v27 = *a3;
        int v28 = a3[1];
        int v29 = a3[2];
        int v30 = a3[3];
        *(_DWORD *)uint64_t v25 = 136316674;
        *(void *)(v25 + 4) = a2;
        *(_WORD *)(v25 + 12) = 1024;
        *(_DWORD *)(v25 + 14) = a5;
        *(_WORD *)(v25 + 18) = 2048;
        *(void *)(v25 + 20) = v26;
        *(_WORD *)(v25 + 28) = 1024;
        *(_DWORD *)(v25 + 30) = v27;
        *(_WORD *)(v25 + 34) = 1024;
        *(_DWORD *)(v25 + 36) = v28;
        *(_WORD *)(v25 + 40) = 1024;
        *(_DWORD *)(v25 + 42) = v29;
        *(_WORD *)(v25 + 46) = 1024;
        *(_DWORD *)(v25 + 48) = v30;
        __SC_log_send(6LL, v20, v21, v23);
      }
    }

    if ((int)sub_50C94(a1) >= 1)
    {
      uint64_t v31 = 0LL;
      do
      {
        uint64_t v32 = (void *)sub_50C98(a1, v31);
        uint64_t v33 = (const char *)nullsub_1(*v32);
        if (!strcmp(v33, a2))
        {
          uint64_t v34 = (void (*)(void, void, unsigned __int8 **))v32[2];
          if (v34) {
            v34(v32[3], v32[4], &v36);
          }
        }

        uint64_t v31 = (v31 + 1);
      }

      while ((int)v31 < (int)sub_50C94(a1));
    }

    sub_50CA0((uint64_t)&v38);
  }

void sub_8A08(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 57))
  {
    uint64_t v1 = sub_57538();
    uint64_t v2 = _SC_syslog_os_log_mapping(3LL);
    if (__SC_log_enabled(3LL, v1, v2))
    {
      uint64_t v3 = _os_log_pack_size(12LL);
      uint64_t v4 = (char *)&v7 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v5 = __error();
      uint64_t v6 = _os_log_pack_fill(v4, v3, *v5, &dword_0, "%s: cancel is already pending?", v7);
      *(_DWORD *)uint64_t v6 = 136315138;
      *(void *)(v6 + 4) = "bootp_session_schedule_close";
      __SC_log_send(3LL, v1, v2, v4);
    }
  }

  else
  {
    *(_BYTE *)(a1 + 57) = 1;
    sub_143D4((dispatch_object_t **)(a1 + 32));
  }

void sub_8B58(uint64_t a1)
{
  if (!*(void *)(a1 + 32))
  {
    uint64_t v3 = sub_57538();
    uint64_t v4 = _SC_syslog_os_log_mapping(3LL);
    uint64_t v9 = _os_log_pack_size(2LL);
    uint64_t v6 = (char *)&v17 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0LL);
    uint64_t v10 = *__error();
    uint64_t v8 = (_WORD *)_os_log_pack_fill(v6, v9, v10, &dword_0, "bootp_session_delayed_close(): socket is already closed");
    goto LABEL_7;
  }

  int v2 = *(_DWORD *)(a1 + 40);
  uint64_t v3 = sub_57538();
  if (v2 >= 1)
  {
    uint64_t v4 = _SC_syslog_os_log_mapping(3LL);
    uint64_t v5 = _os_log_pack_size(2LL);
    uint64_t v6 = (char *)&v17 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0LL);
    uint64_t v7 = *__error();
    uint64_t v8 = (_WORD *)_os_log_pack_fill(v6, v5, v7, &dword_0, "bootp_session_delayed_close(): called when socket in use");
LABEL_7:
    _WORD *v8 = 0;
    __SC_log_send(3LL, v3, v4, v6);
    return;
  }

  uint64_t v11 = _SC_syslog_os_log_mapping(7LL);
  if (__SC_log_enabled(7LL, v3, v11))
  {
    uint64_t v12 = _os_log_pack_size(8LL);
    int v13 = (char *)&v17 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0LL);
    uint64_t v14 = __error();
    uint64_t v15 = (_DWORD *)_os_log_pack_fill( v13,  v12,  *v14,  &dword_0,  "bootp_session_delayed_close(): closing socket %d",  v17);
    int v16 = sub_14418(*(unsigned int **)(a1 + 32));
    *uint64_t v15 = 67109120;
    v15[1] = v16;
    __SC_log_send(7LL, v3, v11, v13);
  }

  sub_8A08(a1);
}

uint64_t sub_8D98(char *a1, unsigned int a2)
{
  BOOL v2 = a1 != 0LL;
  BOOL v3 = a2 != 0;
  BOOL v4 = !v2 || !v3;
  if (v2 && v3) {
    uint64_t v5 = a1;
  }
  else {
    uint64_t v5 = &byte_593A4;
  }
  if (v4) {
    uint64_t v6 = 9LL;
  }
  else {
    uint64_t v6 = a2;
  }
  off_6C000 = v5;
  dword_6C008 = v6;
  off_6C010 = v5;
  dword_6C018 = v6;
  if ((int)v6 < 1)
  {
LABEL_10:
    int v8 = 0;
  }

  else
  {
    while (1)
    {
      int v7 = *v5++;
      if (v7 == 108) {
        break;
      }
      if (!--v6) {
        goto LABEL_10;
      }
    }

    int v8 = 1;
  }

  dword_6C138 = v8;
  uint64_t v9 = sub_57538();
  uint64_t v10 = _SC_syslog_os_log_mapping(5LL);
  uint64_t result = __SC_log_enabled(5LL, v9, v10);
  if ((_DWORD)result)
  {
    uint64_t v12 = _os_log_pack_size(12LL);
    int v13 = (char *)&v17 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0LL);
    uint64_t v14 = __error();
    uint64_t v15 = _os_log_pack_fill(v13, v12, *v14, &dword_0, "ipv6_only_preferred is %s", v17);
    if (dword_6C138) {
      int v16 = "TRUE";
    }
    else {
      int v16 = "FALSE";
    }
    *(_DWORD *)uint64_t v15 = 136315138;
    *(void *)(v15 + 4) = v16;
    return __SC_log_send(5LL, v9, v10, v13);
  }

  return result;
}

uint64_t sub_8F30(int a1)
{
  if (dword_6C018 < 1) {
    return 0LL;
  }
  uint64_t v1 = off_6C010;
  uint64_t v2 = dword_6C018 - 1LL;
  do
  {
    int v3 = *v1++;
    BOOL v4 = v3 == a1;
  }

  while (v3 != a1 && v2-- != 0);
  return v4;
}

void sub_8F94(unsigned __int8 *a1, int a2)
{
  BOOL v4 = off_6C000;
  if (off_6C010) {
    BOOL v5 = off_6C010 == off_6C000;
  }
  else {
    BOOL v5 = 1;
  }
  if (!v5) {
    free(off_6C010);
  }
  size_t v6 = dword_6C008;
  dword_6C018 = dword_6C008;
  if (a1 && a2)
  {
    int v7 = (unsigned __int8 *)malloc(dword_6C008 + a2);
    if (!v7)
    {
      off_6C010 = v4;
      goto LABEL_23;
    }

    int v8 = v7;
    memmove(v7, v4, v6);
    if (a2 < 1) {
      goto LABEL_19;
    }
    uint64_t v9 = 0LL;
    int v10 = dword_6C008;
    int v11 = dword_6C008;
    do
    {
      int v12 = a1[v9];
      if (v11 < 1)
      {
LABEL_15:
        v8[v11++] = v12;
      }

      else
      {
        uint64_t v13 = v11;
        uint64_t v14 = v8;
        while (1)
        {
          int v15 = *v14++;
          if (v15 == v12) {
            break;
          }
          if (!--v13) {
            goto LABEL_15;
          }
        }
      }

      ++v9;
    }

    while (v9 != a2);
    if (v11 <= v10)
    {
LABEL_19:
      free(v8);
    }

    else
    {
      dword_6C018 = v11;
      BOOL v4 = (char *)v8;
    }
  }

  off_6C010 = v4;
  if (a1) {
LABEL_23:
  }
    free(a1);
  if (G_IPConfiguration_verbose)
  {
    Mutable = CFStringCreateMutable(0LL, 0LL);
    uint64_t v17 = dword_6C018;
    if (dword_6C018 >= 1)
    {
      uint64_t v18 = 0LL;
      int v19 = (unsigned __int8 *)off_6C010;
      do
      {
        if (v18) {
          CFStringAppendFormat(Mutable, 0LL, @", %d", v19[v18]);
        }
        else {
          CFStringAppendFormat(Mutable, 0LL, @"%d", *v19);
        }
        ++v18;
      }

      while (v17 != v18);
    }

    uint64_t v20 = sub_57538();
    uint64_t v21 = _SC_syslog_os_log_mapping(7LL);
    if (__SC_log_enabled(7LL, v20, v21))
    {
      uint64_t v22 = _os_log_pack_size(12LL);
      uint64_t v23 = (char *)&v26 - ((__chkstk_darwin(v22) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v24 = __error();
      uint64_t v25 = _os_log_pack_fill(v23, v22, *v24, &dword_0, "DHCP requested parameters = { %@ }");
      *(_DWORD *)uint64_t v25 = 138412290;
      *(void *)(v25 + 4) = Mutable;
      __SC_log_send(7LL, v20, v21, v23);
    }

    CFRelease(Mutable);
  }

uint64_t sub_9200(_DWORD *a1, int a2, unsigned __int8 *a3)
{
  uint64_t v6 = sub_14834((uint64_t)a1);
  uint64_t v7 = sub_194C4((uint64_t)a1);
  uint64_t v8 = 0LL;
  uint64_t v9 = (uint64_t *)v7;
  switch(a2)
  {
    case 0:
      if ((sub_54A84(v6) & 8) != 0) {
        return 4LL;
      }
      if (v9)
      {
        uint64_t v10 = sub_57538();
        uint64_t v11 = _SC_syslog_os_log_mapping(5LL);
        uint64_t v12 = _os_log_pack_size(12LL);
        uint64_t v13 = &__str[-((__chkstk_darwin(v12) + 15) & 0xFFFFFFFFFFFFFFF0LL) - 8];
        uint64_t v14 = *__error();
        uint64_t v15 = _os_log_pack_fill(v13, v12, v14, &dword_0, "INFORM %s: re-entering start state");
LABEL_41:
        uint64_t v38 = v15;
        uint64_t v39 = nullsub_1(v6);
        *(_DWORD *)uint64_t v38 = 136315138;
        *(void *)(v38 + 4) = v39;
        __SC_log_send(5LL, v10, v11, v13);
        return 6LL;
      }

      uint64_t v9 = (uint64_t *)malloc(0x878uLL);
      sub_194CC((uint64_t)a1, (uint64_t)v9);
      bzero(v9, 0x878uLL);
      sub_50C9C(v9 + 5);
      sub_193C8((uint64_t)a1, *(_DWORD *)a3);
      sub_193F0((uint64_t)a1, *((_DWORD *)a3 + 1));
      *((_DWORD *)v9 + 5) = sub_19400((uint64_t)a1);
      uint64_t v40 = (const char *)nullsub_1(v6);
      snprintf(__str, 0x20uLL, "inform-%s", v40);
      uint64_t v41 = timer_callout_init(__str);
      v9[199] = (uint64_t)v41;
      if (!v41)
      {
        uint64_t v44 = sub_57538();
        uint64_t v45 = _SC_syslog_os_log_mapping(5LL);
        uint64_t v52 = _os_log_pack_size(12LL);
        uint64_t v53 = &__str[-((__chkstk_darwin(v52) + 15) & 0xFFFFFFFFFFFFFFF0LL) - 8];
        uint64_t v54 = *__error();
        uint64_t v55 = _os_log_pack_fill(v53, v52, v54, &dword_0, "INFORM %s: timer_callout_init failed");
LABEL_56:
        uint64_t v60 = v55;
        uint64_t v61 = nullsub_1(v6);
        *(_DWORD *)uint64_t v60 = 136315138;
        *(void *)(v60 + 4) = v61;
        __SC_log_send(5LL, v44, v45, v53);
        goto LABEL_57;
      }

      int v42 = bootp_client_init(v6);
      v9[1] = (uint64_t)v42;
      if (!v42)
      {
        uint64_t v44 = sub_57538();
        uint64_t v45 = _SC_syslog_os_log_mapping(5LL);
        uint64_t v56 = _os_log_pack_size(12LL);
        uint64_t v53 = &__str[-((__chkstk_darwin(v56) + 15) & 0xFFFFFFFFFFFFFFF0LL) - 8];
        uint64_t v57 = *__error();
        uint64_t v55 = _os_log_pack_fill(v53, v56, v57, &dword_0, "INFORM %s: bootp_client_init failed");
        goto LABEL_56;
      }

      ssize_t v43 = sub_33B4(v6);
      uint64_t *v9 = (uint64_t)v43;
      uint64_t v44 = sub_57538();
      uint64_t v45 = _SC_syslog_os_log_mapping(5LL);
      int v46 = __SC_log_enabled(5LL, v44, v45);
      if (!v43)
      {
        if (v46)
        {
          uint64_t v58 = _os_log_pack_size(12LL);
          uint64_t v53 = &__str[-((__chkstk_darwin(v58) + 15) & 0xFFFFFFFFFFFFFFF0LL) - 8];
          uint64_t v59 = *__error();
          uint64_t v55 = _os_log_pack_fill(v53, v58, v59, &dword_0, "INFORM %s: arp_client_init failed");
          goto LABEL_56;
        }

LABEL_57:
        uint64_t v8 = 5LL;
        goto LABEL_58;
      }

      if (v46)
      {
        uint64_t v47 = _os_log_pack_size(12LL);
        uint64_t v48 = &__str[-((__chkstk_darwin(v47) + 15) & 0xFFFFFFFFFFFFFFF0LL) - 8];
        uint64_t v49 = __error();
        uint64_t v50 = _os_log_pack_fill(v48, v47, *v49, &dword_0, "INFORM %s: start", v70);
        uint64_t v51 = nullsub_1(v6);
        *(_DWORD *)uint64_t v50 = 136315138;
        *(void *)(v50 + 4) = v51;
        __SC_log_send(5LL, v44, v45, v48);
      }

      *((_DWORD *)v9 + 538) = arc4random();
LABEL_7:
      sub_9B30(a1, 0, 0LL);
      return 0LL;
    case 1:
LABEL_58:
      uint64_t v62 = sub_57538();
      uint64_t v63 = _SC_syslog_os_log_mapping(5LL);
      if (__SC_log_enabled(5LL, v62, v63))
      {
        uint64_t v64 = _os_log_pack_size(12LL);
        uint64_t v65 = &__str[-((__chkstk_darwin(v64) + 15) & 0xFFFFFFFFFFFFFFF0LL) - 8];
        v66 = __error();
        uint64_t v67 = _os_log_pack_fill(v65, v64, *v66, &dword_0, "INFORM %s: stop", v70);
        uint64_t v68 = nullsub_1(v6);
        *(_DWORD *)uint64_t v67 = 136315138;
        *(void *)(v67 + 4) = v68;
        __SC_log_send(5LL, v62, v63, v65);
      }

      if (v9)
      {
        sub_18A00((uint64_t)a1);
        if (v9[199]) {
          timer_callout_free(v9 + 199);
        }
        if (v9[1]) {
          bootp_client_free((void **)v9 + 1);
        }
        if (*v9) {
          sub_3524((uint64_t **)v9);
        }
        sub_50CA0((uint64_t)(v9 + 5));
        free(v9);
        sub_194CC((uint64_t)a1, 0LL);
      }

      return v8;
    case 3:
    case 8:
    case 11:
      if (!v7) {
        return 6LL;
      }
      *(_DWORD *)(v7 + 2156) = 0;
      if (*((_DWORD *)a3 + 1) && !*((_DWORD *)a3 + 2))
      {
        sub_9F84((uint64_t)a1);
        return 0LL;
      }

      return 0LL;
    case 4:
      sub_9FD8((uint64_t)a1);
      return 0LL;
    case 7:
      if (!v7)
      {
        uint64_t v10 = sub_57538();
        uint64_t v11 = _SC_syslog_os_log_mapping(5LL);
        if (__SC_log_enabled(5LL, v10, v11))
        {
          uint64_t v36 = _os_log_pack_size(12LL);
          uint64_t v13 = &__str[-((__chkstk_darwin(v36) + 15) & 0xFFFFFFFFFFFFFFF0LL) - 8];
          uint64_t v37 = *__error();
          uint64_t v15 = _os_log_pack_fill(v13, v36, v37, &dword_0, "INFORM %s: private data is NULL");
          goto LABEL_41;
        }

        return 6LL;
      }

      int v16 = *(unsigned int **)a3;
      *((_DWORD *)a3 + 2) = 0;
      int v17 = *v16;
      if (v17 != sub_193D8((uint64_t)a1))
      {
        uint64_t v8 = 0LL;
        *((_DWORD *)a3 + 2) = 1;
        return v8;
      }

      uint64_t v8 = v16[1];
      if (!(_DWORD)v8) {
        return v8;
      }
      if ((_DWORD)v8 != sub_19400((uint64_t)a1))
      {
        sub_193F0((uint64_t)a1, v16[1]);
        unint64_t v18 = v16[1];
        *((_DWORD *)v9 + 5) = v18;
        sub_18378((uint64_t)a1, *v16, v18, 0LL);
      }

      return 0LL;
    case 9:
      if (!v7) {
        return 6LL;
      }
      int v19 = *(_DWORD *)a3;
      if (v19 == sub_193D8((uint64_t)a1) && !sub_1665C((uint64_t)a1, (uint64_t)a3))
      {
        uint64_t v20 = (unsigned __int8 *)*((void *)a3 + 1);
        snprintf( __str,  0x80uLL,  "%d.%d.%d.%d in use by %02x:%02x:%02x:%02x:%02x:%02x",  *a3,  a3[1],  a3[2],  a3[3],  *v20,  v20[1],  v20[2],  v20[3],  v20[4],  v20[5]);
        if (!*((_DWORD *)v9 + 539)) {
          *((_DWORD *)v9 + 539) = 1;
        }
        uint64_t v21 = sub_57538();
        uint64_t v22 = _SC_syslog_os_log_mapping(5LL);
        if (__SC_log_enabled(5LL, v21, v22))
        {
          uint64_t v23 = _os_log_pack_size(22LL);
          uint64_t v24 = &__str[-((__chkstk_darwin(v23) + 15) & 0xFFFFFFFFFFFFFFF0LL) - 8];
          uint64_t v25 = __error();
          uint64_t v26 = _os_log_pack_fill(v24, v23, *v25, &dword_0, "INFORM %s: %s", v70, *(const char **)__str);
          uint64_t v27 = nullsub_1(v6);
          *(_DWORD *)uint64_t v26 = 136315394;
          *(void *)(v26 + 4) = v27;
          *(_WORD *)(v26 + 12) = 2080;
          *(void *)(v26 + 14) = __str;
          __SC_log_send(5LL, v21, v22, v24);
        }
      }

      return 0LL;
    case 13:
      if (!*((_DWORD *)v9 + 389)) {
        return 0LL;
      }
      *((void *)a3 + 4) = 0LL;
      *(_OWORD *)a3 = 0u;
      *((_OWORD *)a3 + 1) = 0u;
      int v28 = *((_DWORD *)v9 + 389);
      if (!v28) {
        return 0LL;
      }
      uint64_t v8 = 0LL;
      *(void *)a3 = v9 + 7;
      *((_DWORD *)a3 + 2) = v28;
      *((void *)a3 + 2) = v9 + 5;
      return v8;
    case 22:
      uint64_t v29 = sub_194C4((uint64_t)a1);
      Mutable = CFDictionaryCreateMutable(0LL, 0LL, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
      uint64_t v31 = Mutable;
      uint64_t v32 = *(unsigned int *)(v29 + 1584);
      else {
        uint64_t v33 = off_64BF0[v32];
      }
      sub_50228(Mutable, @"State", v33);
      if (sub_194D4((uint64_t)a1))
      {
        uint64_t v34 = sub_10DC8(v29 + 40);
        if (v34)
        {
          uint64_t v35 = v34;
          CFDictionarySetValue(v31, @"Packet", v34);
          CFRelease(v35);
        }
      }

      CFDictionarySetValue((CFMutableDictionaryRef)a3, @"INFORM", v31);
      CFRelease(v31);
      return 0LL;
    default:
      return v8;
  }

            if (sub_540BC((uint64_t *)qword_6C188, v17))
            {
              ssize_t v43 = sub_19E70(v17, 0LL);
              if (v43)
              {
                uint64_t v44 = "configured service conflicts with dynamic service";
              }
            }

            *(void *)(a1 + 16) = CFDictionaryGetValue(v23, @"_DisableUntilNeeded");
            uint64_t v45 = CFDictionaryGetValue(v23, @"ServiceID");
            int v46 = CFRetain(v45);
            uint64_t v47 = *(void *)a1 + ((uint64_t)*(int *)(a1 + 8) << 6);
            *(void *)uint64_t v47 = v46;
            uint64_t v48 = v68;
            uint64_t v49 = v69;
            uint64_t v50 = v70;
            *(void *)(v47 + 56) = v71;
            *(_OWORD *)(v47 + 40) = v50;
            *(_OWORD *)(v47 + 24) = v49;
            *(_OWORD *)(v47 + 8) = v48;
            ++*(_DWORD *)(a1 + 8);
LABEL_71:
            ++v21;
          }

          while (v21 != v18);
        }
      }
    }
  }

  else
  {
    uint64_t v67 = 0LL;
  }

  if (*(_DWORD *)(a1 + 8))
  {
    uint64_t v61 = 1LL;
  }

  else
  {
    sub_25150(a1);
    uint64_t v61 = 0LL;
  }

  sub_4FA18((const void **)&v66);
  sub_4FA18((const void **)&v67);
  return v61;
}

void sub_9B30(_DWORD *a1, int a2, uint64_t a3)
{
  uint64_t v6 = sub_14834((uint64_t)a1);
  uint64_t v7 = sub_194C4((uint64_t)a1);
  if (a2 == 6)
  {
    if (*(_DWORD *)(a3 + 8))
    {
      uint64_t v10 = sub_57538();
      uint64_t v11 = _SC_syslog_os_log_mapping(5LL);
      if (__SC_log_enabled(5LL, v10, v11))
      {
        uint64_t v12 = _os_log_pack_size(22LL);
        uint64_t v13 = &__str[-((__chkstk_darwin(v12) + 15) & 0xFFFFFFFFFFFFFFF0LL) - 8];
        uint64_t v14 = __error();
        uint64_t v15 = _os_log_pack_fill( v13,  v12,  *v14,  &dword_0,  "INFORM %s: arp probe failed, %s",  v29,  *(const char **)__str);
        uint64_t v16 = nullsub_1(v6);
        uint64_t v17 = sub_4AE0(*(void *)v7);
        *(_DWORD *)uint64_t v15 = 136315394;
        *(void *)(v15 + 4) = v16;
        *(_WORD *)(v15 + 12) = 2080;
        *(void *)(v15 + 14) = v17;
        __SC_log_send(5LL, v10, v11, v13);
      }

      sub_F818((uint64_t)a1, 6u);
      timer_callout_set(*(void *)(v7 + 1592), (uint64_t)sub_9B30, (uint64_t)a1, 0LL, 0LL, 8.0);
    }

    else if (*(_DWORD *)(a3 + 12))
    {
      unsigned int v18 = sub_193D8((uint64_t)a1);
      snprintf( __str,  0x80uLL,  "%d.%d.%d.%d in use by %02x:%02x:%02x:%02x:%02x:%02x",  v18,  BYTE1(v18),  BYTE2(v18),  HIBYTE(v18),  *(unsigned __int8 *)(a3 + 24),  *(unsigned __int8 *)(a3 + 25),  *(unsigned __int8 *)(a3 + 26),  *(unsigned __int8 *)(a3 + 27),  *(unsigned __int8 *)(a3 + 28),  *(unsigned __int8 *)(a3 + 29));
      if (!*(_DWORD *)(v7 + 2156)) {
        *(_DWORD *)(v7 + 2156) = 1;
      }
      uint64_t v19 = sub_57538();
      uint64_t v20 = _SC_syslog_os_log_mapping(5LL);
      if (__SC_log_enabled(5LL, v19, v20))
      {
        uint64_t v21 = _os_log_pack_size(22LL);
        uint64_t v22 = &__str[-((__chkstk_darwin(v21) + 15) & 0xFFFFFFFFFFFFFFF0LL) - 8];
        uint64_t v23 = __error();
        uint64_t v24 = _os_log_pack_fill(v22, v21, *v23, &dword_0, "INFORM %s: %s", v29, *(const char **)__str);
        uint64_t v25 = nullsub_1(v6);
        *(_DWORD *)uint64_t v24 = 136315394;
        *(void *)(v24 + 4) = v25;
        *(_WORD *)(v24 + 12) = 2080;
        *(void *)(v24 + 14) = __str;
        __SC_log_send(5LL, v19, v20, v22);
      }

      sub_18A00((uint64_t)a1);
      sub_F818((uint64_t)a1, 8u);
      if (dword_6C048 >= 1) {
        timer_set_relative( *(void *)(v7 + 1592),  dword_6C048,  0,  (uint64_t)sub_9B30,  (uint64_t)a1,  0LL,  0LL);
      }
    }

    else if (sub_19384((uint64_t)a1) == 1)
    {
      sub_9FD8((uint64_t)a1);
    }

    else
    {
      unsigned int v26 = *(_DWORD *)(v7 + 20);
      if (v26) {
        unint64_t v27 = v26;
      }
      else {
        unint64_t v27 = 0xFFFFFFFFLL;
      }
      unsigned int v28 = sub_193D8((uint64_t)a1);
      sub_18378((uint64_t)a1, v28, v27, 0LL);
      sub_F850(a1, 0, 0LL);
    }
  }

  else if (!a2)
  {
    sub_9F84((uint64_t)a1);
    sub_F6B8((uint64_t)a1, 1u);
    uint64_t v8 = *(void *)v7;
    int v9 = sub_193D8((uint64_t)a1);
    sub_45A8(v8, (uint64_t)sub_9B30, (uint64_t)a1, 6LL, 0, v9);
  }

void sub_9F84(uint64_t a1)
{
  uint64_t v2 = sub_194C4(a1);
  if (v2)
  {
    int v3 = (uint64_t *)v2;
    uint64_t v4 = *(void *)(v2 + 1592);
    if (v4) {
      timer_cancel(v4);
    }
    BOOL v5 = (void *)v3[1];
    if (v5) {
      bootp_client_disable_receive(v5);
    }
    sub_14528(a1, *v3);
  }

uint64_t sub_9FD8(uint64_t a1)
{
  uint64_t v2 = sub_194C4(a1);
  sub_9F84(a1);
  sub_18A00(a1);
  sub_50CA0(v2 + 40);
  sub_17FEC(a1, 0xCu);
  return sub_F6B8(a1, 0);
}

uint64_t sub_A028(_DWORD *a1, int a2, unsigned int *a3)
{
  uint64_t v6 = sub_194C4((uint64_t)a1);
  uint64_t v7 = sub_14834((uint64_t)a1);
  uint64_t v8 = 0LL;
  uint64_t v9 = v7;
  switch(a2)
  {
    case 0:
      if ((sub_54A84(v7) & 8) != 0) {
        return 4LL;
      }
      if (v6)
      {
        uint64_t v37 = sub_57538();
        uint64_t v38 = _SC_syslog_os_log_mapping(5LL);
        uint64_t v39 = _os_log_pack_size(12LL);
        uint64_t v40 = &__str[-((__chkstk_darwin(v39) + 15) & 0xFFFFFFFFFFFFFFF0LL) - 8];
        uint64_t v41 = *__error();
        uint64_t v42 = _os_log_pack_fill(v40, v39, v41, &dword_0, "DHCP %s: re-entering start state");
        goto LABEL_125;
      }

      uint64_t v6 = (uint64_t)malloc(0x930uLL);
      bzero((void *)v6, 0x930uLL);
      *(_DWORD *)(v6 + 168) = sub_54E28(v9) == 24;
      sub_50C9C((void *)(v6 + 208));
      sub_194CC((uint64_t)a1, v6);
      sub_AE1C(v6);
      sub_14F54((uint64_t)a1);
      *(_DWORD *)(v6 + 1744) = 0;
      uint64_t v67 = (const char *)nullsub_1(v9);
      snprintf(__str, 0x20uLL, "dhcp-%s", v67);
      uint64_t v68 = timer_callout_init(__str);
      *(void *)(v6 + 1760) = v68;
      if (!v68)
      {
        uint64_t v74 = sub_57538();
        uint64_t v75 = _SC_syslog_os_log_mapping(5LL);
        uint64_t v76 = _os_log_pack_size(12LL);
        uint64_t v77 = &__str[-((__chkstk_darwin(v76) + 15) & 0xFFFFFFFFFFFFFFF0LL) - 8];
        uint64_t v78 = *__error();
        uint64_t v79 = _os_log_pack_fill(v77, v76, v78, &dword_0, "DHCP %s: timer_callout_init failed");
        goto LABEL_103;
      }

      sub_17FF4((uint64_t)a1);
      v69 = bootp_client_init(v9);
      *(void *)(v6 + 16) = v69;
      if (!v69)
      {
        uint64_t v74 = sub_57538();
        uint64_t v75 = _SC_syslog_os_log_mapping(5LL);
        uint64_t v80 = _os_log_pack_size(12LL);
        uint64_t v77 = &__str[-((__chkstk_darwin(v80) + 15) & 0xFFFFFFFFFFFFFFF0LL) - 8];
        uint64_t v81 = *__error();
        uint64_t v79 = _os_log_pack_fill(v77, v80, v81, &dword_0, "DHCP %s: bootp_client_init failed");
        goto LABEL_103;
      }

      uint64_t v70 = sub_33B4(v9);
      *(void *)(v6 + 8) = v70;
      if (!v70)
      {
        uint64_t v74 = sub_57538();
        uint64_t v75 = _SC_syslog_os_log_mapping(5LL);
        uint64_t v82 = _os_log_pack_size(12LL);
        uint64_t v77 = &__str[-((__chkstk_darwin(v82) + 15) & 0xFFFFFFFFFFFFFFF0LL) - 8];
        uint64_t v83 = *__error();
        uint64_t v79 = _os_log_pack_fill(v77, v82, v83, &dword_0, "DHCP %s: arp_client_init failed");
        goto LABEL_103;
      }

      if (!a3) {
        goto LABEL_91;
      }
      size_t v71 = *a3;
      *(_DWORD *)(v6 + 32) = v71;
      uint64_t v72 = malloc(v71);
      *(void *)(v6 + 24) = v72;
      if (v72)
      {
        memmove(v72, *((const void **)a3 + 1), v71);
LABEL_91:
        sub_AE5C((uint64_t)a1);
        return 0LL;
      }

      uint64_t v74 = sub_57538();
      uint64_t v75 = _SC_syslog_os_log_mapping(5LL);
      if (__SC_log_enabled(5LL, v74, v75))
      {
        uint64_t v102 = _os_log_pack_size(12LL);
        uint64_t v77 = &__str[-((__chkstk_darwin(v102) + 15) & 0xFFFFFFFFFFFFFFF0LL) - 8];
        uint64_t v103 = *__error();
        uint64_t v79 = _os_log_pack_fill(v77, v102, v103, &dword_0, "DHCP %s: malloc client ID failed");
LABEL_103:
        uint64_t v84 = v79;
        uint64_t v85 = nullsub_1(v9);
        *(_DWORD *)uint64_t v84 = 136315138;
        *(void *)(v84 + 4) = v85;
        __SC_log_send(5LL, v74, v75, v77);
      }

LABEL_104:
      uint64_t v8 = 5LL;
LABEL_105:
      uint64_t v86 = sub_57538();
      uint64_t v87 = _SC_syslog_os_log_mapping(5LL);
      if (__SC_log_enabled(5LL, v86, v87))
      {
        uint64_t v88 = _os_log_pack_size(12LL);
        uint64_t v89 = &__str[-((__chkstk_darwin(v88) + 15) & 0xFFFFFFFFFFFFFFF0LL) - 8];
        v90 = __error();
        uint64_t v91 = _os_log_pack_fill(v89, v88, *v90, &dword_0, "DHCP %s: stop", v104);
        uint64_t v92 = nullsub_1(v9);
        *(_DWORD *)uint64_t v91 = 136315138;
        *(void *)(v91 + 4) = v92;
        __SC_log_send(5LL, v86, v87, v89);
      }

      if (!v6)
      {
        uint64_t v37 = sub_57538();
        uint64_t v38 = _SC_syslog_os_log_mapping(5LL);
        if (__SC_log_enabled(5LL, v37, v38))
        {
          uint64_t v96 = _os_log_pack_size(12LL);
          uint64_t v40 = &__str[-((__chkstk_darwin(v96) + 15) & 0xFFFFFFFFFFFFFFF0LL) - 8];
          uint64_t v97 = *__error();
          uint64_t v42 = _os_log_pack_fill(v40, v96, v97, &dword_0, "DHCP %s: already stopped");
          goto LABEL_125;
        }

        return 6LL;
      }

      if (a2 == 1) {
        sub_AFD4((uint64_t)a1);
      }
      sub_B424((uint64_t)a1, 0xCu);
      if (*(void *)(v6 + 1760)) {
        timer_callout_free((uint64_t *)(v6 + 1760));
      }
      if (*(void *)(v6 + 16)) {
        bootp_client_free((void **)(v6 + 16));
      }
      if (*(void *)(v6 + 8)) {
        sub_3524((uint64_t **)(v6 + 8));
      }
      v93 = *(void **)(v6 + 24);
      if (v93)
      {
        free(v93);
        *(void *)(v6 + 24) = 0LL;
      }

      DHCPLeaseListFree((uint64_t *)(v6 + 136));
      sub_50CA0(v6 + 208);
      int v94 = *(const void **)(v6 + 120);
      if (v94) {
        CFRelease(v94);
      }
      *(void *)(v6 + 120) = 0LL;
      int v95 = *(const void **)(v6 + 128);
      if (v95) {
        CFRelease(v95);
      }
      free((void *)v6);
      sub_194CC((uint64_t)a1, 0LL);
      return v8;
    case 1:
      goto LABEL_105;
    case 3:
    case 8:
      if (!v6) {
        return 6LL;
      }
      if (*a3 == 1)
      {
        sub_18A00((uint64_t)a1);
        sub_17FEC((uint64_t)a1, 0x13u);
        sub_18090((uint64_t)a1, 0);
      }

      uint64_t v10 = (int *)(a3 + 1);
      uint64_t v11 = a1;
      int v12 = a2;
      goto LABEL_6;
    case 4:
      sub_C270((uint64_t)a1);
      return 0LL;
    case 7:
      if (!v6)
      {
        uint64_t v37 = sub_57538();
        uint64_t v38 = _SC_syslog_os_log_mapping(5LL);
        if (__SC_log_enabled(5LL, v37, v38))
        {
          uint64_t v65 = _os_log_pack_size(12LL);
          uint64_t v40 = &__str[-((__chkstk_darwin(v65) + 15) & 0xFFFFFFFFFFFFFFF0LL) - 8];
          uint64_t v66 = *__error();
          uint64_t v42 = _os_log_pack_fill(v40, v65, v66, &dword_0, "DHCP %s: private data is NULL");
LABEL_125:
          uint64_t v98 = v42;
          uint64_t v99 = nullsub_1(v9);
          *(_DWORD *)uint64_t v98 = 136315138;
          *(void *)(v98 + 4) = v99;
          __SC_log_send(5LL, v37, v38, v40);
          return 6LL;
        }

        return 6LL;
      }

      uint64_t v13 = *(const void ***)a3;
      a3[2] = 0;
      if (v13 && (size_t v14 = *(unsigned int *)v13, (int)v14 >= 1))
      {
        uint64_t v15 = *(const void **)(v6 + 24);
        if (v15 && *(_DWORD *)(v6 + 32) == (_DWORD)v14 && !bcmp(v15, v13[1], v14)) {
          return 0LL;
        }
      }

      else if (!*(void *)(v6 + 24))
      {
        return 0LL;
      }

      uint64_t v8 = 0LL;
      a3[2] = 1;
      return v8;
    case 9:
      if (!v6) {
        return 6LL;
      }
      if (!*(_DWORD *)(v6 + 40))
      {
        int v43 = sub_194D4((uint64_t)a1);
        if (v43 == *(_DWORD *)(v6 + 1732) && *a3 == v43 && !sub_1665C((uint64_t)a1, (uint64_t)a3))
        {
          uint64_t v44 = sub_57538();
          uint64_t v45 = _SC_syslog_os_log_mapping(5LL);
          if (__SC_log_enabled(5LL, v44, v45))
          {
            uint64_t v46 = _os_log_pack_size(96LL);
            uint64_t v47 = &__str[-((__chkstk_darwin(v46) + 15) & 0xFFFFFFFFFFFFFFF0LL) - 8];
            uint64_t v48 = __error();
            uint64_t v49 = _os_log_pack_fill( v47,  v46,  *v48,  &dword_0,  "DHCP %s: %d.%d.%d.%d in use by %02x:%02x:%02x:%02x:%02x:%02x, DHCP Server %d.%d.%d.%d",  v104,  *(_DWORD *)__str,  v106,  v107,  v108,  v109,  v110,  v111,  v112,  v113,  v114,  v115,  v116,  v117,  v118);
            uint64_t v50 = nullsub_1(v9);
            uint64_t v51 = (unsigned __int8 *)*((void *)a3 + 1);
            sub_B510( v49,  v50,  *(unsigned __int8 *)(v6 + 1732),  *(unsigned __int8 *)(v6 + 1733),  *(unsigned __int8 *)(v6 + 1734),  *(unsigned __int8 *)(v6 + 1735),  *v51,  v51[1],  v51[2],  v51[3],  v51[4],  v51[5],  *(unsigned __int8 *)(v6 + 1736),  *(unsigned __int8 *)(v6 + 1737),  *(unsigned __int8 *)(v6 + 1738),  *(unsigned __int8 *)(v6 + 1739));
            __SC_log_send(5LL, v44, v45, v47);
          }

          sub_B5A8((uint64_t)a1, 0);
          sub_17FEC((uint64_t)a1, 8u);
          sub_B6E8((uint64_t)a1);
        }
      }

      return 0LL;
    case 10:
    case 12:
      if (!v6) {
        return 6LL;
      }
      if (*(_DWORD *)(v6 + 56)) {
        sub_C2E4((uint64_t)a1, (const void *)(v6 + 224), *(_DWORD *)(v6 + 1724), 1);
      }
      return 0LL;
    case 11:
      if (a3[1] && !a3[2] || sub_54E78(v9) && *a3 == 1 || !sub_54E78(v9) && !a3[3])
      {
        sub_18A00((uint64_t)a1);
        sub_17FEC((uint64_t)a1, 0x13u);
        uint64_t v11 = a1;
        int v12 = 11;
        uint64_t v10 = (int *)(a3 + 1);
LABEL_6:
        sub_BC50(v11, v12, v10);
      }

      else
      {
        double current_time = timer_get_current_time();
        if (sub_C42C((uint64_t)a1, current_time))
        {
          unsigned int v53 = *(_DWORD *)(v6 + 1744);
          if (v53 <= 8 && ((1 << v53) & 0x1A0) != 0 && sub_160CC((uint64_t)a1) && !*(_DWORD *)(v6 + 200))
          {
            if (*a3 == 2 && sub_14C20((uint64_t)a1, (uint64_t)__str))
            {
LABEL_26:
              sub_DCF8(a1, 0, __str);
            }

            else if (*(_DWORD *)(v6 + 72) != -1)
            {
              double v100 = *(double *)(v6 + 192);
              if (current_time >= v100 || (double v101 = v100 - current_time, LODWORD(v54) = dword_6C07C, v101 < (double)v54))
              {
                sub_E1B4((uint64_t)a1, 0, 0LL);
              }

              else
              {
                uint64_t v33 = (uint64_t)v101;
                uint64_t v31 = *(void *)(v6 + 1760);
                uint64_t v32 = sub_E1B4;
                int v34 = 0;
                uint64_t v35 = (uint64_t)a1;
                uint64_t v36 = 0LL;
LABEL_37:
                timer_set_relative(v31, v33, v34, (uint64_t)v32, v35, v36, 0LL);
              }
            }
          }

          else
          {
            *(_DWORD *)__str = *(_DWORD *)(v6 + 1732);
            sub_CF80(a1, 0, (uint64_t)__str);
          }
        }

        else
        {
          sub_C4A4(a1, 0, 0LL);
        }
      }

      return 0LL;
    case 13:
      unsigned int v16 = *(_DWORD *)(v6 + 1724);
      if (!v16) {
        return 0LL;
      }
      uint64_t v8 = 0LL;
      *(void *)a3 = v6 + 224;
      a3[2] = v16;
      *((void *)a3 + 2) = v6 + 208;
      *((void *)a3 + 3) = *(void *)(v6 + 80);
      *((void *)a3 + 4) = *(void *)(v6 + 64);
      return v8;
    case 16:
      unsigned int v17 = *(_DWORD *)(v6 + 1744);
      BOOL v18 = v17 > 8;
      int v19 = (1 << v17) & 0x1A0;
      BOOL v20 = v18 || v19 == 0;
      return 0LL;
    case 17:
      sub_E9DC((uint64_t)a1, a3);
      return 0LL;
    case 20:
      uint64_t v21 = sub_57538();
      uint64_t v22 = _SC_syslog_os_log_mapping(5LL);
      if (__SC_log_enabled(5LL, v21, v22))
      {
        uint64_t v23 = _os_log_pack_size(22LL);
        uint64_t v24 = &__str[-((__chkstk_darwin(v23) + 15) & 0xFFFFFFFFFFFFFFF0LL) - 8];
        uint64_t v25 = __error();
        uint64_t v26 = _os_log_pack_fill(v24, v23, *v25, &dword_0, "DHCP %s: ForgetSSID %@");
        uint64_t v27 = nullsub_1(v9);
        *(_DWORD *)uint64_t v26 = 136315394;
        *(void *)(v26 + 4) = v27;
        *(_WORD *)(v26 + 12) = 2112;
        *(void *)(v26 + 14) = a3;
        __SC_log_send(5LL, v21, v22, v24);
      }

      DHCPLeaseListRemoveLeaseForWiFi((uint64_t *)(v6 + 136), a3, 0LL);
      unsigned int v28 = *(const void **)(v6 + 120);
      if (!v28 || !CFEqual(v28, a3)) {
        return 0LL;
      }
      sub_AFD4((uint64_t)a1);
      sub_18A00((uint64_t)a1);
      sub_17FEC((uint64_t)a1, 0xBu);
      sub_50CA0(v6 + 208);
      uint64_t v29 = *(const void **)(v6 + 120);
      if (v29) {
        CFRelease(v29);
      }
      *(void *)(v6 + 120) = 0LL;
      int v30 = *(const void **)(v6 + 128);
      if (v30) {
        CFRelease(v30);
      }
      *(void *)(v6 + 128) = 0LL;
      sub_150A4((uint64_t)a1, 0);
      uint64_t v31 = *(void *)(v6 + 1760);
      uint64_t v32 = sub_F3C0;
      uint64_t v33 = 0LL;
      int v34 = 500000;
      uint64_t v35 = (uint64_t)a1;
      uint64_t v36 = 20LL;
      goto LABEL_37;
    case 22:
      uint64_t v55 = sub_194C4((uint64_t)a1);
      Mutable = CFDictionaryCreateMutable(0LL, 0LL, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
      uint64_t v57 = Mutable;
      uint64_t v58 = *(unsigned int *)(v55 + 1744);
      else {
        uint64_t v59 = off_64C18[v58];
      }
      sub_50228(Mutable, @"State", v59);
      if (sub_194D4((uint64_t)a1) && *(_DWORD *)(v55 + 56))
      {
        uint64_t v60 = sub_10DC8(v55 + 208);
        if (v60)
        {
          uint64_t v61 = v60;
          CFDictionarySetValue(v57, @"Packet", v60);
          CFRelease(v61);
        }

        sub_5027C(v57, @"LeaseStartTime", *(CFAbsoluteTime *)(v55 + 80));
        if (*(_DWORD *)(v55 + 72) == -1) {
          CFDictionarySetValue(v57, @"LeaseIsInfinite", kCFBooleanTrue);
        }
        else {
          sub_5027C(v57, @"LeaseExpirationTime", *(CFAbsoluteTime *)(v55 + 64));
        }
      }

      else
      {
        unsigned int v62 = *(_DWORD *)(v55 + 1744);
        if (v62 <= 6 && ((1 << v62) & 0x58) != 0 && *(double *)(v55 + 1776) != 0.0)
        {
          double v63 = timer_get_current_time();
          double v64 = *(double *)(v55 + 1776);
          if (v63 > v64) {
            sub_502C4(v57, @"ElapsedTime", (unint64_t)(v63 - v64));
          }
        }
      }

      CFDictionarySetValue((CFMutableDictionaryRef)a3, @"DHCP", v57);
      CFRelease(v57);
      return 0LL;
    default:
      return v8;
  }

void sub_AE1C(uint64_t a1)
{
  *(_DWORD *)(a1 + 56) = 0;
  uint64_t v2 = *(const void **)(a1 + 120);
  if (v2) {
    CFRelease(v2);
  }
  *(void *)(a1 + 120) = 0LL;
  int v3 = *(const void **)(a1 + 128);
  if (v3) {
    CFRelease(v3);
  }
  *(void *)(a1 + 128) = 0LL;
}

uint64_t sub_AE5C(uint64_t a1)
{
  uint64_t v2 = sub_194C4(a1);
  uint64_t v3 = sub_14834(a1);
  uint64_t v4 = sub_57538();
  uint64_t v5 = _SC_syslog_os_log_mapping(5LL);
  if (__SC_log_enabled(5LL, v4, v5))
  {
    uint64_t v6 = _os_log_pack_size(12LL);
    uint64_t v7 = (char *)&v12 - ((__chkstk_darwin(v6) + 15) & 0xFFFFFFFFFFFFFFF0LL);
    uint64_t v8 = __error();
    uint64_t v9 = _os_log_pack_fill(v7, v6, *v8, &dword_0, "DHCP %s: start", v12);
    uint64_t v10 = nullsub_1(v3);
    *(_DWORD *)uint64_t v9 = 136315138;
    *(void *)(v9 + 4) = v10;
    __SC_log_send(5LL, v4, v5, v7);
  }

  DHCPLeaseListInit((void *)(v2 + 136));
  *(_DWORD *)(v2 + 2332) = arc4random();
  return timer_set_relative(*(void *)(v2 + 1760), 0LL, 0, (uint64_t)sub_10FF8, a1, 0LL, 0LL);
}

unint64_t sub_AFD4(uint64_t a1)
{
  uint64_t v2 = sub_14834(a1);
  unint64_t result = sub_194C4(a1);
  if (*(_DWORD *)(result + 56))
  {
    uint64_t v4 = result;
    uint64_t v5 = sub_57538();
    uint64_t v6 = _SC_syslog_os_log_mapping(5LL);
    if (__SC_log_enabled(5LL, v5, v6))
    {
      uint64_t v7 = _os_log_pack_size(12LL);
      uint64_t v8 = (char *)&v32[-1] - ((__chkstk_darwin(v7) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v9 = __error();
      uint64_t v10 = _os_log_pack_fill(v8, v7, *v9, &dword_0, "DHCP %s: RELEASE", v31);
      uint64_t v11 = nullsub_1(v2);
      *(_DWORD *)uint64_t v10 = 136315138;
      *(void *)(v10 + 4) = v11;
      __SC_log_send(5LL, v5, v6, v8);
    }

    sub_B5A8(a1, 0);
    sub_AE1C(v4);
    sub_14F54(a1);
    sub_11718(a1);
    unint64_t result = sub_19384(a1);
    if (HIDWORD(result) || !(_DWORD)result)
    {
      int v12 = (const void *)sub_54E44(v2);
      unsigned __int8 v13 = sub_54E28(v2);
      unsigned __int8 v14 = sub_54230(v2);
      unint64_t result = (unint64_t)sub_10010( (char *)(v4 + 1784),  7,  v12,  v13,  v14,  *(const void **)(v4 + 24),  *(_DWORD *)(v4 + 32),  0,  (uint64_t *)v32);
      *(void *)(v4 + 176) = result;
      if (result)
      {
        unsigned int v15 = *(_DWORD *)(v4 + 2332) + 1;
        *(_DWORD *)(v4 + 2332) = v15;
        *(_DWORD *)(result + 4) = bswap32(v15);
        *(_DWORD *)(result + 12) = *(_DWORD *)(v4 + 1732);
        if (sub_512B8((uint64_t)v32, 54, 4, (void *)(v4 + 1736)))
        {
          uint64_t v16 = sub_57538();
          uint64_t v17 = _SC_syslog_os_log_mapping(5LL);
          unint64_t result = __SC_log_enabled(5LL, v16, v17);
          if (!(_DWORD)result) {
            return result;
          }
          uint64_t v18 = _os_log_pack_size(22LL);
          int v19 = (char *)&v32[-1] - ((__chkstk_darwin(v18) + 15) & 0xFFFFFFFFFFFFFFF0LL);
          BOOL v20 = __error();
          uint64_t v21 = _os_log_pack_fill( v19,  v18,  *v20,  &dword_0,  "DHCP %s: RELEASE couldn't add server ip, %s",  v31,  v32[0]);
          uint64_t v22 = nullsub_1(v2);
          uint64_t v23 = sub_514D0((uint64_t *)v32);
          *(_DWORD *)uint64_t v21 = 136315394;
          *(void *)(v21 + 4) = v22;
          *(_WORD *)(v21 + 12) = 2080;
          *(void *)(v21 + 14) = v23;
          return __SC_log_send(5LL, v16, v17, v19);
        }

        if (sub_512B8((uint64_t)v32, 255, 0, 0LL))
        {
          uint64_t v16 = sub_57538();
          uint64_t v17 = _SC_syslog_os_log_mapping(5LL);
          unint64_t result = __SC_log_enabled(5LL, v16, v17);
          if (!(_DWORD)result) {
            return result;
          }
          uint64_t v24 = _os_log_pack_size(12LL);
          int v19 = (char *)&v32[-1] - ((__chkstk_darwin(v24) + 15) & 0xFFFFFFFFFFFFFFF0LL);
          uint64_t v25 = *__error();
          uint64_t v26 = _os_log_pack_fill(v19, v24, v25, &dword_0, "DHCP %s: RELEASE failed to terminate options");
          goto LABEL_13;
        }

        if ((bootp_client_transmit( *(void **)(v4 + 16),  *(_DWORD *)(v4 + 1736),  *(unsigned int *)(v4 + 1732),  (unsigned __int16)word_6C044,  (unsigned __int16)word_6C020,  *(void **)(v4 + 176),  *(unsigned int *)(v4 + 184)) & 0x80000000) == 0)
        {
          unint64_t result = sub_13DC8(a1);
          *(_DWORD *)(v4 + 1732) = 0;
          return result;
        }

        uint64_t v16 = sub_57538();
        uint64_t v17 = _SC_syslog_os_log_mapping(5LL);
        unint64_t result = __SC_log_enabled(5LL, v16, v17);
        if ((_DWORD)result)
        {
          uint64_t v29 = _os_log_pack_size(12LL);
          int v19 = (char *)&v32[-1] - ((__chkstk_darwin(v29) + 15) & 0xFFFFFFFFFFFFFFF0LL);
          uint64_t v30 = *__error();
          uint64_t v26 = _os_log_pack_fill(v19, v29, v30, &dword_0, "DHCP %s: RELEASE transmit failed");
LABEL_13:
          uint64_t v27 = v26;
          uint64_t v28 = nullsub_1(v2);
          *(_DWORD *)uint64_t v27 = 136315138;
          *(void *)(v27 + 4) = v28;
          return __SC_log_send(5LL, v16, v17, v19);
        }
      }
    }
  }

  return result;
}

void sub_B424(uint64_t a1, unsigned int a2)
{
  uint64_t v4 = (_DWORD *)sub_194C4(a1);
  sub_11718(a1);
  sub_18014(a1);
  sub_50CA0((uint64_t)(v4 + 52));
  sub_18A00(a1);
  sub_17FEC(a1, a2);
  sub_1175C(a1, 0);
  *uint64_t v4 = 0;
  sub_150A4(a1, 0);
}

void sub_B498(uint64_t a1, CFTypeRef cf)
{
  if (cf) {
    CFRetain(cf);
  }
  uint64_t v4 = *(const void **)(a1 + 120);
  if (v4) {
    CFRelease(v4);
  }
  *(void *)(a1 + 120) = cf;
}

void sub_B4D4(uint64_t a1, CFTypeRef cf)
{
  if (cf) {
    CFRetain(cf);
  }
  uint64_t v4 = *(const void **)(a1 + 128);
  if (v4) {
    CFRelease(v4);
  }
  *(void *)(a1 + 128) = cf;
}

double sub_B510( uint64_t a1, uint64_t a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16)
{
  *(void *)&double result = 136318722LL;
  *(_DWORD *)a1 = 136318722;
  *(void *)(a1 + 4) = a2;
  *(_WORD *)(a1 + 12) = 1024;
  *(_DWORD *)(a1 + 14) = a3;
  *(_WORD *)(a1 + 18) = 1024;
  *(_DWORD *)(a1 + 20) = a4;
  *(_WORD *)(a1 + 24) = 1024;
  *(_DWORD *)(a1 + 26) = a5;
  *(_WORD *)(a1 + 30) = 1024;
  *(_DWORD *)(a1 + 32) = a6;
  *(_WORD *)(a1 + 36) = 1024;
  *(_DWORD *)(a1 + 38) = a7;
  *(_WORD *)(a1 + 42) = 1024;
  *(_DWORD *)(a1 + 44) = a8;
  *(_WORD *)(a1 + 48) = 1024;
  *(_DWORD *)(a1 + 50) = a9;
  *(_WORD *)(a1 + 54) = 1024;
  *(_DWORD *)(a1 + 56) = a10;
  *(_WORD *)(a1 + 60) = 1024;
  *(_DWORD *)(a1 + 62) = a11;
  *(_WORD *)(a1 + 66) = 1024;
  *(_DWORD *)(a1 + 68) = a12;
  *(_WORD *)(a1 + 72) = 1024;
  *(_DWORD *)(a1 + 74) = a13;
  *(_WORD *)(a1 + 78) = 1024;
  *(_DWORD *)(a1 + 80) = a14;
  *(_WORD *)(a1 + 84) = 1024;
  *(_DWORD *)(a1 + 86) = a15;
  *(_WORD *)(a1 + 90) = 1024;
  *(_DWORD *)(a1 + 92) = a16;
  return result;
}

void sub_B5A8(uint64_t a1, int a2)
{
  uint64_t v4 = sub_194C4(a1);
  uint64_t v5 = sub_14834(a1);
  if (!sub_14840(a1))
  {
    int v6 = 0;
    goto LABEL_9;
  }

  int v6 = sub_1485C(a1);
  if (!sub_19440(a1))
  {
LABEL_9:
    uint64_t v7 = 0LL;
    unsigned int v9 = 0;
LABEL_10:
    sub_1105C(v4, v5, (uint64_t *)&v15, &v14, &v13);
    DHCPLeaseListRemoveLease((uint64_t *)(v4 + 136), *(_DWORD *)(v4 + 1732), v6, v7, v9);
    int v12 = (const char *)nullsub_1(v5);
    DHCPLeaseListWrite((uint64_t *)(v4 + 136), v12, v14, v15, v13);
    return;
  }

  uint64_t v7 = (const void *)sub_14EA4(a1);
  unsigned int v8 = sub_54230(v5);
  unsigned int v9 = v8;
  if (!a2 || !v6 || !v8) {
    goto LABEL_10;
  }
  uint64_t Lease = DHCPLeaseListFindLease(v4 + 136, *(_DWORD *)(v4 + 1732), v6, v7, v8);
  if ((_DWORD)Lease != -1)
  {
    uint64_t v11 = sub_50C98(v4 + 136, Lease);
    DHCPLeaseSetNAK(v11, 1);
  }

void sub_B6E8(uint64_t a1)
{
  uint64_t v2 = sub_194C4(a1);
  uint64_t v3 = sub_14834(a1);
  sub_1175C(a1, 1u);
  uint64_t v4 = sub_57538();
  uint64_t v5 = _SC_syslog_os_log_mapping(5LL);
  if (__SC_log_enabled(5LL, v4, v5))
  {
    uint64_t v6 = _os_log_pack_size(22LL);
    uint64_t v7 = (char *)v39 - ((__chkstk_darwin(v6) + 15) & 0xFFFFFFFFFFFFFFF0LL);
    unsigned int v8 = __error();
    uint64_t v9 = _os_log_pack_fill(v7, v6, *v8, &dword_0, "dhcp_decline(%s) declining %s", v39[0], v39[1]);
    uint64_t v10 = nullsub_1(v3);
    uint64_t v11 = inet_ntop(2, (const void *)(v2 + 1732), (char *)v39, 0x10u);
    *(_DWORD *)uint64_t v9 = 136315394;
    *(void *)(v9 + 4) = v10;
    *(_WORD *)(v9 + 12) = 2080;
    *(void *)(v9 + 14) = v11;
    __SC_log_send(5LL, v4, v5, v7);
  }

  sub_11718(a1);
  int v12 = (const void *)sub_54E44(v3);
  unsigned __int8 v13 = sub_54E28(v3);
  unsigned __int8 v14 = sub_54230(v3);
  unsigned int v15 = sub_10010((char *)(v2 + 1784), 4, v12, v13, v14, *(const void **)(v2 + 24), *(_DWORD *)(v2 + 32), 0, v40);
  *(void *)(v2 + 176) = v15;
  if (!v15) {
    goto LABEL_12;
  }
  if (sub_512B8((uint64_t)v40, 50, 4, (void *)(v2 + 1732)))
  {
    uint64_t v16 = sub_57538();
    uint64_t v17 = _SC_syslog_os_log_mapping(5LL);
    if (__SC_log_enabled(5LL, v16, v17))
    {
      uint64_t v18 = _os_log_pack_size(22LL);
      int v19 = (char *)v39 - ((__chkstk_darwin(v18) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v20 = *__error();
      uint64_t v21 = _os_log_pack_fill(v19, v18, v20, &dword_0, "DHCP %s: DECLINE couldn't add our ip, %s");
LABEL_10:
      uint64_t v24 = v21;
      uint64_t v25 = nullsub_1(v3);
      uint64_t v26 = sub_514D0(v40);
      *(_DWORD *)uint64_t v24 = 136315394;
      *(void *)(v24 + 4) = v25;
      *(_WORD *)(v24 + 12) = 2080;
      *(void *)(v24 + 14) = v26;
LABEL_11:
      __SC_log_send(5LL, v16, v17, v19);
      goto LABEL_12;
    }

    goto LABEL_12;
  }

  if (sub_512B8((uint64_t)v40, 54, 4, (void *)(v2 + 1736)))
  {
    uint64_t v16 = sub_57538();
    uint64_t v17 = _SC_syslog_os_log_mapping(5LL);
    if (__SC_log_enabled(5LL, v16, v17))
    {
      uint64_t v22 = _os_log_pack_size(22LL);
      int v19 = (char *)v39 - ((__chkstk_darwin(v22) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v23 = *__error();
      uint64_t v21 = _os_log_pack_fill(v19, v22, v23, &dword_0, "DHCP %s: DECLINE couldn't add server ip, %s");
      goto LABEL_10;
    }

LABEL_12:
    sub_B424(a1, 5u);
    return;
  }

  if (sub_512B8((uint64_t)v40, 255, 0, 0LL))
  {
    uint64_t v16 = sub_57538();
    uint64_t v17 = _SC_syslog_os_log_mapping(5LL);
    uint64_t v27 = _os_log_pack_size(12LL);
    int v19 = (char *)v39 - ((__chkstk_darwin(v27) + 15) & 0xFFFFFFFFFFFFFFF0LL);
    uint64_t v28 = __error();
    uint64_t v29 = _os_log_pack_fill( v19,  v27,  *v28,  &dword_0,  "DHCP %s: DECLINE failed to terminate options",  v39[0]);
    uint64_t v30 = nullsub_1(v3);
    *(_DWORD *)uint64_t v29 = 136315138;
    *(void *)(v29 + 4) = v30;
    goto LABEL_11;
  }

  if ((bootp_client_transmit( *(void **)(v2 + 16),  0xFFFFFFFF,  0LL,  (unsigned __int16)word_6C044,  (unsigned __int16)word_6C020,  *(void **)(v2 + 176),  *(unsigned int *)(v2 + 184)) & 0x80000000) != 0)
  {
    uint64_t v31 = sub_57538();
    uint64_t v32 = _SC_syslog_os_log_mapping(5LL);
    if (__SC_log_enabled(5LL, v31, v32))
    {
      uint64_t v33 = _os_log_pack_size(12LL);
      int v34 = (char *)v39 - ((__chkstk_darwin(v33) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v35 = __error();
      uint64_t v36 = _os_log_pack_fill(v34, v33, *v35, &dword_0, "DHCP %s: DECLINE transmit failed", v39[0]);
      uint64_t v37 = nullsub_1(v3);
      *(_DWORD *)uint64_t v36 = 136315138;
      *(void *)(v36 + 4) = v37;
      __SC_log_send(5LL, v31, v32, v34);
    }
  }

  sub_18A00(a1);
  *(_DWORD *)(v2 + 1732) = 0;
  sub_AE1C(v2);
  sub_14F54(a1);
  sub_18014(a1);
  sub_150A4(a1, 0);
  if (sub_13834(v3)) {
    uint64_t v38 = 1LL;
  }
  else {
    uint64_t v38 = 10LL;
  }
  timer_set_relative(*(void *)(v2 + 1760), v38, 0, (uint64_t)sub_C4A4, a1, 0LL, 0LL);
}

  uint64_t v18 = 0;
LABEL_15:
  if ((_BYTE)v71)
  {
    int v19 = sub_57538();
    uint64_t v20 = _SC_syslog_os_log_mapping(7LL);
    if (__SC_log_enabled(7LL, v19, v20))
    {
      uint64_t v21 = _os_log_pack_size(22LL);
      uint64_t v22 = (char *)&v67 - ((__chkstk_darwin(v21) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v23 = __error();
      uint64_t v24 = _os_log_pack_fill(v22, v21, *v23, &dword_0, "%s: %sscheduled", v67, v68);
      uint64_t v25 = "not ";
      if (v18) {
        uint64_t v25 = "";
      }
      *(_DWORD *)uint64_t v24 = 136315394;
      *(void *)(v24 + 4) = "rtadv_pvd_additional_info_schedule_fetch";
      *(_WORD *)(v24 + 12) = 2080;
      *(void *)(v24 + 14) = v25;
      __SC_log_send(7LL, v19, v20, v22);
    }
  }

  sub_4FA18((const void **)&v69);
}

void sub_BC50(_DWORD *a1, int a2, int *a3)
{
  double current_time = timer_get_current_time();
  uint64_t v7 = sub_194C4((uint64_t)a1);
  uint64_t v8 = sub_14834((uint64_t)a1);
  int v9 = sub_54E78(v8);
  int v10 = *a3;
  if (v9)
  {
    if (!v10) {
      goto LABEL_22;
    }
  }

  else if (!v10)
  {
    goto LABEL_6;
  }

  if (!a3[1])
  {
LABEL_22:
    *(_DWORD *)(v7 + 1768) = 0;
    *(_DWORD *)(v7 + 1744) = 0;
    sub_11718((uint64_t)a1);
    return;
  }

LABEL_6:
  *(_DWORD *)(v7 + 36) = 0;
  *(_DWORD *)(v7 + 2336) = 0;
  if (*(_DWORD *)(v7 + 56) && *(void *)(v7 + 120))
  {
    uint64_t v11 = (const void *)sub_19C04((uint64_t)a1);
    int v12 = (const void *)sub_19BF0((uint64_t)a1);
    if (v12)
    {
      unsigned __int8 v13 = v12;
      if (sub_506A4(*(const void **)(v7 + 120), v12)
        || sub_506A4(*(const void **)(v7 + 128), v11))
      {
        if (*(_DWORD *)(v7 + 112))
        {
          uint64_t v14 = sub_54E44(v8);
          BOOL v16 = *(_DWORD *)(v7 + 104) != *(_DWORD *)v14
             || *(unsigned __int16 *)(v7 + 108) != *(unsigned __int16 *)(v14 + 4);
          uint64_t v17 = sub_57538();
          uint64_t v18 = _SC_syslog_os_log_mapping(5LL);
          int v19 = __SC_log_enabled(5LL, v17, v18);
          if (v16)
          {
            if (v19)
            {
              uint64_t v20 = _os_log_pack_size(22LL);
              uint64_t v21 = (char *)&v54 - ((__chkstk_darwin(v20) + 15) & 0xFFFFFFFFFFFFFFF0LL);
              uint64_t v22 = __error();
              uint64_t v23 = _os_log_pack_fill( v21,  v20,  *v22,  &dword_0,  "%s: discarding lease for %@, MAC mismatch");
              uint64_t v24 = nullsub_1(v8);
              *(_DWORD *)uint64_t v23 = 136315394;
              *(void *)(v23 + 4) = v24;
              *(_WORD *)(v23 + 12) = 2112;
              *(void *)(v23 + 14) = v13;
              __SC_log_send(5LL, v17, v18, v21);
            }

            sub_AE1C(v7);
            *(_DWORD *)(v7 + 1768) = 0;
          }

          else if (v19)
          {
            uint64_t v32 = _os_log_pack_size(22LL);
            uint64_t v33 = (char *)&v54 - ((__chkstk_darwin(v32) + 15) & 0xFFFFFFFFFFFFFFF0LL);
            int v34 = __error();
            uint64_t v35 = _os_log_pack_fill(v33, v32, *v34, &dword_0, "%s: using lease for %@");
            uint64_t v36 = nullsub_1(v8);
            *(_DWORD *)uint64_t v35 = 136315394;
            *(void *)(v35 + 4) = v36;
            *(_WORD *)(v35 + 12) = 2112;
            *(void *)(v35 + 14) = v13;
            __SC_log_send(5LL, v17, v18, v33);
          }

          *(_DWORD *)(v7 + 112) = 0;
        }
      }

      else
      {
        uint64_t v37 = sub_57538();
        uint64_t v38 = _SC_syslog_os_log_mapping(5LL);
        if (__SC_log_enabled(5LL, v37, v38))
        {
          uint64_t v39 = _os_log_pack_size(32LL);
          uint64_t v55 = &v54;
          uint64_t v40 = (char *)&v54 - ((__chkstk_darwin(v39) + 15) & 0xFFFFFFFFFFFFFFF0LL);
          uint64_t v41 = __error();
          uint64_t v42 = _os_log_pack_fill(v40, v39, *v41, &dword_0, "%s: SSID is now %@ (was %@)");
          uint64_t v43 = nullsub_1(v8);
          uint64_t v44 = *(void *)(v7 + 120);
          *(_DWORD *)uint64_t v42 = 136315650;
          *(void *)(v42 + 4) = v43;
          *(_WORD *)(v42 + 12) = 2112;
          *(void *)(v42 + 14) = v13;
          *(_WORD *)(v42 + 22) = 2112;
          *(void *)(v42 + 24) = v44;
          __SC_log_send(5LL, v37, v38, v40);
        }

        uint64_t LeaseForWiFi = DHCPLeaseListFindLeaseForWiFi(v7 + 136, v13, v11);
        if ((_DWORD)LeaseForWiFi == -1)
        {
          uint64_t v47 = sub_57538();
          uint64_t v48 = _SC_syslog_os_log_mapping(5LL);
          if (__SC_log_enabled(5LL, v47, v48))
          {
            uint64_t v49 = _os_log_pack_size(22LL);
            uint64_t v50 = (char *)&v54 - ((__chkstk_darwin(v49) + 15) & 0xFFFFFFFFFFFFFFF0LL);
            uint64_t v51 = __error();
            uint64_t v52 = _os_log_pack_fill(v50, v49, *v51, &dword_0, "%s: No lease for %@");
            uint64_t v53 = nullsub_1(v8);
            *(_DWORD *)uint64_t v52 = 136315394;
            *(void *)(v52 + 4) = v53;
            *(_WORD *)(v52 + 12) = 2112;
            *(void *)(v52 + 14) = v13;
            __SC_log_send(5LL, v47, v48, v50);
          }

          sub_AE1C(v7);
        }

        else
        {
          uint64_t v46 = sub_50C98(v7 + 136, LeaseForWiFi);
          sub_110CC((uint64_t)a1, v46, 0);
        }

        *(_DWORD *)(v7 + 1768) = 0;
      }
    }

    else
    {
      uint64_t v25 = sub_57538();
      uint64_t v26 = _SC_syslog_os_log_mapping(5LL);
      if (__SC_log_enabled(5LL, v25, v26))
      {
        uint64_t v27 = _os_log_pack_size(22LL);
        uint64_t v28 = (char *)&v54 - ((__chkstk_darwin(v27) + 15) & 0xFFFFFFFFFFFFFFF0LL);
        uint64_t v29 = __error();
        uint64_t v30 = _os_log_pack_fill(v28, v27, *v29, &dword_0, "%s: %s: no SSID", v54, (const char *)v55);
        uint64_t v31 = nullsub_1(v8);
        *(_DWORD *)uint64_t v30 = 136315394;
        *(void *)(v30 + 4) = v31;
        *(_WORD *)(v30 + 12) = 2080;
        *(void *)(v30 + 14) = "dhcp_check_link_with_status";
        __SC_log_send(5LL, v25, v26, v28);
      }
    }
  }

  if (sub_C42C((uint64_t)a1, current_time))
  {
    if (a2 == 8 || *(_DWORD *)(v7 + 1744) != 6 || *(_DWORD *)(v7 + 1768) != 1)
    {
      int v56 = *(_DWORD *)(v7 + 1732);
      sub_CF80(a1, 0, (uint64_t)&v56);
    }
  }

  else if (a2 == 8 || *(_DWORD *)(v7 + 1744) != 3 || *(_DWORD *)(v7 + 1768) != 1)
  {
    sub_C4A4(a1, 0, 0LL);
  }

      int v9 = (v9 + 1);
      double result = sub_50C94(qword_6C150);
    }

    while ((int)v9 < (int)result);
  }

  return result;
}

void sub_C270(uint64_t a1)
{
  uint64_t v2 = sub_194C4(a1);
  sub_11718(a1);
  sub_19504(a1, 12);
  sub_18A00(a1);
  sub_18014(a1);
  sub_17FEC(a1, 0xCu);
  sub_1175C(a1, 0);
  *(_DWORD *)uint64_t v2 = 0;
  sub_150A4(a1, 0);
  *(void *)(v2 + 1776) = 0LL;
}

void sub_C2E4(uint64_t a1, const void *a2, int a3, int a4)
{
  uint64_t v8 = sub_194C4(a1);
  uint64_t v9 = sub_14834(a1);
  if (sub_14840(a1))
  {
    int v10 = sub_1485C(a1);
    if (sub_19440(a1))
    {
      uint64_t v11 = (const void *)sub_14EA4(a1);
      unsigned int v12 = sub_54230(v9);
    }

    else
    {
      uint64_t v11 = 0LL;
      unsigned int v12 = 0;
    }
  }

  else
  {
    uint64_t v11 = 0LL;
    unsigned int v12 = 0;
    int v10 = 0;
  }

  sub_1105C(v8, v9, (uint64_t *)&v16, &v15, &v14);
  DHCPLeaseListUpdateLease( (uint64_t *)(v8 + 136),  *(_DWORD *)(v8 + 1732),  v10,  v11,  v12,  *(_DWORD *)(v8 + 72),  a2,  a3,  *(double *)(v8 + 80),  *(const void **)(v8 + 120),  *(const void **)(v8 + 128));
  if (a4)
  {
    unsigned __int8 v13 = (const char *)nullsub_1(v9);
    DHCPLeaseListWrite((uint64_t *)(v8 + 136), v13, v15, v16, v14);
  }

uint64_t sub_C42C(uint64_t a1, double a2)
{
  uint64_t v4 = sub_194C4(a1);
  uint64_t result = *(unsigned int *)(v4 + 56);
  if ((_DWORD)result && *(_DWORD *)(v4 + 72) != -1 && *(double *)(v4 + 64) <= a2)
  {
    sub_AE1C(v4);
    sub_14F54(a1);
    sub_18A00(a1);
    sub_17FEC(a1, 0x14u);
    return *(unsigned int *)(v4 + 56);
  }

  return result;
}

void sub_C4A4(_DWORD *a1, int a2, uint64_t a3)
{
  double current_time = timer_get_current_time();
  double v89 = current_time;
  uint64_t v7 = sub_194C4((uint64_t)a1);
  uint64_t v8 = sub_14834((uint64_t)a1);
  if (a2 == 5)
  {
    LODWORD(v90[0]) = 0;
    unsigned int v87 = 0;
    unsigned int v23 = sub_109A8((uint64_t *)a3, *(_DWORD *)(v7 + 2332), v8, &v87, &v86);
    int v24 = v86;
    if (v23) {
      BOOL v25 = v86 == 0;
    }
    else {
      BOOL v25 = 1;
    }
    if (!v25 && v87 == 2)
    {
      if (dword_6C138
        && sub_17660((uint64_t)a1)
        && !*(_DWORD *)(v7 + 44)
        && sub_13568(a3 + 16, v90))
      {
        sub_135C4((uint64_t)a1, 0, v90);
      }

      else if ((*(_DWORD *)(*(void *)a3 + 16LL) + 1) >= 2)
      {
        int v27 = dword_6C018;
        dhcp_get_lease_from_options(a3 + 16, &v88, &v85, (unsigned int *)&v84 + 1);
        int v28 = sub_511CC(a3 + 16, (unsigned __int8 *)off_6C010, dword_6C018);
        unsigned int v29 = *(_DWORD *)(*(void *)a3 + 16LL);
        unsigned int v30 = bswap32(v29);
        else {
          int v31 = 1000;
        }
        BOOL v32 = v30 >> 20 == 2753 || HIBYTE(v30) == 10;
        unsigned int v33 = HIWORD(v30);
        if (v32 || v33 == 49320) {
          int v31 = 100;
        }
        unsigned int v35 = v31 + v28;
        if (!*(_DWORD *)(v7 + 1724) || v35 > *(_DWORD *)(v7 + 1728))
        {
          sub_14F54((uint64_t)a1);
          sub_50CA0(v7 + 208);
          memmove((void *)(v7 + 224), *(const void **)a3, *(int *)(a3 + 8));
          unsigned int v36 = *(_DWORD *)(a3 + 8);
          *(_DWORD *)(v7 + 1724) = v36;
          *(_DWORD *)(v7 + 1728) = v35;
          sub_50F80((char **)(v7 + 208), v7 + 224, v36, 0LL);
          *(_DWORD *)(v7 + 1732) = *(_DWORD *)(*(void *)a3 + 16LL);
          *(_DWORD *)(v7 + 1736) = v24;
          sub_11550((uint64_t)a1, (uint64_t)"INIT", v88, v85, HIDWORD(v84), current_time);
          if (v35 == v27 + 1000 || sub_13834(v8))
          {
LABEL_57:
            sub_11A14(a1, 0, 0LL);
            return;
          }

          if (!*(_DWORD *)(v7 + 44))
          {
            uint64_t v37 = sub_57538();
            uint64_t v38 = _SC_syslog_os_log_mapping(5LL);
            if (__SC_log_enabled(5LL, v37, v38))
            {
              uint64_t v39 = _os_log_pack_size(22LL);
              uint64_t v40 = (char *)&v82 - ((__chkstk_darwin(v39) + 15) & 0xFFFFFFFFFFFFFFF0LL);
              uint64_t v41 = __error();
              uint64_t v42 = _os_log_pack_fill( v40,  v39,  *v41,  &dword_0,  "DHCP %s: INIT gathering began at %g",  v82,  v83);
              uint64_t v43 = nullsub_1(v8);
              double v44 = current_time - *(double *)(v7 + 1752);
              *(_DWORD *)uint64_t v42 = 136315394;
              *(void *)(v42 + 4) = v43;
              *(_WORD *)(v42 + 12) = 2048;
              *(double *)(v42 + 14) = v44;
              __SC_log_send(5LL, v37, v38, v40);
            }

            *(_DWORD *)(v7 + 44) = 1;
            timer_callout_set(*(void *)(v7 + 1760), (uint64_t)sub_C4A4, (uint64_t)a1, 2LL, 0LL, (double)G_gather_secs);
          }
        }
      }
    }
  }

  else
  {
    if (a2 != 2)
    {
      if (a2) {
        return;
      }
      unsigned int v88 = 10974720;
      int v9 = *(_DWORD *)(v7 + 1744);
      sub_1175C((uint64_t)a1, 3u);
      *(_DWORD *)uint64_t v7 = 1;
      *(_DWORD *)(v7 + 200) = 0;
      sub_11718((uint64_t)a1);
      unsigned int v10 = *(_DWORD *)(v7 + 168) != 0;
      uint64_t v11 = (const void *)sub_54E44(v8);
      unsigned __int8 v12 = sub_54E28(v8);
      unsigned __int8 v13 = sub_54230(v8);
      int v14 = sub_10010((char *)(v7 + 1784), 1, v11, v12, v13, *(const void **)(v7 + 24), *(_DWORD *)(v7 + 32), v10, v90);
      *(void *)(v7 + 176) = v14;
      if (!v14)
      {
        uint64_t v15 = sub_57538();
        uint64_t v16 = _SC_syslog_os_log_mapping(5LL);
        uint64_t v45 = _os_log_pack_size(12LL);
        uint64_t v18 = (char *)&v82 - ((__chkstk_darwin(v45) + 15) & 0xFFFFFFFFFFFFFFF0LL);
        uint64_t v46 = *__error();
        uint64_t v47 = _os_log_pack_fill(v18, v45, v46, &dword_0, "DHCP %s: INIT make_dhcp_request failed");
LABEL_48:
        uint64_t v50 = v47;
        uint64_t v51 = nullsub_1(v8);
        *(_DWORD *)uint64_t v50 = 136315138;
        *(void *)(v50 + 4) = v51;
        goto LABEL_49;
      }

      if (sub_512B8((uint64_t)v90, 51, 4, &v88))
      {
        uint64_t v15 = sub_57538();
        uint64_t v16 = _SC_syslog_os_log_mapping(5LL);
        if (__SC_log_enabled(5LL, v15, v16))
        {
          uint64_t v17 = _os_log_pack_size(22LL);
          uint64_t v18 = (char *)&v82 - ((__chkstk_darwin(v17) + 15) & 0xFFFFFFFFFFFFFFF0LL);
          int v19 = __error();
          uint64_t v20 = _os_log_pack_fill( v18,  v17,  *v19,  &dword_0,  "DHCP %s: INIT dhcpoa_add lease time failed, %s",  v82,  *(const char **)&v83);
          uint64_t v21 = nullsub_1(v8);
          uint64_t v22 = sub_514D0(v90);
          *(_DWORD *)uint64_t v20 = 136315394;
          *(void *)(v20 + 4) = v21;
          *(_WORD *)(v20 + 12) = 2080;
          *(void *)(v20 + 14) = v22;
LABEL_49:
          __SC_log_send(5LL, v15, v16, v18);
        }

LABEL_50:
        sub_B424((uint64_t)a1, 5u);
        return;
      }

      sub_104C8((uint64_t)a1, v90);
      if (sub_512B8((uint64_t)v90, 255, 0, 0LL))
      {
        uint64_t v15 = sub_57538();
        uint64_t v16 = _SC_syslog_os_log_mapping(5LL);
        uint64_t v48 = _os_log_pack_size(12LL);
        uint64_t v18 = (char *)&v82 - ((__chkstk_darwin(v48) + 15) & 0xFFFFFFFFFFFFFFF0LL);
        uint64_t v49 = *__error();
        uint64_t v47 = _os_log_pack_fill(v18, v48, v49, &dword_0, "DHCP %s: INIT failed to terminate options");
        goto LABEL_48;
      }

      unsigned int v52 = sub_5147C((uint64_t)v90) + 240;
      if (v52 <= 0x12C) {
        unsigned int v52 = 300;
      }
      *(_DWORD *)(v7 + 184) = v52;
      if (v9 != 6) {
        *(double *)(v7 + 1752) = current_time;
      }
      *(_DWORD *)(v7 + 2340) = G_initial_wait_secs;
      *(_DWORD *)(v7 + 1768) = 0;
      ++*(_DWORD *)(v7 + 2332);
      *(_DWORD *)(v7 + 1728) = 0;
      *(_DWORD *)(v7 + 44) = 0;
      *(_DWORD *)(v7 + 48) = 0;
      sub_17FF4((uint64_t)a1);
      bootp_client_enable_receive(*(void **)(v7 + 16), (uint64_t)sub_C4A4, (uint64_t)a1, 5LL);
      sub_150A4((uint64_t)a1, 1);
    }

    if (*(_DWORD *)(v7 + 44) == 1) {
      goto LABEL_57;
    }
    int v53 = *(_DWORD *)(v7 + 1768);
    int v54 = v53 + 1;
    *(_DWORD *)(v7 + 1768) = v53 + 1;
    if (v53 >= 1)
    {
      unint64_t v55 = sub_19384((uint64_t)a1);
      if (!HIDWORD(v55) && (_DWORD)v55)
      {
        sub_C270((uint64_t)a1);
        return;
      }

      int v54 = *(_DWORD *)(v7 + 1768);
    }

    BOOL v56 = sub_14F64((uint64_t)a1);
    int v57 = *(_DWORD *)(v7 + 1768);
    if (!v56)
    {
      if (v57 > dword_6C02C && dword_6C024 != 0)
      {
        sub_19504((uint64_t)a1, 9);
        sub_18090((uint64_t)a1, 1);
        int v57 = *(_DWORD *)(v7 + 1768);
      }

      if (v57 > dword_6C030)
      {
        sub_17808((uint64_t)a1);
        int v57 = *(_DWORD *)(v7 + 1768);
      }
    }

    if (v57 <= G_max_retries + 1)
    {
      uint64_t v59 = *(void *)(v7 + 176);
      *(_DWORD *)(v59 + 4) = bswap32(*(_DWORD *)(v7 + 2332));
      *(_WORD *)(v59 + 8) = __rev16((int)(v89 - *(double *)(v7 + 1752)));
      if ((bootp_client_transmit( *(void **)(v7 + 16),  0xFFFFFFFF,  0LL,  (unsigned __int16)word_6C044,  (unsigned __int16)word_6C020,  (void *)v59,  *(unsigned int *)(v7 + 184)) & 0x80000000) != 0)
      {
        uint64_t v60 = sub_57538();
        uint64_t v61 = _SC_syslog_os_log_mapping(5LL);
        if (__SC_log_enabled(5LL, v60, v61))
        {
          uint64_t v62 = _os_log_pack_size(12LL);
          double v63 = (char *)&v82 - ((__chkstk_darwin(v62) + 15) & 0xFFFFFFFFFFFFFFF0LL);
          double v64 = __error();
          uint64_t v65 = _os_log_pack_fill(v63, v62, *v64, &dword_0, "DHCP %s: INIT transmit failed", v82);
          uint64_t v66 = nullsub_1(v8);
          *(_DWORD *)uint64_t v65 = 136315138;
          *(void *)(v65 + 4) = v66;
          __SC_log_send(5LL, v60, v61, v63);
        }
      }

      uint64_t v67 = *(int *)(v7 + 2340);
      unsigned int v68 = sub_558D0(0LL, 999999LL);
      int v69 = v68;
      uint64_t v70 = sub_57538();
      uint64_t v71 = _SC_syslog_os_log_mapping(5LL);
      if (__SC_log_enabled(5LL, v70, v71))
      {
        uint64_t v72 = _os_log_pack_size(38LL);
        uint64_t v82 = (const char *)&v82;
        uint64_t v73 = __chkstk_darwin(v72);
        *(void *)&double v83 = v68;
        uint64_t v74 = (char *)&v82 - ((v73 + 15) & 0xFFFFFFFFFFFFFFF0LL);
        uint64_t v75 = __error();
        uint64_t v76 = _os_log_pack_fill( v74,  v72,  *v75,  &dword_0,  "DHCP %s: INIT waiting at %g for %ld.%06d",  v82,  v83,  v84,  v85);
        uint64_t v77 = nullsub_1(v8);
        double v78 = v89 - *(double *)(v7 + 1752);
        *(_DWORD *)uint64_t v76 = 136315906;
        *(void *)(v76 + 4) = v77;
        *(_WORD *)(v76 + 12) = 2048;
        *(double *)(v76 + 14) = v78;
        *(_WORD *)(v76 + 22) = 2048;
        *(void *)(v76 + 24) = v67;
        *(_WORD *)(v76 + 32) = 1024;
        *(_DWORD *)(v76 + 34) = v68;
        uint64_t v79 = v74;
        int v69 = LODWORD(v83);
        __SC_log_send(5LL, v70, v71, v79);
      }

      timer_set_relative(*(void *)(v7 + 1760), v67, v69, (uint64_t)sub_C4A4, (uint64_t)a1, 2LL, 0LL);
      int v80 = 2 * *(_DWORD *)(v7 + 2340);
      if (v80 >= G_max_wait_secs) {
        int v80 = G_max_wait_secs;
      }
      *(_DWORD *)(v7 + 2340) = v80;
    }

    else if (sub_14F64((uint64_t)a1))
    {
      sub_12D98(a1, 0, 0LL);
    }

    else
    {
      uint64_t v81 = sub_194C4((uint64_t)a1);
      if (dword_6C024) {
        sub_18090((uint64_t)a1, 1);
      }
      sub_11718((uint64_t)a1);
      sub_17FEC((uint64_t)a1, 9u);
      sub_150A4((uint64_t)a1, 0);
      timer_set_relative(*(void *)(v81 + 1760), 60LL, 0, (uint64_t)sub_C4A4, (uint64_t)a1, 0LL, 0LL);
    }
  }

void sub_CF80(_DWORD *a1, int a2, uint64_t a3)
{
  double current_time = timer_get_current_time();
  double v112 = current_time;
  uint64_t v7 = sub_194C4((uint64_t)a1);
  uint64_t v8 = sub_14834((uint64_t)a1);
  unsigned int v111 = 0;
  if (a2 == 5)
  {
    LODWORD(v113) = 0;
    unsigned int v110 = 0;
    int v29 = sub_194B4((uint64_t)a1);
    unsigned int v30 = v110;
    if (!v29 && v110 == 6)
    {
      uint64_t v31 = sub_57538();
      uint64_t v32 = _SC_syslog_os_log_mapping(5LL);
      if (__SC_log_enabled(5LL, v31, v32))
      {
        uint64_t v33 = _os_log_pack_size(12LL);
        int v34 = (char *)&v104 - ((__chkstk_darwin(v33) + 15) & 0xFFFFFFFFFFFFFFF0LL);
        unsigned int v35 = __error();
        uint64_t v36 = _os_log_pack_fill(v34, v33, *v35, &dword_0, "DHCP %s: got DHCP NAK", v104);
        uint64_t v37 = nullsub_1(v8);
        *(_DWORD *)uint64_t v36 = 136315138;
        *(void *)(v36 + 4) = v37;
        __SC_log_send(5LL, v31, v32, v34);
      }

      if (!sub_33A4(*(void *)(v7 + 8)))
      {
        sub_17FEC((uint64_t)a1, 0xBu);
        sub_13870((uint64_t)a1, 1u);
        return;
      }

      *(_DWORD *)(v7 + 48) = 1;
      unsigned int v30 = v110;
    }

    unsigned int v38 = v109;
    if (v109 && v30 == 5)
    {
      if (dword_6C138
        && sub_17660((uint64_t)a1)
        && !*(_DWORD *)(v7 + 44)
        && sub_13568(a3 + 16, &v113))
      {
        sub_135C4((uint64_t)a1, 0, &v113);
        return;
      }

      if (*(_DWORD *)(*(void *)a3 + 16LL) == *(_DWORD *)(v7 + 1732))
      {
        dhcp_get_lease_from_options(a3 + 16, (unsigned int *)v115, &v108, &v107);
        unsigned int v39 = sub_511CC(a3 + 16, (unsigned __int8 *)off_6C010, dword_6C018);
        unsigned int v40 = v39;
        if (!*(_DWORD *)(v7 + 1724) || v39 > *(_DWORD *)(v7 + 1728))
        {
          sub_14F54((uint64_t)a1);
          sub_50CA0(v7 + 208);
          memmove((void *)(v7 + 224), *(const void **)a3, *(int *)(a3 + 8));
          unsigned int v41 = *(_DWORD *)(a3 + 8);
          *(_DWORD *)(v7 + 1724) = v41;
          *(_DWORD *)(v7 + 1728) = v40;
          sub_50F80((char **)(v7 + 208), v7 + 224, v41, 0LL);
          *(_DWORD *)(v7 + 1732) = *(_DWORD *)(*(void *)a3 + 16LL);
          *(_DWORD *)(v7 + 1736) = v38;
          sub_11550((uint64_t)a1, (uint64_t)"INIT-REBOOT", *(unsigned int *)v115, v108, v107, current_time);
          if (sub_13834(v8) || v40 == dword_6C018 && sub_14F64((uint64_t)a1))
          {
LABEL_56:
            sub_12D98(a1, 0, 0LL);
            return;
          }

          if (!*(_DWORD *)(v7 + 44))
          {
            uint64_t v42 = sub_57538();
            uint64_t v43 = _SC_syslog_os_log_mapping(5LL);
            if (__SC_log_enabled(5LL, v42, v43))
            {
              uint64_t v44 = _os_log_pack_size(46LL);
              uint64_t v45 = (char *)&v104 - ((__chkstk_darwin(v44) + 15) & 0xFFFFFFFFFFFFFFF0LL);
              uint64_t v46 = __error();
              uint64_t v47 = _os_log_pack_fill( v45,  v44,  *v46,  &dword_0,  "DHCP %s: INIT-REBOOT (%d.%d.%d.%d) gathering began at %g",  v104,  v105,  v106,  v108,  v110,  v112);
              uint64_t v48 = nullsub_1(v8);
              int v49 = *(unsigned __int8 *)(v7 + 1732);
              int v50 = *(unsigned __int8 *)(v7 + 1733);
              int v51 = *(unsigned __int8 *)(v7 + 1734);
              int v52 = *(unsigned __int8 *)(v7 + 1735);
              double v53 = current_time - *(double *)(v7 + 1752);
              *(_DWORD *)uint64_t v47 = 136316418;
              *(void *)(v47 + 4) = v48;
              *(_WORD *)(v47 + 12) = 1024;
              *(_DWORD *)(v47 + 14) = v49;
              *(_WORD *)(v47 + 18) = 1024;
              *(_DWORD *)(v47 + 20) = v50;
              *(_WORD *)(v47 + 24) = 1024;
              *(_DWORD *)(v47 + 26) = v51;
              *(_WORD *)(v47 + 30) = 1024;
              *(_DWORD *)(v47 + 32) = v52;
              *(_WORD *)(v47 + 36) = 2048;
              *(double *)(v47 + 38) = v53;
              __SC_log_send(5LL, v42, v43, v45);
            }

            *(_DWORD *)(v7 + 44) = 1;
            timer_callout_set(*(void *)(v7 + 1760), (uint64_t)sub_CF80, (uint64_t)a1, 2LL, 0LL, (double)G_gather_secs);
          }
        }
      }
    }
  }

  else
  {
    if (a2 != 2)
    {
      if (a2) {
        return;
      }
      unsigned int v110 = 10974720;
      int v9 = &v111;
      if (!v111) {
        int v9 = (unsigned int *)a3;
      }
      unsigned int v109 = *v9;
      sub_1175C((uint64_t)a1, 6u);
      uint64_t v10 = sub_57538();
      uint64_t v11 = _SC_syslog_os_log_mapping(5LL);
      if (__SC_log_enabled(5LL, v10, v11))
      {
        uint64_t v12 = _os_log_pack_size(22LL);
        unsigned __int8 v13 = (char *)&v104 - ((__chkstk_darwin(v12) + 15) & 0xFFFFFFFFFFFFFFF0LL);
        int v14 = __error();
        uint64_t v15 = _os_log_pack_fill( v13,  v12,  *v14,  &dword_0,  "dhcp_init_reboot(%s) requesting %s",  v104,  (const char *)v105);
        uint64_t v16 = nullsub_1(v8);
        uint64_t v17 = inet_ntop(2, &v109, v115, 0x10u);
        *(_DWORD *)uint64_t v15 = 136315394;
        *(void *)(v15 + 4) = v16;
        *(_WORD *)(v15 + 12) = 2080;
        *(void *)(v15 + 14) = v17;
        __SC_log_send(5LL, v10, v11, v13);
      }

      *(_DWORD *)(v7 + 200) = 0;
      *(_DWORD *)uint64_t v7 = 1;
      *(double *)(v7 + 1752) = current_time;
      *(_DWORD *)(v7 + 1768) = 0;
      *(_DWORD *)(v7 + 2340) = G_initial_wait_secs;
      sub_11718((uint64_t)a1);
      unsigned int v18 = *(_DWORD *)(v7 + 168) != 0;
      int v19 = (const void *)sub_54E44(v8);
      unsigned __int8 v20 = sub_54E28(v8);
      unsigned __int8 v21 = sub_54230(v8);
      uint64_t v22 = sub_10010( (char *)(v7 + 1784),  3,  v19,  v20,  v21,  *(const void **)(v7 + 24),  *(_DWORD *)(v7 + 32),  v18,  &v113);
      *(void *)(v7 + 176) = v22;
      if (!v22) {
        goto LABEL_45;
      }
      if (sub_512B8((uint64_t)&v113, 50, 4, &v109))
      {
        uint64_t v23 = sub_57538();
        uint64_t v24 = _SC_syslog_os_log_mapping(5LL);
        if (__SC_log_enabled(5LL, v23, v24))
        {
          uint64_t v25 = _os_log_pack_size(22LL);
          uint64_t v26 = (char *)&v104 - ((__chkstk_darwin(v25) + 15) & 0xFFFFFFFFFFFFFFF0LL);
          uint64_t v27 = *__error();
          uint64_t v28 = _os_log_pack_fill(v26, v25, v27, &dword_0, "DHCP %s: INIT-REBOOT add request ip failed, %s");
LABEL_43:
          uint64_t v56 = v28;
          uint64_t v57 = nullsub_1(v8);
          uint64_t v58 = sub_514D0(&v113);
          *(_DWORD *)uint64_t v56 = 136315394;
          *(void *)(v56 + 4) = v57;
          *(_WORD *)(v56 + 12) = 2080;
          *(void *)(v56 + 14) = v58;
LABEL_44:
          __SC_log_send(5LL, v23, v24, v26);
          goto LABEL_45;
        }

        goto LABEL_45;
      }

      if (sub_512B8((uint64_t)&v113, 51, 4, &v110))
      {
        uint64_t v23 = sub_57538();
        uint64_t v24 = _SC_syslog_os_log_mapping(5LL);
        if (__SC_log_enabled(5LL, v23, v24))
        {
          uint64_t v54 = _os_log_pack_size(22LL);
          uint64_t v26 = (char *)&v104 - ((__chkstk_darwin(v54) + 15) & 0xFFFFFFFFFFFFFFF0LL);
          uint64_t v55 = *__error();
          uint64_t v28 = _os_log_pack_fill(v26, v54, v55, &dword_0, "DHCP %s: INIT-REBOOT add lease time failed, %s");
          goto LABEL_43;
        }

LABEL_45:
        sub_B424((uint64_t)a1, 5u);
        return;
      }

      sub_104C8((uint64_t)a1, &v113);
      if (sub_512B8((uint64_t)&v113, 255, 0, 0LL))
      {
        uint64_t v23 = sub_57538();
        uint64_t v24 = _SC_syslog_os_log_mapping(5LL);
        uint64_t v59 = _os_log_pack_size(12LL);
        uint64_t v26 = (char *)&v104 - ((__chkstk_darwin(v59) + 15) & 0xFFFFFFFFFFFFFFF0LL);
        uint64_t v60 = __error();
        uint64_t v61 = _os_log_pack_fill( v26,  v59,  *v60,  &dword_0,  "DHCP %s: INIT-REBOOT failed to terminate options",  v104);
        uint64_t v62 = nullsub_1(v8);
        *(_DWORD *)uint64_t v61 = 136315138;
        *(void *)(v61 + 4) = v62;
        goto LABEL_44;
      }

      unsigned int v63 = sub_5147C((uint64_t)&v113) + 240;
      if (v63 <= 0x12C) {
        unsigned int v63 = 300;
      }
      *(_DWORD *)(v7 + 184) = v63;
      *(_DWORD *)(v7 + 44) = 0;
      *(_DWORD *)(v7 + 48) = 0;
      ++*(_DWORD *)(v7 + 2332);
      *(_DWORD *)(v7 + 1732) = v109;
      *(_DWORD *)(v7 + 1728) = 0;
      sub_17FF4((uint64_t)a1);
      bootp_client_enable_receive(*(void **)(v7 + 16), (uint64_t)sub_CF80, (uint64_t)a1, 5LL);
      sub_150A4((uint64_t)a1, 1);
    }

    if (*(_DWORD *)(v7 + 44) == 1) {
      goto LABEL_56;
    }
    int v64 = *(_DWORD *)(v7 + 1768);
    *(_DWORD *)(v7 + 1768) = v64 + 1;
    if (v64 < 1 || (unint64_t v65 = sub_19384((uint64_t)a1), HIDWORD(v65)) || !(_DWORD)v65)
    {
      sub_122BC((uint64_t)a1, 0, (uint64_t)&v112);
      BOOL v66 = sub_14F64((uint64_t)a1);
      int v67 = *(_DWORD *)(v7 + 1768);
      if (!v66 && v67 > dword_6C02C && dword_6C024)
      {
        sub_19504((uint64_t)a1, 9);
        sub_18090((uint64_t)a1, 1);
        int v67 = *(_DWORD *)(v7 + 1768);
      }

      if (v67 <= dword_6C038 + 1)
      {
        uint64_t v79 = *(void *)(v7 + 176);
        *(_DWORD *)(v79 + 4) = bswap32(*(_DWORD *)(v7 + 2332));
        *(_WORD *)(v79 + 8) = __rev16((int)(v112 - *(double *)(v7 + 1752)));
        if ((bootp_client_transmit( *(void **)(v7 + 16),  0xFFFFFFFF,  v111,  (unsigned __int16)word_6C044,  (unsigned __int16)word_6C020,  (void *)v79,  *(unsigned int *)(v7 + 184)) & 0x80000000) != 0)
        {
          uint64_t v80 = sub_57538();
          uint64_t v81 = _SC_syslog_os_log_mapping(5LL);
          if (__SC_log_enabled(5LL, v80, v81))
          {
            uint64_t v82 = _os_log_pack_size(12LL);
            double v83 = (char *)&v104 - ((__chkstk_darwin(v82) + 15) & 0xFFFFFFFFFFFFFFF0LL);
            uint64_t v84 = __error();
            uint64_t v85 = _os_log_pack_fill( v83,  v82,  *v84,  &dword_0,  "DHCP %s: INIT-REBOOT transmit failed",  v104);
            uint64_t v86 = nullsub_1(v8);
            *(_DWORD *)uint64_t v85 = 136315138;
            *(void *)(v85 + 4) = v86;
            __SC_log_send(5LL, v80, v81, v83);
          }
        }

        uint64_t v87 = *(int *)(v7 + 2340);
        unsigned int v88 = sub_558D0(0LL, 999999LL);
        int v89 = v88;
        uint64_t v90 = sub_57538();
        uint64_t v91 = _SC_syslog_os_log_mapping(5LL);
        if (__SC_log_enabled(5LL, v90, v91))
        {
          uint64_t v92 = _os_log_pack_size(62LL);
          unint64_t v105 = v88;
          uint64_t v93 = v92;
          v104 = (const char *)&v104;
          int v94 = (char *)&v104 - ((__chkstk_darwin(v92) + 15) & 0xFFFFFFFFFFFFFFF0LL);
          int v95 = __error();
          uint64_t v96 = _os_log_pack_fill( v94,  v93,  *v95,  &dword_0,  "DHCP %s: INIT-REBOOT (%d.%d.%d.%d) waiting at %g for %ld.%06d",  v104,  v105,  v106,  v108,  v110,  v112,  v113,  v114);
          uint64_t v97 = nullsub_1(v8);
          int v98 = *(unsigned __int8 *)(v7 + 1732);
          int v99 = *(unsigned __int8 *)(v7 + 1733);
          int v100 = *(unsigned __int8 *)(v7 + 1734);
          int v101 = *(unsigned __int8 *)(v7 + 1735);
          double v102 = v112 - *(double *)(v7 + 1752);
          *(_DWORD *)uint64_t v96 = 136316930;
          *(void *)(v96 + 4) = v97;
          *(_WORD *)(v96 + 12) = 1024;
          *(_DWORD *)(v96 + 14) = v98;
          *(_WORD *)(v96 + 18) = 1024;
          *(_DWORD *)(v96 + 20) = v99;
          *(_WORD *)(v96 + 24) = 1024;
          *(_DWORD *)(v96 + 26) = v100;
          *(_WORD *)(v96 + 30) = 1024;
          *(_DWORD *)(v96 + 32) = v101;
          *(_WORD *)(v96 + 36) = 2048;
          *(double *)(v96 + 38) = v102;
          *(_WORD *)(v96 + 46) = 2048;
          *(void *)(v96 + 48) = v87;
          *(_WORD *)(v96 + 56) = 1024;
          *(_DWORD *)(v96 + 58) = v88;
          int v89 = v105;
          __SC_log_send(5LL, v90, v91, v94);
        }

        timer_set_relative(*(void *)(v7 + 1760), v87, v89, (uint64_t)sub_CF80, (uint64_t)a1, 2LL, 0LL);
        int v103 = 2 * *(_DWORD *)(v7 + 2340);
        if (v103 >= G_max_wait_secs) {
          int v103 = G_max_wait_secs;
        }
        *(_DWORD *)(v7 + 2340) = v103;
      }

      else
      {
        uint64_t v68 = sub_57538();
        uint64_t v69 = _SC_syslog_os_log_mapping(5LL);
        if (__SC_log_enabled(5LL, v68, v69))
        {
          uint64_t v70 = _os_log_pack_size(36LL);
          uint64_t v71 = (char *)&v104 - ((__chkstk_darwin(v70) + 15) & 0xFFFFFFFFFFFFFFF0LL);
          uint64_t v72 = __error();
          uint64_t v73 = _os_log_pack_fill( v71,  v70,  *v72,  &dword_0,  "DHCP %s: INIT-REBOOT (%d.%d.%d.%d) timed out",  v104,  v105,  v106,  v108,  v110);
          uint64_t v74 = nullsub_1(v8);
          int v75 = *(unsigned __int8 *)(v7 + 1732);
          int v76 = *(unsigned __int8 *)(v7 + 1733);
          int v77 = *(unsigned __int8 *)(v7 + 1734);
          int v78 = *(unsigned __int8 *)(v7 + 1735);
          *(_DWORD *)uint64_t v73 = 136316162;
          *(void *)(v73 + 4) = v74;
          *(_WORD *)(v73 + 12) = 1024;
          *(_DWORD *)(v73 + 14) = v75;
          *(_WORD *)(v73 + 18) = 1024;
          *(_DWORD *)(v73 + 20) = v76;
          *(_WORD *)(v73 + 24) = 1024;
          *(_DWORD *)(v73 + 26) = v77;
          *(_WORD *)(v73 + 30) = 1024;
          *(_DWORD *)(v73 + 32) = v78;
          __SC_log_send(5LL, v68, v69, v71);
        }

        sub_18A00((uint64_t)a1);
        sub_17B20((uint64_t)a1, 0xAu, 0);
        --*(_DWORD *)(v7 + 1768);
        sub_C4A4(a1, 0, 0LL);
      }
    }

    else
    {
      sub_C270((uint64_t)a1);
    }
  }

  sub_4FA18(&v67);
  sub_4FA18(&v66);
}

  uint64_t v70 = *(void *)v7;
  if (a6) {
    *(_WORD *)a6 = v93;
  }
  if (v21) {
    sub_579E8(&v92);
  }
  if (v70) {
    return v13;
  }
  else {
    return 0LL;
  }
}

void sub_DCF8(_DWORD *a1, int a2, _DWORD *a3)
{
  uint64_t v6 = sub_194C4((uint64_t)a1);
  uint64_t v7 = sub_14834((uint64_t)a1);
  if (a2 != 6)
  {
    if (!a2)
    {
      sub_150A4((uint64_t)a1, 1);
      *a3 = *(_DWORD *)(v6 + 1732);
      uint64_t v8 = sub_57538();
      uint64_t v9 = _SC_syslog_os_log_mapping(5LL);
      if (__SC_log_enabled(5LL, v8, v9))
      {
        uint64_t v10 = _os_log_pack_size(60LL);
        uint64_t v11 = (char *)&v51 - ((__chkstk_darwin(v10) + 15) & 0xFFFFFFFFFFFFFFF0LL);
        uint64_t v12 = __error();
        uint64_t v13 = _os_log_pack_fill( v11,  v10,  *v12,  &dword_0,  "DHCP %s: sending unicast ARP to gateway %d.%d.%d.%d from %d.%d.%d.%d",  v51,  (_DWORD)v52,  v53,  v54,  v55,  v56,  v57,  v58,  v59);
        uint64_t v14 = nullsub_1(v7);
        int v15 = *((unsigned __int8 *)a3 + 4);
        int v16 = *((unsigned __int8 *)a3 + 5);
        int v17 = *((unsigned __int8 *)a3 + 6);
        int v18 = *((unsigned __int8 *)a3 + 7);
        int v19 = *(unsigned __int8 *)a3;
        int v20 = *((unsigned __int8 *)a3 + 1);
        int v21 = *((unsigned __int8 *)a3 + 2);
        int v22 = *((unsigned __int8 *)a3 + 3);
        *(_DWORD *)uint64_t v13 = 136317186;
        *(void *)(v13 + 4) = v14;
        *(_WORD *)(v13 + 12) = 1024;
        *(_DWORD *)(v13 + 14) = v15;
        *(_WORD *)(v13 + 18) = 1024;
        *(_DWORD *)(v13 + 20) = v16;
        *(_WORD *)(v13 + 24) = 1024;
        *(_DWORD *)(v13 + 26) = v17;
        *(_WORD *)(v13 + 30) = 1024;
        *(_DWORD *)(v13 + 32) = v18;
        *(_WORD *)(v13 + 36) = 1024;
        *(_DWORD *)(v13 + 38) = v19;
        *(_WORD *)(v13 + 42) = 1024;
        *(_DWORD *)(v13 + 44) = v20;
        *(_WORD *)(v13 + 48) = 1024;
        *(_DWORD *)(v13 + 50) = v21;
        *(_WORD *)(v13 + 54) = 1024;
        *(_DWORD *)(v13 + 56) = v22;
        __SC_log_send(5LL, v8, v9, v11);
      }

      sub_4928(*(void *)(v6 + 8), (uint64_t)sub_DCF8, (uint64_t)a1, 6LL, a3, 1);
    }

    return;
  }

  sub_150A4((uint64_t)a1, 0);
  if (a3[2])
  {
    uint64_t v23 = sub_57538();
    uint64_t v24 = _SC_syslog_os_log_mapping(5LL);
    if (!__SC_log_enabled(5LL, v23, v24))
    {
LABEL_10:
      int v52 = (const char *)sub_19384((uint64_t)a1);
      int v53 = v34;
      sub_BC50(a1, 6, (int *)&v52);
      return;
    }

    uint64_t v25 = _os_log_pack_size(22LL);
    uint64_t v26 = (char *)&v51 - ((__chkstk_darwin(v25) + 15) & 0xFFFFFFFFFFFFFFF0LL);
    uint64_t v27 = __error();
    uint64_t v28 = _os_log_pack_fill(v26, v25, *v27, &dword_0, "DHCP %s: ARP detect gateway failed, %s", v51, v52);
    uint64_t v29 = nullsub_1(v7);
    uint64_t v30 = sub_4AE0(*(void *)(v6 + 8));
    *(_DWORD *)uint64_t v28 = 136315394;
    *(void *)(v28 + 4) = v29;
    *(_WORD *)(v28 + 12) = 2080;
    *(void *)(v28 + 14) = v30;
    uint64_t v31 = v23;
    uint64_t v32 = v24;
    uint64_t v33 = v26;
LABEL_9:
    __SC_log_send(5LL, v31, v32, v33);
    goto LABEL_10;
  }

  if (!a3[3])
  {
    uint64_t v44 = sub_57538();
    uint64_t v45 = _SC_syslog_os_log_mapping(5LL);
    uint64_t v46 = _os_log_pack_size(12LL);
    uint64_t v47 = (char *)&v51 - ((__chkstk_darwin(v46) + 15) & 0xFFFFFFFFFFFFFFF0LL);
    uint64_t v48 = __error();
    uint64_t v49 = _os_log_pack_fill(v47, v46, *v48, &dword_0, "DHCP %s: ARP detect gateway got no response", v51);
    uint64_t v50 = nullsub_1(v7);
    *(_DWORD *)uint64_t v49 = 136315138;
    *(void *)(v49 + 4) = v50;
    uint64_t v31 = v44;
    uint64_t v32 = v45;
    uint64_t v33 = v47;
    goto LABEL_9;
  }

  double current_time = timer_get_current_time();
  uint64_t v36 = sub_57538();
  uint64_t v37 = _SC_syslog_os_log_mapping(5LL);
  if (__SC_log_enabled(5LL, v36, v37))
  {
    uint64_t v38 = _os_log_pack_size(12LL);
    unsigned int v39 = (char *)&v51 - ((__chkstk_darwin(v38) + 15) & 0xFFFFFFFFFFFFFFF0LL);
    unsigned int v40 = __error();
    uint64_t v41 = _os_log_pack_fill(v39, v38, *v40, &dword_0, "DHCP %s: ARP detect gateway got response", v51);
    uint64_t v42 = nullsub_1(v7);
    *(_DWORD *)uint64_t v41 = 136315138;
    *(void *)(v41 + 4) = v42;
    __SC_log_send(5LL, v36, v37, v39);
  }

  if (*(_DWORD *)(v6 + 72) != -1)
  {
    double v43 = *(double *)(v6 + 192);
    if (current_time >= v43) {
      sub_E1B4((uint64_t)a1, 0, 0LL);
    }
    else {
      timer_set_relative( *(void *)(v6 + 1760),  (uint64_t)(v43 - current_time),  0,  (uint64_t)sub_E1B4,  (uint64_t)a1,  0LL,  0LL);
    }
  }

void sub_E1B4(uint64_t a1, int a2, uint64_t a3)
{
  double current_time = timer_get_current_time();
  uint64_t v7 = sub_194C4(a1);
  uint64_t v8 = sub_14834(a1);
  if (a2 == 5)
  {
    LODWORD(v69[0]) = 7776000;
    LODWORD(v67) = 0;
    if ((_DWORD)v67 == 6)
    {
      unsigned int v30 = 11;
    }

    else
    {
      if ((_DWORD)v67 != 5) {
        return;
      }
      int v32 = HIDWORD(v66);
      dhcp_get_lease_from_options(a3 + 16, (unsigned int *)v69, (unsigned int *)&v66, (unsigned int *)&v65 + 1);
      if (*(_DWORD *)(*(void *)a3 + 16LL) == *(_DWORD *)(v7 + 1732))
      {
        sub_11550(a1, (uint64_t)"RENEW/REBIND", v69[0], v66, HIDWORD(v65), current_time);
        sub_50CA0(v7 + 208);
        memmove((void *)(v7 + 224), *(const void **)a3, *(int *)(a3 + 8));
        unsigned int v33 = *(_DWORD *)(a3 + 8);
        *(void *)(v7 + 1724) = v33;
        sub_50F80((char **)(v7 + 208), v7 + 224, v33, 0LL);
        *(_DWORD *)(v7 + 1736) = v32;
        sub_12D98(a1, 0LL, 0LL);
        return;
      }

      unsigned int v30 = 13;
    }

    uint64_t v31 = a1;
LABEL_34:
    sub_17FEC(v31, v30);
    sub_13870(a1, 0);
    return;
  }

  if (a2 != 2)
  {
    if (a2) {
      return;
    }
    sub_11718(a1);
    *(_DWORD *)uint64_t v7 = 0;
    *(double *)(v7 + 1752) = current_time;
    sub_1175C(a1, 7u);
    uint64_t v9 = sub_57538();
    uint64_t v10 = _SC_syslog_os_log_mapping(5LL);
    if (__SC_log_enabled(5LL, v9, v10))
    {
      uint64_t v11 = _os_log_pack_size(22LL);
      uint64_t v12 = (char *)&v65 - ((__chkstk_darwin(v11) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v13 = __error();
      uint64_t v14 = _os_log_pack_fill(v12, v11, *v13, &dword_0, "dhcp_renew_rebind(%s) renewing %s", v65, v66);
      uint64_t v15 = nullsub_1(v8);
      int v16 = inet_ntop(2, (const void *)(v7 + 1732), (char *)&v67, 0x10u);
      *(_DWORD *)uint64_t v14 = 136315394;
      *(void *)(v14 + 4) = v15;
      *(_WORD *)(v14 + 12) = 2080;
      *(void *)(v14 + 14) = v16;
      __SC_log_send(5LL, v9, v10, v12);
    }

    unsigned int v17 = 2 * (sub_17660(a1) != 0);
    int v18 = (const void *)sub_54E44(v8);
    unsigned __int8 v19 = sub_54E28(v8);
    unsigned __int8 v20 = sub_54230(v8);
    int v21 = sub_10010((char *)(v7 + 1784), 3, v18, v19, v20, *(const void **)(v7 + 24), *(_DWORD *)(v7 + 32), v17, v69);
    *(void *)(v7 + 176) = v21;
    if (!v21) {
      goto LABEL_25;
    }
    *(_DWORD *)(v7 + 1768) = 0;
    *((_DWORD *)v21 + 3) = *(_DWORD *)(v7 + 1732);
    HIDWORD(v66) = 10974720;
    if (sub_512B8((uint64_t)v69, 51, 4, (char *)&v66 + 4))
    {
      uint64_t v22 = sub_57538();
      uint64_t v23 = _SC_syslog_os_log_mapping(5LL);
      if (__SC_log_enabled(5LL, v22, v23))
      {
        uint64_t v24 = _os_log_pack_size(22LL);
        uint64_t v25 = (char *)&v65 - ((__chkstk_darwin(v24) + 15) & 0xFFFFFFFFFFFFFFF0LL);
        uint64_t v26 = __error();
        uint64_t v27 = _os_log_pack_fill( v25,  v24,  *v26,  &dword_0,  "DHCP %s: RENEW/REBIND couldn't add lease time: %s",  v65,  v66);
        uint64_t v28 = nullsub_1(v8);
        uint64_t v29 = sub_514D0(v69);
        *(_DWORD *)uint64_t v27 = 136315394;
        *(void *)(v27 + 4) = v28;
        *(_WORD *)(v27 + 12) = 2080;
        *(void *)(v27 + 14) = v29;
LABEL_24:
        __SC_log_send(5LL, v22, v23, v25);
        goto LABEL_25;
      }

      goto LABEL_25;
    }

    sub_104C8(a1, v69);
    if (sub_512B8((uint64_t)v69, 255, 0, 0LL))
    {
      uint64_t v22 = sub_57538();
      uint64_t v23 = _SC_syslog_os_log_mapping(5LL);
      if (__SC_log_enabled(5LL, v22, v23))
      {
        uint64_t v34 = _os_log_pack_size(12LL);
        uint64_t v25 = (char *)&v65 - ((__chkstk_darwin(v34) + 15) & 0xFFFFFFFFFFFFFFF0LL);
        unsigned int v35 = __error();
        uint64_t v36 = _os_log_pack_fill( v25,  v34,  *v35,  &dword_0,  "DHCP %s: RENEW/REBIND failed to terminate options",  v65);
        uint64_t v37 = nullsub_1(v8);
        *(_DWORD *)uint64_t v36 = 136315138;
        *(void *)(v36 + 4) = v37;
        goto LABEL_24;
      }

LABEL_25:
      sub_B424(a1, 5u);
      return;
    }

    bootp_client_enable_receive(*(void **)(v7 + 16), (uint64_t)sub_E1B4, a1, 5LL);
  }

  if (!timer_still_pending(*(void *)(v7 + 1760)) && timer_time_changed(*(void *)(v7 + 1760)))
  {
    v38.n128_f64[0] = current_time - *(double *)(v7 + 192);
    sub_13C60(a1, v38);
  }

  if (current_time >= *(double *)(v7 + 64))
  {
    uint64_t v31 = a1;
    unsigned int v30 = 10;
    goto LABEL_34;
  }

  unsigned int v39 = (double *)(v7 + 96);
  if (current_time >= *(double *)(v7 + 96))
  {
    sub_1175C(a1, 8u);
    unsigned int v40 = (unsigned int *)&G_ip_broadcast;
    unsigned int v39 = (double *)(v7 + 64);
  }

  else
  {
    sub_1175C(a1, 7u);
    unsigned int v40 = (unsigned int *)(v7 + 1736);
  }

  double v41 = (*v39 - current_time) * 0.5;
  unsigned int v42 = *v40;
  unsigned int v43 = *(_DWORD *)(v7 + 2332) + 1;
  *(_DWORD *)(v7 + 2332) = v43;
  uint64_t v44 = *(void *)(v7 + 176);
  *(_DWORD *)(v44 + 4) = bswap32(v43);
  double v45 = current_time + v41;
  *(_WORD *)(v44 + 8) = __rev16((int)(current_time - *(double *)(v7 + 1752)));
  if ((bootp_client_transmit( *(void **)(v7 + 16),  v42,  *(unsigned int *)(v7 + 1732),  (unsigned __int16)word_6C044,  (unsigned __int16)word_6C020,  (void *)v44,  *(unsigned int *)(v7 + 184)) & 0x80000000) != 0)
  {
    uint64_t v46 = sub_57538();
    uint64_t v47 = _SC_syslog_os_log_mapping(5LL);
    if (__SC_log_enabled(5LL, v46, v47))
    {
      uint64_t v48 = _os_log_pack_size(12LL);
      uint64_t v49 = (char *)&v65 - ((__chkstk_darwin(v48) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v50 = __error();
      uint64_t v51 = _os_log_pack_fill(v49, v48, *v50, &dword_0, "DHCP %s: RENEW/REBIND transmit failed", v65);
      uint64_t v52 = nullsub_1(v8);
      *(_DWORD *)uint64_t v51 = 136315138;
      *(void *)(v51 + 4) = v52;
      __SC_log_send(5LL, v46, v47, v49);
    }
  }

  double v53 = v45 - current_time;
  double v54 = current_time + 60.0;
  if (v45 - current_time >= 60.0) {
    double v54 = v45;
  }
  if (v45 - current_time <= 60.0) {
    double v53 = 60.0;
  }
  uint64_t v55 = (uint64_t)v53;
  *(double *)(v7 + 192) = v54;
  uint64_t v56 = sub_57538();
  uint64_t v57 = _SC_syslog_os_log_mapping(5LL);
  if (__SC_log_enabled(5LL, v56, v57))
  {
    uint64_t v58 = _os_log_pack_size(38LL);
    uint64_t v59 = (char *)&v65 - ((__chkstk_darwin(v58) + 15) & 0xFFFFFFFFFFFFFFF0LL);
    uint64_t v60 = __error();
    uint64_t v61 = _os_log_pack_fill( v59,  v58,  *v60,  &dword_0,  "DHCP %s: RENEW/REBIND waiting at %g for %ld.%06d",  v65,  *(double *)&v66,  v67,  v68);
    uint64_t v62 = nullsub_1(v8);
    double v63 = current_time - *(double *)(v7 + 1752);
    *(_DWORD *)uint64_t v61 = 136315906;
    *(void *)(v61 + 4) = v62;
    *(_WORD *)(v61 + 12) = 2048;
    *(double *)(v61 + 14) = v63;
    *(_WORD *)(v61 + 22) = 2048;
    *(void *)(v61 + 24) = v55;
    *(_WORD *)(v61 + 32) = 1024;
    *(_DWORD *)(v61 + 34) = 0;
    __SC_log_send(5LL, v56, v57, v59);
  }

  timer_set_relative(*(void *)(v7 + 1760), v55, 0, (uint64_t)sub_E1B4, a1, 2LL, 0LL);
  double v64 = *(double *)(v7 + 2344);
}

    uint64_t v27 = sub_553BC((uint64_t *)a1, (uint64_t)ifa_name);
    if (!v27)
    {
      uint64_t v44 = sub_57538();
      double v45 = _SC_syslog_os_log_mapping(5LL);
LABEL_45:
      uint64_t v46 = _os_log_pack_size(2LL);
      uint64_t v47 = (char *)&v71 - ((__chkstk_darwin(v46) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v48 = *__error();
      *(_WORD *)_os_log_pack_fill(v47, v46, v48, &dword_0, "interfaces: S_next_entry returns NULL", v71) = 0;
      __SC_log_send(5LL, v44, v45, v47);
      goto LABEL_82;
    }

    unsigned __int8 v20 = v27;
    *(_WORD *)(v27 + 16) = v3->ifa_flags;
LABEL_27:
    uint64_t v28 = ifa_addr->sa_data[4];
    if (v28 >= 0x11)
    {
      uint64_t v29 = sub_57538();
      unsigned int v30 = _SC_syslog_os_log_mapping(5LL);
      if (__SC_log_enabled(5LL, v29, v30))
      {
        uint64_t v31 = _os_log_pack_size(34LL);
        int v32 = (char *)&v71 - ((__chkstk_darwin(v31) + 15) & 0xFFFFFFFFFFFFFFF0LL);
        unsigned int v33 = __error();
        uint64_t v34 = _os_log_pack_fill( v32,  v31,  *v33,  &dword_0,  "%s: link type %d address length %d > %ld",  (const char *)v71,  v72,  (_DWORD)v74,  *((void *)&v74 + 1));
        unsigned int v35 = ifa_addr->sa_data[2];
        uint64_t v36 = ifa_addr->sa_data[4];
        *(_DWORD *)uint64_t v34 = v74;
        *(void *)(v34 + 4) = ifa_name;
        *(_WORD *)(v34 + 12) = 1024;
        *(_DWORD *)(v34 + 14) = v35;
        *(_WORD *)(v34 + 18) = 1024;
        *(_DWORD *)(v34 + 20) = v36;
        *(_WORD *)(v34 + 24) = 2048;
        uint64_t v28 = 16;
        *(void *)(v34 + 26) = 16LL;
        __SC_log_send(5LL, v29, v30, v32);
        uint64_t v10 = v75;
      }

      else
      {
        uint64_t v28 = 16;
      }
    }

    *(_BYTE *)(v20 + 74) = v28;
    memmove((void *)(v20 + 56), &ifa_addr->sa_data[ifa_addr->sa_data[3] + 6], v28);
    uint64_t v49 = ifa_addr->sa_data[2];
    *(_BYTE *)(v20 + 75) = v49;
    *(_WORD *)(v20 + 72) = *(_WORD *)ifa_addr->sa_data;
    ifa_data = (char *)v3->ifa_data;
    if (ifa_data) {
      uint64_t v49 = *ifa_data;
    }
    *(_BYTE *)(v20 + 18) = v49;
    if (sub_5518C(v10, (uint64_t)ifa_name, (uint64_t)v80))
    {
      if (*(_BYTE *)(v20 + 18) == 6)
      {
        uint64_t v51 = sub_5521C(v10, (uint64_t)ifa_name);
        if ((v51 & 0x4000) != 0) {
          *(_BYTE *)(v20 + 19) |= 8u;
        }
        if ((v80[16] & 0xE0) == 0x80)
        {
          uint64_t v52 = *(_BYTE *)(v20 + 19);
          *(_BYTE *)(v20 + 19) = v52 | 1;
          if ((v51 & 0x100000) != 0)
          {
            BOOL v66 = v52 | 3;
            goto LABEL_70;
          }

          keys = @"IOInterfaceName";
          values = (void *)CFStringCreateWithCString(0LL, ifa_name, 0x8000100u);
          int v77 = CFDictionaryCreate( 0LL,  (const void **)&keys,  (const void **)&values,  1LL,  &kCFTypeDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
          CFRelease(values);
          keys = @"IOPropertyMatch";
          double v53 = CFDictionaryCreate( 0LL,  (const void **)&keys,  (const void **)&v77,  1LL,  &kCFTypeDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
          CFRelease(v77);
          MatchingService = IOServiceGetMatchingService(v73, v53);
          if (MatchingService)
          {
            uint64_t v55 = MatchingService;
            CFProperty = IORegistryEntryCreateCFProperty(MatchingService, @"IO80211InterfaceRole", v71, 0);
            if (CFProperty)
            {
              uint64_t v57 = CFProperty;
              CFTypeID TypeID = CFStringGetTypeID();
              uint64_t v59 = CFGetTypeID(v57) == TypeID && CFEqual(v57, @"Infrastructure") != 0;
              CFRelease(v57);
              IOObjectRelease(v55);
              if (v59)
              {
                BOOL v66 = *(_BYTE *)(v20 + 19) | 0x10;
LABEL_70:
                *(_BYTE *)(v20 + 19) = v66;
              }
            }

            else
            {
              IOObjectRelease(v55);
            }
          }
        }

        else
        {
          uint64_t v60 = CFStringCreateWithCString(0LL, ifa_name, 0x8000100u);
          uint64_t v61 = _SCNetworkInterfaceCreateWithBSDName(0LL, v60, 0LL);
          if (v61)
          {
            uint64_t v62 = (const void *)v61;
            IsTetheredHotspot = _SCNetworkInterfaceIsTetheredHotspot();
            IsCarPlay = _SCNetworkInterfaceIsCarPlay(v62);
            CFRelease(v62);
            if (IsCarPlay)
            {
              if (IsTetheredHotspot) {
                unint64_t v65 = 36;
              }
              else {
                unint64_t v65 = 32;
              }
              CFRelease(v60);
            }

            else
            {
              CFRelease(v60);
              if (!IsTetheredHotspot) {
                goto LABEL_71;
              }
              unint64_t v65 = 4;
            }

            BOOL v66 = *(_BYTE *)(v20 + 19) | v65;
            goto LABEL_70;
          }

          CFRelease(v60);
        }
      }

void sub_E9DC(uint64_t a1, _DWORD *a2)
{
  uint64_t v4 = sub_194C4(a1);
  uint64_t v5 = sub_14834(a1);
  valuePtr = 0LL;
  if (!*a2 || !sub_194D4(a1) || !*(_DWORD *)(v4 + 56) || *(double *)(v4 + 64) == 0.0)
  {
LABEL_34:
    if (*(double *)(v4 + 2344) != 0.0)
    {
      uint64_t v31 = sub_1DDEC(a1);
      int v32 = CFDateCreate(0LL, *(CFAbsoluteTime *)(v4 + 2344));
      IOPMCancelScheduledPowerEvent(v32, v31, @"wake");
      CFRelease(v31);
      uint64_t v33 = sub_57538();
      uint64_t v34 = _SC_syslog_os_log_mapping(6LL);
      if (__SC_log_enabled(6LL, v33, v34))
      {
        uint64_t v35 = _os_log_pack_size(32LL);
        uint64_t v36 = (char *)&v85 - ((__chkstk_darwin(v35) + 15) & 0xFFFFFFFFFFFFFFF0LL);
        uint64_t v37 = __error();
        uint64_t v38 = _os_log_pack_fill(v36, v35, *v37, &dword_0, "DHCP %s: unscheduled old wake at %@ (%g)");
        uint64_t v39 = nullsub_1(v5);
        uint64_t v40 = *(void *)(v4 + 2344);
        *(_DWORD *)uint64_t v38 = 136315650;
        *(void *)(v38 + 4) = v39;
        *(_WORD *)(v38 + 12) = 2112;
        *(void *)(v38 + 14) = v32;
        *(_WORD *)(v38 + 22) = 2048;
        *(void *)(v38 + 24) = v40;
        __SC_log_send(6LL, v33, v34, v36);
      }

      CFRelease(v32);
      *(void *)(v4 + 2344) = 0LL;
    }

    return;
  }

  double current_time = timer_get_current_time();
  double v8 = *(double *)(v4 + 64);
  if (current_time >= v8)
  {
    uint64_t v13 = sub_57538();
    uint64_t v14 = _SC_syslog_os_log_mapping(5LL);
    if (__SC_log_enabled(5LL, v13, v14))
    {
      uint64_t v15 = _os_log_pack_size(12LL);
      int v16 = (char *)&v85 - ((__chkstk_darwin(v15) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      unsigned int v17 = __error();
      uint64_t v18 = _os_log_pack_fill(v16, v15, *v17, &dword_0, "DHCP %s: lease is already expired", v85);
      uint64_t v19 = nullsub_1(v5);
      *(_DWORD *)uint64_t v18 = 136315138;
      *(void *)(v18 + 4) = v19;
      __SC_log_send(5LL, v13, v14, v16);
    }

    unsigned __int8 v20 = "lease is expired";
    goto LABEL_31;
  }

  double v9 = *(double *)(v4 + 192);
  double v10 = (double)dword_6C078;
  double v11 = *(double *)(v4 + 96);
  if (current_time < v9 && v9 - current_time >= v10)
  {
    if (v11 <= v9)
    {
      uint64_t v12 = 0LL;
    }

    else
    {
      uint64_t v12 = (const char *)(uint64_t)((v11 - v9) * 0.5);
      valuePtr = v12;
    }

    unsigned __int8 v20 = "wake at renew_rebind_time";
    goto LABEL_30;
  }

  double v21 = v11 - current_time;
  if (current_time < v11 && v21 >= v10)
  {
    if (v8 <= v11)
    {
      uint64_t v12 = 0LL;
    }

    else
    {
      uint64_t v12 = (const char *)(uint64_t)((v8 - v11) * 0.5);
      valuePtr = v12;
    }

    unsigned __int8 v20 = "wake at t2";
    goto LABEL_29;
  }

  if (*(_DWORD *)v4)
  {
    if (current_time < v11)
    {
      LODWORD(v6) = dword_6C074;
      if (v21 >= (double)v6)
      {
        uint64_t v12 = 0LL;
        unsigned __int8 v20 = "wake at t2 (allow short first wake)";
LABEL_29:
        double v9 = v11;
        goto LABEL_30;
      }
    }
  }

  unsigned __int8 v20 = "expiration is too soon";
  if (current_time >= v8 || v8 - current_time < v10) {
    goto LABEL_31;
  }
  uint64_t v12 = 0LL;
  double v9 = current_time + (double)dword_6C078;
  unsigned __int8 v20 = "wake in min_interval";
LABEL_30:
  if (v9 == 0.0)
  {
LABEL_31:
    uint64_t v22 = sub_57538();
    uint64_t v23 = _SC_syslog_os_log_mapping(5LL);
    if (__SC_log_enabled(5LL, v22, v23))
    {
      uint64_t v24 = v20;
      uint64_t v25 = _os_log_pack_size(22LL);
      uint64_t v86 = &v85;
      uint64_t v26 = (char *)&v85 - ((__chkstk_darwin(v25) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v27 = __error();
      uint64_t v28 = _os_log_pack_fill( v26,  v25,  *v27,  &dword_0,  "DHCP %s: can't schedule wake-up, %s",  v85,  (const char *)v86);
      uint64_t v29 = nullsub_1(v5);
      *(_DWORD *)uint64_t v28 = 136315394;
      *(void *)(v28 + 4) = v29;
      *(_WORD *)(v28 + 12) = 2080;
      *(void *)(v28 + 14) = v24;
      __SC_log_send(5LL, v22, v23, v26);
    }

    uint64_t v30 = nullsub_1(v5);
    sub_118BC(v30, (void *)(v4 + 56), current_time);
    a2[1] = 0;
    goto LABEL_34;
  }

  uint64_t v86 = (const char **)v12;
  uint64_t v41 = sub_57538();
  uint64_t v42 = _SC_syslog_os_log_mapping(5LL);
  if (__SC_log_enabled(5LL, v41, v42))
  {
    unsigned int v43 = v20;
    uint64_t v44 = _os_log_pack_size(32LL);
    uint64_t v85 = (const char *)&v85;
    double v45 = (char *)&v85 - ((__chkstk_darwin(v44) + 15) & 0xFFFFFFFFFFFFFFF0LL);
    uint64_t v46 = __error();
    uint64_t v47 = _os_log_pack_fill( v45,  v44,  *v46,  &dword_0,  "DHCP %s: next wake-up at %g, %s",  v85,  *(double *)&v86,  valuePtr);
    uint64_t v48 = nullsub_1(v5);
    *(_DWORD *)uint64_t v47 = 136315650;
    *(void *)(v47 + 4) = v48;
    *(_WORD *)(v47 + 12) = 2048;
    *(double *)(v47 + 14) = v9;
    *(_WORD *)(v47 + 22) = 2080;
    *(void *)(v47 + 24) = v43;
    __SC_log_send(5LL, v41, v42, v45);
  }

  uint64_t v49 = nullsub_1(v5);
  sub_118BC(v49, (void *)(v4 + 56), current_time);
  if (v9 == *(double *)(v4 + 2344))
  {
    uint64_t v50 = sub_57538();
    uint64_t v51 = _SC_syslog_os_log_mapping(6LL);
    if (__SC_log_enabled(6LL, v50, v51))
    {
      uint64_t v52 = _os_log_pack_size(22LL);
      double v53 = (char *)&v85 - ((__chkstk_darwin(v52) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      double v54 = __error();
      uint64_t v55 = _os_log_pack_fill( v53,  v52,  *v54,  &dword_0,  "DHCP %s: wake at %g already scheduled",  v85,  *(double *)&v86);
      uint64_t v56 = nullsub_1(v5);
      *(_DWORD *)uint64_t v55 = 136315394;
      *(void *)(v55 + 4) = v56;
      *(_WORD *)(v55 + 12) = 2048;
      *(double *)(v55 + 14) = v9;
      __SC_log_send(6LL, v50, v51, v53);
    }
  }

  else
  {
    uint64_t v57 = sub_1DDEC(a1);
    double v58 = *(double *)(v4 + 2344);
    if (v58 != 0.0)
    {
      uint64_t v59 = CFDateCreate(0LL, v58);
      IOPMCancelScheduledPowerEvent(v59, v57, @"wake");
      uint64_t v60 = sub_57538();
      uint64_t v61 = _SC_syslog_os_log_mapping(6LL);
      if (__SC_log_enabled(6LL, v60, v61))
      {
        uint64_t v62 = _os_log_pack_size(32LL);
        double v63 = (char *)&v85 - ((__chkstk_darwin(v62) + 15) & 0xFFFFFFFFFFFFFFF0LL);
        double v64 = __error();
        uint64_t v65 = _os_log_pack_fill(v63, v62, *v64, &dword_0, "DHCP %s: unscheduled old wake at %@ (%g)");
        uint64_t v66 = nullsub_1(v5);
        uint64_t v67 = *(void *)(v4 + 2344);
        *(_DWORD *)uint64_t v65 = 136315650;
        *(void *)(v65 + 4) = v66;
        *(_WORD *)(v65 + 12) = 2112;
        *(void *)(v65 + 14) = v59;
        *(_WORD *)(v65 + 22) = 2048;
        *(void *)(v65 + 24) = v67;
        __SC_log_send(6LL, v60, v61, v63);
      }

      CFRelease(v59);
    }

    CFDateRef v68 = CFDateCreate(0LL, v9);
    Mutable = CFDictionaryCreateMutable(0LL, 0LL, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    CFDictionarySetValue(Mutable, @"scheduledby", v57);
    CFDictionarySetValue(Mutable, @"time", v68);
    if ((uint64_t)v86 >= 1)
    {
      CFNumberRef v70 = CFNumberCreate(kCFAllocatorDefault, kCFNumberLongType, &valuePtr);
      CFDictionarySetValue(Mutable, @"leeway", v70);
      CFRelease(v70);
    }

    int v71 = IOPMRequestSysWake(Mutable);
    CFRelease(Mutable);
    CFRelease(v57);
    uint64_t v72 = sub_57538();
    if (v71)
    {
      uint64_t v73 = _SC_syslog_os_log_mapping(5LL);
      if (__SC_log_enabled(5LL, v72, v73))
      {
        uint64_t v74 = _os_log_pack_size(32LL);
        int v75 = (char *)&v85 - ((__chkstk_darwin(v74) + 15) & 0xFFFFFFFFFFFFFFF0LL);
        int v76 = __error();
        uint64_t v77 = _os_log_pack_fill(v75, v74, *v76, &dword_0, "DHCP %s: failed to schedule wake at %@ (%g)");
        uint64_t v78 = nullsub_1(v5);
        *(_DWORD *)uint64_t v77 = 136315650;
        *(void *)(v77 + 4) = v78;
        *(_WORD *)(v77 + 12) = 2112;
        *(void *)(v77 + 14) = v68;
        *(_WORD *)(v77 + 22) = 2048;
        *(double *)(v77 + 24) = v9;
        __SC_log_send(5LL, v72, v73, v75);
      }

      *(void *)(v4 + 2344) = 0LL;
      a2[1] = 0;
    }

    else
    {
      uint64_t v79 = _SC_syslog_os_log_mapping(6LL);
      if (__SC_log_enabled(6LL, v72, v79))
      {
        uint64_t v80 = _os_log_pack_size(32LL);
        uint64_t v81 = (char *)&v85 - ((__chkstk_darwin(v80) + 15) & 0xFFFFFFFFFFFFFFF0LL);
        uint64_t v82 = __error();
        uint64_t v83 = _os_log_pack_fill(v81, v80, *v82, &dword_0, "DHCP %s: scheduled wake at %@ (%g)");
        uint64_t v84 = nullsub_1(v5);
        *(_DWORD *)uint64_t v83 = 136315650;
        *(void *)(v83 + 4) = v84;
        *(_WORD *)(v83 + 12) = 2112;
        *(void *)(v83 + 14) = v68;
        *(_WORD *)(v83 + 22) = 2048;
        *(double *)(v83 + 24) = v9;
        __SC_log_send(6LL, v72, v79, v81);
      }

      *(double *)(v4 + 2344) = v9;
    }

    CFRelease(v68);
  }

void sub_F3C0(_DWORD *a1, int a2)
{
  uint64_t v5 = sub_19384((uint64_t)a1);
  int v6 = v4;
  sub_BC50(a1, a2, (int *)&v5);
}

double dhcp_get_lease_from_options(uint64_t a1, unsigned int *a2, unsigned int *a3, unsigned int *a4)
{
  double v8 = sub_50E4C(a1, 51, 4);
  double v9 = sub_50E4C(a1, 58, 4);
  double v10 = sub_50E4C(a1, 59, 4);
  if (v8)
  {
    unsigned int v12 = bswap32(*(_DWORD *)v8);
    if (v12 <= 3) {
      unsigned int v12 = 3;
    }
    *a2 = v12;
  }

  if (v9)
  {
    unsigned int v13 = bswap32(*(_DWORD *)v9);
    if (v13 <= 2) {
      unsigned int v13 = 2;
    }
    *a3 = v13;
  }

  if (v10)
  {
    unsigned int v14 = bswap32(*(_DWORD *)v10);
    if (v14 <= 2) {
      unsigned int v14 = 2;
    }
    *a4 = v14;
  }

  if (!v8)
  {
    if (!v9)
    {
      if (v10)
      {
        unsigned int v15 = *a4;
        *a2 = *a4;
        if (v15 == -1) {
          goto LABEL_26;
        }
      }

      else
      {
        unsigned int v15 = 3600;
        *a2 = 3600;
      }

LABEL_28:
      *a3 = v15 >> 1;
      LODWORD(result) = *a2;
      double result = (double)*(unint64_t *)&result * 0.875;
      *a4 = result;
      return result;
    }

    unsigned int v15 = *a3;
    *a2 = *a3;
    if (v15 != -1) {
      goto LABEL_19;
    }
LABEL_26:
    *a4 = 0;
    *a3 = 0;
    return result;
  }

  unsigned int v15 = *a2;
  if (*a2 == -1) {
    goto LABEL_26;
  }
  if (!v9) {
    goto LABEL_28;
  }
LABEL_19:
  if (!v10 || *a3 >= v15 || *a4 >= v15 || *a4 < *a3) {
    goto LABEL_28;
  }
  return result;
}

              IPv6AWDReportSetAutoconfAddressDetached(v12);
              goto LABEL_29;
            }
          }

          else if ((v17 & 0x10) == 0)
          {
            goto LABEL_27;
          }

          IPv6AWDReportSetAutoconfAddressDeprecated(v12);
          if ((*(_DWORD *)v16 & 8) == 0) {
            goto LABEL_29;
          }
          goto LABEL_28;
        }

        unsigned int v14 = 0;
LABEL_38:
        sub_36090((uint64_t)&v62);
        if (v8) {
          IPv6AWDReportSetAPNName(v12, v8);
        }
        uint64_t v25 = v58;
        if (v14)
        {
          uint64_t v26 = *(void *)(v6 + 16);
          if (v26)
          {
            uint64_t v27 = sub_5261C(v26);
            uint64_t v28 = sub_52808(*(void *)(v6 + 16), v59);
            IPv6AWDReportSetRouterLifetime(v12, v27);
            IPv6AWDReportSetPrefixPreferredLifetime(v12, v28);
            IPv6AWDReportSetPrefixValidLifetime(v12, LODWORD(v59[0]));
            if (v9 == 2)
            {
              if ((_DWORD)v27 != 0xFFFF) {
                IPv6AWDReportSetRouterLifetimeNotMaximum(v12);
              }
              if (LODWORD(v59[0]) != -1) {
                IPv6AWDReportSetPrefixLifetimeNotInfinite(v12);
              }
            }
          }
        }

        uint64_t v29 = *(void *)(v6 + 16);
        if (v29 && sub_528A4(v29, 0LL, 0LL))
        {
          IPv6AWDReportSetAutoconfRDNSS(v12);
          if (sub_52960(*(void *)(v6 + 16), 0LL, 0LL)) {
            IPv6AWDReportSetAutoconfDNSSL(v12);
          }
          uint64_t v30 = 1;
        }

        else
        {
          uint64_t v30 = 0;
        }

        uint64_t v31 = *(void *)(v6 + 24);
        if (v31 && sub_3FA04(v31, &v61))
        {
          IPv6AWDReportSetDHCPv6DNSServers(v12);
          if (v61) {
            IPv6AWDReportSetDHCPv6DNSDomainList(v12);
          }
          uint64_t v30 = 1;
        }

        if (a2)
        {
          int v32 = sub_51A70(*(void *)(v6 + 16));
          uint64_t v33 = *(double *)(v6 + 40);
          if (v32 > v33) {
            IPv6AWDReportSetAutoconfAddressAcquisitionSeconds(v12, (v32 - v33));
          }
          uint64_t v34 = *(double *)(v6 + 48);
          if (v34 != 0.0)
          {
            uint64_t v35 = *(double *)(v6 + 40);
            if (v34 > v35) {
              IPv6AWDReportSetDHCPv6AddressAcquisitionSeconds(v12, (v34 - v35));
            }
          }

          if (v30)
          {
            double current_time = timer_get_current_time();
            uint64_t v37 = *(double *)(v6 + 40);
            if (current_time > v37) {
              IPv6AWDReportSetDNSConfigurationAcquisitionSeconds(v12, (current_time - v37));
            }
          }

          uint64_t v38 = 1;
        }

        else
        {
          if (*(_DWORD *)(v6 + 80)) {
            IPv6AWDReportSetRouterLifetimeZero(v12);
          }
          uint64_t v38 = 0;
        }

        *(_DWORD *)(v6 + 56) = v38;
        uint64_t v39 = sub_14834(a1);
        if (sub_54228(v39) == 255)
        {
          uint64_t v40 = sub_194C4(a1);
          if (*(void *)(v40 + 16))
          {
            uint64_t v41 = v40;
            uint64_t v42 = sub_54F6C(v39);
            if (sub_357F0(v42, (uint64_t)v59))
            {
              unsigned int v43 = (void *)sub_51AB4(*(void *)(v41 + 16));
              if (*v43 == v59[0] && v43[1] == v59[1]) {
                IPv6AWDReportSetRouterSourceAddressCollision(v12);
              }
            }
          }
        }

        double v45 = *(_DWORD *)(v6 + 36);
        if (v45 >= 3) {
          uint64_t v46 = 3LL;
        }
        else {
          uint64_t v46 = v45;
        }
        IPv6AWDReportSetRouterSolicitationCount(v12, v46);
        uint64_t v47 = (const char *)nullsub_1(v25);
        if (!sub_3501C(v47, (uint64_t)v59))
        {
          if (v59[23]) {
            IPv6AWDReportSetExpiredPrefixCount(v12);
          }
          if (v59[24]) {
            IPv6AWDReportSetExpiredDefaultRouterCount(v12);
          }
        }

        uint64_t v48 = sub_54F6C((uint64_t)v25);
        uint64_t v49 = sub_34B04(v48, &v60);
        if ((int)v49 >= 1)
        {
          IPv6AWDReportSetDefaultRouterCount(v12, v49);
          IPv6AWDReportSetPrefixCount(v12, v60);
        }

        if (*(_DWORD *)(v6 + 68)) {
          IPv6AWDReportSetAutoconfRestarted(v12);
        }
        nullsub_1(v12);
        uint64_t v50 = sub_57538();
        uint64_t v51 = _SC_syslog_os_log_mapping(5LL);
        if (__SC_log_enabled(5LL, v50, v51))
        {
          uint64_t v52 = _os_log_pack_size(32LL);
          double v53 = (char *)&v59[-1] - ((__chkstk_darwin(v52) + 15) & 0xFFFFFFFFFFFFFFF0LL);
          double v54 = __error();
          uint64_t v55 = _os_log_pack_fill(v53, v52, *v54, &dword_0, "%s: submitted AWD %s report %@");
          uint64_t v56 = nullsub_1(v25);
          uint64_t v57 = "success";
          *(_DWORD *)uint64_t v55 = 136315650;
          *(void *)(v55 + 4) = v56;
          if (!a2) {
            uint64_t v57 = "failure";
          }
          *(_WORD *)(v55 + 12) = 2080;
          *(void *)(v55 + 14) = v57;
          *(_WORD *)(v55 + 22) = 2112;
          *(void *)(v55 + 24) = v12;
          __SC_log_send(5LL, v50, v51, v53);
        }

        CFRelease(v12);
      }
    }
  }

_DWORD *sub_F560(uint64_t a1, _DWORD *a2)
{
  uint64_t v3 = (unsigned __int8 *)sub_50E8C(a1, 121, &v7);
  if (!v3) {
    return 0LL;
  }
  int v4 = v3;
  uint64_t v5 = sub_53924(v3, v7, a2);
  free(v4);
  return v5;
}

unsigned __int8 *sub_F5BC(uint64_t a1, int a2, _DWORD *a3)
{
  int v5 = sub_F630(a1, a2);
  if (v5 == -1)
  {
    uint64_t v6 = a1;
    int v7 = 54;
  }

  else
  {
    if (v5) {
      goto LABEL_7;
    }
    uint64_t v6 = a1;
    int v7 = 6;
  }

  double result = sub_50E4C(v6, v7, 4);
  if (!result) {
    return result;
  }
  int v5 = *(_DWORD *)result;
LABEL_7:
  *a3 = v5;
  return (_BYTE *)(&dword_0 + 1);
}

uint64_t sub_F630(uint64_t a1, int a2)
{
  int v4 = sub_50E4C(a1, 3, 4);
  if (v4)
  {
    if (*(_DWORD *)v4 == a2) {
      return 0LL;
    }
    else {
      return *(unsigned int *)v4;
    }
  }

  else
  {
    uint64_t v6 = sub_F560(a1, &v10);
    if (v6)
    {
      int v7 = v6;
      double v8 = sub_53CDC(v6, v10);
      if (v8) {
        uint64_t v5 = v8[2];
      }
      else {
        uint64_t v5 = 0xFFFFFFFFLL;
      }
      free(v7);
    }

    else
    {
      return 0xFFFFFFFFLL;
    }
  }

  return v5;
}

uint64_t sub_F6B8(uint64_t a1, unsigned int a2)
{
  uint64_t v4 = sub_14834(a1);
  *(_DWORD *)(sub_194C4(a1) + 1584) = a2;
  uint64_t v5 = sub_57538();
  uint64_t v6 = _SC_syslog_os_log_mapping(6LL);
  uint64_t result = __SC_log_enabled(6LL, v5, v6);
  if ((_DWORD)result)
  {
    uint64_t v8 = _os_log_pack_size(22LL);
    double v9 = (char *)v14 - ((__chkstk_darwin(v8) + 15) & 0xFFFFFFFFFFFFFFF0LL);
    int v10 = __error();
    uint64_t v11 = _os_log_pack_fill(v9, v8, *v10, &dword_0, "INFORM %s: %s", v14[0], v14[1]);
    uint64_t v12 = nullsub_1(v4);
    if (a2 > 4) {
      unsigned int v13 = "<unknown>";
    }
    else {
      unsigned int v13 = off_64BF0[a2];
    }
    *(_DWORD *)uint64_t v11 = 136315394;
    *(void *)(v11 + 4) = v12;
    *(_WORD *)(v11 + 12) = 2080;
    *(void *)(v11 + 14) = v13;
    return __SC_log_send(6LL, v5, v6, v9);
  }

  return result;
}

uint64_t sub_F818(uint64_t a1, unsigned int a2)
{
  return sub_F6B8(a1, 0);
}

void sub_F850(_DWORD *a1, int a2, uint64_t a3)
{
  double current_time = timer_get_current_time();
  uint64_t v7 = sub_14834((uint64_t)a1);
  uint64_t v8 = sub_194C4((uint64_t)a1);
  uint64_t v9 = v8;
  if (a2 == 5)
  {
    LODWORD(v73[0]) = 0;
    else {
      BOOL v20 = 0;
    }
    if (v20)
    {
      unsigned int v21 = sub_511CC(a3 + 16, (unsigned __int8 *)off_6C010, dword_6C018);
      unsigned int v22 = v21;
      if (!*(_DWORD *)(v9 + 1556) || v21 > *(_DWORD *)(v9 + 1560))
      {
        sub_50CA0(v9 + 40);
        memmove((void *)(v9 + 56), *(const void **)a3, *(int *)(a3 + 8));
        unsigned int v23 = *(_DWORD *)(a3 + 8);
        *(_DWORD *)(v9 + 1556) = v23;
        *(_DWORD *)(v9 + 1560) = v22;
        sub_50F80((char **)(v9 + 40), v9 + 56, v23, 0LL);
        *(_DWORD *)(v9 + 1568) = v72;
        if (v22 == dword_6C018)
        {
LABEL_28:
          sub_108C0(a1);
          return;
        }

        if (*(_DWORD *)(v9 + 16)) {
          return;
        }
        uint64_t v24 = G_gather_secs;
        uint64_t v25 = sub_57538();
        uint64_t v26 = _SC_syslog_os_log_mapping(5LL);
        if (__SC_log_enabled(5LL, v25, v26))
        {
          uint64_t v27 = _os_log_pack_size(22LL);
          uint64_t v28 = (char *)&v68 - ((__chkstk_darwin(v27) + 15) & 0xFFFFFFFFFFFFFFF0LL);
          uint64_t v29 = __error();
          uint64_t v30 = _os_log_pack_fill( v28,  v27,  *v29,  &dword_0,  "INFORM %s: gathering began at %g",  v68,  *(double *)&v69);
          uint64_t v31 = nullsub_1(v7);
          double v32 = current_time - *(double *)(v9 + 1576);
          *(_DWORD *)uint64_t v30 = 136315394;
          *(void *)(v30 + 4) = v31;
          *(_WORD *)(v30 + 12) = 2048;
          *(double *)(v30 + 14) = v32;
          __SC_log_send(5LL, v25, v26, v28);
        }

        *(_DWORD *)(v9 + 16) = 1;
        uint64_t v33 = *(void *)(v9 + 1592);
        uint64_t v34 = v24;
        uint64_t v35 = (uint64_t)a1;
        uint64_t v36 = 2LL;
        goto LABEL_36;
      }
    }
  }

  else
  {
    if (a2 != 2)
    {
      if (a2) {
        return;
      }
      sub_F6B8((uint64_t)a1, 2u);
      *(double *)(v9 + 1576) = current_time;
      sub_9F84((uint64_t)a1);
      int v10 = (const void *)sub_54E44(v7);
      unsigned __int8 v11 = sub_54E28(v7);
      unsigned __int8 v12 = sub_54230(v7);
      unsigned int v13 = sub_10010((char *)(v9 + 1604), 8, v10, v11, v12, 0LL, 0, 0, v73);
      *(void *)(v9 + 24) = v13;
      if (!v13)
      {
        uint64_t v14 = sub_57538();
        uint64_t v15 = _SC_syslog_os_log_mapping(5LL);
        if (__SC_log_enabled(5LL, v14, v15))
        {
          uint64_t v37 = _os_log_pack_size(12LL);
          unsigned int v17 = (char *)&v68 - ((__chkstk_darwin(v37) + 15) & 0xFFFFFFFFFFFFFFF0LL);
          uint64_t v38 = *__error();
          uint64_t v19 = _os_log_pack_fill(v17, v37, v38, &dword_0, "INFORM %s: make_dhcp_request failed");
          goto LABEL_22;
        }

LABEL_23:
        sub_F818((uint64_t)a1, 5u);
        return;
      }

      *((_DWORD *)v13 + 3) = sub_193D8((uint64_t)a1);
      sub_104C8((uint64_t)a1, v73);
      if (sub_512B8((uint64_t)v73, 255, 0, 0LL))
      {
        uint64_t v14 = sub_57538();
        uint64_t v15 = _SC_syslog_os_log_mapping(5LL);
        if (__SC_log_enabled(5LL, v14, v15))
        {
          uint64_t v16 = _os_log_pack_size(12LL);
          unsigned int v17 = (char *)&v68 - ((__chkstk_darwin(v16) + 15) & 0xFFFFFFFFFFFFFFF0LL);
          uint64_t v18 = *__error();
          uint64_t v19 = _os_log_pack_fill(v17, v16, v18, &dword_0, "INFORM %s: failed to terminate options");
LABEL_22:
          uint64_t v39 = v19;
          uint64_t v40 = nullsub_1(v7);
          *(_DWORD *)uint64_t v39 = 136315138;
          *(void *)(v39 + 4) = v40;
          __SC_log_send(5LL, v14, v15, v17);
          goto LABEL_23;
        }

        goto LABEL_23;
      }

      unsigned int v41 = sub_5147C((uint64_t)v73) + 240;
      if (v41 <= 0x12C) {
        unsigned int v41 = 300;
      }
      *(_DWORD *)(v9 + 32) = v41;
      *(_DWORD *)(v9 + 1600) = 0;
      *(_DWORD *)(v9 + 16) = 0;
      *(_DWORD *)(v9 + 2160) = G_initial_wait_secs;
      bootp_client_enable_receive(*(void **)(v9 + 8), (uint64_t)sub_F850, (uint64_t)a1, 5LL);
      *(_DWORD *)(v9 + 1560) = 0;
      ++*(_DWORD *)(v9 + 2152);
    }

    if (*(_DWORD *)(v9 + 16) == 1) {
      goto LABEL_28;
    }
    int v42 = *(_DWORD *)(v9 + 1600);
    int v43 = v42 + 1;
    *(_DWORD *)(v9 + 1600) = v42 + 1;
    if (v42 >= 1)
    {
      unint64_t v44 = sub_19384((uint64_t)a1);
      if (!HIDWORD(v44) && (_DWORD)v44)
      {
        sub_9FD8((uint64_t)a1);
        return;
      }

      int v43 = *(_DWORD *)(v9 + 1600);
    }

    if (v43 > G_max_retries + 1)
    {
      uint64_t v45 = sub_194C4((uint64_t)a1);
      sub_9F84((uint64_t)a1);
      sub_F6B8((uint64_t)a1, 4u);
      uint64_t v33 = *(void *)(v45 + 1592);
      uint64_t v34 = 60LL;
      uint64_t v35 = (uint64_t)a1;
      uint64_t v36 = 0LL;
LABEL_36:
      timer_set_relative(v33, v34, 0, (uint64_t)sub_F850, v35, v36, 0LL);
      return;
    }

    uint64_t v46 = *(void *)(v9 + 24);
    *(_DWORD *)(v46 + 4) = bswap32(*(_DWORD *)(v9 + 2152));
    *(_WORD *)(v46 + 8) = __rev16((int)(current_time - *(double *)(v9 + 1576)));
    if ((bootp_client_transmit( *(void **)(v9 + 8),  0xFFFFFFFF,  0LL,  (unsigned __int16)word_6C044,  (unsigned __int16)word_6C020,  (void *)v46,  *(unsigned int *)(v9 + 32)) & 0x80000000) != 0)
    {
      uint64_t v47 = sub_57538();
      uint64_t v48 = _SC_syslog_os_log_mapping(5LL);
      if (__SC_log_enabled(5LL, v47, v48))
      {
        uint64_t v49 = _os_log_pack_size(12LL);
        uint64_t v50 = (char *)&v68 - ((__chkstk_darwin(v49) + 15) & 0xFFFFFFFFFFFFFFF0LL);
        uint64_t v51 = __error();
        uint64_t v52 = _os_log_pack_fill(v50, v49, *v51, &dword_0, "INFORM %s: transmit failed", v68);
        uint64_t v53 = nullsub_1(v7);
        *(_DWORD *)uint64_t v52 = 136315138;
        *(void *)(v52 + 4) = v53;
        __SC_log_send(5LL, v47, v48, v50);
      }
    }

    uint64_t v54 = *(int *)(v9 + 2160);
    unsigned int v55 = sub_558D0(0LL, 999999LL);
    int v56 = v55;
    uint64_t v57 = sub_57538();
    uint64_t v58 = _SC_syslog_os_log_mapping(5LL);
    if (__SC_log_enabled(5LL, v57, v58))
    {
      uint64_t v59 = _os_log_pack_size(38LL);
      uint64_t v69 = &v68;
      uint64_t v60 = __chkstk_darwin(v59);
      uint64_t v70 = v55;
      uint64_t v61 = (char *)&v68 - ((v60 + 15) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v62 = __error();
      uint64_t v63 = _os_log_pack_fill( v61,  v59,  *v62,  &dword_0,  "INFORM %s: waiting at %g for %ld.%06d",  v68,  *(double *)&v69,  v70,  v71);
      uint64_t v64 = nullsub_1(v7);
      double v65 = current_time - *(double *)(v9 + 1576);
      *(_DWORD *)uint64_t v63 = 136315906;
      *(void *)(v63 + 4) = v64;
      *(_WORD *)(v63 + 12) = 2048;
      *(double *)(v63 + 14) = v65;
      *(_WORD *)(v63 + 22) = 2048;
      *(void *)(v63 + 24) = v54;
      *(_WORD *)(v63 + 32) = 1024;
      *(_DWORD *)(v63 + 34) = v55;
      uint64_t v66 = v61;
      int v56 = v70;
      __SC_log_send(5LL, v57, v58, v66);
    }

    timer_set_relative(*(void *)(v9 + 1592), v54, v56, (uint64_t)sub_F850, (uint64_t)a1, 2LL, 0LL);
    int v67 = 2 * *(_DWORD *)(v9 + 2160);
    if (v67 >= G_max_wait_secs) {
      int v67 = G_max_wait_secs;
    }
    *(_DWORD *)(v9 + 2160) = v67;
  }

    uint64_t v14 = (v14 + 1);
  }

  while (v11 != (_DWORD)v14);
  uint64_t result = v56;
  a6 = v57;
  uint64_t v54 = v62;
  if (!v62)
  {
LABEL_28:
    free(result);
    goto LABEL_29;
  }

  sub_4FA18((const void **)&v27);
  return qword_6C298 != 0;
}

char *sub_10010( char *a1, int a2, const void *a3, int a4, unsigned int a5, const void *a6, unsigned int a7, unsigned int a8, uint64_t *a9)
{
  uint64_t v14 = a1;
  if (a6) {
    BOOL v15 = a7 == 0;
  }
  else {
    BOOL v15 = 1;
  }
  if (v15) {
    char v16 = a4;
  }
  else {
    char v16 = 0;
  }
  if (v15) {
    unsigned int v17 = a5;
  }
  else {
    unsigned int v17 = a7;
  }
  if (v15) {
    uint64_t v18 = a3;
  }
  else {
    uint64_t v18 = a6;
  }
  bzero(a1, 0x224uLL);
  v14[1] = a4;
  char *v14 = 1;
  if (a4 == 24)
  {
    v14[2] = 0;
    if (v18 == a3) {
      char v16 = 27;
    }
  }

  else
  {
    v14[2] = a5;
    memmove(v14 + 28, a3, a5);
  }

  if (a8 & 1 | G_must_broadcast) {
    *((_WORD *)v14 + 5) = 128;
  }
  *((_DWORD *)v14 + 59) = 1666417251;
  sub_512B0((uint64_t)a9, v14 + 240, 308);
  if (sub_514A4((uint64_t)a9, a2))
  {
    uint64_t v19 = sub_57538();
    uint64_t v20 = _SC_syslog_os_log_mapping(5LL);
    if (__SC_log_enabled(5LL, v19, v20))
    {
      uint64_t v21 = _os_log_pack_size(28LL);
      unsigned int v22 = (char *)&v52 - ((__chkstk_darwin(v21) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      unsigned int v23 = __error();
      uint64_t v24 = _os_log_pack_fill( v22,  v21,  *v23,  &dword_0,  "%s: couldn't add dhcp message tag %d, %s",  v52,  (_DWORD)v53,  v54);
      uint64_t v25 = sub_514D0(a9);
      *(_DWORD *)uint64_t v24 = 136315650;
      *(void *)(v24 + 4) = "make_dhcp_request";
      *(_WORD *)(v24 + 12) = 1024;
      *(_DWORD *)(v24 + 14) = a2;
      *(_WORD *)(v24 + 18) = 2080;
      *(void *)(v24 + 20) = v25;
      __SC_log_send(5LL, v19, v20, v22);
    }

    return 0LL;
  }

  if (a2 != 4 && a2 != 7)
  {
    HIWORD(v52) = -9211;
    if (sub_512B8((uint64_t)a9, 57, 2, (char *)&v52 + 6))
    {
      uint64_t v29 = sub_57538();
      uint64_t v30 = _SC_syslog_os_log_mapping(5LL);
      if (__SC_log_enabled(5LL, v29, v30))
      {
        uint64_t v35 = _os_log_pack_size(22LL);
        double v32 = (char *)&v52 - ((__chkstk_darwin(v35) + 15) & 0xFFFFFFFFFFFFFFF0LL);
        uint64_t v36 = *__error();
        uint64_t v34 = _os_log_pack_fill(v32, v35, v36, &dword_0, "%s: couldn't add max message size, %s");
        goto LABEL_33;
      }

      return 0LL;
    }
  }

  uint64_t v26 = malloc((int)(v17 + 1));
  if (!v26)
  {
    uint64_t v42 = sub_57538();
    uint64_t v43 = _SC_syslog_os_log_mapping(5LL);
    if (__SC_log_enabled(5LL, v42, v43))
    {
      uint64_t v44 = _os_log_pack_size(28LL);
      uint64_t v45 = (char *)&v52 - ((__chkstk_darwin(v44) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v46 = __error();
      uint64_t v47 = _os_log_pack_fill( v45,  v44,  *v46,  &dword_0,  "%s: malloc failed, %s (%d)",  v52,  v53,  (_DWORD)v54);
      uint64_t v48 = __error();
      uint64_t v49 = strerror(*v48);
      int v50 = *__error();
      *(_DWORD *)uint64_t v47 = 136315650;
      *(void *)(v47 + 4) = "make_dhcp_request";
      *(_WORD *)(v47 + 12) = 2080;
      *(void *)(v47 + 14) = v49;
      *(_WORD *)(v47 + 22) = 1024;
      *(_DWORD *)(v47 + 24) = v50;
      uint64_t v39 = v42;
      uint64_t v40 = v43;
      unsigned int v41 = v45;
      goto LABEL_36;
    }

    return 0LL;
  }

  uint64_t v27 = v26;
  _BYTE *v26 = v16;
  memmove(v26 + 1, v18, (int)v17);
  int v28 = sub_512B8((uint64_t)a9, 61, v17 + 1, v27);
  free(v27);
  if (v28)
  {
    uint64_t v29 = sub_57538();
    uint64_t v30 = _SC_syslog_os_log_mapping(5LL);
    if (__SC_log_enabled(5LL, v29, v30))
    {
      uint64_t v31 = _os_log_pack_size(22LL);
      double v32 = (char *)&v52 - ((__chkstk_darwin(v31) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v33 = *__error();
      uint64_t v34 = _os_log_pack_fill(v32, v31, v33, &dword_0, "%s: couldn't add client identifier, %s");
LABEL_33:
      uint64_t v37 = v34;
      uint64_t v38 = sub_514D0(a9);
      *(_DWORD *)uint64_t v37 = 136315394;
      *(void *)(v37 + 4) = "make_dhcp_request";
      *(_WORD *)(v37 + 12) = 2080;
      *(void *)(v37 + 14) = v38;
      uint64_t v39 = v29;
      uint64_t v40 = v30;
      unsigned int v41 = v32;
LABEL_36:
      __SC_log_send(5LL, v39, v40, v41);
      return 0LL;
    }

    return 0LL;
  }

  return v14;
}

uint64_t sub_104C8(uint64_t a1, uint64_t *a2)
{
  uint64_t v4 = sub_14834(a1);
  HIDWORD(v41) = 0;
  if (sub_19C34(a1, (_DWORD *)&v41 + 1))
  {
    if (!HIDWORD(v41))
    {
      uint64_t v23 = sub_57538();
      uint64_t v24 = _SC_syslog_os_log_mapping(5LL);
      uint64_t result = __SC_log_enabled(5LL, v23, v24);
      if (!(_DWORD)result) {
        return result;
      }
      uint64_t v25 = _os_log_pack_size(12LL);
      uint64_t v26 = (char *)&v41 - ((__chkstk_darwin(v25) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v27 = __error();
      uint64_t v28 = _os_log_pack_fill(v26, v25, *v27, &dword_0, "DHCP %s: not supplying hostname", v41);
      uint64_t v29 = nullsub_1(v4);
      *(_DWORD *)uint64_t v28 = 136315138;
      *(void *)(v28 + 4) = v29;
      uint64_t v30 = v23;
      return __SC_log_send(5LL, v30, v24, v26);
    }

    if (!qword_6C140)
    {
      uint64_t v5 = (const __CFString *)MGCopyAnswer(@"ProductType", 0LL);
      if (v5)
      {
        uint64_t v6 = v5;
        uint64_t v7 = sub_50578(v5, 0x8000100u);
        qword_6C140 = (uint64_t)v7;
        if (v7)
        {
          uint64_t v8 = (uint64_t)v7;
          size_t v9 = strlen((const char *)v7);
          if (v9)
          {
            size_t v10 = v9;
            for (uint64_t i = 0LL; v10 != i; ++i)
            {
              __darwin_ct_rune_t v12 = *(char *)(v8 + i);
              if (v12 < 0)
              {
                int v14 = __maskrune(v12, 0x100uLL);
                uint64_t v13 = qword_6C140;
                if (!v14)
                {
LABEL_18:
                  *(_BYTE *)(v8 + i) = 0;
                  break;
                }
              }

              else
              {
                uint64_t v13 = v8;
                if ((_DefaultRuneLocale.__runetype[v12] & 0x100) == 0) {
                  goto LABEL_18;
                }
              }

              uint64_t v8 = v13;
            }
          }
        }

        CFRelease(v6);
      }
    }

    BOOL v15 = (char *)qword_6C140;
    uint64_t v16 = sub_57538();
    uint64_t v17 = _SC_syslog_os_log_mapping(5LL);
    uint64_t result = __SC_log_enabled(5LL, v16, v17);
    if ((_DWORD)result)
    {
      uint64_t v31 = _os_log_pack_size(22LL);
      uint64_t v20 = (char *)&v41 - ((__chkstk_darwin(v31) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v32 = *__error();
      uint64_t v22 = _os_log_pack_fill(v20, v31, v32, &dword_0, "DHCP %s: supplying device type '%s'");
      goto LABEL_22;
    }
  }

  else
  {
    BOOL v15 = (char *)sub_1451C();
    uint64_t v16 = sub_57538();
    uint64_t v17 = _SC_syslog_os_log_mapping(5LL);
    uint64_t result = __SC_log_enabled(5LL, v16, v17);
    if ((_DWORD)result)
    {
      uint64_t v19 = _os_log_pack_size(22LL);
      uint64_t v20 = (char *)&v41 - ((__chkstk_darwin(v19) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v21 = *__error();
      uint64_t v22 = _os_log_pack_fill(v20, v19, v21, &dword_0, "DHCP %s: supplying hostname '%s'");
LABEL_22:
      uint64_t v33 = v22;
      uint64_t v34 = nullsub_1(v4);
      *(_DWORD *)uint64_t v33 = 136315394;
      *(void *)(v33 + 4) = v34;
      *(_WORD *)(v33 + 12) = 2080;
      *(void *)(v33 + 14) = v15;
      uint64_t result = __SC_log_send(5LL, v16, v17, v20);
    }
  }

  if (v15)
  {
    int v35 = strlen(v15);
    uint64_t result = sub_512B8((uint64_t)a2, 12, v35, v15);
    if ((_DWORD)result)
    {
      uint64_t v36 = sub_57538();
      uint64_t v24 = _SC_syslog_os_log_mapping(5LL);
      uint64_t result = __SC_log_enabled(5LL, v36, v24);
      if ((_DWORD)result)
      {
        uint64_t v37 = _os_log_pack_size(12LL);
        uint64_t v26 = (char *)&v41 - ((__chkstk_darwin(v37) + 15) & 0xFFFFFFFFFFFFFFF0LL);
        uint64_t v38 = __error();
        uint64_t v39 = _os_log_pack_fill( v26,  v37,  *v38,  &dword_0,  "make_dhcp_request: couldn't add host_name, %s",  v41);
        uint64_t v40 = sub_514D0(a2);
        *(_DWORD *)uint64_t v39 = 136315138;
        *(void *)(v39 + 4) = v40;
        uint64_t v30 = v36;
        return __SC_log_send(5LL, v30, v24, v26);
      }
    }
  }

  return result;
}

void sub_108C0(_DWORD *a1)
{
  uint64_t v2 = sub_194C4((uint64_t)a1);
  sub_F6B8((uint64_t)a1, 3u);
  uint64_t v3 = sub_50E4C(v2 + 40, 1, 4);
  if (!sub_19400((uint64_t)a1) && v3)
  {
    *(_DWORD *)(v2 + 20) = *(_DWORD *)v3;
    unsigned int v4 = sub_193D8((uint64_t)a1);
    sub_18378((uint64_t)a1, v4, *(unsigned int *)(v2 + 20), 0LL);
  }

  sub_9F84((uint64_t)a1);
  *(_DWORD *)(v2 + 36) = 0;
  if (!sub_14EC8(a1, v2 + 40, *(_DWORD *)(v2 + 1564))
    || (uint64_t v5 = *(void *)v2,
        int v6 = sub_193D8((uint64_t)a1),
        !sub_14564((uint64_t)a1, v5, (uint64_t)sub_10CAC, v6)))
  {
    sub_10D38((uint64_t)a1);
  }

unsigned __int8 *sub_109A8(uint64_t *a1, int a2, uint64_t a3, unsigned int *a4, _DWORD *a5)
{
  uint64_t v10 = *a1;
  unsigned __int8 v11 = sub_54E28(a3);
  __darwin_ct_rune_t v12 = (void *)sub_54E44(a3);
  unsigned int v13 = sub_54230(a3);
  uint64_t result = (unsigned __int8 *)sub_518EC(v10, a2, v11, v12, v13);
  if ((_DWORD)result)
  {
    uint64_t v15 = (uint64_t)(a1 + 2);
    uint64_t result = sub_50DA0(v15, 53, &v18, 0LL);
    if (a4 && result)
    {
      unsigned int v16 = *result;
      *a4 = v16;
    }

    else
    {
      if (!result) {
        return result;
      }
      unsigned int v16 = *a4;
    }

    if (v16 <= 8 && ((1 << v16) & 0x10A) != 0)
    {
      return 0LL;
    }

    else
    {
      *a5 = 0;
      uint64_t v17 = sub_50E4C(v15, 54, 4);
      if (v17) {
        *a5 = *(_DWORD *)v17;
      }
      return (_BYTE *)(&dword_0 + 1);
    }
  }

  return result;
}

uint64_t sub_10AB0(uint64_t *a1, int a2)
{
  uint64_t v3 = dword_6C018;
  if (a2)
  {
    unsigned int v4 = 0LL;
    uint64_t v5 = off_6C010;
  }

  else
  {
    int v6 = off_6C010;
    if (dword_6C018 < 1)
    {
LABEL_7:
      unsigned int v4 = 0LL;
      uint64_t v5 = off_6C010;
    }

    else
    {
      uint64_t v7 = 0LL;
      while (off_6C010[v7] != 108)
      {
        if (dword_6C018 == ++v7) {
          goto LABEL_7;
        }
      }

      uint64_t v8 = (char *)malloc(dword_6C018);
      uint64_t v5 = v8;
      uint64_t v9 = v3;
      LODWORD(v3) = 0;
      do
      {
        int v11 = *v6++;
        char v10 = v11;
        if (v11 != 108)
        {
          v8[(int)v3] = v10;
          LODWORD(v3) = v3 + 1;
        }

        --v9;
      }

      while (v9);
      unsigned int v4 = v8;
    }
  }

  if (!sub_512B8((uint64_t)a1, 55, v3, v5))
  {
    uint64_t v19 = 1LL;
    if (!v4) {
      return v19;
    }
    goto LABEL_17;
  }

  uint64_t v12 = sub_57538();
  uint64_t v13 = _SC_syslog_os_log_mapping(5LL);
  if (__SC_log_enabled(5LL, v12, v13))
  {
    uint64_t v14 = _os_log_pack_size(22LL);
    uint64_t v15 = (char *)v21 - ((__chkstk_darwin(v14) + 15) & 0xFFFFFFFFFFFFFFF0LL);
    unsigned int v16 = __error();
    uint64_t v17 = _os_log_pack_fill( v15,  v14,  *v16,  &dword_0,  "%s: couldn't add parameter request list, %s",  v21[0],  v21[1]);
    int v18 = sub_514D0(a1);
    *(_DWORD *)uint64_t v17 = 136315394;
    *(void *)(v17 + 4) = "add_parameter_request_list";
    *(_WORD *)(v17 + 12) = 2080;
    *(void *)(v17 + 14) = v18;
    __SC_log_send(5LL, v12, v13, v15);
  }

  uint64_t v19 = 0LL;
  if (v4) {
LABEL_17:
  }
    free(v4);
  return v19;
}

void sub_10CAC(uint64_t a1, int a2)
{
  uint64_t v4 = sub_194C4(a1);
  uint64_t v5 = v4;
  if (!a2)
  {
    *(_DWORD *)(v4 + 36) = 0;
LABEL_7:
    sub_10D38(a1);
    return;
  }

  if (a2 == 1)
  {
    timer_set_relative(*(void *)(v4 + 1592), 60LL, 0, (uint64_t)sub_10D94, a1, 0LL, 0LL);
    if (!*(_DWORD *)(v5 + 36))
    {
      *(_DWORD *)(v5 + 36) = 1;
      goto LABEL_7;
    }
  }

void sub_10D38(uint64_t a1)
{
  uint64_t v2 = sub_194C4(a1);
  __int128 v4 = 0u;
  __int128 v5 = 0u;
  uint64_t v6 = 0LL;
  int v3 = *(_DWORD *)(v2 + 1556);
  if (v3)
  {
    *(void *)&__int128 v4 = v2 + 56;
    DWORD2(v4) = v3;
    *(void *)&__int128 v5 = v2 + 40;
  }

  sub_154F8(a1, (uint64_t)&v4);
}

uint64_t sub_10D94(uint64_t a1)
{
  uint64_t v2 = sub_194C4(a1);
  return sub_14564(a1, *(void *)v2, (uint64_t)sub_10CAC, *(_DWORD *)(v2 + 1564));
}

__CFString *sub_10DC8(uint64_t a1)
{
  if (!*(_DWORD *)(a1 + 1516)) {
    return 0LL;
  }
  Mutable = CFStringCreateMutable(0LL, 0LL);
  sub_51588(Mutable, (unsigned __int8 *)(a1 + 16), *(unsigned int *)(a1 + 1516), a1);
  return Mutable;
}

uint64_t sub_10E18(uint64_t a1)
{
  uint64_t v2 = sub_194C4(a1);
  uint64_t v3 = sub_14834(a1);
  sub_1105C(v2, v3, (uint64_t *)&v23, &v22, &v21);
  __int128 v4 = (uint64_t *)(v2 + 136);
  __int128 v5 = (const char *)nullsub_1(v3);
  BOOL v6 = sub_54E78(v3) != 0;
  DHCPLeaseListRead(v4, v5, v6, v22, v23, v21);
  uint64_t result = sub_50C94(v4);
  if ((_DWORD)result)
  {
    uint64_t v8 = (unsigned __int8 *)sub_50C98(v4, (result - 1));
    sub_110CC(a1, (uint64_t)v8, 1);
    uint64_t v9 = sub_57538();
    uint64_t v10 = _SC_syslog_os_log_mapping(5LL);
    uint64_t result = __SC_log_enabled(5LL, v9, v10);
    if ((_DWORD)result)
    {
      uint64_t v11 = _os_log_pack_size(36LL);
      uint64_t v12 = (char *)&v20 - ((__chkstk_darwin(v11) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v13 = __error();
      uint64_t v14 = _os_log_pack_fill( v12,  v11,  *v13,  &dword_0,  "DHCP %s: recovered lease for IP %d.%d.%d.%d",  v20,  v21,  (_DWORD)v23,  v24,  v25);
      uint64_t v15 = nullsub_1(v3);
      int v16 = v8[4];
      int v17 = v8[5];
      int v18 = v8[6];
      int v19 = v8[7];
      *(_DWORD *)uint64_t v14 = 136316162;
      *(void *)(v14 + 4) = v15;
      *(_WORD *)(v14 + 12) = 1024;
      *(_DWORD *)(v14 + 14) = v16;
      *(_WORD *)(v14 + 18) = 1024;
      *(_DWORD *)(v14 + 20) = v17;
      *(_WORD *)(v14 + 24) = 1024;
      *(_DWORD *)(v14 + 26) = v18;
      *(_WORD *)(v14 + 30) = 1024;
      *(_DWORD *)(v14 + 32) = v19;
      return __SC_log_send(5LL, v9, v10, v12);
    }
  }

  return result;
}

void sub_10FF8(_DWORD *a1)
{
  if (sub_194B4((uint64_t)a1))
  {
    LODWORD(v3) = 0;
    sub_CF80(a1, 0, (uint64_t)&v3);
  }

  else
  {
    uint64_t v3 = sub_19384((uint64_t)a1);
    int v4 = v2;
    sub_BC50(a1, 0, (int *)&v3);
  }

uint64_t sub_1105C(uint64_t a1, uint64_t a2, uint64_t *a3, _BYTE *a4, _DWORD *a5)
{
  if (*(void *)(a1 + 24))
  {
    *a4 = 0;
    *a3 = *(void *)(a1 + 24);
    uint64_t result = *(unsigned int *)(a1 + 32);
  }

  else
  {
    *a4 = sub_54E28(a2);
    *a3 = sub_54E44(a2);
    uint64_t result = sub_54230(a2);
  }

  *a5 = result;
  return result;
}

uint64_t sub_110CC(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v6 = sub_194C4(a1);
  uint64_t v7 = sub_14834(a1);
  unsigned int v8 = *(_DWORD *)(a2 + 4);
  if (v8 != *(_DWORD *)(v6 + 1732)) {
    goto LABEL_14;
  }
  unsigned int v9 = bswap32(v8);
  if (HIWORD(v9) != 49320 && (v9 & 0xFF000000) != 167772160 && (v9 & 0xFFF00000) != -1408237568)
  {
    uint64_t v33 = sub_57538();
    uint64_t v34 = _SC_syslog_os_log_mapping(6LL);
    uint64_t result = __SC_log_enabled(6LL, v33, v34);
    if ((_DWORD)result)
    {
      uint64_t v36 = _os_log_pack_size(12LL);
      uint64_t v37 = (char *)&v44 - ((__chkstk_darwin(v36) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v38 = *__error();
      uint64_t v39 = _os_log_pack_fill(v37, v36, v38, &dword_0, "DHCP %s: switch_to_lease returns FALSE, public IP is the same");
LABEL_33:
      uint64_t v40 = v39;
      uint64_t v41 = nullsub_1(v7);
      *(_DWORD *)uint64_t v40 = 136315138;
      *(void *)(v40 + 4) = v41;
      __SC_log_send(6LL, v33, v34, v37);
      return 0LL;
    }

    return result;
  }

  if (!sub_14840(a1)
    || !sub_19440(a1)
    || (int v12 = *(_DWORD *)(a2 + 20), v12 != sub_1485C(a1))
    || (uint64_t v13 = (const void *)sub_14EA4(a1), v14 = sub_54230(v7), bcmp((const void *)(a2 + 24), v13, v14)))
  {
LABEL_14:
    sub_18A00(a1);
    unsigned int v15 = *(_DWORD *)(a2 + 64);
    if (v15 >= 0x5DC) {
      size_t v16 = 1500LL;
    }
    else {
      size_t v16 = v15;
    }
    *(_DWORD *)(v6 + 1724) = v16;
    memmove((void *)(v6 + 224), (const void *)(a2 + 68), v16);
    sub_50CA0(v6 + 208);
    sub_50F80((char **)(v6 + 208), v6 + 224, *(_DWORD *)(v6 + 1724), 0LL);
    dhcp_get_lease_from_options(v6 + 208, v48, &v47, &v46);
    sub_11550(a1, (uint64_t)"RECOVERED", v48[0], v47, v46, *(double *)(a2 + 8));
    *(_DWORD *)(v6 + 56) = 1;
    *(_DWORD *)(v6 + 1728) = 0;
    *(_DWORD *)(v6 + 1732) = *(_DWORD *)(a2 + 4);
    int v17 = sub_50E4C(v6 + 208, 54, 4);
    if (v17) {
      *(_DWORD *)(v6 + 1736) = *(_DWORD *)v17;
    }
    sub_B498(v6, *(CFTypeRef *)(a2 + 48));
    sub_B4D4(v6, *(CFTypeRef *)(a2 + 56));
    sub_14F54(a1);
    *(_DWORD *)(v6 + 112) = 0;
    if (a3 && *(_BYTE *)(a2 + 47))
    {
      *(_DWORD *)(v6 + 112) = 1;
      int v18 = *(_DWORD *)(a2 + 41);
      *(_WORD *)(v6 + 108) = *(_WORD *)(a2 + 45);
      *(_DWORD *)(v6 + 104) = v18;
    }

    int v19 = *(_DWORD *)(a2 + 20);
    if (v19)
    {
      sub_14F88(a1, v19);
      sub_14F98(a1);
      int v20 = *(unsigned __int8 *)(a2 + 40);
      if (*(_BYTE *)(a2 + 40))
      {
        int v21 = (void *)sub_14EA4(a1);
        memmove(v21, (const void *)(a2 + 24), v20);
        sub_1945C(a1);
      }
    }

    uint64_t v22 = sub_57538();
    uint64_t v23 = _SC_syslog_os_log_mapping(5LL);
    if (__SC_log_enabled(5LL, v22, v23))
    {
      uint64_t v24 = _os_log_pack_size(36LL);
      uint64_t v25 = (char *)&v44 - ((__chkstk_darwin(v24) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v26 = __error();
      uint64_t v27 = _os_log_pack_fill( v25,  v24,  *v26,  &dword_0,  "DHCP %s: switched to lease for IP %d.%d.%d.%d",  v44,  v45,  v47,  v48[1],  v48[3]);
      uint64_t v28 = nullsub_1(v7);
      int v29 = *(unsigned __int8 *)(a2 + 4);
      int v30 = *(unsigned __int8 *)(a2 + 5);
      int v31 = *(unsigned __int8 *)(a2 + 6);
      int v32 = *(unsigned __int8 *)(a2 + 7);
      *(_DWORD *)uint64_t v27 = 136316162;
      *(void *)(v27 + 4) = v28;
      *(_WORD *)(v27 + 12) = 1024;
      *(_DWORD *)(v27 + 14) = v29;
      *(_WORD *)(v27 + 18) = 1024;
      *(_DWORD *)(v27 + 20) = v30;
      *(_WORD *)(v27 + 24) = 1024;
      *(_DWORD *)(v27 + 26) = v31;
      *(_WORD *)(v27 + 30) = 1024;
      *(_DWORD *)(v27 + 32) = v32;
      __SC_log_send(5LL, v22, v23, v25);
    }

    return 1LL;
  }

  uint64_t v33 = sub_57538();
  uint64_t v34 = _SC_syslog_os_log_mapping(6LL);
  uint64_t result = __SC_log_enabled(6LL, v33, v34);
  if ((_DWORD)result)
  {
    uint64_t v42 = _os_log_pack_size(12LL);
    uint64_t v37 = (char *)&v44 - ((__chkstk_darwin(v42) + 15) & 0xFFFFFFFFFFFFFFF0LL);
    uint64_t v43 = *__error();
    uint64_t v39 = _os_log_pack_fill( v37,  v42,  v43,  &dword_0,  "DHCP %s: switch_to_lease returns FALSE, private IP has same router");
    goto LABEL_33;
  }

  return result;
}

uint64_t sub_11550(uint64_t a1, uint64_t a2, unsigned int a3, unsigned int a4, unsigned int a5, double a6)
{
  uint64_t v12 = sub_194C4(a1);
  uint64_t v13 = sub_14834(a1);
  *(double *)(v12 + 80) = a6;
  *(_DWORD *)(v12 + 72) = a3;
  if (a3 == -1)
  {
    double v14 = 0.0;
    double v16 = 0.0;
    double v15 = 0.0;
  }

  else
  {
    double v14 = (double)a3 + a6;
    double v15 = (double)a4 + a6;
    double v16 = (double)a5 + a6;
  }

  *(double *)(v12 + 64) = v14;
  *(double *)(v12 + 88) = v15;
  *(double *)(v12 + 96) = v16;
  uint64_t v17 = sub_57538();
  uint64_t v18 = _SC_syslog_os_log_mapping(6LL);
  uint64_t result = __SC_log_enabled(6LL, v17, v18);
  if ((_DWORD)result)
  {
    uint64_t v20 = _os_log_pack_size(62LL);
    int v21 = (char *)v29 - ((__chkstk_darwin(v20) + 15) & 0xFFFFFFFFFFFFFFF0LL);
    uint64_t v22 = __error();
    uint64_t v23 = _os_log_pack_fill( v21,  v20,  *v22,  &dword_0,  "DHCP %s: %s lease = { start %g, t1 %g, t2 %g, expiration %g }",  v29[0],  v29[1],  *(double *)&v29[2],  *(double *)&v29[3],  *(double *)&v29[4],  *(double *)&v29[5]);
    uint64_t v24 = nullsub_1(v13);
    uint64_t v25 = *(void *)(v12 + 80);
    uint64_t v26 = *(void *)(v12 + 88);
    uint64_t v27 = *(void *)(v12 + 96);
    uint64_t v28 = *(void *)(v12 + 64);
    *(_DWORD *)uint64_t v23 = 136316418;
    *(void *)(v23 + 4) = v24;
    *(_WORD *)(v23 + 12) = 2080;
    *(void *)(v23 + 14) = a2;
    *(_WORD *)(v23 + 22) = 2048;
    *(void *)(v23 + 24) = v25;
    *(_WORD *)(v23 + 32) = 2048;
    *(void *)(v23 + 34) = v26;
    *(_WORD *)(v23 + 42) = 2048;
    *(void *)(v23 + 44) = v27;
    *(_WORD *)(v23 + 52) = 2048;
    *(void *)(v23 + 54) = v28;
    return __SC_log_send(6LL, v17, v18, v21);
  }

  return result;
}

void sub_11718(uint64_t a1)
{
  uint64_t v1 = sub_194C4(a1);
  if (v1)
  {
    uint64_t v2 = v1;
    timer_cancel(*(void *)(v1 + 1760));
    bootp_client_disable_receive(*(void **)(v2 + 16));
    sub_4718(*(void *)(v2 + 8));
  }

uint64_t sub_1175C(uint64_t a1, unsigned int a2)
{
  uint64_t v4 = sub_14834(a1);
  *(_DWORD *)(sub_194C4(a1) + 1744) = a2;
  uint64_t v5 = sub_57538();
  uint64_t v6 = _SC_syslog_os_log_mapping(5LL);
  uint64_t result = __SC_log_enabled(5LL, v5, v6);
  if ((_DWORD)result)
  {
    uint64_t v8 = _os_log_pack_size(22LL);
    unsigned int v9 = (char *)v14 - ((__chkstk_darwin(v8) + 15) & 0xFFFFFFFFFFFFFFF0LL);
    uint64_t v10 = __error();
    uint64_t v11 = _os_log_pack_fill(v9, v8, *v10, &dword_0, "DHCP %s: %s", v14[0], v14[1]);
    uint64_t v12 = nullsub_1(v4);
    if (a2 > 8) {
      uint64_t v13 = "<undefined>";
    }
    else {
      uint64_t v13 = off_64C18[a2];
    }
    *(_DWORD *)uint64_t v11 = 136315394;
    *(void *)(v11 + 4) = v12;
    *(_WORD *)(v11 + 12) = 2080;
    *(void *)(v11 + 14) = v13;
    return __SC_log_send(5LL, v5, v6, v9);
  }

  return result;
}

uint64_t sub_118BC(uint64_t a1, void *a2, double a3)
{
  uint64_t v6 = sub_57538();
  uint64_t v7 = _SC_syslog_os_log_mapping(6LL);
  uint64_t result = __SC_log_enabled(6LL, v6, v7);
  if ((_DWORD)result)
  {
    uint64_t v9 = _os_log_pack_size(62LL);
    uint64_t v10 = (char *)v17 - ((__chkstk_darwin(v9) + 15) & 0xFFFFFFFFFFFFFFF0LL);
    uint64_t v11 = __error();
    uint64_t v12 = _os_log_pack_fill( v10,  v9,  *v11,  &dword_0,  "DHCP %s: now = %g, lease = { start %g, t1 %g, t2 %g, expiration %g }",  v17[0],  *(double *)&v17[1],  *(double *)&v17[2],  *(double *)&v17[3],  *(double *)&v17[4],  *(double *)&v17[5]);
    uint64_t v13 = a2[3];
    uint64_t v14 = a2[4];
    uint64_t v15 = a2[5];
    uint64_t v16 = a2[1];
    *(_DWORD *)uint64_t v12 = 136316418;
    *(void *)(v12 + 4) = a1;
    *(_WORD *)(v12 + 12) = 2048;
    *(double *)(v12 + 14) = a3;
    *(_WORD *)(v12 + 22) = 2048;
    *(void *)(v12 + 24) = v13;
    *(_WORD *)(v12 + 32) = 2048;
    *(void *)(v12 + 34) = v14;
    *(_WORD *)(v12 + 42) = 2048;
    *(void *)(v12 + 44) = v15;
    *(_WORD *)(v12 + 52) = 2048;
    *(void *)(v12 + 54) = v16;
    return __SC_log_send(6LL, v6, v7, v10);
  }

  return result;
}

void sub_11A14(_DWORD *a1, int a2, uint64_t a3)
{
  double current_time = timer_get_current_time();
  uint64_t v7 = sub_194C4((uint64_t)a1);
  uint64_t v8 = sub_14834((uint64_t)a1);
  if (a2 == 5)
  {
    LODWORD(v62) = 7776000;
    double v61 = 0.0;
    if (sub_109A8((uint64_t *)a3, *(_DWORD *)(v7 + 2332), v8, (unsigned int *)&v61 + 1, &v61))
    {
      if (HIDWORD(v61) == 5)
      {
        if ((*(_DWORD *)(*(void *)a3 + 16LL) + 1) >= 2)
        {
          dhcp_get_lease_from_options(a3 + 16, (unsigned int *)&v62, (unsigned int *)&v60 + 1, (unsigned int *)&v60);
          sub_11550((uint64_t)a1, (uint64_t)"SELECT", v62, HIDWORD(v60), v60, current_time);
          sub_50CA0(v7 + 208);
          memmove((void *)(v7 + 224), *(const void **)a3, *(int *)(a3 + 8));
          unsigned int v30 = *(_DWORD *)(a3 + 8);
          *(void *)(v7 + 1724) = v30;
          sub_50F80((char **)(v7 + 208), v7 + 224, v30, 0LL);
          *(_DWORD *)(v7 + 1732) = *(_DWORD *)(*(void *)a3 + 16LL);
          if (LODWORD(v61)) {
            *(_DWORD *)(v7 + 1736) = LODWORD(v61);
          }
          sub_12D98(a1, 0, 0LL);
        }
      }

      else if (HIDWORD(v61) == 6 && LODWORD(v61) && LODWORD(v61) == *(_DWORD *)(v7 + 1736))
      {
        sub_11718((uint64_t)a1);
        timer_set_relative(*(void *)(v7 + 1760), 10LL, 0, (uint64_t)sub_C4A4, (uint64_t)a1, 0LL, 0LL);
      }
    }
  }

  else
  {
    if (a2 != 2)
    {
      if (a2) {
        return;
      }
      sub_1175C((uint64_t)a1, 4u);
      sub_11718((uint64_t)a1);
      unsigned int v9 = *(_DWORD *)(v7 + 168) != 0;
      uint64_t v10 = (const void *)sub_54E44(v8);
      unsigned __int8 v11 = sub_54E28(v8);
      unsigned __int8 v12 = sub_54230(v8);
      uint64_t v13 = sub_10010((char *)(v7 + 1784), 3, v10, v11, v12, *(const void **)(v7 + 24), *(_DWORD *)(v7 + 32), v9, &v62);
      *(void *)(v7 + 176) = v13;
      if (!v13)
      {
        uint64_t v14 = sub_57538();
        uint64_t v15 = _SC_syslog_os_log_mapping(5LL);
        uint64_t v20 = _os_log_pack_size(12LL);
        uint64_t v17 = (char *)&v60 - ((__chkstk_darwin(v20) + 15) & 0xFFFFFFFFFFFFFFF0LL);
        uint64_t v21 = *__error();
        uint64_t v22 = _os_log_pack_fill(v17, v20, v21, &dword_0, "DHCP %s: SELECT make_dhcp_request failed");
LABEL_18:
        uint64_t v23 = v22;
        uint64_t v24 = nullsub_1(v8);
        *(_DWORD *)uint64_t v23 = 136315138;
        *(void *)(v23 + 4) = v24;
LABEL_23:
        __SC_log_send(5LL, v14, v15, v17);
        goto LABEL_24;
      }

      if (sub_512B8((uint64_t)&v62, 50, 4, (void *)(v7 + 1732)))
      {
        uint64_t v14 = sub_57538();
        uint64_t v15 = _SC_syslog_os_log_mapping(5LL);
        if (__SC_log_enabled(5LL, v14, v15))
        {
          uint64_t v16 = _os_log_pack_size(22LL);
          uint64_t v17 = (char *)&v60 - ((__chkstk_darwin(v16) + 15) & 0xFFFFFFFFFFFFFFF0LL);
          uint64_t v18 = *__error();
          uint64_t v19 = _os_log_pack_fill(v17, v16, v18, &dword_0, "DHCP %s: SELECT add requested ip failed, %s");
LABEL_22:
          uint64_t v27 = v19;
          uint64_t v28 = nullsub_1(v8);
          int v29 = sub_514D0(&v62);
          *(_DWORD *)uint64_t v27 = 136315394;
          *(void *)(v27 + 4) = v28;
          *(_WORD *)(v27 + 12) = 2080;
          *(void *)(v27 + 14) = v29;
          goto LABEL_23;
        }

        goto LABEL_24;
      }

      if (sub_512B8((uint64_t)&v62, 54, 4, (void *)(v7 + 1736)))
      {
        uint64_t v14 = sub_57538();
        uint64_t v15 = _SC_syslog_os_log_mapping(5LL);
        if (__SC_log_enabled(5LL, v14, v15))
        {
          uint64_t v25 = _os_log_pack_size(22LL);
          uint64_t v17 = (char *)&v60 - ((__chkstk_darwin(v25) + 15) & 0xFFFFFFFFFFFFFFF0LL);
          uint64_t v26 = *__error();
          uint64_t v19 = _os_log_pack_fill(v17, v25, v26, &dword_0, "DHCP %s: SELECT add server ip failed, %s");
          goto LABEL_22;
        }

LABEL_24:
        sub_B424((uint64_t)a1, 5u);
        return;
      }

      sub_104C8((uint64_t)a1, &v62);
      if (sub_512B8((uint64_t)&v62, 255, 0, 0LL))
      {
        uint64_t v14 = sub_57538();
        uint64_t v15 = _SC_syslog_os_log_mapping(5LL);
        uint64_t v31 = _os_log_pack_size(12LL);
        uint64_t v17 = (char *)&v60 - ((__chkstk_darwin(v31) + 15) & 0xFFFFFFFFFFFFFFF0LL);
        uint64_t v32 = *__error();
        uint64_t v22 = _os_log_pack_fill(v17, v31, v32, &dword_0, "DHCP %s: SELECT failed to terminate options");
        goto LABEL_18;
      }

      unsigned int v33 = sub_5147C((uint64_t)&v62) + 240;
      if (v33 <= 0x12C) {
        unsigned int v33 = 300;
      }
      *(_DWORD *)(v7 + 184) = v33;
      *(_DWORD *)(v7 + 1768) = 0;
      *(_DWORD *)(v7 + 44) = 0;
      *(_DWORD *)(v7 + 2340) = G_initial_wait_secs;
      bootp_client_enable_receive(*(void **)(v7 + 16), (uint64_t)sub_11A14, (uint64_t)a1, 5LL);
    }

    int v34 = *(_DWORD *)(v7 + 1768);
    *(_DWORD *)(v7 + 1768) = v34 + 1;
    if (v34 <= dword_6C03C)
    {
      uint64_t v42 = *(void *)(v7 + 176);
      *(_DWORD *)(v42 + 4) = bswap32(*(_DWORD *)(v7 + 2332));
      *(_WORD *)(v42 + 8) = __rev16((int)(current_time - *(double *)(v7 + 1752)));
      if ((bootp_client_transmit( *(void **)(v7 + 16),  0xFFFFFFFF,  0LL,  (unsigned __int16)word_6C044,  (unsigned __int16)word_6C020,  (void *)v42,  *(unsigned int *)(v7 + 184)) & 0x80000000) != 0)
      {
        uint64_t v43 = sub_57538();
        uint64_t v44 = _SC_syslog_os_log_mapping(5LL);
        if (__SC_log_enabled(5LL, v43, v44))
        {
          uint64_t v45 = _os_log_pack_size(12LL);
          unsigned int v46 = (char *)&v60 - ((__chkstk_darwin(v45) + 15) & 0xFFFFFFFFFFFFFFF0LL);
          unsigned int v47 = __error();
          uint64_t v48 = _os_log_pack_fill(v46, v45, *v47, &dword_0, "DHCP %s: SELECT transmit failed", v60);
          uint64_t v49 = nullsub_1(v8);
          *(_DWORD *)uint64_t v48 = 136315138;
          *(void *)(v48 + 4) = v49;
          __SC_log_send(5LL, v43, v44, v46);
        }
      }

      uint64_t v50 = *(int *)(v7 + 2340);
      uint64_t v51 = sub_57538();
      uint64_t v52 = _SC_syslog_os_log_mapping(5LL);
      if (__SC_log_enabled(5LL, v51, v52))
      {
        uint64_t v53 = _os_log_pack_size(38LL);
        uint64_t v54 = (char *)&v60 - ((__chkstk_darwin(v53) + 15) & 0xFFFFFFFFFFFFFFF0LL);
        unsigned int v55 = __error();
        uint64_t v56 = _os_log_pack_fill( v54,  v53,  *v55,  &dword_0,  "DHCP %s: SELECT waiting at %g for %ld.%06d",  v60,  v61,  v62,  v63);
        uint64_t v57 = nullsub_1(v8);
        double v58 = current_time - *(double *)(v7 + 1752);
        *(_DWORD *)uint64_t v56 = 136315906;
        *(void *)(v56 + 4) = v57;
        *(_WORD *)(v56 + 12) = 2048;
        *(double *)(v56 + 14) = v58;
        *(_WORD *)(v56 + 22) = 2048;
        *(void *)(v56 + 24) = v50;
        *(_WORD *)(v56 + 32) = 1024;
        *(_DWORD *)(v56 + 34) = 0;
        __SC_log_send(5LL, v51, v52, v54);
      }

      timer_set_relative(*(void *)(v7 + 1760), v50, 0, (uint64_t)sub_11A14, (uint64_t)a1, 2LL, 0LL);
      int v59 = 2 * *(_DWORD *)(v7 + 2340);
      if (v59 >= G_max_wait_secs) {
        int v59 = G_max_wait_secs;
      }
      *(_DWORD *)(v7 + 2340) = v59;
    }

    else
    {
      uint64_t v35 = sub_57538();
      uint64_t v36 = _SC_syslog_os_log_mapping(5LL);
      if (__SC_log_enabled(5LL, v35, v36))
      {
        uint64_t v37 = _os_log_pack_size(12LL);
        uint64_t v38 = (char *)&v60 - ((__chkstk_darwin(v37) + 15) & 0xFFFFFFFFFFFFFFF0LL);
        uint64_t v39 = __error();
        uint64_t v40 = _os_log_pack_fill(v38, v37, *v39, &dword_0, "DHCP %s: SELECT timed out", v60);
        uint64_t v41 = nullsub_1(v8);
        *(_DWORD *)uint64_t v40 = 136315138;
        *(void *)(v40 + 4) = v41;
        __SC_log_send(5LL, v35, v36, v38);
      }

      sub_C4A4(a1, 0LL, 0LL);
    }
  }

    close(v3);
    return 0xFFFFFFFFLL;
  }

void sub_122BC(uint64_t a1, int a2, uint64_t a3)
{
  uint64_t v6 = sub_194C4(a1);
  uint64_t v7 = sub_14834(a1);
  if (a2 == 6)
  {
    if (*(_DWORD *)(a3 + 8))
    {
      uint64_t v12 = sub_57538();
      uint64_t v13 = _SC_syslog_os_log_mapping(5LL);
      if (!__SC_log_enabled(5LL, v12, v13))
      {
LABEL_12:
        if (!*(_DWORD *)(v6 + 48)) {
          return;
        }
        sub_17FEC(a1, 0xBu);
        uint64_t v20 = a1;
        unsigned int v21 = 1;
        goto LABEL_14;
      }

      uint64_t v14 = _os_log_pack_size(22LL);
      uint64_t v15 = (char *)&v110 - ((__chkstk_darwin(v14) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v16 = __error();
      uint64_t v17 = _os_log_pack_fill( v15,  v14,  *v16,  &dword_0,  "DHCP %s: ARP detect ROUTER failed, %s",  (const char *)v110,  *((const char **)&v110 + 1));
      uint64_t v18 = nullsub_1(v7);
      uint64_t v19 = sub_4AE0(*(void *)(v6 + 8));
      *(_DWORD *)uint64_t v17 = 136315394;
      *(void *)(v17 + 4) = v18;
      *(_WORD *)(v17 + 12) = 2080;
      *(void *)(v17 + 14) = v19;
LABEL_11:
      __SC_log_send(5LL, v12, v13, v15);
      goto LABEL_12;
    }

    if (!*(_DWORD *)(a3 + 12))
    {
      uint64_t v12 = sub_57538();
      uint64_t v13 = _SC_syslog_os_log_mapping(5LL);
      uint64_t v52 = _os_log_pack_size(12LL);
      uint64_t v15 = (char *)&v110 - ((__chkstk_darwin(v52) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v53 = __error();
      uint64_t v54 = _os_log_pack_fill( v15,  v52,  *v53,  &dword_0,  "DHCP %s: ARP detect router got no response",  (const char *)v110);
      uint64_t v55 = nullsub_1(v7);
      *(_DWORD *)uint64_t v54 = 136315138;
      *(void *)(v54 + 4) = v55;
      goto LABEL_11;
    }

    uint64_t v22 = sub_57538();
    uint64_t v23 = _SC_syslog_os_log_mapping(5LL);
    if (__SC_log_enabled(5LL, v22, v23))
    {
      uint64_t v24 = _os_log_pack_size(60LL);
      uint64_t v25 = (char *)&v110 - ((__chkstk_darwin(v24) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v26 = __error();
      uint64_t v27 = _os_log_pack_fill( v25,  v24,  *v26,  &dword_0,  "DHCP %s: got response for sender %d.%d.%d.%d target %d.%d.%d.%d",  (const char *)v110,  DWORD2(v110),  LODWORD(v111),  v112,  v113,  v115,  v116,  v117,  v118);
      uint64_t v28 = nullsub_1(v7);
      int v29 = *(unsigned __int8 *)(a3 + 16);
      int v30 = *(unsigned __int8 *)(a3 + 17);
      int v31 = *(unsigned __int8 *)(a3 + 18);
      int v32 = *(unsigned __int8 *)(a3 + 19);
      int v33 = *(unsigned __int8 *)(a3 + 20);
      int v34 = *(unsigned __int8 *)(a3 + 21);
      int v35 = *(unsigned __int8 *)(a3 + 22);
      int v36 = *(unsigned __int8 *)(a3 + 23);
      *(_DWORD *)uint64_t v27 = 136317186;
      *(void *)(v27 + 4) = v28;
      *(_WORD *)(v27 + 12) = 1024;
      *(_DWORD *)(v27 + 14) = v29;
      *(_WORD *)(v27 + 18) = 1024;
      *(_DWORD *)(v27 + 20) = v30;
      *(_WORD *)(v27 + 24) = 1024;
      *(_DWORD *)(v27 + 26) = v31;
      *(_WORD *)(v27 + 30) = 1024;
      *(_DWORD *)(v27 + 32) = v32;
      *(_WORD *)(v27 + 36) = 1024;
      *(_DWORD *)(v27 + 38) = v33;
      *(_WORD *)(v27 + 42) = 1024;
      *(_DWORD *)(v27 + 44) = v34;
      *(_WORD *)(v27 + 48) = 1024;
      *(_DWORD *)(v27 + 50) = v35;
      *(_WORD *)(v27 + 54) = 1024;
      *(_DWORD *)(v27 + 56) = v36;
      __SC_log_send(5LL, v22, v23, v25);
    }

    unsigned int v37 = sub_54230(v7);
    uint64_t Lease = DHCPLeaseListFindLease(v6 + 136, *(_DWORD *)(a3 + 16), *(_DWORD *)(a3 + 20), (const void *)(a3 + 24), v37);
    if ((_DWORD)Lease == -1)
    {
      uint64_t v82 = sub_57538();
      uint64_t v83 = _SC_syslog_os_log_mapping(5LL);
      if (__SC_log_enabled(5LL, v82, v83))
      {
        uint64_t v84 = _os_log_pack_size(36LL);
        uint64_t v85 = (char *)&v110 - ((__chkstk_darwin(v84) + 15) & 0xFFFFFFFFFFFFFFF0LL);
        uint64_t v86 = __error();
        uint64_t v87 = _os_log_pack_fill( v85,  v84,  *v86,  &dword_0,  "DHCP %s: lease for %d.%d.%d.%d is no longer available",  (const char *)v110,  DWORD2(v110),  LODWORD(v111),  v112,  v113);
        uint64_t v88 = nullsub_1(v7);
        int v89 = *(unsigned __int8 *)(a3 + 16);
        int v90 = *(unsigned __int8 *)(a3 + 17);
        int v91 = *(unsigned __int8 *)(a3 + 18);
        int v92 = *(unsigned __int8 *)(a3 + 19);
        *(_DWORD *)uint64_t v87 = 136316162;
        *(void *)(v87 + 4) = v88;
        *(_WORD *)(v87 + 12) = 1024;
        *(_DWORD *)(v87 + 14) = v89;
        *(_WORD *)(v87 + 18) = 1024;
        *(_DWORD *)(v87 + 20) = v90;
        *(_WORD *)(v87 + 24) = 1024;
        *(_DWORD *)(v87 + 26) = v91;
        *(_WORD *)(v87 + 30) = 1024;
        *(_DWORD *)(v87 + 32) = v92;
        __SC_log_send(5LL, v82, v83, v85);
      }

      if (!*(_DWORD *)(v6 + 48)) {
        return;
      }
    }

    else
    {
      uint64_t v39 = sub_50C98(v6 + 136, Lease);
      uint64_t v40 = sub_57538();
      uint64_t v41 = _SC_syslog_os_log_mapping(5LL);
      if (__SC_log_enabled(5LL, v40, v41))
      {
        uint64_t v42 = _os_log_pack_size(36LL);
        uint64_t v43 = (char *)&v110 - ((__chkstk_darwin(v42) + 15) & 0xFFFFFFFFFFFFFFF0LL);
        uint64_t v44 = __error();
        uint64_t v45 = _os_log_pack_fill( v43,  v42,  *v44,  &dword_0,  "DHCP %s: identified lease for %d.%d.%d.%d",  (const char *)v110,  DWORD2(v110),  LODWORD(v111),  v112,  v113);
        uint64_t v46 = nullsub_1(v7);
        int v47 = *(unsigned __int8 *)(v39 + 4);
        int v48 = *(unsigned __int8 *)(v39 + 5);
        int v49 = *(unsigned __int8 *)(v39 + 6);
        int v50 = *(unsigned __int8 *)(v39 + 7);
        *(_DWORD *)uint64_t v45 = 136316162;
        *(void *)(v45 + 4) = v46;
        *(_WORD *)(v45 + 12) = 1024;
        *(_DWORD *)(v45 + 14) = v47;
        *(_WORD *)(v45 + 18) = 1024;
        *(_DWORD *)(v45 + 20) = v48;
        *(_WORD *)(v45 + 24) = 1024;
        *(_DWORD *)(v45 + 26) = v49;
        *(_WORD *)(v45 + 30) = 1024;
        *(_DWORD *)(v45 + 32) = v50;
        __SC_log_send(5LL, v40, v41, v43);
      }

      int v51 = *(_DWORD *)(v6 + 1744);
      if (v51 != 6)
      {
        if (v51 == 3 && *(_DWORD *)(v6 + 44) != 1)
        {
          sub_110CC(a1, v39, 0);
          sub_19490(a1);
        }

        return;
      }

      if (*(_DWORD *)(v6 + 44) == 1)
      {
        int v105 = *(_DWORD *)(v39 + 4);
        if (v105 != *(_DWORD *)(v6 + 1732)
          || !sub_F5BC(v6 + 208, v105, &v111)
          || LODWORD(v111) != *(_DWORD *)(v39 + 20))
        {
          return;
        }

        goto LABEL_56;
      }

      if (sub_110CC(a1, v39, 0))
      {
        unsigned int v106 = *(_DWORD *)(v6 + 2332) + 1;
        *(_DWORD *)(v6 + 2332) = v106;
        *(_DWORD *)(*(void *)(v6 + 176) + 4LL) = bswap32(v106);
        sub_50C9C(&v111);
        sub_50F80((char **)&v111, v6 + 1784, 0x224u, 0LL);
        unsigned int v107 = sub_50E4C((uint64_t)&v111, 50, 4);
        if (v107)
        {
          *(_DWORD *)unsigned int v107 = *(_DWORD *)(v39 + 4);
          *(_DWORD *)(v6 + 1768) = 0;
        }

        sub_50CA0((uint64_t)&v111);
        goto LABEL_56;
      }

      if (!*(_DWORD *)(v6 + 48))
      {
LABEL_56:
        sub_19490(a1);
        unsigned int v108 = sub_50E4C(v6 + 208, 1, 4);
        if (v108) {
          unint64_t v109 = *(unsigned int *)v108;
        }
        else {
          unint64_t v109 = 0LL;
        }
        *(_DWORD *)(v6 + 36) = 0;
        *(_DWORD *)(v6 + 2336) = 0;
        sub_18378(a1, *(unsigned int *)(v6 + 1732), v109, 0LL);
        sub_13B04(a1);
        if (dword_6C028) {
          sub_18090(a1, 0);
        }
        return;
      }
    }

    sub_17FEC(a1, 0xBu);
    uint64_t v20 = a1;
    unsigned int v21 = 0;
LABEL_14:
    sub_13870(v20, v21);
    return;
  }

  if (!sub_54E78(v7))
  {
    unsigned __int8 v11 = 0LL;
    unsigned int v9 = 0LL;
    uint64_t v10 = 0LL;
LABEL_29:
    uint64_t v56 = DHCPLeaseListCopyARPAddressInfo((uint64_t *)(v6 + 136), v9, v10, v11, 1, &v114);
    uint64_t v57 = sub_57538();
    uint64_t v58 = _SC_syslog_os_log_mapping(5LL);
    int v59 = __SC_log_enabled(5LL, v57, v58);
    if (v56)
    {
      if (v59)
      {
        uint64_t v61 = _os_log_pack_size(12LL);
        uint64_t v62 = (char *)&v110 - ((__chkstk_darwin(v61) + 15) & 0xFFFFFFFFFFFFFFF0LL);
        int v63 = __error();
        uint64_t v64 = _os_log_pack_fill( v62,  v61,  *v63,  &dword_0,  "DHCP %s: ARP detect router starting",  (const char *)v110);
        uint64_t v65 = nullsub_1(v7);
        *(_DWORD *)uint64_t v64 = 136315138;
        *(void *)(v64 + 4) = v65;
        __SC_log_send(5LL, v57, v58, v62);
      }

      int v66 = v114;
      if (v114 >= 1)
      {
        uint64_t v67 = 0LL;
        *(void *)&__int128 v60 = 67111168LL;
        __int128 v110 = v60;
        do
        {
          uint64_t v68 = sub_57538();
          uint64_t v69 = _SC_syslog_os_log_mapping(5LL);
          if (__SC_log_enabled(5LL, v68, v69))
          {
            uint64_t v70 = _os_log_pack_size(56LL);
            int v71 = (char *)&v110 - ((__chkstk_darwin(v70) + 15) & 0xFFFFFFFFFFFFFFF0LL);
            int v72 = __error();
            uint64_t v73 = _os_log_pack_fill( v71,  v70,  *v72,  &dword_0,  "%d. sender %d.%d.%d.%d target %d.%d.%d.%d",  (_DWORD)v110,  DWORD2(v110),  LODWORD(v111),  v112,  v113,  v115,  v116,  v117,  v118);
            uint64_t v74 = (unsigned __int8 *)&v56[6 * v67];
            int v75 = *v74;
            int v76 = v74[1];
            ++v67;
            int v77 = v74[2];
            int v78 = v74[3];
            int v79 = v74[4];
            int v80 = v74[5];
            int v81 = v74[6];
            LODWORD(v74) = v74[7];
            *(_DWORD *)uint64_t v73 = v110;
            *(_DWORD *)(v73 + 4) = v67;
            *(_WORD *)(v73 + 8) = 1024;
            *(_DWORD *)(v73 + 10) = v75;
            *(_WORD *)(v73 + 14) = 1024;
            *(_DWORD *)(v73 + 16) = v76;
            *(_WORD *)(v73 + 20) = 1024;
            *(_DWORD *)(v73 + 22) = v77;
            *(_WORD *)(v73 + 26) = 1024;
            *(_DWORD *)(v73 + 28) = v78;
            *(_WORD *)(v73 + 32) = 1024;
            *(_DWORD *)(v73 + 34) = v79;
            *(_WORD *)(v73 + 38) = 1024;
            *(_DWORD *)(v73 + 40) = v80;
            *(_WORD *)(v73 + 44) = 1024;
            *(_DWORD *)(v73 + 46) = v81;
            *(_WORD *)(v73 + 50) = 1024;
            *(_DWORD *)(v73 + 52) = (_DWORD)v74;
            __SC_log_send(5LL, v68, v69, v71);
          }

          else
          {
            ++v67;
          }

          int v66 = v114;
        }

        while (v67 < v114);
      }

      sub_4928(*(void *)(v6 + 8), (uint64_t)sub_122BC, a1, 6LL, v56, v66);
      free(v56);
    }

    else if (v59)
    {
      uint64_t v93 = _os_log_pack_size(12LL);
      int v94 = (char *)&v110 - ((__chkstk_darwin(v93) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      int v95 = __error();
      uint64_t v96 = _os_log_pack_fill( v94,  v93,  *v95,  &dword_0,  "DHCP %s: ARP router: No leases to query for",  (const char *)v110);
      uint64_t v97 = nullsub_1(v7);
      *(_DWORD *)uint64_t v96 = 136315138;
      *(void *)(v96 + 4) = v97;
      __SC_log_send(5LL, v57, v58, v94);
    }

    return;
  }

  uint64_t v8 = sub_19BF0(a1);
  if (v8)
  {
    unsigned int v9 = (const void *)v8;
    uint64_t v10 = (const void *)sub_19C04(a1);
    double v111 = *(double *)a3 - (double)G_router_arp_wifi_lease_start_threshold_secs;
    unsigned __int8 v11 = &v111;
    goto LABEL_29;
  }

  uint64_t v98 = sub_57538();
  uint64_t v99 = _SC_syslog_os_log_mapping(5LL);
  if (__SC_log_enabled(5LL, v98, v99))
  {
    uint64_t v100 = _os_log_pack_size(12LL);
    int v101 = (char *)&v110 - ((__chkstk_darwin(v100) + 15) & 0xFFFFFFFFFFFFFFF0LL);
    double v102 = __error();
    uint64_t v103 = _os_log_pack_fill( v101,  v100,  *v102,  &dword_0,  "dhcp_arp_router: %s SSID unavailable",  (const char *)v110);
    uint64_t v104 = nullsub_1(v7);
    *(_DWORD *)uint64_t v103 = 136315138;
    *(void *)(v103 + 4) = v104;
    __SC_log_send(5LL, v98, v99, v101);
  }

void sub_12D98(_DWORD *a1, int a2, uint64_t a3)
{
  double current_time = timer_get_current_time();
  uint64_t v7 = sub_194C4((uint64_t)a1);
  uint64_t v8 = sub_14834((uint64_t)a1);
  if (a2 != 6)
  {
    if (a2) {
      return;
    }
    int v9 = *(_DWORD *)(v7 + 1744);
    sub_1175C((uint64_t)a1, 5u);
    *(_DWORD *)(v7 + 116) = 1;
    *(_DWORD *)(v7 + 40) = 1;
    *(void *)(v7 + 1776) = 0LL;
    sub_11718((uint64_t)a1);
    if ((v9 - 7) > 1)
    {
      sub_18014((uint64_t)a1);
      if (!sub_194B4((uint64_t)a1))
      {
        if (!sub_13834(v8) && v9 == 4)
        {
          sub_45A8(*(void *)(v7 + 8), (uint64_t)sub_12D98, (uint64_t)a1, 6LL, 0, *(_DWORD *)(v7 + 1732));
          return;
        }

        int v29 = sub_194D4((uint64_t)a1);
        if (v29 == *(_DWORD *)(v7 + 1732) && (v9 == 6 || v9 == 3))
        {
          sub_3858(*(void *)(v7 + 8), (uint64_t)sub_12D98, (uint64_t)a1, 6LL, 0, v29, 1);
          return;
        }
      }
    }

    else
    {
      double v10 = *(double *)(v7 + 88);
      BOOL v11 = v10 >= current_time && v10 - current_time > (double)dword_6C040;
      *(_DWORD *)(v7 + 116) = v11;
    }

    goto LABEL_30;
  }

  if (*(_DWORD *)(a3 + 8))
  {
    uint64_t v12 = sub_57538();
    uint64_t v13 = _SC_syslog_os_log_mapping(5LL);
    if (__SC_log_enabled(5LL, v12, v13))
    {
      uint64_t v14 = _os_log_pack_size(22LL);
      uint64_t v15 = (char *)&v54 - ((__chkstk_darwin(v14) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v16 = __error();
      uint64_t v17 = _os_log_pack_fill(v15, v14, *v16, &dword_0, "DHCP %s: ARP probe failed, %s", v54, v55);
      uint64_t v18 = nullsub_1(v8);
      uint64_t v19 = sub_4AE0(*(void *)(v7 + 8));
      *(_DWORD *)uint64_t v17 = 136315394;
      *(void *)(v17 + 4) = v18;
      *(_WORD *)(v17 + 12) = 2080;
      *(void *)(v17 + 14) = v19;
      __SC_log_send(5LL, v12, v13, v15);
    }

    sub_B424((uint64_t)a1, 6u);
    return;
  }

  if (*(_DWORD *)(a3 + 12))
  {
    snprintf( __str,  0x80uLL,  "%d.%d.%d.%d in use by %02x:%02x:%02x:%02x:%02x:%02x, DHCP Server %d.%d.%d.%d",  *(unsigned __int8 *)(v7 + 1732),  *(unsigned __int8 *)(v7 + 1733),  *(unsigned __int8 *)(v7 + 1734),  *(unsigned __int8 *)(v7 + 1735),  *(unsigned __int8 *)(a3 + 24),  *(unsigned __int8 *)(a3 + 25),  *(unsigned __int8 *)(a3 + 26),  *(unsigned __int8 *)(a3 + 27),  *(unsigned __int8 *)(a3 + 28),  *(unsigned __int8 *)(a3 + 29),  *(unsigned __int8 *)(v7 + 1736),  *(unsigned __int8 *)(v7 + 1737),  *(unsigned __int8 *)(v7 + 1738),  *(unsigned __int8 *)(v7 + 1739));
    int v20 = *(_DWORD *)(v7 + 1732);
    if (*(_DWORD *)(v7 + 36) == v20)
    {
      if (*(_DWORD *)(v7 + 2336))
      {
LABEL_23:
        *(_DWORD *)(v7 + 36) = v20;
        uint64_t v22 = sub_57538();
        uint64_t v23 = _SC_syslog_os_log_mapping(5LL);
        if (__SC_log_enabled(5LL, v22, v23))
        {
          uint64_t v24 = _os_log_pack_size(22LL);
          uint64_t v25 = (char *)&v54 - ((__chkstk_darwin(v24) + 15) & 0xFFFFFFFFFFFFFFF0LL);
          uint64_t v26 = __error();
          uint64_t v27 = _os_log_pack_fill(v25, v24, *v26, &dword_0, "DHCP %s: %s", v54, v55);
          uint64_t v28 = nullsub_1(v8);
          *(_DWORD *)uint64_t v27 = 136315394;
          *(void *)(v27 + 4) = v28;
          *(_WORD *)(v27 + 12) = 2080;
          *(void *)(v27 + 14) = __str;
          __SC_log_send(5LL, v22, v23, v25);
        }

        sub_B5A8((uint64_t)a1, 0);
        sub_AE1C(v7);
        sub_14F54((uint64_t)a1);
        sub_17FEC((uint64_t)a1, 8u);
        sub_B6E8((uint64_t)a1);
        return;
      }

      int v21 = 1;
    }

    else
    {
      int v21 = 0;
    }

    *(_DWORD *)(v7 + 2336) = v21;
    goto LABEL_23;
  }

  sub_11718((uint64_t)a1);
LABEL_30:
  *(_DWORD *)(v7 + 56) = 1;
  int v30 = (const void *)sub_19BF0((uint64_t)a1);
  sub_B498(v7, v30);
  int v31 = (const void *)sub_19C04((uint64_t)a1);
  sub_B4D4(v7, v31);
  *(_DWORD *)(v7 + 36) = 0;
  *(_DWORD *)(v7 + 2336) = 0;
  uint64_t v32 = v7 + 208;
  int v33 = sub_50E4C(v7 + 208, 1, 4);
  if (v33) {
    unsigned int v34 = *(_DWORD *)v33;
  }
  else {
    unsigned int v34 = 0;
  }
  int v35 = *(_DWORD *)(v7 + 1732);
  uint64_t v36 = sub_57538();
  uint64_t v37 = _SC_syslog_os_log_mapping(5LL);
  if (__SC_log_enabled(5LL, v36, v37))
  {
    uint64_t v38 = _os_log_pack_size(22LL);
    uint64_t v55 = (const char *)&v54;
    uint64_t v39 = (char *)&v54 - ((__chkstk_darwin(v38) + 15) & 0xFFFFFFFFFFFFFFF0LL);
    uint64_t v40 = __error();
    uint64_t v41 = _os_log_pack_fill(v39, v38, *v40, &dword_0, "dhcp_bound(%s) %s", v54, v55);
    uint64_t v42 = v8;
    uint64_t v43 = nullsub_1(v8);
    uint64_t v44 = inet_ntop(2, (const void *)(v7 + 1732), __str, 0x10u);
    *(_DWORD *)uint64_t v41 = 136315394;
    *(void *)(v41 + 4) = v43;
    uint64_t v8 = v42;
    uint64_t v32 = v7 + 208;
    *(_WORD *)(v41 + 12) = 2080;
    *(void *)(v41 + 14) = v44;
    __SC_log_send(5LL, v36, v37, v39);
  }

  if (dword_6C028) {
    sub_18090((uint64_t)a1, 0);
  }
  *(_DWORD *)(v7 + 40) = 0;
  if (*(_DWORD *)(v7 + 72) == -1)
  {
    uint64_t v47 = sub_57538();
    uint64_t v48 = _SC_syslog_os_log_mapping(5LL);
    if (__SC_log_enabled(5LL, v47, v48))
    {
      uint64_t v49 = _os_log_pack_size(12LL);
      int v50 = (char *)&v54 - ((__chkstk_darwin(v49) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      int v51 = __error();
      uint64_t v52 = _os_log_pack_fill(v50, v49, *v51, &dword_0, "DHCP %s: infinite lease", v54);
      uint64_t v53 = nullsub_1(v8);
      *(_DWORD *)uint64_t v52 = 136315138;
      *(void *)(v52 + 4) = v53;
      __SC_log_send(5LL, v47, v48, v50);
    }
  }

  else
  {
    double v45 = *(double *)(v7 + 88);
    if (v45 >= current_time) {
      uint64_t v46 = (uint64_t)(v45 - current_time);
    }
    else {
      uint64_t v46 = 0LL;
    }
    *(double *)(v7 + 192) = v45;
    timer_set_relative(*(void *)(v7 + 1760), v46, v45 < current_time, (uint64_t)sub_E1B4, (uint64_t)a1, 0LL, 0LL);
    if (v45 < current_time)
    {
      *(_DWORD *)(v7 + 200) = 0;
LABEL_50:
      sub_C2E4((uint64_t)a1, (const void *)(v7 + 224), *(_DWORD *)(v7 + 1724), *(_DWORD *)(v7 + 116));
      *(_DWORD *)(v7 + 116) = 0;
      sub_13B04((uint64_t)a1);
      sub_150A4((uint64_t)a1, 0);
      return;
    }
  }

  *(_DWORD *)(v7 + 200) = 0;
  if (!sub_14EC8(a1, v32, *(_DWORD *)(v7 + 1732))
    || !sub_14564((uint64_t)a1, *(void *)(v7 + 8), (uint64_t)sub_13B5C, *(_DWORD *)(v7 + 1732)))
  {
    goto LABEL_50;
  }

uint64_t sub_13568(uint64_t a1, _DWORD *a2)
{
  uint64_t v3 = sub_50DA0(a1, 108, &v5, 0LL);
  uint64_t result = 0LL;
  if (v3)
  {
    if (v5 == 4)
    {
      *a2 = bswap32(*(_DWORD *)v3);
      return 1LL;
    }
  }

  return result;
}

uint64_t sub_135C4(uint64_t a1, int a2, _DWORD *a3)
{
  uint64_t v6 = sub_194C4(a1);
  uint64_t result = sub_14834(a1);
  uint64_t v8 = result;
  if (a2 == 2)
  {
    uint64_t v17 = sub_57538();
    uint64_t v18 = _SC_syslog_os_log_mapping(5LL);
    if (__SC_log_enabled(5LL, v17, v18))
    {
      uint64_t v19 = _os_log_pack_size(12LL);
      int v20 = (char *)&v25 - ((__chkstk_darwin(v19) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      int v21 = __error();
      uint64_t v22 = _os_log_pack_fill(v20, v19, *v21, &dword_0, "DHCP %s: WAIT wakeup", v25);
      uint64_t v23 = nullsub_1(v8);
      *(_DWORD *)uint64_t v22 = 136315138;
      *(void *)(v22 + 4) = v23;
      __SC_log_send(5LL, v17, v18, v20);
    }

    uint64_t v26 = sub_19384(a1);
    int v27 = v24;
    return sub_BC50(a1, 0LL, &v26);
  }

  else if (!a2)
  {
    if (*a3 <= 0x12Cu) {
      uint64_t v9 = 300LL;
    }
    else {
      uint64_t v9 = *a3;
    }
    uint64_t v10 = sub_57538();
    uint64_t v11 = _SC_syslog_os_log_mapping(5LL);
    if (__SC_log_enabled(5LL, v10, v11))
    {
      uint64_t v12 = _os_log_pack_size(18LL);
      uint64_t v13 = (char *)&v25 - ((__chkstk_darwin(v12) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v14 = __error();
      uint64_t v15 = _os_log_pack_fill(v13, v12, *v14, &dword_0, "DHCP %s: WAIT %us", v25, v26);
      uint64_t v16 = nullsub_1(v8);
      *(_DWORD *)uint64_t v15 = 136315394;
      *(void *)(v15 + 4) = v16;
      *(_WORD *)(v15 + 12) = 1024;
      *(_DWORD *)(v15 + 14) = v9;
      __SC_log_send(5LL, v10, v11, v13);
    }

    sub_B424(a1, 0x15u);
    return timer_set_relative(*(void *)(v6 + 1760), v9, 0, (uint64_t)sub_135C4, a1, 2LL, 0LL);
  }

  return result;
}

BOOL sub_13834(uint64_t a1)
{
  return sub_54EB4(a1) || sub_54EA8(a1) != 0;
}

uint64_t sub_13870(uint64_t a1, unsigned int a2)
{
  uint64_t v4 = sub_194C4(a1);
  uint64_t v5 = sub_14834(a1);
  sub_1175C(a1, 2u);
  uint64_t v6 = a2;
  if (a2)
  {
    uint64_t v7 = sub_57538();
    uint64_t v8 = _SC_syslog_os_log_mapping(5LL);
    if (__SC_log_enabled(5LL, v7, v8))
    {
      uint64_t v9 = _os_log_pack_size(12LL);
      uint64_t v10 = (char *)&v23 - ((__chkstk_darwin(v9) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v11 = __error();
      uint64_t v12 = _os_log_pack_fill(v10, v9, *v11, &dword_0, "dhcp_unbound(%s) received NAK", v23);
      uint64_t v13 = nullsub_1(v5);
      *(_DWORD *)uint64_t v12 = 136315138;
      *(void *)(v12 + 4) = v13;
      __SC_log_send(5LL, v7, v8, v10);
    }
  }

  uint64_t v14 = sub_57538();
  uint64_t v15 = _SC_syslog_os_log_mapping(5LL);
  if (__SC_log_enabled(5LL, v14, v15))
  {
    uint64_t v16 = _os_log_pack_size(22LL);
    uint64_t v17 = (char *)&v23 - ((__chkstk_darwin(v16) + 15) & 0xFFFFFFFFFFFFFFF0LL);
    uint64_t v18 = __error();
    uint64_t v19 = _os_log_pack_fill(v17, v16, *v18, &dword_0, "dhcp_unbound(%s) dropping %s", v23, v24);
    uint64_t v20 = nullsub_1(v5);
    int v21 = inet_ntop(2, (const void *)(v4 + 1732), (char *)&v24, 0x10u);
    *(_DWORD *)uint64_t v19 = 136315394;
    *(void *)(v19 + 4) = v20;
    *(_WORD *)(v19 + 12) = 2080;
    *(void *)(v19 + 14) = v21;
    __SC_log_send(5LL, v14, v15, v17);
  }

  sub_11718(a1);
  sub_B5A8(a1, v6 != 0);
  sub_18A00(a1);
  *(_DWORD *)(v4 + 1732) = 0;
  sub_AE1C(v4);
  *(_DWORD *)(v4 + 48) = 0;
  sub_14F54(a1);
  sub_150A4(a1, 0);
  return timer_set_relative(*(void *)(v4 + 1760), 0LL, 1000, (uint64_t)sub_C4A4, a1, 0LL, 0LL);
}

void sub_13B04(uint64_t a1)
{
  uint64_t v2 = sub_194C4(a1);
  uint64_t v4 = v2 + 224;
  int v5 = *(_DWORD *)(v2 + 1724);
  uint64_t v6 = v2 + 208;
  uint64_t v3 = *(void *)(v2 + 64);
  uint64_t v7 = *(void *)(v2 + 80);
  uint64_t v8 = v3;
  sub_154F8(a1, (uint64_t)&v4);
}

void sub_13B5C(uint64_t a1, int a2)
{
  uint64_t v4 = sub_194C4(a1);
  sub_150A4(a1, 0);
  if (a2)
  {
    if (a2 == 1)
    {
      timer_set_relative(*(void *)(v4 + 1760), 60LL, 0, (uint64_t)sub_13C2C, a1, 0LL, 0LL);
      if (!*(_DWORD *)(v4 + 200))
      {
        *(_DWORD *)(v4 + 200) = 1;
        sub_13B04(a1);
        sub_C2E4(a1, (const void *)(v4 + 224), *(_DWORD *)(v4 + 1724), 1);
      }
    }
  }

  else
  {
    sub_C2E4(a1, (const void *)(v4 + 224), *(_DWORD *)(v4 + 1724), *(_DWORD *)(v4 + 116));
    *(_DWORD *)(v4 + 116) = 0;
    sub_13B04(a1);
  }

uint64_t sub_13C2C(uint64_t a1)
{
  uint64_t v2 = sub_194C4(a1);
  return sub_14564(a1, *(void *)(v2 + 8), (uint64_t)sub_13B5C, *(_DWORD *)(v2 + 1732));
}

uint64_t sub_13C60(uint64_t a1, __n128 a2)
{
  __n128 v14 = a2;
  uint64_t v3 = (float64x2_t *)sub_194C4(a1);
  uint64_t v4 = sub_14834(a1);
  uint64_t v5 = v14.n128_i64[0];
  v3[4].f64[0] = v3[4].f64[0] + v14.n128_f64[0];
  v3[5] = vaddq_f64(v3[5], (float64x2_t)vdupq_lane_s64(v5, 0));
  v3[6].f64[0] = v3[6].f64[0] + *(double *)&v5;
  uint64_t v6 = sub_57538();
  uint64_t v7 = _SC_syslog_os_log_mapping(6LL);
  uint64_t result = __SC_log_enabled(6LL, v6, v7);
  if ((_DWORD)result)
  {
    uint64_t v9 = _os_log_pack_size(22LL);
    uint64_t v10 = (char *)&v14 - ((__chkstk_darwin(v9) + 15) & 0xFFFFFFFFFFFFFFF0LL);
    uint64_t v11 = __error();
    uint64_t v12 = _os_log_pack_fill( v10,  v9,  *v11,  &dword_0,  "DHCP %s: adjusted lease by %g seconds",  (const char *)v14.n128_u64[0],  v14.n128_f64[1]);
    uint64_t v13 = nullsub_1(v4);
    *(_DWORD *)uint64_t v12 = 136315394;
    *(void *)(v12 + 4) = v13;
    *(_WORD *)(v12 + 12) = 2048;
    *(void *)(v12 + 14) = v14.n128_u64[0];
    return __SC_log_send(6LL, v6, v7, v10);
  }

  return result;
}

uint64_t sub_13DC8(uint64_t a1)
{
  uint64_t v2 = sub_14834(a1);
  uint64_t v3 = sub_194C4(a1);
  int v4 = sub_194EC(a1);
  int v5 = *(_DWORD *)(v3 + 1732);
  int v6 = *(_DWORD *)(v3 + 1736);
  if (((v6 ^ v5) & v4) != 0)
  {
    int v6 = sub_F630(v3 + 208, v5);
  }

  LODWORD(v38) = v6;
  int v7 = arp_open_routing_socket();
  if (v7 == -1)
  {
    uint64_t v11 = sub_57538();
    uint64_t v12 = _SC_syslog_os_log_mapping(5LL);
    uint64_t result = __SC_log_enabled(5LL, v11, v12);
    if ((_DWORD)result)
    {
      uint64_t v13 = _os_log_pack_size(22LL);
      __n128 v14 = (char *)&v36 - ((__chkstk_darwin(v13) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v15 = __error();
      uint64_t v16 = _os_log_pack_fill( v14,  v13,  *v15,  &dword_0,  "DHCP %s: arp_open_routing_socket() failed, %s",  v36,  v37);
      uint64_t v17 = nullsub_1(v2);
      uint64_t v18 = __error();
      uint64_t v19 = strerror(*v18);
      *(_DWORD *)uint64_t v16 = 136315394;
      *(void *)(v16 + 4) = v17;
      *(_WORD *)(v16 + 12) = 2080;
      *(void *)(v16 + 14) = v19;
      return __SC_log_send(5LL, v11, v12, v14);
    }
  }

  else
  {
    int v8 = v7;
    int v9 = sub_54F6C(v2);
    if (!arp_get(v8, (uint64_t)v40, v6, v9))
    {
      for (int i = 1; ; ++i)
      {
        int v21 = (const sockaddr_dl *)&v41[v41[0]];
        if (v21->sdl_family == 18)
        {
          if (v21->sdl_alen) {
            break;
          }
        }

        if (i == 5)
        {
          uint64_t v22 = sub_57538();
          uint64_t v23 = _SC_syslog_os_log_mapping(5LL);
          uint64_t v24 = _os_log_pack_size(22LL);
          uint64_t v25 = (char *)&v36 - ((__chkstk_darwin(v24) + 15) & 0xFFFFFFFFFFFFFFF0LL);
          uint64_t v26 = __error();
          uint64_t v27 = _os_log_pack_fill(v25, v24, *v26, &dword_0, "DHCP %s: %s was NOT resolved", v36, v37);
          uint64_t v28 = nullsub_1(v2);
          int v29 = inet_ntop(2, &v38, (char *)&v38 + 4, 0x10u);
          *(_DWORD *)uint64_t v27 = 136315394;
          *(void *)(v27 + 4) = v28;
          *(_WORD *)(v27 + 12) = 2080;
          *(void *)(v27 + 14) = v29;
          goto LABEL_20;
        }

        usleep(0x3E8u);
      }

      uint64_t v22 = sub_57538();
      uint64_t v23 = _SC_syslog_os_log_mapping(5LL);
      uint64_t v30 = _os_log_pack_size(38LL);
      uint64_t v37 = (const char *)&v36;
      uint64_t v25 = (char *)&v36 - ((__chkstk_darwin(v30) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      int v31 = __error();
      uint64_t v32 = _os_log_pack_fill( v25,  v30,  *v31,  &dword_0,  "DHCP %s: %s is resolved, %s after trying %d time(s)",  v36,  v37,  v38,  v39);
      uint64_t v33 = nullsub_1(v2);
      unsigned int v34 = inet_ntop(2, &v38, (char *)&v38 + 4, 0x10u);
      int v35 = link_ntoa(v21);
      *(_DWORD *)uint64_t v32 = 136315906;
      *(void *)(v32 + 4) = v33;
      *(_WORD *)(v32 + 12) = 2080;
      *(void *)(v32 + 14) = v34;
      *(_WORD *)(v32 + 22) = 2080;
      *(void *)(v32 + 24) = v35;
      *(_WORD *)(v32 + 32) = 1024;
      *(_DWORD *)(v32 + 34) = i;
LABEL_20:
      __SC_log_send(5LL, v22, v23, v25);
    }

    return close(v8);
  }

  return result;
}

void *sub_141BC(int a1, uint64_t a2, uint64_t a3, uint64_t a4, void *a5)
{
  if (fstat(a1, &v28) < 0)
  {
    uint64_t v13 = sub_57538();
    uint64_t v14 = _SC_syslog_os_log_mapping(3LL);
    if (__SC_log_enabled(3LL, v13, v14))
    {
      uint64_t v15 = _os_log_pack_size(28LL);
      uint64_t v16 = (char *)&handler - ((__chkstk_darwin(v15) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v17 = __error();
      uint64_t v18 = _os_log_pack_fill( v16,  v15,  *v17,  &dword_0,  "%s: fstat %s (%d)",  (const char *)handler,  (const char *)v24,  (_DWORD)v25);
      uint64_t v19 = __error();
      uint64_t v20 = strerror(*v19);
      int v21 = *__error();
      *(_DWORD *)uint64_t v18 = 136315650;
      *(void *)(v18 + 4) = "FDCalloutCreate";
      *(_WORD *)(v18 + 12) = 2080;
      *(void *)(v18 + 14) = v20;
      *(_WORD *)(v18 + 22) = 1024;
      *(_DWORD *)(v18 + 24) = v21;
      __SC_log_send(3LL, v13, v14, v16);
    }

    return 0LL;
  }

  else
  {
    uint64_t v10 = malloc(0x28uLL);
    *(_DWORD *)uint64_t v10 = a1;
    *((_DWORD *)v10 + 1) = 0;
    *((void *)v10 + 2) = a2;
    *((void *)v10 + 3) = a3;
    *((void *)v10 + 4) = a4;
    uint64_t v11 = sub_2A814();
    uint64_t v12 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_read, a1, 0LL, v11);
    *((void *)v10 + 1) = v12;
    dispatch_source_set_cancel_handler(v12, a5);
    handler = _NSConcreteStackBlock;
    uint64_t v24 = 0x40000000LL;
    uint64_t v25 = sub_143BC;
    uint64_t v26 = &unk_64C60;
    uint64_t v27 = v10;
    dispatch_source_set_event_handler(v12, &handler);
    dispatch_activate(*((dispatch_object_t *)v10 + 1));
  }

  return v10;
}

uint64_t sub_143BC(uint64_t result)
{
  uint64_t v1 = *(void **)(result + 32);
  uint64_t v2 = (uint64_t (*)(void, void))v1[2];
  if (v2) {
    return v2(v1[3], v1[4]);
  }
  return result;
}

void sub_143D4(dispatch_object_t **a1)
{
  uint64_t v1 = *a1;
  if (*a1)
  {
    uint64_t v3 = (dispatch_source_s *)v1[1];
    if (v3)
    {
      dispatch_source_cancel(v3);
      dispatch_release(v1[1]);
    }

    free(v1);
    *a1 = 0LL;
  }

uint64_t sub_14418(unsigned int *a1)
{
  return *a1;
}

const char *sub_14420(int a1)
{
  switch(a1)
  {
    case 256:
      uint64_t result = "NONE-V4";
      break;
    case 257:
      uint64_t result = "MANUAL";
      break;
    case 258:
      uint64_t result = "BOOTP";
      break;
    case 259:
      uint64_t result = "DHCP";
      break;
    case 260:
      uint64_t result = "INFORM";
      break;
    case 261:
      uint64_t result = "LINKLOCAL";
      break;
    case 262:
      uint64_t result = "FAILOVER";
      break;
    default:
      switch(a1)
      {
        case 512:
          uint64_t result = "NONE-V6";
          break;
        case 513:
          uint64_t result = "MANUAL-V6";
          break;
        case 514:
          uint64_t result = "AUTOMATIC-V6";
          break;
        case 515:
          uint64_t result = "RTADV";
          break;
        case 516:
          uint64_t result = "6TO4";
          break;
        case 517:
          uint64_t result = "LINKLOCAL-V6";
          break;
        case 518:
          uint64_t result = "DHCPV6-PD";
          break;
        default:
          uint64_t result = "NONE";
          break;
      }

      break;
  }

  return result;
}

uint64_t sub_1451C()
{
  return qword_6C148;
}

void sub_14528(uint64_t a1, uint64_t a2)
{
  if (a2) {
    sub_4718(a2);
  }
  if ((*(_BYTE *)(a1 + 25) & 1) != 0) {
    *(_DWORD *)(a1 + 116) &= ~8u;
  }
}

uint64_t sub_14564(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  if (!G_discover_and_publish_router_mac_address) {
    return 0LL;
  }
  uint64_t v5 = *(void *)(*(void *)(a1 + 16) + 8LL);
  if ((*(_BYTE *)(a1 + 25) & 1) == 0
    || (int v6 = *(_DWORD *)(a1 + 116), *(_DWORD *)(a1 + 116) = v6 & 0xFFFFFFFB, (v6 & 1) == 0))
  {
    uint64_t v7 = sub_57538();
    uint64_t v8 = _SC_syslog_os_log_mapping(5LL);
    uint64_t result = __SC_log_enabled(5LL, v7, v8);
    if (!(_DWORD)result) {
      return result;
    }
    uint64_t v10 = _os_log_pack_size(12LL);
    uint64_t v11 = (char *)&v26 - ((__chkstk_darwin(v10) + 15) & 0xFFFFFFFFFFFFFFF0LL);
    uint64_t v12 = __error();
    uint64_t v13 = _os_log_pack_fill( v11,  v10,  *v12,  &dword_0,  "service_resolve_router %s: IP address missing",  v26);
    uint64_t v14 = nullsub_1(v5);
    *(_DWORD *)uint64_t v13 = 136315138;
    *(void *)(v13 + 4) = v14;
    __SC_log_send(5LL, v7, v8, v11);
    return 0LL;
  }

  *(_DWORD *)(a1 + 116) = v6 & 0xFFFFFFE3 | 8;
  int v18 = *(_DWORD *)(a1 + 120);
  uint64_t v19 = sub_57538();
  uint64_t v20 = _SC_syslog_os_log_mapping(6LL);
  if (__SC_log_enabled(6LL, v19, v20))
  {
    uint64_t v26 = (const char *)HIBYTE(a4);
    uint64_t v28 = HIBYTE(v18);
    uint64_t v21 = _os_log_pack_size(60LL);
    uint64_t v27 = &v26;
    uint64_t v22 = (char *)&v26 - ((__chkstk_darwin(v21) + 15) & 0xFFFFFFFFFFFFFFF0LL);
    uint64_t v23 = __error();
    uint64_t v24 = _os_log_pack_fill( v22,  v21,  *v23,  &dword_0,  "service_resolve_router %s: sender %d.%d.%d.%d target %d.%d.%d.%d started",  v26,  (_DWORD)v27,  v28,  v29,  v30,  v31,  v32,  v33,  v34);
    uint64_t v25 = nullsub_1(v5);
    *(_DWORD *)uint64_t v24 = 136317186;
    *(void *)(v24 + 4) = v25;
    *(_WORD *)(v24 + 12) = 1024;
    *(_DWORD *)(v24 + 14) = a4;
    *(_WORD *)(v24 + 18) = 1024;
    *(_DWORD *)(v24 + 20) = BYTE1(a4);
    *(_WORD *)(v24 + 24) = 1024;
    *(_DWORD *)(v24 + 26) = BYTE2(a4);
    *(_WORD *)(v24 + 30) = 1024;
    *(_DWORD *)(v24 + 32) = (_DWORD)v26;
    *(_WORD *)(v24 + 36) = 1024;
    *(_DWORD *)(v24 + 38) = v18;
    *(_WORD *)(v24 + 42) = 1024;
    *(_DWORD *)(v24 + 44) = BYTE1(v18);
    *(_WORD *)(v24 + 48) = 1024;
    *(_DWORD *)(v24 + 50) = BYTE2(v18);
    *(_WORD *)(v24 + 54) = 1024;
    *(_DWORD *)(v24 + 56) = v28;
    __SC_log_send(6LL, v19, v20, v22);
  }

  sub_4658(a2, (uint64_t)sub_14874, a1, a3, a4, v18, dword_6C080);
  return 1LL;
}

uint64_t sub_14834(uint64_t a1)
{
  return *(void *)(*(void *)(a1 + 16) + 8LL);
}

uint64_t sub_14840(uint64_t a1)
{
  if ((*(_BYTE *)(a1 + 25) & 1) != 0) {
    return *(_DWORD *)(a1 + 116) & 1;
  }
  else {
    return 0LL;
  }
}

uint64_t sub_1485C(uint64_t a1)
{
  if ((*(_BYTE *)(a1 + 25) & 1) != 0) {
    return *(unsigned int *)(a1 + 120);
  }
  else {
    return 0LL;
  }
}

uint64_t sub_14874(uint64_t a1, uint64_t (*a2)(uint64_t, uint64_t), uint64_t a3)
{
  if ((*(_BYTE *)(a1 + 25) & 1) != 0) {
    *(_DWORD *)(a1 + 116) &= ~8u;
  }
  uint64_t v6 = *(void *)(*(void *)(a1 + 16) + 8LL);
  if (*(_DWORD *)(a3 + 8))
  {
    uint64_t v7 = sub_57538();
    uint64_t v8 = _SC_syslog_os_log_mapping(5LL);
    if (__SC_log_enabled(5LL, v7, v8))
    {
      uint64_t v9 = _os_log_pack_size(22LL);
      uint64_t v10 = (char *)&v40 - ((__chkstk_darwin(v9) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v11 = __error();
      uint64_t v12 = _os_log_pack_fill( v10,  v9,  *v11,  &dword_0,  "service_resolve_router_complete %s: ARP failed, %s",  v40,  v41);
      uint64_t v13 = nullsub_1(v6);
      uint64_t v14 = sub_4AE0(*(void *)a3);
      *(_DWORD *)uint64_t v12 = 136315394;
      *(void *)(v12 + 4) = v13;
      *(_WORD *)(v12 + 12) = 2080;
      *(void *)(v12 + 14) = v14;
      __SC_log_send(5LL, v7, v8, v10);
    }

    uint64_t v15 = 99LL;
  }

  else if (*(_DWORD *)(a3 + 12))
  {
    int v16 = sub_54230(*(void *)(*(void *)(a1 + 16) + 8LL));
    memmove((void *)(a1 + 124), (const void *)(a3 + 24), v16);
    if ((*(_BYTE *)(a1 + 25) & 1) != 0) {
      *(_DWORD *)(a1 + 116) |= 7u;
    }
    uint64_t v17 = sub_57538();
    uint64_t v18 = _SC_syslog_os_log_mapping(6LL);
    if (__SC_log_enabled(6LL, v17, v18))
    {
      uint64_t v19 = _os_log_pack_size(36LL);
      uint64_t v20 = (char *)&v40 - ((__chkstk_darwin(v19) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v21 = __error();
      uint64_t v22 = _os_log_pack_fill( v20,  v19,  *v21,  &dword_0,  "service_resolve_router_complete %s: ARP %d.%d.%d.%d: response received",  v40,  (_DWORD)v41,  v42,  v43,  v44);
      uint64_t v23 = nullsub_1(v6);
      int v24 = *(unsigned __int8 *)(a1 + 120);
      int v25 = *(unsigned __int8 *)(a1 + 121);
      int v26 = *(unsigned __int8 *)(a1 + 122);
      int v27 = *(unsigned __int8 *)(a1 + 123);
      *(_DWORD *)uint64_t v22 = 136316162;
      *(void *)(v22 + 4) = v23;
      *(_WORD *)(v22 + 12) = 1024;
      *(_DWORD *)(v22 + 14) = v24;
      *(_WORD *)(v22 + 18) = 1024;
      *(_DWORD *)(v22 + 20) = v25;
      *(_WORD *)(v22 + 24) = 1024;
      *(_DWORD *)(v22 + 26) = v26;
      *(_WORD *)(v22 + 30) = 1024;
      *(_DWORD *)(v22 + 32) = v27;
      __SC_log_send(6LL, v17, v18, v20);
    }

    uint64_t v15 = 0LL;
  }

  else
  {
    uint64_t v28 = sub_57538();
    uint64_t v29 = _SC_syslog_os_log_mapping(6LL);
    if (__SC_log_enabled(6LL, v28, v29))
    {
      uint64_t v30 = _os_log_pack_size(36LL);
      uint64_t v31 = (char *)&v40 - ((__chkstk_darwin(v30) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v32 = __error();
      uint64_t v33 = _os_log_pack_fill( v31,  v30,  *v32,  &dword_0,  "service_resolve_router_complete %s: ARP router %d.%d.%d.%d: no response",  v40,  (_DWORD)v41,  v42,  v43,  v44);
      uint64_t v34 = nullsub_1(v6);
      int v35 = *(unsigned __int8 *)(a1 + 120);
      int v36 = *(unsigned __int8 *)(a1 + 121);
      int v37 = *(unsigned __int8 *)(a1 + 122);
      int v38 = *(unsigned __int8 *)(a1 + 123);
      *(_DWORD *)uint64_t v33 = 136316162;
      *(void *)(v33 + 4) = v34;
      *(_WORD *)(v33 + 12) = 1024;
      *(_DWORD *)(v33 + 14) = v35;
      *(_WORD *)(v33 + 18) = 1024;
      *(_DWORD *)(v33 + 20) = v36;
      *(_WORD *)(v33 + 24) = 1024;
      *(_DWORD *)(v33 + 26) = v37;
      *(_WORD *)(v33 + 30) = 1024;
      *(_DWORD *)(v33 + 32) = v38;
      __SC_log_send(6LL, v28, v29, v31);
    }

    if ((*(_BYTE *)(a1 + 25) & 1) != 0) {
      *(_DWORD *)(a1 + 116) |= 0x10u;
    }
    uint64_t v15 = 1LL;
  }

  return a2(a1, v15);
}

uint64_t sub_14C20(uint64_t a1, uint64_t a2)
{
  if (!G_discover_and_publish_router_mac_address) {
    return 0LL;
  }
  uint64_t v3 = *(void *)(*(void *)(a1 + 16) + 8LL);
  if ((*(_BYTE *)(a1 + 25) & 1) == 0
    || (int v4 = *(_DWORD *)(a1 + 116), *(_DWORD *)(a1 + 116) = v4 & 0xFFFFFFFB, (v4 & 1) == 0))
  {
    uint64_t v5 = sub_57538();
    uint64_t v6 = _SC_syslog_os_log_mapping(6LL);
    uint64_t result = __SC_log_enabled(6LL, v5, v6);
    if (!(_DWORD)result) {
      return result;
    }
    uint64_t v8 = _os_log_pack_size(12LL);
    uint64_t v9 = (char *)&v24 - ((__chkstk_darwin(v8) + 15) & 0xFFFFFFFFFFFFFFF0LL);
    uint64_t v10 = __error();
    uint64_t v11 = _os_log_pack_fill( v9,  v8,  *v10,  &dword_0,  "%s: service_populate_router_arpinfo gateway missing",  v24);
    uint64_t v12 = nullsub_1(v3);
    *(_DWORD *)uint64_t v11 = 136315138;
    *(void *)(v11 + 4) = v12;
    __SC_log_send(6LL, v5, v6, v9);
    return 0LL;
  }

  unsigned int v14 = *(_DWORD *)(a1 + 120);
  uint64_t v15 = sub_57538();
  uint64_t v16 = _SC_syslog_os_log_mapping(6LL);
  if (__SC_log_enabled(6LL, v15, v16))
  {
    uint64_t v17 = _os_log_pack_size(36LL);
    uint64_t v18 = (char *)&v24 - ((__chkstk_darwin(v17) + 15) & 0xFFFFFFFFFFFFFFF0LL);
    uint64_t v19 = __error();
    uint64_t v20 = _os_log_pack_fill( v18,  v17,  *v19,  &dword_0,  "%s: service_populate_router_arpinfo found gateway %d.%d.%d.%d",  v24,  v25,  v26,  v27,  v28);
    uint64_t v21 = nullsub_1(v3);
    *(_DWORD *)uint64_t v20 = 136316162;
    *(void *)(v20 + 4) = v21;
    *(_WORD *)(v20 + 12) = 1024;
    *(_DWORD *)(v20 + 14) = v14;
    *(_WORD *)(v20 + 18) = 1024;
    *(_DWORD *)(v20 + 20) = BYTE1(v14);
    *(_WORD *)(v20 + 24) = 1024;
    *(_DWORD *)(v20 + 26) = BYTE2(v14);
    *(_WORD *)(v20 + 30) = 1024;
    *(_DWORD *)(v20 + 32) = HIBYTE(v14);
    __SC_log_send(6LL, v15, v16, v18);
  }

  *(_DWORD *)(a2 + 4) = v14;
  unint64_t v22 = *(unsigned int *)(a1 + 24);
  if ((v22 & 0x100) != 0) {
    uint64_t v23 = (const void *)(a1 + 124);
  }
  else {
    uint64_t v23 = 0LL;
  }
  memmove((void *)(a2 + 8), v23, (v22 >> 4) & 0x10);
  return 1LL;
}

uint64_t sub_14EA4(uint64_t a1)
{
  if ((*(_BYTE *)(a1 + 25) & 1) != 0) {
    return a1 + 124;
  }
  else {
    return 0LL;
  }
}

uint64_t sub_14EB8(uint64_t a1)
{
  return (*(_DWORD *)(a1 + 24) >> 4) & 0x10;
}

uint64_t sub_14EC8(_DWORD *a1, uint64_t a2, int a3)
{
  unsigned int v4 = sub_F5BC(a2, a3, &v8);
  int v5 = a1[6];
  if (!v4)
  {
    if ((v5 & 0x100) != 0)
    {
      uint64_t result = 0LL;
      a1[29] = 0;
      return result;
    }

    return 0LL;
  }

  if ((v5 & 0x100) == 0) {
    return 1LL;
  }
  int v7 = v8;
  if ((~a1[29] & 7) == 0 && v8 == a1[30]) {
    return 0LL;
  }
  uint64_t result = 1LL;
  a1[29] = 1;
  a1[30] = v7;
  return result;
}

uint64_t sub_14F54(uint64_t result)
{
  if ((*(_BYTE *)(result + 25) & 1) != 0) {
    *(_DWORD *)(result + 116) = 0;
  }
  return result;
}

BOOL sub_14F64(uint64_t a1)
{
  return (*(_BYTE *)(a1 + 25) & 1) != 0 && (~*(_DWORD *)(a1 + 116) & 7) == 0;
}

uint64_t sub_14F88(uint64_t result, int a2)
{
  if ((*(_BYTE *)(result + 25) & 1) != 0) {
    *(_DWORD *)(result + 120) = a2;
  }
  return result;
}

uint64_t sub_14F98(uint64_t result)
{
  if ((*(_BYTE *)(result + 25) & 1) != 0) {
    *(_DWORD *)(result + 116) |= 1u;
  }
  return result;
}

uint64_t sub_14FB0(uint64_t a1, int a2)
{
  uint64_t v4 = 0LL;
  while (1)
  {
    uint64_t v5 = sub_50C98(&unk_6C150, v4) + 24;
LABEL_8:
    uint64_t v4 = (v4 + 1);
  }

  uint64_t v6 = 0LL;
  while (1)
  {
    uint64_t v7 = sub_50C98(v5, v6);
    if (v7 != a1 && *(_DWORD *)(v7 + 100) == a2) {
      return 1LL;
    }
    uint64_t v6 = (v6 + 1);
  }

_DWORD *sub_15078(_DWORD *result, _DWORD *a2)
{
  if (result) {
    *uint64_t result = dword_6C170;
  }
  if (a2) {
    *a2 = dword_6C174;
  }
  return result;
}

const char *sub_1509C(uint64_t a1)
{
  return sub_14420(*(_DWORD *)(a1 + 24));
}

void sub_150A4(uint64_t a1, int a2)
{
  if (*(_DWORD *)(a1 + 72) != a2)
  {
    *(_DWORD *)(a1 + 72) = a2;
    uint64_t v4 = sub_57538();
    uint64_t v5 = _SC_syslog_os_log_mapping(6LL);
    if (__SC_log_enabled(6LL, v4, v5))
    {
      uint64_t v6 = _os_log_pack_size(32LL);
      uint64_t v7 = (char *)v13 - ((__chkstk_darwin(v6) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      int v8 = __error();
      uint64_t v9 = _os_log_pack_fill(v7, v6, *v8, &dword_0, "%s %s: %s", v13[0], v13[1], v13[2]);
      uint64_t v10 = sub_14420(*(_DWORD *)(a1 + 24));
      uint64_t v11 = nullsub_1(*(void *)(*(void *)(a1 + 16) + 8LL));
      uint64_t v12 = "busy";
      *(_DWORD *)uint64_t v9 = 136315650;
      *(void *)(v9 + 4) = v10;
      *(_WORD *)(v9 + 12) = 2080;
      if (!a2) {
        uint64_t v12 = "not busy";
      }
      *(void *)(v9 + 14) = v11;
      *(_WORD *)(v9 + 22) = 2080;
      *(void *)(v9 + 24) = v12;
      __SC_log_send(6LL, v4, v5, v7);
    }

    sub_15218(*(void *)(a1 + 16));
  }

void sub_15218(uint64_t a1)
{
  else {
    int v2 = sub_20290(a1 + 56) != 0;
  }
  int v3 = (*(_DWORD *)a1 >> 1) & 1;
  uint64_t v4 = sub_57538();
  uint64_t v5 = _SC_syslog_os_log_mapping(7LL);
  if (__SC_log_enabled(7LL, v4, v5))
  {
    uint64_t v6 = _os_log_pack_size(42LL);
    uint64_t v7 = (char *)&v21 - ((__chkstk_darwin(v6) + 15) & 0xFFFFFFFFFFFFFFF0LL);
    int v8 = __error();
    uint64_t v9 = _os_log_pack_fill(v7, v6, *v8, &dword_0, "%s: %s current %s requested %s", v21, v22, v23, v24);
    uint64_t v10 = nullsub_1(*(void *)(a1 + 8));
    uint64_t v11 = "busy";
    *(_DWORD *)uint64_t v9 = 136315906;
    *(void *)(v9 + 4) = "IFStateProcessBusy";
    if (v3) {
      uint64_t v12 = "busy";
    }
    else {
      uint64_t v12 = "not busy";
    }
    *(void *)(v9 + 14) = v10;
    *(_WORD *)(v9 + 12) = 2080;
    *(_WORD *)(v9 + 22) = 2080;
    if (!v2) {
      uint64_t v11 = "not busy";
    }
    *(void *)(v9 + 24) = v12;
    *(_WORD *)(v9 + 32) = 2080;
    *(void *)(v9 + 34) = v11;
    __SC_log_send(7LL, v4, v5, v7);
  }

  if (v2 != v3)
  {
    *(_DWORD *)a1 = *(_DWORD *)a1 & 0xFFFFFFFD | (2 * (v2 & 1));
    uint64_t v13 = sub_57538();
    uint64_t v14 = _SC_syslog_os_log_mapping(6LL);
    if (__SC_log_enabled(6LL, v13, v14))
    {
      uint64_t v15 = _os_log_pack_size(22LL);
      uint64_t v16 = (char *)&v21 - ((__chkstk_darwin(v15) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v17 = __error();
      uint64_t v18 = _os_log_pack_fill(v16, v15, *v17, &dword_0, "%s: %s", v21, v22);
      uint64_t v19 = nullsub_1(*(void *)(a1 + 8));
      uint64_t v20 = "busy";
      if (!v2) {
        uint64_t v20 = "not busy";
      }
      *(_DWORD *)uint64_t v18 = 136315394;
      *(void *)(v18 + 4) = v19;
      *(_WORD *)(v18 + 12) = 2080;
      *(void *)(v18 + 14) = v20;
      __SC_log_send(6LL, v13, v14, v16);
    }

    sub_202F0(a1, @"IPConfigurationBusy", (*(_DWORD *)a1 >> 1) & 1);
  }

uint64_t sub_154A8(uint64_t a1)
{
  return sub_154B0(*(void *)(a1 + 16));
}

uint64_t sub_154B0(uint64_t a1)
{
  uint64_t result = sub_50C94(a1 + 24);
  if (!(_DWORD)result)
  {
    uint64_t v3 = *(void *)(a1 + 8);
    *(_DWORD *)a1 |= 1u;
    uint64_t v4 = (const char *)nullsub_1(v3);
    return sub_32224(v4);
  }

  return result;
}

void sub_154F8(uint64_t a1, uint64_t a2)
{
  int v91 = 0LL;
  CFMutableDictionaryRef v92 = 0LL;
  uint64_t v90 = 0LL;
  uint64_t v2 = *(void *)(a1 + 16);
  uint64_t v3 = *(void *)(v2 + 8);
  int v87 = 0;
  if (!*(void *)a1) {
    return;
  }
  uint64_t v6 = &off_6C000;
  if (!*(_DWORD *)(a1 + 40))
  {
    *(_DWORD *)(a1 + 40) = 1;
    *(_DWORD *)(a1 + 28) = 0;
    if (!qword_6C178) {
      return;
    }
LABEL_8:
    byte_6C1A0 = 1;
    *(_DWORD *)v2 |= 0x40u;
    dispatch_source_merge_data((dispatch_source_t)qword_6C1B0, 1uLL);
    if (a2) {
      goto LABEL_6;
    }
    goto LABEL_9;
  }

  int v7 = *(_DWORD *)(a1 + 28);
  *(_DWORD *)(a1 + 40) = 1;
  *(_DWORD *)(a1 + 28) = 0;
  if (!qword_6C178) {
    return;
  }
  if (v7) {
    goto LABEL_8;
  }
  if (a2)
  {
LABEL_6:
    uint64_t v8 = *(void *)(a2 + 16);
    goto LABEL_10;
  }

LABEL_9:
  uint64_t v8 = 0LL;
LABEL_10:
  uint64_t v10 = (void *)(a1 + 48);
  uint64_t v9 = *(const void **)(a1 + 48);
  if (v9)
  {
    uint64_t v11 = sub_160EC(v2, v9, 1);
    if (!v11) {
      return;
    }
    uint64_t v12 = v11;
    if (*((_DWORD *)v11 + 25)) {
      return;
    }
    if (*(_DWORD *)(a1 + 24) == 261)
    {
      uint64_t v13 = (CFStringRef *)(a1 + 48);
      if ((*(_BYTE *)(v2 + 2) & 0x40) != 0)
      {
        uint64_t v14 = sub_57538();
        uint64_t v15 = _SC_syslog_os_log_mapping(5LL);
        if (__SC_log_enabled(5LL, v14, v15))
        {
          uint64_t v16 = _os_log_pack_size(12LL);
          uint64_t v17 = (char *)&v79 - ((__chkstk_darwin(v16) + 15) & 0xFFFFFFFFFFFFFFF0LL);
          uint64_t v18 = __error();
          uint64_t v19 = _os_log_pack_fill( v17,  v16,  *v18,  &dword_0,  "%s: not publishing IPv4LL service, CLAT46 is active",  v79);
          uint64_t v20 = nullsub_1(v3);
          *(_DWORD *)uint64_t v19 = 136315138;
          *(void *)(v19 + 4) = v20;
          __SC_log_send(5LL, v14, v15, v17);
        }

        return;
      }
    }

    else
    {
      uint64_t v13 = (CFStringRef *)(a1 + 48);
    }
  }

  else
  {
    uint64_t v12 = 0LL;
    uint64_t v13 = (CFStringRef *)a1;
  }

  CFStringRef v85 = *v13;
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(0LL, 0LL, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  uint64_t v88 = Mutable;
  sub_4FFF4(Mutable, kSCPropNetIPv4Addresses, *(_DWORD *)(a1 + 100));
  sub_4FFF4(Mutable, kSCPropNetIPv4SubnetMasks, *(_DWORD *)(a1 + 104));
  CFDictionarySetValue(Mutable, kSCPropInterfaceName, *(const void **)(v2 + 16));
  if ((*(_BYTE *)v2 & 0x10) != 0 && !*v10)
  {
    LODWORD(valuePtr[0]) = 1;
    CFNumberRef v22 = CFNumberCreate(0LL, kCFNumberIntType, valuePtr);
    CFDictionarySetValue(Mutable, kSCPropNetOverridePrimary, v22);
    CFRelease(v22);
  }

  if (!v8)
  {
    if ((*(_BYTE *)(a1 + 25) & 1) != 0 && (*(_BYTE *)(a1 + 116) & 1) != 0)
    {
      int v27 = *(_DWORD *)(a1 + 120);
    }

    uint64_t v28 = 0LL;
    goto LABEL_48;
  }

  LODWORD(valuePtr[0]) = 0;
  if (*(_DWORD *)(a1 + 24) == 258 || sub_8F30(12))
  {
    uint64_t v23 = sub_50DA0(v8, 12, valuePtr, 0LL);
    if (v23)
    {
      if (SLODWORD(valuePtr[0]) >= 1)
      {
        CFStringRef v24 = CFStringCreateWithBytes(0LL, v23, LODWORD(valuePtr[0]), 0x8000100u, 0);
        if (v24)
        {
          CFStringRef v25 = v24;
          CFDictionarySetValue(Mutable, @"Hostname", v24);
          CFRelease(v25);
        }
      }
    }
  }

  else {
    uint64_t v26 = 0LL;
  }
  if (!sub_8F30(121))
  {
    uint64_t v28 = 0LL;
    goto LABEL_42;
  }

  uint64_t v29 = sub_F560(v8, &v87);
  uint64_t v28 = v29;
  if (v26 || !v29)
  {
LABEL_42:
    if (v26) {
      goto LABEL_43;
    }
    goto LABEL_48;
  }

  uint64_t v30 = sub_53CDC(v29, v87);
  if (v30)
  {
    uint64_t v26 = (unsigned __int8 *)(v30 + 2);
LABEL_43:
    uint64_t v86 = v28;
    uint64_t v84 = (void *)(a1 + 48);
    int v31 = *v26;
    int v32 = v26[1];
    int v33 = v26[2];
    int v34 = (v33 << 16) | (v32 << 8) | (v26[3] << 24) | v31;
    if ((v34 + 1) > 1)
    {
      sub_500AC(Mutable, kSCPropNetIPv4Router, v34);
    }

    else
    {
      HIDWORD(v80) = v26[3];
      int v83 = v33;
      uint64_t v35 = sub_57538();
      uint64_t v36 = _SC_syslog_os_log_mapping(5LL);
      uint64_t v81 = v35;
      LODWORD(v80) = v36;
      if (__SC_log_enabled(5LL, v35, v36))
      {
        uint64_t v37 = _os_log_pack_size(36LL);
        int v79 = (const char *)&v79;
        int v38 = (char *)&v79 - ((__chkstk_darwin(v37) + 15) & 0xFFFFFFFFFFFFFFF0LL);
        int v39 = __error();
        uint64_t v40 = _os_log_pack_fill( v38,  v37,  *v39,  &dword_0,  "%s: ignoring invalid router %d.%d.%d.%d",  v79,  (_DWORD)v80,  v81,  v82,  (_DWORD)v84);
        uint64_t v41 = nullsub_1(v3);
        *(_DWORD *)uint64_t v40 = 136316162;
        *(void *)(v40 + 4) = v41;
        *(_WORD *)(v40 + 12) = 1024;
        *(_DWORD *)(v40 + 14) = v31;
        *(_WORD *)(v40 + 18) = 1024;
        *(_DWORD *)(v40 + 20) = v32;
        *(_WORD *)(v40 + 24) = 1024;
        *(_DWORD *)(v40 + 26) = v83;
        *(_WORD *)(v40 + 30) = 1024;
        *(_DWORD *)(v40 + 32) = HIDWORD(v80);
        uint64_t v6 = &off_6C000;
        __SC_log_send(5LL, v81, v80, v38);
      }
    }

    uint64_t v10 = v84;
    uint64_t v28 = v86;
  }

  HIDWORD(v50) = 900;
  if (setsockopt(v3, 0xFFFF, 4230, (char *)&v50 + 4, 4u) < 0)
  {
    uint64_t v12 = sub_57538();
    uint64_t v13 = _SC_syslog_os_log_mapping(3LL);
    if (__SC_log_enabled(3LL, v12, v13))
    {
      uint64_t v14 = _os_log_pack_size(12LL);
      uint64_t v15 = (char *)&v50 - ((__chkstk_darwin(v14) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v16 = __error();
      uint64_t v17 = _os_log_pack_fill(v15, v14, *v16, &dword_0, "setsockopt(SO_TRAFFIC_CLASS) failed, %s", v50);
      uint64_t v18 = __error();
      uint64_t v19 = strerror(*v18);
      *(_DWORD *)uint64_t v17 = 136315138;
      *(void *)(v17 + 4) = v19;
      __SC_log_send(3LL, v12, v13, v15);
    }
  }

  HIDWORD(v50) = 0;
  if (setsockopt(v3, 0xFFFF, 4352, (char *)&v50 + 4, 4u) < 0)
  {
    uint64_t v20 = sub_57538();
    uint64_t v21 = _SC_syslog_os_log_mapping(3LL);
    if (__SC_log_enabled(3LL, v20, v21))
    {
      CFNumberRef v22 = _os_log_pack_size(12LL);
      uint64_t v23 = (char *)&v50 - ((__chkstk_darwin(v22) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      CFStringRef v24 = __error();
      CFStringRef v25 = _os_log_pack_fill(v23, v22, *v24, &dword_0, "setsockopt(SO_DEFUNCTOK) failed, %s", v50);
      uint64_t v26 = __error();
      int v27 = strerror(*v26);
      *(_DWORD *)CFStringRef v25 = 136315138;
      *(void *)(v25 + 4) = v27;
      __SC_log_send(3LL, v20, v21, v23);
    }
  }

  return v3;
}

      CFStringAppend(theString, @" proxy");
      goto LABEL_10;
    }

  *a2 = v11;
  if (a4) {
    *a4 = v9;
  }
  if (a3) {
    *a3 = v7;
  }
  return v12;
}

LABEL_48:
  if ((sub_54A84(v3) & 0x18) == 0)
  {
    uint64_t v86 = v28;
    if ((*(_BYTE *)(a1 + 25) & 1) != 0 && (~*(_DWORD *)(a1 + 116) & 7) == 0)
    {
      uint64_t v42 = *(void *)(*(void *)(a1 + 16) + 8LL);
      CFStringRef v43 = CFStringCreateWithFormat( 0LL,  0LL,  @"%d.%d.%d.%d",  *(unsigned __int8 *)(a1 + 120),  *(unsigned __int8 *)(a1 + 121),  *(unsigned __int8 *)(a1 + 122),  *(unsigned __int8 *)(a1 + 123));
      int v44 = sub_54230(v42);
      sub_55C30((char *)valuePtr, 48, (unsigned __int8 *)(a1 + 124), v44);
      CFStringRef v45 = CFStringCreateWithCString(0LL, (const char *)valuePtr, 0x600u);
      CFStringRef v46 = CFStringCreateWithFormat(0LL, 0LL, @"IPv4.Router=%@;IPv4.RouterHardwareAddress=%s", v43, valuePtr);
      CFDictionarySetValue(Mutable, @"NetworkSignature", v46);
      CFDictionarySetValue(Mutable, @"ARPResolvedIPAddress", v43);
      CFDictionarySetValue(Mutable, @"ARPResolvedHardwareAddress", v45);
      CFRelease(v46);
      CFRelease(v43);
      CFRelease(v45);
    }

    LODWORD(v47) = v87;
    LODWORD(valuePtr[0]) = *(_DWORD *)(a1 + 100);
    LODWORD(v95[0]) = 0xFFFF;
    LODWORD(v89) = 65193;
    uint64_t v48 = CFArrayCreateMutable(0LL, v87 + 2LL, &kCFTypeArrayCallBacks);
    CFDictionaryRef v49 = sub_38A28((int *)valuePtr, &G_ip_broadcast, 0LL);
    CFArrayAppendValue(v48, v49);
    CFRelease(v49);
    if (SLOWORD(valuePtr[0]) != -343)
    {
      CFDictionaryRef v50 = sub_38A28((int *)&v89, (int *)v95, 0LL);
      CFArrayAppendValue(v48, v50);
      CFRelease(v50);
    }

    int v51 = Mutable;
    if (v86)
    {
      uint64_t v47 = v47;
      int v51 = Mutable;
      if ((int)v47 >= 1)
      {
        uint64_t v84 = v10;
        uint64_t v52 = v86 + 2;
        do
        {
          if (*v52) {
            uint64_t v53 = v52;
          }
          else {
            uint64_t v53 = 0LL;
          }
          int v54 = *(v52 - 1);
          unsigned int v55 = v54 - 33;
          unsigned int v56 = -1 << -(char)v54;
          if (v55 < 0xFFFFFFE0) {
            unsigned int v56 = 0;
          }
          unsigned int v93 = bswap32(v56);
          unsigned int v94 = v93 & *(v52 - 2);
          CFDictionaryRef v57 = sub_38A28((int *)&v94, (int *)&v93, v53);
          CFArrayAppendValue(v48, v57);
          CFRelease(v57);
          v52 += 3;
          --v47;
        }

        while (v47);
        int v51 = v88;
        uint64_t v10 = v84;
      }
    }

    CFDictionarySetValue(Mutable, kSCPropNetIPv4AdditionalRoutes, v48);
    CFRelease(v48);
    CFDictionarySetValue(v51, kSCPropConfirmedInterfaceName, *(const void **)(v2 + 16));
    CFMutableDictionaryRef Mutable = v51;
    uint64_t v6 = &off_6C000;
    uint64_t v28 = v86;
  }

  if (v28)
  {
    free(v28);
    CFMutableDictionaryRef Mutable = v88;
  }

  unsigned int v94 = 0;
  sub_16170((uint64_t)valuePtr, (uint64_t)v95, (uint64_t)kSCEntNetIPv4, (uint64_t)Mutable, (int *)&v94);
  if (v12) {
    uint64_t v58 = (uint64_t)v12;
  }
  else {
    uint64_t v58 = a1;
  }
  int v91 = sub_162A8(v58, (__CFString *)a2, (CFDictionaryRef *)&v90);
  sub_16170((uint64_t)valuePtr, (uint64_t)v95, (uint64_t)kSCEntNetDNS, (uint64_t)v91, (int *)&v94);
  sub_16170((uint64_t)valuePtr, (uint64_t)v95, kSCEntNetCaptivePortal, v90, (int *)&v94);
  if (a2 && *(_DWORD *)(a2 + 8)) {
    CFMutableDictionaryRef v92 = sub_37A38( *(_DWORD *)(a1 + 24),  *(void *)(a2 + 16),  *(CFAbsoluteTime *)(a2 + 24),  *(CFAbsoluteTime *)(a2 + 32));
  }
  sub_16170((uint64_t)valuePtr, (uint64_t)v95, (uint64_t)kSCEntNetDHCP, (uint64_t)v92, (int *)&v94);
  if (*(_DWORD *)(a1 + 24) != 261) {
    sub_16170((uint64_t)valuePtr, (uint64_t)v95, (uint64_t)kCFNull, 0LL, (int *)&v94);
  }
  int v59 = v94;
  sub_37410((const __SCDynamicStore *)v6[47], v85, (const void **)valuePtr, v95, v94, *(_DWORD *)(a1 + 36));
  dispatch_source_merge_data((dispatch_source_t)qword_6C1B0, 1uLL);
  __int128 v60 = sub_16350(valuePtr, v95, v59);
  int v89 = v60;
  sub_4FA18((const void **)&v88);
  sub_4FA18((const void **)&v91);
  sub_4FA18((const void **)&v90);
  sub_4FA18((const void **)&v92);
  sub_2037C();
  uint64_t v61 = *(void *)(a1 + 16);
  byte_6C1A4 = 1;
  *(_DWORD *)(v61 + 144) = 1;
  dispatch_source_merge_data((dispatch_source_t)qword_6C1B0, 1uLL);
  if (dword_6C0C0)
  {
    byte_6C19C = 1;
    dispatch_source_merge_data((dispatch_source_t)qword_6C1B0, 1uLL);
  }

  if (sub_16454(*(_DWORD *)(a1 + 24)) && (*(_BYTE *)v2 & 8) != 0)
  {
    int v62 = sub_54F6C(*(void *)(v2 + 8));
    sub_6494(v62);
    *(_DWORD *)v2 &= ~8u;
    uint64_t v63 = sub_57538();
    uint64_t v64 = _SC_syslog_os_log_mapping(5LL);
    if (__SC_log_enabled(5LL, v63, v64))
    {
      uint64_t v65 = _os_log_pack_size(22LL);
      int v66 = (char *)&v79 - ((__chkstk_darwin(v65) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v67 = __error();
      uint64_t v68 = _os_log_pack_fill( v66,  v65,  *v67,  &dword_0,  "%s %s: reported address acquisition success symptom",  v79,  v80);
      uint64_t v69 = sub_14420(*(_DWORD *)(a1 + 24));
      uint64_t v70 = nullsub_1(*(void *)(v2 + 8));
      *(_DWORD *)uint64_t v68 = 136315394;
      *(void *)(v68 + 4) = v69;
      *(_WORD *)(v68 + 12) = 2080;
      *(void *)(v68 + 14) = v70;
      __SC_log_send(5LL, v63, v64, v66);
    }
  }

  uint64_t v71 = sub_57538();
  uint64_t v72 = _SC_syslog_os_log_mapping(5LL);
  if (__SC_log_enabled(5LL, v71, v72))
  {
    uint64_t v73 = _os_log_pack_size(32LL);
    uint64_t v74 = (char *)&v79 - ((__chkstk_darwin(v73) + 15) & 0xFFFFFFFFFFFFFFF0LL);
    int v75 = __error();
    uint64_t v76 = _os_log_pack_fill(v74, v73, *v75, &dword_0, "%s %s: publish success { %@ }");
    int v77 = sub_14420(*(_DWORD *)(a1 + 24));
    uint64_t v78 = nullsub_1(*(void *)(v2 + 8));
    *(_DWORD *)uint64_t v76 = 136315650;
    *(void *)(v76 + 4) = v77;
    *(_WORD *)(v76 + 12) = 2080;
    *(void *)(v76 + 14) = v78;
    *(_WORD *)(v76 + 22) = 2112;
    *(void *)(v76 + 24) = v60;
    __SC_log_send(5LL, v71, v72, v74);
  }

  sub_4FA18((const void **)&v89);
  if (!*v10) {
    sub_16474(a1);
  }
}

  sub_4FA18((const void **)v47);
LABEL_49:
  if (v9)
  {
    CFStringRef v24 = sub_535CC((uint64_t)v9, v44);
    if (v24)
    {
      CFStringRef v25 = v24;
      CFDictionarySetValue(Mutable, kSCPropNetDNSSearchDomains, v24);
      CFRelease(v25);
    }

BOOL sub_160CC(uint64_t a1)
{
  return *(_DWORD *)(a1 + 40) && *(_DWORD *)(a1 + 28) == 0;
}

CFTypeRef *sub_160EC(uint64_t a1, const void *a2, int a3)
{
  if (a3) {
    uint64_t v4 = a1 + 24;
  }
  else {
    uint64_t v4 = a1 + 56;
  }
  uint64_t v5 = 0LL;
  while (1)
  {
    uint64_t v6 = (CFTypeRef *)sub_50C98(v4, v5);
    if (CFEqual(a2, *v6)) {
      break;
    }
    uint64_t v5 = (v5 + 1);
  }

  return v6;
}

uint64_t sub_16170(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, int *a5)
{
  int v5 = *a5;
  if (*a5 < 8)
  {
    *(void *)(result + 8LL * v5) = a3;
    *(void *)(a2 + 8LL * v5) = a4;
    *a5 = v5 + 1;
  }

  else
  {
    uint64_t v6 = sub_57538();
    uint64_t v7 = _SC_syslog_os_log_mapping(5LL);
    uint64_t result = __SC_log_enabled(5LL, v6, v7);
    if ((_DWORD)result)
    {
      uint64_t v8 = _os_log_pack_size(14LL);
      uint64_t v9 = (char *)v12 - ((__chkstk_darwin(v8) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v10 = __error();
      uint64_t v11 = _os_log_pack_fill( v9,  v8,  *v10,  &dword_0,  "IPConfiguration: set_entity_value %d >= %d",  v12[0],  v12[2]);
      *(_DWORD *)uint64_t v11 = 67109376;
      *(_DWORD *)(v11 + 4) = v5;
      *(_WORD *)(v11 + 8) = 1024;
      *(_DWORD *)(v11 + 10) = 8;
      return __SC_log_send(5LL, v6, v7, v9);
    }
  }

  return result;
}

__CFDictionary *sub_162A8(uint64_t a1, __CFString *a2, CFDictionaryRef *a3)
{
  uint64_t v5 = *(void *)(*(void *)(a1 + 16) + 8LL);
  uint64_t v6 = sub_160EC(*(void *)(a1 + 16), *(const void **)a1, 0);
  memset(v15, 0, sizeof(v15));
  if (v6 && *((_DWORD *)v6 + 10) && !*((_DWORD *)v6 + 7)) {
    ((void (*)(CFTypeRef *, uint64_t, _OWORD *, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))sub_1B834)( v6,  14LL,  v15,  v7,  v8,  v9,  v10,  v11);
  }
  uint64_t v12 = nullsub_1(v5);
  uint64_t v13 = sub_37D8C(v12, (uint64_t)a2, (uint64_t)v15);
  *a3 = sub_38654(a2, (uint64_t)v15);
  return v13;
}

__CFString *sub_16350(CFNullRef *a1, void *a2, uint64_t a3)
{
  CFMutableDictionaryRef Mutable = CFStringCreateMutable(0LL, 0LL);
  if (a3 >= 1)
  {
    uint64_t v7 = 0LL;
    do
    {
      if (*a2)
      {
        CFNullRef v8 = *a1;
        if (*a1 == kCFNull) {
          CFNullRef v8 = (CFNullRef)@"RankLast";
        }
        uint64_t v9 = v7 + 1;
        if (v7) {
          uint64_t v10 = ", ";
        }
        else {
          uint64_t v10 = "";
        }
        CFStringAppendFormat(Mutable, 0LL, @"%s%@", v10, v8);
        uint64_t v7 = v9;
      }

      ++a2;
      ++a1;
      --a3;
    }

    while (a3);
  }

  return Mutable;
}

void sub_16430(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 16);
  byte_6C1A4 = 1;
  *(_DWORD *)(v1 + 144) = 1;
  dispatch_source_merge_data((dispatch_source_t)qword_6C1B0, 1uLL);
}

BOOL sub_16454(int a1)
{
  return (a1 - 257) < 4 || (a1 - 513) < 3;
}

uint64_t sub_16474(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 16);
  if ((*(_DWORD *)v1 & 0x80) == 0)
  {
    uint64_t v2 = result;
    uint64_t v3 = *(void *)(v1 + 8);
    *(_DWORD *)v1 |= 0x80u;
    uint64_t result = sub_50C94(v1 + 24);
    uint64_t v4 = *(void *)(v1 + 88);
    if (v4)
    {
      uint64_t v5 = v4 + 88;
    }

    else
    {
      uint64_t v5 = 0LL;
    }

    uint64_t result = sub_54A8C(v3);
    if ((int)result >= 1)
    {
      int v7 = result;
      uint64_t v8 = 0LL;
      int v9 = 0;
      *(void *)&__int128 v6 = 136315138LL;
      __int128 v19 = v6;
      do
      {
        uint64_t result = sub_54A94(v3, v8);
        if (*(_DWORD *)result != *(_DWORD *)(v2 + 100))
        {
          uint64_t v10 = (int *)result;
          if (!v5 || *(_DWORD *)result != *(_DWORD *)(v5 + 12))
          {
            if (!v9)
            {
              uint64_t v11 = sub_57538();
              uint64_t v12 = _SC_syslog_os_log_mapping(5LL);
              if (__SC_log_enabled(5LL, v11, v12))
              {
                uint64_t v13 = _os_log_pack_size(12LL);
                uint64_t v20 = &v19;
                uint64_t v14 = (char *)&v19 - ((__chkstk_darwin(v13) + 15) & 0xFFFFFFFFFFFFFFF0LL);
                uint64_t v15 = __error();
                uint64_t v16 = _os_log_pack_fill( v14,  v13,  *v15,  &dword_0,  "%s: removing stale IP address(es)",  (const char *)v19);
                uint64_t v17 = nullsub_1(v3);
                *(_DWORD *)uint64_t v16 = v19;
                *(void *)(v16 + 4) = v17;
                __SC_log_send(5LL, v11, v12, v14);
              }
            }

            uint64_t v18 = (const char *)nullsub_1(v3);
            uint64_t result = sub_18C88(v18, *v10);
            int v9 = 1;
          }
        }

        uint64_t v8 = (v8 + 1);
      }

      while (v7 != (_DWORD)v8);
    }
  }

  return result;
}

uint64_t sub_1665C(uint64_t a1, uint64_t a2)
{
  double current_time = timer_get_current_time();
  int v5 = *(_DWORD *)(a1 + 160);
  *(double *)(a1 + 152) = current_time;
  *(_DWORD *)(a1 + 160) = v5 + 1;
  if (v5 >= dword_6C088) {
    return 0LL;
  }
  uint64_t v6 = *(void *)(*(void *)(a1 + 16) + 8LL);
  int v7 = (uint64_t *)sub_33B4(v6);
  uint64_t v28 = v7;
  if (!v7)
  {
    uint64_t v20 = sub_57538();
    uint64_t v21 = _SC_syslog_os_log_mapping(5LL);
    if (__SC_log_enabled(5LL, v20, v21))
    {
      uint64_t v22 = _os_log_pack_size(2LL);
      uint64_t v23 = (char *)&v26 - ((__chkstk_darwin(v22) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      CFStringRef v24 = __error();
      *(_WORD *)_os_log_pack_fill( v23,  v22,  *v24,  &dword_0,  "IPConfiguration: ServiceDefendIPv4Address arp_client_init failed") = 0;
      __SC_log_send(5LL, v20, v21, v23);
      return 0LL;
    }

    return 0LL;
  }

  uint64_t v8 = (uint64_t)v7;
  sub_1695C(v6, a2);
  uint64_t v9 = sub_4E34(v8, *(_DWORD *)(a1 + 100));
  sub_3524(&v28);
  uint64_t v10 = sub_57538();
  uint64_t v11 = _SC_syslog_os_log_mapping(5LL);
  if (__SC_log_enabled(5LL, v10, v11))
  {
    uint64_t v12 = _os_log_pack_size(104LL);
    int v27 = &v26;
    uint64_t v13 = (char *)&v26 - ((__chkstk_darwin(v12) + 15) & 0xFFFFFFFFFFFFFFF0LL);
    uint64_t v14 = __error();
    uint64_t v15 = _os_log_pack_fill( v13,  v12,  *v14,  &dword_0,  "%s %s: defending IP %d.%d.%d.%d against %s%02x:%02x:%02x:%02x:%02x:%02x %d (of %d)",  v26,  (const char *)v27,  (_DWORD)v28,  v29,  v30,  v31,  v32,  v33,  v34,  v35,  v36,  v37,  v38,  v39,  vars0);
    uint64_t v16 = sub_14420(*(_DWORD *)(a1 + 24));
    uint64_t v17 = nullsub_1(v6);
    if (*(_DWORD *)(a2 + 20)) {
      uint64_t v18 = "BonjourSleepProxy ";
    }
    else {
      uint64_t v18 = "";
    }
    __int128 v19 = *(unsigned __int8 **)(a2 + 8);
    sub_16B08( v15,  (uint64_t)v16,  v17,  *(unsigned __int8 *)(a1 + 100),  *(unsigned __int8 *)(a1 + 101),  *(unsigned __int8 *)(a1 + 102),  *(unsigned __int8 *)(a1 + 103),  (uint64_t)v18,  *v19,  v19[1],  v19[2],  v19[3],  v19[4],  v19[5],  *(_DWORD *)(a1 + 160),  dword_6C088);
    __SC_log_send(5LL, v10, v11, v13);
  }

  return v9;
}

uint64_t sub_1695C(uint64_t result, uint64_t a2)
{
  if (*(void *)(a2 + 32))
  {
    uint64_t v3 = result;
    uint64_t v4 = (const char *)nullsub_1(result);
    int v5 = sub_54E28(v3);
    uint64_t v6 = *(void *)(a2 + 8);
    BytePtr = (UInt8 *)CFDataGetBytePtr(*(CFDataRef *)(a2 + 32));
    int Length = CFDataGetLength(*(CFDataRef *)(a2 + 32));
    int v9 = sub_56E04(-1, v18, v4, v5, v6, *(_DWORD *)(a2 + 24), *(_DWORD *)a2, 0x14E9u, 0x14E9u, BytePtr, Length);
    uint64_t v10 = sub_57538();
    uint64_t v11 = _SC_syslog_os_log_mapping(6LL);
    uint64_t result = __SC_log_enabled(6LL, v10, v11);
    if ((_DWORD)result)
    {
      uint64_t v12 = _os_log_pack_size(18LL);
      uint64_t v13 = (char *)&v18[-2] - ((__chkstk_darwin(v12) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v14 = __error();
      uint64_t v15 = _os_log_pack_fill(v13, v12, *v14, &dword_0, "%s: OPT record sent (status %d)", v17, v18[0]);
      uint64_t v16 = nullsub_1(v3);
      *(_DWORD *)uint64_t v15 = 136315394;
      *(void *)(v15 + 4) = v16;
      *(_WORD *)(v15 + 12) = 1024;
      *(_DWORD *)(v15 + 14) = v9;
      return __SC_log_send(6LL, v10, v11, v13);
    }
  }

  return result;
}

double sub_16B08( uint64_t a1, uint64_t a2, uint64_t a3, int a4, int a5, int a6, int a7, uint64_t a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16)
{
  *(void *)&double result = 136318722LL;
  *(_DWORD *)a1 = 136318722;
  *(void *)(a1 + 4) = a2;
  *(_WORD *)(a1 + 12) = 2080;
  *(void *)(a1 + 14) = a3;
  *(_WORD *)(a1 + 22) = 1024;
  *(_DWORD *)(a1 + 24) = a4;
  *(_WORD *)(a1 + 28) = 1024;
  *(_DWORD *)(a1 + 30) = a5;
  *(_WORD *)(a1 + 34) = 1024;
  *(_DWORD *)(a1 + 36) = a6;
  *(_WORD *)(a1 + 40) = 1024;
  *(_DWORD *)(a1 + 42) = a7;
  *(_WORD *)(a1 + 46) = 2080;
  *(void *)(a1 + 48) = a8;
  *(_WORD *)(a1 + 56) = 1024;
  *(_DWORD *)(a1 + 58) = a9;
  *(_WORD *)(a1 + 62) = 1024;
  *(_DWORD *)(a1 + 64) = a10;
  *(_WORD *)(a1 + 68) = 1024;
  *(_DWORD *)(a1 + 70) = a11;
  *(_WORD *)(a1 + 74) = 1024;
  *(_DWORD *)(a1 + 76) = a12;
  *(_WORD *)(a1 + 80) = 1024;
  *(_DWORD *)(a1 + 82) = a13;
  *(_WORD *)(a1 + 86) = 1024;
  *(_DWORD *)(a1 + 88) = a14;
  *(_WORD *)(a1 + 92) = 1024;
  *(_DWORD *)(a1 + 94) = a15;
  *(_WORD *)(a1 + 98) = 1024;
  *(_DWORD *)(a1 + 100) = a16;
  return result;
}

void sub_16BA4(uint64_t a1, _DWORD *a2, int a3, void *a4, uint64_t a5, uint64_t a6, const void *a7)
{
  int v66 = 0LL;
  CFMutableDictionaryRef v67 = 0LL;
  uint64_t v64 = 0LL;
  uint64_t v65 = 0LL;
  uint64_t v7 = *(void *)(a1 + 16);
  uint64_t v8 = *(void *)(v7 + 8);
  CFDictionaryRef v60 = 0LL;
  if (!*(void *)a1) {
    return;
  }
  *(_DWORD *)(a1 + 40) = 1;
  *(_DWORD *)(a1 + 28) = 0;
  if (!qword_6C178) {
    return;
  }
  uint64_t v13 = a2;
  uint64_t v58 = v8;
  CFDictionaryRef v57 = a7;
  if (a2) {
    BOOL v14 = a3 == 0;
  }
  else {
    BOOL v14 = 1;
  }
  int v15 = !v14;
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(0LL, 0LL, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  uint64_t v17 = Mutable;
  CFMutableDictionaryRef v61 = Mutable;
  if (a6)
  {
    int v18 = v15;
    if (*(_DWORD *)(a6 + 72))
    {
      uint64_t v19 = *(unsigned __int8 *)(a6 + 92);
      if (*(_BYTE *)(a6 + 92))
      {
        uint64_t v20 = *(unsigned int *)(a6 + 96);
        if (*(_DWORD *)(a6 + 76) || *(_DWORD *)(a6 + 80) || *(_DWORD *)(a6 + 84) || *(_DWORD *)(a6 + 88))
        {
          uint64_t v56 = *(unsigned int *)(a6 + 100);
          uint64_t v21 = v20;
          sub_50188(Mutable, @"DelegatedPrefix", (void *)(a6 + 76));
          sub_502C4(v17, @"DelegatedPrefixLength", v19);
          sub_502C4(v17, @"DelegatedPrefixValidLifetime", v21);
          sub_502C4(v17, @"DelegatedPrefixPreferredLifetime", v56);
        }
      }
    }

    int v15 = v18;
    if ((v18 & 1) != 0)
    {
      uint64_t v23 = *(const char **)(a6 + 56);
      uint64_t v22 = *(const void **)(a6 + 64);
      if (v22)
      {
        CFDictionarySetValue(v17, @"NAT64Prefix", v22);
      }

      else if (!v23)
      {
        if (*(_DWORD *)(a6 + 48))
        {
          LODWORD(v56) = *(_DWORD *)(a6 + 48);
          CFDictionarySetValue(v17, kSCPropNetIPv6PerformPLATDiscovery, kCFBooleanTrue);
        }

        else
        {
          LODWORD(v56) = 0;
        }

        uint64_t v23 = 0LL;
        goto LABEL_25;
      }

      LODWORD(v56) = 0;
LABEL_25:
      HIDWORD(v54) = v15;
      unsigned int v55 = v23;
      CFStringRef v25 = CFArrayCreateMutable(0LL, 0LL, &kCFTypeArrayCallBacks);
      uint64_t v26 = CFArrayCreateMutable(0LL, 0LL, &kCFTypeArrayCallBacks);
      if (a3 >= 1)
      {
        uint64_t v27 = a3;
        do
        {
          CFStringRef v28 = sub_50120(v13);
          CFArrayAppendValue(v25, v28);
          CFRelease(v28);
          LODWORD(valuePtr[0]) = v13[4];
          CFNumberRef v29 = CFNumberCreate(0LL, kCFNumberIntType, valuePtr);
          CFArrayAppendValue(v26, v29);
          CFRelease(v29);
          v13 += 8;
          --v27;
        }

        while (v27);
      }

      CFDictionarySetValue(v17, kSCPropNetIPv6Addresses, v25);
      CFRelease(v25);
      CFDictionarySetValue(v17, kSCPropNetIPv6PrefixLength, v26);
      CFRelease(v26);
      if (a4) {
        sub_50188(v17, kSCPropNetIPv6Router, a4);
      }
      CFStringRef v24 = sub_173A4(a1, a6, (CFDictionaryRef *)&v64);
      int v66 = v24;
      uint64_t v23 = v55;
      int v15 = HIDWORD(v54);
      goto LABEL_31;
    }

    CFStringRef v24 = 0LL;
    LODWORD(v56) = 0;
    uint64_t v23 = 0LL;
  }

  else
  {
    LODWORD(v56) = 0;
    uint64_t v23 = 0LL;
    CFStringRef v24 = 0LL;
    if ((v15 & 1) != 0) {
      goto LABEL_25;
    }
  }

LABEL_31:
  CFDictionarySetValue(v17, kSCPropInterfaceName, *(const void **)(v7 + 16));
  if ((sub_54A84(v58) & 8) == 0)
  {
    CFDictionarySetValue(v17, kSCPropConfirmedInterfaceName, *(const void **)(v7 + 16));
    if (v57) {
      CFDictionarySetValue(v17, @"NetworkSignature", v57);
    }
  }

  if (a6)
  {
    CFMutableDictionaryRef v67 = sub_38498(a6);
    uint64_t v65 = PvDEntityCreateWithInfo(a6);
  }

  int v62 = 0;
  sub_16170((uint64_t)valuePtr, (uint64_t)v68, (uint64_t)kSCEntNetIPv6, (uint64_t)v17, &v62);
  if (v23)
  {
    sub_16170((uint64_t)valuePtr, (uint64_t)v68, (uint64_t)kSCEntNetIPv4, (uint64_t)v23, &v62);
    CFStringRef v24 = v66;
  }

  sub_16170((uint64_t)valuePtr, (uint64_t)v68, (uint64_t)kSCEntNetDNS, (uint64_t)v24, &v62);
  sub_16170((uint64_t)valuePtr, (uint64_t)v68, (uint64_t)@"DHCPv6", (uint64_t)v67, &v62);
  sub_16170((uint64_t)valuePtr, (uint64_t)v68, kSCEntNetCaptivePortal, v64, &v62);
  sub_16170((uint64_t)valuePtr, (uint64_t)v68, kSCEntNetPvD, (uint64_t)v65, &v62);
  if (v15)
  {
    BOOL v30 = sub_17444(a1);
    if (!v23 && !v30)
    {
      keys = (void *)kSCPropNetServicePrimaryRank;
      values = (void *)kSCValNetServicePrimaryRankLast;
      CFDictionaryRef v60 = CFDictionaryCreate( 0LL,  (const void **)&keys,  (const void **)&values,  1LL,  &kCFTypeDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
    }
  }

  sub_16170((uint64_t)valuePtr, (uint64_t)v68, (uint64_t)kCFNull, (uint64_t)v60, &v62);
  int v31 = v62;
  int v32 = sub_16350(valuePtr, v68, v62);
  keys = v32;
  sub_37410( (const __SCDynamicStore *)qword_6C178,  *(CFStringRef *)a1,  (const void **)valuePtr,  v68,  v31,  *(_DWORD *)(a1 + 36));
  dispatch_source_merge_data((dispatch_source_t)qword_6C1B0, 1uLL);
  sub_4FA18((const void **)&v61);
  sub_4FA18((const void **)&v66);
  sub_4FA18((const void **)&v67);
  sub_4FA18((const void **)&v64);
  sub_4FA18((const void **)&v60);
  sub_4FA18((const void **)&v65);
  if (dword_6C0C0)
  {
    byte_6C19C = 1;
    dispatch_source_merge_data((dispatch_source_t)qword_6C1B0, 1uLL);
  }

  if (sub_16454(*(_DWORD *)(a1 + 24)) && (*(_BYTE *)v7 & 8) != 0)
  {
    int v33 = sub_54F6C(*(void *)(v7 + 8));
    sub_6494(v33);
    *(_DWORD *)v7 &= ~8u;
    uint64_t v34 = sub_57538();
    uint64_t v35 = _SC_syslog_os_log_mapping(5LL);
    if (__SC_log_enabled(5LL, v34, v35))
    {
      uint64_t v36 = _os_log_pack_size(22LL);
      uint64_t v37 = v23;
      uint64_t v38 = (char *)&v54 - ((__chkstk_darwin(v36) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v39 = __error();
      uint64_t v40 = _os_log_pack_fill( v38,  v36,  *v39,  &dword_0,  "%s %s: reported address acquisition success symptom",  v54,  v55);
      uint64_t v41 = sub_14420(*(_DWORD *)(a1 + 24));
      uint64_t v42 = nullsub_1(*(void *)(v7 + 8));
      *(_DWORD *)uint64_t v40 = 136315394;
      *(void *)(v40 + 4) = v41;
      *(_WORD *)(v40 + 12) = 2080;
      *(void *)(v40 + 14) = v42;
      CFStringRef v43 = v38;
      uint64_t v23 = v37;
      __SC_log_send(5LL, v34, v35, v43);
    }
  }

  uint64_t v44 = sub_57538();
  uint64_t v45 = _SC_syslog_os_log_mapping(5LL);
  if (__SC_log_enabled(5LL, v44, v45))
  {
    CFStringRef v46 = " [PLATDiscovery]";
    if (!(_DWORD)v56) {
      CFStringRef v46 = "";
    }
    if (v23) {
      uint64_t v47 = " [464XLAT]";
    }
    else {
      uint64_t v47 = v46;
    }
    uint64_t v48 = _os_log_pack_size(42LL);
    CFDictionaryRef v49 = (char *)&v54 - ((__chkstk_darwin(v48) + 15) & 0xFFFFFFFFFFFFFFF0LL);
    CFDictionaryRef v50 = __error();
    uint64_t v51 = _os_log_pack_fill(v49, v48, *v50, &dword_0, "%s %s: publish success { %@ }%s");
    uint64_t v52 = sub_14420(*(_DWORD *)(a1 + 24));
    uint64_t v53 = nullsub_1(*(void *)(v7 + 8));
    *(_DWORD *)uint64_t v51 = 136315906;
    *(void *)(v51 + 4) = v52;
    *(_WORD *)(v51 + 12) = 2080;
    *(void *)(v51 + 14) = v53;
    *(_WORD *)(v51 + 22) = 2112;
    *(void *)(v51 + 24) = v32;
    *(_WORD *)(v51 + 32) = 2080;
    *(void *)(v51 + 34) = v47;
    __SC_log_send(5LL, v44, v45, v49);
  }

  sub_4FA18((const void **)&keys);
}

  uint64_t v19 = v42;
  if (v42)
  {
    uint64_t v20 = CFArrayGetCount(v42);
    if (v20 >= 1)
    {
      uint64_t v21 = v20;
      uint64_t v22 = 0LL;
      uint64_t v23 = (const __CFString *)kSCEntNetRefreshConfiguration;
      CFStringRef v24 = kSCEntNetIPv6;
      uint64_t v41 = (CFStringRef)kSCEntNetNAT64;
      uint64_t v40 = (CFStringRef)kSCEntNetInterfaceActiveDuringSleepRequested;
      uint64_t v39 = (CFStringRef)kSCEntNetIPv6RouterExpired;
      uint64_t v38 = (const __SCDynamicStore *)kSCEntNetIPv4ARPCollision;
      do
      {
        CFStringRef v25 = (const __CFString *)CFArrayGetValueAtIndex(v19, v22);
        if (CFStringHasSuffix(v25, kSCEntNetLink))
        {
          sub_226B0((const __SCDynamicStore *)a1, v25);
        }

        else if (CFStringHasSuffix(v25, kSCEntNetAirPort))
        {
          sub_22F8C(v25);
        }

        else if (CFStringHasSuffix(v25, v23))
        {
          if (CFStringHasPrefix(v25, (CFStringRef)qword_6C1D0))
          {
            uint64_t v26 = (__CFArray *)sub_5039C(v25, @"/", 3LL);
            CFStringRef v46 = v26;
            if (v26)
            {
              uint64_t v27 = sub_25BD8(v26);
              if (v27)
              {
                CFStringRef v28 = v27;
                if ((*(_BYTE *)v27 & 0x10) == 0)
                {
                  uint64_t v36 = v23;
                  uint64_t v37 = v24;
                  *(_DWORD *)uint64_t v44 = 0;
                  *(void *)&v44[4] = sub_54F74(*(void *)(v27 + 8));
                  uint64_t v45 = v29;
                  if ((int)sub_50C94(v28 + 24) >= 1)
                  {
                    BOOL v30 = 0LL;
                    do
                    {
                      int v31 = sub_50C98(v28 + 24, v30);
                      if ((*(_BYTE *)(v31 + 25) & 1) != 0) {
                        *(_DWORD *)(v31 + 116) &= ~4u;
                      }
                      sub_1B834(v31, 8LL, (uint64_t)v44);
                      BOOL v30 = (v30 + 1);
                    }

                    while ((int)v30 < (int)sub_50C94(v28 + 24));
                  }

                  sub_21780(v28 + 56, 8LL, (uint64_t)v44);
                  uint64_t v23 = v36;
                  CFStringRef v24 = v37;
                }
              }

              sub_4FA18((const void **)&v46);
            }
          }
        }

        else if (CFStringHasSuffix(v25, v24))
        {
          sub_231FC(v25);
        }

        else if (CFStringHasSuffix(v25, v41))
        {
          sub_233D0((const __SCDynamicStore *)a1, v25);
        }

        else if (CFStringHasSuffix(v25, v40))
        {
          uint64_t v37 = v24;
          if (CFStringHasPrefix(v25, (CFStringRef)qword_6C1D0))
          {
            int v32 = sub_5039C(v25, @"/", 3LL);
            *(void *)uint64_t v44 = v32;
            if (v32)
            {
              int v33 = sub_25BD8(v32);
              sub_4FA18((const void **)v44);
              uint64_t v36 = (const __CFString *)v33;
              if (v33)
              {
                uint64_t v34 = SCDynamicStoreCopyValue((SCDynamicStoreRef)a1, v25);
                if (v34)
                {
                  CFRelease(v34);
                  uint64_t v35 = 1;
                }

                else
                {
                  uint64_t v35 = 0;
                }

                sub_26644((uint64_t)v36, v35);
              }
            }
          }

          CFStringRef v24 = v37;
        }

        else if (CFStringHasSuffix(v25, v39))
        {
          sub_23678(v25);
        }

        else
        {
          v47.length = CFStringGetLength(v25);
          v47.location = 0LL;
          if (CFStringFindWithOptions(v25, (CFStringRef)v38, v47, 0LL, 0LL)) {
            sub_2380C((const __SCDynamicStore *)a1, v25);
          }
        }

        ++v22;
      }

      while (v22 != v21);
    }
  }

  if (v18)
  {
    byte_6C180 = 1;
    dispatch_source_merge_data((dispatch_source_t)qword_6C1B0, 1uLL);
    if (dword_6C0C0)
    {
      byte_6C19C = 1;
      dispatch_source_merge_data((dispatch_source_t)qword_6C1B0, 1uLL);
    }
  }

__CFDictionary *sub_173A4(uint64_t a1, uint64_t a2, CFDictionaryRef *a3)
{
  uint64_t v5 = *(void *)(*(void *)(a1 + 16) + 8LL);
  uint64_t v6 = sub_160EC(*(void *)(a1 + 16), *(const void **)a1, 1);
  memset(&v15, 0, sizeof(v15));
  uint64_t v16 = 0LL;
  if (v6 && *((_DWORD *)v6 + 10) && !*((_DWORD *)v6 + 7)) {
    ((void (*)(CFTypeRef *, uint64_t, __CFString *, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))sub_1B834)( v6,  13LL,  &v15,  v7,  v8,  v9,  v10,  v11);
  }
  uint64_t v12 = nullsub_1(v5);
  uint64_t v13 = sub_37D8C(v12, (uint64_t)&v15, a2);
  *a3 = sub_38654(&v15, a2);
  return v13;
}

BOOL sub_17444(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 16) + 24LL;
  int v2 = sub_50C94(v1);
  if (v2 < 1)
  {
    return 0;
  }

  else
  {
    int v3 = v2;
    uint64_t v4 = 0LL;
    BOOL v5 = 1;
    do
    {
      uint64_t v6 = (_DWORD *)sub_50C98(v1, v4);
      if (v6[6] != 261 && v6[10] && !v6[7]) {
        break;
      }
      uint64_t v4 = (v4 + 1);
      BOOL v5 = (int)v4 < v3;
    }

    while (v3 != (_DWORD)v4);
  }

  return v5;
}

void sub_174D0(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 16);
  if ((*(_BYTE *)(v1 + 2) & 0x40) != 0)
  {
    uint64_t v12 = 0LL;
    CFStringRef v13 = kSCEntNetIPv4;
    uint64_t v3 = sub_57538();
    uint64_t v4 = _SC_syslog_os_log_mapping(5LL);
    if (__SC_log_enabled(5LL, v3, v4))
    {
      uint64_t v5 = _os_log_pack_size(22LL);
      uint64_t v6 = (char *)&v11 - ((__chkstk_darwin(v5) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v7 = __error();
      uint64_t v8 = _os_log_pack_fill( v6,  v5,  *v7,  &dword_0,  "%s %s: unpublish IPv4 (CLAT46)",  v11,  (const char *)v12);
      uint64_t v9 = sub_14420(*(_DWORD *)(a1 + 24));
      uint64_t v10 = nullsub_1(*(void *)(v1 + 8));
      *(_DWORD *)uint64_t v8 = 136315394;
      *(void *)(v8 + 4) = v9;
      *(_WORD *)(v8 + 12) = 2080;
      *(void *)(v8 + 14) = v10;
      __SC_log_send(5LL, v3, v4, v6);
    }

    sub_37410( (const __SCDynamicStore *)qword_6C178,  *(CFStringRef *)a1,  (const void **)&v13,  &v12,  1,  *(_DWORD *)(a1 + 36));
    dispatch_source_merge_data((dispatch_source_t)qword_6C1B0, 1uLL);
  }

uint64_t sub_17650(uint64_t a1)
{
  return (**(_DWORD **)(a1 + 16) >> 22) & 1;
}

uint64_t sub_17660(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 16);
  if ((int)sub_50C94(v1 + 56) < 1)
  {
    uint64_t v5 = 0LL;
    BOOL v4 = 1;
  }

  else
  {
    uint64_t v2 = 0LL;
    while (1)
    {
      unsigned int v3 = *(_DWORD *)(sub_50C98(v1 + 56, v2) + 24) & 0xFFFFFFFE;
      BOOL v4 = v3 != 514;
      if (v3 == 514) {
        break;
      }
      uint64_t v2 = (v2 + 1);
      if ((int)v2 >= (int)sub_50C94(v1 + 56))
      {
        uint64_t v5 = 0LL;
        goto LABEL_8;
      }
    }

    uint64_t v5 = 1LL;
  }

LABEL_8:
  uint64_t v6 = sub_57538();
  uint64_t v7 = _SC_syslog_os_log_mapping(6LL);
  if (__SC_log_enabled(6LL, v6, v7))
  {
    uint64_t v8 = _os_log_pack_size(22LL);
    uint64_t v9 = (char *)v15 - ((__chkstk_darwin(v8) + 15) & 0xFFFFFFFFFFFFFFF0LL);
    uint64_t v10 = __error();
    uint64_t v11 = _os_log_pack_fill(v9, v8, *v10, &dword_0, "%s: IPv6OnlyPreferred is %spossible", v15[0], v15[1]);
    uint64_t v12 = nullsub_1(*(void *)(v1 + 8));
    CFStringRef v13 = "";
    if (v4) {
      CFStringRef v13 = "not ";
    }
    *(_DWORD *)uint64_t v11 = 136315394;
    *(void *)(v11 + 4) = v12;
    *(_WORD *)(v11 + 12) = 2080;
    *(void *)(v11 + 14) = v13;
    __SC_log_send(6LL, v6, v7, v9);
  }

  return v5;
}

    uint64_t v10 = 259;
    goto LABEL_9;
  }

  if (CFEqual(a1, kSCValNetIPv4ConfigMethodDHCP)) {
    goto LABEL_8;
  }
  if (CFEqual(a1, kSCValNetIPv4ConfigMethodManual))
  {
    uint64_t v10 = 257;
    goto LABEL_9;
  }

  if (CFEqual(a1, kSCValNetIPv4ConfigMethodINFORM))
  {
    uint64_t v10 = 260;
    goto LABEL_9;
  }

  if (CFEqual(a1, kSCValNetIPv4ConfigMethodLinkLocal))
  {
    uint64_t v10 = 261;
    goto LABEL_9;
  }

  double result = CFEqual(a1, kSCValNetIPv4ConfigMethodFailover);
  if ((_DWORD)result)
  {
    uint64_t v10 = 262;
    goto LABEL_9;
  }

  return result;
}

  *(NDR_record_t *)(a2 + 24) = v4;
  return result;
}

  *(NDR_record_t *)(a2 + 24) = v4;
  return result;
}

  *(NDR_record_t *)(a2 + 24) = v4;
  return result;
}

  uint64_t v6 = -v4;
  uint64_t v7 = malloc(96LL * -v4);
  *a1 = v7;
  if (!v7) {
    goto LABEL_88;
  }
  uint64_t v8 = socket(2, 2, 0);
  unsigned int v3 = v76;
  if (v8 < 0) {
    goto LABEL_88;
  }
  uint64_t v10 = v8;
  *((_DWORD *)a1 + 2) = 0;
  *((_DWORD *)a1 + 3) = v6;
  uint64_t v11 = 96LL;
  if (!v3) {
    goto LABEL_93;
  }
  uint64_t v73 = kIOMainPortDefault;
  uint64_t v71 = kCFAllocatorDefault;
  *(void *)&uint64_t v9 = 136315906LL;
  uint64_t v74 = v9;
  int v75 = v8;
  do
  {
    ifa_addr = v3->ifa_addr;
    if (!ifa_addr) {
      goto LABEL_82;
    }
    ifa_name = v3->ifa_name;
    sa_family = ifa_addr->sa_family;
    if (sa_family == 2)
    {
      uint64_t v21 = 96LL * ((_DWORD)a1[1] & ~(*((int *)a1 + 2) >> 31));
      uint64_t v22 = -96LL;
      do
      {
        uint64_t v23 = v22 + 96;
        if (v21 == v22 + 96) {
          goto LABEL_30;
        }
        CFStringRef v24 = *a1;
        CFStringRef v25 = strcmp((const char *)*a1 + v22 + 96, ifa_name);
        uint64_t v22 = v23;
      }

      while (v25);
      if (v24)
      {
        uint64_t v26 = (uint64_t)v24 + v23;
LABEL_32:
        uint64_t v38 = *(_DWORD *)&ifa_addr->sa_data[2];
        ifa_netmask = v3->ifa_netmask;
        if (ifa_netmask) {
          uint64_t v40 = *(_DWORD *)&ifa_netmask->sa_data[2];
        }
        else {
          uint64_t v40 = 0;
        }
        if ((*(_WORD *)(v26 + 16) & 2) != 0 && (ifa_dstaddr = v3->ifa_dstaddr) != 0LL) {
          uint64_t v42 = *(_DWORD *)&ifa_dstaddr->sa_data[2];
        }
        else {
          uint64_t v42 = 0;
        }
        CFStringRef v43 = malloc(0x10uLL);
        if (v43)
        {
          char *v43 = v38;
          v43[1] = v40;
          v43[2] = v40 & v38;
          v43[3] = v42;
        }

        sub_53DA4(v26 + 24, v43);
        goto LABEL_82;
      }

uint64_t sub_17808(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 16);
  if ((*(_BYTE *)v2 & 8) != 0)
  {
    uint64_t v18 = sub_57538();
    uint64_t v19 = _SC_syslog_os_log_mapping(6LL);
    uint64_t result = __SC_log_enabled(6LL, v18, v19);
    if (!(_DWORD)result) {
      return result;
    }
    uint64_t v20 = _os_log_pack_size(22LL);
    uint64_t v21 = (char *)&v32 - ((__chkstk_darwin(v20) + 15) & 0xFFFFFFFFFFFFFFF0LL);
    uint64_t v22 = __error();
    uint64_t v23 = _os_log_pack_fill(v21, v20, *v22, &dword_0, "%s %s: symptom failure already reported", v32, v33);
    CFStringRef v24 = sub_14420(*(_DWORD *)(a1 + 24));
    uint64_t v25 = nullsub_1(*(void *)(v2 + 8));
    *(_DWORD *)uint64_t v23 = 136315394;
    *(void *)(v23 + 4) = v24;
    *(_WORD *)(v23 + 12) = 2080;
    *(void *)(v23 + 14) = v25;
    uint64_t v14 = 6LL;
    goto LABEL_8;
  }

  unsigned int v3 = sub_20458(v2 + 24);
  if (v3 || (unsigned int v3 = sub_20458(v2 + 56)) != 0LL)
  {
    uint64_t v4 = sub_57538();
    uint64_t v5 = _SC_syslog_os_log_mapping(6LL);
    uint64_t result = __SC_log_enabled(6LL, v4, v5);
    if (!(_DWORD)result) {
      return result;
    }
    uint64_t v7 = _os_log_pack_size(32LL);
    uint64_t v8 = (char *)&v32 - ((__chkstk_darwin(v7) + 15) & 0xFFFFFFFFFFFFFFF0LL);
    uint64_t v9 = __error();
    uint64_t v10 = _os_log_pack_fill( v8,  v7,  *v9,  &dword_0,  "%s %s: won't report symptom: %s is active",  v32,  v33,  v34);
    uint64_t v11 = sub_14420(*(_DWORD *)(a1 + 24));
    uint64_t v12 = nullsub_1(*(void *)(v2 + 8));
    CFStringRef v13 = sub_14420(v3[6]);
    *(_DWORD *)uint64_t v10 = 136315650;
    *(void *)(v10 + 4) = v11;
    *(_WORD *)(v10 + 12) = 2080;
    *(void *)(v10 + 14) = v12;
    *(_WORD *)(v10 + 22) = 2080;
    *(void *)(v10 + 24) = v13;
    uint64_t v14 = 6LL;
    uint64_t v15 = v4;
    uint64_t v16 = v5;
    uint64_t v17 = v8;
    return __SC_log_send(v14, v15, v16, v17);
  }

  int v26 = sub_54F6C(*(void *)(v2 + 8));
  uint64_t result = sub_6494(v26);
  if ((_DWORD)result)
  {
    *(_DWORD *)v2 |= 8u;
    uint64_t v18 = sub_57538();
    uint64_t v19 = _SC_syslog_os_log_mapping(5LL);
    uint64_t result = __SC_log_enabled(5LL, v18, v19);
    if ((_DWORD)result)
    {
      uint64_t v27 = _os_log_pack_size(22LL);
      uint64_t v21 = (char *)&v32 - ((__chkstk_darwin(v27) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      CFStringRef v28 = __error();
      uint64_t v29 = _os_log_pack_fill( v21,  v27,  *v28,  &dword_0,  "%s %s: reported address acquisition failure symptom",  v32,  v33);
      BOOL v30 = sub_14420(*(_DWORD *)(a1 + 24));
      uint64_t v31 = nullsub_1(*(void *)(v2 + 8));
      *(_DWORD *)uint64_t v29 = 136315394;
      *(void *)(v29 + 4) = v30;
      *(_WORD *)(v29 + 12) = 2080;
      *(void *)(v29 + 14) = v31;
      uint64_t v14 = 5LL;
LABEL_8:
      uint64_t v15 = v18;
      uint64_t v16 = v19;
      uint64_t v17 = v21;
      return __SC_log_send(v14, v15, v16, v17);
    }
  }

  return result;
}

uint64_t sub_17B20(uint64_t a1, unsigned int a2, int a3)
{
  if ((*(_BYTE *)(a1 + 25) & 1) == 0) {
    goto LABEL_2;
  }
  uint64_t v18 = *(const void **)(a1 + 56);
  if (v18) {
    uint64_t v19 = sub_160EC(*(void *)(a1 + 16), v18, 1);
  }
  else {
    uint64_t v19 = 0LL;
  }
  uint64_t v20 = *(const void **)(a1 + 48);
  if (v20)
  {
    uint64_t v6 = sub_160EC(*(void *)(a1 + 16), v20, 1);
    if (!v19) {
      goto LABEL_21;
    }
  }

  else
  {
    uint64_t v6 = 0LL;
    if (!v19)
    {
LABEL_21:
      if (v6 && !*((_DWORD *)v6 + 25))
      {
        int v7 = *((_DWORD *)v6 + 7);
        goto LABEL_3;
      }

LABEL_2:
      uint64_t v6 = (CFTypeRef *)a1;
      int v7 = 0;
LABEL_3:
      sub_17D2C((uint64_t)v6, v7);
      goto LABEL_4;
    }
  }

  if (!*((_DWORD *)v19 + 25)) {
    goto LABEL_21;
  }
  sub_154F8((uint64_t)v19, 0LL);
LABEL_4:
  *(_DWORD *)(a1 + 40) = 1;
  *(_DWORD *)(a1 + 28) = a2;
  uint64_t v8 = sub_57538();
  uint64_t v9 = _SC_syslog_os_log_mapping(5LL);
  uint64_t result = __SC_log_enabled(5LL, v8, v9);
  if ((_DWORD)result)
  {
    uint64_t v11 = _os_log_pack_size(32LL);
    uint64_t v12 = (char *)v21 - ((__chkstk_darwin(v11) + 15) & 0xFFFFFFFFFFFFFFF0LL);
    CFStringRef v13 = __error();
    uint64_t v14 = _os_log_pack_fill(v12, v11, *v13, &dword_0, "%s %s: status = '%s'", v21[0], v21[1], v21[2]);
    uint64_t v15 = sub_14420(*(_DWORD *)(a1 + 24));
    uint64_t v16 = nullsub_1(*(void *)(*(void *)(a1 + 16) + 8LL));
    if (a2 <= 0x15) {
      uint64_t v17 = off_64CE0[a2];
    }
    else {
      uint64_t v17 = "<unknown>";
    }
    *(_DWORD *)uint64_t v14 = 136315650;
    *(void *)(v14 + 4) = v15;
    *(_WORD *)(v14 + 12) = 2080;
    *(void *)(v14 + 14) = v16;
    *(_WORD *)(v14 + 22) = 2080;
    *(void *)(v14 + 24) = v17;
    uint64_t result = __SC_log_send(5LL, v8, v9, v12);
  }

  if (a3 == 1) {
    return sub_2037C();
  }
  return result;
}

  if (a4) {
    vm_deallocate(mach_task_self_, (vm_address_t)a4, a5);
  }
  *a7 = v13;
  return 0LL;
}

void sub_17D2C(uint64_t a1, int a2)
{
  uint64_t v7 = 0LL;
  *(_DWORD *)(a1 + 40) = 0;
  *(_DWORD *)(a1 + 28) = a2;
  if (qword_6C178)
  {
    int v3 = *(_DWORD *)(a1 + 24);
    int v6 = 0;
    if ((v3 & 0x100) != 0)
    {
      if ((*(_BYTE *)(*(void *)(a1 + 16) + 2LL) & 0x40) == 0) {
        sub_16170((uint64_t)v10, (uint64_t)v9, (uint64_t)kSCEntNetIPv4, 0LL, &v6);
      }
      uint64_t v8 = sub_162A8(a1, 0LL, (CFDictionaryRef *)&v7);
      sub_16170((uint64_t)v10, (uint64_t)v9, (uint64_t)kSCEntNetDNS, (uint64_t)v8, &v6);
      sub_16170((uint64_t)v10, (uint64_t)v9, kSCEntNetCaptivePortal, v7, &v6);
      sub_16170((uint64_t)v10, (uint64_t)v9, (uint64_t)kSCEntNetDHCP, 0LL, &v6);
      uint64_t v4 = *(void *)(a1 + 16);
      byte_6C1A4 = 1;
      *(_DWORD *)(v4 + 144) = 1;
      dispatch_source_merge_data((dispatch_source_t)qword_6C1B0, 1uLL);
      uint64_t v5 = *(_DWORD **)(a1 + 16);
      byte_6C1A0 = 1;
      *v5 |= 0x40u;
      dispatch_source_merge_data((dispatch_source_t)qword_6C1B0, 1uLL);
    }

    else
    {
      sub_16170((uint64_t)v10, (uint64_t)v9, (uint64_t)kSCEntNetIPv6, 0LL, &v6);
      if ((*(_BYTE *)(*(void *)(a1 + 16) + 2LL) & 0x40) != 0) {
        sub_16170((uint64_t)v10, (uint64_t)v9, (uint64_t)kSCEntNetIPv4, 0LL, &v6);
      }
      sub_16170((uint64_t)v10, (uint64_t)v9, (uint64_t)@"DHCPv6", 0LL, &v6);
      uint64_t v8 = sub_173A4(a1, 0LL, (CFDictionaryRef *)&v7);
      sub_16170((uint64_t)v10, (uint64_t)v9, (uint64_t)kSCEntNetDNS, (uint64_t)v8, &v6);
      sub_16170((uint64_t)v10, (uint64_t)v9, kSCEntNetCaptivePortal, v7, &v6);
      sub_16170((uint64_t)v10, (uint64_t)v9, (uint64_t)kCFNull, 0LL, &v6);
      sub_16170((uint64_t)v10, (uint64_t)v9, kSCEntNetPvD, 0LL, &v6);
    }

    sub_37410((const __SCDynamicStore *)qword_6C178, *(CFStringRef *)a1, v10, v9, v6, *(_DWORD *)(a1 + 36));
    dispatch_source_merge_data((dispatch_source_t)qword_6C1B0, 1uLL);
    sub_4FA18((const void **)&v8);
    sub_4FA18((const void **)&v7);
    if (dword_6C0C0)
    {
      byte_6C19C = 1;
      dispatch_source_merge_data((dispatch_source_t)qword_6C1B0, 1uLL);
    }
  }

uint64_t sub_17FEC(uint64_t a1, unsigned int a2)
{
  return sub_17B20(a1, a2, 1);
}

uint64_t sub_17FF4(uint64_t a1)
{
  uint64_t v1 = (const char *)nullsub_1(*(void *)(*(void *)(a1 + 16) + 8LL));
  return sub_323EC(v1, 1);
}

uint64_t sub_18014(uint64_t a1)
{
  int v2 = sub_54F6C(*(void *)(*(void *)(a1 + 16) + 8LL));
  sub_37000(v2, 0, 0);
  int v3 = (const char *)nullsub_1(*(void *)(*(void *)(a1 + 16) + 8LL));
  return sub_323EC(v3, 0);
}

CFTypeRef *sub_18058(uint64_t a1)
{
  else {
    return 0LL;
  }
}

BOOL sub_1807C(uint64_t a1)
{
  return ((**(_DWORD **)(a1 + 16) >> 18) & 1) == 0;
}

void sub_18090(uint64_t a1, int a2)
{
  uint64_t v3 = *(void *)(a1 + 16);
  uint64_t v4 = *(void *)(v3 + 88);
  if (!v4) {
    goto LABEL_5;
  }
  int v6 = *(const void **)(v4 + 48);
  if (!v6) {
    return;
  }
  uint64_t v7 = sub_160EC(v3, v6, 1);
  if (v7 && v7 == (CFTypeRef *)a1)
  {
    uint64_t v10 = 0LL;
    memset(v9, 0, sizeof(v9));
    LODWORD(v9[0]) = 261;
    DWORD2(v9[0]) = a2;
    sub_181A0(v4, (unsigned int *)v9, &v8);
  }

  else
  {
LABEL_5:
    byte_6C180 = 1;
    dispatch_source_merge_data((dispatch_source_t)qword_6C1B0, 1uLL);
  }

void sub_18184()
{
  byte_6C180 = 1;
  dispatch_source_merge_data((dispatch_source_t)qword_6C1B0, 1uLL);
}

uint64_t sub_181A0(uint64_t a1, unsigned int *a2, int *a3)
{
  if ((*((_BYTE *)a2 + 1) & 2) != 0)
  {
    uint64_t v6 = *(void *)(a1 + 16);
    if (sub_50C94(v6 + 56) == 1)
    {
      if (a2[8] != (HIWORD(*(_DWORD *)v6) & 1)
        || (*(void *)(a2 + 9) == *(void *)(v6 + 120)
          ? (BOOL v7 = *(void *)(a2 + 11) == *(void *)(v6 + 128))
          : (BOOL v7 = 0),
            !v7))
      {
        uint64_t v8 = sub_57538();
        uint64_t v9 = _SC_syslog_os_log_mapping(5LL);
        uint64_t result = __SC_log_enabled(5LL, v8, v9);
        if ((_DWORD)result)
        {
          uint64_t v11 = _os_log_pack_size(12LL);
          uint64_t v12 = (char *)&v18 - ((__chkstk_darwin(v11) + 15) & 0xFFFFFFFFFFFFFFF0LL);
          CFStringRef v13 = __error();
          uint64_t v14 = _os_log_pack_fill( v12,  v11,  *v13,  &dword_0,  "%s: IPv6 configuration changed, need stop",  v18);
          uint64_t v15 = nullsub_1(*(void *)(v6 + 8));
          *(_DWORD *)uint64_t v14 = 136315138;
          *(void *)(v14 + 4) = v15;
          __SC_log_send(5LL, v8, v9, v12);
          int v16 = 1;
          uint64_t result = 0LL;
        }

        else
        {
          int v16 = 1;
        }

        goto LABEL_12;
      }
    }
  }

  *a3 = 0;
  uint64_t v17 = (uint64_t (*)(uint64_t, uint64_t, unsigned int **))sub_204D4(*a2);
  if (v17)
  {
    uint64_t v19 = a2 + 2;
    int v20 = 0;
    uint64_t result = v17(a1, 7LL, &v19);
    int v16 = v20;
LABEL_12:
    *a3 = v16;
    return result;
  }

  return 7LL;
}

uint64_t sub_18360(uint64_t result, int a2)
{
  *(_DWORD *)(*(void *)(result + 16) + 112LL) = a2;
  return result;
}

uint64_t sub_1836C(uint64_t a1)
{
  return *(unsigned int *)(*(void *)(a1 + 16) + 112LL);
}

uint64_t sub_18378(uint64_t a1, unint64_t a2, unint64_t a3, unint64_t a4)
{
  unint64_t v4 = a4;
  unint64_t v5 = a3;
  unint64_t v80 = a2;
  uint64_t v6 = a1;
  int v81 = a4;
  int v82 = a3;
  uint64_t v79 = *(void *)(*(void *)(a1 + 16) + 8LL);
  int v77 = sub_31700();
  if ((_DWORD)v5)
  {
    uint64_t v75 = v5 >> 16;
    int v7 = v5;
    uint64_t v73 = v5 >> 8;
    uint64_t v74 = (const char **)(v5 >> 24);
  }

  else
  {
    unsigned int v8 = bswap32(v80);
    if ((v8 & 0x80000000) != 0)
    {
      if (v8 >> 30 == 2)
      {
        uint64_t v74 = 0LL;
        uint64_t v75 = 0LL;
        int v7 = 0xFFFF;
        int v82 = 0xFFFF;
        LOBYTE(v5) = -1;
        uint64_t v73 = 255LL;
      }

      else
      {
        int v7 = 0xFFFFFF;
        int v82 = 0xFFFFFF;
        LOBYTE(v5) = -1;
        uint64_t v73 = 255LL;
        uint64_t v74 = 0LL;
        uint64_t v75 = 255LL;
      }
    }

    else
    {
      uint64_t v74 = 0LL;
      uint64_t v75 = 0LL;
      uint64_t v73 = 0LL;
      LOBYTE(v5) = -1;
      int v82 = 255;
      int v7 = 255;
    }
  }

  unint64_t v78 = v80 >> 24;
  uint64_t v9 = v80 >> 16;
  unint64_t v10 = v80 >> 8;
  if ((_DWORD)v4)
  {
    uint64_t v71 = v4 >> 16;
    uint64_t v72 = v4 >> 8;
    int v11 = v80;
  }

  else
  {
    int v11 = v80;
    unsigned int v12 = ((_DWORD)v78 << 24) | (BYTE2(v80) << 16) | (BYTE1(v80) << 8) | ~v7;
    LODWORD(v4) = v12 | v80;
    int v81 = v4;
    uint64_t v71 = HIWORD(v12);
    uint64_t v72 = v12 >> 8;
  }

  int v76 = v78;
  int v13 = BYTE2(v80);
  int v14 = BYTE1(v80);
  uint64_t v15 = sub_57538();
  uint64_t v16 = _SC_syslog_os_log_mapping(5LL);
  uint64_t v70 = v15;
  HIDWORD(v69) = v16;
  if (__SC_log_enabled(5LL, v15, v16))
  {
    unsigned int v65 = BYTE3(v4);
    LODWORD(v69) = BYTE1(v80);
    uint64_t v17 = _os_log_pack_size(94LL);
    int v66 = &v62;
    uint64_t v18 = __chkstk_darwin(v17);
    int v68 = v7;
    uint64_t v19 = (char *)&v62 - ((v18 + 15) & 0xFFFFFFFFFFFFFFF0LL);
    int v20 = __error();
    uint64_t v63 = (const char *)_os_log_pack_fill( v19,  v17,  *v20,  &dword_0,  "%s %s: setting %d.%d.%d.%d netmask %d.%d.%d.%d broadcast %d.%d.%d.%d",  v62,  v63,  v64,  (_DWORD)v66,  v67,  (_DWORD)v69,  v70,  v71,  v72,  v73,  (_DWORD)v74,  v75,  v76,  v78);
    uint64_t v21 = sub_14420(*(_DWORD *)(v6 + 24));
    int v22 = v11;
    char v23 = v10;
    unint64_t v10 = v6;
    char v24 = v9;
    uint64_t v9 = (uint64_t)v21;
    uint64_t v25 = nullsub_1(v79);
    uint64_t v26 = v9;
    LOBYTE(v9) = v24;
    uint64_t v6 = v10;
    LOBYTE(v10) = v23;
    int v11 = v22;
    int v14 = (int)v69;
    sub_1896C( (uint64_t)v63,  v26,  v25,  v22,  (int)v69,  v13,  v76,  v5,  v73,  v75,  v74,  v4,  v72,  v71,  v65);
    uint64_t v27 = v19;
    int v7 = v68;
    __SC_log_send(5LL, v70, HIDWORD(v69), v27);
  }

  if (v77 < 0)
  {
    uint64_t v33 = *__error();
    uint64_t v34 = sub_57538();
    uint64_t v35 = _SC_syslog_os_log_mapping(3LL);
    if (__SC_log_enabled(3LL, v34, v35))
    {
      uint64_t v36 = _os_log_pack_size(28LL);
      uint64_t v37 = (char *)&v62 - ((__chkstk_darwin(v36) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v38 = __error();
      uint64_t v39 = _os_log_pack_fill( v37,  v36,  *v38,  &dword_0,  "service_set_address(%s): socket() failed, %s (%d)",  v62,  v63,  v64);
      uint64_t v40 = nullsub_1(v79);
      uint64_t v41 = __error();
      uint64_t v42 = strerror(*v41);
      int v43 = *__error();
      *(_DWORD *)uint64_t v39 = 136315650;
      *(void *)(v39 + 4) = v40;
      *(_WORD *)(v39 + 12) = 2080;
      *(void *)(v39 + 14) = v42;
      *(_WORD *)(v39 + 22) = 1024;
      *(_DWORD *)(v39 + 24) = v43;
      __SC_log_send(3LL, v34, v35, v37);
    }
  }

  else
  {
    int v28 = v11;
    int v29 = (v13 << 16) | ((_DWORD)v78 << 24) | (v10 << 8) | v11;
    int v30 = v7 & v29;
    uint64_t v31 = (void *)(v6 + 100);
    int v32 = (const char *)nullsub_1(v79);
    if ((sub_3273C(v77, v32, v29, &v82, &v81) & 0x80000000) != 0)
    {
      LODWORD(v75) = v28;
      uint64_t v33 = *__error();
      uint64_t v44 = sub_57538();
      uint64_t v45 = _SC_syslog_os_log_mapping(5LL);
      int v46 = v45;
      if (__SC_log_enabled(5LL, v44, v45))
      {
        uint64_t v47 = _os_log_pack_size(52LL);
        LODWORD(v69) = v14;
        uint64_t v48 = v47;
        uint64_t v74 = &v62;
        uint64_t v49 = __chkstk_darwin(v47);
        LODWORD(v73) = v13;
        CFDictionaryRef v50 = (char *)&v62 - ((v49 + 15) & 0xFFFFFFFFFFFFFFF0LL);
        uint64_t v51 = __error();
        uint64_t v52 = _os_log_pack_fill( v50,  v48,  *v51,  &dword_0,  "service_set_address(%s) %d.%d.%d.%d inet_aifaddr() failed, %s (%d)",  v62,  (_DWORD)v63,  v64,  (_DWORD)v66,  v67,  v69,  v70);
        uint64_t v53 = nullsub_1(v79);
        LODWORD(v72) = v46;
        char v54 = v10;
        unint64_t v10 = v6;
        char v55 = v9;
        uint64_t v9 = v53;
        uint64_t v56 = __error();
        CFDictionaryRef v57 = strerror(*v56);
        uint64_t v71 = v44;
        uint64_t v58 = v57;
        int v59 = *__error();
        *(_DWORD *)uint64_t v52 = 136316674;
        *(void *)(v52 + 4) = v9;
        LOBYTE(v9) = v55;
        uint64_t v6 = v10;
        LOBYTE(v10) = v54;
        *(_WORD *)(v52 + 12) = 1024;
        *(_DWORD *)(v52 + 14) = v75;
        *(_WORD *)(v52 + 18) = 1024;
        *(_DWORD *)(v52 + 20) = (_DWORD)v69;
        *(_WORD *)(v52 + 24) = 1024;
        *(_DWORD *)(v52 + 26) = v73;
        *(_WORD *)(v52 + 30) = 1024;
        *(_DWORD *)(v52 + 32) = v76;
        *(_WORD *)(v52 + 36) = 2080;
        *(void *)(v52 + 38) = v58;
        *(_WORD *)(v52 + 46) = 1024;
        *(_DWORD *)(v52 + 48) = v59;
        __SC_log_send(5LL, v71, v72, v50);
      }
    }

    else
    {
      uint64_t v33 = 0LL;
    }

    void *v31 = 0LL;
    v31[1] = 0LL;
    *(_BYTE *)(v6 + 100) = v80;
    *(_BYTE *)(v6 + 101) = v10;
    *(_BYTE *)(v6 + 102) = v9;
    *(_BYTE *)(v6 + 103) = v78;
    *(_DWORD *)(v6 + 104) = v82;
    *(_DWORD *)(v6 + 108) = v30;
    *(_DWORD *)(v6 + 112) = v81;
    close(v77);
  }

  *(CFAbsoluteTime *)(v6 + 144) = timer_get_current_time();
  *(_DWORD *)(v6 + 160) = 0;
  int v60 = sub_54F6C(v79);
  sub_37000(v60, 0, v81);
  byte_6C180 = 1;
  dispatch_source_merge_data((dispatch_source_t)qword_6C1B0, 1uLL);
  return v33;
}

double sub_1896C( uint64_t a1, uint64_t a2, uint64_t a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15)
{
  *(void *)&double result = 136318466LL;
  *(_DWORD *)a1 = 136318466;
  *(void *)(a1 + 4) = a2;
  *(_WORD *)(a1 + 12) = 2080;
  *(void *)(a1 + 14) = a3;
  *(_WORD *)(a1 + 22) = 1024;
  *(_DWORD *)(a1 + 24) = a4;
  *(_WORD *)(a1 + 28) = 1024;
  *(_DWORD *)(a1 + 30) = a5;
  *(_WORD *)(a1 + 34) = 1024;
  *(_DWORD *)(a1 + 36) = a6;
  *(_WORD *)(a1 + 40) = 1024;
  *(_DWORD *)(a1 + 42) = a7;
  *(_WORD *)(a1 + 46) = 1024;
  *(_DWORD *)(a1 + 48) = a8;
  *(_WORD *)(a1 + 52) = 1024;
  *(_DWORD *)(a1 + 54) = a9;
  *(_WORD *)(a1 + 58) = 1024;
  *(_DWORD *)(a1 + 60) = a10;
  *(_WORD *)(a1 + 64) = 1024;
  *(_DWORD *)(a1 + 66) = a11;
  *(_WORD *)(a1 + 70) = 1024;
  *(_DWORD *)(a1 + 72) = a12;
  *(_WORD *)(a1 + 76) = 1024;
  *(_DWORD *)(a1 + 78) = a13;
  *(_WORD *)(a1 + 82) = 1024;
  *(_DWORD *)(a1 + 84) = a14;
  *(_WORD *)(a1 + 88) = 1024;
  *(_DWORD *)(a1 + 90) = a15;
  return result;
}

uint64_t sub_18A00(uint64_t a1)
{
  uint64_t v1 = (void *)(a1 + 100);
  unsigned int v2 = *(_DWORD *)(a1 + 100);
  if (v2)
  {
    uint64_t v4 = *(void *)(a1 + 16);
    uint64_t v5 = *(void *)(v4 + 8);
    int v6 = *(_DWORD *)(a1 + 112);
    void *v1 = 0LL;
    v1[1] = 0LL;
    unsigned int v7 = v2 & 0xFF000000 | (BYTE2(v2) << 16) | (BYTE1(v2) << 8) | v2;
    if (sub_18C1C(v4, v7))
    {
      uint64_t v8 = 0LL;
    }

    else
    {
      uint64_t v9 = sub_57538();
      uint64_t v10 = _SC_syslog_os_log_mapping(5LL);
      if (__SC_log_enabled(5LL, v9, v10))
      {
        int v24 = BYTE2(v2);
        unsigned int v25 = HIBYTE(v2);
        int v11 = v2;
        int v12 = BYTE1(v2);
        uint64_t v13 = _os_log_pack_size(46LL);
        char v23 = &v22;
        int v14 = (char *)&v22 - ((__chkstk_darwin(v13) + 15) & 0xFFFFFFFFFFFFFFF0LL);
        uint64_t v15 = __error();
        uint64_t v16 = _os_log_pack_fill( v14,  v13,  *v15,  &dword_0,  "%s %s: removing %d.%d.%d.%d",  v22,  (const char *)v23,  v24,  v26,  v27,  v28);
        uint64_t v17 = sub_14420(*(_DWORD *)(a1 + 24));
        uint64_t v18 = nullsub_1(v5);
        *(_DWORD *)uint64_t v16 = 136316418;
        *(void *)(v16 + 4) = v17;
        *(_WORD *)(v16 + 12) = 2080;
        *(void *)(v16 + 14) = v18;
        *(_WORD *)(v16 + 22) = 1024;
        *(_DWORD *)(v16 + 24) = v11;
        *(_WORD *)(v16 + 28) = 1024;
        *(_DWORD *)(v16 + 30) = v12;
        *(_WORD *)(v16 + 34) = 1024;
        *(_DWORD *)(v16 + 36) = v24;
        *(_WORD *)(v16 + 40) = 1024;
        *(_DWORD *)(v16 + 42) = v25;
        __SC_log_send(5LL, v9, v10, v14);
      }

      uint64_t v19 = (const char *)nullsub_1(v5);
      uint64_t v8 = sub_18C88(v19, v7);
    }

    int v20 = sub_54F6C(v5);
    sub_37000(v20, v7, v6);
  }

  else
  {
    uint64_t v8 = 0LL;
  }

  byte_6C180 = 1;
  dispatch_source_merge_data((dispatch_source_t)qword_6C1B0, 1uLL);
  return v8;
}

uint64_t sub_18C1C(uint64_t a1, int a2)
{
  uint64_t v3 = a1 + 24;
  uint64_t v4 = 0LL;
  while (1)
  {
    uint64_t result = sub_50C98(v3, v4);
    if (*(_DWORD *)(result + 100) == a2) {
      break;
    }
    uint64_t v4 = (v4 + 1);
  }

  return result;
}

uint64_t sub_18C88(const char *a1, int a2)
{
  int v4 = sub_31700();
  if (v4 < 0)
  {
    uint64_t v16 = *__error();
    uint64_t v17 = sub_57538();
    uint64_t v18 = _SC_syslog_os_log_mapping(3LL);
    if (__SC_log_enabled(3LL, v17, v18))
    {
      uint64_t v19 = _os_log_pack_size(28LL);
      int v20 = (char *)&v38 - ((__chkstk_darwin(v19) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v21 = __error();
      uint64_t v22 = _os_log_pack_fill( v20,  v19,  *v21,  &dword_0,  "S_remove_ip_address(%s) socket() failed, %s (%d)",  v38,  v39,  (_DWORD)v40);
      char v23 = __error();
      int v24 = strerror(*v23);
      int v25 = *__error();
      *(_DWORD *)uint64_t v22 = 136315650;
      *(void *)(v22 + 4) = a1;
      *(_WORD *)(v22 + 12) = 2080;
      *(void *)(v22 + 14) = v24;
      *(_WORD *)(v22 + 22) = 1024;
      *(_DWORD *)(v22 + 24) = v25;
      __SC_log_send(3LL, v17, v18, v20);
    }
  }

  else
  {
    int v5 = v4;
    int v6 = (const char *)HIBYTE(a2);
    int v7 = BYTE2(a2);
    int v8 = BYTE1(a2);
    int v9 = a2;
    if ((sub_326AC(v4, a1, a2 & 0xFF000000 | (BYTE2(a2) << 16) | (BYTE1(a2) << 8) | a2) & 0x80000000) != 0)
    {
      uint64_t v16 = *__error();
      uint64_t v26 = (const char *)sub_57538();
      uint64_t v27 = _SC_syslog_os_log_mapping(5LL);
      if (__SC_log_enabled(5LL, v26, v27))
      {
        uint64_t v39 = v6;
        uint64_t v28 = _os_log_pack_size(52LL);
        uint64_t v40 = &v38;
        int v29 = (char *)&v38 - ((__chkstk_darwin(v28) + 15) & 0xFFFFFFFFFFFFFFF0LL);
        int v30 = __error();
        uint64_t v31 = _os_log_pack_fill( v29,  v28,  *v30,  &dword_0,  "%s: failed to remove IP address %d.%d.%d.%d, %s (%d)",  v38,  (_DWORD)v39,  (_DWORD)v40,  v41,  v42,  v43,  v44);
        int v32 = __error();
        uint64_t v33 = strerror(*v32);
        uint64_t v38 = v26;
        uint64_t v34 = v33;
        int v35 = *__error();
        *(_DWORD *)uint64_t v31 = 136316674;
        *(void *)(v31 + 4) = a1;
        *(_WORD *)(v31 + 12) = 1024;
        *(_DWORD *)(v31 + 14) = v9;
        *(_WORD *)(v31 + 18) = 1024;
        *(_DWORD *)(v31 + 20) = v8;
        *(_WORD *)(v31 + 24) = 1024;
        *(_DWORD *)(v31 + 26) = v7;
        *(_WORD *)(v31 + 30) = 1024;
        uint64_t v36 = v38;
        *(_DWORD *)(v31 + 32) = (_DWORD)v39;
        *(_WORD *)(v31 + 36) = 2080;
        *(void *)(v31 + 38) = v34;
        *(_WORD *)(v31 + 46) = 1024;
        *(_DWORD *)(v31 + 48) = v35;
        __SC_log_send(5LL, v36, v27, v29);
      }
    }

    else
    {
      uint64_t v10 = sub_57538();
      uint64_t v11 = _SC_syslog_os_log_mapping(5LL);
      if (__SC_log_enabled(5LL, v10, v11))
      {
        uint64_t v12 = _os_log_pack_size(36LL);
        uint64_t v40 = &v38;
        uint64_t v13 = (char *)&v38 - ((__chkstk_darwin(v12) + 15) & 0xFFFFFFFFFFFFFFF0LL);
        int v14 = __error();
        uint64_t v15 = _os_log_pack_fill( v13,  v12,  *v14,  &dword_0,  "%s: removed IP address %d.%d.%d.%d",  v38,  (_DWORD)v39,  (_DWORD)v40,  v41,  v42);
        *(_DWORD *)uint64_t v15 = 136316162;
        *(void *)(v15 + 4) = a1;
        *(_WORD *)(v15 + 12) = 1024;
        *(_DWORD *)(v15 + 14) = v9;
        *(_WORD *)(v15 + 18) = 1024;
        *(_DWORD *)(v15 + 20) = v8;
        *(_WORD *)(v15 + 24) = 1024;
        *(_DWORD *)(v15 + 26) = v7;
        *(_WORD *)(v15 + 30) = 1024;
        *(_DWORD *)(v15 + 32) = (_DWORD)v6;
        __SC_log_send(5LL, v10, v11, v13);
      }

      uint64_t v16 = 0LL;
    }

    close(v5);
  }

  return v16;
}

uint64_t sub_19020(uint64_t a1)
{
  if ((*(_BYTE *)(a1 + 25) & 2) != 0) {
    return *(unsigned int *)(a1 + 108);
  }
  else {
    return 0LL;
  }
}

void sub_19038(uint64_t a1, int a2)
{
  uint64_t v2 = *(void *)(a1 + 16);
  if (((*(_DWORD *)v2 >> 22) & 1) != a2)
  {
    uint64_t v4 = sub_57538();
    uint64_t v5 = _SC_syslog_os_log_mapping(7LL);
    if (__SC_log_enabled(7LL, v4, v5))
    {
      uint64_t v6 = _os_log_pack_size(22LL);
      int v7 = (char *)v12 - ((__chkstk_darwin(v6) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      int v8 = __error();
      uint64_t v9 = _os_log_pack_fill(v7, v6, *v8, &dword_0, "%s: CLAT46 %sactive", v12[0], v12[1]);
      uint64_t v10 = nullsub_1(*(void *)(v2 + 8));
      uint64_t v11 = "";
      if (!a2) {
        uint64_t v11 = "not ";
      }
      *(_DWORD *)uint64_t v9 = 136315394;
      *(void *)(v9 + 4) = v10;
      *(_WORD *)(v9 + 12) = 2080;
      *(void *)(v9 + 14) = v11;
      __SC_log_send(7LL, v4, v5, v7);
    }

    *(_DWORD *)uint64_t v2 = *(_DWORD *)v2 & 0xFFBFFFFF | ((a2 != 0) << 22);
    byte_6C180 = 1;
    dispatch_source_merge_data((dispatch_source_t)qword_6C1B0, 1uLL);
  }

uint64_t sub_191BC(uint64_t result, int a2)
{
  uint64_t v2 = *(void *)(result + 16);
  if (((*(_DWORD *)v2 >> 21) & 1) != a2)
  {
    *(_DWORD *)uint64_t v2 = *(_DWORD *)v2 & 0xFFDFFFFF | ((a2 != 0) << 21);
    uint64_t v4 = sub_57538();
    uint64_t v5 = _SC_syslog_os_log_mapping(7LL);
    uint64_t result = __SC_log_enabled(7LL, v4, v5);
    if ((_DWORD)result)
    {
      uint64_t v6 = _os_log_pack_size(22LL);
      int v7 = (char *)v12 - ((__chkstk_darwin(v6) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      int v8 = __error();
      uint64_t v9 = _os_log_pack_fill(v7, v6, *v8, &dword_0, "%s: CLAT46 %savailable", v12[0], v12[1]);
      uint64_t v10 = nullsub_1(*(void *)(v2 + 8));
      uint64_t v11 = "";
      if (!a2) {
        uint64_t v11 = "not ";
      }
      *(_DWORD *)uint64_t v9 = 136315394;
      *(void *)(v9 + 4) = v10;
      *(_WORD *)(v9 + 12) = 2080;
      *(void *)(v9 + 14) = v11;
      return __SC_log_send(7LL, v4, v5, v7);
    }
  }

  return result;
}

uint64_t sub_19320(uint64_t a1)
{
  return (**(_DWORD **)(a1 + 16) >> 20) & 1;
}

uint64_t sub_19330(uint64_t a1)
{
  return (**(_DWORD **)(a1 + 16) >> 19) & ~(**(_DWORD **)(a1 + 16) >> 20) & 1;
}

uint64_t sub_19348(uint64_t a1)
{
  return (**(_DWORD **)(a1 + 16) >> 19) & 1;
}

uint64_t sub_19358(uint64_t result)
{
  **(_DWORD **)(result + 16) &= 0xFFE7FFFF;
  return result;
}

uint64_t sub_1936C(uint64_t a1)
{
  if ((*(_BYTE *)(a1 + 25) & 2) != 0) {
    return *(unsigned int *)(a1 + 112);
  }
  else {
    return 0LL;
  }
}

uint64_t sub_19384(uint64_t a1)
{
  return sub_54F74(*(void *)(*(void *)(a1 + 16) + 8LL));
}

BOOL sub_193A4(uint64_t a1)
{
  return (*(_BYTE *)(a1 + 25) & 1) != 0 && *(_DWORD *)(a1 + 100) == *(_DWORD *)(a1 + 88);
}

uint64_t sub_193C8(uint64_t result, int a2)
{
  if ((*(_BYTE *)(result + 25) & 1) != 0) {
    *(_DWORD *)(result + 88) = a2;
  }
  return result;
}

uint64_t sub_193D8(uint64_t a1)
{
  if ((*(_BYTE *)(a1 + 25) & 1) != 0) {
    return *(unsigned int *)(a1 + 88);
  }
  else {
    return 0LL;
  }
}

uint64_t sub_193F0(uint64_t result, int a2)
{
  if ((*(_BYTE *)(result + 25) & 1) != 0) {
    *(_DWORD *)(result + 92) = a2;
  }
  return result;
}

uint64_t sub_19400(uint64_t a1)
{
  if ((*(_BYTE *)(a1 + 25) & 1) != 0) {
    return *(unsigned int *)(a1 + 92);
  }
  else {
    return 0LL;
  }
}

uint64_t sub_19418(uint64_t result, int a2)
{
  if ((*(_BYTE *)(result + 25) & 1) != 0) {
    *(_DWORD *)(result + 96) = a2;
  }
  return result;
}

uint64_t sub_19428(uint64_t a1)
{
  if ((*(_BYTE *)(a1 + 25) & 1) != 0) {
    return *(unsigned int *)(a1 + 96);
  }
  else {
    return 0LL;
  }
}

uint64_t sub_19440(uint64_t a1)
{
  if ((*(_BYTE *)(a1 + 25) & 1) != 0) {
    return (*(_DWORD *)(a1 + 116) >> 1) & 1;
  }
  else {
    return 0LL;
  }
}

uint64_t sub_1945C(uint64_t result)
{
  if ((*(_BYTE *)(result + 25) & 1) != 0) {
    *(_DWORD *)(result + 116) |= 2u;
  }
  return result;
}

uint64_t sub_19474(uint64_t a1)
{
  if ((*(_BYTE *)(a1 + 25) & 1) != 0) {
    return (*(_DWORD *)(a1 + 116) >> 2) & 1;
  }
  else {
    return 0LL;
  }
}

uint64_t sub_19490(uint64_t result)
{
  if ((*(_BYTE *)(result + 25) & 1) != 0) {
    *(_DWORD *)(result + 116) |= 7u;
  }
  return result;
}

uint64_t sub_194A8(uint64_t a1)
{
  return *(void *)(*(void *)(a1 + 16) + 16LL);
}

uint64_t sub_194B4(uint64_t a1)
{
  return (**(_DWORD **)(a1 + 16) >> 4) & 1;
}

uint64_t sub_194C4(uint64_t a1)
{
  return *(void *)(a1 + 80);
}

uint64_t sub_194CC(uint64_t result, uint64_t a2)
{
  *(void *)(result + 80) = a2;
  return result;
}

uint64_t sub_194D4(uint64_t a1)
{
  if ((*(_BYTE *)(a1 + 25) & 1) != 0) {
    return *(unsigned int *)(a1 + 100);
  }
  else {
    return 0LL;
  }
}

uint64_t sub_194EC(uint64_t a1)
{
  if ((*(_BYTE *)(a1 + 25) & 1) != 0) {
    return *(unsigned int *)(a1 + 104);
  }
  else {
    return 0LL;
  }
}

uint64_t sub_19504(uint64_t result, int a2)
{
  *(_DWORD *)(result + 28) = a2;
  return result;
}

__n128 sub_1950C(uint64_t a1, __n128 *a2, int a3)
{
  if ((*(_BYTE *)(a1 + 25) & 2) != 0)
  {
    __n128 result = *a2;
    *(__n128 *)(a1 + 88) = *a2;
    *(_DWORD *)(a1 + 104) = a3;
  }

  return result;
}

__n128 sub_19524(uint64_t a1, __n128 *a2, _DWORD *a3)
{
  if ((*(_BYTE *)(a1 + 25) & 2) != 0)
  {
    __n128 result = *(__n128 *)(a1 + 88);
    *a2 = result;
    *a3 = *(_DWORD *)(a1 + 104);
  }

  return result;
}

uint64_t sub_19540(uint64_t a1, char *a2, int a3, int a4, int a5, int a6)
{
  if ((*(_BYTE *)(a1 + 25) & 2) == 0) {
    return 22LL;
  }
  uint64_t v53 = a2;
  uint64_t v12 = *(void *)(*(void *)(a1 + 16) + 8LL);
  uint64_t v13 = sub_57538();
  uint64_t v14 = _SC_syslog_os_log_mapping(6LL);
  if (__SC_log_enabled(6LL, v13, v14))
  {
    HIDWORD(v52) = a6;
    uint64_t v15 = _os_log_pack_size(38LL);
    uint64_t v51 = (const char *)&v51;
    uint64_t v16 = (char *)&v51 - ((__chkstk_darwin(v15) + 15) & 0xFFFFFFFFFFFFFFF0LL);
    uint64_t v17 = __error();
    uint64_t v18 = _os_log_pack_fill(v16, v15, *v17, &dword_0, "%s %s: setting %s/%d", v51, v52, v53, v54);
    uint64_t v19 = sub_14420(*(_DWORD *)(a1 + 24));
    int v20 = a4;
    int v21 = a5;
    uint64_t v22 = v12;
    uint64_t v23 = nullsub_1(v12);
    int v24 = inet_ntop(30, v53, (char *)&v54 + 2, 0x2Eu);
    *(_DWORD *)uint64_t v18 = 136315906;
    *(void *)(v18 + 4) = v19;
    *(_WORD *)(v18 + 12) = 2080;
    *(void *)(v18 + 14) = v23;
    uint64_t v12 = v22;
    a5 = v21;
    a4 = v20;
    *(_WORD *)(v18 + 22) = 2080;
    *(void *)(v18 + 24) = v24;
    *(_WORD *)(v18 + 32) = 1024;
    *(_DWORD *)(v18 + 34) = a3;
    a6 = HIDWORD(v52);
    __SC_log_send(6LL, v13, v14, v16);
  }

  int v25 = sub_32804();
  if (v25 < 0)
  {
    uint64_t v28 = v12;
    uint64_t v6 = *__error();
    uint64_t v29 = sub_57538();
    uint64_t v30 = _SC_syslog_os_log_mapping(3LL);
    if (__SC_log_enabled(3LL, v29, v30))
    {
      uint64_t v31 = _os_log_pack_size(28LL);
      int v32 = (char *)&v51 - ((__chkstk_darwin(v31) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v33 = __error();
      uint64_t v34 = _os_log_pack_fill( v32,  v31,  *v33,  &dword_0,  "ServiceSetIPv6Address(%s): socket() failed, %s (%d)",  v51,  v52,  (_DWORD)v53);
      uint64_t v35 = nullsub_1(v28);
      uint64_t v36 = __error();
      uint64_t v37 = strerror(*v36);
      int v38 = *__error();
      *(_DWORD *)uint64_t v34 = 136315650;
      *(void *)(v34 + 4) = v35;
      *(_WORD *)(v34 + 12) = 2080;
      *(void *)(v34 + 14) = v37;
      *(_WORD *)(v34 + 22) = 1024;
      *(_DWORD *)(v34 + 24) = v38;
      __SC_log_send(3LL, v29, v30, v32);
    }
  }

  else
  {
    int v26 = v25;
    uint64_t v27 = (const char *)nullsub_1(v12);
    if ((sub_34BBC(v26, v27, v53, 0LL, a3, a4, a5, a6) & 0x80000000) != 0)
    {
      uint64_t v39 = v12;
      uint64_t v6 = *__error();
      uint64_t v40 = sub_57538();
      uint64_t v41 = _SC_syslog_os_log_mapping(6LL);
      if (__SC_log_enabled(6LL, v40, v41))
      {
        uint64_t v42 = _os_log_pack_size(28LL);
        int v43 = (char *)&v51 - ((__chkstk_darwin(v42) + 15) & 0xFFFFFFFFFFFFFFF0LL);
        uint64_t v44 = __error();
        uint64_t v45 = _os_log_pack_fill( v43,  v42,  *v44,  &dword_0,  "ServiceSetIPv6Address(%s): inet6_aifaddr() failed, %s (%d)",  v51,  v52,  (_DWORD)v53);
        uint64_t v46 = nullsub_1(v39);
        uint64_t v47 = __error();
        uint64_t v48 = strerror(*v47);
        int v49 = *__error();
        *(_DWORD *)uint64_t v45 = 136315650;
        *(void *)(v45 + 4) = v46;
        *(_WORD *)(v45 + 12) = 2080;
        *(void *)(v45 + 14) = v48;
        *(_WORD *)(v45 + 22) = 1024;
        *(_DWORD *)(v45 + 24) = v49;
        __SC_log_send(6LL, v40, v41, v43);
      }
    }

    else
    {
      uint64_t v6 = 0LL;
    }

    close(v26);
  }

  return v6;
}

uint64_t sub_19938(uint64_t result, _DWORD *a2, int a3)
{
  if ((*(_BYTE *)(result + 25) & 2) != 0)
  {
    uint64_t v5 = result;
    uint64_t v6 = *(void *)(*(void *)(result + 16) + 8LL);
    if (*a2 || a2[1] || a2[2] || a2[3])
    {
      uint64_t v7 = sub_57538();
      uint64_t v8 = _SC_syslog_os_log_mapping(6LL);
      if (__SC_log_enabled(6LL, v7, v8))
      {
        uint64_t v9 = _os_log_pack_size(38LL);
        uint64_t v10 = (char *)&v29 - ((__chkstk_darwin(v9) + 15) & 0xFFFFFFFFFFFFFFF0LL);
        uint64_t v11 = __error();
        uint64_t v12 = _os_log_pack_fill(v10, v9, *v11, &dword_0, "%s %s: removing %s/%d", v29, v30, v31, v32);
        uint64_t v13 = sub_14420(*(_DWORD *)(v5 + 24));
        uint64_t v14 = nullsub_1(v6);
        uint64_t v15 = inet_ntop(30, a2, (char *)&v30 + 2, 0x2Eu);
        *(_DWORD *)uint64_t v12 = 136315906;
        *(void *)(v12 + 4) = v13;
        *(_WORD *)(v12 + 12) = 2080;
        *(void *)(v12 + 14) = v14;
        *(_WORD *)(v12 + 22) = 2080;
        *(void *)(v12 + 24) = v15;
        *(_WORD *)(v12 + 32) = 1024;
        *(_DWORD *)(v12 + 34) = a3;
        __SC_log_send(6LL, v7, v8, v10);
      }

      int v16 = sub_32804();
      if (v16 < 0)
      {
        uint64_t v19 = sub_57538();
        uint64_t v20 = _SC_syslog_os_log_mapping(3LL);
        __n128 result = __SC_log_enabled(3LL, v19, v20);
        if ((_DWORD)result)
        {
          uint64_t v21 = _os_log_pack_size(28LL);
          uint64_t v22 = (char *)&v29 - ((__chkstk_darwin(v21) + 15) & 0xFFFFFFFFFFFFFFF0LL);
          uint64_t v23 = __error();
          uint64_t v24 = _os_log_pack_fill( v22,  v21,  *v23,  &dword_0,  "ServiceRemoveIPv6Address(%s): socket() failed, %s (%d)",  v29,  v30,  (_DWORD)v31);
          uint64_t v25 = nullsub_1(v6);
          int v26 = __error();
          uint64_t v27 = strerror(*v26);
          int v28 = *__error();
          *(_DWORD *)uint64_t v24 = 136315650;
          *(void *)(v24 + 4) = v25;
          *(_WORD *)(v24 + 12) = 2080;
          *(void *)(v24 + 14) = v27;
          *(_WORD *)(v24 + 22) = 1024;
          *(_DWORD *)(v24 + 24) = v28;
          return __SC_log_send(3LL, v19, v20, v22);
        }
      }

      else
      {
        int v17 = v16;
        uint64_t v18 = (const char *)nullsub_1(v6);
        sub_347B8(v17, v18, a2);
        return close(v17);
      }
    }
  }

  return result;
}

uint64_t sub_19BF0(uint64_t a1)
{
  uint64_t result = *(void *)(*(void *)(a1 + 16) + 96LL);
  if (result) {
    return sub_2A59C(result);
  }
  return result;
}

uint64_t sub_19C04(uint64_t a1)
{
  uint64_t result = *(void *)(*(void *)(a1 + 16) + 96LL);
  if (result) {
    return sub_2A630(result);
  }
  return result;
}

uint64_t sub_19C18(uint64_t a1)
{
  return *(void *)(a1 + 8);
}

BOOL sub_19C20(uint64_t a1)
{
  return (*(_WORD *)(*(void *)(a1 + 16) + 2LL) & 1) == 0;
}

uint64_t sub_19C34(uint64_t a1, _DWORD *a2)
{
  uint64_t v4 = *(unsigned __int8 **)(*(void *)(a1 + 16) + 8LL);
  int v5 = sub_54E78((uint64_t)v4);
  if (!v5) {
    goto LABEL_14;
  }
  uint64_t v6 = *(void *)(a1 + 16);
  uint64_t v7 = *(void *)(v6 + 96);
  if (!v7 || ((v8 = sub_2A628(*(void *)(v6 + 96))) != 0 ? (BOOL v9 = v8 == 0xFFFF) : (BOOL v9 = 1), v9))
  {
    int v5 = 0;
    goto LABEL_9;
  }

  int v5 = sub_54E4C(v4);
  if (!v5)
  {
LABEL_14:
    uint64_t v10 = 0LL;
    if (!a2) {
      return v10;
    }
    goto LABEL_10;
  }

  int v5 = WiFiInfoAllowSharingDeviceType(v7);
LABEL_9:
  uint64_t v10 = 1LL;
  if (a2) {
LABEL_10:
  }
    *a2 = v5;
  return v10;
}

uint64_t remove_unused_ip(const char *a1, int a2)
{
  uint64_t result = sub_19E70(a1, 0LL);
  if (result)
  {
    uint64_t v5 = result;
    unsigned int v6 = a2 & 0xFF000000 | (BYTE2(a2) << 16) | (BYTE1(a2) << 8) | a2;
    uint64_t result = sub_18C1C(result, v6);
    if (!result)
    {
      uint64_t v7 = sub_57538();
      uint64_t v8 = _SC_syslog_os_log_mapping(6LL);
      if (__SC_log_enabled(6LL, v7, v8))
      {
        uint64_t v19 = HIBYTE(a2);
        int v18 = BYTE2(a2);
        int v9 = a2;
        int v10 = BYTE1(a2);
        uint64_t v11 = _os_log_pack_size(36LL);
        uint64_t v12 = (char *)&v16 - ((__chkstk_darwin(v11) + 15) & 0xFFFFFFFFFFFFFFF0LL);
        uint64_t v13 = __error();
        uint64_t v14 = _os_log_pack_fill( v12,  v11,  *v13,  &dword_0,  "IPConfiguration %s: removing unused %d.%d.%d.%d",  v16,  v17,  v19,  v20,  v21);
        *(_DWORD *)uint64_t v14 = 136316162;
        *(void *)(v14 + 4) = a1;
        *(_WORD *)(v14 + 12) = 1024;
        *(_DWORD *)(v14 + 14) = v9;
        *(_WORD *)(v14 + 18) = 1024;
        *(_DWORD *)(v14 + 20) = v10;
        *(_WORD *)(v14 + 24) = 1024;
        *(_DWORD *)(v14 + 26) = v18;
        *(_WORD *)(v14 + 30) = 1024;
        *(_DWORD *)(v14 + 32) = v19;
        __SC_log_send(6LL, v7, v8, v12);
      }

      uint64_t v15 = (const char *)nullsub_1(*(void *)(v5 + 8));
      return sub_18C88(v15, v6);
    }
  }

  return result;
}

uint64_t sub_19E70(const char *a1, _DWORD *a2)
{
  uint64_t v4 = 0LL;
  while (1)
  {
    uint64_t v5 = sub_50C98(&unk_6C150, v4);
    unsigned int v6 = (const char *)nullsub_1(*(void *)(v5 + 8));
    if (!strcmp(v6, a1)) {
      break;
    }
    uint64_t v4 = (v4 + 1);
  }

  if (a2) {
    *a2 = v4;
  }
  return v5;
}

CFIndex sub_19F0C(CFIndex result, in_addr *a2)
{
  if (!result) {
    return result;
  }
  uint64_t v3 = (const void *)result;
  CFTypeID TypeID = CFDictionaryGetTypeID();
  if (CFGetTypeID(v3) != TypeID) {
    return 3LL;
  }
  Value = (const __CFDictionary *)CFDictionaryGetValue((CFDictionaryRef)v3, kSCEntNetIPv4);
  if (Value)
  {
    unsigned int v6 = Value;
    BOOL v7 = 0;
  }

  else
  {
    uint64_t v8 = (const __CFDictionary *)CFDictionaryGetValue((CFDictionaryRef)v3, kSCEntNetIPv6);
    BOOL v7 = v8 != 0LL;
    if (v8) {
      unsigned int v6 = v8;
    }
    else {
      unsigned int v6 = (const __CFDictionary *)v3;
    }
  }

  CFTypeID v9 = CFDictionaryGetTypeID();
  if (CFGetTypeID(v6) == v9 && v6 != 0LL)
  {
    uint64_t result = CFDictionaryGetCount(v6);
    if (result)
    {
      if (v7) {
        return sub_1A888(v6, (uint64_t)a2);
      }
      else {
        return sub_1A148(v6, a2);
      }
    }

    else
    {
      if (v7) {
        int v18 = 512;
      }
      else {
        int v18 = 256;
      }
      a2->s_addr = v18;
    }

    return result;
  }

  uint64_t v11 = sub_57538();
  uint64_t v12 = _SC_syslog_os_log_mapping(5LL);
  uint64_t v13 = _os_log_pack_size(8LL);
  uint64_t v14 = (char *)&v19 - ((__chkstk_darwin(v13) + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v15 = __error();
  int v16 = (_DWORD *)_os_log_pack_fill( v14,  v13,  *v15,  &dword_0,  "IPConfiguration: invalid IPv%c entity",  v19);
  if (v7) {
    int v17 = 54;
  }
  else {
    int v17 = 52;
  }
  *int v16 = 67109120;
  v16[1] = v17;
  __SC_log_send(5LL, v11, v12, v14);
  return 3LL;
}

uint64_t sub_1A148(const __CFDictionary *a1, in_addr *a2)
{
  Value = CFDictionaryGetValue(a1, kSCPropNetIPv4ConfigMethod);
  if (sub_217E8(Value, (int *)a2))
  {
    uint64_t result = 0LL;
    switch(a2->s_addr)
    {
      case 0x101u:
      case 0x104u:
      case 0x106u:
        uint64_t v63 = 0LL;
        if (v64[0].s_addr)
        {
          CFStringRef v6 = kSCPropNetIPv4SubnetMasks;
          if (CFDictionaryContainsKey(a1, kSCPropNetIPv4SubnetMasks)
            && !sub_219D0(a1, kSCPropNetIPv4SubnetMasks, (in_addr *)&v63))
          {
            uint64_t v37 = sub_57538();
            uint64_t v38 = _SC_syslog_os_log_mapping(5LL);
          }

          else
          {
            CFStringRef v6 = kSCPropNetIPv4DestAddresses;
            if (!CFDictionaryContainsKey(a1, kSCPropNetIPv4DestAddresses))
            {
              in_addr_t v7 = 0;
LABEL_23:
              in_addr_t v33 = v63;
              a2[2].s_addr = (in_addr_t)v64[0];
              a2[3].s_addr = v33;
              a2[5].s_addr = v7;
              if (a2->s_addr == 262)
              {
                uint64_t v39 = (const __CFNumber *)CFDictionaryGetValue(a1, @"FailoverAddressTimeout");
                if (!v39) {
                  return 0LL;
                }
                uint64_t v40 = v39;
                CFTypeID TypeID = CFNumberGetTypeID();
                if (CFGetTypeID(v40) == TypeID)
                {
                  if (CFNumberGetValue(v40, kCFNumberSInt32Type, &a2[7])) {
                    return 0LL;
                  }
                }

                uint64_t v42 = sub_57538();
                uint64_t v43 = _SC_syslog_os_log_mapping(5LL);
                uint64_t v44 = _os_log_pack_size(2LL);
                uint64_t v45 = (char *)&v64[-2] - ((__chkstk_darwin(v44) + 15) & 0xFFFFFFFFFFFFFFF0LL);
                uint64_t v46 = __error();
                *(_WORD *)_os_log_pack_fill( v45,  v44,  *v46,  &dword_0,  "IPConfiguration: FailoverAddressTimeout invalid") = 0;
                uint64_t v47 = v42;
                uint64_t v48 = v43;
                int v49 = v45;
              }

              else
              {
                if (a2->s_addr != 257) {
                  return 0LL;
                }
                uint64_t v34 = (const __CFBoolean *)CFDictionaryGetValue(a1, kSCPropNetIgnoreLinkStatus);
                CFTypeID v35 = CFBooleanGetTypeID();
                if (v34 && CFGetTypeID(v34) == v35) {
                  in_addr_t v36 = CFBooleanGetValue(v34);
                }
                else {
                  in_addr_t v36 = 0;
                }
                a2[6].s_addr = v36;
                char v55 = (const __CFString *)CFDictionaryGetValue(a1, kSCPropNetIPv4Router);
                if (!v55) {
                  return 0LL;
                }
                if ((sub_4FCC8(v55, a2 + 4) & 1) != 0) {
                  return 0LL;
                }
                uint64_t v56 = sub_57538();
                uint64_t v57 = _SC_syslog_os_log_mapping(5LL);
                uint64_t v58 = _os_log_pack_size(22LL);
                int v59 = (char *)&v64[-2] - ((__chkstk_darwin(v58) + 15) & 0xFFFFFFFFFFFFFFF0LL);
                int v60 = __error();
                uint64_t v61 = _os_log_pack_fill(v59, v58, *v60, &dword_0, "%s: %@ invalid");
                int v62 = sub_14420(a2->s_addr);
                *(_DWORD *)uint64_t v61 = 136315394;
                *(void *)(v61 + 4) = v62;
                *(_WORD *)(v61 + 12) = 2112;
                *(void *)(v61 + 14) = kSCPropNetIPv4Router;
                uint64_t v47 = v56;
                uint64_t v48 = v57;
                int v49 = v59;
              }

              __SC_log_send(5LL, v47, v48, v49);
              return 0LL;
            }

            if (sub_219D0(a1, kSCPropNetIPv4DestAddresses, (in_addr *)&v63 + 1))
            {
              in_addr_t v7 = HIDWORD(v63);
              goto LABEL_23;
            }

            uint64_t v37 = sub_57538();
            uint64_t v38 = _SC_syslog_os_log_mapping(5LL);
          }

          uint64_t v50 = _os_log_pack_size(22LL);
          uint64_t v51 = (char *)&v64[-2] - ((__chkstk_darwin(v50) + 15) & 0xFFFFFFFFFFFFFFF0LL);
          uint64_t v52 = *__error();
          uint64_t v53 = _os_log_pack_fill(v51, v50, v52, &dword_0, "%s: %@ invalid", v63);
          int v54 = sub_14420(a2->s_addr);
          *(_DWORD *)uint64_t v53 = 136315394;
          *(void *)(v53 + 4) = v54;
          *(_WORD *)(v53 + 12) = 2112;
          *(void *)(v53 + 14) = v6;
          uint64_t v30 = v37;
          uint64_t v31 = v38;
          int v32 = v51;
        }

        else
        {
          uint64_t v23 = sub_57538();
          uint64_t v24 = _SC_syslog_os_log_mapping(5LL);
          uint64_t v25 = _os_log_pack_size(12LL);
          int v26 = (char *)&v64[-2] - ((__chkstk_darwin(v25) + 15) & 0xFFFFFFFFFFFFFFF0LL);
          uint64_t v27 = __error();
          uint64_t v28 = _os_log_pack_fill(v26, v25, *v27, &dword_0, "%s 0.0.0.0 is not a valid address", v63);
          uint64_t v29 = sub_14420(a2->s_addr);
          *(_DWORD *)uint64_t v28 = 136315138;
          *(void *)(v28 + 4) = v29;
          uint64_t v30 = v23;
          uint64_t v31 = v24;
          int v32 = v26;
        }

        __SC_log_send(5LL, v30, v31, v32);
        return 3LL;
      case 0x103u:
        uint64_t v13 = (const __CFString *)CFDictionaryGetValue(a1, kSCPropNetIPv4DHCPClientID);
        CFTypeID v14 = CFStringGetTypeID();
        if (!v13) {
          return 0LL;
        }
        if (CFGetTypeID(v13) != v14) {
          return 0LL;
        }
        int v15 = sub_4FC44(v13, (UInt8 *)v64, 256, 0);
        int v16 = v15 - (v15 > 0);
        if (v16 < 1) {
          return 0LL;
        }
        a2[2].s_addr = v16;
        int v17 = strdup((const char *)v64);
        *(void *)&a2[4].s_addr = v17;
        if (v17) {
          return 0LL;
        }
        uint64_t v18 = sub_57538();
        uint64_t v19 = _SC_syslog_os_log_mapping(5LL);
        if (__SC_log_enabled(5LL, v18, v19))
        {
          uint64_t v20 = _os_log_pack_size(2LL);
          uint64_t v21 = (char *)&v64[-2] - ((__chkstk_darwin(v20) + 15) & 0xFFFFFFFFFFFFFFF0LL);
          uint64_t v22 = __error();
          *(_WORD *)_os_log_pack_fill( v21,  v20,  *v22,  &dword_0,  "IPConfiguration: strdup DHCP client ID failed") = 0;
          __SC_log_send(5LL, v18, v19, v21);
        }

        return 5LL;
      case 0x105u:
        uint64_t result = 0LL;
        a2[2].s_addr = 1;
        return result;
      default:
        return result;
    }
  }

  uint64_t v8 = sub_57538();
  uint64_t v9 = _SC_syslog_os_log_mapping(5LL);
  uint64_t v10 = _os_log_pack_size(2LL);
  uint64_t v11 = (char *)&v64[-2] - ((__chkstk_darwin(v10) + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v12 = __error();
  *(_WORD *)_os_log_pack_fill( v11,  v10,  *v12,  &dword_0,  "IPConfiguration: IPv4 ConfigMethod is missing/invalid") = 0;
  __SC_log_send(5LL, v8, v9, v11);
  return 3LL;
}

uint64_t sub_1A888(const __CFDictionary *a1, uint64_t a2)
{
  Value = (const __CFString *)CFDictionaryGetValue(a1, kSCPropNetIPv6LinkLocalAddress);
  uint64_t v5 = CFDictionaryGetValue(a1, kSCPropNetIPv6ConfigMethod);
  CFTypeID TypeID = CFStringGetTypeID();
  if (!v5 || CFGetTypeID(v5) != TypeID) {
    goto LABEL_67;
  }
  if (!CFEqual(v5, kSCValNetIPv6ConfigMethodManual))
  {
    if (CFEqual(v5, kSCValNetIPv6ConfigMethodAutomatic))
    {
      int v12 = 514;
LABEL_36:
      uint64_t v24 = 0LL;
      *(_DWORD *)a2 = v12;
      return (uint64_t)v24;
    }

    if (CFEqual(v5, kSCValNetIPv6ConfigMethodRouterAdvertisement))
    {
      int v12 = 515;
      goto LABEL_36;
    }

    if (CFEqual(v5, kSCValNetIPv6ConfigMethod6to4))
    {
      *(_DWORD *)a2 = 516;
      in_addr_t v33 = (const __CFString *)CFDictionaryGetValue(a1, @"6to4Relay");
      if (!v33) {
        return 0LL;
      }
      uint64_t v34 = v33;
      CFTypeID v35 = CFStringGetTypeID();
      if (CFGetTypeID(v34) == v35)
      {
        if (sub_4FC44(v34, (UInt8 *)v90, 256, 0))
        {
          if (inet_aton((const char *)v90, &v88) == 1)
          {
            *(_DWORD *)(a2 + 8) = 1;
            *(in_addr *)(a2 + 16) = v88;
          }

          else if (inet_pton(30, (const char *)v90, &v87[4]) == 1)
          {
            *(_DWORD *)(a2 + 8) = 2;
            *(_OWORD *)(a2 + 16) = *(_OWORD *)&v87[4];
          }

          else
          {
            *(_DWORD *)(a2 + 8) = 3;
            int v68 = strdup((const char *)v90);
            *(void *)(a2 + 16) = v68;
            if (!v68)
            {
              uint64_t v79 = sub_57538();
              uint64_t v24 = (const __CFString *)(&dword_4 + 1);
              uint64_t v80 = _SC_syslog_os_log_mapping(5LL);
              if (__SC_log_enabled(5LL, v79, v80))
              {
                uint64_t v81 = _os_log_pack_size(2LL);
                int v82 = &v87[-((__chkstk_darwin(v81) + 15) & 0xFFFFFFFFFFFFFFF0LL)];
                int v83 = __error();
                *(_WORD *)_os_log_pack_fill( v82,  v81,  *v83,  &dword_0,  "IPConfiguration: malloc relay dns address failed") = 0;
                uint64_t v24 = (const __CFString *)(&dword_4 + 1);
                __SC_log_send(5LL, v79, v80, v82);
              }

              return (uint64_t)v24;
            }
          }

          return 0LL;
        }

        uint64_t v44 = sub_57538();
        uint64_t v45 = _SC_syslog_os_log_mapping(5LL);
        uint64_t v64 = _os_log_pack_size(12LL);
        uint64_t v47 = &v87[-((__chkstk_darwin(v64) + 15) & 0xFFFFFFFFFFFFFFF0LL)];
        uint64_t v65 = *__error();
        uint64_t v49 = _os_log_pack_fill(v47, v64, v65, &dword_0, "IPConfiguration: %s 6to4 Relay empty");
      }

      else
      {
        uint64_t v44 = sub_57538();
        uint64_t v45 = _SC_syslog_os_log_mapping(5LL);
        uint64_t v46 = _os_log_pack_size(12LL);
        uint64_t v47 = &v87[-((__chkstk_darwin(v46) + 15) & 0xFFFFFFFFFFFFFFF0LL)];
        uint64_t v48 = *__error();
        uint64_t v49 = _os_log_pack_fill(v47, v46, v48, &dword_0, "IPConfiguration: %s 6to4 Relay invalid");
      }

      uint64_t v66 = v49;
      int v67 = sub_14420(*(_DWORD *)a2);
      *(_DWORD *)uint64_t v66 = 136315138;
      *(void *)(v66 + 4) = v67;
      __SC_log_send(5LL, v44, v45, v47);
      return 3LL;
    }

    if (CFEqual(v5, kSCValNetIPv6ConfigMethodLinkLocal))
    {
      int v12 = 517;
      goto LABEL_36;
    }

    if (CFEqual(v5, @"DHCPv6PD"))
    {
      *(_DWORD *)a2 = 518;
      uint64_t v50 = (const __CFString *)CFDictionaryGetValue(a1, @"RequestedPrefix");
      if (!v50) {
        goto LABEL_61;
      }
      uint64_t v51 = v50;
      CFTypeID v52 = CFStringGetTypeID();
      if (CFGetTypeID(v51) == v52)
      {
        if ((sub_4FD78(v51, (void *)(a2 + 8)) & 1) != 0)
        {
          inet_ntop(30, (const void *)(a2 + 8), (char *)v90, 0x2Eu);
LABEL_61:
          uint64_t v24 = (const __CFString *)CFDictionaryGetValue(a1, @"RequestedPrefixLength");
          if (!v24) {
            return (uint64_t)v24;
          }
          CFTypeID v53 = CFNumberGetTypeID();
          if (CFGetTypeID(v24) == v53)
          {
            if ((sub_4FEC8(v24, v90) & 1) != 0)
            {
              if (LODWORD(v90[0]) < 0x81)
              {
                uint64_t v24 = 0LL;
                *(_BYTE *)(a2 + 24) = v90[0];
                return (uint64_t)v24;
              }

              uint64_t v54 = sub_57538();
              uint64_t v26 = _SC_syslog_os_log_mapping(5LL);
              uint64_t v55 = _os_log_pack_size(28LL);
              uint64_t v28 = &v87[-((__chkstk_darwin(v55) + 15) & 0xFFFFFFFFFFFFFFF0LL)];
              uint64_t v56 = __error();
              uint64_t v57 = _os_log_pack_fill(v28, v55, *v56, &dword_0, "%s: %@ %d > 128");
              int v58 = v90[0];
              *(_DWORD *)uint64_t v57 = 136315650;
              *(void *)(v57 + 4) = "method_info_from_ipv6_dict";
              *(_WORD *)(v57 + 12) = 2112;
              *(void *)(v57 + 14) = @"RequestedPrefixLength";
              *(_WORD *)(v57 + 22) = 1024;
              *(_DWORD *)(v57 + 24) = v58;
              goto LABEL_88;
            }

            uint64_t v54 = sub_57538();
            uint64_t v26 = _SC_syslog_os_log_mapping(5LL);
            uint64_t v84 = _os_log_pack_size(22LL);
            uint64_t v28 = &v87[-((__chkstk_darwin(v84) + 15) & 0xFFFFFFFFFFFFFFF0LL)];
            uint64_t v85 = *__error();
            uint64_t v76 = _os_log_pack_fill(v28, v84, v85, &dword_0, "%s: %@ invalid number");
          }

          else
          {
            uint64_t v54 = sub_57538();
            uint64_t v26 = _SC_syslog_os_log_mapping(5LL);
            uint64_t v74 = _os_log_pack_size(22LL);
            uint64_t v28 = &v87[-((__chkstk_darwin(v74) + 15) & 0xFFFFFFFFFFFFFFF0LL)];
            uint64_t v75 = *__error();
            uint64_t v76 = _os_log_pack_fill(v28, v74, v75, &dword_0, "%s: %@ not a number");
          }

          *(_DWORD *)uint64_t v76 = 136315394;
          *(void *)(v76 + 4) = "method_info_from_ipv6_dict";
          *(_WORD *)(v76 + 12) = 2112;
          *(void *)(v76 + 14) = @"RequestedPrefixLength";
LABEL_88:
          uint64_t v42 = v54;
          goto LABEL_50;
        }

        uint64_t v69 = sub_57538();
        uint64_t v70 = _SC_syslog_os_log_mapping(5LL);
        uint64_t v77 = _os_log_pack_size(22LL);
        uint64_t v28 = &v87[-((__chkstk_darwin(v77) + 15) & 0xFFFFFFFFFFFFFFF0LL)];
        uint64_t v78 = *__error();
        uint64_t v73 = _os_log_pack_fill(v28, v77, v78, &dword_0, "%s: %@ not an IPv6 address");
      }

      else
      {
        uint64_t v69 = sub_57538();
        uint64_t v70 = _SC_syslog_os_log_mapping(5LL);
        uint64_t v71 = _os_log_pack_size(22LL);
        uint64_t v28 = &v87[-((__chkstk_darwin(v71) + 15) & 0xFFFFFFFFFFFFFFF0LL)];
        uint64_t v72 = *__error();
        uint64_t v73 = _os_log_pack_fill(v28, v71, v72, &dword_0, "%s: %@ not a string");
      }

      *(_DWORD *)uint64_t v73 = 136315394;
      *(void *)(v73 + 4) = "method_info_from_ipv6_dict";
      *(_WORD *)(v73 + 12) = 2112;
      *(void *)(v73 + 14) = @"RequestedPrefix";
      uint64_t v42 = v69;
      uint64_t v43 = v70;
      goto LABEL_51;
    }

uint64_t sub_1B538()
{
  return sub_50C94(&unk_6C150);
}

uint64_t sub_1B544(const char *a1, _DWORD *a2)
{
  uint64_t v3 = sub_19E70(a1, 0LL);
  if (!v3) {
    return 2LL;
  }
  uint64_t v4 = v3 + 24;
  uint64_t v5 = 0LL;
  while (1)
  {
    int v6 = *(_DWORD *)(sub_50C98(v4, v5) + 100);
    if (v6) {
      break;
    }
    uint64_t v5 = (v5 + 1);
  }

  uint64_t result = 0LL;
  *a2 = v6;
  return result;
}

uint64_t sub_1B5CC(const char *a1, int a2, vm_address_t *a3, _DWORD *a4)
{
  *a3 = 0LL;
  *a4 = 0;
  uint64_t v8 = 0LL;
  while (1)
  {
    uint64_t v9 = sub_50C98(qword_6C150, v8);
    uint64_t v10 = v9;
    if (*a1)
    {
      uint64_t v11 = (const char *)nullsub_1(*(void *)(v9 + 8));
      if (strcmp(v11, a1))
      {
        int v12 = 0;
        goto LABEL_16;
      }

      int v12 = 1;
    }

    else
    {
      int v12 = 0;
    }

    uint64_t v13 = v10 + 24;
LABEL_16:
    int v18 = sub_50C94(qword_6C150);
    if (!v12)
    {
      uint64_t v8 = (v8 + 1);
    }

    if (v12) {
      return 17LL;
    }
    else {
      return 2LL;
    }
  }

  uint64_t v14 = 0LL;
  while (1)
  {
    uint64_t v15 = sub_50C98(v13, v14);
    if ((*(_DWORD *)(v15 + 24) - 258) <= 2)
    {
      if (*(_DWORD *)(v15 + 40))
      {
        uint64_t v22 = 0LL;
        *(_OWORD *)&size[1] = 0u;
        __int128 v21 = 0u;
        sub_1B834(v15, 13LL, (uint64_t)&size[1]);
        if (size[3])
        {
          int v16 = sub_50DA0(v21, a2, size, 0LL);
          if (v16)
          {
            vm_address_t v17 = sub_1B990(v16, size[0], a4);
            *a3 = v17;
            if (v17) {
              return 0LL;
            }
          }
        }
      }
    }

    uint64_t v14 = (v14 + 1);
  }

uint64_t sub_1B758(const char *a1, vm_address_t *a2, _DWORD *a3)
{
  *a2 = 0LL;
  *a3 = 0;
  uint64_t v5 = sub_19E70(a1, 0LL);
  if (!v5) {
    return 2LL;
  }
  uint64_t v6 = v5 + 24;
  uint64_t v7 = 0LL;
  while (1)
  {
    uint64_t v8 = sub_50C98(v6, v7);
    if ((*(_DWORD *)(v8 + 24) - 258) <= 2)
    {
      if (*(_DWORD *)(v8 + 40))
      {
        uint64_t v13 = 0LL;
        *(_OWORD *)size = 0u;
        __int128 v12 = 0u;
        sub_1B834(v8, 13LL, (uint64_t)size);
        if (LODWORD(size[1]))
        {
          vm_address_t v9 = sub_1B990((const void *)size[0], SLODWORD(size[1]), a3);
          *a2 = v9;
          if (v9) {
            break;
          }
        }
      }
    }

    uint64_t v7 = (v7 + 1);
  }

  return 0LL;
}

uint64_t sub_1B834(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v6 = *(_DWORD *)(a1 + 24);
  uint64_t v7 = (void (*)(uint64_t, uint64_t, uint64_t))sub_204D4(v6);
  if (v7)
  {
    v7(a1, a2, a3);
    return 0LL;
  }

  else
  {
    uint64_t v9 = sub_57538();
    uint64_t v10 = _SC_syslog_os_log_mapping(5LL);
    if (__SC_log_enabled(5LL, v9, v10))
    {
      uint64_t v11 = _os_log_pack_size(14LL);
      __int128 v12 = (char *)v15 - ((__chkstk_darwin(v11) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v13 = __error();
      uint64_t v14 = _os_log_pack_fill( v12,  v11,  *v13,  &dword_0,  "config_method_event(%d): lookup_func(%d) failed",  v15[0],  v15[2]);
      *(_DWORD *)uint64_t v14 = 67109376;
      *(_DWORD *)(v14 + 4) = a2;
      *(_WORD *)(v14 + 8) = 1024;
      *(_DWORD *)(v14 + 10) = v6;
      __SC_log_send(5LL, v9, v10, v12);
    }

    return 6LL;
  }

vm_address_t sub_1B990(const void *a1, vm_size_t size, _DWORD *a3)
{
  *a3 = 0;
  if (vm_allocate(mach_task_self_, &address, size, 1)) {
    return 0LL;
  }
  memmove((void *)address, a1, size);
  *a3 = size;
  return address;
}

uint64_t sub_1BA08(const char *a1, vm_address_t *a2, _DWORD *a3)
{
  *a2 = 0LL;
  *a3 = 0;
  uint64_t v5 = sub_19E70(a1, 0LL);
  if (!v5) {
    return 2LL;
  }
  uint64_t v6 = v5 + 56;
  uint64_t v7 = 0LL;
  while (1)
  {
    uint64_t v8 = sub_50C98(v6, v7);
    if ((*(_DWORD *)(v8 + 24) & 0xFFFFFFFE) == 0x202)
    {
      if (*(_DWORD *)(v8 + 40))
      {
        __int128 v16 = 0u;
        __int128 v17 = 0u;
        __int128 v14 = 0u;
        __int128 v15 = 0u;
        __int128 v12 = 0u;
        __int128 v13 = 0u;
        *(_OWORD *)size = 0u;
        sub_1B834(v8, 14LL, (uint64_t)size);
        if (LODWORD(size[1]))
        {
          vm_address_t v9 = sub_1B990((const void *)size[0], SLODWORD(size[1]), a3);
          *a2 = v9;
          if (v9) {
            break;
          }
        }
      }
    }

    uint64_t v7 = (v7 + 1);
  }

  return 0LL;
}

uint64_t sub_1BAEC(const char *a1, const __CFData **a2, _DWORD *a3)
{
  *a2 = 0LL;
  *a3 = 0;
  uint64_t v5 = sub_19E70(a1, 0LL);
  if (!v5) {
    return 2LL;
  }
  uint64_t v6 = v5 + 56;
  uint64_t v7 = 0LL;
  uint64_t v8 = 17LL;
  do
  {
    uint64_t v9 = sub_50C98(v6, v7);
    if ((*(_DWORD *)(v9 + 24) & 0xFFFFFFFE) == 0x202)
    {
      if (*(_DWORD *)(v9 + 40))
      {
        __int128 v17 = 0u;
        __int128 v18 = 0u;
        __int128 v15 = 0u;
        __int128 v16 = 0u;
        __int128 v14 = 0u;
        memset(v13, 0, sizeof(v13));
        sub_1B834(v9, 14LL, (uint64_t)v13);
        if (*((void *)&v14 + 1))
        {
          CFDictionaryRef v10 = sub_52E54(*((uint64_t *)&v14 + 1));
          if (v10)
          {
            CFDictionaryRef v11 = v10;
            *a2 = sub_506B8(v10, a3);
            CFRelease(v11);
            if (*a2) {
              uint64_t v8 = 0LL;
            }
            else {
              uint64_t v8 = v8;
            }
          }
        }
      }
    }

    uint64_t v7 = (v7 + 1);
  }

  while ((int)v7 < (int)sub_50C94(v6));
  return v8;
}

uint64_t sub_1BBF4(const char *a1, uint64_t *a2)
{
  uint64_t v3 = sub_19E70(a1, 0LL);
  if (v3)
  {
    uint64_t v3 = (uint64_t)sub_1BC3C(v3);
    if (v3) {
      uint64_t v4 = 0LL;
    }
    else {
      uint64_t v4 = 17LL;
    }
  }

  else
  {
    uint64_t v4 = 2LL;
  }

  *a2 = v3;
  return v4;
}

__CFDictionary *sub_1BC3C(uint64_t a1)
{
  uint64_t v43 = *(void *)(a1 + 8);
  uint64_t v1 = a1 + 24;
  v49[0] = a1 + 24;
  v49[1] = a1 + 56;
  v49[2] = 0LL;
  v48[0] = kSCEntNetIPv4;
  v48[1] = kSCEntNetIPv6;
  theDict = CFDictionaryCreateMutable(0LL, 0LL, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  uint64_t v2 = 0LL;
  uint64_t v45 = (const __CFString *)kSCValNetIPv4ConfigMethodFailover;
  uint64_t v3 = (const void *)kIPConfigurationServiceOptionAPNName;
  uint64_t v4 = v49;
  do
  {
    uint64_t v46 = v2;
    CFAllocatorRef allocator = 0LL;
    int v5 = sub_50C94(v1);
    if (v5 >= 1)
    {
      int v6 = v5;
      uint64_t v7 = 0LL;
      do
      {
        uint64_t v8 = sub_50C98(*v4, v7);
        CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(0LL, 0LL, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
        CFDictionaryRef v10 = Mutable;
        int v11 = *(_DWORD *)(v8 + 24);
        switch(v11)
        {
          case 257:
            CFStringRef v12 = kSCValNetIPv4ConfigMethodManual;
            break;
          case 258:
            CFStringRef v12 = kSCValNetIPv4ConfigMethodBOOTP;
            break;
          case 259:
            CFStringRef v12 = kSCValNetIPv4ConfigMethodDHCP;
            break;
          case 260:
            CFStringRef v12 = kSCValNetIPv4ConfigMethodINFORM;
            break;
          case 261:
            CFStringRef v12 = kSCValNetIPv4ConfigMethodLinkLocal;
            break;
          case 262:
            CFStringRef v12 = v45;
            break;
          default:
            CFStringRef v12 = @"DHCPv6PD";
            switch(v11)
            {
              case 513:
                CFStringRef v12 = kSCValNetIPv6ConfigMethodManual;
                break;
              case 514:
                CFStringRef v12 = kSCValNetIPv6ConfigMethodAutomatic;
                break;
              case 515:
                CFStringRef v12 = kSCValNetIPv6ConfigMethodRouterAdvertisement;
                break;
              case 516:
                CFStringRef v12 = kSCValNetIPv6ConfigMethod6to4;
                break;
              case 517:
                CFStringRef v12 = kSCValNetIPv6ConfigMethodLinkLocal;
                break;
              case 518:
                goto LABEL_19;
              default:
                CFStringRef v12 = @"<unknown>";
                break;
            }

            break;
        }

LABEL_19:
        CFDictionarySetValue(Mutable, kSCPropNetIPv4ConfigMethod, v12);
        if (!*(_DWORD *)(v8 + 40) || (CFBooleanRef v13 = kCFBooleanTrue, *(_DWORD *)(v8 + 28))) {
          CFBooleanRef v13 = kCFBooleanFalse;
        }
        CFDictionarySetValue(v10, @"IsPublished", v13);
        if (*(_DWORD *)(v8 + 32)) {
          CFDictionarySetValue(v10, @"IsDynamic", kCFBooleanTrue);
        }
        uint64_t v14 = *(unsigned int *)(v8 + 28);
        if ((_DWORD)v14)
        {
          __int128 v15 = "<unknown>";
          CFStringRef v16 = CFStringCreateWithCString(0LL, v15, 0x600u);
          CFDictionarySetValue(v10, @"LastFailureStatus", v16);
          CFRelease(v16);
        }

        CFDictionarySetValue(v10, @"ServiceID", *(const void **)v8);
        __int128 v17 = *(const void **)(v8 + 56);
        if (v17)
        {
          __int128 v18 = v10;
          uint64_t v19 = @"ChildServiceID";
        }

        else
        {
          __int128 v17 = *(const void **)(v8 + 48);
          if (!v17) {
            goto LABEL_33;
          }
          __int128 v18 = v10;
          uint64_t v19 = @"ParentServiceID";
        }

        CFDictionarySetValue(v18, v19, v17);
LABEL_33:
        uint64_t v20 = (int *)(v8 + 88);
        if ((*(_BYTE *)(v8 + 25) & 1) != 0)
        {
          int v21 = *(_DWORD *)(v8 + 100);
          if (v21) {
            sub_4FFF4(v10, kSCPropNetIPv4Addresses, v21);
          }
          int v22 = *(_DWORD *)(v8 + 104);
          if (v22) {
            sub_4FFF4(v10, kSCPropNetIPv4SubnetMasks, v22);
          }
          if ((*(_BYTE *)(v8 + 25) & 1) != 0)
          {
            if (*(_DWORD *)(v8 + 100))
            {
              int v23 = *(_DWORD *)(v8 + 120);
              if (v23)
              {
                sub_500AC(v10, kSCPropNetIPv4Router, v23);
                if ((*(_DWORD *)(v8 + 116) & 4) != 0) {
                  CFBooleanRef v24 = kCFBooleanTrue;
                }
                else {
                  CFBooleanRef v24 = kCFBooleanFalse;
                }
                CFDictionarySetValue(v10, @"RouterARPVerified", v24);
              }
            }
          }

          if (*v20)
          {
            sub_500AC(v10, @"ManualAddress", *v20);
            int v25 = *(_DWORD *)(v8 + 92);
            if (v25) {
              sub_500AC(v10, @"ManualSubnetMask", v25);
            }
          }

          if ((*(_BYTE *)(v8 + 25) & 1) == 0) {
            goto LABEL_59;
          }
          int v26 = *(_DWORD *)(v8 + 116);
          if ((v26 & 8) == 0) {
            goto LABEL_57;
          }
          CFDictionarySetValue(v10, @"RouterARPInProgress", kCFBooleanTrue);
          if ((*(_BYTE *)(v8 + 25) & 1) != 0)
          {
            int v26 = *(_DWORD *)(v8 + 116);
LABEL_57:
            if ((v26 & 0x10) != 0) {
              CFDictionarySetValue(v10, @"RouterARPTimedOut", kCFBooleanTrue);
            }
          }
        }

        else if (*v20 || *(_DWORD *)(v8 + 92) || *(_DWORD *)(v8 + 96) || *(_DWORD *)(v8 + 100))
        {
          sub_50188(v10, @"ManualAddress", (void *)(v8 + 88));
          sub_502C4(v10, @"ManualPrefixLength", *(int *)(v8 + 104));
        }

  sub_4FA18((const void **)&v54);
  uint64_t v56 = 0LL;
  CFStringRef v37 = sub_23CA8(v1, (__CFArray **)&v56);
  thePortRef[0] = v37;
  if (!v37) {
    goto LABEL_34;
  }
  uint64_t v38 = v37;
  uint64_t v39 = 0;
  uint64_t v40 = 0;
  do
  {
    uint64_t v41 = (_OWORD *)sub_53FC8(qword_6C188, v40);
    uint64_t v42 = (const char *)nullsub_1(v41);
    uint64_t v43 = CFStringCreateWithCString(0LL, v42, 0x600u);
    if (v43)
    {
      uint64_t v44 = v43;
      CFIndex Count = CFArrayGetCount(v38);
      if (Count >= 1)
      {
        uint64_t v46 = Count;
        uint64_t v47 = 0LL;
        while (1)
        {
          ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(v38, v47);
          uint64_t v49 = CFDictionaryGetValue(ValueAtIndex, kSCPropNetInterfaceDeviceName);
          if (CFEqual(v49, v44)) {
            break;
          }
          if (v46 == ++v47) {
            goto LABEL_30;
          }
        }

        if (ValueAtIndex)
        {
          sub_1C654(v41);
          ++v39;
        }
      }

    sub_4FA18((const void **)&v17);
    sub_4FA18(&v16);
    __int128 v17 = Value;
    if (byte_6C180 == 1)
    {
      byte_6C180 = 0;
      sub_27098(Value);
    }

    if (byte_6C19C == 1)
    {
      byte_6C19C = 0;
      sub_2737C(Value);
    }

    sub_4FA18((const void **)&v17);
  }

  if (byte_6C1A4 == 1)
  {
    byte_6C1A4 = 0;
    sub_27808();
  }

  if (byte_6C1A0 == 1)
  {
    byte_6C1A0 = 0;
    sub_279A8();
  }

  sub_377E4((SCDynamicStoreRef)qword_6C178);
}

    IOAllowPowerChange(dword_6C1E8, notificationID);
  }

      free(v3);
      return v16;
    }

    CFStringRef v16 = 0LL;
    if (!v3) {
      return v16;
    }
    goto LABEL_19;
  }

  CFBooleanRef v13 = __stderrp;
  uint64_t v14 = __error();
  __int128 v15 = strerror(*v14);
  fprintf(v13, "sysctl() size failed: %s", v15);
  return 0LL;
}

LABEL_59:
        uint64_t v27 = *(const void **)(v8 + 8);
        if (v27) {
          CFDictionarySetValue(v10, v3, v27);
        }
        sub_1B834(v8, 22LL, (uint64_t)v10);
        if (v10)
        {
          uint64_t v28 = allocator;
          if (!allocator)
          {
            uint64_t v28 = CFArrayCreateMutable(0LL, 0LL, &kCFTypeArrayCallBacks);
            CFAllocatorRef allocator = v28;
          }

          CFArrayAppendValue(v28, v10);
          CFRelease(v10);
        }

        uint64_t v7 = (v7 + 1);
      }

      while (v6 != (_DWORD)v7);
    }

    if (allocator)
    {
      CFDictionarySetValue(theDict, (const void *)v48[v46], allocator);
      sub_4FA18((const void **)&allocator);
    }

    uint64_t v29 = v4[1];
    ++v4;
    uint64_t v1 = v29;
    uint64_t v2 = v46 + 1;
  }

  while (v29);
  unint64_t v30 = sub_54F74(v43);
  if ((_DWORD)v30)
  {
    if (!HIDWORD(v30))
    {
      CFStringRef v31 = kSCPropNetLinkActive;
      uint64_t v32 = theDict;
      CFBooleanRef v33 = kCFBooleanFalse;
      goto LABEL_76;
    }

    uint64_t v34 = *(void *)(a1 + 96);
    CFDictionarySetValue(theDict, @"LinkStatusActive", kCFBooleanTrue);
    if (sub_54E84(v43))
    {
      if (v34)
      {
        int v35 = sub_2A628(v34);
        uint64_t v36 = (char *)sub_29CEC(v35);
        sub_50228(theDict, @"Security", v36);
        CFStringRef v37 = sub_2A5A4(v34);
        CFDictionarySetValue(theDict, @"BSSID", v37);
        uint64_t v38 = (const void *)sub_2A59C(v34);
        CFDictionarySetValue(theDict, @"SSID", v38);
        uint64_t v39 = sub_2A630(v34);
        if (v39)
        {
          CFBooleanRef v33 = (CFBooleanRef)v39;
          CFStringRef v31 = @"NetworkID";
          uint64_t v32 = theDict;
LABEL_76:
          CFDictionarySetValue(v32, v31, v33);
        }
      }
    }
  }

  uint64_t v40 = (char *)sub_54EC0(v43);
  if (v40) {
    sub_50228(theDict, @"InterfaceType", v40);
  }
  return theDict;
}

      sub_4FA18(&v87);
    }
  }

            CFRelease(v29);
            timer_callout_set_absolute(*(void *)(v8 + 8), (uint64_t)sub_3D668, (uint64_t)a1, 2LL, 0LL, v26);
            return;
          }
        }
      }

      return;
    }

    if (a2) {
      return;
    }
    sub_3B908((uint64_t)a1, 2u);
    timer_cancel(*(void *)(v8 + 8));
    sub_4C6AC(*(void **)v8, (uint64_t)sub_3D668, (uint64_t)a1, 5LL);
  }

  uint64_t v9 = nullsub_1(v6);
  sub_3DD10(v9, (uint64_t)a3);
  int v11 = (uint64_t *)(v8 + 16);
  CFDictionaryRef v10 = *(void *)(v8 + 16);
  if (v10)
  {
    CFStringRef v12 = (void *)sub_51AB4(v10);
    CFBooleanRef v13 = (void *)sub_51AB4((uint64_t)a3);
    if (*v12 != *v13 || v12[1] != v13[1])
    {
      __int128 v15 = sub_57538();
      CFStringRef v16 = _SC_syslog_os_log_mapping(6LL);
      if (__SC_log_enabled(6LL, v15, v16))
      {
        __int128 v17 = _os_log_pack_size(22LL);
        __int128 v18 = (char *)&v61 - ((__chkstk_darwin(v17) + 15) & 0xFFFFFFFFFFFFFFF0LL);
        uint64_t v19 = __error();
        uint64_t v20 = _os_log_pack_fill(v18, v17, *v19, &dword_0, "RTADV %s: ignoring RA (not from %@)");
        int v21 = nullsub_1(v6);
        int v22 = sub_4E340(*v11);
        *(_DWORD *)uint64_t v20 = 136315394;
        *(void *)(v20 + 4) = v21;
        *(_WORD *)(v20 + 12) = 2112;
        *(void *)(v20 + 14) = v22;
        __SC_log_send(6LL, v15, v16, v18);
      }

      return;
    }
  }

  else if (!sub_5261C((uint64_t)a3))
  {
    *(_DWORD *)(v8 + 80) = 1;
    uint64_t v45 = sub_57538();
    uint64_t v46 = _SC_syslog_os_log_mapping(6LL);
    if (__SC_log_enabled(6LL, v45, v46))
    {
      uint64_t v47 = _os_log_pack_size(12LL);
      uint64_t v48 = (char *)&v61 - ((__chkstk_darwin(v47) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v49 = __error();
      uint64_t v50 = _os_log_pack_fill(v48, v47, *v49, &dword_0, "RTADV %s: ignoring RA (lifetime zero)", v61);
      uint64_t v51 = nullsub_1(v6);
      *(_DWORD *)uint64_t v50 = 136315138;
      *(void *)(v50 + 4) = v51;
      __SC_log_send(6LL, v45, v46, v48);
    }

    return;
  }

  timer_cancel(*(void *)(v8 + 8));
  sub_4FA18((const void **)(v8 + 16));
  if (sub_5261C((uint64_t)a3))
  {
    CFRetain(a3);
    *int v11 = (uint64_t)a3;
  }

  else
  {
    uint64_t v36 = sub_57538();
    CFStringRef v37 = _SC_syslog_os_log_mapping(5LL);
    if (__SC_log_enabled(5LL, v36, v37))
    {
      uint64_t v38 = _os_log_pack_size(12LL);
      uint64_t v39 = (char *)&v61 - ((__chkstk_darwin(v38) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v40 = __error();
      uint64_t v41 = _os_log_pack_fill(v39, v38, *v40, &dword_0, "RTADV %s: router lifetime became zero", v61);
      uint64_t v42 = nullsub_1(v6);
      *(_DWORD *)uint64_t v41 = 136315138;
      *(void *)(v41 + 4) = v42;
      __SC_log_send(5LL, v36, v37, v39);
    }
  }

  uint64_t v43 = *(void *)(v8 + 24);
  if (v43)
  {
    if (*v11 && (uint64_t v44 = sub_52614(*v11), v43 = *(void *)(v8 + 24), v44 >= 0x40))
    {
      if ((v44 & 0x80u) == 0) {
        CFTypeID v52 = 1;
      }
      else {
        CFTypeID v52 = 2;
      }
      if (sub_3FCFC(v43) != v52)
      {
        CFTypeID v53 = sub_19C34((uint64_t)a1, 0LL) != 0;
        sub_404E4(*(void *)(v8 + 24));
        sub_3F84C(*(void *)(v8 + 24), v53);
        sub_403F8(*(void *)(v8 + 24), v52);
        sub_3FE64(*(void *)(v8 + 24));
      }
    }

    else if (sub_3F9FC(v43))
    {
      sub_404E4(*(void *)(v8 + 24));
    }
  }

  if (*v11)
  {
    uint64_t v54 = sub_51A70(*v11);
    int v26 = sub_52B24(*v11, 0LL, 0LL, v54);
  }

  else
  {
    int v26 = 0.0;
  }

  sub_3B790(a1);
  if (*v11) {
    sub_3DE40(a1);
  }
  if (sub_4E330(v8 + 104))
  {
    uint64_t v55 = sub_4E7B8(v8 + 104);
    if (v55 < v26 && v55 != 0.0) {
      int v26 = v55;
    }
  }

  if (v26 != 0.0)
  {
    uint64_t v29 = CFDateCreate(0LL, v26);
    unint64_t v30 = sub_57538();
    CFStringRef v31 = _SC_syslog_os_log_mapping(6LL);
    if (__SC_log_enabled(6LL, v30, v31))
    {
      uint64_t v57 = _os_log_pack_size(22LL);
      CFBooleanRef v33 = (char *)&v61 - ((__chkstk_darwin(v57) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      int v58 = *__error();
      int v35 = _os_log_pack_fill(v33, v57, v58, &dword_0, "RTADV %s: DNS expiration time %@");
      goto LABEL_58;
    }

    goto LABEL_59;
  }

uint64_t sub_1C2EC(__CFArray **a1)
{
  if ((int)sub_50C94(&unk_6C150) < 1)
  {
    CFMutableDictionaryRef Mutable = 0LL;
  }

  else
  {
    uint64_t v2 = 0LL;
    CFMutableDictionaryRef Mutable = 0LL;
    do
    {
      uint64_t v4 = sub_50C98(&unk_6C150, v2);
      if (sub_50C94(v4 + 24) || sub_50C94(v4 + 56))
      {
        if (!Mutable) {
          CFMutableDictionaryRef Mutable = CFArrayCreateMutable(0LL, 0LL, &kCFTypeArrayCallBacks);
        }
        CFArrayAppendValue(Mutable, *(const void **)(v4 + 16));
      }

      uint64_t v2 = (v2 + 1);
    }

    while ((int)v2 < (int)sub_50C94(&unk_6C150));
  }

  *a1 = Mutable;
  return 0LL;
}

uint64_t sub_1C3B4(vm_address_t *a1, _DWORD *a2)
{
  uint64_t v4 = (const __CFData *)sub_4B5E8();
  if (!v4) {
    return 17LL;
  }
  int v5 = v4;
  BytePtr = CFDataGetBytePtr(v4);
  vm_size_t Length = CFDataGetLength(v5);
  vm_address_t v8 = sub_1B990(BytePtr, Length, a2);
  *a1 = v8;
  if (v8) {
    return 0LL;
  }
  else {
    return 5LL;
  }
}

uint64_t sub_1C420(char *a1, _DWORD *a2)
{
  uint64_t v4 = sub_19E70(a1, 0LL);
  if (!v4) {
    return 2LL;
  }
  int v5 = sub_4BFE8(a1);
  uint64_t result = 0LL;
  *a2 = v5;
  return result;
}

uint64_t sub_1C488(char *__s2, int *a2)
{
  uint64_t v4 = (_OWORD *)sub_540BC((uint64_t *)qword_6C188, __s2);
  int v5 = *a2;
  uint64_t v6 = sub_57538();
  uint64_t v7 = _SC_syslog_os_log_mapping(6LL);
  if (__SC_log_enabled(6LL, v6, v7))
  {
    uint64_t v8 = _os_log_pack_size(22LL);
    uint64_t v9 = (char *)v16 - ((__chkstk_darwin(v8) + 15) & 0xFFFFFFFFFFFFFFF0LL);
    CFDictionaryRef v10 = __error();
    uint64_t v11 = _os_log_pack_fill(v9, v8, *v10, &dword_0, "set %s %s", v16[0], v16[1]);
    CFStringRef v12 = sub_14420(v5);
    *(_DWORD *)uint64_t v11 = 136315394;
    *(void *)(v11 + 4) = __s2;
    *(_WORD *)(v11 + 12) = 2080;
    *(void *)(v11 + 14) = v12;
    __SC_log_send(6LL, v6, v7, v9);
  }

  if (!v4) {
    return 2LL;
  }
  uint64_t v13 = sub_1C654(v4);
  if (!v13) {
    return 5LL;
  }
  uint64_t v14 = v13;
  if ((v5 & 0xFFFFFEFF) == 0 || (v5 & 0x100) != 0) {
    sub_1C6A8(v13, 1);
  }
  else {
    sub_1C70C(v13, 1);
  }
  uint64_t result = 0LL;
  if (v5 && v5 != 256 && v5 != 512) {
    return sub_1C770(v14, 0LL, (uint64_t)a2, 0LL, 0LL, 0LL);
  }
  return result;
}

uint64_t sub_1C654(_OWORD *a1)
{
  uint64_t v2 = (const char *)nullsub_1(a1);
  uint64_t v3 = sub_19E70(v2, 0LL);
  if (!v3)
  {
    uint64_t v3 = sub_205C4(a1);
    if (v3) {
      sub_53DA4(qword_6C150, v3);
    }
  }

  return v3;
}

void sub_1C6A8(uint64_t a1, int a2)
{
  uint64_t v4 = (uint64_t *)(a1 + 24);
  int v5 = sub_50C94(a1 + 24);
  if (a2)
  {
    DHCPLeaseListFree_0(v4);
    if (!v5) {
      return;
    }
    goto LABEL_3;
  }

  sub_20EB8(v4);
  if (v5) {
LABEL_3:
  }
    sub_154B0(a1);
}

void sub_1C70C(uint64_t a1, int a2)
{
  uint64_t v4 = (uint64_t *)(a1 + 56);
  int v5 = sub_50C94(a1 + 56);
  if (a2)
  {
    DHCPLeaseListFree_0(v4);
    if (!v5) {
      return;
    }
    goto LABEL_3;
  }

  sub_20EB8(v4);
  if (v5) {
LABEL_3:
  }
    sub_20F24(a1);
}

uint64_t sub_1C770(uint64_t a1, const char **a2, uint64_t a3, CFTypeRef *a4, uint64_t a5, char **a6)
{
  uint64_t v6 = a6;
  uint64_t v12 = *(void *)(a1 + 8);
  uint64_t v13 = &off_6C000;
  int v65 = *(_DWORD *)a3;
  if ((v65 & 0x100) != 0)
  {
    if (a4 || !dword_6C0C0 || !*(_DWORD *)(a1 + 156) || !*(_DWORD *)(a1 + 160))
    {
      CFStringRef v37 = (const char *)nullsub_1(v12);
      sub_31F94(v37, 1);
      goto LABEL_22;
    }
  }

  else
  {
    if (*(_DWORD *)(a3 + 32))
    {
      uint64_t v64 = a6;
      uint64_t v14 = sub_57538();
      uint64_t v15 = _SC_syslog_os_log_mapping(6LL);
      if (__SC_log_enabled(6LL, v14, v15))
      {
        uint64_t v16 = a5;
        __int128 v17 = a2;
        uint64_t v18 = _os_log_pack_size(12LL);
        uint64_t v63 = &v61;
        uint64_t v19 = (char *)&v61 - ((__chkstk_darwin(v18) + 15) & 0xFFFFFFFFFFFFFFF0LL);
        uint64_t v20 = __error();
        uint64_t v21 = _os_log_pack_fill(v19, v18, *v20, &dword_0, "%s: CGA is disabled\n", v61);
        uint64_t v22 = nullsub_1(v12);
        *(_DWORD *)uint64_t v21 = 136315138;
        *(void *)(v21 + 4) = v22;
        a2 = v17;
        a5 = v16;
        int v23 = v19;
        uint64_t v13 = &off_6C000;
        __SC_log_send(6LL, v14, v15, v23);
      }

      *(_DWORD *)a1 |= 0x10000u;
      uint64_t v6 = v64;
    }

    if (*(unsigned __int8 *)(a3 + 36) == 254 && (*(_BYTE *)(a3 + 37) & 0xC0) == 0x80)
    {
      *(_OWORD *)(a1 + 120) = *(_OWORD *)(a3 + 36);
      CFBooleanRef v24 = (const char *)sub_57538();
      uint64_t v25 = _SC_syslog_os_log_mapping(6LL);
      LODWORD(v64) = v25;
      if (__SC_log_enabled(6LL, v24, v25))
      {
        uint64_t v26 = _os_log_pack_size(22LL);
        uint64_t v63 = a2;
        uint64_t v27 = v26;
        int v62 = (const char *)&v61;
        uint64_t v28 = (char *)&v61 - ((__chkstk_darwin(v26) + 15) & 0xFFFFFFFFFFFFFFF0LL);
        uint64_t v29 = __error();
        uint64_t v30 = _os_log_pack_fill( v28,  v27,  *v29,  &dword_0,  "%s: link-local IPv6 address specified %s",  v61,  v62);
        uint64_t v31 = nullsub_1(v12);
        uint64_t v61 = v24;
        uint64_t v32 = v6;
        uint64_t v33 = v31;
        uint64_t v34 = inet_ntop(30, (const void *)(a3 + 36), v66, 0x2Eu);
        *(_DWORD *)uint64_t v30 = 136315394;
        *(void *)(v30 + 4) = v33;
        uint64_t v6 = v32;
        *(_WORD *)(v30 + 12) = 2080;
        *(void *)(v30 + 14) = v34;
        a2 = v63;
        int v35 = v28;
        uint64_t v13 = &off_6C000;
        __SC_log_send(6LL, v61, v64, v35);
      }
    }

    if (a4 || !*((_DWORD *)v13 + 48) || !*(_DWORD *)(a1 + 156) || !*(_DWORD *)(a1 + 160))
    {
      sub_20FA4(a1, 1);
      goto LABEL_22;
    }
  }

  if (!*(_DWORD *)(a1 + 152))
  {
    *(_DWORD *)(a1 + 152) = 1;
    uint64_t v36 = (const char *)nullsub_1(v12);
    sub_31A94(v36, 0);
  }

LABEL_22:
  int v38 = *(_DWORD *)a3;
  if (*(_DWORD *)a3 == 261)
  {
    uint64_t v39 = *(void *)(a1 + 88);
    if (v39) {
      sub_210C0(a1, *(const void **)v39, (*(_DWORD *)(v39 + 24) >> 8) & 1);
    }
  }

  uint64_t v40 = (char *)malloc(0xA8uLL);
  if (!v40)
  {
    uint64_t v43 = 5LL;
    int v44 = v65;
    goto LABEL_38;
  }

  uint64_t v41 = v40;
  *(_OWORD *)(v40 + 24) = 0u;
  *(_OWORD *)(v40 + 8) = 0u;
  *(_OWORD *)(v40 + 152) = 0u;
  *(_OWORD *)(v40 + 136) = 0u;
  *(_OWORD *)(v40 + 120) = 0u;
  *(_OWORD *)(v40 + 104) = 0u;
  *(_OWORD *)(v40 + 88) = 0u;
  *(_OWORD *)(v40 + 72) = 0u;
  *(_OWORD *)(v40 + 56) = 0u;
  *(_OWORD *)(v40 + 40) = 0u;
  *((_DWORD *)v40 + 6) = v38;
  *((void *)v40 + 2) = a1;
  if (a2)
  {
    uint64_t v42 = (void *)CFRetain(a2);
  }

  else
  {
    uint64_t v45 = sub_14420(v38);
    uint64_t v46 = nullsub_1(*(void *)(a1 + 8));
    uint64_t v42 = (void *)CFStringCreateWithFormat(0LL, 0LL, @"%s-%s", v45, v46);
  }

  *(void *)uint64_t v41 = v42;
  int v44 = v65;
  if (a4) {
    *((void *)v41 + 6) = CFRetain(*a4);
  }
  uint64_t v47 = a1;
  if (a5)
  {
    (*(void (**)(uint64_t, char *))(a5 + 16))(a5, v41);
    uint64_t v47 = *((void *)v41 + 2);
  }

  int v48 = *(_DWORD *)a3;
  int v49 = sub_54E20(*(void *)(v47 + 8));
  if (v48 == 516 && v49 != 57) {
    goto LABEL_36;
  }
  if (v49 > 134)
  {
    if (v49 == 144)
    {
      if (v48 == 258) {
        goto LABEL_36;
      }
LABEL_56:
      uint64_t v59 = (uint64_t (*)(char *, void, uint64_t))sub_204D4(v48);
      if (v59)
      {
        uint64_t v43 = v59(v41, 0LL, a3 + 8);
        if (!(_DWORD)v43)
        {
          if (a4)
          {
            sub_4FA18(a4 + 7);
            a4[7] = CFRetain(*(CFTypeRef *)v41);
          }

          if (*((_DWORD *)v41 + 6) == 261) {
            *(void *)(a1 + 88) = v41;
          }
          if ((v44 & 0x100) != 0) {
            uint64_t v60 = a1 + 24;
          }
          else {
            uint64_t v60 = a1 + 56;
          }
          sub_53DA4(v60, v41);
          uint64_t v43 = 0LL;
          if (v6) {
            goto LABEL_53;
          }
          return v43;
        }
      }

      else
      {
        uint64_t v43 = 7LL;
      }

      goto LABEL_37;
    }

LABEL_71:
    goto LABEL_56;
  }

  if (v49 == 6) {
    goto LABEL_56;
  }
  if (v49 == 24)
  {
    if (v48 != 257 && v48 != 513) {
      goto LABEL_36;
    }
    goto LABEL_56;
  }

  if (v49 != 57) {
    goto LABEL_71;
  }
  if (v48 == 516) {
    goto LABEL_56;
  }
LABEL_36:
  uint64_t v43 = 4LL;
LABEL_37:
  sub_4FA18((const void **)v41);
  sub_4FA18((const void **)v41 + 6);
  free(v41);
LABEL_38:
  uint64_t v50 = sub_57538();
  uint64_t v51 = _SC_syslog_os_log_mapping(6LL);
  if (__SC_log_enabled(6LL, v50, v51))
  {
    uint64_t v52 = _os_log_pack_size(22LL);
    CFTypeID v53 = (char *)&v61 - ((__chkstk_darwin(v52) + 15) & 0xFFFFFFFFFFFFFFF0LL);
    uint64_t v54 = __error();
    uint64_t v55 = _os_log_pack_fill(v53, v52, *v54, &dword_0, "status from %s was %s", v61, v62);
    uint64_t v56 = sub_14420(v44);
    else {
      uint64_t v57 = "<unknown>";
    }
    *(_DWORD *)uint64_t v55 = 136315394;
    *(void *)(v55 + 4) = v56;
    *(_WORD *)(v55 + 12) = 2080;
    *(void *)(v55 + 14) = v57;
    __SC_log_send(6LL, v50, v51, v53);
  }

  if ((v44 & 0x100) != 0) {
    sub_154B0(a1);
  }
  else {
    sub_20F24(a1);
  }
  sub_2037C();
  uint64_t v41 = 0LL;
  if (v6) {
LABEL_53:
  }
    *uint64_t v6 = v41;
  return v43;
}

      if (v82 < 1)
      {
        int v68 = 0;
        int v67 = 0LL;
        uint64_t v69 = 0LL;
      }

      else
      {
        int v67 = (unint64_t)(v81 & 2) << 31;
        if ((v81 & 1) != 0) {
          int v68 = (v81 >> 2) & 1;
        }
        else {
          int v68 = 0;
        }
        if ((v81 & 1) == 0) {
          int v67 = 0LL;
        }
        uint64_t v69 = 1LL;
        if ((v81 & 1) == 0) {
          uint64_t v69 = 0LL;
        }
      }

      *(void *)(v20 + 80) = v69 | v67;
      *(_DWORD *)(v20 + 88) = v68;
    }

uint64_t sub_1CDA8(char *a1, int *a2, uint64_t a3, const __CFDictionary *a4, int a5)
{
  return sub_1CDBC(a1, a2, 1, a3, a4, a5);
}

uint64_t sub_1CDBC(char *__s2, int *a2, int a3, uint64_t a4, const __CFDictionary *Value, int a6)
{
  uint64_t v12 = (_OWORD *)sub_540BC((uint64_t *)qword_6C188, __s2);
  int v13 = *a2;
  uint64_t v14 = 3LL;
  if (!*a2 || v13 == 256 || v13 == 512) {
    return v14;
  }
  uint64_t v15 = (uint64_t)v12;
  if (!v12) {
    return 2LL;
  }
  uint64_t v16 = sub_1C654(v12);
  if (!v16) {
    return 5LL;
  }
  __int128 v17 = (_DWORD *)v16;
  uint64_t v18 = (char *)sub_1D774(v16, a2, 0);
  uint64_t v75 = v18;
  if (v18)
  {
    int v74 = 0;
    if ((a3 & 1) != 0) {
      return 15LL;
    }
    uint64_t v19 = v18;
    int v20 = sub_181A0((uint64_t)v18, (unsigned int *)a2, &v74);
    if (!(v20 | v74)) {
      return 0LL;
    }
    sub_210C0((uint64_t)v17, *(const void **)v19, (*((_DWORD *)v19 + 6) >> 8) & 1);
  }

  int v21 = sub_54228(v15);
  BOOL v65 = v21 == 255;
  uint64_t v69 = v17;
  if (!Value)
  {
    int v29 = 0;
    uint64_t v59 = 0LL;
    int v64 = 1;
    int v66 = 0;
    int v67 = -1;
    HIDWORD(v60) = -1;
    int v62 = 0;
    int v63 = 1;
    BOOL v26 = 1;
    goto LABEL_33;
  }

  int v22 = v21;
  Value = (const __CFDictionary *)CFDictionaryGetValue(Value, @"__IPConfigurationServiceOptions");
  CFTypeID TypeID = CFDictionaryGetTypeID();
  if (!Value)
  {
LABEL_24:
    int v29 = 0;
    uint64_t v59 = 0LL;
    int v64 = 1;
    int v66 = 0;
    int v67 = -1;
    HIDWORD(v60) = -1;
    int v62 = 0;
    int v63 = 1;
    BOOL v26 = 1;
    __int128 v17 = v69;
    goto LABEL_33;
  }

  if (CFGetTypeID(Value) != TypeID)
  {
    Value = 0LL;
    goto LABEL_24;
  }

  LODWORD(v68) = v22 != 255;
  else {
    int v24 = -1;
  }
  HIDWORD(v60) = v24;
  LODWORD(v61) = sub_21174(Value, @"NoPublish", 0LL);
  int v67 = sub_211CC(Value, kIPConfigurationServiceOptionMTU, 0xFFFFFFFFLL);
  int v64 = sub_21174(Value, kIPConfigurationServiceOptionPerformNUD, 1LL);
  int v63 = sub_21174(Value, kIPConfigurationServiceOptionEnableDAD, 1LL);
  uint64_t v25 = (const void *)kIPConfigurationServiceOptionEnableCLAT46;
  int v66 = sub_21174(Value, kIPConfigurationServiceOptionEnableCLAT46, 0LL);
  BOOL v26 = CFDictionaryContainsKey(Value, v25) == 0;
  BOOL v65 = sub_21174(Value, kIPConfigurationServiceOptionEnableDHCPv6, v68) == 0;
  uint64_t v27 = CFDictionaryGetValue(Value, @"ServiceID");
  CFTypeID v28 = CFStringGetTypeID();
  if (v27 && CFGetTypeID(v27) == v28) {
    int v68 = (const char **)CFRetain(v27);
  }
  else {
    int v68 = 0LL;
  }
  int v29 = (int)v61;
  int v62 = sub_21174(Value, kIPConfigurationServiceOptionClearState, 0LL);
  uint64_t v30 = (const char *)CFDictionaryGetValue(Value, kIPConfigurationServiceOptionAPNName);
  CFTypeID v31 = CFStringGetTypeID();
  if (v30)
  {
    if (CFGetTypeID(v30) == v31) {
      uint64_t v32 = v30;
    }
    else {
      uint64_t v32 = 0LL;
    }
    uint64_t v59 = v32;
  }

  else
  {
    uint64_t v59 = 0LL;
  }

  Value = (const __CFDictionary *)v68;
  __int128 v17 = v69;
LABEL_33:
  if (v26 && dword_6C1AC && sub_54228(v15) == 255 && v29)
  {
    int v68 = (const char **)Value;
    uint64_t v33 = sub_57538();
    uint64_t v34 = _SC_syslog_os_log_mapping(6LL);
    if (__SC_log_enabled(6LL, v33, v34))
    {
      uint64_t v35 = _os_log_pack_size(12LL);
      uint64_t v61 = &v59;
      uint64_t v36 = (char *)&v59 - ((__chkstk_darwin(v35) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      CFStringRef v37 = __error();
      uint64_t v38 = v35;
      __int128 v17 = v69;
      uint64_t v39 = _os_log_pack_fill(v36, v38, *v37, &dword_0, "[DEBUG] auto-enabling clat46 on %s", v59);
      *(_DWORD *)uint64_t v39 = 136315138;
      *(void *)(v39 + 4) = __s2;
      __SC_log_send(6LL, v33, v34, v36);
    }

    int v66 = 1;
    Value = (const __CFDictionary *)v68;
  }

  if (!Value)
  {
    Value = (const __CFDictionary *)sub_505AC(0LL);
    if (!Value) {
      return 5LL;
    }
  }

  int v68 = (const char **)Value;
  uint64_t v40 = sub_57538();
  uint64_t v41 = _SC_syslog_os_log_mapping(6LL);
  if (__SC_log_enabled(6LL, v40, v41))
  {
    uint64_t v42 = _os_log_pack_size(32LL);
    LODWORD(v61) = v29;
    uint64_t v43 = (char *)&v59 - ((__chkstk_darwin(v42) + 15) & 0xFFFFFFFFFFFFFFF0LL);
    int v44 = __error();
    uint64_t v45 = _os_log_pack_fill(v43, v42, *v44, &dword_0, "%s %s %s", v59, v60, (const char *)v61);
    if (a3) {
      uint64_t v46 = "add_service";
    }
    else {
      uint64_t v46 = "set_service";
    }
    uint64_t v47 = sub_14420(v13);
    *(_DWORD *)uint64_t v45 = 136315650;
    *(void *)(v45 + 4) = v46;
    *(_WORD *)(v45 + 12) = 2080;
    *(void *)(v45 + 14) = __s2;
    *(_WORD *)(v45 + 22) = 2080;
    *(void *)(v45 + 24) = v47;
    __int128 v17 = v69;
    __SC_log_send(6LL, v40, v41, v43);
    int v29 = (int)v61;
  }

  int v48 = v67;
  if (v67 >= 1)
  {
    uint64_t v49 = sub_57538();
    uint64_t v50 = _SC_syslog_os_log_mapping(6LL);
    if (__SC_log_enabled(6LL, v49, v50))
    {
      uint64_t v51 = _os_log_pack_size(18LL);
      uint64_t v52 = (char *)&v59 - ((__chkstk_darwin(v51) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      CFTypeID v53 = __error();
      uint64_t v54 = v51;
      __int128 v17 = v69;
      uint64_t v55 = _os_log_pack_fill(v52, v54, *v53, &dword_0, "set interface %s mtu to %d", v59, (_DWORD)v60);
      *(_DWORD *)uint64_t v55 = 136315394;
      *(void *)(v55 + 4) = __s2;
      *(_WORD *)(v55 + 12) = 1024;
      *(_DWORD *)(v55 + 14) = v67;
      uint64_t v56 = v52;
      int v48 = v67;
      __SC_log_send(6LL, v49, v50, v56);
    }

    sub_318D4(__s2, v48);
  }

  *__int128 v17 = *v17 & 0xFFE1FFFF | ((v64 == 0) << 17) | ((v63 == 0) << 18);
  if ((v13 & 0x200) != 0 && v62) {
    sub_20F24((uint64_t)v17);
  }
  v70[0] = _NSConcreteStackBlock;
  v70[1] = 0x40000000LL;
  v70[2] = sub_21240;
  v70[3] = &unk_64D90;
  int v71 = v29;
  BOOL v72 = v65;
  int v73 = v66;
  uint64_t v57 = (const __CFString *)v68;
  uint64_t v14 = sub_1C770((uint64_t)v17, v68, (uint64_t)a2, 0LL, (uint64_t)v70, &v75);
  if (!(_DWORD)v14)
  {
    if (v59) {
      sub_20E7C((uint64_t)v75, v59);
    }
    if (HIDWORD(v60) != -1) {
      sub_21270((uint64_t)v75, SHIDWORD(v60));
    }
    *(_OWORD *)(a4 + 96) = 0u;
    *(_OWORD *)(a4 + 112) = 0u;
    *(_OWORD *)(a4 + 64) = 0u;
    *(_OWORD *)(a4 + 80) = 0u;
    *(_OWORD *)(a4 + 32) = 0u;
    *(_OWORD *)(a4 + 48) = 0u;
    *(_OWORD *)a4 = 0u;
    *(_OWORD *)(a4 + 16) = 0u;
    sub_4FC44(v57, (UInt8 *)a4, 128, 0);
  }

  CFRelease(v57);
  return v14;
}

uint64_t sub_1D50C(char *a1, int *a2, uint64_t a3)
{
  return sub_1CDBC(a1, a2, 0, a3, 0LL, -1);
}

uint64_t sub_1D520(const char *a1, const char *a2)
{
  CFStringRef v3 = CFStringCreateWithCString(0LL, a2, 0x8000100u);
  if (!v3) {
    return 5LL;
  }
  CFStringRef v4 = v3;
  uint64_t v5 = sub_1D578(a1, v3);
  CFRelease(v4);
  return v5;
}

uint64_t sub_1D578(const char *a1, const void *a2)
{
  if (!a1)
  {
    uint64_t v3 = sub_21634(a2, &v5, 0);
    if (!v3)
    {
      uint64_t v3 = sub_21634(a2, &v5, 1);
      if (!v3) {
        return 14LL;
      }
    }

    return sub_1D91C(v3, (uint64_t)v5);
  }

  uint64_t v3 = sub_1DC2C(a1, a2, (uint64_t *)&v5);
  if (v3) {
    return sub_1D91C(v3, (uint64_t)v5);
  }
  return 14LL;
}

uint64_t sub_1D5EC(const char *a1, int a2, int *a3, uint64_t a4)
{
  int v5 = *a3;
  uint64_t result = 3LL;
  if (*a3 && v5 != 256 && v5 != 512)
  {
    uint64_t v10 = sub_19E70(a1, 0LL);
    if (v10)
    {
      if (a2)
      {
        uint64_t v11 = (const __CFString **)sub_1D6A0(v10, a3);
        if (v11)
        {
LABEL_7:
          uint64_t v12 = *v11;
          *(_OWORD *)(a4 + 96) = 0u;
          *(_OWORD *)(a4 + 112) = 0u;
          *(_OWORD *)(a4 + 64) = 0u;
          *(_OWORD *)(a4 + 80) = 0u;
          *(_OWORD *)(a4 + 32) = 0u;
          *(_OWORD *)(a4 + 48) = 0u;
          *(_OWORD *)a4 = 0u;
          *(_OWORD *)(a4 + 16) = 0u;
          sub_4FC44(v12, (UInt8 *)a4, 128, 0);
          return 0LL;
        }
      }

      else
      {
        uint64_t v11 = (const __CFString **)sub_1D774(v10, a3, 0);
        if (v11) {
          goto LABEL_7;
        }
      }

      return 14LL;
    }

    else
    {
      return 2LL;
    }
  }

  return result;
}

uint64_t sub_1D6A0(uint64_t a1, int *a2)
{
  int v3 = *a2;
  if ((*a2 & 0x100) == 0) {
    return sub_216E4(a1, (uint64_t)a2, 0);
  }
  char v5 = v3 - 1;
  BOOL v6 = (v3 - 257) > 5;
  uint64_t v7 = a1 + 24;
  uint64_t v8 = 0LL;
  unsigned int v9 = v6 | (0x16u >> v5);
  while (1)
  {
    uint64_t result = sub_50C98(v7, v8);
    if (*a2 == *(_DWORD *)(result + 24))
    {
      if ((v9 & 1) != 0) {
        break;
      }
      int v10 = (*a2 & 0x100) != 0 ? *(_DWORD *)(result + 88) : 0;
      if (a2[2] == v10) {
        break;
      }
    }

    uint64_t v8 = (v8 + 1);
  }

  return result;
}

_DWORD *sub_1D774(uint64_t a1, int *a2, int a3)
{
  int v5 = *a2;
  if ((*a2 & 0x100) == 0) {
    return (_DWORD *)sub_216E4(a1, (uint64_t)a2, a3);
  }
  BOOL v7 = (v5 - 257) > 5 || ((1 << (v5 - 1)) & 0x29) == 0;
  char v8 = v7;
  BOOL v9 = v7 && (v5 & 0xFFFFFFFE) == 258;
  uint64_t v10 = a1 + 24;
  if ((int)sub_50C94(a1 + 24) >= 1)
  {
    uint64_t v11 = 0LL;
    do
    {
      uint64_t result = (_DWORD *)sub_50C98(v10, v11);
      if (!a3 || result[8])
      {
        int v12 = result[6];
        if ((v8 & 1) != 0)
        {
          if ((v12 & 0xFFFFFFFE) == 0x102 && v9 || v12 == v5) {
            return result;
          }
        }

        else
        {
          unsigned int v15 = v12 - 257;
          BOOL v16 = v15 > 5;
          int v17 = (1 << v15) & 0x29;
          BOOL v18 = v16 || v17 == 0;
          if (!v18 && a2[2] == result[22]) {
            return result;
          }
        }
      }

      uint64_t v11 = (v11 + 1);
    }

    while ((int)v11 < (int)sub_50C94(v10));
  }

  return 0LL;
}

uint64_t sub_1D8A0(const char *a1, int *a2)
{
  int v3 = *a2;
  uint64_t result = 3LL;
  if (*a2 && v3 != 256 && v3 != 512)
  {
    uint64_t v6 = sub_19E70(a1, 0LL);
    if (v6)
    {
      uint64_t v7 = v6;
      uint64_t v8 = sub_1D6A0(v6, a2);
      if (v8) {
        return sub_1D91C(v7, v8);
      }
      else {
        return 14LL;
      }
    }

    else
    {
      return 2LL;
    }
  }

  return result;
}

uint64_t sub_1D91C(uint64_t a1, uint64_t a2)
{
  if (!*(_DWORD *)(a2 + 32)) {
    return 4LL;
  }
  uint64_t v4 = sub_57538();
  uint64_t v5 = _SC_syslog_os_log_mapping(6LL);
  if (__SC_log_enabled(6LL, v4, v5))
  {
    uint64_t v6 = _os_log_pack_size(22LL);
    uint64_t v7 = (char *)v13 - ((__chkstk_darwin(v6) + 15) & 0xFFFFFFFFFFFFFFF0LL);
    uint64_t v8 = __error();
    uint64_t v9 = _os_log_pack_fill(v7, v6, *v8, &dword_0, "remove_service %s %s", v13[0], v13[1]);
    uint64_t v10 = nullsub_1(*(void *)(a1 + 8));
    uint64_t v11 = sub_14420(*(_DWORD *)(a2 + 24));
    *(_DWORD *)uint64_t v9 = 136315394;
    *(void *)(v9 + 4) = v10;
    *(_WORD *)(v9 + 12) = 2080;
    *(void *)(v9 + 14) = v11;
    __SC_log_send(6LL, v4, v5, v7);
  }

  sub_210C0(a1, *(const void **)a2, (*(_DWORD *)(a2 + 24) >> 8) & 1);
  return 0LL;
}

uint64_t sub_1DA7C(const char *a1, const char *a2)
{
  CFStringRef v3 = CFStringCreateWithCString(0LL, a2, 0x8000100u);
  if (!v3) {
    return 5LL;
  }
  CFStringRef v4 = v3;
  uint64_t v5 = sub_1DC2C(a1, v3, &v20);
  if (v5)
  {
    uint64_t v6 = v5;
    LODWORD(v19) = 0;
    uint64_t v7 = v20;
    *(void *)((char *)&v19 + 4) = sub_54F74(*(void *)(*(void *)(v20 + 16) + 8LL));
    HIDWORD(v19) = v8;
    uint64_t v9 = sub_57538();
    uint64_t v10 = _SC_syslog_os_log_mapping(6LL);
    if (__SC_log_enabled(6LL, v9, v10))
    {
      uint64_t v11 = _os_log_pack_size(22LL);
      int v12 = (char *)&v19 - ((__chkstk_darwin(v11) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      int v13 = __error();
      uint64_t v14 = _os_log_pack_fill( v12,  v11,  *v13,  &dword_0,  "%s %s: refresh",  (const char *)v19,  *((const char **)&v19 + 1));
      uint64_t v15 = nullsub_1(*(void *)(v6 + 8));
      BOOL v16 = sub_14420(*(_DWORD *)(v7 + 24));
      *(_DWORD *)uint64_t v14 = 136315394;
      *(void *)(v14 + 4) = v15;
      *(_WORD *)(v14 + 12) = 2080;
      *(void *)(v14 + 14) = v16;
      __SC_log_send(6LL, v9, v10, v12);
    }

    uint64_t v17 = sub_1B834(v7, 8LL, (uint64_t)&v19);
  }

  else
  {
    uint64_t v17 = 14LL;
  }

  CFRelease(v4);
  return v17;
}

uint64_t sub_1DC2C(const char *a1, const void *a2, uint64_t *a3)
{
  uint64_t v5 = sub_19E70(a1, 0LL);
  if (v5)
  {
    uint64_t v6 = v5;
    uint64_t v5 = (uint64_t)sub_160EC(v5, a2, 0);
    if (!v5) {
      uint64_t v5 = (uint64_t)sub_160EC(v6, a2, 1);
    }
    if (v5) {
      uint64_t v7 = v6;
    }
    else {
      uint64_t v7 = 0LL;
    }
  }

  else
  {
    uint64_t v7 = 0LL;
  }

  *a3 = v5;
  return v7;
}

uint64_t sub_1DC9C(const char *a1, const char *a2)
{
  CFStringRef v3 = CFStringCreateWithCString(0LL, a2, 0x8000100u);
  if (!v3) {
    return 5LL;
  }
  CFStringRef v4 = v3;
  if (sub_1DC2C(a1, v3, &v7)) {
    uint64_t v5 = 0LL;
  }
  else {
    uint64_t v5 = 14LL;
  }
  CFRelease(v4);
  return v5;
}

uint64_t sub_1DD08(const char *a1, uint64_t a2)
{
  if (!a2) {
    return 3LL;
  }
  uint64_t v3 = sub_19E70(a1, 0LL);
  if (!v3) {
    return 2LL;
  }
  uint64_t v4 = v3;
  sub_21780(v4 + 24, 20LL, a2);
  sub_21780(v4 + 56, 20LL, a2);
  return 0LL;
}

uint64_t sub_1DD80(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return sub_21780(a1 + 56, a2, a3);
}

void **get_interface_list()
{
  uint64_t result = (void **)qword_6C188;
  if (!qword_6C188)
  {
    uint64_t result = sub_54238();
    qword_6C188 = (uint64_t)result;
  }

  return result;
}

CFStringRef sub_1DDEC(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 16);
  uint64_t v2 = sub_14420(*(_DWORD *)(a1 + 24));
  uint64_t v3 = nullsub_1(*(void *)(v1 + 8));
  return CFStringCreateWithFormat(0LL, 0LL, @"com.apple.networking.IPConfiguration.%s.%s", v3, v2);
}

dispatch_queue_t load(const void *a1)
{
  os_log_t v2 = os_log_create("com.apple.IPConfiguration", "Server");
  sub_5752C((uint64_t)v2);
  qword_6C190 = (uint64_t)CFRetain(a1);
  CFRunLoopRef Current = CFRunLoopGetCurrent();
  sub_2A808((uint64_t)Current);
  dispatch_queue_t result = sub_2A814();
  return result;
}

void start()
{
  uint64_t v38 = 0LL;
  uint64_t v0 = sub_57538();
  uint64_t v1 = _SC_syslog_os_log_mapping(6LL);
  if (__SC_log_enabled(6LL, v0, v1))
  {
    uint64_t v2 = _os_log_pack_size(2LL);
    uint64_t v3 = (char *)&v39[-1] - ((__chkstk_darwin(v2) + 15) & 0xFFFFFFFFFFFFFFF0LL);
    uint64_t v4 = __error();
    *(_WORD *)_os_log_pack_fill(v3, v2, *v4, &dword_0, "IPConfiguration starting", v38) = 0;
    __SC_log_send(6LL, v0, v1, v3);
  }

  uint64_t v5 = sub_2A814();
  sub_56368(v5, (uint64_t (*)(void))sub_1E794);
  sub_1E794();
  sub_1ECF4();
  sub_2BACC(dword_6C198 != 0);
  LODWORD(v39[0]) = 0;
  if (qword_6C190)
  {
    InfoDictionary = CFBundleGetInfoDictionary((CFBundleRef)qword_6C190);
    if (InfoDictionary)
    {
      Value = (const __CFDictionary *)CFDictionaryGetValue(InfoDictionary, @"IPConfiguration");
      CFTypeID TypeID = CFDictionaryGetTypeID();
      if (Value)
      {
        if (CFGetTypeID(Value) == TypeID)
        {
          G_must_broadcast = sub_21C24(Value, @"MustBroadcast", 0LL);
          G_max_retries = sub_21D74(Value, @"RetryCount", 9LL);
          G_gather_secs = sub_21D74(Value, @"GatherTimeSeconds", 1LL);
          qword_6C0C8 = sub_21EAC(Value, @"LinkInactiveWaitTimeSeconds", *(double *)&qword_6C0C8);
          G_initial_wait_secs = sub_21D74(Value, @"InitialRetryTimeSeconds", 1LL);
          G_max_wait_secs = sub_21D74(Value, @"MaximumRetryTimeSeconds", 8LL);
          dword_6C08C = sub_21D74(Value, @"ARPProbeCount", 3LL);
          dword_6C090 = sub_21D74(Value, @"ARPGratuitousCount", 2LL);
          qword_6C098 = sub_21EAC(Value, @"ARPRetryTimeSeconds", *(double *)&qword_6C098);
          dword_6C0A0 = sub_21D74(Value, @"ARPDetectCount", 6LL);
          qword_6C0A8 = sub_21EAC(Value, @"ARPDetectRetryTimeSeconds", *(double *)&qword_6C0A8);
          dword_6C2E8 = sub_21C24(Value, @"DHCPAcceptsBOOTP", 0LL);
          dword_6C024 = sub_21C24(Value, @"DHCPFailureConfiguresLinkLocal", 1LL);
          dword_6C028 = sub_21C24(Value, @"DHCPSuccessDeconfiguresLinkLocal", 1LL);
          dword_6C038 = sub_21D74(Value, @"DHCPInitRebootRetryCount", 2LL);
          dword_6C03C = sub_21D74(Value, @"DHCPSelectRetryCount", 3LL);
          dword_6C02C = sub_21D74(Value, @"DHCPAllocateLinkLocalAtRetryCount", 4LL);
          dword_6C030 = sub_21D74(Value, @"DHCPGenerateFailureSymptomAtRetryCount", 6LL);
          dword_6C034 = sub_21D74(Value, @"DHCPRouterARPAtRetryCount", 3LL);
          uint64_t v9 = (char *)sub_22020(Value, @"DHCPRequestedParameterList", 1u, v39);
          sub_8D98(v9, v39[0]);
          G_router_arp = sub_21C24(Value, @"RouterARPEnabled", 1LL);
          G_router_arp_wifi_lease_start_threshold_secs = sub_21D74( Value,  @"RouterARPWiFiLeaseStartThresholdSeconds",  G_router_arp_wifi_lease_start_threshold_secs);
          dword_6C0D0 = sub_21D74(Value, @"DHCPLocalHostNameLengthMax", 15LL);
          G_discover_and_publish_router_mac_vm_address_t address = sub_21C24(Value, @"DiscoverAndPublishRouterMACAddress", 1LL);
          dword_6C080 = sub_21D74(Value, @"DiscoverRouterMACAddressTimeSeconds", 60LL);
          dword_6C084 = sub_21D74(Value, @"DefendIPAddressIntervalSeconds", 10LL);
          dword_6C088 = sub_21D74(Value, @"DefendIPAddressCount", 5LL);
          dword_6C040 = sub_21D74(Value, @"DHCPLeaseWriteT1ThresholdSeconds", 3600LL);
          dword_6C0B0 = sub_21D74(Value, @"ARPConflictRetryCount", 2LL);
          qword_6C0B8 = sub_21EAC(Value, @"ARPConflictRetryDelaySeconds", *(double *)&qword_6C0B8);
          dword_6C048 = sub_21D74(Value, @"ManualConflictRetryIntervalSeconds", 300LL);
          dword_6C074 = sub_21D74(Value, @"MinimumShortWakeIntervalSeconds", 60LL);
          dword_6C078 = sub_21D74(Value, @"MinimumWakeIntervalSeconds", 900LL);
          dword_6C07C = sub_21D74(Value, @"WakeSkewSeconds", 30LL);
          dword_6C0C4 = sub_21C24(Value, @"ConfigureIPv6", 1LL);
          if (dword_6C0C4)
          {
            int v40 = 0;
            G_dhcpv6_enabled = sub_21C24(Value, @"DHCPv6Enabled", 1LL);
            uint64_t v10 = (__int16 *)sub_22020(Value, @"DHCPv6RequestedOptions", 2u, &v40);
            sub_3F7A8(v10, v40);
            G_dhcpv6_stateful_enabled = sub_21C24(Value, @"DHCPv6StatefulEnabled", 1LL);
          }

          dword_6C0C0 = sub_21C24(Value, @"DisableUnneededInterfaces", 1LL);
        }
      }
    }
  }

  SCPreferencesRef v11 = SCPreferencesCreate(0LL, @"IPConfiguration.DHCPClient", @"DHCPClient.plist");
  uint64_t v38 = (const char *)v11;
  if (v11)
  {
    int v12 = v11;
    if (SCPreferencesSetCallback(v11, (SCPreferencesCallBack)sub_1EE34, 0LL)
      && (int v13 = sub_2A814(), SCPreferencesSetDispatchQueue(v12, v13)))
    {
      sub_1EF20(v12);
      SCPreferencesSynchronize(v12);
      qword_6C178 = (uint64_t)SCDynamicStoreCreate(0LL, @"IPConfiguration", (SCDynamicStoreCallBack)sub_1EF80, 0LL);
      if (!qword_6C178)
      {
        uint64_t v14 = sub_57538();
        uint64_t v15 = _SC_syslog_os_log_mapping(5LL);
        if (__SC_log_enabled(5LL, v14, v15))
        {
          uint64_t v16 = _os_log_pack_size(12LL);
          uint64_t v17 = (char *)&v39[-1] - ((__chkstk_darwin(v16) + 15) & 0xFFFFFFFFFFFFFFF0LL);
          BOOL v18 = __error();
          uint64_t v19 = _os_log_pack_fill(v17, v16, *v18, &dword_0, "SCDynamicStoreCreate failed: %s", v38);
          int v20 = SCError();
          int v21 = SCErrorString(v20);
          *(_DWORD *)uint64_t v19 = 136315138;
          *(void *)(v19 + 4) = v21;
          __SC_log_send(5LL, v14, v15, v17);
        }
      }

      bootp_session_init((unsigned __int16)word_6C020);
      v39[0] = &dword_6C08C;
      v39[1] = &dword_6C090;
      v39[2] = &qword_6C098;
      v39[3] = &dword_6C0A0;
      v39[4] = &qword_6C0A8;
      v39[5] = &dword_6C0B0;
      v39[6] = &qword_6C0B8;
      sub_53C8((BOOL (*)(uint64_t, int, const void *, int))sub_1F594, (uint64_t)v39);
      sub_53D14(qword_6C150, (uint64_t)sub_1F654, 0LL);
      sub_1F7B4();
      sub_26ADC();
    }

    else
    {
      uint64_t v22 = sub_57538();
      uint64_t v23 = _SC_syslog_os_log_mapping(5LL);
      if (__SC_log_enabled(5LL, v22, v23))
      {
        uint64_t v24 = _os_log_pack_size(12LL);
        uint64_t v25 = (char *)&v39[-1] - ((__chkstk_darwin(v24) + 15) & 0xFFFFFFFFFFFFFFF0LL);
        BOOL v26 = __error();
        uint64_t v27 = _os_log_pack_fill( v25,  v24,  *v26,  &dword_0,  "IPConfigurationSCPreferencesSetCallback failed: %s",  v38);
        int v28 = SCError();
        int v29 = SCErrorString(v28);
        *(_DWORD *)uint64_t v27 = 136315138;
        *(void *)(v27 + 4) = v29;
        __SC_log_send(5LL, v22, v23, v25);
      }

      sub_4FA18((const void **)&v38);
    }
  }

  else
  {
    uint64_t v30 = sub_57538();
    uint64_t v31 = _SC_syslog_os_log_mapping(5LL);
    if (__SC_log_enabled(5LL, v30, v31))
    {
      uint64_t v32 = _os_log_pack_size(12LL);
      uint64_t v33 = (char *)&v39[-1] - ((__chkstk_darwin(v32) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v34 = __error();
      uint64_t v35 = _os_log_pack_fill( v33,  v32,  *v34,  &dword_0,  "IPConfiguration: SCPreferencesCreate failed: %s",  v38);
      int v36 = SCError();
      CFStringRef v37 = SCErrorString(v36);
      *(_DWORD *)uint64_t v35 = 136315138;
      *(void *)(v35 + 4) = v37;
      __SC_log_send(5LL, v30, v31, v33);
    }
  }

void sub_1E794()
{
  int v0 = sub_564B0(0LL);
  int v1 = v0;
  G_IPConfiguration_verbose = v0;
  uint64_t v2 = sub_57538();
  uint64_t v3 = _SC_syslog_os_log_mapping(5LL);
  int v4 = __SC_log_enabled(5LL, v2, v3);
  if (v1)
  {
    if (v4)
    {
      uint64_t v5 = _os_log_pack_size(2LL);
      uint64_t v6 = (char *)&v48 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v7 = *__error();
      int v8 = (_WORD *)_os_log_pack_fill(v6, v5, v7, &dword_0, "IPConfiguration: verbose mode enabled");
LABEL_7:
      _WORD *v8 = 0;
      __SC_log_send(5LL, v2, v3, v6);
    }
  }

  else if (v4)
  {
    uint64_t v9 = _os_log_pack_size(2LL);
    uint64_t v6 = (char *)&v48 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0LL);
    uint64_t v10 = *__error();
    int v8 = (_WORD *)_os_log_pack_fill(v6, v9, v10, &dword_0, "IPConfiguration: verbose mode disabled");
    goto LABEL_7;
  }

  BOOL v11 = v1 != 0;
  bootp_session_set_verbose(v11);
  DHCPv6SocketSetVerbose(v11);
  sub_36188(v11);
LABEL_9:
  unsigned int v12 = sub_565B4();
  if (v12) {
    int v13 = v12;
  }
  else {
    int v13 = 2;
  }
  if (v13 != dword_6C04C)
  {
    uint64_t v14 = sub_57538();
    uint64_t v15 = _SC_syslog_os_log_mapping(5LL);
    if (__SC_log_enabled(5LL, v14, v15))
    {
      uint64_t v16 = _os_log_pack_size(12LL);
      uint64_t v17 = (char *)&v48 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0LL);
      BOOL v18 = __error();
      uint64_t v19 = _os_log_pack_fill(v17, v16, *v18, &dword_0, "IPConfiguration: AWD interface types %@");
      uint64_t v20 = sub_56478(v13);
      *(_DWORD *)uint64_t v19 = 138412290;
      *(void *)(v19 + 4) = v20;
      __SC_log_send(5LL, v14, v15, v17);
    }

    dword_6C04C = v13;
  }

  int v21 = sub_56670(0LL);
  if (dword_6C1AC != v21)
  {
    int v22 = v21;
    uint64_t v23 = sub_57538();
    uint64_t v24 = _SC_syslog_os_log_mapping(5LL);
    if (__SC_log_enabled(5LL, v23, v24))
    {
      uint64_t v25 = _os_log_pack_size(12LL);
      BOOL v26 = (char *)&v48 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v27 = __error();
      uint64_t v28 = _os_log_pack_fill( v26,  v25,  *v27,  &dword_0,  "IPConfiguration: cellular CLAT46 %sauto-enabled",  v48);
      int v29 = "";
      if (!v22) {
        int v29 = "not ";
      }
      *(_DWORD *)uint64_t v28 = 136315138;
      *(void *)(v28 + 4) = v29;
      __SC_log_send(5LL, v23, v24, v26);
    }

    dword_6C1AC = v22;
  }

  int v30 = sub_566AC(1LL);
  if (dword_6C198 != v30)
  {
    int v31 = v30;
    uint64_t v32 = sub_57538();
    uint64_t v33 = _SC_syslog_os_log_mapping(5LL);
    if (__SC_log_enabled(5LL, v32, v33))
    {
      uint64_t v34 = _os_log_pack_size(12LL);
      uint64_t v35 = (char *)&v48 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0LL);
      int v36 = __error();
      uint64_t v37 = _os_log_pack_fill( v35,  v34,  *v36,  &dword_0,  "IPConfiguration: IPv6 linklocal modifier %s",  v48);
      uint64_t v38 = "expires";
      if (!v31) {
        uint64_t v38 = "does not expire";
      }
      *(_DWORD *)uint64_t v37 = 136315138;
      *(void *)(v37 + 4) = v38;
      __SC_log_send(5LL, v32, v33, v35);
    }

    dword_6C198 = v31;
  }

  if (dword_6C2EC)
  {
    G_dhcp_duid_type = 3;
  }

  else
  {
    else {
      __int16 v39 = 1;
    }
    G_dhcp_duid_type = v39;
    int v40 = sub_566E8();
    int v41 = v40;
    if (!v40) {
      goto LABEL_37;
    }
    if (v40 == 1)
    {
LABEL_36:
      G_dhcp_duid_type = v40;
      goto LABEL_37;
    }

    uint64_t v42 = sub_57538();
    uint64_t v43 = _SC_syslog_os_log_mapping(5LL);
    if (__SC_log_enabled(5LL, v42, v43))
    {
      uint64_t v44 = _os_log_pack_size(18LL);
      uint64_t v45 = (char *)&v48 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v46 = __error();
      uint64_t v47 = _os_log_pack_fill( v45,  v44,  *v46,  &dword_0,  "%s: unsupported DHCP DUID type %d specified",  v48,  v49);
      *(_DWORD *)uint64_t v47 = 136315394;
      *(void *)(v47 + 4) = "check_prefs";
      *(_WORD *)(v47 + 12) = 1024;
      *(_DWORD *)(v47 + 14) = v41;
      __SC_log_send(5LL, v42, v43, v45);
    }
  }

LABEL_37:
  sub_56334();
}

uint64_t sub_1ECF4()
{
  uint64_t result = sub_55B04("/var/db/dhcpclient/leases", 0x1C0u);
  if ((result & 0x80000000) != 0)
  {
    uint64_t v1 = sub_57538();
    uint64_t v2 = _SC_syslog_os_log_mapping(3LL);
    uint64_t result = __SC_log_enabled(3LL, v1, v2);
    if ((_DWORD)result)
    {
      uint64_t v3 = _os_log_pack_size(18LL);
      int v4 = (char *)&v10 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v5 = __error();
      uint64_t v6 = _os_log_pack_fill( v4,  v3,  *v5,  &dword_0,  "failed to create /var/db/dhcpclient/leases, %s (%d)",  v10,  v11);
      uint64_t v7 = __error();
      int v8 = strerror(*v7);
      int v9 = *__error();
      *(_DWORD *)uint64_t v6 = 136315394;
      *(void *)(v6 + 4) = v8;
      *(_WORD *)(v6 + 12) = 1024;
      *(_DWORD *)(v6 + 14) = v9;
      return __SC_log_send(3LL, v1, v2, v4);
    }
  }

  return result;
}

const __SCPreferences *sub_1EE34(const __SCPreferences *result, char a2)
{
  if ((a2 & 2) != 0)
  {
    uint64_t v2 = result;
    sub_1EF20(result);
    SCPreferencesSynchronize(v2);
    uint64_t result = (const __SCPreferences *)sub_50C94(&unk_6C150);
    if ((int)result >= 1)
    {
      uint64_t v3 = 0LL;
      do
      {
        uint64_t v4 = sub_50C98(&unk_6C150, v3);
        __int128 v9 = 0uLL;
        *(void *)((char *)&v9 + 4) = sub_54F74(*(void *)(v4 + 8));
        HIDWORD(v9) = v5;
        uint64_t v6 = v4 + 24;
        if ((int)sub_50C94(v6) >= 1)
        {
          uint64_t v7 = 0LL;
          do
          {
            uint64_t v8 = sub_50C98(v6, v7);
            if ((*(_BYTE *)(v8 + 25) & 1) != 0) {
              *(_DWORD *)(v8 + 116) &= ~4u;
            }
            sub_1B834(v8, 8LL, (uint64_t)&v9);
            uint64_t v7 = (v7 + 1);
          }

          while ((int)v7 < (int)sub_50C94(v6));
        }

        uint64_t v3 = (v3 + 1);
        uint64_t result = (const __SCPreferences *)sub_50C94(&unk_6C150);
      }

      while ((int)v3 < (int)result);
    }
  }

  return result;
}

void sub_1EF20(const __SCPreferences *a1)
{
  int v5 = 0;
  CFMutableArrayRef v1 = sub_221D4(a1);
  CFMutableArrayRef v4 = v1;
  if (v1)
  {
    uint64_t v2 = (unsigned __int8 *)sub_2208C(v1, 1u, &v5);
    sub_4FA18((const void **)&v4);
    int v3 = v5;
  }

  else
  {
    int v3 = 0;
    uint64_t v2 = 0LL;
  }

  sub_8F94(v2, v3);
}

void sub_1EF80(const __CFString *a1, CFArrayRef theArray)
{
  uint64_t v42 = 0LL;
  CFStringRef v43 = 0LL;
  CFIndex Count = CFArrayGetCount(theArray);
  if (!Count) {
    goto LABEL_72;
  }
  CFIndex v5 = Count;
  if (G_IPConfiguration_verbose)
  {
    uint64_t v6 = sub_57538();
    uint64_t v7 = _SC_syslog_os_log_mapping(7LL);
    if (__SC_log_enabled(7LL, v6, v7))
    {
      uint64_t v8 = _os_log_pack_size(18LL);
      __int128 v9 = (char *)&v36 - ((__chkstk_darwin(v8) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v10 = __error();
      uint64_t v11 = _os_log_pack_fill(v9, v8, *v10, &dword_0, "Changes: %@ (%d)");
      *(_DWORD *)uint64_t v11 = 138412546;
      *(void *)(v11 + 4) = theArray;
      *(_WORD *)(v11 + 12) = 1024;
      *(_DWORD *)(v11 + 14) = v5;
      __SC_log_send(7LL, v6, v7, v9);
    }
  }

  if (v5 < 1)
  {
    int v18 = 0;
  }

  else
  {
    uint64_t v38 = (const __SCDynamicStore *)a1;
    CFStringRef NetworkGlobalEntity = 0LL;
    LODWORD(v41) = 0;
    CFIndex v13 = 0LL;
    LODWORD(v40) = 0;
    int v14 = 0;
    int v15 = 0;
    CFStringRef v37 = kSCEntNetIPv4;
    CFStringRef v39 = kSCCompInterface;
    do
    {
      ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(theArray, v13);
      if (CFEqual(ValueAtIndex, (CFTypeRef)qword_6C1B8) || CFEqual(ValueAtIndex, (CFTypeRef)qword_6C1C0))
      {
        int v14 = 1;
      }

      else if (CFStringHasPrefix(ValueAtIndex, kSCDynamicStoreDomainSetup))
      {
        if (!NetworkGlobalEntity)
        {
          CFStringRef NetworkGlobalEntity = SCDynamicStoreKeyCreateNetworkGlobalEntity(0LL, kSCDynamicStoreDomainSetup, v37);
          CFStringRef v43 = NetworkGlobalEntity;
        }

        if (CFEqual(ValueAtIndex, NetworkGlobalEntity)) {
          int v15 = 1;
        }
        LODWORD(v41) = 1;
      }

      else if (CFStringHasSuffix(ValueAtIndex, v39))
      {
        LODWORD(v40) = 1;
      }

      else
      {
        CFMutableArrayRef Mutable = v42;
        if (!v42)
        {
          CFMutableArrayRef Mutable = CFArrayCreateMutable(0LL, v5, &kCFTypeArrayCallBacks);
          uint64_t v42 = Mutable;
        }

        CFArrayAppendValue(Mutable, ValueAtIndex);
      }

      ++v13;
    }

    while (v5 != v13);
    if (v14) {
      sub_22460(v38);
    }
    int v18 = v15;
    if ((_DWORD)v40 && sub_2390C())
    {
      sub_23A38();
      a1 = (const __CFString *)v38;
    }

    else
    {
      a1 = (const __CFString *)v38;
      if (!(_DWORD)v41) {
        goto LABEL_31;
      }
    }

    uint64_t v46 = 0LL;
    *(void *)uint64_t v44 = sub_23CA8((const __SCDynamicStore *)a1, &v46);
    sub_24670(*(const __CFArray **)v44, v46);
    sub_4FA18((const void **)v44);
    sub_4FA18((const void **)&v46);
  }

LABEL_72:
  sub_4FA18((const void **)&v43);
  sub_4FA18((const void **)&v42);
}

uint64_t sub_1F594(uint64_t a1, int a2, const void *a3, int a4)
{
  unsigned int v7 = 0;
  while (1)
  {
    uint64_t v8 = sub_53FC8(qword_6C188, v7);
    if (sub_54230(v8) == a4 && sub_54E28(v8) == a2)
    {
      __int128 v9 = (const void *)sub_54E44(v8);
      if (!bcmp(a3, v9, a4)) {
        break;
      }
    }
  }

  return 1LL;
}

void sub_1F654(uint64_t a1)
{
  uint64_t v2 = sub_57538();
  uint64_t v3 = _SC_syslog_os_log_mapping(7LL);
  if (__SC_log_enabled(7LL, v2, v3))
  {
    uint64_t v4 = _os_log_pack_size(12LL);
    CFIndex v5 = (char *)&v9 - ((__chkstk_darwin(v4) + 15) & 0xFFFFFFFFFFFFFFF0LL);
    uint64_t v6 = __error();
    uint64_t v7 = _os_log_pack_fill(v5, v4, *v6, &dword_0, "IFState_free(%s)", v9);
    uint64_t v8 = nullsub_1(*(void *)(a1 + 8));
    *(_DWORD *)uint64_t v7 = 136315138;
    *(void *)(v7 + 4) = v8;
    __SC_log_send(7LL, v2, v3, v5);
  }

  sub_1C6A8(a1, 1);
  sub_1C70C(a1, 1);
  sub_4FA18((const void **)(a1 + 16));
  sub_4FA18((const void **)(a1 + 136));
  sub_4FA18((const void **)(a1 + 96));
  *(void *)(a1 + 96) = 0LL;
  sub_54A9C((uint64_t **)(a1 + 8));
  timer_callout_free((uint64_t *)(a1 + 104));
  free((void *)a1);
}

void sub_1F7B4()
{
  int v0 = IOPMCopyScheduledPowerEvents();
  if (v0)
  {
    CFMutableArrayRef v1 = v0;
    CFIndex Count = CFArrayGetCount(v0);
    if (Count >= 1)
    {
      CFIndex v4 = Count;
      CFIndex v5 = 0LL;
      uint64_t v6 = @"scheduledby";
      *(void *)&__int128 v3 = 138412290LL;
      __int128 v20 = v3;
      do
      {
        ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(v1, v5);
        Value = (const __CFString *)CFDictionaryGetValue(ValueAtIndex, v6);
        if (CFStringHasPrefix(Value, @"com.apple.networking.IPConfiguration"))
        {
          uint64_t v9 = sub_57538();
          uint64_t v10 = _SC_syslog_os_log_mapping(6LL);
          if (__SC_log_enabled(6LL, v9, v10))
          {
            uint64_t v11 = _os_log_pack_size(12LL);
            CFIndex v21 = &v20;
            unsigned int v12 = v1;
            CFIndex v13 = v4;
            int v14 = v6;
            int v15 = (char *)&v20 - ((__chkstk_darwin(v11) + 15) & 0xFFFFFFFFFFFFFFF0LL);
            uint64_t v16 = __error();
            uint64_t v17 = _os_log_pack_fill(v15, v11, *v16, &dword_0, "IOPMCancelScheduledPowerEvent(%@)");
            *(_DWORD *)uint64_t v17 = v20;
            *(void *)(v17 + 4) = Value;
            int v18 = v15;
            uint64_t v6 = v14;
            CFIndex v4 = v13;
            CFMutableArrayRef v1 = v12;
            __SC_log_send(6LL, v9, v10, v18);
          }

          uint64_t v19 = (const __CFDate *)CFDictionaryGetValue(ValueAtIndex, @"time");
          IOPMCancelScheduledPowerEvent(v19, Value, @"wake");
        }

        ++v5;
      }

      while (v4 != v5);
    }

    CFRelease(v1);
  }

void prime()
{
  int v0 = sub_2A814();
  dispatch_async(v0, &stru_64CA0);
}

void sub_1F9A0(id a1)
{
  CFMutableArrayRef v1 = (const __SCDynamicStore *)qword_6C178;
  if (!qword_6C178)
  {
    sub_2390C();
    goto LABEL_38;
  }

  uint64_t v2 = sub_2A814();
  __int128 v3 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_data_add, 0LL, 0LL, v2);
  qword_6C1B0 = (uint64_t)v3;
  dispatch_source_set_event_handler(v3, &stru_64DF0);
  dispatch_activate(v3);
  qword_6C1C8 = (uint64_t)SCDynamicStoreKeyCreate( 0LL,  @"%@/%@/%@/",  kSCDynamicStoreDomainSetup,  kSCCompNetwork,  kSCCompService);
  qword_6C1D0 = (uint64_t)SCDynamicStoreKeyCreate( 0LL,  @"%@/%@/%@/",  kSCDynamicStoreDomainState,  kSCCompNetwork,  kSCCompInterface);
  CFMutableArrayRef Mutable = CFArrayCreateMutable(0LL, 0LL, &kCFTypeArrayCallBacks);
  CFIndex v5 = CFArrayCreateMutable(0LL, 0LL, &kCFTypeArrayCallBacks);
  CFStringRef NetworkServiceEntity = SCDynamicStoreKeyCreateNetworkServiceEntity( 0LL,  kSCDynamicStoreDomainSetup,  kSCCompAnyRegex,  kSCEntNetIPv4);
  CFArrayAppendValue(v5, NetworkServiceEntity);
  CFRelease(NetworkServiceEntity);
  CFStringRef v7 = SCDynamicStoreKeyCreateNetworkServiceEntity(0LL, kSCDynamicStoreDomainSetup, kSCCompAnyRegex, kSCEntNetIPv6);
  CFArrayAppendValue(v5, v7);
  CFRelease(v7);
  CFStringRef v8 = SCDynamicStoreKeyCreateNetworkServiceEntity(0LL, kSCDynamicStoreDomainSetup, kSCCompAnyRegex, kSCEntNet6to4);
  CFArrayAppendValue(v5, v8);
  CFRelease(v8);
  CFStringRef NetworkInterfaceEntity = SCDynamicStoreKeyCreateNetworkInterfaceEntity( 0LL,  kSCDynamicStoreDomainState,  kSCCompAnyRegex,  kSCEntNetIPv6);
  CFArrayAppendValue(v5, NetworkInterfaceEntity);
  CFRelease(NetworkInterfaceEntity);
  CFStringRef v10 = SCDynamicStoreKeyCreateNetworkServiceEntity( 0LL,  kSCDynamicStoreDomainSetup,  kSCCompAnyRegex,  kSCEntNetInterface);
  CFArrayAppendValue(v5, v10);
  CFRelease(v10);
  CFStringRef v11 = SCDynamicStoreKeyCreateNetworkInterfaceEntity(0LL, kSCDynamicStoreDomainState, kSCCompAnyRegex, kSCEntNetLink);
  CFArrayAppendValue(v5, v11);
  CFRelease(v11);
  CFStringRef v12 = SCDynamicStoreKeyCreateNetworkInterfaceEntity( 0LL,  kSCDynamicStoreDomainState,  kSCCompAnyRegex,  kSCEntNetAirPort);
  CFArrayAppendValue(v5, v12);
  CFRelease(v12);
  CFStringRef v13 = SCDynamicStoreKeyCreateNetworkInterfaceEntity(0LL, kSCDynamicStoreDomainState, kSCCompAnyRegex, kSCEntNetNAT64);
  CFArrayAppendValue(v5, v13);
  CFRelease(v13);
  CFStringRef v14 = SCDynamicStoreKeyCreateNetworkInterfaceEntity( 0LL,  kSCDynamicStoreDomainState,  kSCCompAnyRegex,  kSCEntNetRefreshConfiguration);
  CFArrayAppendValue(v5, v14);
  CFRelease(v14);
  int v15 = SCDynamicStoreKeyCreateNetworkInterfaceEntity( 0LL,  kSCDynamicStoreDomainState,  kSCCompAnyRegex,  kSCEntNetIPv4ARPCollision);
  MutableCopy = CFStringCreateMutableCopy(0LL, 0LL, v15);
  CFStringAppend(MutableCopy, @".*");
  CFRelease(v15);
  CFArrayAppendValue(v5, MutableCopy);
  CFRelease(MutableCopy);
  CFStringRef v17 = SCDynamicStoreKeyCreateNetworkInterfaceEntity( 0LL,  kSCDynamicStoreDomainState,  kSCCompAnyRegex,  kSCEntNetInterfaceActiveDuringSleepRequested);
  CFArrayAppendValue(v5, v17);
  CFRelease(v17);
  CFStringRef v18 = SCDynamicStoreKeyCreateNetworkInterfaceEntity(0LL, kSCDynamicStoreDomainSetup, kSCCompAnyRegex, 0LL);
  CFArrayAppendValue(v5, v18);
  CFRelease(v18);
  CFStringRef v19 = SCDynamicStoreKeyCreateNetworkInterfaceEntity( 0LL,  kSCDynamicStoreDomainState,  kSCCompAnyRegex,  kSCEntNetIPv6RouterExpired);
  CFArrayAppendValue(v5, v19);
  CFRelease(v19);
  CFStringRef NetworkInterface = SCDynamicStoreKeyCreateNetworkInterface(0LL, kSCDynamicStoreDomainState);
  CFArrayAppendValue(Mutable, NetworkInterface);
  CFRelease(NetworkInterface);
  CFStringRef NetworkGlobalEntity = SCDynamicStoreKeyCreateNetworkGlobalEntity(0LL, kSCDynamicStoreDomainSetup, kSCEntNetIPv4);
  CFArrayAppendValue(Mutable, NetworkGlobalEntity);
  CFRelease(NetworkGlobalEntity);
  qword_6C1B8 = (uint64_t)SCDynamicStoreKeyCreateComputerName(0LL);
  CFArrayAppendValue(Mutable, (const void *)qword_6C1B8);
  qword_6C1C0 = (uint64_t)SCDynamicStoreKeyCreateHostNames(0LL);
  CFArrayAppendValue(Mutable, (const void *)qword_6C1C0);
  SCDynamicStoreSetNotificationKeys(v1, Mutable, v5);
  CFRelease(Mutable);
  CFRelease(v5);
  CFIndex v22 = sub_2A814();
  SCDynamicStoreSetDispatchQueue(v1, v22);
  sub_22460(v1);
  sub_2390C();
  CFMutableDictionaryRef v54 = 0LL;
  int v55 = 0;
  thePortRef[0] = (IONotificationPortRef)0x2800000001LL;
  size_t v56 = 4LL;
  sysctl((int *)thePortRef, 2u, &v55, &v56, 0LL, 0LL);
  if (v55)
  {
    CFMutableDictionaryRef v23 = sub_5543C("IODeviceTree:/chosen");
    CFMutableDictionaryRef v54 = v23;
    if (v23)
    {
      uint64_t v24 = v23;
      Value = CFDictionaryGetValue(v23, @"dhcp-response");
      CFTypeID TypeID = CFDataGetTypeID();
      if (Value && CFGetTypeID(Value) == TypeID)
      {
        char v27 = 0;
      }

      else
      {
        Value = CFDictionaryGetValue(v24, @"bootp-response");
        CFTypeID v28 = CFDataGetTypeID();
        if (!Value || CFGetTypeID(Value) != v28) {
          goto LABEL_19;
        }
        char v27 = 1;
      }

      BytePtr = CFDataGetBytePtr((CFDataRef)Value);
      unsigned int Length = CFDataGetLength((CFDataRef)Value);
      int v31 = *((_DWORD *)BytePtr + 4);
      if (v31 || (int v31 = *((_DWORD *)BytePtr + 3)) != 0)
      {
        dword_6C170 = v31;
        dword_6C174 = *((_DWORD *)BytePtr + 5);
        CFTypeRef v32 = (_OWORD *)sub_53FFC((uint64_t *)qword_6C188, v31);
        if (v32)
        {
          uint64_t v33 = v32;
          CFPropertyListRef v34 = (_DWORD *)sub_1C654(v32);
          *v34 |= 0x10u;
          if ((v27 & 1) == 0)
          {
            sub_50F80((char **)thePortRef, (uint64_t)BytePtr, Length, 0LL);
            int v35 = sub_50E4C((uint64_t)thePortRef, 54, 4);
            if (v35) {
              dword_6C174 = *(_DWORD *)v35;
            }
            sub_50CA0((uint64_t)thePortRef);
          }

          uint64_t v36 = nullsub_1(v33);
          __strlcpy_chk(&unk_6C1EC, v36, 17LL, 17LL);
          dword_6C2EC = 1;
        }
      }
    }
  }

LABEL_30:
      CFRelease(v44);
    }

    ++v40;
  }

  while (v40 < (int)sub_53FBC(qword_6C188));
  if (v39) {
    sub_24670(v38, (const __CFArray *)v56);
  }
  else {
LABEL_34:
  }
    SCDynamicStoreSetValue(v1, @"Plugin:IPConfiguration", @"Plugin:IPConfiguration");
  sub_4FA18((const void **)thePortRef);
  sub_4FA18((const void **)&v56);
  io_connect_t v50 = IORegisterForSystemPower(0LL, thePortRef, (IOServiceInterestCallback)sub_27DF8, (io_object_t *)&v56);
  if (v50)
  {
    uint64_t v51 = thePortRef[0];
    uint64_t v52 = sub_2A814();
    IONotificationPortSetDispatchQueue(v51, v52);
  }

  dword_6C1E8 = v50;
LABEL_38:
  sub_2DFA8();
  dispatch_queue_t v53 = sub_2A814();
  os_state_add_handler(v53, &stru_64E30);
}

  *a6 = v54;
  return result;
}

    ++v7;
    ++v15;
    --v12;
  }

  while (v12);
  *(void *)CFIndex v47 = v14;
  if (!v13) {
    goto LABEL_43;
  }
LABEL_37:
  CFStringRef v19 = CFStringCreateWithBytes(0LL, v13, v7 - v13, 0x8000100u, 0);
  if (!v19) {
    goto LABEL_48;
  }
  __int128 v20 = v19;
  if (v14) {
    CFArrayAppendValue(v14, v19);
  }
  else {
    CFDictionarySetValue(Mutable, kSCPropNetDNSDomainName, v19);
  }
  CFRelease(v20);
LABEL_43:
  if (v14)
  {
    if (CFArrayGetCount(v14) == 1)
    {
      ValueAtIndex = CFArrayGetValueAtIndex(v14, 0LL);
      CFIndex v22 = Mutable;
      CFMutableDictionaryRef v23 = kSCPropNetDNSDomainName;
    }

    else
    {
      CFMutableDictionaryRef v23 = kSCPropNetDNSSearchDomains;
      CFIndex v22 = Mutable;
      ValueAtIndex = v14;
    }

    CFDictionarySetValue(v22, v23, ValueAtIndex);
  }

      CFStringRef v37 = sub_553BC((uint64_t *)a1, (uint64_t)ifa_name);
      if (v37)
      {
        BOOL v26 = v37;
        *(_WORD *)(v37 + 16) = v3->ifa_flags;
        ifa_addr = v3->ifa_addr;
        goto LABEL_32;
      }

      CFStringRef v44 = sub_57538();
      int v45 = _SC_syslog_os_log_mapping(5LL);
      goto LABEL_45;
    }

    if (sa_family != 18) {
      goto LABEL_82;
    }
    int v15 = 96LL * ((_DWORD)a1[1] & ~(*((int *)a1 + 2) >> 31));
    uint64_t v16 = -96LL;
    do
    {
      CFStringRef v17 = v16 + 96;
      if (v15 == v16 + 96) {
        goto LABEL_25;
      }
      CFStringRef v18 = (uint64_t)*a1;
      CFStringRef v19 = strcmp((const char *)*a1 + v16 + 96, ifa_name);
      uint64_t v16 = v17;
    }

    while (v19);
    if (v18)
    {
      __int128 v20 = v18 + v17;
      goto LABEL_27;
    }

void stop(uint64_t a1)
{
  uint64_t v2 = sub_2A814();
  block[0] = _NSConcreteStackBlock;
  block[1] = 0x40000000LL;
  block[2] = sub_20200;
  block[3] = &unk_64CC0;
  block[4] = a1;
  dispatch_async(v2, block);
}

void sub_20200(uint64_t a1)
{
  CFMutableArrayRef v1 = *(__CFRunLoopSource **)(a1 + 32);
  int v2 = sub_50C94(qword_6C150);
  if (v2 >= 1)
  {
    int v3 = v2;
    uint64_t v4 = 0LL;
    do
    {
      uint64_t v5 = sub_50C98(qword_6C150, v4);
      sub_21780(v5 + 24, 12LL, 0LL);
      sub_21780(v5 + 56, 12LL, 0LL);
      uint64_t v4 = (v4 + 1);
    }

    while (v3 != (_DWORD)v4);
  }

  CFRunLoopSourceSignal(v1);
}

uint64_t sub_20290(uint64_t a1)
{
  uint64_t v2 = 0LL;
  while (!*(_DWORD *)(sub_50C98(a1, v2) + 72))
  {
    uint64_t v2 = (v2 + 1);
  }

  return 1LL;
}

void sub_202F0(uint64_t a1, const __CFString *a2, int a3)
{
  if (a3) {
    CFDictionaryRef v5 = CFDictionaryCreate(0LL, 0LL, 0LL, 0LL, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  }
  else {
    CFDictionaryRef v5 = 0LL;
  }
  CFDictionaryRef v6 = v5;
  sub_3771C((const __SCDynamicStore *)qword_6C178, *(CFStringRef *)(a1 + 16), a2, v5);
  sub_4FA18((const void **)&v6);
  dispatch_source_merge_data((dispatch_source_t)qword_6C1B0, 1uLL);
}

uint64_t sub_2037C()
{
  if ((int)sub_50C94(&unk_6C150) < 1) {
    return SCDynamicStoreSetValue( (SCDynamicStoreRef)qword_6C178,  @"Plugin:IPConfiguration",  @"Plugin:IPConfiguration");
  }
  uint64_t v0 = 0LL;
  while (1)
  {
    CFMutableArrayRef v1 = (_BYTE *)sub_50C98(&unk_6C150, v0);
    uint64_t v2 = v1 + 24;
    uint64_t result = sub_50C94(v1 + 24);
    if (!(_DWORD)result && (*v1 & 1) == 0) {
      return result;
    }
    if ((int)sub_50C94(v2) >= 1)
    {
      uint64_t v4 = 0LL;
      do
      {
        uint64_t result = sub_50C98(v2, v4);
        if (!*(_DWORD *)(result + 40)) {
          return result;
        }
        uint64_t v4 = (v4 + 1);
      }

      while ((int)v4 < (int)sub_50C94(v2));
    }

    uint64_t v0 = (v0 + 1);
    if ((int)v0 >= (int)sub_50C94(&unk_6C150)) {
      return SCDynamicStoreSetValue( (SCDynamicStoreRef)qword_6C178,  @"Plugin:IPConfiguration",  @"Plugin:IPConfiguration");
    }
  }

int *sub_20458(uint64_t a1)
{
  uint64_t v2 = 0LL;
  while (1)
  {
    int v3 = (int *)sub_50C98(a1, v2);
    if (v3[10])
    {
      uint64_t v4 = v3;
      if (!v3[7] && sub_16454(v3[6])) {
        break;
      }
    }

    uint64_t v2 = (v2 + 1);
  }

  return v4;
}

void *sub_204D4(int a1)
{
  switch(a1)
  {
    case 257:
      uint64_t result = sub_2A84C;
      break;
    case 258:
    case 259:
      uint64_t result = sub_A028;
      break;
    case 260:
      uint64_t result = sub_9200;
      break;
    case 261:
      uint64_t result = linklocal_thread;
      break;
    case 262:
      uint64_t result = failover_thread;
      break;
    default:
      switch(a1)
      {
        case 513:
          int v1 = dword_6C0C4;
          uint64_t v2 = sub_3F0E4;
          goto LABEL_10;
        case 514:
        case 515:
          int v1 = dword_6C0C4;
          uint64_t v2 = sub_3940C;
          goto LABEL_10;
        case 516:
          int v1 = dword_6C0C4;
          uint64_t v2 = sub_49A68;
          goto LABEL_10;
        case 517:
          int v1 = dword_6C0C4;
          uint64_t v2 = sub_490C8;
LABEL_10:
          if (v1) {
            uint64_t result = v2;
          }
          else {
            uint64_t result = 0LL;
          }
          break;
        case 518:
          uint64_t result = sub_41A48;
          break;
        default:
          uint64_t result = 0LL;
          break;
      }

      break;
  }

  return result;
}

uint64_t sub_205C4(_OWORD *a1)
{
  uint64_t v2 = malloc(0xB0uLL);
  uint64_t v3 = (uint64_t)v2;
  if (v2)
  {
    v2[9] = 0u;
    v2[10] = 0u;
    v2[7] = 0u;
    v2[8] = 0u;
    v2[5] = 0u;
    v2[6] = 0u;
    v2[3] = 0u;
    v2[4] = 0u;
    v2[1] = 0u;
    v2[2] = 0u;
    _OWORD *v2 = 0u;
    *((void *)v2 + 1) = sub_54AD8(a1);
    uint64_t v4 = (const char *)nullsub_1(a1);
    *(void *)(v3 + 16) = CFStringCreateWithCString(0LL, v4, 0x600u);
    sub_207C0(v3);
    CFStringRef NetworkInterfaceEntity = SCDynamicStoreKeyCreateNetworkInterfaceEntity( 0LL,  kSCDynamicStoreDomainState,  *(CFStringRef *)(v3 + 16),  kSCEntNetInterfaceActiveDuringSleepRequested);
    CFPropertyListRef v6 = SCDynamicStoreCopyValue((SCDynamicStoreRef)qword_6C178, NetworkInterfaceEntity);
    CFRelease(NetworkInterfaceEntity);
    if (v6)
    {
      *(_DWORD *)(v3 + 148) = 1;
      CFRelease(v6);
    }

    CFStringRef v7 = (const char *)nullsub_1(a1);
    *(void *)(v3 + 104) = timer_callout_init(v7);
    *(_DWORD *)(v3 + 116) = dword_6C1A8;
    sub_53D14((void *)(v3 + 24), (uint64_t)sub_209C0, 0LL);
    sub_53D14((void *)(v3 + 56), (uint64_t)sub_209C0, 0LL);
  }

  else
  {
    uint64_t v8 = sub_57538();
    uint64_t v9 = _SC_syslog_os_log_mapping(5LL);
    if (__SC_log_enabled(5LL, v8, v9))
    {
      uint64_t v10 = _os_log_pack_size(2LL);
      CFStringRef v11 = (char *)&v14 - ((__chkstk_darwin(v10) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      CFStringRef v12 = __error();
      *(_WORD *)_os_log_pack_fill(v11, v10, *v12, &dword_0, "IFState_init: malloc ifstate failed") = 0;
      __SC_log_send(5LL, v8, v9, v11);
    }
  }

  return v3;
}

void sub_207C0(uint64_t a1)
{
  uint64_t v2 = nullsub_1(*(void *)(a1 + 8));
  unint64_t v3 = sub_54F84(*(void *)(a1 + 8));
  uint64_t v4 = sub_57538();
  uint64_t v5 = _SC_syslog_os_log_mapping(6LL);
  int v6 = __SC_log_enabled(6LL, v4, v5);
  if ((_DWORD)v3)
  {
    if (!v6) {
      goto LABEL_9;
    }
    uint64_t v7 = _os_log_pack_size(22LL);
    uint64_t v8 = (char *)v17 - ((__chkstk_darwin(v7) + 15) & 0xFFFFFFFFFFFFFFF0LL);
    uint64_t v9 = __error();
    uint64_t v10 = _os_log_pack_fill( v8,  v7,  *v9,  &dword_0,  "%s link is %s",  (const char *)v17[0],  (const char *)v17[1]);
    CFStringRef v11 = "up";
    if (!HIDWORD(v3)) {
      CFStringRef v11 = "down";
    }
    *(_DWORD *)uint64_t v10 = 136315394;
    *(void *)(v10 + 4) = v2;
    *(_WORD *)(v10 + 12) = 2080;
    *(void *)(v10 + 14) = v11;
  }

  else
  {
    if (!v6) {
      goto LABEL_9;
    }
    uint64_t v12 = _os_log_pack_size(12LL);
    uint64_t v8 = (char *)v17 - ((__chkstk_darwin(v12) + 15) & 0xFFFFFFFFFFFFFFF0LL);
    CFStringRef v13 = __error();
    uint64_t v14 = _os_log_pack_fill(v8, v12, *v13, &dword_0, "%s link is unknown", (const char *)v17[0]);
    *(_DWORD *)uint64_t v14 = 136315138;
    *(void *)(v14 + 4) = v2;
  }

  __SC_log_send(6LL, v4, v5, v8);
LABEL_9:
  if (sub_54E84(*(void *)(a1 + 8)))
  {
    int v15 = (const void *)sub_20B70(*(void *)(a1 + 16));
    uint64_t v16 = v15;
    v17[0] = v15;
    if (v15) {
      CFRetain(v15);
    }
    sub_4FA18((const void **)(a1 + 96));
    *(void *)(a1 + 96) = v16;
    sub_4FA18(v17);
  }

void sub_209C0(uint64_t a1)
{
  uint64_t v2 = sub_57538();
  uint64_t v3 = _SC_syslog_os_log_mapping(7LL);
  if (__SC_log_enabled(7LL, v2, v3))
  {
    uint64_t v4 = _os_log_pack_size(22LL);
    uint64_t v5 = (char *)&v14 - ((__chkstk_darwin(v4) + 15) & 0xFFFFFFFFFFFFFFF0LL);
    int v6 = __error();
    uint64_t v7 = _os_log_pack_fill(v5, v4, *v6, &dword_0, "ServiceFree(%@) %s");
    uint64_t v8 = *(const void **)a1;
    uint64_t v9 = sub_14420(*(_DWORD *)(a1 + 24));
    *(_DWORD *)uint64_t v7 = 138412546;
    *(void *)(v7 + 4) = v8;
    *(_WORD *)(v7 + 12) = 2080;
    *(void *)(v7 + 14) = v9;
    __SC_log_send(7LL, v2, v3, v5);
  }

  uint64_t v10 = *(void *)(a1 + 16);
  if (v10 && *(void *)(v10 + 88) == a1) {
    *(void *)(v10 + 88) = 0LL;
  }
  sub_1B834(a1, 1LL, 0LL);
  sub_17D2C(a1, 0);
  sub_4FA18((const void **)a1);
  sub_4FA18((const void **)(a1 + 48));
  sub_4FA18((const void **)(a1 + 56));
  CFStringRef v11 = *(dispatch_object_s **)(a1 + 64);
  if (v11)
  {
    context = dispatch_get_context(v11);
    CFRelease(context);
    dispatch_source_cancel(*(dispatch_source_t *)(a1 + 64));
    dispatch_release(*(dispatch_object_t *)(a1 + 64));
    *(void *)(a1 + 64) = 0LL;
  }

  CFStringRef v13 = *(const void **)(a1 + 8);
  if (v13) {
    CFRelease(v13);
  }
  free((void *)a1);
}

uint64_t sub_20B70(uint64_t a1)
{
  uint64_t v2 = sub_29E8C(a1);
  uint64_t v3 = v2;
  if (v2)
  {
    uint64_t v4 = sub_2A630(v2);
    uint64_t v5 = sub_57538();
    uint64_t v6 = _SC_syslog_os_log_mapping(5LL);
    int v7 = __SC_log_enabled(5LL, v5, v6);
    if (v4)
    {
      if (v7)
      {
        uint64_t v8 = _os_log_pack_size(52LL);
        uint64_t v9 = (char *)&v27 - ((__chkstk_darwin(v8) + 15) & 0xFFFFFFFFFFFFFFF0LL);
        uint64_t v10 = __error();
        uint64_t v11 = _os_log_pack_fill(v9, v8, *v10, &dword_0, "%@: SSID %@ BSSID %@ NetworkID %@ Security %s");
        uint64_t v12 = sub_2A59C(v3);
        CFStringRef v13 = sub_2A5A4(v3);
        int v14 = sub_2A628(v3);
        int v15 = sub_29CEC(v14);
        *(_DWORD *)uint64_t v11 = 138413314;
        *(void *)(v11 + 4) = a1;
        *(_WORD *)(v11 + 12) = 2112;
        *(void *)(v11 + 14) = v12;
        *(_WORD *)(v11 + 22) = 2112;
        *(void *)(v11 + 24) = v13;
        *(_WORD *)(v11 + 32) = 2112;
        *(void *)(v11 + 34) = v4;
        *(_WORD *)(v11 + 42) = 2080;
        *(void *)(v11 + 44) = v15;
LABEL_9:
        __SC_log_send(5LL, v5, v6, v9);
      }
    }

    else if (v7)
    {
      uint64_t v19 = _os_log_pack_size(42LL);
      uint64_t v9 = (char *)&v27 - ((__chkstk_darwin(v19) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      __int128 v20 = __error();
      uint64_t v21 = _os_log_pack_fill(v9, v19, *v20, &dword_0, "%@: SSID %@ BSSID %@ Security %s");
      uint64_t v22 = sub_2A59C(v3);
      CFStringRef v23 = sub_2A5A4(v3);
      int v24 = sub_2A628(v3);
      uint64_t v25 = sub_29CEC(v24);
      *(_DWORD *)uint64_t v21 = 138413058;
      *(void *)(v21 + 4) = a1;
      *(_WORD *)(v21 + 12) = 2112;
      *(void *)(v21 + 14) = v22;
      *(_WORD *)(v21 + 22) = 2112;
      *(void *)(v21 + 24) = v23;
      *(_WORD *)(v21 + 32) = 2080;
      *(void *)(v21 + 34) = v25;
      goto LABEL_9;
    }
  }

  else
  {
    uint64_t v5 = sub_57538();
    uint64_t v6 = _SC_syslog_os_log_mapping(5LL);
    if (__SC_log_enabled(5LL, v5, v6))
    {
      uint64_t v16 = _os_log_pack_size(12LL);
      uint64_t v9 = (char *)&v27 - ((__chkstk_darwin(v16) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      CFStringRef v17 = __error();
      uint64_t v18 = _os_log_pack_fill(v9, v16, *v17, &dword_0, "%@: no SSID");
      *(_DWORD *)uint64_t v18 = 138412290;
      *(void *)(v18 + 4) = a1;
      goto LABEL_9;
    }
  }

  return v3;
}

void sub_20E44(uint64_t a1, CFTypeRef cf)
{
  if (cf) {
    CFRetain(cf);
  }
  sub_4FA18((const void **)(a1 + 96));
  *(void *)(a1 + 96) = cf;
}

void sub_20E7C(uint64_t a1, CFTypeRef cf)
{
  if (cf) {
    CFRetain(cf);
  }
  uint64_t v4 = *(const void **)(a1 + 8);
  if (v4) {
    CFRelease(v4);
  }
  *(void *)(a1 + 8) = cf;
}

uint64_t sub_20EB8(uint64_t *a1)
{
  uint64_t result = sub_50C94(a1);
  if ((int)result >= 1)
  {
    int v3 = result;
    uint64_t v4 = 0LL;
    do
    {
      uint64_t result = sub_50C98(a1, v4);
      if (*(_DWORD *)(result + 32))
      {
        uint64_t v4 = (v4 + 1);
      }

      else
      {
        uint64_t result = sub_53DAC(a1, v4);
        --v3;
      }
    }

    while ((int)v4 < v3);
  }

  return result;
}

uint64_t sub_20F24(uint64_t a1)
{
  uint64_t result = sub_50C94(a1 + 56);
  if (!(_DWORD)result)
  {
    uint64_t v3 = *(void *)(a1 + 8);
    int v4 = sub_54228(v3);
    if (v4 != 24 && v4 != 57)
    {
      uint64_t v5 = (const char *)nullsub_1(v3);
      sub_33EC0(v5);
      uint64_t v6 = (const char *)nullsub_1(v3);
      sub_33618(v6);
      *(void *)(a1 + 120) = 0LL;
      *(void *)(a1 + 128) = 0LL;
      *(_DWORD *)a1 &= ~0x10000u;
    }

    int v7 = (const char *)nullsub_1(v3);
    return sub_32B8C(v7);
  }

  return result;
}

BOOL sub_20FA4(uint64_t a1, int a2)
{
  uint64_t v4 = *(void *)(a1 + 8);
  int v5 = sub_54228(v4);
  int v6 = v5;
  int v7 = 0LL;
  BOOL v8 = 0;
  if (v5 != 24 && v5 != 57)
  {
    if (sub_54E90(v4))
    {
      BOOL v8 = 0;
      int v7 = 0LL;
    }

    else
    {
      int v7 = (_OWORD *)(a1 + 120);
      BOOL v8 = (*(_WORD *)(a1 + 2) & 1) == 0;
    }
  }

  uint64_t v9 = (const char *)nullsub_1(v4);
  int v10 = sub_32814(v9, a2);
  if (v6 != 24 && v6 != 57)
  {
    unint64_t v11 = sub_54F74(v4);
    if (HIDWORD(v11) || !(_DWORD)v11)
    {
      BOOL v12 = ((*(_DWORD *)a1 >> 17) & 1) == 0;
      BOOL v13 = ((*(_DWORD *)a1 >> 18) & 1) == 0;
      int v14 = (char *)nullsub_1(v4);
      sub_32F44(v14, v7, v12, v8, v13, *(unsigned __int8 *)(a1 + 168));
    }
  }

  return v10 == 0;
}

uint64_t sub_210C0(uint64_t a1, const void *a2, int a3)
{
  if (a3) {
    int v6 = (uint64_t *)(a1 + 24);
  }
  else {
    int v6 = (uint64_t *)(a1 + 56);
  }
  if ((int)sub_50C94(v6) >= 1)
  {
    uint64_t v7 = 0LL;
    while (1)
    {
      BOOL v8 = (CFTypeRef *)sub_50C98(v6, v7);
      if (CFEqual(a2, *v8)) {
        break;
      }
      uint64_t v7 = (v7 + 1);
    }

    sub_53DAC(v6, v7);
  }

LABEL_10:
  if (a3) {
    return sub_154B0(a1);
  }
  else {
    return sub_20F24(a1);
  }
}

  CFIndex Count = CFDictionaryGetCount(v12);
  if (Count)
  {
    CFStringRef v17 = Count;
    uint64_t v81 = (__CFString *)Value;
    int v74 = kSCEntNetIPv4;
    uint64_t v75 = kSCEntNetIPv6;
    uint64_t v79 = a2;
    uint64_t v18 = CFArrayCreateMutable(0LL, 0LL, &kCFTypeArrayCallBacks);
    valuePtr = v18;
    uint64_t v19 = (const void **)malloc(8 * v17);
    CFDictionaryGetKeysAndValues(v12, v19, 0LL);
    if (v17 >= 1)
    {
      __int128 v20 = (CFStringRef *)v19;
      do
      {
        if (CFStringHasPrefix(*v20, (CFStringRef)qword_6C1C8))
        {
          uint64_t v21 = sub_5039C(*v20, @"/", 3LL);
          if (v21)
          {
            uint64_t v22 = v21;
            sub_50324(v18, v21);
            CFRelease(v22);
          }
        }

        ++v20;
        --v17;
      }

      while (v17);
    }

    free(v19);
    CFStringRef v23 = CFArrayGetCount(v18);
    if (v23)
    {
      if (v81)
      {
        v91.length = v23;
        v91.location = 0LL;
        CFArraySortValues(v18, v91, (CFComparatorFunction)sub_246F8, v81);
      }
    }

    else
    {
      sub_4FA18((const void **)&valuePtr);
      uint64_t v18 = valuePtr;
    }

    a2 = v79;
    uint64_t v85 = v18;
    if (v18)
    {
      int v24 = CFArrayGetCount(v18);
      if (v24 >= 1)
      {
        BOOL v26 = v24;
        uint64_t v27 = 0LL;
        uint64_t v81 = (__CFString *)kSCPropNetInterfaceType;
        uint64_t v76 = kSCPropNetInterfaceDeviceName;
        int v67 = kCFBooleanFalse;
        int v66 = kCFBooleanTrue;
        int v73 = kSCValNetInterfaceTypeEthernet;
        BOOL v72 = kSCValNetInterfaceTypeFireWire;
        uint64_t v69 = (CFTypeRef)kSCValNetInterfaceTypeLoopback;
        int v68 = kSCValNetInterfaceType6to4;
        BOOL v65 = kSCPropNet6to4Relay;
        *(void *)&uint64_t v25 = 138412290LL;
        uint64_t v77 = v25;
        CFTypeID v28 = v82;
        uint64_t v78 = v18;
        do
        {
          ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(v18, v27);
          uint64_t v30 = SCDynamicStoreKeyCreateNetworkServiceEntity(0LL, kSCDynamicStoreDomainSetup, ValueAtIndex, v28);
          int v31 = (const __CFDictionary *)CFDictionaryGetValue(v12, v30);
          CFRelease(v30);
          CFTypeRef v32 = CFDictionaryGetTypeID();
          if (v31 && CFGetTypeID(v31) == v32)
          {
            uint64_t v33 = CFDictionaryGetValue(v31, v81);
            CFPropertyListRef v34 = CFStringGetTypeID();
            if (v33 && CFGetTypeID(v33) == v34)
            {
              int v35 = (const __CFString *)CFDictionaryGetValue(v31, v76);
              uint64_t v36 = CFStringGetTypeID();
              if (v35 && CFGetTypeID(v35) == v36)
              {
                int v71 = v35;
                CFStringRef v37 = SCDynamicStoreKeyCreateNetworkInterfaceEntity(0LL, kSCDynamicStoreDomainSetup, v35, 0LL);
                uint64_t v38 = CFDictionaryGetValue(v12, v37);
                CFRelease(v37);
                int v39 = CFDictionaryGetTypeID();
                if (v38
                  && CFGetTypeID(v38) == v39
                  && (signed int v40 = (const __CFNumber *)CFDictionaryGetValue((CFDictionaryRef)v38, @"DisableUntilNeeded"),
                      CFStringRef v41 = CFNumberGetTypeID(),
                      v40)
                  && CFGetTypeID(v40) == v41)
                {
                  uint64_t v42 = CFNumberGetValue(v40, kCFNumberIntType, &valuePtr);
                  CFStringRef v43 = v67;
                  if ((_DWORD)valuePtr) {
                    CFStringRef v43 = v66;
                  }
                  if (!v42) {
                    CFStringRef v43 = 0LL;
                  }
                  uint64_t v70 = v43;
                }

                else
                {
                  uint64_t v70 = 0LL;
                }

                BOOL v12 = v83;
                if (CFEqual(v33, v73) || CFEqual(v33, v72) || CFEqual(v33, v69))
                {
                  uint64_t v51 = SCDynamicStoreKeyCreateNetworkServiceEntity(0LL, kSCDynamicStoreDomainSetup, ValueAtIndex, v74);
                  uint64_t v52 = (const __CFDictionary *)CFDictionaryGetValue(v12, v51);
                  CFRelease(v51);
                  dispatch_queue_t v53 = CFDictionaryGetTypeID();
                  if (v52)
                  {
                    if (CFGetTypeID(v52) == v53)
                    {
                      MutableCopy = CFDictionaryCreateMutableCopy(0LL, 0LL, v52);
                      CFDictionarySetValue(MutableCopy, v76, v71);
                      CFDictionarySetValue(MutableCopy, @"ServiceID", ValueAtIndex);
                      if (v70) {
                        CFDictionarySetValue(MutableCopy, @"_DisableUntilNeeded", v70);
                      }
                      if (MutableCopy)
                      {
                        CFArrayAppendValue(v89, MutableCopy);
                        CFRelease(MutableCopy);
                      }
                    }
                  }
                }

                if (CFEqual(v33, v73) || CFEqual(v33, v72) || CFEqual(v33, v68) || CFEqual(v33, v69))
                {
                  int v55 = SCDynamicStoreKeyCreateNetworkServiceEntity(0LL, kSCDynamicStoreDomainSetup, ValueAtIndex, v75);
                  size_t v56 = (const __CFDictionary *)CFDictionaryGetValue(v12, v55);
                  CFRelease(v55);
                  uint64_t v57 = CFDictionaryGetTypeID();
                  if (v56)
                  {
                    if (CFGetTypeID(v56) == v57)
                    {
                      int v58 = CFDictionaryCreateMutableCopy(0LL, 0LL, v56);
                      CFDictionarySetValue(v58, v76, v71);
                      CFDictionarySetValue(v58, @"ServiceID", ValueAtIndex);
                      uint64_t v59 = SCDynamicStoreKeyCreateNetworkServiceEntity( 0LL,  kSCDynamicStoreDomainSetup,  ValueAtIndex,  v80);
                      uint64_t v60 = (const __CFDictionary *)CFDictionaryGetValue(v12, v59);
                      CFRelease(v59);
                      if (v70) {
                        CFDictionarySetValue(v58, @"_DisableUntilNeeded", v70);
                      }
                      uint64_t v61 = CFDictionaryGetTypeID();
                      if (v60)
                      {
                        if (CFGetTypeID(v60) == v61)
                        {
                          int v62 = CFDictionaryGetValue(v60, v65);
                          if (v62) {
                            CFDictionarySetValue(v58, @"6to4Relay", v62);
                          }
                        }
                      }

                      if (v58)
                      {
                        CFArrayAppendValue(v88, v58);
                        CFRelease(v58);
                      }
                    }
                  }
                }
              }
            }

            else
            {
              CFStringRef v44 = sub_57538();
              int v45 = _SC_syslog_os_log_mapping(5LL);
              if (__SC_log_enabled(5LL, v44, v45))
              {
                CFIndex v46 = _os_log_pack_size(12LL);
                CFIndex v47 = (char *)&v65 - ((__chkstk_darwin(v46) + 15) & 0xFFFFFFFFFFFFFFF0LL);
                int v48 = __error();
                uint64_t v49 = _os_log_pack_fill( v47,  v46,  *v48,  &dword_0,  "IPConfiguration: Interface Type missing/invalid\nInterface = %@");
                *(_DWORD *)uint64_t v49 = v77;
                *(void *)(v49 + 4) = v31;
                io_connect_t v50 = v47;
                CFTypeID v28 = v82;
                __SC_log_send(5LL, v44, v45, v50);
                uint64_t v18 = v78;
              }
            }
          }

          ++v27;
        }

        while (v26 != v27);
        uint64_t v4 = v89;
        a2 = v79;
      }
    }
  }

  else
  {
    uint64_t v85 = 0LL;
  }

  *(NDR_record_t *)(a2 + 24) = v4;
  return result;
}

uint64_t sub_21174(const __CFDictionary *a1, const void *a2, uint64_t a3)
{
  Value = (const __CFBoolean *)CFDictionaryGetValue(a1, a2);
  CFTypeID TypeID = CFBooleanGetTypeID();
  if (Value && CFGetTypeID(Value) == TypeID) {
    return CFBooleanGetValue(Value);
  }
  return a3;
}

uint64_t sub_211CC(const __CFDictionary *a1, const void *a2, uint64_t a3)
{
  uint64_t v3 = a3;
  unsigned int valuePtr = a3;
  Value = (const __CFNumber *)CFDictionaryGetValue(a1, a2);
  CFTypeID TypeID = CFNumberGetTypeID();
  if (Value && CFGetTypeID(Value) == TypeID)
  {
    if (CFNumberGetValue(Value, kCFNumberIntType, &valuePtr)) {
      return valuePtr;
    }
    else {
      return v3;
    }
  }

  return v3;
}

_DWORD *sub_21240(_DWORD *result, uint64_t a2)
{
  int v2 = result[8];
  *(_DWORD *)(a2 + 32) = 1;
  *(_DWORD *)(a2 + 36) = v2;
  if ((*(_BYTE *)(a2 + 25) & 2) != 0)
  {
    *(_DWORD *)(a2 + 112) = result[9];
    if (result[10]) {
      *(_DWORD *)(a2 + 108) = 1;
    }
  }

  return result;
}

void sub_21270(uint64_t a1, int a2)
{
  uintptr_t v3 = a2;
  uint64_t v4 = sub_2A814();
  dispatch_source_t v5 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_proc, v3, 0x80000000uLL, v4);
  if (v5)
  {
    int v6 = v5;
    CFRetain(*(CFTypeRef *)a1);
    dispatch_set_context(v6, *(void **)a1);
    handler[0] = _NSConcreteStackBlock;
    handler[1] = 0x40000000LL;
    handler[2] = sub_21434;
    handler[3] = &unk_64DB0;
    handler[4] = v6;
    dispatch_source_set_event_handler(v6, handler);
    dispatch_resume(v6);
    *(void *)(a1 + 64) = v6;
  }

  else
  {
    uint64_t v7 = sub_57538();
    uint64_t v8 = _SC_syslog_os_log_mapping(5LL);
    if (__SC_log_enabled(5LL, v7, v8))
    {
      uint64_t v9 = _os_log_pack_size(2LL);
      int v10 = (char *)handler - ((__chkstk_darwin(v9) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      unint64_t v11 = __error();
      *(_WORD *)_os_log_pack_fill( v10,  v9,  *v11,  &dword_0,  "IPConfiguration: dispatch_source_create failed") = 0;
      __SC_log_send(5LL, v7, v8, v10);
    }
  }

const void *sub_213F4(const void *a1)
{
  CFTypeID TypeID = CFNumberGetTypeID();
  if (!a1) {
    return 0LL;
  }
  if (CFGetTypeID(a1) == TypeID) {
    return a1;
  }
  return 0LL;
}

uint64_t sub_21434(uint64_t a1)
{
  return sub_2143C(*(dispatch_source_s **)(a1 + 32));
}

uint64_t sub_2143C(dispatch_source_s *a1)
{
  int handle = dispatch_source_get_handle(a1);
  uint64_t v3 = sub_57538();
  uint64_t v4 = _SC_syslog_os_log_mapping(6LL);
  if (__SC_log_enabled(6LL, v3, v4))
  {
    uint64_t v5 = _os_log_pack_size(8LL);
    int v6 = (char *)&v19 - ((__chkstk_darwin(v5) + 15) & 0xFFFFFFFFFFFFFFF0LL);
    uint64_t v7 = __error();
    uint64_t v8 = (_DWORD *)_os_log_pack_fill(v6, v5, *v7, &dword_0, "IPConfiguration: pid %d exited", v19);
    _DWORD *v8 = 67109120;
    v8[1] = handle;
    __SC_log_send(6LL, v3, v4, v6);
  }

  context = dispatch_get_context(a1);
  uint64_t result = sub_1D578(0LL, context);
  if ((_DWORD)result)
  {
    int v11 = result;
    uint64_t v12 = sub_57538();
    uint64_t v13 = _SC_syslog_os_log_mapping(5LL);
    uint64_t result = __SC_log_enabled(5LL, v12, v13);
    if ((_DWORD)result)
    {
      uint64_t v14 = _os_log_pack_size(22LL);
      int v15 = (char *)&v19 - ((__chkstk_darwin(v14) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v16 = __error();
      uint64_t v17 = _os_log_pack_fill(v15, v14, *v16, &dword_0, "IPConfiguration: failed to stop service %@, %s");
      uint64_t v18 = off_64CE0[v11];
      *(_DWORD *)uint64_t v17 = 138412546;
      *(void *)(v17 + 4) = context;
      *(_WORD *)(v17 + 12) = 2080;
      *(void *)(v17 + 14) = v18;
      return __SC_log_send(5LL, v12, v13, v15);
    }
  }

  return result;
}

uint64_t sub_21634(const void *a1, CFTypeRef **a2, int a3)
{
  if ((int)sub_50C94(qword_6C150) < 1)
  {
LABEL_5:
    uint64_t v8 = 0LL;
    uint64_t v7 = 0LL;
    uint64_t v9 = 0LL;
    if (!a2) {
      return v9;
    }
LABEL_6:
    *a2 = v8;
    return v7;
  }

  uint64_t v6 = 0LL;
  while (1)
  {
    uint64_t v7 = sub_50C98(qword_6C150, v6);
    uint64_t v8 = sub_160EC(v7, a1, a3);
    if (v8) {
      break;
    }
    uint64_t v6 = (v6 + 1);
  }

  uint64_t v9 = v7;
  if (a2) {
    goto LABEL_6;
  }
  return v9;
}

uint64_t sub_216E4(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v5 = a1 + 56;
  uint64_t v6 = 0LL;
  while (1)
  {
    uint64_t result = sub_50C98(v5, v6);
    if (!a3 || *(_DWORD *)(result + 32))
    {
      int v8 = *(_DWORD *)(result + 24);
      if (v8 == *(_DWORD *)a2)
      {
        if (v8 != 513) {
          break;
        }
        if (*(void *)(a2 + 8) == *(void *)result && *(void *)(a2 + 16) == *(void *)(result + 8)) {
          break;
        }
      }
    }

    uint64_t v6 = (v6 + 1);
  }

  return result;
}

uint64_t sub_21780(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result = sub_50C94(a1);
  if ((int)result >= 1)
  {
    uint64_t v7 = 0LL;
    do
    {
      uint64_t v8 = sub_50C98(a1, v7);
      sub_1B834(v8, a2, a3);
      uint64_t v7 = (v7 + 1);
      uint64_t result = sub_50C94(a1);
    }

    while ((int)v7 < (int)result);
  }

  return result;
}

uint64_t sub_217E8(const void *a1, int *a2)
{
  CFTypeID TypeID = CFStringGetTypeID();
  if (!a1 || CFGetTypeID(a1) != TypeID) {
    return 0LL;
  }
  if (CFEqual(a1, kSCValNetIPv4ConfigMethodBOOTP))
  {
    uint64_t v5 = sub_57538();
    uint64_t v6 = _SC_syslog_os_log_mapping(6LL);
    if (__SC_log_enabled(6LL, v5, v6))
    {
      uint64_t v7 = _os_log_pack_size(2LL);
      uint64_t v8 = (char *)&v12 - ((__chkstk_darwin(v7) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v9 = __error();
      *(_WORD *)_os_log_pack_fill(v8, v7, *v9, &dword_0, "BOOTP is deprecated, using DHCP instead") = 0;
      __SC_log_send(6LL, v5, v6, v8);
      int v10 = 259;
LABEL_9:
      *a2 = v10;
      return 1LL;
    }

const void *sub_219D0(const __CFDictionary *a1, const void *a2, in_addr *a3)
{
  a3->s_addr = 0;
  uint64_t result = CFDictionaryGetValue(a1, a2);
  if (result)
  {
    uint64_t v6 = result;
    CFTypeID TypeID = CFArrayGetTypeID();
    if (CFGetTypeID(v6) != TypeID)
    {
      uint64_t v9 = sub_57538();
      uint64_t v10 = _SC_syslog_os_log_mapping(5LL);
      uint64_t result = (const void *)__SC_log_enabled(5LL, v9, v10);
      if (!(_DWORD)result) {
        return result;
      }
      uint64_t v11 = _os_log_pack_size(12LL);
      uint64_t v12 = (char *)&v19 - ((__chkstk_darwin(v11) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v13 = *__error();
      uint64_t v14 = _os_log_pack_fill(v12, v11, v13, &dword_0, "%@ is not an array");
      goto LABEL_12;
    }

    if (!CFArrayGetCount((CFArrayRef)v6))
    {
      uint64_t v9 = sub_57538();
      uint64_t v10 = _SC_syslog_os_log_mapping(5LL);
      uint64_t result = (const void *)__SC_log_enabled(5LL, v9, v10);
      if (!(_DWORD)result) {
        return result;
      }
      uint64_t v15 = _os_log_pack_size(12LL);
      uint64_t v12 = (char *)&v19 - ((__chkstk_darwin(v15) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v16 = *__error();
      uint64_t v14 = _os_log_pack_fill(v12, v15, v16, &dword_0, "%@ empty array");
      goto LABEL_12;
    }

    ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex((CFArrayRef)v6, 0LL);
    if ((sub_4FCC8(ValueAtIndex, a3) & 1) != 0) {
      return &dword_0 + 1;
    }
    uint64_t v9 = sub_57538();
    uint64_t v10 = _SC_syslog_os_log_mapping(5LL);
    uint64_t result = (const void *)__SC_log_enabled(5LL, v9, v10);
    if ((_DWORD)result)
    {
      uint64_t v17 = _os_log_pack_size(12LL);
      uint64_t v12 = (char *)&v19 - ((__chkstk_darwin(v17) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v18 = *__error();
      uint64_t v14 = _os_log_pack_fill(v12, v17, v18, &dword_0, "%@[0] is not an IP address");
LABEL_12:
      *(_DWORD *)uint64_t v14 = 138412290;
      *(void *)(v14 + 4) = a2;
      __SC_log_send(5LL, v9, v10, v12);
      return 0LL;
    }
  }

  return result;
}

uint64_t sub_21C24(const __CFDictionary *a1, const void *a2, uint64_t a3)
{
  uint64_t v4 = sub_21174(a1, a2, a3);
  if (G_IPConfiguration_verbose)
  {
    uint64_t v5 = sub_57538();
    uint64_t v6 = _SC_syslog_os_log_mapping(7LL);
    if (__SC_log_enabled(7LL, v5, v6))
    {
      uint64_t v7 = _os_log_pack_size(22LL);
      uint64_t v8 = (char *)&v13 - ((__chkstk_darwin(v7) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v9 = __error();
      uint64_t v10 = _os_log_pack_fill(v8, v7, *v9, &dword_0, "%@ = %s");
      uint64_t v11 = "false";
      if ((_DWORD)v4 == 1) {
        uint64_t v11 = "true";
      }
      *(_DWORD *)uint64_t v10 = 138412546;
      *(void *)(v10 + 4) = a2;
      *(_WORD *)(v10 + 12) = 2080;
      *(void *)(v10 + 14) = v11;
      __SC_log_send(7LL, v5, v6, v8);
    }
  }

  return v4;
}

uint64_t sub_21D74(const __CFDictionary *a1, const void *a2, uint64_t a3)
{
  uint64_t v4 = sub_211CC(a1, a2, a3);
  if (G_IPConfiguration_verbose)
  {
    uint64_t v5 = sub_57538();
    uint64_t v6 = _SC_syslog_os_log_mapping(7LL);
    if (__SC_log_enabled(7LL, v5, v6))
    {
      uint64_t v7 = _os_log_pack_size(18LL);
      uint64_t v8 = (char *)&v12 - ((__chkstk_darwin(v7) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v9 = __error();
      uint64_t v10 = _os_log_pack_fill(v8, v7, *v9, &dword_0, "%@ = %d");
      *(_DWORD *)uint64_t v10 = 138412546;
      *(void *)(v10 + 4) = a2;
      *(_WORD *)(v10 + 12) = 1024;
      *(_DWORD *)(v10 + 14) = v4;
      __SC_log_send(7LL, v5, v6, v8);
    }
  }

  return v4;
}

double sub_21EAC(const __CFDictionary *a1, const void *a2, double a3)
{
  Value = CFDictionaryGetValue(a1, a2);
  CFTypeID TypeID = CFNumberGetTypeID();
  if (Value
    && CFGetTypeID(Value) == TypeID
    && CFNumberGetValue((CFNumberRef)Value, kCFNumberDoubleType, &valuePtr) == 1)
  {
    a3 = valuePtr;
  }

  if (G_IPConfiguration_verbose)
  {
    uint64_t v7 = sub_57538();
    uint64_t v8 = _SC_syslog_os_log_mapping(7LL);
    if (__SC_log_enabled(7LL, v7, v8))
    {
      uint64_t v9 = _os_log_pack_size(22LL);
      uint64_t v10 = (char *)&valuePtr - ((__chkstk_darwin(v9) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v11 = __error();
      uint64_t v12 = _os_log_pack_fill(v10, v9, *v11, &dword_0, "%@ = %g");
      *(_DWORD *)uint64_t v12 = 138412546;
      *(void *)(v12 + 4) = a2;
      *(_WORD *)(v12 + 12) = 2048;
      *(double *)(v12 + 14) = a3;
      __SC_log_send(7LL, v7, v8, v10);
    }
  }

  return a3;
}

void *sub_22020(const __CFDictionary *a1, const void *a2, unsigned int a3, _DWORD *a4)
{
  Value = (const __CFArray *)CFDictionaryGetValue(a1, a2);
  CFTypeID TypeID = CFArrayGetTypeID();
  if (Value && CFGetTypeID(Value) == TypeID) {
    return sub_2208C(Value, a3, a4);
  }
  else {
    return 0LL;
  }
}

void *sub_2208C(const __CFArray *a1, unsigned int a2, _DWORD *a3)
{
  if (a2 <= 4
    && ((1 << a2) & 0x16) != 0
    && (CFIndex Count = CFArrayGetCount(a1)) != 0
    && (uint64_t v7 = Count, (v8 = malloc(Count * a2)) != 0LL))
  {
    uint64_t v9 = v8;
    if (v7 < 1)
    {
      *a3 = 0;
LABEL_20:
      free(v9);
      return 0LL;
    }

    uint64_t v16 = a3;
    CFIndex v10 = 0LL;
    int v11 = 0;
    uint64_t v12 = v8;
    do
    {
      ValueAtIndex = CFArrayGetValueAtIndex(a1, v10);
      CFTypeID TypeID = CFNumberGetTypeID();
      if (ValueAtIndex
        && CFGetTypeID(ValueAtIndex) == TypeID
        && CFNumberGetValue((CFNumberRef)ValueAtIndex, kCFNumberIntType, &valuePtr))
      {
        if (a2 == 2)
        {
          _WORD *v12 = valuePtr;
        }

        else if (a2 == 1)
        {
          *(_BYTE *)uint64_t v12 = valuePtr;
        }

        ++v11;
        uint64_t v12 = (_WORD *)((char *)v12 + a2);
      }

      ++v10;
    }

    while (v7 != v10);
    *uint64_t v16 = v11;
    if (!v11) {
      goto LABEL_20;
    }
  }

  else
  {
    uint64_t v9 = 0LL;
    *a3 = 0;
  }

  return v9;
}

CFMutableArrayRef sub_221D4(const __SCPreferences *a1)
{
  CFPropertyListRef Value = SCPreferencesGetValue(a1, @"Application");
  CFTypeID TypeID = CFDictionaryGetTypeID();
  if (!Value || CFGetTypeID(Value) != TypeID) {
    return 0LL;
  }
  if (G_IPConfiguration_verbose)
  {
    uint64_t v3 = sub_57538();
    uint64_t v4 = _SC_syslog_os_log_mapping(7LL);
    if (__SC_log_enabled(7LL, v3, v4))
    {
      uint64_t v5 = _os_log_pack_size(12LL);
      uint64_t v6 = (char *)&v11 - ((__chkstk_darwin(v5) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v7 = __error();
      uint64_t v8 = _os_log_pack_fill(v6, v5, *v7, &dword_0, "dictionary is %@");
      *(_DWORD *)uint64_t v8 = 138412290;
      *(void *)(v8 + 4) = Value;
      __SC_log_send(7LL, v3, v4, v6);
    }
  }

  CFMutableArrayRef Mutable = CFArrayCreateMutable(0LL, 0LL, &kCFTypeArrayCallBacks);
  if (Mutable)
  {
    CFDictionaryApplyFunction((CFDictionaryRef)Value, (CFDictionaryApplierFunction)sub_22360, Mutable);
    if (!CFArrayGetCount(Mutable))
    {
      CFRelease(Mutable);
      return 0LL;
    }
  }

  return Mutable;
}

void sub_22360(uint64_t a1, const __CFDictionary *a2, void *a3)
{
  CFTypeID TypeID = CFDictionaryGetTypeID();
  if (a2)
  {
    if (CFGetTypeID(a2) == TypeID)
    {
      CFPropertyListRef Value = (const __CFArray *)CFDictionaryGetValue(a2, @"DHCPRequestedParameterList");
      CFTypeID v7 = CFArrayGetTypeID();
      if (Value)
      {
        if (CFGetTypeID(Value) == v7)
        {
          v8.length = CFArrayGetCount(Value);
          v8.location = 0LL;
          CFArrayApplyFunction(Value, v8, (CFArrayApplierFunction)sub_22404, a3);
        }
      }
    }
  }

void sub_22404(const void *a1, const __CFArray *a2)
{
  CFTypeID TypeID = CFNumberGetTypeID();
  if (a1)
  {
    if (CFGetTypeID(a1) == TypeID) {
      sub_50324(a2, a1);
    }
  }

void sub_22460(SCDynamicStoreRef store)
{
  if (store)
  {
    if (qword_6C148)
    {
      free((void *)qword_6C148);
      qword_6C148 = 0LL;
    }

    CFStringRef theString = SCDynamicStoreCopyComputerName(store, &nameEncoding);
    if (!theString) {
      goto LABEL_19;
    }
    if (_SC_CFStringIsValidDNSName())
    {
      MutableCopy = (__CFString *)theString;
    }

    else
    {
      sub_4FA18((const void **)&theString);
      CFStringRef theString = SCDynamicStoreCopyLocalHostName(store);
      CFIndex Length = CFStringGetLength(theString);
      uint64_t v4 = theString;
      if (Length <= dword_6C0D0)
      {
        MutableCopy = (__CFString *)theString;
      }

      else
      {
        uint64_t v5 = dword_6C0D0;
        if (dword_6C0D0 < 3 || !theString) {
          goto LABEL_19;
        }
        MutableCopy = CFStringCreateMutableCopy(kCFAllocatorDefault, 0LL, theString);
        v12.length = CFStringGetLength(v4);
        v12.location = 0LL;
        CFStringFindAndReplace(MutableCopy, @"macbook-air", @"Air", v12, 1uLL);
        v13.length = CFStringGetLength(v4);
        v13.location = 0LL;
        CFStringFindAndReplace(MutableCopy, @"macbook-pro", @"MBP", v13, 1uLL);
        v14.length = CFStringGetLength(v4);
        v14.location = 0LL;
        CFStringFindAndReplace(MutableCopy, @"mac-mini", @"Mini", v14, 1uLL);
        v15.length = CFStringGetLength(v4);
        v15.location = 0LL;
        CFStringFindAndReplace(MutableCopy, @"mac-pro", @"Pro", v15, 1uLL);
        CFIndex v6 = CFStringGetLength(MutableCopy);
        if (v6 > v5)
        {
          v16.length = v6 - 1;
          v16.location = 0LL;
          CFStringFindAndReplace(MutableCopy, @"-", &stru_67670, v16, 1uLL);
          CFIndex v7 = CFStringGetLength(MutableCopy);
          if (v7 > v5)
          {
            v11.location = v5 >> 1;
            v11.length = v7 - v5;
            CFStringDelete(MutableCopy, v11);
          }
        }

        if (!MutableCopy) {
          goto LABEL_19;
        }
        sub_4FA18((const void **)&theString);
        CFStringRef theString = MutableCopy;
      }
    }

    if (CFStringGetCString(MutableCopy, buffer, 256LL, 0x600u)) {
      qword_6C148 = (uint64_t)strdup(buffer);
    }
LABEL_19:
    sub_4FA18((const void **)&theString);
  }

void sub_226B0(const __SCDynamicStore *a1, CFStringRef theString)
{
  if (CFStringHasPrefix(theString, (CFStringRef)qword_6C1D0))
  {
    uint64_t v4 = (const __CFString *)sub_5039C(theString, @"/", 3LL);
    uint64_t v86 = v4;
    if (v4)
    {
      sub_4FC44(v4, (UInt8 *)__s2, 17, 0);
      sub_4FA18((const void **)&v86);
      uint64_t v5 = sub_19E70(__s2, 0LL);
      CFPropertyListRef v6 = sub_373B8(a1, theString);
      int v87 = v6;
      if (v6 && CFDictionaryContainsKey((CFDictionaryRef)v6, kSCPropNetLinkDetaching))
      {
        if (v5)
        {
          sub_1C6A8(v5, 1);
          sub_1C70C(v5, 1);
        }

        goto LABEL_59;
      }

      uint64_t v7 = sub_540BC((uint64_t *)qword_6C188, __s2);
      if (v7)
      {
        uint64_t v8 = v7;
        unint64_t v9 = sub_54F84(v7);
        int v11 = v10;
        unint64_t v84 = v9;
        int v85 = v10;
        CFRange v12 = (const char *)v9;
        if ((_DWORD)v9)
        {
          int v13 = sub_54B5C(v8);
          if (!v5) {
            goto LABEL_59;
          }
        }

        else
        {
          int v13 = 0;
          if (!v5) {
            goto LABEL_59;
          }
        }

        int v14 = *(_DWORD *)v5;
        if ((*(_DWORD *)v5 & 0x10) == 0)
        {
          CFRange v15 = (const char *)HIDWORD(v9);
          *(_BYTE *)(v5 + 168) = 0;
          *(_DWORD *)uint64_t v5 = v14 & 0xFFE7FFF7;
          sub_54B30(*(void *)(v5 + 8), v8);
          uint64_t v16 = sub_57538();
          uint64_t v17 = _SC_syslog_os_log_mapping(5LL);
          int v18 = __SC_log_enabled(5LL, v16, v17);
          if (v12)
          {
            if (!v18) {
              goto LABEL_31;
            }
            uint64_t v19 = _os_log_pack_size(62LL);
            int v82 = &v77;
            __int128 v20 = (char *)&v77 - ((__chkstk_darwin(v19) + 15) & 0xFFFFFFFFFFFFFFF0LL);
            uint64_t v21 = __error();
            uint64_t v22 = _os_log_pack_fill( v20,  v19,  *v21,  &dword_0,  "%s link %s%s%s%s%s",  v77,  v78,  v79,  v80,  v81,  (const char *)v82);
            if ((_DWORD)v15) {
              CFStringRef v23 = "ACTIVE";
            }
            else {
              CFStringRef v23 = "INACTIVE";
            }
            int v24 = " [link address changed]";
            uint64_t v81 = v15;
            if (!v13) {
              int v24 = "";
            }
            uint64_t v78 = v24;
            uint64_t v79 = v23;
            uint64_t v25 = " [wake on same network]";
            if (!v11) {
              uint64_t v25 = "";
            }
            uint64_t v77 = v25;
            int v26 = sub_54EB4(v8);
            uint64_t v80 = v12;
            uint64_t v27 = v17;
            uint64_t v28 = v16;
            int v29 = v13;
            if (v26) {
              uint64_t v30 = " [expensive]";
            }
            else {
              uint64_t v30 = "";
            }
            int v31 = sub_54EA8(v8);
            *(void *)(v22 + 4) = __s2;
            CFTypeRef v32 = " [carplay]";
            *(_DWORD *)uint64_t v22 = 136316418;
            *(_WORD *)(v22 + 12) = 2080;
            if (!v31) {
              CFTypeRef v32 = "";
            }
            *(void *)(v22 + 14) = v79;
            *(_WORD *)(v22 + 22) = 2080;
            *(void *)(v22 + 24) = v78;
            *(_WORD *)(v22 + 32) = 2080;
            *(void *)(v22 + 34) = v77;
            *(_WORD *)(v22 + 42) = 2080;
            *(void *)(v22 + 44) = v30;
            int v13 = v29;
            uint64_t v16 = v28;
            uint64_t v17 = v27;
            CFRange v12 = v80;
            CFRange v15 = v81;
            *(_WORD *)(v22 + 52) = 2080;
            *(void *)(v22 + 54) = v32;
          }

          else
          {
            if (!v18) {
              goto LABEL_31;
            }
            uint64_t v33 = _os_log_pack_size(12LL);
            int v82 = &v77;
            __int128 v20 = (char *)&v77 - ((__chkstk_darwin(v33) + 15) & 0xFFFFFFFFFFFFFFF0LL);
            CFPropertyListRef v34 = __error();
            uint64_t v35 = _os_log_pack_fill(v20, v33, *v34, &dword_0, "%s link is unknown", v77);
            *(_DWORD *)uint64_t v35 = 136315138;
            *(void *)(v35 + 4) = __s2;
          }

          __SC_log_send(5LL, v16, v17, v20);
LABEL_31:
          if (!v13 && dword_6C1A8 != *(_DWORD *)(v5 + 116))
          {
            uint64_t v36 = sub_57538();
            uint64_t v37 = _SC_syslog_os_log_mapping(5LL);
            if (__SC_log_enabled(5LL, v36, v37))
            {
              uint64_t v38 = _os_log_pack_size(12LL);
              uint64_t v81 = v15;
              int v39 = (char *)&v77 - ((__chkstk_darwin(v38) + 15) & 0xFFFFFFFFFFFFFFF0LL);
              signed int v40 = __error();
              uint64_t v41 = _os_log_pack_fill(v39, v38, *v40, &dword_0, "%s: link status changed at wake", v77);
              *(_DWORD *)uint64_t v41 = 136315138;
              *(void *)(v41 + 4) = __s2;
              __SC_log_send(5LL, v36, v37, v39);
              LODWORD(v15) = (_DWORD)v81;
            }

            sub_25210(v5);
            if (v11) {
              goto LABEL_59;
            }
          }

          sub_2560C((const void **)v5, (uint64_t)v83, (uint64_t *)&v84);
          if (v12) {
            BOOL v42 = (_DWORD)v15 == 0;
          }
          else {
            BOOL v42 = 0;
          }
          int v43 = !v42;
          if (v42)
          {
            if (byte_6C1D8 == 1)
            {
              uint64_t v44 = sub_57538();
              uint64_t v45 = _SC_syslog_os_log_mapping(6LL);
              if (__SC_log_enabled(6LL, v44, v45))
              {
                uint64_t v46 = _os_log_pack_size(12LL);
                CFIndex v47 = (char *)&v77 - ((__chkstk_darwin(v46) + 15) & 0xFFFFFFFFFFFFFFF0LL);
                int v48 = __error();
                uint64_t v49 = _os_log_pack_fill( v47,  v46,  *v48,  &dword_0,  "%s: suppressing link inactive timer (going to sleep)",  v77);
                *(_DWORD *)uint64_t v49 = 136315138;
                *(void *)(v49 + 4) = __s2;
                __SC_log_send(6LL, v44, v45, v47);
              }

              timer_cancel(*(void *)(v5 + 104));
              *(_DWORD *)v5 |= 0x20u;
            }

            else
            {
              *(_DWORD *)v5 &= ~0x20u;
              uint64_t v50 = sub_57538();
              uint64_t v51 = _SC_syslog_os_log_mapping(6LL);
              if (__SC_log_enabled(6LL, v50, v51))
              {
                uint64_t v52 = _os_log_pack_size(22LL);
                dispatch_queue_t v53 = (char *)&v77 - ((__chkstk_darwin(v52) + 15) & 0xFFFFFFFFFFFFFFF0LL);
                CFMutableDictionaryRef v54 = __error();
                uint64_t v55 = _os_log_pack_fill( v53,  v52,  *v54,  &dword_0,  "%s: scheduling link inactive timer for %g secs",  v77,  *(double *)&v78);
                uint64_t v56 = qword_6C0C8;
                *(_DWORD *)uint64_t v55 = 136315394;
                *(void *)(v55 + 4) = __s2;
                *(_WORD *)(v55 + 12) = 2048;
                *(void *)(v55 + 14) = v56;
                __SC_log_send(6LL, v50, v51, v53);
              }

              timer_callout_set(*(void *)(v5 + 104), (uint64_t)sub_25890, v5, 0LL, 0LL, *(double *)&qword_6C0C8);
            }
          }

          else
          {
            *(_DWORD *)v5 &= ~0x20u;
            timer_cancel(*(void *)(v5 + 104));
          }

          if (v13)
          {
            uint64_t v59 = sub_57538();
            uint64_t v60 = _SC_syslog_os_log_mapping(5LL);
            if (__SC_log_enabled(5LL, v59, v60))
            {
              uint64_t v61 = _os_log_pack_size(12LL);
              int v62 = (char *)&v77 - ((__chkstk_darwin(v61) + 15) & 0xFFFFFFFFFFFFFFF0LL);
              int v63 = __error();
              uint64_t v64 = _os_log_pack_fill(v62, v61, *v63, &dword_0, "%s: link address changed", v77);
              uint64_t v65 = nullsub_1(v8);
              *(_DWORD *)uint64_t v64 = 136315138;
              *(void *)(v64 + 4) = v65;
              __SC_log_send(5LL, v59, v60, v62);
            }

            int v66 = (const char *)nullsub_1(v8);
            sub_33618(v66);
          }

          if (sub_50C94(v5 + 24))
          {
            int v67 = (const char *)nullsub_1(v8);
            int v68 = sub_31F94(v67, v43);
            BOOL v69 = v68 == 0;
            if (!sub_50C94(v5 + 56))
            {
              if (!v68) {
                goto LABEL_72;
              }
              goto LABEL_53;
            }
          }

          else
          {
            BOOL v69 = 0;
          }

          if (sub_20FA4(v5, v43) || v69)
          {
LABEL_72:
            uint64_t v70 = sub_57538();
            uint64_t v71 = _SC_syslog_os_log_mapping(5LL);
            if (__SC_log_enabled(5LL, v70, v71))
            {
              uint64_t v72 = _os_log_pack_size(12LL);
              int v73 = (char *)&v77 - ((__chkstk_darwin(v72) + 15) & 0xFFFFFFFFFFFFFFF0LL);
              int v74 = __error();
              uint64_t v75 = _os_log_pack_fill( v73,  v72,  *v74,  &dword_0,  "%s: interface reattached, forcing link timer expired",  v77);
              uint64_t v76 = nullsub_1(v8);
              *(_DWORD *)uint64_t v75 = 136315138;
              *(void *)(v75 + 4) = v76;
              __SC_log_send(5LL, v70, v71, v73);
            }

            sub_1DD80(v5, 4LL, 0LL);
          }

LABEL_53:
          if ((int)sub_50C94(v5 + 24) >= 1)
          {
            uint64_t v57 = 0LL;
            do
            {
              uint64_t v58 = sub_50C98(v5 + 24, v57);
              if ((*(_BYTE *)(v58 + 25) & 1) != 0) {
                *(_DWORD *)(v58 + 116) &= ~4u;
              }
              sub_1B834(v58, 3LL, (uint64_t)v83);
              uint64_t v57 = (v57 + 1);
            }

            while ((int)v57 < (int)sub_50C94(v5 + 24));
          }

          sub_21780(v5 + 56, 3LL, (uint64_t)v83);
        }
      }

        uint64_t v21 = 0;
      }

  theDict = Mutable;
  uint64_t v44 = 0LL;
  uint64_t v46 = 0LL;
  *(void *)CFIndex v47 = 0LL;
  theArray = 0LL;
  int v26 = *(void *)(a3 + 16);
  if (v26)
  {
    uint64_t v27 = sub_57BD4(*(void *)(a3 + 16), 23, (unsigned int *)&v49, 0LL);
    uint64_t v28 = 0LL;
    if (v27)
    {
      int v29 = 0LL;
      if (v49 >= 0x10)
      {
        uint64_t v30 = (char *)v27;
        int v31 = v49 >> 4;
        int v29 = CFArrayCreateMutable(0LL, (uint64_t)v49 >> 4, &kCFTypeArrayCallBacks);
        sub_39380(v29, v30, v31);
        else {
          uint64_t v28 = 0LL;
        }
      }
    }

    else
    {
      int v29 = 0LL;
    }

    uint64_t v46 = v29;
    *(void *)CFIndex v47 = v28;
  }

  else
  {
    uint64_t v28 = 0LL;
    int v29 = 0LL;
  }

  uint64_t v33 = *(void *)(a3 + 40);
  if (v33)
  {
    CFPropertyListRef v34 = sub_39064(v33, a1, (uint64_t *)&theArray);
    uint64_t v44 = v34;
  }

  else
  {
    CFPropertyListRef v34 = 0LL;
  }

  if (!((unint64_t)v29 | (unint64_t)v34))
  {
LABEL_69:
    uint64_t v35 = 0LL;
    goto LABEL_70;
  }

  uint64_t v35 = CFDictionaryCreateMutable(0LL, 0LL, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  uint64_t v38 = &v46;
  if (v29)
  {
    if (v34)
    {
      sub_392E8(v29, v34);
      uint64_t v38 = &v46;
      uint64_t v28 = *(__CFArray **)v47;
    }
  }

  else
  {
    uint64_t v38 = &v44;
  }

  CFDictionarySetValue(v35, kSCPropNetDNSServerAddresses, *v38);
  int v39 = theArray;
  if (!v28)
  {
    if (!theArray) {
      goto LABEL_89;
    }
    uint64_t v41 = kSCPropNetDNSSearchDomains;
    BOOL v42 = v35;
LABEL_88:
    CFDictionarySetValue(v42, v41, v39);
    goto LABEL_89;
  }

  if (!theArray)
  {
    uint64_t v41 = kSCPropNetDNSSearchDomains;
    BOOL v42 = v35;
    int v39 = v28;
    goto LABEL_88;
  }

  MutableCopy = CFArrayCreateMutableCopy(0LL, 0LL, v28);
  sub_392E8(MutableCopy, theArray);
  CFDictionarySetValue(v35, kSCPropNetDNSSearchDomains, MutableCopy);
  CFRelease(MutableCopy);
LABEL_89:
  sub_4FA18((const void **)v47);
  sub_4FA18(&v46);
  sub_4FA18((const void **)&theArray);
  sub_4FA18(&v44);
  CFMutableArrayRef Mutable = theDict;
LABEL_70:
  *(void *)CFIndex v47 = v35;
  if (Mutable && v35)
  {
    uint64_t v35 = CFDictionaryCreateMutableCopy(0LL, 0LL, Mutable);
    uint64_t v36 = *(const __CFDictionary **)v47;
    sub_38348(v35, theDict, *(const __CFDictionary **)v47, (void *)kSCPropNetDNSServerAddresses);
    sub_38348(v35, theDict, v36, (void *)kSCPropNetDNSSearchDomains);
    sub_4FA18((const void **)&theDict);
    sub_4FA18((const void **)v47);
  }

  else if (Mutable)
  {
    return Mutable;
  }

  return v35;
}

void sub_22F8C(const __CFString *a1)
{
  uint64_t v22 = 0LL;
  if (CFStringHasPrefix(a1, (CFStringRef)qword_6C1D0))
  {
    CFTypeRef v2 = sub_5039C(a1, @"/", 3LL);
    CFStringRef v23 = v2;
    if (v2)
    {
      uint64_t v3 = sub_25BD8(v2);
      sub_4FA18(&v23);
      if (v3)
      {
        if ((*(_BYTE *)v3 & 0x10) == 0)
        {
          uint64_t v4 = (uint64_t *)qword_6C188;
          uint64_t v5 = (char *)nullsub_1(*(void *)(v3 + 8));
          uint64_t v6 = sub_540BC(v4, v5);
          if (v6)
          {
            uint64_t v7 = v6;
            unint64_t v8 = sub_54F84(v6);
            if (sub_54E84(*(void *)(v3 + 8)))
            {
              if (HIDWORD(v8) || v8 == 0LL)
              {
                uint64_t v10 = *(void *)(v3 + 8);
                if (!*(_DWORD *)(v10 + 80) || *(_DWORD *)(v10 + 84))
                {
                  int v11 = (const void *)sub_20B70(*(void *)(v3 + 16));
                  uint64_t v22 = v11;
                  if (sub_2A638(*(void *)(v3 + 96), (uint64_t)v11) == 3)
                  {
                    if (!sub_54E90(v7))
                    {
                      uint64_t v12 = sub_57538();
                      uint64_t v13 = _SC_syslog_os_log_mapping(5LL);
                      if (__SC_log_enabled(5LL, v12, v13))
                      {
                        uint64_t v14 = _os_log_pack_size(12LL);
                        CFRange v15 = (char *)&v21 - ((__chkstk_darwin(v14) + 15) & 0xFFFFFFFFFFFFFFF0LL);
                        uint64_t v16 = __error();
                        uint64_t v17 = _os_log_pack_fill(v15, v14, *v16, &dword_0, "%s: Wi-Fi roam", v21);
                        uint64_t v18 = nullsub_1(v7);
                        *(_DWORD *)uint64_t v17 = 136315138;
                        *(void *)(v17 + 4) = v18;
                        __SC_log_send(5LL, v12, v13, v15);
                      }
                    }

                    sub_20E44(v3, v11);
                    if (sub_50C94(v3 + 24))
                    {
                      uint64_t v19 = 0LL;
                      do
                      {
                        uint64_t v20 = sub_50C98(v3 + 24, v19);
                        if ((*(_BYTE *)(v20 + 25) & 1) != 0) {
                          *(_DWORD *)(v20 + 116) &= ~4u;
                        }
                        sub_1B834(v20, 16LL, 0LL);
                        uint64_t v19 = (v19 + 1);
                      }

                      while (v19 < sub_50C94(v3 + 24));
                    }

                    sub_21780(v3 + 56, 16LL, 0LL);
                  }
                }
              }
            }
          }
        }
      }

      sub_4FA18(&v22);
    }
  }

void sub_231FC(const __CFString *a1)
{
  if (CFStringHasPrefix(a1, (CFStringRef)qword_6C1D0))
  {
    CFTypeRef v2 = sub_5039C(a1, @"/", 3LL);
    CFRange v15 = v2;
    if (v2)
    {
      CFTypeRef v3 = v2;
      uint64_t v4 = sub_25BD8(v2);
      if (v4)
      {
        uint64_t v5 = v4;
        int v6 = sub_54F6C(*(void *)(v4 + 8));
        sub_35A4C((uint64_t)v16, v6);
        if (G_IPConfiguration_verbose)
        {
          uint64_t v7 = sub_35EFC((uint64_t)v16);
          uint64_t v8 = sub_57538();
          uint64_t v9 = _SC_syslog_os_log_mapping(4294967289LL);
          if (__SC_log_enabled(4294967289LL, v8, v9))
          {
            uint64_t v10 = _os_log_pack_size(22LL);
            int v11 = (char *)&v14 - ((__chkstk_darwin(v10) + 15) & 0xFFFFFFFFFFFFFFF0LL);
            uint64_t v12 = __error();
            uint64_t v13 = _os_log_pack_fill(v11, v10, *v12, &dword_0, "%@: IPv6 address list = %@");
            *(_DWORD *)uint64_t v13 = 138412546;
            *(void *)(v13 + 4) = v3;
            *(_WORD *)(v13 + 12) = 2112;
            *(void *)(v13 + 14) = v7;
            __SC_log_send(4294967289LL, v8, v9, v11);
          }

          CFRelease(v7);
        }

        sub_25C58(v5, (uint64_t)v16);
        sub_21780(v5 + 56, 15LL, (uint64_t)v16);
        sub_25F90(v5, v16);
        sub_36090((uint64_t)v16);
      }

      sub_4FA18(&v15);
    }
  }

void sub_233D0(const __SCDynamicStore *a1, CFStringRef theString)
{
  if (CFStringHasPrefix(theString, (CFStringRef)qword_6C1D0))
  {
    CFTypeRef v4 = sub_5039C(theString, @"/", 3LL);
    uint64_t v30 = v4;
    if (v4)
    {
      CFTypeRef v5 = v4;
      uint64_t v6 = sub_25BD8(v4);
      if (v6)
      {
        uint64_t v7 = (int *)v6;
        uint64_t v8 = (const char *)nullsub_1(*(void *)(v6 + 8));
        int v9 = sub_34218(v8);
        int v29 = v9;
        int v10 = *v7;
        if (v9)
        {
          int v11 = v10 | 0x100000;
        }

        else
        {
          int *v7 = v10 & 0xFFEFFFFF;
          uint64_t v19 = (const __CFDictionary *)sub_373B8(a1, theString);
          if (!v19
            || (uint64_t v20 = v19,
                int v21 = CFDictionaryContainsKey(v19, kSCPropNetNAT64PLATDiscoveryCompletionTime),
                CFRelease(v20),
                !v21))
          {
            uint64_t v22 = sub_57538();
            uint64_t v23 = _SC_syslog_os_log_mapping(7LL);
            if (__SC_log_enabled(7LL, v22, v23))
            {
              uint64_t v24 = _os_log_pack_size(12LL);
              uint64_t v25 = &v28[-((__chkstk_darwin(v24) + 15) & 0xFFFFFFFFFFFFFFF0LL)];
              int v26 = __error();
              uint64_t v27 = _os_log_pack_fill(v25, v24, *v26, &dword_0, "%@: PLATDiscovery incomplete");
              *(_DWORD *)uint64_t v27 = 138412290;
              *(void *)(v27 + 4) = v5;
              __SC_log_send(7LL, v22, v23, v25);
            }

            goto LABEL_11;
          }

          int v11 = *v7;
        }

        int *v7 = v11 | 0x80000;
        uint64_t v12 = sub_57538();
        uint64_t v13 = _SC_syslog_os_log_mapping(6LL);
        if (__SC_log_enabled(6LL, v12, v13))
        {
          uint64_t v14 = _os_log_pack_size(22LL);
          CFRange v15 = &v28[-((__chkstk_darwin(v14) + 15) & 0xFFFFFFFFFFFFFFF0LL)];
          uint64_t v16 = __error();
          uint64_t v17 = _os_log_pack_fill(v15, v14, *v16, &dword_0, "%@: PLATDiscovery complete (%sNAT64)");
          uint64_t v18 = "";
          if (!v9) {
            uint64_t v18 = "no ";
          }
          *(_DWORD *)uint64_t v17 = 138412546;
          *(void *)(v17 + 4) = v5;
          *(_WORD *)(v17 + 12) = 2080;
          *(void *)(v17 + 14) = v18;
          __SC_log_send(6LL, v12, v13, v15);
        }

        sub_21780((uint64_t)(v7 + 14), 19LL, (uint64_t)&v29);
      }

LABEL_11:
      sub_4FA18(&v30);
    }
  }

  *(NDR_record_t *)(a2 + 24) = v5;
  return result;
}

  *(NDR_record_t *)(a2 + 24) = v5;
  return result;
}

  *(NDR_record_t *)(a2 + 24) = v5;
  return result;
}

  *(NDR_record_t *)(a2 + 24) = v5;
  return result;
}

  *(NDR_record_t *)(a2 + 24) = v5;
  return result;
}

      sub_4F718(v3);
      return 0xFFFFFFFFLL;
    }
  }

  return v3;
}

void sub_23678(const __CFString *a1)
{
  if (CFStringHasPrefix(a1, (CFStringRef)qword_6C1D0))
  {
    CFTypeRef v2 = sub_5039C(a1, @"/", 3LL);
    uint64_t v17 = v2;
    if (v2)
    {
      CFTypeRef v3 = v2;
      uint64_t v4 = sub_25BD8(v2);
      if (v4)
      {
        uint64_t v5 = v4;
        uint64_t v16 = 0LL;
        int v6 = sub_54F6C(*(void *)(v4 + 8));
        HIDWORD(v16) = sub_34B04(v6, &v16);
        uint64_t v7 = sub_57538();
        uint64_t v8 = _SC_syslog_os_log_mapping(5LL);
        if (__SC_log_enabled(5LL, v7, v8))
        {
          uint64_t v9 = _os_log_pack_size(24LL);
          int v10 = (char *)&v15 - ((__chkstk_darwin(v9) + 15) & 0xFFFFFFFFFFFFFFF0LL);
          int v11 = __error();
          uint64_t v12 = _os_log_pack_fill( v10,  v9,  *v11,  &dword_0,  "%@: IPv6 router expired, router count %d prefix count %d");
          int v14 = v16;
          int v13 = HIDWORD(v16);
          *(_DWORD *)uint64_t v12 = 138412802;
          *(void *)(v12 + 4) = v3;
          *(_WORD *)(v12 + 12) = 1024;
          *(_DWORD *)(v12 + 14) = v13;
          *(_WORD *)(v12 + 18) = 1024;
          *(_DWORD *)(v12 + 20) = v14;
          __SC_log_send(5LL, v7, v8, v10);
        }

        sub_21780(v5 + 56, 18LL, (uint64_t)&v16);
      }

      sub_4FA18(&v17);
    }
  }

void sub_2380C(const __SCDynamicStore *a1, CFStringRef theString)
{
  int v11 = 0LL;
  CFTypeRef v3 = sub_37CA8(theString, &v8, &v11, &v10);
  uint64_t v9 = v3;
  uint64_t v4 = v11;
  if (v3 && v11)
  {
    uint64_t v5 = sub_25BD8(v3);
    if (v5)
    {
      uint64_t v6 = v5;
      if ((*(_BYTE *)v5 & 0x10) == 0)
      {
        uint64_t v7 = sub_54E28(*(void *)(v5 + 8));
        if (!sub_1F594(v7, v7, v11, v10))
        {
          __int128 v13 = 0u;
          v14[0] = 0LL;
          v12[0] = v8.s_addr;
          v12[1] = v11;
          LODWORD(v13) = v10;
          DWORD1(v13) = sub_267B4(a1, *(CFStringRef *)(v6 + 16), v11, v10, (in_addr *)&v13 + 2, v14);
          sub_21780(v6 + 24, 9LL, (uint64_t)v12);
          sub_4FA18(v14);
        }
      }
    }

    uint64_t v4 = v11;
  }

  if (v4) {
    free(v4);
  }
  sub_4FA18(&v9);
}

uint64_t sub_2390C()
{
  uint64_t v0 = sub_54238();
  if (v0)
  {
    uint64_t v1 = (uint64_t)v0;
    if (qword_6C188) {
      sub_54A08(&qword_6C188);
    }
    qword_6C188 = v1;
    return 1LL;
  }

  else
  {
    uint64_t v3 = sub_57538();
    uint64_t v4 = _SC_syslog_os_log_mapping(5LL);
    uint64_t result = __SC_log_enabled(5LL, v3, v4);
    if ((_DWORD)result)
    {
      uint64_t v5 = _os_log_pack_size(2LL);
      uint64_t v6 = (char *)&v8 - ((__chkstk_darwin(v5) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v7 = __error();
      *(_WORD *)_os_log_pack_fill(v6, v5, *v7, &dword_0, "IPConfiguration: ifl_init failed") = 0;
      __SC_log_send(5LL, v3, v4, v6);
      return 0LL;
    }
  }

  return result;
}

void sub_23A38()
{
  uint64_t v0 = sub_50C94(qword_6C150);
  if (!(_DWORD)v0) {
    return;
  }
  uint64_t v1 = v0;
  CFTypeRef v2 = (const char **)malloc(8LL * (int)v0);
  if (!v2) {
    return;
  }
  uint64_t v4 = v2;
  int v5 = 0;
  uint64_t v6 = 0LL;
  uint64_t v7 = qword_6C150;
  uint64_t v8 = &off_6C000;
  *(void *)&__int128 v3 = 136315650LL;
  __int128 v33 = v3;
  CFPropertyListRef v34 = v2;
  do
  {
    uint64_t v9 = sub_50C98(v7, v6);
    int v10 = (uint64_t *)v8[49];
    int v11 = (char *)nullsub_1(*(void *)(v9 + 8));
    uint64_t v12 = sub_540BC(v10, v11);
    if (v12)
    {
      uint64_t v13 = v12;
      int v14 = sub_54F6C(v12);
      uint64_t v15 = sub_57538();
      uint64_t v16 = _SC_syslog_os_log_mapping(5LL);
      unsigned int v17 = v16;
      if (__SC_log_enabled(5LL, v15, v16))
      {
        uint64_t v18 = _os_log_pack_size(24LL);
        uint64_t v37 = &v33;
        uint64_t v19 = (char *)&v33 - ((__chkstk_darwin(v18) + 15) & 0xFFFFFFFFFFFFFFF0LL);
        uint64_t v20 = __error();
        uint64_t v21 = _os_log_pack_fill( v19,  v18,  *v20,  &dword_0,  "%s: index changed from %d => %d",  (const char *)v33,  DWORD2(v33),  (_DWORD)v34);
        uint64_t v22 = nullsub_1(v13);
        unsigned int v36 = v17;
        uint64_t v23 = v7;
        uint64_t v24 = v22;
        int v25 = sub_54F6C(*(void *)(v9 + 8));
        uint64_t v35 = v15;
        uint64_t v26 = v1;
        int v27 = v25;
        int v28 = sub_54F6C(v13);
        *(_DWORD *)uint64_t v21 = v33;
        *(void *)(v21 + 4) = v24;
        uint64_t v7 = v23;
        *(_WORD *)(v21 + 12) = 1024;
        *(_DWORD *)(v21 + 14) = v27;
        uint64_t v1 = v26;
        *(_WORD *)(v21 + 18) = 1024;
        *(_DWORD *)(v21 + 20) = v28;
        uint64_t v4 = v34;
        int v29 = v19;
        uint64_t v8 = &off_6C000;
        __SC_log_send(5LL, v35, v36, v29);
      }
    }

    v4[v5++] = (const char *)nullsub_1(*(void *)(v9 + 8));
LABEL_10:
    uint64_t v6 = (v6 + 1);
  }

  while ((_DWORD)v1 != (_DWORD)v6);
  if (v5 >= 1)
  {
    uint64_t v30 = v5;
    int v31 = v4;
    do
    {
      CFTypeRef v32 = *v31;
      unsigned int v38 = -1;
      if (sub_19E70(v32, &v38)) {
        sub_53DAC(qword_6C150, v38);
      }
      ++v31;
      --v30;
    }

    while (v30);
  }

LABEL_16:
  free(v4);
}

__CFArray *sub_23CA8(const __SCDynamicStore *a1, __CFArray **a2)
{
  CFMutableArrayRef v85 = 0LL;
  CFMutableArrayRef Mutable = CFArrayCreateMutable(0LL, 0LL, &kCFTypeArrayCallBacks);
  uint64_t v86 = CFArrayCreateMutable(0LL, 0LL, &kCFTypeArrayCallBacks);
  CFMutableArrayRef v4 = CFArrayCreateMutable(0LL, 0LL, &kCFTypeArrayCallBacks);
  __int128 v89 = v4;
  in_addr v88 = CFArrayCreateMutable(0LL, 0LL, &kCFTypeArrayCallBacks);
  CFStringRef NetworkServiceEntity = SCDynamicStoreKeyCreateNetworkServiceEntity( 0LL,  kSCDynamicStoreDomainSetup,  kSCCompAnyRegex,  kSCEntNetIPv4);
  CFArrayAppendValue(v86, NetworkServiceEntity);
  CFRelease(NetworkServiceEntity);
  CFStringRef v6 = SCDynamicStoreKeyCreateNetworkServiceEntity(0LL, kSCDynamicStoreDomainSetup, kSCCompAnyRegex, kSCEntNetIPv6);
  CFArrayAppendValue(v86, v6);
  CFRelease(v6);
  CFStringRef v80 = kSCEntNet6to4;
  CFStringRef v7 = SCDynamicStoreKeyCreateNetworkServiceEntity(0LL, kSCDynamicStoreDomainSetup, kSCCompAnyRegex, kSCEntNet6to4);
  CFArrayAppendValue(v86, v7);
  CFRelease(v7);
  CFStringRef v82 = kSCEntNetInterface;
  CFStringRef v8 = SCDynamicStoreKeyCreateNetworkServiceEntity(0LL, kSCDynamicStoreDomainSetup, kSCCompAnyRegex, kSCEntNetInterface);
  CFArrayAppendValue(v86, v8);
  CFRelease(v8);
  CFStringRef NetworkInterfaceEntity = SCDynamicStoreKeyCreateNetworkInterfaceEntity( 0LL,  kSCDynamicStoreDomainSetup,  kSCCompAnyRegex,  0LL);
  CFArrayAppendValue(v86, NetworkInterfaceEntity);
  CFRelease(NetworkInterfaceEntity);
  CFStringRef NetworkGlobalEntity = SCDynamicStoreKeyCreateNetworkGlobalEntity(0LL, kSCDynamicStoreDomainSetup, kSCEntNetIPv4);
  CFStringRef v84 = NetworkGlobalEntity;
  CFArrayAppendValue(Mutable, NetworkGlobalEntity);
  CFDictionaryRef v11 = SCDynamicStoreCopyMultiple(a1, Mutable, v86);
  int v83 = v11;
  if (!v11) {
    goto LABEL_68;
  }
  uint64_t v12 = v11;
  CFPropertyListRef Value = (const __CFDictionary *)CFDictionaryGetValue(v11, NetworkGlobalEntity);
  CFTypeID TypeID = CFDictionaryGetTypeID();
  if (Value)
  {
    if (CFGetTypeID(Value) == TypeID)
    {
      CFPropertyListRef Value = (const __CFDictionary *)CFDictionaryGetValue(Value, kSCPropNetServiceOrder);
      CFTypeID v15 = CFArrayGetTypeID();
      if (!Value) {
        goto LABEL_10;
      }
      if (CFGetTypeID(Value) == v15)
      {
        if (!CFArrayGetCount(Value)) {
          CFPropertyListRef Value = 0LL;
        }
        goto LABEL_10;
      }
    }

    CFPropertyListRef Value = 0LL;
  }

LABEL_68:
  sub_4FA18((const void **)&v83);
  sub_4FA18((const void **)&v84);
  sub_4FA18((const void **)&Mutable);
  sub_4FA18((const void **)&v86);
  sub_4FA18((const void **)&v85);
  if (v4 && !CFArrayGetCount(v4)) {
    sub_4FA18((const void **)&v89);
  }
  int v63 = v88;
  if (v88 && !CFArrayGetCount(v88))
  {
    sub_4FA18((const void **)&v88);
    int v63 = v88;
  }

  *a2 = v63;
  return v89;
}

uint64_t sub_24670(const __CFArray *a1, const __CFArray *a2)
{
  uint64_t result = sub_53FBC(qword_6C188);
  if ((int)result >= 1)
  {
    signed int v5 = 0;
    do
    {
      CFStringRef v6 = (_OWORD *)sub_53FC8(qword_6C188, v5);
      sub_247CC(v6, a1, 1LL);
      sub_247CC(v6, a2, 0LL);
      ++v5;
      uint64_t result = sub_53FBC(qword_6C188);
    }

    while (v5 < (int)result);
  }

  return result;
}

uint64_t sub_246F8(const void *a1, const void *a2, const __CFArray *a3)
{
  int v5 = sub_2474C(a3, a1);
  int v6 = sub_2474C(a3, a2);
  uint64_t v7 = -1LL;
  if (v5 >= v6) {
    uint64_t v7 = 1LL;
  }
  if (v5 == v6) {
    return 0LL;
  }
  else {
    return v7;
  }
}

CFIndex sub_2474C(const __CFArray *a1, const void *a2)
{
  uint64_t v2 = 1000000LL;
  if (a1)
  {
    CFIndex Count = CFArrayGetCount(a1);
    if (Count >= 1)
    {
      CFIndex v6 = Count;
      CFIndex v7 = 0LL;
      while (1)
      {
        ValueAtIndex = CFArrayGetValueAtIndex(a1, v7);
        if (CFEqual(ValueAtIndex, a2)) {
          break;
        }
        if (v6 == ++v7) {
          return v2;
        }
      }

      return v7;
    }
  }

  return v2;
}

void sub_247CC(_OWORD *a1, const __CFArray *a2, uint64_t a3)
{
  CFIndex v6 = (char *)nullsub_1(a1);
  LODWORD(a2) = sub_24A68((uint64_t)&v36, a3, a2, v6);
  CFIndex v7 = (const char *)nullsub_1(a1);
  if ((_DWORD)a2)
  {
    uint64_t v8 = sub_19E70(v7, 0LL);
    if (v8)
    {
      uint64_t v9 = v8;
      uint64_t v10 = v38 ? v8 + 24 : v8 + 56;
      CFMutableArrayRef Mutable = (CFTypeRef *)CFArrayCreateMutable(0LL, 0LL, &kCFTypeArrayCallBacks);
      CFTypeID v41 = Mutable;
      if (Mutable)
      {
        uint64_t v12 = (__CFArray *)Mutable;
        if ((int)sub_50C94(v10) >= 1)
        {
          uint64_t v13 = 0LL;
          do
          {
            uint64_t v14 = sub_50C98(v10, v13);
            if (!*(_DWORD *)(v14 + 32) && !*(void *)(v14 + 48))
            {
              CFTypeID v15 = *(const void **)v14;
              if (v37 < 1)
              {
LABEL_15:
                CFArrayAppendValue(v12, v15);
              }

              else
              {
                int v16 = 0;
                uint64_t v17 = (CFTypeRef *)v36;
                while (!CFEqual(v15, *v17))
                {
                  ++v16;
                  v17 += 8;
                  if (v16 >= v37) {
                    goto LABEL_15;
                  }
                }
              }
            }

            uint64_t v13 = (v13 + 1);
          }

          while ((int)v13 < (int)sub_50C94(v10));
        }

        CFIndex Count = CFArrayGetCount(v12);
        if (Count >= 1)
        {
          CFIndex v19 = Count;
          for (CFIndex i = 0LL; i != v19; ++i)
          {
            ValueAtIndex = CFArrayGetValueAtIndex(v12, i);
            sub_210C0(v9, ValueAtIndex, v38);
          }
        }

        sub_4FA18((const void **)&v41);
      }
    }

    uint64_t v22 = sub_1C654(a1);
    if (v22)
    {
      uint64_t v23 = v22;
      sub_24F9C(v22, BOOLean);
      if (v37 >= 1)
      {
        int v24 = 0;
        __int128 v25 = (unsigned int *)(v36 + 8);
        while (1)
        {
          int v26 = v38;
          CFIndex v27 = (void *)*((void *)v25 - 1);
          int v28 = sub_160EC(v23, v27, v38);
          CFTypeID v41 = v28;
          if (!v28) {
            break;
          }
          int v29 = v28;
          int v40 = 0;
          unsigned int v30 = *((_DWORD *)v28 + 6);
          if (v30 != *v25) {
            goto LABEL_28;
          }
          int v31 = sub_181A0((uint64_t)v28, v25, &v40);
          if (v31 | v40)
          {
            unsigned int v30 = *((_DWORD *)v29 + 6);
LABEL_28:
            CFTypeRef v32 = *v29;
            int v33 = (v30 >> 8) & 1;
            uint64_t v34 = v23;
LABEL_31:
            sub_210C0(v34, v32, v33);
            goto LABEL_32;
          }

LABEL_33:
          ++v24;
          v25 += 16;
          if (v24 >= v37) {
            goto LABEL_34;
          }
        }

        uint64_t v34 = sub_21634(v27, &v41, v26);
        if (v34)
        {
          CFTypeRef v32 = *v41;
          int v33 = (*((_DWORD *)v41 + 6) >> 8) & 1;
          goto LABEL_31;
        }

        CFTypeID v15 = "<unknown>";
      }

LABEL_32:
        sub_1C770(v23, (const char **)v27, (uint64_t)v25, 0LL, 0LL, 0LL);
        goto LABEL_33;
      }
    }

LABEL_34:
    sub_25150((uint64_t)&v36);
  }

  else
  {
    uint64_t v35 = sub_19E70(v7, 0LL);
    if (v35)
    {
      if ((_DWORD)a3) {
        sub_1C6A8(v35, 0);
      }
      else {
        sub_1C70C(v35, 0);
      }
    }
  }

  int v48 = sub_2CA48(4uLL);
  CFStringRef v68 = v48;
  uint64_t v49 = sub_2CA48(0x8CuLL);
  CFTypeRef v69 = v49;
  uint64_t v50 = sub_2CA48(0x10uLL);
  CFBooleanRef v70 = v50;
  uint64_t v71 = (const char *)sub_2CA90(v50, 0);
  sub_4FA18((const void **)&v69);
  sub_4FA18((const void **)&v68);
  sub_4FA18((const void **)&v70);
  if (v71)
  {
    int v28 = 0LL;
    qword_6C228 = (uint64_t)v71;
    goto LABEL_40;
  }

      int v16 = v12[1];
      uint64_t v17 = 8LL * v12[1];
      CFStringAppendFormat(theString, 0LL, @"\t%s option (%d), length %d (%d): ", v15, v14, v17, v12[1]);
      CFMutableArrayRef v18 = *v13;
      if (v18 > 0x18)
      {
        if (*v13 <= 0x24u)
        {
          if (v18 == 25)
          {
            if (v16 <= 2)
            {
              CFStringAppendFormat(theString, 0LL, @"truncated (%d < %d) ", 8LL * v16, 24LL);
              CFTypeRef v21 = (uint64_t)(v13 + 2);
              uint64_t v22 = v17 - 2;
              uint64_t v23 = theString;
              goto LABEL_89;
            }

            uint64_t v34 = *((_DWORD *)v13 + 1);
            CFStringAppend(theString, @" lifetime ");
            if (v34 == -1) {
              CFStringAppend(theString, @"infinite");
            }
            else {
              CFStringAppendFormat(theString, 0LL, @"%us", bswap32(v34));
            }
            CFStringAppend(theString, @", addr: ");
            if ((int)((unint64_t)(v17 + 0xFFFFFFFF8LL) >> 4) >= 1)
            {
              uint64_t v45 = 0LL;
              do
              {
                if (v45) {
                  uint64_t v46 = ", ";
                }
                else {
                  uint64_t v46 = "";
                }
                CFIndex v47 = inet_ntop(30, &v13[v45 + 8], v69, 0x2Eu);
                CFStringAppendFormat(theString, 0LL, @"%s%s", v46, v47);
                v45 += 16LL;
              }

              while (((v17 + 0xFFFFFFFF8LL) & 0xFFFFFFFF0LL) != v45);
            }

uint64_t sub_24A68(uint64_t a1, uint64_t a2, const __CFArray *a3, char *cStr)
{
  uint64_t v6 = a2;
  *(void *)a1 = 0LL;
  *(void *)(a1 + 8) = 0LL;
  *(void *)(a1 + 16) = 0LL;
  *(_DWORD *)(a1 + 12) = a2;
  CFStringRef v8 = CFStringCreateWithCString(0LL, cStr, 0x600u);
  CFStringRef v66 = v8;
  if (a3
    && (CFStringRef v9 = v8, Mutable = CFArrayCreateMutable(0LL, 0LL, &kCFTypeArrayCallBacks), (*(void *)&v68 = Mutable) != 0LL))
  {
    CFDictionaryRef v11 = Mutable;
    CFStringRef v65 = cStr;
    CFIndex Count = CFArrayGetCount(a3);
    if (Count >= 1)
    {
      CFIndex v13 = Count;
      for (CFIndex i = 0LL; i != v13; ++i)
      {
        ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(a3, i);
        CFPropertyListRef Value = CFDictionaryGetValue(ValueAtIndex, kSCPropNetInterfaceDeviceName);
        if (CFEqual(Value, v9)) {
          CFArrayAppendValue(v11, ValueAtIndex);
        }
      }
    }

    if (!CFArrayGetCount(v11))
    {
      sub_4FA18((const void **)&v68);
      CFDictionaryRef v11 = (__CFArray *)v68;
    }

    CFBooleanRef v67 = v11;
    uint64_t v17 = v65;
    if (v11)
    {
      CFIndex v18 = CFArrayGetCount(v11);
      CFIndex v19 = malloc(v18 << 6);
      *(void *)a1 = v19;
      if (v19)
      {
        *(_DWORD *)(a1 + 8) = 0;
        if (v18 >= 1)
        {
          CFIndex v21 = 0LL;
          *(void *)&__int128 v20 = 136315650LL;
          __int128 v63 = v20;
          do
          {
            uint64_t v71 = 0LL;
            __int128 v69 = 0u;
            __int128 v70 = 0u;
            __int128 v68 = 0u;
            uint64_t v22 = (const __CFDictionary *)CFArrayGetValueAtIndex(v11, v21);
            uint64_t v23 = v22;
            if ((_DWORD)v6)
            {
            }

            else if (sub_1A888(v22, (uint64_t)&v68))
            {
              goto LABEL_71;
            }

            if ((int)v68 > 512)
            {
              if ((v68 - 514) >= 2)
              {
                if ((_DWORD)v68 == 513)
                {
                  int v40 = *(_DWORD *)(a1 + 8);
                  if (v40 >= 1)
                  {
                    CFTypeID v41 = (void *)(*(void *)a1 + 16LL);
                    while (*((_DWORD *)v41 - 2) != 513 || *((void *)&v68 + 1) != *v41 || (void)v69 != v41[1])
                    {
                      v41 += 8;
                      if (!--v40) {
                        goto LABEL_57;
                      }
                    }

                    goto LABEL_61;
                  }
                }
              }

              else
              {
                int v31 = *(_DWORD *)(a1 + 8);
                if (v31 >= 1)
                {
                  CFTypeRef v32 = (int *)(*(void *)a1 + 8LL);
                  do
                  {
                    int v33 = *v32;
                    v32 += 16;
                    if ((v33 & 0xFFFFFFFE) == 0x202) {
                      goto LABEL_61;
                    }
                  }

                  while (--v31);
                }
              }
            }

            else if ((v68 - 257) <= 5)
            {
              int v24 = 1 << (v68 - 1);
              if ((v24 & 0x29) != 0)
              {
                int v25 = *(_DWORD *)(a1 + 8);
                if (v25 >= 1)
                {
                  int v26 = (_DWORD *)(*(void *)a1 + 16LL);
                  while (1)
                  {
                    unsigned int v27 = *(v26 - 2) - 257;
                    BOOL v28 = v27 > 5;
                    int v29 = (1 << v27) & 0x29;
                    BOOL v30 = v28 || v29 == 0;
                    if (!v30 && DWORD2(v68) == *v26) {
                      break;
                    }
                    v26 += 16;
                    if (!--v25) {
                      goto LABEL_57;
                    }
                  }

LABEL_61:
                  uint64_t v44 = "duplicate configured service";
LABEL_62:
                  uint64_t v51 = sub_57538();
                  uint64_t v52 = _SC_syslog_os_log_mapping(5LL);
                  if (__SC_log_enabled(5LL, v51, v52))
                  {
                    uint64_t v53 = v6;
                    CFIndex v54 = v18;
                    uint64_t v55 = _os_log_pack_size(32LL);
                    uint64_t v64 = (const char *)&v63;
                    uint64_t v56 = (char *)&v63 - ((__chkstk_darwin(v55) + 15) & 0xFFFFFFFFFFFFFFF0LL);
                    CFTypeID v57 = __error();
                    uint64_t v58 = _os_log_pack_fill( v56,  v55,  *v57,  &dword_0,  "%s: %s %s",  (const char *)v63,  *((const char **)&v63 + 1),  v64);
                    CFStringRef v59 = sub_14420(v68);
                    *(_DWORD *)uint64_t v58 = v63;
                    *(void *)(v58 + 4) = v65;
                    *(_WORD *)(v58 + 12) = 2080;
                    *(void *)(v58 + 14) = v59;
                    *(_WORD *)(v58 + 22) = 2080;
                    *(void *)(v58 + 24) = v44;
                    CFIndex v18 = v54;
                    uint64_t v6 = v53;
                    __SC_log_send(5LL, v51, v52, v56);
                  }

                  if ((_DWORD)v68 == 516) {
                    BOOL v60 = DWORD2(v68) == 3;
                  }
                  else {
                    BOOL v60 = (_DWORD)v68 == 259;
                  }
                  uint64_t v17 = v65;
                  if (v60 && (void)v69) {
                    free((void *)v69);
                  }
                  goto LABEL_71;
                }

                goto LABEL_57;
              }

              if ((v24 & 6) != 0)
              {
                int v34 = *(_DWORD *)(a1 + 8);
                if (v34 >= 1)
                {
                  uint64_t v35 = (int *)(*(void *)a1 + 8LL);
                  while (1)
                  {
                    int v36 = *v35;
                    v35 += 16;
                    if ((v36 & 0xFFFFFFFE) == 0x102) {
                      goto LABEL_61;
                    }
                    if (!--v34) {
                      goto LABEL_57;
                    }
                  }
                }

                goto LABEL_57;
              }

LABEL_43:
              int v37 = *(_DWORD *)(a1 + 8);
              if (v37 >= 1)
              {
                int v38 = (int *)(*(void *)a1 + 8LL);
                do
                {
                  int v39 = *v38;
                  v38 += 16;
                  if ((_DWORD)v68 == v39) {
                    goto LABEL_61;
                  }
                }

                while (--v37);
              }
            }

        CFStringRef v8 = 5LL;
        goto LABEL_44;
      }

      BOOL v28 = sub_33B4(v6);
      *(void *)CFStringRef v9 = v28;
      if (!v28)
      {
        int v29 = sub_57538();
        BOOL v30 = _SC_syslog_os_log_mapping(5LL);
        if (__SC_log_enabled(5LL, v29, v30))
        {
          uint64_t v35 = _os_log_pack_size(12LL);
          CFTypeRef v32 = &__str[-((__chkstk_darwin(v35) + 15) & 0xFFFFFFFFFFFFFFF0LL) - 8];
          int v36 = *__error();
          int v34 = _os_log_pack_fill(v32, v35, v36, &dword_0, "LINKLOCAL %s: arp_client_init failed");
          goto LABEL_42;
        }

        goto LABEL_43;
      }

      sub_3850((uint64_t)v28, 1);
      *((_DWORD *)v9 + 7) = 1;
      if (a3 && !*a3)
      {
        *((_DWORD *)v9 + 7) = 0;
        goto LABEL_11;
      }

  sub_4FA18(&v38);
}

void sub_24F9C(uint64_t a1, CFBooleanRef BOOLean)
{
  if (!dword_6C0C0) {
    return;
  }
  if (*(_DWORD *)(a1 + 156))
  {
    int v3 = *(_DWORD *)(a1 + 160);
    if (BOOLean)
    {
LABEL_4:
      *(_DWORD *)(a1 + 156) = 1;
      int Value = CFBooleanGetValue(BOOLean);
      *(_DWORD *)(a1 + 160) = Value;
      goto LABEL_7;
    }
  }

  else
  {
    int v3 = 0;
    if (BOOLean) {
      goto LABEL_4;
    }
  }

  int Value = 0;
  *(_DWORD *)(a1 + 156) = 0;
LABEL_7:
  if (Value != v3)
  {
    uint64_t v5 = sub_57538();
    uint64_t v6 = _SC_syslog_os_log_mapping(6LL);
    if (__SC_log_enabled(6LL, v5, v6))
    {
      uint64_t v7 = _os_log_pack_size(22LL);
      CFStringRef v8 = (char *)v13 - ((__chkstk_darwin(v7) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      CFStringRef v9 = __error();
      uint64_t v10 = _os_log_pack_fill( v8,  v7,  *v9,  &dword_0,  "%s: disable until needed %srequested",  v13[0],  v13[1]);
      uint64_t v11 = nullsub_1(*(void *)(a1 + 8));
      uint64_t v12 = "";
      if (!Value) {
        uint64_t v12 = "not ";
      }
      *(_DWORD *)uint64_t v10 = 136315394;
      *(void *)(v10 + 4) = v11;
      *(_WORD *)(v10 + 12) = 2080;
      *(void *)(v10 + 14) = v12;
      __SC_log_send(6LL, v5, v6, v8);
    }

    if (dword_6C0C0)
    {
      byte_6C19C = 1;
      dispatch_source_merge_data((dispatch_source_t)qword_6C1B0, 1uLL);
    }
  }

void sub_25150(uint64_t a1)
{
  uint64_t v1 = *(void ***)a1;
  if (!*(void *)a1) {
    return;
  }
  int v3 = 0;
  CFMutableArrayRef v4 = v1 + 3;
  do
  {
    uint64_t v5 = v4 - 3;
    sub_4FA18((const void **)v4 - 3);
    int v6 = *((_DWORD *)v4 - 4);
    if (v6 == 516)
    {
      if (*((_DWORD *)v4 - 2) == 3)
      {
        uint64_t v7 = *v4;
        CFStringRef v8 = v4;
        if (*v4) {
          goto LABEL_10;
        }
      }
    }

    else if (v6 == 259)
    {
      uint64_t v7 = *v4;
      if (*v4)
      {
        CFStringRef v8 = v1 + 3;
LABEL_10:
        free(v7);
        char *v8 = 0LL;
      }
    }

    ++v3;
    v4 += 8;
    uint64_t v1 = v5 + 8;
  }

  while (v3 < *(_DWORD *)(a1 + 8));
  uint64_t v1 = *(void ***)a1;
LABEL_13:
  free(v1);
  *(void *)a1 = 0LL;
}

uint64_t sub_25210(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  unint64_t v36 = sub_54F74(v2);
  int v37 = v3;
  if ((_DWORD)v36) {
    BOOL v4 = HIDWORD(v36) == 0;
  }
  else {
    BOOL v4 = 0;
  }
  if (!v4 || v3 == 0)
  {
    int v6 = *(_DWORD *)a1;
    if ((*(_DWORD *)a1 & 0x20) != 0)
    {
      *(_DWORD *)a1 = v6 & 0xFFFFFFDF;
      uint64_t v7 = sub_57538();
      uint64_t v8 = _SC_syslog_os_log_mapping(6LL);
      if (__SC_log_enabled(6LL, v7, v8))
      {
        uint64_t v9 = _os_log_pack_size(12LL);
        uint64_t v10 = (char *)&v35 - ((__chkstk_darwin(v9) + 15) & 0xFFFFFFFFFFFFFFF0LL);
        uint64_t v11 = __error();
        uint64_t v12 = _os_log_pack_fill(v10, v9, *v11, &dword_0, "%s: processing link timer expired at wake", v35);
        uint64_t v13 = nullsub_1(v2);
        *(_DWORD *)uint64_t v12 = 136315138;
        *(void *)(v12 + 4) = v13;
        __SC_log_send(6LL, v7, v8, v10);
      }

      sub_25894(a1);
    }

    *(_DWORD *)(a1 + 116) = dword_6C1A8;
    uint64_t v14 = sub_57538();
    uint64_t v15 = _SC_syslog_os_log_mapping(6LL);
    if (__SC_log_enabled(6LL, v14, v15))
    {
      uint64_t v16 = _os_log_pack_size(12LL);
      uint64_t v17 = (char *)&v35 - ((__chkstk_darwin(v16) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      CFIndex v18 = __error();
      uint64_t v19 = _os_log_pack_fill(v17, v16, *v18, &dword_0, "%s: Wake", v35);
      uint64_t v20 = nullsub_1(v2);
      *(_DWORD *)uint64_t v19 = 136315138;
      *(void *)(v19 + 4) = v20;
      __SC_log_send(6LL, v14, v15, v17);
    }

    sub_2560C((const void **)a1, (uint64_t)v38, (uint64_t *)&v36);
    if (*(_DWORD *)(a1 + 152))
    {
      uint64_t v25 = sub_57538();
      uint64_t v26 = _SC_syslog_os_log_mapping(6LL);
      uint64_t result = __SC_log_enabled(6LL, v25, v26);
      if (!(_DWORD)result) {
        return result;
      }
      uint64_t v21 = _os_log_pack_size(12LL);
      uint64_t v22 = (char *)&v35 - ((__chkstk_darwin(v21) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v23 = *__error();
      uint64_t v24 = _os_log_pack_fill(v22, v21, v23, &dword_0, "%s: ignoring wake (interface is disabled)");
      goto LABEL_20;
    }

    if ((int)sub_50C94(a1 + 24) >= 1)
    {
      CFTypeRef v32 = (const char *)nullsub_1(v2);
      sub_31F94(v32, 1);
      sub_21780(a1 + 24, 11LL, (uint64_t)v38);
    }

    uint64_t result = sub_50C94(a1 + 56);
    if ((int)result >= 1)
    {
      int v34 = *(const void **)(a1 + 136);
      if (v34) {
        CFRelease(v34);
      }
      *(void *)(a1 + 136) = sub_259E4((const __SCDynamicStore *)qword_6C178, *(CFStringRef *)(a1 + 16));
      return sub_21780(a1 + 56, 11LL, (uint64_t)v38);
    }
  }

  else
  {
    uint64_t v25 = sub_57538();
    uint64_t v26 = _SC_syslog_os_log_mapping(6LL);
    uint64_t result = __SC_log_enabled(6LL, v25, v26);
    if ((_DWORD)result)
    {
      uint64_t v28 = _os_log_pack_size(12LL);
      uint64_t v22 = (char *)&v35 - ((__chkstk_darwin(v28) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v29 = *__error();
      uint64_t v24 = _os_log_pack_fill(v22, v28, v29, &dword_0, "%s: wake on same network (link inactive)");
LABEL_20:
      uint64_t v30 = v24;
      uint64_t v31 = nullsub_1(v2);
      *(_DWORD *)uint64_t v30 = 136315138;
      *(void *)(v30 + 4) = v31;
      return __SC_log_send(6LL, v25, v26, v22);
    }
  }

  return result;
}

void sub_2560C(const void **a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v6 = (uint64_t)a1[1];
  *(void *)a2 = 0LL;
  *(void *)(a2 + 8) = 0LL;
  uint64_t v7 = *a3;
  *(_DWORD *)(a2 + 12) = *((_DWORD *)a3 + 2);
  *(void *)(a2 + 4) = v7;
  if (sub_54E84(v6))
  {
    uint64_t v8 = (const char *)sub_20B70((uint64_t)a1[2]);
    uint64_t v24 = v8;
    if (v8)
    {
      int v9 = sub_2A638((uint64_t)a1[12], (uint64_t)v8);
      if (v9 == 3)
      {
        if (!sub_54E90(v6))
        {
          uint64_t v17 = sub_57538();
          uint64_t v18 = _SC_syslog_os_log_mapping(5LL);
          if (__SC_log_enabled(5LL, v17, v18))
          {
            uint64_t v19 = _os_log_pack_size(12LL);
            uint64_t v20 = (char *)&v24 - ((__chkstk_darwin(v19) + 15) & 0xFFFFFFFFFFFFFFF0LL);
            uint64_t v21 = __error();
            uint64_t v22 = _os_log_pack_fill(v20, v19, *v21, &dword_0, "%s: Wi-Fi roam", v24);
            uint64_t v23 = nullsub_1(v6);
            *(_DWORD *)uint64_t v22 = 136315138;
            *(void *)(v22 + 4) = v23;
            __SC_log_send(5LL, v17, v18, v20);
          }
        }

        *(_DWORD *)a2 = 2;
      }

      else if (v9 == 2)
      {
        *(_DWORD *)a2 = 1;
        uint64_t v10 = sub_57538();
        uint64_t v11 = _SC_syslog_os_log_mapping(5LL);
        if (__SC_log_enabled(5LL, v10, v11))
        {
          uint64_t v12 = _os_log_pack_size(12LL);
          uint64_t v13 = (char *)&v24 - ((__chkstk_darwin(v12) + 15) & 0xFFFFFFFFFFFFFFF0LL);
          uint64_t v14 = __error();
          uint64_t v15 = _os_log_pack_fill(v13, v12, *v14, &dword_0, "%s: Wi-Fi switched networks", v24);
          uint64_t v16 = nullsub_1(v6);
          *(_DWORD *)uint64_t v15 = 136315138;
          *(void *)(v15 + 4) = v16;
          __SC_log_send(5LL, v10, v11, v13);
        }
      }

      CFRetain(v8);
    }

    else if (!*(_DWORD *)a3 || *((_DWORD *)a3 + 1))
    {
      goto LABEL_16;
    }

    sub_4FA18(a1 + 12);
    a1[12] = v8;
LABEL_16:
    sub_4FA18((const void **)&v24);
  }

uint64_t sub_25894(uint64_t a1)
{
  uint64_t v2 = sub_57538();
  uint64_t v3 = _SC_syslog_os_log_mapping(5LL);
  if (__SC_log_enabled(5LL, v2, v3))
  {
    uint64_t v4 = _os_log_pack_size(12LL);
    uint64_t v5 = (char *)&v11 - ((__chkstk_darwin(v4) + 15) & 0xFFFFFFFFFFFFFFF0LL);
    uint64_t v6 = __error();
    uint64_t v7 = _os_log_pack_fill(v5, v4, *v6, &dword_0, "%s: link inactive timer fired", v11);
    uint64_t v8 = nullsub_1(*(void *)(a1 + 8));
    *(_DWORD *)uint64_t v7 = 136315138;
    *(void *)(v7 + 4) = v8;
    __SC_log_send(5LL, v2, v3, v5);
  }

  sub_21780(a1 + 24, 4LL, 0LL);
  sub_21780(a1 + 56, 4LL, 0LL);
  uint64_t result = sub_50C94(a1 + 56);
  if ((_DWORD)result)
  {
    uint64_t v10 = (const char *)nullsub_1(*(void *)(a1 + 8));
    return sub_33618(v10);
  }

  return result;
}

CFMutableArrayRef sub_259E4(const __SCDynamicStore *a1, CFStringRef ifname)
{
  CFStringRef NetworkInterfaceEntity = SCDynamicStoreKeyCreateNetworkInterfaceEntity( 0LL,  kSCDynamicStoreDomainState,  ifname,  @"BonjourSleepProxyAddress");
  CFPropertyListRef v5 = SCDynamicStoreCopyValue(a1, NetworkInterfaceEntity);
  uint64_t v18 = v5;
  CFRelease(NetworkInterfaceEntity);
  CFTypeID TypeID = CFDictionaryGetTypeID();
  if (!v5 || CFGetTypeID(v5) != TypeID)
  {
    sub_4FA18(&v18);
    CFPropertyListRef v5 = v18;
    if (!v18) {
      return 0LL;
    }
  }

  int Value = (const __CFArray *)CFDictionaryGetValue((CFDictionaryRef)v5, @"RegisteredAddresses");
  CFTypeID v8 = CFArrayGetTypeID();
  if (Value && CFGetTypeID(Value) == v8)
  {
    uint64_t v9 = sub_57538();
    uint64_t v10 = _SC_syslog_os_log_mapping(6LL);
    if (__SC_log_enabled(6LL, v9, v10))
    {
      uint64_t v11 = _os_log_pack_size(22LL);
      uint64_t v12 = (char *)&v18 - ((__chkstk_darwin(v11) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v13 = __error();
      uint64_t v14 = _os_log_pack_fill(v12, v11, *v13, &dword_0, "%@: Sleep Proxy Addresses = %@");
      *(_DWORD *)uint64_t v14 = 138412546;
      *(void *)(v14 + 4) = ifname;
      *(_WORD *)(v14 + 12) = 2112;
      *(void *)(v14 + 14) = Value;
      __SC_log_send(6LL, v9, v10, v12);
    }

    CFIndex Count = CFArrayGetCount(Value);
    CFMutableArrayRef MutableCopy = CFArrayCreateMutableCopy(0LL, Count, Value);
  }

  else
  {
    CFMutableArrayRef MutableCopy = 0LL;
  }

  CFRelease(v5);
  return MutableCopy;
}

uint64_t sub_25BD8(const void *a1)
{
  uint64_t v2 = 0LL;
  while (1)
  {
    uint64_t v3 = sub_50C98(&unk_6C150, v2);
    if (CFEqual(a1, *(CFTypeRef *)(v3 + 16))) {
      break;
    }
    uint64_t v2 = (v2 + 1);
  }

  return v3;
}

_BYTE *sub_25C58(uint64_t a1, uint64_t a2)
{
  uint64_t result = (_BYTE *)sub_50C94(a1 + 56);
  if ((_DWORD)result)
  {
    uint64_t result = (_BYTE *)sub_3617C(a2);
    if (result)
    {
      if ((result[20] & 4) != 0)
      {
        inet_ntop(30, result, (char *)v33 + 2, 0x2Eu);
        uint64_t v5 = sub_57538();
        uint64_t v6 = _SC_syslog_os_log_mapping(5LL);
        uint64_t result = (_BYTE *)__SC_log_enabled(5LL, v5, v6);
        if ((_DWORD)result)
        {
          uint64_t v7 = _os_log_pack_size(22LL);
          CFTypeID v8 = (char *)&v33[-1] - ((__chkstk_darwin(v7) + 15) & 0xFFFFFFFFFFFFFFF0LL);
          uint64_t v9 = __error();
          uint64_t v10 = _os_log_pack_fill( v8,  v7,  *v9,  &dword_0,  "%s: IPv6LL address %s is duplicated",  v32,  v33[0]);
          uint64_t v11 = nullsub_1(*(void *)(a1 + 8));
          *(_DWORD *)uint64_t v10 = 136315394;
          *(void *)(v10 + 4) = v11;
          *(_WORD *)(v10 + 12) = 2080;
          *(void *)(v10 + 14) = (char *)v33 + 2;
          uint64_t result = (_BYTE *)__SC_log_send(5LL, v5, v6, v8);
        }

        if ((*(_BYTE *)(a1 + 2) & 1) == 0)
        {
          int v12 = *(unsigned __int8 *)(a1 + 168);
          if (v12 == 3)
          {
            uint64_t v13 = sub_57538();
            uint64_t v14 = _SC_syslog_os_log_mapping(5LL);
            uint64_t result = (_BYTE *)__SC_log_enabled(5LL, v13, v14);
            if ((_DWORD)result)
            {
              uint64_t v15 = _os_log_pack_size(18LL);
              uint64_t v16 = (char *)&v33[-1] - ((__chkstk_darwin(v15) + 15) & 0xFFFFFFFFFFFFFFF0LL);
              uint64_t v17 = __error();
              uint64_t v18 = _os_log_pack_fill( v16,  v15,  *v17,  &dword_0,  "%s: IPv6LL too many collisions (%d allowed)",  v32,  LODWORD(v33[0]));
              uint64_t v19 = nullsub_1(*(void *)(a1 + 8));
              *(_DWORD *)uint64_t v18 = 136315394;
              *(void *)(v18 + 4) = v19;
              *(_WORD *)(v18 + 12) = 1024;
              *(_DWORD *)(v18 + 14) = 3;
              return (_BYTE *)__SC_log_send(5LL, v13, v14, v16);
            }
          }

          else
          {
            *(_BYTE *)(a1 + 168) = v12 + 1;
            uint64_t v20 = sub_57538();
            uint64_t v21 = _SC_syslog_os_log_mapping(5LL);
            if (__SC_log_enabled(5LL, v20, v21))
            {
              uint64_t v22 = _os_log_pack_size(18LL);
              uint64_t v23 = (char *)&v33[-1] - ((__chkstk_darwin(v22) + 15) & 0xFFFFFFFFFFFFFFF0LL);
              uint64_t v24 = __error();
              uint64_t v25 = _os_log_pack_fill( v23,  v22,  *v24,  &dword_0,  "%s: IPv6LL stop/start (collision count %d)",  v32,  LODWORD(v33[0]));
              uint64_t v26 = nullsub_1(*(void *)(a1 + 8));
              int v27 = *(unsigned __int8 *)(a1 + 168);
              *(_DWORD *)uint64_t v25 = 136315394;
              *(void *)(v25 + 4) = v26;
              *(_WORD *)(v25 + 12) = 1024;
              *(_DWORD *)(v25 + 14) = v27;
              __SC_log_send(5LL, v20, v21, v23);
            }

            uint64_t v28 = (const char *)nullsub_1(*(void *)(a1 + 8));
            sub_33618(v28);
            unint64_t v29 = sub_54F74(*(void *)(a1 + 8));
            if (HIDWORD(v29)) {
              BOOL v30 = 1;
            }
            else {
              BOOL v30 = (_DWORD)v29 == 0;
            }
            int v31 = v30;
            return (_BYTE *)sub_20FA4(a1, v31);
          }
        }
      }
    }
  }

  return result;
}

void sub_25F90(uint64_t a1, uint64_t *a2)
{
  __int128 v70 = a2;
  uint64_t v71 = a1;
  uint64_t v2 = (const void **)(a1 + 136);
  if (!*(void *)(a1 + 136)) {
    return;
  }
  double current_time = timer_get_current_time();
  if (current_time - *(double *)&qword_6C1E0 > 60.0)
  {
    uint64_t v4 = sub_57538();
    uint64_t v5 = _SC_syslog_os_log_mapping(6LL);
    if (__SC_log_enabled(6LL, v4, v5))
    {
      uint64_t v6 = _os_log_pack_size(38LL);
      uint64_t v7 = (char *)&v65 - ((__chkstk_darwin(v6) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      CFTypeID v8 = __error();
      uint64_t v9 = _os_log_pack_fill(v7, v6, *v8, &dword_0, "%@: tossing neighbor advert list (%g - %g) > (%d)");
      uint64_t v10 = *(void *)(v71 + 16);
      uint64_t v11 = qword_6C1E0;
      *(_DWORD *)uint64_t v9 = 138413058;
      *(void *)(v9 + 4) = v10;
      *(_WORD *)(v9 + 12) = 2048;
      *(double *)(v9 + 14) = current_time;
      *(_WORD *)(v9 + 22) = 2048;
      *(void *)(v9 + 24) = v11;
      *(_WORD *)(v9 + 32) = 1024;
      *(_DWORD *)(v9 + 34) = 60;
      __SC_log_send(6LL, v4, v5, v7);
    }

    sub_4FA18(v2);
    return;
  }

  uint64_t v68 = *(void *)(v71 + 8);
  CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(v71 + 136));
  if (Count < 1)
  {
    LODWORD(v17) = -1;
    goto LABEL_27;
  }

  CFIndex v14 = Count;
  CFIndex v15 = 0LL;
  int v16 = 0;
  uint64_t v17 = 0xFFFFFFFFLL;
  *(void *)&__int128 v13 = 138412546LL;
  __int128 v67 = v13;
  *(void *)&__int128 v13 = 136315394LL;
  __int128 v65 = v13;
  __int128 v69 = v2;
  while (1)
  {
    ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex((CFArrayRef)*v2, v15);
    if ((sub_4FD78(ValueAtIndex, &v72) & 1) != 0) {
      break;
    }
    uint64_t v34 = sub_57538();
    uint64_t v35 = _SC_syslog_os_log_mapping(5LL);
    if (__SC_log_enabled(5LL, v34, v35))
    {
      uint64_t v36 = _os_log_pack_size(22LL);
      int v37 = (char *)&v65 - ((__chkstk_darwin(v36) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      int v38 = __error();
      uint64_t v39 = _os_log_pack_fill(v37, v36, *v38, &dword_0, "%@: bogus address value %@");
      uint64_t v40 = *(void *)(v71 + 16);
      *(_DWORD *)uint64_t v39 = v67;
      *(void *)(v39 + 4) = v40;
      *(_WORD *)(v39 + 12) = 2112;
      *(void *)(v39 + 14) = ValueAtIndex;
      __SC_log_send(5LL, v34, v35, v37);
LABEL_17:
      uint64_t v2 = v69;
    }

void sub_26644(uint64_t a1, int a2)
{
  if (*(_DWORD *)(a1 + 148) != a2)
  {
    uint64_t v4 = sub_57538();
    uint64_t v5 = _SC_syslog_os_log_mapping(6LL);
    if (__SC_log_enabled(6LL, v4, v5))
    {
      uint64_t v6 = _os_log_pack_size(22LL);
      uint64_t v7 = (char *)v12 - ((__chkstk_darwin(v6) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      CFTypeID v8 = __error();
      uint64_t v9 = _os_log_pack_fill(v7, v6, *v8, &dword_0, "%s: active during sleep %srequested", v12[0], v12[1]);
      uint64_t v10 = nullsub_1(*(void *)(a1 + 8));
      uint64_t v11 = "";
      if (!a2) {
        uint64_t v11 = "not ";
      }
      *(_DWORD *)uint64_t v9 = 136315394;
      *(void *)(v9 + 4) = v10;
      *(_WORD *)(v9 + 12) = 2080;
      *(void *)(v9 + 14) = v11;
      __SC_log_send(6LL, v4, v5, v7);
    }

    byte_6C1A4 = 1;
    *(_DWORD *)(a1 + 144) = 1;
    *(_DWORD *)(a1 + 148) = a2;
    dispatch_source_merge_data((dispatch_source_t)qword_6C1B0, 1uLL);
  }

uint64_t sub_267B4( const __SCDynamicStore *a1, CFStringRef ifname, const void *a3, int a4, in_addr *a5, CFTypeRef *a6)
{
  a5->s_addr = 0;
  *a6 = 0LL;
  CFStringRef NetworkInterfaceEntity = SCDynamicStoreKeyCreateNetworkInterfaceEntity( 0LL,  kSCDynamicStoreDomainState,  ifname,  @"BonjourSleepProxyAddress");
  values[0] = (void *)NetworkInterfaceEntity;
  CFStringRef v13 = SCDynamicStoreKeyCreateNetworkInterfaceEntity( 0LL,  kSCDynamicStoreDomainState,  ifname,  @"BonjourSleepProxyOPTRecord");
  values[1] = (void *)v13;
  CFIndex v14 = CFArrayCreate(0LL, (const void **)values, 2LL, &kCFTypeArrayCallBacks);
  CFDictionaryRef v15 = SCDynamicStoreCopyMultiple(a1, v14, 0LL);
  CFDictionaryRef v37 = v15;
  CFRelease(v14);
  if (v15)
  {
    uint64_t v35 = a3;
    int Value = CFDictionaryGetValue(v15, NetworkInterfaceEntity);
    CFTypeID TypeID = CFDictionaryGetTypeID();
    if (Value && CFGetTypeID(Value) != TypeID) {
      int Value = 0LL;
    }
    uint64_t v18 = CFDictionaryGetValue(v15, v13);
    CFTypeID v19 = CFDictionaryGetTypeID();
    if (v18 && CFGetTypeID(v18) != v19) {
      uint64_t v18 = 0LL;
    }
    if (Value)
    {
      int v20 = (const __CFString *)CFDictionaryGetValue((CFDictionaryRef)Value, kSCPropMACAddress);
      CFTypeID v21 = CFStringGetTypeID();
      if (v20)
      {
        if (CFGetTypeID(v20) == v21)
        {
          int v22 = sub_37BD4(v20, &v36);
          if (v22)
          {
            int v23 = v22;
            if (v36 == a4 && !bcmp(v22, v35, a4))
            {
              free(v23);
              if (v18)
              {
                uint64_t v26 = (const __CFString *)CFDictionaryGetValue((CFDictionaryRef)Value, @"IPAddress");
                if (sub_4FCC8(v26, a5))
                {
                  uint64_t v27 = CFDictionaryGetValue((CFDictionaryRef)v18, @"OwnerOPTRecord");
                  CFTypeID v28 = CFDataGetTypeID();
                  if (v27)
                  {
                    if (CFGetTypeID(v27) == v28) {
                      *a6 = CFRetain(v27);
                    }
                  }
                }
              }

              else
              {
                uint64_t v29 = sub_57538();
                uint64_t v30 = _SC_syslog_os_log_mapping(5LL);
                if (__SC_log_enabled(5LL, v29, v30))
                {
                  uint64_t v31 = _os_log_pack_size(12LL);
                  uint64_t v32 = (char *)&v35 - ((__chkstk_darwin(v31) + 15) & 0xFFFFFFFFFFFFFFF0LL);
                  uint64_t v33 = __error();
                  uint64_t v34 = _os_log_pack_fill( v32,  v31,  *v33,  &dword_0,  "%@: BonjourSleepProxyOPTRecord is missing");
                  *(_DWORD *)uint64_t v34 = 138412290;
                  *(void *)(v34 + 4) = ifname;
                  __SC_log_send(5LL, v29, v30, v32);
                  uint64_t v24 = 1LL;
                  goto LABEL_16;
                }
              }

              uint64_t v24 = 1LL;
              goto LABEL_16;
            }

            free(v23);
          }
        }
      }
    }
  }

  uint64_t v24 = 0LL;
LABEL_16:
  sub_4FA18((const void **)&v37);
  CFRelease(NetworkInterfaceEntity);
  CFRelease(v13);
  return v24;
}

uint64_t sub_26ADC()
{
  int v0 = sub_31700();
  HIDWORD(v28) = 255;
  if (v0 < 0)
  {
    uint64_t v12 = sub_57538();
    uint64_t v13 = _SC_syslog_os_log_mapping(3LL);
    uint64_t result = __SC_log_enabled(3LL, v12, v13);
    if (!(_DWORD)result) {
      return result;
    }
    uint64_t v22 = _os_log_pack_size(18LL);
    CFDictionaryRef v15 = (char *)&v28 - ((__chkstk_darwin(v22) + 15) & 0xFFFFFFFFFFFFFFF0LL);
    int v23 = __error();
    uint64_t v24 = _os_log_pack_fill( v15,  v22,  *v23,  &dword_0,  "set_loopback(): socket() failed, %s (%d)",  v28,  v29);
    uint64_t v25 = __error();
    uint64_t v26 = strerror(*v25);
    int v27 = *__error();
    *(_DWORD *)uint64_t v24 = 136315394;
    *(void *)(v24 + 4) = v26;
    *(_WORD *)(v24 + 12) = 1024;
    *(_DWORD *)(v24 + 14) = v27;
    uint64_t v21 = 3LL;
    return __SC_log_send(v21, v12, v13, v15);
  }

  int v1 = v0;
  if ((sub_3273C(v0, "lo0", 16777343, (int *)&v28 + 1, 0LL) & 0x80000000) != 0)
  {
    uint64_t v2 = sub_57538();
    uint64_t v3 = _SC_syslog_os_log_mapping(6LL);
    if (__SC_log_enabled(6LL, v2, v3))
    {
      uint64_t v4 = _os_log_pack_size(18LL);
      uint64_t v5 = (char *)&v28 - ((__chkstk_darwin(v4) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v6 = __error();
      uint64_t v7 = _os_log_pack_fill( v5,  v4,  *v6,  &dword_0,  "set_loopback: inet_aifaddr() failed, %s (%d)",  v28,  v29);
      CFTypeID v8 = __error();
      uint64_t v9 = strerror(*v8);
      int v10 = *__error();
      *(_DWORD *)uint64_t v7 = 136315394;
      *(void *)(v7 + 4) = v9;
      *(_WORD *)(v7 + 12) = 1024;
      *(_DWORD *)(v7 + 14) = v10;
      __SC_log_send(6LL, v2, v3, v5);
    }
  }

  close(v1);
  uint64_t result = sub_36C6C(16777343, 127, SHIDWORD(v28), "lo0");
  if (!(_DWORD)result)
  {
    uint64_t v12 = sub_57538();
    uint64_t v13 = _SC_syslog_os_log_mapping(6LL);
    uint64_t result = __SC_log_enabled(6LL, v12, v13);
    if ((_DWORD)result)
    {
      uint64_t v14 = _os_log_pack_size(18LL);
      CFDictionaryRef v15 = (char *)&v28 - ((__chkstk_darwin(v14) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      int v16 = __error();
      uint64_t v17 = _os_log_pack_fill( v15,  v14,  *v16,  &dword_0,  "set_loopback: subnet_route_add() failed, %s (%d)",  v28,  v29);
      uint64_t v18 = __error();
      CFTypeID v19 = strerror(*v18);
      int v20 = *__error();
      *(_DWORD *)uint64_t v17 = 136315394;
      *(void *)(v17 + 4) = v19;
      *(_WORD *)(v17 + 12) = 1024;
      *(_DWORD *)(v17 + 14) = v20;
      uint64_t v21 = 6LL;
      return __SC_log_send(v21, v12, v13, v15);
    }
  }

  return result;
}

void sub_26E00()
{
  if (!qword_6C178) {
    return;
  }
  uint64_t v0 = sub_57538();
  uint64_t v1 = _SC_syslog_os_log_mapping(7LL);
  if (__SC_log_enabled(7LL, v0, v1))
  {
    uint64_t v2 = _os_log_pack_size(12LL);
    uint64_t v3 = (char *)&v15 - ((__chkstk_darwin(v2) + 15) & 0xFFFFFFFFFFFFFFF0LL);
    uint64_t v4 = __error();
    uint64_t v5 = _os_log_pack_fill(v3, v2, *v4, &dword_0, "%s", v15);
    *(_DWORD *)uint64_t v5 = 136315138;
    *(void *)(v5 + 4) = "perform_async_work";
    __SC_log_send(7LL, v0, v1, v3);
  }

  if ((byte_6C180 & 1) != 0 || byte_6C19C)
  {
    int Value = (const __SCDynamicStore *)qword_6C178;
    int v16 = 0LL;
    uint64_t v17 = 0LL;
    if (qword_6C178)
    {
      CFStringRef NetworkGlobalEntity = SCDynamicStoreKeyCreateNetworkGlobalEntity(0LL, kSCDynamicStoreDomainSetup, kSCEntNetIPv4);
      uint64_t v17 = (void *)NetworkGlobalEntity;
      if (!NetworkGlobalEntity) {
        goto LABEL_18;
      }
      CFPropertyListRef v8 = sub_373B8(Value, NetworkGlobalEntity);
      int v16 = v8;
      if (!v8) {
        goto LABEL_18;
      }
      int Value = (const __SCDynamicStore *)CFDictionaryGetValue((CFDictionaryRef)v8, kSCPropNetServiceOrder);
      CFTypeID TypeID = CFArrayGetTypeID();
      if (!Value) {
        goto LABEL_19;
      }
      if (CFGetTypeID(Value) != TypeID || (CFIndex Count = CFArrayGetCount(Value)) == 0)
      {
LABEL_18:
        int Value = 0LL;
        goto LABEL_19;
      }

      CFIndex v11 = Count;
      if (Count >= 1)
      {
        CFIndex v12 = 0LL;
        do
        {
          ValueAtIndex = CFArrayGetValueAtIndex(Value, v12);
          CFTypeID v14 = CFStringGetTypeID();
          if (!ValueAtIndex || CFGetTypeID(ValueAtIndex) != v14) {
            goto LABEL_18;
          }
        }

        while (v11 != ++v12);
      }

      CFRetain(Value);
    }

uint64_t sub_27098(const __CFArray *a1)
{
  uint64_t v2 = sub_57538();
  uint64_t v3 = _SC_syslog_os_log_mapping(7LL);
  if (__SC_log_enabled(7LL, v2, v3))
  {
    uint64_t v4 = _os_log_pack_size(12LL);
    uint64_t v5 = (char *)&v22 - ((__chkstk_darwin(v4) + 15) & 0xFFFFFFFFFFFFFFF0LL);
    uint64_t v6 = __error();
    uint64_t v7 = _os_log_pack_fill(v5, v4, *v6, &dword_0, "%s", v22);
    *(_DWORD *)uint64_t v7 = 136315138;
    *(void *)(v7 + 4) = "linklocal_elect";
    __SC_log_send(7LL, v2, v3, v5);
  }

  uint64_t result = sub_50C94(qword_6C150);
  if ((int)result >= 1)
  {
    uint64_t v9 = 0LL;
    do
    {
      uint64_t v10 = sub_50C98(qword_6C150, v9);
      if ((sub_54A84(*(void *)(v10 + 8)) & 0x18) == 0)
      {
        uint64_t v11 = *(void *)(v10 + 88);
        if (v11)
        {
          CFIndex v12 = *(const void **)(v11 + 48);
          if (!v12)
          {
            if (*(_DWORD *)(v11 + 100)) {
              sub_27B0C(*(void *)(v10 + 88), a1);
            }
            goto LABEL_6;
          }

          uint64_t v13 = sub_160EC(v10, v12, 1);
          if (!v13)
          {
            sub_210C0(v10, *(const void **)v11, (*(_DWORD *)(v11 + 24) >> 8) & 1);
            uint64_t v11 = 0LL;
          }
        }

        else
        {
          uint64_t v13 = 0LL;
        }

        if ((int)sub_50C94(v10 + 24) < 1)
        {
          uint64_t v14 = 0LL;
        }

        else
        {
          uint64_t v14 = 0LL;
          uint64_t v15 = 0LL;
          unsigned int v16 = 1048577;
          do
          {
            uint64_t v17 = sub_50C98(v10 + 24, v15);
            int v18 = *(_DWORD *)(v17 + 24);
            if (v18 != 261)
            {
              uint64_t v19 = v17;
              if (*(_DWORD *)(v17 + 100)
                || (v18 == 259 ? (BOOL v21 = dword_6C024 == 0) : (BOOL v21 = 1),
                    !v21 && *(_DWORD *)(v17 + 28) == 9 && (*(_BYTE *)(*(void *)(v17 + 16) + 2LL) & 0x40) == 0))
              {
                unsigned int v20 = sub_27B0C(v17, a1);
                if (!v14 || v20 < v16 || !*(_DWORD *)(v14 + 100) && *(_DWORD *)(v19 + 100))
                {
                  uint64_t v14 = v19;
                  unsigned int v16 = v20;
                }
              }
            }

            uint64_t v15 = (v15 + 1);
          }

          while ((int)v15 < (int)sub_50C94(v10 + 24));
        }

        if (v13 != (CFTypeRef *)v14)
        {
          if (v13)
          {
            sub_4FA18(v13 + 7);
            sub_210C0(v10, *(const void **)v11, (*(_DWORD *)(v11 + 24) >> 8) & 1);
          }

          if (v14) {
            sub_27BA8(v14, *(_DWORD *)(v14 + 100) == 0);
          }
        }
      }

void sub_2737C(const __CFArray *a1)
{
  uint64_t v2 = sub_57538();
  uint64_t v3 = _SC_syslog_os_log_mapping(7LL);
  if (__SC_log_enabled(7LL, v2, v3))
  {
    uint64_t v4 = _os_log_pack_size(12LL);
    uint64_t v5 = (char *)&v46[-2] - ((__chkstk_darwin(v4) + 15) & 0xFFFFFFFFFFFFFFF0LL);
    uint64_t v6 = __error();
    uint64_t v7 = _os_log_pack_fill(v5, v4, *v6, &dword_0, "%s", (const char *)v45);
    *(_DWORD *)uint64_t v7 = 136315138;
    *(void *)(v7 + 4) = "DisableUntilNeededProcess";
    __SC_log_send(7LL, v2, v3, v5);
  }

  sub_55590(v46);
  int v8 = sub_50C94(qword_6C150);
  if (v8 >= 1)
  {
    uint64_t v9 = 0LL;
    uint64_t v10 = v8;
    do
    {
      uint64_t v11 = (_DWORD *)sub_50C98(qword_6C150, v9);
      *v11 &= ~4u;
      unsigned int v12 = sub_27D30((uint64_t)(v11 + 6), a1, &v47);
      if (v47) {
        *v11 |= 4u;
      }
      unsigned int v13 = sub_27D30((uint64_t)(v11 + 14), a1, &v47);
      if (v47) {
        *v11 |= 4u;
      }
      if (v12 >= v13) {
        unsigned int v14 = v13;
      }
      else {
        unsigned int v14 = v12;
      }
      v11[41] = v14;
      int v15 = sub_55628((uint64_t)v46);
      if (v15 < 1)
      {
LABEL_16:
        sub_556EC((uint64_t)v46, (uint64_t)v11);
      }

      else
      {
        uint64_t v16 = 0LL;
        uint64_t v17 = v15;
        while (v11[41] >= *(_DWORD *)(sub_55644((uint64_t)v46, v16) + 164))
        {
          if (v17 == ++v16) {
            goto LABEL_16;
          }
        }

        sub_5579C((uint64_t)v46, (uint64_t)v11, v16);
      }

      ++v9;
    }

    while (v9 != v10);
  }

  int v18 = sub_55628((uint64_t)v46);
  if (v18 >= 1)
  {
    char v20 = 0;
    uint64_t v21 = 0LL;
    uint64_t v22 = v18;
    int v23 = &off_6C000;
    *(void *)&__int128 v19 = 136315138LL;
    __int128 v45 = v19;
    do
    {
      uint64_t v24 = sub_55644((uint64_t)v46, v21);
      uint64_t v25 = v24;
      uint64_t v26 = *(void *)(v24 + 8);
      if (*((_DWORD *)v23 + 48)
        && *(_DWORD *)(v24 + 156)
        && (*(_DWORD *)(v24 + 160) ? (BOOL v27 = v20 == 0) : (BOOL v27 = 1), !v27))
      {
        if (!*(_DWORD *)(v24 + 152))
        {
          uint64_t v37 = sub_57538();
          uint64_t v38 = _SC_syslog_os_log_mapping(5LL);
          if (__SC_log_enabled(5LL, v37, v38))
          {
            uint64_t v39 = _os_log_pack_size(12LL);
            uint64_t v40 = (char *)&v46[-2] - ((__chkstk_darwin(v39) + 15) & 0xFFFFFFFFFFFFFFF0LL);
            uint64_t v41 = __error();
            uint64_t v42 = _os_log_pack_fill( v40,  v39,  *v41,  &dword_0,  "%s: marking interface down",  (const char *)v45);
            uint64_t v43 = nullsub_1(v26);
            *(_DWORD *)uint64_t v42 = v45;
            *(void *)(v42 + 4) = v43;
            __SC_log_send(5LL, v37, v38, v40);
            int v23 = &off_6C000;
          }

          uint64_t v44 = (const char *)nullsub_1(v26);
          sub_31A94(v44, 0);
          *(_DWORD *)(v25 + 152) = 1;
        }
      }

      else if (*(_DWORD *)(v24 + 152))
      {
        *(_DWORD *)(v24 + 152) = 0;
        uint64_t v28 = sub_57538();
        uint64_t v29 = _SC_syslog_os_log_mapping(5LL);
        if (__SC_log_enabled(5LL, v28, v29))
        {
          uint64_t v30 = _os_log_pack_size(12LL);
          uint64_t v31 = (char *)&v46[-2] - ((__chkstk_darwin(v30) + 15) & 0xFFFFFFFFFFFFFFF0LL);
          uint64_t v32 = __error();
          uint64_t v33 = _os_log_pack_fill( v31,  v30,  *v32,  &dword_0,  "%s: marking interface up again",  (const char *)v45);
          uint64_t v34 = nullsub_1(v26);
          *(_DWORD *)uint64_t v33 = v45;
          *(void *)(v33 + 4) = v34;
          __SC_log_send(5LL, v28, v29, v31);
          int v23 = &off_6C000;
        }

        uint64_t v35 = (const char *)nullsub_1(v26);
        sub_31A94(v35, 1);
        if ((int)sub_50C94(v25 + 24) >= 1)
        {
          int v36 = (const char *)nullsub_1(v26);
          sub_31F94(v36, 1);
        }
      }

      if ((*(_BYTE *)v25 & 4) != 0) {
        char v20 = 1;
      }
      ++v21;
    }

    while (v22 != v21);
  }

  sub_55598((uint64_t)v46);
}

void sub_27808()
{
  uint64_t v0 = sub_57538();
  uint64_t v1 = _SC_syslog_os_log_mapping(7LL);
  if (__SC_log_enabled(7LL, v0, v1))
  {
    uint64_t v2 = _os_log_pack_size(12LL);
    uint64_t v3 = (char *)&v14 - ((__chkstk_darwin(v2) + 15) & 0xFFFFFFFFFFFFFFF0LL);
    uint64_t v4 = __error();
    uint64_t v5 = _os_log_pack_fill(v3, v2, *v4, &dword_0, "%s", v14);
    *(_DWORD *)uint64_t v5 = 136315138;
    *(void *)(v5 + 4) = "ActiveDuringSleepProcess";
    __SC_log_send(7LL, v0, v1, v3);
  }

  int v6 = sub_50C94(qword_6C150);
  if (v6 >= 1)
  {
    int v7 = v6;
    uint64_t v8 = 0LL;
    uint64_t v9 = (const __CFString *)kSCEntNetInterfaceActiveDuringSleepSupported;
    do
    {
      uint64_t v10 = sub_50C98(qword_6C150, v8);
      if (*(_DWORD *)(v10 + 144))
      {
        uint64_t v11 = v10;
        *(_DWORD *)(v10 + 144) = 0;
        LODWORD(v14) = *(_DWORD *)(v10 + 148);
        HIDWORD(v14) = 1;
        sub_21780(v10 + 24, 17LL, (uint64_t)&v14);
        if (*(_DWORD *)(v11 + 148)) {
          BOOL v12 = HIDWORD(v14) == 0;
        }
        else {
          BOOL v12 = 1;
        }
        int v13 = !v12;
        sub_202F0(v11, v9, v13);
      }

      uint64_t v8 = (v8 + 1);
    }

    while (v7 != (_DWORD)v8);
  }

_DWORD *sub_279A8()
{
  uint64_t v0 = sub_57538();
  uint64_t v1 = _SC_syslog_os_log_mapping(7LL);
  if (__SC_log_enabled(7LL, v0, v1))
  {
    uint64_t v2 = _os_log_pack_size(12LL);
    uint64_t v3 = (char *)&v9 - ((__chkstk_darwin(v2) + 15) & 0xFFFFFFFFFFFFFFF0LL);
    uint64_t v4 = __error();
    uint64_t v5 = _os_log_pack_fill(v3, v2, *v4, &dword_0, "%s", v9);
    *(_DWORD *)uint64_t v5 = 136315138;
    *(void *)(v5 + 4) = "IPv4ServicePublishProcess";
    __SC_log_send(7LL, v0, v1, v3);
  }

  uint64_t result = (_DWORD *)sub_50C94(qword_6C150);
  if ((int)result >= 1)
  {
    int v7 = (int)result;
    uint64_t v8 = 0LL;
    do
    {
      uint64_t result = (_DWORD *)sub_50C98(qword_6C150, v8);
      if ((*result & 0x40) != 0)
      {
        *result &= ~0x40u;
        uint64_t result = (_DWORD *)sub_21780((uint64_t)(result + 14), 21LL, 0LL);
      }

      uint64_t v8 = (v8 + 1);
    }

    while (v7 != (_DWORD)v8);
  }

  return result;
}

CFIndex sub_27B0C(uint64_t a1, CFArrayRef theArray)
{
  uint64_t v3 = *(const void **)a1;
  if ((**(_BYTE **)(a1 + 16) & 0x10) != 0 && *(_DWORD *)(a1 + 24) == 259) {
    return 0LL;
  }
  CFIndex v4 = 0x100000LL;
  if (theArray && v3)
  {
    int Count = CFArrayGetCount(theArray);
    if (Count < 1)
    {
      return 0x100000LL;
    }

    else
    {
      CFIndex v4 = 0LL;
      uint64_t v6 = Count;
      while (1)
      {
        ValueAtIndex = CFArrayGetValueAtIndex(theArray, v4);
        if (CFEqual(v3, ValueAtIndex)) {
          break;
        }
        if (v6 == ++v4) {
          return 0x100000LL;
        }
      }
    }
  }

  return v4;
}

uint64_t sub_27BA8(uint64_t a1, int a2)
{
  uint64_t v2 = *(void *)(a1 + 16);
  memset(v15, 0, sizeof(v15));
  uint64_t v16 = 0LL;
  LODWORD(v15[0]) = 261;
  DWORD2(v15[0]) = a2;
  uint64_t result = sub_1C770(v2, 0LL, (uint64_t)v15, (CFTypeRef *)a1, 0LL, &v14);
  if ((_DWORD)result)
  {
    unsigned int v4 = result;
    uint64_t v5 = sub_57538();
    uint64_t v6 = _SC_syslog_os_log_mapping(5LL);
    uint64_t result = __SC_log_enabled(5LL, v5, v6);
    if ((_DWORD)result)
    {
      uint64_t v7 = _os_log_pack_size(22LL);
      uint64_t v8 = (char *)&v13 - ((__chkstk_darwin(v7) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v9 = __error();
      uint64_t v10 = _os_log_pack_fill( v8,  v7,  *v9,  &dword_0,  "IPConfiguration: failed to start link-local service on %s, %s",  v13,  v14);
      uint64_t v11 = nullsub_1(*(void *)(v2 + 8));
      if (v4 <= 0x15) {
        BOOL v12 = off_64CE0[v4];
      }
      else {
        BOOL v12 = "<unknown>";
      }
      *(_DWORD *)uint64_t v10 = 136315394;
      *(void *)(v10 + 4) = v11;
      *(_WORD *)(v10 + 12) = 2080;
      *(void *)(v10 + 14) = v12;
      return __SC_log_send(5LL, v5, v6, v8);
    }
  }

  return result;
}

uint64_t sub_27D30(uint64_t a1, const __CFArray *a2, _DWORD *a3)
{
  uint64_t v6 = 1048577LL;
  *a3 = 0;
  int v7 = sub_50C94(a1);
  if (v7 >= 1)
  {
    uint64_t v8 = 0LL;
    uint64_t v9 = v7;
    do
    {
      uint64_t v10 = sub_50C98(a1, v8);
      if (!*(void *)(v10 + 48))
      {
        uint64_t v11 = (_DWORD *)v10;
        unsigned int v12 = sub_27B0C(v10, a2);
        else {
          uint64_t v6 = v12;
        }
        int v13 = v11[6];
        if (v13 != 261 && v13 != 517 && v11[10] && !v11[7]) {
          *a3 = 1;
        }
      }

      ++v8;
    }

    while (v9 != v8);
  }

  return v6;
}

void sub_27DF8(int a1, int a2, int a3, intptr_t notificationID)
{
  HIDWORD(v6) = a3;
  LODWORD(v6) = a3 + 536870320;
  int v5 = v6 >> 4;
  if (v5 <= 3)
  {
    if (v5 == 1) {
      return;
    }
    if (v5 == 3 && (byte_6C1D8 & 1) == 0)
    {
      uint64_t v13 = sub_57538();
      uint64_t v14 = _SC_syslog_os_log_mapping(6LL);
      if (__SC_log_enabled(6LL, v13, v14))
      {
        uint64_t v15 = _os_log_pack_size(2LL);
        uint64_t v16 = (char *)&v22 - ((__chkstk_darwin(v15) + 15) & 0xFFFFFFFFFFFFFFF0LL);
        uint64_t v17 = __error();
        *(_WORD *)_os_log_pack_fill(v16, v15, *v17, &dword_0, "IPConfiguration: Sleep") = 0;
        __SC_log_send(6LL, v13, v14, v16);
      }

      byte_6C1D8 = 1;
      int v18 = sub_50C94(qword_6C150);
      if (v18 >= 1)
      {
        int v19 = v18;
        uint64_t v20 = 0LL;
        do
        {
          uint64_t v21 = sub_50C98(qword_6C150, v20);
          sub_21780(v21 + 24, 10LL, 0LL);
          sub_21780(v21 + 56, 10LL, 0LL);
          sub_4FA18((const void **)(v21 + 136));
          uint64_t v20 = (v20 + 1);
        }

        while (v19 != (_DWORD)v20);
      }
    }

    goto LABEL_19;
  }

  if (v5 != 4 && v5 != 11)
  {
    if (v5 == 13 && byte_6C1D8 == 1)
    {
      uint64_t v8 = sub_57538();
      uint64_t v9 = _SC_syslog_os_log_mapping(6LL);
      if (__SC_log_enabled(6LL, v8, v9))
      {
        uint64_t v10 = _os_log_pack_size(2LL);
        uint64_t v11 = (char *)&v22 - ((__chkstk_darwin(v10) + 15) & 0xFFFFFFFFFFFFFFF0LL);
        unsigned int v12 = __error();
        *(_WORD *)_os_log_pack_fill(v11, v10, *v12, &dword_0, "IPConfiguration: Wake") = 0;
        __SC_log_send(6LL, v8, v9, v11);
      }

      byte_6C1D8 = 0;
      qword_6C1E0 = timer_get_current_time();
      ++dword_6C1A8;
      sub_28098();
    }

uint64_t sub_28098()
{
  uint64_t result = sub_50C94(qword_6C150);
  if ((int)result >= 1)
  {
    int v2 = result;
    uint64_t v3 = 0LL;
    *(void *)&__int128 v1 = 136315138LL;
    __int128 v13 = v1;
    do
    {
      uint64_t v4 = sub_50C98(qword_6C150, v3);
      uint64_t v5 = v4;
      if (*(_DWORD *)(v4 + 116) == dword_6C1A8)
      {
        uint64_t v6 = sub_57538();
        uint64_t v7 = _SC_syslog_os_log_mapping(6LL);
        uint64_t result = __SC_log_enabled(6LL, v6, v7);
        if ((_DWORD)result)
        {
          uint64_t v8 = _os_log_pack_size(12LL);
          uint64_t v9 = (char *)&v13 - ((__chkstk_darwin(v8) + 15) & 0xFFFFFFFFFFFFFFF0LL);
          uint64_t v10 = __error();
          uint64_t v11 = _os_log_pack_fill( v9,  v8,  *v10,  &dword_0,  "%s: ignoring wake (already processed)",  (const char *)v13);
          uint64_t v12 = nullsub_1(*(void *)(v5 + 8));
          *(_DWORD *)uint64_t v11 = v13;
          *(void *)(v11 + 4) = v12;
          uint64_t result = __SC_log_send(6LL, v6, v7, v9);
        }
      }

      else
      {
        uint64_t result = sub_25210(v4);
      }

      uint64_t v3 = (v3 + 1);
    }

    while (v2 != (_DWORD)v3);
  }

  return result;
}

_DWORD *sub_28224()
{
  CFMutableArrayRef Mutable = CFDictionaryCreateMutable(0LL, 0LL, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  int v1 = sub_50C94(qword_6C150);
  if (v1 >= 1)
  {
    int v2 = v1;
    uint64_t v3 = 0LL;
    do
    {
      uint64_t v4 = sub_50C98(qword_6C150, v3);
      uint64_t v5 = sub_1BC3C(v4);
      if (v5)
      {
        uint64_t v6 = v5;
        CFDictionarySetValue(Mutable, *(const void **)(v4 + 16), v5);
        CFRelease(v6);
      }

      uint64_t v3 = (v3 + 1);
    }

    while (v2 != (_DWORD)v3);
  }

  if (CFDictionaryGetCount(Mutable))
  {
    Data = CFPropertyListCreateData(0LL, Mutable, kCFPropertyListBinaryFormat_v1_0, 0LL, 0LL);
    CFRelease(Mutable);
    CFIndex Length = CFDataGetLength(Data);
    size_t v9 = Length + 200;
    if ((unint64_t)(Length + 200) <= 0x8000)
    {
      size_t v17 = Length;
      uint64_t v16 = calloc(1uLL, v9);
      *uint64_t v16 = 1;
      v16[1] = v17;
      __strlcpy_chk(v16 + 34, "Interface Configuration Summary", 64LL, 64LL);
      BytePtr = CFDataGetBytePtr(Data);
      memcpy(v16 + 50, BytePtr, v17);
    }

    else
    {
      uint64_t v10 = sub_57538();
      uint64_t v11 = _SC_syslog_os_log_mapping(5LL);
      if (__SC_log_enabled(5LL, v10, v11))
      {
        uint64_t v12 = _os_log_pack_size(28LL);
        __int128 v13 = (char *)v20 - ((__chkstk_darwin(v12) + 15) & 0xFFFFFFFFFFFFFFF0LL);
        uint64_t v14 = __error();
        uint64_t v15 = _os_log_pack_fill( v13,  v12,  *v14,  &dword_0,  "%s: state data too large (%zd > %d)",  v20[0],  (size_t)v20[1],  v21);
        *(_DWORD *)uint64_t v15 = 136315650;
        *(void *)(v15 + 4) = "IPConfigurationCopyOSStateData";
        *(_WORD *)(v15 + 12) = 2048;
        *(void *)(v15 + 14) = v9;
        *(_WORD *)(v15 + 22) = 1024;
        *(_DWORD *)(v15 + 24) = 0x8000;
        __SC_log_send(5LL, v10, v11, v13);
      }

      uint64_t v16 = 0LL;
    }

    CFRelease(Data);
  }

  else
  {
    CFRelease(Mutable);
    return 0LL;
  }

  return v16;
}

uint64_t S_find_linklocal_address(uint64_t a1)
{
  uint64_t result = sub_1836C(a1);
  if (!(_DWORD)result)
  {
    uint64_t v3 = sub_14834(a1);
    int v4 = sub_54A8C(v3);
    if (v4 < 1)
    {
      uint64_t v8 = (unsigned __int8 *)&G_ip_zeroes;
    }

    else
    {
      int v5 = v4;
      uint64_t v6 = 0LL;
      while (1)
      {
        uint64_t v7 = (unsigned __int8 *)sub_54A94(v3, v6);
        uint64_t v6 = (v6 + 1);
        if (v5 == (_DWORD)v6)
        {
          uint64_t v8 = (unsigned __int8 *)&G_ip_zeroes;
          return *(unsigned int *)v8;
        }
      }

      uint64_t v8 = v7;
      uint64_t v9 = sub_57538();
      uint64_t v10 = _SC_syslog_os_log_mapping(6LL);
      if (__SC_log_enabled(6LL, v9, v10))
      {
        uint64_t v11 = _os_log_pack_size(36LL);
        uint64_t v12 = (char *)&v20 - ((__chkstk_darwin(v11) + 15) & 0xFFFFFFFFFFFFFFF0LL);
        __int128 v13 = __error();
        uint64_t v14 = _os_log_pack_fill( v12,  v11,  *v13,  &dword_0,  "LINKLOCAL %s: found address %d.%d.%d.%d",  v20,  v21,  v22,  v23,  v24);
        uint64_t v15 = nullsub_1(v3);
        int v16 = *v8;
        int v17 = v8[1];
        int v18 = v8[2];
        int v19 = v8[3];
        *(_DWORD *)uint64_t v14 = 136316162;
        *(void *)(v14 + 4) = v15;
        *(_WORD *)(v14 + 12) = 1024;
        *(_DWORD *)(v14 + 14) = v16;
        *(_WORD *)(v14 + 18) = 1024;
        *(_DWORD *)(v14 + 20) = v17;
        *(_WORD *)(v14 + 24) = 1024;
        *(_DWORD *)(v14 + 26) = v18;
        *(_WORD *)(v14 + 30) = 1024;
        *(_DWORD *)(v14 + 32) = v19;
        __SC_log_send(6LL, v9, v10, v12);
      }
    }

    return *(unsigned int *)v8;
  }

  return result;
}

uint64_t linklocal_thread(uint64_t a1, int a2, _DWORD *a3)
{
  uint64_t v6 = sub_14834(a1);
  uint64_t v7 = (_DWORD *)sub_194C4(a1);
  uint64_t v8 = 0LL;
  uint64_t v9 = v7;
  switch(a2)
  {
    case 0:
      if ((sub_54A84(v6) & 8) != 0) {
        return 4LL;
      }
      uint64_t v12 = sub_57538();
      if (v9)
      {
        uint64_t v13 = _SC_syslog_os_log_mapping(5LL);
        uint64_t v14 = _os_log_pack_size(12LL);
        uint64_t v15 = &__str[-((__chkstk_darwin(v14) + 15) & 0xFFFFFFFFFFFFFFF0LL) - 8];
        int v16 = __error();
        uint64_t v17 = _os_log_pack_fill(v15, v14, *v16, &dword_0, "LINKLOCAL %s: re-entering start state", v54);
        uint64_t v18 = nullsub_1(v6);
        *(_DWORD *)uint64_t v17 = 136315138;
        *(void *)(v17 + 4) = v18;
        __SC_log_send(5LL, v12, v13, v15);
        return 6LL;
      }

      uint64_t v20 = _SC_syslog_os_log_mapping(6LL);
      if (__SC_log_enabled(6LL, v12, v20))
      {
        uint64_t v21 = _os_log_pack_size(12LL);
        uint64_t v22 = &__str[-((__chkstk_darwin(v21) + 15) & 0xFFFFFFFFFFFFFFF0LL) - 8];
        uint64_t v23 = __error();
        uint64_t v24 = _os_log_pack_fill(v22, v21, *v23, &dword_0, "LINKLOCAL %s: start", v54);
        uint64_t v25 = nullsub_1(v6);
        *(_DWORD *)uint64_t v24 = 136315138;
        *(void *)(v24 + 4) = v25;
        __SC_log_send(6LL, v12, v20, v22);
      }

      uint64_t v9 = malloc(0x28uLL);
      *(_OWORD *)uint64_t v9 = 0u;
      *((_OWORD *)v9 + 1) = 0u;
      *((void *)v9 + 4) = 0LL;
      sub_194CC(a1, (uint64_t)v9);
      uint64_t v26 = (const char *)nullsub_1(v6);
      snprintf(__str, 0x20uLL, "linklocal-%s", v26);
      BOOL v27 = timer_callout_init(__str);
      *((void *)v9 + 1) = v27;
      if (!v27)
      {
        uint64_t v29 = sub_57538();
        uint64_t v30 = _SC_syslog_os_log_mapping(5LL);
        if (__SC_log_enabled(5LL, v29, v30))
        {
          uint64_t v31 = _os_log_pack_size(12LL);
          uint64_t v32 = &__str[-((__chkstk_darwin(v31) + 15) & 0xFFFFFFFFFFFFFFF0LL) - 8];
          uint64_t v33 = *__error();
          uint64_t v34 = _os_log_pack_fill(v32, v31, v33, &dword_0, "LINKLOCAL %s: timer_callout_init failed");
LABEL_42:
          uint64_t v37 = v34;
          uint64_t v38 = nullsub_1(v6);
          *(_DWORD *)uint64_t v37 = 136315138;
          *(void *)(v37 + 4) = v38;
          __SC_log_send(5LL, v29, v30, v32);
        }

LABEL_26:
      *((_DWORD *)v9 + 5) = S_find_linklocal_address(a1);
LABEL_27:
      sub_2925C(a1, 0, 0LL);
      return 0LL;
    case 1:
LABEL_44:
      uint64_t v39 = sub_57538();
      uint64_t v40 = _SC_syslog_os_log_mapping(6LL);
      if (__SC_log_enabled(6LL, v39, v40))
      {
        uint64_t v41 = _os_log_pack_size(12LL);
        uint64_t v42 = &__str[-((__chkstk_darwin(v41) + 15) & 0xFFFFFFFFFFFFFFF0LL) - 8];
        uint64_t v43 = __error();
        uint64_t v44 = _os_log_pack_fill(v42, v41, *v43, &dword_0, "LINKLOCAL %s: stop", v54);
        uint64_t v45 = nullsub_1(v6);
        *(_DWORD *)uint64_t v44 = 136315138;
        *(void *)(v44 + 4) = v45;
        __SC_log_send(6LL, v39, v40, v42);
      }

      if (v9)
      {
        uint64_t v46 = (const char *)nullsub_1(v6);
        sub_29A0C(v46, 0);
        sub_18A00(a1);
        sub_17FEC(a1, 0);
        if (*((void *)v9 + 1)) {
          timer_callout_free((uint64_t *)v9 + 1);
        }
        if (*(void *)v9) {
          sub_3524((uint64_t **)v9);
        }
        free(v9);
        sub_194CC(a1, 0LL);
      }

      else
      {
        uint64_t v47 = sub_57538();
        uint64_t v8 = 6LL;
        uint64_t v48 = _SC_syslog_os_log_mapping(6LL);
        if (__SC_log_enabled(6LL, v47, v48))
        {
          uint64_t v49 = _os_log_pack_size(12LL);
          uint64_t v50 = &__str[-((__chkstk_darwin(v49) + 15) & 0xFFFFFFFFFFFFFFF0LL) - 8];
          uint64_t v51 = __error();
          uint64_t v52 = _os_log_pack_fill(v50, v49, *v51, &dword_0, "LINKLOCAL %s: already stopped", v54);
          uint64_t v53 = nullsub_1(v6);
          *(_DWORD *)uint64_t v52 = 136315138;
          *(void *)(v52 + 4) = v53;
          uint64_t v8 = 6LL;
          __SC_log_send(6LL, v47, v48, v50);
        }
      }

      return v8;
    case 3:
    case 11:
      if (!v7) {
        return 6LL;
      }
      if (a3[1] && !a3[2])
      {
        sub_299C8(a1);
        uint64_t v8 = 0LL;
        *((_DWORD *)v9 + 8) = 0;
        return v8;
      }

      if (*(_DWORD *)(sub_194C4(a1) + 28)) {
        goto LABEL_27;
      }
      goto LABEL_11;
    case 4:
      sub_29950(a1, 0xCu);
      return 0LL;
    case 7:
      if (*(void *)a3)
      {
        int v10 = **(_DWORD **)a3;
        int v11 = v10 != 0;
        if (v7[7] == v11) {
          return 0LL;
        }
        v7[7] = v11;
        if (!v10)
        {
          sub_29950(a1, 0);
LABEL_11:
          sub_28D2C(a1, 0, 0LL);
          return 0LL;
        }
      }

      else
      {
        if (v7[7] == 1) {
          return 0LL;
        }
        v7[7] = 1;
      }

      goto LABEL_26;
    case 9:
      if (!v7) {
        return 6LL;
      }
      if (v7[7] && v7[8] && *a3 == v7[5])
      {
        v7[5] = 0;
        sub_18A00(a1);
        sub_17FEC(a1, 8u);
        goto LABEL_27;
      }

      return 0LL;
    default:
      return v8;
  }

  uint64_t v21 = s_addr & 0xFF000000 | (BYTE2(s_addr) << 16) | (BYTE1(s_addr) << 8) | s_addr;
  if (v21)
  {
    if (v21 == *v6) {
      goto LABEL_41;
    }
    uint64_t v22 = sub_14834(a1);
    uint64_t v23 = sub_57538();
    uint64_t v24 = _SC_syslog_os_log_mapping(6LL);
    if (__SC_log_enabled(6LL, v23, v24))
    {
      uint64_t v42 = v16;
      uint64_t v40 = BYTE2(s_addr);
      uint64_t v41 = HIBYTE(s_addr);
      uint64_t v38 = s_addr;
      uint64_t v39 = BYTE1(s_addr);
      uint64_t v25 = _os_log_pack_size(36LL);
      uint64_t v26 = (char *)&v37 - ((__chkstk_darwin(v25) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      BOOL v27 = __error();
      uint64_t v28 = _os_log_pack_fill( v26,  v25,  *v27,  &dword_0,  "6TO4 %s: primary IPv4 address changed to %d.%d.%d.%d",  v37,  v38,  v40,  (_DWORD)v42,  v43[0].s_addr);
      uint64_t v29 = nullsub_1(v22);
      *(_DWORD *)uint64_t v28 = 136316162;
      *(void *)(v28 + 4) = v29;
      *(_WORD *)(v28 + 12) = 1024;
      *(_DWORD *)(v28 + 14) = v38;
      *(_WORD *)(v28 + 18) = 1024;
      *(_DWORD *)(v28 + 20) = v39;
      *(_WORD *)(v28 + 24) = 1024;
      *(_DWORD *)(v28 + 26) = v40;
      *(_WORD *)(v28 + 30) = 1024;
      *(_DWORD *)(v28 + 32) = v41;
LABEL_32:
      __SC_log_send(6LL, v23, v24, v26);
      int v16 = v42;
    }
  }

  else
  {
    uint64_t v30 = sub_14834(a1);
    uint64_t v23 = sub_57538();
    uint64_t v24 = _SC_syslog_os_log_mapping(6LL);
    if (__SC_log_enabled(6LL, v23, v24))
    {
      uint64_t v42 = v16;
      uint64_t v31 = _os_log_pack_size(12LL);
      uint64_t v26 = (char *)&v37 - ((__chkstk_darwin(v31) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v32 = __error();
      uint64_t v33 = _os_log_pack_fill(v26, v31, *v32, &dword_0, "6TO4 %s: no primary IPv4 address", v37);
      uint64_t v34 = nullsub_1(v30);
      *(_DWORD *)uint64_t v33 = 136315138;
      *(void *)(v33 + 4) = v34;
      goto LABEL_32;
    }
  }

  uint64_t v35 = *v6;
  if ((_DWORD)v35)
  {
    sub_4AB88(v35, (uint64_t)v43, 1);
    sub_19938(a1, v43, 16);
  }

  sub_4FA18((const void **)v6 + 5);
  *uint64_t v6 = s_addr;
  if (v21)
  {
    sub_4AB88( s_addr & 0xFF000000 | (BYTE2(s_addr) << 16) | (BYTE1(s_addr) << 8) | s_addr,  (uint64_t)v43,  1);
    sub_19540(a1, (char *)v43, 16, 0, -1, -1);
    uint64_t v36 = CFStringGetTypeID();
    if (v16 && CFGetTypeID(v16) == v36) {
      *((void *)v6 + 5) = CFRetain(v44);
    }
    sub_4B1F0(a1);
  }

  else
  {
    sub_17FEC(a1, 0x12u);
  }

void sub_28D2C(uint64_t a1, int a2, uint64_t a3)
{
  uint64_t v6 = sub_14834(a1);
  uint64_t v7 = (uint64_t *)sub_194C4(a1);
  if (a2 == 6)
  {
    if (*(_DWORD *)(a3 + 8))
    {
      uint64_t v10 = sub_57538();
      uint64_t v11 = _SC_syslog_os_log_mapping(6LL);
      if (__SC_log_enabled(6LL, v10, v11))
      {
        uint64_t v12 = _os_log_pack_size(22LL);
        uint64_t v13 = (char *)&v48 - ((__chkstk_darwin(v12) + 15) & 0xFFFFFFFFFFFFFFF0LL);
        uint64_t v14 = __error();
        uint64_t v15 = _os_log_pack_fill(v13, v12, *v14, &dword_0, "LINKLOCAL %s: ARP probe failed, %s", v48, v49);
        uint64_t v16 = nullsub_1(v6);
        uint64_t v17 = sub_4AE0(*v7);
        *(_DWORD *)uint64_t v15 = 136315394;
        *(void *)(v15 + 4) = v16;
        *(_WORD *)(v15 + 12) = 2080;
        *(void *)(v15 + 14) = v17;
        __SC_log_send(6LL, v10, v11, v13);
      }
    }

    else
    {
      sub_18184();
      if (*(_DWORD *)(a3 + 12))
      {
        uint64_t v28 = sub_57538();
        uint64_t v29 = _SC_syslog_os_log_mapping(6LL);
        if (__SC_log_enabled(6LL, v28, v29))
        {
          uint64_t v30 = _os_log_pack_size(48LL);
          uint64_t v31 = (char *)&v48 - ((__chkstk_darwin(v30) + 15) & 0xFFFFFFFFFFFFFFF0LL);
          uint64_t v32 = __error();
          uint64_t v33 = _os_log_pack_fill( v31,  v30,  *v32,  &dword_0,  "LINKLOCAL %s: ARP response received for 169.254.255.255 from %02x:%02x:%02x:%02x:%02x:%02x",  v48,  (_DWORD)v49,  v50,  v51,  v52,  v53,  v54);
          uint64_t v34 = nullsub_1(v6);
          int v35 = *(unsigned __int8 *)(a3 + 24);
          int v36 = *(unsigned __int8 *)(a3 + 25);
          int v37 = *(unsigned __int8 *)(a3 + 26);
          int v38 = *(unsigned __int8 *)(a3 + 27);
          int v39 = *(unsigned __int8 *)(a3 + 28);
          int v40 = *(unsigned __int8 *)(a3 + 29);
          *(_DWORD *)uint64_t v33 = 136316674;
          *(void *)(v33 + 4) = v34;
          *(_WORD *)(v33 + 12) = 1024;
          *(_DWORD *)(v33 + 14) = v35;
          *(_WORD *)(v33 + 18) = 1024;
          *(_DWORD *)(v33 + 20) = v36;
          *(_WORD *)(v33 + 24) = 1024;
          *(_DWORD *)(v33 + 26) = v37;
          *(_WORD *)(v33 + 30) = 1024;
          *(_DWORD *)(v33 + 32) = v38;
          *(_WORD *)(v33 + 36) = 1024;
          *(_DWORD *)(v33 + 38) = v39;
          *(_WORD *)(v33 + 42) = 1024;
          *(_DWORD *)(v33 + 44) = v40;
          __SC_log_send(6LL, v28, v29, v31);
        }

        sub_17FEC(a1, 8u);
      }

      else
      {
        if (sub_19384(a1) != 1)
        {
          uint64_t v9 = (const char *)nullsub_1(v6);
          goto LABEL_4;
        }

        sub_29950(a1, 0xCu);
      }
    }
  }

  else if (!a2)
  {
    int v8 = sub_54E78(v6);
    uint64_t v9 = (const char *)nullsub_1(v6);
    if (v8)
    {
LABEL_4:
      sub_29A0C(v9, 1u);
      sub_17FEC(a1, 0);
      return;
    }

    sub_29A0C(v9, 0);
    sub_299C8(a1);
    uint64_t v18 = sub_18058(a1);
    if (v18 && (unsigned int v19 = sub_194D4((uint64_t)v18)) != 0)
    {
      unsigned int v20 = v19;
      uint64_t v21 = sub_57538();
      uint64_t v22 = _SC_syslog_os_log_mapping(6LL);
      if (__SC_log_enabled(6LL, v21, v22))
      {
        uint64_t v23 = _os_log_pack_size(36LL);
        uint64_t v24 = (char *)&v48 - ((__chkstk_darwin(v23) + 15) & 0xFFFFFFFFFFFFFFF0LL);
        uint64_t v25 = __error();
        uint64_t v26 = _os_log_pack_fill( v24,  v23,  *v25,  &dword_0,  "LINKLOCAL %s: ARP Request: Source %d.%d.%d.%d Target 169.254.255.255",  v48,  (_DWORD)v49,  v50,  v51,  v52);
        uint64_t v27 = nullsub_1(v6);
        *(_DWORD *)uint64_t v26 = 136316162;
        *(void *)(v26 + 4) = v27;
        *(_WORD *)(v26 + 12) = 1024;
        *(_DWORD *)(v26 + 14) = v20;
        *(_WORD *)(v26 + 18) = 1024;
        *(_DWORD *)(v26 + 20) = BYTE1(v20);
        *(_WORD *)(v26 + 24) = 1024;
        *(_DWORD *)(v26 + 26) = BYTE2(v20);
        *(_WORD *)(v26 + 30) = 1024;
        *(_DWORD *)(v26 + 32) = HIBYTE(v20);
        __SC_log_send(6LL, v21, v22, v24);
      }

      sub_45A8(*v7, (uint64_t)sub_28D2C, a1, 6LL, v20, -343);
    }

    else
    {
      uint64_t v41 = sub_57538();
      uint64_t v42 = _SC_syslog_os_log_mapping(5LL);
      if (__SC_log_enabled(5LL, v41, v42))
      {
        uint64_t v43 = _os_log_pack_size(12LL);
        uint64_t v44 = (char *)&v48 - ((__chkstk_darwin(v43) + 15) & 0xFFFFFFFFFFFFFFF0LL);
        uint64_t v45 = __error();
        uint64_t v46 = _os_log_pack_fill(v44, v43, *v45, &dword_0, "LINKLOCAL %s: parent has no IP", v48);
        uint64_t v47 = nullsub_1(v6);
        *(_DWORD *)uint64_t v46 = 136315138;
        *(void *)(v46 + 4) = v47;
        __SC_log_send(5LL, v41, v42, v44);
      }
    }
  }

void sub_2925C(uint64_t a1, int a2, uint64_t a3)
{
  uint64_t v6 = sub_14834(a1);
  uint64_t v7 = sub_194C4(a1);
  uint64_t v8 = v7;
  switch(a2)
  {
    case 6:
      if (*(_DWORD *)(a3 + 8))
      {
        uint64_t v22 = sub_57538();
        uint64_t v23 = _SC_syslog_os_log_mapping(6LL);
        uint64_t v24 = _os_log_pack_size(22LL);
        uint64_t v25 = (char *)&v62 - ((__chkstk_darwin(v24) + 15) & 0xFFFFFFFFFFFFFFF0LL);
        uint64_t v26 = __error();
        uint64_t v27 = _os_log_pack_fill(v25, v24, *v26, &dword_0, "LINKLOCAL %s: ARP probe failed, %s", v62, v63);
        uint64_t v28 = nullsub_1(v6);
        uint64_t v29 = sub_4AE0(*(void *)v8);
        *(_DWORD *)uint64_t v27 = 136315394;
        *(void *)(v27 + 4) = v28;
        *(_WORD *)(v27 + 12) = 2080;
        *(void *)(v27 + 14) = v29;
LABEL_23:
        __SC_log_send(6LL, v22, v23, v25);
        return;
      }

      if (*(_DWORD *)(a3 + 12)) {
        goto LABEL_13;
      }
      if (!sub_14FB0(a1, *(_DWORD *)(v7 + 24)))
      {
        if (sub_19384(a1) == 1)
        {
          sub_29950(a1, 0xCu);
        }

        else
        {
          sub_18378(a1, *(unsigned int *)(v8 + 24), 0xFFFFuLL, 0LL);
          sub_18360(a1, *(_DWORD *)(v8 + 24));
          uint64_t v61 = (const char *)nullsub_1(v6);
          sub_29A0C(v61, 1u);
          sub_299C8(a1);
          *(_DWORD *)(v8 + 20) = *(_DWORD *)(v8 + 24);
          sub_154F8(a1, 0LL);
          *(_DWORD *)(v8 + 32) = 1;
        }

        return;
      }

      if (*(_DWORD *)(a3 + 12))
      {
LABEL_13:
        uint64_t v30 = sub_57538();
        uint64_t v31 = _SC_syslog_os_log_mapping(6LL);
        if (!__SC_log_enabled(6LL, v30, v31))
        {
LABEL_16:
          if (*(_DWORD *)(v8 + 20) == *(_DWORD *)(v8 + 24))
          {
            *(_DWORD *)(v8 + 20) = 0;
            sub_18A00(a1);
            sub_17FEC(a1, 8u);
          }

          int v40 = *(_DWORD *)(v8 + 16);
          if (v40 >= 10)
          {
            timer_set_relative(*(void *)(v8 + 8), 30LL, 0, (uint64_t)sub_2925C, a1, 2LL, 0LL);
            return;
          }

          *(_DWORD *)(v8 + 16) = v40 + 1;
          goto LABEL_21;
        }

        uint64_t v32 = _os_log_pack_size(72LL);
        uint64_t v33 = (char *)&v62 - ((__chkstk_darwin(v32) + 15) & 0xFFFFFFFFFFFFFFF0LL);
        uint64_t v34 = __error();
        uint64_t v35 = _os_log_pack_fill( v33,  v32,  *v34,  &dword_0,  "LINKLOCAL %s: IP address %d.%d.%d.%d is in use by %02x:%02x:%02x:%02x:%02x:%02x",  v62,  (_DWORD)v63,  v64,  v65,  v66,  v67,  v68,  v69,  v70,  v71,  v72);
        uint64_t v36 = nullsub_1(v6);
        sub_29C7C( v35,  v36,  *(unsigned __int8 *)(v8 + 24),  *(unsigned __int8 *)(v8 + 25),  *(unsigned __int8 *)(v8 + 26),  *(unsigned __int8 *)(v8 + 27),  *(unsigned __int8 *)(a3 + 24),  *(unsigned __int8 *)(a3 + 25),  *(unsigned __int8 *)(a3 + 26),  *(unsigned __int8 *)(a3 + 27),  *(unsigned __int8 *)(a3 + 28),  *(unsigned __int8 *)(a3 + 29));
        uint64_t v37 = v30;
        uint64_t v38 = v31;
        int v39 = v33;
      }

      else
      {
        uint64_t v50 = sub_57538();
        uint64_t v51 = _SC_syslog_os_log_mapping(6LL);
        uint64_t v52 = _os_log_pack_size(36LL);
        uint64_t v53 = (char *)&v62 - ((__chkstk_darwin(v52) + 15) & 0xFFFFFFFFFFFFFFF0LL);
        uint64_t v54 = __error();
        uint64_t v55 = _os_log_pack_fill( v53,  v52,  *v54,  &dword_0,  "LINKLOCAL %s: IP address %d.%d.%d.%d is no longer unique",  v62,  (_DWORD)v63,  v64,  v65,  v66);
        uint64_t v56 = nullsub_1(v6);
        int v57 = *(unsigned __int8 *)(v8 + 24);
        int v58 = *(unsigned __int8 *)(v8 + 25);
        int v59 = *(unsigned __int8 *)(v8 + 26);
        int v60 = *(unsigned __int8 *)(v8 + 27);
        *(_DWORD *)uint64_t v55 = 136316162;
        *(void *)(v55 + 4) = v56;
        *(_WORD *)(v55 + 12) = 1024;
        *(_DWORD *)(v55 + 14) = v57;
        *(_WORD *)(v55 + 18) = 1024;
        *(_DWORD *)(v55 + 20) = v58;
        *(_WORD *)(v55 + 24) = 1024;
        *(_DWORD *)(v55 + 26) = v59;
        *(_WORD *)(v55 + 30) = 1024;
        *(_DWORD *)(v55 + 32) = v60;
        uint64_t v37 = v50;
        uint64_t v38 = v51;
        int v39 = v53;
      }

      __SC_log_send(6LL, v37, v38, v39);
      goto LABEL_16;
    case 2:
LABEL_21:
      int v41 = bswap32(sub_558D0(0LL, 65024LL) - 1442971392);
      *(_DWORD *)(v8 + 24) = v41;
      sub_45A8(*(void *)v8, (uint64_t)sub_2925C, a1, 6LL, 0, v41);
      uint64_t v22 = sub_57538();
      uint64_t v23 = _SC_syslog_os_log_mapping(6LL);
      uint64_t v42 = _os_log_pack_size(36LL);
      uint64_t v25 = (char *)&v62 - ((__chkstk_darwin(v42) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v43 = __error();
      uint64_t v44 = _os_log_pack_fill( v25,  v42,  *v43,  &dword_0,  "LINKLOCAL %s probing %d.%d.%d.%d",  v62,  (_DWORD)v63,  v64,  v65,  v66);
      uint64_t v45 = nullsub_1(v6);
      int v46 = *(unsigned __int8 *)(v8 + 24);
      int v47 = *(unsigned __int8 *)(v8 + 25);
      int v48 = *(unsigned __int8 *)(v8 + 26);
      int v49 = *(unsigned __int8 *)(v8 + 27);
      *(_DWORD *)uint64_t v44 = 136316162;
      *(void *)(v44 + 4) = v45;
      *(_WORD *)(v44 + 12) = 1024;
      *(_DWORD *)(v44 + 14) = v46;
      *(_WORD *)(v44 + 18) = 1024;
      *(_DWORD *)(v44 + 20) = v47;
      *(_WORD *)(v44 + 24) = 1024;
      *(_DWORD *)(v44 + 26) = v48;
      *(_WORD *)(v44 + 30) = 1024;
      *(_DWORD *)(v44 + 32) = v49;
      goto LABEL_23;
    case 0:
      *(_DWORD *)(v7 + 32) = 0;
      uint64_t v9 = (const char *)nullsub_1(v6);
      sub_29A0C(v9, 0);
      sub_299C8(a1);
      *(_DWORD *)(v8 + 16) = 1;
      unsigned int v10 = *(_DWORD *)(v8 + 20);
      if (!v10) {
        unsigned int v10 = bswap32(sub_558D0(0LL, 65024LL) - 1442971392);
      }
      *(_DWORD *)(v8 + 24) = v10;
      uint64_t v11 = sub_57538();
      uint64_t v12 = _SC_syslog_os_log_mapping(6LL);
      if (__SC_log_enabled(6LL, v11, v12))
      {
        uint64_t v13 = _os_log_pack_size(36LL);
        uint64_t v14 = (char *)&v62 - ((__chkstk_darwin(v13) + 15) & 0xFFFFFFFFFFFFFFF0LL);
        uint64_t v15 = __error();
        uint64_t v16 = _os_log_pack_fill( v14,  v13,  *v15,  &dword_0,  "LINKLOCAL %s: probing %d.%d.%d.%d",  v62,  (_DWORD)v63,  v64,  v65,  v66);
        uint64_t v17 = nullsub_1(v6);
        int v18 = *(unsigned __int8 *)(v8 + 24);
        int v19 = *(unsigned __int8 *)(v8 + 25);
        int v20 = *(unsigned __int8 *)(v8 + 26);
        int v21 = *(unsigned __int8 *)(v8 + 27);
        *(_DWORD *)uint64_t v16 = 136316162;
        *(void *)(v16 + 4) = v17;
        *(_WORD *)(v16 + 12) = 1024;
        *(_DWORD *)(v16 + 14) = v18;
        *(_WORD *)(v16 + 18) = 1024;
        *(_DWORD *)(v16 + 20) = v19;
        *(_WORD *)(v16 + 24) = 1024;
        *(_DWORD *)(v16 + 26) = v20;
        *(_WORD *)(v16 + 30) = 1024;
        *(_DWORD *)(v16 + 32) = v21;
        __SC_log_send(6LL, v11, v12, v14);
      }

      sub_45A8(*(void *)v8, (uint64_t)sub_2925C, a1, 6LL, 0, *(_DWORD *)(v8 + 24));
      break;
  }

uint64_t sub_29950(uint64_t a1, unsigned int a2)
{
  uint64_t v4 = sub_194C4(a1);
  *(_DWORD *)(v4 + 32) = 0;
  sub_299C8(a1);
  uint64_t v5 = sub_14834(a1);
  uint64_t v6 = (const char *)nullsub_1(v5);
  sub_29A0C(v6, 0);
  sub_18A00(a1);
  if (a2 != 12) {
    *(_DWORD *)(v4 + 20) = 0;
  }
  return sub_17FEC(a1, a2);
}

void sub_299C8(uint64_t a1)
{
  uint64_t v1 = sub_194C4(a1);
  if (v1)
  {
    int v2 = (uint64_t *)v1;
    uint64_t v3 = *(void *)(v1 + 8);
    if (v3) {
      timer_cancel(v3);
    }
    if (*v2) {
      sub_4718(*v2);
    }
  }

uint64_t sub_29A0C(const char *a1, unsigned int a2)
{
  int v4 = socket(2, 2, 0);
  if (v4 == -1)
  {
    uint64_t v15 = sub_57538();
    uint64_t v16 = _SC_syslog_os_log_mapping(5LL);
    uint64_t result = __SC_log_enabled(5LL, v15, v16);
    if ((_DWORD)result)
    {
      uint64_t v17 = _os_log_pack_size(22LL);
      int v18 = (char *)&__dst[-1] - ((__chkstk_darwin(v17) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      int v19 = __error();
      uint64_t v20 = _os_log_pack_fill( v18,  v17,  *v19,  &dword_0,  "set_arp_linklocal(%s) socket() failed, %s",  v23,  __dst[0]);
      int v21 = __error();
      uint64_t v22 = strerror(*v21);
      *(_DWORD *)uint64_t v20 = 136315394;
      *(void *)(v20 + 4) = a1;
      *(_WORD *)(v20 + 12) = 2080;
      *(void *)(v20 + 14) = v22;
      return __SC_log_send(5LL, v15, v16, v18);
    }
  }

  else
  {
    int v5 = v4;
    __dst[3] = 0LL;
    __dst[2] = (const char *)a2;
    strncpy((char *)__dst, a1, 0x10uLL);
    if (ioctl(v5, 0xC0206928uLL, __dst) < 0 && *__error() != 6)
    {
      uint64_t v6 = sub_57538();
      uint64_t v7 = _SC_syslog_os_log_mapping(5LL);
      if (__SC_log_enabled(5LL, v6, v7))
      {
        uint64_t v8 = _os_log_pack_size(28LL);
        uint64_t v9 = (char *)&__dst[-1] - ((__chkstk_darwin(v8) + 15) & 0xFFFFFFFFFFFFFFF0LL);
        unsigned int v10 = __error();
        uint64_t v11 = _os_log_pack_fill( v9,  v8,  *v10,  &dword_0,  "set_arp_linklocal(%s) SIOCARPIPLL %d failed, %s",  v23,  LODWORD(__dst[0]),  __dst[1]);
        uint64_t v12 = __error();
        uint64_t v13 = strerror(*v12);
        *(_DWORD *)uint64_t v11 = 136315650;
        *(void *)(v11 + 4) = a1;
        *(_WORD *)(v11 + 12) = 1024;
        *(_DWORD *)(v11 + 14) = a2;
        *(_WORD *)(v11 + 18) = 2080;
        *(void *)(v11 + 20) = v13;
        __SC_log_send(5LL, v6, v7, v9);
      }
    }

    return close(v5);
  }

  return result;
}

double sub_29C7C( uint64_t a1, uint64_t a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12)
{
  *(void *)&double result = 136317698LL;
  *(_DWORD *)a1 = 136317698;
  *(void *)(a1 + 4) = a2;
  *(_WORD *)(a1 + 12) = 1024;
  *(_DWORD *)(a1 + 14) = a3;
  *(_WORD *)(a1 + 18) = 1024;
  *(_DWORD *)(a1 + 20) = a4;
  *(_WORD *)(a1 + 24) = 1024;
  *(_DWORD *)(a1 + 26) = a5;
  *(_WORD *)(a1 + 30) = 1024;
  *(_DWORD *)(a1 + 32) = a6;
  *(_WORD *)(a1 + 36) = 1024;
  *(_DWORD *)(a1 + 38) = a7;
  *(_WORD *)(a1 + 42) = 1024;
  *(_DWORD *)(a1 + 44) = a8;
  *(_WORD *)(a1 + 48) = 1024;
  *(_DWORD *)(a1 + 50) = a9;
  *(_WORD *)(a1 + 54) = 1024;
  *(_DWORD *)(a1 + 56) = a10;
  *(_WORD *)(a1 + 60) = 1024;
  *(_DWORD *)(a1 + 62) = a11;
  *(_WORD *)(a1 + 66) = 1024;
  *(_DWORD *)(a1 + 68) = a12;
  return result;
}

const char *sub_29CEC(int a1)
{
  if (a1 > 255)
  {
    if (a1 <= 4095)
    {
      if (a1 > 1023)
      {
        if (a1 == 1024) {
          return "SHA256_PSK";
        }
        if (a1 == 2048) {
          return "SHA256_8021X";
        }
      }

      else
      {
        if (a1 == 256) {
          return "WPS";
        }
        if (a1 == 512) {
          return "WAPI";
        }
      }
    }

    else if (a1 < 0x4000)
    {
      if (a1 == 4096) {
        return "WPA3_SAE";
      }
      if (a1 == 0x2000) {
        return "FT_SAE";
      }
    }

    else
    {
      switch(a1)
      {
        case 0x4000:
          return "SHA384_8021X";
        case 0x8000:
          return "SHA384_FT_8021X";
        case 0xFFFF:
          return "UNKNOWN";
      }
    }

    return "UNRECOGNIZED";
  }

  if (a1 > 15)
  {
    if (a1 > 63)
    {
      if (a1 == 64) {
        return "8021X";
      }
      if (a1 == 128) {
        return "FT_8021X";
      }
    }

    else
    {
      if (a1 == 16) {
        return "FT_PSK";
      }
      if (a1 == 32) {
        return "LEAP";
      }
    }

    return "UNRECOGNIZED";
  }

  double result = "NONE";
  switch(a1)
  {
    case 0:
      return result;
    case 1:
      double result = "WPA";
      break;
    case 2:
      double result = "WPA_PSK";
      break;
    case 4:
      double result = "WPA2";
      break;
    case 8:
      double result = "WPA2_PSK";
      break;
    default:
      return "UNRECOGNIZED";
  }

  return result;
}

uint64_t sub_29E8C(uint64_t a1)
{
  uint64_t v14 = 0LL;
  int v2 = Apple80211Open(&v14);
  if (v2)
  {
    int v3 = v2;
    uint64_t v4 = sub_57538();
    uint64_t v5 = _SC_syslog_os_log_mapping(5LL);
    if (__SC_log_enabled(5LL, v4, v5))
    {
      uint64_t v6 = _os_log_pack_size(8LL);
      uint64_t v7 = (char *)&v13 - ((__chkstk_darwin(v6) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v8 = __error();
      uint64_t v9 = (_DWORD *)_os_log_pack_fill(v7, v6, *v8, &dword_0, "Apple80211Open failed, 0x%x", v13);
      _DWORD *v9 = 67109120;
      v9[1] = v3;
      __SC_log_send(5LL, v4, v5, v7);
    }

    goto LABEL_5;
  }

  if (Apple80211BindToInterface(v14, a1))
  {
LABEL_5:
    uint64_t Instance = 0LL;
    goto LABEL_6;
  }

  CFMutableArrayRef Mutable = CFDataCreateMutable(0LL, 0LL);
  uint64_t Instance = 0LL;
  if (!Apple80211Get(v14, 1LL, 0LL, Mutable, 0LL))
  {
    if (Apple80211Get(v14, 9LL, 0LL, &v15, 6LL))
    {
      uint64_t Instance = 0LL;
    }

    else
    {
      pthread_once(&stru_6C0D8, (void (*)(void))sub_2A6C8);
      uint64_t Instance = _CFRuntimeCreateInstance(0LL, qword_6C200, 48LL, 0LL);
      *(void *)(Instance + 16) = sub_50628(Mutable);
      *(_DWORD *)(Instance + 36) = v15;
      *(_WORD *)(Instance + 40) = v16;
      *(_DWORD *)(Instance + 32) = sub_2A0A0(v14);
      *(void *)(Instance + 24) = sub_2A24C(v14);
      *(_BYTE *)(Instance + 56) = sub_2A398(v14);
    }
  }

  CFRelease(Mutable);
LABEL_6:
  if (v14) {
    Apple80211Close();
  }
  return Instance;
}

uint64_t sub_2A0A0(uint64_t a1)
{
  int v15 = 0LL;
  int v1 = Apple80211CopyValue(a1, 2LL, 0LL, &v15);
  if (v1)
  {
    int v2 = v1;
    uint64_t v3 = sub_57538();
    uint64_t v4 = _SC_syslog_os_log_mapping(5LL);
    if (__SC_log_enabled(5LL, v3, v4))
    {
      uint64_t v5 = _os_log_pack_size(8LL);
      uint64_t v6 = (char *)&v13 - ((__chkstk_darwin(v5) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v7 = __error();
      uint64_t v8 = (_DWORD *)_os_log_pack_fill( v6,  v5,  *v7,  &dword_0,  "Apple80211CopyValue(APPLE80211_IOC_AUTH_TYPE) failed, 0x%x",  v13);
      _DWORD *v8 = 67109120;
      v8[1] = v2;
      __SC_log_send(5LL, v3, v4, v6);
      uint64_t v9 = 0xFFFFLL;
      goto LABEL_14;
    }

LABEL_13:
    uint64_t v9 = 0xFFFFLL;
    goto LABEL_14;
  }

  if (!v15) {
    goto LABEL_13;
  }
  int Value = (const __CFNumber *)CFDictionaryGetValue(v15, @"AUTH_UPPER");
  if (!Value)
  {
    uint64_t v11 = (const __CFNumber *)CFDictionaryGetValue(v15, @"AUTH_LOWER");
    if (v11 && CFNumberGetValue(v11, kCFNumberSInt32Type, &v14) && v14 == 1)
    {
      uint64_t v9 = 0LL;
      unsigned int valuePtr = 0;
      goto LABEL_14;
    }

    goto LABEL_13;
  }

  if (CFNumberGetValue(Value, kCFNumberSInt32Type, &valuePtr)) {
    uint64_t v9 = valuePtr;
  }
  else {
    uint64_t v9 = 0xFFFFLL;
  }
LABEL_14:
  sub_4FA18((const void **)&v15);
  return v9;
}

    sub_4E220(v16, 0);
    goto LABEL_14;
  }

  int v18 = v17;
  sub_4E2E0(v14 + 104, v17);
  int v19 = sub_14834((uint64_t)a1);
  uint64_t v20 = nullsub_1(v19);
  sub_4E318(v14 + 104, v20);
  int v21 = PvDInfoRequestCreate(a2, v18, v20, a4);
  *(void *)(v14 + 96) = v21;
  if (!v21)
  {
    uint64_t v30 = sub_57538();
    uint64_t v31 = _SC_syslog_os_log_mapping(3LL);
    if (__SC_log_enabled(3LL, v30, v31))
    {
      uint64_t v36 = _os_log_pack_size(12LL);
      uint64_t v33 = (char *)v38 - ((__chkstk_darwin(v36) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v37 = *__error();
      uint64_t v35 = _os_log_pack_fill(v33, v36, v37, &dword_0, "%s: couldn't create pvd info request");
      goto LABEL_12;
    }

    goto LABEL_13;
  }

  uint64_t v22 = v21;
  v38[0] = (const char *)_NSConcreteStackBlock;
  v38[1] = (const char *)0x40000000;
  v38[2] = (const char *)sub_3EC24;
  v38[3] = (const char *)&unk_64F58;
  v38[4] = a1;
  v38[5] = (const char *)v14;
  uint64_t v23 = sub_2A814();
  PvDInfoRequestSetCompletionHandler(v22, v38, v23);
  uint64_t v24 = sub_57538();
  uint64_t v25 = _SC_syslog_os_log_mapping(6LL);
  if (__SC_log_enabled(6LL, v24, v25))
  {
    uint64_t v26 = _os_log_pack_size(42LL);
    uint64_t v27 = (char *)v38 - ((__chkstk_darwin(v26) + 15) & 0xFFFFFFFFFFFFFFF0LL);
    uint64_t v28 = __error();
    uint64_t v29 = _os_log_pack_fill( v27,  v26,  *v28,  &dword_0,  "%s: requesting PvD Additional Information fetch via if '%s' for PvD ID '%@' and IPv6 Prefixes %@");
    *(_DWORD *)uint64_t v29 = 136315906;
    *(void *)(v29 + 4) = "_new_pvd_info_request";
    *(_WORD *)(v29 + 12) = 2080;
    *(void *)(v29 + 14) = v20;
    *(_WORD *)(v29 + 22) = 2112;
    *(void *)(v29 + 24) = a2;
    *(_WORD *)(v29 + 32) = 2112;
    *(void *)(v29 + 34) = v18;
    __SC_log_send(6LL, v24, v25, v27);
  }

  PvDInfoRequestResume(*(void *)(v14 + 96));
LABEL_14:
  sub_4FA18((const void **)&v39);
}

    unsigned int v10 = 0LL;
    goto LABEL_17;
  }

  if (!a1)
  {
    uint64_t v12 = sub_57538();
    int v13 = _SC_syslog_os_log_mapping(7LL);
    if (__SC_log_enabled(7LL, v12, v13))
    {
      int v18 = _os_log_pack_size(2LL);
      int v15 = (char *)&v20 - ((__chkstk_darwin(v18) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      int v19 = *__error();
      uint64_t v17 = (_WORD *)_os_log_pack_fill( v15,  v18,  v19,  &dword_0,  "ignoring pvd info request callback: no parent service",  v20);
      goto LABEL_12;
    }

    goto LABEL_13;
  }

  unsigned int v10 = sub_194C4(a1);
  CompletionStatus = PvDInfoRequestGetCompletionStatus(a2);
  if (CompletionStatus)
  {
    if (CompletionStatus == 2)
    {
      uint64_t v20 = (const char *)PvDInfoRequestCopyAdditionalInformation(a2);
      sub_4E348(v10 + 104, v20);
      sub_4E338(v10 + 104, 1);
      sub_4E3B4(v10 + 104);
      sub_4E3E8((const void **)(v10 + 104));
    }

    else
    {
      sub_4E338(v10 + 104, 0);
      sub_4E220(v10 + 104, 1);
      sub_4E3B4(v10 + 104);
    }
  }

  else
  {
    sub_4E220(v10 + 104, 0);
  }

  sub_3B790(a1);
LABEL_17:
  sub_4FA18((const void **)(v10 + 96));
  sub_4FA18((const void **)&v20);
}

CFMutableStringRef sub_2A24C(uint64_t a1)
{
  CFMutableStringRef Mutable = CFStringCreateMutable(0LL, 0LL);
  CFMutableStringRef v12 = Mutable;
  int v3 = Apple80211Get(a1, 387LL, 0LL, Mutable, 8LL);
  if (v3)
  {
    int v4 = v3;
    uint64_t v5 = sub_57538();
    uint64_t v6 = _SC_syslog_os_log_mapping(7LL);
    if (__SC_log_enabled(7LL, v5, v6))
    {
      uint64_t v7 = _os_log_pack_size(8LL);
      uint64_t v8 = (char *)&v12 - ((__chkstk_darwin(v7) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v9 = __error();
      unsigned int v10 = (_DWORD *)_os_log_pack_fill( v8,  v7,  *v9,  &dword_0,  "Apple80211Get(APPLE80211_IOC_COLOCATED_NETWORK_SCOPE_ID)failed, 0x%x",  (_DWORD)v12);
      *unsigned int v10 = 67109120;
      v10[1] = v4;
      __SC_log_send(7LL, v5, v6, v8);
    }

    sub_4FA18((const void **)&v12);
    return v12;
  }

  return Mutable;
}

BOOL sub_2A398(uint64_t a1)
{
  int v1 = Apple80211Get(a1, 552LL, 0LL, (char *)&v19 + 4, 4LL);
  if (v1)
  {
    int v2 = v1;
    uint64_t v3 = sub_57538();
    uint64_t v4 = _SC_syslog_os_log_mapping(5LL);
    if (__SC_log_enabled(5LL, v3, v4))
    {
      uint64_t v5 = _os_log_pack_size(8LL);
      uint64_t v6 = (char *)&v19 - ((__chkstk_darwin(v5) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v7 = __error();
      uint64_t v8 = (_DWORD *)_os_log_pack_fill( v6,  v5,  *v7,  &dword_0,  "Apple80211Get(APPLE80211_IOC_DEVICE_TYPE_IN_DHCP_ALLOW)failed, 0x%x",  (_DWORD)v19);
      _DWORD *v8 = 67109120;
      v8[1] = v2;
      __SC_log_send(5LL, v3, v4, v6);
    }

    return 0LL;
  }

  else
  {
    int v10 = HIDWORD(v19);
    BOOL v9 = HIDWORD(v19) == 1;
    uint64_t v11 = sub_57538();
    uint64_t v12 = _SC_syslog_os_log_mapping(5LL);
    if (__SC_log_enabled(5LL, v11, v12))
    {
      uint64_t v13 = _os_log_pack_size(12LL);
      int v14 = (char *)&v19 - ((__chkstk_darwin(v13) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      int v15 = __error();
      uint64_t v16 = _os_log_pack_fill(v14, v13, *v15, &dword_0, "Allow Sharing Device Type is %s", v19);
      uint64_t v17 = "false";
      if (v10 == 1) {
        uint64_t v17 = "true";
      }
      *(_DWORD *)uint64_t v16 = 136315138;
      *(void *)(v16 + 4) = v17;
      __SC_log_send(5LL, v11, v12, v14);
    }
  }

  return v9;
}

uint64_t sub_2A59C(uint64_t a1)
{
  return *(void *)(a1 + 16);
}

CFStringRef sub_2A5A4(uint64_t a1)
{
  CFStringRef result = *(CFStringRef *)(a1 + 48);
  if (!result)
  {
    sub_55C30(cStr, 18, (unsigned __int8 *)(a1 + 36), 6);
    CFStringRef result = CFStringCreateWithCString(0LL, cStr, 0x8000100u);
    *(void *)(a1 + 48) = result;
  }

  return result;
}

uint64_t sub_2A628(uint64_t a1)
{
  return *(unsigned int *)(a1 + 32);
}

uint64_t sub_2A630(uint64_t a1)
{
  return *(void *)(a1 + 24);
}

uint64_t sub_2A638(uint64_t a1, uint64_t a2)
{
  if (!a1 || !a2) {
    return 2 * (a1 != a2);
  }
  if (!CFEqual(*(CFTypeRef *)(a1 + 16), *(CFTypeRef *)(a2 + 16))
    && !sub_506A4(*(const void **)(a1 + 24), *(const void **)(a2 + 24)))
  {
    return 2LL;
  }

  return 1LL;
}

uint64_t WiFiInfoAllowSharingDeviceType(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 56);
}

uint64_t sub_2A6C8()
{
  uint64_t result = _CFRuntimeRegisterClass(&unk_64E50);
  qword_6C200 = result;
  return result;
}

void sub_2A6EC(const void **a1)
{
}

__CFString *sub_2A71C(uint64_t a1)
{
  int v2 = CFGetAllocator((CFTypeRef)a1);
  CFMutableStringRef Mutable = CFStringCreateMutable(v2, 0LL);
  int v4 = *(_DWORD *)(a1 + 32);
  uint64_t v5 = *(void *)(a1 + 16);
  CFStringRef v6 = sub_2A5A4(a1);
  uint64_t v7 = sub_29CEC(v4);
  CFStringAppendFormat(Mutable, 0LL, @"<WiFiInfo %p [%p]> { SSID %@ BSSID %@ Security %s", a1, v2, v5, v6, v7);
  if (*(void *)(a1 + 24)) {
    CFStringAppendFormat(Mutable, 0LL, @" NetworkID %@", *(void *)(a1 + 24));
  }
  if (*(_BYTE *)(a1 + 56)) {
    uint64_t v8 = "1";
  }
  else {
    uint64_t v8 = "0";
  }
  CFStringAppendFormat(Mutable, 0LL, @" AllowSharingDeviceType=%s", v8);
  CFStringAppend(Mutable, @" }");
  return Mutable;
}

uint64_t sub_2A808(uint64_t result)
{
  qword_6C208 = result;
  return result;
}

dispatch_queue_t sub_2A814()
{
  dispatch_queue_t result = (dispatch_queue_t)qword_6C210;
  if (!qword_6C210)
  {
    dispatch_queue_t result = dispatch_queue_create("IPConfigurationAgentQueue", 0LL);
    qword_6C210 = (uint64_t)result;
  }

  return result;
}

uint64_t sub_2A84C(uint64_t a1, int a2, unsigned __int8 *a3)
{
  uint64_t v6 = sub_14834(a1);
  uint64_t v7 = sub_194C4(a1);
  uint64_t v8 = 0LL;
  uint64_t v9 = v7;
  switch(a2)
  {
    case 0:
      if (v7)
      {
        uint64_t v10 = sub_57538();
        uint64_t v11 = _SC_syslog_os_log_mapping(6LL);
        if (__SC_log_enabled(6LL, v10, v11))
        {
          uint64_t v12 = _os_log_pack_size(12LL);
          uint64_t v13 = &__str[-((__chkstk_darwin(v12) + 15) & 0xFFFFFFFFFFFFFFF0LL) - 8];
          int v14 = __error();
          uint64_t v15 = _os_log_pack_fill(v13, v12, *v14, &dword_0, "MANUAL %s: re-entering start state", v77);
          uint64_t v16 = nullsub_1(v6);
          *(_DWORD *)uint64_t v15 = 136315138;
          *(void *)(v15 + 4) = v16;
          __SC_log_send(6LL, v10, v11, v13);
        }

        return 6LL;
      }

      uint64_t v9 = (uint64_t)malloc(0x20uLL);
      sub_194CC(a1, v9);
      *(_OWORD *)uint64_t v9 = 0u;
      *(_OWORD *)(v9 + 16) = 0u;
      *(_DWORD *)(v9 + 20) = *((_DWORD *)a3 + 4);
      sub_193C8(a1, *(_DWORD *)a3);
      sub_193F0(a1, *((_DWORD *)a3 + 1));
      sub_19418(a1, *((_DWORD *)a3 + 3));
      int v34 = *((_DWORD *)a3 + 2);
      if (v34)
      {
        sub_14F88(a1, v34);
        sub_14F98(a1);
      }

      if ((sub_54A84(v6) & 0x18) != 0)
      {
        unsigned int v35 = sub_193D8(a1);
        unsigned int v36 = sub_19400(a1);
        unsigned int v37 = sub_19428(a1);
        unint64_t v22 = v35;
        unint64_t v23 = v36;
        unint64_t v24 = v37;
        goto LABEL_37;
      }

      uint64_t v45 = (const char *)nullsub_1(v6);
      snprintf(__str, 0x20uLL, "manual-%s", v45);
      int v46 = timer_callout_init(__str);
      *(void *)(v9 + 8) = v46;
      if (v46)
      {
        int v47 = sub_33B4(v6);
        *(void *)uint64_t v9 = v47;
        if (!v47)
        {
          uint64_t v48 = sub_57538();
          uint64_t v49 = _SC_syslog_os_log_mapping(5LL);
          if (__SC_log_enabled(5LL, v48, v49))
          {
            uint64_t v50 = _os_log_pack_size(12LL);
            uint64_t v51 = &__str[-((__chkstk_darwin(v50) + 15) & 0xFFFFFFFFFFFFFFF0LL) - 8];
            uint64_t v52 = __error();
            uint64_t v53 = _os_log_pack_fill(v51, v50, *v52, &dword_0, "MANUAL %s: arp_client_init failed", v77);
            uint64_t v54 = nullsub_1(v6);
            *(_DWORD *)uint64_t v53 = 136315138;
            *(void *)(v53 + 4) = v54;
            __SC_log_send(5LL, v48, v49, v51);
          }
        }

        uint64_t v55 = sub_57538();
        uint64_t v56 = _SC_syslog_os_log_mapping(6LL);
        if (__SC_log_enabled(6LL, v55, v56))
        {
          uint64_t v57 = _os_log_pack_size(12LL);
          int v58 = &__str[-((__chkstk_darwin(v57) + 15) & 0xFFFFFFFFFFFFFFF0LL) - 8];
          int v59 = __error();
          uint64_t v60 = _os_log_pack_fill(v58, v57, *v59, &dword_0, "MANUAL %s: starting", v77);
          uint64_t v61 = nullsub_1(v6);
          *(_DWORD *)uint64_t v60 = 136315138;
          *(void *)(v60 + 4) = v61;
          __SC_log_send(6LL, v55, v56, v58);
        }

        goto LABEL_47;
      }

      uint64_t v63 = sub_57538();
      uint64_t v64 = _SC_syslog_os_log_mapping(5LL);
      if (__SC_log_enabled(5LL, v63, v64))
      {
        uint64_t v65 = _os_log_pack_size(12LL);
        uint64_t v66 = &__str[-((__chkstk_darwin(v65) + 15) & 0xFFFFFFFFFFFFFFF0LL) - 8];
        uint64_t v67 = __error();
        uint64_t v68 = _os_log_pack_fill(v66, v65, *v67, &dword_0, "MANUAL %s: timer_callout_init failed", v77);
        uint64_t v69 = nullsub_1(v6);
        *(_DWORD *)uint64_t v68 = 136315138;
        *(void *)(v68 + 4) = v69;
        __SC_log_send(5LL, v63, v64, v66);
      }

      uint64_t v8 = 5LL;
      goto LABEL_53;
    case 1:
LABEL_53:
      uint64_t v70 = sub_57538();
      uint64_t v71 = _SC_syslog_os_log_mapping(6LL);
      if (__SC_log_enabled(6LL, v70, v71))
      {
        uint64_t v72 = _os_log_pack_size(12LL);
        CFStringRef v73 = &__str[-((__chkstk_darwin(v72) + 15) & 0xFFFFFFFFFFFFFFF0LL) - 8];
        CFStringRef v74 = __error();
        uint64_t v75 = _os_log_pack_fill(v73, v72, *v74, &dword_0, "MANUAL %s: stop", v77);
        uint64_t v76 = nullsub_1(v6);
        *(_DWORD *)uint64_t v75 = 136315138;
        *(void *)(v75 + 4) = v76;
        __SC_log_send(6LL, v70, v71, v73);
      }

      if (v9)
      {
        sub_18A00(a1);
        if (*(void *)v9) {
          sub_3524((uint64_t **)v9);
        }
        if (*(void *)(v9 + 8)) {
          timer_callout_free((uint64_t *)(v9 + 8));
        }
        free((void *)v9);
        sub_194CC(a1, 0LL);
      }

      return v8;
    case 3:
    case 8:
    case 11:
      if (!v7) {
        return 6LL;
      }
      if (!*(_DWORD *)(v7 + 20))
      {
        *(_DWORD *)(v7 + 24) = 0;
        if (*((_DWORD *)a3 + 1) && !*((_DWORD *)a3 + 2))
        {
          sub_2B654(a1);
        }

        else if (a2 != 11 || !sub_160CC(a1))
        {
LABEL_47:
          sub_2B158(a1, 0, 0LL);
        }
      }

      return 0LL;
    case 4:
      if (!*(_DWORD *)(v7 + 20)) {
        sub_2B69C(a1);
      }
      return 0LL;
    case 7:
      if (!v7)
      {
        uint64_t v38 = sub_57538();
        uint64_t v8 = 6LL;
        uint64_t v39 = _SC_syslog_os_log_mapping(6LL);
        if (__SC_log_enabled(6LL, v38, v39))
        {
          uint64_t v40 = _os_log_pack_size(12LL);
          int v41 = &__str[-((__chkstk_darwin(v40) + 15) & 0xFFFFFFFFFFFFFFF0LL) - 8];
          uint64_t v42 = __error();
          uint64_t v43 = _os_log_pack_fill(v41, v40, *v42, &dword_0, "MANUAL %s: private data is NULL", v77);
          uint64_t v44 = nullsub_1(v6);
          *(_DWORD *)uint64_t v43 = 136315138;
          *(void *)(v43 + 4) = v44;
          uint64_t v8 = 6LL;
          __SC_log_send(6LL, v38, v39, v41);
        }

        return v8;
      }

      uint64_t v17 = *(unsigned int **)a3;
      *((_DWORD *)a3 + 2) = 0;
      int v18 = *v17;
      if (v18 != sub_193D8(a1)
        || sub_14840(a1) && (unsigned int v19 = v17[2], v19 != sub_1485C(a1))
        || v17[4] != *(_DWORD *)(v9 + 20))
      {
        uint64_t v8 = 0LL;
        *((_DWORD *)a3 + 2) = 1;
        return v8;
      }

      unsigned int v20 = v17[1];
      if (v20 != sub_19400(a1) || (unsigned int v21 = v17[3], v21 != sub_19428(a1)))
      {
        sub_193F0(a1, v17[1]);
        sub_19418(a1, v17[3]);
        unint64_t v22 = *v17;
        unint64_t v23 = v17[1];
        unint64_t v24 = v17[3];
LABEL_37:
        sub_18378(a1, v22, v23, v24);
        sub_154F8(a1, 0LL);
      }

      return 0LL;
    case 9:
      if (!v7) {
        return 6LL;
      }
      int v25 = *(_DWORD *)a3;
      if (v25 == sub_193D8(a1) && !sub_1665C(a1, (uint64_t)a3))
      {
        uint64_t v26 = (unsigned __int8 *)*((void *)a3 + 1);
        snprintf( __str,  0x80uLL,  "%d.%d.%d.%d in use by %02x:%02x:%02x:%02x:%02x:%02x",  *a3,  a3[1],  a3[2],  a3[3],  *v26,  v26[1],  v26[2],  v26[3],  v26[4],  v26[5]);
        if (!*(_DWORD *)(v9 + 24)) {
          *(_DWORD *)(v9 + 24) = 1;
        }
        uint64_t v27 = sub_57538();
        uint64_t v28 = _SC_syslog_os_log_mapping(5LL);
        if (__SC_log_enabled(5LL, v27, v28))
        {
          uint64_t v29 = _os_log_pack_size(22LL);
          uint64_t v30 = &__str[-((__chkstk_darwin(v29) + 15) & 0xFFFFFFFFFFFFFFF0LL) - 8];
          uint64_t v31 = __error();
          uint64_t v32 = _os_log_pack_fill(v30, v29, *v31, &dword_0, "MANUAL %s: %s", v77, *(const char **)__str);
          uint64_t v33 = nullsub_1(v6);
          *(_DWORD *)uint64_t v32 = 136315394;
          *(void *)(v32 + 4) = v33;
          *(_WORD *)(v32 + 12) = 2080;
          *(void *)(v32 + 14) = __str;
          __SC_log_send(5LL, v27, v28, v30);
        }

        sub_18A00(a1);
        sub_17FEC(a1, 8u);
        if (dword_6C048 >= 1) {
          timer_set_relative(*(void *)(v9 + 8), dword_6C048, 0, (uint64_t)sub_2B158, a1, 0LL, 0LL);
        }
      }

      return 0LL;
    default:
      return v8;
  }

void sub_2B158(uint64_t a1, int a2, uint64_t a3)
{
  uint64_t v6 = sub_14834(a1);
  uint64_t v7 = (uint64_t *)sub_194C4(a1);
  uint64_t v8 = v7;
  if (a2 == 6)
  {
    if (*(_DWORD *)(a3 + 8))
    {
      uint64_t v11 = sub_57538();
      uint64_t v12 = _SC_syslog_os_log_mapping(5LL);
      if (__SC_log_enabled(5LL, v11, v12))
      {
        uint64_t v13 = _os_log_pack_size(22LL);
        int v14 = &__str[-((__chkstk_darwin(v13) + 15) & 0xFFFFFFFFFFFFFFF0LL) - 8];
        uint64_t v15 = __error();
        uint64_t v16 = _os_log_pack_fill( v14,  v13,  *v15,  &dword_0,  "MANUAL %s: arp probe failed, %s",  v38,  *(const char **)__str);
        uint64_t v17 = nullsub_1(v6);
        uint64_t v18 = sub_4AE0(*v8);
        *(_DWORD *)uint64_t v16 = 136315394;
        *(void *)(v16 + 4) = v17;
        *(_WORD *)(v16 + 12) = 2080;
        *(void *)(v16 + 14) = v18;
        __SC_log_send(5LL, v11, v12, v14);
      }

      timer_callout_set(v8[1], (uint64_t)sub_2B158, a1, 0LL, 0LL, 8.0);
    }

    else if (*(_DWORD *)(a3 + 12))
    {
      unsigned int v23 = sub_193D8(a1);
      snprintf( __str,  0x80uLL,  "%d.%d.%d.%d in use by %02x:%02x:%02x:%02x:%02x:%02x",  v23,  BYTE1(v23),  BYTE2(v23),  HIBYTE(v23),  *(unsigned __int8 *)(a3 + 24),  *(unsigned __int8 *)(a3 + 25),  *(unsigned __int8 *)(a3 + 26),  *(unsigned __int8 *)(a3 + 27),  *(unsigned __int8 *)(a3 + 28),  *(unsigned __int8 *)(a3 + 29));
      if (!*((_DWORD *)v8 + 6)) {
        *((_DWORD *)v8 + 6) = 1;
      }
      uint64_t v24 = sub_57538();
      uint64_t v25 = _SC_syslog_os_log_mapping(5LL);
      if (__SC_log_enabled(5LL, v24, v25))
      {
        uint64_t v26 = _os_log_pack_size(22LL);
        uint64_t v27 = &__str[-((__chkstk_darwin(v26) + 15) & 0xFFFFFFFFFFFFFFF0LL) - 8];
        uint64_t v28 = __error();
        uint64_t v29 = _os_log_pack_fill(v27, v26, *v28, &dword_0, "MANUAL %s: %s", v38, *(const char **)__str);
        uint64_t v30 = nullsub_1(v6);
        *(_DWORD *)uint64_t v29 = 136315394;
        *(void *)(v29 + 4) = v30;
        *(_WORD *)(v29 + 12) = 2080;
        *(void *)(v29 + 14) = __str;
        __SC_log_send(5LL, v24, v25, v27);
      }

      sub_18A00(a1);
      sub_17FEC(a1, 8u);
      if (dword_6C048 >= 1) {
        timer_set_relative(v8[1], dword_6C048, 0, (uint64_t)sub_2B158, a1, 0LL, 0LL);
      }
    }

    else
    {
      unint64_t v31 = sub_19384(a1);
      if (!*((_DWORD *)v8 + 5) && v31 == 1LL && !HIDWORD(v31))
      {
LABEL_25:
        sub_2B69C(a1);
        return;
      }

      unsigned int v32 = sub_193D8(a1);
      unsigned int v33 = sub_19400(a1);
      unsigned int v34 = sub_19428(a1);
      sub_18378(a1, v32, v33, v34);
      int v35 = sub_193D8(a1);
      uint64_t v36 = *v8;
      int v37 = sub_193D8(a1);
      *((_DWORD *)v8 + 4) = 0;
    }
  }

  else if (!a2)
  {
    if (*v7)
    {
      sub_2B654(a1);
      uint64_t v9 = *v8;
      int v10 = sub_193D8(a1);
      sub_45A8(v9, (uint64_t)sub_2B158, a1, 6LL, 0, v10);
      return;
    }

    unint64_t v19 = sub_19384(a1);
    if (*((_DWORD *)v8 + 5) || v19 != 1LL || HIDWORD(v19))
    {
      unsigned int v20 = sub_193D8(a1);
      unsigned int v21 = sub_19400(a1);
      unsigned int v22 = sub_19428(a1);
      sub_18378(a1, v20, v21, v22);
LABEL_14:
      sub_154F8(a1, 0LL);
      return;
    }

    goto LABEL_25;
  }

void sub_2B654(uint64_t a1)
{
  uint64_t v2 = sub_194C4(a1);
  if (v2)
  {
    uint64_t v3 = (uint64_t *)v2;
    uint64_t v4 = *(void *)(v2 + 8);
    if (v4) {
      timer_cancel(v4);
    }
    sub_14528(a1, *v3);
  }

uint64_t sub_2B69C(uint64_t a1)
{
  return sub_17FEC(a1, 0xCu);
}

void sub_2B6CC(uint64_t a1, int a2)
{
  uint64_t v4 = sub_14834(a1);
  uint64_t v5 = sub_194C4(a1);
  uint64_t v6 = v5;
  switch(a2)
  {
    case 0:
      *(_DWORD *)(v5 + 16) = 0;
      goto LABEL_7;
    case 99:
      uint64_t v7 = sub_57538();
      uint64_t v8 = _SC_syslog_os_log_mapping(5LL);
      if (__SC_log_enabled(5LL, v7, v8))
      {
        uint64_t v9 = _os_log_pack_size(22LL);
        int v10 = (char *)v15 - ((__chkstk_darwin(v9) + 15) & 0xFFFFFFFFFFFFFFF0LL);
        uint64_t v11 = __error();
        uint64_t v12 = _os_log_pack_fill( v10,  v9,  *v11,  &dword_0,  "MANUAL %s: router arp resolution failed, %s",  v15[0],  v15[1]);
        uint64_t v13 = nullsub_1(v4);
        uint64_t v14 = sub_4AE0(*(void *)v6);
        *(_DWORD *)uint64_t v12 = 136315394;
        *(void *)(v12 + 4) = v13;
        *(_WORD *)(v12 + 12) = 2080;
        *(void *)(v12 + 14) = v14;
        __SC_log_send(5LL, v7, v8, v10);
      }

      break;
    case 1:
      timer_set_relative(*(void *)(v5 + 8), 60LL, 0, (uint64_t)sub_2B8A4, a1, 0LL, 0LL);
      if (!*(_DWORD *)(v6 + 16))
      {
        *(_DWORD *)(v6 + 16) = 1;
LABEL_7:
        sub_154F8(a1, 0LL);
      }

      break;
  }

uint64_t sub_2B8A4(uint64_t a1)
{
  uint64_t v2 = *(void *)sub_194C4(a1);
  int v3 = sub_193D8(a1);
  return sub_14564(a1, v2, (uint64_t)sub_2B6CC, v3);
}

void sub_2B8E4(char *a1, uint64_t a2)
{
}

void sub_2B8EC(char *cStr, uint64_t a2, int a3)
{
  HIBYTE(v22) = 0;
  if (qword_6C218) {
    BOOL v3 = qword_6C220 == 0;
  }
  else {
    BOOL v3 = 1;
  }
  if (v3)
  {
    uint64_t v4 = sub_57538();
    uint64_t v5 = _SC_syslog_os_log_mapping(5LL);
    if (__SC_log_enabled(5LL, v4, v5))
    {
      uint64_t v6 = _os_log_pack_size(2LL);
      uint64_t v7 = (char *)&v22 - ((__chkstk_darwin(v6) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v8 = __error();
      *(_WORD *)_os_log_pack_fill( v7,  v6,  *v8,  &dword_0,  "S_LinkLocalModifiers or S_InterfaceModifiers is NULL") = 0;
      __SC_log_send(5LL, v4, v5, v7);
    }
  }

  else
  {
    uint64_t v11 = (__CFString *)CFStringCreateWithCString(0LL, cStr, 0x600u);
    uint64_t v12 = (const __CFData *)sub_2C654(v11, (CFDictionaryRef)qword_6C218, (char *)&v22 + 6, (_BYTE *)&v22 + 7);
    int v13 = HIBYTE(v22);
    BOOL v14 = a3 == 0;
    if (a3) {
      char v15 = BYTE6(v22);
    }
    else {
      char v15 = 0;
    }
    if (v14) {
      uint64_t v16 = 0LL;
    }
    else {
      uint64_t v16 = v12;
    }
    uint64_t v17 = (const __CFData *)sub_2C654(v11, (CFDictionaryRef)qword_6C220, (char *)&v22 + 6, (_BYTE *)&v22 + 7);
    int v18 = HIBYTE(v22) | v13;
    if (v16) {
      char v19 = v15;
    }
    else {
      char v19 = BYTE6(v22);
    }
    if (v16) {
      unsigned int v20 = v16;
    }
    else {
      unsigned int v20 = v17;
    }
    CFRelease(v11);
    sub_2C718(a2, v20, v19);
    if (v18)
    {
      unsigned int v21 = (void *)sub_36C04();
      sub_2C76C(v21, (const char *)qword_6C228, qword_6C218, (void *)qword_6C220);
    }
  }

void sub_2BAB0(char *a1, uint64_t a2)
{
}

BOOL sub_2BAB8()
{
  return qword_6C218 != 0;
}

void sub_2BACC(int a1)
{
  if (!dword_6C2EC && sub_2BC1C())
  {
    uint64_t v2 = (void *)sub_36C04();
    if (v2)
    {
      sub_2BD7C(v2, a1);
    }

    else
    {
      uint64_t v3 = sub_57538();
      uint64_t v4 = _SC_syslog_os_log_mapping(5LL);
      if (__SC_log_enabled(5LL, v3, v4))
      {
        uint64_t v5 = _os_log_pack_size(2LL);
        uint64_t v6 = (char *)&v8 - ((__chkstk_darwin(v5) + 15) & 0xFFFFFFFFFFFFFFF0LL);
        uint64_t v7 = __error();
        *(_WORD *)_os_log_pack_fill(v6, v5, *v7, &dword_0, "Failed to get HostUUID") = 0;
        __SC_log_send(5LL, v3, v4, v6);
      }
    }
  }

uint64_t sub_2BC1C()
{
  size_t v10 = 4LL;
  if (!sysctlbyname("net.inet6.send.opmode", &v11, &v10, 0LL, 0LL)) {
    return v11 != 0;
  }
  uint64_t v0 = sub_57538();
  uint64_t v1 = _SC_syslog_os_log_mapping(5LL);
  uint64_t result = __SC_log_enabled(5LL, v0, v1);
  if ((_DWORD)result)
  {
    uint64_t v3 = _os_log_pack_size(22LL);
    uint64_t v4 = (char *)&v9 - ((__chkstk_darwin(v3) + 15) & 0xFFFFFFFFFFFFFFF0LL);
    uint64_t v5 = __error();
    uint64_t v6 = _os_log_pack_fill(v4, v3, *v5, &dword_0, "sysctl(%s) failed, %s", v9, (const char *)v10);
    uint64_t v7 = __error();
    uint64_t v8 = strerror(*v7);
    *(_DWORD *)uint64_t v6 = 136315394;
    *(void *)(v6 + 4) = "net.inet6.send.opmode";
    *(_WORD *)(v6 + 12) = 2080;
    *(void *)(v6 + 14) = v8;
    __SC_log_send(5LL, v0, v1, v4);
    return 0LL;
  }

  return result;
}

void sub_2BD7C(void *a1, int a2)
{
  uint64_t v67 = 0LL;
  uint64_t v4 = "/var/db/dhcpclient/CGA.plist";
  CFPropertyListRef v5 = sub_4FA48("/var/db/dhcpclient/CGA.plist");
  uint64_t v66 = v5;
  CFTypeID TypeID = CFDictionaryGetTypeID();
  if (!v5) {
    goto LABEL_34;
  }
  if (CFGetTypeID(v5) != TypeID)
  {
    uint64_t v37 = sub_57538();
    uint64_t v38 = _SC_syslog_os_log_mapping(5LL);
    uint64_t v39 = _os_log_pack_size(12LL);
    uint64_t v40 = (char *)&v65 - ((__chkstk_darwin(v39) + 15) & 0xFFFFFFFFFFFFFFF0LL);
    int v41 = __error();
    uint64_t v42 = _os_log_pack_fill(v40, v39, *v41, &dword_0, "%s is not a dictionary", v65);
    int v43 = 136315138;
LABEL_32:
    *(_DWORD *)uint64_t v42 = v43;
    *(void *)(v42 + 4) = v4;
    uint64_t v46 = v37;
    uint64_t v47 = v38;
LABEL_33:
    __SC_log_send(5LL, v46, v47, v40);
    goto LABEL_34;
  }

  uint64_t v4 = @"HostUUID";
  int Value = CFDictionaryGetValue((CFDictionaryRef)v5, @"HostUUID");
  CFTypeID v8 = CFDataGetTypeID();
  if (!Value || CFGetTypeID(Value) != v8 || !CFEqual(Value, a1))
  {
    uint64_t v37 = sub_57538();
    uint64_t v38 = _SC_syslog_os_log_mapping(5LL);
    uint64_t v44 = _os_log_pack_size(12LL);
    uint64_t v40 = (char *)&v65 - ((__chkstk_darwin(v44) + 15) & 0xFFFFFFFFFFFFFFF0LL);
    uint64_t v45 = __error();
    uint64_t v42 = _os_log_pack_fill(v40, v44, *v45, &dword_0, "%@ missing/invalid");
    int v43 = 138412290;
    goto LABEL_32;
  }

  uint64_t v9 = @"GlobalModifier";
  size_t v10 = CFDictionaryGetValue((CFDictionaryRef)v5, @"GlobalModifier");
  if (!v10 || (int v11 = v10, (v12 = (const __CFData *)sub_2C974(v10, (_BYTE *)&v65 + 7)) == 0LL))
  {
    uint64_t v52 = sub_57538();
    uint64_t v53 = _SC_syslog_os_log_mapping(5LL);
    goto LABEL_47;
  }

  int v13 = v12;
  uint64_t v9 = (const __CFString *)"/var/db/dhcpclient/CGAKeys.plist";
  CFPropertyListRef v14 = sub_4FA48("/var/db/dhcpclient/CGAKeys.plist");
  uint64_t v67 = v14;
  CFTypeID v15 = CFDictionaryGetTypeID();
  if (v14)
  {
    if (CFGetTypeID(v14) != v15)
    {
      uint64_t v52 = sub_57538();
      uint64_t v53 = _SC_syslog_os_log_mapping(5LL);
      uint64_t v58 = _os_log_pack_size(12LL);
      uint64_t v40 = (char *)&v65 - ((__chkstk_darwin(v58) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      int v59 = __error();
      uint64_t v56 = _os_log_pack_fill(v40, v58, *v59, &dword_0, "%s is not a dictionary", v65);
      int v57 = 136315138;
      goto LABEL_48;
    }

    uint64_t v9 = @"PrivateKey";
    uint64_t v16 = CFDictionaryGetValue((CFDictionaryRef)v14, @"PrivateKey");
    CFTypeID v17 = CFDataGetTypeID();
    if (!v16 || CFGetTypeID(v16) != v17)
    {
      uint64_t v52 = sub_57538();
      uint64_t v53 = _SC_syslog_os_log_mapping(5LL);
      goto LABEL_47;
    }

    uint64_t v9 = @"PublicKey";
    int v18 = (const __CFData *)CFDictionaryGetValue((CFDictionaryRef)v14, @"PublicKey");
    CFTypeID v19 = CFDataGetTypeID();
    if (v18 && CFGetTypeID(v18) == v19)
    {
      if (sub_2CB6C((const __CFData *)v16, v18, v13, SHIBYTE(v65)))
      {
        unsigned int v20 = CFDictionaryGetValue((CFDictionaryRef)v5, @"LinkLocalModifiers");
        if (v20)
        {
          CFTypeID v21 = CFDictionaryGetTypeID();
          if (CFGetTypeID(v20) != v21)
          {
            uint64_t v22 = sub_57538();
            uint64_t v23 = _SC_syslog_os_log_mapping(5LL);
            if (__SC_log_enabled(5LL, v22, v23))
            {
              uint64_t v24 = _os_log_pack_size(12LL);
              uint64_t v25 = (char *)&v65 - ((__chkstk_darwin(v24) + 15) & 0xFFFFFFFFFFFFFFF0LL);
              uint64_t v26 = __error();
              uint64_t v27 = _os_log_pack_fill(v25, v24, *v26, &dword_0, "%@ is not a dictionary");
              *(_DWORD *)uint64_t v27 = 138412290;
              *(void *)(v27 + 4) = @"LinkLocalModifiers";
              __SC_log_send(5LL, v22, v23, v25);
            }

            unsigned int v20 = 0LL;
          }
        }

        uint64_t v28 = CFDictionaryGetValue((CFDictionaryRef)v5, @"InterfaceModifiers");
        if (v28)
        {
          CFTypeID v29 = CFDictionaryGetTypeID();
          if (CFGetTypeID(v28) != v29)
          {
            uint64_t v30 = sub_57538();
            uint64_t v31 = _SC_syslog_os_log_mapping(5LL);
            if (__SC_log_enabled(5LL, v30, v31))
            {
              uint64_t v32 = _os_log_pack_size(12LL);
              unsigned int v33 = (char *)&v65 - ((__chkstk_darwin(v32) + 15) & 0xFFFFFFFFFFFFFFF0LL);
              unsigned int v34 = __error();
              uint64_t v35 = _os_log_pack_fill(v33, v32, *v34, &dword_0, "%@ is not a dictionary");
              *(_DWORD *)uint64_t v35 = 138412290;
              *(void *)(v35 + 4) = @"InterfaceModifiers";
              __SC_log_send(5LL, v30, v31, v33);
            }

            uint64_t v28 = 0LL;
          }
        }

        qword_6C228 = (uint64_t)CFRetain(v11);
        if (v20)
        {
          CFMutableArrayRef MutableCopy = CFDictionaryCreateMutableCopy(0LL, 0LL, (CFDictionaryRef)v20);
          qword_6C218 = (uint64_t)MutableCopy;
          if (a2) {
            sub_2CD54(MutableCopy);
          }
          goto LABEL_41;
        }

LABEL_40:
        qword_6C218 = (uint64_t)CFDictionaryCreateMutable( 0LL,  0LL,  &kCFTypeDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
LABEL_41:
        if (v28) {
          CFMutableDictionaryRef Mutable = CFDictionaryCreateMutableCopy(0LL, 0LL, (CFDictionaryRef)v28);
        }
        else {
          CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable( 0LL,  0LL,  &kCFTypeDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
        }
        qword_6C220 = (uint64_t)Mutable;
        goto LABEL_45;
      }

      uint64_t v60 = sub_57538();
      uint64_t v61 = _SC_syslog_os_log_mapping(5LL);
      if (__SC_log_enabled(5LL, v60, v61))
      {
        uint64_t v62 = _os_log_pack_size(2LL);
        uint64_t v63 = (char *)&v65 - ((__chkstk_darwin(v62) + 15) & 0xFFFFFFFFFFFFFFF0LL);
        uint64_t v64 = __error();
        *(_WORD *)_os_log_pack_fill(v63, v62, *v64, &dword_0, "cga_parameters_set failed") = 0;
        __SC_log_send(5LL, v60, v61, v63);
      }

      goto LABEL_45;
    }

    uint64_t v52 = sub_57538();
    uint64_t v53 = _SC_syslog_os_log_mapping(5LL);
    if (__SC_log_enabled(5LL, v52, v53))
    {
LABEL_47:
      uint64_t v54 = _os_log_pack_size(12LL);
      uint64_t v40 = (char *)&v65 - ((__chkstk_darwin(v54) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v55 = *__error();
      uint64_t v56 = _os_log_pack_fill(v40, v54, v55, &dword_0, "%@ missing/invalid");
      int v57 = 138412290;
LABEL_48:
      *(_DWORD *)uint64_t v56 = v57;
      *(void *)(v56 + 4) = v9;
      uint64_t v46 = v52;
      uint64_t v47 = v53;
      goto LABEL_33;
    }
  }

void *sub_2C654(void *key, CFDictionaryRef theDict, char *a3, _BYTE *a4)
{
  *a4 = 0;
  int Value = CFDictionaryGetValue(theDict, key);
  CFTypeID TypeID = CFDictionaryGetTypeID();
  if (!Value || CFGetTypeID(Value) != TypeID || (size_t v10 = (void *)sub_2C974(Value, a3)) == 0LL)
  {
    *a3 = 0;
    size_t v10 = sub_2CA48(0x10uLL);
    CFDictionaryRef v11 = sub_2CA90(v10, *a3);
    CFRelease(v10);
    CFDictionarySetValue(theDict, key, v11);
    CFRelease(v11);
    *a4 = 1;
  }

  return v10;
}

void sub_2C718(uint64_t a1, CFDataRef theData, char a3)
{
  v6.length = CFDataGetLength(theData);
  v6.location = 0LL;
  CFDataGetBytes(theData, v6, (UInt8 *)a1);
  *(_BYTE *)(a1 + 16) = a3;
  *(void *)(a1 + 17) = 0LL;
  *(void *)(a1 + 24) = 0LL;
}

BOOL sub_2C76C(void *a1, const char *a2, uint64_t a3, void *a4)
{
  *(_OWORD *)keys = *(_OWORD *)off_64EC8;
  __int128 v24 = unk_64ED8;
  values = a1;
  unsigned int v20 = a2;
  uint64_t v21 = 0LL;
  uint64_t v22 = 0LL;
  if (!a3)
  {
    CFIndex v4 = 2LL;
    if (!a4) {
      goto LABEL_4;
    }
    goto LABEL_3;
  }

  *(void *)&__int128 v24 = @"LinkLocalModifiers";
  uint64_t v21 = a3;
  CFIndex v4 = 3LL;
  if (a4)
  {
LABEL_3:
    keys[v4] = @"InterfaceModifiers";
    *(&values + v4++) = a4;
  }

LABEL_4:
  CFDictionaryRef v5 = CFDictionaryCreate( 0LL,  (const void **)keys,  (const void **)&values,  v4,  &kCFTypeDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
  int v6 = sub_4FB24(v5, "/var/db/dhcpclient/CGA.plist", 0x1A4u);
  if (v6 < 0)
  {
    uint64_t v7 = sub_57538();
    uint64_t v8 = *__error() == 2 ? 6LL : 5LL;
    uint64_t v9 = _SC_syslog_os_log_mapping(v8);
    uint64_t v10 = *__error() == 2 ? 6LL : 5LL;
    if (__SC_log_enabled(v10, v7, v9))
    {
      uint64_t v11 = _os_log_pack_size(22LL);
      uint64_t v12 = (char *)&values - ((__chkstk_darwin(v11) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      int v13 = __error();
      uint64_t v14 = _os_log_pack_fill( v12,  v11,  *v13,  &dword_0,  "CGAParameters: failed to write %s, %s",  (const char *)values,  v20);
      CFTypeID v15 = __error();
      uint64_t v16 = strerror(*v15);
      *(_DWORD *)uint64_t v14 = 136315394;
      *(void *)(v14 + 4) = "/var/db/dhcpclient/CGA.plist";
      *(_WORD *)(v14 + 12) = 2080;
      *(void *)(v14 + 14) = v16;
      if (*__error() == 2) {
        uint64_t v17 = 6LL;
      }
      else {
        uint64_t v17 = 5LL;
      }
      __SC_log_send(v17, v7, v9, v12);
    }
  }

  CFRelease(v5);
  return v6 >= 0;
}

  if (a3) {
    vm_deallocate(mach_task_self_, (vm_address_t)a3, a4);
  }
  *a5 = v11;
  return 0LL;
}

  if (a3)
  {
    keys[v5] = (void *)kSCPropNetIPv4RouteGatewayAddress;
    values[v5++] = (void *)sub_50068(*a3);
  }

  else if (!v5)
  {
    return 0LL;
  }

  int v6 = v5;
  uint64_t v7 = values;
  uint64_t v8 = CFDictionaryCreate( 0LL,  (const void **)keys,  (const void **)values,  v6,  &kCFTypeDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
  do
  {
    uint64_t v9 = *v7++;
    CFRelease(v9);
    --v6;
  }

  while (v6);
  return v8;
}

const void *sub_2C974(const void *a1, _BYTE *a2)
{
  *a2 = 0;
  CFTypeID TypeID = CFDictionaryGetTypeID();
  if (!a1 || CFGetTypeID(a1) != TypeID) {
    return 0LL;
  }
  int Value = CFDictionaryGetValue((CFDictionaryRef)a1, @"Modifier");
  CFTypeID v6 = CFDataGetTypeID();
  if (!Value) {
    return Value;
  }
  if (CFGetTypeID(Value) != v6 || CFDataGetLength((CFDataRef)Value) != 16) {
    return 0LL;
  }
  uint64_t v7 = (const __CFNumber *)CFDictionaryGetValue((CFDictionaryRef)a1, @"SecurityLevel");
  CFTypeID v8 = CFNumberGetTypeID();
  if (v7 && CFGetTypeID(v7) == v8) {
    CFNumberGetValue(v7, kCFNumberSInt8Type, a2);
  }
  return Value;
}

__CFData *sub_2CA48(size_t capacity)
{
  CFMutableDictionaryRef Mutable = CFDataCreateMutable(0LL, capacity);
  CFDataSetLength(Mutable, capacity);
  MutableBytePtr = CFDataGetMutableBytePtr(Mutable);
  arc4random_buf(MutableBytePtr, capacity);
  return Mutable;
}

CFDictionaryRef sub_2CA90(void *a1, char a2)
{
  char valuePtr = a2;
  CFAbsoluteTime Current = CFAbsoluteTimeGetCurrent();
  CFDateRef v4 = CFDateCreate(0LL, Current);
  CFNumberRef v5 = CFNumberCreate(0LL, kCFNumberSInt8Type, &valuePtr);
  *(_OWORD *)keys = *(_OWORD *)off_64EB0;
  uint64_t v11 = @"CreationDate";
  values[0] = a1;
  values[1] = v5;
  values[2] = v4;
  CFDictionaryRef v6 = CFDictionaryCreate( 0LL,  (const void **)keys,  (const void **)values,  3LL,  &kCFTypeDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
  CFRelease(v4);
  CFRelease(v5);
  return v6;
}

BOOL sub_2CB6C(const __CFData *a1, const __CFData *a2, const __CFData *a3, char a4)
{
  unsigned __int16 Length = CFDataGetLength(a1);
  unsigned __int16 v20 = Length;
  v22.length = Length;
  v22.location = 0LL;
  CFDataGetBytes(a1, v22, v21);
  uint64_t v7 = &v21[Length];
  unsigned __int16 v8 = CFDataGetLength(a2);
  *(_WORD *)uint64_t v7 = v8;
  v7 += 2;
  v23.length = v8;
  v23.location = 0LL;
  CFDataGetBytes(a2, v23, v7);
  int v9 = sysctlbyname("net.inet6.send.cga_parameters", 0LL, 0LL, (char *)v19 + 4, &v7[v8] - ((UInt8 *)v19 + 4));
  if (v9)
  {
    uint64_t v10 = sub_57538();
    uint64_t v11 = _SC_syslog_os_log_mapping(5LL);
    if (__SC_log_enabled(5LL, v10, v11))
    {
      uint64_t v12 = _os_log_pack_size(22LL);
      int v13 = (char *)v19 - ((__chkstk_darwin(v12) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v14 = __error();
      uint64_t v15 = _os_log_pack_fill(v13, v12, *v14, &dword_0, "sysctl(%s) failed, %s", v19[0], v19[1]);
      uint64_t v16 = __error();
      uint64_t v17 = strerror(*v16);
      *(_DWORD *)uint64_t v15 = 136315394;
      *(void *)(v15 + 4) = "net.inet6.send.cga_parameters";
      *(_WORD *)(v15 + 12) = 2080;
      *(void *)(v15 + 14) = v17;
      __SC_log_send(5LL, v10, v11, v13);
    }
  }

  return v9 == 0;
}

void sub_2CD54(const __CFDictionary *a1)
{
  CFIndex Count = CFDictionaryGetCount(a1);
  if (Count >= 1)
  {
    CFIndex v3 = Count;
    uint64_t v21 = (uint64_t)&v21;
    uint64_t v4 = __chkstk_darwin(Count);
    CFDictionaryRef v6 = (const void **)((char *)&v21 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0LL));
    __chkstk_darwin(v4);
    unsigned __int16 v8 = (const void **)((char *)&v21 - v7);
    CFAbsoluteTime Current = CFAbsoluteTimeGetCurrent();
    CFDateRef v22 = CFDateCreate(0LL, Current);
    CFDictionaryGetKeysAndValues(a1, v6, v8);
    *(void *)&__int128 v10 = 138412290LL;
    __int128 v23 = v10;
    do
    {
      uint64_t v11 = (const __CFDictionary *)*v8;
      if (!sub_2C974(*v8, &v24)
        || (Value = CFDictionaryGetValue(v11, @"CreationDate"), CFTypeID TypeID = CFDateGetTypeID(), !Value)
        || CFGetTypeID(Value) != TypeID
        || CFDateGetTimeIntervalSinceDate(v22, (CFDateRef)Value) >= 86400.0)
      {
        uint64_t v14 = *v6;
        uint64_t v15 = sub_57538();
        uint64_t v16 = _SC_syslog_os_log_mapping(5LL);
        if (__SC_log_enabled(5LL, v15, v16))
        {
          uint64_t v17 = _os_log_pack_size(12LL);
          int v18 = (char *)&v21 - ((__chkstk_darwin(v17) + 15) & 0xFFFFFFFFFFFFFFF0LL);
          CFTypeID v19 = __error();
          uint64_t v20 = _os_log_pack_fill(v18, v17, *v19, &dword_0, "%@: CGA linklocal modifier expired");
          *(_DWORD *)uint64_t v20 = v23;
          *(void *)(v20 + 4) = v14;
          __SC_log_send(5LL, v15, v16, v18);
        }

        CFDictionaryRemoveValue(a1, v14);
      }

      ++v6;
      ++v8;
      --v3;
    }

    while (v3);
    CFRelease(v22);
  }

BOOL sub_2CF88(void *a1, const char *a2)
{
  *(_OWORD *)keys = *(_OWORD *)off_64EE8;
  values = a1;
  uint64_t v17 = a2;
  CFDictionaryRef v2 = CFDictionaryCreate( 0LL,  (const void **)keys,  (const void **)&values,  2LL,  &kCFTypeDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
  int v3 = sub_4FB24(v2, "/var/db/dhcpclient/CGAKeys.plist", 0x180u);
  if (v3 < 0)
  {
    uint64_t v4 = sub_57538();
    uint64_t v5 = *__error() == 2 ? 6LL : 5LL;
    uint64_t v6 = _SC_syslog_os_log_mapping(v5);
    uint64_t v7 = *__error() == 2 ? 6LL : 5LL;
    if (__SC_log_enabled(v7, v4, v6))
    {
      uint64_t v8 = _os_log_pack_size(22LL);
      int v9 = (char *)&values - ((__chkstk_darwin(v8) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      __int128 v10 = __error();
      uint64_t v11 = _os_log_pack_fill( v9,  v8,  *v10,  &dword_0,  "CGAParameters: failed to write %s, %s",  (const char *)values,  v17);
      uint64_t v12 = __error();
      int v13 = strerror(*v12);
      *(_DWORD *)uint64_t v11 = 136315394;
      *(void *)(v11 + 4) = "/var/db/dhcpclient/CGAKeys.plist";
      *(_WORD *)(v11 + 12) = 2080;
      *(void *)(v11 + 14) = v13;
      if (*__error() == 2) {
        uint64_t v14 = 6LL;
      }
      else {
        uint64_t v14 = 5LL;
      }
      __SC_log_send(v14, v4, v6, v9);
    }
  }

  CFRelease(v2);
  return v3 >= 0;
}

uint64_t sub_2D148(uint64_t a1, uint64_t a2, _DWORD *a3, _DWORD *a4)
{
  *(_BYTE *)(a2 + 15) = 0;
  *a4 = sub_1B544((const char *)a2, a3);
  return 0LL;
}

uint64_t sub_2D17C(uint64_t a1, _DWORD *a2)
{
  *a2 = sub_1B538();
  return 0LL;
}

uint64_t sub_2D1A4(uint64_t a1, uint64_t a2, int a3, vm_address_t *a4, _DWORD *a5, _DWORD *a6)
{
  *(_BYTE *)(a2 + 15) = 0;
  *a6 = sub_1B5CC((const char *)a2, a3, a4, a5);
  return 0LL;
}

uint64_t sub_2D1E0(uint64_t a1, uint64_t a2, vm_address_t *a3, _DWORD *a4, _DWORD *a5)
{
  *(_BYTE *)(a2 + 15) = 0;
  *a5 = sub_1B758((const char *)a2, a3, a4);
  return 0LL;
}

uint64_t sub_2D218(uint64_t a1, uint64_t a2, vm_address_t *a3, _DWORD *a4, _DWORD *a5)
{
  *(_BYTE *)(a2 + 15) = 0;
  *a5 = sub_1BA08((const char *)a2, a3, a4);
  return 0LL;
}

uint64_t sub_2D250(uint64_t a1, char *a2, UInt8 *a3, unsigned int a4, int *a5, _OWORD *a6)
{
  __int128 v10 = a6[1];
  *(_OWORD *)atoken.val = *a6;
  *(_OWORD *)&atoken.val[4] = v10;
  dword_6C0E8 = -1;
  dword_6C0EC = -1;
  audit_token_to_au32(&atoken, 0LL, (uid_t *)&dword_6C0E8, 0LL, 0LL, 0LL, &dword_6C0EC, 0LL, 0LL);
  if (dword_6C0E8)
  {
    int v11 = 1;
    goto LABEL_4;
  }

  uint64_t v15 = 0LL;
  __int128 v14 = 0u;
  memset(&atoken, 0, sizeof(atoken));
  int v11 = sub_2D3AC(a3, a4, (in_addr *)&atoken);
  if (!v11)
  {
    a2[15] = 0;
    int v11 = sub_1C488(a2, (int *)&atoken);
    if (atoken.val[0] == 516)
    {
      if (atoken.val[2] != 3) {
        goto LABEL_4;
      }
    }

    else if (atoken.val[0] != 259)
    {
      goto LABEL_4;
    }

    if (*(void *)&atoken.val[4])
    {
      free(*(void **)&atoken.val[4]);
      *(void *)&atoken.val[4] = 0LL;
    }
  }

CFIndex sub_2D3AC(UInt8 *a1, int a2, in_addr *a3)
{
  if (!a1) {
    return sub_19F0C(0LL, a3);
  }
  uint64_t v4 = sub_5076C(a1, a2);
  CFIndex v5 = sub_19F0C((CFIndex)v4, a3);
  if (v4) {
    CFRelease(v4);
  }
  return v5;
}

uint64_t sub_2D400(uint64_t a1, uint64_t a2, _DWORD *a3)
{
  *a3 = 1;
  return 0LL;
}

uint64_t sub_2D410(uint64_t a1, char *a2, UInt8 *a3, unsigned int a4, _OWORD *a5, int *a6, __int128 *a7)
{
  __int128 v12 = a7[1];
  __int128 v16 = *a7;
  *(_OWORD *)uint64_t v17 = v12;
  if (!sub_2D584(&v16))
  {
    int v14 = 1;
    goto LABEL_9;
  }

  if (a3) {
    int v13 = sub_5076C(a3, a4);
  }
  else {
    int v13 = 0LL;
  }
  uint64_t v19 = 0LL;
  *(_OWORD *)uint64_t v17 = 0u;
  __int128 v18 = 0u;
  __int128 v16 = 0u;
  int v14 = sub_19F0C((CFIndex)v13, (in_addr *)&v16);
  if (!v14)
  {
    a5[6] = 0u;
    a5[7] = 0u;
    a5[4] = 0u;
    a5[5] = 0u;
    a5[2] = 0u;
    a5[3] = 0u;
    *a5 = 0u;
    a5[1] = 0u;
    a2[15] = 0;
    int v14 = sub_1CDA8(a2, (int *)&v16, (uint64_t)a5, v13, dword_6C0EC);
    if ((_DWORD)v16 == 516)
    {
      if (DWORD2(v16) != 3) {
        goto LABEL_7;
      }
    }

    else if ((_DWORD)v16 != 259)
    {
      goto LABEL_7;
    }

    if (v17[0])
    {
      free(v17[0]);
      v17[0] = 0LL;
    }
  }

BOOL sub_2D584(_OWORD *a1)
{
  __int128 v2 = a1[1];
  *(_OWORD *)atoken.val = *a1;
  *(_OWORD *)&atoken.val[4] = v2;
  dword_6C0E8 = -1;
  dword_6C0EC = -1;
  audit_token_to_au32(&atoken, 0LL, (uid_t *)&dword_6C0E8, 0LL, 0LL, 0LL, &dword_6C0EC, 0LL, 0LL);
  if (!dword_6C0E8) {
    return 1LL;
  }
  __int128 v3 = a1[1];
  *(_OWORD *)atoken.val = *a1;
  *(_OWORD *)&atoken.val[4] = v3;
  uint64_t v4 = SecTaskCreateWithAuditToken(0LL, &atoken);
  if (v4)
  {
    CFIndex v5 = v4;
    uint64_t v6 = (const __CFBoolean *)SecTaskCopyValueForEntitlement(v4, @"com.apple.IPConfigurationService", 0LL);
    if (v6)
    {
      uint64_t v7 = v6;
      CFTypeID TypeID = CFBooleanGetTypeID();
      if (CFGetTypeID(v7) == TypeID)
      {
        int Value = CFBooleanGetValue(v7);
        CFRelease(v7);
        CFRelease(v5);
        return Value != 0;
      }

      CFRelease(v7);
    }

    CFRelease(v5);
  }

  return 0LL;
}

uint64_t _ipconfig_set_service( uint64_t a1, char *a2, UInt8 *a3, unsigned int a4, _OWORD *a5, int *a6, __int128 *a7)
{
  __int128 v12 = a7[1];
  __int128 v15 = *a7;
  *(_OWORD *)__int128 v16 = v12;
  if (!sub_2D584(&v15))
  {
    int v13 = 1;
    goto LABEL_7;
  }

  uint64_t v18 = 0LL;
  *(_OWORD *)__int128 v16 = 0u;
  __int128 v17 = 0u;
  __int128 v15 = 0u;
  int v13 = sub_2D3AC(a3, a4, (in_addr *)&v15);
  if (v13) {
    goto LABEL_7;
  }
  a5[6] = 0u;
  a5[7] = 0u;
  a5[4] = 0u;
  a5[5] = 0u;
  a5[2] = 0u;
  a5[3] = 0u;
  *a5 = 0u;
  a5[1] = 0u;
  a2[15] = 0;
  int v13 = sub_1D50C(a2, (int *)&v15, (uint64_t)a5);
  if ((_DWORD)v15 == 516)
  {
    if (DWORD2(v15) != 3) {
      goto LABEL_7;
    }
  }

  else if ((_DWORD)v15 != 259)
  {
    goto LABEL_7;
  }

  if (v16[0])
  {
    free(v16[0]);
    v16[0] = 0LL;
  }

uint64_t sub_2D7C0(uint64_t a1, uint64_t a2, uint64_t a3, int *a4, _OWORD *a5)
{
  __int128 v8 = a5[1];
  v11[0] = *a5;
  v11[1] = v8;
  if (sub_2D584(v11))
  {
    if (*(_BYTE *)a2) {
      *(_BYTE *)(a2 + 15) = 0;
    }
    else {
      a2 = 0LL;
    }
    *(_BYTE *)(a3 + 127) = 0;
    int v9 = sub_1D520((const char *)a2, (const char *)a3);
  }

  else
  {
    int v9 = 1;
  }

  *a4 = v9;
  return 0LL;
}

uint64_t sub_2D83C(uint64_t a1, uint64_t a2, int a3, UInt8 *a4, unsigned int a5, _OWORD *a6, _DWORD *a7)
{
  a6[6] = 0u;
  a6[7] = 0u;
  a6[4] = 0u;
  a6[5] = 0u;
  a6[2] = 0u;
  a6[3] = 0u;
  *a6 = 0u;
  a6[1] = 0u;
  __int128 v15 = 0u;
  *(_OWORD *)__int128 v16 = 0u;
  __int128 v17 = 0u;
  uint64_t v18 = 0LL;
  int v13 = sub_2D3AC(a4, a5, (in_addr *)&v15);
  if (!v13)
  {
    *(_BYTE *)(a2 + 15) = 0;
    int v13 = sub_1D5EC((const char *)a2, a3, (int *)&v15, (uint64_t)a6);
    if ((_DWORD)v15 == 516)
    {
      if (DWORD2(v15) != 3) {
        goto LABEL_2;
      }
    }

    else if ((_DWORD)v15 != 259)
    {
      goto LABEL_2;
    }

    if (v16[0])
    {
      free(v16[0]);
      v16[0] = 0LL;
    }
  }

uint64_t sub_2D968(uint64_t a1, uint64_t a2, UInt8 *a3, unsigned int a4, int *a5, __int128 *a6)
{
  __int128 v10 = a6[1];
  __int128 v13 = *a6;
  *(_OWORD *)int v14 = v10;
  if (!sub_2D584(&v13))
  {
    int v11 = 1;
    goto LABEL_7;
  }

  uint64_t v16 = 0LL;
  *(_OWORD *)int v14 = 0u;
  __int128 v15 = 0u;
  __int128 v13 = 0u;
  int v11 = sub_2D3AC(a3, a4, (in_addr *)&v13);
  if (v11) {
    goto LABEL_7;
  }
  *(_BYTE *)(a2 + 15) = 0;
  int v11 = sub_1D8A0((const char *)a2, (int *)&v13);
  if ((_DWORD)v13 == 516)
  {
    if (DWORD2(v13) != 3) {
      goto LABEL_7;
    }
  }

  else if ((_DWORD)v13 != 259)
  {
    goto LABEL_7;
  }

  if (v14[0])
  {
    free(v14[0]);
    v14[0] = 0LL;
  }

uint64_t sub_2DA84(uint64_t a1, uint64_t a2, uint64_t a3, int *a4, _OWORD *a5)
{
  __int128 v8 = a5[1];
  v11[0] = *a5;
  v11[1] = v8;
  if (sub_2D584(v11))
  {
    *(_BYTE *)(a3 + 127) = 0;
    *(_BYTE *)(a2 + 15) = 0;
    int v9 = sub_1DA7C((const char *)a2, (const char *)a3);
  }

  else
  {
    int v9 = 1;
  }

  *a4 = v9;
  return 0LL;
}

uint64_t sub_2DAF0(uint64_t a1, uint64_t a2, uint64_t a3, _DWORD *a4)
{
  *(_BYTE *)(a2 + 15) = 0;
  *(_BYTE *)(a3 + 127) = 0;
  *a4 = sub_1DC9C((const char *)a2, (const char *)a3);
  return 0LL;
}

uint64_t sub_2DB28(uint64_t a1, uint64_t a2, UInt8 *a3, unsigned int a4, int *a5, _OWORD *a6)
{
  __int128 v10 = a6[1];
  *(_OWORD *)atoken.val = *a6;
  *(_OWORD *)&atoken.val[4] = v10;
  dword_6C0E8 = -1;
  dword_6C0EC = -1;
  uint64_t v18 = 0LL;
  audit_token_to_au32(&atoken, 0LL, (uid_t *)&dword_6C0E8, 0LL, 0LL, 0LL, &dword_6C0EC, 0LL, 0LL);
  if (dword_6C0E8)
  {
    int v11 = 1;
    if (a3) {
LABEL_3:
    }
      vm_deallocate(mach_task_self_, (vm_address_t)a3, a4);
  }

  else
  {
    if (a3
      && (__int128 v13 = sub_5076C(a3, a4), v18 = v13, TypeID = CFDictionaryGetTypeID(), v13)
      && CFGetTypeID(v13) == TypeID
      && (Value = CFDictionaryGetValue(v13, @"SSID"), CFTypeID v16 = CFStringGetTypeID(), Value))
    {
      if (CFGetTypeID(Value) == v16) {
        uint64_t v17 = (uint64_t)Value;
      }
      else {
        uint64_t v17 = 0LL;
      }
    }

    else
    {
      uint64_t v17 = 0LL;
    }

    *(_BYTE *)(a2 + 15) = 0;
    int v11 = sub_1DD08((const char *)a2, v17);
    sub_4FA18((const void **)&v18);
    if (a3) {
      goto LABEL_3;
    }
  }

  *a5 = v11;
  return 0LL;
}

uint64_t sub_2DC6C(uint64_t a1, uint64_t a2, const __CFData **a3, _DWORD *a4, _DWORD *a5)
{
  *(_BYTE *)(a2 + 15) = 0;
  *a5 = sub_1BAEC((const char *)a2, a3, a4);
  return 0LL;
}

uint64_t sub_2DCA4(uint64_t a1, uint64_t a2, const __CFData **a3, _DWORD *a4, int *a5)
{
  CFTypeID v16 = 0LL;
  *a3 = 0LL;
  *a4 = 0;
  *(_BYTE *)(a2 + 15) = 0;
  int v8 = sub_1BBF4((const char *)a2, (uint64_t *)&v16);
  if (v16)
  {
    int v9 = sub_506B8(v16, a4);
    *a3 = v9;
    if (!v9)
    {
      uint64_t v10 = sub_57538();
      int v8 = 5;
      uint64_t v11 = _SC_syslog_os_log_mapping(5LL);
      if (__SC_log_enabled(5LL, v10, v11))
      {
        uint64_t v12 = _os_log_pack_size(2LL);
        __int128 v13 = (char *)&v16 - ((__chkstk_darwin(v12) + 15) & 0xFFFFFFFFFFFFFFF0LL);
        int v14 = __error();
        *(_WORD *)_os_log_pack_fill(v13, v12, *v14, &dword_0, "failed to serialize data") = 0;
        int v8 = 5;
        __SC_log_send(5LL, v10, v11, v13);
      }
    }
  }

  sub_4FA18(&v16);
  *a5 = v8;
  return 0LL;
}

uint64_t sub_2DDF8(uint64_t a1, const __CFData **a2, _DWORD *a3, int *a4)
{
  __int128 v15 = 0LL;
  *a2 = 0LL;
  *a3 = 0;
  int v7 = sub_1C2EC(&v15);
  if (v15)
  {
    int v8 = sub_506B8(v15, a3);
    *a2 = v8;
    if (!v8)
    {
      uint64_t v9 = sub_57538();
      int v7 = 5;
      uint64_t v10 = _SC_syslog_os_log_mapping(5LL);
      if (__SC_log_enabled(5LL, v9, v10))
      {
        uint64_t v11 = _os_log_pack_size(2LL);
        uint64_t v12 = (char *)&v15 - ((__chkstk_darwin(v11) + 15) & 0xFFFFFFFFFFFFFFF0LL);
        __int128 v13 = __error();
        *(_WORD *)_os_log_pack_fill(v12, v11, *v13, &dword_0, "failed to serialize data") = 0;
        int v7 = 5;
        __SC_log_send(5LL, v9, v10, v12);
      }
    }
  }

  sub_4FA18((const void **)&v15);
  *a4 = v7;
  return 0LL;
}

uint64_t sub_2DF44(uint64_t a1, vm_address_t *a2, _DWORD *a3, _DWORD *a4)
{
  *a4 = sub_1C3B4(a2, a3);
  return 0LL;
}

uint64_t sub_2DF74(uint64_t a1, char *a2, _DWORD *a3, _DWORD *a4)
{
  a2[15] = 0;
  *a4 = sub_1C420(a2, a3);
  return 0LL;
}

void sub_2DFA8()
{
  kern_return_t v0;
  mach_error_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  char *v5;
  int *v6;
  uint64_t v7;
  char *v8;
  uintptr_t v9;
  dispatch_queue_s *v10;
  dispatch_source_s *v11;
  const char *v12;
  void handler[5];
  mach_port_t sp;
  uint64_t v0 = bootstrap_check_in(bootstrap_port, "com.apple.network.IPConfiguration", &sp);
  if (v0)
  {
    uint64_t v1 = v0;
    __int128 v2 = sub_57538();
    __int128 v3 = _SC_syslog_os_log_mapping(5LL);
    if (__SC_log_enabled(5LL, v2, v3))
    {
      uint64_t v4 = _os_log_pack_size(12LL);
      CFIndex v5 = (char *)&handler[-1] - ((__chkstk_darwin(v4) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v6 = __error();
      int v7 = _os_log_pack_fill(v5, v4, *v6, &dword_0, "IPConfiguration: bootstrap_check_in failed, %s", v12);
      int v8 = mach_error_string(v1);
      *(_DWORD *)int v7 = 136315138;
      *(void *)(v7 + 4) = v8;
      __SC_log_send(5LL, v2, v3, v5);
    }
  }

  else
  {
    uint64_t v9 = sp;
    uint64_t v10 = sub_2A814();
    uint64_t v11 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_mach_recv, v9, 0LL, v10);
    handler[0] = _NSConcreteStackBlock;
    handler[1] = 0x40000000LL;
    handler[2] = sub_2E144;
    handler[3] = &unk_64EF8;
    handler[4] = v11;
    dispatch_source_set_event_handler(v11, handler);
    dispatch_activate(v11);
  }

uint64_t sub_2E144(uint64_t a1)
{
  uint64_t result = dispatch_mig_server(*(void *)(a1 + 32), 176LL, sub_4F660);
  if ((_DWORD)result)
  {
    int v2 = result;
    uint64_t v3 = sub_57538();
    uint64_t v4 = _SC_syslog_os_log_mapping(5LL);
    uint64_t result = __SC_log_enabled(5LL, v3, v4);
    if ((_DWORD)result)
    {
      uint64_t v5 = _os_log_pack_size(18LL);
      uint64_t v6 = (char *)&v9 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0LL);
      int v7 = __error();
      uint64_t v8 = _os_log_pack_fill(v6, v5, *v7, &dword_0, "%s: failed %d", v9, v10);
      *(_DWORD *)uint64_t v8 = 136315394;
      *(void *)(v8 + 4) = "server_init_block_invoke";
      *(_WORD *)(v8 + 12) = 1024;
      *(_DWORD *)(v8 + 14) = v2;
      return __SC_log_send(5LL, v3, v4, v6);
    }
  }

  return result;
}

char *timer_callout_init(const char *a1)
{
  int v2 = (char *)malloc(0x40uLL);
  uint64_t v3 = v2;
  if (v2)
  {
    *((void *)v2 + 7) = 0LL;
    *(_OWORD *)(v2 + 40) = 0u;
    *(_OWORD *)(v2 + 24) = 0u;
    *(_OWORD *)(v2 + 8) = 0u;
    *(void *)int v2 = strdup(a1);
    sub_2E2C8();
    *((_DWORD *)v3 + 12) = dword_6C230;
  }

  return v3;
}

void sub_2E2C8()
{
  if ((byte_6C234 & 1) == 0)
  {
    uint32_t v0 = notify_register_check("com.apple.system.clock_set", &dword_6C238);
    if (v0)
    {
      uint32_t v1 = v0;
      uint64_t v2 = sub_57538();
      uint64_t v3 = _SC_syslog_os_log_mapping(5LL);
      if (__SC_log_enabled(5LL, v2, v3))
      {
        uint64_t v4 = _os_log_pack_size(18LL);
        uint64_t v5 = (char *)&v8 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0LL);
        uint64_t v6 = __error();
        uint64_t v7 = _os_log_pack_fill( v5,  v4,  *v6,  &dword_0,  "timer: notify_register_check(%s) failed, %d",  v8,  v9);
        *(_DWORD *)uint64_t v7 = 136315394;
        *(void *)(v7 + 4) = "com.apple.system.clock_set";
        *(_WORD *)(v7 + 12) = 1024;
        *(_DWORD *)(v7 + 14) = v1;
        __SC_log_send(5LL, v2, v3, v5);
      }
    }

    else
    {
      byte_6C234 = 1;
      sub_2E940();
    }
  }

void timer_callout_free(uint64_t *a1)
{
  uint64_t v1 = *a1;
  if (*a1)
  {
    uint64_t v3 = *(dispatch_source_s **)(v1 + 40);
    if (v3)
    {
      dispatch_source_cancel(v3);
      if (*(_DWORD *)(v1 + 56))
      {
        dispatch_resume(*(dispatch_object_t *)(v1 + 40));
        *(_DWORD *)(v1 + 56) = 0;
      }

      dispatch_release(*(dispatch_object_t *)(v1 + 40));
      *(void *)(v1 + 40) = 0LL;
    }

    free(*(void **)v1);
    free((void *)v1);
    *a1 = 0LL;
  }

uint64_t timer_callout_set_absolute(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, double a6)
{
  double v11 = a6 - CFAbsoluteTimeGetCurrent();
  return timer_callout_set_0(a1, a2, a3, a4, a5, v11);
}

uint64_t timer_callout_set_0(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, double a6)
{
  if (result)
  {
    uint64_t v11 = result;
    sub_2E8BC(result);
    if (a2)
    {
      *(void *)(v11 + 8) = a2;
      *(void *)(v11 + 16) = a3;
      *(void *)(v11 + 24) = a4;
      *(void *)(v11 + 32) = a5;
      *(_DWORD *)(v11 + 48) = dword_6C230;
      *(_DWORD *)(v11 + 52) = 1;
      uint64_t v12 = *(dispatch_source_s **)(v11 + 40);
      if (v12)
      {
        dispatch_time_t v13 = dispatch_time(0LL, (unint64_t)(a6 * 1000000000.0));
        dispatch_source_set_timer(v12, v13, 0xFFFFFFFFFFFFFFFFLL, 0LL);
        if (*(_DWORD *)(v11 + 56))
        {
          dispatch_resume(*(dispatch_object_t *)(v11 + 40));
          *(_DWORD *)(v11 + 56) = 0;
        }
      }

      else
      {
        int v14 = sub_2A814();
        __int128 v15 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_timer, 0LL, 0LL, v14);
        *(void *)(v11 + 40) = v15;
        handler = _NSConcreteStackBlock;
        uint64_t v26 = 0x40000000LL;
        uint64_t v27 = sub_2EA94;
        uint64_t v28 = &unk_64F18;
        uint64_t v29 = v11;
        dispatch_source_set_event_handler(v15, &handler);
        CFTypeID v16 = *(dispatch_source_s **)(v11 + 40);
        dispatch_time_t v17 = dispatch_time(0LL, (unint64_t)(a6 * 1000000000.0));
        dispatch_source_set_timer(v16, v17, 0xFFFFFFFFFFFFFFFFLL, 0LL);
        dispatch_activate(*(dispatch_object_t *)(v11 + 40));
      }

      uint64_t v18 = sub_57538();
      uint64_t v19 = _SC_syslog_os_log_mapping(7LL);
      if (__SC_log_enabled(7LL, v18, v19))
      {
        uint64_t v20 = _os_log_pack_size(22LL);
        uint64_t v21 = (char *)&handler - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0LL);
        CFDateRef v22 = __error();
        uint64_t v23 = _os_log_pack_fill( v21,  v20,  *v22,  &dword_0,  "timer(%s): %0.09gs",  (const char *)handler,  *(double *)&v26);
        uint64_t v24 = *(void *)v11;
        *(_DWORD *)uint64_t v23 = 136315394;
        *(void *)(v23 + 4) = v24;
        *(_WORD *)(v23 + 12) = 2048;
        *(double *)(v23 + 14) = a6;
        __SC_log_send(7LL, v18, v19, v21);
      }

      return 1LL;
    }

    else
    {
      return 0LL;
    }
  }

  return result;
}

uint64_t timer_set_relative(uint64_t a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  double v7 = (double)a3 / 1000000.0;
  if (a2 < 0) {
    double v7 = 0.000001;
  }
  return timer_callout_set_0(a1, a4, a5, a6, a7, v7 + (double)(a2 & ~(a2 >> 63)));
}

void timer_cancel(uint64_t a1)
{
  if (a1)
  {
    if (*(_DWORD *)(a1 + 52))
    {
      uint64_t v2 = sub_57538();
      uint64_t v3 = _SC_syslog_os_log_mapping(7LL);
      if (__SC_log_enabled(7LL, v2, v3))
      {
        uint64_t v4 = _os_log_pack_size(12LL);
        uint64_t v5 = (char *)&v9 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0LL);
        uint64_t v6 = __error();
        uint64_t v7 = _os_log_pack_fill(v5, v4, *v6, &dword_0, "timer(%s): cancelled", v9);
        uint64_t v8 = *(void *)a1;
        *(_DWORD *)uint64_t v7 = 136315138;
        *(void *)(v7 + 4) = v8;
        __SC_log_send(7LL, v2, v3, v5);
      }
    }

    sub_2E8BC(a1);
  }

void sub_2E8BC(uint64_t a1)
{
  *(void *)(a1 + 8) = 0LL;
  *(_DWORD *)(a1 + 48) = dword_6C230;
  uint64_t v2 = *(dispatch_object_s **)(a1 + 40);
  if (v2 && !*(_DWORD *)(a1 + 56))
  {
    dispatch_suspend(v2);
    *(_DWORD *)(a1 + 56) = 1;
  }

  *(_DWORD *)(a1 + 52) = 0;
}

BOOL timer_time_changed(uint64_t a1)
{
  return *(_DWORD *)(a1 + 48) != dword_6C230;
}

void sub_2E940()
{
  int check = 0;
  if (byte_6C234 == 1)
  {
    uint32_t v0 = notify_check(dword_6C238, &check);
    if (v0)
    {
      uint32_t v1 = v0;
      uint64_t v2 = sub_57538();
      uint64_t v3 = _SC_syslog_os_log_mapping(5LL);
      if (__SC_log_enabled(5LL, v2, v3))
      {
        uint64_t v4 = _os_log_pack_size(8LL);
        uint64_t v5 = (char *)&v8 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0LL);
        uint64_t v6 = __error();
        uint64_t v7 = (_DWORD *)_os_log_pack_fill(v5, v4, *v6, &dword_0, "timer: notify_check failed with %d", v8);
        _DWORD *v7 = 67109120;
        v7[1] = v1;
        __SC_log_send(5LL, v2, v3, v5);
      }
    }

    else if (check)
    {
      ++dword_6C230;
    }
  }

uint64_t timer_still_pending(uint64_t a1)
{
  return *(unsigned int *)(a1 + 52);
}

uint64_t sub_2EA94(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 32);
  uint64_t v2 = *(uint64_t (**)(void, void, void))(v1 + 8);
  if (v2)
  {
    if (*(_DWORD *)(v1 + 52))
    {
      *(_DWORD *)(v1 + 52) = 0;
      return v2(*(void *)(v1 + 16), *(void *)(v1 + 24), *(void *)(v1 + 32));
    }
  }

  return result;
}

uint64_t failover_thread(uint64_t a1, int a2, unsigned __int8 *a3)
{
  uint64_t v6 = sub_14834(a1);
  uint64_t v7 = sub_194C4(a1);
  uint64_t v8 = 0LL;
  uint64_t v9 = (unsigned int *)v7;
  switch(a2)
  {
    case 0:
      if (v7)
      {
        uint64_t v14 = sub_57538();
        uint64_t v8 = 6LL;
        uint64_t v15 = _SC_syslog_os_log_mapping(6LL);
        if (__SC_log_enabled(6LL, v14, v15))
        {
          uint64_t v16 = _os_log_pack_size(12LL);
          dispatch_time_t v17 = &__str[-((__chkstk_darwin(v16) + 15) & 0xFFFFFFFFFFFFFFF0LL) - 8];
          uint64_t v18 = *__error();
          uint64_t v19 = _os_log_pack_fill(v17, v16, v18, &dword_0, "FAILOVER %s: re-entering start state");
          goto LABEL_28;
        }
      }

      else
      {
        if ((sub_54A84(v6) & 8) == 0)
        {
          uint64_t v9 = (unsigned int *)malloc(0x20uLL);
          sub_194CC(a1, (uint64_t)v9);
          *(_OWORD *)uint64_t v9 = 0u;
          *((_OWORD *)v9 + 1) = 0u;
          sub_193C8(a1, *(_DWORD *)a3);
          sub_193F0(a1, *((_DWORD *)a3 + 1));
          unsigned int v33 = timer_callout_init("failover");
          *((void *)v9 + 1) = v33;
          if (v33)
          {
            unsigned int v34 = sub_33B4(v6);
            *(void *)uint64_t v9 = v34;
            if (v34)
            {
              v9[4] = *((_DWORD *)a3 + 5);
              uint64_t v35 = sub_57538();
              uint64_t v36 = _SC_syslog_os_log_mapping(6LL);
              if (__SC_log_enabled(6LL, v35, v36))
              {
                uint64_t v37 = _os_log_pack_size(12LL);
                uint64_t v38 = &__str[-((__chkstk_darwin(v37) + 15) & 0xFFFFFFFFFFFFFFF0LL) - 8];
                uint64_t v39 = __error();
                uint64_t v40 = _os_log_pack_fill(v38, v37, *v39, &dword_0, "FAILOVER %s: starting", v64);
                uint64_t v41 = nullsub_1(v6);
                *(_DWORD *)uint64_t v40 = 136315138;
                *(void *)(v40 + 4) = v41;
                __SC_log_send(6LL, v35, v36, v38);
              }

              goto LABEL_22;
            }

            uint64_t v49 = sub_57538();
            uint64_t v50 = _SC_syslog_os_log_mapping(5LL);
            if (__SC_log_enabled(5LL, v49, v50))
            {
              uint64_t v51 = _os_log_pack_size(12LL);
              uint64_t v52 = &__str[-((__chkstk_darwin(v51) + 15) & 0xFFFFFFFFFFFFFFF0LL) - 8];
              uint64_t v53 = __error();
              uint64_t v54 = _os_log_pack_fill( v52,  v51,  *v53,  &dword_0,  "FAILOVER %s: arp_client_init failed",  v64);
              uint64_t v55 = nullsub_1(v6);
              *(_DWORD *)uint64_t v54 = 136315138;
              *(void *)(v54 + 4) = v55;
              __SC_log_send(5LL, v49, v50, v52);
            }

            uint64_t v8 = 0LL;
          }

          else
          {
            uint64_t v42 = sub_57538();
            uint64_t v8 = 5LL;
            uint64_t v43 = _SC_syslog_os_log_mapping(5LL);
            if (__SC_log_enabled(5LL, v42, v43))
            {
              uint64_t v44 = _os_log_pack_size(12LL);
              uint64_t v45 = &__str[-((__chkstk_darwin(v44) + 15) & 0xFFFFFFFFFFFFFFF0LL) - 8];
              uint64_t v46 = __error();
              uint64_t v47 = _os_log_pack_fill( v45,  v44,  *v46,  &dword_0,  "FAILOVER %s: timer_callout_init failed",  v64);
              uint64_t v48 = nullsub_1(v6);
              *(_DWORD *)uint64_t v47 = 136315138;
              *(void *)(v47 + 4) = v48;
              uint64_t v8 = 5LL;
              __SC_log_send(5LL, v42, v43, v45);
            }
          }

          goto LABEL_40;
        }

        return 3LL;
      }

      return v8;
    case 1:
LABEL_40:
      uint64_t v56 = sub_57538();
      uint64_t v57 = _SC_syslog_os_log_mapping(6LL);
      if (__SC_log_enabled(6LL, v56, v57))
      {
        uint64_t v58 = _os_log_pack_size(12LL);
        int v59 = &__str[-((__chkstk_darwin(v58) + 15) & 0xFFFFFFFFFFFFFFF0LL) - 8];
        uint64_t v60 = __error();
        uint64_t v61 = _os_log_pack_fill(v59, v58, *v60, &dword_0, "FAILOVER %s: stop", v64);
        uint64_t v62 = nullsub_1(v6);
        *(_DWORD *)uint64_t v61 = 136315138;
        *(void *)(v61 + 4) = v62;
        __SC_log_send(6LL, v56, v57, v59);
      }

      if (v9)
      {
        sub_18A00(a1);
        if (*(void *)v9) {
          sub_3524((uint64_t **)v9);
        }
        if (*((void *)v9 + 1)) {
          timer_callout_free((uint64_t *)v9 + 1);
        }
        free(v9);
        sub_194CC(a1, 0LL);
      }

      return v8;
    case 3:
    case 11:
      if (!v7) {
        return 6LL;
      }
      if (!*((_DWORD *)a3 + 1) || *((_DWORD *)a3 + 2)) {
        goto LABEL_22;
      }
      *(_BYTE *)(v7 + 20) = 0;
      sub_299C8(a1);
      return 0LL;
    case 4:
      sub_2F854(a1);
      return 0LL;
    case 7:
      if (!v7)
      {
        uint64_t v14 = sub_57538();
        uint64_t v8 = 6LL;
        uint64_t v15 = _SC_syslog_os_log_mapping(6LL);
        if (__SC_log_enabled(6LL, v14, v15))
        {
          uint64_t v29 = _os_log_pack_size(12LL);
          dispatch_time_t v17 = &__str[-((__chkstk_darwin(v29) + 15) & 0xFFFFFFFFFFFFFFF0LL) - 8];
          uint64_t v30 = *__error();
          uint64_t v19 = _os_log_pack_fill(v17, v29, v30, &dword_0, "FAILOVER %s: private data is NULL");
LABEL_28:
          uint64_t v31 = v19;
          uint64_t v32 = nullsub_1(v6);
          *(_DWORD *)uint64_t v31 = 136315138;
          *(void *)(v31 + 4) = v32;
          uint64_t v8 = 6LL;
          __SC_log_send(6LL, v14, v15, v17);
        }

        return v8;
      }

      uint64_t v10 = *(int **)a3;
      *((_DWORD *)a3 + 2) = 0;
      int v11 = *v10;
      if (v11 != sub_193D8(a1) || (int v12 = v10[1], v12 != sub_19400(a1)))
      {
        uint64_t v8 = 0LL;
        *((_DWORD *)a3 + 2) = 1;
        return v8;
      }

      v9[4] = v10[5];
      if (sub_193A4(a1) && *((_BYTE *)v9 + 20))
      {
        uint64_t v13 = v9[4];
        if ((_DWORD)v13) {
          timer_set_relative(*((void *)v9 + 1), v13, 0, (uint64_t)sub_2F720, a1, 0LL, 0LL);
        }
        else {
          timer_cancel(*((void *)v9 + 1));
        }
        return 0LL;
      }

      goto LABEL_22;
    case 9:
      if (!v7) {
        return 6LL;
      }
      int v20 = *(_DWORD *)a3;
      if (v20 == sub_193D8(a1))
      {
        uint64_t v21 = (unsigned __int8 *)*((void *)a3 + 1);
        snprintf( __str,  0x80uLL,  "%d.%d.%d.%d in use by %02x:%02x:%02x:%02x:%02x:%02x",  *a3,  a3[1],  a3[2],  a3[3],  *v21,  v21[1],  v21[2],  v21[3],  v21[4],  v21[5]);
        uint64_t v22 = sub_57538();
        uint64_t v23 = _SC_syslog_os_log_mapping(5LL);
        if (__SC_log_enabled(5LL, v22, v23))
        {
          uint64_t v24 = _os_log_pack_size(22LL);
          uint64_t v25 = &__str[-((__chkstk_darwin(v24) + 15) & 0xFFFFFFFFFFFFFFF0LL) - 8];
          uint64_t v26 = __error();
          uint64_t v27 = _os_log_pack_fill(v25, v24, *v26, &dword_0, "FAILOVER %s: %s", v64, *(const char **)__str);
          uint64_t v28 = nullsub_1(v6);
          *(_DWORD *)uint64_t v27 = 136315394;
          *(void *)(v27 + 4) = v28;
          *(_WORD *)(v27 + 12) = 2080;
          *(void *)(v27 + 14) = __str;
          __SC_log_send(5LL, v22, v23, v25);
        }

        sub_18A00(a1);
        sub_17FEC(a1, 8u);
LABEL_22:
        sub_2F288(a1, 0, 0LL);
      }

      return 0LL;
    default:
      return v8;
  }

void sub_2F288(uint64_t a1, int a2, uint64_t a3)
{
  uint64_t v6 = sub_14834(a1);
  uint64_t v7 = sub_194C4(a1);
  uint64_t v8 = v7;
  switch(a2)
  {
    case 6:
      if (*(_DWORD *)(a3 + 8))
      {
        uint64_t v19 = sub_57538();
        uint64_t v20 = _SC_syslog_os_log_mapping(5LL);
        if (__SC_log_enabled(5LL, v19, v20))
        {
          uint64_t v21 = _os_log_pack_size(22LL);
          uint64_t v22 = &__str[-((__chkstk_darwin(v21) + 15) & 0xFFFFFFFFFFFFFFF0LL) - 8];
          uint64_t v23 = __error();
          uint64_t v24 = _os_log_pack_fill( v22,  v21,  *v23,  &dword_0,  "FAILOVER %s: arp probe failed, %s",  v37,  *(const char **)__str);
          uint64_t v25 = nullsub_1(v6);
          uint64_t v26 = sub_4AE0(*(void *)v8);
          *(_DWORD *)uint64_t v24 = 136315394;
          *(void *)(v24 + 4) = v25;
          *(_WORD *)(v24 + 12) = 2080;
          *(void *)(v24 + 14) = v26;
          __SC_log_send(5LL, v19, v20, v22);
        }
      }

      else if (*(_DWORD *)(a3 + 12))
      {
        unsigned int v27 = sub_193D8(a1);
        snprintf( __str,  0x80uLL,  "%d.%d.%d.%d in use by %02x:%02x:%02x:%02x:%02x:%02x",  v27,  BYTE1(v27),  BYTE2(v27),  HIBYTE(v27),  *(unsigned __int8 *)(a3 + 24),  *(unsigned __int8 *)(a3 + 25),  *(unsigned __int8 *)(a3 + 26),  *(unsigned __int8 *)(a3 + 27),  *(unsigned __int8 *)(a3 + 28),  *(unsigned __int8 *)(a3 + 29));
        uint64_t v28 = sub_57538();
        uint64_t v29 = _SC_syslog_os_log_mapping(5LL);
        if (__SC_log_enabled(5LL, v28, v29))
        {
          uint64_t v30 = _os_log_pack_size(22LL);
          uint64_t v31 = &__str[-((__chkstk_darwin(v30) + 15) & 0xFFFFFFFFFFFFFFF0LL) - 8];
          uint64_t v32 = __error();
          uint64_t v33 = _os_log_pack_fill(v31, v30, *v32, &dword_0, "FAILOVER %s: %s", v37, *(const char **)__str);
          uint64_t v34 = nullsub_1(v6);
          *(_DWORD *)uint64_t v33 = 136315394;
          *(void *)(v33 + 4) = v34;
          *(_WORD *)(v33 + 12) = 2080;
          *(void *)(v33 + 14) = __str;
          __SC_log_send(5LL, v28, v29, v31);
        }

        sub_18A00(a1);
        sub_17FEC(a1, 8u);
        timer_set_relative(*(void *)(v8 + 8), 10LL, 0, (uint64_t)sub_2F288, a1, 0LL, 0LL);
      }

      else if (sub_19384(a1) == 1)
      {
        sub_2F854(a1);
      }

      else
      {
        unsigned int v35 = sub_193D8(a1);
        unsigned int v36 = sub_19400(a1);
        sub_18378(a1, v35, v36, 0LL);
        sub_154F8(a1, 0LL);
        *(_BYTE *)(v8 + 20) = 1;
        uint64_t v14 = *(unsigned int *)(v8 + 16);
        if ((_DWORD)v14)
        {
          uint64_t v11 = *(void *)(v8 + 8);
          uint64_t v13 = sub_2F720;
          int v12 = 0;
          uint64_t v15 = a1;
          uint64_t v16 = 0LL;
          goto LABEL_5;
        }
      }

      break;
    case 2:
      uint64_t v17 = *(void *)v7;
      int v18 = sub_193D8(a1);
      sub_45A8(v17, (uint64_t)sub_2F288, a1, 6LL, 0, v18);
      break;
    case 0:
      *(_BYTE *)(v7 + 20) = 0;
      sub_299C8(a1);
      uint64_t v9 = sub_558D0(0LL, 4LL);
      int v10 = sub_558D0(0LL, 999999LL);
      uint64_t v11 = *(void *)(v8 + 8);
      int v12 = v10;
      uint64_t v13 = (uint64_t (*)(uint64_t))sub_2F288;
      uint64_t v14 = v9;
      uint64_t v15 = a1;
      uint64_t v16 = 2LL;
LABEL_5:
      timer_set_relative(v11, v14, v12, (uint64_t)v13, v15, v16, 0LL);
      break;
  }

uint64_t sub_2F720(uint64_t a1)
{
  uint64_t v2 = sub_57538();
  uint64_t v3 = _SC_syslog_os_log_mapping(6LL);
  if (__SC_log_enabled(6LL, v2, v3))
  {
    uint64_t v4 = _os_log_pack_size(12LL);
    uint64_t v5 = (char *)&v11 - ((__chkstk_darwin(v4) + 15) & 0xFFFFFFFFFFFFFFF0LL);
    uint64_t v6 = __error();
    uint64_t v7 = _os_log_pack_fill(v5, v4, *v6, &dword_0, "FAILOVER %s: address timer fired", v11);
    uint64_t v8 = sub_14834(a1);
    uint64_t v9 = nullsub_1(v8);
    *(_DWORD *)uint64_t v7 = 136315138;
    *(void *)(v7 + 4) = v9;
    __SC_log_send(6LL, v2, v3, v5);
  }

  sub_299C8(a1);
  sub_18A00(a1);
  return sub_17FEC(a1, 0x10u);
}

uint64_t sub_2F854(uint64_t a1)
{
  return sub_17FEC(a1, 0xCu);
}

uint64_t DHCPLeaseSetNAK(uint64_t result, int a2)
{
  *(_BYTE *)(result + 1) = a2 != 0;
  return result;
}

void *DHCPLeaseListInit(void *a1)
{
  return sub_53D14(a1, (uint64_t)sub_2F8A4, 0LL);
}

void sub_2F8A4(const void **a1)
{
}

void DHCPLeaseListRead(uint64_t *a1, const char *a2, int a3, int a4, const void *a5, int a6)
{
  CFPropertyListRef v12 = sub_4FA48(__str);
  uint64_t v38 = v12;
  CFTypeID TypeID = CFDictionaryGetTypeID();
  if (v12)
  {
    if (CFGetTypeID(v12) == TypeID)
    {
      int Value = (const __CFData *)CFDictionaryGetValue((CFDictionaryRef)v12, @"ClientIdentifier");
      if (a6)
      {
        uint64_t v15 = Value;
        CFTypeID v16 = CFDataGetTypeID();
        if (v15)
        {
          if (CFGetTypeID(v15) == v16 && CFDataGetLength(v15) == a6 + 1)
          {
            BytePtr = CFDataGetBytePtr(v15);
            if (*BytePtr == a4)
            {
              int v18 = BytePtr + 1;
              int v19 = bcmp(BytePtr + 1, a5, a6);
              if (!v19 || a4 == 1 && a6 == 6 && (*v18 & 2) != 0 && a3)
              {
                uint64_t v20 = (const __CFDate *)CFDictionaryGetValue((CFDictionaryRef)v12, @"LeaseStartDate");
                CFTypeID v21 = CFDateGetTypeID();
                if (v20)
                {
                  if (CFGetTypeID(v20) == v21)
                  {
                    uint64_t v22 = (const __CFData *)CFDictionaryGetValue((CFDictionaryRef)v12, @"PacketData");
                    CFTypeID v23 = CFDataGetTypeID();
                    if (v22)
                    {
                      if (CFGetTypeID(v22) == v23)
                      {
                        if (a3)
                        {
                          uint64_t v24 = CFDictionaryGetValue((CFDictionaryRef)v12, @"SSID");
                          CFTypeID v25 = CFStringGetTypeID();
                          if (!v24) {
                            goto LABEL_43;
                          }
                          if (CFGetTypeID(v24) != v25) {
                            goto LABEL_43;
                          }
                          uint64_t v26 = CFDictionaryGetValue((CFDictionaryRef)v12, @"NetworkID");
                          if (v26)
                          {
                            CFTypeID v27 = CFStringGetTypeID();
                            if (CFGetTypeID(v26) != v27) {
                              goto LABEL_43;
                            }
                          }
                        }

                        else
                        {
                          uint64_t v24 = 0LL;
                          uint64_t v26 = 0LL;
                        }

                        unint64_t Length = CFDataGetLength(v22);
                        if (Length >= 0xEC)
                        {
                          CFIndex v29 = Length;
                          CFTypeRef v37 = v26;
                          uint64_t v30 = malloc(Length + 68);
                          *(_OWORD *)uint64_t v30 = 0u;
                          *((_OWORD *)v30 + 1) = 0u;
                          *((_OWORD *)v30 + 2) = 0u;
                          *((_OWORD *)v30 + 3) = 0u;
                          *((_DWORD *)v30 + 16) = 0;
                          v44.location = 0LL;
                          v44.length = v29;
                          CFDataGetBytes(v22, v44, (UInt8 *)v30 + 68);
                          *((_DWORD *)v30 + 16) = v29;
                          *((CFAbsoluteTime *)v30 + 1) = CFDateGetAbsoluteTime(v20);
                          sub_50F80(v41, (uint64_t)v30 + 68, v29, 0LL);
                          dhcp_get_lease_from_options((uint64_t)v41, &v42, &v40, &v39);
                          *((_DWORD *)v30 + 4) = v42;
                          int v31 = *((_DWORD *)v30 + 21);
                          *((_DWORD *)v30 + 1) = v31;
                          if (sub_F5BC((uint64_t)v41, v31, (_DWORD *)v30 + 5))
                          {
                            uint64_t v32 = (const __CFData *)CFDictionaryGetValue( (CFDictionaryRef)v12,  @"RouterHardwareAddress");
                            CFTypeID v33 = CFDataGetTypeID();
                            if (v32)
                            {
                              if (CFGetTypeID(v32) == v33)
                              {
                                uint64_t v34 = CFDataGetLength(v32);
                                if (v34 >= 1)
                                {
                                  else {
                                    v35.length = v34;
                                  }
                                  *((_BYTE *)v30 + 40) = v35.length;
                                  v35.location = 0LL;
                                  CFDataGetBytes(v32, v35, (UInt8 *)v30 + 24);
                                }
                              }
                            }
                          }

                          sub_50CA0((uint64_t)v41);
                          if (v24)
                          {
                            CFRetain(v24);
                            *((void *)v30 + 6) = v24;
                          }

                          if (v37)
                          {
                            CFRetain(v37);
                            *((void *)v30 + 7) = v37;
                          }

                          if (v19)
                          {
                            v45.location = 1LL;
                            v45.length = 6LL;
                            CFDataGetBytes(v15, v45, (UInt8 *)v30 + 41);
                            *((_BYTE *)v30 + 47) = 1;
                          }

                          *(_BYTE *)uint64_t v30 = 1;
                          sub_53DA4(a1, v30);
                          if (G_IPConfiguration_verbose) {
                            sub_2FCC0((uint64_t)a1);
                          }
                          int v36 = *((_DWORD *)v30 + 1);
                          sub_2FF9C(a1);
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }

void sub_2FCC0(uint64_t a1)
{
  CFMutableDictionaryRef Mutable = CFStringCreateMutable(0LL, 0LL);
  int v3 = sub_50C94(a1);
  if (v3 >= 1)
  {
    uint64_t v4 = 0LL;
    do
    {
      uint64_t v5 = sub_50C98(a1, v4);
      uint64_t v4 = (v4 + 1);
      CFStringAppendFormat(Mutable, 0LL, @"\n%d. ", v4);
      CFStringAppendFormat( Mutable,  0LL,  @"IP %d.%d.%d.%d Start %d Length",  *(unsigned __int8 *)(v5 + 4),  *(unsigned __int8 *)(v5 + 5),  *(unsigned __int8 *)(v5 + 6),  *(unsigned __int8 *)(v5 + 7),  (int)*(double *)(v5 + 8));
      if (*(_DWORD *)(v5 + 16) == -1) {
        CFStringAppendFormat(Mutable, 0LL, @" infinite");
      }
      else {
        CFStringAppendFormat(Mutable, 0LL, @" %d", *(unsigned int *)(v5 + 16));
      }
      if (*(_DWORD *)(v5 + 20))
      {
        CFStringAppendFormat( Mutable,  0LL,  @" Router IP %d.%d.%d.%d",  *(_DWORD *)(v5 + 20),  BYTE1(*(_DWORD *)(v5 + 20)),  BYTE2(*(_DWORD *)(v5 + 20)),  HIBYTE(*(_DWORD *)(v5 + 20)));
        if (*(_BYTE *)(v5 + 40))
        {
          sub_55C30(__str, 48, (unsigned __int8 *)(v5 + 24), *(unsigned __int8 *)(v5 + 40));
          CFStringAppendFormat(Mutable, 0LL, @" MAC %s", __str);
        }
      }

      if (*(void *)(v5 + 48))
      {
        CFStringAppendFormat(Mutable, 0LL, @" SSID '%@'", *(void *)(v5 + 48));
        if (*(void *)(v5 + 56)) {
          CFStringAppendFormat(Mutable, 0LL, @" NetworkID '%@'", *(void *)(v5 + 56));
        }
      }
    }

    while (v3 != (_DWORD)v4);
  }

  uint64_t v6 = sub_57538();
  uint64_t v7 = _SC_syslog_os_log_mapping(4294967288LL);
  if (__SC_log_enabled(4294967288LL, v6, v7))
  {
    uint64_t v8 = _os_log_pack_size(18LL);
    uint64_t v9 = &__str[-((__chkstk_darwin(v8) + 15) & 0xFFFFFFFFFFFFFFF0LL) - 8];
    int v10 = __error();
    uint64_t v11 = _os_log_pack_fill(v9, v8, *v10, &dword_0, "DHCPLeaseList has %d element(s)%@");
    *(_DWORD *)uint64_t v11 = 67109378;
    *(_DWORD *)(v11 + 4) = v3;
    *(_WORD *)(v11 + 8) = 2112;
    *(void *)(v11 + 10) = Mutable;
    __SC_log_send(4294967288LL, v6, v7, v9);
  }

  CFRelease(Mutable);
}

void sub_2FF9C(uint64_t *a1)
{
  int v2 = sub_50C94(a1);
  if (v2)
  {
    int v3 = v2;
    *(double *)&__int128 v4 = timer_get_current_time();
    if (v3 >= 1)
    {
      double v5 = *(double *)&v4;
      uint64_t v6 = 0LL;
      *(void *)&__int128 v4 = 67110912LL;
      __int128 v24 = v4;
      do
      {
        uint64_t v7 = sub_50C98(a1, v6);
        unsigned int v8 = *(_DWORD *)(v7 + 16);
        if (v8 == -1 || (uint64_t v9 = (unsigned __int8 *)v7, v5 < *(double *)(v7 + 8) + (double)v8))
        {
          uint64_t v6 = (v6 + 1);
        }

        else
        {
          uint64_t v10 = sub_57538();
          uint64_t v11 = _SC_syslog_os_log_mapping(6LL);
          if (__SC_log_enabled(6LL, v10, v11))
          {
            uint64_t v12 = _os_log_pack_size(50LL);
            uint64_t v13 = (char *)&v24 - ((__chkstk_darwin(v12) + 15) & 0xFFFFFFFFFFFFFFF0LL);
            uint64_t v14 = __error();
            uint64_t v15 = _os_log_pack_fill( v13,  v12,  *v14,  &dword_0,  "Removing Stale Lease %d.%d.%d.%d Router %d.%d.%d.%d",  (_DWORD)v24,  DWORD2(v24),  v25,  v26,  v27,  v28,  v29,  v30);
            int v16 = v9[4];
            int v17 = v9[5];
            int v18 = v9[6];
            int v19 = v9[7];
            int v20 = v9[20];
            int v21 = v9[21];
            int v22 = v9[22];
            int v23 = v9[23];
            *(_DWORD *)uint64_t v15 = v24;
            *(_DWORD *)(v15 + 4) = v16;
            *(_WORD *)(v15 + 8) = 1024;
            *(_DWORD *)(v15 + 10) = v17;
            *(_WORD *)(v15 + 14) = 1024;
            *(_DWORD *)(v15 + 16) = v18;
            *(_WORD *)(v15 + 20) = 1024;
            *(_DWORD *)(v15 + 22) = v19;
            *(_WORD *)(v15 + 26) = 1024;
            *(_DWORD *)(v15 + 28) = v20;
            *(_WORD *)(v15 + 32) = 1024;
            *(_DWORD *)(v15 + 34) = v21;
            *(_WORD *)(v15 + 38) = 1024;
            *(_DWORD *)(v15 + 40) = v22;
            *(_WORD *)(v15 + 44) = 1024;
            *(_DWORD *)(v15 + 46) = v23;
            __SC_log_send(6LL, v10, v11, v13);
          }

          sub_53DAC(a1, v6);
          --v3;
        }
      }

      while ((int)v6 < v3);
    }
  }

void DHCPLeaseListWrite(uint64_t *a1, const char *a2, char a3, const UInt8 *a4, int a5)
{
  int v9 = sub_50C94(a1);
  if (v9)
  {
    uint64_t v10 = sub_50C98(a1, (v9 - 1));
    CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(0LL, 0LL, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    LOBYTE(v29) = a3;
    uint64_t v12 = CFDataCreateMutable(0LL, a5 + 1);
    CFDataAppendBytes(v12, (const UInt8 *)&v29, 1LL);
    CFDataAppendBytes(v12, a4, a5);
    CFDictionarySetValue(Mutable, @"ClientIdentifier", v12);
    CFRelease(v12);
    CFStringRef v13 = CFStringCreateWithFormat( 0LL,  0LL,  @"%d.%d.%d.%d",  *(unsigned __int8 *)(v10 + 4),  *(unsigned __int8 *)(v10 + 5),  *(unsigned __int8 *)(v10 + 6),  *(unsigned __int8 *)(v10 + 7),  v29);
    CFDictionarySetValue(Mutable, @"IPAddress", v13);
    CFRelease(v13);
    CFDateRef v14 = CFDateCreate(0LL, *(CFAbsoluteTime *)(v10 + 8));
    CFDictionarySetValue(Mutable, @"LeaseStartDate", v14);
    CFRelease(v14);
    CFNumberRef v15 = CFNumberCreate(0LL, kCFNumberSInt32Type, (const void *)(v10 + 16));
    CFDictionarySetValue(Mutable, @"LeaseLength", v15);
    CFRelease(v15);
    int v16 = *(const void **)(v10 + 48);
    if (v16)
    {
      CFDictionarySetValue(Mutable, @"SSID", v16);
      int v17 = *(const void **)(v10 + 56);
      if (v17) {
        CFDictionarySetValue(Mutable, @"NetworkID", v17);
      }
    }

    CFDataRef v18 = CFDataCreateWithBytesNoCopy(0LL, (const UInt8 *)(v10 + 68), *(int *)(v10 + 64), kCFAllocatorNull);
    CFDictionarySetValue(Mutable, @"PacketData", v18);
    CFRelease(v18);
    if (*(_DWORD *)(v10 + 20))
    {
      CFStringRef v19 = CFStringCreateWithFormat( 0LL,  0LL,  @"%d.%d.%d.%d",  *(_DWORD *)(v10 + 20),  BYTE1(*(_DWORD *)(v10 + 20)),  BYTE2(*(_DWORD *)(v10 + 20)),  HIBYTE(*(_DWORD *)(v10 + 20)));
      CFDictionarySetValue(Mutable, @"RouterIPAddress", v19);
      CFRelease(v19);
      if (*(_BYTE *)(v10 + 40))
      {
        CFDataRef v20 = CFDataCreateWithBytesNoCopy( 0LL,  (const UInt8 *)(v10 + 24),  *(unsigned __int8 *)(v10 + 40),  kCFAllocatorNull);
        CFDictionarySetValue(Mutable, @"RouterHardwareAddress", v20);
        CFRelease(v20);
      }
    }

    uint64_t v29 = (const char *)Mutable;
    if ((sub_4FB24(Mutable, (const char *)v30, 0x1A4u) & 0x80000000) != 0 && *__error() != 2)
    {
      uint64_t v21 = sub_57538();
      uint64_t v22 = _SC_syslog_os_log_mapping(5LL);
      if (__SC_log_enabled(5LL, v21, v22))
      {
        uint64_t v23 = _os_log_pack_size(22LL);
        __int128 v24 = (char *)&v30[-1] - ((__chkstk_darwin(v23) + 15) & 0xFFFFFFFFFFFFFFF0LL);
        int v25 = __error();
        uint64_t v26 = _os_log_pack_fill( v24,  v23,  *v25,  &dword_0,  "my_CFPropertyListWriteFile(%s) failed, %s",  v29,  v30[0]);
        uint64_t v27 = __error();
        uint64_t v28 = strerror(*v27);
        *(_DWORD *)uint64_t v26 = 136315394;
        *(void *)(v26 + 4) = v30;
        *(_WORD *)(v26 + 12) = 2080;
        *(void *)(v26 + 14) = v28;
        __SC_log_send(5LL, v21, v22, v24);
      }
    }

    sub_4FA18((const void **)&v29);
  }

  else
  {
    unlink((const char *)v30);
  }

_DWORD *DHCPLeaseListCopyARPAddressInfo( uint64_t *a1, const void *a2, const void *a3, double *a4, int a5, _DWORD *a6)
{
  int v63 = a5;
  uint64_t v61 = a3;
  sub_2FF9C(a1);
  int v10 = sub_50C94(a1);
  if (!v10)
  {
LABEL_29:
    int v54 = 0;
    uint64_t result = 0LL;
    goto LABEL_30;
  }

  int v11 = v10;
  uint64_t result = malloc(24LL * v10);
  if (v11 < 1) {
    goto LABEL_28;
  }
  int v59 = a4;
  uint64_t v57 = a6;
  int v62 = 0;
  uint64_t v14 = 0LL;
  *(void *)&__int128 v13 = 67110400LL;
  __int128 v55 = v13;
  *(void *)&__int128 v13 = 138412290LL;
  __int128 v58 = v13;
  uint64_t v56 = result;
  uint64_t v60 = result;
  do
  {
    uint64_t v15 = sub_50C98(a1, v14);
    uint64_t v16 = v15;
    if (!a2) {
      goto LABEL_9;
    }
    int v17 = *(const void **)(v15 + 48);
    if (!v17)
    {
      uint64_t v41 = sub_57538();
      uint64_t v42 = _SC_syslog_os_log_mapping(6LL);
      if (__SC_log_enabled(6LL, v41, v42))
      {
        uint64_t v43 = _os_log_pack_size(2LL);
        CFRange v44 = (char *)&v55 - ((__chkstk_darwin(v43) + 15) & 0xFFFFFFFFFFFFFFF0LL);
        CFRange v45 = __error();
        *(_WORD *)_os_log_pack_fill(v44, v43, *v45, &dword_0, "ignoring lease with no SSID") = 0;
        __SC_log_send(6LL, v41, v42, v44);
      }

      goto LABEL_23;
    }

    if (CFEqual(v17, a2) || sub_506A4(v61, *(const void **)(v16 + 56)))
    {
LABEL_9:
      if (!*(_DWORD *)(v16 + 20) || (size_t v18 = *(unsigned __int8 *)(v16 + 40), !*(_BYTE *)(v16 + 40)))
      {
        uint64_t v19 = sub_57538();
        uint64_t v20 = _SC_syslog_os_log_mapping(6LL);
        uint64_t v31 = _os_log_pack_size(26LL);
        uint64_t v22 = (char *)&v55 - ((__chkstk_darwin(v31) + 15) & 0xFFFFFFFFFFFFFFF0LL);
        uint64_t v32 = __error();
        uint64_t v33 = _os_log_pack_fill( v22,  v31,  *v32,  &dword_0,  "ignoring lease for %d.%d.%d.%d",  (_DWORD)v55,  DWORD2(v55),  (_DWORD)v56,  (_DWORD)v57);
        int v34 = *(unsigned __int8 *)(v16 + 4);
        int v35 = *(unsigned __int8 *)(v16 + 5);
        int v36 = *(unsigned __int8 *)(v16 + 6);
        int v37 = *(unsigned __int8 *)(v16 + 7);
        *(_DWORD *)uint64_t v33 = 67109888;
        *(_DWORD *)(v33 + 4) = v34;
        *(_WORD *)(v33 + 8) = 1024;
        *(_DWORD *)(v33 + 10) = v35;
        *(_WORD *)(v33 + 14) = 1024;
        *(_DWORD *)(v33 + 16) = v36;
        *(_WORD *)(v33 + 20) = 1024;
        *(_DWORD *)(v33 + 22) = v37;
LABEL_18:
        uint64_t v38 = v19;
        uint64_t v39 = v20;
        unsigned int v40 = v22;
LABEL_19:
        __SC_log_send(6LL, v38, v39, v40);
        goto LABEL_23;
      }

      if (!*(_BYTE *)v16 || v63)
      {
        if (v59 && *(double *)(v16 + 8) < *v59)
        {
          uint64_t v19 = sub_57538();
          uint64_t v20 = _SC_syslog_os_log_mapping(6LL);
          uint64_t v21 = _os_log_pack_size(46LL);
          uint64_t v22 = (char *)&v55 - ((__chkstk_darwin(v21) + 15) & 0xFFFFFFFFFFFFFFF0LL);
          uint64_t v23 = __error();
          uint64_t v24 = _os_log_pack_fill( v22,  v21,  *v23,  &dword_0,  "start time on lease %d.%d.%d.%d too old (%g < %g)",  (_DWORD)v55,  DWORD2(v55),  (_DWORD)v56,  (_DWORD)v57,  *(double *)&v58,  *((double *)&v58 + 1));
          int v25 = *(unsigned __int8 *)(v16 + 4);
          int v26 = *(unsigned __int8 *)(v16 + 5);
          int v27 = *(unsigned __int8 *)(v16 + 6);
          int v28 = *(unsigned __int8 *)(v16 + 7);
          uint64_t v29 = *(void *)(v16 + 8);
          double v30 = *v59;
          *(_DWORD *)uint64_t v24 = v55;
          *(_DWORD *)(v24 + 4) = v25;
          *(_WORD *)(v24 + 8) = 1024;
          *(_DWORD *)(v24 + 10) = v26;
          *(_WORD *)(v24 + 14) = 1024;
          *(_DWORD *)(v24 + 16) = v27;
          *(_WORD *)(v24 + 20) = 1024;
          *(_DWORD *)(v24 + 22) = v28;
          *(_WORD *)(v24 + 26) = 2048;
          *(void *)(v24 + 28) = v29;
          *(_WORD *)(v24 + 36) = 2048;
          *(double *)(v24 + 38) = v30;
          goto LABEL_18;
        }

        uint64_t v46 = v60;
        *uint64_t v60 = *(_DWORD *)(v16 + 4);
        v46[1] = *(_DWORD *)(v16 + 20);
        memmove(v46 + 2, (const void *)(v16 + 24), v18);
        ++v62;
        uint64_t v60 = v46 + 6;
      }
    }

    else
    {
      uint64_t v47 = sub_57538();
      uint64_t v48 = _SC_syslog_os_log_mapping(6LL);
      if (__SC_log_enabled(6LL, v47, v48))
      {
        uint64_t v49 = _os_log_pack_size(12LL);
        uint64_t v50 = (char *)&v55 - ((__chkstk_darwin(v49) + 15) & 0xFFFFFFFFFFFFFFF0LL);
        uint64_t v51 = __error();
        uint64_t v52 = _os_log_pack_fill(v50, v49, *v51, &dword_0, "ignoring lease with SSID %@");
        uint64_t v53 = *(void *)(v16 + 48);
        *(_DWORD *)uint64_t v52 = v58;
        *(void *)(v52 + 4) = v53;
        uint64_t v38 = v47;
        uint64_t v39 = v48;
        unsigned int v40 = v50;
        goto LABEL_19;
      }
    }

uint64_t DHCPLeaseListFindLease(uint64_t a1, unsigned int a2, int a3, const void *a4, unsigned int a5)
{
  unsigned int v10 = bswap32(a2);
  BOOL v11 = HIBYTE(v10) == 10 || v10 >> 20 == 2753;
  unsigned int v12 = HIWORD(v10);
  int v14 = v11 || v12 == 49320;
  int v15 = sub_50C94(a1);
  if (v15 < 1) {
    return 0xFFFFFFFFLL;
  }
  int v16 = v15;
  uint64_t v17 = 0LL;
  if (a4) {
    BOOL v18 = a5 == 0;
  }
  else {
    BOOL v18 = 1;
  }
  char v19 = v18;
  while (1)
  {
    uint64_t v20 = sub_50C98(a1, v17);
    if (*(_DWORD *)(v20 + 4) == a2
      && (!v14
       || *(_DWORD *)(v20 + 20) == a3
       && (!a3 || *(unsigned __int8 *)(v20 + 40) == a5 && ((v19 & 1) != 0 || !bcmp((const void *)(v20 + 24), a4, a5)))))
    {
      break;
    }

    uint64_t v17 = (v17 + 1);
    if (v16 == (_DWORD)v17) {
      return 0xFFFFFFFFLL;
    }
  }

  return v17;
}

uint64_t DHCPLeaseListFindLeaseForWiFi(uint64_t a1, const void *a2, const void *a3)
{
  int v6 = sub_50C94(a1);
  if (v6 >= 1)
  {
    LODWORD(v7) = v6;
    for (unsigned int i = v6 + 1; i > 1; --i)
    {
      uint64_t v7 = (v7 - 1);
      uint64_t v9 = sub_50C98(a1, i - 2);
      unsigned int v10 = *(const void **)(v9 + 48);
      if (v10)
      {
        if (CFEqual(v10, a2)) {
          return i - 2;
        }
      }
    }
  }

  return 0xFFFFFFFFLL;
}

uint64_t DHCPLeaseListRemoveLeaseForWiFi(uint64_t *a1, const void *a2, const void *a3)
{
  uint64_t v24 = a3;
  uint64_t result = DHCPLeaseListFindLeaseForWiFi((uint64_t)a1, a2, a3);
  if ((_DWORD)result != -1)
  {
    uint64_t v7 = result;
    *(void *)&__int128 v6 = 138414338LL;
    __int128 v23 = v6;
    do
    {
      unsigned int v8 = (unsigned __int8 *)sub_50C98(a1, v7);
      uint64_t v9 = sub_57538();
      uint64_t v10 = _SC_syslog_os_log_mapping(5LL);
      if (__SC_log_enabled(5LL, v9, v10))
      {
        uint64_t v11 = _os_log_pack_size(60LL);
        unsigned int v12 = (char *)&v23 - ((__chkstk_darwin(v11) + 15) & 0xFFFFFFFFFFFFFFF0LL);
        __int128 v13 = __error();
        uint64_t v14 = _os_log_pack_fill( v12,  v11,  *v13,  &dword_0,  "Removing Lease SSID %@ %d.%d.%d.%d Router %d.%d.%d.%d");
        int v15 = v8[4];
        int v16 = v8[5];
        int v17 = v8[6];
        int v18 = v8[7];
        int v19 = v8[20];
        int v20 = v8[21];
        int v21 = v8[22];
        int v22 = v8[23];
        *(_DWORD *)uint64_t v14 = v23;
        *(void *)(v14 + 4) = a2;
        *(_WORD *)(v14 + 12) = 1024;
        *(_DWORD *)(v14 + 14) = v15;
        *(_WORD *)(v14 + 18) = 1024;
        *(_DWORD *)(v14 + 20) = v16;
        *(_WORD *)(v14 + 24) = 1024;
        *(_DWORD *)(v14 + 26) = v17;
        *(_WORD *)(v14 + 30) = 1024;
        *(_DWORD *)(v14 + 32) = v18;
        *(_WORD *)(v14 + 36) = 1024;
        *(_DWORD *)(v14 + 38) = v19;
        *(_WORD *)(v14 + 42) = 1024;
        *(_DWORD *)(v14 + 44) = v20;
        *(_WORD *)(v14 + 48) = 1024;
        *(_DWORD *)(v14 + 50) = v21;
        *(_WORD *)(v14 + 54) = 1024;
        *(_DWORD *)(v14 + 56) = v22;
        __SC_log_send(5LL, v9, v10, v12);
      }

      sub_53DAC(a1, v7);
      uint64_t result = DHCPLeaseListFindLeaseForWiFi((uint64_t)a1, a2, v24);
      uint64_t v7 = result;
    }

    while ((_DWORD)result != -1);
  }

  return result;
}

void DHCPLeaseListUpdateLease( uint64_t *a1, unsigned int a2, int a3, const void *a4, unsigned int a5, int a6, const void *a7, int a8, double a9, const void *a10, const void *a11)
{
  uint64_t v41 = a7;
  uint64_t v42 = a4;
  unsigned int v18 = bswap32(a2);
  BOOL v19 = HIBYTE(v18) == 10 || v18 >> 20 == 2753;
  unsigned int v20 = HIWORD(v18);
  int v22 = v19 || v20 == 49320;
  __int128 v23 = malloc(a8 + 68LL);
  *__int128 v23 = 0u;
  v23[1] = 0u;
  v23[2] = 0u;
  v23[3] = 0u;
  *((_DWORD *)v23 + 16) = 0;
  *((_DWORD *)v23 + 1) = a2;
  *((double *)v23 + 1) = a9;
  *((_DWORD *)v23 + 4) = a6;
  *((_DWORD *)v23 + 5) = a3;
  memmove((char *)v23 + 68, v41, a8);
  uint64_t v24 = v42;
  *((_DWORD *)v23 + 16) = a8;
  if (v24 && a5)
  {
    if (a5 >= 0x10) {
      size_t v25 = 16LL;
    }
    else {
      size_t v25 = a5;
    }
    *((_BYTE *)v23 + 40) = v25;
    memmove((char *)v23 + 24, v24, v25);
  }

  if (a10)
  {
    CFRetain(a10);
    *((void *)v23 + 6) = a10;
    if (a11)
    {
      CFRetain(a11);
      *((void *)v23 + 7) = a11;
    }
  }

  int v26 = sub_50C94(a1);
  if (v26 >= 1)
  {
    int v27 = v26;
    uint64_t v28 = 0LL;
    do
    {
      uint64_t v29 = sub_50C98(a1, v28);
      if (sub_31018(v29, (uint64_t)v23, v22))
      {
        sub_53DAC(a1, v28);
        LODWORD(v28) = v28 - 1;
        --v27;
      }

      uint64_t v28 = (v28 + 1);
    }

    while ((int)v28 < v27);
  }

  sub_53DA4(a1, v23);
  uint64_t v30 = sub_57538();
  uint64_t v31 = _SC_syslog_os_log_mapping(6LL);
  if (__SC_log_enabled(6LL, v30, v31))
  {
    uint64_t v32 = _os_log_pack_size(26LL);
    uint64_t v33 = (char *)&v40 - ((__chkstk_darwin(v32) + 15) & 0xFFFFFFFFFFFFFFF0LL);
    int v34 = __error();
    uint64_t v35 = _os_log_pack_fill( v33,  v32,  *v34,  &dword_0,  "Saved lease for %d.%d.%d.%d",  v40,  (_DWORD)v41,  (_DWORD)v42,  v43);
    int v36 = *((unsigned __int8 *)v23 + 4);
    int v37 = *((unsigned __int8 *)v23 + 5);
    int v38 = *((unsigned __int8 *)v23 + 6);
    int v39 = *((unsigned __int8 *)v23 + 7);
    *(_DWORD *)uint64_t v35 = 67109888;
    *(_DWORD *)(v35 + 4) = v36;
    *(_WORD *)(v35 + 8) = 1024;
    *(_DWORD *)(v35 + 10) = v37;
    *(_WORD *)(v35 + 14) = 1024;
    *(_DWORD *)(v35 + 16) = v38;
    *(_WORD *)(v35 + 20) = 1024;
    *(_DWORD *)(v35 + 22) = v39;
    __SC_log_send(6LL, v30, v31, v33);
  }

  if (G_IPConfiguration_verbose) {
    sub_2FCC0((uint64_t)a1);
  }
}

uint64_t sub_31018(uint64_t a1, uint64_t a2, int a3)
{
  if (!*(_DWORD *)(a1 + 20) || (size_t v5 = *(unsigned __int8 *)(a1 + 40), !*(_BYTE *)(a1 + 40)))
  {
    uint64_t v22 = sub_57538();
    uint64_t v23 = _SC_syslog_os_log_mapping(6LL);
    if (__SC_log_enabled(6LL, v22, v23))
    {
      uint64_t v28 = _os_log_pack_size(26LL);
      size_t v25 = (char *)&v57 - ((__chkstk_darwin(v28) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v29 = *__error();
      uint64_t v27 = _os_log_pack_fill(v25, v28, v29, &dword_0, "Removing lease with no router for IP address %d.%d.%d.%d");
      goto LABEL_24;
    }

    return 1LL;
  }

  if (*(_BYTE *)(a1 + 1))
  {
    *(_BYTE *)(a1 + 1) = 0;
    unsigned int v7 = bswap32(*(_DWORD *)(a1 + 4));
    BOOL v8 = HIBYTE(v7) == 10 || v7 >> 20 == 2753;
    unsigned int v9 = HIWORD(v7);
    int v11 = v8 || v9 == 49320;
    if (v11 == a3 && (!*(_BYTE *)(a2 + 40) || !bcmp((const void *)(a1 + 24), (const void *)(a2 + 24), v5)))
    {
      uint64_t v22 = sub_57538();
      uint64_t v23 = _SC_syslog_os_log_mapping(6LL);
      uint64_t v39 = _os_log_pack_size(26LL);
      size_t v25 = (char *)&v57 - ((__chkstk_darwin(v39) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v40 = *__error();
      uint64_t v27 = _os_log_pack_fill(v25, v39, v40, &dword_0, "Removing NAK'd lease for IP address %d.%d.%d.%d");
      goto LABEL_24;
    }

    uint64_t v12 = sub_57538();
    uint64_t v13 = _SC_syslog_os_log_mapping(6LL);
    if (__SC_log_enabled(6LL, v12, v13))
    {
      uint64_t v14 = _os_log_pack_size(26LL);
      int v15 = (char *)&v57 - ((__chkstk_darwin(v14) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      int v16 = __error();
      uint64_t v17 = _os_log_pack_fill( v15,  v14,  *v16,  &dword_0,  "Ignoring NAK on IP address %d.%d.%d.%d",  v57,  v58,  v59,  v60);
      int v18 = *(unsigned __int8 *)(a1 + 4);
      int v19 = *(unsigned __int8 *)(a1 + 5);
      int v20 = *(unsigned __int8 *)(a1 + 6);
      int v21 = *(unsigned __int8 *)(a1 + 7);
      *(_DWORD *)uint64_t v17 = 67109888;
      *(_DWORD *)(v17 + 4) = v18;
      *(_WORD *)(v17 + 8) = 1024;
      *(_DWORD *)(v17 + 10) = v19;
      *(_WORD *)(v17 + 14) = 1024;
      *(_DWORD *)(v17 + 16) = v20;
      *(_WORD *)(v17 + 20) = 1024;
      *(_DWORD *)(v17 + 22) = v21;
      __SC_log_send(6LL, v12, v13, v15);
    }
  }

  if (!a3 && *(_DWORD *)(a2 + 4) == *(_DWORD *)(a1 + 4))
  {
    uint64_t v22 = sub_57538();
    uint64_t v23 = _SC_syslog_os_log_mapping(6LL);
    if (__SC_log_enabled(6LL, v22, v23))
    {
      uint64_t v24 = _os_log_pack_size(26LL);
      size_t v25 = (char *)&v57 - ((__chkstk_darwin(v24) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v26 = *__error();
      uint64_t v27 = _os_log_pack_fill(v25, v24, v26, &dword_0, "Removing lease for public IP address %d.%d.%d.%d");
LABEL_24:
      int v30 = *(unsigned __int8 *)(a1 + 4);
      int v31 = *(unsigned __int8 *)(a1 + 5);
      int v32 = *(unsigned __int8 *)(a1 + 6);
      int v33 = *(unsigned __int8 *)(a1 + 7);
      *(_DWORD *)uint64_t v27 = 67109888;
      *(_DWORD *)(v27 + 4) = v30;
      *(_WORD *)(v27 + 8) = 1024;
      *(_DWORD *)(v27 + 10) = v31;
      *(_WORD *)(v27 + 14) = 1024;
      *(_DWORD *)(v27 + 16) = v32;
      *(_WORD *)(v27 + 20) = 1024;
      *(_DWORD *)(v27 + 22) = v33;
      uint64_t v34 = v22;
      uint64_t v35 = v23;
      goto LABEL_25;
    }

    return 1LL;
  }

  int v38 = *(_DWORD *)(a2 + 20);
  if (v38
    && *(_BYTE *)(a2 + 40)
    && v38 == *(_DWORD *)(a1 + 20)
    && !bcmp((const void *)(a2 + 24), (const void *)(a1 + 24), *(unsigned __int8 *)(a2 + 40)))
  {
    int v41 = *(_DWORD *)(a2 + 4);
    int v42 = *(_DWORD *)(a1 + 4);
    uint64_t v43 = sub_57538();
    uint64_t v44 = _SC_syslog_os_log_mapping(6LL);
    int v45 = __SC_log_enabled(6LL, v43, v44);
    if (v41 != v42)
    {
      if (!v45) {
        return 1LL;
      }
      uint64_t v53 = _os_log_pack_size(50LL);
      int v54 = (char *)&v57 - ((__chkstk_darwin(v53) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      __int128 v55 = __error();
      uint64_t v56 = _os_log_pack_fill( v54,  v53,  *v55,  &dword_0,  "Removing lease with same router, old IP %d.%d.%d.%d new IP %d.%d.%d.%d",  v57,  v58,  v59,  v60,  v61,  v62,  v63,  v64);
      sub_316AC( v56,  *(unsigned __int8 *)(a1 + 4),  *(unsigned __int8 *)(a1 + 5),  *(unsigned __int8 *)(a1 + 6),  *(unsigned __int8 *)(a1 + 7),  *(unsigned __int8 *)(a2 + 4),  *(unsigned __int8 *)(a2 + 5),  *(unsigned __int8 *)(a2 + 6),  *(unsigned __int8 *)(a2 + 7));
      uint64_t v34 = v43;
      uint64_t v35 = v44;
      int v36 = v54;
      goto LABEL_26;
    }

    if (!v45) {
      return 1LL;
    }
    uint64_t v46 = _os_log_pack_size(26LL);
    size_t v25 = (char *)&v57 - ((__chkstk_darwin(v46) + 15) & 0xFFFFFFFFFFFFFFF0LL);
    uint64_t v47 = __error();
    uint64_t v48 = _os_log_pack_fill( v25,  v46,  *v47,  &dword_0,  "Removing lease with same router for IP address %d.%d.%d.%d",  v57,  v58,  v59,  v60);
    int v49 = *(unsigned __int8 *)(a1 + 4);
    int v50 = *(unsigned __int8 *)(a1 + 5);
    int v51 = *(unsigned __int8 *)(a1 + 6);
    int v52 = *(unsigned __int8 *)(a1 + 7);
    *(_DWORD *)uint64_t v48 = 67109888;
    *(_DWORD *)(v48 + 4) = v49;
    *(_WORD *)(v48 + 8) = 1024;
    *(_DWORD *)(v48 + 10) = v50;
    *(_WORD *)(v48 + 14) = 1024;
    *(_DWORD *)(v48 + 16) = v51;
    *(_WORD *)(v48 + 20) = 1024;
    *(_DWORD *)(v48 + 22) = v52;
    uint64_t v34 = v43;
    uint64_t v35 = v44;
LABEL_25:
    int v36 = v25;
LABEL_26:
    __SC_log_send(6LL, v34, v35, v36);
    return 1LL;
  }

  return 0LL;
}

uint64_t DHCPLeaseListRemoveLease(uint64_t *a1, unsigned int a2, int a3, const void *a4, unsigned int a5)
{
  uint64_t result = DHCPLeaseListFindLease((uint64_t)a1, a2, a3, a4, a5);
  if ((_DWORD)result != -1)
  {
    unsigned int v7 = result;
    BOOL v8 = (unsigned __int8 *)sub_50C98(a1, result);
    uint64_t v9 = sub_57538();
    uint64_t v10 = _SC_syslog_os_log_mapping(6LL);
    if (__SC_log_enabled(6LL, v9, v10))
    {
      uint64_t v11 = _os_log_pack_size(26LL);
      uint64_t v12 = (char *)v19 - ((__chkstk_darwin(v11) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v13 = __error();
      uint64_t v14 = _os_log_pack_fill( v12,  v11,  *v13,  &dword_0,  "Removing lease for %d.%d.%d.%d",  v19[0],  v19[2],  v19[4],  v19[6]);
      int v15 = v8[4];
      int v16 = v8[5];
      int v17 = v8[6];
      int v18 = v8[7];
      *(_DWORD *)uint64_t v14 = 67109888;
      *(_DWORD *)(v14 + 4) = v15;
      *(_WORD *)(v14 + 8) = 1024;
      *(_DWORD *)(v14 + 10) = v16;
      *(_WORD *)(v14 + 14) = 1024;
      *(_DWORD *)(v14 + 16) = v17;
      *(_WORD *)(v14 + 20) = 1024;
      *(_DWORD *)(v14 + 22) = v18;
      __SC_log_send(6LL, v9, v10, v12);
    }

    return sub_53DAC(a1, v7);
  }

  return result;
}

double sub_316AC(uint64_t a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9)
{
  *(void *)&double result = 67110912LL;
  *(_DWORD *)a1 = 67110912;
  *(_DWORD *)(a1 + 4) = a2;
  *(_WORD *)(a1 + 8) = 1024;
  *(_DWORD *)(a1 + 10) = a3;
  *(_WORD *)(a1 + 14) = 1024;
  *(_DWORD *)(a1 + 16) = a4;
  *(_WORD *)(a1 + 20) = 1024;
  *(_DWORD *)(a1 + 22) = a5;
  *(_WORD *)(a1 + 26) = 1024;
  *(_DWORD *)(a1 + 28) = a6;
  *(_WORD *)(a1 + 32) = 1024;
  *(_DWORD *)(a1 + 34) = a7;
  *(_WORD *)(a1 + 38) = 1024;
  *(_DWORD *)(a1 + 40) = a8;
  *(_WORD *)(a1 + 44) = 1024;
  *(_DWORD *)(a1 + 46) = a9;
  return result;
}

uint64_t sub_31700()
{
  return socket(2, 2, 0);
}

uint64_t sub_31710(int a1, uint64_t a2, void *a3)
{
  uint64_t result = sub_31730(a1, a2, a3);
  if ((_DWORD)result) {
    return *__error();
  }
  return result;
}

uint64_t sub_31730(int a1, uint64_t a2, void *a3)
{
  __int128 v20 = 0u;
  __int128 v21 = 0u;
  __strlcpy_chk(&v20, a2, 16LL, 16LL);
  uint64_t v6 = ioctl(a1, 0xC020698EuLL, &v20);
  if ((_DWORD)v6)
  {
    unsigned int v7 = __error();
    uint64_t v8 = 0LL;
    int v9 = *v7;
    BOOL v10 = *v7 == 6 || v9 == 22;
    if (!v10 && v9 != 82)
    {
      uint64_t v11 = sub_57538();
      uint64_t v12 = _SC_syslog_os_log_mapping(5LL);
      if (__SC_log_enabled(5LL, v11, v12))
      {
        uint64_t v13 = _os_log_pack_size(22LL);
        uint64_t v14 = (char *)&v20 - ((__chkstk_darwin(v13) + 15) & 0xFFFFFFFFFFFFFFF0LL);
        int v15 = __error();
        uint64_t v16 = _os_log_pack_fill( v14,  v13,  *v15,  &dword_0,  "%s: SIOCGIFEFLAGS failed status, %s",  (const char *)v20,  *((const char **)&v20 + 1));
        int v17 = __error();
        int v18 = strerror(*v17);
        *(_DWORD *)uint64_t v16 = 136315394;
        *(void *)(v16 + 4) = a2;
        *(_WORD *)(v16 + 12) = 2080;
        *(void *)(v16 + 14) = v18;
        __SC_log_send(5LL, v11, v12, v14);
      }

      uint64_t v8 = 0LL;
    }
  }

  else
  {
    uint64_t v8 = v21;
  }

  *a3 = v8;
  return v6;
}

uint64_t sub_318D4(const char *a1, int a2)
{
  int v4 = socket(2, 2, 0);
  if (v4 < 0) {
    return *__error();
  }
  int v5 = v4;
  uint64_t v18 = 0LL;
  uint64_t v19 = 0LL;
  strncpy(__dst, a1, 0x10uLL);
  LODWORD(v18) = a2;
  if (ioctl(v5, 0x80206934uLL, __dst) < 0)
  {
    uint64_t v6 = *__error();
    uint64_t v7 = sub_57538();
    uint64_t v8 = _SC_syslog_os_log_mapping(3LL);
    if (__SC_log_enabled(3LL, v7, v8))
    {
      uint64_t v9 = _os_log_pack_size(34LL);
      BOOL v10 = &__dst[-((__chkstk_darwin(v9) + 15) & 0xFFFFFFFFFFFFFFF0LL) - 8];
      uint64_t v11 = __error();
      uint64_t v12 = _os_log_pack_fill( v10,  v9,  *v11,  &dword_0,  "siocsifmtu(%s, %d) failed, %s (%d)",  v15,  *(_DWORD *)__dst,  v17,  v18);
      uint64_t v13 = strerror(v6);
      *(_DWORD *)uint64_t v12 = 136315906;
      *(void *)(v12 + 4) = a1;
      *(_WORD *)(v12 + 12) = 1024;
      *(_DWORD *)(v12 + 14) = a2;
      *(_WORD *)(v12 + 18) = 2080;
      *(void *)(v12 + 20) = v13;
      *(_WORD *)(v12 + 28) = 1024;
      *(_DWORD *)(v12 + 30) = v6;
      __SC_log_send(3LL, v7, v8, v10);
    }
  }

  else
  {
    uint64_t v6 = 0LL;
  }

  close(v5);
  return v6;
}

uint64_t sub_31A94(const char *a1, int a2)
{
  int v4 = socket(2, 2, 0);
  if (v4 < 0) {
    return *__error();
  }
  int v5 = v4;
  uint64_t v6 = sub_57538();
  uint64_t v7 = _SC_syslog_os_log_mapping(6LL);
  if (__SC_log_enabled(6LL, v6, v7))
  {
    uint64_t v8 = _os_log_pack_size(32LL);
    uint64_t v9 = (char *)v15 - ((__chkstk_darwin(v8) + 15) & 0xFFFFFFFFFFFFFFF0LL);
    BOOL v10 = __error();
    uint64_t v11 = _os_log_pack_fill(v9, v8, *v10, &dword_0, "%s(%s, %s)", v15[0], v15[1], v15[2]);
    uint64_t v12 = "UP";
    *(void *)(v11 + 4) = "interface_up_down";
    *(_DWORD *)uint64_t v11 = 136315650;
    if (!a2) {
      uint64_t v12 = "DOWN";
    }
    *(_WORD *)(v11 + 12) = 2080;
    *(void *)(v11 + 14) = a1;
    *(_WORD *)(v11 + 22) = 2080;
    *(void *)(v11 + 24) = v12;
    __SC_log_send(6LL, v6, v7, v9);
  }

  uint64_t v13 = sub_31C28(v5, a1, a2 != 0, a2 == 0);
  close(v5);
  return v13;
}

uint64_t sub_31C28(int a1, const char *a2, int a3, int a4)
{
  uint64_t v21 = 0LL;
  uint64_t v22 = 0LL;
  strncpy((char *)__dst, a2, 0x10uLL);
  uint64_t v8 = ioctl(a1, 0xC0206911uLL, __dst);
  if ((v8 & 0x80000000) != 0) {
    return v8;
  }
  int v9 = (unsigned __int16)v21;
  int v10 = ((unsigned __int16)v21 | a3) & (a4 ^ 0xFFFF);
  LOWORD(v21) = (v21 | a3) & ~(_WORD)a4;
  if (v9 == v10) {
    return 0LL;
  }
  uint64_t v11 = ioctl(a1, 0x80206910uLL, __dst);
  uint64_t v12 = sub_57538();
  uint64_t v13 = _SC_syslog_os_log_mapping(6LL);
  if (__SC_log_enabled(6LL, v12, v13))
  {
    uint64_t v14 = _os_log_pack_size(36LL);
    uint64_t v19 = (const char *)&v19;
    int v15 = (char *)&__dst[-2] - ((__chkstk_darwin(v14) + 15) & 0xFFFFFFFFFFFFFFF0LL);
    uint64_t v16 = __error();
    uint64_t v17 = _os_log_pack_fill( v15,  v14,  *v16,  &dword_0,  "interface_set_flags(%s, set 0x%x, clear 0x%x) 0x%x => 0x%x",  v19,  __dst[0],  __dst[2],  v21,  v22);
    *(_DWORD *)uint64_t v17 = 136316162;
    *(void *)(v17 + 4) = a2;
    *(_WORD *)(v17 + 12) = 1024;
    *(_DWORD *)(v17 + 14) = a3;
    *(_WORD *)(v17 + 18) = 1024;
    *(_DWORD *)(v17 + 20) = a4;
    *(_WORD *)(v17 + 24) = 1024;
    *(_DWORD *)(v17 + 26) = v9;
    *(_WORD *)(v17 + 30) = 1024;
    *(_DWORD *)(v17 + 32) = v10;
    __SC_log_send(6LL, v12, v13, v15);
  }

  return v11;
}

uint64_t sub_31DF8(const char *a1, int a2)
{
  int v4 = socket(2, 2, 0);
  if (v4 < 0) {
    return *__error();
  }
  int v5 = v4;
  uint64_t v6 = sub_57538();
  uint64_t v7 = _SC_syslog_os_log_mapping(6LL);
  if (__SC_log_enabled(6LL, v6, v7))
  {
    uint64_t v8 = _os_log_pack_size(32LL);
    int v9 = (char *)v15 - ((__chkstk_darwin(v8) + 15) & 0xFFFFFFFFFFFFFFF0LL);
    int v10 = __error();
    uint64_t v11 = _os_log_pack_fill(v9, v8, *v10, &dword_0, "%s(%s, %s NOARP)", v15[0], v15[1], v15[2]);
    uint64_t v12 = "set";
    *(void *)(v11 + 4) = "interface_set_noarp";
    *(_DWORD *)uint64_t v11 = 136315650;
    if (!a2) {
      uint64_t v12 = "clear";
    }
    *(_WORD *)(v11 + 12) = 2080;
    *(void *)(v11 + 14) = a1;
    *(_WORD *)(v11 + 22) = 2080;
    *(void *)(v11 + 24) = v12;
    __SC_log_send(6LL, v6, v7, v9);
  }

  uint64_t v13 = sub_31C28(v5, a1, (a2 != 0) << 7, (a2 == 0) << 7);
  close(v5);
  return v13;
}

uint64_t sub_31F94(const char *a1, int a2)
{
  int v4 = socket(2, 2, 0);
  if (v4 < 0) {
    return *__error();
  }
  int v5 = v4;
  uint64_t v27 = 0LL;
  uint64_t v28 = 0LL;
  strncpy((char *)&__dst, a1, 0x10uLL);
  if (ioctl(v5, 0xC0206950uLL, &__dst) < 0)
  {
    uint64_t v6 = *__error();
    if ((_DWORD)v6 != 6 && (_DWORD)v6 != 17)
    {
      uint64_t v8 = sub_57538();
      uint64_t v9 = _SC_syslog_os_log_mapping(5LL);
      if (__SC_log_enabled(5LL, v8, v9))
      {
        uint64_t v10 = _os_log_pack_size(28LL);
        uint64_t v11 = (char *)&v24 - ((__chkstk_darwin(v10) + 15) & 0xFFFFFFFFFFFFFFF0LL);
        uint64_t v12 = __error();
        uint64_t v13 = _os_log_pack_fill( v11,  v10,  *v12,  &dword_0,  "siocprotoattach(%s) failed, %s (%d)",  v24,  __dst,  v26);
        uint64_t v14 = __error();
        int v15 = strerror(*v14);
        int v16 = *__error();
        *(_DWORD *)uint64_t v13 = 136315650;
        *(void *)(v13 + 4) = a1;
        *(_WORD *)(v13 + 12) = 2080;
        *(void *)(v13 + 14) = v15;
        *(_WORD *)(v13 + 22) = 1024;
        *(_DWORD *)(v13 + 24) = v16;
        __SC_log_send(5LL, v8, v9, v11);
      }
    }
  }

  else
  {
    uint64_t v6 = 0LL;
  }

  uint64_t v17 = sub_57538();
  uint64_t v18 = _SC_syslog_os_log_mapping(6LL);
  if (__SC_log_enabled(6LL, v17, v18))
  {
    uint64_t v19 = _os_log_pack_size(12LL);
    __int128 v20 = (char *)&v24 - ((__chkstk_darwin(v19) + 15) & 0xFFFFFFFFFFFFFFF0LL);
    uint64_t v21 = __error();
    uint64_t v22 = _os_log_pack_fill(v20, v19, *v21, &dword_0, "inet_attach_interface(%s)", v24);
    *(_DWORD *)uint64_t v22 = 136315138;
    *(void *)(v22 + 4) = a1;
    __SC_log_send(6LL, v17, v18, v20);
  }

  if (a2) {
    sub_31C28(v5, a1, 1, 0);
  }
  close(v5);
  return v6;
}

uint64_t sub_32224(const char *a1)
{
  int v2 = socket(2, 2, 0);
  if (v2 < 0) {
    return *__error();
  }
  int v3 = v2;
  uint64_t v18 = 0LL;
  uint64_t v19 = 0LL;
  strncpy((char *)&__dst, a1, 0x10uLL);
  if (ioctl(v3, 0xC0206951uLL, &__dst) < 0)
  {
    uint64_t v4 = *__error();
    if ((_DWORD)v4 != 6)
    {
      uint64_t v5 = sub_57538();
      uint64_t v6 = _SC_syslog_os_log_mapping(3LL);
      if (__SC_log_enabled(3LL, v5, v6))
      {
        uint64_t v7 = _os_log_pack_size(28LL);
        uint64_t v8 = (char *)&v15 - ((__chkstk_darwin(v7) + 15) & 0xFFFFFFFFFFFFFFF0LL);
        uint64_t v9 = __error();
        uint64_t v10 = _os_log_pack_fill( v8,  v7,  *v9,  &dword_0,  "siocprotodetach(%s) failed, %s (%d)",  v15,  __dst,  v17);
        uint64_t v11 = __error();
        uint64_t v12 = strerror(*v11);
        int v13 = *__error();
        *(_DWORD *)uint64_t v10 = 136315650;
        *(void *)(v10 + 4) = a1;
        *(_WORD *)(v10 + 12) = 2080;
        *(void *)(v10 + 14) = v12;
        *(_WORD *)(v10 + 22) = 1024;
        *(_DWORD *)(v10 + 24) = v13;
        __SC_log_send(3LL, v5, v6, v8);
      }
    }
  }

  else
  {
    uint64_t v4 = 0LL;
  }

  close(v3);
  return v4;
}

uint64_t sub_323EC(const char *a1, int a2)
{
  int v4 = socket(2, 2, 0);
  if (v4 < 0)
  {
    uint64_t v6 = *__error();
    uint64_t v7 = sub_57538();
    uint64_t v8 = _SC_syslog_os_log_mapping(3LL);
    if (__SC_log_enabled(3LL, v7, v8))
    {
      uint64_t v9 = _os_log_pack_size(34LL);
      uint64_t v10 = &__dst[-((__chkstk_darwin(v9) + 15) & 0xFFFFFFFFFFFFFFF0LL) - 8];
      uint64_t v11 = __error();
      uint64_t v12 = _os_log_pack_fill( v10,  v9,  *v11,  &dword_0,  "inet_set_autoaddr(%s, %d): socket() failed, %s (%d)",  v26,  *(_DWORD *)__dst,  v28,  v29);
      int v13 = __error();
      uint64_t v14 = strerror(*v13);
      int v15 = *__error();
      *(_DWORD *)uint64_t v12 = 136315906;
      *(void *)(v12 + 4) = a1;
      *(_WORD *)(v12 + 12) = 1024;
      *(_DWORD *)(v12 + 14) = a2;
      *(_WORD *)(v12 + 18) = 2080;
      *(void *)(v12 + 20) = v14;
      *(_WORD *)(v12 + 28) = 1024;
      *(_DWORD *)(v12 + 30) = v15;
      __SC_log_send(3LL, v7, v8, v10);
    }
  }

  else
  {
    int v5 = v4;
    uint64_t v30 = 0LL;
    strncpy(__dst, a1, 0x10uLL);
    uint64_t v29 = a2;
    if (ioctl(v5, 0xC0206926uLL, __dst) < 0)
    {
      uint64_t v6 = *__error();
      if ((_DWORD)v6 != 6)
      {
        uint64_t v16 = sub_57538();
        uint64_t v17 = _SC_syslog_os_log_mapping(3LL);
        if (__SC_log_enabled(3LL, v16, v17))
        {
          uint64_t v18 = _os_log_pack_size(34LL);
          uint64_t v19 = &__dst[-((__chkstk_darwin(v18) + 15) & 0xFFFFFFFFFFFFFFF0LL) - 8];
          __int128 v20 = __error();
          uint64_t v21 = _os_log_pack_fill( v19,  v18,  *v20,  &dword_0,  "inet_set_autoaddr(%s, %d) failed, %s (%d)",  v26,  *(_DWORD *)__dst,  v28,  v29);
          uint64_t v22 = __error();
          uint64_t v23 = strerror(*v22);
          int v24 = *__error();
          *(_DWORD *)uint64_t v21 = 136315906;
          *(void *)(v21 + 4) = a1;
          *(_WORD *)(v21 + 12) = 1024;
          *(_DWORD *)(v21 + 14) = a2;
          *(_WORD *)(v21 + 18) = 2080;
          *(void *)(v21 + 20) = v23;
          *(_WORD *)(v21 + 28) = 1024;
          *(_DWORD *)(v21 + 30) = v24;
          __SC_log_send(3LL, v16, v17, v19);
        }
      }
    }

    else
    {
      uint64_t v6 = 0LL;
    }

    close(v5);
  }

  return v6;
}

uint64_t sub_326AC(int a1, const char *a2, int a3)
{
  uint64_t v7 = 0LL;
  uint64_t v8 = 0LL;
  strncpy(__dst, a2, 0x10uLL);
  LOWORD(v7) = 528;
  HIDWORD(v7) = a3;
  return ioctl(a1, 0x80206919uLL, __dst);
}

uint64_t sub_3273C(int a1, const char *a2, int a3, int *a4, int *a5)
{
  __int128 v15 = 0u;
  __int128 v14 = 0u;
  __int128 v13 = 0u;
  strncpy(__dst, a2, 0x10uLL);
  LOWORD(v13) = 528;
  DWORD1(v13) = a3;
  if (a4)
  {
    int v9 = *a4;
    LOWORD(v15) = 528;
    DWORD1(v15) = v9;
  }

  if (a5)
  {
    int v10 = *a5;
    LOWORD(v14) = 528;
    DWORD1(v14) = v10;
  }

  return ioctl(a1, 0x8040691AuLL, __dst);
}

uint64_t sub_32804()
{
  return socket(30, 2, 0);
}

uint64_t sub_32814(const char *a1, int a2)
{
  int v4 = socket(30, 2, 0);
  if (v4 < 0)
  {
    uint64_t v6 = *__error();
    uint64_t v7 = sub_57538();
    uint64_t v8 = _SC_syslog_os_log_mapping(3LL);
    if (__SC_log_enabled(3LL, v7, v8))
    {
      uint64_t v9 = _os_log_pack_size(28LL);
      int v10 = (char *)&v31 - ((__chkstk_darwin(v9) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v11 = __error();
      uint64_t v12 = _os_log_pack_fill( v10,  v9,  *v11,  &dword_0,  "inet6_attach_interface(%s): socket() failed, %s (%d)",  v31,  __dst,  v33);
      __int128 v13 = strerror(v6);
      *(_DWORD *)uint64_t v12 = 136315650;
      *(void *)(v12 + 4) = a1;
      *(_WORD *)(v12 + 12) = 2080;
      *(void *)(v12 + 14) = v13;
      *(_WORD *)(v12 + 22) = 1024;
      *(_DWORD *)(v12 + 24) = v6;
      __SC_log_send(3LL, v7, v8, v10);
    }
  }

  else
  {
    int v5 = v4;
    __int128 v40 = 0u;
    __int128 v39 = 0u;
    __int128 v38 = 0u;
    __int128 v37 = 0u;
    __int128 v36 = 0u;
    __int128 v35 = 0u;
    __int128 v34 = 0u;
    strncpy((char *)&__dst, a1, 0x10uLL);
    if (ioctl(v5, 0xC080696EuLL, &__dst) < 0)
    {
      uint64_t v6 = *__error();
      if ((_DWORD)v6 != 6 && (_DWORD)v6 != 17)
      {
        uint64_t v15 = sub_57538();
        uint64_t v16 = _SC_syslog_os_log_mapping(5LL);
        if (__SC_log_enabled(5LL, v15, v16))
        {
          uint64_t v17 = _os_log_pack_size(28LL);
          uint64_t v18 = (char *)&v31 - ((__chkstk_darwin(v17) + 15) & 0xFFFFFFFFFFFFFFF0LL);
          uint64_t v19 = __error();
          uint64_t v20 = _os_log_pack_fill( v18,  v17,  *v19,  &dword_0,  "siocprotoattach_in6(%s) failed, %s (%d)",  v31,  __dst,  v33);
          uint64_t v21 = __error();
          uint64_t v22 = strerror(*v21);
          int v23 = *__error();
          *(_DWORD *)uint64_t v20 = 136315650;
          *(void *)(v20 + 4) = a1;
          *(_WORD *)(v20 + 12) = 2080;
          *(void *)(v20 + 14) = v22;
          *(_WORD *)(v20 + 22) = 1024;
          *(_DWORD *)(v20 + 24) = v23;
          __SC_log_send(5LL, v15, v16, v18);
        }
      }
    }

    else
    {
      uint64_t v6 = 0LL;
    }

    uint64_t v24 = sub_57538();
    uint64_t v25 = _SC_syslog_os_log_mapping(6LL);
    if (__SC_log_enabled(6LL, v24, v25))
    {
      uint64_t v26 = _os_log_pack_size(12LL);
      uint64_t v27 = (char *)&v31 - ((__chkstk_darwin(v26) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v28 = __error();
      uint64_t v29 = _os_log_pack_fill(v27, v26, *v28, &dword_0, "inet6_attach_interface(%s)", v31);
      *(_DWORD *)uint64_t v29 = 136315138;
      *(void *)(v29 + 4) = a1;
      __SC_log_send(6LL, v24, v25, v27);
    }

    if (a2) {
      sub_31C28(v5, a1, 1, 0);
    }
    close(v5);
  }

  return v6;
}

uint64_t sub_32B8C(const char *a1)
{
  int v2 = socket(30, 2, 0);
  if (v2 < 0)
  {
    uint64_t v4 = *__error();
    uint64_t v5 = sub_57538();
    uint64_t v6 = _SC_syslog_os_log_mapping(3LL);
    if (__SC_log_enabled(3LL, v5, v6))
    {
      uint64_t v7 = _os_log_pack_size(28LL);
      uint64_t v8 = (char *)&v26 - ((__chkstk_darwin(v7) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v9 = __error();
      uint64_t v10 = _os_log_pack_fill( v8,  v7,  *v9,  &dword_0,  "inet6_detach_interface(%s): socket() failed, %s (%d)",  v26,  v27,  (_DWORD)v28);
      uint64_t v11 = strerror(v4);
      *(_DWORD *)uint64_t v10 = 136315650;
      *(void *)(v10 + 4) = a1;
      *(_WORD *)(v10 + 12) = 2080;
      *(void *)(v10 + 14) = v11;
      *(_WORD *)(v10 + 22) = 1024;
      *(_DWORD *)(v10 + 24) = v4;
      uint64_t v12 = 3LL;
LABEL_11:
      __SC_log_send(v12, v5, v6, v8);
    }
  }

  else
  {
    int v3 = v2;
    __int128 v43 = 0u;
    __int128 v44 = 0u;
    __int128 v41 = 0u;
    __int128 v42 = 0u;
    __int128 v39 = 0u;
    __int128 v40 = 0u;
    __int128 v37 = 0u;
    __int128 v38 = 0u;
    __int128 v35 = 0u;
    __int128 v36 = 0u;
    __int128 v33 = 0u;
    __int128 v34 = 0u;
    __int128 v31 = 0u;
    __int128 v32 = 0u;
    __int128 v29 = 0u;
    __int128 v30 = 0u;
    __int128 v28 = 0u;
    strncpy((char *)&v26, a1, 0x10uLL);
    if (ioctl(v3, 0xC120696FuLL, &v26) < 0)
    {
      uint64_t v4 = *__error();
      if ((_DWORD)v4 != 6)
      {
        uint64_t v13 = sub_57538();
        uint64_t v14 = _SC_syslog_os_log_mapping(5LL);
        if (__SC_log_enabled(5LL, v13, v14))
        {
          uint64_t v15 = _os_log_pack_size(28LL);
          uint64_t v16 = (char *)&v26 - ((__chkstk_darwin(v15) + 15) & 0xFFFFFFFFFFFFFFF0LL);
          uint64_t v17 = __error();
          uint64_t v18 = _os_log_pack_fill( v16,  v15,  *v17,  &dword_0,  "siocprotodetach_in6(%s) failed, %s (%d)",  v26,  v27,  (_DWORD)v28);
          uint64_t v19 = __error();
          uint64_t v20 = strerror(*v19);
          int v21 = *__error();
          *(_DWORD *)uint64_t v18 = 136315650;
          *(void *)(v18 + 4) = a1;
          *(_WORD *)(v18 + 12) = 2080;
          *(void *)(v18 + 14) = v20;
          *(_WORD *)(v18 + 22) = 1024;
          *(_DWORD *)(v18 + 24) = v21;
          __SC_log_send(5LL, v13, v14, v16);
        }
      }
    }

    else
    {
      uint64_t v4 = 0LL;
    }

    close(v3);
    uint64_t v5 = sub_57538();
    uint64_t v6 = _SC_syslog_os_log_mapping(6LL);
    if (__SC_log_enabled(6LL, v5, v6))
    {
      uint64_t v22 = _os_log_pack_size(12LL);
      uint64_t v8 = (char *)&v26 - ((__chkstk_darwin(v22) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      int v23 = __error();
      uint64_t v24 = _os_log_pack_fill(v8, v22, *v23, &dword_0, "inet6_detach_interface(%s)", v26);
      *(_DWORD *)uint64_t v24 = 136315138;
      *(void *)(v24 + 4) = a1;
      uint64_t v12 = 6LL;
      goto LABEL_11;
    }
  }

  return v4;
}

uint64_t sub_32EDC(uint64_t a1)
{
  uint64_t v1 = (int *)sub_36360(a1, &v7);
  if (!v1) {
    return 0LL;
  }
  uint64_t v2 = v7;
  if (v7)
  {
    int v3 = v1;
    while (1)
    {
      int v4 = *v3++;
      if (v4 == 30) {
        break;
      }
      if (!--v2) {
        goto LABEL_6;
      }
    }

    uint64_t v5 = 1LL;
  }

  else
  {
LABEL_6:
    uint64_t v5 = 0LL;
  }

  free(v1);
  return v5;
}

uint64_t sub_32F44(char *a1, _OWORD *a2, int a3, int a4, int a5, int a6)
{
  int v12 = socket(30, 2, 0);
  if (v12 < 0)
  {
    uint64_t v18 = *__error();
    uint64_t v19 = sub_57538();
    uint64_t v20 = _SC_syslog_os_log_mapping(3LL);
    if (__SC_log_enabled(3LL, v19, v20))
    {
      uint64_t v21 = _os_log_pack_size(28LL);
      uint64_t v22 = (char *)&v36 - ((__chkstk_darwin(v21) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      int v23 = __error();
      uint64_t v24 = _os_log_pack_fill( v22,  v21,  *v23,  &dword_0,  "inet6_linklocal_start(%s): socket() failed, %s (%d)",  v36,  v37,  v38);
      uint64_t v25 = strerror(v18);
      *(_DWORD *)uint64_t v24 = 136315650;
      *(void *)(v24 + 4) = a1;
      *(_WORD *)(v24 + 12) = 2080;
      *(void *)(v24 + 14) = v25;
      *(_WORD *)(v24 + 22) = 1024;
      *(_DWORD *)(v24 + 24) = v18;
      __SC_log_send(3LL, v19, v20, v22);
    }
  }

  else
  {
    int v13 = v12;
    if (a4) {
      int v14 = 136;
    }
    else {
      int v14 = 8;
    }
    int v15 = v14 | (a3 == 0);
    if (a5) {
      int v16 = (a3 != 0) | ((a4 == 0) << 7) | 0x200;
    }
    else {
      int v16 = (a3 != 0) | ((a4 == 0) << 7);
    }
    if (a5) {
      int v17 = v15;
    }
    else {
      int v17 = v15 | 0x200;
    }
    sub_33220(v12, a1, v16, v17);
    if ((sub_33440(v13, a1, a2, a4, a6) & 0x80000000) != 0)
    {
      uint64_t v18 = *__error();
      if (*__error() != 6)
      {
        uint64_t v26 = sub_57538();
        uint64_t v27 = _SC_syslog_os_log_mapping(3LL);
        if (__SC_log_enabled(3LL, v26, v27))
        {
          uint64_t v28 = _os_log_pack_size(28LL);
          __int128 v29 = (char *)&v36 - ((__chkstk_darwin(v28) + 15) & 0xFFFFFFFFFFFFFFF0LL);
          __int128 v30 = __error();
          uint64_t v31 = _os_log_pack_fill( v29,  v28,  *v30,  &dword_0,  "siocll_start(%s) failed, %s (%d)",  v36,  v37,  v38);
          __int128 v32 = __error();
          __int128 v33 = strerror(*v32);
          int v34 = *__error();
          *(_DWORD *)uint64_t v31 = 136315650;
          *(void *)(v31 + 4) = a1;
          *(_WORD *)(v31 + 12) = 2080;
          *(void *)(v31 + 14) = v33;
          *(_WORD *)(v31 + 22) = 1024;
          *(_DWORD *)(v31 + 24) = v34;
          __SC_log_send(3LL, v26, v27, v29);
        }
      }
    }

    else
    {
      uint64_t v18 = 0LL;
    }

    close(v13);
  }

  return v18;
}

uint64_t sub_33220(int a1, const char *a2, int a3, int a4)
{
  uint64_t v24 = 0LL;
  __int128 v22 = 0u;
  __int128 v23 = 0u;
  __int128 v21 = 0u;
  strncpy(__dst, a2, 0x10uLL);
  uint64_t result = ioctl(a1, 0xC030694CuLL, __dst);
  if ((_DWORD)result)
  {
    uint64_t v9 = sub_57538();
    uint64_t v10 = _SC_syslog_os_log_mapping(3LL);
    uint64_t result = __SC_log_enabled(3LL, v9, v10);
    if (!(_DWORD)result) {
      return result;
    }
    uint64_t v11 = _os_log_pack_size(22LL);
    int v12 = &__dst[-((__chkstk_darwin(v11) + 15) & 0xFFFFFFFFFFFFFFF0LL)];
    uint64_t v13 = *__error();
    uint64_t v14 = _os_log_pack_fill(v12, v11, v13, &dword_0, "SIOCGIFINFO_IN6(%s) failed, %s");
    goto LABEL_4;
  }

  if (((DWORD1(v22) | a3) & ~a4) != DWORD1(v22))
  {
    DWORD1(v22) = (DWORD1(v22) | a3) & ~a4;
    uint64_t result = ioctl(a1, 0xC0486957uLL, __dst);
    if ((_DWORD)result)
    {
      uint64_t v9 = sub_57538();
      uint64_t v10 = _SC_syslog_os_log_mapping(3LL);
      uint64_t result = __SC_log_enabled(3LL, v9, v10);
      if ((_DWORD)result)
      {
        uint64_t v18 = _os_log_pack_size(22LL);
        int v12 = &__dst[-((__chkstk_darwin(v18) + 15) & 0xFFFFFFFFFFFFFFF0LL)];
        uint64_t v19 = *__error();
        uint64_t v14 = _os_log_pack_fill(v12, v18, v19, &dword_0, "SIOCSIFINFO_FLAGS(%s) failed, %s");
LABEL_4:
        uint64_t v15 = v14;
        int v16 = __error();
        int v17 = strerror(*v16);
        *(_DWORD *)uint64_t v15 = 136315394;
        *(void *)(v15 + 4) = a2;
        *(_WORD *)(v15 + 12) = 2080;
        *(void *)(v15 + 14) = v17;
        return __SC_log_send(3LL, v9, v10, v12);
      }
    }
  }

  return result;
}

uint64_t sub_33440(int a1, char *a2, _OWORD *a3, int a4, int a5)
{
  if (a3 || !a4 || !sub_2BAB8()) {
    return sub_367A0(a1, a2, a3);
  }
  uint64_t v20 = 0LL;
  __int128 v19 = 0u;
  memset(v18, 0, sizeof(v18));
  strncpy((char *)&__dst, a2, 0x10uLL);
  sub_2B8E4(a2, (uint64_t)v18 + 4);
  *((void *)&v19 + 1) = -1LL;
  LOBYTE(v20) = a5;
  uint64_t v9 = sub_57538();
  uint64_t v10 = _SC_syslog_os_log_mapping(6LL);
  if (__SC_log_enabled(6LL, v9, v10))
  {
    uint64_t v11 = _os_log_pack_size(18LL);
    int v12 = (char *)&__dst - ((__chkstk_darwin(v11) + 15) & 0xFFFFFFFFFFFFFFF0LL);
    uint64_t v13 = __error();
    uint64_t v14 = _os_log_pack_fill( v12,  v11,  *v13,  &dword_0,  "ioctl(%s, SIOCLL_CGASTART) collision_count=%d",  __dst,  v17);
    *(_DWORD *)uint64_t v14 = 136315394;
    *(void *)(v14 + 4) = a2;
    *(_WORD *)(v14 + 12) = 1024;
    *(_DWORD *)(v14 + 14) = a5;
    __SC_log_send(6LL, v9, v10, v12);
  }

  return ioctl(a1, 0x805869A0uLL, &__dst);
}

uint64_t sub_33618(const char *a1)
{
  int v2 = socket(30, 2, 0);
  if (v2 < 0)
  {
    uint64_t v4 = *__error();
    uint64_t v5 = sub_57538();
    uint64_t v6 = _SC_syslog_os_log_mapping(3LL);
    if (__SC_log_enabled(3LL, v5, v6))
    {
      uint64_t v7 = _os_log_pack_size(28LL);
      uint64_t v8 = (char *)&v22 - ((__chkstk_darwin(v7) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v9 = __error();
      uint64_t v10 = _os_log_pack_fill( v8,  v7,  *v9,  &dword_0,  "inet6_linklocal_stop(%s): socket() failed, %s (%d)",  v22,  v23,  v24);
      uint64_t v11 = strerror(v4);
      *(_DWORD *)uint64_t v10 = 136315650;
      *(void *)(v10 + 4) = a1;
      *(_WORD *)(v10 + 12) = 2080;
      *(void *)(v10 + 14) = v11;
      *(_WORD *)(v10 + 22) = 1024;
      *(_DWORD *)(v10 + 24) = v4;
      __SC_log_send(3LL, v5, v6, v8);
    }
  }

  else
  {
    int v3 = v2;
    if ((sub_3388C(v2, a1) & 0x80000000) != 0)
    {
      uint64_t v4 = *__error();
      if (*__error() != 6)
      {
        uint64_t v12 = sub_57538();
        uint64_t v13 = _SC_syslog_os_log_mapping(3LL);
        if (__SC_log_enabled(3LL, v12, v13))
        {
          uint64_t v14 = _os_log_pack_size(28LL);
          uint64_t v15 = (char *)&v22 - ((__chkstk_darwin(v14) + 15) & 0xFFFFFFFFFFFFFFF0LL);
          int v16 = __error();
          uint64_t v17 = _os_log_pack_fill( v15,  v14,  *v16,  &dword_0,  "siocll_stop(%s) failed, %s (%d)",  v22,  v23,  v24);
          uint64_t v18 = __error();
          __int128 v19 = strerror(*v18);
          int v20 = *__error();
          *(_DWORD *)uint64_t v17 = 136315650;
          *(void *)(v17 + 4) = a1;
          *(_WORD *)(v17 + 12) = 2080;
          *(void *)(v17 + 14) = v19;
          *(_WORD *)(v17 + 22) = 1024;
          *(_DWORD *)(v17 + 24) = v20;
          __SC_log_send(3LL, v12, v13, v15);
        }
      }
    }

    else
    {
      uint64_t v4 = 0LL;
    }

    close(v3);
  }

  return v4;
}

uint64_t sub_3388C(int a1, const char *a2)
{
  __int128 v29 = 0u;
  __int128 v28 = 0u;
  __int128 v27 = 0u;
  __int128 v26 = 0u;
  __int128 v25 = 0u;
  __int128 v24 = 0u;
  __int128 v23 = 0u;
  __int128 v22 = 0u;
  __int128 v21 = 0u;
  __int128 v20 = 0u;
  __int128 v19 = 0u;
  __int128 v18 = 0u;
  __int128 v17 = 0u;
  __int128 v16 = 0u;
  __int128 v15 = 0u;
  __int128 v14 = 0u;
  __int128 v13 = 0u;
  strncpy(v12, a2, 0x10uLL);
  uint64_t v4 = sub_57538();
  uint64_t v5 = _SC_syslog_os_log_mapping(6LL);
  if (__SC_log_enabled(6LL, v4, v5))
  {
    uint64_t v6 = _os_log_pack_size(12LL);
    uint64_t v7 = &v12[-((__chkstk_darwin(v6) + 15) & 0xFFFFFFFFFFFFFFF0LL) - 8];
    uint64_t v8 = __error();
    uint64_t v9 = _os_log_pack_fill(v7, v6, *v8, &dword_0, "ioctl(%s, SIOCLL_STOP)", v11);
    *(_DWORD *)uint64_t v9 = 136315138;
    *(void *)(v9 + 4) = a2;
    __SC_log_send(6LL, v4, v5, v7);
  }

  return ioctl(a1, 0xC1206983uLL, v12);
}

uint64_t sub_33A24(char *a1, int a2)
{
  int v4 = socket(30, 2, 0);
  if ((v4 & 0x80000000) == 0)
  {
    int v5 = v4;
    if (!a2) {
      goto LABEL_5;
    }
    if (!sub_2BAB8()) {
      goto LABEL_5;
    }
    *(void *)&__int128 v41 = 0LL;
    __int128 v39 = 0u;
    __int128 v40 = 0u;
    __int128 v37 = 0u;
    __int128 v38 = 0u;
    strncpy((char *)&v35, a1, 0x10uLL);
    sub_2BAB0(a1, (uint64_t)&v37 + 4);
    *((void *)&v40 + 1) = -1LL;
    if (ioctl(v5, 0xC05869BCuLL, &v35) < 0)
    {
      uint64_t v6 = *__error();
      if ((_DWORD)v6 == 6) {
        goto LABEL_15;
      }
      uint64_t v23 = sub_57538();
      uint64_t v24 = _SC_syslog_os_log_mapping(3LL);
      uint64_t v31 = _os_log_pack_size(28LL);
      __int128 v26 = (char *)&v35 - ((__chkstk_darwin(v31) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      __int128 v32 = __error();
      uint64_t v33 = _os_log_pack_fill( v26,  v31,  *v32,  &dword_0,  "siocsifcgaprep_in6(%s) failed, %s (%d)",  v35,  v36,  (_DWORD)v37);
      int v34 = strerror(v6);
      *(_DWORD *)uint64_t v33 = 136315650;
      *(void *)(v33 + 4) = a1;
      *(_WORD *)(v33 + 12) = 2080;
      *(void *)(v33 + 14) = v34;
      *(_WORD *)(v33 + 22) = 1024;
      *(_DWORD *)(v33 + 24) = v6;
      uint64_t v29 = 3LL;
    }

    else
    {
LABEL_5:
      __int128 v52 = 0u;
      __int128 v53 = 0u;
      __int128 v50 = 0u;
      __int128 v51 = 0u;
      __int128 v48 = 0u;
      __int128 v49 = 0u;
      __int128 v46 = 0u;
      __int128 v47 = 0u;
      __int128 v44 = 0u;
      __int128 v45 = 0u;
      __int128 v42 = 0u;
      __int128 v43 = 0u;
      __int128 v40 = 0u;
      __int128 v41 = 0u;
      __int128 v38 = 0u;
      __int128 v39 = 0u;
      __int128 v37 = 0u;
      strncpy((char *)&v35, a1, 0x10uLL);
      if (ioctl(v5, 0xC1206984uLL, &v35) < 0)
      {
        uint64_t v6 = *__error();
        if (*__error() != 6)
        {
          uint64_t v14 = sub_57538();
          uint64_t v15 = _SC_syslog_os_log_mapping(3LL);
          if (__SC_log_enabled(3LL, v14, v15))
          {
            uint64_t v16 = _os_log_pack_size(28LL);
            __int128 v17 = (char *)&v35 - ((__chkstk_darwin(v16) + 15) & 0xFFFFFFFFFFFFFFF0LL);
            __int128 v18 = __error();
            uint64_t v19 = _os_log_pack_fill( v17,  v16,  *v18,  &dword_0,  "siocautoconf_start(%s) failed, %s (%d)",  v35,  v36,  (_DWORD)v37);
            __int128 v20 = __error();
            __int128 v21 = strerror(*v20);
            int v22 = *__error();
            *(_DWORD *)uint64_t v19 = 136315650;
            *(void *)(v19 + 4) = a1;
            *(_WORD *)(v19 + 12) = 2080;
            *(void *)(v19 + 14) = v21;
            *(_WORD *)(v19 + 22) = 1024;
            *(_DWORD *)(v19 + 24) = v22;
            __SC_log_send(3LL, v14, v15, v17);
          }
        }
      }

      else
      {
        uint64_t v6 = 0LL;
      }

      uint64_t v23 = sub_57538();
      uint64_t v24 = _SC_syslog_os_log_mapping(6LL);
      uint64_t v25 = _os_log_pack_size(12LL);
      __int128 v26 = (char *)&v35 - ((__chkstk_darwin(v25) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      __int128 v27 = __error();
      uint64_t v28 = _os_log_pack_fill(v26, v25, *v27, &dword_0, "rtadv_enable(%s)", v35);
      *(_DWORD *)uint64_t v28 = 136315138;
      *(void *)(v28 + 4) = a1;
      uint64_t v29 = 6LL;
    }

    __SC_log_send(v29, v23, v24, v26);
LABEL_15:
    close(v5);
    return v6;
  }

  uint64_t v6 = *__error();
  uint64_t v7 = sub_57538();
  uint64_t v8 = _SC_syslog_os_log_mapping(3LL);
  if (__SC_log_enabled(3LL, v7, v8))
  {
    uint64_t v9 = _os_log_pack_size(28LL);
    uint64_t v10 = (char *)&v35 - ((__chkstk_darwin(v9) + 15) & 0xFFFFFFFFFFFFFFF0LL);
    uint64_t v11 = __error();
    uint64_t v12 = _os_log_pack_fill( v10,  v9,  *v11,  &dword_0,  "inet6_rtadv_enable(%s): socket() failed, %s (%d)",  v35,  v36,  (_DWORD)v37);
    __int128 v13 = strerror(v6);
    *(_DWORD *)uint64_t v12 = 136315650;
    *(void *)(v12 + 4) = a1;
    *(_WORD *)(v12 + 12) = 2080;
    *(void *)(v12 + 14) = v13;
    *(_WORD *)(v12 + 22) = 1024;
    *(_DWORD *)(v12 + 24) = v6;
    __SC_log_send(3LL, v7, v8, v10);
  }

  return v6;
}

uint64_t sub_33EC0(const char *a1)
{
  int v2 = socket(30, 2, 0);
  if (v2 < 0)
  {
    uint64_t v4 = *__error();
    uint64_t v5 = sub_57538();
    uint64_t v6 = _SC_syslog_os_log_mapping(3LL);
    if (__SC_log_enabled(3LL, v5, v6))
    {
      uint64_t v7 = _os_log_pack_size(28LL);
      uint64_t v8 = (char *)&v26 - ((__chkstk_darwin(v7) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v9 = __error();
      uint64_t v10 = _os_log_pack_fill( v8,  v7,  *v9,  &dword_0,  "inet6_rtadv_disable(%s): socket() failed, %s (%d)",  v26,  v27,  (_DWORD)v28);
      uint64_t v11 = strerror(v4);
      *(_DWORD *)uint64_t v10 = 136315650;
      *(void *)(v10 + 4) = a1;
      *(_WORD *)(v10 + 12) = 2080;
      *(void *)(v10 + 14) = v11;
      *(_WORD *)(v10 + 22) = 1024;
      *(_DWORD *)(v10 + 24) = v4;
      uint64_t v12 = 3LL;
LABEL_11:
      __SC_log_send(v12, v5, v6, v8);
    }
  }

  else
  {
    int v3 = v2;
    __int128 v43 = 0u;
    __int128 v44 = 0u;
    __int128 v41 = 0u;
    __int128 v42 = 0u;
    __int128 v39 = 0u;
    __int128 v40 = 0u;
    __int128 v37 = 0u;
    __int128 v38 = 0u;
    __int128 v35 = 0u;
    __int128 v36 = 0u;
    __int128 v33 = 0u;
    __int128 v34 = 0u;
    __int128 v31 = 0u;
    __int128 v32 = 0u;
    __int128 v29 = 0u;
    __int128 v30 = 0u;
    __int128 v28 = 0u;
    strncpy((char *)&v26, a1, 0x10uLL);
    if (ioctl(v3, 0xC1206985uLL, &v26) < 0)
    {
      uint64_t v4 = *__error();
      if (*__error() != 6)
      {
        uint64_t v13 = sub_57538();
        uint64_t v14 = _SC_syslog_os_log_mapping(3LL);
        if (__SC_log_enabled(3LL, v13, v14))
        {
          uint64_t v15 = _os_log_pack_size(28LL);
          uint64_t v16 = (char *)&v26 - ((__chkstk_darwin(v15) + 15) & 0xFFFFFFFFFFFFFFF0LL);
          __int128 v17 = __error();
          uint64_t v18 = _os_log_pack_fill( v16,  v15,  *v17,  &dword_0,  "siocautoconf_stop(%s) failed, %s (%d)",  v26,  v27,  (_DWORD)v28);
          uint64_t v19 = __error();
          __int128 v20 = strerror(*v19);
          int v21 = *__error();
          *(_DWORD *)uint64_t v18 = 136315650;
          *(void *)(v18 + 4) = a1;
          *(_WORD *)(v18 + 12) = 2080;
          *(void *)(v18 + 14) = v20;
          *(_WORD *)(v18 + 22) = 1024;
          *(_DWORD *)(v18 + 24) = v21;
          __SC_log_send(3LL, v13, v14, v16);
        }
      }
    }

    else
    {
      uint64_t v4 = 0LL;
    }

    close(v3);
    uint64_t v5 = sub_57538();
    uint64_t v6 = _SC_syslog_os_log_mapping(6LL);
    if (__SC_log_enabled(6LL, v5, v6))
    {
      uint64_t v22 = _os_log_pack_size(12LL);
      uint64_t v8 = (char *)&v26 - ((__chkstk_darwin(v22) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v23 = __error();
      uint64_t v24 = _os_log_pack_fill(v8, v22, *v23, &dword_0, "rtadv_disable(%s)", v26);
      *(_DWORD *)uint64_t v24 = 136315138;
      *(void *)(v24 + 4) = a1;
      uint64_t v12 = 6LL;
      goto LABEL_11;
    }
  }

  return v4;
}

uint64_t sub_34218(const char *a1)
{
  int v2 = socket(30, 2, 0);
  if (v2 < 0)
  {
    int v7 = *__error();
    uint64_t v8 = sub_57538();
    uint64_t v9 = _SC_syslog_os_log_mapping(3LL);
    uint64_t result = __SC_log_enabled(3LL, v8, v9);
    if ((_DWORD)result)
    {
      uint64_t v10 = _os_log_pack_size(38LL);
      uint64_t v11 = (char *)&__dst[-1] - ((__chkstk_darwin(v10) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v12 = __error();
      uint64_t v13 = _os_log_pack_fill( v11,  v10,  *v12,  &dword_0,  "%s(%s): socket() failed, %s (%d)",  v15,  __dst[0],  __dst[1],  (_DWORD)v17);
      uint64_t v14 = strerror(v7);
      *(_DWORD *)uint64_t v13 = 136315906;
      *(void *)(v13 + 4) = "inet6_has_nat64_prefixlist";
      *(_WORD *)(v13 + 12) = 2080;
      *(void *)(v13 + 14) = a1;
      *(_WORD *)(v13 + 22) = 2080;
      *(void *)(v13 + 24) = v14;
      *(_WORD *)(v13 + 32) = 1024;
      *(_DWORD *)(v13 + 34) = v7;
      __SC_log_send(3LL, v8, v9, v11);
      return 0LL;
    }
  }

  else
  {
    int v3 = v2;
    __int128 v21 = 0u;
    __int128 v20 = 0u;
    __int128 v19 = 0u;
    __int128 v18 = 0u;
    __int128 v17 = 0u;
    strncpy((char *)__dst, a1, 0x10uLL);
    int v4 = ioctl(v3, 0xC06069C1uLL, __dst);
    close(v3);
    if (v4) {
      BOOL v5 = 1;
    }
    else {
      BOOL v5 = (_DWORD)v18 == 0;
    }
    return !v5;
  }

  return result;
}

BOOL sub_343E4(const char *a1, __int128 *a2, unsigned __int8 *a3, int a4)
{
  int v8 = socket(30, 2, 0);
  if (v8 < 0)
  {
    uint64_t v26 = sub_57538();
    uint64_t v27 = _SC_syslog_os_log_mapping(3LL);
    if (__SC_log_enabled(3LL, v26, v27))
    {
      uint64_t v28 = _os_log_pack_size(38LL);
      __int128 v29 = (char *)&v42 - ((__chkstk_darwin(v28) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      __int128 v30 = __error();
      uint64_t v31 = _os_log_pack_fill( v29,  v28,  *v30,  &dword_0,  "%s(%s): socket() failed, %s (%d)",  v42,  __dst,  v44,  LODWORD(v45[0]));
      __int128 v32 = __error();
      __int128 v33 = strerror(*v32);
      int v34 = *__error();
      *(_DWORD *)uint64_t v31 = 136315906;
      *(void *)(v31 + 4) = "inet6_set_nat64_prefixlist";
      *(_WORD *)(v31 + 12) = 2080;
      *(void *)(v31 + 14) = a1;
      *(_WORD *)(v31 + 22) = 2080;
      *(void *)(v31 + 24) = v33;
      *(_WORD *)(v31 + 32) = 1024;
      *(_DWORD *)(v31 + 34) = v34;
      __SC_log_send(3LL, v26, v27, v29);
    }

    return 0LL;
  }

  else
  {
    int v9 = v8;
    memset(v45, 0, sizeof(v45));
    strncpy((char *)&__dst, a1, 0x10uLL);
    if (a4 >= 4) {
      int v10 = 4;
    }
    else {
      int v10 = a4;
    }
    if (a4 >= 1)
    {
      uint64_t v11 = v45;
      if (v10 <= 1) {
        uint64_t v12 = 1LL;
      }
      else {
        uint64_t v12 = v10;
      }
      do
      {
        __int128 v13 = *a2++;
        __int128 v14 = v13;
        LODWORD(v13) = *a3++;
        *uint64_t v11 = v14;
        *((_DWORD *)v11 + 4) = v13 >> 3;
        uint64_t v11 = (_OWORD *)((char *)v11 + 20);
        --v12;
      }

      while (v12);
    }

    if (ioctl(v9, 0xC06069C2uLL, &__dst))
    {
      int v15 = *__error();
      uint64_t v16 = sub_57538();
      uint64_t v17 = _SC_syslog_os_log_mapping(3LL);
      if (__SC_log_enabled(3LL, v16, v17))
      {
        uint64_t v18 = _os_log_pack_size(34LL);
        __int128 v19 = (char *)&v42 - ((__chkstk_darwin(v18) + 15) & 0xFFFFFFFFFFFFFFF0LL);
        __int128 v20 = __error();
        uint64_t v21 = _os_log_pack_fill( v19,  v18,  *v20,  &dword_0,  "%s: SIOCSIFNAT64PREFIX(%d) failed, %s (%d)",  v42,  (_DWORD)__dst,  v44,  LODWORD(v45[0]));
        uint64_t v22 = __error();
        uint64_t v23 = strerror(*v22);
        int v24 = *__error();
        *(_DWORD *)uint64_t v21 = 136315906;
        *(void *)(v21 + 4) = a1;
        *(_WORD *)(v21 + 12) = 1024;
        *(_DWORD *)(v21 + 14) = v10;
        *(_WORD *)(v21 + 18) = 2080;
        *(void *)(v21 + 20) = v23;
        *(_WORD *)(v21 + 28) = 1024;
        *(_DWORD *)(v21 + 30) = v24;
        __SC_log_send(3LL, v16, v17, v19);
      }

      BOOL v25 = v15 == 0;
    }

    else
    {
      uint64_t v35 = sub_57538();
      uint64_t v36 = _SC_syslog_os_log_mapping(7LL);
      if (__SC_log_enabled(7LL, v35, v36))
      {
        uint64_t v37 = _os_log_pack_size(18LL);
        __int128 v38 = (char *)&v42 - ((__chkstk_darwin(v37) + 15) & 0xFFFFFFFFFFFFFFF0LL);
        __int128 v39 = __error();
        uint64_t v40 = _os_log_pack_fill( v38,  v37,  *v39,  &dword_0,  "%s: SIOCSIFNAT64PREFIX(%d) success",  v42,  (_DWORD)__dst);
        *(_DWORD *)uint64_t v40 = 136315394;
        *(void *)(v40 + 4) = a1;
        *(_WORD *)(v40 + 12) = 1024;
        *(_DWORD *)(v40 + 14) = v10;
        __SC_log_send(7LL, v35, v36, v38);
      }

      BOOL v25 = 1LL;
    }

    close(v9);
  }

  return v25;
}

uint64_t sub_347B8(int a1, const char *a2, _OWORD *a3)
{
  __int128 v21 = 0u;
  __int128 v20 = 0u;
  __int128 v19 = 0u;
  __int128 v18 = 0u;
  __int128 v17 = 0u;
  __int128 v16 = 0u;
  __int128 v15 = 0u;
  __int128 v14 = 0u;
  __int128 v13 = 0u;
  __int128 v12 = 0u;
  __int128 v11 = 0u;
  __int128 v10 = 0u;
  __int128 v9 = 0u;
  __int128 v8 = 0u;
  __int128 v7 = 0u;
  memset(&__dst[16], 0, 32);
  strncpy(__dst, a2, 0x10uLL);
  if (a3)
  {
    *(_WORD *)&char __dst[16] = 7708;
    *(_OWORD *)&__dst[24] = *a3;
  }

  return ioctl(a1, 0x81206919uLL, __dst);
}

int8x16_t sub_3489C(int8x16_t *a1, int a2)
{
  int8x16_t result = vandq_s8(*a1, v4);
  *a1 = result;
  return result;
}

void *sub_348D8(void *__b, int a2)
{
  int v3 = __b;
  size_t v4 = 0LL;
  *__b = 0LL;
  __b[1] = 0LL;
  if (a2 >= 8)
  {
    size_t v4 = (a2 >> 3) - 1 + 1LL;
    __b = memset(__b, 255, v4);
  }

  if (a2 <= 0) {
    int v5 = -(-a2 & 7);
  }
  else {
    int v5 = a2 & 7;
  }
  if (v5) {
    *((_BYTE *)v3 + v4) = 0xFF00u >> v5;
  }
  return __b;
}

uint64_t sub_3494C(int8x16_t *a1, int a2)
{
  size_t v4 = sub_34A30((size_t *)&v14);
  if (!v4) {
    return 0LL;
  }
  int v5 = v4;
  if (v14 < 1)
  {
LABEL_11:
    uint64_t v11 = 0LL;
  }

  else
  {
    unint64_t v6 = (unint64_t)v4 + v14;
    __int128 v7 = v4;
    while (1)
    {
      unsigned int v8 = *((unsigned __int16 *)v7 + 33);
      if (!a2 || *((unsigned __int16 *)v7 + 32) == a2)
      {
        int8x16_t v13 = *a1;
        sub_348D8(&__b, *((unsigned __int8 *)v7 + 29));
        int8x16_t v9 = vandq_s8(v13, __b);
        if (v9.i64[0] == v7[1] && v9.i64[1] == v7[2]) {
          break;
        }
      }

      __int128 v7 = (void *)((char *)v7 + 28 * v8 + 72);
    }

    uint64_t v11 = *((unsigned __int8 *)v7 + 29);
  }

  free(v5);
  return v11;
}

void *sub_34A30(size_t *a1)
{
  *(_OWORD *)int v5 = xmmword_594D0;
  *a1 = 0LL;
  if (sysctl(v5, 4u, 0LL, &v4, 0LL, 0LL) < 0) {
    return 0LL;
  }
  v4 += 1024LL;
  int v2 = malloc(v4);
  if (sysctl(v5, 4u, v2, &v4, 0LL, 0LL) < 0)
  {
    free(v2);
    return 0LL;
  }

  *a1 = v4;
  return v2;
}

uint64_t sub_34B04(int a1, _DWORD *a2)
{
  size_t v4 = (char *)sub_34A30((size_t *)&v11);
  if (v4)
  {
    if (v11 >= 1)
    {
      uint64_t v5 = 0LL;
      int v6 = 0;
      __int128 v7 = v4;
      while (1)
      {
        int v8 = *((unsigned __int16 *)v7 + 33);
        if (a1)
        {
        }

        else if (!*((_WORD *)v7 + 33))
        {
          goto LABEL_10;
        }

        uint64_t v5 = (v5 + v8);
        ++v6;
LABEL_10:
        v7 += 28 * *((unsigned __int16 *)v7 + 33) + 72;
        if (v7 >= &v4[v11]) {
          goto LABEL_16;
        }
      }
    }

    int v6 = 0;
    uint64_t v5 = 0LL;
LABEL_16:
    free(v4);
  }

  else
  {
    uint64_t v5 = 0LL;
    int v6 = 0;
  }

  *a2 = v6;
  return v5;
}

uint64_t sub_34BBC(int a1, const char *a2, _OWORD *a3, _OWORD *a4, int a5, int a6, int a7, int a8)
{
  uint64_t v20 = 0LL;
  __int128 v19 = 0u;
  __int128 v18 = 0u;
  memset(&__dst[16], 0, 64);
  strncpy(__dst, a2, 0x10uLL);
  int v21 = a7;
  int v22 = a8;
  DWORD1(v19) = a6;
  if (a3)
  {
    *(_WORD *)&char __dst[16] = 7708;
    *(_OWORD *)&__dst[24] = *a3;
  }

  if (a4)
  {
    *(_WORD *)&__dst[44] = 7708;
    *(_OWORD *)&__dst[52] = *a4;
  }

  if (a5)
  {
    sub_348D8(&__b, a5);
    *(_WORD *)&__dst[72] = 7708;
    __int128 v18 = __b;
  }

  return ioctl(a1, 0x8080691AuLL, __dst);
}

uint64_t sub_34CD0(const char *a1)
{
  uint64_t v2 = sub_57538();
  uint64_t v3 = _SC_syslog_os_log_mapping(6LL);
  if (__SC_log_enabled(6LL, v2, v3))
  {
    uint64_t v4 = _os_log_pack_size(12LL);
    uint64_t v5 = (char *)&v9 - ((__chkstk_darwin(v4) + 15) & 0xFFFFFFFFFFFFFFF0LL);
    int v6 = __error();
    uint64_t v7 = _os_log_pack_fill(v5, v4, *v6, &dword_0, "inet6_flush_prefixes(%s)", v9);
    *(_DWORD *)uint64_t v7 = 136315138;
    *(void *)(v7 + 4) = a1;
    __SC_log_send(6LL, v2, v3, v5);
  }

  return sub_34DE8(a1, 0xC120694FuLL);
}

uint64_t sub_34DE8(const char *a1, unint64_t a2)
{
  int v4 = socket(30, 2, 0);
  if (v4 < 0) {
    return *__error();
  }
  int v5 = v4;
  __int128 v25 = 0u;
  __int128 v24 = 0u;
  __int128 v23 = 0u;
  __int128 v22 = 0u;
  __int128 v21 = 0u;
  __int128 v20 = 0u;
  __int128 v19 = 0u;
  __int128 v18 = 0u;
  __int128 v17 = 0u;
  __int128 v16 = 0u;
  __int128 v15 = 0u;
  __int128 v14 = 0u;
  __int128 v13 = 0u;
  __int128 v12 = 0u;
  __int128 v11 = 0u;
  __int128 v10 = 0u;
  __int128 v9 = 0u;
  strncpy(&__dst, a1, 0x10uLL);
  if (ioctl(v5, a2, &__dst) < 0) {
    uint64_t v6 = *__error();
  }
  else {
    uint64_t v6 = 0LL;
  }
  close(v5);
  return v6;
}

uint64_t sub_34F04(const char *a1)
{
  uint64_t v2 = sub_57538();
  uint64_t v3 = _SC_syslog_os_log_mapping(6LL);
  if (__SC_log_enabled(6LL, v2, v3))
  {
    uint64_t v4 = _os_log_pack_size(12LL);
    int v5 = (char *)&v9 - ((__chkstk_darwin(v4) + 15) & 0xFFFFFFFFFFFFFFF0LL);
    uint64_t v6 = __error();
    uint64_t v7 = _os_log_pack_fill(v5, v4, *v6, &dword_0, "inet6_flush_routes(%s)", v9);
    *(_DWORD *)uint64_t v7 = 136315138;
    *(void *)(v7 + 4) = a1;
    __SC_log_send(6LL, v2, v3, v5);
  }

  return sub_34DE8(a1, 0xC1206950uLL);
}

uint64_t sub_3501C(const char *a1, uint64_t a2)
{
  __int128 v52 = 0u;
  __int128 v53 = 0u;
  __int128 v50 = 0u;
  __int128 v51 = 0u;
  __int128 v48 = 0u;
  __int128 v49 = 0u;
  __int128 v46 = 0u;
  __int128 v47 = 0u;
  __int128 v44 = 0u;
  __int128 v45 = 0u;
  __int128 v42 = 0u;
  __int128 v43 = 0u;
  __int128 v40 = 0u;
  __int128 v41 = 0u;
  __int128 v38 = 0u;
  __int128 v39 = 0u;
  __int128 v36 = 0u;
  __int128 v37 = 0u;
  int v4 = socket(30, 2, 0);
  if (v4 < 0)
  {
    uint64_t v6 = *__error();
    uint64_t v7 = sub_57538();
    uint64_t v8 = _SC_syslog_os_log_mapping(3LL);
    if (__SC_log_enabled(3LL, v7, v8))
    {
      uint64_t v9 = _os_log_pack_size(22LL);
      __int128 v10 = (char *)&v36 - ((__chkstk_darwin(v9) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      __int128 v11 = __error();
      uint64_t v12 = _os_log_pack_fill( v10,  v9,  *v11,  &dword_0,  "socket(%s) failed, %s",  (const char *)v36,  *((const char **)&v36 + 1));
      __int128 v13 = __error();
      __int128 v14 = strerror(*v13);
      *(_DWORD *)uint64_t v12 = 136315394;
      *(void *)(v12 + 4) = a1;
      *(_WORD *)(v12 + 12) = 2080;
      *(void *)(v12 + 14) = v14;
      __SC_log_send(3LL, v7, v8, v10);
    }

    __int128 v15 = v48;
    *(_OWORD *)(a2 + 160) = v47;
    *(_OWORD *)(a2 + 176) = v15;
    *(void *)(a2 + 192) = v49;
    __int128 v16 = v44;
    *(_OWORD *)(a2 + 96) = v43;
    *(_OWORD *)(a2 + 112) = v16;
    __int128 v17 = v46;
    *(_OWORD *)(a2 + 128) = v45;
    *(_OWORD *)(a2 + 144) = v17;
    __int128 v18 = v40;
    *(_OWORD *)(a2 + 32) = v39;
    *(_OWORD *)(a2 + 48) = v18;
    __int128 v19 = v42;
    *(_OWORD *)(a2 + 64) = v41;
    *(_OWORD *)(a2 + 80) = v19;
    __int128 v20 = v38;
    *(_OWORD *)a2 = v37;
    *(_OWORD *)(a2 + 16) = v20;
  }

  else
  {
    int v5 = v4;
    strncpy((char *)&v36, a1, 0x10uLL);
    if (ioctl(v5, 0xC1206953uLL, &v36) < 0)
    {
      uint64_t v6 = *__error();
      uint64_t v21 = sub_57538();
      uint64_t v22 = _SC_syslog_os_log_mapping(3LL);
      if (__SC_log_enabled(3LL, v21, v22))
      {
        uint64_t v23 = _os_log_pack_size(22LL);
        __int128 v24 = (char *)&v36 - ((__chkstk_darwin(v23) + 15) & 0xFFFFFFFFFFFFFFF0LL);
        __int128 v25 = __error();
        uint64_t v26 = _os_log_pack_fill( v24,  v23,  *v25,  &dword_0,  "SIOCGIFSTAT_IN6(%s) failed, %s",  (const char *)v36,  *((const char **)&v36 + 1));
        uint64_t v27 = __error();
        uint64_t v28 = strerror(*v27);
        *(_DWORD *)uint64_t v26 = 136315394;
        *(void *)(v26 + 4) = a1;
        *(_WORD *)(v26 + 12) = 2080;
        *(void *)(v26 + 14) = v28;
        __SC_log_send(3LL, v21, v22, v24);
      }
    }

    else
    {
      uint64_t v6 = 0LL;
    }

    __int128 v29 = v48;
    *(_OWORD *)(a2 + 160) = v47;
    *(_OWORD *)(a2 + 176) = v29;
    *(void *)(a2 + 192) = v49;
    __int128 v30 = v44;
    *(_OWORD *)(a2 + 96) = v43;
    *(_OWORD *)(a2 + 112) = v30;
    __int128 v31 = v46;
    *(_OWORD *)(a2 + 128) = v45;
    *(_OWORD *)(a2 + 144) = v31;
    __int128 v32 = v40;
    *(_OWORD *)(a2 + 32) = v39;
    *(_OWORD *)(a2 + 48) = v32;
    __int128 v33 = v42;
    *(_OWORD *)(a2 + 64) = v41;
    *(_OWORD *)(a2 + 80) = v33;
    __int128 v34 = v38;
    *(_OWORD *)a2 = v37;
    *(_OWORD *)(a2 + 16) = v34;
    close(v5);
  }

  return v6;
}

uint64_t sub_35324(uint64_t a1)
{
  return sub_3532C(a1, 1);
}

uint64_t sub_3532C(uint64_t a1, int a2)
{
  int v4 = socket(30, 2, 0);
  if ((v4 & 0x80000000) == 0)
  {
    int v5 = v4;
    uint64_t v6 = sub_57538();
    uint64_t v7 = _SC_syslog_os_log_mapping(6LL);
    int v8 = __SC_log_enabled(6LL, v6, v7);
    if (a2)
    {
      if (v8)
      {
        uint64_t v9 = _os_log_pack_size(12LL);
        __int128 v10 = (char *)&v39 - ((__chkstk_darwin(v9) + 15) & 0xFFFFFFFFFFFFFFF0LL);
        __int128 v11 = __error();
        uint64_t v12 = _os_log_pack_fill(v10, v9, *v11, &dword_0, "ioctl(%s, SIOCCLAT46_START)", (const char *)v39);
        *(_DWORD *)uint64_t v12 = 136315138;
        *(void *)(v12 + 4) = a1;
        __SC_log_send(6LL, v6, v7, v10);
      }

      __int128 v55 = 0u;
      __int128 v56 = 0u;
      __int128 v53 = 0u;
      __int128 v54 = 0u;
      __int128 v51 = 0u;
      __int128 v52 = 0u;
      __int128 v49 = 0u;
      __int128 v50 = 0u;
      __int128 v47 = 0u;
      __int128 v48 = 0u;
      __int128 v45 = 0u;
      __int128 v46 = 0u;
      __int128 v43 = 0u;
      __int128 v44 = 0u;
      __int128 v41 = 0u;
      __int128 v42 = 0u;
      __int128 v39 = 0u;
      __int128 v40 = 0u;
      __strlcpy_chk(&v39, a1, 16LL, 16LL);
      if (ioctl(v5, 0xC12069BDuLL, &v39) < 0)
      {
        uint64_t v13 = sub_57538();
        uint64_t v14 = _SC_syslog_os_log_mapping(5LL);
        if (__SC_log_enabled(5LL, v13, v14))
        {
          uint64_t v15 = _os_log_pack_size(28LL);
          __int128 v16 = (char *)&v39 - ((__chkstk_darwin(v15) + 15) & 0xFFFFFFFFFFFFFFF0LL);
          uint64_t v17 = *__error();
          uint64_t v18 = _os_log_pack_fill(v16, v15, v17, &dword_0, "ioctl(%s, SIOCCLAT46_START), failed, %s (%d)");
LABEL_16:
          uint64_t v34 = v18;
          uint64_t v35 = __error();
          __int128 v36 = strerror(*v35);
          int v37 = *__error();
          *(_DWORD *)uint64_t v34 = 136315650;
          *(void *)(v34 + 4) = a1;
          *(_WORD *)(v34 + 12) = 2080;
          *(void *)(v34 + 14) = v36;
          *(_WORD *)(v34 + 22) = 1024;
          *(_DWORD *)(v34 + 24) = v37;
          __SC_log_send(5LL, v13, v14, v16);
          goto LABEL_17;
        }

        goto LABEL_17;
      }
    }

    else
    {
      if (v8)
      {
        uint64_t v28 = _os_log_pack_size(12LL);
        __int128 v29 = (char *)&v39 - ((__chkstk_darwin(v28) + 15) & 0xFFFFFFFFFFFFFFF0LL);
        __int128 v30 = __error();
        uint64_t v31 = _os_log_pack_fill(v29, v28, *v30, &dword_0, "ioctl(%s, SIOCCLAT46_STOP)", (const char *)v39);
        *(_DWORD *)uint64_t v31 = 136315138;
        *(void *)(v31 + 4) = a1;
        __SC_log_send(6LL, v6, v7, v29);
      }

      __int128 v55 = 0u;
      __int128 v56 = 0u;
      __int128 v53 = 0u;
      __int128 v54 = 0u;
      __int128 v51 = 0u;
      __int128 v52 = 0u;
      __int128 v49 = 0u;
      __int128 v50 = 0u;
      __int128 v47 = 0u;
      __int128 v48 = 0u;
      __int128 v45 = 0u;
      __int128 v46 = 0u;
      __int128 v43 = 0u;
      __int128 v44 = 0u;
      __int128 v41 = 0u;
      __int128 v42 = 0u;
      __int128 v39 = 0u;
      __int128 v40 = 0u;
      __strlcpy_chk(&v39, a1, 16LL, 16LL);
      if (ioctl(v5, 0xC12069BEuLL, &v39) < 0)
      {
        uint64_t v13 = sub_57538();
        uint64_t v14 = _SC_syslog_os_log_mapping(5LL);
        if (__SC_log_enabled(5LL, v13, v14))
        {
          uint64_t v32 = _os_log_pack_size(28LL);
          __int128 v16 = (char *)&v39 - ((__chkstk_darwin(v32) + 15) & 0xFFFFFFFFFFFFFFF0LL);
          uint64_t v33 = *__error();
          uint64_t v18 = _os_log_pack_fill(v16, v32, v33, &dword_0, "ioctl(%s, SIOCCLAT46_STOP), failed, %s (%d)");
          goto LABEL_16;
        }

LABEL_17:
        uint64_t v19 = *__error();
        goto LABEL_18;
      }
    }

    uint64_t v19 = 0LL;
LABEL_18:
    close(v5);
    return v19;
  }

  uint64_t v19 = *__error();
  uint64_t v20 = sub_57538();
  uint64_t v21 = _SC_syslog_os_log_mapping(3LL);
  if (__SC_log_enabled(3LL, v20, v21))
  {
    uint64_t v22 = _os_log_pack_size(22LL);
    uint64_t v23 = (char *)&v39 - ((__chkstk_darwin(v22) + 15) & 0xFFFFFFFFFFFFFFF0LL);
    __int128 v24 = __error();
    uint64_t v25 = _os_log_pack_fill( v23,  v22,  *v24,  &dword_0,  "socket(%s) failed, %s",  (const char *)v39,  *((const char **)&v39 + 1));
    uint64_t v26 = __error();
    uint64_t v27 = strerror(*v26);
    *(_DWORD *)uint64_t v25 = 136315394;
    *(void *)(v25 + 4) = a1;
    *(_WORD *)(v25 + 12) = 2080;
    *(void *)(v25 + 14) = v27;
    __SC_log_send(3LL, v20, v21, v23);
  }

  return v19;
}

uint64_t sub_357E8(uint64_t a1)
{
  return sub_3532C(a1, 0);
}

uint64_t sub_357F0(int a1, uint64_t a2)
{
  *(void *)a2 = 0LL;
  *(void *)(a2 + 8) = 0LL;
  uint64_t v3 = (char *)sub_3591C(a1, &v15);
  if (!v3) {
    return 0LL;
  }
  int v4 = v3;
  if (v15 < 1)
  {
LABEL_15:
    uint64_t v8 = 0LL;
  }

  else
  {
    int v5 = (unsigned __int16 *)&v3[v15];
    uint64_t v6 = (unsigned __int16 *)v3;
    while (1)
    {
      if (*((_BYTE *)v6 + 2) == 5 && *((_BYTE *)v6 + 3) == 12)
      {
        v13[0] = *((_DWORD *)v6 + 1);
        int v7 = sub_55D70((unsigned __int8 *)v6 + 20, (unint64_t)v6 + *v6, v13);
        if (v7)
        {
          int v9 = v7;
          __int128 v10 = __stderrp;
          __int128 v11 = strerror(v7);
          fprintf(v10, "couldn't extract rt_addrinfo %s (%d)\n", v11, v9);
          goto LABEL_15;
        }

        if (v14 && *v14 >= 0x1Cu && v14[8] == 254 && (v14[9] & 0xC0) == 0x80) {
          break;
        }
      }

      uint64_t v6 = (unsigned __int16 *)((char *)v6 + *v6);
      if (v6 >= v5) {
        goto LABEL_15;
      }
    }

    *(_OWORD *)a2 = *(_OWORD *)(v14 + 8);
    *(_WORD *)(a2 + 2) = 0;
    uint64_t v8 = 1LL;
  }

  free(v4);
  return v8;
}

void *sub_3591C(int a1, _DWORD *a2)
{
  size_t v9 = 0LL;
  *(_OWORD *)__int128 v10 = xmmword_594C0;
  int v11 = 3;
  int v12 = a1;
  *a2 = 0;
  if (sysctl(v10, 6u, 0LL, &v9, 0LL, 0LL) < 0)
  {
    int v4 = __stderrp;
    int v5 = __error();
    strerror(*v5);
    fprintf(v4, "sysctl() size failed: %s");
    return 0LL;
  }

  v9 *= 2LL;
  uint64_t v3 = malloc(v9);
  if (sysctl(v10, 6u, v3, &v9, 0LL, 0LL) < 0)
  {
    free(v3);
    uint64_t v6 = __stderrp;
    int v7 = __error();
    strerror(*v7);
    fprintf(v6, "sysctl() failed: %s");
    return 0LL;
  }

  *a2 = v9;
  return v3;
}

void sub_35A4C(uint64_t a1, int a2)
{
  uint64_t v3 = (char *)sub_3591C(a2, &v37);
  if (!v3)
  {
    uint64_t v13 = 0LL;
    int v12 = 0LL;
    int v11 = 0;
    goto LABEL_21;
  }

  int v4 = (unsigned __int16 *)v3;
  int v5 = v37;
  __src[0] = 0;
  if (v37 < 1) {
    goto LABEL_17;
  }
  int v6 = 0;
  int v7 = (unsigned __int16 *)&v3[v37];
  uint64_t v8 = (unsigned __int16 *)v3;
  do
  {
    if (*((_BYTE *)v8 + 2) == 5)
    {
      int v9 = *((unsigned __int8 *)v8 + 3);
      if (v9 == 12)
      {
        ++v6;
      }

      else if (v9 == 14 && (v8[2] & 0x10) != 0)
      {
        __memmove_chk(__src, v8 + 60);
        __src[*((unsigned __int8 *)v8 + 117)] = 0;
      }
    }

    uint64_t v8 = (unsigned __int16 *)((char *)v8 + *v8);
  }

  while (v8 < v7);
  if (!__src[0] || v6 == 0)
  {
LABEL_17:
    int v11 = 0;
    int v12 = 0LL;
LABEL_18:
    uint64_t v13 = 0LL;
    goto LABEL_19;
  }

  if (v6 < 6)
  {
    int v12 = (_DWORD *)(a1 + 12);
  }

  else
  {
    int v12 = malloc(32LL * v6);
    if (!v12)
    {
      int v11 = 0;
      goto LABEL_18;
    }
  }

  if (v5 < 1)
  {
    uint64_t v13 = 0LL;
    int v30 = -1;
    goto LABEL_74;
  }

  int v11 = 0;
  uint64_t v34 = 0LL;
  int v35 = -1;
  uint64_t v14 = v4;
  do
  {
    if (*((_BYTE *)v14 + 2) != 5 || *((_BYTE *)v14 + 3) != 12) {
      goto LABEL_70;
    }
    v36[0] = *((_DWORD *)v14 + 1);
    int v15 = sub_55D70((unsigned __int8 *)v14 + 20, (unint64_t)v14 + *v14, v36);
    if (v15)
    {
      int v31 = v15;
      uint64_t v32 = __stderrp;
      uint64_t v33 = strerror(v15);
      fprintf(v32, "couldn't extract rt_addrinfo %s (%d)\n", v33, v31);
      uint64_t v13 = v34;
      int v30 = v35;
      if ((v35 & 0x80000000) == 0) {
        goto LABEL_78;
      }
      goto LABEL_19;
    }

    uint64_t v16 = 0LL;
    uint64_t v17 = (unsigned __int8 *)&v12[8 * v11];
    char v18 = 1;
    do
    {
      while (1)
      {
        uint64_t v19 = *(unsigned __int8 **)&v36[2 * v16 + 2];
        if (!v19 || *v19 < 0x1Cu) {
          goto LABEL_56;
        }
        if ((_DWORD)v16 == 2) {
          break;
        }
        if ((_DWORD)v16 != 5) {
          goto LABEL_56;
        }
        char v18 = 0;
        *(_OWORD *)uint64_t v17 = *(_OWORD *)(v19 + 8);
        if (++v16 == 8) {
          goto LABEL_58;
        }
      }

      uint64_t v20 = 0LL;
      int v21 = 0;
      uint64_t v22 = v19 + 8;
      while (v22[v20] == 255)
      {
        ++v20;
        v21 += 8;
        if (v20 == 16)
        {
          int v21 = 128;
          goto LABEL_55;
        }
      }

      if ((_DWORD)v20 != 16)
      {
        int v23 = 0;
        unsigned int v24 = v22[v20];
        int v25 = v21 + 7;
        while (1)
        {
          int v26 = v23 + 7;
          if (((v24 >> (v23 + 7)) & 1) == 0) {
            break;
          }
          if (--v23 == -7)
          {
LABEL_50:
            uint64_t v27 = v19 + 9;
            while (v20 != 15)
            {
              if (v27[v20++]) {
                goto LABEL_53;
              }
            }

            int v21 = v25;
            goto LABEL_55;
          }
        }

        int v25 = v21 - v23;
        while (((v24 >> v26) & 1) == 0)
        {
          if (!--v26) {
            goto LABEL_50;
          }
        }

LABEL_55:
      *((_DWORD *)v17 + 4) = v21;
LABEL_56:
      ++v16;
    }

    while (v16 != 8);
    if ((v18 & 1) != 0) {
      goto LABEL_70;
    }
LABEL_58:
    if ((v35 & 0x80000000) == 0 || (int v35 = socket(30, 2, 0), (v35 & 0x80000000) == 0))
    {
      __int128 v54 = 0u;
      __int128 v55 = 0u;
      __int128 v52 = 0u;
      __int128 v53 = 0u;
      __int128 v50 = 0u;
      __int128 v51 = 0u;
      __int128 v48 = 0u;
      __int128 v49 = 0u;
      __int128 v46 = 0u;
      __int128 v47 = 0u;
      __int128 v44 = 0u;
      __int128 v45 = 0u;
      __int128 v42 = 0u;
      __int128 v43 = 0u;
      __int128 v41 = 0u;
      memset(v40, 0, sizeof(v40));
      strncpy(__dst, __src, 0x10uLL);
      LOWORD(v40[0]) = 7708;
      *(_OWORD *)&v40[1] = *(_OWORD *)v17;
      if ((ioctl(v35, 0xC1206949uLL, __dst) & 0x80000000) == 0) {
        v12[8 * v11 + 5] = v40[0];
      }
      __int128 v54 = 0u;
      __int128 v55 = 0u;
      __int128 v52 = 0u;
      __int128 v53 = 0u;
      __int128 v50 = 0u;
      __int128 v51 = 0u;
      __int128 v48 = 0u;
      __int128 v49 = 0u;
      __int128 v46 = 0u;
      __int128 v47 = 0u;
      __int128 v44 = 0u;
      __int128 v45 = 0u;
      __int128 v42 = 0u;
      __int128 v43 = 0u;
      __int128 v41 = 0u;
      memset(v40, 0, sizeof(v40));
      strncpy(__dst, __src, 0x10uLL);
      LOWORD(v40[0]) = 7708;
      *(_OWORD *)&v40[1] = *(_OWORD *)v17;
      if ((ioctl(v35, 0xC1206951uLL, __dst) & 0x80000000) == 0) {
        *(void *)&v12[8 * v11 + 6] = v40[2];
      }
    }

    if (*v17 == 254 && (v17[1] & 0xC0) == 0x80)
    {
      *((_WORD *)v17 + 1) = 0;
      __int128 v29 = v34;
      if (!v34) {
        __int128 v29 = (char *)&v12[8 * v11];
      }
      uint64_t v34 = v29;
    }

    ++v11;
LABEL_70:
    uint64_t v14 = (unsigned __int16 *)((char *)v14 + *v14);
  }

  while (v14 < v7);
  uint64_t v13 = v34;
  int v30 = v35;
  if (!v11)
  {
LABEL_74:
    if (v12 != (_DWORD *)(a1 + 12)) {
      free(v12);
    }
    int v12 = 0LL;
    int v11 = 0;
  }

  if ((v30 & 0x80000000) == 0) {
LABEL_78:
  }
    close(v30);
LABEL_19:
  free(v4);
LABEL_21:
  *(void *)a1 = v12;
  *(_DWORD *)(a1 + 8) = v11;
  *(void *)(a1 + 176) = v13;
}

      CFStringAppendFormat(a1, 0LL, @"\n", v33, v34, v37);
      return;
    case 7u:
      if (a3 <= 0xB)
      {
        CFStringAppendFormat(a1, 0LL, @" IA_NA option is too short %d < %d\n", a3, 12LL, v37);
        return;
      }

      int v26 = a3 - 12;
      CFStringAppendFormat( a1,  0LL,  @" IA_NA IAID=%d T1=%d T2=%d",  bswap32(*(_DWORD *)a4),  bswap32(*((_DWORD *)a4 + 1)),  bswap32(*((_DWORD *)a4 + 2)));
      goto LABEL_48;
    case 8u:
      sub_58208(a1, (uint64_t)a4, a3, a5);
      return;
    case 9u:
      if (a3 > 1)
      {
        uint64_t v27 = bswap32(*a4);
        uint64_t v28 = HIWORD(v27);
        __int128 v29 = (a3 - 2);
        int v30 = sub_583E0(HIWORD(v27));
        if ((_DWORD)v29) {
          CFStringAppendFormat(a1, 0LL, @" STATUS_CODE %s (%d) '%.*s'\n", v30, v28, v29, a4 + 1);
        }
        else {
          CFStringAppendFormat(a1, 0LL, @" STATUS_CODE %s (%d)\n", v30, v28, v37);
        }
      }

      else
      {
        CFStringAppendFormat(a1, 0LL, @" STATUS_CODE option is too short %d < %d\n", a3, 2LL, v37);
      }

      return;
    case 0xAu:
      *(void *)__int128 v39 = CFStringCreateWithBytes(kCFAllocatorDefault, (const UInt8 *)a4, a3, 0x8000100u, 0);
      CFStringAppendFormat(a1, 0LL, @" %@\n", *(void *)v39);
      sub_4FA18((const void **)v39);
      return;
    case 0xBu:
      if (a3 > 0xB)
      {
        int v26 = a3 - 12;
        CFStringAppendFormat( a1,  0LL,  @" IA_PD IAID=%d T1=%d T2=%d",  bswap32(*(_DWORD *)a4),  bswap32(*((_DWORD *)a4 + 1)),  bswap32(*((_DWORD *)a4 + 2)));
LABEL_48:
        if (v26)
        {
          int v31 = sub_578CC(a4 + 6, v26, v39);
          if (v31)
          {
            uint64_t v32 = v31;
            CFStringAppendFormat(a1, 0LL, @" ");
            sub_57A2C(a1, v32, (a5 + 1));
            sub_55598((uint64_t)v32);
            free(v32);
          }

          else
          {
            CFStringAppendFormat(a1, 0LL, @" options invalid:\n\t%s\n", v39, v36, v38);
          }
        }

        else
        {
LABEL_51:
          CFStringAppendFormat(a1, 0LL, @"\n");
        }
      }

      else
      {
        CFStringAppendFormat(a1, 0LL, @" IA_PD option is too short %d < %d\n", a3, 12LL, v37);
      }

      return;
    case 0xCu:
      sub_582F0(a1, (uint64_t)a4, a3, a5);
      return;
    default:
      goto LABEL_53;
  }

__CFString *sub_35EFC(uint64_t a1)
{
  CFMutableDictionaryRef Mutable = CFStringCreateMutable(0LL, 0LL);
  CFStringAppendFormat(Mutable, 0LL, @"{");
  if (*(int *)(a1 + 8) >= 1)
  {
    int v3 = 0;
    int v4 = *(unsigned int **)a1;
    do
    {
      sub_36040(v4[6], __str);
      sub_36040(v4[7], v9);
      if (v3) {
        int v5 = "";
      }
      else {
        int v5 = "\n";
      }
      int v6 = inet_ntop(30, v4, v10, 0x2Eu);
      CFStringAppendFormat( Mutable,  0LL,  @"%s%s/%d flags 0x%04x vltime=%s pltime=%s\n",  v5,  v6,  v4[4],  v4[5],  __str,  v9);
      ++v3;
      v4 += 8;
    }

    while (v3 < *(_DWORD *)(a1 + 8));
  }

  CFStringAppendFormat(Mutable, 0LL, @"}");
  return Mutable;
}

uint64_t sub_36040(uint64_t result, char *__str)
{
  if ((_DWORD)result != -1) {
    return snprintf(__str, 0x20uLL, "%u", result);
  }
  strcpy(__str, "infinity");
  return result;
}

void sub_36090(uint64_t a1)
{
  uint64_t v2 = *(void **)a1;
  if (v2)
  {
    *(void *)a1 = 0LL;
    *(_DWORD *)(a1 + 8) = 0;
    *(void *)(a1 + 176) = 0LL;
  }

uint64_t sub_360D0(uint64_t result)
{
  *(void *)int8x16_t result = 0LL;
  *(_DWORD *)(result + 8) = 0;
  *(void *)(result + 176) = 0LL;
  return result;
}

BOOL sub_360E0(uint64_t *a1, void *a2)
{
  int v2 = *((_DWORD *)a1 + 2);
  if (v2 < 1) {
    return 0LL;
  }
  for (uint64_t i = *a1; *(void *)i != *a2 || *(void *)(i + 8) != a2[1]; i += 32LL)
  {
    if (!--v2) {
      return 0LL;
    }
  }

  return (*(_WORD *)(i + 20) & 0x206) == 0;
}

uint64_t sub_3612C(uint64_t *a1, uint64_t a2)
{
  int v2 = *((_DWORD *)a1 + 2);
  if (v2 < 1) {
    return 0LL;
  }
  for (uint64_t i = *a1; ; i += 32LL)
  {
    BOOL v4 = *(void *)i == *(void *)a2 && *(void *)(i + 8) == *(void *)(a2 + 8);
    if (v4 && *(_DWORD *)(i + 16) == *(_DWORD *)(a2 + 16)) {
      break;
    }
    if (!--v2) {
      return 0LL;
    }
  }

  return 1LL;
}

uint64_t sub_3617C(uint64_t result)
{
  if (result) {
    return *(void *)(result + 176);
  }
  return result;
}

uint64_t sub_36188(int a1)
{
  if (a1)
  {
    BOOL v1 = sub_369EC("net.route.verbose", 2, &dword_6C23C);
    char v2 = dword_6C23C != 2 && v1;
    byte_6C240 = v2;
    uint64_t result = sub_369EC("net.inet6.icmp6.nd6_debug", 2, &dword_6C244);
    if (dword_6C244 == 2) {
      char v4 = 0;
    }
    else {
      char v4 = result;
    }
    byte_6C248 = v4;
  }

  else
  {
    sub_36244("net.route.verbose", dword_6C23C, byte_6C240);
    return sub_36244("net.inet6.icmp6.nd6_debug", dword_6C244, byte_6C248);
  }

  return result;
}

uint64_t sub_36244(const char *a1, int a2, int a3)
{
  if (a3) {
    return sub_369EC(a1, a2, (int *)&v11 + 1);
  }
  uint64_t v5 = sub_57538();
  uint64_t v6 = _SC_syslog_os_log_mapping(7LL);
  uint64_t result = __SC_log_enabled(7LL, v5, v6);
  if ((_DWORD)result)
  {
    uint64_t v7 = _os_log_pack_size(12LL);
    uint64_t v8 = (char *)&v11 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0LL);
    int v9 = __error();
    uint64_t v10 = _os_log_pack_fill(v8, v7, *v9, &dword_0, "sysctl %s not modified", v11);
    *(_DWORD *)uint64_t v10 = 136315138;
    *(void *)(v10 + 4) = a1;
    return __SC_log_send(7LL, v5, v6, v8);
  }

  return result;
}

void *sub_36360(uint64_t a1, _DWORD *a2)
{
  HIDWORD(v36) = 0;
  int v4 = socket(2, 2, 0);
  if (v4 < 0)
  {
    uint64_t v15 = sub_57538();
    uint64_t v16 = _SC_syslog_os_log_mapping(3LL);
    if (__SC_log_enabled(3LL, v15, v16))
    {
      uint64_t v17 = _os_log_pack_size(18LL);
      char v18 = (char *)&v36 - ((__chkstk_darwin(v17) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v19 = __error();
      uint64_t v20 = _os_log_pack_fill( v18,  v17,  *v19,  &dword_0,  "protolist_copy: socket failed, %s (%d)",  v36,  v37);
      int v21 = __error();
      uint64_t v22 = strerror(*v21);
      int v23 = *__error();
      *(_DWORD *)uint64_t v20 = 136315394;
      *(void *)(v20 + 4) = v22;
      *(_WORD *)(v20 + 12) = 1024;
      *(_DWORD *)(v20 + 14) = v23;
      __SC_log_send(3LL, v15, v16, v18);
    }

    int v24 = 0;
    goto LABEL_17;
  }

  int v5 = v4;
  if (sub_366E8(v4, a1, 0LL, (_DWORD *)&v36 + 1))
  {
    uint64_t v6 = sub_57538();
    uint64_t v7 = _SC_syslog_os_log_mapping(3LL);
    if (__SC_log_enabled(3LL, v6, v7))
    {
      uint64_t v8 = _os_log_pack_size(18LL);
      int v9 = (char *)&v36 - ((__chkstk_darwin(v8) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v10 = __error();
      uint64_t v11 = _os_log_pack_fill(v9, v8, *v10, &dword_0, "SIOCGIFPROTOLIST failed: %s (%d)", v36, v37);
      int v12 = __error();
      uint64_t v13 = strerror(*v12);
      int v14 = *__error();
      *(_DWORD *)uint64_t v11 = 136315394;
      *(void *)(v11 + 4) = v13;
      *(_WORD *)(v11 + 12) = 1024;
      *(_DWORD *)(v11 + 14) = v14;
      __SC_log_send(3LL, v6, v7, v9);
    }

    goto LABEL_13;
  }

  if (!HIDWORD(v36))
  {
LABEL_13:
    int v24 = 0;
    int v25 = 0LL;
    goto LABEL_14;
  }

  int v25 = malloc(4LL * HIDWORD(v36));
  if (sub_366E8(v5, a1, (uint64_t)v25, (_DWORD *)&v36 + 1))
  {
    uint64_t v26 = sub_57538();
    uint64_t v27 = _SC_syslog_os_log_mapping(3LL);
    if (__SC_log_enabled(3LL, v26, v27))
    {
      uint64_t v28 = _os_log_pack_size(18LL);
      __int128 v29 = (char *)&v36 - ((__chkstk_darwin(v28) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      int v30 = __error();
      uint64_t v31 = _os_log_pack_fill(v29, v28, *v30, &dword_0, "SIOCGIFPROTOLIST failed#2: %s (%d)", v36, v37);
      uint64_t v32 = __error();
      uint64_t v33 = strerror(*v32);
      int v34 = *__error();
      *(_DWORD *)uint64_t v31 = 136315394;
      *(void *)(v31 + 4) = v33;
      *(_WORD *)(v31 + 12) = 1024;
      *(_DWORD *)(v31 + 14) = v34;
      __SC_log_send(3LL, v26, v27, v29);
    }

    int v24 = 0;
  }

  else
  {
    int v24 = HIDWORD(v36);
  }

LABEL_14:
  close(v5);
  if (v25 && !v24)
  {
    free(v25);
LABEL_17:
    int v25 = 0LL;
  }

  *a2 = v24;
  return v25;
}

    close(v6);
    if (v9)
    {
      __int128 v48 = nullsub_1(v2);
      sub_3BF14(v48, v9);
    }

    return 0LL;
  }

  uint64_t v65 = 0LL;
  uint64_t v37 = nullsub_1(v2);
  sub_31710(v6, v37, &v65);
  if ((v65 & 0x1000) == 0)
  {
    __int128 v38 = nullsub_1(v2);
    if (sub_35324(v38))
    {
      __int128 v39 = sub_57538();
      __int128 v40 = _SC_syslog_os_log_mapping(3LL);
      if (__SC_log_enabled(3LL, v39, v40))
      {
        __int128 v41 = _os_log_pack_size(12LL);
        __int128 v42 = (char *)&v62 - ((__chkstk_darwin(v41) + 15) & 0xFFFFFFFFFFFFFFF0LL);
        __int128 v43 = __error();
        __int128 v44 = _os_log_pack_fill(v42, v41, *v43, &dword_0, "RTADV %s: failed to enable CLAT46", v62);
        __int128 v45 = nullsub_1(v2);
        *(_DWORD *)__int128 v44 = 136315138;
        *(void *)(v44 + 4) = v45;
        __SC_log_send(3LL, v39, v40, v42);
      }

      __int128 v46 = (const char *)nullsub_1(v2);
      sub_326AC(v6, v46, v67);
      sub_154A8(a1);
      __int128 v47 = sub_54F6C(v2);
      sub_37000(v47, 0, v67);
      goto LABEL_14;
    }
  }

  __int128 v50 = sub_57538();
  __int128 v51 = _SC_syslog_os_log_mapping(5LL);
  if (__SC_log_enabled(5LL, v50, v51))
  {
    __int128 v52 = _os_log_pack_size(36LL);
    __int128 v53 = (char *)&v62 - ((__chkstk_darwin(v52) + 15) & 0xFFFFFFFFFFFFFFF0LL);
    __int128 v54 = __error();
    __int128 v55 = _os_log_pack_fill( v53,  v52,  *v54,  &dword_0,  "RTADV %s: CLAT46 enabled using address %d.%d.%d.%d",  v62,  v63,  (_DWORD)v64,  v65,  v66);
    __int128 v56 = nullsub_1(v2);
    int v57 = v67;
    uint64_t v58 = BYTE1(v67);
    uint64_t v59 = BYTE2(v67);
    uint64_t v60 = HIBYTE(v67);
    *(_DWORD *)__int128 v55 = 136316162;
    *(void *)(v55 + 4) = v56;
    *(_WORD *)(v55 + 12) = 1024;
    *(_DWORD *)(v55 + 14) = v57;
    *(_WORD *)(v55 + 18) = 1024;
    *(_DWORD *)(v55 + 20) = v58;
    *(_WORD *)(v55 + 24) = 1024;
    *(_DWORD *)(v55 + 26) = v59;
    *(_WORD *)(v55 + 30) = 1024;
    *(_DWORD *)(v55 + 32) = v60;
    __SC_log_send(5LL, v50, v51, v53);
  }

  int v4 = 1LL;
  sub_19038(a1, 1);
  uint64_t v61 = sub_54F6C(v2);
  sub_37000(v61, 0, v67);
  close(v6);
  *(_BYTE *)(v3 + 160) = v9;
  return v4;
}

uint64_t sub_366E8(int a1, uint64_t a2, uint64_t a3, _DWORD *a4)
{
  __int128 v8 = 0u;
  __int128 v9 = 0u;
  __strlcpy_chk(&v8, a2, 16LL, 16LL);
  if (a3)
  {
    LODWORD(v9) = *a4;
    *((void *)&v9 + 1) = a3;
  }

  if (ioctl(a1, 0xC02069C4uLL, &v8) < 0) {
    return 0xFFFFFFFFLL;
  }
  uint64_t result = 0LL;
  *a4 = v9;
  return result;
}

uint64_t sub_367A0(int a1, const char *a2, _OWORD *a3)
{
  __int128 v25 = 0u;
  __int128 v26 = 0u;
  __int128 v24 = 0u;
  __int128 v23 = 0u;
  __int128 v22 = 0u;
  memset(&__dst[16], 0, 32);
  strncpy(__dst, a2, 0x10uLL);
  if (a3)
  {
    *(_WORD *)&char __dst[16] = 7708;
    *(_OWORD *)&__dst[24] = *a3;
    inet_ntop(30, a3, (char *)v20 + 2, 0x2Eu);
    uint64_t v6 = sub_57538();
    uint64_t v7 = _SC_syslog_os_log_mapping(6LL);
    if (__SC_log_enabled(6LL, v6, v7))
    {
      uint64_t v8 = _os_log_pack_size(22LL);
      __int128 v9 = (char *)&v20[-1] - ((__chkstk_darwin(v8) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v10 = __error();
      uint64_t v11 = _os_log_pack_fill(v9, v8, *v10, &dword_0, "ioctl(%s, SIOCLL_START %s)", v19, v20[0]);
      *(_DWORD *)uint64_t v11 = 136315394;
      *(void *)(v11 + 4) = a2;
      *(_WORD *)(v11 + 12) = 2080;
      *(void *)(v11 + 14) = (char *)v20 + 2;
      __SC_log_send(6LL, v6, v7, v9);
    }
  }

  else
  {
    uint64_t v12 = sub_57538();
    uint64_t v13 = _SC_syslog_os_log_mapping(6LL);
    if (__SC_log_enabled(6LL, v12, v13))
    {
      uint64_t v14 = _os_log_pack_size(12LL);
      uint64_t v15 = (char *)&v20[-1] - ((__chkstk_darwin(v14) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v16 = __error();
      uint64_t v17 = _os_log_pack_fill(v15, v14, *v16, &dword_0, "ioctl(%s, SIOCLL_START)", v19);
      *(_DWORD *)uint64_t v17 = 136315138;
      *(void *)(v17 + 4) = a2;
      __SC_log_send(6LL, v12, v13, v15);
    }
  }

  return ioctl(a1, 0xC0806982uLL, __dst);
}

BOOL sub_369EC(const char *a1, int a2, int *a3)
{
  HIDWORD(v25) = a2;
  size_t v24 = 4LL;
  int v5 = sysctlbyname(a1, a3, &v24, (char *)&v25 + 4, 4uLL);
  uint64_t v6 = sub_57538();
  uint64_t v7 = _SC_syslog_os_log_mapping(5LL);
  int v8 = __SC_log_enabled(5LL, v6, v7);
  if (v5)
  {
    if (v8)
    {
      uint64_t v9 = _os_log_pack_size(34LL);
      uint64_t v10 = (char *)&v23 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v11 = __error();
      uint64_t v12 = _os_log_pack_fill( v10,  v9,  *v11,  &dword_0,  "sysctlbyname(%s) %d failed, %s (%d)",  v23,  v24,  v25,  v26);
      int v13 = HIDWORD(v25);
      uint64_t v14 = __error();
      uint64_t v15 = strerror(*v14);
      int v16 = *__error();
      *(_DWORD *)uint64_t v12 = 136315906;
      *(void *)(v12 + 4) = a1;
      *(_WORD *)(v12 + 12) = 1024;
      *(_DWORD *)(v12 + 14) = v13;
      *(_WORD *)(v12 + 18) = 2080;
      *(void *)(v12 + 20) = v15;
      *(_WORD *)(v12 + 28) = 1024;
      *(_DWORD *)(v12 + 30) = v16;
LABEL_6:
      __SC_log_send(5LL, v6, v7, v10);
    }
  }

  else if (v8)
  {
    uint64_t v17 = _os_log_pack_size(24LL);
    uint64_t v10 = (char *)&v23 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0LL);
    char v18 = __error();
    uint64_t v19 = _os_log_pack_fill(v10, v17, *v18, &dword_0, "sysctlbyname(%s) %d -> %d ", v23, v24, (_DWORD)v25);
    int v20 = *a3;
    int v21 = HIDWORD(v25);
    *(_DWORD *)uint64_t v19 = 136315650;
    *(void *)(v19 + 4) = a1;
    *(_WORD *)(v19 + 12) = 1024;
    *(_DWORD *)(v19 + 14) = v20;
    *(_WORD *)(v19 + 18) = 1024;
    *(_DWORD *)(v19 + 20) = v21;
    goto LABEL_6;
  }

  return v5 == 0;
}

uint64_t sub_36C04()
{
  v2.tv_sec = 0LL;
  v2.tv_nsec = 0LL;
  uint64_t result = qword_6C250;
  if (!qword_6C250)
  {
    qword_6C250 = (uint64_t)CFDataCreateMutable(0LL, 16LL);
    CFDataSetLength((CFMutableDataRef)qword_6C250, 16LL);
    MutableBytePtr = CFDataGetMutableBytePtr((CFMutableDataRef)qword_6C250);
    if (gethostuuid(MutableBytePtr, &v2)) {
      sub_4FA18((const void **)&qword_6C250);
    }
    return qword_6C250;
  }

  return result;
}

uint64_t sub_36C6C(int a1, int a2, int a3, const char *a4)
{
  return sub_36C7C(a1, a2, a3, a4);
}

uint64_t sub_36C7C(int a1, int a2, int a3, const char *a4)
{
  int v8 = arp_open_routing_socket();
  if ((v8 & 0x80000000) == 0)
  {
    int v9 = v8;
    __int128 v44 = 0u;
    __int128 v45 = 0u;
    __int128 v42 = 0u;
    __int128 v43 = 0u;
    __int128 v40 = 0u;
    __int128 v41 = 0u;
    __int128 v38 = 0u;
    __int128 v39 = 0u;
    __int128 v36 = 0u;
    __int128 v37 = 0u;
    __buf = (const char *)17104896;
    DWORD1(v36) = arp_get_next_seq();
    uint64_t __buf_8 = 0x700000901LL;
    WORD6(v40) = 528;
    LODWORD(v41) = a2;
    WORD6(v41) = 528;
    LODWORD(v42) = a1;
    WORD6(v42) = 528;
    LODWORD(v43) = a3;
    if (a4)
    {
      HIDWORD(__buf_8) = 55;
      WORD6(v43) = 4628;
      BYTE1(v44) = strlen(a4);
      __memmove_chk((char *)&v44 + 4, a4);
      LOWORD(v45) = 528;
      DWORD1(v45) = a1;
      unsigned int v10 = 176;
    }

    else
    {
      unsigned int v10 = 140;
    }

    LOWORD(__buf) = v10;
    if ((write(v9, &__buf, v10) & 0x8000000000000000LL) == 0)
    {
      uint64_t v19 = 1LL;
LABEL_18:
      close(v9);
      return v19;
    }

    int v20 = *__error();
    if (v20 == 17 || v20 == 3)
    {
      uint64_t v21 = sub_57538();
      uint64_t v22 = _SC_syslog_os_log_mapping(6LL);
      if (__SC_log_enabled(6LL, v21, v22))
      {
        uint64_t v23 = _os_log_pack_size(12LL);
        size_t v24 = (char *)&__buf - ((__chkstk_darwin(v23) + 15) & 0xFFFFFFFFFFFFFFF0LL);
        __int128 v25 = __error();
        uint64_t v26 = _os_log_pack_fill( v24,  v23,  *v25,  &dword_0,  "subnet_route: write routing socket failed, %s",  __buf);
        uint64_t v27 = strerror(v20);
        *(_DWORD *)uint64_t v26 = 136315138;
        *(void *)(v26 + 4) = v27;
        uint64_t v28 = 6LL;
LABEL_16:
        __SC_log_send(v28, v21, v22, v24);
      }
    }

    else
    {
      uint64_t v21 = sub_57538();
      uint64_t v22 = _SC_syslog_os_log_mapping(5LL);
      if (__SC_log_enabled(5LL, v21, v22))
      {
        uint64_t v29 = _os_log_pack_size(12LL);
        size_t v24 = (char *)&__buf - ((__chkstk_darwin(v29) + 15) & 0xFFFFFFFFFFFFFFF0LL);
        int v30 = __error();
        uint64_t v31 = _os_log_pack_fill( v24,  v29,  *v30,  &dword_0,  "subnet_route: write routing socket failed, %s",  __buf);
        uint64_t v32 = strerror(v20);
        *(_DWORD *)uint64_t v31 = 136315138;
        *(void *)(v31 + 4) = v32;
        uint64_t v28 = 5LL;
        goto LABEL_16;
      }
    }

    uint64_t v19 = 0LL;
    goto LABEL_18;
  }

  uint64_t v11 = sub_57538();
  uint64_t v12 = _SC_syslog_os_log_mapping(5LL);
  if (__SC_log_enabled(5LL, v11, v12))
  {
    uint64_t v13 = _os_log_pack_size(12LL);
    uint64_t v14 = (char *)&__buf - ((__chkstk_darwin(v13) + 15) & 0xFFFFFFFFFFFFFFF0LL);
    uint64_t v15 = __error();
    uint64_t v16 = _os_log_pack_fill( v14,  v13,  *v15,  &dword_0,  "subnet_route: open routing socket failed, %s",  __buf);
    uint64_t v17 = __error();
    char v18 = strerror(*v17);
    *(_DWORD *)uint64_t v16 = 136315138;
    *(void *)(v16 + 4) = v18;
    __SC_log_send(5LL, v11, v12, v14);
  }

  return 0LL;
}

uint64_t sub_37000(int a1, int a2, int a3)
{
  uint64_t result = arp_open_routing_socket();
  if ((result & 0x80000000) == 0)
  {
    uint64_t v7 = result;
    if (a2) {
      arp_delete(result, a2, 0);
    }
    if (a3) {
      arp_delete(v7, a3, 0);
    }
    arp_flush(v7, 0, a1);
    sub_3708C(v7);
    return close(v7);
  }

  return result;
}

void sub_3708C(uint64_t a1)
{
  *(_OWORD *)__int128 v40 = xmmword_59500;
  uint64_t v41 = 0x1000000002LL;
  int v2 = 3;
  while (1)
  {
    if (sysctl(v40, 6u, 0LL, &v39, 0LL, 0LL) < 0) {
      return;
    }
    int v3 = (unsigned __int16 *)malloc(v39);
    if (!v3) {
      return;
    }
    int v4 = v3;
    if ((sysctl(v40, 6u, v3, &v39, 0LL, 0LL) & 0x80000000) == 0) {
      break;
    }
    free(v4);
    if (!--v2) {
      return;
    }
  }

  if ((uint64_t)v39 >= 1)
  {
    unint64_t v6 = (unint64_t)v4 + v39;
    *(void *)&__int128 v5 = 67110146LL;
    __int128 v34 = v5;
    uint64_t v7 = v4;
    do
    {
      *((_BYTE *)v7 + 3) = 2;
      *((_DWORD *)v7 + 5) = arp_get_next_seq();
      ssize_t v8 = write(a1, v7, *v7);
      uint64_t v9 = sub_57538();
      if (v8 < 0)
      {
        uint64_t v22 = _SC_syslog_os_log_mapping(5LL);
        unsigned int v23 = v22;
        if (__SC_log_enabled(5LL, v9, v22))
        {
          uint64_t v24 = _os_log_pack_size(36LL);
          __int128 v38 = (const char *)&v34;
          uint64_t v12 = (char *)&v34 - ((__chkstk_darwin(v24) + 15) & 0xFFFFFFFFFFFFFFF0LL);
          __int128 v25 = __error();
          uint64_t v26 = _os_log_pack_fill( v12,  v24,  *v25,  &dword_0,  "IPConfiguration: removing dynamic route for %d.%d.%d.%d failed, %s",  (_DWORD)v34,  DWORD2(v34),  v35,  v36,  v38);
          unsigned int v37 = v23;
          uint64_t v27 = a1;
          int v28 = *((unsigned __int8 *)v7 + 96);
          unint64_t v29 = v6;
          int v30 = *((unsigned __int8 *)v7 + 97);
          int v31 = *((unsigned __int8 *)v7 + 98);
          int v36 = *((unsigned __int8 *)v7 + 99);
          uint64_t v32 = __error();
          uint64_t v33 = strerror(*v32);
          *(_DWORD *)uint64_t v26 = v34;
          *(_DWORD *)(v26 + 4) = v28;
          a1 = v27;
          *(_WORD *)(v26 + 8) = 1024;
          *(_DWORD *)(v26 + 10) = v30;
          unint64_t v6 = v29;
          *(_WORD *)(v26 + 14) = 1024;
          *(_DWORD *)(v26 + 16) = v31;
          *(_WORD *)(v26 + 20) = 1024;
          uint64_t v21 = v37;
          *(_DWORD *)(v26 + 22) = v36;
          *(_WORD *)(v26 + 26) = 2080;
          *(void *)(v26 + 28) = v33;
          uint64_t v19 = 5LL;
          uint64_t v20 = v9;
          goto LABEL_14;
        }
      }

      else
      {
        uint64_t v10 = _SC_syslog_os_log_mapping(6LL);
        if (__SC_log_enabled(6LL, v9, v10))
        {
          uint64_t v11 = _os_log_pack_size(26LL);
          __int128 v38 = (const char *)&v34;
          uint64_t v12 = (char *)&v34 - ((__chkstk_darwin(v11) + 15) & 0xFFFFFFFFFFFFFFF0LL);
          uint64_t v13 = __error();
          uint64_t v14 = _os_log_pack_fill( v12,  v11,  *v13,  &dword_0,  "IPConfiguration: removed dynamic route for %d.%d.%d.%d",  (_DWORD)v34,  DWORD2(v34),  v35,  v36);
          int v15 = *((unsigned __int8 *)v7 + 96);
          int v16 = *((unsigned __int8 *)v7 + 97);
          int v17 = *((unsigned __int8 *)v7 + 98);
          int v18 = *((unsigned __int8 *)v7 + 99);
          *(_DWORD *)uint64_t v14 = 67109888;
          *(_DWORD *)(v14 + 4) = v15;
          *(_WORD *)(v14 + 8) = 1024;
          *(_DWORD *)(v14 + 10) = v16;
          *(_WORD *)(v14 + 14) = 1024;
          *(_DWORD *)(v14 + 16) = v17;
          *(_WORD *)(v14 + 20) = 1024;
          *(_DWORD *)(v14 + 22) = v18;
          uint64_t v19 = 6LL;
          uint64_t v20 = v9;
          uint64_t v21 = v10;
LABEL_14:
          __SC_log_send(v19, v20, v21, v12);
        }
      }

      uint64_t v7 = (unsigned __int16 *)((char *)v7 + *v7);
    }

    while ((unint64_t)v7 < v6);
  }

  free(v4);
}

CFPropertyListRef sub_373B8(const __SCDynamicStore *a1, const __CFString *a2)
{
  CFPropertyListRef v2 = SCDynamicStoreCopyValue(a1, a2);
  __int128 v5 = v2;
  if (v2)
  {
    CFTypeID TypeID = CFDictionaryGetTypeID();
    if (CFGetTypeID(v2) != TypeID)
    {
      sub_4FA18(&v5);
      return v5;
    }
  }

  return v2;
}

void sub_37410( const __SCDynamicStore *a1, CFStringRef serviceID, const void **a3, const __CFDictionary **a4, int a5, int a6)
{
  if (a5)
  {
    LODWORD(v7) = a5;
    if (!qword_6C258) {
      qword_6C258 = (uint64_t)CFDictionaryCreateMutable( 0LL,  0LL,  &kCFTypeDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
    }
    if (!qword_6C260)
    {
      qword_6C260 = (uint64_t)CFArrayCreateMutable(0LL, 0LL, &kCFTypeArrayCallBacks);
      xmmword_6C268 = 0uLL;
    }

    if (a6)
    {
      CFMutableDictionaryRef Mutable = 0LL;
      if ((int)v7 >= 1)
      {
        uint64_t v7 = v7;
        do
        {
          uint64_t v13 = *a4;
          if (*a4)
          {
            CFNullRef v14 = (CFNullRef)*a3;
            if (!Mutable) {
              CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable( 0LL,  0LL,  &kCFTypeDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
            }
            if (v14 == kCFNull) {
              CFDictionaryApplyFunction(v13, (CFDictionaryApplierFunction)sub_38E54, Mutable);
            }
            else {
              CFDictionarySetValue(Mutable, v14, v13);
            }
          }

          ++a4;
          ++a3;
          --v7;
        }

        while (v7);
      }

      int v15 = CFStringCreateWithFormat(0LL, 0LL, @"Plugin:IPConfigurationService:%@", serviceID);
      sub_37618(a1, v15, Mutable);
      CFRelease(v15);
      if (Mutable) {
        CFRelease(Mutable);
      }
    }

    else if ((int)v7 >= 1)
    {
      uint64_t v16 = v7;
      do
      {
        int v18 = (const __CFNull *)*a3++;
        int v17 = v18;
        if (v18 == kCFNull) {
          uint64_t v19 = 0LL;
        }
        else {
          uint64_t v19 = (const __CFString *)v17;
        }
        CFStringRef NetworkServiceEntity = SCDynamicStoreKeyCreateNetworkServiceEntity( 0LL,  kSCDynamicStoreDomainState,  serviceID,  v19);
        uint64_t v21 = *a4++;
        sub_37618(a1, NetworkServiceEntity, v21);
        CFRelease(NetworkServiceEntity);
        --v16;
      }

      while (v16);
    }
  }

void sub_37618(const __SCDynamicStore *a1, const __CFString *value, const void *a3)
{
  CFRange v6 = (CFRange)xmmword_6C268;
  if (a3)
  {
    FirstIndexOfint Value = CFArrayGetFirstIndexOfValue((CFArrayRef)qword_6C260, v6, value);
    if (FirstIndexOfValue != -1)
    {
      CFArrayRemoveValueAtIndex((CFMutableArrayRef)qword_6C260, FirstIndexOfValue);
      --*((void *)&xmmword_6C268 + 1);
LABEL_4:
      CFDictionarySetValue((CFMutableDictionaryRef)qword_6C258, value, a3);
      return;
    }

    CFPropertyListRef v8 = sub_373B8(a1, value);
    uint64_t v10 = v8;
    if (!v8) {
      goto LABEL_4;
    }
    int v9 = CFEqual(a3, v8);
    sub_4FA18(&v10);
    if (!v9) {
      goto LABEL_4;
    }
  }

  else
  {
    if (!CFArrayContainsValue((CFArrayRef)qword_6C260, v6, value))
    {
      CFArrayAppendValue((CFMutableArrayRef)qword_6C260, value);
      ++*((void *)&xmmword_6C268 + 1);
    }

    CFDictionaryRemoveValue((CFMutableDictionaryRef)qword_6C258, value);
  }

void sub_3771C(const __SCDynamicStore *a1, CFStringRef ifname, CFStringRef entity, const void *a4)
{
  if (!qword_6C258) {
    qword_6C258 = (uint64_t)CFDictionaryCreateMutable( 0LL,  0LL,  &kCFTypeDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
  }
  if (!qword_6C260)
  {
    qword_6C260 = (uint64_t)CFArrayCreateMutable(0LL, 0LL, &kCFTypeArrayCallBacks);
    xmmword_6C268 = 0uLL;
  }

  CFStringRef NetworkInterfaceEntity = SCDynamicStoreKeyCreateNetworkInterfaceEntity( 0LL,  kSCDynamicStoreDomainState,  ifname,  entity);
  sub_37618(a1, NetworkInterfaceEntity, a4);
  CFRelease(NetworkInterfaceEntity);
}

void sub_377E4(SCDynamicStoreRef store)
{
  if (*((void *)&xmmword_6C258 + 1) && !CFArrayGetCount(*((CFArrayRef *)&xmmword_6C258 + 1))) {
    sub_4FA18((const void **)&xmmword_6C258 + 1);
  }
  if ((void)xmmword_6C258 && !CFDictionaryGetCount((CFDictionaryRef)xmmword_6C258)) {
    sub_4FA18((const void **)&xmmword_6C258);
  }
  if (xmmword_6C258 != 0)
  {
    SCDynamicStoreSetMultiple(store, (CFDictionaryRef)xmmword_6C258, *((CFArrayRef *)&xmmword_6C258 + 1), 0LL);
    if (G_IPConfiguration_verbose)
    {
      if ((void)xmmword_6C258)
      {
        uint64_t v2 = sub_57538();
        uint64_t v3 = _SC_syslog_os_log_mapping(4294967289LL);
        if (__SC_log_enabled(4294967289LL, v2, v3))
        {
          uint64_t v4 = _os_log_pack_size(12LL);
          __int128 v5 = (char *)&v16 - ((__chkstk_darwin(v4) + 15) & 0xFFFFFFFFFFFFFFF0LL);
          CFRange v6 = __error();
          uint64_t v7 = _os_log_pack_fill(v5, v4, *v6, &dword_0, "DynamicStore Publish\n%@");
          uint64_t v8 = xmmword_6C258;
          *(_DWORD *)uint64_t v7 = 138412290;
          *(void *)(v7 + 4) = v8;
          __SC_log_send(4294967289LL, v2, v3, v5);
        }
      }

      if (*((void *)&xmmword_6C258 + 1))
      {
        uint64_t v9 = sub_57538();
        uint64_t v10 = _SC_syslog_os_log_mapping(4294967289LL);
        if (__SC_log_enabled(4294967289LL, v9, v10))
        {
          uint64_t v11 = _os_log_pack_size(12LL);
          uint64_t v12 = (char *)&v16 - ((__chkstk_darwin(v11) + 15) & 0xFFFFFFFFFFFFFFF0LL);
          uint64_t v13 = __error();
          uint64_t v14 = _os_log_pack_fill(v12, v11, *v13, &dword_0, "DynamicStore Remove\n%@");
          uint64_t v15 = *((void *)&xmmword_6C258 + 1);
          *(_DWORD *)uint64_t v14 = 138412290;
          *(void *)(v14 + 4) = v15;
          __SC_log_send(4294967289LL, v9, v10, v12);
        }
      }
    }

    sub_4FA18((const void **)&xmmword_6C258 + 1);
    sub_4FA18((const void **)&xmmword_6C258);
  }

CFMutableDictionaryRef sub_37A38(int a1, uint64_t a2, CFAbsoluteTime a3, CFAbsoluteTime a4)
{
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(0LL, 0LL, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  CFMutableDictionaryRef v19 = Mutable;
  int v9 = sub_50C94(a2);
  if (v9 >= 1)
  {
    int v10 = v9;
    uint64_t v11 = 0LL;
    do
    {
      uint64_t v12 = (unsigned __int8 *)sub_50C98(a2, v11);
      uint64_t v13 = *v12;
      if (a1 == 258 && (_DWORD)v13 == 12 || sub_8F30(*v12))
      {
        *(void *)&length[1] = CFStringCreateWithFormat(0LL, 0LL, @"Option_%d", v13);
        if (!CFDictionaryGetValue(Mutable, *(const void **)&length[1]))
        {
          uint64_t v14 = sub_50E8C(a2, v13, length);
          if (v14)
          {
            uint64_t v15 = v14;
            CFDataRef v16 = CFDataCreate(0LL, (const UInt8 *)v14, length[0]);
            CFDictionarySetValue(Mutable, *(const void **)&length[1], v16);
            CFRelease(v16);
            free(v15);
          }
        }

        sub_4FA18((const void **)&length[1]);
      }

      uint64_t v11 = (v11 + 1);
    }

    while (v10 != (_DWORD)v11);
  }

  if (a1 == 259)
  {
    sub_5027C(Mutable, @"LeaseStartTime", a3);
    if (a4 != 0.0) {
      sub_5027C(Mutable, @"LeaseExpirationTime", a4);
    }
  }

  if (!CFDictionaryGetCount(Mutable))
  {
    sub_4FA18((const void **)&v19);
    return v19;
  }

  return Mutable;
}

_BYTE *sub_37BD4(CFStringRef theString, int *a2)
{
  ArrayBySeparatingStrings = CFStringCreateArrayBySeparatingStrings(0LL, theString, @":");
  CFArrayRef theArray = ArrayBySeparatingStrings;
  if (ArrayBySeparatingStrings && (Count = CFArrayGetCount(ArrayBySeparatingStrings), (int v5 = Count) != 0))
  {
    CFRange v6 = malloc(Count);
    if (v5 >= 1)
    {
      for (CFIndex i = 0LL; i != v5; v6[i++] = strtoul(__str, 0LL, 16))
      {
        ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(theArray, i);
        sub_4FC44(ValueAtIndex, (UInt8 *)__str, 4, 0);
      }
    }

    sub_4FA18((const void **)&theArray);
    *a2 = v5;
  }

  else
  {
    sub_4FA18((const void **)&theArray);
    return 0LL;
  }

  return v6;
}

const void *sub_37CA8(CFStringRef theString, in_addr *a2, void *a3, int *a4)
{
  a2->s_addr = 0;
  *a3 = 0LL;
  *a4 = 0;
  CFArrayRef ArrayBySeparatingStrings = CFStringCreateArrayBySeparatingStrings(0LL, theString, @"/");
  CFArrayRef v13 = ArrayBySeparatingStrings;
  if (ArrayBySeparatingStrings
    && (uint64_t v8 = ArrayBySeparatingStrings, CFArrayGetCount(ArrayBySeparatingStrings) >= 7)
    && (ValueAtIndex = CFArrayGetValueAtIndex(v8, 3LL),
        int v10 = (const __CFString *)CFArrayGetValueAtIndex(v8, 5LL),
        uint64_t v11 = (const __CFString *)CFArrayGetValueAtIndex(v8, 6LL),
        sub_4FCC8(v10, a2),
        a2->s_addr))
  {
    *a3 = sub_37BD4(v11, a4);
    CFRetain(ValueAtIndex);
  }

  else
  {
    ValueAtIndex = 0LL;
  }

  sub_4FA18((const void **)&v13);
  return ValueAtIndex;
}

__CFDictionary *sub_37D8C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  LODWORD(v46) = 0;
  LODWORD(theArray) = 0;
  LODWORD(v44) = 0;
  if (!a2)
  {
    CFMutableDictionaryRef Mutable = 0LL;
    goto LABEL_53;
  }

  CFMutableDictionaryRef Mutable = *(__CFDictionary **)(a2 + 16);
  if (!Mutable) {
    goto LABEL_53;
  }
  else {
    CFRange v6 = 0LL;
  }
  else {
    uint64_t v7 = 0LL;
  }
  else {
    int v9 = 0LL;
  }
  int v10 = sub_38E68(a1, (uint64_t)v6, (signed int)theArray, v8);
  if (!v10)
  {
    CFMutableDictionaryRef Mutable = 0LL;
    if (v9) {
      goto LABEL_52;
    }
    goto LABEL_53;
  }

  uint64_t v11 = v10;
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(0LL, 0LL, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  CFDictionarySetValue(Mutable, kSCPropNetDNSServerAddresses, v11);
  CFRelease(v11);
  if (!v7) {
    goto LABEL_49;
  }
  int v12 = (int)v46;
  if ((int)v46 < 1)
  {
    *(void *)__int128 v47 = 0LL;
    goto LABEL_48;
  }

  CFArrayRef v13 = 0LL;
  uint64_t v14 = 0LL;
  uint64_t v15 = v7;
  do
  {
    uint64_t v16 = *v7;
    if (*v7)
    {
      if ((v16 & 0x80) != 0)
      {
        if (!__maskrune(*v7, 0x4000uLL))
        {
LABEL_28:
          if (!v13) {
            CFArrayRef v13 = v7;
          }
          goto LABEL_30;
        }
      }

      else if ((_DefaultRuneLocale.__runetype[v16] & 0x4000) == 0)
      {
        goto LABEL_28;
      }
    }

    if (v13)
    {
      if (v9 || !(_DWORD)v16)
      {
        *(void *)__int128 v47 = v14;
        goto LABEL_37;
      }

      CFStringRef v17 = CFStringCreateWithBytes(0LL, v13, v15 - v13, 0x8000100u, 0);
      if (!v17)
      {
        *(void *)__int128 v47 = v14;
        goto LABEL_48;
      }

      CFStringRef v18 = v17;
      if (!v14) {
        uint64_t v14 = CFArrayCreateMutable(0LL, 0LL, &kCFTypeArrayCallBacks);
      }
      CFArrayAppendValue(v14, v18);
      CFRelease(v18);
      CFArrayRef v13 = 0LL;
    }

LABEL_52:
    free(v9);
  }

void sub_38348(__CFDictionary *a1, CFDictionaryRef theDict, const __CFDictionary *a3, void *key)
{
  int Value = (const __CFArray *)CFDictionaryGetValue(theDict, key);
  __n128 v8 = (const __CFArray *)CFDictionaryGetValue(a3, key);
  if ((unint64_t)Value | (unint64_t)v8)
  {
    int v9 = v8;
    if (Value && v8)
    {
      CFIndex Count = CFArrayGetCount(Value);
      CFMutableArrayRef MutableCopy = CFArrayCreateMutableCopy(0LL, 0LL, Value);
      CFIndex v12 = CFArrayGetCount(v9);
      if (v12 >= 1)
      {
        CFIndex v13 = v12;
        for (CFIndex i = 0LL; i != v13; ++i)
        {
          ValueAtIndex = CFArrayGetValueAtIndex(v9, i);
          v17.location = 0LL;
          v17.length = Count;
          if (!CFArrayContainsValue(Value, v17, ValueAtIndex)) {
            CFArrayAppendValue(MutableCopy, ValueAtIndex);
          }
        }
      }

      CFDictionarySetValue(a1, key, MutableCopy);
      CFRelease(MutableCopy);
    }

    else
    {
      if (Value) {
        uint64_t v16 = Value;
      }
      else {
        uint64_t v16 = v8;
      }
      CFDictionarySetValue(a1, key, v16);
    }
  }

CFMutableDictionaryRef sub_38498(uint64_t a1)
{
  if (!a1) {
    return 0LL;
  }
  uint64_t v2 = *(void *)(a1 + 16);
  if (!v2) {
    return 0LL;
  }
  int v3 = sub_50C94(*(void *)(a1 + 16));
  if (!v3) {
    return 0LL;
  }
  uint64_t v4 = v3;
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(0LL, 0LL, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  CFMutableDictionaryRef v15 = Mutable;
  if ((int)v4 >= 1)
  {
    for (uint64_t i = 0LL; i != v4; ++i)
    {
      uint64_t v7 = (const UInt8 *)sub_50C98(v2, i);
      unsigned int v8 = bswap32(*(unsigned __int16 *)v7);
      uint64_t v9 = HIWORD(v8);
      if (sub_3F7E4(HIWORD(v8)))
      {
        CFDataRef v10 = CFDataCreate(0LL, v7 + 4, bswap32(*((unsigned __int16 *)v7 + 1)) >> 16);
        CFStringRef v11 = CFStringCreateWithFormat(0LL, 0LL, @"Option_%d", v9);
        int Value = (void *)CFDictionaryGetValue(Mutable, v11);
        if (!Value)
        {
          int Value = CFArrayCreateMutable(0LL, 0LL, &kCFTypeArrayCallBacks);
          CFDictionarySetValue(Mutable, v11, Value);
          CFRelease(Value);
        }

        CFArrayAppendValue((CFMutableArrayRef)Value, v10);
        CFRelease(v11);
        CFRelease(v10);
      }
    }
  }

  if (*(_DWORD *)(a1 + 72))
  {
    sub_5027C(Mutable, @"LeaseStartTime", *(CFAbsoluteTime *)(a1 + 24));
    double v13 = *(double *)(a1 + 32);
    if (v13 != 0.0) {
      sub_5027C(Mutable, @"LeaseExpirationTime", v13);
    }
  }

  if (!CFDictionaryGetCount(Mutable))
  {
    sub_4FA18((const void **)&v15);
    return v15;
  }

  return Mutable;
}

CFDictionaryRef sub_38654(__CFString *a1, uint64_t a2)
{
  int v3 = a1;
  LODWORD(keys) = 0;
  if (a1)
  {
    if (sub_8F30(114) && (uint64_t data = (uint64_t)v3->data) != 0)
    {
      int v5 = sub_50DA0(data, 114, &keys, 0LL);
      int v3 = (__CFString *)sub_505EC(v5, keys);
    }

    else
    {
      int v3 = 0LL;
    }
  }

  CFStringRef v18 = v3;
  CFRange v6 = (__CFString *)sub_38850(a2);
  uint64_t v7 = v6;
  CFRange v17 = v6;
  if (v3)
  {
    if (v6)
    {
      if (CFStringCompare(v3, v6, 1uLL))
      {
        uint64_t v8 = sub_57538();
        uint64_t v9 = _SC_syslog_os_log_mapping(3LL);
        if (__SC_log_enabled(3LL, v8, v9))
        {
          uint64_t v10 = _os_log_pack_size(22LL);
          CFStringRef v11 = (char *)&v16 - ((__chkstk_darwin(v10) + 15) & 0xFFFFFFFFFFFFFFF0LL);
          CFIndex v12 = __error();
          uint64_t v13 = _os_log_pack_fill( v11,  v10,  *v12,  &dword_0,  "Mismatch in Captive Portal URLs: IPv4=%@ IPv6=%@");
          *(_DWORD *)uint64_t v13 = 138412546;
          *(void *)(v13 + 4) = v3;
          *(_WORD *)(v13 + 12) = 2112;
          *(void *)(v13 + 14) = v7;
          __SC_log_send(3LL, v8, v9, v11);
        }
      }
    }

    values = v3;
    keys = (void *)kSCPropNetCaptivePortalURL;
  }

  else
  {
    if (!v6)
    {
      CFDictionaryRef v14 = 0LL;
      goto LABEL_15;
    }

    values = v6;
    keys = (void *)kSCPropNetCaptivePortalURL;
  }

  CFDictionaryRef v14 = CFDictionaryCreate( 0LL,  (const void **)&keys,  (const void **)&values,  1LL,  &kCFTypeDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
LABEL_15:
  sub_4FA18((const void **)&v18);
  sub_4FA18((const void **)&v17);
  return v14;
}

CFStringRef sub_38850(uint64_t a1)
{
  if (a1 && sub_3F7E4(103))
  {
    uint64_t v2 = *(void *)(a1 + 16);
    if (v2)
    {
      int v3 = sub_57BD4(v2, 103, &v17, 0LL);
      uint64_t v4 = sub_505EC((UInt8 *)v3, v17);
      uint64_t v5 = *(void *)(a1 + 40);
      if (v5)
      {
        CFStringRef v6 = sub_52C40(v5);
        CFStringRef v7 = v6;
        CFStringRef v18 = v6;
        if (v4)
        {
          if (v6)
          {
            if (CFStringCompare(v4, v6, 1uLL))
            {
              uint64_t v8 = sub_57538();
              uint64_t v9 = _SC_syslog_os_log_mapping(3LL);
              if (__SC_log_enabled(3LL, v8, v9))
              {
                uint64_t v10 = _os_log_pack_size(22LL);
                CFStringRef v11 = (char *)&v16 - ((__chkstk_darwin(v10) + 15) & 0xFFFFFFFFFFFFFFF0LL);
                CFIndex v12 = __error();
                uint64_t v13 = _os_log_pack_fill( v11,  v10,  *v12,  &dword_0,  "Mismatch in Captive Portal URLs: DHCPv6=%@ RA=%@");
                *(_DWORD *)uint64_t v13 = 138412546;
                *(void *)(v13 + 4) = v4;
                *(_WORD *)(v13 + 12) = 2112;
                *(void *)(v13 + 14) = v7;
                __SC_log_send(3LL, v8, v9, v11);
              }
            }

            sub_4FA18((const void **)&v18);
          }
        }

        else
        {
          return v6;
        }
      }

      return v4;
    }

    uint64_t v14 = *(void *)(a1 + 40);
    if (v14) {
      return sub_52C40(v14);
    }
  }

  return 0LL;
}

CFDictionaryRef sub_38A28(int *a1, int *a2, int *a3)
{
  if (a1)
  {
    keys[0] = (void *)kSCPropNetIPv4RouteDestinationAddress;
    values[0] = (void *)sub_50068(*a1);
    unsigned int v5 = 1;
    if (!a2) {
      goto LABEL_4;
    }
    goto LABEL_3;
  }

  unsigned int v5 = 0;
  if (a2)
  {
LABEL_3:
    keys[v5] = (void *)kSCPropNetIPv4RouteSubnetMask;
    values[v5++] = (void *)sub_50068(*a2);
  }

__CFDictionary *PvDEntityCreateWithInfo(uint64_t a1)
{
  unsigned __int16 v28 = 0;
  int v27 = 0;
  uint64_t v26 = 0LL;
  unsigned __int16 v25 = 0;
  uint64_t v2 = *(void *)(a1 + 40);
  if (!v2) {
    return 0LL;
  }
  uint64_t v3 = sub_52A44(v2, &v26, &v25, (uint64_t)&v27);
  if (!v3 || v26 == 0) {
    return 0LL;
  }
  if (BYTE2(v27))
  {
    uint64_t v5 = sub_57538();
    uint64_t v6 = _SC_syslog_os_log_mapping(6LL);
    if (__SC_log_enabled(6LL, v5, v6))
    {
      uint64_t v7 = _os_log_pack_size(2LL);
      CFDictionaryRef v8 = (char *)&v23 - ((__chkstk_darwin(v7) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v9 = __error();
      *(_WORD *)_os_log_pack_fill(v8, v7, *v9, &dword_0, "Ignoring PvD option with R flag") = 0;
      __SC_log_send(6LL, v5, v6, v8);
    }

    return 0LL;
  }

  uint64_t v10 = v3;
  CFStringRef v11 = sub_536F4(v3, v26);
  CFStringRef v24 = v11;
  if (!v11)
  {
    CFMutableStringRef Mutable = CFStringCreateMutable(0LL, 0LL);
    CFMutableStringRef v23 = Mutable;
    sub_55914(Mutable, v10, v26);
    uint64_t v16 = sub_57538();
    uint64_t v17 = _SC_syslog_os_log_mapping(6LL);
    if (__SC_log_enabled(6LL, v16, v17))
    {
      uint64_t v18 = _os_log_pack_size(12LL);
      CFStringRef v19 = (char *)&v23 - ((__chkstk_darwin(v18) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      CFStringRef v20 = __error();
      uint64_t v21 = _os_log_pack_fill( v19,  v18,  *v20,  &dword_0,  "Failed to get PvD ID from raw str:\n%@",  v23,  v24);
      *(_DWORD *)uint64_t v21 = 138412290;
      *(void *)(v21 + 4) = Mutable;
      __SC_log_send(6LL, v16, v17, v19);
    }

    sub_4FA18((const void **)&v23);
    return 0LL;
  }

  CFStringRef v12 = v11;
  uint64_t v13 = CFDictionaryCreateMutable(0LL, 1LL, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  CFDictionarySetValue(v13, kSCPropNetPvDIdentifier, v12);
  if ((_BYTE)v27)
  {
    sub_502C4(v13, kSCPropNetPvDHTTPSupported, 1LL);
    sub_502C4(v13, kSCPropNetPvDSequenceNumber, v25);
    sub_502C4(v13, kSCPropNetPvDDelay, v28);
    uint64_t v14 = *(const void **)(a1 + 104);
    if (v14) {
      CFDictionarySetValue(v13, kSCPropNetPvDAdditionalInformation, v14);
    }
  }

  if (BYTE1(v27)) {
    sub_502C4(v13, kSCPropNetPvDLegacy, 1LL);
  }
  sub_4FA18((const void **)&v24);
  return v13;
}

void sub_38E54(void *key, void *value, CFMutableDictionaryRef theDict)
{
}

__CFArray *sub_38E68(uint64_t a1, uint64_t a2, signed int a3, __n128 a4)
{
  uint64_t v22 = a1;
  CFMutableStringRef Mutable = 0LL;
  if (a2 && a3 >= 4)
  {
    CFMutableStringRef Mutable = 0LL;
    else {
      unint64_t v5 = (unint64_t)a3 >> 2;
    }
    uint64_t v6 = (unsigned __int8 *)(a2 + 3);
    a4.n128_u64[0] = 136316162LL;
    __n128 v21 = a4;
    do
    {
      unsigned int v7 = *(v6 - 3);
      int v8 = *(v6 - 2);
      int v9 = *(v6 - 1);
      int v10 = *v6;
      if (((v9 << 16) | (v8 << 8) | (v10 << 24) | v7) + 1 > 1)
      {
        if (!Mutable) {
          CFMutableStringRef Mutable = CFArrayCreateMutable(0LL, 0LL, &kCFTypeArrayCallBacks);
        }
        CFStringRef v19 = sub_50068((v9 << 16) | (v8 << 8) | (v10 << 24) | v7);
        CFArrayAppendValue(Mutable, v19);
        CFRelease(v19);
      }

      else
      {
        uint64_t v11 = sub_57538();
        uint64_t v12 = _SC_syslog_os_log_mapping(5LL);
        if (__SC_log_enabled(5LL, v11, v12))
        {
          uint64_t v13 = _os_log_pack_size(36LL);
          CFStringRef v24 = Mutable;
          uint64_t v14 = v13;
          CFMutableStringRef v23 = &v21;
          CFMutableDictionaryRef v15 = (char *)&v21 - ((__chkstk_darwin(v13) + 15) & 0xFFFFFFFFFFFFFFF0LL);
          uint64_t v16 = __error();
          uint64_t v17 = v14;
          CFMutableStringRef Mutable = v24;
          uint64_t v18 = _os_log_pack_fill( v15,  v17,  *v16,  &dword_0,  "%s: ignoring invalid DNS server %d.%d.%d.%d",  (const char *)v21.n128_u64[0],  v21.n128_u32[2],  v22,  (_DWORD)v23,  (_DWORD)v24);
          *(_DWORD *)uint64_t v18 = v21.n128_u32[0];
          *(void *)(v18 + 4) = v22;
          *(_WORD *)(v18 + 12) = 1024;
          *(_DWORD *)(v18 + 14) = v7;
          *(_WORD *)(v18 + 18) = 1024;
          *(_DWORD *)(v18 + 20) = v8;
          *(_WORD *)(v18 + 24) = 1024;
          *(_DWORD *)(v18 + 26) = v9;
          *(_WORD *)(v18 + 30) = 1024;
          *(_DWORD *)(v18 + 32) = v10;
          __SC_log_send(5LL, v11, v12, v15);
        }
      }

      v6 += 4;
      --v5;
    }

    while (v5);
  }

  return Mutable;
}

CFArrayRef sub_39064(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v6 = sub_528A4(a1, &v26, &v27);
  if (v6)
  {
    unsigned int v7 = (char *)v6;
    double Current = CFAbsoluteTimeGetCurrent();
    if (!sub_51A78(a1, v27, Current))
    {
      CFMutableStringRef Mutable = CFArrayCreateMutable(0LL, v26, &kCFTypeArrayCallBacks);
      sub_39380(Mutable, v7, v26);
      if (sub_3F7E4(24))
      {
        uint64_t v6 = sub_52960(a1, &v25, &v27);
        if (!v6) {
          goto LABEL_15;
        }
        uint64_t v16 = v6;
        if (!sub_51A78(a1, v27, Current))
        {
          uint64_t v6 = (uint64_t)sub_535CC(v16, v25);
          goto LABEL_15;
        }

        if (a2)
        {
          uint64_t v17 = sub_57538();
          uint64_t v18 = _SC_syslog_os_log_mapping(5LL);
          if (__SC_log_enabled(5LL, v17, v18))
          {
            uint64_t v19 = _os_log_pack_size(12LL);
            CFStringRef v20 = (char *)&v24 - ((__chkstk_darwin(v19) + 15) & 0xFFFFFFFFFFFFFFF0LL);
            __n128 v21 = __error();
            uint64_t v22 = _os_log_pack_fill(v20, v19, *v21, &dword_0, "%s: DNSSL expired", v24);
            *(_DWORD *)uint64_t v22 = 136315138;
            *(void *)(v22 + 4) = a2;
            __SC_log_send(5LL, v17, v18, v20);
          }
        }
      }

      uint64_t v6 = 0LL;
      goto LABEL_15;
    }

    if (a2)
    {
      uint64_t v9 = sub_57538();
      uint64_t v10 = _SC_syslog_os_log_mapping(5LL);
      if (__SC_log_enabled(5LL, v9, v10))
      {
        uint64_t v11 = _os_log_pack_size(12LL);
        uint64_t v12 = (char *)&v24 - ((__chkstk_darwin(v11) + 15) & 0xFFFFFFFFFFFFFFF0LL);
        uint64_t v13 = __error();
        uint64_t v14 = _os_log_pack_fill(v12, v11, *v13, &dword_0, "%s: RDNSS expired", v24);
        *(_DWORD *)uint64_t v14 = 136315138;
        *(void *)(v14 + 4) = a2;
        __SC_log_send(5LL, v9, v10, v12);
      }
    }

    uint64_t v6 = 0LL;
  }

  CFMutableStringRef Mutable = 0LL;
LABEL_15:
  *a3 = v6;
  return Mutable;
}

void sub_392E8(const __CFArray *a1, CFArrayRef theArray)
{
  CFIndex Count = CFArrayGetCount(theArray);
  CFIndex v5 = CFArrayGetCount(a1);
  if (Count >= 1)
  {
    CFIndex v6 = v5;
    for (CFIndex i = 0LL; i != Count; ++i)
    {
      ValueAtIndex = CFArrayGetValueAtIndex(theArray, i);
      v9.location = 0LL;
      v9.length = v6;
      if (!CFArrayContainsValue(a1, v9, ValueAtIndex))
      {
        CFArrayAppendValue(a1, ValueAtIndex);
        ++v6;
      }
    }
  }

void sub_39380(const __CFArray *a1, char *a2, int a3)
{
  CFIndex Count = CFArrayGetCount(a1);
  if (a3 >= 1)
  {
    CFIndex v7 = Count;
    do
    {
      CFStringRef v8 = sub_50120(a2);
      v9.location = 0LL;
      v9.length = v7;
      if (!CFArrayContainsValue(a1, v9, v8))
      {
        CFArrayAppendValue(a1, v8);
        ++v7;
      }

      CFRelease(v8);
      a2 += 16;
      --a3;
    }

    while (a3);
  }

uint64_t sub_3940C(const char *a1, int a2, uint64_t a3)
{
  uint64_t v6 = sub_14834((uint64_t)a1);
  uint64_t v7 = sub_194C4((uint64_t)a1);
  CFStringRef v8 = (void *)v7;
  if (a2 && !v7)
  {
    uint64_t v9 = sub_57538();
    uint64_t v10 = _SC_syslog_os_log_mapping(5LL);
    uint64_t v11 = _os_log_pack_size(12LL);
    uint64_t v12 = &__str[-((__chkstk_darwin(v11) + 15) & 0xFFFFFFFFFFFFFFF0LL) - 8];
    uint64_t v13 = *__error();
    uint64_t v14 = _os_log_pack_fill(v12, v11, v13, &dword_0, "RTADV %s: is NULL");
    goto LABEL_5;
  }

  uint64_t v17 = 0LL;
  switch(a2)
  {
    case 0:
      if ((sub_54A84(v6) & 8) != 0) {
        return 4LL;
      }
      if (v8)
      {
        uint64_t v9 = sub_57538();
        uint64_t v10 = _SC_syslog_os_log_mapping(5LL);
        uint64_t v25 = _os_log_pack_size(12LL);
        uint64_t v12 = &__str[-((__chkstk_darwin(v25) + 15) & 0xFFFFFFFFFFFFFFF0LL) - 8];
        uint64_t v26 = *__error();
        uint64_t v14 = _os_log_pack_fill(v12, v25, v26, &dword_0, "RTADV %s: re-entering start state");
LABEL_5:
        uint64_t v15 = v14;
        uint64_t v16 = nullsub_1(v6);
        *(_DWORD *)uint64_t v15 = 136315138;
        *(void *)(v15 + 4) = v16;
        __SC_log_send(5LL, v9, v10, v12);
        return 6LL;
      }

      __int128 v50 = malloc(0xA8uLL);
      if (!v50)
      {
        uint64_t v61 = sub_57538();
        uint64_t v17 = 5LL;
        uint64_t v62 = _SC_syslog_os_log_mapping(5LL);
        if (__SC_log_enabled(5LL, v61, v62))
        {
          uint64_t v63 = _os_log_pack_size(12LL);
          uint64_t v64 = &__str[-((__chkstk_darwin(v63) + 15) & 0xFFFFFFFFFFFFFFF0LL) - 8];
          uint64_t v65 = __error();
          uint64_t v66 = _os_log_pack_fill(v64, v63, *v65, &dword_0, "RTADV %s: malloc failed", v88);
          uint64_t v67 = nullsub_1(v6);
          *(_DWORD *)uint64_t v66 = 136315138;
          *(void *)(v66 + 4) = v67;
          __SC_log_send(5LL, v61, v62, v64);
        }

        return v17;
      }

      CFStringRef v8 = v50;
      v50[20] = 0LL;
      *((_OWORD *)v50 + 8) = 0u;
      *((_OWORD *)v50 + 9) = 0u;
      *((_OWORD *)v50 + 6) = 0u;
      *((_OWORD *)v50 + 7) = 0u;
      *((_OWORD *)v50 + 4) = 0u;
      *((_OWORD *)v50 + 5) = 0u;
      *((_OWORD *)v50 + 2) = 0u;
      *((_OWORD *)v50 + 3) = 0u;
      *(_OWORD *)__int128 v50 = 0u;
      *((_OWORD *)v50 + 1) = 0u;
      sub_194CC((uint64_t)a1, (uint64_t)v50);
      __int128 v51 = (const char *)nullsub_1(v6);
      snprintf(__str, 0x20uLL, "rtadv-%s", v51);
      __int128 v52 = timer_callout_init(__str);
      v8[1] = v52;
      if (!v52)
      {
        uint64_t v68 = sub_57538();
        uint64_t v17 = 5LL;
        uint64_t v69 = _SC_syslog_os_log_mapping(5LL);
        uint64_t v70 = _os_log_pack_size(12LL);
        uint64_t v71 = &__str[-((__chkstk_darwin(v70) + 15) & 0xFFFFFFFFFFFFFFF0LL) - 8];
        uint64_t v72 = *__error();
        uint64_t v73 = _os_log_pack_fill(v71, v70, v72, &dword_0, "RTADV %s: timer_callout_init failed");
LABEL_80:
        uint64_t v76 = v73;
        uint64_t v77 = nullsub_1(v6);
        *(_DWORD *)uint64_t v76 = 136315138;
        *(void *)(v76 + 4) = v77;
        __SC_log_send(5LL, v68, v69, v71);
        uint64_t v17 = 5LL;
        goto LABEL_81;
      }

      __int128 v53 = sub_4C244(v6);
      void *v8 = v53;
      if (!v53)
      {
        uint64_t v68 = sub_57538();
        uint64_t v17 = 5LL;
        uint64_t v69 = _SC_syslog_os_log_mapping(5LL);
        uint64_t v74 = _os_log_pack_size(12LL);
        uint64_t v71 = &__str[-((__chkstk_darwin(v74) + 15) & 0xFFFFFFFFFFFFFFF0LL) - 8];
        uint64_t v75 = *__error();
        uint64_t v73 = _os_log_pack_fill(v71, v74, v75, &dword_0, "RTADV %s: RTADVSocketCreate failed");
        goto LABEL_80;
      }

      if (G_dhcpv6_enabled)
      {
        if (sub_1936C((uint64_t)a1))
        {
          uint64_t v54 = sub_57538();
          uint64_t v55 = _SC_syslog_os_log_mapping(5LL);
          if (__SC_log_enabled(5LL, v54, v55))
          {
            uint64_t v56 = _os_log_pack_size(12LL);
            int v57 = &__str[-((__chkstk_darwin(v56) + 15) & 0xFFFFFFFFFFFFFFF0LL) - 8];
            uint64_t v58 = __error();
            uint64_t v59 = _os_log_pack_fill(v57, v56, *v58, &dword_0, "RTADV %s: DHCPv6 client is disabled", v88);
            uint64_t v60 = nullsub_1(v6);
            *(_DWORD *)uint64_t v59 = 136315138;
            *(void *)(v59 + 4) = v60;
            __SC_log_send(5LL, v54, v55, v57);
          }
        }

        else
        {
          int v87 = sub_3FD04((uint64_t)a1);
          v8[3] = v87;
          sub_40E20(v87, (uint64_t)sub_39E38, (uint64_t)a1);
        }
      }

      sub_39E5C((uint64_t)a1, 0LL);
      sub_39F38((uint64_t)a1);
      return 0LL;
    case 1:
LABEL_81:
      uint64_t v78 = sub_57538();
      uint64_t v79 = _SC_syslog_os_log_mapping(5LL);
      if (__SC_log_enabled(5LL, v78, v79))
      {
        uint64_t v80 = _os_log_pack_size(12LL);
        uint64_t v81 = &__str[-((__chkstk_darwin(v80) + 15) & 0xFFFFFFFFFFFFFFF0LL) - 8];
        CFStringRef v82 = __error();
        uint64_t v83 = _os_log_pack_fill(v81, v80, *v82, &dword_0, "RTADV %s: stop", v88);
        uint64_t v84 = nullsub_1(v6);
        *(_DWORD *)uint64_t v83 = 136315138;
        *(void *)(v83 + 4) = v84;
        __SC_log_send(5LL, v78, v79, v81);
      }

      sub_3A5D4((uint64_t)a1, 0x12u);
      sub_4C520((void **)v8);
      sub_40A4C(v8 + 3);
      if (v8[1]) {
        timer_callout_free(v8 + 1);
      }
      CFMutableArrayRef v85 = (const char *)nullsub_1(v6);
      sub_34CD0(v85);
      uint64_t v86 = (const char *)nullsub_1(v6);
      sub_34F04(v86);
      sub_194CC((uint64_t)a1, 0LL);
      free(v8);
      return v17;
    case 3:
    case 8:
    case 11:
      if (*(_DWORD *)(a3 + 4) && !*(_DWORD *)(a3 + 8))
      {
        *(_DWORD *)(v7 + 36) = 0;
        goto LABEL_48;
      }

      if (*(_DWORD *)a3 == 1)
      {
        *(_DWORD *)(v7 + 68) = 0;
        uint64_t v18 = sub_14834((uint64_t)a1);
        uint64_t v19 = sub_194C4((uint64_t)a1);
        CFStringRef v20 = (const char *)nullsub_1(v18);
        sub_34CD0(v20);
        __n128 v21 = (const char *)nullsub_1(v18);
        sub_34F04(v21);
        uint64_t v22 = (const char *)nullsub_1(v18);
        sub_33EC0(v22);
        uint64_t v23 = *(void *)(v19 + 24);
        if (v23)
        {
          sub_404E4(v23);
          sub_40448(*(void *)(v19 + 24));
        }

        sub_3A5D4((uint64_t)a1, 0x13u);
        int v24 = 1;
      }

      else
      {
        int v24 = 1;
        if (a2 == 8) {
          goto LABEL_20;
        }
        if (a2 == 11) {
          int v24 = sub_3B2C0(a1);
        }
        if (*((_DWORD *)v8 + 9) == 1 && !v8[2]) {
          int v24 = 0;
        }
      }

      if (a2 != 8) {
        goto LABEL_22;
      }
LABEL_20:
LABEL_22:
      if (v24) {
        sub_3B594(a1);
      }
LABEL_48:
      uint64_t v31 = v8[3];
      if (v31)
      {
        int v32 = a2;
LABEL_50:
        DHCPv6ClientHandleEvent(v31, v32, (uint64_t *)a3);
      }

      return 0LL;
    case 4:
      sub_3B5C8((uint64_t)a1);
      uint64_t v27 = v8[3];
      if (v27) {
        sub_404E4(v27);
      }
      return 0LL;
    case 14:
      uint64_t v28 = *(void *)(v7 + 24);
      if (v28) {
        sub_40EE0(v28, a3);
      }
      uint64_t v29 = v8[2];
      if (!v29) {
        return 0LL;
      }
      uint64_t v17 = 0LL;
      *(void *)(a3 + 40) = v29;
      return v17;
    case 15:
      uint64_t v30 = *(void *)(v7 + 24);
      if (v30) {
        DHCPv6ClientHandleEvent(v30, 15, (uint64_t *)a3);
      }
      sub_3A678(a1, a3);
      return 0LL;
    case 16:
      uint64_t v31 = *(void *)(v7 + 24);
      if (!v31) {
        return 0LL;
      }
      int v32 = 16;
      goto LABEL_50;
    case 18:
      sub_3B634(a1, a3);
      return 0LL;
    case 19:
      uint64_t v43 = sub_57538();
      uint64_t v44 = _SC_syslog_os_log_mapping(5LL);
      if (__SC_log_enabled(5LL, v43, v44))
      {
        uint64_t v45 = _os_log_pack_size(12LL);
        __int128 v46 = &__str[-((__chkstk_darwin(v45) + 15) & 0xFFFFFFFFFFFFFFF0LL) - 8];
        __int128 v47 = __error();
        uint64_t v48 = _os_log_pack_fill(v46, v45, *v47, &dword_0, "RTADV %s: PLAT discovery failed", v88);
        uint64_t v49 = nullsub_1(v6);
        *(_DWORD *)uint64_t v48 = 136315138;
        *(void *)(v48 + 4) = v49;
        __SC_log_send(5LL, v43, v44, v46);
      }

      sub_39F78((uint64_t)a1, 0);
      return 0LL;
    case 21:
LABEL_44:
      sub_3B790(a1);
      return 0LL;
    case 22:
      uint64_t v33 = sub_194C4((uint64_t)a1);
      CFMutableStringRef Mutable = CFDictionaryCreateMutable(0LL, 0LL, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
      int v35 = Mutable;
      uint64_t v36 = *(unsigned int *)(v33 + 32);
      else {
        unsigned int v37 = off_64F38[v36];
      }
      sub_50228(Mutable, @"State", v37);
      uint64_t v39 = *(void *)(v33 + 16);
      if (v39)
      {
        __int128 v40 = sub_51ABC(v39);
        if (v40)
        {
          CFStringRef v41 = v40;
          CFDictionarySetValue(v35, @"RouterAdvertisement", v40);
          CFRelease(v41);
        }
      }

      CFDictionarySetValue((CFMutableDictionaryRef)a3, @"RTADV", v35);
      CFRelease(v35);
      uint64_t v42 = *(void *)(v33 + 24);
      if (v42) {
        sub_3FA84(v42, (__CFDictionary *)a3);
      }
      return 0LL;
    default:
      return v17;
  }

void sub_39E38(uint64_t a1, const char *a2, int a3)
{
  if (a3 == 2)
  {
    sub_17808((uint64_t)a2);
  }

  else if (a3 == 1)
  {
    sub_3B790(a2);
  }

void sub_39E5C(uint64_t a1, const void *a2)
{
  uint64_t v4 = sub_14834(a1);
  uint64_t v5 = sub_194C4(a1);
  uint64_t v6 = *(void *)(v5 + 16);
  if (!v6 || (sub_52CF8(v6, (char *)&v14, &v13, &v12) ? (BOOL v7 = v12 == 0) : (BOOL v7 = 1), v7))
  {
    sub_4FA18((const void **)(v5 + 88));
    if (!*(_DWORD *)(v5 + 76)) {
      return;
    }
    int v8 = 0;
  }

  else
  {
    if (a2)
    {
      uint64_t v9 = *(const void **)(v5 + 88);
      if (v9 && CFEqual(a2, v9)) {
        return;
      }
      CFRetain(a2);
      sub_4FA18((const void **)(v5 + 88));
      *(void *)(v5 + 88) = a2;
    }

    int v8 = 1;
  }

  uint64_t v10 = (const char *)nullsub_1(v4);
  if (sub_343E4(v10, &v14, &v13, v8)) {
    int v11 = v8;
  }
  else {
    int v11 = 0;
  }
  *(_DWORD *)(v5 + 76) = v11;
}

uint64_t sub_39F38(uint64_t a1)
{
  uint64_t v2 = sub_194C4(a1);
  return timer_set_relative(*(void *)(v2 + 8), 0LL, 0, (uint64_t)sub_3B7DC, a1, 0LL, 0LL);
}

void sub_39F78(uint64_t a1, int a2)
{
  char v61 = 0;
  uint64_t v4 = (const char *)sub_14834(a1);
  unsigned int v60 = 0;
  uint64_t v5 = sub_194C4(a1);
  uint64_t v6 = v5;
  if (!a2) {
    goto LABEL_4;
  }
  if (*(_DWORD *)(v5 + 56)) {
    return;
  }
  if (!*(void *)(v5 + 16))
  {
    uint64_t v18 = sub_57538();
    uint64_t v19 = _SC_syslog_os_log_mapping(5LL);
    if (__SC_log_enabled(5LL, v18, v19))
    {
      uint64_t v20 = _os_log_pack_size(12LL);
      __n128 v21 = (char *)&v59[-1] - ((__chkstk_darwin(v20) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v22 = __error();
      uint64_t v23 = _os_log_pack_fill(v21, v20, *v22, &dword_0, "RTADV %s: success yet ra is NULL?", v58);
      uint64_t v24 = nullsub_1(v4);
      *(_DWORD *)uint64_t v23 = 136315138;
      *(void *)(v23 + 4) = v24;
      __SC_log_send(5LL, v18, v19, v21);
    }
  }

  else
  {
LABEL_4:
    int v7 = sub_54228((uint64_t)v4);
    if (v7 == 6)
    {
      uint64_t v8 = 0LL;
      else {
        int v9 = 3;
      }
    }

    else if (v7 == 255)
    {
      uint64_t v8 = sub_19C18(a1);
      int v9 = 2;
    }

    else
    {
      int v9 = 0;
      uint64_t v8 = 0LL;
    }

    if (dword_6C04C == 3 || (dword_6C04C == 2 ? (BOOL v10 = v9 == 2) : (BOOL v10 = 0), v10))
    {
      uint64_t v11 = sub_4C1BC();
      if (v11)
      {
        __int16 v12 = (const void *)v11;
        uint64_t v58 = v4;
        int v13 = sub_54F6C((uint64_t)v4);
        sub_35A4C((uint64_t)&v62, v13);
        if (v63 >= 1)
        {
          int v14 = 0;
          int v15 = 0;
          uint64_t v16 = (_BYTE *)(v62 + 20);
          while (1)
          {
            if (*(v16 - 20) == 254 && (*(v16 - 19) & 0xC0) == 0x80)
            {
              if ((*v16 & 4) != 0) {
                IPv6AWDReportSetLinkLocalAddressDuplicated(v12);
              }
              goto LABEL_30;
            }

            if ((*v16 & 0x40) != 0) {
              break;
            }
LABEL_30:
            ++v15;
            v16 += 32;
            if (v15 >= v63) {
              goto LABEL_38;
            }
          }

          IPv6AWDReportSetAutoconfAddressAcquired(v12);
          int v17 = *(_DWORD *)v16;
          if ((*(_DWORD *)v16 & 4) != 0)
          {
            IPv6AWDReportSetAutoconfAddressDuplicated(v12);
            int v17 = *(_DWORD *)v16;
            if ((*(_DWORD *)v16 & 0x10) == 0)
            {
LABEL_27:
              if ((v17 & 8) == 0)
              {
LABEL_29:
                int v14 = 1;
                goto LABEL_30;
              }

void sub_3A5D4(uint64_t a1, unsigned int a2)
{
  uint64_t v4 = sub_194C4(a1);
  sub_3B908(a1, 0);
  *(_DWORD *)(v4 + 36) = 0;
  sub_4FA18((const void **)(v4 + 16));
  sub_3BA6C(v4);
  sub_3BAA8(a1);
  uint64_t v5 = sub_14834(a1);
  uint64_t v6 = (const char *)nullsub_1(v5);
  sub_33EC0(v6);
  sub_39E5C(a1, 0LL);
  sub_3BAE4(a1, 0);
  sub_17FEC(a1, a2);
  sub_19038(a1, 0);
  *(_DWORD *)(v4 + 80) = 0;
  sub_150A4(a1, 0);
}

void sub_3A678(const char *a1, uint64_t a2)
{
  uint64_t v115 = sub_14834((uint64_t)a1);
  uint64_t v4 = (const char *)sub_194C4((uint64_t)a1);
  uint64_t v5 = sub_57538();
  uint64_t v6 = _SC_syslog_os_log_mapping(7LL);
  uint64_t v116 = a2;
  if (__SC_log_enabled(7LL, v5, v6))
  {
    uint64_t v7 = _os_log_pack_size(12LL);
    uint64_t v8 = (char *)&v107 - ((__chkstk_darwin(v7) + 15) & 0xFFFFFFFFFFFFFFF0LL);
    int v9 = __error();
    uint64_t v10 = _os_log_pack_fill(v8, v7, *v9, &dword_0, "%s", v107);
    *(_DWORD *)uint64_t v10 = 136315138;
    *(void *)(v10 + 4) = "rtadv_address_changed_common";
    __SC_log_send(7LL, v5, v6, v8);
    a2 = v116;
  }

  uint64_t v11 = sub_3617C(a2);
  if (!v11)
  {
    uint64_t v13 = sub_57538();
    uint64_t v14 = _SC_syslog_os_log_mapping(6LL);
    uint64_t v19 = _os_log_pack_size(12LL);
    uint64_t v16 = (char *)&v107 - ((__chkstk_darwin(v19) + 15) & 0xFFFFFFFFFFFFFFF0LL);
    uint64_t v20 = *__error();
    uint64_t v18 = _os_log_pack_fill(v16, v19, v20, &dword_0, "RTADV %s: link-local address not present");
    goto LABEL_10;
  }

  int v12 = *(_DWORD *)(v11 + 20);
  if ((v12 & 6) != 0)
  {
    uint64_t v13 = sub_57538();
    if ((v12 & 4) != 0)
    {
      uint64_t v14 = _SC_syslog_os_log_mapping(5LL);
      uint64_t v46 = _os_log_pack_size(12LL);
      uint64_t v16 = (char *)&v107 - ((__chkstk_darwin(v46) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      __int128 v47 = __error();
      uint64_t v48 = _os_log_pack_fill( v16,  v46,  *v47,  &dword_0,  "RTADV %s: link-local address is duplicated",  v107);
      uint64_t v49 = nullsub_1(v115);
      *(_DWORD *)uint64_t v48 = 136315138;
      *(void *)(v48 + 4) = v49;
      uint64_t v23 = 5LL;
LABEL_26:
      __SC_log_send(v23, v13, v14, v16);
      return;
    }

    uint64_t v14 = _SC_syslog_os_log_mapping(6LL);
    uint64_t v15 = _os_log_pack_size(12LL);
    uint64_t v16 = (char *)&v107 - ((__chkstk_darwin(v15) + 15) & 0xFFFFFFFFFFFFFFF0LL);
    uint64_t v17 = *__error();
    uint64_t v18 = _os_log_pack_fill(v16, v15, v17, &dword_0, "RTADV %s: link-local address is not ready");
LABEL_10:
    uint64_t v21 = v18;
    uint64_t v22 = nullsub_1(v115);
    *(_DWORD *)uint64_t v21 = 136315138;
    *(void *)(v21 + 4) = v22;
    uint64_t v23 = 6LL;
    goto LABEL_26;
  }

  *((_DWORD *)v4 + 15) = (*(_DWORD *)(v11 + 20) & 0x202) == 0;
  uint64_t v24 = sub_57538();
  uint64_t v25 = _SC_syslog_os_log_mapping(6LL);
  uint64_t v26 = __SC_log_enabled(6LL, v24, v25);
  if ((_DWORD)v26)
  {
    uint64_t v27 = _os_log_pack_size(22LL);
    uint64_t v28 = (char *)&v107 - ((__chkstk_darwin(v27) + 15) & 0xFFFFFFFFFFFFFFF0LL);
    uint64_t v29 = __error();
    uint64_t v30 = _os_log_pack_fill( v28,  v27,  *v29,  &dword_0,  "RTADV %s: link-layer option in Router Solicitation is %sOK",  v107,  v108);
    uint64_t v31 = nullsub_1(v115);
    double v32 = "";
    if (!*((_DWORD *)v4 + 15)) {
      double v32 = "not ";
    }
    *(_DWORD *)uint64_t v30 = 136315394;
    *(void *)(v30 + 4) = v31;
    *(_WORD *)(v30 + 12) = 2080;
    *(void *)(v30 + 14) = v32;
    uint64_t v26 = __SC_log_send(6LL, v24, v25, v28);
  }

  int v33 = *((_DWORD *)v4 + 9);
  if (!v33)
  {
    uint64_t v26 = sub_19384((uint64_t)a1);
    if (!(_DWORD)v26 || (v26 & 0xFFFFFFFF00000000LL) == 0x100000000LL)
    {
      uint64_t v34 = sub_57538();
      uint64_t v35 = _SC_syslog_os_log_mapping(5LL);
      if (__SC_log_enabled(5LL, v34, v35))
      {
        uint64_t v36 = _os_log_pack_size(12LL);
        double v37 = (char *)&v107 - ((__chkstk_darwin(v36) + 15) & 0xFFFFFFFFFFFFFFF0LL);
        int v38 = __error();
        uint64_t v39 = _os_log_pack_fill( v37,  v36,  *v38,  &dword_0,  "RTADV %s: link-local address is ready, starting",  v107);
        uint64_t v40 = nullsub_1(v115);
        *(_DWORD *)uint64_t v39 = 136315138;
        *(void *)(v39 + 4) = v40;
        __SC_log_send(5LL, v34, v35, v37);
      }

      sub_3C3BC(a1, 0, 0LL);
    }
  }

  if (!(*((_DWORD *)v4 + 16) | v33)) {
    return;
  }
  __int128 v110 = &v107;
  uint64_t v41 = v116;
  __chkstk_darwin(v26);
  uint64_t v43 = &(&v107)[-4 * v42];
  uint64_t v117 = 0LL;
  sub_360D0((uint64_t)&v123);
  uint64_t v45 = *((void *)v4 + 3);
  if (v45)
  {
    sub_40F90(v45, (uint64_t)&v123);
    HIDWORD(v107) = v124 != 0;
  }

  else
  {
    HIDWORD(v107) = 0;
  }

  unint64_t v109 = a1;
  if (*(int *)(v41 + 8) <= 0)
  {
    sub_36090((uint64_t)&v123);
    LODWORD(v50) = 0;
    int v68 = 0;
    int v69 = 0;
LABEL_44:
    if (*((_DWORD *)v4 + 18))
    {
      uint64_t v70 = sub_57538();
      uint64_t v71 = _SC_syslog_os_log_mapping(5LL);
      if (__SC_log_enabled(5LL, v70, v71))
      {
        uint64_t v72 = _os_log_pack_size(12LL);
        uint64_t v73 = (char *)&v107 - ((__chkstk_darwin(v72) + 15) & 0xFFFFFFFFFFFFFFF0LL);
        uint64_t v74 = __error();
        uint64_t v75 = _os_log_pack_fill(v73, v72, *v74, &dword_0, "RTADV %s: autoconf addresses expired", v107);
        uint64_t v76 = nullsub_1(v115);
        *(_DWORD *)uint64_t v75 = 136315138;
        *(void *)(v75 + 4) = v76;
        __SC_log_send(5LL, v70, v71, v73);
      }

      uint64_t v77 = v109;
      sub_39F78((uint64_t)v109, 0);
      sub_3C934(v77, 0);
    }

    else
    {
      int v51 = 0;
      if ((_DWORD)v50) {
        goto LABEL_49;
      }
    }

    return;
  }

  unsigned int v108 = v4;
  uint64_t v50 = 0LL;
  int v51 = 0;
  uint64_t v114 = 0LL;
  int v52 = 0;
  uint64_t v53 = *(void *)v41;
  *(void *)&__int128 v44 = 136315138LL;
  __int128 v111 = v44;
  do
  {
    unsigned int v54 = *(_DWORD *)(v53 + 20);
    unsigned int v55 = v54 & 0x40;
    if ((v54 & 6) != 0)
    {
      if ((v54 & 4) != 0)
      {
        uint64_t v56 = sub_57538();
        uint64_t v57 = _SC_syslog_os_log_mapping(5LL);
        if (__SC_log_enabled(5LL, v56, v57))
        {
          uint64_t v58 = _os_log_pack_size(12LL);
          int v112 = &v107;
          uint64_t v59 = __chkstk_darwin(v58);
          uint64_t v113 = v50;
          unsigned int v60 = v43;
          char v61 = (char *)&v107 - ((v59 + 15) & 0xFFFFFFFFFFFFFFF0LL);
          uint64_t v62 = __error();
          uint64_t v63 = _os_log_pack_fill(v61, v58, *v62, &dword_0, "RTADV %s: duplicated address", v107);
          uint64_t v64 = nullsub_1(v115);
          *(_DWORD *)uint64_t v63 = v111;
          *(void *)(v63 + 4) = v64;
          uint64_t v41 = v116;
          uint64_t v65 = v61;
          uint64_t v43 = v60;
          uint64_t v50 = v113;
          __SC_log_send(5LL, v56, v57, v65);
        }
      }
    }

    else
    {
      if ((v54 & 0x40) != 0)
      {
        LODWORD(v114) = ((v54 >> 3) & 1) + v114;
        HIDWORD(v114) += (v54 >> 4) & 1;
LABEL_38:
        __int128 v66 = *(_OWORD *)(v53 + 16);
        uint64_t v67 = &v43[4 * (int)v50];
        *(_OWORD *)uint64_t v67 = *(_OWORD *)v53;
        *((_OWORD *)v67 + 1) = v66;
        uint64_t v50 = (v50 + 1);
        goto LABEL_39;
      }
    }

LABEL_39:
    v51 += v55 >> 6;
    ++v52;
    v53 += 32LL;
  }

  while (v52 < *(_DWORD *)(v41 + 8));
  sub_36090((uint64_t)&v123);
  uint64_t v4 = v108;
  int v69 = v114;
  int v68 = HIDWORD(v114);
  if (!v51) {
    goto LABEL_44;
  }
  if (!(_DWORD)v50) {
    return;
  }
LABEL_49:
  int v78 = v50;
  if (v51)
  {
    if (v68 + v69 == v51)
    {
      uint64_t v79 = sub_57538();
      uint64_t v80 = _SC_syslog_os_log_mapping(5LL);
      if (__SC_log_enabled(5LL, v79, v80))
      {
        uint64_t v81 = _os_log_pack_size(12LL);
        CFStringRef v82 = (char *)&v107 - ((__chkstk_darwin(v81) + 15) & 0xFFFFFFFFFFFFFFF0LL);
        uint64_t v83 = __error();
        uint64_t v84 = _os_log_pack_fill( v82,  v81,  *v83,  &dword_0,  "RTADV %s: all autoconf addresses detached/deprecated",  v107);
        uint64_t v85 = nullsub_1(v115);
        *(_DWORD *)uint64_t v84 = 136315138;
        *(void *)(v84 + 4) = v85;
        __SC_log_send(5LL, v79, v80, v82);
      }
    }
  }

  *((_DWORD *)v4 + 18) = v51 != 0;
  __int128 v119 = 0u;
  __int128 v120 = 0u;
  __int128 v122 = 0u;
  memset(v121, 0, sizeof(v121));
  memset(v118, 0, sizeof(v118));
  if (*((void *)v4 + 2))
  {
    uint64_t v86 = *((void *)v4 + 3);
    uint64_t v87 = (uint64_t)v109;
    int v88 = sub_19020(v87);
    *((void *)&v119 + 1) = *((void *)v4 + 2);
    v121[0] = sub_3CB14(*((uint64_t *)&v119 + 1));
    if (v121[0] || sub_19320(v87))
    {
      sub_191BC(v87, 1);
      if (v121[0]) {
        sub_39E5C(v87, v121[0]);
      }
      if (sub_17444(v87)) {
        goto LABEL_66;
      }
      CFMutableDictionaryRef v92 = (const void *)sub_194A8(v87);
    }

    else
    {
      sub_191BC(v87, 0);
LABEL_66:
      sub_39E5C(v87, 0LL);
      if (v4[160])
      {
        sub_3BAE4(v87, 0);
        sub_19038(v87, 0);
      }
    }

    CFRange v91 = (void *)sub_51AB4(*((void *)v4 + 2));
    uint64_t v93 = *((void *)v4 + 2);
    if (v93 && (unsigned int v94 = sub_5262C(v93, &v126)) != 0LL)
    {
      uint64_t v95 = (uint64_t)v94;
      int8x16_t v125 = *(int8x16_t *)v43;
      uint64_t v96 = *((unsigned int *)v43 + 4);
      sub_3489C(&v125, *((_DWORD *)v43 + 4));
      CFMutableStringRef Mutable = CFStringCreateMutable(0LL, 0LL);
      uint64_t v97 = inet_ntop(30, &v125, v127, 0x2Eu);
      CFStringAppendFormat(Mutable, 0LL, @"IPv6.Prefix=%s/%d;IPv6.RouterHardwareAddress=", v97, v96);
      sub_5040C(Mutable, v95, v126, 58);
    }

    else
    {
      CFMutableStringRef Mutable = 0LL;
    }

    uint64_t v117 = Mutable;
    uint64_t v90 = 1LL;
  }

  else
  {
    CFMutableStringRef Mutable = 0LL;
    uint64_t v90 = 0LL;
    CFRange v91 = 0LL;
    uint64_t v87 = (uint64_t)v109;
  }

  sub_16BA4(v87, v43, v78, v91, v90, (uint64_t)v118, Mutable);
  sub_4FA18((const void **)&v117);
  sub_4FA18((const void **)&v120 + 1);
  sub_4FA18(v121);
  if (*((void *)v4 + 2))
  {
    uint64_t v98 = *(void *)(sub_194C4(v87) + 24);
    if (!v98 || !sub_3F9FC(v98)) {
      sub_39F78(v87, 1);
    }
    uint64_t v99 = *((void *)v4 + 3);
    if (v99 && sub_3F9FC(v99))
    {
      uint64_t v100 = sub_57538();
      uint64_t v101 = _SC_syslog_os_log_mapping(5LL);
      if (__SC_log_enabled(5LL, v100, v101))
      {
        uint64_t v102 = _os_log_pack_size(12LL);
        uint64_t v103 = (char *)&v107 - ((__chkstk_darwin(v102) + 15) & 0xFFFFFFFFFFFFFFF0LL);
        uint64_t v104 = __error();
        uint64_t v105 = _os_log_pack_fill(v103, v102, *v104, &dword_0, "%s: DHCPv6 client still active", v107);
        uint64_t v106 = nullsub_1(v115);
        *(_DWORD *)uint64_t v105 = 136315138;
        *(void *)(v105 + 4) = v106;
        __SC_log_send(5LL, v100, v101, v103);
      }
    }

    else
    {
      sub_150A4(v87, 0);
    }
  }

  if (*((_DWORD *)v4 + 16))
  {
    sub_3D2BC(v87, (uint64_t)v43, v78);
    *((_DWORD *)v4 + 16) = 0;
  }

uint64_t sub_3B2C0(const char *a1)
{
  HIWORD(v26) = 0;
  uint64_t v2 = sub_14834((uint64_t)a1);
  uint64_t v3 = sub_194C4((uint64_t)a1);
  if (!*(void *)(v3 + 16)) {
    return 0LL;
  }
  uint64_t v4 = v3;
  double current_time = timer_get_current_time();
  double v6 = sub_52B24(*(void *)(v4 + 16), (BOOL *)&v26 + 7, (char *)&v26 + 6, current_time);
  if (!HIBYTE(v26)) {
    return 0LL;
  }
  double v7 = v6;
  uint64_t result = sub_4E330(v4 + 104);
  if (!(_DWORD)result) {
    return result;
  }
  if (!BYTE6(v26))
  {
    double v16 = sub_4E7B8(v4 + 104);
    if (v16 != 0.0)
    {
      double v17 = v16;
      if (v16 < v7)
      {
        sub_3DE40(a1);
        double v7 = v17;
      }
    }

    if (v7 != 0.0)
    {
      CFDateRef v18 = CFDateCreate(0LL, v7);
      uint64_t v19 = sub_57538();
      uint64_t v20 = _SC_syslog_os_log_mapping(6LL);
      if (__SC_log_enabled(6LL, v19, v20))
      {
        uint64_t v21 = _os_log_pack_size(32LL);
        uint64_t v22 = (char *)&v26 - ((__chkstk_darwin(v21) + 15) & 0xFFFFFFFFFFFFFFF0LL);
        uint64_t v23 = __error();
        uint64_t v24 = _os_log_pack_fill(v22, v21, *v23, &dword_0, "%s %s: DNS expiration time %@");
        uint64_t v25 = nullsub_1(v2);
        *(_DWORD *)uint64_t v24 = 136315650;
        *(void *)(v24 + 4) = "rtadv_handle_wake";
        *(_WORD *)(v24 + 12) = 2080;
        *(void *)(v24 + 14) = v25;
        *(_WORD *)(v24 + 22) = 2112;
        *(void *)(v24 + 24) = v18;
        __SC_log_send(6LL, v19, v20, v22);
      }

      CFRelease(v18);
      timer_callout_set_absolute(*(void *)(v4 + 8), (uint64_t)sub_3D668, (uint64_t)a1, 2LL, 0LL, v7);
    }

    return 0LL;
  }

  uint64_t v9 = sub_57538();
  uint64_t v10 = _SC_syslog_os_log_mapping(5LL);
  if (__SC_log_enabled(5LL, v9, v10))
  {
    uint64_t v11 = _os_log_pack_size(12LL);
    int v12 = (char *)&v26 - ((__chkstk_darwin(v11) + 15) & 0xFFFFFFFFFFFFFFF0LL);
    uint64_t v13 = __error();
    uint64_t v14 = _os_log_pack_fill(v12, v11, *v13, &dword_0, "RTADV %s: DNS expired", v26);
    uint64_t v15 = nullsub_1(v2);
    *(_DWORD *)uint64_t v14 = 136315138;
    *(void *)(v14 + 4) = v15;
    __SC_log_send(5LL, v9, v10, v12);
  }

  timer_cancel(*(void *)(v4 + 8));
  return 1LL;
}

void sub_3B594(const char *a1)
{
  *(_DWORD *)(sub_194C4((uint64_t)a1) + 36) = 0;
  sub_3B790(a1);
  sub_150A4((uint64_t)a1, 1);
}

void sub_3B5C8(uint64_t a1)
{
  uint64_t v2 = sub_14834(a1);
  sub_3B908(a1, 0);
  uint64_t v3 = sub_194C4(a1);
  uint64_t v4 = (const char *)nullsub_1(v2);
  sub_34CD0(v4);
  uint64_t v5 = (const char *)nullsub_1(v2);
  sub_34F04(v5);
  sub_3A5D4(a1, 0xCu);
  *(_DWORD *)(v3 + 68) = 0;
}

void sub_3B634(const char *a1, uint64_t a2)
{
  uint64_t v4 = sub_14834((uint64_t)a1);
  uint64_t v5 = sub_57538();
  uint64_t v6 = _SC_syslog_os_log_mapping(5LL);
  if (__SC_log_enabled(5LL, v5, v6))
  {
    uint64_t v7 = _os_log_pack_size(12LL);
    uint64_t v8 = (char *)&v12 - ((__chkstk_darwin(v7) + 15) & 0xFFFFFFFFFFFFFFF0LL);
    uint64_t v9 = __error();
    uint64_t v10 = _os_log_pack_fill(v8, v7, *v9, &dword_0, "RTADV %s: router expired", v12);
    uint64_t v11 = nullsub_1(v4);
    *(_DWORD *)uint64_t v10 = 136315138;
    *(void *)(v10 + 4) = v11;
    __SC_log_send(5LL, v5, v6, v8);
  }

  sub_39F78((uint64_t)a1, 0);
  if (*(_DWORD *)(a2 + 4)) {
    sub_3C3BC(a1, 0, 0LL);
  }
  else {
    sub_3C934(a1, 0);
  }
}

void sub_3B790(const char *a1)
{
  uint64_t v2 = sub_14834((uint64_t)a1);
  int v3 = sub_54F6C(v2);
  sub_35A4C((uint64_t)v4, v3);
  sub_3A678(a1, (uint64_t)v4);
  sub_36090((uint64_t)v4);
}

void sub_3B7DC(const char *a1)
{
  uint64_t v2 = sub_14834((uint64_t)a1);
  uint64_t v3 = sub_57538();
  uint64_t v4 = _SC_syslog_os_log_mapping(5LL);
  if (__SC_log_enabled(5LL, v3, v4))
  {
    uint64_t v5 = _os_log_pack_size(12LL);
    uint64_t v6 = (char *)&v10 - ((__chkstk_darwin(v5) + 15) & 0xFFFFFFFFFFFFFFF0LL);
    uint64_t v7 = __error();
    uint64_t v8 = _os_log_pack_fill(v6, v5, *v7, &dword_0, "RTADV %s: start", v10);
    uint64_t v9 = nullsub_1(v2);
    *(_DWORD *)uint64_t v8 = 136315138;
    *(void *)(v8 + 4) = v9;
    __SC_log_send(5LL, v3, v4, v6);
  }

  sub_3B594(a1);
}

uint64_t sub_3B908(uint64_t a1, unsigned int a2)
{
  uint64_t v4 = sub_14834(a1);
  uint64_t v5 = sub_194C4(a1);
  uint64_t v6 = sub_57538();
  uint64_t v7 = _SC_syslog_os_log_mapping(5LL);
  uint64_t result = __SC_log_enabled(5LL, v6, v7);
  if ((_DWORD)result)
  {
    uint64_t v9 = _os_log_pack_size(22LL);
    uint64_t v10 = (char *)v15 - ((__chkstk_darwin(v9) + 15) & 0xFFFFFFFFFFFFFFF0LL);
    uint64_t v11 = __error();
    uint64_t v12 = _os_log_pack_fill(v10, v9, *v11, &dword_0, "RTADV %s: %s", v15[0], v15[1]);
    uint64_t v13 = nullsub_1(v4);
    if (a2 > 3) {
      uint64_t v14 = "<unknown>";
    }
    else {
      uint64_t v14 = off_64F38[a2];
    }
    *(_DWORD *)uint64_t v12 = 136315394;
    *(void *)(v12 + 4) = v13;
    *(_WORD *)(v12 + 12) = 2080;
    *(void *)(v12 + 14) = v14;
    uint64_t result = __SC_log_send(5LL, v6, v7, v10);
  }

  *(_DWORD *)(v5 + 32) = a2;
  return result;
}

void sub_3BA6C(uint64_t a1)
{
  uint64_t v2 = (const void **)(a1 + 96);
  if (*(void *)(a1 + 96))
  {
    PvDInfoRequestCancel();
    sub_4FA18(v2);
  }

  sub_4E220(a1 + 104, 0);
}

uint64_t sub_3BAA8(uint64_t a1)
{
  BOOL v1 = (uint64_t *)sub_194C4(a1);
  timer_cancel(v1[1]);
  uint64_t result = *v1;
  if (*v1) {
    return sub_4CA50(result);
  }
  return result;
}

uint64_t sub_3BAE4(uint64_t a1, int a2)
{
  v56[0] = 0LL;
  uint64_t v4 = sub_14834(a1);
  uint64_t v5 = sub_194C4(a1);
  uint64_t v6 = sub_31700();
  if ((v6 & 0x80000000) == 0)
  {
    uint64_t v7 = v6;
    uint64_t v8 = (const char *)nullsub_1(v4);
    sub_31DF8(v8, 0);
    int v10 = *(unsigned __int8 *)(v5 + 160);
    if (!*(_BYTE *)(v5 + 160))
    {
LABEL_12:
      if (a2) {
        sub_3C1EC(v7, v4, v10, v9);
      }
      uint64_t v49 = nullsub_1(v4);
      sub_31710(v7, v49, v56);
      if ((v56[0] & 0x1000LL) != 0)
      {
        uint64_t v50 = nullsub_1(v4);
        sub_357E8(v50);
      }

      close(v7);
      return sub_154A8(a1);
    }

    uint64_t v11 = nullsub_1(v4);
    sub_3BF14(v11, v10);
    *(_BYTE *)(v5 + 160) = 0;
    unsigned int v12 = bswap32(v10 | 0xC0000000);
    uint64_t v13 = (const char *)nullsub_1(v4);
    if (sub_326AC(v7, v13, v12))
    {
      int v14 = *__error();
      uint64_t v15 = sub_57538();
      uint64_t v16 = _SC_syslog_os_log_mapping(5LL);
      unsigned int v17 = v16;
      if (__SC_log_enabled(5LL, v15, v16))
      {
        unsigned int v54 = HIBYTE(v12);
        uint64_t v18 = _os_log_pack_size(52LL);
        unsigned int v55 = &v51;
        uint64_t v19 = __chkstk_darwin(v18);
        unsigned int v53 = v17;
        uint64_t v20 = (char *)&v51 - ((v19 + 15) & 0xFFFFFFFFFFFFFFF0LL);
        uint64_t v21 = __error();
        uint64_t v22 = _os_log_pack_fill( v20,  v18,  *v21,  &dword_0,  "RTADV %s: remove CLAT46 address %d.%d.%d.%d failed, %s (%d)",  v51,  v52,  v53,  (_DWORD)v55,  LODWORD(v56[0]),  (const char *)v56[1],  v57);
        uint64_t v23 = nullsub_1(v4);
        uint64_t v52 = v15;
        int v24 = a2;
        uint64_t v25 = v23;
        uint64_t v26 = strerror(v14);
        *(_DWORD *)uint64_t v22 = 136316674;
        *(void *)(v22 + 4) = v25;
        a2 = v24;
        *(_WORD *)(v22 + 12) = 1024;
        *(_DWORD *)(v22 + 14) = 192;
        *(_WORD *)(v22 + 18) = 1024;
        *(_DWORD *)(v22 + 20) = 0;
        *(_WORD *)(v22 + 24) = 1024;
        *(_DWORD *)(v22 + 26) = 0;
        *(_WORD *)(v22 + 30) = 1024;
        uint64_t v27 = v53;
        *(_DWORD *)(v22 + 32) = v54;
        *(_WORD *)(v22 + 36) = 2080;
        *(void *)(v22 + 38) = v26;
        *(_WORD *)(v22 + 46) = 1024;
        *(_DWORD *)(v22 + 48) = v14;
        uint64_t v28 = v52;
        uint64_t v29 = v20;
LABEL_10:
        __SC_log_send(5LL, v28, v27, v29);
      }
    }

    else
    {
      uint64_t v40 = sub_57538();
      uint64_t v41 = _SC_syslog_os_log_mapping(5LL);
      if (__SC_log_enabled(5LL, v40, v41))
      {
        uint64_t v42 = _os_log_pack_size(36LL);
        unsigned int v55 = &v51;
        uint64_t v43 = __chkstk_darwin(v42);
        unsigned int v54 = HIBYTE(v12);
        __int128 v44 = (char *)&v51 - ((v43 + 15) & 0xFFFFFFFFFFFFFFF0LL);
        uint64_t v45 = __error();
        uint64_t v46 = _os_log_pack_fill( v44,  v42,  *v45,  &dword_0,  "RTADV %s: removed CLAT46 address %d.%d.%d.%d",  v51,  v52,  v53,  (_DWORD)v55,  LODWORD(v56[0]));
        uint64_t v47 = nullsub_1(v4);
        *(_DWORD *)uint64_t v46 = 136316162;
        *(void *)(v46 + 4) = v47;
        *(_WORD *)(v46 + 12) = 1024;
        *(_DWORD *)(v46 + 14) = 192;
        *(_WORD *)(v46 + 18) = 1024;
        *(_DWORD *)(v46 + 20) = 0;
        *(_WORD *)(v46 + 24) = 1024;
        *(_DWORD *)(v46 + 26) = 0;
        *(_WORD *)(v46 + 30) = 1024;
        *(_DWORD *)(v46 + 32) = v54;
        uint64_t v28 = v40;
        uint64_t v27 = v41;
        uint64_t v29 = v44;
        goto LABEL_10;
      }
    }

    int v48 = sub_54F6C(v4);
    sub_37000(v48, 0, v12);
    goto LABEL_12;
  }

  uint64_t v30 = sub_57538();
  uint64_t v31 = _SC_syslog_os_log_mapping(3LL);
  uint64_t result = __SC_log_enabled(3LL, v30, v31);
  if ((_DWORD)result)
  {
    uint64_t v33 = _os_log_pack_size(18LL);
    uint64_t v34 = (char *)&v51 - ((__chkstk_darwin(v33) + 15) & 0xFFFFFFFFFFFFFFF0LL);
    uint64_t v35 = __error();
    uint64_t v36 = _os_log_pack_fill(v34, v33, *v35, &dword_0, "socket failed, %s (%d)", v51, v52);
    double v37 = __error();
    int v38 = strerror(*v37);
    int v39 = *__error();
    *(_DWORD *)uint64_t v36 = 136315394;
    *(void *)(v36 + 4) = v38;
    *(_WORD *)(v36 + 12) = 1024;
    *(_DWORD *)(v36 + 14) = v39;
    return __SC_log_send(3LL, v30, v31, v34);
  }

  return result;
}

uint64_t sub_3BF14(uint64_t a1, int a2)
{
  if ((a2 - 6) <= 0xFBu)
  {
    uint64_t v4 = sub_57538();
    uint64_t v5 = _SC_syslog_os_log_mapping(5LL);
    uint64_t result = __SC_log_enabled(5LL, v4, v5);
    if (!(_DWORD)result) {
      return result;
    }
    uint64_t v7 = _os_log_pack_size(18LL);
    uint64_t v8 = (char *)&v21 - ((__chkstk_darwin(v7) + 15) & 0xFFFFFFFFFFFFFFF0LL);
    uint64_t v9 = *__error();
    uint64_t v10 = _os_log_pack_fill(v8, v7, v9, &dword_0, "%s: CLAT46 partial address %d is invalid");
LABEL_10:
    *(_DWORD *)uint64_t v10 = 136315394;
    *(void *)(v10 + 4) = a1;
    *(_WORD *)(v10 + 12) = 1024;
    *(_DWORD *)(v10 + 14) = a2;
    return __SC_log_send(5LL, v4, v5, v8);
  }

  uint64_t v11 = (a2 - 2);
  int v12 = word_6C278[v11];
  if (!word_6C278[v11])
  {
    uint64_t v4 = sub_57538();
    uint64_t v5 = _SC_syslog_os_log_mapping(5LL);
    uint64_t result = __SC_log_enabled(5LL, v4, v5);
    if (!(_DWORD)result) {
      return result;
    }
    uint64_t v15 = _os_log_pack_size(18LL);
    uint64_t v8 = (char *)&v21 - ((__chkstk_darwin(v15) + 15) & 0xFFFFFFFFFFFFFFF0LL);
    uint64_t v16 = *__error();
    uint64_t v10 = _os_log_pack_fill(v8, v15, v16, &dword_0, "%s: CLAT46 192.0.0.%d is already released!");
    goto LABEL_10;
  }

  word_6C278[v11] = v12 - 1;
  uint64_t v4 = sub_57538();
  uint64_t v5 = _SC_syslog_os_log_mapping(5LL);
  uint64_t result = __SC_log_enabled(5LL, v4, v5);
  if (v12 == 1)
  {
    if (!(_DWORD)result) {
      return result;
    }
    uint64_t v13 = _os_log_pack_size(18LL);
    uint64_t v8 = (char *)&v21 - ((__chkstk_darwin(v13) + 15) & 0xFFFFFFFFFFFFFFF0LL);
    uint64_t v14 = *__error();
    uint64_t v10 = _os_log_pack_fill(v8, v13, v14, &dword_0, "%s: CLAT46 192.0.0.%d released");
    goto LABEL_10;
  }

  if ((_DWORD)result)
  {
    uint64_t v17 = _os_log_pack_size(24LL);
    uint64_t v8 = (char *)&v21 - ((__chkstk_darwin(v17) + 15) & 0xFFFFFFFFFFFFFFF0LL);
    uint64_t v18 = __error();
    uint64_t v19 = _os_log_pack_fill(v8, v17, *v18, &dword_0, "%s: CLAT46 192.0.0.%d use count %d", v21, v22, v23);
    int v20 = word_6C278[v11];
    *(_DWORD *)uint64_t v19 = 136315650;
    *(void *)(v19 + 4) = a1;
    *(_WORD *)(v19 + 12) = 1024;
    *(_DWORD *)(v19 + 14) = a2;
    *(_WORD *)(v19 + 18) = 1024;
    *(_DWORD *)(v19 + 20) = v20;
    return __SC_log_send(5LL, v4, v5, v8);
  }

  return result;
}

uint64_t sub_3C1EC(uint64_t result, uint64_t a2, int a3, __n128 a4)
{
  int v6 = result;
  uint64_t v22 = 0LL;
  int v7 = 2;
  a4.n128_u64[0] = 136316162LL;
  __n128 v20 = a4;
  do
  {
    if (a3 != v7)
    {
      unsigned int v8 = bswap32(v7 | 0xC0000000);
      uint64_t v9 = (const char *)nullsub_1(a2);
      int v10 = v8 & 0x7F000000 | 0xC0;
      uint64_t result = sub_326AC(v6, v9, v10);
      if (!(_DWORD)result)
      {
        uint64_t v11 = sub_57538();
        uint64_t v12 = _SC_syslog_os_log_mapping(5LL);
        if (__SC_log_enabled(5LL, v11, v12))
        {
          unsigned int v13 = HIBYTE(v8);
          uint64_t v14 = _os_log_pack_size(36LL);
          uint64_t v23 = &v20;
          uint64_t v15 = (char *)&v20 - ((__chkstk_darwin(v14) + 15) & 0xFFFFFFFFFFFFFFF0LL);
          uint64_t v16 = __error();
          uint64_t v17 = _os_log_pack_fill( v15,  v14,  *v16,  &dword_0,  "RTADV %s: removed CLAT46 address %d.%d.%d.%d",  (const char *)v20.n128_u64[0],  v20.n128_u32[2],  v21,  v22,  (_DWORD)v23);
          uint64_t v18 = nullsub_1(a2);
          *(_DWORD *)uint64_t v17 = v20.n128_u32[0];
          *(void *)(v17 + 4) = v18;
          *(_WORD *)(v17 + 12) = 1024;
          *(_DWORD *)(v17 + 14) = 192;
          *(_WORD *)(v17 + 18) = 1024;
          *(_DWORD *)(v17 + 20) = 0;
          *(_WORD *)(v17 + 24) = 1024;
          *(_DWORD *)(v17 + 26) = 0;
          *(_WORD *)(v17 + 30) = 1024;
          *(_DWORD *)(v17 + 32) = v13;
          __SC_log_send(5LL, v11, v12, v15);
        }

        int v19 = sub_54F6C(a2);
        uint64_t result = sub_37000(v19, v22, v10);
      }
    }

    ++v7;
  }

  while (v7 != 6);
  return result;
}

void sub_3C3BC(const char *a1, int a2, const void *a3)
{
  uint64_t v6 = sub_14834((uint64_t)a1);
  uint64_t v7 = sub_194C4((uint64_t)a1);
  if (a2 == 5)
  {
  }

  else
  {
    uint64_t v8 = v7;
    if (a2 != 2)
    {
      if (a2) {
        return;
      }
      sub_3B908((uint64_t)a1, 1u);
      sub_19358((uint64_t)a1);
      sub_150A4((uint64_t)a1, 1);
      *(CFAbsoluteTime *)(v8 + 40) = timer_get_current_time();
      *(void *)(v8 + 48) = 0LL;
      *(_DWORD *)(v8 + 56) = 0;
      *(_DWORD *)(v8 + 80) = 0;
      sub_174D0((uint64_t)a1);
      sub_3BAE4((uint64_t)a1, 1);
      sub_19038((uint64_t)a1, 0);
      sub_3BAA8((uint64_t)a1);
      sub_4C6AC(*(void **)v8, (uint64_t)sub_3C3BC, (uint64_t)a1, 5LL);
      uint64_t v9 = (char *)nullsub_1(v6);
      BOOL v10 = sub_19C20((uint64_t)a1);
      if (sub_33A24(v9, v10))
      {
        sub_3A5D4((uint64_t)a1, 6u);
        return;
      }

      *(_DWORD *)(v8 + 36) = 0;
      sub_4FA18((const void **)(v8 + 16));
      *(_DWORD *)(v8 + 72) = 0;
    }

    int v11 = *(_DWORD *)(v8 + 36);
    *(_DWORD *)(v8 + 36) = v11 + 1;
    if (v11 < 1) {
      goto LABEL_20;
    }
    if (sub_19384((uint64_t)a1) == 1)
    {
      sub_3B5C8((uint64_t)a1);
      return;
    }

    if (sub_17444((uint64_t)a1))
    {
      uint64_t v12 = sub_57538();
      uint64_t v13 = _SC_syslog_os_log_mapping(6LL);
      if (__SC_log_enabled(6LL, v12, v13))
      {
        uint64_t v14 = _os_log_pack_size(12LL);
        uint64_t v15 = (char *)&v42 - ((__chkstk_darwin(v14) + 15) & 0xFFFFFFFFFFFFFFF0LL);
        uint64_t v16 = __error();
        uint64_t v17 = _os_log_pack_fill(v15, v14, *v16, &dword_0, "RTADV %s: IPv4 is ready, release busy", v42);
        uint64_t v18 = nullsub_1(v6);
        *(_DWORD *)uint64_t v17 = 136315138;
        *(void *)(v17 + 4) = v18;
        __SC_log_send(6LL, v12, v13, v15);
      }

      sub_150A4((uint64_t)a1, 0);
    }

    int v19 = *(_DWORD *)(v8 + 36);
    if (v19 < 4)
    {
LABEL_20:
      uint64_t v23 = sub_57538();
      uint64_t v24 = _SC_syslog_os_log_mapping(5LL);
      if (__SC_log_enabled(5LL, v23, v24))
      {
        uint64_t v25 = _os_log_pack_size(24LL);
        uint64_t v26 = (char *)&v42 - ((__chkstk_darwin(v25) + 15) & 0xFFFFFFFFFFFFFFF0LL);
        uint64_t v27 = __error();
        uint64_t v28 = _os_log_pack_fill( v26,  v25,  *v27,  &dword_0,  "RTADV %s: sending Router Solicitation (%d of %d)",  v42,  (_DWORD)v43,  v44);
        uint64_t v29 = nullsub_1(v6);
        int v30 = *(_DWORD *)(v8 + 36);
        *(_DWORD *)uint64_t v28 = 136315650;
        *(void *)(v28 + 4) = v29;
        *(_WORD *)(v28 + 12) = 1024;
        *(_DWORD *)(v28 + 14) = v30;
        *(_WORD *)(v28 + 18) = 1024;
        *(_DWORD *)(v28 + 20) = 3;
        __SC_log_send(5LL, v23, v24, v26);
      }

      unsigned int v31 = sub_4CD54(*(void *)v8, *(_DWORD *)(v8 + 60) != 0);
      if (v31 > 0x32 || ((1LL << v31) & 0x6000000000041LL) == 0)
      {
        int v33 = v31;
        uint64_t v34 = sub_57538();
        uint64_t v35 = _SC_syslog_os_log_mapping(3LL);
        if (__SC_log_enabled(3LL, v34, v35))
        {
          uint64_t v36 = _os_log_pack_size(22LL);
          double v37 = (char *)&v42 - ((__chkstk_darwin(v36) + 15) & 0xFFFFFFFFFFFFFFF0LL);
          int v38 = __error();
          uint64_t v39 = _os_log_pack_fill( v37,  v36,  *v38,  &dword_0,  "RTADV %s: send Router Solicitation: failed, %s",  v42,  v43);
          uint64_t v40 = nullsub_1(v6);
          uint64_t v41 = strerror(v33);
          *(_DWORD *)uint64_t v39 = 136315394;
          *(void *)(v39 + 4) = v40;
          *(_WORD *)(v39 + 12) = 2080;
          *(void *)(v39 + 14) = v41;
          __SC_log_send(3LL, v34, v35, v37);
        }
      }

      else {
        int v22 = sub_558D0(0LL, 999999LL);
      }
      uint64_t v20 = *(void *)(v8 + 8);
      uint64_t v21 = 4LL;
      goto LABEL_30;
    }

    if (v19 == 5)
    {
      sub_17808((uint64_t)a1);
      sub_150A4((uint64_t)a1, 0);
      return;
    }

    if (v19 == 4)
    {
      uint64_t v20 = *(void *)(v8 + 8);
      uint64_t v21 = 20LL;
      int v22 = 0;
LABEL_30:
      timer_set_relative(v20, v21, v22, (uint64_t)sub_3C3BC, (uint64_t)a1, 2LL, 0LL);
    }
  }

void sub_3C934(const char *a1, int a2)
{
  uint64_t v4 = sub_14834((uint64_t)a1);
  uint64_t v5 = sub_194C4((uint64_t)a1);
  uint64_t v6 = v5;
  if (a2 == 2)
  {
    ++*(_DWORD *)(v5 + 68);
    uint64_t v8 = sub_57538();
    uint64_t v9 = _SC_syslog_os_log_mapping(5LL);
    if (__SC_log_enabled(5LL, v8, v9))
    {
      uint64_t v10 = _os_log_pack_size(18LL);
      int v11 = (char *)&v16 - ((__chkstk_darwin(v10) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v12 = __error();
      uint64_t v13 = _os_log_pack_fill(v11, v10, *v12, &dword_0, "RTADV %s: restart count %u", v16, v17);
      uint64_t v14 = nullsub_1(v4);
      int v15 = *(_DWORD *)(v6 + 68);
      *(_DWORD *)uint64_t v13 = 136315394;
      *(void *)(v13 + 4) = v14;
      *(_WORD *)(v13 + 12) = 1024;
      *(_DWORD *)(v13 + 14) = v15;
      __SC_log_send(5LL, v8, v9, v11);
    }

    sub_3C3BC(a1, 0, 0LL);
  }

  else if (!a2)
  {
    sub_3B908((uint64_t)a1, 3u);
    int v7 = sub_558D0(0LL, 999999LL);
    timer_set_relative(*(void *)(v6 + 8), 1LL, v7, (uint64_t)sub_3C934, (uint64_t)a1, 2LL, 0LL);
  }

CFStringRef sub_3CB14(uint64_t a1)
{
  CFStringRef v1 = sub_52DAC(a1, &v11);
  CFStringRef v12 = v1;
  if (v1)
  {
    uint64_t v2 = sub_57538();
    uint64_t v3 = _SC_syslog_os_log_mapping(5LL);
    if (__SC_log_enabled(5LL, v2, v3))
    {
      uint64_t v4 = _os_log_pack_size(18LL);
      uint64_t v5 = (char *)&v10 - ((__chkstk_darwin(v4) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v6 = __error();
      uint64_t v7 = _os_log_pack_fill(v5, v4, *v6, &dword_0, "PREF64 prefix %@ lifetime %ds");
      int v8 = v11;
      *(_DWORD *)uint64_t v7 = 138412546;
      *(void *)(v7 + 4) = v1;
      *(_WORD *)(v7 + 12) = 1024;
      *(_DWORD *)(v7 + 14) = v8;
      __SC_log_send(5LL, v2, v3, v5);
    }

    if (!v11)
    {
      sub_4FA18((const void **)&v12);
      return v12;
    }
  }

  return v1;
}

uint64_t sub_3CC54(uint64_t a1)
{
  uint64_t v2 = sub_14834(a1);
  uint64_t v3 = sub_194C4(a1);
  int v5 = sub_31700();
  if (v5 < 0)
  {
    uint64_t v28 = sub_57538();
    uint64_t v29 = _SC_syslog_os_log_mapping(3LL);
    if (__SC_log_enabled(3LL, v28, v29))
    {
      uint64_t v30 = _os_log_pack_size(18LL);
      unsigned int v31 = (char *)&v62 - ((__chkstk_darwin(v30) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      double v32 = __error();
      uint64_t v33 = _os_log_pack_fill(v31, v30, *v32, &dword_0, "socket failed, %s (%d)", v62, v63);
      uint64_t v34 = __error();
      uint64_t v35 = strerror(*v34);
      int v36 = *__error();
      *(_DWORD *)uint64_t v33 = 136315394;
      *(void *)(v33 + 4) = v35;
      *(_WORD *)(v33 + 12) = 1024;
      *(_DWORD *)(v33 + 14) = v36;
      __SC_log_send(3LL, v28, v29, v31);
    }

    return 0LL;
  }

  int v6 = v5;
  uint64_t v7 = (const char *)nullsub_1(v2);
  sub_31DF8(v7, 1);
  uint64_t v8 = nullsub_1(v2);
  int v9 = sub_3EF20(v8);
  int v67 = bswap32(v9 | 0xC0000000);
  uint64_t v10 = (const char *)nullsub_1(v2);
  int v11 = sub_3273C(v6, v10, v67, &G_ip_broadcast, &v67);
  if (v11)
  {
    int v12 = v11;
    uint64_t v13 = sub_57538();
    uint64_t v14 = _SC_syslog_os_log_mapping(5LL);
    int v15 = v14;
    if (__SC_log_enabled(5LL, v13, v14))
    {
      uint64_t v16 = _os_log_pack_size(52LL);
      uint64_t v64 = &v62;
      uint64_t v17 = (char *)&v62 - ((__chkstk_darwin(v16) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v18 = __error();
      uint64_t v19 = _os_log_pack_fill( v17,  v16,  *v18,  &dword_0,  "RTADV %s: set CLAT46 address %d.%d.%d.%d failed, %s (%d)",  v62,  v63,  (_DWORD)v64,  v65,  v66,  v68,  v69);
      uint64_t v20 = nullsub_1(v2);
      uint64_t v63 = v13;
      int v21 = v9;
      int v22 = v67;
      int v23 = BYTE1(v67);
      HIDWORD(v62) = v15;
      int v24 = v6;
      int v25 = BYTE2(v67);
      LODWORD(v62) = HIBYTE(v67);
      uint64_t v26 = strerror(v12);
      *(_DWORD *)uint64_t v19 = 136316674;
      *(void *)(v19 + 4) = v20;
      *(_WORD *)(v19 + 12) = 1024;
      *(_DWORD *)(v19 + 14) = v22;
      int v9 = v21;
      *(_WORD *)(v19 + 18) = 1024;
      *(_DWORD *)(v19 + 20) = v23;
      *(_WORD *)(v19 + 24) = 1024;
      *(_DWORD *)(v19 + 26) = v25;
      int v6 = v24;
      *(_WORD *)(v19 + 30) = 1024;
      uint64_t v27 = HIDWORD(v62);
      *(_DWORD *)(v19 + 32) = (_DWORD)v62;
      *(_WORD *)(v19 + 36) = 2080;
      *(void *)(v19 + 38) = v26;
      *(_WORD *)(v19 + 46) = 1024;
      *(_DWORD *)(v19 + 48) = v12;
      __SC_log_send(5LL, v63, v27, v17);
    }

__CFDictionary *sub_3D1C0(const void *a1, int a2)
{
  int v3 = bswap32(a2 | 0xC0000000);
  CFMutableStringRef Mutable = CFDictionaryCreateMutable(0LL, 0LL, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  sub_4FFF4(Mutable, kSCPropNetIPv4Addresses, v3);
  sub_500AC(Mutable, kSCPropNetIPv4Router, 16777408);
  CFDictionarySetValue(Mutable, kSCPropInterfaceName, a1);
  CFDictionarySetValue(Mutable, kSCPropNetIPv4CLAT46, kCFBooleanTrue);
  int v7 = v3;
  CFDictionaryRef v5 = sub_38A28(&v7, &G_ip_broadcast, 0LL);
  sub_4FF88(Mutable, kSCPropNetIPv4AdditionalRoutes, v5);
  CFRelease(v5);
  return Mutable;
}

uint64_t sub_3D2BC(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v5 = sub_14834(a1);
  uint64_t v6 = sub_32804();
  if ((v6 & 0x80000000) != 0)
  {
    uint64_t v37 = sub_57538();
    uint64_t v38 = _SC_syslog_os_log_mapping(3LL);
    uint64_t result = __SC_log_enabled(3LL, v37, v38);
    if ((_DWORD)result)
    {
      uint64_t v39 = _os_log_pack_size(22LL);
      uint64_t v40 = (char *)&v46 - ((__chkstk_darwin(v39) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v41 = __error();
      uint64_t v42 = _os_log_pack_fill( v40,  v39,  *v41,  &dword_0,  "RTADV %s: failed to open socket, %s",  (const char *)v46,  *((const char **)&v46 + 1));
      uint64_t v43 = nullsub_1(v5);
      uint64_t v44 = __error();
      uint64_t v45 = strerror(*v44);
      *(_DWORD *)uint64_t v42 = 136315394;
      *(void *)(v42 + 4) = v43;
      *(_WORD *)(v42 + 12) = 2080;
      *(void *)(v42 + 14) = v45;
      return __SC_log_send(3LL, v37, v38, v40);
    }
  }

  else
  {
    uint64_t v8 = v6;
    if (a3 >= 1)
    {
      *(void *)&__int128 v7 = 136315906LL;
      __int128 v46 = v7;
      *(void *)&__int128 v7 = 136315650LL;
      __int128 v47 = v7;
      do
      {
        int v9 = (const char *)nullsub_1(v5);
        int v10 = sub_34BBC( v8,  v9,  (_OWORD *)a2,  0LL,  *(_DWORD *)(a2 + 16),  *(_DWORD *)(a2 + 20) | 0x800u,  *(_DWORD *)(a2 + 24),  *(_DWORD *)(a2 + 28));
        uint64_t v11 = sub_57538();
        if (v10 < 0)
        {
          uint64_t v23 = _SC_syslog_os_log_mapping(3LL);
          unsigned int v24 = v23;
          if (__SC_log_enabled(3LL, v11, v23))
          {
            uint64_t v25 = _os_log_pack_size(38LL);
            uint64_t v49 = &v46;
            uint64_t v14 = (char *)&v46 - ((__chkstk_darwin(v25) + 15) & 0xFFFFFFFFFFFFFFF0LL);
            uint64_t v26 = __error();
            uint64_t v27 = _os_log_pack_fill( v14,  v25,  *v26,  &dword_0,  "RTADV %s: inet6_aifaddr(%s/%d) failed, %s",  (const char *)v46,  *((const char **)&v46 + 1),  (_DWORD)v47,  *((const char **)&v47 + 1));
            uint64_t v28 = nullsub_1(v5);
            uint64_t v29 = inet_ntop(30, (const void *)a2, v50, 0x2Eu);
            unsigned int v48 = v24;
            uint64_t v30 = v29;
            uint64_t v31 = v8;
            uint64_t v32 = v5;
            int v33 = *(_DWORD *)(a2 + 16);
            uint64_t v34 = __error();
            uint64_t v35 = strerror(*v34);
            *(_DWORD *)uint64_t v27 = v46;
            *(void *)(v27 + 4) = v28;
            *(_WORD *)(v27 + 12) = 2080;
            *(void *)(v27 + 14) = v30;
            *(_WORD *)(v27 + 22) = 1024;
            *(_DWORD *)(v27 + 24) = v33;
            uint64_t v5 = v32;
            uint64_t v8 = v31;
            *(_WORD *)(v27 + 28) = 2080;
            *(void *)(v27 + 30) = v35;
            uint64_t v20 = 3LL;
            uint64_t v21 = v11;
            uint64_t v22 = v48;
            goto LABEL_9;
          }
        }

        else
        {
          uint64_t v12 = _SC_syslog_os_log_mapping(5LL);
          if (__SC_log_enabled(5LL, v11, v12))
          {
            uint64_t v13 = _os_log_pack_size(28LL);
            uint64_t v14 = (char *)&v46 - ((__chkstk_darwin(v13) + 15) & 0xFFFFFFFFFFFFFFF0LL);
            int v15 = __error();
            uint64_t v16 = _os_log_pack_fill( v14,  v13,  *v15,  &dword_0,  "RTADV %s: Re-assigned %s/%d",  (const char *)v46,  *((const char **)&v46 + 1),  (_DWORD)v47);
            uint64_t v17 = nullsub_1(v5);
            uint64_t v18 = inet_ntop(30, (const void *)a2, v50, 0x2Eu);
            int v19 = *(_DWORD *)(a2 + 16);
            *(_DWORD *)uint64_t v16 = v47;
            *(void *)(v16 + 4) = v17;
            *(_WORD *)(v16 + 12) = 2080;
            *(void *)(v16 + 14) = v18;
            *(_WORD *)(v16 + 22) = 1024;
            *(_DWORD *)(v16 + 24) = v19;
            uint64_t v20 = 5LL;
            uint64_t v21 = v11;
            uint64_t v22 = v12;
LABEL_9:
            __SC_log_send(v20, v21, v22, v14);
          }
        }

        a2 += 32LL;
        --a3;
      }

      while (a3);
    }

    return close(v8);
  }

  return result;
}

void sub_3D668(const char *a1, int a2, const void *a3)
{
  uint64_t v6 = sub_14834((uint64_t)a1);
  uint64_t v7 = sub_194C4((uint64_t)a1);
  uint64_t v8 = v7;
  if (a2 != 5)
  {
    if (a2 == 2)
    {
      if (*(void *)(v7 + 16))
      {
        if (sub_4E330(v7 + 104))
        {
          double v23 = sub_4E7B8(v8 + 104);
          double current_time = timer_get_current_time();
          if (v23 != 0.0 && v23 < current_time) {
            sub_3DE40(a1);
          }
        }

        sub_3B790(a1);
        if (*(void *)(v8 + 16))
        {
          double v25 = timer_get_current_time();
          double v26 = sub_52B24(*(void *)(v8 + 16), 0LL, 0LL, v25);
          if (sub_4E330(v8 + 104))
          {
            double v27 = sub_4E7B8(v8 + 104);
            if (v27 < v26 && v27 != 0.0) {
              double v26 = v27;
            }
          }

          if (v26 != 0.0)
          {
            CFDateRef v29 = CFDateCreate(0LL, v26);
            uint64_t v30 = sub_57538();
            uint64_t v31 = _SC_syslog_os_log_mapping(6LL);
            if (__SC_log_enabled(6LL, v30, v31))
            {
              uint64_t v32 = _os_log_pack_size(22LL);
              int v33 = (char *)&v61 - ((__chkstk_darwin(v32) + 15) & 0xFFFFFFFFFFFFFFF0LL);
              uint64_t v34 = *__error();
              uint64_t v35 = _os_log_pack_fill(v33, v32, v34, &dword_0, "RTADV %s: DNS expiration time %@");
LABEL_58:
              uint64_t v59 = v35;
              uint64_t v60 = nullsub_1(v6);
              *(_DWORD *)uint64_t v59 = 136315394;
              *(void *)(v59 + 4) = v60;
              *(_WORD *)(v59 + 12) = 2112;
              *(void *)(v59 + 14) = v29;
              __SC_log_send(6LL, v30, v31, v33);
            }

void sub_3DD10(uint64_t a1, uint64_t a2)
{
  int v3 = sub_51ABC(a2);
  uint64_t v4 = sub_57538();
  uint64_t v5 = _SC_syslog_os_log_mapping(6LL);
  if (__SC_log_enabled(6LL, v4, v5))
  {
    uint64_t v6 = _os_log_pack_size(22LL);
    uint64_t v7 = (char *)&v10 - ((__chkstk_darwin(v6) + 15) & 0xFFFFFFFFFFFFFFF0LL);
    uint64_t v8 = __error();
    uint64_t v9 = _os_log_pack_fill(v7, v6, *v8, &dword_0, "RTADV %s: received RA %@");
    *(_DWORD *)uint64_t v9 = 136315394;
    *(void *)(v9 + 4) = a1;
    *(_WORD *)(v9 + 12) = 2112;
    *(void *)(v9 + 14) = v3;
    __SC_log_send(6LL, v4, v5, v7);
  }

  CFRelease(v3);
}

void sub_3DE40(const char *a1)
{
  unsigned __int16 v72 = 0;
  int v71 = 0;
  CFStringRef v69 = 0LL;
  uint64_t v70 = 0LL;
  HIWORD(v68) = 0;
  uint64_t v2 = sub_194C4((uint64_t)a1);
  uint64_t v3 = sub_52A44(*(void *)(v2 + 16), &v70, (_WORD *)&v68 + 3, (uint64_t)&v71);
  if (!(_BYTE)v71)
  {
LABEL_10:
    uint64_t v17 = v2 + 104;
LABEL_11:
    sub_4E220(v17, 1);
    goto LABEL_12;
  }

  uint64_t v4 = v3;
  CFStringRef v5 = sub_536F4(v3, v70);
  CFStringRef v69 = v5;
  if (!v5)
  {
    CFMutableStringRef Mutable = CFStringCreateMutable(0LL, 0LL);
    int v67 = (const char *)Mutable;
    sub_55914(Mutable, v4, v70);
    uint64_t v11 = sub_57538();
    uint64_t v12 = _SC_syslog_os_log_mapping(3LL);
    if (__SC_log_enabled(3LL, v11, v12))
    {
      uint64_t v13 = _os_log_pack_size(22LL);
      uint64_t v14 = (char *)&v67 - ((__chkstk_darwin(v13) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v15 = __error();
      uint64_t v16 = _os_log_pack_fill( v14,  v13,  *v15,  &dword_0,  "%s: failed to create pvd id from raw str:\n%@",  v67);
      *(_DWORD *)uint64_t v16 = 136315394;
      *(void *)(v16 + 4) = "rtadv_pvd_additional_info_schedule_fetch";
      *(_WORD *)(v16 + 12) = 2112;
      *(void *)(v16 + 14) = Mutable;
      __SC_log_send(3LL, v11, v12, v14);
    }

    sub_4FA18((const void **)&v67);
    goto LABEL_10;
  }

  uint64_t v6 = v5;
  uint64_t v7 = v2 + 104;
  uint64_t v8 = (const __CFString *)sub_468A4(v7);
  if (!v8)
  {
    uint64_t v9 = -1LL;
    goto LABEL_14;
  }

  if (CFStringCompare(v6, v8, 1uLL))
  {
    uint64_t v9 = -1LL;
LABEL_6:
    sub_4E220(v7, 0);
LABEL_14:
    sub_3E810(a1, v6, SHIWORD(v68), v9);
    int v18 = 1;
    goto LABEL_15;
  }

  if ((sub_4E330(v7) & 1) == 0)
  {
    uint64_t v38 = sub_57538();
    uint64_t v39 = _SC_syslog_os_log_mapping(5LL);
    if (__SC_log_enabled(5LL, v38, v39))
    {
      uint64_t v40 = _os_log_pack_size(22LL);
      uint64_t v41 = (char *)&v67 - ((__chkstk_darwin(v40) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v42 = __error();
      uint64_t v43 = _os_log_pack_fill(v41, v40, *v42, &dword_0, "%s: not allowed to fetch info for pvdid '%@'");
      *(_DWORD *)uint64_t v43 = 136315394;
      *(void *)(v43 + 4) = "rtadv_pvd_additional_info_schedule_fetch";
      *(_WORD *)(v43 + 12) = 2112;
      *(void *)(v43 + 14) = v6;
      __SC_log_send(5LL, v38, v39, v41);
    }

    goto LABEL_12;
  }

  if (!sub_4E380(v7))
  {
    uint64_t v44 = sub_57538();
    uint64_t v45 = _SC_syslog_os_log_mapping(7LL);
    if (__SC_log_enabled(7LL, v44, v45))
    {
      uint64_t v46 = _os_log_pack_size(18LL);
      uint64_t v47 = (char *)&v67 - ((__chkstk_darwin(v46) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      unsigned int v48 = __error();
      uint64_t v49 = _os_log_pack_fill( v47,  v46,  *v48,  &dword_0,  "%s: hasn't been %d seconds since last fetch",  v67,  (_DWORD)v68);
      *(_DWORD *)uint64_t v49 = 136315394;
      *(void *)(v49 + 4) = "rtadv_pvd_additional_info_schedule_fetch";
      *(_WORD *)(v49 + 12) = 1024;
      *(_DWORD *)(v49 + 14) = 10;
      __SC_log_send(7LL, v44, v45, v47);
    }

    goto LABEL_12;
  }

  int v26 = sub_4E320(v7);
  double v27 = sub_4E7B8(v7);
  double Current = CFAbsoluteTimeGetCurrent();
  if (HIWORD(v68) != v26)
  {
    uint64_t v50 = sub_57538();
    uint64_t v51 = _SC_syslog_os_log_mapping(7LL);
    if (__SC_log_enabled(7LL, v50, v51))
    {
      uint64_t v52 = _os_log_pack_size(12LL);
      char v53 = (char *)&v67 - ((__chkstk_darwin(v52) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      double v54 = __error();
      uint64_t v55 = _os_log_pack_fill(v53, v52, *v54, &dword_0, "%s: got new seqnr != old seqnr", v67);
      *(_DWORD *)uint64_t v55 = 136315138;
      *(void *)(v55 + 4) = "rtadv_pvd_additional_info_schedule_fetch";
      __SC_log_send(7LL, v50, v51, v53);
    }

    uint64_t v56 = sub_3E608(v72);
    if (v56 != -1)
    {
      uint64_t v9 = v56;
      uint64_t v37 = "new sequence number";
LABEL_41:
      uint64_t v61 = sub_57538();
      uint64_t v62 = _SC_syslog_os_log_mapping(6LL);
      if (__SC_log_enabled(6LL, v61, v62))
      {
        uint64_t v63 = _os_log_pack_size(32LL);
        uint64_t v64 = (char *)&v67 - ((__chkstk_darwin(v63) + 15) & 0xFFFFFFFFFFFFFFF0LL);
        uint64_t v65 = __error();
        uint64_t v66 = _os_log_pack_fill( v64,  v63,  *v65,  &dword_0,  "%s: deprecating info for PvD ID '%@' with reason '%s'");
        *(_DWORD *)uint64_t v66 = 136315650;
        *(void *)(v66 + 4) = "rtadv_pvd_additional_info_schedule_fetch";
        *(_WORD *)(v66 + 12) = 2112;
        *(void *)(v66 + 14) = v6;
        *(_WORD *)(v66 + 22) = 2080;
        *(void *)(v66 + 24) = v37;
        __SC_log_send(6LL, v61, v62, v64);
      }

      goto LABEL_6;
    }

    uint64_t v17 = v7;
    goto LABEL_11;
  }

  double v29 = Current;
  uint64_t v30 = sub_57538();
  uint64_t v31 = _SC_syslog_os_log_mapping(7LL);
  int v32 = __SC_log_enabled(7LL, v30, v31);
  if (v27 != 0.0 && v27 < v29)
  {
    if (v32)
    {
      uint64_t v33 = _os_log_pack_size(12LL);
      uint64_t v34 = (char *)&v67 - ((__chkstk_darwin(v33) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v35 = __error();
      uint64_t v36 = _os_log_pack_fill( v34,  v33,  *v35,  &dword_0,  "%s: pvd addinfo has expired, need new fetch",  v67);
      *(_DWORD *)uint64_t v36 = 136315138;
      *(void *)(v36 + 4) = "rtadv_pvd_additional_info_schedule_fetch";
      __SC_log_send(7LL, v30, v31, v34);
    }

    uint64_t v9 = -1LL;
    uint64_t v37 = "expired";
    goto LABEL_41;
  }

  if (v32)
  {
    uint64_t v57 = _os_log_pack_size(12LL);
    uint64_t v58 = (char *)&v67 - ((__chkstk_darwin(v57) + 15) & 0xFFFFFFFFFFFFFFF0LL);
    uint64_t v59 = __error();
    uint64_t v60 = _os_log_pack_fill(v58, v57, *v59, &dword_0, "%s: no need to refetch", v67);
    *(_DWORD *)uint64_t v60 = 136315138;
    *(void *)(v60 + 4) = "rtadv_pvd_additional_info_schedule_fetch";
    __SC_log_send(7LL, v30, v31, v58);
  }

uint64_t sub_3E608(unsigned int a1)
{
  if (a1 < 0x10)
  {
    if (a1 >= 4) {
      char v7 = 4;
    }
    else {
      char v7 = a1;
    }
    uint32_t v8 = arc4random_uniform(1 << (v7 + 10));
    uint64_t v9 = sub_57538();
    uint64_t v10 = _SC_syslog_os_log_mapping(6LL);
    if (__SC_log_enabled(6LL, v9, v10))
    {
      uint64_t v11 = _os_log_pack_size(18LL);
      uint64_t v12 = (char *)&v16 - ((__chkstk_darwin(v11) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v13 = __error();
      uint64_t v14 = _os_log_pack_fill( v12,  v11,  *v13,  &dword_0,  "%s: delaying PvD Additional Info fetch by %u milliseconds",  v16,  v17);
      *(_DWORD *)uint64_t v14 = 136315394;
      *(void *)(v14 + 4) = "_calculate_randomized_backoff";
      *(_WORD *)(v14 + 12) = 1024;
      *(_DWORD *)(v14 + 14) = v8;
      __SC_log_send(6LL, v9, v10, v12);
    }

    if (v8 != -1) {
      return v8;
    }
  }

  else
  {
    uint64_t v1 = sub_57538();
    uint64_t v2 = _SC_syslog_os_log_mapping(3LL);
    if (__SC_log_enabled(3LL, v1, v2))
    {
      uint64_t v3 = _os_log_pack_size(12LL);
      uint64_t v4 = (char *)&v16 - ((__chkstk_darwin(v3) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      CFStringRef v5 = __error();
      uint64_t v6 = _os_log_pack_fill(v4, v3, *v5, &dword_0, "%s: can't have delay value greater than 15", v16);
      *(_DWORD *)uint64_t v6 = 136315138;
      *(void *)(v6 + 4) = "_calculate_randomized_backoff";
      __SC_log_send(3LL, v1, v2, v4);
    }
  }

  return -1LL;
}

void sub_3E810(const char *a1, const void *a2, __int16 a3, uint64_t a4)
{
  uint64_t v8 = sub_57538();
  uint64_t v9 = _SC_syslog_os_log_mapping(7LL);
  if (__SC_log_enabled(7LL, v8, v9))
  {
    uint64_t v10 = _os_log_pack_size(12LL);
    uint64_t v11 = (char *)v38 - ((__chkstk_darwin(v10) + 15) & 0xFFFFFFFFFFFFFFF0LL);
    uint64_t v12 = __error();
    uint64_t v13 = _os_log_pack_fill(v11, v10, *v12, &dword_0, "%s", v38[0]);
    *(_DWORD *)uint64_t v13 = 136315138;
    *(void *)(v13 + 4) = "_new_pvd_info_request";
    __SC_log_send(7LL, v8, v9, v11);
  }

  uint64_t v14 = sub_194C4((uint64_t)a1);
  uint64_t v15 = *(void *)(v14 + 16);
  sub_3BA6C(v14);
  uint64_t v16 = v14 + 104;
  sub_4E2A8((const void **)(v14 + 104), a2);
  sub_4E328(v14 + 104, a3);
  uint64_t v17 = sub_526B8(v15);
  uint64_t v39 = v17;
  if (!v17)
  {
    uint64_t v30 = sub_57538();
    uint64_t v31 = _SC_syslog_os_log_mapping(3LL);
    if (__SC_log_enabled(3LL, v30, v31))
    {
      uint64_t v32 = _os_log_pack_size(12LL);
      uint64_t v33 = (char *)v38 - ((__chkstk_darwin(v32) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v34 = *__error();
      uint64_t v35 = _os_log_pack_fill(v33, v32, v34, &dword_0, "%s: couldn't copy prefixes from RA");
LABEL_12:
      *(_DWORD *)uint64_t v35 = 136315138;
      *(void *)(v35 + 4) = "_new_pvd_info_request";
      __SC_log_send(3LL, v30, v31, v33);
    }

void sub_3EC24(uint64_t a1)
{
}

void sub_3EC34(uint64_t a1, uint64_t a2)
{
  uint64_t v20 = 0LL;
  uint64_t v4 = sub_57538();
  uint64_t v5 = _SC_syslog_os_log_mapping(7LL);
  if (__SC_log_enabled(7LL, v4, v5))
  {
    uint64_t v6 = _os_log_pack_size(12LL);
    char v7 = (char *)&v20 - ((__chkstk_darwin(v6) + 15) & 0xFFFFFFFFFFFFFFF0LL);
    uint64_t v8 = __error();
    uint64_t v9 = _os_log_pack_fill(v7, v6, *v8, &dword_0, "%s", v20);
    *(_DWORD *)uint64_t v9 = 136315138;
    *(void *)(v9 + 4) = "rtadv_pvd_additional_info_request_callback";
    __SC_log_send(7LL, v4, v5, v7);
  }

  if (!a2)
  {
    uint64_t v12 = sub_57538();
    uint64_t v13 = _SC_syslog_os_log_mapping(7LL);
    if (__SC_log_enabled(7LL, v12, v13))
    {
      uint64_t v14 = _os_log_pack_size(2LL);
      uint64_t v15 = (char *)&v20 - ((__chkstk_darwin(v14) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v16 = *__error();
      uint64_t v17 = (_WORD *)_os_log_pack_fill( v15,  v14,  v16,  &dword_0,  "ignoring pvd info request callback: no longer active",  v20);
LABEL_12:
      *uint64_t v17 = 0;
      __SC_log_send(7LL, v12, v13, v15);
    }

uint64_t sub_3EF20(uint64_t a1)
{
  uint64_t v2 = 0LL;
  while (word_6C278[v2])
  {
    if (++v2 == 4)
    {
      LOBYTE(v2) = 0;
      break;
    }
  }

  unsigned __int8 v3 = v2 + 2;
  uint64_t v4 = v2;
  int v5 = word_6C278[v2];
  uint64_t v6 = sub_57538();
  uint64_t v7 = _SC_syslog_os_log_mapping(5LL);
  int v8 = __SC_log_enabled(5LL, v6, v7);
  if (v5)
  {
    if (v8)
    {
      uint64_t v9 = _os_log_pack_size(18LL);
      uint64_t v10 = (char *)&v16 - ((__chkstk_darwin(v9) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v11 = *__error();
      uint64_t v12 = _os_log_pack_fill(v10, v9, v11, &dword_0, "%s: CLAT46 address space exhausted, re-using 192.0.0.%d");
LABEL_10:
      *(_DWORD *)uint64_t v12 = 136315394;
      *(void *)(v12 + 4) = a1;
      *(_WORD *)(v12 + 12) = 1024;
      *(_DWORD *)(v12 + 14) = v3;
      __SC_log_send(5LL, v6, v7, v10);
    }
  }

  else if (v8)
  {
    uint64_t v13 = _os_log_pack_size(18LL);
    uint64_t v10 = (char *)&v16 - ((__chkstk_darwin(v13) + 15) & 0xFFFFFFFFFFFFFFF0LL);
    uint64_t v14 = *__error();
    uint64_t v12 = _os_log_pack_fill(v10, v13, v14, &dword_0, "%s: CLAT46 192.0.0.%d allocated");
    goto LABEL_10;
  }

  ++word_6C278[v4];
  return v3;
}

uint64_t sub_3F0E4(uint64_t a1, int a2, __n128 *a3)
{
  uint64_t v6 = sub_14834(a1);
  switch(a2)
  {
    case 0:
      uint64_t v7 = sub_57538();
      uint64_t v8 = _SC_syslog_os_log_mapping(6LL);
      if (__SC_log_enabled(6LL, v7, v8))
      {
        uint64_t v9 = _os_log_pack_size(22LL);
        uint64_t v10 = (char *)&v27 - ((__chkstk_darwin(v9) + 15) & 0xFFFFFFFFFFFFFFF0LL);
        uint64_t v11 = __error();
        uint64_t v12 = _os_log_pack_fill(v10, v9, *v11, &dword_0, "%s %s: starting", v27, v28);
        uint64_t v13 = sub_1509C(a1);
        uint64_t v14 = nullsub_1(v6);
        *(_DWORD *)uint64_t v12 = 136315394;
        *(void *)(v12 + 4) = v13;
        *(_WORD *)(v12 + 12) = 2080;
        *(void *)(v12 + 14) = v14;
        __SC_log_send(6LL, v7, v8, v10);
      }

      sub_1950C(a1, a3, a3[1].n128_i32[0]);
      sub_3F438(a1);
      uint64_t v15 = sub_14834(a1);
      int v16 = sub_54F6C(v15);
      sub_35A4C((uint64_t)&v29, v16);
      sub_3F4EC(a1, (uint64_t *)&v29);
      sub_36090((uint64_t)&v29);
      break;
    case 1:
      sub_19524(a1, &v29, (_DWORD *)&v28 + 1);
      uint64_t v17 = sub_57538();
      uint64_t v18 = _SC_syslog_os_log_mapping(6LL);
      if (__SC_log_enabled(6LL, v17, v18))
      {
        uint64_t v19 = _os_log_pack_size(22LL);
        uint64_t v20 = (char *)&v27 - ((__chkstk_darwin(v19) + 15) & 0xFFFFFFFFFFFFFFF0LL);
        uint64_t v21 = __error();
        uint64_t v22 = _os_log_pack_fill(v20, v19, *v21, &dword_0, "%s %s: stop", v27, v28);
        dispatch_queue_t v23 = sub_1509C(a1);
        uint64_t v24 = nullsub_1(v6);
        *(_DWORD *)uint64_t v22 = 136315394;
        *(void *)(v22 + 4) = v23;
        *(_WORD *)(v22 + 12) = 2080;
        *(void *)(v22 + 14) = v24;
        __SC_log_send(6LL, v17, v18, v20);
      }

      sub_19938(a1, &v29, SHIDWORD(v28));
      break;
    case 3:
    case 8:
    case 11:
      if (a3->n128_u32[1] == 1 && a3->n128_u32[2] == 1 && (a2 != 11 || !sub_160CC(a1))) {
        sub_3F438(a1);
      }
      break;
    case 4:
      sub_3F4A0(a1);
      break;
    case 7:
      sub_19524(a1, &v29, (_DWORD *)&v28 + 1);
      BOOL v25 = *(void *)a3->n128_u64[0] == v29.n128_u64[0] && *(void *)(a3->n128_u64[0] + 8) == v29.n128_u64[1];
      if (!v25 || *(_DWORD *)(a3->n128_u64[0] + 16) != HIDWORD(v28)) {
        a3->n128_u32[2] = 1;
      }
      break;
    case 15:
      sub_3F4EC(a1, (uint64_t *)a3);
      break;
    default:
      return 0LL;
  }

  return 0LL;
}

void sub_3F438(uint64_t a1)
{
  uint64_t v2 = sub_14834(a1);
  if (sub_54228(v2) == 24)
  {
    sub_3F6D4(a1);
    sub_3F750(a1);
  }

  else if (sub_19384(a1) == 1)
  {
    sub_3F4A0(a1);
  }

  else
  {
    sub_3F6D4(a1);
  }

uint64_t sub_3F4A0(uint64_t a1)
{
  return sub_17FEC(a1, 0xCu);
}

void sub_3F4EC(uint64_t a1, uint64_t *a2)
{
  uint64_t v4 = sub_14834(a1);
  if (a2)
  {
    if (*((_DWORD *)a2 + 2))
    {
      uint64_t v5 = v4;
      sub_19524(a1, &v20, (_DWORD *)&v19 + 1);
      int v6 = *((_DWORD *)a2 + 2);
      if (v6 >= 1)
      {
        for (uint64_t i = *a2; ; i += 32LL)
        {
          int v8 = *(_DWORD *)(i + 20);
          if ((v8 & 0x40) == 0 && *(void *)i == v20.n128_u64[0] && *(void *)(i + 8) == v20.n128_u64[1]) {
            break;
          }
          if (!--v6) {
            return;
          }
        }

        if ((v8 & 4) != 0)
        {
          uint64_t v10 = sub_57538();
          uint64_t v11 = _SC_syslog_os_log_mapping(5LL);
          if (__SC_log_enabled(5LL, v10, v11))
          {
            uint64_t v12 = _os_log_pack_size(32LL);
            uint64_t v13 = (char *)&v19 - ((__chkstk_darwin(v12) + 15) & 0xFFFFFFFFFFFFFFF0LL);
            uint64_t v14 = __error();
            uint64_t v15 = _os_log_pack_fill( v13,  v12,  *v14,  &dword_0,  "%s %s: IPv6 address %s is in use by another host",  v19,  (const char *)v20.n128_u64[0],  (const char *)v20.n128_u64[1]);
            int v16 = sub_1509C(a1);
            uint64_t v17 = nullsub_1(v5);
            uint64_t v18 = inet_ntop(30, &v20, v21, 0x2Eu);
            *(_DWORD *)uint64_t v15 = 136315650;
            *(void *)(v15 + 4) = v16;
            *(_WORD *)(v15 + 12) = 2080;
            *(void *)(v15 + 14) = v17;
            *(_WORD *)(v15 + 22) = 2080;
            *(void *)(v15 + 24) = v18;
            __SC_log_send(5LL, v10, v11, v13);
          }

          sub_19938(a1, &v20, SHIDWORD(v19));
          sub_17FEC(a1, 8u);
        }

        else if ((v8 & 2) == 0)
        {
          sub_3F750(a1);
        }
      }
    }
  }

uint64_t sub_3F6D4(uint64_t a1)
{
  uint64_t v2 = sub_14834(a1);
  sub_19524(a1, &v6, &v5);
  else {
    int v3 = 0;
  }
  return sub_19540(a1, (char *)&v6, v5, v3, -1, -1);
}

void sub_3F750(uint64_t a1)
{
  v3[1] = 0;
  sub_19524(a1, &v2, v3);
  sub_16BA4(a1, &v2, 1, 0LL, 0LL, 0LL, 0LL);
}

__int16 *sub_3F7A8(__int16 *result, int a2)
{
  BOOL v2 = result != 0LL;
  BOOL v3 = a2 != 0;
  BOOL v4 = !v2 || !v3;
  if (v2 && v3) {
    int v5 = result;
  }
  else {
    int v5 = &word_595A0;
  }
  if (v4) {
    int v6 = 3;
  }
  else {
    int v6 = a2;
  }
  off_6C0F0 = v5;
  dword_6C0F8 = v6;
  return result;
}

uint64_t sub_3F7E4(int a1)
{
  if (dword_6C0F8 < 1) {
    return 0LL;
  }
  uint64_t v1 = off_6C0F0;
  uint64_t v2 = dword_6C0F8 - 1LL;
  do
  {
    int v3 = (unsigned __int16)*v1++;
    BOOL v4 = v3 == a1;
  }

  while (v3 != a1 && v2-- != 0);
  return v4;
}

BOOL sub_3F84C(uint64_t a1, char a2)
{
  BOOL result = sub_3F880(a1, (uint64_t)"DHCPv6ClientSetUsePrivateAddress");
  if (result) {
    *(_BYTE *)(a1 + 241) = a2;
  }
  return result;
}

BOOL sub_3F880(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = sub_468A4(*(void *)(a1 + 128));
  int v5 = *(_DWORD *)(a1 + 116);
  if (v5)
  {
    uint64_t v6 = v4;
    uint64_t v7 = sub_57538();
    uint64_t v8 = _SC_syslog_os_log_mapping(5LL);
    if (__SC_log_enabled(5LL, v7, v8))
    {
      uint64_t v9 = _os_log_pack_size(32LL);
      uint64_t v10 = (char *)v17 - ((__chkstk_darwin(v9) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v11 = __error();
      uint64_t v12 = _os_log_pack_fill( v10,  v9,  *v11,  &dword_0,  "%s(%s): mode is %s, ignoring",  v17[0],  v17[1],  v17[2]);
      uint64_t v13 = nullsub_1(v6);
      uint64_t v14 = *(unsigned int *)(a1 + 116);
      else {
        uint64_t v15 = off_64FF8[v14];
      }
      *(_DWORD *)uint64_t v12 = 136315650;
      *(void *)(v12 + 4) = a2;
      *(_WORD *)(v12 + 12) = 2080;
      *(void *)(v12 + 14) = v13;
      *(_WORD *)(v12 + 22) = 2080;
      *(void *)(v12 + 24) = v15;
      __SC_log_send(5LL, v7, v8, v10);
    }
  }

  return v5 == 0;
}

BOOL sub_3F9FC(uint64_t a1)
{
  return sub_46F90(*(void *)(a1 + 128));
}

uint64_t sub_3FA04(uint64_t a1, _BYTE *a2)
{
  *a2 = 0;
  uint64_t result = *(void *)(a1 + 192);
  if (result)
  {
    else {
      BOOL v5 = 1;
    }
    if (!v5) {
      *a2 = 1;
    }
    return sub_57BD4(*(void *)(a1 + 192), 23, &v7, 0LL) && v7 > 0xF;
  }

  return result;
}

void sub_3FA84(uint64_t a1, __CFDictionary *a2)
{
  CFMutableStringRef Mutable = CFDictionaryCreateMutable(0LL, 0LL, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  BOOL v5 = Mutable;
  uint64_t v6 = *(unsigned int *)(a1 + 120);
  else {
    unsigned int v7 = off_64F98[v6];
  }
  sub_50228(Mutable, @"State", v7);
  uint64_t v8 = *(unsigned int *)(a1 + 116);
  else {
    uint64_t v9 = off_64FF8[v8];
  }
  sub_50228(v5, @"Mode", v9);
  if (*(_BYTE *)(a1 + 224) && *(_DWORD *)(a1 + 184) && *(_BYTE *)(a1 + 240))
  {
    int v10 = *(_DWORD *)(a1 + 116);
    if (v10 == 3)
    {
      if (*(_DWORD *)(a1 + 76) || *(_DWORD *)(a1 + 80) || *(_DWORD *)(a1 + 84) || *(_DWORD *)(a1 + 88))
      {
        sub_50188(v5, @"DelegatedPrefix", (void *)(a1 + 76));
        sub_502C4(v5, @"DelegatedPrefixLength", *(unsigned __int8 *)(a1 + 92));
      }
    }

    else if (v10 == 2 && (*(_DWORD *)(a1 + 56) || *(_DWORD *)(a1 + 60) || *(_DWORD *)(a1 + 64) || *(_DWORD *)(a1 + 68)))
    {
      sub_50188(v5, @"StatefulAddress", (void *)(a1 + 56));
    }

    sub_5027C(v5, @"LeaseStartTime", *(CFAbsoluteTime *)(a1 + 200));
    unsigned int v14 = *(_DWORD *)(a1 + 216);
    if (v14 == -1) {
      CFDictionarySetValue(v5, @"LeaseIsInfinite", kCFBooleanTrue);
    }
    else {
      sub_5027C(v5, @"LeaseExpirationTime", *(double *)(a1 + 200) + (double)v14);
    }
  }

  else
  {
    unsigned int v11 = *(_DWORD *)(a1 + 120);
    if (v11 <= 0xA && ((1 << v11) & 0x446) != 0)
    {
      double current_time = timer_get_current_time();
      double v13 = *(double *)(a1 + 160);
      if (current_time > v13) {
        sub_502C4(v5, @"ElapsedTime", (unint64_t)(current_time - v13));
      }
    }
  }

  if (*(_BYTE *)(a1 + 240) && *(void *)(a1 + 176) && *(void *)(a1 + 192))
  {
    uint64_t v15 = CFStringCreateMutable(0LL, 0LL);
    DHCPv6PacketPrintToString(v15, *(unsigned __int8 **)(a1 + 176), *(unsigned int *)(a1 + 184));
    sub_57A24(v15, *(void *)(a1 + 192));
    CFDictionarySetValue(v5, @"Packet", v15);
    CFRelease(v15);
  }

  CFDictionarySetValue(a2, @"DHCPv6", v5);
  CFRelease(v5);
}

uint64_t sub_3FCFC(uint64_t a1)
{
  return *(unsigned int *)(a1 + 116);
}

_OWORD *sub_3FD04(uint64_t a1)
{
  uint64_t v2 = sub_14834(a1);
  int v3 = malloc(0x120uLL);
  _OWORD *v3 = 0u;
  v3[1] = 0u;
  v3[2] = 0u;
  v3[3] = 0u;
  _DWORD v3[4] = 0u;
  v3[5] = 0u;
  v3[6] = 0u;
  v3[7] = 0u;
  v3[8] = 0u;
  v3[9] = 0u;
  v3[10] = 0u;
  v3[11] = 0u;
  v3[12] = 0u;
  v3[13] = 0u;
  v3[14] = 0u;
  v3[15] = 0u;
  v3[16] = 0u;
  v3[17] = 0u;
  *((void *)v3 + 17) = a1;
  *((void *)v3 + 16) = sub_468AC(v2);
  uint64_t v4 = (const char *)nullsub_1(v2);
  snprintf(__str, 0x20uLL, "DHCPv6-%s", v4);
  *((void *)v3 + 18) = timer_callout_init(__str);
  sub_3FDE0((uint64_t)v3);
  return v3;
}

uint64_t sub_3FDE0(uint64_t a1)
{
  uint64_t v2 = sub_14834(*(void *)(a1 + 136));
  if (*(_DWORD *)(a1 + 116))
  {
    nullsub_1(v2);
    return snprintf((char *)a1, 0x20uLL, "DHCPv6-%s %s");
  }

  else
  {
    nullsub_1(v2);
    return snprintf((char *)a1, 0x20uLL, "DHCPv6 %s");
  }

void sub_3FE64(uint64_t a1)
{
  uint64_t v2 = sub_468A4(*(void *)(a1 + 128));
  uint64_t v3 = sub_57538();
  uint64_t v4 = _SC_syslog_os_log_mapping(5LL);
  if (__SC_log_enabled(5LL, v3, v4))
  {
    uint64_t v5 = _os_log_pack_size(42LL);
    uint64_t v6 = (char *)v14 - ((__chkstk_darwin(v5) + 15) & 0xFFFFFFFFFFFFFFF0LL);
    unsigned int v7 = __error();
    uint64_t v8 = _os_log_pack_fill( v6,  v5,  *v7,  &dword_0,  "%s(%s): %s using %s address",  v14[0],  v14[1],  v14[2],  v14[3]);
    uint64_t v9 = nullsub_1(v2);
    uint64_t v10 = *(unsigned int *)(a1 + 116);
    else {
      unsigned int v11 = off_64FF8[v10];
    }
    uint64_t v12 = "private";
    int v13 = *(unsigned __int8 *)(a1 + 241);
    *(void *)(v8 + 4) = "DHCPv6ClientStart";
    *(_DWORD *)uint64_t v8 = 136315906;
    *(_WORD *)(v8 + 12) = 2080;
    if (!v13) {
      uint64_t v12 = "permanent";
    }
    *(void *)(v8 + 14) = v9;
    *(_WORD *)(v8 + 22) = 2080;
    *(void *)(v8 + 24) = v11;
    *(_WORD *)(v8 + 32) = 2080;
    *(void *)(v8 + 34) = v12;
    __SC_log_send(5LL, v3, v4, v6);
  }

  sub_3FFF8(a1);
}

void sub_3FFF8(uint64_t a1)
{
  uint64_t v2 = sub_468A4(*(void *)(a1 + 128));
  int v3 = *(_DWORD *)(a1 + 116);
  if ((v3 - 2) >= 2)
  {
    if (v3 == 1)
    {
      sub_42038(a1, 0, 0LL);
    }

    else
    {
      uint64_t v23 = v2;
      uint64_t v24 = sub_57538();
      uint64_t v25 = _SC_syslog_os_log_mapping(5LL);
      if (__SC_log_enabled(5LL, v24, v25))
      {
        uint64_t v26 = _os_log_pack_size(22LL);
        double v27 = (char *)&v31 - ((__chkstk_darwin(v26) + 15) & 0xFFFFFFFFFFFFFFF0LL);
        uint64_t v28 = __error();
        uint64_t v29 = _os_log_pack_fill(v27, v26, *v28, &dword_0, "%s(%s): no/invalid mode specified", v31, v32);
        uint64_t v30 = nullsub_1(v23);
        *(_DWORD *)uint64_t v29 = 136315394;
        *(void *)(v29 + 4) = "DHCPv6ClientStartInternal";
        *(_WORD *)(v29 + 12) = 2080;
        *(void *)(v29 + 14) = v30;
        __SC_log_send(5LL, v24, v25, v27);
      }
    }
  }

  else
  {
    uint64_t v4 = sub_57538();
    uint64_t v5 = _SC_syslog_os_log_mapping(5LL);
    if (__SC_log_enabled(5LL, v4, v5))
    {
      uint64_t v6 = _os_log_pack_size(22LL);
      unsigned int v7 = (char *)&v31 - ((__chkstk_darwin(v6) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v8 = __error();
      uint64_t v9 = _os_log_pack_fill(v7, v6, *v8, &dword_0, "%s: %s()", v31, v32);
      *(_DWORD *)uint64_t v9 = 136315394;
      *(void *)(v9 + 4) = a1;
      *(_WORD *)(v9 + 12) = 2080;
      *(void *)(v9 + 14) = "DHCPv6ClientStartInternal";
      __SC_log_send(5LL, v4, v5, v7);
    }

    double current_time = timer_get_current_time();
    if (sub_40AD8(a1, current_time) && sub_42410(a1))
    {
      uint64_t v11 = sub_57538();
      uint64_t v12 = _SC_syslog_os_log_mapping(5LL);
      if (__SC_log_enabled(5LL, v11, v12))
      {
        uint64_t v13 = _os_log_pack_size(22LL);
        unsigned int v14 = (char *)&v31 - ((__chkstk_darwin(v13) + 15) & 0xFFFFFFFFFFFFFFF0LL);
        uint64_t v15 = __error();
        uint64_t v16 = _os_log_pack_fill(v14, v13, *v15, &dword_0, "%s: %s() CONFIRM", v31, v32);
        *(_DWORD *)uint64_t v16 = 136315394;
        *(void *)(v16 + 4) = a1;
        *(_WORD *)(v16 + 12) = 2080;
        *(void *)(v16 + 14) = "DHCPv6ClientStartInternal";
        __SC_log_send(5LL, v11, v12, v14);
      }

      sub_42578(a1, 0, 0LL);
    }

    else
    {
      uint64_t v17 = sub_57538();
      uint64_t v18 = _SC_syslog_os_log_mapping(5LL);
      if (__SC_log_enabled(5LL, v17, v18))
      {
        uint64_t v19 = _os_log_pack_size(22LL);
        __n128 v20 = (char *)&v31 - ((__chkstk_darwin(v19) + 15) & 0xFFFFFFFFFFFFFFF0LL);
        uint64_t v21 = __error();
        uint64_t v22 = _os_log_pack_fill(v20, v19, *v21, &dword_0, "%s: %s() SOLICIT", v31, v32);
        *(_DWORD *)uint64_t v22 = 136315394;
        *(void *)(v22 + 4) = a1;
        *(_WORD *)(v22 + 12) = 2080;
        *(void *)(v22 + 14) = "DHCPv6ClientStartInternal";
        __SC_log_send(5LL, v17, v18, v20);
      }

      sub_42B4C(a1, 0, 0LL);
    }
  }

uint64_t sub_403F8(uint64_t result, int a2)
{
  if (*(_DWORD *)(result + 116) != a2)
  {
    uint64_t v3 = result;
    uint64_t result = sub_3F880(result, (uint64_t)"DHCPv6ClientSetMode");
    if ((_DWORD)result)
    {
      *(_DWORD *)(v3 + 116) = a2;
      return sub_3FDE0(v3);
    }
  }

  return result;
}

void sub_40448(uint64_t a1)
{
}

void sub_40484(uint64_t a1)
{
  *(void *)(a1 + 232) = 0LL;
  *(_OWORD *)(a1 + 216) = 0u;
  *(_OWORD *)(a1 + 200) = 0u;
  uint64_t v2 = *(void **)(a1 + 176);
  if (v2)
  {
    free(v2);
    *(void *)(a1 + 176) = 0LL;
    *(_DWORD *)(a1 + 184) = 0;
  }

  sub_579E8((void **)(a1 + 192));
  *(_BYTE *)(a1 + 240) = 0;
  *(_DWORD *)(a1 + 184) = 0;
  *(void *)(a1 + 272) = 0LL;
  *(void *)(a1 + 280) = 0LL;
  *(void *)(a1 + 264) = 0LL;
}

void sub_404E4(uint64_t a1)
{
  *(void *)(a1 + 84) = 0LL;
  *(void *)(a1 + 76) = 0LL;
  *(_BYTE *)(a1 + 92) = 0;
  *(_BYTE *)(a1 + 240) = 0;
  sub_40908(a1, 0);
  *(_DWORD *)(a1 + 116) = 0;
  sub_4FA18((const void **)(a1 + 248));
  uint64_t v2 = *(dispatch_source_s **)(a1 + 32);
  if (v2) {
    dispatch_source_merge_data(v2, 1uLL);
  }
}

uint64_t sub_4055C(uint64_t a1, uint64_t a2)
{
  uint64_t result = sub_468A4(*(void *)(a1 + 128));
  uint64_t v5 = result;
  if (*(_DWORD *)(a1 + 56) || *(_DWORD *)(a1 + 60) || *(_DWORD *)(a1 + 64) || *(_DWORD *)(a1 + 68))
  {
    uint64_t v6 = sub_57538();
    uint64_t v7 = _SC_syslog_os_log_mapping(6LL);
    if (__SC_log_enabled(6LL, v6, v7))
    {
      uint64_t v8 = _os_log_pack_size(32LL);
      uint64_t v9 = (char *)&v37 - ((__chkstk_darwin(v8) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v10 = __error();
      uint64_t v11 = _os_log_pack_fill(v9, v8, *v10, &dword_0, "%s: %s: removing %s", v37, v38, v39);
      uint64_t v12 = inet_ntop(30, (const void *)(a1 + 56), (char *)&v38 + 2, 0x2Eu);
      *(_DWORD *)uint64_t v11 = 136315650;
      *(void *)(v11 + 4) = a1;
      *(_WORD *)(v11 + 12) = 2080;
      *(void *)(v11 + 14) = a2;
      *(_WORD *)(v11 + 22) = 2080;
      *(void *)(v11 + 24) = v12;
      __SC_log_send(6LL, v6, v7, v9);
    }

    int v13 = sub_32804();
    if (v13 < 0)
    {
      uint64_t v27 = sub_57538();
      uint64_t v28 = _SC_syslog_os_log_mapping(5LL);
      uint64_t result = __SC_log_enabled(5LL, v27, v28);
      if ((_DWORD)result)
      {
        uint64_t v29 = _os_log_pack_size(28LL);
        uint64_t v30 = (char *)&v37 - ((__chkstk_darwin(v29) + 15) & 0xFFFFFFFFFFFFFFF0LL);
        uint64_t v31 = __error();
        uint64_t v32 = _os_log_pack_fill( v30,  v29,  *v31,  &dword_0,  "DHCPv6ClientRemoveAddress(%s):socket() failed, %s (%d)",  v37,  v38,  (_DWORD)v39);
        uint64_t v33 = nullsub_1(v5);
        uint64_t v34 = __error();
        uint64_t v35 = strerror(*v34);
        int v36 = *__error();
        *(_DWORD *)uint64_t v32 = 136315650;
        *(void *)(v32 + 4) = v33;
        *(_WORD *)(v32 + 12) = 2080;
        *(void *)(v32 + 14) = v35;
        *(_WORD *)(v32 + 22) = 1024;
        *(_DWORD *)(v32 + 24) = v36;
        uint64_t result = __SC_log_send(5LL, v27, v28, v30);
      }
    }

    else
    {
      int v14 = v13;
      uint64_t v15 = (const char *)nullsub_1(v5);
      if ((sub_347B8(v14, v15, (_OWORD *)(a1 + 56)) & 0x80000000) != 0)
      {
        uint64_t v16 = sub_57538();
        uint64_t v17 = _SC_syslog_os_log_mapping(6LL);
        if (__SC_log_enabled(6LL, v16, v17))
        {
          uint64_t v18 = _os_log_pack_size(38LL);
          uint64_t v37 = (const char *)&v37;
          uint64_t v19 = (char *)&v37 - ((__chkstk_darwin(v18) + 15) & 0xFFFFFFFFFFFFFFF0LL);
          __n128 v20 = __error();
          uint64_t v21 = _os_log_pack_fill( v19,  v18,  *v20,  &dword_0,  "DHCPv6ClientRemoveAddress(%s): remove %s failed, %s (%d)",  v37,  v38,  v39,  v40);
          uint64_t v22 = nullsub_1(v5);
          uint64_t v23 = inet_ntop(30, (const void *)(a1 + 56), (char *)&v38 + 2, 0x2Eu);
          uint64_t v24 = __error();
          uint64_t v25 = strerror(*v24);
          int v26 = *__error();
          *(_DWORD *)uint64_t v21 = 136315906;
          *(void *)(v21 + 4) = v22;
          *(_WORD *)(v21 + 12) = 2080;
          *(void *)(v21 + 14) = v23;
          *(_WORD *)(v21 + 22) = 2080;
          *(void *)(v21 + 24) = v25;
          *(_WORD *)(v21 + 32) = 1024;
          *(_DWORD *)(v21 + 34) = v26;
          __SC_log_send(6LL, v16, v17, v19);
        }
      }

      uint64_t result = close(v14);
    }

    *(void *)(a1 + 56) = 0LL;
    *(void *)(a1 + 64) = 0LL;
    *(_BYTE *)(a1 + 72) = 0;
  }

  return result;
}

uint64_t sub_40908(uint64_t a1, unsigned int a2)
{
  *(_DWORD *)(a1 + 120) = a2;
  uint64_t v4 = sub_57538();
  uint64_t v5 = _SC_syslog_os_log_mapping(6LL);
  uint64_t result = __SC_log_enabled(6LL, v4, v5);
  if ((_DWORD)result)
  {
    uint64_t v7 = _os_log_pack_size(22LL);
    uint64_t v8 = (char *)v12 - ((__chkstk_darwin(v7) + 15) & 0xFFFFFFFFFFFFFFF0LL);
    uint64_t v9 = __error();
    uint64_t v10 = _os_log_pack_fill(v8, v7, *v9, &dword_0, "%s: %s", v12[0], v12[1]);
    if (a2 > 0xB) {
      uint64_t v11 = "<unknown>";
    }
    else {
      uint64_t v11 = off_64F98[a2];
    }
    *(_DWORD *)uint64_t v10 = 136315394;
    *(void *)(v10 + 4) = a1;
    *(_WORD *)(v10 + 12) = 2080;
    *(void *)(v10 + 14) = v11;
    return __SC_log_send(6LL, v4, v5, v8);
  }

  return result;
}

void sub_40A4C(uint64_t *a1)
{
  uint64_t v1 = *a1;
  if (*a1)
  {
    *a1 = 0LL;
    double current_time = timer_get_current_time();
    if (*(void *)(v1 + 144)) {
      timer_callout_free((uint64_t *)(v1 + 144));
    }
    sub_46A40((void **)(v1 + 128));
    sub_40484(v1);
    sub_40E20((void *)v1, 0LL, 0LL);
    sub_579E8((void **)(v1 + 192));
    sub_4FA18((const void **)(v1 + 248));
    free((void *)v1);
  }

uint64_t sub_40AD8(uint64_t a1, double a2)
{
  if (*(_BYTE *)(a1 + 224))
  {
    unsigned int v3 = *(_DWORD *)(a1 + 216);
    if (v3 != -1)
    {
      double v4 = *(double *)(a1 + 200);
      if (v4 <= a2)
      {
        if (a2 - v4 >= (double)v3)
        {
          uint64_t v11 = sub_57538();
          uint64_t v12 = _SC_syslog_os_log_mapping(6LL);
          if (__SC_log_enabled(6LL, v11, v12))
          {
            uint64_t v13 = _os_log_pack_size(12LL);
            int v14 = (char *)&v18 - ((__chkstk_darwin(v13) + 15) & 0xFFFFFFFFFFFFFFF0LL);
            uint64_t v15 = __error();
            uint64_t v16 = _os_log_pack_fill(v14, v13, *v15, &dword_0, "%s: lease has expired", v18);
            *(_DWORD *)uint64_t v16 = 136315138;
            *(void *)(v16 + 4) = a1;
            __SC_log_send(6LL, v11, v12, v14);
          }

          sub_40484(a1);
          *(_BYTE *)(a1 + 224) = 0;
        }
      }

      else
      {
        sub_40484(a1);
        *(_BYTE *)(a1 + 224) = 0;
        uint64_t v5 = sub_57538();
        uint64_t v6 = _SC_syslog_os_log_mapping(6LL);
        if (__SC_log_enabled(6LL, v5, v6))
        {
          uint64_t v7 = _os_log_pack_size(12LL);
          uint64_t v8 = (char *)&v18 - ((__chkstk_darwin(v7) + 15) & 0xFFFFFFFFFFFFFFF0LL);
          uint64_t v9 = __error();
          uint64_t v10 = _os_log_pack_fill(v8, v7, *v9, &dword_0, "%s: lease no longer valid", v18);
          *(_DWORD *)uint64_t v10 = 136315138;
          *(void *)(v10 + 4) = a1;
          __SC_log_send(6LL, v5, v6, v8);
        }
      }
    }
  }

  return *(unsigned __int8 *)(a1 + 224);
}

uint64_t sub_40CD8(uint64_t a1)
{
  *(_DWORD *)(a1 + 156) = 0;
  *(_DWORD *)(a1 + 152) = arc4random() & 0xFFFFFF;
  uint64_t v2 = sub_57538();
  uint64_t v3 = _SC_syslog_os_log_mapping(6LL);
  if (__SC_log_enabled(6LL, v2, v3))
  {
    uint64_t v4 = _os_log_pack_size(12LL);
    uint64_t v5 = (char *)&v9 - ((__chkstk_darwin(v4) + 15) & 0xFFFFFFFFFFFFFFF0LL);
    uint64_t v6 = __error();
    uint64_t v7 = _os_log_pack_fill(v5, v4, *v6, &dword_0, "%s: Release Transmit", v9);
    *(_DWORD *)uint64_t v7 = 136315138;
    *(void *)(v7 + 4) = a1;
    __SC_log_send(6LL, v2, v3, v5);
  }

  return sub_443E4(a1);
}

void sub_40E20(void *a1, uint64_t a2, uint64_t a3)
{
  a1[5] = a2;
  a1[6] = a3;
  uint64_t v4 = (dispatch_source_s *)a1[4];
  if (a2)
  {
    if (!v4)
    {
      uint64_t v5 = sub_2A814();
      uint64_t v6 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_data_add, 0LL, 0LL, v5);
      handler[0] = _NSConcreteStackBlock;
      handler[1] = 0x40000000LL;
      handler[2] = sub_40FE0;
      handler[3] = &unk_64F78;
      handler[4] = a1;
      dispatch_source_set_event_handler(v6, handler);
      dispatch_activate(v6);
      a1[4] = v6;
    }
  }

  else if (v4)
  {
    a1[4] = 0LL;
    dispatch_source_cancel(v4);
    dispatch_release(v4);
  }

uint64_t sub_40EE0(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 192);
  if (v2 && *(_BYTE *)(a1 + 240) && (int v3 = *(_DWORD *)(a1 + 184)) != 0)
  {
    *(void *)a2 = *(void *)(a1 + 176);
    *(_DWORD *)(a2 + 8) = v3;
    *(void *)(a2 + 16) = v2;
    int v4 = *(_DWORD *)(a1 + 116);
    if (v4 == 3)
    {
      *(_OWORD *)(a2 + 76) = *(_OWORD *)(a1 + 76);
      *(_BYTE *)(a2 + 92) = *(_BYTE *)(a1 + 92);
      uint64_t v8 = *(void *)(a1 + 216);
      *(void *)(a2 + 96) = v8;
      unsigned int v5 = v8;
    }

    else
    {
      if (v4 != 2) {
        return 1LL;
      }
      unsigned int v5 = *(_DWORD *)(a1 + 216);
    }

    uint64_t v6 = 1LL;
    *(_DWORD *)(a2 + 72) = 1;
    double v9 = *(double *)(a1 + 200);
    *(double *)(a2 + 24) = v9;
    *(void *)(a2 + 32) = 0LL;
    if (v5 != -1) {
      *(double *)(a2 + 32) = v9 + (double)v5;
    }
  }

  else
  {
    uint64_t v6 = 0LL;
    *(void *)a2 = 0LL;
    *(_DWORD *)(a2 + 8) = 0;
    *(void *)(a2 + 16) = 0LL;
    *(_DWORD *)(a2 + 72) = 0;
  }

  return v6;
}

uint64_t sub_40F90(uint64_t result, uint64_t a2)
{
  if (!*(_DWORD *)(result + 56) && !*(_DWORD *)(result + 60) && !*(_DWORD *)(result + 64) && !*(_DWORD *)(result + 68)) {
    return sub_360D0(a2);
  }
  *(void *)a2 = a2 + 12;
  *(_DWORD *)(a2 + 8) = 1;
  *(_OWORD *)(a2 + 12) = *(_OWORD *)(result + 56);
  *(void *)(a2 + 28) = *(unsigned __int8 *)(result + 72);
  return result;
}

uint64_t sub_40FE0(uint64_t a1)
{
  return sub_40FE8(*(void *)(a1 + 32));
}

uint64_t sub_40FE8(uint64_t a1)
{
  uint64_t v1 = *(uint64_t (**)(uint64_t, void, uint64_t))(a1 + 40);
  if (v1) {
    return v1(a1, *(void *)(a1 + 48), 1LL);
  }
  uint64_t v3 = sub_57538();
  uint64_t v4 = _SC_syslog_os_log_mapping(5LL);
  uint64_t result = __SC_log_enabled(5LL, v3, v4);
  if ((_DWORD)result)
  {
    uint64_t v5 = _os_log_pack_size(2LL);
    uint64_t v6 = (char *)&v8 - ((__chkstk_darwin(v5) + 15) & 0xFFFFFFFFFFFFFFF0LL);
    uint64_t v7 = __error();
    *(_WORD *)_os_log_pack_fill( v6,  v5,  *v7,  &dword_0,  "DHCPv6Client: runloop source signaled but callback is NULL") = 0;
    return __SC_log_send(5LL, v3, v4, v6);
  }

  return result;
}

void DHCPv6ClientHandleEvent(uint64_t a1, int a2, uint64_t *a3)
{
  if (*(_DWORD *)(a1 + 116) == 2)
  {
    switch(a2)
    {
      case 8:
        goto LABEL_5;
      case 9:
      case 10:
      case 12:
      case 13:
      case 14:
        return;
      case 11:
        sub_41334(a1, a3);
        break;
      case 15:
        sub_41178(a1, a3);
        break;
      case 16:
        sub_418D0(a1);
        break;
      default:
        if (a2 == 3) {
LABEL_5:
        }
          sub_416DC(a1, (uint64_t)a3);
        break;
    }
  }

void sub_41178(uint64_t a1, uint64_t *a2)
{
  if (a2)
  {
    int v2 = *((_DWORD *)a2 + 2);
    if (v2)
    {
      if (*(_DWORD *)(a1 + 120) == 3 && v2 >= 1)
      {
        for (uint64_t i = *a2; *(void *)(a1 + 56) != *(void *)i || *(void *)(a1 + 64) != *(void *)(i + 8); i += 32LL)
        {
          if (!--v2) {
            return;
          }
        }

        int v6 = *(_DWORD *)(i + 20);
        if ((v6 & 4) != 0)
        {
          sub_4636C(a1, 0, 0LL);
        }

        else if ((v6 & 2) != 0)
        {
          uint64_t v8 = sub_57538();
          uint64_t v9 = _SC_syslog_os_log_mapping(6LL);
          if (__SC_log_enabled(6LL, v8, v9))
          {
            uint64_t v10 = _os_log_pack_size(2LL);
            uint64_t v11 = (char *)&v13 - ((__chkstk_darwin(v10) + 15) & 0xFFFFFFFFFFFFFFF0LL);
            uint64_t v12 = __error();
            *(_WORD *)_os_log_pack_fill(v11, v10, *v12, &dword_0, "address is still tentative") = 0;
            __SC_log_send(6LL, v8, v9, v11);
          }
        }

        else
        {
          uint64_t v7 = *(dispatch_source_s **)(a1 + 32);
          if (v7) {
            dispatch_source_merge_data(v7, 1uLL);
          }
        }
      }
    }
  }

void sub_41334(uint64_t a1, _DWORD *a2)
{
  uint64_t v4 = sub_468A4(*(void *)(a1 + 128));
  uint64_t v5 = v4;
  if (a2[1] && !a2[2])
  {
    sub_4055C(a1, (uint64_t)"Wake");
  }

  else if (sub_54E78(v4) && *a2 == 1 || !sub_54E78(v5) && !a2[3])
  {
    sub_4055C(a1, (uint64_t)"Wake");
    if (*(_DWORD *)(a1 + 120) != 1) {
      sub_42B4C(a1, 0, 0LL);
    }
  }

  else
  {
    double current_time = timer_get_current_time();
    char v7 = sub_40AD8(a1, current_time);
    int v8 = *(_DWORD *)(a1 + 120);
    if ((v7 & 1) != 0)
    {
      if ((v8 - 3) > 2 || *a2 == 2)
      {
        sub_42578(a1, 0, 0LL);
      }

      else if (*(_DWORD *)(a1 + 216) != -1)
      {
        double v9 = *(double *)(a1 + 256);
        int v10 = dword_6C07C;
        uint64_t v11 = sub_57538();
        uint64_t v12 = _SC_syslog_os_log_mapping(6LL);
        int v13 = __SC_log_enabled(6LL, v11, v12);
        if (current_time >= v9 || (double v14 = v9 - current_time, v14 < (double)v10))
        {
          if (v13)
          {
            uint64_t v19 = _os_log_pack_size(12LL);
            __n128 v20 = (char *)v23 - ((__chkstk_darwin(v19) + 15) & 0xFFFFFFFFFFFFFFF0LL);
            uint64_t v21 = __error();
            uint64_t v22 = _os_log_pack_fill(v20, v19, *v21, &dword_0, "%s: wake: need to renew/rebind", v23[0]);
            *(_DWORD *)uint64_t v22 = 136315138;
            *(void *)(v22 + 4) = a1;
            __SC_log_send(6LL, v11, v12, v20);
          }

          sub_45500(a1, 0, 0LL);
        }

        else
        {
          if (v13)
          {
            uint64_t v15 = _os_log_pack_size(22LL);
            uint64_t v16 = (char *)v23 - ((__chkstk_darwin(v15) + 15) & 0xFFFFFFFFFFFFFFF0LL);
            uint64_t v17 = __error();
            uint64_t v18 = _os_log_pack_fill( v16,  v15,  *v17,  &dword_0,  "%s: wake: calculated new timer (%lu secs)",  v23[0],  v23[1]);
            *(_DWORD *)uint64_t v18 = 136315394;
            *(void *)(v18 + 4) = a1;
            *(_WORD *)(v18 + 12) = 2048;
            *(void *)(v18 + 14) = (unint64_t)v14;
            __SC_log_send(6LL, v11, v12, v16);
          }

          timer_callout_set(*(void *)(a1 + 144), (uint64_t)sub_45500, a1, 0LL, 0LL, v14);
        }
      }
    }

    else if (v8 != 1)
    {
      sub_44A38((void *)a1);
    }
  }

void sub_416DC(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 4) && !*(_DWORD *)(a2 + 8))
  {
    uint64_t v9 = sub_57538();
    uint64_t v10 = _SC_syslog_os_log_mapping(5LL);
    if (__SC_log_enabled(5LL, v9, v10))
    {
      uint64_t v11 = _os_log_pack_size(22LL);
      uint64_t v12 = (char *)&v15 - ((__chkstk_darwin(v11) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      int v13 = __error();
      uint64_t v14 = _os_log_pack_fill(v12, v11, *v13, &dword_0, "%s: %s() link is inactive", v15, v16);
      *(_DWORD *)uint64_t v14 = 136315394;
      *(void *)(v14 + 4) = a1;
      *(_WORD *)(v14 + 12) = 2080;
      *(void *)(v14 + 14) = "DHCPv6ClientHandleLinkStatusRenew";
      __SC_log_send(5LL, v9, v10, v12);
    }
  }

  else
  {
    uint64_t v3 = sub_57538();
    uint64_t v4 = _SC_syslog_os_log_mapping(5LL);
    if (__SC_log_enabled(5LL, v3, v4))
    {
      uint64_t v5 = _os_log_pack_size(22LL);
      int v6 = (char *)&v15 - ((__chkstk_darwin(v5) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      char v7 = __error();
      uint64_t v8 = _os_log_pack_fill(v6, v5, *v7, &dword_0, "%s: %s() link is active", v15, v16);
      *(_DWORD *)uint64_t v8 = 136315394;
      *(void *)(v8 + 4) = a1;
      *(_WORD *)(v8 + 12) = 2080;
      *(void *)(v8 + 14) = "DHCPv6ClientHandleLinkStatusRenew";
      __SC_log_send(5LL, v3, v4, v6);
    }

    sub_3FFF8(a1);
  }

void sub_418D0(uint64_t a1)
{
  uint64_t v2 = sub_57538();
  uint64_t v3 = _SC_syslog_os_log_mapping(5LL);
  if (__SC_log_enabled(5LL, v2, v3))
  {
    uint64_t v4 = _os_log_pack_size(32LL);
    uint64_t v5 = (char *)v11 - ((__chkstk_darwin(v4) + 15) & 0xFFFFFFFFFFFFFFF0LL);
    int v6 = __error();
    uint64_t v7 = _os_log_pack_fill(v5, v4, *v6, &dword_0, "%s: %s() state is %s", v11[0], v11[1], v11[2]);
    uint64_t v8 = *(unsigned int *)(a1 + 120);
    else {
      uint64_t v9 = off_64F98[v8];
    }
    *(_DWORD *)uint64_t v7 = 136315650;
    *(void *)(v7 + 4) = a1;
    *(_WORD *)(v7 + 12) = 2080;
    *(void *)(v7 + 14) = "DHCPv6ClientHandleRoam";
    *(_WORD *)(v7 + 22) = 2080;
    *(void *)(v7 + 24) = v9;
    __SC_log_send(5LL, v2, v3, v5);
  }

  double current_time = timer_get_current_time();
  if (sub_40AD8(a1, current_time))
  {
  }

uint64_t sub_41A48(uint64_t a1, int a2, __CFDictionary *a3)
{
  uint64_t v6 = sub_194C4(a1);
  v40[0] = (const char *)v6;
  uint64_t v7 = sub_14834(a1);
  uint64_t result = 0LL;
  switch(a2)
  {
    case 0:
      if (!v6)
      {
        sub_41EA0(a1, (uint64_t)a3);
        goto LABEL_25;
      }

      uint64_t v15 = sub_57538();
      uint64_t v16 = _SC_syslog_os_log_mapping(5LL);
      uint64_t v17 = _os_log_pack_size(12LL);
      uint64_t v18 = (char *)v40 - ((__chkstk_darwin(v17) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v19 = __error();
      uint64_t v20 = _os_log_pack_fill(v18, v17, *v19, &dword_0, "%s: re-entering start state", v40[0]);
      *(_DWORD *)uint64_t v20 = 136315138;
      *(void *)(v20 + 4) = v6;
      uint64_t v21 = v15;
      uint64_t v22 = v16;
      goto LABEL_29;
    case 1:
      uint64_t v23 = sub_57538();
      uint64_t v24 = _SC_syslog_os_log_mapping(5LL);
      if (__SC_log_enabled(5LL, v23, v24))
      {
        uint64_t v25 = _os_log_pack_size(12LL);
        int v26 = (char *)v40 - ((__chkstk_darwin(v25) + 15) & 0xFFFFFFFFFFFFFFF0LL);
        uint64_t v27 = __error();
        uint64_t v28 = _os_log_pack_fill(v26, v25, *v27, &dword_0, "DHCPv6 %s: stop", v40[0]);
        uint64_t v29 = nullsub_1(v7);
        *(_DWORD *)uint64_t v28 = 136315138;
        *(void *)(v28 + 4) = v29;
        __SC_log_send(5LL, v23, v24, v26);
      }

      if (v6)
      {
        sub_40A4C((uint64_t *)v40);
        sub_194CC(a1, 0LL);
LABEL_25:
        uint64_t result = 0LL;
      }

      else
      {
        uint64_t v34 = sub_57538();
        uint64_t v35 = _SC_syslog_os_log_mapping(5LL);
        if (__SC_log_enabled(5LL, v34, v35))
        {
          uint64_t v36 = _os_log_pack_size(12LL);
          uint64_t v18 = (char *)v40 - ((__chkstk_darwin(v36) + 15) & 0xFFFFFFFFFFFFFFF0LL);
          uint64_t v37 = __error();
          uint64_t v38 = _os_log_pack_fill(v18, v36, *v37, &dword_0, "DHCPv6 %s: already stopped", v40[0]);
          uint64_t v39 = nullsub_1(v7);
          *(_DWORD *)uint64_t v38 = 136315138;
          *(void *)(v38 + 4) = v39;
          uint64_t v21 = v34;
          uint64_t v22 = v35;
LABEL_29:
          __SC_log_send(5LL, v21, v22, v18);
          uint64_t result = 6LL;
        }

        else
        {
LABEL_30:
          uint64_t result = 6LL;
        }
      }

      break;
    case 3:
    case 8:
      uint64_t v9 = sub_57538();
      uint64_t v10 = _SC_syslog_os_log_mapping(5LL);
      if (__SC_log_enabled(5LL, v9, v10))
      {
        uint64_t v11 = _os_log_pack_size(22LL);
        uint64_t v12 = (char *)v40 - ((__chkstk_darwin(v11) + 15) & 0xFFFFFFFFFFFFFFF0LL);
        int v13 = __error();
        uint64_t v14 = _os_log_pack_fill(v12, v11, *v13, &dword_0, "%s: %s() link status changed", v40[0], v40[1]);
        *(_DWORD *)uint64_t v14 = 136315394;
        *(void *)(v14 + 4) = v6;
        *(_WORD *)(v14 + 12) = 2080;
        *(void *)(v14 + 14) = "dhcpv6_pd_thread";
        __SC_log_send(5LL, v9, v10, v12);
      }

      sub_403F8(v6, 3);
      sub_416DC(v6, (uint64_t)a3);
      goto LABEL_25;
    case 4:
      sub_404E4(v6);
      goto LABEL_25;
    case 7:
      uint64_t v30 = *(uint64_t **)a3;
      *((_DWORD *)a3 + 2) = 0;
      if (!v30) {
        goto LABEL_25;
      }
      if (*(unsigned __int8 *)(v6 + 112) == *((unsigned __int8 *)v30 + 16))
      {
        uint64_t v32 = *v30;
        uint64_t v31 = v30[1];
        if (v32 == *(void *)(v6 + 96) && v31 == *(void *)(v6 + 104)) {
          goto LABEL_25;
        }
      }

      uint64_t result = 0LL;
      *((_DWORD *)a3 + 2) = 1;
      break;
    case 11:
      sub_41334(v6, a3);
      goto LABEL_25;
    case 14:
      sub_40EE0(v6, (uint64_t)a3);
      goto LABEL_25;
    case 16:
      sub_418D0(v6);
      goto LABEL_25;
    case 22:
      sub_3FA84(v6, a3);
      goto LABEL_25;
    default:
      return result;
  }

  return result;
}

void sub_41EA0(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = sub_14834(a1);
  uint64_t v5 = sub_3FD04(a1);
  sub_194CC(a1, (uint64_t)v5);
  sub_403F8((uint64_t)v5, 3);
  uint64_t v6 = sub_57538();
  uint64_t v7 = _SC_syslog_os_log_mapping(5LL);
  if (__SC_log_enabled(5LL, v6, v7))
  {
    uint64_t v8 = _os_log_pack_size(12LL);
    uint64_t v9 = (char *)&v13 - ((__chkstk_darwin(v8) + 15) & 0xFFFFFFFFFFFFFFF0LL);
    uint64_t v10 = __error();
    uint64_t v11 = _os_log_pack_fill(v9, v8, *v10, &dword_0, "%s: start", v13);
    *(_DWORD *)uint64_t v11 = 136315138;
    *(void *)(v11 + 4) = v5;
    __SC_log_send(5LL, v6, v7, v9);
  }

  if (a2 && *(_BYTE *)(a2 + 16) && *((_DWORD *)v5 + 29) == 3)
  {
    *((_BYTE *)v5 + 112) = *(_BYTE *)(a2 + 16);
    int v5[6] = *(_OWORD *)a2;
  }

  sub_40E20(v5, (uint64_t)sub_466D4, 0LL);
  unint64_t v12 = sub_54F74(v4);
  if (HIDWORD(v12) || !(_DWORD)v12) {
    sub_3FE64((uint64_t)v5);
  }
}

void sub_42038(uint64_t a1, int a2, unsigned __int8 **a3)
{
  uint64_t v6 = sub_468A4(*(void *)(a1 + 128));
  if (a2 == 5)
  {
    if (**a3 == 7)
    {
      if (sub_43418(a1, (uint64_t)a3[2]))
      {
        uint64_t v11 = sub_57BD4((uint64_t)a3[2], 2, (unsigned int *)&v32 + 1, 0LL);
        if (v11)
        {
          if (sub_56AA8(v11, SHIDWORD(v32)))
          {
            uint64_t v12 = sub_57538();
            uint64_t v13 = _SC_syslog_os_log_mapping(6LL);
            if (__SC_log_enabled(6LL, v12, v13))
            {
              uint64_t v14 = _os_log_pack_size(28LL);
              uint64_t v15 = (char *)&v32 - ((__chkstk_darwin(v14) + 15) & 0xFFFFFFFFFFFFFFF0LL);
              uint64_t v16 = __error();
              uint64_t v17 = _os_log_pack_fill(v15, v14, *v16, &dword_0, "%s: %s Received (try=%d)", v32, v33, v34);
              uint64_t v18 = DHCPv6MessageTypeName(**a3);
              int v19 = *(_DWORD *)(a1 + 156);
              *(_DWORD *)uint64_t v17 = 136315650;
              *(void *)(v17 + 4) = a1;
              *(_WORD *)(v17 + 12) = 2080;
              *(void *)(v17 + 14) = v18;
              *(_WORD *)(v17 + 22) = 1024;
              *(_DWORD *)(v17 + 24) = v19;
              __SC_log_send(6LL, v12, v13, v15);
            }

            sub_4349C(a1, (uint64_t)a3);
            uint64_t v20 = *(dispatch_source_s **)(a1 + 32);
            if (v20) {
              dispatch_source_merge_data(v20, 1uLL);
            }
            sub_437A8(a1);
          }
        }
      }
    }
  }

  else
  {
    uint64_t v7 = v6;
    if (a2 != 2)
    {
      if (a2) {
        return;
      }
      sub_40908(a1, 0xAu);
      sub_40484(a1);
      *(_DWORD *)(a1 + 156) = 0;
      uint32_t v8 = arc4random();
      *(_DWORD *)(a1 + 152) = v8 & 0xFFFFFF;
      sub_46BD8(*(void *)(a1 + 128), v8 & 0xFFFFFF, (uint64_t)sub_42038, a1, 5LL);
      if (sub_54228(v7) != 255)
      {
        uint64_t v30 = *(void *)(a1 + 144);
        uint32_t v31 = arc4random();
        timer_callout_set(v30, (uint64_t)sub_42038, a1, 2LL, 0LL, (double)v31 / 4294967300.0);
        return;
      }
    }

    if (*(_DWORD *)(a1 + 156))
    {
      unint64_t v9 = sub_54F74(v7);
      if (HIDWORD(v9)) {
        BOOL v10 = 1;
      }
      else {
        BOOL v10 = v9 == 0LL;
      }
      if (!v10)
      {
        sub_4314C((void *)a1);
        return;
      }
    }

    else
    {
      *(CFAbsoluteTime *)(a1 + 160) = timer_get_current_time();
    }

    uint64_t v21 = *(void *)(a1 + 144);
    sub_431A8(a1, 1.0, 3600.0);
    timer_callout_set(v21, (uint64_t)sub_42038, a1, 2LL, 0LL, v22);
    uint64_t v23 = sub_57538();
    uint64_t v24 = _SC_syslog_os_log_mapping(6LL);
    if (__SC_log_enabled(6LL, v23, v24))
    {
      uint64_t v25 = _os_log_pack_size(18LL);
      int v26 = (char *)&v32 - ((__chkstk_darwin(v25) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v27 = __error();
      uint64_t v28 = _os_log_pack_fill(v26, v25, *v27, &dword_0, "%s: Inform Transmit (try=%d)", v32, (_DWORD)v33);
      int v29 = *(_DWORD *)(a1 + 156);
      *(_DWORD *)uint64_t v28 = 136315394;
      *(void *)(v28 + 4) = a1;
      *(_WORD *)(v28 + 12) = 1024;
      *(_DWORD *)(v28 + 14) = v29;
      __SC_log_send(6LL, v23, v24, v26);
    }

    sub_43284(a1);
  }

uint64_t sub_42410(uint64_t a1)
{
  uint64_t v2 = sub_14834(*(void *)(a1 + 136));
  uint64_t v3 = (const void *)sub_19BF0(*(void *)(a1 + 136));
  uint64_t v4 = v3;
  if (v3)
  {
    uint64_t v5 = *(const void **)(a1 + 232);
    if (v5)
    {
      if (CFEqual(v3, v5)) {
        return 1LL;
      }
    }
  }

  uint64_t v7 = sub_57538();
  uint64_t v8 = _SC_syslog_os_log_mapping(6LL);
  uint64_t result = __SC_log_enabled(6LL, v7, v8);
  if ((_DWORD)result)
  {
    uint64_t v9 = _os_log_pack_size(32LL);
    BOOL v10 = (char *)&v14 - ((__chkstk_darwin(v9) + 15) & 0xFFFFFFFFFFFFFFF0LL);
    uint64_t v11 = __error();
    uint64_t v12 = _os_log_pack_fill(v10, v9, *v11, &dword_0, "%s: SSID now %@ (was %@)");
    uint64_t v13 = *(void *)(a1 + 232);
    *(_DWORD *)uint64_t v12 = 136315650;
    *(void *)(v12 + 4) = a1;
    *(_WORD *)(v12 + 12) = 2112;
    *(void *)(v12 + 14) = v4;
    *(_WORD *)(v12 + 22) = 2112;
    *(void *)(v12 + 24) = v13;
    __SC_log_send(6LL, v7, v8, v10);
    return 0LL;
  }

  return result;
}

void sub_42578(uint64_t a1, int a2, unsigned __int8 **a3)
{
  double current_time = timer_get_current_time();
  uint64_t v7 = sub_468A4(*(void *)(a1 + 128));
  if (a2 == 5)
  {
    if (**a3 == 7)
    {
      if (sub_43418(a1, (uint64_t)a3[2]))
      {
        uint64_t v15 = sub_57BD4((uint64_t)a3[2], 2, (unsigned int *)&v48, 0LL);
        if (v15)
        {
          if (sub_56AA8(v15, (int)v48)
            && sub_58408((uint64_t)a3[2], (_WORD *)&v48 + 3, &v47, (unsigned int *)&v46 + 1))
          {
            int v16 = HIWORD(v48);
            uint64_t v17 = sub_57538();
            if (v16)
            {
              uint64_t v18 = _SC_syslog_os_log_mapping(5LL);
              if (__SC_log_enabled(5LL, v17, v18))
              {
                uint64_t v19 = _os_log_pack_size(48LL);
                uint64_t v20 = (char *)&v44 - ((__chkstk_darwin(v19) + 15) & 0xFFFFFFFFFFFFFFF0LL);
                uint64_t v21 = __error();
                uint64_t v22 = _os_log_pack_fill( v20,  v19,  *v21,  &dword_0,  "%s: %s %s '%.*s'",  v44,  (const char *)v45,  v46,  (int)v47,  v48);
                uint64_t v23 = DHCPv6MessageTypeName(**a3);
                uint64_t v24 = sub_583E0(HIWORD(v48));
                int v25 = HIDWORD(v46);
                int v26 = v47;
                *(_DWORD *)uint64_t v22 = 136316162;
                *(void *)(v22 + 4) = a1;
                *(_WORD *)(v22 + 12) = 2080;
                *(void *)(v22 + 14) = v23;
                *(_WORD *)(v22 + 22) = 2080;
                *(void *)(v22 + 24) = v24;
                *(_WORD *)(v22 + 32) = 1040;
                *(_DWORD *)(v22 + 34) = v25;
                *(_WORD *)(v22 + 38) = 2080;
                *(void *)(v22 + 40) = v26;
                __SC_log_send(5LL, v17, v18, v20);
              }

              sub_44A38((void *)a1);
            }

            else
            {
              uint64_t v36 = _SC_syslog_os_log_mapping(6LL);
              if (__SC_log_enabled(6LL, v17, v36))
              {
                uint64_t v37 = _os_log_pack_size(28LL);
                uint64_t v38 = (char *)&v44 - ((__chkstk_darwin(v37) + 15) & 0xFFFFFFFFFFFFFFF0LL);
                uint64_t v39 = __error();
                uint64_t v40 = _os_log_pack_fill( v38,  v37,  *v39,  &dword_0,  "%s: %s Received (try=%d)",  v44,  (const char *)v45,  (_DWORD)v46);
                uint64_t v41 = DHCPv6MessageTypeName(**a3);
                int v42 = *(_DWORD *)(a1 + 156);
                *(_DWORD *)uint64_t v40 = 136315650;
                *(void *)(v40 + 4) = a1;
                *(_WORD *)(v40 + 12) = 2080;
                *(void *)(v40 + 14) = v41;
                *(_WORD *)(v40 + 22) = 1024;
                *(_DWORD *)(v40 + 24) = v42;
                __SC_log_send(6LL, v17, v36, v38);
              }

              if (*(_DWORD *)(a1 + 116) == 3 && sub_43C00(a1, **a3, 0, (uint64_t)a3[2], (const char *)&v45, 0LL))
              {
                sub_44AA0(a1, **a3, 0, &v45, v43);
                sub_4349C(a1, (uint64_t)a3);
              }

              sub_442BC(a1);
            }
          }
        }
      }
    }
  }

  else
  {
    if (a2 != 2)
    {
      if (!a2)
      {
        sub_40908(a1, 6u);
        sub_46FA0(*(void *)(a1 + 128));
        timer_cancel(*(void *)(a1 + 144));
        *(_DWORD *)(a1 + 156) = 0;
        *(_BYTE *)(a1 + 240) = 0;
        uint32_t v8 = arc4random();
        *(_DWORD *)(a1 + 152) = v8 & 0xFFFFFF;
        sub_46BD8(*(void *)(a1 + 128), v8 & 0xFFFFFF, (uint64_t)sub_42578, a1, 5LL);
        uint64_t v9 = *(void *)(a1 + 144);
        uint32_t v10 = arc4random();
        timer_callout_set(v9, (uint64_t)sub_42578, a1, 2LL, 0LL, (double)v10 / 4294967300.0);
      }

      return;
    }

    if (*(_DWORD *)(a1 + 156))
    {
      unint64_t v11 = sub_54F74(v7);
      if (HIDWORD(v11)) {
        BOOL v12 = 1;
      }
      else {
        BOOL v12 = v11 == 0LL;
      }
      if (!v12)
      {
        sub_4314C((void *)a1);
        return;
      }

      double v13 = *(double *)(a1 + 160);
      if (current_time <= v13 || current_time - v13 >= 10.0)
      {
        else {
          sub_42B4C(a1, 0, 0LL);
        }
        return;
      }
    }

    else
    {
      *(double *)(a1 + 160) = current_time;
    }

    uint64_t v27 = *(void *)(a1 + 144);
    sub_431A8(a1, 1.0, 4.0);
    timer_callout_set(v27, (uint64_t)sub_42578, a1, 2LL, 0LL, v28);
    uint64_t v29 = sub_57538();
    uint64_t v30 = _SC_syslog_os_log_mapping(6LL);
    if (__SC_log_enabled(6LL, v29, v30))
    {
      uint64_t v31 = _os_log_pack_size(18LL);
      uint64_t v32 = (char *)&v44 - ((__chkstk_darwin(v31) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v33 = __error();
      uint64_t v34 = _os_log_pack_fill(v32, v31, *v33, &dword_0, "%s: Confirm Transmit (try=%d)", v44, (_DWORD)v45);
      int v35 = *(_DWORD *)(a1 + 156);
      *(_DWORD *)uint64_t v34 = 136315394;
      *(void *)(v34 + 4) = a1;
      *(_WORD *)(v34 + 12) = 1024;
      *(_DWORD *)(v34 + 14) = v35;
      __SC_log_send(6LL, v29, v30, v32);
    }

    sub_443E4(a1);
  }

void sub_42B4C(uint64_t a1, int a2, unsigned __int8 **a3)
{
  uint64_t v6 = sub_468A4(*(void *)(a1 + 128));
  switch(a2)
  {
    case 5:
      if (**a3 == 2)
      {
        if (sub_43418(a1, (uint64_t)a3[2]))
        {
          BOOL v12 = sub_57BD4((uint64_t)a3[2], 2, (unsigned int *)&v46, 0LL);
          if (v12)
          {
            double v13 = v12;
            if (sub_56AA8(v12, (int)v46))
            {
              if (sub_58408((uint64_t)a3[2], &v49, (unsigned __int16 **)&v47, (unsigned int *)&v46 + 1))
              {
                if (v49)
                {
                  uint64_t v14 = sub_57538();
                  uint64_t v15 = _SC_syslog_os_log_mapping(5LL);
                  if (__SC_log_enabled(5LL, v14, v15))
                  {
                    uint64_t v16 = _os_log_pack_size(48LL);
                    uint64_t v17 = (char *)&v45 - ((__chkstk_darwin(v16) + 15) & 0xFFFFFFFFFFFFFFF0LL);
                    uint64_t v18 = __error();
                    uint64_t v19 = _os_log_pack_fill( v17,  v16,  *v18,  &dword_0,  "%s: %s %s '%.*s'",  v45,  v46,  v47,  v48,  (const char *)v50);
                    uint64_t v20 = DHCPv6MessageTypeName(**a3);
                    uint64_t v21 = sub_583E0(v49);
                    int v22 = HIDWORD(v46);
                    uint64_t v23 = v47;
                    *(_DWORD *)uint64_t v19 = 136316162;
                    *(void *)(v19 + 4) = a1;
                    *(_WORD *)(v19 + 12) = 2080;
                    *(void *)(v19 + 14) = v20;
                    *(_WORD *)(v19 + 22) = 2080;
                    *(void *)(v19 + 24) = v21;
                    *(_WORD *)(v19 + 32) = 1040;
                    *(_DWORD *)(v19 + 34) = v22;
                    *(_WORD *)(v19 + 38) = 2080;
                    *(void *)(v19 + 40) = v23;
                    __SC_log_send(5LL, v14, v15, v17);
                  }
                }

                if ((v49 & 0xFFFB) != 2)
                {
                  int v24 = *(_DWORD *)(a1 + 116);
                  if (v24 == 2)
                  {
                    int v25 = 1;
                  }

                  else
                  {
                    if (v24 != 3) {
                      return;
                    }
                    int v25 = 0;
                  }

                  if (sub_43C00(a1, **a3, v25, (uint64_t)a3[2], (const char *)&v50, 0LL))
                  {
                    sub_44AA0(a1, **a3, v25, &v50, v35);
                    unsigned int v36 = sub_46328((uint64_t)a3[2]);
                    uint64_t v37 = *(void *)(a1 + 192);
                    if (!v37 || sub_46328(v37) < v36)
                    {
                      CFMutableStringRef Mutable = CFStringCreateMutable(0LL, 0LL);
                      sub_5680C(Mutable, v13, bswap32(*(v13 - 1)) >> 16);
                      uint64_t v39 = sub_57538();
                      uint64_t v40 = _SC_syslog_os_log_mapping(6LL);
                      if (__SC_log_enabled(6LL, v39, v40))
                      {
                        uint64_t v41 = _os_log_pack_size(22LL);
                        int v42 = (char *)&v45 - ((__chkstk_darwin(v41) + 15) & 0xFFFFFFFFFFFFFFF0LL);
                        __n128 v43 = __error();
                        uint64_t v44 = _os_log_pack_fill(v42, v41, *v43, &dword_0, "%s: Saving Advertise from %@");
                        *(_DWORD *)uint64_t v44 = 136315394;
                        *(void *)(v44 + 4) = a1;
                        *(_WORD *)(v44 + 12) = 2112;
                        *(void *)(v44 + 14) = Mutable;
                        __SC_log_send(6LL, v39, v40, v42);
                      }

                      CFRelease(Mutable);
                      sub_4349C(a1, (uint64_t)a3);
                    }
                  }
                }
              }
            }
          }
        }
      }

      break;
    case 2:
      if (*(_DWORD *)(a1 + 156))
      {
        unint64_t v10 = sub_54F74(v6);
        if (HIDWORD(v10)) {
          BOOL v11 = 1;
        }
        else {
          BOOL v11 = v10 == 0LL;
        }
        if (!v11)
        {
          sub_4314C((void *)a1);
          return;
        }
      }

      else
      {
        *(CFAbsoluteTime *)(a1 + 160) = timer_get_current_time();
      }

      if (*(_DWORD *)(a1 + 184))
      {
        sub_45B80(a1, 0, 0LL);
      }

      else
      {
        uint64_t v26 = *(void *)(a1 + 144);
        sub_431A8(a1, 1.0, 3600.0);
        timer_callout_set(v26, (uint64_t)sub_42B4C, a1, 2LL, 0LL, v27);
        uint64_t v28 = sub_57538();
        uint64_t v29 = _SC_syslog_os_log_mapping(6LL);
        if (__SC_log_enabled(6LL, v28, v29))
        {
          uint64_t v30 = _os_log_pack_size(18LL);
          uint64_t v31 = (char *)&v45 - ((__chkstk_darwin(v30) + 15) & 0xFFFFFFFFFFFFFFF0LL);
          uint64_t v32 = __error();
          uint64_t v33 = _os_log_pack_fill( v31,  v30,  *v32,  &dword_0,  "%s: Solicit Transmit (try=%d)",  v45,  (_DWORD)v46);
          int v34 = *(_DWORD *)(a1 + 156);
          *(_DWORD *)uint64_t v33 = 136315394;
          *(void *)(v33 + 4) = a1;
          *(_WORD *)(v33 + 12) = 1024;
          *(_DWORD *)(v33 + 14) = v34;
          __SC_log_send(6LL, v28, v29, v31);
        }

        sub_4601C(a1);
      }

      break;
    case 0:
      sub_40908(a1, 1u);
      *(_DWORD *)(a1 + 156) = 0;
      sub_40484(a1);
      uint32_t v7 = arc4random();
      *(_DWORD *)(a1 + 152) = v7 & 0xFFFFFF;
      sub_46BD8(*(void *)(a1 + 128), v7 & 0xFFFFFF, (uint64_t)sub_42B4C, a1, 5LL);
      uint64_t v8 = *(void *)(a1 + 144);
      uint32_t v9 = arc4random();
      timer_callout_set(v8, (uint64_t)sub_42B4C, a1, 2LL, 0LL, (double)v9 / 4294967300.0);
      break;
  }

void sub_4314C(void *a1)
{
  uint64_t v2 = (dispatch_source_s *)a1[4];
  if (v2) {
    dispatch_source_merge_data(v2, 1uLL);
  }
}

uint64_t sub_431A8(uint64_t a1, double a2, double a3)
{
  int v4 = *(_DWORD *)(a1 + 156);
  *(_DWORD *)(a1 + 156) = v4 + 1;
  if (v4)
  {
    double v6 = *(double *)(a1 + 168);
    uint64_t result = arc4random();
    double v8 = v6 * ((double)result / 4294967300.0 * 0.2 + -0.1) + v6 * 2.0;
    if (a3 != 0.0 && v8 > a3)
    {
      uint64_t result = arc4random();
      double v8 = a3 + ((double)result / 4294967300.0 * 0.2 + -0.1) * a3;
    }
  }

  else
  {
    uint64_t result = arc4random();
    double v8 = a2 + ((double)result / 4294967300.0 * 0.2 + -0.1) * a2;
  }

  *(double *)(a1 + 168) = v8;
  return result;
}

uint64_t sub_43284(uint64_t a1)
{
  uint64_t result = (uint64_t)sub_437D8(a1, 11, v17, (uint64_t)v16);
  if (result)
  {
    uint64_t v3 = (unsigned __int8 *)result;
    int v4 = *(uint64_t **)(a1 + 128);
    int v5 = sub_57760((uint64_t)v16);
    uint64_t result = sub_472A0(v4, v3, (v5 + 4));
    if (result > 0x32 || ((1LL << result) & 0x4000000000041LL) == 0)
    {
      int v7 = result;
      uint64_t v8 = sub_57538();
      uint64_t v9 = _SC_syslog_os_log_mapping(5LL);
      uint64_t result = __SC_log_enabled(5LL, v8, v9);
      if ((_DWORD)result)
      {
        uint64_t v10 = _os_log_pack_size(22LL);
        BOOL v11 = (char *)&v16[-1] - ((__chkstk_darwin(v10) + 15) & 0xFFFFFFFFFFFFFFF0LL);
        BOOL v12 = __error();
        uint64_t v13 = _os_log_pack_fill( v11,  v10,  *v12,  &dword_0,  "%s: SendInformRequest transmit failed, %s",  v15,  v16[0]);
        uint64_t v14 = strerror(v7);
        *(_DWORD *)uint64_t v13 = 136315394;
        *(void *)(v13 + 4) = a1;
        *(_WORD *)(v13 + 12) = 2080;
        *(void *)(v13 + 14) = v14;
        return __SC_log_send(5LL, v8, v9, v11);
      }
    }
  }

  return result;
}

unsigned __int16 *sub_43418(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (const __CFData *)sub_43BA0(a1);
  uint64_t result = sub_57BD4(a2, 1, (unsigned int *)&v8, 0LL);
  if (result)
  {
    int v5 = result;
    CFIndex Length = CFDataGetLength(v3);
    if (Length == (int)v8)
    {
      BytePtr = CFDataGetBytePtr(v3);
      return (unsigned __int16 *)(bcmp(v5, BytePtr, (int)v8) == 0);
    }

    else
    {
      return 0LL;
    }
  }

  return result;
}

unsigned __int16 *sub_4349C(uint64_t a1, uint64_t a2)
{
  CFAbsoluteTime current_time = timer_get_current_time();
  sub_40484(a1);
  int v5 = (const void *)sub_19BF0(*(void *)(a1 + 136));
  double v6 = v5;
  if (v5) {
    CFRetain(v5);
  }
  sub_4FA18((const void **)(a1 + 232));
  *(void *)(a1 + 232) = v6;
  int v7 = *(_DWORD *)(a2 + 8);
  *(_DWORD *)(a1 + 184) = v7;
  size_t v8 = malloc(v7);
  *(void *)(a1 + 176) = v8;
  memmove(v8, *(const void **)a2, v7);
  uint64_t v9 = sub_579D0((uint64_t)v8, v7, (char *)v32);
  *(void *)(a1 + 192) = v9;
  uint64_t result = sub_57BD4((uint64_t)v9, 2, (unsigned int *)&v31 + 1, 0LL);
  *(void *)(a1 + 264) = result;
  int v11 = *(_DWORD *)(a1 + 116);
  if (v11 == 2)
  {
    int v12 = 1;
  }

  else
  {
    if (v11 != 3)
    {
LABEL_40:
      *(_BYTE *)(a1 + 240) = 1;
      return result;
    }

    int v12 = 0;
  }

  uint64_t result = sub_43C00(a1, **(unsigned __int8 **)(a1 + 176), v12, *(void *)(a1 + 192), (const char *)(a1 + 280), 0LL);
  *(void *)(a1 + 272) = result;
  if (result)
  {
    uint64_t v13 = *(unsigned int **)(a1 + 280);
    int32x2_t v14 = (int32x2_t)vrev32_s8(*(int8x8_t *)(result + 2));
    if (v12)
    {
      unsigned int v15 = bswap32(v13[5]);
      v13 += 4;
    }

    else
    {
      unsigned int v15 = bswap32(v13[1]);
    }

    unsigned int v26 = *v13;
    unsigned int v27 = bswap32(v26);
    if (v26) {
      unsigned int v28 = v27;
    }
    else {
      unsigned int v28 = v15;
    }
    if (v14.i32[0]) {
      BOOL v29 = v14.i32[1] == 0;
    }
    else {
      BOOL v29 = 1;
    }
    if (v29)
    {
      if (v28 == -1) {
        int32x2_t v14 = 0LL;
      }
      else {
        int32x2_t v14 = vmovn_s64((int64x2_t)vcvtq_u64_f64(vmulq_n_f64((float64x2_t)xmmword_595B0, (double)v28)));
      }
    }

    else if (v14.i32[0] == -1 || v14.i32[1] == -1)
    {
      *(CFAbsoluteTime *)(a1 + 200) = current_time;
      int32x2_t v14 = 0LL;
      unsigned int v15 = -1;
      goto LABEL_38;
    }

    *(CFAbsoluteTime *)(a1 + 200) = current_time;
    if (v15 != -1)
    {
LABEL_39:
      *(int32x2_t *)(a1 + 208) = v14;
      *(_DWORD *)(a1 + 216) = v15;
      *(_DWORD *)(a1 + 220) = v28;
      goto LABEL_40;
    }

    int32x2_t v14 = 0LL;
LABEL_38:
    unsigned int v28 = -1;
    goto LABEL_39;
  }

  uint64_t v16 = sub_57538();
  uint64_t v17 = _SC_syslog_os_log_mapping(5LL);
  uint64_t result = (unsigned __int16 *)__SC_log_enabled(5LL, v16, v17);
  if ((_DWORD)result)
  {
    uint64_t v18 = _os_log_pack_size(42LL);
    uint64_t v19 = (char *)&v32[-1] - ((__chkstk_darwin(v18) + 15) & 0xFFFFFFFFFFFFFFF0LL);
    uint64_t v20 = __error();
    uint64_t v21 = _os_log_pack_fill( v19,  v18,  *v20,  &dword_0,  "%s: %s() failed to retrieve %s/%s",  v31,  v32[0],  v32[1],  v32[2]);
    if (v12) {
      int v22 = 3;
    }
    else {
      int v22 = 25;
    }
    if (v12) {
      int v23 = 5;
    }
    else {
      int v23 = 26;
    }
    int v24 = sub_575D0(v22);
    int v25 = sub_575D0(v23);
    *(_DWORD *)uint64_t v21 = 136315906;
    *(void *)(v21 + 4) = a1;
    *(_WORD *)(v21 + 12) = 2080;
    *(void *)(v21 + 14) = "DHCPv6ClientSavePacket";
    *(_WORD *)(v21 + 22) = 2080;
    *(void *)(v21 + 24) = v24;
    *(_WORD *)(v21 + 32) = 2080;
    *(void *)(v21 + 34) = v25;
    return (unsigned __int16 *)__SC_log_send(5LL, v16, v17, v19);
  }

  return result;
}

void sub_437A8(uint64_t a1)
{
}

_BYTE *sub_437D8(uint64_t a1, char a2, _BYTE *a3, uint64_t a4)
{
  int v5 = a3;
  DHCPv6PacketSetMessageType(a3, a2);
  DHCPv6PacketSetTransactionID(v5, *(_DWORD *)(a1 + 152));
  sub_57754(a4, (uint64_t)(v5 + 4), 1496);
  if (*(_DWORD *)(a1 + 116) != 3 && !sub_5782C(a4))
  {
    uint64_t v9 = sub_57538();
    uint64_t v10 = _SC_syslog_os_log_mapping(5LL);
    if (__SC_log_enabled(5LL, v9, v10))
    {
      uint64_t v11 = _os_log_pack_size(12LL);
      int v12 = &v18[-((__chkstk_darwin(v11) + 15) & 0xFFFFFFFFFFFFFFF0LL)];
      uint64_t v13 = *__error();
      uint64_t v14 = _os_log_pack_fill(v12, v11, v13, &dword_0, "DHCPv6Client: failed to add ORO, %s");
LABEL_14:
      *(_DWORD *)uint64_t v14 = 136315138;
      *(void *)(v14 + 4) = v20;
      __SC_log_send(5LL, v9, v10, v12);
    }

    return 0LL;
  }

  if (*(_DWORD *)(a1 + 156) == 1)
  {
    LOWORD(v7) = 0;
  }

  else
  {
    unsigned int v8 = ((timer_get_current_time() - *(double *)(a1 + 160)) * 100.0);
    if (HIWORD(v8)) {
      LOWORD(v7) = -1;
    }
    else {
      unsigned int v7 = bswap32(v8) >> 16;
    }
  }

  __int16 v19 = v7;
  if (!sub_57768(a4, 8u, 2uLL, &v19, v20))
  {
    uint64_t v9 = sub_57538();
    uint64_t v10 = _SC_syslog_os_log_mapping(5LL);
    if (__SC_log_enabled(5LL, v9, v10))
    {
      uint64_t v15 = _os_log_pack_size(12LL);
      int v12 = &v18[-((__chkstk_darwin(v15) + 15) & 0xFFFFFFFFFFFFFFF0LL)];
      uint64_t v16 = *__error();
      uint64_t v14 = _os_log_pack_fill(v12, v15, v16, &dword_0, "DHCPv6Client: failed to add ELAPSED_TIME, %s");
      goto LABEL_14;
    }

    return 0LL;
  }

  return v5;
}

CFDataRef sub_43A40(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (const __CFData *)sub_43BA0(a1);
  int v4 = v3;
  if (v3)
  {
    unsigned __int16 Length = CFDataGetLength(v3);
    BytePtr = (UInt8 *)CFDataGetBytePtr(v4);
    int v4 = (const __CFData *)(&dword_0 + 1);
    if (!sub_57768(a2, 1u, Length, BytePtr, v15))
    {
      uint64_t v7 = sub_57538();
      uint64_t v8 = _SC_syslog_os_log_mapping(5LL);
      if (__SC_log_enabled(5LL, v7, v8))
      {
        uint64_t v9 = _os_log_pack_size(12LL);
        uint64_t v10 = &v15[-((__chkstk_darwin(v9) + 15) & 0xFFFFFFFFFFFFFFF0LL) - 8];
        uint64_t v11 = __error();
        uint64_t v12 = _os_log_pack_fill(v10, v9, *v11, &dword_0, "DHCPv6Client: failed to add CLIENTID, %s", v14);
        *(_DWORD *)uint64_t v12 = 136315138;
        *(void *)(v12 + 4) = v15;
        __SC_log_send(5LL, v7, v8, v10);
      }

      return 0LL;
    }
  }

  return v4;
}

uint64_t sub_43BA0(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 241))
  {
    uint64_t result = *(void *)(a1 + 248);
    if (!result)
    {
      uint64_t v3 = sub_468A4(*(void *)(a1 + 128));
      uint64_t result = sub_4BF98(v3);
      *(void *)(a1 + 248) = result;
    }
  }

  else
  {
    uint64_t result = qword_6C280;
    if (!qword_6C280)
    {
      uint64_t result = sub_4B5F4((unsigned __int16)G_dhcp_duid_type);
      qword_6C280 = result;
    }
  }

  return result;
}

unsigned __int16 *sub_43C00(uint64_t a1, unsigned int a2, int a3, uint64_t a4, const char *a5, char *a6)
{
  uint64_t v7 = a5;
  unsigned __int16 v93 = 0;
  CFMutableDictionaryRef v92 = 0LL;
  *(void *)a5 = 0LL;
  if (a3) {
    int v11 = 3;
  }
  else {
    int v11 = 25;
  }
  uint64_t v12 = sub_57BD4(a4, v11, (unsigned int *)&v94, 0LL);
  uint64_t v13 = v12;
  if (!v12
    || (int v14 = v94, v94 < 13)
    || ((unsigned int v15 = *((_DWORD *)v12 + 2), v16 = bswap32(*((_DWORD *)v12 + 1)), v17 = bswap32(v15), v16)
      ? (BOOL v18 = v15 == 0)
      : (BOOL v18 = 1),
        !v18 ? (BOOL v19 = v16 > v17) : (BOOL v19 = 0),
        v19))
  {
LABEL_44:
    uint64_t v21 = 0LL;
    goto LABEL_45;
  }

  int v86 = v11;
  v94 -= 12;
  uint64_t v20 = sub_578CC(v12 + 6, v14 - 12, v97);
  CFMutableDictionaryRef v92 = v20;
  if (!v20)
  {
    uint64_t v60 = sub_57538();
    uint64_t v61 = _SC_syslog_os_log_mapping(6LL);
    if (__SC_log_enabled(6LL, v60, v61))
    {
      uint64_t v62 = _os_log_pack_size(32LL);
      uint64_t v90 = (const char **)&v82;
      uint64_t v63 = __chkstk_darwin(v62);
      uint64_t v88 = a1;
      unsigned int v64 = a2;
      uint64_t v65 = (char *)&v82 - ((v63 + 15) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v66 = __error();
      uint64_t v67 = _os_log_pack_fill( v65,  v62,  *v66,  &dword_0,  "%s: %s %s contains no options",  v82,  v83,  (const char *)v84);
      int v68 = sub_575D0(v86);
      CFStringRef v69 = DHCPv6MessageTypeName(v64);
      *(_DWORD *)uint64_t v67 = 136315650;
      *(void *)(v67 + 4) = v88;
      *(_WORD *)(v67 + 12) = 2080;
      *(void *)(v67 + 14) = v68;
      *(_WORD *)(v67 + 22) = 2080;
      *(void *)(v67 + 24) = v69;
      __SC_log_send(6LL, v60, v61, v65);
    }

    goto LABEL_44;
  }

  uint64_t v21 = (uint64_t)v20;
  if (sub_58408((uint64_t)v20, &v93, &v96, &v95))
  {
    unsigned int v87 = a2;
    uint64_t v88 = a1;
    CFStringRef v82 = a6;
    uint64_t v83 = (char *)v7;
    if (v93)
    {
      uint64_t v22 = sub_57538();
      uint64_t v23 = _SC_syslog_os_log_mapping(6LL);
      if (__SC_log_enabled(6LL, v22, v23))
      {
        uint64_t v24 = _os_log_pack_size(48LL);
        int v25 = (char *)&v82 - ((__chkstk_darwin(v24) + 15) & 0xFFFFFFFFFFFFFFF0LL);
        unsigned int v26 = __error();
        uint64_t v27 = _os_log_pack_fill( v25,  v24,  *v26,  &dword_0,  "%s: %s Status %s '%.*s'",  v82,  v83,  (const char *)v84,  SDWORD2(v84),  v85);
        unsigned int v28 = sub_575D0(v86);
        BOOL v29 = sub_583E0(v93);
        unsigned int v30 = v95;
        uint64_t v31 = v96;
        *(_DWORD *)uint64_t v27 = 136316162;
        *(void *)(v27 + 4) = v88;
        *(_WORD *)(v27 + 12) = 2080;
        *(void *)(v27 + 14) = v28;
        *(_WORD *)(v27 + 22) = 2080;
        *(void *)(v27 + 24) = v29;
        *(_WORD *)(v27 + 32) = 1040;
        *(_DWORD *)(v27 + 34) = v30;
        *(_WORD *)(v27 + 38) = 2080;
        *(void *)(v27 + 40) = v31;
        __SC_log_send(6LL, v22, v23, v25);
      }
    }

    if (a3) {
      int v32 = 5;
    }
    else {
      int v32 = 26;
    }
    int v91 = 0;
    uint64_t v33 = sub_57BD4(v21, v32, (unsigned int *)&v94, &v91);
    if (v33)
    {
      if (a3) {
        int v35 = 24;
      }
      else {
        int v35 = 25;
      }
      LODWORD(v89) = v35;
      *(void *)&__int128 v34 = 136315650LL;
      __int128 v84 = v34;
      while (v94 >= (int)v89)
      {
        if (a3)
        {
          unsigned int v36 = bswap32(*((_DWORD *)v33 + 5));
          uint64_t v37 = (unsigned int *)(v33 + 8);
        }

        else
        {
          unsigned int v36 = bswap32(*((_DWORD *)v33 + 1));
          uint64_t v37 = (unsigned int *)v33;
        }

        unsigned int v38 = *v37;
        if (v36) {
          BOOL v39 = v38 == 0;
        }
        else {
          BOOL v39 = 1;
        }
        if (!v39)
        {
          unsigned int v72 = bswap32(v38);
          if (v72 <= v36)
          {
            *(void *)uint64_t v83 = v33;
            goto LABEL_41;
          }

          uint64_t v73 = sub_57538();
          uint64_t v74 = _SC_syslog_os_log_mapping(6LL);
          uint64_t v75 = _os_log_pack_size(44LL);
          uint64_t v89 = v73;
          uint64_t v76 = v75;
          uint64_t v90 = (const char **)&v82;
          uint64_t v77 = (char *)&v82 - ((__chkstk_darwin(v75) + 15) & 0xFFFFFFFFFFFFFFF0LL);
          int v78 = __error();
          uint64_t v79 = _os_log_pack_fill( v77,  v76,  *v78,  &dword_0,  "%s: %s %s preferred %d > valid lifetime %d",  v82,  v83,  (const char *)v84,  DWORD2(v84),  (_DWORD)v85);
          uint64_t v80 = DHCPv6MessageTypeName(v87);
          uint64_t v81 = sub_575D0(v32);
          *(_DWORD *)uint64_t v79 = 136316162;
          uint64_t v57 = v89;
          *(void *)(v79 + 4) = v88;
          *(_WORD *)(v79 + 12) = 2080;
          *(void *)(v79 + 14) = v80;
          *(_WORD *)(v79 + 22) = 2080;
          *(void *)(v79 + 24) = v81;
          *(_WORD *)(v79 + 32) = 1024;
          *(_DWORD *)(v79 + 34) = v72;
          *(_WORD *)(v79 + 38) = 1024;
          *(_DWORD *)(v79 + 40) = v36;
          uint64_t v58 = v74;
          uint64_t v59 = v77;
          goto LABEL_40;
        }

        uint64_t v40 = sub_57538();
        uint64_t v41 = _SC_syslog_os_log_mapping(6LL);
        if (__SC_log_enabled(6LL, v40, v41))
        {
          uint64_t v42 = _os_log_pack_size(32LL);
          uint64_t v90 = (const char **)&v82;
          __n128 v43 = (char *)&v82 - ((__chkstk_darwin(v42) + 15) & 0xFFFFFFFFFFFFFFF0LL);
          uint64_t v44 = __error();
          uint64_t v45 = _os_log_pack_fill( v43,  v42,  *v44,  &dword_0,  "%s: %s %s has valid/preferred lifetime 0, skipping",  v82,  v83,  (const char *)v84);
          uint64_t v46 = DHCPv6MessageTypeName(v87);
          uint64_t v47 = sub_575D0(v32);
          *(_DWORD *)uint64_t v45 = v84;
          *(void *)(v45 + 4) = v88;
          *(_WORD *)(v45 + 12) = 2080;
          *(void *)(v45 + 14) = v46;
          *(_WORD *)(v45 + 22) = 2080;
          *(void *)(v45 + 24) = v47;
          __SC_log_send(6LL, v40, v41, v43);
        }

        ++v91;
        uint64_t v33 = sub_57BD4(v21, v32, (unsigned int *)&v94, &v91);
        if (!v33) {
          break;
        }
      }
    }

    uint64_t v48 = sub_57538();
    uint64_t v49 = _SC_syslog_os_log_mapping(6LL);
    if (__SC_log_enabled(6LL, v48, v49))
    {
      uint64_t v50 = _os_log_pack_size(42LL);
      uint64_t v90 = (const char **)&v82;
      uint64_t v51 = (char *)&v82 - ((__chkstk_darwin(v50) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v52 = __error();
      uint64_t v53 = _os_log_pack_fill( v51,  v50,  *v52,  &dword_0,  "%s: %s %s contains no valid %s option",  v82,  v83,  (const char *)v84,  *((const char **)&v84 + 1));
      double v54 = DHCPv6MessageTypeName(v87);
      uint64_t v55 = sub_575D0(v86);
      uint64_t v56 = sub_575D0(v32);
      *(_DWORD *)uint64_t v53 = 136315906;
      *(void *)(v53 + 4) = v88;
      *(_WORD *)(v53 + 12) = 2080;
      *(void *)(v53 + 14) = v54;
      *(_WORD *)(v53 + 22) = 2080;
      *(void *)(v53 + 24) = v55;
      *(_WORD *)(v53 + 32) = 2080;
      *(void *)(v53 + 34) = v56;
      uint64_t v57 = v48;
      uint64_t v58 = v49;
      uint64_t v59 = v51;
LABEL_40:
      __SC_log_send(6LL, v57, v58, v59);
    }

LABEL_41:
    a6 = v82;
    uint64_t v7 = v83;
  }

  sub_4FA18(&v44);
}

void sub_442BC(uint64_t a1)
{
  double current_time = timer_get_current_time();
  sub_40908(a1, 3u);
  *(_BYTE *)(a1 + 224) = 1;
  *(_BYTE *)(a1 + 240) = 1;
  sub_46FA0(*(void *)(a1 + 128));
  timer_cancel(*(void *)(a1 + 144));
  unsigned int v4 = *(_DWORD *)(a1 + 216);
  unsigned int v3 = *(_DWORD *)(a1 + 220);
  if (v4 == -1)
  {
    unsigned int v6 = 0;
    int v7 = -1;
  }

  else
  {
    double v5 = *(double *)(a1 + 200);
    if (current_time < v5 || (unsigned int v6 = (current_time - v5), v7 = v4 - v6, v4 <= v6))
    {
      sub_44A38((void *)a1);
      return;
    }

    if (v3 >= v6) {
      v3 -= v6;
    }
    else {
      unsigned int v3 = 0;
    }
  }

  if (*(_DWORD *)(a1 + 116) == 2)
  {
    BOOL v8 = sub_44CC8(a1, v7, v3);
    if (v7 == -1 || !v8) {
      return;
    }
  }

  else
  {
    sub_4530C(a1, v7, v3);
    if (v7 == -1) {
      return;
    }
  }

  unsigned int v9 = *(_DWORD *)(a1 + 208);
  BOOL v10 = v9 >= v6;
  unsigned int v11 = v9 - v6;
  double v12 = (double)v11;
  if (v11 == 0 || !v10) {
    double v12 = 10.0;
  }
  *(double *)(a1 + 256) = current_time + v12;
  timer_callout_set(*(void *)(a1 + 144), (uint64_t)sub_45500, a1, 0LL, 0LL, v12);
}

uint64_t sub_443E4(uint64_t a1)
{
  if (!*(void *)(a1 + 264))
  {
    uint64_t v3 = sub_57538();
    uint64_t v4 = _SC_syslog_os_log_mapping(5LL);
    uint64_t result = __SC_log_enabled(5LL, v3, v4);
    if (!(_DWORD)result) {
      return result;
    }
    uint64_t v6 = _os_log_pack_size(22LL);
    int v7 = (char *)&v45[-1] - ((__chkstk_darwin(v6) + 15) & 0xFFFFFFFFFFFFFFF0LL);
    uint64_t v8 = *__error();
    uint64_t v9 = _os_log_pack_fill(v7, v6, v8, &dword_0, "%s: %s() NULL server_id");
LABEL_9:
    *(_DWORD *)uint64_t v9 = 136315394;
    *(void *)(v9 + 4) = a1;
    *(_WORD *)(v9 + 12) = 2080;
    *(void *)(v9 + 14) = "DHCPv6ClientSendPacket";
    uint64_t v12 = v3;
    uint64_t v13 = v4;
    int v14 = v7;
    return __SC_log_send(5LL, v12, v13, v14);
  }

  if (!*(void *)(a1 + 272))
  {
    uint64_t v3 = sub_57538();
    uint64_t v4 = _SC_syslog_os_log_mapping(5LL);
    uint64_t result = __SC_log_enabled(5LL, v3, v4);
    if (!(_DWORD)result) {
      return result;
    }
    uint64_t v10 = _os_log_pack_size(22LL);
    int v7 = (char *)&v45[-1] - ((__chkstk_darwin(v10) + 15) & 0xFFFFFFFFFFFFFFF0LL);
    uint64_t v11 = *__error();
    uint64_t v9 = _os_log_pack_fill(v7, v10, v11, &dword_0, "%s: %s() NULL IA_NA/IA_PD");
    goto LABEL_9;
  }

  int v2 = 3;
  switch(*(_DWORD *)(a1 + 120))
  {
    case 2:
      goto LABEL_19;
    case 4:
      int v2 = 5;
      goto LABEL_19;
    case 5:
      int v2 = 6;
      goto LABEL_19;
    case 6:
      if (*(_DWORD *)(a1 + 116) == 3) {
        int v2 = 6;
      }
      else {
        int v2 = 4;
      }
      goto LABEL_19;
    case 7:
      int v2 = 8;
      goto LABEL_19;
    case 9:
      int v2 = 9;
LABEL_19:
      uint64_t result = (uint64_t)sub_437D8(a1, v2, v47, (uint64_t)v45);
      if (!result) {
        return result;
      }
      uint64_t v23 = (unsigned __int8 *)result;
      if ((v2 | 2) != 6
        && !sub_57768( (uint64_t)v45,  2u,  bswap32(*(unsigned __int16 *)(*(void *)(a1 + 264) - 2LL)) >> 16,  *(void **)(a1 + 264),  v46))
      {
        uint64_t v15 = sub_57538();
        uint64_t v16 = _SC_syslog_os_log_mapping(5LL);
        uint64_t result = __SC_log_enabled(5LL, v15, v16);
        if (!(_DWORD)result) {
          return result;
        }
        uint64_t v36 = _os_log_pack_size(32LL);
        BOOL v18 = (char *)&v45[-1] - ((__chkstk_darwin(v36) + 15) & 0xFFFFFFFFFFFFFFF0LL);
        uint64_t v37 = __error();
        uint64_t v38 = _os_log_pack_fill( v18,  v36,  *v37,  &dword_0,  "%s: %s failed to add SERVERID, %s",  v44,  v45[0],  v45[1]);
        uint64_t v39 = *(unsigned int *)(a1 + 120);
        else {
          uint64_t v40 = off_64F98[v39];
        }
        *(_DWORD *)uint64_t v38 = 136315650;
        *(void *)(v38 + 4) = a1;
        *(_WORD *)(v38 + 12) = 2080;
        *(void *)(v38 + 14) = v40;
        *(_WORD *)(v38 + 22) = 2080;
        *(void *)(v38 + 24) = v46;
LABEL_40:
        uint64_t v12 = v15;
        uint64_t v13 = v16;
        goto LABEL_41;
      }

      if (*(_DWORD *)(a1 + 116) == 2)
      {
        if (!sub_459B8(a1, 0, (uint64_t)v45, v46))
        {
          uint64_t v24 = sub_57538();
          uint64_t v25 = _SC_syslog_os_log_mapping(5LL);
          uint64_t result = __SC_log_enabled(5LL, v24, v25);
          if (!(_DWORD)result) {
            return result;
          }
LABEL_35:
          uint64_t v41 = _os_log_pack_size(12LL);
          BOOL v18 = (char *)&v45[-1] - ((__chkstk_darwin(v41) + 15) & 0xFFFFFFFFFFFFFFF0LL);
          uint64_t v42 = *__error();
          uint64_t v43 = _os_log_pack_fill(v18, v41, v42, &dword_0, "DHCPv6Client: failed to add IA_NA, %s");
          *(_DWORD *)uint64_t v43 = 136315138;
          *(void *)(v43 + 4) = v46;
          uint64_t v12 = v24;
          uint64_t v13 = v25;
LABEL_41:
          int v14 = v18;
          return __SC_log_send(5LL, v12, v13, v14);
        }
      }

      else if (!sub_45A6C(a1, 0, (uint64_t)v45, v46))
      {
        uint64_t v24 = sub_57538();
        uint64_t v25 = _SC_syslog_os_log_mapping(5LL);
        uint64_t result = __SC_log_enabled(5LL, v24, v25);
        if (!(_DWORD)result) {
          return result;
        }
        goto LABEL_35;
      }

      unsigned int v26 = *(uint64_t **)(a1 + 128);
      int v27 = sub_57760((uint64_t)v45);
      uint64_t result = sub_472A0(v26, v23, (v27 + 4));
      int v28 = result;
      if (result > 0x32 || ((1LL << result) & 0x4000000000041LL) == 0)
      {
        uint64_t v29 = sub_57538();
        uint64_t v30 = _SC_syslog_os_log_mapping(5LL);
        uint64_t result = __SC_log_enabled(5LL, v29, v30);
        if ((_DWORD)result)
        {
          uint64_t v31 = _os_log_pack_size(22LL);
          int v32 = (char *)&v45[-1] - ((__chkstk_darwin(v31) + 15) & 0xFFFFFFFFFFFFFFF0LL);
          uint64_t v33 = __error();
          uint64_t v34 = _os_log_pack_fill( v32,  v31,  *v33,  &dword_0,  "%s: SendPacket transmit failed, %s",  v44,  v45[0]);
          int v35 = strerror(v28);
          *(_DWORD *)uint64_t v34 = 136315394;
          *(void *)(v34 + 4) = a1;
          *(_WORD *)(v34 + 12) = 2080;
          *(void *)(v34 + 14) = v35;
          uint64_t v12 = v29;
          uint64_t v13 = v30;
          int v14 = v32;
          return __SC_log_send(5LL, v12, v13, v14);
        }
      }

      break;
    default:
      uint64_t v15 = sub_57538();
      uint64_t v16 = _SC_syslog_os_log_mapping(5LL);
      uint64_t result = __SC_log_enabled(5LL, v15, v16);
      if (!(_DWORD)result) {
        return result;
      }
      uint64_t v17 = _os_log_pack_size(22LL);
      BOOL v18 = (char *)&v45[-1] - ((__chkstk_darwin(v17) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      BOOL v19 = __error();
      uint64_t v20 = _os_log_pack_fill(v18, v17, *v19, &dword_0, "%s: SendPacket doesn't know %s", v44, v45[0]);
      uint64_t v21 = *(unsigned int *)(a1 + 120);
      else {
        uint64_t v22 = off_64F98[v21];
      }
      *(_DWORD *)uint64_t v20 = 136315394;
      *(void *)(v20 + 4) = a1;
      *(_WORD *)(v20 + 12) = 2080;
      *(void *)(v20 + 14) = v22;
      goto LABEL_40;
  }

  return result;
}

uint64_t sub_44A38(void *a1)
{
  int v2 = (dispatch_source_s *)a1[4];
  if (v2) {
    dispatch_source_merge_data(v2, 1uLL);
  }
  return sub_42B4C(a1, 0LL, 0LL);
}

uint64_t sub_44AA0(uint64_t a1, unsigned int a2, int a3, int8x8_t **a4, __n128 a5)
{
  int v7 = *a4;
  if (a3)
  {
    a5.n128_u64[0] = (unint64_t)vrev32_s8(v7[2]);
    __n128 v26 = a5;
    BYTE2(v27) = 0;
    int v8 = 5;
  }

  else
  {
    int v9 = v7[1].u8[0];
    a5.n128_u64[0] = (unint64_t)vrev32_s8(*v7);
    __n128 v26 = a5;
    snprintf((char *)&v27 + 2, 8uLL, "/%d", v9);
    int v8 = 26;
    int v7 = (int8x8_t *)((char *)v7 + 9);
  }

  uint64_t v10 = sub_57538();
  uint64_t v11 = _SC_syslog_os_log_mapping(6LL);
  uint64_t result = __SC_log_enabled(6LL, v10, v11);
  if ((_DWORD)result)
  {
    uint64_t v13 = _os_log_pack_size(80LL);
    uint64_t v25 = &v24;
    int v14 = (char *)&v24 - ((__chkstk_darwin(v13) + 15) & 0xFFFFFFFFFFFFFFF0LL);
    uint64_t v15 = __error();
    uint64_t v16 = _os_log_pack_fill( v14,  v13,  *v15,  &dword_0,  "%s: %s Received %s (try=%d) %s %s%s Preferred %d Valid=%d",  v24,  (const char *)v25,  (const char *)v26.n128_u64[0],  v26.n128_u32[2],  v27,  v28[0],  v28[1],  v29,  v30);
    uint64_t v17 = *(unsigned int *)(a1 + 120);
    else {
      BOOL v18 = off_64F98[v17];
    }
    BOOL v19 = DHCPv6MessageTypeName(a2);
    int v20 = *(_DWORD *)(a1 + 156);
    uint64_t v21 = sub_575D0(v8);
    uint64_t v22 = inet_ntop(30, v7, (char *)v28 + 2, 0x2Eu);
    *(_DWORD *)uint64_t v16 = 136317186;
    *(void *)(v16 + 4) = a1;
    *(_WORD *)(v16 + 12) = 2080;
    *(void *)(v16 + 14) = v18;
    *(_WORD *)(v16 + 22) = 2080;
    *(void *)(v16 + 24) = v19;
    *(_WORD *)(v16 + 32) = 1024;
    *(_DWORD *)(v16 + 34) = v20;
    *(_WORD *)(v16 + 38) = 2080;
    *(void *)(v16 + 40) = v21;
    *(_WORD *)(v16 + 48) = 2080;
    *(void *)(v16 + 50) = v22;
    *(_WORD *)(v16 + 58) = 2080;
    *(void *)(v16 + 60) = (char *)&v27 + 2;
    *(_WORD *)(v16 + 68) = 1024;
    unsigned __int32 v23 = v26.n128_u32[1];
    *(_DWORD *)(v16 + 70) = v26.n128_u32[0];
    *(_WORD *)(v16 + 74) = 1024;
    *(_DWORD *)(v16 + 76) = v23;
    return __SC_log_send(6LL, v10, v11, v14);
  }

  return result;
}

BOOL sub_44CC8(uint64_t a1, int a2, int a3)
{
  uint64_t v6 = sub_468A4(*(void *)(a1 + 128));
  int8x16_t v64 = *(int8x16_t *)*(void *)(a1 + 280);
  int v7 = sub_32804();
  if ((v7 & 0x80000000) == 0)
  {
    int v8 = (int8x16_t *)(a1 + 56);
    if ((*(_DWORD *)(a1 + 56) || *(_DWORD *)(a1 + 60) || *(_DWORD *)(a1 + 64) || *(_DWORD *)(a1 + 68))
      && (v8->i64[0] != v64.i64[0] || *(void *)(a1 + 64) != v64.i64[1]))
    {
      inet_ntop(30, (const void *)(a1 + 56), v66, 0x2Eu);
      uint64_t v10 = (const char *)nullsub_1(v6);
      int v11 = sub_347B8(v7, v10, (_OWORD *)(a1 + 56));
      uint64_t v12 = sub_57538();
      uint64_t v13 = _SC_syslog_os_log_mapping(5LL);
      int v14 = __SC_log_enabled(5LL, v12, v13);
      if (v11 < 0)
      {
        if (!v14) {
          goto LABEL_18;
        }
        HIDWORD(v63) = a3;
        uint64_t v30 = _os_log_pack_size(48LL);
        uint64_t v62 = (const char *)&v60;
        uint64_t v16 = (char *)&v60 - ((__chkstk_darwin(v30) + 15) & 0xFFFFFFFFFFFFFFF0LL);
        uint64_t v31 = __error();
        uint64_t v32 = _os_log_pack_fill( v16,  v30,  *v31,  &dword_0,  "%s(%s): remove %s failed, %s (%d)",  v60,  v61,  v62,  v63,  v64.i32[0]);
        uint64_t v61 = (const char *)nullsub_1(v6);
        uint64_t v33 = __error();
        uint64_t v60 = strerror(*v33);
        int v34 = *__error();
        *(_DWORD *)uint64_t v32 = 136316162;
        *(void *)(v32 + 4) = "DHCPv6ClientBoundAddress";
        *(_WORD *)(v32 + 12) = 2080;
        *(void *)(v32 + 14) = v61;
        *(_WORD *)(v32 + 22) = 2080;
        *(void *)(v32 + 24) = v66;
        *(_WORD *)(v32 + 32) = 2080;
        *(void *)(v32 + 34) = v60;
        *(_WORD *)(v32 + 42) = 1024;
        *(_DWORD *)(v32 + 44) = v34;
      }

      else
      {
        if (!v14) {
          goto LABEL_18;
        }
        HIDWORD(v63) = a3;
        uint64_t v15 = _os_log_pack_size(32LL);
        uint64_t v62 = (const char *)&v60;
        uint64_t v16 = (char *)&v60 - ((__chkstk_darwin(v15) + 15) & 0xFFFFFFFFFFFFFFF0LL);
        uint64_t v17 = __error();
        uint64_t v18 = _os_log_pack_fill(v16, v15, *v17, &dword_0, "%s(%s): removed %s", v60, v61, v62);
        uint64_t v19 = nullsub_1(v6);
        *(_DWORD *)uint64_t v18 = 136315650;
        *(void *)(v18 + 4) = "DHCPv6ClientBoundAddress";
        *(_WORD *)(v18 + 12) = 2080;
        *(void *)(v18 + 14) = v19;
        *(_WORD *)(v18 + 22) = 2080;
        *(void *)(v18 + 24) = v66;
      }

      __SC_log_send(5LL, v12, v13, v16);
      a3 = HIDWORD(v63);
    }

void sub_4530C(uint64_t a1, int a2, int a3)
{
  uint64_t v6 = (_OWORD *)(a1 + 76);
  int v7 = *(_DWORD *)(a1 + 76);
  uint64_t v8 = *(void *)(a1 + 280);
  int v9 = (_OWORD *)(v8 + 9);
  __int128 v20 = *(_OWORD *)(v8 + 9);
  char v10 = *(_BYTE *)(v8 + 8);
  if (v7 || *(_DWORD *)(a1 + 80) || *(_DWORD *)(a1 + 84) || *(_DWORD *)(a1 + 88))
  {
    if (*(_OWORD *)(a1 + 76) == v20) {
      int v11 = "Maintained";
    }
    else {
      int v11 = "Changed";
    }
  }

  else
  {
    int v11 = "New";
  }

  *uint64_t v6 = *v9;
  *(_BYTE *)(a1 + 92) = v10;
  inet_ntop(30, v6, (char *)v22 + 2, 0x2Eu);
  uint64_t v12 = sub_57538();
  uint64_t v13 = _SC_syslog_os_log_mapping(5LL);
  if (__SC_log_enabled(5LL, v12, v13))
  {
    uint64_t v14 = _os_log_pack_size(50LL);
    uint64_t v15 = (char *)&v20 - ((__chkstk_darwin(v14) + 15) & 0xFFFFFFFFFFFFFFF0LL);
    uint64_t v16 = __error();
    uint64_t v17 = _os_log_pack_fill( v15,  v14,  *v16,  &dword_0,  "%s: %s prefix %s/%d valid %d preferred %d",  (const char *)v20,  *((const char **)&v20 + 1),  v21,  v22[0],  v22[2],  v22[4]);
    int v18 = *(unsigned __int8 *)(a1 + 92);
    *(_DWORD *)uint64_t v17 = 136316418;
    *(void *)(v17 + 4) = a1;
    *(_WORD *)(v17 + 12) = 2080;
    *(void *)(v17 + 14) = v11;
    *(_WORD *)(v17 + 22) = 2080;
    *(void *)(v17 + 24) = (char *)v22 + 2;
    *(_WORD *)(v17 + 32) = 1024;
    *(_DWORD *)(v17 + 34) = v18;
    *(_WORD *)(v17 + 38) = 1024;
    *(_DWORD *)(v17 + 40) = a2;
    *(_WORD *)(v17 + 44) = 1024;
    *(_DWORD *)(v17 + 46) = a3;
    __SC_log_send(5LL, v12, v13, v15);
  }

  uint64_t v19 = *(dispatch_source_s **)(a1 + 32);
  if (v19) {
    dispatch_source_merge_data(v19, 1uLL);
  }
}

void sub_45500(uint64_t a1, int a2, unsigned __int8 **a3)
{
  double current_time = timer_get_current_time();
  if (a2 == 5)
  {
    if (**a3 == 7)
    {
      if (sub_43418(a1, (uint64_t)a3[2]))
      {
        uint64_t v12 = sub_57BD4((uint64_t)a3[2], 2, (unsigned int *)&v38, 0LL);
        if (v12)
        {
          if (sub_56AA8(v12, (int)v38)
            && sub_58408( (uint64_t)a3[2],  (_WORD *)&v40 + 3,  (unsigned __int16 **)&v39,  (unsigned int *)&v38 + 1))
          {
            if (HIWORD(v40))
            {
              uint64_t v13 = sub_57538();
              uint64_t v14 = _SC_syslog_os_log_mapping(5LL);
              if (__SC_log_enabled(5LL, v13, v14))
              {
                uint64_t v15 = _os_log_pack_size(48LL);
                uint64_t v16 = (char *)&v37 - ((__chkstk_darwin(v15) + 15) & 0xFFFFFFFFFFFFFFF0LL);
                uint64_t v17 = __error();
                uint64_t v18 = _os_log_pack_fill( v16,  v15,  *v17,  &dword_0,  "%s: %s %s %.*s",  v37,  v38,  v39,  v40,  (const char *)v41);
                uint64_t v19 = DHCPv6MessageTypeName(**a3);
                __int128 v20 = sub_583E0(HIWORD(v40));
                int v21 = HIDWORD(v38);
                uint64_t v22 = v39;
                *(_DWORD *)uint64_t v18 = 136316162;
                *(void *)(v18 + 4) = a1;
                *(_WORD *)(v18 + 12) = 2080;
                *(void *)(v18 + 14) = v19;
                *(_WORD *)(v18 + 22) = 2080;
                *(void *)(v18 + 24) = v20;
                *(_WORD *)(v18 + 32) = 1040;
                *(_DWORD *)(v18 + 34) = v21;
                *(_WORD *)(v18 + 38) = 2080;
                *(void *)(v18 + 40) = v22;
                __SC_log_send(5LL, v13, v14, v16);
              }
            }

            else
            {
              int v35 = *(_DWORD *)(a1 + 116);
              if (sub_43C00(a1, **a3, v35 == 2, (uint64_t)a3[2], (const char *)&v41, 0LL))
              {
                sub_44AA0(a1, **a3, v35 == 2, &v41, v36);
                sub_4349C(a1, (uint64_t)a3);
                sub_442BC(a1);
                return;
              }
            }

            sub_44A38((void *)a1);
          }
        }
      }
    }
  }

  else
  {
    double v7 = current_time;
    if (a2 != 2)
    {
      if (a2) {
        return;
      }
      sub_40908(a1, 4u);
      sub_46FA0(*(void *)(a1 + 128));
      timer_cancel(*(void *)(a1 + 144));
      *(_DWORD *)(a1 + 156) = 0;
      *(double *)(a1 + 160) = v7;
      uint32_t v8 = arc4random();
      *(_DWORD *)(a1 + 152) = v8 & 0xFFFFFF;
      sub_46BD8(*(void *)(a1 + 128), v8 & 0xFFFFFF, (uint64_t)sub_45500, a1, 5LL);
    }

    if ((sub_40AD8(a1, v7) & 1) != 0)
    {
      unsigned int v9 = (v7 - *(double *)(a1 + 200));
      if (*(_DWORD *)(a1 + 212) <= v9)
      {
        if (*(_DWORD *)(a1 + 120) != 5)
        {
          uint32_t v23 = arc4random();
          *(_DWORD *)(a1 + 152) = v23 & 0xFFFFFF;
          sub_46BD8(*(void *)(a1 + 128), v23 & 0xFFFFFF, (uint64_t)sub_45500, a1, 5LL);
          *(double *)(a1 + 160) = v7;
          sub_40908(a1, 5u);
          *(_DWORD *)(a1 + 156) = 0;
        }

        sub_431A8(a1, 10.0, 600.0);
        int v11 = *(_DWORD *)(a1 + 216);
      }

      else
      {
        sub_431A8(a1, 10.0, 600.0);
        int v11 = *(_DWORD *)(a1 + 212);
      }

      unsigned int v24 = v11 - v9;
      else {
        double v25 = (double)v24;
      }
      *(double *)(a1 + 256) = v7 + v25;
      timer_callout_set(*(void *)(a1 + 144), (uint64_t)sub_45500, a1, 2LL, 0LL, v25);
      uint64_t v26 = sub_57538();
      uint64_t v27 = _SC_syslog_os_log_mapping(6LL);
      if (__SC_log_enabled(6LL, v26, v27))
      {
        uint64_t v28 = _os_log_pack_size(38LL);
        int v29 = (char *)&v37 - ((__chkstk_darwin(v28) + 15) & 0xFFFFFFFFFFFFFFF0LL);
        uint64_t v30 = __error();
        uint64_t v31 = _os_log_pack_fill( v29,  v28,  *v30,  &dword_0,  "%s: %s Transmit (try=%d) (wait_time=%lu)",  v37,  v38,  (_DWORD)v39,  v40);
        uint64_t v32 = *(unsigned int *)(a1 + 120);
        else {
          uint64_t v33 = off_64F98[v32];
        }
        int v34 = *(_DWORD *)(a1 + 156);
        *(_DWORD *)uint64_t v31 = 136315906;
        *(void *)(v31 + 4) = a1;
        *(_WORD *)(v31 + 12) = 2080;
        *(void *)(v31 + 14) = v33;
        *(_WORD *)(v31 + 22) = 1024;
        *(_DWORD *)(v31 + 24) = v34;
        *(_WORD *)(v31 + 28) = 2048;
        *(void *)(v31 + 30) = (unint64_t)v25;
        __SC_log_send(6LL, v26, v27, v29);
      }

      sub_443E4(a1);
    }

    else
    {
      sub_44A38((void *)a1);
    }
  }

BOOL sub_459B8(uint64_t a1, char a2, uint64_t a3, char *a4)
{
  v10[1] = 0;
  v10[2] = 0;
  v10[0] = bswap32(sub_45B50(a1));
  if ((a2 & 1) != 0)
  {
    size_t v8 = 12LL;
  }

  else
  {
    v10[3] = 402654464;
    __int128 v11 = *(_OWORD *)*(void *)(a1 + 280);
    uint64_t v12 = 0LL;
    size_t v8 = 40LL;
  }

  return sub_57768(a3, 3u, v8, v10, a4);
}

BOOL sub_45A6C(uint64_t a1, int a2, uint64_t a3, char *a4)
{
  uint64_t v15 = 0LL;
  unsigned int __src = bswap32(sub_45B50(a1));
  if (a2)
  {
    size_t v8 = (char *)(a1 + 112);
    if (!*(_BYTE *)(a1 + 112))
    {
      size_t v12 = 12LL;
      return sub_57768(a3, 0x19u, v12, &__src, a4);
    }

    int v16 = 419437056;
    unsigned int v9 = (__int128 *)(a1 + 96);
  }

  else
  {
    int v16 = 419437056;
    uint64_t v10 = *(void *)(a1 + 280);
    unsigned int v9 = (__int128 *)(v10 + 9);
    size_t v8 = (char *)(v10 + 8);
  }

  char v11 = *v8;
  __int128 v19 = *v9;
  char v18 = v11;
  uint64_t v17 = 0LL;
  size_t v12 = 41LL;
  return sub_57768(a3, 0x19u, v12, &__src, a4);
}

CFIndex sub_45B50(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 241)) {
    return 0LL;
  }
  uint64_t v2 = sub_468A4(*(void *)(a1 + 128));
  uint64_t v3 = (char *)nullsub_1(v2);
  return sub_4BFE8(v3);
}

void sub_45B80(uint64_t a1, int a2, unsigned __int8 **a3)
{
  if (a2 == 5)
  {
    if (**a3 == 7)
    {
      if (sub_43418(a1, (uint64_t)a3[2]))
      {
        double v5 = sub_57BD4((uint64_t)a3[2], 2, &v37, 0LL);
        if (v5)
        {
          if (sub_56AA8(v5, v37)
            && sub_58408((uint64_t)a3[2], &v38, (unsigned __int16 **)&v36, (unsigned int *)&v35 + 1))
          {
            if (v38)
            {
              uint64_t v6 = sub_57538();
              uint64_t v7 = _SC_syslog_os_log_mapping(5LL);
              if (__SC_log_enabled(5LL, v6, v7))
              {
                uint64_t v8 = _os_log_pack_size(48LL);
                unsigned int v9 = (char *)&v34 - ((__chkstk_darwin(v8) + 15) & 0xFFFFFFFFFFFFFFF0LL);
                uint64_t v10 = __error();
                uint64_t v11 = _os_log_pack_fill( v9,  v8,  *v10,  &dword_0,  "%s: %s %s '%.*s'",  v34,  v35,  v36,  v37,  (const char *)v39);
                size_t v12 = DHCPv6MessageTypeName(**a3);
                uint64_t v13 = sub_583E0(v38);
                int v14 = HIDWORD(v35);
                uint64_t v15 = v36;
                *(_DWORD *)uint64_t v11 = 136316162;
                *(void *)(v11 + 4) = a1;
                *(_WORD *)(v11 + 12) = 2080;
                *(void *)(v11 + 14) = v12;
                *(_WORD *)(v11 + 22) = 2080;
                *(void *)(v11 + 24) = v13;
                *(_WORD *)(v11 + 32) = 1040;
                *(_DWORD *)(v11 + 34) = v14;
                *(_WORD *)(v11 + 38) = 2080;
                *(void *)(v11 + 40) = v15;
                __SC_log_send(5LL, v6, v7, v9);
              }
            }

            if ((v38 & 0xFFFB) != 2)
            {
              int v16 = *(_DWORD *)(a1 + 116);
              uint64_t v17 = sub_43C00(a1, **a3, v16 == 2, (uint64_t)a3[2], (const char *)&v39, (char *)&v38);
              if (v38 == 4)
              {
                uint64_t v19 = sub_57538();
                uint64_t v20 = _SC_syslog_os_log_mapping(5LL);
                if (__SC_log_enabled(5LL, v19, v20))
                {
                  uint64_t v21 = _os_log_pack_size(12LL);
                  uint64_t v22 = (char *)&v34 - ((__chkstk_darwin(v21) + 15) & 0xFFFFFFFFFFFFFFF0LL);
                  uint32_t v23 = __error();
                  uint64_t v24 = _os_log_pack_fill(v22, v21, *v23, &dword_0, "%s: NotOnLink", v34);
                  *(_DWORD *)uint64_t v24 = 136315138;
                  *(void *)(v24 + 4) = a1;
                  __SC_log_send(5LL, v19, v20, v22);
                }

                sub_4055C(a1, (uint64_t)"Request");
                sub_42B4C(a1, 0LL, 0LL);
              }

              else if (v17)
              {
                sub_44AA0(a1, **a3, v16 == 2, &v39, v18);
                sub_4349C(a1, (uint64_t)a3);
                sub_442BC(a1);
              }
            }
          }
        }
      }
    }
  }

  else
  {
    if (a2 != 2)
    {
      if (a2) {
        return;
      }
      sub_40908(a1, 2u);
      *(_DWORD *)(a1 + 156) = 0;
      *(_DWORD *)(a1 + 152) = arc4random() & 0xFFFFFF;
      *(CFAbsoluteTime *)(a1 + 160) = timer_get_current_time();
      sub_46BD8(*(void *)(a1 + 128), *(_DWORD *)(a1 + 152), (uint64_t)sub_45B80, a1, 5LL);
    }

    if (*(int *)(a1 + 156) < 10)
    {
      uint64_t v25 = *(void *)(a1 + 144);
      sub_431A8(a1, 1.0, 30.0);
      timer_callout_set(v25, (uint64_t)sub_45B80, a1, 2LL, 0LL, v26);
      uint64_t v27 = sub_57538();
      uint64_t v28 = _SC_syslog_os_log_mapping(6LL);
      if (__SC_log_enabled(6LL, v27, v28))
      {
        uint64_t v29 = _os_log_pack_size(18LL);
        uint64_t v30 = (char *)&v34 - ((__chkstk_darwin(v29) + 15) & 0xFFFFFFFFFFFFFFF0LL);
        uint64_t v31 = __error();
        uint64_t v32 = _os_log_pack_fill( v30,  v29,  *v31,  &dword_0,  "%s: Request Transmit (try=%d)",  v34,  (_DWORD)v35);
        int v33 = *(_DWORD *)(a1 + 156);
        *(_DWORD *)uint64_t v32 = 136315394;
        *(void *)(v32 + 4) = a1;
        *(_WORD *)(v32 + 12) = 1024;
        *(_DWORD *)(v32 + 14) = v33;
        __SC_log_send(6LL, v27, v28, v30);
      }

      sub_443E4(a1);
    }

    else
    {
      sub_42B4C(a1, 0LL, 0LL);
    }
  }

uint64_t sub_4601C(uint64_t a1)
{
  uint64_t result = (uint64_t)sub_437D8(a1, 1, v29, (uint64_t)v27);
  if (result)
  {
    uint64_t v3 = (unsigned __int8 *)result;
    int v4 = *(_DWORD *)(a1 + 116);
    if (v4 == 3)
    {
      if (!sub_45A6C(a1, 1, (uint64_t)v27, v28))
      {
        uint64_t v6 = sub_57538();
        uint64_t v7 = _SC_syslog_os_log_mapping(5LL);
        uint64_t result = __SC_log_enabled(5LL, v6, v7);
        if (!(_DWORD)result) {
          return result;
        }
        uint64_t v25 = _os_log_pack_size(12LL);
        unsigned int v9 = (char *)v27 - ((__chkstk_darwin(v25) + 15) & 0xFFFFFFFFFFFFFFF0LL);
        uint64_t v26 = *__error();
        uint64_t v11 = _os_log_pack_fill(v9, v25, v26, &dword_0, "DHCPv6Client: failed to add IA_PD, %s");
        goto LABEL_14;
      }
    }

    else
    {
      if (v4 != 2) {
        return result;
      }
      unsigned int v5 = sub_45B50(a1);
      uint64_t v31 = 0LL;
      unsigned int __src = bswap32(v5);
      if (!sub_57768((uint64_t)v27, 3u, 0xCuLL, &__src, v28))
      {
        uint64_t v6 = sub_57538();
        uint64_t v7 = _SC_syslog_os_log_mapping(5LL);
        uint64_t result = __SC_log_enabled(5LL, v6, v7);
        if (!(_DWORD)result) {
          return result;
        }
        uint64_t v8 = _os_log_pack_size(12LL);
        unsigned int v9 = (char *)v27 - ((__chkstk_darwin(v8) + 15) & 0xFFFFFFFFFFFFFFF0LL);
        uint64_t v10 = *__error();
        uint64_t v11 = _os_log_pack_fill(v9, v8, v10, &dword_0, "DHCPv6Client: failed to add IA_NA, %s");
LABEL_14:
        *(_DWORD *)uint64_t v11 = 136315138;
        *(void *)(v11 + 4) = v28;
        uint64_t v22 = v6;
        uint64_t v23 = v7;
        uint64_t v24 = v9;
        return __SC_log_send(5LL, v22, v23, v24);
      }
    }

    size_t v12 = *(uint64_t **)(a1 + 128);
    int v13 = sub_57760((uint64_t)v27);
    uint64_t result = sub_472A0(v12, v3, (v13 + 4));
    int v14 = result;
    if (result > 0x32 || ((1LL << result) & 0x4000000000041LL) == 0)
    {
      uint64_t v15 = sub_57538();
      uint64_t v16 = _SC_syslog_os_log_mapping(5LL);
      uint64_t result = __SC_log_enabled(5LL, v15, v16);
      if ((_DWORD)result)
      {
        uint64_t v17 = _os_log_pack_size(22LL);
        __n128 v18 = (char *)v27 - ((__chkstk_darwin(v17) + 15) & 0xFFFFFFFFFFFFFFF0LL);
        uint64_t v19 = __error();
        uint64_t v20 = _os_log_pack_fill( v18,  v17,  *v19,  &dword_0,  "%s: SendSolicit transmit failed, %s",  v27[0],  v27[1]);
        uint64_t v21 = strerror(v14);
        *(_DWORD *)uint64_t v20 = 136315394;
        *(void *)(v20 + 4) = a1;
        *(_WORD *)(v20 + 12) = 2080;
        *(void *)(v20 + 14) = v21;
        uint64_t v22 = v15;
        uint64_t v23 = v16;
        uint64_t v24 = v18;
        return __SC_log_send(5LL, v22, v23, v24);
      }
    }
  }

  return result;
}

uint64_t sub_46328(uint64_t a1)
{
  uint64_t v1 = sub_57BD4(a1, 7, (unsigned int *)&v3, 0LL);
  uint64_t result = 0LL;
  if (v1)
  {
    if (v3 >= 1) {
      return *(unsigned __int8 *)v1;
    }
  }

  return result;
}

uint64_t sub_4636C(uint64_t result, int a2, unsigned __int8 **a3)
{
  uint64_t v3 = result;
  if (a2 == 5)
  {
    if (**a3 == 7)
    {
      uint64_t result = (uint64_t)sub_43418(result, (uint64_t)a3[2]);
      if ((_DWORD)result)
      {
        uint64_t result = (uint64_t)sub_57BD4((uint64_t)a3[2], 2, (unsigned int *)&v24 + 1, 0LL);
        if (result)
        {
          uint64_t result = sub_56AA8((unsigned __int16 *)result, SHIDWORD(v24));
          if ((_DWORD)result)
          {
            uint64_t v7 = sub_57538();
            uint64_t v8 = _SC_syslog_os_log_mapping(6LL);
            if (__SC_log_enabled(6LL, v7, v8))
            {
              uint64_t v9 = _os_log_pack_size(28LL);
              uint64_t v10 = (char *)&v24 - ((__chkstk_darwin(v9) + 15) & 0xFFFFFFFFFFFFFFF0LL);
              uint64_t v11 = __error();
              uint64_t v12 = _os_log_pack_fill(v10, v9, *v11, &dword_0, "%s: %s Received (try=%d)", v24, v25, v26);
              int v13 = DHCPv6MessageTypeName(**a3);
              int v14 = *(_DWORD *)(v3 + 156);
              *(_DWORD *)uint64_t v12 = 136315650;
              *(void *)(v12 + 4) = v3;
              *(_WORD *)(v12 + 12) = 2080;
              *(void *)(v12 + 14) = v13;
              *(_WORD *)(v12 + 22) = 1024;
              *(_DWORD *)(v12 + 24) = v14;
              __SC_log_send(6LL, v7, v8, v10);
            }

            return sub_42B4C(v3, 0LL, 0LL);
          }
        }
      }
    }
  }

  else
  {
    if (a2 != 2)
    {
      if (a2) {
        return result;
      }
      sub_40908(result, 9u);
      sub_4055C(v3, (uint64_t)"Decline");
      sub_46FA0(*(void *)(v3 + 128));
      timer_cancel(*(void *)(v3 + 144));
      sub_4FA18((const void **)(v3 + 232));
      *(void *)(v3 + 232) = 0LL;
      *(_OWORD *)(v3 + 216) = 0u;
      *(_OWORD *)(v3 + 200) = 0u;
      *(_BYTE *)(v3 + 240) = 0;
      int v4 = *(dispatch_source_s **)(v3 + 32);
      if (v4) {
        dispatch_source_merge_data(v4, 1uLL);
      }
      *(_DWORD *)(v3 + 156) = 0;
      uint32_t v5 = arc4random();
      *(_DWORD *)(v3 + 152) = v5 & 0xFFFFFF;
      sub_46BD8(*(void *)(v3 + 128), v5 & 0xFFFFFF, (uint64_t)sub_4636C, v3, 5LL);
    }

    if (*(int *)(v3 + 156) < 5)
    {
      uint64_t v15 = *(void *)(v3 + 144);
      sub_431A8(v3, 1.0, 0.0);
      timer_callout_set(v15, (uint64_t)sub_4636C, v3, 2LL, 0LL, v16);
      uint64_t v17 = sub_57538();
      uint64_t v18 = _SC_syslog_os_log_mapping(6LL);
      if (__SC_log_enabled(6LL, v17, v18))
      {
        uint64_t v19 = _os_log_pack_size(18LL);
        uint64_t v20 = (char *)&v24 - ((__chkstk_darwin(v19) + 15) & 0xFFFFFFFFFFFFFFF0LL);
        uint64_t v21 = __error();
        uint64_t v22 = _os_log_pack_fill( v20,  v19,  *v21,  &dword_0,  "%s: Decline Transmit (try=%d)",  v24,  (_DWORD)v25);
        int v23 = *(_DWORD *)(v3 + 156);
        *(_DWORD *)uint64_t v22 = 136315394;
        *(void *)(v22 + 4) = v3;
        *(_WORD *)(v22 + 12) = 1024;
        *(_DWORD *)(v22 + 14) = v23;
        __SC_log_send(6LL, v17, v18, v20);
      }

      return sub_443E4(v3);
    }

    else
    {
      return sub_42B4C(v3, 0LL, 0LL);
    }
  }

  return result;
}

void sub_466D4(uint64_t a1)
{
  CFMutableStringRef Mutable = CFDictionaryCreateMutable(0LL, 0LL, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  sub_3FA84(a1, Mutable);
  uint64_t v3 = sub_57538();
  uint64_t v4 = _SC_syslog_os_log_mapping(5LL);
  if (__SC_log_enabled(5LL, v3, v4))
  {
    uint64_t v5 = _os_log_pack_size(32LL);
    uint64_t v6 = (char *)v11 - ((__chkstk_darwin(v5) + 15) & 0xFFFFFFFFFFFFFFF0LL);
    uint64_t v7 = __error();
    uint64_t v8 = _os_log_pack_fill(v6, v5, *v7, &dword_0, "%s: %s() %@");
    *(_DWORD *)uint64_t v8 = 136315650;
    *(void *)(v8 + 4) = a1;
    *(_WORD *)(v8 + 12) = 2080;
    *(void *)(v8 + 14) = "dhcpv6_pd_notify";
    *(_WORD *)(v8 + 22) = 2112;
    *(void *)(v8 + 24) = Mutable;
    __SC_log_send(5LL, v3, v4, v6);
  }

  CFRelease(Mutable);
  memset(v11, 0, sizeof(v11));
  int v9 = sub_40EE0(a1, (uint64_t)v11);
  uint64_t v10 = *(void *)(a1 + 136);
  if (v9)
  {
    sub_16BA4(v10, 0LL, 0, 0LL, 0LL, (uint64_t)v11, 0LL);
  }

  else if (sub_160CC(v10))
  {
    sub_17FEC(*(void *)(a1 + 136), 0xCu);
  }

uint64_t DHCPv6SocketSetVerbose(uint64_t result)
{
  byte_6C288 = result;
  return result;
}

uint64_t sub_468A4(uint64_t a1)
{
  return *(void *)a1;
}

void *sub_468AC(uint64_t a1)
{
  uint64_t v2 = qword_6C290;
  if (!qword_6C290)
  {
    uint64_t v3 = malloc(0x40uLL);
    if (!v3)
    {
      qword_6C290 = 0LL;
      uint64_t v6 = sub_57538();
      uint64_t v7 = _SC_syslog_os_log_mapping(5LL);
      if (__SC_log_enabled(5LL, v6, v7))
      {
        uint64_t v8 = _os_log_pack_size(2LL);
        int v9 = (char *)&v12 - ((__chkstk_darwin(v8) + 15) & 0xFFFFFFFFFFFFFFF0LL);
        uint64_t v10 = __error();
        *(_WORD *)_os_log_pack_fill( v9,  v8,  *v10,  &dword_0,  "DHCPv6SocketCreate: could not allocate globals") = 0;
        __SC_log_send(5LL, v6, v7, v9);
      }

      return 0LL;
    }

    uint64_t v2 = (uint64_t)v3;
    v3[2] = 0u;
    v3[3] = 0u;
    _OWORD *v3 = 0u;
    v3[1] = 0u;
    sub_53D14(v3, (uint64_t)sub_46BAC, 0LL);
    *(void *)(v2 + 48) = timer_callout_init("DHCPv6Socket");
    qword_6C290 = v2;
  }

  uint64_t v4 = malloc(0x28uLL);
  uint64_t v5 = v4;
  if (v4)
  {
    v4[4] = 0LL;
    *(_OWORD *)uint64_t v4 = 0u;
    *((_OWORD *)v4 + 1) = 0u;
    if (sub_53DA4(v2, v4))
    {
      void *v5 = a1;
      return v5;
    }

    free(v5);
    return 0LL;
  }

  return v5;
}

void sub_46A40(void **a1)
{
  uint64_t v1 = *a1;
  if (*a1)
  {
    unsigned int v3 = sub_53E84((uint64_t *)qword_6C290, (uint64_t)v1);
    if (v3 == -1)
    {
      uint64_t v4 = sub_57538();
      uint64_t v5 = _SC_syslog_os_log_mapping(5LL);
      if (__SC_log_enabled(5LL, v4, v5))
      {
        uint64_t v6 = _os_log_pack_size(12LL);
        uint64_t v7 = (char *)&v11 - ((__chkstk_darwin(v6) + 15) & 0xFFFFFFFFFFFFFFF0LL);
        uint64_t v8 = __error();
        uint64_t v9 = _os_log_pack_fill(v7, v6, *v8, &dword_0, "DHCPv6SocketRelease: %s not in list?", v11);
        uint64_t v10 = nullsub_1(*v1);
        *(_DWORD *)uint64_t v9 = 136315138;
        *(void *)(v9 + 4) = v10;
        __SC_log_send(5LL, v4, v5, v7);
      }
    }

    else
    {
      sub_53DA8((uint64_t *)qword_6C290, v3, 0LL);
    }

    v1[2] = 0LL;
    v1[3] = 0LL;
    v1[4] = 0LL;
    sub_46FAC((uint64_t)v1);
    free(v1);
    *a1 = 0LL;
  }

void sub_46BAC(void *a1)
{
  a1[2] = 0LL;
  a1[3] = 0LL;
  a1[4] = 0LL;
  sub_46FAC((uint64_t)a1);
  free(a1);
}

uint64_t sub_46BD8(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  *(void *)(a1 + 16) = a3;
  *(void *)(a1 + 24) = a4;
  *(void *)(a1 + 32) = a5;
  *(_DWORD *)(a1 + 12) = a2;
  uint64_t result = sub_46D34(a1);
  if ((_DWORD)result)
  {
    int v7 = result;
    uint64_t v8 = sub_57538();
    uint64_t v9 = _SC_syslog_os_log_mapping(5LL);
    uint64_t result = __SC_log_enabled(5LL, v8, v9);
    if ((_DWORD)result)
    {
      uint64_t v10 = _os_log_pack_size(32LL);
      uint64_t v11 = (char *)v16 - ((__chkstk_darwin(v10) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v12 = __error();
      uint64_t v13 = _os_log_pack_fill( v11,  v10,  *v12,  &dword_0,  "%s(%s): DHCPv6SocketOpenSocket failed, %s",  v16[0],  v16[1],  v16[2]);
      uint64_t v14 = nullsub_1(*(void *)a1);
      uint64_t v15 = strerror(v7);
      *(_DWORD *)uint64_t v13 = 136315650;
      *(void *)(v13 + 4) = "DHCPv6SocketEnableReceive";
      *(_WORD *)(v13 + 12) = 2080;
      *(void *)(v13 + 14) = v14;
      *(_WORD *)(v13 + 22) = 2080;
      *(void *)(v13 + 24) = v15;
      return __SC_log_send(5LL, v8, v9, v11);
    }
  }

  return result;
}

uint64_t sub_46D34(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 8)) {
    return 0LL;
  }
  timer_cancel(*(void *)(qword_6C290 + 48));
  ++*(_DWORD *)(qword_6C290 + 40);
  uint64_t v2 = sub_57538();
  uint64_t v3 = _SC_syslog_os_log_mapping(7LL);
  if (__SC_log_enabled(7LL, v2, v3))
  {
    uint64_t v4 = _os_log_pack_size(28LL);
    uint64_t v5 = (char *)v18 - ((__chkstk_darwin(v4) + 15) & 0xFFFFFFFFFFFFFFF0LL);
    uint64_t v6 = __error();
    uint64_t v7 = _os_log_pack_fill(v5, v4, *v6, &dword_0, "%s (%s): refcount %d", v18[0], v18[1], v19);
    uint64_t v8 = nullsub_1(*(void *)a1);
    int v9 = *(_DWORD *)(qword_6C290 + 40);
    *(_DWORD *)uint64_t v7 = 136315650;
    *(void *)(v7 + 4) = "DHCPv6SocketOpenSocket";
    *(_WORD *)(v7 + 12) = 2080;
    *(void *)(v7 + 14) = v8;
    *(_WORD *)(v7 + 22) = 1024;
    *(_DWORD *)(v7 + 24) = v9;
    __SC_log_send(7LL, v2, v3, v5);
  }

  *(_BYTE *)(a1 + 8) = 1;
  if (*(void *)(qword_6C290 + 32))
  {
    uint64_t v10 = sub_57538();
    uint64_t v11 = _SC_syslog_os_log_mapping(6LL);
    if (__SC_log_enabled(6LL, v10, v11))
    {
      uint64_t v12 = _os_log_pack_size(12LL);
      uint64_t v13 = (char *)v18 - ((__chkstk_darwin(v12) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v14 = __error();
      uint64_t v15 = _os_log_pack_fill(v13, v12, *v14, &dword_0, "%s: socket is still open", v18[0]);
      *(_DWORD *)uint64_t v15 = 136315138;
      *(void *)(v15 + 4) = "DHCPv6SocketOpenSocket";
      __SC_log_send(6LL, v10, v11, v13);
    }

    return 0LL;
  }

  uint64_t v16 = sub_477FC();
  if ((_DWORD)v16) {
    sub_46FAC(a1);
  }
  return v16;
}

BOOL sub_46F90(uint64_t a1)
{
  return *(void *)(a1 + 16) != 0LL;
}

uint64_t sub_46FA0(uint64_t result)
{
  *(void *)(result + 16) = 0LL;
  *(void *)(result + 24) = 0LL;
  *(void *)(result + 32) = 0LL;
  return sub_46FAC(result);
}

uint64_t sub_46FAC(uint64_t result)
{
  if (*(_BYTE *)(result + 8))
  {
    uint64_t v1 = (void *)result;
    int v2 = *(_DWORD *)(qword_6C290 + 40);
    if (v2 <= 0)
    {
      uint64_t v16 = sub_57538();
      uint64_t v17 = _SC_syslog_os_log_mapping(5LL);
      uint64_t result = __SC_log_enabled(5LL, v16, v17);
      if ((_DWORD)result)
      {
        uint64_t v18 = _os_log_pack_size(18LL);
        uint64_t v19 = (char *)&v24 - ((__chkstk_darwin(v18) + 15) & 0xFFFFFFFFFFFFFFF0LL);
        uint64_t v20 = __error();
        uint64_t v21 = _os_log_pack_fill( v19,  v18,  *v20,  &dword_0,  "DHCPv6SocketCloseSocket(%s): refcount %d",  v24,  v25);
        uint64_t v22 = nullsub_1(*v1);
        int v23 = *(_DWORD *)(qword_6C290 + 40);
        *(_DWORD *)uint64_t v21 = 136315394;
        *(void *)(v21 + 4) = v22;
        *(_WORD *)(v21 + 12) = 1024;
        *(_DWORD *)(v21 + 14) = v23;
        return __SC_log_send(5LL, v16, v17, v19);
      }
    }

    else
    {
      *(_DWORD *)(qword_6C290 + 40) = v2 - 1;
      uint64_t v3 = sub_57538();
      uint64_t v4 = _SC_syslog_os_log_mapping(7LL);
      uint64_t result = __SC_log_enabled(7LL, v3, v4);
      if ((_DWORD)result)
      {
        uint64_t v5 = _os_log_pack_size(18LL);
        uint64_t v6 = (char *)&v24 - ((__chkstk_darwin(v5) + 15) & 0xFFFFFFFFFFFFFFF0LL);
        uint64_t v7 = __error();
        uint64_t v8 = _os_log_pack_fill( v6,  v5,  *v7,  &dword_0,  "DHCPv6SocketCloseSocket(%s): refcount %d",  v24,  v25);
        uint64_t v9 = nullsub_1(*v1);
        int v10 = *(_DWORD *)(qword_6C290 + 40);
        *(_DWORD *)uint64_t v8 = 136315394;
        *(void *)(v8 + 4) = v9;
        *(_WORD *)(v8 + 12) = 1024;
        *(_DWORD *)(v8 + 14) = v10;
        uint64_t result = __SC_log_send(7LL, v3, v4, v6);
      }

      *((_BYTE *)v1 + 8) = 0;
      if (!*(_DWORD *)(qword_6C290 + 40))
      {
        uint64_t v11 = sub_57538();
        uint64_t v12 = _SC_syslog_os_log_mapping(7LL);
        if (__SC_log_enabled(7LL, v11, v12))
        {
          uint64_t v13 = _os_log_pack_size(2LL);
          uint64_t v14 = (char *)&v24 - ((__chkstk_darwin(v13) + 15) & 0xFFFFFFFFFFFFFFF0LL);
          uint64_t v15 = __error();
          *(_WORD *)_os_log_pack_fill( v14,  v13,  *v15,  &dword_0,  "DHCPv6SocketCloseSocket(): scheduling delayed close") = 0;
          __SC_log_send(7LL, v11, v12, v14);
        }

        return timer_set_relative(*(void *)(qword_6C290 + 48), 1LL, 0, (uint64_t)sub_48E84, 0LL, 0LL, 0LL);
      }
    }
  }

  return result;
}

uint64_t sub_472A0(uint64_t *a1, unsigned __int8 *a2, uint64_t a3)
{
  uint64_t v3 = &off_6C000;
  if (*(void *)(qword_6C290 + 32))
  {
    int v7 = *((unsigned __int8 *)a1 + 8);
    if (*((_BYTE *)a1 + 8) || (uint64_t v17 = sub_46D34((uint64_t)a1), !(_DWORD)v17))
    {
      if (byte_6C288)
      {
        CFMutableStringRef Mutable = CFStringCreateMutable(0LL, 0LL);
        DHCPv6PacketPrintToString(Mutable, a2, a3);
        uint64_t v9 = sub_579D0((uint64_t)a2, a3, v54);
        *(void *)uint64_t v53 = v9;
        if (v9)
        {
          sub_57A24(Mutable, (uint64_t)v9);
          sub_579E8((void **)v53);
        }

        else
        {
          uint64_t v34 = sub_57538();
          uint64_t v35 = _SC_syslog_os_log_mapping(7LL);
          if (__SC_log_enabled(7LL, v34, v35))
          {
            uint64_t v36 = _os_log_pack_size(12LL);
            uint64_t v52 = &v51;
            unsigned int v37 = (char *)&v51 - ((__chkstk_darwin(v36) + 15) & 0xFFFFFFFFFFFFFFF0LL);
            unsigned __int16 v38 = __error();
            uint64_t v39 = v36;
            uint64_t v3 = &off_6C000;
            uint64_t v40 = _os_log_pack_fill(v37, v39, *v38, &dword_0, "parse options failed, %s", v51);
            *(_DWORD *)uint64_t v40 = 136315138;
            *(void *)(v40 + 4) = v54;
            __SC_log_send(7LL, v34, v35, v37);
          }
        }

        uint64_t v41 = sub_57538();
        uint64_t v42 = _SC_syslog_os_log_mapping(4294967289LL);
        if (__SC_log_enabled(4294967289LL, v41, v42))
        {
          uint64_t v43 = _os_log_pack_size(22LL);
          LODWORD(v52) = v7;
          uint64_t v44 = (char *)&v51 - ((__chkstk_darwin(v43) + 15) & 0xFFFFFFFFFFFFFFF0LL);
          int v45 = __error();
          uint64_t v46 = _os_log_pack_fill(v44, v43, *v45, &dword_0, "[%s] Transmit %@");
          uint64_t v47 = nullsub_1(*a1);
          *(_DWORD *)uint64_t v46 = 136315394;
          *(void *)(v46 + 4) = v47;
          *(_WORD *)(v46 + 12) = 2112;
          *(void *)(v46 + 14) = Mutable;
          uint64_t v3 = &off_6C000;
          __SC_log_send(4294967289LL, v41, v42, v44);
          int v7 = (int)v52;
        }

        CFRelease(Mutable);
      }

      else
      {
        uint64_t v24 = sub_57538();
        uint64_t v25 = _SC_syslog_os_log_mapping(6LL);
        if (__SC_log_enabled(6LL, v24, v25))
        {
          uint64_t v26 = _os_log_pack_size(34LL);
          uint64_t v52 = &v51;
          uint64_t v27 = (char *)&v51 - ((__chkstk_darwin(v26) + 15) & 0xFFFFFFFFFFFFFFF0LL);
          uint64_t v28 = __error();
          uint64_t v29 = _os_log_pack_fill( v27,  v26,  *v28,  &dword_0,  "[%s] Transmit %s (%d) [%d bytes]",  v51,  (const char *)v52,  *(_DWORD *)v53,  *(_DWORD *)&v53[8]);
          uint64_t v30 = nullsub_1(*a1);
          uint64_t v31 = DHCPv6MessageTypeName(*a2);
          int v32 = *a2;
          *(_DWORD *)uint64_t v29 = 136315906;
          *(void *)(v29 + 4) = v30;
          *(_WORD *)(v29 + 12) = 2080;
          *(void *)(v29 + 14) = v31;
          *(_WORD *)(v29 + 22) = 1024;
          *(_DWORD *)(v29 + 24) = v32;
          *(_WORD *)(v29 + 28) = 1024;
          *(_DWORD *)(v29 + 30) = a3;
          int v33 = v27;
          uint64_t v3 = &off_6C000;
          __SC_log_send(6LL, v24, v25, v33);
        }
      }

      int v48 = sub_14418(*((unsigned int **)v3[82] + 4));
      int v49 = sub_54F6C(*a1);
      *(_OWORD *)uint64_t v53 = xmmword_595C8;
      *(_OWORD *)&v53[12] = *(__int128 *)((char *)&xmmword_595C8 + 12);
      *(_WORD *)&v53[2] = bswap32((unsigned __int16)word_6C0FE) >> 16;
      uint64_t v16 = sub_56244(v48, v49, v53, (uint64_t)a2, a3, -1);
      if (!v7) {
        sub_46FAC((uint64_t)a1);
      }
    }

    else
    {
      uint64_t v16 = v17;
      uint64_t v18 = sub_57538();
      uint64_t v19 = _SC_syslog_os_log_mapping(5LL);
      if (__SC_log_enabled(5LL, v18, v19))
      {
        uint64_t v20 = _os_log_pack_size(12LL);
        uint64_t v21 = (char *)&v51 - ((__chkstk_darwin(v20) + 15) & 0xFFFFFFFFFFFFFFF0LL);
        uint64_t v22 = __error();
        uint64_t v23 = _os_log_pack_fill(v21, v20, *v22, &dword_0, "%s: DHCPv6SocketOpenSocket failed", v51);
        *(_DWORD *)uint64_t v23 = 136315138;
        *(void *)(v23 + 4) = "DHCPv6SocketTransmit";
        __SC_log_send(5LL, v18, v19, v21);
      }
    }
  }

  else
  {
    uint64_t v10 = sub_57538();
    uint64_t v11 = _SC_syslog_os_log_mapping(5LL);
    if (__SC_log_enabled(5LL, v10, v11))
    {
      uint64_t v12 = _os_log_pack_size(12LL);
      uint64_t v13 = (char *)&v51 - ((__chkstk_darwin(v12) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v14 = __error();
      uint64_t v15 = _os_log_pack_fill(v13, v12, *v14, &dword_0, "%s: waiting for socket to close", v51);
      *(_DWORD *)uint64_t v15 = 136315138;
      *(void *)(v15 + 4) = "DHCPv6SocketTransmit";
      __SC_log_send(5LL, v10, v11, v13);
    }

    return 0LL;
  }

  return v16;
}

uint64_t sub_477FC()
{
  if (*(_BYTE *)(qword_6C290 + 56))
  {
    uint64_t v0 = sub_57538();
    uint64_t v1 = _SC_syslog_os_log_mapping(7LL);
    if (__SC_log_enabled(7LL, v0, v1))
    {
      uint64_t v2 = _os_log_pack_size(12LL);
      uint64_t v3 = (char *)&v23 - ((__chkstk_darwin(v2) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v4 = __error();
      uint64_t v5 = _os_log_pack_fill(v3, v2, *v4, &dword_0, "%s: waiting for cancel to complete", v23);
      *(_DWORD *)uint64_t v5 = 136315138;
      *(void *)(v5 + 4) = "DHCPv6SocketOpenSocketFD";
      __SC_log_send(7LL, v0, v1, v3);
    }

    return 0LL;
  }

  int v6 = sub_47AD0((unsigned __int16)word_6C0FC);
  if ((v6 & 0x80000000) == 0)
  {
    int v7 = v6;
    uint64_t v8 = sub_57538();
    uint64_t v9 = _SC_syslog_os_log_mapping(7LL);
    if (__SC_log_enabled(7LL, v8, v9))
    {
      uint64_t v10 = _os_log_pack_size(18LL);
      uint64_t v11 = (char *)&v23 - ((__chkstk_darwin(v10) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v12 = __error();
      uint64_t v13 = _os_log_pack_fill(v11, v10, *v12, &dword_0, "%s: opened DHCPv6 socket %d", v23, (_DWORD)v24);
      *(_DWORD *)uint64_t v13 = 136315394;
      *(void *)(v13 + 4) = "DHCPv6SocketOpenSocketFD";
      *(_WORD *)(v13 + 12) = 1024;
      *(_DWORD *)(v13 + 14) = v7;
      __SC_log_send(7LL, v8, v9, v11);
    }

    sub_48150(v7);
    return 0LL;
  }

  uint64_t v14 = *__error();
  uint64_t v16 = sub_57538();
  uint64_t v17 = _SC_syslog_os_log_mapping(5LL);
  if (__SC_log_enabled(5LL, v16, v17))
  {
    uint64_t v18 = _os_log_pack_size(22LL);
    uint64_t v19 = (char *)&v23 - ((__chkstk_darwin(v18) + 15) & 0xFFFFFFFFFFFFFFF0LL);
    uint64_t v20 = __error();
    uint64_t v21 = _os_log_pack_fill(v19, v18, *v20, &dword_0, "%s: socket() failed, %s", v23, v24);
    uint64_t v22 = strerror(v14);
    *(_DWORD *)uint64_t v21 = 136315394;
    *(void *)(v21 + 4) = "DHCPv6SocketOpenSocketFD";
    *(_WORD *)(v21 + 12) = 2080;
    *(void *)(v21 + 14) = v22;
    __SC_log_send(5LL, v16, v17, v19);
  }

  return v14;
}

uint64_t sub_47AD0(unsigned int a1)
{
  HIDWORD(v53) = 1;
  uint64_t v2 = socket(30, 2, 0);
  uint64_t v3 = v2;
  if ((v2 & 0x80000000) != 0)
  {
    uint64_t v13 = sub_57538();
    uint64_t v14 = _SC_syslog_os_log_mapping(3LL);
    uint64_t v15 = _os_log_pack_size(12LL);
    uint64_t v16 = (char *)&v53 - ((__chkstk_darwin(v15) + 15) & 0xFFFFFFFFFFFFFFF0LL);
    uint64_t v17 = *__error();
    uint64_t v18 = _os_log_pack_fill(v16, v15, v17, &dword_0, "DHCPv6Socket: socket failed, %s");
LABEL_9:
    uint64_t v19 = v18;
    uint64_t v20 = __error();
    uint64_t v21 = strerror(*v20);
    *(_DWORD *)uint64_t v19 = 136315138;
    *(void *)(v19 + 4) = v21;
    __SC_log_send(3LL, v13, v14, v16);
    return v3;
  }

  *(void *)&v54.sa_len = 7680LL;
  *(void *)&v54.sa_data[6] = 0LL;
  int v56 = 0;
  uint64_t v55 = 0LL;
  *(_WORD *)v54.sa_uint64_t data = __rev16(a1);
  if (bind(v2, &v54, 0x1Cu))
  {
    uint64_t v4 = sub_57538();
    uint64_t v5 = _SC_syslog_os_log_mapping(3LL);
    if (!__SC_log_enabled(3LL, v4, v5))
    {
LABEL_6:
      close(v3);
      return 0xFFFFFFFFLL;
    }

    uint64_t v6 = _os_log_pack_size(12LL);
    int v7 = (char *)&v53 - ((__chkstk_darwin(v6) + 15) & 0xFFFFFFFFFFFFFFF0LL);
    uint64_t v8 = *__error();
    uint64_t v9 = _os_log_pack_fill(v7, v6, v8, &dword_0, "DHCPv6Socket: bind failed, %s");
LABEL_5:
    uint64_t v10 = v9;
    uint64_t v11 = __error();
    uint64_t v12 = strerror(*v11);
    *(_DWORD *)uint64_t v10 = 136315138;
    *(void *)(v10 + 4) = v12;
    __SC_log_send(3LL, v4, v5, v7);
    goto LABEL_6;
  }

  if (ioctl(v3, 0x8004667EuLL, (char *)&v53 + 4) < 0)
  {
    uint64_t v4 = sub_57538();
    uint64_t v5 = _SC_syslog_os_log_mapping(3LL);
    uint64_t v49 = _os_log_pack_size(12LL);
    int v7 = (char *)&v53 - ((__chkstk_darwin(v49) + 15) & 0xFFFFFFFFFFFFFFF0LL);
    uint64_t v50 = *__error();
    uint64_t v9 = _os_log_pack_fill(v7, v49, v50, &dword_0, "DHCPv6Socket: ioctl FIONBIO failed, %s");
    goto LABEL_5;
  }

  if (setsockopt(v3, 41, 61, (char *)&v53 + 4, 4u) < 0)
  {
    uint64_t v4 = sub_57538();
    uint64_t v5 = _SC_syslog_os_log_mapping(3LL);
    uint64_t v51 = _os_log_pack_size(12LL);
    int v7 = (char *)&v53 - ((__chkstk_darwin(v51) + 15) & 0xFFFFFFFFFFFFFFF0LL);
    uint64_t v52 = *__error();
    uint64_t v9 = _os_log_pack_fill(v7, v51, v52, &dword_0, "DHCPv6Socket: setsockopt(IPV6_PKTINFO) failed, %s");
    goto LABEL_5;
  }

  if (setsockopt(v3, 0xFFFF, 4356, (char *)&v53 + 4, 4u) < 0)
  {
    uint64_t v23 = sub_57538();
    uint64_t v24 = _SC_syslog_os_log_mapping(3LL);
    if (__SC_log_enabled(3LL, v23, v24))
    {
      uint64_t v25 = _os_log_pack_size(12LL);
      uint64_t v26 = (char *)&v53 - ((__chkstk_darwin(v25) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v27 = __error();
      uint64_t v28 = _os_log_pack_fill(v26, v25, *v27, &dword_0, "setsockopt(SO_RECV_ANYIF) failed, %s", v53);
      uint64_t v29 = __error();
      uint64_t v30 = strerror(*v29);
      *(_DWORD *)uint64_t v28 = 136315138;
      *(void *)(v28 + 4) = v30;
      __SC_log_send(3LL, v23, v24, v26);
    }
  }

  HIDWORD(v53) = 900;
  if (setsockopt(v3, 0xFFFF, 4230, (char *)&v53 + 4, 4u) < 0)
  {
    uint64_t v31 = sub_57538();
    uint64_t v32 = _SC_syslog_os_log_mapping(3LL);
    if (__SC_log_enabled(3LL, v31, v32))
    {
      uint64_t v33 = _os_log_pack_size(12LL);
      uint64_t v34 = (char *)&v53 - ((__chkstk_darwin(v33) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v35 = __error();
      uint64_t v36 = _os_log_pack_fill(v34, v33, *v35, &dword_0, "setsockopt(SO_TRAFFIC_CLASS) failed, %s", v53);
      unsigned int v37 = __error();
      unsigned __int16 v38 = strerror(*v37);
      *(_DWORD *)uint64_t v36 = 136315138;
      *(void *)(v36 + 4) = v38;
      __SC_log_send(3LL, v31, v32, v34);
    }
  }

  HIDWORD(v53) = 0;
  if (setsockopt(v3, 0xFFFF, 4352, (char *)&v53 + 4, 4u) < 0)
  {
    uint64_t v39 = sub_57538();
    uint64_t v40 = _SC_syslog_os_log_mapping(3LL);
    if (__SC_log_enabled(3LL, v39, v40))
    {
      uint64_t v41 = _os_log_pack_size(12LL);
      uint64_t v42 = (char *)&v53 - ((__chkstk_darwin(v41) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v43 = __error();
      uint64_t v44 = _os_log_pack_fill(v42, v41, *v43, &dword_0, "setsockopt(SO_DEFUNCTOK) failed, %s", v53);
      int v45 = __error();
      uint64_t v46 = strerror(*v45);
      *(_DWORD *)uint64_t v44 = 136315138;
      *(void *)(v44 + 4) = v46;
      __SC_log_send(3LL, v39, v40, v42);
    }
  }

  HIDWORD(v53) = 0;
  if (setsockopt(v3, 41, 11, (char *)&v53 + 4, 4u) < 0)
  {
    uint64_t v13 = sub_57538();
    uint64_t v14 = _SC_syslog_os_log_mapping(3LL);
    if (__SC_log_enabled(3LL, v13, v14))
    {
      uint64_t v47 = _os_log_pack_size(12LL);
      uint64_t v16 = (char *)&v53 - ((__chkstk_darwin(v47) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v48 = *__error();
      uint64_t v18 = _os_log_pack_fill(v16, v47, v48, &dword_0, "setsockopt(IPV6_MULTICAST_LOOP) failed, %s");
      goto LABEL_9;
    }
  }

  return v3;
}

void *sub_48150(int a1)
{
  uint64_t v2 = sub_57538();
  uint64_t v3 = _SC_syslog_os_log_mapping(7LL);
  if (__SC_log_enabled(7LL, v2, v3))
  {
    uint64_t v4 = _os_log_pack_size(18LL);
    uint64_t v5 = (char *)&v9 - ((__chkstk_darwin(v4) + 15) & 0xFFFFFFFFFFFFFFF0LL);
    uint64_t v6 = __error();
    uint64_t v7 = _os_log_pack_fill( v5,  v4,  *v6,  &dword_0,  "%s: enabling receive on socket %d",  (const char *)v9,  v10);
    *(_DWORD *)uint64_t v7 = 136315394;
    *(void *)(v7 + 4) = "DHCPv6SocketEnableReceiveCallBack";
    *(_WORD *)(v7 + 12) = 1024;
    *(_DWORD *)(v7 + 14) = a1;
    __SC_log_send(7LL, v2, v3, v5);
  }

  uint64_t v9 = _NSConcreteStackBlock;
  uint64_t v10 = 0x40000000LL;
  uint64_t v11 = sub_482C4;
  uint64_t v12 = &unk_65038;
  int v13 = a1;
  uint64_t result = sub_141BC(a1, (uint64_t)sub_48558, 0LL, 0LL, &v9);
  *(void *)(qword_6C290 + 32) = result;
  return result;
}

uint64_t sub_482C4(uint64_t a1)
{
  return sub_482CC(*(unsigned int *)(a1 + 32));
}

uint64_t sub_482CC(uint64_t a1)
{
  uint64_t v2 = sub_57538();
  uint64_t v3 = _SC_syslog_os_log_mapping(7LL);
  if (__SC_log_enabled(7LL, v2, v3))
  {
    uint64_t v4 = _os_log_pack_size(18LL);
    uint64_t v5 = (char *)&v22 - ((__chkstk_darwin(v4) + 15) & 0xFFFFFFFFFFFFFFF0LL);
    uint64_t v6 = __error();
    uint64_t v7 = _os_log_pack_fill(v5, v4, *v6, &dword_0, "%s: socket %d complete", v22, v23);
    *(_DWORD *)uint64_t v7 = 136315394;
    *(void *)(v7 + 4) = "DHCPv6SocketFDComplete";
    *(_WORD *)(v7 + 12) = 1024;
    *(_DWORD *)(v7 + 14) = a1;
    __SC_log_send(7LL, v2, v3, v5);
  }

  uint64_t v8 = qword_6C290;
  *(_BYTE *)(qword_6C290 + 56) = 0;
  int v9 = *(_DWORD *)(v8 + 40);
  uint64_t v10 = sub_57538();
  uint64_t v11 = _SC_syslog_os_log_mapping(7LL);
  int v12 = __SC_log_enabled(7LL, v10, v11);
  if (v9 < 1)
  {
    if (v12)
    {
      uint64_t v18 = _os_log_pack_size(18LL);
      uint64_t v19 = (char *)&v22 - ((__chkstk_darwin(v18) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v20 = __error();
      uint64_t v21 = _os_log_pack_fill(v19, v18, *v20, &dword_0, "%s: closing socket %d", v22, v23);
      *(_DWORD *)uint64_t v21 = 136315394;
      *(void *)(v21 + 4) = "DHCPv6SocketFDComplete";
      *(_WORD *)(v21 + 12) = 1024;
      *(_DWORD *)(v21 + 14) = a1;
      __SC_log_send(7LL, v10, v11, v19);
    }

    return close(a1);
  }

  else
  {
    if (v12)
    {
      uint64_t v13 = _os_log_pack_size(18LL);
      uint64_t v14 = (char *)&v22 - ((__chkstk_darwin(v13) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v15 = __error();
      uint64_t v16 = _os_log_pack_fill(v14, v13, *v15, &dword_0, "%s: re-enabling socket %d", v22, v23);
      *(_DWORD *)uint64_t v16 = 136315394;
      *(void *)(v16 + 4) = "DHCPv6SocketFDComplete";
      *(_WORD *)(v16 + 12) = 1024;
      *(_DWORD *)(v16 + 14) = a1;
      __SC_log_send(7LL, v10, v11, v14);
    }

    return sub_48150(a1);
  }

void sub_48558()
{
  v31[0] = v32;
  v31[1] = 1500LL;
  v28.msg_name = &v29;
  v28.msg_namelen = 28;
  v28.msg_iov = (iovec *)v31;
  v28.msg_iovlen = 1;
  v28.msg_control = &v33;
  *(void *)&v28.msg_controllen = 32LL;
  int v0 = sub_14418(*(unsigned int **)(qword_6C290 + 32));
  ssize_t v1 = recvmsg(v0, &v28, 0);
  if (v1 < 0)
  {
    int v13 = *__error();
    if (v13 != 35)
    {
      uint64_t v14 = sub_57538();
      uint64_t v15 = _SC_syslog_os_log_mapping(3LL);
      if (__SC_log_enabled(3LL, v14, v15))
      {
        uint64_t v16 = _os_log_pack_size(18LL);
        uint64_t v17 = (char *)&v27 - ((__chkstk_darwin(v16) + 15) & 0xFFFFFFFFFFFFFFF0LL);
        uint64_t v18 = __error();
        uint64_t v19 = _os_log_pack_fill( v17,  v16,  *v18,  &dword_0,  "DHCPv6SocketRead: recvfrom failed %s (%d)",  (const char *)v27,  DWORD2(v27));
        uint64_t v20 = __error();
        uint64_t v21 = strerror(*v20);
        *(_DWORD *)uint64_t v19 = 136315394;
        *(void *)(v19 + 4) = v21;
        *(_WORD *)(v19 + 12) = 1024;
        *(_DWORD *)(v19 + 14) = v13;
        __SC_log_send(3LL, v14, v15, v17);
      }

      if (v13 == 57) {
        sub_488F4();
      }
    }
  }

  else
  {
    uint64_t v3 = v1;
    if (v1)
    {
      if (v28.msg_controllen < 0xC) {
        goto LABEL_21;
      }
      msg_control = (unsigned int *)v28.msg_control;
      if (!v28.msg_control) {
        goto LABEL_21;
      }
      uint64_t v5 = 0LL;
      *(void *)&__int128 v2 = 67109120LL;
      __int128 v27 = v2;
      do
      {
        if (msg_control[1] == 41)
        {
          if (msg_control[2] == 46)
          {
            if (*msg_control >= 0x20) {
              uint64_t v5 = msg_control + 3;
            }
          }

          else
          {
            uint64_t v6 = sub_57538();
            uint64_t v7 = _SC_syslog_os_log_mapping(5LL);
            if (__SC_log_enabled(5LL, v6, v7))
            {
              uint64_t v8 = _os_log_pack_size(8LL);
              int v9 = (char *)&v27 - ((__chkstk_darwin(v8) + 15) & 0xFFFFFFFFFFFFFFF0LL);
              uint64_t v10 = __error();
              uint64_t v11 = (_DWORD *)_os_log_pack_fill( v9,  v8,  *v10,  &dword_0,  "Why did we get control message type %d?",  (_DWORD)v27);
              unsigned int v12 = msg_control[2];
              *uint64_t v11 = v27;
              v11[1] = v12;
              __SC_log_send(5LL, v6, v7, v9);
            }
          }
        }

        msg_control = (unsigned int *)((char *)msg_control + ((*msg_control + 3LL) & 0x1FFFFFFFCLL));
      }

      while ((char *)(msg_control + 3) <= (char *)v28.msg_control + v28.msg_controllen);
      if (v5)
      {
        sub_48A4C(v5[4], &v30, v32, v3);
      }

      else
      {
LABEL_21:
        uint64_t v22 = sub_57538();
        uint64_t v23 = _SC_syslog_os_log_mapping(5LL);
        if (__SC_log_enabled(5LL, v22, v23))
        {
          uint64_t v24 = _os_log_pack_size(2LL);
          uint64_t v25 = (char *)&v27 - ((__chkstk_darwin(v24) + 15) & 0xFFFFFFFFFFFFFFF0LL);
          uint64_t v26 = __error();
          *(_WORD *)_os_log_pack_fill(v25, v24, *v26, &dword_0, "DHCPv6SocketRead: missing IPV6_PKTINFO") = 0;
          __SC_log_send(5LL, v22, v23, v25);
        }
      }
    }
  }

void sub_488F4()
{
  uint64_t v0 = qword_6C290;
  if (*(_BYTE *)(qword_6C290 + 56))
  {
    uint64_t v1 = sub_57538();
    uint64_t v2 = _SC_syslog_os_log_mapping(3LL);
    if (__SC_log_enabled(3LL, v1, v2))
    {
      uint64_t v3 = _os_log_pack_size(12LL);
      uint64_t v4 = (char *)&v7 - ((__chkstk_darwin(v3) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v5 = __error();
      uint64_t v6 = _os_log_pack_fill(v4, v3, *v5, &dword_0, "%s: cancel is already pending?", v7);
      *(_DWORD *)uint64_t v6 = 136315138;
      *(void *)(v6 + 4) = "DHCPv6SocketScheduleClose";
      __SC_log_send(3LL, v1, v2, v4);
    }
  }

  else
  {
    *(_BYTE *)(qword_6C290 + 56) = 1;
    sub_143D4((dispatch_object_t **)(v0 + 32));
  }

void sub_48A4C(int a1, const void *a2, char *a3, uint64_t a4)
{
  if ((int)a4 >= 4)
  {
    uint64_t v46 = a3;
    int v47 = a4;
    uint64_t v48 = sub_579D0((uint64_t)a3, a4, v50);
    if (v48)
    {
      if ((int)sub_50C94(qword_6C290) >= 1)
      {
        uint64_t v8 = 0LL;
        while (1)
        {
          int v9 = (void *)sub_50C98(qword_6C290, v8);
          if (sub_54F6C(*v9) == a1)
          {
            int v10 = *((_DWORD *)v9 + 3);
          }

          uint64_t v8 = (v8 + 1);
        }

        if (byte_6C288)
        {
          CFMutableStringRef Mutable = CFStringCreateMutable(0LL, 0LL);
          DHCPv6PacketPrintToString(Mutable, (unsigned __int8 *)a3, a4);
          sub_57A24(Mutable, (uint64_t)v48);
          uint64_t v18 = sub_57538();
          uint64_t v19 = _SC_syslog_os_log_mapping(4294967289LL);
          if (__SC_log_enabled(4294967289LL, v18, v19))
          {
            uint64_t v20 = _os_log_pack_size(32LL);
            int v45 = &v40;
            uint64_t v21 = (char *)&v40 - ((__chkstk_darwin(v20) + 15) & 0xFFFFFFFFFFFFFFF0LL);
            uint64_t v22 = __error();
            uint64_t v23 = _os_log_pack_fill(v21, v20, *v22, &dword_0, "[%s] Receive from %s %@");
            uint64_t v24 = nullsub_1(*v9);
            uint64_t v25 = inet_ntop(30, a2, v49, 0x2Eu);
            *(_DWORD *)uint64_t v23 = 136315650;
            *(void *)(v23 + 4) = v24;
            *(_WORD *)(v23 + 12) = 2080;
            *(void *)(v23 + 14) = v25;
            *(_WORD *)(v23 + 22) = 2112;
            *(void *)(v23 + 24) = Mutable;
            __SC_log_send(4294967289LL, v18, v19, v21);
          }

          CFRelease(Mutable);
        }

        else
        {
          uint64_t v26 = sub_57538();
          uint64_t v27 = _SC_syslog_os_log_mapping(6LL);
          unsigned int v28 = v27;
          if (__SC_log_enabled(6LL, v26, v27))
          {
            uint64_t v29 = _os_log_pack_size(50LL);
            int v45 = &v40;
            int v30 = (char *)&v40 - ((__chkstk_darwin(v29) + 15) & 0xFFFFFFFFFFFFFFF0LL);
            uint64_t v31 = __error();
            uint64_t v32 = _os_log_pack_fill( v30,  v29,  *v31,  &dword_0,  "[%s] Receive %s (%d) [%d bytes] [xid=0x%x] from %s",  v40,  v41,  v42,  v43,  (_DWORD)v45,  v46);
            uint64_t v41 = (const char *)nullsub_1(*v9);
            char v33 = DHCPv6MessageTypeName(*a3);
            unsigned int v44 = v28;
            uint64_t v34 = v33;
            uint64_t v42 = v26;
            int v35 = *a3;
            int TransactionID = DHCPv6PacketGetTransactionID((unsigned __int8 *)a3);
            unsigned int v37 = inet_ntop(30, a2, v49, 0x2Eu);
            *(_DWORD *)uint64_t v32 = 136316418;
            uint64_t v38 = v42;
            *(void *)(v32 + 4) = v41;
            *(_WORD *)(v32 + 12) = 2080;
            *(void *)(v32 + 14) = v34;
            *(_WORD *)(v32 + 22) = 1024;
            *(_DWORD *)(v32 + 24) = v35;
            *(_WORD *)(v32 + 28) = 1024;
            *(_DWORD *)(v32 + 30) = a4;
            *(_WORD *)(v32 + 34) = 1024;
            *(_DWORD *)(v32 + 36) = TransactionID;
            *(_WORD *)(v32 + 40) = 2080;
            *(void *)(v32 + 42) = v37;
            __SC_log_send(6LL, v38, v44, v30);
          }
        }

        uint64_t v39 = (void (*)(void, void, char **))v9[2];
        if (v39) {
          v39(v9[3], v9[4], &v46);
        }
      }

LABEL_21:
      sub_579E8((void **)&v48);
    }

    else
    {
      uint64_t v11 = sub_57538();
      uint64_t v12 = _SC_syslog_os_log_mapping(5LL);
      if (__SC_log_enabled(5LL, v11, v12))
      {
        uint64_t v13 = _os_log_pack_size(12LL);
        uint64_t v14 = (char *)&v40 - ((__chkstk_darwin(v13) + 15) & 0xFFFFFFFFFFFFFFF0LL);
        uint64_t v15 = __error();
        uint64_t v16 = _os_log_pack_fill(v14, v13, *v15, &dword_0, "DHCPv6Socket: options parse failed, %s", v40);
        *(_DWORD *)uint64_t v16 = 136315138;
        *(void *)(v16 + 4) = v50;
        __SC_log_send(5LL, v11, v12, v14);
      }
    }
  }

void sub_48E84()
{
  if (!*(void *)(qword_6C290 + 32))
  {
    uint64_t v1 = sub_57538();
    uint64_t v2 = _SC_syslog_os_log_mapping(5LL);
    uint64_t v7 = _os_log_pack_size(2LL);
    uint64_t v4 = (char *)&v15 - ((__chkstk_darwin(v7) + 15) & 0xFFFFFFFFFFFFFFF0LL);
    uint64_t v8 = *__error();
    uint64_t v6 = (_WORD *)_os_log_pack_fill(v4, v7, v8, &dword_0, "DHCPv6SocketDelayedClose(): socket is already closed");
    goto LABEL_7;
  }

  int v0 = *(_DWORD *)(qword_6C290 + 40);
  uint64_t v1 = sub_57538();
  if (v0 >= 1)
  {
    uint64_t v2 = _SC_syslog_os_log_mapping(5LL);
    uint64_t v3 = _os_log_pack_size(2LL);
    uint64_t v4 = (char *)&v15 - ((__chkstk_darwin(v3) + 15) & 0xFFFFFFFFFFFFFFF0LL);
    uint64_t v5 = *__error();
    uint64_t v6 = (_WORD *)_os_log_pack_fill(v4, v3, v5, &dword_0, "DHCPv6SocketDelayedClose(): called when socket in use");
LABEL_7:
    *uint64_t v6 = 0;
    __SC_log_send(5LL, v1, v2, v4);
    return;
  }

  uint64_t v9 = _SC_syslog_os_log_mapping(7LL);
  if (__SC_log_enabled(7LL, v1, v9))
  {
    uint64_t v10 = _os_log_pack_size(8LL);
    uint64_t v11 = (char *)&v15 - ((__chkstk_darwin(v10) + 15) & 0xFFFFFFFFFFFFFFF0LL);
    uint64_t v12 = __error();
    uint64_t v13 = (_DWORD *)_os_log_pack_fill( v11,  v10,  *v12,  &dword_0,  "DHCPv6SocketDelayedClose(): closing DHCPv6 socket %d",  v15);
    int v14 = sub_14418(*(unsigned int **)(qword_6C290 + 32));
    *uint64_t v13 = 67109120;
    v13[1] = v14;
    __SC_log_send(7LL, v1, v9, v11);
  }

  sub_488F4();
}

uint64_t sub_490C8(uint64_t a1, int a2, uint64_t a3)
{
  uint64_t v6 = sub_14834(a1);
  if (a2 == 15)
  {
    sub_49334(a1, a3);
  }

  else
  {
    uint64_t v7 = v6;
    if (a2 == 1)
    {
      uint64_t v17 = sub_57538();
      uint64_t v18 = _SC_syslog_os_log_mapping(7LL);
      if (__SC_log_enabled(7LL, v17, v18))
      {
        uint64_t v19 = _os_log_pack_size(22LL);
        uint64_t v20 = (char *)&v26 - ((__chkstk_darwin(v19) + 15) & 0xFFFFFFFFFFFFFFF0LL);
        uint64_t v21 = __error();
        uint64_t v22 = _os_log_pack_fill(v20, v19, *v21, &dword_0, "%s %s: STOP", v26, v27);
        uint64_t v23 = sub_1509C(a1);
        uint64_t v24 = nullsub_1(v7);
        *(_DWORD *)uint64_t v22 = 136315394;
        *(void *)(v22 + 4) = v23;
        *(_WORD *)(v22 + 12) = 2080;
        *(void *)(v22 + 14) = v24;
        __SC_log_send(7LL, v17, v18, v20);
      }
    }

    else if (!a2)
    {
      uint64_t v8 = sub_57538();
      uint64_t v9 = _SC_syslog_os_log_mapping(7LL);
      if (__SC_log_enabled(7LL, v8, v9))
      {
        uint64_t v10 = _os_log_pack_size(22LL);
        uint64_t v11 = (char *)&v26 - ((__chkstk_darwin(v10) + 15) & 0xFFFFFFFFFFFFFFF0LL);
        uint64_t v12 = __error();
        uint64_t v13 = _os_log_pack_fill(v11, v10, *v12, &dword_0, "%s %s: START", v26, v27);
        int v14 = sub_1509C(a1);
        uint64_t v15 = nullsub_1(v7);
        *(_DWORD *)uint64_t v13 = 136315394;
        *(void *)(v13 + 4) = v14;
        *(_WORD *)(v13 + 12) = 2080;
        *(void *)(v13 + 14) = v15;
        __SC_log_send(7LL, v8, v9, v11);
      }

      int v16 = sub_54F6C(v7);
      sub_35A4C((uint64_t)&v26, v16);
      sub_49334(a1, (uint64_t)&v26);
      sub_36090((uint64_t)&v26);
    }
  }

  return 0LL;
}

void sub_49334(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = sub_3617C(a2);
  if (v3 && (*(_BYTE *)(v3 + 20) & 6) == 0) {
    sub_16BA4(a1, (_DWORD *)v3, 1, 0LL, 0LL, 0LL, 0LL);
  }
  else {
    sub_17FEC(a1, 0x12u);
  }
}

uint64_t sub_49398(int a1)
{
  HIDWORD(v50) = 1;
  uint64_t v2 = socket(30, 3, 58);
  if ((v2 & 0x80000000) != 0)
  {
    uint64_t v28 = sub_57538();
    uint64_t v29 = _SC_syslog_os_log_mapping(3LL);
    if (__SC_log_enabled(3LL, v28, v29))
    {
      uint64_t v30 = _os_log_pack_size(12LL);
      uint64_t v31 = (char *)&v50 - ((__chkstk_darwin(v30) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v32 = __error();
      uint64_t v33 = _os_log_pack_fill(v31, v30, *v32, &dword_0, "error opening socket: %s", v50);
      uint64_t v34 = __error();
      int v35 = strerror(*v34);
      *(_DWORD *)uint64_t v33 = 136315138;
      *(void *)(v33 + 4) = v35;
      __SC_log_send(3LL, v28, v29, v31);
      return 0xFFFFFFFFLL;
    }

    return 0xFFFFFFFFLL;
  }

  uint64_t v3 = v2;
  if (ioctl(v2, 0x8004667EuLL, (char *)&v50 + 4) < 0)
  {
    uint64_t v36 = sub_57538();
    uint64_t v37 = _SC_syslog_os_log_mapping(3LL);
    uint64_t v38 = _os_log_pack_size(12LL);
    uint64_t v39 = (char *)&v50 - ((__chkstk_darwin(v38) + 15) & 0xFFFFFFFFFFFFFFF0LL);
    uint64_t v40 = *__error();
    uint64_t v41 = _os_log_pack_fill(v39, v38, v40, &dword_0, "ioctl FIONBIO failed %s");
LABEL_23:
    uint64_t v46 = v41;
    int v47 = __error();
    uint64_t v48 = strerror(*v47);
    *(_DWORD *)uint64_t v46 = 136315138;
    *(void *)(v46 + 4) = v48;
    __SC_log_send(3LL, v36, v37, v39);
    goto LABEL_24;
  }

  if (setsockopt(v3, 0xFFFF, 4356, (char *)&v50 + 4, 4u) < 0)
  {
    uint64_t v4 = sub_57538();
    uint64_t v5 = _SC_syslog_os_log_mapping(3LL);
    if (__SC_log_enabled(3LL, v4, v5))
    {
      uint64_t v6 = _os_log_pack_size(12LL);
      uint64_t v7 = (char *)&v50 - ((__chkstk_darwin(v6) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v8 = __error();
      uint64_t v9 = _os_log_pack_fill(v7, v6, *v8, &dword_0, "setsockopt(SO_RECV_ANYIF) failed, %s", v50);
      uint64_t v10 = __error();
      uint64_t v11 = strerror(*v10);
      *(_DWORD *)uint64_t v9 = 136315138;
      *(void *)(v9 + 4) = v11;
      __SC_log_send(3LL, v4, v5, v7);
    }
  }

  if (!a1) {
    goto LABEL_9;
  }
  if (setsockopt(v3, 41, 61, (char *)&v50 + 4, 4u) < 0)
  {
    uint64_t v36 = sub_57538();
    uint64_t v37 = _SC_syslog_os_log_mapping(3LL);
    uint64_t v42 = _os_log_pack_size(12LL);
    uint64_t v39 = (char *)&v50 - ((__chkstk_darwin(v42) + 15) & 0xFFFFFFFFFFFFFFF0LL);
    uint64_t v43 = *__error();
    uint64_t v41 = _os_log_pack_fill(v39, v42, v43, &dword_0, "IPV6_PKTINFO: %s");
    goto LABEL_23;
  }

  if (setsockopt(v3, 41, 37, (char *)&v50 + 4, 4u) < 0)
  {
    uint64_t v36 = sub_57538();
    uint64_t v37 = _SC_syslog_os_log_mapping(3LL);
    if (__SC_log_enabled(3LL, v36, v37))
    {
      uint64_t v44 = _os_log_pack_size(12LL);
      uint64_t v39 = (char *)&v50 - ((__chkstk_darwin(v44) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v45 = *__error();
      uint64_t v41 = _os_log_pack_fill(v39, v44, v45, &dword_0, "IPV6_HOPLIMIT: %s");
      goto LABEL_23;
    }

uint64_t sub_4997C(int a1, int a2, uint64_t a3, int a4, __int128 *a5)
{
  uint64_t v10 = 0x2000000088LL;
  __int128 v11 = *a5;
  if (a3)
  {
    if (((a4 + 2) & 7LL) != 0) {
      int v7 = a4 - ((a4 + 2) & 7) + 10;
    }
    else {
      int v7 = a4 + 2;
    }
    char v12 = 2;
    char v13 = v7 / 8;
    __memmove_chk(v14, a3);
    int v8 = v7 + 24;
  }

  else
  {
    int v8 = 24;
  }

  return sub_56244(a1, a2, &unk_595E4, (uint64_t)&v10, v8, 255);
}

uint64_t sub_49A68(void *a1, int a2, int **a3)
{
  uint64_t v6 = sub_14834((uint64_t)a1);
  uint64_t v7 = sub_194C4((uint64_t)a1);
  if (a2 == 7)
  {
    uint64_t v19 = *a3;
    uint64_t v20 = a1;
LABEL_9:
    sub_4A298(v20, v19);
    return 0LL;
  }

  int v8 = (const void **)v7;
  if (a2 == 1)
  {
    uint64_t v21 = sub_57538();
    uint64_t v22 = _SC_syslog_os_log_mapping(7LL);
    int v23 = __SC_log_enabled(7LL, v21, v22);
    if (!v8)
    {
      if (v23)
      {
        uint64_t v33 = _os_log_pack_size(12LL);
        uint64_t v34 = (char *)&v47[-2] - ((__chkstk_darwin(v33) + 15) & 0xFFFFFFFFFFFFFFF0LL);
        int v35 = __error();
        uint64_t v36 = _os_log_pack_fill(v34, v33, *v35, &dword_0, "6TO4 %s: already stopped", v46);
        uint64_t v37 = nullsub_1(v6);
        *(_DWORD *)uint64_t v36 = 136315138;
        *(void *)(v36 + 4) = v37;
        uint64_t v16 = v21;
        uint64_t v17 = v22;
        uint64_t v18 = v34;
        goto LABEL_23;
      }

      return 6LL;
    }

    if (v23)
    {
      uint64_t v24 = _os_log_pack_size(12LL);
      uint64_t v25 = (char *)&v47[-2] - ((__chkstk_darwin(v24) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v26 = __error();
      uint64_t v27 = _os_log_pack_fill(v25, v24, *v26, &dword_0, "6TO4 %s: stop", v46);
      uint64_t v28 = nullsub_1(v6);
      *(_DWORD *)uint64_t v27 = 136315138;
      *(void *)(v27 + 4) = v28;
      __SC_log_send(7LL, v21, v22, v25);
    }

    sub_4A814(a1, 0LL);
    uint64_t v29 = *(unsigned int *)v8;
    if ((_DWORD)v29)
    {
      sub_4AB88(v29, (uint64_t)v47, 1);
      sub_19938((uint64_t)a1, v47, 16);
    }

    uint64_t v30 = (const __SCDynamicStore *)v8[6];
    if (v30) {
      SCDynamicStoreSetDispatchQueue(v30, 0LL);
    }
    sub_4FA18(v8 + 6);
    sub_4FA18(v8 + 5);
    sub_194CC((uint64_t)a1, 0LL);
    free(v8);
    return 0LL;
  }

  if (a2) {
    return 0LL;
  }
  if ((sub_54A84(v6) & 8) != 0) {
    return 4LL;
  }
  if (v8)
  {
    uint64_t v9 = sub_57538();
    uint64_t v10 = _SC_syslog_os_log_mapping(7LL);
    if (__SC_log_enabled(7LL, v9, v10))
    {
      uint64_t v11 = _os_log_pack_size(12LL);
      char v12 = (char *)&v47[-2] - ((__chkstk_darwin(v11) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      char v13 = __error();
      uint64_t v14 = _os_log_pack_fill(v12, v11, *v13, &dword_0, "6TO4 %s: re-entering start state", v46);
      uint64_t v15 = nullsub_1(v6);
      *(_DWORD *)uint64_t v14 = 136315138;
      *(void *)(v14 + 4) = v15;
      uint64_t v16 = v9;
      uint64_t v17 = v10;
      uint64_t v18 = v12;
LABEL_23:
      __SC_log_send(7LL, v16, v17, v18);
      return 6LL;
    }

    return 6LL;
  }

  uint64_t v38 = malloc(0x38uLL);
  if (v38)
  {
    v38[6] = 0LL;
    *((_OWORD *)v38 + 1) = 0u;
    *((_OWORD *)v38 + 2) = 0u;
    *(_OWORD *)uint64_t v38 = 0u;
    sub_194CC((uint64_t)a1, (uint64_t)v38);
    sub_49EA0((uint64_t)a1);
    sub_4A0A8(a1);
    uint64_t v20 = a1;
    uint64_t v19 = (int *)a3;
    goto LABEL_9;
  }

  uint64_t v39 = sub_57538();
  uint64_t v31 = 5LL;
  uint64_t v40 = _SC_syslog_os_log_mapping(5LL);
  if (__SC_log_enabled(5LL, v39, v40))
  {
    uint64_t v41 = _os_log_pack_size(12LL);
    uint64_t v42 = (char *)&v47[-2] - ((__chkstk_darwin(v41) + 15) & 0xFFFFFFFFFFFFFFF0LL);
    uint64_t v43 = __error();
    uint64_t v44 = _os_log_pack_fill(v42, v41, *v43, &dword_0, "6TO4 %s: malloc failed", v46);
    uint64_t v45 = nullsub_1(v6);
    *(_DWORD *)uint64_t v44 = 136315138;
    *(void *)(v44 + 4) = v45;
    uint64_t v31 = 5LL;
    __SC_log_send(5LL, v39, v40, v42);
  }

  return v31;
}

void sub_49EA0(uint64_t a1)
{
  uint64_t v1 = sub_14834(a1);
  int v2 = sub_54F6C(v1);
  sub_35A4C((uint64_t)&v20, v2);
  if (v21)
  {
    int v3 = sub_32804();
    if ((v3 & 0x80000000) == 0)
    {
      int v5 = v3;
      if (v21 >= 1)
      {
        uint64_t v6 = 0LL;
        uint64_t v7 = 0LL;
        *(void *)&__int128 v4 = 136315650LL;
        __int128 v18 = v4;
        do
        {
          uint64_t v8 = sub_57538();
          uint64_t v9 = _SC_syslog_os_log_mapping(7LL);
          if (__SC_log_enabled(7LL, v8, v9))
          {
            uint64_t v10 = _os_log_pack_size(28LL);
            uint64_t v11 = (char *)&v18 - ((__chkstk_darwin(v10) + 15) & 0xFFFFFFFFFFFFFFF0LL);
            char v12 = __error();
            uint64_t v13 = _os_log_pack_fill( v11,  v10,  *v12,  &dword_0,  "6TO4 %s: removing %s/%d",  (const char *)v18,  *((const char **)&v18 + 1),  v19);
            uint64_t v14 = nullsub_1(v1);
            uint64_t v15 = inet_ntop(30, (const void *)(v20 + v6), v22, 0x2Eu);
            int v16 = *(_DWORD *)(v20 + v6 + 16);
            *(_DWORD *)uint64_t v13 = v18;
            *(void *)(v13 + 4) = v14;
            *(_WORD *)(v13 + 12) = 2080;
            *(void *)(v13 + 14) = v15;
            *(_WORD *)(v13 + 22) = 1024;
            *(_DWORD *)(v13 + 24) = v16;
            __SC_log_send(7LL, v8, v9, v11);
          }

          uint64_t v17 = (const char *)nullsub_1(v1);
          sub_347B8(v5, v17, (_OWORD *)(v20 + v6));
          ++v7;
          v6 += 32LL;
        }

        while (v7 < v21);
      }

      close(v5);
    }

    sub_36090((uint64_t)&v20);
  }

void sub_4A0A8(void *a1)
{
  context.version = 0LL;
  memset(&context.retain, 0, 24);
  uint64_t v2 = sub_194C4((uint64_t)a1);
  context.info = a1;
  *(void *)(v2 + 48) = SCDynamicStoreCreate( 0LL,  @"IPConfiguration:STF",  (SCDynamicStoreCallBack)sub_4ABAC,  &context);
  values = (void *)SCDynamicStoreKeyCreateNetworkGlobalEntity(0LL, kSCDynamicStoreDomainState, kSCEntNetIPv4);
  int v3 = CFArrayCreate(0LL, (const void **)&values, 1LL, &kCFTypeArrayCallBacks);
  SCDynamicStoreSetNotificationKeys(*(SCDynamicStoreRef *)(v2 + 48), v3, 0LL);
  CFRelease(v3);
  __int128 v4 = *(const __SCDynamicStore **)(v2 + 48);
  int v5 = sub_2A814();
  if (!SCDynamicStoreSetDispatchQueue(v4, v5))
  {
    uint64_t v6 = sub_57538();
    uint64_t v7 = _SC_syslog_os_log_mapping(5LL);
    if (__SC_log_enabled(5LL, v6, v7))
    {
      uint64_t v8 = _os_log_pack_size(12LL);
      uint64_t v9 = (char *)&v12 - ((__chkstk_darwin(v8) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v10 = __error();
      uint64_t v11 = _os_log_pack_fill(v9, v8, *v10, &dword_0, "%s: SCDynamicStoreSetDispatchQueue failed", v12);
      *(_DWORD *)uint64_t v11 = 136315138;
      *(void *)(v11 + 4) = "stf_configure_address";
      __SC_log_send(5LL, v6, v7, v9);
    }
  }

  uint64_t v15 = sub_4AC28(*(const __SCDynamicStore **)(v2 + 48), values);
  sub_4ACF0((uint64_t)a1, v15, values);
  CFRelease(values);
  sub_4FA18((const void **)&v15);
}

void sub_4A298(void *a1, int *a2)
{
  uint64_t v4 = sub_194C4((uint64_t)a1);
  uint64_t v5 = sub_14834((uint64_t)a1);
  if (a2)
  {
    int v6 = *a2;
    switch(*a2)
    {
      case 0:
        goto LABEL_3;
      case 1:
        sub_4AB88(a2[2], (uint64_t)v60, 0);
        sub_4A814(a1, 0LL);
        uint64_t v17 = *(void *)(v4 + 4);
        uint64_t v7 = v4 + 4;
        if (*(void *)v60 == v17 && *(void *)&v60[8] == *(void *)(v7 + 8)) {
          return;
        }
        uint64_t v19 = sub_57538();
        uint64_t v20 = _SC_syslog_os_log_mapping(6LL);
        if (__SC_log_enabled(6LL, v19, v20))
        {
          uint64_t v21 = _os_log_pack_size(36LL);
          uint64_t v22 = &v60[-((__chkstk_darwin(v21) + 15) & 0xFFFFFFFFFFFFFFF0LL) - 8];
          int v23 = __error();
          uint64_t v24 = _os_log_pack_fill( v22,  v21,  *v23,  &dword_0,  "6TO4 %s: specified IPv4 relay %d.%d.%d.%d",  v59,  *(_DWORD *)v60,  *(_DWORD *)&v60[8],  v61,  v62);
          uint64_t v25 = nullsub_1(v5);
          int v26 = *((unsigned __int8 *)a2 + 8);
          int v27 = *((unsigned __int8 *)a2 + 9);
          int v28 = *((unsigned __int8 *)a2 + 10);
          int v29 = *((unsigned __int8 *)a2 + 11);
          *(_DWORD *)uint64_t v24 = 136316162;
          *(void *)(v24 + 4) = v25;
          *(_WORD *)(v24 + 12) = 1024;
          *(_DWORD *)(v24 + 14) = v26;
          *(_WORD *)(v24 + 18) = 1024;
          *(_DWORD *)(v24 + 20) = v27;
          *(_WORD *)(v24 + 24) = 1024;
          *(_DWORD *)(v24 + 26) = v28;
          *(_WORD *)(v24 + 30) = 1024;
          *(_DWORD *)(v24 + 32) = v29;
          __SC_log_send(6LL, v19, v20, v22);
        }

        __int128 v16 = *(_OWORD *)v60;
        break;
      case 2:
        sub_4A814(a1, 0LL);
        uint64_t v30 = *((void *)a2 + 1);
        uint64_t v31 = *((void *)a2 + 2);
        uint64_t v32 = a2 + 2;
        uint64_t v33 = *(void *)(v4 + 4);
        uint64_t v7 = v4 + 4;
        if (v30 == v33 && v31 == *(void *)(v7 + 8)) {
          return;
        }
        uint64_t v35 = sub_57538();
        uint64_t v36 = _SC_syslog_os_log_mapping(6LL);
        if (__SC_log_enabled(6LL, v35, v36))
        {
          uint64_t v37 = _os_log_pack_size(22LL);
          uint64_t v38 = &v60[-((__chkstk_darwin(v37) + 15) & 0xFFFFFFFFFFFFFFF0LL) - 8];
          uint64_t v39 = __error();
          uint64_t v40 = _os_log_pack_fill( v38,  v37,  *v39,  &dword_0,  "6TO4 %s: specified IPv6 relay %s",  v59,  *(const char **)v60);
          uint64_t v41 = nullsub_1(v5);
          uint64_t v42 = inet_ntop(30, v32, v60, 0x2Eu);
          *(_DWORD *)uint64_t v40 = 136315394;
          *(void *)(v40 + 4) = v41;
          *(_WORD *)(v40 + 12) = 2080;
          *(void *)(v40 + 14) = v42;
          __SC_log_send(6LL, v35, v36, v38);
        }

        __int128 v16 = *v32;
        break;
      case 3:
        uint64_t v43 = *(const char **)(v4 + 24);
        if (!v43 || strcmp(v43, *((const char **)a2 + 1)))
        {
          uint64_t v44 = sub_57538();
          uint64_t v45 = _SC_syslog_os_log_mapping(6LL);
          if (__SC_log_enabled(6LL, v44, v45))
          {
            uint64_t v46 = _os_log_pack_size(22LL);
            int v47 = &v60[-((__chkstk_darwin(v46) + 15) & 0xFFFFFFFFFFFFFFF0LL) - 8];
            uint64_t v48 = __error();
            uint64_t v49 = _os_log_pack_fill( v47,  v46,  *v48,  &dword_0,  "6TO4 %s: specified DNS relay %s",  v59,  *(const char **)v60);
            uint64_t v50 = nullsub_1(v5);
            uint64_t v51 = *((void *)a2 + 1);
            *(_DWORD *)uint64_t v49 = 136315394;
            *(void *)(v49 + 4) = v50;
            *(_WORD *)(v49 + 12) = 2080;
            *(void *)(v49 + 14) = v51;
            __SC_log_send(6LL, v44, v45, v47);
          }

          sub_4A814(a1, *((const char **)a2 + 1));
        }

        return;
      default:
        uint64_t v52 = sub_57538();
        uint64_t v53 = _SC_syslog_os_log_mapping(5LL);
        if (__SC_log_enabled(5LL, v52, v53))
        {
          uint64_t v54 = _os_log_pack_size(18LL);
          uint64_t v55 = &v60[-((__chkstk_darwin(v54) + 15) & 0xFFFFFFFFFFFFFFF0LL) - 8];
          int v56 = __error();
          uint64_t v57 = _os_log_pack_fill( v55,  v54,  *v56,  &dword_0,  "6TO4 %s: specified unknown relay type %d",  v59,  *(_DWORD *)v60);
          uint64_t v58 = nullsub_1(v5);
          *(_DWORD *)uint64_t v57 = 136315394;
          *(void *)(v57 + 4) = v58;
          *(_WORD *)(v57 + 12) = 1024;
          *(_DWORD *)(v57 + 14) = v6;
          __SC_log_send(5LL, v52, v53, v55);
        }

        return;
    }
  }

  else
  {
LABEL_3:
    sub_4A814(a1, 0LL);
    uint64_t v8 = *(void *)(v4 + 4);
    uint64_t v7 = v4 + 4;
    if (!(v8 ^ 0x16358C00220LL | *(void *)(v7 + 8))) {
      return;
    }
    uint64_t v9 = sub_57538();
    uint64_t v10 = _SC_syslog_os_log_mapping(6LL);
    if (__SC_log_enabled(6LL, v9, v10))
    {
      uint64_t v11 = _os_log_pack_size(12LL);
      char v12 = &v60[-((__chkstk_darwin(v11) + 15) & 0xFFFFFFFFFFFFFFF0LL) - 8];
      uint64_t v13 = __error();
      uint64_t v14 = _os_log_pack_fill(v12, v11, *v13, &dword_0, "6TO4 %s: using default anycast relay", v59);
      uint64_t v15 = nullsub_1(v5);
      *(_DWORD *)uint64_t v14 = 136315138;
      *(void *)(v14 + 4) = v15;
      __SC_log_send(6LL, v9, v10, v12);
    }

    __int128 v16 = xmmword_5960C;
  }

  *(_OWORD *)uint64_t v7 = v16;
  sub_4B1F0((uint64_t)a1);
}

void sub_4A814(void *a1, const char *a2)
{
  uint64_t v4 = sub_14834((uint64_t)a1);
  uint64_t v5 = sub_194C4((uint64_t)a1);
  int v6 = *(void **)(v5 + 24);
  if (v6)
  {
    free(v6);
    *(void *)(v5 + 24) = 0LL;
  }

  uint64_t v8 = (const __SCNetworkReachability **)(v5 + 32);
  uint64_t v7 = *(const __SCNetworkReachability **)(v5 + 32);
  if (v7)
  {
    SCNetworkReachabilitySetDispatchQueue(v7, 0LL);
    sub_4FA18((const void **)(v5 + 32));
  }

  if (a2)
  {
    uint64_t v9 = SCNetworkReachabilityCreateWithName(0LL, a2);
    int *v8 = v9;
    if (v9)
    {
      context.info = a1;
      if (!SCNetworkReachabilitySetCallback(v9, (SCNetworkReachabilityCallBack)sub_4B2CC, &context))
      {
        uint64_t v10 = sub_57538();
        uint64_t v11 = _SC_syslog_os_log_mapping(5LL);
        if (__SC_log_enabled(5LL, v10, v11))
        {
          uint64_t v12 = _os_log_pack_size(22LL);
          uint64_t v13 = (char *)&context - ((__chkstk_darwin(v12) + 15) & 0xFFFFFFFFFFFFFFF0LL);
          uint64_t v14 = __error();
          uint64_t v15 = _os_log_pack_fill( v13,  v12,  *v14,  &dword_0,  "6TO4 %s: SCNetworkReachabilitySetCallback failed, %s",  (const char *)context.version,  (const char *)context.info);
          uint64_t v16 = nullsub_1(v4);
          int v17 = SCError();
          __int128 v18 = SCErrorString(v17);
          *(_DWORD *)uint64_t v15 = 136315394;
          *(void *)(v15 + 4) = v16;
          *(_WORD *)(v15 + 12) = 2080;
          *(void *)(v15 + 14) = v18;
          __SC_log_send(5LL, v10, v11, v13);
        }

        sub_4FA18((const void **)(v5 + 32));
      }

      uint64_t v19 = *v8;
      uint64_t v20 = sub_2A814();
      SCNetworkReachabilitySetDispatchQueue(v19, v20);
      uint64_t v21 = sub_57538();
      uint64_t v22 = _SC_syslog_os_log_mapping(6LL);
      if (__SC_log_enabled(6LL, v21, v22))
      {
        uint64_t v23 = _os_log_pack_size(22LL);
        uint64_t v24 = (char *)&context - ((__chkstk_darwin(v23) + 15) & 0xFFFFFFFFFFFFFFF0LL);
        uint64_t v25 = __error();
        uint64_t v26 = _os_log_pack_fill( v24,  v23,  *v25,  &dword_0,  "6TO4 %s: resolving %s",  (const char *)context.version,  (const char *)context.info);
        uint64_t v27 = nullsub_1(v4);
        *(_DWORD *)uint64_t v26 = 136315394;
        *(void *)(v26 + 4) = v27;
        *(_WORD *)(v26 + 12) = 2080;
        *(void *)(v26 + 14) = a2;
        __SC_log_send(6LL, v21, v22, v24);
      }

      *(void *)(v5 + 24) = strdup(a2);
    }

    else
    {
      uint64_t v28 = sub_57538();
      uint64_t v29 = _SC_syslog_os_log_mapping(5LL);
      if (__SC_log_enabled(5LL, v28, v29))
      {
        uint64_t v30 = _os_log_pack_size(22LL);
        uint64_t v31 = (char *)&context - ((__chkstk_darwin(v30) + 15) & 0xFFFFFFFFFFFFFFF0LL);
        uint64_t v32 = __error();
        uint64_t v33 = _os_log_pack_fill( v31,  v30,  *v32,  &dword_0,  "6TO4 %s:SCNetworkReachabilityCreateWithName failed, %s",  (const char *)context.version,  (const char *)context.info);
        uint64_t v34 = nullsub_1(v4);
        int v35 = SCError();
        uint64_t v36 = SCErrorString(v35);
        *(_DWORD *)uint64_t v33 = 136315394;
        *(void *)(v33 + 4) = v34;
        *(_WORD *)(v33 + 12) = 2080;
        *(void *)(v33 + 14) = v36;
        __SC_log_send(5LL, v28, v29, v31);
      }
    }
  }

uint64_t sub_4AB88(uint64_t result, uint64_t a2, int a3)
{
  *(void *)a2 = 0LL;
  *(void *)(a2 + 8) = 0LL;
  *(_WORD *)a2 = 544;
  *(_DWORD *)(a2 + 2) = result;
  if (a3)
  {
    *(_BYTE *)(a2 + 7) = 1;
    *(_BYTE *)(a2 + 15) = 1;
  }

  return result;
}

void sub_4ABAC(const __SCDynamicStore *a1, CFArrayRef theArray, uint64_t a3)
{
  if (theArray)
  {
    if (CFArrayGetCount(theArray))
    {
      ValueAtIndex = (void *)CFArrayGetValueAtIndex(theArray, 0LL);
      uint64_t v7 = sub_4AC28(a1, ValueAtIndex);
      sub_4ACF0(a3, v7, ValueAtIndex);
      sub_4FA18((const void **)&v7);
    }
  }

CFDictionaryRef sub_4AC28(const __SCDynamicStore *a1, void *a2)
{
  values = a2;
  int v3 = CFArrayCreate(0LL, (const void **)&values, 1LL, &kCFTypeArrayCallBacks);
  CFTypeRef cf = SCDynamicStoreKeyCreateNetworkServiceEntity(0LL, kSCDynamicStoreDomainState, kSCCompAnyRegex, kSCEntNetIPv4);
  uint64_t v4 = CFArrayCreate(0LL, &cf, 1LL, &kCFTypeArrayCallBacks);
  CFRelease(cf);
  CFDictionaryRef v5 = SCDynamicStoreCopyMultiple(a1, v3, v4);
  CFRelease(v3);
  CFRelease(v4);
  return v5;
}

void sub_4ACF0(uint64_t a1, const __CFDictionary *a2, const void *a3)
{
  uint64_t v44 = 0LL;
  int v6 = (unsigned int *)sub_194C4(a1);
  if (!a2
    || (Value = CFDictionaryGetValue(a2, a3), CFTypeID TypeID = CFDictionaryGetTypeID(), !Value)
    || CFGetTypeID(Value) != TypeID)
  {
    CFStringGetTypeID();
    goto LABEL_24;
  }

  uint64_t v9 = (const __CFString *)CFDictionaryGetValue((CFDictionaryRef)Value, kSCDynamicStorePropNetPrimaryService);
  CFTypeID v10 = CFStringGetTypeID();
  if (!v9 || CFGetTypeID(v9) != v10) {
    goto LABEL_24;
  }
  CFStringRef NetworkServiceEntity = SCDynamicStoreKeyCreateNetworkServiceEntity(0LL, kSCDynamicStoreDomainState, v9, kSCEntNetIPv4);
  uint64_t v12 = CFDictionaryGetValue(a2, NetworkServiceEntity);
  CFTypeID v13 = CFDictionaryGetTypeID();
  if (!v12 || CFGetTypeID(v12) != v13)
  {
    CFRelease(NetworkServiceEntity);
    goto LABEL_24;
  }

  CFRelease(NetworkServiceEntity);
  uint64_t v14 = CFDictionaryGetValue((CFDictionaryRef)v12, @"NetworkSignature");
  CFTypeID v15 = CFStringGetTypeID();
  if (v14 && CFGetTypeID(v14) != v15) {
    uint64_t v14 = 0LL;
  }
  uint64_t v16 = CFDictionaryGetValue((CFDictionaryRef)v12, kSCPropNetIPv4Addresses);
  CFTypeID v17 = CFArrayGetTypeID();
  if (!v16) {
    goto LABEL_25;
  }
  if (CFGetTypeID(v16) != v17 || CFArrayGetCount((CFArrayRef)v16) < 1)
  {
LABEL_24:
    uint64_t v16 = 0LL;
LABEL_25:
    in_addr_t s_addr = 0;
    goto LABEL_26;
  }

  ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex((CFArrayRef)v16, 0LL);
  in_addr_t s_addr = 0;
  uint64_t v16 = 0LL;
  if (sub_4FCC8(ValueAtIndex, v43))
  {
    if (v43[0].s_addr)
    {
      if (LOWORD(v43[0].s_addr) != 65193)
      {
        in_addr_t s_addr = 0;
        uint64_t v16 = 0LL;
        unsigned int v20 = bswap32(v43[0].s_addr);
        if (HIWORD(v20) != 49320 && (v20 & 0xFF000000) != 0xA000000 && (v20 & 0xFFF00000) != 0xAC100000)
        {
          if (v14)
          {
            uint64_t v16 = CFRetain(v14);
            uint64_t v44 = v16;
          }

          else
          {
            uint64_t v16 = 0LL;
          }

          in_addr_t s_addr = v43[0].s_addr;
        }
      }
    }
  }

void sub_4B1F0(uint64_t a1)
{
  CFStringRef v7 = 0LL;
  uint64_t v2 = sub_194C4(a1);
  int v3 = (unsigned int *)v2;
  uint64_t v4 = (void *)(v2 + 4);
  if (*(_DWORD *)(v2 + 4) || *(_DWORD *)(v2 + 8) || *(_DWORD *)(v2 + 12) || *(_DWORD *)(v2 + 16))
  {
    unsigned int v5 = *(_DWORD *)v2;
    if (*(_DWORD *)v2)
    {
      if (*(void *)(v2 + 40))
      {
        CFStringRef v6 = CFStringCreateWithFormat(0LL, 0LL, @"IPv6.6to4=(%@)", *(void *)(v2 + 40), v7);
        CFStringRef v7 = v6;
        unsigned int v5 = *v3;
      }

      else
      {
        CFStringRef v6 = 0LL;
      }

      sub_4AB88(v5, (uint64_t)v8, 1);
      uint64_t v9 = 16LL;
      sub_16BA4(a1, v8, 1, v4, 1LL, 0LL, v6);
      sub_4FA18((const void **)&v7);
    }
  }

void sub_4B2CC(uint64_t a1, char a2, uint64_t a3)
{
  uint64_t v5 = sub_194C4(a3);
  uint64_t v6 = sub_14834(a3);
  if ((a2 & 6) == 2)
  {
    CFStringRef v7 = (const __CFArray *)SCNetworkReachabilityCopyResolvedAddress(*(void *)(v5 + 32), v42);
    if (v7)
    {
      uint64_t v8 = v7;
      CFIndex Count = CFArrayGetCount(v7);
      if (Count >= 1)
      {
        CFIndex v10 = Count;
        CFIndex v11 = 0LL;
        while (1)
        {
          ValueAtIndex = (const __CFData *)CFArrayGetValueAtIndex(v8, v11);
          BytePtr = CFDataGetBytePtr(ValueAtIndex);
          if (BytePtr[1] == 2)
          {
            uint64_t v14 = (unsigned __int8 *)BytePtr;
            if (*((_DWORD *)BytePtr + 1)) {
              break;
            }
          }

          if (v10 == ++v11) {
            goto LABEL_18;
          }
        }

        uint64_t v23 = sub_57538();
        uint64_t v24 = _SC_syslog_os_log_mapping(6LL);
        if (__SC_log_enabled(6LL, v23, v24))
        {
          uint64_t v25 = _os_log_pack_size(46LL);
          int v39 = (const char *)&v38;
          uint64_t v26 = (char *)&v38 - ((__chkstk_darwin(v25) + 15) & 0xFFFFFFFFFFFFFFF0LL);
          uint64_t v27 = __error();
          uint64_t v28 = _os_log_pack_fill( v26,  v25,  *v27,  &dword_0,  "6TO4 %s: resolved %s to %d.%d.%d.%d",  v38,  v39,  v40,  DWORD1(v41),  HIDWORD(v41),  v43);
          uint64_t v29 = nullsub_1(v6);
          uint64_t v30 = *(void *)(v5 + 24);
          int v31 = v14[4];
          int v32 = v14[5];
          int v33 = v14[6];
          int v34 = v14[7];
          *(_DWORD *)uint64_t v28 = 136316418;
          *(void *)(v28 + 4) = v29;
          *(_WORD *)(v28 + 12) = 2080;
          *(void *)(v28 + 14) = v30;
          *(_WORD *)(v28 + 22) = 1024;
          *(_DWORD *)(v28 + 24) = v31;
          *(_WORD *)(v28 + 28) = 1024;
          *(_DWORD *)(v28 + 30) = v32;
          *(_WORD *)(v28 + 34) = 1024;
          *(_DWORD *)(v28 + 36) = v33;
          *(_WORD *)(v28 + 40) = 1024;
          *(_DWORD *)(v28 + 42) = v34;
          __SC_log_send(6LL, v23, v24, v26);
        }

        SCNetworkReachabilitySetDispatchQueue(*(SCNetworkReachabilityRef *)(v5 + 32), 0LL);
        sub_4FA18((const void **)(v5 + 32));
        sub_4AB88(*((unsigned int *)v14 + 1), (uint64_t)&v41, 0);
        uint64_t v36 = *(void *)(v5 + 4);
        uint64_t v35 = v5 + 4;
        if (v36 != (void)v41 || *(void *)(v35 + 8) != *((void *)&v41 + 1))
        {
          *(_OWORD *)uint64_t v35 = v41;
          sub_4B1F0(a3);
        }
      }

uint64_t sub_4B5E8()
{
  return qword_6C298;
}

uint64_t sub_4B5F4(unsigned int a1)
{
  if (!qword_6C298 && !sub_4B768(a1))
  {
    if (a1 == 4)
    {
      v12.tv_sec = 0LL;
      v12.tv_nsec = 0LL;
      int v2 = gethostuuid(v13, &v12);
      int v3 = 0LL;
      if (!v2) {
        int v3 = sub_56C44(v13);
      }
    }

    else
    {
      int v3 = sub_4BA68(a1);
    }

    qword_6C298 = (uint64_t)v3;
    if (v3)
    {
      sub_4BC70(v3);
      sub_4BDC8();
    }

    else
    {
      uint64_t v4 = sub_57538();
      uint64_t v5 = _SC_syslog_os_log_mapping(3LL);
      if (__SC_log_enabled(3LL, v4, v5))
      {
        uint64_t v6 = _os_log_pack_size(12LL);
        CFStringRef v7 = (char *)&v11 - ((__chkstk_darwin(v6) + 15) & 0xFFFFFFFFFFFFFFF0LL);
        uint64_t v8 = __error();
        uint64_t v9 = _os_log_pack_fill(v7, v6, *v8, &dword_0, "%s: failed to establish DUID\n", v11);
        *(_DWORD *)uint64_t v9 = 136315138;
        *(void *)(v9 + 4) = "DHCPDUIDEstablishAndGet";
        __SC_log_send(3LL, v4, v5, v7);
      }
    }
  }

  return qword_6C298;
}

BOOL sub_4B768(unsigned int a1)
{
  int v2 = (const char *)sub_4FA48("/var/db/dhcpclient/DUID_IA.plist");
  uint64_t v27 = v2;
  CFTypeID TypeID = CFDictionaryGetTypeID();
  if (v2 && CFGetTypeID(v2) == TypeID)
  {
    int Value = CFDictionaryGetValue((CFDictionaryRef)v2, @"HostUUID");
    CFTypeID v5 = CFDataGetTypeID();
    if (Value)
    {
      if (CFGetTypeID(Value) == v5 && CFDataGetLength((CFDataRef)Value) == 16)
      {
        uint64_t v6 = (const void *)sub_36C04();
        if (v6)
        {
          if (!CFEqual(Value, v6))
          {
            syslog(5, "DHCPDUID: ignoring DUID - host UUID doesn't match", v27);
            goto LABEL_23;
          }
        }
      }
    }

    CFStringRef v7 = (const __CFData *)CFDictionaryGetValue((CFDictionaryRef)v2, @"DUID");
    CFTypeID v8 = CFDataGetTypeID();
    if (v7)
    {
      if (CFGetTypeID(v7) == v8)
      {
        unsigned int v9 = sub_4C08C(v7);
        if (v9 == a1)
        {
          CFIndex v10 = CFDictionaryGetValue((CFDictionaryRef)v2, @"IAIDList");
          CFTypeID v11 = CFArrayGetTypeID();
          if (!v10 || CFGetTypeID(v10) != v11)
          {
LABEL_21:
            qword_6C298 = (uint64_t)CFRetain(v7);
            goto LABEL_23;
          }

          CFIndex Count = CFArrayGetCount((CFArrayRef)v10);
          if (Count >= 1)
          {
            CFIndex v13 = Count;
            CFIndex v14 = 0LL;
            do
            {
              ValueAtIndex = CFArrayGetValueAtIndex((CFArrayRef)v10, v14);
              CFTypeID v16 = CFStringGetTypeID();
              if (!ValueAtIndex || CFGetTypeID(ValueAtIndex) != v16) {
                goto LABEL_21;
              }
            }

            while (v13 != ++v14);
          }

          qword_6C298 = (uint64_t)CFRetain(v7);
          qword_6C2A0 = (uint64_t)CFArrayCreateMutableCopy(0LL, 0LL, (CFArrayRef)v10);
        }

        else
        {
          unsigned int v17 = v9;
          uint64_t v18 = sub_57538();
          uint64_t v19 = _SC_syslog_os_log_mapping(5LL);
          if (__SC_log_enabled(5LL, v18, v19))
          {
            uint64_t v20 = _os_log_pack_size(34LL);
            uint64_t v21 = (char *)&v27 - ((__chkstk_darwin(v20) + 15) & 0xFFFFFFFFFFFFFFF0LL);
            uint64_t v22 = __error();
            uint64_t v23 = _os_log_pack_fill( v21,  v20,  *v22,  &dword_0,  "Discarding existing DUID with type %s (%d), need type %s (%d)",  v27,  v28,  v29,  v30);
            uint64_t v24 = sub_567E8(v17);
            uint64_t v25 = sub_567E8(a1);
            *(_DWORD *)uint64_t v23 = 136315906;
            *(void *)(v23 + 4) = v24;
            *(_WORD *)(v23 + 12) = 1024;
            *(_DWORD *)(v23 + 14) = v17;
            *(_WORD *)(v23 + 18) = 2080;
            *(void *)(v23 + 20) = v25;
            *(_WORD *)(v23 + 28) = 1024;
            *(_DWORD *)(v23 + 30) = a1;
            __SC_log_send(5LL, v18, v19, v21);
          }
        }
      }
    }
  }

__CFData *sub_4BA68(int a1)
{
  uint64_t result = (__CFData *)get_interface_list();
  if (result)
  {
    uint64_t v3 = sub_5413C((uint64_t)result);
    uint64_t v4 = sub_57538();
    uint64_t v5 = _SC_syslog_os_log_mapping(5LL);
    int v6 = __SC_log_enabled(5LL, v4, v5);
    if (v3)
    {
      if (v6)
      {
        uint64_t v7 = _os_log_pack_size(12LL);
        CFTypeID v8 = (char *)&v19 - ((__chkstk_darwin(v7) + 15) & 0xFFFFFFFFFFFFFFF0LL);
        unsigned int v9 = __error();
        uint64_t v10 = _os_log_pack_fill(v8, v7, *v9, &dword_0, "DHCPDUID: chose %s for DUID", v19);
        uint64_t v11 = nullsub_1(v3);
        *(_DWORD *)uint64_t v10 = 136315138;
        *(void *)(v10 + 4) = v11;
        __SC_log_send(5LL, v4, v5, v8);
      }

      if (a1 == 3)
      {
        return sub_4BF9C(v3);
      }

      else
      {
        CFTypeID v16 = (const void *)sub_54E44(v3);
        int v17 = sub_54230(v3);
        unsigned int v18 = sub_54E28(v3);
        return sub_56B74(v16, v17, v18);
      }
    }

    else
    {
      if (v6)
      {
        uint64_t v12 = _os_log_pack_size(12LL);
        CFIndex v13 = (char *)&v19 - ((__chkstk_darwin(v12) + 15) & 0xFFFFFFFFFFFFFFF0LL);
        CFIndex v14 = __error();
        uint64_t v15 = _os_log_pack_fill(v13, v12, *v14, &dword_0, "%s: can't find suitable interface", v19);
        *(_DWORD *)uint64_t v15 = 136315138;
        *(void *)(v15 + 4) = "make_DUID_data";
        __SC_log_send(5LL, v4, v5, v13);
      }

      return 0LL;
    }
  }

  return result;
}

void sub_4BC70(const __CFData *a1)
{
  CFMutableStringRef Mutable = CFStringCreateMutable(0LL, 0LL);
  BytePtr = (unsigned __int16 *)CFDataGetBytePtr(a1);
  CFIndex Length = CFDataGetLength(a1);
  sub_5680C(Mutable, BytePtr, Length);
  uint64_t v5 = sub_57538();
  uint64_t v6 = _SC_syslog_os_log_mapping(5LL);
  if (__SC_log_enabled(5LL, v5, v6))
  {
    uint64_t v7 = _os_log_pack_size(22LL);
    CFTypeID v8 = (char *)&v11 - ((__chkstk_darwin(v7) + 15) & 0xFFFFFFFFFFFFFFF0LL);
    unsigned int v9 = __error();
    uint64_t v10 = _os_log_pack_fill(v8, v7, *v9, &dword_0, "%s %@");
    *(_DWORD *)uint64_t v10 = 136315394;
    *(void *)(v10 + 4) = "Established";
    *(_WORD *)(v10 + 12) = 2112;
    *(void *)(v10 + 14) = Mutable;
    __SC_log_send(5LL, v5, v6, v8);
  }

  CFRelease(Mutable);
}

void sub_4BDC8()
{
  if (qword_6C298)
  {
    CFMutableStringRef Mutable = CFDictionaryCreateMutable(0LL, 0LL, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    CFDictionarySetValue(Mutable, @"DUID", (const void *)qword_6C298);
    if (qword_6C2A0) {
      CFDictionarySetValue(Mutable, @"IAIDList", (const void *)qword_6C2A0);
    }
    uint64_t v1 = (const void *)sub_36C04();
    if (v1) {
      CFDictionarySetValue(Mutable, @"HostUUID", v1);
    }
    if ((sub_4FB24(Mutable, "/var/db/dhcpclient/DUID_IA.plist", 0x1A4u) & 0x80000000) != 0 && *__error() != 2)
    {
      uint64_t v2 = sub_57538();
      uint64_t v3 = _SC_syslog_os_log_mapping(5LL);
      if (__SC_log_enabled(5LL, v2, v3))
      {
        uint64_t v4 = _os_log_pack_size(22LL);
        uint64_t v5 = (char *)v10 - ((__chkstk_darwin(v4) + 15) & 0xFFFFFFFFFFFFFFF0LL);
        uint64_t v6 = __error();
        uint64_t v7 = _os_log_pack_fill(v5, v4, *v6, &dword_0, "DHCPDUID: failed to write %s, %s", v10[0], v10[1]);
        CFTypeID v8 = __error();
        unsigned int v9 = strerror(*v8);
        *(_DWORD *)uint64_t v7 = 136315394;
        *(void *)(v7 + 4) = "/var/db/dhcpclient/DUID_IA.plist";
        *(_WORD *)(v7 + 12) = 2080;
        *(void *)(v7 + 14) = v9;
        __SC_log_send(5LL, v2, v3, v5);
      }
    }

    CFRelease(Mutable);
  }

__CFData *sub_4BF9C(uint64_t a1)
{
  uint64_t v2 = (const void *)sub_54E44(a1);
  int v3 = sub_54230(a1);
  unsigned int v4 = sub_54E28(a1);
  return sub_56AF0(v2, v3, v4);
}

CFIndex sub_4BFE8(char *cStr)
{
  CFStringRef v1 = CFStringCreateWithCString(0LL, cStr, 0x600u);
  if (!qword_6C2A0)
  {
    CFMutableStringRef Mutable = CFArrayCreateMutable(0LL, 0LL, &kCFTypeArrayCallBacks);
    CFIndex Count = 0LL;
    qword_6C2A0 = (uint64_t)Mutable;
LABEL_6:
    CFArrayAppendValue(Mutable, v1);
    sub_4BDC8();
    goto LABEL_7;
  }

  CFIndex Count = CFArrayGetCount((CFArrayRef)qword_6C2A0);
  v6.location = 0LL;
  v6.length = Count;
  FirstIndexOfint Value = CFArrayGetFirstIndexOfValue((CFArrayRef)qword_6C2A0, v6, v1);
  if (FirstIndexOfValue == -1)
  {
    CFMutableStringRef Mutable = (__CFArray *)qword_6C2A0;
    goto LABEL_6;
  }

  CFIndex Count = FirstIndexOfValue;
LABEL_7:
  CFRelease(v1);
  return Count;
}

uint64_t sub_4C08C(const __CFData *a1)
{
  BytePtr = (unsigned __int16 *)CFDataGetBytePtr(a1);
  int Length = CFDataGetLength(a1);
  if (sub_56AA8(BytePtr, Length)) {
    return bswap32(*BytePtr) >> 16;
  }
  uint64_t v5 = sub_57538();
  uint64_t v6 = _SC_syslog_os_log_mapping(5LL);
  uint64_t result = __SC_log_enabled(5LL, v5, v6);
  if ((_DWORD)result)
  {
    uint64_t v7 = _os_log_pack_size(2LL);
    CFTypeID v8 = (char *)&v10 - ((__chkstk_darwin(v7) + 15) & 0xFFFFFFFFFFFFFFF0LL);
    unsigned int v9 = __error();
    *(_WORD *)_os_log_pack_fill(v8, v7, *v9, &dword_0, "DUID is invalid") = 0;
    __SC_log_send(5LL, v5, v6, v8);
    return 0LL;
  }

  return result;
}

uint64_t sub_4C1BC()
{
  return 0LL;
}

uint64_t *sub_4C244(uint64_t a1)
{
  uint64_t v2 = qword_6C2A8;
  if (!qword_6C2A8)
  {
    int v3 = malloc(0x38uLL);
    if (!v3)
    {
      qword_6C2A8 = 0LL;
      uint64_t v14 = sub_57538();
      uint64_t v15 = _SC_syslog_os_log_mapping(5LL);
      if (__SC_log_enabled(5LL, v14, v15))
      {
        uint64_t v16 = _os_log_pack_size(2LL);
        int v17 = (char *)&v20 - ((__chkstk_darwin(v16) + 15) & 0xFFFFFFFFFFFFFFF0LL);
        unsigned int v18 = __error();
        *(_WORD *)_os_log_pack_fill( v17,  v16,  *v18,  &dword_0,  "RTADVSocketCreate: could not allocate globals") = 0;
        __SC_log_send(5LL, v14, v15, v17);
      }

      return 0LL;
    }

    uint64_t v2 = (uint64_t)v3;
    v3[6] = 0LL;
    *((_OWORD *)v3 + 1) = 0u;
    *((_OWORD *)v3 + 2) = 0u;
    *(_OWORD *)int v3 = 0u;
    sub_53D14(v3, (uint64_t)sub_4C67C, 0LL);
    *(void *)(v2 + 48) = timer_callout_init("RTADVSocket");
    qword_6C2A8 = v2;
  }

  int v4 = sub_54F6C(a1);
  if (sub_4C4A8(v4))
  {
    uint64_t v5 = sub_57538();
    uint64_t v6 = _SC_syslog_os_log_mapping(5LL);
    if (__SC_log_enabled(5LL, v5, v6))
    {
      uint64_t v7 = _os_log_pack_size(12LL);
      CFTypeID v8 = (char *)&v20 - ((__chkstk_darwin(v7) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      unsigned int v9 = __error();
      uint64_t v10 = _os_log_pack_fill( v8,  v7,  *v9,  &dword_0,  "RTADVSocketCreate(%s): socket already allocated",  v20);
      uint64_t v11 = nullsub_1(a1);
      *(_DWORD *)uint64_t v10 = 136315138;
      *(void *)(v10 + 4) = v11;
      __SC_log_send(5LL, v5, v6, v8);
    }

    return 0LL;
  }

  uint64_t v12 = (uint64_t *)malloc(0x38uLL);
  CFIndex v13 = v12;
  if (v12)
  {
    v12[6] = 0LL;
    *((_OWORD *)v12 + 1) = 0u;
    *((_OWORD *)v12 + 2) = 0u;
    *(_OWORD *)uint64_t v12 = 0u;
    if (!sub_53DA4(v2, v12))
    {
      free(v13);
      return 0LL;
    }

    *CFIndex v13 = a1;
  }

  return v13;
}

uint64_t *sub_4C4A8(int a1)
{
  uint64_t v2 = 0LL;
  while (1)
  {
    int v3 = (uint64_t *)sub_50C98(qword_6C2A8, v2);
    uint64_t v2 = (v2 + 1);
  }

  return v3;
}

void sub_4C520(void **a1)
{
  CFStringRef v1 = *a1;
  if (*a1)
  {
    unsigned int v3 = sub_53E84((uint64_t *)qword_6C2A8, (uint64_t)v1);
    if (v3 == -1)
    {
      uint64_t v4 = sub_57538();
      uint64_t v5 = _SC_syslog_os_log_mapping(5LL);
      if (__SC_log_enabled(5LL, v4, v5))
      {
        uint64_t v6 = _os_log_pack_size(12LL);
        uint64_t v7 = (char *)&v11 - ((__chkstk_darwin(v6) + 15) & 0xFFFFFFFFFFFFFFF0LL);
        CFTypeID v8 = __error();
        uint64_t v9 = _os_log_pack_fill(v7, v6, *v8, &dword_0, "RTADVSocketRelease: %s not in list?", v11);
        uint64_t v10 = nullsub_1(*v1);
        *(_DWORD *)uint64_t v9 = 136315138;
        *(void *)(v9 + 4) = v10;
        __SC_log_send(5LL, v4, v5, v7);
      }
    }

    else
    {
      sub_53DA8((uint64_t *)qword_6C2A8, v3, 0LL);
    }

    sub_4C67C(v1);
    *a1 = 0LL;
  }

void sub_4C67C(void *a1)
{
  a1[4] = 0LL;
  a1[5] = 0LL;
  a1[6] = 0LL;
  a1[1] = 0LL;
  a1[2] = 0LL;
  sub_4CA60((uint64_t)a1);
  free(a1);
}

uint64_t sub_4C6AC(void *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  a1[4] = a2;
  a1[5] = a3;
  a1[6] = a4;
  uint64_t result = sub_4C7F4((uint64_t)a1);
  if ((_DWORD)result)
  {
    int v6 = result;
    uint64_t v7 = sub_57538();
    uint64_t v8 = _SC_syslog_os_log_mapping(5LL);
    uint64_t result = __SC_log_enabled(5LL, v7, v8);
    if ((_DWORD)result)
    {
      uint64_t v9 = _os_log_pack_size(22LL);
      uint64_t v10 = (char *)v15 - ((__chkstk_darwin(v9) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v11 = __error();
      uint64_t v12 = _os_log_pack_fill(v10, v9, *v11, &dword_0, "%s: failed, %s", v15[0], v15[1]);
      uint64_t v13 = nullsub_1(*a1);
      uint64_t v14 = strerror(v6);
      *(_DWORD *)uint64_t v12 = 136315394;
      *(void *)(v12 + 4) = v13;
      *(_WORD *)(v12 + 12) = 2080;
      *(void *)(v12 + 14) = v14;
      return __SC_log_send(5LL, v7, v8, v10);
    }
  }

  return result;
}

uint64_t sub_4C7F4(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 24)) {
    return 0LL;
  }
  timer_cancel(*(void *)(qword_6C2A8 + 48));
  ++*(_DWORD *)(qword_6C2A8 + 40);
  uint64_t v2 = sub_57538();
  uint64_t v3 = _SC_syslog_os_log_mapping(7LL);
  if (__SC_log_enabled(7LL, v2, v3))
  {
    uint64_t v4 = _os_log_pack_size(28LL);
    uint64_t v5 = (char *)v18 - ((__chkstk_darwin(v4) + 15) & 0xFFFFFFFFFFFFFFF0LL);
    int v6 = __error();
    uint64_t v7 = _os_log_pack_fill(v5, v4, *v6, &dword_0, "%s(%s): refcount %d", v18[0], v18[1], v19);
    uint64_t v8 = nullsub_1(*(void *)a1);
    int v9 = *(_DWORD *)(qword_6C2A8 + 40);
    *(_DWORD *)uint64_t v7 = 136315650;
    *(void *)(v7 + 4) = "RTADVSocketOpenSocket";
    *(_WORD *)(v7 + 12) = 2080;
    *(void *)(v7 + 14) = v8;
    *(_WORD *)(v7 + 22) = 1024;
    *(_DWORD *)(v7 + 24) = v9;
    __SC_log_send(7LL, v2, v3, v5);
  }

  *(_BYTE *)(a1 + 24) = 1;
  if (*(void *)(qword_6C2A8 + 32))
  {
    uint64_t v10 = sub_57538();
    uint64_t v11 = _SC_syslog_os_log_mapping(6LL);
    if (__SC_log_enabled(6LL, v10, v11))
    {
      uint64_t v12 = _os_log_pack_size(12LL);
      uint64_t v13 = (char *)v18 - ((__chkstk_darwin(v12) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v14 = __error();
      uint64_t v15 = _os_log_pack_fill(v13, v12, *v14, &dword_0, "%s: socket is still open", v18[0]);
      *(_DWORD *)uint64_t v15 = 136315138;
      *(void *)(v15 + 4) = "RTADVSocketOpenSocket";
      __SC_log_send(6LL, v10, v11, v13);
    }

    return 0LL;
  }

  uint64_t v16 = sub_4CFA4();
  if ((_DWORD)v16) {
    sub_4CA60(a1);
  }
  return v16;
}

uint64_t sub_4CA50(uint64_t result)
{
  *(void *)(result + 32) = 0LL;
  *(void *)(result + 40) = 0LL;
  *(void *)(result + 48) = 0LL;
  *(void *)(result + 8) = 0LL;
  *(void *)(result + 16) = 0LL;
  return sub_4CA60(result);
}

uint64_t sub_4CA60(uint64_t result)
{
  if (*(_BYTE *)(result + 24))
  {
    CFStringRef v1 = (void *)result;
    int v2 = *(_DWORD *)(qword_6C2A8 + 40);
    if (v2 <= 0)
    {
      uint64_t v16 = sub_57538();
      uint64_t v17 = _SC_syslog_os_log_mapping(5LL);
      uint64_t result = __SC_log_enabled(5LL, v16, v17);
      if ((_DWORD)result)
      {
        uint64_t v18 = _os_log_pack_size(18LL);
        uint64_t v19 = (char *)&v24 - ((__chkstk_darwin(v18) + 15) & 0xFFFFFFFFFFFFFFF0LL);
        uint64_t v20 = __error();
        uint64_t v21 = _os_log_pack_fill( v19,  v18,  *v20,  &dword_0,  "RTADVSocketCloseSocket(%s): refcount %d",  v24,  v25);
        uint64_t v22 = nullsub_1(*v1);
        int v23 = *(_DWORD *)(qword_6C2A8 + 40);
        *(_DWORD *)uint64_t v21 = 136315394;
        *(void *)(v21 + 4) = v22;
        *(_WORD *)(v21 + 12) = 1024;
        *(_DWORD *)(v21 + 14) = v23;
        return __SC_log_send(5LL, v16, v17, v19);
      }
    }

    else
    {
      *(_DWORD *)(qword_6C2A8 + 40) = v2 - 1;
      uint64_t v3 = sub_57538();
      uint64_t v4 = _SC_syslog_os_log_mapping(7LL);
      uint64_t result = __SC_log_enabled(7LL, v3, v4);
      if ((_DWORD)result)
      {
        uint64_t v5 = _os_log_pack_size(18LL);
        int v6 = (char *)&v24 - ((__chkstk_darwin(v5) + 15) & 0xFFFFFFFFFFFFFFF0LL);
        uint64_t v7 = __error();
        uint64_t v8 = _os_log_pack_fill(v6, v5, *v7, &dword_0, "RTADVSocketCloseSocket(%s): refcount %d", v24, v25);
        uint64_t v9 = nullsub_1(*v1);
        int v10 = *(_DWORD *)(qword_6C2A8 + 40);
        *(_DWORD *)uint64_t v8 = 136315394;
        *(void *)(v8 + 4) = v9;
        *(_WORD *)(v8 + 12) = 1024;
        *(_DWORD *)(v8 + 14) = v10;
        uint64_t result = __SC_log_send(7LL, v3, v4, v6);
      }

      *((_BYTE *)v1 + 24) = 0;
      if (!*(_DWORD *)(qword_6C2A8 + 40))
      {
        uint64_t v11 = sub_57538();
        uint64_t v12 = _SC_syslog_os_log_mapping(7LL);
        if (__SC_log_enabled(7LL, v11, v12))
        {
          uint64_t v13 = _os_log_pack_size(2LL);
          uint64_t v14 = (char *)&v24 - ((__chkstk_darwin(v13) + 15) & 0xFFFFFFFFFFFFFFF0LL);
          uint64_t v15 = __error();
          *(_WORD *)_os_log_pack_fill( v14,  v13,  *v15,  &dword_0,  "RTADVSocketCloseSocket(): scheduling delayed close") = 0;
          __SC_log_send(7LL, v11, v12, v14);
        }

        return timer_set_relative(*(void *)(qword_6C2A8 + 48), 1LL, 0, (uint64_t)sub_4DFD4, 0LL, 0LL, 0LL);
      }
    }
  }

  return result;
}

uint64_t sub_4CD54(uint64_t a1, int a2)
{
  uint64_t v4 = *(void *)a1;
  int v5 = *(unsigned __int8 *)(a1 + 24);
  uint64_t v6 = *(void *)a1;
  if (*(_BYTE *)(a1 + 24)) {
    goto LABEL_2;
  }
  uint64_t v11 = sub_4C7F4(a1);
  if (!(_DWORD)v11)
  {
    uint64_t v6 = *(void *)a1;
LABEL_2:
    uint64_t v25 = 133LL;
    if (a2 && sub_54E20(v6) == 6)
    {
      int v7 = (sub_54230(v6) + 2) & 7;
      int v8 = sub_54230(v6);
      if (v7) {
        int v9 = v8 - ((sub_54230(v6) + 2) & 7) + 10;
      }
      else {
        int v9 = v8 + 2;
      }
      char v26 = 1;
      char v27 = v9 / 8;
      uint64_t v20 = sub_54E44(v6);
      sub_54230(v6);
      __memmove_chk(v28, v20);
      int v10 = v9 + 8;
    }

    else
    {
      int v10 = 8;
    }

    int v21 = sub_14418(*(unsigned int **)(qword_6C2A8 + 32));
    int v22 = sub_54F6C(v4);
    uint64_t v12 = sub_56244(v21, v22, &unk_59630, (uint64_t)&v25, v10, 255);
    if (!v5) {
      sub_4CA60(a1);
    }
    return v12;
  }

  uint64_t v12 = v11;
  uint64_t v13 = sub_57538();
  uint64_t v14 = _SC_syslog_os_log_mapping(5LL);
  if (__SC_log_enabled(5LL, v13, v14))
  {
    uint64_t v15 = _os_log_pack_size(12LL);
    uint64_t v16 = (char *)&v24 - ((__chkstk_darwin(v15) + 15) & 0xFFFFFFFFFFFFFFF0LL);
    uint64_t v17 = __error();
    uint64_t v18 = _os_log_pack_fill(v16, v15, *v17, &dword_0, "RTADVSocket: failed to open socket, %s", v24);
    uint64_t v19 = strerror(v12);
    *(_DWORD *)uint64_t v18 = 136315138;
    *(void *)(v18 + 4) = v19;
    __SC_log_send(5LL, v13, v14, v16);
  }

  return v12;
}

uint64_t sub_4CFA4()
{
  int v0 = sub_4D1AC();
  if (v0 < 0)
  {
    uint64_t v8 = *__error();
    uint64_t v9 = sub_57538();
    uint64_t v10 = _SC_syslog_os_log_mapping(3LL);
    if (__SC_log_enabled(3LL, v9, v10))
    {
      uint64_t v11 = _os_log_pack_size(22LL);
      uint64_t v12 = (char *)&v17 - ((__chkstk_darwin(v11) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v13 = __error();
      uint64_t v14 = _os_log_pack_fill(v12, v11, *v13, &dword_0, "%s: socket() failed, %s", v17, v18);
      uint64_t v15 = strerror(v8);
      *(_DWORD *)uint64_t v14 = 136315394;
      *(void *)(v14 + 4) = "RTADVSocketOpenSocketFD";
      *(_WORD *)(v14 + 12) = 2080;
      *(void *)(v14 + 14) = v15;
      __SC_log_send(3LL, v9, v10, v12);
    }
  }

  else
  {
    int v1 = v0;
    uint64_t v2 = sub_57538();
    uint64_t v3 = _SC_syslog_os_log_mapping(7LL);
    if (__SC_log_enabled(7LL, v2, v3))
    {
      uint64_t v4 = _os_log_pack_size(18LL);
      int v5 = (char *)&v17 - ((__chkstk_darwin(v4) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v6 = __error();
      uint64_t v7 = _os_log_pack_fill(v5, v4, *v6, &dword_0, "%s: opened RTADV socket %d", v17, (_DWORD)v18);
      *(_DWORD *)uint64_t v7 = 136315394;
      *(void *)(v7 + 4) = "RTADVSocketOpenSocketFD";
      *(_WORD *)(v7 + 12) = 1024;
      *(_DWORD *)(v7 + 14) = v1;
      __SC_log_send(7LL, v2, v3, v5);
    }

    sub_4D3D0(v1);
    return 0LL;
  }

  return v8;
}

uint64_t sub_4D1AC()
{
  uint64_t v0 = sub_49398(1);
  if ((v0 & 0x80000000) != 0)
  {
    uint64_t v10 = sub_57538();
    uint64_t v11 = _SC_syslog_os_log_mapping(3LL);
    uint64_t v12 = _os_log_pack_size(12LL);
    uint64_t v13 = (char *)&v19 - ((__chkstk_darwin(v12) + 15) & 0xFFFFFFFFFFFFFFF0LL);
    uint64_t v14 = __error();
    uint64_t v15 = _os_log_pack_fill(v13, v12, *v14, &dword_0, "error opening socket: %s", (const char *)v19);
    uint64_t v16 = __error();
    uint64_t v17 = strerror(*v16);
    *(_DWORD *)uint64_t v15 = 136315138;
    *(void *)(v15 + 4) = v17;
    __SC_log_send(3LL, v10, v11, v13);
    return 0xFFFFFFFFLL;
  }

  else
  {
    uint64_t v1 = v0;
    __int128 v19 = 0u;
    __int128 v20 = 0u;
    LODWORD(v20) = 64;
    if (setsockopt(v0, 58, 18, &v19, 0x20u) == -1)
    {
      uint64_t v2 = sub_57538();
      uint64_t v3 = _SC_syslog_os_log_mapping(3LL);
      if (__SC_log_enabled(3LL, v2, v3))
      {
        uint64_t v4 = _os_log_pack_size(12LL);
        int v5 = (char *)&v19 - ((__chkstk_darwin(v4) + 15) & 0xFFFFFFFFFFFFFFF0LL);
        uint64_t v6 = __error();
        uint64_t v7 = _os_log_pack_fill(v5, v4, *v6, &dword_0, "setsockopt(ICMP6_FILTER): %s", (const char *)v19);
        uint64_t v8 = __error();
        uint64_t v9 = strerror(*v8);
        *(_DWORD *)uint64_t v7 = 136315138;
        *(void *)(v7 + 4) = v9;
        __SC_log_send(3LL, v2, v3, v5);
      }

      close(v1);
      return 0xFFFFFFFFLL;
    }
  }

  return v1;
}

void *sub_4D3D0(int a1)
{
  uint64_t v2 = sub_57538();
  uint64_t v3 = _SC_syslog_os_log_mapping(7LL);
  if (__SC_log_enabled(7LL, v2, v3))
  {
    uint64_t v4 = _os_log_pack_size(18LL);
    int v5 = (char *)&v9 - ((__chkstk_darwin(v4) + 15) & 0xFFFFFFFFFFFFFFF0LL);
    uint64_t v6 = __error();
    uint64_t v7 = _os_log_pack_fill( v5,  v4,  *v6,  &dword_0,  "%s: enabling receive on socket %d",  (const char *)v9,  v10);
    *(_DWORD *)uint64_t v7 = 136315394;
    *(void *)(v7 + 4) = "RTADVSocketEnableReceiveCallBack";
    *(_WORD *)(v7 + 12) = 1024;
    *(_DWORD *)(v7 + 14) = a1;
    __SC_log_send(7LL, v2, v3, v5);
  }

  uint64_t v9 = _NSConcreteStackBlock;
  uint64_t v10 = 0x40000000LL;
  uint64_t v11 = sub_4D544;
  uint64_t v12 = &unk_65058;
  int v13 = a1;
  uint64_t result = sub_141BC(a1, (uint64_t)sub_4D670, 0LL, 0LL, &v9);
  *(void *)(qword_6C2A8 + 32) = result;
  return result;
}

uint64_t sub_4D544(uint64_t a1)
{
  return sub_4D54C(*(_DWORD *)(a1 + 32));
}

uint64_t sub_4D54C(int a1)
{
  uint64_t v2 = sub_57538();
  uint64_t v3 = _SC_syslog_os_log_mapping(7LL);
  if (__SC_log_enabled(7LL, v2, v3))
  {
    uint64_t v4 = _os_log_pack_size(18LL);
    int v5 = (char *)&v9 - ((__chkstk_darwin(v4) + 15) & 0xFFFFFFFFFFFFFFF0LL);
    uint64_t v6 = __error();
    uint64_t v7 = _os_log_pack_fill(v5, v4, *v6, &dword_0, "%s: socket %d complete, closing", v9, v10);
    *(_DWORD *)uint64_t v7 = 136315394;
    *(void *)(v7 + 4) = "RTADVSocketFDComplete";
    *(_WORD *)(v7 + 12) = 1024;
    *(_DWORD *)(v7 + 14) = a1;
    __SC_log_send(7LL, v2, v3, v5);
  }

  return close(a1);
}

void sub_4D670()
{
  v68[0] = &v69;
  v68[1] = 1500LL;
  v65.msg_name = &v66;
  v65.msg_namelen = 28;
  v65.msg_iov = (iovec *)v68;
  v65.msg_iovlen = 1;
  v65.msg_control = &v72;
  *(void *)&v65.msg_controllen = 48LL;
  int v0 = sub_14418(*(unsigned int **)(qword_6C2A8 + 32));
  unint64_t v1 = recvmsg(v0, &v65, 0);
  if ((v1 & 0x8000000000000000LL) != 0)
  {
    if (*__error() != 35)
    {
      uint64_t v12 = sub_57538();
      uint64_t v13 = _SC_syslog_os_log_mapping(3LL);
      if (__SC_log_enabled(3LL, v12, v13))
      {
        uint64_t v14 = _os_log_pack_size(18LL);
        uint64_t v15 = (char *)&v63 - ((__chkstk_darwin(v14) + 15) & 0xFFFFFFFFFFFFFFF0LL);
        uint64_t v16 = __error();
        uint64_t v17 = _os_log_pack_fill( v15,  v14,  *v16,  &dword_0,  "RTADVSocketRead: recvfrom failed %s (%d)",  (const char *)v63,  DWORD2(v63));
        uint64_t v18 = __error();
        __int128 v19 = strerror(*v18);
        int v20 = *__error();
        *(_DWORD *)uint64_t v17 = 136315394;
        *(void *)(v17 + 4) = v19;
        *(_WORD *)(v17 + 12) = 1024;
        *(_DWORD *)(v17 + 14) = v20;
        uint64_t v10 = 3LL;
        uint64_t v11 = v12;
        uint64_t v21 = v13;
        int v22 = v15;
LABEL_35:
        __SC_log_send(v10, v11, v21, v22);
        return;
      }
    }

    return;
  }

  size_t v3 = v1;
  if (!v1) {
    return;
  }
  if (v1 <= 0xF)
  {
    uint64_t v4 = sub_57538();
    uint64_t v5 = _SC_syslog_os_log_mapping(5LL);
    uint64_t v6 = _os_log_pack_size(12LL);
    uint64_t v7 = (char *)&v63 - ((__chkstk_darwin(v6) + 15) & 0xFFFFFFFFFFFFFFF0LL);
    uint64_t v8 = __error();
    uint64_t v9 = _os_log_pack_fill( v7,  v6,  *v8,  &dword_0,  "RTADVSocketRead: packet size(%ld) is too short",  (void)v63);
    *(_DWORD *)uint64_t v9 = 134217984;
    *(void *)(v9 + 4) = v3;
    uint64_t v10 = 5LL;
    uint64_t v11 = v4;
LABEL_34:
    uint64_t v21 = v5;
    int v22 = v7;
    goto LABEL_35;
  }

  if (v67 != 254 || (BYTE1(v67) & 0xC0) != 0x80)
  {
    uint64_t v43 = sub_57538();
    uint64_t v5 = _SC_syslog_os_log_mapping(5LL);
    uint64_t v44 = _os_log_pack_size(12LL);
    uint64_t v7 = (char *)&v63 - ((__chkstk_darwin(v44) + 15) & 0xFFFFFFFFFFFFFFF0LL);
    uint64_t v45 = __error();
    uint64_t v46 = _os_log_pack_fill( v7,  v44,  *v45,  &dword_0,  "RTADVSocketRead: RA has non link-local source address %s",  (const char *)v63);
    int v47 = inet_ntop(30, &v67, v71, 0x2Eu);
    *(_DWORD *)uint64_t v46 = 136315138;
    *(void *)(v46 + 4) = v47;
    uint64_t v10 = 5LL;
    uint64_t v11 = v43;
    goto LABEL_34;
  }

  if (v65.msg_controllen < 0xC) {
    goto LABEL_37;
  }
  msg_control = (unsigned int *)v65.msg_control;
  if (!v65.msg_control) {
    goto LABEL_37;
  }
  uint64_t v24 = 0LL;
  uint64_t v25 = 0LL;
  *(void *)&__int128 v2 = 67109120LL;
  __int128 v63 = v2;
  do
  {
    if (msg_control[1] == 41)
    {
      unsigned int v26 = msg_control[2];
      if (v26 == 47)
      {
        if (*msg_control >= 0x10) {
          uint64_t v24 = msg_control + 3;
        }
      }

      else if (v26 == 46)
      {
        if (*msg_control >= 0x20) {
          uint64_t v25 = msg_control + 3;
        }
      }

      else
      {
        uint64_t v27 = sub_57538();
        uint64_t v28 = _SC_syslog_os_log_mapping(5LL);
        if (__SC_log_enabled(5LL, v27, v28))
        {
          uint64_t v29 = _os_log_pack_size(8LL);
          int8x16_t v64 = v25;
          uint64_t v30 = v24;
          int v31 = (char *)&v63 - ((__chkstk_darwin(v29) + 15) & 0xFFFFFFFFFFFFFFF0LL);
          int v32 = __error();
          int v33 = (_DWORD *)_os_log_pack_fill( v31,  v29,  *v32,  &dword_0,  "RTADVSocketRead: why control message type %d?",  (_DWORD)v63);
          unsigned int v34 = msg_control[2];
          *int v33 = v63;
          v33[1] = v34;
          uint64_t v35 = v31;
          uint64_t v24 = v30;
          __SC_log_send(5LL, v27, v28, v35);
          uint64_t v25 = v64;
        }
      }
    }

    msg_control = (unsigned int *)((char *)msg_control + ((*msg_control + 3LL) & 0x1FFFFFFFCLL));
  }

  while ((char *)(msg_control + 3) <= (char *)v65.msg_control + v65.msg_controllen);
  if (!v25)
  {
LABEL_37:
    uint64_t v36 = sub_57538();
    uint64_t v37 = _SC_syslog_os_log_mapping(5LL);
    uint64_t v48 = _os_log_pack_size(2LL);
    int v39 = (char *)&v63 - ((__chkstk_darwin(v48) + 15) & 0xFFFFFFFFFFFFFFF0LL);
    uint64_t v49 = *__error();
    uint64_t v50 = (_WORD *)_os_log_pack_fill( v39,  v48,  v49,  &dword_0,  "RTADVSocketRead: missing IPV6_PKTINFO",  (void)v63,  *((void *)&v63 + 1));
    goto LABEL_39;
  }

  if (!v24)
  {
    uint64_t v36 = sub_57538();
    uint64_t v37 = _SC_syslog_os_log_mapping(5LL);
    uint64_t v51 = _os_log_pack_size(2LL);
    int v39 = (char *)&v63 - ((__chkstk_darwin(v51) + 15) & 0xFFFFFFFFFFFFFFF0LL);
    uint64_t v52 = *__error();
    uint64_t v50 = (_WORD *)_os_log_pack_fill( v39,  v51,  v52,  &dword_0,  "RTADVSocketRead: missing IPV6_HOPLIMIT",  (void)v63,  *((void *)&v63 + 1));
LABEL_39:
    _WORD *v50 = 0;
LABEL_40:
    __SC_log_send(5LL, v36, v37, v39);
    return;
  }

  if (v69 == 134)
  {
    if (v70)
    {
      uint64_t v36 = sub_57538();
      uint64_t v37 = _SC_syslog_os_log_mapping(5LL);
      uint64_t v38 = _os_log_pack_size(8LL);
      int v39 = (char *)&v63 - ((__chkstk_darwin(v38) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      int v40 = __error();
      __int128 v41 = (_DWORD *)_os_log_pack_fill( v39,  v38,  *v40,  &dword_0,  "RTADVSocket: invalid icmp code %d",  (_DWORD)v63);
      int v42 = v70;
      goto LABEL_45;
    }

    if (*v24 == 255)
    {
      sub_4DE44(v25[4], &v67, &v69, v3);
    }

    else
    {
      uint64_t v55 = sub_57538();
      uint64_t v56 = _SC_syslog_os_log_mapping(5LL);
      if (__SC_log_enabled(5LL, v55, v56))
      {
        uint64_t v57 = _os_log_pack_size(18LL);
        uint64_t v58 = (char *)&v63 - ((__chkstk_darwin(v57) + 15) & 0xFFFFFFFFFFFFFFF0LL);
        uint64_t v59 = __error();
        uint64_t v60 = _os_log_pack_fill( v58,  v57,  *v59,  &dword_0,  "RTADVSocket: invalid RA hop limit %d from %s",  (_DWORD)v63,  *((const char **)&v63 + 1));
        int v61 = *v24;
        int v62 = inet_ntop(30, &v67, v71, 0x2Eu);
        *(_DWORD *)uint64_t v60 = 67109378;
        *(_DWORD *)(v60 + 4) = v61;
        *(_WORD *)(v60 + 8) = 2080;
        *(void *)(v60 + 10) = v62;
        __SC_log_send(5LL, v55, v56, v58);
      }
    }
  }

  else
  {
    uint64_t v36 = sub_57538();
    uint64_t v37 = _SC_syslog_os_log_mapping(5LL);
    if (__SC_log_enabled(5LL, v36, v37))
    {
      uint64_t v53 = _os_log_pack_size(8LL);
      int v39 = (char *)&v63 - ((__chkstk_darwin(v53) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v54 = __error();
      __int128 v41 = (_DWORD *)_os_log_pack_fill( v39,  v53,  *v54,  &dword_0,  "RTADVSocket: received unexpected ND packet type %d",  (_DWORD)v63);
      int v42 = v69;
LABEL_45:
      *__int128 v41 = v63;
      v41[1] = v42;
      goto LABEL_40;
    }
  }

void sub_4DE44(int a1, _OWORD *a2, const void *a3, size_t a4)
{
  uint64_t v7 = sub_4C4A8(a1);
  if (v7)
  {
    uint64_t v8 = v7;
    if (v7[4])
    {
      double Current = CFAbsoluteTimeGetCurrent();
      uint64_t v10 = sub_51964(a3, a4, a2, Current);
      if (v10)
      {
        uint64_t v11 = (const void *)v10;
        ((void (*)(uint64_t, uint64_t, uint64_t))v8[4])(v8[5], v8[6], v10);
        CFRelease(v11);
      }

      else
      {
        uint64_t v12 = sub_57538();
        uint64_t v13 = _SC_syslog_os_log_mapping(5LL);
        if (__SC_log_enabled(5LL, v12, v13))
        {
          uint64_t v14 = _os_log_pack_size(12LL);
          uint64_t v15 = (char *)&v19 - ((__chkstk_darwin(v14) + 15) & 0xFFFFFFFFFFFFFFF0LL);
          uint64_t v16 = __error();
          uint64_t v17 = _os_log_pack_fill( v15,  v14,  *v16,  &dword_0,  "%s: failed to create RouterAdvertisement",  v19);
          uint64_t v18 = nullsub_1(*v8);
          *(_DWORD *)uint64_t v17 = 136315138;
          *(void *)(v17 + 4) = v18;
          __SC_log_send(5LL, v12, v13, v15);
        }
      }
    }
  }

void sub_4DFD4()
{
  if (!*(void *)(qword_6C2A8 + 32))
  {
    uint64_t v1 = sub_57538();
    uint64_t v2 = _SC_syslog_os_log_mapping(5LL);
    uint64_t v7 = _os_log_pack_size(2LL);
    uint64_t v4 = (char *)&v15 - ((__chkstk_darwin(v7) + 15) & 0xFFFFFFFFFFFFFFF0LL);
    uint64_t v8 = *__error();
    uint64_t v6 = (_WORD *)_os_log_pack_fill(v4, v7, v8, &dword_0, "RTADVSocketDelayedClose(): socket is already closed");
    goto LABEL_7;
  }

  int v0 = *(_DWORD *)(qword_6C2A8 + 40);
  uint64_t v1 = sub_57538();
  if (v0 >= 1)
  {
    uint64_t v2 = _SC_syslog_os_log_mapping(5LL);
    uint64_t v3 = _os_log_pack_size(2LL);
    uint64_t v4 = (char *)&v15 - ((__chkstk_darwin(v3) + 15) & 0xFFFFFFFFFFFFFFF0LL);
    uint64_t v5 = *__error();
    uint64_t v6 = (_WORD *)_os_log_pack_fill(v4, v3, v5, &dword_0, "RTADVSocketDelayedClose(): called when socket in use");
LABEL_7:
    *uint64_t v6 = 0;
    __SC_log_send(5LL, v1, v2, v4);
    return;
  }

  uint64_t v9 = _SC_syslog_os_log_mapping(7LL);
  if (__SC_log_enabled(7LL, v1, v9))
  {
    uint64_t v10 = _os_log_pack_size(8LL);
    uint64_t v11 = (char *)&v15 - ((__chkstk_darwin(v10) + 15) & 0xFFFFFFFFFFFFFFF0LL);
    uint64_t v12 = __error();
    uint64_t v13 = (_DWORD *)_os_log_pack_fill( v11,  v10,  *v12,  &dword_0,  "RTADVSocketDelayedClose(): closing RTADV socket %d",  v15);
    int v14 = sub_14418(*(unsigned int **)(qword_6C2A8 + 32));
    *uint64_t v13 = 67109120;
    v13[1] = v14;
    __SC_log_send(7LL, v1, v9, v11);
  }

  sub_143D4((dispatch_object_t **)(qword_6C2A8 + 32));
}

void sub_4E220(uint64_t a1, int a2)
{
  if (*(_BYTE *)(a1 + 26)) {
    int v3 = 0;
  }
  else {
    int v3 = a2;
  }
  if (v3 == 1)
  {
    uint64_t v4 = *(const void **)a1;
  }

  else
  {
    sub_4FA18((const void **)a1);
    uint64_t v4 = 0LL;
  }

  sub_4FA18((const void **)(a1 + 8));
  sub_4FA18((const void **)(a1 + 32));
  sub_4FA18((const void **)(a1 + 40));
  sub_4FA18((const void **)(a1 + 48));
  *(void *)(a1 + 48) = 0LL;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)a1 = 0u;
  if (v3)
  {
    *(void *)a1 = v4;
    *(_BYTE *)(a1 + 26) = 0;
  }

void sub_4E2A8(const void **a1, CFTypeRef cf)
{
  if (cf) {
    CFRetain(cf);
  }
  sub_4FA18(a1);
  *a1 = cf;
}

void sub_4E2E0(uint64_t a1, CFTypeRef cf)
{
  if (cf) {
    CFRetain(cf);
  }
  sub_4FA18((const void **)(a1 + 8));
  *(void *)(a1 + 8) = cf;
}

uint64_t sub_4E318(uint64_t result, uint64_t a2)
{
  *(void *)(result + 16) = a2;
  return result;
}

uint64_t sub_4E320(uint64_t a1)
{
  return *(unsigned __int16 *)(a1 + 24);
}

uint64_t sub_4E328(uint64_t result, __int16 a2)
{
  *(_WORD *)(result + 24) = a2;
  return result;
}

uint64_t sub_4E330(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 26);
}

uint64_t sub_4E338(uint64_t result, char a2)
{
  *(_BYTE *)(result + 26) = a2;
  return result;
}

uint64_t sub_4E340(uint64_t a1)
{
  return *(void *)(a1 + 32);
}

void sub_4E348(uint64_t a1, CFTypeRef cf)
{
  if (cf) {
    CFRetain(cf);
  }
  sub_4FA18((const void **)(a1 + 32));
  *(void *)(a1 + 32) = cf;
}

BOOL sub_4E380(uint64_t a1)
{
  CFAbsoluteTime v1 = CFDateGetAbsoluteTime(*(CFDateRef *)(a1 + 40)) + 10.0;
  return v1 < CFAbsoluteTimeGetCurrent();
}

CFDateRef sub_4E3B4(uint64_t a1)
{
  CFAbsoluteTime Current = CFAbsoluteTimeGetCurrent();
  CFDateRef result = CFDateCreate(0LL, Current);
  *(void *)(a1 + 40) = result;
  return result;
}

void sub_4E3E8(const void **a1)
{
  CFStringRef v34 = 0LL;
  uint64_t v2 = sub_57538();
  uint64_t v3 = _SC_syslog_os_log_mapping(7LL);
  if (__SC_log_enabled(7LL, v2, v3))
  {
    uint64_t v4 = _os_log_pack_size(12LL);
    uint64_t v5 = (char *)&v33 - ((__chkstk_darwin(v4) + 15) & 0xFFFFFFFFFFFFFFF0LL);
    uint64_t v6 = __error();
    uint64_t v7 = _os_log_pack_fill(v5, v4, *v6, &dword_0, "%s", v33);
    *(_DWORD *)uint64_t v7 = 136315138;
    *(void *)(v7 + 4) = "PvDInfoContextCalculateEffectiveExpiration";
    __SC_log_send(7LL, v2, v3, v5);
  }

  uint64_t v8 = a1[4];
  if (v8)
  {
    int Value = (const __CFString *)CFDictionaryGetValue((CFDictionaryRef)a1[4], @"expires");
    CFAbsoluteTime atp = 0.0;
    CFLocaleRef v10 = CFLocaleCreate(0LL, @"en_US_POSIX");
    CFLocaleRef v37 = v10;
    if (v10 && (uint64_t v11 = CFDateFormatterCreate(0LL, v10, kCFDateFormatterNoStyle, kCFDateFormatterNoStyle)) != 0LL)
    {
      uint64_t v12 = v11;
      CFDateFormatterSetFormat(v11, @"yyyy-MM-dd'T'HH:mm:ss'Z'");
      sub_4FA18((const void **)&v37);
      uint64_t v36 = v12;
      if (CFDateFormatterGetAbsoluteTimeFromString(v12, Value, 0LL, &atp))
      {
        double v13 = (CFAbsoluteTimeGetCurrent() + atp) * 0.5;
        double v14 = atp - v13;
        if (atp - v13 > 4294967300.0) {
          double v14 = 4294967300.0;
        }
        double v15 = v13 + (double)arc4random_uniform(v14);
        CFDateRef v16 = CFDateCreate(0LL, v15);
        if (v16)
        {
          CFDateRef v17 = v16;
          CFStringRef StringWithAbsoluteTime = CFDateFormatterCreateStringWithAbsoluteTime(0LL, v12, v15);
          CFStringRef v34 = StringWithAbsoluteTime;
          sub_4FA18((const void **)&v36);
          uint64_t v19 = sub_57538();
          uint64_t v20 = _SC_syslog_os_log_mapping(6LL);
          if (__SC_log_enabled(6LL, v19, v20))
          {
            uint64_t v21 = _os_log_pack_size(32LL);
            int v22 = (char *)&v33 - ((__chkstk_darwin(v21) + 15) & 0xFFFFFFFFFFFFFFF0LL);
            int v23 = __error();
            uint64_t v24 = _os_log_pack_fill( v22,  v21,  *v23,  &dword_0,  "%s: PvD info with ID '%@' has effective expiration date '%@'");
            uint64_t v25 = *a1;
            *(_DWORD *)uint64_t v24 = 136315650;
            *(void *)(v24 + 4) = "PvDInfoContextCalculateEffectiveExpiration";
            *(_WORD *)(v24 + 12) = 2112;
            *(void *)(v24 + 14) = v25;
            *(_WORD *)(v24 + 22) = 2112;
            *(void *)(v24 + 24) = StringWithAbsoluteTime;
            __SC_log_send(6LL, v19, v20, v22);
          }

          sub_4FA18(a1 + 6);
          a1[6] = v17;
          goto LABEL_18;
        }
      }
    }

    else
    {
      sub_4FA18((const void **)&v37);
      uint64_t v36 = 0LL;
    }

    sub_4FA18((const void **)&v36);
  }

  uint64_t v26 = sub_57538();
  uint64_t v27 = _SC_syslog_os_log_mapping(3LL);
  if (__SC_log_enabled(3LL, v26, v27))
  {
    uint64_t v28 = _os_log_pack_size(32LL);
    uint64_t v29 = (char *)&v33 - ((__chkstk_darwin(v28) + 15) & 0xFFFFFFFFFFFFFFF0LL);
    uint64_t v30 = __error();
    uint64_t v31 = _os_log_pack_fill( v29,  v28,  *v30,  &dword_0,  "%s: couldn't set expiration date for pvdid '%@' with addinfo '%@'");
    int v32 = *a1;
    *(_DWORD *)uint64_t v31 = 136315650;
    *(void *)(v31 + 4) = "PvDInfoContextCalculateEffectiveExpiration";
    *(_WORD *)(v31 + 12) = 2112;
    *(void *)(v31 + 14) = v32;
    *(_WORD *)(v31 + 22) = 2112;
    *(void *)(v31 + 24) = v8;
    __SC_log_send(3LL, v26, v27, v29);
  }

  sub_4FA18(a1 + 6);
LABEL_18:
  sub_4FA18((const void **)&v34);
}

double sub_4E7B8(uint64_t a1)
{
  CFAbsoluteTime v1 = *(const __CFDate **)(a1 + 48);
  if (v1) {
    return CFDateGetAbsoluteTime(v1);
  }
  else {
    return 0.0;
  }
}

uint64_t sub_4E7CC(uint64_t a1)
{
  int v1 = *(_DWORD *)(a1 + 20);
  else {
    return 0LL;
  }
}

_DWORD *sub_4E808(_DWORD *result, uint64_t a2)
{
  if ((*result & 0x80000000) != 0 || result[1] != 24)
  {
    *(_DWORD *)(a2 + 32) = -304;
    NDR_record_t v3 = NDR_record;
  }

  else
  {
    CFDateRef result = (_DWORD *)sub_2D17C(result[3], (_DWORD *)(a2 + 36));
    *(_DWORD *)(a2 + 32) = (_DWORD)result;
    NDR_record_t v3 = NDR_record;
    if (!(_DWORD)result)
    {
      *(NDR_record_t *)(a2 + 24) = NDR_record;
      *(_DWORD *)(a2 + 4) = 40;
      return result;
    }
  }

  *(NDR_record_t *)(a2 + 24) = v3;
  return result;
}

_DWORD *sub_4E880(_DWORD *result, uint64_t a2)
{
  if ((*result & 0x80000000) != 0 || result[1] != 52)
  {
    *(_DWORD *)(a2 + 32) = -304;
    goto LABEL_6;
  }

  *(_DWORD *)(a2 + 36) = 16777473;
  CFDateRef result = (_DWORD *)sub_2D1A4( result[3],  (uint64_t)(result + 8),  result[12],  (vm_address_t *)(a2 + 28),  (_DWORD *)(a2 + 52),  (_DWORD *)(a2 + 56));
  if ((_DWORD)result)
  {
    *(_DWORD *)(a2 + 32) = (_DWORD)result;
LABEL_6:
    *(NDR_record_t *)(a2 + 24) = NDR_record;
    return result;
  }

  *(_DWORD *)(a2 + 40) = *(_DWORD *)(a2 + 52);
  *(NDR_record_t *)(a2 + 44) = NDR_record;
  *(_DWORD *)a2 |= 0x80000000;
  *(_DWORD *)(a2 + 4) = 60;
  *(_DWORD *)(a2 + 24) = 1;
  return result;
}

_DWORD *sub_4E934(_DWORD *result, uint64_t a2)
{
  if ((*result & 0x80000000) != 0 || result[1] != 48)
  {
    *(_DWORD *)(a2 + 32) = -304;
    NDR_record_t v3 = NDR_record;
  }

  else
  {
    CFDateRef result = (_DWORD *)sub_2D148( result[3],  (uint64_t)(result + 8),  (_DWORD *)(a2 + 36),  (_DWORD *)(a2 + 40));
    *(_DWORD *)(a2 + 32) = (_DWORD)result;
    NDR_record_t v3 = NDR_record;
    if (!(_DWORD)result)
    {
      *(NDR_record_t *)(a2 + 24) = NDR_record;
      *(_DWORD *)(a2 + 4) = 44;
      return result;
    }
  }

  *(NDR_record_t *)(a2 + 24) = v3;
  return result;
}

_DWORD *sub_4E9B8(_DWORD *result, uint64_t a2)
{
  if ((*result & 0x80000000) != 0 || result[1] != 48)
  {
    *(_DWORD *)(a2 + 32) = -304;
    goto LABEL_6;
  }

  *(_DWORD *)(a2 + 36) = 16777473;
  CFDateRef result = (_DWORD *)sub_2D1E0( result[3],  (uint64_t)(result + 8),  (vm_address_t *)(a2 + 28),  (_DWORD *)(a2 + 52),  (_DWORD *)(a2 + 56));
  if ((_DWORD)result)
  {
    *(_DWORD *)(a2 + 32) = (_DWORD)result;
LABEL_6:
    *(NDR_record_t *)(a2 + 24) = NDR_record;
    return result;
  }

  *(_DWORD *)(a2 + 40) = *(_DWORD *)(a2 + 52);
  *(NDR_record_t *)(a2 + 44) = NDR_record;
  *(_DWORD *)a2 |= 0x80000000;
  *(_DWORD *)(a2 + 4) = 60;
  *(_DWORD *)(a2 + 24) = 1;
  return result;
}

uint64_t sub_4EA68(uint64_t result, uint64_t a2)
{
  if ((*(_DWORD *)result & 0x80000000) == 0 || *(_DWORD *)(result + 24) != 1 || *(_DWORD *)(result + 4) != 72)
  {
    int v4 = -304;
    goto LABEL_10;
  }

  if (*(_BYTE *)(result + 39) != 1 || (unsigned int v3 = *(_DWORD *)(result + 40), v3 != *(_DWORD *)(result + 68)))
  {
    int v4 = -300;
    goto LABEL_10;
  }

  if (*(_DWORD *)(result + 72) || *(_DWORD *)(result + 76) <= 0x1Fu)
  {
    int v4 = -309;
LABEL_10:
    *(_DWORD *)(a2 + 32) = v4;
    NDR_record_t v5 = NDR_record;
    goto LABEL_11;
  }

  uint64_t v6 = *(unsigned int *)(result + 12);
  uint64_t v7 = *(UInt8 **)(result + 28);
  __int128 v8 = *(_OWORD *)(result + 108);
  v9[0] = *(_OWORD *)(result + 92);
  v9[1] = v8;
  CFDateRef result = sub_2D250(v6, (char *)(result + 52), v7, v3, (int *)(a2 + 36), v9);
  *(_DWORD *)(a2 + 32) = result;
  NDR_record_t v5 = NDR_record;
  if (!(_DWORD)result)
  {
    *(NDR_record_t *)(a2 + 24) = NDR_record;
    *(_DWORD *)(a2 + 4) = 40;
    return result;
  }

_DWORD *sub_4EB54(_DWORD *result, uint64_t a2)
{
  if ((*result & 0x80000000) != 0 || result[1] != 36)
  {
    int v3 = -304;
    goto LABEL_7;
  }

  if (result[9] || result[10] <= 0x1Fu)
  {
    int v3 = -309;
LABEL_7:
    *(_DWORD *)(a2 + 32) = v3;
    NDR_record_t v4 = NDR_record;
    goto LABEL_8;
  }

  CFDateRef result = (_DWORD *)sub_2D400(result[3], result[8], (_DWORD *)(a2 + 36));
  *(_DWORD *)(a2 + 32) = (_DWORD)result;
  NDR_record_t v4 = NDR_record;
  if (!(_DWORD)result)
  {
    *(NDR_record_t *)(a2 + 24) = NDR_record;
    *(_DWORD *)(a2 + 4) = 40;
    return result;
  }

uint64_t sub_4EC0C(uint64_t result, uint64_t a2)
{
  if ((*(_DWORD *)result & 0x80000000) == 0 || *(_DWORD *)(result + 24) != 1 || *(_DWORD *)(result + 4) != 72)
  {
    int v4 = -304;
    goto LABEL_10;
  }

  if (*(_BYTE *)(result + 39) != 1 || (unsigned int v3 = *(_DWORD *)(result + 40), v3 != *(_DWORD *)(result + 68)))
  {
    int v4 = -300;
    goto LABEL_10;
  }

  if (*(_DWORD *)(result + 72) || *(_DWORD *)(result + 76) <= 0x1Fu)
  {
    int v4 = -309;
LABEL_10:
    *(_DWORD *)(a2 + 32) = v4;
    NDR_record_t v5 = NDR_record;
    goto LABEL_11;
  }

  uint64_t v6 = *(unsigned int *)(result + 12);
  uint64_t v7 = *(UInt8 **)(result + 28);
  __int128 v8 = *(_OWORD *)(result + 108);
  v9[0] = *(_OWORD *)(result + 92);
  v9[1] = v8;
  CFDateRef result = sub_2D410(v6, (char *)(result + 52), v7, v3, (_OWORD *)(a2 + 36), (int *)(a2 + 164), v9);
  *(_DWORD *)(a2 + 32) = result;
  NDR_record_t v5 = NDR_record;
  if (!(_DWORD)result)
  {
    *(NDR_record_t *)(a2 + 24) = NDR_record;
    *(_DWORD *)(a2 + 4) = 168;
    return result;
  }

uint64_t sub_4ECFC(uint64_t result, uint64_t a2)
{
  if ((*(_DWORD *)result & 0x80000000) == 0 || *(_DWORD *)(result + 24) != 1 || *(_DWORD *)(result + 4) != 76)
  {
    int v5 = -304;
LABEL_9:
    *(_DWORD *)(a2 + 32) = v5;
    NDR_record_t v4 = NDR_record;
    goto LABEL_10;
  }

  if (*(_BYTE *)(result + 39) != 1 || (unsigned int v3 = *(_DWORD *)(result + 40), v3 != *(_DWORD *)(result + 72)))
  {
    int v5 = -300;
    goto LABEL_9;
  }

  CFDateRef result = sub_2D83C( *(unsigned int *)(result + 12),  result + 52,  *(_DWORD *)(result + 68),  *(UInt8 **)(result + 28),  v3,  (_OWORD *)(a2 + 36),  (_DWORD *)(a2 + 164));
  *(_DWORD *)(a2 + 32) = result;
  NDR_record_t v4 = NDR_record;
  if (!(_DWORD)result)
  {
    *(NDR_record_t *)(a2 + 24) = NDR_record;
    *(_DWORD *)(a2 + 4) = 168;
    return result;
  }

uint64_t sub_4EDB8(uint64_t result, uint64_t a2)
{
  if ((*(_DWORD *)result & 0x80000000) == 0 || *(_DWORD *)(result + 24) != 1 || *(_DWORD *)(result + 4) != 72)
  {
    int v4 = -304;
    goto LABEL_10;
  }

  if (*(_BYTE *)(result + 39) != 1 || (unsigned int v3 = *(_DWORD *)(result + 40), v3 != *(_DWORD *)(result + 68)))
  {
    int v4 = -300;
    goto LABEL_10;
  }

  if (*(_DWORD *)(result + 72) || *(_DWORD *)(result + 76) <= 0x1Fu)
  {
    int v4 = -309;
LABEL_10:
    *(_DWORD *)(a2 + 32) = v4;
    NDR_record_t v5 = NDR_record;
    goto LABEL_11;
  }

  uint64_t v6 = *(unsigned int *)(result + 12);
  uint64_t v7 = *(UInt8 **)(result + 28);
  __int128 v8 = *(_OWORD *)(result + 108);
  v9[0] = *(_OWORD *)(result + 92);
  v9[1] = v8;
  CFDateRef result = sub_2D968(v6, result + 52, v7, v3, (int *)(a2 + 36), v9);
  *(_DWORD *)(a2 + 32) = result;
  NDR_record_t v5 = NDR_record;
  if (!(_DWORD)result)
  {
    *(NDR_record_t *)(a2 + 24) = NDR_record;
    *(_DWORD *)(a2 + 4) = 40;
    return result;
  }

uint64_t sub_4EEA4(uint64_t result, uint64_t a2)
{
  if ((*(_DWORD *)result & 0x80000000) == 0 || *(_DWORD *)(result + 24) != 1 || *(_DWORD *)(result + 4) != 72)
  {
    int v4 = -304;
    goto LABEL_10;
  }

  if (*(_BYTE *)(result + 39) != 1 || (unsigned int v3 = *(_DWORD *)(result + 40), v3 != *(_DWORD *)(result + 68)))
  {
    int v4 = -300;
    goto LABEL_10;
  }

  if (*(_DWORD *)(result + 72) || *(_DWORD *)(result + 76) <= 0x1Fu)
  {
    int v4 = -309;
LABEL_10:
    *(_DWORD *)(a2 + 32) = v4;
    NDR_record_t v5 = NDR_record;
    goto LABEL_11;
  }

  uint64_t v6 = *(unsigned int *)(result + 12);
  uint64_t v7 = *(UInt8 **)(result + 28);
  __int128 v8 = *(_OWORD *)(result + 108);
  v9[0] = *(_OWORD *)(result + 92);
  v9[1] = v8;
  CFDateRef result = _ipconfig_set_service(v6, (char *)(result + 52), v7, v3, (_OWORD *)(a2 + 36), (int *)(a2 + 164), v9);
  *(_DWORD *)(a2 + 32) = result;
  NDR_record_t v5 = NDR_record;
  if (!(_DWORD)result)
  {
    *(NDR_record_t *)(a2 + 24) = NDR_record;
    *(_DWORD *)(a2 + 4) = 168;
    return result;
  }

_DWORD *sub_4EF94(_DWORD *result, uint64_t a2)
{
  if ((*result & 0x80000000) != 0 || result[1] != 48)
  {
    *(_DWORD *)(a2 + 32) = -304;
    goto LABEL_6;
  }

  *(_DWORD *)(a2 + 36) = 16777473;
  CFDateRef result = (_DWORD *)sub_2D218( result[3],  (uint64_t)(result + 8),  (vm_address_t *)(a2 + 28),  (_DWORD *)(a2 + 52),  (_DWORD *)(a2 + 56));
  if ((_DWORD)result)
  {
    *(_DWORD *)(a2 + 32) = (_DWORD)result;
LABEL_6:
    *(NDR_record_t *)(a2 + 24) = NDR_record;
    return result;
  }

  *(_DWORD *)(a2 + 40) = *(_DWORD *)(a2 + 52);
  *(NDR_record_t *)(a2 + 44) = NDR_record;
  *(_DWORD *)a2 |= 0x80000000;
  *(_DWORD *)(a2 + 4) = 60;
  *(_DWORD *)(a2 + 24) = 1;
  return result;
}

uint64_t sub_4F044(uint64_t result, uint64_t a2)
{
  if ((*(_DWORD *)result & 0x80000000) != 0 || *(_DWORD *)(result + 4) != 176)
  {
    int v3 = -304;
    goto LABEL_7;
  }

  if (*(_DWORD *)(result + 176) || *(_DWORD *)(result + 180) <= 0x1Fu)
  {
    int v3 = -309;
LABEL_7:
    *(_DWORD *)(a2 + 32) = v3;
    NDR_record_t v4 = NDR_record;
    goto LABEL_8;
  }

  uint64_t v5 = *(unsigned int *)(result + 12);
  __int128 v6 = *(_OWORD *)(result + 212);
  v7[0] = *(_OWORD *)(result + 196);
  v7[1] = v6;
  CFDateRef result = sub_2D7C0(v5, result + 32, result + 48, (int *)(a2 + 36), v7);
  *(_DWORD *)(a2 + 32) = result;
  NDR_record_t v4 = NDR_record;
  if (!(_DWORD)result)
  {
    *(NDR_record_t *)(a2 + 24) = NDR_record;
    *(_DWORD *)(a2 + 4) = 40;
    return result;
  }

uint64_t sub_4F100(uint64_t result, uint64_t a2)
{
  if ((*(_DWORD *)result & 0x80000000) != 0 || *(_DWORD *)(result + 4) != 176)
  {
    int v3 = -304;
    goto LABEL_7;
  }

  if (*(_DWORD *)(result + 176) || *(_DWORD *)(result + 180) <= 0x1Fu)
  {
    int v3 = -309;
LABEL_7:
    *(_DWORD *)(a2 + 32) = v3;
    NDR_record_t v4 = NDR_record;
    goto LABEL_8;
  }

  uint64_t v5 = *(unsigned int *)(result + 12);
  __int128 v6 = *(_OWORD *)(result + 212);
  v7[0] = *(_OWORD *)(result + 196);
  v7[1] = v6;
  CFDateRef result = sub_2DA84(v5, result + 32, result + 48, (int *)(a2 + 36), v7);
  *(_DWORD *)(a2 + 32) = result;
  NDR_record_t v4 = NDR_record;
  if (!(_DWORD)result)
  {
    *(NDR_record_t *)(a2 + 24) = NDR_record;
    *(_DWORD *)(a2 + 4) = 40;
    return result;
  }

uint64_t sub_4F1BC(uint64_t result, uint64_t a2)
{
  if ((*(_DWORD *)result & 0x80000000) == 0 || *(_DWORD *)(result + 24) != 1 || *(_DWORD *)(result + 4) != 72)
  {
    int v4 = -304;
    goto LABEL_10;
  }

  if (*(_BYTE *)(result + 39) != 1 || (unsigned int v3 = *(_DWORD *)(result + 40), v3 != *(_DWORD *)(result + 68)))
  {
    int v4 = -300;
    goto LABEL_10;
  }

  if (*(_DWORD *)(result + 72) || *(_DWORD *)(result + 76) <= 0x1Fu)
  {
    int v4 = -309;
LABEL_10:
    *(_DWORD *)(a2 + 32) = v4;
    NDR_record_t v5 = NDR_record;
    goto LABEL_11;
  }

  uint64_t v6 = *(unsigned int *)(result + 12);
  uint64_t v7 = *(UInt8 **)(result + 28);
  __int128 v8 = *(_OWORD *)(result + 108);
  v9[0] = *(_OWORD *)(result + 92);
  v9[1] = v8;
  CFDateRef result = sub_2DB28(v6, result + 52, v7, v3, (int *)(a2 + 36), v9);
  *(_DWORD *)(a2 + 32) = result;
  NDR_record_t v5 = NDR_record;
  if (!(_DWORD)result)
  {
    *(NDR_record_t *)(a2 + 24) = NDR_record;
    *(_DWORD *)(a2 + 4) = 40;
    return result;
  }

_DWORD *sub_4F2A8(_DWORD *result, uint64_t a2)
{
  if ((*result & 0x80000000) != 0 || result[1] != 48)
  {
    *(_DWORD *)(a2 + 32) = -304;
    goto LABEL_6;
  }

  *(_DWORD *)(a2 + 36) = 16777473;
  CFDateRef result = (_DWORD *)sub_2DC6C( result[3],  (uint64_t)(result + 8),  (const __CFData **)(a2 + 28),  (_DWORD *)(a2 + 52),  (_DWORD *)(a2 + 56));
  if ((_DWORD)result)
  {
    *(_DWORD *)(a2 + 32) = (_DWORD)result;
LABEL_6:
    *(NDR_record_t *)(a2 + 24) = NDR_record;
    return result;
  }

  *(_DWORD *)(a2 + 40) = *(_DWORD *)(a2 + 52);
  *(NDR_record_t *)(a2 + 44) = NDR_record;
  *(_DWORD *)a2 |= 0x80000000;
  *(_DWORD *)(a2 + 4) = 60;
  *(_DWORD *)(a2 + 24) = 1;
  return result;
}

_DWORD *sub_4F358(_DWORD *result, uint64_t a2)
{
  if ((*result & 0x80000000) != 0 || result[1] != 48)
  {
    *(_DWORD *)(a2 + 32) = -304;
    goto LABEL_6;
  }

  *(_DWORD *)(a2 + 36) = 16777473;
  CFDateRef result = (_DWORD *)sub_2DCA4( result[3],  (uint64_t)(result + 8),  (const __CFData **)(a2 + 28),  (_DWORD *)(a2 + 52),  (int *)(a2 + 56));
  if ((_DWORD)result)
  {
    *(_DWORD *)(a2 + 32) = (_DWORD)result;
LABEL_6:
    *(NDR_record_t *)(a2 + 24) = NDR_record;
    return result;
  }

  *(_DWORD *)(a2 + 40) = *(_DWORD *)(a2 + 52);
  *(NDR_record_t *)(a2 + 44) = NDR_record;
  *(_DWORD *)a2 |= 0x80000000;
  *(_DWORD *)(a2 + 4) = 60;
  *(_DWORD *)(a2 + 24) = 1;
  return result;
}

_DWORD *sub_4F408(_DWORD *result, uint64_t a2)
{
  if ((*result & 0x80000000) != 0 || result[1] != 24)
  {
    *(_DWORD *)(a2 + 32) = -304;
    goto LABEL_6;
  }

  *(_DWORD *)(a2 + 36) = 16777473;
  CFDateRef result = (_DWORD *)sub_2DDF8( result[3],  (const __CFData **)(a2 + 28),  (_DWORD *)(a2 + 52),  (int *)(a2 + 56));
  if ((_DWORD)result)
  {
    *(_DWORD *)(a2 + 32) = (_DWORD)result;
LABEL_6:
    *(NDR_record_t *)(a2 + 24) = NDR_record;
    return result;
  }

  *(_DWORD *)(a2 + 40) = *(_DWORD *)(a2 + 52);
  *(NDR_record_t *)(a2 + 44) = NDR_record;
  *(_DWORD *)a2 |= 0x80000000;
  *(_DWORD *)(a2 + 4) = 60;
  *(_DWORD *)(a2 + 24) = 1;
  return result;
}

_DWORD *sub_4F4B0(_DWORD *result, uint64_t a2)
{
  if ((*result & 0x80000000) != 0 || result[1] != 24)
  {
    *(_DWORD *)(a2 + 32) = -304;
    goto LABEL_6;
  }

  *(_DWORD *)(a2 + 36) = 16777473;
  CFDateRef result = (_DWORD *)sub_2DF44( result[3],  (vm_address_t *)(a2 + 28),  (_DWORD *)(a2 + 52),  (_DWORD *)(a2 + 56));
  if ((_DWORD)result)
  {
    *(_DWORD *)(a2 + 32) = (_DWORD)result;
LABEL_6:
    *(NDR_record_t *)(a2 + 24) = NDR_record;
    return result;
  }

  *(_DWORD *)(a2 + 40) = *(_DWORD *)(a2 + 52);
  *(NDR_record_t *)(a2 + 44) = NDR_record;
  *(_DWORD *)a2 |= 0x80000000;
  *(_DWORD *)(a2 + 4) = 60;
  *(_DWORD *)(a2 + 24) = 1;
  return result;
}

uint64_t sub_4F558(uint64_t result, uint64_t a2)
{
  if ((*(_DWORD *)result & 0x80000000) != 0 || *(_DWORD *)(result + 4) != 48)
  {
    *(_DWORD *)(a2 + 32) = -304;
    NDR_record_t v3 = NDR_record;
  }

  else
  {
    CFDateRef result = sub_2DF74(*(unsigned int *)(result + 12), (char *)(result + 32), (_DWORD *)(a2 + 36), (_DWORD *)(a2 + 40));
    *(_DWORD *)(a2 + 32) = result;
    NDR_record_t v3 = NDR_record;
    if (!(_DWORD)result)
    {
      *(NDR_record_t *)(a2 + 24) = NDR_record;
      *(_DWORD *)(a2 + 4) = 44;
      return result;
    }
  }

  *(NDR_record_t *)(a2 + 24) = v3;
  return result;
}

_DWORD *sub_4F5DC(_DWORD *result, uint64_t a2)
{
  if ((*result & 0x80000000) != 0 || result[1] != 176)
  {
    *(_DWORD *)(a2 + 32) = -304;
    NDR_record_t v3 = NDR_record;
  }

  else
  {
    CFDateRef result = (_DWORD *)sub_2DAF0( result[3],  (uint64_t)(result + 8),  (uint64_t)(result + 12),  (_DWORD *)(a2 + 36));
    *(_DWORD *)(a2 + 32) = (_DWORD)result;
    NDR_record_t v3 = NDR_record;
    if (!(_DWORD)result)
    {
      *(NDR_record_t *)(a2 + 24) = NDR_record;
      *(_DWORD *)(a2 + 4) = 40;
      return result;
    }
  }

  *(NDR_record_t *)(a2 + 24) = v3;
  return result;
}

uint64_t sub_4F660(_DWORD *a1, uint64_t a2)
{
  int v2 = a1[2];
  *(_DWORD *)a2 = *a1 & 0x1F;
  *(_DWORD *)(a2 + 4) = 36;
  int v3 = a1[5] + 100;
  *(_DWORD *)(a2 + 8) = v2;
  *(_DWORD *)(a2 + 12) = 0;
  *(_DWORD *)(a2 + 16) = 0;
  *(_DWORD *)(a2 + 20) = v3;
  int v4 = a1[5];
  if ((v4 - 20022) >= 0xFFFFFFEA
    && (NDR_record_t v5 = (void (*)(void))*(&_ipconfig_subsystem + 5 * (v4 - 20000) + 5)) != 0LL)
  {
    v5();
    return 1LL;
  }

  else
  {
    uint64_t result = 0LL;
    *(NDR_record_t *)(a2 + 24) = NDR_record;
    *(_DWORD *)(a2 + 32) = -303;
  }

  return result;
}

uint64_t sub_4F6F0(int a1, uint64_t a2)
{
  return ioctl(a1, 0x40044266uLL, a2);
}

uint64_t sub_4F718(int a1)
{
  if (a1 < 0) {
    return 0LL;
  }
  else {
    return close(a1);
  }
}

uint64_t sub_4F728()
{
  uint64_t v0 = open(__str, 2, 0LL);
  if ((v0 & 0x80000000) != 0)
  {
    if (*__error() != 16) {
      return v0;
    }
    for (int i = 1; ; ++i)
    {
      snprintf(__str, 0x100uLL, "/dev/bpf%d", i);
      uint64_t v0 = open(__str, 2, 0LL);
      if ((v0 & 0x80000000) == 0) {
        break;
      }
      if (*__error() != 16) {
        return v0;
      }
    }
  }

  int v3 = 900;
  ioctl(v0, 0x8004427BuLL, &v3);
  return v0;
}

uint64_t sub_4F830(int a1, uint64_t a2)
{
  return ioctl(a1, 0x8020426CuLL, v4);
}

uint64_t sub_4F8A8(int a1, int a2)
{
  int v3 = a2;
  return ioctl(a1, 0x80044270uLL, &v3);
}

uint64_t sub_4F8D8(int a1, int a2)
{
  int v3 = a2;
  return ioctl(a1, 0x80044275uLL, &v3);
}

uint64_t sub_4F908(int a1)
{
  uint64_t v4 = 6LL;
  int v2 = 1;
  int v3 = &v4;
  return ioctl(a1, 0x80104267uLL, &v2);
}

uint64_t sub_4F978(int a1, int a2, int a3, int a4)
{
  v7[0] = 40;
  v7[1] = a2;
  _OWORD v7[2] = 16777237;
  v7[3] = a3;
  v7[4] = 6;
  v7[5] = a4;
  uint64_t v8 = 6LL;
  int v5 = 4;
  uint64_t v6 = v7;
  return ioctl(a1, 0x80104267uLL, &v5);
}

ssize_t sub_4FA00(int a1, const void *a2, int a3)
{
  return write(a1, a2, a3);
}

void sub_4FA18(const void **a1)
{
  if (a1)
  {
    int v2 = *a1;
    if (v2)
    {
      CFRelease(v2);
      *a1 = 0LL;
    }
  }

CFPropertyListRef sub_4FA48(const char *a1)
{
  if (stat(a1, &v11) < 0) {
    return 0LL;
  }
  off_t st_size = v11.st_size;
  if (!v11.st_size) {
    return 0LL;
  }
  int v3 = malloc(v11.st_size);
  if (!v3) {
    return 0LL;
  }
  uint64_t v4 = v3;
  int v5 = open(a1, 0);
  if ((v5 & 0x80000000) == 0)
  {
    int v6 = v5;
    read(v5, v4, st_size);
    close(v6);
  }

  uint64_t v7 = CFDataCreateWithBytesNoCopy(0LL, (const UInt8 *)v4, st_size, kCFAllocatorNull);
  if (v7)
  {
    uint64_t v8 = v7;
    CFPropertyListRef v9 = CFPropertyListCreateWithData(0LL, v7, 0LL, 0LL, 0LL);
    CFRelease(v8);
  }

  else
  {
    CFPropertyListRef v9 = 0LL;
  }

  free(v4);
  return v9;
}

uint64_t sub_4FB24(CFPropertyListRef propertyList, const char *a2, unsigned int a3)
{
  if (!propertyList) {
    return 0LL;
  }
  Data = CFPropertyListCreateData(0LL, propertyList, kCFPropertyListXMLFormat_v1_0, 0LL, 0LL);
  if (!Data) {
    return 0LL;
  }
  int v6 = Data;
  BytePtr = CFDataGetBytePtr(Data);
  size_t Length = CFDataGetLength(v6);
  snprintf(__str, 0x400uLL, "%s-", a2);
  int v9 = open(__str, 1537, a3);
  if (v9 < 0)
  {
    uint64_t v11 = 0xFFFFFFFFLL;
  }

  else
  {
    int v10 = v9;
    if (write(v9, BytePtr, Length) == Length)
    {
      rename(__str, a2);
      uint64_t v11 = 0LL;
    }

    else
    {
      uint64_t v11 = 0xFFFFFFFFLL;
    }

    close(v10);
  }

  CFRelease(v6);
  return v11;
}

uint64_t sub_4FC44(const __CFString *a1, UInt8 *a2, int a3, Boolean a4)
{
  CFIndex usedBufLen = 0LL;
  v11.length = CFStringGetLength(a1);
  v11.location = 0LL;
  CFStringGetBytes(a1, v11, 0x8000100u, 0, a4, a2, a3 - 1, &usedBufLen);
  int v8 = usedBufLen;
  if (a2) {
    a2[usedBufLen] = 0;
  }
  return (v8 + 1);
}

uint64_t sub_4FCC8(const __CFString *a1, in_addr *a2)
{
  a2->in_addr_t s_addr = 0;
  CFTypeID TypeID = CFStringGetTypeID();
  if (!a1 || CFGetTypeID(a1) != TypeID) {
    return 0LL;
  }
  uint64_t result = CFStringGetCString(a1, buffer, 64LL, 0x600u);
  if ((_DWORD)result) {
    return inet_aton(buffer, a2) == 1;
  }
  return result;
}

uint64_t sub_4FD78(const __CFString *a1, void *a2)
{
  *a2 = 0LL;
  a2[1] = 0LL;
  CFTypeID TypeID = CFStringGetTypeID();
  if (!a1 || CFGetTypeID(a1) != TypeID) {
    return 0LL;
  }
  uint64_t result = CFStringGetCString(a1, buffer, 64LL, 0x600u);
  if ((_DWORD)result) {
    return inet_pton(30, buffer, a2) == 1;
  }
  return result;
}

uint64_t sub_4FE2C(const __CFString *a1, _DWORD *a2)
{
  unint64_t v3 = strtoul(__str, 0LL, 0);
  if (v3 == -1LL) {
    return 0LL;
  }
  int v4 = v3;
  if (*__error() == 34) {
    return 0LL;
  }
  *a2 = v4;
  return 1LL;
}

uint64_t sub_4FEC8(const __CFString *a1, _DWORD *a2)
{
  CFTypeID TypeID = CFStringGetTypeID();
  if (!a1)
  {
    CFBooleanGetTypeID();
    CFNumberGetTypeID();
    return 0LL;
  }

  if (CFGetTypeID(a1) == TypeID) {
    return (sub_4FE2C(a1, a2) & 1) != 0;
  }
  CFTypeID v6 = CFBooleanGetTypeID();
  if (CFGetTypeID(a1) != v6)
  {
    CFTypeID v7 = CFNumberGetTypeID();
    if (CFGetTypeID(a1) == v7)
    {
      uint64_t result = CFNumberGetValue((CFNumberRef)a1, kCFNumberSInt32Type, a2);
      if (!(_DWORD)result) {
        return result;
      }
      return 1LL;
    }

    return 0LL;
  }

  *a2 = CFBooleanGetValue((CFBooleanRef)a1);
  return 1LL;
}

void sub_4FF88(__CFDictionary *a1, const void *a2, void *a3)
{
  values = a3;
  CFArrayRef v5 = CFArrayCreate(0LL, (const void **)&values, 1LL, &kCFTypeArrayCallBacks);
  if (v5)
  {
    CFArrayRef v6 = v5;
    CFDictionarySetValue(a1, a2, v5);
    CFRelease(v6);
  }

void sub_4FFF4(__CFDictionary *a1, const void *a2, int a3)
{
  CFArrayRef v5 = (__CFString *)CFStringCreateWithFormat( 0LL,  0LL,  @"%d.%d.%d.%d",  a3,  BYTE1(a3),  BYTE2(a3),  HIBYTE(a3));
  sub_4FF88(a1, a2, v5);
  CFRelease(v5);
}

CFStringRef sub_50068(int a1)
{
  return CFStringCreateWithFormat(0LL, 0LL, @"%d.%d.%d.%d", a1, BYTE1(a1), BYTE2(a1), HIBYTE(a1));
}

void sub_500AC(__CFDictionary *a1, const void *a2, int a3)
{
  CFStringRef v5 = CFStringCreateWithFormat(0LL, 0LL, @"%d.%d.%d.%d", a3, BYTE1(a3), BYTE2(a3), HIBYTE(a3));
  CFDictionarySetValue(a1, a2, v5);
  CFRelease(v5);
}

CFStringRef sub_50120(void *a1)
{
  int v1 = inet_ntop(30, a1, v3, 0x2Eu);
  return CFStringCreateWithCString(0LL, v1, 0x600u);
}

void sub_50188(__CFDictionary *a1, const void *a2, void *a3)
{
  CFStringRef v5 = inet_ntop(30, a3, v7, 0x2Eu);
  CFStringRef v6 = CFStringCreateWithCString(0LL, v5, 0x600u);
  CFDictionarySetValue(a1, a2, v6);
  CFRelease(v6);
}

void sub_50228(__CFDictionary *a1, const void *a2, char *cStr)
{
  CFStringRef v5 = CFStringCreateWithCString(0LL, cStr, 0x8000100u);
  CFDictionarySetValue(a1, a2, v5);
  CFRelease(v5);
}

void sub_5027C(__CFDictionary *a1, const void *a2, CFAbsoluteTime a3)
{
  CFDateRef v5 = CFDateCreate(0LL, a3);
  CFDictionarySetValue(a1, a2, v5);
  CFRelease(v5);
}

void sub_502C4(__CFDictionary *a1, const void *a2, uint64_t a3)
{
  uint64_t valuePtr = a3;
  CFNumberRef v5 = CFNumberCreate(0LL, kCFNumberSInt64Type, &valuePtr);
  CFDictionarySetValue(a1, a2, v5);
  CFRelease(v5);
}

void sub_50324(const __CFArray *a1, const void *a2)
{
  CFIndex Count = CFArrayGetCount(a1);
  if (Count < 1)
  {
LABEL_5:
    CFArrayAppendValue(a1, a2);
  }

  else
  {
    CFIndex v5 = Count;
    CFIndex v6 = 0LL;
    while (1)
    {
      ValueAtIndex = CFArrayGetValueAtIndex(a1, v6);
      if (CFEqual(ValueAtIndex, a2)) {
        break;
      }
      if (v5 == ++v6) {
        goto LABEL_5;
      }
    }
  }

CFTypeRef sub_5039C(CFStringRef theString, CFStringRef separatorString, CFIndex a3)
{
  CFArrayRef ArrayBySeparatingStrings = CFStringCreateArrayBySeparatingStrings(0LL, theString, separatorString);
  if (!ArrayBySeparatingStrings) {
    return 0LL;
  }
  CFIndex v5 = ArrayBySeparatingStrings;
  if (CFArrayGetCount(ArrayBySeparatingStrings) <= a3)
  {
    CFTypeRef v7 = 0LL;
  }

  else
  {
    ValueAtIndex = CFArrayGetValueAtIndex(v5, a3);
    CFTypeRef v7 = CFRetain(ValueAtIndex);
  }

  CFRelease(v5);
  return v7;
}

void sub_5040C(CFMutableStringRef theString, uint64_t a2, int a3, int a4)
{
  if (a3 >= 1)
  {
    uint64_t v12 = v4;
    uint64_t v13 = v5;
    uint64_t v9 = 0LL;
    uint64_t v10 = a3;
    do
    {
      if (v9)
      {
        if (a4 != 32 || (v9 & 7) != 0) {
          *(_WORD *)CFRange v11 = a4;
        }
        else {
          strcpy(v11, "  ");
        }
      }

      else
      {
        v11[0] = 0;
      }

      CFStringAppendFormat(theString, 0LL, @"%s%02x", v11, *(unsigned __int8 *)(a2 + v9++));
    }

    while (v10 != v9);
  }

UInt8 *sub_504C4(const __CFString *a1, CFRange a2, CFStringEncoding a3)
{
  CFIndex length = a2.length;
  CFIndex location = a2.location;
  CFIndex usedBufLen = 0LL;
  CFStringGetBytes(a1, a2, a3, 0, 0, 0LL, 0LL, &usedBufLen);
  CFIndex v7 = usedBufLen;
  if (!usedBufLen) {
    return 0LL;
  }
  int v8 = (UInt8 *)malloc(usedBufLen + 1);
  v11.CFIndex location = location;
  v11.CFIndex length = length;
  CFStringGetBytes(a1, v11, a3, 0, 0, v8, v7, &usedBufLen);
  v8[usedBufLen] = 0;
  return v8;
}

UInt8 *sub_50578(const __CFString *a1, CFStringEncoding a2)
{
  v5.CFIndex length = CFStringGetLength(a1);
  v5.CFIndex location = 0LL;
  return sub_504C4(a1, v5, a2);
}

CFStringRef sub_505AC(const __CFAllocator *a1)
{
  int v2 = CFUUIDCreate(a1);
  CFStringRef v3 = CFUUIDCreateString(a1, v2);
  CFRelease(v2);
  return v3;
}

CFStringRef sub_505EC(UInt8 *bytes, CFIndex numBytes)
{
  else {
    return 0LL;
  }
}

CFStringRef sub_50628(CFDataRef theData)
{
  uint64_t v2 = 0LL;
  char v3 = 1;
  do
  {
    char v4 = v3;
    BytePtr = CFDataGetBytePtr(theData);
    CFIndex Length = CFDataGetLength(theData);
    CFStringRef result = CFStringCreateWithBytes(0LL, BytePtr, Length, dword_5964C[v2], 0);
    if (result) {
      break;
    }
    char v3 = 0;
    uint64_t v2 = 1LL;
  }

  while ((v4 & 1) != 0);
  return result;
}

uint64_t sub_506A4(const void *a1, const void *a2)
{
  if (a1 && a2) {
    return CFEqual(a1, a2);
  }
  else {
    return 0LL;
  }
}

CFDataRef sub_506B8(CFPropertyListRef propertyList, _DWORD *a2)
{
  vm_address_t address = 0LL;
  *a2 = 0;
  CFStringRef result = CFPropertyListCreateData(0LL, propertyList, kCFPropertyListBinaryFormat_v1_0, 0LL, 0LL);
  if (result)
  {
    char v4 = result;
    int Length = CFDataGetLength(result);
    if (!vm_allocate(mach_task_self_, &address, Length, 1))
    {
      CFIndex v6 = (void *)address;
      BytePtr = CFDataGetBytePtr(v4);
      memmove(v6, BytePtr, Length);
      *a2 = Length;
    }

    CFRelease(v4);
    return (const __CFData *)address;
  }

  return result;
}

CFDataRef sub_5076C(UInt8 *bytes, int a2)
{
  CFStringRef result = CFDataCreateWithBytesNoCopy(0LL, bytes, a2, kCFAllocatorNull);
  if (result)
  {
    char v3 = result;
    CFPropertyListRef v4 = CFPropertyListCreateWithData(0LL, result, 0LL, 0LL, 0LL);
    CFRelease(v3);
    return (const __CFData *)v4;
  }

  return result;
}

void sub_507D4(CFMutableStringRef theString, int a2, unsigned __int8 *a3, uint64_t a4)
{
  int v4 = a4;
  switch(a2)
  {
    case 1:
      CFStringAppendFormat(theString, 0LL, @"\n");
      sub_55914(theString, (uint64_t)a3, v4);
      return;
    case 2:
      if (*a3) {
        int v8 = "TRUE";
      }
      else {
        int v8 = "FALSE";
      }
      CFStringAppendFormat(theString, 0LL, @"%s", v8);
      return;
    case 3:
      uint64_t v7 = *a3;
      goto LABEL_10;
    case 4:
      uint64_t v7 = bswap32(*(unsigned __int16 *)a3) >> 16;
      goto LABEL_10;
    case 5:
    case 6:
      uint64_t v7 = bswap32(*(_DWORD *)a3);
LABEL_10:
      CFStringAppendFormat(theString, 0LL, @"0x%x", v7);
      return;
    case 9:
      CFStringAppendFormat(theString, 0LL, @"%.*s", a4, a3);
      return;
    case 10:
      CFStringAppendFormat(theString, 0LL, @"%d.%d.%d.%d", *a3, a3[1], a3[2], a3[3]);
      return;
    case 13:
      int v20 = 0;
      uint64_t v9 = (unsigned __int8 *)sub_5311C((uint64_t)a3, a4, &v20);
      CFStringAppendFormat(theString, 0LL, @"{");
      if (!v9) {
        goto LABEL_29;
      }
      if (v20 >= 1)
      {
        for (uint64_t i = 0LL; i < v20; CFStringAppendFormat(theString, 0LL, @"%s%s", v11, *(void *)&v9[8 * i++]))
        {
          if (i) {
            CFRange v11 = ", ";
          }
          else {
            CFRange v11 = "";
          }
        }
      }

      break;
    case 14:
      uint64_t v9 = (unsigned __int8 *)sub_53924(a3, a4, &v19);
      CFStringAppendFormat(theString, 0LL, @"{");
      if (!v9) {
        goto LABEL_29;
      }
      if (v19 >= 1)
      {
        int v12 = 0;
        uint64_t v13 = v9;
        do
        {
          if (v12) {
            double v14 = "; ";
          }
          else {
            double v14 = "";
          }
          CFStringAppendFormat( theString,  0LL,  @"%s%d.%d.%d.%d/%d, %d.%d.%d.%d",  v14,  *v13,  v13[1],  v13[2],  v13[3],  *((unsigned int *)v13 + 1),  v13[8],  v13[9],  v13[10],  v13[11]);
          ++v12;
          v13 += 12;
        }

        while (v12 < v19);
      }

      break;
    default:
      return;
  }

  free(v9);
LABEL_29:
  CFStringAppendFormat(theString, 0LL, @"}", v15, v16, v17, v18);
}

void sub_50A6C(CFMutableStringRef theString, unsigned int a2, unsigned __int8 *a3, uint64_t a4)
{
  int v4 = a3;
  if (a2 <= 0xE && (unsigned int v6 = *((_DWORD *)&unk_65408 + 6 * a2 + 1)) != 0)
  {
    if (v6 <= 0xE)
    {
      uint64_t v7 = *((int *)&unk_65408 + 6 * v6);
      int v8 = (int)a4 / (int)v7;
      CFStringAppendFormat(theString, 0LL, @"{");
      if (v8 >= 1)
      {
        for (int i = 0; i != v8; ++i)
        {
          if (i) {
            CFStringAppendFormat(theString, 0LL, @", ");
          }
          sub_507D4(theString, v6, v4, v7);
          v4 += v7;
        }
      }

      CFStringAppendFormat(theString, 0LL, @"}");
    }
  }

  else
  {
    sub_507D4(theString, a2, a3, a4);
  }

BOOL sub_50B84(CFMutableStringRef theString, unsigned __int8 *a2)
{
  uint64_t v3 = *a2;
  unsigned int v4 = *((_DWORD *)&unk_65570 + 4 * v3);
  if (v4 >= 0xF)
  {
    CFStringAppendFormat(theString, 0LL, @"unknown type %d\n", *((unsigned int *)&unk_65570 + 4 * v3));
  }

  else
  {
    uint64_t v5 = a2[1];
    unsigned int v6 = a2 + 2;
    CFStringAppendFormat( theString,  0LL,  @"%s (%s): ",  *((void *)&unk_65570 + 2 * v3 + 1),  *((void *)&unk_65408 + 3 * v4 + 1));
    if ((_DWORD)v3 == 53)
    {
      unint64_t v7 = *v6;
      if (v7 > 8) {
        int v8 = "<unknown>";
      }
      else {
        int v8 = off_66570[v7];
      }
      CFStringAppendFormat(theString, 0LL, @"%s ", v8);
    }

    sub_50A6C(theString, v4, v6, v5);
    CFStringAppendFormat(theString, 0LL, @"\n", v10);
  }

  return v4 < 0xF;
}

uint64_t sub_50CA4(void *a1, unsigned __int8 *a2, int a3, char *a4)
{
  if (a4) {
    *a4 = 0;
  }
  sub_55590(a1);
  if (a3 < 1)
  {
    int v8 = 0;
    if ((a3 & 0x80000000) == 0) {
      return 1LL;
    }
    goto LABEL_16;
  }

  while (1)
  {
    int v8 = *a2;
    if (*a2) {
      break;
    }
    ++a2;
    --a3;
LABEL_9:
    if (a3 <= 0) {
      goto LABEL_14;
    }
  }

  if (v8 != 255)
  {
    uint64_t v9 = a2[1];
    sub_556EC((uint64_t)a1, (uint64_t)a2);
    a3 -= v9 + 2;
    a2 += v9 + 2;
    goto LABEL_9;
  }

  sub_556EC((uint64_t)a1, (uint64_t)a2);
  --a3;
LABEL_14:
  if ((a3 & 0x80000000) == 0) {
    return 1LL;
  }
LABEL_16:
  if (a4) {
    snprintf(a4, 0x100uLL, "parse failed near tag %d", v8);
  }
  sub_55598((uint64_t)a1);
  return 0LL;
}

unsigned __int8 *sub_50DA0(uint64_t a1, int a2, _DWORD *a3, int *a4)
{
  CFStringRef result = 0LL;
  if (a2 && a2 != 255)
  {
    if (a4) {
      int v9 = *a4;
    }
    else {
      int v9 = 0;
    }
    while (1)
    {
      uint64_t v10 = (unsigned __int8 *)sub_55644(a1, v9);
      if (*v10 == a2) {
        break;
      }
      ++v9;
    }

    if (a3) {
      *a3 = v10[1];
    }
    if (a4) {
      *a4 = v9 + 1;
    }
    return v10 + 2;
  }

  return result;
}

unsigned __int8 *sub_50E4C(uint64_t a1, int a2, int a3)
{
  CFStringRef result = sub_50DA0(a1, a2, &v6, 0LL);
  if (v6 < a3 || result == 0LL) {
    return 0LL;
  }
  return result;
}

char *sub_50E8C(uint64_t a1, int a2, _DWORD *a3)
{
  uint64_t v3 = 0LL;
  if (a2 && a2 != 255)
  {
    if ((int)sub_55628(a1) < 1)
    {
      uint64_t v3 = 0LL;
      int v8 = 0;
    }

    else
    {
      int v7 = 0;
      int v8 = 0;
      uint64_t v3 = 0LL;
      do
      {
        int v9 = (unsigned __int8 *)sub_55644(a1, v7);
        if (*v9 == a2)
        {
          uint64_t v10 = v9;
          size_t v11 = v9[1];
          if (v3)
          {
            int v12 = v11 + v8;
            uint64_t v3 = (char *)reallocf(v3, v11 + v8);
          }

          else
          {
            uint64_t v3 = (char *)malloc(v9[1]);
            int v12 = v8 + v11;
          }

          memmove(&v3[v8], v10 + 2, v11);
          int v8 = v12;
        }

        ++v7;
      }

      while (v7 < (int)sub_55628(a1));
    }

    *a3 = v8;
  }

  return v3;
}

uint64_t sub_50F80(char **a1, uint64_t a2, unsigned int a3, char *a4)
{
  if (a4)
  {
    *a4 = 0;
    if (a3 <= 0xEF)
    {
      snprintf(a4, 0x100uLL, "packet is too short: %d < %d", a3, 240);
      return 0LL;
    }

    if (*(_DWORD *)(a2 + 236) != 1666417251)
    {
      uint64_t result = 0LL;
      strcpy(a4, "missing magic number");
      return result;
    }
  }

  else if (a3 < 0xF0 || *(_DWORD *)(a2 + 236) != 1666417251)
  {
    return 0LL;
  }

  uint64_t result = sub_50CA4(a1, (unsigned __int8 *)(a2 + 240), a3 - 240, a4);
  if ((_DWORD)result)
  {
    int v9 = sub_50DA0((uint64_t)a1, 52, &v12, 0LL);
    if (v9 && v12 == 1)
    {
      uint64_t v10 = v9;
      sub_55590(v11);
      if ((*v10 | 2) == 3 && sub_50CA4(v11, (unsigned __int8 *)(a2 + 108), 128, 0LL))
      {
        sub_55838(a1, (uint64_t)v11);
        sub_55598((uint64_t)v11);
      }

      if ((*v10 & 0xFE) == 2)
      {
        if (sub_50CA4(v11, (unsigned __int8 *)(a2 + 44), 64, 0LL))
        {
          sub_55838(a1, (uint64_t)v11);
          sub_55598((uint64_t)v11);
        }
      }
    }

    return 1LL;
  }

  return result;
}

uint64_t sub_51108(__CFString *a1, uint64_t a2)
{
  uint64_t v4 = sub_55628(a2);
  CFStringAppendFormat(a1, 0LL, @"Options count is %d\n", v4);
  uint64_t result = sub_55628(a2);
  if ((int)result >= 1)
  {
    int v6 = 0;
    do
    {
      int v7 = (unsigned __int8 *)sub_55644(a2, v6);
      if (!sub_50B84(a1, v7)) {
        CFStringAppendFormat(a1, 0LL, @"undefined tag %d len %d\n", *v7, v7[1]);
      }
      ++v6;
      uint64_t result = sub_55628(a2);
    }

    while (v6 < (int)result);
  }

  return result;
}

uint64_t sub_511CC(uint64_t a1, unsigned __int8 *a2, int a3)
{
  if (a3 < 1) {
    return 0LL;
  }
  LODWORD(v5) = 0;
  uint64_t v6 = a3;
  do
  {
    int v7 = *a2++;
    if (sub_50DA0(a1, v7, 0LL, 0LL)) {
      uint64_t v5 = (v5 + 1);
    }
    else {
      uint64_t v5 = v5;
    }
    --v6;
  }

  while (v6);
  return v5;
}

double sub_51234(uint64_t a1, void *a2, int a3, int a4)
{
  double result = 0.0;
  *(_OWORD *)(a1 + 272) = 0u;
  *(_OWORD *)(a1 + 288) = 0u;
  *(_OWORD *)(a1 + 24snprintf(__str, 0x100uLL, "/dev/bpf%d", 0) = 0u;
  *(_OWORD *)(a1 + 256) = 0u;
  *(_OWORD *)(a1 + 208) = 0u;
  *(_OWORD *)(a1 + 224) = 0u;
  *(_OWORD *)(a1 + 176) = 0u;
  *(_OWORD *)(a1 + 192) = 0u;
  *(_OWORD *)(a1 + 144) = 0u;
  *(_OWORD *)(a1 + 16snprintf(__str, 0x100uLL, "/dev/bpf%d", 0) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 128) = 0u;
  *(_OWORD *)(a1 + 8snprintf(__str, 0x100uLL, "/dev/bpf%d", 0) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)a1 = 0u;
  *(void *)a1 = 287454020LL;
  *(void *)(a1 + 8) = a2;
  *(_DWORD *)(a1 + 16) = a3;
  *(_DWORD *)(a1 + 296) = a4;
  return result;
}

double sub_512B0(uint64_t a1, void *a2, int a3)
{
  return sub_51234(a1, a2, a3, 1);
}

uint64_t sub_512B8(uint64_t a1, int a2, int a3, void *__src)
{
  *(_BYTE *)(a1 + 4snprintf(__str, 0x100uLL, "/dev/bpf%d", 0) = 0;
  uint64_t v5 = (char *)(a1 + 40);
  if (a3 >= 256)
  {
    snprintf(v5, 0x100uLL, "tag %d option %d > %d", __src);
    return 1LL;
  }

  if (*(void *)a1 != 287454020LL)
  {
    uint64_t v6 = "dhcpoa_t not initialized - internal error!!!";
    goto LABEL_7;
  }

  if (*(_DWORD *)(a1 + 24))
  {
    uint64_t v6 = "attempt to add data after end tag";
LABEL_7:
    __strlcpy_chk(v5, v6, 256LL, 256LL);
    return 1LL;
  }

  if (a2)
  {
    if (a2 == 255)
    {
      uint64_t v8 = *(int *)(a1 + 20);
      if ((int)v8 >= *(_DWORD *)(a1 + 16))
      {
        snprintf(v5, 0x100uLL, "can't add end tag %d > %d", __src);
        return 1LL;
      }

      *(_BYTE *)(*(void *)(a1 + 8) + v8) = -1;
      ++*(_DWORD *)(a1 + 20);
      *(_DWORD *)(a1 + 24) = 1;
      goto LABEL_24;
    }

    int v11 = a3 + 2;
    uint64_t v12 = *(int *)(a1 + 20);
    if (a3 + 2 + (int)v12 + *(_DWORD *)(a1 + 296) > *(_DWORD *)(a1 + 16))
    {
      snprintf(v5, 0x100uLL, "can't add tag %d (%d > %d)", __src);
      return 2LL;
    }

    *(_BYTE *)(*(void *)(a1 + 8) + v12) = a2;
    *(_BYTE *)(*(int *)(a1 + 20) + *(void *)(a1 + 8) + 1LL) = a3;
    if (a3) {
      memmove((void *)(*(int *)(a1 + 20) + *(void *)(a1 + 8) + 2LL), __src, a3);
    }
    int v13 = *(_DWORD *)(a1 + 28);
    int v14 = *(_DWORD *)(a1 + 20);
    *(_DWORD *)(a1 + 28) = v14;
    *(_DWORD *)(a1 + 32) = v13;
    int v10 = v11 + v14;
  }

  else
  {
    uint64_t v9 = *(int *)(a1 + 20);
    if (*(_DWORD *)(a1 + 296) + (int)v9 >= *(_DWORD *)(a1 + 16))
    {
      snprintf(v5, 0x100uLL, "can't add pad tag %d > %d", __src);
      return 2LL;
    }

    *(_BYTE *)(*(void *)(a1 + 8) + v9) = 0;
    int v10 = *(_DWORD *)(a1 + 20) + 1;
  }

  *(_DWORD *)(a1 + 2snprintf(__str, 0x100uLL, "/dev/bpf%d", 0) = v10;
LABEL_24:
  uint64_t result = 0LL;
  ++*(_DWORD *)(a1 + 36);
  return result;
}

uint64_t sub_5147C(uint64_t result)
{
  if (result)
  {
    if (*(void *)result == 287454020LL) {
      return *(unsigned int *)(result + 20);
    }
    else {
      return 0LL;
    }
  }

  return result;
}

uint64_t sub_514A4(uint64_t a1, char a2)
{
  char __src = a2;
  return sub_512B8(a1, 53, 1, &__src);
}

const char *sub_514D0(uint64_t *a1)
{
  uint64_t result = "<bad parameter>";
  if (a1)
  {
    uint64_t v4 = *a1;
    uint64_t v3 = a1 + 5;
    if (v4 == 287454020) {
      return (const char *)v3;
    }
  }

  return result;
}

void sub_514F8(CFMutableStringRef theString, unsigned __int8 *a2, uint64_t a3)
{
  unsigned int v3 = a3;
  if (a3 > 0xEB)
  {
    sub_50C9C(v7);
    sub_50F80(v7, (uint64_t)a2, v3, 0LL);
    sub_51588(theString, a2, v6, (uint64_t)v7);
    sub_50CA0((uint64_t)v7);
  }

  else
  {
    CFStringAppendFormat(theString, 0LL, @"Packet is too short %d < %d\n", a3, 236LL);
  }

void sub_51588(__CFString *a1, unsigned __int8 *a2, uint64_t a3, uint64_t a4)
{
  CFStringAppendFormat(a1, 0LL, @"op = ");
  int v7 = *a2;
  if (v7 == 2)
  {
    CFStringAppendFormat(a1, 0LL, @"BOOTREPLY\n");
  }

  else if (v7 == 1)
  {
    CFStringAppendFormat(a1, 0LL, @"BOOTREQUEST\n");
  }

  else
  {
    CFStringAppendFormat(a1, 0LL, @"OP(%d)\n", *a2);
  }

  CFStringAppendFormat(a1, 0LL, @"htype = %d\n", a2[1]);
  CFStringAppendFormat(a1, 0LL, @"flags = 0x%x\n", bswap32(*((unsigned __int16 *)a2 + 5)) >> 16);
  unsigned int v8 = a2[2];
  if (v8 >= 0x11)
  {
    int v10 = 16;
    CFStringAppendFormat(a1, 0LL, @"hlen = %d (invalid > %lu)\n", a2[2], 16LL);
    uint64_t v9 = "[truncated] ";
  }

  else
  {
    CFStringAppendFormat(a1, 0LL, @"hlen = %d\n", a2[2]);
    uint64_t v9 = "";
    int v10 = v8;
  }

  CFStringAppendFormat(a1, 0LL, @"hops = %d\n", a2[3]);
  CFStringAppendFormat(a1, 0LL, @"xid = 0x%lx\n", bswap32(*((_DWORD *)a2 + 1)));
  CFStringAppendFormat(a1, 0LL, @"secs = %hu\n", bswap32(*((unsigned __int16 *)a2 + 4)) >> 16);
  int v11 = inet_ntop(2, a2 + 12, v16, 0x10u);
  CFStringAppendFormat(a1, 0LL, @"ciaddr = %s\n", v11);
  uint64_t v12 = inet_ntop(2, a2 + 16, v16, 0x10u);
  CFStringAppendFormat(a1, 0LL, @"yiaddr = %s\n", v12);
  int v13 = inet_ntop(2, a2 + 20, v16, 0x10u);
  CFStringAppendFormat(a1, 0LL, @"siaddr = %s\n", v13);
  int v14 = inet_ntop(2, a2 + 24, v16, 0x10u);
  CFStringAppendFormat(a1, 0LL, @"giaddr = %s\n", v14);
  CFStringAppendFormat(a1, 0LL, @"chaddr = %s", v9);
  if (v10)
  {
    for (uint64_t i = 0LL; i != v10; CFStringAppendFormat(a1, 0LL, @"%0x", a2[i++ + 28]))
    {
      if (i) {
        CFStringAppendFormat(a1, 0LL, @":");
      }
    }
  }

  CFStringAppendFormat(a1, 0LL, @"\n");
  CFStringAppendFormat(a1, 0LL, @"sname = %.*s\n", 64LL, a2 + 44);
  CFStringAppendFormat(a1, 0LL, @"file = %.*s\n", 128LL, a2 + 108);
  if (a4)
  {
    if ((int)sub_50C94(a4) >= 1)
    {
      CFStringAppendFormat(a1, 0LL, @"options:\n");
      sub_51108(a1, a4);
    }
  }

BOOL sub_518EC(uint64_t a1, int a2, int a3, void *a4, unsigned int a5)
{
  uint64_t v6 = 0LL;
  if (a3 == 24) {
    size_t v7 = 0LL;
  }
  else {
    size_t v7 = a5;
  }
  if (*(_BYTE *)a1 == 2) {
    return bswap32(*(_DWORD *)(a1 + 4)) == a2
  }
        && *(unsigned __int8 *)(a1 + 1) == a3
  return v6;
}

uint64_t sub_51964(const void *a1, size_t a2, _OWORD *a3, double a4)
{
  uint64_t Instance = _CFRuntimeCreateInstance(0LL, qword_6C2B0, (int)a2 + 56, 0LL);
  memcpy((void *)(Instance + 72), a1, a2);
  *(void *)(Instance + 64) = a2;
  *(_OWORD *)(Instance + 16) = *a3;
  *(void *)(Instance + 32) = sub_50120(a3);
  *(double *)(Instance + 4snprintf(__str, 0x100uLL, "/dev/bpf%d", 0) = a4;
  unsigned int v9 = *(_DWORD *)(Instance + 64) - 16;
  sub_55590((void *)(Instance + 48));
  if (v9 >= 2)
  {
    uint64_t v10 = Instance + 88;
    while (1)
    {
      uint64_t v11 = 8LL * *(unsigned __int8 *)(v10 + 1);
      sub_556EC(Instance + 48, v10);
      v10 += v11;
      v9 -= v11;
      if (v9 < 2) {
        return Instance;
      }
    }

    sub_55598(Instance + 48);
    CFRelease((CFTypeRef)Instance);
    return 0LL;
  }

  return Instance;
}

double sub_51A70(uint64_t a1)
{
  return *(double *)(a1 + 40);
}

BOOL sub_51A78(uint64_t a1, unsigned int a2, double a3)
{
  if (!a2) {
    return 1LL;
  }
  if (a2 == -1) {
    return 0LL;
  }
  double v4 = *(double *)(a1 + 40);
  return a3 - v4 >= (double)a2 || v4 > a3;
}

uint64_t sub_51AB4(uint64_t a1)
{
  return a1 + 16;
}

__CFString *sub_51ABC(uint64_t a1)
{
  CFMutableStringRef Mutable = CFStringCreateMutable(0LL, 0LL);
  sub_51AF8(a1, Mutable);
  return Mutable;
}

void sub_51AF8(uint64_t a1, CFMutableStringRef theString)
{
  uint64_t v4 = *(unsigned __int8 *)(a1 + 77);
  unsigned int v5 = *(unsigned __int16 *)(a1 + 78);
  uint64_t v6 = __rev16(v5);
  if (v5 == 0xFFFF) {
    size_t v7 = " (max)";
  }
  else {
    size_t v7 = "";
  }
  CFStringAppendFormat( theString,  0LL,  @"from %@, length %ld, hop limit %d, lifetime %us%s, reachable %dms, retransmit %dms, flags 0x%x",  *(void *)(a1 + 32),  *(void *)(a1 + 64),  *(unsigned __int8 *)(a1 + 76),  v6,  v7,  bswap32(*(_DWORD *)(a1 + 80)),  bswap32(*(_DWORD *)(a1 + 84)),  v4);
  if ((_DWORD)v4)
  {
    CFStringAppend(theString, @"=[");
    if ((v4 & 0x80) != 0)
    {
      CFStringAppend(theString, @" managed");
      if ((v4 & 0x40) == 0)
      {
LABEL_7:
        if ((v4 & 0x20) == 0) {
          goto LABEL_8;
        }
        goto LABEL_143;
      }
    }

    else if ((v4 & 0x40) == 0)
    {
      goto LABEL_7;
    }

    CFStringAppend(theString, @" other");
    if ((v4 & 0x20) == 0)
    {
LABEL_8:
      if ((v4 & 4) == 0)
      {
LABEL_10:
        CFStringAppend(theString, @" ]");
        CFStringAppend(theString, @", pref=");
        CFStringAppendFormat(theString, 0LL, @"%s\n", *(char **)((char *)off_66630 + (v4 & 0x18)));
        goto LABEL_12;
      }

LABEL_143:
    CFStringAppend(theString, @" home-agent");
    if ((v4 & 4) == 0) {
      goto LABEL_10;
    }
    goto LABEL_9;
  }

  CFStringAppend(theString, @"\n");
LABEL_12:
  uint64_t v8 = a1 + 48;
  int v9 = sub_55628(a1 + 48);
  if (v9 >= 1)
  {
    int v10 = v9;
    int v11 = 0;
    uint64_t v64 = a1 + 48;
    int v65 = v9;
    do
    {
      uint64_t v12 = (unsigned __int8 *)sub_55644(v8, v11);
      int v13 = v12;
      uint64_t v14 = *v12;
      if (*v12 <= 0x14u)
      {
        uint64_t v15 = "source link-address";
        switch(*v12)
        {
          case 1u:
            break;
          case 2u:
            uint64_t v15 = "target link-address";
            break;
          case 3u:
            uint64_t v15 = "prefix info";
            break;
          case 4u:
            uint64_t v15 = "redirected header";
            break;
          case 5u:
            uint64_t v15 = "mtu";
            break;
          default:
            goto LABEL_33;
        }
      }

      else
      {
        if (*v12 > 0x1Eu)
        {
          switch((_DWORD)v14)
          {
            case 0x1F:
              uint64_t v15 = "dnssl";
              goto LABEL_34;
            case 0x25:
              uint64_t v15 = "captive portal";
              goto LABEL_34;
            case 0x26:
              uint64_t v15 = "pref64";
              goto LABEL_34;
          }
        }

        else
        {
          switch((_DWORD)v14)
          {
            case 0x15:
              uint64_t v15 = "provisioning domain";
              goto LABEL_34;
            case 0x18:
              uint64_t v15 = "route info";
              goto LABEL_34;
            case 0x19:
              uint64_t v15 = "rdnss";
              goto LABEL_34;
          }
        }

LABEL_101:
            uint64_t v8 = v64;
LABEL_129:
            int v10 = v65;
            goto LABEL_133;
          }

          if (v18 == 31)
          {
            *(_DWORD *)unsigned __int8 v69 = 0;
            if (v16 > 1)
            {
              unsigned int v39 = *((_DWORD *)v13 + 1);
              CFStringAppend(theString, @" lifetime ");
              if (v39 == -1) {
                CFStringAppend(theString, @"infinite");
              }
              else {
                CFStringAppendFormat(theString, 0LL, @"%us", bswap32(v39));
              }
              CFStringAppend(theString, @", domain(s): ");
              uint64_t v48 = (uint64_t)(v13 + 8);
              uint64_t v49 = (v17 - 8);
              while (!*(_BYTE *)(v48 + (v49 - 2)))
              {
                if (v49-- <= 2)
                {
                  LODWORD(v49) = 1;
                  goto LABEL_116;
                }
              }

              if (!(_DWORD)v49)
              {
                CFStringAppendFormat(theString, 0LL, @"no domains ", v57, v60);
                goto LABEL_40;
              }

LABEL_116:
              uint64_t v51 = sub_5311C(v48, v49, (int *)v69);
              uint64_t v52 = v51;
              if (*(int *)v69 < 1)
              {
                if (!v51) {
                  goto LABEL_129;
                }
              }

              else
              {
                uint64_t v53 = 0LL;
                do
                {
                  if (v53) {
                    uint64_t v54 = ", ";
                  }
                  else {
                    uint64_t v54 = "";
                  }
                  CFStringAppendFormat(theString, 0LL, @"%s%s", v54, *(void *)&v52[8 * v53++]);
                }

                while (v53 < *(int *)v69);
              }

              free(v52);
            }

            else
            {
              CFStringAppendFormat(theString, 0LL, @"truncated (%d < %d) ", 8LL * v16, 16LL);
LABEL_40:
              sub_5040C(theString, (uint64_t)(v13 + 2), v17 - 2, 58);
            }

            goto LABEL_129;
          }

          goto LABEL_81;
        }

        if (v18 != 37)
        {
          if (v18 == 38)
          {
            if (sub_52FF0((uint64_t)v13, 8LL * v16, (char *)__dst, &v67, &v66, theString))
            {
              int v20 = inet_ntop(30, __dst, v69, 0x2Eu);
              CFStringAppendFormat(theString, 0LL, @"%s/%d lifetime %us", v20, v67, v66);
            }

            goto LABEL_133;
          }

          goto LABEL_81;
        }

        if (!v16)
        {
          uint64_t v24 = v17;
          uint64_t v25 = 3LL;
          goto LABEL_80;
        }

        int v27 = v13[2];
        uint64_t v26 = v13 + 2;
        if (v27)
        {
          uint64_t v28 = 0LL;
          while (!v26[(v17 - 4 + v28)])
          {
            --v28;
            if ((v17 - 8) + v28 + 7 <= 2)
            {
              uint64_t v29 = 1LL;
              goto LABEL_93;
            }
          }

          uint64_t v29 = (v17 + v28 - 2);
LABEL_93:
          CFStringAppendFormat(theString, 0LL, @"uri=%.*s", v29, v26, v62);
          goto LABEL_133;
        }

        CFStringAppend(theString, @"empty uri: ");
        int v41 = v17 - 2;
        int v42 = theString;
        uint64_t v40 = (uint64_t)v26;
LABEL_82:
        sub_5040C(v42, v40, v41, 58);
        goto LABEL_133;
      }

      if (v18 == 3)
      {
        if (v16 > 3)
        {
          uint64_t v35 = inet_ntop(30, v13 + 16, v69, 0x2Eu);
          CFStringAppendFormat(theString, 0LL, @" %s/%d, flags [", v35, v13[2]);
          int v36 = (char)v13[3];
          if (v36 < 0)
          {
            CFStringAppend(theString, @" onlink");
            if ((v13[3] & 0x40) != 0) {
LABEL_73:
            }
              CFStringAppend(theString, @" auto");
          }

          else if ((v36 & 0x40) != 0)
          {
            goto LABEL_73;
          }

          CFStringAppend(theString, @" ], valid time ");
          unsigned int v37 = *((_DWORD *)v13 + 1);
          int v38 = *((_DWORD *)v13 + 2);
          if (v37 == -1) {
            CFStringAppendFormat(theString, 0LL, @"infinite", v58);
          }
          else {
            CFStringAppendFormat(theString, 0LL, @"%us", bswap32(v37));
          }
          CFStringAppend(theString, @", pref. time ");
          if (v38 == -1) {
            CFStringAppendFormat(theString, 0LL, @"infinite", v59, v61, v62);
          }
          else {
            CFStringAppendFormat(theString, 0LL, @"%us", bswap32(*((_DWORD *)v13 + 2)), v61, v62);
          }
          goto LABEL_133;
        }

        uint64_t v24 = 8LL * v16;
        uint64_t v25 = 32LL;
LABEL_80:
        CFStringAppendFormat(theString, 0LL, @"truncated (%d < %d) ", v24, v25);
LABEL_81:
        uint64_t v40 = (uint64_t)(v13 + 2);
        int v41 = v17 - 2;
        int v42 = theString;
        goto LABEL_82;
      }

      if (v18 == 21)
      {
        *(void *)unsigned __int8 v69 = 0LL;
        if (v16)
        {
          if (8 * v13[1])
          {
            unsigned __int8 v30 = v13[2];
            unsigned __int8 v63 = v13[3];
            unsigned int v31 = *((unsigned __int16 *)v13 + 2);
            unsigned int v32 = (8 * v13[1]) - 6;
            CFStringAppend(theString, @" ");
            CFStringRef v33 = sub_536F4((uint64_t)(v13 + 6), v32);
            *(void *)unsigned __int8 v69 = v33;
            if (v33)
            {
              CFStringAppendFormat(theString, 0LL, @"%@", v33);
              CFStringAppend(theString, @", flags [");
              uint64_t v8 = v64;
              if ((v30 & 0x80) == 0)
              {
                if ((v30 & 0x20) == 0) {
                  goto LABEL_66;
                }
LABEL_137:
                CFStringAppend(theString, @" ra");
                if ((v30 & 0x40) == 0) {
                  goto LABEL_68;
                }
LABEL_67:
                CFStringAppend(theString, @" legacy");
                goto LABEL_68;
              }

              CFStringAppend(theString, @" http");
              if ((v30 & 0x20) != 0) {
                goto LABEL_137;
              }
LABEL_66:
              if ((v30 & 0x40) != 0) {
                goto LABEL_67;
              }
LABEL_68:
              CFStringAppend(theString, @" ]");
              CFStringAppendFormat(theString, 0LL, @", delay %hu", v63 & 0xF);
              CFStringAppendFormat(theString, 0LL, @", sequence nr %hu", bswap32(v31) >> 16);
              int v10 = v65;
            }

            else
            {
              CFStringAppend(theString, @"invalid id");
              uint64_t v8 = v64;
            }
          }

          else
          {
            CFStringAppend(theString, @" ");
            CFStringAppend(theString, @"invalid id");
          }
        }

        else
        {
          CFStringAppendFormat(theString, 0LL, @"truncated (%d < %d) ", v17, 6LL);
          sub_5040C(theString, (uint64_t)(v13 + 2), v17 - 2, 58);
        }

        sub_4FA18((const void **)v69);
        goto LABEL_133;
      }

      if (v18 != 24) {
        goto LABEL_81;
      }
      if (!v16)
      {
        uint64_t v24 = v17;
        uint64_t v25 = 8LL;
        goto LABEL_80;
      }

      uint64_t v19 = v13[2];
      if (v19 < 0x81)
      {
        unsigned int v43 = v19 >> 3;
        if ((v19 & 7) != 0) {
          uint64_t v44 = v43 + 1;
        }
        else {
          uint64_t v44 = v43;
        }
        if (v44 + 8 <= (unint64_t)v17)
        {
          __dst[0] = 0LL;
          __dst[1] = 0LL;
          __memcpy_chk(__dst, v13 + 8, v44, 16LL);
          if ((v19 & 7) != 0) {
            *((_BYTE *)__dst + v44 - 1) &= -1 << (8 - (v19 & 7));
          }
          uint64_t v55 = inet_ntop(30, __dst, v69, 0x2Eu);
          CFStringAppendFormat( theString,  0LL,  @" %s/%d, pref=%s, lifetime ",  v55,  v19,  *(char **)((char *)off_66630 + (v13[3] & 0x18)));
          unsigned int v56 = *((_DWORD *)v13 + 1);
          uint64_t v8 = v64;
          int v10 = v65;
          if (v56 == -1) {
            CFStringAppend(theString, @"infinite");
          }
          else {
            CFStringAppendFormat(theString, 0LL, @"%us", bswap32(v56));
          }
          goto LABEL_133;
        }

        CFStringAppendFormat(theString, 0LL, @"truncated (%d < %d) ", v17, v44 + 8);
        int v22 = v17 - 2;
        int v23 = theString;
        uint64_t v21 = (uint64_t)(v13 + 2);
LABEL_89:
        sub_5040C(v23, v21, v22, 58);
        goto LABEL_101;
      }

      CFStringAppendFormat(theString, 0LL, @"invalid prefix length %d > %d", v13[2], 128LL);
      sub_5040C(theString, (uint64_t)(v13 + 2), v17 - 2, 58);
LABEL_133:
      CFStringAppend(theString, @"\n");
      ++v11;
    }

    while (v11 != v10);
  }

uint64_t sub_52614(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 77);
}

uint64_t sub_5261C(uint64_t a1)
{
  return bswap32(*(unsigned __int16 *)(a1 + 78)) >> 16;
}

_BYTE *sub_5262C(uint64_t a1, _DWORD *a2)
{
  uint64_t v3 = a1 + 48;
  int v4 = sub_55628(a1 + 48);
  *a2 = 0;
  if (v4 < 1) {
    return 0LL;
  }
  int v5 = v4;
  int v6 = 0;
  while (1)
  {
    size_t v7 = (_BYTE *)sub_55644(v3, v6);
    if (*v7 == 1) {
      break;
    }
    if (v5 == ++v6) {
      return 0LL;
    }
  }

  if (!v7[1]) {
    return 0LL;
  }
  *a2 = 8 * v7[1] - 2;
  return v7 + 2;
}

__CFArray *sub_526B8(uint64_t a1)
{
  uint64_t v1 = a1 + 48;
  int v11 = 0LL;
  CFMutableStringRef Mutable = 0LL;
  uint64_t v3 = 0LL;
  int v4 = 0;
  while (1)
  {
    CFStringRef v10 = 0LL;
    int v5 = (_BYTE *)sub_55644(v1, v4);
    if (*v5 == 3) {
      break;
    }
LABEL_10:
  }

  int v6 = v5;
  if ((v5[1] & 0x1C) != 0)
  {
    if (v3 || (Mutable = CFArrayCreateMutable(0LL, 1LL, &kCFTypeArrayCallBacks), (int v11 = Mutable) != 0LL))
    {
      size_t v7 = inet_ntop(30, v6 + 16, v12, 0x2Eu);
      if (v7)
      {
        CFStringRef v8 = CFStringCreateWithCString(0LL, v7, 0x8000100u);
        CFStringRef v10 = v8;
        if (v8)
        {
          CFArrayAppendValue(Mutable, v8);
          sub_4FA18((const void **)&v10);
          uint64_t v3 = Mutable;
          goto LABEL_10;
        }
      }
    }
  }

  sub_4FA18((const void **)&v11);
  return v11;
}

uint64_t sub_52808(uint64_t a1, _DWORD *a2)
{
  uint64_t v3 = a1 + 48;
  int v4 = sub_55628(a1 + 48);
  if (v4 < 1)
  {
LABEL_8:
    *a2 = 0;
    return 0LL;
  }

  else
  {
    int v5 = v4;
    int v6 = 0;
    while (1)
    {
      uint64_t v7 = sub_55644(v3, v6);
      if (*(_BYTE *)v7 == 3)
      {
        unsigned int v8 = *(_DWORD *)(v7 + 4);
        if (v8)
        {
          if (*(_DWORD *)(v7 + 8)) {
            break;
          }
        }
      }

      if (v5 == ++v6) {
        goto LABEL_8;
      }
    }

    *a2 = bswap32(v8);
    return bswap32(*(_DWORD *)(v7 + 8));
  }

uint64_t sub_528A4(uint64_t a1, _DWORD *a2, unsigned int *a3)
{
  uint64_t v5 = a1 + 48;
  int v6 = sub_55628(a1 + 48);
  if (v6 < 1)
  {
LABEL_7:
    uint64_t result = 0LL;
    LODWORD(v13) = 0;
    unsigned int v14 = 0;
    if (!a2) {
      goto LABEL_9;
    }
    goto LABEL_8;
  }

  int v7 = v6;
  int v8 = 0;
  while (1)
  {
    uint64_t v9 = sub_55644(v5, v8);
    if (*(_BYTE *)v9 == 25)
    {
      unint64_t v10 = *(unsigned __int8 *)(v9 + 1);
      if (v10 < 3) {
        goto LABEL_7;
      }
      unsigned int v11 = *(_DWORD *)(v9 + 4);
      if (v11) {
        break;
      }
    }

    if (v7 == ++v8) {
      goto LABEL_7;
    }
  }

  uint64_t result = v9 + 8;
  unsigned int v14 = bswap32(v11);
  unint64_t v13 = (8 * v10 + 0xFFFFFFFF8LL) >> 4;
  if (a2) {
LABEL_8:
  }
    *a2 = v13;
LABEL_9:
  if (a3) {
    *a3 = v14;
  }
  return result;
}

uint64_t sub_52960(uint64_t a1, _DWORD *a2, unsigned int *a3)
{
  uint64_t v5 = a1 + 48;
  int v6 = sub_55628(a1 + 48);
  if (v6 < 1)
  {
LABEL_7:
    LODWORD(v12) = 0;
    unsigned int v13 = 0;
    uint64_t result = 0LL;
    if (!a2) {
      goto LABEL_9;
    }
    goto LABEL_8;
  }

  int v7 = v6;
  int v8 = 0;
  while (1)
  {
    uint64_t v9 = sub_55644(v5, v8);
    if (*(_BYTE *)v9 == 31)
    {
      unint64_t v10 = *(unsigned __int8 *)(v9 + 1);
      if (v10 < 2) {
        goto LABEL_7;
      }
      unsigned int v11 = *(_DWORD *)(v9 + 4);
      if (v11) {
        break;
      }
    }

    if (v7 == ++v8) {
      goto LABEL_7;
    }
  }

  uint64_t result = v9 + 8;
  uint64_t v12 = (8 * v10 - 8);
  while (!*(_BYTE *)(result + (v12 - 2)))
  {
    if (v12-- <= 2)
    {
      LODWORD(v12) = 1;
      goto LABEL_19;
    }
  }

  if (!(_DWORD)v12) {
    uint64_t result = 0LL;
  }
LABEL_19:
  unsigned int v13 = bswap32(v11);
  if (a2) {
LABEL_8:
  }
    *a2 = v12;
LABEL_9:
  if (a3) {
    *a3 = v13;
  }
  return result;
}

uint64_t sub_52A44(uint64_t a1, void *a2, _WORD *a3, uint64_t a4)
{
  uint64_t v7 = a1 + 48;
  int v8 = sub_55628(a1 + 48);
  if (v8 < 1) {
    return 0LL;
  }
  int v9 = v8;
  int v10 = 0;
  while (1)
  {
    uint64_t v11 = sub_55644(v7, v10);
    if (*(_BYTE *)v11 == 21) {
      break;
    }
    if (v9 == ++v10) {
      return 0LL;
    }
  }

  unsigned __int8 v12 = 8 * *(_BYTE *)(v11 + 1);
  if (!v12) {
    return 0LL;
  }
  *(_BYTE *)a4 = *(_BYTE *)(v11 + 2) >> 7;
  *(_BYTE *)(a4 + 1) = (*(_BYTE *)(v11 + 2) & 0x40) != 0;
  *(_BYTE *)(a4 + 2) = (*(_BYTE *)(v11 + 2) & 0x20) != 0;
  *(_WORD *)(a4 + 4) = *(_BYTE *)(v11 + 3) & 0xF;
  *a3 = bswap32(*(unsigned __int16 *)(v11 + 4)) >> 16;
  *a2 = v12 - 6LL;
  return v11 + 6;
}

double sub_52B24(uint64_t a1, BOOL *a2, char *a3, double a4)
{
  uint64_t v8 = sub_528A4(a1, &v19, &v18);
  double v9 = 0.0;
  if (!v8)
  {
LABEL_19:
    char v12 = 0;
    if (!a2) {
      goto LABEL_21;
    }
    goto LABEL_20;
  }

  if (v18 != -1)
  {
    if (!v18 || ((double v10 = *(double *)(a1 + 40), v10 <= a4) ? (v11 = a4 - v10 < (double)v18) : (v11 = 0), !v11))
    {
      char v12 = 1;
      if (!a2) {
        goto LABEL_21;
      }
LABEL_20:
      *a2 = v8 != 0;
      goto LABEL_21;
    }
  }

  if (sub_52960(a1, &v21, &v20)
    && ((unsigned int v13 = v20, v20 == -1)
     || v20 && ((double v14 = *(double *)(a1 + 40), v14 <= a4) ? (v15 = a4 - v14 < (double)v20) : (v15 = 0), v15)))
  {
    unsigned int v16 = v18;
    if (v20 < v18) {
      goto LABEL_25;
    }
  }

  else
  {
    unsigned int v16 = v18;
  }

  unsigned int v13 = v16;
  if (v16 == -1) {
    goto LABEL_19;
  }
LABEL_25:
  char v12 = 0;
  double v9 = *(double *)(a1 + 40) + (double)v13;
  if (a2) {
    goto LABEL_20;
  }
LABEL_21:
  if (a3) {
    *a3 = v12;
  }
  return v9;
}

CFStringRef sub_52C40(uint64_t a1)
{
  uint64_t v1 = a1 + 48;
  int v2 = sub_55628(a1 + 48);
  if (v2 < 1) {
    goto LABEL_12;
  }
  int v3 = v2;
  int v4 = 0;
  while (1)
  {
    uint64_t v5 = (_BYTE *)sub_55644(v1, v4);
    if (*v5 == 37) {
      break;
    }
    if (v3 == ++v4) {
      goto LABEL_12;
    }
  }

  int v6 = v5[1];
  if (v5[1] && (v8 = v5[2], uint64_t v7 = v5 + 2, v8))
  {
    for (uint64_t i = 2LL * ((4 * v6 + 2147483644) & 0x7FFFFFFC); !v7[(i + 4)]; --i)
    {
      uint64_t v10 = i + 6;
      if (v10 <= 2)
      {
        CFIndex v11 = 1LL;
        return sub_505EC(v7, v11);
      }
    }

    CFIndex v11 = (i + 6);
  }

  else
  {
LABEL_12:
    CFIndex v11 = 0LL;
    uint64_t v7 = 0LL;
  }

  return sub_505EC(v7, v11);
}

BOOL sub_52CF8(uint64_t a1, char *a2, _BYTE *a3, _WORD *a4)
{
  uint64_t v7 = a1 + 48;
  int v8 = sub_55628(a1 + 48);
  if (v8 < 1)
  {
    return 0;
  }

  else
  {
    int v9 = v8;
    int v10 = 0;
    BOOL v11 = 1;
    do
    {
      char v12 = (_BYTE *)sub_55644(v7, v10);
      BOOL v11 = ++v10 < v9;
    }

    while (v9 != v10);
  }

  return v11;
}

CFStringRef sub_52DAC(uint64_t a1, _WORD *a2)
{
  if (!sub_52CF8(a1, v6, &v5, &v4)) {
    return 0LL;
  }
  inet_ntop(30, v6, v7, 0x2Eu);
  CFStringRef result = CFStringCreateWithFormat(0LL, 0LL, @"%s/%d", v7, v5);
  *a2 = v4;
  return result;
}

CFDictionaryRef sub_52E54(uint64_t a1)
{
  *(_OWORD *)keys = *(_OWORD *)off_665B8;
  int v9 = @"ReceiveDate";
  CFDataRef v2 = CFDataCreate(0LL, (const UInt8 *)(a1 + 72), *(void *)(a1 + 64));
  CFDateRef v3 = CFDateCreate(0LL, *(CFAbsoluteTime *)(a1 + 40));
  __int16 v4 = *(void **)(a1 + 32);
  values[0] = v2;
  values[1] = v4;
  values[2] = v3;
  CFDictionaryRef v5 = CFDictionaryCreate( 0LL,  (const void **)keys,  (const void **)values,  3LL,  &kCFTypeDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
  CFRelease(v2);
  CFRelease(v3);
  return v5;
}

uint64_t sub_52F30()
{
  uint64_t result = _CFRuntimeRegisterClass(&unk_665D0);
  qword_6C2B0 = result;
  return result;
}

void sub_52F54(uint64_t a1)
{
}

__CFString *sub_52F7C(const void *a1)
{
  CFDataRef v2 = CFGetAllocator(a1);
  CFMutableStringRef Mutable = CFStringCreateMutable(v2, 0LL);
  CFStringAppendFormat(Mutable, 0LL, @"<RouterAdvertisement %p [%p]> { ", a1, v2);
  sub_51AF8((uint64_t)a1, Mutable);
  CFStringAppend(Mutable, @"}");
  return Mutable;
}

uint64_t sub_52FF0(uint64_t a1, uint64_t a2, char *__dst, _BYTE *a4, _WORD *a5, CFMutableStringRef theString)
{
  int v7 = a2;
  if (a2 > 0xF)
  {
    unsigned int v12 = bswap32(*(unsigned __int16 *)(a1 + 2));
    if ((HIWORD(v12) & 7) < 6u)
    {
      unsigned int v16 = HIWORD(v12);
      unint64_t v17 = 0x202830384060uLL >> (8 * (BYTE2(v12) & 7u));
      memmove(__dst, (const void *)(a1 + 4), (v17 >> 3) & 0xF);
      bzero(&__dst[(v17 >> 3) & 0xF], 16 - ((v17 & 0x78) >> 3));
      *a4 = v17;
      *a5 = v16 & 0xFFF8;
      return 1LL;
    }

    if (theString)
    {
      CFStringAppendFormat(theString, 0LL, @"invalid PLC=%d: ", HIWORD(v12) & 7);
      int v10 = v7 - 2;
      BOOL v11 = theString;
      uint64_t v9 = a1 + 2;
      goto LABEL_8;
    }
  }

  else if (theString)
  {
    CFStringAppendFormat(theString, 0LL, @"truncated (%d < %d) ", a2, 16LL);
    uint64_t v9 = a1 + 2;
    int v10 = v7 - 2;
    BOOL v11 = theString;
LABEL_8:
    sub_5040C(v11, v9, v10, 58);
  }

  return 0LL;
}

char *sub_5311C(uint64_t a1, unsigned int a2, int *a3)
{
  __src[0] = 0LL;
  memset(v12, 0, sizeof(v12));
  __src[1] = v12;
  uint64_t v14 = 0x8000000000LL;
  int v4 = sub_5322C(a1, a2, (uint64_t)v12, 0);
  int v5 = v4;
  if (v4)
  {
    size_t v6 = (int)v14;
    int v7 = (char *)malloc((int)v14 + 8LL * v4);
    int v8 = &v7[8 * v5];
    memcpy(v8, __src[1], v6);
    if (v5 >= 1)
    {
      uint64_t v9 = 0LL;
      do
      {
        *(void *)&v7[v9] = v8;
        v8 += strlen(v8) + 1;
        v9 += 8LL;
      }

      while (8LL * v5 != v9);
    }
  }

  else
  {
    int v7 = 0LL;
  }

  if (v7) {
    int v10 = v5;
  }
  else {
    int v10 = 0;
  }
  *a3 = v10;
  sub_53578(v12);
  return v7;
}

uint64_t sub_5322C(uint64_t a1, unsigned int a2, uint64_t a3, int a4)
{
  uint64_t v4 = 0LL;
  if (a1 && a2)
  {
    size_t v7 = 0LL;
    size_t v8 = 0LL;
    uint64_t v4 = 0LL;
    unsigned int v9 = 0;
    v30[1] = (void *)0x800000000LL;
    memset(v29, 0, sizeof(v29));
    v30[0] = v29;
    char v10 = 1;
    unsigned int v11 = a2;
    do
    {
      unsigned int v12 = (unsigned __int8 *)(a1 + v8);
      unsigned int v13 = *v12;
      if ((~v13 & 0xC0) != 0)
      {
        if (v8 >= v7)
        {
          if (v13 >= 0x40)
          {
            fprintf(__stderrp, "label length %d > %d\n");
            goto LABEL_48;
          }

          unsigned int v18 = v13 + 1;
          if (v11 <= v13)
          {
            fprintf(__stderrp, "label truncated %d < %d\n");
            goto LABEL_48;
          }

          size_t v7 = v18 + v7;
          v11 -= v18;
        }

        if (*v12)
        {
          char __src = 46;
          if (SLODWORD(v30[1]) < 1) {
            goto LABEL_29;
          }
          if (*(_DWORD *)v30[0] != (_DWORD)v8)
          {
            uint64_t v19 = 1LL;
            do
            {
              unint64_t v20 = v19;
              if (LODWORD(v30[1]) == v19) {
                break;
              }
              int v21 = *((_DWORD *)v30[0] + v19++);
            }

            while (v21 != (_DWORD)v8);
            if (v20 >= LODWORD(v30[1])) {
LABEL_29:
            }
              sub_537A4((int *)v29, v8);
          }

          if ((v10 & 1) == 0) {
            sub_5382C(a3, &__src, 1);
          }
          sub_5382C(a3, v12 + 1, v13);
          char v10 = 0;
          size_t v8 = v8 + v13 + 1;
        }

        else
        {
          char __src = 0;
          char v10 = 1;
          sub_5382C(a3, &__src, 1);
          uint64_t v4 = (v4 + 1);
          unsigned int v9 = v7;
          size_t v8 = v7;
          if (a4) {
            break;
          }
        }
      }

      else
      {
        if (a4)
        {
          int v22 = __stderrp;
          int v23 = "single name with pointers\n";
          size_t v24 = 26LL;
          goto LABEL_47;
        }

        if (v8 >= v7)
        {
          if (v11 <= 1)
          {
            int v22 = __stderrp;
            int v23 = "truncated pointer value\n";
            size_t v24 = 24LL;
            goto LABEL_47;
          }

          size_t v7 = (v7 + 2);
          v11 -= 2;
        }

        unsigned int v14 = bswap32(*(_WORD *)v12 & 0xFF3F);
        if (v8 <= HIWORD(v14))
        {
          int v22 = __stderrp;
          int v23 = "pointer points at or ahead of current position\n";
          size_t v24 = 47LL;
          goto LABEL_47;
        }

        size_t v8 = HIWORD(v14);
        if (v9 <= v8)
        {
          int v22 = __stderrp;
          int v23 = "attempt to create infinite loop\n";
          size_t v24 = 32LL;
          goto LABEL_47;
        }

        if (SLODWORD(v30[1]) < 1) {
          goto LABEL_38;
        }
        if (*(_DWORD *)v30[0] != (_DWORD)v8)
        {
          uint64_t v15 = 1LL;
          do
          {
            unint64_t v16 = v15;
            if (LODWORD(v30[1]) == v15) {
              break;
            }
            int v17 = *((_DWORD *)v30[0] + v15++);
          }

          while (v17 != (_DWORD)v8);
          if (v16 >= LODWORD(v30[1]))
          {
LABEL_38:
            int v22 = __stderrp;
            int v23 = "attempt to point off into the weeds\n";
            size_t v24 = 36LL;
            goto LABEL_47;
          }
        }
      }
    }

    while (v8 < a2);
    if ((_DWORD)v4) {
      goto LABEL_49;
    }
    int v22 = __stderrp;
    if (*(_DWORD *)(a3 + 144))
    {
      int v23 = "name missing end label\n";
      size_t v24 = 23LL;
    }

    else
    {
      int v23 = "empty list\n";
      size_t v24 = 11LL;
    }

LABEL_47:
    fwrite(v23, v24, 1uLL, v22);
LABEL_48:
    sub_53578((_OWORD *)a3);
    uint64_t v4 = 0LL;
LABEL_49:
    if (v30[0] && v30[0] != v29) {
      free(v30[0]);
    }
  }

  return v4;
}

double sub_53578(_OWORD *a1)
{
  if (!*((_BYTE *)a1 + 128))
  {
    CFDataRef v2 = (_OWORD *)*((void *)a1 + 17);
    if (v2) {
      BOOL v3 = v2 == a1;
    }
    else {
      BOOL v3 = 1;
    }
    if (!v3) {
      free(v2);
    }
  }

  *((void *)a1 + 18) = 0LL;
  double result = 0.0;
  a1[7] = 0u;
  a1[8] = 0u;
  a1[5] = 0u;
  a1[6] = 0u;
  a1[3] = 0u;
  a1[4] = 0u;
  a1[1] = 0u;
  a1[2] = 0u;
  *a1 = 0u;
  return result;
}

__CFArray *sub_535CC(uint64_t a1, unsigned int a2)
{
  cStr[0] = 0LL;
  memset(v9, 0, sizeof(v9));
  cStr[1] = (char *)v9;
  uint64_t v11 = 0x8000000000LL;
  int v2 = sub_5322C(a1, a2, (uint64_t)v9, 0);
  if (!v2) {
    return 0LL;
  }
  int v3 = v2;
  CFMutableStringRef Mutable = CFArrayCreateMutable(0LL, v2, &kCFTypeArrayCallBacks);
  if (v3 >= 1)
  {
    int v5 = cStr[1];
    do
    {
      CFStringRef v6 = CFStringCreateWithCString(0LL, v5, 0x8000100u);
      if (v6)
      {
        CFStringRef v7 = v6;
        CFArrayAppendValue(Mutable, v6);
        CFRelease(v7);
      }

      v5 += strlen(v5) + 1;
      --v3;
    }

    while (v3);
  }

  if (!CFArrayGetCount(Mutable))
  {
    CFRelease(Mutable);
    CFMutableStringRef Mutable = 0LL;
  }

  sub_53578(v9);
  return Mutable;
}

CFStringRef sub_536F4(uint64_t a1, unsigned int a2)
{
  cStr[0] = 0LL;
  memset(v4, 0, sizeof(v4));
  cStr[1] = (char *)v4;
  uint64_t v6 = 0x8000000000LL;
  CFStringRef v2 = CFStringCreateWithCString(0LL, cStr[1], 0x8000100u);
  sub_53578(v4);
  return v2;
}

int *sub_537A4(int *result, size_t __size)
{
  int v2 = __size;
  uint64_t v3 = (uint64_t)result;
  uint64_t v4 = result[11];
  if ((_DWORD)v4 == result[10])
  {
    result[11] = 2 * v4;
    int v5 = (void *)*((void *)result + 4);
    if (v5 == (void *)v3)
    {
      uint64_t v6 = malloc(8 * v4);
      *(void *)(v3 + 32) = v6;
      double result = (int *)memmove(v6, (const void *)v3, 4 * v4);
    }

    else
    {
      double result = (int *)reallocf(v5, 8 * v4);
      *(void *)(v3 + 32) = result;
    }
  }

  uint64_t v7 = *(void *)(v3 + 32);
  uint64_t v8 = *(int *)(v3 + 40);
  *(_DWORD *)(v3 + 4snprintf(__str, 0x100uLL, "/dev/bpf%d", 0) = v8 + 1;
  *(_DWORD *)(v7 + 4 * v8) = v2;
  return result;
}

uint64_t sub_5382C(uint64_t a1, void *__src, int a3)
{
  int v7 = *(_DWORD *)(a1 + 144);
  int v6 = *(_DWORD *)(a1 + 148);
  if (v6 - v7 >= a3)
  {
    unsigned int v9 = *(char **)(a1 + 136);
  }

  else
  {
    if (*(_BYTE *)(a1 + 128))
    {
      fprintf(__stderrp, "user-supplied buffer failed to add data with length %d (> %d)\n", a3, v6 - v7);
      return 0LL;
    }

    if (a3 <= 128) {
      int v10 = 128;
    }
    else {
      int v10 = a3;
    }
    int v11 = v6 + v10;
    *(_DWORD *)(a1 + 148) = v11;
    unsigned int v12 = *(void **)(a1 + 136);
    if (v12 == (void *)a1)
    {
      unsigned int v9 = (char *)malloc(v11);
      *(void *)(a1 + 136) = v9;
      memcpy(v9, (const void *)a1, v7);
    }

    else
    {
      unsigned int v9 = (char *)reallocf(v12, v11);
      *(void *)(a1 + 136) = v9;
      int v7 = *(_DWORD *)(a1 + 144);
    }
  }

  memcpy(&v9[v7], __src, a3);
  *(_DWORD *)(a1 + 144) += a3;
  return 1LL;
}

_DWORD *sub_53924(unsigned __int8 *a1, int a2, _DWORD *a3)
{
  uint64_t v4 = 0LL;
  LODWORD(v5) = 0;
  if (a1 && a2)
  {
    uint64_t v8 = sub_539C4(a1, a2, 0LL, 0LL);
    uint64_t v5 = v8;
    if (!(_DWORD)v8)
    {
LABEL_6:
      uint64_t v4 = 0LL;
      goto LABEL_7;
    }

    uint64_t v4 = malloc(12LL * (int)v8);
    if (sub_539C4(a1, a2, v4, v5) != (_DWORD)v5)
    {
      free(v4);
      LODWORD(v5) = 0;
      goto LABEL_6;
    }
  }

uint64_t sub_539C4(unsigned __int8 *a1, int a2, _DWORD *__dst, uint64_t a4)
{
  if (a2 >= 1)
  {
    unsigned int v5 = a2;
    uint64_t v7 = 0LL;
    uint64_t v34 = a4;
    uint64_t v8 = (int)a4;
    for (uint64_t i = __dst; ; i += 3)
    {
      unsigned int v10 = *a1;
      if (v10 >= 0x21) {
        break;
      }
      LODWORD(v11) = v10 + 8;
      if ((v10 & 7) != 0) {
        unint64_t v11 = v11;
      }
      else {
        unint64_t v11 = *a1;
      }
      unint64_t v12 = v11 >> 3;
      unsigned int v13 = (v11 >> 3) + 5;
      int v14 = v5 - v13;
      if (v5 < v13)
      {
        uint64_t v21 = sub_57538();
        uint64_t v22 = _SC_syslog_os_log_mapping(5LL);
        if (__SC_log_enabled(5LL, v21, v22))
        {
          uint64_t v23 = _os_log_pack_size(14LL);
          size_t v24 = (char *)&v34 - ((__chkstk_darwin(v23) + 15) & 0xFFFFFFFFFFFFFFF0LL);
          uint64_t v25 = __error();
          uint64_t v26 = _os_log_pack_fill(v24, v23, *v25, &dword_0, "truncated descriptor %d < %d", v34, v35);
          *(_DWORD *)uint64_t v26 = 67109376;
          *(_DWORD *)(v26 + 4) = v5;
          *(_WORD *)(v26 + 8) = 1024;
          *(_DWORD *)(v26 + 1snprintf(__str, 0x100uLL, "/dev/bpf%d", 0) = v13;
          __SC_log_send(5LL, v21, v22, v24);
        }

        return 0LL;
      }

      if (__dst)
      {
        if (v7 >= v8)
        {
          uint64_t v27 = sub_57538();
          uint64_t v28 = _SC_syslog_os_log_mapping(5LL);
          if (__SC_log_enabled(5LL, v27, v28))
          {
            uint64_t v29 = _os_log_pack_size(8LL);
            unsigned __int8 v30 = (char *)&v34 - ((__chkstk_darwin(v29) + 15) & 0xFFFFFFFFFFFFFFF0LL);
            unsigned int v31 = __error();
            unsigned int v32 = (_DWORD *)_os_log_pack_fill( v30,  v29,  *v31,  &dword_0,  "supplied route list too small (%d elements)",  v34);
            *unsigned int v32 = 67109120;
            v32[1] = v34;
            __SC_log_send(5LL, v27, v28, v30);
          }

          return 0LL;
        }

        *uint64_t i = 0;
        i[1] = v10;
        memcpy(i, a1 + 1, v11 >> 3);
        i[2] = *(_DWORD *)&a1[v12 + 1];
      }

      ++v7;
      a1 += v13;
      v5 -= v13;
      if (v14 <= 0) {
        return v7;
      }
    }

    uint64_t v15 = sub_57538();
    uint64_t v16 = _SC_syslog_os_log_mapping(5LL);
    if (__SC_log_enabled(5LL, v15, v16))
    {
      uint64_t v17 = _os_log_pack_size(8LL);
      unsigned int v18 = (char *)&v34 - ((__chkstk_darwin(v17) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v19 = __error();
      unint64_t v20 = (_DWORD *)_os_log_pack_fill(v18, v17, *v19, &dword_0, "prefix length is %d (> 32)", v34);
      *unint64_t v20 = 67109120;
      v20[1] = v10;
      __SC_log_send(5LL, v15, v16, v18);
    }
  }

  return 0LL;
}

_DWORD *sub_53CDC(_DWORD *a1, int a2)
{
  uint64_t v2 = 0LL;
  if (a1 && a2 >= 1)
  {
    while (*a1)
    {
      a1 += 3;
      if (!--a2) {
        return 0LL;
      }
    }

    return a1;
  }

  return (_DWORD *)v2;
}

void *sub_53D14(void *a1, uint64_t a2, uint64_t a3)
{
  double result = sub_55590(a1);
  a1[2] = a2;
  a1[3] = a3;
  return result;
}

void DHCPLeaseListFree_0(uint64_t *a1)
{
  uint64_t v1 = (uint64_t)a1;
  while (sub_55668(a1, 0, &v3))
  {
    if (v3)
    {
      uint64_t v2 = *(void (**)(void))(v1 + 16);
      if (v2) {
        v2();
      }
    }

    a1 = (uint64_t *)v1;
  }

  sub_55598(v1);
}

uint64_t sub_53DAC(uint64_t *a1, unsigned int a2)
{
  uint64_t result = sub_55668(a1, a2, &v5);
  if ((_DWORD)result)
  {
    if (v5)
    {
      uint64_t v4 = (void (*)(void))a1[2];
      if (v4) {
        v4();
      }
    }

    return 1LL;
  }

  return result;
}

uint64_t sub_53DF4(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)(a1 + 16) = *(_OWORD *)(a2 + 16);
  sub_55590((void *)a1);
  if ((int)sub_55628(a2) >= 1)
  {
    int v4 = 0;
    do
    {
      uint64_t v5 = sub_55644(a2, v4);
      uint64_t v6 = v5;
      if (v5)
      {
        uint64_t v7 = *(uint64_t (**)(uint64_t))(a1 + 24);
        if (v7) {
          uint64_t v6 = v7(v5);
        }
      }

      sub_556EC(a1, v6);
      ++v4;
    }

    while (v4 < (int)sub_55628(a2));
  }

  return 1LL;
}

uint64_t sub_53E88(_OWORD *a1, int a2)
{
  if (a2 < 32)
  {
    unsigned int v2 = 0;
  }

  else
  {
    unsigned int v2 = 0;
    unsigned int v3 = a2;
    do
    {
      a2 = v3 - 32;
      uint16x8_t v4 = *(uint16x8_t *)a1;
      uint16x8_t v5 = *((uint16x8_t *)a1 + 1);
      a1 += 2;
      v2 += vaddvq_s32( vaddq_s32( (int32x4_t)vaddl_u16(*(uint16x4_t *)v4.i8, *(uint16x4_t *)v5.i8),  (int32x4_t)vaddl_high_u16(v4, v5)));
      BOOL v6 = v3 > 0x3F;
      v3 -= 32;
    }

    while (v6);
  }

  if (a2 < 8)
  {
    int v7 = a2;
    if (!a2) {
      return (unsigned __int16)~(HIWORD(v2) + v2 + ((HIWORD(v2) + (unsigned __int16)v2) >> 16));
    }
  }

  else
  {
    do
    {
      int v7 = a2 - 8;
      uint16x4_t v8 = *(uint16x4_t *)a1;
      a1 = (_OWORD *)((char *)a1 + 8);
      v2 += vaddvq_s32((int32x4_t)vmovl_u16(v8));
      BOOL v6 = a2 > 0xF;
      a2 -= 8;
    }

    while (v6);
    if (!v7) {
      return (unsigned __int16)~(HIWORD(v2) + v2 + ((HIWORD(v2) + (unsigned __int16)v2) >> 16));
    }
  }

  unsigned int v2 = HIWORD(v2) + (unsigned __int16)v2;
  if (HIWORD(v2)) {
    v2 -= 0xFFFF;
  }
  int v9 = v7 - 2;
  if (v7 < 2)
  {
    unint64_t v11 = (unsigned __int8 *)a1;
  }

  else
  {
    uint64_t v10 = v9 & 0xFFFFFFFE;
    unint64_t v11 = (unsigned __int8 *)a1 + v10 + 2;
    for (unsigned int i = v7; i > 1; i -= 2)
    {
      int v13 = *(unsigned __int16 *)a1;
      a1 = (_OWORD *)((char *)a1 + 2);
      v2 += v13;
    }

    int v9 = v7 - v10 - 4;
  }

  if (v9 == -1) {
    v2 += *v11;
  }
  return (unsigned __int16)~(HIWORD(v2) + v2 + ((HIWORD(v2) + (unsigned __int16)v2) >> 16));
}

__n128 sub_53F88(__n128 *a1)
{
  unsigned int v2 = malloc(0x10uLL);
  if (v2)
  {
    __n128 result = *a1;
    _OWORD *v2 = *a1;
  }

  return result;
}

uint64_t sub_53FBC(uint64_t result)
{
  if (result) {
    return *(unsigned int *)(result + 8);
  }
  return result;
}

uint64_t sub_53FC8(uint64_t a1, unsigned int a2)
{
  if (a1) {
    int v2 = *(_DWORD *)(a1 + 8);
  }
  else {
    int v2 = 0;
  }
  uint64_t v3 = 0LL;
  return v3;
}

uint64_t sub_53FFC(uint64_t *a1, int a2)
{
  uint64_t v4 = 0LL;
  if (!a1) {
    goto LABEL_3;
  }
LABEL_2:
  for (int i = *((_DWORD *)a1 + 2); ; int i = 0)
  {
    if (v4 >= i) {
      return 0LL;
    }
    uint64_t v6 = *a1;
    uint64_t v7 = *a1 + 96 * v4 + 24;
LABEL_9:
    ++v4;
    if (a1) {
      goto LABEL_2;
    }
LABEL_3:
    ;
  }

  uint64_t v8 = 0LL;
  while (*(_DWORD *)sub_50C98(v7, v8) != a2)
  {
    uint64_t v8 = (v8 + 1);
  }

  return v6 + 96 * v4;
}

uint64_t sub_540BC(uint64_t *a1, char *__s2)
{
  uint64_t v4 = -96LL;
  uint64_t v5 = -1LL;
  while (1)
  {
    int v6 = a1 ? *((_DWORD *)a1 + 2) : 0;
    if (++v5 >= v6) {
      break;
    }
    uint64_t v7 = v4 + 96;
    uint64_t v8 = *a1;
    int v9 = strcmp((const char *)(*a1 + v4 + 96), __s2);
    uint64_t v4 = v7;
    if (!v9) {
      return v8 + v7;
    }
  }

  return 0LL;
}

uint64_t sub_5413C(uint64_t a1)
{
  uint64_t result = sub_540BC((uint64_t *)a1, "en0");
  if (!result)
  {
    if (a1 && (uint64_t v3 = *(unsigned int *)(a1 + 8), (int)v3 >= 1))
    {
      uint64_t v4 = 0LL;
      uint64_t v5 = 0LL;
      uint64_t v6 = 0LL;
      uint64_t v7 = *(int *)(a1 + 8);
      do
      {
        if (v4 >= v7) {
          uint64_t v8 = 0LL;
        }
        else {
          uint64_t v8 = *(void *)a1 + 96 * v4;
        }
        int v9 = *(unsigned __int8 *)(v8 + 18);
        if (v9 == 6 || v9 == 144)
        {
          if (v5)
          {
          }

          else
          {
            uint64_t v5 = (const char *)v8;
          }
        }

        else if (!v6)
        {
          if (*(_BYTE *)(v8 + 74)) {
            uint64_t v6 = v8;
          }
          else {
            uint64_t v6 = 0LL;
          }
        }

        ++v4;
      }

      while (v4 != v3);
    }

    else
    {
      uint64_t v6 = 0LL;
      uint64_t v5 = 0LL;
    }

    if (v6) {
      BOOL v10 = v5 == 0LL;
    }
    else {
      BOOL v10 = 0;
    }
    if (v10) {
      return v6;
    }
    else {
      return (uint64_t)v5;
    }
  }

  return result;
}

uint64_t sub_54228(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 18);
}

uint64_t sub_54230(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 74);
}

void **sub_54238()
{
  uint64_t v0 = (void **)malloc(0x10uLL);
  uint64_t v1 = v0;
  if (v0 && !sub_5427C(v0))
  {
    free(v1);
    return 0LL;
  }

  return v1;
}

void *sub_5427C(void **a1)
{
  uint64_t v76 = 0LL;
  *a1 = 0LL;
  int v2 = getifaddrs(&v76);
  uint64_t v3 = v76;
  if (v2 < 0) {
    goto LABEL_88;
  }
  if (!v76)
  {
LABEL_90:
    uint64_t result = *a1;
    if (*a1)
    {
      free(result);
      uint64_t result = 0LL;
      *a1 = 0LL;
    }

    return result;
  }

  int v4 = 0;
  uint64_t v5 = v76;
  while (v5->ifa_addr)
  {
    uint64_t v5 = v5->ifa_next;
    --v4;
    if (!v5) {
      goto LABEL_8;
    }
  }

  if (!v4)
  {
LABEL_88:
    if (v3) {
      freeifaddrs(v3);
    }
    goto LABEL_90;
  }

LABEL_82:
    uint64_t v3 = v3->ifa_next;
  }

  while (v3);
  size_t v11 = 96LL * *((int *)a1 + 2) + 96;
LABEL_93:
  *a1 = reallocf(*a1, v11);
  if (v76) {
    freeifaddrs(v76);
  }
  if ((v10 & 0x80000000) == 0) {
    close(v10);
  }
  return &dword_0 + 1;
}

void sub_54A08(uint64_t *a1)
{
  if (a1)
  {
    uint64_t v2 = *a1;
    if (*a1)
    {
      if (*(int *)(v2 + 8) >= 1)
      {
        uint64_t v3 = 0LL;
        uint64_t v4 = 24LL;
        do
        {
          DHCPLeaseListFree_0((uint64_t *)(*(void *)v2 + v4));
          ++v3;
          v4 += 96LL;
        }

        while (v3 < *(int *)(v2 + 8));
      }

      if (*(void *)v2) {
        free(*(void **)v2);
      }
      free((void *)v2);
      *a1 = 0LL;
    }
  }

uint64_t sub_54A84(uint64_t a1)
{
  return *(unsigned __int16 *)(a1 + 16);
}

uint64_t sub_54A8C(uint64_t a1)
{
  return sub_50C94(a1 + 24);
}

uint64_t sub_54A94(uint64_t a1, uint64_t a2)
{
  return sub_50C98(a1 + 24, a2);
}

void sub_54A9C(uint64_t **a1)
{
  if (a1)
  {
    uint64_t v2 = *a1;
    if (*a1)
    {
      DHCPLeaseListFree_0(v2 + 3);
      free(v2);
      *a1 = 0LL;
    }
  }

_OWORD *sub_54AD8(_OWORD *a1)
{
  uint64_t v2 = calloc(1uLL, 0x60uLL);
  uint64_t v3 = v2;
  if (v2)
  {
    __int128 v4 = a1[1];
    _OWORD *v2 = *a1;
    v2[1] = v4;
    __int128 v5 = a1[2];
    __int128 v6 = a1[3];
    __int128 v7 = a1[5];
    v2[4] = a1[4];
    v2[5] = v7;
    v2[2] = v5;
    v2[3] = v6;
    sub_53DF4((uint64_t)v2 + 24, (uint64_t)a1 + 24);
  }

  return v3;
}

__n128 sub_54B30(uint64_t a1, uint64_t a2)
{
  *(_BYTE *)(a1 + 19) = *(_BYTE *)(a2 + 19);
  uint64_t v2 = *(void *)(a2 + 80);
  *(_DWORD *)(a1 + 88) = *(_DWORD *)(a2 + 88);
  *(void *)(a1 + 8snprintf(__str, 0x100uLL, "/dev/bpf%d", 0) = v2;
  __n128 result = *(__n128 *)(a2 + 56);
  *(_DWORD *)(a1 + 72) = *(_DWORD *)(a2 + 72);
  *(__n128 *)(a1 + 56) = result;
  return result;
}

uint64_t sub_54B5C(uint64_t a1)
{
  size_t v22 = 0LL;
  *(_OWORD *)uint64_t v23 = xmmword_59670;
  int v2 = *(unsigned __int16 *)(a1 + 72);
  int v24 = 3;
  int v25 = v2;
  if ((sysctl(v23, 6u, 0LL, &v22, 0LL, 0LL) & 0x80000000) == 0)
  {
    uint64_t v3 = malloc(v22);
    if (sysctl(v23, 6u, v3, &v22, 0LL, 0LL) < 0)
    {
      uint64_t v17 = __stderrp;
      uint64_t v18 = __error();
      int v19 = strerror(*v18);
      fprintf(v17, "sysctl() failed: %s", v19);
    }

    else if (v22 >= 0x84)
    {
      if (v3[3] != 14) {
        goto LABEL_18;
      }
      __int128 v4 = &v3[v3[117] + 120];
      unsigned int v5 = v3[118];
      int v6 = v3[116];
      if (v5 >= 0x11)
      {
        uint64_t v7 = sub_57538();
        uint64_t v8 = _SC_syslog_os_log_mapping(7LL);
        if (__SC_log_enabled(7LL, v7, v8))
        {
          uint64_t v9 = _os_log_pack_size(34LL);
          uint64_t v21 = (const char *)&v21;
          int v10 = (char *)&v21 - ((__chkstk_darwin(v9) + 15) & 0xFFFFFFFFFFFFFFF0LL);
          size_t v11 = __error();
          uint64_t v12 = _os_log_pack_fill( v10,  v9,  *v11,  &dword_0,  "%s: link type %d address length %d > %ld",  v21,  v22,  v23[0],  *(void *)&v23[2]);
          *(_DWORD *)uint64_t v12 = 136315906;
          *(void *)(v12 + 4) = a1;
          *(_WORD *)(v12 + 12) = 1024;
          *(_DWORD *)(v12 + 14) = v6;
          *(_WORD *)(v12 + 18) = 1024;
          *(_DWORD *)(v12 + 2snprintf(__str, 0x100uLL, "/dev/bpf%d", 0) = v5;
          *(_WORD *)(v12 + 24) = 2048;
          unsigned int v5 = 16;
          *(void *)(v12 + 26) = 16LL;
          __SC_log_send(7LL, v7, v8, v10);
        }

        else
        {
          unsigned int v5 = 16;
        }
      }

      if (*(unsigned __int8 *)(a1 + 75) != v6
        || v5 != *(unsigned __int8 *)(a1 + 74)
        || v5 && bcmp(v4, (const void *)(a1 + 56), v5))
      {
        *(_BYTE *)(a1 + 74) = v5;
        memmove((void *)(a1 + 56), v4, v5);
        *(_BYTE *)(a1 + 75) = v3[116];
        uint64_t v16 = 1LL;
      }

      else
      {
LABEL_18:
        uint64_t v16 = 0LL;
      }

uint64_t sub_54E20(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 75);
}

uint64_t sub_54E28(uint64_t a1)
{
  int v1 = *(unsigned __int8 *)(a1 + 75);
  if (v1 == 144) {
    unsigned int v2 = 24;
  }
  else {
    unsigned int v2 = -1;
  }
  if (v1 == 6) {
    return 1LL;
  }
  else {
    return v2;
  }
}

uint64_t sub_54E44(uint64_t a1)
{
  return a1 + 56;
}

uint64_t sub_54E4C(unsigned __int8 *a1)
{
  if (a1[75] == 6 && a1[74] == 6) {
    return (a1[56] >> 1) & 1;
  }
  else {
    return 0LL;
  }
}

uint64_t sub_54E78(uint64_t a1)
{
  return *(_BYTE *)(a1 + 19) & 1;
}

uint64_t sub_54E84(uint64_t a1)
{
  return (*(unsigned __int8 *)(a1 + 19) >> 4) & 1;
}

uint64_t sub_54E90(uint64_t a1)
{
  return (*(unsigned __int8 *)(a1 + 19) >> 1) & 1;
}

uint64_t sub_54E9C(uint64_t a1)
{
  return (*(unsigned __int8 *)(a1 + 19) >> 2) & 1;
}

uint64_t sub_54EA8(uint64_t a1)
{
  return (*(unsigned __int8 *)(a1 + 19) >> 5) & 1;
}

uint64_t sub_54EB4(uint64_t a1)
{
  return (*(unsigned __int8 *)(a1 + 19) >> 3) & 1;
}

const char *sub_54EC0(uint64_t a1)
{
  if ((*(_BYTE *)(a1 + 19) & 2) != 0) {
    return "AWDL";
  }
  if ((*(_BYTE *)(a1 + 19) & 1) != 0) {
    return "WiFi";
  }
  int v1 = *(unsigned __int8 *)(a1 + 18);
  unsigned int v2 = "Bridge";
  uint64_t v3 = "Cellular";
  if (v1 != 255) {
    uint64_t v3 = 0LL;
  }
  if (v1 != 209) {
    unsigned int v2 = v3;
  }
  __int128 v4 = "Link Aggregate";
  unsigned int v5 = "Firewire";
  if (v1 != 144) {
    unsigned int v5 = 0LL;
  }
  if (v1 != 136) {
    __int128 v4 = v5;
  }
  int v6 = "Ethernet";
  uint64_t v7 = "6to4";
  uint64_t v8 = "VLAN";
  if (v1 != 135) {
    uint64_t v8 = 0LL;
  }
  if (v1 != 57) {
    uint64_t v7 = v8;
  }
  if (v1 != 6) {
    int v6 = v7;
  }
  else {
    return v2;
  }
}

uint64_t sub_54F6C(uint64_t a1)
{
  return *(unsigned __int16 *)(a1 + 72);
}

uint64_t sub_54F74(uint64_t a1)
{
  return *(void *)(a1 + 80);
}

uint64_t sub_54F84(uint64_t a1)
{
  int v2 = socket(2, 2, 0);
  if ((v2 & 0x80000000) == 0)
  {
    int v3 = v2;
    if (sub_5518C(v2, a1, (uint64_t)&v17 + 4))
    {
      if (v19 < 1)
      {
        int v5 = 0;
        unint64_t v4 = 0LL;
        uint64_t v6 = 0LL;
      }

      else
      {
        unint64_t v4 = (unint64_t)(v18 & 2) << 31;
        if ((v18 & 1) != 0) {
          int v5 = (v18 >> 2) & 1;
        }
        else {
          int v5 = 0;
        }
        if ((v18 & 1) != 0)
        {
          uint64_t v6 = 1LL;
        }

        else
        {
          unint64_t v4 = 0LL;
          uint64_t v6 = 0LL;
        }
      }

      *(void *)(a1 + 8snprintf(__str, 0x100uLL, "/dev/bpf%d", 0) = v6 | v4;
      *(_DWORD *)(a1 + 88) = v5;
    }

    else if (*__error() != 6 && *__error() != 82 && *__error() != 22)
    {
      uint64_t v7 = sub_57538();
      uint64_t v8 = _SC_syslog_os_log_mapping(5LL);
      if (__SC_log_enabled(5LL, v7, v8))
      {
        uint64_t v9 = _os_log_pack_size(22LL);
        int v10 = (char *)&v16 - ((__chkstk_darwin(v9) + 15) & 0xFFFFFFFFFFFFFFF0LL);
        size_t v11 = __error();
        uint64_t v12 = _os_log_pack_fill(v10, v9, *v11, &dword_0, "%s: failed to get media status, %s", v16, v17);
        int v13 = __error();
        int v14 = strerror(*v13);
        *(_DWORD *)uint64_t v12 = 136315394;
        *(void *)(v12 + 4) = a1;
        *(_WORD *)(v12 + 12) = 2080;
        *(void *)(v12 + 14) = v14;
        __SC_log_send(5LL, v7, v8, v10);
      }
    }

    *(_BYTE *)(a1 + 19) = *(_BYTE *)(a1 + 19) & 0xF7 | (sub_5521C(v3, a1) >> 11) & 8;
    close(v3);
  }

  return *(void *)(a1 + 80);
}

uint64_t sub_5518C(int a1, uint64_t a2, uint64_t a3)
{
  *(_OWORD *)(a3 + 28) = 0u;
  *(_OWORD *)a3 = 0u;
  *(_OWORD *)(a3 + 16) = 0u;
  __strlcpy_chk(a3, a2, 16LL, 16LL);
  if (ioctl(a1, 0xC02C6938uLL, a3) != -1) {
    return 1LL;
  }
  if (*__error() != 102) {
    return 0LL;
  }
  *(_DWORD *)(a3 + 24) = 3;
  uint64_t result = 1LL;
  *(_DWORD *)(a3 + 32) = 1;
  return result;
}

uint64_t sub_5521C(int a1, uint64_t a2)
{
  __int128 v13 = 0u;
  __int128 v14 = 0u;
  __strlcpy_chk(&v13, a2, 16LL, 16LL);
  if (ioctl(a1, 0xC020698EuLL, &v13) != -1) {
    return v14;
  }
  if (*__error() != 6 && *__error() != 82 && *__error() != 22)
  {
    uint64_t v5 = sub_57538();
    uint64_t v6 = _SC_syslog_os_log_mapping(5LL);
    if (__SC_log_enabled(5LL, v5, v6))
    {
      uint64_t v7 = _os_log_pack_size(22LL);
      uint64_t v8 = (char *)&v13 - ((__chkstk_darwin(v7) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v9 = __error();
      uint64_t v10 = _os_log_pack_fill( v8,  v7,  *v9,  &dword_0,  "%s: SIOCGIFEFLAGS failed status, %s",  (const char *)v13,  *((const char **)&v13 + 1));
      size_t v11 = __error();
      uint64_t v12 = strerror(*v11);
      *(_DWORD *)uint64_t v10 = 136315394;
      *(void *)(v10 + 4) = a2;
      *(_WORD *)(v10 + 12) = 2080;
      *(void *)(v10 + 14) = v12;
      __SC_log_send(5LL, v5, v6, v8);
    }
  }

  return 0LL;
}

uint64_t sub_553BC(uint64_t *a1, uint64_t a2)
{
  int v2 = *((_DWORD *)a1 + 2);
  if (v2 >= *((_DWORD *)a1 + 3)) {
    return 0LL;
  }
  uint64_t v3 = *a1;
  *((_DWORD *)a1 + 2) = v2 + 1;
  uint64_t v4 = v3 + 96LL * v2;
  *(_OWORD *)(v4 + 64) = 0u;
  *(_OWORD *)(v4 + 8snprintf(__str, 0x100uLL, "/dev/bpf%d", 0) = 0u;
  *(_OWORD *)(v4 + 32) = 0u;
  *(_OWORD *)(v4 + 48) = 0u;
  *(_OWORD *)uint64_t v4 = 0u;
  *(_OWORD *)(v4 + 16) = 0u;
  __strlcpy_chk(v4, a2, 16LL, 16LL);
  sub_53D14((void *)(v4 + 24), (uint64_t)j__free, (uint64_t)sub_53F88);
  return v4;
}

CFMutableDictionaryRef sub_5543C(char *path)
{
  CFMutableDictionaryRef properties = 0LL;
  io_registry_entry_t v1 = IORegistryEntryFromPath(kIOMainPortDefault, path);
  if (!v1) {
    return 0LL;
  }
  io_object_t v2 = v1;
  if (IORegistryEntryCreateCFProperties(v1, &properties, kCFAllocatorDefault, 0)) {
    CFMutableDictionaryRef properties = 0LL;
  }
  IOObjectRelease(v2);
  return properties;
}

CFMutableDictionaryRef sub_554B0(char *bsdName, int a2)
{
  kern_return_t ParentEntry;
  io_registry_entry_t parent;
  CFMutableDictionaryRef properties;
  CFMutableDictionaryRef properties = 0LL;
  uint64_t v3 = IOBSDNameMatching(kIOMainPortDefault, 0, bsdName);
  io_service_t MatchingService = IOServiceGetMatchingService(kIOMainPortDefault, v3);
  if (!MatchingService) {
    return 0LL;
  }
  io_object_t v5 = MatchingService;
  if (a2)
  {
    ParentEntry = IORegistryEntryGetParentEntry(MatchingService, "IOService", &parent);
    if (!ParentEntry)
    {
      ParentEntry = IORegistryEntryCreateCFProperties(parent, &properties, kCFAllocatorDefault, 0);
      IOObjectRelease(parent);
    }
  }

  else
  {
    ParentEntry = IORegistryEntryCreateCFProperties(MatchingService, &properties, kCFAllocatorDefault, 0);
  }

  if (ParentEntry) {
    CFMutableDictionaryRef properties = 0LL;
  }
  IOObjectRelease(v5);
  return properties;
}

void *sub_55590(void *result)
{
  *uint64_t result = 0LL;
  result[1] = 0LL;
  return result;
}

void sub_55598(uint64_t a1)
{
  io_object_t v2 = *(void **)a1;
  if (v2) {
    free(v2);
  }
  *(void *)a1 = 0LL;
  *(void *)(a1 + 8) = 0LL;
}

uint64_t sub_555C4(uint64_t *a1, uint64_t a2)
{
  uint64_t result = 0LL;
  if (!a1) {
    goto LABEL_4;
  }
LABEL_2:
  uint64_t v4 = *a1;
  if (*a1) {
    LODWORD(v4) = *((_DWORD *)a1 + 3);
  }
  while (result < (int)v4)
  {
    uint64_t v5 = *a1;
    if (*a1)
    {
      else {
        uint64_t v5 = *(void *)(v5 + 8 * result);
      }
    }

    if (v5 == a2) {
      return result;
    }
    ++result;
    if (a1) {
      goto LABEL_2;
    }
LABEL_4:
    LODWORD(v4) = 0;
  }

  return 0xFFFFFFFFLL;
}

uint64_t sub_55628(uint64_t result)
{
  if (result)
  {
    if (*(void *)result) {
      return *(unsigned int *)(result + 12);
    }
    else {
      return 0LL;
    }
  }

  return result;
}

uint64_t sub_55644(uint64_t a1, int a2)
{
  if (*(void *)a1 && *(_DWORD *)(a1 + 12) > a2) {
    return *(void *)(*(void *)a1 + 8LL * a2);
  }
  else {
    return 0LL;
  }
}

uint64_t sub_55668(uint64_t *a1, unsigned int a2, void *a3)
{
  uint64_t v3 = *a1;
  if (!*a1) {
    return 0LL;
  }
  uint64_t result = 0LL;
  if ((a2 & 0x80000000) == 0)
  {
    int v6 = *((_DWORD *)a1 + 3);
    if (v6 > (int)a2)
    {
      if (a3) {
        *a3 = *(void *)(v3 + 8LL * a2);
      }
      if ((int)(v6 + ~a2) >= 1)
      {
        memmove((void *)(*a1 + 8LL * a2), (const void *)(*a1 + 8LL * (a2 + 1)), 8LL * (v6 + ~a2));
        int v6 = *((_DWORD *)a1 + 3);
      }

      *((_DWORD *)a1 + 3) = v6 - 1;
      return 1LL;
    }
  }

  return result;
}

BOOL sub_556EC(uint64_t a1, uint64_t a2)
{
  BOOL result = sub_5572C(a1);
  if (result)
  {
    uint64_t v5 = *(void *)a1;
    uint64_t v6 = *(int *)(a1 + 12);
    *(_DWORD *)(a1 + 12) = v6 + 1;
    *(void *)(v5 + 8 * v6) = a2;
    return 1LL;
  }

  return result;
}

BOOL sub_5572C(uint64_t a1)
{
  io_object_t v2 = *(void **)a1;
  int v3 = *(_DWORD *)(a1 + 8);
  if (!v2)
  {
    if (!v3)
    {
      int v3 = 16;
      *(_DWORD *)(a1 + 8) = 16;
    }

    *(_DWORD *)(a1 + 12) = 0;
    io_object_t v2 = malloc(8LL * v3);
    goto LABEL_7;
  }

  if (v3 == *(_DWORD *)(a1 + 12))
  {
    *(_DWORD *)(a1 + 8) = 2 * v3;
    io_object_t v2 = realloc(v2, 16LL * v3);
LABEL_7:
    *(void *)a1 = v2;
  }

  return v2 != 0LL;
}

BOOL sub_5579C(uint64_t a1, uint64_t a2, unsigned int a3)
{
  if ((a3 & 0x80000000) != 0) {
    return 0LL;
  }
  int v6 = *(_DWORD *)(a1 + 12);
  BOOL result = sub_5572C(a1);
  if (v6 <= (int)a3)
  {
    if (!result) {
      return result;
    }
    uint64_t v8 = *(void *)a1;
    uint64_t v9 = *(int *)(a1 + 12);
    *(_DWORD *)(a1 + 12) = v9 + 1;
    *(void *)(v8 + 8 * v9) = a2;
  }

  else
  {
    if (!result) {
      return result;
    }
    memmove( (void *)(*(void *)a1 + 8LL * a3 + 8),  (const void *)(*(void *)a1 + 8LL * a3),  8LL * (int)(*(_DWORD *)(a1 + 12) - a3));
    *(void *)(*(void *)a1 + 8LL * a3) = a2;
    ++*(_DWORD *)(a1 + 12);
  }

  return 1LL;
}

char *sub_55838(char **a1, uint64_t a2)
{
  int v2 = *(_DWORD *)(a2 + 12);
  if (!v2) {
    return (_BYTE *)(&dword_0 + 1);
  }
  int v5 = *((_DWORD *)a1 + 3) + v2;
  if (v5 <= *((_DWORD *)a1 + 2))
  {
    BOOL result = *a1;
    if (*a1)
    {
LABEL_9:
      memmove(&result[8 * *((int *)a1 + 3)], *(const void **)a2, 8LL * *(int *)(a2 + 12));
      *((_DWORD *)a1 + 3) += *(_DWORD *)(a2 + 12);
      return (_BYTE *)(&dword_0 + 1);
    }
  }

  else
  {
    *((_DWORD *)a1 + 2) = v5;
    int v6 = *a1;
    if (*a1) {
      BOOL result = (char *)realloc(v6, 8LL * v5);
    }
    else {
      BOOL result = (char *)malloc(8LL * v5);
    }
    *a1 = result;
    if (result) {
      goto LABEL_9;
    }
  }

  return result;
}

uint64_t sub_558D0(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = a1;
  uint64_t v3 = 0xFFFFFFFFLL / (a2 - a1 + 1);
  if (v3) {
    return arc4random() / v3 + a1;
  }
  return v2;
}

void sub_55914(CFMutableStringRef theString, uint64_t a2, int a3)
{
  if (a3 >= 1)
  {
    uint64_t v5 = 0LL;
    int v6 = 0;
    do
    {
      if (!v6) {
        CFStringAppendFormat(theString, 0LL, @"%04x ", v5);
      }
      int v8 = *(char *)(a2 + v5);
      if (v8 < 0) {
        __uint32_t v9 = __maskrune(*(unsigned __int8 *)(a2 + v5), 0x40000uLL);
      }
      else {
        __uint32_t v9 = _DefaultRuneLocale.__runetype[*(unsigned __int8 *)(a2 + v5)] & 0x40000;
      }
      unsigned __int8 v10 = *(_BYTE *)(a2 + v5);
      if (v9) {
        char v11 = v8;
      }
      else {
        char v11 = 46;
      }
      v14[v6] = v11;
      CFStringAppendFormat(theString, 0LL, @" %02x", v10);
      if (v6 == 7)
      {
        CFStringAppendFormat(theString, 0LL, @" ");
        int v6 = 8;
      }

      else if (v6 == 15)
      {
        char v15 = 0;
        CFStringAppendFormat(theString, 0LL, @"  %s\n", v14);
        int v6 = 0;
      }

      else
      {
        ++v6;
      }

      ++v5;
    }

    while (a3 != (_DWORD)v5);
    if (v6)
    {
      if (v6 >= 8) {
        uint64_t v12 = "";
      }
      else {
        uint64_t v12 = " ";
      }
      if (v6 <= 15)
      {
        uint64_t v13 = v6;
        do
        {
          CFStringAppendFormat(theString, 0LL, @"   ");
          v14[v13++] = 32;
        }

        while ((_DWORD)v13 != 16);
      }

      char v15 = 0;
      CFStringAppendFormat(theString, 0LL, @"  %s%s\n", v12, v14);
    }
  }

void sub_55AFC(__CFString *a1, uint64_t a2, int a3)
{
}

uint64_t sub_55B04(const char *a1, mode_t a2)
{
  uint64_t result = mkdir(a1, a2);
  if ((_DWORD)result)
  {
    if (*__error() == 17) {
      return 0LL;
    }
    if (*__error() == 2)
    {
      v7[0] = 0;
      if (a1)
      {
        uint64_t v5 = a1;
        while (*v5 == 47)
        {
          int v6 = strchr(v5 + 1, 47);
          uint64_t v5 = v6;
          if (!v6) {
            uint64_t v5 = &a1[strlen(a1)];
          }
          __strncpy_chk(v7, a1, v5 - a1, 1024LL);
          v7[v5 - a1] = 0;
          if (mkdir(v7, a2) && *__error() != 17) {
            return 0xFFFFFFFFLL;
          }
          uint64_t result = 0LL;
          if (!v6 || !v5) {
            return result;
          }
        }
      }

      return 0LL;
    }

    return 0xFFFFFFFFLL;
  }

  return result;
}

char *sub_55C30(char *__str, int a2, unsigned __int8 *a3, int a4)
{
  uint64_t v5 = __str;
  if (a4 == 6) {
    return (char *)snprintf(__str, a2, "%02x:%02x:%02x:%02x:%02x:%02x", *a3);
  }
  if (a4 == 8) {
    return (char *)snprintf(__str, a2, "%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x", *a3, a3[1]);
  }
  if (a4 >= 1)
  {
    uint64_t v6 = 0LL;
    uint64_t v7 = a4;
    do
    {
      int v8 = a2;
      if (v6) {
        __uint32_t v9 = ":%02x";
      }
      else {
        __uint32_t v9 = "%02x";
      }
      if (v6) {
        uint64_t v10 = 3LL;
      }
      else {
        uint64_t v10 = 2LL;
      }
      if (v6) {
        int v11 = -3;
      }
      else {
        int v11 = -2;
      }
      __str = (char *)snprintf(v5, a2, v9, a3[v6]);
      v5 += v10;
      a2 = v8 + v11;
      ++v6;
    }

    while (v7 != v6);
  }

  return __str;
}

uint64_t sub_55D70(unsigned __int8 *a1, unint64_t a2, int *a3)
{
  *(_OWORD *)(a3 + 14) = 0u;
  *(_OWORD *)(a3 + 1snprintf(__str, 0x100uLL, "/dev/bpf%d", 0) = 0u;
  *(_OWORD *)(a3 + 6) = 0u;
  *(_OWORD *)(a3 + 2) = 0u;
  if ((unint64_t)a1 < a2)
  {
    unint64_t v3 = 0LL;
    unsigned int v6 = *a3;
    uint64_t v4 = a3 + 2;
    unsigned int v5 = v6;
    while (1)
    {
      if (((v5 >> v3) & 1) != 0)
      {
        uint64_t v7 = *a1;
        *(void *)&v4[2 * v3] = a1;
        if ((_DWORD)v7) {
          uint64_t v8 = (((_DWORD)v7 - 1) & 0xFFFFFFFC) + 4LL;
        }
        else {
          uint64_t v8 = 4LL;
        }
        a1 += v8;
      }

      uint64_t v9 = 0LL;
      if (v3 <= 6)
      {
        ++v3;
      }

      return v9;
    }
  }

  return 0LL;
}

uint64_t arp_open_routing_socket()
{
  uint64_t v0 = socket(17, 3, 17);
  if ((v0 & 0x80000000) != 0) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v1 = v0;
  int v3 = 1;
  if (ioctl(v0, 0x8004667EuLL, &v3) < 0)
  {
    close(v1);
    return 0xFFFFFFFFLL;
  }

  return v1;
}

uint64_t arp_get_next_seq()
{
  return ++dword_6C2B8;
}

uint64_t arp_get(int a1, uint64_t a2, int a3, int a4)
{
  pid_t v8 = getpid();
  *(_OWORD *)a2 = 0u;
  *(_OWORD *)(a2 + 16) = 0u;
  *(_OWORD *)(a2 + 32) = 0u;
  *(_OWORD *)(a2 + 48) = 0u;
  *(_OWORD *)(a2 + 64) = 0u;
  *(_OWORD *)(a2 + 76) = 0u;
  *(_DWORD *)(a2 + 8) = 1024;
  if (a4)
  {
    *(_WORD *)(a2 + 4) = a4;
    *(_DWORD *)(a2 + 8) = 16778240;
  }

  *(_DWORD *)(a2 + 12) = 1;
  *(_OWORD *)(a2 + 92) = xmmword_59688;
  *(_DWORD *)(a2 + 96) = a3;
  *(_DWORD *)a2 = 285540460;
  int v9 = dword_6C2B8 + 1;
  dword_6C2B8 = v9;
  *(_DWORD *)(a2 + 2snprintf(__str, 0x100uLL, "/dev/bpf%d", 0) = v9;
  *__error() = 0;
  while (*(_BYTE *)(a2 + 3) != 4 || *(_DWORD *)(a2 + 20) != v9 || *(_DWORD *)(a2 + 16) != v8)
  {
  }

  if ((~*(_DWORD *)(a2 + 12) & 3) != 0) {
    return 5LL;
  }
  if ((*(_DWORD *)(a2 + 8) & 0x402) != 0x400) {
    return 5LL;
  }
  if (*(_DWORD *)(a2 + 96) != a3) {
    return 5LL;
  }
  uint64_t v11 = a2 + 92 + *(unsigned __int8 *)(a2 + 92);
  if (*(_BYTE *)(v11 + 1) != 18) {
    return 5LL;
  }
  uint64_t result = 0LL;
  unsigned int v12 = *(unsigned __int8 *)(v11 + 4);
  BOOL v13 = v12 > 0xF || ((1 << v12) & 0x83C0) == 0;
  if (v13 && v12 != 144) {
    return 5LL;
  }
  return result;
}

unint64_t arp_delete(int a1, int a2, int a3)
{
  unint64_t result = arp_get(a1, (uint64_t)&__buf, a2, a3);
  if (!(_DWORD)result)
  {
    int v7 = ++dword_6C2B8;
    char v6 = 2;
    return (unint64_t)write(a1, &__buf, __buf) >> 63;
  }

  return result;
}

uint64_t arp_flush(int a1, int a2, int a3)
{
  *(_OWORD *)unsigned int v12 = xmmword_59500;
  uint64_t v13 = 0x40000000002LL;
  if (sysctl(v12, 6u, 0LL, &__size, 0LL, 0LL) < 0) {
    return 1LL;
  }
  char v6 = (unsigned __int16 *)malloc(__size);
  if (!v6) {
    return 1LL;
  }
  int v7 = v6;
  if (sysctl(v12, 6u, v6, &__size, 0LL, 0LL) < 0)
  {
    free(v7);
    return 1LL;
  }

  if ((uint64_t)__size >= 1)
  {
    unint64_t v8 = (unint64_t)v7 + __size;
    int v9 = v7;
    do
    {
      if ((a2 || *((_DWORD *)v9 + 12))
        && (!a3 || v9[48] != 65193 || v9[2] == a3)
        && *((_BYTE *)v9 + *((unsigned __int8 *)v9 + 92) + 93) == 18)
      {
        *((_DWORD *)v9 + 5) = ++dword_6C2B8;
        *((_BYTE *)v9 + 3) = 2;
        write(a1, v9, *v9);
      }

      int v9 = (unsigned __int16 *)((char *)v9 + *v9);
    }

    while ((unint64_t)v9 < v8);
  }

  free(v7);
  return 0LL;
}

uint64_t sub_56244(int a1, int a2, void *a3, uint64_t a4, int a5, int a6)
{
  uint64_t v6 = a5;
  v11[0] = a4;
  v11[1] = a5;
  v10.msg_name = a3;
  v10.msg_namelen = 28;
  v10.msg_iov = (iovec *)v11;
  v10.msg_iovlen = 1;
  v10.msg_control = &v12;
  if (a6 >= 0) {
    socklen_t v7 = 48;
  }
  else {
    socklen_t v7 = 32;
  }
  v10.msg_controllen = v7;
  v10.msg_flags = 0;
  __int128 v15 = 0u;
  __int128 v14 = 0u;
  int v13 = 46;
  uint64_t v12 = 0x2900000020LL;
  int v16 = 0;
  LODWORD(v15) = a2;
  if ((a6 & 0x80000000) == 0)
  {
    *(void *)((char *)&v15 + 4) = 0x2900000010LL;
    HIDWORD(v15) = 47;
    int v16 = a6;
  }

  ssize_t v8 = sendmsg(a1, &v10, 0);
  uint64_t result = 0LL;
  if (v8 != v6) {
    return *__error();
  }
  return result;
}

void sub_56334()
{
  if (qword_6C2C0) {
    SCPreferencesSynchronize((SCPreferencesRef)qword_6C2C0);
  }
  if (qword_6C2C8) {
    SCPreferencesSynchronize((SCPreferencesRef)qword_6C2C8);
  }
}

const __SCPreferences *sub_56368(dispatch_queue_s *a1, uint64_t (*a2)(void))
{
  uint64_t result = SCPreferencesCreate( 0LL,  @"IPConfigurationControlPrefs",  @"com.apple.IPConfiguration.control.plist");
  qword_6C2C0 = (uint64_t)result;
  if (a1)
  {
    if (a2)
    {
      off_6C2D0 = a2;
      SCPreferencesSetCallback(result, (SCPreferencesCallBack)sub_563FC, 0LL);
      SCPreferencesSetDispatchQueue((SCPreferencesRef)qword_6C2C0, a1);
      _scprefs_observer_watch(2LL, "com.apple.IPConfiguration.control.plist", a1, &stru_666A0);
      return (const __SCPreferences *)qword_6C2C0;
    }
  }

  return result;
}

uint64_t sub_563FC()
{
  if (off_6C2D0) {
    return off_6C2D0(qword_6C2C0);
  }
  return result;
}

const void *sub_56418(const void *cf2)
{
  if (cf2)
  {
    uint64_t v1 = cf2;
    uint64_t v2 = 0LL;
    while (!CFEqual(*(CFTypeRef *)&dword_66650[v2 + 2], v1))
    {
      v2 += 4LL;
      if ((_DWORD)(v2 * 4) == 48) {
        return 0LL;
      }
    }

    return (const void *)dword_66650[v2];
  }

  return cf2;
}

uint64_t sub_56478(int a1)
{
  uint64_t v1 = 0LL;
  while (dword_66650[v1] != a1)
  {
    v1 += 4LL;
    if ((_DWORD)(v1 * 4) == 48) {
      return 0LL;
    }
  }

  return *(void *)&dword_66650[v1 + 2];
}

uint64_t sub_564B0(uint64_t a1)
{
  uint64_t v2 = (const __CFBoolean *)sub_564EC(@"Verbose");
  if (v2) {
    return CFBooleanGetValue(v2);
  }
  else {
    return a1;
  }
}

CFPropertyListRef sub_564EC(CFStringRef key)
{
  uint64_t v2 = (const __SCPreferences *)qword_6C2C8;
  if (!qword_6C2C8)
  {
    uint64_t v2 = SCPreferencesCreate( 0LL,  @"IPConfigurationControlPrefs",  @"/Library/Managed Preferences/mobile/com.apple.IPConfiguration.control.plist");
    qword_6C2C8 = (uint64_t)v2;
  }

  CFPropertyListRef Value = SCPreferencesGetValue(v2, key);
  CFTypeID TypeID = CFBooleanGetTypeID();
  if (!Value || CFGetTypeID(Value) != TypeID)
  {
    unsigned int v5 = (const __SCPreferences *)qword_6C2C0;
    if (!qword_6C2C0)
    {
      unsigned int v5 = SCPreferencesCreate( 0LL,  @"IPConfigurationControlPrefs",  @"com.apple.IPConfiguration.control.plist");
      qword_6C2C0 = (uint64_t)v5;
    }

    CFPropertyListRef v6 = SCPreferencesGetValue(v5, key);
    CFTypeID v7 = CFBooleanGetTypeID();
    if (v6)
    {
      if (CFGetTypeID(v6) == v7) {
        return v6;
      }
      else {
        return 0LL;
      }
    }

    else
    {
      return 0LL;
    }
  }

  return Value;
}

const void *sub_565B4()
{
  uint64_t v0 = (const __SCPreferences *)qword_6C2C8;
  if (!qword_6C2C8)
  {
    uint64_t v0 = SCPreferencesCreate( 0LL,  @"IPConfigurationControlPrefs",  @"/Library/Managed Preferences/mobile/com.apple.IPConfiguration.control.plist");
    qword_6C2C8 = (uint64_t)v0;
  }

  CFPropertyListRef Value = SCPreferencesGetValue(v0, @"AWDReportInterfaceTypes");
  CFTypeID TypeID = CFStringGetTypeID();
  if (!Value || CFGetTypeID(Value) != TypeID)
  {
    int v3 = (const __SCPreferences *)qword_6C2C0;
    if (!qword_6C2C0)
    {
      int v3 = SCPreferencesCreate( 0LL,  @"IPConfigurationControlPrefs",  @"com.apple.IPConfiguration.control.plist");
      qword_6C2C0 = (uint64_t)v3;
    }

    CFPropertyListRef Value = SCPreferencesGetValue(v3, @"AWDReportInterfaceTypes");
    CFTypeID v4 = CFStringGetTypeID();
    if (Value && CFGetTypeID(Value) != v4) {
      CFPropertyListRef Value = 0LL;
    }
  }

  return sub_56418(Value);
}

uint64_t sub_56670(uint64_t a1)
{
  uint64_t v2 = (const __CFBoolean *)sub_564EC(@"CellularCLAT46AutoEnable");
  if (v2) {
    return CFBooleanGetValue(v2);
  }
  else {
    return a1;
  }
}

uint64_t sub_566AC(uint64_t a1)
{
  uint64_t v2 = (const __CFBoolean *)sub_564EC(@"IPv6LinkLocalModifierExpires");
  if (v2) {
    return CFBooleanGetValue(v2);
  }
  else {
    return a1;
  }
}

uint64_t sub_566E8()
{
  int valuePtr = 0;
  uint64_t v0 = (const __SCPreferences *)qword_6C2C8;
  if (!qword_6C2C8)
  {
    uint64_t v0 = SCPreferencesCreate( 0LL,  @"IPConfigurationControlPrefs",  @"/Library/Managed Preferences/mobile/com.apple.IPConfiguration.control.plist");
    qword_6C2C8 = (uint64_t)v0;
  }

  CFPropertyListRef Value = SCPreferencesGetValue(v0, @"DHCPDUIDType");
  CFTypeID TypeID = CFNumberGetTypeID();
  if (Value && CFGetTypeID(Value) == TypeID) {
    goto LABEL_9;
  }
  int v3 = (const __SCPreferences *)qword_6C2C0;
  if (!qword_6C2C0)
  {
    int v3 = SCPreferencesCreate( 0LL,  @"IPConfigurationControlPrefs",  @"com.apple.IPConfiguration.control.plist");
    qword_6C2C0 = (uint64_t)v3;
  }

  CFPropertyListRef Value = SCPreferencesGetValue(v3, @"DHCPDUIDType");
  CFTypeID v4 = CFNumberGetTypeID();
  if (Value && CFGetTypeID(Value) == v4)
  {
LABEL_9:
    CFNumberGetValue((CFNumberRef)Value, kCFNumberIntType, &valuePtr);
    return (unsigned __int16)valuePtr;
  }

  else
  {
    return 0;
  }

void sub_567CC(id a1)
{
  if (off_6C2D0) {
    off_6C2D0(qword_6C2C0);
  }
}

const char *sub_567E8(unsigned int a1)
{
  if (a1 > 4) {
    return "<unknown>";
  }
  else {
    return (&off_666C0)[a1];
  }
}

void sub_5680C(CFMutableStringRef theString, unsigned __int16 *a2, uint64_t a3)
{
  int v3 = a3;
  if ((int)a3 >= 2)
  {
    uint64_t v7 = bswap32(*a2) >> 16;
    switch((int)v7)
    {
      case 1:
        int v8 = a3 - 8;
        if (a3 < 8)
        {
          uint64_t v6 = 8LL;
          goto LABEL_3;
        }

        CFStringAppendFormat( theString,  0LL,  @"DUID LLT HW %d Time %u Addr ",  bswap32(a2[1]) >> 16,  bswap32(*((_DWORD *)a2 + 1)));
        uint64_t v9 = (uint64_t)(a2 + 4);
        goto LABEL_17;
      case 2:
        int v8 = a3 - 6;
        if (a3 < 6)
        {
          uint64_t v6 = 6LL;
          goto LABEL_3;
        }

        CFStringAppendFormat(theString, 0LL, @"DUID EN Num %d Id ", __rev16(a2[2]));
        uint64_t v9 = (uint64_t)(a2 + 3);
        goto LABEL_17;
      case 3:
        int v8 = a3 - 4;
        if (a3 < 4)
        {
          uint64_t v6 = 4LL;
          goto LABEL_3;
        }

        CFStringAppendFormat(theString, 0LL, @"DUID LL HW %d Addr ", bswap32(a2[1]) >> 16);
        uint64_t v9 = (uint64_t)(a2 + 2);
LABEL_17:
        sub_5040C(theString, v9, v8, 58);
        return;
      case 4:
        if (a3 < 0x12)
        {
          uint64_t v6 = 18LL;
          goto LABEL_3;
        }

        uuid_unparse((const unsigned __int8 *)a2 + 2, out);
        CFStringAppendFormat(theString, 0LL, @"DUID UUID %s", out);
        break;
      default:
        CFStringAppendFormat(theString, 0LL, @"DUID (unrecognized type=%d): ", v7);
        sub_5040C(theString, (uint64_t)a2, v3, 32);
        return;
    }
  }

  else
  {
    uint64_t v6 = 2LL;
LABEL_3:
    CFStringAppendFormat(theString, 0LL, @"DUID too short (%d < %d), Data = { ", a3, v6);
    sub_5040C(theString, (uint64_t)a2, v3, 32);
    CFStringAppendCString(theString, " }", 0x600u);
  }

BOOL sub_56AA8(unsigned __int16 *a1, int a2)
{
  if (a2 < 2) {
    return 0LL;
  }
  unsigned int v2 = (bswap32(*a1) >> 16) - 1;
  return (unsigned __int16)v2 <= 3u && dword_596B0[(__int16)v2] <= a2;
}

__CFData *sub_56AF0(const void *a1, int a2, unsigned int a3)
{
  size_t v5 = a2;
  CFIndex v6 = a2 + 4;
  CFMutableStringRef Mutable = CFDataCreateMutable(0LL, v6);
  CFDataSetLength(Mutable, v6);
  MutableBytePtr = CFDataGetMutableBytePtr(Mutable);
  *(_WORD *)MutableBytePtr = 768;
  *((_WORD *)MutableBytePtr + 1) = bswap32(a3) >> 16;
  memcpy(MutableBytePtr + 4, a1, v5);
  return Mutable;
}

__CFData *sub_56B74(const void *a1, int a2, unsigned int a3)
{
  size_t v5 = a2;
  CFIndex v6 = a2 + 8;
  CFMutableStringRef Mutable = CFDataCreateMutable(0LL, v6);
  CFDataSetLength(Mutable, v6);
  MutableBytePtr = CFDataGetMutableBytePtr(Mutable);
  *(_WORD *)MutableBytePtr = 256;
  *((_WORD *)MutableBytePtr + 1) = bswap32(a3) >> 16;
  memcpy(MutableBytePtr + 8, a1, v5);
  memset(&v11, 0, sizeof(v11));
  v11.tm_year = 100;
  v11.tm_mday = 1;
  int v9 = timegm(&v11);
  *((_DWORD *)MutableBytePtr + 1) = bswap32(time(0LL) - v9);
  return Mutable;
}

__CFData *sub_56C44(const unsigned __int8 *a1)
{
  CFMutableStringRef Mutable = CFDataCreateMutable(0LL, 18LL);
  CFDataSetLength(Mutable, 18LL);
  MutableBytePtr = CFDataGetMutableBytePtr(Mutable);
  *(_WORD *)MutableBytePtr = 1024;
  uuid_copy(MutableBytePtr + 2, a1);
  return Mutable;
}

const char *DHCPv6MessageTypeName(unsigned int a1)
{
  if (a1 > 0xD) {
    return "<unknown";
  }
  else {
    return (&off_666E8)[(char)a1];
  }
}

_BYTE *DHCPv6PacketSetMessageType(_BYTE *result, char a2)
{
  *uint64_t result = a2;
  return result;
}

_BYTE *DHCPv6PacketSetTransactionID(_BYTE *result, unsigned int a2)
{
  unsigned int v2 = bswap32(a2);
  result[1] = BYTE1(v2);
  result[2] = BYTE2(v2);
  result[3] = HIBYTE(v2);
  return result;
}

uint64_t DHCPv6PacketGetTransactionID(unsigned __int8 *a1)
{
  return bswap32((a1[1] << 8) | (a1[2] << 16) | (a1[3] << 24));
}

void DHCPv6PacketPrintToString(CFMutableStringRef theString, unsigned __int8 *a2, uint64_t a3)
{
  if ((int)a3 > 3)
  {
    uint64_t v6 = *a2;
    uint64_t v7 = DHCPv6MessageTypeName(*a2);
    CFStringAppendFormat( theString,  0LL,  @"DHCPv6 %s (%d) Transaction ID 0x%06x Length %d\n",  v7,  v6,  bswap32((a2[1] << 8) | (a2[2] << 16) | (a2[3] << 24)),  a3);
  }

  else
  {
    CFStringAppendFormat(theString, 0LL, @"Packet too short %d < %d\n", a3, 4LL);
  }

void DHCPv6PacketFPrint(uint64_t a1, unsigned __int8 *a2, uint64_t a3)
{
  CFMutableStringRef Mutable = CFStringCreateMutable(0LL, 0LL);
  DHCPv6PacketPrintToString(Mutable, a2, a3);
  SCPrint(1LL, a1, @"%@");
  CFRelease(Mutable);
}

ssize_t sub_56E04( int a1, _WORD *a2, const char *a3, int a4, uint64_t a5, int a6, int a7, unsigned int a8, unsigned __int16 a9, void *a10, int a11)
{
  if ((byte_6C2D8 & 1) == 0)
  {
    byte_6C2D8 = 1;
    dword_6C2DC = arc4random();
  }

  if ((a4 == 24 || a4 == 1) && (a5 || a6 == -1))
  {
    int v20 = sub_571F8((uint64_t)a3);
    if (v20 < 0)
    {
      return 0xFFFFFFFFLL;
    }

    else
    {
      int v21 = v20;
      uint64_t v46 = a3;
      unsigned int v48 = a9;
      if (a4 == 24)
      {
        *(void *)a2 = -1LL;
        a2[8] = 8;
        size_t v22 = (char *)(a2 + 9);
        uint64_t v23 = (char *)(a2 + 13);
        int v24 = a2 + 23;
        int v25 = 46;
      }

      else
      {
        size_t v22 = (char *)(a2 + 7);
        uint64_t v23 = (char *)(a2 + 11);
        int v24 = a2 + 21;
        if (a6 == -1)
        {
          int v31 = -1;
          a2[2] = -1;
        }

        else
        {
          int v31 = *(_DWORD *)a5;
          a2[2] = *(_WORD *)(a5 + 4);
        }

        *(_DWORD *)a2 = v31;
        a2[6] = 8;
        int v25 = 42;
      }

      int v32 = v25 + a11;
      memmove(v24, a10, a11);
      *(_DWORD *)uint64_t v23 = a7;
      *((_DWORD *)v23 + 1) = a6;
      *((_WORD *)v23 + 4) = 4352;
      unsigned int v33 = bswap32(a11 + 8) >> 16;
      *((_WORD *)v23 + 5) = v33;
      *((_WORD *)v22 + 1snprintf(__str, 0x100uLL, "/dev/bpf%d", 0) = __rev16(v48);
      *((_WORD *)v22 + 11) = __rev16(a8);
      *((_DWORD *)v22 + 6) = (unsigned __int16)v33;
      *((_WORD *)v22 + 13) = sub_53E88(v23, a11 + 20);
      *(void *)size_t v22 = 0LL;
      *((void *)v22 + 1) = 0LL;
      char *v22 = 69;
      *((_DWORD *)v22 + 2) = 4607;
      *((_DWORD *)v22 + 3) = a7;
      *((_DWORD *)v22 + 4) = a6;
      *((_WORD *)v22 + 1) = bswap32(a11 + 28) >> 16;
      unsigned int v34 = dword_6C2DC++;
      *((_WORD *)v22 + 2) = bswap32(v34) >> 16;
      *((_WORD *)v22 + 5) = sub_53E88(v22, 20);
      ssize_t v19 = sub_4FA00(v21, a2, v32);
      if ((v19 & 0x80000000) != 0)
      {
        uint64_t v35 = sub_57538();
        uint64_t v36 = _SC_syslog_os_log_mapping(3LL);
        if (__SC_log_enabled(3LL, v35, v36))
        {
          uint64_t v37 = _os_log_pack_size(28LL);
          int v38 = (char *)&v45 - ((__chkstk_darwin(v37) + 15) & 0xFFFFFFFFFFFFFFF0LL);
          unsigned int v39 = __error();
          uint64_t v40 = _os_log_pack_fill( v38,  v37,  *v39,  &dword_0,  "bpf_write(%s) failed: %s (%d)",  v45,  v46,  v47);
          int v41 = __error();
          int v42 = strerror(*v41);
          int v43 = *__error();
          *(_DWORD *)uint64_t v40 = 136315650;
          *(void *)(v40 + 4) = v46;
          *(_WORD *)(v40 + 12) = 2080;
          *(void *)(v40 + 14) = v42;
          *(_WORD *)(v40 + 22) = 1024;
          *(_DWORD *)(v40 + 24) = v43;
          __SC_log_send(3LL, v35, v36, v38);
        }
      }

      sub_4F718(v21);
    }
  }

  else if (a1 < 0)
  {
    uint64_t v26 = sub_57538();
    uint64_t v27 = _SC_syslog_os_log_mapping(3LL);
    if (__SC_log_enabled(3LL, v26, v27))
    {
      uint64_t v28 = _os_log_pack_size(2LL);
      uint64_t v29 = (char *)&v45 - ((__chkstk_darwin(v28) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v30 = __error();
      *(_WORD *)_os_log_pack_fill(v29, v28, *v30, &dword_0, "neither bpf nor socket send available") = 0;
      __SC_log_send(3LL, v26, v27, v29);
    }

    return 0LL;
  }

  else
  {
    *(void *)&v49.sa_data[6] = 0LL;
    *(_WORD *)&v49.sa_len = 528;
    *(_WORD *)v49.sa_uint64_t data = __rev16(a8);
    *(_DWORD *)&v49.sa_data[2] = a6;
    if (sendto(a1, a10, a11, 0, &v49, 0x10u) >= a11) {
      return 0LL;
    }
    else {
      return 0xFFFFFFFFLL;
    }
  }

  return v19;
}

uint64_t sub_571F8(uint64_t a1)
{
  uint64_t v2 = sub_4F728();
  uint64_t v3 = v2;
  if ((v2 & 0x80000000) != 0)
  {
    uint64_t v13 = sub_57538();
    uint64_t v14 = _SC_syslog_os_log_mapping(3LL);
    if (__SC_log_enabled(3LL, v13, v14))
    {
      uint64_t v15 = _os_log_pack_size(18LL);
      int v16 = (char *)&v32 - ((__chkstk_darwin(v15) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v17 = __error();
      uint64_t v18 = _os_log_pack_fill( v16,  v15,  *v17,  &dword_0,  "Transmitter: bpf_fd() failed, %s (%d)",  v32,  (_DWORD)v33);
      ssize_t v19 = __error();
      int v20 = strerror(*v19);
      int v21 = *__error();
      *(_DWORD *)uint64_t v18 = 136315394;
      *(void *)(v18 + 4) = v20;
      *(_WORD *)(v18 + 12) = 1024;
      *(_DWORD *)(v18 + 14) = v21;
      __SC_log_send(3LL, v13, v14, v16);
    }
  }

  else
  {
    if ((sub_4F908(v2) & 0x80000000) != 0)
    {
      uint64_t v22 = sub_57538();
      uint64_t v23 = _SC_syslog_os_log_mapping(3LL);
      if (__SC_log_enabled(3LL, v22, v23))
      {
        uint64_t v24 = _os_log_pack_size(18LL);
        int v25 = (char *)&v32 - ((__chkstk_darwin(v24) + 15) & 0xFFFFFFFFFFFFFFF0LL);
        uint64_t v26 = __error();
        uint64_t v27 = _os_log_pack_fill( v25,  v24,  *v26,  &dword_0,  "Transmitter: failed to set filter, %s (%d)",  v32,  (_DWORD)v33);
        uint64_t v28 = __error();
        uint64_t v29 = strerror(*v28);
        int v30 = *__error();
        *(_DWORD *)uint64_t v27 = 136315394;
        *(void *)(v27 + 4) = v29;
        *(_WORD *)(v27 + 12) = 1024;
        *(_DWORD *)(v27 + 14) = v30;
        __SC_log_send(3LL, v22, v23, v25);
      }

      goto LABEL_11;
    }

    if ((sub_4F830(v3, a1) & 0x80000000) != 0)
    {
      if (*__error() != 6)
      {
        uint64_t v4 = sub_57538();
        uint64_t v5 = _SC_syslog_os_log_mapping(3LL);
        if (__SC_log_enabled(3LL, v4, v5))
        {
          uint64_t v6 = _os_log_pack_size(28LL);
          uint64_t v7 = (char *)&v32 - ((__chkstk_darwin(v6) + 15) & 0xFFFFFFFFFFFFFFF0LL);
          int v8 = __error();
          uint64_t v9 = _os_log_pack_fill( v7,  v6,  *v8,  &dword_0,  "Transmitter: bpf_setif (%s) failed: %s (%d)",  v32,  v33,  v34);
          msghdr v10 = __error();
          tm v11 = strerror(*v10);
          int v12 = *__error();
          *(_DWORD *)uint64_t v9 = 136315650;
          *(void *)(v9 + 4) = a1;
          *(_WORD *)(v9 + 12) = 2080;
          *(void *)(v9 + 14) = v11;
          *(_WORD *)(v9 + 22) = 1024;
          *(_DWORD *)(v9 + 24) = v12;
          __SC_log_send(3LL, v4, v5, v7);
        }
      }

uint64_t sub_5752C(uint64_t result)
{
  qword_6C2E0 = result;
  return result;
}

uint64_t sub_57538()
{
  return qword_6C2E0;
}

uint64_t sub_57544(int a1)
{
  uint64_t result = 1LL;
  switch(a1)
  {
    case 1:
    case 2:
      uint64_t result = 2LL;
      break;
    case 3:
      uint64_t result = 7LL;
      break;
    case 4:
    case 7:
    case 9:
    case 10:
    case 11:
    case 15:
    case 16:
    case 17:
    case 18:
    case 19:
    case 20:
    case 27:
    case 28:
    case 29:
    case 30:
    case 31:
    case 32:
    case 33:
    case 34:
    case 35:
    case 36:
    case 37:
    case 38:
    case 39:
    case 40:
      return result;
    case 5:
      uint64_t result = 8LL;
      break;
    case 6:
    case 8:
      uint64_t result = 3LL;
      break;
    case 12:
    case 22:
    case 23:
      uint64_t result = 5LL;
      break;
    case 13:
      uint64_t result = 9LL;
      break;
    case 14:
      uint64_t result = 0LL;
      break;
    case 21:
    case 24:
      uint64_t result = 6LL;
      break;
    case 25:
      uint64_t result = 11LL;
      break;
    case 26:
      uint64_t result = 12LL;
      break;
    case 41:
    case 42:
      goto LABEL_7;
    default:
      if (a1 == 103) {
LABEL_7:
      }
        uint64_t result = 10LL;
      break;
  }

  return result;
}

const char *sub_575D0(int a1)
{
  int v1 = a1 - 1;
  uint64_t result = "CLIENTID";
  switch(v1)
  {
    case 0:
      return result;
    case 1:
      uint64_t result = "SERVERID";
      break;
    case 2:
      uint64_t result = "IA_NA";
      break;
    case 3:
      uint64_t result = "IA_TA";
      break;
    case 4:
      uint64_t result = "IAADDR";
      break;
    case 5:
      uint64_t result = "ORO";
      break;
    case 6:
      uint64_t result = "PREFERENCE";
      break;
    case 7:
      uint64_t result = "ELAPSED_TIME";
      break;
    case 8:
      uint64_t result = "RELAY_MSG";
      break;
    case 9:
    case 26:
    case 27:
    case 28:
    case 29:
    case 30:
    case 31:
    case 32:
    case 33:
    case 34:
    case 35:
    case 36:
    case 37:
    case 38:
    case 39:
      goto LABEL_5;
    case 10:
      uint64_t result = "AUTH";
      break;
    case 11:
      uint64_t result = "UNICAST";
      break;
    case 12:
      uint64_t result = "STATUS_CODE";
      break;
    case 13:
      uint64_t result = "RAPID_COMMIT";
      break;
    case 14:
      uint64_t result = "USER_CLASS";
      break;
    case 15:
      uint64_t result = "VENDOR_CLASS";
      break;
    case 16:
      uint64_t result = "VENDOR_OPTS";
      break;
    case 17:
      uint64_t result = "INTERFACE_ID";
      break;
    case 18:
      uint64_t result = "RECONF_MSG";
      break;
    case 19:
      uint64_t result = "RECONF_ACCEPT";
      break;
    case 20:
      uint64_t result = "SIP_SERVER_D";
      break;
    case 21:
      uint64_t result = "SIP_SERVER_A";
      break;
    case 22:
      uint64_t result = "DNS_SERVERS";
      break;
    case 23:
      uint64_t result = "DOMAIN_LIST";
      break;
    case 24:
      uint64_t result = "IA_PD";
      break;
    case 25:
      uint64_t result = "IAPREFIX";
      break;
    case 40:
      uint64_t result = "POSIX_TIMEZONE";
      break;
    case 41:
      uint64_t result = "TZDB_TIMEZONE";
      break;
    default:
      else {
LABEL_5:
      }
        uint64_t result = "<unknown>";
      break;
  }

  return result;
}

uint64_t sub_57754(uint64_t result, uint64_t a2, int a3)
{
  *(void *)uint64_t result = a2;
  *(_DWORD *)(result + 8) = a3;
  *(_DWORD *)(result + 12) = 0;
  return result;
}

uint64_t sub_57760(uint64_t a1)
{
  return *(unsigned int *)(a1 + 12);
}

BOOL sub_57768(uint64_t a1, unsigned int a2, size_t __len, void *__src, char *a5)
{
  int v6 = *(_DWORD *)(a1 + 8) - *(_DWORD *)(a1 + 12);
  int v7 = __len + 4;
  *a5 = 0;
  if (v6 < (int)__len + 4)
  {
    tm v11 = sub_575D0(a2);
    snprintf(a5, 0x100uLL, "No room for option %s (%d), %d < %d", v11, a2, v6, v7);
  }

  else
  {
    uint64_t v9 = (_WORD *)(*(void *)a1 + *(int *)(a1 + 12));
    _WORD *v9 = __rev16(a2);
    v9[1] = __rev16(__len);
    if ((_DWORD)__len) {
      memmove(v9 + 2, __src, __len);
    }
    *(_DWORD *)(a1 + 12) += v7;
  }

  return v6 >= v7;
}

BOOL sub_5782C(uint64_t a1)
{
  uint64_t v1 = __chkstk_darwin(a1);
  int v6 = (char *)&v11 - v5;
  if (v3 >= 1)
  {
    uint64_t v7 = v3;
    int v8 = v6;
    do
    {
      unsigned int v9 = *v2++;
      *v8++ = bswap32(v9) >> 16;
      --v7;
    }

    while (v7);
  }

  return sub_57768(v1, 6u, 2 * (v3 & 0x7FFFu), v6, v4);
}

_OWORD *sub_578CC(unsigned __int16 *a1, unsigned int a2, char *a3)
{
  int v6 = a1;
  if (a2 >= 4)
  {
    while (1)
    {
      unsigned int v8 = (bswap32(v6[1]) >> 16) + 4;
      unsigned int v7 = a2 - v8;
      sub_556EC((uint64_t)&v10, (uint64_t)v6);
      int v6 = (unsigned __int16 *)((char *)v6 + v8);
      a2 -= v8;
      if (v7 < 4) {
        goto LABEL_5;
      }
    }

    if (a3)
    {
      sub_575D0(bswap32(*v6) >> 16);
      snprintf(a3, 0x100uLL, "truncated option %s (%d) at offset %d, left %d < need %d");
    }
  }

  else
  {
    unsigned int v7 = a2;
LABEL_5:
    if (!v7)
    {
      uint64_t result = malloc(0x10uLL);
      *uint64_t result = v10;
      return result;
    }

    if (a3) {
      snprintf(a3, 0x100uLL, "truncated buffer at offset %d\n");
    }
  }

  sub_55598((uint64_t)&v10);
  return 0LL;
}

_OWORD *sub_579D0(uint64_t a1, int a2, char *a3)
{
  BOOL v3 = __OFSUB__(a2, 4);
  signed int v4 = a2 - 4;
  if (v4 < 0 != v3) {
    return 0LL;
  }
  else {
    return sub_578CC((unsigned __int16 *)(a1 + 4), v4, a3);
  }
}

void sub_579E8(void **a1)
{
  uint64_t v1 = *a1;
  if (*a1)
  {
    *a1 = 0LL;
    sub_55598((uint64_t)v1);
    free(v1);
  }

void sub_57A24(__CFString *a1, uint64_t a2)
{
}

void sub_57A2C(__CFString *a1, uint64_t a2, int a3)
{
  uint64_t v6 = sub_55628(a2);
  int v7 = v6;
  CFStringAppendFormat(a1, 0LL, @"Options[%d] = {\n", v6);
  if (v7 >= 1)
  {
    for (int i = 0; i != v7; ++i)
    {
      unsigned int v9 = (unsigned __int16 *)sub_55644(a2, i);
      unsigned int v10 = *v9;
      unsigned int v11 = v9[1];
      if (a3 >= 1)
      {
        int v12 = a3;
        do
        {
          CFStringAppendFormat(a1, 0LL, @"  ");
          --v12;
        }

        while (v12);
      }

      CFStringAppendFormat(a1, 0LL, @"  ");
      sub_57C7C(a1, bswap32(v10) >> 16, bswap32(v11) >> 16, v9 + 2, a3);
    }
  }

  if (a3 >= 1)
  {
    do
    {
      CFStringAppendFormat(a1, 0LL, @"  ");
      --a3;
    }

    while (a3);
  }

  CFStringAppendFormat(a1, 0LL, @"}\n");
}

void DHCPv6OptionListFPrint(uint64_t a1, uint64_t a2)
{
  CFMutableStringRef Mutable = CFStringCreateMutable(0LL, 0LL);
  sub_57A2C(Mutable, a2, 0);
  SCPrint(1LL, a1, @"%@\n");
  CFRelease(Mutable);
}

unsigned __int16 *sub_57BD4(uint64_t a1, int a2, unsigned int *a3, int *a4)
{
  int v8 = sub_55628(a1);
  int v9 = v8;
  if (a4) {
    int v10 = *a4;
  }
  else {
    int v10 = 0;
  }
  if (v10 >= v8) {
    return 0LL;
  }
  while (1)
  {
    unsigned int v11 = (unsigned __int16 *)sub_55644(a1, v10);
    if (a2 == bswap32(*v11) >> 16) {
      break;
    }
    if (v9 == ++v10) {
      return 0LL;
    }
  }

  if (a4) {
    *a4 = v10 + 1;
  }
  *a3 = bswap32(v11[1]) >> 16;
  return v11 + 2;
}

void sub_57C7C(__CFString *a1, unsigned int a2, uint64_t a3, unsigned __int16 *a4, int a5)
{
  int v10 = sub_575D0(a2);
  CFStringAppendFormat(a1, 0LL, @"%s (%d) Length %d: ", v10, a2, a3);
  switch(sub_57544(a2))
  {
    case 0u:
      return;
    case 2u:
      sub_5680C(a1, a4, a3);
      goto LABEL_51;
    case 3u:
      if (a3 >= 2)
      {
        uint64_t v11 = 0LL;
        do
        {
          unsigned int v12 = bswap32(a4[v11]);
          uint64_t v13 = HIWORD(v12);
          if ((_DWORD)(v11 * 2)) {
            uint64_t v14 = ", ";
          }
          else {
            uint64_t v14 = "";
          }
          if (a2 == 6)
          {
            uint64_t v35 = sub_575D0(HIWORD(v12));
            CFStringAppendFormat(a1, 0LL, @"%s%s (%d)", v14, v35, v13);
          }

          else
          {
            CFStringAppendFormat(a1, 0LL, @"%s%d", v14, HIWORD(v12), v37);
          }

          ++v11;
        }

        while ((a3 & 0xFFFE) != (_DWORD)(v11 * 2));
      }

      goto LABEL_51;
    case 4u:
      if (a3 >= 4)
      {
        uint64_t v15 = 0LL;
        int v16 = a3 & 0xFFFC;
        do
        {
          if ((_DWORD)(v15 * 2)) {
            uint64_t v17 = ", ";
          }
          else {
            uint64_t v17 = "";
          }
          CFStringAppendFormat(a1, 0LL, @"%s%d", v17, bswap32(*(_DWORD *)&a4[v15]));
          v15 += 2LL;
        }

        while (v16 != (_DWORD)(v15 * 2));
      }

      goto LABEL_51;
    case 5u:
      if (a3 >= 0x10)
      {
        uint64_t v18 = 0LL;
        int v19 = a3 & 0xFFF0;
        do
        {
          if ((_DWORD)(v18 * 2)) {
            int v20 = ", ";
          }
          else {
            int v20 = "";
          }
          int v21 = inet_ntop(30, &a4[v18], v39, 0x2Eu);
          CFStringAppendFormat(a1, 0LL, @"%s%s", v20, v21);
          v18 += 8LL;
        }

        while (v19 != (_DWORD)(v18 * 2));
      }

      goto LABEL_55;
    case 6u:
      uint64_t v22 = sub_5311C((uint64_t)a4, a3, (int *)v39);
      if (v22)
      {
        uint64_t v23 = v22;
        if (*(int *)v39 >= 1)
        {
          uint64_t v24 = 0LL;
          do
          {
            if (v24) {
              int v25 = ", ";
            }
            else {
              int v25 = "";
            }
            CFStringAppendFormat(a1, 0LL, @"%s%s", v25, *(void *)&v23[8 * v24++]);
          }

          while (v24 < *(int *)v39);
        }

        free(v23);
      }

      else
      {
        CFStringAppendFormat(a1, 0LL, @" Invalid");
LABEL_53:
        if ((_DWORD)a3)
        {
          CFStringAppendFormat(a1, 0LL, @" Data ");
          sub_55AFC(a1, (uint64_t)a4, a3);
        }
      }

void sub_58208(CFMutableStringRef theString, uint64_t a2, uint64_t a3, int a4)
{
  if ((int)a3 > 23)
  {
    unsigned int v7 = a3 - 24;
    int v8 = inet_ntop(30, (const void *)a2, v11, 0x2Eu);
    CFStringAppendFormat( theString,  0LL,  @" IAADDR %s Preferred %d Valid=%d",  v8,  bswap32(*(_DWORD *)(a2 + 16)),  bswap32(*(_DWORD *)(a2 + 20)));
    if (v7) {
      sub_585B4(theString, (unsigned __int16 *)(a2 + 24), v7, a4);
    }
    else {
      CFStringAppendFormat(theString, 0LL, @"\n", v9, v10);
    }
  }

  else
  {
    CFStringAppendFormat(theString, 0LL, @" IAADDR option is too short %d < %d\n", a3, 24LL);
  }

void sub_582F0(CFMutableStringRef theString, uint64_t a2, uint64_t a3, int a4)
{
  if ((int)a3 > 24)
  {
    unsigned int v7 = a3 - 25;
    int v8 = inet_ntop(30, (const void *)(a2 + 9), v11, 0x2Eu);
    CFStringAppendFormat( theString,  0LL,  @" IAPREFIX %s/%d Preferred %d Valid=%d",  v8,  *(unsigned __int8 *)(a2 + 8),  bswap32(*(_DWORD *)a2),  bswap32(*(_DWORD *)(a2 + 4)));
    if (v7) {
      sub_585B4(theString, (unsigned __int16 *)(a2 + 25), v7, a4);
    }
    else {
      CFStringAppendFormat(theString, 0LL, @"\n", v9, v10);
    }
  }

  else
  {
    CFStringAppendFormat(theString, 0LL, @" IAPREFIX option is too short %d < %d\n", a3, 25LL);
  }

const char *sub_583E0(unsigned int a1)
{
  if (a1 > 0x16) {
    return "<unknown>";
  }
  else {
    return (&off_66758)[(__int16)a1];
  }
}

uint64_t sub_58408(uint64_t a1, _WORD *a2, unsigned __int16 **a3, unsigned int *a4)
{
  unsigned int v7 = sub_57BD4(a1, 13, v21, 0LL);
  if (!v7)
  {
    unsigned int v9 = 0;
    LOWORD(v11) = 0;
    goto LABEL_5;
  }

  unsigned int v8 = v21[0];
  unsigned int v9 = v21[0] - 2;
  if ((int)v21[0] >= 2)
  {
    unsigned int v10 = *v7++;
    unsigned int v11 = bswap32(v10) >> 16;
LABEL_5:
    uint64_t v12 = 1LL;
    goto LABEL_9;
  }

  uint64_t v13 = _SC_LOG_DEFAULT();
  uint64_t v14 = _SC_syslog_os_log_mapping(5LL);
  if (__SC_log_enabled(5LL, v13, v14))
  {
    uint64_t v15 = _os_log_pack_size(14LL);
    int v16 = (char *)&v21[-1] - ((__chkstk_darwin(v15) + 15) & 0xFFFFFFFFFFFFFFF0LL);
    uint64_t v17 = __error();
    uint64_t v18 = _os_log_pack_fill( v16,  v15,  *v17,  &dword_0,  "DHCPv6 StatusCode option too short %d < %d",  v20,  v21[1]);
    *(_DWORD *)uint64_t v18 = 67109376;
    *(_DWORD *)(v18 + 4) = v8;
    *(_WORD *)(v18 + 8) = 1024;
    *(_DWORD *)(v18 + 1snprintf(__str, 0x100uLL, "/dev/bpf%d", 0) = 2;
    __SC_log_send(5LL, v13, v14, v16);
    LOWORD(v11) = 1;
    uint64_t v12 = 0LL;
    unsigned int v9 = 0;
    unsigned int v7 = 0LL;
  }

  else
  {
    uint64_t v12 = 0LL;
    unsigned int v9 = 0;
    unsigned int v7 = 0LL;
    LOWORD(v11) = 1;
  }

void sub_585B4(__CFString *a1, unsigned __int16 *a2, unsigned int a3, int a4)
{
  uint64_t v6 = sub_578CC(a2, a3, v8);
  if (v6)
  {
    unsigned int v7 = v6;
    CFStringAppendFormat(a1, 0LL, @" ");
    sub_57A2C(a1, v7, (a4 + 1));
    sub_55598((uint64_t)v7);
    free(v7);
  }

  else
  {
    CFStringAppendFormat(a1, 0LL, @" options invalid:\n\t%s\n", v8);
  }

void sub_58688()
{
}