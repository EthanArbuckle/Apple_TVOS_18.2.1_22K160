void _os_eventlink_xref_dispose(unsigned int *a1)
{
  _os_object_release_internal(a1);
}

void _os_eventlink_explicit_dispose(void *a1)
{
}

void _os_eventlink_dispose(uint64_t a1)
{
  if ((*(void *)(a1 + 24) & 1LL) != 0) {
    free(*(void **)(a1 + 16));
  }
  if (*(_DWORD *)(a1 + 32) && *(_DWORD *)(a1 + 32) != -1) {
    mach_port_deallocate(mach_task_self_, *(_DWORD *)(a1 + 32));
  }
  if (*(_DWORD *)(a1 + 36))
  {
    if (*(_DWORD *)(a1 + 36) != -1) {
      mach_port_deallocate(mach_task_self_, *(_DWORD *)(a1 + 36));
    }
  }
}

void *os_eventlink_create( const char *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return _os_eventlink_create_internal(a1, a2, a3, a4, a5, a6, a7, a8);
}

void *_os_eventlink_create_internal( const char *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  v10 = _os_object_alloc(_OS_os_eventlink_vtable, 0x30uLL, a3, a4, a5, a6, a7, a8);
  if (v10)
  {
    if (a1)
    {
      v9 = _dispatch_strdup_if_mutable(a1);
      if (v9 != a1) {
        v10[3] |= 1uLL;
      }
      v10[2] = v9;
    }

    return v10;
  }

  else
  {
    **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8) = 12;
    return 0LL;
  }

uint64_t os_eventlink_activate(uint64_t a1)
{
  uint64_t v8 = a1;
  unsigned int v7 = 0;
  if (!*(_DWORD *)(a1 + 32) || *(_DWORD *)(v8 + 32) == -1)
  {
    if (_os_eventlink_is_cancelled(*(void *)(v8 + 24)))
    {
      unsigned int v7 = 89;
      uint64_t v10 = 1LL;
      uint64_t v11 = 1LL;
      **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8) = 89;
      return v7;
    }

    else
    {
      memset(__b, 0, sizeof(__b));
      unsigned int v5 = mach_eventlink_create(mach_task_self_, 1LL, &__b[4]);
      if (v5) {
        return _mach_error_to_errno(v5);
      }
      v1 = (unint64_t *)(v8 + 32);
      unint64_t v2 = __b[4];
      do
        unint64_t v3 = __ldaxr(v1);
      while (!v3 && __stlxr(v2, v1));
      if (!v3)
      {
        return _mach_error_to_errno(v5);
      }

      else
      {
        if (LODWORD(__b[4]) && LODWORD(__b[4]) != -1) {
          mach_port_deallocate(mach_task_self_, __b[4]);
        }
        if (HIDWORD(__b[4]) && HIDWORD(__b[4]) != -1) {
          mach_port_deallocate(mach_task_self_, HIDWORD(__b[4]));
        }
        return 22;
      }
    }
  }

  else
  {
    return v7;
  }

BOOL _os_eventlink_is_cancelled(char a1)
{
  return (a1 & 2) == 2LL;
}

uint64_t _mach_error_to_errno(unsigned int a1)
{
  if (a1 <= 0x31uLL) {
    __asm { BR              X8 }
  }

  return 0xFFFFFFFFLL;
}

uint64_t os_eventlink_extract_remote_port(uint64_t a1, unsigned int *a2)
{
  if (!_os_eventlink_inactive(*(_DWORD *)(a1 + 32)))
  {
    if (_os_eventlink_is_cancelled(*(void *)(a1 + 24)))
    {
      **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8) = 89;
      return 89;
    }

    unsigned int v6 = *(_DWORD *)(a1 + 36);
    do
    {
      unsigned int v2 = v6;
      unsigned int v5 = (unsigned int *)(a1 + 36);
      do
        unsigned int v3 = __ldaxr(v5);
      while (v3 == v6 && __stlxr(0, v5));
      unsigned int v6 = v3;
    }

    while (v3 != v2);
    if (v3 && v3 != -1)
    {
      *a2 = v3;
      return 0;
    }
  }

  **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8) = 22;
  return 22;
}

BOOL _os_eventlink_inactive(int a1)
{
  return a1 == 0;
}

void *os_eventlink_create_with_port( const char *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  mach_port_name_t v12 = a2;
  internal = _os_eventlink_create_internal(a1, a2, a3, a4, a5, a6, a7, a8);
  if (mach_port_mod_refs(mach_task_self_, v12, 0, 1))
  {
    uint64_t v10 = _os_assert_log(0LL);
    _os_crash(v10);
    __break(1u);
  }

  if (*((_DWORD *)internal + 8))
  {
    uint64_t v9 = _os_assert_log(*((_DWORD *)internal + 8) == 0);
    _os_crash(v9);
    __break(1u);
  }

  *((_DWORD *)internal + 8) = v12;
  return internal;
}

void *os_eventlink_create_remote_with_eventlink(const char *a1, uint64_t a2)
{
  v13 = a1;
  uint64_t v12 = a2;
  mach_port_name_t name = 0;
  int v10 = os_eventlink_extract_remote_port(a2, &name);
  if (v10)
  {
    uint64_t v15 = 1LL;
    uint64_t v16 = 1LL;
    unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
    **(_DWORD **)(StatusReg + 8) = v10;
    return 0LL;
  }

  else
  {
    uint64_t v9 = os_eventlink_create_with_port(v13, name, v2, v3, v4, v5, v6, v7);
    mach_port_mod_refs(mach_task_self_, name, 0, -1);
    return v9;
  }

uint64_t os_eventlink_associate(uint64_t a1, uint64_t a2)
{
  if (_os_eventlink_inactive(*(_DWORD *)(a1 + 32)))
  {
    **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8) = 22;
    return 22;
  }

  else if (_os_eventlink_is_cancelled(*(void *)(a1 + 24)))
  {
    **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8) = 89;
    return 89;
  }

  else
  {
    if (a2 == 1) {
      unsigned int v3 = 0;
    }
    else {
      unsigned int v3 = _dispatch_thread_getspecific(3uLL);
    }
    unsigned int v4 = mach_eventlink_associate(*(unsigned int *)(a1 + 32), v3, 0LL, 0LL, 0LL, 0LL, a2 == 1);
    return _mach_error_to_errno(v4);
  }

void *_dispatch_thread_getspecific(pthread_key_t a1)
{
  if (v1) {
    char v2 = 1;
  }
  else {
    char v2 = 0;
  }
  if ((v2 & 1) != 0) {
    return pthread_getspecific(a1);
  }
  else {
    return *(void **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * a1);
  }
}

uint64_t os_eventlink_disassociate(uint64_t a1)
{
  if (_os_eventlink_inactive(*(_DWORD *)(a1 + 32)))
  {
    **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8) = 22;
    return 22;
  }

  else if (_os_eventlink_is_cancelled(*(void *)(a1 + 24)))
  {
    return 0;
  }

  else
  {
    unsigned int v2 = mach_eventlink_disassociate(*(unsigned int *)(a1 + 32), 0LL);
    if (v2 == 37) {
      return 0;
    }
    else {
      return _mach_error_to_errno(v2);
    }
  }

uint64_t os_eventlink_wait_until(uint64_t a1, int a2, uint64_t a3, void *a4)
{
  uint64_t v6 = _os_clockid_normalize_to_machabs(a2, a3);
  uint64_t v4 = mach_absolute_time();
  return os_eventlink_wait_until_internal(a1, a2, v4 + v6, a4);
}

uint64_t _os_clockid_normalize_to_machabs(int a1, uint64_t a2)
{
  uint64_t v3 = 0LL;
  if (a1 == 32) {
    return a2;
  }
  return v3;
}

uint64_t os_eventlink_wait_until_internal(uint64_t a1, int a2, uint64_t a3, void *a4)
{
  if (a2 != 32)
  {
    uint64_t v8 = _os_assert_log(a2 == 32);
    _os_crash(v8);
    __break(1u);
  }

  if (_os_eventlink_inactive(*(_DWORD *)(a1 + 32)))
  {
    **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8) = 22;
    return 22;
  }

  else if (_os_eventlink_is_cancelled(*(void *)(a1 + 24)))
  {
    **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8) = 89;
    return 89;
  }

  else
  {
    uint64_t v6 = *(void *)(a1 + 40);
    unsigned int v7 = mach_eventlink_wait_until(*(unsigned int *)(a1 + 32), a1 + 40, 0LL, 1LL, a3);
    if (v7 || !a4)
    {
      if (v7 == 15 && !_os_eventlink_is_cancelled(*(void *)(a1 + 24)))
      {
        uint64_t v5 = _os_assert_log(0LL);
        _os_crash(v5);
        __break(1u);
      }
    }

    else
    {
      *a4 = *(void *)(a1 + 40) - v6;
    }

    return _mach_error_to_errno(v7);
  }

uint64_t os_eventlink_wait(uint64_t a1, void *a2)
{
  return os_eventlink_wait_until_internal(a1, 32, 0LL, a2);
}

uint64_t os_eventlink_signal(uint64_t a1)
{
  if (_os_eventlink_inactive(*(_DWORD *)(a1 + 32)))
  {
    **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8) = 22;
    return 22;
  }

  else if (_os_eventlink_is_cancelled(*(void *)(a1 + 24)))
  {
    **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8) = 89;
    return 89;
  }

  else
  {
    unsigned int v2 = mach_eventlink_signal(*(unsigned int *)(a1 + 32), 0LL);
    return _mach_error_to_errno(v2);
  }

uint64_t os_eventlink_signal_and_wait(uint64_t a1, void *a2)
{
  return os_eventlink_signal_and_wait_until_internal(a1, 32, 0LL, a2);
}

uint64_t os_eventlink_signal_and_wait_until_internal(uint64_t a1, int a2, uint64_t a3, void *a4)
{
  if (a2 != 32)
  {
    uint64_t v7 = _os_assert_log(a2 == 32);
    _os_crash(v7);
    __break(1u);
  }

  if (_os_eventlink_inactive(*(_DWORD *)(a1 + 32)))
  {
    **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8) = 22;
    return 22;
  }

  else if (_os_eventlink_is_cancelled(*(void *)(a1 + 24)))
  {
    **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8) = 89;
    return 89;
  }

  else
  {
    uint64_t v6 = *(void *)(a1 + 40);
    unsigned int v8 = mach_eventlink_signal_wait_until(*(unsigned int *)(a1 + 32), a1 + 40, 0LL, 0LL, 1LL, a3);
    if (v8 || !a4)
    {
      if (v8 == 15 && !_os_eventlink_is_cancelled(*(void *)(a1 + 24)))
      {
        uint64_t v5 = _os_assert_log(0LL);
        _os_crash(v5);
        __break(1u);
      }
    }

    else
    {
      *a4 = *(void *)(a1 + 40) - v6;
    }

    return _mach_error_to_errno(v8);
  }

uint64_t os_eventlink_signal_and_wait_until(uint64_t a1, int a2, uint64_t a3, void *a4)
{
  uint64_t v6 = _os_clockid_normalize_to_machabs(a2, a3);
  uint64_t v4 = mach_absolute_time();
  return os_eventlink_signal_and_wait_until_internal(a1, a2, v4 + v6, a4);
}

uint64_t os_eventlink_cancel(uint64_t a1)
{
  uint64_t result = _os_eventlink_is_cancelled(*(void *)(a1 + 24));
  if ((result & 1) == 0)
  {
    uint64_t v4 = (unint64_t *)(a1 + 24);
    unint64_t v5 = *(void *)(a1 + 24);
    do
    {
      unint64_t v2 = v5;
      do
        unint64_t v3 = __ldaxr(v4);
      while (v3 == v5 && __stlxr(v5 | 2, v4));
      unint64_t v5 = v3;
    }

    while (v3 != v2);
    mach_port_name_t name = *(_DWORD *)(a1 + 32);
    if (name && name != -1)
    {
      if (mach_port_mod_refs(mach_task_self_, name, 0, 1))
      {
        uint64_t v6 = _os_assert_log(0LL);
        _os_crash(v6);
        __break(1u);
      }

      return mach_eventlink_destroy(name);
    }
  }

  return result;
}

void _os_workgroup_explicit_xref_dispose(unsigned int *a1)
{
}

void _os_workgroup_explicit_dispose( void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void _os_workgroup_interval_explicit_xref_dispose(unsigned int *a1)
{
}

void _os_workgroup_interval_explicit_dispose(void *a1)
{
}

void _os_workgroup_xref_dispose(uint64_t a1)
{
  uint64_t v1 = *(void (***)(void))(a1 + 48);
  if (v1)
  {
    v1[1](*v1);
    free(v1);
  }

uint64_t _os_workgroup_interval_xref_dispose(uint64_t result)
{
  if ((*(void *)(result + 24) & 8) != 0)
  {
    _os_crash("BUG IN CLIENT: Releasing last reference to workgroup interval while an interval has been started");
    __break(1u);
    JUMPOUT(0x2950LL);
  }

  return result;
}

void _os_workgroup_dispose( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(_DWORD *)(a1 + 60)) {
    _dispatch_abort(165LL, *(_DWORD *)(a1 + 60) == 0, a3, a4, a5, a6, a7, a8);
  }
  uint64_t v10 = *(void *)(a1 + 24);
  if (_os_workgroup_has_backing_workinterval(a1))
  {
    BOOL v8 = mach_port_mod_refs(mach_task_self_, *(_DWORD *)(a1 + 40), 0, -1) == 0;
    if (!v8) {
      _os_assumes_log(v8);
    }
    if (_os_workgroup_is_configurable(v10))
    {
      BOOL v9 = work_interval_destroy(*(void *)(a1 + 32)) == 0;
      if (!v9) {
        _os_assumes_log(v9);
      }
    }
  }

  if ((v10 & 4) != 0) {
    free(*(void **)(a1 + 16));
  }
}

BOOL _os_workgroup_has_backing_workinterval(uint64_t a1)
{
  return *(_DWORD *)(a1 + 40) != 0;
}

BOOL _os_workgroup_is_configurable(char a1)
{
  return (a1 & 1) == 1LL;
}

uint64_t _os_workgroup_interval_dispose(uint64_t a1)
{
  return work_interval_instance_free(*(void *)(a1 + 72));
}

uint64_t _os_workgroup_tsd_cleanup(uint64_t result)
{
  if (result)
  {
    __snprintf_chk( v1,  0x200uLL,  0,  0x200uLL,  "BUG IN CLIENT: Thread exiting without leaving workgroup '%s'",  *(const char **)(result + 16));
    _os_crash(v1);
    __break(1u);
    JUMPOUT(0x2BF4LL);
  }

  return result;
}

void _os_workgroup_join_token_tsd_cleanup(uint64_t a1)
{
  if (a1)
  {
    if (*(void *)(a1 + 8))
    {
      uint64_t v1 = _os_assert_log(*(void *)(a1 + 8) == 0LL);
      _os_crash(v1);
      __break(1u);
    }

    _os_workgroup_leave_update_wg(*(_DWORD **)(a1 + 16));
    free((void *)a1);
  }

void _os_workgroup_leave_update_wg(_DWORD *a1)
{
  if (_os_workgroup_get_current() != a1)
  {
    uint64_t v5 = _os_assert_log(0LL);
    _os_crash(v5);
    __break(1u);
  }

  uint64_t v3 = a1 + 15;
  unsigned int v4 = a1[15];
  do
  {
    unsigned int v1 = v4;
    do
      unsigned int v2 = __ldaxr(v3);
    while (v2 == v4 && __stlxr(v4 - 1, v3));
    unsigned int v4 = v2;
  }

  while (v2 != v1);
  if (!v2)
  {
    qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: Joined count underflowed";
    __break(1u);
  }

  _os_workgroup_set_current(0LL);
}

uint64_t _workgroup_init()
{
  return pthread_install_workgroup_functions_np(&_os_workgroup_pthread_functions);
}

uint64_t _os_workgroup_get_backing_workinterval(uint64_t a1)
{
  else {
    return 0;
  }
}

uint64_t os_workgroup_interval_data_set_flags(_DWORD *a1, int a2)
{
  unsigned int v3 = 0;
  else {
    a1[1] = a2;
  }
  return v3;
}

BOOL _os_workgroup_client_interval_data_is_valid(_DWORD *a1)
{
  BOOL v2 = 0;
  if (a1) {
    return _os_workgroup_client_interval_data_initialized(a1);
  }
  return v2;
}

uint64_t os_workgroup_interval_data_set_telemetry(uint64_t a1, __int16 a2, uint64_t a3, uint64_t a4)
{
  if (_os_workgroup_telemetry_flavor_is_valid(a2) && (a2 != 1 || a4 == 40))
  {
    *(_WORD *)(a1 + 16) = a2;
    *(void *)(a1 + 8) = a3;
    *(_WORD *)(a1 + 18) = a4;
    return 0;
  }

  else
  {
    **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8) = 22;
    return **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
  }

BOOL _os_workgroup_telemetry_flavor_is_valid(__int16 a1)
{
  return a1 == 1;
}

uint64_t os_workgroup_attr_set_interval_type(uint64_t a1, unsigned __int16 a2)
{
  unsigned int v3 = 0;
  else {
    return 22;
  }
  return v3;
}

BOOL _os_workgroup_client_attr_is_valid(_DWORD *a1)
{
  BOOL v2 = 0;
  if (a1) {
    return _os_workgroup_client_attr_initialized(a1);
  }
  return v2;
}

BOOL _os_workgroup_type_is_interval_type(unsigned __int16 a1)
{
  BOOL v2 = 0;
  if (a1) {
    return a1 <= 0xAu;
  }
  return v2;
}

uint64_t os_workgroup_attr_set_flags(_DWORD *a1, int a2)
{
  unsigned int v3 = 0;
  if (_os_workgroup_client_attr_is_valid(a1)) {
    a1[1] = a2;
  }
  else {
    return 22;
  }
  return v3;
}

uint64_t os_workgroup_attr_set_telemetry_flavor(uint64_t a1, __int16 a2)
{
  unsigned int v3 = 0;
  if (_os_workgroup_client_attr_is_valid((_DWORD *)a1) && _os_workgroup_telemetry_flavor_is_valid(a2)) {
    *(_WORD *)(a1 + 10) = a2;
  }
  else {
    return 22;
  }
  return v3;
}

__int16 *os_workgroup_interval_copy_current_4AudioToolbox()
{
  object = (__int16 *)_os_workgroup_get_current();
  if (object)
  {
    if (_os_workgroup_type_is_audio_type(object[28])) {
      return (__int16 *)os_retain(object);
    }
    else {
      return 0LL;
    }
  }

  return object;
}

void *_os_workgroup_get_current()
{
  return _dispatch_thread_getspecific(0x74uLL);
}

BOOL _os_workgroup_type_is_audio_type(__int16 a1)
{
  BOOL v2 = 1;
  if (a1 != 4) {
    return a1 == 3;
  }
  return v2;
}

void *os_workgroup_create(const char *a1, _DWORD *a2)
{
  v14 = a1;
  v13 = a2;
  uint64_t v12 = 0LL;
  uint64_t work_interval = 0LL;
  memset(__b, 0, sizeof(__b));
  v13 = _os_workgroup_client_attr_resolve(__b, v13, (uint64_t)&_os_workgroup_attr_default);
  if (v13)
  {
    if (_os_workgroup_type_is_default_type(*((_WORD *)v13 + 4)))
    {
      if (_os_workgroup_attr_is_propagating((uint64_t)v13))
      {
        uint64_t v18 = 1LL;
        uint64_t v21 = 1LL;
        unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
        **(_DWORD **)(StatusReg + 8) = 45;
        return 0LL;
      }

      else if (_os_workgroup_attr_has_telemetry_enabled((uint64_t)v13))
      {
        uint64_t v19 = 1LL;
        uint64_t v20 = 1LL;
        unint64_t v27 = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
        **(_DWORD **)(v27 + 8) = 45;
        return 0LL;
      }

      else
      {
        int v9 = 0;
        uint64_t work_interval = _os_workgroup_create_work_interval((uint64_t)v13, (uint64_t)&v9);
        if (work_interval)
        {
          uint64_t v12 = _os_object_alloc(_OS_os_workgroup_vtable, 0x40uLL, v2, v3, v4, v5, v6, v7);
          v12[4] = work_interval;
          *((_DWORD *)v12 + 10) = v9;
          v12[3] = 1LL;
          *((_WORD *)v12 + 28) = *((_WORD *)v13 + 4);
          _os_workgroup_set_name((uint64_t)v12, v14);
          return v12;
        }

        else
        {
          return 0LL;
        }
      }
    }

    else
    {
      uint64_t v17 = 1LL;
      uint64_t v22 = 1LL;
      unint64_t v25 = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
      **(_DWORD **)(v25 + 8) = 22;
      return 0LL;
    }
  }

  else
  {
    uint64_t v16 = 1LL;
    uint64_t v23 = 1LL;
    unint64_t v24 = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
    **(_DWORD **)(v24 + 8) = 22;
    return 0LL;
  }

_DWORD *_os_workgroup_client_attr_resolve(_DWORD *a1, _DWORD *a2, uint64_t a3)
{
  if (a2)
  {
    if (!_os_workgroup_client_attr_is_valid(a2)) {
      return 0LL;
    }
    memcpy(a1, a2, 0x40uLL);
    if (*a1 == 799564724)
    {
      if (!a1[1]) {
        a1[1] = *(_DWORD *)(a3 + 4);
      }
      if (!*((_WORD *)a1 + 4)) {
        *((_WORD *)a1 + 4) = *(_WORD *)(a3 + 8);
      }
    }

    else if (*a1 != 799564740)
    {
      return 0LL;
    }

    *a1 = 2015762650;
  }

  else
  {
    memcpy(a1, (const void *)a3, 0x40uLL);
  }

  if (!_os_workgroup_attr_is_resolved(a1))
  {
    uint64_t v4 = (void *)_os_assert_log(0LL);
    _os_crash(v4);
    __break(1u);
    JUMPOUT(0x371CLL);
  }

  return a1;
}

BOOL _os_workgroup_type_is_default_type(__int16 a1)
{
  return a1 == 0;
}

BOOL _os_workgroup_attr_is_propagating(uint64_t a1)
{
  return (*(_DWORD *)(a1 + 4) & 2) == 0;
}

BOOL _os_workgroup_attr_has_telemetry_enabled(uint64_t a1)
{
  return *(_WORD *)(a1 + 10) != 0;
}

uint64_t _os_workgroup_create_work_interval(uint64_t a1, uint64_t a2)
{
  uint64_t v6 = a1;
  uint64_t v5 = a2;
  unsigned int v4 = _wg_type_to_wi_flags(*(_WORD *)(a1 + 8)) | 1;
  if (_os_workgroup_attr_is_differentiated(v6)) {
    v4 |= 2u;
  }
  if (_os_workgroup_attr_has_workload_id(v6)) {
    v4 |= 0x80u;
  }
  if (_os_workgroup_attr_has_telemetry_enabled(v6)) {
    v4 |= 0x100u;
  }
  uint64_t v3 = 0LL;
  work_interval_destroy(v3);
  return 0LL;
}

void _os_workgroup_set_name(uint64_t a1, const char *a2)
{
  uint64_t v4 = (uint64_t)a2;
  if (a2)
  {
    uint64_t v3 = _dispatch_strdup_if_mutable(a2);
    if (v3 != (const char *)v4)
    {
      *(void *)(a1 + 24) |= 4uLL;
      uint64_t v4 = (uint64_t)v3;
    }
  }

  *(void *)(a1 + 16) = v4;
  uint64_t v2 = *(void *)(a1 + 24);
}

void *os_workgroup_interval_create(const char *a1, int a2, _DWORD *a3)
{
  uint64_t v17 = a1;
  int v16 = a2;
  uint64_t v15 = a3;
  v14 = 0LL;
  uint64_t work_interval = 0LL;
  memset(__b, 0, sizeof(__b));
  uint64_t v15 = _os_workgroup_client_attr_resolve(__b, v15, (uint64_t)&_os_workgroup_interval_attr_default);
  if (v15)
  {
    if (_os_workgroup_type_is_interval_type(*((_WORD *)v15 + 4)))
    {
      if (_os_workgroup_attr_is_differentiated((uint64_t)v15))
      {
        if (_os_workgroup_attr_is_propagating((uint64_t)v15))
        {
          uint64_t v22 = 1LL;
          uint64_t v23 = 1LL;
          unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
          **(_DWORD **)(StatusReg + 8) = 45;
          return 0LL;
        }

        else
        {
          int v11 = 0;
          uint64_t work_interval = _os_workgroup_create_work_interval((uint64_t)v15, (uint64_t)&v11);
          if (work_interval)
          {
            v14 = _os_object_alloc(_OS_os_workgroup_interval_vtable, 0x50uLL, v3, v4, v5, v6, v7, v8);
            v14[4] = work_interval;
            *((_DWORD *)v14 + 10) = v11;
            *((_DWORD *)v14 + 16) = v16;
            uint64_t v9 = work_interval_instance_alloc(work_interval);
            v14[9] = v9;
            *((_DWORD *)v14 + 17) = 0;
            *((_WORD *)v14 + 28) = *((_WORD *)v15 + 4);
            v14[3] = 1LL;
            *((_WORD *)v14 + 22) = *((_WORD *)v15 + 5);
            _os_workgroup_set_name((uint64_t)v14, v17);
            return v14;
          }

          else
          {
            return 0LL;
          }
        }
      }

      else
      {
        uint64_t v21 = 1LL;
        uint64_t v24 = 1LL;
        unint64_t v29 = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
        **(_DWORD **)(v29 + 8) = 22;
        return 0LL;
      }
    }

    else
    {
      uint64_t v20 = 1LL;
      uint64_t v25 = 1LL;
      unint64_t v28 = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
      **(_DWORD **)(v28 + 8) = 22;
      return 0LL;
    }
  }

  else
  {
    uint64_t v19 = 1LL;
    uint64_t v26 = 1LL;
    unint64_t v27 = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
    **(_DWORD **)(v27 + 8) = 22;
    return 0LL;
  }

BOOL _os_workgroup_attr_is_differentiated(uint64_t a1)
{
  return (*(_DWORD *)(a1 + 4) & 4) == 0;
}

unsigned int *os_workgroup_create_with_workload_id(const char *a1, const char *a2, _DWORD *a3)
{
  v45 = a1;
  v44 = a2;
  v43 = a3;
  v42 = 0LL;
  uint64_t work_interval = 0LL;
  v40 = &_os_workgroup_with_workload_id_attr_default;
  memset(__b, 0, sizeof(__b));
  v43 = _os_workgroup_client_attr_resolve(__b, v43, (uint64_t)&_os_workgroup_with_workload_id_attr_default);
  if (v43)
  {
    v43 = (_DWORD *)_os_workgroup_workload_id_attr_resolve(v44, (uint64_t)v43, (uint64_t)v40);
    if (v43)
    {
      if (v43[1] == v40[1])
      {
        if (_os_workgroup_type_is_default_type(*((_WORD *)v43 + 4)))
        {
          if (_os_workgroup_attr_is_propagating((uint64_t)v43))
          {
            _dispatch_log( "BUG IN CLIENT of %s: Unsupported attribute flags: 0x%x",  v24,  v25,  v26,  v27,  v28,  v29,  v30,  (uint64_t)"os_workgroup_create_with_workload_id");
            uint64_t v51 = 1LL;
            uint64_t v54 = 1LL;
            unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
            **(_DWORD **)(StatusReg + 8) = 45;
            return 0LL;
          }

          else if (_os_workgroup_attr_has_telemetry_enabled((uint64_t)v43))
          {
            uint64_t v52 = 1LL;
            uint64_t v53 = 1LL;
            unint64_t v64 = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
            **(_DWORD **)(v64 + 8) = 45;
            return 0LL;
          }

          else
          {
            unsigned int v38 = 0;
            uint64_t work_interval = _os_workgroup_create_work_interval((uint64_t)v43, (uint64_t)&v38);
            if (work_interval)
            {
              v42 = (unsigned int *)_os_object_alloc(_OS_os_workgroup_vtable, 0x40uLL, v31, v32, v33, v34, v35, v36);
              *((void *)v42 + 4) = work_interval;
              v42[10] = v38;
              *((void *)v42 + 3) = 1LL;
              *((_WORD *)v42 + 28) = *((_WORD *)v43 + 4);
              if (_os_workgroup_set_work_interval_workload_id((uint64_t)v42, (uint64_t)v44, v43[3]))
              {
                _os_object_release(v42);
                return 0LL;
              }

              else
              {
                _os_workgroup_set_name((uint64_t)v42, v45);
                return v42;
              }
            }

            else
            {
              return 0LL;
            }
          }
        }

        else
        {
          _dispatch_log( "BUG IN CLIENT of %s: Non-default workload type: %s (%hd)",  v17,  v18,  v19,  v20,  v21,  v22,  v23,  (uint64_t)"os_workgroup_create_with_workload_id");
          uint64_t v50 = 1LL;
          uint64_t v55 = 1LL;
          unint64_t v62 = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
          **(_DWORD **)(v62 + 8) = 22;
          return 0LL;
        }
      }

      else
      {
        _dispatch_log( "BUG IN CLIENT of %s: Non-default attribute flags: 0x%x",  v10,  v11,  v12,  v13,  v14,  v15,  v16,  (uint64_t)"os_workgroup_create_with_workload_id");
        uint64_t v49 = 1LL;
        uint64_t v56 = 1LL;
        unint64_t v61 = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
        **(_DWORD **)(v61 + 8) = 22;
        return 0LL;
      }
    }

    else
    {
      _dispatch_log( "BUG IN CLIENT of %s: Mismatched workload ID and attribute interval type: %s vs %hd",  v10,  v11,  v12,  v13,  v14,  v15,  v16,  (uint64_t)"os_workgroup_create_with_workload_id");
      uint64_t v48 = 1LL;
      uint64_t v57 = 1LL;
      unint64_t v60 = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
      **(_DWORD **)(v60 + 8) = 22;
      return 0LL;
    }
  }

  else
  {
    _dispatch_log( "BUG IN CLIENT of %s: Invalid attribute pointer",  v3,  v4,  v5,  v6,  v7,  v8,  v9,  (uint64_t)"os_workgroup_create_with_workload_id");
    uint64_t v47 = 1LL;
    uint64_t v58 = 1LL;
    unint64_t v59 = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
    **(_DWORD **)(v59 + 8) = 22;
    return 0LL;
  }

uint64_t _os_workgroup_workload_id_attr_resolve(const char *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v8 = a1;
  uint64_t v7 = a2;
  uint64_t v6 = a3;
  unsigned __int16 v5 = 0;
  __int16 v4 = _os_workgroup_lookup_type_from_workload_id(a1, (unsigned int *)(a2 + 12), (__int16 *)&v5);
  if (!_os_workgroup_type_is_default_type(v4))
  {
    if (*(unsigned __int16 *)(v7 + 8) == *(unsigned __int16 *)(v6 + 8))
    {
      *(_WORD *)(v7 + 8) = v4;
    }

    else if (*(unsigned __int16 *)(v7 + 8) == v5)
    {
      *(_WORD *)(v7 + 8) = v4;
    }

    else if (v4 != *(_WORD *)(v7 + 8))
    {
      return 0LL;
    }

    return v7;
  }

  return v7;
}

uint64_t _os_workgroup_set_work_interval_workload_id(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v20 = a1;
  uint64_t v19 = a2;
  int v18 = a3;
  unsigned int v17 = 0;
  if (!*(_DWORD *)(a1 + 40) || *(_DWORD *)(v20 + 40) == -1)
  {
    uint64_t v16 = 0LL;
    uint64_t v3 = *(unsigned int *)(v20 + 40);
    qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: Invalid workgroup port";
    qword_E4DA8 = v3;
    __break(1u);
    JUMPOUT(0x41CCLL);
  }

  if (v18)
  {
    v18 &= ~1u;
    __strlcpy_chk(v27, v19, 64LL, 64LL);
    int v15 = 0;
    int v15 = _wg_type_to_wi_flags(*(_WORD *)(v20 + 56));
    v12[0] = v18;
    v12[1] = v15;
    uint64_t v13 = v27;
    __int128 v14 = 0uLL;
    unsigned int v17 = __work_interval_ctl(11LL, *(unsigned int *)(v20 + 40), v12, 32LL);
    if (v17 == -1)
    {
      uint64_t v22 = 1LL;
      uint64_t v23 = 1LL;
      unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
      unsigned int v17 = **(_DWORD **)(StatusReg + 8);
      uint64_t v26 = (int)v17;
      uint64_t v25 = 576LL;
      if (v17) {
        _dispatch_bug(v25, v26, v4, v5, v6, v7, v8, v9);
      }
    }

    if (v17 || (v12[0] & 1) != 0)
    {
      if (v17) {
        unsigned int v11 = 0;
      }
      else {
        unsigned int v11 = v12[0];
      }
      _dispatch_log( "BUG IN CLIENT of %s: Unable to set kernel workload ID: %s (0x%x) -> %d (0x%x)",  v17,  v11,  v5,  v6,  v7,  v8,  v9,  (uint64_t)"_os_workgroup_set_work_interval_workload_id");
      if (!v17) {
        return 37;
      }
    }

    else
    {
      *(void *)(v20 + 24) |= 0x10uLL;
    }

    return v17;
  }

  else
  {
    return v17;
  }

unsigned int *os_workgroup_interval_create_with_workload_id( const char *a1, const char *a2, unsigned int a3, _DWORD *a4)
{
  uint64_t v55 = a1;
  uint64_t v54 = a2;
  unsigned int v53 = a3;
  uint64_t v52 = a4;
  uint64_t v51 = 0LL;
  uint64_t work_interval = 0LL;
  uint64_t v49 = &_os_workgroup_interval_attr_default;
  memset(__b, 0, sizeof(__b));
  uint64_t v52 = _os_workgroup_client_attr_resolve(__b, v52, (uint64_t)&_os_workgroup_interval_attr_default);
  if (v52)
  {
    uint64_t v52 = (_DWORD *)_os_workgroup_workload_id_attr_resolve(v54, (uint64_t)v52, (uint64_t)v49);
    if (v52)
    {
      if (v52[1] == v49[1])
      {
        if (_os_workgroup_type_is_interval_type(*((_WORD *)v52 + 4)))
        {
          if (_os_workgroup_attr_is_differentiated((uint64_t)v52))
          {
            if (_os_workgroup_attr_is_propagating((uint64_t)v52))
            {
              _dispatch_log( "BUG IN CLIENT of %s: Unsupported attribute flags: 0x%x",  v32,  v33,  v34,  v35,  v36,  v37,  v38,  (uint64_t)"os_workgroup_interval_create_with_workload_id");
              uint64_t v62 = 1LL;
              uint64_t v63 = 1LL;
              unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
              **(_DWORD **)(StatusReg + 8) = 45;
              return 0LL;
            }

            else
            {
              unsigned int v47 = 0;
              uint64_t work_interval = _os_workgroup_create_work_interval((uint64_t)v52, (uint64_t)&v47);
              if (work_interval)
              {
                uint64_t v51 = (unsigned int *)_os_object_alloc( _OS_os_workgroup_interval_vtable,  0x50uLL,  v39,  v40,  v41,  v42,  v43,  v44);
                *((void *)v51 + 4) = work_interval;
                v51[10] = v47;
                v51[16] = v53;
                uint64_t v45 = work_interval_instance_alloc(work_interval);
                *((void *)v51 + 9) = v45;
                v51[17] = 0;
                *((_WORD *)v51 + 28) = *((_WORD *)v52 + 4);
                *((void *)v51 + 3) = 1LL;
                *((_WORD *)v51 + 22) = *((_WORD *)v52 + 5);
                if (_os_workgroup_set_work_interval_workload_id((uint64_t)v51, (uint64_t)v54, v52[3]))
                {
                  _os_object_release(v51);
                  return 0LL;
                }

                else
                {
                  _os_workgroup_set_name((uint64_t)v51, v55);
                  return v51;
                }
              }

              else
              {
                return 0LL;
              }
            }
          }

          else
          {
            _dispatch_log( "BUG IN CLIENT of %s: Invalid attribute flags: 0x%x",  v25,  v26,  v27,  v28,  v29,  v30,  v31,  (uint64_t)"os_workgroup_interval_create_with_workload_id");
            uint64_t v61 = 1LL;
            uint64_t v64 = 1LL;
            unint64_t v73 = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
            **(_DWORD **)(v73 + 8) = 22;
            return 0LL;
          }
        }

        else
        {
          _dispatch_log( "BUG IN CLIENT of %s: Invalid workload interval type: %s (%hd)",  v18,  v19,  v20,  v21,  v22,  v23,  v24,  (uint64_t)"os_workgroup_interval_create_with_workload_id");
          uint64_t v60 = 1LL;
          uint64_t v65 = 1LL;
          unint64_t v72 = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
          **(_DWORD **)(v72 + 8) = 22;
          return 0LL;
        }
      }

      else
      {
        _dispatch_log( "BUG IN CLIENT of %s: Non-default attribute flags: 0x%x",  v11,  v12,  v13,  v14,  v15,  v16,  v17,  (uint64_t)"os_workgroup_interval_create_with_workload_id");
        uint64_t v59 = 1LL;
        uint64_t v66 = 1LL;
        unint64_t v71 = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
        **(_DWORD **)(v71 + 8) = 22;
        return 0LL;
      }
    }

    else
    {
      _dispatch_log( "BUG IN CLIENT of %s: Mismatched workload ID and attribute interval type: %s vs %hd",  v11,  v12,  v13,  v14,  v15,  v16,  v17,  (uint64_t)"os_workgroup_interval_create_with_workload_id");
      uint64_t v58 = 1LL;
      uint64_t v67 = 1LL;
      unint64_t v70 = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
      **(_DWORD **)(v70 + 8) = 22;
      return 0LL;
    }
  }

  else
  {
    _dispatch_log( "BUG IN CLIENT of %s: Invalid attribute pointer",  v4,  v5,  v6,  v7,  v8,  v9,  v10,  (uint64_t)"os_workgroup_interval_create_with_workload_id");
    uint64_t v57 = 1LL;
    uint64_t v68 = 1LL;
    unint64_t v69 = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
    **(_DWORD **)(v69 + 8) = 22;
    return 0LL;
  }

uint64_t os_workgroup_join_self(os_workgroup_s *a1, os_workgroup_join_token_opaque_s *a2)
{
  return os_workgroup_join(a1, a2);
}

int os_workgroup_join(os_workgroup_t wg, os_workgroup_join_token_t token_out)
{
  if (_os_workgroup_get_current())
  {
    **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8) = 37;
    return **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
  }

  else
  {
    uint64_t v4 = *((void *)wg + 3);
    if ((v4 & 2) != 0)
    {
      **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8) = 22;
      return **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
    }

    else
    {
      int v3 = 0;
      if (_os_workgroup_has_backing_workinterval((uint64_t)wg))
      {
        if (_os_workgroup_is_configurable(v4)) {
          int v3 = work_interval_join(*((void *)wg + 4));
        }
        else {
          int v3 = work_interval_join_port(*((unsigned int *)wg + 10));
        }
      }

      if (v3)
      {
        return **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
      }

      else
      {
        _os_workgroup_join_update_wg((uint64_t)wg, (uint64_t)token_out);
        return 0;
      }
    }
  }

void os_workgroup_leave_self(os_workgroup_s *a1, os_workgroup_join_token_opaque_s *a2)
{
}

void os_workgroup_leave(os_workgroup_t wg, os_workgroup_join_token_t token)
{
  if (!_os_workgroup_join_token_initialized(token))
  {
    _os_crash("Join token is corrupt");
    __break(1u);
  }

  int v8 = *(_DWORD *)token->opaque;
  if (v8 != _dispatch_thread_getspecific(3uLL))
  {
    _os_crash("Join token provided is for a different thread");
    __break(1u);
  }

  current = (os_workgroup_s *)_os_workgroup_get_current();
  if (*(os_workgroup_s **)&token->opaque[12] != current || current != wg)
  {
    _os_crash("Join token provided is for a different workgroup than the last one joined by thread");
    __break(1u);
  }

  if (*(void *)&token->opaque[4])
  {
    uint64_t v9 = _os_assert_log(*(void *)&token->opaque[4] == 0LL);
    _os_crash(v9);
    __break(1u);
  }

  _os_workgroup_leave_update_wg(wg);
}

os_workgroup_parallel_t os_workgroup_parallel_create(const char *name, os_workgroup_attr_t attr)
{
  uint64_t v13 = name;
  __src = attr;
  uint64_t v11 = 0LL;
  memset(__b, 0, sizeof(__b));
  if (__src)
  {
    if (!_os_workgroup_client_attr_is_valid(__src))
    {
      uint64_t v15 = 1LL;
      uint64_t v24 = 1LL;
      unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
      **(_DWORD **)(StatusReg + 8) = 22;
      return 0LL;
    }

    memcpy(__b, __src, sizeof(__b));
    __src = __b;
    if (__b[0] == 799564724)
    {
      if (!*((_DWORD *)__src + 1)) {
        *((_DWORD *)__src + 1) = 6;
      }
      if (!*((_WORD *)__src + 4)) {
        *((_WORD *)__src + 4) = 64;
      }
    }

    else if (__b[0] != 799564740)
    {
      uint64_t v16 = 1LL;
      uint64_t v23 = 1LL;
      unint64_t v26 = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
      **(_DWORD **)(v26 + 8) = 22;
      return 0LL;
    }

    *(_DWORD *)__src = 2015762650;
  }

  else
  {
    memcpy(__b, &_os_workgroup_parallel_attr_default, sizeof(__b));
    __src = __b;
  }

  if (!_os_workgroup_attr_is_resolved(__src))
  {
    uint64_t v9 = (void *)_os_assert_log(0LL);
    _os_crash(v9);
    __break(1u);
    JUMPOUT(0x4ED8LL);
  }

  if (_os_workgroup_type_is_parallel_type(*((_WORD *)__src + 4)))
  {
    if (_os_workgroup_attr_is_propagating((uint64_t)__src))
    {
      uint64_t v18 = 1LL;
      uint64_t v21 = 1LL;
      unint64_t v28 = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
      **(_DWORD **)(v28 + 8) = 45;
      return 0LL;
    }

    else if (_os_workgroup_attr_has_telemetry_enabled((uint64_t)__src))
    {
      uint64_t v19 = 1LL;
      uint64_t v20 = 1LL;
      unint64_t v29 = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
      **(_DWORD **)(v29 + 8) = 45;
      return 0LL;
    }

    else
    {
      uint64_t v11 = _os_object_alloc(_OS_os_workgroup_parallel_vtable, 0x40uLL, v2, v3, v4, v5, v6, v7);
      v11[4] = 0LL;
      v11[3] = 1LL;
      *((_WORD *)v11 + 28) = *((_WORD *)__src + 4);
      _os_workgroup_set_name((uint64_t)v11, v13);
      return (os_workgroup_parallel_t)v11;
    }
  }

  else
  {
    uint64_t v17 = 1LL;
    uint64_t v22 = 1LL;
    unint64_t v27 = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
    **(_DWORD **)(v27 + 8) = 22;
    return 0LL;
  }

BOOL _os_workgroup_attr_is_resolved(_DWORD *a1)
{
  return *a1 == 2015762650;
}

BOOL _os_workgroup_type_is_parallel_type(__int16 a1)
{
  return a1 == 64;
}

int os_workgroup_copy_port(os_workgroup_t wg, mach_port_t *mach_port_out)
{
  if (!wg)
  {
    uint64_t v10 = _os_assert_log(0LL);
    _os_crash(v10);
    __break(1u);
  }

  if (!mach_port_out)
  {
    uint64_t v9 = _os_assert_log(0LL);
    _os_crash(v9);
    __break(1u);
  }

  *mach_port_out = 0;
  if ((*((void *)wg + 3) & 2) != 0) {
    return 22;
  }
  if (mach_port_mod_refs(mach_task_self_, *((_DWORD *)wg + 10), 0, 1))
  {
    _dispatch_bug(1419LL, 0LL, v2, v3, v4, v5, v6, v7);
    return 12;
  }

  else
  {
    *mach_port_out = *((_DWORD *)wg + 10);
    return 0;
  }

os_workgroup_t os_workgroup_create_with_port(const char *name, mach_port_t mach_port)
{
  uint64_t v13 = name;
  mach_port_name_t namea = mach_port;
  if (mach_port && namea != -1)
  {
    __int16 v11 = 0;
    if (_os_workgroup_get_wg_wi_types_from_port(namea, &v11, 0LL))
    {
      return 0LL;
    }

    else
    {
      BOOL v10 = mach_port_mod_refs(mach_task_self_, namea, 0, 1) == 0;
      BOOL v16 = v10;
      uint64_t v15 = 1443LL;
      if (v10)
      {
        uint64_t v9 = _os_object_alloc(_OS_os_workgroup_vtable, 0x40uLL, v2, v3, v4, v5, v6, v7);
        *((_DWORD *)v9 + 10) = namea;
        *((_WORD *)v9 + 28) = v11;
        _os_workgroup_set_name((uint64_t)v9, v13);
        return (os_workgroup_t)v9;
      }

      else
      {
        _dispatch_bug(v15, v16, v2, v3, v4, v5, v6, v7);
        return 0LL;
      }
    }
  }

  else
  {
    uint64_t v17 = 1LL;
    **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8) = 22;
    return 0LL;
  }

uint64_t _os_workgroup_get_wg_wi_types_from_port(unsigned int a1, _WORD *a2, _DWORD *a3)
{
  unsigned int v10 = a1;
  uint64_t v9 = a2;
  int v8 = a3;
  __int16 v7 = 0;
  int v6 = 0;
  int v5 = 0;
  unsigned int flags_from_port = work_interval_get_flags_from_port(a1, &v5);
  if (flags_from_port)
  {
    return flags_from_port;
  }

  else
  {
    __int16 v7 = _wi_flags_to_wg_type(v5);
    int v6 = _wi_flags_to_wi_type(v5);
    if (v9) {
      _WORD *v9 = v7;
    }
    if (v8) {
      *int v8 = v6;
    }
    return 0;
  }

void *os_workgroup_create_with_workload_id_and_port( const char *a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v44 = a1;
  uint64_t v43 = a2;
  mach_port_name_t name = a3;
  if ((_DWORD)a3 && name != -1)
  {
    __int16 v41 = 0;
    int v40 = 0;
    int wg_wi_types_from_port = _os_workgroup_get_wg_wi_types_from_port(name, &v41, &v40);
    if (wg_wi_types_from_port)
    {
      _dispatch_log( "BUG IN CLIENT of %s: Invalid mach port 0x%x",  v8,  v9,  v10,  v11,  v12,  v13,  v14,  (uint64_t)"os_workgroup_create_with_workload_id_and_port");
      return 0LL;
    }

    else
    {
      int v38 = 0;
      if (_os_workgroup_workload_id_is_valid_for_wi_type(v43, v40, (unsigned int *)&v38))
      {
        BOOL v37 = mach_port_mod_refs(mach_task_self_, name, 0, 1) == 0;
        BOOL v47 = v37;
        uint64_t v46 = 1488LL;
        if (v37)
        {
          uint64_t v36 = _os_object_alloc(_OS_os_workgroup_vtable, 0x40uLL, v22, v23, v24, v25, v26, v27);
          *((_DWORD *)v36 + 10) = name;
          *((_WORD *)v36 + 28) = v41;
          int wg_wi_types_from_port = _os_workgroup_set_work_interval_workload_id((uint64_t)v36, (uint64_t)v43, v38);
          if (!wg_wi_types_from_port || wg_wi_types_from_port == 37)
          {
            _os_workgroup_set_name((uint64_t)v36, v44);
            return v36;
          }

          else
          {
            _os_object_release((unsigned int *)v36);
            return 0LL;
          }
        }

        else
        {
          _dispatch_bug(v46, v47, v22, v23, v24, v25, v26, v27);
          _dispatch_log( "BUG IN CLIENT of %s: Invalid mach port 0x%x",  v28,  v29,  v30,  v31,  v32,  v33,  v34,  (uint64_t)"os_workgroup_create_with_workload_id_and_port");
          return 0LL;
        }
      }

      else
      {
        _dispatch_log( "BUG IN CLIENT of %s: Mismatched workload ID and port interval type: %s vs %hd",  v15,  v16,  v17,  v18,  v19,  v20,  v21,  (uint64_t)"os_workgroup_create_with_workload_id_and_port");
        uint64_t v49 = 1LL;
        uint64_t v50 = 1LL;
        unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
        **(_DWORD **)(StatusReg + 8) = 22;
        return 0LL;
      }
    }
  }

  else
  {
    _dispatch_log( "BUG IN CLIENT of %s: Invalid mach port 0x%x",  (uint64_t)a2,  a3,  a4,  a5,  a6,  a7,  a8,  (uint64_t)"os_workgroup_create_with_workload_id_and_port");
    uint64_t v48 = 1LL;
    **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8) = 22;
    return 0LL;
  }

BOOL _os_workgroup_workload_id_is_valid_for_wi_type(const char *a1, int a2, unsigned int *a3)
{
  uint64_t v8 = a1;
  int v7 = a2;
  int v6 = a3;
  unsigned __int16 v5 = 0;
  __int16 v4 = _os_workgroup_lookup_type_from_workload_id(a1, a3, (__int16 *)&v5);
  return _os_workgroup_type_is_default_type(v4)
      || _wg_type_to_wi_type(v5) == v7
      || _wg_type_to_wi_type(v4) == v7;
}

os_workgroup_t os_workgroup_create_with_workgroup(const char *name, os_workgroup_t wg)
{
  if ((*((void *)wg + 3) & 2) == 0)
  {
    uint64_t v9 = _os_object_alloc(_OS_os_workgroup_vtable, 0x40uLL, v2, v3, v4, v5, v6, v7);
    *((_WORD *)v9 + 28) = *((_WORD *)wg + 28);
    if (_os_workgroup_has_backing_workinterval((uint64_t)wg))
    {
      if (mach_port_mod_refs(mach_task_self_, *((_DWORD *)wg + 10), 0, 1))
      {
        free(v9);
        return 0LL;
      }

      *((_DWORD *)v9 + 10) = *((_DWORD *)wg + 10);
    }

    _os_workgroup_set_name((uint64_t)v9, name);
    return (os_workgroup_t)v9;
  }

  **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8) = 22;
  return 0LL;
}

void *os_workgroup_create_with_workload_id_and_workgroup( const char *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v34 = a1;
  uint64_t v33 = (const char *)a2;
  uint64_t v32 = a3;
  uint64_t v31 = 0LL;
  uint64_t v30 = 0LL;
  uint64_t v29 = *(void *)(a3 + 24);
  uint64_t v30 = v29;
  uint64_t v28 = v29;
  uint64_t v31 = v29;
  if ((v29 & 2) != 0)
  {
    _dispatch_log( "BUG IN CLIENT of %s: Workgroup already cancelled",  a2,  a3,  a4,  a5,  a6,  a7,  a8,  (uint64_t)"os_workgroup_create_with_workload_id_and_workgroup");
    uint64_t v36 = 1LL;
    uint64_t v39 = 1LL;
    **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8) = 22;
    return 0LL;
  }

  else
  {
    int v27 = 0;
    uint64_t v24 = v33;
    int v8 = _wg_type_to_wi_type(*(_WORD *)(v32 + 56));
    if (_os_workgroup_workload_id_is_valid_for_wi_type(v24, v8, (unsigned int *)&v27))
    {
      uint64_t v26 = _os_object_alloc(_OS_os_workgroup_vtable, 0x40uLL, v10, v11, v12, v13, v14, v15);
      *((_WORD *)v26 + 28) = *(_WORD *)(v32 + 56);
      if (_os_workgroup_has_backing_workinterval(v32))
      {
        if (mach_port_mod_refs(mach_task_self_, *(_DWORD *)(v32 + 40), 0, 1))
        {
          _dispatch_log( "BUG IN CLIENT of %s: Invalid workgroup port 0x%x",  v16,  v17,  v18,  v19,  v20,  v21,  v22,  (uint64_t)"os_workgroup_create_with_workload_id_and_workgroup");
          free(v26);
          return 0LL;
        }

        *((_DWORD *)v26 + 10) = *(_DWORD *)(v32 + 40);
        int v25 = _os_workgroup_set_work_interval_workload_id((uint64_t)v26, (uint64_t)v33, v27);
        if (v25 && v25 != 37)
        {
          _os_object_release((unsigned int *)v26);
          return 0LL;
        }
      }

      _os_workgroup_set_name((uint64_t)v26, v34);
      return v26;
    }

    _dispatch_log( "BUG IN CLIENT of %s: Mismatched workload ID and workgroup interval type: %s vs %hd",  v9,  v10,  v11,  v12,  v13,  v14,  v15,  (uint64_t)"os_workgroup_create_with_workload_id_and_workgroup");
    uint64_t v37 = 1LL;
    uint64_t v38 = 1LL;
    unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
    **(_DWORD **)(StatusReg + 8) = 22;
    return 0LL;
  }

uint64_t _wg_type_to_wi_type(unsigned __int16 a1)
{
  int v1 = _wg_type_to_wi_flags(a1);
  return _wi_flags_to_wi_type(v1);
}

int os_workgroup_max_parallel_threads(os_workgroup_t wg, os_workgroup_mpt_attr_t attr)
{
  if (!wg)
  {
    uint64_t v4 = _os_assert_log(0LL);
    _os_crash(v4);
    __break(1u);
  }

  if (*((_WORD *)wg + 28) != 4 && *((_WORD *)wg + 28) != 3) {
    return pthread_qos_max_parallelism(33LL, 0LL);
  }
  else {
    return pthread_time_constraint_max_parallelism(0LL);
  }
}

void _os_workgroup_join_update_wg(uint64_t a1, uint64_t a2)
{
  if (_os_workgroup_get_current()) {
    __assert_rtn("_os_workgroup_join_update_wg", "workgroup.c", 1653, "cur_wg == NULL");
  }
  uint64_t v4 = (unsigned int *)(a1 + 60);
  unsigned int v5 = *(_DWORD *)(a1 + 60);
  do
  {
    unsigned int v2 = v5;
    do
      unsigned int v3 = __ldaxr(v4);
    while (v3 == v5 && __stlxr(v5 + 1, v4));
    unsigned int v5 = v3;
  }

  while (v3 != v2);
  __memset_chk(a2, 0LL, 40LL, -1LL);
  *(_DWORD *)a2 = 1298094680;
  *(_DWORD *)(a2 + 4) = _dispatch_thread_getspecific(3uLL);
  *(void *)(a2 + 8) = 0LL;
  *(void *)(a2 + 16) = a1;
  _os_workgroup_set_current(a1);
}

void _os_workgroup_set_current(uint64_t a1)
{
  if (a1) {
    _os_object_retain_internal(a1);
  }
  current = (unsigned int *)_os_workgroup_get_current();
  _dispatch_thread_setspecific(116LL, a1);
  if (current) {
    _os_object_release_internal(current);
  }
}

BOOL _os_workgroup_join_token_initialized(_DWORD *a1)
{
  return *a1 == 1298094680;
}

uint64_t os_workgroup_set_working_arena(uint64_t a1, uint64_t a2, unsigned int a3, uint64_t a4)
{
  unint64_t v16 = 4LL * a3;
  if (!is_mul_ok(4uLL, a3)
    || v16 >= 0xFFFFFFFFFFFFFFE8LL
    || (uint64_t v15 = (_DWORD *)malloc_type_calloc(v16 + 24, 1LL, 187101423LL)) == 0LL)
  {
    **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8) = 12;
    return **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
  }

  else
  {
    v15[4] = a3;
    *(void *)uint64_t v15 = a2;
    *((void *)v15 + 1) = a4;
    uint64_t v13 = 0LL;
    BOOL v12 = 0;
    uint64_t v11 = (unsigned __int128 *)(a1 + 48);
    while (1)
    {
      if (_os_atomic_mo_has_acquire(0))
      {
        unsigned __int128 v6 = __ldaxp(v11);
        uint64_t v4 = *((void *)&v6 + 1);
        uint64_t v5 = v6;
      }

      else
      {
        unsigned __int128 v8 = __ldxp(v11);
        uint64_t v4 = *((void *)&v8 + 1);
        uint64_t v5 = v8;
      }

      *(void *)&__int128 v7 = v5;
      *((void *)&v7 + 1) = v4;
      __int128 v14 = v7;
      _wg_arena(v14, *((unint64_t *)&v14 + 1));
      uint64_t v13 = v9;
      if (_os_atomic_mo_has_release(0)) {
        BOOL v12 = __stlxp((unint64_t)v15, v11) == 0;
      }
      else {
        BOOL v12 = __stxp((unint64_t)v15, v11) == 0;
      }
      if (v12) {
        goto LABEL_14;
      }
    }

    __clrex();
LABEL_14:
    if (v12)
    {
      if (v13)
      {
        v13[1](*v13);
        free(v13);
      }

      return 0;
    }

    else
    {
      free(v15);
      **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8) = 16;
      return **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
    }
  }

BOOL _os_atomic_mo_has_acquire(int a1)
{
  BOOL v1 = a1 == 2 || a1 == 1;
  BOOL v4 = 1;
  if (!v1 && a1 != 5 && a1 != 4) {
    return 0;
  }
  return v4;
}

unint64_t _wg_joined_cnt(uint64_t a1, uint64_t a2)
{
  return (a2 & 0xFFFFFFFF00000000LL) >> 32;
}

__n128 _wg_arena(unint64_t a1, unint64_t a2)
{
  result.n128_u64[0] = a1;
  result.n128_u64[1] = a2;
  return result;
}

BOOL _os_atomic_mo_has_release(int a1)
{
  return (a1 - 3) <= 2;
}

uint64_t os_workgroup_get_working_arena(uint64_t a1, unsigned int *a2)
{
  if (_os_workgroup_get_current() != (void *)a1)
  {
    _os_crash("Thread is not a member of the workgroup");
    __break(1u);
    JUMPOUT(0x65A8LL);
  }

  if (!*(_DWORD *)(a1 + 60)) {
    _dispatch_abort(1765LL, *(_DWORD *)(a1 + 60) != 0, v2, v3, v4, v5, v6, v7);
  }
  uint64_t v17 = *(unsigned int **)(a1 + 48);
  if (!v17) {
    return 0LL;
  }
  if (a2 && !v17[4])
  {
    _os_crash("The arena associated with workgroup is not to be partitioned");
    __break(1u);
    JUMPOUT(0x6678LL);
  }

  if (a2)
  {
    unsigned int v16 = 0;
    char v15 = 0;
    for (unsigned int i = 0; i < v17[4]; ++i)
    {
      unsigned int v13 = v17[i + 6];
      if (v13 == _dispatch_thread_getspecific(3uLL))
      {
        unsigned int v16 = i;
        char v15 = 1;
        break;
      }
    }

    if ((v15 & 1) == 0)
    {
      uint64_t v11 = v17 + 5;
      unsigned int v12 = v17[5];
      do
      {
        unsigned int v8 = v12;
        do
          unsigned int v9 = __ldaxr(v11);
        while (v9 == v12 && __stlxr(v12 + 1, v11));
        unsigned int v12 = v9;
      }

      while (v9 != v8);
      unsigned int v16 = v9;
      if (v9 >= v17[4])
      {
        _os_crash("Exceeded the maximum number of workers who can access the arena");
        __break(1u);
        JUMPOUT(0x67F8LL);
      }

      v17[v9 + 6] = _dispatch_thread_getspecific(3uLL);
    }

    *a2 = v16;
  }

  return *(void *)v17;
}

void os_workgroup_cancel(os_workgroup_t wg)
{
  uint64_t v3 = (unint64_t *)((char *)wg + 24);
  unint64_t v4 = *((void *)wg + 3);
  do
  {
    unint64_t v1 = v4;
    do
      unint64_t v2 = __ldaxr(v3);
    while (v2 == v4 && __stlxr(v4 | 2, v3));
    unint64_t v4 = v2;
  }

  while (v2 != v1);
}

BOOL os_workgroup_testcancel(os_workgroup_t wg)
{
  return (*((void *)wg + 3) & 2) != 0;
}

int os_workgroup_interval_start( os_workgroup_interval_t wg, uint64_t start, uint64_t deadline, os_workgroup_interval_data_t data)
{
  if (_os_workgroup_get_current() != wg)
  {
    _os_crash("Thread is not a member of the workgroup");
    __break(1u);
    JUMPOUT(0x69BCLL);
  }

  if (!_os_workgroup_interval_invalid_telemetry_request((uint64_t)wg, (uint64_t)data)
    && deadline >= start
    && _start_time_is_in_past(*((_DWORD *)wg + 16), start))
  {
    if (os_unfair_lock_trylock((os_unfair_lock_t)wg + 17))
    {
      BOOL v17 = _os_workgroup_interval_data_complexity(data);
      int v15 = 0;
      uint64_t v11 = (unint64_t *)((char *)wg + 24);
      while (1)
      {
        if (_os_atomic_mo_has_acquire(0)) {
          unint64_t v4 = __ldaxr(v11);
        }
        else {
          unint64_t v4 = __ldxr(v11);
        }
        unint64_t v14 = v4;
        if ((v4 & 0xA) != 0)
        {
          int v15 = 22;
          __clrex();
          goto LABEL_25;
        }

        if (!_os_workgroup_is_configurable(v4))
        {
          int v15 = 1;
          __clrex();
          goto LABEL_25;
        }

        if (v17 && !_os_workgroup_has_workload_id(v14)) {
          break;
        }
        unint64_t v13 = v14 | 8;
        if (_os_atomic_mo_has_release(0)) {
          BOOL v12 = __stlxr(v13, v11) == 0;
        }
        else {
          BOOL v12 = __stxr(v13, v11) == 0;
        }
        if (v12) {
          goto LABEL_25;
        }
      }

      **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8) = 22;
      __clrex();
LABEL_25:
      if (v15)
      {
        os_unfair_lock_unlock((os_unfair_lock_t)wg + 17);
        **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8) = v15;
        return v15;
      }

      else
      {
        uint64_t v10 = *((void *)wg + 9);
        work_interval_instance_clear(v10);
        work_interval_instance_set_start(v10, start);
        work_interval_instance_set_deadline(v10, deadline);
        work_interval_instance_set_complexity(v10, v17);
        int v16 = work_interval_instance_start(v10);
        if (v16)
        {
          unsigned int v8 = (unint64_t *)((char *)wg + 24);
          unint64_t v9 = *((void *)wg + 3);
          do
          {
            unint64_t v5 = v9;
            do
              unint64_t v6 = __ldaxr(v8);
            while (v6 == v9 && __stlxr(v9 & 0xFFFFFFFFFFFFFFF7LL, v8));
            unint64_t v9 = v6;
          }

          while (v6 != v5);
        }

        else if (_os_workgroup_interval_data_telemetry_requested((uint64_t)data))
        {
          _os_workgroup_interval_copy_telemetry_data((uint64_t)wg, (uint64_t)data);
        }

        os_unfair_lock_unlock((os_unfair_lock_t)wg + 17);
        return v16;
      }
    }

    else
    {
      **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8) = 16;
      return **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
    }
  }

  else
  {
    **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8) = 22;
    return **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
  }

BOOL _os_workgroup_interval_invalid_telemetry_request(uint64_t a1, uint64_t a2)
{
  BOOL v3 = 0;
  return v3;
}

BOOL _start_time_is_in_past(int a1, uint64_t a2)
{
  if (a1 == 32) {
    return a2 <= mach_absolute_time();
  }
  return v3;
}

BOOL _os_workgroup_interval_data_complexity(_DWORD *a1)
{
  uint64_t v2 = 0LL;
  return v2;
}

BOOL _os_workgroup_has_workload_id(char a1)
{
  return (a1 & 0x10) != 0;
}

BOOL _os_workgroup_interval_data_telemetry_requested(uint64_t a1)
{
  BOOL v2 = 0;
  if (a1) {
    return _os_workgroup_telemetry_flavor_is_valid(*(_WORD *)(a1 + 16));
  }
  return v2;
}

uint64_t _os_workgroup_interval_copy_telemetry_data(uint64_t a1, uint64_t a2)
{
  uint64_t v6 = a1;
  uint64_t v5 = a2;
  memset(__b, 0, sizeof(__b));
  uint64_t result = work_interval_instance_get_telemetry_data(*(void *)(v6 + 72), __b, 40LL);
  if (*(_WORD *)(v5 + 16) == 1)
  {
    BOOL v3 = *(void **)(v5 + 8);
    *BOOL v3 = __b[0];
    v3[3] = __b[3];
    v3[4] = __b[4];
    v3[1] = __b[1];
    v3[2] = __b[2];
  }

  return result;
}

int os_workgroup_interval_update( os_workgroup_interval_t wg, uint64_t deadline, os_workgroup_interval_data_t data)
{
  if (_os_workgroup_get_current() != wg)
  {
    _os_crash("Thread is not a member of the workgroup");
    __break(1u);
    JUMPOUT(0x7174LL);
  }

  if (_os_workgroup_interval_invalid_telemetry_request((uint64_t)wg, (uint64_t)data))
  {
    **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8) = 22;
    return **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
  }

  else if (os_unfair_lock_trylock((os_unfair_lock_t)wg + 17))
  {
    BOOL v7 = _os_workgroup_interval_data_complexity(data);
    uint64_t v6 = *((void *)wg + 3);
    if (_os_workgroup_is_configurable(v6))
    {
      if ((!v7 || _os_workgroup_has_workload_id(v6)) && (v6 & 8) != 0)
      {
        uint64_t v5 = *((void *)wg + 9);
        work_interval_instance_set_deadline(v5, deadline);
        work_interval_instance_set_complexity(v5, v7);
        int v4 = work_interval_instance_update(v5);
        if (v4)
        {
          int v4 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
        }

        else if (_os_workgroup_interval_data_telemetry_requested((uint64_t)data))
        {
          _os_workgroup_interval_copy_telemetry_data((uint64_t)wg, (uint64_t)data);
        }

        os_unfair_lock_unlock((os_unfair_lock_t)wg + 17);
        return v4;
      }

      else
      {
        os_unfair_lock_unlock((os_unfair_lock_t)wg + 17);
        **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8) = 22;
        return **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
      }
    }

    else
    {
      os_unfair_lock_unlock((os_unfair_lock_t)wg + 17);
      **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8) = 1;
      return **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
    }
  }

  else
  {
    **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8) = 16;
    return **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
  }

int os_workgroup_interval_finish(os_workgroup_interval_t wg, os_workgroup_interval_data_t data)
{
  if (_os_workgroup_get_current() != wg)
  {
    _os_crash("Thread is not a member of the workgroup");
    __break(1u);
    JUMPOUT(0x7574LL);
  }

  if (_os_workgroup_interval_invalid_telemetry_request((uint64_t)wg, (uint64_t)data))
  {
    **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8) = 22;
    return **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
  }

  else if (os_unfair_lock_trylock((os_unfair_lock_t)wg + 17))
  {
    BOOL v11 = _os_workgroup_interval_data_complexity(data);
    uint64_t v10 = *((void *)wg + 3);
    if (_os_workgroup_is_configurable(v10))
    {
      if ((!v11 || _os_workgroup_has_workload_id(v10)) && (v10 & 8) != 0)
      {
        uint64_t v9 = *((void *)wg + 9);
        uint64_t v8 = 0LL;
        if (*((_DWORD *)wg + 16) == 32) {
          uint64_t v8 = mach_absolute_time();
        }
        work_interval_instance_set_finish(v9, v8);
        work_interval_instance_set_complexity(v9, v11);
        int v7 = work_interval_instance_finish(v9);
        if (v7)
        {
          int v7 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
        }

        else
        {
          uint64_t v5 = (unint64_t *)((char *)wg + 24);
          unint64_t v6 = *((void *)wg + 3);
          do
          {
            unint64_t v2 = v6;
            do
              unint64_t v3 = __ldaxr(v5);
            while (v3 == v6 && __stlxr(v6 & 0xFFFFFFFFFFFFFFF7LL, v5));
            unint64_t v6 = v3;
          }

          while (v3 != v2);
        }

        os_unfair_lock_unlock((os_unfair_lock_t)wg + 17);
        return v7;
      }

      else
      {
        os_unfair_lock_unlock((os_unfair_lock_t)wg + 17);
        **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8) = 22;
        return **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
      }
    }

    else
    {
      os_unfair_lock_unlock((os_unfair_lock_t)wg + 17);
      **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8) = 1;
      return **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
    }
  }

  else
  {
    **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8) = 16;
    return **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
  }

uint64_t _os_workgroup_pthread_create_with_workgroup( pthread_t *a1, unsigned int *a2, const pthread_attr_t *a3, uint64_t a4, uint64_t a5)
{
  int v7 = (void *)_dispatch_calloc(1LL, 24LL);
  _os_object_retain_internal((uint64_t)a2);
  *int v7 = a2;
  v7[1] = a4;
  v7[2] = a5;
  unsigned int v6 = pthread_create(a1, a3, (void *(__cdecl *)(void *))_os_workgroup_pthread_start, v7);
  if (v6)
  {
    _os_object_release_internal(a2);
    free(v7);
  }

  return v6;
}

uint64_t _os_workgroup_pthread_start(os_workgroup_s **a1)
{
  uint64_t v9 = a1;
  uint64_t v8 = a1;
  int v7 = 0LL;
  int v7 = *a1;
  unsigned int v6 = 0LL;
  unsigned int v6 = a1[1];
  uint64_t v5 = 0LL;
  uint64_t v5 = a1[2];
  free(a1);
  memset(&token_out, 0, sizeof(token_out));
  int v3 = os_workgroup_join(v7, &token_out);
  if (v3)
  {
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: pthread_start os_workgroup_join failed";
    qword_E4DA8 = v3;
    __break(1u);
    JUMPOUT(0x7B88LL);
  }

  uint64_t v2 = ((uint64_t (*)(os_workgroup_s *))v6)(v5);
  os_workgroup_leave(v7, &token_out);
  _os_object_release_internal((unsigned int *)v7);
  return v2;
}

BOOL _os_workgroup_client_interval_data_initialized(_DWORD *a1)
{
  return *a1 == 1386695757;
}

BOOL _os_workgroup_client_attr_initialized(_DWORD *a1)
{
  BOOL v2 = 1;
  if (*a1 != 799564724) {
    return *a1 == 799564740;
  }
  return v2;
}

uint64_t _wg_type_to_wi_flags(unsigned __int16 a1)
{
  if (a1 <= 0xAuLL) {
    __asm { BR              X8 }
  }

  uint64_t result = _os_crash("Creating an os_workgroup of unknown type");
  __break(1u);
  return result;
}

uint64_t sub_7D48()
{
  return *(unsigned int *)(v0 - 4);
}

BOOL _os_workgroup_attr_has_workload_id(uint64_t a1)
{
  return (*(_DWORD *)(a1 + 12) & 1) != 0;
}

void _os_workgroup_set_work_interval_name(uint64_t a1, uint64_t a2)
{
  if (!*(_DWORD *)(a1 + 40) || *(_DWORD *)(a1 + 40) == -1)
  {
    uint64_t v2 = *(unsigned int *)(a1 + 40);
    qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: Invalid workgroup port";
    qword_E4DA8 = v2;
    __break(1u);
    JUMPOUT(0x7E34LL);
  }

  if (a2) {
    uint64_t v9 = __strlcpy_chk(v12, a2, 32LL, 32LL);
  }
  else {
    uint64_t v9 = 0LL;
  }
  if (v9)
  {
    if (__work_interval_ctl(10LL, *(unsigned int *)(a1 + 40), v12, 32LL) == -1)
    {
      int v10 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
      if (v10) {
        _dispatch_bug(534LL, v10, v3, v4, v5, v6, v7, v8);
      }
    }
  }

uint64_t _os_workgroup_lookup_type_from_workload_id(const char *a1, unsigned int *a2, __int16 *a3)
{
  unsigned __int16 v7 = 0;
  __int16 v6 = 0;
  unsigned int v5 = 0;
  if (!a1)
  {
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Workload identifier must not be NULL";
    __break(1u);
    JUMPOUT(0x7FE0LL);
  }

  for (unint64_t i = 0LL; i < 2; ++i)
  {
    if (!strcasecmp(a1, (&_os_workgroup_workload_id_table)[2 * i]))
    {
      unsigned __int16 v7 = (unsigned __int16)(&_os_workgroup_workload_id_table)[2 * i + 1];
      __int16 v6 = *((_WORD *)&_os_workgroup_workload_id_table + 8 * i + 5);
      if (_os_workgroup_type_is_default_type(v6)) {
        __int16 v6 = v7;
      }
      unsigned int v5 = *((_DWORD *)&_os_workgroup_workload_id_table + 4 * i + 3) & 0xFFFFFFFA | 1;
      if (_os_workgroup_type_is_default_type(v7))
      {
        qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: Invalid workload ID type";
        qword_E4DA8 = i;
        __break(1u);
        JUMPOUT(0x80FCLL);
      }

      break;
    }
  }

  if (!v5) {
    unsigned int v5 = 1;
  }
  *a2 = v5;
  *a3 = v6;
  return v7;
}

uint64_t _wi_flags_to_wg_type(int a1)
{
  BOOL v4 = (a1 & 4) != 0;
  int v3 = _wi_flags_to_wi_type(a1);
  if (v3)
  {
    switch(v3)
    {
      case 268435456:
        if (v4) {
          return 3;
        }
        else {
          return 4;
        }
      case 536870912:
        return 5;
      case 805306368:
        return 2;
      case 1073741824:
        return 7;
      case 1342177280:
        return 8;
      case 1610612736:
        return 9;
      case 1879048192:
        return 10;
      default:
        __snprintf_chk(v7, 0x200uLL, 0, 0x200uLL, "BUG IN DISPATCH: Invalid wi flags = %u", a1);
        _os_crash(v7);
        __break(1u);
        JUMPOUT(0x8318LL);
    }
  }

  else
  {
    return 0;
  }

uint64_t _wi_flags_to_wi_type(int a1)
{
  return a1 & 0xF0000000;
}

uint64_t _dispatch_thread_setspecific(uint64_t result, uint64_t a2)
{
  if (v2) {
    char v3 = 1;
  }
  else {
    char v3 = 0;
  }
  if ((v3 & 1) != 0)
  {
    __break(1u);
    JUMPOUT(0x83D8LL);
  }

  *(void *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * result) = a2;
  return result;
}

uint64_t dispatch_atfork_prepare()
{
  uint64_t v0 = _voucher_atfork_prepare();
  return _os_object_atfork_prepare(v0);
}

void *dispatch_atfork_parent(uint64_t a1)
{
  return _voucher_atfork_parent();
}

void dispatch_atfork_child(uint64_t a1)
{
  if ((_dispatch_unsafe_fork & 1) != 0) {
    _dispatch_child_of_unsafe_fork = 1;
  }
  _dispatch_queue_atfork_child(v1, v2, v3, v4, v5, v6, v7, v8);
  _dispatch_unsafe_fork = 0;
}

uint64_t _dispatch_sigmask()
{
  v8[9] = 4;
  v8[8] = 5;
  v8[7] = 7;
  v8[6] = 8;
  v8[5] = 10;
  v8[4] = 11;
  v8[3] = 12;
  v8[2] = 13;
  v8[1] = 27;
  v8[0] = -67116761;
  int v7 = pthread_sigmask(1, v8, 0LL);
  uint64_t v10 = v7;
  uint64_t v9 = 108LL;
  if (v7) {
    _dispatch_bug(v9, v10, v0, v1, v2, v3, v4, v5);
  }
  return v7;
}

BOOL _dispatch_is_multithreaded()
{
  return (_dispatch_unsafe_fork & 1) != 0;
}

uint64_t _dispatch_is_fork_of_multithreaded_parent()
{
  return _dispatch_child_of_unsafe_fork & 1;
}

dispatch_queue_t dispatch_get_current_queue(void)
{
  uint64_t v2 = (dispatch_queue_s *)_dispatch_thread_getspecific(0x14uLL);
  if (v2) {
    return v2;
  }
  else {
    return (dispatch_queue_t)&off_E46C0;
  }
}

unint64_t _dispatch_queue_attr_to_info(uint64_t *a1)
{
  unsigned int v5 = 0;
  if (a1)
  {
    if (a1 < (uint64_t *)&_dispatch_queue_attr_concurrent || a1 >= qword_E0A78)
    {
      uint64_t v1 = *a1;
      qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Invalid queue attribute";
      qword_E4DA8 = v1;
      __break(1u);
      JUMPOUT(0x898CLL);
    }

    HIWORD(v6) = (unint64_t)((((((char *)a1 - (char *)&_dispatch_queue_attr_concurrent) >> 4) & 1) << 21) | ((((((char *)a1 - (char *)&_dispatch_queue_attr_concurrent) >> 4) & 2) == 0) << 20)) >> 16;
    BYTE1(v6) = -(((unint64_t)(((char *)a1 - (char *)&_dispatch_queue_attr_concurrent) >> 4) >> 2) & 0xF);
    unint64_t v4 = (unint64_t)(((char *)a1 - (char *)&_dispatch_queue_attr_concurrent) >> 4) >> 6;
    int v2 = (v4 * (unsigned __int128)0x2492492492492493uLL) >> 64;
    LOBYTE(v6) = v4 - 7 * ((v2 + ((v4 - v2) >> 1)) >> 2);
    v4 /= 7uLL;
    return v6 & 0xFFF0FFFF | (((_DWORD)v4 - (((v4 / 3) & 0x7FFFFFFF) + 2 * (v4 / 3))) << 18) | (((v4 / 3) - (((v4 / 3 / 3) & 0x7FFFFFFF) + 2 * (v4 / 3 / 3))) << 16);
  }

  return v5;
}

dispatch_queue_attr_t dispatch_queue_attr_make_with_qos_class( dispatch_queue_attr_t attr, dispatch_qos_class_t qos_class, int relative_priority)
{
  unsigned __int8 v7 = relative_priority;
  if (qos_class == QOS_CLASS_UNSPECIFIED
    || qos_class == 5
    || qos_class == QOS_CLASS_BACKGROUND
    || qos_class == QOS_CLASS_UTILITY
    || qos_class == QOS_CLASS_DEFAULT
    || qos_class == QOS_CLASS_USER_INITIATED
    || qos_class == QOS_CLASS_USER_INTERACTIVE)
  {
    BOOL v5 = 0;
    if (relative_priority >= -15) {
      BOOL v5 = relative_priority <= 0;
    }
    BOOL v10 = v5;
  }

  else
  {
    BOOL v10 = 0;
  }

  if (!v10) {
    return attr;
  }
  int v6 = _dispatch_queue_attr_to_info((uint64_t *)attr);
  unint64_t v4 = qos_class - 5;
  if (v4 <= 0x1C) {
    __asm { BR              X8 }
  }

  return (dispatch_queue_attr_t)_dispatch_queue_attr_from_info(v6 & 0xFFFF0000 | (v7 << 8));
}

char *_dispatch_queue_attr_from_info(unsigned int a1)
{
  return (char *)&_dispatch_queue_attr_concurrent
       + 21504 * (BYTE2(a1) & 3)
       + 7168 * ((a1 >> 18) & 3)
       + 1024 * a1
       + 32 * (((a1 >> 20) & 1) == 0)
       + 16 * ((a1 >> 21) & 1)
       + -64 * ((__int16)a1 >> 8);
}

dispatch_queue_attr_t dispatch_queue_attr_make_initially_inactive(dispatch_queue_attr_t attr)
{
  unsigned int v2 = _dispatch_queue_attr_to_info((uint64_t *)attr) & 0xFFDFFFFF | 0x200000;
  return (dispatch_queue_attr_t)_dispatch_queue_attr_from_info(v2);
}

char *dispatch_queue_attr_make_with_overcommit(uint64_t *a1, char a2)
{
  char v5 = a2 & 1;
  int v3 = _dispatch_queue_attr_to_info(a1);
  if ((v5 & 1) != 0) {
    unsigned int v4 = v3 & 0xFFFCFFFF | 0x10000;
  }
  else {
    unsigned int v4 = v3 & 0xFFFCFFFF | 0x20000;
  }
  return _dispatch_queue_attr_from_info(v4);
}

dispatch_queue_attr_t dispatch_queue_attr_make_with_autorelease_frequency( dispatch_queue_attr_t attr, dispatch_autorelease_frequency_t frequency)
{
  unsigned int v3 = _dispatch_queue_attr_to_info((uint64_t *)attr) & 0xFFF3FFFF | ((frequency & 3) << 18);
  return (dispatch_queue_attr_t)_dispatch_queue_attr_from_info(v3);
}

void _dispatch_object_no_invoke(uint64_t a1)
{
  uint64_t v1 = *(void *)(*(void *)a1 + 16LL);
  qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: do_invoke called";
  qword_E4DA8 = v1;
  __break(1u);
}

  ;
}

void _dispatch_object_no_dispose(uint64_t a1)
{
  uint64_t v1 = *(void *)(*(void *)a1 + 16LL);
  qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: do_dispose called";
  qword_E4DA8 = v1;
  __break(1u);
}

  ;
}

uint64_t _dispatch_object_missing_debug(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return __strlcpy_chk(a2, "missing do_debug vtable slot: ", a3, -1LL);
}

void _dispatch_queue_no_activate(uint64_t a1)
{
  uint64_t v1 = *(void *)(*(void *)a1 + 16LL);
  qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: dq_activate called";
  qword_E4DA8 = v1;
  __break(1u);
}

  ;
}

void _dispatch_data_destructor_free_block_invoke(id a1)
{
  qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: free destructor called";
  __break(1u);
}

  ;
}

void _dispatch_data_destructor_none_block_invoke_2(id a1)
{
  qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: none destructor called";
  __break(1u);
}

  ;
}

void _dispatch_data_destructor_vm_deallocate_block_invoke_3(id a1)
{
  qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: vmdeallocate destructor called";
  __break(1u);
}

  ;
}

void _dispatch_data_destructor_inline_block_invoke_4(id a1)
{
  qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: inline destructor called";
  __break(1u);
}

  ;
}

BOOL _dispatch_parse_BOOL(const char *a1)
{
  BOOL v2 = 1;
  if (strcasecmp(a1, "YES"))
  {
    BOOL v2 = 1;
    if (strcasecmp(a1, "Y"))
    {
      BOOL v2 = 1;
      if (strcasecmp(a1, "TRUE")) {
        return atoi(a1) != 0;
      }
    }
  }

  return v2;
}

BOOL _dispatch_getenv_BOOL(const char *a1, char a2)
{
  char v4 = a2 & 1;
  *(void *)&v3[4] = getenv(a1);
  if (*(void *)&v3[4]) {
    *(_DWORD *)unsigned int v3 = _dispatch_parse_BOOL(*(const char **)&v3[4]);
  }
  else {
    *(void *)unsigned int v3 = v4 & 1;
  }
  return *(_DWORD *)v3 != 0;
}

uint64_t _dispatch_build_init(size_t a1)
{
  v2[1] = a1;
  *(void *)unsigned int v3 = 0x4100000001LL;
  v2[0] = 16LL;
  return sysctl(v3, 2u, &_dispatch_build, v2, 0LL, 0LL);
}

uint64_t _dispatch_continuation_get_function_symbol(uint64_t a1)
{
  if ((*(_BYTE *)a1 & 0x20) != 0)
  {
    uint64_t v4 = *(void *)(a1 + 40);
    if ((void (*)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))_Block_get_invoke_fn(v4) == ___dispatch_block_create_block_invoke)
    {
      if (*(void *)(v4 + 32) != 3512316172LL)
      {
        uint64_t v1 = *(void *)(v4 + 32);
        qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Corruption of dispatch block object";
        qword_E4DA8 = v1;
        __break(1u);
        JUMPOUT(0x94D4LL);
      }

      uint64_t v5 = v4 + 32;
    }

    else
    {
      uint64_t v5 = 0LL;
    }

    return _Block_get_invoke_fn(*(void *)(v5 + 40));
  }

  else if ((*(_BYTE *)a1 & 0x10) != 0)
  {
    return _Block_get_invoke_fn(*(void *)(a1 + 40));
  }

  else
  {
    return *(void *)(a1 + 32);
  }

uint64_t _Block_get_invoke_fn(uint64_t a1)
{
  return *(void *)(a1 + 16);
}

void _dispatch_debugv(uint64_t a1, const char *a2, va_list a3)
{
  uint64_t v14 = _dispatch_uptime() - dispatch_log_basetime;
  unsigned int v3 = _dispatch_thread_getspecific(0LL);
  int v16 = __snprintf_chk(v23, 0x800uLL, 0, 0xFFFFFFFFFFFFFFFFLL, "%llu\t\t%p\t", v14, v3);
  if (v16 >= 0)
  {
    else {
      uint64_t v12 = 2048LL;
    }
    uint64_t v13 = v12;
  }

  else
  {
    uint64_t v13 = 0LL;
  }

  if (a1)
  {
    uint64_t v18 = v13 + _dispatch_object_debug2(a1, (uint64_t)&v23[v13], 2048 - v13);
    v23[v18] = 58;
    uint64_t v10 = v18 + 1;
    uint64_t v19 = v18 + 2;
    v23[v10] = 32;
    v23[v19] = 0;
  }

  else
  {
    uint64_t v19 = v13 + __strlcpy_chk(&v23[v13], "NULL: ", 2048 - v13, -1LL);
  }

  int v17 = __vsnprintf_chk(&v23[v19], 2048 - v19, 0, 0xFFFFFFFFFFFFFFFFLL, a2, a3);
  if (v17 >= 0) {
    uint64_t v11 = v17;
  }
  else {
    uint64_t v11 = 0LL;
  }
  uint64_t v15 = v19 + v11;
  if (_dispatch_logv_pred != -1LL) {
    dispatch_once_f(&_dispatch_logv_pred, 0LL, (dispatch_function_t)_dispatch_logv_init);
  }
  if ((dispatch_log_disabled & 1) == 0)
  {
    if (dispatch_logfile == -1) {
      _dispatch_syslog((uint64_t)v23);
    }
    else {
      _dispatch_log_file((uint64_t)v23, v15);
    }
  }

void _dispatch_object_debug( uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
}

uint64_t _dispatch_temporary_resource_shortage()
{
  return sleep_NOCANCEL(1LL);
}

uint64_t _dispatch_calloc(uint64_t a1, uint64_t a2)
{
  while (1)
  {
    uint64_t v3 = malloc_type_calloc(a1, a2, 458526829LL);
    if (v3) {
      break;
    }
    _dispatch_temporary_resource_shortage();
  }

  return v3;
}

const char *_dispatch_strdup_if_mutable(const char *a1)
{
  size_t v9 = strlen(a1) + 1;
  uint64_t v8 = malloc_type_malloc(v9, 312244285LL);
  if (v8) {
    __memcpy_chk(v8, a1, v9, -1LL);
  }
  else {
    _dispatch_bug(1515LL, 0LL, v1, v2, v3, v4, v5, v6);
  }
  return (const char *)v8;
}

void *_dispatch_Block_copy(const void *a1)
{
  if (!a1)
  {
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: NULL was passed where a block should have been";
    __break(1u);
    JUMPOUT(0x9BC8LL);
  }

  while (1)
  {
    uint64_t v2 = _Block_copy(a1);
    if (v2) {
      break;
    }
    _dispatch_temporary_resource_shortage();
  }

  return v2;
}

void _dispatch_call_block_and_release(void (**a1)(void))
{
}

uint64_t _dispatch_client_callout(uint64_t a1, uint64_t (*a2)(uint64_t))
{
  return a2(a1);
}

uint64_t _dispatch_client_callout2(uint64_t a1, uint64_t a2, uint64_t (*a3)(uint64_t, uint64_t))
{
  return a3(a1, a2);
}

uint64_t _dispatch_client_callout3( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t (*a4)(uint64_t, uint64_t, uint64_t))
{
  return a4(a1, a2, a3);
}

uint64_t _dispatch_client_callout4( uint64_t a1, uint64_t a2, uint64_t a3, unsigned int a4, uint64_t (*a5)(uint64_t, uint64_t, uint64_t, void))
{
  return a5(a1, a2, a3, a4);
}

void *_os_object_alloc_bridged( uint64_t a1, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return _os_objc_alloc(a1, a2, a3, a4, a5, a6, a7, a8);
}

void *_os_objc_alloc( uint64_t a1, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a2 < 8) {
    _dispatch_abort(1693LL, a2 >= 8, a3, a4, a5, a6, a7, a8);
  }
  while (1)
  {
    size_t v9 = (void *)malloc_type_calloc(1LL, a2, 3970180825LL);
    if (v9) {
      break;
    }
    _dispatch_temporary_resource_shortage();
  }

  void *v9 = a1;
  return v9;
}

void *_os_object_alloc_realized( uint64_t a1, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a2 < 0x10) {
    _dispatch_abort(1711LL, a2 >= 0x10, a3, a4, a5, a6, a7, a8);
  }
  uint64_t result = _os_objc_alloc(a1, a2, a3, a4, a5, a6, a7, a8);
  *((_DWORD *)result + 2) = 1;
  *((_DWORD *)result + 3) = 1;
  return result;
}

void *_os_object_alloc( void *a1, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  size_t v9 = a1;
  if (!a1) {
    size_t v9 = &_os_object_vtable;
  }
  return _os_object_alloc_realized((uint64_t)v9, a2, a3, a4, a5, a6, a7, a8);
}

void _os_object_dealloc(void *a1)
{
  *a1 = 512LL;
  free(a1);
}

void _os_object_xref_dispose(unsigned int *a1)
{
  if (**(void **)a1) {
    (**(void (***)(unsigned int *))a1)(a1);
  }
  else {
    _os_object_release_internal(a1);
  }
}

void _os_object_dispose(unsigned int *a1)
{
  if (*(void *)(*(void *)a1 + 8LL)) {
    (*(void (**)(unsigned int *))(*(void *)a1 + 8LL))(a1);
  }
  else {
    _os_object_dealloc(a1);
  }
}

void *__cdecl os_retain(void *object)
{
  if (object) {
    return (void *)_os_object_retain((uint64_t)object);
  }
  else {
    return 0LL;
  }
}

void os_release(void *object)
{
  if (object) {
    _os_object_release((unsigned int *)object);
  }
}

uint64_t _dispatch_autorelease_pool_push()
{
  uint64_t v1 = 0LL;
  if (_dispatch_begin_NSAutoReleasePool) {
    return _dispatch_begin_NSAutoReleasePool();
  }
  return v1;
}

uint64_t _dispatch_autorelease_pool_pop(uint64_t result)
{
  if (_dispatch_end_NSAutoReleasePool) {
    return _dispatch_end_NSAutoReleasePool(result);
  }
  return result;
}

uint64_t _dispatch_last_resort_autorelease_pool_push(uint64_t a1)
{
  uint64_t result = _dispatch_autorelease_pool_push();
  *(void *)(a1 + 24) = result;
  return result;
}

uint64_t _dispatch_last_resort_autorelease_pool_pop(uint64_t a1)
{
  uint64_t result = _dispatch_autorelease_pool_pop(*(void *)(a1 + 24));
  *(void *)(a1 + 24) = 0LL;
  return result;
}

uint64_t dispatch_mach_msg_get_context(uint64_t a1)
{
  uint64_t v2 = 0LL;
  uint64_t v3 = a1 + ((*(unsigned int *)(a1 + 4) + 3LL) & 0xFFFFFFFFFFFFFFFCLL);
  if (*(_DWORD *)(v3 + 4) >= 0x3Cu) {
    return *(void *)(v3 + 52);
  }
  return v2;
}

uint64_t _dispatch_wakeup_runloop_thread()
{
  return 0LL;
}

void _dispatch_mach_notify_port_destroyed(uint64_t a1, unsigned int a2)
{
  qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: unexpected receipt of port-destroyed";
  qword_E4DA8 = a2;
  __break(1u);
}

uint64_t sub_A390()
{
  return 5LL;
}

void _dispatch_mach_notify_no_senders(uint64_t a1, unsigned int a2)
{
  qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: unexpected receipt of no-more-senders";
  qword_E4DA8 = a2;
  __break(1u);
}

uint64_t sub_A3E8()
{
  return 5LL;
}

uint64_t _dispatch_mach_notify_send_once( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return 0LL;
}

uint64_t _dispatch_mach_xpc_no_handle_message()
{
  return 0LL;
}

uint64_t _dispatch_mach_msg_context_no_async_reply_queue()
{
  return 0LL;
}

void _dispatch_mach_default_async_reply_handler()
{
  qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: _dispatch_mach_default_async_reply_handler called";
  qword_E4DA8 = (uint64_t)_dispatch_mach_xpc_hooks;
  __break(1u);
}

void sub_A4AC()
{
}

uint64_t _dispatch_mach_enable_sigterm()
{
  return 1LL;
}

char *_dispatch_logv_init(uint64_t a1)
{
  uint64_t v10 = a1;
  char v9 = 1;
  uint64_t result = getenv("LIBDISPATCH_LOG");
  __s1 = result;
  if (result)
  {
    uint64_t result = (char *)strcmp(__s1, "YES");
    if ((_DWORD)result)
    {
      uint64_t result = (char *)strcmp(__s1, "NO");
      if ((_DWORD)result)
      {
        uint64_t result = (char *)strcmp(__s1, "syslog");
        if ((_DWORD)result)
        {
          uint64_t result = (char *)strcmp(__s1, "file");
          if ((_DWORD)result)
          {
            uint64_t result = (char *)strcmp(__s1, "stderr");
            if (!(_DWORD)result)
            {
              char v9 = 1;
              dispatch_logfile = 2;
            }
          }

          else
          {
            char v9 = 1;
          }
        }

        else
        {
          char v9 = 0;
        }
      }

      else
      {
        dispatch_log_disabled = 1;
      }
    }
  }

  if ((dispatch_log_disabled & 1) == 0)
  {
    if ((v9 & 1) != 0 && dispatch_logfile == -1)
    {
      pid_t v2 = getpid();
      __snprintf_chk(v11, 0x400uLL, 0, 0x400uLL, "/var/tmp/libdispatch.%d.log", v2);
      uint64_t result = (char *)open_NOCANCEL(v11, 16777993LL);
      dispatch_logfile = (int)result;
    }

    if (dispatch_logfile != -1)
    {
      v7.tv_sec = 0LL;
      *(void *)&v7.tv_usec = 0LL;
      gettimeofday(&v7, 0LL);
      dispatch_log_basetime = _dispatch_uptime();
      int v5 = dispatch_logfile;
      uint64_t v6 = getprogname();
      if (v6) {
        uint64_t v4 = v6;
      }
      else {
        uint64_t v4 = "";
      }
      pid_t v3 = getpid();
      return (char *)dprintf(v5, "=== log file opened for %s[%u] at %ld.%06u ===\n", v4, v3, v7.tv_sec, v7.tv_usec);
    }
  }

  return result;
}

uint64_t _dispatch_log_file(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = a2 + 1;
  *(_BYTE *)(a1 + a2) = 10;
  do
    uint64_t result = write_NOCANCEL(dispatch_logfile, a1, v3);
  while (result == -1 && **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8) == 4);
  return result;
}

uint64_t _dispatch_logv_file(const char *a1, va_list a2)
{
  uint64_t v2 = _dispatch_uptime();
  int v6 = __snprintf_chk(v10, 0x800uLL, 0, 0xFFFFFFFFFFFFFFFFLL, "%llu\t", v2 - dispatch_log_basetime);
  if (v6 >= 0)
  {
    else {
      uint64_t v4 = 2048LL;
    }
    uint64_t v5 = v4;
  }

  else
  {
    uint64_t v5 = 0LL;
  }

  uint64_t result = __vsnprintf_chk(&v10[v5], 2048 - v5, 0, 0xFFFFFFFFFFFFFFFFLL, a1, a2);
  if ((int)result >= 0)
  {
    unint64_t v7 = v5 + (int)result;
    if (v7 > 0x7FF) {
      unint64_t v7 = 2047LL;
    }
    return _dispatch_log_file((uint64_t)v10, v7);
  }

  return result;
}

uint64_t _dispatch_syslog(uint64_t a1)
{
  return _simple_asl_log(5LL, "com.apple.libsystem.libdispatch", a1);
}

void _dispatch_vsyslog(char *a1, char *a2)
{
  size_t v2[2] = a1;
  v2[1] = a2;
  v2[0] = 0LL;
  vasprintf(v2, a1, a2);
  if (v2[0])
  {
    _dispatch_syslog((uint64_t)v2[0]);
    free(v2[0]);
  }

uint64_t _dispatch_uptime()
{
  return mach_absolute_time();
}

uint64_t _dispatch_object_debug2(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)a1 + 40LL))(a1, a2, a3);
}

uint64_t _os_object_retain_internal(uint64_t result)
{
  int v5 = *(_DWORD *)(result + 8);
  if (v5 != 0x7FFFFFFF)
  {
    uint64_t v3 = (unsigned int *)(result + 8);
    unsigned int v4 = *(_DWORD *)(result + 8);
    do
    {
      unsigned int v1 = v4;
      do
        unsigned int v2 = __ldaxr(v3);
      while (v2 == v4 && __stlxr(v4 + 1, v3));
      unsigned int v4 = v2;
    }

    while (v2 != v1);
    int v5 = v2;
  }

  if (v5 <= 0)
  {
    qword_E4D78 = (uint64_t)"API MISUSE: Resurrection of an object";
    __break(1u);
    JUMPOUT(0xAC6CLL);
  }

  return result;
}

uint64_t _os_object_retain_internal_n(uint64_t result, unsigned __int16 a2)
{
  int v6 = *(_DWORD *)(result + 8);
  if (v6 != 0x7FFFFFFF)
  {
    unsigned int v4 = (unsigned int *)(result + 8);
    unsigned int v5 = *(_DWORD *)(result + 8);
    do
    {
      unsigned int v2 = v5;
      do
        unsigned int v3 = __ldaxr(v4);
      while (v3 == v5 && __stlxr(v5 + a2, v4));
      unsigned int v5 = v3;
    }

    while (v3 != v2);
    int v6 = v3;
  }

  if (v6 <= 0)
  {
    qword_E4D78 = (uint64_t)"API MISUSE: Resurrection of an object";
    __break(1u);
    JUMPOUT(0xADC4LL);
  }

  return result;
}

void _os_object_release_internal(unsigned int *a1)
{
  int v6 = a1[2];
  if (v6 != 0x7FFFFFFF)
  {
    unsigned int v3 = a1 + 2;
    unsigned int v4 = a1[2];
    do
    {
      unsigned int v1 = v4;
      do
        unsigned int v2 = __ldaxr(v3);
      while (v2 == v4 && __stlxr(v4 - 1, v3));
      unsigned int v4 = v2;
    }

    while (v2 != v1);
    int v6 = v2 - 1;
  }

  if (v6 < 1)
  {
    if (v6 < 0)
    {
      qword_E4D78 = (uint64_t)"API MISUSE: Over-release of an object";
      __break(1u);
      JUMPOUT(0xAF60LL);
    }

    int v5 = a1[3];
    if (v5 >= 1)
    {
      qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: Release while external references exist";
      qword_E4DA8 = v5;
      __break(1u);
      JUMPOUT(0xAFC0LL);
    }

    _os_object_dispose(a1);
  }

void _os_object_release_internal_n(unsigned int *a1, unsigned __int16 a2)
{
  int v7 = a1[2];
  if (v7 != 0x7FFFFFFF)
  {
    unsigned int v4 = a1 + 2;
    unsigned int v5 = a1[2];
    do
    {
      unsigned int v2 = v5;
      do
        unsigned int v3 = __ldaxr(v4);
      while (v3 == v5 && __stlxr(v5 - a2, v4));
      unsigned int v5 = v3;
    }

    while (v3 != v2);
    int v7 = v3 - a2;
  }

  if (v7 < 1)
  {
    if (v7 < 0)
    {
      qword_E4D78 = (uint64_t)"API MISUSE: Over-release of an object";
      __break(1u);
      JUMPOUT(0xB16CLL);
    }

    int v6 = a1[3];
    if (v6 >= 1)
    {
      qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: Release while external references exist";
      qword_E4DA8 = v6;
      __break(1u);
      JUMPOUT(0xB1CCLL);
    }

    _os_object_dispose(a1);
  }

uint64_t _os_object_retain(uint64_t result)
{
  int v5 = *(_DWORD *)(result + 12);
  if (v5 != 0x7FFFFFFF)
  {
    unsigned int v3 = (unsigned int *)(result + 12);
    unsigned int v4 = *(_DWORD *)(result + 12);
    do
    {
      unsigned int v1 = v4;
      do
        unsigned int v2 = __ldaxr(v3);
      while (v2 == v4 && __stlxr(v4 + 1, v3));
      unsigned int v4 = v2;
    }

    while (v2 != v1);
    int v5 = v2;
  }

  if (v5 <= 0)
  {
    qword_E4D78 = (uint64_t)"API MISUSE: Resurrection of an object";
    __break(1u);
    JUMPOUT(0xB320LL);
  }

  return result;
}

uint64_t _os_object_retain_with_resurrect(uint64_t a1)
{
  unsigned int v6 = *(_DWORD *)(a1 + 12);
  if (v6 != 0x7FFFFFFF)
  {
    unsigned int v4 = (unsigned int *)(a1 + 12);
    unsigned int v5 = *(_DWORD *)(a1 + 12);
    do
    {
      unsigned int v1 = v5;
      do
        unsigned int v2 = __ldaxr(v4);
      while (v2 == v5 && __stlxr(v5 + 1, v4));
      unsigned int v5 = v2;
    }

    while (v2 != v1);
    unsigned int v6 = v2;
  }

  if ((int)(v6 + 1) <= 0)
  {
    qword_E4D78 = (uint64_t)"API MISUSE: Resurrection of an over-released object";
    __break(1u);
    JUMPOUT(0xB478LL);
  }

  if (!v6) {
    _os_object_retain_internal(a1);
  }
  return a1;
}

void _os_object_release(unsigned int *a1)
{
  int v5 = a1[3];
  if (v5 != 0x7FFFFFFF)
  {
    unsigned int v3 = a1 + 3;
    unsigned int v4 = a1[3];
    do
    {
      unsigned int v1 = v4;
      do
        unsigned int v2 = __ldaxr(v3);
      while (v2 == v4 && __stlxr(v4 - 1, v3));
      unsigned int v4 = v2;
    }

    while (v2 != v1);
    int v5 = v2 - 1;
  }

  if (v5 < 1)
  {
    if (v5 < 0)
    {
      qword_E4D78 = (uint64_t)"API MISUSE: Over-release of an object";
      __break(1u);
      JUMPOUT(0xB638LL);
    }

    char v6 = 1;
  }

  else
  {
    char v6 = 0;
  }

  if (v6 == 1) {
    _os_object_xref_dispose(a1);
  }
}

void _os_object_release_without_xref_dispose(unsigned int *a1)
{
  int v5 = a1[3];
  if (v5 != 0x7FFFFFFF)
  {
    unsigned int v3 = a1 + 3;
    unsigned int v4 = a1[3];
    do
    {
      unsigned int v1 = v4;
      do
        unsigned int v2 = __ldaxr(v3);
      while (v2 == v4 && __stlxr(v4 - 1, v3));
      unsigned int v4 = v2;
    }

    while (v2 != v1);
    int v5 = v2 - 1;
  }

  if (v5 < 1)
  {
    if (v5 < 0)
    {
      qword_E4D78 = (uint64_t)"API MISUSE: Over-release of an object";
      __break(1u);
      JUMPOUT(0xB7FCLL);
    }

    char v6 = 1;
  }

  else
  {
    char v6 = 0;
  }

  if (v6 == 1) {
    _os_object_release_internal(a1);
  }
}

void *_dispatch_object_alloc( uint64_t a1, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return _os_object_alloc_realized(a1, a2, a3, a4, a5, a6, a7, a8);
}

  ;
}

void _dispatch_object_dealloc(void *a1)
{
  *a1 = 0LL;
  free(a1);
}

void dispatch_retain(dispatch_object_t object)
{
}

void dispatch_release(dispatch_object_t object)
{
  int v5 = *((_DWORD *)object + 3);
  if (v5 != 0x7FFFFFFF)
  {
    unsigned int v3 = (unsigned int *)((char *)object + 12);
    unsigned int v4 = *((_DWORD *)object + 3);
    do
    {
      unsigned int v1 = v4;
      do
        unsigned int v2 = __ldaxr(v3);
      while (v2 == v4 && __stlxr(v4 - 1, v3));
      unsigned int v4 = v2;
    }

    while (v2 != v1);
    int v5 = v2 - 1;
  }

  if (v5 < 1)
  {
    if (v5 < 0)
    {
      qword_E4D78 = (uint64_t)"API MISUSE: Over-release of an object";
      __break(1u);
      JUMPOUT(0xBA4CLL);
    }

    char v6 = 1;
  }

  else
  {
    char v6 = 0;
  }

  if (v6 == 1)
  {
    atomic_load((unsigned int *)object + 3);
    _dispatch_xref_dispose((unsigned int *)object);
  }

void _dispatch_xref_dispose(unsigned int *a1)
{
  if ((*(void *)(*(void *)a1 + 16LL) & 0xF0LL) == 0x10)
  {
    _dispatch_queue_xref_dispose((uint64_t)a1);
    uint64_t v8 = *(void *)(*(void *)a1 + 16LL);
    switch(v8)
    {
      case 275LL:
        _dispatch_source_xref_dispose((uint64_t)a1);
        break;
      case 531LL:
        _dispatch_channel_xref_dispose((uint64_t)a1);
        break;
      case 787LL:
        if (((*((_WORD *)a1 + 58) >> 4) & 1) != 0) {
          *(void *)(*((void *)a1 + 11) + 48LL) = 195952365LL;
        }
        break;
      case 395025LL:
        _dispatch_runloop_queue_xref_dispose((uint64_t)a1, v1, v2, v3, v4, v5, v6, v7);
        break;
    }
  }

  _dispatch_release_tailcall(a1);
}

void _dispatch_release_tailcall(unsigned int *a1)
{
}

void _dispatch_dispose(uint64_t a1)
{
  uint64_t v7 = (void *)a1;
  dispatch_queue_t queue = 0LL;
  dispatch_queue_t queue = *(dispatch_queue_t *)(a1 + 24);
  dispatch_function_t work = 0LL;
  uint64_t v8 = a1;
  dispatch_function_t work = *(dispatch_function_t *)(a1 + 40);
  context = 0LL;
  context = *(void **)(a1 + 32);
  char v3 = 1;
  if (*(void *)(a1 + 16) != -1985229329LL)
  {
    uint64_t v1 = v7[2];
    qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: Release while enqueued";
    qword_E4DA8 = v1;
    __break(1u);
    JUMPOUT(0xBCB4LL);
  }

  BOOL v2 = 0;
  if (queue) {
    BOOL v2 = *((void *)queue + 8) == 22LL;
  }
  if (v2)
  {
    int v11 = 4;
    uint64_t v10 = 0LL;
    int v9 = 0;
    dispatch_queue_t queue = (dispatch_queue_t)&off_E4640;
  }

  (*(void (**)(void *, char *))(*v7 + 32LL))(v7, &v3);
  if ((v3 & 1) != 0)
  {
    _dispatch_object_finalize();
    _dispatch_object_dealloc(v7);
  }

  if (work && context) {
    dispatch_channel_async_f(queue, context, work);
  }
  if (queue) {
    _dispatch_release_tailcall((unsigned int *)queue);
  }
}

void *__cdecl dispatch_get_context(dispatch_object_t object)
{
  if ((*(void *)(*(void *)object + 16LL) & 0x40000LL) != 0) {
    return 0LL;
  }
  else {
    return (void *)*((void *)object + 4);
  }
}

void dispatch_set_context(dispatch_object_t object, void *context)
{
  if ((*(void *)(*(void *)object + 16LL) & 0x40000LL) == 0) {
    *((void *)object + 4) = context;
  }
}

void dispatch_set_finalizer_f(dispatch_object_t object, dispatch_function_t finalizer)
{
  if ((*(void *)(*(void *)object + 16LL) & 0x40000LL) == 0) {
    *((void *)object + 5) = finalizer;
  }
}

void dispatch_set_target_queue(dispatch_object_t object, dispatch_queue_t queue)
{
  int v11 = (uint64_t (***)())queue;
  char v10 = 1;
  if (*((_DWORD *)object + 2) != 0x7FFFFFFF)
  {
    LOBYTE(v9) = 1;
    if ((*(_BYTE *)(*(void *)object + 18LL) & 1) == 0) {
      int v9 = (*(unsigned __int8 *)(*(void *)object + 18LL) >> 1) & 1;
    }
    char v10 = v9;
  }

  if ((v10 & 1) == 0)
  {
    char v8 = 0;
    if (queue)
    {
      char v8 = 0;
      if ((*((_BYTE *)queue + 87) & 8) != 0)
      {
        if (*(void *)object >= 0x1000uLL)
        {
          char v7 = 1;
          if (*(void *)(*(void *)object + 16LL) != 1LL)
          {
            BOOL is_timer = 0;
            if (*(_BYTE *)(*(void *)object + 16LL) == 19LL) {
              BOOL is_timer = _dispatch_source_is_timer((uint64_t)object);
            }
            char v7 = is_timer;
          }

          char v13 = v7 & 1;
        }

        else
        {
          char v13 = 1;
        }

        char v8 = v13 ^ 1;
      }
    }

    if ((v8 & 1) != 0)
    {
      qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Cannot target the cooperative root queue - not implemented";
      qword_E4DA8 = (uint64_t)object;
      __break(1u);
      JUMPOUT(0xC138LL);
    }

    if ((*(void *)(*(void *)object + 16LL) & 0xF0LL) == 0x10)
    {
      _dispatch_lane_set_target_queue((uint64_t)object, v11);
    }

    else if (*(void *)(*(void *)object + 16LL) == 4LL)
    {
      _dispatch_io_set_target_queue((uint64_t)object, (uint64_t)v11);
    }

    else
    {
      if (!v11) {
        int v11 = &off_E4640;
      }
      _dispatch_retain((uint64_t)v11);
      uint64_t v4 = (unint64_t *)((char *)object + 24);
      uint64_t v5 = (unsigned int *)*((void *)object + 3);
      do
      {
        BOOL v2 = v5;
        do
          char v3 = (unsigned int *)__ldaxr(v4);
        while (v3 == v5 && __stlxr((unint64_t)v11, v4));
        uint64_t v5 = v3;
      }

      while (v3 != v2);
      if (v3) {
        _dispatch_release(v3);
      }
    }
  }

void dispatch_activate(dispatch_object_t object)
{
  if (*((_DWORD *)object + 2) != 0x7FFFFFFF)
  {
    if (*(_BYTE *)(*(void *)object + 16LL) == 18LL)
    {
      _dispatch_workloop_activate((uint64_t)object);
    }

    else if ((*(void *)(*(void *)object + 16LL) & 0xF0LL) == 0x10)
    {
      _dispatch_lane_resume((unsigned __int16 *)object, 1);
    }
  }

void dispatch_suspend(dispatch_object_t object)
{
  char v3 = 1;
  if (*((_DWORD *)object + 2) != 0x7FFFFFFF)
  {
    LOBYTE(v2) = 1;
    if ((*(_BYTE *)(*(void *)object + 18LL) & 1) == 0) {
      int v2 = (*(unsigned __int8 *)(*(void *)object + 18LL) >> 1) & 1;
    }
    char v3 = v2;
  }

  if ((v3 & 1) == 0 && (*(void *)(*(void *)object + 16LL) & 0xF0LL) == 0x10)
  {
    BOOL v1 = 0;
    if (*(_BYTE *)(*(void *)object + 16LL) == 18LL) {
      BOOL v1 = _dispatch_workloop_uses_bound_thread((uint64_t)object);
    }
    if (v1)
    {
      qword_E4D78 = (uint64_t)"API MISUSE: Object type does not support suspension";
      __break(1u);
      JUMPOUT(0xC468LL);
    }

    _dispatch_lane_suspend((uint64_t)object);
  }

void dispatch_resume(dispatch_object_t object)
{
  char v3 = 1;
  if (*((_DWORD *)object + 2) != 0x7FFFFFFF)
  {
    LOBYTE(v2) = 1;
    if ((*(_BYTE *)(*(void *)object + 18LL) & 1) == 0) {
      int v2 = (*(unsigned __int8 *)(*(void *)object + 18LL) >> 1) & 1;
    }
    char v3 = v2;
  }

  if ((v3 & 1) == 0 && (*(void *)(*(void *)object + 16LL) & 0xF0LL) == 0x10)
  {
    BOOL v1 = 0;
    if (*(_BYTE *)(*(void *)object + 16LL) == 18LL) {
      BOOL v1 = _dispatch_workloop_uses_bound_thread((uint64_t)object);
    }
    if (v1)
    {
      qword_E4D78 = (uint64_t)"API MISUSE: Object type does not support resume";
      __break(1u);
      JUMPOUT(0xC5A0LL);
    }

    _dispatch_lane_resume((unsigned __int16 *)object, 0);
  }

uint64_t _dispatch_retain(uint64_t result)
{
  int v5 = *(_DWORD *)(result + 8);
  if (v5 != 0x7FFFFFFF)
  {
    char v3 = (unsigned int *)(result + 8);
    unsigned int v4 = *(_DWORD *)(result + 8);
    do
    {
      unsigned int v1 = v4;
      do
        unsigned int v2 = __ldaxr(v3);
      while (v2 == v4 && __stlxr(v4 + 1, v3));
      unsigned int v4 = v2;
    }

    while (v2 != v1);
    int v5 = v2;
  }

  if (v5 <= 0)
  {
    qword_E4D78 = (uint64_t)"API MISUSE: Resurrection of an object";
    __break(1u);
    JUMPOUT(0xC710LL);
  }

  return result;
}

void _dispatch_release(unsigned int *a1)
{
  int v6 = a1[2];
  if (v6 != 0x7FFFFFFF)
  {
    char v3 = a1 + 2;
    unsigned int v4 = a1[2];
    do
    {
      unsigned int v1 = v4;
      do
        unsigned int v2 = __ldaxr(v3);
      while (v2 == v4 && __stlxr(v4 - 1, v3));
      unsigned int v4 = v2;
    }

    while (v2 != v1);
    int v6 = v2 - 1;
  }

  if (v6 < 1)
  {
    if (v6 < 0)
    {
      qword_E4D78 = (uint64_t)"API MISUSE: Over-release of an object";
      __break(1u);
      JUMPOUT(0xC8A8LL);
    }

    int v5 = a1[3];
    if (v5 >= 1)
    {
      qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: Release while external references exist";
      qword_E4DA8 = v5;
      __break(1u);
      JUMPOUT(0xC908LL);
    }

    _os_object_dispose(a1);
  }

void *_dispatch_block_create( void *a1, void *a2, uint64_t a3, const void *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v36 = a1;
  uint64_t v35 = a2;
  uint64_t v34 = a3;
  uint64_t v33 = a4;
  __int16 v41 = v24;
  int v40 = a1;
  uint64_t v39 = a2;
  uint64_t v38 = a3;
  uint64_t v37 = a4;
  uint64_t v50 = v24;
  uint64_t v49 = a1;
  uint64_t v48 = a2;
  uint64_t v47 = a3;
  uint64_t v46 = a4;
  v24[0] = 0LL;
  v24[1] = a1;
  int v25 = 0;
  int v26 = 0;
  uint64_t v27 = a3;
  uint64_t v28 = a2;
  uint64_t v29 = a4;
  uint64_t v30 = 0LL;
  uint64_t v31 = 0LL;
  int v32 = 0;
  char v10 = _NSConcreteStackBlock;
  int v11 = 1174405120;
  int v12 = 0;
  char v13 = ___dispatch_block_create_block_invoke;
  uint64_t v14 = &__block_descriptor_tmp_0;
  uint64_t v43 = v15;
  uint64_t v42 = v24;
  uint64_t v52 = v15;
  uint64_t v51 = v24;
  unsigned int v53 = v15;
  v15[0] = 3512316172LL;
  v15[1] = a1;
  int v16 = 0;
  int v17 = 0;
  uint64_t v18 = a3;
  uint64_t v19 = a2;
  uint64_t v20 = 0LL;
  uint64_t v21 = 0LL;
  uint64_t v22 = 0LL;
  int v23 = 0;
  if (v51[5])
  {
    a1 = _dispatch_Block_copy((const void *)v51[5]);
    uint64_t v20 = a1;
  }

  if (*v51) {
    uint64_t v21 = (dispatch_group_s *)_dispatch_group_create_and_enter( (uint64_t)a1,  (uint64_t)a2,  a3,  (uint64_t)a4,  a5,  a6,  a7,  a8);
  }
  int v9 = _dispatch_Block_copy(&v10);
  uint64_t v45 = v15;
  uint64_t v54 = v15;
  uint64_t v55 = v15;
  if (v15[0] == 3512316172LL)
  {
    if (v21)
    {
      if (!v17) {
        dispatch_group_leave(v21);
      }
      _os_object_release_without_xref_dispose((unsigned int *)v21);
    }

    if (v22) {
      _os_object_release_internal_n(v22, 2u);
    }
    if (v20) {
      _Block_release(v20);
    }
  }

  uint64_t v44 = v24;
  uint64_t v56 = v24;
  uint64_t v57 = v24;
  if (v24[0] == 3512316172LL)
  {
    if (v30)
    {
      if (!v26) {
        dispatch_group_leave(v30);
      }
      _os_object_release_without_xref_dispose((unsigned int *)v30);
    }

    if (v31) {
      _os_object_release_internal_n(v31, 2u);
    }
    if (v29) {
      _Block_release(v29);
    }
  }

  return v9;
}

void ___dispatch_block_create_block_invoke( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

char *__copy_helper_block_8_32c35_ZTS29dispatch_block_private_data_s( char *result, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v9 = a2 + 4;
  char v8 = result + 32;
  *((void *)result + 4) = 3512316172LL;
  *((void *)result + 5) = a2[5];
  *((_DWORD *)result + 12) = 0;
  *((_DWORD *)result + 13) = 0;
  *((void *)result + 7) = a2[7];
  *((void *)result + 8) = a2[8];
  *((void *)result + 9) = 0LL;
  *((void *)result + 10) = 0LL;
  *((void *)result + 11) = 0LL;
  *((_DWORD *)result + 24) = 0;
  if (*((void *)result + 8) && *((void *)result + 8) != -1LL) {
    uint64_t result = (char *)voucher_retain(*((void **)result + 8));
  }
  if (v9[5])
  {
    uint64_t result = (char *)_dispatch_Block_copy((const void *)v9[5]);
    *((void *)v8 + 5) = result;
  }

  if (*v9)
  {
    uint64_t result = (char *)_dispatch_group_create_and_enter((uint64_t)result, (uint64_t)a2, a3, a4, a5, a6, a7, a8);
    *((void *)v8 + 6) = result;
  }

  return result;
}

void __destroy_helper_block_8_32c35_ZTS29dispatch_block_private_data_s(uint64_t a1)
{
  uint64_t v1 = a1 + 32;
  if (*(void *)(a1 + 32) == 3512316172LL)
  {
    if (*(void *)(a1 + 80))
    {
      if (!*(_DWORD *)(a1 + 52)) {
        dispatch_group_leave(*(dispatch_group_t *)(a1 + 80));
      }
      _os_object_release_without_xref_dispose(*(unsigned int **)(v1 + 48));
    }

    if (*(void *)(v1 + 56)) {
      _os_object_release_internal_n(*(unsigned int **)(v1 + 56), 2u);
    }
    if (*(void *)(v1 + 40)) {
      _Block_release(*(const void **)(v1 + 40));
    }
    if (*(void *)(v1 + 32))
    {
      if (*(void *)(v1 + 32) != -1LL) {
        voucher_release(*(void **)(v1 + 32));
      }
    }
  }

void _dispatch_sema4_create_slow(unsigned int *a1, int a2)
{
  kern_return_t v6;
  kern_return_t v7;
  semaphore_t semaphore;
  int policy;
  unsigned int *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  unint64_t v21;
  unint64_t StatusReg;
  char v10 = a1;
  policy = a2;
  semaphore = 0;
  if ((_dispatch_unsafe_fork & 1) == 0) {
    _dispatch_fork_becomes_unsafe_slow();
  }
  if (policy)
  {
    int v6 = semaphore_create(mach_task_self_, &semaphore, policy, 0);
    if (v6 == -301)
    {
      qword_E4D78 = (uint64_t)"MIG_REPLY_MISMATCH";
      qword_E4DA8 = -301LL;
      __break(1u);
      JUMPOUT(0xD28CLL);
    }

    if (v6 == 15)
    {
      qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Use-after-free of dispatch_semaphore_t or dispatch_group_t";
      qword_E4DA8 = 15LL;
      __break(1u);
      JUMPOUT(0xD2E0LL);
    }

    if (v6)
    {
      qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: mach semaphore API failure";
      qword_E4DA8 = v6;
      __break(1u);
      JUMPOUT(0xD330LL);
    }

    char v3 = v10;
    semaphore_t v4 = semaphore;
    do
      unsigned int v5 = __ldaxr(v3);
    while (!v5 && __stlxr(v4, v3));
    if (v5)
    {
      char v7 = semaphore_destroy(mach_task_self_, semaphore);
      if (v7 == -301)
      {
        qword_E4D78 = (uint64_t)"MIG_REPLY_MISMATCH";
        qword_E4DA8 = -301LL;
        __break(1u);
        JUMPOUT(0xD448LL);
      }

      if (v7 == 15)
      {
        qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Use-after-free of dispatch_semaphore_t or dispatch_group_t";
        qword_E4DA8 = 15LL;
        __break(1u);
        JUMPOUT(0xD49CLL);
      }

      if (v7)
      {
        qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: mach semaphore API failure";
        qword_E4DA8 = v7;
        __break(1u);
        JUMPOUT(0xD4ECLL);
      }
    }
  }

  else
  {
    int v11 = 0LL;
    int v16 = 9LL;
    unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
    int v11 = *(void *)(StatusReg + 72);
    if (v11)
    {
      uint64_t v20 = 9LL;
      uint64_t v19 = 0LL;
      uint64_t v21 = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
      *(void *)(v21 + 72) = 0LL;
      int v12 = v11;
    }

    else
    {
      int v12 = _os_semaphore_create();
    }

    semaphore = v12;
    do
      unsigned int v2 = __ldaxr(v10);
    while (!v2 && __stlxr(v12, v10));
    if (v2)
    {
      uint64_t v14 = semaphore;
      char v13 = 0LL;
      uint64_t v15 = 9LL;
      char v13 = *(void *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 72);
      uint64_t v18 = 9LL;
      int v17 = semaphore;
      *(void *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 72) = semaphore;
      if (v13) {
        _os_semaphore_dispose(v13);
      }
    }
  }

semaphore_t *_dispatch_sema4_dispose_slow(semaphore_t *result, int a2)
{
  semaphore_t semaphore = *result;
  *uint64_t result = -1;
  if (a2)
  {
    uint64_t result = (semaphore_t *)semaphore_destroy(mach_task_self_, semaphore);
    if ((_DWORD)result == -301)
    {
      qword_E4D78 = (uint64_t)"MIG_REPLY_MISMATCH";
      qword_E4DA8 = -301LL;
      __break(1u);
      JUMPOUT(0xD63CLL);
    }

    if ((_DWORD)result == 15)
    {
      qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Use-after-free of dispatch_semaphore_t or dispatch_group_t";
      qword_E4DA8 = 15LL;
      __break(1u);
      JUMPOUT(0xD690LL);
    }

    if ((_DWORD)result)
    {
      qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: mach semaphore API failure";
      qword_E4DA8 = (int)result;
      __break(1u);
      JUMPOUT(0xD6E0LL);
    }
  }

  else
  {
    uint64_t v3 = *(void *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 72);
    *(void *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 72) = semaphore;
    if (v3) {
      return (semaphore_t *)_os_semaphore_dispose(v3);
    }
  }

  return result;
}

uint64_t _dispatch_sema4_signal(semaphore_t *a1, uint64_t a2)
{
  do
  {
    uint64_t result = semaphore_signal(*a1);
    if ((_DWORD)result == -301)
    {
      qword_E4D78 = (uint64_t)"MIG_REPLY_MISMATCH";
      qword_E4DA8 = -301LL;
      __break(1u);
      JUMPOUT(0xD77CLL);
    }

    if ((_DWORD)result == 15)
    {
      qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Use-after-free of dispatch_semaphore_t or dispatch_group_t";
      qword_E4DA8 = 15LL;
      __break(1u);
      JUMPOUT(0xD7D0LL);
    }

    if ((_DWORD)result)
    {
      qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: mach semaphore API failure";
      qword_E4DA8 = (int)result;
      __break(1u);
      JUMPOUT(0xD820LL);
    }

    --a2;
  }

  while (a2);
  return result;
}

uint64_t _dispatch_sema4_wait(semaphore_t *a1)
{
  do
    uint64_t result = semaphore_wait(*a1);
  while ((_DWORD)result == 14);
  if ((_DWORD)result == -301)
  {
    qword_E4D78 = (uint64_t)"MIG_REPLY_MISMATCH";
    qword_E4DA8 = -301LL;
    __break(1u);
    JUMPOUT(0xD8E4LL);
  }

  if ((_DWORD)result == 15)
  {
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Use-after-free of dispatch_semaphore_t or dispatch_group_t";
    qword_E4DA8 = 15LL;
    __break(1u);
    JUMPOUT(0xD938LL);
  }

  if ((_DWORD)result)
  {
    qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: mach semaphore API failure";
    qword_E4DA8 = (int)result;
    __break(1u);
    JUMPOUT(0xD988LL);
  }

  return result;
}

uint64_t _dispatch_sema4_timedwait( semaphore_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  kern_return_t v11;
  mach_timespec_t v12;
  do
  {
    unint64_t v10 = _dispatch_timeout(a2, a2, a3, a4, a5, a6, a7, a8);
    v12.tv_sec = v10 / 0x3B9ACA00;
    v12.tv_nsec = v10 % 0x3B9ACA00;
    mach_timespec_t v8 = v12;
    int v11 = semaphore_timedwait(*a1, v8);
  }

  while (v11 == 14);
  switch(v11)
  {
    case 49:
      return 1;
    case -301:
      qword_E4D78 = (uint64_t)"MIG_REPLY_MISMATCH";
      qword_E4DA8 = -301LL;
      __break(1u);
      JUMPOUT(0xDABCLL);
    case 15:
      qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Use-after-free of dispatch_semaphore_t or dispatch_group_t";
      qword_E4DA8 = 15LL;
      __break(1u);
      JUMPOUT(0xDB10LL);
    default:
      if (v11)
      {
        qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: mach semaphore API failure";
        qword_E4DA8 = v11;
        __break(1u);
        JUMPOUT(0xDB60LL);
      }

      return 0;
  }

uint64_t _dispatch_wait_on_address( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v24 = a2;
  int v22 = a4;
  unint64_t v20 = _dispatch_timeout(a3, a2, a3, a4, a5, a6, a7, a8);
  if (v20)
  {
    if (v20 == -1LL)
    {
      return _dispatch_ulock_wait(a1, v24, 0, v22);
    }

    else
    {
      do
      {
        if (v20 % 0x3E8) {
          unint64_t v17 = v20 / 0x3E8 + 1;
        }
        else {
          unint64_t v17 = v20 / 0x3E8;
        }
        uint64_t v19 = v17;
        if (v17 > 0xFFFFFFFF) {
          uint64_t v19 = 0xFFFFFFFFLL;
        }
        unsigned int v18 = _dispatch_ulock_wait(a1, v24, v19, v22);
        BOOL v16 = 0;
        if (v19 == 0xFFFFFFFFLL)
        {
          BOOL v16 = 0;
          if (v18 == 60)
          {
            unint64_t v20 = _dispatch_timeout(a3, v8, v9, v10, v11, v12, v13, v14);
            BOOL v16 = v20 != 0;
          }
        }
      }

      while (v16);
      return v18;
    }
  }

  else
  {
    return 60;
  }

uint64_t _dispatch_ulock_wait(uint64_t a1, unsigned int a2, unsigned int a3, int a4)
{
  return _dlock_wait(a1, a2, a3, a4 | 1u);
}

uint64_t _dispatch_wake_by_address(uint64_t a1)
{
  return _dispatch_ulock_wake(a1, 256);
}

uint64_t _dispatch_ulock_wake(uint64_t a1, int a2)
{
  return _dlock_wake(a1, a2 | 1u);
}

uint64_t _dispatch_thread_event_signal_slow(uint64_t a1)
{
  return _dispatch_ulock_wake(a1, 0);
}

BOOL _dispatch_thread_event_wait_slow(BOOL result)
{
  uint64_t v10 = (unsigned int *)result;
  while (1)
  {
    unsigned int v1 = atomic_load(v10);
    if (!v1) {
      break;
    }
    if (v1 != -1)
    {
      qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Corrupt thread event value";
      qword_E4DA8 = v1;
      __break(1u);
      JUMPOUT(0xDEA8LL);
    }

    int v9 = _dispatch_ulock_wait((uint64_t)v10, 0xFFFFFFFF, 0, 0);
    BOOL v8 = 1;
    if (v9)
    {
      BOOL v8 = 1;
      if (v9 != 14) {
        BOOL v8 = v9 == 4;
      }
    }

    uint64_t result = v8;
    if (!v8) {
      _dispatch_abort(559LL, v8, v2, v3, v4, v5, v6, v7);
    }
  }

  return result;
}

uint64_t _dispatch_unfair_lock_lock_slow(unsigned int *a1, int a2)
{
  unsigned int v8 = _dispatch_thread_getspecific(3uLL) & 0xFFFFFFFC;
  unsigned int v5 = v8;
  while (1)
  {
    do
    {
      if (_os_atomic_mo_has_acquire(2)) {
        uint64_t v2 = __ldaxr(a1);
      }
      else {
        uint64_t v2 = __ldxr(a1);
      }
      uint64_t result = v2;
      int v7 = v2;
      if ((v2 & 0xFFFFFFFC) != 0)
      {
        unsigned int v6 = v2 | 1;
        if ((v2 | 1) == (_DWORD)v2)
        {
          __clrex();
          break;
        }
      }

      else
      {
        unsigned int v6 = v5;
      }

      if (_os_atomic_mo_has_release(2))
      {
        uint64_t result = v6;
        BOOL v4 = __stlxr(v6, a1) == 0;
      }

      else
      {
        uint64_t result = v6;
        BOOL v4 = __stxr(v6, a1) == 0;
      }
    }

    while (!v4);
    if (((v7 ^ v8) & 0xFFFFFFFC) == 0)
    {
      qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: trying to lock recursively";
      __break(1u);
      JUMPOUT(0xE10CLL);
    }

    if (v6 == v5) {
      return result;
    }
  }

uint64_t _dispatch_unfair_lock_wait(uint64_t a1, unsigned int a2, unsigned int a3, int a4)
{
  return _dlock_wait(a1, a2, a3, a4 | 2u);
}

void *_dispatch_unfair_lock_unlock_slow(uint64_t a1, unsigned int a2)
{
  uint64_t result = _dispatch_thread_getspecific(3uLL);
  if (((a2 ^ result) & 0xFFFFFFFC) != 0)
  {
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: lock not owned by current thread";
    qword_E4DA8 = a2;
    __break(1u);
    JUMPOUT(0xE234LL);
  }

  if ((a2 & 1) != 0) {
    return (void *)_dispatch_unfair_lock_wake(a1, 0);
  }
  return result;
}

uint64_t _dispatch_unfair_lock_wake(uint64_t a1, int a2)
{
  return _dlock_wake(a1, a2 | 2u);
}

BOOL _dispatch_once_wait(unint64_t *a1)
{
  unsigned int v6 = _dispatch_thread_getspecific(3uLL) & 0xFFFFFFFC;
  while (1)
  {
    BOOL result = _os_atomic_mo_has_acquire(0);
    if (result) {
      unint64_t v2 = __ldaxr(a1);
    }
    else {
      unint64_t v2 = __ldxr(a1);
    }
    int v5 = v2;
    if (v2 == -1LL)
    {
      __clrex();
      return result;
    }

    if ((v2 & 3) == 2) {
      break;
    }
    uint64_t v4 = v2 | 1;
    if ((v2 | 1) == v2)
    {
      __clrex();
LABEL_16:
      if (((v5 ^ v6) & 0xFFFFFFFC) == 0)
      {
        qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: trying to lock recursively";
        __break(1u);
        JUMPOUT(0xE4D8LL);
      }

      _dispatch_unfair_lock_wait((uint64_t)a1, v4, 0, 0);
    }

    else
    {
      if (_os_atomic_mo_has_release(0)) {
        BOOL v3 = __stlxr(v4, a1) == 0;
      }
      else {
        BOOL v3 = __stxr(v4, a1) == 0;
      }
      if (v3) {
        goto LABEL_16;
      }
    }
  }

  __clrex();
  __dmb(9u);
  if (4LL * MEMORY[0xFFFFFC180] - v2 + 2 >= 0x10) {
    *a1 = -1LL;
  }
  return result;
}

uint64_t _dispatch_gate_broadcast_slow(uint64_t a1, unsigned int a2)
{
  if (((a2 ^ _dispatch_thread_getspecific(3uLL)) & 0xFFFFFFFC) != 0)
  {
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: lock not owned by current thread";
    qword_E4DA8 = a2;
    __break(1u);
    JUMPOUT(0xE588LL);
  }

  return _dispatch_unfair_lock_wake(a1, 256);
}

uint64_t _dispatch_firehose_gate_wait(uint64_t a1, unsigned int a2, int a3)
{
  return _dispatch_unfair_lock_wait(a1, a2, 0, a3);
}

uint64_t _dlock_wait(uint64_t a1, unsigned int a2, unsigned int a3, int a4)
{
  while (1)
  {
    int v6 = __ulock_wait(a4 | 0x1000000u, a1, a2, a3);
    if (v6 >= 1) {
      return 66;
    }
    int v5 = -v6;
    if (!v6) {
      return 0;
    }
    if (v5 != 4) {
      break;
    }
    if (a3) {
      return -v6;
    }
  }

  if (v5 != 14 && v5 != 60)
  {
    if (v5 != 105)
    {
      qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: ulock_wait() failed";
      qword_E4DA8 = -v6;
      __break(1u);
      JUMPOUT(0xE764LL);
    }

    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Owner in ulock is unknown - possible memory corruption";
    qword_E4DA8 = a2;
    __break(1u);
    JUMPOUT(0xE710LL);
  }

  return -v6;
}

uint64_t _dlock_wake(uint64_t a1, int a2)
{
  uint64_t result = __ulock_wake(a2 | 0x1000000u, a1, 0LL);
  if ((_DWORD)result && (_DWORD)result != -2)
  {
    qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: ulock_wake() failed";
    qword_E4DA8 = -(int)result;
    __break(1u);
    JUMPOUT(0xE820LL);
  }

  return result;
}

dispatch_semaphore_t dispatch_semaphore_create(intptr_t value)
{
  if (value < 0) {
    return 0LL;
  }
  int v7 = _dispatch_object_alloc((uint64_t)_OS_dispatch_semaphore_vtable, 0x48uLL, v1, v2, v3, v4, v5, v6);
  v7[2] = -1985229329LL;
  v7[3] = &off_E4640;
  v7[6] = value;
  *((_DWORD *)v7 + 16) = 0;
  v7[7] = value;
  return (dispatch_semaphore_t)v7;
}

semaphore_t *_dispatch_semaphore_dispose(semaphore_t *result)
{
  if (*((void *)result + 6) < *((void *)result + 7))
  {
    uint64_t v1 = *((void *)result + 7) - *((void *)result + 6);
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Semaphore object deallocated while in use (current value < original value)";
    qword_E4DA8 = v1;
    __break(1u);
    JUMPOUT(0xE95CLL);
  }

  if (result[16]) {
    return _dispatch_sema4_dispose_slow(result + 16, 0);
  }
  return result;
}

uint64_t _dispatch_semaphore_signal_slow(uint64_t a1)
{
  if (!*(_DWORD *)(a1 + 64)) {
    _dispatch_sema4_create_slow((unsigned int *)(a1 + 64), 0);
  }
  _dispatch_sema4_signal((semaphore_t *)(a1 + 64), 1LL);
  return 1LL;
}

intptr_t dispatch_semaphore_signal(dispatch_semaphore_t dsema)
{
  uint64_t v4 = (unint64_t *)((char *)dsema + 48);
  unint64_t v5 = *((void *)dsema + 6);
  do
  {
    unint64_t v1 = v5;
    do
      unint64_t v2 = __ldaxr(v4);
    while (v2 == v5 && __stlxr(v5 + 1, v4));
    unint64_t v5 = v2;
  }

  while (v2 != v1);
  if (v2 == 0x7FFFFFFFFFFFFFFFLL)
  {
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Unbalanced call to dispatch_semaphore_signal()";
    qword_E4DA8 = 0x8000000000000000LL;
    __break(1u);
    JUMPOUT(0xEB60LL);
  }

  return _dispatch_semaphore_signal_slow((uint64_t)dsema);
}

intptr_t dispatch_semaphore_wait(dispatch_semaphore_t dsema, dispatch_time_t timeout)
{
  uint64_t v11 = (unint64_t *)((char *)dsema + 48);
  unint64_t v12 = *((void *)dsema + 6);
  do
  {
    unint64_t v8 = v12;
    do
      unint64_t v9 = __ldaxr(v11);
    while (v9 == v12 && __stlxr(v12 - 1, v11));
    unint64_t v12 = v9;
  }

  while (v9 != v8);
  else {
    return 0LL;
  }
}

uint64_t _dispatch_semaphore_wait_slow( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!*(_DWORD *)(a1 + 64)) {
    _dispatch_sema4_create_slow((unsigned int *)(a1 + 64), 0);
  }
  if (a2 != -1)
  {
    if (a2 && (_dispatch_sema4_timedwait((semaphore_t *)(a1 + 64), a2, a3, a4, a5, a6, a7, a8) & 1) == 0) {
      return 0LL;
    }
    uint64_t v13 = *(void *)(a1 + 48);
    while (v13 < 0)
    {
      uint64_t v12 = v13;
      unint64_t v8 = (unint64_t *)(a1 + 48);
      do
        unint64_t v9 = __ldaxr(v8);
      while (v9 == v13 && __stlxr(v13 + 1, v8));
      BOOL v11 = v9 == v13;
      if (v9 != v13) {
        uint64_t v12 = v9;
      }
      uint64_t v13 = v12;
      if (v11) {
        return 49LL;
      }
    }
  }

  _dispatch_sema4_wait((semaphore_t *)(a1 + 64));
  return 0LL;
}

dispatch_group_t dispatch_group_create(void)
{
  uint64_t v7 = (dispatch_group_s *)_dispatch_object_alloc((uint64_t)_OS_dispatch_group_vtable, 0x48uLL, v0, v1, v2, v3, v4, v5);
  *((void *)v7 + 2) = -1985229329LL;
  *((void *)v7 + 3) = &off_E4640;
  return v7;
}

void *_dispatch_group_create_and_enter( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t v9 = _dispatch_object_alloc((uint64_t)_OS_dispatch_group_vtable, 0x48uLL, a3, a4, a5, a6, a7, a8);
  v9[2] = -1985229329LL;
  v9[3] = &off_E4640;
  *((_DWORD *)v9 + 12) = -4;
  _dispatch_retain((uint64_t)v9);
  return v9;
}

uint64_t _dispatch_group_dispose(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 48);
  if ((_DWORD)v1)
  {
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Group object deallocated while in use";
    qword_E4DA8 = v1;
    __break(1u);
    JUMPOUT(0xF06CLL);
  }

  return result;
}

intptr_t dispatch_group_wait(dispatch_group_t group, dispatch_time_t timeout)
{
  unint64_t v9 = (unint64_t *)((char *)group + 48);
  while (1)
  {
    if (_os_atomic_mo_has_acquire(0)) {
      unint64_t v7 = __ldaxr(v9);
    }
    else {
      unint64_t v7 = __ldxr(v9);
    }
    if ((v7 & 0xFFFFFFFC) == 0)
    {
      __dmb(9u);
      return 0LL;
    }

    if (!timeout)
    {
      __clrex();
      return 49LL;
    }

    unint64_t v11 = v7 | 1;
    if ((v7 & 1) != 0) {
      break;
    }
    if (_os_atomic_mo_has_release(0)) {
      BOOL v10 = __stlxr(v11, v9) == 0;
    }
    else {
      BOOL v10 = __stxr(v11, v9) == 0;
    }
    if (v10) {
      return _dispatch_group_wait_slow((uint64_t)group, HIDWORD(v11), timeout, v2, v3, v4, v5, v6);
    }
  }

  __clrex();
  return _dispatch_group_wait_slow((uint64_t)group, HIDWORD(v11), timeout, v2, v3, v4, v5, v6);
}

uint64_t _dispatch_group_wait_slow( uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  do
  {
    int v11 = _dispatch_wait_on_address(a1 + 52, a2, a3, 0LL, a5, a6, a7, a8);
    unsigned int v8 = a2;
    unsigned int v9 = atomic_load((unsigned int *)(a1 + 52));
    if (v8 != v9) {
      return 0LL;
    }
  }

  while (v11 != 60);
  return 49LL;
}

void dispatch_group_leave(dispatch_group_t group)
{
  uint64_t v6 = (unint64_t *)((char *)group + 48);
  unint64_t v7 = *((void *)group + 6);
  do
  {
    unint64_t v1 = v7;
    do
      unint64_t v2 = __ldaxr(v6);
    while (v2 == v7 && __stlxr(v7 + 4, v6));
    unint64_t v7 = v2;
  }

  while (v2 != v1);
  if ((v2 & 0xFFFFFFFC) == 0xFFFFFFFC)
  {
    unint64_t v9 = v2 + 4;
    do
    {
      if ((v9 & 0xFFFFFFFC) != 0) {
        unint64_t v10 = v9 & 0xFFFFFFFFFFFFFFFDLL;
      }
      else {
        unint64_t v10 = v9 & 0xFFFFFFFFFFFFFFFCLL;
      }
      if (v9 == v10) {
        break;
      }
      unint64_t v8 = v9;
      uint64_t v3 = (unint64_t *)((char *)group + 48);
      do
        unint64_t v4 = __ldaxr(v3);
      while (v4 == v9 && __stlxr(v10, v3));
      BOOL v5 = v4 == v9;
      if (v4 != v9) {
        unint64_t v8 = v4;
      }
      unint64_t v9 = v8;
    }

    while (!v5);
    _dispatch_group_wake((uint64_t)group, v9, 1);
  }

  else if ((v2 & 0xFFFFFFFC) == 0)
  {
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Unbalanced call to dispatch_group_leave()";
    qword_E4DA8 = 0LL;
    __break(1u);
    JUMPOUT(0xF548LL);
  }

void _dispatch_group_wake(uint64_t a1, char a2, char a3)
{
  unsigned __int16 v16 = (a3 & 1) != 0;
  if ((a2 & 2) != 0)
  {
    uint64_t v13 = *(void *)(a1 + 56);
    if (!v13) {
      uint64_t v13 = _dispatch_wait_for_enqueuer((unint64_t *)(a1 + 56), a1 + 64);
    }
    *(void *)(a1 + 56) = 0LL;
    unint64_t v8 = (unint64_t *)(a1 + 64);
    unint64_t v9 = *(void *)(a1 + 64);
    do
    {
      unint64_t v3 = v9;
      do
        unint64_t v4 = __ldaxr(v8);
      while (v4 == v9 && __stlxr(0LL, v8));
      unint64_t v9 = v4;
    }

    while (v4 != v3);
    unint64_t v14 = v4 & 0xFFFFFFFFFFFFFFF8LL;
    uint64_t v15 = (void *)v13;
    do
    {
      uint64_t v12 = (unsigned int *)v15[6];
      int v11 = 0LL;
      if (v15 != (void *)v14)
      {
        uint64_t v10 = v15[2];
        if (!v10) {
          uint64_t v10 = _dispatch_wait_for_enqueuer(v15 + 2, 0LL);
        }
        int v11 = (void *)v10;
      }

      unsigned int v5 = (v15[1] & 0x3FFF00uLL) >> 8;
      unsigned int v6 = __clz(__rbit32(v5));
      if (v5) {
        unsigned int v7 = v6 + 1;
      }
      else {
        unsigned int v7 = 0;
      }
      (*(void (**)(unsigned int *, void *, void))(*(void *)v12 + 72LL))(v12, v15, v7);
      _dispatch_release(v12);
      uint64_t v15 = v11;
    }

    while (v11);
    ++v16;
  }

  if ((a2 & 1) != 0) {
    _dispatch_wake_by_address(a1 + 52);
  }
  if (v16) {
    _dispatch_release_n((unsigned int *)a1, v16);
  }
}

void dispatch_group_enter(dispatch_group_t group)
{
  unint64_t v4 = (unsigned int *)((char *)group + 48);
  unsigned int v5 = *((_DWORD *)group + 12);
  do
  {
    unsigned int v1 = v5;
    do
      unsigned int v2 = __ldaxr(v4);
    while (v2 == v5 && __stlxr(v5 - 4, v4));
    unsigned int v3 = v2;
    unsigned int v5 = v2;
  }

  while (v2 != v1);
  unsigned int v6 = v2 & 0xFFFFFFFC;
  if ((v2 & 0xFFFFFFFC) == 0) {
    _dispatch_retain((uint64_t)group);
  }
  if (v6 == 4)
  {
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Too many nested calls to dispatch_group_enter()";
    qword_E4DA8 = v3;
    __break(1u);
    JUMPOUT(0xFA74LL);
  }

void dispatch_group_notify_f( dispatch_group_t group, dispatch_queue_t queue, void *context, dispatch_function_t work)
{
  int v26 = _dispatch_thread_getspecific(0x16uLL);
  if (v26)
  {
    _dispatch_thread_setspecific(22LL, v26[2]);
    uint64_t v21 = v26;
  }

  else
  {
    uint64_t v21 = (void *)_dispatch_continuation_alloc_from_heap();
  }

  *uint64_t v21 = 260LL;
  v21[4] = work;
  v21[5] = context;
  unint64_t v28 = (unint64_t)_dispatch_thread_getspecific(4uLL) & 0xFFFFFF;
  if (v28 <= 0x10FF) {
    uint64_t v29 = v28;
  }
  else {
    uint64_t v29 = 4351LL;
  }
  uint64_t v30 = _dispatch_thread_getspecific(0x1CuLL);
  if (v30) {
    os_retain(v30);
  }
  v21[3] = v30;
  _dispatch_thread_getspecific(0LL);
  _dispatch_log("%u\t%p\tvoucher[%p]: continuation[%p] set", v4, v5, v6, v7, v8, v9, v10, 589LL);
  uint64_t v31 = v21[3];
  if (v31 != -1)
  {
    unsigned int v16 = v31 ? *(_DWORD *)(v31 + 32) : 0;
    if (MEMORY[0xFFFFFC100]) {
      kdebug_trace(771817476LL, v16, v21, 0LL, 0LL);
    }
  }

  uint64_t v27 = v29;
  if (v29 && (*((_DWORD *)queue + 21) & 0x40000000) == 0 && (*((_DWORD *)queue + 21) & 0xFFF) != 0) {
    uint64_t v27 = 0LL;
  }
  v21[1] = v27;
  v21[6] = queue;
  _dispatch_retain((uint64_t)queue);
  v21[2] = 0LL;
  _dispatch_thread_setspecific(122LL, (uint64_t)group + 64);
  unint64_t v14 = (unint64_t *)((char *)group + 64);
  unint64_t v15 = *((void *)group + 8);
  do
  {
    unint64_t v11 = v15;
    do
      unint64_t v12 = __ldaxr(v14);
    while (v12 == v15 && __stlxr((unint64_t)v21, v14));
    unint64_t v15 = v12;
  }

  while (v12 != v11);
  unint64_t v24 = v12;
  if (!v12) {
    _dispatch_retain((uint64_t)group);
  }
  if (v24) {
    *(void *)(v24 + 16) = v21;
  }
  else {
    *((void *)group + 7) = v21;
  }
  _dispatch_thread_setspecific(122LL, 0LL);
  if (!v24)
  {
    int v22 = (unint64_t *)((char *)group + 48);
    while (1)
    {
      unint64_t v13 = _os_atomic_mo_has_acquire(3) ? __ldaxr(v22) : __ldxr(v22);
      uint64_t v25 = v13 | 2;
      if (!(_DWORD)v13) {
        break;
      }
      if (_os_atomic_mo_has_release(3)) {
        BOOL v23 = __stlxr(v25, v22) == 0;
      }
      else {
        BOOL v23 = __stxr(v25, v22) == 0;
      }
      if (v23) {
        return;
      }
    }

    __clrex();
    _dispatch_group_wake((uint64_t)group, v25, 0);
  }

void dispatch_group_notify(dispatch_group_t group, dispatch_queue_t queue, dispatch_block_t block)
{
  uint64_t v25 = (uint64_t *)_dispatch_thread_getspecific(0x16uLL);
  if (v25)
  {
    _dispatch_thread_setspecific(22LL, v25[2]);
    uint64_t v19 = v25;
  }

  else
  {
    uint64_t v19 = (uint64_t *)_dispatch_continuation_alloc_from_heap();
  }

  unint64_t v24 = _dispatch_Block_copy(block);
  if ((void (*)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))_Block_get_invoke_fn((uint64_t)block) == ___dispatch_block_create_block_invoke)
  {
    *uint64_t v19 = 276LL;
    v19[5] = (uint64_t)v24;
    _dispatch_continuation_init_slow(v19, (unsigned int *)queue, 0);
  }

  else
  {
    _Block_get_invoke_fn((uint64_t)block);
    *uint64_t v19 = 276LL;
    v19[4] = (uint64_t)_dispatch_call_block_and_release;
    v19[5] = (uint64_t)v24;
    unint64_t v27 = (unint64_t)_dispatch_thread_getspecific(4uLL) & 0xFFFFFF;
    if (v27 <= 0x10FF) {
      uint64_t v28 = v27;
    }
    else {
      uint64_t v28 = 4351LL;
    }
    uint64_t v29 = _dispatch_thread_getspecific(0x1CuLL);
    if (v29) {
      os_retain(v29);
    }
    v19[3] = (uint64_t)v29;
    _dispatch_thread_getspecific(0LL);
    _dispatch_log("%u\t%p\tvoucher[%p]: continuation[%p] set", v3, v4, v5, v6, v7, v8, v9, 589LL);
    uint64_t v30 = v19[3];
    if (v30 != -1)
    {
      unsigned int v15 = v30 ? *(_DWORD *)(v30 + 32) : 0;
      if (MEMORY[0xFFFFFC100]) {
        kdebug_trace(771817476LL, v15, v19, 0LL, 0LL);
      }
    }

    uint64_t v26 = v28;
    if (v28 && (*((_DWORD *)queue + 21) & 0x40000000) == 0 && (*((_DWORD *)queue + 21) & 0xFFF) != 0) {
      uint64_t v26 = 0LL;
    }
    v19[1] = v26;
  }

  v19[6] = (uint64_t)queue;
  _dispatch_retain((uint64_t)queue);
  v19[2] = 0LL;
  _dispatch_thread_setspecific(122LL, (uint64_t)group + 64);
  unint64_t v13 = (unint64_t *)((char *)group + 64);
  unint64_t v14 = *((void *)group + 8);
  do
  {
    unint64_t v10 = v14;
    do
      unint64_t v11 = __ldaxr(v13);
    while (v11 == v14 && __stlxr((unint64_t)v19, v13));
    unint64_t v14 = v11;
  }

  while (v11 != v10);
  unint64_t v22 = v11;
  if (!v11) {
    _dispatch_retain((uint64_t)group);
  }
  if (v22) {
    *(void *)(v22 + 16) = v19;
  }
  else {
    *((void *)group + 7) = v19;
  }
  _dispatch_thread_setspecific(122LL, 0LL);
  if (!v22)
  {
    unint64_t v20 = (unint64_t *)((char *)group + 48);
    while (1)
    {
      unint64_t v12 = _os_atomic_mo_has_acquire(3) ? __ldaxr(v20) : __ldxr(v20);
      uint64_t v23 = v12 | 2;
      if (!(_DWORD)v12) {
        break;
      }
      if (_os_atomic_mo_has_release(3)) {
        BOOL v21 = __stlxr(v23, v20) == 0;
      }
      else {
        BOOL v21 = __stxr(v23, v20) == 0;
      }
      if (v21) {
        return;
      }
    }

    __clrex();
    _dispatch_group_wake((uint64_t)group, v23, 0);
  }

void dispatch_group_async_f( dispatch_group_t group, dispatch_queue_t queue, void *context, dispatch_function_t work)
{
  unint64_t v20 = _dispatch_thread_getspecific(0x16uLL);
  if (v20)
  {
    _dispatch_thread_setspecific(22LL, v20[2]);
    uint64_t v19 = v20;
  }

  else
  {
    uint64_t v19 = (void *)_dispatch_continuation_alloc_from_heap();
  }

  *uint64_t v19 = 268LL;
  v19[4] = work;
  v19[5] = context;
  unint64_t v23 = (unint64_t)_dispatch_thread_getspecific(4uLL) & 0xFFFFFF;
  if (v23 <= 0x10FF) {
    unint64_t v24 = v23;
  }
  else {
    unint64_t v24 = 4351LL;
  }
  uint64_t v25 = _dispatch_thread_getspecific(0x1CuLL);
  if (v25) {
    os_retain(v25);
  }
  v19[3] = v25;
  _dispatch_thread_getspecific(0LL);
  _dispatch_log("%u\t%p\tvoucher[%p]: continuation[%p] set", v4, v5, v6, v7, v8, v9, v10, 589LL);
  uint64_t v26 = v19[3];
  if (v26 != -1)
  {
    unsigned int v14 = v26 ? *(_DWORD *)(v26 + 32) : 0;
    if (MEMORY[0xFFFFFC100]) {
      kdebug_trace(771817476LL, v14, v19, 0LL, 0LL);
    }
  }

  unint64_t v22 = v24;
  unsigned int v21 = 0;
  if (v24)
  {
    if ((*((_DWORD *)queue + 21) & 0x40000000) != 0 || (*((_DWORD *)queue + 21) & 0xFFF) == 0)
    {
      unsigned int v11 = v24 >> 8;
      unsigned int v12 = __clz(__rbit32(v11));
      if (v11) {
        unsigned int v13 = v12 + 1;
      }
      else {
        unsigned int v13 = 0;
      }
      unsigned int v21 = v13;
    }

    else
    {
      unint64_t v22 = 0LL;
    }
  }

  v19[1] = v22;
  dispatch_group_enter(group);
  v19[6] = group;
  (*(void (**)(dispatch_queue_t, void *, void))(*(void *)queue + 72LL))(queue, v19, v21);
}

void dispatch_group_async(dispatch_group_t group, dispatch_queue_t queue, dispatch_block_t block)
{
  unint64_t v20 = (uint64_t *)_dispatch_thread_getspecific(0x16uLL);
  if (v20)
  {
    _dispatch_thread_setspecific(22LL, v20[2]);
    unint64_t v17 = v20;
  }

  else
  {
    unint64_t v17 = (uint64_t *)_dispatch_continuation_alloc_from_heap();
  }

  unsigned int v18 = _dispatch_Block_copy(block);
  if ((void (*)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))_Block_get_invoke_fn((uint64_t)block) == ___dispatch_block_create_block_invoke)
  {
    *unint64_t v17 = 284LL;
    v17[5] = (uint64_t)v18;
    unsigned int inited = _dispatch_continuation_init_slow(v17, (unsigned int *)queue, 0);
  }

  else
  {
    _Block_get_invoke_fn((uint64_t)block);
    *unint64_t v17 = 284LL;
    v17[4] = (uint64_t)_dispatch_call_block_and_release;
    v17[5] = (uint64_t)v18;
    unint64_t v23 = (unint64_t)_dispatch_thread_getspecific(4uLL) & 0xFFFFFF;
    if (v23 <= 0x10FF) {
      unint64_t v24 = v23;
    }
    else {
      unint64_t v24 = 4351LL;
    }
    uint64_t v25 = _dispatch_thread_getspecific(0x1CuLL);
    if (v25) {
      os_retain(v25);
    }
    v17[3] = (uint64_t)v25;
    _dispatch_thread_getspecific(0LL);
    _dispatch_log("%u\t%p\tvoucher[%p]: continuation[%p] set", v3, v4, v5, v6, v7, v8, v9, 589LL);
    uint64_t v26 = v17[3];
    if (v26 != -1)
    {
      unsigned int v13 = v26 ? *(_DWORD *)(v26 + 32) : 0;
      if (MEMORY[0xFFFFFC100]) {
        kdebug_trace(771817476LL, v13, v17, 0LL, 0LL);
      }
    }

    unint64_t v22 = v24;
    unsigned int v21 = 0;
    if (v24)
    {
      if ((*((_DWORD *)queue + 21) & 0x40000000) != 0 || (*((_DWORD *)queue + 21) & 0xFFF) == 0)
      {
        unsigned int v10 = v24 >> 8;
        unsigned int v11 = __clz(__rbit32(v10));
        if (v10) {
          unsigned int v12 = v11 + 1;
        }
        else {
          unsigned int v12 = 0;
        }
        unsigned int v21 = v12;
      }

      else
      {
        unint64_t v22 = 0LL;
      }
    }

    v17[1] = v22;
    unsigned int inited = v21;
  }

  dispatch_group_enter(group);
  v17[6] = (uint64_t)group;
  (*(void (**)(dispatch_queue_t, uint64_t *, void))(*(void *)queue + 72LL))(queue, v17, inited);
}

void _dispatch_release_n(unsigned int *a1, int a2)
{
  int v7 = a1[2];
  if (v7 != 0x7FFFFFFF)
  {
    uint64_t v4 = a1 + 2;
    unsigned int v5 = a1[2];
    do
    {
      unsigned int v2 = v5;
      do
        unsigned int v3 = __ldaxr(v4);
      while (v3 == v5 && __stlxr(v5 - a2, v4));
      unsigned int v5 = v3;
    }

    while (v3 != v2);
    int v7 = v3 - a2;
  }

  if (v7 < 1)
  {
    if (v7 < 0)
    {
      qword_E4D78 = (uint64_t)"API MISUSE: Over-release of an object";
      __break(1u);
      JUMPOUT(0x11BB0LL);
    }

    int v6 = a1[3];
    if (v6 >= 1)
    {
      qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: Release while external references exist";
      qword_E4DA8 = v6;
      __break(1u);
      JUMPOUT(0x11C10LL);
    }

    _os_object_dispose(a1);
  }

void dispatch_once(dispatch_once_t *predicate, dispatch_block_t block)
{
  unsigned int v2 = (void (__cdecl *)(void *))_Block_get_invoke_fn((uint64_t)block);
  dispatch_once_f(predicate, block, v2);
}

void dispatch_once_f(dispatch_once_t *predicate, void *context, dispatch_function_t function)
{
  unint64_t v3 = atomic_load((unint64_t *)predicate);
  if (v3 != -1LL)
  {
    if ((v3 & 3) == 2)
    {
      if (4LL * MEMORY[0xFFFFFC180] + 2 - v3 >= 0x10) {
        *predicate = -1LL;
      }
    }

    else
    {
      unsigned int v4 = _dispatch_thread_getspecific(3uLL);
      do
        unint64_t v5 = __ldaxr((unint64_t *)predicate);
      while (!v5 && __stlxr(v4 & 0xFFFFFFFC, (unint64_t *)predicate));
      if (v5) {
        _dispatch_once_wait((unint64_t *)predicate);
      }
      else {
        _dispatch_once_callout( (unint64_t *)predicate,  (uint64_t)context,  (void (*)(void (**)(void)))function);
      }
    }
  }

uint64_t _dispatch_once_callout(unint64_t *a1, uint64_t a2, void (*a3)(void (**a1)(void)))
{
  if (a3 == _dispatch_call_block_and_release && a2) {
    _Block_get_invoke_fn(a2);
  }
  _dispatch_client_callout(a2, (uint64_t (*)(uint64_t))a3);
  uint64_t result = (uint64_t)_dispatch_thread_getspecific(3uLL);
  unint64_t v6 = 4LL * MEMORY[0xFFFFFC180] + 2;
  unint64_t v7 = *a1;
  do
  {
    unint64_t v4 = v7;
    do
      unint64_t v5 = __ldaxr(a1);
    while (v5 == v7 && __stlxr(v6, a1));
    unint64_t v7 = v5;
  }

  while (v5 != v4);
  if ((_DWORD)v5 != (result & 0xFFFFFFFC)) {
    return _dispatch_gate_broadcast_slow((uint64_t)a1, v5);
  }
  return result;
}

void dispatch_assert_queue_V2(dispatch_queue_t queue)
{
  uint64_t v6 = *(unsigned __int8 *)(*(void *)queue + 16LL);
  BOOL v5 = 0;
  if (v6 != 17) {
    BOOL v5 = v6 != 18;
  }
  if (v5)
  {
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: invalid queue passed to dispatch_assert_queue()";
    qword_E4DA8 = v6;
    __break(1u);
    JUMPOUT(0x1220CLL);
  }

  int v12 = *((void *)queue + 7);
  if (((v12 ^ _dispatch_thread_getspecific(3uLL)) & 0xFFFFFFFC) != 0)
  {
    dispatch_queue_t v10 = queue;
    uint64_t v9 = 0LL;
    dispatch_queue_t v8 = 0LL;
    unsigned int v13 = (void **)&v8;
    _dispatch_thread_getspecific_pair(0x14uLL, (void **)&v8, 0x15uLL, (pthread_key_t *)&v9, v1, v2, v3, v4);
    while (v8)
    {
      if (v8 == v10)
      {
        char v11 = 1;
        goto LABEL_18;
      }

      unint64_t v17 = (void **)&v8;
      unsigned int v16 = v9;
      unsigned int v15 = v8;
      if (v9)
      {
        unsigned int v14 = 0LL;
        unsigned int v14 = (void *)*((void *)v15 + 3);
        if (v14)
        {
          *unint64_t v17 = v14;
          if (v15 == *v16) {
            v17[1] = v16[1];
          }
        }

        else
        {
          *unint64_t v17 = *v16;
          v17[1] = v16[1];
        }
      }

      else
      {
        *unint64_t v17 = (void *)*((void *)v15 + 3);
      }
    }

    char v11 = 0;
LABEL_18:
    if (!v11) {
      _dispatch_assert_queue_fail(queue, 1);
    }
  }

void _dispatch_assert_queue_fail(void *a1, char a2)
{
  unsigned int v14 = a1;
  char v13 = a2 & 1;
  int v12 = 0LL;
  uint64_t v2 = "";
  if ((a2 & 1) == 0) {
    uint64_t v2 = "not ";
  }
  dispatch_queue_t v10 = (const char *)v14[9];
  if (v10) {
    asprintf( &v12,  "%sBlock was %sexpected to execute on queue [%s (%p)]",  "BUG IN CLIENT OF LIBDISPATCH: Assertion failed: ",  v2,  v10,  v14);
  }
  else {
    asprintf( &v12,  "%sBlock was %sexpected to execute on queue [%s (%p)]",  "BUG IN CLIENT OF LIBDISPATCH: Assertion failed: ",  v2,  "",  v14);
  }
  char v11 = v12;
  _dispatch_log("%s", v3, v4, v5, v6, v7, v8, v9, (uint64_t)v12);
  qword_E4D78 = (uint64_t)v11;
  __break(1u);
}

void sub_124F8()
{
}

void dispatch_assert_queue_not_V2(dispatch_queue_t queue)
{
  uint64_t v6 = *(unsigned __int8 *)(*(void *)queue + 16LL);
  BOOL v5 = 0;
  if (v6 != 17) {
    BOOL v5 = v6 != 18;
  }
  if (v5)
  {
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: invalid queue passed to dispatch_assert_queue_not()";
    qword_E4DA8 = v6;
    __break(1u);
    JUMPOUT(0x125A8LL);
  }

  int v12 = *((void *)queue + 7);
  dispatch_queue_t v10 = queue;
  uint64_t v9 = 0LL;
  dispatch_queue_t v8 = 0LL;
  char v13 = (void **)&v8;
  _dispatch_thread_getspecific_pair(0x14uLL, (void **)&v8, 0x15uLL, (pthread_key_t *)&v9, v1, v2, v3, v4);
  while (v8)
  {
    if (v8 == v10)
    {
      char v11 = 1;
      goto LABEL_19;
    }

    unint64_t v17 = (void **)&v8;
    unsigned int v16 = v9;
    unsigned int v15 = v8;
    if (v9)
    {
      unsigned int v14 = 0LL;
      unsigned int v14 = (void *)*((void *)v15 + 3);
      if (v14)
      {
        *unint64_t v17 = v14;
        if (v15 == *v16) {
          v17[1] = v16[1];
        }
      }

      else
      {
        *unint64_t v17 = *v16;
        v17[1] = v16[1];
      }
    }

    else
    {
      *unint64_t v17 = (void *)*((void *)v15 + 3);
    }
  }

  char v11 = 0;
LABEL_19:
  if (v11) {
    _dispatch_assert_queue_fail(queue, 0);
  }
}

void dispatch_assert_queue_barrier(dispatch_queue_t queue)
{
  if (*((_WORD *)queue + 40) != 1 && (!*((void *)queue + 3) || (*((void *)queue + 7) & 0x40000000000000LL) == 0)) {
    _dispatch_assert_queue_barrier_fail(queue);
  }
}

void _dispatch_assert_queue_barrier_fail(void *a1)
{
  char v11 = a1;
  dispatch_queue_t v10 = 0LL;
  dispatch_queue_t v8 = (const char *)a1[9];
  if (v8) {
    asprintf( &v10,  "%sBlock was expected to act as a barrier on queue [%s (%p)]",  "BUG IN CLIENT OF LIBDISPATCH: Assertion failed: ",  v8,  v11);
  }
  else {
    asprintf( &v10,  "%sBlock was expected to act as a barrier on queue [%s (%p)]",  "BUG IN CLIENT OF LIBDISPATCH: Assertion failed: ",  "",  v11);
  }
  uint64_t v9 = v10;
  _dispatch_log("%s", v1, v2, v3, v4, v5, v6, v7, (uint64_t)v10);
  qword_E4D78 = (uint64_t)v9;
  __break(1u);
}

void sub_1293C()
{
}

uint64_t dispatch_allow_send_signals(unsigned int a1)
{
  return _pthread_workqueue_allow_send_signals(a1);
}

void _dispatch_set_priority_and_mach_voucher_slow(uint64_t a1, unsigned int a2)
{
  uint64_t v14 = a1;
  unsigned int v12 = 0;
  if (a1)
  {
    if ((_dispatch_set_qos_class_enabled & 1) != 0)
    {
      uint64_t v11 = (uint64_t)_dispatch_thread_getspecific(4uLL);
      if (v14 != v11)
      {
        if ((v11 & 0x1000000) != 0)
        {
          unsigned int v12 = 16;
          v14 |= (unint64_t)_dispatch_thread_getspecific(0x19uLL) & 0x80000000;
        }

        else
        {
          v14 |= v11 & 0x88000000;
        }

        if ((v11 & 0xFFFFFF) != 0) {
          v12 |= 1u;
        }
        int v8 = qword_E4178;
        if (((v8 ^ _dispatch_thread_getspecific(3uLL)) & 0xFFFFFFFC) == 0)
        {
          qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: Changing the QoS while on the manager queue";
          qword_E4DA8 = v14;
          __break(1u);
          JUMPOUT(0x12B74LL);
        }

        if (((BYTE3(v14) >> 1) & 1) != 0)
        {
          qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: Cannot raise oneself to manager";
          qword_E4DA8 = v14;
          __break(1u);
          JUMPOUT(0x12BC8LL);
        }

        if ((v11 & 0x2000000) != 0)
        {
          qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: Cannot turn a manager thread into a normal one";
          qword_E4DA8 = v11;
          __break(1u);
          JUMPOUT(0x12C18LL);
        }
      }
    }
  }

  if (a2 != -1) {
    v12 |= 2u;
  }
  dispatch_queue_t v10 = _dispatch_thread_getspecific(0x1DuLL);
  if (v10 && (v10[45] & 2) != 0) {
    _dispatch_event_loop_drain(1u);
  }
  if (v12)
  {
    int v9 = _pthread_set_properties_self(v12, v14, a2);
    if (v9 == 22)
    {
      qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: _pthread_set_properties_self failed";
      qword_E4DA8 = v14;
      __break(1u);
      JUMPOUT(0x12D00LL);
    }

    if (v9) {
      _dispatch_bug(206LL, v9, v2, v3, v4, v5, v6, v7);
    }
  }

uint64_t _dispatch_set_priority_and_voucher_slow(uint64_t a1, _DWORD *a2, char a3)
{
  uint64_t v16 = -1LL;
  unsigned int v15 = -1;
  if (a2 != (_DWORD *)-1LL)
  {
    BOOL v14 = (a3 & 4) != 0;
    uint64_t v16 = (uint64_t)_dispatch_thread_getspecific(0x1CuLL);
    if ((_DWORD *)v16 == a2 && (a3 & 2) != 0)
    {
      if (v14 && a2) {
        os_release(a2);
      }
      uint64_t v16 = -1LL;
    }

    else
    {
      if (!v14 && a2) {
        os_retain(a2);
      }
      if ((_DWORD *)v16 == a2)
      {
        int v20 = -1;
      }

      else
      {
        _dispatch_thread_setspecific(28LL, (uint64_t)a2);
        _dispatch_thread_getspecific(0LL);
        _dispatch_log("%u\t%p\tvoucher[%p]: swap from voucher[%p]", v3, v4, v5, v6, v7, v8, v9, 400LL);
        if (a2) {
          int v13 = a2[8];
        }
        else {
          int v13 = 0;
        }
        if (v16) {
          int v12 = *(_DWORD *)(v16 + 32);
        }
        else {
          int v12 = 0;
        }
        if (v13 == v12) {
          int v11 = -1;
        }
        else {
          int v11 = v13;
        }
        int v20 = v11;
      }

      unsigned int v15 = v20;
    }
  }

  if ((a3 & 8) == 0) {
    _dispatch_set_priority_and_mach_voucher_slow(a1, v15);
  }
  if (v16 != -1 && (a3 & 2) != 0)
  {
    if (v16) {
      os_release((void *)v16);
    }
    return -1LL;
  }

  return v16;
}

void _dispatch_async_redirect_invoke(void *a1, uint64_t a2, unsigned int a3)
{
  uint64_t v57 = a1;
  uint64_t v56 = a2;
  unsigned int v55 = a3;
  __int128 v54 = 0uLL;
  unsigned int v53 = (void *)a1[7];
  int v52 = a1[5];
  uint64_t v51 = a1[4];
  uint64_t v50 = a1[6];
  if (v52) {
    unsigned int v55 = v55 & 0xFCFFFFFF | v52;
  }
  uint64_t v48 = _dispatch_thread_getspecific(0x14uLL);
  if (v51)
  {
    uint64_t v127 = v51;
    unsigned int v126 = _dispatch_thread_getspecific(0x19uLL);
    uint64_t v129 = *(void *)(*(void *)v51 + 16LL) & 0x10000LL;
    uint64_t v128 = 1946LL;
    if (!v129) {
      _dispatch_abort(v128, 0LL, v3, v4, v5, v6, v7, v8);
    }
    unsigned int v149 = *(_DWORD *)(v127 + 84);
    unsigned int v148 = _dispatch_thread_getspecific(0x19uLL);
    unsigned int v149 = v149 & 0xFFF0FFFF | v148 & 0xF0000;
    _dispatch_thread_setspecific(25LL, v149);
    uint64_t v125 = v127;
    uint64_t v130 = v127;
    _dispatch_thread_setspecific(20LL, v127);
    unsigned int v47 = v126;
    int v140 = *(_DWORD *)(v50 + 84);
    unsigned int v139 = _dispatch_thread_getspecific(0x19uLL);
    unsigned int v138 = v139;
    if (v139)
    {
      if ((v140 & 0xFFF) != 0)
      {
        v138 &= 0x880F0000;
        if ((v139 & 0xFFF) <= (v140 & 0xFFFu)) {
          int v44 = v140 & 0xFFF;
        }
        else {
          int v44 = v139 & 0xFFF;
        }
        v138 |= v44;
        unsigned int v142 = v140 & 0xF000;
        unsigned int v144 = v138 & 0xF00;
        if (v142 >> 12 <= v144 >> 8) {
          v140 &= 0x40000000u;
        }
        else {
          v140 &= 0x4400F000u;
        }
        v138 |= v140;
      }

      else
      {
        if ((v138 & 0xFFF) != 0) {
          v138 |= 0x40000000u;
        }
        unsigned int v141 = v140 & 0xF000;
        unsigned int v143 = v138 & 0xF00;
        if (v141 >> 12 > v143 >> 8) {
          unsigned int v138 = v138 & 0xFFFF0FFF | v140 & 0x400F000;
        }
      }
    }

    else
    {
      unsigned int v138 = v140 & 0xFFF0FFFF;
    }

    _dispatch_thread_setspecific(25LL, v138);
  }

  else
  {
    int v133 = *(_DWORD *)(v50 + 84);
    unsigned int v132 = _dispatch_thread_getspecific(0x19uLL);
    unsigned int v131 = v132;
    if (v132)
    {
      if ((v133 & 0xFFF) != 0)
      {
        v131 &= 0x880F0000;
        if ((v132 & 0xFFF) <= (v133 & 0xFFFu)) {
          int v43 = v133 & 0xFFF;
        }
        else {
          int v43 = v132 & 0xFFF;
        }
        v131 |= v43;
        unsigned int v135 = v133 & 0xF000;
        unsigned int v137 = v131 & 0xF00;
        if (v135 >> 12 <= v137 >> 8) {
          v133 &= 0x40000000u;
        }
        else {
          v133 &= 0x4400F000u;
        }
        v131 |= v133;
      }

      else
      {
        if ((v131 & 0xFFF) != 0) {
          v131 |= 0x40000000u;
        }
        unsigned int v134 = v133 & 0xF000;
        unsigned int v136 = v131 & 0xF00;
        if (v134 >> 12 > v136 >> 8) {
          unsigned int v131 = v131 & 0xFFFF0FFF | v133 & 0x400F000;
        }
      }
    }

    else
    {
      unsigned int v131 = v133 & 0xFFF0FFFF;
    }

    _dispatch_thread_setspecific(25LL, v131);
    unsigned int v47 = v132;
  }

  uint64_t v146 = v50;
  v145 = &v54;
  v152 = &v54;
  _dispatch_thread_getspecific_packed_pair(20LL, 21LL, &v54, v9, v10, v11, v12, v13);
  _dispatch_thread_setspecific_pair(20LL, v146, 21LL, (uint64_t)v145, v14, v15, v16, v17);
  uint64_t v46 = (uint64_t)v57;
  uint64_t v63 = v57;
  uint64_t v62 = 516LL;
  uint64_t v61 = 0LL;
  uint64_t v61 = (_DWORD *)v57[3];
  uint64_t v60 = 4LL;
  uint64_t v85 = 1LL;
  uint64_t v84 = 600LL;
  v63[3] = -1LL;
  if (v61 != (_DWORD *)-1LL)
  {
    int v78 = 771817480;
    v77 = v61;
    v76 = v63;
    unsigned int v75 = 0;
    if (v61) {
      unsigned int v42 = v77[8];
    }
    else {
      unsigned int v42 = 0;
    }
    unsigned int v75 = v42;
    unsigned int v83 = v78;
    uint64_t v82 = v42;
    v81 = v76;
    uint64_t v80 = 0LL;
    uint64_t v79 = 0LL;
    if (MEMORY[0xFFFFFC100]) {
      kdebug_trace(v83, v82, v81, v80, v79);
    }
    _dispatch_thread_getspecific(0LL);
    _dispatch_log("%u\t%p\tvoucher[%p]: continuation[%p] adopt", v24, v25, v26, v27, v28, v29, v30, 607LL);
  }

  unint64_t v67 = v63[1];
  uint64_t v66 = (uint64_t)v61;
  uint64_t v65 = v60 | 2;
  uint64_t v64 = 0LL;
  if (v67 != -1LL)
  {
    unint64_t v114 = v67;
    uint64_t v113 = v65;
    unsigned int v112 = 0;
    unsigned int v112 = _dispatch_thread_getspecific(0x19uLL);
    uint64_t v111 = 0LL;
    unsigned int v120 = v112;
    unsigned int v121 = v112 & 0xF00;
    unsigned int v119 = v121 >> 8;
    uint64_t v118 = v112;
    if (v121 >> 8) {
      v118 |= 1LL << (v119 + 7);
    }
    uint64_t v111 = v118;
    uint64_t v122 = v118;
    unint64_t v110 = v118 & 0xFFFFFF00;
    BOOL v109 = 0;
    BOOL v41 = 1;
    if ((v113 & 1) == 0) {
      BOOL v41 = (v114 & 0x10000000) != 0;
    }
    BOOL v109 = v41;
    unint64_t v116 = v114;
    v114 &= 0xFFFFFFu;
    if (v114)
    {
      if (v114 >= v110)
      {
        if (v109 || (v112 & 0x44000000) != 0) {
          uint64_t v115 = v114;
        }
        else {
          uint64_t v115 = v111;
        }
      }

      else
      {
        uint64_t v115 = v111;
      }
    }

    else
    {
      unsigned int v117 = v112 & 0xF000;
      unsigned int v108 = v117 >> 12;
      if (v117 >> 12)
      {
        unsigned int v124 = v108;
        uint64_t v123 = 1LL << (v108 + 7);
        uint64_t v40 = v123 | 0xFF;
      }

      else
      {
        uint64_t v40 = v111;
      }

      uint64_t v115 = v40;
    }

    uint64_t v64 = v115;
  }

  uint64_t v71 = v64;
  uint64_t v70 = v66;
  uint64_t v69 = v65;
  uint64_t v94 = v64;
  BOOL v107 = v64 != -1;
  uint64_t v106 = 2395LL;
  if (v64 == -1) {
    _dispatch_abort(v106, v107, v18, v19, v20, v21, v22, v23);
  }
  if ((_dispatch_set_qos_class_enabled & 1) != 0)
  {
    uint64_t v105 = v94;
    uint64_t v104 = 4261412863LL;
    uint64_t v103 = 0LL;
    v94 &= 0xFFFFFFFF02FFFFFFLL;
    unint64_t v93 = 0LL;
    v96 = 0LL;
    v96 = _dispatch_thread_getspecific(4uLL);
    unint64_t v93 = (unint64_t)v96;
    uint64_t v92 = 0x1000000LL;
    uint64_t v91 = 2281701376LL;
    if ((v96 & 0x1000000) != 0)
    {
      if (v94)
      {
        uint64_t v39 = v94;
      }

      else
      {
        unint64_t v102 = v93;
        uint64_t v101 = v92;
        uint64_t v100 = 0LL;
        uint64_t v39 = v93 & (~v92 | 0xFFFFFF);
      }

      uint64_t v95 = v39;
    }

    else
    {
      unint64_t v99 = v93;
      uint64_t v98 = v91;
      uint64_t v97 = 0LL;
      v93 &= ~v91 | 0xFFFFFF;
      if (v94 == v93) {
        uint64_t v95 = 0LL;
      }
      else {
        uint64_t v95 = v94;
      }
    }
  }

  else
  {
    uint64_t v95 = 0LL;
  }

  uint64_t v71 = v95;
  if (v95) {
    goto LABEL_88;
  }
  if (v70 == -1)
  {
    uint64_t v72 = -1LL;
    goto LABEL_89;
  }

  uint64_t v38 = (void *)v70;
  if (v38 != _dispatch_thread_getspecific(0x1CuLL))
  {
LABEL_88:
    uint64_t v72 = _dispatch_set_priority_and_voucher_slow(v71, (_DWORD *)v70, v69);
  }

  else
  {
    BOOL v68 = (v69 & 4) != 0;
    if ((v69 & 2) != 0)
    {
      if (v68 && v70)
      {
        object = (void *)v70;
        os_release((void *)v70);
      }

      uint64_t v70 = -1LL;
    }

    else if (!v68 && v70)
    {
      v74 = (void *)v70;
      os_retain((void *)v70);
    }

    uint64_t v72 = v70;
  }

LABEL_89:
  uint64_t v88 = v46;
  v87 = 0LL;
  v87 = _dispatch_thread_getspecific(0x16uLL);
  int v86 = 0;
  if (v87) {
    int v37 = v87[2] + 1;
  }
  else {
    int v37 = 1;
  }
  int v86 = v37;
  if (v37 <= _dispatch_continuation_cache_limit)
  {
    *(void *)(v88 + 16) = v87;
    *(_DWORD *)(v88 + 8) = v86;
    _dispatch_thread_setspecific(22LL, v88);
    uint64_t v89 = 0LL;
  }

  else
  {
    uint64_t v89 = v88;
  }

  uint64_t v45 = (void *)v89;
  _dispatch_continuation_pop(v53, v56, v55, v50);
  if (v45) {
    _dispatch_continuation_free_to_cache_limit(v45);
  }
  v147 = &v54;
  _dispatch_thread_setspecific_packed_pair(20LL, 21LL, &v54, v31, v32, v33, v34, v35);
  if (v51)
  {
    v90 = v48;
    _dispatch_thread_setspecific(20LL, (uint64_t)v48);
  }

  unsigned int v151 = v47;
  unsigned int v150 = 0;
  unsigned int v150 = _dispatch_thread_getspecific(0x19uLL);
  v151 &= 0xFFF0FFFF;
  v151 |= v150 & 0xF0000;
  _dispatch_thread_setspecific(25LL, v151);
  for (uint64_t i = *(void *)(v50 + 24); ; uint64_t i = *(void *)(i + 24))
  {
    BOOL v36 = 0;
    if (*(void *)(i + 24)) {
      BOOL v36 = i != (void)v48;
    }
    if (!v36) {
      break;
    }
    uint64_t v58 = i;
    uint64_t v59 = i;
    _dispatch_lane_non_barrier_complete(i, 0);
  }

  _dispatch_lane_non_barrier_complete(v50, 1u);
}

void *_dispatch_workloop_stealer_invoke( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v21 = a3;
  uint64_t v24 = *(_DWORD **)(a1 + 24);
  *(void *)(a1 + 24) = -1LL;
  if (v24 != (_DWORD *)-1LL)
  {
    if (v24) {
      unsigned int v19 = v24[8];
    }
    else {
      unsigned int v19 = 0;
    }
    if (MEMORY[0xFFFFFC100]) {
      kdebug_trace(771817480LL, v19, a1, 0LL, 0LL);
    }
    _dispatch_thread_getspecific(0LL);
    _dispatch_log("%u\t%p\tvoucher[%p]: continuation[%p] adopt", v8, v9, v10, v11, v12, v13, v14, 607LL);
  }

  uint64_t v27 = *(void *)(a1 + 8);
  uint64_t v26 = 0LL;
  if (v27 != -1)
  {
    unsigned int v34 = _dispatch_thread_getspecific(0x19uLL);
    int v37 = (unsigned __int16)(v34 & 0xF00) >> 8;
    unint64_t v36 = v34;
    if (v37) {
      unint64_t v36 = v34 | (unint64_t)(1LL << (v37 + 7));
    }
    if ((v27 & 0xFFFFFF) != 0)
    {
      if ((v27 & 0xFFFFFFuLL) >= (v36 & 0xFFFFFF00))
      {
        if ((v27 & 0x10000000) != 0 || (v34 & 0x44000000) != 0) {
          uint64_t v35 = v27 & 0xFFFFFF;
        }
        else {
          uint64_t v35 = v36;
        }
      }

      else
      {
        uint64_t v35 = v36;
      }
    }

    else
    {
      int v33 = (unsigned __int16)(v34 & 0xF000) >> 12;
      if (v33) {
        uint64_t v18 = (1LL << (v33 + 7)) | 0xFF;
      }
      else {
        uint64_t v18 = v36;
      }
      uint64_t v35 = v18;
    }

    uint64_t v26 = v35;
  }

  if (v26 == -1) {
    _dispatch_abort(2395LL, 0LL, a3, a4, a5, a6, a7, a8);
  }
  if ((_dispatch_set_qos_class_enabled & 1) != 0)
  {
    unint64_t v31 = v26 & 0xFFFFFFFF02FFFFFFLL;
    unint64_t v30 = (unint64_t)_dispatch_thread_getspecific(4uLL);
    if ((v30 & 0x1000000) != 0)
    {
      if (v31) {
        unint64_t v17 = v26 & 0xFFFFFFFF02FFFFFFLL;
      }
      else {
        unint64_t v17 = v30 & 0xFFFFFFFFFEFFFFFFLL;
      }
      unint64_t v32 = v17;
    }

    else if (v31 == (v30 & 0xFFFFFFFF77FFFFFFLL))
    {
      unint64_t v32 = 0LL;
    }

    else
    {
      unint64_t v32 = v26 & 0xFFFFFFFF02FFFFFFLL;
    }
  }

  else
  {
    unint64_t v32 = 0LL;
  }

  if (v32) {
    goto LABEL_41;
  }
  if (v24 == (_DWORD *)-1LL) {
    goto LABEL_42;
  }
  if (v24 != _dispatch_thread_getspecific(0x1CuLL))
  {
LABEL_41:
    _dispatch_set_priority_and_voucher_slow(v32, v24, 6);
  }

  else if (v24)
  {
    os_release(v24);
  }

LABEL_42:
  uint64_t v28 = _dispatch_thread_getspecific(0x16uLL);
  if (v28) {
    int v16 = v28[2] + 1;
  }
  else {
    int v16 = 1;
  }
  if (v16 <= _dispatch_continuation_cache_limit)
  {
    *(void *)(a1 + 16) = v28;
    *(_DWORD *)(a1 + 8) = v16;
    _dispatch_thread_setspecific(22LL, a1);
    uint64_t v29 = 0LL;
  }

  else
  {
    uint64_t v29 = (void *)a1;
  }

  uint64_t result = (void *)(*(uint64_t (**)(void, uint64_t, void))(**(void **)(a1 + 48) + 48LL))( *(void *)(a1 + 48),  a2,  v21 | 1u);
  if (v29) {
    return _dispatch_continuation_free_to_cache_limit(v29);
  }
  return result;
}

uint64_t _dispatch_queue_override_invoke(void *a1, uint64_t a2, unsigned int a3)
{
  unsigned int v47 = _dispatch_thread_getspecific(0x14uLL);
  __int16 v45 = 4;
  uint64_t v46 = (void *)a1[6];
  v87 = (_DWORD *)a1[7];
  unsigned int v86 = _dispatch_thread_getspecific(0x19uLL);
  if ((*(void *)(*(void *)v87 + 16LL) & 0x10000LL) == 0) {
    _dispatch_abort(1946LL, 0LL, v3, v4, v5, v6, v7, v8);
  }
  int v88 = v87[21];
  unsigned int v89 = v88 & 0xFFF0FFFF | _dispatch_thread_getspecific(0x19uLL) & 0xF0000;
  _dispatch_thread_setspecific(25LL, v89);
  _dispatch_thread_setspecific(20LL, (uint64_t)v87);
  if (*(void *)(*a1 + 16LL) == 1792LL)
  {
    a3 |= 1u;
    __int16 v45 = 516;
  }

  uint64_t v51 = (_DWORD *)a1[3];
  a1[3] = -1LL;
  if (v51 != (_DWORD *)-1LL)
  {
    if (v51) {
      unsigned int v44 = v51[8];
    }
    else {
      unsigned int v44 = 0;
    }
    if (MEMORY[0xFFFFFC100]) {
      kdebug_trace(771817480LL, v44, a1, 0LL, 0LL);
    }
    _dispatch_thread_getspecific(0LL);
    _dispatch_log("%u\t%p\tvoucher[%p]: continuation[%p] adopt", v15, v16, v17, v18, v19, v20, v21, 607LL);
  }

  uint64_t v53 = a1[1];
  unint64_t v52 = 0LL;
  if (v53 != -1)
  {
    unsigned int v80 = _dispatch_thread_getspecific(0x19uLL);
    int v83 = (unsigned __int16)(v80 & 0xF00) >> 8;
    unint64_t v82 = v80;
    if (v83) {
      unint64_t v82 = v80 | (unint64_t)(1LL << (v83 + 7));
    }
    if ((v53 & 0xFFFFFF) != 0)
    {
      if ((v53 & 0xFFFFFF) >= (unint64_t)(v82 & 0xFFFFFF00))
      {
        if ((v53 & 0x10000000) != 0 || (v80 & 0x44000000) != 0) {
          unint64_t v81 = v53 & 0xFFFFFF;
        }
        else {
          unint64_t v81 = v82;
        }
      }

      else
      {
        unint64_t v81 = v82;
      }
    }

    else
    {
      int v79 = (unsigned __int16)(v80 & 0xF000) >> 12;
      if (v79) {
        uint64_t v43 = (1LL << (v79 + 7)) | 0xFF;
      }
      else {
        uint64_t v43 = v82;
      }
      unint64_t v81 = v43;
    }

    unint64_t v52 = v81;
  }

  if (v52 == -1LL) {
    _dispatch_abort(2395LL, 0LL, v9, v10, v11, v12, v13, v14);
  }
  if ((_dispatch_set_qos_class_enabled & 1) != 0)
  {
    unint64_t v74 = v52 & 0xFFFFFFFF02FFFFFFLL;
    unint64_t v73 = (unint64_t)_dispatch_thread_getspecific(4uLL);
    if ((v73 & 0x1000000) != 0)
    {
      if (v74) {
        unint64_t v42 = v52 & 0xFFFFFFFF02FFFFFFLL;
      }
      else {
        unint64_t v42 = v73 & 0xFFFFFFFFFEFFFFFFLL;
      }
      unint64_t v75 = v42;
    }

    else if (v74 == (v73 & 0xFFFFFFFF77FFFFFFLL))
    {
      unint64_t v75 = 0LL;
    }

    else
    {
      unint64_t v75 = v52 & 0xFFFFFFFF02FFFFFFLL;
    }
  }

  else
  {
    unint64_t v75 = 0LL;
  }

  if (v75) {
    goto LABEL_45;
  }
  if (v51 == (_DWORD *)-1LL) {
    goto LABEL_46;
  }
  if (v51 != _dispatch_thread_getspecific(0x1CuLL))
  {
LABEL_45:
    _dispatch_set_priority_and_voucher_slow(v75, v51, v45 & 4 | 2);
  }

  else if (v51)
  {
    os_release(v51);
  }

LABEL_46:
  __int128 v54 = _dispatch_thread_getspecific(0x16uLL);
  if (v54) {
    int v41 = v54[2] + 1;
  }
  else {
    int v41 = 1;
  }
  if (v41 <= _dispatch_continuation_cache_limit)
  {
    a1[2] = v54;
    *((_DWORD *)a1 + 2) = v41;
    _dispatch_thread_setspecific(22LL, (uint64_t)a1);
    unsigned int v55 = 0LL;
  }

  else
  {
    unsigned int v55 = a1;
  }

  if (*v46 >= 0x1000uLL)
  {
    if (*(void *)(*v46 + 16LL) == 1LL) {
      (*(void (**)(void *, void, void))(*v46 + 24LL))(v46, 0LL, (a3 >> 21) & 1);
    }
    else {
      (*(void (**)(void *, uint64_t, void))(*v46 + 48LL))(v46, a2, a3);
    }
    goto LABEL_129;
  }

  uint64_t v57 = 0LL;
  if ((a3 & 0x1000000) != 0) {
    uint64_t v57 = _dispatch_autorelease_pool_push();
  }
  uint64_t v56 = *v46;
  uint64_t v62 = (_DWORD *)v46[3];
  uint64_t v61 = *v46 & 4LL;
  if (v61) {
    v46[3] = -1LL;
  }
  if (v62 != (_DWORD *)-1LL)
  {
    if (v62) {
      unsigned int v40 = v62[8];
    }
    else {
      unsigned int v40 = 0;
    }
    if (MEMORY[0xFFFFFC100]) {
      kdebug_trace(771817480LL, v40, v46, 0LL, 0LL);
    }
    _dispatch_thread_getspecific(0LL);
    _dispatch_log("%u\t%p\tvoucher[%p]: continuation[%p] adopt", v28, v29, v30, v31, v32, v33, v34, 607LL);
  }

  uint64_t v64 = v46[1];
  unint64_t v63 = 0LL;
  if (v64 != -1)
  {
    unsigned int v77 = _dispatch_thread_getspecific(0x19uLL);
    int v85 = (unsigned __int16)(v77 & 0xF00) >> 8;
    unint64_t v84 = v77;
    if (v85) {
      unint64_t v84 = v77 | (unint64_t)(1LL << (v85 + 7));
    }
    if ((v64 & 0xFFFFFF) != 0)
    {
      if ((v64 & 0xFFFFFF) >= (unint64_t)(v84 & 0xFFFFFF00))
      {
        if ((v64 & 0x10000000) != 0 || (v77 & 0x44000000) != 0) {
          unint64_t v78 = v64 & 0xFFFFFF;
        }
        else {
          unint64_t v78 = v84;
        }
      }

      else
      {
        unint64_t v78 = v84;
      }
    }

    else
    {
      int v76 = (unsigned __int16)(v77 & 0xF000) >> 12;
      if (v76) {
        uint64_t v39 = (1LL << (v76 + 7)) | 0xFF;
      }
      else {
        uint64_t v39 = v84;
      }
      unint64_t v78 = v39;
    }

    unint64_t v63 = v78;
  }

  if (v63 == -1LL) {
    _dispatch_abort(2395LL, 0LL, v22, v23, v24, v25, v26, v27);
  }
  if ((_dispatch_set_qos_class_enabled & 1) != 0)
  {
    unint64_t v71 = v63 & 0xFFFFFFFF02FFFFFFLL;
    unint64_t v70 = (unint64_t)_dispatch_thread_getspecific(4uLL);
    if ((v70 & 0x1000000) != 0)
    {
      if (v71) {
        unint64_t v38 = v63 & 0xFFFFFFFF02FFFFFFLL;
      }
      else {
        unint64_t v38 = v70 & 0xFFFFFFFFFEFFFFFFLL;
      }
      unint64_t v72 = v38;
    }

    else if (v71 == (v70 & 0xFFFFFFFF77FFFFFFLL))
    {
      unint64_t v72 = 0LL;
    }

    else
    {
      unint64_t v72 = v63 & 0xFFFFFFFF02FFFFFFLL;
    }
  }

  else
  {
    unint64_t v72 = 0LL;
  }

  if (v72)
  {
LABEL_101:
    _dispatch_set_priority_and_voucher_slow(v72, v62, v61 | 2);
    goto LABEL_102;
  }

  if (v62 != (_DWORD *)-1LL)
  {
    if (v62 == _dispatch_thread_getspecific(0x1CuLL))
    {
      if ((v61 & 4) != 0 && v62) {
        os_release(v62);
      }
      goto LABEL_102;
    }

    goto LABEL_101;
  }

    unint64_t v38 = v53;
    if (*(void *)a2 <= 0xFFFuLL && (*(void *)a2 & 0x81LL) != 0) {
      _dispatch_non_barrier_waiter_redirect_or_wake(a1, a2, a3, a4, a5, a6, a7, a8);
    }
    else {
      _dispatch_continuation_redirect_push( a1,  (void *)a2,  (((unint64_t)*(unsigned int *)(a1 + 60) << 32) & 0x700000000LL) >> 32);
    }
LABEL_52:
    a2 = (uint64_t)v38;
    uint64_t v26 = 0;
    if (v38)
    {
      if (*(void *)v38 > 0xFFFuLL) {
        __int16 v45 = (*(void *)(*(void *)v38 + 16LL) & 0xF0LL) == 0x10 && (v38[20] & 0x80000) != 0;
      }
      else {
        __int16 v45 = (*(void *)v38 & 2LL) != 0;
      }
      uint64_t v26 = !v45;
    }

    if (!v26) {
      goto LABEL_60;
    }
  }

  if (*(void *)a2 <= 0xFFFuLL && (*(void *)a2 & 0x81LL) != 0)
  {
    uint64_t v28 = (unint64_t *)(a1 + 56);
    uint64_t v29 = *(void *)(a1 + 56);
    do
    {
      uint64_t v10 = v29;
      do
        uint64_t v11 = __ldaxr(v28);
      while (v11 == v29 && __stlxr(v29 + 0x20000000000LL, v28));
      uint64_t v29 = v11;
    }

    while (v11 != v10);
    goto LABEL_33;
  }

  uint64_t v46 = (unint64_t *)(a1 + 56);
  do
  {
    if (_os_atomic_mo_has_acquire(2)) {
      uint64_t v12 = __ldaxr(v46);
    }
    else {
      uint64_t v12 = __ldxr(v46);
    }
    uint64_t v27 = 1;
    if (v12 < 0x20000000000000LL)
    {
      uint64_t v27 = 1;
      if ((v12 & 0x8000000000LL) == 0) {
        uint64_t v27 = (v12 & 0x10000000000LL) != 0;
      }
    }

    if (v27)
    {
      __clrex();
      uint64_t v49 = 0;
      goto LABEL_32;
    }

    uint64_t v48 = v12 + 0x20000000000LL;
    if (_os_atomic_mo_has_release(2)) {
      unsigned int v47 = __stlxr(v48, v46) == 0;
    }
    else {
      unsigned int v47 = __stxr(v48, v46) == 0;
    }
  }

  while (!v47);
  uint64_t v49 = 1;
LABEL_32:
  if ((v49 & 1) != 0) {
    goto LABEL_33;
  }
LABEL_60:
  uint64_t v35 = (unint64_t)_dispatch_thread_getspecific(3uLL) & 0xFFFFFFFC;
  uint64_t v34 = v39 << 41;
  if (a2)
  {
    uint64_t v61 = v39 << 41;
    uint64_t v60 = *(_WORD *)(a1 + 80);
    if (v60 > 1u)
    {
      if (*(void *)a2 > 0xFFFuLL) {
        uint64_t v62 = (*(void *)(*(void *)a2 + 16LL) & 0xF0LL) == 0x10 && (*(_DWORD *)(a2 + 80) & 0x80000) != 0;
      }
      else {
        uint64_t v62 = (*(void *)a2 & 2LL) != 0;
      }
      if (v62) {
        uint64_t v61 = v34 - (((uint64_t)(v60 - 1) << 41) + 0x10000000000LL);
      }
    }

    uint64_t v34 = v61;
  }

  uint64_t v32 = (unint64_t *)(a1 + 56);
  do
  {
    if (_os_atomic_mo_has_acquire(0)) {
      uint64_t v14 = __ldaxr(v32);
    }
    else {
      uint64_t v14 = __ldxr(v32);
    }
    int v37 = v14;
    unint64_t v36 = (v14 - v34) & 0xFFFFFF7700000001LL;
    if (a2)
    {
      uint64_t v57 = v36 | 0x8000000000LL;
      __int128 v54 = v36 | 0x8000000000LL;
      if (((v14 - v34) & 0x10000000000LL) != 0) {
        unsigned int v55 = v54 + 0x10000000000LL;
      }
      else {
        unsigned int v55 = v54 + ((unint64_t)*(unsigned __int16 *)(a1 + 80) << 41);
      }
      uint64_t v56 = v55 + 0x40000000000000LL;
      if ((v56 & 0x3FFE0000000000LL) == 0x20000000000000LL)
      {
        uint64_t v57 = v56 & 0xFFFFFF7FFFFFFFFFLL | v35;
      }

      else if ((v14 & 0x8000000000LL) != 0)
      {
        uint64_t v57 = (v14 - v34) & 0xFFFFFF7700000000LL | 0x8000000001LL;
      }

      unint64_t v36 = v57;
    }

    else if ((v14 & 0x8000000000LL) != 0)
    {
      __clrex();
      uint64_t v24 = (unint64_t *)(a1 + 56);
      uint64_t v25 = *(void *)(a1 + 56);
      do
      {
        uint64_t v15 = v25;
        do
          uint64_t v16 = __ldaxr(v24);
        while (v16 == v25 && __stlxr(v25 ^ 0x8000000000LL, v24));
        uint64_t v25 = v16;
      }

      while (v16 != v15);
      unint64_t v38 = *(_DWORD **)(a1 + 104);
      goto LABEL_52;
    }

    if (_os_atomic_mo_has_release(0)) {
      uint64_t v33 = __stlxr(v36, v32) == 0;
    }
    else {
      uint64_t v33 = __stxr(v36, v32) == 0;
    }
  }

  while (!v33);
  uint64_t v58 = v37 - v34;
  uint64_t v23 = 0;
  if (((v37 - v34) & 0x1000000000LL) != 0) {
    uint64_t v23 = ((v37 - v34) & 0x800000000LL) != 0;
  }
  if (v23)
  {
    uint64_t v59 = v58 & 0x700000000LL;
    LODWORD(v59) = _dispatch_thread_getspecific(0x19uLL);
  }

  if (((v58 ^ v36) & 0x40000000000000LL) != 0)
  {
    _dispatch_lane_barrier_complete(a1, 0LL, v40);
  }

  else if (((v58 ^ v36) & 1) != 0)
  {
    if ((v40 & 1) == 0) {
      _dispatch_retain_2(a1);
    }
    if ((v36 & 0x2000000000LL) != 0) {
      _dispatch_abort(1002LL, 0LL, v17, v18, v19, v20, v21, v22);
    }
    (*(void (**)(void, uint64_t, unint64_t, uint64_t, uint64_t, uint64_t))(**(void **)(a1 + 24) + 72LL))( *(void *)(a1 + 24),  a1,  (v36 & 0x700000000LL) >> 32,  v18,  v19,  v20);
  }

  else if ((v40 & 1) != 0)
  {
    _dispatch_release_2_tailcall((unsigned int *)a1);
  }

LABEL_102:
  if ((v56 & 4) != 0)
  {
    uint64_t v65 = _dispatch_thread_getspecific(0x16uLL);
    if (v65) {
      int v37 = v65[2] + 1;
    }
    else {
      int v37 = 1;
    }
    if (v37 <= _dispatch_continuation_cache_limit)
    {
      v46[2] = v65;
      *((_DWORD *)v46 + 2) = v37;
      _dispatch_thread_setspecific(22LL, (uint64_t)v46);
      uint64_t v66 = 0LL;
    }

    else
    {
      uint64_t v66 = v46;
    }

    uint64_t v58 = v66;
  }

  else
  {
    uint64_t v58 = 0LL;
  }

  if ((v56 & 8) != 0)
  {
    group = (dispatch_group_s *)v46[6];
    if (*(void *)(*(void *)group + 16LL) != 514LL)
    {
      uint64_t v35 = *(void *)(*(void *)group + 16LL);
      qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: Unexpected object type";
      qword_E4DA8 = v35;
      __break(1u);
      JUMPOUT(0x16A98LL);
    }

    uint64_t v69 = v46[5];
    BOOL v68 = (void (*)(void (**)(void)))v46[4];
    if (v68 == _dispatch_call_block_and_release && v69) {
      _Block_get_invoke_fn(v69);
    }
    _dispatch_client_callout(v69, (uint64_t (*)(uint64_t))v68);
    if (MEMORY[0xFFFFFC100]) {
      kdebug_trace(772079660LL, v46, 0LL, 0LL, 0LL);
    }
    dispatch_group_leave(group);
  }

  else
  {
    uint64_t v60 = v46[5];
    uint64_t v59 = (void (*)(void (**)(void)))v46[4];
    if (v59 == _dispatch_call_block_and_release && v60) {
      _Block_get_invoke_fn(v60);
    }
    _dispatch_client_callout(v60, (uint64_t (*)(uint64_t))v59);
    if (MEMORY[0xFFFFFC100]) {
      kdebug_trace(772079660LL, v46, 0LL, 0LL, 0LL);
    }
  }

  if (v58) {
    _dispatch_continuation_free_to_cache_limit(v58);
  }
  if (v57) {
    _dispatch_autorelease_pool_pop(v57);
  }
LABEL_129:
  if ((v45 & 0x200) == 0 && MEMORY[0xFFFFFC100]) {
    kdebug_trace(772079660LL, a1, 0LL, 0LL, 0LL);
  }
  if (v55) {
    _dispatch_continuation_free_to_cache_limit(v55);
  }
  unsigned int v90 = _dispatch_thread_getspecific(0x19uLL);
  _dispatch_thread_setspecific(25LL, v86 & 0xFFF0FFFF | v90 & 0xF0000);
  return _dispatch_thread_setspecific(20LL, (uint64_t)v47);
}

void *_dispatch_continuation_free_to_cache_limit(void *a1)
{
  uint64_t result = _dispatch_thread_getspecific(0x16uLL);
  uint64_t v5 = result;
  if (result)
  {
    int v3 = *((_DWORD *)result + 2) - _dispatch_continuation_cache_limit;
    if (v3 > 0)
    {
      do
      {
        uint64_t v4 = v5[2];
        _dispatch_continuation_free_to_heap(v5);
        --v3;
        BOOL v2 = 0;
        if (v3)
        {
          uint64_t v5 = (void *)v4;
          BOOL v2 = v4 != 0;
        }
      }

      while (v2);
      return (void *)_dispatch_thread_setspecific(22LL, v4);
    }
  }

  return result;
}

void _dispatch_continuation_pop(void *a1, uint64_t a2, int a3, uint64_t a4)
{
}

void _dispatch_continuation_pop_inline(void *a1, uint64_t a2, int a3, uint64_t a4)
{
  unsigned __int16 v25 = HIWORD(a3);
  uint64_t v23 = (void (**)(uint64_t))_dispatch_thread_getspecific(0x18uLL);
  if (v23) {
    (*v23)(a4);
  }
  unsigned int v24 = v25 << 16;
  if (*a1 >= 0x1000uLL)
  {
    if (*(void *)(*a1 + 16LL) == 1LL) {
      (*(void (**)(void *, void, void))(*a1 + 24LL))(a1, 0LL, (v24 >> 21) & 1);
    }
    else {
      (*(void (**)(void *, uint64_t, void))(*a1 + 48LL))(a1, a2, v24);
    }
    goto LABEL_80;
  }

  uint64_t v30 = 0LL;
  if ((v24 & 0x1000000) != 0) {
    uint64_t v30 = _dispatch_autorelease_pool_push();
  }
  uint64_t v29 = *a1;
  uint64_t v35 = (_DWORD *)a1[3];
  uint64_t v34 = *a1 & 4LL;
  if (v34) {
    a1[3] = -1LL;
  }
  if (v35 != (_DWORD *)-1LL)
  {
    if (v35) {
      unsigned int v22 = v35[8];
    }
    else {
      unsigned int v22 = 0;
    }
    if (MEMORY[0xFFFFFC100]) {
      kdebug_trace(771817480LL, v22, a1, 0LL, 0LL);
    }
    _dispatch_thread_getspecific(0LL);
    _dispatch_log("%u\t%p\tvoucher[%p]: continuation[%p] adopt", v10, v11, v12, v13, v14, v15, v16, 607LL);
  }

  uint64_t v37 = a1[1];
  uint64_t v36 = 0LL;
  if (v37 != -1)
  {
    unsigned int v17 = _dispatch_thread_getspecific(0x19uLL);
    int v49 = (unsigned __int16)(v17 & 0xF00) >> 8;
    unint64_t v48 = v17;
    if (v49) {
      unint64_t v48 = v17 | (unint64_t)(1LL << (v49 + 7));
    }
    if ((v37 & 0xFFFFFF) != 0)
    {
      if ((v37 & 0xFFFFFFuLL) >= (v48 & 0xFFFFFF00))
      {
        if ((v37 & 0x10000000) != 0 || (v17 & 0x44000000) != 0) {
          uint64_t v47 = v37 & 0xFFFFFF;
        }
        else {
          uint64_t v47 = v48;
        }
      }

      else
      {
        uint64_t v47 = v48;
      }
    }

    else
    {
      int v46 = (unsigned __int16)(v17 & 0xF000) >> 12;
      if (v46) {
        uint64_t v21 = (1LL << (v46 + 7)) | 0xFF;
      }
      else {
        uint64_t v21 = v48;
      }
      uint64_t v47 = v21;
    }

    uint64_t v36 = v47;
  }

  if (v36 == -1) {
    _dispatch_abort(2395LL, 0LL, v4, v5, v6, v7, v8, v9);
  }
  if ((_dispatch_set_qos_class_enabled & 1) != 0)
  {
    unint64_t v44 = v36 & 0xFFFFFFFF02FFFFFFLL;
    unint64_t v43 = (unint64_t)_dispatch_thread_getspecific(4uLL);
    if ((v43 & 0x1000000) != 0)
    {
      if (v44) {
        unint64_t v20 = v36 & 0xFFFFFFFF02FFFFFFLL;
      }
      else {
        unint64_t v20 = v43 & 0xFFFFFFFFFEFFFFFFLL;
      }
      unint64_t v45 = v20;
    }

    else if (v44 == (v43 & 0xFFFFFFFF77FFFFFFLL))
    {
      unint64_t v45 = 0LL;
    }

    else
    {
      unint64_t v45 = v36 & 0xFFFFFFFF02FFFFFFLL;
    }
  }

  else
  {
    unint64_t v45 = 0LL;
  }

  if (v45)
  {
LABEL_52:
    _dispatch_set_priority_and_voucher_slow(v45, v35, v34 | 2);
    goto LABEL_53;
  }

  if (v35 != (_DWORD *)-1LL)
  {
    if (v35 == _dispatch_thread_getspecific(0x1CuLL))
    {
      if ((v34 & 4) != 0 && v35) {
        os_release(v35);
      }
      goto LABEL_53;
    }

    goto LABEL_52;
  }

LABEL_53:
  if ((v29 & 4) != 0)
  {
    unint64_t v38 = _dispatch_thread_getspecific(0x16uLL);
    if (v38) {
      int v19 = v38[2] + 1;
    }
    else {
      int v19 = 1;
    }
    if (v19 <= _dispatch_continuation_cache_limit)
    {
      a1[2] = v38;
      *((_DWORD *)a1 + 2) = v19;
      _dispatch_thread_setspecific(22LL, (uint64_t)a1);
      uint64_t v39 = 0LL;
    }

    else
    {
      uint64_t v39 = a1;
    }

    uint64_t v31 = v39;
  }

  else
  {
    uint64_t v31 = 0LL;
  }

  if ((v29 & 8) != 0)
  {
    group = (dispatch_group_s *)a1[6];
    if (*(void *)(*(void *)group + 16LL) != 514LL)
    {
      uint64_t v18 = *(void *)(*(void *)group + 16LL);
      qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: Unexpected object type";
      qword_E4DA8 = v18;
      __break(1u);
      JUMPOUT(0x17DECLL);
    }

    uint64_t v42 = a1[5];
    int v41 = (void (*)(void (**)(void)))a1[4];
    if (v41 == _dispatch_call_block_and_release && v42) {
      _Block_get_invoke_fn(v42);
    }
    _dispatch_client_callout(v42, (uint64_t (*)(uint64_t))v41);
    if (MEMORY[0xFFFFFC100]) {
      kdebug_trace(772079660LL, a1, 0LL, 0LL, 0LL);
    }
    dispatch_group_leave(group);
  }

  else
  {
    uint64_t v33 = a1[5];
    uint64_t v32 = (void (*)(void (**)(void)))a1[4];
    if (v32 == _dispatch_call_block_and_release && v33) {
      _Block_get_invoke_fn(v33);
    }
    _dispatch_client_callout(v33, (uint64_t (*)(uint64_t))v32);
    if (MEMORY[0xFFFFFC100]) {
      kdebug_trace(772079660LL, a1, 0LL, 0LL, 0LL);
    }
  }

  if (v31) {
    _dispatch_continuation_free_to_cache_limit(v31);
  }
  if (v30) {
    _dispatch_autorelease_pool_pop(v30);
  }
LABEL_80:
  if (v23) {
    v23[1](a4);
  }
}

  if ((v37 & 0x200) == 0)
  {
    uint64_t v60 = v44;
    uint64_t v59 = v47;
    uint64_t v58 = 0;
    uint64_t v57 = 0;
    unsigned int v124 = v44;
    uint64_t v123 = v47;
  }

  if ((v37 & 4) != 0)
  {
    unint64_t v63 = v39;
    uint64_t v62 = 0LL;
    uint64_t v62 = _dispatch_thread_getspecific(0x16uLL);
    uint64_t v61 = 0;
    if (v62) {
      uint64_t v31 = v62[2] + 1;
    }
    else {
      uint64_t v31 = 1;
    }
    uint64_t v61 = v31;
    if (v31 <= _dispatch_continuation_cache_limit)
    {
      *(void *)(v63 + 16) = v62;
      *(_DWORD *)(v63 + 8) = v61;
      _dispatch_thread_setspecific(22LL, v63);
      uint64_t v64 = 0LL;
    }

    else
    {
      uint64_t v64 = v63;
    }

    unint64_t v38 = (void *)v64;
  }

  else
  {
    unint64_t v38 = 0LL;
  }

  _dispatch_mach_send_invoke(v44, v45, 6u);
  if ((v37 & 0x200) == 0)
  {
    uint64_t v65 = v39;
    uint64_t v125 = v39;
    uint64_t v130 = 772079660;
    uint64_t v129 = v39;
    uint64_t v128 = 0LL;
    uint64_t v127 = 0LL;
    unsigned int v126 = 0LL;
    if (MEMORY[0xFFFFFC100]) {
      kdebug_trace(v130, v129, v128, v127, v126);
    }
    unsigned int v131 = v65;
  }

  if (v38) {
    _dispatch_continuation_free_to_cache_limit(v38);
  }
  uint64_t v66 = &v40;
  int v76 = &v40;
  return _dispatch_thread_setspecific_packed_pair(20LL, 21LL, &v40, v25, v26, v27, v28, v29);
}

      int v41 = v32;
      if (!v32) {
        goto LABEL_2;
      }
    }

    uint64_t v42 = v41;
    unint64_t v43 = 0LL;
LABEL_37:
    int v49 = v42[8];
    if (v49 != -1LL)
    {
      unint64_t v20 = v49 ? *(_DWORD *)(v49 + 32) : 0;
      if (MEMORY[0xFFFFFC100]) {
        kdebug_trace(771817488LL, v20, v42, 0LL, 0LL);
      }
    }

    int v19 = 1;
    if (!*(_DWORD *)(v44 + 88)) {
      int v19 = (*(_DWORD *)(a1 + 80) & 0x10000000) != 0;
    }
    if (v19)
    {
      _dispatch_mach_msg_not_sent(a1, (dispatch_object_s *)v42, v43);
      goto LABEL_53;
    }

    uint64_t v37 = _dispatch_mach_msg_send(a1, v42, v43, v40, v33);
    if (v37)
    {
      if ((v37 & 2) != 0) {
        uint64_t v36 = 1;
      }
      goto LABEL_53;
    }

    if ((*(_WORD *)(a1 + 118) & 1) != 0) {
      v35 |= 2u;
    }
LABEL_67:
    v41[2] = (unint64_t)v32;
    uint64_t v18 = 0;
    if (!v32)
    {
      uint64_t v11 = (unint64_t *)(v44 + 72);
      do
        uint64_t v12 = __ldaxr(v11);
      while (!v12 && __stlxr((unint64_t)v41, v11));
      uint64_t v18 = v12 != 0;
    }

    if (v18)
    {
      uint64_t v26 = *(void *)(v44 + 80);
      if (!v26) {
        uint64_t v26 = _dispatch_wait_for_enqueuer((unint64_t *)(v44 + 80), v44 + 72);
      }
      v41[2] = v26;
    }

    *(void *)(v44 + 80) = v41;
    unsigned int v17 = 0;
    if (*v41 > 0xFFF) {
      unsigned int v17 = *(void *)(*v41 + 16) == 768LL;
    }
    if (v17)
    {
      unsigned int v24 = (unint64_t *)(v44 + 64);
      do
      {
        if (_os_atomic_mo_has_acquire(3)) {
          uint64_t v13 = __ldaxr(v24);
        }
        else {
          uint64_t v13 = __ldxr(v24);
        }
        uint64_t v39 = v13;
        unint64_t v38 = v13 & 0xFFFFFFC700000000LL | 0x3000000000LL;
        if (_os_atomic_mo_has_release(3)) {
          unsigned __int16 v25 = __stlxr(v38, v24) == 0;
        }
        else {
          unsigned __int16 v25 = __stxr(v38, v24) == 0;
        }
      }

      while (!v25);
    }

    else
    {
      unsigned int v22 = (unint64_t *)(v44 + 64);
      do
      {
        if (_os_atomic_mo_has_acquire(3)) {
          uint64_t v14 = __ldaxr(v22);
        }
        else {
          uint64_t v14 = __ldxr(v22);
        }
        uint64_t v39 = v14;
        if ((v14 & 0x2800000000LL) != 0) {
          unint64_t v38 = v14 & 0xFFFFFFC7FFFFFFFFLL;
        }
        else {
          unint64_t v38 = v14 & 0xFFFFFFDF00000000LL | 0x2000000000LL;
        }
        if (_os_atomic_mo_has_release(3)) {
          uint64_t v23 = __stlxr(v38, v22) == 0;
        }
        else {
          uint64_t v23 = __stxr(v38, v22) == 0;
        }
      }

      while (!v23);
    }

dispatch_block_t dispatch_block_create(dispatch_block_flags_t flags, dispatch_block_t block)
{
  if ((flags & 0xFFFFFF00) != 0) {
    return 0LL;
  }
  else {
    return _dispatch_block_create_with_voucher_and_priority(flags, 0LL, 0LL, block, v2, v3, v4, v5);
  }
}

void *_dispatch_block_create_with_voucher_and_priority( uint64_t a1, uint64_t a2, uint64_t a3, const void *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v22 = a3;
  uint64_t v25 = a1;
  if ((a1 & 0xA) != 0) {
    uint64_t v25 = a1 | 0x40000000;
  }
  if ((v25 & 0x20) != 0) {
    v25 &= ~0x10uLL;
  }
  uint64_t v24 = v25;
  if ((v25 & 0x80000000LL) == 0)
  {
    if ((v25 & 2) != 0)
    {
      a2 = 0LL;
      uint64_t v24 = v25 | 0x80000000LL;
    }

    else if ((v25 & 0x40) != 0)
    {
      a2 = -1LL;
      uint64_t v24 = v25 | 0x80000000LL;
    }

    else if ((v25 & 4) != 0)
    {
      a2 = -3LL;
      uint64_t v24 = v25 | 0x80000000LL;
    }
  }

  if (a2 == -3) {
    a2 = (uint64_t)_dispatch_thread_getspecific(0x1CuLL);
  }
  if ((v25 & 4) != 0 && (v24 & 0x40000000) == 0)
  {
    unint64_t v28 = (unint64_t)_dispatch_thread_getspecific(4uLL) & 0xFFFFFF;
    if (v28 <= 0x10FF) {
      uint64_t v29 = v28;
    }
    else {
      uint64_t v29 = 4351LL;
    }
    uint64_t v22 = v29;
    v24 |= 0x40000000uLL;
  }

  uint64_t v18 = _dispatch_block_create((void *)v24, (void *)a2, v22, a4, a5, a6, a7, a8);
  if ((void (*)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))_Block_get_invoke_fn((uint64_t)v18) == ___dispatch_block_create_block_invoke)
  {
    if (v18[4] != 3512316172LL)
    {
      uint64_t v14 = v18[4];
      qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Corruption of dispatch block object";
      qword_E4DA8 = v14;
      __break(1u);
      JUMPOUT(0x1846CLL);
    }

    uint64_t v26 = (char *)(v18 + 4);
  }

  else
  {
    uint64_t v26 = 0LL;
  }

  if (!v26) {
    _dispatch_abort(405LL, 0LL, v8, v9, v10, v11, v12, v13);
  }
  uint64_t v17 = _Block_get_invoke_fn((uint64_t)a4);
  if ((a1 & 0x40000000) != 0) {
    uint64_t v16 = a3;
  }
  else {
    uint64_t v16 = 0xFFFFFFFFLL;
  }
  uint64_t v27 = v22 | ((void)_dispatch_thread_getspecific(4uLL) << 32);
  if (MEMORY[0xFFFFFC100]) {
    kdebug_trace(772079628LL, v18, v17, v16 | (a1 << 32), v27);
  }
  return v18;
}

dispatch_block_t dispatch_block_create_with_qos_class( dispatch_block_flags_t flags, dispatch_qos_class_t qos_class, int relative_priority, dispatch_block_t block)
{
  if ((flags & 0xFFFFFF00) != 0) {
    return 0LL;
  }
  if (qos_class == QOS_CLASS_UNSPECIFIED
    || qos_class == 5
    || qos_class == QOS_CLASS_BACKGROUND
    || qos_class == QOS_CLASS_UTILITY
    || qos_class == QOS_CLASS_DEFAULT
    || qos_class == QOS_CLASS_USER_INITIATED
    || qos_class == QOS_CLASS_USER_INTERACTIVE)
  {
    BOOL v10 = 0;
    if (relative_priority >= -15) {
      BOOL v10 = relative_priority <= 0;
    }
    BOOL v14 = v10;
  }

  else
  {
    BOOL v14 = 0;
  }

  if (!v14) {
    return 0LL;
  }
  uint64_t v4 = _pthread_qos_class_encode(qos_class, relative_priority, 0LL);
  return _dispatch_block_create_with_voucher_and_priority(flags | 0x40000000, 0LL, v4, block, v5, v6, v7, v8);
}

void *dispatch_block_create_with_voucher( uint64_t a1, uint64_t a2, const void *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if ((a1 & 0xFFFFFF00) != 0) {
    return 0LL;
  }
  else {
    return _dispatch_block_create_with_voucher_and_priority( a1 & 0xFFFFFFFF7FFFFFBFLL | 0x80000000,  a2,  0LL,  a3,  a5,  a6,  a7,  a8);
  }
}

void *dispatch_block_create_with_voucher_and_qos_class( uint64_t a1, uint64_t a2, unsigned int a3, int a4, const void *a5)
{
  if ((a1 & 0xFFFFFF00) != 0) {
    return 0LL;
  }
  if (!a3 || a3 == 5 || a3 == 9 || a3 == 17 || a3 == 21 || a3 == 25 || a3 == 33)
  {
    BOOL v11 = 0;
    if (a4 >= -15) {
      BOOL v11 = a4 <= 0;
    }
    BOOL v16 = v11;
  }

  else
  {
    BOOL v16 = 0;
  }

  if (!v16) {
    return 0LL;
  }
  uint64_t v5 = _pthread_qos_class_encode(a3, a4, 0LL);
  return _dispatch_block_create_with_voucher_and_priority( a1 & 0xFFFFFFFF3FFFFFB7LL | 0xC0000000,  a2,  v5,  a5,  v6,  v7,  v8,  v9);
}

void dispatch_block_perform(dispatch_block_flags_t flags, dispatch_block_t block)
{
  dispatch_block_flags_t v15 = flags;
  dispatch_block_t v14 = block;
  dispatch_block_flags_t v16 = flags;
  if ((flags & 0xFFFFFF00) != 0)
  {
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Invalid flags passed to dispatch_block_perform()";
    qword_E4DA8 = v15;
    __break(1u);
    JUMPOUT(0x189FCLL);
  }

  dispatch_block_flags_t v17 = v15;
  if ((v15 & 0xA) != 0) {
    v17 |= 0x40000000uLL;
  }
  if ((v17 & 0x20) != 0) {
    v17 &= ~0x10uLL;
  }
  dispatch_block_flags_t v15 = v17;
  uint64_t v13 = -1LL;
  if ((v17 & 2) != 0)
  {
    uint64_t v13 = 0LL;
    v15 |= 0x80000000uLL;
  }

  uint64_t v12 = 0LL;
  v8[0] = 0xD159B10CuLL;
  *((void *)&v8[0] + 1) = v15;
  v8[1] = 8uLL;
  uint64_t v9 = v13;
  dispatch_block_t v10 = v14;
  __int128 v11 = 0uLL;
  _dispatch_block_invoke_direct((uint64_t)v8, (uint64_t)block, v2, v3, v4, v5, v6, v7);
}

void _dispatch_block_invoke_direct( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v18 = *(void *)(a1 + 8);
  unsigned int v17 = *(_DWORD *)(a1 + 16);
  if (((v17 >> 2) & 1) != 0)
  {
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: A block object may not be both run more than once and waited for";
    qword_E4DA8 = v17;
    __break(1u);
    JUMPOUT(0x18B90LL);
  }

  if ((v17 & 1) != 0) {
    goto LABEL_54;
  }
  uint64_t v16 = 0LL;
  uint64_t v20 = 0LL;
  if ((v18 & 0x40000000) != 0 && ((v18 & 0x20) != 0 || (v18 & 0x10) == 0))
  {
    unint64_t v21 = *(void *)(a1 + 24) & 0xFFFFFFLL;
    uint64_t v22 = _dispatch_thread_getspecific(4uLL);
  }

  if (v20) {
    uint64_t v16 = *(void *)(a1 + 24);
  }
  uint64_t v15 = -1LL;
  if ((v18 & 0x80000000LL) != 0) {
    uint64_t v15 = *(void *)(a1 + 32);
  }
  if (v16 == -1) {
    _dispatch_abort(2395LL, 0LL, a3, a4, a5, a6, a7, a8);
  }
  if ((_dispatch_set_qos_class_enabled & 1) != 0)
  {
    unint64_t v28 = v16 & 0xFFFFFFFF02FFFFFFLL;
    unint64_t v8 = (unint64_t)_dispatch_thread_getspecific(4uLL);
    if ((v8 & 0x1000000) != 0)
    {
      if (v28) {
        unint64_t v14 = v16 & 0xFFFFFFFF02FFFFFFLL;
      }
      else {
        unint64_t v14 = v8 & 0xFFFFFFFFFEFFFFFFLL;
      }
      unint64_t v29 = v14;
    }

    else if (v28 == (v8 & 0xFFFFFFFF77FFFFFFLL))
    {
      unint64_t v29 = 0LL;
    }

    else
    {
      unint64_t v29 = v16 & 0xFFFFFFFF02FFFFFFLL;
    }
  }

  else
  {
    unint64_t v29 = 0LL;
  }

  if (!v29)
  {
    if (v15 == -1)
    {
      uint64_t v23 = -1LL;
      goto LABEL_34;
    }

    if ((void *)v15 == _dispatch_thread_getspecific(0x1CuLL))
    {
      if (v15) {
        os_retain((void *)v15);
      }
      uint64_t v23 = v15;
      goto LABEL_34;
    }
  }

  uint64_t v23 = _dispatch_set_priority_and_voucher_slow(v29, v15, 0LL);
LABEL_34:
  *(_DWORD *)(a1 + 64) = _dispatch_thread_getspecific(3uLL);
  uint64_t v25 = *(void *)(a1 + 40);
  uint64_t v24 = (void (*)(void (**)(void)))_Block_get_invoke_fn(v25);
  if (v24 == _dispatch_call_block_and_release && v25) {
    _Block_get_invoke_fn(v25);
  }
  _dispatch_client_callout(v25, (uint64_t (*)(uint64_t))v24);
  if ((_dispatch_set_qos_class_enabled & 1) != 0)
  {
    unint64_t v26 = (unint64_t)_dispatch_thread_getspecific(4uLL);
    if ((v26 & 0x1000000) != 0)
    {
      if ((v20 & 0x2FFFFFF) != 0) {
        unint64_t v13 = v20 & 0x2FFFFFF;
      }
      else {
        unint64_t v13 = v26 & 0xFFFFFFFFFEFFFFFFLL;
      }
      unint64_t v27 = v13;
    }

    else if ((v20 & 0x2FFFFFF) == (v26 & 0xFFFFFFFF77FFFFFFLL))
    {
      unint64_t v27 = 0LL;
    }

    else
    {
      unint64_t v27 = v20 & 0xFFFFFFFF02FFFFFFLL;
    }
  }

  else
  {
    unint64_t v27 = 0LL;
  }

  if (v27) {
    goto LABEL_53;
  }
  if (v23 == -1) {
    goto LABEL_54;
  }
  if ((void *)v23 != _dispatch_thread_getspecific(0x1CuLL))
  {
LABEL_53:
    _dispatch_set_priority_and_voucher_slow(v27, v23, 6LL);
  }

  else if (v23)
  {
    os_release((void *)v23);
  }

LABEL_54:
  if ((v17 & 8) == 0)
  {
    __int128 v11 = (unsigned int *)(a1 + 20);
    unsigned int v12 = *(_DWORD *)(a1 + 20);
    do
    {
      unsigned int v9 = v12;
      do
        unsigned int v10 = __ldaxr(v11);
      while (v10 == v12 && __stlxr(v12 + 1, v11));
      unsigned int v12 = v10;
    }

    while (v10 != v9);
    if (!v10) {
      dispatch_group_leave(*(dispatch_group_t *)(a1 + 48));
    }
  }

    if (_dispatch_thread_getspecific(5uLL)) {
      _dispatch_return_to_kernel();
    }
    _dispatch_continuation_pop_inline(v33, v38, v37, v39);
    uint64_t i = *(unsigned __int8 *)(v39 + 100);
    uint64_t v33 = v29;
    uint64_t v23 = 0;
    if (v29)
    {
      int v41 = v39;
      uint64_t v42 = (unint64_t)*(unsigned int *)(v39 + 60) << 32;
      v42 &= 0x700000000uLL;
      uint64_t v23 = HIDWORD(v42) <= i;
    }

    if (!v23) {
      goto LABEL_5;
    }
  }

  *(_DWORD *)(v38 + 16) = i;
  *(void *)(v38 + 8) = v33;
  *(_BYTE *)(v39 + 100) = 0;
  int v46 = &v34;
  _dispatch_thread_setspecific_packed_pair(20LL, 21LL, &v34, v12, v13, v14, v15, v16);
  unint64_t v52 = 0LL;
  _dispatch_thread_setspecific(24LL, 0LL);
  return *(void *)(v39 + 24);
}

void _dispatch_block_sync_invoke(uint64_t a1)
{
  if ((void (*)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))_Block_get_invoke_fn(a1) == ___dispatch_block_create_block_invoke)
  {
    if (*(void *)(a1 + 32) != 3512316172LL)
    {
      uint64_t v1 = *(void *)(a1 + 32);
      qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Corruption of dispatch block object";
      qword_E4DA8 = v1;
      __break(1u);
      JUMPOUT(0x1964CLL);
    }

    uint64_t v22 = a1 + 32;
  }

  else
  {
    uint64_t v22 = 0LL;
  }

  unsigned int v20 = *(_DWORD *)(v22 + 16);
  if (((v20 >> 2) & 1) != 0)
  {
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: A block object may not be both run more than once and waited for";
    qword_E4DA8 = v20;
    __break(1u);
    JUMPOUT(0x196D8LL);
  }

  if ((v20 & 1) != 0) {
    goto LABEL_48;
  }
  uint64_t v19 = -1LL;
  if ((*(void *)(v22 + 8) & 0x80000000LL) != 0)
  {
    uint64_t v23 = *(_DWORD **)(v22 + 32);
    unsigned __int16 v2 = (unsigned __int16)_dispatch_thread_getspecific(0x19uLL);
    int v32 = (unsigned __int16)(v2 & 0xF00) >> 8;
    unint64_t v31 = v2;
    if (v32) {
      unint64_t v31 = v2 | (unint64_t)(1LL << (v32 + 7));
    }
    int v30 = (unsigned __int16)(v2 & 0xF000) >> 12;
    if (v30) {
      uint64_t v18 = (1LL << (v30 + 7)) | 0xFF;
    }
    else {
      uint64_t v18 = v31;
    }
    if (v18 == -1) {
      _dispatch_abort(2395LL, 0LL, v3, v4, v5, v6, v7, v8);
    }
    if ((_dispatch_set_qos_class_enabled & 1) != 0)
    {
      unint64_t v28 = v18 & 0xFFFFFFFF02FFFFFFLL;
      unint64_t v27 = (unint64_t)_dispatch_thread_getspecific(4uLL);
      if ((v27 & 0x1000000) != 0)
      {
        if (v28) {
          unint64_t v17 = v18 & 0xFFFFFFFF02FFFFFFLL;
        }
        else {
          unint64_t v17 = v27 & 0xFFFFFFFFFEFFFFFFLL;
        }
        unint64_t v29 = v17;
      }

      else if (v28 == (v27 & 0xFFFFFFFF77FFFFFFLL))
      {
        unint64_t v29 = 0LL;
      }

      else
      {
        unint64_t v29 = v18 & 0xFFFFFFFF02FFFFFFLL;
      }
    }

    else
    {
      unint64_t v29 = 0LL;
    }

    if (!v29)
    {
      if (v23 == (_DWORD *)-1LL)
      {
        uint64_t v24 = -1LL;
LABEL_35:
        uint64_t v19 = v24;
        goto LABEL_36;
      }

      if (v23 == _dispatch_thread_getspecific(0x1CuLL))
      {
        if (v23) {
          os_retain(v23);
        }
        uint64_t v24 = (uint64_t)v23;
        goto LABEL_35;
      }
    }

    uint64_t v24 = _dispatch_set_priority_and_voucher_slow(v29, v23, 0);
    goto LABEL_35;
  }

LABEL_36:
  (*(void (**)(void))(*(void *)(v22 + 40) + 16LL))();
  if ((_dispatch_set_qos_class_enabled & 1) != 0)
  {
    unint64_t v25 = (unint64_t)_dispatch_thread_getspecific(4uLL);
    if ((v25 & 0x1000000) != 0) {
      unint64_t v26 = v25 & 0xFFFFFFFFFEFFFFFFLL;
    }
    else {
      unint64_t v26 = 0LL;
    }
  }

  else
  {
    unint64_t v26 = 0LL;
  }

  if (v26) {
    goto LABEL_47;
  }
  if (v19 == -1) {
    goto LABEL_48;
  }
  if ((void *)v19 != _dispatch_thread_getspecific(0x1CuLL))
  {
LABEL_47:
    _dispatch_set_priority_and_voucher_slow(v26, (_DWORD *)v19, 6);
    goto LABEL_48;
  }

  if (v19) {
    os_release((void *)v19);
  }
LABEL_48:
  if ((v20 & 8) == 0)
  {
    uint64_t v15 = (unsigned int *)(v22 + 20);
    unsigned int v16 = *(_DWORD *)(v22 + 20);
    do
    {
      unsigned int v9 = v16;
      do
        unsigned int v10 = __ldaxr(v15);
      while (v10 == v16 && __stlxr(v16 + 1, v15));
      unsigned int v16 = v10;
    }

    while (v10 != v9);
    if (!v10) {
      dispatch_group_leave(*(dispatch_group_t *)(v22 + 48));
    }
  }

  unint64_t v13 = (unint64_t *)(v22 + 56);
  unint64_t v14 = *(unsigned int **)(v22 + 56);
  do
  {
    __int128 v11 = v14;
    do
      unsigned int v12 = (unsigned int *)__ldaxr(v13);
    while (v12 == v14 && __stlxr(0LL, v13));
    unint64_t v14 = v12;
  }

  while (v12 != v11);
  if (v12) {
    _dispatch_release_2(v12);
  }
}

void _dispatch_release_2(unsigned int *a1)
{
  int v6 = a1[2];
  if (v6 != 0x7FFFFFFF)
  {
    uint64_t v3 = a1 + 2;
    unsigned int v4 = a1[2];
    do
    {
      unsigned int v1 = v4;
      do
        unsigned int v2 = __ldaxr(v3);
      while (v2 == v4 && __stlxr(v4 - 2, v3));
      unsigned int v4 = v2;
    }

    while (v2 != v1);
    int v6 = v2 - 2;
  }

  if (v6 < 1)
  {
    if (v6 < 0)
    {
      qword_E4D78 = (uint64_t)"API MISUSE: Over-release of an object";
      __break(1u);
      JUMPOUT(0x1A274LL);
    }

    int v5 = a1[3];
    if (v5 >= 1)
    {
      qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: Release while external references exist";
      qword_E4DA8 = v5;
      __break(1u);
      JUMPOUT(0x1A2D4LL);
    }

    _os_object_dispose(a1);
  }

void dispatch_block_cancel(dispatch_block_t block)
{
  if ((void (*)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))_Block_get_invoke_fn((uint64_t)block) == ___dispatch_block_create_block_invoke)
  {
    if (*((void *)block + 4) != 3512316172LL)
    {
      uint64_t v1 = *((void *)block + 4);
      qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Corruption of dispatch block object";
      qword_E4DA8 = v1;
      __break(1u);
      JUMPOUT(0x1A3C4LL);
    }

    uint64_t v7 = (char *)block + 32;
  }

  else
  {
    uint64_t v7 = 0LL;
  }

  if (!v7)
  {
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Invalid block object passed to dispatch_block_cancel()";
    __break(1u);
    JUMPOUT(0x1A40CLL);
  }

  unsigned int v4 = (unsigned int *)(v7 + 16);
  unsigned int v5 = *((_DWORD *)v7 + 4);
  do
  {
    unsigned int v2 = v5;
    do
      unsigned int v3 = __ldaxr(v4);
    while (v3 == v5 && __stlxr(v5 | 1, v4));
    unsigned int v5 = v3;
  }

  while (v3 != v2);
}

intptr_t dispatch_block_testcancel(dispatch_block_t block)
{
  if ((void (*)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))_Block_get_invoke_fn((uint64_t)block) == ___dispatch_block_create_block_invoke)
  {
    if (*((void *)block + 4) != 3512316172LL)
    {
      uint64_t v1 = *((void *)block + 4);
      qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Corruption of dispatch block object";
      qword_E4DA8 = v1;
      __break(1u);
      JUMPOUT(0x1A5BCLL);
    }

    unsigned int v4 = (char *)block + 32;
  }

  else
  {
    unsigned int v4 = 0LL;
  }

  if (!v4)
  {
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Invalid block object passed to dispatch_block_testcancel()";
    __break(1u);
    JUMPOUT(0x1A604LL);
  }

  return *((_DWORD *)v4 + 4) & 1LL;
}

intptr_t dispatch_block_wait(dispatch_block_t block, dispatch_time_t timeout)
{
  if ((void (*)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))_Block_get_invoke_fn((uint64_t)block) == ___dispatch_block_create_block_invoke)
  {
    if (*((void *)block + 4) != 3512316172LL)
    {
      uint64_t v2 = *((void *)block + 4);
      qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Corruption of dispatch block object";
      qword_E4DA8 = v2;
      __break(1u);
      JUMPOUT(0x1A700LL);
    }

    int v32 = (char *)block + 32;
  }

  else
  {
    int v32 = 0LL;
  }

  if (!v32)
  {
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Invalid block object passed to dispatch_block_wait()";
    __break(1u);
    JUMPOUT(0x1A748LL);
  }

  uint64_t v24 = (unsigned int *)(v32 + 16);
  unsigned int v25 = *((_DWORD *)v32 + 4);
  do
  {
    unsigned int v3 = v25;
    do
      unsigned int v4 = __ldaxr(v24);
    while (v4 == v25 && __stlxr(v25 | 2, v24));
    unsigned int v25 = v4;
  }

  while (v4 != v3);
  if ((v4 & 6) != 0)
  {
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: A block object may not be waited for more than once";
    qword_E4DA8 = v4;
    __break(1u);
    JUMPOUT(0x1A840LL);
  }

  unint64_t v29 = (unint64_t)_dispatch_thread_getspecific(4uLL);
  uint64_t v22 = (unint64_t *)(v32 + 56);
  unint64_t v23 = *((void *)v32 + 7);
  do
  {
    unint64_t v5 = v23;
    do
      unint64_t v6 = __ldaxr(v22);
    while (v6 == v23 && __stlxr(0LL, v22));
    unint64_t v21 = v6;
    unint64_t v23 = v6;
  }

  while (v6 != v5);
  if (v6)
  {
    unsigned int v7 = (v29 & 0x3FFF00) >> 8;
    unsigned int v8 = __clz(__rbit32(v7));
    if (v7) {
      uint64_t v9 = v8 + 1;
    }
    else {
      uint64_t v9 = 0LL;
    }
    (*(void (**)(unint64_t, uint64_t, uint64_t))(*(void *)v6 + 64LL))(v6, v9, 9LL);
  }

  unsigned int v28 = *((_DWORD *)v32 + 16);
  if (v28 && (_dispatch_set_qos_class_enabled & 1) != 0) {
    _pthread_qos_override_start_direct(v28, v29, v32);
  }
  int v27 = *((_DWORD *)v32 + 5);
  char v20 = 1;
  if (v27 <= 1)
  {
    BOOL v19 = 0;
    if (v28) {
      BOOL v19 = v21 != 0;
    }
    char v20 = v19;
  }

  if ((v20 & 1) != 0)
  {
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: A block object may not be both run more than once and waited for";
    qword_E4DA8 = v27;
    __break(1u);
    JUMPOUT(0x1AA9CLL);
  }

  intptr_t v26 = dispatch_group_wait(*((dispatch_group_t *)v32 + 6), timeout);
  if (v28 && (_dispatch_set_qos_class_enabled & 1) != 0) {
    _pthread_qos_override_end_direct(v28, v32);
  }
  if (v26)
  {
    unint64_t v17 = (unsigned int *)(v32 + 16);
    unsigned int v18 = *((_DWORD *)v32 + 4);
    do
    {
      unsigned int v10 = v18;
      do
        unsigned int v11 = __ldaxr(v17);
      while (v11 == v18 && __stlxr(v18 & 0xFFFFFFFD, v17));
      unsigned int v18 = v11;
    }

    while (v11 != v10);
  }

  else
  {
    uint64_t v15 = (unsigned int *)(v32 + 16);
    unsigned int v16 = *((_DWORD *)v32 + 4);
    do
    {
      unsigned int v12 = v16;
      do
        unsigned int v13 = __ldaxr(v15);
      while (v13 == v16 && __stlxr(v16 | 4, v15));
      unsigned int v16 = v13;
    }

    while (v13 != v12);
  }

  return v26;
}

void dispatch_block_notify(dispatch_block_t block, dispatch_queue_t queue, dispatch_block_t notification_block)
{
  if ((void (*)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))_Block_get_invoke_fn((uint64_t)block) == ___dispatch_block_create_block_invoke)
  {
    if (*((void *)block + 4) != 3512316172LL)
    {
      uint64_t v3 = *((void *)block + 4);
      qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Corruption of dispatch block object";
      qword_E4DA8 = v3;
      __break(1u);
      JUMPOUT(0x1AD9CLL);
    }

    uint64_t v9 = (char *)block + 32;
  }

  else
  {
    uint64_t v9 = 0LL;
  }

  if (!v9)
  {
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Invalid block object passed to dispatch_block_notify()";
    qword_E4DA8 = (uint64_t)block;
    __break(1u);
    JUMPOUT(0x1ADFCLL);
  }

  int v4 = *((_DWORD *)v9 + 5);
  if (v4 >= 2)
  {
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: A block object may not be both run more than once and observed";
    qword_E4DA8 = v4;
    __break(1u);
    JUMPOUT(0x1AE80LL);
  }

  dispatch_group_notify(*((dispatch_group_t *)v9 + 6), queue, notification_block);
}

uint64_t _dispatch_continuation_init_slow(uint64_t *a1, unsigned int *a2, int a3)
{
  uint64_t v39 = a1[5];
  if ((void (*)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))_Block_get_invoke_fn(v39) == ___dispatch_block_create_block_invoke)
  {
    if (*(void *)(v39 + 32) != 3512316172LL)
    {
      uint64_t v3 = *(void *)(v39 + 32);
      qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Corruption of dispatch block object";
      qword_E4DA8 = v3;
      __break(1u);
      JUMPOUT(0x1AF8CLL);
    }

    unsigned int v40 = (void *)(v39 + 32);
  }

  else
  {
    unsigned int v40 = 0LL;
  }

  uint64_t v34 = v40[1];
  uint64_t v33 = *a1;
  _dispatch_retain_2((uint64_t)a2);
  unsigned int v10 = v40 + 7;
  do
    unint64_t v11 = __ldaxr(v10);
  while (!v11 && __stlxr((unint64_t)a2, v10));
  if (v11) {
    _dispatch_release_2(a2);
  }
  if ((v33 & 4) != 0) {
    a1[4] = (uint64_t)_dispatch_block_async_invoke_and_release;
  }
  else {
    a1[4] = (uint64_t)_dispatch_block_async_invoke;
  }
  int v36 = a3 | v34;
  if ((v34 & 0x40000000) != 0)
  {
    uint64_t v32 = v40[3] & 0xFFFFFFLL;
  }

  else if ((v36 & 0x40000000) != 0)
  {
    uint64_t v32 = 0LL;
  }

  else
  {
    unint64_t v46 = (unint64_t)_dispatch_thread_getspecific(4uLL) & 0xFFFFFF;
    if (v46 <= 0x10FF) {
      uint64_t v47 = v46;
    }
    else {
      uint64_t v47 = 4351LL;
    }
    uint64_t v32 = v47;
  }

  uint64_t v42 = v32;
  if (v32)
  {
    if ((v36 & 0x20) != 0)
    {
      uint64_t v42 = v32 | 0x10000000;
    }

    else if ((a2[21] & 0x40000000) == 0 && (a2[21] & 0xFFF) != 0)
    {
      uint64_t v42 = 0LL;
    }
  }

  a1[1] = v42;
  if ((v34 & 1) != 0) {
    v33 |= 2uLL;
  }
  if ((v34 & 0x80000000LL) != 0)
  {
    unint64_t v31 = (void *)v40[4];
    if (!v31 || v31 == (void *)-1LL)
    {
      uint64_t v30 = v40[4];
    }

    else
    {
      os_retain(v31);
      uint64_t v30 = (uint64_t)v31;
    }

    a1[3] = v30;
    _dispatch_thread_getspecific(0LL);
    _dispatch_log("%u\t%p\tvoucher[%p]: continuation[%p] set", v12, v13, v14, v15, v16, v17, v18, 746LL);
    uint64_t v43 = a1[3];
    if (v43 != -1)
    {
      unsigned int v29 = v43 ? *(_DWORD *)(v43 + 32) : 0;
      if (MEMORY[0xFFFFFC100]) {
        kdebug_trace(771817476LL, v29, a1, 0LL, 0LL);
      }
    }
  }

  else
  {
    uint64_t v44 = 0LL;
    if (v36 < 0) {
      _dispatch_abort(583LL, v36 >= 0, v4, v5, v6, v7, v8, v9);
    }
    if ((v36 & 0x40) == 0)
    {
      unint64_t v48 = _dispatch_thread_getspecific(0x1CuLL);
      if (v48) {
        os_retain(v48);
      }
      uint64_t v44 = (uint64_t)v48;
    }

    a1[3] = v44;
    _dispatch_thread_getspecific(0LL);
    _dispatch_log("%u\t%p\tvoucher[%p]: continuation[%p] set", v19, v20, v21, v22, v23, v24, v25, 589LL);
    uint64_t v45 = a1[3];
    if (v45 != -1)
    {
      unsigned int v28 = v45 ? *(_DWORD *)(v45 + 32) : 0;
      if (MEMORY[0xFFFFFC100]) {
        kdebug_trace(771817476LL, v28, a1, 0LL, 0LL);
      }
    }
  }

  *a1 = v33 | 0x20;
  unint64_t v41 = (a1[1] & 0x3FFF00uLL) >> 8;
  unsigned int v26 = __clz(__rbit32(v41));
  if ((_DWORD)v41) {
    return v26 + 1;
  }
  else {
    return 0LL;
  }
}

void _dispatch_block_async_invoke_and_release(void *a1)
{
}

void _dispatch_block_async_invoke(void *a1)
{
}

void dispatch_barrier_async_f(dispatch_queue_t queue, void *context, dispatch_function_t work)
{
  uint64_t v17 = _dispatch_thread_getspecific(0x16uLL);
  if (v17)
  {
    _dispatch_thread_setspecific(22LL, v17[2]);
    *uint64_t v17 = 262LL;
    v17[4] = work;
    v17[5] = context;
    unint64_t v21 = (unint64_t)_dispatch_thread_getspecific(4uLL) & 0xFFFFFF;
    if (v21 <= 0x10FF) {
      unint64_t v22 = v21;
    }
    else {
      unint64_t v22 = 4351LL;
    }
    uint64_t v23 = _dispatch_thread_getspecific(0x1CuLL);
    if (v23) {
      os_retain(v23);
    }
    v17[3] = v23;
    _dispatch_thread_getspecific(0LL);
    _dispatch_log("%u\t%p\tvoucher[%p]: continuation[%p] set", v3, v4, v5, v6, v7, v8, v9, 589LL);
    uint64_t v20 = v17[3];
    if (v20 != -1)
    {
      unsigned int v13 = v20 ? *(_DWORD *)(v20 + 32) : 0;
      if (MEMORY[0xFFFFFC100]) {
        kdebug_trace(771817476LL, v13, v17, 0LL, 0LL);
      }
    }

    unint64_t v19 = v22;
    unsigned int v18 = 0;
    if (v22)
    {
      if ((*((_DWORD *)queue + 21) & 0x40000000) != 0 || (*((_DWORD *)queue + 21) & 0xFFF) == 0)
      {
        unsigned int v10 = v22 >> 8;
        unsigned int v11 = __clz(__rbit32(v10));
        if (v10) {
          unsigned int v12 = v11 + 1;
        }
        else {
          unsigned int v12 = 0;
        }
        unsigned int v18 = v12;
      }

      else
      {
        unint64_t v19 = 0LL;
      }
    }

    v17[1] = v19;
    (*(void (**)(dispatch_queue_t, void *, void))(*(void *)queue + 72LL))(queue, v17, v18);
  }

  else
  {
    _dispatch_async_f_slow(queue, (uint64_t)context, (uint64_t)work, 0, 6LL);
  }

uint64_t _dispatch_async_f_slow(_DWORD *a1, uint64_t a2, uint64_t a3, int a4, uint64_t a5)
{
  unsigned int v26 = (void *)_dispatch_continuation_alloc_from_heap();
  unint64_t v32 = 0LL;
  *unsigned int v26 = a5 | 0x100;
  v26[4] = a3;
  v26[5] = a2;
  if ((a4 & 0x40000000) == 0)
  {
    unint64_t v37 = (unint64_t)_dispatch_thread_getspecific(4uLL) & 0xFFFFFF;
    if (v37 <= 0x10FF) {
      uint64_t v38 = v37;
    }
    else {
      uint64_t v38 = 4351LL;
    }
    unint64_t v32 = v38;
  }

  uint64_t v35 = 0LL;
  if (a4 < 0) {
    _dispatch_abort(583LL, a4 >= 0, v5, v6, v7, v8, v9, v10);
  }
  if ((a4 & 0x40) == 0)
  {
    uint64_t v39 = _dispatch_thread_getspecific(0x1CuLL);
    if (v39) {
      os_retain(v39);
    }
    uint64_t v35 = v39;
  }

  v26[3] = v35;
  _dispatch_thread_getspecific(0LL);
  _dispatch_log("%u\t%p\tvoucher[%p]: continuation[%p] set", v11, v12, v13, v14, v15, v16, v17, 589LL);
  uint64_t v36 = v26[3];
  if (v36 != -1)
  {
    unsigned int v25 = v36 ? *(_DWORD *)(v36 + 32) : 0;
    if (MEMORY[0xFFFFFC100]) {
      kdebug_trace(771817476LL, v25, v26, 0LL, 0LL);
    }
  }

  uint64_t v34 = v32;
  unsigned int v33 = 0;
  if (v32)
  {
    if ((a4 & 0x20) != 0)
    {
      uint64_t v34 = v32 | 0x10000000;
      unsigned int v18 = (v32 | 0x10000000) >> 8;
      unsigned int v19 = __clz(__rbit32(v18));
      if (v18) {
        unsigned int v20 = v19 + 1;
      }
      else {
        unsigned int v20 = 0;
      }
      unsigned int v33 = v20;
    }

    else if ((a1[21] & 0x40000000) != 0 || (a1[21] & 0xFFF) == 0)
    {
      unsigned int v21 = v32 >> 8;
      unsigned int v22 = __clz(__rbit32(v21));
      if (v21) {
        unsigned int v23 = v22 + 1;
      }
      else {
        unsigned int v23 = 0;
      }
      unsigned int v33 = v23;
    }

    else
    {
      uint64_t v34 = 0LL;
    }
  }

  v26[1] = v34;
  return (*(uint64_t (**)(_DWORD *, void *, void))(*(void *)a1 + 72LL))(a1, v26, v33);
}

uint64_t _dispatch_barrier_async_detached_f(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v11 = _dispatch_thread_getspecific(0x16uLL);
  if (v11)
  {
    _dispatch_thread_setspecific(22LL, v11[2]);
    uint64_t v10 = v11;
  }

  else
  {
    uint64_t v10 = (void *)_dispatch_continuation_alloc_from_heap();
  }

  void *v10 = 262LL;
  v10[4] = a3;
  v10[5] = a2;
  v10[3] = -1LL;
  v10[1] = -1LL;
  return (*(uint64_t (**)(uint64_t, void *, void, uint64_t, uint64_t, uint64_t))(*(void *)a1 + 72LL))( a1,  v10,  0LL,  v3,  v4,  v5);
}

void dispatch_barrier_async(dispatch_queue_t queue, dispatch_block_t block)
{
  uint64_t v16 = (uint64_t *)_dispatch_thread_getspecific(0x16uLL);
  if (v16)
  {
    _dispatch_thread_setspecific(22LL, v16[2]);
    uint64_t v15 = v16;
  }

  else
  {
    uint64_t v15 = (uint64_t *)_dispatch_continuation_alloc_from_heap();
  }

  uint64_t v17 = _dispatch_Block_copy(block);
  if ((void (*)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))_Block_get_invoke_fn((uint64_t)block) == ___dispatch_block_create_block_invoke)
  {
    *uint64_t v15 = 278LL;
    v15[5] = (uint64_t)v17;
    unsigned int inited = _dispatch_continuation_init_slow(v15, (unsigned int *)queue, 0);
  }

  else
  {
    _Block_get_invoke_fn((uint64_t)block);
    *uint64_t v15 = 278LL;
    v15[4] = (uint64_t)_dispatch_call_block_and_release;
    v15[5] = (uint64_t)v17;
    unint64_t v22 = (unint64_t)_dispatch_thread_getspecific(4uLL) & 0xFFFFFF;
    if (v22 <= 0x10FF) {
      unint64_t v23 = v22;
    }
    else {
      unint64_t v23 = 4351LL;
    }
    uint64_t v24 = _dispatch_thread_getspecific(0x1CuLL);
    if (v24) {
      os_retain(v24);
    }
    v15[3] = (uint64_t)v24;
    _dispatch_thread_getspecific(0LL);
    _dispatch_log("%u\t%p\tvoucher[%p]: continuation[%p] set", v2, v3, v4, v5, v6, v7, v8, 589LL);
    uint64_t v21 = v15[3];
    if (v21 != -1)
    {
      unsigned int v12 = v21 ? *(_DWORD *)(v21 + 32) : 0;
      if (MEMORY[0xFFFFFC100]) {
        kdebug_trace(771817476LL, v12, v15, 0LL, 0LL);
      }
    }

    unint64_t v20 = v23;
    unsigned int v19 = 0;
    if (v23)
    {
      if ((*((_DWORD *)queue + 21) & 0x40000000) != 0 || (*((_DWORD *)queue + 21) & 0xFFF) == 0)
      {
        unsigned int v9 = v23 >> 8;
        unsigned int v10 = __clz(__rbit32(v9));
        if (v9) {
          unsigned int v11 = v10 + 1;
        }
        else {
          unsigned int v11 = 0;
        }
        unsigned int v19 = v11;
      }

      else
      {
        unint64_t v20 = 0LL;
      }
    }

    v15[1] = v20;
    unsigned int inited = v19;
  }

  (*(void (**)(dispatch_queue_t, uint64_t *, void))(*(void *)queue + 72LL))(queue, v15, inited);
}

void dispatch_channel_async_f(dispatch_queue_t queue, void *context, dispatch_function_t work)
{
  uint64_t v17 = _dispatch_thread_getspecific(0x16uLL);
  if (v17)
  {
    _dispatch_thread_setspecific(22LL, v17[2]);
    *uint64_t v17 = 260LL;
    v17[4] = work;
    v17[5] = context;
    unint64_t v21 = (unint64_t)_dispatch_thread_getspecific(4uLL) & 0xFFFFFF;
    if (v21 <= 0x10FF) {
      unint64_t v22 = v21;
    }
    else {
      unint64_t v22 = 4351LL;
    }
    unint64_t v23 = _dispatch_thread_getspecific(0x1CuLL);
    if (v23) {
      os_retain(v23);
    }
    v17[3] = v23;
    _dispatch_thread_getspecific(0LL);
    _dispatch_log("%u\t%p\tvoucher[%p]: continuation[%p] set", v3, v4, v5, v6, v7, v8, v9, 589LL);
    uint64_t v20 = v17[3];
    if (v20 != -1)
    {
      unsigned int v13 = v20 ? *(_DWORD *)(v20 + 32) : 0;
      if (MEMORY[0xFFFFFC100]) {
        kdebug_trace(771817476LL, v13, v17, 0LL, 0LL);
      }
    }

    unint64_t v19 = v22;
    unsigned int v18 = 0;
    if (v22)
    {
      if ((*((_DWORD *)queue + 21) & 0x40000000) != 0 || (*((_DWORD *)queue + 21) & 0xFFF) == 0)
      {
        unsigned int v10 = v22 >> 8;
        unsigned int v11 = __clz(__rbit32(v10));
        if (v10) {
          unsigned int v12 = v11 + 1;
        }
        else {
          unsigned int v12 = 0;
        }
        unsigned int v18 = v12;
      }

      else
      {
        unint64_t v19 = 0LL;
      }
    }

    v17[1] = v19;
    (*(void (**)(dispatch_queue_t, void *, void))(*(void *)queue + 72LL))(queue, v17, v18);
  }

  else
  {
    _dispatch_async_f_slow(queue, (uint64_t)context, (uint64_t)work, 0, 4LL);
  }

uint64_t dispatch_async_enforce_qos_class_f(_DWORD *a1, uint64_t a2, uint64_t a3)
{
  unsigned int v18 = _dispatch_thread_getspecific(0x16uLL);
  if (!v18) {
    return _dispatch_async_f_slow(a1, a2, a3, 32, 4LL);
  }
  _dispatch_thread_setspecific(22LL, v18[2]);
  *unsigned int v18 = 260LL;
  v18[4] = a3;
  v18[5] = a2;
  unint64_t v22 = (unint64_t)_dispatch_thread_getspecific(4uLL) & 0xFFFFFF;
  if (v22 <= 0x10FF) {
    uint64_t v23 = v22;
  }
  else {
    uint64_t v23 = 4351LL;
  }
  uint64_t v24 = _dispatch_thread_getspecific(0x1CuLL);
  if (v24) {
    os_retain(v24);
  }
  v18[3] = v24;
  _dispatch_thread_getspecific(0LL);
  _dispatch_log("%u\t%p\tvoucher[%p]: continuation[%p] set", v4, v5, v6, v7, v8, v9, v10, 589LL);
  uint64_t v21 = v18[3];
  if (v21 != -1)
  {
    unsigned int v14 = v21 ? *(_DWORD *)(v21 + 32) : 0;
    if (MEMORY[0xFFFFFC100]) {
      kdebug_trace(771817476LL, v14, v18, 0LL, 0LL);
    }
  }

  uint64_t v20 = v23;
  unsigned int v19 = 0;
  if (v23)
  {
    uint64_t v20 = v23 | 0x10000000;
    unsigned int v11 = (v23 | 0x10000000uLL) >> 8;
    unsigned int v12 = __clz(__rbit32(v11));
    if (v11) {
      unsigned int v13 = v12 + 1;
    }
    else {
      unsigned int v13 = 0;
    }
    unsigned int v19 = v13;
  }

  v18[1] = v20;
  return (*(uint64_t (**)(_DWORD *, void *, void))(*(void *)a1 + 72LL))(a1, v18, v19);
}

void dispatch_channel_async(dispatch_queue_t queue, dispatch_block_t block)
{
  uint64_t v16 = (uint64_t *)_dispatch_thread_getspecific(0x16uLL);
  if (v16)
  {
    _dispatch_thread_setspecific(22LL, v16[2]);
    uint64_t v15 = v16;
  }

  else
  {
    uint64_t v15 = (uint64_t *)_dispatch_continuation_alloc_from_heap();
  }

  uint64_t v17 = _dispatch_Block_copy(block);
  if ((void (*)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))_Block_get_invoke_fn((uint64_t)block) == ___dispatch_block_create_block_invoke)
  {
    *uint64_t v15 = 276LL;
    v15[5] = (uint64_t)v17;
    unsigned int inited = _dispatch_continuation_init_slow(v15, (unsigned int *)queue, 0);
  }

  else
  {
    _Block_get_invoke_fn((uint64_t)block);
    *uint64_t v15 = 276LL;
    v15[4] = (uint64_t)_dispatch_call_block_and_release;
    v15[5] = (uint64_t)v17;
    unint64_t v22 = (unint64_t)_dispatch_thread_getspecific(4uLL) & 0xFFFFFF;
    if (v22 <= 0x10FF) {
      unint64_t v23 = v22;
    }
    else {
      unint64_t v23 = 4351LL;
    }
    uint64_t v24 = _dispatch_thread_getspecific(0x1CuLL);
    if (v24) {
      os_retain(v24);
    }
    v15[3] = (uint64_t)v24;
    _dispatch_thread_getspecific(0LL);
    _dispatch_log("%u\t%p\tvoucher[%p]: continuation[%p] set", v2, v3, v4, v5, v6, v7, v8, 589LL);
    uint64_t v21 = v15[3];
    if (v21 != -1)
    {
      unsigned int v12 = v21 ? *(_DWORD *)(v21 + 32) : 0;
      if (MEMORY[0xFFFFFC100]) {
        kdebug_trace(771817476LL, v12, v15, 0LL, 0LL);
      }
    }

    unint64_t v20 = v23;
    unsigned int v19 = 0;
    if (v23)
    {
      if ((*((_DWORD *)queue + 21) & 0x40000000) != 0 || (*((_DWORD *)queue + 21) & 0xFFF) == 0)
      {
        unsigned int v9 = v23 >> 8;
        unsigned int v10 = __clz(__rbit32(v9));
        if (v9) {
          unsigned int v11 = v10 + 1;
        }
        else {
          unsigned int v11 = 0;
        }
        unsigned int v19 = v11;
      }

      else
      {
        unint64_t v20 = 0LL;
      }
    }

    v15[1] = v20;
    unsigned int inited = v19;
  }

  (*(void (**)(dispatch_queue_t, uint64_t *, void))(*(void *)queue + 72LL))(queue, v15, inited);
}

uint64_t _dispatch_barrier_trysync_or_async_f( uint64_t a1, uint64_t a2, uint64_t (*a3)(uint64_t), unsigned int a4)
{
  unsigned int v4 = _dispatch_thread_getspecific(3uLL);
  uint64_t v19 = (4096LL - *(unsigned __int16 *)(a1 + 80)) << 41;
  unint64_t v18 = v4 & 0xFFFFFFFC | 0x60000000000002LL | ((unint64_t)((a4 & 1) != 0) << 58);
  BOOL v16 = 0;
  uint64_t v15 = (unint64_t *)(a1 + 56);
  while (1)
  {
    unint64_t v9 = _os_atomic_mo_has_acquire(2) ? __ldaxr(v15) : __ldxr(v15);
    if (v9 != (v19 | v9 & 0x3000000000LL)) {
      break;
    }
    unint64_t v17 = v18 | v9 & 0x3000000000LL;
    if (_os_atomic_mo_has_release(2)) {
      BOOL v16 = __stlxr(v17, v15) == 0;
    }
    else {
      BOOL v16 = __stxr(v17, v15) == 0;
    }
    if (v16) {
      goto LABEL_11;
    }
  }

  __clrex();
LABEL_11:
  if (!v16) {
    return _dispatch_barrier_async_detached_f(a1, a2, (uint64_t)a3);
  }
  if ((a4 & 1) != 0) {
    _dispatch_retain_2(a1);
  }
  return _dispatch_barrier_trysync_or_async_f_complete((unint64_t *)a1, a2, a3, a4, v5, v6, v7, v8);
}

uint64_t _dispatch_retain_2(uint64_t result)
{
  int v5 = *(_DWORD *)(result + 8);
  if (v5 != 0x7FFFFFFF)
  {
    uint64_t v3 = (unsigned int *)(result + 8);
    unsigned int v4 = *(_DWORD *)(result + 8);
    do
    {
      unsigned int v1 = v4;
      do
        unsigned int v2 = __ldaxr(v3);
      while (v2 == v4 && __stlxr(v4 + 2, v3));
      unsigned int v4 = v2;
    }

    while (v2 != v1);
    int v5 = v2;
  }

  if (v5 <= 0)
  {
    qword_E4D78 = (uint64_t)"API MISUSE: Resurrection of an object";
    __break(1u);
    JUMPOUT(0x1E59CLL);
  }

  return result;
}

uint64_t _dispatch_barrier_trysync_or_async_f_complete( unint64_t *a1, uint64_t a2, uint64_t (*a3)(uint64_t), uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  char v24 = a4;
  unsigned int v23 = 4;
  unsigned int v29 = a1;
  uint64_t v28 = a2;
  int v27 = a3;
  __int128 v26 = 0uLL;
  uint64_t v42 = a1;
  unint64_t v41 = &v26;
  uint64_t v44 = &v26;
  _dispatch_thread_getspecific_packed_pair(20LL, 21LL, &v26, a4, a5, a6, a7, a8);
  _dispatch_thread_setspecific_pair(20LL, (uint64_t)v42, 21LL, (uint64_t)v41, v8, v9, v10, v11);
  uint64_t v36 = v28;
  uint64_t v35 = v27;
  uint64_t v34 = 0LL;
  else {
    unint64_t v22 = v35;
  }
  uint64_t v34 = v22;
  uint64_t v38 = v36;
  unint64_t v37 = v22;
  int v33 = 0;
  int v32 = 0;
  int v31 = 0;
  int v30 = 0;
  _dispatch_client_callout(v36, v35);
  uint64_t v40 = v36;
  uint64_t v39 = v34;
  uint64_t v43 = &v26;
  _dispatch_thread_setspecific_packed_pair(20LL, 21LL, &v26, v12, v13, v14, v15, v16);
  if ((v24 & 1) != 0)
  {
    unint64_t v20 = a1 + 7;
    unint64_t v21 = a1[7];
    do
    {
      unint64_t v17 = v21;
      do
        unint64_t v18 = __ldaxr(v20);
      while (v18 == v21 && __stlxr(v21 - 0x400000000000000LL, v20));
      unint64_t v21 = v18;
    }

    while (v18 != v17);
    if (((v18 - 0x400000000000000LL) & 0xFF80000000000000LL) == 0) {
      unsigned int v23 = 5;
    }
  }

  return (*(uint64_t (**)(unint64_t *, void, void))(*a1 + 64))(a1, 0LL, v23);
}

void dispatch_barrier_sync_f(dispatch_queue_t queue, void *context, dispatch_function_t work)
{
  *(_DWORD *)&v9[8] = 0;
  *(void *)uint64_t v9 = _dispatch_thread_getspecific(3uLL);
  if (*(_BYTE *)(*(void *)queue + 16LL) != 17LL) {
    goto LABEL_5;
  }
  LOBYTE(v8) = 0;
  if ((*((_DWORD *)queue + 20) & 0x1000000) != 0) {
    int v8 = (BYTE2(*((_DWORD *)queue + 20)) >> 2) & 1;
  }
  if ((v8 & 1) == 0) {
    char v13 = 1;
  }
  else {
LABEL_5:
  }
    char v13 = 0;
  if ((v13 & 1) == 0)
  {
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Queue type doesn't support dispatch_sync";
    __break(1u);
    JUMPOUT(0x1EAB4LL);
  }

  unint64_t v17 = (unint64_t)(4096 - *((unsigned __int16 *)queue + 40)) << 41;
  BOOL v15 = 0;
  uint64_t v14 = (unint64_t *)((char *)queue + 56);
  while (1)
  {
    unint64_t v7 = _os_atomic_mo_has_acquire(2) ? __ldaxr(v14) : __ldxr(v14);
    if (v7 != (v17 | v7 & 0x3000000000LL)) {
      break;
    }
    unint64_t v16 = *(_DWORD *)v9 & 0xFFFFFFFC | 0x60000000000002LL | v7 & 0x3000000000LL;
    if (_os_atomic_mo_has_release(2)) {
      BOOL v15 = __stlxr(v16, v14) == 0;
    }
    else {
      BOOL v15 = __stxr(v16, v14) == 0;
    }
    if (v15) {
      goto LABEL_19;
    }
  }

  __clrex();
LABEL_19:
  if (v15)
  {
    if (*(void *)(*((void *)queue + 3) + 24LL)) {
      _dispatch_sync_recurse( (uint64_t)queue,  (uint64_t)context,  (uint64_t (*)(uint64_t))work,  *(void *)&v9[4] | 2LL);
    }
    else {
      _dispatch_lane_barrier_sync_invoke_and_complete( (uint64_t)queue,  (uint64_t)context,  (uint64_t (*)(uint64_t))work,  0LL,  v3,  v4,  v5,  v6);
    }
  }

  else
  {
    _dispatch_sync_f_slow( (uint64_t)queue,  (uint64_t)context,  (uint64_t (*)(uint64_t))work,  2LL,  (uint64_t)queue,  *(void *)&v9[4] | 2LL,  v5,  v6);
  }

void dispatch_sync_f(dispatch_queue_t queue, void *context, dispatch_function_t work)
{
  if (*((_WORD *)queue + 40) == 1)
  {
    _dispatch_barrier_sync_f((uint64_t)queue, (uint64_t)context, (uint64_t (*)(uint64_t))work, 0LL);
  }

  else
  {
    if (*(_BYTE *)(*(void *)queue + 16LL) != 17LL) {
      goto LABEL_7;
    }
    LOBYTE(v8) = 0;
    if ((*((_DWORD *)queue + 20) & 0x1000000) != 0) {
      int v8 = (BYTE2(*((_DWORD *)queue + 20)) >> 2) & 1;
    }
    if ((v8 & 1) == 0) {
      char v12 = 1;
    }
    else {
LABEL_7:
    }
      char v12 = 0;
    if ((v12 & 1) == 0)
    {
      qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Queue type doesn't support dispatch_sync";
      __break(1u);
      JUMPOUT(0x1EEC4LL);
    }

    if (*((void *)queue + 6))
    {
      char v16 = 0;
    }

    else
    {
      char v13 = (unint64_t *)((char *)queue + 56);
      do
      {
        if (_os_atomic_mo_has_acquire(0)) {
          unint64_t v7 = __ldaxr(v13);
        }
        else {
          unint64_t v7 = __ldxr(v13);
        }
        if (v7 >> 54 || (v7 & 0x8000000000LL) != 0 || (v7 & 0x10000000000LL) != 0)
        {
          __clrex();
          char v16 = 0;
          goto LABEL_26;
        }

        unint64_t v15 = v7 + 0x20000000000LL;
        if (_os_atomic_mo_has_release(0)) {
          BOOL v14 = __stlxr(v15, v13) == 0;
        }
        else {
          BOOL v14 = __stxr(v15, v13) == 0;
        }
      }

      while (!v14);
      char v16 = 1;
    }

LABEL_26:
    if ((v16 & 1) != 0)
    {
      if (*(void *)(*((void *)queue + 3) + 24LL)) {
        _dispatch_sync_recurse((uint64_t)queue, (uint64_t)context, (uint64_t (*)(uint64_t))work, 0LL);
      }
      else {
        _dispatch_sync_invoke_and_complete( (uint64_t)queue,  (uint64_t)context,  (uint64_t (*)(uint64_t))work,  0LL,  v3,  v4,  v5,  v6);
      }
    }

    else
    {
      _dispatch_sync_f_slow( (uint64_t)queue,  (uint64_t)context,  (uint64_t (*)(uint64_t))work,  0LL,  (uint64_t)queue,  0LL,  v5,  v6);
    }
  }

    if ((v18 & 1) != 0)
    {
      if (*(void *)(*(void *)(a1 + 24) + 24LL)) {
        _dispatch_sync_recurse(a1, a2, a3, a4);
      }
      else {
        _dispatch_sync_invoke_and_complete(a1, a2, a3, 0LL, a5, a6, a7, a8);
      }
    }

    else
    {
      _dispatch_sync_f_slow(a1, a2, a3, 0LL, a1, a4, a7, a8);
    }
  }

void dispatch_barrier_sync(dispatch_queue_t queue, dispatch_block_t block)
{
  if ((void (*)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))_Block_get_invoke_fn((uint64_t)block) == ___dispatch_block_create_block_invoke)
  {
    _dispatch_sync_block_with_privdata((unsigned int *)queue, (uint64_t)block, 18LL);
  }

  else
  {
    unsigned int v2 = (uint64_t (*)(uint64_t))_Block_get_invoke_fn((uint64_t)block);
    _dispatch_barrier_sync_f((uint64_t)queue, (uint64_t)block, v2, 18LL);
  }

void _dispatch_sync_block_with_privdata(unsigned int *a1, uint64_t a2, uint64_t a3)
{
  if ((void (*)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))_Block_get_invoke_fn(a2) == ___dispatch_block_create_block_invoke)
  {
    if (*(void *)(a2 + 32) != 3512316172LL)
    {
      uint64_t v9 = *(void *)(a2 + 32);
      qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Corruption of dispatch block object";
      qword_E4DA8 = v9;
      __break(1u);
      JUMPOUT(0x1F2B8LL);
    }

    int v31 = (void *)(a2 + 32);
  }

  else
  {
    int v31 = 0LL;
  }

  uint64_t v21 = 0LL;
  uint64_t v20 = v31[1];
  if ((v20 & 1) != 0) {
    uint64_t v23 = a3 | 0x22;
  }
  else {
    uint64_t v23 = a3 | 0x20;
  }
  uint64_t v26 = 0LL;
  if ((v20 & 0x40000000) != 0 && ((v20 & 0x20) != 0 || (v20 & 0x10) == 0))
  {
    unint64_t v27 = v31[3] & 0xFFFFFFLL;
    uint64_t v28 = _dispatch_thread_getspecific(4uLL);
  }

  if (v26) {
    uint64_t v21 = v31[3];
  }
  uint64_t v19 = -1LL;
  if ((v20 & 0x80000000LL) != 0) {
    uint64_t v19 = v31[4];
  }
  if (v21 == -1) {
    _dispatch_abort(2395LL, 0LL, v3, v4, v5, v6, v7, v8);
  }
  if ((_dispatch_set_qos_class_enabled & 1) != 0)
  {
    unint64_t v34 = v21 & 0xFFFFFFFF02FFFFFFLL;
    unint64_t v10 = (unint64_t)_dispatch_thread_getspecific(4uLL);
    if ((v10 & 0x1000000) != 0)
    {
      if (v34) {
        unint64_t v18 = v21 & 0xFFFFFFFF02FFFFFFLL;
      }
      else {
        unint64_t v18 = v10 & 0xFFFFFFFFFEFFFFFFLL;
      }
      unint64_t v35 = v18;
    }

    else if (v34 == (v10 & 0xFFFFFFFF77FFFFFFLL))
    {
      unint64_t v35 = 0LL;
    }

    else
    {
      unint64_t v35 = v21 & 0xFFFFFFFF02FFFFFFLL;
    }
  }

  else
  {
    unint64_t v35 = 0LL;
  }

  if (!v35)
  {
    if (v19 == -1)
    {
      uint64_t v29 = -1LL;
      goto LABEL_39;
    }

    if ((void *)v19 == _dispatch_thread_getspecific(0x1CuLL))
    {
      if (v19) {
        os_retain((void *)v19);
      }
      uint64_t v29 = v19;
      goto LABEL_39;
    }
  }

  uint64_t v29 = _dispatch_set_priority_and_voucher_slow(v35, (_DWORD *)v19, 0);
LABEL_39:
  _dispatch_retain_2((uint64_t)a1);
  unint64_t v15 = v31 + 7;
  do
    unint64_t v16 = __ldaxr(v15);
  while (!v16 && __stlxr((unint64_t)a1, v15));
  if (v16) {
    _dispatch_release_2(a1);
  }
  if ((v23 & 2) != 0) {
    _dispatch_barrier_sync_f((uint64_t)a1, a2, (uint64_t (*)(uint64_t))_dispatch_block_sync_invoke, v23);
  }
  else {
    _dispatch_sync_f( (uint64_t)a1,  a2,  (uint64_t (*)(uint64_t))_dispatch_block_sync_invoke,  v23,  v11,  v12,  v13,  v14);
  }
  if ((_dispatch_set_qos_class_enabled & 1) != 0)
  {
    unint64_t v32 = (unint64_t)_dispatch_thread_getspecific(4uLL);
    if ((v32 & 0x1000000) != 0)
    {
      if ((v26 & 0x2FFFFFF) != 0) {
        unint64_t v17 = v26 & 0x2FFFFFF;
      }
      else {
        unint64_t v17 = v32 & 0xFFFFFFFFFEFFFFFFLL;
      }
      unint64_t v33 = v17;
    }

    else if ((v26 & 0x2FFFFFF) == (v32 & 0xFFFFFFFF77FFFFFFLL))
    {
      unint64_t v33 = 0LL;
    }

    else
    {
      unint64_t v33 = v26 & 0xFFFFFFFF02FFFFFFLL;
    }
  }

  else
  {
    unint64_t v33 = 0LL;
  }

  if (v33) {
    goto LABEL_63;
  }
  if (v29 == -1) {
    return;
  }
  if ((void *)v29 != _dispatch_thread_getspecific(0x1CuLL))
  {
LABEL_63:
    _dispatch_set_priority_and_voucher_slow(v33, (_DWORD *)v29, 6);
  }

  else if (v29)
  {
    os_release((void *)v29);
  }

void _dispatch_barrier_sync_f(uint64_t a1, uint64_t a2, uint64_t (*a3)(uint64_t), uint64_t a4)
{
  unsigned int v10 = _dispatch_thread_getspecific(3uLL);
  if (*(_BYTE *)(*(void *)a1 + 16LL) != 17LL) {
    goto LABEL_5;
  }
  LOBYTE(v9) = 0;
  if ((*(_DWORD *)(a1 + 80) & 0x1000000) != 0) {
    int v9 = (BYTE2(*(_DWORD *)(a1 + 80)) >> 2) & 1;
  }
  if ((v9 & 1) == 0) {
    char v15 = 1;
  }
  else {
LABEL_5:
  }
    char v15 = 0;
  if ((v15 & 1) == 0)
  {
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Queue type doesn't support dispatch_sync";
    __break(1u);
    JUMPOUT(0x1FC88LL);
  }

  unint64_t v19 = (unint64_t)(4096 - *(unsigned __int16 *)(a1 + 80)) << 41;
  BOOL v17 = 0;
  unint64_t v16 = (unint64_t *)(a1 + 56);
  while (1)
  {
    unint64_t v8 = _os_atomic_mo_has_acquire(2) ? __ldaxr(v16) : __ldxr(v16);
    if (v8 != (v19 | v8 & 0x3000000000LL)) {
      break;
    }
    unint64_t v18 = v10 & 0xFFFFFFFC | 0x60000000000002LL | v8 & 0x3000000000LL;
    if (_os_atomic_mo_has_release(2)) {
      BOOL v17 = __stlxr(v18, v16) == 0;
    }
    else {
      BOOL v17 = __stxr(v18, v16) == 0;
    }
    if (v17) {
      goto LABEL_19;
    }
  }

  __clrex();
LABEL_19:
  if (v17)
  {
    if (*(void *)(*(void *)(a1 + 24) + 24LL)) {
      _dispatch_sync_recurse(a1, a2, a3, a4 | 2);
    }
    else {
      _dispatch_lane_barrier_sync_invoke_and_complete(a1, a2, a3, 0LL, v4, v5, v6, v7);
    }
  }

  else
  {
    _dispatch_sync_f_slow(a1, a2, a3, 2LL, a1, a4 | 2, v6, v7);
  }

void dispatch_sync(dispatch_queue_t queue, dispatch_block_t block)
{
  if ((void (*)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))_Block_get_invoke_fn((uint64_t)block) == ___dispatch_block_create_block_invoke)
  {
    _dispatch_sync_block_with_privdata((unsigned int *)queue, (uint64_t)block, 16LL);
  }

  else
  {
    unsigned int v2 = (uint64_t (*)(uint64_t))_Block_get_invoke_fn((uint64_t)block);
    _dispatch_sync_f((uint64_t)queue, (uint64_t)block, v2, 16LL, v3, v4, v5, v6);
  }

void _dispatch_sync_f( uint64_t a1, uint64_t a2, uint64_t (*a3)(uint64_t), uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(_WORD *)(a1 + 80) == 1)
  {
    _dispatch_barrier_sync_f(a1, a2, a3, a4);
  }

  else
  {
    if (*(_BYTE *)(*(void *)a1 + 16LL) != 17LL) {
      goto LABEL_7;
    }
    LOBYTE(v9) = 0;
    if ((*(_DWORD *)(a1 + 80) & 0x1000000) != 0) {
      int v9 = (BYTE2(*(_DWORD *)(a1 + 80)) >> 2) & 1;
    }
    if ((v9 & 1) == 0) {
      char v14 = 1;
    }
    else {
LABEL_7:
    }
      char v14 = 0;
    if ((v14 & 1) == 0)
    {
      qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Queue type doesn't support dispatch_sync";
      __break(1u);
      JUMPOUT(0x20144LL);
    }

    if (*(void *)(a1 + 48))
    {
      char v18 = 0;
    }

    else
    {
      char v15 = (unint64_t *)(a1 + 56);
      do
      {
        if (_os_atomic_mo_has_acquire(0)) {
          unint64_t v8 = __ldaxr(v15);
        }
        else {
          unint64_t v8 = __ldxr(v15);
        }
        if (v8 >> 54 || (v8 & 0x8000000000LL) != 0 || (v8 & 0x10000000000LL) != 0)
        {
          __clrex();
          char v18 = 0;
          goto LABEL_26;
        }

        unint64_t v17 = v8 + 0x20000000000LL;
        if (_os_atomic_mo_has_release(0)) {
          BOOL v16 = __stlxr(v17, v15) == 0;
        }
        else {
          BOOL v16 = __stxr(v17, v15) == 0;
        }
      }

      while (!v16);
      char v18 = 1;
    }

void dispatch_async_and_wait_f(dispatch_queue_t queue, void *context, dispatch_function_t work)
{
  if (*((void *)queue + 3))
  {
    uint64_t v8 = 128LL;
    if (*((_WORD *)queue + 40) == 1) {
      uint64_t v8 = 130LL;
    }
    _dispatch_async_and_wait_f((uint64_t)queue, (uint64_t)context, (uint64_t)work, v8);
  }

  else
  {
    _dispatch_sync_function_invoke( (uint64_t)queue,  (uint64_t)context,  (uint64_t (*)(uint64_t))work,  v3,  v4,  v5,  v6,  v7);
  }

uint64_t _dispatch_sync_function_invoke( uint64_t a1, uint64_t a2, uint64_t (*a3)(uint64_t), uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v22 = a1;
  uint64_t v21 = a2;
  uint64_t v20 = a3;
  __int128 v19 = 0uLL;
  uint64_t v35 = a1;
  unint64_t v34 = &v19;
  unint64_t v37 = &v19;
  _dispatch_thread_getspecific_packed_pair(20LL, 21LL, &v19, a4, a5, a6, a7, a8);
  _dispatch_thread_setspecific_pair(20LL, v35, 21LL, (uint64_t)v34, v8, v9, v10, v11);
  uint64_t v29 = v21;
  uint64_t v28 = v20;
  unint64_t v27 = 0LL;
  else {
    char v18 = v28;
  }
  unint64_t v27 = v18;
  uint64_t v31 = v29;
  int v30 = v18;
  int v26 = 0;
  int v25 = 0;
  int v24 = 0;
  int v23 = 0;
  _dispatch_client_callout(v29, v28);
  uint64_t v33 = v29;
  unint64_t v32 = v27;
  uint64_t v36 = &v19;
  return _dispatch_thread_setspecific_packed_pair(20LL, 21LL, &v19, v12, v13, v14, v15, v16);
}

void _dispatch_async_and_wait_f(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v10 = a1;
  uint64_t v9 = a2;
  uint64_t v8 = a3;
  uint64_t v7 = a4;
  unint64_t v11 = (unint64_t)_dispatch_thread_getspecific(4uLL);
  unint64_t v6 = v11;
  int v5 = _dispatch_thread_getspecific(3uLL);
  memset(__b, 0, sizeof(__b));
  __b[0] = v7;
  __b[1] = v11 | 0x10000000;
  __b[2] = 0LL;
  __b[3] = _dispatch_thread_getspecific(0x1CuLL);
  __b[4] = _dispatch_async_and_wait_invoke;
  void __b[5] = __b;
  void __b[6] = 0LL;
  __b[7] = v10;
  __b[8] = v8;
  __b[9] = v9;
  memset(&__b[10], 0, 20);
  HIDWORD(__b[12]) = v5;
  LOWORD(__b[13]) = 0;
  BYTE2(__b[13]) = 0;
  _dispatch_async_and_wait_recurse(v10, (uint64_t)__b, v5, v7);
}

void dispatch_barrier_async_and_wait_f(dispatch_queue_t queue, void *context, dispatch_function_t work)
{
  if (*((void *)queue + 3)) {
    _dispatch_async_and_wait_f((uint64_t)queue, (uint64_t)context, (uint64_t)work, 130LL);
  }
  else {
    _dispatch_sync_function_invoke( (uint64_t)queue,  (uint64_t)context,  (uint64_t (*)(uint64_t))work,  v3,  v4,  v5,  v6,  v7);
  }
}

void dispatch_barrier_async_and_wait(dispatch_queue_t queue, dispatch_block_t block)
{
  if (*((void *)queue + 3))
  {
    if ((void (*)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))_Block_get_invoke_fn((uint64_t)block) == ___dispatch_block_create_block_invoke)
    {
      _dispatch_async_and_wait_block_with_privdata((unsigned int *)queue, (uint64_t)block, 146LL);
    }

    else
    {
      uint64_t v2 = _Block_get_invoke_fn((uint64_t)block);
      _dispatch_async_and_wait_f((uint64_t)queue, (uint64_t)block, v2, 146LL);
    }
  }

  else
  {
    dispatch_barrier_sync(queue, block);
  }

void _dispatch_async_and_wait_block_with_privdata(unsigned int *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v20 = a1;
  uint64_t v19 = a2;
  uint64_t v18 = a3;
  unint64_t v17 = 0LL;
  uint64_t v32 = a2;
  uint64_t v45 = a2;
  if ((void (*)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))_Block_get_invoke_fn(a2) == ___dispatch_block_create_block_invoke)
  {
    uint64_t v31 = v32 + 32;
    int v30 = (uint64_t *)(v32 + 32);
    if (*(void *)(v32 + 32) != 3512316172LL)
    {
      uint64_t v29 = 0LL;
      uint64_t v3 = *v30;
      qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Corruption of dispatch block object";
      qword_E4DA8 = v3;
      __break(1u);
      JUMPOUT(0x20A70LL);
    }

    uint64_t v33 = v30;
  }

  else
  {
    uint64_t v33 = 0LL;
  }

  unint64_t v17 = v33;
  uint64_t v16 = 0LL;
  uint64_t v16 = v33[1];
  unint64_t v15 = 0LL;
  uint64_t v14 = 0LL;
  if ((v33[1] & 1) != 0) {
    v18 |= 0x22uLL;
  }
  else {
    v18 |= 0x20uLL;
  }
  unint64_t v4 = v17[3];
  uint64_t v25 = v16;
  unint64_t v24 = v4;
  unint64_t v23 = 0LL;
  unint64_t v22 = 0LL;
  if ((v16 & 0x40000000) != 0 && ((v25 & 0x20) != 0 || (v25 & 0x10) == 0))
  {
    unint64_t v28 = v24;
    v24 &= 0xFFFFFFuLL;
    unint64_t v26 = (unint64_t)_dispatch_thread_getspecific(4uLL);
    unint64_t v27 = v26;
    unint64_t v23 = v26 & 0xFFFFFF;
    if ((v26 & 0xFFFFFF) != 0 && v23 < v24) {
      unint64_t v22 = v23;
    }
  }

  if (v22)
  {
    unint64_t v15 = v17[3];
  }

  else
  {
    uint64_t v21 = _dispatch_thread_getspecific(4uLL);
    unint64_t v15 = (unint64_t)v21;
  }

  if ((*((_BYTE *)v17 + 11) & 0x80) != 0) {
    uint64_t v14 = (void *)v17[4];
  }
  else {
    uint64_t v14 = _dispatch_thread_getspecific(0x1CuLL);
  }
  uint64_t v44 = v17;
  uint64_t v43 = v20;
  uint64_t v42 = v20;
  _dispatch_retain_2((uint64_t)v20);
  unint64_t v41 = 0LL;
  BOOL v40 = 0;
  uint64_t v5 = (unint64_t *)(v17 + 7);
  uint64_t v38 = v20;
  unint64_t v37 = v20;
  uint64_t v39 = v20;
  do
    unint64_t v6 = __ldaxr(v5);
  while (!v6 && __stlxr((unint64_t)v20, v5));
  if (v6) {
    unint64_t v41 = v6;
  }
  BOOL v36 = v6 == 0;
  BOOL v40 = v6 == 0;
  BOOL v35 = v40;
  if (v6)
  {
    unint64_t v34 = v43;
    _dispatch_release_2(v43);
  }

  int v13 = _dispatch_thread_getspecific(3uLL);
  v7[0] = v18;
  v7[1] = v15 | 0x10000000;
  v7[2] = 0LL;
  v7[3] = v14;
  v7[4] = _dispatch_async_and_wait_invoke;
  v7[5] = v7;
  v7[6] = 0LL;
  v7[7] = v20;
  v7[8] = _dispatch_block_sync_invoke;
  v7[9] = v19;
  __int128 v8 = 0uLL;
  int v9 = 0;
  int v10 = v13;
  char v11 = 0;
  memset(v12, 0, sizeof(v12));
  _dispatch_async_and_wait_recurse((uint64_t)v20, (uint64_t)v7, v13, v18);
}

void dispatch_async_and_wait(dispatch_queue_t queue, dispatch_block_t block)
{
  if (*((void *)queue + 3))
  {
    uint64_t v3 = 144LL;
    if (*((_WORD *)queue + 40) == 1) {
      uint64_t v3 = 146LL;
    }
    if ((void (*)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))_Block_get_invoke_fn((uint64_t)block) == ___dispatch_block_create_block_invoke)
    {
      _dispatch_async_and_wait_block_with_privdata((unsigned int *)queue, (uint64_t)block, v3);
    }

    else
    {
      uint64_t v2 = _Block_get_invoke_fn((uint64_t)block);
      _dispatch_async_and_wait_f((uint64_t)queue, (uint64_t)block, v2, v3);
    }
  }

  else
  {
    dispatch_sync(queue, block);
  }

void dispatch_queue_set_specific( dispatch_queue_t queue, const void *key, void *context, dispatch_function_t destructor)
{
  if (key)
  {
    uint64_t v10 = *((void *)queue + 11);
    if (*(_BYTE *)(*(void *)queue + 16LL) == 17LL)
    {
      BOOL v8 = 1;
      if (*(void *)(*(void *)queue + 16LL) != 394769LL) {
        BOOL v8 = (*(_BYTE *)(*(void *)queue + 18LL) & 2) == 0;
      }
      BOOL v15 = v8;
    }

    else
    {
      BOOL v15 = *(_BYTE *)(*(void *)queue + 16LL) == 18LL;
    }

    if (!v15)
    {
      qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Queue doesn't support dispatch_queue_set_specific";
      __break(1u);
      JUMPOUT(0x21030LL);
    }

    if (!context || v10)
    {
      if (!v10) {
        return;
      }
    }

    else
    {
      _dispatch_queue_init_specific((uint64_t)queue);
      uint64_t v10 = *((void *)queue + 11);
    }

    unsigned int v16 = _dispatch_thread_getspecific(3uLL) & 0xFFFFFFFC;
    do
      unsigned int v4 = __ldaxr((unsigned int *)v10);
    while (!v4 && __stlxr(v16, (unsigned int *)v10));
    if (v4) {
      _dispatch_unfair_lock_lock_slow((unsigned int *)v10, 0x10000);
    }
    for (uint64_t i = *(uint64_t **)(v10 + 8); i; uint64_t i = (uint64_t *)i[3])
    {
      if (*i == (void)key)
      {
        uint64_t v18 = i;
        goto LABEL_24;
      }
    }

    uint64_t v18 = 0LL;
LABEL_24:
    if (v18)
    {
      if (v18[2]) {
        _dispatch_barrier_async_detached_f((uint64_t)&off_E4640, v18[1], v18[2]);
      }
      if (context)
      {
        v18[1] = (uint64_t)context;
        v18[2] = (uint64_t)destructor;
      }

      else
      {
        if (v18[3]) {
          *(void *)(v18[3] + 32) = v18[4];
        }
        else {
          *(void *)(v10 + 16) = v18[4];
        }
        *(void *)v18[4] = v18[3];
        v18[3] = -1LL;
        v18[4] = -1LL;
        free(v18);
      }
    }

    else if (context)
    {
      int v9 = (void *)_dispatch_calloc(1LL, 40LL);
      void *v9 = key;
      v9[1] = context;
      v9[2] = destructor;
      v9[3] = 0LL;
      v9[4] = *(void *)(v10 + 16);
      **(void **)(v10 + 16) = v9;
      *(void *)(v10 + 16) = v9 + 3;
    }

    unsigned int v19 = _dispatch_thread_getspecific(3uLL) & 0xFFFFFFFC;
    unsigned int v7 = *(_DWORD *)v10;
    do
    {
      unsigned int v5 = v7;
      do
        unsigned int v6 = __ldaxr((unsigned int *)v10);
      while (v6 == v7 && __stlxr(0, (unsigned int *)v10));
      unsigned int v7 = v6;
    }

    while (v6 != v5);
    if (v6 != v19) {
      _dispatch_unfair_lock_unlock_slow(v10, v6);
    }
  }

void _dispatch_queue_init_specific(uint64_t a1)
{
  uint64_t v3 = (void *)_dispatch_calloc(1LL, 24LL);
  v3[1] = 0LL;
  int v3[2] = v3 + 1;
  unsigned int v1 = (unint64_t *)(a1 + 88);
  do
    unint64_t v2 = __ldaxr(v1);
  while (!v2 && __stlxr((unint64_t)v3, v1));
  if (v2) {
    _dispatch_queue_specific_head_dispose(v3);
  }
}

void *__cdecl dispatch_queue_get_specific(dispatch_queue_t queue, const void *key)
{
  if (!key) {
    return 0LL;
  }
  uint64_t v11 = *((void *)queue + 11);
  uint64_t v10 = 0LL;
  if (*(_BYTE *)(*(void *)queue + 16LL) == 17LL)
  {
    BOOL v8 = 1;
    if (*(void *)(*(void *)queue + 16LL) != 394769LL) {
      BOOL v8 = (*(void *)(*(void *)queue + 16LL) & 0x20000LL) == 0;
    }
    BOOL v13 = v8;
  }

  else
  {
    BOOL v13 = *(_BYTE *)(*(void *)queue + 16LL) == 18LL;
  }

  BOOL v7 = 0;
  if (v13) {
    BOOL v7 = v11 != 0;
  }
  if (v7)
  {
    unsigned int v14 = _dispatch_thread_getspecific(3uLL) & 0xFFFFFFFC;
    do
      unsigned int v2 = __ldaxr((unsigned int *)v11);
    while (!v2 && __stlxr(v14, (unsigned int *)v11));
    if (v2) {
      _dispatch_unfair_lock_lock_slow((unsigned int *)v11, 0x10000);
    }
    for (uint64_t i = *(void *)(v11 + 8); i; uint64_t i = *(void *)(i + 24))
    {
      if (*(const void **)i == key)
      {
        uint64_t v16 = i;
        goto LABEL_22;
      }
    }

    uint64_t v16 = 0LL;
LABEL_22:
    if (v16) {
      uint64_t v10 = *(void **)(v16 + 8);
    }
    unsigned int v17 = _dispatch_thread_getspecific(3uLL) & 0xFFFFFFFC;
    unsigned int v6 = *(_DWORD *)v11;
    do
    {
      unsigned int v3 = v6;
      do
        unsigned int v4 = __ldaxr((unsigned int *)v11);
      while (v4 == v6 && __stlxr(0, (unsigned int *)v11));
      unsigned int v6 = v4;
    }

    while (v4 != v3);
    if (v4 != v17) {
      _dispatch_unfair_lock_unlock_slow(v11, v4);
    }
  }

  return v10;
}

void *__cdecl dispatch_get_specific(const void *key)
{
  *((void *)&v10 + 1) = key;
  *(void *)&__int128 v10 = _dispatch_thread_getspecific(0x14uLL);
  int v9 = 0LL;
  if (v10 != 0)
  {
    do
    {
      uint64_t v12 = *(void *)(v10 + 88);
      uint64_t v11 = 0LL;
      if (*(_BYTE *)(*(void *)v10 + 16LL) == 17LL)
      {
        BOOL v8 = 1;
        if (*(void *)(*(void *)v10 + 16LL) != 394769LL) {
          BOOL v8 = (*(void *)(*(void *)v10 + 16LL) & 0x20000LL) == 0;
        }
        BOOL v13 = v8;
      }

      else
      {
        BOOL v13 = *(_BYTE *)(*(void *)v10 + 16LL) == 18LL;
      }

      BOOL v7 = 0;
      if (v13) {
        BOOL v7 = v12 != 0;
      }
      if (v7)
      {
        unsigned int v14 = _dispatch_thread_getspecific(3uLL) & 0xFFFFFFFC;
        do
          unsigned int v1 = __ldaxr((unsigned int *)v12);
        while (!v1 && __stlxr(v14, (unsigned int *)v12));
        if (v1) {
          _dispatch_unfair_lock_lock_slow((unsigned int *)v12, 0x10000);
        }
        for (uint64_t i = *(void **)(v12 + 8); i; uint64_t i = (void *)i[3])
        {
          if (*i == *((void *)&v10 + 1))
          {
            uint64_t v16 = i;
            goto LABEL_21;
          }
        }

        uint64_t v16 = 0LL;
LABEL_21:
        if (v16) {
          uint64_t v11 = (void *)v16[1];
        }
        unsigned int v17 = _dispatch_thread_getspecific(3uLL) & 0xFFFFFFFC;
        unsigned int v6 = *(_DWORD *)v12;
        do
        {
          unsigned int v2 = v6;
          do
            unsigned int v3 = __ldaxr((unsigned int *)v12);
          while (v3 == v6 && __stlxr(0, (unsigned int *)v12));
          unsigned int v6 = v3;
        }

        while (v3 != v2);
        if (v3 != v17) {
          _dispatch_unfair_lock_unlock_slow(v12, v3);
        }
      }

      int v9 = v11;
      *(void *)&__int128 v10 = *(void *)(v10 + 24);
      BOOL v5 = 0;
      if (!v11) {
        BOOL v5 = (void)v10 != 0LL;
      }
    }

    while (v5);
  }

  return v9;
}

uint64_t dispatch_queue_set_label_nocopy(uint64_t result, uint64_t a2)
{
  if (*(_DWORD *)(result + 8) != 0x7FFFFFFF)
  {
    if (((BYTE2(*(_DWORD *)(result + 80)) >> 5) & 1) != 0)
    {
      qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Cannot change label for this queue";
      qword_E4DA8 = result;
      __break(1u);
      JUMPOUT(0x21F28LL);
    }

    *(void *)(result + 72) = a2;
  }

  return result;
}

uint64_t _dispatch_queue_compute_priority_and_wlh(uint64_t a1, uint64_t *a2)
{
  int v20 = *(_DWORD *)(a1 + 84);
  unsigned int v18 = v20 & 0xFFF;
  unsigned int v17 = (unsigned __int16)(v20 & 0xF000) >> 12;
  unint64_t v16 = *(void *)(a1 + 24);
  uint64_t v15 = -4LL;
  if ((*(void *)(a1 + 56) & 0x2000000000LL) != 0) {
    uint64_t v15 = a1;
  }
  while (1)
  {
    if ((*(void *)(*(void *)v16 + 16LL) & 0x10000LL) != 0)
    {
LABEL_46:
      BOOL v7 = 0;
      BOOL v6 = 1;
      if (!v7) {
        BOOL v6 = *(void *)(v16 + 64) == 22LL;
      }
      if (v6)
      {
        if (!v17) {
          unsigned int v17 = (*(_DWORD *)(v16 + 84) & 0xF000u) >> 12;
        }
        if (v18 < (*(_DWORD *)(v16 + 84) & 0xFFFu)) {
          unsigned int v18 = *(_DWORD *)(v16 + 84) & 0xFFF;
        }
        unsigned int v19 = v18 | *(_DWORD *)(v16 + 84) & 0x88000000;
        if ((v20 & 0x40000000) != 0 || (v20 & 0xFFF) == 0)
        {
          v19 |= v20 & 0x40000000;
          if (v17 > (unsigned __int16)(v19 & 0xF00) >> 8)
          {
            if (v17) {
              int v5 = (v17 << 12) & 0xF000 | 0x4000000;
            }
            else {
              int v5 = 0;
            }
            v19 |= v5;
          }
        }

        if (a2) {
          *a2 = v15;
        }
        return v19;
      }

      else
      {
        if (a2) {
          *a2 = -4LL;
        }
        return 0x2000000;
      }
    }

    if ((uint64_t (***)())v16 == &_dispatch_mgr_q)
    {
      if (a2) {
        *a2 = -4LL;
      }
      return 0x2000000;
    }

    BOOL v12 = 0;
    if ((*(_DWORD *)(v16 + 80) & 0x40000) != 0) {
      BOOL v12 = (*(_DWORD *)(v16 + 80) & 0x1000000) == 0;
    }
    if (v12)
    {
      if (a2) {
        *a2 = -4LL;
      }
      return *(unsigned int *)(v16 + 84);
    }

    if ((*(void *)(v16 + 56) & 0xFF80000000000000LL) != 0)
    {
      if (*(_BYTE *)(*(void *)a1 + 16LL) == 19LL) {
        uint64_t v11 = a1;
      }
      else {
        uint64_t v11 = 0LL;
      }
      if (MEMORY[0xFFFFFC100]) {
        kdebug_trace(771883024LL, a1, v11, 0LL, 0LL);
      }
      if (a2) {
        *a2 = 0LL;
      }
      return 0;
    }

    if ((*(void *)(v16 + 56) & 0x2000000000LL) == 0) {
      break;
    }
    uint64_t v15 = v16;
    if (*(_BYTE *)(*(void *)v16 + 16LL) == 18LL)
    {
      int v9 = (unsigned int *)(a1 + 80);
      unsigned int v10 = *(_DWORD *)(a1 + 80);
      do
      {
        unsigned int v2 = v10;
        do
          unsigned int v3 = __ldaxr(v9);
        while (v3 == v10 && __stlxr(v10 & 0xFFBFFFFF, v9));
        unsigned int v10 = v3;
      }

      while (v3 != v2);
    }

LABEL_40:
    int v13 = *(_DWORD *)(v16 + 84);
    unint64_t v16 = *(void *)(v16 + 24);
    if ((v13 & 0x20000000) != 0) {
      goto LABEL_46;
    }
    if (!v17) {
      unsigned int v17 = (unsigned __int16)(v13 & 0xF000) >> 12;
    }
    unsigned int v14 = v13 & 0xFFF;
    if (v18 < v14) {
      unsigned int v18 = v14;
    }
  }

  if ((*(_DWORD *)(v16 + 80) & 0x400000) == 0) {
    goto LABEL_40;
  }
  if (*(_BYTE *)(*(void *)a1 + 16LL) == 19LL) {
    uint64_t v8 = a1;
  }
  else {
    uint64_t v8 = 0LL;
  }
  if (MEMORY[0xFFFFFC100]) {
    kdebug_trace(771883024LL, a1, v8, 0LL, 0LL);
  }
  if (a2) {
    *a2 = 0LL;
  }
  return 0;
}

void dispatch_set_qos_class_floor( dispatch_object_t object, dispatch_qos_class_t qos_class, int relative_priority)
{
  if ((*(void *)(*(void *)object + 16LL) & 0xF0LL) != 0x10)
  {
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: dispatch_set_qos_class_floor called on invalid object type";
    __break(1u);
    JUMPOUT(0x2288CLL);
  }

  if (*(_BYTE *)(*(void *)object + 16LL) == 18LL)
  {
    dispatch_workloop_set_qos_class_floor((uint64_t)object, qos_class, relative_priority, 0);
  }

  else
  {
    switch(qos_class)
    {
      case 5u:
        int v5 = 1;
        break;
      case 9u:
        int v5 = 2;
        break;
      case 0x11u:
        int v5 = 3;
        break;
      case 0x15u:
        int v5 = 4;
        break;
      case 0x19u:
        int v5 = 5;
        break;
      case 0x21u:
        int v5 = 6;
        break;
      default:
        int v5 = 0;
        break;
    }

    if (v5) {
      int v3 = (relative_priority - 1) | ((v5 & 0xF) << 8);
    }
    else {
      int v3 = 0;
    }
    int v4 = v3;
    if (v3) {
      int v4 = v3 | 0x40000000;
    }
    *((_DWORD *)object + 21) = v4 | *((_DWORD *)object + 21) & 0xBFFFF000;
    uint64_t v6 = *((void *)object + 7);
    if ((~v6 & 0x180000000000000LL) != 0)
    {
      qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: dispatch queue/source property setter called after activation";
      qword_E4DA8 = v6;
      __break(1u);
      JUMPOUT(0x22A9CLL);
    }
  }

uint64_t dispatch_workloop_set_qos_class_floor(uint64_t result, int a2, char a3, char a4)
{
  uint64_t v7 = result;
  uint64_t v9 = *(void *)(result + 56);
  if ((~v9 & 0x180000000000000LL) != 0)
  {
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: dispatch queue/source property setter called after activation";
    qword_E4DA8 = v9;
    __break(1u);
    JUMPOUT(0x22BD8LL);
  }

  if (!*(void *)(result + 200))
  {
    uint64_t result = _dispatch_calloc(1LL, 56LL);
    *(void *)(v7 + 200) = result;
  }

  switch(a2)
  {
    case 5:
      int v8 = 1;
      break;
    case 9:
      int v8 = 2;
      break;
    case 17:
      int v8 = 3;
      break;
    case 21:
      int v8 = 4;
      break;
    case 25:
      int v8 = 5;
      break;
    case 33:
      int v8 = 6;
      break;
    default:
      int v8 = 0;
      break;
  }

  if (v8)
  {
    *(_DWORD *)(*(void *)(v7 + 200) + 4LL) = (a3 - 1) | ((v8 & 0xF) << 8);
    **(_DWORD **)(v7 + 200) |= 8u;
  }

  else
  {
    *(_DWORD *)(*(void *)(v7 + 200) + 4LL) = 0;
    **(_DWORD **)(v7 + 200) &= ~8u;
  }

  if ((a4 & 1) != 0)
  {
    *(_DWORD *)(*(void *)(v7 + 200) + 16LL) = 2;
    **(_DWORD **)(v7 + 200) |= 2u;
  }

  else
  {
    **(_DWORD **)(v7 + 200) &= ~2u;
  }

  return result;
}

uint64_t dispatch_set_qos_class(uint64_t result, int a2, char a3)
{
  if ((*(void *)(*(void *)result + 16LL) & 0xF0LL) != 0x10 || *(_BYTE *)(*(void *)result + 16LL) == 18LL)
  {
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: dispatch_set_qos_class called on invalid object type";
    __break(1u);
    JUMPOUT(0x22E78LL);
  }

  switch(a2)
  {
    case 5:
      int v4 = 1;
      break;
    case 9:
      int v4 = 2;
      break;
    case 17:
      int v4 = 3;
      break;
    case 21:
      int v4 = 4;
      break;
    case 25:
      int v4 = 5;
      break;
    case 33:
      int v4 = 6;
      break;
    default:
      int v4 = 0;
      break;
  }

  if (v4) {
    int v3 = (a3 - 1) | ((v4 & 0xF) << 8);
  }
  else {
    int v3 = 0;
  }
  *(_DWORD *)(result + 84) = v3 | *(_DWORD *)(result + 84) & 0xBFFFF000;
  uint64_t v5 = *(void *)(result + 56);
  if ((~v5 & 0x180000000000000LL) != 0)
  {
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: dispatch queue/source property setter called after activation";
    qword_E4DA8 = v5;
    __break(1u);
    JUMPOUT(0x2303CLL);
  }

  return result;
}

uint64_t dispatch_set_qos_class_fallback(uint64_t result, int a2)
{
  if ((*(void *)(*(void *)result + 16LL) & 0xF0LL) != 0x10)
  {
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: dispatch_set_qos_class_fallback called on invalid object type";
    __break(1u);
    JUMPOUT(0x23108LL);
  }

  switch(a2)
  {
    case 5:
      int v3 = 1;
      break;
    case 9:
      int v3 = 2;
      break;
    case 17:
      int v3 = 3;
      break;
    case 21:
      int v3 = 4;
      break;
    case 25:
      int v3 = 5;
      break;
    case 33:
      int v3 = 6;
      break;
    default:
      int v3 = 0;
      break;
  }

  if (v3) {
    int v2 = ((v3 & 0xF) << 12) | 0x4000000;
  }
  else {
    int v2 = 0;
  }
  *(_DWORD *)(result + 84) = v2 | *(_DWORD *)(result + 84) & 0xFBFF0FFF;
  uint64_t v4 = *(void *)(result + 56);
  if ((~v4 & 0x180000000000000LL) != 0)
  {
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: dispatch queue/source property setter called after activation";
    qword_E4DA8 = v4;
    __break(1u);
    JUMPOUT(0x232C4LL);
  }

  return result;
}

dispatch_queue_t dispatch_queue_create_with_target_V2( const char *label, dispatch_queue_attr_t attr, dispatch_queue_t target)
{
  return (dispatch_queue_t)_dispatch_lane_create_with_target( label,  (uint64_t *)attr,  (uint64_t (***)())target,  0);
}

void *_dispatch_lane_create_with_target( const char *a1, uint64_t *a2, uint64_t (***a3)(), char a4)
{
  unsigned int v40 = _dispatch_queue_attr_to_info(a2);
  unsigned int v39 = v40;
  int v38 = BYTE2(v40) & 3;
  if ((v40 & 0x30000) != 0 && a3 && a3[3])
  {
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Cannot specify both overcommit and a non-global target queue";
    qword_E4DA8 = (uint64_t)a3;
    __break(1u);
    JUMPOUT(0x2343CLL);
  }

  if (a3 && (*a3)[2] == (uint64_t (*)())((char *)&loc_50310 + 1))
  {
    if ((v40 & 0x30000) == 0)
    {
      if ((*((_BYTE *)a3 + 87) & 0x80) != 0) {
        int v38 = 1;
      }
      else {
        int v38 = 2;
      }
    }

    if (!(_BYTE)v40) {
      unsigned int v39 = (*((_DWORD *)a3 + 21) & 0xF00u) >> 8;
    }
    a3 = 0LL;
  }

  else
  {
    if (a3 && (*((_BYTE *)a3 + 87) & 8) != 0)
    {
      qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Cannot target object to cooperative root queue - not implemented";
      qword_E4DA8 = (uint64_t)a3;
      __break(1u);
      JUMPOUT(0x23554LL);
    }

    if (!a3 || a3[3])
    {
      if ((v40 & 0x30000) == 0)
      {
        if (((v40 >> 20) & 1) != 0) {
          int v10 = 2;
        }
        else {
          int v10 = 1;
        }
        int v38 = v10;
      }
    }

    else if ((v40 & 0x30000) != 0)
    {
      qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Cannot specify an overcommit attribute and use this kind of target queue";
      qword_E4DA8 = (uint64_t)a3;
      __break(1u);
      JUMPOUT(0x235C0LL);
    }
  }

  if (!a3)
  {
    if (v39) {
      unsigned int v33 = v39;
    }
    else {
      unsigned int v33 = 4;
    }
    if (v33 > 6)
    {
      qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Corrupted priority";
      qword_E4DA8 = v33;
      __break(1u);
      JUMPOUT(0x236C8LL);
    }

    int v44 = 0;
    if (((2 * (v38 == 1)) & 2) != 0)
    {
      int v44 = 1;
    }

    else if (((2 * (v38 == 1)) & 4) != 0)
    {
      int v44 = 2;
    }

    a3 = &(&_dispatch_root_queues)[16 * (unint64_t)(3 * v33 + v44 - 3)];
    if (!a3)
    {
      qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Invalid queue attribute";
      qword_E4DA8 = v39;
      __break(1u);
      JUMPOUT(0x23780LL);
    }
  }

  if ((a4 & 1) != 0 && ((v40 & 0x200000) != 0 || ((v40 >> 18) & 3) != 0)) {
    a4 = 0;
  }
  if ((a4 & 1) != 0) {
    int v11 = 0x400000;
  }
  else {
    int v11 = 0;
  }
  int v36 = v11;
  if ((v40 & 0x100000) != 0) {
    unint64_t v37 = _OS_dispatch_queue_concurrent_vtable;
  }
  else {
    unint64_t v37 = _OS_dispatch_queue_serial_vtable;
  }
  int v32 = (v40 >> 18) & 3;
  if (v32 == 1)
  {
    int v36 = v11 | 0x10000;
  }

  else if (v32 == 2)
  {
    int v36 = v11 | 0x20000;
  }

  if (a1)
  {
    BOOL v35 = _dispatch_strdup_if_mutable(a1);
    if (v35 != a1)
    {
      v36 |= 0x200000u;
      a1 = v35;
    }
  }

  unint64_t v34 = _dispatch_object_alloc((uint64_t)v37, 0x78uLL, v4, v5, v6, v7, v8, v9);
  if (((v40 >> 21) & 1) != 0) {
    uint64_t v16 = 0x180000000000000LL;
  }
  else {
    uint64_t v16 = 0LL;
  }
  if (((v40 >> 20) & 1) != 0) {
    uint64_t v17 = 4094LL;
  }
  else {
    uint64_t v17 = 1LL;
  }
  _dispatch_queue_init((uint64_t)v34, v36, v17, v16, v12, v13, v14, v15);
  v34[9] = a1;
  if ((_BYTE)v40) {
    int v31 = (BYTE1(v40) - 1) | ((v40 & 0xF) << 8);
  }
  else {
    int v31 = 0;
  }
  *((_DWORD *)v34 + 21) = v31;
  if (v38 == 1) {
    *((_DWORD *)v34 + 21) |= 0x80000000;
  }
  if ((v40 & 0x200000) == 0)
  {
    _dispatch_queue_priority_inherit_from_target((uint64_t)v34, (unint64_t)a3);
    _dispatch_lane_inherit_wlh_from_target((uint64_t)v34, a3, v18, v19, v20, v21, v22, v23);
  }

  _dispatch_retain((uint64_t)a3);
  v34[3] = a3;
  _dispatch_object_debug((uint64_t)v34, "%s", v24, v25, v26, v27, v28, v29, (char)"_dispatch_lane_create_with_target");
  return v34;
}

dispatch_queue_t dispatch_queue_create(const char *label, dispatch_queue_attr_t attr)
{
  return (dispatch_queue_t)_dispatch_lane_create_with_target(label, (uint64_t *)attr, 0LL, 1);
}

void dispatch_queue_create_with_accounting_override_voucher()
{
  qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Unsupported interface";
  __break(1u);
}

uint64_t sub_23AA0()
{
  return v1;
}

void _dispatch_lane_class_dispose(uint64_t a1, _BYTE *a2)
{
  if (*(void *)(a1 + 48))
  {
    uint64_t v2 = *(void *)(a1 + 48);
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Release of a queue while items are enqueued";
    qword_E4DA8 = v2;
    __break(1u);
    JUMPOUT(0x23B24LL);
  }

  *(void *)(a1 + 104) = 512LL;
  *(void *)(a1 + 48) = 512LL;
  uint64_t v4 = *(void *)(a1 + 56);
  unint64_t v3 = (unint64_t)(4096 - *(unsigned __int16 *)(a1 + 80)) << 41;
  if ((*(_BYTE *)(*(void *)a1 + 18LL) & 1) != 0) {
    unint64_t v3 = 0x60000000000000LL;
  }
  if ((*(void *)(a1 + 56) & 0xFFFFFF48FFFFFFFFLL) != v3)
  {
    if ((*(_DWORD *)(a1 + 56) & 0xFFFFFFFC) != 0)
    {
      qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Premature release of a locked queue";
      qword_E4DA8 = v4;
      __break(1u);
      JUMPOUT(0x23C4CLL);
    }

    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Release of a queue with corrupt state";
    qword_E4DA8 = v4;
    __break(1u);
    JUMPOUT(0x23C90LL);
  }

  _dispatch_queue_dispose(a1, a2);
}

void _dispatch_queue_dispose(uint64_t a1, _BYTE *a2)
{
  if (*(void *)(a1 + 72) && (*(_DWORD *)(a1 + 80) & 0x200000) != 0) {
    free(*(void **)(a1 + 72));
  }
  uint64_t v8 = (unint64_t *)(a1 + 88);
  uint64_t v9 = *(void **)(a1 + 88);
  do
  {
    uint64_t v2 = v9;
    do
      unint64_t v3 = (void *)__ldaxr(v8);
    while (v3 == v9 && __stlxr(0x200uLL, v8));
    uint64_t v9 = v3;
  }

  while (v3 != v2);
  if (v3) {
    _dispatch_queue_specific_head_dispose(v3);
  }
  if (*(_DWORD *)(a1 + 96))
  {
    _dispatch_object_finalize();
    *a2 = 0;
    *(void *)(a1 + 72) = "<released queue, pending free>";
    *(void *)(a1 + 24) = 0LL;
    *(void *)(a1 + 40) = 0LL;
    *(void *)(a1 + 32) = 0LL;
    uint64_t v6 = (unsigned int *)(a1 + 96);
    unsigned int v7 = *(_DWORD *)(a1 + 96);
    do
    {
      unsigned int v4 = v7;
      do
        unsigned int v5 = __ldaxr(v6);
      while (v5 == v7 && __stlxr(v7 - 1, v6));
      unsigned int v7 = v5;
    }

    while (v5 != v4);
    if (((v5 - 1) & 0x80000000) != 0)
    {
      if ((int)(v5 - 1) <= -2)
      {
        qword_E4D78 = (uint64_t)"API MISUSE: Over-release of an object";
        __break(1u);
        JUMPOUT(0x23FA8LL);
      }

      *(void *)(a1 + 56) = 0xDEAD000000000000LL;
      _dispatch_object_dealloc((void *)a1);
    }
  }

  else
  {
    *(void *)(a1 + 56) = 0xDEAD000000000000LL;
  }

void _dispatch_lane_dispose( uint64_t a1, _BYTE *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (MEMORY[0xFFFFFC100]) {
    kdebug_trace(772079624LL, *(void *)(a1 + 64), 0LL, 0LL, 0LL);
  }
  _dispatch_lane_class_dispose(a1, a2);
}

uint64_t _dispatch_queue_xref_dispose(uint64_t result)
{
  uint64_t v5 = *(void *)(result + 56);
  if ((v5 & 0xFF80000000000000LL) != 0)
  {
    if ((v5 & 0x180000000000000LL) != 0)
    {
      qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Release of an inactive object";
      qword_E4DA8 = v5;
      __break(1u);
      JUMPOUT(0x24178LL);
    }

    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Release of a suspended object";
    qword_E4DA8 = v5;
    __break(1u);
    JUMPOUT(0x241BCLL);
  }

  unint64_t v3 = (unsigned int *)(result + 80);
  unsigned int v4 = *(_DWORD *)(result + 80);
  do
  {
    unsigned int v1 = v4;
    do
      unsigned int v2 = __ldaxr(v3);
    while (v2 == v4 && __stlxr(v4 | 0x800000, v3));
    unsigned int v4 = v2;
  }

  while (v2 != v1);
  return result;
}

uint64_t _dispatch_lane_suspend(uint64_t a1)
{
  unint64_t v3 = (unint64_t *)(a1 + 56);
  do
  {
    if (_os_atomic_mo_has_acquire(0)) {
      unint64_t v1 = __ldaxr(v3);
    }
    else {
      unint64_t v1 = __ldxr(v3);
    }
    unint64_t v6 = v1;
    unint64_t v5 = v1 + 0x400000000000000LL;
    if (v1 >= 0xFC00000000000000LL)
    {
      __clrex();
      return _dispatch_lane_suspend_slow(a1);
    }

    uint64_t result = _os_atomic_mo_has_release(0);
    if ((_DWORD)result) {
      BOOL v4 = __stlxr(v5, v3) == 0;
    }
    else {
      BOOL v4 = __stxr(v5, v3) == 0;
    }
  }

  while (!v4);
  if ((v6 & 0xFF80000000000000LL) == 0) {
    return _dispatch_retain_2(a1);
  }
  return result;
}

uint64_t _dispatch_lane_suspend_slow(uint64_t a1)
{
  uint64_t v21 = (unsigned int *)(a1 + 100);
  unsigned int v20 = _dispatch_thread_getspecific(3uLL) & 0xFFFFFFFC;
  do
    unsigned int v1 = __ldaxr(v21);
  while (!v1 && __stlxr(v20, v21));
  if (v1) {
    _dispatch_unfair_lock_lock_slow(v21, 0x10000);
  }
  unint64_t v17 = 0x7C00000000000000LL;
  if (!*(_DWORD *)(a1 + 112)) {
    unint64_t v17 = 0x7A00000000000000LL;
  }
  uint64_t v15 = (unint64_t *)(a1 + 56);
  do
  {
    if (_os_atomic_mo_has_acquire(0)) {
      unint64_t v2 = __ldaxr(v15);
    }
    else {
      unint64_t v2 = __ldxr(v15);
    }
    unint64_t v18 = v2 - v17;
    if (v2 < v17)
    {
      __clrex();
      unsigned int v24 = _dispatch_thread_getspecific(3uLL) & 0xFFFFFFFC;
      int v10 = (unsigned int *)(a1 + 100);
      unsigned int v11 = *(_DWORD *)(a1 + 100);
      do
      {
        unsigned int v7 = v11;
        do
          unsigned int v8 = __ldaxr(v10);
        while (v8 == v11 && __stlxr(0, v10));
        char v9 = v8;
        unsigned int v11 = v8;
      }

      while (v8 != v7);
      if (v8 == v24)
      {
        BOOL v25 = 0;
      }

      else
      {
        _dispatch_unfair_lock_unlock_slow(a1 + 100, v8);
        BOOL v25 = (v9 & 2) != 0;
      }

      if (v25)
      {
        unsigned int v22 = _dispatch_thread_getspecific(0x19uLL);
        if (!((v22 & 0xF0000) >> 16)) {
          _dispatch_thread_setspecific(25LL, v22 & 0xFFF0FFFF | 0x10000);
        }
      }

      return _dispatch_lane_suspend(a1);
    }

    if (_os_atomic_mo_has_release(0)) {
      BOOL v16 = __stlxr(v18, v15) == 0;
    }
    else {
      BOOL v16 = __stxr(v18, v15) == 0;
    }
  }

  while (!v16);
  unsigned int v3 = *(_DWORD *)(a1 + 112);
  *(_DWORD *)(a1 + 112) = v3 + 32;
  if (v3 >= 0xFFFFFFE0)
  {
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Too many nested calls to dispatch_suspend()";
    __break(1u);
    JUMPOUT(0x24694LL);
  }

  uint64_t result = (uint64_t)_dispatch_thread_getspecific(3uLL);
  uint64_t v13 = (unsigned int *)(a1 + 100);
  unsigned int v14 = *(_DWORD *)(a1 + 100);
  do
  {
    unsigned int v5 = v14;
    do
      unsigned int v6 = __ldaxr(v13);
    while (v6 == v14 && __stlxr(0, v13));
    char v12 = v6;
    unsigned int v14 = v6;
  }

  while (v6 != v5);
  if (v6 == (result & 0xFFFFFFFC))
  {
    BOOL v23 = 0;
  }

  else
  {
    uint64_t result = (uint64_t)_dispatch_unfair_lock_unlock_slow(a1 + 100, v6);
    BOOL v23 = (v12 & 2) != 0;
  }

  if (v23)
  {
    uint64_t result = (uint64_t)_dispatch_thread_getspecific(0x19uLL);
  }

  return result;
}

void _dispatch_lane_resume(unsigned __int16 *a1, int a2)
{
  unint64_t v18 = (unint64_t)(a1[40] - 1) << 41;
  unint64_t v17 = (unint64_t)_dispatch_thread_getspecific(3uLL) & 0xFFFFFFFC | 0x60000000000002LL;
  BOOL v16 = *(_BYTE *)(*(void *)a1 + 16LL) == 19LL;
  if (a2 == 1)
  {
    int v10 = (unint64_t *)(a1 + 28);
    while (1)
    {
      unint64_t v2 = _os_atomic_mo_has_acquire(0) ? __ldaxr(v10) : __ldxr(v10);
      unint64_t v15 = v2;
      if ((~v2 & 0x180000000000000LL) != 0) {
        break;
      }
      if (v2 >> 58) {
        unint64_t v12 = v2 - 0x80000000000000LL;
      }
      else {
        unint64_t v12 = v2 - 0x100000000000000LL;
      }
      if (_os_atomic_mo_has_release(0)) {
        BOOL v11 = __stlxr(v12, v10) == 0;
      }
      else {
        BOOL v11 = __stxr(v12, v10) == 0;
      }
      if (v11) {
        goto LABEL_60;
      }
    }

    __clrex();
  }

  else
  {
    if (a2 != 2)
    {
      unsigned int v6 = (unint64_t *)(a1 + 28);
      while (1)
      {
        if (_os_atomic_mo_has_acquire(3)) {
          unint64_t v4 = __ldaxr(v6);
        }
        else {
          unint64_t v4 = __ldxr(v6);
        }
        unint64_t v15 = v4;
        if (v16 && v4 >> 55 == 3)
        {
          unint64_t v12 = v4 - 0x100000000000000LL;
        }

        else
        {
          unint64_t v14 = v4 - 0x400000000000000LL;
          if (v4 < 0x400000000000000LL)
          {
            __clrex();
            if ((v4 & 0x200000000000000LL) == 0)
            {
              if ((~v4 & 0x180000000000000LL) == 0)
              {
                qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Over-resume of an inactive object";
                qword_E4DA8 = (uint64_t)a1;
                __break(1u);
                JUMPOUT(0x25208LL);
              }

              qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Over-resume of an object";
              qword_E4DA8 = (uint64_t)a1;
              __break(1u);
              JUMPOUT(0x2524CLL);
            }

            _dispatch_lane_resume_slow((uint64_t)a1);
            return;
          }

          if ((v14 & 0x180000000000000LL) == 0x100000000000000LL)
          {
            unint64_t v12 = v4 - 0x480000000000000LL;
          }

          else if (v14 >> 53)
          {
            unint64_t v12 = v14 | 0x8000000000LL;
          }

          else if ((v4 & 0xFFFFFFFC) != 0)
          {
            unint64_t v12 = v14 | 0x8000000000LL;
          }

          else if (v16 || (v14 & 0x10000000000LL) == 0 && (v14 + v18) >> 53)
          {
            unint64_t v12 = v14 & 0xFFFFFFF000000001LL;
          }

          else
          {
            unint64_t v12 = v14 & 0x7700000001LL | v17;
          }
        }

        if (_os_atomic_mo_has_release(3)) {
          BOOL v7 = __stlxr(v12, v6) == 0;
        }
        else {
          BOOL v7 = __stxr(v12, v6) == 0;
        }
        if (v7) {
          goto LABEL_60;
        }
      }
    }

    unsigned int v8 = (unint64_t *)(a1 + 28);
    do
    {
      if (_os_atomic_mo_has_acquire(3)) {
        unint64_t v3 = __ldaxr(v8);
      }
      else {
        unint64_t v3 = __ldxr(v8);
      }
      unint64_t v15 = v3;
      if ((v3 & 0x180000000000000LL) == 0)
      {
        __clrex();
        _dispatch_release_2_tailcall((unsigned int *)a1);
        return;
      }

      unint64_t v13 = v3 - 0x80000000000000LL;
      if ((v3 - 0x80000000000000LL) >> 53)
      {
        unint64_t v12 = v13 | 0x8000000000LL;
      }

      else if ((v3 & 0xFFFFFFFC) != 0)
      {
        unint64_t v12 = v13 | 0x8000000000LL;
      }

      else
      {
        unint64_t v12 = v13 & 0xFFFFFFF000000001LL;
      }

      if (_os_atomic_mo_has_release(3)) {
        BOOL v9 = __stlxr(v12, v8) == 0;
      }
      else {
        BOOL v9 = __stxr(v12, v8) == 0;
      }
    }

    while (!v9);
    if ((v12 & 0x180000000000000LL) != 0)
    {
      qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Corrupt activation state";
      qword_E4DA8 = (uint64_t)a1;
      __break(1u);
      JUMPOUT(0x24DD4LL);
    }

LABEL_60:
    if ((v12 & 0x180000000000000LL) == 0x80000000000000LL)
    {
      _dispatch_lane_resume_activate((uint64_t)a1);
      return;
    }

    if ((v12 & 0xFF80000000000000LL) == 0)
    {
      unsigned int v5 = 1;
      if (((v15 ^ v12) & 0x40000000000000LL) != 0)
      {
        unsigned int v5 = 5;
      }

      else if (v12 >> 53)
      {
        if ((v15 & 0x2000000000LL) != 0) {
          _dispatch_event_loop_assert_not_owned((uint64_t)a1);
        }
        _dispatch_release_2((unsigned int *)a1);
        return;
      }

      (*(void (**)(unsigned __int16 *, unint64_t, void))(*(void *)a1 + 64LL))( a1,  (v15 & 0x700000000LL) >> 32,  v5);
    }
  }

  if ((v39 & 0x200) == 0)
  {
    uint64_t v56 = v41;
    unsigned int v55 = v45;
    __int128 v54 = 0;
    uint64_t v53 = 0;
    uint64_t v128 = v41;
    uint64_t v127 = v45;
  }

  if ((v39 & 4) != 0)
  {
    uint64_t v59 = v36;
    uint64_t v58 = 0LL;
    uint64_t v58 = _dispatch_thread_getspecific(0x16uLL);
    uint64_t v57 = 0;
    if (v58) {
      uint64_t v28 = v58[2] + 1;
    }
    else {
      uint64_t v28 = 1;
    }
    uint64_t v57 = v28;
    if (v28 <= _dispatch_continuation_cache_limit)
    {
      *(void *)(v59 + 16) = v58;
      *(_DWORD *)(v59 + 8) = v57;
      _dispatch_thread_setspecific(22LL, v59);
      uint64_t v60 = 0LL;
    }

    else
    {
      uint64_t v60 = v59;
    }

    BOOL v35 = (void *)v60;
  }

  else
  {
    BOOL v35 = 0LL;
  }

  unint64_t v34 = 0LL;
  if ((v43 & 0x1000000) != 0) {
    unint64_t v34 = _dispatch_autorelease_pool_push();
  }
  unsigned int v20 = (uint64_t (*)(uint64_t))v45[4];
  uint64_t v69 = v45[5];
  BOOL v68 = v20;
  unint64_t v67 = 0LL;
  else {
    uint64_t v27 = v68;
  }
  unint64_t v67 = v27;
  unsigned int v137 = v69;
  unsigned int v136 = v27;
  uint64_t v66 = 0;
  uint64_t v65 = 0;
  uint64_t v64 = 0;
  unint64_t v63 = 0;
  _dispatch_client_callout(v69, v68);
  unsigned int v139 = v69;
  unsigned int v138 = v67;
  uint64_t result = _dispatch_client_callout4( *(void *)(v40 + 48),  6LL,  0LL,  0,  *(uint64_t (**)(uint64_t, uint64_t, uint64_t, void))(v40 + 40));
  if (v34) {
    uint64_t result = _dispatch_autorelease_pool_pop(v34);
  }
  if ((v39 & 0x200) == 0)
  {
    uint64_t v61 = v36;
    uint64_t v129 = v36;
    unsigned int v134 = 772079660;
    int v133 = v36;
    unsigned int v132 = 0LL;
    unsigned int v131 = 0LL;
    uint64_t v130 = 0LL;
    if (MEMORY[0xFFFFFC100]) {
      uint64_t result = kdebug_trace(v134, v133, v132, v131, v130);
    }
    unsigned int v135 = v61;
  }

  if (v35) {
    uint64_t result = (uint64_t)_dispatch_continuation_free_to_cache_limit(v35);
  }
  if (v38 == 1024)
  {
    uint64_t v62 = &v42;
    unsigned int v80 = &v42;
    return _dispatch_thread_setspecific_packed_pair(20LL, 21LL, &v42, v22, v23, v24, v25, v26);
  }

  return result;
}

void _dispatch_release_2_tailcall(unsigned int *a1)
{
}

uint64_t _dispatch_lane_resume_slow(uint64_t a1)
{
  BOOL v23 = (unsigned int *)(a1 + 100);
  unsigned int v22 = _dispatch_thread_getspecific(3uLL) & 0xFFFFFFFC;
  do
    unsigned int v1 = __ldaxr(v23);
  while (!v1 && __stlxr(v22, v23));
  if (v1) {
    _dispatch_unfair_lock_lock_slow(v23, 0x10000);
  }
  uint64_t v18 = 0x7C00000000000000LL;
  int v15 = *(_DWORD *)(a1 + 112);
  if (v15)
  {
    if (v15 == 32) {
      uint64_t v18 = 0x7A00000000000000LL;
    }
    BOOL v16 = (unint64_t *)(a1 + 56);
    do
    {
      if (_os_atomic_mo_has_acquire(0)) {
        unint64_t v2 = __ldaxr(v16);
      }
      else {
        unint64_t v2 = __ldxr(v16);
      }
      unint64_t v20 = v2;
      BOOL v3 = __CFADD__(v2, v18);
      unint64_t v19 = v20 + v18;
      if (v3)
      {
        __clrex();
        goto LABEL_36;
      }

      if (_os_atomic_mo_has_release(0)) {
        BOOL v17 = __stlxr(v19, v16) == 0;
      }
      else {
        BOOL v17 = __stxr(v19, v16) == 0;
      }
    }

    while (!v17);
    *(_DWORD *)(a1 + 112) -= 32;
    uint64_t result = (uint64_t)_dispatch_thread_getspecific(3uLL);
    unint64_t v13 = (unsigned int *)(a1 + 100);
    unsigned int v14 = *(_DWORD *)(a1 + 100);
    do
    {
      unsigned int v5 = v14;
      do
        unsigned int v6 = __ldaxr(v13);
      while (v6 == v14 && __stlxr(0, v13));
      char v12 = v6;
      unsigned int v14 = v6;
    }

    while (v6 != v5);
    if (v6 == (result & 0xFFFFFFFC))
    {
      BOOL v25 = 0;
    }

    else
    {
      uint64_t result = (uint64_t)_dispatch_unfair_lock_unlock_slow(a1 + 100, v6);
      BOOL v25 = (v12 & 2) != 0;
    }

    if (v25)
    {
      uint64_t result = (uint64_t)_dispatch_thread_getspecific(0x19uLL);
    }
  }

  else
  {
LABEL_36:
    unsigned int v26 = _dispatch_thread_getspecific(3uLL) & 0xFFFFFFFC;
    int v10 = (unsigned int *)(a1 + 100);
    unsigned int v11 = *(_DWORD *)(a1 + 100);
    do
    {
      unsigned int v7 = v11;
      do
        unsigned int v8 = __ldaxr(v10);
      while (v8 == v11 && __stlxr(0, v10));
      char v9 = v8;
      unsigned int v11 = v8;
    }

    while (v8 != v7);
    if (v8 == v26)
    {
      BOOL v27 = 0;
    }

    else
    {
      _dispatch_unfair_lock_unlock_slow(a1 + 100, v8);
      BOOL v27 = (v9 & 2) != 0;
    }

    if (v27)
    {
      unsigned int v24 = _dispatch_thread_getspecific(0x19uLL);
      if (!((v24 & 0xF0000) >> 16)) {
        _dispatch_thread_setspecific(25LL, v24 & 0xFFF0FFFF | 0x10000);
      }
    }

    return _dispatch_lane_resume(a1, 0LL);
  }

  return result;
}

uint64_t _dispatch_lane_resume_activate(uint64_t a1)
{
  if (*(void *)(*(void *)a1 + 56LL)) {
    (*(void (**)(uint64_t))(*(void *)a1 + 56LL))(a1);
  }
  return _dispatch_lane_resume(a1, 2LL);
}

const char *__cdecl dispatch_queue_get_label(dispatch_queue_t queue)
{
  dispatch_queue_t v5 = queue;
  if (!queue)
  {
    unint64_t v4 = (uint64_t (***)())_dispatch_thread_getspecific(0x14uLL);
    if (v4) {
      BOOL v3 = v4;
    }
    else {
      BOOL v3 = &off_E46C0;
    }
    dispatch_queue_t v5 = (dispatch_queue_t)v3;
  }

  if (*((void *)v5 + 9)) {
    return (const char *)*((void *)v5 + 9);
  }
  else {
    return "";
  }
}

dispatch_qos_class_t dispatch_queue_get_qos_class(dispatch_queue_t queue, int *relative_priority_ptr)
{
  unsigned int v5 = (*((_DWORD *)queue + 21) & 0xF00u) >> 8;
  if (relative_priority_ptr)
  {
    if (v5)
    {
      int v6 = *((_DWORD *)queue + 21);
      if ((v6 & 0xF00) != 0) {
        int v7 = (char)v6 + 1;
      }
      else {
        int v7 = 0;
      }
      int v4 = v7;
    }

    else
    {
      int v4 = 0;
    }

    *relative_priority_ptr = v4;
  }

  unint64_t v3 = v5 - 1;
  if (v3 <= 5) {
    __asm { BR              X8 }
  }

  return 0;
}

uint64_t dispatch_queue_set_width(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(*(void *)a1 + 16LL);
  if (*(_BYTE *)(*(void *)a1 + 16LL) != 17LL)
  {
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Unexpected dispatch object type";
    qword_E4DA8 = v3;
    __break(1u);
    JUMPOUT(0x25BECLL);
  }

  if (v3 != 529)
  {
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Cannot set width of a serial queue";
    qword_E4DA8 = v3;
    __break(1u);
    JUMPOUT(0x25C40LL);
  }

  if ((a2 & 0x80000000) != 0) {
    return _dispatch_barrier_async_detached_f(a1, a2, (uint64_t)_dispatch_lane_set_width);
  }
  else {
    return _dispatch_barrier_trysync_or_async_f(a1, a2, (uint64_t (*)(uint64_t))_dispatch_lane_set_width, 1u);
  }
}

void _dispatch_lane_set_width(int a1)
{
  BOOL v25 = (char *)_dispatch_thread_getspecific(0x14uLL);
  if (a1 >= 0)
  {
    if (a1) {
      int v21 = a1;
    }
    else {
      int v21 = 1;
    }
    unsigned int v26 = v21;
    goto LABEL_38;
  }

  unsigned int v1 = _dispatch_thread_getspecific(4uLL);
  unsigned int v2 = 0;
  unsigned int v3 = (v1 & 0x3FFF00) >> 8;
  unsigned int v4 = __clz(__rbit32(v3));
  if (v3) {
    unsigned int v2 = v4 + 1;
  }
  switch(a1)
  {
    case -3:
      goto LABEL_30;
    case -2:
      int v32 = 0;
      if (v2)
      {
        unint64_t v20 = v2 - 1;
        if (v20 <= 5) {
          __asm { BR              X8 }
        }

        int v32 = pthread_qos_max_parallelism(0LL, 1LL);
      }

      if (v32 <= 0) {
        int v33 = MEMORY[0xFFFFFC035];
      }
      else {
        int v33 = v32;
      }
      unsigned int v26 = v33;
      break;
    case -1:
      int v30 = 0;
      if (v2)
      {
        unint64_t v19 = v2 - 1;
        if (v19 <= 5) {
          __asm { BR              X8 }
        }

        int v30 = pthread_qos_max_parallelism(0LL, 0LL);
      }

      if (v30 <= 0) {
        unsigned int v31 = MEMORY[0xFFFFFC036];
      }
      else {
        unsigned int v31 = v30;
      }
      if (MEMORY[0xFFFFFC034] < v31) {
        unsigned int v31 = MEMORY[0xFFFFFC034];
      }
      unsigned int v26 = v31;
      break;
    default:
LABEL_30:
      int v28 = 0;
      if (v2)
      {
        unint64_t v18 = v2 - 1;
        if (v18 <= 5) {
          __asm { BR              X8 }
        }

        int v28 = pthread_qos_max_parallelism(0LL, 0LL);
      }

      if (v28 <= 0) {
        int v29 = MEMORY[0xFFFFFC036];
      }
      else {
        int v29 = v28;
      }
      unsigned int v26 = v29;
      break;
  }

LABEL_38:
  if (v26 > 0xFFEuLL) {
    LOWORD(v26) = 4094;
  }
  unsigned int v22 = (unsigned int *)(v25 + 80);
  do
  {
    if (_os_atomic_mo_has_acquire(0)) {
      unsigned int v5 = __ldaxr(v22);
    }
    else {
      unsigned int v5 = __ldxr(v22);
    }
    unsigned int v24 = v5 & 0xFFFF0000 | (unsigned __int16)v26;
    if (_os_atomic_mo_has_release(0)) {
      BOOL v23 = __stlxr(v24, v22) == 0;
    }
    else {
      BOOL v23 = __stxr(v24, v22) == 0;
    }
  }

  while (!v23);
  _dispatch_lane_inherit_wlh_from_target((uint64_t)v25, *((_DWORD **)v25 + 3), v6, v7, v8, v9, v10, v11);
  _dispatch_object_debug((uint64_t)v25, "%s", v12, v13, v14, v15, v16, v17, (char)"_dispatch_lane_set_width");
}

      dispatch_queue_t queue = v111;
    }

    int v88 = 0;
    unsigned int v112 = *((_DWORD *)queue + 21) & 0xF00;
    if (v112 >> 8)
    {
      unint64_t v72 = v112 >> 8;
    }

    else
    {
      uint64_t v113 = *((_DWORD *)queue + 21) & 0xF000;
      unint64_t v72 = v113 >> 12;
    }

    int v88 = v72;
    if (*((void *)queue + 3))
    {
      unsigned int v131 = _dispatch_thread_getspecific(4uLL);
      uint64_t v129 = (unint64_t)(v131 & 0x3FFF00) >> 8;
      uint64_t v9 = (v131 & 0x3FFF00) >> 8;
      uint64_t v10 = __clz(__rbit32(v9));
      if (v9) {
        uint64_t v11 = v10 + 1;
      }
      else {
        uint64_t v11 = 0;
      }
      int v88 = v11;
    }

    v87 = 0LL;
    uint64_t v123 = v97;
    uint64_t v122 = v91;
    unsigned int v121 = v88;
    unsigned int v120 = 1;
    if (v97 && !_dispatch_attr_is_initialized(v123))
    {
      unsigned int v119 = v123;
      qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: dispatch_apply_attr not initialized using dispatch_apply_attr_init";
      qword_E4DA8 = v123;
      __break(1u);
      JUMPOUT(0x56510LL);
    }

    uint64_t v118 = 0LL;
    if (v123)
    {
      if (v122)
      {
        uint64_t v118 = 1LL;
      }

      else
      {
        unint64_t v116 = 2LL;
        uint64_t v115 = 0LL;
        v262 = v121;
        v261 = 2LL;
        v260 = 0;
        v259 = 0;
        if (v121)
        {
          v267 = v262;
          switch(v262)
          {
            case 1u:
              v268 = 5;
              break;
            case 2u:
              v268 = 9;
              break;
            case 3u:
              v268 = 17;
              break;
            case 4u:
              v268 = 21;
              break;
            case 5u:
              v268 = 25;
              break;
            case 6u:
              v268 = 33;
              break;
            default:
              v268 = 0;
              break;
          }

          v259 = pthread_qos_max_parallelism(v268, v261 & 1);
        }

        if (v259 < 1)
        {
          v274 = 0;
          v273 = 0xFFFFFC036LL;
          v260 = MEMORY[0xFFFFFC036];
        }

        else
        {
          v260 = v259;
        }

        v272 = 2;
        v271 = 0xFFFFFC034LL;
        v258 = MEMORY[0xFFFFFC034];
        if (MEMORY[0xFFFFFC034] < v260) {
          v260 = v258;
        }
        uint64_t v115 = v260;
        unint64_t v114 = 0LL;
        v266 = v123;
        v265 = v121;
        v264 = -1LL;
        if (*(void *)(v123 + 8))
        {
          v263 = 0;
          v281 = v265;
          v280 = 0;
          v279 = 0;
          v282 = v265;
          switch(v265)
          {
            case 1u:
              v283 = 5;
              break;
            case 2u:
              v283 = 9;
              break;
            case 3u:
              v283 = 17;
              break;
            case 4u:
              v283 = 21;
              break;
            case 5u:
              v283 = 25;
              break;
            case 6u:
              v283 = 33;
              break;
            default:
              v283 = 0;
              break;
          }

          v279 = pthread_qos_max_parallelism(v283, 2LL);
          if (v279 >= 1) {
            v280 = v279;
          }
          v263 = v280;
          if (v280) {
            v264 = (v263 * *(_DWORD *)(v266 + 8));
          }
          else {
            v264 = 0LL;
          }
        }

        unint64_t v114 = v264;
        if (v115 >= v264) {
          unint64_t v70 = v114;
        }
        else {
          unint64_t v70 = v115;
        }
        uint64_t v118 = v70;
      }
    }

    else
    {
      unsigned int v117 = 2LL;
      v257 = v121;
      v256 = 2LL;
      v255 = 0;
      v254 = 0;
      if (v121)
      {
        v269 = v257;
        switch(v257)
        {
          case 1u:
            v270 = 5;
            break;
          case 2u:
            v270 = 9;
            break;
          case 3u:
            v270 = 17;
            break;
          case 4u:
            v270 = 21;
            break;
          case 5u:
            v270 = 25;
            break;
          case 6u:
            v270 = 33;
            break;
          default:
            v270 = 0;
            break;
        }

        v254 = pthread_qos_max_parallelism(v270, v256 & 1);
      }

      if (v254 < 1)
      {
        v278 = 0;
        v277 = 0xFFFFFC036LL;
        v255 = MEMORY[0xFFFFFC036];
      }

      else
      {
        v255 = v254;
      }

      v276 = 2;
      v275 = 0xFFFFFC034LL;
      v253 = MEMORY[0xFFFFFC034];
      if (MEMORY[0xFFFFFC034] < v255) {
        v255 = v253;
      }
      uint64_t v118 = v255;
      if (v122)
      {
        if (v122 >= v118) {
          unint64_t v71 = 1LL;
        }
        else {
          unint64_t v71 = v118 / v122;
        }
        uint64_t v118 = v71;
      }
    }

    v87 = v118;
    if (!v118)
    {
      unsigned int v86 = v97;
      qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: attribute's properties are invalid or meaningless on this system";
      qword_E4DA8 = v97;
      __break(1u);
      JUMPOUT(0x570C8LL);
    }

    int v85 = 0LL;
    if (v97)
    {
      int v85 = 0xFFFFLL;
    }

    else if (v91)
    {
      if (v91 > 0xFFFE || v98 > 0xFFFE) {
        uint64_t v69 = 0xFFFFLL;
      }
      else {
        uint64_t v69 = v91 * v98;
      }
      int v85 = v69;
    }

    else
    {
      int v85 = v98;
    }

    if (v98 < v87) {
      v87 = v98;
    }
    memset(v82, 0, 32);
    v82[2] = v95;
    int v83 = v94;
    unint64_t v84 = queue;
    context = 0LL;
    unsigned int v132 = 0LL;
    v162 = 0LL;
    v164 = _dispatch_thread_getspecific(0x16uLL);
    if (v164) {
      _dispatch_thread_setspecific(22LL, v164[2]);
    }
    v162 = v164;
    if (v164) {
      v163 = v162;
    }
    else {
      v163 = (void *)_dispatch_continuation_alloc_from_heap();
    }
    unsigned int v132 = v163;
    context = v163;
    v163[1] = 0LL;
    *((void *)context + 2) = v98;
    *((void *)context + 3) = v85;
    *((_DWORD *)context + 11) = v87;
    *((_DWORD *)context + 13) = 0;
    _dispatch_apply_da_copy_attr((uint64_t)context, v97);
    *((void *)context + 4) = 0LL;
    *(void *)context = v82;
    *((_DWORD *)context + 10) = 0;
    unsigned int v134 = queue;
    BOOL v68 = 1;
    if (*((void *)queue + 3) != (void)&_dispatch_custom_workloop_root_queue) {
      BOOL v68 = *((void *)v134 + 3) == (void)&_dispatch_custom_workloop_overcommit_root_queue;
    }
    if (v68)
    {
      unsigned int v80 = 0LL;
      int v79 = 0LL;
      unsigned int v135 = *((void *)queue + 7);
      v166 = v135;
      unint64_t v67 = v135;
      else {
        _dispatch_apply_serial((uint64_t)context);
      }
      return;
    }

    uint64_t v66 = 1;
    if (*((_WORD *)queue + 40) != 1) {
      uint64_t v66 = v87 < 2;
    }
    if (v66)
    {
LABEL_135:
      dispatch_sync_f(queue, context, (dispatch_function_t)_dispatch_apply_serial);
      return;
    }

    if (*((void *)queue + 3))
    {
      if (queue != v90)
      {
        dispatch_sync_f(queue, context, (dispatch_function_t)_dispatch_apply_redirect);
        return;
      }

      goto LABEL_135;
    }

    unint64_t v78 = 0uLL;
    uint64_t v125 = queue;
    unsigned int v124 = &v78;
    uint64_t v127 = &v78;
    _dispatch_thread_getspecific_packed_pair(20LL, 21LL, &v78, v12, v13, v14, v15, v16);
    _dispatch_thread_setspecific_pair(20LL, (uint64_t)v125, 21LL, (uint64_t)v124, v17, v18, v19, v20);
    v158 = queue;
    v159 = queue;
    unsigned int v150 = (uint64_t (***)())queue;
    unsigned int v149 = (uint64_t (*)())context;
    unsigned int v148 = _dispatch_apply_invoke;
    j = 0;
    uint64_t v146 = 0LL;
    v145 = 0LL;
    unsigned int v144 = 0LL;
    v153 = 0LL;
    v153 = _dispatch_thread_getspecific(4uLL);
    unsigned int v144 = (unint64_t)v153;
    unsigned int v143 = 0;
    unsigned int v143 = *((_DWORD *)v149 + 11) - 1;
    v152 = v143;
    unsigned int v151 = 336LL;
    if (!v143) {
      _dispatch_abort(v151, v152, v21, v22, v23, v24, v25, v26);
    }
    for (j = 0; j < v143; ++j)
    {
      unsigned int v142 = 0LL;
      v160 = 0LL;
      v165 = 0LL;
      v165 = (uint64_t (**)())_dispatch_thread_getspecific(0x16uLL);
      if (v165) {
        _dispatch_thread_setspecific(22LL, (uint64_t)v165[2]);
      }
      v160 = v165;
      if (v165) {
        v161 = v160;
      }
      else {
        v161 = (uint64_t (**)())_dispatch_continuation_alloc_from_heap();
      }
      unsigned int v142 = v161;
      unsigned int v141 = 4LL;
      int v140 = v150;
      v173 = v150;
      v172 = v161;
      v171 = v149;
      v170 = v148;
      v169 = 0x40000000LL;
      v168 = 4LL;
      v167 = 0LL;
      *v161 = (uint64_t (*)())(&stru_B8 + 76);
      v172[4] = (uint64_t (*)())v170;
      v172[5] = v171;
      if ((v169 & 0x40000000) == 0)
      {
        v224 = 0LL;
        v223 = 1;
        v226 = 0LL;
        v226 = _dispatch_thread_getspecific(4uLL);
        v227 = v226;
        v224 = v226 & 0xFFFFFF;
        if ((v223 & 2) != 0 || (v231 = 5, v230 = 4096LL, v224 <= 0x10FF))
        {
          v225 = v224;
        }

        else
        {
          v229 = 5;
          v228 = 4096LL;
          v225 = 4351LL;
        }

        v167 = v225;
      }

      v211 = v172;
      v210 = v169;
      v209 = 0LL;
      v213 = (int)v169 >= 0;
      v212 = 583LL;
      if ((v210 & 0x40) == 0)
      {
        v232 = 0LL;
        v232 = _dispatch_thread_getspecific(0x1CuLL);
        if (v232)
        {
          object = v232;
          os_retain(v232);
        }

        v209 = (uint64_t (*)())v232;
      }

      v211[3] = v209;
      _dispatch_thread_getspecific(0LL);
      _dispatch_log("%u\t%p\tvoucher[%p]: continuation[%p] set", v33, v34, v35, v36, v37, v38, v39, 589LL);
      unsigned int v40 = v211[3];
      v236 = 771817476;
      v235 = v40;
      v234 = v211;
      if (v40 != (uint64_t (*)())-1LL)
      {
        v233 = 0;
        uint64_t v65 = v235 ? *((_DWORD *)v235 + 8) : 0;
        v233 = v65;
        v242 = v236;
        v241 = v65;
        v240 = v234;
        v239 = 0LL;
        v238 = 0LL;
        if (MEMORY[0xFFFFFC100]) {
          kdebug_trace(v242, v241, v240, v239, v238);
        }
      }

      v222 = v173;
      v221 = v172;
      v220 = v167;
      v219 = v169;
      v218 = 0;
      v217 = v173;
      if (v167)
      {
        v216 = (v219 & 0x20) != 0;
        v215 = 0;
        v215 = (*((_DWORD *)v217 + 21) & 0x40000000) != 0;
        v214 = 0;
        v214 = (*((_DWORD *)v217 + 21) & 0xFFF) != 0;
        if ((v219 & 0x20) != 0)
        {
          v220 |= 0x10000000uLL;
          v243 = v220 >> 8;
          unint64_t v41 = v220 >> 8;
          uint64_t v42 = __clz(__rbit32(v41));
          if (v41) {
            uint64_t v43 = v42 + 1;
          }
          else {
            uint64_t v43 = 0;
          }
          v218 = v43;
        }

        else if (v215 || !v214)
        {
          v244 = v220 >> 8;
          int v44 = v220 >> 8;
          uint64_t v45 = __clz(__rbit32(v44));
          if (v44) {
            unint64_t v46 = v45 + 1;
          }
          else {
            unint64_t v46 = 0;
          }
          v218 = v46;
        }

        else
        {
          v220 = 0LL;
        }
      }

      v221[1] = (uint64_t (*)())v220;
      v142[1] = (uint64_t (*)())(v144 | 0x10000000);
      v142[2] = (uint64_t (*)())v146;
      uint64_t v146 = v142;
      if (!v145) {
        v145 = v142;
      }
    }

    *((_DWORD *)v149 + 12) = *((_DWORD *)v149 + 11);
    *((void *)v149 + 4) = _dispatch_calloc(*((int *)v149 + 11), 8LL);
    unsigned int v139 = v146;
    unsigned int v138 = v145;
    v182 = v146;
    v181 = v145;
    v180 = v150;
    v179 = 0;
    v178 = 0;
    if (MEMORY[0xFFFFFC100])
    {
      v177 = v182;
      do
      {
        v176 = 0;
        v175 = 0;
        uint64_t v64 = 0;
        if (v177 != v181)
        {
          v177 = (uint64_t (**)())v177[2];
          uint64_t v64 = v177 != 0LL;
        }
      }

      while (v64);
    }

    v174 = v180;
    v247 = v180;
    v246 = v182;
    v245 = v181;
    unsigned int v137 = v146;
    unsigned int v136 = v145;
    v208 = v146;
    v207 = v145;
    v206 = v150;
    v205 = v143;
    v204 = v146;
    v203 = v145;
    v202 = 0LL;
    v201 = (unint64_t)v145;
    v200 = 0LL;
    v199 = 0LL;
    v145[2] = 0LL;
    v198 = v200;
    _dispatch_thread_setspecific(122LL, (uint64_t)(v206 + 6));
    v196 = 0LL;
    v194 = v201;
    v193 = v201;
    v195 = v201;
    uint64_t v61 = (unint64_t *)(v206 + 6);
    uint64_t v62 = v201;
    unint64_t v63 = v206[6];
    do
    {
      uint64_t v47 = v63;
      do
        unint64_t v48 = __ldaxr(v61);
      while ((uint64_t (**)())v48 == v63 && __stlxr(v62, v61));
      unint64_t v63 = (uint64_t (**)())v48;
    }

    while (v48 != (void)v47);
    v192 = v48;
    v196 = v48;
    v191 = v48;
    v197 = v48;
    v202 = v48;
    v190 = v48;
    if (v48)
    {
      v189 = v204;
      v188 = v204;
      *(void *)(v190 + 16) = v204;
      v187 = v189;
    }

    else
    {
      v186 = v204;
      v185 = v204;
      v206[13] = v204;
      v184 = v186;
    }

    _dispatch_thread_setspecific(122LL, 0LL);
    v183 = v202 == 0;
    if (!v202) {
      _dispatch_root_queue_poke_and_wakeup(v206, v205, 0, v51, v52, v53, v54, v55);
    }
    _dispatch_apply_invoke_and_wait((uint64_t)v149, v49, v50, v51, v52, v53, v54, v55);
    unsigned int v126 = &v78;
    _dispatch_thread_setspecific_packed_pair(20LL, 21LL, &v78, v56, v57, v58, v59, v60);
  }

      uint64_t v13 = v32;
      if (v32 < 0) {
        firehose_buffer_ring_enqueue(v17, BYTE4(v15));
      }
      if (v13 >= 1)
      {
        qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: Allocation should always fail";
        qword_E4DA8 = v13;
        __break(1u);
        JUMPOUT(0x9B784LL);
      }

      uint64_t v14 = v15;
      BYTE4(v14) = 0;
      do
        uint64_t v9 = __ldaxr(v16);
      while (v9 == v15 && __stlxr(v14, v16));
    }

    else
    {
      firehose_buffer_force_connect(_firehose_task_buffer, a2, a3, a4, a5, a6, a7, a8);
    }
  }

void _dispatch_lane_set_target_queue(uint64_t a1, uint64_t (***a2)())
{
  uint64_t v16 = a2;
  if (!a2) {
    uint64_t v16 = &(&_dispatch_root_queues)[16 * (unint64_t)((*(_WORD *)(a1 + 80) == 1) + 9)];
  }
  unint64_t v18 = (unint64_t *)(a1 + 56);
  do
  {
    if (_os_atomic_mo_has_acquire(0)) {
      unint64_t v9 = __ldaxr(v18);
    }
    else {
      unint64_t v9 = __ldxr(v18);
    }
    __int16 v21 = HIWORD(v9);
    if ((~v9 & 0x180000000000000LL) != 0)
    {
      __clrex();
      char v22 = 0;
      goto LABEL_18;
    }

    unint64_t v20 = v9 + 0x400000000000000LL;
    if (_os_atomic_mo_has_release(0)) {
      BOOL v19 = __stlxr(v20, v18) == 0;
    }
    else {
      BOOL v19 = __stxr(v20, v18) == 0;
    }
  }

  while (!v19);
  LOBYTE(v14) = 1;
  if ((v21 & 0xFF80) != 0) {
    int v14 = (HIBYTE(v21) >> 1) & 1;
  }
  if ((v14 & 1) != 0)
  {
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Too many calls to dispatch_suspend() prior to calling dispatch_"
                           "set_target_queue() or dispatch_set_*_handler()";
    __break(1u);
    JUMPOUT(0x26F58LL);
  }

  char v22 = 1;
LABEL_18:
  if (v22 == 1)
  {
    _dispatch_retain((uint64_t)v16);
    uint64_t v12 = (unint64_t *)(a1 + 24);
    uint64_t v13 = *(unsigned int **)(a1 + 24);
    do
    {
      uint64_t v10 = v13;
      do
        uint64_t v11 = (unsigned int *)__ldaxr(v12);
      while (v11 == v13 && __stlxr((unint64_t)v16, v12));
      uint64_t v13 = v11;
    }

    while (v11 != v10);
    if (v11) {
      _dispatch_release(v11);
    }
    _dispatch_lane_resume((unsigned __int16 *)a1, 0);
  }

  else
  {
    if (((BYTE2(*(_DWORD *)(a1 + 80)) >> 6) & 1) == 0)
    {
      if ((*(_DWORD *)(a1 + 80) & 0x100000) != 0)
      {
        qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Cannot change the target of a queue already targeted by oth"
                               "er dispatch objects";
        __break(1u);
        JUMPOUT(0x2711CLL);
      }

      qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Cannot change the target of this object after it has been activated";
      __break(1u);
      JUMPOUT(0x27148LL);
    }

    uint64_t v15 = *(unsigned __int8 *)(*(void *)a1 + 16LL);
    if (v15 == 17)
    {
      if ((*(_DWORD *)(a1 + 80) & 0x100000) != 0) {
        _dispatch_bug_deprecated( (uint64_t)"Changing the target of a queue already targeted by other dispatch objects",  v2,  v3,  v4,  v5,  v6,  v7,  v8);
      }
    }

    else
    {
      if (*(_BYTE *)(*(void *)a1 + 16LL) != 19LL)
      {
        qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Unexpected dispatch object type";
        qword_E4DA8 = v15;
        __break(1u);
        JUMPOUT(0x27298LL);
      }

      if (MEMORY[0xFFFFFC100]) {
        kdebug_trace(771883016LL, a1, 0LL, 0LL, 0LL);
      }
      _dispatch_bug_deprecated( (uint64_t)"Changing the target of a source after it has been activated",  v2,  v3,  v4,  v5,  v6,  v7,  v8);
    }

    _dispatch_retain((uint64_t)v16);
    _dispatch_barrier_trysync_or_async_f( a1,  (uint64_t)v16,  (uint64_t (*)(uint64_t))_dispatch_lane_legacy_set_target_queue,  1u);
  }

void _dispatch_lane_legacy_set_target_queue(unint64_t a1)
{
  int v29 = (char *)_dispatch_thread_getspecific(0x14uLL);
  BOOL v27 = (unsigned int *)*((void *)v29 + 3);
  if ((*((_DWORD *)v29 + 20) & 0x100000) != 0)
  {
    if (MEMORY[0xFFFFFC100]) {
      kdebug_trace(771883012LL, v29, v27, a1, 0LL);
    }
    _dispatch_bug_deprecated( (uint64_t)"Changing the target of a queue already targeted by other dispatch objects",  v1,  v2,  v3,  v4,  v5,  v6,  v7);
  }

  int v28 = _dispatch_queue_priority_inherit_from_target((uint64_t)v29, a1);
  _dispatch_lane_inherit_wlh_from_target((uint64_t)v29, v28, v8, v9, v10, v11, v12, v13);
  unsigned int v31 = _dispatch_thread_getspecific(3uLL) & 0xFFFFFFFC;
  int v14 = (unsigned int *)(v29 + 100);
  do
    unsigned int v15 = __ldaxr(v14);
  while (!v15 && __stlxr(v31, v14));
  if (v15) {
    _dispatch_unfair_lock_lock_slow((unsigned int *)v29 + 25, 0x10000);
  }
  if (((BYTE2(*((_DWORD *)v29 + 20)) >> 6) & 1) == 0)
  {
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Cannot change the target of this object after it has been activated";
    __break(1u);
    JUMPOUT(0x27594LL);
  }

  *((void *)v29 + 3) = v28;
  unsigned int v33 = _dispatch_thread_getspecific(3uLL) & 0xFFFFFFFC;
  BOOL v25 = (unsigned int *)(v29 + 100);
  unsigned int v26 = *((_DWORD *)v29 + 25);
  do
  {
    unsigned int v22 = v26;
    do
      unsigned int v23 = __ldaxr(v25);
    while (v23 == v26 && __stlxr(0, v25));
    char v24 = v23;
    unsigned int v26 = v23;
  }

  while (v23 != v22);
  if (v23 == v33)
  {
    BOOL v34 = 0;
  }

  else
  {
    _dispatch_unfair_lock_unlock_slow((uint64_t)(v29 + 100), v23);
    BOOL v34 = (v24 & 2) != 0;
  }

  if (v34)
  {
    unsigned int v32 = _dispatch_thread_getspecific(0x19uLL);
    if (!((v32 & 0xF0000) >> 16)) {
      _dispatch_thread_setspecific(25LL, v32 & 0xFFF0FFFF | 0x10000);
    }
  }

  _dispatch_object_debug( (uint64_t)v29,  "%s",  v16,  v17,  v18,  v19,  v20,  v21,  (char)"_dispatch_lane_legacy_set_target_queue");
  _dispatch_release_tailcall(v27);
}

void _dispatch_poll_for_events_4launchd()
{
  _dispatch_return_to_kernel();
}

void _dispatch_return_to_kernel()
{
  uint64_t v7 = _dispatch_thread_getspecific(0x1DuLL);
  BOOL v6 = 0;
  if (v7) {
    BOOL v6 = v7[3] != -4LL;
  }
  if (v6)
  {
    if ((*((_BYTE *)v7 + 45) & 4) == 0) {
      _dispatch_abort(3612LL, (*((_BYTE *)v7 + 45) & 4) != 0, v0, v1, v2, v3, v4, v5);
    }
    _dispatch_event_loop_drain(1u);
  }

  else
  {
    _dispatch_thread_setspecific(5LL, 0LL);
  }

BOOL dispatch_swift_job_should_yield()
{
  return _dispatch_thread_getspecific(0x78uLL) != 0LL;
}

uint64_t _dispatch_lane_serial_drain( uint64_t a1, uint64_t a2, int a3, void *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v46 = a1;
  uint64_t v45 = a2;
  unsigned int v44 = a3 & 0xFFFDFFFF;
  uint64_t v43 = a4;
  char v42 = 1;
  uint64_t v41 = 0LL;
  uint64_t v41 = *(void *)(a1 + 24);
  __int128 v40 = 0uLL;
  uint64_t v36 = *a4;
  if (!*(void *)(a1 + 48)) {
    return 0LL;
  }
  uint64_t v152 = v46;
  unsigned int v151 = &v40;
  v156 = &v40;
  _dispatch_thread_getspecific_packed_pair(20LL, 21LL, &v40, (uint64_t)a4, a5, a6, a7, a8);
  _dispatch_thread_setspecific_pair(20LL, v152, 21LL, (uint64_t)v151, v8, v9, v10, v11);
  if ((v42 & 1) != 0 || (uint64_t v48 = v36, (v36 & 0x40000000000000LL) != 0)) {
    uint64_t v37 = 0x40000000000000LL;
  }
  else {
    uint64_t v37 = v36 & 0x3FFE0000000000LL;
  }
  uint64_t v89 = v46;
  int v88 = (unint64_t *)(v46 + 104);
  uint64_t v87 = 0LL;
  uint64_t v86 = 0LL;
  uint64_t v85 = *(void *)(v46 + 104);
  uint64_t v86 = v85;
  uint64_t v84 = v85;
  uint64_t v87 = v85;
  if (!v85) {
    uint64_t v87 = _dispatch_wait_for_enqueuer(v88, v89 + 48);
  }
  uint64_t v83 = v87;
  unsigned int v39 = (void *)v87;
  while (1)
  {
    uint64_t v49 = *(void *)(v46 + 56);
    if ((v49 & 0xFF80000000000000LL) != 0 || v41 != *(void *)(v46 + 24)) {
      break;
    }
    if ((v42 & 1) != 0) {
      goto LABEL_35;
    }
    uint64_t v64 = v39;
    int v63 = 0;
    unsigned int v148 = v39;
    if (*v39 > 0xFFFuLL)
    {
      if ((*(void *)(*(void *)v64 + 16LL) & 0xF0LL) == 0x10)
      {
        int v62 = 0;
        int v61 = v64[20];
        int v62 = v61;
        int v60 = v61;
        int v63 = v61;
        BOOL v65 = (v61 & 0x80000) != 0;
      }

      else
      {
        BOOL v65 = 0;
      }
    }

    else
    {
      BOOL v65 = (*v64 & 2) != 0;
    }

    if (v65)
    {
LABEL_35:
      if ((v42 & 1) == 0 && v37 != 0x40000000000000LL)
      {
        uint64_t v166 = v46;
        uint64_t v165 = v37;
        unint64_t v164 = 0LL;
        unint64_t v163 = 0LL;
        unint64_t v162 = 0LL;
        unint64_t v162 = ((unint64_t)(*(unsigned __int16 *)(v46 + 80) - 1) << 41) | 0x10000000000LL;
        BOOL v161 = 0;
        v160 = (unint64_t *)(v46 + 56);
        do
        {
          if (_os_atomic_mo_has_acquire(2)) {
            unint64_t v19 = __ldaxr(v160);
          }
          else {
            unint64_t v19 = __ldxr(v160);
          }
          unint64_t v164 = v19;
          unint64_t v163 = v19 - v165;
          unint64_t v168 = v19;
          if ((v19 & 0x10000000000LL) == 0) {
            v163 += v162;
          }
          unint64_t v167 = v163;
          if (!(v163 >> 53))
          {
            v163 += 0x20000000000LL;
            v163 += 0x40000000000000LL;
            v163 -= 0x10000000000LL;
          }

          v163 &= ~0x8000000000uLL;
          if (_os_atomic_mo_has_release(2)) {
            BOOL v161 = __stlxr(v163, v160) == 0;
          }
          else {
            BOOL v161 = __stxr(v163, v160) == 0;
          }
        }

        while (!v161);
        BOOL v159 = v161;
        if ((v163 & 0x40000000000000LL) == 0) {
          goto LABEL_144;
        }
        uint64_t v37 = 0x40000000000000LL;
      }

      v169 = v39;
      v171 = v39;
      if (*v39 >= 0x1000uLL) {
        char v170 = 0;
      }
      else {
        char v170 = *v169 & 1;
      }
      if (v170 == 1 && (v44 & 0x80000) == 0)
      {
        *(void *)(v45 + 8) = v39;
        if ((v44 & 8) != 0)
        {
          qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: Deferred continuation on source, mach channel or mgr";
          __break(1u);
          JUMPOUT(0x28BE8LL);
        }

        v153 = &v40;
        _dispatch_thread_setspecific_packed_pair(20LL, 21LL, &v40, v13, v14, v15, v16, v17);
        return *(void *)(v46 + 24);
      }

      uint64_t v117 = v46;
      unint64_t v116 = v39;
      uint64_t v115 = v39;
      uint64_t v114 = 0LL;
      unint64_t v113 = 0LL;
      unint64_t v112 = 0LL;
      uint64_t v111 = 0LL;
      uint64_t v110 = v39[2];
      uint64_t v111 = v110;
      uint64_t v109 = v110;
      uint64_t v114 = v110;
      uint64_t v108 = v110;
      uint64_t v107 = v110;
      *(void *)(v46 + 104) = v110;
      uint64_t v106 = v108;
      if (!v114)
      {
        uint64_t v103 = 0LL;
        uint64_t v104 = 0LL;
        uint64_t v105 = v117 + 48;
        BOOL v102 = 0;
        uint64_t v101 = (unint64_t *)(v117 + 48);
        while (1)
        {
          unint64_t v20 = _os_atomic_mo_has_acquire(3) ? __ldaxr(v101) : __ldxr(v101);
          unint64_t v112 = v20;
          unint64_t v147 = v20;
          if (v115 != (void *)(v20 & 0xFFFFFFFFFFFFFFF8LL)) {
            break;
          }
          unint64_t v113 = 0LL;
          if (_os_atomic_mo_has_release(3)) {
            BOOL v102 = __stlxr(v113, v101) == 0;
          }
          else {
            BOOL v102 = __stxr(v113, v101) == 0;
          }
          if (v102) {
            goto LABEL_70;
          }
        }

        __clrex();
        uint64_t v100 = v115;
        uint64_t v99 = 0LL;
        uint64_t v98 = 0LL;
        uint64_t v97 = v115[2];
        uint64_t v98 = v97;
        uint64_t v96 = v97;
        uint64_t v99 = v97;
        if (!v97) {
          uint64_t v99 = _dispatch_wait_for_enqueuer(v100 + 2, v117 + 48);
        }
        uint64_t v95 = v99;
        uint64_t v114 = v99;
        uint64_t v94 = v99;
        uint64_t v93 = v99;
        *(void *)(v117 + 104) = v99;
        uint64_t v92 = v94;
LABEL_70:
        BOOL v91 = v102;
      }

      uint64_t v90 = v114;
      int v38 = (void *)v114;
LABEL_127:
      _dispatch_continuation_pop_inline(v39, v45, v44, v46);
      goto LABEL_10;
    }

    if (v37 == 0x40000000000000LL)
    {
      unsigned int v33 = (unint64_t *)(v46 + 56);
      unint64_t v34 = *(void *)(v46 + 56);
      do
      {
        unint64_t v21 = v34;
        do
          unint64_t v22 = __ldaxr(v33);
        while (v22 == v34 && __stlxr(v34 ^ 0x40000000000000LL, v33));
        unint64_t v34 = v22;
      }

      while (v22 != v21);
      uint64_t v37 = (unint64_t)*(unsigned __int16 *)(v46 + 80) << 41;
    }

    else if (!v37)
    {
      uint64_t v56 = v39;
      unsigned int v150 = v39;
      if (*v39 < 0x1000uLL && (*v56 & 0x81LL) != 0)
      {
        uint64_t v182 = v46;
        uint64_t v180 = 0x20000000000LL;
        uint64_t v179 = 0x20000000000LL;
        uint64_t v181 = 0x20000000000LL;
        unint64_t v177 = 0LL;
        uint64_t v175 = 0x20000000000LL;
        uint64_t v174 = 0x20000000000LL;
        uint64_t v176 = 0x20000000000LL;
        unsigned int v31 = (unint64_t *)(v46 + 56);
        unint64_t v32 = *(void *)(v46 + 56);
        do
        {
          unint64_t v23 = v32;
          do
            unint64_t v24 = __ldaxr(v31);
          while (v24 == v32 && __stlxr(v32 + 0x20000000000LL, v31));
          unint64_t v32 = v24;
        }

        while (v24 != v23);
        unint64_t v173 = v24;
        unint64_t v177 = v24;
        unint64_t v172 = v24;
        unint64_t v178 = v24 + v181;
      }

      else
      {
        uint64_t v71 = v46;
        unint64_t v70 = 0LL;
        unint64_t v69 = 0LL;
        BOOL v68 = 0;
        unint64_t v67 = (unint64_t *)(v46 + 56);
        do
        {
          if (_os_atomic_mo_has_acquire(2)) {
            unint64_t v25 = __ldaxr(v67);
          }
          else {
            unint64_t v25 = __ldxr(v67);
          }
          unint64_t v70 = v25;
          unint64_t v73 = v25;
          char v30 = 1;
          if (!(v25 >> 53))
          {
            unint64_t v75 = v70;
            char v30 = 1;
            if ((v70 & 0x8000000000LL) == 0)
            {
              unint64_t v74 = v70;
              char v30 = BYTE5(v70) & 1;
            }
          }

          if ((v30 & 1) != 0)
          {
            __clrex();
            BOOL v72 = 0;
            goto LABEL_104;
          }

          unint64_t v69 = v70 + 0x20000000000LL;
          if (_os_atomic_mo_has_release(2)) {
            BOOL v68 = __stlxr(v69, v67) == 0;
          }
          else {
            BOOL v68 = __stxr(v69, v67) == 0;
          }
        }

        while (!v68);
        BOOL v66 = v68;
        BOOL v72 = v68;
LABEL_104:
        if (!v72)
        {
LABEL_144:
          *v43 &= 0x4000000001uLL;
          v154 = &v40;
          _dispatch_thread_setspecific_packed_pair(20LL, 21LL, &v40, v13, v14, v15, v16, v17);
          return -1LL;
        }
      }

      uint64_t v37 = 0x20000000000LL;
    }

    uint64_t v145 = v46;
    unsigned int v144 = v39;
    unsigned int v143 = v39;
    uint64_t v142 = 0LL;
    unint64_t v141 = 0LL;
    unint64_t v140 = 0LL;
    uint64_t v139 = 0LL;
    uint64_t v138 = v39[2];
    uint64_t v139 = v138;
    uint64_t v137 = v138;
    uint64_t v142 = v138;
    uint64_t v136 = v138;
    uint64_t v135 = v138;
    *(void *)(v46 + 104) = v138;
    uint64_t v134 = v136;
    if (!v142)
    {
      uint64_t v131 = 0LL;
      uint64_t v132 = 0LL;
      uint64_t v133 = v145 + 48;
      BOOL v130 = 0;
      uint64_t v129 = (unint64_t *)(v145 + 48);
      while (1)
      {
        unint64_t v26 = _os_atomic_mo_has_acquire(3) ? __ldaxr(v129) : __ldxr(v129);
        unint64_t v140 = v26;
        unint64_t v146 = v26;
        if (v143 != (void *)(v26 & 0xFFFFFFFFFFFFFFF8LL)) {
          break;
        }
        unint64_t v141 = 0LL;
        if (_os_atomic_mo_has_release(3)) {
          BOOL v130 = __stlxr(v141, v129) == 0;
        }
        else {
          BOOL v130 = __stxr(v141, v129) == 0;
        }
        if (v130) {
          goto LABEL_119;
        }
      }

      __clrex();
      uint64_t v128 = v143;
      uint64_t v127 = 0LL;
      uint64_t v126 = 0LL;
      uint64_t v125 = v143[2];
      uint64_t v126 = v125;
      uint64_t v124 = v125;
      uint64_t v127 = v125;
      if (!v125) {
        uint64_t v127 = _dispatch_wait_for_enqueuer(v128 + 2, v145 + 48);
      }
      uint64_t v123 = v127;
      uint64_t v142 = v127;
      uint64_t v122 = v127;
      uint64_t v121 = v127;
      *(void *)(v145 + 104) = v127;
      uint64_t v120 = v122;
LABEL_119:
      BOOL v119 = v130;
    }

    uint64_t v118 = v142;
    int v38 = (void *)v142;
    uint64_t v58 = v39;
    unsigned int v149 = v39;
    if (*v39 < 0x1000uLL && (*v58 & 0x81LL) != 0)
    {
      v37 -= 0x20000000000LL;
      _dispatch_non_barrier_waiter_redirect_or_wake(v46, (uint64_t)v39, v12, v13, v14, v15, v16, v17);
    }

    else
    {
      if ((v44 & 0x20000) == 0) {
        goto LABEL_127;
      }
      v37 -= 0x20000000000LL;
      uint64_t v52 = v46;
      unint64_t v53 = (unint64_t)*(unsigned int *)(v46 + 60) << 32;
      v53 &= 0x700000000uLL;
      _dispatch_continuation_redirect_push(v46, v39, HIDWORD(v53));
    }

LABEL_10:
    BOOL v18 = *(void *)(v45 + 8) == 0LL;
    BOOL v51 = *(void *)(v45 + 8) == 0LL;
    uint64_t v50 = 3803LL;
    if (!v18) {
      _dispatch_abort(v50, v51, v27, v13, v14, v15, v16, v17);
    }
    unsigned int v39 = v38;
    if (!v38)
    {
      if (!*(void *)(v46 + 48)) {
        break;
      }
      uint64_t v82 = v46;
      unint64_t v81 = (unint64_t *)(v46 + 104);
      uint64_t v80 = 0LL;
      uint64_t v79 = 0LL;
      uint64_t v78 = *(void *)(v46 + 104);
      uint64_t v79 = v78;
      uint64_t v77 = v78;
      uint64_t v80 = v78;
      if (!v78) {
        uint64_t v80 = _dispatch_wait_for_enqueuer(v81, v82 + 48);
      }
      uint64_t v76 = v80;
      unsigned int v39 = (void *)v80;
    }

    if (_dispatch_thread_getspecific(5uLL)) {
      _dispatch_return_to_kernel();
    }
    if ((v42 & 1) == (*(_WORD *)(v46 + 80) == 1))
    {
      char v35 = 0;
      if ((v44 & 0x4000000) == 0)
      {
        uint64_t v158 = v45;
        v157 = 0LL;
        v157 = _dispatch_thread_getspecific(0x78uLL);
        char v35 = v157 & 1;
      }

      if ((v35 & 1) == 0)
      {
        if ((v44 & 0x100000) == 0) {
          continue;
        }
        __int128 v54 = (unsigned int *)_dispatch_thread_getspecific(0x1BuLL);
        unint64_t v55 = (unint64_t)v54[15] << 32;
        v55 &= 0x700000000uLL;
      }
    }

    break;
  }

  if (v37 == 0x40000000000000LL) {
    uint64_t v37 = ((unint64_t)*(unsigned __int16 *)(v46 + 80) << 41) + 0x40000000000000LL;
  }
  if (v39)
  {
    uint64_t v188 = v46;
    uint64_t v187 = v37;
    v186 = v39;
    unsigned __int16 v185 = 0;
    unsigned __int16 v185 = *(_WORD *)(v46 + 80);
    unint64_t v184 = 0LL;
    if (v185 >= 2u)
    {
      v183 = v186;
      v193 = v186;
      int v192 = 0;
      v195 = v186;
      if (*v186 > 0xFFFuLL)
      {
        if ((*(void *)(*(void *)v193 + 16LL) & 0xF0LL) == 0x10)
        {
          int v191 = 0;
          int v190 = v193[20];
          int v191 = v190;
          int v189 = v190;
          int v192 = v190;
          BOOL v194 = (v190 & 0x80000) != 0;
        }

        else
        {
          BOOL v194 = 0;
        }
      }

      else
      {
        BOOL v194 = (*v193 & 2) != 0;
      }

      if (v194)
      {
        unint64_t v184 = ((unint64_t)(v185 - 1) << 41) + 0x10000000000LL;
        v187 -= v184;
      }
    }

    uint64_t v37 = v187;
  }

  *v43 &= 0x4000000001uLL;
  *v43 |= v37;
  v155 = &v40;
  _dispatch_thread_setspecific_packed_pair(20LL, 21LL, &v40, v13, v14, v15, v16, v17);
  if (v39) {
    return *(void *)(v46 + 24);
  }
  else {
    return 0LL;
  }
}

    BOOL v18 = *(void *)(v45 + 8) == 0LL;
    BOOL v51 = *(void *)(v45 + 8) == 0LL;
    uint64_t v50 = 3803LL;
    if (!v18) {
      _dispatch_abort(v50, v51, v27, v13, v14, v15, v16, v17);
    }
    unsigned int v39 = v38;
    if (!v38)
    {
      if (!*(void *)(v46 + 48)) {
        break;
      }
      uint64_t v82 = v46;
      unint64_t v81 = (unint64_t *)(v46 + 104);
      uint64_t v80 = 0LL;
      uint64_t v79 = 0LL;
      uint64_t v78 = *(void *)(v46 + 104);
      uint64_t v79 = v78;
      uint64_t v77 = v78;
      uint64_t v80 = v78;
      if (!v78) {
        uint64_t v80 = _dispatch_wait_for_enqueuer(v81, v82 + 48);
      }
      uint64_t v76 = v80;
      unsigned int v39 = (void *)v80;
    }

    if (_dispatch_thread_getspecific(5uLL)) {
      _dispatch_return_to_kernel();
    }
    if ((v42 & 1) == (*(_WORD *)(v46 + 80) == 1))
    {
      char v35 = 0;
      if ((v44 & 0x4000000) == 0)
      {
        uint64_t v158 = v45;
        v157 = 0LL;
        v157 = _dispatch_thread_getspecific(0x78uLL);
        char v35 = v157 & 1;
      }

      if ((v35 & 1) == 0)
      {
        if ((v44 & 0x100000) == 0) {
          continue;
        }
        __int128 v54 = (unsigned int *)_dispatch_thread_getspecific(0x1BuLL);
        unint64_t v55 = (unint64_t)v54[15] << 32;
        v55 &= 0x700000000uLL;
      }
    }

    break;
  }

  if (v37 == 0x40000000000000LL) {
    uint64_t v37 = ((unint64_t)*(unsigned __int16 *)(v46 + 80) << 41) + 0x40000000000000LL;
  }
  if (v39)
  {
    uint64_t v188 = v46;
    uint64_t v187 = v37;
    v186 = v39;
    unsigned __int16 v185 = 0;
    unsigned __int16 v185 = *(_WORD *)(v46 + 80);
    unint64_t v184 = 0LL;
    if (v185 >= 2u)
    {
      v183 = v186;
      v193 = v186;
      int v192 = 0;
      v195 = v186;
      if (*v186 > 0xFFFuLL)
      {
        if ((*(void *)(*(void *)v193 + 16LL) & 0xF0LL) == 0x10)
        {
          int v191 = 0;
          int v190 = v193[20];
          int v191 = v190;
          int v189 = v190;
          int v192 = v190;
          BOOL v194 = (v190 & 0x80000) != 0;
        }

        else
        {
          BOOL v194 = 0;
        }
      }

      else
      {
        BOOL v194 = (*v193 & 2) != 0;
      }

      if (v194)
      {
        unint64_t v184 = ((unint64_t)(v185 - 1) << 41) + 0x10000000000LL;
        v187 -= v184;
      }
    }

    uint64_t v37 = v187;
  }

  *v43 &= 0x4000000001uLL;
  *v43 |= v37;
  v155 = &v40;
  _dispatch_thread_setspecific_packed_pair(20LL, 21LL, &v40, v13, v14, v15, v16, v17);
  if (v39) {
    return *(void *)(v46 + 24);
  }
  else {
    return 0LL;
  }
}

void _dispatch_queue_invoke_finish(unsigned int *a1, uint64_t a2, uint64_t (***a3)(), uint64_t a4)
{
  uint64_t v19 = *(void *)(a2 + 8);
  int v18 = *(_DWORD *)(a2 + 16);
  if (v19)
  {
    *(_BYTE *)(v19 + 106) = *(_BYTE *)(v19 + 106) & 0x7F | 0x80;
    *(void *)(a2 + 8) = 0LL;
    *(_DWORD *)(a2 + 16) = 0;
    uint64_t v21 = a4 & 0x4000000001LL;
    if (v18) {
      _dispatch_workloop_drain_barrier_waiter((uint64_t)a1, v19, v18, 1u, v21);
    }
    else {
      _dispatch_lane_drain_barrier_waiter((uint64_t)a1, v19, 1u, v21);
    }
  }

  else
  {
    uint64_t v14 = 1LL;
    if (a3 == &_dispatch_mgr_q) {
      uint64_t v14 = 0x4000000000LL;
    }
    uint64_t v12 = (unint64_t *)(a1 + 14);
    do
    {
      if (_os_atomic_mo_has_acquire(3)) {
        unint64_t v4 = __ldaxr(v12);
      }
      else {
        unint64_t v4 = __ldxr(v12);
      }
      unint64_t v16 = v4;
      unint64_t v15 = (v4 - a4) & 0xFFFFFF7700000001LL | 0x8000000000LL;
      if (v15 < 0x20000000000000LL && ((v4 - a4) & 0x4000000001LL) == 0) {
        v15 |= v14;
      }
      if (_os_atomic_mo_has_release(3)) {
        BOOL v13 = __stlxr(v15, v12) == 0;
      }
      else {
        BOOL v13 = __stxr(v15, v12) == 0;
      }
    }

    while (!v13);
    uint64_t v17 = v16 - a4;
    BOOL v11 = 0;
    if ((v17 & 0x1000000000LL) != 0) {
      BOOL v11 = (v17 & 0x800000000LL) != 0;
    }
    if (v11)
    {
      unsigned int v24 = _dispatch_thread_getspecific(0x19uLL);
      if ((BYTE4(v15) & 7u) > (v24 & 0xF0000) >> 16) {
        _dispatch_thread_setspecific(25LL, v24 & 0xFFF0FFFF | ((BYTE4(v15) & 7) << 16));
      }
    }

    if (((v17 ^ v15) & v14) != 0)
    {
      if ((v15 & 0x4000000001LL) == 0) {
        _dispatch_abort(3979LL, (v15 & 0x4000000001LL) != 0, v5, v6, v7, v8, v9, v10);
      }
      if ((v15 & 0x2000000000LL) != 0) {
        _dispatch_event_loop_poke(a1, v15, 1LL, v6, v7, v8, v9, v10);
      }
      else {
        ((void (*)(uint64_t (***)(), unsigned int *, unint64_t, uint64_t, uint64_t, uint64_t))(*a3)[9])( a3,  a1,  (v15 & 0x700000000LL) >> 32,  v6,  v7,  v8);
      }
    }

    else
    {
      _dispatch_release_2_tailcall(a1);
    }
  }

void _dispatch_workloop_drain_barrier_waiter(uint64_t a1, uint64_t a2, int a3, unsigned int a4, uint64_t a5)
{
  uint64_t v29 = *(_DWORD *)(a2 + 100) & 0xFFFFFFFC;
  uint64_t v24 = *(void *)(a2 + 16);
  *(void *)(a1 + 104 + 8LL * (a3 - 1)) = v24;
  if (!v24)
  {
    unint64_t v22 = (unint64_t *)(a1 + 152 + 8LL * (a3 - 1));
    while (1)
    {
      unint64_t v5 = _os_atomic_mo_has_acquire(3) ? __ldaxr(v22) : __ldxr(v22);
      if (a2 != (v5 & 0xFFFFFFFFFFFFFFF8LL)) {
        break;
      }
      if (!_os_atomic_mo_has_release(3)) {
        BOOL v23 = __stxr(0LL, v22) == 0;
      }
      else {
        BOOL v23 = __stlxr(0LL, v22) == 0;
      }
      if (v23) {
        goto LABEL_15;
      }
    }

    __clrex();
    uint64_t v21 = *(void *)(a2 + 16);
    if (!v21) {
      uint64_t v21 = _dispatch_wait_for_enqueuer((unint64_t *)(a2 + 16), a1 + 152 + 8LL * (a3 - 1));
    }
    uint64_t v24 = v21;
    *(void *)(a1 + 104 + 8LL * (a3 - 1)) = v21;
  }

LABEL_15:
  BOOL v26 = v24 != 0;
LABEL_16:
  if (!v26)
  {
    for (int i = 6; i; --i)
    {
      if (*(void *)(a1 + 152 + 8LL * (i - 1)))
      {
        char v37 = 1;
        goto LABEL_23;
      }
    }

    char v37 = 0;
LABEL_23:
    BOOL v26 = v37;
  }

  uint64_t v19 = (unint64_t *)(a1 + 56);
  do
  {
    if (_os_atomic_mo_has_acquire(3)) {
      unint64_t v7 = __ldaxr(v19);
    }
    else {
      unint64_t v7 = __ldxr(v19);
    }
    unint64_t v28 = v7;
    if ((v7 & 0x2000000000LL) != 0 && (v7 & 2) != 0 && (v7 & 0x800000001LL) != 0)
    {
      _dispatch_event_loop_ensure_ownership(a1);
      uint64_t v17 = (unint64_t *)(a1 + 56);
      unint64_t v18 = *(void *)(a1 + 56);
      do
      {
        unint64_t v8 = v18;
        do
          unint64_t v9 = __ldaxr(v17);
        while (v9 == v18 && __stlxr(v18 & 0xFFFFFFF7FFFFFFFDLL, v17));
        unint64_t v18 = v9;
      }

      while (v9 != v8);
      __clrex();
      goto LABEL_16;
    }

    unint64_t v27 = v7 & 0xFFFFFF7700000001LL | v29;
    if ((v7 & 0x2000000000LL) != 0)
    {
      if (!v26)
      {
        if ((v7 & 0x8000000000LL) != 0)
        {
          __clrex();
          unint64_t v15 = (unint64_t *)(a1 + 56);
          unint64_t v16 = *(void *)(a1 + 56);
          do
          {
            unint64_t v10 = v16;
            do
              unint64_t v11 = __ldaxr(v15);
            while (v11 == v16 && __stlxr(v16 ^ 0x8000000000LL, v15));
            unint64_t v16 = v11;
          }

          while (v11 != v10);
          goto LABEL_16;
        }

        unint64_t v27 = v7 & 0xFFFFFF7000000000LL | v29 & 0xFFFFFFF8FFFFFFFELL;
      }
    }

    else
    {
      v27 -= a5;
    }

    if (_os_atomic_mo_has_release(3)) {
      BOOL v20 = __stlxr(v27, v19) == 0;
    }
    else {
      BOOL v20 = __stxr(v27, v19) == 0;
    }
  }

  while (!v20);
  _dispatch_barrier_waiter_redirect_or_wake(a1, a2, a4, v28, v27, v12, v13, v14);
}

void _dispatch_lane_drain_barrier_waiter(uint64_t a1, uint64_t a2, unsigned int a3, uint64_t a4)
{
  uint64_t v21 = *(_DWORD *)(a2 + 100) & 0xFFFFFFFC;
  uint64_t v30 = *(void *)(a2 + 16);
  *(void *)(a1 + 104) = v30;
  if (!v30)
  {
    unint64_t v28 = (unint64_t *)(a1 + 48);
    while (1)
    {
      unint64_t v4 = _os_atomic_mo_has_acquire(3) ? __ldaxr(v28) : __ldxr(v28);
      if (a2 != (v4 & 0xFFFFFFFFFFFFFFF8LL)) {
        break;
      }
      if (_os_atomic_mo_has_release(3)) {
        BOOL v29 = __stlxr(0LL, v28) == 0;
      }
      else {
        BOOL v29 = __stxr(0LL, v28) == 0;
      }
      if (v29) {
        goto LABEL_14;
      }
    }

    __clrex();
    uint64_t v27 = *(void *)(a2 + 16);
    if (!v27) {
      uint64_t v27 = _dispatch_wait_for_enqueuer((unint64_t *)(a2 + 16), a1 + 48);
    }
    uint64_t v30 = v27;
    *(void *)(a1 + 104) = v27;
  }

LABEL_14:
  uint64_t v22 = v30;
LABEL_15:
  uint64_t v17 = (unint64_t *)(a1 + 56);
  do
  {
    if (_os_atomic_mo_has_acquire(3)) {
      unint64_t v5 = __ldaxr(v17);
    }
    else {
      unint64_t v5 = __ldxr(v17);
    }
    unint64_t v20 = v5;
    if ((v5 & 0x2000000000LL) != 0 && (v5 & 2) != 0 && (v5 & 0x800000001LL) != 0)
    {
      _dispatch_event_loop_ensure_ownership(a1);
      unint64_t v15 = (unint64_t *)(a1 + 56);
      unint64_t v16 = *(void *)(a1 + 56);
      do
      {
        unint64_t v6 = v16;
        do
          unint64_t v7 = __ldaxr(v15);
        while (v7 == v16 && __stlxr(v16 & 0xFFFFFFF7FFFFFFFDLL, v15));
        unint64_t v16 = v7;
      }

      while (v7 != v6);
      __clrex();
      goto LABEL_15;
    }

    unint64_t v19 = v5 & 0xFFFFFF7700000001LL | v21;
    if ((v5 & 0x2000000000LL) != 0)
    {
      if (!v22)
      {
        if ((v5 & 0x8000000000LL) != 0)
        {
          __clrex();
          uint64_t v13 = (unint64_t *)(a1 + 56);
          unint64_t v14 = *(void *)(a1 + 56);
          do
          {
            unint64_t v8 = v14;
            do
              unint64_t v9 = __ldaxr(v13);
            while (v9 == v14 && __stlxr(v14 ^ 0x8000000000LL, v13));
            unint64_t v14 = v9;
          }

          while (v9 != v8);
          uint64_t v22 = *(void *)(a1 + 104);
          goto LABEL_15;
        }

        unint64_t v19 = v5 & 0xFFFFFF7000000000LL | v21 & 0xFFFFFFF8FFFFFFFELL;
      }
    }

    else
    {
      v19 -= a4;
    }

    if (_os_atomic_mo_has_release(3)) {
      BOOL v18 = __stlxr(v19, v17) == 0;
    }
    else {
      BOOL v18 = __stxr(v19, v17) == 0;
    }
  }

  while (!v18);
  _dispatch_barrier_waiter_redirect_or_wake(a1, a2, a3, v20, v19, v10, v11, v12);
}

void _dispatch_lane_activate(uint64_t a1)
{
  unint64_t v9 = *(void *)(a1 + 24);
  int v8 = *(_DWORD *)(a1 + 84);
  if ((unsigned __int16)(v8 & 0xF000) >> 12 <= ((unsigned __int16)(v8 & 0xF00) >> 8)
    || (unsigned __int16)(v8 & 0xF00) >> 8 && (v8 & 0x40000000) == 0)
  {
    *(_DWORD *)(a1 + 84) = v8 & 0xFBFF0FFF;
  }

  uint64_t v1 = _dispatch_queue_priority_inherit_from_target(a1, v9);
  _dispatch_lane_inherit_wlh_from_target(a1, v1, v2, v3, v4, v5, v6, v7);
}

uint64_t (***_dispatch_queue_priority_inherit_from_target(uint64_t a1, unint64_t a2))()
{
  unint64_t v9 = a2;
  unsigned int v8 = *(_DWORD *)(a1 + 84);
  BOOL v6 = 0;
  if ((v8 & 0x20000000) == 0) {
    BOOL v6 = (v8 & 0x44000FFF) != 0;
  }
  if (v6)
  {
    BOOL v5 = 0;
    if (v5)
    {
      unsigned int v7 = (*(_DWORD *)(a1 + 84) & 0xF00u) >> 8;
      if (!v7) {
        unsigned int v7 = 4;
      }
      int v12 = 2 * (v8 >> 31);
      BOOL v4 = 1;
      if (v7) {
        BOOL v4 = v7 > 6;
      }
      if (v4)
      {
        qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Corrupted priority";
        qword_E4DA8 = v7;
        __break(1u);
        JUMPOUT(0x2A660LL);
      }

      int v11 = 0;
      if ((v12 & 2) != 0)
      {
        int v11 = 1;
      }

      else if ((v12 & 4) != 0)
      {
        int v11 = 2;
      }

      return &(&_dispatch_root_queues)[16 * (unint64_t)(3 * v7 + v11 - 3)];
    }

    return (uint64_t (***)())v9;
  }

  else
  {
    BOOL v3 = 0;
    if (v3)
    {
      unsigned int v8 = *(_DWORD *)(a2 + 84) | 0x20000000;
    }

    else if ((v8 & 0x20000000) != 0)
    {
      v8 &= 0xFBFF0FFF;
    }

    *(_DWORD *)(a1 + 84) = v8;
    return (uint64_t (***)())a2;
  }

void _dispatch_lane_inherit_wlh_from_target( uint64_t a1, _DWORD *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if ((*(void *)(*(void *)a2 + 16LL) & 0x10000LL) != 0)
  {
    else {
      uint64_t v24 = 0x1000000000LL;
    }
  }

  else
  {
    uint64_t v24 = 0LL;
  }

  uint64_t v22 = (unint64_t *)(a1 + 56);
  while (1)
  {
    unint64_t v8 = _os_atomic_mo_has_acquire(0) ? __ldaxr(v22) : __ldxr(v22);
    unint64_t v26 = v8;
    unint64_t v25 = v8 & 0xFFFFFFCFFFFFFFFFLL | v24;
    if (v26 == (v26 & 0xFFFFFFCFFFFFFFFFLL | v24)) {
      break;
    }
    if (_os_atomic_mo_has_release(0)) {
      BOOL v23 = __stlxr(v25, v22) == 0;
    }
    else {
      BOOL v23 = __stxr(v25, v22) == 0;
    }
    if (v23) {
      goto LABEL_16;
    }
  }

  __clrex();
LABEL_16:
  if ((v26 & 0x2000000000LL) != 0 && (v25 & 0x2000000000LL) == 0)
  {
    uint64_t v21 = _dispatch_thread_getspecific(0x1DuLL);
    if (v21)
    {
      if (v21[3] == a1) {
        _dispatch_event_loop_leave_immediate(v25);
      }
    }
  }

  if ((*(void *)(*(void *)a2 + 16LL) & 0x10000LL) == 0)
  {
    int v20 = 0;
    int v19 = 0;
    if (*(_BYTE *)(*(void *)a2 + 16LL) == 18LL)
    {
      int v20 = 0x400000;
      BOOL v18 = 0;
      if (!v18)
      {
        int v19 = 0x1000000;
      }
    }

    else
    {
      int v19 = a2[20] & 0x1000000;
      if (v19) {
        int v19 = a2[20] & 0x1040000;
      }
    }

    if (v20)
    {
      BOOL v29 = a2 + 20;
      while (1)
      {
        unsigned int v9 = _os_atomic_mo_has_acquire(0) ? __ldaxr(v29) : __ldxr(v29);
        unsigned int v31 = (v9 | 0x100000) & ~v20;
        if (v31 == v9) {
          break;
        }
        if (_os_atomic_mo_has_release(0)) {
          BOOL v30 = __stlxr(v31, v29) == 0;
        }
        else {
          BOOL v30 = __stxr(v31, v29) == 0;
        }
        if (v30) {
          goto LABEL_48;
        }
      }

      __clrex();
    }

    else
    {
      unint64_t v16 = a2 + 20;
      unsigned int v17 = a2[20];
      do
      {
        unsigned int v10 = v17;
        do
          unsigned int v11 = __ldaxr(v16);
        while (v11 == v17 && __stlxr(v17 | 0x100000, v16));
        unsigned int v17 = v11;
      }

      while (v11 != v10);
    }

LABEL_48:
    if (v19)
    {
      unint64_t v14 = (unsigned int *)(a1 + 80);
      unsigned int v15 = *(_DWORD *)(a1 + 80);
      do
      {
        unsigned int v12 = v15;
        do
          unsigned int v13 = __ldaxr(v14);
        while (v13 == v15 && __stlxr(v15 | v19, v14));
        unsigned int v15 = v13;
      }

      while (v13 != v12);
    }
  }

void _dispatch_lane_invoke(unsigned int *a1, uint64_t a2, int a3)
{
  int v60 = a1;
  uint64_t v59 = a2;
  unsigned int v58 = a3;
  int v57 = 0;
  uint64_t v56 = _dispatch_lane_invoke2;
  unint64_t v55 = a1;
  v54[8] = 0;
  *(void *)__int128 v54 = (a3 & 1) == 0;
  uint64_t v53 = 0LL;
  if ((a3 & 3) == 0)
  {
    *((void *)v55 + 2) = -1985229329LL;
    uint64_t v52 = _dispatch_thread_getspecific(0x14uLL);
    BOOL v51 = v55;
    uint64_t v82 = v52;
    unint64_t v81 = v55;
    int v80 = 0;
    int v79 = 0;
    uint64_t v176 = v52;
    uint64_t v175 = v55;
  }

  v58 |= v57;
  if ((v58 & 2) != 0)
  {
    uint64_t v53 = 0x40020000000001LL;
    goto LABEL_54;
  }

  uint64_t v108 = v55;
  int v107 = v58;
  uint64_t v106 = 0LL;
  uint64_t v106 = (uint64_t)(*((unsigned __int16 *)v55 + 40) - 1) << 41;
  unsigned int v121 = _dispatch_thread_getspecific(3uLL);
  uint64_t v105 = v121 & 0xFFFFFFFC | 0x20000000000000LL;
  unint64_t v103 = 0LL;
  unint64_t v102 = 0LL;
  uint64_t v101 = 0LL;
  unint64_t v104 = 0xFFE00000FFFFFFFCLL;
  if ((v58 & 1) != 0)
  {
    v104 |= 0x4000000000uLL;
    uint64_t v101 = 0LL;
  }

  else if ((v107 & 0x40000) != 0)
  {
    uint64_t v101 = 0x4000000000LL;
  }

  else
  {
    v104 |= 0x4000000000uLL;
    uint64_t v101 = 1LL;
  }

  BOOL v114 = (v107 & 2) == 0;
  uint64_t v113 = 1323LL;
  if ((v107 & 2) != 0) {
    _dispatch_abort(v113, v114, v3, v4, v5, v6, v7, v8);
  }
  unsigned int v100 = 0;
  unsigned int v118 = _dispatch_thread_getspecific(0x19uLL);
  unsigned int v120 = v118 & 0xF00;
  unsigned int v117 = v120 >> 8;
  unsigned int v119 = v118 & 0xF000;
  unsigned int v116 = v119 >> 12;
  int v122 = v118 & 0xF0000;
  unsigned int v115 = (v118 & 0xF0000) >> 16;
  if (v120 >> 8 <= v119 >> 12) {
    unsigned int v46 = v116;
  }
  else {
    unsigned int v46 = v117;
  }
  if (v46 <= v115)
  {
    unsigned int v44 = v115;
  }

  else
  {
    if (v117 <= v116) {
      unsigned int v45 = v116;
    }
    else {
      unsigned int v45 = v117;
    }
    unsigned int v44 = v45;
  }

  unsigned int v100 = v44;
LABEL_22:
  BOOL v99 = 0;
  uint64_t v98 = (unint64_t *)(v108 + 14);
  while (1)
  {
    unint64_t v15 = _os_atomic_mo_has_acquire(2) ? __ldaxr(v98) : __ldxr(v98);
    unint64_t v103 = v15;
    unint64_t v102 = v15;
    if ((v15 & v104) != 0) {
      break;
    }
    unint64_t v153 = v103;
    unsigned int v152 = v100;
    unint64_t v155 = v103;
    BOOL v43 = 0;
    if ((v103 & 0x1000000000LL) != 0)
    {
      uint64_t v154 = v153 & 0x700000000LL;
      BOOL v43 = v152 < (v153 & 0x700000000LL) >> 32;
    }

    if (v43)
    {
      __clrex();
      unint64_t v157 = v103;
      uint64_t v158 = v103 & 0x700000000LL;
      unsigned int v156 = (v103 & 0x700000000LL) >> 32;
      unsigned int v162 = _dispatch_thread_getspecific(3uLL);
      unsigned int v161 = v156;
      if ((_dispatch_set_qos_class_enabled & 1) != 0)
      {
        unsigned int v164 = v161;
        uint64_t v163 = 0LL;
        if (v161) {
          uint64_t v163 = 1LL << (v164 + 7);
        }
        _pthread_workqueue_override_start_direct(v162, v163 | 0xFF);
      }

      unsigned int v160 = v156;
      unsigned int v159 = _dispatch_thread_getspecific(0x19uLL);
      int v165 = v159 & 0xF0000;
      if (v156 > (v159 & 0xF0000) >> 16)
      {
        unsigned int v159 = v159 & 0xFFF0FFFF | (v160 << 16);
        _dispatch_thread_setspecific(25LL, v159);
      }

      unsigned int v100 = v156;
      goto LABEL_22;
    }

    unint64_t v102 = v102 & 0x7700000001LL | v105;
    unint64_t v110 = v103;
    if ((v103 & 0x10000000000LL) != 0 || v103 + v106 < 0x20000000000000LL) {
      v102 |= 0x40000000000000uLL;
    }
LABEL_44:
    if (_os_atomic_mo_has_release(2)) {
      BOOL v99 = __stlxr(v102, v98) == 0;
    }
    else {
      BOOL v99 = __stxr(v102, v98) == 0;
    }
    if (v99) {
      goto LABEL_48;
    }
  }

  if (v101)
  {
    v102 ^= v101;
    goto LABEL_44;
  }

  __clrex();
LABEL_48:
  BOOL v97 = v99;
  BOOL v112 = (v103 & v101) == v101;
  uint64_t v111 = 1356LL;
  if ((v103 & v101) != v101) {
    _dispatch_abort(v111, v112, v9, v10, v11, v12, v13, v14);
  }
  if ((v103 & v104) != 0)
  {
    uint64_t v109 = 0LL;
  }

  else
  {
    v102 &= v101 | 0x60000000000000LL;
    v103 &= 0x3FFE0000000000uLL;
    uint64_t v109 = v102 - v103;
  }

  uint64_t v53 = v109;
LABEL_54:
  if (v53)
  {
    unsigned int v50 = 0;
    if ((v58 & 0x40000) != 0)
    {
      unsigned int v50 = 0;
    }

    else
    {
      unsigned int v86 = v55[21];
      unsigned int v85 = _dispatch_thread_getspecific(0x19uLL);
      unsigned int v84 = v85;
      if (v85)
      {
        if ((v86 & 0xFFF) != 0)
        {
          v84 &= 0x880F0000;
          if ((v85 & 0xFFF) <= (v86 & 0xFFF)) {
            int v42 = v86 & 0xFFF;
          }
          else {
            int v42 = v85 & 0xFFF;
          }
          v84 |= v42;
          unsigned int v88 = v86 & 0xF000;
          unsigned int v90 = v84 & 0xF00;
          if (v88 >> 12 <= v90 >> 8) {
            v86 &= 0x40000000u;
          }
          else {
            v86 &= 0x4400F000u;
          }
          v84 |= v86;
        }

        else
        {
          if ((v84 & 0xFFF) != 0) {
            v84 |= 0x40000000u;
          }
          unsigned int v87 = v86 & 0xF000;
          unsigned int v89 = v84 & 0xF00;
          if (v87 >> 12 > v89 >> 8) {
            unsigned int v84 = v84 & 0xFFFF0FFF | v86 & 0x400F000;
          }
        }
      }

      else
      {
        unsigned int v84 = v86 & 0xFFF0FFFF;
      }

      _dispatch_thread_setspecific(25LL, v84);
      unsigned int v50 = v85;
    }

    if ((v58 & 0x100000) != 0)
    {
      uint64_t v64 = v60;
      unsigned int v63 = 0;
      unsigned int v62 = v60[20];
      unsigned int v63 = v62;
      unsigned int v61 = v62;
      if ((v62 & 0x400000) != 0)
      {
        uint64_t v76 = v60;
        int v75 = 0x400000;
        int v73 = -4194305;
        int v72 = -4194305;
        int v74 = -4194305;
        unsigned int v70 = 0;
        __int128 v40 = v60 + 20;
        int v68 = -4194305;
        int v67 = -4194305;
        int v69 = -4194305;
        unsigned int v41 = v60[20];
        do
        {
          unsigned int v16 = v41;
          do
            unsigned int v17 = __ldaxr(v40);
          while (v17 == v41 && __stlxr(v41 & 0xFFBFFFFF, v40));
          unsigned int v41 = v17;
        }

        while (v17 != v16);
        unsigned int v66 = v17;
        unsigned int v70 = v17;
        unsigned int v65 = v17;
        int v71 = v17 & v74;
      }
    }

    uint64_t v49 = v55;
    uint64_t v125 = v55;
    unsigned int v124 = v58;
    int v123 = 0;
    unint64_t v168 = v55;
    uint64_t v167 = 256LL;
    uint64_t v174 = 1LL;
    uint64_t v173 = 730LL;
    int v166 = 0;
    unint64_t v172 = v55;
    unsigned int v171 = 0;
    unsigned int v170 = v55[20];
    unsigned int v171 = v170;
    unsigned int v169 = v170;
    int v166 = v170 & 0x30000;
    int v123 = (v170 & 0x30000) << 8;
    if (v123) {
      unsigned int v124 = v124 & 0xFCFFFFFF | v123;
    }
    unsigned int v58 = v124;
    do
    {
      if ((v58 & 2) != 0 && (v58 & 0x1000000) == 0) {
        _dispatch_last_resort_autorelease_pool_push(v59);
      }
      uint64_t v48 = v55;
      *(void *)&v54[1] = v56((uint64_t)v55, v59, v58, &v53);
      if ((v58 & 2) != 0 && (v58 & 0x1000000) == 0)
      {
        __int128 v47 = 0uLL;
        uint64_t v92 = v55;
        BOOL v91 = &v47;
        uint64_t v96 = &v47;
        _dispatch_thread_getspecific_packed_pair(20LL, 21LL, &v47, v19, v20, v21, v22, v23);
        _dispatch_thread_setspecific_pair(20LL, (uint64_t)v92, 21LL, (uint64_t)v91, v24, v25, v26, v27);
        _dispatch_last_resort_autorelease_pool_pop(v59);
        uint64_t v93 = &v47;
        _dispatch_thread_setspecific_packed_pair(20LL, 21LL, &v47, v28, v29, v30, v31, v32);
      }

      BOOL v78 = *(void *)&v54[1] != 1LL;
      uint64_t v77 = 2018LL;
      if (*(void *)&v54[1] == 1LL) {
        _dispatch_abort(v77, v78, v18, v19, v20, v21, v22, v23);
      }
      BOOL v39 = 0;
      if (*(void *)&v54[1]) {
        BOOL v39 = *(void *)&v54[1] != -1LL;
      }
      if (v39) {
        break;
      }
      unsigned int v143 = v55;
      uint64_t v142 = v53;
      BOOL v141 = *(void *)&v54[1] == 0LL;
      unint64_t v140 = 0LL;
      unint64_t v139 = 0LL;
      int v138 = 0;
      uint64_t v137 = (unint64_t *)(v55 + 14);
      do
      {
        if (_os_atomic_mo_has_acquire(3)) {
          unint64_t v33 = __ldaxr(v137);
        }
        else {
          unint64_t v33 = __ldxr(v137);
        }
        unint64_t v140 = v33;
        unint64_t v139 = (v33 - v142) & 0xFFFFFFF700000001LL;
        unint64_t v145 = v33;
        if ((v33 & 0xFF80000000000000LL) == 0)
        {
          unint64_t v146 = v140;
          if ((v140 & 0x8000000000LL) != 0)
          {
            __clrex();
            uint64_t v135 = 0x8000000000LL;
            uint64_t v134 = 0x8000000000LL;
            uint64_t v136 = 0x8000000000LL;
            unint64_t v132 = 0LL;
            char v37 = (unint64_t *)(v143 + 14);
            uint64_t v130 = 0x8000000000LL;
            uint64_t v129 = 0x8000000000LL;
            uint64_t v131 = 0x8000000000LL;
            unint64_t v38 = *((void *)v143 + 7);
            do
            {
              unint64_t v34 = v38;
              do
                unint64_t v35 = __ldaxr(v37);
              while (v35 == v38 && __stlxr(v38 ^ 0x8000000000LL, v37));
              unint64_t v38 = v35;
            }

            while (v35 != v34);
            unint64_t v128 = v35;
            unint64_t v132 = v35;
            unint64_t v127 = v35;
            unint64_t v133 = v35 ^ v136;
            char v144 = 0;
            goto LABEL_119;
          }

          if (v141) {
            v139 &= 0xFFFFFFF8FFFFFFFFLL;
          }
          else {
            v139 |= 0x8000000000uLL;
          }
        }

        if (_os_atomic_mo_has_release(3))
        {
          LOBYTE(v138) = __stlxr(v139, v137) == 0;
          int v138 = v138;
        }

        else
        {
          LOBYTE(v138) = __stxr(v139, v137) == 0;
          int v138 = v138;
        }
      }

      while (!v138);
      int v126 = v138;
      unint64_t v148 = v140;
      unint64_t v150 = v140;
      BOOL v36 = 0;
      if ((v140 & 0x1000000000LL) != 0) {
        BOOL v36 = (v148 & 0x800000000LL) != 0;
      }
      if (v36)
      {
        uint64_t v147 = v140 & 0x700000000LL;
        uint64_t v149 = v140 & 0x700000000LL;
        LODWORD(v149) = _dispatch_thread_getspecific(0x19uLL);
        int v151 = v149 & 0xF0000;
        if (HIDWORD(v149) > (v149 & 0xF0000) >> 16)
        {
          LODWORD(v149) = v149 & 0xFFF0FFFF;
          LODWORD(v149) = v149 | (HIDWORD(v149) << 16);
          _dispatch_thread_setspecific(25LL, v149);
        }
      }

      char v144 = 1;
LABEL_119:
      if ((v144 & 1) != 0)
      {
        uint64_t v53 = 0LL;
        *(void *)&v54[1] = 0LL;
        break;
      }

      *(void *)&v54[1] = _dispatch_thread_getspecific(0x14uLL);
    }

    while ((*(void *)(**(void **)&v54[1] + 16LL) & 0x10000LL) != 0 || (v54[0] & 1) == 0);
    if ((v58 & 0x40000) == 0)
    {
      unsigned int v95 = v50;
      unsigned int v94 = 0;
      unsigned int v94 = _dispatch_thread_getspecific(0x19uLL);
      v95 &= 0xFFF0FFFF;
      v95 |= v94 & 0xF0000;
      _dispatch_thread_setspecific(25LL, v95);
    }
  }

  if ((v54[0] & 1) != 0)
  {
    uint64_t v83 = v55;
    unint64_t v177 = v55;
    unsigned int v182 = 772079660;
    uint64_t v181 = v55;
    uint64_t v180 = 0LL;
    uint64_t v179 = 0LL;
    uint64_t v178 = 0LL;
    if (MEMORY[0xFFFFFC100]) {
      kdebug_trace(v182, v181, v180, v179, v178);
    }
    v183 = v83;
  }

  if (*(void *)&v54[1]) {
    _dispatch_queue_invoke_finish(v55, v59, *(uint64_t (****)())&v54[1], v53);
  }
  else {
    _dispatch_release_2_tailcall(v55);
  }
}

uint64_t _dispatch_lane_invoke2(uint64_t a1, uint64_t a2, int a3, void *a4)
{
  uint64_t v9 = *(void **)(a1 + 24);
  if (_dispatch_thread_getspecific(0x14uLL) != v9) {
    return (uint64_t)v9;
  }
  if (*(_WORD *)(a1 + 80) == 1) {
    return _dispatch_lane_serial_drain(a1, a2, a3, a4, v4, v5, v6, v7);
  }
  return _dispatch_lane_concurrent_drain(a1, a2, a3, a4, v4, v5, v6, v7);
}

uint64_t dispatch_workloop_copy_current()
{
  uint64_t v2 = _dispatch_thread_getspecific(0x1BuLL);
  if (v2 && v2 != (void *)-4LL)
  {
    if (*(_BYTE *)(*(void *)v2 + 16LL) == 18LL) {
      uint64_t v3 = (uint64_t)v2;
    }
    else {
      uint64_t v3 = 0LL;
    }
  }

  else
  {
    uint64_t v3 = 0LL;
  }

  if (!v3) {
    return 0LL;
  }
  _os_object_retain_with_resurrect(v3);
  return v3;
}

BOOL dispatch_workloop_is_current(void *a1)
{
  return _dispatch_thread_getspecific(0x1BuLL) == a1;
}

BOOL _dispatch_workloop_uses_bound_thread(uint64_t a1)
{
  uint64_t v2 = *(_DWORD **)(a1 + 200);
  return v2 && (*v2 & 0x40) != 0;
}

BOOL _dispatch_workloop_should_yield_4NW()
{
  uint64_t v2 = (unsigned int *)_dispatch_thread_getspecific(0x1BuLL);
  if (v2 && v2 != (unsigned int *)-4LL)
  {
    if (*(_BYTE *)(*(void *)v2 + 16LL) == 18LL) {
      uint64_t v3 = v2;
    }
    else {
      uint64_t v3 = 0LL;
    }
  }

  else
  {
    uint64_t v3 = 0LL;
  }

  return v3 && (((unint64_t)v3[15] << 32) & 0x700000000LL) >> 32 > *((unsigned __int8 *)v3 + 100);
}

dispatch_workloop_t dispatch_workloop_create(const char *label)
{
  return (dispatch_workloop_t)_dispatch_workloop_create(label, 0LL, v1, v2, v3, v4, v5, v6);
}

void *_dispatch_workloop_create( const char *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v24 = a1;
  int v21 = 0x10000;
  if (a1)
  {
    uint64_t v20 = _dispatch_strdup_if_mutable(a1);
    if (v20 != v24)
    {
      int v21 = 2162688;
      uint64_t v24 = v20;
    }
  }

  if ((_dispatch_kevent_workqueue_enabled & 1) != 0) {
    uint64_t v25 = 0x2000000000LL;
  }
  else {
    uint64_t v25 = 0x1000000000LL;
  }
  uint64_t v23 = a2 | v25;
  uint64_t v19 = _dispatch_object_alloc((uint64_t)_OS_dispatch_workloop_vtable, 0xD0uLL, a3, a4, a5, a6, a7, a8);
  _dispatch_queue_init((uint64_t)v19, v21, 1LL, v23, v8, v9, v10, v11);
  v19[9] = v24;
  v19[3] = &off_E46C0;
  if ((v23 & 0x180000000000000LL) == 0) {
    *((_DWORD *)v19 + 21) = -2080358400;
  }
  _dispatch_object_debug((uint64_t)v19, "%s", v12, v13, v14, v15, v16, v17, (char)"_dispatch_workloop_create");
  return v19;
}

dispatch_workloop_t dispatch_workloop_create_inactive(const char *label)
{
  return (dispatch_workloop_t)_dispatch_workloop_create(label, 0x180000000000000LL, v1, v2, v3, v4, v5, v6);
}

void dispatch_workloop_set_autorelease_frequency( dispatch_workloop_t workloop, dispatch_autorelease_frequency_t frequency)
{
  if (frequency == DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM)
  {
    uint64_t v9 = (unsigned int *)((char *)workloop + 80);
    while (1)
    {
      unsigned int v2 = _os_atomic_mo_has_acquire(0) ? __ldaxr(v9) : __ldxr(v9);
      unsigned int v11 = v2 & 0xFFFCFFFF | 0x10000;
      if (v11 == v2) {
        break;
      }
      if (_os_atomic_mo_has_release(0)) {
        BOOL v10 = __stlxr(v11, v9) == 0;
      }
      else {
        BOOL v10 = __stxr(v11, v9) == 0;
      }
      if (v10) {
        goto LABEL_22;
      }
    }
  }

  else
  {
    uint64_t v6 = (unsigned int *)((char *)workloop + 80);
    while (1)
    {
      unsigned int v3 = _os_atomic_mo_has_acquire(0) ? __ldaxr(v6) : __ldxr(v6);
      unsigned int v8 = v3 & 0xFFFCFFFF | 0x20000;
      if (v8 == v3) {
        break;
      }
      if (_os_atomic_mo_has_release(0)) {
        BOOL v7 = __stlxr(v8, v6) == 0;
      }
      else {
        BOOL v7 = __stxr(v8, v6) == 0;
      }
      if (v7) {
        goto LABEL_22;
      }
    }
  }

  __clrex();
LABEL_22:
  uint64_t v5 = *((void *)workloop + 7);
  if ((~v5 & 0x180000000000000LL) != 0)
  {
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: dispatch queue/source property setter called after activation";
    qword_E4DA8 = v5;
    __break(1u);
    JUMPOUT(0x2CC50LL);
  }

uint64_t dispatch_workloop_set_scheduler_priority(uint64_t result, int a2, char a3)
{
  uint64_t v5 = result;
  uint64_t v6 = *(void *)(result + 56);
  if ((~v6 & 0x180000000000000LL) != 0)
  {
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: dispatch queue/source property setter called after activation";
    qword_E4DA8 = v6;
    __break(1u);
    JUMPOUT(0x2CD10LL);
  }

  if (!*(void *)(result + 200))
  {
    uint64_t result = _dispatch_calloc(1LL, 56LL);
    *(void *)(v5 + 200) = result;
  }

  if (a2)
  {
    *(_DWORD *)(*(void *)(v5 + 200) + 8LL) = a2;
    **(_DWORD **)(v5 + 200) |= 1u;
  }

  else
  {
    *(_DWORD *)(*(void *)(v5 + 200) + 8LL) = 0;
    **(_DWORD **)(v5 + 200) &= ~1u;
  }

  if ((a3 & 1) != 0)
  {
    *(_DWORD *)(*(void *)(v5 + 200) + 16LL) = 2;
    **(_DWORD **)(v5 + 200) |= 2u;
  }

  else
  {
    **(_DWORD **)(v5 + 200) &= ~2u;
  }

  return result;
}

uint64_t dispatch_workloop_set_uses_bound_thread(uint64_t a1)
{
  if (_dispatch_workloop_bound_thread_pred != -1) {
    dispatch_once_f( &_dispatch_workloop_bound_thread_pred,  0LL,  (dispatch_function_t)_dispatch_workloop_bound_thread_init_once);
  }
  if ((_dispatch_thread_bound_kqwl_enabled & 1) != 0)
  {
    uint64_t v4 = *(void *)(a1 + 56);
    if ((~v4 & 0x180000000000000LL) != 0)
    {
      qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: dispatch queue/source property setter called after activation";
      qword_E4DA8 = v4;
      __break(1u);
      JUMPOUT(0x2CF14LL);
    }

    if (!*(void *)(a1 + 200)) {
      *(void *)(a1 + 200) = _dispatch_calloc(1LL, 56LL);
    }
    **(_DWORD **)(a1 + 200) |= 0x40u;
    return 0;
  }

  else
  {
    return -1;
  }

void dispatch_workloop_set_os_workgroup(dispatch_workloop_t workloop, os_workgroup_t workgroup)
{
  uint64_t v5 = *((void *)workloop + 7);
  if ((~v5 & 0x180000000000000LL) != 0)
  {
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: dispatch queue/source property setter called after activation";
    qword_E4DA8 = v5;
    __break(1u);
    JUMPOUT(0x2D02CLL);
  }

  if (!*((void *)workloop + 25)) {
    *((void *)workloop + 25) = _dispatch_calloc(1LL, 56LL);
  }
  unsigned int v2 = *(unsigned int **)(*((void *)workloop + 25) + 32LL);
  if (v2) {
    _os_object_release(v2);
  }
  _os_object_retain((uint64_t)workgroup);
  *(void *)(*((void *)workloop + 25) + 32LL) = workgroup;
}

uint64_t dispatch_workloop_set_qos_class(uint64_t a1, int a2, char a3)
{
  return dispatch_workloop_set_qos_class_floor(a1, a2, 0, a3);
}

uint64_t dispatch_workloop_set_cpupercent(uint64_t result, char a2, int a3)
{
  uint64_t v5 = result;
  uint64_t v6 = *(void *)(result + 56);
  if ((~v6 & 0x180000000000000LL) != 0)
  {
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: dispatch queue/source property setter called after activation";
    qword_E4DA8 = v6;
    __break(1u);
    JUMPOUT(0x2D1A4LL);
  }

  if (!*(void *)(result + 200))
  {
    uint64_t result = _dispatch_calloc(1LL, 56LL);
    *(void *)(v5 + 200) = result;
  }

  if ((**(_BYTE **)(v5 + 200) & 9) == 0)
  {
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: workloop qos class or priority must be set before cpupercent";
    __break(1u);
    JUMPOUT(0x2D220LL);
  }

  *(_BYTE *)(*(void *)(v5 + 200) + 20LL) = a2;
  *(_DWORD *)(*(void *)(v5 + 200) + 24LL) = a3;
  **(_DWORD **)(v5 + 200) |= 4u;
  return result;
}

__n128 _dispatch_workloop_set_observer_hooks_4IOHID(uint64_t a1, __n128 *a2)
{
  uint64_t v5 = *(void *)(a1 + 56);
  if ((~v5 & 0x180000000000000LL) != 0)
  {
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: dispatch queue/source property setter called after activation";
    qword_E4DA8 = v5;
    __break(1u);
    JUMPOUT(0x2D314LL);
  }

  if (!*(void *)(a1 + 200)) {
    *(void *)(a1 + 200) = _dispatch_calloc(1LL, 56LL);
  }
  __n128 result = *a2;
  *(__n128 *)(*(void *)(a1 + 200) + 40LL) = *a2;
  **(_DWORD **)(a1 + 200) |= 0x20u;
  return result;
}

void _dispatch_workloop_dispose( uint64_t a1, _BYTE *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v24 = *(void *)(a1 + 56);
  if ((_dispatch_kevent_workqueue_enabled & 1) != 0) {
    uint64_t v27 = 0x2000000000LL;
  }
  else {
    uint64_t v27 = 0x1000000000LL;
  }
  if (v24 != (v27 | 0x1FFE0000000000LL))
  {
    if ((v24 & 0xFFFFFFFC) != 0)
    {
      qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Release of a locked workloop";
      qword_E4DA8 = v24;
      __break(1u);
      JUMPOUT(0x2D480LL);
    }

    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Release of a workloop with corrupt state";
    qword_E4DA8 = v24;
    __break(1u);
    JUMPOUT(0x2D4C4LL);
  }

  _dispatch_object_debug(a1, "%s", a3, a4, a5, a6, a7, a8, (char)"_dispatch_workloop_dispose");
  for (unint64_t i = 0LL; i < 6; ++i)
  {
    if (*(void *)(a1 + 8 * i + 152))
    {
      uint64_t v22 = *(void *)(a1 + 8 * i + 152);
      qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Release of a workloop while items are enqueued";
      qword_E4DA8 = v22;
      __break(1u);
      JUMPOUT(0x2D590LL);
    }

    *(void *)(a1 + 8 * i + 152) = 512LL;
    *(void *)(a1 + 8 * i + 104) = 512LL;
  }

  if (*(void *)(a1 + 48))
  {
    for (unint64_t j = 0LL; j <= 5; ++j)
    {
      if (*(_DWORD *)(*(void *)(a1 + 48) + 32 * j)) {
        _dispatch_abort(4557LL, *(_DWORD *)(*(void *)(a1 + 48) + 32 * j) == 0, v8, v9, v10, v11, v12, v13);
      }
    }

    free(*(void **)(a1 + 48));
    *(void *)(a1 + 48) = 0LL;
  }

  if (*(void *)(a1 + 200))
  {
    if ((**(_BYTE **)(a1 + 200) & 0x10) != 0)
    {
      int v20 = _pthread_workloop_destroy(a1);
      if (v20) {
        _dispatch_bug(4566LL, v20, v14, v15, v16, v17, v18, v19);
      }
    }
  }

  if (*(void *)(a1 + 200))
  {
    if (*(void *)(*(void *)(a1 + 200) + 32LL)) {
      _os_object_release(*(unsigned int **)(*(void *)(a1 + 200) + 32LL));
    }
    free(*(void **)(a1 + 200));
  }

  _dispatch_queue_dispose(a1, a2);
}

void _dispatch_workloop_activate(uint64_t a1)
{
  BOOL v7 = (unint64_t *)(a1 + 56);
  unint64_t v8 = *(void *)(a1 + 56);
  do
  {
    unint64_t v1 = v8;
    do
      unint64_t v2 = __ldaxr(v7);
    while (v2 == v8 && __stlxr(v8 & 0xFEFFFFFFFFFFFFFFLL, v7));
    unint64_t v8 = v2;
  }

  while (v2 != v1);
  if ((v2 & 0x180000000000000LL) == 0x180000000000000LL)
  {
    if (*(void *)(a1 + 200)) {
      _dispatch_workloop_activate_attributes(a1);
    }
    if (!*(_DWORD *)(a1 + 84)) {
      *(_DWORD *)(a1 + 84) = 67125248;
    }
    *(_DWORD *)(a1 + 84) |= 0x80000000;
    uint64_t v5 = (unint64_t *)(a1 + 56);
    unint64_t v6 = *(void *)(a1 + 56);
    do
    {
      unint64_t v3 = v6;
      do
        unint64_t v4 = __ldaxr(v5);
      while (v4 == v6 && __stlxr(v6 & 0xFF7FFFFFFFFFFFFFLL, v5));
      unint64_t v6 = v4;
    }

    while (v4 != v3);
    _dispatch_workloop_wakeup(a1, 0, 1u);
  }

uint64_t _dispatch_workloop_activate_attributes(uint64_t a1)
{
  uint64_t v14 = *(void *)(a1 + 200);
  memset(&v16, 0, sizeof(v16));
  uint64_t v13 = 0LL;
  pthread_attr_init(&v16);
  if ((*(_BYTE *)v14 & 8) != 0) {
    *(_DWORD *)(a1 + 84) |= *(_DWORD *)(v14 + 4) | 0x40000000;
  }
  if ((*(_BYTE *)v14 & 1) != 0)
  {
    pthread_attr_setschedparam(&v16, (const sched_param *)(v14 + 8));
    *(void *)(a1 + 24) = &_dispatch_custom_workloop_root_queue;
  }

  if (*(void *)(v14 + 32))
  {
    *(void *)(a1 + 24) = &_dispatch_custom_workloop_root_queue;
    unsigned int backing_workinterval = _os_workgroup_get_backing_workinterval(*(void *)(v14 + 32));
  }

  if ((*(_BYTE *)v14 & 0x40) != 0)
  {
    if (_dispatch_root_queues_pred != -1LL) {
      dispatch_once_f(&_dispatch_root_queues_pred, 0LL, (dispatch_function_t)_dispatch_root_queues_init_once);
    }
    uint64_t v13 = 1LL;
    *(void *)(a1 + 24) = &_dispatch_custom_workloop_overcommit_root_queue;
  }

  if ((*(_BYTE *)v14 & 2) != 0) {
    pthread_attr_setschedpolicy(&v16, *(_DWORD *)(v14 + 16));
  }
  if ((*(_BYTE *)v14 & 4) != 0) {
    pthread_attr_setcpupercent_np(&v16, *(unsigned __int8 *)(v14 + 20), *(unsigned int *)(v14 + 24));
  }
  BOOL v10 = 0;
  if (*(void *)(a1 + 200)) {
    BOOL v10 = (**(_BYTE **)(a1 + 200) & 0x47) != 0;
  }
  char v9 = 1;
  if (!v10)
  {
    BOOL v8 = 0;
    if (*(void *)(a1 + 200))
    {
      BOOL v8 = 0;
      if (*(void *)(*(void *)(a1 + 200) + 32LL)) {
        BOOL v8 = _os_workgroup_get_backing_workinterval(*(void *)(*(void *)(a1 + 200) + 32LL)) != 0;
      }
    }

    char v9 = v8;
  }

  if ((v9 & 1) != 0)
  {
    int v11 = _pthread_workloop_create(a1, v13, &v16);
    if (v11)
    {
      switch(v11)
      {
        case '!':
          if ((*(_DWORD *)v14 & 0x40) == 0) {
            _dispatch_abort(4509LL, 0LL, v1, v2, v3, v4, v5, v6);
          }
          qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Process has too many threads.";
          qword_E4DA8 = a1;
          __break(1u);
          JUMPOUT(0x2DD40LL);
        case '-':
          _dispatch_workloop_activate_tg_unsupported_fallback(a1);
          break;
        case 'N':
          _dispatch_workloop_activate_simulator_fallback(a1, (uint64_t)&v16, v1, v2, v3, v4, v5, v6);
          break;
        default:
          _dispatch_abort(4514LL, v11, v1, v2, v3, v4, v5, v6);
      }
    }

    else
    {
      *(_DWORD *)v14 |= 0x10u;
    }
  }

  return pthread_attr_destroy(&v16);
}

void _dispatch_workloop_wakeup(uint64_t a1, unsigned int a2, unsigned int a3)
{
  if (((a3 >> 2) & 1) != 0)
  {
    _dispatch_workloop_barrier_complete(a1, a2, a3);
    return;
  }

  if ((a3 & 1) == 0)
  {
    qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: Invalid way to wake up a workloop";
    qword_E4DA8 = a3;
    __break(1u);
    JUMPOUT(0x2DE34LL);
  }

  BOOL v10 = (unint64_t *)(a1 + 56);
  do
  {
    if (_os_atomic_mo_has_acquire(3)) {
      unint64_t v3 = __ldaxr(v10);
    }
    else {
      unint64_t v3 = __ldxr(v10);
    }
    uint64_t v13 = v3;
    unint64_t v17 = v3;
    if ((v3 & 0x700000000LL) < (unint64_t)a2 << 32)
    {
      unint64_t v17 = v3 & 0xFFFFFFF8FFFFFFFFLL | ((unint64_t)a2 << 32);
      if ((v17 & 0x1000000000LL) != 0) {
        v17 |= 0x800000000uLL;
      }
    }

    uint64_t v12 = v17;
    if ((v17 & 0x700000000LL) >> 32) {
      uint64_t v12 = v17 | 1;
    }
    if ((a3 & 2) != 0)
    {
      v12 |= 0x8000000000uLL;
    }

    else if (v12 == v3)
    {
      __clrex();
      goto LABEL_43;
    }

    if (_os_atomic_mo_has_release(3)) {
      BOOL v11 = __stlxr(v12, v10) == 0;
    }
    else {
      BOOL v11 = __stxr(v12, v10) == 0;
    }
  }

  while (!v11);
  if ((v13 & 0xFF80000000000000LL) != 0)
  {
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Waking up an inactive workloop";
    qword_E4DA8 = v13;
    __break(1u);
    JUMPOUT(0x2E05CLL);
  }

  if (((v13 ^ v12) & 1) != 0)
  {
    if ((a3 & 1) == 0) {
      _dispatch_abort(1929LL, a3 & 1, v4, v5, v6, v7, v8, v9);
    }
    if ((v12 & 0x2000000000LL) != 0) {
      _dispatch_event_loop_poke((unsigned int *)a1, v12, 1LL, v5, v6, v7, v8, v9);
    }
    else {
      (*(void (**)(void, uint64_t, unint64_t, uint64_t, uint64_t, uint64_t))(**(void **)(a1 + 24)
    }
                                                                                           + 72LL))( *(void *)(a1 + 24),  a1,  (v12 & 0x700000000uLL) >> 32,  v5,  v6,  v7);
    return;
  }

  if (((v13 ^ v12) & 0x700000000LL) == 0)
  {
LABEL_43:
    _dispatch_release_2_tailcall((unsigned int *)a1);
    return;
  }

  if ((v12 & 0xFF80000000000000LL) != 0 || (v12 & 0x4000000000LL) != 0 || (v12 & 1) == 0 && (v12 & 0xFFFFFFFC) == 0) {
    _dispatch_abort(5301LL, 0LL, v4, v5, v6, v7, v8, v9);
  }
  if ((v12 & 0x2000000000LL) != 0) {
    _dispatch_event_loop_poke((unsigned int *)a1, v12, a3 | 0x80000000, v5, v6, v7, v8, v9);
  }
  else {
    _dispatch_queue_wakeup_with_override_slow(a1, v12, a3);
  }
}

void _dispatch_workloop_invoke( unsigned int *a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v61 = a1;
  uint64_t v60 = a2;
  unsigned int v59 = a3 & 0xFFEDFFFF | 0x100000;
  int v58 = 0;
  int v57 = _dispatch_workloop_invoke2;
  uint64_t v56 = a1;
  v55[8] = 0;
  *(void *)unint64_t v55 = (a3 & 1) == 0;
  uint64_t v54 = 0LL;
  if ((a3 & 3) == 0)
  {
    *((void *)v56 + 2) = -1985229329LL;
    uint64_t v53 = _dispatch_thread_getspecific(0x14uLL);
    uint64_t v52 = v56;
    uint64_t v83 = v53;
    uint64_t v82 = v56;
    int v81 = 0;
    int v80 = 0;
    unint64_t v177 = v53;
    uint64_t v176 = v56;
  }

  v59 |= v58;
  if ((v59 & 2) != 0)
  {
    uint64_t v54 = 0x40020000000001LL;
    goto LABEL_54;
  }

  uint64_t v109 = v56;
  unsigned int v108 = v59;
  uint64_t v107 = 0LL;
  uint64_t v107 = (uint64_t)(*((unsigned __int16 *)v56 + 40) - 1) << 41;
  unsigned int v122 = _dispatch_thread_getspecific(3uLL);
  uint64_t v106 = v122 & 0xFFFFFFFC | 0x20000000000000LL;
  unint64_t v104 = 0LL;
  unint64_t v103 = 0LL;
  uint64_t v102 = 0LL;
  unint64_t v105 = 0xFFE00000FFFFFFFCLL;
  if ((v59 & 1) != 0)
  {
    v105 |= 0x4000000000uLL;
    uint64_t v102 = 0LL;
  }

  else if ((v108 & 0x40000) != 0)
  {
    uint64_t v102 = 0x4000000000LL;
  }

  else
  {
    v105 |= 0x4000000000uLL;
    uint64_t v102 = 1LL;
  }

  BOOL v115 = (v108 & 2) == 0;
  uint64_t v114 = 1323LL;
  if ((v108 & 2) != 0) {
    _dispatch_abort(v114, v115, v8, v9, v10, v11, v12, v13);
  }
  unsigned int v101 = 0;
  unsigned int v119 = _dispatch_thread_getspecific(0x19uLL);
  unsigned int v121 = v119 & 0xF00;
  unsigned int v118 = v121 >> 8;
  unsigned int v120 = v119 & 0xF000;
  unsigned int v117 = v120 >> 12;
  int v123 = v119 & 0xF0000;
  unsigned int v116 = (v119 & 0xF0000) >> 16;
  if (v121 >> 8 <= v120 >> 12) {
    unsigned int v47 = v117;
  }
  else {
    unsigned int v47 = v118;
  }
  if (v47 <= v116)
  {
    unsigned int v45 = v116;
  }

  else
  {
    if (v118 <= v117) {
      unsigned int v46 = v117;
    }
    else {
      unsigned int v46 = v118;
    }
    unsigned int v45 = v46;
  }

  unsigned int v101 = v45;
LABEL_22:
  BOOL v100 = 0;
  BOOL v99 = (unint64_t *)(v109 + 14);
  while (1)
  {
    unint64_t v16 = _os_atomic_mo_has_acquire(2) ? __ldaxr(v99) : __ldxr(v99);
    unint64_t v104 = v16;
    unint64_t v103 = v16;
    if ((v16 & v105) != 0) {
      break;
    }
    unint64_t v154 = v104;
    unsigned int v153 = v101;
    unint64_t v156 = v104;
    BOOL v44 = 0;
    if ((v104 & 0x1000000000LL) != 0)
    {
      uint64_t v155 = v154 & 0x700000000LL;
      BOOL v44 = v153 < (v154 & 0x700000000LL) >> 32;
    }

    if (v44)
    {
      __clrex();
      unint64_t v158 = v104;
      uint64_t v159 = v104 & 0x700000000LL;
      unsigned int v157 = (v104 & 0x700000000LL) >> 32;
      unsigned int v163 = _dispatch_thread_getspecific(3uLL);
      unsigned int v162 = v157;
      if ((_dispatch_set_qos_class_enabled & 1) != 0)
      {
        unsigned int v165 = v162;
        uint64_t v164 = 0LL;
        if (v162) {
          uint64_t v164 = 1LL << (v165 + 7);
        }
        _pthread_workqueue_override_start_direct(v163, v164 | 0xFF);
      }

      unsigned int v161 = v157;
      unsigned int v160 = _dispatch_thread_getspecific(0x19uLL);
      int v166 = v160 & 0xF0000;
      if (v157 > (v160 & 0xF0000) >> 16)
      {
        unsigned int v160 = v160 & 0xFFF0FFFF | (v161 << 16);
        _dispatch_thread_setspecific(25LL, v160);
      }

      unsigned int v101 = v157;
      goto LABEL_22;
    }

    unint64_t v103 = v103 & 0x7700000001LL | v106;
    unint64_t v111 = v104;
    if ((v104 & 0x10000000000LL) != 0 || v104 + v107 < 0x20000000000000LL) {
      v103 |= 0x40000000000000uLL;
    }
LABEL_44:
    if (_os_atomic_mo_has_release(2)) {
      BOOL v100 = __stlxr(v103, v99) == 0;
    }
    else {
      BOOL v100 = __stxr(v103, v99) == 0;
    }
    if (v100) {
      goto LABEL_48;
    }
  }

  if (v102)
  {
    v103 ^= v102;
    goto LABEL_44;
  }

  __clrex();
LABEL_48:
  BOOL v98 = v100;
  BOOL v113 = (v104 & v102) == v102;
  uint64_t v112 = 1356LL;
  if ((v104 & v102) != v102) {
    _dispatch_abort(v112, v113, v14, v15, a5, a6, a7, a8);
  }
  if ((v104 & v105) != 0)
  {
    uint64_t v110 = 0LL;
  }

  else
  {
    v103 &= v102 | 0x60000000000000LL;
    v104 &= 0x3FFE0000000000uLL;
    uint64_t v110 = v103 - v104;
  }

  uint64_t v54 = v110;
LABEL_54:
  if (v54)
  {
    unsigned int v51 = 0;
    if ((v59 & 0x40000) != 0)
    {
      unsigned int v51 = 0;
    }

    else
    {
      unsigned int v87 = v56[21];
      unsigned int v86 = _dispatch_thread_getspecific(0x19uLL);
      unsigned int v85 = v86;
      if (v86)
      {
        if ((v87 & 0xFFF) != 0)
        {
          v85 &= 0x880F0000;
          if ((v86 & 0xFFF) <= (v87 & 0xFFF)) {
            int v43 = v87 & 0xFFF;
          }
          else {
            int v43 = v86 & 0xFFF;
          }
          v85 |= v43;
          unsigned int v89 = v87 & 0xF000;
          unsigned int v91 = v85 & 0xF00;
          if (v89 >> 12 <= v91 >> 8) {
            v87 &= 0x40000000u;
          }
          else {
            v87 &= 0x4400F000u;
          }
          v85 |= v87;
        }

        else
        {
          if ((v85 & 0xFFF) != 0) {
            v85 |= 0x40000000u;
          }
          unsigned int v88 = v87 & 0xF000;
          unsigned int v90 = v85 & 0xF00;
          if (v88 >> 12 > v90 >> 8) {
            unsigned int v85 = v85 & 0xFFFF0FFF | v87 & 0x400F000;
          }
        }
      }

      else
      {
        unsigned int v85 = v87 & 0xFFF0FFFF;
      }

      _dispatch_thread_setspecific(25LL, v85);
      unsigned int v51 = v86;
    }

    if ((v59 & 0x100000) != 0)
    {
      unsigned int v65 = v61;
      unsigned int v64 = 0;
      unsigned int v63 = v61[20];
      unsigned int v64 = v63;
      unsigned int v62 = v63;
      if ((v63 & 0x400000) != 0)
      {
        uint64_t v77 = v61;
        int v76 = 0x400000;
        int v74 = -4194305;
        int v73 = -4194305;
        int v75 = -4194305;
        unsigned int v71 = 0;
        unsigned int v41 = v61 + 20;
        int v69 = -4194305;
        int v68 = -4194305;
        int v70 = -4194305;
        unsigned int v42 = v61[20];
        do
        {
          unsigned int v17 = v42;
          do
            unsigned int v18 = __ldaxr(v41);
          while (v18 == v42 && __stlxr(v42 & 0xFFBFFFFF, v41));
          unsigned int v42 = v18;
        }

        while (v18 != v17);
        unsigned int v67 = v18;
        unsigned int v71 = v18;
        unsigned int v66 = v18;
        int v72 = v18 & v75;
      }
    }

    unsigned int v50 = v56;
    int v126 = v56;
    unsigned int v125 = v59;
    int v124 = 0;
    unsigned int v169 = v56;
    uint64_t v168 = 256LL;
    uint64_t v175 = 1LL;
    uint64_t v174 = 730LL;
    int v167 = 0;
    uint64_t v173 = v56;
    unsigned int v172 = 0;
    unsigned int v171 = v56[20];
    unsigned int v172 = v171;
    unsigned int v170 = v171;
    int v167 = v171 & 0x30000;
    int v124 = (v171 & 0x30000) << 8;
    if (v124) {
      unsigned int v125 = v125 & 0xFCFFFFFF | v124;
    }
    unsigned int v59 = v125;
    do
    {
      if ((v59 & 2) != 0 && (v59 & 0x1000000) == 0) {
        _dispatch_last_resort_autorelease_pool_push(v60);
      }
      uint64_t v49 = v56;
      *(void *)&v55[1] = v57((uint64_t)v56, v60, v59, (uint64_t)&v54, a5, a6, a7, a8);
      if ((v59 & 2) != 0 && (v59 & 0x1000000) == 0)
      {
        __int128 v48 = 0uLL;
        uint64_t v93 = v56;
        uint64_t v92 = &v48;
        BOOL v97 = &v48;
        _dispatch_thread_getspecific_packed_pair(20LL, 21LL, &v48, v20, v21, v22, v23, v24);
        _dispatch_thread_setspecific_pair(20LL, (uint64_t)v93, 21LL, (uint64_t)v92, v25, v26, v27, v28);
        _dispatch_last_resort_autorelease_pool_pop(v60);
        unsigned int v94 = &v48;
        _dispatch_thread_setspecific_packed_pair(20LL, 21LL, &v48, v29, v30, v31, v32, v33);
      }

      BOOL v79 = *(void *)&v55[1] != 1LL;
      uint64_t v78 = 2018LL;
      if (*(void *)&v55[1] == 1LL) {
        _dispatch_abort(v78, v79, v19, v20, v21, v22, v23, v24);
      }
      BOOL v40 = 0;
      if (*(void *)&v55[1]) {
        BOOL v40 = *(void *)&v55[1] != -1LL;
      }
      if (v40) {
        break;
      }
      char v144 = v56;
      uint64_t v143 = v54;
      BOOL v142 = *(void *)&v55[1] == 0LL;
      unint64_t v141 = 0LL;
      unint64_t v140 = 0LL;
      int v139 = 0;
      int v138 = (unint64_t *)(v56 + 14);
      do
      {
        if (_os_atomic_mo_has_acquire(3)) {
          unint64_t v34 = __ldaxr(v138);
        }
        else {
          unint64_t v34 = __ldxr(v138);
        }
        unint64_t v141 = v34;
        unint64_t v140 = (v34 - v143) & 0xFFFFFFF700000001LL;
        unint64_t v146 = v34;
        if ((v34 & 0xFF80000000000000LL) == 0)
        {
          unint64_t v147 = v141;
          if ((v141 & 0x8000000000LL) != 0)
          {
            __clrex();
            uint64_t v136 = 0x8000000000LL;
            uint64_t v135 = 0x8000000000LL;
            uint64_t v137 = 0x8000000000LL;
            unint64_t v133 = 0LL;
            unint64_t v38 = (unint64_t *)(v144 + 14);
            uint64_t v131 = 0x8000000000LL;
            uint64_t v130 = 0x8000000000LL;
            uint64_t v132 = 0x8000000000LL;
            unint64_t v39 = *((void *)v144 + 7);
            do
            {
              unint64_t v35 = v39;
              do
                unint64_t v36 = __ldaxr(v38);
              while (v36 == v39 && __stlxr(v39 ^ 0x8000000000LL, v38));
              unint64_t v39 = v36;
            }

            while (v36 != v35);
            unint64_t v129 = v36;
            unint64_t v133 = v36;
            unint64_t v128 = v36;
            unint64_t v134 = v36 ^ v137;
            char v145 = 0;
            goto LABEL_119;
          }

          if (v142) {
            v140 &= 0xFFFFFFF8FFFFFFFFLL;
          }
          else {
            v140 |= 0x8000000000uLL;
          }
        }

        if (_os_atomic_mo_has_release(3))
        {
          LOBYTE(v139) = __stlxr(v140, v138) == 0;
          int v139 = v139;
        }

        else
        {
          LOBYTE(v139) = __stxr(v140, v138) == 0;
          int v139 = v139;
        }
      }

      while (!v139);
      int v127 = v139;
      unint64_t v149 = v141;
      unint64_t v151 = v141;
      BOOL v37 = 0;
      if ((v141 & 0x1000000000LL) != 0) {
        BOOL v37 = (v149 & 0x800000000LL) != 0;
      }
      if (v37)
      {
        uint64_t v148 = v141 & 0x700000000LL;
        uint64_t v150 = v141 & 0x700000000LL;
        LODWORD(v150) = _dispatch_thread_getspecific(0x19uLL);
        int v152 = v150 & 0xF0000;
        if (HIDWORD(v150) > (v150 & 0xF0000) >> 16)
        {
          LODWORD(v150) = v150 & 0xFFF0FFFF;
          LODWORD(v150) = v150 | (HIDWORD(v150) << 16);
          _dispatch_thread_setspecific(25LL, v150);
        }
      }

      char v145 = 1;
LABEL_119:
      if ((v145 & 1) != 0)
      {
        uint64_t v54 = 0LL;
        *(void *)&v55[1] = 0LL;
        break;
      }

      *(void *)&v55[1] = _dispatch_thread_getspecific(0x14uLL);
    }

    while ((*(void *)(**(void **)&v55[1] + 16LL) & 0x10000LL) != 0 || (v55[0] & 1) == 0);
    if ((v59 & 0x40000) == 0)
    {
      unsigned int v96 = v51;
      unsigned int v95 = 0;
      unsigned int v95 = _dispatch_thread_getspecific(0x19uLL);
      v96 &= 0xFFF0FFFF;
      v96 |= v95 & 0xF0000;
      _dispatch_thread_setspecific(25LL, v96);
    }
  }

  if ((v55[0] & 1) != 0)
  {
    unsigned int v84 = v56;
    uint64_t v178 = v56;
    unsigned int v183 = 772079660;
    unsigned int v182 = v56;
    uint64_t v181 = 0LL;
    uint64_t v180 = 0LL;
    uint64_t v179 = 0LL;
    if (MEMORY[0xFFFFFC100]) {
      kdebug_trace(v183, v182, v181, v180, v179);
    }
    unint64_t v184 = v84;
  }

  if (*(void *)&v55[1]) {
    _dispatch_queue_invoke_finish(v56, v60, *(uint64_t (****)())&v55[1], v54);
  }
  else {
    _dispatch_release_2_tailcall(v56);
  }
}

uint64_t _dispatch_workloop_invoke2( uint64_t a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v39 = a1;
  uint64_t v38 = a2;
  int v37 = a3;
  unint64_t v36 = (void *)a4;
  unint64_t v35 = 0LL;
  unint64_t v35 = *(_DWORD **)(a1 + 200);
  __int128 v34 = 0uLL;
  if (v35 && (*v35 & 0x20) != 0)
  {
    uint64_t v54 = v35 + 10;
    _dispatch_thread_setspecific(24LL, (uint64_t)(v35 + 10));
  }

  uint64_t v45 = v39;
  BOOL v44 = &v34;
  __int128 v48 = &v34;
  _dispatch_thread_getspecific_packed_pair(20LL, 21LL, &v34, a4, a5, a6, a7, a8);
  _dispatch_thread_setspecific_pair(20LL, v45, 21LL, (uint64_t)v44, v8, v9, v10, v11);
  do
  {
LABEL_5:
    if (!i)
    {
      *unint64_t v36 = (*v36 & 1LL) + 0x40020000000000LL;
      unsigned int v47 = &v34;
      _dispatch_thread_setspecific_packed_pair(20LL, 21LL, &v34, v12, v13, v14, v15, v16);
      uint64_t v53 = 0LL;
      _dispatch_thread_setspecific(24LL, 0LL);
      return 0LL;
    }

    uint64_t v73 = v39;
    unsigned int v72 = i;
    unint64_t v71 = 0LL;
    unint64_t v70 = 0LL;
    unsigned int v76 = i;
    unint64_t v69 = (unint64_t)i << 32;
    int v68 = 0;
    unsigned int v67 = (unint64_t *)(v39 + 56);
    do
    {
      if (_os_atomic_mo_has_acquire(0)) {
        unint64_t v17 = __ldaxr(v67);
      }
      else {
        unint64_t v17 = __ldxr(v67);
      }
      unint64_t v71 = v17;
      if ((v17 & 0x700000000LL) <= v69)
      {
        __clrex();
        char v74 = 1;
        goto LABEL_31;
      }

      unint64_t v75 = v71;
      if ((v71 & 0x8000000000LL) != 0)
      {
        __clrex();
        uint64_t v65 = 0x8000000000LL;
        uint64_t v64 = 0x8000000000LL;
        uint64_t v66 = 0x8000000000LL;
        unint64_t v62 = 0LL;
        uint64_t v24 = (unint64_t *)(v73 + 56);
        uint64_t v60 = 0x8000000000LL;
        uint64_t v59 = 0x8000000000LL;
        uint64_t v61 = 0x8000000000LL;
        unint64_t v25 = *(void *)(v73 + 56);
        do
        {
          unint64_t v18 = v25;
          do
            unint64_t v19 = __ldaxr(v24);
          while (v19 == v25 && __stlxr(v25 ^ 0x8000000000LL, v24));
          unint64_t v25 = v19;
        }

        while (v19 != v18);
        unint64_t v58 = v19;
        unint64_t v62 = v19;
        unint64_t v57 = v19;
        unint64_t v63 = v19 ^ v66;
        char v74 = 0;
        goto LABEL_31;
      }

      unint64_t v70 = v71 & 0xFFFFFFF8FFFFFFFFLL | v69;
      if (_os_atomic_mo_has_release(0))
      {
        LOBYTE(v68) = __stlxr(v70, v67) == 0;
        int v68 = v68;
      }

      else
      {
        LOBYTE(v68) = __stxr(v70, v67) == 0;
        int v68 = v68;
      }
    }

    while (!v68);
    int v56 = v68;
    unint64_t v55 = 0LL;
    unint64_t v55 = _dispatch_thread_getspecific(0x1DuLL);
    if (v55)
    {
      v55[45] = v55[45] & 0xFD | 2;
      _dispatch_return_to_kernel();
    }

    char v74 = 1;
LABEL_31:
    ;
  }

  while (((v74 ^ 1) & 1) != 0);
  *(_BYTE *)(v39 + 100) = i;
  uint64_t v31 = (unint64_t *)(v39 + 104 + 8LL * (int)(i - 1));
  uint64_t v30 = *v31;
  if (!*v31) {
    uint64_t v30 = _dispatch_wait_for_enqueuer(v31, v39 + 152 + 8LL * (int)(i - 1));
  }
  uint64_t v33 = (void *)v30;
  while (1)
  {
    uint64_t v49 = v33;
    unsigned int v51 = v33;
    if (*v33 <= 0xFFFuLL && (*v49 & 1LL) != 0) {
      break;
    }
    uint64_t v29 = (void *)v33[2];
    *(void *)(v39 + 104 + 8LL * (int)(i - 1)) = v29;
    if (!v29)
    {
      uint64_t v27 = (unint64_t *)(v39 + 152 + 8LL * (int)(i - 1));
      while (1)
      {
        unint64_t v20 = _os_atomic_mo_has_acquire(3) ? __ldaxr(v27) : __ldxr(v27);
        unint64_t v43 = v20;
        if (v33 != (void *)(v20 & 0xFFFFFFFFFFFFFFF8LL)) {
          break;
        }
        if (!_os_atomic_mo_has_release(3)) {
          BOOL v28 = __stxr(0LL, v27) == 0;
        }
        else {
          BOOL v28 = __stlxr(0LL, v27) == 0;
        }
        if (v28) {
          goto LABEL_54;
        }
      }

      __clrex();
      uint64_t v26 = v33[2];
      if (!v26) {
        uint64_t v26 = _dispatch_wait_for_enqueuer(v33 + 2, v39 + 152 + 8LL * (int)(i - 1));
      }
      uint64_t v29 = (void *)v26;
      *(void *)(v39 + 104 + 8LL * (int)(i - 1)) = v26;
    }

void _dispatch_workloop_barrier_complete(uint64_t a1, unsigned int a2, unsigned int a3)
{
  uint64_t v28 = 0LL;
LABEL_2:
  for (unsigned int i = 6; i; --i)
  {
    if (*(void *)(a1 + 152 + 8LL * (int)(i - 1)))
    {
      uint64_t v26 = (unint64_t *)(a1 + 104 + 8LL * (int)(i - 1));
      unint64_t v25 = (void *)*v26;
      if (!*v26) {
        unint64_t v25 = (void *)_dispatch_wait_for_enqueuer(v26, a1 + 152 + 8LL * (int)(i - 1));
      }
      if (*v25 <= 0xFFFuLL && (*v25 & 0x81LL) != 0)
      {
        _dispatch_workloop_drain_barrier_waiter(a1, v25, i, a3, 0LL);
        return;
      }

      uint64_t v28 = 1LL;
    }
  }

  BOOL v20 = 0;
  if (v28) {
    BOOL v20 = (a3 & 1) == 0;
  }
  if (v20)
  {
    _dispatch_retain_2(a1);
    a3 |= 1u;
  }

LABEL_18:
  uint64_t v21 = (unint64_t *)(a1 + 56);
  do
  {
    if (_os_atomic_mo_has_acquire(3)) {
      unint64_t v3 = __ldaxr(v21);
    }
    else {
      unint64_t v3 = __ldxr(v21);
    }
    unint64_t v24 = v3;
    if ((v3 & 0x2000000000LL) != 0 && (v3 & 2) != 0 && (v3 & 0x800000001LL) != 0)
    {
      _dispatch_event_loop_ensure_ownership(a1);
      unint64_t v18 = (unint64_t *)(a1 + 56);
      unint64_t v19 = *(void *)(a1 + 56);
      do
      {
        unint64_t v4 = v19;
        do
          unint64_t v5 = __ldaxr(v18);
        while (v5 == v19 && __stlxr(v19 & 0xFFFFFFF7FFFFFFFDLL, v18));
        unint64_t v19 = v5;
      }

      while (v5 != v4);
      __clrex();
      goto LABEL_18;
    }

    unint64_t v34 = v3;
    unint64_t v33 = (unint64_t)a2 << 32;
    if ((v3 & 0x700000000LL) < v33)
    {
      unint64_t v34 = v3 & 0xFFFFFFF8FFFFFFFFLL | v33;
      if (v3 & 0x1000000000LL | v33 & 0x1000000000LL) {
        v34 |= 0x800000000uLL;
      }
    }

    if (v28)
    {
      unint64_t v23 = (v34 - 0x40020000000000LL) & 0xFFFFFFF700000000LL | 1;
    }

    else
    {
      if ((v3 & 0x8000000000LL) != 0)
      {
        __clrex();
        uint64_t v16 = (unint64_t *)(a1 + 56);
        unint64_t v17 = *(void *)(a1 + 56);
        do
        {
          unint64_t v6 = v17;
          do
            unint64_t v7 = __ldaxr(v16);
          while (v7 == v17 && __stlxr(v17 ^ 0x8000000000LL, v16));
          unint64_t v17 = v7;
        }

        while (v7 != v6);
        goto LABEL_2;
      }

      if ((v3 & 0x2000000000LL) != 0) {
        unint64_t v23 = (v34 - 0x40020000000000LL) & 0xFFFFFFF000000000LL;
      }
      else {
        unint64_t v23 = (v34 - 0x40020000000000LL) & 0xFFFFFFF000000001LL;
      }
    }

    if (_os_atomic_mo_has_release(3)) {
      BOOL v22 = __stlxr(v23, v21) == 0;
    }
    else {
      BOOL v22 = __stxr(v23, v21) == 0;
    }
  }

  while (!v22);
  BOOL v14 = ((v24 ^ _dispatch_thread_getspecific(3uLL)) & 0xFFFFFFFC) == 0;
  if (!v14) {
    _dispatch_abort(4827LL, v14, v8, v9, v10, v11, v12, v13);
  }
  if ((v24 & 0x4000000000LL) != 0) {
    _dispatch_abort(4828LL, (v24 & 0x4000000000LL) == 0, v8, v9, v10, v11, v12, v13);
  }
  if ((v24 & 0x2000000000LL) != 0)
  {
    if ((v23 & 0x4000000000LL) != 0) {
      _dispatch_abort(4845LL, (v23 & 0x4000000000LL) == 0, v8, v9, v10, v11, v12, v13);
    }
    if ((v24 & 1) != 0 || (v23 & 1) != 0 || (v24 & 2) == 0)
    {
      _dispatch_event_loop_end_ownership((unsigned int *)a1, v24, v23, a3, v10, v11, v12, v13);
      return;
    }

    _dispatch_event_loop_assert_not_owned(a1);
    goto LABEL_96;
  }

  BOOL v15 = 0;
  if ((v24 & 0x1000000000LL) != 0) {
    BOOL v15 = (v24 & 0x800000000LL) != 0;
  }
  if (v15)
  {
    unsigned int v32 = _dispatch_thread_getspecific(0x19uLL);
    if ((BYTE4(v24) & 7u) > (v32 & 0xF0000) >> 16) {
      _dispatch_thread_setspecific(25LL, v32 & 0xFFF0FFFF | ((BYTE4(v24) & 7) << 16));
    }
  }

  if (!v28) {
    goto LABEL_96;
  }
  if (((v24 ^ v23) & 1) != 0)
  {
    if ((v23 & 0x4000000001LL) == 0) {
      _dispatch_abort(4864LL, (v23 & 0x4000000001LL) != 0, v8, v9, v10, v11, v12, v13);
    }
    if ((a3 & 1) == 0) {
      _dispatch_abort(1929LL, a3 & 1, v8, v9, v10, v11, v12, v13);
    }
    if ((v23 & 0x2000000000LL) != 0) {
      _dispatch_event_loop_poke((unsigned int *)a1, v23, 1LL, v9, v10, v11, v12, v13);
    }
    else {
      (*(void (**)(void, uint64_t, unint64_t, uint64_t, uint64_t, uint64_t))(**(void **)(a1 + 24)
    }
                                                                                           + 72LL))( *(void *)(a1 + 24),  a1,  (v23 & 0x700000000LL) >> 32,  v9,  v10,  v11);
    return;
  }

  if ((v23 & 0xFF80000000000000LL) != 0 || (v23 & 0x4000000000LL) != 0 || (v23 & 1) == 0 && (v23 & 0xFFFFFFFC) == 0)
  {
LABEL_96:
    if ((a3 & 1) != 0) {
      _dispatch_release_2_tailcall((unsigned int *)a1);
    }
    return;
  }

  BOOL v36 = (v23 & 0xFF80000000000000LL) == 0 && (v23 & 0x4000000000LL) == 0 && ((v23 & 1) != 0 || (v23 & 0xFFFFFFFC) != 0);
  if (!v36) {
    _dispatch_abort(5301LL, v36, v8, v9, v10, v11, v12, v13);
  }
  if ((v23 & 0x2000000000LL) != 0) {
    _dispatch_event_loop_poke((unsigned int *)a1, v23, a3 | 0x80000000, v9, v10, v11, v12, v13);
  }
  else {
    _dispatch_queue_wakeup_with_override_slow(a1, v23, a3);
  }
}

void _dispatch_workloop_push( uint64_t a1, void *a2, unsigned int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v13 = a3;
  if (*a2 <= 0xFFFuLL && (*a2 & 0x81LL) != 0)
  {
    _dispatch_workloop_push_waiter(a1, (unint64_t)a2, a3, a4, a5, a6, a7, a8);
  }

  else
  {
    if (a3 < (*(_DWORD *)(a1 + 84) & 0xF00u) >> 8) {
      unsigned int v13 = (*(_DWORD *)(a1 + 84) & 0xF00u) >> 8;
    }
    if (!v13) {
      unsigned int v13 = (*(_DWORD *)(a1 + 84) & 0xF000u) >> 12;
    }
    a2[2] = 0LL;
    _dispatch_thread_setspecific(122LL, a1 + 152 + 8LL * (int)(v13 - 1));
    uint64_t v10 = (unint64_t *)(a1 + 152 + 8LL * (int)(v13 - 1));
    unint64_t v11 = *v10;
    do
    {
      unint64_t v8 = v11;
      do
        unint64_t v9 = __ldaxr(v10);
      while (v9 == v11 && __stlxr((unint64_t)a2, v10));
      unint64_t v11 = v9;
    }

    while (v9 != v8);
    unint64_t v12 = v9;
    if (!v9) {
      _dispatch_retain_2_unsafe(a1);
    }
    if (v12) {
      *(void *)(v12 + 16) = a2;
    }
    else {
      *(void *)(a1 + 104 + 8LL * (int)(v13 - 1)) = a2;
    }
    _dispatch_thread_setspecific(122LL, 0LL);
    if (!v12) {
      _dispatch_workloop_wakeup(a1, v13, 3LL);
    }
  }

void _dispatch_workloop_push_waiter( uint64_t a1, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v39 = a3;
  uint64_t v46 = *(void *)(a2 + 8);
  if ((v46 & 0x20000000) != 0) {
    _dispatch_abort(458LL, (*(void *)(a2 + 8) & 0x20000000LL) == 0, a3, a4, a5, a6, a7, a8);
  }
  unsigned int v8 = (v46 & 0x3FFF00uLL) >> 8;
  __int16 v9 = __clz(__rbit32(v8));
  if (v8) {
    __int16 v10 = v9 + 1;
  }
  else {
    __int16 v10 = 0;
  }
  if (!v39) {
    unsigned int v39 = 4;
  }
  *(void *)(a2 + 16) = 0LL;
  _dispatch_thread_setspecific(122LL, a1 + 152 + 8LL * (int)(v39 - 1));
  unint64_t v24 = (unint64_t *)(a1 + 152 + 8LL * (int)(v39 - 1));
  unint64_t v25 = *v24;
  do
  {
    unint64_t v11 = v25;
    do
      unint64_t v12 = __ldaxr(v24);
    while (v12 == v25 && __stlxr(a2, v24));
    unint64_t v25 = v12;
  }

  while (v12 != v11);
  unint64_t v38 = v12;
  if (v12) {
    *(void *)(v12 + 16) = a2;
  }
  else {
    *(void *)(a1 + 104 + 8LL * (int)(v39 - 1)) = a2;
  }
  _dispatch_thread_setspecific(122LL, 0LL);
  if (!v38)
  {
    if ((*(void *)a2 & 0x80LL) == 0) {
      goto LABEL_24;
    }
    unint64_t v42 = *(void *)(a1 + 24);
    BOOL v23 = 0;
    if (v23)
    {
LABEL_24:
      unint64_t v36 = (unint64_t)_dispatch_thread_getspecific(3uLL) & 0xFFFFFFFC | 0x60000000000002LL;
      unsigned int v32 = (unint64_t *)(a1 + 56);
      do
      {
        if (_os_atomic_mo_has_acquire(3)) {
          unint64_t v13 = __ldaxr(v32);
        }
        else {
          unint64_t v13 = __ldxr(v32);
        }
        unint64_t v35 = v13;
        unint64_t v44 = v13;
        unint64_t v43 = (unint64_t)v39 << 32;
        if ((v13 & 0x700000000LL) < v43)
        {
          unint64_t v44 = v13 & 0xFFFFFFF8FFFFFFFFLL | v43;
          if (v13 & 0x1000000000LL | v43 & 0x1000000000LL) {
            v44 |= 0x800000000uLL;
          }
        }

        unint64_t v34 = v44 | 0x8000000000LL;
        if ((v13 & 0xFFFFFFFC) == 0 && (v13 & 0x4000000001LL) == 0) {
          unint64_t v34 = v44 & 0x7700000001LL | v36;
        }
        if (_os_atomic_mo_has_release(3)) {
          BOOL v33 = __stlxr(v34, v32) == 0;
        }
        else {
          BOOL v33 = __stxr(v34, v32) == 0;
        }
      }

      while (!v33);
      if ((v34 & 0x2000000000LL) != 0 && *(void *)(a2 + 48) != -4LL)
      {
        int v22 = *(_DWORD *)(a2 + 100);
        *(_BYTE *)(a2 + 106) = *(_BYTE *)(a2 + 106) & 0xFB | (4
                                                            * (v22 == _dispatch_thread_getspecific(3uLL)));
      }

      if (((v35 ^ v34) & 0x40000000000000LL) != 0)
      {
        if ((*(_BYTE *)(a2 + 106) & 4) == 0) {
          goto LABEL_63;
        }
        uint64_t v31 = (unint64_t *)(a1 + 104 + 8LL * (int)(v39 - 1));
        uint64_t v30 = *v31;
        if (!*v31) {
          uint64_t v30 = _dispatch_wait_for_enqueuer(v31, a1 + 152 + 8LL * (int)(v39 - 1));
        }
        if (v30 == a2)
        {
          *(_BYTE *)(a2 + 106) = *(_BYTE *)(a2 + 106) & 0xF7 | 8;
          if ((*(void *)a2 & 0x80LL) != 0) {
            *(void *)(a2 + 56) = a1;
          }
          uint64_t v29 = *(void *)(a2 + 16);
          *(void *)(a1 + 104 + 8LL * (int)(v39 - 1)) = v29;
          if (!v29)
          {
            uint64_t v27 = (unint64_t *)(a1 + 152 + 8LL * (int)(v39 - 1));
            while (1)
            {
              unint64_t v20 = _os_atomic_mo_has_acquire(3) ? __ldaxr(v27) : __ldxr(v27);
              if (a2 != (v20 & 0xFFFFFFFFFFFFFFF8LL)) {
                break;
              }
              if (!_os_atomic_mo_has_release(3)) {
                BOOL v28 = __stxr(0LL, v27) == 0;
              }
              else {
                BOOL v28 = __stlxr(0LL, v27) == 0;
              }
              if (v28) {
                return;
              }
            }

            __clrex();
            uint64_t v26 = *(void *)(a2 + 16);
            if (!v26) {
              uint64_t v26 = _dispatch_wait_for_enqueuer((unint64_t *)(a2 + 16), a1 + 152 + 8LL * (int)(v39 - 1));
            }
            *(void *)(a1 + 104 + 8LL * (int)(v39 - 1)) = v26;
          }
        }

        else
        {
LABEL_63:
          _dispatch_workloop_barrier_complete(a1, v39, 0LL);
        }
      }

      else if (((v35 ^ v34) & 0x700000000LL) != 0)
      {
        if ((v34 & 0xFF80000000000000LL) != 0 || (v34 & 0x4000000000LL) != 0) {
          BOOL v47 = 0;
        }
        else {
          BOOL v47 = (v34 & 1) != 0 || (v34 & 0x2000000000LL) == 0 && (v34 & 0xFFFFFFFC) != 0;
        }
        if (v47)
        {
          BOOL v45 = (v34 & 0xFF80000000000000LL) == 0
             && (v34 & 0x4000000000LL) == 0
             && ((v34 & 1) != 0 || (v34 & 0xFFFFFFFC) != 0);
          if (!v45) {
            _dispatch_abort(5301LL, v45, v14, v15, v16, v17, v18, v19);
          }
          if ((v34 & 0x2000000000LL) != 0) {
            _dispatch_event_loop_poke((unsigned int *)a1, v34, 0x80000000LL, v15, v16, v17, v18, v19);
          }
          else {
            _dispatch_queue_wakeup_with_override_slow(a1, v34, 0LL);
          }
        }
      }
    }

    else
    {
      *(void *)(a2 + 56) = a1;
      *(void *)a2 &= ~0x80uLL;
      _dispatch_retain_2_unsafe(a1);
      _dispatch_workloop_wakeup(a1, v39, 3LL);
    }
  }

uint64_t _dispatch_retain_2_unsafe(uint64_t a1)
{
  return _dispatch_retain_n_unsafe(a1, 2);
}

uint64_t dispatch_thread_get_current_override_qos_floor()
{
  uint64_t v6 = 0LL;
  uint64_t v0 = _dispatch_thread_getspecific(0x19uLL);
  unsigned int v7 = (unsigned __int16)((unsigned __int16)v0 & 0xF000) >> 12;
  else {
    unsigned int v5 = (unsigned __int16)((unsigned __int16)v0 & 0xF00) >> 8;
  }
  if (v5 <= (v0 & 0xF0000) >> 16)
  {
    unsigned int v3 = (v0 & 0xF0000) >> 16;
  }

  else
  {
    else {
      int v4 = (unsigned __int16)((unsigned __int16)v0 & 0xF00) >> 8;
    }
    unsigned int v3 = v4;
  }

  if (v3 != 15)
  {
    LODWORD(v6) = 1;
    unint64_t v2 = v3 - 1;
    if (v2 <= 5) {
      __asm { BR              X8 }
    }

    HIDWORD(v6) = 0;
  }

  return v6;
}

uint64_t dispatch_thread_override_self(int a1)
{
  unint64_t v2 = (a1 - 5);
  if (v2 <= 0x1C) {
    __asm { BR              X8 }
  }

  unsigned int v3 = _dispatch_thread_getspecific(3uLL);
  if ((_dispatch_set_qos_class_enabled & 1) != 0) {
    _pthread_workqueue_override_start_direct(v3, 255LL);
  }
  _dispatch_thread_getspecific(0x19uLL);
  return 0LL;
}

uint64_t dispatch_lock_override_start_with_debounce(uint64_t a1, unsigned int a2, int a3)
{
  unint64_t v4 = (a3 - 5);
  if (v4 <= 0x1C) {
    __asm { BR              X8 }
  }

  if ((_dispatch_set_qos_class_enabled & 1) != 0) {
    return _pthread_workqueue_override_start_direct_check_owner(a2, 255LL, a1);
  }
  else {
    return 0;
  }
}

uint64_t dispatch_lock_override_end(int a1)
{
  unint64_t v2 = (a1 - 5);
  if (v2 <= 0x1C) {
    __asm { BR              X8 }
  }

  _dispatch_thread_getspecific(0x19uLL);
  return 0LL;
}

void _dispatch_queue_wakeup( _DWORD *a1, unsigned int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v30 = a3;
  uint64_t v29 = (uint64_t (***)())a4;
  uint64_t v25 = 1LL;
  if (a4 == -1) {
    _dispatch_abort(5360LL, 0LL, a3, -1LL, a5, a6, a7, a8);
  }
  if (a4 && (a3 & 1) == 0)
  {
    _dispatch_retain_2((uint64_t)a1);
    v30 |= 1u;
  }

  if ((v30 & 4) != 0)
  {
    if (*(_BYTE *)(*(void *)a1 + 16LL) != 19LL) {
      _dispatch_abort(5378LL, *(unsigned __int8 *)(*(void *)a1 + 16LL) == 19LL, a3, a4, a5, a6, a7, a8);
    }
    unsigned int v37 = a2;
    if (!a2) {
      unsigned int v37 = (a1[21] & 0xF000u) >> 12;
    }
    if (v37 <= (a1[21] & 0xF00u) >> 8) {
      unsigned int v19 = (a1[21] & 0xF00u) >> 8;
    }
    else {
      unsigned int v19 = v37;
    }
    _dispatch_lane_class_barrier_complete(a1, v19, v30, v29, 0x40020000000000LL);
    return;
  }

  if (v29)
  {
    if (v29 == &_dispatch_mgr_q) {
      uint64_t v25 = 0x4000000000LL;
    }
    unsigned int v36 = a2;
    if (!a2) {
      unsigned int v36 = (a1[21] & 0xF000u) >> 12;
    }
    if (v36 <= (a1[21] & 0xF00u) >> 8) {
      unsigned int v18 = (a1[21] & 0xF00u) >> 8;
    }
    else {
      unsigned int v18 = v36;
    }
    BOOL v23 = (unint64_t *)(a1 + 14);
    do
    {
      if (_os_atomic_mo_has_acquire(3)) {
        unint64_t v8 = __ldaxr(v23);
      }
      else {
        unint64_t v8 = __ldxr(v23);
      }
      unint64_t v27 = v8;
      unint64_t v35 = v8;
      unint64_t v34 = (unint64_t)v18 << 32;
      if ((v8 & 0x700000000LL) < v34)
      {
        unint64_t v35 = v8 & 0xFFFFFFF8FFFFFFFFLL | v34;
        if (v8 & 0x1000000000LL | v34 & 0x1000000000LL) {
          v35 |= 0x800000000uLL;
        }
      }

      unint64_t v26 = v35;
      if ((v30 & 0x20) != 0 && (v8 & 0x180000000000000LL) == 0x80000000000000LL) {
        unint64_t v26 = v35 & 0xFF7FFFFFFFFFFFFFLL;
      }
      BOOL v17 = 0;
      if ((v26 & 0xFF80000000000000LL) == 0)
      {
        BOOL v17 = 0;
        if ((v8 & 0x4000000001LL) == 0)
        {
          BOOL v16 = 1;
          if ((v8 & 0xFFFFFFFC) != 0) {
            BOOL v16 = v25 != 0x4000000000LL;
          }
          BOOL v17 = v16;
        }
      }

      if (v17) {
        v26 |= v25;
      }
      if ((v30 & 2) != 0)
      {
        v26 |= 0x8000000000uLL;
      }

      else if (v26 == v8)
      {
        goto LABEL_64;
      }

      if (_os_atomic_mo_has_release(3)) {
        BOOL v24 = __stlxr(v26, v23) == 0;
      }
      else {
        BOOL v24 = __stxr(v26, v23) == 0;
      }
    }

    while (!v24);
  }

  else
  {
    if (!a2) {
      goto LABEL_104;
    }
    uint64_t v21 = (unint64_t *)(a1 + 14);
    do
    {
      if (_os_atomic_mo_has_acquire(0)) {
        unint64_t v15 = __ldaxr(v21);
      }
      else {
        unint64_t v15 = __ldxr(v21);
      }
      unint64_t v27 = v15;
      if ((v15 & 0xFFFFFFFC) == 0 && (v15 & 0x4000000001LL) == 0) {
        goto LABEL_64;
      }
      unint64_t v33 = v15;
      unint64_t v32 = (unint64_t)a2 << 32;
      if ((v15 & 0x700000000LL) < v32)
      {
        unint64_t v33 = v15 & 0xFFFFFFF8FFFFFFFFLL | v32;
        if (v15 & 0x1000000000LL | v32 & 0x1000000000LL) {
          v33 |= 0x800000000uLL;
        }
      }

      unint64_t v26 = v33;
      if ((v15 & 0x2000000000LL) != 0 && (v15 & 0xFF80000000000000LL) == 0 && (v15 & 0x4000000000LL) == 0) {
        unint64_t v26 = v33 | 1;
      }
      if (v26 == v15)
      {
LABEL_64:
        __clrex();
        goto LABEL_104;
      }

      if (_os_atomic_mo_has_release(0)) {
        BOOL v22 = __stlxr(v26, v21) == 0;
      }
      else {
        BOOL v22 = __stxr(v26, v21) == 0;
      }
    }

    while (!v22);
    uint64_t v29 = (uint64_t (***)())(&dword_0 + 1);
    if (((v27 ^ v26) & 1) != 0 && (v30 & 1) == 0)
    {
      _dispatch_retain_2((uint64_t)a1);
      v30 |= 1u;
    }
  }

  if (((v27 ^ v26) & v25) != 0)
  {
    else {
      unint64_t v20 = v29;
    }
    if ((v26 & 0x4000000001LL) == 0) {
      _dispatch_abort(5519LL, (v26 & 0x4000000001LL) != 0, v9, v10, v11, v12, v13, v14);
    }
    if ((v30 & 1) == 0) {
      _dispatch_abort(1929LL, v30 & 1, v9, v10, v11, v12, v13, v14);
    }
    if ((v26 & 0x2000000000LL) != 0) {
      _dispatch_event_loop_poke(a1, v26, 1LL, v10, v11, v12, v13, v14);
    }
    else {
      ((void (*)(uint64_t (***)(), _DWORD *, unint64_t, uint64_t, uint64_t, uint64_t))(*v20)[9])( v20,  a1,  (v26 & 0x700000000LL) >> 32,  v10,  v11,  v12);
    }
    return;
  }

  if (((v27 ^ v26) & 0x700000000LL) != 0
    && (v26 & 0xFF80000000000000LL) == 0
    && (v26 & 0x4000000000LL) == 0
    && ((v26 & 1) != 0 || (v26 & 0xFFFFFFFC) != 0))
  {
    if ((v26 & 0xFF80000000000000LL) != 0 || (v26 & 0x4000000000LL) != 0 || (v26 & 1) == 0 && (v26 & 0xFFFFFFFC) == 0) {
      _dispatch_abort(5301LL, 0LL, v9, v10, v11, v12, v13, v14);
    }
    if ((v26 & 0x2000000000LL) != 0) {
      _dispatch_event_loop_poke(a1, v26, v30 | 0x80000000, v10, v11, v12, v13, v14);
    }
    else {
      _dispatch_queue_wakeup_with_override_slow((uint64_t)a1, v26, v30);
    }
    return;
  }

LABEL_104:
  if ((v30 & 1) != 0) {
    _dispatch_release_2_tailcall(a1);
  }
}

void _dispatch_lane_class_barrier_complete( unsigned int *a1, unsigned int a2, unsigned int a3, uint64_t (***a4)(), uint64_t a5)
{
  if (a4 == &_dispatch_mgr_q)
  {
    uint64_t v25 = &_dispatch_mgr_q;
    uint64_t v26 = 0x4000000000LL;
  }

  else if (a4)
  {
    else {
      BOOL v22 = a4;
    }
    uint64_t v25 = v22;
    uint64_t v26 = 1LL;
  }

  else
  {
    uint64_t v25 = 0LL;
    uint64_t v26 = 0LL;
  }

LABEL_9:
  BOOL v23 = (unint64_t *)(a1 + 14);
  do
  {
    if (_os_atomic_mo_has_acquire(3)) {
      unint64_t v5 = __ldaxr(v23);
    }
    else {
      unint64_t v5 = __ldxr(v23);
    }
    unint64_t v28 = v5;
    if ((v5 & 0x2000000000LL) != 0 && (v5 & 2) != 0 && (v5 & 0x800000001LL) != 0)
    {
      _dispatch_event_loop_ensure_ownership((uint64_t)a1);
      unint64_t v20 = (unint64_t *)(a1 + 14);
      unint64_t v21 = *((void *)a1 + 7);
      do
      {
        unint64_t v6 = v21;
        do
          unint64_t v7 = __ldaxr(v20);
        while (v7 == v21 && __stlxr(v21 & 0xFFFFFFF7FFFFFFFDLL, v20));
        unint64_t v21 = v7;
      }

      while (v7 != v6);
      __clrex();
      goto LABEL_9;
    }

    unint64_t v36 = v5 - a5;
    unint64_t v35 = (unint64_t)a2 << 32;
    if (((v5 - a5) & 0x700000000LL) < v35)
    {
      unint64_t v36 = v36 & 0xFFFFFFF8FFFFFFFFLL | v35;
      if ((v36 & 0x1000000000LL) != 0) {
        v36 |= 0x800000000uLL;
      }
    }

    unint64_t v27 = v36 & 0xFFFFFFF700000001LL;
    if ((v5 & 0xFF80000000000000LL) != 0)
    {
      if ((v5 & 0x2000000000LL) != 0) {
        unint64_t v27 = v36 & 0xFFFFFFF700000000LL;
      }
    }

    else if (v26)
    {
      if ((v5 & 0x4000000001LL) == 0) {
        v27 |= v26;
      }
    }

    else
    {
      if ((v5 & 0x8000000000LL) != 0)
      {
        __clrex();
        unsigned int v18 = (unint64_t *)(a1 + 14);
        unint64_t v19 = *((void *)a1 + 7);
        do
        {
          unint64_t v8 = v19;
          do
            unint64_t v9 = __ldaxr(v18);
          while (v9 == v19 && __stlxr(v19 ^ 0x8000000000LL, v18));
          unint64_t v19 = v9;
        }

        while (v9 != v8);
        (*(void (**)(unsigned int *, void, void))(*(void *)a1 + 64LL))(a1, a2, a3 | 4);
        return;
      }

      unint64_t v27 = v36 & 0xFFFFFFF000000001LL;
    }

    if (_os_atomic_mo_has_release(3)) {
      BOOL v24 = __stlxr(v27, v23) == 0;
    }
    else {
      BOOL v24 = __stxr(v27, v23) == 0;
    }
  }

  while (!v24);
  uint64_t v29 = v28 - a5;
  BOOL v16 = ((v29 ^ _dispatch_thread_getspecific(3uLL)) & 0xFFFFFFFC) == 0;
  if (!v16) {
    _dispatch_abort(1424LL, v16, v10, v11, v12, v13, v14, v15);
  }
  if ((v29 & 0x4000000000LL) != 0) {
    _dispatch_abort(1425LL, (v29 & 0x4000000000LL) == 0, v10, v11, v12, v13, v14, v15);
  }
  if ((v29 & 0x2000000000LL) == 0)
  {
    BOOL v17 = 0;
    if ((v29 & 0x1000000000LL) != 0) {
      BOOL v17 = (v29 & 0x800000000LL) != 0;
    }
    if (v17)
    {
      unsigned int v34 = _dispatch_thread_getspecific(0x19uLL);
      if ((BYTE4(v29) & 7u) > (v34 & 0xF0000) >> 16) {
        _dispatch_thread_setspecific(25LL, v34 & 0xFFF0FFFF | ((BYTE4(v29) & 7) << 16));
      }
    }

    if (v25)
    {
      if (((v29 ^ v27) & v26) != 0)
      {
        if ((v27 & 0x4000000001LL) == 0) {
          _dispatch_abort(1464LL, (v27 & 0x4000000001LL) != 0, v10, v11, v12, v13, v14, v15);
        }
        if ((a3 & 1) == 0) {
          _dispatch_abort(1929LL, a3 & 1, v10, v11, v12, v13, v14, v15);
        }
        if ((v27 & 0x2000000000LL) != 0) {
          _dispatch_event_loop_poke(a1, v27, 1LL, v11, v12, v13, v14, v15);
        }
        else {
          ((void (*)(uint64_t (***)(), unsigned int *, unint64_t, uint64_t, uint64_t, uint64_t))(*v25)[9])( v25,  a1,  (v27 & 0x700000000LL) >> 32,  v11,  v12,  v13);
        }
        return;
      }

      if ((v27 & 0xFF80000000000000LL) == 0
        && (v27 & 0x4000000000LL) == 0
        && ((v27 & 1) != 0 || (v27 & 0xFFFFFFFC) != 0))
      {
        BOOL v37 = (v27 & 0xFF80000000000000LL) == 0
           && (v27 & 0x4000000000LL) == 0
           && ((v27 & 1) != 0 || (v27 & 0xFFFFFFFC) != 0);
        if (!v37) {
          _dispatch_abort(5301LL, v37, v10, v11, v12, v13, v14, v15);
        }
        if ((v27 & 0x2000000000LL) != 0) {
          _dispatch_event_loop_poke(a1, v27, a3 | 0x80000000, v11, v12, v13, v14, v15);
        }
        else {
          _dispatch_queue_wakeup_with_override_slow((uint64_t)a1, v27, a3);
        }
        return;
      }
    }

    if ((a3 & 1) == 0) {
      return;
    }
LABEL_93:
    _dispatch_release_2_tailcall(a1);
    return;
  }

  if ((v27 & 0x4000000000LL) != 0) {
    _dispatch_abort(1442LL, (v27 & 0x4000000000LL) == 0, v10, v11, v12, v13, v14, v15);
  }
  if ((v29 & 1) != 0 || (v27 & 1) != 0 || (v29 & 2) == 0)
  {
    _dispatch_event_loop_end_ownership(a1, v29, v27, a3, v12, v13, v14, v15);
    return;
  }

  _dispatch_event_loop_assert_not_owned((uint64_t)a1);
  if ((a3 & 1) != 0) {
    goto LABEL_93;
  }
}

void _dispatch_lane_wakeup( uint64_t a1, unsigned int a2, unsigned int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if ((a3 & 4) != 0) {
    _dispatch_lane_barrier_complete(a1, a2, a3, a4, a5, a6, a7, a8);
  }
  else {
    _dispatch_queue_wakeup((_DWORD *)a1, a2, a3, *(void *)(a1 + 48) != 0LL, a5, a6, a7, a8);
  }
}

void _dispatch_lane_barrier_complete( uint64_t a1, unsigned int a2, unsigned int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10 = 0LL;
  if (*(void *)(a1 + 48) && (*(void *)(a1 + 56) & 0xFF80000000000000LL) == 0)
  {
    BOOL v16 = *(_DWORD **)(a1 + 104);
    if (!v16) {
      BOOL v16 = (_DWORD *)_dispatch_wait_for_enqueuer((unint64_t *)(a1 + 104), a1 + 48);
    }
    char v8 = 1;
    if (*(_WORD *)(a1 + 80) != 1)
    {
      if (*(void *)v16 > 0xFFFuLL) {
        BOOL v15 = (*(void *)(*(void *)v16 + 16LL) & 0xF0LL) == 0x10 && (v16[20] & 0x80000) != 0;
      }
      else {
        BOOL v15 = (*(void *)v16 & 2LL) != 0;
      }
      char v8 = v15;
    }

    if ((v8 & 1) != 0)
    {
      if (*(void *)v16 <= 0xFFFuLL && (*(void *)v16 & 0x81LL) != 0)
      {
        _dispatch_lane_drain_barrier_waiter(a1, (uint64_t)v16, a3, 0LL);
        return;
      }
    }

    else if (*(unsigned __int16 *)(a1 + 80) > 1u)
    {
      if (*(void *)v16 > 0xFFFuLL) {
        BOOL v14 = (*(void *)(*(void *)v16 + 16LL) & 0xF0LL) == 0x10 && (v16[20] & 0x80000) != 0;
      }
      else {
        BOOL v14 = (*(void *)v16 & 2LL) != 0;
      }
      if (!v14)
      {
        _dispatch_lane_drain_non_barriers(a1, (uint64_t)v16, a3, a4, a5, a6, a7, a8);
        return;
      }
    }

    if ((a3 & 1) == 0)
    {
      _dispatch_retain_2(a1);
      a3 |= 1u;
    }

    uint64_t v10 = (uint64_t (***)())(&dword_0 + 1);
  }

  _dispatch_lane_class_barrier_complete( (unsigned int *)a1,  a2,  a3,  v10,  ((unint64_t)*(unsigned __int16 *)(a1 + 80) << 41) + 0x40000000000000LL);
}

void _dispatch_lane_push( uint64_t a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v14 = 0;
  if (*a2 <= 0xFFFuLL && (*a2 & 0x81LL) != 0)
  {
    _dispatch_lane_push_waiter((unsigned int *)a1, (unint64_t)a2, a3);
  }

  else
  {
    if (*(_DWORD *)(a1 + 8) == 0x7FFFFFFF) {
      _dispatch_abort(5669LL, *(_DWORD *)(a1 + 8) != 0x7FFFFFFF, a3, a4, a5, a6, a7, a8);
    }
    else {
      unsigned int v18 = a3;
    }
    a2[2] = 0LL;
    _dispatch_thread_setspecific(122LL, a1 + 48);
    uint64_t v11 = (unint64_t *)(a1 + 48);
    unint64_t v12 = *(void *)(a1 + 48);
    do
    {
      unint64_t v8 = v12;
      do
        unint64_t v9 = __ldaxr(v11);
      while (v9 == v12 && __stlxr((unint64_t)a2, v11));
      unint64_t v12 = v9;
    }

    while (v9 != v8);
    unint64_t v13 = v9;
    if (v9)
    {
      unsigned int v19 = (((unint64_t)*(unsigned int *)(a1 + 60) << 32) & 0x700000000LL) >> 32;
      BOOL v10 = 1;
      if (v19) {
        BOOL v10 = v19 < v18;
      }
      if (v10)
      {
        _dispatch_retain_2_unsafe(a1);
        unsigned int v14 = 1;
      }
    }

    else
    {
      _dispatch_retain_2_unsafe(a1);
      unsigned int v14 = 3;
    }

    if (v13) {
      *(void *)(v13 + 16) = a2;
    }
    else {
      *(void *)(a1 + 104) = a2;
    }
    _dispatch_thread_setspecific(122LL, 0LL);
    if (v14) {
      (*(void (**)(uint64_t, void, void))(*(void *)a1 + 64LL))(a1, v18, v14);
    }
  }

void _dispatch_lane_push_waiter(unsigned int *a1, unint64_t a2, unsigned int a3)
{
  if (*(void *)(a2 + 48) != -4LL) {
    a3 = 0;
  }
  *(void *)(a2 + 16) = 0LL;
  _dispatch_thread_setspecific(122LL, (uint64_t)(a1 + 12));
  unint64_t v20 = (unint64_t *)(a1 + 12);
  unint64_t v21 = *((void *)a1 + 6);
  do
  {
    unint64_t v3 = v21;
    do
      unint64_t v4 = __ldaxr(v20);
    while (v4 == v21 && __stlxr(a2, v20));
    unint64_t v21 = v4;
  }

  while (v4 != v3);
  unint64_t v43 = v4;
  if (v4) {
    *(void *)(v4 + 16) = a2;
  }
  else {
    *((void *)a1 + 13) = a2;
  }
  _dispatch_thread_setspecific(122LL, 0LL);
  if (!v43)
  {
    if ((a1[20] & 0x40000) == 0 || (a1[20] & 0x1000000) != 0)
    {
      if ((*(void *)a2 & 0x80LL) != 0)
      {
        char v19 = 1;
        if ((a1[20] & 0x1000000) == 0)
        {
          char v18 = 0;
          if ((*((void *)a1 + 7) & 0x3000000000LL) != 0)
          {
            BOOL v17 = 0;
            char v18 = !v17;
          }

          char v19 = v18;
        }

        char v46 = v19 & 1;
      }

      else
      {
        char v46 = 0;
      }
    }

    else
    {
      char v46 = 1;
    }

    if ((v46 & 1) != 0)
    {
      *(void *)a2 &= ~0x80uLL;
      *(void *)(a2 + 56) = a1;
      (*(void (**)(unsigned int *, void, uint64_t))(*(void *)a1 + 64LL))(a1, a3, 2LL);
      return;
    }

    uint64_t v27 = (uint64_t)(*((unsigned __int16 *)a1 + 40) - 1) << 41;
    unint64_t v26 = (unint64_t)_dispatch_thread_getspecific(3uLL) & 0xFFFFFFFC | 0x60000000000002LL;
    BOOL v24 = (unint64_t *)(a1 + 14);
    do
    {
      if (_os_atomic_mo_has_acquire(3)) {
        unint64_t v5 = __ldaxr(v24);
      }
      else {
        unint64_t v5 = __ldxr(v24);
      }
      unint64_t v29 = v5;
      unint64_t v36 = v5;
      unint64_t v35 = (unint64_t)a3 << 32;
      if ((v5 & 0x700000000LL) < v35)
      {
        unint64_t v36 = v5 & 0xFFFFFFF8FFFFFFFFLL | v35;
        if (v5 & 0x1000000000LL | v35 & 0x1000000000LL) {
          v36 |= 0x800000000uLL;
        }
      }

      uint64_t v28 = v36 | 0x8000000000LL;
      BOOL v16 = 1;
      if ((v5 & 0xFFFFFFFC) == 0) {
        BOOL v16 = v5 >= 0x20000000000000LL;
      }
      if (!v16
        && ((v5 & 0x2000000000LL) == 0 || (v5 & 0x4000000001LL) == 0)
        && ((v5 & 0x10000000000LL) != 0 || (unint64_t)(v28 + v27) < 0x20000000000000LL))
      {
        uint64_t v28 = v36 & 0x7700000001LL | v26;
      }

      if (_os_atomic_mo_has_release(3)) {
        BOOL v25 = __stlxr(v28, v24) == 0;
      }
      else {
        BOOL v25 = __stxr(v28, v24) == 0;
      }
    }

    while (!v25);
    if ((v29 & 0x2000000000LL) != 0 && *(void *)(a2 + 48) != -4LL)
    {
      int v15 = *(_DWORD *)(a2 + 100);
      *(_BYTE *)(a2 + 106) = *(_BYTE *)(a2 + 106) & 0xFB | (4 * (v15 == _dispatch_thread_getspecific(3uLL)));
    }

    if (((v29 ^ v28) & 0x40000000000000LL) != 0)
    {
      if ((*(_BYTE *)(a2 + 106) & 4) != 0 && *((void *)a1 + 13) == a2)
      {
        *(_BYTE *)(a2 + 106) = *(_BYTE *)(a2 + 106) & 0xF7 | 8;
        if ((*(void *)a2 & 0x80LL) != 0) {
          *(void *)(a2 + 56) = a1;
        }
        uint64_t v42 = *(void *)(a2 + 16);
        *((void *)a1 + 13) = v42;
        if (!v42)
        {
          BOOL v40 = (unint64_t *)(a1 + 12);
          while (1)
          {
            unint64_t v12 = _os_atomic_mo_has_acquire(3) ? __ldaxr(v40) : __ldxr(v40);
            if (a2 != (v12 & 0xFFFFFFFFFFFFFFF8LL)) {
              break;
            }
            if (_os_atomic_mo_has_release(3)) {
              BOOL v41 = __stlxr(0LL, v40) == 0;
            }
            else {
              BOOL v41 = __stxr(0LL, v40) == 0;
            }
            if (v41) {
              return;
            }
          }

          __clrex();
          uint64_t v39 = *(void *)(a2 + 16);
          if (!v39) {
            uint64_t v39 = _dispatch_wait_for_enqueuer((unint64_t *)(a2 + 16), (uint64_t)(a1 + 12));
          }
          *((void *)a1 + 13) = v39;
        }
      }

      else
      {
        _dispatch_lane_barrier_complete((uint64_t)a1, a3, 0, v7, v8, v9, v10, v11);
      }

      return;
    }

    if (((v29 ^ v28) & 0x700000000LL) == 0) {
      return;
    }
    if ((v28 & 0xFF80000000000000LL) != 0 || (v28 & 0x4000000000LL) != 0) {
      BOOL v45 = 0;
    }
    else {
      BOOL v45 = (v28 & 1) != 0 || (v28 & 0x2000000000LL) == 0 && (v28 & 0xFFFFFFFC) != 0;
    }
    if (!v45) {
      return;
    }
    BOOL v37 = (v28 & 0xFF80000000000000LL) == 0
       && (v28 & 0x4000000000LL) == 0
       && ((v28 & 1) != 0 || (v28 & 0xFFFFFFFC) != 0);
    if (!v37) {
      _dispatch_abort(5301LL, v37, v6, v7, v8, v9, v10, v11);
    }
    if ((v28 & 0x2000000000LL) == 0)
    {
      _dispatch_queue_wakeup_with_override_slow((uint64_t)a1, v28, 0);
      return;
    }

LABEL_87:
    _dispatch_event_loop_poke(a1, v28, 0x80000000LL, v7, v8, v9, v10, v11);
    return;
  }

  if (a3)
  {
    BOOL v22 = (unint64_t *)(a1 + 14);
    do
    {
      if (_os_atomic_mo_has_acquire(0)) {
        unint64_t v13 = __ldaxr(v22);
      }
      else {
        unint64_t v13 = __ldxr(v22);
      }
      unint64_t v34 = v13;
      unint64_t v33 = (unint64_t)a3 << 32;
      if ((v13 & 0x700000000LL) < v33)
      {
        unint64_t v34 = v13 & 0xFFFFFFF8FFFFFFFFLL | v33;
        if (v13 & 0x1000000000LL | v33 & 0x1000000000LL) {
          v34 |= 0x800000000uLL;
        }
      }

      uint64_t v28 = v34;
      if (v13 == v34)
      {
        __clrex();
        return;
      }

      if (_os_atomic_mo_has_release(0)) {
        BOOL v23 = __stlxr(v34, v22) == 0;
      }
      else {
        BOOL v23 = __stxr(v34, v22) == 0;
      }
    }

    while (!v23);
    if ((v34 & 0xFF80000000000000LL) != 0 || (v34 & 0x4000000000LL) != 0) {
      BOOL v44 = 0;
    }
    else {
      BOOL v44 = (v34 & 1) != 0 || (v34 & 0x2000000000LL) == 0 && (v34 & 0xFFFFFFFC) != 0;
    }
    if (v44)
    {
      BOOL v38 = (v34 & 0xFF80000000000000LL) == 0
         && (v34 & 0x4000000000LL) == 0
         && ((v34 & 1) != 0 || (v34 & 0xFFFFFFFC) != 0);
      if (!v38) {
        _dispatch_abort(5301LL, v38, v14, v7, v8, v9, v10, v11);
      }
      if ((v34 & 0x2000000000LL) == 0)
      {
        _dispatch_queue_wakeup_with_override_slow((uint64_t)a1, v34, 0);
        return;
      }

      goto LABEL_87;
    }
  }

void _dispatch_lane_concurrent_push( uint64_t a1, _DWORD *a2, unsigned int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  char v12 = 0;
  if ((*(_BYTE *)(a1 + 87) & 8) != 0)
  {
    if (*(void *)a2 >= 0x1000uLL)
    {
      char v11 = 1;
      if (*(void *)(*(void *)a2 + 16LL) != 1LL)
      {
        BOOL is_timer = 0;
        if (*(_BYTE *)(*(void *)a2 + 16LL) == 19LL) {
          BOOL is_timer = _dispatch_source_is_timer((uint64_t)a2);
        }
        char v11 = is_timer;
      }

      char v17 = v11 & 1;
    }

    else
    {
      char v17 = 1;
    }

    char v12 = v17 ^ 1;
  }

  if ((v12 & 1) != 0)
  {
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Cannot target the cooperative root queue - not implemented";
    qword_E4DA8 = (uint64_t)a2;
    __break(1u);
    JUMPOUT(0x369ECLL);
  }

  if (*(void *)(a1 + 48)) {
    goto LABEL_39;
  }
  if (*(void *)a2 < 0x1000uLL && (*(void *)a2 & 0x81LL) != 0) {
    goto LABEL_39;
  }
  if (*(void *)a2 > 0xFFFuLL) {
    BOOL v18 = (*(void *)(*(void *)a2 + 16LL) & 0xF0LL) == 0x10 && (a2[20] & 0x80000) != 0;
  }
  else {
    BOOL v18 = (*a2 & 2) != 0;
  }
  if (v18) {
    goto LABEL_39;
  }
  char v19 = (unint64_t *)(a1 + 56);
  do
  {
    if (_os_atomic_mo_has_acquire(2)) {
      unint64_t v8 = __ldaxr(v19);
    }
    else {
      unint64_t v8 = __ldxr(v19);
    }
    char v9 = 1;
    if (!(v8 >> 53))
    {
      char v9 = 1;
      if ((v8 & 0x8000000000LL) == 0) {
        char v9 = BYTE5(v8) & 1;
      }
    }

    if ((v9 & 1) != 0)
    {
      __clrex();
      char v22 = 0;
      goto LABEL_37;
    }

    unint64_t v21 = v8 + 0x20000000000LL;
    if (_os_atomic_mo_has_release(2)) {
      BOOL v20 = __stlxr(v21, v19) == 0;
    }
    else {
      BOOL v20 = __stxr(v21, v19) == 0;
    }
  }

  while (!v20);
  char v22 = 1;
LABEL_37:
  if (v22 != 1) {
LABEL_39:
  }
    _dispatch_lane_push(a1, a2, a3, a4, a5, a6, a7, a8);
  else {
    _dispatch_continuation_redirect_push(a1, a2, a3);
  }
}

uint64_t _dispatch_continuation_redirect_push(uint64_t a1, void *a2, unsigned int a3)
{
  unint64_t v8 = a2;
  BOOL v4 = 0;
  if (*a2 > 0xFFFuLL) {
    BOOL v4 = *(void *)(*a2 + 16LL) == 256LL;
  }
  if (!v4)
  {
    char v11 = _dispatch_thread_getspecific(0x16uLL);
    if (v11)
    {
      _dispatch_thread_setspecific(22LL, v11[2]);
      uint64_t v10 = v11;
    }

    else
    {
      uint64_t v10 = (void *)_dispatch_continuation_alloc_from_heap();
    }

    _OWORD v8[2] = 0LL;
    void *v10 = &unk_E0C98;
    v10[4] = 0LL;
    v10[5] = (*(_DWORD *)(a1 + 80) & 0x30000u) << 8;
    v10[6] = a1;
    v10[7] = v8;
    v10[3] = -1LL;
    v10[1] = -1LL;
    _dispatch_retain_2(a1);
    unint64_t v8 = v10;
  }

  else if (!a2[5])
  {
    a2[5] = (*(_DWORD *)(a1 + 80) & 0x30000u) << 8;
  }

  unint64_t v5 = *(_DWORD **)(a1 + 24);
  if (!a3) {
    a3 = (v5[21] & 0xF00u) >> 8;
  }
  return (*(uint64_t (**)(_DWORD *, void *, void))(*(void *)v5 + 72LL))(v5, v8, a3);
}

uint64_t dispatch_async_swift_job(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v4 = *(void *)(*(void *)a2 + 16LL);
  if (v4 != 1)
  {
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Used Swift only SPI to enqueue non-Swift runtime objects into dispatch";
    qword_E4DA8 = v4;
    __break(1u);
    JUMPOUT(0x370ACLL);
  }

  switch(a3)
  {
    case 5:
      unsigned int v5 = 1;
      break;
    case 9:
      unsigned int v5 = 2;
      break;
    case 17:
      unsigned int v5 = 3;
      break;
    case 21:
      unsigned int v5 = 4;
      break;
    case 25:
      unsigned int v5 = 5;
      break;
    case 33:
      unsigned int v5 = 6;
      break;
    default:
      unsigned int v5 = 0;
      break;
  }

  return (*(uint64_t (**)(uint64_t, uint64_t, void))(*(void *)a1 + 72LL))(a1, a2, v5);
}

void _dispatch_channel_dispose(uint64_t a1, _BYTE *a2)
{
  *(void *)(a1 + 88) = 0LL;
  _dispatch_lane_class_dispose(a1, a2);
}

uint64_t _dispatch_channel_xref_dispose(uint64_t a1)
{
  if (*(void *)(*(void *)(a1 + 88) + 24LL) && (*(_DWORD *)(a1 + 80) & 0x10000000) == 0)
  {
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Release of a channel that has not been cancelled, but has a can"
                           "cel acknowledgement callback";
    qword_E4DA8 = a1;
    __break(1u);
    JUMPOUT(0x372ECLL);
  }

  return (*(uint64_t (**)(uint64_t, void, uint64_t))(*(void *)a1 + 64LL))(a1, 0LL, 2LL);
}

void _dispatch_channel_invoke( void *a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v61 = a1;
  uint64_t v60 = a2;
  unsigned int v59 = a3;
  int v58 = 8;
  unint64_t v57 = _dispatch_channel_invoke2;
  int v56 = a1;
  v55[8] = 0;
  *(void *)unint64_t v55 = (a3 & 1) == 0;
  uint64_t v54 = 0LL;
  if ((a3 & 3) == 0)
  {
    v56[2] = -1985229329LL;
    uint64_t v53 = _dispatch_thread_getspecific(0x14uLL);
    uint64_t v52 = v56;
    uint64_t v83 = v53;
    uint64_t v82 = v56;
    int v81 = 0;
    int v80 = 0;
    unint64_t v177 = v53;
    uint64_t v176 = v56;
  }

  v59 |= v58;
  if ((v59 & 2) != 0)
  {
    uint64_t v54 = 0x40020000000001LL;
    goto LABEL_54;
  }

  uint64_t v109 = v56;
  int v108 = v59;
  uint64_t v107 = 0LL;
  uint64_t v107 = (uint64_t)(*((unsigned __int16 *)v56 + 40) - 1) << 41;
  unsigned int v122 = _dispatch_thread_getspecific(3uLL);
  uint64_t v106 = v122 & 0xFFFFFFFC | 0x20000000000000LL;
  unint64_t v104 = 0LL;
  unint64_t v103 = 0LL;
  uint64_t v102 = 0LL;
  unint64_t v105 = 0xFFE00000FFFFFFFCLL;
  if ((v59 & 1) != 0)
  {
    v105 |= 0x4000000000uLL;
    uint64_t v102 = 0LL;
  }

  else if ((v108 & 0x40000) != 0)
  {
    uint64_t v102 = 0x4000000000LL;
  }

  else
  {
    v105 |= 0x4000000000uLL;
    uint64_t v102 = 1LL;
  }

  BOOL v115 = (v108 & 2) == 0;
  uint64_t v114 = 1323LL;
  if ((v108 & 2) != 0) {
    _dispatch_abort(v114, v115, v8, v9, v10, v11, v12, v13);
  }
  unsigned int v101 = 0;
  unsigned int v119 = _dispatch_thread_getspecific(0x19uLL);
  unsigned int v121 = v119 & 0xF00;
  unsigned int v118 = v121 >> 8;
  unsigned int v120 = v119 & 0xF000;
  unsigned int v117 = v120 >> 12;
  int v123 = v119 & 0xF0000;
  unsigned int v116 = (v119 & 0xF0000) >> 16;
  if (v121 >> 8 <= v120 >> 12) {
    unsigned int v47 = v117;
  }
  else {
    unsigned int v47 = v118;
  }
  if (v47 <= v116)
  {
    unsigned int v45 = v116;
  }

  else
  {
    if (v118 <= v117) {
      unsigned int v46 = v117;
    }
    else {
      unsigned int v46 = v118;
    }
    unsigned int v45 = v46;
  }

  unsigned int v101 = v45;
LABEL_22:
  BOOL v100 = 0;
  BOOL v99 = v109 + 7;
  while (1)
  {
    unint64_t v16 = _os_atomic_mo_has_acquire(2) ? __ldaxr(v99) : __ldxr(v99);
    unint64_t v104 = v16;
    unint64_t v103 = v16;
    if ((v16 & v105) != 0) {
      break;
    }
    unint64_t v154 = v104;
    unsigned int v153 = v101;
    unint64_t v156 = v104;
    BOOL v44 = 0;
    if ((v104 & 0x1000000000LL) != 0)
    {
      uint64_t v155 = v154 & 0x700000000LL;
      BOOL v44 = v153 < (v154 & 0x700000000LL) >> 32;
    }

    if (v44)
    {
      __clrex();
      unint64_t v158 = v104;
      uint64_t v159 = v104 & 0x700000000LL;
      unsigned int v157 = (v104 & 0x700000000LL) >> 32;
      unsigned int v163 = _dispatch_thread_getspecific(3uLL);
      unsigned int v162 = v157;
      if ((_dispatch_set_qos_class_enabled & 1) != 0)
      {
        unsigned int v165 = v162;
        uint64_t v164 = 0LL;
        if (v162) {
          uint64_t v164 = 1LL << (v165 + 7);
        }
        _pthread_workqueue_override_start_direct(v163, v164 | 0xFF);
      }

      unsigned int v161 = v157;
      unsigned int v160 = _dispatch_thread_getspecific(0x19uLL);
      int v166 = v160 & 0xF0000;
      if (v157 > (v160 & 0xF0000) >> 16)
      {
        unsigned int v160 = v160 & 0xFFF0FFFF | (v161 << 16);
        _dispatch_thread_setspecific(25LL, v160);
      }

      unsigned int v101 = v157;
      goto LABEL_22;
    }

    unint64_t v103 = v103 & 0x7700000001LL | v106;
    unint64_t v111 = v104;
    if ((v104 & 0x10000000000LL) != 0 || v104 + v107 < 0x20000000000000LL) {
      v103 |= 0x40000000000000uLL;
    }
LABEL_44:
    if (_os_atomic_mo_has_release(2)) {
      BOOL v100 = __stlxr(v103, v99) == 0;
    }
    else {
      BOOL v100 = __stxr(v103, v99) == 0;
    }
    if (v100) {
      goto LABEL_48;
    }
  }

  if (v102)
  {
    v103 ^= v102;
    goto LABEL_44;
  }

  __clrex();
LABEL_48:
  BOOL v98 = v100;
  BOOL v113 = (v104 & v102) == v102;
  uint64_t v112 = 1356LL;
  if ((v104 & v102) != v102) {
    _dispatch_abort(v112, v113, v14, v15, a5, a6, a7, a8);
  }
  if ((v104 & v105) != 0)
  {
    uint64_t v110 = 0LL;
  }

  else
  {
    v103 &= v102 | 0x60000000000000LL;
    v104 &= 0x3FFE0000000000uLL;
    uint64_t v110 = v103 - v104;
  }

  uint64_t v54 = v110;
LABEL_54:
  if (v54)
  {
    unsigned int v51 = 0;
    if ((v59 & 0x40000) != 0)
    {
      unsigned int v51 = 0;
    }

    else
    {
      int v87 = *((_DWORD *)v56 + 21);
      unsigned int v86 = _dispatch_thread_getspecific(0x19uLL);
      unsigned int v85 = v86;
      if (v86)
      {
        if ((v87 & 0xFFF) != 0)
        {
          v85 &= 0x880F0000;
          if ((v86 & 0xFFF) <= (v87 & 0xFFFu)) {
            int v43 = v87 & 0xFFF;
          }
          else {
            int v43 = v86 & 0xFFF;
          }
          v85 |= v43;
          unsigned int v89 = v87 & 0xF000;
          unsigned int v91 = v85 & 0xF00;
          if (v89 >> 12 <= v91 >> 8) {
            v87 &= 0x40000000u;
          }
          else {
            v87 &= 0x4400F000u;
          }
          v85 |= v87;
        }

        else
        {
          if ((v85 & 0xFFF) != 0) {
            v85 |= 0x40000000u;
          }
          unsigned int v88 = v87 & 0xF000;
          unsigned int v90 = v85 & 0xF00;
          if (v88 >> 12 > v90 >> 8) {
            unsigned int v85 = v85 & 0xFFFF0FFF | v87 & 0x400F000;
          }
        }
      }

      else
      {
        unsigned int v85 = v87 & 0xFFF0FFFF;
      }

      _dispatch_thread_setspecific(25LL, v85);
      unsigned int v51 = v86;
    }

    if ((v59 & 0x100000) != 0)
    {
      uint64_t v65 = v61;
      int v64 = 0;
      int v63 = *((_DWORD *)v61 + 20);
      int v64 = v63;
      int v62 = v63;
      if ((v63 & 0x400000) != 0)
      {
        uint64_t v77 = v61;
        int v76 = 0x400000;
        int v74 = -4194305;
        int v73 = -4194305;
        int v75 = -4194305;
        unsigned int v71 = 0;
        BOOL v41 = (unsigned int *)(v61 + 10);
        int v69 = -4194305;
        int v68 = -4194305;
        int v70 = -4194305;
        unsigned int v42 = *((_DWORD *)v61 + 20);
        do
        {
          unsigned int v17 = v42;
          do
            unsigned int v18 = __ldaxr(v41);
          while (v18 == v42 && __stlxr(v42 & 0xFFBFFFFF, v41));
          unsigned int v42 = v18;
        }

        while (v18 != v17);
        unsigned int v67 = v18;
        unsigned int v71 = v18;
        unsigned int v66 = v18;
        int v72 = v18 & v75;
      }
    }

    unsigned int v50 = v56;
    int v126 = v56;
    unsigned int v125 = v59;
    int v124 = 0;
    unsigned int v169 = v56;
    uint64_t v168 = 256LL;
    uint64_t v175 = 1LL;
    uint64_t v174 = 730LL;
    int v167 = 0;
    uint64_t v173 = v56;
    int v172 = 0;
    int v171 = *((_DWORD *)v56 + 20);
    int v172 = v171;
    int v170 = v171;
    int v167 = v171 & 0x30000;
    int v124 = (v171 & 0x30000) << 8;
    if (v124) {
      unsigned int v125 = v125 & 0xFCFFFFFF | v124;
    }
    unsigned int v59 = v125;
    do
    {
      if ((v59 & 2) != 0 && (v59 & 0x1000000) == 0) {
        _dispatch_last_resort_autorelease_pool_push(v60);
      }
      uint64_t v49 = v56;
      *(void *)&v55[1] = v57(v56, v60, v59, (uint64_t)&v54, a5, a6, a7, a8);
      if ((v59 & 2) != 0 && (v59 & 0x1000000) == 0)
      {
        __int128 v48 = 0uLL;
        uint64_t v93 = v56;
        uint64_t v92 = &v48;
        BOOL v97 = &v48;
        _dispatch_thread_getspecific_packed_pair(20LL, 21LL, &v48, v20, v21, v22, v23, v24);
        _dispatch_thread_setspecific_pair(20LL, (uint64_t)v93, 21LL, (uint64_t)v92, v25, v26, v27, v28);
        _dispatch_last_resort_autorelease_pool_pop(v60);
        unsigned int v94 = &v48;
        _dispatch_thread_setspecific_packed_pair(20LL, 21LL, &v48, v29, v30, v31, v32, v33);
      }

      BOOL v79 = *(void *)&v55[1] != 1LL;
      uint64_t v78 = 2018LL;
      if (*(void *)&v55[1] == 1LL) {
        _dispatch_abort(v78, v79, v19, v20, v21, v22, v23, v24);
      }
      BOOL v40 = 0;
      if (*(void *)&v55[1]) {
        BOOL v40 = *(void *)&v55[1] != -1LL;
      }
      if (v40) {
        break;
      }
      char v144 = v56;
      uint64_t v143 = v54;
      BOOL v142 = *(void *)&v55[1] == 0LL;
      unint64_t v141 = 0LL;
      unint64_t v140 = 0LL;
      int v139 = 0;
      int v138 = v56 + 7;
      do
      {
        if (_os_atomic_mo_has_acquire(3)) {
          unint64_t v34 = __ldaxr(v138);
        }
        else {
          unint64_t v34 = __ldxr(v138);
        }
        unint64_t v141 = v34;
        unint64_t v140 = (v34 - v143) & 0xFFFFFFF700000001LL;
        unint64_t v146 = v34;
        if ((v34 & 0xFF80000000000000LL) == 0)
        {
          unint64_t v147 = v141;
          if ((v141 & 0x8000000000LL) != 0)
          {
            __clrex();
            uint64_t v136 = 0x8000000000LL;
            uint64_t v135 = 0x8000000000LL;
            uint64_t v137 = 0x8000000000LL;
            unint64_t v133 = 0LL;
            BOOL v38 = v144 + 7;
            uint64_t v131 = 0x8000000000LL;
            uint64_t v130 = 0x8000000000LL;
            uint64_t v132 = 0x8000000000LL;
            unint64_t v39 = v144[7];
            do
            {
              unint64_t v35 = v39;
              do
                unint64_t v36 = __ldaxr(v38);
              while (v36 == v39 && __stlxr(v39 ^ 0x8000000000LL, v38));
              unint64_t v39 = v36;
            }

            while (v36 != v35);
            unint64_t v129 = v36;
            unint64_t v133 = v36;
            unint64_t v128 = v36;
            unint64_t v134 = v36 ^ v137;
            char v145 = 0;
            goto LABEL_119;
          }

          if (v142) {
            v140 &= 0xFFFFFFF8FFFFFFFFLL;
          }
          else {
            v140 |= 0x8000000000uLL;
          }
        }

        if (_os_atomic_mo_has_release(3))
        {
          LOBYTE(v139) = __stlxr(v140, v138) == 0;
          int v139 = v139;
        }

        else
        {
          LOBYTE(v139) = __stxr(v140, v138) == 0;
          int v139 = v139;
        }
      }

      while (!v139);
      int v127 = v139;
      unint64_t v149 = v141;
      unint64_t v151 = v141;
      BOOL v37 = 0;
      if ((v141 & 0x1000000000LL) != 0) {
        BOOL v37 = (v149 & 0x800000000LL) != 0;
      }
      if (v37)
      {
        uint64_t v148 = v141 & 0x700000000LL;
        uint64_t v150 = v141 & 0x700000000LL;
        LODWORD(v150) = _dispatch_thread_getspecific(0x19uLL);
        int v152 = v150 & 0xF0000;
        if (HIDWORD(v150) > (v150 & 0xF0000) >> 16)
        {
          LODWORD(v150) = v150 & 0xFFF0FFFF;
          LODWORD(v150) = v150 | (HIDWORD(v150) << 16);
          _dispatch_thread_setspecific(25LL, v150);
        }
      }

      char v145 = 1;
LABEL_119:
      if ((v145 & 1) != 0)
      {
        uint64_t v54 = 0LL;
        *(void *)&v55[1] = 0LL;
        break;
      }

      *(void *)&v55[1] = _dispatch_thread_getspecific(0x14uLL);
    }

    while ((*(void *)(**(void **)&v55[1] + 16LL) & 0x10000LL) != 0 || (v55[0] & 1) == 0);
    if ((v59 & 0x40000) == 0)
    {
      unsigned int v96 = v51;
      unsigned int v95 = 0;
      unsigned int v95 = _dispatch_thread_getspecific(0x19uLL);
      v96 &= 0xFFF0FFFF;
      v96 |= v95 & 0xF0000;
      _dispatch_thread_setspecific(25LL, v96);
    }
  }

  if ((v55[0] & 1) != 0)
  {
    unsigned int v84 = v56;
    uint64_t v178 = v56;
    unsigned int v183 = 772079660;
    unsigned int v182 = v56;
    uint64_t v181 = 0LL;
    uint64_t v180 = 0LL;
    uint64_t v179 = 0LL;
    if (MEMORY[0xFFFFFC100]) {
      kdebug_trace(v183, v182, v181, v180, v179);
    }
    unint64_t v184 = v84;
  }

  if (*(void *)&v55[1]) {
    _dispatch_queue_invoke_finish((unsigned int *)v56, v60, *(uint64_t (****)())&v55[1], v54);
  }
  else {
    _dispatch_release_2_tailcall((unsigned int *)v56);
  }
}

uint64_t _dispatch_channel_invoke2( void *a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v31 = a1;
  uint64_t v30 = a2;
  int v29 = a3;
  uint64_t v28 = a4;
  uint64_t v27 = 0LL;
  uint64_t v27 = a1[11];
  __int128 v21 = (unint64_t)a1;
  uint64_t v22 = 0LL;
  uint64_t v23 = a2;
  uint64_t v24 = a3 & 0xFFFDFFFF;
  uint64_t v25 = 0LL;
  __int128 v26 = 0uLL;
  int v72 = a1;
  uint64_t v71 = (uint64_t)&v21 + 8;
  int v74 = (char *)&v21 + 8;
  _dispatch_thread_getspecific_packed_pair(20LL, 21LL, (__int128 *)((char *)&v21 + 8), a4, a5, a6, a7, a8);
  _dispatch_thread_setspecific_pair(20LL, (uint64_t)v72, 21LL, v71, v8, v9, v10, v11);
  if ((_dispatch_channel_invoke_cancel_check((uint64_t)v31, (uint64_t)&v21, v27) & 1) != 0)
  {
    do
    {
      uint64_t v20 = (void *)v26;
      if (!(void)v26)
      {
        if (!v31[6]) {
          break;
        }
        BOOL v40 = v31;
        unint64_t v39 = v31 + 13;
        uint64_t v38 = 0LL;
        uint64_t v37 = 0LL;
        uint64_t v36 = v31[13];
        uint64_t v37 = v36;
        uint64_t v35 = v36;
        uint64_t v38 = v36;
        if (!v36) {
          uint64_t v38 = _dispatch_wait_for_enqueuer(v39, (uint64_t)(v40 + 6));
        }
        uint64_t v34 = v38;
        uint64_t v20 = (void *)v38;
      }

      int v75 = v20;
      uint64_t v77 = v20;
      if (*v20 >= 0x1000uLL) {
        char v76 = 0;
      }
      else {
        char v76 = *v75 & 1;
      }
      if (v76)
      {
        qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: sync waiter found on channel";
        __break(1u);
        JUMPOUT(0x38A3CLL);
      }

      uint64_t v32 = v20;
      int v70 = v20;
      if (*v20 < 0x1000uLL && (*v32 & 0x400) != 0)
      {
        *(void *)&__int128 v26 = v20;
        BYTE8(v26) = 0;
        uint64_t v19 = 0LL;
        if ((v24 & 0x1000000) != 0) {
          uint64_t v19 = _dispatch_autorelease_pool_push();
        }
        if ((*(unsigned int (**)(void *, __int128 *, void))(v27 + 16))(v31, &v21, v31[4]))
        {
          if ((BYTE8(v26) & 1) == 0)
          {
            qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Channel didn't call dispatch_channel_drain";
            __break(1u);
            JUMPOUT(0x38B24LL);
          }
        }

        else
        {
          uint64_t v25 = -1LL;
        }

        if (v19) {
          _dispatch_autorelease_pool_pop(v19);
        }
      }

      else
      {
        int v68 = v31;
        unsigned int v67 = v20;
        unsigned int v66 = v20;
        uint64_t v65 = 0LL;
        unint64_t v64 = 0LL;
        unint64_t v63 = 0LL;
        uint64_t v62 = 0LL;
        uint64_t v61 = v20[2];
        uint64_t v62 = v61;
        uint64_t v60 = v61;
        uint64_t v65 = v61;
        uint64_t v59 = v61;
        uint64_t v58 = v61;
        v31[13] = v61;
        uint64_t v57 = v59;
        if (!v65)
        {
          uint64_t v54 = 0LL;
          uint64_t v55 = 0LL;
          int v56 = v68 + 6;
          BOOL v53 = 0;
          uint64_t v52 = v68 + 6;
          while (1)
          {
            unint64_t v17 = _os_atomic_mo_has_acquire(3) ? __ldaxr(v52) : __ldxr(v52);
            unint64_t v63 = v17;
            unint64_t v69 = v17;
            if (v66 != (void *)(v17 & 0xFFFFFFFFFFFFFFF8LL)) {
              break;
            }
            unint64_t v64 = 0LL;
            if (_os_atomic_mo_has_release(3)) {
              BOOL v53 = __stlxr(v64, v52) == 0;
            }
            else {
              BOOL v53 = __stxr(v64, v52) == 0;
            }
            if (v53) {
              goto LABEL_39;
            }
          }

          __clrex();
          unsigned int v51 = v66;
          uint64_t v50 = 0LL;
          uint64_t v49 = 0LL;
          uint64_t v48 = v66[2];
          uint64_t v49 = v48;
          uint64_t v47 = v48;
          uint64_t v50 = v48;
          if (!v48) {
            uint64_t v50 = _dispatch_wait_for_enqueuer(v51 + 2, (uint64_t)(v68 + 6));
          }
          uint64_t v46 = v50;
          uint64_t v65 = v50;
          uint64_t v45 = v50;
          uint64_t v44 = v50;
          v68[13] = v50;
          uint64_t v43 = v45;
LABEL_39:
          BOOL v42 = v53;
        }

        uint64_t v41 = v65;
        *(void *)&__int128 v26 = v65;
        _dispatch_continuation_pop_inline(v20, v30, v29, (uint64_t)v31);
      }
    }

    while (!v25);
  }

  int v73 = (char *)&v21 + 8;
  _dispatch_thread_setspecific_packed_pair(20LL, 21LL, (__int128 *)((char *)&v21 + 8), v12, v13, v14, v15, v16);
  return v25;
}

uint64_t dispatch_channel_foreach_work_item_peek_f( uint64_t result, uint64_t a2, uint64_t (*a3)(uint64_t, void))
{
  if ((*(_BYTE *)(result + 56) & 1) != 0)
  {
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Called peek after drain";
    __break(1u);
    JUMPOUT(0x38E84LL);
  }

  uint64_t v5 = *(void *)result;
  for (unsigned int i = *(void **)(result + 48); *i < 0x1000uLL && (*(_DWORD *)i & 0x400) != 0; unsigned int i = v3)
  {
    __n128 result = a3(a2, i[5]);
    if ((result & 1) == 0 || i == *(void **)(v5 + 48)) {
      break;
    }
    unint64_t v3 = (void *)i[2];
    if (!v3)
    {
      __n128 result = _dispatch_wait_for_enqueuer(i + 2, v5 + 48);
      unint64_t v3 = (void *)result;
    }
  }

  return result;
}

void dispatch_channel_drain_f( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v61 = a1;
  uint64_t v60 = a2;
  uint64_t v59 = (uint64_t (*)(uint64_t, void, uint64_t *))a3;
  uint64_t v58 = 0LL;
  uint64_t v58 = *(void **)a1;
  uint64_t v57 = 0LL;
  uint64_t v57 = v58[11];
  int v56 = 0LL;
  uint64_t v55 = 1028LL;
  uint64_t v54 = 0LL;
  if ((*(_BYTE *)(a1 + 56) & 1) != 0)
  {
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Called drain twice in the same invoke";
    __break(1u);
    JUMPOUT(0x39078LL);
  }

  *(_BYTE *)(v61 + 56) = 1;
  do
  {
    int v56 = *(void **)(v61 + 48);
    if (!v56)
    {
      if (!v58[6]) {
        break;
      }
      BOOL v113 = v58;
      uint64_t v112 = v58 + 13;
      uint64_t v111 = 0LL;
      uint64_t v110 = 0LL;
      uint64_t v109 = v58[13];
      uint64_t v110 = v109;
      uint64_t v108 = v109;
      uint64_t v111 = v109;
      if (!v109) {
        uint64_t v111 = _dispatch_wait_for_enqueuer(v112, (uint64_t)(v113 + 6));
      }
      uint64_t v107 = v111;
      int v56 = (void *)v111;
    }

    unint64_t v105 = v56;
    uint64_t v178 = v56;
    if (*v56 >= 0x1000uLL || (*v105 & 0x400) == 0) {
      break;
    }
    unint64_t v141 = v58;
    unint64_t v140 = v56;
    int v139 = v56;
    uint64_t v138 = 0LL;
    unint64_t v137 = 0LL;
    unint64_t v136 = 0LL;
    uint64_t v135 = 0LL;
    uint64_t v134 = v56[2];
    uint64_t v135 = v134;
    uint64_t v133 = v134;
    uint64_t v138 = v134;
    uint64_t v132 = v134;
    uint64_t v131 = v134;
    v58[13] = v134;
    uint64_t v130 = v132;
    if (!v138)
    {
      uint64_t v127 = 0LL;
      uint64_t v128 = 0LL;
      unint64_t v129 = v141 + 6;
      BOOL v126 = 0;
      unsigned int v125 = v141 + 6;
      while (1)
      {
        unint64_t v8 = _os_atomic_mo_has_acquire(3) ? __ldaxr(v125) : __ldxr(v125);
        unint64_t v136 = v8;
        unint64_t v177 = v8;
        if (v139 != (void *)(v8 & 0xFFFFFFFFFFFFFFF8LL)) {
          break;
        }
        unint64_t v137 = 0LL;
        if (_os_atomic_mo_has_release(3)) {
          BOOL v126 = __stlxr(v137, v125) == 0;
        }
        else {
          BOOL v126 = __stxr(v137, v125) == 0;
        }
        if (v126) {
          goto LABEL_26;
        }
      }

      __clrex();
      int v124 = v139;
      uint64_t v123 = 0LL;
      uint64_t v122 = 0LL;
      uint64_t v121 = v139[2];
      uint64_t v122 = v121;
      uint64_t v120 = v121;
      uint64_t v123 = v121;
      if (!v121) {
        uint64_t v123 = _dispatch_wait_for_enqueuer(v124 + 2, (uint64_t)(v141 + 6));
      }
      uint64_t v119 = v123;
      uint64_t v138 = v123;
      uint64_t v118 = v123;
      uint64_t v117 = v123;
      v141[13] = v123;
      uint64_t v116 = v118;
LABEL_26:
      BOOL v115 = v126;
    }

    uint64_t v114 = v138;
    *(void *)(v61 + 48) = v138;
    unsigned int v101 = v56;
    uint64_t v102 = v56;
    uint64_t v52 = (uint64_t)v56;
    __int16 v50 = v55;
    char v145 = v56;
    uint64_t v144 = v55;
    uint64_t v143 = 0LL;
    uint64_t v143 = (_DWORD *)v56[3];
    uint64_t v142 = v55 & 4;
    uint64_t v167 = 1LL;
    uint64_t v166 = 600LL;
    if ((v55 & 4) != 0) {
      v145[3] = -1LL;
    }
    if (v143 != (_DWORD *)-1LL)
    {
      int v160 = 771817480;
      uint64_t v159 = v143;
      unint64_t v158 = v145;
      unsigned int v157 = 0;
      if (v143) {
        unsigned int v45 = v159[8];
      }
      else {
        unsigned int v45 = 0;
      }
      unsigned int v157 = v45;
      unsigned int v165 = v160;
      uint64_t v164 = v45;
      unsigned int v163 = v158;
      uint64_t v162 = 0LL;
      uint64_t v161 = 0LL;
      if (MEMORY[0xFFFFFC100]) {
        kdebug_trace(v165, v164, v163, v162, v161);
      }
      _dispatch_thread_getspecific(0LL);
      _dispatch_log("%u\t%p\tvoucher[%p]: continuation[%p] adopt", v9, v10, v11, v12, v13, v14, v15, 607LL);
    }

    unint64_t v149 = v145[1];
    uint64_t v148 = (uint64_t)v143;
    uint64_t v147 = v142 | 2;
    uint64_t v146 = 0LL;
    if (v149 != -1LL)
    {
      unint64_t v202 = v149;
      uint64_t v201 = v147;
      unsigned int v200 = 0;
      unsigned int v200 = _dispatch_thread_getspecific(0x19uLL);
      uint64_t v199 = 0LL;
      unsigned int v208 = v200;
      unsigned int v209 = v200 & 0xF00;
      unsigned int v207 = v209 >> 8;
      uint64_t v206 = v200;
      if (v209 >> 8) {
        v206 |= 1LL << (v207 + 7);
      }
      uint64_t v199 = v206;
      uint64_t v210 = v206;
      unint64_t v198 = v206 & 0xFFFFFF00;
      char v197 = 0;
      LOBYTE(v44) = 1;
      if ((v201 & 1) == 0) {
        int v44 = (BYTE3(v202) >> 4) & 1;
      }
      char v197 = v44;
      unint64_t v204 = v202;
      v202 &= 0xFFFFFFuLL;
      if (v202)
      {
        if (v202 >= v198)
        {
          if ((v197 & 1) != 0 || (v200 & 0x44000000) != 0) {
            uint64_t v203 = v202;
          }
          else {
            uint64_t v203 = v199;
          }
        }

        else
        {
          uint64_t v203 = v199;
        }
      }

      else
      {
        unsigned int v205 = v200 & 0xF000;
        unsigned int v196 = v205 >> 12;
        if (v205 >> 12)
        {
          unsigned int v212 = v196;
          uint64_t v211 = 1LL << (v196 + 7);
          uint64_t v43 = v211 | 0xFF;
        }

        else
        {
          uint64_t v43 = v199;
        }

        uint64_t v203 = v43;
      }

      uint64_t v146 = v203;
    }

    uint64_t v153 = v146;
    uint64_t v152 = v148;
    uint64_t v151 = v147;
    uint64_t v182 = v146;
    BOOL v195 = v146 != -1;
    uint64_t v194 = 2395LL;
    if (v146 == -1) {
      _dispatch_abort(v194, v195, a3, a4, a5, a6, a7, a8);
    }
    if ((_dispatch_set_qos_class_enabled & 1) != 0)
    {
      uint64_t v193 = v182;
      uint64_t v192 = 4261412863LL;
      uint64_t v191 = 0LL;
      v182 &= 0xFFFFFFFF02FFFFFFLL;
      unint64_t v181 = 0LL;
      unint64_t v184 = 0LL;
      unint64_t v184 = _dispatch_thread_getspecific(4uLL);
      unint64_t v181 = (unint64_t)v184;
      uint64_t v180 = 0x1000000LL;
      uint64_t v179 = 2281701376LL;
      if ((v184 & 0x1000000) != 0)
      {
        if (v182)
        {
          uint64_t v42 = v182;
        }

        else
        {
          unint64_t v190 = v181;
          uint64_t v189 = v180;
          uint64_t v188 = 0LL;
          uint64_t v42 = v181 & (~v180 | 0xFFFFFF);
        }

        uint64_t v183 = v42;
      }

      else
      {
        unint64_t v187 = v181;
        uint64_t v186 = v179;
        uint64_t v185 = 0LL;
        v181 &= ~v179 | 0xFFFFFF;
        if (v182 == v181) {
          uint64_t v183 = 0LL;
        }
        else {
          uint64_t v183 = v182;
        }
      }
    }

    else
    {
      uint64_t v183 = 0LL;
    }

    uint64_t v153 = v183;
    if (v183) {
      goto LABEL_78;
    }
    if (v152 != -1)
    {
      uint64_t v41 = (void *)v152;
      if (v41 == _dispatch_thread_getspecific(0x1CuLL))
      {
        BOOL v150 = (v151 & 4) != 0;
        if ((v151 & 2) != 0)
        {
          if (v150 && v152)
          {
            object = (void *)v152;
            os_release((void *)v152);
          }

          uint64_t v152 = -1LL;
        }

        else if (!v150 && v152)
        {
          unint64_t v156 = (void *)v152;
          os_retain((void *)v152);
        }

        uint64_t v154 = v152;
        goto LABEL_79;
      }

LABEL_78:
      uint64_t v154 = _dispatch_set_priority_and_voucher_slow(v153, (_DWORD *)v152, v151);
      goto LABEL_79;
    }

    uint64_t v154 = -1LL;
LABEL_79:
    if ((v50 & 0x200) == 0)
    {
      BOOL v99 = v56;
      BOOL v100 = v56;
      int v171 = v58;
      int v170 = v56;
      int v169 = 0;
      int v168 = 0;
      v227 = v58;
      v226 = v56;
    }

    if ((v50 & 4) != 0)
    {
      uint64_t v174 = v52;
      uint64_t v173 = 0LL;
      uint64_t v173 = _dispatch_thread_getspecific(0x16uLL);
      int v172 = 0;
      if (v173) {
        int v40 = v173[2] + 1;
      }
      else {
        int v40 = 1;
      }
      int v172 = v40;
      if (v40 <= _dispatch_continuation_cache_limit)
      {
        *(void *)(v174 + 16) = v173;
        *(_DWORD *)(v174 + 8) = v172;
        _dispatch_thread_setspecific(22LL, v174);
        uint64_t v175 = 0LL;
      }

      else
      {
        uint64_t v175 = v174;
      }

      unsigned int v51 = (void *)v175;
    }

    else
    {
      unsigned int v51 = 0LL;
    }

    uint64_t v49 = 0LL;
    if ((*(_BYTE *)(v61 + 35) & 1) != 0) {
      uint64_t v49 = _dispatch_autorelease_pool_push();
    }
    BOOL v97 = v56;
    BOOL v98 = v56;
    char v53 = v59(v60, v56[5], &v54) ^ 1;
    if (v49) {
      _dispatch_autorelease_pool_pop(v49);
    }
    if ((v50 & 0x200) == 0)
    {
      uint64_t v176 = v52;
      uint64_t v228 = v52;
      unsigned int v233 = 772079660;
      uint64_t v232 = v52;
      uint64_t v231 = 0LL;
      uint64_t v230 = 0LL;
      uint64_t v229 = 0LL;
      if (MEMORY[0xFFFFFC100]) {
        kdebug_trace(v233, v232, v231, v230, v229);
      }
      uint64_t v234 = v176;
    }

    if (v51) {
      _dispatch_continuation_free_to_cache_limit(v51);
    }
  }

  while ((v53 & 1) == 0 && (_dispatch_channel_invoke_checks((uint64_t)v58, v61, v57) & 1) != 0);
  if (v54)
  {
    unsigned int v85 = 0LL;
    int v87 = 0LL;
    int v87 = _dispatch_thread_getspecific(0x16uLL);
    if (v87) {
      _dispatch_thread_setspecific(22LL, v87[2]);
    }
    unsigned int v85 = v87;
    if (v87) {
      unsigned int v86 = v85;
    }
    else {
      unsigned int v86 = (void *)_dispatch_continuation_alloc_from_heap();
    }
    unint64_t v48 = (unint64_t)v86;
    int v68 = v58;
    unsigned int v67 = v86;
    uint64_t v66 = v54;
    uint64_t v65 = 0LL;
    uint64_t v64 = 0LL;
    uint64_t v63 = v55;
    uint64_t v62 = 0LL;
    *unsigned int v86 = v55 | 0x100;
    v67[4] = v65;
    v67[5] = v66;
    if ((v64 & 0x40000000) == 0)
    {
      unint64_t v214 = 0LL;
      int v213 = 1;
      unint64_t v216 = 0LL;
      unint64_t v216 = (unint64_t)_dispatch_thread_getspecific(4uLL);
      unint64_t v217 = v216;
      unint64_t v214 = v216 & 0xFFFFFF;
      if ((v213 & 2) != 0 || (v221 = 5, uint64_t v220 = 4096LL, v214 <= 0x10FF))
      {
        uint64_t v215 = v214;
      }

      else
      {
        int v219 = 5;
        uint64_t v218 = 4096LL;
        uint64_t v215 = 4351LL;
      }

      uint64_t v62 = v215;
    }

    int v80 = v67;
    uint64_t v79 = v64;
    uint64_t v78 = 0LL;
    BOOL v104 = (int)v64 >= 0;
    uint64_t v103 = 583LL;
    if ((v79 & 0x40) == 0)
    {
      v224 = 0LL;
      v224 = _dispatch_thread_getspecific(0x1CuLL);
      if (v224)
      {
        v225 = v224;
        os_retain(v224);
      }

      uint64_t v78 = v224;
    }

    v80[3] = v78;
    _dispatch_thread_getspecific(0LL);
    _dispatch_log("%u\t%p\tvoucher[%p]: continuation[%p] set", v22, v23, v24, v25, v26, v27, v28, 589LL);
    uint64_t v29 = v80[3];
    int v84 = 771817476;
    uint64_t v83 = v29;
    uint64_t v82 = v80;
    if (v29 != -1)
    {
      unsigned int v81 = 0;
      unsigned int v39 = v83 ? *(_DWORD *)(v83 + 32) : 0;
      unsigned int v81 = v39;
      unsigned int v92 = v84;
      uint64_t v91 = v39;
      unsigned int v90 = v82;
      uint64_t v89 = 0LL;
      uint64_t v88 = 0LL;
      if (MEMORY[0xFFFFFC100]) {
        kdebug_trace(v92, v91, v90, v89, v88);
      }
    }

    uint64_t v77 = v68;
    char v76 = v67;
    unint64_t v75 = v62;
    uint64_t v74 = v64;
    unsigned int v73 = 0;
    int v72 = v68;
    if (v62)
    {
      BOOL v71 = (v74 & 0x20) != 0;
      BOOL v70 = 0;
      BOOL v70 = (*((_DWORD *)v72 + 21) & 0x40000000) != 0;
      BOOL v69 = 0;
      BOOL v69 = (*((_DWORD *)v72 + 21) & 0xFFF) != 0;
      if ((v74 & 0x20) != 0)
      {
        v75 |= 0x10000000uLL;
        unint64_t v222 = v75 >> 8;
        unsigned int v30 = v75 >> 8;
        unsigned int v31 = __clz(__rbit32(v30));
        if (v30) {
          unsigned int v32 = v31 + 1;
        }
        else {
          unsigned int v32 = 0;
        }
        unsigned int v73 = v32;
      }

      else if (v70 || !v69)
      {
        unint64_t v223 = v75 >> 8;
        unsigned int v33 = v75 >> 8;
        unsigned int v34 = __clz(__rbit32(v33));
        if (v33) {
          unsigned int v35 = v34 + 1;
        }
        else {
          unsigned int v35 = 0;
        }
        unsigned int v73 = v35;
      }

      else
      {
        unint64_t v75 = 0LL;
      }
    }

    v76[1] = v75;
    unint64_t v95 = v48;
    unint64_t v96 = v48;
    uint64_t v47 = *(void *)(v61 + 48);
    *(void *)(v48 + 16) = v47;
    BOOL v38 = 0;
    if (!v47)
    {
      uint64_t v36 = v58 + 6;
      do
        unint64_t v37 = __ldaxr(v36);
      while (!v37 && __stlxr(v48, v36));
      BOOL v38 = v37 != 0;
    }

    if (v38)
    {
      uint64_t v46 = v58[13];
      if (!v46) {
        uint64_t v46 = _dispatch_wait_for_enqueuer(v58 + 13, (uint64_t)(v58 + 6));
      }
      *(void *)(v48 + 16) = v46;
    }

    v58[13] = v48;
    unint64_t v93 = v48;
    unint64_t v94 = v48;
    *(void *)(v61 + 48) = v48;
  }

uint64_t _dispatch_channel_invoke_checks(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if ((_dispatch_channel_invoke_cancel_check(a1, a2, a3) & 1) != 0)
  {
    if (_dispatch_thread_getspecific(5uLL)) {
      _dispatch_return_to_kernel();
    }
    if ((*(_DWORD *)(a2 + 32) & 0x100000) != 0
      && (uint64_t v7 = (unsigned int *)_dispatch_thread_getspecific(0x1BuLL),
          (((unint64_t)v7[15] << 32) & 0x700000000LL) >> 32 > *((unsigned __int8 *)v7 + 100)))
    {
      *(void *)(a2 + 40) = *(void *)(a1 + 24);
      char v6 = 0;
    }

    else if (((unint64_t)_dispatch_thread_getspecific(0x78uLL) & 1) != 0)
    {
      *(void *)(a2 + 40) = *(void *)(a1 + 24);
      char v6 = 0;
    }

    else if ((*(void *)(a1 + 56) & 0xFF80000000000000LL) != 0)
    {
      *(void *)(a2 + 40) = *(void *)(a1 + 24);
      char v6 = 0;
    }

    else
    {
      char v6 = 1;
    }
  }

  else
  {
    char v6 = 0;
  }

  return v6 & 1;
}

uint64_t dispatch_channel_foreach_work_item_peek(uint64_t a1, uint64_t a2)
{
  unint64_t v2 = (uint64_t (*)(uint64_t, void))_Block_get_invoke_fn(a2);
  return dispatch_channel_foreach_work_item_peek_f(a1, a2, v2);
}

void dispatch_channel_drain(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = _Block_get_invoke_fn(a2);
  dispatch_channel_drain_f(a1, a2, v2, v3, v4, v5, v6, v7);
}

void _dispatch_channel_wakeup(uint64_t a1, unsigned int a2, unsigned int a3)
{
  BOOL v8 = 0LL;
  if ((((*(unsigned __int8 (**)(uint64_t, void))(*(void *)(a1 + 88) + 8LL))(a1, *(void *)(a1 + 32)) ^ 1) & 1) != 0)
  {
    _dispatch_queue_wakeup((_DWORD *)a1, a2, a3, -1LL, v3, v4, v5, v6);
  }

  else if (*(void *)(a1 + 48))
  {
    _dispatch_queue_wakeup((_DWORD *)a1, a2, a3, 1LL, v3, v4, v5, v6);
  }

  else
  {
    if ((*(_DWORD *)(a1 + 80) & 0x10000000) != 0) {
      BOOL v8 = ((*(_WORD *)(a1 + 116) >> 3) & 1) == 0;
    }
    _dispatch_queue_wakeup((_DWORD *)a1, a2, a3, v8, v3, v4, v5, v6);
  }

void *dispatch_channel_create( const char *a1, uint64_t (***a2)(), uint64_t a3, uint64_t *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v20 = a1;
  int v16 = 0x4000000;
  if (!*a4)
  {
    uint64_t v8 = *a4;
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Unsupported callbacks version";
    qword_E4DA8 = v8;
    __break(1u);
    JUMPOUT(0x3AC44LL);
  }

  if (a1)
  {
    uint64_t v15 = _dispatch_strdup_if_mutable(a1);
    if (v15 != v20)
    {
      int v16 = 69206016;
      uint64_t v20 = v15;
    }
  }

  if (a2) {
    _dispatch_retain((uint64_t)a2);
  }
  else {
    a2 = &off_E46C0;
  }
  uint64_t v14 = _dispatch_object_alloc((uint64_t)_OS_dispatch_channel_vtable, 0x78uLL, a3, (uint64_t)a4, a5, a6, a7, a8);
  _dispatch_queue_init((uint64_t)v14, v16, 1LL, 0x180000000000000LL, v9, v10, v11, v12);
  v14[9] = v20;
  v14[3] = a2;
  v14[11] = a4;
  v14[4] = a3;
  if (!a4[3])
  {
    *((_WORD *)v14 + 58) |= 8u;
    --*((_DWORD *)v14 + 2);
  }

  return v14;
}

void __spoils<X1,X2,X3,X4,X5,X6,X7,X8,X9,X10,X11,X12,X13,X14,X15,X16,X17,Q0,Q1,Q2,Q3,Q4,Q5,Q6,Q7,Q16,Q17,Q18,Q19,Q20,Q21,Q22,Q23,Q24,Q25,Q26,Q27,Q28,Q29,Q30,Q31> _dispatch_queue_init( uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if ((a4 & 0xFE7FFFCFFFFFFFFFLL) != 0) {
    _dispatch_abort(1223LL, (a4 & 0xFE7FFFCFFFFFFFFFLL) == 0, a3, a4, a5, a6, a7, a8);
  }
  if ((a4 & 0x180000000000000LL) != 0)
  {
    *(_DWORD *)(a1 + 8) += 2;
    if (*(_BYTE *)(*(void *)a1 + 16LL) == 19LL) {
      ++*(_DWORD *)(a1 + 8);
    }
  }

  *(void *)(a1 + 16) = -1985229329LL;
  *(_DWORD *)(a1 + 80) = a2 | (unsigned __int16)a3;
  *(void *)(a1 + 56) = ((4096LL - (unsigned __int16)a3) << 41) | a4;
  uint64_t v10 = _dispatch_queue_serial_numbers;
  do
  {
    uint64_t v8 = v10;
    do
      unint64_t v9 = __ldaxr((unint64_t *)&_dispatch_queue_serial_numbers);
    while (v9 == v10 && __stlxr(v10 + 1, (unint64_t *)&_dispatch_queue_serial_numbers));
    uint64_t v10 = v9;
  }

  while (v9 != v8);
  *(void *)(a1 + 64) = v9;
}

uint64_t dispatch_channel_enqueue(_DWORD *a1, uint64_t a2)
{
  int v16 = _dispatch_thread_getspecific(0x16uLL);
  if (!v16) {
    return _dispatch_channel_enqueue_slow(a1, a2);
  }
  _dispatch_thread_setspecific(22LL, v16[2]);
  *int v16 = 1284LL;
  v16[4] = 0LL;
  v16[5] = a2;
  unint64_t v20 = (unint64_t)_dispatch_thread_getspecific(4uLL) & 0xFFFFFF;
  if (v20 <= 0x10FF) {
    unint64_t v21 = v20;
  }
  else {
    unint64_t v21 = 4351LL;
  }
  uint64_t v22 = _dispatch_thread_getspecific(0x1CuLL);
  if (v22) {
    os_retain(v22);
  }
  v16[3] = v22;
  _dispatch_thread_getspecific(0LL);
  _dispatch_log("%u\t%p\tvoucher[%p]: continuation[%p] set", v3, v4, v5, v6, v7, v8, v9, 589LL);
  uint64_t v19 = v16[3];
  if (v19 != -1)
  {
    unsigned int v13 = v19 ? *(_DWORD *)(v19 + 32) : 0;
    if (MEMORY[0xFFFFFC100]) {
      kdebug_trace(771817476LL, v13, v16, 0LL, 0LL);
    }
  }

  unint64_t v18 = v21;
  unsigned int v17 = 0;
  if (v21)
  {
    if ((a1[21] & 0x40000000) != 0 || (a1[21] & 0xFFF) == 0)
    {
      unsigned int v10 = v21 >> 8;
      unsigned int v11 = __clz(__rbit32(v10));
      if (v10) {
        unsigned int v12 = v11 + 1;
      }
      else {
        unsigned int v12 = 0;
      }
      unsigned int v17 = v12;
    }

    else
    {
      unint64_t v18 = 0LL;
    }
  }

  v16[1] = v18;
  return (*(uint64_t (**)(_DWORD *, void *, void))(*(void *)a1 + 72LL))(a1, v16, v17);
}

uint64_t _dispatch_channel_enqueue_slow(_DWORD *a1, uint64_t a2)
{
  uint64_t v14 = (void *)_dispatch_continuation_alloc_from_heap();
  void *v14 = 1284LL;
  v14[4] = 0LL;
  v14[5] = a2;
  unint64_t v20 = (unint64_t)_dispatch_thread_getspecific(4uLL) & 0xFFFFFF;
  if (v20 <= 0x10FF) {
    unint64_t v21 = v20;
  }
  else {
    unint64_t v21 = 4351LL;
  }
  uint64_t v22 = _dispatch_thread_getspecific(0x1CuLL);
  if (v22) {
    os_retain(v22);
  }
  v14[3] = v22;
  _dispatch_thread_getspecific(0LL);
  _dispatch_log("%u\t%p\tvoucher[%p]: continuation[%p] set", v2, v3, v4, v5, v6, v7, v8, 589LL);
  uint64_t v19 = v14[3];
  if (v19 != -1)
  {
    unsigned int v13 = v19 ? *(_DWORD *)(v19 + 32) : 0;
    if (MEMORY[0xFFFFFC100]) {
      kdebug_trace(771817476LL, v13, v14, 0LL, 0LL);
    }
  }

  unint64_t v18 = v21;
  unsigned int v17 = 0;
  if (v21)
  {
    if ((a1[21] & 0x40000000) != 0 || (a1[21] & 0xFFF) == 0)
    {
      unsigned int v9 = v21 >> 8;
      unsigned int v10 = __clz(__rbit32(v9));
      if (v9) {
        unsigned int v11 = v10 + 1;
      }
      else {
        unsigned int v11 = 0;
      }
      unsigned int v17 = v11;
    }

    else
    {
      unint64_t v18 = 0LL;
    }
  }

  v14[1] = v18;
  return (*(uint64_t (**)(_DWORD *, void *, void))(*(void *)a1 + 72LL))(a1, v14, v17);
}

uint64_t dispatch_channel_wakeup(uint64_t a1, int a2)
{
  unint64_t v3 = (a2 - 5);
  if (v3 <= 0x1C) {
    __asm { BR              X8 }
  }

  return (*(uint64_t (**)(uint64_t, void, uint64_t))(*(void *)a1 + 64LL))(a1, 0LL, 2LL);
}

uint64_t _dispatch_mgr_queue_push(void *a1, void *a2)
{
  if (*a2 < 0x1000uLL && (*a2 & 0x81LL) != 0)
  {
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Waiter pushed onto manager";
    __break(1u);
    JUMPOUT(0x3BD28LL);
  }

  a2[2] = 0LL;
  _dispatch_thread_setspecific(122LL, (uint64_t)(a1 + 6));
  unsigned int v10 = a1 + 6;
  unint64_t v11 = a1[6];
  do
  {
    unint64_t v2 = v11;
    do
      unint64_t v3 = __ldaxr(v10);
    while (v3 == v11 && __stlxr((unint64_t)a2, v10));
    unint64_t v11 = v3;
  }

  while (v3 != v2);
  unint64_t v15 = v3;
  if (v3) {
    *(void *)(v3 + 16) = a2;
  }
  else {
    a1[13] = a2;
  }
  uint64_t result = _dispatch_thread_setspecific(122LL, 0LL);
  if (!v15)
  {
    uint64_t v8 = a1 + 7;
    unint64_t v9 = a1[7];
    do
    {
      unint64_t v5 = v9;
      do
        unint64_t v6 = __ldaxr(v8);
      while (v6 == v9 && __stlxr(v9 | 0x8000000000LL, v8));
      int v7 = v6;
      unint64_t v9 = v6;
    }

    while (v6 != v5);
    uint64_t result = (uint64_t)_dispatch_thread_getspecific(3uLL);
  }

  return result;
}

void _dispatch_mgr_queue_wakeup()
{
  qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: Don't try to wake up or override the manager";
  __break(1u);
}

void sub_3C07C()
{
}

void _dispatch_mgr_thread(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v10 = a1;
  uint64_t v9 = a2;
  int v8 = a3;
  if ((_dispatch_kevent_workqueue_enabled & 1) != 0)
  {
    qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: Manager queue invoked with kevent workqueue enabled";
    __break(1u);
    JUMPOUT(0x3C0E0LL);
  }

  int v7 = &_dispatch_mgr_q;
  unint64_t v11 = &_dispatch_mgr_q;
  _dispatch_thread_setspecific(20LL, (uint64_t)&_dispatch_mgr_q);
  _dispatch_mgr_priority_init();
  uint64_t v19 = &_dispatch_mgr_q;
  uint64_t v18 = 0LL;
  unint64_t v17 = 0LL;
  unsigned int v22 = _dispatch_thread_getspecific(3uLL);
  uint64_t v16 = v22 & 0xFFFFFFFC | 0x40020000000000LL;
  BOOL v15 = 0;
  uint64_t v14 = (unint64_t *)&qword_E4178;
  while (1)
  {
    if (_os_atomic_mo_has_acquire(2)) {
      unint64_t v3 = __ldaxr(v14);
    }
    else {
      unint64_t v3 = __ldxr(v14);
    }
    uint64_t v18 = v3;
    unint64_t v17 = v3;
    unint64_t v21 = v3;
    BOOL v5 = 1;
    if (!(v3 >> 53))
    {
      uint64_t v20 = v18;
      int v23 = v18;
      BOOL v5 = (v18 & 0xFFFFFFFC) != 0;
    }

    if (v5)
    {
      uint64_t v13 = v18;
      qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: Locking the manager should not fail";
      qword_E4DA8 = v18;
      __break(1u);
      JUMPOUT(0x3C240LL);
    }

    unint64_t v17 = v17 & 0x7700000001LL | v16;
    if (_os_atomic_mo_has_release(2)) {
      BOOL v15 = __stlxr(v17, v14) == 0;
    }
    else {
      BOOL v15 = __stxr(v17, v14) == 0;
    }
    if (v15)
    {
      BOOL v12 = v15;
      memset(v6, 0, 512);
      uint64_t v4 = pthread_self();
      *(void *)&v6[0] = pthread_get_stackaddr_np(v4);
      __memset_chk((char *)v6 + 8, 0LL, *(void *)&v6[0] - ((void)v6 + 8), -1LL);
      _dispatch_mgr_invoke();
    }
  }

void _dispatch_mgr_priority_init()
{
  unint64_t v11 = off_E40E0;
  __attr = (pthread_attr_t *)off_E40E0;
  sched_param v9 = 0LL;
  qos_class_t v8 = pthread_attr_getschedparam((const pthread_attr_t *)off_E40E0, &v9);
  uint64_t v13 = (int)v8;
  uint64_t v12 = 6262LL;
  if (v8) {
    _dispatch_bug(v12, v13, v0, v1, v2, v3, v4, v5);
  }
  __qos_class[1] = v8;
  __qos_class[0] = QOS_CLASS_UNSPECIFIED;
  pthread_attr_get_qos_class_np(__attr, __qos_class, 0LL);
  if (dword_E505C > __qos_class[0] && (_dispatch_set_qos_class_enabled & 1) != 0)
  {
    pthread_set_qos_class_self_np((qos_class_t)dword_E505C, 0);
    int v6 = _dispatch_mgr_sched_qos2prio(dword_E505C);
    if (v6 > v9.sched_priority) {
      v9.sched_priority = v6;
    }
  }

  if (_dispatch_mgr_sched > v9.sched_priority) {
    _dispatch_mgr_priority_apply();
  }
}

void _dispatch_mgr_invoke()
{
  __b[3] = -4LL;
  __b[4] = &v7;
  LODWORD(__b[5]) = 0x100000;
  WORD2(__b[5]) &= 0xFE00u;
  BYTE5(__b[5]) &= ~2u;
  BYTE5(__b[5]) &= ~4u;
  uint64_t v13 = __b;
  _dispatch_thread_setspecific(29LL, (uint64_t)__b);
  while (1)
  {
    _dispatch_mgr_queue_drain();
    if (byte_E4E16) {
      _dispatch_event_loop_drain_timers((uint64_t)&_dispatch_timers_heap, 9u, v0, v1, v2, v3, v4, v5);
    }
    uint64_t v12 = &_dispatch_mgr_q;
    uint64_t v9 = qword_E4170;
    uint64_t v10 = qword_E4170;
    uint64_t v8 = qword_E4170;
    uint64_t v11 = qword_E4170;
    _dispatch_event_loop_drain(qword_E4170 != 0);
  }

void _dispatch_kevent_workqueue_init()
{
  if (_dispatch_root_queues_pred != -1LL) {
    dispatch_once_f(&_dispatch_root_queues_pred, 0LL, (dispatch_function_t)_dispatch_root_queues_init_once);
  }
  if ((_dispatch_kevent_workqueue_enabled & 1) != 0)
  {
    if (_dispatch_mgr_sched_pred != -1LL) {
      dispatch_once_f(&_dispatch_mgr_sched_pred, 0LL, (dispatch_function_t)_dispatch_mgr_sched_init);
    }
    int v8 = _dispatch_mgr_sched;
    uint64_t v7 = 0LL;
    if (dword_E505C) {
      uint64_t v7 = _pthread_qos_class_encode(dword_E505C, 0LL, 0LL);
    }
    if (v8 > dword_E5060) {
      uint64_t v7 = v8 | 0x20000000LL;
    }
    if (v7)
    {
      int v6 = _pthread_workqueue_set_event_manager_priority(v7);
      if (v6) {
        _dispatch_bug(6510LL, v6, v0, v1, v2, v3, v4, v5);
      }
    }
  }

uint64_t _dispatch_mgr_sched_init(uint64_t a1)
{
  uint64_t v26 = a1;
  sched_param v25 = 0LL;
  uint64_t v24 = (pthread_attr_t *)off_E40E0;
  int v23 = pthread_attr_init((pthread_attr_t *)off_E40E0);
  uint64_t v32 = v23;
  uint64_t v31 = 6165LL;
  if (v23) {
    _dispatch_bug(v31, v32, v1, v2, v3, v4, v5, v6);
  }
  int v22 = pthread_attr_getschedpolicy(v24, &dword_E5064);
  uint64_t v30 = v22;
  uint64_t v29 = 6167LL;
  if (v22) {
    _dispatch_bug(v29, v30, v7, v8, v9, v10, v11, v12);
  }
  int v21 = pthread_attr_getschedparam(v24, &v25);
  uint64_t v28 = v21;
  uint64_t v27 = 6168LL;
  if (v21) {
    _dispatch_bug(v27, v28, v13, v14, v15, v16, v17, v18);
  }
  uint64_t result = qos_class_main();
  int v20 = result;
  if ((_DWORD)result == 21) {
    int v20 = 25;
  }
  if (v20)
  {
    dword_E505C = v20;
    uint64_t result = _dispatch_mgr_sched_qos2prio(v20);
    v25.sched_priority = result;
  }

  dword_E5060 = v25.sched_priority;
  _dispatch_mgr_sched = v25.sched_priority;
  return result;
}

void _dispatch_root_queue_poke( unsigned int *a1, unsigned int a2, unsigned int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*((void *)a1 + 6))
  {
    BOOL v10 = 1;
    if (*(void *)(*(void *)a1 + 16LL) != 328465LL) {
      BOOL v10 = *(void *)(*(void *)a1 + 16LL) == 330001LL;
    }
    if (!v10) {
      goto LABEL_9;
    }
    uint64_t v8 = a1 + 28;
    do
      unsigned int v9 = __ldaxr(v8);
    while (!v9 && __stlxr(a2, v8));
    if (!v9) {
LABEL_9:
    }
      _dispatch_root_queue_poke_slow((uint64_t (***)())a1, a2, a3, a4, a5, a6, a7, a8);
  }

void _dispatch_root_queue_poke_slow( uint64_t (***a1)(), signed int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v92 = a1;
  signed int v91 = a2;
  int v90 = a3;
  signed int v89 = a2;
  int v88 = 78;
  BOOL v104 = &_dispatch_root_queues_pred;
  uint64_t v103 = 0LL;
  dispatch_function_t v102 = (dispatch_function_t)_dispatch_root_queues_init_once;
  if (_dispatch_root_queues_pred != -1LL) {
    dispatch_once_f(v104, v103, v102);
  }
  int v101 = 3;
  BOOL v100 = v92;
  uint64_t v99 = v91;
  if ((*v92)[2] == (uint64_t (*)())((char *)&loc_50310 + 1))
  {
    int v113 = *((_DWORD *)v92 + 21);
    int v112 = 0;
    uint64_t v111 = 0LL;
    if ((v113 & 0x4000000) != 0)
    {
      uint64_t v111 = v113 & 0x8E000000 | 0xFFLL;
      int v112 = (unsigned __int16)(v113 & 0xF000) >> 12;
      BOOL v116 = v112 != 0;
      uint64_t v115 = 523LL;
      if (!v112) {
        _dispatch_abort(v115, v116, a3, a4, a5, a6, a7, a8);
      }
    }

    else
    {
      uint64_t v111 = v113 & 0x8E0000FF;
      int v112 = (unsigned __int16)(v113 & 0xF00) >> 8;
      if (!v112)
      {
        uint64_t v114 = v111;
LABEL_11:
        int v87 = _pthread_workqueue_addthreads(v89, v114);
        uint64_t v98 = v87;
        uint64_t v97 = 6840LL;
        if (v87) {
          _dispatch_bug(v97, v98, v8, v9, v10, v11, v12, v13);
        }
        int v86 = v87;
        return;
      }
    }

    uint64_t v114 = v111 | (1LL << (v112 + 7));
    goto LABEL_11;
  }

  if ((*v92)[2] == (uint64_t (*)())((char *)&loc_50910 + 1))
  {
    int v107 = *((_DWORD *)v92 + 21);
    int v106 = 0;
    uint64_t v105 = 0LL;
    if ((v107 & 0x4000000) != 0)
    {
      uint64_t v105 = v107 & 0x8E000000 | 0xFFLL;
      int v106 = (unsigned __int16)(v107 & 0xF000) >> 12;
      BOOL v110 = v106 != 0;
      uint64_t v109 = 523LL;
      if (!v106) {
        _dispatch_abort(v109, v110, a3, a4, a5, a6, a7, a8);
      }
    }

    else
    {
      uint64_t v105 = v107 & 0x8E0000FF;
      int v106 = (unsigned __int16)(v107 & 0xF00) >> 8;
      if (!v106)
      {
        uint64_t v108 = v105;
LABEL_22:
        int v85 = _pthread_workqueue_add_cooperativethreads(v89, v108);
        uint64_t v96 = v85;
        uint64_t v95 = 6848LL;
        if (v85) {
          _dispatch_bug(v95, v96, v14, v15, v16, v17, v18, v19);
        }
        int v84 = v85;
        return;
      }
    }

    uint64_t v108 = v105 | (1LL << (v106 + 7));
    goto LABEL_22;
  }

  uint64_t v83 = 0LL;
  uint64_t v83 = v92[4];
  if (v83[9])
  {
    while (dispatch_semaphore_signal((dispatch_semaphore_t)(v83 + 9)))
    {
      if (!--v89) {
        return;
      }
    }
  }

  BOOL v82 = 0;
  BOOL v82 = *((int *)v92 + 21) < 0;
  if (v82)
  {
    signed int v80 = v89;
    signed int v79 = v89;
    signed int v81 = v89;
    unsigned int v77 = 0;
    BOOL v38 = (unsigned int *)(v92 + 14);
    signed int v75 = v89;
    signed int v74 = v89;
    signed int v76 = v89;
    unsigned int v39 = *((_DWORD *)v92 + 28);
    do
    {
      unsigned int v20 = v39;
      do
        unsigned int v21 = __ldaxr(v38);
      while (v21 == v39 && __stlxr(v39 + v89, v38));
      unsigned int v39 = v21;
    }

    while (v21 != v20);
    unsigned int v73 = v21;
    unsigned int v77 = v21;
    unsigned int v72 = v21;
    unsigned int v78 = v21 + v81;
  }

  else
  {
    unsigned int v71 = 0;
    BOOL v70 = 0;
    int v22 = (unsigned int *)(v92 + 14);
    signed int v68 = v89;
    signed int v67 = v89;
    signed int v69 = v89;
    do
      unsigned int v23 = __ldaxr(v22);
    while (!v23 && __stlxr(v89, v22));
    if (v23) {
      unsigned int v71 = v23;
    }
    BOOL v66 = v23 == 0;
    BOOL v70 = v23 == 0;
    BOOL v65 = v70;
    if (v23) {
      return;
    }
  }

  signed int v64 = 0;
  signed int v63 = 0;
  int v62 = 0;
  signed int v61 = *((_DWORD *)v92 + 25);
  int v62 = v61;
  int v60 = v61;
  signed int v63 = v61;
  while (1)
  {
    if (v63 >= v90) {
      signed int v37 = v63 - v90;
    }
    else {
      signed int v37 = 0;
    }
    signed int v64 = v37;
    if (v89 > v37)
    {
      int v58 = v89 - v64;
      int v57 = v89 - v64;
      int v59 = v89 - v64;
      unsigned int v55 = 0;
      unsigned int v35 = (unsigned int *)(v92 + 14);
      int v53 = v89 - v64;
      int v52 = v89 - v64;
      int v54 = v89 - v64;
      unsigned int v36 = *((_DWORD *)v92 + 28);
      do
      {
        unsigned int v24 = v36;
        do
          unsigned int v25 = __ldaxr(v35);
        while (v25 == v36 && __stlxr(v36 - (v89 - v64), v35));
        unsigned int v36 = v25;
      }

      while (v25 != v24);
      unsigned int v51 = v25;
      unsigned int v55 = v25;
      unsigned int v50 = v25;
      unsigned int v56 = v25 - v59;
      signed int v89 = v64;
    }

    if (!v89) {
      break;
    }
    unsigned int v49 = v63;
    BOOL v48 = 0;
    uint64_t v26 = (unsigned int *)v92 + 25;
    int v46 = v63 - v89;
    int v45 = v63 - v89;
    int v47 = v63 - v89;
    do
      unsigned int v27 = __ldaxr(v26);
    while (v27 == v63 && __stlxr(v63 - v89, v26));
    BOOL v34 = v27 == v63;
    if (v27 != v63) {
      unsigned int v49 = v27;
    }
    BOOL v44 = v27 == v63;
    BOOL v48 = v27 == v63;
    signed int v63 = v49;
    int v43 = v34;
    if (v34)
    {
      uint64_t v42 = (pthread_attr_t *)v83;
      uint64_t v41 = 0LL;
      int v40 = (pthread_t *)&v41;
      if (v92 == &_dispatch_mgr_root_queue) {
        int v40 = (pthread_t *)_dispatch_mgr_root_queue_init();
      }
      do
      {
        _dispatch_retain((uint64_t)v92);
        while (1)
        {
          int v88 = pthread_create(v40, v42, (void *(__cdecl *)(void *))_dispatch_worker_thread, v92);
          if (!v88) {
            break;
          }
          if (v88 != 35)
          {
            uint64_t v94 = v88;
            uint64_t v93 = 6907LL;
            _dispatch_bug(6907LL, v88, v28, v29, v30, v31, v32, v33);
          }

          _dispatch_temporary_resource_shortage();
        }

        --v89;
      }

      while (v89);
      return;
    }
  }

void _dispatch_root_queue_poke_and_wakeup( uint64_t (***a1)(), signed int a2, unsigned int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  BOOL v10 = 1;
  if (!v10) {
    goto LABEL_16;
  }
  uint64_t v11 = (unsigned int *)(a1 + 14);
  do
  {
    if (_os_atomic_mo_has_acquire(3)) {
      unsigned int v8 = __ldaxr(v11);
    }
    else {
      unsigned int v8 = __ldxr(v11);
    }
    int v13 = v8;
    if (v8) {
      unsigned int v9 = v8;
    }
    else {
      unsigned int v9 = a2;
    }
    if (_os_atomic_mo_has_release(3)) {
      BOOL v12 = __stlxr(v9, v11) == 0;
    }
    else {
      BOOL v12 = __stxr(v9, v11) == 0;
    }
  }

  while (!v12);
  if (v13 <= 0) {
LABEL_16:
  }
    _dispatch_root_queue_poke_slow(a1, a2, a3, a4, a5, a6, a7, a8);
}

void _dispatch_root_queue_wakeup(unsigned int *a1, uint64_t a2, char a3)
{
  if ((a3 & 8) == 0)
  {
    uint64_t v3 = a1[21];
    qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: Don't try to wake up or override a root queue";
    qword_E4DA8 = v3;
    __break(1u);
    JUMPOUT(0x3D754LL);
  }

  if ((a3 & 1) != 0) {
    _dispatch_release_2_tailcall(a1);
  }
}

void _dispatch_root_queue_push(uint64_t a1, void *a2, unsigned int a3)
{
  uint64_t v30 = _dispatch_thread_getspecific(0x1DuLL);
  char v25 = 0;
  if (v30) {
    char v25 = v30[44];
  }
  if ((v25 & 1) == 0) {
    goto LABEL_11;
  }
  uint64_t v29 = (void *)*((void *)v30 + 1);
  unsigned int v28 = *(_DWORD *)(a1 + 84) & 0x80000000;
  BOOL v24 = 1;
  if (v29) {
    BOOL v24 = *(int *)(a1 + 84) < 0;
  }
  if (!v24) {
    goto LABEL_11;
  }
  uint64_t v27 = *(void *)v30;
  unsigned int v26 = *((_DWORD *)v30 + 4);
  *(void *)uint64_t v30 = a1;
  *((void *)v30 + 1) = a2;
  *((_DWORD *)v30 + 4) = a3;
  _dispatch_thread_getspecific(0LL);
  _dispatch_log("%u\t%p\tdeferring item %p, rq %p, qos %d", v3, v4, v5, v6, v7, v8, v9, 7572LL);
  if (v28) {
    v30[44] = 0;
  }
  if (v29)
  {
    a3 = v26;
    a1 = v27;
    a2 = v29;
LABEL_11:
    char v23 = 0;
    if ((*(_BYTE *)(a1 + 87) & 8) != 0)
    {
      if (*a2 >= 0x1000uLL)
      {
        char v22 = 1;
        if (*(void *)(*a2 + 16LL) != 1LL)
        {
          BOOL is_timer = 0;
          if (*(_BYTE *)(*a2 + 16LL) == 19LL) {
            BOOL is_timer = _dispatch_source_is_timer((uint64_t)a2);
          }
          char v22 = is_timer;
        }

        char v34 = v22 & 1;
      }

      else
      {
        char v34 = 1;
      }

      char v23 = v34 ^ 1;
    }

    if ((v23 & 1) != 0)
    {
      qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Cannot target the cooperative root queue - not implemented";
      qword_E4DA8 = (uint64_t)a2;
      __break(1u);
      JUMPOUT(0x3DA48LL);
    }

    unsigned int v36 = (*(_DWORD *)(a1 + 84) & 0xF000u) >> 12;
    if (v36)
    {
      BOOL v20 = 0;
      if (a3) {
        BOOL v20 = a3 != v36;
      }
      BOOL v37 = v20;
    }

    else
    {
      unsigned int v35 = (*(_DWORD *)(a1 + 84) & 0xF00u) >> 8;
      BOOL v19 = 0;
      if (v35) {
        BOOL v19 = a3 > v35;
      }
      BOOL v37 = v19;
    }

    if (v37)
    {
      _dispatch_root_queue_push_override(a1, a2, a3);
    }

    else
    {
      a2[2] = 0LL;
      _dispatch_thread_setspecific(122LL, a1 + 48);
      uint64_t v17 = (unint64_t *)(a1 + 48);
      unint64_t v18 = *(void *)(a1 + 48);
      do
      {
        unint64_t v10 = v18;
        do
          unint64_t v11 = __ldaxr(v17);
        while (v11 == v18 && __stlxr((unint64_t)a2, v17));
        unint64_t v18 = v11;
      }

      while (v11 != v10);
      unint64_t v38 = v11;
      if (v11) {
        *(void *)(v11 + 16) = a2;
      }
      else {
        *(void *)(a1 + 104) = a2;
      }
      _dispatch_thread_setspecific(122LL, 0LL);
      if (!v38) {
        _dispatch_root_queue_poke_and_wakeup((uint64_t (***)())a1, 1, 0, v12, v13, v14, v15, v16);
      }
    }
  }

void _dispatch_root_queue_push_override(uint64_t a1, void *a2, unsigned int a3)
{
  char v16 = 0;
  if ((*(_BYTE *)(a1 + 87) & 0x80) != 0)
  {
    char v16 = 2;
  }

  else if ((*(_BYTE *)(a1 + 87) & 8) != 0)
  {
    char v16 = 4;
  }

  BOOL v13 = 1;
  if (a3) {
    BOOL v13 = a3 > 6;
  }
  if (v13)
  {
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Corrupted priority";
    qword_E4DA8 = a3;
    __break(1u);
    JUMPOUT(0x3DE54LL);
  }

  int v22 = 0;
  if ((v16 & 2) != 0)
  {
    int v22 = 1;
  }

  else if ((v16 & 4) != 0)
  {
    int v22 = 2;
  }

  uint64_t v15 = &(&_dispatch_root_queues)[16 * (unint64_t)(3 * a3 + v22 - 3)];
  unint64_t v14 = (unint64_t)a2;
  BOOL v12 = 0;
  if (*a2 >= 0x1000uLL) {
    BOOL v12 = *(void *)(*a2 + 16LL) == 256LL;
  }
  if (v12)
  {
    a2[4] = a1;
  }

  else
  {
    BOOL v20 = _dispatch_thread_getspecific(0x16uLL);
    if (v20)
    {
      _dispatch_thread_setspecific(22LL, v20[2]);
      BOOL v19 = v20;
    }

    else
    {
      BOOL v19 = (void *)_dispatch_continuation_alloc_from_heap();
    }

    unint64_t v14 = (unint64_t)v19;
    *BOOL v19 = &unk_E0E20;
    v19[5] = v19;
    v19[7] = a1;
    v19[6] = a2;
    v19[1] = -1LL;
    v19[3] = -1LL;
  }

  *(void *)(v14 + 16) = 0LL;
  _dispatch_thread_setspecific(122LL, (uint64_t)(v15 + 6));
  unint64_t v10 = (unint64_t *)(v15 + 6);
  unint64_t v11 = v15[6];
  do
  {
    uint64_t v3 = v11;
    do
      unint64_t v4 = __ldaxr(v10);
    while ((uint64_t (**)())v4 == v11 && __stlxr(v14, v10));
    unint64_t v11 = (uint64_t (**)())v4;
  }

  while (v4 != (void)v3);
  unint64_t v21 = v4;
  if (v4) {
    *(void *)(v4 + 16) = v14;
  }
  else {
    v15[13] = (uint64_t (**)())v14;
  }
  _dispatch_thread_setspecific(122LL, 0LL);
  if (!v21) {
    _dispatch_root_queue_poke_and_wakeup(v15, 1, 0, v5, v6, v7, v8, v9);
  }
}

void *dispatch_pthread_root_queue_create( const char *a1, int a2, uint64_t a3, const void *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return _dispatch_pthread_root_queue_create(a1, a2, a3, a4, 0LL, a6, a7, a8);
}

void *_dispatch_pthread_root_queue_create( const char *a1, int a2, uint64_t a3, const void *a4, _OWORD *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v35 = a1;
  int v31 = 0;
  if (a2 < 0) {
    int v25 = (char)a2;
  }
  else {
    int v25 = 0;
  }
  if (a1)
  {
    uint64_t v30 = _dispatch_strdup_if_mutable(a1);
    if (v30 != v35)
    {
      int v31 = 0x200000;
      unsigned int v35 = v30;
    }
  }

  uint64_t v29 = _dispatch_object_alloc( (uint64_t)_OS_dispatch_queue_pthread_root_vtable,  0x140uLL,  a3,  (uint64_t)a4,  (uint64_t)a5,  a6,  a7,  a8);
  _dispatch_queue_init((uint64_t)v29, v31, 4095LL, 0LL, v8, v9, v10, v11);
  v29[9] = v35;
  v29[7] = 0x60000000000000LL;
  *((_DWORD *)v29 + 21) = 0x80000000;
  v29[4] = v29 + 15;
  unsigned int v28 = (pthread_attr_t *)(v29 + 15);
  _dispatch_root_queue_init_pthread_pool((uint64_t)v29, v25, 0x80000000);
  if (a3)
  {
    __memcpy_chk(v28, a3, 64LL, -1LL);
    _dispatch_mgr_priority_raise(v28);
  }

  else
  {
    int v27 = pthread_attr_init(v28);
    if (v27) {
      _dispatch_bug(7641LL, v27, v12, v13, v14, v15, v16, v17);
    }
  }

  int v26 = pthread_attr_setdetachstate(v28, 2);
  if (v26) {
    _dispatch_bug(7644LL, v26, v18, v19, v20, v21, v22, v23);
  }
  if (a4) {
    v29[23] = _dispatch_Block_copy(a4);
  }
  if (a5) {
    *(_OWORD *)(v29 + 33) = *a5;
  }
  _dispatch_object_debug((uint64_t)v29, "%s", v18, v19, v20, v21, v22, v23, (char)"_dispatch_pthread_root_queue_create");
  return v29;
}

void *_dispatch_pthread_root_queue_create_with_observer_hooks_4IOHID( const char *a1, int a2, uint64_t a3, uint64_t a4, const void *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!*(void *)a4 || !*(void *)(a4 + 8))
  {
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Invalid pthread root queue observer hooks";
    __break(1u);
    JUMPOUT(0x3E590LL);
  }

  return _dispatch_pthread_root_queue_create(a1, a2, a3, a5, (_OWORD *)a4, a6, a7, a8);
}

BOOL _dispatch_queue_is_exclusively_owned_by_current_thread_4IOHID(uint64_t a1)
{
  if (*(_WORD *)(a1 + 80) != 1)
  {
    uint64_t v1 = *(unsigned __int16 *)(a1 + 80);
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Invalid queue type";
    qword_E4DA8 = v1;
    __break(1u);
    JUMPOUT(0x3E620LL);
  }

  int v3 = *(void *)(a1 + 56);
  return ((v3 ^ _dispatch_thread_getspecific(3uLL)) & 0xFFFFFFFC) == 0;
}

void *dispatch_pthread_root_queue_copy_current()
{
  uint64_t v1 = _dispatch_thread_getspecific(0x14uLL);
  if (!v1) {
    return 0LL;
  }
  while (v1[3])
    uint64_t v1 = (void *)v1[3];
  if (*(void *)(*v1 + 16LL) != 328721LL) {
    return 0LL;
  }
  _os_object_retain_with_resurrect((uint64_t)v1);
  return v1;
}

void _dispatch_pthread_root_queue_dispose( void *a1, _BYTE *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = (pthread_attr_t *)a1[4];
  _dispatch_object_debug((uint64_t)a1, "%s", a3, a4, a5, a6, a7, a8, (char)"_dispatch_pthread_root_queue_dispose");
  if (MEMORY[0xFFFFFC100]) {
    kdebug_trace(772079624LL, a1[8], 0LL, 0LL, 0LL);
  }
  pthread_attr_destroy(v8);
  _dispatch_semaphore_dispose((semaphore_t *)v8[1].__opaque);
  if (v8[1].__sig) {
    _Block_release((const void *)v8[1].__sig);
  }
  a1[3] = &off_E4640;
  _dispatch_lane_class_dispose((uint64_t)a1, a2);
}

void _dispatch_runloop_queue_wakeup( uint64_t a1, unsigned int a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if ((*(_DWORD *)(a1 + 80) & 0x800000) != 0) {
    goto LABEL_2;
  }
  if ((a3 & 2) == 0) {
    goto LABEL_29;
  }
  uint64_t v14 = (unint64_t *)(a1 + 56);
  unint64_t v15 = *(void *)(a1 + 56);
  do
  {
    unint64_t v8 = v15;
    do
      unint64_t v9 = __ldaxr(v14);
    while (v9 == v15 && __stlxr(v15 | 0x8000000000LL, v14));
    unint64_t v15 = v9;
  }

  while (v9 != v8);
  if ((v9 & 0xFFFFFFFC) == 0)
  {
LABEL_2:
    _dispatch_lane_wakeup(a1, a2, a3, a4, a5, a6, a7, a8);
  }

  else
  {
LABEL_29:
    if (*(void *)(a1 + 48))
    {
      _dispatch_runloop_queue_poke((unint64_t *)a1, a2, a3);
    }

    else
    {
      uint64_t v12 = (unint64_t *)(a1 + 56);
      unint64_t v13 = *(void *)(a1 + 56);
      do
      {
        unint64_t v10 = v13;
        do
          unint64_t v11 = __ldaxr(v12);
        while (v11 == v13 && __stlxr(v13 & 0xFFFFFFF0FFFFFFFFLL, v12));
        unint64_t v13 = v11;
      }

      while (v11 != v10);
      unsigned int v16 = (v11 & 0x700000000LL) >> 32;
      if (v16)
      {
        int v18 = *(void *)(a1 + 56);
        if ((v18 & 0xFFFFFFFC) != 0) {
          unsigned int v19 = v18 | 3;
        }
        else {
          unsigned int v19 = 0;
        }
        if (*(void *)(a1 + 48)) {
          _dispatch_runloop_queue_poke((unint64_t *)a1, v16, a3);
        }
        if ((_dispatch_set_qos_class_enabled & 1) != 0) {
          _pthread_qos_override_end_direct(v19, a1);
        }
      }

      else if ((a3 & 1) != 0)
      {
        _dispatch_release_2_tailcall((unsigned int *)a1);
      }
    }
  }

void _dispatch_runloop_queue_poke(unint64_t *a1, unsigned int a2, char a3)
{
  if (*(void *)(*a1 + 16) == 394769LL && _dispatch_main_q_handle_pred != -1) {
    dispatch_once_f(&_dispatch_main_q_handle_pred, a1, (dispatch_function_t)_dispatch_runloop_queue_handle_init);
  }
  unsigned int v13 = a2;
  if (!a2) {
    unsigned int v13 = (*((_DWORD *)a1 + 21) & 0xF000u) >> 12;
  }
  if (v13 <= (*((_DWORD *)a1 + 21) & 0xF00u) >> 8) {
    unsigned int v4 = (*((_DWORD *)a1 + 21) & 0xF00u) >> 8;
  }
  else {
    unsigned int v4 = v13;
  }
  uint64_t v6 = a1 + 7;
  do
  {
    if (_os_atomic_mo_has_acquire(0)) {
      unint64_t v3 = __ldaxr(v6);
    }
    else {
      unint64_t v3 = __ldxr(v6);
    }
    unint64_t v8 = v3;
    unint64_t v12 = v3;
    if ((v3 & 0x700000000LL) < (unint64_t)v4 << 32)
    {
      unint64_t v12 = v3 & 0xFFFFFFF8FFFFFFFFLL | ((unint64_t)v4 << 32);
    }

    if (v3 == v12)
    {
      __clrex();
      goto LABEL_33;
    }

    if (_os_atomic_mo_has_release(0)) {
      BOOL v7 = __stlxr(v12, v6) == 0;
    }
    else {
      BOOL v7 = __stxr(v12, v6) == 0;
    }
  }

  while (!v7);
  unsigned int v5 = (*((_DWORD *)a1 + 21) & 0xF00u) >> 8;
  if (v4 > v5)
  {
    if ((v12 & 0xFFFFFFFC) != 0) {
      unsigned int v15 = v12 | 3;
    }
    else {
      unsigned int v15 = 0;
    }
    uint64_t v14 = 0LL;
    if (v4) {
      uint64_t v14 = 1LL << (v4 + 7);
    }
    if ((_dispatch_set_qos_class_enabled & 1) != 0) {
      _pthread_qos_override_start_direct(v15, v14 | 0xFF, a1);
    }
    if ((v8 & 0x700000000LL) >> 32 > v5 && (_dispatch_set_qos_class_enabled & 1) != 0) {
      _pthread_qos_override_end_direct(v15, a1);
    }
  }

LABEL_33:
  _dispatch_runloop_queue_class_poke((uint64_t)a1);
  if ((a3 & 1) != 0) {
    _dispatch_release_2_tailcall((unsigned int *)a1);
  }
}

void *_dispatch_runloop_root_queue_create_4CF(const char *a1, uint64_t a2)
{
  unsigned int v38 = _dispatch_thread_getspecific(4uLL);
  if (a2) {
    return 0LL;
  }
  BOOL v37 = _dispatch_object_alloc((uint64_t)_OS_dispatch_queue_runloop_vtable, 0x78uLL, v2, v3, v4, v5, v6, v7);
  _dispatch_queue_init((uint64_t)v37, 0x40000, 1LL, 0x1000000000LL, v8, v9, v10, v11);
  v37[3] = &off_E46C0;
  if (a1) {
    unsigned int v36 = a1;
  }
  else {
    unsigned int v36 = "runloop-queue";
  }
  v37[9] = v36;
  BOOL v35 = 0;
  if ((v38 & 0x22000000) == 0) {
    BOOL v35 = (v38 & 0x3F00) != 0;
  }
  if (v35)
  {
    if ((v38 & 0x20000000) != 0) {
      _dispatch_abort(458LL, (v38 & 0x20000000) == 0, v12, v13, v14, v15, v16, v17);
    }
    unsigned int v18 = (v38 & 0x3FFF00) >> 8;
    unsigned int v19 = __clz(__rbit32(v18));
    if (v18) {
      unsigned int v20 = v19 + 1;
    }
    else {
      unsigned int v20 = 0;
    }
    *((_DWORD *)v37 + 21) = v38 | (v20 << 8);
  }

  _dispatch_runloop_queue_handle_init(v37);
  if ((v37[10] & 0x40000) == 0) {
    _dispatch_abort(2140LL, (v37[10] & 0x40000) != 0, v21, v22, v23, v24, v25, v26);
  }
  if ((v37[10] & 0x1000000) != 0) {
    _dispatch_abort(2146LL, (v37[10] & 0x1000000) == 0, v21, v22, v23, v24, v25, v26);
  }
  uint64_t v42 = v37 + 7;
  do
  {
    if (_os_atomic_mo_has_acquire(0)) {
      unint64_t v27 = __ldaxr(v42);
    }
    else {
      unint64_t v27 = __ldxr(v42);
    }
    unint64_t v44 = v27 & 0xFFFFFFFF00000003LL | (unint64_t)_dispatch_thread_getspecific(3uLL) & 0xFFFFFFFC;
    if (_os_atomic_mo_has_release(0)) {
      BOOL v43 = __stlxr(v44, v42) == 0;
    }
    else {
      BOOL v43 = __stxr(v44, v42) == 0;
    }
  }

  while (!v43);
  _dispatch_object_debug( (uint64_t)v37,  "%s",  v28,  v29,  v30,  v31,  v32,  v33,  (char)"_dispatch_runloop_root_queue_create_4CF");
  return v37;
}

void _dispatch_runloop_queue_handle_init(void *a1)
{
  kern_return_t v8;
  mach_port_context_t context;
  mach_port_options_t options;
  mach_port_name_t v11;
  void *v12;
  void *v13;
  uint64_t v14;
  uint64_t v15;
  mach_port_name_t v16;
  void *v17;
  uint64_t v13 = a1;
  uint64_t v12 = a1;
  uint64_t v11 = 0;
  if ((_dispatch_unsafe_fork & 1) == 0) {
    _dispatch_fork_becomes_unsafe_slow();
  }
  options.reserved[1] = 0LL;
  *(_OWORD *)&options.flags = xmmword_C29C8;
  context = (mach_port_context_t)v12;
  uint64_t v8 = 0;
  mach_port_name_t name = 0;
  if (*(void *)(*v12 + 16LL) == 394769LL)
  {
    options.flags |= 2u;
    options.mpl.mpl_qlimit = 1;
  }

  uint64_t v8 = mach_port_construct(mach_task_self_, &options, context, &name);
  if (v8 == -301)
  {
    qword_E4D78 = (uint64_t)"MIG_REPLY_MISMATCH";
    qword_E4DA8 = -301LL;
    __break(1u);
    JUMPOUT(0x3F770LL);
  }

  uint64_t v15 = v8;
  uint64_t v14 = 7808LL;
  if (v8) {
    _dispatch_bug(v14, v15, v1, v2, v3, v4, v5, v6);
  }
  uint64_t v11 = name;
  uint64_t v17 = v12;
  uint64_t v16 = name;
  v12[4] = name;
  _dispatch_program_is_probably_callback_driven = 1;
}

uint64_t _dispatch_runloop_queue_xref_dispose( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t v22 = *(void *)(a1 + 56);
  do
  {
    unint64_t v14 = v22;
    uint64_t v15 = (unint64_t *)(a1 + 56);
    do
      unint64_t v16 = __ldaxr(v15);
    while (v16 == v22 && __stlxr(v22 & 0xFFFFFFF0FFFFFFFFLL, v15));
    unint64_t v22 = v16;
  }

  while (v16 != v14);
  unsigned int v23 = (v16 & 0x700000000LL) >> 32;
  if ((*(_DWORD *)(a1 + 80) & 0x40000) == 0) {
    _dispatch_abort(2160LL, (*(_DWORD *)(a1 + 80) & 0x40000) != 0, v8, v9, v10, v11, v12, v13);
  }
  if ((*(_DWORD *)(a1 + 80) & 0x1000000) != 0) {
    _dispatch_abort(2166LL, (*(_DWORD *)(a1 + 80) & 0x1000000) == 0, v8, v9, v10, v11, v12, v13);
  }
  unsigned int v20 = (unint64_t *)(a1 + 56);
  unint64_t v21 = *(void *)(a1 + 56);
  do
  {
    unint64_t v17 = v21;
    do
      unint64_t v18 = __ldaxr(v20);
    while (v18 == v21 && __stlxr(v21 & 0xFFFFFFFF00000003LL, v20));
    unint64_t v21 = v18;
  }

  while (v18 != v17);
  uint64_t result = (*(uint64_t (**)(uint64_t, void, uint64_t))(*(void *)a1 + 64LL))(a1, v23, 2LL);
  if (v23)
  {
    if ((*(void *)(a1 + 56) & 0xFFFFFFFC) != 0) {
      unsigned int v25 = *(void *)(a1 + 56) | 3;
    }
    else {
      unsigned int v25 = 0;
    }
    if ((_dispatch_set_qos_class_enabled & 1) != 0) {
      return _pthread_qos_override_end_direct(v25, a1);
    }
  }

  return result;
}

void _dispatch_runloop_queue_dispose( mach_port_context_t a1, _BYTE *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (MEMORY[0xFFFFFC100]) {
    kdebug_trace(772079624LL, *(void *)(a1 + 64), 0LL, 0LL, 0LL);
  }
  _dispatch_runloop_queue_handle_dispose(a1);
  _dispatch_lane_class_dispose(a1, a2);
}

void _dispatch_runloop_queue_handle_dispose(mach_port_context_t a1)
{
  kern_return_t v8;
  mach_port_name_t v9;
  uint64_t v9 = *(void *)(a1 + 32);
  BOOL v7 = 0;
  if (v9) {
    BOOL v7 = v9 != -1;
  }
  if (v7)
  {
    *(void *)(a1 + 32) = 0LL;
    uint64_t v8 = mach_port_destruct(mach_task_self_, v9, -1, a1);
    if (v8 == -301)
    {
      qword_E4D78 = (uint64_t)"MIG_REPLY_MISMATCH";
      qword_E4DA8 = -301LL;
      __break(1u);
      JUMPOUT(0x3FDA4LL);
    }

    if (v8) {
      _dispatch_bug(7864LL, v8, v1, v2, v3, v4, v5, v6);
    }
  }

BOOL _dispatch_runloop_root_queue_perform_4CF(dispatch_object_s *a1)
{
  if (*(void *)(*(void *)a1 + 16LL) != 395025LL)
  {
    uint64_t v1 = *(void *)(*(void *)a1 + 16LL);
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Not a runloop queue";
    qword_E4DA8 = v1;
    __break(1u);
    JUMPOUT(0x3FE74LL);
  }

  dispatch_retain(a1);
  BOOL v3 = _dispatch_runloop_queue_drain_one((unint64_t *)a1);
  dispatch_release(a1);
  return v3;
}

BOOL _dispatch_runloop_queue_drain_one(unint64_t *a1)
{
  unsigned int v72 = a1;
  if (!a1[6]) {
    return 0;
  }
  __int128 v71 = 0uLL;
  char v70 = 0;
  unint64_t v169 = (unint64_t)_dispatch_thread_getspecific(0x1BuLL);
  unint64_t v167 = v169 & 0xFFFFFFFFFFFFFFFELL;
  if ((v169 & 0xFFFFFFFFFFFFFFFELL) == 0xFFFFFFFFFFFFFFFCLL)
  {
    char v168 = 0;
  }

  else
  {
    _dispatch_thread_getspecific(0LL);
    _dispatch_log("%u\t%p\twlh[anon]: set current (releasing %p)", v6, v7, v8, v9, v10, v11, v12, 825LL);
    unint64_t v171 = v167;
    if (v167 && v171 != -4LL)
    {
      unint64_t v170 = v171;
      unint64_t v184 = (void *)v171;
      int v183 = 0;
      int v181 = 1;
      int v180 = 1;
      int v182 = 1;
      unsigned int v178 = 0;
      int v176 = 1;
      int v175 = 1;
      int v177 = 1;
      int v60 = (unsigned int *)(v171 + 96);
      unsigned int v61 = *(_DWORD *)(v171 + 96);
      do
      {
        unsigned int v13 = v61;
        do
          unsigned int v14 = __ldaxr(v60);
        while (v14 == v61 && __stlxr(v61 - 1, v60));
        unsigned int v61 = v14;
      }

      while (v14 != v13);
      unsigned int v174 = v14;
      unsigned int v178 = v14;
      unsigned int v173 = v14;
      unsigned int v179 = v14 - v182;
      int v183 = v14 - v182;
      if (((v14 - v182) & 0x80000000) != 0)
      {
        if (v183 <= -2)
        {
          qword_E4D78 = (uint64_t)"API MISUSE: Over-release of an object";
          __break(1u);
          JUMPOUT(0x400DCLL);
        }

        v184[7] = 0xDEAD000000000000LL;
        int v172 = v184;
        _dispatch_object_dealloc(v184);
      }
    }

    _dispatch_thread_setspecific(27LL, -4LL);
    char v168 = 1;
  }

  char v70 = v168;
  signed int v69 = v72;
  uint64_t v155 = v72;
  uint64_t v154 = &v71;
  uint64_t v159 = &v71;
  _dispatch_thread_getspecific_packed_pair(20LL, 21LL, &v71, v1, v2, v3, v4, v5);
  _dispatch_thread_setspecific_pair(20LL, (uint64_t)v155, 21LL, (uint64_t)v154, v15, v16, v17, v18);
  signed int v74 = 0LL;
  signed int v74 = _dispatch_thread_getspecific(4uLL);
  signed int v68 = v74;
  unsigned int v67 = 0;
  uint64_t v123 = v74;
  char v122 = 1;
  BOOL v126 = (v74 & 0x20000000) == 0;
  uint64_t v125 = 458LL;
  unsigned int v121 = v123 & 0x8E0000FF;
  unint64_t v124 = (unint64_t)(v123 & 0x3FFF00) >> 8;
  unsigned int v25 = (v123 & 0x3FFF00) >> 8;
  unsigned int v26 = __clz(__rbit32(v25));
  if (v25) {
    unsigned int v27 = v26 + 1;
  }
  else {
    unsigned int v27 = 0;
  }
  v121 |= v27 << 8;
  unsigned int v67 = v121;
  uint64_t v66 = 0LL;
  char v145 = 0LL;
  char v145 = _dispatch_thread_getspecific(0x1CuLL);
  if (v145)
  {
    uint64_t v146 = v145;
    os_retain(v145);
  }

  uint64_t v66 = (uint64_t)v145;
  unsigned int v65 = 0;
  unsigned int v149 = v67;
  unsigned int v148 = 0;
  unsigned int v148 = _dispatch_thread_getspecific(0x19uLL);
  unsigned int v147 = v148;
  if (v148)
  {
    if ((v149 & 0xFFF) != 0)
    {
      v147 &= 0x880F0000;
      if ((v148 & 0xFFF) > (v149 & 0xFFF)) {
        int v59 = v148 & 0xFFF;
      }
      else {
        int v59 = v149 & 0xFFF;
      }
      v147 |= v59;
      unsigned int v151 = v149 & 0xF000;
      unsigned int v153 = v147 & 0xF00;
      if (v151 >> 12 > v153 >> 8) {
        v149 &= 0x4400F000u;
      }
      else {
        v149 &= 0x40000000u;
      }
      v147 |= v149;
    }

    else
    {
      if ((v147 & 0xFFF) != 0) {
        v147 |= 0x40000000u;
      }
      unsigned int v150 = v149 & 0xF000;
      unsigned int v152 = v147 & 0xF00;
      if (v150 >> 12 > v152 >> 8)
      {
        v147 &= 0xFFFF0FFF;
        v147 |= v149 & 0x400F000;
      }
    }
  }

  else
  {
    unsigned int v147 = v149 & 0xFFF0FFFF;
  }

  _dispatch_thread_setspecific(25LL, v147);
  unsigned int v65 = v148;
  unsigned int v85 = 15;
  unsigned int v84 = 0;
  unsigned int v84 = _dispatch_thread_getspecific(0x19uLL);
  int v160 = v84 & 0xF0000;
  if ((v84 & 0xF0000) >> 16 < v85)
  {
    v84 &= 0xFFF0FFFF;
    v84 |= v85 << 16;
    _dispatch_thread_setspecific(25LL, v84);
  }

  memset(v64, 0, sizeof(v64));
  unsigned int v92 = v72;
  signed int v91 = v72 + 13;
  uint64_t v90 = 0LL;
  uint64_t v89 = 0LL;
  uint64_t v88 = v72[13];
  uint64_t v89 = v88;
  uint64_t v87 = v88;
  uint64_t v90 = v88;
  if (!v88) {
    uint64_t v90 = _dispatch_wait_for_enqueuer(v91, (uint64_t)(v92 + 6));
  }
  uint64_t v86 = v90;
  signed int v63 = (void *)v90;
  uint64_t v120 = v72;
  uint64_t v119 = v90;
  uint64_t v118 = v90;
  uint64_t v117 = 0LL;
  unint64_t v116 = 0LL;
  unint64_t v115 = 0LL;
  unint64_t v114 = 0LL;
  unint64_t v113 = *(void *)(v90 + 16);
  unint64_t v114 = v113;
  unint64_t v112 = v113;
  uint64_t v117 = v113;
  unint64_t v111 = v113;
  unint64_t v110 = v113;
  v72[13] = v113;
  unint64_t v109 = v111;
  if (!v117)
  {
    uint64_t v106 = 0LL;
    uint64_t v107 = 0LL;
    uint64_t v108 = v120 + 6;
    BOOL v105 = 0;
    BOOL v104 = v120 + 6;
    while (1)
    {
      unint64_t v28 = _os_atomic_mo_has_acquire(3) ? __ldaxr(v104) : __ldxr(v104);
      unint64_t v115 = v28;
      unint64_t v127 = v28;
      if (v118 != (v28 & 0xFFFFFFFFFFFFFFF8LL)) {
        break;
      }
      unint64_t v116 = 0LL;
      if (_os_atomic_mo_has_release(3)) {
        BOOL v105 = __stlxr(v116, v104) == 0;
      }
      else {
        BOOL v105 = __stxr(v116, v104) == 0;
      }
      if (v105) {
        goto LABEL_55;
      }
    }

    __clrex();
    uint64_t v103 = v118;
    uint64_t v102 = 0LL;
    uint64_t v101 = 0LL;
    uint64_t v100 = *(void *)(v118 + 16);
    uint64_t v101 = v100;
    uint64_t v99 = v100;
    uint64_t v102 = v100;
    if (!v100) {
      uint64_t v102 = _dispatch_wait_for_enqueuer((unint64_t *)(v103 + 16), (uint64_t)(v120 + 6));
    }
    uint64_t v98 = v102;
    uint64_t v117 = v102;
    uint64_t v97 = v102;
    uint64_t v96 = v102;
    v120[13] = v102;
    uint64_t v95 = v97;
LABEL_55:
    BOOL v94 = v105;
  }

  uint64_t v93 = v117;
  uint64_t v62 = v117;
  _dispatch_continuation_pop_inline(v63, (uint64_t)v64, 0x80000, (uint64_t)v72);
  if (!v62) {
    (*(void (**)(unint64_t *, void))(*v72 + 64))(v72, 0LL);
  }
  _dispatch_thread_getspecific(0LL);
  _dispatch_log("%u\t%p\tvoucher[%p]: runloop queue restore", v29, v30, v31, v32, v33, v34, v35, 8135LL);
  unsigned int v158 = v65;
  unsigned int v157 = 0;
  unsigned int v157 = _dispatch_thread_getspecific(0x19uLL);
  v158 &= 0xFFF0FFFF;
  v158 |= v157 & 0xF0000;
  _dispatch_thread_setspecific(25LL, v158);
  unsigned int v162 = 0;
  unsigned int v162 = _dispatch_thread_getspecific(0x19uLL);
  int v164 = v162 & 0xF0000;
  unsigned int v161 = (v162 & 0xF0000) >> 16;
  if ((v162 & 0xF0000) >> 16)
  {
    v162 &= 0xFFF0FFFF;
    _dispatch_thread_setspecific(25LL, v162);
    BOOL v163 = v161 != 15;
  }

  else
  {
    BOOL v163 = 0;
  }

  uint64_t v76 = (uint64_t)v68;
  uint64_t v75 = v66;
  uint64_t v80 = v76;
  uint64_t v79 = v75;
  uint64_t v78 = 6LL;
  uint64_t v131 = v76;
  BOOL v144 = v76 != -1;
  uint64_t v143 = 2395LL;
  if (v76 == -1) {
    _dispatch_abort(v143, v144, v36, v37, v38, v39, v40, v41);
  }
  if ((_dispatch_set_qos_class_enabled & 1) != 0)
  {
    uint64_t v142 = v131;
    uint64_t v141 = 4261412863LL;
    uint64_t v140 = 0LL;
    v131 &= 0xFFFFFFFF02FFFFFFLL;
    unint64_t v130 = 0LL;
    uint64_t v133 = 0LL;
    uint64_t v133 = _dispatch_thread_getspecific(4uLL);
    unint64_t v130 = (unint64_t)v133;
    uint64_t v129 = 0x1000000LL;
    uint64_t v128 = 2281701376LL;
    if ((v133 & 0x1000000) != 0)
    {
      if (v131)
      {
        uint64_t v58 = v131;
      }

      else
      {
        unint64_t v139 = v130;
        uint64_t v138 = v129;
        uint64_t v137 = 0LL;
        uint64_t v58 = v130 & (~v129 | 0xFFFFFF);
      }

      uint64_t v132 = v58;
    }

    else
    {
      unint64_t v136 = v130;
      uint64_t v135 = v128;
      uint64_t v134 = 0LL;
      v130 &= ~v128 | 0xFFFFFF;
      if (v131 == v130) {
        uint64_t v132 = 0LL;
      }
      else {
        uint64_t v132 = v131;
      }
    }
  }

  else
  {
    uint64_t v132 = 0LL;
  }

  uint64_t v80 = v132;
  if (v132)
  {
LABEL_88:
    uint64_t v81 = _dispatch_set_priority_and_voucher_slow(v80, (_DWORD *)v79, v78);
    goto LABEL_89;
  }

  if (v79 != -1)
  {
    int v57 = (void *)v79;
    if (v57 == _dispatch_thread_getspecific(0x1CuLL))
    {
      BOOL v77 = (v78 & 4) != 0;
      if ((v78 & 2) != 0)
      {
        if (v77 && v79)
        {
          object = (void *)v79;
          os_release((void *)v79);
        }

        uint64_t v79 = -1LL;
      }

      else if (!v77 && v79)
      {
        uint64_t v83 = (void *)v79;
        os_retain((void *)v79);
      }

      uint64_t v81 = v79;
      goto LABEL_89;
    }

    goto LABEL_88;
  }

  uint64_t v81 = -1LL;
LABEL_89:
  unint64_t v156 = &v71;
  _dispatch_thread_setspecific_packed_pair(20LL, 21LL, &v71, v37, v38, v39, v40, v41);
  if ((v70 & 1) != 0)
  {
    BOOL v48 = _dispatch_thread_getspecific(0x1BuLL) == (void *)-4LL;
    BOOL v166 = v48;
    uint64_t v165 = 871LL;
    if (!v48) {
      _dispatch_abort(v165, v166, v42, v43, v44, v45, v46, v47);
    }
    _dispatch_thread_getspecific(0LL);
    _dispatch_log("%u\t%p\twlh[anon]: clear current", v49, v50, v51, v52, v53, v54, v55, 872LL);
    _dispatch_thread_setspecific(27LL, 0LL);
    _dispatch_thread_setspecific(5LL, 0LL);
  }

  _dispatch_force_cache_cleanup();
  return v62 != 0;
}

void _dispatch_runloop_root_queue_wakeup_4CF( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(void *)(*(void *)a1 + 16LL) != 395025LL)
  {
    uint64_t v8 = *(void *)(*(void *)a1 + 16LL);
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Not a runloop queue";
    qword_E4DA8 = v8;
    __break(1u);
    JUMPOUT(0x40DD0LL);
  }

  _dispatch_runloop_queue_wakeup(a1, 0, 0, a4, a5, a6, a7, a8);
}

uint64_t _dispatch_runloop_root_queue_get_port_4CF(unsigned int *a1)
{
  if (*(void *)(*(void *)a1 + 16LL) != 395025LL)
  {
    uint64_t v1 = *(void *)(*(void *)a1 + 16LL);
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Not a runloop queue";
    qword_E4DA8 = v1;
    __break(1u);
    JUMPOUT(0x40E80LL);
  }

  return a1[8];
}

uint64_t _dispatch_get_main_queue_handle_4CF()
{
  if (_dispatch_main_q_handle_pred != -1) {
    dispatch_once_f( &_dispatch_main_q_handle_pred,  &_dispatch_main_q,  (dispatch_function_t)_dispatch_runloop_queue_handle_init);
  }
  return unk_E4060;
}

uint64_t _dispatch_get_main_queue_port_4CF()
{
  return _dispatch_get_main_queue_handle_4CF();
}

void _dispatch_main_queue_callback_4CF()
{
  if (!dword_E40B0)
  {
    dword_E40B0 = 1;
    _dispatch_main_queue_drain((uint64_t)&_dispatch_main_q);
    dword_E40B0 = 0;
  }

void _dispatch_main_queue_drain(uint64_t a1)
{
  uint64_t v83 = a1;
  __int128 v82 = 0uLL;
  if (!*(void *)(a1 + 48)) {
    return;
  }
  uint64_t v81 = v83;
  uint64_t v95 = v83;
  uint64_t v99 = v83;
  int v98 = 0;
  int v97 = *(_DWORD *)(v83 + 80);
  int v98 = v97;
  int v96 = v97;
  if (((BYTE2(v97) >> 2) & 1) == 0)
  {
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: _dispatch_main_queue_callback_4CF called after dispatch_main()";
    __break(1u);
    JUMPOUT(0x4106CLL);
  }

  uint64_t v80 = 0LL;
  uint64_t v79 = 0LL;
  uint64_t v78 = *(void *)(v83 + 56);
  uint64_t v79 = v78;
  uint64_t v77 = v78;
  uint64_t v80 = v78;
  uint64_t v84 = v78;
  int v114 = v78;
  if (((v78 ^ _dispatch_thread_getspecific(3uLL)) & 0xFFFFFFFC) != 0)
  {
    uint64_t v76 = v80;
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: _dispatch_main_queue_callback_4CF called from the wrong thread";
    qword_E4DA8 = v80;
    __break(1u);
    JUMPOUT(0x4111CLL);
  }

  predicate = &_dispatch_main_q_handle_pred;
  context = (void *)v83;
  dispatch_function_t function = (dispatch_function_t)_dispatch_runloop_queue_handle_init;
  if (_dispatch_main_q_handle_pred != -1) {
    dispatch_once_f(predicate, context, function);
  }
  unint64_t v157 = (unint64_t)_dispatch_thread_getspecific(0x1BuLL);
  unint64_t v155 = v157 & 0xFFFFFFFFFFFFFFFELL;
  if ((v157 & 0xFFFFFFFFFFFFFFFELL) == 0xFFFFFFFFFFFFFFFCLL)
  {
    char v156 = 0;
  }

  else
  {
    _dispatch_thread_getspecific(0LL);
    _dispatch_log("%u\t%p\twlh[anon]: set current (releasing %p)", v6, v7, v8, v9, v10, v11, v12, 825LL);
    unint64_t v159 = v155;
    if (v155 && v159 != -4LL)
    {
      unint64_t v158 = v159;
      int v172 = (void *)v159;
      int v171 = 0;
      int v169 = 1;
      int v168 = 1;
      int v170 = 1;
      unsigned int v166 = 0;
      int v164 = 1;
      int v163 = 1;
      int v165 = 1;
      uint64_t v62 = (unsigned int *)(v159 + 96);
      unsigned int v63 = *(_DWORD *)(v159 + 96);
      do
      {
        unsigned int v13 = v63;
        do
          unsigned int v14 = __ldaxr(v62);
        while (v14 == v63 && __stlxr(v63 - 1, v62));
        unsigned int v63 = v14;
      }

      while (v14 != v13);
      unsigned int v162 = v14;
      unsigned int v166 = v14;
      unsigned int v161 = v14;
      unsigned int v167 = v14 - v170;
      int v171 = v14 - v170;
      if (((v14 - v170) & 0x80000000) != 0)
      {
        if (v171 <= -2)
        {
          qword_E4D78 = (uint64_t)"API MISUSE: Over-release of an object";
          __break(1u);
          JUMPOUT(0x41328LL);
        }

        v172[7] = 0xDEAD000000000000LL;
        int v160 = v172;
        _dispatch_object_dealloc(v172);
      }
    }

    _dispatch_thread_setspecific(27LL, -4LL);
    char v156 = 1;
  }

  if ((v156 & 1) == 0)
  {
    qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: Lingering DISPATCH_WLH_ANON";
    __break(1u);
    JUMPOUT(0x41398LL);
  }

  uint64_t v75 = v83;
  uint64_t v146 = v83;
  char v145 = &v82;
  uint64_t v144 = 0LL;
  unsigned int v147 = &v82;
  _dispatch_thread_getspecific_packed_pair(20LL, 21LL, &v82, v1, v2, v3, v4, v5);
  _dispatch_thread_setspecific_pair(20LL, v146, 21LL, v144, v15, v16, v17, v18);
  unsigned int v85 = 0LL;
  unsigned int v85 = _dispatch_thread_getspecific(4uLL);
  signed int v74 = v85;
  unsigned int v73 = 0;
  unint64_t v109 = v85;
  char v108 = 1;
  BOOL v112 = (v85 & 0x20000000) == 0;
  uint64_t v111 = 458LL;
  unsigned int v107 = v109 & 0x8E0000FF;
  unint64_t v110 = (unint64_t)(v109 & 0x3FFF00) >> 8;
  unsigned int v25 = (v109 & 0x3FFF00) >> 8;
  unsigned int v26 = __clz(__rbit32(v25));
  if (v25) {
    unsigned int v27 = v26 + 1;
  }
  else {
    unsigned int v27 = 0;
  }
  v107 |= v27 << 8;
  unsigned int v73 = v107;
  unsigned int v101 = v107 & 0xF00;
  unsigned int v72 = v101 >> 8;
  uint64_t v71 = 0LL;
  uint64_t v132 = 0LL;
  uint64_t v132 = _dispatch_thread_getspecific(0x1CuLL);
  if (v132)
  {
    uint64_t v133 = v132;
    os_retain(v132);
  }

  uint64_t v71 = (uint64_t)v132;
  LOWORD(v100) = *(_DWORD *)(v83 + 84);
  v100 &= 0xF00u;
  if (v72 != v100 >> 8) {
    _dispatch_main_queue_update_priority_from_thread();
  }
  unsigned int v70 = 0;
  unsigned int v136 = v73;
  unsigned int v135 = 0;
  unsigned int v135 = _dispatch_thread_getspecific(0x19uLL);
  unsigned int v134 = v135;
  if (v135)
  {
    if ((v136 & 0xFFF) != 0)
    {
      v134 &= 0x880F0000;
      if ((v135 & 0xFFF) > (v136 & 0xFFF)) {
        int v61 = v135 & 0xFFF;
      }
      else {
        int v61 = v136 & 0xFFF;
      }
      v134 |= v61;
      unsigned int v138 = v136 & 0xF000;
      unsigned int v140 = v134 & 0xF00;
      if (v138 >> 12 > v140 >> 8) {
        v136 &= 0x4400F000u;
      }
      else {
        v136 &= 0x40000000u;
      }
      v134 |= v136;
    }

    else
    {
      if ((v134 & 0xFFF) != 0) {
        v134 |= 0x40000000u;
      }
      unsigned int v137 = v136 & 0xF000;
      unsigned int v139 = v134 & 0xF00;
      if (v137 >> 12 > v139 >> 8)
      {
        v134 &= 0xFFFF0FFF;
        v134 |= v136 & 0x400F000;
      }
    }
  }

  else
  {
    unsigned int v134 = v136 & 0xFFF0FFFF;
  }

  _dispatch_thread_setspecific(25LL, v134);
  unsigned int v70 = v135;
  unsigned int v103 = 15;
  unsigned int v102 = 0;
  unsigned int v102 = _dispatch_thread_getspecific(0x19uLL);
  int v148 = v102 & 0xF0000;
  if ((v102 & 0xF0000) >> 16 < v103)
  {
    v102 &= 0xFFF0FFFF;
    v102 |= v103 << 16;
    _dispatch_thread_setspecific(25LL, v102);
  }

  memset(v69, 0, 32);
  uint64_t v66 = *(void *)(v83 + 104);
  if (!v66) {
    uint64_t v66 = _dispatch_wait_for_enqueuer((unint64_t *)(v83 + 104), v83 + 48);
  }
  *(void *)(v83 + 104) = 0LL;
  int v59 = (unint64_t *)(v83 + 48);
  unint64_t v60 = *(void *)(v83 + 48);
  do
  {
    unint64_t v28 = v60;
    do
      unint64_t v29 = __ldaxr(v59);
    while (v29 == v60 && __stlxr(0LL, v59));
    unint64_t v60 = v29;
  }

  while (v29 != v28);
  unint64_t v113 = v29;
  unint64_t v67 = v29 & 0xFFFFFFFFFFFFFFF8LL;
  signed int v68 = (void *)v66;
  do
  {
    unsigned int v65 = 0LL;
    if (v68 != (void *)v67)
    {
      uint64_t v64 = v68[2];
      if (!v64) {
        uint64_t v64 = _dispatch_wait_for_enqueuer(v68 + 2, 0LL);
      }
      unsigned int v65 = (void *)v64;
    }

    _dispatch_continuation_pop_inline(v68, (uint64_t)v69, 0x80000, v83);
    signed int v68 = v65;
  }

  while (v65);
  (*(void (**)(uint64_t, void))(*(void *)v83 + 64LL))(v83, 0LL);
  _dispatch_thread_getspecific(0LL);
  _dispatch_log("%u\t%p\tvoucher[%p]: main queue restore", v30, v31, v32, v33, v34, v35, v36, 8098LL);
  unsigned int v143 = v70;
  unsigned int v142 = 0;
  unsigned int v142 = _dispatch_thread_getspecific(0x19uLL);
  v143 &= 0xFFF0FFFF;
  v143 |= v142 & 0xF0000;
  _dispatch_thread_setspecific(25LL, v143);
  unsigned int v150 = 0;
  unsigned int v150 = _dispatch_thread_getspecific(0x19uLL);
  int v152 = v150 & 0xF0000;
  unsigned int v149 = (v150 & 0xF0000) >> 16;
  if ((v150 & 0xF0000) >> 16)
  {
    v150 &= 0xFFF0FFFF;
    _dispatch_thread_setspecific(25LL, v150);
    BOOL v151 = v149 != 15;
  }

  else
  {
    BOOL v151 = 0;
  }

  uint64_t v87 = (uint64_t)v74;
  uint64_t v86 = v71;
  uint64_t v91 = v87;
  uint64_t v90 = v86;
  uint64_t v89 = 6LL;
  uint64_t v118 = v87;
  BOOL v131 = v87 != -1;
  uint64_t v130 = 2395LL;
  if (v87 == -1) {
    _dispatch_abort(v130, v131, v37, v38, v39, v40, v41, v42);
  }
  if ((_dispatch_set_qos_class_enabled & 1) != 0)
  {
    uint64_t v129 = v118;
    uint64_t v128 = 4261412863LL;
    uint64_t v127 = 0LL;
    v118 &= 0xFFFFFFFF02FFFFFFLL;
    unint64_t v117 = 0LL;
    uint64_t v120 = 0LL;
    uint64_t v120 = _dispatch_thread_getspecific(4uLL);
    unint64_t v117 = (unint64_t)v120;
    uint64_t v116 = 0x1000000LL;
    uint64_t v115 = 2281701376LL;
    if ((v120 & 0x1000000) != 0)
    {
      if (v118)
      {
        uint64_t v58 = v118;
      }

      else
      {
        unint64_t v126 = v117;
        uint64_t v125 = v116;
        uint64_t v124 = 0LL;
        uint64_t v58 = v117 & (~v116 | 0xFFFFFF);
      }

      uint64_t v119 = v58;
    }

    else
    {
      unint64_t v123 = v117;
      uint64_t v122 = v115;
      uint64_t v121 = 0LL;
      v117 &= ~v115 | 0xFFFFFF;
      if (v118 == v117) {
        uint64_t v119 = 0LL;
      }
      else {
        uint64_t v119 = v118;
      }
    }
  }

  else
  {
    uint64_t v119 = 0LL;
  }

  uint64_t v91 = v119;
  if (v119)
  {
LABEL_92:
    uint64_t v92 = _dispatch_set_priority_and_voucher_slow(v91, (_DWORD *)v90, v89);
    goto LABEL_93;
  }

  if (v90 != -1)
  {
    int v57 = (void *)v90;
    if (v57 == _dispatch_thread_getspecific(0x1CuLL))
    {
      BOOL v88 = (v89 & 4) != 0;
      if ((v89 & 2) != 0)
      {
        if (v88 && v90)
        {
          object = (void *)v90;
          os_release((void *)v90);
        }

        uint64_t v90 = -1LL;
      }

      else if (!v88 && v90)
      {
        BOOL v94 = (void *)v90;
        os_retain((void *)v90);
      }

      uint64_t v92 = v90;
      goto LABEL_93;
    }

    goto LABEL_92;
  }

  uint64_t v92 = -1LL;
LABEL_93:
  uint64_t v141 = &v82;
  _dispatch_thread_setspecific_packed_pair(20LL, 21LL, &v82, v38, v39, v40, v41, v42);
  BOOL v49 = _dispatch_thread_getspecific(0x1BuLL) == (void *)-4LL;
  BOOL v154 = v49;
  uint64_t v153 = 871LL;
  if (!v49) {
    _dispatch_abort(v153, v154, v43, v44, v45, v46, v47, v48);
  }
  _dispatch_thread_getspecific(0LL);
  _dispatch_log("%u\t%p\twlh[anon]: clear current", v50, v51, v52, v53, v54, v55, v56, 872LL);
  _dispatch_thread_setspecific(27LL, 0LL);
  _dispatch_thread_setspecific(5LL, 0LL);
  _dispatch_force_cache_cleanup();
}

uint64_t _dispatch_main_queue_push(uint64_t a1, uint64_t a2, unsigned int a3)
{
  unint64_t v3 = (unint64_t)_dispatch_thread_getspecific(4uLL);
  unsigned int v4 = 0;
  unsigned int v5 = (v3 & 0x3FFF00) >> 8;
  unsigned int v6 = __clz(__rbit32(v5));
  if (v5) {
    unsigned int v4 = v6 + 1;
  }
  unsigned int v21 = v4;
  *(void *)(a2 + 16) = 0LL;
  _dispatch_thread_setspecific(122LL, a1 + 48);
  uint64_t v17 = (unint64_t *)(a1 + 48);
  do
  {
    if (_os_atomic_mo_has_acquire(3)) {
      unint64_t v13 = __ldaxr(v17);
    }
    else {
      unint64_t v13 = __ldxr(v17);
    }
    unint64_t v20 = v13;
    if (v21 <= (v13 & 7)) {
      unsigned int v16 = v13 & 7;
    }
    else {
      unsigned int v16 = v21;
    }
    if ((a2 & 7) != 0) {
      _dispatch_abort(1647LL, (a2 & 7) == 0, v7, v8, v9, v10, v11, v12);
    }
    if ((v16 & 0xFFFFFFF8) != 0) {
      _dispatch_abort(1648LL, (v16 & 0xFFFFFFF8) == 0LL, v7, v8, v9, v10, v11, v12);
    }
    unint64_t v19 = a2 | v16;
    if (_os_atomic_mo_has_release(3)) {
      BOOL v18 = __stlxr(v19, v17) == 0;
    }
    else {
      BOOL v18 = __stxr(v19, v17) == 0;
    }
  }

  while (!v18);
  if ((v20 & 0xFFFFFFFFFFFFFFF8LL) != 0) {
    *(void *)((v20 & 0xFFFFFFFFFFFFFFF8LL) + 16) = a2;
  }
  else {
    *(void *)(a1 + 104) = a2;
  }
  uint64_t result = _dispatch_thread_setspecific(122LL, 0LL);
  if (!v20 || (v20 & 7) < v21 && (*(_DWORD *)(a1 + 80) & 0x40000) != 0) {
    return (*(uint64_t (**)(uint64_t, void, uint64_t))(*(void *)a1 + 64LL))(a1, a3, 2LL);
  }
  if (a3 <= (*(_DWORD *)(a1 + 84) & 0xF00u) >> 8) {
    unsigned int v25 = 0;
  }
  else {
    unsigned int v25 = a3;
  }
  unsigned int v26 = (((unint64_t)*(unsigned int *)(a1 + 60) << 32) & 0x700000000LL) >> 32;
  BOOL v15 = 1;
  if (v26) {
    BOOL v15 = v26 < v25;
  }
  if (v15) {
    return (*(uint64_t (**)(uint64_t, void, void))(*(void *)a1 + 64LL))(a1, v25, 0LL);
  }
  return result;
}

void _dispatch_main_queue_wakeup( uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if ((*(_DWORD *)(a1 + 80) & 0x40000) != 0)
  {
    if ((*(_DWORD *)(a1 + 80) & 0x1000000) != 0) {
      _dispatch_abort(8306LL, (*(_DWORD *)(a1 + 80) & 0x1000000) == 0, a3, a4, a5, a6, a7, a8);
    }
    _dispatch_runloop_queue_wakeup(a1, a2, a3, a4, a5, a6, a7, a8);
  }

  else
  {
    _dispatch_lane_wakeup(a1, a2, a3, a4, a5, a6, a7, a8);
  }

void dispatch_main(void)
{
  if (_dispatch_root_queues_pred != -1LL) {
    dispatch_once_f(&_dispatch_root_queues_pred, 0LL, (dispatch_function_t)_dispatch_root_queues_init_once);
  }
  if (pthread_main_np())
  {
    if (!dword_E40B0)
    {
      dword_E40B0 = 1;
      _dispatch_main_queue_drain((uint64_t)&_dispatch_main_q);
      dword_E40B0 = 0;
      _dispatch_object_debug((uint64_t)&_dispatch_main_q, "%s", v0, v1, v2, v3, v4, v5, (char)"dispatch_main");
      _dispatch_program_is_probably_callback_driven = 1;
      if (MEMORY[0xFFFFFC100]) {
        kdebug_trace(735838216LL, 0LL, 0LL, 0LL, 0LL);
      }
      pthread_exit(0LL);
    }

    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: dispatch_main called from a block on the main queue";
    __break(1u);
  }

  else
  {
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: dispatch_main() must be called on the main thread";
    __break(1u);
  }

  JUMPOUT(0x42690LL);
}

void sub_42780()
{
}

dispatch_queue_global_t dispatch_get_global_queue(intptr_t identifier, uintptr_t flags)
{
  if ((flags & 0xFFFFFFFFFFFFFFF9LL) != 0) {
    return 0LL;
  }
  if ((flags & 2) != 0 && (flags & 4) != 0) {
    return 0LL;
  }
  switch(identifier)
  {
    case -32768LL:
      int v4 = 2;
      break;
    case -128LL:
      int v4 = 3;
      break;
    case -2LL:
      int v4 = 3;
      break;
    default:
      if (identifier)
      {
        if (identifier == 2)
        {
          int v4 = 5;
        }

        else
        {
          switch((int)identifier)
          {
            case 5:
              int v5 = 1;
              break;
            case 9:
              int v5 = 2;
              break;
            case 17:
              int v5 = 3;
              break;
            case 21:
              int v5 = 4;
              break;
            case 25:
              int v5 = 5;
              break;
            case 33:
              int v5 = 6;
              break;
            default:
              int v5 = 0;
              break;
          }

          int v4 = v5;
        }
      }

      else
      {
        int v4 = 4;
      }

      break;
  }

  if (!v4) {
    return 0LL;
  }
  int v6 = 0;
  if ((flags & 2) != 0)
  {
    int v6 = 1;
  }

  else if ((flags & 4) != 0)
  {
    int v6 = 2;
  }

  return (dispatch_queue_global_t)&(&_dispatch_root_queues)[16 * (unint64_t)(3 * v4 + v6 - 3)];
}

uint64_t libdispatch_init()
{
  if (_dispatch_getenv_BOOL("LIBDISPATCH_STRICT", 0)) {
    _dispatch_mode |= 1u;
  }
  if (_dispatch_getenv_BOOL("LIBDISPATCH_COOPERATIVE_POOL_STRICT", 0)) {
    _dispatch_mode |= 4u;
  }
  if (getenv("LIBDISPATCH_DISABLE_KEVENT_WQ")) {
    _dispatch_kevent_workqueue_enabled = 0;
  }
  unint64_t v10 = qos_class_main() - 5;
  if (v10 <= 0x1C) {
    __asm { BR              X8 }
  }

  dword_E4094 = 0;
  if (!getenv("LIBDISPATCH_DISABLE_SET_QOS")) {
    _dispatch_set_qos_class_enabled = 1;
  }
  _dispatch_thread_key_create(&dispatch_priority_key, 0LL);
  _dispatch_thread_key_create(&dispatch_r2k_key, 0LL);
  _dispatch_thread_key_create(&dispatch_queue_key, (uint64_t)_dispatch_queue_cleanup);
  _dispatch_thread_key_create(&dispatch_frame_key, (uint64_t)_dispatch_frame_cleanup);
  _dispatch_thread_key_create(&dispatch_cache_key, (uint64_t)_dispatch_cache_cleanup);
  _dispatch_thread_key_create(&dispatch_context_key, (uint64_t)_dispatch_context_cleanup);
  _dispatch_thread_key_create(&dispatch_pthread_root_queue_observer_hooks_key, 0LL);
  _dispatch_thread_key_create(&dispatch_basepri_key, 0LL);
  _dispatch_thread_key_create(&dispatch_wlh_key, (uint64_t)_dispatch_wlh_cleanup);
  _dispatch_thread_key_create(&dispatch_voucher_key, (uint64_t)_voucher_thread_cleanup);
  _dispatch_thread_key_create(&dispatch_deferred_items_key, (uint64_t)_dispatch_deferred_items_cleanup);
  _dispatch_thread_key_create(&dispatch_quantum_key, 0LL);
  _dispatch_thread_key_create(&dispatch_dsc_key, 0LL);
  _dispatch_thread_key_create(&os_workgroup_join_token_key, (uint64_t)_os_workgroup_join_token_tsd_cleanup);
  _dispatch_thread_key_create(&os_workgroup_key, (uint64_t)_os_workgroup_tsd_cleanup);
  _dispatch_thread_key_create(&dispatch_enqueue_key, 0LL);
  _dispatch_thread_key_create(&dispatch_msgv_aux_key, (uint64_t)&_free);
  _dispatch_thread_key_create(&dispatch_set_threadname_key, 0LL);
  _dispatch_thread_setspecific(20LL, (uint64_t)&_dispatch_main_q);
  if ((unk_E4090 & 0x40000) == 0) {
    _dispatch_abort(2140LL, (unk_E4090 & 0x40000) != 0, v0, v1, v2, v3, v4, v5);
  }
  if ((unk_E4090 & 0x1000000) != 0) {
    _dispatch_abort(2146LL, (unk_E4090 & 0x1000000) == 0, v0, v1, v2, v3, v4, v5);
  }
  do
  {
    if (_os_atomic_mo_has_acquire(0)) {
      unint64_t v6 = __ldaxr((unint64_t *)&dword_E4078);
    }
    else {
      unint64_t v6 = __ldxr((unint64_t *)&dword_E4078);
    }
    unint64_t v13 = v6 & 0xFFFFFFFF00000003LL | (unint64_t)_dispatch_thread_getspecific(3uLL) & 0xFFFFFFFC;
    if (_os_atomic_mo_has_release(0)) {
      BOOL v12 = __stlxr(v13, (unint64_t *)&dword_E4078) == 0;
    }
    else {
      BOOL v12 = __stxr(v13, (unint64_t *)&dword_E4078) == 0;
    }
  }

  while (!v12);
  unsigned int v11 = _dispatch_thread_getspecific(0x19uLL);
  if ((v11 & 0xF0000) >> 16 < 0xF) {
    _dispatch_thread_setspecific(25LL, v11 & 0xFFF0FFFF | 0xF0000);
  }
  _dispatch_time_init();
  uint64_t v8 = _os_object_atfork_prepare(v7);
  _os_object_atfork_prepare(v8);
  _voucher_init();
  return _workgroup_init();
}

void *_dispatch_thread_key_create(void *result, uint64_t a2)
{
  if (*result && a2)
  {
    uint64_t result = (void *)pthread_key_init_np(*result, a2);
    if ((_DWORD)result) {
      _dispatch_abort(119LL, (int)result, v2, v3, v4, v5, v6, v7);
    }
  }

  return result;
}

void _dispatch_queue_cleanup(dispatch_queue_s *a1)
{
  if (a1 != &_dispatch_main_q)
  {
    qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: Premature thread exit while a dispatch queue is running";
    qword_E4DA8 = (uint64_t)a1;
    __break(1u);
    JUMPOUT(0x43214LL);
  }

  _dispatch_queue_cleanup2();
}

void _dispatch_frame_cleanup(uint64_t a1)
{
  qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: Premature thread exit while a dispatch frame is active";
  qword_E4DA8 = a1;
  __break(1u);
}

void sub_43268()
{
}

void _dispatch_cache_cleanup(void *a1)
{
  while (1)
  {
    uint64_t v2 = a1;
    if (!a1) {
      break;
    }
    a1 = (void *)a1[2];
    _dispatch_continuation_free_to_heap(v2);
  }

void _dispatch_context_cleanup(uint64_t a1)
{
  qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: Premature thread exit while a dispatch context is set";
  qword_E4DA8 = a1;
  __break(1u);
}

void sub_43318()
{
}

void _dispatch_wlh_cleanup(uint64_t a1)
{
  uint64_t v5 = (void *)(a1 & 0xFFFFFFFFFFFFFFFELL);
  uint64_t v3 = (unsigned int *)((a1 & 0xFFFFFFFFFFFFFFFELL) + 96);
  unsigned int v4 = *v3;
  do
  {
    unsigned int v1 = v4;
    do
      unsigned int v2 = __ldaxr(v3);
    while (v2 == v4 && __stlxr(v4 - 1, v3));
    unsigned int v4 = v2;
  }

  while (v2 != v1);
  if (((v2 - 1) & 0x80000000) != 0)
  {
    if ((int)(v2 - 1) <= -2)
    {
      qword_E4D78 = (uint64_t)"API MISUSE: Over-release of an object";
      __break(1u);
      JUMPOUT(0x43468LL);
    }

    v5[7] = 0xDEAD000000000000LL;
    _dispatch_object_dealloc(v5);
  }

void _dispatch_deferred_items_cleanup(uint64_t a1)
{
  qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: Premature thread exit with unhandled deferred items";
  qword_E4DA8 = a1;
  __break(1u);
}

void sub_434DC()
{
}

void _dispatch_queue_atfork_child( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if ((unk_E4090 & 0x40000) != 0)
  {
    if ((unk_E4090 & 0x1000000) != 0) {
      _dispatch_abort(2146LL, (unk_E4090 & 0x1000000) == 0, a3, a4, a5, a6, a7, a8);
    }
    do
    {
      if (_os_atomic_mo_has_acquire(0)) {
        unint64_t v8 = __ldaxr((unint64_t *)&unk_E4078);
      }
      else {
        unint64_t v8 = __ldxr((unint64_t *)&unk_E4078);
      }
      unint64_t v11 = v8 & 0xFFFFFFFF00000003LL | (unint64_t)_dispatch_thread_getspecific(3uLL) & 0xFFFFFFFC;
      if (_os_atomic_mo_has_release(0)) {
        BOOL v10 = __stlxr(v11, (unint64_t *)&unk_E4078) == 0;
      }
      else {
        BOOL v10 = __stxr(v11, (unint64_t *)&unk_E4078) == 0;
      }
    }

    while (!v10);
  }

  if ((_dispatch_unsafe_fork & 1) != 0)
  {
    unk_E40A8 = 256LL;
    unk_E4070 = 256LL;
    qword_E41A8 = 256LL;
    qword_E4170 = 256LL;
    for (unint64_t i = 0LL; i < 0x12; ++i)
    {
      (&_dispatch_root_queues)[16 * i + 13] = (uint64_t (**)())(&stru_B8 + 72);
      (&_dispatch_root_queues)[16 * i + 6] = (uint64_t (**)())(&stru_B8 + 72);
    }
  }

void _dispatch_fork_becomes_unsafe_slow()
{
  unsigned __int8 v2 = _dispatch_unsafe_fork;
  do
  {
    unsigned __int8 v0 = v2;
    do
      int v1 = __ldaxr((unsigned __int8 *)&_dispatch_unsafe_fork);
    while (v1 == v2 && __stlxr(v2 | 1, (unsigned __int8 *)&_dispatch_unsafe_fork));
    unsigned __int8 v2 = v1;
  }

  while (v1 != v0);
  if ((v1 & 2) != 0)
  {
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Transition to multithreaded is prohibited";
    __break(1u);
    JUMPOUT(0x43924LL);
  }

uint64_t _dispatch_prohibit_transition_to_multithreaded(uint64_t result)
{
  if ((result & 1) != 0)
  {
    unsigned __int8 v6 = _dispatch_unsafe_fork;
    do
    {
      unsigned __int8 v1 = v6;
      do
        int v2 = __ldaxr((unsigned __int8 *)&_dispatch_unsafe_fork);
      while (v2 == v6 && __stlxr(v6 | 2, (unsigned __int8 *)&_dispatch_unsafe_fork));
      unsigned __int8 v6 = v2;
    }

    while (v2 != v1);
    if ((v2 & 1) != 0)
    {
      qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: The executable is already multithreaded";
      __break(1u);
      JUMPOUT(0x43A50LL);
    }
  }

  else
  {
    unsigned __int8 v5 = _dispatch_unsafe_fork;
    do
    {
      unsigned __int8 v3 = v5;
      do
        int v4 = __ldaxr((unsigned __int8 *)&_dispatch_unsafe_fork);
      while (v4 == v5 && __stlxr(v5 & 0xFD, (unsigned __int8 *)&_dispatch_unsafe_fork));
      unsigned __int8 v5 = v4;
    }

    while (v4 != v3);
  }

  return result;
}

pthread_key_t _dispatch_thread_getspecific_pair( pthread_key_t result, void **a2, pthread_key_t a3, pthread_key_t *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (v8) {
    char v9 = 1;
  }
  else {
    char v9 = 0;
  }
  if ((v9 & 1) != 0)
  {
    *a2 = _dispatch_thread_getspecific(result);
    uint64_t result = (pthread_key_t)_dispatch_thread_getspecific(a3);
    *a4 = result;
  }

  else
  {
    if (a3 != result + 1) {
      _dispatch_abort(295LL, a3 == result + 1, a3, (uint64_t)a4, a5, a6, a7, a8);
    }
    __int128 v10 = *(_OWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * result);
    *a2 = (void *)v10;
    *a4 = *((void *)&v10 + 1);
  }

  return result;
}

void _dispatch_block_async_invoke2(void *a1, char a2)
{
  if ((void (*)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))_Block_get_invoke_fn((uint64_t)a1) == ___dispatch_block_create_block_invoke)
  {
    if (a1[4] != 3512316172LL)
    {
      uint64_t v2 = a1[4];
      qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Corruption of dispatch block object";
      qword_E4DA8 = v2;
      __break(1u);
      JUMPOUT(0x43CFCLL);
    }

    BOOL v15 = a1 + 4;
  }

  else
  {
    BOOL v15 = 0LL;
  }

  unsigned int v11 = *((_DWORD *)v15 + 4);
  if (((v11 >> 2) & 1) != 0)
  {
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: A block object may not be both run more than once and waited for";
    qword_E4DA8 = v11;
    __break(1u);
    JUMPOUT(0x43D74LL);
  }

  if ((v11 & 1) == 0) {
    (*(void (**)(void))(v15[5] + 16LL))();
  }
  if ((v11 & 8) == 0)
  {
    char v9 = (unsigned int *)v15 + 5;
    unsigned int v10 = *((_DWORD *)v15 + 5);
    do
    {
      unsigned int v3 = v10;
      do
        unsigned int v4 = __ldaxr(v9);
      while (v4 == v10 && __stlxr(v10 + 1, v9));
      unsigned int v10 = v4;
    }

    while (v4 != v3);
    if (!v4) {
      dispatch_group_leave((dispatch_group_t)v15[6]);
    }
  }

  uint64_t v7 = v15 + 7;
  char v8 = (unsigned int *)v15[7];
  do
  {
    unsigned __int8 v5 = v8;
    do
      unsigned __int8 v6 = (unsigned int *)__ldaxr(v7);
    while (v6 == v8 && __stlxr(0LL, v7));
    char v8 = v6;
  }

  while (v6 != v5);
  if (v6) {
    _dispatch_release_2(v6);
  }
  if ((a2 & 1) != 0) {
    _Block_release(a1);
  }
}

void _dispatch_lane_non_barrier_complete(uint64_t a1, unsigned int a2)
{
  unint64_t v12 = (unint64_t)_dispatch_thread_getspecific(3uLL) & 0xFFFFFFFC;
  unsigned int v10 = (unint64_t *)(a1 + 56);
  do
  {
    if (_os_atomic_mo_has_acquire(0)) {
      unint64_t v2 = __ldaxr(v10);
    }
    else {
      unint64_t v2 = __ldxr(v10);
    }
    unint64_t v14 = v2;
    unint64_t v13 = v2 - 0x20000000000LL;
    if ((v2 & 0xFFFFFFFC) != 0)
    {
      v13 |= 0x8000000000uLL;
    }

    else if (v13 < 0x20000000000000LL)
    {
      unint64_t v18 = v2 - 0x20000000000LL;
      if ((v13 & 0x10000000000LL) != 0) {
        unint64_t v17 = v2 + 0x3FFF0000000000LL;
      }
      else {
        unint64_t v17 = v13 + ((unint64_t)*(unsigned __int16 *)(a1 + 80) << 41) + 0x40000000000000LL;
      }
      if ((v17 & 0x3FFE0000000000LL) == 0x20000000000000LL)
      {
        unint64_t v18 = v17 & 0xFFFFFF7FFFFFFFFFLL | v12;
      }

      else if ((v2 & 0x8000000000LL) != 0)
      {
        unint64_t v18 = v13 | 1;
      }

      unint64_t v13 = v18;
    }

    if (_os_atomic_mo_has_release(0)) {
      BOOL v11 = __stlxr(v13, v10) == 0;
    }
    else {
      BOOL v11 = __stxr(v13, v10) == 0;
    }
  }

  while (!v11);
  BOOL v9 = 0;
  if ((v14 & 0x1000000000LL) != 0) {
    BOOL v9 = (v14 & 0x800000000LL) != 0;
  }
  if (v9)
  {
    uint64_t v19 = v14 & 0x700000000LL;
    LODWORD(v19) = _dispatch_thread_getspecific(0x19uLL);
  }

  if (((v14 ^ v13) & 0x40000000000000LL) != 0)
  {
    _dispatch_lane_barrier_complete(a1, 0, a2, v4, v5, v6, v7, v8);
  }

  else if (((v14 ^ v13) & 1) != 0)
  {
    if ((a2 & 1) == 0) {
      _dispatch_retain_2(a1);
    }
    if ((v13 & 0x2000000000LL) != 0) {
      _dispatch_abort(1002LL, 0LL, v3, v4, v5, v6, v7, v8);
    }
    (*(void (**)(void, uint64_t, unint64_t, uint64_t, uint64_t, uint64_t))(**(void **)(a1 + 24) + 72LL))( *(void *)(a1 + 24),  a1,  (v13 & 0x700000000LL) >> 32,  v4,  v5,  v6);
  }

  else if ((a2 & 1) != 0)
  {
    _dispatch_release_2_tailcall((unsigned int *)a1);
  }

uint64_t _dispatch_thread_setspecific_pair( uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (v8) {
    char v9 = 1;
  }
  else {
    char v9 = 0;
  }
  if ((v9 & 1) != 0)
  {
    _dispatch_thread_setspecific(result, a2);
    return _dispatch_thread_setspecific(a3, a4);
  }

  else
  {
    if (a3 != result + 1) {
      _dispatch_abort(339LL, a3 == result + 1, a3, a4, a5, a6, a7, a8);
    }
    *(void *)&__int128 v10 = a2;
    *((void *)&v10 + 1) = a4;
    *(_OWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * result) = v10;
  }

  return result;
}

uint64_t _dispatch_thread_getspecific_packed_pair( uint64_t result, uint64_t a2, _OWORD *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a2 != result + 1) {
    _dispatch_abort(318LL, a2 == result + 1, (uint64_t)a3, a4, a5, a6, a7, a8);
  }
  *a3 = *(_OWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * result);
  return result;
}

uint64_t _dispatch_thread_setspecific_packed_pair( uint64_t result, uint64_t a2, _OWORD *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a2 != result + 1) {
    _dispatch_abort(360LL, a2 == result + 1, (uint64_t)a3, a4, a5, a6, a7, a8);
  }
  *(_OWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * result) = *a3;
  return result;
}

void _dispatch_sync_f_slow( uint64_t a1, uint64_t a2, uint64_t (*a3)(uint64_t), uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v19 = a1;
  uint64_t v18 = a5;
  uint64_t v17 = a2;
  unsigned int v16 = a3;
  uint64_t v15 = a4;
  uint64_t v14 = a6;
  uint64_t v13 = a1;
  uint64_t v12 = a5;
  if (*(void *)(a5 + 24))
  {
    unint64_t v20 = (unint64_t)_dispatch_thread_getspecific(4uLL);
    void __b[14] = v20;
    memset(__b, 0, 0x70uLL);
    __b[0] = v14 | 1;
    __b[1] = v20 | 0x10000000;
    __b[2] = 0LL;
    __b[3] = _dispatch_thread_getspecific(0x1CuLL);
    __b[4] = _dispatch_async_and_wait_invoke;
    void __b[5] = __b;
    void __b[6] = 0LL;
    __b[7] = v13;
    __b[8] = v16;
    __b[9] = v17;
    memset(&__b[10], 0, 20);
    HIDWORD(__b[12]) = _dispatch_thread_getspecific(3uLL);
    LOWORD(__b[13]) = 0;
    BYTE2(__b[13]) &= 0xFCu;
    BYTE2(__b[13]) &= ~4u;
    BYTE2(__b[13]) &= ~8u;
    BYTE2(__b[13]) &= ~0x10u;
    BYTE2(__b[13]) &= ~0x20u;
    BYTE2(__b[13]) &= ~0x40u;
    BYTE2(__b[13]) &= ~0x80u;
    uint64_t v24 = v13;
    uint64_t v23 = __b;
    int v22 = 0;
    int v21 = 0;
    uint64_t v30 = v13;
    unint64_t v29 = __b;
    __DISPATCH_WAIT_FOR_QUEUE__((uint64_t)__b, v12);
    if (__b[8])
    {
      uint64_t v31 = v13;
      uint64_t v28 = v13;
      unsigned int v27 = __b;
      int v26 = 0;
      int v25 = 0;
      uint64_t v33 = v13;
      uint64_t v32 = __b;
      _dispatch_sync_invoke_and_complete_recurse(v13, v17, v16, v15, (uint64_t)__b, v8, v9, v10);
    }

    else
    {
      _dispatch_sync_complete_recurse(v13, __b[7], v15);
    }
  }

  else
  {
    __b[15] = v12;
    _dispatch_sync_function_invoke(v12, v17, v16, a4, a5, a6, a7, a8);
  }

void _dispatch_sync_recurse(uint64_t a1, uint64_t a2, uint64_t (*a3)(uint64_t), uint64_t a4)
{
  unsigned int v10 = _dispatch_thread_getspecific(3uLL);
  uint64_t v9 = *(void *)(a1 + 24);
  do
  {
    if (*(_WORD *)(v9 + 80) == 1)
    {
      uint64_t v18 = (4096LL - *(unsigned __int16 *)(v9 + 80)) << 41;
      BOOL v16 = 0;
      uint64_t v15 = (unint64_t *)(v9 + 56);
      while (1)
      {
        unint64_t v7 = _os_atomic_mo_has_acquire(2) ? __ldaxr(v15) : __ldxr(v15);
        if (v7 != (v18 | v7 & 0x3000000000LL)) {
          break;
        }
        unint64_t v17 = v10 & 0xFFFFFFFC | 0x60000000000002LL | v7 & 0x3000000000LL;
        if (_os_atomic_mo_has_release(2)) {
          BOOL v16 = __stlxr(v17, v15) == 0;
        }
        else {
          BOOL v16 = __stxr(v17, v15) == 0;
        }
        if (v16) {
          goto LABEL_13;
        }
      }

      __clrex();
LABEL_13:
      if (!v16)
      {
        _dispatch_sync_f_slow(a1, a2, a3, a4, v9, 2LL, v5, v6);
        return;
      }
    }

    else
    {
      if (*(void *)(v9 + 48))
      {
        char v22 = 0;
      }

      else
      {
        uint64_t v19 = (unint64_t *)(v9 + 56);
        do
        {
          if (_os_atomic_mo_has_acquire(0)) {
            unint64_t v8 = __ldaxr(v19);
          }
          else {
            unint64_t v8 = __ldxr(v19);
          }
          if (v8 >= 0x40000000000000LL || (v8 & 0x8000000000LL) != 0 || (v8 & 0x10000000000LL) != 0)
          {
            __clrex();
            char v22 = 0;
            goto LABEL_31;
          }

          unint64_t v21 = v8 + 0x20000000000LL;
          if (_os_atomic_mo_has_release(0)) {
            BOOL v20 = __stlxr(v21, v19) == 0;
          }
          else {
            BOOL v20 = __stxr(v21, v19) == 0;
          }
        }

        while (!v20);
        char v22 = 1;
      }

LABEL_31:
      if (((v22 ^ 1) & 1) != 0)
      {
        _dispatch_sync_f_slow(a1, a2, a3, a4, v9, 0LL, v5, v6);
        return;
      }
    }

    uint64_t v9 = *(void *)(v9 + 24);
  }

  while (*(void *)(v9 + 24));
  _dispatch_sync_invoke_and_complete_recurse(a1, a2, a3, a4, 0LL, v4, v5, v6);
}

    if ((v17 & 1) == 0) {
      return (*(uint64_t (**)(uint64_t, uint64_t, void))(*(void *)v10 + 72LL))(v10, a2, 0LL);
    }
    a1 = v10;
  }

  if ((*(void *)a2 & 0x80LL) != 0) {
    *(void *)(a2 + 56) = a1;
  }
  return _dispatch_waiter_wake_wlh_anon(a2);
}

  uint64_t v24 = *((_DWORD *)v23 + 21) & 0xF00;
  if (v24 >> 8) {
    BOOL v11 = v24 >> 8;
  }
  else {
    BOOL v11 = (*((_DWORD *)v23 + 21) & 0xF000u) >> 12;
  }
  switch(a2)
  {
    case 0LL:
      return dispatch_apply_attr_query(a1, 1LL, a3) != 0;
    case 1LL:
      if ((a3 & 1) != 0)
      {
        if (a1 && !_dispatch_attr_is_initialized(a1))
        {
          qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: dispatch_apply_attr not initialized using dispatch_apply_attr_init";
          qword_E4DA8 = a1;
          __break(1u);
          JUMPOUT(0x597A4LL);
        }

        if (a1)
        {
          if (v15)
          {
            return 1LL;
          }

          else
          {
            uint64_t v35 = 0;
            if (v11)
            {
              switch(v11)
              {
                case 1u:
                  uint64_t v44 = 5;
                  break;
                case 2u:
                  uint64_t v44 = 9;
                  break;
                case 3u:
                  uint64_t v44 = 17;
                  break;
                case 4u:
                  uint64_t v44 = 21;
                  break;
                case 5u:
                  uint64_t v44 = 25;
                  break;
                case 6u:
                  uint64_t v44 = 33;
                  break;
                default:
                  uint64_t v44 = 0;
                  break;
              }

              uint64_t v35 = pthread_qos_max_parallelism(v44, 0LL);
            }

            if (v35 < 1) {
              uint64_t v36 = MEMORY[0xFFFFFC036];
            }
            else {
              uint64_t v36 = v35;
            }
            if (MEMORY[0xFFFFFC034] < v36) {
              uint64_t v36 = MEMORY[0xFFFFFC034];
            }
            uint64_t v42 = -1LL;
            if (*(void *)(a1 + 8))
            {
              uint64_t v51 = 0;
              switch(v11)
              {
                case 1u:
                  uint64_t v52 = 5;
                  break;
                case 2u:
                  uint64_t v52 = 9;
                  break;
                case 3u:
                  uint64_t v52 = 17;
                  break;
                case 4u:
                  uint64_t v52 = 21;
                  break;
                case 5u:
                  uint64_t v52 = 25;
                  break;
                case 6u:
                  uint64_t v52 = 33;
                  break;
                default:
                  uint64_t v52 = 0;
                  break;
              }

              uint64_t v50 = pthread_qos_max_parallelism(v52, 2LL);
              if (v50 >= 1) {
                uint64_t v51 = v50;
              }
              if (v51) {
                uint64_t v42 = (v51 * *(_DWORD *)(a1 + 8));
              }
              else {
                uint64_t v42 = 0LL;
              }
            }

            if (v36 >= v42) {
              return v42;
            }
            else {
              return v36;
            }
          }
        }

        else
        {
          uint64_t v33 = 0;
          if (v11)
          {
            switch(v11)
            {
              case 1u:
                uint64_t v45 = 5;
                break;
              case 2u:
                uint64_t v45 = 9;
                break;
              case 3u:
                uint64_t v45 = 17;
                break;
              case 4u:
                uint64_t v45 = 21;
                break;
              case 5u:
                uint64_t v45 = 25;
                break;
              case 6u:
                uint64_t v45 = 33;
                break;
              default:
                uint64_t v45 = 0;
                break;
            }

            uint64_t v33 = pthread_qos_max_parallelism(v45, 0LL);
          }

          if (v33 < 1) {
            uint64_t v34 = MEMORY[0xFFFFFC036];
          }
          else {
            uint64_t v34 = v33;
          }
          if (MEMORY[0xFFFFFC034] < v34) {
            uint64_t v34 = MEMORY[0xFFFFFC034];
          }
          int v26 = v34;
          if (v15)
          {
            if (v15 >= v34) {
              return 1LL;
            }
            else {
              return v34 / v15;
            }
          }
        }

        return v26;
      }

      else
      {
        if (a1 && !_dispatch_attr_is_initialized(a1))
        {
          qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: dispatch_apply_attr not initialized using dispatch_apply_attr_init";
          qword_E4DA8 = a1;
          __break(1u);
          JUMPOUT(0x5A4D0LL);
        }

        if (a1)
        {
          uint64_t v39 = pthread_qos_max_parallelism(33LL, 0LL);
          if (v39 < 1) {
            uint64_t v40 = MEMORY[0xFFFFFC036];
          }
          else {
            uint64_t v40 = v39;
          }
          uint64_t v43 = -1LL;
          if (*(void *)(a1 + 8))
          {
            BOOL v49 = 0;
            uint64_t v48 = pthread_qos_max_parallelism(33LL, 2LL);
            if (v48 >= 1) {
              BOOL v49 = v48;
            }
            if (v49) {
              uint64_t v43 = (v49 * *(_DWORD *)(a1 + 8));
            }
            else {
              uint64_t v43 = 0LL;
            }
          }

          if (v40 >= v43) {
            return v43;
          }
          else {
            return v40;
          }
        }

        else
        {
          uint64_t v37 = pthread_qos_max_parallelism(33LL, 0LL);
          if (v37 < 1) {
            return MEMORY[0xFFFFFC036];
          }
          else {
            return v37;
          }
        }
      }

    case 2LL:
      if (a1 && !_dispatch_attr_is_initialized(a1))
      {
        qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: dispatch_apply_attr not initialized using dispatch_apply_attr_init";
        qword_E4DA8 = a1;
        __break(1u);
        JUMPOUT(0x58A6CLL);
      }

      if (a1)
      {
        if (v15)
        {
          return 1LL;
        }

        else
        {
          uint64_t v31 = 0;
          if (v11)
          {
            switch(v11)
            {
              case 1u:
                uint64_t v46 = 5;
                break;
              case 2u:
                uint64_t v46 = 9;
                break;
              case 3u:
                uint64_t v46 = 17;
                break;
              case 4u:
                uint64_t v46 = 21;
                break;
              case 5u:
                uint64_t v46 = 25;
                break;
              case 6u:
                uint64_t v46 = 33;
                break;
              default:
                uint64_t v46 = 0;
                break;
            }

            uint64_t v31 = pthread_qos_max_parallelism(v46, 0LL);
          }

          if (v31 < 1) {
            uint64_t v32 = MEMORY[0xFFFFFC036];
          }
          else {
            uint64_t v32 = v31;
          }
          if (MEMORY[0xFFFFFC034] < v32) {
            uint64_t v32 = MEMORY[0xFFFFFC034];
          }
          uint64_t v41 = -1LL;
          if (*(void *)(a1 + 8))
          {
            uint64_t v54 = 0;
            switch(v11)
            {
              case 1u:
                uint64_t v55 = 5;
                break;
              case 2u:
                uint64_t v55 = 9;
                break;
              case 3u:
                uint64_t v55 = 17;
                break;
              case 4u:
                uint64_t v55 = 21;
                break;
              case 5u:
                uint64_t v55 = 25;
                break;
              case 6u:
                uint64_t v55 = 33;
                break;
              default:
                uint64_t v55 = 0;
                break;
            }

            uint64_t v53 = pthread_qos_max_parallelism(v55, 2LL);
            if (v53 >= 1) {
              uint64_t v54 = v53;
            }
            if (v54) {
              uint64_t v41 = (v54 * *(_DWORD *)(a1 + 8));
            }
            else {
              uint64_t v41 = 0LL;
            }
          }

          if (v32 >= v41) {
            return v41;
          }
          else {
            return v32;
          }
        }
      }

      else
      {
        unint64_t v29 = 0;
        if (v11)
        {
          switch(v11)
          {
            case 1u:
              uint64_t v47 = 5;
              break;
            case 2u:
              uint64_t v47 = 9;
              break;
            case 3u:
              uint64_t v47 = 17;
              break;
            case 4u:
              uint64_t v47 = 21;
              break;
            case 5u:
              uint64_t v47 = 25;
              break;
            case 6u:
              uint64_t v47 = 33;
              break;
            default:
              uint64_t v47 = 0;
              break;
          }

          unint64_t v29 = pthread_qos_max_parallelism(v47, 0LL);
        }

        if (v29 < 1) {
          uint64_t v30 = MEMORY[0xFFFFFC036];
        }
        else {
          uint64_t v30 = v29;
        }
        if (MEMORY[0xFFFFFC034] < v30) {
          uint64_t v30 = MEMORY[0xFFFFFC034];
        }
        unsigned int v27 = v30;
        if (v15)
        {
          if (v15 >= v30) {
            return 1LL;
          }
          else {
            return v30 / v15;
          }
        }
      }

      return v27;
  }

  return v19;
}

  *(_DWORD *)(*(void *)(a1 + 48) + 144LL) = v27;
  if (v27)
  {
    free(*(void **)(a1 + 40));
    _dispatch_io_init(*(void **)(a1 + 48), 0LL, *(void *)(a1 + 56), v27, *(void *)(a1 + 32));
    char v22 = *(unsigned int **)(a1 + 48);
    _dispatch_release(v22);
    _dispatch_release(*(unsigned int **)(a1 + 56));
  }

  else
  {
    object = *(dispatch_object_t *)(*(void *)(a1 + 48) + 48LL);
    dispatch_suspend(object);
    uint64_t v34 = &_dispatch_io_init_pred;
    uint64_t v33 = 0LL;
    uint64_t v32 = _dispatch_io_queues_init;
    if (_dispatch_io_init_pred != -1LL) {
      dispatch_once_f(v34, v33, (dispatch_function_t)v32);
    }
    BOOL v11 = _NSConcreteStackBlock;
    uint64_t v12 = 1107296256;
    uint64_t v13 = 0;
    uint64_t v14 = __dispatch_io_create_with_path_block_invoke_2;
    uint64_t v15 = &__block_descriptor_tmp_7;
    unint64_t v17 = *(void *)(a1 + 40);
    memcpy(v18, &__b, sizeof(v18));
    uint64_t v19 = *(void *)(a1 + 48);
    BOOL v20 = *(void *)(a1 + 56);
    BOOL v16 = *(void *)(a1 + 32);
    dispatch_channel_async((dispatch_queue_t)_dispatch_io_devs_lockq, &v11);
  }

void _dispatch_lane_barrier_sync_invoke_and_complete( uint64_t a1, uint64_t a2, uint64_t (*a3)(uint64_t), uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v39 = a1;
  uint64_t v38 = a2;
  uint64_t v37 = a3;
  __int128 v36 = 0uLL;
  uint64_t v52 = a1;
  uint64_t v51 = &v36;
  uint64_t v54 = &v36;
  _dispatch_thread_getspecific_packed_pair(20LL, 21LL, &v36, a4, a5, a6, a7, a8);
  _dispatch_thread_setspecific_pair(20LL, v52, 21LL, (uint64_t)v51, v8, v9, v10, v11);
  uint64_t v46 = v38;
  uint64_t v45 = v37;
  uint64_t v44 = 0LL;
  else {
    unint64_t v29 = v45;
  }
  uint64_t v44 = v29;
  uint64_t v48 = v46;
  uint64_t v47 = v29;
  int v43 = 0;
  int v42 = 0;
  int v41 = 0;
  int v40 = 0;
  _dispatch_client_callout(v46, v45);
  uint64_t v50 = v46;
  BOOL v49 = v44;
  uint64_t v53 = &v36;
  _dispatch_thread_setspecific_packed_pair(20LL, 21LL, &v36, v12, v13, v14, v15, v16);
  uint64_t v55 = a4;
  unsigned int v60 = 772079660;
  uint64_t v59 = a4;
  uint64_t v58 = 0LL;
  uint64_t v57 = 0LL;
  uint64_t v56 = 0LL;
  if (MEMORY[0xFFFFFC100]) {
    kdebug_trace(v60, v59, v58, v57, v56);
  }
  uint64_t v61 = a4;
  BOOL v28 = 1;
  if (!*(void *)(a1 + 48)) {
    BOOL v28 = *(unsigned __int16 *)(a1 + 80) > 1u;
  }
  if (v28)
  {
    _dispatch_lane_barrier_complete(a1, 0, 0, v17, v18, v19, v20, v21);
  }

  else
  {
    uint64_t v30 = (unint64_t *)(a1 + 56);
    do
    {
      if (_os_atomic_mo_has_acquire(3)) {
        unint64_t v27 = __ldaxr(v30);
      }
      else {
        unint64_t v27 = __ldxr(v30);
      }
      unint64_t v33 = v27;
      unint64_t v32 = (v27 - 0x40020000000000LL) & 0xFFFFFFF000000001LL;
      if ((v27 & 0xFF80008800000001LL) != 0)
      {
        __clrex();
        _dispatch_lane_barrier_complete(a1, 0, 0, v22, v23, v24, v25, v26);
        return;
      }

      if (_os_atomic_mo_has_release(3)) {
        BOOL v31 = __stlxr(v32, v30) == 0;
      }
      else {
        BOOL v31 = __stxr(v32, v30) == 0;
      }
    }

    while (!v31);
    if ((v33 & 0x2000000000LL) != 0) {
      _dispatch_event_loop_assert_not_owned(a1);
    }
  }

void *_dispatch_async_and_wait_invoke( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v36 = a1;
  uint64_t v35 = a1;
  uint64_t v34 = 0LL;
  uint64_t v34 = *(void *)(a1 + 56);
  int v33 = 0;
  int v33 = (*(_BYTE *)(a1 + 106) & 3) << 24;
  uint64_t v32 = 0LL;
  if ((v33 & 0x1000000) != 0) {
    uint64_t v32 = _dispatch_autorelease_pool_push();
  }
  __int128 v31 = 0uLL;
  uint64_t v49 = v34;
  uint64_t v52 = v34;
  uint64_t v51 = &v31;
  uint64_t v50 = v35 + 80;
  uint64_t v53 = &v31;
  _dispatch_thread_getspecific_packed_pair(20LL, 21LL, &v31, a4, a5, a6, a7, a8);
  _dispatch_thread_setspecific_pair(20LL, v52, 21LL, v50, v8, v9, v10, v11);
  uint64_t v12 = *(uint64_t (**)(uint64_t))(v35 + 64);
  uint64_t v43 = *(void *)(v35 + 72);
  int v42 = v12;
  int v41 = 0LL;
  else {
    uint64_t v30 = v42;
  }
  int v41 = v30;
  uint64_t v45 = v43;
  uint64_t v44 = v30;
  int v40 = 0;
  int v39 = 0;
  int v38 = 0;
  int v37 = 0;
  _dispatch_client_callout(v43, v42);
  uint64_t v47 = v43;
  uint64_t v46 = v41;
  uint64_t v48 = &v31;
  _dispatch_thread_setspecific_packed_pair(20LL, 21LL, &v31, v13, v14, v15, v16, v17);
  if (v32) {
    _dispatch_autorelease_pool_pop(v32);
  }
  uint64_t result = _dispatch_thread_getspecific(0x14uLL);
  *(void *)(v35 + 56) = result;
  *(void *)(v35 + 64) = 0LL;
  if (*(void *)(v35 + 48) != -4LL) {
    return (void *)_dispatch_event_loop_cancel_waiter(v35, v19, v20, v21, v22, v23, v24, v25);
  }
  uint64_t v60 = v35 + 96;
  unsigned int v59 = 0;
  BOOL v28 = (unsigned int *)(v35 + 96);
  int v57 = 1;
  int v56 = 1;
  int v58 = 1;
  unsigned int v29 = *(_DWORD *)(v35 + 96);
  do
  {
    unsigned int v26 = v29;
    do
      unsigned int v27 = __ldaxr(v28);
    while (v27 == v29 && __stlxr(v29 + 1, v28));
    unsigned int v29 = v27;
  }

  while (v27 != v26);
  unsigned int v55 = v27;
  unsigned int v59 = v27;
  unsigned int v54 = v27;
  if (v27) {
    return (void *)_dispatch_thread_event_signal_slow(v60);
  }
  return result;
}

uint64_t __DISPATCH_WAIT_FOR_QUEUE__(uint64_t a1, uint64_t a2)
{
  int v38 = (unint64_t *)(a2 + 56);
  do
  {
    if (_os_atomic_mo_has_acquire(0)) {
      unint64_t v7 = __ldaxr(v38);
    }
    else {
      unint64_t v7 = __ldxr(v38);
    }
    if ((v7 & 0xFF80000000000000LL) != 0 || (v7 & 0x2000000000LL) == 0 || (v7 & 2) == 0)
    {
      __clrex();
      uint64_t v41 = v7;
      goto LABEL_14;
    }

    unint64_t v40 = v7 | 0x800000000LL;
    if (_os_atomic_mo_has_release(0)) {
      BOOL v39 = __stlxr(v40, v38) == 0;
    }
    else {
      BOOL v39 = __stxr(v40, v38) == 0;
    }
  }

  while (!v39);
  uint64_t v41 = v40;
LABEL_14:
  if (((v41 ^ *(_DWORD *)(a1 + 100)) & 0xFFFFFFFC) == 0)
  {
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: dispatch_sync called on queue already owned by current thread";
    qword_E4DA8 = v41;
    __break(1u);
    JUMPOUT(0x46328LL);
  }

  _dispatch_thread_getspecific_packed_pair(20LL, 21LL, (_OWORD *)(a1 + 80), v2, v3, v4, v5, v6);
  if ((v41 & 0xFF80000000000000LL) != 0 || (v41 & 0x1000000000LL) != 0)
  {
    *(void *)(a1 + 48) = -4LL;
  }

  else if ((v41 & 0x2000000000LL) != 0)
  {
    *(void *)(a1 + 48) = a2;
  }

  else
  {
    _dispatch_wait_compute_wlh(a2, a1);
  }

  if (*(void *)(a1 + 48) == -4LL)
  {
    unsigned int v37 = _dispatch_thread_getspecific(0x19uLL);
    unsigned int v36 = (unsigned __int16)(v37 & 0xF00) >> 8;
    unsigned int v35 = (unsigned __int16)(v37 & 0xF000) >> 12;
    if (v36 <= v35) {
      unsigned int v30 = (unsigned __int16)(v37 & 0xF000) >> 12;
    }
    else {
      unsigned int v30 = (unsigned __int16)(v37 & 0xF00) >> 8;
    }
    if (v30 <= (v37 & 0xF0000) >> 16)
    {
      char v28 = (v37 & 0xF0000) >> 16;
    }

    else
    {
      if (v36 <= v35) {
        int v29 = (unsigned __int16)(v37 & 0xF000) >> 12;
      }
      else {
        int v29 = (unsigned __int16)(v37 & 0xF00) >> 8;
      }
      char v28 = v29;
    }

    *(_BYTE *)(a1 + 105) = v28;
    *(_BYTE *)(a1 + 104) = v28;
    *(_DWORD *)(a1 + 96) = 0;
  }

  _dispatch_thread_setspecific(121LL, a1);
  unint64_t v33 = (*(void *)(a1 + 8) & 0x3FFF00uLL) >> 8;
  unsigned int v8 = __clz(__rbit32(v33));
  if ((_DWORD)v33) {
    uint64_t v9 = v8 + 1;
  }
  else {
    uint64_t v9 = 0LL;
  }
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)a2 + 72LL))(a2, a1, v9);
  if (*(void *)(a1 + 48) == -4LL)
  {
    unsigned int v26 = (unsigned int *)(a1 + 96);
    unsigned int v27 = *(_DWORD *)(a1 + 96);
    do
    {
      unsigned int v17 = v27;
      do
        unsigned int v18 = __ldaxr(v26);
      while (v18 == v27 && __stlxr(v27 - 1, v26));
      unsigned int v27 = v18;
    }

    while (v18 != v17);
    if (v18 != 1) {
      _dispatch_thread_event_wait_slow(a1 + 96);
    }
  }

  else if ((*(_BYTE *)(a1 + 106) & 8) == 0)
  {
    _dispatch_event_loop_wait_for_ownership(a1, v10, v11, v12, v13, v14, v15, v16);
  }

  uint64_t result = _dispatch_thread_setspecific(121LL, 0LL);
  if (*(void *)(a1 + 48) == -4LL)
  {
    if (*(_DWORD *)(a1 + 96)) {
      _dispatch_abort(339LL, *(_DWORD *)(a1 + 96) == 0, v20, v21, v22, v23, v24, v25);
    }
    if (*(unsigned __int8 *)(a1 + 105) > (int)*(unsigned __int8 *)(a1 + 104))
    {
      unsigned int v34 = *(unsigned __int8 *)(a1 + 105);
      uint64_t result = (uint64_t)_dispatch_thread_getspecific(0x19uLL);
    }
  }

  return result;
}

void _dispatch_sync_complete_recurse(uint64_t a1, uint64_t a2, char a3)
{
  BOOL v3 = (a3 & 2) != 0;
  do
  {
    if (a1 == a2) {
      break;
    }
    if (v3) {
      (*(void (**)(uint64_t, void, uint64_t))(*(void *)a1 + 64LL))(a1, 0LL, 4LL);
    }
    else {
      _dispatch_lane_non_barrier_complete(a1, 0);
    }
    a1 = *(void *)(a1 + 24);
    BOOL v3 = *(unsigned __int16 *)(a1 + 80) == 1;
  }

  while (*(void *)(a1 + 24));
}

void _dispatch_sync_invoke_and_complete_recurse( uint64_t a1, uint64_t a2, uint64_t (*a3)(uint64_t), uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  char v19 = a4;
  uint64_t v24 = a1;
  uint64_t v23 = a2;
  uint64_t v22 = a3;
  __int128 v21 = 0uLL;
  uint64_t v37 = a1;
  unsigned int v36 = &v21;
  BOOL v39 = &v21;
  _dispatch_thread_getspecific_packed_pair(20LL, 21LL, &v21, a4, a5, a6, a7, a8);
  _dispatch_thread_setspecific_pair(20LL, v37, 21LL, (uint64_t)v36, v8, v9, v10, v11);
  uint64_t v31 = v23;
  unsigned int v30 = v22;
  int v29 = 0LL;
  else {
    unsigned int v17 = v30;
  }
  int v29 = v17;
  uint64_t v33 = v31;
  uint64_t v32 = v17;
  int v28 = 0;
  int v27 = 0;
  int v26 = 0;
  int v25 = 0;
  _dispatch_client_callout(v31, v30);
  uint64_t v35 = v31;
  unsigned int v34 = v29;
  int v38 = &v21;
  _dispatch_thread_setspecific_packed_pair(20LL, 21LL, &v21, v12, v13, v14, v15, v16);
  uint64_t v40 = a5;
  unsigned int v45 = 772079660;
  uint64_t v44 = a5;
  uint64_t v43 = 0LL;
  uint64_t v42 = 0LL;
  uint64_t v41 = 0LL;
  if (MEMORY[0xFFFFFC100]) {
    kdebug_trace(v45, v44, v43, v42, v41);
  }
  uint64_t v46 = a5;
  _dispatch_sync_complete_recurse(a1, 0LL, v19);
}

uint64_t _dispatch_wait_compute_wlh(uint64_t a1, uint64_t a2)
{
  int v22 = *(_DWORD *)(a1 + 80);
  if ((v22 & 0x400000) != 0)
  {
    *(_BYTE *)(a2 + 106) |= 0x40u;
    int v28 = (unsigned int *)(a1 + 100);
    unsigned int v27 = _dispatch_thread_getspecific(3uLL) & 0xFFFFFFFC;
    uint64_t v2 = (unsigned int *)(a1 + 100);
    do
      unsigned int v3 = __ldaxr(v2);
    while (!v3 && __stlxr(v27, v2));
    if (v3) {
      _dispatch_unfair_lock_lock_slow(v28, 0x10000);
    }
  }

  char v19 = *(_DWORD **)(a1 + 24);
  uint64_t v23 = (unint64_t *)(v19 + 14);
  do
  {
    uint64_t result = _os_atomic_mo_has_acquire(0);
    if ((_DWORD)result) {
      unint64_t v5 = __ldaxr(v23);
    }
    else {
      unint64_t v5 = __ldxr(v23);
    }
    if ((v5 & 0xFF80000000000000LL) != 0 || (v5 & 0x2000000000LL) == 0 || (v5 & 2) == 0)
    {
      __clrex();
      int v26 = HIDWORD(v5);
      goto LABEL_20;
    }

    unint64_t v25 = v5 | 0x800000000LL;
    uint64_t result = _os_atomic_mo_has_release(0);
    if ((_DWORD)result) {
      BOOL v24 = __stlxr(v25, v23) == 0;
    }
    else {
      BOOL v24 = __stxr(v25, v23) == 0;
    }
  }

  while (!v24);
  int v26 = HIDWORD(v25);
LABEL_20:
  if ((v26 & 0xFF800000) != 0 || (v26 & 0x10) != 0)
  {
    *(_BYTE *)(a2 + 106) &= ~0x40u;
    *(void *)(a2 + 48) = -4LL;
  }

  else if ((v26 & 0x20) != 0)
  {
    if (*(_BYTE *)(*(void *)v19 + 16LL) == 18LL)
    {
      *(_BYTE *)(a2 + 106) |= 0x10u;
      *(_BYTE *)(a2 + 106) &= ~0x40u;
    }

    else if ((*(_BYTE *)(a2 + 106) & 0x40) != 0)
    {
      unsigned int v17 = v19 + 24;
      unsigned int v18 = v19[24];
      do
      {
        unsigned int v6 = v18;
        do
          unsigned int v7 = __ldaxr(v17);
        while (v7 == v18 && __stlxr(v18 + 1, v17));
        unsigned int v18 = v7;
      }

      while (v7 != v6);
      if ((int)(v7 + 1) <= 0)
      {
        qword_E4D78 = (uint64_t)"API MISUSE: Resurrection of an object";
        __break(1u);
        JUMPOUT(0x470ACLL);
      }
    }

    *(void *)(a2 + 48) = v19;
  }

  else
  {
    uint64_t result = _dispatch_wait_compute_wlh(v19, a2);
  }

  if ((v22 & 0x400000) != 0)
  {
    if ((*(_BYTE *)(a2 + 106) & 0x10) != 0)
    {
      uint64_t v15 = (unsigned int *)(a1 + 80);
      unsigned int v16 = *(_DWORD *)(a1 + 80);
      do
      {
        unsigned int v8 = v16;
        do
          unsigned int v9 = __ldaxr(v15);
        while (v9 == v16 && __stlxr(v16 & 0xFFBFFFFF, v15));
        unsigned int v16 = v9;
      }

      while (v9 != v8);
    }

    uint64_t result = (uint64_t)_dispatch_thread_getspecific(3uLL);
    uint64_t v13 = (unsigned int *)(a1 + 100);
    unsigned int v14 = *(_DWORD *)(a1 + 100);
    do
    {
      unsigned int v10 = v14;
      do
        unsigned int v11 = __ldaxr(v13);
      while (v11 == v14 && __stlxr(0, v13));
      char v12 = v11;
      unsigned int v14 = v11;
    }

    while (v11 != v10);
    if (v11 == (result & 0xFFFFFFFC))
    {
      BOOL v29 = 0;
    }

    else
    {
      uint64_t result = (uint64_t)_dispatch_unfair_lock_unlock_slow(a1 + 100, v11);
      BOOL v29 = (v12 & 2) != 0;
    }

    if (v29)
    {
      uint64_t result = (uint64_t)_dispatch_thread_getspecific(0x19uLL);
    }
  }

  return result;
}

void _dispatch_sync_invoke_and_complete( uint64_t a1, uint64_t a2, uint64_t (*a3)(uint64_t), uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v23 = a1;
  uint64_t v22 = a2;
  __int128 v21 = a3;
  __int128 v20 = 0uLL;
  uint64_t v36 = a1;
  uint64_t v35 = &v20;
  int v38 = &v20;
  _dispatch_thread_getspecific_packed_pair(20LL, 21LL, &v20, a4, a5, a6, a7, a8);
  _dispatch_thread_setspecific_pair(20LL, v36, 21LL, (uint64_t)v35, v8, v9, v10, v11);
  uint64_t v30 = v22;
  BOOL v29 = v21;
  int v28 = 0LL;
  else {
    unsigned int v17 = v29;
  }
  int v28 = v17;
  uint64_t v32 = v30;
  uint64_t v31 = v17;
  int v27 = 0;
  int v26 = 0;
  int v25 = 0;
  int v24 = 0;
  _dispatch_client_callout(v30, v29);
  uint64_t v34 = v30;
  uint64_t v33 = v28;
  uint64_t v37 = &v20;
  _dispatch_thread_setspecific_packed_pair(20LL, 21LL, &v20, v12, v13, v14, v15, v16);
  uint64_t v39 = a4;
  unsigned int v44 = 772079660;
  uint64_t v43 = a4;
  uint64_t v42 = 0LL;
  uint64_t v41 = 0LL;
  uint64_t v40 = 0LL;
  if (MEMORY[0xFFFFFC100]) {
    kdebug_trace(v44, v43, v42, v41, v40);
  }
  uint64_t v45 = a4;
  _dispatch_lane_non_barrier_complete(a1, 0);
}

void _dispatch_async_and_wait_recurse(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  uint64_t v10 = a1;
  for (uint64_t i = a4; ; *(void *)a2 = i)
  {
    char v8 = 1;
    if ((*(_DWORD *)(v10 + 80) & 0x1000000) == 0)
    {
      char v7 = 0;
      if ((*(void *)(v10 + 56) & 0x3000000000LL) != 0)
      {
        BOOL v6 = 0;
        char v7 = !v6;
      }

      char v8 = v7;
    }

    if ((v8 & 1) != 0)
    {
      *(void *)a2 &= ~0x80uLL;
      *(void *)(a2 + 56) = v10;
      BOOL v15 = 0;
    }

    else if ((i & 2) != 0)
    {
      uint64_t v19 = (4096LL - *(unsigned __int16 *)(v10 + 80)) << 41;
      BOOL v17 = 0;
      uint64_t v16 = (unint64_t *)(v10 + 56);
      while (1)
      {
        unint64_t v4 = _os_atomic_mo_has_acquire(2) ? __ldaxr(v16) : __ldxr(v16);
        if (v4 != (v19 | v4 & 0x3000000000LL)) {
          break;
        }
        unint64_t v18 = a3 & 0xFFFFFFFC | 0x60000000000002LL | v4 & 0x3000000000LL;
        if (_os_atomic_mo_has_release(2)) {
          BOOL v17 = __stlxr(v18, v16) == 0;
        }
        else {
          BOOL v17 = __stxr(v18, v16) == 0;
        }
        if (v17) {
          goto LABEL_21;
        }
      }

      __clrex();
LABEL_21:
      BOOL v15 = v17;
    }

    else
    {
      if (*(void *)(v10 + 48))
      {
        char v23 = 0;
      }

      else
      {
        __int128 v20 = (unint64_t *)(v10 + 56);
        do
        {
          if (_os_atomic_mo_has_acquire(0)) {
            unint64_t v5 = __ldaxr(v20);
          }
          else {
            unint64_t v5 = __ldxr(v20);
          }
          if (v5 >= 0x40000000000000LL || (v5 & 0x8000000000LL) != 0 || (v5 & 0x10000000000LL) != 0)
          {
            __clrex();
            char v23 = 0;
            goto LABEL_37;
          }

          unint64_t v22 = v5 + 0x20000000000LL;
          if (_os_atomic_mo_has_release(0)) {
            BOOL v21 = __stlxr(v22, v20) == 0;
          }
          else {
            BOOL v21 = __stxr(v22, v20) == 0;
          }
        }

        while (!v21);
        char v23 = 1;
      }

LABEL_37:
      BOOL v15 = v23;
    }

    if (!v15)
    {
      _dispatch_async_and_wait_f_slow(a1, a4, a2, v10);
      return;
    }

    if ((*(_DWORD *)(v10 + 84) & 0xFFF) != 0)
    {
      unsigned int v25 = (*(_DWORD *)(v10 + 84) & 0xF00u) >> 8;
      unint64_t v24 = *(unsigned __int8 *)(v10 + 84);
      if (v25) {
        unint64_t v24 = *(unsigned __int8 *)(v10 + 84) | (unint64_t)(1LL << (v25 + 7));
      }
      if (v24 > (*(void *)(a2 + 8) & 0xFFFFFFuLL)) {
        *(void *)(a2 + 8) = v24 | 0x10000000;
      }
    }

    if ((*(_BYTE *)(a2 + 106) & 3) == 0) {
      *(_BYTE *)(a2 + 106) = *(_BYTE *)(a2 + 106) & 0xFC | ((*(_DWORD *)(v10 + 80) & 0x30000u) / 0x10000) & 3;
    }
    if (!*(void *)(*(void *)(v10 + 24) + 24LL)) {
      break;
    }
    uint64_t v10 = *(void *)(v10 + 24);
    if (*(_WORD *)(v10 + 80) == 1) {
      i |= 2uLL;
    }
    else {
      i &= ~2uLL;
    }
  }

  _dispatch_async_and_wait_invoke_and_complete_recurse(a1, a2, v10, a4);
}

void _dispatch_async_and_wait_f_slow(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (*(void *)(a3 + 64)) {
    _dispatch_async_and_wait_invoke_and_complete_recurse(a1, a3, *(void *)(a3 + 56), a2);
  }
  else {
    _dispatch_sync_complete_recurse(a1, *(void *)(a3 + 56), a2);
  }
}

void _dispatch_async_and_wait_invoke_and_complete_recurse(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v44 = a1;
  uint64_t v43 = a2;
  uint64_t v42 = a3;
  uint64_t v41 = a4;
  int v40 = 0;
  uint64_t v39 = 0LL;
  uint64_t v128 = a3;
  uint64_t v127 = -4LL;
  if (*(_BYTE *)(*(void *)a3 + 16LL) == 18LL
    || (v126 = 0LL, v125 = *(void *)(v128 + 56), v126 = v125, uint64_t v124 = v125, v129 = v125, (v125 & 0x2000000000LL) != 0))
  {
    uint64_t v127 = v128;
  }

  unint64_t v123 = _dispatch_thread_getspecific(0x1BuLL);
  _dispatch_thread_setspecific(27LL, v127);
  uint64_t v39 = (uint64_t)v123;
  int v40 = (*(_BYTE *)(v43 + 106) & 3) << 24;
  uint64_t v38 = 0LL;
  if ((v40 & 0x1000000) != 0) {
    uint64_t v38 = _dispatch_autorelease_pool_push();
  }
  uint64_t v37 = 0x40000000LL;
  __int128 v36 = 0uLL;
  uint64_t v34 = *(void *)(v43 + 8);
  uint64_t v32 = *(void *)(v43 + 24);
  uint64_t v122 = v44;
  uint64_t v119 = v44;
  uint64_t v118 = &v36;
  uint64_t v121 = &v36;
  _dispatch_thread_getspecific_packed_pair(20LL, 21LL, &v36, v4, v5, v6, v7, v8);
  _dispatch_thread_setspecific_pair(20LL, v119, 21LL, (uint64_t)v118, v9, v10, v11, v12);
  uint64_t v48 = v37;
  unint64_t v47 = v34;
  unint64_t v46 = 0LL;
  uint64_t v45 = 0LL;
  if ((v37 & 0x40000000) != 0 && ((v48 & 0x20) != 0 || (v48 & 0x10) == 0))
  {
    unint64_t v51 = v47;
    v47 &= 0xFFFFFFu;
    uint64_t v49 = 0LL;
    uint64_t v49 = _dispatch_thread_getspecific(4uLL);
    uint64_t v50 = v49;
    unint64_t v46 = v49 & 0xFFFFFF;
  }

  uint64_t v35 = v45;
  if (v45) {
    uint64_t v31 = v34;
  }
  else {
    uint64_t v31 = 0LL;
  }
  uint64_t v55 = v31;
  uint64_t v54 = v32;
  uint64_t v53 = 0LL;
  uint64_t v100 = v31;
  BOOL v113 = v31 != -1;
  uint64_t v112 = 2395LL;
  if (v31 == -1) {
    _dispatch_abort(v112, v113, v13, v14, v15, v16, v17, v18);
  }
  if ((_dispatch_set_qos_class_enabled & 1) != 0)
  {
    uint64_t v111 = v100;
    uint64_t v110 = 4261412863LL;
    uint64_t v109 = 0LL;
    v100 &= 0xFFFFFFFF02FFFFFFLL;
    unint64_t v99 = 0LL;
    unsigned int v102 = 0LL;
    unsigned int v102 = _dispatch_thread_getspecific(4uLL);
    unint64_t v99 = (unint64_t)v102;
    uint64_t v98 = 0x1000000LL;
    uint64_t v97 = 2281701376LL;
    if ((v102 & 0x1000000) != 0)
    {
      if (v100)
      {
        uint64_t v30 = v100;
      }

      else
      {
        unint64_t v108 = v99;
        uint64_t v107 = v98;
        uint64_t v106 = 0LL;
        uint64_t v30 = v99 & (~v98 | 0xFFFFFF);
      }

      uint64_t v101 = v30;
    }

    else
    {
      unint64_t v105 = v99;
      uint64_t v104 = v97;
      uint64_t v103 = 0LL;
      v99 &= ~v97 | 0xFFFFFF;
      if (v100 == v99) {
        uint64_t v101 = 0LL;
      }
      else {
        uint64_t v101 = v100;
      }
    }
  }

  else
  {
    uint64_t v101 = 0LL;
  }

  uint64_t v55 = v101;
  if (!v101)
  {
    if (v54 == -1)
    {
      uint64_t v56 = -1LL;
      goto LABEL_41;
    }

    BOOL v29 = (void *)v54;
    if (v29 == _dispatch_thread_getspecific(0x1CuLL))
    {
      BOOL v52 = (v53 & 4) != 0;
      if ((v53 & 2) != 0)
      {
        if (v52 && v54)
        {
          object = (void *)v54;
          os_release((void *)v54);
        }

        uint64_t v54 = -1LL;
      }

      else if (!v52 && v54)
      {
        int v58 = (void *)v54;
        os_retain((void *)v54);
      }

      uint64_t v56 = v54;
      goto LABEL_41;
    }
  }

  uint64_t v56 = _dispatch_set_priority_and_voucher_slow(v55, (_DWORD *)v54, v53);
LABEL_41:
  uint64_t v33 = v56;
  uint64_t v78 = v44;
  uint64_t v77 = v43;
  int v76 = 0;
  int v75 = 0;
  uint64_t v132 = v44;
  uint64_t v131 = v43;
  uint64_t v19 = *(uint64_t (**)(uint64_t))(v43 + 64);
  uint64_t v65 = *(void *)(v43 + 72);
  uint64_t v64 = v19;
  unsigned int v63 = 0LL;
  else {
    int v28 = v64;
  }
  unsigned int v63 = v28;
  uint64_t v115 = v65;
  int v114 = v28;
  int v62 = 0;
  int v61 = 0;
  int v60 = 0;
  int v59 = 0;
  _dispatch_client_callout(v65, v64);
  uint64_t v117 = v65;
  uint64_t v116 = v63;
  uint64_t v67 = v35;
  uint64_t v66 = v33;
  if (v35 == -1) {
    uint64_t v67 = 0LL;
  }
  uint64_t v71 = v67;
  uint64_t v70 = v66;
  uint64_t v69 = 6LL;
  uint64_t v83 = v67;
  BOOL v96 = v67 != -1;
  uint64_t v95 = 2395LL;
  if (v67 == -1) {
    _dispatch_abort(v95, v96, v20, v21, v22, v23, v24, v25);
  }
  if ((_dispatch_set_qos_class_enabled & 1) != 0)
  {
    uint64_t v94 = v83;
    uint64_t v93 = 4261412863LL;
    uint64_t v92 = 0LL;
    v83 &= 0xFFFFFFFF02FFFFFFLL;
    unint64_t v82 = 0LL;
    unsigned int v85 = 0LL;
    unsigned int v85 = _dispatch_thread_getspecific(4uLL);
    unint64_t v82 = (unint64_t)v85;
    uint64_t v81 = 0x1000000LL;
    uint64_t v80 = 2281701376LL;
    if ((v85 & 0x1000000) != 0)
    {
      if (v83)
      {
        uint64_t v27 = v83;
      }

      else
      {
        unint64_t v91 = v82;
        uint64_t v90 = v81;
        uint64_t v89 = 0LL;
        uint64_t v27 = v82 & (~v81 | 0xFFFFFF);
      }

      uint64_t v84 = v27;
    }

    else
    {
      unint64_t v88 = v82;
      uint64_t v87 = v80;
      uint64_t v86 = 0LL;
      v82 &= ~v80 | 0xFFFFFF;
      if (v83 == v82) {
        uint64_t v84 = 0LL;
      }
      else {
        uint64_t v84 = v83;
      }
    }
  }

  else
  {
    uint64_t v84 = 0LL;
  }

  uint64_t v71 = v84;
  if (v84) {
    goto LABEL_72;
  }
  if (v70 == -1)
  {
    uint64_t v72 = -1LL;
    goto LABEL_73;
  }

  int v26 = (void *)v70;
  if (v26 != _dispatch_thread_getspecific(0x1CuLL))
  {
LABEL_72:
    uint64_t v72 = _dispatch_set_priority_and_voucher_slow(v71, (_DWORD *)v70, v69);
  }

  else
  {
    BOOL v68 = (v69 & 4) != 0;
    if ((v69 & 2) != 0)
    {
      if (v68 && v70)
      {
        unsigned int v73 = (void *)v70;
        os_release((void *)v70);
      }

      uint64_t v70 = -1LL;
    }

    else if (!v68 && v70)
    {
      signed int v74 = (void *)v70;
      os_retain((void *)v70);
    }

    uint64_t v72 = v70;
  }

LABEL_73:
  uint64_t v120 = &v36;
  _dispatch_thread_setspecific_packed_pair(20LL, 21LL, &v36, v21, v22, v23, v24, v25);
  if (v38) {
    _dispatch_autorelease_pool_pop(v38);
  }
  uint64_t v79 = v43;
  uint64_t v133 = v43;
  unsigned int v138 = 772079660;
  uint64_t v137 = v43;
  uint64_t v136 = 0LL;
  uint64_t v135 = 0LL;
  uint64_t v134 = 0LL;
  if (MEMORY[0xFFFFFC100]) {
    kdebug_trace(v138, v137, v136, v135, v134);
  }
  uint64_t v139 = v79;
  uint64_t v130 = v39;
  _dispatch_thread_setspecific(27LL, v39);
  _dispatch_sync_complete_recurse(v44, 0LL, v41);
}

void _dispatch_queue_specific_head_dispose(void *a1)
{
  uint64_t v7 = a1;
  uint64_t v6 = &off_E4640;
  uint64_t i = 0LL;
  uint64_t v4 = 0LL;
  uint64_t v2 = 0LL;
  unsigned int v3 = (void **)&v2;
  if (a1[1])
  {
    *unsigned int v3 = (void *)v7[1];
    *(void *)(v7[1] + 32LL) = v3;
    unsigned int v3 = (void **)v7[2];
    v7[1] = 0LL;
    v7[2] = v7 + 1;
  }

  for (uint64_t i = v2; ; uint64_t i = v4)
  {
    char v1 = 0;
    if (i)
    {
      uint64_t v4 = (void *)i[3];
      char v1 = 1;
    }

    if ((v1 & 1) == 0) {
      break;
    }
    if (i[2])
    {
      i[3] = 0LL;
      i[4] = v7[2];
      *(void *)v7[2] = i;
      v7[2] = i + 3;
    }

    else
    {
      free(i);
    }
  }

  if (v7[1]) {
    _dispatch_barrier_async_detached_f((uint64_t)v6, (uint64_t)v7, (uint64_t)_dispatch_queue_specific_head_dispose_slow);
  }
  else {
    free(v7);
  }
}

void _dispatch_queue_specific_head_dispose_slow( void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = 0LL;
  for (uint64_t i = (void *)a1[1]; ; uint64_t i = v9)
  {
    char v8 = 0;
    if (i)
    {
      uint64_t v9 = (void *)i[3];
      char v8 = 1;
    }

    if ((v8 & 1) == 0) {
      break;
    }
    if (!i[2]) {
      _dispatch_abort(2313LL, 0LL, a3, a4, a5, a6, a7, a8);
    }
    uint64_t v13 = i[1];
    uint64_t v12 = (void (*)(void (**)(void)))i[2];
    if (v12 == _dispatch_call_block_and_release)
    {
      if (v13) {
        _Block_get_invoke_fn(v13);
      }
    }

    _dispatch_client_callout(v13, (uint64_t (*)(uint64_t))v12);
    free(i);
  }

  free(a1);
}

uint64_t _dispatch_non_barrier_waiter_redirect_or_wake( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if ((*(void *)a2 & 2LL) != 0) {
    _dispatch_abort(1211LL, (*(void *)a2 & 2LL) == 0, a3, a4, a5, a6, a7, a8);
  }
  while (1)
  {
    uint64_t v11 = *(void *)(a1 + 56);
    if ((*(void *)a2 & 0x80LL) != 0)
    {
      if ((*(_DWORD *)(a1 + 84) & 0xFFF) != 0)
      {
        unsigned int v19 = (*(_DWORD *)(a1 + 84) & 0xF00u) >> 8;
        unint64_t v18 = *(unsigned __int8 *)(a1 + 84);
        if (v19) {
          unint64_t v18 = *(unsigned __int8 *)(a1 + 84) | (unint64_t)(1LL << (v19 + 7));
        }
        if (v18 > (*(void *)(a2 + 8) & 0xFFFFFFuLL)) {
          *(void *)(a2 + 8) = v18 | 0x10000000;
        }
      }

      if ((*(_BYTE *)(a2 + 106) & 3) == 0) {
        *(_BYTE *)(a2 + 106) = *(_BYTE *)(a2 + 106) & 0xFC | ((*(_DWORD *)(a1 + 80) & 0x30000u) / 0x10000) & 3;
      }
    }

    if ((v11 & 0x3000000000LL) != 0) {
      break;
    }
    uint64_t v10 = *(void *)(a1 + 24);
    if (*(_WORD *)(v10 + 80) == 1)
    {
      *(void *)a2 |= 2uLL;
      return (*(uint64_t (**)(uint64_t, uint64_t, void))(*(void *)v10 + 72LL))(v10, a2, 0LL);
    }

    *(void *)a2 &= ~2uLL;
    if (*(void *)(v10 + 48))
    {
      char v17 = 0;
    }

    else
    {
      uint64_t v14 = (unint64_t *)(v10 + 56);
      do
      {
        if (_os_atomic_mo_has_acquire(0)) {
          unint64_t v8 = __ldaxr(v14);
        }
        else {
          unint64_t v8 = __ldxr(v14);
        }
        if (v8 >= 0x40000000000000LL || (v8 & 0x8000000000LL) != 0 || (v8 & 0x10000000000LL) != 0)
        {
          __clrex();
          char v17 = 0;
          goto LABEL_31;
        }

        unint64_t v16 = v8 + 0x20000000000LL;
        if (_os_atomic_mo_has_release(0)) {
          BOOL v15 = __stlxr(v16, v14) == 0;
        }
        else {
          BOOL v15 = __stxr(v16, v14) == 0;
        }
      }

      while (!v15);
      char v17 = 1;
    }

uint64_t _dispatch_waiter_wake_wlh_anon(uint64_t result)
{
  uint64_t v5 = result;
  if (*(unsigned __int8 *)(result + 105) > (int)*(unsigned __int8 *)(result + 104)
    && (_dispatch_set_qos_class_enabled & 1) != 0)
  {
    uint64_t v6 = 0LL;
    if (*(_BYTE *)(result + 105)) {
      uint64_t v6 = 1LL << (*(_BYTE *)(result + 105) + 7);
    }
    uint64_t result = _pthread_workqueue_override_start_direct(*(unsigned int *)(result + 100), v6 | 0xFF);
  }

  unsigned int v3 = (unsigned int *)(v5 + 96);
  unsigned int v4 = *(_DWORD *)(v5 + 96);
  do
  {
    unsigned int v1 = v4;
    do
      unsigned int v2 = __ldaxr(v3);
    while (v2 == v4 && __stlxr(v4 + 1, v3));
    unsigned int v4 = v2;
  }

  while (v2 != v1);
  if (v2) {
    return _dispatch_thread_event_signal_slow(v5 + 96);
  }
  return result;
}

void _dispatch_barrier_waiter_redirect_or_wake( uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, unint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  char v16 = a3;
  uint64_t v11 = -4LL;
  if ((a4 & 0x2000000000LL) != 0)
  {
    uint64_t v11 = a1;
  }

  else
  {
    BOOL v9 = 0;
    if ((a4 & 0x1000000000LL) != 0) {
      BOOL v9 = (a4 & 0x800000000LL) != 0;
    }
    if (v9)
    {
      unsigned int v18 = _dispatch_thread_getspecific(0x19uLL);
      if ((BYTE4(a4) & 7u) > (v18 & 0xF0000) >> 16) {
        _dispatch_thread_setspecific(25LL, v18 & 0xFFF0FFFF | ((BYTE4(a4) & 7) << 16));
      }
    }
  }

  if ((v16 & 1) != 0)
  {
    if ((a4 & 0x2000000000LL) == 0 || (a5 & 1) == 0)
    {
      _dispatch_release_2_no_dispose(a1);
      goto LABEL_19;
    }

    goto LABEL_18;
  }

  if ((a4 & 0x2000000000LL) != 0 && (a4 & 1) != 0 && (a5 & 1) == 0) {
LABEL_18:
  }
    _dispatch_release_no_dispose(a1);
LABEL_19:
  if ((a4 & 0x3000000000LL) != 0)
  {
    if ((*(void *)a2 & 0x80LL) != 0) {
      *(void *)(a2 + 56) = a1;
    }
    _dispatch_waiter_wake(a2, v11, a4, a5);
  }

  else
  {
    uint64_t v10 = *(void *)(a1 + 24);
    if ((*(void *)a2 & 0x80LL) != 0)
    {
      if ((*(_DWORD *)(a1 + 84) & 0xFFF) != 0)
      {
        unsigned int v24 = (*(_DWORD *)(a1 + 84) & 0xF00u) >> 8;
        unint64_t v23 = *(unsigned __int8 *)(a1 + 84);
        if (v24) {
          unint64_t v23 = *(unsigned __int8 *)(a1 + 84) | (unint64_t)(1LL << (v24 + 7));
        }
        if (v23 > (*(void *)(a2 + 8) & 0xFFFFFFuLL)) {
          *(void *)(a2 + 8) = v23 | 0x10000000;
        }
      }

      if ((*(_BYTE *)(a2 + 106) & 3) == 0) {
        *(_BYTE *)(a2 + 106) = *(_BYTE *)(a2 + 106) & 0xFC | ((*(_DWORD *)(a1 + 80) & 0x30000u) / 0x10000) & 3;
      }
    }

    if (*(_WORD *)(v10 + 80) == 1)
    {
      *(void *)a2 |= 2uLL;
    }

    else
    {
      *(void *)a2 &= ~2uLL;
      if (*(void *)(v10 + 48))
      {
        char v22 = 0;
      }

      else
      {
        unsigned int v19 = (unint64_t *)(v10 + 56);
        do
        {
          if (_os_atomic_mo_has_acquire(0)) {
            unint64_t v8 = __ldaxr(v19);
          }
          else {
            unint64_t v8 = __ldxr(v19);
          }
          if (v8 >= 0x40000000000000LL || (v8 & 0x8000000000LL) != 0 || (v8 & 0x10000000000LL) != 0)
          {
            __clrex();
            char v22 = 0;
            goto LABEL_45;
          }

          unint64_t v21 = v8 + 0x20000000000LL;
          if (_os_atomic_mo_has_release(0)) {
            BOOL v20 = __stlxr(v21, v19) == 0;
          }
          else {
            BOOL v20 = __stxr(v21, v19) == 0;
          }
        }

        while (!v20);
        char v22 = 1;
      }

LABEL_45:
      if ((v22 & 1) != 0)
      {
        _dispatch_non_barrier_waiter_redirect_or_wake(v10, a2, a3, a4, a5, a6, a7, a8);
        return;
      }
    }

    *(_BYTE *)(a2 + 106) &= ~0x80u;
    (*(void (**)(uint64_t, uint64_t, unint64_t))(*(void *)v10 + 72LL))( v10,  a2,  (a4 & 0x700000000LL) >> 32);
  }

  if ((*(void *)(*(void *)v8 + 16LL) & 0x10000LL) != 0)
  {
    if (v9 > (v8[21] & 0xF00) >> 8) {
      _dispatch_root_queue_push_override_stealer((uint64_t)v8, a1, v9);
    }
  }

  else if (*(_BYTE *)(*(void *)v8 + 16LL) == 18LL)
  {
    _dispatch_workloop_push_stealer((uint64_t)v8, a1, v9);
  }

  else
  {
    uint64_t v12 = (((unint64_t)v8[15] << 32) & 0x700000000LL) >> 32;
    uint64_t v5 = 1;
    if (v12) {
      uint64_t v5 = v12 < v9;
    }
    if (v5) {
      (*(void (**)(unsigned int *, void, void))(*(void *)v8 + 64LL))(v8, v9, 0LL);
    }
  }

  if (((v7 ^ 1) & 1) == 0)
  {
    while (1)
    {
      unsigned int v24 = a1;
      unint64_t v47 = a1 + 100;
      unint64_t v46 = 0;
      uint64_t v45 = 0;
      uint64_t v44 = 0;
      uint64_t v43 = (unsigned int *)(a1 + 100);
      do
      {
        if (_os_atomic_mo_has_acquire(3)) {
          unsigned int v4 = __ldaxr(v43);
        }
        else {
          unsigned int v4 = __ldxr(v43);
        }
        unint64_t v46 = v4;
        if ((v4 & 2) != 0) {
          uint64_t v45 = v46 ^ 2;
        }
        else {
          uint64_t v45 = 0;
        }
        if (_os_atomic_mo_has_release(3))
        {
          LOBYTE(v44) = __stlxr(v45, v43) == 0;
          uint64_t v44 = v44;
        }

        else
        {
          LOBYTE(v44) = __stxr(v45, v43) == 0;
          uint64_t v44 = v44;
        }
      }

      while (!v44);
      uint64_t v42 = v44;
      if (v45)
      {
        __dmb(9u);
        uint64_t v48 = 0;
      }

      else
      {
        uint64_t v49 = v46;
        if ((v46 & 1) != 0) {
          _dispatch_unfair_lock_unlock_slow(v47, v46);
        }
        uint64_t v48 = 1;
      }

      if ((v48 & 1) != 0)
      {
        uint64_t v25 = 1;
      }

      else
      {
        uint64_t v27 = 1;
        int v26 = 0;
        int v26 = _dispatch_thread_getspecific(0x19uLL);
        int v28 = v26 & 0xF0000;
        if (v27 > (v26 & 0xF0000) >> 16)
        {
          v26 &= 0xFFF0FFFF;
          v26 |= v27 << 16;
          _dispatch_thread_setspecific(25LL, v26);
        }

        uint64_t v25 = 0;
      }

      if ((((unint64_t)*(unsigned int *)(a1 + 60) << 32) & 0x700000000LL) >> 32 > v9)
      {
        BOOL v9 = (((unint64_t)*(unsigned int *)(a1 + 60) << 32) & 0x700000000LL) >> 32;
        goto LABEL_45;
      }
    }
  }

        _dispatch_event_loop_leave_deferred((uint64_t)v44, v38, v21, v22, v23, v24, v25, v26);
      }
    }

    break;
  }

  _dispatch_thread_setspecific(25LL, 0LL);
  int v75 = 0LL;
  _dispatch_thread_setspecific(20LL, 0LL);
  _dispatch_thread_getspecific(0LL);
  _dispatch_log("%u\t%p\tvoucher[%p]: root queue clear", v27, v28, v29, v30, v31, v32, v33, 7270LL);
  unint64_t v46 = 0LL;
  uint64_t v45 = 14LL;
  uint64_t v50 = 0LL;
  uint64_t v49 = 0LL;
  uint64_t v48 = 14LL;
  uint64_t v80 = 0LL;
  uint64_t v93 = 1LL;
  uint64_t v92 = 2395LL;
  if ((_dispatch_set_qos_class_enabled & 1) != 0)
  {
    unint64_t v91 = v80;
    uint64_t v90 = 4261412863LL;
    uint64_t v89 = 0LL;
    v80 &= 0xFFFFFFFF02FFFFFFLL;
    uint64_t v79 = 0LL;
    unint64_t v82 = 0LL;
    unint64_t v82 = _dispatch_thread_getspecific(4uLL);
    uint64_t v79 = (unint64_t)v82;
    uint64_t v78 = 0x1000000LL;
    uint64_t v77 = 2281701376LL;
    if ((v82 & 0x1000000) != 0)
    {
      if (v80)
      {
        uint64_t v35 = v80;
      }

      else
      {
        unint64_t v88 = v79;
        uint64_t v87 = v78;
        uint64_t v86 = 0LL;
        uint64_t v35 = v79 & (~v78 | 0xFFFFFF);
      }

      uint64_t v81 = v35;
    }

    else
    {
      unsigned int v85 = v79;
      uint64_t v84 = v77;
      uint64_t v83 = 0LL;
      v79 &= ~v77 | 0xFFFFFF;
      if (v80 == v79) {
        uint64_t v81 = 0LL;
      }
      else {
        uint64_t v81 = v80;
      }
    }
  }

  else
  {
    uint64_t v81 = 0LL;
  }

  uint64_t v50 = v81;
  if (v81) {
    goto LABEL_69;
  }
  if (v49 == -1)
  {
    unint64_t v51 = -1LL;
    return;
  }

  uint64_t v34 = (void *)v49;
  if (v34 != _dispatch_thread_getspecific(0x1CuLL))
  {
LABEL_69:
    unint64_t v51 = _dispatch_set_priority_and_voucher_slow(v50, (_DWORD *)v49, v48);
  }

  else
  {
    unint64_t v47 = (v48 & 4) != 0;
    if ((v48 & 2) != 0)
    {
      if (v47 && v49)
      {
        object = (void *)v49;
        os_release((void *)v49);
      }

      uint64_t v49 = -1LL;
    }

    else if (!v47 && v49)
    {
      uint64_t v53 = (void *)v49;
      os_retain((void *)v49);
    }

    unint64_t v51 = v49;
  }

uint64_t _dispatch_release_no_dispose(uint64_t result)
{
  int v5 = *(_DWORD *)(result + 8);
  if (v5 != 0x7FFFFFFF)
  {
    unsigned int v3 = (unsigned int *)(result + 8);
    unsigned int v4 = *(_DWORD *)(result + 8);
    do
    {
      unsigned int v1 = v4;
      do
        unsigned int v2 = __ldaxr(v3);
      while (v2 == v4 && __stlxr(v4 - 1, v3));
      unsigned int v4 = v2;
    }

    while (v2 != v1);
    int v5 = v2 - 1;
  }

  if (v5 < 1)
  {
    qword_E4D78 = (uint64_t)"API MISUSE: Over-release of an object";
    __break(1u);
    JUMPOUT(0x4A5A0LL);
  }

  return result;
}

uint64_t _dispatch_release_2_no_dispose(uint64_t result)
{
  int v5 = *(_DWORD *)(result + 8);
  if (v5 != 0x7FFFFFFF)
  {
    unsigned int v3 = (unsigned int *)(result + 8);
    unsigned int v4 = *(_DWORD *)(result + 8);
    do
    {
      unsigned int v1 = v4;
      do
        unsigned int v2 = __ldaxr(v3);
      while (v2 == v4 && __stlxr(v4 - 2, v3));
      unsigned int v4 = v2;
    }

    while (v2 != v1);
    int v5 = v2 - 2;
  }

  if (v5 < 1)
  {
    qword_E4D78 = (uint64_t)"API MISUSE: Over-release of an object";
    __break(1u);
    JUMPOUT(0x4A724LL);
  }

  return result;
}

void _dispatch_waiter_wake(uint64_t a1, uint64_t a2, unint64_t a3, unint64_t a4)
{
  uint64_t v4 = *(void *)(a1 + 48);
  if (v4 == -4) {
    _dispatch_waiter_wake_wlh_anon(a1);
  }
}

uint64_t _dispatch_base_lane_is_wlh( uint64_t a1, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (((_dispatch_kevent_workqueue_enabled ^ 1) & 1) != 0)
  {
    char v11 = 0;
  }

  else if (*(void *)(*(void *)a1 + 16LL) == 133137LL)
  {
    char v11 = 1;
  }

  else
  {
    if (*(_BYTE *)(*(void *)a1 + 16LL) == 19LL)
    {
      if ((*(_BYTE *)(*(void *)(a1 + 88) + 29LL) & 0x20) == 0)
      {
        char v11 = 0;
        return v11 & 1;
      }

      if ((*(_BYTE *)(*(void *)(a1 + 88) + 29LL) & 1) == 0) {
        _dispatch_abort(2510LL, *(_BYTE *)(*(void *)(a1 + 88) + 29LL) & 1, a3, a4, a5, a6, a7, a8);
      }
    }

    char v10 = 0;
    if (*(_WORD *)(a1 + 80) == 1)
    {
      BOOL v9 = 0;
      char v10 = v9;
    }

    char v11 = v10;
  }

  return v11 & 1;
}

uint64_t _dispatch_lane_concurrent_drain( uint64_t a1, uint64_t a2, int a3, void *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v46 = a1;
  uint64_t v45 = a2;
  int v44 = a3;
  uint64_t v43 = a4;
  char v42 = 0;
  uint64_t v41 = 0LL;
  uint64_t v41 = *(void *)(a1 + 24);
  __int128 v40 = 0uLL;
  uint64_t v36 = *a4;
  if (!*(void *)(a1 + 48)) {
    return 0LL;
  }
  uint64_t v152 = v46;
  BOOL v151 = &v40;
  char v156 = &v40;
  _dispatch_thread_getspecific_packed_pair(20LL, 21LL, &v40, (uint64_t)a4, a5, a6, a7, a8);
  _dispatch_thread_setspecific_pair(20LL, v152, 21LL, (uint64_t)v151, v8, v9, v10, v11);
  if ((v42 & 1) != 0 || (uint64_t v48 = v36, (v36 & 0x40000000000000LL) != 0)) {
    uint64_t v37 = 0x40000000000000LL;
  }
  else {
    uint64_t v37 = v36 & 0x3FFE0000000000LL;
  }
  uint64_t v89 = v46;
  unint64_t v88 = (unint64_t *)(v46 + 104);
  uint64_t v87 = 0LL;
  uint64_t v86 = 0LL;
  uint64_t v85 = *(void *)(v46 + 104);
  uint64_t v86 = v85;
  uint64_t v84 = v85;
  uint64_t v87 = v85;
  if (!v85) {
    uint64_t v87 = _dispatch_wait_for_enqueuer(v88, v89 + 48);
  }
  uint64_t v83 = v87;
  uint64_t v39 = (void *)v87;
  while (1)
  {
    uint64_t v49 = *(void *)(v46 + 56);
    if ((v49 & 0xFF80000000000000LL) != 0 || v41 != *(void *)(v46 + 24)) {
      break;
    }
    if ((v42 & 1) != 0) {
      goto LABEL_35;
    }
    uint64_t v64 = v39;
    int v63 = 0;
    int v148 = v39;
    if (*v39 > 0xFFFuLL)
    {
      if ((*(void *)(*(void *)v64 + 16LL) & 0xF0LL) == 0x10)
      {
        int v62 = 0;
        int v61 = v64[20];
        int v62 = v61;
        int v60 = v61;
        int v63 = v61;
        BOOL v65 = (v61 & 0x80000) != 0;
      }

      else
      {
        BOOL v65 = 0;
      }
    }

    else
    {
      BOOL v65 = (*v64 & 2) != 0;
    }

    if (v65)
    {
LABEL_35:
      if ((v42 & 1) == 0 && v37 != 0x40000000000000LL)
      {
        uint64_t v166 = v46;
        uint64_t v165 = v37;
        unint64_t v164 = 0LL;
        unint64_t v163 = 0LL;
        unint64_t v162 = 0LL;
        unint64_t v162 = ((unint64_t)(*(unsigned __int16 *)(v46 + 80) - 1) << 41) | 0x10000000000LL;
        BOOL v161 = 0;
        int v160 = (unint64_t *)(v46 + 56);
        do
        {
          if (_os_atomic_mo_has_acquire(2)) {
            unint64_t v19 = __ldaxr(v160);
          }
          else {
            unint64_t v19 = __ldxr(v160);
          }
          unint64_t v164 = v19;
          unint64_t v163 = v19 - v165;
          unint64_t v168 = v19;
          if ((v19 & 0x10000000000LL) == 0) {
            v163 += v162;
          }
          unint64_t v167 = v163;
          if (!(v163 >> 53))
          {
            v163 += 0x20000000000LL;
            v163 += 0x40000000000000LL;
            v163 -= 0x10000000000LL;
          }

          v163 &= ~0x8000000000uLL;
          if (_os_atomic_mo_has_release(2)) {
            BOOL v161 = __stlxr(v163, v160) == 0;
          }
          else {
            BOOL v161 = __stxr(v163, v160) == 0;
          }
        }

        while (!v161);
        BOOL v159 = v161;
        if ((v163 & 0x40000000000000LL) == 0) {
          goto LABEL_144;
        }
        uint64_t v37 = 0x40000000000000LL;
      }

      int v169 = v39;
      int v171 = v39;
      if (*v39 >= 0x1000uLL) {
        char v170 = 0;
      }
      else {
        char v170 = *v169 & 1;
      }
      if (v170 == 1 && (v44 & 0x80000) == 0)
      {
        *(void *)(v45 + 8) = v39;
        if ((v44 & 8) != 0)
        {
          qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: Deferred continuation on source, mach channel or mgr";
          __break(1u);
          JUMPOUT(0x4BD30LL);
        }

        uint64_t v153 = &v40;
        _dispatch_thread_setspecific_packed_pair(20LL, 21LL, &v40, v13, v14, v15, v16, v17);
        return *(void *)(v46 + 24);
      }

      uint64_t v117 = v46;
      uint64_t v116 = v39;
      uint64_t v115 = v39;
      uint64_t v114 = 0LL;
      unint64_t v113 = 0LL;
      unint64_t v112 = 0LL;
      uint64_t v111 = 0LL;
      uint64_t v110 = v39[2];
      uint64_t v111 = v110;
      uint64_t v109 = v110;
      uint64_t v114 = v110;
      uint64_t v108 = v110;
      uint64_t v107 = v110;
      *(void *)(v46 + 104) = v110;
      uint64_t v106 = v108;
      if (!v114)
      {
        uint64_t v103 = 0LL;
        uint64_t v104 = 0LL;
        uint64_t v105 = v117 + 48;
        BOOL v102 = 0;
        uint64_t v101 = (unint64_t *)(v117 + 48);
        while (1)
        {
          unint64_t v20 = _os_atomic_mo_has_acquire(3) ? __ldaxr(v101) : __ldxr(v101);
          unint64_t v112 = v20;
          unint64_t v147 = v20;
          if (v115 != (void *)(v20 & 0xFFFFFFFFFFFFFFF8LL)) {
            break;
          }
          unint64_t v113 = 0LL;
          if (_os_atomic_mo_has_release(3)) {
            BOOL v102 = __stlxr(v113, v101) == 0;
          }
          else {
            BOOL v102 = __stxr(v113, v101) == 0;
          }
          if (v102) {
            goto LABEL_70;
          }
        }

        __clrex();
        uint64_t v100 = v115;
        uint64_t v99 = 0LL;
        uint64_t v98 = 0LL;
        uint64_t v97 = v115[2];
        uint64_t v98 = v97;
        uint64_t v96 = v97;
        uint64_t v99 = v97;
        if (!v97) {
          uint64_t v99 = _dispatch_wait_for_enqueuer(v100 + 2, v117 + 48);
        }
        uint64_t v95 = v99;
        uint64_t v114 = v99;
        uint64_t v94 = v99;
        uint64_t v93 = v99;
        *(void *)(v117 + 104) = v99;
        uint64_t v92 = v94;
LABEL_70:
        BOOL v91 = v102;
      }

      uint64_t v90 = v114;
      uint64_t v38 = (void *)v114;
LABEL_127:
      _dispatch_continuation_pop_inline(v39, v45, v44, v46);
      goto LABEL_10;
    }

    if (v37 == 0x40000000000000LL)
    {
      uint64_t v33 = (unint64_t *)(v46 + 56);
      unint64_t v34 = *(void *)(v46 + 56);
      do
      {
        unint64_t v21 = v34;
        do
          unint64_t v22 = __ldaxr(v33);
        while (v22 == v34 && __stlxr(v34 ^ 0x40000000000000LL, v33));
        unint64_t v34 = v22;
      }

      while (v22 != v21);
      uint64_t v37 = (unint64_t)*(unsigned __int16 *)(v46 + 80) << 41;
    }

    else if (!v37)
    {
      uint64_t v56 = v39;
      unsigned int v150 = v39;
      if (*v39 < 0x1000uLL && (*v56 & 0x81LL) != 0)
      {
        uint64_t v182 = v46;
        uint64_t v180 = 0x20000000000LL;
        uint64_t v179 = 0x20000000000LL;
        uint64_t v181 = 0x20000000000LL;
        unint64_t v177 = 0LL;
        uint64_t v175 = 0x20000000000LL;
        uint64_t v174 = 0x20000000000LL;
        uint64_t v176 = 0x20000000000LL;
        uint64_t v31 = (unint64_t *)(v46 + 56);
        unint64_t v32 = *(void *)(v46 + 56);
        do
        {
          unint64_t v23 = v32;
          do
            unint64_t v24 = __ldaxr(v31);
          while (v24 == v32 && __stlxr(v32 + 0x20000000000LL, v31));
          unint64_t v32 = v24;
        }

        while (v24 != v23);
        unint64_t v173 = v24;
        unint64_t v177 = v24;
        unint64_t v172 = v24;
        unint64_t v178 = v24 + v181;
      }

      else
      {
        uint64_t v71 = v46;
        unint64_t v70 = 0LL;
        unint64_t v69 = 0LL;
        BOOL v68 = 0;
        uint64_t v67 = (unint64_t *)(v46 + 56);
        do
        {
          if (_os_atomic_mo_has_acquire(2)) {
            unint64_t v25 = __ldaxr(v67);
          }
          else {
            unint64_t v25 = __ldxr(v67);
          }
          unint64_t v70 = v25;
          unint64_t v73 = v25;
          char v30 = 1;
          if (!(v25 >> 53))
          {
            unint64_t v75 = v70;
            char v30 = 1;
            if ((v70 & 0x8000000000LL) == 0)
            {
              unint64_t v74 = v70;
              char v30 = BYTE5(v70) & 1;
            }
          }

          if ((v30 & 1) != 0)
          {
            __clrex();
            BOOL v72 = 0;
            goto LABEL_104;
          }

          unint64_t v69 = v70 + 0x20000000000LL;
          if (_os_atomic_mo_has_release(2)) {
            BOOL v68 = __stlxr(v69, v67) == 0;
          }
          else {
            BOOL v68 = __stxr(v69, v67) == 0;
          }
        }

        while (!v68);
        BOOL v66 = v68;
        BOOL v72 = v68;
LABEL_104:
        if (!v72)
        {
LABEL_144:
          *v43 &= 0x4000000001uLL;
          BOOL v154 = &v40;
          _dispatch_thread_setspecific_packed_pair(20LL, 21LL, &v40, v13, v14, v15, v16, v17);
          return -1LL;
        }
      }

      uint64_t v37 = 0x20000000000LL;
    }

    uint64_t v145 = v46;
    uint64_t v144 = v39;
    unsigned int v143 = v39;
    uint64_t v142 = 0LL;
    unint64_t v141 = 0LL;
    unint64_t v140 = 0LL;
    uint64_t v139 = 0LL;
    uint64_t v138 = v39[2];
    uint64_t v139 = v138;
    uint64_t v137 = v138;
    uint64_t v142 = v138;
    uint64_t v136 = v138;
    uint64_t v135 = v138;
    *(void *)(v46 + 104) = v138;
    uint64_t v134 = v136;
    if (!v142)
    {
      uint64_t v131 = 0LL;
      uint64_t v132 = 0LL;
      uint64_t v133 = v145 + 48;
      BOOL v130 = 0;
      uint64_t v129 = (unint64_t *)(v145 + 48);
      while (1)
      {
        unint64_t v26 = _os_atomic_mo_has_acquire(3) ? __ldaxr(v129) : __ldxr(v129);
        unint64_t v140 = v26;
        unint64_t v146 = v26;
        if (v143 != (void *)(v26 & 0xFFFFFFFFFFFFFFF8LL)) {
          break;
        }
        unint64_t v141 = 0LL;
        if (_os_atomic_mo_has_release(3)) {
          BOOL v130 = __stlxr(v141, v129) == 0;
        }
        else {
          BOOL v130 = __stxr(v141, v129) == 0;
        }
        if (v130) {
          goto LABEL_119;
        }
      }

      __clrex();
      uint64_t v128 = v143;
      uint64_t v127 = 0LL;
      uint64_t v126 = 0LL;
      uint64_t v125 = v143[2];
      uint64_t v126 = v125;
      uint64_t v124 = v125;
      uint64_t v127 = v125;
      if (!v125) {
        uint64_t v127 = _dispatch_wait_for_enqueuer(v128 + 2, v145 + 48);
      }
      uint64_t v123 = v127;
      uint64_t v142 = v127;
      uint64_t v122 = v127;
      uint64_t v121 = v127;
      *(void *)(v145 + 104) = v127;
      uint64_t v120 = v122;
LABEL_119:
      BOOL v119 = v130;
    }

    uint64_t v118 = v142;
    uint64_t v38 = (void *)v142;
    int v58 = v39;
    unsigned int v149 = v39;
    if (*v39 < 0x1000uLL && (*v58 & 0x81LL) != 0)
    {
      v37 -= 0x20000000000LL;
      _dispatch_non_barrier_waiter_redirect_or_wake(v46, (uint64_t)v39, v12, v13, v14, v15, v16, v17);
    }

    else
    {
      if ((v44 & 0x20000) == 0) {
        goto LABEL_127;
      }
      v37 -= 0x20000000000LL;
      uint64_t v52 = v46;
      unint64_t v53 = (unint64_t)*(unsigned int *)(v46 + 60) << 32;
      v53 &= 0x700000000uLL;
      _dispatch_continuation_redirect_push(v46, v39, HIDWORD(v53));
    }

void _dispatch_workloop_bound_thread_init_once(uint64_t a1)
{
  uint64_t v10 = a1;
  int v9 = 0;
  size_t v8 = 4LL;
  int v7 = sysctlbyname("kern.kern_event.thread_bound_kqwl_support_enabled", &v9, &v8, 0LL, 0LL);
  uint64_t v12 = v7;
  uint64_t v11 = 4220LL;
  if (v7) {
    _dispatch_bug(v11, v12, v1, v2, v3, v4, v5, v6);
  }
  if (v9) {
    _dispatch_thread_bound_kqwl_enabled = 1;
  }
}

BOOL _dispatch_workloop_activate_simulator_fallback( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v12 = (dispatch_object_s *)dispatch_pthread_root_queue_create( "com.apple.libdispatch.workloop_fallback",  0,  a2,  0LL,  a5,  a6,  a7,  a8);
  *(void *)(a1 + 24) = v12;
  _dispatch_retain((uint64_t)v12);
  dispatch_release(v12);
  uint64_t v10 = (unint64_t *)(a1 + 56);
  do
  {
    if (_os_atomic_mo_has_acquire(0)) {
      unint64_t v8 = __ldaxr(v10);
    }
    else {
      unint64_t v8 = __ldxr(v10);
    }
    unint64_t v13 = v8 & 0xFFFFFFCFFFFFFFFFLL | 0x1000000000LL;
    BOOL result = _os_atomic_mo_has_release(0);
    if (result) {
      BOOL v11 = __stlxr(v13, v10) == 0;
    }
    else {
      BOOL v11 = __stxr(v13, v10) == 0;
    }
  }

  while (!v11);
  return result;
}

uint64_t _dispatch_workloop_activate_tg_unsupported_fallback(uint64_t a1)
{
  int v9 = *(const sched_param **)(a1 + 200);
  memset(&__b, 0, sizeof(__b));
  pthread_attr_init(&__b);
  if ((v9->sched_priority & 1) != 0) {
    pthread_attr_setschedparam(&__b, v9 + 1);
  }
  if ((v9->sched_priority & 2) != 0) {
    pthread_attr_setschedpolicy(&__b, v9[2].sched_priority);
  }
  if ((v9->sched_priority & 4) != 0) {
    pthread_attr_setcpupercent_np(&__b, v9[2].__opaque[0], v9[3].sched_priority);
  }
  int v8 = _pthread_workloop_create(a1, 0LL, &__b);
  if (v8)
  {
    if (v8 != 45) {
      _dispatch_abort(4396LL, v8, v1, v2, v3, v4, v5, v6);
    }
    _dispatch_workloop_activate_simulator_fallback(a1, (uint64_t)&__b, v1, v2, v3, v4, v5, v6);
  }

  else
  {
    v9->sched_priority |= 0x10u;
  }

  return pthread_attr_destroy(&__b);
}

uint64_t _dispatch_retain_n_unsafe(uint64_t result, int a2)
{
  uint64_t v4 = (unsigned int *)(result + 8);
  unsigned int v5 = *(_DWORD *)(result + 8);
  do
  {
    unsigned int v2 = v5;
    do
      unsigned int v3 = __ldaxr(v4);
    while (v3 == v5 && __stlxr(v5 + a2, v4));
    unsigned int v5 = v3;
  }

  while (v3 != v2);
  return result;
}

void _dispatch_queue_wakeup_with_override_slow(uint64_t a1, uint64_t a2, char a3)
{
  unsigned int v9 = (a2 & 0x700000000uLL) >> 32;
  int v8 = *(unsigned int **)(a1 + 24);
  if ((a2 & 0x1000000000LL) != 0)
  {
    BOOL v6 = 0;
    if (!v6) {
      goto LABEL_81;
    }
    if ((a2 & 0xFFFFFFFC) != 0) {
      unsigned int v14 = a2 | 3;
    }
    else {
      unsigned int v14 = 0;
    }
    if (v14)
    {
      if ((_dispatch_set_qos_class_enabled & 1) != 0)
      {
        uint64_t v13 = 0LL;
        if (v9) {
          uint64_t v13 = 1LL << (v9 + 7);
        }
        _pthread_workqueue_override_start_direct_check_owner(v14, v13 | 0xFF, a1 + 56);
      }

      goto LABEL_81;
    }

    char v7 = 0;
  }

  else if ((*(_DWORD *)(a1 + 80) & 0x400000) != 0)
  {
    uint64_t v16 = a1;
    uint64_t v15 = a2 & 0x700000000LL;
    uint64_t v36 = (unsigned int *)(a1 + 100);
    char v35 = &v15;
    unsigned int v34 = 0;
    unsigned int v37 = _dispatch_thread_getspecific(3uLL);
    unsigned int v34 = v37 & 0xFFFFFFFC;
    unsigned int v33 = 0;
    unsigned int v32 = 0;
    int v31 = 0;
    char v30 = v36;
    do
    {
      if (_os_atomic_mo_has_acquire(2)) {
        unsigned int v3 = __ldaxr(v30);
      }
      else {
        unsigned int v3 = __ldxr(v30);
      }
      unsigned int v33 = v3;
      unsigned int v39 = v3;
      if ((v3 & 0xFFFFFFFC) != 0) {
        unsigned int v32 = v33 | 2;
      }
      else {
        unsigned int v32 = v34;
      }
      if (_os_atomic_mo_has_release(2))
      {
        LOBYTE(v31) = __stlxr(v32, v30) == 0;
        int v31 = v31;
      }

      else
      {
        LOBYTE(v31) = __stxr(v32, v30) == 0;
        int v31 = v31;
      }
    }

    while (!v31);
    int v29 = v31;
    if (v35)
    {
      unsigned int v40 = v32;
      if ((v32 & 0xFFFFFFFC) != 0) {
        int v41 = v40 | 3;
      }
      else {
        int v41 = 0;
      }
      *(_DWORD *)char v35 = v41;
    }

    unsigned int v38 = v33;
    if ((v33 & 0xFFFFFFFC) != 0)
    {
      int v19 = HIDWORD(v15);
      unsigned int v20 = v15;
      uint64_t v18 = v16 + 100;
      if ((_dispatch_set_qos_class_enabled & 1) != 0)
      {
        int v23 = v19;
        uint64_t v22 = 0LL;
        if (v19) {
          uint64_t v22 = 1LL << (v23 + 7);
        }
        int v21 = _pthread_workqueue_override_start_direct_check_owner(v20, v22 | 0xFF, v18);
      }

      else
      {
        int v21 = 0;
      }

      char v17 = 0;
    }

    else
    {
      char v17 = 1;
    }

    if ((v17 & 1) == 0)
    {
      if (MEMORY[0xFFFFFC100]) {
        kdebug_trace(771883028LL, a1, 0LL, 0LL, 0LL);
      }
      goto LABEL_81;
    }

    char v7 = 1;
    int v8 = *(unsigned int **)(a1 + 24);
    if (MEMORY[0xFFFFFC100]) {
      kdebug_trace(771883028LL, a1, 0LL, 0LL, 0LL);
    }
  }

  else
  {
    char v7 = 0;
  }

LABEL_81:
  if ((a3 & 1) != 0) {
    _dispatch_release_2_tailcall((unsigned int *)a1);
  }
}

void _dispatch_root_queue_push_override_stealer(uint64_t a1, uint64_t a2, unsigned int a3)
{
  char v14 = 0;
  if ((*(_BYTE *)(a1 + 87) & 0x80) != 0)
  {
    char v14 = 2;
  }

  else if ((*(_BYTE *)(a1 + 87) & 8) != 0)
  {
    char v14 = 4;
  }

  BOOL v12 = 1;
  if (a3) {
    BOOL v12 = a3 > 6;
  }
  if (v12)
  {
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Corrupted priority";
    qword_E4DA8 = a3;
    __break(1u);
    JUMPOUT(0x4CE30LL);
  }

  int v20 = 0;
  if ((v14 & 2) != 0)
  {
    int v20 = 1;
  }

  else if ((v14 & 4) != 0)
  {
    int v20 = 2;
  }

  uint64_t v13 = &(&_dispatch_root_queues)[16 * (unint64_t)(3 * a3 + v20 - 3)];
  uint64_t v18 = (uint64_t (**)())_dispatch_thread_getspecific(0x16uLL);
  if (v18)
  {
    _dispatch_thread_setspecific(22LL, (uint64_t)v18[2]);
    char v17 = v18;
  }

  else
  {
    char v17 = (uint64_t (**)())_dispatch_continuation_alloc_from_heap();
  }

  *char v17 = (uint64_t (*)())&unk_E0DE8;
  _dispatch_retain_2(a2);
  v17[4] = 0LL;
  v17[5] = (uint64_t (*)())v17;
  v17[7] = (uint64_t (*)())a1;
  v17[6] = (uint64_t (*)())a2;
  v17[1] = (uint64_t (*)())-1LL;
  v17[3] = (uint64_t (*)())-1LL;
  v17[2] = 0LL;
  _dispatch_thread_setspecific(122LL, (uint64_t)(v13 + 6));
  uint64_t v10 = (unint64_t *)(v13 + 6);
  BOOL v11 = v13[6];
  do
  {
    unsigned int v3 = v11;
    do
      unint64_t v4 = __ldaxr(v10);
    while ((uint64_t (**)())v4 == v11 && __stlxr((unint64_t)v17, v10));
    BOOL v11 = (uint64_t (**)())v4;
  }

  while (v4 != (void)v3);
  unint64_t v19 = v4;
  if (v4) {
    *(void *)(v4 + 16) = v17;
  }
  else {
    v13[13] = v17;
  }
  _dispatch_thread_setspecific(122LL, 0LL);
  if (!v19) {
    _dispatch_root_queue_poke_and_wakeup(v13, 1, 0, v5, v6, v7, v8, v9);
  }
}

void _dispatch_workloop_push_stealer(uint64_t a1, uint64_t a2, unsigned int a3)
{
  BOOL v12 = _dispatch_thread_getspecific(0x16uLL);
  if (v12)
  {
    _dispatch_thread_setspecific(22LL, v12[2]);
    BOOL v11 = v12;
  }

  else
  {
    BOOL v11 = (void *)_dispatch_continuation_alloc_from_heap();
  }

  *BOOL v11 = &unk_E0DB0;
  _dispatch_retain_2(a2);
  v11[4] = 0LL;
  v11[5] = v11;
  v11[7] = 0LL;
  v11[6] = a2;
  v11[1] = -1LL;
  v11[3] = -1LL;
  _dispatch_workloop_push(a1, v11, a3, v3, v4, v5, v6, v7);
}

void _dispatch_lane_drain_non_barriers( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v40 = a3;
  uint64_t v39 = *(unsigned __int16 *)(a1 + 80);
  char v30 = (unint64_t *)(a1 + 56);
  unint64_t v31 = *(void *)(a1 + 56);
  do
  {
    unint64_t v8 = v31;
    do
      unint64_t v9 = __ldaxr(v30);
    while (v9 == v31 && __stlxr(v31 & 0xFFBFFFFFFFFFFFFFLL, v30));
    unint64_t v31 = v9;
  }

  while (v9 != v8);
  while (v39)
  {
    --v39;
LABEL_33:
    unint64_t v53 = *(_DWORD **)(a2 + 16);
    *(void *)(a1 + 104) = v53;
    if (!v53)
    {
      BOOL v51 = (unint64_t *)(a1 + 48);
      while (1)
      {
        unint64_t v13 = _os_atomic_mo_has_acquire(3) ? __ldaxr(v51) : __ldxr(v51);
        if (a2 != (v13 & 0xFFFFFFFFFFFFFFF8LL)) {
          break;
        }
        if (_os_atomic_mo_has_release(3)) {
          BOOL v52 = __stlxr(0LL, v51) == 0;
        }
        else {
          BOOL v52 = __stxr(0LL, v51) == 0;
        }
        if (v52) {
          goto LABEL_46;
        }
      }

      __clrex();
      uint64_t v50 = *(void *)(a2 + 16);
      if (!v50) {
        uint64_t v50 = _dispatch_wait_for_enqueuer((unint64_t *)(a2 + 16), a1 + 48);
      }
      unint64_t v53 = (_DWORD *)v50;
      *(void *)(a1 + 104) = v50;
    }

uint64_t _dispatch_channel_invoke_cancel_check(uint64_t a1, uint64_t a2, uint64_t a3)
{
  char v5 = 1;
  if (((*(_WORD *)(a1 + 116) >> 3) & 1) == 0 && (*(_DWORD *)(a1 + 80) & 0x10000000) != 0)
  {
    uint64_t v4 = 0LL;
    if ((*(_DWORD *)(a2 + 32) & 0x1000000) != 0) {
      uint64_t v4 = _dispatch_autorelease_pool_push();
    }
    char v5 = (*(uint64_t (**)(uint64_t, void))(a3 + 24))(a1, *(void *)(a1 + 32)) & 1;
    if (v4) {
      _dispatch_autorelease_pool_pop(v4);
    }
    if ((v5 & 1) != 0)
    {
      *(_WORD *)(a1 + 116) = *(_WORD *)(a1 + 116) & 0xFFF7 | 8;
      _dispatch_release_no_dispose(a1);
    }

    else
    {
      *(void *)(a2 + 40) = -1LL;
    }
  }

  return v5 & 1;
}

uint64_t _dispatch_mgr_sched_qos2prio(int a1)
{
  if (a1 == 5)
  {
    return 4;
  }

  else
  {
    unint64_t v2 = (a1 - 9);
    if (v2 <= 0x18) {
      __asm { BR              X8 }
    }

    return 0;
  }

void _dispatch_mgr_priority_apply()
{
  sched_param v7 = 0LL;
  do
  {
    v7.sched_priority = _dispatch_mgr_sched;
    if (_dispatch_mgr_sched > dword_E5060)
    {
      int v6 = pthread_setschedparam((pthread_t)qword_E5068, dword_E5064, &v7);
      uint64_t v9 = v6;
      uint64_t v8 = 6239LL;
      if (v6) {
        _dispatch_bug(v8, v9, v0, v1, v2, v3, v4, v5);
      }
    }
  }

  while (_dispatch_mgr_sched > v7.sched_priority);
}

void _dispatch_mgr_queue_drain()
{
  int v24 = 0x40000;
  memset(v23, 0, sizeof(v23));
  uint64_t v22 = &_dispatch_mgr_q;
  uint64_t v21 = 0x40020000000000LL;
  if (qword_E4170)
  {
    int v26 = 15;
    unsigned int v25 = _dispatch_thread_getspecific(0x19uLL);
    int v27 = v25 & 0xF0000;
    if ((v25 & 0xF0000) >> 16 < 0xF)
    {
      unsigned int v25 = v25 & 0xFFF0FFFF | (v26 << 16);
      _dispatch_thread_setspecific(25LL, v25);
    }

    if (_dispatch_lane_serial_drain((uint64_t)v22, (uint64_t)v23, 0x40000, &v21, v0, v1, v2, v3))
    {
      qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: Interrupted drain on manager queue";
      __break(1u);
      JUMPOUT(0x4EBECLL);
    }

    _dispatch_thread_getspecific(0LL);
    _dispatch_log("%u\t%p\tvoucher[%p]: mgr queue clear", v4, v5, v6, v7, v8, v9, v10, 6387LL);
    uint64_t v33 = 0LL;
    unsigned int v32 = 0LL;
    uint64_t v36 = 0LL;
    unint64_t v35 = 0LL;
    unint64_t v35 = _dispatch_thread_getspecific(0x1CuLL);
    int v44 = v35;
    uint64_t v43 = v36;
    if (v35 == (_BYTE *)v36)
    {
      unsigned int v45 = -1;
    }

    else
    {
      if (v44)
      {
        int v42 = 0;
        int v41 = 0;
      }

      _dispatch_thread_setspecific(28LL, v43);
      if (v43)
      {
        int v40 = 0;
        int v39 = 0;
      }

      _dispatch_thread_getspecific(0LL);
      _dispatch_log("%u\t%p\tvoucher[%p]: swap from voucher[%p]", v11, v12, v13, v14, v15, v16, v17, 400LL);
      int v38 = 0;
      if (v43) {
        int v20 = *(_DWORD *)(v43 + 32);
      }
      else {
        int v20 = 0;
      }
      int v38 = v20;
      int v37 = 0;
      if (v44) {
        int v19 = *((_DWORD *)v44 + 8);
      }
      else {
        int v19 = 0;
      }
      int v37 = v19;
      if (v38 == v19) {
        int v18 = -1;
      }
      else {
        int v18 = v38;
      }
      unsigned int v45 = v18;
    }

    unsigned int v46 = v45;
    if (v45 != -1) {
      _dispatch_set_priority_and_mach_voucher_slow(0LL, v46);
    }
    unsigned int v32 = v35;
    if (v35)
    {
      uint64_t v34 = v32;
      os_release(v32);
    }

    unsigned int v29 = 0;
    unsigned int v29 = _dispatch_thread_getspecific(0x19uLL);
    int v31 = v29 & 0xF0000;
    unsigned int v28 = (v29 & 0xF0000) >> 16;
    if ((v29 & 0xF0000) >> 16)
    {
      v29 &= 0xFFF0FFFF;
      _dispatch_thread_setspecific(25LL, v29);
      BOOL v30 = v28 != 15;
    }

    else
    {
      BOOL v30 = 0;
    }
  }

  if ((_dispatch_kevent_workqueue_enabled & 1) == 0) {
    _dispatch_force_cache_cleanup();
  }
}

void _dispatch_force_cache_cleanup()
{
  uint64_t v0 = _dispatch_thread_getspecific(0x16uLL);
  if (v0)
  {
    _dispatch_thread_setspecific(22LL, 0LL);
    _dispatch_cache_cleanup(v0);
  }

uint64_t *_dispatch_mgr_root_queue_init()
{
  uint64_t v33 = &_dispatch_mgr_sched_pred;
  unsigned int v32 = 0LL;
  dispatch_function_t v31 = (dispatch_function_t)_dispatch_mgr_sched_init;
  if (_dispatch_mgr_sched_pred != -1LL) {
    dispatch_once_f(v33, v32, v31);
  }
  int v24 = off_E40E0;
  __attr = (pthread_attr_t *)off_E40E0;
  sched_param v22 = 0LL;
  int v21 = pthread_attr_setdetachstate((pthread_attr_t *)off_E40E0, 2);
  uint64_t v30 = v21;
  uint64_t v29 = 6200LL;
  if (v21) {
    _dispatch_bug(v29, v30, v0, v1, v2, v3, v4, v5);
  }
  if (dword_E505C)
  {
    if ((_dispatch_set_qos_class_enabled & 1) != 0)
    {
      int v20 = pthread_attr_set_qos_class_np(__attr, (qos_class_t)dword_E505C, 0);
      uint64_t v28 = v20;
      uint64_t v27 = 6209LL;
      if (v20) {
        _dispatch_bug(v27, v28, v6, v7, v8, v9, v10, v11);
      }
    }
  }

  v22.sched_priority = _dispatch_mgr_sched;
  if (_dispatch_mgr_sched > dword_E5060)
  {
    int v19 = pthread_attr_setschedparam(__attr, &v22);
    uint64_t v26 = v19;
    uint64_t v25 = 6215LL;
    if (v19) {
      _dispatch_bug(v25, v26, v12, v13, v14, v15, v16, v17);
    }
  }

  return &qword_E5068;
}

uint64_t _dispatch_worker_thread(uint64_t a1)
{
  uint64_t v32 = *(void *)(a1 + 32);
  uint64_t v27 = (unsigned int *)(a1 + 112);
  unsigned int v28 = *(_DWORD *)(a1 + 112);
  do
  {
    unsigned int v1 = v28;
    do
      unsigned int v2 = __ldaxr(v27);
    while (v2 == v28 && __stlxr(v28 - 1, v27));
    unsigned int v28 = v2;
  }

  while (v2 != v1);
  if (((v2 - 1) & 0x80000000) != 0)
  {
    qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: Pending thread request underflow";
    qword_E4DA8 = (int)(v2 - 1);
    __break(1u);
    JUMPOUT(0x4F2A4LL);
  }

  if (*(void *)(v32 + 144)) {
    _dispatch_thread_setspecific(24LL, v32 + 144);
  }
  if (*(void *)(a1 + 72)) {
    pthread_setname_np(*(const char **)(a1 + 72));
  }
  if (*(void *)(v32 + 64)) {
    (*(void (**)(void))(*(void *)(v32 + 64) + 16LL))();
  }
  _dispatch_sigmask();
  dispatch_function_t v31 = _dispatch_thread_getspecific(4uLL);
  unsigned int v29 = *(_DWORD *)(a1 + 84);
  if ((v29 & 0x46000FFF) == 0)
  {
    unsigned int v30 = v29 & 0x80000000;
    BOOL v26 = 0;
    if ((BYTE3(v31) & 0x22) == 0) {
      BOOL v26 = (BYTE1(v31) & 0x3F) != 0;
    }
    if (v26)
    {
      unsigned int v9 = (v31 & 0x3FFF00) >> 8;
      unsigned int v10 = __clz(__rbit32(v9));
      if (v9) {
        unsigned int v11 = v10 + 1;
      }
      else {
        unsigned int v11 = 0;
      }
      unsigned int v29 = v30 | v31 & 0x8E0000FF | (v11 << 8);
    }

    else
    {
      unsigned int v29 = v30 | 0xF0000;
    }
  }

  do
  {
    _dispatch_root_queue_drain(a1, v29, 0x20000LL);
    unint64_t v34 = (unint64_t)v31;
    if (v34 == -1LL) {
      _dispatch_abort(2395LL, 0LL, v12, v13, v14, v15, v16, v17);
    }
    if ((_dispatch_set_qos_class_enabled & 1) != 0)
    {
      unint64_t v35 = v34 & 0xFFFFFFFF02FFFFFFLL;
      unint64_t v18 = (unint64_t)_dispatch_thread_getspecific(4uLL);
      if ((v18 & 0x1000000) != 0)
      {
        if (v35) {
          unint64_t v25 = v34 & 0xFFFFFFFF02FFFFFFLL;
        }
        else {
          unint64_t v25 = v18 & 0xFFFFFFFFFEFFFFFFLL;
        }
        unint64_t v36 = v25;
      }

      else if (v35 == (v18 & 0xFFFFFFFF77FFFFFFLL))
      {
        unint64_t v36 = 0LL;
      }

      else
      {
        unint64_t v36 = v34 & 0xFFFFFFFF02FFFFFFLL;
      }
    }

    else
    {
      unint64_t v36 = 0LL;
    }

    if (v36 || _dispatch_thread_getspecific(0x1CuLL)) {
      _dispatch_set_priority_and_voucher_slow(v36, 0LL, 6);
    }
    dispatch_time_t v19 = dispatch_time(0LL, 5000000000LL);
  }

  while (!dispatch_semaphore_wait((dispatch_semaphore_t)(v32 + 72), v19));
  BOOL v23 = (unsigned int *)(a1 + 100);
  unsigned int v24 = *(_DWORD *)(a1 + 100);
  do
  {
    unsigned int v20 = v24;
    do
      unsigned int v21 = __ldaxr(v23);
    while (v21 == v24 && __stlxr(v24 + 1, v23));
    unsigned int v24 = v21;
  }

  while (v21 != v20);
  _dispatch_root_queue_poke(a1, 1LL, 0LL);
  _dispatch_release((unsigned int *)a1);
  return 0LL;
}

uint64_t _dispatch_root_queue_drain(uint64_t a1, unsigned int a2, int a3)
{
  uint64_t v51 = a1;
  unsigned int v50 = a2;
  int v49 = a3;
  unint64_t v48 = _dispatch_thread_getspecific(0x14uLL);
  if (v48)
  {
    BOOL v47 = v48;
    qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: Premature thread recycling";
    qword_E4DA8 = (uint64_t)v48;
    __break(1u);
    JUMPOUT(0x4F9A8LL);
  }

  uint64_t v46 = v51;
  uint64_t v52 = v51;
  _dispatch_thread_setspecific(20LL, v51);
  unsigned int v59 = v50;
  BOOL v9 = _dispatch_thread_getspecific(0x19uLL) == 0;
  BOOL v61 = v9;
  uint64_t v60 = 2319LL;
  if (!v9) {
    _dispatch_abort(v60, v61, v3, v4, v5, v6, v7, v8);
  }
  _dispatch_thread_setspecific(25LL, v59);
  unint64_t v66 = (unint64_t)_dispatch_thread_getspecific(0x1BuLL);
  unint64_t v64 = v66 & 0xFFFFFFFFFFFFFFFELL;
  if ((v66 & 0xFFFFFFFFFFFFFFFELL) == 0xFFFFFFFFFFFFFFFCLL)
  {
    char v65 = 0;
  }

  else
  {
    _dispatch_thread_getspecific(0LL);
    _dispatch_log("%u\t%p\twlh[anon]: set current (releasing %p)", v10, v11, v12, v13, v14, v15, v16, 825LL);
    unint64_t v68 = v64;
    if (v64 && v68 != -4LL)
    {
      unint64_t v67 = v68;
      uint64_t v81 = (void *)v68;
      int v80 = 0;
      int v78 = 1;
      int v77 = 1;
      int v79 = 1;
      unsigned int v75 = 0;
      int v73 = 1;
      int v72 = 1;
      int v74 = 1;
      int v41 = (unsigned int *)(v68 + 96);
      unsigned int v42 = *(_DWORD *)(v68 + 96);
      do
      {
        unsigned int v17 = v42;
        do
          unsigned int v18 = __ldaxr(v41);
        while (v18 == v42 && __stlxr(v42 - 1, v41));
        unsigned int v42 = v18;
      }

      while (v18 != v17);
      unsigned int v71 = v18;
      unsigned int v75 = v18;
      unsigned int v70 = v18;
      unsigned int v76 = v18 - v79;
      int v80 = v18 - v79;
      if (((v18 - v79) & 0x80000000) != 0)
      {
        if (v80 <= -2)
        {
          qword_E4D78 = (uint64_t)"API MISUSE: Over-release of an object";
          __break(1u);
          JUMPOUT(0x4FBE4LL);
        }

        v81[7] = 0xDEAD000000000000LL;
        unint64_t v69 = v81;
        _dispatch_object_dealloc(v81);
      }
    }

    _dispatch_thread_setspecific(27LL, -4LL);
    char v65 = 1;
  }

  if ((v65 & 1) == 0)
  {
    qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: Lingering DISPATCH_WLH_ANON";
    __break(1u);
    JUMPOUT(0x4FC54LL);
  }

  unsigned int v45 = 0LL;
  BOOL v44 = 0;
  memset(v43, 0, sizeof(v43));
  _dispatch_last_resort_autorelease_pool_push((uint64_t)v43);
  while (1)
  {
    unsigned int v45 = (void *)_dispatch_root_queue_drain_one(v51, v19, v20, v21, v22, v23, v24, v25);
    if (!v45) {
      break;
    }
    if (v44 && (_dispatch_set_qos_class_enabled & 1) != 0) {
      _pthread_workqueue_override_reset();
    }
    _dispatch_continuation_pop_inline(v45, (uint64_t)v43, v49, v51);
    unsigned int v56 = 0;
    unsigned int v56 = _dispatch_thread_getspecific(0x19uLL);
    int v58 = v56 & 0xF0000;
    unsigned int v55 = (v56 & 0xF0000) >> 16;
    if ((v56 & 0xF0000) >> 16)
    {
      v56 &= 0xFFF0FFFF;
      _dispatch_thread_setspecific(25LL, v56);
      BOOL v57 = v55 != 15;
    }

    else
    {
      BOOL v57 = 0;
    }

    BOOL v44 = v57;
    uint64_t v54 = v43;
    unint64_t v53 = 0LL;
    unint64_t v53 = _dispatch_thread_getspecific(0x78uLL);
    _dispatch_thread_setspecific(120LL, 0LL);
  }

  _dispatch_last_resort_autorelease_pool_pop((uint64_t)v43);
  BOOL v32 = _dispatch_thread_getspecific(0x1BuLL) == (void *)-4LL;
  BOOL v63 = v32;
  uint64_t v62 = 871LL;
  if (!v32) {
    _dispatch_abort(v62, v63, v26, v27, v28, v29, v30, v31);
  }
  _dispatch_thread_getspecific(0LL);
  _dispatch_log("%u\t%p\twlh[anon]: clear current", v33, v34, v35, v36, v37, v38, v39, 872LL);
  _dispatch_thread_setspecific(27LL, 0LL);
  _dispatch_thread_setspecific(5LL, 0LL);
  _dispatch_thread_setspecific(25LL, 0LL);
  return _dispatch_thread_setspecific(20LL, 0LL);
}

unint64_t _dispatch_root_queue_drain_one( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  while (1)
  {
    while (1)
    {
      uint64_t v16 = (unint64_t *)(a1 + 104);
      unint64_t v17 = *(void *)(a1 + 104);
      do
      {
        unint64_t v8 = v17;
        do
          unint64_t v9 = __ldaxr(v16);
        while (v9 == v17 && __stlxr(0xFFFFFFFFFFFFFFFFLL, v16));
        unint64_t v15 = v9;
        unint64_t v17 = v9;
      }

      while (v9 != v8);
      if (v9) {
        break;
      }
      uint64_t v10 = (unint64_t *)(a1 + 104);
      do
        unint64_t v11 = __ldaxr(v10);
      while (v11 == -1LL && __stlxr(0LL, v10));
      if (v11 == -1LL
        && (!*(void *)(a1 + 48)
         || !__DISPATCH_ROOT_QUEUE_CONTENDED_WAIT__(a1, _dispatch_root_queue_head_tail_quiesced, a3, a4, a5, a6, a7, a8)))
      {
        return 0LL;
      }
    }

    if (v9 != -1LL) {
      break;
    }
    if (!__DISPATCH_ROOT_QUEUE_CONTENDED_WAIT__( a1,  (uint64_t (*)(uint64_t))_dispatch_root_queue_mediator_is_gone,  a3,  a4,  a5,  a6,  a7,  a8)) {
      return 0LL;
    }
  }

  uint64_t v19 = *(void *)(v9 + 16);
  if (!v19)
  {
    *(void *)(a1 + 104) = 0LL;
    uint64_t v12 = (unint64_t *)(a1 + 48);
    do
      unint64_t v13 = __ldaxr(v12);
    while (v13 == v9 && __stlxr(0LL, v12));
    if (v13 == v9) {
      return v15;
    }
    uint64_t v18 = *(void *)(v9 + 16);
    if (!v18) {
      uint64_t v18 = _dispatch_wait_for_enqueuer((unint64_t *)(v9 + 16), a1 + 48);
    }
    uint64_t v19 = v18;
  }

  *(void *)(a1 + 104) = v19;
  _dispatch_root_queue_poke((unsigned int *)a1, 1u, 0, a4, a5, a6, a7, a8);
  return v15;
}

BOOL __DISPATCH_ROOT_QUEUE_CONTENDED_WAIT__( uint64_t a1, uint64_t (*a2)(uint64_t), uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  mach_msg_timeout_t v29 = 500;
  int v28 = 1;
  char v27 = 0;
  while (1)
  {
    BOOL v26 = 0;
    int v25 = 79;
    do
    {
      if (!v25--) {
        break;
      }
      __yield();
      int v28 = a2(a1);
      BOOL v26 = v28 != 0;
    }

    while (!v28);
    if (v26) {
      break;
    }
    if ((v27 & 1) == 0)
    {
      uint64_t v23 = (unsigned int *)(a1 + 112);
      unsigned int v24 = *(_DWORD *)(a1 + 112);
      do
      {
        unsigned int v9 = v24;
        do
          unsigned int v10 = __ldaxr(v23);
        while (v10 == v24 && __stlxr(v24 + 1, v23));
        unsigned int v24 = v10;
      }

      while (v10 != v9);
      char v27 = 1;
    }

    thread_switch(0, 3, v29);
    int v28 = a2(a1);
    if (v28) {
      break;
    }
    v29 *= 2;
    if (v29 >= 0x186A0)
    {
      _dispatch_thread_getspecific(0LL);
      _dispatch_log("%u\t%p\tcontention on global queue: %p", v11, v12, v13, v14, v15, v16, v17, 7076LL);
      break;
    }
  }

  if ((v27 & 1) != 0)
  {
    uint64_t v21 = (unsigned int *)(a1 + 112);
    unsigned int v22 = *(_DWORD *)(a1 + 112);
    do
    {
      unsigned int v18 = v22;
      do
        unsigned int v19 = __ldaxr(v21);
      while (v19 == v22 && __stlxr(v22 - 1, v21));
      unsigned int v22 = v19;
    }

    while (v19 != v18);
    if (*(void *)(a1 + 48)) {
      int v28 = 1;
    }
  }

  if (!v28) {
    _dispatch_root_queue_poke((unsigned int *)a1, 1u, 0, a4, a5, a6, a7, a8);
  }
  return v28 == 1;
}

uint64_t _dispatch_root_queue_head_tail_quiesced(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 48);
  if ((*(void *)(a1 + 104) == 0LL) == (v2 == 0))
  {
    if (v2) {
      return 1;
    }
    else {
      return 2;
    }
  }

  else
  {
    return 0;
  }

BOOL _dispatch_root_queue_mediator_is_gone(uint64_t a1)
{
  return *(void *)(a1 + 104) != -1LL;
}

void _dispatch_root_queue_init_pthread_pool(uint64_t a1, int a2, int a3)
{
  uint64_t v6 = *(void *)(a1 + 32);
  int v5 = 32;
  if (a3 >= 0) {
    int v5 = MEMORY[0xFFFFFC034];
  }
  if (a2 && a2 < v5) {
    int v5 = a2;
  }
  *(_DWORD *)(a1 + 100) = v5;
  else {
    int v4 = (unsigned __int16)(a3 & 0xF000) >> 12;
  }
  unint64_t v3 = (v4 - 1);
  if (v3 <= 5) {
    __asm { BR              X8 }
  }

  *(void *)(v6 + 72) = _OS_dispatch_semaphore_vtable;
  *(_DWORD *)(v6 + 136) = 0;
  if (!*(_DWORD *)(v6 + 136)) {
    _dispatch_sema4_create_slow((unsigned int *)(v6 + 136), 2);
  }
}

void _dispatch_mgr_priority_raise(pthread_attr_t *a1)
{
  int v25 = a1;
  uint64_t v35 = &_dispatch_mgr_sched_pred;
  uint64_t v34 = 0LL;
  dispatch_function_t v33 = (dispatch_function_t)_dispatch_mgr_sched_init;
  if (_dispatch_mgr_sched_pred != -1LL) {
    dispatch_once_f(v35, v34, v33);
  }
  sched_param v24 = 0LL;
  int v23 = pthread_attr_getschedparam(v25, &v24);
  uint64_t v29 = v23;
  uint64_t v28 = 6293LL;
  if (v23) {
    _dispatch_bug(v28, v29, v1, v2, v3, v4, v5, v6);
  }
  int v22 = v23;
  qos_class_t v21 = QOS_CLASS_UNSPECIFIED;
  qos_class_t __qos_class = QOS_CLASS_UNSPECIFIED;
  pthread_attr_get_qos_class_np(v25, &__qos_class, 0LL);
  if (__qos_class)
  {
    v24.signed int sched_priority = _dispatch_mgr_sched_qos2prio(__qos_class);
    while (1)
    {
      qos_class_t v7 = _os_atomic_mo_has_acquire(0) ? __ldaxr((unsigned int *)&dword_E505C) : __ldxr((unsigned int *)&dword_E505C);
      qos_class_t v21 = v7;
      if (v7 >= __qos_class) {
        break;
      }
      if (_os_atomic_mo_has_release(0)) {
        BOOL v19 = __stlxr(__qos_class, (unsigned int *)&dword_E505C) == 0;
      }
      else {
        BOOL v19 = __stxr(__qos_class, (unsigned int *)&dword_E505C) == 0;
      }
      if (v19) {
        goto LABEL_16;
      }
    }

    __clrex();
  }

LABEL_16:
  signed int sched_priority = v24.sched_priority;
  do
  {
    if (_os_atomic_mo_has_acquire(0)) {
      signed int v8 = __ldaxr((unsigned int *)&_dispatch_mgr_sched);
    }
    else {
      signed int v8 = __ldxr((unsigned int *)&_dispatch_mgr_sched);
    }
    if (v8 >= sched_priority)
    {
      __clrex();
      return;
    }

    if (_os_atomic_mo_has_release(0)) {
      BOOL v17 = __stlxr(sched_priority, (unsigned int *)&_dispatch_mgr_sched) == 0;
    }
    else {
      BOOL v17 = __stxr(sched_priority, (unsigned int *)&_dispatch_mgr_sched) == 0;
    }
  }

  while (!v17);
  BOOL v32 = &_dispatch_root_queues_pred;
  uint64_t v31 = 0LL;
  dispatch_function_t v30 = (dispatch_function_t)_dispatch_root_queues_init_once;
  if (_dispatch_root_queues_pred != -1LL) {
    dispatch_once_f(v32, v31, v30);
  }
  if ((_dispatch_kevent_workqueue_enabled & 1) != 0)
  {
    uint64_t v16 = 0LL;
    if (sched_priority <= dword_E5060)
    {
      if (__qos_class) {
        uint64_t v16 = _pthread_qos_class_encode(__qos_class, 0LL, 0LL);
      }
    }

    else
    {
      uint64_t v16 = sched_priority | 0x20000000LL;
    }

    if (v16)
    {
      int v15 = _pthread_workqueue_set_event_manager_priority(v16);
      uint64_t v27 = v15;
      uint64_t v26 = 6325LL;
      if (v15) {
        _dispatch_bug(v26, v27, v9, v10, v11, v12, v13, v14);
      }
    }
  }

  else if (qword_E5068)
  {
    _dispatch_mgr_priority_apply();
  }

void _dispatch_runloop_queue_class_poke(uint64_t a1)
{
  unsigned int v10 = *(void *)(a1 + 32);
  BOOL v8 = 0;
  if (v10) {
    BOOL v8 = v10 != -1;
  }
  if (v8)
  {
    int v9 = _dispatch_send_wakeup_runloop_thread(v10, 0);
    if (v9 != 16 && v9 != 268435460 && v9 != 268435459)
    {
      if (v9) {
        _dispatch_bug(7895LL, v9, v1, v2, v3, v4, v5, v6);
      }
    }
  }

uint64_t _dispatch_main_queue_update_priority_from_thread()
{
  uint64_t v13 = *(void *)&dword_E4078;
  if ((dword_E4078 & 0xFFFFFFFC) != 0) {
    unsigned int v15 = dword_E4078 | 3;
  }
  else {
    unsigned int v15 = 0;
  }
  uint64_t result = (uint64_t)_dispatch_thread_getspecific(4uLL);
  if ((result & 0x20000000) != 0) {
    _dispatch_abort(458LL, (result & 0x20000000) == 0, v1, v2, v3, v4, v5, v6);
  }
  unsigned int v7 = (result & 0x3FFF00) >> 8;
  unsigned int v8 = __clz(__rbit32(v7));
  if (v7) {
    unsigned int v9 = v8 + 1;
  }
  else {
    unsigned int v9 = 0;
  }
  unsigned int v12 = ((result | (v9 << 8)) & 0xF00) >> 8;
  unsigned int v11 = (v13 & 0x700000000uLL) >> 32;
  unsigned int v10 = (unsigned __int16)(dword_E4094 & 0xF00) >> 8;
  dword_E4094 = result | (v9 << 8);
  if (v10 < v11 && !v12)
  {
    if ((_dispatch_set_qos_class_enabled & 1) == 0) {
      return result;
    }
    return _pthread_qos_override_end_direct(v15, &_dispatch_main_q);
  }

  if (v10 >= v11 || v11 > v12)
  {
    if (v12 < v11 && v11 <= v10)
    {
      uint64_t v14 = 0LL;
      if (v11) {
        uint64_t v14 = 1LL << (v11 + 7);
      }
      if ((_dispatch_set_qos_class_enabled & 1) != 0) {
        return _pthread_qos_override_start_direct(v15, v14 | 0xFF, &_dispatch_main_q);
      }
    }
  }

  else if ((_dispatch_set_qos_class_enabled & 1) != 0)
  {
    return _pthread_qos_override_end_direct(v15, &_dispatch_main_q);
  }

  return result;
}

uint64_t _dispatch_root_queues_init_once(uint64_t a1)
{
  uint64_t v10 = a1;
  if ((_dispatch_unsafe_fork & 1) == 0) {
    _dispatch_fork_becomes_unsafe_slow();
  }
  int v9 = _pthread_workqueue_supported();
  int v8 = 45;
  if ((v9 & 0x10) == 0)
  {
    qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: QoS Maintenance support required";
    qword_E4DA8 = v9;
    __break(1u);
    JUMPOUT(0x51594LL);
  }

  __int128 v4 = 0x200000000uLL;
  __int128 v5 = 0uLL;
  uint64_t v6 = 64LL;
  uint64_t v7 = 72LL;
  if ((_dispatch_kevent_workqueue_enabled & 1) != 0)
  {
    if ((v9 & 0x80) != 0)
    {
      *((void *)&v5 + 1) = _dispatch_worker_thread2;
      *((void *)&v4 + 1) = _dispatch_kevent_worker_thread;
      *(void *)&__int128 v5 = _dispatch_workloop_worker_thread;
      uint64_t result = pthread_workqueue_setup(&v4, 48LL);
      int v8 = result;
    }

    else
    {
      if ((v9 & 0x40) == 0)
      {
        qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: Missing Kevent WORKQ support";
        qword_E4DA8 = v9;
        __break(1u);
        JUMPOUT(0x516DCLL);
      }

      *((void *)&v5 + 1) = _dispatch_worker_thread2;
      *((void *)&v4 + 1) = _dispatch_kevent_worker_thread;
      uint64_t result = pthread_workqueue_setup(&v4, 48LL);
      int v8 = result;
    }
  }

  else
  {
    *((void *)&v5 + 1) = _dispatch_worker_thread2;
    uint64_t result = pthread_workqueue_setup(&v4, 48LL);
    int v8 = result;
  }

  if (v8)
  {
    qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: Root queue initialization failed";
    qword_E4DA8 = v9 | (v8 << 16);
    __break(1u);
    JUMPOUT(0x51744LL);
  }

  if ((_dispatch_mode & 4) != 0)
  {
    int v3 = -1;
    uint64_t result = sysctlbyname("kern.wq_limit_cooperative_threads", 0LL, 0LL, &v3, 4uLL);
    int v8 = result;
    if ((_DWORD)result)
    {
      uint64_t v11 = 1LL;
      uint64_t v12 = 1LL;
      unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
      uint64_t v2 = **(int **)(StatusReg + 8);
      qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: Unable to limit cooperative pool size";
      qword_E4DA8 = v2;
      __break(1u);
      JUMPOUT(0x51804LL);
    }
  }

  return result;
}

uint64_t _dispatch_worker_thread2(uint64_t a1)
{
  BOOL v27 = (int)a1 < 0;
  BOOL v26 = (a1 & 0x8000000) != 0;
  unint64_t v29 = a1 & 0xFFFFFFFF88FFFFFFLL;
  _dispatch_thread_setspecific(4LL, v29);
  int v24 = 0;
  if (v26)
  {
    char v23 = 4;
    int v24 = 0x200000;
  }

  else
  {
    if (v27) {
      char v7 = 2;
    }
    else {
      char v7 = 0;
    }
    char v23 = v7;
  }

  unint64_t v30 = (v29 & 0x3FFF00) >> 8;
  unsigned int v8 = __clz(__rbit32(v30));
  if ((_DWORD)v30) {
    unsigned int v9 = v8 + 1;
  }
  else {
    unsigned int v9 = 0;
  }
  BOOL v22 = 1;
  if (v9) {
    BOOL v22 = v9 > 6;
  }
  if (v22)
  {
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Corrupted priority";
    qword_E4DA8 = v9;
    __break(1u);
    JUMPOUT(0x519E4LL);
  }

  int v31 = 0;
  if ((v23 & 2) != 0)
  {
    int v31 = 1;
  }

  else if ((v23 & 4) != 0)
  {
    int v31 = 2;
  }

  int v25 = &(&_dispatch_root_queues)[16 * (unint64_t)(3 * v9 + v31 - 3)];
  uint64_t v20 = (unsigned int *)(v25 + 14);
  unsigned int v21 = *((_DWORD *)v25 + 28);
  do
  {
    unsigned int v10 = v21;
    do
      unsigned int v11 = __ldaxr(v20);
    while (v11 == v21 && __stlxr(v21 - 1, v20));
    unsigned int v21 = v11;
  }

  while (v11 != v10);
  _dispatch_root_queue_drain((uint64_t)v25, *((_DWORD *)v25 + 21), v24 | 0x30000);
  _dispatch_thread_getspecific(0LL);
  _dispatch_log("%u\t%p\tvoucher[%p]: root queue clear", v12, v13, v14, v15, v16, v17, v18, 7400LL);
  if ((_dispatch_set_qos_class_enabled & 1) != 0)
  {
    unint64_t v32 = (unint64_t)_dispatch_thread_getspecific(4uLL);
    if ((v32 & 0x1000000) != 0) {
      unint64_t v33 = v32 & 0xFFFFFFFFFEFFFFFFLL;
    }
    else {
      unint64_t v33 = 0LL;
    }
  }

  else
  {
    unint64_t v33 = 0LL;
  }

  if (v33 || _dispatch_thread_getspecific(0x1CuLL)) {
    _dispatch_set_priority_and_voucher_slow(v33, 0LL, 14);
  }
  return _dispatch_thread_setspecific(120LL, 0LL);
}

void _dispatch_kevent_worker_thread( uint64_t *a1, unsigned int *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  BOOL v97 = 0;
  if (a1) {
    BOOL v97 = a2 != 0LL;
  }
  if (v97)
  {
    if (*a2 && *a1)
    {
      unint64_t v100 = (unint64_t)_dispatch_thread_getspecific(0x1BuLL) & 0xFFFFFFFFFFFFFFFELL;
      if (v100 == -4LL)
      {
        char v101 = 0;
      }

      else
      {
        _dispatch_thread_getspecific(0LL);
        _dispatch_log("%u\t%p\twlh[anon]: set current (releasing %p)", v8, v9, v10, v11, v12, v13, v14, 825LL);
        if (v100)
        {
          uint64_t v95 = (unsigned int *)(v100 + 96);
          unsigned int v96 = *(_DWORD *)(v100 + 96);
          do
          {
            unsigned int v15 = v96;
            do
              unsigned int v16 = __ldaxr(v95);
            while (v16 == v96 && __stlxr(v96 - 1, v95));
            unsigned int v96 = v16;
          }

          while (v16 != v15);
          if (((v16 - 1) & 0x80000000) != 0)
          {
            if ((int)(v16 - 1) <= -2)
            {
              qword_E4D78 = (uint64_t)"API MISUSE: Over-release of an object";
              __break(1u);
              JUMPOUT(0x521C8LL);
            }

            *(void *)(v100 + 56) = 0xDEAD000000000000LL;
            _dispatch_object_dealloc((void *)v100);
          }
        }

        _dispatch_thread_setspecific(27LL, -4LL);
        char v101 = 1;
      }

      if ((v101 & 1) == 0)
      {
        qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: Lingering DISPATCH_WLH_ANON";
        __break(1u);
        JUMPOUT(0x52238LL);
      }

      uint64_t v17 = *a1;
      uint64_t v114 = -4LL;
      uint64_t v113 = v17;
      unint64_t v112 = a2;
      _dispatch_thread_setspecific(120LL, 0LL);
      __int128 v111 = 0u;
      uint64_t v109 = 0LL;
      uint64_t v107 = 0LL;
      uint64_t v108 = 0LL;
      uint64_t v110 = -4LL;
      *(void *)&__int128 v111 = v113;
      DWORD2(v111) = 0;
      WORD6(v111) = 0;
      char v106 = 0;
      BOOL v105 = _dispatch_wlh_uses_bound_thread(-4LL);
      memset(&token_out, 0, sizeof(token_out));
      wg = 0LL;
      if (v105)
      {
        _dispatch_wlh_uses_bound_thread_setup(v114);
      }

      else
      {
        wg = (os_workgroup_s *)_dispatch_wlh_get_workgroup((void *)v114);
        if (wg)
        {
          int v102 = os_workgroup_join(wg, &token_out);
          if (v102 == 22)
          {
            _dispatch_thread_getspecific(0LL);
            _dispatch_log( "%u\t%p\twlh[%p]: Failed to join cancelled workgroup %p",  v24,  v25,  v26,  v27,  v28,  v29,  v30,  6679LL);
            wg = 0LL;
          }

          else if (v102)
          {
            qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: dispatch_workloop os_workgroup_join failed";
            qword_E4DA8 = v102;
            __break(1u);
            JUMPOUT(0x523ECLL);
          }
        }
      }

      unint64_t v140 = &v107;
      uint64_t v150 = v110;
      uint64_t v149 = 6518LL;
      if (!v110) {
        _dispatch_abort(v149, 0LL, v18, v19, v20, v21, v22, v23);
      }
      unint64_t v139 = 0LL;
      uint64_t v142 = 0LL;
      uint64_t v142 = (uint64_t)_dispatch_thread_getspecific(4uLL);
      unint64_t v139 = v142;
      if ((v142 & 0x2000000) != 0)
      {
        if ((v139 & 0x20000000) != 0)
        {
          uint64_t v170 = v139;
          unint64_t v139 = (unint64_t)BYTE3(v139) << 24;
        }

        uint64_t v145 = v139;
        uint64_t v144 = 0x1000000LL;
        uint64_t v143 = 0LL;
        v139 &= ~0x1000000uLL;
        _dispatch_thread_setspecific(4LL, v139);
        unsigned int v171 = 0x2000000;
        BOOL v44 = _dispatch_thread_getspecific(0x19uLL) == 0;
        BOOL v173 = v44;
        uint64_t v172 = 2331LL;
        if (!v44) {
          _dispatch_abort(v172, v173, v38, v39, v40, v41, v42, v43);
        }
        v171 |= 0xF0000u;
        _dispatch_thread_setspecific(25LL, v171);
        uint64_t v138 = &_dispatch_mgr_q;
        BOOL v151 = &_dispatch_mgr_q;
        _dispatch_thread_setspecific(20LL, (uint64_t)&_dispatch_mgr_q);
        BOOL v159 = &_dispatch_mgr_q;
        uint64_t v158 = 0LL;
        unint64_t v157 = 0LL;
        uint64_t v156 = 0LL;
        unsigned int v162 = _dispatch_thread_getspecific(3uLL);
        uint64_t v156 = v162 & 0xFFFFFFFC | 0x40020000000000LL;
        BOOL v155 = 0;
        BOOL v154 = (unint64_t *)(v159 + 7);
        do
        {
          if (_os_atomic_mo_has_acquire(2)) {
            unint64_t v45 = __ldaxr(v154);
          }
          else {
            unint64_t v45 = __ldxr(v154);
          }
          uint64_t v158 = v45;
          unint64_t v157 = v45;
          unint64_t v161 = v45;
          BOOL v94 = 1;
          if (!(v45 >> 53))
          {
            uint64_t v160 = v158;
            int v163 = v158;
            BOOL v94 = (v158 & 0xFFFFFFFC) != 0;
          }

          if (v94)
          {
            uint64_t v153 = v158;
            qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: Locking the manager should not fail";
            qword_E4DA8 = v158;
            __break(1u);
            JUMPOUT(0x52758LL);
          }

          v157 &= 0x7700000001uLL;
          v157 |= v156;
          if (_os_atomic_mo_has_release(2)) {
            BOOL v155 = __stlxr(v157, v154) == 0;
          }
          else {
            BOOL v155 = __stxr(v157, v154) == 0;
          }
        }

        while (!v155);
        BOOL v152 = v155;
        char v141 = 1;
      }

      else
      {
        uint64_t v148 = v139;
        uint64_t v147 = 2013265919LL;
        uint64_t v146 = 0LL;
        v139 &= 0xFFFFFFFF88FFFFFFLL;
        if (v140[3] == -4) {
          v139 |= 0x1000000uLL;
        }
        _dispatch_thread_setspecific(4LL, v139);
        if (v140[3] == -4)
        {
          *((_BYTE *)v140 + 44) = 1;
        }

        else
        {
          _dispatch_thread_getspecific(0LL);
          _dispatch_log("%u\t%p\twlh[%p]: handling events", v31, v32, v33, v34, v35, v36, v37, 6538LL);
        }

        char v141 = 0;
      }

      char v106 = v141;
      if ((v141 & 1) != 0)
      {
        uint64_t v47 = (int)*v112;
        int v131 = 1;
        BOOL v130 = &_dispatch_mgr_q;
        uint64_t v129 = v47;
        uint64_t v110 = -4LL;
      }

      else
      {
        if (v114 == -4) {
          uint64_t v93 = 0LL;
        }
        else {
          uint64_t v93 = v114;
        }
        uint64_t v46 = (int)*v112;
        int v134 = 1;
        uint64_t v133 = v93;
        uint64_t v132 = v46;
      }

      uint64_t v137 = &v107;
      _dispatch_thread_setspecific(29LL, (uint64_t)&v107);
      _dispatch_event_loop_merge(v113, *v112);
      if ((v106 & 1) != 0)
      {
        int v128 = 2;
        uint64_t v127 = &_dispatch_mgr_q;
        uint64_t v126 = 0LL;
        _dispatch_mgr_queue_drain();
        if (byte_E4E16) {
          _dispatch_event_loop_drain_timers((uint64_t)&_dispatch_timers_heap, 9u, v48, v49, v50, v51, v52, v53);
        }
        BOOL v165 = 0;
        uint64_t v179 = &_dispatch_mgr_q;
        unint64_t v178 = 0LL;
        unint64_t v177 = 0LL;
        BOOL v176 = 0;
        uint64_t v175 = (unint64_t *)&qword_E4178;
        do
        {
          if (_os_atomic_mo_has_acquire(3)) {
            unint64_t v54 = __ldaxr(v175);
          }
          else {
            unint64_t v54 = __ldxr(v175);
          }
          unint64_t v178 = v54;
          unint64_t v177 = (v54 - 0x40020000000000LL) & 0xFFFFFFF000000001LL;
          if (_os_atomic_mo_has_release(3)) {
            BOOL v176 = __stlxr(v177, v175) == 0;
          }
          else {
            BOOL v176 = __stxr(v177, v175) == 0;
          }
        }

        while (!v176);
        BOOL v174 = v176;
        unint64_t v180 = v178;
        BOOL v165 = (v178 & 0x8000000000LL) != 0;
        _dispatch_thread_setspecific(25LL, 0LL);
        uint64_t v164 = 0LL;
        uint64_t v169 = 0LL;
        _dispatch_thread_setspecific(20LL, 0LL);
        if (v165)
        {
          int v168 = 3;
          unint64_t v167 = &_dispatch_mgr_q;
          uint64_t v166 = 1LL;
          _dispatch_event_loop_poke((unsigned int *)0xFFFFFFFFFFFFFFF8LL, 0LL, 0LL, v55, v56, v57, v58, v59);
        }
      }

      else if (v108)
      {
        _dispatch_thread_getspecific(0LL);
        _dispatch_log("%u\t%p\twlh[%p]: draining deferred item %p", v60, v61, v62, v63, v64, v65, v66, 6708LL);
        if (v110 == -4)
        {
          BOOL v116 = WORD4(v111) == 0;
          uint64_t v115 = 6710LL;
          if (WORD4(v111)) {
            _dispatch_abort(v115, v116, v67, v68, v69, v70, v71, v72);
          }
          uint64_t v136 = 0LL;
          _dispatch_thread_setspecific(29LL, 0LL);
          int v125 = 2;
          uint64_t v124 = v107;
          uint64_t v123 = 0LL;
          _dispatch_root_queue_drain_deferred_item(&v107);
        }

        else
        {
          int v122 = 2;
          uint64_t v121 = v114;
          uint64_t v120 = 0LL;
          _dispatch_root_queue_drain_deferred_wlh(&v107);
        }
      }

      if (!v105 && wg) {
        os_workgroup_leave(wg, &token_out);
      }
      uint64_t v135 = 0LL;
      _dispatch_thread_setspecific(29LL, 0LL);
      _dispatch_thread_getspecific(0LL);
      _dispatch_log("%u\t%p\treturning %d deferred kevents", v73, v74, v75, v76, v77, v78, v79, 6735LL);
      _dispatch_thread_setspecific(5LL, 0LL);
      _dispatch_thread_setspecific(120LL, 0LL);
      *unint64_t v112 = WORD4(v111);
      int v119 = 4;
      uint64_t v118 = 0LL;
      uint64_t v117 = 0LL;
      _dispatch_thread_getspecific(0LL);
      _dispatch_log("%u\t%p\twlh[anon]: clear current", v86, v87, v88, v89, v90, v91, v92, 872LL);
      _dispatch_thread_setspecific(27LL, 0LL);
      _dispatch_thread_setspecific(5LL, 0LL);
    }
  }

  else
  {
    _dispatch_bug(6755LL, v97, a3, a4, a5, a6, a7, a8);
  }

void _dispatch_workloop_worker_thread( void *a1, uint64_t *a2, unsigned int *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  BOOL v108 = 0;
  if (a1)
  {
    BOOL v108 = 0;
    if (a2) {
      BOOL v108 = a3 != 0LL;
    }
  }

  if (v108)
  {
    BOOL v110 = *a1 != 0LL;
    if (!*a1) {
      _dispatch_bug(6777LL, *a1 != 0LL, (uint64_t)a3, a4, a5, a6, a7, a8);
    }
    if (v110)
    {
      if (*a3 && *a2)
      {
        uint64_t v109 = (void *)*a1;
        BOOL v194 = (void *)*a1;
        unint64_t v197 = (unint64_t)_dispatch_thread_getspecific(0x1BuLL);
        unint64_t v193 = v197 & 0xFFFFFFFFFFFFFFFELL;
        _dispatch_thread_getspecific(0LL);
        _dispatch_log("%u\t%p\twlh[%p]: adopt current (releasing %p)", v8, v9, v10, v11, v12, v13, v14, 845LL);
        if ((v197 & 0xFFFFFFFFFFFFFFFELL) == 0xFFFFFFFFFFFFFFFCLL)
        {
          qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: Lingering DISPATCH_WLH_ANON";
          __break(1u);
          JUMPOUT(0x52EBCLL);
        }

        if (v193 != (void)v194)
        {
          uint64_t v196 = (uint64_t)v194;
          uint64_t v195 = 850LL;
          if (!v194) {
            _dispatch_abort(v195, 0LL, v15, v16, v17, v18, v19, v20);
          }
          unint64_t v199 = v193;
          if (v193)
          {
            unint64_t v198 = v199;
            unsigned int v212 = (void *)v199;
            int v211 = 0;
            int v209 = 1;
            int v208 = 1;
            int v210 = 1;
            unsigned int v206 = 0;
            int v204 = 1;
            int v203 = 1;
            int v205 = 1;
            char v106 = (unsigned int *)(v199 + 96);
            unsigned int v107 = *(_DWORD *)(v199 + 96);
            do
            {
              unsigned int v21 = v107;
              do
                unsigned int v22 = __ldaxr(v106);
              while (v22 == v107 && __stlxr(v107 - 1, v106));
              unsigned int v107 = v22;
            }

            while (v22 != v21);
            unsigned int v202 = v22;
            unsigned int v206 = v22;
            unsigned int v201 = v22;
            unsigned int v207 = v22 - v210;
            int v211 = v22 - v210;
            if (((v22 - v210) & 0x80000000) != 0)
            {
              if (v211 <= -2)
              {
                qword_E4D78 = (uint64_t)"API MISUSE: Over-release of an object";
                __break(1u);
                JUMPOUT(0x53044LL);
              }

              v212[7] = 0xDEAD000000000000LL;
              unsigned int v200 = v212;
              _dispatch_object_dealloc(v212);
            }
          }

          uint64_t v219 = (uint64_t)v194;
          if (v194 && v219 != -4)
          {
            uint64_t v218 = v219;
            uint64_t v231 = v219;
            unsigned int v230 = 0;
            int v228 = 1;
            int v227 = 1;
            int v229 = 1;
            unsigned int v225 = 0;
            int v223 = 1;
            int v222 = 1;
            int v224 = 1;
            uint64_t v104 = (unsigned int *)(v219 + 96);
            unsigned int v105 = *(_DWORD *)(v219 + 96);
            do
            {
              unsigned int v23 = v105;
              do
                unsigned int v24 = __ldaxr(v104);
              while (v24 == v105 && __stlxr(v105 + 1, v104));
              unsigned int v105 = v24;
            }

            while (v24 != v23);
            unsigned int v221 = v24;
            unsigned int v225 = v24;
            unsigned int v220 = v24;
            unsigned int v226 = v24 + v229;
            unsigned int v230 = v24 + v229;
            if ((int)(v24 + v229) <= 0)
            {
              qword_E4D78 = (uint64_t)"API MISUSE: Resurrection of an object";
              __break(1u);
              JUMPOUT(0x531A4LL);
            }
          }
        }

        _dispatch_thread_setspecific(27LL, (uint64_t)v194);
        uint64_t v25 = *a2;
        uint64_t v126 = v109;
        uint64_t v125 = v25;
        uint64_t v124 = a3;
        _dispatch_thread_setspecific(120LL, 0LL);
        __int128 v123 = 0u;
        uint64_t v121 = 0LL;
        uint64_t v119 = 0LL;
        uint64_t v120 = 0LL;
        uint64_t v122 = (uint64_t)v109;
        *(void *)&__int128 v123 = v125;
        DWORD2(v123) = 0;
        WORD6(v123) = 0;
        char v118 = 0;
        BOOL v117 = _dispatch_wlh_uses_bound_thread((uint64_t)v109);
        memset(&token_out, 0, sizeof(token_out));
        wg = 0LL;
        if (v117)
        {
          _dispatch_wlh_uses_bound_thread_setup((uint64_t)v126);
        }

        else
        {
          wg = (os_workgroup_s *)_dispatch_wlh_get_workgroup(v126);
          if (wg)
          {
            int v114 = os_workgroup_join(wg, &token_out);
            if (v114 == 22)
            {
              _dispatch_thread_getspecific(0LL);
              _dispatch_log( "%u\t%p\twlh[%p]: Failed to join cancelled workgroup %p",  v32,  v33,  v34,  v35,  v36,  v37,  v38,  6679LL);
              wg = 0LL;
            }

            else if (v114)
            {
              qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: dispatch_workloop os_workgroup_join failed";
              qword_E4DA8 = v114;
              __break(1u);
              JUMPOUT(0x5336CLL);
            }
          }
        }

        BOOL v152 = &v119;
        uint64_t v162 = v122;
        uint64_t v161 = 6518LL;
        if (!v122) {
          _dispatch_abort(v161, 0LL, v26, v27, v28, v29, v30, v31);
        }
        unint64_t v151 = 0LL;
        uint64_t v154 = 0LL;
        uint64_t v154 = (uint64_t)_dispatch_thread_getspecific(4uLL);
        unint64_t v151 = v154;
        if ((v154 & 0x2000000) != 0)
        {
          if ((v151 & 0x20000000) != 0)
          {
            uint64_t v182 = v151;
            unint64_t v151 = (unint64_t)BYTE3(v151) << 24;
          }

          uint64_t v157 = v151;
          uint64_t v156 = 0x1000000LL;
          uint64_t v155 = 0LL;
          v151 &= ~0x1000000uLL;
          _dispatch_thread_setspecific(4LL, v151);
          unsigned int v183 = 0x2000000;
          BOOL v52 = _dispatch_thread_getspecific(0x19uLL) == 0;
          BOOL v185 = v52;
          uint64_t v184 = 2331LL;
          if (!v52) {
            _dispatch_abort(v184, v185, v46, v47, v48, v49, v50, v51);
          }
          v183 |= 0xF0000u;
          _dispatch_thread_setspecific(25LL, v183);
          uint64_t v150 = &_dispatch_mgr_q;
          int v163 = &_dispatch_mgr_q;
          _dispatch_thread_setspecific(20LL, (uint64_t)&_dispatch_mgr_q);
          unsigned int v171 = &_dispatch_mgr_q;
          uint64_t v170 = 0LL;
          unint64_t v169 = 0LL;
          uint64_t v168 = 0LL;
          unsigned int v174 = _dispatch_thread_getspecific(3uLL);
          uint64_t v168 = v174 & 0xFFFFFFFC | 0x40020000000000LL;
          BOOL v167 = 0;
          uint64_t v166 = (unint64_t *)(v171 + 7);
          do
          {
            if (_os_atomic_mo_has_acquire(2)) {
              unint64_t v53 = __ldaxr(v166);
            }
            else {
              unint64_t v53 = __ldxr(v166);
            }
            uint64_t v170 = v53;
            unint64_t v169 = v53;
            unint64_t v173 = v53;
            BOOL v103 = 1;
            if (!(v53 >> 53))
            {
              uint64_t v172 = v170;
              int v175 = v170;
              BOOL v103 = (v170 & 0xFFFFFFFC) != 0;
            }

            if (v103)
            {
              uint64_t v165 = v170;
              qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: Locking the manager should not fail";
              qword_E4DA8 = v170;
              __break(1u);
              JUMPOUT(0x536D8LL);
            }

            v169 &= 0x7700000001uLL;
            v169 |= v168;
            if (_os_atomic_mo_has_release(2)) {
              BOOL v167 = __stlxr(v169, v166) == 0;
            }
            else {
              BOOL v167 = __stxr(v169, v166) == 0;
            }
          }

          while (!v167);
          BOOL v164 = v167;
          char v153 = 1;
        }

        else
        {
          uint64_t v160 = v151;
          uint64_t v159 = 2013265919LL;
          uint64_t v158 = 0LL;
          v151 &= 0xFFFFFFFF88FFFFFFLL;
          if (v152[3] == -4) {
            v151 |= 0x1000000uLL;
          }
          _dispatch_thread_setspecific(4LL, v151);
          if (v152[3] == -4)
          {
            *((_BYTE *)v152 + 44) = 1;
          }

          else
          {
            _dispatch_thread_getspecific(0LL);
            _dispatch_log("%u\t%p\twlh[%p]: handling events", v39, v40, v41, v42, v43, v44, v45, 6538LL);
          }

          char v153 = 0;
        }

        char v118 = v153;
        if ((v153 & 1) != 0)
        {
          uint64_t v55 = (int)*v124;
          int v143 = 1;
          uint64_t v142 = &_dispatch_mgr_q;
          uint64_t v141 = v55;
          uint64_t v122 = -4LL;
        }

        else
        {
          if (v126 == (void *)-4LL) {
            int v102 = 0LL;
          }
          else {
            int v102 = v126;
          }
          uint64_t v54 = (int)*v124;
          int v146 = 1;
          uint64_t v145 = v102;
          uint64_t v144 = v54;
        }

        uint64_t v149 = &v119;
        _dispatch_thread_setspecific(29LL, (uint64_t)&v119);
        _dispatch_event_loop_merge(v125, *v124);
        if ((v118 & 1) != 0)
        {
          int v140 = 2;
          unint64_t v139 = &_dispatch_mgr_q;
          uint64_t v138 = 0LL;
          _dispatch_mgr_queue_drain();
          if (byte_E4E16) {
            _dispatch_event_loop_drain_timers((uint64_t)&_dispatch_timers_heap, 9u, v56, v57, v58, v59, v60, v61);
          }
          BOOL v177 = 0;
          int v191 = &_dispatch_mgr_q;
          unint64_t v190 = 0LL;
          unint64_t v189 = 0LL;
          BOOL v188 = 0;
          uint64_t v187 = (unint64_t *)&qword_E4178;
          do
          {
            if (_os_atomic_mo_has_acquire(3)) {
              unint64_t v62 = __ldaxr(v187);
            }
            else {
              unint64_t v62 = __ldxr(v187);
            }
            unint64_t v190 = v62;
            unint64_t v189 = (v62 - 0x40020000000000LL) & 0xFFFFFFF000000001LL;
            if (_os_atomic_mo_has_release(3)) {
              BOOL v188 = __stlxr(v189, v187) == 0;
            }
            else {
              BOOL v188 = __stxr(v189, v187) == 0;
            }
          }

          while (!v188);
          BOOL v186 = v188;
          unint64_t v192 = v190;
          BOOL v177 = (v190 & 0x8000000000LL) != 0;
          _dispatch_thread_setspecific(25LL, 0LL);
          uint64_t v176 = 0LL;
          uint64_t v181 = 0LL;
          _dispatch_thread_setspecific(20LL, 0LL);
          if (v177)
          {
            int v180 = 3;
            uint64_t v179 = &_dispatch_mgr_q;
            uint64_t v178 = 1LL;
            _dispatch_event_loop_poke((unsigned int *)0xFFFFFFFFFFFFFFF8LL, 0LL, 0LL, v63, v64, v65, v66, v67);
          }
        }

        else if (v120)
        {
          _dispatch_thread_getspecific(0LL);
          _dispatch_log("%u\t%p\twlh[%p]: draining deferred item %p", v68, v69, v70, v71, v72, v73, v74, 6708LL);
          if (v122 == -4)
          {
            BOOL v128 = WORD4(v123) == 0;
            uint64_t v127 = 6710LL;
            if (WORD4(v123)) {
              _dispatch_abort(v127, v128, v75, v76, v77, v78, v79, v80);
            }
            uint64_t v148 = 0LL;
            _dispatch_thread_setspecific(29LL, 0LL);
            int v137 = 2;
            uint64_t v136 = v119;
            uint64_t v135 = 0LL;
            _dispatch_root_queue_drain_deferred_item(&v119);
          }

          else
          {
            int v134 = 2;
            uint64_t v133 = v126;
            uint64_t v132 = 0LL;
            _dispatch_root_queue_drain_deferred_wlh(&v119);
          }
        }

        if (!v117 && wg) {
          os_workgroup_leave(wg, &token_out);
        }
        uint64_t v147 = 0LL;
        _dispatch_thread_setspecific(29LL, 0LL);
        _dispatch_thread_getspecific(0LL);
        _dispatch_log("%u\t%p\treturning %d deferred kevents", v81, v82, v83, v84, v85, v86, v87, 6735LL);
        _dispatch_thread_setspecific(5LL, 0LL);
        _dispatch_thread_setspecific(120LL, 0LL);
        *uint64_t v124 = WORD4(v123);
        int v131 = 4;
        uint64_t v130 = 0LL;
        uint64_t v129 = 0LL;
        unint64_t v213 = (unint64_t)v109;
        BOOL v217 = (void *)((char *)v109 + 4) != 0LL;
        uint64_t v216 = 861LL;
        if (v109 == (void *)-4LL) {
          _dispatch_abort(v216, v217, v88, v89, v90, v91, v92, v93);
        }
        char v101 = (void *)v213;
        BOOL v100 = v101 == _dispatch_thread_getspecific(0x1BuLL);
        BOOL v215 = v100;
        uint64_t v214 = 862LL;
        if (!v100) {
          _dispatch_abort(v214, v215, v94, v95, v96, v97, v98, v99);
        }
        _dispatch_thread_setspecific(27LL, v213 | 1);
      }
    }

    else
    {
      _dispatch_kevent_worker_thread(a2, a3, (uint64_t)a3, a4, a5, a6, a7, a8);
    }
  }

  else
  {
    _dispatch_bug(6774LL, v108, (uint64_t)a3, a4, a5, a6, a7, a8);
  }

BOOL _dispatch_wlh_uses_bound_thread(uint64_t a1)
{
  return a1 != -4 && *(void *)(*(void *)a1 + 16LL) == 131090LL && _dispatch_workloop_uses_bound_thread(a1);
}

uint64_t _dispatch_wlh_uses_bound_thread_setup(uint64_t result)
{
  uint64_t v2 = result;
  if (*(void *)(result + 72))
  {
    uint64_t result = (uint64_t)_dispatch_thread_getspecific(0x7CuLL);
    if (!result)
    {
      pthread_setname_np(*(const char **)(v2 + 72));
      uint64_t result = _dispatch_thread_setspecific(124LL, 1LL);
    }
  }

  if (*(void *)(v2 + 200) && *(void *)(*(void *)(v2 + 200) + 32LL))
  {
    uint64_t result = (uint64_t)_dispatch_thread_getspecific(0x73uLL);
    if (!result)
    {
      uint64_t v1 = _dispatch_calloc(1LL, 40LL);
      _os_workgroup_join_update_wg(*(void *)(*(void *)(v2 + 200) + 32LL), v1);
      return _dispatch_thread_setspecific(115LL, v1);
    }
  }

  return result;
}

uint64_t _dispatch_wlh_get_workgroup(void *a1)
{
  uint64_t v2 = 0LL;
  if (a1 != (void *)-4LL && *(void *)(*a1 + 16LL) == 131090LL && a1[25]) {
    return *(void *)(a1[25] + 32LL);
  }
  return v2;
}

void _dispatch_root_queue_drain_deferred_item(uint64_t *a1)
{
  uint64_t v19 = a1;
  uint64_t v18 = 0LL;
  uint64_t v18 = *a1;
  uint64_t v17 = v18;
  uint64_t v33 = v18;
  _dispatch_thread_setspecific(20LL, v18);
  int v31 = 2;
  uint64_t v30 = 0LL;
  uint64_t v29 = 0LL;
  memset(v16, 0, sizeof(v16));
  _dispatch_last_resort_autorelease_pool_push((uint64_t)v16);
  unsigned int v51 = *(_DWORD *)(v18 + 84);
  BOOL v53 = _dispatch_thread_getspecific(0x19uLL) == 0;
  uint64_t v52 = 2319LL;
  if (!v53) {
    _dispatch_abort(v52, 0LL, v1, v2, v3, v4, v5, v6);
  }
  _dispatch_thread_setspecific(25LL, v51);
  _dispatch_continuation_pop_inline((void *)v19[1], (uint64_t)v16, 196608, v18);
  _dispatch_last_resort_autorelease_pool_pop((uint64_t)v16);
  _dispatch_thread_setspecific(25LL, 0LL);
  uint64_t v32 = 0LL;
  _dispatch_thread_setspecific(20LL, 0LL);
  _dispatch_thread_getspecific(0LL);
  _dispatch_log("%u\t%p\tvoucher[%p]: root queue clear", v7, v8, v9, v10, v11, v12, v13, 7301LL);
  uint64_t v21 = 0LL;
  uint64_t v20 = 14LL;
  uint64_t v25 = 0LL;
  uint64_t v24 = 0LL;
  uint64_t v23 = 14LL;
  uint64_t v37 = 0LL;
  uint64_t v50 = 1LL;
  uint64_t v49 = 2395LL;
  if ((_dispatch_set_qos_class_enabled & 1) != 0)
  {
    uint64_t v48 = v37;
    uint64_t v47 = 4261412863LL;
    uint64_t v46 = 0LL;
    v37 &= 0xFFFFFFFF02FFFFFFLL;
    unint64_t v36 = 0LL;
    uint64_t v39 = 0LL;
    uint64_t v39 = _dispatch_thread_getspecific(4uLL);
    unint64_t v36 = (unint64_t)v39;
    uint64_t v35 = 0x1000000LL;
    uint64_t v34 = 2281701376LL;
    if ((v39 & 0x1000000) != 0)
    {
      if (v37)
      {
        uint64_t v15 = v37;
      }

      else
      {
        unint64_t v45 = v36;
        uint64_t v44 = v35;
        uint64_t v43 = 0LL;
        uint64_t v15 = v36 & (~v35 | 0xFFFFFF);
      }

      uint64_t v38 = v15;
    }

    else
    {
      unint64_t v42 = v36;
      uint64_t v41 = v34;
      uint64_t v40 = 0LL;
      v36 &= ~v34 | 0xFFFFFF;
      if (v37 == v36) {
        uint64_t v38 = 0LL;
      }
      else {
        uint64_t v38 = v37;
      }
    }
  }

  else
  {
    uint64_t v38 = 0LL;
  }

  uint64_t v25 = v38;
  if (v38) {
    goto LABEL_26;
  }
  if (v24 == -1)
  {
    uint64_t v26 = -1LL;
    return;
  }

  uint64_t v14 = (void *)v24;
  if (v14 != _dispatch_thread_getspecific(0x1CuLL))
  {
LABEL_26:
    _dispatch_set_priority_and_voucher_slow(v25, (_DWORD *)v24, v23);
  }

  else
  {
    BOOL v22 = (v23 & 4) != 0;
    if ((v23 & 2) != 0)
    {
      if (v22)
      {
        if (v24)
        {
          object = (void *)v24;
          os_release((void *)v24);
        }
      }

      uint64_t v24 = -1LL;
    }

    else if (!v22 && v24)
    {
      uint64_t v28 = (void *)v24;
      os_retain((void *)v24);
    }

    uint64_t v26 = v24;
  }

void _dispatch_root_queue_drain_deferred_wlh(uint64_t *a1)
{
  uint64_t v44 = a1;
  uint64_t v43 = 0LL;
  uint64_t v43 = *a1;
  unint64_t v42 = 0LL;
  unint64_t v42 = (void *)a1[1];
  uint64_t v41 = v43;
  uint64_t v76 = v43;
  _dispatch_thread_setspecific(20LL, v43);
  memset(v40, 0, sizeof(v40));
  unsigned int v39 = 196610;
  unint64_t v38 = 0LL;
  unsigned int v100 = *(_DWORD *)(v43 + 84);
  BOOL v7 = _dispatch_thread_getspecific(0x19uLL) == 0;
  BOOL v102 = v7;
  uint64_t v101 = 2331LL;
  if (!v7) {
    _dispatch_abort(v101, v102, v1, v2, v3, v4, v5, v6);
  }
  v100 |= 0xF0000u;
  _dispatch_thread_setspecific(25LL, v100);
  *((_BYTE *)v44 + 45) |= 4u;
  while (2)
  {
    uint64_t v70 = *((_BYTE *)v44 + 45) & 1;
    uint64_t v69 = 7189LL;
    if (!v70) {
      _dispatch_abort(v69, 0LL, v8, v9, v10, v11, v12, v13);
    }
    uint64_t v74 = v43;
    uint64_t v73 = v42;
    int v72 = 0;
    int v71 = 0;
    uint64_t v99 = v43;
    uint64_t v98 = v42;
    __int128 v111 = v42;
    BOOL v110 = &v38;
    uint64_t v109 = 0LL;
    unint64_t v108 = 0LL;
    uint64_t v107 = 0LL;
    unsigned int v118 = _dispatch_thread_getspecific(3uLL);
    uint64_t v107 = v118 & 0xFFFFFFFC | 0x60000000000000LL;
    BOOL v106 = 0;
    unsigned int v105 = v111 + 7;
    while (1)
    {
      unint64_t v20 = _os_atomic_mo_has_acquire(2) ? __ldaxr(v105) : __ldxr(v105);
      uint64_t v109 = v20;
      unint64_t v108 = v20;
      unint64_t v114 = v20;
      if ((v20 & 0xFF80000000000000LL) == 0) {
        break;
      }
      v108 &= ~1uLL;
LABEL_17:
      if (_os_atomic_mo_has_release(2)) {
        BOOL v106 = __stlxr(v108, v105) == 0;
      }
      else {
        BOOL v106 = __stxr(v108, v105) == 0;
      }
      if (v106) {
        goto LABEL_21;
      }
    }

    uint64_t v116 = v109;
    int v120 = v109;
    if ((v109 & 0xFFFFFFFC) == 0)
    {
      v108 &= 0x7700000001uLL;
      v108 |= v107;
      goto LABEL_17;
    }

    uint64_t v119 = v109;
    if ((v109 & 2) != 0)
    {
      v108 |= 0x800000000uLL;
      goto LABEL_17;
    }

    __clrex();
LABEL_21:
    BOOL v104 = v106;
    uint64_t v112 = v109;
    LOBYTE(v37) = 1;
    if ((v109 & 0x2000000000LL) != 0)
    {
      uint64_t v122 = v109;
      LOBYTE(v37) = 1;
      if ((v109 & 1) != 0)
      {
        uint64_t v117 = v109;
        int v37 = (BYTE4(v109) >> 6) & 1;
      }
    }

    if ((v37 & 1) != 0)
    {
      uint64_t v103 = v109;
      qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: Invalid wlh state";
      qword_E4DA8 = v109;
      __break(1u);
      JUMPOUT(0x54940LL);
    }

    if (v110) {
      *BOOL v110 = v108;
    }
    uint64_t v113 = v109;
    BOOL v36 = 0;
    if ((v109 & 0xFF80000000000000LL) == 0)
    {
      uint64_t v115 = v109;
      int v121 = v109;
      BOOL v36 = (v109 & 0xFFFFFFFC) == 0;
    }

    if (!v36)
    {
      unint64_t v59 = v38;
      if ((v38 & 0xFF80000000000000LL) != 0)
      {
        unint64_t v62 = v38;
        BOOL v68 = (v38 & 0x4000000001LL) == 0;
        uint64_t v67 = 7253LL;
        if ((v38 & 0x4000000001LL) != 0) {
          _dispatch_abort(v67, v68, v14, v15, v16, v17, v18, v19);
        }
        _dispatch_release_2_no_dispose((uint64_t)v42);
      }

      else
      {
        unint64_t v61 = v38;
        BOOL v66 = (v38 & 0x4000000001LL) != 0;
        uint64_t v65 = 7256LL;
        if ((v38 & 0x4000000001LL) == 0) {
          _dispatch_abort(v65, v66, v14, v15, v16, v17, v18, v19);
        }
        unint64_t v60 = v38;
        int v96 = v38;
        BOOL v64 = (v38 & 0xFFFFFFFC) != 0;
        uint64_t v63 = 7257LL;
        if ((v38 & 0xFFFFFFFC) == 0) {
          _dispatch_abort(v63, v64, v14, v15, v16, v17, v18, v19);
        }
        _dispatch_release_no_dispose((uint64_t)v42);
      }

      goto LABEL_45;
    }

    (*(void (**)(void *, _OWORD *, void))(*v42 + 48LL))(v42, v40, v39);
    if ((*((_BYTE *)v44 + 45) & 1) != 0)
    {
      unint64_t v38 = v42[7];
      unint64_t v58 = v38;
      if (((BYTE4(v38) >> 5) & 1) != 0)
      {
        unint64_t v97 = v38;
        if ((v38 & 1) != 0)
        {
          _dispatch_retain((uint64_t)v42);
          uint64_t v57 = v42[3];
          uint64_t v56 = v42;
          int v55 = 0;
          int v54 = 0;
          uint64_t v95 = v57;
          uint64_t v94 = v42;
          continue;
        }

void _dispatch_queue_cleanup2()
{
  uint64_t v17 = &_dispatch_main_q;
  unint64_t v16 = 0LL;
  unint64_t v15 = 0LL;
  BOOL v14 = 0;
  uint64_t v13 = (unint64_t *)&dword_E4078;
  do
  {
    if (_os_atomic_mo_has_acquire(2)) {
      unint64_t v0 = __ldaxr(v13);
    }
    else {
      unint64_t v0 = __ldxr(v13);
    }
    unint64_t v16 = v0;
    unint64_t v15 = (v0 & 0xFFFFFF7FFFFFFFFFLL) + 0x40020000000000LL;
    if (_os_atomic_mo_has_release(2)) {
      BOOL v14 = __stlxr(v15, v13) == 0;
    }
    else {
      BOOL v14 = __stxr(v15, v13) == 0;
    }
  }

  while (!v14);
  BOOL v12 = v14;
  v11[2] = (pthread_t)v17;
  uint64_t v29 = v17;
  int v28 = 0x40000;
  int v26 = -262145;
  int v25 = -262145;
  int v27 = -262145;
  unsigned int v23 = 0;
  int v21 = -262145;
  int v20 = -262145;
  int v22 = -262145;
  uint64_t v8 = (unsigned int *)((char *)v17 + 80);
  unsigned int v9 = *((_DWORD *)v17 + 20);
  do
  {
    unsigned int v6 = v9;
    do
      unsigned int v7 = __ldaxr(v8);
    while (v7 == v9 && __stlxr(v9 & 0xFFFBFFFF, v8));
    unsigned int v9 = v7;
  }

  while (v7 != v6);
  unsigned int v19 = v7;
  unsigned int v23 = v7;
  unsigned int v18 = v7;
  int v24 = v7 & v27;
  v11[1] = (pthread_t)v17;
  _dispatch_lane_barrier_complete((uint64_t)v17, 0, 0, v1, v2, v3, v4, v5);
  if ((_dispatch_program_is_probably_callback_driven & 1) != 0)
  {
    memset(&v33, 0, sizeof(v33));
    pthread_attr_init(&v33);
    pthread_attr_setdetachstate(&v33, 2);
    v11[0] = 0LL;
    int v10 = pthread_create(v11, &v33, (void *(__cdecl *)(void *))_dispatch_sig_thread, 0LL);
    if (v10)
    {
      qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Unable to create signal thread";
      qword_E4DA8 = v10;
      __break(1u);
      JUMPOUT(0x55458LL);
    }

    pthread_attr_destroy(&v33);
    sleep_NOCANCEL(1LL);
  }

  uint64_t v32 = &_dispatch_main_q_handle_pred;
  uint64_t v31 = v17;
  dispatch_function_t v30 = (dispatch_function_t)_dispatch_runloop_queue_handle_init;
  if (_dispatch_main_q_handle_pred != -1) {
    dispatch_once_f(v32, v31, v30);
  }
  _dispatch_runloop_queue_handle_dispose((mach_port_context_t)v17);
}

void _dispatch_sig_thread(uint64_t a1)
{
  uint64_t v3 = a1;
  stackaddr_np = 0LL;
  uint64_t v1 = pthread_self();
  stackaddr_np = pthread_get_stackaddr_np(v1);
  __memset_chk(&v3, 0LL, stackaddr_np - (_BYTE *)&v3, -1LL);
  _dispatch_sigsuspend();
}

void _dispatch_sigsuspend()
{
  while (1)
    sigsuspend_NOCANCEL(_dispatch_sigsuspend_mask);
}

void _dispatch_apply_invoke( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v27 = a1;
  uint64_t v26 = 0LL;
  int i = 0;
  unsigned int v24 = 0;
  unsigned int v23 = 0;
  int v21 = 1;
  int v20 = 1;
  int v22 = 1;
  unsigned int v16 = *(_DWORD *)(a1 + 52);
  do
  {
    unsigned int v8 = v16;
    unsigned int v9 = (unsigned int *)(a1 + 52);
    do
      unsigned int v10 = __ldaxr(v9);
    while (v10 == v16 && __stlxr(v16 + 1, v9));
    unsigned int v16 = v10;
  }

  while (v10 != v8);
  unsigned int v19 = v10;
  unsigned int v23 = v10;
  unsigned int v18 = v10;
  unsigned int v24 = v10;
  BOOL v29 = v10 < *(_DWORD *)(v27 + 48);
  uint64_t v28 = 210LL;
  if (!v29) {
    _dispatch_abort(v28, 0LL, a3, a4, a5, a6, a7, a8);
  }
  v17[0] = v27;
  v17[1] = v26;
  v17[2] = v24;
  _dispatch_apply_set_attr_behavior(*(int **)(v27 + 56), v24);
  uint64_t v35 = (dispatch_once_t *)(*(void *)(v27 + 32) + 8LL * v24);
  uint64_t v34 = v17;
  dispatch_function_t v33 = (dispatch_function_t)_dispatch_apply_invoke3;
  if (*v35 != -1) {
    dispatch_once_f(v35, v34, v33);
  }
  _dispatch_apply_clear_attr_behavior(*(void *)(v27 + 56), v24);
  if ((v26 & 2) != 0)
  {
    for (int i = 0; i < *(_DWORD *)(v27 + 48); ++i)
    {
      if (i != v24)
      {
        uint64_t v32 = (dispatch_once_t *)(*(void *)(v27 + 32) + 8LL * i);
        uint64_t v31 = 0LL;
        dispatch_function_t v30 = _dispatch_no_op;
        if (*v32 != -1) {
          dispatch_once_f(v32, v31, (dispatch_function_t)v30);
        }
      }
    }
  }

  BOOL v14 = (unsigned int *)(v27 + 44);
  unsigned int v15 = *(_DWORD *)(v27 + 44);
  do
  {
    unsigned int v11 = v15;
    do
      unsigned int v12 = __ldaxr(v14);
    while (v12 == v15 && __stlxr(v15 - 1, v14));
    unsigned int v15 = v12;
  }

  while (v12 != v11);
  if (v12 == 1)
  {
    uint64_t v36 = v27;
    if (*(void *)(v27 + 32)) {
      free(*(void **)(v36 + 32));
    }
    if (*(void *)(v36 + 56))
    {
      dispatch_apply_attr_destroy(*(void *)(v36 + 56));
      free(*(void **)(v36 + 56));
    }

    uint64_t v37 = v36;
    unint64_t v38 = (void *)v36;
    uint64_t v41 = v36;
    uint64_t v40 = 0LL;
    uint64_t v40 = _dispatch_thread_getspecific(0x16uLL);
    int v39 = 0;
    if (v40) {
      int v13 = v40[2] + 1;
    }
    else {
      int v13 = 1;
    }
    int v39 = v13;
    if (v13 <= _dispatch_continuation_cache_limit)
    {
      *(void *)(v41 + 16) = v40;
      *(_DWORD *)(v41 + 8) = v39;
      _dispatch_thread_setspecific(22LL, v41);
      unint64_t v42 = 0LL;
    }

    else
    {
      unint64_t v42 = (void *)v41;
    }

    unint64_t v38 = v42;
    if (v42) {
      _dispatch_continuation_free_to_cache_limit(v38);
    }
  }

void _dispatch_apply_redirect_invoke( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v27 = a1;
  uint64_t v26 = 1LL;
  int i = 0;
  unsigned int v24 = 0;
  unsigned int v23 = 0;
  int v21 = 1;
  int v20 = 1;
  int v22 = 1;
  unsigned int v16 = *(_DWORD *)(a1 + 52);
  do
  {
    unsigned int v8 = v16;
    unsigned int v9 = (unsigned int *)(a1 + 52);
    do
      unsigned int v10 = __ldaxr(v9);
    while (v10 == v16 && __stlxr(v16 + 1, v9));
    unsigned int v16 = v10;
  }

  while (v10 != v8);
  unsigned int v19 = v10;
  unsigned int v23 = v10;
  unsigned int v18 = v10;
  unsigned int v24 = v10;
  BOOL v29 = v10 < *(_DWORD *)(v27 + 48);
  uint64_t v28 = 210LL;
  if (!v29) {
    _dispatch_abort(v28, 0LL, a3, a4, a5, a6, a7, a8);
  }
  v17[0] = v27;
  v17[1] = v26;
  v17[2] = v24;
  _dispatch_apply_set_attr_behavior(*(int **)(v27 + 56), v24);
  uint64_t v35 = (dispatch_once_t *)(*(void *)(v27 + 32) + 8LL * v24);
  uint64_t v34 = v17;
  dispatch_function_t v33 = (dispatch_function_t)_dispatch_apply_invoke3;
  if (*v35 != -1) {
    dispatch_once_f(v35, v34, v33);
  }
  _dispatch_apply_clear_attr_behavior(*(void *)(v27 + 56), v24);
  if ((v26 & 2) != 0)
  {
    for (int i = 0; i < *(_DWORD *)(v27 + 48); ++i)
    {
      if (i != v24)
      {
        uint64_t v32 = (dispatch_once_t *)(*(void *)(v27 + 32) + 8LL * i);
        uint64_t v31 = 0LL;
        dispatch_function_t v30 = _dispatch_no_op;
        if (*v32 != -1) {
          dispatch_once_f(v32, v31, (dispatch_function_t)v30);
        }
      }
    }
  }

  BOOL v14 = (unsigned int *)(v27 + 44);
  unsigned int v15 = *(_DWORD *)(v27 + 44);
  do
  {
    unsigned int v11 = v15;
    do
      unsigned int v12 = __ldaxr(v14);
    while (v12 == v15 && __stlxr(v15 - 1, v14));
    unsigned int v15 = v12;
  }

  while (v12 != v11);
  if (v12 == 1)
  {
    uint64_t v36 = v27;
    if (*(void *)(v27 + 32)) {
      free(*(void **)(v36 + 32));
    }
    if (*(void *)(v36 + 56))
    {
      dispatch_apply_attr_destroy(*(void *)(v36 + 56));
      free(*(void **)(v36 + 56));
    }

    uint64_t v37 = v36;
    unint64_t v38 = (void *)v36;
    uint64_t v41 = v36;
    uint64_t v40 = 0LL;
    uint64_t v40 = _dispatch_thread_getspecific(0x16uLL);
    int v39 = 0;
    if (v40) {
      int v13 = v40[2] + 1;
    }
    else {
      int v13 = 1;
    }
    int v39 = v13;
    if (v13 <= _dispatch_continuation_cache_limit)
    {
      *(void *)(v41 + 16) = v40;
      *(_DWORD *)(v41 + 8) = v39;
      _dispatch_thread_setspecific(22LL, v41);
      unint64_t v42 = 0LL;
    }

    else
    {
      unint64_t v42 = (void *)v41;
    }

    unint64_t v38 = v42;
    if (v42) {
      _dispatch_continuation_free_to_cache_limit(v38);
    }
  }

void dispatch_apply_f( size_t iterations, dispatch_queue_t queue, void *context, void (__cdecl *work)(void *, size_t))
{
}

void _dispatch_apply_with_attr_f( unint64_t a1, uint64_t a2, dispatch_queue_s *a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  unint64_t v98 = a1;
  uint64_t v97 = a2;
  int v96 = a3;
  *((void *)&v95 + 1) = a4;
  *(void *)&__int128 v95 = a5;
  uint64_t v94 = a6;
  if (a1)
  {
    if (v97 && !_dispatch_attr_is_initialized(v97))
    {
      uint64_t v93 = v97;
      qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: dispatch_apply_attr not initialized using dispatch_apply_attr_init";
      qword_E4DA8 = v97;
      __break(1u);
      JUMPOUT(0x55FD0LL);
    }

    uint64_t v92 = 0LL;
    unsigned int v100 = "apply";
    for (int i = _dispatch_thread_getspecific(0x17uLL); i; int i = (void *)*i)
    {
      if (i[1] == (void)v100)
      {
        uint64_t v101 = i;
        goto LABEL_11;
      }
    }

    uint64_t v101 = 0LL;
LABEL_11:
    uint64_t v92 = v101;
    unint64_t v91 = 0LL;
    if (v101) {
      unint64_t v77 = v92[2];
    }
    else {
      unint64_t v77 = 0LL;
    }
    unint64_t v91 = v77;
    uint64_t v90 = (dispatch_queue_s *)_dispatch_thread_getspecific(0x14uLL);
    dispatch_queue_t queue = 0LL;
    if (v96)
    {
      dispatch_queue_t queue = v96;
    }

    else
    {
      unint64_t v110 = (unint64_t)v90;
      unint64_t v109 = 0LL;
      if (v90)
      {
        while (*(void *)(v110 + 24))
        {
          unint64_t v109 = *(void *)(v110 + 24);
          unint64_t v133 = v110;
          BOOL v76 = 1;
          if (*(void *)(v110 + 24) != (void)&_dispatch_custom_workloop_root_queue) {
            BOOL v76 = *(void *)(v133 + 24) == (void)&_dispatch_custom_workloop_overcommit_root_queue;
          }
          if (v76)
          {
            unint64_t v108 = v110;
            unint64_t v154 = v110;
            unint64_t v155 = v110;
            unint64_t v107 = v110;
            __int128 v111 = (dispatch_queue_s *)v110;
            goto LABEL_38;
          }

          unint64_t v110 = v109;
        }
      }

      if (!v110) {
        goto LABEL_27;
      }
      unint64_t v106 = v110;
      unint64_t v248 = v110;
      BOOL v75 = 0;
      if (v75)
      {
LABEL_27:
        uint64_t v130 = _dispatch_thread_getspecific(4uLL);
        uint64_t v103 = v130;
        int v102 = 0;
        unint64_t v128 = (unint64_t)(v130 & 0x3FFF00) >> 8;
        unsigned int v6 = (v130 & 0x3FFF00) >> 8;
        unsigned int v7 = __clz(__rbit32(v6));
        if (v6) {
          unsigned int v8 = v7 + 1;
        }
        else {
          unsigned int v8 = 0;
        }
        int v102 = v8;
        if (v8) {
          int v74 = v102;
        }
        else {
          int v74 = 4;
        }
        unsigned int v252 = v74;
        uint64_t v251 = 0LL;
        BOOL v73 = 1;
        if (v74) {
          BOOL v73 = v252 > 6;
        }
        if (v73)
        {
          uint64_t v250 = v252;
          qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Corrupted priority";
          qword_E4DA8 = v252;
          __break(1u);
          JUMPOUT(0x5632CLL);
        }

        int v249 = 0;
        __int128 v111 = (dispatch_queue_s *)&(&_dispatch_root_queues)[16 * (unint64_t)(3 * v252 - 3)];
      }

      else
      {
        unint64_t v105 = v110;
        unint64_t v156 = v110;
        unint64_t v157 = v110;
        unint64_t v104 = v110;
        __int128 v111 = (dispatch_queue_s *)v110;
      }

void dispatch_apply_with_attr_f(unint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
}

void dispatch_apply(size_t iterations, dispatch_queue_t queue, void *block)
{
  context = _dispatch_Block_copy(block);
  uint64_t v3 = (void (__cdecl *)(void *, size_t))_Block_get_invoke_fn((uint64_t)context);
  dispatch_apply_f(iterations, queue, context, v3);
  _Block_release(context);
}

void dispatch_apply_with_attr(unint64_t a1, uint64_t a2, const void *a3)
{
  uint64_t v4 = _dispatch_Block_copy(a3);
  uint64_t v3 = _Block_get_invoke_fn((uint64_t)v4);
  dispatch_apply_with_attr_f(a1, a2, (uint64_t)v4, v3);
  _Block_release(v4);
}

uint64_t dispatch_apply_attr_init(uint64_t a1)
{
  uint64_t result = __memset_chk(a1, 0LL, 64LL, -1LL);
  *(_DWORD *)a1 = -1592086528;
  *(void *)(a1 + 16) = ~a1;
  return result;
}

uint64_t dispatch_apply_attr_destroy(uint64_t a1)
{
  return __memset_chk(a1, 0LL, 64LL, -1LL);
}

BOOL dispatch_apply_attr_set_parallelism(BOOL result, uint64_t a2, unint64_t a3)
{
  if (a2 == -1) {
    return dispatch_apply_attr_set_per_cluster_parallelism(result, a3);
  }
  if (a2 != 1)
  {
    if (a2 != 2)
    {
      qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Unknown entity";
      qword_E4DA8 = a2;
      __break(1u);
      JUMPOUT(0x583B4LL);
    }

    return dispatch_apply_attr_set_per_cluster_parallelism(result, a3);
  }

  if (a3 != 1)
  {
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Invalid threads_per_entity value for CPU entity";
    qword_E4DA8 = a3;
    __break(1u);
    JUMPOUT(0x5835CLL);
  }

  return result;
}

BOOL dispatch_apply_attr_set_per_cluster_parallelism(BOOL result, unint64_t a2)
{
  uint64_t v3 = result;
  if (!a2)
  {
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: 0 is an invalid threads_per_cluster value";
    qword_E4DA8 = 0LL;
    __break(1u);
    JUMPOUT(0x58424LL);
  }

  if (a2 >= 2)
  {
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Invalid threads_per_cluster value, only acceptable value is 1";
    qword_E4DA8 = a2;
    __break(1u);
    JUMPOUT(0x58478LL);
  }

  if (result)
  {
    uint64_t result = _dispatch_attr_is_initialized(result);
    if (!result)
    {
      qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: dispatch_apply_attr not initialized using dispatch_apply_attr_init";
      qword_E4DA8 = v3;
      __break(1u);
      JUMPOUT(0x584D8LL);
    }
  }

  *(void *)(v3 + 8) = a2;
  return result;
}

unint64_t dispatch_apply_attr_query(uint64_t a1, uint64_t a2, uint64_t a3)
{
  for (int i = _dispatch_thread_getspecific(0x17uLL); i; int i = (void *)*i)
  {
    if (i[1] == (void)"apply")
    {
      uint64_t v21 = i;
      goto LABEL_7;
    }
  }

  uint64_t v21 = 0LL;
LABEL_7:
  if (v21) {
    unint64_t v15 = v21[2];
  }
  else {
    unint64_t v15 = 0LL;
  }
  uint64_t v22 = (uint64_t *)_dispatch_thread_getspecific(0x14uLL);
  if (v22)
  {
    while (v22[3])
    {
      BOOL v14 = 1;
      if (v22[3] != (void)&_dispatch_custom_workloop_root_queue) {
        BOOL v14 = v22[3] == (void)&_dispatch_custom_workloop_overcommit_root_queue;
      }
      if (v14)
      {
        uint64_t v23 = (uint64_t (***)())v22;
        goto LABEL_31;
      }

      uint64_t v22 = (uint64_t *)v22[3];
    }
  }

  if (!v22) {
    goto LABEL_22;
  }
  BOOL v13 = 0;
  if (v13)
  {
LABEL_22:
    unint64_t v28 = ((unint64_t)_dispatch_thread_getspecific(4uLL) & 0x3FFF00) >> 8;
    unsigned int v3 = __clz(__rbit32(v28));
    if ((_DWORD)v28) {
      unsigned int v4 = v3 + 1;
    }
    else {
      unsigned int v4 = 0;
    }
    if (v4) {
      unsigned int v12 = v4;
    }
    else {
      unsigned int v12 = 4;
    }
    if (v12 > 6)
    {
      qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Corrupted priority";
      qword_E4DA8 = v12;
      __break(1u);
      JUMPOUT(0x58898LL);
    }

    uint64_t v23 = &(&_dispatch_root_queues)[16 * (unint64_t)(3 * v12 - 3)];
  }

  else
  {
    uint64_t v23 = (uint64_t (***)())v22;
  }

int *_dispatch_apply_set_attr_behavior(int *result, uint64_t a2)
{
  if (result)
  {
    if (*((void *)result + 1))
    {
      uint64_t result = (int *)__bsdthread_ctl(0x2000LL, 1LL, a2, *((void *)result + 1));
      if ((_DWORD)result)
      {
        uint64_t result = __error();
        if (*result != 45)
        {
          __break(1u);
          JUMPOUT(0x5B310LL);
        }
      }
    }
  }

  return result;
}

void *_dispatch_apply_invoke3(void *result)
{
  int v53 = result;
  unsigned int v52 = result;
  uint64_t v51 = 0LL;
  uint64_t v51 = *result;
  unint64_t v50 = 0LL;
  unint64_t v50 = *(void *)(v51 + 16);
  unint64_t v49 = 0LL;
  uint64_t v48 = 0LL;
  unint64_t v47 = 0LL;
  uint64_t v45 = 1LL;
  uint64_t v44 = 1LL;
  uint64_t v46 = 1LL;
  unsigned int v30 = (unint64_t *)(v51 + 8);
  unint64_t v31 = *(void *)(v51 + 8);
  do
  {
    unint64_t v1 = v31;
    do
      unint64_t v2 = __ldaxr(v30);
    while (v2 == v31 && __stlxr(v31 + 1, v30));
    unint64_t v31 = v2;
  }

  while (v2 != v1);
  unint64_t v43 = v2;
  unint64_t v47 = v2;
  unint64_t v42 = v2;
  unint64_t v49 = v2;
  if (v2 < v50)
  {
    unint64_t v41 = 0LL;
    unint64_t v41 = *(uint64_t (**)(uint64_t, uint64_t))(*(void *)v51 + 32LL);
    uint64_t v40 = 0LL;
    uint64_t v40 = *(void *)(*(void *)v51 + 40LL);
    uint64_t v39 = 0LL;
    uint64_t v39 = *(void *)(*(void *)v51 + 48LL);
    uint64_t v38 = 0LL;
    v37[0] = 0LL;
    v37[1] = "apply";
    uint64_t v38 = *(void *)(v51 + 24);
    int v54 = v37;
    v37[0] = _dispatch_thread_getspecific(0x17uLL);
    _dispatch_thread_setspecific(23LL, (uint64_t)v54);
    __int128 v36 = 0uLL;
    unsigned int v35 = 0;
    if ((v52[1] & 1) != 0)
    {
      uint64_t v56 = *(void *)(*(void *)v51 + 56LL);
      uint64_t v34 = v56;
      unsigned int v55 = &v36;
      unint64_t v87 = &v36;
      _dispatch_thread_getspecific_packed_pair(20LL, 21LL, &v36, v3, v4, v5, v6, v7);
      _dispatch_thread_setspecific_pair(20LL, v56, 21LL, (uint64_t)v55, v8, v9, v10, v11);
      int v59 = *(_DWORD *)(v34 + 84);
      unsigned int v58 = 0;
      unsigned int v58 = _dispatch_thread_getspecific(0x19uLL);
      unsigned int v57 = v58;
      if (v58)
      {
        if ((v59 & 0xFFF) != 0)
        {
          v57 &= 0x880F0000;
          if ((v58 & 0xFFF) > (v59 & 0xFFFu)) {
            int v29 = v58 & 0xFFF;
          }
          else {
            int v29 = v59 & 0xFFF;
          }
          v57 |= v29;
          unsigned int v63 = v59 & 0xF000;
          unsigned int v61 = v57 & 0xF00;
          if (v63 >> 12 > v61 >> 8) {
            v59 &= 0x4400F000u;
          }
          else {
            v59 &= 0x40000000u;
          }
          v57 |= v59;
        }

        else
        {
          if ((v57 & 0xFFF) != 0) {
            v57 |= 0x40000000u;
          }
          unsigned int v62 = v59 & 0xF000;
          unsigned int v60 = v57 & 0xF00;
          if (v62 >> 12 > v60 >> 8)
          {
            v57 &= 0xFFFF0FFF;
            v57 |= v59 & 0x400F000;
          }
        }
      }

      else
      {
        unsigned int v57 = v59 & 0xFFF0FFFF;
      }

      _dispatch_thread_setspecific(25LL, v57);
      unsigned int v35 = v58;
    }

    int v33 = *(_DWORD *)(v51 + 40);
    do
    {
      uint64_t v32 = 0LL;
      if ((v33 & 0x1000000) != 0) {
        uint64_t v32 = _dispatch_autorelease_pool_push();
      }
      if ((v39 & 1) != 0)
      {
        uint64_t v71 = v40;
        unint64_t v70 = v49;
        uint64_t v69 = v41;
        BOOL v68 = v41;
        uint64_t v91 = v40;
        uint64_t v90 = v41;
        int v67 = 0;
        int v66 = 0;
        int v65 = 0;
        int v64 = 0;
        _dispatch_client_callout2(v40, v49, v41);
        uint64_t v95 = v71;
        uint64_t v94 = v68;
      }

      else
      {
        if ((v39 & 2) == 0)
        {
          qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: apply continuation has invalid flags";
          qword_E4DA8 = v39;
          __break(1u);
          JUMPOUT(0x5BB04LL);
        }

        uint64_t v12 = *((unsigned int *)v52 + 4);
        uint64_t v80 = v40;
        unint64_t v79 = v49;
        uint64_t v78 = v12;
        unint64_t v77 = v41;
        BOOL v76 = v41;
        uint64_t v89 = v40;
        unsigned int v88 = v41;
        int v75 = 0;
        int v74 = 0;
        int v73 = 0;
        int v72 = 0;
        _dispatch_client_callout3(v40, v49, v12, (uint64_t (*)(uint64_t, uint64_t, uint64_t))v41);
        uint64_t v93 = v80;
        uint64_t v92 = v76;
      }

      ++v48;
      uint64_t v27 = (unint64_t *)(v51 + 8);
      unint64_t v28 = *(void *)(v51 + 8);
      do
      {
        unint64_t v13 = v28;
        do
          unint64_t v14 = __ldaxr(v27);
        while (v14 == v28 && __stlxr(v28 + 1, v27));
        unint64_t v28 = v14;
      }

      while (v14 != v13);
      unint64_t v49 = v14;
      if (v32) {
        _dispatch_autorelease_pool_pop(v32);
      }
    }

    while (v49 < v50);
    if ((v52[1] & 1) != 0)
    {
      unsigned int v82 = v35;
      unsigned int v81 = 0;
      unsigned int v81 = _dispatch_thread_getspecific(0x19uLL);
      v82 &= 0xFFF0FFFF;
      v82 |= v81 & 0xF0000;
      _dispatch_thread_setspecific(25LL, v82);
      uint64_t v83 = &v36;
      _dispatch_thread_setspecific_packed_pair(20LL, 21LL, &v36, v15, v16, v17, v18, v19);
    }

    dispatch_queue_t v84 = v37;
    BOOL v26 = _dispatch_thread_getspecific(0x17uLL) == v37;
    BOOL v86 = v26;
    uint64_t v85 = 449LL;
    if (!v26) {
      _dispatch_abort(v85, v86, v20, v21, v22, v23, v24, v25);
    }
    return (void *)_dispatch_thread_setspecific(23LL, *v84);
  }

  return result;
}

uint64_t _dispatch_apply_clear_attr_behavior(uint64_t result, uint64_t a2)
{
  if (result)
  {
    if (*(void *)(result + 8))
    {
      uint64_t result = __bsdthread_ctl(0x2000LL, 2LL, a2, *(void *)(result + 8));
      if ((_DWORD)result)
      {
        __break(1u);
        JUMPOUT(0x5BD7CLL);
      }
    }
  }

  return result;
}

  ;
}

BOOL _dispatch_attr_is_initialized(uint64_t a1)
{
  BOOL v2 = 0;
  if (*(_DWORD *)a1 == -1592086528) {
    return ~*(void *)(a1 + 16) == a1;
  }
  return v2;
}

uint64_t _dispatch_apply_da_copy_attr(uint64_t result, uint64_t a2)
{
  uint64_t v4 = result;
  if (a2)
  {
    uint64_t v2 = _dispatch_calloc(1LL, 64LL);
    uint64_t result = dispatch_apply_attr_init(v2);
    *(void *)(v2 + 8) = *(void *)(a2 + 8);
    *(_DWORD *)(v2 + 4) = *(_DWORD *)(a2 + 4);
    *(void *)(v4 + 56) = v2;
  }

  else
  {
    *(void *)(result + 56) = 0LL;
  }

  return result;
}

void *_dispatch_apply_serial(uint64_t a1)
{
  uint64_t v8 = *(void *)a1;
  unint64_t v7 = *(void *)(a1 + 16);
  unint64_t v6 = 0LL;
  uint64_t v12 = *(void *)(*(void *)a1 + 56LL);
  int v11 = 0;
  while (1)
  {
    BOOL v4 = 0;
    if (v12) {
      BOOL v4 = v11 == 0;
    }
    if (!v4) {
      break;
    }
    int v11 = (*(_DWORD *)(v12 + 80) & 0x30000) << 8;
    uint64_t v12 = *(void *)(v12 + 24);
  }

  do
  {
    uint64_t v5 = 0LL;
    if ((v11 & 0x1000000) != 0) {
      uint64_t v5 = _dispatch_autorelease_pool_push();
    }
    if ((*(_BYTE *)(v8 + 48) & 1) != 0)
    {
      _dispatch_client_callout2(*(void *)(v8 + 40), v6, *(uint64_t (**)(uint64_t, uint64_t))(v8 + 32));
    }

    else
    {
      if ((*(_BYTE *)(v8 + 48) & 2) == 0)
      {
        uint64_t v1 = *(void *)(v8 + 48);
        qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: apply continuation has invalid flags";
        qword_E4DA8 = v1;
        __break(1u);
        JUMPOUT(0x5C380LL);
      }

      _dispatch_client_callout3( *(void *)(v8 + 40),  v6,  0LL,  *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v8 + 32));
    }

    if (v5) {
      _dispatch_autorelease_pool_pop(v5);
    }
    ++v6;
  }

  while (v6 < v7);
  if (*(void *)(a1 + 32)) {
    free(*(void **)(a1 + 32));
  }
  if (*(void *)(a1 + 56))
  {
    dispatch_apply_attr_destroy(*(void *)(a1 + 56));
    free(*(void **)(a1 + 56));
  }

  uint64_t result = _dispatch_thread_getspecific(0x16uLL);
  if (result) {
    int v3 = *((_DWORD *)result + 2) + 1;
  }
  else {
    int v3 = 1;
  }
  if (v3 <= _dispatch_continuation_cache_limit)
  {
    *(void *)(a1 + 16) = result;
    *(_DWORD *)(a1 + 8) = v3;
    uint64_t result = (void *)_dispatch_thread_setspecific(22LL, a1);
    uint64_t v10 = 0LL;
  }

  else
  {
    uint64_t v10 = (void *)a1;
  }

  if (v10) {
    return _dispatch_continuation_free_to_cache_limit(v10);
  }
  return result;
}

void _dispatch_apply_redirect(uint64_t a1)
{
  int v39 = *(_DWORD *)(a1 + 44) - 1;
  uint64_t v38 = *(void *)(*(void *)a1 + 56LL);
  uint64_t v37 = v38;
  do
  {
    if (*(_WORD *)(v37 + 80) == 1)
    {
      int v52 = 0;
    }

    else
    {
      uint64_t v48 = (unint64_t *)(v37 + 56);
      do
      {
        if (_os_atomic_mo_has_acquire(0)) {
          unint64_t v1 = __ldaxr(v48);
        }
        else {
          unint64_t v1 = __ldxr(v48);
        }
        if ((v1 & 0x20000000000000LL) != 0) {
          int v55 = 0;
        }
        else {
          int v55 = 4096 - ((v1 & 0x3FFE0000000000LL) >> 41);
        }
        int v50 = v55;
        if (!v55)
        {
          __clrex();
          int v52 = 0;
          goto LABEL_20;
        }

        if (v55 > v39) {
          int v50 = v39;
        }
        unint64_t v51 = v1 + ((uint64_t)v50 << 41);
        if (_os_atomic_mo_has_release(0)) {
          BOOL v49 = __stlxr(v51, v48) == 0;
        }
        else {
          BOOL v49 = __stxr(v51, v48) == 0;
        }
      }

      while (!v49);
      int v52 = v50;
    }

LABEL_20:
    if (v39 > v52)
    {
      int v36 = v39 - v52;
      for (uint64_t i = v38; i != v37; uint64_t i = *(void *)(i + 24))
      {
        uint64_t v34 = (unint64_t *)(i + 56);
        unint64_t v35 = *(void *)(i + 56);
        do
        {
          unint64_t v2 = v35;
          do
            unint64_t v3 = __ldaxr(v34);
          while (v3 == v35 && __stlxr(v35 - ((uint64_t)(v39 - v52) << 41), v34));
          unint64_t v35 = v3;
        }

        while (v3 != v2);
      }

      int v39 = v52;
      if (!v52)
      {
        _dispatch_apply_serial(a1);
        return;
      }

      *(_DWORD *)(a1 + 44) -= v36;
    }

    if (!*(_DWORD *)(a1 + 40)) {
      *(_DWORD *)(a1 + 40) = (*(_DWORD *)(v37 + 80) & 0x30000) << 8;
    }
    uint64_t v37 = *(void *)(v37 + 24);
  }

  while (*(void *)(v37 + 24));
  uint64_t v44 = 0LL;
  unint64_t v43 = 0LL;
  unint64_t v42 = (unint64_t)_dispatch_thread_getspecific(4uLL);
  signed int v41 = *(_DWORD *)(a1 + 44) - 1;
  if (*(_DWORD *)(a1 + 44) == 1) {
    _dispatch_abort(336LL, v41, v4, v5, v6, v7, v8, v9);
  }
  for (signed int j = 0; j < v41; ++j)
  {
    unint64_t v47 = _dispatch_thread_getspecific(0x16uLL);
    if (v47)
    {
      _dispatch_thread_setspecific(22LL, v47[2]);
      uint64_t v46 = v47;
    }

    else
    {
      uint64_t v46 = (void *)_dispatch_continuation_alloc_from_heap();
    }

    *uint64_t v46 = 260LL;
    v46[4] = _dispatch_apply_redirect_invoke;
    v46[5] = a1;
    unsigned int v58 = _dispatch_thread_getspecific(0x1CuLL);
    if (v58) {
      os_retain(v58);
    }
    v46[3] = v58;
    _dispatch_thread_getspecific(0LL);
    _dispatch_log("%u\t%p\tvoucher[%p]: continuation[%p] set", v10, v11, v12, v13, v14, v15, v16, 589LL);
    uint64_t v59 = v46[3];
    if (v59 != -1)
    {
      unsigned int v33 = v59 ? *(_DWORD *)(v59 + 32) : 0;
      if (MEMORY[0xFFFFFC100]) {
        kdebug_trace(771817476LL, v33, v46, 0LL, 0LL);
      }
    }

    v46[1] = 0LL;
    v46[1] = v42 | 0x10000000;
    v46[2] = v44;
    uint64_t v44 = v46;
    if (!v43) {
      unint64_t v43 = (unint64_t)v46;
    }
  }

  *(_DWORD *)(a1 + 48) = *(_DWORD *)(a1 + 44);
  *(void *)(a1 + 32) = _dispatch_calloc(*(int *)(a1 + 44), 8LL);
  if (MEMORY[0xFFFFFC100])
  {
    uint64_t v56 = v44;
    do
    {
      BOOL v32 = 0;
      if (v56 != (void *)v43)
      {
        uint64_t v56 = (void *)v56[2];
        BOOL v32 = v56 != 0LL;
      }
    }

    while (v32);
  }

  *(void *)(v43 + 16) = 0LL;
  _dispatch_thread_setspecific(122LL, v37 + 48);
  unsigned int v30 = (unint64_t *)(v37 + 48);
  unint64_t v31 = *(void *)(v37 + 48);
  do
  {
    unint64_t v17 = v31;
    do
      unint64_t v18 = __ldaxr(v30);
    while (v18 == v31 && __stlxr(v43, v30));
    unint64_t v31 = v18;
  }

  while (v18 != v17);
  unint64_t v57 = v18;
  if (v18) {
    *(void *)(v18 + 16) = v44;
  }
  else {
    *(void *)(v37 + 104) = v44;
  }
  _dispatch_thread_setspecific(122LL, 0LL);
  if (!v57) {
    _dispatch_root_queue_poke_and_wakeup((uint64_t (***)())v37, v41, 0, v21, v22, v23, v24, v25);
  }
  _dispatch_apply_invoke_and_wait(a1, v19, v20, v21, v22, v23, v24, v25);
  for (uint64_t k = v38; k != v37; uint64_t k = *(void *)(k + 24))
  {
    unint64_t v28 = (unint64_t *)(k + 56);
    unint64_t v29 = *(void *)(k + 56);
    do
    {
      unint64_t v26 = v29;
      do
        unint64_t v27 = __ldaxr(v28);
      while (v27 == v29 && __stlxr(v29 - ((uint64_t)v39 << 41), v28));
      unint64_t v29 = v27;
    }

    while (v27 != v26);
  }

      uint64_t v21 = 0;
      if (*v41 > 0xFFF) {
        uint64_t v21 = *(void *)(*v41 + 16) == 768LL;
      }
      if (v21)
      {
        if ((v45 & 4) == 0) {
          goto LABEL_67;
        }
        _dispatch_continuation_pop(v41, 0LL, a2, a1);
        goto LABEL_53;
      }

      if (*v41 <= 0xFFF && (*v41 & 1) != 0)
      {
        unint64_t v42 = (unint64_t *)v41[6];
        unint64_t v43 = v41[7];
        goto LABEL_37;
      }

      if (*v41 > 0xFFF) {
        break;
      }
      if (*(void *)(v44 + 16) && _dispatch_thread_getspecific(0x14uLL) != &_dispatch_mgr_q)
      {
        *(_WORD *)(a1 + 118) = *(_WORD *)(a1 + 118) & 0xFFFE | 1;
        v35 |= 2u;
        goto LABEL_67;
      }

    if (v34)
    {
      __s2[4] = 0LL;
      *uint64_t v34 = v36[56];
    }

    return;
  }

  *(_DWORD *)(a1[6] + 144) = error;
  if (error)
  {
    _dispatch_io_init((void *)a1[6], 0LL, a1[8], error, a1[4]);
    unsigned int v33 = *(dispatch_object_t *)(a1[6] + 48);
    dispatch_resume(v33);
    BOOL v32 = (unsigned int *)a1[6];
    _dispatch_release(v32);
    unint64_t v31 = (unsigned int *)a1[5];
    _dispatch_release(v31);
    _dispatch_release((unsigned int *)a1[8]);
  }

  else
  {
    if (*(_DWORD *)(a1[5] + 124) == -1)
    {
      *(_DWORD *)(a1[6] + 124) = -1;
      *(_DWORD *)(a1[6] + 128) = -1;
      unsigned int v30 = 0;
      unsigned int v30 = *(_WORD *)(*(void *)(a1[5] + 112) + 36LL);
      unint64_t v29 = 0;
      unint64_t v29 = *(_DWORD *)(*(void *)(a1[5] + 112) + 32LL);
      unint64_t v28 = 0LL;
      unint64_t v28 = *(void *)(*(void *)(*(void *)(a1[5] + 112) + 8LL) + 16LL) + 25LL;
      unint64_t v27 = (void *)malloc_type_malloc(v28, 743473637LL);
      __memcpy_chk(v27, *(void *)(*(void *)(a1[5] + 112) + 8LL), v28, -1LL);
      *unint64_t v27 = a1[6];
      blocuint64_t k = _NSConcreteStackBlock;
      unint64_t v17 = 1107296256;
      unint64_t v18 = 0;
      uint64_t v19 = __dispatch_io_create_with_io_block_invoke_3;
      uint64_t v20 = &__block_descriptor_tmp_11;
      uint64_t v22 = v27;
      uint64_t v25 = v29;
      unint64_t v26 = v30;
      uint64_t v23 = a1[6];
      uint64_t v24 = a1[8];
      uint64_t v21 = a1[4];
      dispatch_channel_async((dispatch_queue_t)_dispatch_io_devs_lockq, &block);
    }

    else
    {
      uint64_t v15 = *(void *)(a1[5] + 112);
      *(_DWORD *)(a1[6] + 124) = *(_DWORD *)(a1[5] + 124);
      *(_DWORD *)(a1[6] + 128) = *(_DWORD *)(a1[5] + 128);
      _dispatch_fd_entry_retain(v15);
      _dispatch_io_init((void *)a1[6], v15, a1[8], 0, a1[4]);
      dispatch_resume(*(dispatch_object_t *)(a1[6] + 48));
      _dispatch_release((unsigned int *)a1[6]);
      _dispatch_release((unsigned int *)a1[8]);
    }

    _dispatch_release((unsigned int *)a1[5]);
    _dispatch_object_debug(a1[6], "%s", v7, v8, v9, v10, v11, v12, (char)"dispatch_io_create_with_io_block_invoke");
  }

void _dispatch_apply_invoke_and_wait( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v27 = a1;
  uint64_t v26 = 2LL;
  int i = 0;
  unsigned int v24 = 0;
  unsigned int v23 = 0;
  int v21 = 1;
  int v20 = 1;
  int v22 = 1;
  unsigned int v16 = *(_DWORD *)(a1 + 52);
  do
  {
    unsigned int v8 = v16;
    uint64_t v9 = (unsigned int *)(a1 + 52);
    do
      unsigned int v10 = __ldaxr(v9);
    while (v10 == v16 && __stlxr(v16 + 1, v9));
    unsigned int v16 = v10;
  }

  while (v10 != v8);
  unsigned int v19 = v10;
  unsigned int v23 = v10;
  unsigned int v18 = v10;
  unsigned int v24 = v10;
  BOOL v29 = v10 < *(_DWORD *)(v27 + 48);
  uint64_t v28 = 210LL;
  if (!v29) {
    _dispatch_abort(v28, 0LL, a3, a4, a5, a6, a7, a8);
  }
  v17[0] = v27;
  v17[1] = v26;
  v17[2] = v24;
  _dispatch_apply_set_attr_behavior(*(int **)(v27 + 56), v24);
  unint64_t v35 = (dispatch_once_t *)(*(void *)(v27 + 32) + 8LL * v24);
  uint64_t v34 = v17;
  dispatch_function_t v33 = (dispatch_function_t)_dispatch_apply_invoke3;
  if (*v35 != -1) {
    dispatch_once_f(v35, v34, v33);
  }
  _dispatch_apply_clear_attr_behavior(*(void *)(v27 + 56), v24);
  if ((v26 & 2) != 0)
  {
    for (int i = 0; i < *(_DWORD *)(v27 + 48); ++i)
    {
      if (i != v24)
      {
        BOOL v32 = (dispatch_once_t *)(*(void *)(v27 + 32) + 8LL * i);
        unint64_t v31 = 0LL;
        unsigned int v30 = _dispatch_no_op;
        if (*v32 != -1) {
          dispatch_once_f(v32, v31, (dispatch_function_t)v30);
        }
      }
    }
  }

  uint64_t v14 = (unsigned int *)(v27 + 44);
  unsigned int v15 = *(_DWORD *)(v27 + 44);
  do
  {
    unsigned int v11 = v15;
    do
      unsigned int v12 = __ldaxr(v14);
    while (v12 == v15 && __stlxr(v15 - 1, v14));
    unsigned int v15 = v12;
  }

  while (v12 != v11);
  if (v12 == 1)
  {
    uint64_t v36 = v27;
    if (*(void *)(v27 + 32)) {
      free(*(void **)(v36 + 32));
    }
    if (*(void *)(v36 + 56))
    {
      dispatch_apply_attr_destroy(*(void *)(v36 + 56));
      free(*(void **)(v36 + 56));
    }

    uint64_t v37 = v36;
    uint64_t v38 = (void *)v36;
    uint64_t v41 = v36;
    uint64_t v40 = 0LL;
    uint64_t v40 = _dispatch_thread_getspecific(0x16uLL);
    int v39 = 0;
    if (v40) {
      int v13 = v40[2] + 1;
    }
    else {
      int v13 = 1;
    }
    int v39 = v13;
    if (v13 <= _dispatch_continuation_cache_limit)
    {
      *(void *)(v41 + 16) = v40;
      *(_DWORD *)(v41 + 8) = v39;
      _dispatch_thread_setspecific(22LL, v41);
      unint64_t v42 = 0LL;
    }

    else
    {
      unint64_t v42 = (void *)v41;
    }

    uint64_t v38 = v42;
    if (v42) {
      _dispatch_continuation_free_to_cache_limit(v38);
    }
  }

dispatch_source_t dispatch_source_create( dispatch_source_type_t type, uintptr_t handle, uintptr_t mask, dispatch_queue_t queue)
{
  uint64_t v23 = (*((uint64_t (**)(dispatch_source_type_t, uintptr_t, uintptr_t))type + 4))(type, handle, mask);
  if (!v23) {
    return 0LL;
  }
  uint64_t v22 = (uint64_t)_dispatch_object_alloc((uint64_t)_OS_dispatch_source_vtable, 0x78uLL, v4, v5, v6, v7, v8, v9);
  else {
    int v14 = 0x400000;
  }
  _dispatch_queue_init(v22, v14, 1LL, 0x180000000000000LL, v10, v11, v12, v13);
  *(void *)(v22 + 72) = "source";
  *(void *)(v22 + 88) = v23;
  *(void *)(v23 + 8) = ~v22;
  if (queue)
  {
    if ((*((_BYTE *)queue + 87) & 8) != 0 && (*(_BYTE *)(v23 + 29) & 2) == 0)
    {
      qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Cannot target source to the cooperative root queue - not implemented";
      qword_E4DA8 = v22;
      __break(1u);
      JUMPOUT(0x5DDC4LL);
    }

    _dispatch_retain((uint64_t)queue);
  }

  else
  {
    dispatch_queue_t queue = (dispatch_queue_t)&off_E46C0;
  }

  *(void *)(v22 + 24) = queue;
  if ((*(_BYTE *)(v23 + 29) & 2) != 0 && (*(_BYTE *)(v23 + 30) & 0x10) != 0) {
    dispatch_source_set_timer((dispatch_source_t)v22, 0LL, handle, 0xFFFFFFFFFFFFFFFFLL);
  }
  _dispatch_object_debug(v22, "%s", v15, v16, v17, v18, v19, v20, (char)"dispatch_source_create");
  return (dispatch_source_t)v22;
}

void dispatch_source_set_timer( dispatch_source_t source, dispatch_time_t start, uint64_t interval, uint64_t leeway)
{
  uint64_t v9 = *((void *)source + 11);
  if ((*(_BYTE *)(v9 + 29) & 2) == 0)
  {
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Attempt to set timer on a non-timer source";
    qword_E4DA8 = (uint64_t)source;
    __break(1u);
    JUMPOUT(0x5DEECLL);
  }

  if ((*(_BYTE *)(v9 + 30) & 0x10) != 0) {
    uint64_t v8 = (_DWORD *)_dispatch_interval_config_create(start, interval, leeway, v9);
  }
  else {
    uint64_t v8 = (_DWORD *)_dispatch_timer_config_create(start, interval, leeway, v9);
  }
  if (_dispatch_timer_flags_to_clock(*(_BYTE *)(v9 + 30)) != v8[6] && *(char *)(v9 + 28) == -20)
  {
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Attempting to modify timer clock";
    __break(1u);
    JUMPOUT(0x5DF94LL);
  }

  uint64_t v7 = *(void **)(v9 + 104);
  do
  {
    uint64_t v4 = v7;
    uint64_t v6 = (unint64_t *)(v9 + 104);
    do
      uint64_t v5 = (void *)__ldaxr(v6);
    while (v5 == v7 && __stlxr((unint64_t)v8, v6));
    uint64_t v7 = v5;
  }

  while (v5 != v4);
  if (v5) {
    free(v5);
  }
  (*(void (**)(dispatch_source_t, void, uint64_t))(*(void *)source + 64LL))(source, 0LL, 2LL);
}

BOOL _dispatch_source_is_timer(uint64_t a1)
{
  return (*(_BYTE *)(*(void *)(a1 + 88) + 29LL) & 2) != 0;
}

void _dispatch_source_dispose( uint64_t a1, _BYTE *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (MEMORY[0xFFFFFC100]) {
    kdebug_trace(772079668LL, a1, 0LL, 0LL, 0LL);
  }
  uint64_t v18 = (unint64_t *)(*(void *)(a1 + 88) + 56LL);
  unint64_t v19 = *v18;
  do
  {
    unint64_t v8 = v19;
    do
      uint64_t v9 = __ldaxr(v18);
    while (v9 == v19 && __stlxr(0LL, v18));
    unint64_t v19 = v9;
  }

  while (v9 != v8);
  if (v9) {
    _dispatch_source_handler_dispose(v9);
  }
  uint64_t v16 = (unint64_t *)(*(void *)(a1 + 88) + 40LL);
  unint64_t v17 = *v16;
  do
  {
    unint64_t v10 = v17;
    do
      uint64_t v11 = __ldaxr(v16);
    while (v11 == v17 && __stlxr(0LL, v16));
    unint64_t v17 = v11;
  }

  while (v11 != v10);
  if (v11) {
    _dispatch_source_handler_dispose(v11);
  }
  int v14 = (unint64_t *)(*(void *)(a1 + 88) + 48LL);
  unint64_t v15 = *v14;
  do
  {
    unint64_t v12 = v15;
    do
      uint64_t v13 = __ldaxr(v14);
    while (v13 == v15 && __stlxr(0LL, v14));
    unint64_t v15 = v13;
  }

  while (v13 != v12);
  if (v13) {
    _dispatch_source_handler_dispose(v13);
  }
  _dispatch_unote_dispose(*(void *)(a1 + 88));
  *(void *)(a1 + 88) = 0LL;
  _dispatch_lane_class_dispose(a1, a2);
}

uint64_t _dispatch_source_xref_dispose(uint64_t a1)
{
  unsigned int v3 = *(_DWORD *)(a1 + 80);
  BOOL v2 = 0;
  if ((v3 & 0x4000000) != 0)
  {
    BOOL v2 = 0;
    if ((v3 & 0x10000000) == 0) {
      BOOL v2 = *(void *)(*(void *)(a1 + 88) + 48LL) != 0LL;
    }
  }

  if (v2)
  {
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Release of a source that has not been cancelled, but has a mand"
                           "atory cancel handler";
    qword_E4DA8 = v3;
    __break(1u);
    JUMPOUT(0x5EB94LL);
  }

  return (*(uint64_t (**)(uint64_t, void, uint64_t))(*(void *)a1 + 64LL))(a1, 0LL, 2LL);
}

intptr_t dispatch_source_testcancel(dispatch_source_t source)
{
  return (*((_DWORD *)source + 20) & 0x10000000) != 0;
}

uintptr_t dispatch_source_get_mask(dispatch_source_t source)
{
  uint64_t v2 = *((void *)source + 11);
  if ((*((_DWORD *)source + 20) & 0x10000000) != 0) {
    return 0LL;
  }
  if ((*(_BYTE *)(v2 + 29) & 0x10) != 0) {
    return 0x80000000LL;
  }
  if ((*(_BYTE *)(v2 + 29) & 2) != 0) {
    return *(unsigned __int8 *)(v2 + 30);
  }
  return *(unsigned int *)(v2 + 32);
}

uintptr_t dispatch_source_get_handle(dispatch_source_t source)
{
  uint64_t v3 = *((void *)source + 11);
  int v2 = _dispatch_timer_flags_to_clock(*(_BYTE *)(v3 + 30));
  if (!v2) {
    return 1LL;
  }
  if (v2 == 1) {
    return 2LL;
  }
  if (v2 != 2) {
    return *(unsigned int *)(v3 + 24);
  }
  return 3LL;
}

uint64_t _dispatch_timer_flags_to_clock(char a1)
{
  return (a1 & 0xC) >> 2;
}

uintptr_t dispatch_source_get_data(dispatch_source_t source)
{
  uint64_t v3 = *((void *)source + 11);
  if ((*(_BYTE *)(v3 + 29) & 0x10) != 0) {
    return 0x80000000LL;
  }
  if ((*(_BYTE *)(v3 + 29) & 4) != 0) {
    return *(void *)(v3 + 64);
  }
  else {
    return *(void *)(v3 + 64);
  }
}

uint64_t dispatch_source_get_extended_data(uint64_t a1, uintptr_t *a2, unint64_t a3)
{
  uint64_t v8 = *(void *)(a1 + 88);
  if (a3 >= 0x10) {
    uint64_t v4 = 16LL;
  }
  else {
    uint64_t v4 = a3;
  }
  if (a3)
  {
    uintptr_t v6 = 0LL;
    if ((*(_BYTE *)(v8 + 29) & 4) != 0)
    {
      unint64_t v5 = *(void *)(v8 + 64);
      uintptr_t data = v5;
      uintptr_t v6 = HIDWORD(v5);
    }

    else
    {
      uintptr_t data = dispatch_source_get_data((dispatch_source_t)a1);
    }

    if (a3 >= 8) {
      *a2 = data;
    }
    if (a3 >= 0x10) {
      a2[1] = v6;
    }
    if (a3 > 0x10) {
      __memset_chk(a2 + 2, 0LL, a3 - 16, -1LL);
    }
  }

  return v4;
}

void dispatch_source_merge_data(dispatch_source_t source, uintptr_t value)
{
  uint64_t v12 = *((void *)source + 11);
  if ((*((_DWORD *)source + 20) & 0x10800000) == 0)
  {
    int v11 = *(char *)(v12 + 28);
    switch(v11)
    {
      case -23:
        *(void *)(v12 + 72) = value;
        break;
      case -22:
        uint64_t v7 = (unint64_t *)(v12 + 72);
        unint64_t v8 = *(void *)(v12 + 72);
        do
        {
          unint64_t v4 = v8;
          do
            unint64_t v5 = __ldaxr(v7);
          while (v5 == v8 && __stlxr(v8 | value, v7));
          unint64_t v8 = v5;
        }

        while (v5 != v4);
        break;
      case -21:
        uint64_t v9 = (unint64_t *)(v12 + 72);
        unint64_t v10 = *(void *)(v12 + 72);
        do
        {
          unint64_t v2 = v10;
          do
            unint64_t v3 = __ldaxr(v9);
          while (v3 == v10 && __stlxr(v10 + value, v9));
          unint64_t v10 = v3;
        }

        while (v3 != v2);
        break;
      default:
        uint64_t v6 = *(char *)(v12 + 28);
        qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Invalid source type";
        qword_E4DA8 = v6;
        __break(1u);
        JUMPOUT(0x5F298LL);
    }

    (*(void (**)(dispatch_source_t, void, uint64_t))(*(void *)source + 64LL))(source, 0LL, 2LL);
  }

void dispatch_source_set_event_handler(dispatch_source_t source, dispatch_block_t handler)
{
}

void _dispatch_source_set_handler(uint64_t a1, const void *a2, uint64_t a3, char a4)
{
  char v39 = a4 & 1;
  int v55 = (uint64_t *)_dispatch_thread_getspecific(0x16uLL);
  if (v55)
  {
    _dispatch_thread_setspecific(22LL, v55[2]);
    unint64_t v51 = v55;
  }

  else
  {
    unint64_t v51 = (uint64_t *)_dispatch_continuation_alloc_from_heap();
  }

  if (a2)
  {
    uint64_t v38 = 0LL;
    if (a3) {
      uint64_t v38 = 4LL;
    }
    if ((v39 & 1) != 0)
    {
      int v53 = _dispatch_Block_copy(a2);
      if ((void (*)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))_Block_get_invoke_fn((uint64_t)a2) == ___dispatch_block_create_block_invoke)
      {
        *unint64_t v51 = v38 | 0x110;
        v51[5] = (uint64_t)v53;
        _dispatch_continuation_init_slow(v51, (unsigned int *)a1, 1073741888);
      }

      else
      {
        uint64_t v52 = _Block_get_invoke_fn((uint64_t)a2);
        if ((v38 & 4) != 0) {
          uint64_t v52 = (uint64_t)_dispatch_call_block_and_release;
        }
        *unint64_t v51 = v38 | 0x110;
        v51[4] = v52;
        v51[5] = (uint64_t)v53;
        v51[3] = 0LL;
        _dispatch_thread_getspecific(0LL);
        _dispatch_log("%u\t%p\tvoucher[%p]: continuation[%p] set", v4, v5, v6, v7, v8, v9, v10, 589LL);
        uint64_t v56 = v51[3];
        if (v56 != -1)
        {
          unsigned int v33 = v56 ? *(_DWORD *)(v56 + 32) : 0;
          if (MEMORY[0xFFFFFC100]) {
            kdebug_trace(771817476LL, v33, v51, 0LL, 0LL);
          }
        }

        v51[1] = 0LL;
      }
    }

    else
    {
      uint64_t v54 = *(void *)(a1 + 32);
      *unint64_t v51 = v38 | 0x140;
      v51[4] = (uint64_t)a2;
      v51[5] = v54;
      v51[3] = 0LL;
      _dispatch_thread_getspecific(0LL);
      _dispatch_log("%u\t%p\tvoucher[%p]: continuation[%p] set", v11, v12, v13, v14, v15, v16, v17, 589LL);
      uint64_t v57 = v51[3];
      if (v57 != -1)
      {
        unsigned int v32 = v57 ? *(_DWORD *)(v57 + 32) : 0;
        if (MEMORY[0xFFFFFC100]) {
          kdebug_trace(771817476LL, v32, v51, 0LL, 0LL);
        }
      }

      v51[1] = 0LL;
    }
  }

  else
  {
    *unint64_t v51 = 256LL;
    v51[4] = 0LL;
  }

  unint64_t v43 = (unint64_t *)(a1 + 56);
  do
  {
    if (_os_atomic_mo_has_acquire(0)) {
      unint64_t v25 = __ldaxr(v43);
    }
    else {
      unint64_t v25 = __ldxr(v43);
    }
    __int16 v46 = HIWORD(v25);
    if ((~v25 & 0x180000000000000LL) != 0)
    {
      __clrex();
      char v47 = 0;
      goto LABEL_42;
    }

    unint64_t v45 = v25 + 0x400000000000000LL;
    if (_os_atomic_mo_has_release(0)) {
      BOOL v44 = __stlxr(v45, v43) == 0;
    }
    else {
      BOOL v44 = __stxr(v45, v43) == 0;
    }
  }

  while (!v44);
  LOBYTE(v3_dispatch_source_set_handler((uint64_t)source, handler, 0LL, 1) = 1;
  if ((v46 & 0xFF80) != 0) {
    int v31 = (HIBYTE(v46) >> 1) & 1;
  }
  if ((v31 & 1) != 0)
  {
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Too many calls to dispatch_suspend() prior to calling dispatch_"
                           "set_target_queue() or dispatch_set_*_handler()";
    __break(1u);
    JUMPOUT(0x5FFDCLL);
  }

  char v47 = 1;
LABEL_42:
  if (v47 == 1)
  {
    unint64_t v48 = (unint64_t)v51;
    if (v51[4])
    {
      if ((*(_BYTE *)v51 & 0x40) != 0) {
        v51[5] = *(void *)(a1 + 32);
      }
    }

    else
    {
      BOOL v49 = _dispatch_thread_getspecific(0x16uLL);
      if (v49) {
        int v30 = v49[2] + 1;
      }
      else {
        int v30 = 1;
      }
      if (v30 <= _dispatch_continuation_cache_limit)
      {
        v51[2] = (uint64_t)v49;
        *((_DWORD *)v51 + 2) = v30;
        _dispatch_thread_setspecific(22LL, (uint64_t)v51);
        int v50 = 0LL;
      }

      else
      {
        int v50 = v51;
      }

      if (v50) {
        _dispatch_continuation_free_to_cache_limit(v50);
      }
      unint64_t v48 = 0LL;
    }

    uint64_t v28 = (unint64_t *)(*(void *)(a1 + 88) + 8 * a3 + 40);
    unint64_t v29 = *v28;
    do
    {
      unint64_t v26 = v29;
      do
        uint64_t v27 = __ldaxr(v28);
      while (v27 == v29 && __stlxr(v48, v28));
      unint64_t v29 = v27;
    }

    while (v27 != v26);
    if (v27) {
      _dispatch_source_handler_dispose(v27);
    }
    _dispatch_lane_resume((unsigned __int16 *)a1, 0);
  }

  else
  {
    int v34 = *(_DWORD *)(a1 + 80);
    if (((HIBYTE(v34) >> 2) & 1) != 0)
    {
      qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Cannot change a handler of this source after it has been activated";
      qword_E4DA8 = a3;
      __break(1u);
      JUMPOUT(0x6029CLL);
    }

    if ((v34 & 0x10000000) == 0)
    {
      if (MEMORY[0xFFFFFC100]) {
        kdebug_trace(771883020LL, a1, 0LL, 0LL, 0LL);
      }
      if (a3 == 2)
      {
        _dispatch_bug_deprecated( (uint64_t)"Setting registration handler after the source has been activated",  v18,  v19,  v20,  v21,  v22,  v23,  v24);
      }

      else if (!a2)
      {
        _dispatch_bug_deprecated( (uint64_t)"Clearing handler after the source has been activated",  v18,  v19,  v20,  v21,  v22,  v23,  v24);
      }
    }

    v51[6] = a3;
    _dispatch_barrier_trysync_or_async_f(a1, v51, _dispatch_source_set_handler_slow, 0LL);
  }

void dispatch_source_set_event_handler_f(dispatch_source_t source, dispatch_function_t handler)
{
}

void dispatch_source_set_cancel_handler(dispatch_source_t source, dispatch_block_t handler)
{
}

void dispatch_source_set_mandatory_cancel_handler(dispatch_source_s *a1, void *a2)
{
  uint64_t v5 = (unsigned int *)((char *)a1 + 80);
  while (1)
  {
    unsigned int v2 = _os_atomic_mo_has_acquire(0) ? __ldaxr(v5) : __ldxr(v5);
    unsigned int v7 = v2 & 0xFBBFFFFF | 0x4000000;
    if (v7 == v2) {
      break;
    }
    if (_os_atomic_mo_has_release(0)) {
      BOOL v6 = __stlxr(v7, v5) == 0;
    }
    else {
      BOOL v6 = __stxr(v7, v5) == 0;
    }
    if (v6) {
      goto LABEL_11;
    }
  }

  __clrex();
LABEL_11:
  dispatch_source_set_cancel_handler(a1, a2);
}

void dispatch_source_set_cancel_handler_f(dispatch_source_t source, dispatch_function_t handler)
{
}

void dispatch_source_set_mandatory_cancel_handler_f(dispatch_source_s *a1, void (__cdecl *a2)(void *))
{
  uint64_t v5 = (unsigned int *)((char *)a1 + 80);
  while (1)
  {
    unsigned int v2 = _os_atomic_mo_has_acquire(0) ? __ldaxr(v5) : __ldxr(v5);
    unsigned int v7 = v2 & 0xFBBFFFFF | 0x4000000;
    if (v7 == v2) {
      break;
    }
    if (_os_atomic_mo_has_release(0)) {
      BOOL v6 = __stlxr(v7, v5) == 0;
    }
    else {
      BOOL v6 = __stxr(v7, v5) == 0;
    }
    if (v6) {
      goto LABEL_11;
    }
  }

  __clrex();
LABEL_11:
  dispatch_source_set_cancel_handler_f(a1, a2);
}

void dispatch_source_set_registration_handler(dispatch_source_t source, dispatch_block_t handler)
{
}

void dispatch_source_set_registration_handler_f(dispatch_source_t source, dispatch_function_t handler)
{
}

BOOL _dispatch_source_will_reenable_kevent_4NW(uint64_t a1)
{
  int v3 = *(void *)(a1 + 56);
  if (((v3 ^ _dispatch_thread_getspecific(3uLL)) & 0xFFFFFFFC) != 0)
  {
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: _dispatch_source_will_reenable_kevent_4NW not called from withi"
                           "n the event handler";
    __break(1u);
    JUMPOUT(0x60834LL);
  }

  uint64_t v5 = *(void *)(*(void *)(a1 + 88) + 16LL);
  BOOL v2 = 0;
  if (v5)
  {
    BOOL v2 = 0;
    if ((v5 & 1) == 0) {
      return (v5 & 2) == 0;
    }
  }

  return v2;
}

void _dispatch_source_activate( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v30 = (unsigned int *)a1;
  uint64_t v29 = 0LL;
  uint64_t v28 = 0LL;
  uint64_t v28 = *(void *)(a1 + 88);
  unsigned int v27 = 0;
  uint64_t v26 = 0LL;
  uint64_t v34 = a1;
  int v33 = 0;
  int v32 = *(_DWORD *)(a1 + 80);
  int v33 = v32;
  int v31 = v32;
  if (((HIBYTE(v32) >> 4) & 1) != 0)
  {
    *((_WORD *)v30 + 58) |= 1u;
    _dispatch_source_refs_finalize_unregistration(v30);
  }

  else
  {
    uint64_t v39 = v28;
    uint64_t v38 = 0LL;
    uint64_t v37 = 0LL;
    uint64_t v36 = *(void *)(v28 + 40);
    uint64_t v37 = v36;
    uint64_t v35 = v36;
    uint64_t v29 = v36;
    if (v36)
    {
      BOOL v44 = (_DWORD *)v29;
      int v43 = 0;
      uint64_t v72 = v29;
      if (*(void *)v29 > 0xFFFuLL)
      {
        if ((*(void *)(*(void *)v44 + 16LL) & 0xF0LL) == 0x10)
        {
          int v42 = 0;
          int v41 = v44[20];
          int v42 = v41;
          int v40 = v41;
          int v43 = v41;
          BOOL v45 = (v41 & 0x80000) != 0;
        }

        else
        {
          BOOL v45 = 0;
        }
      }

      else
      {
        BOOL v45 = (*v44 & 2) != 0;
      }

      if (v45)
      {
        uint64_t v57 = v30;
        int v56 = 0x80000;
        int v54 = 0x80000;
        int v53 = 0x80000;
        int v55 = 0x80000;
        unsigned int v51 = 0;
        int v49 = 0x80000;
        int v48 = 0x80000;
        int v50 = 0x80000;
        uint64_t v23 = v30 + 20;
        unsigned int v24 = v30[20];
        do
        {
          unsigned int v8 = v24;
          do
            unsigned int v9 = __ldaxr(v23);
          while (v9 == v24 && __stlxr(v24 | 0x80000, v23));
          unsigned int v24 = v9;
        }

        while (v9 != v8);
        unsigned int v47 = v9;
        unsigned int v51 = v9;
        unsigned int v46 = v9;
        int v52 = v9 | v55;
      }

      if ((*(_BYTE *)(v29 + 11) & 0x10) != 0) {
        goto LABEL_20;
      }
      unsigned int v58 = v30[21];
      BOOL v22 = 0;
      if ((v58 & 0x20000000) == 0) {
        BOOL v22 = (v58 & 0x44000FFF) != 0;
      }
      if (!v22)
      {
LABEL_20:
        uint64_t v61 = *(void *)(v29 + 8);
        char v60 = 0;
        BOOL v71 = (v61 & 0x20000000) == 0;
        uint64_t v70 = 458LL;
        if ((v61 & 0x20000000) != 0) {
          _dispatch_abort(v70, v71, a3, a4, a5, a6, a7, a8);
        }
        unsigned int v59 = v61;
        unint64_t v69 = (unint64_t)(v61 & 0x3FFF00) >> 8;
        unsigned int v10 = (v61 & 0x3FFF00) >> 8;
        unsigned int v11 = __clz(__rbit32(v10));
        if (v10) {
          unsigned int v12 = v11 + 1;
        }
        else {
          unsigned int v12 = 0;
        }
        v59 |= v12 << 8;
        v30[21] = v59;
      }

      if ((*(_BYTE *)v29 & 0x40) != 0) {
        *(void *)(v29 + 4_dispatch_source_set_handler((uint64_t)source, handler, 2LL, 0) = *((void *)v30 + 4);
      }
    }

    else
    {
      _dispatch_bug_deprecated( (uint64_t)"dispatch source activated with no event handler set",  a2,  a3,  a4,  a5,  a6,  a7,  a8);
    }

    _dispatch_lane_activate((uint64_t)v30);
    if (((*(_BYTE *)(v28 + 29) & 1) != 0 || (*(_BYTE *)(v28 + 29) & 2) != 0) && (v30[29] & 1) == 0)
    {
      unsigned int v27 = _dispatch_queue_compute_priority_and_wlh((uint64_t)v30, &v26);
      if (v27)
      {
        uint64_t v62 = v26;
        if (v26 && v62 != -4)
        {
          if (*(_BYTE *)(*(void *)v62 + 16LL) == 18LL) {
            uint64_t v63 = v62;
          }
          else {
            uint64_t v63 = 0LL;
          }
        }

        else
        {
          uint64_t v63 = 0LL;
        }

        uint64_t v25 = v63;
        if (v63 && *(char *)(v28 + 28) == -20 && *(_DWORD *)(v28 + 24) <= 5u)
        {
          if (!*(void *)(v63 + 48)) {
            *(void *)(v25 + 48) = _dispatch_calloc(6LL, 32LL);
          }
          *(_BYTE *)(v28 + 29) |= 1u;
          uint64_t v65 = v26;
          if (v26 && v65 != -4)
          {
            uint64_t v64 = v65;
            uint64_t v84 = v65;
            unsigned int v83 = 0;
            int v81 = 1;
            int v80 = 1;
            int v82 = 1;
            unsigned int v78 = 0;
            int v76 = 1;
            int v75 = 1;
            int v77 = 1;
            uint64_t v20 = (unsigned int *)(v65 + 96);
            unsigned int v21 = *(_DWORD *)(v65 + 96);
            do
            {
              unsigned int v18 = v21;
              do
                unsigned int v19 = __ldaxr(v20);
              while (v19 == v21 && __stlxr(v21 + 1, v20));
              unsigned int v21 = v19;
            }

            while (v19 != v18);
            unsigned int v74 = v19;
            unsigned int v78 = v19;
            unsigned int v73 = v19;
            unsigned int v79 = v19 + v82;
            unsigned int v83 = v19 + v82;
            if ((int)(v19 + v82) <= 0)
            {
              qword_E4D78 = (uint64_t)"API MISUSE: Resurrection of an object";
              __break(1u);
              JUMPOUT(0x60F60LL);
            }
          }

          uint64_t v68 = v28;
          uint64_t v67 = v26;
          uint64_t v66 = 0LL;
          uint64_t v89 = v28;
          uint64_t v88 = v26;
          uint64_t v87 = v26;
          uint64_t v86 = v26;
          *(void *)(v28 + 16) = v26;
          uint64_t v85 = v87;
        }

        _dispatch_source_install((uint64_t)v30, v26, v27, v13, v14, v15, v16, v17);
      }
    }
  }

void _dispatch_source_refs_finalize_unregistration(unsigned int *a1)
{
  unsigned int v9 = a1 + 20;
  do
  {
    if (_os_atomic_mo_has_acquire(0)) {
      unsigned int v7 = __ldaxr(v9);
    }
    else {
      unsigned int v7 = __ldxr(v9);
    }
    unsigned int v12 = v7;
    unsigned int v11 = v7 & 0x1FFFFFFF | 0x80000000;
    if ((v12 & 0x1FFFFFFF | 0x80000000) == v12)
    {
      __clrex();
      unsigned int v13 = v7;
      goto LABEL_12;
    }

    if (_os_atomic_mo_has_release(0)) {
      BOOL v10 = __stlxr(v11, v9) == 0;
    }
    else {
      BOOL v10 = __stxr(v11, v9) == 0;
    }
  }

  while (!v10);
  unsigned int v13 = v12;
LABEL_12:
  if ((v13 & 0x80000000) != 0)
  {
    qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: Source finalized twice";
    qword_E4DA8 = v13;
    __break(1u);
    JUMPOUT(0x61198LL);
  }

  if ((v13 & 0x20000000) != 0) {
    _dispatch_wake_by_address((uint64_t)(a1 + 20));
  }
  _dispatch_object_debug( (uint64_t)a1,  "%s",  v1,  v2,  v3,  v4,  v5,  v6,  (char)"_dispatch_source_refs_finalize_unregistration");
  _dispatch_release_tailcall(a1);
}

void _dispatch_source_install( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v14 = a3;
  uint64_t v13 = *(void *)(a1 + 88);
  if ((*(_WORD *)(a1 + 116) & 1) != 0) {
    _dispatch_abort(660LL, (*(_WORD *)(a1 + 116) & 1) == 0, a3, a4, a5, a6, a7, a8);
  }
  *(_WORD *)(a1 + 116) = *(_WORD *)(a1 + 116) & 0xFFFE | 1;
  _dispatch_object_debug(a1, "%s", a3, a4, a5, a6, a7, a8, (char)"_dispatch_source_install");
  if (!_dispatch_unote_register(v13, a2, v14, v8, v9, v10, v11, v12)) {
    _dispatch_source_refs_finalize_unregistration((unsigned int *)a1);
  }
}

void _dispatch_source_invoke(unsigned int *a1, uint64_t a2, unsigned int a3)
{
  unint64_t v69 = a1;
  uint64_t v68 = a2;
  unsigned int v67 = a3;
  int v66 = 8;
  uint64_t v65 = _dispatch_source_invoke2;
  uint64_t v64 = a1;
  v63[8] = 0;
  *(void *)uint64_t v63 = (a3 & 1) == 0;
  uint64_t v62 = 0LL;
  if ((a3 & 3) == 0)
  {
    *((void *)v64 + 2) = -1985229329LL;
    uint64_t v61 = _dispatch_thread_getspecific(0x14uLL);
    char v60 = v64;
    unsigned int v79 = v61;
    unsigned int v78 = v64;
    int v77 = 0;
    int v76 = 0;
    uint64_t v142 = v61;
    uint64_t v141 = v64;
  }

  v67 |= v66;
  if ((v67 & 2) != 0)
  {
    uint64_t v62 = 0x40020000000001LL;
    goto LABEL_54;
  }

  uint64_t v91 = v64;
  unsigned int v90 = v67;
  uint64_t v89 = 0LL;
  uint64_t v89 = (uint64_t)(*((unsigned __int16 *)v64 + 40) - 1) << 41;
  unsigned int v192 = _dispatch_thread_getspecific(3uLL);
  uint64_t v88 = v192 & 0xFFFFFFFC | 0x20000000000000LL;
  unint64_t v86 = 0LL;
  unint64_t v85 = 0LL;
  uint64_t v84 = 0LL;
  unint64_t v87 = 0xFFE00000FFFFFFFCLL;
  if ((v67 & 1) != 0)
  {
    v87 |= 0x4000000000uLL;
    uint64_t v84 = 0LL;
  }

  else if ((v90 & 0x40000) != 0)
  {
    uint64_t v84 = 0x4000000000LL;
  }

  else
  {
    v87 |= 0x4000000000uLL;
    uint64_t v84 = 1LL;
  }

  BOOL v96 = (v90 & 2) == 0;
  uint64_t v95 = 1323LL;
  if ((v90 & 2) != 0) {
    _dispatch_abort(v95, v96, v3, v4, v5, v6, v7, v8);
  }
  unsigned int v83 = 0;
  unsigned int v146 = _dispatch_thread_getspecific(0x19uLL);
  unsigned int v152 = v146 & 0xF00;
  unsigned int v145 = v152 >> 8;
  unsigned int v155 = v146 & 0xF000;
  unsigned int v144 = v155 >> 12;
  int v158 = v146 & 0xF0000;
  unsigned int v143 = (v146 & 0xF0000) >> 16;
  if (v152 >> 8 <= v155 >> 12) {
    unsigned int v52 = v144;
  }
  else {
    unsigned int v52 = v145;
  }
  if (v52 <= v143)
  {
    unsigned int v50 = v143;
  }

  else
  {
    if (v145 <= v144) {
      unsigned int v51 = v144;
    }
    else {
      unsigned int v51 = v145;
    }
    unsigned int v50 = v51;
  }

  unsigned int v83 = v50;
LABEL_22:
  BOOL v82 = 0;
  int v81 = (unint64_t *)(v91 + 14);
  while (1)
  {
    unint64_t v15 = _os_atomic_mo_has_acquire(2) ? __ldaxr(v81) : __ldxr(v81);
    unint64_t v86 = v15;
    unint64_t v85 = v15;
    if ((v15 & v87) != 0) {
      break;
    }
    unint64_t v148 = v86;
    unsigned int v147 = v83;
    unint64_t v159 = v86;
    BOOL v49 = 0;
    if ((v86 & 0x1000000000LL) != 0)
    {
      uint64_t v161 = v148 & 0x700000000LL;
      BOOL v49 = v147 < (v148 & 0x700000000LL) >> 32;
    }

    if (v49)
    {
      __clrex();
      unint64_t v150 = v86;
      uint64_t v160 = v86 & 0x700000000LL;
      unsigned int v149 = (v86 & 0x700000000LL) >> 32;
      unsigned int v164 = _dispatch_thread_getspecific(3uLL);
      unsigned int v163 = v149;
      if ((_dispatch_set_qos_class_enabled & 1) != 0)
      {
        unsigned int v166 = v163;
        uint64_t v165 = 0LL;
        if (v163) {
          uint64_t v165 = 1LL << (v166 + 7);
        }
        _pthread_workqueue_override_start_direct(v164, v165 | 0xFF);
      }

      unsigned int v168 = v149;
      unsigned int v167 = _dispatch_thread_getspecific(0x19uLL);
      int v169 = v167 & 0xF0000;
      if (v149 > (v167 & 0xF0000) >> 16)
      {
        unsigned int v167 = v167 & 0xFFF0FFFF | (v168 << 16);
        _dispatch_thread_setspecific(25LL, v167);
      }

      unsigned int v83 = v149;
      goto LABEL_22;
    }

    unint64_t v85 = v85 & 0x7700000001LL | v88;
    unint64_t v151 = v86;
    if ((v86 & 0x10000000000LL) != 0 || v86 + v89 < 0x20000000000000LL) {
      v85 |= 0x40000000000000uLL;
    }
LABEL_44:
    if (_os_atomic_mo_has_release(2)) {
      BOOL v82 = __stlxr(v85, v81) == 0;
    }
    else {
      BOOL v82 = __stxr(v85, v81) == 0;
    }
    if (v82) {
      goto LABEL_48;
    }
  }

  if (v84)
  {
    v85 ^= v84;
    goto LABEL_44;
  }

  __clrex();
LABEL_48:
  BOOL v80 = v82;
  BOOL v94 = (v86 & v84) == v84;
  uint64_t v93 = 1356LL;
  if ((v86 & v84) != v84) {
    _dispatch_abort(v93, v94, v9, v10, v11, v12, v13, v14);
  }
  if ((v86 & v87) != 0)
  {
    uint64_t v92 = 0LL;
  }

  else
  {
    v85 &= v84 | 0x60000000000000LL;
    v86 &= 0x3FFE0000000000uLL;
    uint64_t v92 = v85 - v86;
  }

  uint64_t v62 = v92;
LABEL_54:
  if (v62)
  {
    unsigned int v59 = 0;
    if ((v67 & 0x40000) != 0)
    {
      unsigned int v59 = 0;
    }

    else
    {
      unsigned int v99 = v64[21];
      unsigned int v98 = _dispatch_thread_getspecific(0x19uLL);
      unsigned int v97 = v98;
      if (v98)
      {
        if ((v99 & 0xFFF) != 0)
        {
          v97 &= 0x880F0000;
          if ((v98 & 0xFFF) <= (v99 & 0xFFF)) {
            int v48 = v99 & 0xFFF;
          }
          else {
            int v48 = v98 & 0xFFF;
          }
          v97 |= v48;
          unsigned int v156 = v99 & 0xF000;
          unsigned int v153 = v97 & 0xF00;
          if (v156 >> 12 <= v153 >> 8) {
            v99 &= 0x40000000u;
          }
          else {
            v99 &= 0x4400F000u;
          }
          v97 |= v99;
        }

        else
        {
          if ((v97 & 0xFFF) != 0) {
            v97 |= 0x40000000u;
          }
          unsigned int v157 = v99 & 0xF000;
          unsigned int v154 = v97 & 0xF00;
          if (v157 >> 12 > v154 >> 8) {
            unsigned int v97 = v97 & 0xFFFF0FFF | v99 & 0x400F000;
          }
        }
      }

      else
      {
        unsigned int v97 = v99 & 0xFFF0FFFF;
      }

      _dispatch_thread_setspecific(25LL, v97);
      unsigned int v59 = v98;
    }

    if ((v67 & 0x100000) != 0)
    {
      unsigned int v73 = v69;
      unsigned int v72 = 0;
      unsigned int v71 = v69[20];
      unsigned int v72 = v71;
      unsigned int v70 = v71;
      if ((v71 & 0x400000) != 0)
      {
        __int128 v111 = v69;
        int v110 = 0x400000;
        int v108 = -4194305;
        int v107 = -4194305;
        int v109 = -4194305;
        unsigned int v105 = 0;
        unsigned int v46 = v69 + 20;
        int v103 = -4194305;
        int v102 = -4194305;
        int v104 = -4194305;
        unsigned int v47 = v69[20];
        do
        {
          unsigned int v16 = v47;
          do
            unsigned int v17 = __ldaxr(v46);
          while (v17 == v47 && __stlxr(v47 & 0xFFBFFFFF, v46));
          unsigned int v47 = v17;
        }

        while (v17 != v16);
        unsigned int v101 = v17;
        unsigned int v105 = v17;
        unsigned int v100 = v17;
        int v106 = v17 & v109;
      }
    }

    unsigned int v58 = v64;
    unint64_t v114 = v64;
    unsigned int v113 = v67;
    int v112 = 0;
    unsigned int v174 = v64;
    uint64_t v173 = 256LL;
    uint64_t v180 = 1LL;
    uint64_t v179 = 730LL;
    int v172 = 0;
    int v178 = v64;
    unsigned int v177 = 0;
    unsigned int v176 = v64[20];
    unsigned int v177 = v176;
    unsigned int v175 = v176;
    int v172 = v176 & 0x30000;
    int v112 = (v176 & 0x30000) << 8;
    if (v112) {
      unsigned int v113 = v113 & 0xFCFFFFFF | v112;
    }
    unsigned int v67 = v113;
    do
    {
      if ((v67 & 2) != 0 && (v67 & 0x1000000) == 0) {
        _dispatch_last_resort_autorelease_pool_push(v68);
      }
      uint64_t v57 = v64;
      *(void *)&v63[1] = v65((uint64_t)v64, v68, v67, &v62);
      if ((v67 & 2) != 0 && (v67 & 0x1000000) == 0)
      {
        __int128 v56 = 0uLL;
        uint64_t v116 = v64;
        unint64_t v115 = &v56;
        uint64_t v181 = &v56;
        _dispatch_thread_getspecific_packed_pair(20LL, 21LL, &v56, v19, v20, v21, v22, v23);
        _dispatch_thread_setspecific_pair(20LL, (uint64_t)v116, 21LL, (uint64_t)v115, v24, v25, v26, v27);
        _dispatch_last_resort_autorelease_pool_pop(v68);
        uint64_t v117 = &v56;
        _dispatch_thread_setspecific_packed_pair(20LL, 21LL, &v56, v28, v29, v30, v31, v32);
      }

      BOOL v75 = *(void *)&v63[1] != 1LL;
      uint64_t v74 = 2018LL;
      if (*(void *)&v63[1] == 1LL) {
        _dispatch_abort(v74, v75, v18, v19, v20, v21, v22, v23);
      }
      BOOL v45 = 0;
      if (*(void *)&v63[1]) {
        BOOL v45 = *(void *)&v63[1] != -1LL;
      }
      if (v45) {
        break;
      }
      uint64_t v135 = v64;
      uint64_t v134 = v62;
      BOOL v133 = *(void *)&v63[1] == 0LL;
      unint64_t v132 = 0LL;
      unint64_t v131 = 0LL;
      int v130 = 0;
      unint64_t v129 = (unint64_t *)(v64 + 14);
      do
      {
        if (_os_atomic_mo_has_acquire(3)) {
          unint64_t v33 = __ldaxr(v129);
        }
        else {
          unint64_t v33 = __ldxr(v129);
        }
        unint64_t v132 = v33;
        unint64_t v131 = (v33 - v134) & 0xFFFFFFF700000001LL;
        unint64_t v137 = v33;
        if ((v33 & 0xFF80000000000000LL) == 0)
        {
          unint64_t v182 = v132;
          if ((v132 & 0x8000000000LL) != 0)
          {
            __clrex();
            uint64_t v127 = 0x8000000000LL;
            uint64_t v126 = 0x8000000000LL;
            uint64_t v128 = 0x8000000000LL;
            unint64_t v124 = 0LL;
            int v43 = (unint64_t *)(v135 + 14);
            uint64_t v122 = 0x8000000000LL;
            uint64_t v121 = 0x8000000000LL;
            uint64_t v123 = 0x8000000000LL;
            unint64_t v44 = *((void *)v135 + 7);
            do
            {
              unint64_t v34 = v44;
              do
                unint64_t v35 = __ldaxr(v43);
              while (v35 == v44 && __stlxr(v44 ^ 0x8000000000LL, v43));
              unint64_t v44 = v35;
            }

            while (v35 != v34);
            unint64_t v120 = v35;
            unint64_t v124 = v35;
            unint64_t v119 = v35;
            unint64_t v125 = v35 ^ v128;
            char v136 = 0;
            goto LABEL_119;
          }

          if (v133) {
            v131 &= 0xFFFFFFF8FFFFFFFFLL;
          }
          else {
            v131 |= 0x8000000000uLL;
          }
        }

        if (_os_atomic_mo_has_release(3))
        {
          LOBYTE(v13_dispatch_source_set_handler((uint64_t)source, handler, 2LL, 0) = __stlxr(v131, v129) == 0;
          int v130 = v130;
        }

        else
        {
          LOBYTE(v13_dispatch_source_set_handler((uint64_t)source, handler, 2LL, 0) = __stxr(v131, v129) == 0;
          int v130 = v130;
        }
      }

      while (!v130);
      int v118 = v130;
      unint64_t v183 = v132;
      unint64_t v184 = v132;
      BOOL v42 = 0;
      if ((v132 & 0x1000000000LL) != 0) {
        BOOL v42 = (v183 & 0x800000000LL) != 0;
      }
      if (v42)
      {
        uint64_t v162 = v132 & 0x700000000LL;
        uint64_t v170 = v132 & 0x700000000LL;
        LODWORD(v17_dispatch_source_set_handler((uint64_t)source, handler, 2LL, 0) = _dispatch_thread_getspecific(0x19uLL);
        int v171 = v170 & 0xF0000;
        if (HIDWORD(v170) > (v170 & 0xF0000) >> 16)
        {
          LODWORD(v17_dispatch_source_set_handler((uint64_t)source, handler, 2LL, 0) = v170 & 0xFFF0FFFF;
          LODWORD(v17_dispatch_source_set_handler((uint64_t)source, handler, 2LL, 0) = v170 | (HIDWORD(v170) << 16);
          _dispatch_thread_setspecific(25LL, v170);
        }
      }

      char v136 = 1;
LABEL_119:
      if ((v136 & 1) != 0)
      {
        uint64_t v62 = 0LL;
        *(void *)&v63[1] = 0LL;
        break;
      }

      *(void *)&v63[1] = _dispatch_thread_getspecific(0x14uLL);
    }

    while ((*(void *)(**(void **)&v63[1] + 16LL) & 0x10000LL) != 0 || (v63[0] & 1) == 0);
    if ((v67 & 0x40000) == 0)
    {
      unsigned int v139 = v59;
      unsigned int v138 = 0;
      unsigned int v138 = _dispatch_thread_getspecific(0x19uLL);
      v139 &= 0xFFF0FFFF;
      v139 |= v138 & 0xF0000;
      _dispatch_thread_setspecific(25LL, v139);
    }
  }

  if ((v63[0] & 1) != 0)
  {
    int v140 = v64;
    BOOL v185 = v64;
    unsigned int v190 = 772079660;
    unint64_t v189 = v64;
    uint64_t v188 = 0LL;
    uint64_t v187 = 0LL;
    uint64_t v186 = 0LL;
    if (MEMORY[0xFFFFFC100]) {
      kdebug_trace(v190, v189, v188, v187, v186);
    }
    unint64_t v191 = v140;
  }

  if (*(void *)&v63[1]) {
    _dispatch_queue_invoke_finish(v64, v68, *(uint64_t (****)())&v63[1], v62);
  }
  else {
    _dispatch_release_2_tailcall(v64);
  }
  if ((a3 & 0x100000) != 0)
  {
    int v54 = _dispatch_thread_getspecific(0x1BuLL);
    uint64_t v53 = v54[6];
    if (v53)
    {
      if (*(_BYTE *)(v53 + 6)) {
        _dispatch_event_loop_drain_timers(v54[6], 6u, v36, v37, v38, v39, v40, v41);
      }
    }
  }

uint64_t _dispatch_source_invoke2(uint64_t a1, uint64_t a2, unsigned int a3, void *a4)
{
  uint64_t v32 = 0LL;
  uint64_t v31 = (uint64_t (***)())_dispatch_thread_getspecific(0x14uLL);
  uint64_t v30 = *(void *)(a1 + 88);
  BOOL v24 = 0;
  if ((a3 & 0x40000) == 0)
  {
    unint64_t v44 = _dispatch_thread_getspecific(0x1DuLL);
    if (v44) {
      uint64_t v45 = v44[3];
    }
    else {
      uint64_t v45 = -4LL;
    }
    unint64_t v42 = *(void *)(v30 + 16) & 0xFFFFFFFFFFFFFFFCLL;
    BOOL v23 = 0;
    if (v42)
    {
      BOOL v23 = 0;
      if (v42 != -4LL) {
        BOOL v23 = v42 != v45;
      }
    }

    BOOL v24 = v23;
  }

  if (v24) {
    _dispatch_source_handle_wlh_change(a1, v4, v5, v6, v7, v8, v9, v10);
  }
  if (*(void *)(a1 + 48))
  {
    int v35 = a3 | 0x4000000;
    uint64_t v32 = _dispatch_lane_serial_drain(a1, a2, v35, a4, v7, v8, v9, v10);
    a3 = v35 & 0xFBFFFFFF;
  }

  uint64_t v28 = &_dispatch_mgr_q;
  BOOL v27 = 0;
  if ((*(_BYTE *)(v30 + 29) & 1) != 0) {
    uint64_t v28 = *(uint64_t (****)())(a1 + 24);
  }
  if ((*(_WORD *)(a1 + 116) & 1) == 0)
  {
    if (v31 != v28) {
      return (uint64_t)v28;
    }
    unsigned int v26 = 0x2000000;
    if ((a3 & 0x10000) != 0) {
      unsigned int v26 = _dispatch_thread_getspecific(0x19uLL);
    }
    int v43 = _dispatch_thread_getspecific(0x1DuLL);
    if (v43) {
      _dispatch_source_install(a1, v43[3], v26, v11, v12, v13, v14, v15);
    }
    else {
      _dispatch_source_install(a1, -4LL, v26, v11, v12, v13, v14, v15);
    }
  }

  if ((*(void *)(a1 + 56) & 0xFF80000000000000LL) != 0) {
    return *(void *)(a1 + 24);
  }
  BOOL v22 = 0;
  if ((*(_BYTE *)(v30 + 29) & 2) != 0) {
    BOOL v22 = *(void *)(v30 + 104) != 0LL;
  }
  if (v22 && (*(_DWORD *)(a1 + 80) & 0x10800000) == 0)
  {
    if (v31 != v28) {
      return (uint64_t)v28;
    }
    _dispatch_timer_unote_configure(*(void *)(a1 + 88));
  }

  if (*(void *)(v30 + 56))
  {
    _dispatch_source_registration_callout(a1, (uint64_t)v31, a3);
  }

  if ((*(void *)(v30 + 16) & 2) != 0) {
    _dispatch_source_refs_unregister(a1, 5u, v5, v6, v7, v8, v9, v10);
  }
  int v29 = *(_DWORD *)(a1 + 80);
  if ((v29 & 0x10800000) == 0 && *(void *)(v30 + 72))
  {
    _dispatch_source_latch_and_call(a1, (uint64_t)v31, a3, v6, v7, v8, v9, v10);
    int v29 = *(_DWORD *)(a1 + 80);
    if ((v29 & 0x90000000) == 0)
    {
      BOOL v21 = 1;
      if (!v31[3]) {
        BOOL v21 = *((_DWORD *)v31 + 21) >= 0;
      }
      BOOL v27 = v21;
    }

    *(_WORD *)(a1 + 116) = *(_WORD *)(a1 + 116) & 0xFFFD | 2;
  }

  if ((v29 & 0x10800000) == 0 || v29 < 0) {
    goto LABEL_61;
  }
  if (((*(_BYTE *)(v30 + 29) & 2) == 0 || (*(void *)(v30 + 16) & 1) != 0) && v31 != v28) {
    return (uint64_t)v28;
  }
  unsigned int v25 = 1;
  if ((v29 & 0x40000000) == 0) {
    unsigned int v25 = 3;
  }
  _dispatch_source_refs_unregister(a1, v25, v5, v6, v7, v8, v9, v10);
  int v29 = *(_DWORD *)(a1 + 80);
  if (v29 < 0)
  {
LABEL_61:
    if ((v29 & 0x10800000) != 0 && v29 < 0)
    {
      if (v31 != *(uint64_t (****)())(a1 + 24)
        && (*(void *)(v30 + 40) || *(void *)(v30 + 48) || *(void *)(v30 + 56)))
      {
        uint64_t v32 = *(void *)(a1 + 24);
      }

      else
      {
        _dispatch_source_cancel_callout(a1, (uint64_t)v31, a3);
        int v29 = *(_DWORD *)(a1 + 80);
      }

      BOOL v27 = 0;
    }

    if ((v29 & 0x10800000) == 0)
    {
      if ((*(_BYTE *)(v30 + 29) & 2) != 0)
      {
        if (*(void *)(v30 + 104))
        {
          BOOL v39 = 1;
        }

        else
        {
          uint64_t v40 = *(void *)(v30 + 16);
          BOOL v18 = 0;
          if (v40)
          {
            BOOL v18 = 0;
            if ((v40 & 1) == 0) {
              BOOL v18 = (v40 & 2) == 0;
            }
          }

          BOOL v39 = v18 && *(void *)(v30 + 80) < 0x7FFFFFFFFFFFFFFFuLL;
        }
      }

      else
      {
        uint64_t v41 = *(void *)(v30 + 16);
        BOOL v19 = 0;
        if (v41)
        {
          BOOL v19 = 0;
          if ((v41 & 1) == 0) {
            BOOL v19 = (v41 & 2) == 0;
          }
        }

        BOOL v39 = v19;
      }

      if (v39)
      {
        if (v31 != v28) {
          return (uint64_t)v28;
        }
        if ((*(void *)(a1 + 56) & 0xFF80000000000000LL) != 0) {
          return *(void *)(a1 + 24);
        }
        if ((*(_BYTE *)(v30 + 29) & 1) != 0 && (*(void *)(v30 + 16) & 0xFFFFFFFFFFFFFFFCLL) == 0xFFFFFFFFFFFFFFFCLL)
        {
          if (((*(_WORD *)(a1 + 116) >> 1) & 1) != 0)
          {
            *(_WORD *)(a1 + 116) &= ~2u;
            _dispatch_unote_resume(v30, v4, v5, v6, v7, v8, v9, v10);
          }

          if (v27) {
            return *(void *)(a1 + 24);
          }
        }

        else
        {
          _dispatch_unote_resume(v30, v4, v5, v6, v7, v8, v9, v10);
          if (!v27)
          {
            unsigned int v46 = _dispatch_thread_getspecific(0x1DuLL);
            BOOL v17 = 0;
            if (_dispatch_thread_getspecific(5uLL))
            {
              BOOL v17 = 0;
              if (v46)
              {
                BOOL v17 = 0;
                if (v46[3] != -4LL) {
                  BOOL v17 = (*(void *)(v30 + 16) & 0xFFFFFFFFFFFFFFFCLL) == v46[3];
                }
              }
            }

            if (v17) {
              _dispatch_event_loop_drain(1u);
            }
          }
        }
      }
    }

    return v32;
  }

  if (v32) {
    return v32;
  }
  else {
    return -1LL;
  }
}

void _dispatch_source_wakeup( uint64_t a1, unsigned int a2, unsigned int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v13 = *(void *)(a1 + 88);
  uint64_t v12 = &_dispatch_mgr_q;
  *(_DWORD *)&v11[8] = 0;
  *(void *)uint64_t v11 = *(unsigned int *)(a1 + 80);
  if ((*(_BYTE *)(v13 + 29) & 1) != 0) {
    uint64_t v12 = (uint64_t (***)())(&dword_0 + 1);
  }
  if ((*(_WORD *)(a1 + 116) & 1) != 0)
  {
    if ((*(_DWORD *)v11 & 0x10800000) != 0) {
      goto LABEL_55;
    }
    BOOL v10 = 0;
    if ((*(_BYTE *)(v13 + 29) & 2) != 0) {
      BOOL v10 = *(void *)(v13 + 104) != 0LL;
    }
    if (!v10)
    {
LABEL_55:
      if (*(void *)(v13 + 56))
      {
        *(void *)&v11[4] = 1LL;
      }

      else if ((*(void *)(v13 + 16) & 2LL) != 0)
      {
        *(void *)&v11[4] = 1LL;
      }

      else if ((*(_DWORD *)v11 & 0x10800000) != 0 || !*(void *)(v13 + 72))
      {
        if ((*(_DWORD *)v11 & 0x10800000) != 0 && *(int *)v11 >= 0)
        {
          if ((*(_BYTE *)(v13 + 29) & 2) == 0 || (*(void *)(v13 + 16) & 1LL) != 0)
          {
            if ((*(_DWORD *)v11 & 0x40000000) == 0 || (a3 & 0x10) != 0) {
              *(void *)&v11[4] = v12;
            }
          }

          else
          {
            *(void *)&v11[4] = 1LL;
          }
        }

        else if ((*(_DWORD *)v11 & 0x10800000) != 0 {
               && *(int *)v11 < 0
        }
               && (*(void *)(v13 + 40) || *(void *)(v13 + 48) || *(void *)(v13 + 56)))
        {
          *(void *)&v11[4] = 1LL;
        }

        else if ((*(_DWORD *)v11 & 0x10800000) == 0)
        {
          if ((*(_BYTE *)(v13 + 29) & 2) != 0)
          {
            if (*(void *)(v13 + 104))
            {
              BOOL v14 = 1;
            }

            else
            {
              uint64_t v15 = *(void *)(v13 + 16);
              BOOL v8 = 0;
              if (v15)
              {
                BOOL v8 = 0;
                if ((v15 & 1) == 0) {
                  BOOL v8 = (v15 & 2) == 0;
                }
              }

              BOOL v14 = v8 && *(void *)(v13 + 80) < 0x7FFFFFFFFFFFFFFFuLL;
            }
          }

          else
          {
            uint64_t v16 = *(void *)(v13 + 16);
            BOOL v9 = 0;
            if (v16)
            {
              BOOL v9 = 0;
              if ((v16 & 1) == 0) {
                BOOL v9 = (v16 & 2) == 0;
              }
            }

            BOOL v14 = v9;
          }

          if (v14) {
            *(void *)&v11[4] = v12;
          }
        }
      }

      else
      {
        *(void *)&v11[4] = 1LL;
      }
    }

    else
    {
      *(void *)&v11[4] = v12;
    }
  }

  else
  {
    *(void *)&v11[4] = v12;
  }

  if (!*(void *)&v11[4]) {
    *(void *)&v11[4] = *(void *)(a1 + 48) != 0LL;
  }
  _dispatch_queue_wakeup((_DWORD *)a1, a2, a3, *(uint64_t *)&v11[4], a5, a6, a7, a8);
}

void dispatch_source_cancel(dispatch_source_t source)
{
  unsigned int v10 = *((_DWORD *)source + 20);
  do
  {
    unsigned int v7 = v10;
    BOOL v8 = (unsigned int *)((char *)source + 80);
    do
      unsigned int v9 = __ldaxr(v8);
    while (v9 == v10 && __stlxr(v10 | 0x10000000, v8));
    unsigned int v10 = v9;
  }

  while (v9 != v7);
  if ((v9 & 0x10000000) != 0) {
    _dispatch_release_2_tailcall((unsigned int *)source);
  }
  else {
    (*(void (**)(dispatch_source_t, void, uint64_t))(*(void *)source + 64LL))(source, 0LL, 3LL);
  }
}

void dispatch_source_cancel_and_wait( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v36 = *(void *)(a1 + 88);
  if (*(void *)(v36 + 48))
  {
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Source has a cancel handler";
    qword_E4DA8 = a1;
    __break(1u);
    JUMPOUT(0x640F4LL);
  }

  _dispatch_object_debug(a1, "%s", a3, a4, a5, a6, a7, a8, (char)"dispatch_source_cancel_and_wait");
  unint64_t v34 = (unsigned int *)(a1 + 80);
  while (1)
  {
    unsigned int v8 = _os_atomic_mo_has_acquire(0) ? __ldaxr(v34) : __ldxr(v34);
    __int16 v38 = HIWORD(v8);
    unsigned int v37 = v8 | 0x10000000;
    if ((v8 & 0x20000000) != 0) {
      break;
    }
    if ((v8 & 0x80000000) == 0
      && ((v8 & 0x40000000) != 0 || (*(_BYTE *)(v36 + 29) & 2) != 0 || (*(_BYTE *)(v36 + 29) & 1) == 0))
    {
      unsigned int v37 = v8 | 0x30000000;
    }

    if (_os_atomic_mo_has_release(0)) {
      BOOL v35 = __stlxr(v37, v34) == 0;
    }
    else {
      BOOL v35 = __stxr(v37, v34) == 0;
    }
    if (v35) {
      goto LABEL_18;
    }
  }

  __clrex();
LABEL_18:
  if ((v38 & 0x80) != 0)
  {
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Dispatch source used after last release";
    qword_E4DA8 = a1;
    __break(1u);
    JUMPOUT(0x642B0LL);
  }

  if ((v38 & 0x8000u) == 0)
  {
    if ((v37 & 0x20000000) != 0) {
      goto LABEL_51;
    }
    unint64_t v33 = (unint64_t)_dispatch_thread_getspecific(3uLL) & 0xFFFFFFFC | 0x60000000000000LL;
    int v29 = (unint64_t *)(a1 + 56);
    while (1)
    {
      if (_os_atomic_mo_has_acquire(5)) {
        unint64_t v15 = __ldaxr(v29);
      }
      else {
        unint64_t v15 = __ldxr(v29);
      }
      unint64_t v32 = v15;
      BOOL v26 = 0;
      if (!(v15 >> 53)) {
        BOOL v26 = (v15 & 0xFFFFFFFC) == 0;
      }
      if (v26)
      {
        unint64_t v31 = v15 & 0x7700000001LL | v33;
      }

      else
      {
        if ((v38 & 0x1000) != 0)
        {
          __clrex();
LABEL_37:
          if ((v32 & 0xFF80000000000000LL) != 0)
          {
            if (v32 >> 58)
            {
              qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Source is suspended";
              qword_E4DA8 = a1;
              __break(1u);
              JUMPOUT(0x644D8LL);
            }

            dispatch_activate((dispatch_object_t)a1);
            return;
          }

          BOOL v25 = 0;
          if (!(v32 >> 53)) {
            BOOL v25 = (v32 & 0xFFFFFFFC) == 0;
          }
          if (v25)
          {
            (*(void (**)(uint64_t, void, uint64_t))(*(void *)a1 + 64LL))(a1, 0LL, 20LL);
LABEL_55:
            unsigned int v28 = *(_DWORD *)(a1 + 80);
            do
            {
LABEL_56:
              if (HIBYTE(v28) >> 7) {
                return;
              }
              if (((HIBYTE(v28) >> 5) & 1) != 0) {
                goto LABEL_65;
              }
              unsigned int v27 = v28;
              BOOL v22 = (unsigned int *)(a1 + 80);
              do
                unsigned int v23 = __ldaxr(v22);
              while (v23 == v28 && __stlxr(v28 | 0x20000000, v22));
              BOOL v24 = v23 == v28;
              if (v23 != v28) {
                unsigned int v27 = v23;
              }
              unsigned int v28 = v27;
            }

            while (!v24);
            unsigned int v28 = v27 | 0x20000000;
LABEL_65:
            _dispatch_wait_on_address(a1 + 80, v28, -1LL, 0LL, v16, v17, v18, v19);
            unsigned int v28 = *(_DWORD *)(a1 + 80);
            goto LABEL_56;
          }

          if (((v32 ^ _dispatch_thread_getspecific(3uLL)) & 0xFFFFFFFC) == 0)
          {
            qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: dispatch_source_cancel_and_wait called from a source handler";
            qword_E4DA8 = a1;
            __break(1u);
            JUMPOUT(0x6468CLL);
          }

LABEL_51:
          unint64_t v40 = ((unint64_t)_dispatch_thread_getspecific(4uLL) & 0x3FFF00) >> 8;
          unsigned int v20 = __clz(__rbit32(v40));
          if ((_DWORD)v40) {
            unsigned int v21 = v20 + 1;
          }
          else {
            unsigned int v21 = 0;
          }
          (*(void (**)(uint64_t, void, uint64_t))(*(void *)a1 + 64LL))(a1, v21, 2LL);
          dispatch_activate((dispatch_object_t)a1);
          goto LABEL_55;
        }

        unint64_t v31 = v15 | 0x8000000000LL;
      }

      if (_os_atomic_mo_has_release(5)) {
        BOOL v30 = __stlxr(v31, v29) == 0;
      }
      else {
        BOOL v30 = __stxr(v31, v29) == 0;
      }
      if (v30) {
        goto LABEL_37;
      }
    }
  }

void _dispatch_source_refs_unregister( uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if ((_dispatch_unote_unregister(*(void *)(a1 + 88), a2, v8, v9, v10, v11, v12, v13) & 1) != 0)
  {
    _dispatch_source_refs_finalize_unregistration((unsigned int *)a1);
  }

  else
  {
    unint64_t v15 = (unsigned int *)(a1 + 80);
    while (1)
    {
      unsigned int v14 = _os_atomic_mo_has_acquire(0) ? __ldaxr(v15) : __ldxr(v15);
      if ((v14 & 0xC0000000) != 0) {
        break;
      }
      unsigned int v17 = v14 | 0x40000000;
      if (_os_atomic_mo_has_release(0)) {
        BOOL v16 = __stlxr(v17, v15) == 0;
      }
      else {
        BOOL v16 = __stxr(v17, v15) == 0;
      }
      if (v16) {
        return;
      }
    }

    __clrex();
  }

void _dispatch_source_cancel_callout(uint64_t a1, uint64_t a2, int a3)
{
  unsigned int v17 = *(unint64_t **)(a1 + 88);
  uint64_t v16 = 0LL;
  if ((a3 & 0x1000000) != 0) {
    uint64_t v16 = _dispatch_autorelease_pool_push();
  }
  unint64_t v15 = v17[6];
  do
  {
    unint64_t v3 = v15;
    unsigned int v14 = v17 + 6;
    do
      unint64_t v4 = __ldaxr(v14);
    while (v4 == v15 && __stlxr(0LL, v14));
    uint64_t v13 = (void *)v4;
    unint64_t v15 = v4;
  }

  while (v4 != v3);
  v17[9] = 0LL;
  v17[8] = 0LL;
  uint64_t v12 = v17[5];
  do
  {
    uint64_t v5 = v12;
    uint64_t v11 = v17 + 5;
    do
      uint64_t v6 = __ldaxr(v11);
    while (v6 == v12 && __stlxr(0LL, v11));
    uint64_t v12 = v6;
  }

  while (v6 != v5);
  if (v6) {
    _dispatch_source_handler_dispose(v6);
  }
  uint64_t v10 = v17[7];
  do
  {
    uint64_t v7 = v10;
    uint64_t v9 = v17 + 7;
    do
      uint64_t v8 = __ldaxr(v9);
    while (v8 == v10 && __stlxr(0LL, v9));
    uint64_t v10 = v8;
  }

  while (v8 != v7);
  if (v8) {
    _dispatch_source_handler_dispose(v8);
  }
  if (v13)
  {
    if ((*(_DWORD *)(a1 + 80) & 0x10000000) != 0)
    {
      if ((*v13 & 0x40LL) != 0) {
        v13[5] = *(void *)(a1 + 32);
      }
      _dispatch_continuation_pop(v13, 0LL, a3 & 0xFEFFFFFF, a2);
    }

    else
    {
      _dispatch_source_handler_dispose((uint64_t)v13);
    }
  }

  if (v16) {
    _dispatch_autorelease_pool_pop(v16);
  }
}

uint64_t _dispatch_source_merge_evt( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned __int8 v27 = BYTE1(a2);
  int v26 = a4;
  BOOL v25 = (unsigned int *)~*(void *)(a1 + 8);
  if ((a2 & 0x100) == 0 && !*(void *)(a1 + 16) && (*(_BYTE *)(a1 + 29) & 2) == 0) {
    _dispatch_source_refs_finalize_unregistration(v25);
  }
  if (((v27 >> 1) & 1) != 0)
  {
    if ((v25[20] & 0x4000000) != 0)
    {
      uint64_t v8 = *(unsigned int *)(a1 + 24);
      qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Unexpected EV_VANISHED (do not destroy random mach ports or f"
                             "ile descriptors)";
      qword_E4DA8 = v8;
      __break(1u);
      JUMPOUT(0x64F40LL);
    }

    _dispatch_bug_kevent_vanished(a1, a2, a3, a4, a5, a6, a7, a8);
    *(void *)(a1 + 72) = 0LL;
  }

  _dispatch_thread_getspecific(0LL);
  _dispatch_log("%u\t%p\tkevent-source[%p]: merged kevent[%p]", v9, v10, v11, v12, v13, v14, v15, 1201LL);
  _dispatch_object_debug((uint64_t)v25, "%s", v16, v17, v18, v19, v20, v21, (char)"_dispatch_source_merge_evt");
  unint64_t v29 = (unint64_t)(v26 & 0x3FFF00) >> 8;
  unsigned int v22 = __clz(__rbit32(v29));
  if ((_DWORD)v29) {
    uint64_t v23 = v22 + 1;
  }
  else {
    uint64_t v23 = 0LL;
  }
  return (*(uint64_t (**)(unsigned int *, uint64_t, uint64_t))(*(void *)v25 + 64LL))(v25, v23, 51LL);
}

uint64_t _dispatch_interval_config_create(uint64_t a1, unint64_t a2, unint64_t a3, uint64_t a4)
{
  BOOL v9 = (*(_BYTE *)(a4 + 30) & 0x20) != 0;
  uint64_t v8 = _dispatch_calloc(1LL, 32LL);
  *(_DWORD *)(v8 + 24) = 0;
  if (a1 == -1)
  {
    *(void *)uint64_t v8 = 0x7FFFFFFFFFFFFFFFLL;
    *(void *)(v8 + 16) = 0x7FFFFFFFFFFFFFFFLL;
    *(void *)(v8 + 8) = 0x7FFFFFFFFFFFFFFFLL;
    return v8;
  }

  else
  {
    if (a1)
    {
      qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Start value is not DISPATCH_TIME_NOW or DISPATCH_TIME_FOREVER";
      __break(1u);
      JUMPOUT(0x65110LL);
    }

    if (!a2)
    {
      qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Setting interval to 0";
      __break(1u);
      JUMPOUT(0x65148LL);
    }

    unint64_t v4 = 1892160075LL;
    if (!v9) {
      unint64_t v4 = 31536000000LL;
    }
    if (a2 > v4)
    {
      unint64_t v13 = 31536000000000000LL;
    }

    else
    {
      uint64_t v5 = 1000000LL;
      if (v9) {
        uint64_t v5 = 16666666LL;
      }
      unint64_t v13 = a2 * v5;
    }

    if (_dispatch_host_time_nano2mach)
    {
      unint64_t v18 = _dispatch_host_time_nano2mach(v13);
    }

    else if (v13)
    {
      if (v13 < 0x7FFFFFFFFFFFFFFFLL)
      {
        if (v13 >= 0x5555555555555555LL)
        {
          unint64_t v18 = 3 * (v13 / 0x7D);
        }

        else
        {
          uint64_t v6 = (3 * v13 * (unsigned __int128)0x624DD2F1A9FBE77uLL) >> 64;
          unint64_t v18 = (v6 + ((3 * v13 - v6) >> 1)) >> 6;
        }
      }

      else
      {
        unint64_t v18 = 0x7FFFFFFFFFFFFFFFLL;
      }
    }

    else
    {
      unint64_t v18 = 0LL;
    }

    uint64_t v15 = (_dispatch_uptime() + v18) / v18 * v18;
    if (a3 > 0x3E8)
    {
      if (a3 != -1LL)
      {
        qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Passing an invalid leeway";
        __break(1u);
        JUMPOUT(0x6534CLL);
      }

      if (v9)
      {
        if (_dispatch_host_time_nano2mach) {
          unint64_t v17 = _dispatch_host_time_nano2mach(16666666LL);
        }
        else {
          unint64_t v17 = (unint64_t)(((0x2FAF07E * (unsigned __int128)0x624DD2F1A9FBE77uLL) >> 64)
        }
                                 + ((unint64_t)(49999998
                                                     - ((0x2FAF07E * (unsigned __int128)0x624DD2F1A9FBE77uLL) >> 64)) >> 1)) >> 6;
        unint64_t v11 = v17;
      }

      else
      {
        unint64_t v11 = v18 >> 1;
      }
    }

    else
    {
      unint64_t v11 = v18 * a3 / 0x3E8;
    }

    *(_DWORD *)(v8 + 24) = 0;
    *(void *)uint64_t v8 = v15;
    *(void *)(v8 + 8) = v15 + v11;
    *(void *)(v8 + 16) = v18;
    return v8;
  }

uint64_t _dispatch_timer_config_create(uint64_t a1, unint64_t a2, int64_t a3, uint64_t a4)
{
  uint64_t v19 = a1;
  unint64_t v18 = a2;
  int64_t v17 = a3;
  uint64_t v16 = a4;
  uint64_t v15 = _dispatch_calloc(1LL, 32LL);
  if (v18)
  {
    if ((v18 & 0x8000000000000000LL) != 0LL) {
      unint64_t v18 = 0x7FFFFFFFFFFFFFFFLL;
    }
  }

  else
  {
    if (v19 != -1) {
      _dispatch_bug_deprecated( (uint64_t)"Setting timer interval to 0 requests a 1ns timer, did you mean FOREVER (a one-shot timer)?",  v4,  v5,  v6,  v7,  v8,  v9,  v10);
    }
    unint64_t v18 = 1LL;
  }

  if (v17 < 0) {
    int64_t v17 = 0x7FFFFFFFFFFFFFFFLL;
  }
  int v14 = 0;
  uint64_t v13 = 0LL;
  if (v19 == -1)
  {
    uint64_t v13 = 0x7FFFFFFFFFFFFFFFLL;
    int v14 = _dispatch_timer_flags_to_clock(*(_BYTE *)(v16 + 30));
  }

  else
  {
    uint64_t v28 = v19;
    char v27 = 1;
    int v26 = &v14;
    BOOL v25 = &v13;
    unint64_t v24 = 0LL;
    if (v19 == 0x8000000000000000LL)
    {
      *int v26 = 1;
      *BOOL v25 = _dispatch_monotonic_time();
    }

    else if (v19 == -2)
    {
      *int v26 = 2;
      *BOOL v25 = _dispatch_get_nanoseconds();
    }

    else if (v19)
    {
      if (v28 >= 0)
      {
        *int v26 = 0;
        unint64_t v24 = v28;
      }

      else if ((v28 & 0x4000000000000000LL) != 0)
      {
        *int v26 = 2;
        unint64_t v24 = -v28;
      }

      else
      {
        *int v26 = 1;
        unint64_t v24 = v28 & 0x7FFFFFFFFFFFFFFFLL;
      }

      if (v24 <= 0x3FFFFFFFFFFFFFFFLL) {
        uint64_t v12 = v24;
      }
      else {
        uint64_t v12 = -1LL;
      }
      *BOOL v25 = v12;
    }

    else
    {
      *int v26 = 0;
      *BOOL v25 = _dispatch_uptime();
    }
  }

  if (v14 != 2)
  {
    unint64_t v22 = v18;
    if (_dispatch_host_time_nano2mach)
    {
      unint64_t v23 = _dispatch_host_time_nano2mach(v22);
    }

    else if (v22)
    {
      if (v22 < 0x7FFFFFFFFFFFFFFFLL)
      {
        if (v22 < 0x5555555555555555LL) {
          unint64_t v23 = 3 * v22 / 0x7D;
        }
        else {
          unint64_t v23 = 3 * (v22 / 0x7D);
        }
      }

      else
      {
        unint64_t v23 = 0x7FFFFFFFFFFFFFFFLL;
      }
    }

    else
    {
      unint64_t v23 = 0LL;
    }

    unint64_t v18 = v23;
    if (!v23) {
      unint64_t v18 = 1LL;
    }
    unint64_t v20 = v17;
    if (_dispatch_host_time_nano2mach)
    {
      unint64_t v21 = _dispatch_host_time_nano2mach(v20);
    }

    else if (v20)
    {
      if (v20 < 0x7FFFFFFFFFFFFFFFLL)
      {
        if (v20 < 0x5555555555555555LL) {
          unint64_t v21 = 3 * v20 / 0x7D;
        }
        else {
          unint64_t v21 = 3 * (v20 / 0x7D);
        }
      }

      else
      {
        unint64_t v21 = 0x7FFFFFFFFFFFFFFFLL;
      }
    }

    else
    {
      unint64_t v21 = 0LL;
    }

    int64_t v17 = v21;
  }

  if (v18 < 0x7FFFFFFFFFFFFFFFLL && v17 > v18 / 2) {
    int64_t v17 = v18 / 2;
  }
  *(_DWORD *)(v15 + 24) = v14;
  *(void *)uint64_t v15 = v13;
  *(void *)(v15 + 16) = v18;
  else {
    *(void *)(v15 + 8) = v13 + v17;
  }
  return v15;
}

void dispatch_after_f(dispatch_time_t when, dispatch_queue_t queue, void *context, dispatch_function_t work)
{
  dispatch_time_t v48 = when;
  dispatch_queue_t queuea = queue;
  contexta = context;
  blocuint64_t k = work;
  char v44 = 0;
  uint64_t v43 = 0LL;
  dispatch_source_t v42 = 0LL;
  unint64_t v41 = 0LL;
  unint64_t v40 = 0LL;
  if (when == -1LL)
  {
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: dispatch_after called with 'when' == infinity";
    __break(1u);
    JUMPOUT(0x65A88LL);
  }

  unint64_t v40 = _dispatch_timeout(v48, (uint64_t)queue, (uint64_t)context, (uint64_t)work, v4, v5, v6, v7);
  if (v40)
  {
    unint64_t v41 = _dispatch_after_leeway(v40);
    if (v41 <= 0xF423F) {
      unint64_t v41 = 1000000LL;
    }
    if (v41 >= 0xDF8475801LL) {
      unint64_t v41 = 60000000000LL;
    }
    dispatch_source_t v42 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_after, 0LL, 0LL, queuea);
    uint64_t v43 = *((void *)v42 + 11);
    BOOL v39 = 0LL;
    BOOL v49 = 0LL;
    unsigned int v58 = _dispatch_thread_getspecific(0x16uLL);
    if (v58) {
      _dispatch_thread_setspecific(22LL, v58[2]);
    }
    BOOL v49 = v58;
    if (v58) {
      unsigned int v50 = v49;
    }
    else {
      unsigned int v50 = (void *)_dispatch_continuation_alloc_from_heap();
    }
    BOOL v39 = v50;
    dispatch_queue_t v38 = queuea;
    dispatch_queue_t v57 = queuea;
    __int128 v56 = v50;
    int v55 = contexta;
    dispatch_block_t v54 = block;
    uint64_t v53 = 0LL;
    uint64_t v52 = 0LL;
    uint64_t v51 = 0LL;
    *unsigned int v50 = 256LL;
    v56[4] = v54;
    v56[5] = v55;
    if ((v53 & 0x40000000) == 0)
    {
      int v73 = 1;
      int v76 = _dispatch_thread_getspecific(4uLL);
      int v77 = v76;
      unint64_t v74 = v76 & 0xFFFFFF;
      int v81 = 5;
      uint64_t v80 = 4096LL;
      if (v74 <= 0x10FF)
      {
        uint64_t v75 = v74;
      }

      else
      {
        int v79 = 5;
        uint64_t v78 = 4096LL;
        uint64_t v75 = 4351LL;
      }

      uint64_t v51 = v75;
    }

    uint64_t v61 = v56;
    uint64_t v60 = v53;
    unsigned int v59 = 0LL;
    BOOL v63 = (int)v53 >= 0;
    uint64_t v62 = 583LL;
    if ((v60 & 0x40) == 0)
    {
      BOOL v82 = _dispatch_thread_getspecific(0x1CuLL);
      if (v82)
      {
        uint64_t v92 = v82;
        os_retain(v82);
      }

      unsigned int v59 = v82;
    }

    v61[3] = v59;
    _dispatch_thread_getspecific(0LL);
    _dispatch_log("%u\t%p\tvoucher[%p]: continuation[%p] set", v14, v15, v16, v17, v18, v19, v20, 589LL);
    uint64_t v21 = v61[3];
    int v86 = 771817476;
    uint64_t v85 = v21;
    uint64_t v84 = v61;
    if (v21 != -1)
    {
      unsigned int v83 = 0;
      unsigned int v30 = v85 ? *(_DWORD *)(v85 + 32) : 0;
      unsigned int v83 = v30;
      unsigned int v91 = v86;
      uint64_t v90 = v30;
      uint64_t v89 = v84;
      uint64_t v88 = 0LL;
      uint64_t v87 = 0LL;
      if (MEMORY[0xFFFFFC100]) {
        kdebug_trace(v91, v90, v89, v88, v87);
      }
    }

    dispatch_queue_t v72 = v57;
    unsigned int v71 = v56;
    unint64_t v70 = v51;
    uint64_t v69 = v53;
    unsigned int v68 = 0;
    dispatch_queue_t v67 = v57;
    if (v51)
    {
      BOOL v66 = (v69 & 0x20) != 0;
      BOOL v65 = 0;
      BOOL v65 = (*((_DWORD *)v67 + 21) & 0x40000000) != 0;
      BOOL v64 = 0;
      BOOL v64 = (*((_DWORD *)v67 + 21) & 0xFFF) != 0;
      if ((v69 & 0x20) != 0)
      {
        v70 |= 0x10000000uLL;
        unint64_t v93 = v70 >> 8;
        unsigned int v22 = v70 >> 8;
        unsigned int v23 = __clz(__rbit32(v22));
        if (v22) {
          unsigned int v24 = v23 + 1;
        }
        else {
          unsigned int v24 = 0;
        }
        unsigned int v68 = v24;
      }

      else if (v65 || !v64)
      {
        unint64_t v94 = v70 >> 8;
        unsigned int v25 = v70 >> 8;
        unsigned int v26 = __clz(__rbit32(v25));
        if (v25) {
          unsigned int v27 = v26 + 1;
        }
        else {
          unsigned int v27 = 0;
        }
        unsigned int v68 = v27;
      }

      else
      {
        unint64_t v70 = 0LL;
      }
    }

    v71[1] = v70;
    v39[6] = v42;
    dispatch_queue_t v37 = queuea;
    uint64_t v36 = v39;
    dispatch_queue_t v105 = queuea;
    int v104 = v39;
    int v103 = 0;
    int v102 = 0;
    dispatch_queue_t v107 = queuea;
    int v106 = v39;
    BOOL v35 = v39;
    unint64_t v34 = v39;
    *(void *)(v43 + 4_dispatch_source_set_handler((uint64_t)source, handler, 2LL, 0) = v39;
    unint64_t v33 = v35;
    int v32 = 0;
    uint64_t v31 = 0LL;
    dispatch_time_t v101 = v48;
    char v100 = 0;
    unsigned int v99 = &v32;
    unsigned int v98 = &v31;
    unint64_t v97 = 0LL;
    if ((v48 & 0x8000000000000000LL) != 0)
    {
      if ((v101 & 0x4000000000000000LL) != 0)
      {
        *unsigned int v99 = 2;
        unint64_t v97 = -(uint64_t)v101;
      }

      else
      {
        *unsigned int v99 = 1;
        unint64_t v97 = v101 & 0x7FFFFFFFFFFFFFFFLL;
      }
    }

    else
    {
      *unsigned int v99 = 0;
      unint64_t v97 = v101;
    }

    if (v97 >> 62) {
      uint64_t v29 = -1LL;
    }
    else {
      uint64_t v29 = v97;
    }
    *unsigned int v98 = v29;
    if (v32 != 2)
    {
      unint64_t v95 = v41;
      if (_dispatch_host_time_nano2mach)
      {
        unint64_t v96 = _dispatch_host_time_nano2mach(v95);
      }

      else if (v95)
      {
        if (v95 < 0x7FFFFFFFFFFFFFFFLL)
        {
          if (v95 >= 0x5555555555555555LL)
          {
            unint64_t v96 = 3 * (v95 / 0x7D);
          }

          else
          {
            uint64_t v28 = (3 * v95 * (unsigned __int128)0x624DD2F1A9FBE77uLL) >> 64;
            unint64_t v96 = (v28 + ((3 * v95 - v28) >> 1)) >> 6;
          }
        }

        else
        {
          unint64_t v96 = 0x7FFFFFFFFFFFFFFFLL;
        }
      }

      else
      {
        unint64_t v96 = 0LL;
      }

      unint64_t v41 = v96;
    }

    *(_BYTE *)(v43 + 30) |= _dispatch_timer_flags_from_clock(v32);
    *(void *)(v43 + 8_dispatch_source_set_handler((uint64_t)source, handler, 2LL, 0) = v31;
    *(void *)(v43 + 96) = -1LL;
    *(void *)(v43 + 88) = v31 + v41;
    dispatch_activate(v42);
  }

  else
  {
    dispatch_channel_async_f(queuea, contexta, (dispatch_function_t)block);
  }

void dispatch_after(dispatch_time_t when, dispatch_queue_t queue, dispatch_block_t block)
{
  dispatch_time_t v48 = when;
  dispatch_queue_t queuea = queue;
  context = 0LL;
  dispatch_block_t blocka = block;
  char v44 = 1;
  uint64_t v43 = 0LL;
  dispatch_source_t v42 = 0LL;
  unint64_t v41 = 0LL;
  unint64_t v40 = 0LL;
  if (when == -1LL)
  {
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: dispatch_after called with 'when' == infinity";
    __break(1u);
    JUMPOUT(0x66C40LL);
  }

  unint64_t v40 = _dispatch_timeout(v48, (uint64_t)queue, (uint64_t)block, v3, v4, v5, v6, v7);
  if (v40)
  {
    unint64_t v41 = _dispatch_after_leeway(v40);
    if (v41 <= 0xF423F) {
      unint64_t v41 = 1000000LL;
    }
    if (v41 >= 0xDF8475801LL) {
      unint64_t v41 = 60000000000LL;
    }
    dispatch_source_t v42 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_after, 0LL, 0LL, queuea);
    uint64_t v43 = *((void *)v42 + 11);
    BOOL v39 = 0LL;
    BOOL v49 = 0LL;
    BOOL v66 = (uint64_t *)_dispatch_thread_getspecific(0x16uLL);
    if (v66) {
      _dispatch_thread_setspecific(22LL, v66[2]);
    }
    BOOL v49 = v66;
    if (v66) {
      unsigned int v50 = v49;
    }
    else {
      unsigned int v50 = (uint64_t *)_dispatch_continuation_alloc_from_heap();
    }
    BOOL v39 = v50;
    dispatch_queue_t v38 = queuea;
    dispatch_queue_t v57 = (unsigned int *)queuea;
    __int128 v56 = v50;
    dispatch_block_t v55 = blocka;
    uint64_t v54 = 0LL;
    uint64_t v52 = _dispatch_Block_copy(blocka);
    uint64_t v53 = 272LL;
    dispatch_block_t v67 = blocka;
    if ((void (*)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))_Block_get_invoke_fn((uint64_t)blocka) == ___dispatch_block_create_block_invoke)
    {
      *__int128 v56 = v53;
      v56[5] = (uint64_t)v52;
      int inited = _dispatch_continuation_init_slow(v56, v57, v54);
    }

    else
    {
      uint64_t v51 = _Block_get_invoke_fn((uint64_t)v55);
      BOOL v65 = v57;
      BOOL v64 = v56;
      uint64_t v63 = (uint64_t)v52;
      uint64_t v62 = v51;
      uint64_t v61 = v54;
      uint64_t v60 = v53;
      uint64_t v59 = 0LL;
      *__int128 v56 = v53 | 0x100;
      v64[4] = v62;
      v64[5] = v63;
      if ((v61 & 0x40000000) == 0)
      {
        int v82 = 1;
        uint64_t v85 = _dispatch_thread_getspecific(4uLL);
        int v86 = v85;
        unint64_t v83 = v85 & 0xFFFFFF;
        int v90 = 5;
        uint64_t v89 = 4096LL;
        if (v83 <= 0x10FF)
        {
          uint64_t v84 = v83;
        }

        else
        {
          int v88 = 5;
          uint64_t v87 = 4096LL;
          uint64_t v84 = 4351LL;
        }

        uint64_t v59 = v84;
      }

      unint64_t v70 = v64;
      uint64_t v69 = v61;
      uint64_t v68 = 0LL;
      BOOL v72 = (int)v61 >= 0;
      uint64_t v71 = 583LL;
      if ((v69 & 0x40) == 0)
      {
        unsigned int v91 = _dispatch_thread_getspecific(0x1CuLL);
        if (v91)
        {
          object = v91;
          os_retain(v91);
        }

        uint64_t v68 = (uint64_t)v91;
      }

      v70[3] = v68;
      _dispatch_thread_getspecific(0LL);
      _dispatch_log("%u\t%p\tvoucher[%p]: continuation[%p] set", v14, v15, v16, v17, v18, v19, v20, 589LL);
      uint64_t v21 = v70[3];
      int v95 = 771817476;
      uint64_t v94 = v21;
      unint64_t v93 = v70;
      if (v21 != -1)
      {
        unsigned int v92 = 0;
        unsigned int v30 = v94 ? *(_DWORD *)(v94 + 32) : 0;
        unsigned int v92 = v30;
        unsigned int v100 = v95;
        uint64_t v99 = v30;
        unsigned int v98 = v93;
        uint64_t v97 = 0LL;
        uint64_t v96 = 0LL;
        if (MEMORY[0xFFFFFC100]) {
          kdebug_trace(v100, v99, v98, v97, v96);
        }
      }

      int v81 = v65;
      uint64_t v80 = v64;
      unint64_t v79 = v59;
      uint64_t v78 = v61;
      unsigned int v77 = 0;
      int v76 = v65;
      if (v59)
      {
        BOOL v75 = (v78 & 0x20) != 0;
        BOOL v74 = 0;
        BOOL v74 = (v76[21] & 0x40000000) != 0;
        BOOL v73 = 0;
        BOOL v73 = (v76[21] & 0xFFF) != 0;
        if ((v78 & 0x20) != 0)
        {
          v79 |= 0x10000000uLL;
          unint64_t v102 = v79 >> 8;
          unsigned int v22 = v79 >> 8;
          unsigned int v23 = __clz(__rbit32(v22));
          if (v22) {
            unsigned int v24 = v23 + 1;
          }
          else {
            unsigned int v24 = 0;
          }
          unsigned int v77 = v24;
        }

        else if (v74 || !v73)
        {
          unint64_t v103 = v79 >> 8;
          unsigned int v25 = v79 >> 8;
          unsigned int v26 = __clz(__rbit32(v25));
          if (v25) {
            unsigned int v27 = v26 + 1;
          }
          else {
            unsigned int v27 = 0;
          }
          unsigned int v77 = v27;
        }

        else
        {
          unint64_t v79 = 0LL;
        }
      }

      v80[1] = v79;
      int inited = v77;
    }

    v39[6] = (uint64_t)v42;
    dispatch_queue_t v37 = queuea;
    uint64_t v36 = v39;
    dispatch_queue_t v114 = queuea;
    unsigned int v113 = v39;
    int v112 = 0;
    int v111 = 0;
    dispatch_queue_t v116 = queuea;
    unint64_t v115 = v39;
    BOOL v35 = v39;
    unint64_t v34 = v39;
    *(void *)(v43 + 4_dispatch_source_set_handler((uint64_t)source, handler, 2LL, 0) = v39;
    unint64_t v33 = v35;
    int v32 = 0;
    uint64_t v31 = 0LL;
    dispatch_time_t v110 = v48;
    char v109 = 0;
    int v108 = &v32;
    dispatch_queue_t v107 = &v31;
    unint64_t v106 = 0LL;
    if ((v48 & 0x8000000000000000LL) != 0)
    {
      if ((v110 & 0x4000000000000000LL) != 0)
      {
        *int v108 = 2;
        unint64_t v106 = -(uint64_t)v110;
      }

      else
      {
        *int v108 = 1;
        unint64_t v106 = v110 & 0x7FFFFFFFFFFFFFFFLL;
      }
    }

    else
    {
      *int v108 = 0;
      unint64_t v106 = v110;
    }

    if (v106 >> 62) {
      uint64_t v29 = -1LL;
    }
    else {
      uint64_t v29 = v106;
    }
    *dispatch_queue_t v107 = v29;
    if (v32 != 2)
    {
      unint64_t v104 = v41;
      if (_dispatch_host_time_nano2mach)
      {
        unint64_t v105 = _dispatch_host_time_nano2mach(v104);
      }

      else if (v104)
      {
        if (v104 < 0x7FFFFFFFFFFFFFFFLL)
        {
          if (v104 >= 0x5555555555555555LL)
          {
            unint64_t v105 = 3 * (v104 / 0x7D);
          }

          else
          {
            uint64_t v28 = (3 * v104 * (unsigned __int128)0x624DD2F1A9FBE77uLL) >> 64;
            unint64_t v105 = (v28 + ((3 * v104 - v28) >> 1)) >> 6;
          }
        }

        else
        {
          unint64_t v105 = 0x7FFFFFFFFFFFFFFFLL;
        }
      }

      else
      {
        unint64_t v105 = 0LL;
      }

      unint64_t v41 = v105;
    }

    *(_BYTE *)(v43 + 30) |= _dispatch_timer_flags_from_clock(v32);
    *(void *)(v43 + 8_dispatch_source_set_handler((uint64_t)source, handler, 2LL, 0) = v31;
    *(void *)(v43 + 96) = -1LL;
    *(void *)(v43 + 88) = v31 + v41;
    dispatch_activate(v42);
  }

  else
  {
    dispatch_channel_async(queuea, blocka);
  }

void *_dispatch_source_handler_dispose(uint64_t a1)
{
  if ((*(void *)a1 & 0x10LL) != 0) {
    _Block_release(*(const void **)(a1 + 40));
  }
  if (*(void *)(a1 + 24))
  {
    os_release(*(void **)(a1 + 24));
    *(void *)(a1 + 24) = -1LL;
  }

  uint64_t result = _dispatch_thread_getspecific(0x16uLL);
  if (result) {
    int v2 = *((_DWORD *)result + 2) + 1;
  }
  else {
    int v2 = 1;
  }
  if (v2 <= _dispatch_continuation_cache_limit)
  {
    *(void *)(a1 + 16) = result;
    *(_DWORD *)(a1 + 8) = v2;
    uint64_t result = (void *)_dispatch_thread_setspecific(22LL, a1);
    uint64_t v4 = 0LL;
  }

  else
  {
    uint64_t v4 = (void *)a1;
  }

  if (v4) {
    return _dispatch_continuation_free_to_cache_limit(v4);
  }
  return result;
}

void *_dispatch_source_set_handler_slow(uint64_t a1)
{
  uint64_t result = _dispatch_thread_getspecific(0x14uLL);
  uint64_t v14 = result;
  if (*(void *)(*result + 16LL) != 275LL) {
    _dispatch_abort(323LL, *(void *)(*result + 16LL) == 275LL, v2, v3, v4, v5, v6, v7);
  }
  uint64_t v13 = *(void *)(a1 + 48);
  *(void *)(a1 + 48) = 0LL;
  unint64_t v16 = a1;
  if (*(void *)(a1 + 32))
  {
    if ((*(void *)a1 & 0x40LL) != 0) {
      *(void *)(a1 + 4_dispatch_source_set_handler((uint64_t)source, handler, 2LL, 0) = result[4];
    }
  }

  else
  {
    uint64_t result = _dispatch_thread_getspecific(0x16uLL);
    if (result) {
      int v12 = *((_DWORD *)result + 2) + 1;
    }
    else {
      int v12 = 1;
    }
    if (v12 <= _dispatch_continuation_cache_limit)
    {
      *(void *)(a1 + 16) = result;
      *(_DWORD *)(a1 + 8) = v12;
      uint64_t result = (void *)_dispatch_thread_setspecific(22LL, a1);
      uint64_t v17 = 0LL;
    }

    else
    {
      uint64_t v17 = (void *)a1;
    }

    if (v17) {
      uint64_t result = _dispatch_continuation_free_to_cache_limit(v17);
    }
    unint64_t v16 = 0LL;
  }

  uint64_t v10 = (unint64_t *)(v14[11] + 40LL + 8 * v13);
  unint64_t v11 = *v10;
  do
  {
    unint64_t v8 = v11;
    do
      uint64_t v9 = __ldaxr(v10);
    while (v9 == v11 && __stlxr(v16, v10));
    unint64_t v11 = v9;
  }

  while (v9 != v8);
  if (v9) {
    return _dispatch_source_handler_dispose(v9);
  }
  return result;
}

void _dispatch_source_handle_wlh_change( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10 = (unsigned int *)(a1 + 80);
  unsigned int v11 = *(_DWORD *)(a1 + 80);
  do
  {
    unsigned int v8 = v11;
    do
      unsigned int v9 = __ldaxr(v10);
    while (v9 == v11 && __stlxr(v11 | 0x8000000, v10));
    unsigned int v11 = v9;
  }

  while (v9 != v8);
  if ((v9 & 0x400000) == 0)
  {
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Changing target queue hierarchy after source was activated";
    __break(1u);
    JUMPOUT(0x6829CLL);
  }

  if ((v9 & 0x8000000) == 0) {
    _dispatch_bug_deprecated( (uint64_t)"Changing target queue hierarchy after source was activated",  a2,  a3,  a4,  a5,  a6,  a7,  a8);
  }
}

void _dispatch_source_registration_callout(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v7 = *(void *)(a1 + 88);
  unsigned int v8 = *(void **)(v7 + 56);
  do
  {
    uint64_t v3 = v8;
    uint64_t v4 = (unint64_t *)(v7 + 56);
    do
      uint64_t v5 = (void *)__ldaxr(v4);
    while (v5 == v8 && __stlxr(0LL, v4));
    uint64_t v6 = (uint64_t)v5;
    unsigned int v8 = v5;
  }

  while (v5 != v3);
  if ((*(_DWORD *)(a1 + 80) & 0x10800000) != 0)
  {
    uint64_t v9 = 0LL;
    if ((a3 & 0x1000000) != 0) {
      uint64_t v9 = _dispatch_autorelease_pool_push();
    }
    _dispatch_source_handler_dispose(v6);
    if (v9) {
      _dispatch_autorelease_pool_pop(v9);
    }
  }

  else
  {
    if ((*v5 & 0x40LL) != 0) {
      v5[5] = *(void *)(a1 + 32);
    }
    _dispatch_continuation_pop(v5, 0LL, a3, a2);
  }

void _dispatch_source_latch_and_call( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v23 = a3;
  uint64_t v22 = *(void *)(a1 + 88);
  uint64_t v21 = *(void **)(v22 + 40);
  uint64_t v17 = (unint64_t *)(v22 + 72);
  unint64_t v18 = *(void *)(v22 + 72);
  do
  {
    unint64_t v8 = v18;
    do
      unint64_t v9 = __ldaxr(v17);
    while (v9 == v18 && __stlxr(0LL, v17));
    unint64_t v18 = v9;
  }

  while (v9 != v8);
  unint64_t v20 = v9;
  int v16 = *(unsigned __int8 *)(*(void *)v22 + 9LL);
  if (v16 == 3)
  {
    *(void *)(v22 + 64) = ~v9;
  }

  else if (v16 == 5)
  {
    if ((v9 & 1) != 0)
    {
      unint64_t v27 = v9 >> 1;
      uint64_t v28 = *(void *)(a1 + 88);
      if (*(void *)(v28 + 80) < 0x7FFFFFFFFFFFFFFFuLL)
      {
        unsigned int v15 = *(_DWORD *)(v28 + 24) / 3u;
        if (v15) {
          uint64_t v29 = v15 == 1 ? _dispatch_monotonic_time() : _dispatch_get_nanoseconds();
        }
        else {
          uint64_t v29 = _dispatch_uptime();
        }
        if (v29 >= *(void *)(v28 + 80))
        {
          uint64_t v31 = (v29 - *(void *)(v28 + 80)) / *(void *)(v28 + 96) + 1;
          if (v31 + v27 > 0x7FFFFFFFFFFFFFFFLL) {
            uint64_t v31 = 0x7FFFFFFFFFFFFFFFLL - v27;
          }
          if (*(void *)(v28 + 96) >= 0x7FFFFFFFFFFFFFFFuLL)
          {
            *(void *)(v28 + 8_dispatch_source_set_handler((uint64_t)source, handler, 2LL, 0) = -1LL;
            *(void *)(v28 + 88) = -1LL;
          }

          else
          {
            uint64_t v30 = v31 * *(void *)(v28 + 96);
            *(void *)(v28 + 80) += v30;
            *(void *)(v28 + 88) += v30;
          }

          v27 += v31;
        }
      }

      *(void *)(v22 + 64) = v27;
    }

    else
    {
      *(void *)(v22 + 64) = v9 >> 1;
    }
  }

  else
  {
    *(void *)(v22 + 64) = v9;
  }

  if (v21)
  {
    if (v20)
    {
      if (*(char *)(v22 + 28) == -14)
      {
        uint64_t function_symbol = _dispatch_continuation_get_function_symbol((uint64_t)v21);
        if (MEMORY[0xFFFFFC100]) {
          kdebug_trace(67240961LL, v20, function_symbol, 0LL, 0LL);
        }
      }

      _dispatch_continuation_pop(v21, 0LL, v23, a2);
      if ((*(_BYTE *)(v22 + 29) & 2) != 0)
      {
        if ((v20 & 1) != 0)
        {
          BOOL v14 = 0;
          if ((*(_BYTE *)(v22 + 29) & 2) != 0) {
            BOOL v14 = *(void *)(v22 + 104) != 0LL;
          }
          if (v14) {
            _dispatch_timer_unote_configure(*(void *)(a1 + 88));
          }
        }

        if ((*(_BYTE *)(v22 + 30) & 0x40) != 0)
        {
          if (MEMORY[0xFFFFFC100]) {
            kdebug_trace(772079660LL, v21, 0LL, 0LL, 0LL);
          }
          uint64_t v19 = 0LL;
          if ((v23 & 0x1000000) != 0) {
            uint64_t v19 = _dispatch_autorelease_pool_push();
          }
          int v12 = (unint64_t *)(v22 + 40);
          uint64_t v13 = *(void *)(v22 + 40);
          do
          {
            uint64_t v10 = v13;
            do
              uint64_t v11 = __ldaxr(v12);
            while (v11 == v13 && __stlxr(0LL, v12));
            uint64_t v13 = v11;
          }

          while (v11 != v10);
          if (v11) {
            _dispatch_source_handler_dispose(v11);
          }
          if (v19) {
            _dispatch_autorelease_pool_pop(v19);
          }
          dispatch_release((dispatch_object_t)a1);
        }
      }
    }

    else
    {
      _dispatch_bug(586LL, v20 != 0, a3, a4, a5, a6, a7, a8);
    }
  }

  else if (MEMORY[0xFFFFFC100])
  {
    kdebug_trace(771883040LL, a1, 0LL, 0LL, 0LL);
  }

uint64_t _dispatch_monotonic_time()
{
  return mach_continuous_time();
}

__uint64_t _dispatch_get_nanoseconds()
{
  return clock_gettime_nsec_np(_CLOCK_REALTIME);
}

uint64_t _dispatch_trace_timer_function(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 40);
  if (v3) {
    return *(void *)(v3 + 32);
  }
  else {
    return 0LL;
  }
}

unint64_t _dispatch_after_leeway(unint64_t a1)
{
  unsigned int v1 = ((unint64_t)_dispatch_thread_getspecific(4uLL) & 0x3FFF00) >> 8;
  unsigned int v2 = __clz(__rbit32(v1));
  if (v1) {
    unsigned int v3 = v2 + 1;
  }
  else {
    unsigned int v3 = 0;
  }
  if (v3 <= 3) {
    return a1 / 0xA;
  }
  if (v3 == 5 || v3 == 4) {
    return a1 / 0xF;
  }
  else {
    return a1 / 0x14;
  }
}

uint64_t _dispatch_timer_flags_from_clock(char a1)
{
  return (4 * a1);
}

uint64_t _dispatch_wait_for_enqueuer(unint64_t *a1, uint64_t a2)
{
  int v5 = 10;
  while (1)
  {
    int v2 = v5--;
    if (v2 <= 0) {
      break;
    }
    unint64_t v3 = __ldxr(a1);
    if (v3)
    {
      __clrex();
      return v3;
    }

    __wfe();
  }

  return __DISPATCH_WAIT_FOR_ENQUEUER__((uint64_t)a1, a2);
}

uint64_t __DISPATCH_WAIT_FOR_ENQUEUER__(uint64_t a1, uint64_t a2)
{
  int v3 = 0;
  while (!*(void *)a1)
  {
    ++v3;
    _pthread_yield_to_enqueuer_4dispatch(122LL, a2);
  }

  return *(void *)a1;
}

void *dispatch_mach_hooks_install_4libxpc(void *result)
{
  if (*result <= 2uLL)
  {
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: trying to install hooks with unsupported version";
    qword_E4DA8 = (uint64_t)result;
    __break(1u);
    JUMPOUT(0x693E8LL);
  }

  do
    unsigned int v1 = (void *)__ldaxr((unint64_t *)&_dispatch_mach_xpc_hooks);
  while (v1 == &_dispatch_mach_xpc_hooks_default
       && __stlxr((unint64_t)result, (unint64_t *)&_dispatch_mach_xpc_hooks));
  if (v1 != &_dispatch_mach_xpc_hooks_default)
  {
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: dispatch_mach_hooks_install_4libxpc called twice";
    qword_E4DA8 = (uint64_t)_dispatch_mach_xpc_hooks;
    __break(1u);
    JUMPOUT(0x694E4LL);
  }

  return result;
}

void _dispatch_mach_hooks_install_default()
{
  _dispatch_mach_xpc_hooks = &_dispatch_mach_xpc_hooks_default;
}

uint64_t dispatch_mach_create(uint64_t a1, uint64_t (***a2)(), const void *a3)
{
  unint64_t v8 = _dispatch_Block_copy(a3);
  uint64_t v3 = _Block_get_invoke_fn((uint64_t)v8);
  return _dispatch_mach_create(a1, a2, (uint64_t)v8, v3, 1LL, v4, v5, v6);
}

uint64_t _dispatch_mach_create( uint64_t a1, uint64_t (***a2)(), uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  char v28 = a5;
  uint64_t v26 = (uint64_t)_dispatch_object_alloc((uint64_t)_OS_dispatch_mach_vtable, 0x88uLL, a3, a4, a5, a6, a7, a8);
  _dispatch_queue_init(v26, 0x400000, 1LL, 0x180000000000000LL, v8, v9, v10, v11);
  *(void *)(v26 + 72) = a1;
  *(_WORD *)(v26 + 116) = *(_WORD *)(v26 + 116) & 0xFFEF | (8 * (v28 & 2));
  *(_WORD *)(v26 + 116) = *(_WORD *)(v26 + 116) & 0xFF7F | (32 * (v28 & 4));
  uint64_t v27 = _dispatch_unote_create_without_handle((uint64_t)&_dispatch_mach_type_recv, 0LL, 0LL);
  if ((*(_BYTE *)(v27 + 29) & 1) == 0) {
    _dispatch_abort(131LL, 0LL, v12, v13, v14, v15, v16, v17);
  }
  *(void *)(v27 + 8) = ~v26;
  *(void *)(v27 + 4_dispatch_source_set_handler((uint64_t)source, handler, 2LL, 0) = a4;
  *(void *)(v27 + 48) = a3;
  *(_BYTE *)(v27 + 29) = *(_BYTE *)(v27 + 29) & 0xBF | ((v28 & 1) << 6);
  if ((*(_WORD *)(v26 + 116) & 0x80) != 0) {
    *(_DWORD *)(v27 + 32) |= 0x200u;
  }
  *(void *)(v26 + 88) = v27;
  uint64_t v25 = _dispatch_mach_send_create((uint64_t)&_dispatch_mach_type_send, 0LL, 9LL);
  *(void *)(v25 + 8) = ~v26;
  *(void *)(v26 + 1memset(__b, 0, 20) = v25;
  if (a2)
  {
    if ((*((_BYTE *)a2 + 87) & 8) != 0)
    {
      qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Cannot target object to cooperative root queue - not implemented";
      qword_E4DA8 = (uint64_t)a2;
      __break(1u);
      JUMPOUT(0x697D4LL);
    }

    _dispatch_retain((uint64_t)a2);
  }

  else
  {
    a2 = &off_E46C0;
  }

  *(void *)(v26 + 24) = a2;
  _dispatch_object_debug(v26, "%s", v18, v19, v20, v21, v22, v23, (char)"_dispatch_mach_create");
  return v26;
}

uint64_t dispatch_mach_create_f( uint64_t a1, uint64_t (***a2)(), uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return _dispatch_mach_create(a1, a2, a3, a4, 0LL, a6, a7, a8);
}

uint64_t dispatch_mach_create_4libxpc( uint64_t a1, uint64_t (***a2)(), uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return _dispatch_mach_create(a1, a2, a3, a4, 6LL, a6, a7, a8);
}

void _dispatch_mach_dispose( uint64_t *a1, _BYTE *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  a1[11] = 0LL;
  _dispatch_unote_dispose(a1[15]);
  a1[15] = 0LL;
  if (a1[16])
  {
    _dispatch_unote_dispose(a1[16]);
    a1[16] = 0LL;
  }

  _dispatch_lane_class_dispose((uint64_t)a1, a2);
}

uint64_t dispatch_mach_request_no_senders(uint64_t result)
{
  *(_WORD *)(result + 116) |= 0x20u;
  uint64_t v1 = *(void *)(result + 56);
  if ((~v1 & 0x180000000000000LL) != 0)
  {
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: dispatch queue/source property setter called after activation";
    qword_E4DA8 = v1;
    __break(1u);
    JUMPOUT(0x69A30LL);
  }

  return result;
}

uint64_t dispatch_mach_notify_no_senders(uint64_t result, char a2)
{
  *(_WORD *)(result + 116) |= 0x20u;
  *(_WORD *)(result + 116) = *(_WORD *)(result + 116) & 0xFFBF | ((a2 & 1) << 6);
  uint64_t v2 = *(void *)(result + 56);
  if ((~v2 & 0x180000000000000LL) != 0)
  {
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: dispatch queue/source property setter called after activation";
    qword_E4DA8 = v2;
    __break(1u);
    JUMPOUT(0x69B0CLL);
  }

  return result;
}

uint64_t dispatch_mach_set_flags(uint64_t result, char a2)
{
  *(_WORD *)(result + 116) = *(_WORD *)(result + 116) & 0xFF7F | ((a2 & 1) << 7);
  uint64_t v2 = *(void *)(result + 56);
  if ((~v2 & 0x180000000000000LL) != 0)
  {
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: dispatch queue/source property setter called after activation";
    qword_E4DA8 = v2;
    __break(1u);
    JUMPOUT(0x69BD8LL);
  }

  return result;
}

void dispatch_mach_connect( uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v12 = *(void *)(a1 + 120);
  if (a2 && a2 != -1) {
    *(_DWORD *)(*(void *)(a1 + 88) + 24LL) = a2;
  }
  *(_DWORD *)(v12 + 92) = a3;
  if ((_DWORD)a3 && (_DWORD)a3 != -1)
  {
    if (a4)
    {
      dispatch_retain((dispatch_object_t)a4);
      *(_DWORD *)(a4 + 48) = _dispatch_mach_checkin_options();
      *(_DWORD *)(v12 + 96) = _dispatch_mach_msg_get_remote_port(a4);
    }

    *(void *)(v12 + 48) = a4;
  }

  if ((*(_WORD *)(a1 + 116) & 0x20) != 0 && !*(void *)(v12 + 48)) {
    _dispatch_mach_arm_no_senders(a1, 0);
  }
  uint64_t v10 = (unsigned int *)(v12 + 88);
  unsigned int v11 = *(_DWORD *)(v12 + 88);
  do
  {
    unsigned int v8 = v11;
    do
      unsigned int v9 = __ldaxr(v10);
    while (v9 == v11 && __stlxr(v11 & 0x7FFFFFFF, v10));
    unsigned int v11 = v9;
  }

  while (v9 != v8);
  if (!(HIBYTE(v9) >> 7))
  {
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Channel already connected";
    qword_E4DA8 = v9;
    __break(1u);
    JUMPOUT(0x69DF0LL);
  }

  _dispatch_object_debug(a1, "%s", a3, a4, a5, a6, a7, a8, (char)"dispatch_mach_connect");
  dispatch_activate((dispatch_object_t)a1);
}

uint64_t _dispatch_mach_checkin_options()
{
  return 0x40000LL;
}

uint64_t _dispatch_mach_msg_get_remote_port(uint64_t a1)
{
  return *(unsigned int *)(_dispatch_mach_msg_get_msg(a1) + 8);
}

void _dispatch_mach_arm_no_senders(uint64_t a1, char a2)
{
  kern_return_t v14;
  kern_return_t v15;
  mach_port_t previous;
  mach_port_name_t v17;
  char v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v19 = a1;
  uint64_t v18 = a2;
  uint64_t v17 = 0;
  uint64_t v17 = *(_DWORD *)(*(void *)(a1 + 88) + 24LL);
  previous = 0;
  if (v17 && v17 != -1)
  {
    uint64_t v14 = mach_port_request_notification( mach_task_self_,  v17,  70,  ((*(unsigned __int16 *)(v19 + 116) >> 6) & 1) == 0,  v17,  0x15u,  &previous);
    if (v14 == -301)
    {
      qword_E4D78 = (uint64_t)"MIG_REPLY_MISMATCH";
      qword_E4DA8 = -301LL;
      __break(1u);
      JUMPOUT(0x69F88LL);
    }

    uint64_t v23 = v14;
    uint64_t v22 = 252LL;
    if (v14) {
      _dispatch_bug(v22, v23, v2, v3, v4, v5, v6, v7);
    }
  }

  if (previous)
  {
    if ((v18 & 1) == 0)
    {
      qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Mach port notification collision";
      qword_E4DA8 = previous;
      __break(1u);
      JUMPOUT(0x6A02CLL);
    }

    uint64_t v15 = mach_port_deallocate(mach_task_self_, previous);
    if (v15 == -301)
    {
      qword_E4D78 = (uint64_t)"MIG_REPLY_MISMATCH";
      qword_E4DA8 = -301LL;
      __break(1u);
      JUMPOUT(0x6A098LL);
    }

    uint64_t v21 = v15;
    uint64_t v20 = 260LL;
    if (v15) {
      _dispatch_bug(v20, v21, v8, v9, v10, v11, v12, v13);
    }
  }

void _dispatch_mach_merge_msg( uint64_t a1, unsigned int a2, mach_msg_header_t *a3, unsigned int a4, _DWORD *a5, uint64_t a6, uint64_t a7)
{
  if ((a2 & 0x200) != 0)
  {
    uint64_t v7 = *(unsigned int *)(a1 + 24);
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Unexpected EV_VANISHED (do not destroy random mach ports)";
    qword_E4DA8 = v7;
    __break(1u);
    JUMPOUT(0x6A16CLL);
  }

  _dispatch_thread_getspecific(0LL);
  _dispatch_log( "%u\t%p\tmachport[0x%08x]: received msg id 0x%x, reply on 0x%08x",  v8,  v9,  v10,  v11,  v12,  v13,  v14,  676LL);
  unint64_t v41 = (unsigned int *)~*(void *)(a1 + 8);
  if (((HIBYTE(*(_DWORD *)(79LL - *(void *)(a1 + 8))) >> 4) & 1) != 0)
  {
    _dispatch_thread_getspecific(0LL);
    _dispatch_log( "%u\t%p\tmachport[0x%08x]: drop msg id 0x%x, reply on 0x%08x",  v17,  v18,  v19,  v20,  v21,  v22,  v23,  681LL);
    mach_msg_destroy(a3);
    if ((a2 & 0x10000) != 0) {
      free(a3);
    }
  }

  else if (a3->msgh_id == 70 && (*(_WORD *)(115LL - *(void *)(a1 + 8)) & 0x20) != 0)
  {
    BOOL is_kernel = _dispatch_mach_msg_sender_is_kernel((uint64_t)a3);
    if (is_kernel)
    {
      unsigned int v50 = _dispatch_thread_getspecific(0x16uLL);
      if (v50)
      {
        _dispatch_thread_setspecific(22LL, v50[2]);
        BOOL v49 = v50;
      }

      else
      {
        BOOL v49 = (void *)_dispatch_continuation_alloc_from_heap();
      }

      *BOOL v49 = 260LL;
      v49[4] = _dispatch_mach_no_senders_invoke;
      v49[5] = v41;
      v49[3] = 0LL;
      _dispatch_thread_getspecific(0LL);
      _dispatch_log("%u\t%p\tvoucher[%p]: continuation[%p] set", v30, v31, v32, v33, v34, v35, v36, 589LL);
      uint64_t v51 = v49[3];
      if (v51 != -1)
      {
        unsigned int v38 = v51 ? *(_DWORD *)(v51 + 32) : 0;
        if (MEMORY[0xFFFFFC100]) {
          kdebug_trace(771817476LL, v38, v49, 0LL, 0LL);
        }
      }

      v49[1] = 0LL;
      (*(void (**)(unsigned int *, void *, void))(*(void *)v41 + 72LL))(v41, v49, 0LL);
    }

    else
    {
      _dispatch_bug(687LL, is_kernel, v24, v25, v26, v27, v28, v29);
    }

    mach_msg_destroy(a3);
    if ((a2 & 0x10000) != 0) {
      free(a3);
    }
  }

  else
  {
    recv = (dispatch_object_s *)_dispatch_mach_msg_create_recv(a3, a4, a5, 0LL, a2, a6, v15, v16);
    _dispatch_mach_handle_or_push_received_msg((uint64_t)v41, recv, a7);
  }

  BOOL v37 = 1;
  if ((*(void *)(a1 + 16) & 2) == 0) {
    BOOL v37 = (((unint64_t)v41[15] << 32) & 0x180000000000000LL) == 0x80000000000000LL;
  }
  if (v37) {
    (*(void (**)(unsigned int *, void, uint64_t))(*(void *)v41 + 64LL))(v41, 0LL, 51LL);
  }
  else {
    _dispatch_release_2_tailcall(v41);
  }
}

uint64_t _dispatch_mach_no_senders_invoke(uint64_t result)
{
  if ((*(_DWORD *)(result + 80) & 0x10000000) == 0) {
    return _dispatch_client_callout4( *(void *)(*(void *)(result + 88) + 48LL),  13LL,  0LL,  0,  *(uint64_t (**)(uint64_t, uint64_t, uint64_t, void))(*(void *)(result + 88) + 40LL));
  }
  return result;
}

void *_dispatch_mach_msg_create_recv( _DWORD *a1, unsigned int a2, _DWORD *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v34 = a5;
  int v32 = a6;
  if (a4)
  {
    unsigned int v41 = (*a1 & 0x1F0000u) >> 16;
    mach_port_name_t v40 = a1[4];
    if ((v41 == 19 || v41 == 17) && v40)
    {
      _dispatch_thread_getspecific(0LL);
      _dispatch_log("%u\t%p\tkvoucher[0x%08x]: msg[%p] clear %s", v8, v9, v10, v11, v12, v13, v14, 520LL);
      if (v41 == 17) {
        _voucher_dealloc_mach_voucher(v40);
      }
      a1[4] = 0;
      *a1 &= 0xFFE0FFFF;
    }

    uint64_t v33 = *(unsigned int *)(a4 + 40);
    uint64_t v30 = *(void **)(a4 + 56);
    *(void *)(a4 + 56) = 0LL;
  }

  else
  {
    uint64_t v30 = _voucher_create_with_mach_msgv(a1, a3, (uint64_t)a3, 0LL, a5, a6, a7, a8);
    if ((v32 & 0xFFFFFFu) <= 0x10FFuLL) {
      uint64_t v38 = v32 & 0xFFFFFF;
    }
    else {
      uint64_t v38 = 4351LL;
    }
    uint64_t v33 = v38;
  }

  uint64_t v31 = dispatch_mach_msg_create((uint64_t)a1, a2, (v34 & 0x10000) != 0, 0LL, a5, a6, a7, a8);
  if ((v34 & 0x10000) == 0 && MEMORY[0xFFFFFC100]) {
    kdebug_trace(771948548LL, a1, v31 + 11, 0LL, 0LL);
  }
  v31[8] = v30;
  v31[7] = v33;
  if (a4) {
    uint64_t v29 = *(void *)(a4 + 48);
  }
  else {
    uint64_t v29 = 0LL;
  }
  v31[4] = v29;
  _dispatch_mach_msg_set_reason((uint64_t)v31, 0, 2LL, v15, v16, v17, v18, v19);
  _dispatch_thread_getspecific(0LL);
  _dispatch_log("%u\t%p\tvoucher[%p]: mach-msg[%p] create", v20, v21, v22, v23, v24, v25, v26, 646LL);
  uint64_t v39 = v31[8];
  if (v39 != -1)
  {
    if (v39) {
      unsigned int v28 = *(_DWORD *)(v39 + 32);
    }
    else {
      unsigned int v28 = 0;
    }
    if (MEMORY[0xFFFFFC100]) {
      kdebug_trace(771817484LL, v28, v31, 0LL, 0LL);
    }
  }

  return v31;
}

void _dispatch_mach_handle_or_push_received_msg(uint64_t a1, dispatch_object_s *a2, uint64_t a3)
{
  uint64_t v15 = a1;
  uint64_t v14 = a2;
  uint64_t v13 = a3;
  unsigned int v12 = 0;
  uint64_t reason = _dispatch_mach_msg_get_reason((uint64_t)a2, (int *)&v12);
  if (reason != 2
    && ((*(_WORD *)(v15 + 116) >> 4) & 1) != 0
    && ((*(uint64_t (**)(void, uint64_t, dispatch_object_s *, void))((char *)&dword_8
                                                                                + (void)_dispatch_mach_xpc_hooks))( *(void *)(*(void *)(v15 + 88) + 48LL),  reason,  v14,  v12) & 1) != 0)
  {
    *((void *)v14 + 2) = -1985229329LL;
    dispatch_release(v14);
  }

  else
  {
    uint64_t v19 = v15;
    uint64_t v18 = v14;
    int v17 = 0;
    int v16 = 0;
    uint64_t v23 = v15;
    uint64_t v22 = v14;
    unint64_t v20 = v13 & 0x3FFF00;
    v20 >>= 8;
    unsigned int v8 = __clz(__rbit32(v20));
    if ((_DWORD)v20) {
      unsigned int v9 = v8 + 1;
    }
    else {
      unsigned int v9 = 0;
    }
    unsigned int v10 = v9;
    if (!v9)
    {
      unsigned int v21 = *(_DWORD *)(v15 + 84);
      v21 &= 0xF00u;
      unsigned int v10 = v21 >> 8;
    }

    _dispatch_lane_push(v15, v14, v10, v3, v4, v5, v6, v7);
  }

void _dispatch_mach_reply_merge_msg( uint64_t a1, unsigned int a2, mach_msg_header_t *a3, unsigned int a4, _DWORD *a5, uint64_t a6, uint64_t a7)
{
  uint64_t v39 = ~*(void *)(a1 + 8);
  BOOL v38 = (*(_DWORD *)(79LL - *(void *)(a1 + 8)) & 0x10000000) != 0;
  recv = 0LL;
  _dispatch_thread_getspecific(0LL);
  _dispatch_log( "%u\t%p\tmachport[0x%08x]: received msg id 0x%x, reply on 0x%08x",  v7,  v8,  v9,  v10,  v11,  v12,  v13,  737LL);
  if (!v38) {
    recv = (dispatch_object_s *)_dispatch_mach_msg_create_recv(a3, a4, a5, a1, a2, a6, v14, v15);
  }
  if (recv)
  {
    uint64_t v36 = 0LL;
    if (((*(_WORD *)(v39 + 116) >> 4) & 1) != 0 && *((void *)recv + 4))
    {
      uint64_t v47 = (*(uint64_t (**)(void))((char *)&dword_10 + (void)_dispatch_mach_xpc_hooks))(*((void *)recv + 4));
      if (!v47) {
        uint64_t v47 = v39;
      }
      uint64_t v36 = v47;
    }

    if (v36)
    {
      dispatch_time_t v48 = _dispatch_mach_msg_async_reply_wrap((uint64_t)recv, v39);
      unsigned int v19 = (*((void *)recv + 7) & 0x3FFF00uLL) >> 8;
      unsigned int v20 = __clz(__rbit32(v19));
      if (v19) {
        uint64_t v21 = v20 + 1;
      }
      else {
        uint64_t v21 = 0LL;
      }
      (*(void (**)(uint64_t, void *, uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)v36 + 72LL))( v36,  v48,  v21,  v16,  v17,  v18);
    }

    else
    {
      _dispatch_mach_handle_or_push_received_msg(v39, recv, a7);
    }
  }

  else
  {
    _dispatch_thread_getspecific(0LL);
    _dispatch_log( "%u\t%p\tmachport[0x%08x]: drop msg id 0x%x, reply on 0x%08x",  v28,  v29,  v30,  v31,  v32,  v33,  v34,  755LL);
    mach_msg_destroy(a3);
    if ((a2 & 0x10000) != 0) {
      free(a3);
    }
  }

  char v35 = 101;
  if (v38) {
    char v35 = 117;
  }
  if ((*(void *)(a1 + 16) & 2) == 0) {
    _dispatch_abort(765LL, (*(void *)(a1 + 16) & 2) != 0, v22, v23, v24, v25, v26, v27);
  }
  _dispatch_mach_reply_unregister((unsigned int *)v39, a1, v35);
}

void _dispatch_mach_reply_unregister(unsigned int *a1, uint64_t a2, char a3)
{
  BOOL v49 = *(void *)a2 == -2LL;
  uint64_t v48 = *((void *)a1 + 15);
  BOOL v47 = (a3 & 0x10) != 0;
  char v46 = 0;
  _dispatch_thread_getspecific(0LL);
  _dispatch_log("%u\t%p\tmachport[0x%08x]: unregistering for%s reply%s, ctxt %p", v3, v4, v5, v6, v7, v8, v9, 355LL);
  if ((a3 & 0x20) != 0)
  {
    unsigned int v55 = _dispatch_thread_getspecific(3uLL) & 0xFFFFFFFC;
    uint64_t v23 = (unsigned int *)(v48 + 40);
    do
      unsigned int v24 = __ldaxr(v23);
    while (!v24 && __stlxr(v55, v23));
    if (v24) {
      _dispatch_unfair_lock_lock_slow((unsigned int *)(v48 + 40), 0x10000);
    }
    _dispatch_mach_reply_list_remove_locked(a2, v16, v17, v18, v19, v20, v21, v22);
    if (!*(void *)(v48 + 56) && *(_DWORD *)(v48 + 88)) {
      char v46 = 1;
    }
    unsigned int v56 = _dispatch_thread_getspecific(3uLL) & 0xFFFFFFFC;
    dispatch_source_t v42 = (unsigned int *)(v48 + 40);
    unsigned int v43 = *(_DWORD *)(v48 + 40);
    do
    {
      unsigned int v25 = v43;
      do
        unsigned int v26 = __ldaxr(v42);
      while (v26 == v43 && __stlxr(0, v42));
      unsigned int v43 = v26;
    }

    while (v26 != v25);
    if (v26 != v56) {
      _dispatch_unfair_lock_unlock_slow(v48 + 40, v26);
    }
  }

  if (!*(void *)(a2 + 16) || (_dispatch_unote_unregister(a2, a3 & 0xF, v10, v11, v12, v13, v14, v15) & 1) != 0)
  {
    reply_disconnected = 0LL;
    uint64_t v44 = 0LL;
    if (v47)
    {
      if (((*((_WORD *)a1 + 58) >> 4) & 1) != 0 && *(void *)(a2 + 48))
      {
        uint64_t v53 = (*(uint64_t (**)(void))((char *)&dword_10 + (void)_dispatch_mach_xpc_hooks))(*(void *)(a2 + 48));
        if (!v53) {
          uint64_t v53 = (uint64_t)a1;
        }
        uint64_t v44 = v53;
      }

      if (v44) {
        uint64_t v29 = 12LL;
      }
      else {
        uint64_t v29 = 7LL;
      }
      reply_disconnected = (dispatch_object_s *)_dispatch_mach_msg_create_reply_disconnected( 0LL,  a2,  v29,  v11,  v12,  v13,  v14,  v15);
      if (*(void *)(a2 + 56)) {
        _dispatch_abort(387LL, *(void *)(a2 + 56) == 0LL, v30, v31, v32, v33, v34, v35);
      }
    }

    else if (*(void *)(a2 + 56))
    {
      os_release(*(void **)(a2 + 56));
      *(void *)(a2 + 56) = 0LL;
    }

    if (!v49) {
      _dispatch_unote_dispose(a2);
    }
    if (reply_disconnected)
    {
      if (v44)
      {
        uint64_t v54 = _dispatch_mach_msg_async_reply_wrap((uint64_t)reply_disconnected, (uint64_t)a1);
        unsigned int v39 = (*((void *)reply_disconnected + 7) & 0x3FFF00uLL) >> 8;
        unsigned int v40 = __clz(__rbit32(v39));
        if (v39) {
          uint64_t v41 = v40 + 1;
        }
        else {
          uint64_t v41 = 0LL;
        }
        (*(void (**)(uint64_t, void *, uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)v44 + 72LL))( v44,  v54,  v41,  v36,  v37,  v38);
      }

      else
      {
        _dispatch_mach_handle_or_push_received_msg((uint64_t)a1, reply_disconnected, 0LL);
      }
    }

    if ((a3 & 0x40) != 0)
    {
      if ((v46 & 1) != 0) {
        (*(void (**)(unsigned int *, void, uint64_t))(*(void *)a1 + 64LL))(a1, 0LL, 3LL);
      }
      else {
        _dispatch_release_2_tailcall(a1);
      }
    }
  }

  else
  {
    if (v49) {
      _dispatch_abort(368LL, !v49, v27, v11, v12, v13, v14, v15);
    }
    if (a3 < 0)
    {
      uint64_t v28 = *(void *)(v48 + 56);
      *(void *)(a2 + 64) = v28;
      if (v28) {
        *(void *)(*(void *)(v48 + 56) + 72LL) = a2 + 64;
      }
      *(void *)(v48 + 56) = a2;
      *(void *)(a2 + 72) = v48 + 56;
    }
  }

uint64_t _dispatch_mach_send_barrier_drain_invoke(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v47 = a1;
  uint64_t v46 = a2;
  int v45 = a3;
  unsigned int v43 = _dispatch_thread_getspecific(0x14uLL);
  uint64_t v48 = v43;
  BOOL v49 = v43;
  dispatch_source_t v42 = v43;
  uint64_t v44 = (uint64_t)v43;
  uint64_t v41 = 516LL;
  __int128 v40 = 0uLL;
  unsigned int v50 = &v40;
  _dispatch_thread_getspecific_pair(0x14uLL, (void **)&v40, 0x15uLL, (pthread_key_t *)&v40 + 1, v3, v4, v5, v6);
  unsigned int v77 = (_OWORD *)*((void *)v50 + 1);
  _dispatch_thread_setspecific_packed_pair(20LL, 21LL, v77, v7, v8, v9, v10, v11);
  uint64_t v39 = v47;
  __int16 v37 = v41;
  uint64_t v54 = v47;
  uint64_t v53 = v41;
  uint64_t v52 = 0LL;
  uint64_t v52 = *(_DWORD **)(v47 + 24);
  uint64_t v51 = v41 & 4;
  uint64_t v56 = 1LL;
  uint64_t v55 = 600LL;
  if ((v41 & 4) != 0) {
    *(void *)(v54 + 24) = -1LL;
  }
  if (v52 != (_DWORD *)-1LL)
  {
    int v70 = 771817480;
    uint64_t v69 = v52;
    uint64_t v68 = v54;
    unsigned int v67 = 0;
    if (v52) {
      unsigned int v36 = v69[8];
    }
    else {
      unsigned int v36 = 0;
    }
    unsigned int v67 = v36;
    unsigned int v75 = v70;
    uint64_t v74 = v36;
    uint64_t v73 = v68;
    uint64_t v72 = 0LL;
    uint64_t v71 = 0LL;
    if (MEMORY[0xFFFFFC100]) {
      kdebug_trace(v75, v74, v73, v72, v71);
    }
    _dispatch_thread_getspecific(0LL);
    _dispatch_log("%u\t%p\tvoucher[%p]: continuation[%p] adopt", v18, v19, v20, v21, v22, v23, v24, 607LL);
  }

  unint64_t v81 = *(void *)(v54 + 8);
  uint64_t v80 = (uint64_t)v52;
  uint64_t v79 = v51 | 2;
  uint64_t v78 = 0LL;
  if (v81 != -1LL)
  {
    unint64_t v88 = v81;
    uint64_t v87 = v79;
    unsigned int v86 = 0;
    unsigned int v86 = _dispatch_thread_getspecific(0x19uLL);
    uint64_t v85 = 0LL;
    unsigned int v101 = v86;
    unsigned int v104 = v86 & 0xF00;
    unsigned int v100 = v104 >> 8;
    uint64_t v99 = v86;
    if (v104 >> 8) {
      v99 |= 1LL << (v100 + 7);
    }
    uint64_t v85 = v99;
    uint64_t v102 = v99;
    unint64_t v84 = v99 & 0xFFFFFF00;
    BOOL v83 = 0;
    BOOL v35 = 1;
    if ((v87 & 1) == 0) {
      BOOL v35 = (v88 & 0x10000000) != 0;
    }
    BOOL v83 = v35;
    unint64_t v90 = v88;
    v88 &= 0xFFFFFFu;
    if (v88)
    {
      if (v88 >= v84)
      {
        if (v83 || (v86 & 0x44000000) != 0) {
          uint64_t v89 = v88;
        }
        else {
          uint64_t v89 = v85;
        }
      }

      else
      {
        uint64_t v89 = v85;
      }
    }

    else
    {
      unsigned int v103 = v86 & 0xF000;
      unsigned int v82 = v103 >> 12;
      if (v103 >> 12)
      {
        unsigned int v92 = v82;
        uint64_t v91 = 1LL << (v82 + 7);
        uint64_t v34 = v91 | 0xFF;
      }

      else
      {
        uint64_t v34 = v85;
      }

      uint64_t v89 = v34;
    }

    uint64_t v78 = v89;
  }

  uint64_t v96 = v78;
  uint64_t v95 = v80;
  uint64_t v94 = v79;
  uint64_t v108 = v78;
  BOOL v111 = v78 != -1;
  uint64_t v110 = 2395LL;
  if (v78 == -1) {
    _dispatch_abort(v110, v111, v12, v13, v14, v15, v16, v17);
  }
  if ((_dispatch_set_qos_class_enabled & 1) != 0)
  {
    uint64_t v122 = v108;
    uint64_t v121 = 4261412863LL;
    uint64_t v120 = 0LL;
    v108 &= 0xFFFFFFFF02FFFFFFLL;
    unint64_t v107 = 0LL;
    int v112 = 0LL;
    int v112 = _dispatch_thread_getspecific(4uLL);
    unint64_t v107 = (unint64_t)v112;
    uint64_t v106 = 0x1000000LL;
    uint64_t v105 = 2281701376LL;
    if ((v112 & 0x1000000) != 0)
    {
      if (v108)
      {
        uint64_t v33 = v108;
      }

      else
      {
        unint64_t v116 = v107;
        uint64_t v115 = v106;
        uint64_t v114 = 0LL;
        uint64_t v33 = v107 & (~v106 | 0xFFFFFF);
      }

      uint64_t v109 = v33;
    }

    else
    {
      unint64_t v119 = v107;
      uint64_t v118 = v105;
      uint64_t v117 = 0LL;
      v107 &= ~v105 | 0xFFFFFF;
      if (v108 == v107) {
        uint64_t v109 = 0LL;
      }
      else {
        uint64_t v109 = v108;
      }
    }
  }

  else
  {
    uint64_t v109 = 0LL;
  }

  uint64_t v96 = v109;
  if (v109) {
    goto LABEL_52;
  }
  if (v95 == -1)
  {
    uint64_t v97 = -1LL;
    goto LABEL_53;
  }

  uint64_t v32 = (void *)v95;
  if (v32 != _dispatch_thread_getspecific(0x1CuLL))
  {
LABEL_52:
    uint64_t v97 = _dispatch_set_priority_and_voucher_slow(v96, (_DWORD *)v95, v94);
  }

  else
  {
    BOOL v93 = (v94 & 4) != 0;
    if ((v94 & 2) != 0)
    {
      if (v93 && v95)
      {
        uint64_t v113 = v95;
        os_release((void *)v95);
      }

      uint64_t v95 = -1LL;
    }

    else if (!v93 && v95)
    {
      object = (void *)v95;
      os_retain((void *)v95);
    }

    uint64_t v97 = v95;
  }

uint64_t _dispatch_mach_send_invoke(uint64_t a1, int a2, unsigned int a3)
{
  uint64_t v21 = *(void *)(a1 + 120);
  unsigned int v20 = _dispatch_thread_getspecific(3uLL) & 0xFFFFFFFC;
  uint64_t v17 = 0xFFFFFFFFLL;
  uint64_t v16 = 0LL;
  if ((a3 & 2) != 0)
  {
    uint64_t v17 = 0x10FFFFFFFFLL;
    uint64_t v16 = 0x1000000000LL;
  }

  else if ((a3 & 4) == 0)
  {
    uint64_t v17 = 0x10FFFFFFFFLL;
  }

  unsigned int v26 = _dispatch_thread_getspecific(0x19uLL);
  unsigned int v25 = (unsigned __int16)(v26 & 0xF000) >> 12;
  else {
    unsigned int v12 = (unsigned __int16)(v26 & 0xF00) >> 8;
  }
  if (v12 <= (v26 & 0xF0000) >> 16)
  {
    unsigned int v10 = (v26 & 0xF0000) >> 16;
  }

  else
  {
    else {
      int v11 = (unsigned __int16)(v26 & 0xF00) >> 8;
    }
    unsigned int v10 = v11;
  }

  int v15 = v10;
LABEL_15:
  uint64_t v13 = (unint64_t *)(v21 + 64);
  while (1)
  {
    uint64_t result = _os_atomic_mo_has_acquire(2);
    unint64_t v9 = (_DWORD)result ? __ldaxr(v13) : __ldxr(v13);
    unint64_t v19 = v9;
    if ((v9 & v17) != v16) {
      break;
    }
    if (v15 < (v9 & 0x700000000LL) >> 32)
    {
      __clrex();
      unsigned int v27 = (v9 & 0x700000000LL) >> 32;
      unsigned int v29 = _dispatch_thread_getspecific(3uLL);
      if ((_dispatch_set_qos_class_enabled & 1) != 0)
      {
        uint64_t v30 = 0LL;
        int v28 = (v19 & 0x700000000LL) >> 32;
        if (v28) {
          uint64_t v30 = 1LL << (v28 + 7);
        }
        _pthread_workqueue_override_start_direct(v29, v30 | 0xFF);
      }

      unsigned int v31 = _dispatch_thread_getspecific(0x19uLL);
      if (v27 > (v31 & 0xF0000) >> 16) {
        _dispatch_thread_setspecific(25LL, v31 & 0xFFF0FFFF | (v27 << 16));
      }
      int v15 = (v19 & 0x700000000LL) >> 32;
      goto LABEL_15;
    }

    unint64_t v18 = (v9 | v20) & 0xFFFFFFC7FFFFFFFFLL;
LABEL_32:
    uint64_t result = _os_atomic_mo_has_release(2);
    if ((_DWORD)result) {
      BOOL v14 = __stlxr(v18, v13) == 0;
    }
    else {
      BOOL v14 = __stxr(v18, v13) == 0;
    }
    if (v14) {
      goto LABEL_36;
    }
  }

  if ((a3 & 1) != 0)
  {
    unint64_t v18 = v9 | 0x2000000000LL;
    goto LABEL_32;
  }

  __clrex();
LABEL_36:
  if ((v19 & v17) == v16) {
    return _dispatch_mach_send_drain(a1, a2, a3, v4, v5, v6, v7, v8);
  }
  return result;
}

void _dispatch_mach_notification_merge_evt(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v3 = ~*(void *)(a1 + 8);
  if ((a3 & *(_DWORD *)(a1 + 32)) != 0) {
    _dispatch_mach_send_invoke(v3, 0x40000, 1u);
  }
  _dispatch_release_2_tailcall((unsigned int *)v3);
}

uint64_t dispatch_mach_send( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if ((_WORD)a3) {
    _dispatch_abort(1906LL, (unsigned __int16)a3, a3, a4, a5, a6, a7, a8);
  }
  uint64_t result = _dispatch_mach_send_msg(a1, a2, 0LL, a3 & 0xFFFF0000);
  if ((result & 1) != 0) {
    _dispatch_abort(1909LL, !(result & 1), v9, v10, v11, v12, v13, v14);
  }
  return result;
}

uint64_t _dispatch_mach_send_msg(uint64_t a1, uint64_t a2, unint64_t a3, int a4)
{
  uint64_t v47 = *(void *)(a1 + 120);
  if (*(void *)(a2 + 16) != -1985229329LL)
  {
    uint64_t v4 = *(void *)(a2 + 16);
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Message already enqueued";
    qword_E4DA8 = v4;
    __break(1u);
    JUMPOUT(0x6D984LL);
  }

  if ((*(_WORD *)(a1 + 116) & 0x10) != 0 && (a4 & 4) == 0 && _dispatch_mach_msg_get_reply_port(a2))
  {
    uint64_t v57 = (*(uint64_t (**)(void))((char *)&dword_10 + (void)_dispatch_mach_xpc_hooks))(*(void *)(a2 + 32));
    if (!v57) {
      uint64_t v57 = a1;
    }
    if (!v57) {
      _dispatch_abort(1830LL, 0LL, v5, v6, v7, v8, v9, v10);
    }
  }

  if ((a4 & 0x40000) != 0)
  {
    *(void *)(a2 + 56) = 0LL;
  }

  else
  {
    char v54 = 1;
    if ((a4 & 4) != 0) {
      char v54 = 3;
    }
    unint64_t v58 = (unint64_t)_dispatch_thread_getspecific(4uLL) & 0xFFFFFF;
    if ((v54 & 2) != 0 || v58 <= 0x10FF) {
      uint64_t v59 = v58;
    }
    else {
      uint64_t v59 = 4351LL;
    }
    *(void *)(a2 + 56) = v59;
  }

  uint64_t v60 = _dispatch_thread_getspecific(0x1CuLL);
  if (v60) {
    os_retain(v60);
  }
  *(void *)(a2 + 64) = v60;
  _dispatch_thread_getspecific(0LL);
  _dispatch_log("%u\t%p\tvoucher[%p]: mach-msg[%p] set", v11, v12, v13, v14, v15, v16, v17, 1847LL);
  int v55 = a4 | _dispatch_mach_send_options();
  *(_DWORD *)(a2 + 48) = v55;
  dispatch_retain((dispatch_object_t)a2);
  unint64_t v52 = (*(void *)(a2 + 56) & 0x3FFF00uLL) >> 8;
  unsigned int v18 = __clz(__rbit32(v52));
  if ((_DWORD)v52) {
    unsigned int v19 = v18 + 1;
  }
  else {
    unsigned int v19 = 0;
  }
  unsigned int v46 = v19;
  msg = (_DWORD *)_dispatch_mach_msg_get_msg(a2);
  *(_DWORD *)(a2 + 52) = _dispatch_mach_msg_get_reply_port(a2);
  int v42 = 0;
  if ((v55 & 1) != 0) {
    int v42 = 8;
  }
  if ((*msg & 0x1F) != 0x12
    || *(_DWORD *)(a2 + 52)
    || *(_DWORD *)(v47 + 88)
    || (*(_DWORD *)(a1 + 80) & 0x10000000) != 0)
  {
    uint64_t v53 = *(void *)(a2 + 64);
    if (v53 != -1)
    {
      unsigned int v40 = v53 ? *(_DWORD *)(v53 + 32) : 0;
      if (MEMORY[0xFFFFFC100]) {
        kdebug_trace(771817484LL, v40, a2, 0LL, 0LL);
      }
    }

    unint64_t v41 = a2;
    if (a3) {
      unint64_t v41 = a3;
    }
    char v43 = _dispatch_mach_send_push_and_trydrain(a1, v41, v46, v42);
  }

  else
  {
    if (a3) {
      _dispatch_abort(1879LL, a3 == 0, v20, v21, v22, v23, v24, v25);
    }
    unsigned int v44 = _dispatch_mach_msg_send(a1, (void *)a2, 0LL, 0, v42);
    if (!v44) {
      _dispatch_abort(1881LL, v44, v26, v27, v28, v29, v30, v31);
    }
    char v43 = (v44 & 2) != 0;
  }

  if ((v43 & 1) != 0)
  {
    _dispatch_thread_getspecific(0LL);
    _dispatch_log("%u\t%p\tvoucher[%p]: mach-msg[%p] clear", v32, v33, v34, v35, v36, v37, v38, 1892LL);
    if (*(void *)(a2 + 64)) {
      os_release(*(void **)(a2 + 64));
    }
    *(void *)(a2 + 64) = 0LL;
    *(void *)(a2 + 16) = -1985229329LL;
    dispatch_release((dispatch_object_t)a2);
  }

  return v43 & 1;
}

uint64_t dispatch_mach_send_with_result( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v17 = a1;
  uint64_t v16 = a2;
  int v15 = a3;
  uint64_t v14 = a4;
  uint64_t v13 = (void *)a5;
  uint64_t v12 = (_DWORD *)a6;
  if (a4)
  {
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Invalid send flags";
    qword_E4DA8 = v14;
    __break(1u);
    JUMPOUT(0x6E044LL);
  }

  uint64_t v19 = (unsigned __int16)v15;
  uint64_t v18 = 1921LL;
  if ((_WORD)v15) {
    _dispatch_abort(v18, v19, a3, 0LL, a5, a6, a7, a8);
  }
  int v15 = (HIWORD(v15) << 16) | 1;
  uint64_t result = _dispatch_mach_send_msg(v17, v16, 0LL, v15);
  char v11 = result;
  uint64_t v10 = 10LL;
  int v9 = 0;
  if ((result & 1) != 0)
  {
    uint64_t result = _dispatch_mach_msg_get_reason(v16, &v9);
    uint64_t v10 = result;
  }

  void *v13 = v10;
  *uint64_t v12 = v9;
  return result;
}

uint64_t _dispatch_mach_msg_get_reason(uint64_t a1, int *a2)
{
  int v4 = *(_DWORD *)(a1 + 48);
  if ((v4 & 0xFC000000) == 0xF8000000 && ((v4 >> 14) & 0xFFF) == 0x3E0)
  {
    *a2 = 0;
    return v4 & 0x3FFF;
  }

  else
  {
    *a2 = v4;
    uint64_t v2 = 4LL;
    if (!v4) {
      return 3LL;
    }
    return v2;
  }

uint64_t dispatch_mach_send_and_wait_for_reply( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v19 = a1;
  uint64_t v18 = a2;
  int v17 = a3;
  unsigned __int8 v16 = 0;
  uint64_t v23 = (unsigned __int16)a3;
  uint64_t v22 = 1994LL;
  if ((_WORD)a3) {
    _dispatch_abort(v22, v23, a3, a4, a5, a6, a7, a8);
  }
  v17 &= 0xFFFF0000;
  uint64_t v15 = _dispatch_mach_send_and_wait_for_reply(v19, v18, v17, &v16);
  uint64_t v21 = (v16 ^ 1) & 1;
  uint64_t v20 = 1998LL;
  if (((v16 ^ 1) & 1) == 0) {
    _dispatch_abort(v20, v21, v8, v9, v10, v11, v12, v13);
  }
  return v15;
}

uint64_t _dispatch_mach_send_and_wait_for_reply(uint64_t a1, uint64_t a2, int a3, _BYTE *a4)
{
  uint64_t v100 = a1;
  uint64_t v99 = a2;
  int v98 = a3;
  uint64_t v97 = a4;
  uint64_t v84 = 0LL;
  __int128 v83 = 0u;
  uint64_t v96 = 0LL;
  __int128 v95 = 0u;
  __int128 v94 = 0u;
  __int128 v93 = 0u;
  __int128 v92 = 0u;
  __int128 v91 = 0u;
  *(void *)&__int128 v91 = -2LL;
  *(void *)&__int128 v94 = *(void *)(a2 + 32);
  uint64_t v96 = _dispatch_thread_getspecific(3uLL);
  unint64_t v90 = &v91;
  mach_port_name_t v89 = 0;
  uint64_t v87 = v99;
  mach_port_name_t reply_port = _dispatch_mach_msg_get_reply_port(v99);
  if (!reply_port)
  {
    mach_port_name_t reply_port = _dispatch_get_thread_reply_port();
    msg = (_DWORD *)_dispatch_mach_msg_get_msg(v99);
    BOOL v10 = ((*msg >> 8) & 0x1F) == 21;
    BOOL v102 = ((*msg >> 8) & 0x1F) == 21;
    uint64_t v101 = 1956LL;
    if (!v10) {
      _dispatch_abort(v101, v102, v4, v5, v6, v7, v8, v9);
    }
    msg[3] = reply_port;
    *((_BYTE *)v90 + 3_dispatch_source_set_handler((uint64_t)source, handler, 2LL, 0) = 1;
  }

  v98 |= 4u;
  uint64_t v82 = 1LL;
  uint64_t v11 = (__int128 *)_dispatch_calloc(1LL, 88LL);
  unint64_t v90 = v11;
  __int128 v12 = v91;
  v11[1] = v92;
  *uint64_t v11 = v12;
  __int128 v13 = v93;
  __int128 v14 = v94;
  __int128 v15 = v95;
  *((void *)v11 + 1_dispatch_source_set_handler((uint64_t)source, handler, 2LL, 0) = v96;
  v11[4] = v15;
  pthread_t v11[3] = v14;
  v11[2] = v13;
  v85[0] = 1LL;
  v85[1] = -1LL;
  v85[2] = 0LL;
  v85[3] = -1LL;
  v85[4] = 0LL;
  v85[5] = 0LL;
  v85[6] = v99;
  v85[7] = v90;
  char v16 = _dispatch_mach_send_msg(v100, v99, (unint64_t)v85, v98);
  *uint64_t v97 = v16;
  if ((*((_BYTE *)v90 + 30) & 1) != 0)
  {
    _dispatch_clear_thread_reply_port(reply_port);
    mach_port_name_t v89 = *(_DWORD *)(*(void *)(v100 + 120) + 92LL);
  }

  uint64_t v80 = &v65;
  uint64_t v121 = v100;
  uint64_t v120 = v90;
  mach_port_name_t v119 = reply_port;
  mach_port_name_t v118 = v89;
  BOOL v81 = 0;
  if (reply_port) {
    BOOL v81 = v119 != -1;
  }
  if (!v81)
  {
    uint64_t v117 = v119;
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Invalid reply port";
    qword_E4DA8 = v119;
    __break(1u);
    JUMPOUT(0x6E560LL);
  }

  uint64_t v78 = 0LL;
  uint64_t v116 = 0LL;
  uint64_t v116 = *((void *)v120 + 6);
  uint64_t v115 = 0LL;
  uint64_t v114 = 0LL;
  *(_DWORD *)&v113[8] = 0;
  mach_msg_size_t v112 = 0;
  mach_error_t v111 = 0;
  unsigned int v110 = 0;
  mach_port_name_t v109 = 0;
  uint64_t v79 = &vm_page_mask;
  *(void *)uint64_t v113 = ((_DWORD)vm_page_mask + 0x4000) & ~(_DWORD)vm_page_mask;
  unsigned int v77 = (mach_msg_header_t *)((char *)&v65 - ((*(unsigned int *)v113 + 15LL) & 0x1FFFFFFF0LL));
  bzero(v77, *(unsigned int *)v113);
  uint64_t v115 = v77;
  uint64_t v127 = v77;
  uint64_t v126 = *(unsigned int *)v113;
  int i = v78;
  unsigned int v110 = 117440526;
  if (v118 && v118 != -1)
  {
    mach_port_name_t v109 = v118;
    v110 |= 0x4000u;
  }

  if ((*(_WORD *)(v121 + 116) & 0x80) != 0) {
    v110 |= 0x200u;
  }
  while (1)
  {
    pthread_key_t v71 = 0LL;
    _dispatch_thread_getspecific(0LL);
    _dispatch_log("%u\t%p\tmachport[0x%08x]: MACH_RCV_MSG %s", v17, v18, v19, v20, v21, v22, v23, 815LL);
    mach_error_t v111 = mach_msg(v115, v110, 0, *(mach_msg_size_t *)v113, v119, 0, v109);
    *(void *)&v113[4] = v115;
    unsigned int v75 = _dispatch_thread_getspecific(v71);
    uint64_t v74 = v119;
    uint64_t v73 = *(unsigned int *)v113;
    uint64_t v72 = v110;
    mach_error_string(v111);
    _dispatch_log( "%u\t%p\tmachport[0x%08x]: MACH_RCV_MSG (size %u, opts 0x%x) returned: %s - 0x%x",  v24,  v25,  v26,  v27,  v28,  v29,  v30,  822LL);
    mach_error_t v76 = v111;
    if (!v111) {
      break;
    }
    if (v76 == 268451842) {
      goto LABEL_34;
    }
    if (v76 != 268451844)
    {
      if (v76 != 268451846 && v76 != 268451849)
      {
        uint64_t v104 = v111;
        qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: Unexpected error from mach_msg_receive";
        qword_E4DA8 = v111;
        __break(1u);
        JUMPOUT(0x6EB70LL);
      }

LABEL_34:
      int v70 = _dispatch_thread_getspecific(0LL);
      uint64_t v68 = v116;
      uint64_t v69 = v119;
      mach_error_string(v111);
      _dispatch_log( "%u\t%p\tmachport[0x%08x]: sync reply port destroyed, ctxt %p: %s - 0x%x",  v44,  v45,  v46,  v47,  v48,  v49,  v50,  849LL);
      if ((*((_BYTE *)v120 + 30) & 1) != 0) {
        _dispatch_destruct_reply_port(v119, 2u);
      }
LABEL_52:
      free(v114);
      uint64_t v122 = 0LL;
      goto LABEL_53;
    }

    if (v115->msgh_size >= 0xFFFFFFBC)
    {
      uint64_t msgh_size = 0LL;
      uint64_t msgh_size = v115->msgh_size;
      qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Overlarge message";
      qword_E4DA8 = msgh_size;
      __break(1u);
      JUMPOUT(0x6E8CCLL);
    }

    if ((v110 & 4) == 0)
    {
      _dispatch_log( "BUG in libdispatch client: dispatch_mach_send_and_wait_for_reply: dropped message too large to fit in memory: id = 0x%x, size = %u",  v31,  v32,  v33,  v34,  v35,  v36,  v37,  v115->msgh_id);
      goto LABEL_41;
    }

    mach_msg_size_t v112 = v115->msgh_size + 68;
    uint64_t v114 = (mach_msg_header_t *)malloc_type_malloc(v112, 1659555374LL);
    unint64_t v107 = v114;
    uint64_t v124 = v114;
    uint64_t v123 = 831LL;
    if (!v114) {
      _dispatch_bug(v123, 0LL, v38, v39, v40, v41, v42, v43);
    }
    uint64_t v106 = v107;
    if (v107)
    {
      uint64_t v115 = v114;
      *(_DWORD *)uint64_t v113 = v112;
    }

    v110 |= 0x100u;
    v110 &= ~4u;
  }

  _dispatch_thread_getspecific(0LL);
  _dispatch_log( "%u\t%p\tmachport[0x%08x]: received msg id 0x%x, size = %u, reply on 0x%08x",  v51,  v52,  v53,  v54,  v55,  v56,  v57,  861LL);
  *(_DWORD *)uint64_t v113 = v115->msgh_size + 68;
  if (v114)
  {
    if (*(_DWORD *)v113 < v112)
    {
      uint64_t v105 = 0LL;
      uint64_t v105 = (mach_msg_header_t *)malloc_type_realloc(v114, v112, 2096623925LL);
      if (v105)
      {
        uint64_t v114 = v105;
        uint64_t v115 = v105;
      }
    }
  }

LABEL_41:
  _dispatch_mach_msg_reply_received(v121, (uint64_t)v120, v115->msgh_local_port);
  v115->msgh_local_port = 0;
  int v62 = *(_DWORD *)(v121 + 80);
  BOOL v67 = 1;
  if ((v62 & 0x10000000) == 0) {
    BOOL v67 = v111 != 0;
  }
  if (v67)
  {
    if (!v111) {
      mach_msg_destroy(v115);
    }
    goto LABEL_52;
  }

  *(_DWORD *)&v103[8] = 0;
  *(void *)unsigned int v103 = v114 != 0LL;
  *(void *)&v103[4] = dispatch_mach_msg_create( (uint64_t)v115,  *(unsigned int *)v113,  *(uint64_t *)v103,  0LL,  v58,  v59,  v60,  v61);
  if (!v114 || v115 != *(mach_msg_header_t **)&v113[4])
  {
    uint64_t v66 = *(void *)&v113[4];
    uint64_t v63 = _dispatch_mach_msg_get_msg(*(uint64_t *)&v103[4]);
    unsigned int v132 = 771948548;
    uint64_t v131 = v66;
    uint64_t v130 = v63;
    uint64_t v129 = 0LL;
    uint64_t v128 = 0LL;
    if (MEMORY[0xFFFFFC100]) {
      kdebug_trace(v132, v131, v130, v129, v128);
    }
  }

  *(void *)(*(void *)&v103[4] + 32LL) = v116;
  uint64_t v122 = *(void *)&v103[4];
LABEL_53:
  uint64_t v99 = v122;
  free(v90);
  return v99;
}

  uint64_t v22 = (v18 & 0x700000000LL) >> 32;
  if ((v19 & 0xFFFFFFFC) != 0) {
    uint64_t v27 = v19 | 3;
  }
  else {
    uint64_t v27 = 0;
  }
  if (v27)
  {
    if ((v19 & 0x700000000LL) < (unint64_t)v22 << 32 && (_dispatch_set_qos_class_enabled & 1) != 0)
    {
      uint64_t v28 = 0LL;
      if (v22) {
        uint64_t v28 = 1LL << (v22 + 7);
      }
      _pthread_workqueue_override_start_direct_check_owner(v27, v28 | 0xFF, v20 + 64);
    }
  }

  else if ((v17 & 0x1000000000LL) != 0)
  {
    _dispatch_mach_push_send_barrier_drain((uint64_t)a1, v22);
  }

  else
  {
    if ((_DWORD)v15 || *(_DWORD *)(v20 + 88) || (a1[20] & 0x10000000) != 0)
    {
      (*(void (**)(unsigned int *, void, void))(*(void *)a1 + 64LL))(a1, v22, v15 | 1);
      return;
    }

    if ((v19 & 0x1000000000LL) != 0)
    {
      (*(void (**)(unsigned int *, void, uint64_t))(*(void *)a1 + 64LL))(a1, v22, 1LL);
      return;
    }
  }

  _dispatch_release_2_tailcall(a1);
}

      *uint64_t v8 = 0LL;
      *uint64_t v7 = -1LL;
      BOOL v10 = 0;
      return v10 & 1;
    }

    *uint64_t v8 = 2LL;
    char v16 = v5;
    if (_dispatch_host_time_mach2nano)
    {
      uint64_t v17 = _dispatch_host_time_mach2nano(v16);
    }

    else if (v16)
    {
      if (v16 < 0x3126E978D4FDF3ALL)
      {
        if (v16 < 0x20C49BA5E353F7CLL) {
          uint64_t v17 = 125 * v16 / 3;
        }
        else {
          uint64_t v17 = 125 * (v16 / 3);
        }
      }

      else
      {
        uint64_t v17 = 0x7FFFFFFFFFFFFFFFLL;
      }
    }

    else
    {
      uint64_t v17 = 0LL;
    }

    *uint64_t v7 = v17;
    BOOL v10 = 1;
  }

  else
  {
    *uint64_t v8 = 1LL;
    uint64_t v18 = v5;
    if (_dispatch_host_time_mach2nano)
    {
      uint64_t v19 = _dispatch_host_time_mach2nano(v18);
    }

    else if (v18)
    {
      if (v18 < 0x3126E978D4FDF3ALL)
      {
        if (v18 < 0x20C49BA5E353F7CLL) {
          uint64_t v19 = 125 * v18 / 3;
        }
        else {
          uint64_t v19 = 125 * (v18 / 3);
        }
      }

      else
      {
        uint64_t v19 = 0x7FFFFFFFFFFFFFFFLL;
      }
    }

    else
    {
      uint64_t v19 = 0LL;
    }

    *uint64_t v7 = v19;
    BOOL v10 = 1;
  }

  return v10 & 1;
}

uint64_t dispatch_mach_send_with_result_and_wait_for_reply( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v18 = a1;
  uint64_t v17 = a2;
  int v16 = a3;
  uint64_t v15 = a4;
  __int128 v14 = (void *)a5;
  __int128 v13 = (_DWORD *)a6;
  if (a4)
  {
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Invalid send flags";
    qword_E4DA8 = v15;
    __break(1u);
    JUMPOUT(0x6EDA8LL);
  }

  char v12 = 0;
  uint64_t v11 = 0LL;
  uint64_t v20 = (unsigned __int16)v16;
  uint64_t v19 = 2014LL;
  if ((_WORD)v16) {
    _dispatch_abort(v19, v20, a3, 0LL, a5, a6, a7, a8);
  }
  int v16 = HIWORD(v16) << 16;
  v16 |= 1u;
  uint64_t v11 = _dispatch_mach_send_and_wait_for_reply(v18, v17, v16, &v12);
  uint64_t reason = 10LL;
  int v9 = 0;
  if ((v12 & 1) != 0) {
    uint64_t reason = _dispatch_mach_msg_get_reason(v17, &v9);
  }
  void *v14 = reason;
  _DWORD *v13 = v9;
  return v11;
}

uint64_t dispatch_mach_send_with_result_and_async_reply_4libxpc( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v19 = a1;
  uint64_t v18 = a2;
  int v17 = a3;
  uint64_t v16 = a4;
  uint64_t v15 = (void *)a5;
  __int128 v14 = (_DWORD *)a6;
  if (a4)
  {
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Invalid send flags";
    qword_E4DA8 = v16;
    __break(1u);
    JUMPOUT(0x6EEE8LL);
  }

  if ((*(_WORD *)(v19 + 116) & 0x10) == 0)
  {
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: dispatch_mach_send_with_result_and_wait_for_reply is XPC only";
    __break(1u);
    JUMPOUT(0x6EF24LL);
  }

  uint64_t v21 = (unsigned __int16)v17;
  uint64_t v20 = 2044LL;
  if ((_WORD)v17) {
    _dispatch_abort(v20, v21, a3, 0LL, a5, a6, a7, a8);
  }
  int v17 = (HIWORD(v17) << 16) | 1;
  uint64_t v12 = v18;
  if (!_dispatch_mach_msg_get_reply_port(v18))
  {
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Reply port needed for async send with reply";
    __break(1u);
    JUMPOUT(0x6EFB8LL);
  }

  uint64_t result = _dispatch_mach_send_msg(v19, v18, 0LL, v17);
  char v11 = result;
  uint64_t v10 = 10LL;
  int v9 = 0;
  if ((result & 1) != 0)
  {
    uint64_t result = _dispatch_mach_msg_get_reason(v18, &v9);
    uint64_t v10 = result;
  }

  *uint64_t v15 = v10;
  _DWORD *v14 = v9;
  return result;
}

uint64_t _dispatch_mach_msg_get_reply_port(uint64_t a1)
{
  msg = (_DWORD *)_dispatch_mach_msg_get_msg(a1);
  int v2 = msg[3];
  if (v2 && v2 != -1 && (*msg & 0x1F00u) >> 8 == 21) {
    return msg[3];
  }
  else {
    return 0;
  }
}

void dispatch_mach_reconnect(uint64_t a1, unsigned int a2, dispatch_object_s *a3)
{
  uint64_t v8 = (uint64_t)a3;
  uint64_t v7 = *(void *)(a1 + 120);
  uint64_t v5 = (unsigned int *)(v7 + 88);
  unsigned int v6 = *(_DWORD *)(v7 + 88);
  do
  {
    unsigned int v3 = v6;
    do
      unsigned int v4 = __ldaxr(v5);
    while (v4 == v6 && __stlxr(v6 + 1, v5));
    unsigned int v6 = v4;
  }

  while (v4 != v3);
  if (a2 && a2 != -1 && a3)
  {
    dispatch_retain(a3);
    *(_DWORD *)(v8 + 48) = _dispatch_mach_checkin_options();
    *(_DWORD *)(v7 + 96) = _dispatch_mach_msg_get_remote_port(v8);
  }

  else
  {
    if (a3 != (dispatch_object_s *)-1LL) {
      uint64_t v8 = 0LL;
    }
    *(_DWORD *)(v7 + 96) = 0;
  }

  uint64_t v12 = _dispatch_thread_getspecific(0x16uLL);
  if (v12)
  {
    _dispatch_thread_setspecific(22LL, v12[2]);
    char v11 = v12;
  }

  else
  {
    char v11 = (void *)_dispatch_continuation_alloc_from_heap();
  }

  *char v11 = 260LL;
  v11[4] = _dispatch_mach_reconnect_invoke;
  v11[5] = v11;
  v11[6] = v8;
  v11[7] = a2;
  pthread_t v11[3] = -1LL;
  v11[1] = -1LL;
  _dispatch_mach_send_push((unsigned int *)a1, v11, 0);
}

BOOL _dispatch_mach_reconnect_invoke( unsigned int *a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v51 = a2;
  uint64_t v50 = a1;
  uint64_t v49 = a1;
  _dispatch_object_debug((uint64_t)a1, "%s", a3, a4, a5, a6, a7, a8, (char)"_dispatch_mach_reconnect_invoke");
  uint64_t v48 = 0LL;
  uint64_t v48 = *((void *)v50 + 15);
  uint64_t v47 = v48;
  uint64_t v59 = v48;
  uint64_t v58 = 0LL;
  uint64_t v57 = *(void *)(v48 + 16);
  uint64_t v58 = v57;
  uint64_t v56 = v57;
  uint64_t v60 = v57;
  if (v57)
  {
    __int128 v91 = v50;
    int v90 = 5;
    dispatch_assert_queue_V2((dispatch_queue_t)&_dispatch_mgr_q);
    uint64_t v89 = *((void *)v50 + 15);
    _dispatch_unote_unregister(v89, 5LL, v13, v14, v15, v16, v17, v18);
    *(_DWORD *)(*((void *)v50 + 15) + 24LL) = 0;
  }

  if (*(_DWORD *)(v48 + 92) && *(_DWORD *)(v48 + 92) != -1)
  {
    _dispatch_mach_msg_disconnected((uint64_t)v50, 0, *(_DWORD *)(v48 + 92), v8, v9, v10, v11, v12);
    *(_DWORD *)(v48 + 92) = 0;
  }

  if (*(void *)(v48 + 48))
  {
    uint64_t v46 = *(dispatch_object_s **)(v48 + 48);
    _dispatch_mach_msg_not_sent((uint64_t)v50, v46, 0LL);
    *(void *)(v48 + 48) = 0LL;
  }

  *((_WORD *)v50 + 59) &= ~1u;
  uint64_t i = 0LL;
  uint64_t v44 = 0LL;
  uint64_t v43 = 0LL;
  char v41 = -112;
  uint64_t v55 = v50;
  unsigned int v54 = 0;
  unsigned int v53 = v50[20];
  unsigned int v54 = v53;
  unsigned int v52 = v53;
  if ((v53 & 0x40000000) == 0) {
    char v41 = -110;
  }
  uint64_t v74 = (unsigned int *)(v48 + 40);
  unsigned int v76 = _dispatch_thread_getspecific(3uLL);
  unsigned int v73 = v76 & 0xFFFFFFFC;
  unsigned int v72 = 0;
  BOOL v71 = 0;
  uint64_t v19 = (unsigned int *)(v48 + 40);
  unsigned int v69 = v76 & 0xFFFFFFFC;
  unsigned int v68 = v76 & 0xFFFFFFFC;
  unsigned int v70 = v76 & 0xFFFFFFFC;
  do
    unsigned int v20 = __ldaxr(v19);
  while (!v20 && __stlxr(v76 & 0xFFFFFFFC, v19));
  if (v20) {
    unsigned int v72 = v20;
  }
  BOOL v67 = v20 == 0;
  BOOL v71 = v20 == 0;
  BOOL v66 = v71;
  if (v20) {
    _dispatch_unfair_lock_lock_slow(v74, 0x10000);
  }
  uint64_t v39 = v43;
  uint64_t v43 = *(void *)(v48 + 56);
  *(void *)(v48 + 56) = v39;
  if (v43) {
    *(void *)(v43 + 72) = &v43;
  }
  uint64_t v40 = *(void *)(v48 + 56);
  if (v40) {
    *(void *)(v40 + 72) = v48 + 56;
  }
  for (uint64_t i = v43; ; uint64_t i = v44)
  {
    char v36 = 0;
    if (i)
    {
      uint64_t v44 = *(void *)(i + 64);
      char v36 = 1;
    }

    if ((v36 & 1) == 0) {
      break;
    }
    *(void *)(i + 72) = 0LL;
    _dispatch_mach_reply_unregister(v50, i, v41);
  }

  BOOL v42 = *(void *)(v48 + 56) == 0LL;
  uint64_t v75 = v48 + 40;
  uint64_t v85 = (unsigned int *)(v48 + 40);
  unsigned int v84 = 0;
  unsigned int v83 = 0;
  unsigned int v87 = _dispatch_thread_getspecific(3uLL);
  unsigned int v83 = v87 & 0xFFFFFFFC;
  unsigned int v82 = 0;
  uint64_t v34 = v85;
  int v80 = 0;
  int v79 = 0;
  int v81 = 0;
  unsigned int v35 = *v85;
  do
  {
    unsigned int v21 = v35;
    do
      unsigned int v22 = __ldaxr(v34);
    while (v22 == v35 && __stlxr(0, v34));
    unsigned int v35 = v22;
  }

  while (v22 != v21);
  unsigned int v78 = v22;
  unsigned int v82 = v22;
  unsigned int v77 = v22;
  unsigned int v84 = v22;
  if (v22 == v83)
  {
    BOOL v86 = 0;
  }

  else
  {
    _dispatch_unfair_lock_unlock_slow((uint64_t)v85, v84);
    unsigned int v88 = v84;
    BOOL v86 = (v84 & 2) != 0;
  }

  if (v42)
  {
    int v38 = v51[7];
    uint64_t v37 = (dispatch_object_s *)v51[6];
    uint64_t v61 = v51;
    uint64_t v64 = v51;
    uint64_t v63 = 0LL;
    uint64_t v63 = _dispatch_thread_getspecific(0x16uLL);
    int v62 = 0;
    if (v63) {
      int v33 = v63[2] + 1;
    }
    else {
      int v33 = 1;
    }
    int v62 = v33;
    if (v33 <= _dispatch_continuation_cache_limit)
    {
      _OWORD v64[2] = v63;
      *((_DWORD *)v64 + 2) = v62;
      _dispatch_thread_setspecific(22LL, (uint64_t)v64);
      uint64_t v65 = 0LL;
    }

    else
    {
      uint64_t v65 = v64;
    }

    uint64_t v61 = v65;
    if (v65) {
      _dispatch_continuation_free_to_cache_limit(v61);
    }
    if (v37 == (dispatch_object_s *)-1LL)
    {
      *((_WORD *)v50 + 59) = *((_WORD *)v50 + 59) & 0xFFFD | 2;
      uint64_t v37 = 0LL;
    }

    if (((*((_WORD *)v50 + 59) >> 1) & 1) != 0)
    {
      if (v38 && v38 != -1) {
        _dispatch_mach_msg_disconnected((uint64_t)v50, 0, v38, v23, v24, v25, v26, v27);
      }
      if (v37) {
        _dispatch_mach_msg_not_sent((uint64_t)v50, v37, 0LL);
      }
    }

    else
    {
      *(_DWORD *)(v48 + 92) = v38;
      *(void *)(v48 + 48) = v37;
    }

    uint64_t v31 = (unsigned int *)(v48 + 88);
    unsigned int v32 = *(_DWORD *)(v48 + 88);
    do
    {
      unsigned int v28 = v32;
      do
        unsigned int v29 = __ldaxr(v31);
      while (v29 == v32 && __stlxr(v32 - 1, v31));
      unsigned int v32 = v29;
    }

    while (v29 != v28);
  }

  return v42;
}

void _dispatch_mach_send_push(unsigned int *a1, void *a2, unsigned int a3)
{
  uint64_t v20 = *((void *)a1 + 15);
  uint64_t v17 = 0LL;
  LODWORD(v15) = 0;
  BOOL v14 = 0;
  if (*a2 > 0xFFFuLL) {
    BOOL v14 = *a2 == (void)&unk_E0D08;
  }
  a2[2] = 0LL;
  _dispatch_thread_setspecific(122LL, v20 + 72);
  uint64_t v8 = (unint64_t *)(v20 + 72);
  unint64_t v9 = *(void *)(v20 + 72);
  do
  {
    unint64_t v3 = v9;
    do
      unint64_t v4 = __ldaxr(v8);
    while (v4 == v9 && __stlxr((unint64_t)a2, v8));
    unint64_t v9 = v4;
  }

  while (v4 != v3);
  unint64_t v16 = v4;
  if (v4) {
    int v5 = 2;
  }
  else {
    int v5 = 4;
  }
  _dispatch_retain_n_unsafe((uint64_t)a1, v5);
  if (v16) {
    *(void *)(v16 + 16) = a2;
  }
  else {
    *(void *)(v20 + 8_dispatch_source_set_handler((uint64_t)source, handler, 2LL, 0) = a2;
  }
  _dispatch_thread_setspecific(122LL, 0LL);
  if (v16)
  {
    uint64_t v10 = (unint64_t *)(v20 + 64);
    while (1)
    {
      if (_os_atomic_mo_has_acquire(0)) {
        unint64_t v7 = __ldaxr(v10);
      }
      else {
        unint64_t v7 = __ldxr(v10);
      }
      unint64_t v19 = v7;
      unint64_t v25 = v7;
      unint64_t v18 = v25;
      if (v7 == v25) {
        break;
      }
      if (_os_atomic_mo_has_release(0)) {
        BOOL v11 = __stlxr(v25, v10) == 0;
      }
      else {
        BOOL v11 = __stxr(v25, v10) == 0;
      }
      if (v11) {
        goto LABEL_41;
      }
    }

    __clrex();
  }

  else
  {
    uint64_t v17 = 0xA000000000LL;
    uint64_t v15 = 2LL;
    if (v14) {
      uint64_t v17 = 0xB000000000LL;
    }
    uint64_t v12 = (unint64_t *)(v20 + 64);
    do
    {
      if (_os_atomic_mo_has_acquire(3)) {
        unint64_t v6 = __ldaxr(v12);
      }
      else {
        unint64_t v6 = __ldxr(v12);
      }
      unint64_t v19 = v6;
      unint64_t v26 = v6;
      unint64_t v18 = v26 | v17;
      if (_os_atomic_mo_has_release(3)) {
        BOOL v13 = __stlxr(v18, v12) == 0;
      }
      else {
        BOOL v13 = __stxr(v18, v12) == 0;
      }
    }

    while (!v13);
    if (((v19 ^ v18) & 0x8000000000LL) == 0) {
      _dispatch_release_2_no_dispose((uint64_t)a1);
    }
  }

uint64_t dispatch_mach_get_checkin_port(uint64_t a1)
{
  if ((*(_DWORD *)(a1 + 80) & 0x10000000) != 0) {
    return -1;
  }
  else {
    return *(unsigned int *)(*(void *)(a1 + 120) + 96LL);
  }
}

BOOL dispatch_mach_can_handoff_4libxpc()
{
  for (uint64_t i = (char *)_dispatch_thread_getspecific(0x17uLL); i; uint64_t i = *(char **)i)
  {
    if (*((char **)i + 1) == "mach_msg")
    {
      unint64_t v3 = i;
      goto LABEL_7;
    }
  }

  unint64_t v3 = 0LL;
LABEL_7:
  BOOL v1 = 0;
  if (v3)
  {
    BOOL v1 = 0;
    if (*((void *)v3 + 2)) {
      return *(void *)(*((void *)v3 + 2) + 56LL) == 0LL;
    }
  }

  return v1;
}

void dispatch_mach_handoff_reply_f(uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4)
{
  unint64_t v16 = _dispatch_mach_handoff_context(a2);
  uint64_t v15 = (void *)v16[2];
  _dispatch_mach_handoff_set_wlh((uint64_t)v15, a1);
  _dispatch_retain(a1);
  v16[3] = a1;
  *uint64_t v15 = 260LL;
  v15[4] = a4;
  v15[5] = a3;
  unint64_t v22 = (unint64_t)_dispatch_thread_getspecific(4uLL) & 0xFFFFFF;
  if (v22 <= 0x10FF) {
    unint64_t v23 = v22;
  }
  else {
    unint64_t v23 = 4351LL;
  }
  uint64_t v24 = _dispatch_thread_getspecific(0x1CuLL);
  if (v24) {
    os_retain(v24);
  }
  v15[3] = v24;
  _dispatch_thread_getspecific(0LL);
  _dispatch_log("%u\t%p\tvoucher[%p]: continuation[%p] set", v4, v5, v6, v7, v8, v9, v10, 589LL);
  uint64_t v25 = v15[3];
  if (v25 != -1)
  {
    unsigned int v14 = v25 ? *(_DWORD *)(v25 + 32) : 0;
    if (MEMORY[0xFFFFFC100]) {
      kdebug_trace(771817476LL, v14, v15, 0LL, 0LL);
    }
  }

  unint64_t v21 = v23;
  unsigned int v20 = 0;
  if (v23)
  {
    if ((*(_DWORD *)(a1 + 84) & 0x40000000) != 0 || (*(_DWORD *)(a1 + 84) & 0xFFF) == 0)
    {
      unsigned int v11 = v23 >> 8;
      unsigned int v12 = __clz(__rbit32(v11));
      if (v11) {
        unsigned int v13 = v12 + 1;
      }
      else {
        unsigned int v13 = 0;
      }
      unsigned int v20 = v13;
    }

    else
    {
      unint64_t v21 = 0LL;
    }
  }

  v15[1] = v21;
  *((_DWORD *)v16 + 8) = v20;
  *uint64_t v15 = &unk_E0E58;
}

void *_dispatch_mach_handoff_context(unsigned int a1)
{
  for (uint64_t i = _dispatch_thread_getspecific(0x17uLL); i; uint64_t i = (void *)*i)
  {
    if (i[1] == (void)"mach_msg")
    {
      uint64_t v9 = i;
      goto LABEL_7;
    }
  }

  uint64_t v9 = 0LL;
LABEL_7:
  if (!v9 || !v9[2])
  {
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Trying to handoff IPC from non IPC context";
    __break(1u);
    JUMPOUT(0x70D28LL);
  }

  if (*(void *)(*(void *)v9[2] + 16LL) == 515LL)
  {
    v9[2] = _dispatch_calloc(1LL, 80LL);
    uint64_t v6 = v9[2];
    *(_DWORD *)(v6 + 72) = 1;
  }

  else
  {
    uint64_t v6 = v9[2];
    uint64_t v4 = (unsigned int *)(v6 + 72);
    unsigned int v5 = *(_DWORD *)(v6 + 72);
    do
    {
      unsigned int v1 = v5;
      do
        unsigned int v2 = __ldaxr(v4);
      while (v2 == v5 && __stlxr(v5 + 1, v4));
      unsigned int v5 = v2;
    }

    while (v2 != v1);
  }

  if (*(void *)(v6 + 56))
  {
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Calling dispatch_mach_handoff_reply multiple times from the same context";
    __break(1u);
    JUMPOUT(0x70CF8LL);
  }

  *(void *)(v6 + 56) = a1;
  return v9;
}

uint64_t _dispatch_mach_handoff_set_wlh(uint64_t result, uint64_t a2)
{
  uint64_t v13 = result;
  while (*(void *)(a2 + 24))
  {
    if ((*(_DWORD *)(a2 + 80) & 0x400000) != 0)
    {
      unsigned int v14 = _dispatch_thread_getspecific(3uLL) & 0xFFFFFFFC;
      unsigned int v2 = (unsigned int *)(a2 + 100);
      do
        unsigned int v3 = __ldaxr(v2);
      while (!v3 && __stlxr(v14, v2));
      if (v3) {
        _dispatch_unfair_lock_lock_slow((unsigned int *)(a2 + 100), 0x10000);
      }
      uint64_t v10 = (unsigned int *)(a2 + 80);
      unsigned int v11 = *(_DWORD *)(a2 + 80);
      do
      {
        unsigned int v4 = v11;
        do
          unsigned int v5 = __ldaxr(v10);
        while (v5 == v11 && __stlxr(v11 & 0xFFBFFFFF, v10));
        unsigned int v11 = v5;
      }

      while (v5 != v4);
      uint64_t result = (uint64_t)_dispatch_thread_getspecific(3uLL);
      uint64_t v8 = (unsigned int *)(a2 + 100);
      unsigned int v9 = *(_DWORD *)(a2 + 100);
      do
      {
        unsigned int v6 = v9;
        do
          unsigned int v7 = __ldaxr(v8);
        while (v7 == v9 && __stlxr(0, v8));
        unsigned int v9 = v7;
      }

      while (v7 != v6);
      char v15 = v7;
      if (v7 == (result & 0xFFFFFFFC))
      {
        BOOL v16 = 0;
      }

      else
      {
        uint64_t result = (uint64_t)_dispatch_unfair_lock_unlock_slow(a2 + 100, v7);
        BOOL v16 = (v15 & 2) != 0;
      }

      if (v16)
      {
        uint64_t result = (uint64_t)_dispatch_thread_getspecific(0x19uLL);
      }
    }

    if ((*(void *)(a2 + 56) & 0x2000000000LL) != 0)
    {
      *(void *)(v13 + 64) = a2;
      return result;
    }

    a2 = *(void *)(a2 + 24);
  }

  *(void *)(v13 + 64) = 0LL;
  return result;
}

void dispatch_mach_handoff_reply(unsigned int *a1, unsigned int a2, const void *a3)
{
  char v15 = _dispatch_mach_handoff_context(a2);
  unsigned int v14 = (uint64_t *)v15[2];
  _dispatch_mach_handoff_set_wlh((uint64_t)v14, (uint64_t)a1);
  _dispatch_retain((uint64_t)a1);
  v15[3] = a1;
  unint64_t v18 = _dispatch_Block_copy(a3);
  if ((void (*)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))_Block_get_invoke_fn((uint64_t)a3) == ___dispatch_block_create_block_invoke)
  {
    uint64_t *v14 = 276LL;
    v14[5] = (uint64_t)v18;
    int inited = _dispatch_continuation_init_slow(v14, a1, 0);
  }

  else
  {
    _Block_get_invoke_fn((uint64_t)a3);
    uint64_t *v14 = 276LL;
    v14[4] = (uint64_t)_dispatch_call_block_and_release;
    v14[5] = (uint64_t)v18;
    unint64_t v22 = (unint64_t)_dispatch_thread_getspecific(4uLL) & 0xFFFFFF;
    if (v22 <= 0x10FF) {
      unint64_t v23 = v22;
    }
    else {
      unint64_t v23 = 4351LL;
    }
    uint64_t v24 = _dispatch_thread_getspecific(0x1CuLL);
    if (v24) {
      os_retain(v24);
    }
    v14[3] = (uint64_t)v24;
    _dispatch_thread_getspecific(0LL);
    _dispatch_log("%u\t%p\tvoucher[%p]: continuation[%p] set", v3, v4, v5, v6, v7, v8, v9, 589LL);
    uint64_t v25 = v14[3];
    if (v25 != -1)
    {
      unsigned int v13 = v25 ? *(_DWORD *)(v25 + 32) : 0;
      if (MEMORY[0xFFFFFC100]) {
        kdebug_trace(771817476LL, v13, v14, 0LL, 0LL);
      }
    }

    unint64_t v21 = v23;
    unsigned int v20 = 0;
    if (v23)
    {
      if ((a1[21] & 0x40000000) != 0 || (a1[21] & 0xFFF) == 0)
      {
        unsigned int v10 = v23 >> 8;
        unsigned int v11 = __clz(__rbit32(v10));
        if (v10) {
          unsigned int v12 = v11 + 1;
        }
        else {
          unsigned int v12 = 0;
        }
        unsigned int v20 = v12;
      }

      else
      {
        unint64_t v21 = 0LL;
      }
    }

    v14[1] = v21;
    int inited = v20;
  }

  *((_DWORD *)v15 + 8) = inited;
  v14[6] = *v14;
  uint64_t *v14 = (uint64_t)&unk_E0E58;
}

void _dispatch_mach_ipc_handoff_invoke(unsigned int *a1, uint64_t a2, int a3)
{
  uint64_t v44 = a1;
  uint64_t v43 = a2;
  int v42 = a3;
  char v41 = a1;
  memset(__b, 0, sizeof(__b));
  __b[0] = 0LL;
  __b[1] = "mach_msg";
  __b[2] = v41;
  __b[3] = 0LL;
  LODWORD(__b[4]) = 0;
  uint64_t v39 = _dispatch_thread_getspecific(0x14uLL);
  uint64_t v38 = *((void *)v44 + 6);
  unsigned int v37 = *((void *)v44 + 7);
  unsigned int v32 = (unint64_t *)(v41 + 16);
  uint64_t v33 = *((void *)v41 + 8);
  do
  {
    uint64_t v3 = v33;
    do
      uint64_t v4 = __ldaxr(v32);
    while (v4 == v33 && __stlxr(0LL, v32));
    uint64_t v33 = v4;
  }

  while (v4 != v3);
  uint64_t v36 = v4;
  if (v4)
  {
    if ((v4 & 1) != 0) {
      uint64_t v36 = ~v4;
    }
    else {
      _dispatch_sync_ipc_handoff_begin(v4, v37, (uint64_t)(v41 + 16));
    }
  }

  *((void *)v44 + 2) = -1985229329LL;
  *((void *)v44 + 7) = 0LL;
  uint64_t v56 = __b;
  __b[0] = _dispatch_thread_getspecific(0x17uLL);
  _dispatch_thread_setspecific(23LL, (uint64_t)v56);
  unsigned int v35 = v44;
  uint64_t v48 = v44;
  uint64_t v47 = v38;
  uint64_t v46 = 0LL;
  uint64_t v46 = (_DWORD *)*((void *)v44 + 3);
  uint64_t v45 = v38 & 4;
  uint64_t v50 = 1LL;
  uint64_t v49 = 600LL;
  if ((v38 & 4) != 0) {
    *((void *)v48 + 3) = -1LL;
  }
  if (v46 != (_DWORD *)-1LL)
  {
    int v70 = 771817480;
    unsigned int v69 = v46;
    unsigned int v68 = v48;
    unsigned int v67 = 0;
    if (v46) {
      unsigned int v31 = v69[8];
    }
    else {
      unsigned int v31 = 0;
    }
    unsigned int v67 = v31;
    unsigned int v75 = v70;
    uint64_t v74 = v31;
    unsigned int v73 = v68;
    uint64_t v72 = 0LL;
    uint64_t v71 = 0LL;
    if (MEMORY[0xFFFFFC100]) {
      kdebug_trace(v75, v74, v73, v72, v71);
    }
    _dispatch_thread_getspecific(0LL);
    _dispatch_log("%u\t%p\tvoucher[%p]: continuation[%p] adopt", v11, v12, v13, v14, v15, v16, v17, 607LL);
  }

  unint64_t v79 = *((void *)v48 + 1);
  uint64_t v78 = (uint64_t)v46;
  uint64_t v77 = v45 | 2;
  uint64_t v76 = 0LL;
  if (v79 != -1LL)
  {
    unint64_t v86 = v79;
    uint64_t v85 = v77;
    unsigned int v84 = 0;
    unsigned int v84 = _dispatch_thread_getspecific(0x19uLL);
    uint64_t v83 = 0LL;
    unsigned int v99 = v84;
    unsigned int v102 = v84 & 0xF00;
    unsigned int v98 = v102 >> 8;
    uint64_t v97 = v84;
    if (v102 >> 8) {
      v97 |= 1LL << (v98 + 7);
    }
    uint64_t v83 = v97;
    uint64_t v100 = v97;
    unint64_t v82 = v97 & 0xFFFFFF00;
    BOOL v81 = 0;
    BOOL v30 = 1;
    if ((v85 & 1) == 0) {
      BOOL v30 = (v86 & 0x10000000) != 0;
    }
    BOOL v81 = v30;
    unint64_t v88 = v86;
    v86 &= 0xFFFFFFu;
    if (v86)
    {
      if (v86 >= v82)
      {
        if (v81 || (v84 & 0x44000000) != 0) {
          uint64_t v87 = v86;
        }
        else {
          uint64_t v87 = v83;
        }
      }

      else
      {
        uint64_t v87 = v83;
      }
    }

    else
    {
      unsigned int v101 = v84 & 0xF000;
      unsigned int v80 = v101 >> 12;
      if (v101 >> 12)
      {
        unsigned int v90 = v80;
        uint64_t v89 = 1LL << (v80 + 7);
        uint64_t v29 = v89 | 0xFF;
      }

      else
      {
        uint64_t v29 = v83;
      }

      uint64_t v87 = v29;
    }

    uint64_t v76 = v87;
  }

  uint64_t v94 = v76;
  uint64_t v93 = v78;
  uint64_t v92 = v77;
  uint64_t v106 = v76;
  BOOL v109 = v76 != -1;
  uint64_t v108 = 2395LL;
  if (v76 == -1) {
    _dispatch_abort(v108, v109, v5, v6, v7, v8, v9, v10);
  }
  if ((_dispatch_set_qos_class_enabled & 1) != 0)
  {
    uint64_t v120 = v106;
    uint64_t v119 = 4261412863LL;
    uint64_t v118 = 0LL;
    v106 &= 0xFFFFFFFF02FFFFFFLL;
    unint64_t v105 = 0LL;
    unsigned int v110 = 0LL;
    unsigned int v110 = _dispatch_thread_getspecific(4uLL);
    unint64_t v105 = (unint64_t)v110;
    uint64_t v104 = 0x1000000LL;
    uint64_t v103 = 2281701376LL;
    if ((v110 & 0x1000000) != 0)
    {
      if (v106)
      {
        uint64_t v28 = v106;
      }

      else
      {
        unint64_t v114 = v105;
        uint64_t v113 = v104;
        uint64_t v112 = 0LL;
        uint64_t v28 = v105 & (~v104 | 0xFFFFFF);
      }

      uint64_t v107 = v28;
    }

    else
    {
      unint64_t v117 = v105;
      uint64_t v116 = v103;
      uint64_t v115 = 0LL;
      v105 &= ~v103 | 0xFFFFFF;
      if (v106 == v105) {
        uint64_t v107 = 0LL;
      }
      else {
        uint64_t v107 = v106;
      }
    }
  }

  else
  {
    uint64_t v107 = 0LL;
  }

  uint64_t v94 = v107;
  if (v107) {
    goto LABEL_61;
  }
  if (v93 == -1)
  {
    uint64_t v95 = -1LL;
    goto LABEL_62;
  }

  unsigned int v27 = (void *)v93;
  if (v27 != _dispatch_thread_getspecific(0x1CuLL))
  {
LABEL_61:
    uint64_t v95 = _dispatch_set_priority_and_voucher_slow(v94, (_DWORD *)v93, v92);
  }

  else
  {
    BOOL v91 = (v92 & 4) != 0;
    if ((v92 & 2) != 0)
    {
      if (v91 && v93)
      {
        uint64_t v111 = v93;
        os_release((void *)v93);
      }

      uint64_t v93 = -1LL;
    }

    else if (!v91 && v93)
    {
      object = (void *)v93;
      os_retain((void *)v93);
    }

    uint64_t v95 = v93;
  }

LABEL_62:
  if ((v38 & 0x200) == 0)
  {
    unsigned int v54 = v39;
    unsigned int v53 = v44;
    int v52 = 0;
    int v51 = 0;
    uint64_t v122 = v39;
    uint64_t v121 = v44;
  }

  uint64_t v34 = 0LL;
  if ((v42 & 0x1000000) != 0) {
    uint64_t v34 = _dispatch_autorelease_pool_push();
  }
  unint64_t v18 = (uint64_t (*)(uint64_t))*((void *)v44 + 4);
  uint64_t v63 = *((void *)v44 + 5);
  int v62 = v18;
  uint64_t v61 = 0LL;
  else {
    unint64_t v26 = v62;
  }
  uint64_t v61 = v26;
  uint64_t v131 = v63;
  uint64_t v130 = v26;
  int v60 = 0;
  int v59 = 0;
  int v58 = 0;
  int v57 = 0;
  _dispatch_client_callout(v63, v62);
  uint64_t v133 = v63;
  unsigned int v132 = v61;
  if (v34) {
    _dispatch_autorelease_pool_pop(v34);
  }
  if ((v38 & 0x200) == 0)
  {
    uint64_t v55 = v35;
    uint64_t v123 = v35;
    unsigned int v128 = 772079660;
    uint64_t v127 = v35;
    uint64_t v126 = 0LL;
    uint64_t v125 = 0LL;
    uint64_t v124 = 0LL;
    if (MEMORY[0xFFFFFC100]) {
      kdebug_trace(v128, v127, v126, v125, v124);
    }
    uint64_t v129 = v55;
  }

  uint64_t v64 = __b;
  BOOL v25 = _dispatch_thread_getspecific(0x17uLL) == __b;
  BOOL v66 = v25;
  uint64_t v65 = 449LL;
  if (!v25) {
    _dispatch_abort(v65, v66, v19, v20, v21, v22, v23, v24);
  }
  _dispatch_thread_setspecific(23LL, *v64);
  if (__b[3]) {
    _dispatch_mach_ipc_handoff_async((uint64_t)__b);
  }
  else {
    _dispatch_ipc_handoff_release(v41);
  }
  if (v36) {
    _dispatch_sync_ipc_handoff_end(v36, v37);
  }
}

void _dispatch_mach_ipc_handoff_async(uint64_t a1)
{
  uint64_t v5 = *(void *)(a1 + 16);
  unsigned int v4 = *(void *)(v5 + 56);
  uint64_t v3 = *(void *)(v5 + 64);
  (*(void (**)(void, uint64_t, void))(**(void **)(a1 + 24) + 72LL))( *(void *)(a1 + 24),  v5,  *(unsigned int *)(a1 + 32));
  if (v3)
  {
    _dispatch_sync_ipc_handoff_begin(v3, v4, v5 + 64);
    unsigned int v1 = (unint64_t *)(v5 + 64);
    do
      unint64_t v2 = __ldaxr(v1);
    while (v2 == v3 && __stlxr(~v3, v1));
  }

  _dispatch_ipc_handoff_release((unsigned int *)v5);
  _dispatch_release_tailcall(*(unsigned int **)(a1 + 24));
}

void _dispatch_ipc_handoff_release(unsigned int *a1)
{
  uint64_t v3 = a1 + 18;
  unsigned int v4 = a1[18];
  do
  {
    unsigned int v1 = v4;
    do
      unsigned int v2 = __ldaxr(v3);
    while (v2 == v4 && __stlxr(v4 - 1, v3));
    unsigned int v4 = v2;
  }

  while (v2 != v1);
  if (!v2) {
    free(a1);
  }
}

uint64_t _dispatch_mach_msg_invoke( dispatch_object_s *a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v56 = a1;
  uint64_t v55 = a2;
  int v54 = a3;
  __int128 v53 = 0uLL;
  int v59 = (uint64_t *)&v53;
  _dispatch_thread_getspecific_pair(0x14uLL, (void **)&v53, 0x15uLL, (pthread_key_t *)&v53 + 1, a5, a6, a7, a8);
  unsigned int v99 = (_OWORD *)v59[1];
  _dispatch_thread_setspecific_packed_pair(20LL, 21LL, v99, v8, v9, v10, v11, v12);
  uint64_t v57 = *v59;
  uint64_t v58 = v57;
  unsigned int v75 = v56;
  int v74 = v54;
  uint64_t v73 = v57;
  uint64_t v72 = 0LL;
  unsigned int v71 = 0;
  uint64_t reason = 0LL;
  uint64_t reason = _dispatch_mach_msg_get_reason((uint64_t)v56, (int *)&v71);
  uint64_t v69 = 7LL;
  memset(__b, 0, sizeof(__b));
  __b[0] = 0LL;
  __b[1] = "mach_msg";
  __b[2] = v75;
  __b[3] = 0LL;
  LODWORD(__b[4]) = 0;
  uint64_t v85 = __b;
  __b[0] = _dispatch_thread_getspecific(0x17uLL);
  _dispatch_thread_setspecific(23LL, (uint64_t)v85);
  uint64_t v67 = v73;
  BOOL v66 = v75;
  uint64_t v83 = v73;
  unint64_t v82 = v75;
  int v81 = 0;
  int v80 = 0;
  uint64_t v146 = v73;
  unsigned int v145 = v75;
  uint64_t v72 = *(void *)(v73 + 88);
  *((void *)v75 + 2) = -1985229329LL;
  uint64_t v13 = *((void *)v75 + 8);
  int v92 = 771817488;
  uint64_t v91 = v13;
  unsigned int v90 = v75;
  if (v13 != -1)
  {
    unsigned int v89 = 0;
    unsigned int v52 = v91 ? *(_DWORD *)(v91 + 32) : 0;
    unsigned int v89 = v52;
    unsigned int v97 = v92;
    uint64_t v96 = v52;
    uint64_t v95 = v90;
    uint64_t v94 = 0LL;
    uint64_t v93 = 0LL;
    if (MEMORY[0xFFFFFC100]) {
      kdebug_trace(v97, v96, v95, v94, v93);
    }
  }

  _dispatch_thread_getspecific(0LL);
  _dispatch_log("%u\t%p\tvoucher[%p]: mach-msg[%p] adopt", v14, v15, v16, v17, v18, v19, v20, 2458LL);
  uint64_t v27 = *((void *)v75 + 8);
  unint64_t v103 = *((void *)v75 + 7);
  uint64_t v102 = v27;
  uint64_t v101 = v69;
  uint64_t v100 = 0LL;
  if (v103 != -1LL)
  {
    unint64_t v110 = v103;
    uint64_t v109 = v101;
    unsigned int v108 = 0;
    unsigned int v108 = _dispatch_thread_getspecific(0x19uLL);
    uint64_t v107 = 0LL;
    unsigned int v123 = v108;
    unsigned int v126 = v108 & 0xF00;
    unsigned int v122 = v126 >> 8;
    uint64_t v121 = v108;
    if (v126 >> 8) {
      v121 |= 1LL << (v122 + 7);
    }
    uint64_t v107 = v121;
    uint64_t v124 = v121;
    unint64_t v106 = v121 & 0xFFFFFF00;
    BOOL v105 = 0;
    BOOL v51 = 1;
    if ((v109 & 1) == 0) {
      BOOL v51 = (v110 & 0x10000000) != 0;
    }
    BOOL v105 = v51;
    unint64_t v112 = v110;
    v110 &= 0xFFFFFFu;
    if (v110)
    {
      if (v110 >= v106)
      {
        if (v105 || (v108 & 0x44000000) != 0) {
          uint64_t v111 = v110;
        }
        else {
          uint64_t v111 = v107;
        }
      }

      else
      {
        uint64_t v111 = v107;
      }
    }

    else
    {
      unsigned int v125 = v108 & 0xF000;
      unsigned int v104 = v125 >> 12;
      if (v125 >> 12)
      {
        unsigned int v114 = v104;
        uint64_t v113 = 1LL << (v104 + 7);
        uint64_t v50 = v113 | 0xFF;
      }

      else
      {
        uint64_t v50 = v107;
      }

      uint64_t v111 = v50;
    }

    uint64_t v100 = v111;
  }

  uint64_t v118 = v100;
  uint64_t v117 = v102;
  uint64_t v116 = v101;
  uint64_t v130 = v100;
  BOOL v133 = v100 != -1;
  uint64_t v132 = 2395LL;
  if (v100 == -1) {
    _dispatch_abort(v132, v133, v21, v22, v23, v24, v25, v26);
  }
  if ((_dispatch_set_qos_class_enabled & 1) != 0)
  {
    uint64_t v144 = v130;
    uint64_t v143 = 4261412863LL;
    uint64_t v142 = 0LL;
    v130 &= 0xFFFFFFFF02FFFFFFLL;
    unint64_t v129 = 0LL;
    uint64_t v134 = 0LL;
    uint64_t v134 = _dispatch_thread_getspecific(4uLL);
    unint64_t v129 = (unint64_t)v134;
    uint64_t v128 = 0x1000000LL;
    uint64_t v127 = 2281701376LL;
    if ((v134 & 0x1000000) != 0)
    {
      if (v130)
      {
        uint64_t v49 = v130;
      }

      else
      {
        unint64_t v138 = v129;
        uint64_t v137 = v128;
        uint64_t v136 = 0LL;
        uint64_t v49 = v129 & (~v128 | 0xFFFFFF);
      }

      uint64_t v131 = v49;
    }

    else
    {
      unint64_t v141 = v129;
      uint64_t v140 = v127;
      uint64_t v139 = 0LL;
      v129 &= ~v127 | 0xFFFFFF;
      if (v130 == v129) {
        uint64_t v131 = 0LL;
      }
      else {
        uint64_t v131 = v130;
      }
    }
  }

  else
  {
    uint64_t v131 = 0LL;
  }

  uint64_t v118 = v131;
  if (v131) {
    goto LABEL_49;
  }
  if (v117 == -1)
  {
    uint64_t v119 = -1LL;
    goto LABEL_50;
  }

  uint64_t v48 = (void *)v117;
  if (v48 != _dispatch_thread_getspecific(0x1CuLL))
  {
LABEL_49:
    uint64_t v119 = _dispatch_set_priority_and_voucher_slow(v118, (_DWORD *)v117, v116);
  }

  else
  {
    BOOL v115 = (v116 & 4) != 0;
    if ((v116 & 2) != 0)
    {
      if (v115 && v117)
      {
        uint64_t v135 = v117;
        os_release((void *)v117);
      }

      uint64_t v117 = -1LL;
    }

    else if (!v115 && v117)
    {
      object = (void *)v117;
      os_retain((void *)v117);
    }

    uint64_t v119 = v117;
  }

LABEL_50:
  *((void *)v75 + 8) = 0LL;
  uint64_t v65 = 0LL;
  if ((v74 & 0x1000000) != 0) {
    uint64_t v65 = _dispatch_autorelease_pool_push();
  }
  if ((v74 & 4) != 0)
  {
    _dispatch_client_callout3( *(void *)(v72 + 48),  reason,  (uint64_t)v75,  *(uint64_t (**)(uint64_t, uint64_t, uint64_t))((char *)&dword_18 + (void)_dispatch_mach_xpc_hooks));
  }

  else
  {
    if (((*(_WORD *)(v73 + 116) >> 2) & 1) == 0) {
      _dispatch_mach_connect_invoke(v73);
    }
    if (reason == 2
      && (uint64_t v64 = v73, v79 = v73, v78 = 0, v77 = *(_DWORD *)(v73 + 80), v78 = v77, v76 = v77, (v77 & 0x10000000) != 0))
    {
      msg = 0LL;
      msg = (mach_msg_header_t *)_dispatch_mach_msg_get_msg((uint64_t)v75);
      _dispatch_thread_getspecific(0LL);
      _dispatch_log( "%u\t%p\tmachport[0x%08x]: drop msg id 0x%x, reply on 0x%08x",  v28,  v29,  v30,  v31,  v32,  v33,  v34,  2483LL);
      mach_msg_destroy(msg);
    }

    else
    {
      _dispatch_client_callout4( *(void *)(v72 + 48),  reason,  (uint64_t)v75,  v71,  *(uint64_t (**)(uint64_t, uint64_t, uint64_t, void))(v72 + 40));
    }
  }

  if (v65) {
    _dispatch_autorelease_pool_pop(v65);
  }
  int v62 = v75;
  unsigned int v84 = v75;
  unsigned int v147 = v75;
  unsigned int v152 = 772079660;
  unint64_t v151 = v75;
  uint64_t v150 = 0LL;
  uint64_t v149 = 0LL;
  uint64_t v148 = 0LL;
  if (MEMORY[0xFFFFFC100]) {
    kdebug_trace(v152, v151, v150, v149, v148);
  }
  unsigned int v153 = v84;
  dispatch_object_t v61 = v75;
  dispatch_release(v75);
  unint64_t v86 = __b;
  BOOL v41 = _dispatch_thread_getspecific(0x17uLL) == __b;
  BOOL v88 = v41;
  uint64_t v87 = 449LL;
  if (!v41) {
    _dispatch_abort(v87, v88, v35, v36, v37, v38, v39, v40);
  }
  _dispatch_thread_setspecific(23LL, *v86);
  if (__b[3]) {
    _dispatch_mach_ipc_handoff_async((uint64_t)__b);
  }
  int v60 = &v53;
  unsigned int v98 = &v53;
  return _dispatch_thread_setspecific_packed_pair(20LL, 21LL, &v53, v42, v43, v44, v45, v46);
}

  v50[8] = 0LL;
  uint64_t v42 = 0LL;
  if ((v49 & 0x1000000) != 0) {
    uint64_t v42 = _dispatch_autorelease_pool_push();
  }
  if ((v49 & 4) != 0)
  {
    _dispatch_client_callout3( *(void *)(v47 + 48),  reason,  (uint64_t)v50,  *(uint64_t (**)(uint64_t, uint64_t, uint64_t))((char *)&dword_18 + (void)_dispatch_mach_xpc_hooks));
  }

  else
  {
    if (((*(_WORD *)(v48 + 116) >> 2) & 1) == 0) {
      _dispatch_mach_connect_invoke(v48);
    }
    if (reason == 2 && (v54 = v48, v53 = 0, v52 = *(_DWORD *)(v48 + 80), v53 = v52, BOOL v51 = v52, (v52 & 0x10000000) != 0))
    {
      msg = (mach_msg_header_t *)_dispatch_mach_msg_get_msg((uint64_t)v50);
      _dispatch_thread_getspecific(0LL);
      _dispatch_log( "%u\t%p\tmachport[0x%08x]: drop msg id 0x%x, reply on 0x%08x",  v18,  v19,  v20,  v21,  v22,  v23,  v24,  2483LL);
      mach_msg_destroy(msg);
    }

    else
    {
      _dispatch_client_callout4( *(void *)(v47 + 48),  reason,  (uint64_t)v50,  v46,  *(uint64_t (**)(uint64_t, uint64_t, uint64_t, void))(v47 + 40));
    }
  }

  if (v42) {
    _dispatch_autorelease_pool_pop(v42);
  }
  int v59 = v50;
  unsigned int v125 = v50;
  uint64_t v130 = 772079660;
  unint64_t v129 = v50;
  uint64_t v128 = 0LL;
  uint64_t v127 = 0LL;
  unsigned int v126 = 0LL;
  if (MEMORY[0xFFFFFC100]) {
    kdebug_trace(v130, v129, v128, v127, v126);
  }
  uint64_t v131 = v59;
  dispatch_release((dispatch_object_t)v50);
  dispatch_object_t v61 = __b;
  uint64_t v31 = _dispatch_thread_getspecific(0x17uLL) == __b;
  uint64_t v63 = v31;
  int v62 = 449LL;
  if (!v31) {
    _dispatch_abort(v62, v63, v25, v26, v27, v28, v29, v30);
  }
  _dispatch_thread_setspecific(23LL, *v61);
  if (__b[3]) {
    _dispatch_mach_ipc_handoff_async((uint64_t)__b);
  }
  _dispatch_release(*(unsigned int **)(a1 + 56));
  uint64_t v64 = (void *)a1;
  uint64_t v67 = a1;
  BOOL v66 = 0LL;
  uint64_t result = _dispatch_thread_getspecific(0x16uLL);
  BOOL v66 = result;
  uint64_t v65 = 0;
  if (result) {
    uint64_t v33 = *((_DWORD *)v66 + 2) + 1;
  }
  else {
    uint64_t v33 = 1;
  }
  uint64_t v65 = v33;
  if (v33 <= _dispatch_continuation_cache_limit)
  {
    *(void *)(v67 + 16) = v66;
    *(_DWORD *)(v67 + 8) = v65;
    uint64_t result = (void *)_dispatch_thread_setspecific(22LL, v67);
    unsigned int v68 = 0LL;
  }

  else
  {
    unsigned int v68 = (void *)v67;
  }

  uint64_t v64 = v68;
  if (v68) {
    return _dispatch_continuation_free_to_cache_limit(v64);
  }
  return result;
}

uint64_t _dispatch_mach_barrier_invoke( void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v45 = a1;
  uint64_t v44 = a2;
  int v43 = a3;
  __int128 v42 = 0uLL;
  uint64_t v41 = a1[7];
  uint64_t v39 = a1[6];
  int v70 = a1;
  uint64_t v38 = *(void *)(*a1 + 16LL);
  if (v38 == 1024)
  {
    uint64_t v46 = &v42;
    _dispatch_thread_getspecific_pair(0x14uLL, (void **)&v42, 0x15uLL, (pthread_key_t *)&v42 + 1, a5, a6, a7, a8);
    int v81 = (_OWORD *)*((void *)v46 + 1);
    _dispatch_thread_setspecific_packed_pair(20LL, 21LL, v81, v8, v9, v10, v11, v12);
  }

  uint64_t v40 = *(void *)(v41 + 88);
  if (((*(_WORD *)(v41 + 116) >> 2) & 1) == 0)
  {
    uint64_t v37 = 0LL;
    if ((v43 & 0x1000000) != 0) {
      uint64_t v37 = _dispatch_autorelease_pool_push();
    }
    _dispatch_mach_connect_invoke(v41);
    if (v37) {
      _dispatch_autorelease_pool_pop(v37);
    }
  }

  uint64_t v36 = (uint64_t)v45;
  uint64_t v50 = v45;
  uint64_t v49 = v39;
  uint64_t v48 = 0LL;
  uint64_t v48 = (_DWORD *)v45[3];
  uint64_t v47 = v39 & 4;
  uint64_t v52 = 1LL;
  uint64_t v51 = 600LL;
  if ((v39 & 4) != 0) {
    v50[3] = -1LL;
  }
  if (v48 != (_DWORD *)-1LL)
  {
    int v74 = 771817480;
    uint64_t v73 = v48;
    uint64_t v72 = v50;
    unsigned int v71 = 0;
    if (v48) {
      unsigned int v33 = v73[8];
    }
    else {
      unsigned int v33 = 0;
    }
    unsigned int v71 = v33;
    unsigned int v79 = v74;
    uint64_t v78 = v33;
    int v77 = v72;
    uint64_t v76 = 0LL;
    uint64_t v75 = 0LL;
    if (MEMORY[0xFFFFFC100]) {
      kdebug_trace(v79, v78, v77, v76, v75);
    }
    _dispatch_thread_getspecific(0LL);
    _dispatch_log("%u\t%p\tvoucher[%p]: continuation[%p] adopt", v13, v14, v15, v16, v17, v18, v19, 607LL);
  }

  unint64_t v85 = v50[1];
  uint64_t v84 = (uint64_t)v48;
  uint64_t v83 = v47 | 2;
  uint64_t v82 = 0LL;
  if (v85 != -1LL)
  {
    unint64_t v92 = v85;
    uint64_t v91 = v83;
    unsigned int v90 = 0;
    unsigned int v90 = _dispatch_thread_getspecific(0x19uLL);
    uint64_t v89 = 0LL;
    unsigned int v105 = v90;
    unsigned int v108 = v90 & 0xF00;
    unsigned int v104 = v108 >> 8;
    uint64_t v103 = v90;
    if (v108 >> 8) {
      v103 |= 1LL << (v104 + 7);
    }
    uint64_t v89 = v103;
    uint64_t v106 = v103;
    unint64_t v88 = v103 & 0xFFFFFF00;
    BOOL v87 = 0;
    BOOL v32 = 1;
    if ((v91 & 1) == 0) {
      BOOL v32 = (v92 & 0x10000000) != 0;
    }
    BOOL v87 = v32;
    unint64_t v94 = v92;
    v92 &= 0xFFFFFFu;
    if (v92)
    {
      if (v92 >= v88)
      {
        if (v87 || (v90 & 0x44000000) != 0) {
          uint64_t v93 = v92;
        }
        else {
          uint64_t v93 = v89;
        }
      }

      else
      {
        uint64_t v93 = v89;
      }
    }

    else
    {
      unsigned int v107 = v90 & 0xF000;
      unsigned int v86 = v107 >> 12;
      if (v107 >> 12)
      {
        unsigned int v96 = v86;
        uint64_t v95 = 1LL << (v86 + 7);
        uint64_t v31 = v95 | 0xFF;
      }

      else
      {
        uint64_t v31 = v89;
      }

      uint64_t v93 = v31;
    }

    uint64_t v82 = v93;
  }

  uint64_t v100 = v82;
  uint64_t v99 = v84;
  uint64_t v98 = v83;
  uint64_t v112 = v82;
  BOOL v115 = v82 != -1;
  uint64_t v114 = 2395LL;
  if (v82 == -1) {
    _dispatch_abort(v114, v115, a3, a4, a5, a6, a7, a8);
  }
  if ((_dispatch_set_qos_class_enabled & 1) != 0)
  {
    uint64_t v126 = v112;
    uint64_t v125 = 4261412863LL;
    uint64_t v124 = 0LL;
    v112 &= 0xFFFFFFFF02FFFFFFLL;
    unint64_t v111 = 0LL;
    uint64_t v116 = 0LL;
    uint64_t v116 = _dispatch_thread_getspecific(4uLL);
    unint64_t v111 = (unint64_t)v116;
    uint64_t v110 = 0x1000000LL;
    uint64_t v109 = 2281701376LL;
    if ((v116 & 0x1000000) != 0)
    {
      if (v112)
      {
        uint64_t v30 = v112;
      }

      else
      {
        unint64_t v120 = v111;
        uint64_t v119 = v110;
        uint64_t v118 = 0LL;
        uint64_t v30 = v111 & (~v110 | 0xFFFFFF);
      }

      uint64_t v113 = v30;
    }

    else
    {
      unint64_t v123 = v111;
      uint64_t v122 = v109;
      uint64_t v121 = 0LL;
      v111 &= ~v109 | 0xFFFFFF;
      if (v112 == v111) {
        uint64_t v113 = 0LL;
      }
      else {
        uint64_t v113 = v112;
      }
    }
  }

  else
  {
    uint64_t v113 = 0LL;
  }

  uint64_t v100 = v113;
  if (v113) {
    goto LABEL_59;
  }
  if (v99 == -1)
  {
    uint64_t v101 = -1LL;
    goto LABEL_60;
  }

  uint64_t v29 = (void *)v99;
  if (v29 != _dispatch_thread_getspecific(0x1CuLL))
  {
LABEL_59:
    uint64_t v101 = _dispatch_set_priority_and_voucher_slow(v100, (_DWORD *)v99, v98);
  }

  else
  {
    BOOL v97 = (v98 & 4) != 0;
    if ((v98 & 2) != 0)
    {
      if (v97 && v99)
      {
        uint64_t v117 = v99;
        os_release((void *)v99);
      }

      uint64_t v99 = -1LL;
    }

    else if (!v97 && v99)
    {
      object = (void *)v99;
      os_retain((void *)v99);
    }

    uint64_t v101 = v99;
  }

uint64_t _dispatch_mach_connect_invoke(uint64_t a1)
{
  uint64_t result = _dispatch_client_callout4( *(void *)(*(void *)(a1 + 88) + 48LL),  1LL,  0LL,  0,  *(uint64_t (**)(uint64_t, uint64_t, uint64_t, void))(*(void *)(a1 + 88) + 40LL));
  *(_WORD *)(a1 + 116) = *(_WORD *)(a1 + 116) & 0xFFFB | 4;
  return result;
}

void dispatch_mach_send_barrier_f(unsigned int *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v18 = _dispatch_thread_getspecific(0x16uLL);
  if (v18)
  {
    _dispatch_thread_setspecific(22LL, v18[2]);
    uint64_t v16 = v18;
  }

  else
  {
    uint64_t v16 = (void *)_dispatch_continuation_alloc_from_heap();
  }

  *uint64_t v16 = 260LL;
  v16[4] = a3;
  v16[5] = a2;
  unint64_t v20 = (unint64_t)_dispatch_thread_getspecific(4uLL) & 0xFFFFFF;
  if (v20 <= 0x10FF) {
    uint64_t v21 = v20;
  }
  else {
    uint64_t v21 = 4351LL;
  }
  uint64_t v22 = _dispatch_thread_getspecific(0x1CuLL);
  if (v22) {
    os_retain(v22);
  }
  v16[3] = v22;
  _dispatch_thread_getspecific(0LL);
  _dispatch_log("%u\t%p\tvoucher[%p]: continuation[%p] set", v3, v4, v5, v6, v7, v8, v9, 589LL);
  uint64_t v23 = v16[3];
  if (v23 != -1)
  {
    unsigned int v12 = v23 ? *(_DWORD *)(v23 + 32) : 0;
    if (MEMORY[0xFFFFFC100]) {
      kdebug_trace(771817476LL, v12, v16, 0LL, 0LL);
    }
  }

  uint64_t v19 = v21;
  if (v21 && (a1[21] & 0x40000000) == 0 && (a1[21] & 0xFFF) != 0) {
    uint64_t v19 = 0LL;
  }
  v16[1] = v19;
  v16[6] = *v16;
  v16[7] = a1;
  *uint64_t v16 = &unk_E0D08;
  unint64_t v17 = (v16[1] & 0x3FFF00uLL) >> 8;
  unsigned int v10 = __clz(__rbit32(v17));
  if ((_DWORD)v17) {
    unsigned int v11 = v10 + 1;
  }
  else {
    unsigned int v11 = 0;
  }
  _dispatch_mach_send_push(a1, v16, v11);
}

void dispatch_mach_send_barrier(unsigned int *a1, const void *a2)
{
  unint64_t v17 = (uint64_t *)_dispatch_thread_getspecific(0x16uLL);
  if (v17)
  {
    _dispatch_thread_setspecific(22LL, v17[2]);
    uint64_t v14 = v17;
  }

  else
  {
    uint64_t v14 = (uint64_t *)_dispatch_continuation_alloc_from_heap();
  }

  uint64_t v15 = _dispatch_Block_copy(a2);
  if ((void (*)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))_Block_get_invoke_fn((uint64_t)a2) == ___dispatch_block_create_block_invoke)
  {
    uint64_t *v14 = 276LL;
    v14[5] = (uint64_t)v15;
    _dispatch_continuation_init_slow(v14, a1, 0);
  }

  else
  {
    _Block_get_invoke_fn((uint64_t)a2);
    uint64_t *v14 = 276LL;
    v14[4] = (uint64_t)_dispatch_call_block_and_release;
    v14[5] = (uint64_t)v15;
    unint64_t v19 = (unint64_t)_dispatch_thread_getspecific(4uLL) & 0xFFFFFF;
    if (v19 <= 0x10FF) {
      uint64_t v20 = v19;
    }
    else {
      uint64_t v20 = 4351LL;
    }
    uint64_t v21 = _dispatch_thread_getspecific(0x1CuLL);
    if (v21) {
      os_retain(v21);
    }
    v14[3] = (uint64_t)v21;
    _dispatch_thread_getspecific(0LL);
    _dispatch_log("%u\t%p\tvoucher[%p]: continuation[%p] set", v2, v3, v4, v5, v6, v7, v8, 589LL);
    uint64_t v22 = v14[3];
    if (v22 != -1)
    {
      unsigned int v11 = v22 ? *(_DWORD *)(v22 + 32) : 0;
      if (MEMORY[0xFFFFFC100]) {
        kdebug_trace(771817476LL, v11, v14, 0LL, 0LL);
      }
    }

    uint64_t v18 = v20;
    if (v20 && (a1[21] & 0x40000000) == 0 && (a1[21] & 0xFFF) != 0) {
      uint64_t v18 = 0LL;
    }
    v14[1] = v18;
  }

  v14[6] = *v14;
  v14[7] = (uint64_t)a1;
  uint64_t *v14 = (uint64_t)&unk_E0D08;
  unint64_t v16 = (v14[1] & 0x3FFF00uLL) >> 8;
  unsigned int v9 = __clz(__rbit32(v16));
  if ((_DWORD)v16) {
    unsigned int v10 = v9 + 1;
  }
  else {
    unsigned int v10 = 0;
  }
  _dispatch_mach_send_push(a1, v14, v10);
}

uint64_t dispatch_mach_receive_barrier_f(_DWORD *a1, uint64_t a2, uint64_t a3)
{
  unint64_t v19 = _dispatch_thread_getspecific(0x16uLL);
  if (v19)
  {
    _dispatch_thread_setspecific(22LL, v19[2]);
    uint64_t v18 = v19;
  }

  else
  {
    uint64_t v18 = (void *)_dispatch_continuation_alloc_from_heap();
  }

  *uint64_t v18 = 260LL;
  v18[4] = a3;
  v18[5] = a2;
  unint64_t v22 = (unint64_t)_dispatch_thread_getspecific(4uLL) & 0xFFFFFF;
  if (v22 <= 0x10FF) {
    unint64_t v23 = v22;
  }
  else {
    unint64_t v23 = 4351LL;
  }
  uint64_t v24 = _dispatch_thread_getspecific(0x1CuLL);
  if (v24) {
    os_retain(v24);
  }
  v18[3] = v24;
  _dispatch_thread_getspecific(0LL);
  _dispatch_log("%u\t%p\tvoucher[%p]: continuation[%p] set", v3, v4, v5, v6, v7, v8, v9, 589LL);
  uint64_t v25 = v18[3];
  if (v25 != -1)
  {
    unsigned int v14 = v25 ? *(_DWORD *)(v25 + 32) : 0;
    if (MEMORY[0xFFFFFC100]) {
      kdebug_trace(771817476LL, v14, v18, 0LL, 0LL);
    }
  }

  unint64_t v21 = v23;
  unsigned int v20 = 0;
  if (v23)
  {
    if ((a1[21] & 0x40000000) != 0 || (a1[21] & 0xFFF) == 0)
    {
      unsigned int v10 = v23 >> 8;
      unsigned int v11 = __clz(__rbit32(v10));
      if (v10) {
        unsigned int v12 = v11 + 1;
      }
      else {
        unsigned int v12 = 0;
      }
      unsigned int v20 = v12;
    }

    else
    {
      unint64_t v21 = 0LL;
    }
  }

  v18[1] = v21;
  v18[6] = *v18;
  v18[7] = a1;
  *uint64_t v18 = &unk_E0D40;
  return (*(uint64_t (**)(_DWORD *, void *, void))(*(void *)a1 + 72LL))(a1, v18, v20);
}

uint64_t dispatch_mach_receive_barrier(unsigned int *a1, const void *a2)
{
  unint64_t v19 = (uint64_t *)_dispatch_thread_getspecific(0x16uLL);
  if (v19)
  {
    _dispatch_thread_setspecific(22LL, v19[2]);
    unint64_t v16 = v19;
  }

  else
  {
    unint64_t v16 = (uint64_t *)_dispatch_continuation_alloc_from_heap();
  }

  unint64_t v17 = _dispatch_Block_copy(a2);
  if ((void (*)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))_Block_get_invoke_fn((uint64_t)a2) == ___dispatch_block_create_block_invoke)
  {
    *unint64_t v16 = 276LL;
    v16[5] = (uint64_t)v17;
    unsigned int inited = _dispatch_continuation_init_slow(v16, a1, 0);
  }

  else
  {
    _Block_get_invoke_fn((uint64_t)a2);
    *unint64_t v16 = 276LL;
    v16[4] = (uint64_t)_dispatch_call_block_and_release;
    v16[5] = (uint64_t)v17;
    unint64_t v22 = (unint64_t)_dispatch_thread_getspecific(4uLL) & 0xFFFFFF;
    if (v22 <= 0x10FF) {
      unint64_t v23 = v22;
    }
    else {
      unint64_t v23 = 4351LL;
    }
    uint64_t v24 = _dispatch_thread_getspecific(0x1CuLL);
    if (v24) {
      os_retain(v24);
    }
    v16[3] = (uint64_t)v24;
    _dispatch_thread_getspecific(0LL);
    _dispatch_log("%u\t%p\tvoucher[%p]: continuation[%p] set", v2, v3, v4, v5, v6, v7, v8, 589LL);
    uint64_t v25 = v16[3];
    if (v25 != -1)
    {
      unsigned int v13 = v25 ? *(_DWORD *)(v25 + 32) : 0;
      if (MEMORY[0xFFFFFC100]) {
        kdebug_trace(771817476LL, v13, v16, 0LL, 0LL);
      }
    }

    unint64_t v21 = v23;
    unsigned int v20 = 0;
    if (v23)
    {
      if ((a1[21] & 0x40000000) != 0 || (a1[21] & 0xFFF) == 0)
      {
        unsigned int v9 = v23 >> 8;
        unsigned int v10 = __clz(__rbit32(v9));
        if (v9) {
          unsigned int v11 = v10 + 1;
        }
        else {
          unsigned int v11 = 0;
        }
        unsigned int v20 = v11;
      }

      else
      {
        unint64_t v21 = 0LL;
      }
    }

    v16[1] = v21;
    unsigned int inited = v20;
  }

  v16[6] = *v16;
  v16[7] = (uint64_t)a1;
  *unint64_t v16 = (uint64_t)&unk_E0D40;
  return (*(uint64_t (**)(unsigned int *, uint64_t *, void))(*(void *)a1 + 72LL))(a1, v16, inited);
}

void dispatch_mach_cancel( unsigned int *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v11 = a1[20];
  do
  {
    unsigned int v8 = v11;
    unsigned int v9 = a1 + 20;
    do
      unsigned int v10 = __ldaxr(v9);
    while (v10 == v11 && __stlxr(v11 | 0x10000000, v9));
    unsigned int v11 = v10;
  }

  while (v10 != v8);
  if ((v10 & 0x10000000) == 0) {
    dispatch_mach_reconnect((uint64_t)a1, 0, (dispatch_object_s *)0xFFFFFFFFFFFFFFFFLL);
  }
  _dispatch_release_tailcall(a1);
}

void _dispatch_mach_activate(uint64_t a1)
{
  uint64_t v8 = a1;
  unsigned int v7 = 0;
  uint64_t v6 = 0LL;
  _dispatch_lane_activate(a1);
  if ((*(_WORD *)(v8 + 116) & 1) == 0)
  {
    unsigned int v7 = _dispatch_queue_compute_priority_and_wlh(v8, &v6);
    if (v7) {
      _dispatch_mach_install(v8, v6, v7, v1, v2, v3, v4, v5);
    }
  }

uint64_t _dispatch_mach_install( uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v19 = result;
  unsigned int v17 = a3;
  BOOL v16 = (*(_DWORD *)(result + 80) & 0x10000000) != 0;
  uint64_t v15 = *(void *)(result + 88);
  if ((*(_WORD *)(result + 116) & 1) != 0) {
    _dispatch_abort(2664LL, (*(_WORD *)(result + 116) & 1) == 0, a3, a4, a5, a6, a7, a8);
  }
  *(_WORD *)(result + 116) |= 1u;
  unsigned int v14 = *(_DWORD *)(*(void *)(result + 120) + 88LL);
  if (HIBYTE(v14) >> 7)
  {
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Channel never connected";
    qword_E4DA8 = v14;
    __break(1u);
    JUMPOUT(0x76D48LL);
  }

  if (!*(_DWORD *)(result + 84)) {
    *(_DWORD *)(result + 84) = a3;
  }
  if (!v16 && (*(_WORD *)(result + 116) & 0x10) != 0)
  {
    uint64_t result = (*(uint64_t (**)(void))((char *)&stru_20.cmd + (void)_dispatch_mach_xpc_hooks))(*(void *)(v15 + 48));
    if ((_DWORD)result)
    {
      uint64_t v13 = _dispatch_unote_create_with_handle((uint64_t)&_dispatch_xpc_type_sigterm, 15LL, 0LL);
      *(void *)(v13 + 8) = ~v19;
      *(void *)(v19 + 128) = v13;
      uint64_t result = _dispatch_unote_register(*(void *)(v19 + 128), a2, v17, v8, v9, v10, v11, v12);
    }
  }

  if (!v16 && *(_DWORD *)(v15 + 24))
  {
    if ((*(_BYTE *)(v15 + 29) & 1) == 0) {
      _dispatch_abort(2692LL, *(_BYTE *)(v15 + 29) & 1, a3, a4, a5, a6, a7, a8);
    }
    return _dispatch_unote_register(v15, a2, v17, a4, a5, a6, a7, a8);
  }

  return result;
}

void _dispatch_mach_invoke(unsigned int *a1, uint64_t a2, int a3)
{
  uint64_t v60 = a1;
  uint64_t v59 = a2;
  unsigned int v58 = a3;
  int v57 = 8;
  uint64_t v56 = _dispatch_mach_invoke2;
  uint64_t v55 = a1;
  v54[8] = 0;
  *(void *)int v54 = (a3 & 1) == 0;
  uint64_t v53 = 0LL;
  if ((a3 & 3) == 0)
  {
    *((void *)v55 + 2) = -1985229329LL;
    uint64_t v52 = _dispatch_thread_getspecific(0x14uLL);
    uint64_t v51 = v55;
    int v70 = v52;
    uint64_t v69 = v55;
    int v68 = 0;
    int v67 = 0;
    int v74 = v52;
    uint64_t v73 = v55;
  }

  v58 |= v57;
  if ((v58 & 2) != 0)
  {
    uint64_t v53 = 0x40020000000001LL;
    goto LABEL_54;
  }

  unsigned int v105 = v55;
  int v104 = v58;
  uint64_t v103 = 0LL;
  uint64_t v103 = (uint64_t)(*((unsigned __int16 *)v55 + 40) - 1) << 41;
  unsigned int v111 = _dispatch_thread_getspecific(3uLL);
  uint64_t v102 = v111 & 0xFFFFFFFC | 0x20000000000000LL;
  unint64_t v100 = 0LL;
  unint64_t v99 = 0LL;
  uint64_t v98 = 0LL;
  unint64_t v101 = 0xFFE00000FFFFFFFCLL;
  if ((v58 & 1) != 0)
  {
    v101 |= 0x4000000000uLL;
    uint64_t v98 = 0LL;
  }

  else if ((v104 & 0x40000) != 0)
  {
    uint64_t v98 = 0x4000000000LL;
  }

  else
  {
    v101 |= 0x4000000000uLL;
    uint64_t v98 = 1LL;
  }

  BOOL v110 = (v104 & 2) == 0;
  uint64_t v109 = 1323LL;
  if ((v104 & 2) != 0) {
    _dispatch_abort(v109, v110, v3, v4, v5, v6, v7, v8);
  }
  unsigned int v97 = 0;
  unsigned int v115 = _dispatch_thread_getspecific(0x19uLL);
  unsigned int v117 = v115 & 0xF00;
  unsigned int v114 = v117 >> 8;
  unsigned int v116 = v115 & 0xF000;
  unsigned int v113 = v116 >> 12;
  int v121 = v115 & 0xF0000;
  unsigned int v112 = (v115 & 0xF0000) >> 16;
  if (v117 >> 8 <= v116 >> 12) {
    unsigned int v46 = v113;
  }
  else {
    unsigned int v46 = v114;
  }
  if (v46 <= v112)
  {
    unsigned int v44 = v112;
  }

  else
  {
    if (v114 <= v113) {
      unsigned int v45 = v113;
    }
    else {
      unsigned int v45 = v114;
    }
    unsigned int v44 = v45;
  }

  unsigned int v97 = v44;
LABEL_22:
  BOOL v96 = 0;
  uint64_t v95 = (unint64_t *)(v105 + 14);
  while (1)
  {
    unint64_t v15 = _os_atomic_mo_has_acquire(2) ? __ldaxr(v95) : __ldxr(v95);
    unint64_t v100 = v15;
    unint64_t v99 = v15;
    if ((v15 & v101) != 0) {
      break;
    }
    unint64_t v167 = v100;
    unsigned int v166 = v97;
    unint64_t v170 = v100;
    BOOL v43 = 0;
    if ((v100 & 0x1000000000LL) != 0)
    {
      uint64_t v168 = v167 & 0x700000000LL;
      BOOL v43 = v166 < (v167 & 0x700000000LL) >> 32;
    }

    if (v43)
    {
      __clrex();
      unint64_t v119 = v100;
      uint64_t v120 = v100 & 0x700000000LL;
      unsigned int v118 = (v100 & 0x700000000LL) >> 32;
      unsigned int v123 = _dispatch_thread_getspecific(3uLL);
      unsigned int v122 = v118;
      if ((_dispatch_set_qos_class_enabled & 1) != 0)
      {
        unsigned int v125 = v122;
        uint64_t v124 = 0LL;
        if (v122) {
          uint64_t v124 = 1LL << (v125 + 7);
        }
        _pthread_workqueue_override_start_direct(v123, v124 | 0xFF);
      }

      unsigned int v127 = v118;
      unsigned int v126 = _dispatch_thread_getspecific(0x19uLL);
      int v128 = v126 & 0xF0000;
      if (v118 > (v126 & 0xF0000) >> 16)
      {
        unsigned int v126 = v126 & 0xFFF0FFFF | (v127 << 16);
        _dispatch_thread_setspecific(25LL, v126);
      }

      unsigned int v97 = v118;
      goto LABEL_22;
    }

    unint64_t v99 = v99 & 0x7700000001LL | v102;
    unint64_t v169 = v100;
    if ((v100 & 0x10000000000LL) != 0 || v100 + v103 < 0x20000000000000LL) {
      v99 |= 0x40000000000000uLL;
    }
LABEL_44:
    if (_os_atomic_mo_has_release(2)) {
      BOOL v96 = __stlxr(v99, v95) == 0;
    }
    else {
      BOOL v96 = __stxr(v99, v95) == 0;
    }
    if (v96) {
      goto LABEL_48;
    }
  }

  if (v98)
  {
    v99 ^= v98;
    goto LABEL_44;
  }

  __clrex();
LABEL_48:
  BOOL v94 = v96;
  BOOL v108 = (v100 & v98) == v98;
  uint64_t v107 = 1356LL;
  if ((v100 & v98) != v98) {
    _dispatch_abort(v107, v108, v9, v10, v11, v12, v13, v14);
  }
  if ((v100 & v101) != 0)
  {
    uint64_t v106 = 0LL;
  }

  else
  {
    v99 &= v98 | 0x60000000000000LL;
    v100 &= 0x3FFE0000000000uLL;
    uint64_t v106 = v99 - v100;
  }

  uint64_t v53 = v106;
LABEL_54:
  if (v53)
  {
    unsigned int v50 = 0;
    if ((v58 & 0x40000) != 0)
    {
      unsigned int v50 = 0;
    }

    else
    {
      unsigned int v131 = v55[21];
      unsigned int v130 = _dispatch_thread_getspecific(0x19uLL);
      unsigned int v129 = v130;
      if (v130)
      {
        if ((v131 & 0xFFF) != 0)
        {
          v129 &= 0x880F0000;
          if ((v130 & 0xFFF) <= (v131 & 0xFFF)) {
            int v42 = v131 & 0xFFF;
          }
          else {
            int v42 = v130 & 0xFFF;
          }
          v129 |= v42;
          unsigned int v133 = v131 & 0xF000;
          unsigned int v135 = v129 & 0xF00;
          if (v133 >> 12 <= v135 >> 8) {
            v131 &= 0x40000000u;
          }
          else {
            v131 &= 0x4400F000u;
          }
          v129 |= v131;
        }

        else
        {
          if ((v129 & 0xFFF) != 0) {
            v129 |= 0x40000000u;
          }
          unsigned int v132 = v131 & 0xF000;
          unsigned int v134 = v129 & 0xF00;
          if (v132 >> 12 > v134 >> 8) {
            unsigned int v129 = v129 & 0xFFFF0FFF | v131 & 0x400F000;
          }
        }
      }

      else
      {
        unsigned int v129 = v131 & 0xFFF0FFFF;
      }

      _dispatch_thread_setspecific(25LL, v129);
      unsigned int v50 = v130;
    }

    if ((v58 & 0x100000) != 0)
    {
      int v64 = v60;
      unsigned int v63 = 0;
      unsigned int v62 = v60[20];
      unsigned int v63 = v62;
      unsigned int v61 = v62;
      if ((v62 & 0x400000) != 0)
      {
        uint64_t v93 = v60;
        int v92 = 0x400000;
        int v90 = -4194305;
        int v89 = -4194305;
        int v91 = -4194305;
        unsigned int v87 = 0;
        uint64_t v40 = v60 + 20;
        int v85 = -4194305;
        int v84 = -4194305;
        int v86 = -4194305;
        unsigned int v41 = v60[20];
        do
        {
          unsigned int v16 = v41;
          do
            unsigned int v17 = __ldaxr(v40);
          while (v17 == v41 && __stlxr(v41 & 0xFFBFFFFF, v40));
          unsigned int v41 = v17;
        }

        while (v17 != v16);
        unsigned int v83 = v17;
        unsigned int v87 = v17;
        unsigned int v82 = v17;
        int v88 = v17 & v91;
      }
    }

    uint64_t v49 = v55;
    unint64_t v138 = v55;
    unsigned int v137 = v58;
    int v136 = 0;
    uint64_t v173 = v55;
    uint64_t v172 = 256LL;
    uint64_t v179 = 1LL;
    uint64_t v178 = 730LL;
    int v171 = 0;
    unsigned int v177 = v55;
    unsigned int v176 = 0;
    unsigned int v175 = v55[20];
    unsigned int v176 = v175;
    unsigned int v174 = v175;
    int v171 = v175 & 0x30000;
    int v136 = (v175 & 0x30000) << 8;
    if (v136) {
      unsigned int v137 = v137 & 0xFCFFFFFF | v136;
    }
    unsigned int v58 = v137;
    do
    {
      if ((v58 & 2) != 0 && (v58 & 0x1000000) == 0) {
        _dispatch_last_resort_autorelease_pool_push(v59);
      }
      uint64_t v48 = v55;
      *(void *)&v54[1] = v56((uint64_t)v55, v59, v58, &v53);
      if ((v58 & 2) != 0 && (v58 & 0x1000000) == 0)
      {
        __int128 v47 = 0uLL;
        uint64_t v140 = v55;
        uint64_t v139 = &v47;
        uint64_t v180 = &v47;
        _dispatch_thread_getspecific_packed_pair(20LL, 21LL, &v47, v19, v20, v21, v22, v23);
        _dispatch_thread_setspecific_pair(20LL, (uint64_t)v140, 21LL, (uint64_t)v139, v24, v25, v26, v27);
        _dispatch_last_resort_autorelease_pool_pop(v59);
        uint64_t v72 = &v47;
        _dispatch_thread_setspecific_packed_pair(20LL, 21LL, &v47, v28, v29, v30, v31, v32);
      }

      BOOL v66 = *(void *)&v54[1] != 1LL;
      uint64_t v65 = 2018LL;
      if (*(void *)&v54[1] == 1LL) {
        _dispatch_abort(v65, v66, v18, v19, v20, v21, v22, v23);
      }
      BOOL v39 = 0;
      if (*(void *)&v54[1]) {
        BOOL v39 = *(void *)&v54[1] != -1LL;
      }
      if (v39) {
        break;
      }
      int v158 = v55;
      uint64_t v157 = v53;
      BOOL v156 = *(void *)&v54[1] == 0LL;
      unint64_t v155 = 0LL;
      unint64_t v154 = 0LL;
      int v153 = 0;
      unsigned int v152 = (unint64_t *)(v55 + 14);
      do
      {
        if (_os_atomic_mo_has_acquire(3)) {
          unint64_t v33 = __ldaxr(v152);
        }
        else {
          unint64_t v33 = __ldxr(v152);
        }
        unint64_t v155 = v33;
        unint64_t v154 = (v33 - v157) & 0xFFFFFFF700000001LL;
        unint64_t v160 = v33;
        if ((v33 & 0xFF80000000000000LL) == 0)
        {
          unint64_t v181 = v155;
          if ((v155 & 0x8000000000LL) != 0)
          {
            __clrex();
            uint64_t v150 = 0x8000000000LL;
            uint64_t v149 = 0x8000000000LL;
            uint64_t v151 = 0x8000000000LL;
            unint64_t v147 = 0LL;
            uint64_t v37 = (unint64_t *)(v158 + 14);
            uint64_t v145 = 0x8000000000LL;
            uint64_t v144 = 0x8000000000LL;
            uint64_t v146 = 0x8000000000LL;
            unint64_t v38 = *((void *)v158 + 7);
            do
            {
              unint64_t v34 = v38;
              do
                unint64_t v35 = __ldaxr(v37);
              while (v35 == v38 && __stlxr(v38 ^ 0x8000000000LL, v37));
              unint64_t v38 = v35;
            }

            while (v35 != v34);
            unint64_t v143 = v35;
            unint64_t v147 = v35;
            unint64_t v142 = v35;
            unint64_t v148 = v35 ^ v151;
            char v159 = 0;
            goto LABEL_119;
          }

          if (v156) {
            v154 &= 0xFFFFFFF8FFFFFFFFLL;
          }
          else {
            v154 |= 0x8000000000uLL;
          }
        }

        if (_os_atomic_mo_has_release(3))
        {
          LOBYTE(v153) = __stlxr(v154, v152) == 0;
          int v153 = v153;
        }

        else
        {
          LOBYTE(v153) = __stxr(v154, v152) == 0;
          int v153 = v153;
        }
      }

      while (!v153);
      int v141 = v153;
      unint64_t v182 = v155;
      unint64_t v183 = v155;
      BOOL v36 = 0;
      if ((v155 & 0x1000000000LL) != 0) {
        BOOL v36 = (v182 & 0x800000000LL) != 0;
      }
      if (v36)
      {
        uint64_t v161 = v155 & 0x700000000LL;
        uint64_t v162 = v155 & 0x700000000LL;
        LODWORD(v162) = _dispatch_thread_getspecific(0x19uLL);
        int v163 = v162 & 0xF0000;
        if (HIDWORD(v162) > (v162 & 0xF0000) >> 16)
        {
          LODWORD(v162) = v162 & 0xFFF0FFFF;
          LODWORD(v162) = v162 | (HIDWORD(v162) << 16);
          _dispatch_thread_setspecific(25LL, v162);
        }
      }

      char v159 = 1;
LABEL_119:
      if ((v159 & 1) != 0)
      {
        uint64_t v53 = 0LL;
        *(void *)&v54[1] = 0LL;
        break;
      }

      *(void *)&v54[1] = _dispatch_thread_getspecific(0x14uLL);
    }

    while ((*(void *)(**(void **)&v54[1] + 16LL) & 0x10000LL) != 0 || (v54[0] & 1) == 0);
    if ((v58 & 0x40000) == 0)
    {
      unsigned int v165 = v50;
      unsigned int v164 = 0;
      unsigned int v164 = _dispatch_thread_getspecific(0x19uLL);
      v165 &= 0xFFF0FFFF;
      v165 |= v164 & 0xF0000;
      _dispatch_thread_setspecific(25LL, v165);
    }
  }

  if ((v54[0] & 1) != 0)
  {
    unsigned int v71 = v55;
    uint64_t v75 = v55;
    unsigned int v80 = 772079660;
    unsigned int v79 = v55;
    uint64_t v78 = 0LL;
    uint64_t v77 = 0LL;
    uint64_t v76 = 0LL;
    if (MEMORY[0xFFFFFC100]) {
      kdebug_trace(v80, v79, v78, v77, v76);
    }
    int v81 = v71;
  }

  if (*(void *)&v54[1]) {
    _dispatch_queue_invoke_finish(v55, v59, *(uint64_t (****)())&v54[1], v53);
  }
  else {
    _dispatch_release_2_tailcall(v55);
  }
}

uint64_t _dispatch_mach_invoke2(uint64_t a1, uint64_t a2, int a3, void *a4)
{
  uint64_t v32 = 0LL;
  uint64_t v31 = (uint64_t (***)())_dispatch_thread_getspecific(0x14uLL);
  uint64_t v30 = *(void *)(a1 + 120);
  uint64_t v29 = *(void *)(a1 + 88);
  BOOL v25 = 0;
  if ((a3 & 0x40000) == 0)
  {
    BOOL v25 = 0;
    if (v29)
    {
      uint64_t v40 = _dispatch_thread_getspecific(0x1DuLL);
      if (v40) {
        uint64_t v41 = v40[3];
      }
      else {
        uint64_t v41 = -4LL;
      }
      unint64_t v38 = *(void *)(v29 + 16) & 0xFFFFFFFFFFFFFFFCLL;
      BOOL v24 = 0;
      if (v38)
      {
        BOOL v24 = 0;
        if (v38 != -4LL) {
          BOOL v24 = v38 != v41;
        }
      }

      BOOL v25 = v24;
    }
  }

  if (v25) {
    _dispatch_mach_handle_wlh_change(a1, v4, v5, v6, v7, v8, v9, v10);
  }
  if ((*(_WORD *)(a1 + 116) & 1) == 0)
  {
    if ((a3 & 0x40000) != 0) {
      return *(void *)(a1 + 24);
    }
    unsigned int v27 = 0x2000000;
    if ((a3 & 0x10000) != 0) {
      unsigned int v27 = _dispatch_thread_getspecific(0x19uLL);
    }
    BOOL v39 = _dispatch_thread_getspecific(0x1DuLL);
    if (v39) {
      _dispatch_mach_install(a1, v39[3], v27, v11, v12, v13, v14, v15);
    }
    else {
      _dispatch_mach_install(a1, -4LL, v27, v11, v12, v13, v14, v15);
    }
  }

  if (!*(void *)(a1 + 48)) {
    goto LABEL_24;
  }
  if (v31 != *(uint64_t (****)())(a1 + 24))
  {
    uint64_t v32 = *(void *)(a1 + 24);
    goto LABEL_24;
  }

  while (1)
  {
    while (1)
    {
      uint64_t v32 = _dispatch_lane_serial_drain(a1, a2, a3, a4, v7, v8, v9, v10);
LABEL_24:
      int v28 = *(_DWORD *)(a1 + 80);
      if (v32 || (v28 & 0x10000000) != 0) {
        break;
      }
      uint64_t v42 = *(void *)(v29 + 16);
      BOOL v23 = 0;
      if (v42)
      {
        BOOL v23 = 0;
        if ((v42 & 1) == 0) {
          BOOL v23 = (v42 & 2) == 0;
        }
      }

      if (!v23) {
        break;
      }
      _dispatch_unote_resume(v29, v4, v5, v6, v7, v8, v9, v10);
      if (v31 == *(uint64_t (****)())(a1 + 24) && !v31[3] && !*(void *)(v30 + 72) && *((int *)v31 + 21) < 0)
      {
        BOOL v43 = _dispatch_thread_getspecific(0x1DuLL);
        BOOL v22 = 0;
        if (_dispatch_thread_getspecific(5uLL))
        {
          BOOL v22 = 0;
          if (v43)
          {
            BOOL v22 = 0;
            if (v43[3] != -4LL) {
              BOOL v22 = (*(void *)(v29 + 16) & 0xFFFFFFFFFFFFFFFCLL) == v43[3];
            }
          }
        }

        if (v22)
        {
          _dispatch_event_loop_drain(1u);
          if (*(void *)(a1 + 48)) {
            continue;
          }
        }
      }

      int v28 = *(_DWORD *)(a1 + 80);
      break;
    }

    if (*(void *)(v30 + 72))
    {
      if ((*(_BYTE *)(v30 + 30) & 1) == 0 || *(_DWORD *)(v30 + 88))
      {
        if (*(_DWORD *)(v30 + 88)) {
          int v21 = *(void *)(v30 + 16) != 0LL;
        }
        else {
          int v21 = *(_WORD *)(a1 + 118) & 1;
        }
        BOOL v20 = 0;
        if (v21) {
          BOOL v20 = v31 != &_dispatch_mgr_q;
        }
        if (v20)
        {
          if (v32) {
            return v32;
          }
          else {
            return (uint64_t)&_dispatch_mgr_q;
          }
        }

        unsigned int v26 = 0;
        if (v31 != &_dispatch_mgr_q) {
          unsigned int v26 = 4;
        }
        _dispatch_mach_send_invoke(a1, a3, v26);
        if (!v32 && *(void *)(a1 + 48)) {
          uint64_t v32 = *(void *)(a1 + 24);
        }
      }

      if (!v32 && *(void *)(v30 + 72)) {
        uint64_t v32 = -1LL;
      }
    }

    if ((v28 & 0x10000000) == 0) {
      return v32;
    }
    if (v28 >= 0 && !_dispatch_mach_cancel(a1, v4, v5, v6, v7, v8, v9, v10))
    {
      if (v32) {
        return v32;
      }
      else {
        return -1LL;
      }
    }

    if (((*(_WORD *)(a1 + 116) >> 3) & 1) != 0) {
      return v32;
    }
    if ((*(void *)(a1 + 56) & 0xFF80000000000000LL) != 0) {
      return *(void *)(a1 + 24);
    }
    if (!*(void *)(a1 + 48))
    {
      _dispatch_mach_cancel_invoke(a1, a3);
      return v32;
    }
  }

  if (v32) {
    return v32;
  }
  else {
    return *(void *)(a1 + 24);
  }
}

void _dispatch_mach_wakeup( uint64_t a1, unsigned int a2, unsigned int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10 = *(void *)(a1 + 120);
  *(_DWORD *)&v9[8] = 0;
  *(void *)uint64_t v9 = *(unsigned int *)(a1 + 80);
  if ((*(_WORD *)(a1 + 116) & 1) != 0)
  {
    if (*(void *)(a1 + 48))
    {
      *(void *)&v9[4] = 1LL;
    }

    else if (*(void *)(v10 + 72))
    {
      if ((*(_DWORD *)(v10 + 64) & 0xFFFFFFFC) == 0 && ((*(_BYTE *)(v10 + 30) & 1) == 0 || *(_DWORD *)(v10 + 88)))
      {
        if (*(_DWORD *)(v10 + 88)) {
          int v8 = *(void *)(v10 + 16) != 0LL;
        }
        else {
          int v8 = *(_WORD *)(a1 + 118) & 1;
        }
        if (v8) {
          *(void *)&v9[4] = &_dispatch_mgr_q;
        }
        else {
          *(void *)&v9[4] = 1LL;
        }
      }
    }

    else if (((*(_DWORD *)v9 & 0x10000000) == 0 || (*(_DWORD *)v9 & 0x40000000) == 0 || (a3 & 0x10) != 0) {
           && (*(_DWORD *)v9 & 0x10000000) != 0
    }
           && ((*(_WORD *)(a1 + 116) >> 3) & 1) == 0)
    {
      *(void *)&v9[4] = 1LL;
    }
  }

  else
  {
    *(void *)&v9[4] = 1LL;
  }

  _dispatch_queue_wakeup((_DWORD *)a1, a2, a3, *(uint64_t *)&v9[4], a5, a6, a7, a8);
}

uint64_t _dispatch_xpc_sigterm_merge_evt(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t v8 = ~*(void *)(a1 + 8);
  _dispatch_barrier_async_detached_f(v8, v8, (uint64_t)_dispatch_mach_sigterm_invoke);
  unsigned int v4 = (*(void *)&a4 & 0x3FFF00uLL) >> 8;
  unsigned int v5 = __clz(__rbit32(v4));
  if (v4) {
    uint64_t v6 = v5 + 1;
  }
  else {
    uint64_t v6 = 0LL;
  }
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v8 + 64LL))(v8, v6, 19LL);
}

uint64_t _dispatch_mach_sigterm_invoke( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t result = _dispatch_unote_unregister(*(void *)(a1 + 128), 5LL, a3, a4, a5, a6, a7, a8);
  if ((*(_DWORD *)(a1 + 80) & 0x10000000) == 0) {
    return _dispatch_client_callout4( *(void *)(*(void *)(a1 + 88) + 48LL),  11LL,  0LL,  0,  *(uint64_t (**)(uint64_t, uint64_t, uint64_t, void))(*(void *)(a1 + 88) + 40LL));
  }
  return result;
}

void *dispatch_mach_msg_create( uint64_t a1, unint64_t a2, uint64_t a3, uint64_t *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v14 = a3;
  char v10 = 1;
  if (a2 >= 0x18)
  {
    BOOL v9 = 0;
    if ((_DWORD)a3) {
      BOOL v9 = a1 == 0;
    }
    char v10 = v9;
  }

  if ((v10 & 1) != 0)
  {
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Empty message";
    qword_E4DA8 = a2;
    __break(1u);
    JUMPOUT(0x79348LL);
  }

  unint64_t v11 = 96LL;
  if (!(_DWORD)a3)
  {
    unint64_t v11 = a2 + 88;
    if (a2 - 8 >= 0xFFFFFFFFFFFFFFA0LL)
    {
      qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Message size too large";
      qword_E4DA8 = a2;
      __break(1u);
      JUMPOUT(0x793D4LL);
    }
  }

  uint64_t v12 = _dispatch_object_alloc((uint64_t)_OS_dispatch_mach_msg_vtable, v11, a3, (uint64_t)a4, a5, a6, a7, a8);
  if (v14)
  {
    v12[11] = a1;
  }

  else if (a1)
  {
    __memcpy_chk(v12 + 11, a1, a2, -1LL);
  }

  _DWORD v12[2] = -1985229329LL;
  v12[3] = &off_E4640;
  *((_DWORD *)v12 + 18) = v14;
  v12[10] = a2;
  if (a4) {
    *a4 = _dispatch_mach_msg_get_msg((uint64_t)v12);
  }
  return v12;
}

uint64_t _dispatch_mach_msg_get_msg(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 72)) {
    return *(void *)(a1 + 88);
  }
  else {
    return a1 + 88;
  }
}

void _dispatch_mach_msg_dispose(uint64_t a1)
{
  kern_return_t v8;
  if (*(void *)(a1 + 64))
  {
    os_release(*(void **)(a1 + 64));
    *(void *)(a1 + 64) = 0LL;
  }

  int v7 = *(_DWORD *)(a1 + 72);
  if (v7)
  {
    if (v7 == 1)
    {
      free(*(void **)(a1 + 88));
    }

    else if (v7 == 2)
    {
      uint64_t v8 = mach_vm_deallocate(mach_task_self_, *(void *)(a1 + 88), *(void *)(a1 + 80));
      if (v8) {
        _dispatch_bug(3000LL, v8, v1, v2, v3, v4, v5, v6);
      }
    }
  }

uint64_t dispatch_mach_msg_get_msg(uint64_t a1, void *a2)
{
  if (a2) {
    *a2 = *(void *)(a1 + 80);
  }
  return _dispatch_mach_msg_get_msg(a1);
}

void *_dispatch_mach_msg_async_reply_invoke(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v39 = *(void *)(a1 + 56);
  unsigned int v50 = *(void **)(a1 + 48);
  int v49 = a3 | 4;
  uint64_t v48 = v39;
  uint64_t v47 = 0LL;
  unsigned int v46 = 0;
  uint64_t reason = _dispatch_mach_msg_get_reason((uint64_t)v50, (int *)&v46);
  uint64_t v44 = 7LL;
  memset(__b, 0, sizeof(__b));
  __b[0] = 0LL;
  __b[1] = "mach_msg";
  __b[2] = v50;
  __b[3] = 0LL;
  LODWORD(__b[4]) = 0;
  uint64_t v60 = __b;
  __b[0] = _dispatch_thread_getspecific(0x17uLL);
  _dispatch_thread_setspecific(23LL, (uint64_t)v60);
  uint64_t v58 = v48;
  int v57 = v50;
  int v56 = 0;
  int v55 = 0;
  uint64_t v124 = v48;
  unsigned int v123 = v50;
  uint64_t v47 = *(void *)(v48 + 88);
  v50[2] = -1985229329LL;
  uint64_t v3 = v50[8];
  int v72 = 771817488;
  uint64_t v71 = v3;
  int v70 = v50;
  if (v3 != -1)
  {
    unsigned int v69 = 0;
    unsigned int v38 = v71 ? *(_DWORD *)(v71 + 32) : 0;
    unsigned int v69 = v38;
    unsigned int v77 = v72;
    uint64_t v76 = v38;
    uint64_t v75 = v70;
    uint64_t v74 = 0LL;
    uint64_t v73 = 0LL;
    if (MEMORY[0xFFFFFC100]) {
      kdebug_trace(v77, v76, v75, v74, v73);
    }
  }

  _dispatch_thread_getspecific(0LL);
  _dispatch_log("%u\t%p\tvoucher[%p]: mach-msg[%p] adopt", v4, v5, v6, v7, v8, v9, v10, 2458LL);
  uint64_t v17 = v50[8];
  unint64_t v81 = v50[7];
  uint64_t v80 = v17;
  uint64_t v79 = v44;
  uint64_t v78 = 0LL;
  if (v81 != -1LL)
  {
    unint64_t v88 = v81;
    uint64_t v87 = v79;
    unsigned int v86 = 0;
    unsigned int v86 = _dispatch_thread_getspecific(0x19uLL);
    uint64_t v85 = 0LL;
    unsigned int v101 = v86;
    unsigned int v104 = v86 & 0xF00;
    unsigned int v100 = v104 >> 8;
    uint64_t v99 = v86;
    if (v104 >> 8) {
      v99 |= 1LL << (v100 + 7);
    }
    uint64_t v85 = v99;
    uint64_t v102 = v99;
    unint64_t v84 = v99 & 0xFFFFFF00;
    BOOL v83 = 0;
    BOOL v37 = 1;
    if ((v87 & 1) == 0) {
      BOOL v37 = (v88 & 0x10000000) != 0;
    }
    BOOL v83 = v37;
    unint64_t v90 = v88;
    v88 &= 0xFFFFFFu;
    if (v88)
    {
      if (v88 >= v84)
      {
        if (v83 || (v86 & 0x44000000) != 0) {
          uint64_t v89 = v88;
        }
        else {
          uint64_t v89 = v85;
        }
      }

      else
      {
        uint64_t v89 = v85;
      }
    }

    else
    {
      unsigned int v103 = v86 & 0xF000;
      unsigned int v82 = v103 >> 12;
      if (v103 >> 12)
      {
        unsigned int v92 = v82;
        uint64_t v91 = 1LL << (v82 + 7);
        uint64_t v36 = v91 | 0xFF;
      }

      else
      {
        uint64_t v36 = v85;
      }

      uint64_t v89 = v36;
    }

    uint64_t v78 = v89;
  }

  uint64_t v96 = v78;
  uint64_t v95 = v80;
  uint64_t v94 = v79;
  uint64_t v108 = v78;
  BOOL v111 = v78 != -1;
  uint64_t v110 = 2395LL;
  if (v78 == -1) {
    _dispatch_abort(v110, v111, v11, v12, v13, v14, v15, v16);
  }
  if ((_dispatch_set_qos_class_enabled & 1) != 0)
  {
    uint64_t v122 = v108;
    uint64_t v121 = 4261412863LL;
    uint64_t v120 = 0LL;
    v108 &= 0xFFFFFFFF02FFFFFFLL;
    unint64_t v107 = 0LL;
    unsigned int v112 = 0LL;
    unsigned int v112 = _dispatch_thread_getspecific(4uLL);
    unint64_t v107 = (unint64_t)v112;
    uint64_t v106 = 0x1000000LL;
    uint64_t v105 = 2281701376LL;
    if ((v112 & 0x1000000) != 0)
    {
      if (v108)
      {
        uint64_t v35 = v108;
      }

      else
      {
        unint64_t v116 = v107;
        uint64_t v115 = v106;
        uint64_t v114 = 0LL;
        uint64_t v35 = v107 & (~v106 | 0xFFFFFF);
      }

      uint64_t v109 = v35;
    }

    else
    {
      unint64_t v119 = v107;
      uint64_t v118 = v105;
      uint64_t v117 = 0LL;
      v107 &= ~v105 | 0xFFFFFF;
      if (v108 == v107) {
        uint64_t v109 = 0LL;
      }
      else {
        uint64_t v109 = v108;
      }
    }
  }

  else
  {
    uint64_t v109 = 0LL;
  }

  uint64_t v96 = v109;
  if (v109) {
    goto LABEL_49;
  }
  if (v95 == -1)
  {
    uint64_t v97 = -1LL;
    goto LABEL_50;
  }

  unint64_t v34 = (void *)v95;
  if (v34 != _dispatch_thread_getspecific(0x1CuLL))
  {
LABEL_49:
    uint64_t v97 = _dispatch_set_priority_and_voucher_slow(v96, (_DWORD *)v95, v94);
  }

  else
  {
    BOOL v93 = (v94 & 4) != 0;
    if ((v94 & 2) != 0)
    {
      if (v93 && v95)
      {
        uint64_t v113 = v95;
        os_release((void *)v95);
      }

      uint64_t v95 = -1LL;
    }

    else if (!v93 && v95)
    {
      object = (void *)v95;
      os_retain((void *)v95);
    }

    uint64_t v97 = v95;
  }

uint64_t dispatch_mach_msg_get_filter_policy_id(uint64_t a1, _DWORD *a2)
{
  if (!a2)
  {
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Filter id should be non-NULL";
    qword_E4DA8 = 0LL;
    __break(1u);
    JUMPOUT(0x7A534LL);
  }

  uint64_t result = dispatch_mach_msg_get_msg(a1, 0LL);
  if (!result)
  {
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Messsage should be non-NULL";
    qword_E4DA8 = a1;
    __break(1u);
    JUMPOUT(0x7A598LL);
  }

  uint64_t v5 = (unsigned int *)(result + ((*(unsigned int *)(result + 4) + 3LL) & 0x1FFFFFFFCLL));
  if (*v5)
  {
    uint64_t v3 = *v5;
    qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: Trailer format is invalid";
    qword_E4DA8 = v3;
    __break(1u);
    JUMPOUT(0x7A608LL);
  }

  if (v5[1] < 0x44)
  {
    uint64_t v4 = v5[1];
    qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: Trailer doesn't contain filter policy id";
    qword_E4DA8 = v4;
    __break(1u);
    JUMPOUT(0x7A680LL);
  }

  *a2 = v5[15];
  return result;
}

uint64_t dispatch_mig_server( uint64_t a1, uint64_t a2, uint64_t (*a3)(mach_msg_header_t *, mach_msg_header_t *))
{
  uint64_t v60 = a1;
  uint64_t v59 = a2;
  uint64_t v58 = a3;
  mach_msg_option_t v57 = 117442818;
  mach_msg_option_t v56 = 0;
  int v55 = 0LL;
  uint64_t v54 = 0LL;
  int v53 = 0LL;
  unsigned int v52 = 0;
  int v51 = 0;
  uint64_t v50 = 0LL;
  int v49 = 1000;
  int v48 = 0;
  char v47 = 0;
  size_t v46 = a2 + 68;
  uint64_t v45 = 0LL;
  uint64_t v45 = *(void *)(a1 + 88);
  unint64_t v34 = (mach_msg_header_t *)&v27[-((a2 + 83) & 0xFFFFFFFFFFFFFFF0LL)];
  bzero(v34, a2 + 68);
  uint64_t v54 = v34;
  v34[1].msgh_remote_port = 0;
  int v70 = v54;
  size_t v69 = v46;
  for (uint64_t i = (_BYTE *)(((unint64_t)v54 + vm_page_size) & ~(_DWORD)vm_page_mask);
        i < (_BYTE *)v70 + v69;
        i += vm_page_size)
  {
    *uint64_t i = 0;
  }

  int v33 = (mach_msg_header_t *)&v27[-((v46 + 15) & 0xFFFFFFFFFFFFFFF0LL)];
  bzero(v33, v46);
  int v53 = v33;
  v33->uint64_t msgh_size = 0;
  uint64_t v67 = v53;
  size_t v66 = v46;
  for (signed int j = (_BYTE *)(((unint64_t)v53 + vm_page_size) & ~(_DWORD)vm_page_mask);
        j < (_BYTE *)v67 + v66;
        j += vm_page_size)
  {
    *signed int j = 0;
  }

  v57 |= 4u;
  mach_msg_option_t v56 = v57;
  while (1)
  {
    int v44 = 0;
    uint64_t v43 = v60;
    uint64_t v64 = v60;
    int v63 = 0;
    int v62 = *(_DWORD *)(v60 + 80);
    int v63 = v62;
    int v61 = v62;
    int v44 = v62;
    uint64_t v42 = 0LL;
    uint64_t v41 = *(void *)(v60 + 56);
    uint64_t v42 = v41;
    uint64_t v40 = v41;
    uint64_t v71 = v41;
    if ((v41 & 0xFF80000000000000LL) != 0 || (v44 & 0x10000000) != 0 || (--v49, !v49))
    {
      v57 &= ~2u;
      v56 &= ~2u;
      if ((v56 & 1) == 0) {
        break;
      }
    }

    unsigned int v52 = mach_msg(v53, v56, v53->msgh_size, v46, *(_DWORD *)(v45 + 24), 0, 0);
    mach_msg_option_t v56 = v57;
    if (v52)
    {
      unsigned int v32 = v52;
      if (v52 == 268435460 || v52 == 268435459)
      {
        _dispatch_mig_consume_unsent_message(v53, v3, v4, v5, v6, v7, v8, v9);
      }

      else if (v32 != 268451842)
      {
        if (v32 == 268451843)
        {
          if (v53->msgh_remote_port || (v47 & 1) != 0) {
            return 0;
          }
        }

        else
        {
          if (v32 == 268451844)
          {
            v56 &= 0xFFFFFFFA;
            size_t v39 = 0LL;
            size_t v39 = v53->msgh_size + 68;
            unsigned int v38 = 0LL;
            unsigned int v38 = (mach_msg_header_t *)malloc_type_malloc(v39, 4250307884LL);
            if (v38)
            {
              size_t v46 = v39;
              int v53 = v38;
            }

            if (!mach_msg(v53, v56, 0, v46, *(_DWORD *)(v45 + 24), 0, 0))
            {
              _dispatch_log( "BUG in libdispatch client: dispatch_mig_server received message larger than requested size %zd: id = 0x%x, size = %d",  v11,  v12,  v13,  v14,  v15,  v16,  v17,  v59);
              mach_msg_destroy(v53);
            }

            if (v38) {
              free(v38);
            }
          }

          _dispatch_bug_mach_client((uint64_t)"dispatch_mig_server: mach_msg() failed", v52);
        }
      }

      return v52;
    }

    if ((v56 & 2) == 0) {
      return v52;
    }
    if (v50) {
      uint64_t v50 = 0LL;
    }
    char v47 = 1;
    int v55 = v54;
    uint64_t v54 = v53;
    int v53 = v55;
    uint64_t v73 = voucher_create_with_mach_msg(v54, v3, v4, v5, v6, v7, v8, v9);
    int v72 = 0LL;
    uint64_t v76 = (uint64_t)v73;
    uint64_t v75 = 0LL;
    uint64_t v75 = _dispatch_thread_getspecific(0x1CuLL);
    uint64_t v85 = v75;
    uint64_t v84 = v76;
    if (v75 == (_DWORD *)v76)
    {
      unsigned int v86 = -1;
    }

    else
    {
      if (v85)
      {
        int v83 = 0;
        int v82 = 0;
      }

      _dispatch_thread_setspecific(28LL, v84);
      if (v84)
      {
        int v81 = 0;
        int v80 = 0;
      }

      _dispatch_thread_getspecific(0LL);
      _dispatch_log("%u\t%p\tvoucher[%p]: swap from voucher[%p]", v18, v19, v20, v21, v22, v23, v24, 400LL);
      int v79 = 0;
      if (v84) {
        int v31 = *(_DWORD *)(v84 + 32);
      }
      else {
        int v31 = 0;
      }
      int v79 = v31;
      int v78 = 0;
      if (v85) {
        int v30 = v85[8];
      }
      else {
        int v30 = 0;
      }
      int v78 = v30;
      if (v79 == v30) {
        int v29 = -1;
      }
      else {
        int v29 = v79;
      }
      unsigned int v86 = v29;
    }

    unsigned int v77 = v86;
    if (v86 != -1) {
      _dispatch_set_priority_and_mach_voucher_slow(0LL, v77);
    }
    int v72 = v75;
    if (v75)
    {
      uint64_t v74 = v72;
      os_release(v72);
    }

    uint64_t v25 = v53;
    uint64_t v35 = 0LL;
    uint64_t v36 = 0LL;
    uint64_t v37 = 0LL;
    *(_OWORD *)&v53->msgh_bits = 0u;
    *(void *)&v25->msgh_voucher_port = v37;
    int v48 = v58(v54, v53);
    if (v48) {
      int v51 = _dispatch_mig_return_code((uint64_t)v53);
    }
    else {
      int v51 = -303;
    }
    int v28 = v51;
    if (v51 == -305)
    {
      v53->msgh_remote_port = 0;
    }

    else if (v28)
    {
      v54->msgh_remote_port = 0;
      mach_msg_destroy(v54);
    }

    if (v53->msgh_remote_port)
    {
      v56 |= 1u;
      if ((v53->msgh_bits & 0x1F) != 0x12) {
        v56 |= 0x10u;
      }
    }
  }

  return v52;
}

void _dispatch_mig_consume_unsent_message( mach_msg_header_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  kern_return_t v9;
  mach_port_name_t msgh_local_port;
  msgh_local_port = a1->msgh_local_port;
  if (msgh_local_port && msgh_local_port != -1)
  {
    uint64_t v9 = 0;
    int v8 = (a1->msgh_bits >> 8) & 0x1F;
    if (v8 == 16)
    {
      uint64_t v9 = mach_port_mod_refs(mach_task_self_, msgh_local_port, 1u, -1);
    }

    else if (v8 == 18 || v8 == 17)
    {
      uint64_t v9 = mach_port_deallocate(mach_task_self_, msgh_local_port);
    }

    if (v9 == -301)
    {
      qword_E4D78 = (uint64_t)"MIG_REPLY_MISMATCH";
      qword_E4DA8 = -301LL;
      __break(1u);
      JUMPOUT(0x7B0FCLL);
    }

    if (v9) {
      _dispatch_bug(3170LL, v9, a3, a4, a5, a6, a7, a8);
    }
  }

  mach_msg_destroy(a1);
}

uint64_t _dispatch_mig_return_code(uint64_t a1)
{
  else {
    return 0;
  }
}

uint64_t dispatch_mach_mig_demux(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4)
{
  mach_msg_return_t v22;
  int v23;
  uint64_t v24;
  mach_msg_header_t *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  mach_msg_option_t v29;
  __int128 v30;
  uint64_t v31;
  mach_msg_return_t v32;
  unsigned int v33;
  mach_msg_header_t *v34;
  uint64_t v35;
  mach_msg_id_t msgh_id;
  mach_msg_header_t *msg;
  void v38[4];
  unint64_t v39;
  uint64_t v40;
  uint64_t v41;
  void *v43;
  uint64_t *v44;
  uint64_t v45;
  BOOL v46;
  _BYTE *i;
  uint64_t v48;
  mach_msg_header_t *v49;
  uint64_t v41 = a1;
  uint64_t v40 = a2;
  size_t v39 = a3;
  v38[3] = a4;
  uint64_t v26 = 0LL;
  v38[0] = 0LL;
  v38[1] = "mach_mig_demux";
  v38[2] = a1;
  msg = (mach_msg_header_t *)dispatch_mach_msg_get_msg(a4, 0LL);
  msgh_id = 0;
  msgh_id = msg->msgh_id;
  unint64_t v34 = 0LL;
  int v33 = 0;
  unsigned int v32 = 0;
  uint64_t v35 = _dispatch_mach_mig_resolve(msgh_id, v40, v39);
  if (v35)
  {
    uint64_t v43 = v38;
    uint64_t v24 = 23LL;
    v38[0] = _dispatch_thread_getspecific(0x17uLL);
    _dispatch_thread_setspecific(23LL, (uint64_t)v43);
    int v33 = *(_DWORD *)(v35 + 32) + 68;
    uint64_t v25 = (mach_msg_header_t *)((char *)&v21 - ((v33 + 15LL) & 0x1FFFFFFF0LL));
    bzero(v25, v33);
    unint64_t v34 = v25;
    int v49 = v25;
    int v48 = v33;
    for (uint64_t i = (_BYTE *)(((unint64_t)v25 + vm_page_size) & ~(_DWORD)vm_page_mask);
          i < (_BYTE *)v49 + v48;
          i += vm_page_size)
    {
      *uint64_t i = 0;
    }

    uint64_t v4 = v34;
    LODWORD(v3_dispatch_source_set_handler((uint64_t)source, handler, 2LL, 0) = msg->msgh_bits & 0x1F;
    DWORD1(v3_dispatch_source_set_handler((uint64_t)source, handler, 2LL, 0) = 36;
    *((void *)&v30 + _dispatch_source_set_handler((uint64_t)source, handler, 2LL, 1) = msg->msgh_remote_port;
    LODWORD(v3_dispatch_source_set_handler((uint64_t)source, handler, 2LL, 1) = 0;
    HIDWORD(v3_dispatch_source_set_handler((uint64_t)source, handler, 2LL, 1) = msgh_id + 100;
    __int128 v5 = v30;
    *(void *)&v34->msgh_voucher_port = v31;
    *(_OWORD *)&v4->msgh_bits = v5;
    (*(void (**)(mach_msg_header_t *, mach_msg_header_t *))(v35 + 8))(msg, v34);
    uint64_t v23 = _dispatch_mig_return_code((uint64_t)v34);
    if (v23 == -305)
    {
      v34->msgh_remote_port = 0;
    }

    else if (v23)
    {
      msg->msgh_remote_port = 0;
      mach_msg_destroy(msg);
    }

    if (v34->msgh_remote_port)
    {
      int v29 = 1;
      if ((v34->msgh_bits & 0x1F) != 0x12) {
        v29 |= 0x10u;
      }
      unsigned int v32 = mach_msg(v34, v29, v34->msgh_size, 0, 0, 0, 0);
      uint64_t v22 = v32;
      if (v32)
      {
        if ((v22 - 268435459) >= 2)
        {
          if (v32 == -301)
          {
            int v28 = -301LL;
            qword_E4D78 = (uint64_t)"MIG_REPLY_MISMATCH";
            qword_E4DA8 = -301LL;
            __break(1u);
            JUMPOUT(0x7B528LL);
          }

          uint64_t v27 = v32;
          qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: dispatch_mach_mig_demux: mach_msg(MACH_SEND_MSG) failed";
          qword_E4DA8 = v32;
          __break(1u);
          JUMPOUT(0x7B56CLL);
        }

        _dispatch_mig_consume_unsent_message(v34, v6, v7, v8, v9, v10, v11, v12);
      }
    }

    int v44 = v38;
    BOOL v19 = _dispatch_thread_getspecific(0x17uLL) == v38;
    size_t v46 = v19;
    uint64_t v45 = 449LL;
    if (!v19) {
      _dispatch_abort(v45, v46, v13, v14, v15, v16, v17, v18);
    }
    _dispatch_thread_setspecific(23LL, *v44);
    return 1;
  }

  else
  {
    return 0;
  }

uint64_t _dispatch_mach_mig_resolve(int a1, uint64_t a2, unint64_t a3)
{
  for (unint64_t i = 0LL; ; ++i)
  {
    if (i >= a3) {
      return 0LL;
    }
    if (*(_DWORD *)(*(void *)(a2 + 8 * i) + 8LL) <= a1 && a1 < *(_DWORD *)(*(void *)(a2 + 8 * i) + 12LL)) {
      break;
    }
  }

  if (*(void *)(*(void *)(a2 + 8 * i) + 32LL + 40LL * (a1 - *(_DWORD *)(*(void *)(a2 + 8 * i) + 8LL)) + 8)) {
    return *(void *)(a2 + 8 * i) + 32LL + 40LL * (a1 - *(_DWORD *)(*(void *)(a2 + 8 * i) + 8LL));
  }
  else {
    return 0LL;
  }
}

uint64_t dispatch_mach_mig_demux_get_context()
{
  for (unint64_t i = _dispatch_thread_getspecific(0x17uLL); i; unint64_t i = (void *)*i)
  {
    if (i[1] == (void)"mach_mig_demux")
    {
      uint64_t v2 = i;
      goto LABEL_7;
    }
  }

  uint64_t v2 = 0LL;
LABEL_7:
  if (!v2)
  {
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: dispatch_mach_mig_demux_get_context not called from dispatch_ma"
                           "ch_mig_demux context";
    __break(1u);
    JUMPOUT(0x7B7F8LL);
  }

  return v2[2];
}

uint64_t _dispatch_mach_msg_set_reason( uint64_t result, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if ((a3 & 0xFFFFFFFFFFFFC000LL) != 0) {
    _dispatch_abort(597LL, a3 & 0xFFFFFFFFFFFFC000LL, a3, a4, a5, a6, a7, a8);
  }
  if (!a2 && a3) {
    int v8 = a3 | 0xF8F80000;
  }
  else {
    int v8 = a2;
  }
  *(_DWORD *)(result + 48) = v8;
  return result;
}

uint64_t _dispatch_mach_reply_list_remove_locked( uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!*(void *)(result + 72)) {
    _dispatch_abort(310LL, *(void *)(result + 72) != 0LL, a3, a4, a5, a6, a7, a8);
  }
  if (*(void *)(result + 64)) {
    *(void *)(*(void *)(result + 64) + 72LL) = *(void *)(result + 72);
  }
  **(void **)(result + 72) = *(void *)(result + 64);
  *(void *)(result + 64) = -1LL;
  *(void *)(result + 72) = -1LL;
  *(void *)(result + 72) = 0LL;
  return result;
}

void *_dispatch_mach_msg_create_reply_disconnected( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v28 = a1;
  uint64_t v27 = a2;
  uint64_t v26 = a3;
  uint64_t v25 = a1;
  uint64_t v24 = 0LL;
  unsigned int v23 = 0;
  if (a1) {
    unsigned int v21 = *(_DWORD *)(v25 + 52);
  }
  else {
    unsigned int v21 = *(_DWORD *)(v27 + 24);
  }
  unsigned int v23 = v21;
  if (v21)
  {
    if (v27
      && (v22[1] = v27, v33 = v27, v32 = 0LL, v31 = *(void *)(v27 + 16), v32 = v31, uint64_t v30 = v31, (v34 = v31) == 0)
      && (*(_BYTE *)(v27 + 30) & 1) != 0)
    {
      if (*(void *)(v27 + 56))
      {
        os_release(*(void **)(v27 + 56));
        *(void *)(v27 + 56) = 0LL;
      }

      _dispatch_destruct_reply_port(v23, 1u);
      return 0LL;
    }

    else
    {
      v22[0] = 0LL;
      uint64_t v24 = dispatch_mach_msg_create(0LL, 0x18uLL, 0LL, v22, a5, a6, a7, a8);
      *(_DWORD *)(v22[0] + 12) = v23;
      if (v25)
      {
        v24[7] = *(void *)(v25 + 56);
        v24[4] = *(void *)(v25 + 32);
        v24[8] = *(void *)(v25 + 64);
        if (v24[8])
        {
          uint64_t v35 = (void *)v24[8];
          os_retain(v35);
        }
      }

      else
      {
        v24[7] = *(unsigned int *)(v27 + 40);
        v24[4] = *(void *)(v27 + 48);
        v24[8] = *(void *)(v27 + 56);
        *(void *)(v27 + 56) = 0LL;
      }

      _dispatch_mach_msg_set_reason((uint64_t)v24, 0, v26, v8, v9, v10, v11, v12);
      _dispatch_thread_getspecific(0LL);
      _dispatch_log("%u\t%p\tmachport[0x%08x]: reply disconnected, ctxt %p", v13, v14, v15, v16, v17, v18, v19, 1005LL);
      return v24;
    }
  }

  else
  {
    if (!v25 && *(void *)(v27 + 56))
    {
      os_release(*(void **)(v27 + 56));
      *(void *)(v27 + 56) = 0LL;
    }

    return 0LL;
  }

void _dispatch_destruct_reply_port(unsigned int a1, unsigned int a2)
{
  int v8 = thread_destruct_special_reply_port(a1, a2);
  if (v8 == -301)
  {
    qword_E4D78 = (uint64_t)"MIG_REPLY_MISMATCH";
    qword_E4DA8 = -301LL;
    __break(1u);
    JUMPOUT(0x7BCF8LL);
  }

  if (v8) {
    _dispatch_bug(515LL, v8, v2, v3, v4, v5, v6, v7);
  }
}

uint64_t _dispatch_mach_send_drain( uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v45 = a3;
  uint64_t v44 = *(void *)(a1 + 120);
  unsigned int v40 = (*(void *)(v44 + 64) & 0x700000000uLL) >> 32;
  char v36 = 0;
  unsigned int v35 = 0;
  do
  {
LABEL_2:
    if (!*(void *)(v44 + 72))
    {
      uint64_t v27 = (unint64_t *)(v44 + 64);
      do
      {
        if (_os_atomic_mo_has_acquire(3)) {
          unint64_t v10 = __ldaxr(v27);
        }
        else {
          unint64_t v10 = __ldxr(v27);
        }
        unint64_t v39 = v10;
        if ((v10 & 0x2000000000LL) != 0) {
          unint64_t v38 = v10 & 0xFFFFFFC7FFFFFFFFLL;
        }
        else {
          unint64_t v38 = 0LL;
        }
        if (_os_atomic_mo_has_release(3)) {
          BOOL v28 = __stlxr(v38, v27) == 0;
        }
        else {
          BOOL v28 = __stxr(v38, v27) == 0;
        }
      }

      while (!v28);
      goto LABEL_99;
    }

    uint64_t v34 = *(void *)(v44 + 80);
    if (!v34) {
      uint64_t v34 = _dispatch_wait_for_enqueuer((unint64_t *)(v44 + 80), v44 + 72);
    }
    uint64_t v41 = (unint64_t *)v34;
    while (1)
    {
      int v33 = v45;
      v45 &= ~8u;
      uint64_t v32 = (unint64_t *)v41[2];
      *(void *)(v44 + 8_dispatch_source_set_handler((uint64_t)source, handler, 2LL, 0) = v32;
      if (!v32)
      {
        uint64_t v30 = (unint64_t *)(v44 + 72);
        while (1)
        {
          unint64_t v8 = _os_atomic_mo_has_acquire(3) ? __ldaxr(v30) : __ldxr(v30);
          if (!_os_atomic_mo_has_release(3)) {
            BOOL v31 = __stxr(0LL, v30) == 0;
          }
          else {
            BOOL v31 = __stlxr(0LL, v30) == 0;
          }
          if (v31) {
            goto LABEL_20;
          }
        }

        __clrex();
        uint64_t v29 = v41[2];
        if (!v29) {
          uint64_t v29 = _dispatch_wait_for_enqueuer(v41 + 2, v44 + 72);
        }
        uint64_t v32 = (unint64_t *)v29;
        *(void *)(v44 + 8_dispatch_source_set_handler((uint64_t)source, handler, 2LL, 0) = v29;
      }

LABEL_99:
    if ((v39 & 0x800000000LL) != 0)
    {
      unsigned int v50 = _dispatch_thread_getspecific(0x19uLL);
      if ((BYTE4(v39) & 7u) > (v50 & 0xF0000) >> 16) {
        _dispatch_thread_setspecific(25LL, v50 & 0xFFF0FFFF | ((BYTE4(v39) & 7) << 16));
      }
    }

    unsigned int v40 = (v38 & 0x700000000LL) >> 32;
  }

  while ((_DWORD)v38);
  if ((v38 & 0x1000000000LL) != 0)
  {
    _dispatch_mach_push_send_barrier_drain(a1, v40);
    char v48 = v36 & 1;
  }

  else
  {
    if (!v38 && ((*(_WORD *)(a1 + 118) >> 1) & 1) != 0 && ((*(_WORD *)(a1 + 116) >> 3) & 1) == 0) {
      v35 |= 0x12u;
    }
    if (((v39 ^ v38) & 0x8000000000LL) != 0)
    {
      if (v35) {
        v35 |= 1u;
      }
      else {
        _dispatch_release_2((unsigned int *)a1);
      }
    }

    if (v35)
    {
      if ((*(_WORD *)(a1 + 118) & 1) != 0) {
        unsigned int v16 = (v38 & 0x700000000LL) >> 32;
      }
      else {
        unsigned int v16 = 0;
      }
      (*(void (**)(uint64_t, void, void))(*(void *)a1 + 64LL))(a1, v16, v35);
    }

    char v48 = v36;
  }

  return v48 & 1;
}

void _dispatch_mach_msg_not_sent(uint64_t a1, dispatch_object_s *a2, uint64_t a3)
{
  char v47 = a2;
  uint64_t v46 = a1;
  uint64_t v45 = a3;
  uint64_t v44 = a2;
  reply_disconnected = 0LL;
  uint64_t v42 = 0LL;
  msg = (unsigned int *)_dispatch_mach_msg_get_msg((uint64_t)a2);
  unsigned int v40 = 0;
  unsigned int v40 = *((_DWORD *)v44 + 12);
  uint64_t v3 = _dispatch_thread_getspecific(0LL);
  uint64_t v4 = msg[2];
  uint64_t v5 = msg[5];
  uint64_t v6 = *((void *)v44 + 4);
  uint64_t v7 = msg[4];
  uint64_t v8 = *((unsigned int *)v44 + 13);
  int v37 = v35;
  v35[1] = v3;
  v35[2] = v4;
  v35[3] = v5;
  v35[4] = v6;
  v35[5] = v40;
  v35[6] = v7;
  v35[7] = v8;
  _dispatch_log( "%u\t%p\tmachport[0x%08x]: not sent msg id 0x%x, ctxt %p, msg_opts 0x%x, kvoucher 0x%08x, reply on 0x%08x",  v9,  v10,  v11,  v12,  v13,  v14,  v15,  1021LL);
  uint64_t v21 = 0LL;
  uint64_t v39 = 0LL;
  if ((v40 & 2) == 0) {
    uint64_t v21 = 5LL;
  }
  uint64_t v39 = v21;
  if (((*(_WORD *)(v46 + 116) >> 4) & 1) != 0 && *((void *)v44 + 4))
  {
    uint64_t v22 = *((void *)v44 + 4);
    uint64_t v50 = v46;
    uint64_t v49 = v22;
    uint64_t v48 = 0LL;
    uint64_t v48 = (*(uint64_t (**)(uint64_t))((char *)&dword_10 + (void)_dispatch_mach_xpc_hooks))(v22);
    if (!v48) {
      uint64_t v48 = v50;
    }
    uint64_t v42 = v48;
  }

  unint64_t v38 = v44;
  if (v45) {
    uint64_t v36 = v45;
  }
  else {
    uint64_t v36 = 0LL;
  }
  if (v42) {
    uint64_t v23 = 12LL;
  }
  else {
    uint64_t v23 = 7LL;
  }
  reply_disconnected = (dispatch_object_s *)_dispatch_mach_msg_create_reply_disconnected( (uint64_t)v38,  v36,  v23,  v16,  v17,  v18,  v19,  v20);
  _dispatch_mach_msg_set_reason((uint64_t)v44, 0, v39, v24, v25, v26, v27, v28);
  _dispatch_mach_handle_or_push_received_msg(v46, v44, 0LL);
  if (reply_disconnected)
  {
    if (v42)
    {
      uint64_t v58 = v46;
      mach_msg_option_t v57 = reply_disconnected;
      uint64_t v56 = v42;
      int v55 = 0LL;
      int v55 = _dispatch_mach_msg_async_reply_wrap((uint64_t)reply_disconnected, v46);
      uint64_t v54 = v56;
      int v53 = v55;
      uint64_t v62 = v56;
      int v61 = v55;
      int v60 = 0;
      int v59 = 0;
      uint64_t v65 = v56;
      uint64_t v64 = v55;
      uint64_t v32 = *(void (**)(uint64_t, void *, uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)v56 + 72LL);
      uint64_t v52 = v56;
      int v51 = v55;
      unint64_t v63 = *((void *)v57 + 7);
      v63 &= 0x3FFF00uLL;
      v63 >>= 8;
      unsigned int v33 = __clz(__rbit32(v63));
      if ((_DWORD)v63) {
        uint64_t v34 = v33 + 1;
      }
      else {
        uint64_t v34 = 0LL;
      }
      v32(v52, v51, v34, v29, v30, v31);
    }

    else
    {
      _dispatch_mach_handle_or_push_received_msg(v46, reply_disconnected, 0LL);
    }
  }

uint64_t _dispatch_mach_msg_send(uint64_t a1, void *a2, uint64_t a3, unsigned int a4, int a5)
{
  unsigned int v134 = v164;
  uint64_t v180 = a2;
  uint64_t v179 = (unsigned int *)a1;
  uint64_t v178 = a3;
  unsigned int v177 = a4;
  int v176 = a5;
  uint64_t v133 = 0LL;
  uint64_t v175 = 0LL;
  uint64_t v175 = *(void *)(a1 + 120);
  unsigned int v174 = a2;
  reply_disconnected = 0LL;
  uint64_t v172 = 0LL;
  uint64_t v172 = a2[8];
  uint64_t v171 = 0LL;
  int v135 = 0;
  unsigned int v170 = 0;
  char v169 = 0;
  uint64_t msg = 0LL;
  uint64_t msg = _dispatch_mach_msg_get_msg((uint64_t)a2);
  BOOL v167 = 0;
  BOOL v167 = (*(_DWORD *)msg & 0x1F) == 18;
  unsigned int v166 = 0;
  unsigned int v166 = *((_DWORD *)v174 + 13);
  memset(v287, 0, sizeof(v287));
  uint64_t v165 = 0LL;
  memset(v164, 0, sizeof(v164));
  int v163 = 0;
  if (!v167)
  {
    *((_WORD *)v179 + 59) &= ~1u;
    uint64_t v12 = *(void *)(v175 + 48);
    BOOL v132 = 0;
    if (v12) {
      BOOL v132 = v174 != *(void **)(v175 + 48);
    }
    if (v132)
    {
      uint64_t v162 = v175;
      uint64_t v200 = v175;
      uint64_t v199 = 0LL;
      uint64_t v198 = *(void *)(v175 + 16);
      uint64_t v199 = v198;
      uint64_t v197 = v198;
      uint64_t v225 = v198;
      BOOL v131 = 0;
      if (v198) {
        BOOL v131 = _dispatch_thread_getspecific(0x14uLL) != &_dispatch_mgr_q;
      }
      if (v131)
      {
        *((_WORD *)v179 + 59) |= 1u;
        return v170;
      }

      uint64_t v13 = *(void *)(v175 + 48);
      int v236 = v179;
      uint64_t v235 = v13;
      int v234 = 0;
      if ((v179[29] & 0x10) != 0)
      {
        uint64_t v233 = v235;
        if (_dispatch_mach_msg_get_reply_port(v235))
        {
          uint64_t v14 = *(void *)(v235 + 32);
          uint64_t v239 = v236;
          uint64_t v238 = v14;
          uint64_t v237 = 0LL;
          uint64_t v237 = (*(uint64_t (**)(uint64_t))((char *)&dword_10 + (void)_dispatch_mach_xpc_hooks))(v14);
          if (!v237) {
            uint64_t v237 = (uint64_t)v239;
          }
          uint64_t v241 = v237;
          uint64_t v240 = 1830LL;
          if (!v237) {
            _dispatch_abort(v240, 0LL, v15, v16, v17, v18, v19, v20);
          }
        }
      }

      if ((v234 & 0x40000) != 0)
      {
        *(void *)(v235 + 56) = 0LL;
      }

      else
      {
        int v232 = 1;
        if ((v234 & 4) != 0) {
          v232 |= 2u;
        }
        unint64_t v243 = 0LL;
        int v242 = v232;
        if ((v232 & 1) != 0)
        {
          v245 = 0LL;
          v245 = _dispatch_thread_getspecific(4uLL);
          unint64_t v243 = (unint64_t)v245;
        }

        unint64_t v246 = v243;
        v243 &= 0xFFFFFFu;
        if ((v242 & 2) != 0 || (unint64_t v130 = v243, v250 = 5, v249 = 4096LL, v243 <= 0x10FF))
        {
          uint64_t v244 = v243;
        }

        else
        {
          int v248 = 5;
          uint64_t v247 = 4096LL;
          uint64_t v244 = 4351LL;
        }

        *(void *)(v235 + 56) = v244;
      }

      uint64_t v251 = 0LL;
      uint64_t v251 = _dispatch_thread_getspecific(0x1CuLL);
      if (v251)
      {
        object = v251;
        os_retain(v251);
      }

      *(void *)(v235 + 64) = v251;
      uint64_t v129 = 0LL;
      uint64_t v21 = _dispatch_thread_getspecific(0LL);
      uint64_t v22 = *(void *)(v235 + 64);
      unsigned int v103 = (void *)v235;
      uint64_t v102 = v22;
      unsigned int v101 = v21;
      _dispatch_log("%u\t%p\tvoucher[%p]: mach-msg[%p] set", v23, v24, v25, v26, v27, v28, v29, 1847LL);
      v234 |= _dispatch_mach_send_options();
      *(_DWORD *)(v235 + 48) = v234;
      uint64_t v161 = *(void *)(v175 + 48);
      if (!_dispatch_mach_msg_send(v179, v161, 0LL, v177, 0LL))
      {
        unint64_t v160 = 0LL;
        unint64_t v160 = *(void **)(*(void *)(v175 + 48) + 64LL);
        if (v160)
        {
          unsigned int v226 = v160;
          os_release(v160);
          *(void *)(*(void *)(v175 + 48) + 64LL) = 0LL;
        }

        return v170;
      }

      if ((v179[29] & 0x20) != 0) {
        _dispatch_mach_arm_no_senders((uint64_t)v179, 1);
      }
      *(void *)(v175 + 48) = 0LL;
    }
  }

  mach_error_t error_value = 0;
  int v158 = 0;
  unsigned int v157 = 0;
  unsigned int v157 = *((_DWORD *)v174 + 12);
  if ((v157 & 2) != 0) {
    goto LABEL_117;
  }
  unsigned int v156 = 0;
  int v158 = (HIWORD(v157) << 16) | 1;
  if (v167)
  {
LABEL_88:
    if ((v157 & 4) != 0)
    {
      if ((*(_BYTE *)(v178 + 30) & 1) != 0)
      {
        v158 |= 0x100000u;
        _dispatch_clear_thread_reply_port(v166);
      }

      _dispatch_mach_reply_waiter_register((uint64_t)v179, v178, v166, v174);
    }

    __int128 v147 = (unint64_t)msg;
    uint64_t v148 = *(unsigned int *)(msg + 4);
    *(void *)&v287[1] = v148;
    *((_OWORD *)v134 + 67) = (unint64_t)msg;
    unsigned int v125 = (char *)&v287[1] + 8;
    *(void *)&__int128 v145 = v164;
    *((void *)&v145 + _dispatch_source_set_handler((uint64_t)source, handler, 2LL, 1) = 0LL;
    uint64_t v126 = v146;
    if (v163) {
      int v124 = v164[0];
    }
    else {
      int v124 = 0;
    }
    uint64_t v64 = v125;
    *uint64_t v126 = v124;
    v146[1] = 0;
    __int128 v65 = v145;
    *((void *)v64 + 2) = v146[0];
    *(_OWORD *)uint64_t v64 = v65;
    __int128 v66 = *(_OWORD *)msg;
    uint64_t v144 = *(void *)(msg + 16);
    __int128 v143 = v66;
    mach_error_t error_value = mach_msg2((int **)v287, v158 | 0x500000000LL, (unsigned int *)&v143, 2u, 0, 0, 0LL, v156);
    uint64_t v122 = _dispatch_thread_getspecific(0LL);
    unint64_t v119 = (const char *)v174[4];
    uint64_t v121 = *(unsigned int *)(msg + 8);
    uint64_t v120 = (void *)*(unsigned int *)(msg + 20);
    uint64_t v118 = v158;
    uint64_t v117 = v157;
    uint64_t v116 = *(unsigned int *)(msg + 16);
    uint64_t v115 = v166;
    uint64_t v67 = mach_error_string(error_value);
    unsigned int v123 = &v100;
    uint64_t v110 = error_value;
    uint64_t v109 = v67;
    uint64_t v108 = v115;
    uint64_t v107 = v116;
    uint64_t v106 = v117;
    uint64_t v105 = v118;
    unsigned int v104 = v119;
    unsigned int v103 = v120;
    uint64_t v102 = v121;
    unsigned int v101 = v122;
    _dispatch_log( "%u\t%p\tmachport[0x%08x]: sent msg id 0x%x, ctxt %p, opts 0x%x, msg_opts 0x%x, kvoucher 0x%08x, reply on 0x%08x: %s - 0x%x",  v68,  v69,  v70,  v71,  v72,  v73,  v74,  1193LL);
    int v114 = 0;
    if (error_value) {
      int v114 = (v157 >> 2) & 1;
    }
    if ((v114 & 1) != 0)
    {
      int v142 = 36;
      uint64_t v213 = v178;
      uint64_t v212 = 1196LL;
      if (!v178) {
        _dispatch_abort(v212, 0LL, v6, v7, v8, v9, v10, v11);
      }
      _dispatch_mach_reply_unregister(v179, v178, v142);
    }

    if ((v169 & 1) != 0)
    {
      if (error_value == 268435461 && *(_DWORD *)(msg + 16))
      {
        uint64_t v141 = error_value;
        qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Voucher port corruption";
        qword_E4DA8 = error_value;
        __break(1u);
        JUMPOUT(0x7E344LL);
      }

      mach_port_name_t v140 = 0;
      int v231 = (_DWORD *)msg;
      char v230 = 0;
      int v229 = 0;
      int v229 = HIWORD(*(_DWORD *)msg) & 0x1F;
      mach_port_name_t v228 = 0;
      mach_port_name_t v228 = *(_DWORD *)(msg + 16);
      mach_port_name_t v227 = 0;
      if ((v229 == 19 || v229 == 17) && v228)
      {
        uint64_t v75 = _dispatch_thread_getspecific(0LL);
        if ((v230 & 1) != 0) {
          int v83 = "move-send";
        }
        else {
          int v83 = "copy-send";
        }
        unsigned int v104 = v83;
        unsigned int v103 = v231;
        uint64_t v102 = v228;
        unsigned int v101 = v75;
        _dispatch_log("%u\t%p\tkvoucher[0x%08x]: msg[%p] clear %s", v76, v77, v78, v79, v80, v81, v82, 520LL);
        if (v229 == 17)
        {
          if ((v230 & 1) != 0) {
            mach_port_name_t v227 = v228;
          }
          else {
            _voucher_dealloc_mach_voucher(v228);
          }
        }

        v231[4] = 0;
        *v231 &= 0xFFE0FFFF;
      }

      mach_port_name_t v140 = v227;
    }

LABEL_117:
    if (error_value == 268435460 && (v158 & 0x10) != 0)
    {
      if (*(_DWORD *)(msg + 8) == -1)
      {
        *(_DWORD *)msg &= 0xFFFFFFE0;
        *(_DWORD *)msg |= 0x13u;
      }

      if ((v158 & 0x80) != 0) {
        _dispatch_mach_notification_set_armed(v175, v5, v6, v7, v8, v9, v10, v11);
      }
      else {
        *((_WORD *)v179 + 59) |= 1u;
      }
    }

    else
    {
      uint64_t v139 = 0LL;
      uint64_t v139 = *((void *)v179 + 11);
      if ((v157 & 4) == 0 && !error_value)
      {
        if (v166)
        {
          uint64_t v138 = v139;
          uint64_t v188 = v139;
          uint64_t v187 = 0LL;
          uint64_t v186 = *(void *)(v139 + 16);
          uint64_t v187 = v186;
          uint64_t v185 = v186;
          uint64_t v222 = v186;
          if (!v186 || *(_DWORD *)(v139 + 24) != v166) {
            _dispatch_mach_reply_kevent_register(v179, v166, v174);
          }
        }
      }

      BOOL v113 = 0;
      if (!v167)
      {
        uint64_t v84 = *(void **)(v175 + 48);
        BOOL v113 = 0;
        if (v174 == v84)
        {
          uint64_t v137 = v175;
          uint64_t v184 = v175;
          uint64_t v183 = 0LL;
          uint64_t v182 = *(void *)(v175 + 16);
          uint64_t v183 = v182;
          uint64_t v181 = v182;
          uint64_t v221 = v182;
          BOOL v113 = v182 != 0;
        }
      }

      if (v113)
      {
        uint64_t v273 = v179;
        int v112 = 0;
        unsigned int v272 = 5;
        dispatch_assert_queue_V2((dispatch_queue_t)&_dispatch_mgr_q);
        uint64_t v271 = *((void *)v273 + 15);
        _dispatch_unote_unregister(v271, v272, v85, v86, v87, v88, v89, v90);
        *(_DWORD *)(*((void *)v273 + 15) + 24LL) = v112;
      }

      if (error_value)
      {
        if ((v179[29] & 0x10) != 0 && v174[4])
        {
          uint64_t v91 = v174[4];
          int v203 = v179;
          uint64_t v202 = v91;
          uint64_t v201 = 0LL;
          uint64_t v201 = (*(uint64_t (**)(uint64_t))((char *)&dword_10 + (void)_dispatch_mach_xpc_hooks))(v91);
          if (!v201) {
            uint64_t v201 = (uint64_t)v203;
          }
          uint64_t v171 = v201;
        }

        int v136 = v174;
        if (v178) {
          uint64_t v111 = v178;
        }
        else {
          uint64_t v111 = 0LL;
        }
        if (v171) {
          uint64_t v92 = 12LL;
        }
        else {
          uint64_t v92 = 7LL;
        }
        reply_disconnected = (dispatch_object_s *)_dispatch_mach_msg_create_reply_disconnected( (uint64_t)v136,  v111,  v92,  v7,  v8,  v9,  v10,  v11);
      }

      _dispatch_mach_msg_set_reason((uint64_t)v174, error_value, 0LL, v7, v8, v9, v10, v11);
      if ((v176 & 8) != 0 && (v157 & 1) != 0) {
        v170 |= 2u;
      }
      else {
        _dispatch_mach_handle_or_push_received_msg((uint64_t)v179, (dispatch_object_s *)v174, 0LL);
      }
      if (reply_disconnected)
      {
        if (v171)
        {
          int v211 = v179;
          uint64_t v210 = reply_disconnected;
          uint64_t v209 = v171;
          int v208 = 0LL;
          int v208 = _dispatch_mach_msg_async_reply_wrap((uint64_t)reply_disconnected, (uint64_t)v179);
          uint64_t v207 = v209;
          unsigned int v206 = v208;
          uint64_t v219 = v209;
          unsigned int v218 = v208;
          int v217 = 0;
          int v216 = 0;
          uint64_t v286 = v209;
          v285 = v208;
          uint64_t v96 = *(void (**)(uint64_t, void *, uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)v209 + 72LL);
          uint64_t v205 = v209;
          int v204 = v208;
          LODWORD(v2memset(__b, 0, 20) = *((void *)v210 + 7);
          v220 &= 0x3FFF00u;
          v220 >>= 8;
          unsigned int v97 = __clz(__rbit32(v220));
          if ((_DWORD)v220) {
            uint64_t v98 = v97 + 1;
          }
          else {
            uint64_t v98 = 0LL;
          }
          v96(v205, v204, v98, v93, v94, v95);
        }

        else
        {
          _dispatch_mach_handle_or_push_received_msg((uint64_t)v179, reply_disconnected, 0LL);
        }
      }

      v170 |= 1u;
    }

    return v170;
  }

  if (v174 != *(void **)(v175 + 48)) {
    *(_DWORD *)(msg + 8) = *(_DWORD *)(v175 + 92);
  }
  if (_dispatch_thread_getspecific(0x14uLL) != &_dispatch_mgr_q)
  {
LABEL_47:
    v158 |= 0x10u;
    if (v172 && *(void *)(v172 + 48))
    {
      uint64_t v42 = v134;
      int v163 = 32;
      *(void *)&__int128 v149 = 59821818LL;
      *((void *)&v149 + _dispatch_source_set_handler((uint64_t)source, handler, 2LL, 1) = *(void *)(v172 + 48);
      __int128 v150 = *(_OWORD *)(v172 + 56);
      __int128 v43 = v149;
      *(_OWORD *)(v134 + 6) = v150;
      *(_OWORD *)(v42 + 2) = v43;
    }

    if (v163) {
      v164[0] = v163 + 8;
    }
    uint64_t v44 = _dispatch_thread_getspecific(0LL);
    unsigned int v103 = v174;
    uint64_t v102 = v172;
    unsigned int v101 = v44;
    _dispatch_log("%u\t%p\tvoucher[%p]: mach-msg[%p] msg_set", v45, v46, v47, v48, v49, v50, v51, 1149LL);
    unsigned int v262 = (_DWORD *)msg;
    uint64_t v261 = v172;
    if ((*(_DWORD *)msg & 0x1F0000) != 0)
    {
      char v263 = 0;
    }

    else
    {
      int mach_voucher = 0;
      if (v261)
      {
        int mach_voucher = _voucher_get_mach_voucher(v261);
      }

      else
      {
        int v280 = &_voucher_task_mach_voucher_pred;
        int v279 = 0LL;
        dispatch_function_t v278 = (dispatch_function_t)_voucher_task_mach_voucher_init;
        if (_voucher_task_mach_voucher_pred != -1) {
          dispatch_once_f(v280, v279, v278);
        }
        int mach_voucher = _voucher_task_mach_voucher;
      }

      int v276 = v262;
      unsigned int v275 = mach_voucher;
      char v274 = 0;
      if ((*v262 & 0x1F0000) != 0)
      {
        char v277 = 0;
      }

      else if (v275)
      {
        v276[4] = v275;
        if ((v274 & 1) != 0) {
          int v52 = 1114112;
        }
        else {
          int v52 = 1245184;
        }
        *v276 |= v52;
        int v53 = _dispatch_thread_getspecific(0LL);
        if ((v274 & 1) != 0) {
          int v61 = "move-send";
        }
        else {
          int v61 = "copy-send";
        }
        unsigned int v104 = v61;
        unsigned int v103 = v276;
        uint64_t v102 = v275;
        unsigned int v101 = v53;
        _dispatch_log("%u\t%p\tkvoucher[0x%08x]: msg[%p] set %s", v54, v55, v56, v57, v58, v59, v60, 476LL);
        char v277 = 1;
      }

      else
      {
        char v277 = 0;
      }

      char v263 = v277;
    }

    char v169 = v263;
    unsigned int v268 = v174;
    unsigned int v267 = v177;
    uint64_t v266 = &v158;
    unsigned int v281 = v177;
    if (v177 > 4) {
      int v128 = 5;
    }
    else {
      int v128 = v281;
    }
    unsigned int v267 = v128;
    if (v128)
    {
      unsigned __int8 v265 = 0;
      int v264 = 0;
      unint64_t v270 = v268[7];
      v270 &= 0x3FFF00uLL;
      v270 >>= 8;
      char v62 = __clz(__rbit32(v270));
      if ((_DWORD)v270) {
        unsigned __int8 v63 = v62 + 1;
      }
      else {
        unsigned __int8 v63 = 0;
      }
      unsigned __int8 v265 = v63;
      uint64_t v282 = v268[7];
      uint64_t v284 = v282;
      BOOL v127 = 0;
      if ((v282 & 0x22000000) == 0) {
        BOOL v127 = (v284 & 0x3F00) != 0;
      }
      if (v127)
      {
        uint64_t v282 = v282;
        int v283 = (char)v282 + 1;
      }

      else
      {
        int v283 = 0;
      }

      int v264 = v283;
      *v266 |= 0x20u;
      unsigned int v269 = mach_msg_priority_encode_inline(v267, v265, v264);
    }

    else
    {
      unsigned int v269 = 0;
    }

    unsigned int v156 = v269;
    if (v166 && (v179[29] & 0x80) != 0) {
      v158 |= 0x200u;
    }
    goto LABEL_88;
  }

  uint64_t v155 = v175;
  uint64_t v196 = v175;
  uint64_t v195 = 0LL;
  uint64_t v194 = *(void *)(v175 + 16);
  uint64_t v195 = v194;
  uint64_t v193 = v194;
  uint64_t v224 = v194;
  if (!v194)
  {
    int v30 = *(_DWORD *)(msg + 8);
    unsigned int v257 = v179;
    int v256 = v30;
    dispatch_assert_queue_V2((dispatch_queue_t)&_dispatch_mgr_q);
    *(_DWORD *)(*((void *)v257 + 15) + 24LL) = v256;
    BOOL v255 = 0;
    uint64_t v254 = *((void *)v257 + 15);
    BOOL v255 = _dispatch_unote_register(v254, -4LL, 0x2000000LL, v31, v32, v33, v34, v35);
    BOOL v259 = v255;
    uint64_t v258 = 1743LL;
    if (!v255) {
      _dispatch_bug(v258, v259, v36, v37, v38, v39, v40, v41);
    }
    BOOL v253 = v255;
    uint64_t v154 = v175;
    uint64_t v192 = v175;
    uint64_t v191 = 0LL;
    uint64_t v190 = *(void *)(v175 + 16);
    uint64_t v191 = v190;
    uint64_t v189 = v190;
    uint64_t v223 = v190;
    BOOL v215 = v190 != 0;
    uint64_t v214 = 1125LL;
    if (!v190) {
      _dispatch_abort(v214, v215, v36, v37, v38, v39, v40, v41);
    }
  }

  char v153 = 0;
  char v152 = *(_BYTE *)(v175 + 30);
  char v153 = v152 & 1;
  char v151 = v152 & 1;
  if ((v152 & 1) == 0)
  {
    v158 |= 0x80u;
    goto LABEL_47;
  }

  return v170;
}

void _dispatch_mach_push_send_barrier_drain(uint64_t a1, unsigned int a2)
{
  uint64_t v10 = _dispatch_thread_getspecific(0x16uLL);
  if (v10)
  {
    _dispatch_thread_setspecific(22LL, v10[2]);
    uint64_t v9 = v10;
  }

  else
  {
    uint64_t v9 = (void *)_dispatch_continuation_alloc_from_heap();
  }

  void *v9 = &unk_E0CD0;
  v9[4] = 0LL;
  v9[5] = 0LL;
  v9[3] = -1LL;
  v9[1] = -1LL;
  _dispatch_lane_push(a1, v9, a2, v2, v3, v4, v5, v6);
}

void _dispatch_clear_thread_reply_port(int a1)
{
  unsigned int v15 = _dispatch_thread_getspecific(8uLL);
  if (a1 == v15)
  {
    _dispatch_thread_setspecific(8LL, 0LL);
    _dispatch_thread_getspecific(0LL);
    _dispatch_log("%u\t%p\tmachport[0x%08x]: cleared thread sync reply port", v8, v9, v10, v11, v12, v13, v14, 555LL);
  }

  else if (v15)
  {
    _dispatch_thread_getspecific(0LL);
    _dispatch_log( "%u\t%p\tmachport[0x%08x]: did not clear thread sync reply port (found 0x%08x)",  v1,  v2,  v3,  v4,  v5,  v6,  v7,  548LL);
  }

void *_dispatch_mach_reply_waiter_register(uint64_t a1, uint64_t a2, int a3, void *a4)
{
  *(void *)(a2 + 8) = ~a1;
  *(_BYTE *)(a2 + 28) = -8;
  *(_DWORD *)(a2 + 24) = a3;
  if ((*(_BYTE *)(a2 + 30) & 1) == 0)
  {
    if (a4[8])
    {
      unsigned int v15 = (void *)a4[8];
      os_retain(v15);
      *(void *)(a2 + 56) = v15;
    }

    *(_DWORD *)(a2 + 4_dispatch_source_set_handler((uint64_t)source, handler, 2LL, 0) = a4[7];
    *(void *)(a2 + 48) = a4[4];
  }

  _dispatch_thread_getspecific(0LL);
  _dispatch_log("%u\t%p\tmachport[0x%08x]: registering for sync reply, ctxt %p", v4, v5, v6, v7, v8, v9, v10, 432LL);
  return _dispatch_mach_reply_list_insert(*(void *)(a1 + 120), a2);
}

uint64_t mach_msg2( int **a1, uint64_t a2, unsigned int *a3, unsigned int a4, unsigned int a5, unsigned int a6, uint64_t a7, unsigned int a8)
{
  if ((a2 & 0x100000000LL) != 0) {
    uint64_t v10 = *a1;
  }
  else {
    uint64_t v10 = (int *)a1;
  }
  if ((a2 & 1) != 0 && *v10 < 0) {
    unsigned int v9 = v10[6];
  }
  else {
    unsigned int v9 = 0;
  }
  return mach_msg2_internal( a1,  a2,  *a3 | ((unint64_t)a4 << 32),  a3[2] | ((unint64_t)a3[3] << 32),  a3[4] | (unint64_t)((uint64_t)(int)a3[5] << 32),  v9 | ((unint64_t)a6 << 32),  a5 | ((unint64_t)a8 << 32),  a7);
}

void _dispatch_mach_reply_kevent_register(unsigned int *a1, unsigned int a2, void *a3)
{
  unint64_t v35 = (unint64_t)a1;
  unsigned int v34 = a2;
  uint64_t v33 = a3;
  unsigned int v31 = 0;
  unsigned int v30 = 0;
  unsigned int v29 = 0;
  unsigned int v28 = 0;
  unint64_t v27 = 0LL;
  uint64_t v32 = _dispatch_unote_create_with_handle((uint64_t)&_dispatch_mach_type_reply, a2, 0LL);
  uint64_t v48 = *(_BYTE *)(v32 + 29) & 1;
  uint64_t v47 = 447LL;
  if (!v48) {
    _dispatch_abort(v47, 0LL, v3, v4, v5, v6, v7, v8);
  }
  *(void *)(v32 + 8) = ~v35;
  if (v33[8])
  {
    uint64_t v49 = (void *)v33[8];
    os_retain(v49);
    *(void *)(v32 + 56) = v49;
  }

  *(_DWORD *)(v32 + 4_dispatch_source_set_handler((uint64_t)source, handler, 2LL, 0) = v33[7];
  *(void *)(v32 + 48) = v33[4];
  uint64_t v26 = 0LL;
  if (((*(_WORD *)(v35 + 116) >> 4) & 1) != 0 && v33[4])
  {
    uint64_t v9 = v33[4];
    unint64_t v46 = v35;
    uint64_t v45 = v9;
    uint64_t v44 = 0LL;
    uint64_t v44 = (*(uint64_t (**)(uint64_t))((char *)&dword_10 + (void)_dispatch_mach_xpc_hooks))(v9);
    if (!v44) {
      uint64_t v44 = v46;
    }
    uint64_t v26 = (unsigned int *)v44;
  }

  if (((*(_WORD *)(v35 + 116) >> 7) & 1) != 0) {
    *(_DWORD *)(v32 + 32) |= 0x200u;
  }
  if (!v26 || (BOOL v25 = 0, v26 == (unsigned int *)v35))
  {
    uint64_t v43 = *(void *)(v35 + 88);
    uint64_t v42 = 0LL;
    uint64_t v41 = *(void *)(v43 + 16);
    uint64_t v42 = v41;
    uint64_t v40 = v41;
    uint64_t v52 = v41;
    BOOL v25 = (v41 & 0xFFFFFFFFFFFFFFFCLL) != 0;
  }

  if (v25)
  {
    uint64_t v39 = *(void *)(v35 + 88);
    uint64_t v38 = 0LL;
    uint64_t v37 = *(void *)(v39 + 16);
    uint64_t v38 = v37;
    uint64_t v36 = v37;
    uint64_t v51 = v37;
    unint64_t v27 = v37 & 0xFFFFFFFFFFFFFFFCLL;
    unsigned int v30 = *(_DWORD *)(v35 + 84);
  }

  else if ((*(void *)(*(void *)v26 + 16LL) & 0x10000LL) != 0)
  {
    unint64_t v27 = -4LL;
    int v53 = v26;
    BOOL v24 = 0;
    if (v24) {
      unsigned int v30 = v26[21];
    }
    else {
      unsigned int v30 = 0x2000000;
    }
  }

  else
  {
    unsigned int v30 = _dispatch_queue_compute_priority_and_wlh((uint64_t)v26, (uint64_t *)&v27);
    if (!v30)
    {
      unint64_t v27 = -4LL;
      unsigned int v30 = v26[21];
    }
  }

  uint64_t v56 = v33[7];
  char v55 = 0;
  BOOL v58 = (v56 & 0x20000000) == 0;
  uint64_t v57 = 458LL;
  if ((v56 & 0x20000000) != 0) {
    _dispatch_abort(v57, 0LL, v3, v4, v5, v6, v7, v8);
  }
  unsigned int v54 = v56;
  unint64_t v59 = v56 & 0x3FFF00;
  v59 >>= 8;
  unsigned int v10 = __clz(__rbit32(v59));
  if ((_DWORD)v59) {
    unsigned int v11 = v10 + 1;
  }
  else {
    unsigned int v11 = 0;
  }
  v54 |= v11 << 8;
  unsigned int v31 = v54;
  unsigned int v29 = v30 & 0x80000000;
  unsigned int v50 = v30 & 0xF000;
  unsigned int v28 = v50 >> 12;
  if ((v30 & 0xFFF) != 0)
  {
    v30 &= 0xFFFu;
    if (v30 < v31) {
      unsigned int v30 = v31;
    }
    v30 |= v29;
  }

  else if (v28 && v31)
  {
    unsigned int v30 = v31 | v29;
  }

  else if (!v28 || v31)
  {
    unsigned int v30 = 0x2000000;
    unint64_t v27 = -4LL;
  }

  else
  {
    unsigned int v30 = (v28 << 8) & 0xF00 | 0xFF | v29;
  }

  _dispatch_thread_getspecific(0LL);
  _dispatch_log("%u\t%p\tmachport[0x%08x]: registering for reply, ctxt %p", v12, v13, v14, v15, v16, v17, v18, 495LL);
  _dispatch_mach_reply_list_insert(*(void *)(v35 + 120), v32);
  if (!_dispatch_unote_register(v32, v27, v30, v19, v20, v21, v22, v23)) {
    _dispatch_mach_reply_unregister((unsigned int *)v35, v32, 52);
  }
}

uint64_t _dispatch_mach_send_options()
{
  unsigned int v0 = (_dispatch_thread_getspecific(4uLL) & 0x3FFF00) >> 8;
  unsigned int v1 = __clz(__rbit32(v0));
  if (v0) {
    unsigned int v2 = v1 + 1;
  }
  else {
    unsigned int v2 = 0;
  }
  BOOL v4 = 0;
  if (v2) {
    BOOL v4 = v2 <= 2;
  }
  if (v4) {
    return 0x40000LL;
  }
  else {
    return 0LL;
  }
}

uint64_t mach_msg_priority_encode_inline(unsigned __int8 a1, unsigned __int8 a2, char a3)
{
  unsigned int v4 = 0;
  if (a2 && a2 <= 6u) {
    unsigned int v4 = (a2 << 16) | ((a3 - 1) << 8);
  }
  if (a1 && a1 <= 6u) {
    v4 |= a1 << 20;
  }
  return v4;
}

void *_dispatch_mach_reply_list_insert(uint64_t a1, uint64_t a2)
{
  uint64_t v18 = (unsigned int *)(a1 + 40);
  unsigned int v17 = _dispatch_thread_getspecific(3uLL) & 0xFFFFFFFC;
  do
    unsigned int v8 = __ldaxr(v18);
  while (!v8 && __stlxr(v17, v18));
  if (v8) {
    _dispatch_unfair_lock_lock_slow(v18, 0x10000);
  }
  if (*(void *)(a2 + 72)) {
    _dispatch_abort(302LL, *(void *)(a2 + 72) == 0LL, v2, v3, v4, v5, v6, v7);
  }
  uint64_t v9 = *(void *)(a1 + 56);
  *(void *)(a2 + 64) = v9;
  if (v9) {
    *(void *)(*(void *)(a1 + 56) + 72LL) = a2 + 64;
  }
  *(void *)(a1 + 56) = a2;
  *(void *)(a2 + 72) = a1 + 56;
  uint64_t result = _dispatch_thread_getspecific(3uLL);
  uint64_t v13 = (unsigned int *)(a1 + 40);
  unsigned int v14 = *(_DWORD *)(a1 + 40);
  do
  {
    unsigned int v11 = v14;
    do
      unsigned int v12 = __ldaxr(v13);
    while (v12 == v14 && __stlxr(0, v13));
    unsigned int v14 = v12;
  }

  while (v12 != v11);
  return result;
}

void *_dispatch_mach_msg_async_reply_wrap(uint64_t a1, uint64_t a2)
{
  uint64_t v6 = _dispatch_thread_getspecific(0x16uLL);
  if (v6)
  {
    _dispatch_thread_setspecific(22LL, v6[2]);
    uint64_t v5 = v6;
  }

  else
  {
    uint64_t v5 = (void *)_dispatch_continuation_alloc_from_heap();
  }

  *uint64_t v5 = &unk_E0D78;
  v5[6] = a1;
  v5[7] = a2;
  v5[1] = -1LL;
  v5[3] = -1LL;
  return v5;
}

uint64_t _dispatch_mach_send_push_and_trydrain( uint64_t a1, unint64_t a2, unsigned int a3, unsigned int a4)
{
  uint64_t v34 = *(void *)(a1 + 120);
  unsigned int v33 = _dispatch_thread_getspecific(3uLL) & 0xFFFFFFFC;
  uint64_t v27 = 0LL;
  unsigned int v26 = 0;
  *(void *)(a2 + 16) = 0LL;
  _dispatch_thread_setspecific(122LL, v34 + 72);
  unsigned int v17 = (unint64_t *)(v34 + 72);
  unint64_t v18 = *(void *)(v34 + 72);
  do
  {
    unint64_t v4 = v18;
    do
      unint64_t v5 = __ldaxr(v17);
    while (v5 == v18 && __stlxr(a2, v17));
    unint64_t v18 = v5;
  }

  while (v5 != v4);
  unint64_t v25 = v5;
  if (!v5)
  {
    _dispatch_retain_2(a1);
    uint64_t v27 = 0xA000000000LL;
    unsigned int v26 = 3;
  }

  if (v25) {
    *(void *)(v25 + 16) = a2;
  }
  else {
    *(void *)(v34 + 8_dispatch_source_set_handler((uint64_t)source, handler, 2LL, 0) = a2;
  }
  _dispatch_thread_setspecific(122LL, 0LL);
  BOOL v16 = 1;
  if (!*(_DWORD *)(v34 + 88)) {
    BOOL v16 = (*(_DWORD *)(a1 + 80) & 0x10000000) != 0;
  }
  if (v16)
  {
    uint64_t v23 = (unint64_t *)(v34 + 64);
    do
    {
      if (_os_atomic_mo_has_acquire(3)) {
        unint64_t v6 = __ldaxr(v23);
      }
      else {
        unint64_t v6 = __ldxr(v23);
      }
      unint64_t v31 = v6;
      unint64_t v42 = v6;
      unint64_t v28 = v42 | v27;
      if (_os_atomic_mo_has_release(3)) {
        BOOL v24 = __stlxr(v28, v23) == 0;
      }
      else {
        BOOL v24 = __stxr(v28, v23) == 0;
      }
    }

    while (!v24);
    if (((v31 ^ v28) & 0x8000000000LL) != 0) {
      v26 &= ~1u;
    }
    goto LABEL_70;
  }

  if (v27)
  {
    uint64_t v21 = (unint64_t *)(v34 + 64);
    do
    {
      if (_os_atomic_mo_has_acquire(5)) {
        unint64_t v7 = __ldaxr(v21);
      }
      else {
        unint64_t v7 = __ldxr(v21);
      }
      unint64_t v32 = v7;
      unint64_t v41 = v7;
      unint64_t v29 = v41 | v27;
      if ((v7 & 0x10FFFFFFFFLL) == 0) {
        unint64_t v29 = (v29 | v33) & 0xFFFFFFC7FFFFFFFFLL;
      }
      if (_os_atomic_mo_has_release(5)) {
        BOOL v22 = __stlxr(v29, v21) == 0;
      }
      else {
        BOOL v22 = __stxr(v29, v21) == 0;
      }
    }

    while (!v22);
    if (((v32 ^ v29) & 0x8000000000LL) != 0) {
      v26 &= ~1u;
    }
LABEL_57:
    if ((v32 & 0xFFFFFFFC) != 0) {
      unsigned int v43 = v32 | 3;
    }
    else {
      unsigned int v43 = 0;
    }
    if (v43)
    {
      if ((v32 & 0x700000000LL) < (unint64_t)a3 << 32 && (_dispatch_set_qos_class_enabled & 1) != 0)
      {
        uint64_t v44 = 0LL;
        if (a3) {
          uint64_t v44 = 1LL << (a3 + 7);
        }
        _pthread_workqueue_override_start_direct_check_owner(v43, v44 | 0xFF, v34 + 64);
      }

      if ((v26 & 1) != 0) {
        _dispatch_release_2((unsigned int *)a1);
      }
      char v39 = 0;
    }

    else
    {
      if ((v32 & 0x1000000000LL) != 0)
      {
LABEL_70:
        (*(void (**)(uint64_t, void, void))(*(void *)a1 + 64LL))(a1, a3, v26);
        char v39 = 0;
        return v39 & 1;
      }

      BOOL v15 = 0;
      if (v26) {
        BOOL v15 = a2 == *(void *)(v34 + 80);
      }
      if (!v15) {
        a4 &= ~8u;
      }
      if ((v26 & 1) != 0) {
        _dispatch_release_2_no_dispose(a1);
      }
      char v39 = _dispatch_mach_send_drain(a1, 0, a4, v8, v9, v10, v11, v12) & 1;
    }
  }

  else
  {
    uint64_t v19 = (unint64_t *)(v34 + 64);
    while (1)
    {
      if (_os_atomic_mo_has_acquire(2)) {
        unint64_t v13 = __ldaxr(v19);
      }
      else {
        unint64_t v13 = __ldxr(v19);
      }
      unint64_t v32 = v13;
      unint64_t v40 = v13;
      unint64_t v30 = v40;
      if (v40 == v13) {
        break;
      }
      if ((v13 & 0x10FFFFFFFFLL) == 0) {
        unint64_t v30 = (v40 | v33) & 0xFFFFFFC7FFFFFFFFLL;
      }
      if (_os_atomic_mo_has_release(2)) {
        BOOL v20 = __stlxr(v30, v19) == 0;
      }
      else {
        BOOL v20 = __stxr(v30, v19) == 0;
      }
      if (v20) {
        goto LABEL_57;
      }
    }

    __clrex();
    char v39 = 0;
  }

  return v39 & 1;
}

uint64_t _dispatch_get_thread_reply_port()
{
  unsigned int v16 = _dispatch_thread_getspecific(8uLL);
  if (v16)
  {
    special_mach_port_name_t reply_port = v16;
    _dispatch_thread_getspecific(0LL);
    _dispatch_log("%u\t%p\tmachport[0x%08x]: borrowed thread sync reply port", v0, v1, v2, v3, v4, v5, v6, 526LL);
  }

  else
  {
    special_mach_port_name_t reply_port = thread_get_special_reply_port();
    _dispatch_thread_setspecific(8LL, special_reply_port);
    BOOL v15 = 0;
    if (special_reply_port) {
      BOOL v15 = special_reply_port != -1;
    }
    if (!v15)
    {
      qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Unable to allocate reply port, possible port leak";
      __break(1u);
      JUMPOUT(0x807E4LL);
    }

    _dispatch_thread_getspecific(0LL);
    _dispatch_log("%u\t%p\tmachport[0x%08x]: allocated thread sync reply port", v7, v8, v9, v10, v11, v12, v13, 535LL);
  }

  return special_reply_port;
}

void _dispatch_mach_msg_reply_received(uint64_t a1, uint64_t a2, unsigned int a3)
{
  uint64_t v26 = a1;
  uint64_t v25 = a2;
  unsigned int v24 = a3;
  uint64_t v23 = a2;
  BOOL v22 = 0;
  BOOL v22 = _dispatch_mach_reply_list_tryremove(*(void *)(a1 + 120), a2);
  unsigned int v21 = 0;
  unsigned int v21 = *(_DWORD *)(v23 + 24);
  if (v22)
  {
    _dispatch_thread_getspecific(0LL);
    _dispatch_log( "%u\t%p\tmachport[0x%08x]: unregistered for sync reply, ctxt %p",  v7,  v8,  v9,  v10,  v11,  v12,  v13,  906LL);
  }

  if ((*(_BYTE *)(v23 + 30) & 1) != 0)
  {
    if (v24 != v21 && (v22 || v24 && v24 != -1))
    {
      qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Reply received on unexpected port";
      qword_E4DA8 = v24;
      __break(1u);
      JUMPOUT(0x80968LL);
    }

    if (v22) {
      _dispatch_set_thread_reply_port(v21);
    }
    else {
      _dispatch_destruct_reply_port(v21, 2u);
    }
  }

  else if (v24 && v24 != -1 && v22)
  {
    uint64_t v20 = 0LL;
    uint64_t v19 = (dispatch_object_s *)dispatch_mach_msg_create(0LL, 0x18uLL, 0LL, &v20, v3, v4, v5, v6);
    *(_DWORD *)(v20 + 12) = v24;
    *((void *)v19 + 8) = *(void *)(v23 + 56);
    *(void *)(v23 + 56) = 0LL;
    *((void *)v19 + 7) = *(unsigned int *)(v23 + 40);
    *((void *)v19 + 4) = *(void *)(v23 + 48);
    _dispatch_mach_msg_set_reason((uint64_t)v19, 0, 9LL, v14, v15, v16, v17, v18);
    _dispatch_mach_handle_or_push_received_msg(v26, v19, 0LL);
  }

BOOL _dispatch_mach_reply_list_tryremove(uint64_t a1, uint64_t a2)
{
  uint64_t v19 = (unsigned int *)(a1 + 40);
  unsigned int v18 = _dispatch_thread_getspecific(3uLL) & 0xFFFFFFFC;
  do
    unsigned int v9 = __ldaxr(v19);
  while (!v9 && __stlxr(v18, v19));
  if (v9) {
    _dispatch_unfair_lock_lock_slow(v19, 0x10000);
  }
  BOOL v15 = *(void *)(a2 + 72) != 0LL;
  if (*(void *)(a2 + 72)) {
    _dispatch_mach_reply_list_remove_locked(a2, v2, v3, v4, v5, v6, v7, v8);
  }
  unsigned int v20 = _dispatch_thread_getspecific(3uLL) & 0xFFFFFFFC;
  uint64_t v13 = (unsigned int *)(a1 + 40);
  unsigned int v14 = *(_DWORD *)(a1 + 40);
  do
  {
    unsigned int v10 = v14;
    do
      unsigned int v11 = __ldaxr(v13);
    while (v11 == v14 && __stlxr(0, v13));
    unsigned int v14 = v11;
  }

  while (v11 != v10);
  if (v11 != v20) {
    _dispatch_unfair_lock_unlock_slow(a1 + 40, v11);
  }
  return v15;
}

void _dispatch_set_thread_reply_port(unsigned int a1)
{
  if (_dispatch_thread_getspecific(8uLL))
  {
    _dispatch_destruct_reply_port(a1, 0);
    _dispatch_thread_getspecific(0LL);
    _dispatch_log( "%u\t%p\tmachport[0x%08x]: deallocated sync reply port (found 0x%08x)",  v1,  v2,  v3,  v4,  v5,  v6,  v7,  567LL);
  }

  else
  {
    _dispatch_thread_setspecific(8LL, a1);
    _dispatch_thread_getspecific(0LL);
    _dispatch_log("%u\t%p\tmachport[0x%08x]: restored thread sync reply port", v8, v9, v10, v11, v12, v13, v14, 571LL);
  }

void _dispatch_mach_msg_disconnected( uint64_t a1, int a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v24 = a1;
  int v23 = a2;
  int v22 = a3;
  uint64_t v21 = 0LL;
  unsigned int v20 = (dispatch_object_s *)dispatch_mach_msg_create(0LL, 0x18uLL, 0LL, &v21, a5, a6, a7, a8);
  if (v23) {
    *(_DWORD *)(v21 + 12) = v23;
  }
  if (v22) {
    *(_DWORD *)(v21 + 8) = v22;
  }
  _dispatch_mach_msg_set_reason((uint64_t)v20, 0, 7LL, v8, v9, v10, v11, v12);
  _dispatch_thread_getspecific(0LL);
  _dispatch_log("%u\t%p\tmachport[0x%08x]: %s right disconnected", v13, v14, v15, v16, v17, v18, v19, 955LL);
  _dispatch_mach_handle_or_push_received_msg(v24, v20, 0LL);
}

void _dispatch_mach_handle_wlh_change( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10 = (unsigned int *)(a1 + 80);
  unsigned int v11 = *(_DWORD *)(a1 + 80);
  do
  {
    unsigned int v8 = v11;
    do
      unsigned int v9 = __ldaxr(v10);
    while (v9 == v11 && __stlxr(v11 | 0x8000000, v10));
    unsigned int v11 = v9;
  }

  while (v9 != v8);
  if ((v9 & 0x400000) == 0)
  {
    if ((*(_WORD *)(a1 + 116) & 0x10) != 0)
    {
      qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Changing target queue hierarchy after xpc connection was activated";
      __break(1u);
      JUMPOUT(0x81008LL);
    }

    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Changing target queue hierarchy after mach channel was connected";
    __break(1u);
    JUMPOUT(0x81034LL);
  }

  if ((v9 & 0x8000000) == 0)
  {
    if ((*(_WORD *)(a1 + 116) & 0x10) != 0) {
      _dispatch_bug_deprecated( (uint64_t)"Changing target queue hierarchy after xpc connection was activated",  a2,  a3,  a4,  a5,  a6,  a7,  a8);
    }
    else {
      _dispatch_bug_deprecated( (uint64_t)"Changing target queue hierarchy after mach channel was connected",  a2,  a3,  a4,  a5,  a6,  a7,  a8);
    }
  }

BOOL _dispatch_mach_cancel( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  BOOL v29 = (*(_BYTE *)(a1 + 118) & 2) != 0;
  if (*(_DWORD *)(*(void *)(a1 + 120) + 88LL)) {
    BOOL v29 = 0;
  }
  _dispatch_object_debug(a1, "%s", a3, a4, a5, a6, a7, a8, (char)"_dispatch_mach_cancel");
  unsigned int v28 = 1;
  if ((*(_DWORD *)(a1 + 80) & 0x40000000) == 0) {
    unsigned int v28 = 3;
  }
  uint64_t v27 = *(void *)(a1 + 128);
  if (v27 && (_dispatch_unote_unregister(v27, v28, v8, v9, v10, v11, v12, v13) & 1) == 0) {
    BOOL v29 = 0;
  }
  uint64_t v26 = *(void *)(a1 + 88);
  int v25 = *(_DWORD *)(v26 + 24);
  if (v25)
  {
    if (_dispatch_unote_unregister(v26, v28, v8, v9, v10, v11, v12, v13))
    {
      _dispatch_mach_msg_disconnected(a1, v25, 0, v14, v15, v16, v17, v18);
      *(_DWORD *)(v26 + 24) = 0;
    }

    else
    {
      BOOL v29 = 0;
    }
  }

  if (v29)
  {
    unint64_t v31 = (unsigned int *)(a1 + 80);
    do
    {
      if (_os_atomic_mo_has_acquire(0)) {
        unsigned int v19 = __ldaxr(v31);
      }
      else {
        unsigned int v19 = __ldxr(v31);
      }
      unsigned int v34 = v19;
      unsigned int v33 = v19 & 0x3FFFFFFF | 0x80000000;
      if ((v34 & 0x3FFFFFFF | 0x80000000) == v34)
      {
        __clrex();
        unsigned int v35 = v19;
        goto LABEL_24;
      }

      if (_os_atomic_mo_has_release(0)) {
        BOOL v32 = __stlxr(v33, v31) == 0;
      }
      else {
        BOOL v32 = __stxr(v33, v31) == 0;
      }
    }

    while (!v32);
    unsigned int v35 = v34;
LABEL_24:
    if ((v35 & 0xA0000000) != 0)
    {
      qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Corrupt channel state";
      qword_E4DA8 = v35;
      __break(1u);
      JUMPOUT(0x813D0LL);
    }

    _dispatch_release_no_dispose(a1);
  }

  else
  {
    int v23 = (unsigned int *)(a1 + 80);
    unsigned int v24 = *(_DWORD *)(a1 + 80);
    do
    {
      unsigned int v20 = v24;
      do
        unsigned int v21 = __ldaxr(v23);
      while (v21 == v24 && __stlxr(v24 | 0x40000000, v23));
      unsigned int v24 = v21;
    }

    while (v21 != v20);
  }

  return v29;
}

uint64_t _dispatch_mach_cancel_invoke(uint64_t a1, int a2)
{
  uint64_t v4 = *(void *)(a1 + 88);
  uint64_t v3 = 0LL;
  if ((a2 & 0x1000000) != 0) {
    uint64_t v3 = _dispatch_autorelease_pool_push();
  }
  if (((*(_WORD *)(a1 + 116) >> 2) & 1) == 0) {
    _dispatch_mach_connect_invoke(a1);
  }
  uint64_t result = _dispatch_client_callout4( *(void *)(v4 + 48),  8LL,  0LL,  0,  *(uint64_t (**)(uint64_t, uint64_t, uint64_t, void))(v4 + 40));
  if (v3) {
    uint64_t result = _dispatch_autorelease_pool_pop(v3);
  }
  *(_WORD *)(a1 + 116) = *(_WORD *)(a1 + 116) & 0xFFF7 | 8;
  return result;
}

uint64_t _dispatch_unote_create_with_handle(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a2) {
    return _dispatch_unote_create(a1, a2, a3);
  }
  else {
    return 0LL;
  }
}

uint64_t _dispatch_unote_create(uint64_t a1, int a2, uint64_t a3)
{
  int v5 = a3;
  if (*(_DWORD *)(a1 + 20) && (*(_BYTE *)(a1 + 10) & 4) == 0 && !a3) {
    return 0LL;
  }
  if ((*(_WORD *)(a1 + 12) & 0x100) != 0) {
    uint64_t v4 = _dispatch_calloc(1LL, *(unsigned int *)(a1 + 24));
  }
  else {
    uint64_t v4 = _dispatch_calloc(1LL, *(unsigned int *)(a1 + 24) + 24LL) + 24;
  }
  *(void *)uint64_t v4 = a1;
  *(_BYTE *)(v4 + 29) = *(_BYTE *)(v4 + 29) & 0xDF | (32 * (*(_BYTE *)(a1 + 10) & 1));
  *(_DWORD *)(v4 + 24) = a2;
  *(_BYTE *)(v4 + 28) = *(_BYTE *)(a1 + 8);
  *(_DWORD *)(v4 + 32) = v5;
  if ((*(_WORD *)(a1 + 12) & 0x100) != 0) {
    *(_BYTE *)(v4 + 29) = *(_BYTE *)(v4 + 29) & 0xFE | 1;
  }
  return v4;
}

uint64_t _dispatch_unote_create_with_fd(uint64_t a1, int a2, uint64_t a3)
{
  return _dispatch_unote_create(a1, a2, a3);
}

uint64_t _dispatch_unote_create_without_handle(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a2) {
    return 0LL;
  }
  else {
    return _dispatch_unote_create(a1, 0, a3);
  }
}

void _dispatch_unote_dispose(uint64_t a1)
{
  uint64_t v2 = (void *)a1;
  if ((*(_BYTE *)(a1 + 29) & 0x40) != 0) {
    _Block_release(*(const void **)(a1 + 48));
  }
  if ((*(_BYTE *)(a1 + 29) & 2) != 0)
  {
    BOOL v1 = 1;
    if (*(_DWORD *)(a1 + 112) == -1) {
      BOOL v1 = *(_DWORD *)(a1 + 116) != -1;
    }
    if (v1)
    {
      qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: Disposing of timer still in its heap";
      __break(1u);
      JUMPOUT(0x81930LL);
    }

    if (*(void *)(a1 + 104))
    {
      free(*(void **)(a1 + 104));
      *(void *)(a1 + 104) = 0LL;
    }
  }

  else if ((*(_BYTE *)(a1 + 29) & 1) == 0)
  {
    uint64_t v2 = (void *)(a1 - 24);
  }

  free(v2);
}

BOOL _dispatch_unote_register( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v12 = a3;
  BOOL v10 = 1;
  if ((*(_BYTE *)(a1 + 29) & 2) == 0) {
    BOOL v10 = *(void *)(a1 + 16) == 0LL;
  }
  if (!v10) {
    _dispatch_abort(127LL, v10, a3, a4, a5, a6, a7, a8);
  }
  int v11 = a3 & 0x4600FFFF;
  BOOL v9 = 1;
  if (a2 != -4) {
    BOOL v9 = v11 != 0;
  }
  if (!v9) {
    _dispatch_abort(136LL, v9, a3, a4, a5, a6, a7, a8);
  }
  if (v11 == 67125248 && MEMORY[0xFFFFFC100]) {
    kdebug_trace(771883044LL, ~*(void *)(a1 + 8), 0LL, 0LL, 0LL);
  }
  *(_DWORD *)(a1 + 36) = v12;
  if ((*(char *)(a1 + 28) + 23) > 2)
  {
    if ((*(_BYTE *)(a1 + 29) & 2) != 0)
    {
      _dispatch_timer_unote_register(a1, a2, v12, a4, a5, a6, a7, a8);
      return 1;
    }

    else if ((*(_BYTE *)(a1 + 29) & 1) != 0)
    {
      return _dispatch_unote_register_direct((uint64_t *)a1, a2);
    }

    else
    {
      return _dispatch_unote_register_muxed((uint64_t *)a1, a2, a3, a4, a5, a6, a7, a8);
    }
  }

  else
  {
    *(void *)(a1 + 16) = -3LL;
    return 1;
  }

void _dispatch_timer_unote_register( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v11 = (unsigned __int16)(a3 & 0xF00) >> 8;
  BOOL v8 = 0;
  if (v11) {
    BOOL v8 = v11 <= 2;
  }
  if (v8)
  {
    if ((*(_BYTE *)(a1 + 30) & 1) != 0)
    {
      if (MEMORY[0xFFFFFC100]) {
        kdebug_trace(771883032LL, ~*(void *)(a1 + 8), 0LL, 0LL, 0LL);
      }
    }

    else
    {
      *(_BYTE *)(a1 + 30) |= 2u;
      int v12 = _dispatch_timer_flags_to_clock(*(_BYTE *)(a1 + 30));
      if ((*(_BYTE *)(a1 + 30) & 3u) >= 3) {
        _dispatch_abort(781LL, (*(_BYTE *)(a1 + 30) & 3u) < 3, a3, a4, a5, a6, a7, a8);
      }
      *(_DWORD *)(a1 + 24) = 3 * v12 + (*(_BYTE *)(a1 + 30) & 3);
    }
  }

  if ((*(void *)(a1 + 16) & 0xFFFFFFFFFFFFFFFCLL) != a2)
  {
    if ((*(void *)(a1 + 16) & 0xFFFFFFFFFFFFFFFCLL) != 0) {
      _dispatch_abort(853LL, (*(void *)(a1 + 16) & 0xFFFFFFFFFFFFFFFCLL) == 0, a3, a4, a5, a6, a7, a8);
    }
    *(void *)(a1 + 16) = -4LL;
  }

  if (*(void *)(a1 + 104)) {
    _dispatch_timer_unote_configure(a1);
  }
}

void _dispatch_unote_resume( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  char v9 = 1;
  if ((*(_BYTE *)(a1 + 29) & 2) == 0)
  {
    uint64_t v10 = *(void *)(a1 + 16);
    BOOL v8 = 0;
    if (v10)
    {
      BOOL v8 = 0;
      if ((v10 & 1) == 0) {
        BOOL v8 = (v10 & 2) == 0;
      }
    }

    char v9 = v8;
  }

  if ((v9 & 1) == 0) {
    _dispatch_abort(166LL, v9 & 1, a3, a4, a5, a6, a7, a8);
  }
  if ((*(_BYTE *)(a1 + 29) & 2) != 0)
  {
    _dispatch_timer_unote_resume(a1);
  }

  else if ((*(_BYTE *)(a1 + 29) & 1) != 0)
  {
    _dispatch_unote_resume_direct((uint64_t *)a1);
  }

  else
  {
    _dispatch_unote_resume_muxed(a1, a2, a3, a4, a5, a6, a7, a8);
  }

void _dispatch_timer_unote_resume(uint64_t a1)
{
  if ((*(void *)(55LL - *(void *)(a1 + 8)) & 0xFF80000000000000LL) != 0)
  {
    BOOL v22 = 0;
  }

  else
  {
    BOOL v15 = 0;
    if (*(_DWORD *)(a1 + 24) != -1) {
      BOOL v15 = *(void *)(a1 + 80) < 0x7FFFFFFFFFFFFFFFuLL;
    }
    BOOL v22 = v15;
  }

  BOOL v18 = (*(void *)(a1 + 16) & 1) != 0;
  int v21 = _dispatch_timer_flags_to_clock(*(_BYTE *)(a1 + 30));
  unsigned int v20 = *(_BYTE *)(a1 + 30) & 3;
  if (v20 >= 3) {
    _dispatch_abort(781LL, v20 < 3, v1, v2, v3, v4, v5, v6);
  }
  unsigned int v17 = 3 * v21 + v20;
  uint64_t v16 = _dispatch_timer_unote_heap(a1);
  BOOL v14 = 0;
  if (v18)
  {
    BOOL v13 = 1;
    if (v22) {
      BOOL v13 = *(_DWORD *)(a1 + 24) != v17;
    }
    BOOL v14 = v13;
  }

  if (v14) {
    _dispatch_timer_unote_disarm(a1, (uint64_t)v16, v7, v8, v9, v10, v11, v12);
  }
  if (v22)
  {
    if (!v18) {
      _dispatch_retain_2(~*(void *)(a1 + 8));
    }
    _dispatch_timer_unote_arm(a1, (uint64_t)v16, v17);
  }

  else if (v18)
  {
    _dispatch_release_2_tailcall((unsigned int *)~*(void *)(a1 + 8));
  }

uint64_t _dispatch_unote_unregister( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(void *)(a1 + 16))
  {
    if ((*(char *)(a1 + 28) + 23) > 2)
    {
      if ((*(_BYTE *)(a1 + 29) & 2) != 0)
      {
        _dispatch_timer_unote_unregister(a1);
        char v9 = 1;
      }

      else if ((*(_BYTE *)(a1 + 29) & 1) != 0)
      {
        char v9 = _dispatch_unote_unregister_direct(a1, a2) & 1;
      }

      else
      {
        if ((a2 & 1) == 0) {
          _dispatch_abort(201LL, a2 & 1, a3, a4, a5, a6, a7, a8);
        }
        char v9 = _dispatch_unote_unregister_muxed(a1, a2, a3, a4, a5, a6, a7, a8) & 1;
      }
    }

    else
    {
      *(void *)(a1 + 16) = 0LL;
      char v9 = 1;
    }
  }

  else
  {
    char v9 = 1;
  }

  return v9 & 1;
}

void _dispatch_timer_unote_unregister(uint64_t a1)
{
  uint64_t v11 = _dispatch_timer_unote_heap(a1);
  if ((*(void *)(a1 + 16) & 1) != 0)
  {
    _dispatch_timer_unote_disarm(a1, (uint64_t)v11, v1, v2, v3, v4, v5, v6);
    _dispatch_release_2_no_dispose(~*(void *)(a1 + 8));
  }

  unint64_t v13 = *(void *)(a1 + 16) & 0xFFFFFFFFFFFFFFFCLL;
  if (v13 && v13 != -4LL)
  {
    char v9 = (unsigned int *)(v13 + 96);
    unsigned int v10 = *(_DWORD *)(v13 + 96);
    do
    {
      unsigned int v7 = v10;
      do
        unsigned int v8 = __ldaxr(v9);
      while (v8 == v10 && __stlxr(v10 - 1, v9));
      unsigned int v10 = v8;
    }

    while (v8 != v7);
    if (((v8 - 1) & 0x80000000) != 0)
    {
      if ((int)(v8 - 1) <= -2)
      {
        qword_E4D78 = (uint64_t)"API MISUSE: Over-release of an object";
        __break(1u);
        JUMPOUT(0x829C0LL);
      }

      *(void *)(v13 + 56) = 0xDEAD000000000000LL;
      _dispatch_object_dealloc((void *)v13);
    }
  }

  *(void *)(a1 + 16) = 0LL;
  *(_DWORD *)(a1 + 24) = -1;
}

uint64_t _dispatch_source_data_create(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a2 || a3) {
    return 0LL;
  }
  uint64_t v3 = _dispatch_calloc(1LL, *(unsigned int *)(a1 + 24));
  *(void *)uint64_t v3 = a1;
  *(_BYTE *)(v3 + 28) = *(_BYTE *)(a1 + 8);
  *(_BYTE *)(v3 + 29) = *(_BYTE *)(v3 + 29) & 0xFE | 1;
  return v3;
}

uint64_t _dispatch_source_signal_create(uint64_t a1, unint64_t a2, uint64_t a3)
{
  if (a2 < 0x20) {
    return _dispatch_unote_create_with_handle(a1, a2, a3);
  }
  else {
    return 0LL;
  }
}

void _dispatch_timer_unote_configure(uint64_t a1)
{
  unint64_t v6 = *(void *)(a1 + 104);
  do
  {
    unint64_t v1 = v6;
    uint64_t v5 = (unint64_t *)(a1 + 104);
    do
      unint64_t v2 = __ldaxr(v5);
    while (v2 == v6 && __stlxr(0LL, v5));
    uint64_t v4 = (_DWORD *)v2;
    unint64_t v6 = v2;
  }

  while (v2 != v1);
  int v3 = *(_DWORD *)(v2 + 24);
  if (v3 != _dispatch_timer_flags_to_clock(*(_BYTE *)(a1 + 30)))
  {
    *(_BYTE *)(a1 + 30) &= 0xF3u;
    *(_BYTE *)(a1 + 30) |= _dispatch_timer_flags_from_clock(v4[6]);
  }

  *(_OWORD *)(a1 + 8_dispatch_source_set_handler((uint64_t)source, handler, 2LL, 0) = *(_OWORD *)v4;
  *(void *)(a1 + 96) = *((void *)v4 + 2);
  free(v4);
  *(void *)(a1 + 72) = 0LL;
  if ((*(void *)(a1 + 16) & 1LL) != 0) {
    _dispatch_timer_unote_resume(a1);
  }
}

uint64_t _dispatch_source_timer_create(uint64_t a1, unint64_t a2, unsigned int a3)
{
  unsigned int v11 = a3;
  if ((a3 & 1) != 0) {
    unsigned int v11 = a3 & 0xFFFFFFFD;
  }
  if ((v11 & ~*(_DWORD *)(a1 + 20)) != 0) {
    return 0LL;
  }
  if ((*(_BYTE *)(a1 + 11) & 0x10) != 0)
  {
    if (!a2) {
      return 0LL;
    }
    goto LABEL_16;
  }

  if (*(char *)(a1 + 8) == -20)
  {
    if (a2) {
      return 0LL;
    }
LABEL_16:
    uint64_t v10 = _dispatch_calloc(1LL, *(unsigned int *)(a1 + 24));
    *(void *)uint64_t v10 = a1;
    *(_BYTE *)(v10 + 28) = *(_BYTE *)(a1 + 8);
    *(_BYTE *)(v10 + 29) = *(_BYTE *)(v10 + 29) & 0xFD | 2;
    *(_BYTE *)(v10 + 30) |= v11 | *(_BYTE *)(a1 + 11);
    int v15 = _dispatch_timer_flags_to_clock(*(_BYTE *)(v10 + 30));
    unsigned int v14 = *(_BYTE *)(v10 + 30) & 3;
    if (v14 >= 3) {
      _dispatch_abort(781LL, v14 < 3, v3, v4, v5, v6, v7, v8);
    }
    *(_DWORD *)(v10 + 24) = 3 * v15 + v14;
    *(void *)(v10 + 8_dispatch_source_set_handler((uint64_t)source, handler, 2LL, 0) = -1LL;
    *(void *)(v10 + 88) = -1LL;
    *(void *)(v10 + 96) = -1LL;
    *(_DWORD *)(v10 + 112) = -1;
    *(_DWORD *)(v10 + 116) = -1;
    return v10;
  }

  if (a2 <= 3) {
    __asm { BR              X8 }
  }

  return 0LL;
}

void _dispatch_event_loop_drain_timers( uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v12 = a1;
  unsigned int v11 = a2;
  memset(v10, 0, sizeof(v10));
  do
  {
    for (unsigned int i = 0; i < v11; ++i)
      _dispatch_timers_run(v12, i, (uint64_t)v10, a4, a5, a6, a7, a8);
    *(_BYTE *)(v12 + 6) = 0;
    for (unsigned int j = 0; j < v11; ++j)
    {
      if ((*(_BYTE *)(v12 + 32LL * j + 7) & 2) != 0) {
        _dispatch_timers_program(v12, j, (uint64_t)v10, a4, a5, a6, a7, a8);
      }
    }
  }

  while (*(_BYTE *)(v12 + 6));
}

void _dispatch_timers_run( uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  while (1)
  {
    uint64_t v19 = *(void *)(a1 + 32LL * a2 + 8);
    if (!v19) {
      break;
    }
    unsigned int v17 = *(_DWORD *)(v19 + 24);
    if (v17 != a2)
    {
      qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Timer: tidx";
      qword_E4DA8 = v17;
      __break(1u);
      JUMPOUT(0x83324LL);
    }

    if (!*(void *)(v19 + 80))
    {
      qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Timer: missing target";
      qword_E4DA8 = 0LL;
      __break(1u);
      JUMPOUT(0x83388LL);
    }

    unsigned int v28 = a2 / 3;
    uint64_t v27 = a3;
    if (!*(void *)(a3 + 8LL * (a2 / 3)))
    {
      uint64_t v26 = 0LL;
      uint64_t v25 = 0LL;
      mach_get_times(v27, v27 + 8, &v25);
      *(void *)(v27 + 16) = 1000000000 * v25 + v26;
    }

    unint64_t v29 = *(void *)(v27 + 8LL * v28);
    if (*(void *)(v19 + 80) > v29) {
      break;
    }
    if ((*(_BYTE *)(v19 + 30) & 0x40) != 0)
    {
      _dispatch_timer_unote_disarm(v19, a1, a3, a4, a5, a6, a7, a8);
      unint64_t v24 = *(void *)(v19 + 16) & 0xFFFFFFFFFFFFFFFCLL;
      if (v24 && v24 != -4LL)
      {
        int v15 = (unsigned int *)(v24 + 96);
        unsigned int v16 = *(_DWORD *)(v24 + 96);
        do
        {
          unsigned int v8 = v16;
          do
            unsigned int v9 = __ldaxr(v15);
          while (v9 == v16 && __stlxr(v16 - 1, v15));
          unsigned int v16 = v9;
        }

        while (v9 != v8);
        if (((v9 - 1) & 0x80000000) != 0)
        {
          if ((int)(v9 - 1) <= -2)
          {
            qword_E4D78 = (uint64_t)"API MISUSE: Over-release of an object";
            __break(1u);
            JUMPOUT(0x83600LL);
          }

          *(void *)(v24 + 56) = 0xDEAD000000000000LL;
          _dispatch_object_dealloc((void *)v24);
        }
      }

      *(void *)(v19 + 16) = 0LL;
      *(void *)(v19 + 72) = 2LL;
      uint64_t v39 = v19;
      uint64_t v38 = 1LL;
      uint64_t v37 = 1LL;
      int v36 = 0;
      int v35 = 0;
      (*(void (**)(uint64_t, uint64_t, void))(*(void *)v19 + 48LL))(v19, 16LL, 0LL);
    }

    else if (*(void *)(v19 + 104))
    {
      _dispatch_timer_unote_configure(v19);
    }

    else
    {
      if (*(void *)(v19 + 72))
      {
        _dispatch_timer_unote_disarm(v19, a1, a3, a4, a5, a6, a7, a8);
        unint64_t v13 = (unint64_t *)(v19 + 72);
        unint64_t v14 = *(void *)(v19 + 72);
        do
        {
          unint64_t v10 = v14;
          do
            unint64_t v11 = __ldaxr(v13);
          while (v11 == v14 && __stlxr(v14 | 1, v13));
          unint64_t v14 = v11;
        }

        while (v11 != v10);
        unint64_t v18 = v11;
      }

      else
      {
        uint64_t v44 = (void *)v19;
        unint64_t v43 = v29;
        uint64_t v42 = 0LL;
        unint64_t v41 = 0LL;
        unint64_t v41 = (v29 - *(void *)(v19 + 80)) / *(void *)(v19 + 96);
        if ((++v41 & 0x8000000000000000LL) != 0) {
          unint64_t v41 = v42 ^ 0x7FFFFFFFFFFFFFFFLL;
        }
        if (v44[12] > 0x7FFFFFFFFFFFFFFEuLL)
        {
          v44[10] = -1LL;
          v44[11] = -1LL;
        }

        else
        {
          uint64_t v40 = 0LL;
          uint64_t v40 = v41 * v44[12];
          v44[10] += v40;
          v44[11] += v40;
        }

        v42 += v41;
        unint64_t v18 = 2 * v42;
        if ((*(void *)(55LL - *(void *)(v19 + 8)) & 0xFF80000000000000LL) != 0)
        {
          if (MEMORY[0xFFFFFC100]) {
            kdebug_trace(771883036LL, ~*(void *)(v19 + 8), 0LL, 0LL, 0LL);
          }
          BOOL v23 = 0;
        }

        else
        {
          BOOL v12 = 0;
          if (*(_DWORD *)(v19 + 24) != -1) {
            BOOL v12 = *(void *)(v19 + 80) < 0x7FFFFFFFFFFFFFFFuLL;
          }
          BOOL v23 = v12;
        }

        if (v23)
        {
          _dispatch_retain_2(~*(void *)(v19 + 8));
          _dispatch_timer_unote_arm(v19, a1, a2);
          *(void *)(v19 + 72) = v18;
        }

        else
        {
          _dispatch_timer_unote_disarm(v19, a1, a3, a4, a5, a6, a7, a8);
          v18 |= 1uLL;
          atomic_store(v18, (unint64_t *)(v19 + 72));
        }
      }

      uint64_t v34 = v19;
      unint64_t v33 = v18 >> 1;
      unint64_t v32 = v18 >> 1;
      int v31 = 0;
      int v30 = 0;
      (*(void (**)(uint64_t, uint64_t, void))(*(void *)v19 + 48LL))(v19, 16LL, 0LL);
    }
  }

void _dispatch_timers_program( uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v11 = a2 % 3;
  unsigned int v19 = a2 % 3;
  if (*(void *)(a1 + 32LL * a2 + 8))
  {
    unint64_t v18 = *(void *)(*(void *)(a1 + 32LL * a2 + 8) + 80LL);
    unint64_t v17 = *(void *)(*(void *)(a1 + 32LL * a2 + 16) + 88LL);
    BOOL v10 = 0;
    if (v18 <= v17) {
      BOOL v10 = v18 < 0x7FFFFFFFFFFFFFFFLL;
    }
    if (!v10) {
      _dispatch_abort(1141LL, v10, a3, a4, a5, a6, a7, a8);
    }
    unsigned int v27 = a2 / 3;
    uint64_t v26 = a3;
    if (!*(void *)(a3 + 8LL * (a2 / 3)))
    {
      uint64_t v24 = 0LL;
      uint64_t v25 = 0LL;
      mach_get_times(v26, v26 + 8, &v24);
      *(void *)(v26 + 16) = 1000000000 * v24 + v25;
    }

    unint64_t v28 = *(void *)(v26 + 8LL * v27);
    unint64_t v16 = v28;
    if (v18 > v28)
    {
      if (v19 < 3 && *(_DWORD *)(a1 + 32LL * a2) > 2u)
      {
        uint64_t v15 = _dispatch_kevent_coalescing_window[v19];
        if (v18 + v15 < v17) {
          unint64_t v18 = _dispatch_timer_heap_max_target_before(a1 + 32LL * a2, v17 - v15);
        }
      }

      if (v18 - v16 >= 0x7FFFFFFFFFFFFFFFLL) {
        uint64_t v9 = 0x7FFFFFFFFFFFFFFFLL;
      }
      else {
        uint64_t v9 = v18 - v16;
      }
      unint64_t v22 = v9;
      if (v17 - v18 >= 0x7FFFFFFFFFFFFFFFLL) {
        uint64_t v8 = 0x7FFFFFFFFFFFFFFFLL;
      }
      else {
        uint64_t v8 = v17 - v18;
      }
      uint64_t v23 = v8;
    }

    else
    {
      uint64_t v23 = 0LL;
      unint64_t v22 = 0LL;
    }
  }

  else
  {
    uint64_t v23 = 0x7FFFFFFFFFFFFFFFLL;
    unint64_t v22 = 0x7FFFFFFFFFFFFFFFLL;
  }

  if (v22)
  {
    if (v22 < 0x7FFFFFFFFFFFFFFFLL)
    {
      _dispatch_trace_next_timer[v11] = *(void *)(a1 + 32LL * a2 + 8);
      uint64_t v32 = _dispatch_trace_next_timer[v11];
      unint64_t v31 = v22;
      int v30 = 0;
      int v29 = 0;
      _dispatch_event_loop_timer_arm(a1, a2, v22, v23, a3);
      *(_BYTE *)(a1 + 32LL * a2 + 7) = *(_BYTE *)(a1 + 32LL * a2 + 7) & 0xFE | 1;
      *(_BYTE *)(a1 + 32LL * a2 + 7) &= ~2u;
      return;
    }
  }

  else
  {
    *(_BYTE *)(a1 + 6) |= (1 << (a2 % 3)) | 0x80;
  }

  _dispatch_trace_next_timer[v11] = 0LL;
  if ((*(_BYTE *)(a1 + 32LL * a2 + 7) & 1) != 0) {
    _dispatch_event_loop_timer_delete(a1, a2);
  }
  *(_BYTE *)(a1 + 32LL * a2 + 7) &= ~1u;
  *(_BYTE *)(a1 + 32LL * a2 + 7) &= ~2u;
}

void *_dispatch_timer_unote_heap(uint64_t a1)
{
  unint64_t v2 = *(void *)(a1 + 16) & 0xFFFFFFFFFFFFFFFCLL;
  if (v2 == -4LL) {
    return &_dispatch_timers_heap;
  }
  else {
    return *(void **)(v2 + 48);
  }
}

void _dispatch_timer_unote_disarm( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v15 = *(_DWORD *)(a1 + 24);
  if ((*(void *)(a1 + 16) & 1LL) == 0) {
    _dispatch_abort(793LL, (*(void *)(a1 + 16) & 1LL) != 0, a3, a4, a5, a6, a7, a8);
  }
  _dispatch_timer_heap_remove(a2 + 32LL * v15, a1);
  *(_BYTE *)(a2 + 6) |= (1 << (v15 % 3)) | 0x80;
  *(void *)(a1 + 16) &= ~1uLL;
  _dispatch_thread_getspecific(0LL);
  _dispatch_log("%u\t%p\tkevent-source[%p]: %s kevent[%p] { ident = 0x%x }", v8, v9, v10, v11, v12, v13, v14, 797LL);
}

uint64_t _dispatch_timer_unote_arm(uint64_t a1, uint64_t a2, unsigned int a3)
{
  if ((*(void *)(a1 + 16) & 1) != 0)
  {
    unsigned int v20 = *(_DWORD *)(a1 + 24);
    if (v20 != a3)
    {
      qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Timer: tidx";
      qword_E4DA8 = v20;
      __break(1u);
      JUMPOUT(0x84AD4LL);
    }

    uint64_t v24 = a2 + 32LL * a3;
    if (*(_DWORD *)(a1 + 112) == -1)
    {
      qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Timer: target idx";
      qword_E4DA8 = 0xFFFFFFFFLL;
      __break(1u);
      JUMPOUT(0x84B50LL);
    }

    if (*(_DWORD *)(a1 + 116) == -1)
    {
      qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Timer: deadline idx";
      qword_E4DA8 = 0xFFFFFFFFLL;
      __break(1u);
      JUMPOUT(0x84BB0LL);
    }

    _dispatch_timer_heap_resift(v24, a1, *(_DWORD *)(a1 + 112));
    _dispatch_timer_heap_resift(v24, a1, *(_DWORD *)(a1 + 116));
    _dispatch_thread_getspecific(0LL);
    _dispatch_log("%u\t%p\tkevent-source[%p]: %s kevent[%p] { ident = 0x%x }", v3, v4, v5, v6, v7, v8, v9, 807LL);
  }

  else
  {
    *(_DWORD *)(a1 + 24) = a3;
    uint64_t v28 = a2 + 32LL * a3;
    unsigned int v10 = *(_DWORD *)v28;
    *(_DWORD *)v28 += 2;
    unsigned int v27 = v10;
    unsigned int v26 = *(_DWORD *)(a1 + 112);
    if (v26 != -1)
    {
      qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Timer: target idx";
      qword_E4DA8 = v26;
      __break(1u);
      JUMPOUT(0x84CC8LL);
    }

    unsigned int v25 = *(_DWORD *)(a1 + 116);
    if (v25 != -1)
    {
      qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Timer: deadline idx";
      qword_E4DA8 = v25;
      __break(1u);
      JUMPOUT(0x84D28LL);
    }

    if ((*(_DWORD *)(a1 + 36) & 0xF00u) >> 8 > (*(_DWORD *)(a1 + 36) & 0xF000u) >> 12) {
      unsigned int v19 = (*(_DWORD *)(a1 + 36) & 0xF00u) >> 8;
    }
    else {
      unsigned int v19 = (*(_DWORD *)(a1 + 36) & 0xF000u) >> 12;
    }
    if (*(unsigned __int8 *)(v28 + 5) < v19)
    {
      *(_BYTE *)(v28 + 5) = v19;
      *(_BYTE *)(v28 + 7) |= 2u;
    }

    if (v10)
    {
      if (*(_BYTE *)(v28 + 4)) {
        unsigned int v29 = (8 << (*(_BYTE *)(v28 + 4) - 1)) - (*(unsigned __int8 *)(v28 + 4) - 1) + 2;
      }
      else {
        unsigned int v29 = 2;
      }
      if (v10 + 2 > v29) {
        _dispatch_timer_heap_grow(v28);
      }
      _dispatch_timer_heap_resift(v28, a1, v27);
      _dispatch_timer_heap_resift(v28, a1, v27 + 1);
    }

    else
    {
      *(_BYTE *)(v28 + 7) |= 2u;
      *(_DWORD *)(a1 + 112) = 0;
      *(_DWORD *)(a1 + 116) = 1;
      *(void *)(v28 + 16) = a1;
      *(void *)(v28 + 8) = a1;
    }

    *(void *)(a1 + 16) |= 1uLL;
    _dispatch_thread_getspecific(0LL);
    _dispatch_log("%u\t%p\tkevent-source[%p]: %s kevent[%p] { ident = 0x%x }", v11, v12, v13, v14, v15, v16, v17, 812LL);
  }

  uint64_t result = 2863311531LL;
  *(_BYTE *)(a2 + 6) |= (1 << (a3 % 3)) | 0x80;
  return result;
}

void _dispatch_timer_heap_remove(uint64_t a1, uint64_t a2)
{
  int v2 = *(_DWORD *)a1 - 2;
  *(_DWORD *)a1 = v2;
  unsigned int v7 = v2;
  if (*(_DWORD *)(a2 + 112) == -1)
  {
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Timer: target idx";
    qword_E4DA8 = 0xFFFFFFFFLL;
    __break(1u);
    JUMPOUT(0x850E4LL);
  }

  if (*(_DWORD *)(a2 + 116) == -1)
  {
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Timer: deadline idx";
    qword_E4DA8 = 0xFFFFFFFFLL;
    __break(1u);
    JUMPOUT(0x8514CLL);
  }

  if (v2)
  {
    for (unsigned int i = 0; i <= 1; ++i)
    {
      unsigned int v13 = v7 + i;
      int v11 = *(unsigned __int8 *)(a1 + 4);
      if (v7 + i > 1)
      {
        unsigned int v14 = v13 - 2;
        unsigned int v12 = 29 - __clz(v14 | 7);
        if (v12 + 1 == v11) {
          uint64_t v10 = *(void *)(a1 + 24);
        }
        else {
          uint64_t v10 = *(void *)(*(void *)(a1 + 24) + 8LL * (~v12 + (8 << (v11 - 2))));
        }
        if (v12) {
          v14 -= 8 << (v12 - 1);
        }
        uint64_t v15 = (uint64_t *)(v10 + 8LL * v14);
      }

      else
      {
        uint64_t v15 = (uint64_t *)(a1 + 8LL * v13 + 8);
      }

      uint64_t v3 = *v15;
      *uint64_t v15 = 0LL;
      if (v3 != a2) {
        _dispatch_timer_heap_resift(a1, v3, *(_DWORD *)(a2 + 4LL * i + 112));
      }
    }

    if (*(_BYTE *)(a1 + 4) == 1) {
      unsigned int v16 = 2;
    }
    else {
      unsigned int v16 = (8 << (*(_BYTE *)(a1 + 4) - 2)) - (*(unsigned __int8 *)(a1 + 4) - 2) + 2;
    }
    if (v7 <= v16) {
      _dispatch_timer_heap_shrink(a1);
    }
  }

  else
  {
    uint64_t v6 = *(void *)(a1 + 8);
    if (v6 != a2)
    {
      qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Timer: target slot";
      qword_E4DA8 = v6;
      __break(1u);
      JUMPOUT(0x851C4LL);
    }

    uint64_t v5 = *(void *)(a1 + 16);
    if (v5 != a2)
    {
      qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Timer: deadline slot";
      qword_E4DA8 = v5;
      __break(1u);
      JUMPOUT(0x85230LL);
    }

    *(_BYTE *)(a1 + 7) |= 2u;
    *(void *)(a1 + 16) = 0LL;
    *(void *)(a1 + 8) = 0LL;
  }

  *(_DWORD *)(a2 + 112) = -1;
  *(_DWORD *)(a2 + 116) = -1;
}

uint64_t _dispatch_timer_heap_resift(uint64_t result, uint64_t a2, unsigned int a3)
{
  unsigned int v15 = a3;
  unsigned int v10 = *(_DWORD *)result;
  char v8 = 0;
  int v33 = *(unsigned __int8 *)(result + 4);
  if (a3 >= 2)
  {
    unsigned int v35 = a3 - 2;
    unsigned int v3 = __clz((a3 - 2) | 7);
    unsigned int v34 = 29 - v3;
    if (30 - v3 == v33) {
      uint64_t v32 = *(void *)(result + 24);
    }
    else {
      uint64_t v32 = *(void *)(*(void *)(result + 24) + 8LL * ((8 << (v33 - 2)) - v34 - 1));
    }
    if (v34) {
      v35 -= 8 << (28 - v3);
    }
    uint64_t v36 = v32 + 8LL * v35;
  }

  else
  {
    uint64_t v36 = result + 8 + 8LL * a3;
  }

  uint64_t v9 = (void *)v36;
  while (v15 >= 2)
  {
    unsigned int v29 = ((v15 - 2) / 2) & 0xFFFFFFFE | v15 & 1;
    int v27 = *(unsigned __int8 *)(result + 4);
    if (v29 >= 2)
    {
      unsigned int v30 = v29 - 2;
      unsigned int v4 = __clz(v30 | 7);
      unsigned int v28 = 29 - v4;
      if (30 - v4 == v27) {
        uint64_t v26 = *(void *)(result + 24);
      }
      else {
        uint64_t v26 = *(void *)(*(void *)(result + 24) + 8LL * ((8 << (v27 - 2)) - v28 - 1));
      }
      if (v28) {
        v30 -= 8 << (28 - v4);
      }
      unint64_t v31 = (void *)(v26 + 8LL * v30);
    }

    else
    {
      unint64_t v31 = (void *)(result + 8 + 8LL * v29);
    }

    uint64_t v14 = *v31;
    if (*(void *)(*v31 + 80LL + 8LL * (a3 & 1)) <= *(void *)(a2 + 80 + 8LL * (a3 & 1))) {
      break;
    }
    void *v9 = v14;
    *(_DWORD *)(v14 + 112 + 4LL * (v15 & 1)) = v15;
    uint64_t v9 = v31;
    unsigned int v15 = ((v15 - 2) / 2) & 0xFFFFFFFE | v15 & 1;
    char v8 = 1;
  }

  if ((v8 & 1) == 0)
  {
    while (1)
    {
      unsigned int v11 = 2 * v15 + 2 - (v15 & 1);
      if (v11 >= v10) {
        break;
      }
      unsigned int v7 = v11 + 2;
      int v22 = *(unsigned __int8 *)(result + 4);
      if (v11 >= 2)
      {
        unsigned int v24 = 2 * v15 - (v15 & 1);
        unsigned int v5 = __clz(v24 | 7);
        unsigned int v23 = 29 - v5;
        if (30 - v5 == v22) {
          uint64_t v21 = *(void *)(result + 24);
        }
        else {
          uint64_t v21 = *(void *)(*(void *)(result + 24) + 8LL * ((8 << (v22 - 2)) - v23 - 1));
        }
        if (v23) {
          v24 -= 8 << (28 - v5);
        }
        unsigned int v25 = (void *)(v21 + 8LL * v24);
      }

      else
      {
        unsigned int v25 = (void *)(result + 8 + 8LL * v11);
      }

      unsigned int v13 = v25;
      uint64_t v12 = *v25;
      if (v7 < v10)
      {
        int v17 = *(unsigned __int8 *)(result + 4);
        if (v7 >= 2)
        {
          unsigned int v19 = 2 * v15 + 2 - (v15 & 1);
          unsigned int v6 = __clz(v11 | 7);
          unsigned int v18 = 29 - v6;
          if (30 - v6 == v17) {
            uint64_t v16 = *(void *)(result + 24);
          }
          else {
            uint64_t v16 = *(void *)(*(void *)(result + 24) + 8LL * ((8 << (v17 - 2)) - v18 - 1));
          }
          if (v18) {
            unsigned int v19 = v11 - (8 << (28 - v6));
          }
          unsigned int v20 = (void *)(v16 + 8LL * v19);
        }

        else
        {
          unsigned int v20 = (void *)(result + 8 + 8LL * v7);
        }

        if (*(void *)(v12 + 80 + 8LL * (a3 & 1)) > *(void *)(*v20 + 80LL + 8LL * (a3 & 1)))
        {
          v11 += 2;
          uint64_t v12 = *v20;
          unsigned int v13 = v20;
        }
      }

      if (*(void *)(a2 + 80 + 8LL * (a3 & 1)) <= *(void *)(v12 + 80 + 8LL * (a3 & 1))) {
        break;
      }
      if (v15 < 2) {
        *(_BYTE *)(result + 7) = *(_BYTE *)(result + 7) & 0xFD | 2;
      }
      void *v9 = v12;
      *(_DWORD *)(v12 + 112 + 4LL * (v15 & 1)) = v15;
      uint64_t v9 = v13;
      unsigned int v15 = v11;
    }
  }

  if (v15 < 2) {
    *(_BYTE *)(result + 7) = *(_BYTE *)(result + 7) & 0xFD | 2;
  }
  void *v9 = a2;
  *(_DWORD *)(a2 + 112 + 4LL * (v15 & 1)) = v15;
  return result;
}

void _dispatch_timer_heap_shrink(uint64_t a1)
{
  unsigned int v5 = 8;
  char v1 = *(_BYTE *)(a1 + 4);
  *(_BYTE *)(a1 + 4) = v1 - 1;
  unsigned int v4 = (v1 - 1);
  unsigned int v3 = *(void **)(a1 + 24);
  uint64_t v2 = 0LL;
  if (v1 != 1)
  {
    unsigned int v5 = 8 << (v1 - 2);
    uint64_t v2 = v3[v5 - v4];
  }

  if (v4 > 1) {
    __memcpy_chk(v2 + 8LL * ((v5 >> 1) - (v4 - 1)), &v3[v5 - (v4 - 1)], 8LL * (v4 - 1), -1LL);
  }
  *(void *)(a1 + 24) = v2;
  free(v3);
}

uint64_t _dispatch_timer_heap_grow(uint64_t a1)
{
  unsigned int v6 = 8;
  unsigned int v1 = *(unsigned __int8 *)(a1 + 4);
  *(_BYTE *)(a1 + 4) = v1 + 1;
  unsigned int v5 = v1;
  uint64_t v3 = *(void *)(a1 + 24);
  if (v1) {
    unsigned int v6 = 8 << (v1 - 1);
  }
  uint64_t result = _dispatch_calloc(v6, 8LL);
  uint64_t v4 = result;
  if (v5 > 1) {
    uint64_t result = __memcpy_chk(result + 8LL * (v6 - (v5 - 1)), v3 + 8LL * ((v6 >> 1) - (v5 - 1)), 8LL * (v5 - 1), -1LL);
  }
  if (v5) {
    *(void *)(v4 + 8LL * (v6 - v5)) = v3;
  }
  *(void *)(a1 + 24) = v4;
  return result;
}

unint64_t _dispatch_timer_heap_max_target_before(uint64_t a1, unint64_t a2)
{
  unsigned int v9 = 2;
  unsigned int v8 = *(_DWORD *)a1;
  unint64_t v6 = *(void *)(*(void *)(a1 + 8) + 80LL);
  while (v9 < v8)
  {
    int v11 = *(unsigned __int8 *)(a1 + 4);
    if (v9 >= 2)
    {
      unsigned int v13 = v9 - 2;
      unsigned int v2 = __clz((v9 - 2) | 7);
      unsigned int v12 = 29 - v2;
      if (30 - v2 == v11) {
        uint64_t v10 = *(void *)(a1 + 24);
      }
      else {
        uint64_t v10 = *(void *)(*(void *)(a1 + 24) + 8LL * ((8 << (v11 - 2)) - v12 - 1));
      }
      if (v12) {
        v13 -= 8 << (28 - v2);
      }
      uint64_t v14 = v10 + 8LL * v13;
    }

    else
    {
      uint64_t v14 = a1 + 8 + 8LL * v9;
    }

    unint64_t v7 = *(void *)(*(void *)v14 + 80LL);
    if (v7 <= a2)
    {
      if (v7 > v6) {
        unint64_t v6 = *(void *)(*(void *)v14 + 80LL);
      }
      if (2 * v9 + 2 - (v9 & 1) >= v8)
      {
        unsigned int v18 = v9 - (v9 & 1);
        if (v18 + 2 == v8) {
          unsigned int v18 = ((v18 - 2) / 2) & 0xFFFFFFFE | v18 & 1;
        }
        unsigned int v19 = (v18 + 3) >> __clz(__rbit32(~(v18 + 3)));
        if (v19) {
          int v4 = 2 * v19 + (v9 & 1);
        }
        else {
          int v4 = -1;
        }
        int v17 = v4;
      }

      else
      {
        int v17 = 2 * v9 + 2 - (v9 & 1);
      }

      unsigned int v9 = v17;
    }

    else
    {
      unsigned int v15 = v9 - (v9 & 1);
      if (v15 + 2 == v8) {
        unsigned int v15 = ((v15 - 2) / 2) & 0xFFFFFFFE | v15 & 1;
      }
      unsigned int v16 = (v15 + 3) >> __clz(__rbit32(~(v15 + 3)));
      if (v16) {
        int v5 = 2 * v16 + (v9 & 1);
      }
      else {
        int v5 = -1;
      }
      unsigned int v9 = v5;
    }
  }

  return v6;
}

uint64_t _dispatch_sync_ipc_handoff_begin(uint64_t a1, unsigned int a2, uint64_t a3)
{
  uint64_t v12 = a1;
  unsigned int v11 = a2;
  uint64_t v10 = a3;
  v5[0] = a2;
  v5[1] = 655343LL;
  v5[2] = a1;
  v5[3] = 2147483904LL;
  __int128 v6 = 0uLL;
  uint64_t v7 = a3;
  uint64_t v8 = -1LL;
  uint64_t v9 = a1;
  uint64_t result = _dispatch_kq_immediate_update(a1, (uint64_t)v5);
  BOOL v4 = 0;
  if ((_DWORD)result) {
    BOOL v4 = (_DWORD)result != 2;
  }
  if (v4)
  {
    qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: Unexpected error from kevent";
    qword_E4DA8 = (int)result;
    __break(1u);
    JUMPOUT(0x86590LL);
  }

  return result;
}

uint64_t _dispatch_kq_immediate_update(uint64_t a1, uint64_t a2)
{
  BOOL v4 = _dispatch_thread_getspecific(0x1DuLL);
  if (v4 && v4[3] == a1)
  {
    uint64_t v8 = v4[4];
    for (int i = 0;
          i < *((unsigned __int16 *)v4 + 20)
       && (*(__int16 *)(v8 + 72LL * i + 8) != *(__int16 *)(a2 + 8)
        || *(void *)(v8 + 72LL * i) != *(void *)a2
        || *(void *)(v8 + 72LL * i + 16) != *(void *)(a2 + 16));
      ;
    }

    if (i < *((unsigned __int16 *)v4 + 20))
    {
      __int16 v2 = *((_WORD *)v4 + 20);
      *((_WORD *)v4 + memset(__b, 0, 20) = v2 - 1;
    }
  }

  return _dispatch_kq_drain(a1, a2, 1, 3u);
}

void _dispatch_sync_ipc_handoff_end(uint64_t a1, unsigned int a2)
{
  unsigned int v11 = a2;
  uint64_t __b = a2;
  __int16 v3 = -17;
  __int16 v4 = 7;
  int v5 = 0;
  unsigned int v6 = 0x80000000;
  int v7 = 0;
  uint64_t v8 = 0LL;
  __int128 v9 = 0u;
  __int128 v10 = 0u;
  _dispatch_kq_deferred_update(a1, (__int16 *)&__b);
}

void _dispatch_kq_deferred_update(uint64_t a1, __int16 *a2)
{
  uint64_t v8 = _dispatch_thread_getspecific(0x1DuLL);
  if (v8 && v8[3] == a1 && *((_WORD *)v8 + 21))
  {
    uint64_t v12 = v8[4];
    for (int i = 0;
          i < *((unsigned __int16 *)v8 + 20)
       && (*(__int16 *)(v12 + 72LL * i + 8) != a2[4]
        || *(void *)(v12 + 72LL * i) != *(void *)a2
        || *(void *)(v12 + 72LL * i + 16) != *((void *)a2 + 2));
      ;
    }

    int v14 = i;
    if (a1 != -4) {
      _dispatch_thread_setspecific(5LL, 1LL);
    }
    if (i == *((unsigned __int16 *)v8 + 21))
    {
      int v13 = *((unsigned __int16 *)v8 + 20);
      *((_WORD *)v8 + memset(__b, 0, 20) = 1;
      _dispatch_kq_drain(a1, v8[4], v13, 3u);
      if (*((_WORD *)v8 + 20) != 1) {
        _dispatch_abort(915LL, *((unsigned __int16 *)v8 + 20) == 1, v2, v3, v4, v5, v6, v7);
      }
      int v14 = 0;
    }

    else if (i == *((unsigned __int16 *)v8 + 20))
    {
      ++*((_WORD *)v8 + 20);
    }

    memcpy((void *)(v8[4] + 72LL * v14), a2, 0x48uLL);
    if (a2[4] != -10) {
      dispatch_kevent_debug("deferred", (uint64_t)a2, 0, 0, (uint64_t)"_dispatch_kq_deferred_update", 0x3B3u);
    }
  }

  else
  {
    _dispatch_kq_drain(a1, (uint64_t)a2, 1, 3u);
  }

BOOL _dispatch_unote_register_muxed( uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t v30 = *((unsigned int *)a1 + 6);
  unsigned int v28 = (char *)&_dispatch_sources + 8 * (v30 & 0x3F);
  BOOL v26 = 1;
  for (uint64_t i = *(void *)v28;
        i && (*(void *)(i + 24) != *((_DWORD *)a1 + 6) || *(__int16 *)(i + 32) != *((char *)a1 + 28));
    ;
  }

  uint64_t v27 = i;
  if (i)
  {
    int v25 = a1[4] & ~*(_DWORD *)(i + 48);
    if (v25)
    {
      *(_DWORD *)(i + 48) |= v25;
      BOOL v26 = *(void *)(*a1 + 40)
          ? (*(uint64_t (**)(uint64_t))(*a1 + 40))(i) & 1
          : _dispatch_kq_immediate_update(-4LL, i + 24) == 0;
      if (!v26) {
        *(_DWORD *)(i + 48) &= ~v25;
      }
    }

    goto LABEL_35;
  }

  uint64_t v27 = _dispatch_calloc(1LL, 96LL);
  uint64_t v38 = a1;
  uint64_t v37 = (void *)(v27 + 24);
  __int16 v36 = 5;
  unsigned int v35 = (unsigned int *)a1;
  uint64_t v34 = 0LL;
  uint64_t v34 = *a1;
  __int16 v33 = 0;
  __int16 v33 = *(_WORD *)(v34 + 12) | 5;
  if ((v33 & 0x200) != 0 && (v33 & 1) == 0) {
    v33 &= ~0x200u;
  }
  __src[0] = v35[6];
  LOWORD(__src[1]) = *(char *)(v34 + 8);
  WORD1(__src[1]) = v33;
  unsigned int v52 = v35[9];
  unsigned int v51 = 0;
  uint64_t v50 = 0LL;
  if ((v52 & 0x4000000) != 0)
  {
    uint64_t v50 = v52 & 0x8E000000 | 0xFFLL;
    unsigned int v56 = v52 & 0xF000;
    unsigned int v51 = v56 >> 12;
    BOOL v55 = v56 >> 12 != 0;
    uint64_t v54 = 523LL;
    if (!(v56 >> 12)) {
      _dispatch_abort(v54, v55, v8, v9, v10, v11, v12, v13);
    }
  }

  else
  {
    uint64_t v50 = v52 & 0x8E0000FF;
    unsigned int v57 = v52 & 0xF00;
    unsigned int v51 = v57 >> 8;
    if (!(v57 >> 8))
    {
      uint64_t v53 = v50;
      goto LABEL_27;
    }
  }

  uint64_t v53 = v50 | (1LL << (v51 + 7));
LABEL_27:
  HIDWORD(__src[1]) = v53;
  __src[2] = v35;
  __src[3] = v35[8] | (unint64_t)*(unsigned int *)(v34 + 16);
  __src[4] = *(unsigned __int16 *)(v34 + 14);
  memset(&__src[5], 0, 32);
  memcpy(v37, __src, 0x48uLL);
  *(_DWORD *)(v27 + 36) = 0x2000000;
  *(void *)(v27 + 4_dispatch_source_set_handler((uint64_t)source, handler, 2LL, 0) = v27 | 1;
  if (*(void *)(*a1 + 40)) {
    BOOL v26 = (*(uint64_t (**)(uint64_t))(*a1 + 40))(v27) & 1;
  }
  else {
    BOOL v26 = _dispatch_kq_immediate_update(-4LL, v27 + 24) == 0;
  }
  if (v26)
  {
    *(_WORD *)(v27 + 34) &= 0xFDFEu;
    uint64_t v14 = *(void *)v28;
    *(void *)uint64_t v27 = *(void *)v28;
    if (v14) {
      *(void *)(*(void *)v28 + 8LL) = v27;
    }
    *(void *)unsigned int v28 = v27;
    *(void *)(v27 + 8) = v28;
  }

  else
  {
    free((void *)v27);
  }

LABEL_35:
  if (v26)
  {
    uint64_t v39 = a1;
    BOOL v49 = (*((_BYTE *)a1 + 29) & 1) == 0;
    uint64_t v48 = 588LL;
    if (!v49) {
      _dispatch_abort(v48, 0LL, a3, a4, a5, a6, a7, a8);
    }
    unsigned int v24 = v39 - 3;
    uint64_t v15 = *(void *)(v27 + 16);
    *(v39 - 3) = v15;
    if (v15) {
      *(void *)(*(void *)(v27 + 16) + 8LL) = v24;
    }
    *(void *)(v27 + 16) = v24;
    v24[1] = v27 + 16;
    void v24[2] = v27;
    uint64_t v42 = a1;
    uint64_t v41 = -4LL;
    uint64_t v40 = 1LL;
    uint64_t v47 = a1;
    uint64_t v46 = -3LL;
    uint64_t v45 = -3LL;
    uint64_t v44 = -3LL;
    a1[2] = -3LL;
    uint64_t v43 = v45;
    _dispatch_thread_getspecific(0LL);
    _evfiltstr(*((char *)a1 + 28));
    _dispatch_log( "%u\t%p\tkevent-source[%p]: %s kevent[%p] { filter = %s, ident = 0x%x }",  v16,  v17,  v18,  v19,  v20,  v21,  v22,  1183LL);
  }

  return v26;
}

      uint64_t v40 = v58;
      if (v58 < 0) {
        firehose_buffer_ring_enqueue(a1, BYTE4(v42));
      }
      if (v40 >= 1)
      {
        qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: Allocation should always fail";
        qword_E4DA8 = v40;
        __break(1u);
        JUMPOUT(0xA52BCLL);
      }

      uint64_t v41 = v42;
      BYTE4(v4_dispatch_source_set_handler((uint64_t)source, handler, 2LL, 1) = 0;
      do
        uint64_t v16 = __ldaxr(v43);
      while (v16 == v42 && __stlxr(v41, v43));
    }

    else
    {
      firehose_buffer_force_connect(a1, v1, v2, v3, v4, v5, v6, v7);
    }

    uint64_t v39 = (unint64_t *)(a1 + 640);
    uint64_t v38 = *(void *)(a1 + 640);
    if (BYTE4(v38) && BYTE4(*(void *)(a1 + 640)) != 255)
    {
      uint64_t v74 = (unint64_t *)(a1 + ((unint64_t)BYTE4(v38) << 12));
      uint64_t v73 = -1LL;
      uint64_t v72 = 0;
      uint64_t v71 = 0;
      uint64_t v70 = 1;
      uint64_t v69 = 0;
      uint64_t v68 = 0LL;
      uint64_t v67 = 24;
      __int128 v66 = 0LL;
      __int128 v65 = 0LL;
      uint64_t v64 = 0;
      unsigned __int8 v63 = 0;
      unsigned __int8 v63 = (-1LL - v74[1]) >> 48 == 0;
      char v62 = 0;
      int v61 = v74;
      do
      {
        if (_os_atomic_mo_has_acquire(0)) {
          unsigned int v24 = __ldaxr(v61);
        }
        else {
          unsigned int v24 = __ldxr(v61);
        }
        __int128 v66 = v24;
        if (!v24 || (HIWORD(v66) & 0x1FF) != (unint64_t)v72)
        {
          __clrex();
          uint64_t v75 = 0LL;
          goto LABEL_74;
        }

        __int128 v65 = v66;
        uint64_t v100 = &v66;
        uint64_t v99 = v70 + v69 + 24;
        if ((unsigned __int16)v66 + v99 <= WORD1(v66) && v63)
        {
          if ((((_BYTE)v70 + 24) & 7) != 0) {
            unsigned int v29 = ((v70 + 24) & 0x1FFF8) + 8;
          }
          else {
            unsigned int v29 = v70 + 24;
          }
          v65 += v29;
          v65 -= (unint64_t)v69 << 16;
          v65 += 0x100000000LL;
          uint64_t v60 = 16;
          uint64_t v98 = &v65;
          unsigned int v97 = 40;
          uint64_t v64 = 0;
        }

        else
        {
          HIBYTE(v65) |= 1u;
          uint64_t v64 = 1;
        }

        if (_os_atomic_mo_has_release(0)) {
          char v62 = __stlxr(v65, v61) == 0;
        }
        else {
          char v62 = __stxr(v65, v61) == 0;
        }
      }

      while (!v62);
      unint64_t v59 = v62;
      if ((v64 & 1) != 0)
      {
        if (BYTE4(v65)) {
          uint64_t v75 = 0LL;
        }
        else {
          uint64_t v75 = -1LL;
        }
      }

      else
      {
        if (v68) {
          *uint64_t v68 = (char *)v74 + WORD1(v65);
        }
        uint64_t v75 = (unsigned __int16)v66;
      }

const char *_evfiltstr(__int16 a1)
{
  unint64_t v2 = (a1 + 24);
  if (v2 <= 0x17) {
    __asm { BR              X8 }
  }

  return "EVFILT_missing";
}

void _dispatch_unote_resume_muxed( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  *(void *)(a1 + 16) |= 1uLL;
  if (*(void *)(*(void *)a1 + 40LL))
  {
    if ((*(_BYTE *)(a1 + 29) & 1) != 0) {
      _dispatch_abort(588LL, (*(_BYTE *)(a1 + 29) & 1) == 0, a3, a4, a5, a6, a7, a8);
    }
    (*(void (**)(void))(*(void *)a1 + 40LL))(*(void *)(a1 - 8));
  }

  else
  {
    if ((*(_BYTE *)(a1 + 29) & 1) != 0) {
      _dispatch_abort(588LL, (*(_BYTE *)(a1 + 29) & 1) == 0, a3, a4, a5, a6, a7, a8);
    }
    _dispatch_kq_deferred_update(-4LL, (__int16 *)(*(void *)(a1 - 8) + 24LL));
  }

uint64_t _dispatch_unote_unregister_muxed( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v28 = (char *)a1;
  if ((*(_BYTE *)(a1 + 29) & 1) != 0) {
    _dispatch_abort(588LL, 0LL, a3, a4, a5, a6, a7, a8);
  }
  BOOL v26 = (void *)(a1 - 24);
  int v25 = *(__int16 **)(a1 - 8);
  BOOL v24 = 0;
  char v23 = 0;
  if (v25[16] == -24) {
    *(_BYTE *)(a1 + 3_dispatch_source_set_handler((uint64_t)source, handler, 2LL, 0) = 0;
  }
  *(void *)(a1 + 16) = 0LL;
  if (*v26) {
    *(void *)(*(void *)(a1 - 24) + 8LL) = *(void *)(a1 - 16);
  }
  **(void **)(a1 - 16) = *(void *)(a1 - 24);
  *BOOL v26 = -1LL;
  *(void *)(a1 - 16) = -1LL;
  *BOOL v26 = -1LL;
  *(void *)(a1 - 16) = -1LL;
  *(void *)(a1 - 8) = 0LL;
  if (*((void *)v25 + 2))
  {
    int v22 = *(_DWORD *)(*(void *)a1 + 16LL);
    for (uint64_t i = (uint64_t *)*((void *)v25 + 2); i; uint64_t i = (uint64_t *)*i)
    {
      unsigned int v28 = (char *)(i + 3);
      v22 |= *((_DWORD *)i + 14);
    }

    if ((*((_DWORD *)v25 + 12) & ~v22) != 0)
    {
      *((_DWORD *)v25 + 12) &= v22;
      BOOL v24 = 1;
    }
  }

  else
  {
    char v23 = 1;
    BOOL v24 = (v25[17] & 2) == 0;
    v25[17] |= 2u;
  }

  if (v24)
  {
    if (*(void *)(*(void *)v28 + 40LL))
    {
    }

    else
    {
      _dispatch_kq_deferred_update(-4LL, v25 + 12);
    }
  }

  if ((v23 & 1) != 0)
  {
    if (*(void *)v25) {
      *(void *)(*(void *)v25 + 8LL) = *((void *)v25 + 1);
    }
    **((void **)v25 + _dispatch_source_set_handler((uint64_t)source, handler, 2LL, 1) = *(void *)v25;
    *(void *)int v25 = -1LL;
    *((void *)v25 + _dispatch_source_set_handler((uint64_t)source, handler, 2LL, 1) = -1LL;
    free(v25);
  }

  _dispatch_thread_getspecific(0LL);
  _evfiltstr(v28[28]);
  _dispatch_log( "%u\t%p\tkevent-source[%p]: %s kevent[%p] { filter = %s, ident = 0x%x }",  v14,  v15,  v16,  v17,  v18,  v19,  v20,  1245LL);
  return 1LL;
}

BOOL _dispatch_unote_register_direct(uint64_t *a1, uint64_t a2)
{
  return _dispatch_kq_unote_update(a2, a1, 5);
}

BOOL _dispatch_kq_unote_update(uint64_t a1, uint64_t *a2, __int16 a3)
{
  uint64_t v80 = (unsigned int *)a2;
  uint64_t v79 = a1;
  __int16 v78 = a3;
  uint64_t v77 = _dispatch_thread_getspecific(0x1DuLL);
  uint64_t v76 = v80;
  uint64_t v75 = 0LL;
  int v74 = 0;
  if ((v78 & 1) != 0)
  {
    uint64_t v155 = v79;
    if (v79 && v155 != -4)
    {
      uint64_t v154 = v155;
      uint64_t v199 = v155;
      unsigned int v198 = 0;
      int v196 = 1;
      int v195 = 1;
      int v197 = 1;
      unsigned int v193 = 0;
      int v191 = 1;
      int v190 = 1;
      int v192 = 1;
      uint64_t v67 = (unsigned int *)(v155 + 96);
      unsigned int v68 = *(_DWORD *)(v155 + 96);
      do
      {
        unsigned int v9 = v68;
        do
          unsigned int v10 = __ldaxr(v67);
        while (v10 == v68 && __stlxr(v68 + 1, v67));
        unsigned int v68 = v10;
      }

      while (v10 != v9);
      unsigned int v189 = v10;
      unsigned int v193 = v10;
      unsigned int v188 = v10;
      unsigned int v194 = v10 + v197;
      unsigned int v198 = v10 + v197;
      if ((int)(v10 + v197) <= 0)
      {
        qword_E4D78 = (uint64_t)"API MISUSE: Resurrection of an object";
        __break(1u);
        JUMPOUT(0x87DB4LL);
      }
    }

    uint64_t v73 = v76;
    uint64_t v102 = v76;
    uint64_t v101 = v79;
    uint64_t v100 = 1LL;
    uint64_t v107 = v76;
    uint64_t v106 = v79 | 1;
    uint64_t v105 = v79 | 1;
    uint64_t v104 = v79 | 1;
    *((void *)v76 + 2) = v79 | 1;
    uint64_t v103 = v105;
  }

  if (v77 && v77[3] == v79)
  {
    int v72 = 0;
    __int16 v11 = *((char *)v76 + 28);
    uint64_t v12 = v76[6];
    unsigned int v123 = v77;
    __int16 v122 = v11;
    uint64_t v121 = v12;
    uint64_t v120 = v76;
    uint64_t v119 = 0LL;
    uint64_t v119 = v77[4];
    for (int i = 0;
          i < *((unsigned __int16 *)v123 + 20)
       && (*(__int16 *)(v119 + 72LL * i + 8) != v122
        || *(void *)(v119 + 72LL * i) != v121
        || *(void *)(v119 + 72LL * i + 16) != (void)v120);
      ;
    }

    int v72 = i;
    if ((v78 & 1) == 0 && (v78 & 4) != 0)
    {
      uint64_t v132 = v79;
      BOOL v131 = v77;
      int v130 = v72;
      if (v79 != -4) {
        _dispatch_thread_setspecific(5LL, 1LL);
      }
      if (v130 == *((unsigned __int16 *)v131 + 21))
      {
        unsigned int v129 = 0;
        unsigned int v129 = *((unsigned __int16 *)v131 + 20);
        *((_WORD *)v131 + memset(__b, 0, 20) = 1;
        uint64_t v13 = v131[4];
        uint64_t v137 = v132;
        uint64_t v136 = v13;
        unsigned int v135 = v129;
        _dispatch_kq_drain(v132, v13, v129, 3LL);
        BOOL v14 = *((unsigned __int16 *)v131 + 20) == 1;
        BOOL v134 = *((unsigned __int16 *)v131 + 20) == 1;
        uint64_t v133 = 915LL;
        if (!v14) {
          _dispatch_abort(v133, v134, v3, v4, v5, v6, v7, v8);
        }
        int v130 = 0;
      }

      else if (v130 == *((unsigned __int16 *)v131 + 20))
      {
        ++*((_WORD *)v131 + 20);
      }

      uint64_t v75 = (_OWORD *)(v131[4] + 72LL * v130);
      uint64_t v71 = v76;
      uint64_t v99 = v76;
      uint64_t v98 = v75;
      __int16 v97 = v78;
      uint64_t v96 = v76;
      uint64_t v95 = 0LL;
      uint64_t v95 = *(void *)v76;
      __int16 v94 = 0;
      __int16 v94 = *(_WORD *)(v95 + 12) | v78;
      if ((v94 & 0x200) != 0 && (v94 & 1) == 0) {
        v94 &= ~0x200u;
      }
      __int128 v66 = v98;
      *(void *)&__int128 v91 = v96[6];
      WORD4(v9_dispatch_source_set_handler((uint64_t)source, handler, 2LL, 1) = *(char *)(v95 + 8);
      WORD5(v9_dispatch_source_set_handler((uint64_t)source, handler, 2LL, 1) = v94;
      unsigned int v140 = v96[9];
      unsigned int v139 = 0;
      uint64_t v138 = 0LL;
      if ((v140 & 0x4000000) != 0)
      {
        uint64_t v138 = v140 & 0x8E000000 | 0xFFLL;
        unsigned int v151 = v140 & 0xF000;
        unsigned int v139 = v151 >> 12;
        BOOL v143 = v151 >> 12 != 0;
        uint64_t v142 = 523LL;
        if (!(v151 >> 12)) {
          _dispatch_abort(v142, v143, v3, v4, v5, v6, v7, v8);
        }
      }

      else
      {
        uint64_t v138 = v140 & 0x8E0000FF;
        unsigned int v153 = v140 & 0xF00;
        unsigned int v139 = v153 >> 8;
        if (!(v153 >> 8))
        {
          uint64_t v141 = v138;
LABEL_42:
          HIDWORD(v9_dispatch_source_set_handler((uint64_t)source, handler, 2LL, 1) = v141;
          *(void *)&__int128 v92 = v96;
          *((void *)&v92 + _dispatch_source_set_handler((uint64_t)source, handler, 2LL, 1) = v96[8] | (unint64_t)*(unsigned int *)(v95 + 16);
          *(void *)uint64_t v93 = *(unsigned __int16 *)(v95 + 14);
          memset(&v93[8], 0, 32);
          *uint64_t v98 = v91;
          __int128 v15 = v92;
          __int128 v16 = *(_OWORD *)v93;
          __int128 v17 = *(_OWORD *)&v93[16];
          *((void *)v66 + 8) = *(void *)&v93[32];
          v66[3] = v17;
          v66[2] = v16;
          v66[1] = v15;
          dispatch_kevent_debug("deferred", (uint64_t)v75, 0, 0, (uint64_t)"_dispatch_kq_unote_update", 0x410u);
          goto LABEL_58;
        }
      }

      uint64_t v141 = v138 | (1LL << (v139 + 7));
      goto LABEL_42;
    }

    uint64_t v126 = v77;
    int v125 = v72;
    if (v72 < *((unsigned __int16 *)v77 + 20))
    {
      int v124 = 0;
      unsigned __int16 v18 = *((_WORD *)v126 + 20) - 1;
      *((_WORD *)v126 + memset(__b, 0, 20) = v18;
      int v124 = v18;
      if (v125 != v18)
      {
        uint64_t v19 = v126[4];
        uint64_t v20 = v19 + 72LL * v125;
        uint64_t v21 = v19 + 72LL * v124;
        *(_OWORD *)uint64_t v20 = *(_OWORD *)v21;
        __int128 v22 = *(_OWORD *)(v21 + 16);
        __int128 v23 = *(_OWORD *)(v21 + 32);
        __int128 v24 = *(_OWORD *)(v21 + 48);
        *(void *)(v20 + 64) = *(void *)(v21 + 64);
        *(_OWORD *)(v20 + 48) = v24;
        *(_OWORD *)(v20 + 32) = v23;
        *(_OWORD *)(v20 + 16) = v22;
      }
    }
  }

  if (v78)
  {
    uint64_t v70 = 0LL;
    memset(v69, 0, sizeof(v69));
    uint64_t v90 = v76;
    uint64_t v89 = v69;
    __int16 v88 = v78;
    uint64_t v87 = v76;
    uint64_t v86 = 0LL;
    uint64_t v86 = *(void *)v76;
    __int16 v85 = 0;
    __int16 v85 = *(_WORD *)(v86 + 12) | v78;
    if ((v85 & 0x200) != 0 && (v85 & 1) == 0) {
      v85 &= ~0x200u;
    }
    __int128 v65 = v89;
    *(void *)&__int128 v82 = v87[6];
    WORD4(v82) = *(char *)(v86 + 8);
    WORD5(v82) = v85;
    unsigned int v146 = v87[9];
    unsigned int v145 = 0;
    uint64_t v144 = 0LL;
    if ((v146 & 0x4000000) != 0)
    {
      uint64_t v144 = v146 & 0x8E000000 | 0xFFLL;
      unsigned int v150 = v146 & 0xF000;
      unsigned int v145 = v150 >> 12;
      BOOL v149 = v150 >> 12 != 0;
      uint64_t v148 = 523LL;
      if (!(v150 >> 12)) {
        _dispatch_abort(v148, v149, v3, v4, v5, v6, v7, v8);
      }
    }

    else
    {
      uint64_t v144 = v146 & 0x8E0000FF;
      unsigned int v152 = v146 & 0xF00;
      unsigned int v145 = v152 >> 8;
      if (!(v152 >> 8))
      {
        uint64_t v147 = v144;
LABEL_57:
        HIDWORD(v82) = v147;
        *(void *)&__int128 v83 = v87;
        *((void *)&v83 + _dispatch_source_set_handler((uint64_t)source, handler, 2LL, 1) = v87[8] | (unint64_t)*(unsigned int *)(v86 + 16);
        *(void *)uint64_t v84 = *(unsigned __int16 *)(v86 + 14);
        memset(&v84[8], 0, 32);
        *uint64_t v89 = v82;
        __int128 v25 = v83;
        __int128 v26 = *(_OWORD *)v84;
        __int128 v27 = *(_OWORD *)&v84[16];
        *((void *)v65 + 8) = *(void *)&v84[32];
        v65[3] = v27;
        v65[2] = v26;
        v65[1] = v25;
        uint64_t v128 = v79;
        BOOL v127 = v69;
        int v74 = _dispatch_kq_drain(v79, v69, 1LL, 3LL);
        goto LABEL_58;
      }
    }

    uint64_t v147 = v144 | (1LL << (v145 + 7));
    goto LABEL_57;
  }

LABEL_58:
  if ((v78 & 1) != 0)
  {
    if (v74)
    {
      uint64_t v172 = v79;
      if (v79 && v172 != -4)
      {
        uint64_t v171 = v172;
        uint64_t v185 = (void *)v172;
        int v184 = 0;
        int v182 = 1;
        int v181 = 1;
        int v183 = 1;
        unsigned int v179 = 0;
        int v177 = 1;
        int v176 = 1;
        int v178 = 1;
        unsigned __int8 v63 = (unsigned int *)(v172 + 96);
        unsigned int v64 = *(_DWORD *)(v172 + 96);
        do
        {
          unsigned int v28 = v64;
          do
            unsigned int v29 = __ldaxr(v63);
          while (v29 == v64 && __stlxr(v64 - 1, v63));
          unsigned int v64 = v29;
        }

        while (v29 != v28);
        unsigned int v175 = v29;
        unsigned int v179 = v29;
        unsigned int v174 = v29;
        unsigned int v180 = v29 - v183;
        int v184 = v29 - v183;
        if (((v29 - v183) & 0x80000000) != 0)
        {
          if (v184 <= -2)
          {
            qword_E4D78 = (uint64_t)"API MISUSE: Over-release of an object";
            __break(1u);
            JUMPOUT(0x88804LL);
          }

          v185[7] = 0xDEAD000000000000LL;
          uint64_t v173 = v185;
          _dispatch_object_dealloc(v185);
        }
      }

      uint64_t v117 = v76;
      uint64_t v116 = 0LL;
      uint64_t v115 = 0LL;
      uint64_t v114 = 0LL;
      *((void *)v76 + 2) = 0LL;
      uint64_t v113 = v115;
    }

    else
    {
      _dispatch_thread_getspecific(0LL);
      _evfiltstr(*((char *)v76 + 28));
      _dispatch_log( "%u\t%p\tkevent-source[%p]: %s kevent[%p] { filter = %s, ident = 0x%x }",  v30,  v31,  v32,  v33,  v34,  v35,  v36,  1060LL);
    }

    return v74 == 0;
  }

  else
  {
    if ((v78 & 2) != 0)
    {
      if (v74 == 36)
      {
        _dispatch_thread_getspecific(0LL);
        _evfiltstr(*((char *)v76 + 28));
        _dispatch_log( "%u\t%p\tkevent-source[%p]: %s kevent[%p] { filter = %s, ident = 0x%x }",  v37,  v38,  v39,  v40,  v41,  v42,  v43,  1067LL);
        return 0;
      }

      uint64_t v157 = v79;
      if (v79 && v157 != -4)
      {
        uint64_t v156 = v157;
        unsigned int v170 = (void *)v157;
        int v169 = 0;
        int v167 = 1;
        int v166 = 1;
        int v168 = 1;
        unsigned int v164 = 0;
        int v162 = 1;
        int v161 = 1;
        int v163 = 1;
        int v61 = (unsigned int *)(v157 + 96);
        unsigned int v62 = *(_DWORD *)(v157 + 96);
        do
        {
          unsigned int v44 = v62;
          do
            unsigned int v45 = __ldaxr(v61);
          while (v45 == v62 && __stlxr(v62 - 1, v61));
          unsigned int v62 = v45;
        }

        while (v45 != v44);
        unsigned int v160 = v45;
        unsigned int v164 = v45;
        unsigned int v159 = v45;
        unsigned int v165 = v45 - v168;
        int v169 = v45 - v168;
        if (((v45 - v168) & 0x80000000) != 0)
        {
          if (v169 <= -2)
          {
            qword_E4D78 = (uint64_t)"API MISUSE: Over-release of an object";
            __break(1u);
            JUMPOUT(0x88B00LL);
          }

          v170[7] = 0xDEAD000000000000LL;
          int v158 = v170;
          _dispatch_object_dealloc(v170);
        }
      }

      int v112 = v76;
      uint64_t v111 = 0LL;
      uint64_t v110 = 0LL;
      uint64_t v109 = 0LL;
      *((void *)v76 + 2) = 0LL;
      uint64_t v108 = v110;
      _dispatch_thread_getspecific(0LL);
      _evfiltstr(*((char *)v76 + 28));
      _dispatch_log( "%u\t%p\tkevent-source[%p]: %s kevent[%p] { filter = %s, ident = 0x%x }",  v46,  v47,  v48,  v49,  v50,  v51,  v52,  1072LL);
    }

    else if ((v78 & 4) != 0)
    {
      _dispatch_thread_getspecific(0LL);
      _evfiltstr(*((char *)v76 + 28));
      _dispatch_log( "%u\t%p\tkevent-source[%p]: %s kevent[%p] { filter = %s, ident = 0x%x }",  v53,  v54,  v55,  v56,  v57,  v58,  v59,  1074LL);
    }

    uint64_t v187 = v74;
    uint64_t v186 = 1077LL;
    if (v74) {
      _dispatch_bug(v186, v187, v3, v4, v5, v6, v7, v8);
    }
    return 1;
  }

BOOL _dispatch_unote_resume_direct(uint64_t *a1)
{
  a1[2] |= 1uLL;
  return _dispatch_kq_unote_update(a1[2] & 0xFFFFFFFFFFFFFFFCLL, a1, 4);
}

uint64_t _dispatch_unote_unregister_direct(uint64_t a1, char a2)
{
  uint64_t v14 = *(void *)(a1 + 16);
  unint64_t v13 = v14 & 0xFFFFFFFFFFFFFFFCLL;
  uint64_t v12 = _dispatch_thread_getspecific(0x1DuLL);
  __int16 v11 = 2;
  BOOL v10 = 0;
  if ((v14 & 0xFFFFFFFFFFFFFFFCLL) != 0xFFFFFFFFFFFFFFFCLL)
  {
    BOOL v10 = 0;
    if (v12) {
      BOOL v10 = v12[3] == v13;
    }
  }

  if (v10)
  {
    __int16 v11 = 6;
    a2 |= 5u;
  }

  if ((v14 & 2) == 0 || (a2 & 1) != 0)
  {
    if (v14 == 2)
    {
      *(void *)(a1 + 16) = 0LL;
      _dispatch_thread_getspecific(0LL);
      _evfiltstr(*(char *)(a1 + 28));
      _dispatch_log( "%u\t%p\tkevent-source[%p]: %s kevent[%p] { filter = %s, ident = 0x%x }",  v2,  v3,  v4,  v5,  v6,  v7,  v8,  1285LL);
      return 1;
    }

    if ((v14 & 1) == 0)
    {
      v11 |= 4u;
      a2 |= 4u;
    }
  }

  if ((a2 & 4) != 0)
  {
    qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: Unregistration failed";
    __break(1u);
    JUMPOUT(0x8906CLL);
  }

  return 0;
}

void _dispatch_event_loop_atfork_child()
{
  _dispatch_mach_host_port_pred = 0LL;
  _dispatch_mach_host_port = 0;
}

void _dispatch_event_loop_poke( unsigned int *a1, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v20 = a1;
  unint64_t v19 = a2;
  int v18 = a3;
  if (a1 == (unsigned int *)-8LL)
  {
    uint64_t v17 = 0LL;
    __int128 v16 = 0u;
    __int128 v15 = 0u;
    v14[1] = 65526LL;
    v14[0] = 1LL;
    v14[2] = -8LL;
    v14[3] = 0x1000000LL;
    _dispatch_kq_deferred_update(-4LL, (__int16 *)v14);
  }

  else
  {
    if (!v20 || v20 == (unsigned int *)-4LL)
    {
      qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: Unsupported wlh configuration";
      qword_E4DA8 = (uint64_t)v20;
      __break(1u);
      JUMPOUT(0x8958CLL);
    }

    unint64_t v27 = v19;
    unint64_t v26 = (v19 >> 37) & 1;
    uint64_t v25 = 1890LL;
    if (!v26) {
      _dispatch_abort(v25, 0LL, a3, a4, a5, a6, a7, a8);
    }
    unint64_t v28 = v19;
    if (((BYTE4(v19) >> 6) & 1) != 0)
    {
      BOOL v24 = v18 >= 0;
      uint64_t v23 = 1892LL;
      if (v18 < 0) {
        _dispatch_abort(v23, v24, a3, a4, a5, a6, a7, a8);
      }
      uint64_t v22 = v18 & 1;
      uint64_t v21 = 1893LL;
      if ((v18 & 1) == 0) {
        _dispatch_abort(v21, v22, a3, a4, a5, a6, a7, a8);
      }
      uint64_t v32 = &_dispatch_mgr_q;
      uint64_t v31 = v20;
      int v30 = 0;
      int v29 = 0;
      uint64_t v34 = &_dispatch_mgr_q;
      uint64_t v33 = v20;
      (*(void (**)(void *, void *))((char *)&stru_20.fileoff + (void)_dispatch_mgr_q))( &_dispatch_mgr_q,  v20);
    }

    else
    {
      unint64_t v13 = _dispatch_thread_getspecific(0x1DuLL);
      if (v13 && v13[3] == (void)v20) {
        _dispatch_kevent_workloop_poke_self((uint64_t)v13, v19, v18, v8, v9, v10, v11, v12);
      }
      else {
        _dispatch_kevent_workloop_poke(v20, v19, v18, v8, v9, v10, v11, v12);
      }
    }
  }

void _dispatch_kevent_workloop_poke_self( uint64_t a1, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v14 = *(void *)(a1 + 24);
  if ((*(_BYTE *)(a1 + 45) & 4) != 0)
  {
    if ((*(_BYTE *)(a1 + 45) & 1) == 0) {
      _dispatch_abort(1790LL, *(_BYTE *)(a1 + 45) & 1, a3, a4, a5, a6, a7, a8);
    }
    if ((int)a3 >= 0)
    {
      if ((a2 & 0xFFFFFFFC) != 0) {
        _dispatch_abort(1802LL, (a2 & 0xFFFFFFFC) == 0, a3, a4, a5, a6, a7, a8);
      }
      if ((a2 & 1) == 0) {
        _dispatch_abort(1803LL, (a2 & 1) != 0, a3, a4, a5, a6, a7, a8);
      }
      if ((a3 & 1) == 0) {
        _dispatch_abort(1804LL, a3 & 1, a3, a4, a5, a6, a7, a8);
      }
      _dispatch_release_no_dispose(v14);
      _dispatch_event_loop_leave_deferred(a1, a2, v8, v9, v10, v11, v12, v13);
    }

    else
    {
      _dispatch_kevent_workloop_override_self(a1, a2, a3, a4, a5, a6, a7, a8);
    }
  }

  else if ((*(_BYTE *)(a1 + 45) & 1) != 0)
  {
    if (!*(void *)(a1 + 8)) {
      _dispatch_abort(1826LL, 0LL, a3, a4, a5, a6, a7, a8);
    }
    if ((a3 & 1) != 0) {
      _dispatch_release_2_no_dispose(v14);
    }
  }

  else
  {
    if ((int)a3 >= 0)
    {
      if ((a3 & 1) == 0) {
        _dispatch_abort(1864LL, a3 & 1, a3, a4, a5, a6, a7, a8);
      }
    }

    else if ((a3 & 1) != 0)
    {
      _dispatch_release_no_dispose(v14);
    }

    else
    {
      _dispatch_retain(v14);
    }

    if (*(void *)(a1 + 8)) {
      _dispatch_abort(1866LL, *(void *)(a1 + 8) == 0LL, a3, a4, a5, a6, a7, a8);
    }
    *(_BYTE *)(a1 + 45) = *(_BYTE *)(a1 + 45) & 0xFE | 1;
    *(_BYTE *)(a1 + 45) = *(_BYTE *)(a1 + 45) & 0xFD | 2;
    *(void *)a1 = *(void *)(v14 + 24);
    *(void *)(a1 + 8) = v14;
    *(_DWORD *)(a1 + 16) = (a2 & 0x700000000LL) >> 32;
  }

void _dispatch_kevent_workloop_poke( unsigned int *a1, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v21 = a1;
  unint64_t v20 = a2;
  int v19 = a3;
  unsigned int v18 = 3;
  uint64_t v17 = 0LL;
  __int128 v16 = 0u;
  __int128 v15 = 0u;
  memset(v14, 0, sizeof(v14));
  unint64_t v44 = a2;
  unint64_t v25 = a2 & 1;
  uint64_t v24 = 1737LL;
  if ((a2 & 1) == 0) {
    _dispatch_abort(v24, 0LL, a3, a4, a5, a6, a7, a8);
  }
  unint64_t v26 = v20;
  BOOL v23 = (v20 & 0x4000000000LL) == 0;
  uint64_t v22 = 1738LL;
  if ((v20 & 0x4000000000LL) != 0) {
    _dispatch_abort(v22, v23, a3, a4, a5, a6, a7, a8);
  }
  unint64_t v38 = v20;
  unint64_t v42 = v20;
  unint64_t v41 = (v20 >> 37) & 1;
  uint64_t v40 = 1659LL;
  if (!v41) {
    _dispatch_abort(v40, 0LL, a3, a4, a5, a6, a7, a8);
  }
  unint64_t v43 = v38;
  if ((v38 & 1) != 0)
  {
    unint64_t v45 = v38;
    int v46 = v38;
    if ((v38 & 0xFFFFFFFC) != 0) {
      int v39 = 2;
    }
    else {
      int v39 = 0;
    }
  }

  else
  {
    int v39 = 3;
  }

  _dispatch_kq_fill_workloop_event((uint64_t)v14, v39, (uint64_t)v21, v20, a5, a6, a7, a8);
  if (_dispatch_kq_poll(v21, v14, 1LL, v14, 1LL, 0LL, 0LL, v18))
  {
    uint64_t v34 = v14;
    uint64_t v33 = 0LL;
    unsigned int v32 = v15;
    dispatch_kevent_debug( "received error",  (uint64_t)v14,  0,  0,  (uint64_t)"_dispatch_kevent_workloop_drain_error",  0x62Du);
    uint64_t v37 = *((_WORD *)v34 + 5) & 0x4000;
    uint64_t v36 = 1582LL;
    if (!v37) {
      _dispatch_abort(v36, 0LL, v8, v9, v10, v11, v12, v13);
    }
    *((_WORD *)v34 + 5) &= ~0x4000u;
    *((_DWORD *)v34 + 7) = v32;
    *((void *)v34 + 4) = 0LL;
    switch(v32)
    {
      case 2u:
        if ((v33 & 1) == 0
          || (*((_WORD *)v34 + 5) & 2) == 0
          || (*((_BYTE *)v34 + 24) & 8) == 0
          || (*((_BYTE *)v34 + 24) & 0x20) == 0)
        {
          unint64_t v31 = 0LL;
          unint64_t v31 = (unint64_t)*((unsigned int *)v34 + 6) << 32;
          v31 |= *((unsigned __int16 *)v34 + 5) << 16;
          v31 |= v32;
          unint64_t v30 = v31;
          qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: Unexpected error from kevent";
          qword_E4DA8 = v31;
          __break(1u);
          JUMPOUT(0x89CFCLL);
        }

        int v35 = 2;
        break;
      case 4u:
        if ((v33 & 4) == 0 || (*((_BYTE *)v34 + 24) & 4) == 0) {
          goto LABEL_39;
        }
        int v35 = 4;
        break;
      case 0x22u:
        uint64_t v29 = 0LL;
        uint64_t v29 = *((int *)v34 + 3);
        qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: Broken priority";
        qword_E4DA8 = v29;
        __break(1u);
        JUMPOUT(0x89D88LL);
      case 0x46u:
        if ((v33 & 2) == 0 || (*((_BYTE *)v34 + 25) & 1) != 0 || !*((void *)v34 + 6) || !*((void *)v34 + 7)) {
          goto LABEL_39;
        }
        int v35 = 70;
        break;
      case 0x69u:
        uint64_t v28 = 0LL;
        uint64_t v28 = *((void *)v34 + 8);
        qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Invalid workloop owner, possible memory corruption";
        qword_E4DA8 = v28;
        __break(1u);
        JUMPOUT(0x89DC8LL);
      default:
LABEL_39:
        uint64_t v27 = (int)v32;
        qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: Unexpected error from kevent";
        qword_E4DA8 = (int)v32;
        __break(1u);
        JUMPOUT(0x89E08LL);
    }

    __break(1u);
  }

  if (v19 < 0)
  {
    if ((v19 & 1) != 0) {
      _dispatch_release_2_tailcall(v21);
    }
  }

  else
  {
    _dispatch_release_tailcall(v21);
  }

void _dispatch_event_loop_drain(unsigned int a1)
{
  uint64_t v17 = _dispatch_thread_getspecific(0x1DuLL);
  __int128 v16 = (void *)v17[3];
  do
  {
    if ((*((_BYTE *)v17 + 45) & 2) != 0)
    {
      unint64_t v14 = v16[7];
      if ((*((_BYTE *)v17 + 45) & 1) == 0) {
        _dispatch_abort(1925LL, 0LL, v1, v2, v3, v4, v5, v6);
      }
      *((_BYTE *)v17 + 45) &= ~2u;
      uint64_t v21 = v17[4];
      for (int i = 0;
            i < *((unsigned __int16 *)v17 + 20)
         && (*(__int16 *)(v21 + 72LL * i + 8) != -17
          || *(void **)(v21 + 72LL * i) != v16
          || *(void **)(v21 + 72LL * i + 16) != v16);
        ;
      }

      if (i == *((unsigned __int16 *)v17 + 20))
      {
        if (i >= 16) {
          _dispatch_abort(1496LL, i < 16, v1, v2, v3, v4, v5, v6);
        }
        ++*((_WORD *)v17 + 20);
      }

      _dispatch_kq_fill_workloop_event(v17[4] + 72LL * i, 2, (uint64_t)v16, v14, v3, v4, v5, v6);
    }

    int v15 = *((unsigned __int16 *)v17 + 20);
    *((_WORD *)v17 + memset(__b, 0, 20) = 0;
    _dispatch_kq_drain((uint64_t)v16, v17[4], v15, a1);
    if (v16 && v16 != (void *)-4LL)
    {
      if (*(_BYTE *)(*v16 + 16LL) == 18LL) {
        int v19 = v16;
      }
      else {
        int v19 = 0LL;
      }
    }

    else
    {
      int v19 = 0LL;
    }

    if (v19)
    {
      uint64_t v13 = v19[6];
      if (v13)
      {
        if (*(_BYTE *)(v13 + 6)) {
          _dispatch_event_loop_drain_timers(v13, 6u, v7, v8, v9, v10, v11, v12);
        }
      }
    }
  }

  while ((a1 & 1) != 0 && (a1 & 2) == 0 && _dispatch_thread_getspecific(5uLL));
}

uint64_t _dispatch_kq_drain(uint64_t a1, uint64_t a2, int a3, unsigned int a4)
{
  uint64_t v21 = a1;
  uint64_t v20 = a2;
  int v19 = a3;
  unsigned int v18 = a4;
  BOOL v17 = (a4 & 2) == 0;
  int v16 = 0;
  uint64_t v14 = 16LL;
  unsigned int v15 = 16;
  int i = 0;
  uint64_t v12 = 0LL;
  uint64_t v11 = 0LL;
  uint64_t v10 = 0LL;
  if ((a4 & 2) == 0)
  {
    uint64_t v23 = 1LL;
    uint64_t v22 = 803LL;
    uint64_t v9 = &v10;
    uint64_t v10 = 0x8000LL;
    uint64_t v8 = &v5 - 4096;
    bzero(&v5 - 4096, 0x8000uLL);
    uint64_t v11 = v8;
    uint64_t v12 = v9;
  }

  for (int i = 0; i < v19; ++i)
    dispatch_kevent_debug(0LL, v20 + 72LL * i, i, v19, (uint64_t)"_dispatch_kq_drain", 0x32Du);
  if (v17) {
    _dispatch_thread_setspecific(5LL, 0LL);
  }
  int v19 = _dispatch_kq_poll(v21, v20, v19, v24, v15, v11, v12, v18);
  if (v19)
  {
    if ((v18 & 2) != 0)
    {
      int v16 = 0;
      int i = 0;
      while (v16 < v19)
      {
        if ((v24[36 * v16 + 5] & 0x4000) != 0 && *(void *)&v24[36 * v16 + 16])
        {
          uint64_t v6 = 72LL;
          uint64_t v7 = v24;
          _dispatch_kevent_drain((unsigned __int8 *)&v24[36 * v16]);
          int i = *(void *)((char *)v7 + v16 * v6 + 32);
        }

        ++v16;
      }
    }

    else
    {
      if ((v24[5] & 0x4000) != 0) {
        _dispatch_thread_setspecific(5LL, 1LL);
      }
      int v16 = 0;
      int i = 0;
      while (v16 < v19)
        _dispatch_kevent_drain((unsigned __int8 *)&v24[36 * v16++]);
    }
  }

  else
  {
    return 0;
  }

  return i;
}

void _dispatch_event_loop_merge(uint64_t a1, unsigned int a2)
{
  uint64_t v17 = a1;
  unsigned int v16 = a2;
  unsigned int v15 = _dispatch_thread_getspecific(0x1DuLL);
  uint64_t v14 = 0LL;
  uint64_t v14 = (void *)v15[3];
  uint64_t v13 = &v8;
  uint64_t v9 = (char *)&v8 - ((72LL * v16 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v12 = v16;
  __memcpy_chk(v9, v17, 72LL * v16, -1LL);
  *((_WORD *)v15 + 2_dispatch_source_set_handler((uint64_t)source, handler, 2LL, 1) = 14;
  if (v14 == (void *)-4LL)
  {
    if (v15[1])
    {
      if (*((_WORD *)v15 + 20)) {
        _dispatch_event_loop_drain(3u);
      }
    }
  }

  else if (*(_BYTE *)(*v14 + 16LL) == 18LL)
  {
    uint64_t v10 = 0LL;
    uint64_t v10 = v14[6];
    if (v10)
    {
      if (*(_BYTE *)(v10 + 6)) {
        _dispatch_event_loop_drain_timers(v10, 6u, v2, v3, v4, v5, v6, v7);
      }
    }
  }

void _dispatch_kevent_drain(unsigned __int8 *a1)
{
  if (*((__int16 *)a1 + 4) == -10)
  {
    dispatch_kevent_debug("received", (uint64_t)a1, 0, 0, (uint64_t)"_dispatch_kevent_drain", 0x22Du);
    return;
  }

  if (*((__int16 *)a1 + 4) == -17)
  {
    _dispatch_kevent_workloop_poke_drain((uint64_t)a1);
    return;
  }

  dispatch_kevent_debug("received", (uint64_t)a1, 0, 0, (uint64_t)"_dispatch_kevent_drain", 0x235u);
  if ((*((_WORD *)a1 + 5) & 0x4000) != 0)
  {
    if (*((__int16 *)a1 + 4) != -5 || *((void *)a1 + 4) != 3LL)
    {
      _dispatch_kevent_print_error((uint64_t)a1);
      return;
    }

    *((_WORD *)a1 + 5) = 274;
    *((_DWORD *)a1 + 6) = -2080374784;
    *((void *)a1 + 4) = 0LL;
    dispatch_kevent_debug("synthetic NOTE_EXIT", (uint64_t)a1, 0, 0, (uint64_t)"_dispatch_kevent_drain", 0x23Eu);
  }

  if (*((__int16 *)a1 + 4) == -7)
  {
    uint64_t v9 = *((void *)a1 + 2);
    unsigned int v8 = *a1;
    if (*(void *)a1 != (v8 | 0xFFFFFFFFFFFFFF00LL)) {
      _dispatch_abort(2409LL, *(void *)a1 == (v8 | 0xFFFFFFFFFFFFFF00LL), v1, v2, v3, v4, v5, v6);
    }
    if (v8 >= 9) {
      _dispatch_abort(2410LL, v8 < 9, v1, v2, v3, v4, v5, v6);
    }
    *(_BYTE *)(v9 + 6) |= (1 << (*a1 % 3u)) | 0x80;
    *(_BYTE *)(v9 + 32LL * v8 + 7) = *(_BYTE *)(v9 + 32LL * v8 + 7) & 0xFD | 2;
    *(_BYTE *)(v9 + 32LL * v8 + 7) &= ~1u;
  }

  else if (*((__int16 *)a1 + 4) == -8 {
         && (_dispatch_kevent_mach_msg_size((uint64_t)a1)
  }
          || _dispatch_kevent_has_machmsg_rcv_error((uint64_t)a1)))
  {
    _dispatch_kevent_mach_msg_drain((uint64_t)a1);
  }

  else if ((*((void *)a1 + 2) & 1LL) != 0)
  {
    _dispatch_kevent_merge_muxed((uint64_t)a1);
  }

  else
  {
    _dispatch_kevent_merge(*((void *)a1 + 2), (uint64_t)a1);
  }

void _dispatch_event_loop_leave_immediate(unint64_t a1)
{
  unint64_t v20 = a1;
  int v19 = _dispatch_thread_getspecific(0x1DuLL);
  uint64_t v18 = 0LL;
  uint64_t v18 = v19[3];
  unsigned int v17 = 131075;
  uint64_t v16 = 0LL;
  __int128 v15 = 0u;
  __int128 v14 = 0u;
  memset(v13, 0, sizeof(v13));
  unint64_t v25 = v20;
  BOOL v24 = (v20 & 0x2000000000LL) == 0;
  uint64_t v23 = 1994LL;
  if ((v20 & 0x2000000000LL) != 0) {
    _dispatch_abort(v23, v24, v1, v2, v3, v4, v5, v6);
  }
  uint64_t v22 = *((_BYTE *)v19 + 45) & 1;
  uint64_t v21 = 2004LL;
  if (!v22) {
    _dispatch_abort(v21, 0LL, v1, v2, v3, v4, v5, v6);
  }
  *((_BYTE *)v19 + 45) &= ~1u;
  *((_BYTE *)v19 + 45) &= ~2u;
  _dispatch_kq_fill_workloop_event((uint64_t)v13, 6, v18, v20, v3, v4, v5, v6);
  if (_dispatch_kq_poll(v18, (uint64_t)v13, 1u, (uint64_t)v13, 1u, 0LL, 0LL, v17))
  {
    uint64_t v33 = v13;
    uint64_t v32 = 0LL;
    unsigned int v31 = v14;
    dispatch_kevent_debug( "received error",  (uint64_t)v13,  0,  0,  (uint64_t)"_dispatch_kevent_workloop_drain_error",  0x62Du);
    uint64_t v36 = *((_WORD *)v33 + 5) & 0x4000;
    uint64_t v35 = 1582LL;
    if (!v36) {
      _dispatch_abort(v35, 0LL, v7, v8, v9, v10, v11, v12);
    }
    *((_WORD *)v33 + 5) &= ~0x4000u;
    *((_DWORD *)v33 + 7) = v31;
    *((void *)v33 + 4) = 0LL;
    switch(v31)
    {
      case 2u:
        if ((v32 & 1) == 0
          || (*((_WORD *)v33 + 5) & 2) == 0
          || (*((_BYTE *)v33 + 24) & 8) == 0
          || (*((_BYTE *)v33 + 24) & 0x20) == 0)
        {
          unint64_t v30 = 0LL;
          unint64_t v30 = (unint64_t)*((unsigned int *)v33 + 6) << 32;
          v30 |= *((unsigned __int16 *)v33 + 5) << 16;
          v30 |= v31;
          unint64_t v29 = v30;
          qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: Unexpected error from kevent";
          qword_E4DA8 = v30;
          __break(1u);
          JUMPOUT(0x8AED8LL);
        }

        int v34 = 2;
        break;
      case 4u:
        if ((v32 & 4) == 0 || (*((_BYTE *)v33 + 24) & 4) == 0) {
          goto LABEL_32;
        }
        int v34 = 4;
        break;
      case 0x22u:
        uint64_t v28 = 0LL;
        uint64_t v28 = *((int *)v33 + 3);
        qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: Broken priority";
        qword_E4DA8 = v28;
        __break(1u);
        JUMPOUT(0x8AF64LL);
      case 0x46u:
        if ((v32 & 2) == 0 || (*((_BYTE *)v33 + 25) & 1) != 0 || !*((void *)v33 + 6) || !*((void *)v33 + 7)) {
          goto LABEL_32;
        }
        int v34 = 70;
        break;
      case 0x69u:
        uint64_t v27 = 0LL;
        uint64_t v27 = *((void *)v33 + 8);
        qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Invalid workloop owner, possible memory corruption";
        qword_E4DA8 = v27;
        __break(1u);
        JUMPOUT(0x8AFA4LL);
      default:
LABEL_32:
        uint64_t v26 = (int)v31;
        qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: Unexpected error from kevent";
        qword_E4DA8 = (int)v31;
        __break(1u);
        JUMPOUT(0x8AFE4LL);
    }

    __break(1u);
  }

void _dispatch_kq_fill_workloop_event( uint64_t a1, int a2, uint64_t a3, unint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v14 = 0;
  unsigned int v13 = 0;
  uint64_t v12 = 0LL;
  switch(a2)
  {
    case 0:
    case 1:
    case 2:
      if (((a4 >> 37) & 1) == 0) {
        _dispatch_abort(1439LL, 0LL, a3, a4, a5, a6, a7, a8);
      }
      if ((a4 & 1) == 0) {
        _dispatch_abort(1440LL, 0LL, a3, a4, a5, a6, a7, a8);
      }
      __int16 v11 = 5;
      uint64_t v12 = 0x3700000001LL;
      unsigned int v13 = 272;
      if ((a4 & 2) != 0)
      {
        unsigned int v13 = 400;
        uint64_t v12 = 0x3700000003LL;
      }

      unsigned int v16 = (a4 & 0x700000000LL) >> 32;
      unsigned int v15 = *(_DWORD *)(*(void *)(a3 + 24) + 84LL);
      if (!v16) {
        LOBYTE(v16) = 1;
      }
      if ((v15 & 0x8000000) != 0)
      {
        qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: Waking up a kq with cooperative thread request is not supported";
        qword_E4DA8 = v15;
        __break(1u);
        JUMPOUT(0x8B2A8LL);
      }

      int v14 = (1LL << (v16 + 7)) | 0xFF | v15 & 0x80000000;
      break;
    case 3:
      goto LABEL_16;
    case 4:
    case 5:
      unsigned int v13 = 256;
LABEL_16:
      if ((a4 & 1) != 0) {
        _dispatch_abort(1459LL, (a4 & 1) == 0, a3, a4, a5, a6, a7, a8);
      }
      __int16 v11 = 7;
      uint64_t v12 = 1LL;
      break;
    case 6:
      __int16 v11 = 7;
      unsigned int v13 = 32;
      break;
    default:
      qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: Invalid transition";
      qword_E4DA8 = a2;
      __break(1u);
      JUMPOUT(0x8B3A4LL);
  }

  *(void *)&__int128 v8 = a3;
  WORD4(v8) = -17;
  WORD5(v8) = v11;
  HIDWORD(v8) = v14;
  *(void *)&__int128 v9 = a3;
  *((void *)&v9 + _dispatch_source_set_handler((uint64_t)source, handler, 2LL, 1) = v13 | 1LL;
  *(void *)&__int128 v10 = a3 + 56;
  *((void *)&v10 + _dispatch_source_set_handler((uint64_t)source, handler, 2LL, 1) = v12;
  *(_OWORD *)a1 = v8;
  *(void *)(a1 + 64) = a4;
  *(_OWORD *)(a1 + 48) = v10;
  *(_OWORD *)(a1 + 32) = 0uLL;
  *(_OWORD *)(a1 + 16) = v9;
  dispatch_kevent_debug(_dispatch_workloop_actions[a2], a1, 0, 0, (uint64_t)"_dispatch_kq_fill_workloop_event", 0x5CDu);
}

uint64_t _dispatch_kq_poll( uint64_t a1, uint64_t a2, unsigned int a3, uint64_t a4, unsigned int a5, uint64_t a6, uint64_t a7, unsigned int a8)
{
  uint64_t v20 = a1;
  uint64_t v19 = a2;
  unsigned int v18 = a3;
  uint64_t v17 = a4;
  unsigned int v16 = a5;
  uint64_t v15 = a6;
  uint64_t v14 = a7;
  unsigned int v13 = a8;
  char v12 = 0;
  BOOL v24 = &_dispatch_kq_poll_pred;
  uint64_t v23 = &v12;
  dispatch_function_t v22 = (dispatch_function_t)_dispatch_kq_init;
  if (_dispatch_kq_poll_pred != -1LL) {
    dispatch_once_f(v24, v23, v22);
  }
  if ((v12 & 1) != 0)
  {
    _dispatch_memorypressure_init();
    _voucher_activity_debug_channel_init();
  }

  while (2)
  {
    if (!v20)
    {
      qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: Invalid wlh";
      qword_E4DA8 = 0LL;
      __break(1u);
      JUMPOUT(0x8B580LL);
    }

    if (v20 == -4)
    {
      unsigned int v10 = _dispatch_kq_fd();
      if ((_dispatch_kevent_workqueue_enabled & 1) != 0) {
        v13 |= 0x20u;
      }
      unsigned int v11 = kevent_qos(v10, v19, v18, v17, v16, v15);
    }

    else
    {
      v13 |= 0x400u;
      if ((v13 & 2) == 0) {
        v13 |= 0x20000u;
      }
      unsigned int v11 = kevent_id(v20, v19, v18, v17, v16, v15, v14, v13);
    }

    if (v11 == -1)
    {
      uint64_t v25 = 1LL;
      uint64_t v26 = 1LL;
      unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
      int v9 = **(_DWORD **)(StatusReg + 8);
      switch(v9)
      {
        case 2:
          if ((v13 & 2) == 0 || (v13 & 0x20000) == 0) {
            goto LABEL_21;
          }
          unsigned int v21 = 0;
          break;
        case 4:
          continue;
        case 9:
          qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Do not close random Unix descriptors";
          qword_E4DA8 = v9;
          __break(1u);
          JUMPOUT(0x8B718LL);
        case 12:
          _dispatch_temporary_resource_shortage();
          continue;
        default:
LABEL_21:
          qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Unexpected error from kevent";
          qword_E4DA8 = v9;
          __break(1u);
          JUMPOUT(0x8B784LL);
      }
    }

    else
    {
      return v11;
    }

    return v21;
  }

void _dispatch_event_loop_leave_deferred( uint64_t a1, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  BOOL v8 = 0;
  if ((a2 & 0x2000000000LL) != 0) {
    BOOL v8 = (a2 & 0x800000000LL) != 0;
  }
  if (v8)
  {
    if ((a2 & 0xFFFFFFFC) != 0) {
      int v17 = a2 | 3;
    }
    else {
      int v17 = 0;
    }
    uint64_t v15 = *(void *)(a1 + 32);
    for (int i = 0;
          i < *(unsigned __int16 *)(a1 + 40)
       && (*(__int16 *)(v15 + 72LL * i + 8) != -17
        || *(void *)(v15 + 72LL * i) != *(void *)(a1 + 24)
        || *(void *)(v15 + 72LL * i + 16) != v17);
      ;
    }

    if (i == *(unsigned __int16 *)(a1 + 40))
    {
      if (i >= 16) {
        _dispatch_abort(2028LL, i < 16, a3, a4, a5, a6, a7, a8);
      }
      ++*(_WORD *)(a1 + 40);
    }

    if ((a2 & 0xFFFFFFFC) != 0) {
      unsigned int v18 = a2 | 3;
    }
    else {
      unsigned int v18 = 0;
    }
    _dispatch_kq_fill_workloop_sync_event(*(void *)(a1 + 32) + 72LL * i, 7, *(void *)(a1 + 24), a2, v18, a6, a7, a8);
  }

  if ((a2 & 0x2000000000LL) == 0) {
    _dispatch_abort(1659LL, 0LL, a3, a4, a5, a6, a7, a8);
  }
  if ((a2 & 1) != 0)
  {
    if ((a2 & 0xFFFFFFFC) != 0) {
      int v16 = 2;
    }
    else {
      int v16 = 0;
    }
  }

  else
  {
    int v16 = 3;
  }

  if ((*(_BYTE *)(a1 + 45) & 1) == 0) {
    _dispatch_abort(2037LL, 0LL, a3, a4, a5, a6, a7, a8);
  }
  *(_BYTE *)(a1 + 45) &= ~1u;
  *(_BYTE *)(a1 + 45) &= ~2u;
  uint64_t v11 = *(void *)(a1 + 24);
  uint64_t v13 = *(void *)(a1 + 32);
  for (int j = 0;
        j < *(unsigned __int16 *)(a1 + 40)
     && (*(__int16 *)(v13 + 72LL * j + 8) != -17
      || *(void *)(v13 + 72LL * j) != *(void *)(a1 + 24)
      || *(void *)(v13 + 72LL * j + 16) != *(void *)(a1 + 24));
    ;
  }

  if (j == *(unsigned __int16 *)(a1 + 40))
  {
    if (j >= 16) {
      _dispatch_abort(1496LL, j < 16, a3, a4, a5, a6, a7, a8);
    }
    ++*(_WORD *)(a1 + 40);
  }

  _dispatch_kq_fill_workloop_event(*(void *)(a1 + 32) + 72LL * j, v16, v11, a2, a5, a6, a7, a8);
}

void _dispatch_kq_fill_workloop_sync_event( uint64_t a1, int a2, uint64_t a3, unint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v20 = a5;
  unsigned int v18 = 0;
  uint64_t v16 = 0LL;
  switch(a2)
  {
    case 7:
      LOBYTE(v1_dispatch_source_set_handler((uint64_t)source, handler, 2LL, 1) = 0;
      if ((a4 & 0x2000000000LL) != 0) {
        int v11 = (BYTE4(a4) >> 3) & 1;
      }
      if ((v11 & 1) == 0) {
        _dispatch_abort(1516LL, v11 & 1, a3, a4, a5, a6, a7, a8);
      }
      if (((a4 >> 1) & 1) == 0) {
        _dispatch_abort(1517LL, 0LL, a3, a4, a5, a6, a7, a8);
      }
      __int16 v15 = 9;
      unsigned int v17 = 392;
      uint64_t v16 = 0x3800000002LL;
      break;
    case 8:
      __int16 v15 = 9;
      unsigned int v17 = 4;
      unsigned int v18 = _dispatch_thread_getspecific(4uLL);
      unsigned int v8 = (*(void *)&v18 & 0x3FFF00uLL) >> 8;
      unsigned int v9 = __clz(__rbit32(v8));
      if (v8) {
        unsigned int v10 = v9 + 1;
      }
      else {
        unsigned int v10 = 0;
      }
      if (!v10) {
        unsigned int v18 = 2303;
      }
      break;
    case 9:
      __int16 v15 = 9;
      unsigned int v17 = 136;
      break;
    case 10:
      __int16 v15 = 9;
      unsigned int v17 = 8;
      break;
    case 11:
      __int16 v15 = 6;
      unsigned int v17 = 40;
      break;
    default:
      qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: Invalid transition";
      qword_E4DA8 = a2;
      __break(1u);
      JUMPOUT(0x8C098LL);
  }

  *(void *)&__int128 v12 = v20;
  WORD4(v12) = -17;
  WORD5(v12) = v15;
  HIDWORD(v12) = v18;
  *(void *)&__int128 v13 = a3;
  *((void *)&v13 + _dispatch_source_set_handler((uint64_t)source, handler, 2LL, 1) = v17;
  *(void *)&__int128 v14 = 0LL;
  *((void *)&v14 + _dispatch_source_set_handler((uint64_t)source, handler, 2LL, 1) = v16;
  *(_OWORD *)a1 = v12;
  *(void *)(a1 + 64) = a4;
  *(_OWORD *)(a1 + 48) = v14;
  *(_OWORD *)(a1 + 32) = 0uLL;
  *(_OWORD *)(a1 + 16) = v13;
  if ((v17 & 0x80) != 0) {
    *(void *)(a1 + 48) = a3 + 56;
  }
  dispatch_kevent_debug( _dispatch_workloop_actions[a2],  a1,  0,  0,  (uint64_t)"_dispatch_kq_fill_workloop_sync_event",  0x620u);
}

uint64_t _dispatch_event_loop_cancel_waiter( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v22 = a1;
  uint64_t v21 = 0LL;
  uint64_t v21 = *(void *)(a1 + 48);
  unsigned int v20 = 3;
  uint64_t v19 = 0LL;
  __int128 v18 = 0u;
  __int128 v17 = 0u;
  memset(v16, 0, sizeof(v16));
  while (1)
  {
    _dispatch_kq_fill_workloop_sync_event((uint64_t)v16, 11, v21, 0LL, *(unsigned int *)(v22 + 100), a6, a7, a8);
    uint64_t result = _dispatch_kq_poll(v21, (uint64_t)v16, 1u, (uint64_t)v16, 1u, 0LL, 0LL, v20);
    if (!(_DWORD)result) {
      return result;
    }
    BOOL v9 = ((*(unsigned __int8 *)(v22 + 106) >> 5) & 1) == 0;
    unint64_t v30 = v16;
    BOOL v29 = v9;
    unsigned int v28 = v17;
    dispatch_kevent_debug( "received error",  (uint64_t)v16,  0,  0,  (uint64_t)"_dispatch_kevent_workloop_drain_error",  0x62Du);
    uint64_t v33 = *((_WORD *)v30 + 5) & 0x4000;
    uint64_t v32 = 1582LL;
    if (!v33) {
      _dispatch_abort(v32, 0LL, v10, v11, v12, v13, v14, v15);
    }
    *((_WORD *)v30 + 5) &= ~0x4000u;
    *((_DWORD *)v30 + 7) = v28;
    *((void *)v30 + 4) = 0LL;
    switch(v28)
    {
      case 2u:
        if (!v29
          || (*((_WORD *)v30 + 5) & 2) == 0
          || (*((_BYTE *)v30 + 24) & 8) == 0
          || (*((_BYTE *)v30 + 24) & 0x20) == 0)
        {
          unint64_t v27 = 0LL;
          unint64_t v27 = (unint64_t)*((unsigned int *)v30 + 6) << 32;
          v27 |= *((unsigned __int16 *)v30 + 5) << 16;
          v27 |= v28;
          unint64_t v26 = v27;
          qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: Unexpected error from kevent";
          qword_E4DA8 = v27;
          __break(1u);
          JUMPOUT(0x8C430LL);
        }

        int v31 = 2;
        break;
      case 4u:
        if (!(v29 & 4) || (*((_BYTE *)v30 + 24) & 4) == 0) {
          goto LABEL_29;
        }
        int v31 = 4;
        break;
      case 0x22u:
        uint64_t v25 = 0LL;
        uint64_t v25 = *((int *)v30 + 3);
        qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: Broken priority";
        qword_E4DA8 = v25;
        __break(1u);
        JUMPOUT(0x8C4BCLL);
      case 0x46u:
        if (!(v29 & 2) || (*((_BYTE *)v30 + 25) & 1) != 0 || !*((void *)v30 + 6) || !*((void *)v30 + 7)) {
          goto LABEL_29;
        }
        int v31 = 70;
        break;
      case 0x69u:
        uint64_t v24 = 0LL;
        uint64_t v24 = *((void *)v30 + 8);
        qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Invalid workloop owner, possible memory corruption";
        qword_E4DA8 = v24;
        __break(1u);
        JUMPOUT(0x8C4FCLL);
      default:
LABEL_29:
        uint64_t v23 = (int)v28;
        qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: Unexpected error from kevent";
        qword_E4DA8 = (int)v28;
        __break(1u);
        JUMPOUT(0x8C53CLL);
    }

    thread_switch(*(_DWORD *)(v22 + 100), 4, 1u);
  }

void _dispatch_event_loop_wake_owner(uint64_t a1, uint64_t a2, unint64_t a3, unint64_t a4)
{
  uint64_t v47 = _dispatch_thread_getspecific(0x1DuLL);
  uint64_t v46 = *(void *)(a1 + 48);
  unsigned int v44 = 0;
  if (a2 == -4 || !v47 || v47[3] != a2) {
    goto LABEL_41;
  }
  if ((*((_BYTE *)v47 + 45) & 1) == 0) {
    _dispatch_abort(2109LL, 0LL, v4, v5, v6, v7, v8, v9);
  }
  *((_BYTE *)v47 + 45) &= ~1u;
  *((_BYTE *)v47 + 45) &= ~2u;
  if (a2 == v46)
  {
    if ((a3 & 1) == 0) {
      _dispatch_abort(2114LL, 0LL, v4, v5, v6, v7, v8, v9);
    }
    if ((a3 & 2) != 0) {
      _dispatch_abort(2115LL, 0LL, v4, v5, v6, v7, v8, v9);
    }
    if ((a4 & 2) != 0) {
      _dispatch_abort(2116LL, (a4 & 2) == 0, v4, v5, v6, v7, v8, v9);
    }
    if ((a4 & 1) != 0) {
      int v45 = 2;
    }
    else {
      int v45 = 5;
    }
    uint64_t v54 = v47[4];
    for (int i = 0;
          i < *((unsigned __int16 *)v47 + 20)
       && (*(__int16 *)(v54 + 72LL * i + 8) != -17
        || *(void *)(v54 + 72LL * i) != a2
        || *(void *)(v54 + 72LL * i + 16) != a2);
      ;
    }

    if (i == *((unsigned __int16 *)v47 + 20))
    {
      if (i >= 16) {
        _dispatch_abort(1496LL, 0LL, v4, v5, v6, v7, v8, v9);
      }
      ++*((_WORD *)v47 + 20);
    }

    _dispatch_kq_fill_workloop_event(v47[4] + 72LL * i, v45, a2, a4, v6, v7, v8, v9);
    uint64_t v56 = v47[4];
    for (int j = 0;
          j < *((unsigned __int16 *)v47 + 20)
       && (*(__int16 *)(v56 + 72LL * j + 8) != -17
        || *(void *)(v56 + 72LL * j) != a2
        || *(void *)(v56 + 72LL * j + 16) != *(_DWORD *)(a1 + 100));
      ;
    }

    if (j == *((unsigned __int16 *)v47 + 20))
    {
      if (j >= 16) {
        _dispatch_abort(2128LL, j < 16, v10, v11, v12, v13, v14, v15);
      }
      ++*((_WORD *)v47 + 20);
    }

    _dispatch_kq_fill_workloop_sync_event(v47[4] + 72LL * j, 9, a2, a4, *(unsigned int *)(a1 + 100), v13, v14, v15);
  }

  else
  {
LABEL_41:
    if (((a3 ^ a4) & 1) != 0)
    {
      if ((a3 & 1) == 0) {
        _dispatch_abort(2138LL, 0LL, v4, v5, v6, v7, v8, v9);
      }
      if ((a4 & 2) != 0) {
        _dispatch_abort(2139LL, (a4 & 2) == 0, v4, v5, v6, v7, v8, v9);
      }
      unsigned int v44 = 1;
      _dispatch_kq_fill_workloop_event((uint64_t)v57, 5, a2, a4, v6, v7, v8, v9);
    }

    if ((a4 & 0x2000000000LL) != 0)
    {
      unsigned int v16 = v44++;
      _dispatch_kq_fill_workloop_sync_event((uint64_t)&v57[72 * v16], 9, a2, a4, *(unsigned int *)(a1 + 100), v7, v8, v9);
    }

    if ((*(_BYTE *)(a1 + 106) & 0x80) == 0 && (a3 & 0x2000000000LL) != 0 && (a3 & 2) == 0)
    {
      unsigned int v43 = _dispatch_thread_getspecific(3uLL);
      unsigned int v17 = v44++;
      _dispatch_kq_fill_workloop_sync_event((uint64_t)&v57[72 * v17], 11, a2, a3, v43, v18, v19, v20);
    }

    if (_dispatch_kq_poll(a2, (uint64_t)v57, v44, (uint64_t)v57, v44, 0LL, 0LL, 3u))
    {
      BOOL v42 = 0;
      if (v46 != -4) {
        BOOL v42 = v46 != a2;
      }
      if (v42) {
        _dispatch_bug_deprecated( (uint64_t)"Changing target queue hierarchy with a dispatch_sync in flight",  v21,  v22,  v23,  v24,  v25,  v26,  v27);
      }
      int v52 = v62;
      dispatch_kevent_debug( "received error",  (uint64_t)v57,  0,  0,  (uint64_t)"_dispatch_kevent_workloop_drain_error",  0x62Du);
      if ((v58 & 0x4000) == 0) {
        _dispatch_abort(1582LL, 0LL, v28, v29, v30, v31, v32, v33);
      }
      v58 &= ~0x4000u;
      int v61 = v52;
      uint64_t v62 = 0LL;
      if (v52 != 2)
      {
        if (v52 != 4)
        {
          if (v52 == 34)
          {
            qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: Broken priority";
            qword_E4DA8 = v59;
            __break(1u);
            JUMPOUT(0x8D074LL);
          }

          if (v52 == 105)
          {
            qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Invalid workloop owner, possible memory corruption";
            qword_E4DA8 = v63;
            __break(1u);
            JUMPOUT(0x8D0B8LL);
          }
        }

        qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: Unexpected error from kevent";
        qword_E4DA8 = v52;
        __break(1u);
        JUMPOUT(0x8D0FCLL);
      }

      qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: Unexpected error from kevent";
      qword_E4DA8 = ((unint64_t)v60 << 32) | (v58 << 16) | 2;
      __break(1u);
      JUMPOUT(0x8CFD8LL);
    }

    BOOL v41 = 0;
    if (v46 != -4) {
      BOOL v41 = v46 != a2;
    }
    if (v41)
    {
      _dispatch_bug_deprecated( (uint64_t)"Changing target queue hierarchy with a dispatch_sync in flight",  v21,  v22,  v23,  v24,  v25,  v26,  v27);
      _dispatch_event_loop_cancel_waiter(a1, v34, v35, v36, v37, v38, v39, v40);
    }
  }

void _dispatch_event_loop_wait_for_ownership( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v29 = *(void *)(a1 + 48);
  int v25 = 0;
  unint64_t v28 = *(void *)(v29 + 56);
  if ((v28 & 0xFFFFFFFC) != 0 || (v28 & 1) == 0)
  {
    LOBYTE(v23) = 0;
    if ((v28 & 0x2000000000LL) != 0) {
      int v23 = (BYTE4(v28) >> 3) & 1;
    }
    if ((v23 & 1) != 0)
    {
      int v25 = 1;
      if ((v28 & 0xFFFFFFFC) != 0) {
        unsigned int v34 = v28 | 3;
      }
      else {
        unsigned int v34 = 0;
      }
      _dispatch_kq_fill_workloop_sync_event((uint64_t)v35, 7, v29, v28, v34, a6, a7, a8);
    }
  }

  else
  {
    int v25 = 1;
    _dispatch_kq_fill_workloop_event((uint64_t)v35, 0, v29, v28, a5, a6, a7, a8);
  }

  while (1)
  {
    _dispatch_kq_fill_workloop_sync_event((uint64_t)&v35[9 * v25], 8, v29, v28, *(unsigned int *)(a1 + 100), a6, a7, a8);
    int v26 = _dispatch_kq_poll(v29, (uint64_t)v35, v25 + 1, (uint64_t)v35, v25 + 1, 0LL, 0LL, 3u);
    for (int i = 0; i < v26; ++i)
    {
      char v24 = 0;
      if ((v35[9 * i + 3] & 4) != 0) {
        char v24 = 4;
      }
      uint64_t v32 = &v35[9 * i];
      int v31 = v32[4];
      dispatch_kevent_debug( "received error",  (uint64_t)v32,  0,  0,  (uint64_t)"_dispatch_kevent_workloop_drain_error",  0x62Du);
      if ((*((_WORD *)v32 + 5) & 0x4000) == 0) {
        _dispatch_abort(1582LL, 0LL, v9, v10, v11, v12, v13, v14);
      }
      *((_WORD *)v32 + 5) &= ~0x4000u;
      *((_DWORD *)v32 + 7) = v31;
      v32[4] = 0LL;
      if (v31 == 2)
      {
        unint64_t v15 = ((unint64_t)*((unsigned int *)v32 + 6) << 32) | (*((unsigned __int16 *)v32 + 5) << 16) | 2;
        qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: Unexpected error from kevent";
        qword_E4DA8 = v15;
        __break(1u);
        JUMPOUT(0x8D604LL);
      }

      if (v31 != 4)
      {
        if (v31 == 34)
        {
          uint64_t v16 = *((int *)v32 + 3);
          qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: Broken priority";
          qword_E4DA8 = v16;
          __break(1u);
          JUMPOUT(0x8D690LL);
        }

        if (v31 == 105)
        {
          uint64_t v17 = v32[8];
          qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Invalid workloop owner, possible memory corruption";
          qword_E4DA8 = v17;
          __break(1u);
          JUMPOUT(0x8D6D0LL);
        }

LABEL_28:
        qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: Unexpected error from kevent";
        qword_E4DA8 = v31;
        __break(1u);
        JUMPOUT(0x8D710LL);
      }

      if ((v24 & 4) == 0 || (v32[3] & 4) == 0) {
        goto LABEL_28;
      }
    }

    if (!v26) {
      break;
    }
    LOBYTE(v22) = 0;
    if (v26 == 1) {
      int v22 = (v36 >> 2) & 1;
    }
    if ((v22 & 1) == 0) {
      _dispatch_abort(2245LL, v22 & 1, v9, v10, v11, v12, v13, v14);
    }
    dispatch_kevent_debug("restarting", (uint64_t)v35, 0, 0, (uint64_t)"_dispatch_event_loop_wait_for_ownership", 0x8C6u);
    unint64_t v28 = v37;
    int v25 = 0;
  }

  if ((*(_BYTE *)(a1 + 106) & 0x20) != 0)
  {
    _dispatch_event_loop_cancel_waiter(a1, v8, v9, v10, v11, v12, v13, v14);
    *(_BYTE *)(a1 + 106) &= ~0x20u;
  }

  if ((*(_BYTE *)(a1 + 106) & 0x40) != 0)
  {
    uint64_t v33 = *(void *)(a1 + 48);
    uint64_t v20 = (unsigned int *)(v33 + 96);
    unsigned int v21 = *(_DWORD *)(v33 + 96);
    do
    {
      unsigned int v18 = v21;
      do
        unsigned int v19 = __ldaxr(v20);
      while (v19 == v21 && __stlxr(v21 - 1, v20));
      unsigned int v21 = v19;
    }

    while (v19 != v18);
    if (((v19 - 1) & 0x80000000) != 0)
    {
      if ((int)(v19 - 1) <= -2)
      {
        qword_E4D78 = (uint64_t)"API MISUSE: Over-release of an object";
        __break(1u);
        JUMPOUT(0x8D92CLL);
      }

      *(void *)(v33 + 56) = 0xDEAD000000000000LL;
      _dispatch_object_dealloc((void *)v33);
    }
  }

void dispatch_kevent_debug(const char *a1, uint64_t a2, int a3, int a4, uint64_t a5, unsigned int a6)
{
  unint64_t v28 = a1;
  uint64_t v27 = a2;
  int v26 = a3;
  int v25 = a4;
  uint64_t v24 = a5;
  unsigned int v23 = a6;
  if (a4 <= 1) {
    v29[0] = 0;
  }
  else {
    __snprintf_chk(v29, 0x1FuLL, 0, 0x1FuLL, "%d/%d ", v26 + 1, v25);
  }
  if (!v28)
  {
    if ((*(_WORD *)(v27 + 10) & 2) != 0)
    {
      unint64_t v28 = "deleting";
    }

    else if ((*(_WORD *)(v27 + 10) & 1) != 0)
    {
      unint64_t v28 = "adding";
    }

    else
    {
      unint64_t v28 = "updating";
    }
  }

  uint64_t v17 = _dispatch_thread_getspecific(0LL);
  unsigned int v18 = v28;
  uint64_t v19 = v27;
  uint64_t v20 = *(void *)v27;
  unsigned int v21 = _evfiltstr(*(_WORD *)(v27 + 8));
  uint64_t v6 = _evflagstr(*(_WORD *)(v27 + 10), v30, 256LL);
  uint64_t v7 = *(unsigned __int16 *)(v27 + 10);
  uint64_t v8 = *(unsigned int *)(v27 + 24);
  uint64_t v9 = *(void *)(v27 + 32);
  uint64_t v10 = *(void *)(v27 + 16);
  uint64_t v11 = *(unsigned int *)(v27 + 12);
  uint64_t v12 = *(void *)(v27 + 40);
  uint64_t v13 = *(void *)(v27 + 48);
  uint64_t v14 = *(void *)(v27 + 56);
  uint64_t v15 = *(void *)(v27 + 64);
  int v22 = v16;
  v16[1] = v17;
  _OWORD v16[2] = v28;
  v16[3] = v27;
  v16[4] = v29;
  v16[5] = v20;
  v16[6] = v21;
  v16[7] = v6;
  v16[8] = v7;
  v16[9] = v8;
  v16[10] = v9;
  v16[11] = v10;
  v16[12] = v11;
  v16[13] = v12;
  v16[14] = v13;
  v16[15] = v14;
  v16[16] = v15;
  v16[17] = v24;
  v16[18] = v23;
  _dispatch_log( "%u\t%p\t%s kevent[%p] %s= { ident = 0x%llx, filter = %s, flags = %s (0x%x), fflags = 0x%x, uintptr_t data = 0x%llx, uuintptr_t data = 0x %llx, qos = 0x%x, ext[0] = 0x%llx, ext[1] = 0x%llx, ext[2] = 0x%llx, ext[3] = 0x%llx }: %s #%u",  v7,  v7,  (uint64_t)v21,  v20,  (uint64_t)v29,  (uint64_t)v28,  (uint64_t)v17,  203LL);
}

void _dispatch_event_loop_ensure_ownership(uint64_t a1)
{
  uint64_t v16 = a1;
  unsigned int v15 = 3;
  unsigned int v14 = _dispatch_thread_getspecific(3uLL);
  uint64_t v13 = 0LL;
  __int128 v12 = 0u;
  __int128 v11 = 0u;
  memset(v10, 0, sizeof(v10));
  _dispatch_kq_fill_workloop_sync_event((uint64_t)v10, 9, v16, v14, v14, v1, v2, v3);
  if (_dispatch_kq_poll(v16, v10, 1LL, v10, 1LL, 0LL, 0LL, v15))
  {
    uint64_t v24 = v10;
    uint64_t v23 = 0LL;
    unsigned int v22 = v11;
    dispatch_kevent_debug( "received error",  (uint64_t)v10,  0,  0,  (uint64_t)"_dispatch_kevent_workloop_drain_error",  0x62Du);
    uint64_t v27 = *((_WORD *)v24 + 5) & 0x4000;
    uint64_t v26 = 1582LL;
    if (!v27) {
      _dispatch_abort(v26, 0LL, v4, v5, v6, v7, v8, v9);
    }
    *((_WORD *)v24 + 5) &= ~0x4000u;
    *((_DWORD *)v24 + 7) = v22;
    *((void *)v24 + 4) = 0LL;
    switch(v22)
    {
      case 2u:
        if ((v23 & 1) == 0
          || (*((_WORD *)v24 + 5) & 2) == 0
          || (*((_BYTE *)v24 + 24) & 8) == 0
          || (*((_BYTE *)v24 + 24) & 0x20) == 0)
        {
          unint64_t v21 = 0LL;
          unint64_t v21 = (unint64_t)*((unsigned int *)v24 + 6) << 32;
          v21 |= *((unsigned __int16 *)v24 + 5) << 16;
          v21 |= v22;
          unint64_t v20 = v21;
          qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: Unexpected error from kevent";
          qword_E4DA8 = v21;
          __break(1u);
          JUMPOUT(0x8DE88LL);
        }

        int v25 = 2;
        break;
      case 4u:
        if ((v23 & 4) == 0 || (*((_BYTE *)v24 + 24) & 4) == 0) {
          goto LABEL_28;
        }
        int v25 = 4;
        break;
      case 0x22u:
        uint64_t v19 = 0LL;
        uint64_t v19 = *((int *)v24 + 3);
        qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: Broken priority";
        qword_E4DA8 = v19;
        __break(1u);
        JUMPOUT(0x8DF14LL);
      case 0x46u:
        if ((v23 & 2) == 0 || (*((_BYTE *)v24 + 25) & 1) != 0 || !*((void *)v24 + 6) || !*((void *)v24 + 7)) {
          goto LABEL_28;
        }
        int v25 = 70;
        break;
      case 0x69u:
        uint64_t v18 = 0LL;
        uint64_t v18 = *((void *)v24 + 8);
        qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Invalid workloop owner, possible memory corruption";
        qword_E4DA8 = v18;
        __break(1u);
        JUMPOUT(0x8DF54LL);
      default:
LABEL_28:
        uint64_t v17 = (int)v22;
        qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: Unexpected error from kevent";
        qword_E4DA8 = (int)v22;
        __break(1u);
        JUMPOUT(0x8DF94LL);
    }

    __break(1u);
  }

void _dispatch_event_loop_end_ownership( unsigned int *a1, char a2, unint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  char v27 = a4;
  unsigned int v26 = 0;
  if (((a3 >> 37) & 1) == 0) {
    _dispatch_abort(2289LL, 0LL, a3, a4, a5, a6, a7, a8);
  }
  if ((a3 & 1) != 0)
  {
    unsigned int v26 = 1;
    _dispatch_kq_fill_workloop_event((uint64_t)v32, 1, (uint64_t)a1, a3, a5, a6, a7, a8);
  }

  else if ((a2 & 1) != 0)
  {
    if ((a3 & 0xFF80000000000000LL) == 0) {
      _dispatch_abort(2294LL, (a3 & 0xFF80000000000000LL) != 0, a3, a4, a5, a6, a7, a8);
    }
    unsigned int v26 = 1;
    _dispatch_kq_fill_workloop_event((uint64_t)v32, 4, (uint64_t)a1, a3, a5, a6, a7, a8);
  }

  if ((a2 & 2) == 0)
  {
    unsigned int v25 = _dispatch_thread_getspecific(3uLL);
    unsigned int v8 = v26++;
    _dispatch_kq_fill_workloop_sync_event((uint64_t)&v32[72 * v8], 11, (uint64_t)a1, a3, v25, v9, v10, v11);
  }

  if (_dispatch_kq_poll(a1, v32, v26, v32, v26, 0LL, 0LL, 3LL))
  {
    int v31 = v37;
    dispatch_kevent_debug( "received error",  (uint64_t)v32,  0,  0,  (uint64_t)"_dispatch_kevent_workloop_drain_error",  0x62Du);
    if ((v33 & 0x4000) == 0) {
      _dispatch_abort(1582LL, 0LL, v12, v13, v14, v15, v16, v17);
    }
    v33 &= ~0x4000u;
    int v36 = v31;
    uint64_t v37 = 0LL;
    if (v31 != 2)
    {
      if (v31 != 4)
      {
        if (v31 == 34)
        {
          qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: Broken priority";
          qword_E4DA8 = v34;
          __break(1u);
          JUMPOUT(0x8E400LL);
        }

        if (v31 == 105)
        {
          qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Invalid workloop owner, possible memory corruption";
          qword_E4DA8 = v38;
          __break(1u);
          JUMPOUT(0x8E440LL);
        }
      }

      qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: Unexpected error from kevent";
      qword_E4DA8 = v31;
      __break(1u);
      JUMPOUT(0x8E480LL);
    }

    qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: Unexpected error from kevent";
    qword_E4DA8 = ((unint64_t)v35 << 32) | (v33 << 16) | 2;
    __break(1u);
    JUMPOUT(0x8E374LL);
  }

  _dispatch_event_loop_assert_not_owned((uint64_t)a1);
  int v24 = 2 * (v27 & 1);
  if ((a2 & 1) != 0) {
    ++v24;
  }
  if ((a3 & 1) != 0) {
    --v24;
  }
  if (v24 < 0) {
    _dispatch_abort(2315LL, v24 >= 0, v18, v19, v20, v21, v22, v23);
  }
  if (v24 >= 1) {
    _dispatch_release_n(a1, v24);
  }
}

uint64_t _dispatch_event_loop_assert_not_owned(uint64_t result)
{
  uint64_t v8 = result;
  if (result != -4)
  {
    memset(__b, 0, sizeof(__b));
    uint64_t result = _dispatch_kevent_workloop_get_info(v8, __b);
    if ((result & 1) != 0)
    {
      unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
      BOOL v10 = __b[5] != *(void *)(StatusReg - 8);
      uint64_t v9 = 2330LL;
      if (!v10) {
        _dispatch_abort(v9, 0LL, v1, v2, v3, v4, v5, v6);
      }
    }
  }

  return result;
}

BOOL _dispatch_kevent_workloop_get_info(uint64_t a1, _WORD *a2)
{
  uint64_t v14 = a1;
  uint64_t v13 = a2;
  unsigned int v12 = 131075;
  memset(__b, 0, sizeof(__b));
  __b[4] = -17;
  void __b[5] = 5;
  memcpy(a2, __b, 0x48uLL);
  if (_dispatch_kq_poll(v14, v13, 1LL, v13, 1LL, 0LL, 0LL, v12))
  {
    uint64_t v17 = v13[5] & 0x4000;
    uint64_t v16 = 1375LL;
    if (!v17) {
      _dispatch_abort(v16, 0LL, v2, v3, v4, v5, v6, v7);
    }
    return *((void *)v13 + 4) == 16LL;
  }

  else
  {
    memset(v10, 0, sizeof(v10));
    WORD1(v10[1]) = 0x4000;
    v10[4] = 2LL;
    memcpy(v13, v10, 0x48uLL);
    return 1;
  }

void _dispatch_event_loop_timer_arm(uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  unsigned int v7 = a2 / 3;
  unsigned int v14 = a2 / 3;
  uint64_t v13 = a5;
  if (!*(void *)(a5 + 8LL * (a2 / 3)))
  {
    uint64_t v11 = 0LL;
    uint64_t v12 = 0LL;
    mach_get_times(v13, v13 + 8, &v11);
    *(void *)(v13 + 16) = 1000000000 * v11 + v12;
  }

  uint64_t v15 = *(void *)(v13 + 8LL * v14);
  uint64_t v6 = a3 + v15;
  if ((_dispatch_timers_force_max_leeway & 1) != 0)
  {
    v6 += a4;
    a4 = 0LL;
  }

  _dispatch_event_loop_timer_program(a1, a2, v6, a4, 5);
  if (v7 == 2)
  {
    uint64_t v18 = &_dispatch_mach_calendar_pred;
    uint64_t v17 = 0LL;
    uint64_t v16 = _dispatch_mach_host_notify_update;
    if (_dispatch_mach_calendar_pred != -1LL) {
      dispatch_once_f(v18, v17, (dispatch_function_t)v16);
    }
  }

void _dispatch_event_loop_timer_program(uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4, __int16 a5)
{
  uint64_t v12 = a1;
  unsigned int v11 = a2;
  uint64_t v10 = a3;
  uint64_t v9 = a4;
  __int16 v8 = a5;
  unsigned int v7 = _dispatch_thread_getspecific(0x1BuLL);
  uint64_t v6 = 0x2000000LL;
  if (v7 != (void *)-4LL)
  {
    int v14 = *(unsigned __int8 *)(v12 + 32LL * v11 + 5);
    uint64_t v13 = 0LL;
    if (v14) {
      uint64_t v13 = 1LL << (v14 + 7);
    }
    uint64_t v6 = v13 | 0xFF;
  }

  memset(__b, 0, sizeof(__b));
  __b[0] = v11 | 0xFFFFFFFFFFFFFF00LL;
  LOWORD(__b[1]) = -7;
  WORD1(__b[1]) = v8 | 0x10;
  HIDWORD(__b[1]) = v6;
  __b[2] = v12;
  __b[3] = _dispatch_timer_index_to_fflags[v11];
  __b[4] = v10;
  void __b[5] = 0LL;
  *(_OWORD *)&__b[7] = 0u;
  void __b[6] = v9;
  _dispatch_kq_deferred_update((uint64_t)v7, (__int16 *)__b);
}

void _dispatch_event_loop_timer_delete(uint64_t a1, unsigned int a2)
{
}

uint64_t _dispatch_source_proc_create(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v4 = a3;
  uint64_t v5 = _dispatch_unote_create_with_handle(a1, a2, a3);
  if (v5 && (v4 & 0x4000000) != 0) {
    *(_BYTE *)(v5 + 29) = *(_BYTE *)(v5 + 29) & 0xFB | 4;
  }
  return v5;
}

uint64_t _dispatch_source_vm_create(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = _dispatch_unote_create_without_handle((uint64_t)&_dispatch_source_type_memorystatus, a2, 2LL);
  if (v3) {
    *(_BYTE *)(v3 + 29) = *(_BYTE *)(v3 + 29) & 0xEF | 0x10;
  }
  return v3;
}

BOOL _dispatch_mach_msg_sender_is_kernel(uint64_t a1)
{
  uint64_t audit_trailer = _dispatch_mach_msg_get_audit_trailer(a1);
  if (!audit_trailer)
  {
    qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: message received without expected trailer";
    __break(1u);
    JUMPOUT(0x8EC0CLL);
  }

  return *(_DWORD *)(audit_trailer + 40) == 0;
}

uint64_t _dispatch_mach_msg_get_audit_trailer(uint64_t a1)
{
  uint64_t v2 = 0LL;
  uint64_t v3 = (_DWORD *)(a1 + ((*(unsigned int *)(a1 + 4) + 3LL) & 0xFFFFFFFFFFFFFFFCLL));
  return v2;
}

uint64_t _dispatch_get_mach_host_port()
{
  if (_dispatch_mach_host_port_pred != -1) {
    dispatch_once_f(&_dispatch_mach_host_port_pred, 0LL, (dispatch_function_t)_dispatch_mach_host_port_init);
  }
  return _dispatch_mach_host_port;
}

void _dispatch_mach_host_port_init(uint64_t a1)
{
  kern_return_t special_port;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v10 = a1;
  special_mach_port_t port = 0;
  mach_port_t port = 0;
  mach_port_t v7 = mach_host_self();
  special_mach_port_t port = host_get_special_port(v7, -1, 1, &port);
  if (special_port == -301)
  {
    qword_E4D78 = (uint64_t)"MIG_REPLY_MISMATCH";
    qword_E4DA8 = -301LL;
    __break(1u);
    JUMPOUT(0x8EDACLL);
  }

  if (special_port)
  {
    if (special_port != 4)
    {
      uint64_t v12 = special_port;
      unsigned int v11 = 2859LL;
      _dispatch_bug(2859LL, special_port, v1, v2, v3, v4, v5, v6);
    }
  }

  else
  {
    special_mach_port_t port = mach_port_deallocate(mach_task_self_, v7);
    if (special_port == -301)
    {
      qword_E4D78 = (uint64_t)"MIG_REPLY_MISMATCH";
      qword_E4DA8 = -301LL;
      __break(1u);
      JUMPOUT(0x8EE24LL);
    }

    mach_port_t v7 = port;
  }

  if (!v7)
  {
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Could not get unprivileged host port";
    qword_E4DA8 = special_port;
    __break(1u);
    JUMPOUT(0x8EEDCLL);
  }

  _dispatch_mach_host_mach_port_t port = v7;
}

uint64_t _dispatch_mach_notify_port_deleted( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v14 = a2;
  _dispatch_log( "Corruption: Mach send/send-once/dead-name right 0x%x deleted prematurely",  a2,  a3,  a4,  a5,  a6,  a7,  a8,  a2);
  _dispatch_mach_notify_merge(v14, 4, 1LL, v8, v9, v10, v11, v12);
  return 0LL;
}

uint64_t _dispatch_mach_notify_merge( uint64_t result, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned __int8 v25 = a3 & 1;
  uint64_t v23 = 0LL;
  unsigned int v22 = 4;
  for (uint64_t i = _dispatch_sources[((unint64_t)result >> 8) & 0x3F];
        i && (*(void *)(i + 24) != result || *(__int16 *)(i + 32) != -24);
    ;
  }

  if (i)
  {
    *(void *)(i + 56) &= 0xFFFFFFFFFFFFFFF2LL;
    if ((a3 & 1) != 0
      || (uint64_t result = _dispatch_kevent_mach_notify_resume(i, a2, 0LL, a4, a5, a6, a7, a8), (result & 1) == 0))
    {
      unsigned int v22 = 16;
      *(_WORD *)(i + 34) |= 2u;
    }

    *(void *)(i + 64) = 0LL;
    for (int j = *(uint64_t **)(i + 16); ; int j = v23)
    {
      char v19 = 0;
      if (j)
      {
        uint64_t v23 = (uint64_t *)*j;
        char v19 = 1;
      }

      if ((v19 & 1) == 0) {
        break;
      }
      if (*(void *)(i + 64))
      {
        if (((v25 ^ 1) & 1) == 0) {
          _dispatch_abort(3026LL, (v25 ^ 1) & 1, a3, a4, a5, a6, a7, a8);
        }
        return result;
      }

      uint64_t v21 = (uint64_t)(j + 3);
      unsigned int v20 = a2 & j[7];
      *((_BYTE *)j + 54) = 0;
      if ((v25 & 1) != 0 || v20)
      {
        _dispatch_retain_2(~j[4]);
        if ((v25 & 1) != 0) {
          _dispatch_unote_unregister_muxed(v21, v8, v9, v10, v11, v12, v13, v14);
        }
        if (v20 && *(_BYTE *)(*(void *)v21 + 9LL) == 2)
        {
          uint64_t v17 = (unint64_t *)(j + 12);
          unint64_t v18 = j[12];
          do
          {
            unint64_t v15 = v18;
            do
              unint64_t v16 = __ldaxr(v17);
            while (v16 == v18 && __stlxr(v18 | v20, v17));
            unint64_t v18 = v16;
          }

          while (v16 != v15);
        }

        uint64_t result = (*(uint64_t (**)(uint64_t, void, void, void))(*(void *)v21 + 48LL))( v21,  v22,  v20,  0LL);
      }
    }
  }

  return result;
}

uint64_t _dispatch_mach_notify_dead_name(uint64_t a1, mach_port_name_t a2)
{
  uint64_t v15 = a2;
  _dispatch_thread_getspecific(0LL);
  _dispatch_log("%u\t%p\tmachport[0x%08x]: dead-name notification", v2, v3, v4, v5, v6, v7, v8, 3064LL);
  _dispatch_mach_notify_merge(v15, 1, 1LL, v9, v10, v11, v12, v13);
  if (mach_port_deallocate(mach_task_self_, a2) == -301)
  {
    qword_E4D78 = (uint64_t)"MIG_REPLY_MISMATCH";
    qword_E4DA8 = -301LL;
    __break(1u);
    JUMPOUT(0x8F4F0LL);
  }

  return 0LL;
}

uint64_t _dispatch_mach_notify_send_possible(uint64_t a1, unsigned int a2)
{
  return 0LL;
}

void _dispatch_mach_notification_set_armed( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if ((*(_BYTE *)(a1 + 29) & 1) != 0) {
    _dispatch_abort(588LL, (*(_BYTE *)(a1 + 29) & 1) == 0, a3, a4, a5, a6, a7, a8);
  }
  uint64_t v16 = *(void *)(a1 - 8);
  if (v16)
  {
    *(void *)(v16 + 64) = 1LL;
    _dispatch_thread_getspecific(0LL);
    _dispatch_log("%u\t%p\tmachport[0x%08x]: send-possible notification armed", v8, v9, v10, v11, v12, v13, v14, 3099LL);
  }

uint64_t _dispatch_source_mach_send_create(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = a2;
  uint64_t v4 = a3;
  if (!a3) {
    uint64_t v4 = 1LL;
  }
  if (!a2) {
    uint64_t v5 = 0xFFFFFFFFLL;
  }
  return _dispatch_unote_create_with_handle(a1, v5, v4);
}

BOOL _dispatch_mach_send_update( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if ((*(_WORD *)(a1 + 34) & 2) != 0) {
    return _dispatch_kevent_mach_notify_resume(a1, 0, *(unsigned int *)(a1 + 48), a4, a5, a6, a7, a8);
  }
  else {
    return _dispatch_kevent_mach_notify_resume(a1, *(_DWORD *)(a1 + 48), 0LL, a4, a5, a6, a7, a8);
  }
}

uint64_t _dispatch_mach_send_create(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = _dispatch_unote_create_without_handle(a1, a2, a3);
  if (v4)
  {
    *(_DWORD *)(v4 + 88) = 0x80000000;
    *(void *)(v4 + 56) = 0LL;
  }

  return v4;
}

void _dispatch_mach_notification_event(uint64_t a1)
{
  uint64_t v1 = *(unsigned int *)(a1 + 24);
  qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Unexpected non message event";
  qword_E4DA8 = v1;
  __break(1u);
}

  ;
}

void _dispatch_mach_notification_merge_msg( uint64_t a1, int a2, mach_msg_header_t *a3, int a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v36 = a1;
  int v35 = a2;
  int v34 = a3;
  int v33 = a4;
  uint64_t v32 = a5;
  uint64_t v31 = a6;
  uint64_t v30 = a7;
  memset(__b, 0, sizeof(__b));
  uint64_t v44 = 1LL;
  uint64_t v43 = 2786LL;
  uint64_t v42 = 1LL;
  uint64_t v41 = 2788LL;
  if (v34->msgh_id <= 77)
  {
    BOOL is_kernel = _dispatch_mach_msg_sender_is_kernel((uint64_t)v34);
    BOOL v40 = is_kernel;
    uint64_t v39 = 2790LL;
    if (!is_kernel) {
      _dispatch_bug(v39, 0LL, v7, v8, v9, v10, v11, v12);
    }
    if (!is_kernel) {
      goto LABEL_18;
    }
  }

  int v27 = libdispatch_internal_protocol_server(v34, (uint64_t)__b);
  if (!v27 && __b[8] == -303 && (v34->msgh_id == 951 || v34->msgh_id == 950))
  {
    _dispatch_thread_getspecific(0LL);
    _dispatch_log("%u\t%p\tcalendar-change notification", v20, v21, v22, v23, v24, v25, v26, 2799LL);
    _dispatch_timers_calendar_change();
    _dispatch_mach_host_notify_update();
    int v27 = 1;
    __b[8] = 0;
  }

  uint64_t v38 = v27;
  uint64_t v37 = 2805LL;
  if (v27)
  {
    if (__b[8] != -305)
    {
      uint64_t v46 = __b[8];
      uint64_t v45 = 2806LL;
      if (__b[8]) {
        _dispatch_bug(v45, v46, v14, v15, v16, v17, v18, v19);
      }
    }
  }

  else
  {
    _dispatch_bug(v37, v38, v14, v15, v16, v17, v18, v19);
  }

  if (!v27 || __b[8] && __b[8] != -305) {
LABEL_18:
  }
    mach_msg_destroy(v34);
  if ((v35 & 0x10000) != 0) {
    free(v34);
  }
  _dispatch_unote_resume(v36, v13, v14, v15, v16, v17, v18, v19);
}

uint64_t _dispatch_mach_recv_direct_merge_evt( uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if ((a2 & 0x200) != 0)
  {
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Unexpected EV_VANISHED (do not destroy random mach ports)";
    __break(1u);
    JUMPOUT(0x8FC70LL);
  }

  return _dispatch_source_merge_evt(a1, a2, a3, a4, a5, a6, a7, a8);
}

void _dispatch_mach_reply_merge_evt(uint64_t a1, unsigned int a2, int a3)
{
  if ((a2 & 0x200) != 0)
  {
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Unexpected EV_VANISHED (do not destroy random mach ports)";
  }

  else
  {
    qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: Unexpected event";
    qword_E4DA8 = a3 | ((unint64_t)a2 << 32);
  }

  __break(1u);
  JUMPOUT(0x8FCDCLL);
}

void sub_8FD3C()
{
}

void _dispatch_kevent_workloop_override_self( uint64_t a1, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v22 = a1;
  unint64_t v21 = a2;
  int v20 = a3;
  uint64_t v19 = 0LL;
  uint64_t v19 = *(void *)(a1 + 24);
  unsigned int v18 = 3;
  uint64_t v17 = 0LL;
  __int128 v16 = 0u;
  __int128 v15 = 0u;
  memset(v14, 0, sizeof(v14));
  uint64_t v24 = *(_BYTE *)(a1 + 45) & 1;
  uint64_t v23 = 1769LL;
  if (!v24) {
    _dispatch_abort(v23, 0LL, a3, a4, a5, a6, a7, a8);
  }
  *(_BYTE *)(v22 + 45) &= ~2u;
  _dispatch_kq_fill_workloop_event((uint64_t)v14, 0, v19, v21, a5, a6, a7, a8);
  if (_dispatch_kq_poll(v19, v14, 1LL, v14, 1LL, 0LL, 0LL, v18))
  {
    uint64_t v32 = v14;
    uint64_t v31 = 0LL;
    unsigned int v30 = v15;
    dispatch_kevent_debug( "received error",  (uint64_t)v14,  0,  0,  (uint64_t)"_dispatch_kevent_workloop_drain_error",  0x62Du);
    uint64_t v35 = *((_WORD *)v32 + 5) & 0x4000;
    uint64_t v34 = 1582LL;
    if (!v35) {
      _dispatch_abort(v34, 0LL, v8, v9, v10, v11, v12, v13);
    }
    *((_WORD *)v32 + 5) &= ~0x4000u;
    *((_DWORD *)v32 + 7) = v30;
    *((void *)v32 + 4) = 0LL;
    switch(v30)
    {
      case 2u:
        if ((v31 & 1) == 0
          || (*((_WORD *)v32 + 5) & 2) == 0
          || (*((_BYTE *)v32 + 24) & 8) == 0
          || (*((_BYTE *)v32 + 24) & 0x20) == 0)
        {
          unint64_t v29 = 0LL;
          unint64_t v29 = (unint64_t)*((unsigned int *)v32 + 6) << 32;
          v29 |= *((unsigned __int16 *)v32 + 5) << 16;
          v29 |= v30;
          unint64_t v28 = v29;
          qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: Unexpected error from kevent";
          qword_E4DA8 = v29;
          __break(1u);
          JUMPOUT(0x9000CLL);
        }

        int v33 = 2;
        break;
      case 4u:
        if ((v31 & 4) == 0 || (*((_BYTE *)v32 + 24) & 4) == 0) {
          goto LABEL_30;
        }
        int v33 = 4;
        break;
      case 0x22u:
        uint64_t v27 = 0LL;
        uint64_t v27 = *((int *)v32 + 3);
        qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: Broken priority";
        qword_E4DA8 = v27;
        __break(1u);
        JUMPOUT(0x90098LL);
      case 0x46u:
        if ((v31 & 2) == 0 || (*((_BYTE *)v32 + 25) & 1) != 0 || !*((void *)v32 + 6) || !*((void *)v32 + 7)) {
          goto LABEL_30;
        }
        int v33 = 70;
        break;
      case 0x69u:
        uint64_t v26 = 0LL;
        uint64_t v26 = *((void *)v32 + 8);
        qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Invalid workloop owner, possible memory corruption";
        qword_E4DA8 = v26;
        __break(1u);
        JUMPOUT(0x900D8LL);
      default:
LABEL_30:
        uint64_t v25 = (int)v30;
        qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: Unexpected error from kevent";
        qword_E4DA8 = (int)v30;
        __break(1u);
        JUMPOUT(0x90118LL);
    }

    __break(1u);
  }

  if ((v20 & 1) != 0) {
    _dispatch_release_2_no_dispose(v19);
  }
}

void _dispatch_kevent_workloop_poke_drain(uint64_t a1)
{
  uint64_t v35 = _dispatch_thread_getspecific(0x1DuLL);
  uint64_t v34 = *(void *)(a1 + 16);
  if ((*(_BYTE *)(a1 + 27) & 0x80) != 0)
  {
    BOOL v32 = 0;
    if ((*(_WORD *)(a1 + 10) & 0x4000) != 0) {
      BOOL v32 = *(void *)(a1 + 32) == 2LL;
    }
    if (!v32) {
      _dispatch_abort(1679LL, v32, v1, v2, v3, v4, v5, v6);
    }
    dispatch_kevent_debug("ignoring", a1, 0, 0, (uint64_t)"_dispatch_kevent_workloop_poke_drain", 0x690u);
    return;
  }

  if ((*(_DWORD *)(a1 + 24) & 1) == 0) {
    _dispatch_abort(1684LL, 0LL, v1, v2, v3, v4, v5, v6);
  }
  if ((*(_WORD *)(a1 + 10) & 0x4000) != 0)
  {
    unint64_t v33 = *(void *)(a1 + 64);
    int v37 = *(void *)(a1 + 32);
    dispatch_kevent_debug("received error", a1, 0, 0, (uint64_t)"_dispatch_kevent_workloop_drain_error", 0x62Du);
    if ((*(_WORD *)(a1 + 10) & 0x4000) == 0) {
      _dispatch_abort(1582LL, 0LL, v7, v8, v9, v10, v11, v12);
    }
    *(_WORD *)(a1 + 10) &= ~0x4000u;
    *(_DWORD *)(a1 + 28) = v37;
    *(void *)(a1 + 32) = 0LL;
    switch(v37)
    {
      case 2:
        unint64_t v13 = ((unint64_t)*(unsigned int *)(a1 + 24) << 32) | (*(unsigned __int16 *)(a1 + 10) << 16) | 2;
        qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: Unexpected error from kevent";
        qword_E4DA8 = v13;
        __break(1u);
        JUMPOUT(0x90498LL);
      case 4:
LABEL_26:
        qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: Unexpected error from kevent";
        qword_E4DA8 = v37;
        __break(1u);
        JUMPOUT(0x905B8LL);
      case 34:
        uint64_t v14 = *(int *)(a1 + 12);
        qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: Broken priority";
        qword_E4DA8 = v14;
        __break(1u);
        JUMPOUT(0x90534LL);
    }

    if (v37 != 70)
    {
      if (v37 == 105)
      {
        uint64_t v15 = *(void *)(a1 + 64);
        qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Invalid workloop owner, possible memory corruption";
        qword_E4DA8 = v15;
        __break(1u);
        JUMPOUT(0x90578LL);
      }

      goto LABEL_26;
    }

    if ((*(_BYTE *)(a1 + 25) & 1) != 0 || !*(void *)(a1 + 48) || !*(void *)(a1 + 56)) {
      goto LABEL_26;
    }
    if ((v33 & 0x2000000000LL) != 0)
    {
      if (((v33 >> 37) & 1) == 0) {
        _dispatch_abort(1659LL, 0LL, v7, v8, v9, v10, v11, v12);
      }
      if ((v33 & 1) != 0)
      {
        if ((v33 & 0xFFFFFFFC) != 0) {
          int v38 = 2;
        }
        else {
          int v38 = 0;
        }
      }

      else
      {
        int v38 = 3;
      }

      if (v38)
      {
        _dispatch_kq_fill_workloop_event(a1, v38, v34, v33, v9, v10, v11, v12);
        _dispatch_kq_deferred_update(v34, a1);
      }

      else
      {
        dispatch_kevent_debug("retry drain", a1, 0, 0, (uint64_t)"_dispatch_kevent_workloop_poke_drain", 0x6ABu);
        if (v35[1]) {
          _dispatch_abort(1647LL, 0LL, v16, v17, v18, v19, v20, v21);
        }
        *((_BYTE *)v35 + 45) |= 1u;
        _dispatch_retain(v34);
        *uint64_t v35 = *(void *)(v34 + 24);
        v35[1] = v34;
        unint64_t v39 = (unint64_t)(*(_DWORD *)(a1 + 12) & 0x3FFF00) >> 8;
        unsigned int v22 = __clz(__rbit32(v39));
        if ((_DWORD)v39) {
          unsigned int v23 = v22 + 1;
        }
        else {
          unsigned int v23 = 0;
        }
        *((_DWORD *)v35 + 4) = v23;
      }
    }

    else
    {
      if ((*(_WORD *)(a1 + 10) & 2) != 0) {
        _dispatch_abort(1692LL, (*(_WORD *)(a1 + 10) & 2) == 0, v7, v8, v9, v10, v11, v12);
      }
      dispatch_kevent_debug("ignoring", a1, 0, 0, (uint64_t)"_dispatch_kevent_workloop_poke_drain", 0x6A2u);
    }
  }

  else if ((*((_BYTE *)v35 + 45) & 1) != 0)
  {
    dispatch_kevent_debug("ignoring", a1, 0, 0, (uint64_t)"_dispatch_kevent_workloop_poke_drain", 0x6B7u);
  }

  else
  {
    dispatch_kevent_debug("got drain", a1, 0, 0, (uint64_t)"_dispatch_kevent_workloop_poke_drain", 0x6BCu);
    if (v35[1]) {
      _dispatch_abort(1647LL, 0LL, v24, v25, v26, v27, v28, v29);
    }
    *((_BYTE *)v35 + 45) |= 1u;
    _dispatch_retain(v34);
    *uint64_t v35 = *(void *)(v34 + 24);
    v35[1] = v34;
    unint64_t v40 = (unint64_t)(*(_DWORD *)(a1 + 12) & 0x3FFF00) >> 8;
    unsigned int v30 = __clz(__rbit32(v40));
    if ((_DWORD)v40) {
      unsigned int v31 = v30 + 1;
    }
    else {
      unsigned int v31 = 0;
    }
    *((_DWORD *)v35 + 4) = v31;
  }

void _dispatch_kevent_print_error(uint64_t a1)
{
  uint64_t v13 = 0LL;
  _dispatch_thread_getspecific(0LL);
  _dispatch_log("%u\t%p\tkevent[0x%llx]: handling error", v1, v2, v3, v4, v5, v6, v7, 390LL);
  if ((*(_WORD *)(a1 + 10) & 2) != 0)
  {
    if ((*(_WORD *)(a1 + 10) & 0x100) != 0 && *(void *)(a1 + 32) == 36LL) {
      return;
    }
  }

  else if ((*(_BYTE *)(a1 + 16) & 1) != 0)
  {
    *(_WORD *)(a1 + 10) |= *(_WORD *)((*(void *)(a1 + 16) & 0xFFFFFFFFFFFFFFFELL) + 34);
  }

  else if (*(void *)(a1 + 16))
  {
    uint64_t v13 = *(void *)(a1 + 16);
    if (!*(void *)(v13 + 16)) {
      *(_WORD *)(a1 + 10) |= 1u;
    }
  }

  if (*(void *)(a1 + 32))
  {
    if (*(void *)(a1 + 32) == 34LL)
    {
      uint64_t v8 = *(int *)(a1 + 12);
      qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: Invalid kevent priority";
      qword_E4DA8 = v8;
      __break(1u);
      JUMPOUT(0x90BA4LL);
    }

    uint64_t v9 = _evfiltstr(*(_WORD *)(a1 + 8));
    uint64_t v12 = (uint64_t)v9;
    if (*(void *)(a1 + 16))
    {
      if ((*(_WORD *)(a1 + 10) & 2) != 0)
      {
        _dispatch_bug_kevent_client( (uint64_t)"kevent",  (uint64_t)v9,  (uint64_t)"delete",  *(unsigned int *)(a1 + 32),  *(void *)a1,  *(void *)(a1 + 16),  v13,  v10);
      }

      else if ((*(_WORD *)(a1 + 10) & 1) != 0)
      {
        _dispatch_bug_kevent_client( (uint64_t)"kevent",  (uint64_t)v9,  (uint64_t)"add",  *(unsigned int *)(a1 + 32),  *(void *)a1,  *(void *)(a1 + 16),  v13,  v10);
      }

      else
      {
        if ((*(_WORD *)(a1 + 10) & 4) != 0) {
          uint64_t v11 = "enable";
        }
        else {
          uint64_t v11 = "monitor";
        }
        _dispatch_bug_kevent_client( (uint64_t)"kevent",  v12,  (uint64_t)v11,  *(unsigned int *)(a1 + 32),  *(void *)a1,  *(void *)(a1 + 16),  v13,  v10);
      }
    }

    else
    {
      _dispatch_bug_kevent_client( (uint64_t)"kevent",  (uint64_t)v9,  0LL,  *(unsigned int *)(a1 + 32),  *(void *)a1,  *(void *)(a1 + 16),  v13,  v10);
    }
  }

uint64_t _dispatch_kevent_mach_msg_size(uint64_t a1)
{
  return *(void *)(a1 + 48);
}

BOOL _dispatch_kevent_has_machmsg_rcv_error(uint64_t a1)
{
  int v3 = *(_DWORD *)(a1 + 24);
  BOOL v2 = 0;
  if ((v3 & 0xFC000000) == 0x10000000) {
    return ((v3 >> 14) & 0xFFF) == 1;
  }
  return v2;
}

void _dispatch_kevent_mach_msg_drain(uint64_t a1)
{
  uint64_t v69 = a1;
  uint64_t v42 = 0LL;
  unsigned int v68 = (unsigned int *)_dispatch_kevent_mach_msg_buf(a1);
  int v41 = 0;
  unsigned int v67 = _dispatch_kevent_mach_msg_size(v69);
  *(_DWORD *)&v66[8] = 0;
  *(void *)__int128 v66 = _dispatch_kevent_mach_msg_aux_size(v69);
  uint64_t v65 = *(unsigned int *)&v66[4];
  uint64_t v76 = v69;
  uint64_t v80 = v69;
  BOOL v9 = (*(void *)(v69 + 16) & 1LL) == 0;
  BOOL v79 = (*(void *)(v69 + 16) & 1LL) == 0;
  uint64_t v78 = 380LL;
  if (!v9) {
    _dispatch_abort(v78, v79, v3, v4, v5, v6, v7, v8);
  }
  uint64_t v77 = *(void *)(v76 + 16);
  uint64_t v65 = v77;
  uint64_t v64 = 0LL;
  uint64_t v64 = *(unsigned int *)(v69 + 60);
  uint64_t v63 = 0LL;
  uint64_t v63 = *(int *)(v69 + 12);
  unsigned int v62 = 0;
  unsigned int v62 = *(unsigned __int16 *)(v69 + 10);
  mach_error_t v61 = 0;
  mach_error_t v61 = *(_DWORD *)(v69 + 24);
  if (v61 == 268451844)
  {
    if (!v67)
    {
      uint64_t v60 = v61;
      uint64_t v29 = v1;
      uint64_t v30 = v2;
      qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: EVFILT_MACHPORT with no message size";
      qword_E4DA8 = v61;
      __break(1u);
      JUMPOUT(0x90E98LL);
    }

    if (!*(void *)(v69 + 32))
    {
      uint64_t v29 = v1;
      uint64_t v30 = v2;
      qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: MACH_RCV_LARGE_IDENTITY with no identity";
      __break(1u);
      JUMPOUT(0x91020LL);
    }

    if (_dispatch_kevent_mach_msg_size(v69) >= 0xFFFFFFBC)
    {
      uint64_t v57 = _dispatch_kevent_mach_msg_size(v69);
      uint64_t v29 = v1;
      uint64_t v30 = v2;
      qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: EVFILT_MACHPORT with overlarge message";
      qword_E4DA8 = v57;
      __break(1u);
      JUMPOUT(0x91080LL);
    }

    int v56 = 0;
    if ((*(_BYTE *)(v65 + 33) & 2) != 0) {
      v56 |= 0x200u;
    }
    int v37 = 0;
    signed int v55 = v56 & 0xF8FFF6F1 | 0x700090A;
    v67 += 68;
    unsigned int v68 = (unsigned int *)malloc_type_malloc(v67, 3883670545LL);
    *(_DWORD *)__int128 v66 = 40;
    uint64_t v36 = v28;
    bzero(v28, 0x28uLL);
    *(void *)&v66[4] = v36;
    int v38 = v81;
    __int128 v53 = (unint64_t)v68;
    LODWORD(v54) = v37;
    unint64_t v39 = (unsigned int *)&v54 + 1;
    int v52 = v68;
    uint64_t v73 = v68;
    uint64_t v72 = 3256LL;
    if (!v68) {
      _dispatch_bug(v72, 0LL, v10, v11, v12, v13, v14, v15);
    }
    v51[1] = v52;
    if (v52) {
      unsigned int v35 = v67;
    }
    else {
      unsigned int v35 = 0;
    }
    uint64_t v16 = v38;
    *unint64_t v39 = v35;
    __int128 v17 = v53;
    _OWORD v16[2] = v54;
    *(_OWORD *)uint64_t v16 = v17;
    unint64_t v33 = &v82;
    __int128 v50 = *(unint64_t *)&v66[4];
    LODWORD(v51[0]) = 0;
    uint64_t v34 = (_DWORD *)v51 + 1;
    uint64_t v49 = *(void *)&v66[4];
    uint64_t v71 = *(void *)&v66[4];
    uint64_t v70 = 3262LL;
    if (!*(void *)&v66[4]) {
      _dispatch_bug(v70, 0LL, v10, v11, v12, v13, v14, v15);
    }
    uint64_t v48 = v49;
    if (v49) {
      int v32 = *(_DWORD *)v66;
    }
    else {
      int v32 = 0;
    }
    uint64_t v18 = v33;
    *uint64_t v34 = v32;
    __int128 v19 = v50;
    v18[2] = v51[0];
    *(_OWORD *)uint64_t v18 = v19;
    uint64_t v47 = 0LL;
    uint64_t v46 = 0LL;
    uint64_t v45 = 0LL;
    unsigned int v20 = *(_DWORD *)(v69 + 32);
    uint64_t v44 = 0LL;
    __int128 v43 = 0u;
    mach_error_t v61 = mach_msg2(v81, v55 | 0x100000000LL, (unsigned int *)&v43, 0, 2u, v20, 0LL, 0);
    if (!v61)
    {
      v62 |= 0x10000u;
      if (!**(_DWORD **)&v66[4]) {
        *(void *)&v66[4] = 0LL;
      }
      _dispatch_kevent_mach_msg_recv(v65, v62, v68, *(uint64_t *)&v66[4], v64, v63);
      return;
    }

    if (v61 == 268451844)
    {
      uint64_t v31 = v68[5];
      _dispatch_kevent_mach_msg_size(v69);
      _dispatch_log( "BUG in libdispatch client: _dispatch_kevent_mach_msg_drain: dropped message too large to fit in memory: id = 0x%x, size = %u",  v21,  v22,  v23,  v24,  v25,  v26,  v27,  v31);
      mach_error_t v61 = 0;
    }

    free(v68);
  }

  else
  {
    if (v61 == 268451848)
    {
      BOOL v75 = v67 == 0;
      uint64_t v74 = 3214LL;
      if (v67) {
        _dispatch_abort(v74, v75, v3, v4, v5, v6, v7, v8);
      }
      uint64_t v59 = v61;
      uint64_t v29 = v1;
      uint64_t v30 = v2;
      qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Unable to copyout msg, possible port leak";
      qword_E4DA8 = v61;
      __break(1u);
      JUMPOUT(0x90F2CLL);
    }

    if (!v68)
    {
      uint64_t v58 = v61;
      uint64_t v29 = v1;
      uint64_t v30 = v2;
      qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: EVFILT_MACHPORT with no message";
      qword_E4DA8 = v61;
      __break(1u);
      JUMPOUT(0x90F7CLL);
    }

    if (!v61)
    {
      if (*(_DWORD *)v66) {
        uint64_t v40 = (uint64_t)v68 + v67;
      }
      else {
        uint64_t v40 = 0LL;
      }
      *(void *)&v66[4] = v40;
      _dispatch_kevent_mach_msg_recv(v65, v62, v68, v40, v64, v63);
      return;
    }
  }

  if (v61) {
    _dispatch_bug_mach_client((uint64_t)"_dispatch_kevent_mach_msg_drain: message reception failed", v61);
  }
}

uint64_t _dispatch_kevent_merge_muxed(uint64_t result)
{
  uint64_t v5 = result;
  unint64_t v4 = *(void *)(result + 16) & 0xFFFFFFFFFFFFFFFELL;
  uint64_t v2 = 0LL;
  if ((*(_WORD *)(result + 10) & 0x12) != 0) {
    *(_WORD *)(v4 + 34) |= 2u;
  }
  for (uint64_t i = *(void **)(v4 + 16); ; uint64_t i = v2)
  {
    char v1 = 0;
    if (i)
    {
      uint64_t v2 = (void *)*i;
      char v1 = 1;
    }

    if ((v1 & 1) == 0) {
      break;
    }
    uint64_t result = _dispatch_kevent_merge((uint64_t)(i + 3), v5);
  }

  return result;
}

uint64_t _dispatch_kevent_merge(uint64_t a1, uint64_t a2)
{
  unsigned __int8 v31 = *(_BYTE *)(*(void *)a1 + 9LL);
  _dispatch_retain_2(~*(void *)(a1 + 8));
  switch(v31)
  {
    case 0u:
      uint64_t v30 = *(void *)(a2 + 32);
      break;
    case 1u:
      uint64_t v30 = *(unsigned int *)(a2 + 24);
      break;
    case 2u:
      uint64_t v30 = (*(_DWORD *)(a2 + 24) & *(_DWORD *)(a1 + 32));
      if ((*(_BYTE *)(a1 + 29) & 4) != 0)
      {
        unint64_t v28 = v30 | ((unint64_t)*(void *)(a2 + 32) << 32);
        uint64_t v26 = (unint64_t *)(a1 + 72);
        do
        {
          if (_os_atomic_mo_has_acquire(0)) {
            unsigned int v10 = __ldaxr(v26);
          }
          else {
            unsigned int v10 = __ldxr(v26);
          }
          unint64_t v29 = v10 | v28;
          if (_os_atomic_mo_has_release(0)) {
            BOOL v27 = __stlxr(v29, v26) == 0;
          }
          else {
            BOOL v27 = __stxr(v29, v26) == 0;
          }
        }

        while (!v27);
      }

      else if (*(char *)(a1 + 28) == -8)
      {
        uint64_t v30 = 2LL;
        *(void *)(a1 + 72) = 2LL;
      }

      else if ((*(_DWORD *)(a2 + 24) & *(_DWORD *)(a1 + 32)) != 0)
      {
        uint64_t v22 = (unint64_t *)(a1 + 72);
        unint64_t v23 = *(void *)(a1 + 72);
        do
        {
          unint64_t v11 = v23;
          do
            unint64_t v12 = __ldaxr(v22);
          while (v12 == v23 && __stlxr(v23 | v30, v22));
          unint64_t v23 = v12;
        }

        while (v12 != v11);
      }

      break;
    case 3u:
      uint64_t v30 = *(void *)(a2 + 32);
      *(void *)(a1 + 72) = ~v30;
      break;
    case 4u:
      uint64_t v30 = *(void *)(a2 + 32);
      if (v30)
      {
        uint64_t v24 = (unint64_t *)(a1 + 72);
        unint64_t v25 = *(void *)(a1 + 72);
        do
        {
          unint64_t v8 = v25;
          do
            unint64_t v9 = __ldaxr(v24);
          while (v9 == v25 && __stlxr(v25 + v30, v24));
          unint64_t v25 = v9;
        }

        while (v9 != v8);
      }

      break;
    default:
      qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: Corrupt unote action";
      qword_E4DA8 = v31;
      __break(1u);
      JUMPOUT(0x919B0LL);
  }

  __int16 v34 = *(_WORD *)(a2 + 10);
  LOBYTE(v2_dispatch_source_set_handler((uint64_t)source, handler, 2LL, 1) = 0;
  if ((v34 & 0x100) == 0) {
    int v21 = (v34 >> 4) & 1;
  }
  if ((v21 & 1) != 0)
  {
    _dispatch_unote_unregister(a1, 5LL, v2, v3, v4, v5, v6, v7);
  }

  else
  {
    if ((v34 & 2) != 0)
    {
      *(void *)(a1 + 16) = 2LL;
    }

    else if ((*(_WORD *)(a2 + 10) & 0x210) != 0)
    {
      *(void *)(a1 + 16) = *(void *)(a1 + 16) & 0xFFFFFFFFFFFFFFFCLL | 2;
    }

    else
    {
      if ((v34 & 0x80) == 0) {
        return (*(uint64_t (**)(uint64_t, void, uint64_t, uint64_t))(*(void *)a1 + 48LL))( a1,  *(unsigned __int16 *)(a2 + 10),  v30,  *(_DWORD *)(a2 + 12) & 0xFFFFFFLL);
      }
      *(void *)(a1 + 16) &= ~1uLL;
    }

    _dispatch_thread_getspecific(0LL);
    _evfiltstr(*(char *)(a1 + 28));
    _dispatch_log( "%u\t%p\tkevent-source[%p]: %s kevent[%p] { filter = %s, ident = 0x%x }",  v13,  v14,  v15,  v16,  v17,  v18,  v19,  460LL);
  }

  return (*(uint64_t (**)(uint64_t, void, uint64_t, uint64_t))(*(void *)a1 + 48LL))( a1,  *(unsigned __int16 *)(a2 + 10),  v30,  *(_DWORD *)(a2 + 12) & 0xFFFFFFLL);
}

uint64_t _dispatch_kevent_mach_msg_buf(uint64_t a1)
{
  return *(void *)(a1 + 40);
}

uint64_t _dispatch_kevent_mach_msg_aux_size(uint64_t a1)
{
  return *(void *)(a1 + 64);
}

uint64_t _dispatch_kevent_mach_msg_recv( uint64_t a1, unsigned int a2, _DWORD *a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  unsigned int v23 = a3[1] + 68;
  if (((a3[1] + 68LL) & 0x100000000LL) != 0)
  {
    uint64_t v6 = a3[1];
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Overlarge message received";
    qword_E4DA8 = v6;
    __break(1u);
    JUMPOUT(0x91DB4LL);
  }

  if (!a3[3])
  {
    uint64_t v7 = (int)a3[5];
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Received message with MACH_PORT_NULL msgh_local_port";
    qword_E4DA8 = v7;
    __break(1u);
    JUMPOUT(0x91E08LL);
  }

  _dispatch_retain_2(~*(void *)(a1 + 8));
  LOBYTE(v22) = 0;
  if ((a2 & 0x100) == 0) {
    int v22 = (a2 >> 4) & 1;
  }
  if ((v22 & 1) != 0)
  {
    _dispatch_unote_unregister(a1, 5LL, v8, v9, v10, v11, v12, v13);
  }

  else
  {
    if ((a2 & 2) != 0)
    {
      *(void *)(a1 + 16) = 2LL;
    }

    else if ((a2 & 0x210) != 0)
    {
      *(void *)(a1 + 16) = *(void *)(a1 + 16) & 0xFFFFFFFFFFFFFFFCLL | 2;
    }

    else
    {
      if ((a2 & 0x80) == 0) {
        return (*(uint64_t (**)(uint64_t, void, _DWORD *, void, uint64_t, uint64_t, uint64_t))(*(void *)a1 + 56LL))( a1,  a2,  a3,  v23,  a4,  a5,  a6);
      }
      *(void *)(a1 + 16) &= ~1uLL;
    }

    _dispatch_thread_getspecific(0LL);
    _evfiltstr(*(char *)(a1 + 28));
    _dispatch_log( "%u\t%p\tkevent-source[%p]: %s kevent[%p] { filter = %s, ident = 0x%x }",  v14,  v15,  v16,  v17,  v18,  v19,  v20,  460LL);
  }

  return (*(uint64_t (**)(uint64_t, void, _DWORD *, void, uint64_t, uint64_t, uint64_t))(*(void *)a1 + 56LL))( a1,  a2,  a3,  v23,  a4,  a5,  a6);
}

void _dispatch_kq_init(_BYTE *a1)
{
  uint64_t v10 = a1;
  uint64_t v9 = a1;
  if ((_dispatch_unsafe_fork & 1) == 0) {
    _dispatch_fork_becomes_unsafe_slow();
  }
  if (getenv("LIBDISPATCH_TIMERS_FORCE_MAX_LEEWAY")) {
    _dispatch_timers_force_max_leeway = 1;
  }
  _BYTE *v9 = 1;
  _dispatch_kevent_workqueue_init();
  if ((_dispatch_kevent_workqueue_enabled & 1) != 0)
  {
    int v8 = 0;
    unsigned int v7 = _dispatch_kq_fd();
    uint64_t v6 = 0LL;
    __int128 v5 = 0u;
    __int128 v4 = 0u;
    v2[0] = 1LL;
    v2[1] = 0x20000000021FFF6LL;
    __int128 v3 = 0xFFFFFFFFFFFFFFF8LL;
    while (1)
    {
      int v8 = kevent_qos(v7, v2, 1LL, 0LL, 0LL, 0LL);
      if (v8 != -1) {
        break;
      }
      uint64_t v17 = 1LL;
      uint64_t v18 = 1LL;
      unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
      int v1 = **(_DWORD **)(StatusReg + 8);
      if (v1 != 4)
      {
        qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Failed to initalize workqueue kevent";
        qword_E4DA8 = v1;
        __break(1u);
        JUMPOUT(0x922D4LL);
      }
    }
  }

  else
  {
    _dispatch_kq_create(&qword_E4160);
    uint64_t v14 = off_E4158;
    uint64_t v13 = &_dispatch_mgr_q;
    int v12 = 0;
    int v11 = 0;
    uint64_t v16 = off_E4158;
    uint64_t v15 = &_dispatch_mgr_q;
    (*(void (**)(uint64_t, void *, unsigned int))((char *)&stru_20.fileoff + (void)*off_E4158))( (uint64_t)off_E4158,  &_dispatch_mgr_q,  0);
  }

void _dispatch_memorypressure_init()
{
}

uint64_t _dispatch_kq_fd()
{
  return qword_E4160;
}

void _dispatch_kq_create(void *a1)
{
  int v11 = a1;
  unsigned int v10 = 0;
  if ((_dispatch_unsafe_fork & 1) == 0) {
    _dispatch_fork_becomes_unsafe_slow();
  }
  uint64_t v9 = v11;
  unsigned int v10 = guarded_kqueue_np(&v9, 3LL);
  if (v10 == -1)
  {
    uint64_t v14 = 1LL;
    uint64_t v15 = 1LL;
    unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
    int v8 = **(_DWORD **)(StatusReg + 8);
    if (v8 != 12)
    {
      if (v8 != 23)
      {
        if (v8 == 24)
        {
          qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: kqueue() failure: process is out of file descriptors";
          qword_E4DA8 = 24LL;
          __break(1u);
          JUMPOUT(0x9273CLL);
        }

        qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: kqueue() failure";
        qword_E4DA8 = v8;
        __break(1u);
        JUMPOUT(0x92808LL);
      }

      qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: kqueue() failure: system is out of file descriptors";
      qword_E4DA8 = 23LL;
      __break(1u);
      JUMPOUT(0x92780LL);
    }

    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: kqueue() failure: kernel is out of memory";
    qword_E4DA8 = 12LL;
    __break(1u);
    JUMPOUT(0x927C4LL);
  }

  int v7 = kevent_qos(v10, &_dispatch_kq_create_kev, 1LL, 0LL, 0LL, 0LL);
  uint64_t v13 = v7;
  uint64_t v12 = 640LL;
  if (v7) {
    _dispatch_bug(v12, v13, v1, v2, v3, v4, v5, v6);
  }
  *int v11 = (int)v10;
}

void _dispatch_memorypressure_create(uintptr_t a1)
{
  dispatch_source_t v1 = dispatch_source_create( (dispatch_source_type_t)&_dispatch_source_type_memorystatus,  0LL,  a1,  (dispatch_queue_t)&_dispatch_mgr_q);
  dispatch_set_context(v1, v1);
  dispatch_source_set_event_handler_f(v1, (dispatch_function_t)_dispatch_memorypressure_handler);
  dispatch_activate(v1);
  if (_dispatch_memorypressure_source)
  {
    dispatch_source_cancel((dispatch_source_t)_dispatch_memorypressure_source);
    dispatch_release((dispatch_object_t)_dispatch_memorypressure_source);
  }

  _dispatch_memorypressure_source = (uint64_t)v1;
}

uint64_t _dispatch_memorypressure_handler(dispatch_source_s *a1)
{
  uintptr_t data = dispatch_source_get_data(a1);
  if ((data & 0xF0000000) != 0
    && dispatch_source_get_mask((dispatch_source_t)_dispatch_memorypressure_source) != malloc_memorypressure_mask_msl_4libdispatch)
  {
    _dispatch_memorypressure_create(malloc_memorypressure_mask_msl_4libdispatch);
  }

  if ((data & 1) != 0)
  {
    _dispatch_memory_warn = 0;
    _dispatch_continuation_cache_limit = 112;
    if (_firehose_task_buffer)
    {
      int v11 = (void *)_firehose_task_buffer;
      int v8 = (unint64_t *)(_firehose_task_buffer + 512);
      unint64_t v9 = *(void *)(_firehose_task_buffer + 512);
      do
      {
        unint64_t v1 = v9;
        do
          unint64_t v2 = __ldaxr(v8);
        while (v2 == v9 && __stlxr(v9 & 0xFFFFFFFFFFFFFFFELL, v8));
        unint64_t v9 = v2;
      }

      while (v2 != v1);
      if (v2 != (v2 & 0xFFFFFFFFFFFFFFFELL)) {
        firehose_buffer_update_limits(v11);
      }
    }
  }

  if ((data & 2) != 0)
  {
    _dispatch_memory_warn = 1;
    _dispatch_continuation_cache_limit = 16;
    if (_firehose_task_buffer)
    {
      uint64_t v12 = (void *)_firehose_task_buffer;
      uint64_t v6 = (unint64_t *)(_firehose_task_buffer + 512);
      unint64_t v7 = *(void *)(_firehose_task_buffer + 512);
      do
      {
        unint64_t v3 = v7;
        do
          unint64_t v4 = __ldaxr(v6);
        while (v4 == v7 && __stlxr(v7 | 1, v6));
        unint64_t v7 = v4;
      }

      while (v4 != v3);
      if (v4 != (v4 | 1)) {
        firehose_buffer_update_limits(v12);
      }
    }
  }

  return malloc_memory_event_handler(data);
}

const char *_evflagstr(__int16 a1, const char *a2, uint64_t a3)
{
  __int16 v8 = a1;
  *a2 = 0;
  while (v8)
  {
    unint64_t v3 = _evflagstr2(&v8);
    __strlcat_chk(a2, v3, a3, -1LL);
  }

  size_t v5 = strlen(a2);
  if (v5) {
    a2[v5 - 1] = 0;
  }
  return a2;
}

const char *_evflagstr2(_WORD *a1)
{
  if ((*a1 & 1) == 1)
  {
    *a1 &= ~1u;
    return "EV_ADD|";
  }

  else if ((*a1 & 2) == 2)
  {
    *a1 &= ~2u;
    return "EV_DELETE|";
  }

  else if ((*a1 & 4) == 4)
  {
    *a1 &= ~4u;
    return "EV_ENABLE|";
  }

  else if ((*a1 & 8) == 8)
  {
    *a1 &= ~8u;
    return "EV_DISABLE|";
  }

  else if ((*a1 & 0x10) == 0x10)
  {
    *a1 &= ~0x10u;
    return "EV_ONESHOT|";
  }

  else if ((*a1 & 0x20) == 0x20)
  {
    *a1 &= ~0x20u;
    return "EV_CLEAR|";
  }

  else if ((*a1 & 0x40) == 0x40)
  {
    *a1 &= ~0x40u;
    return "EV_RECEIPT|";
  }

  else if ((*a1 & 0x80) == 0x80)
  {
    *a1 &= ~0x80u;
    return "EV_DISPATCH|";
  }

  else if ((*a1 & 0x100) == 0x100)
  {
    *a1 &= ~0x100u;
    return "EV_UDATA_SPECIFIC|";
  }

  else if ((*a1 & 0x1000) == 0x1000)
  {
    *a1 &= ~0x1000u;
    return "EV_POLL|";
  }

  else if ((*a1 & 0x2000) == 0x2000)
  {
    *a1 &= ~0x2000u;
    return "EV_OOBAND|";
  }

  else if ((*a1 & 0x4000) == 0x4000)
  {
    *a1 &= ~0x4000u;
    return "EV_ERROR|";
  }

  else if ((*a1 & 0x8000) == 0x8000)
  {
    *a1 &= ~0x8000u;
    return "EV_EOF|";
  }

  else if ((*a1 & 0x200) == 0x200)
  {
    *a1 &= ~0x200u;
    return "EV_VANISHED|";
  }

  else
  {
    *a1 = 0;
    return "EV_UNKNOWN ";
  }

void _dispatch_mach_host_notify_update()
{
  kern_return_t v14;
  _dispatch_thread_getspecific(0LL);
  _dispatch_log("%u\t%p\tregistering for calendar-change notification", v0, v1, v2, v3, v4, v5, v6, 2888LL);
  host_t host = _dispatch_get_mach_host_port();
  if (_dispatch_mach_notify_port_pred != -1) {
    dispatch_once_f(&_dispatch_mach_notify_port_pred, 0LL, (dispatch_function_t)_dispatch_mach_notify_port_init);
  }
  uint64_t v14 = host_request_notification(host, 1, _dispatch_mach_notify_port);
  if (v14 == -301)
  {
    qword_E4D78 = (uint64_t)"MIG_REPLY_MISMATCH";
    qword_E4DA8 = -301LL;
    __break(1u);
    JUMPOUT(0x9319CLL);
  }

  if (v14) {
    _dispatch_bug(2893LL, v14, v7, v8, v9, v10, v11, v12);
  }
}

void _dispatch_mach_notify_port_init(uint64_t a1)
{
  kern_return_t v14;
  mach_port_options_t options;
  uint64_t v16;
  uint64_t v17;
  BOOL v18;
  uint64_t v16 = a1;
  options.reserved[1] = 0LL;
  *(_OWORD *)&options.flags = xmmword_C2A70;
  uint64_t v14 = mach_port_construct( mach_task_self_,  &options,  (mach_port_context_t)&_dispatch_mach_notify_port,  (mach_port_name_t *)&_dispatch_mach_notify_port);
  if (v14)
  {
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: mach_port_construct() failed: cannot create receive right";
    qword_E4DA8 = v14;
    __break(1u);
    JUMPOUT(0x93298LL);
  }

  uint64_t v13 = _dispatch_unote_create_with_handle( (uint64_t)&_dispatch_mach_type_notification,  _dispatch_mach_notify_port,  0LL);
  *(void *)(v13 + 8) = ~(unint64_t)&_dispatch_mgr_q;
  BOOL v12 = _dispatch_unote_register(v13, -4LL, 0x2000000LL, v1, v2, v3, v4, v5);
  uint64_t v18 = v12;
  uint64_t v17 = 2842LL;
  if (!v12) {
    _dispatch_bug(v17, v18, v6, v7, v8, v9, v10, v11);
  }
  _dispatch_mach_notify_unote = v13;
}

BOOL _dispatch_kevent_mach_notify_resume( uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v9 = 0;
  if ((a2 & 0xD) != 0 || (a3 & 0xD) != 0) {
    int v9 = _dispatch_mach_notify_update(a1, a2, a3, 0xDu, 66, 0);
  }
  return v9 == 0;
}

uint64_t _dispatch_mach_notify_update( uint64_t a1, int a2, int a3, unsigned int a4, mach_msg_id_t a5, mach_port_mscount_t a6)
{
  kern_return_t v48;
  kern_return_t v49;
  kern_return_t v50;
  uint64_t v51;
  mach_port_name_t v52;
  mach_port_t previous;
  mach_port_mscount_t v54;
  mach_msg_id_t v55;
  unsigned int v56;
  int v57;
  int v58;
  uint64_t v59;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  dispatch_function_t v71;
  void *v72;
  dispatch_once_t *v73;
  uint64_t v59 = a1;
  uint64_t v58 = a2;
  uint64_t v57 = a3;
  int v56 = a4;
  signed int v55 = a5;
  uint64_t v54 = a6;
  previous = 0;
  int v52 = *(void *)(a1 + 24);
  uint64_t v51 = *(void *)(a1 + 56);
  uint64_t v48 = 0;
  *(void *)(a1 + 56) = v51 | (a2 | *(_DWORD *)(a1 + 48)) & a4;
  *(void *)(v59 + 56) &= ~(v57 & v56);
  if ((*(void *)(v59 + 56) & v56) == 0LL || (v51 & v56) != 0)
  {
    _dispatch_thread_getspecific(0LL);
    _dispatch_log( "%u\t%p\tmachport[0x%08x]: unregistering for send-possible notification",  v25,  v26,  v27,  v28,  v29,  v30,  v31,  2953LL);
    previous = 0;
    __int128 v50 = mach_port_request_notification(mach_task_self_, v52, v55, v54, 0, 0x12u, &previous);
    if (v50 == -301)
    {
      qword_E4D78 = (uint64_t)"MIG_REPLY_MISMATCH";
      qword_E4DA8 = -301LL;
      __break(1u);
      JUMPOUT(0x938D8LL);
    }

    if (v50 != 4 && v50 != 15 && v50 != 17)
    {
      uint64_t v64 = v50;
      uint64_t v63 = 2966LL;
      if (v50) {
        _dispatch_bug(v63, v64, v32, v33, v34, v35, v36, v37);
      }
    }
  }

  else
  {
    _dispatch_thread_getspecific(0LL);
    _dispatch_log( "%u\t%p\tmachport[0x%08x]: registering for send-possible notification",  v6,  v7,  v8,  v9,  v10,  v11,  v12,  2920LL);
    previous = 0;
    tasuint64_t k = mach_task_self_;
    uint64_t v73 = &_dispatch_mach_notify_port_pred;
    uint64_t v72 = 0LL;
    uint64_t v71 = (dispatch_function_t)_dispatch_mach_notify_port_init;
    if (_dispatch_mach_notify_port_pred != -1) {
      dispatch_once_f(v73, v72, v71);
    }
    uint64_t v48 = mach_port_request_notification(task, v52, v55, v54, _dispatch_mach_notify_port, 0x15u, &previous);
    if (v48 == -301)
    {
      qword_E4D78 = (uint64_t)"MIG_REPLY_MISMATCH";
      qword_E4DA8 = -301LL;
      __break(1u);
      JUMPOUT(0x9361CLL);
    }

    if (v48 == 15 || v48 == 17)
    {
      *(void *)(v59 + 56) &= ~v56;
    }

    else
    {
      uint64_t v70 = v48;
      uint64_t v69 = 2935LL;
      if (v48)
      {
        _dispatch_bug(v69, v70, v13, v14, v15, v16, v17, v18);
        *(void *)(v59 + 56) &= ~v56;
      }

      else
      {
        mach_port_t v47 = previous;
        unsigned int v68 = previous;
        unsigned int v67 = 2938LL;
        if (previous) {
          _dispatch_bug(v67, v68, v13, v14, v15, v16, v17, v18);
        }
        if (v47)
        {
          uint64_t v49 = mach_port_deallocate(mach_task_self_, previous);
          if (v49 == -301)
          {
            qword_E4D78 = (uint64_t)"MIG_REPLY_MISMATCH";
            qword_E4DA8 = -301LL;
            __break(1u);
            JUMPOUT(0x93798LL);
          }

          __int128 v66 = v49;
          uint64_t v65 = 2947LL;
          if (v49) {
            _dispatch_bug(v65, v66, v19, v20, v21, v22, v23, v24);
          }
          previous = 0;
        }
      }
    }
  }

  if (previous)
  {
    int v46 = _dispatch_send_consume_send_once_right(previous);
    unsigned int v62 = v46;
    mach_error_t v61 = 2976LL;
    if (v46) {
      _dispatch_bug(v61, v62, v38, v39, v40, v41, v42, v43);
    }
  }

  return v48;
}

void _dispatch_timers_calendar_change()
{
  for (unsigned int i = 0; i < 3; ++i)
  {
    byte_E4E16 |= (1 << ((i + 6) % 3)) | 0x80;
    *((_BYTE *)&_dispatch_timers_heap + 32 * i + 199) = *((_BYTE *)&_dispatch_timers_heap + 32 * i + 199) & 0xFD | 2;
  }

void _voucher_xref_dispose(unsigned int *a1)
{
  int v14 = a1[2];
  if (v14 != 0x7FFFFFFF)
  {
    uint64_t v11 = a1 + 2;
    unsigned int v12 = a1[2];
    do
    {
      unsigned int v8 = v12;
      do
        unsigned int v9 = __ldaxr(v11);
      while (v9 == v12 && __stlxr(v12 - 1, v11));
      unsigned int v12 = v9;
    }

    while (v9 != v8);
    int v14 = v9 - 1;
  }

  if (v14 < 1)
  {
    if (v14 < 0)
    {
      qword_E4D78 = (uint64_t)"API MISUSE: Over-release of an object";
      __break(1u);
      JUMPOUT(0x93C84LL);
    }

    int v13 = a1[3];
    if (v13 >= 1)
    {
      qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: Release while external references exist";
      qword_E4DA8 = v13;
      __break(1u);
      JUMPOUT(0x93CE4LL);
    }

    _os_object_dispose(a1);
  }

void _voucher_dispose(uint64_t a1)
{
  if (*(void *)(a1 + 24))
  {
    _dispatch_thread_getspecific(0LL);
    _dispatch_log("%u\t%p\tvoucher[%p]: corruption", v8, v9, v10, v11, v12, v13, v14, 793LL);
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Voucher corruption";
    __break(1u);
    JUMPOUT(0x93DECLL);
  }

  *(void *)(a1 + 24) = 0LL;
  *(void *)(a1 + 16) = -1985229329LL;
  if (*(_DWORD *)(a1 + 36))
  {
    if (*(_DWORD *)(a1 + 36) != *(_DWORD *)(a1 + 32)) {
      _voucher_dealloc_mach_voucher(*(_DWORD *)(a1 + 36));
    }
    *(_DWORD *)(a1 + 36) = 0;
  }

  if (*(_DWORD *)(a1 + 32))
  {
    if (!*(void *)(a1 + 40)) {
      _voucher_dealloc_mach_voucher(*(_DWORD *)(a1 + 32));
    }
    *(_DWORD *)(a1 + 32) = 0;
  }

  if (*(void *)(a1 + 40))
  {
    os_release(*(void **)(a1 + 40));
    *(void *)(a1 + 4_dispatch_source_set_handler((uint64_t)source, handler, 2LL, 0) = 0LL;
  }

  *(void *)(a1 + 48) = 0LL;
  *(void *)(a1 + 56) = 0LL;
  *(void *)(a1 + 64) = 0LL;
  _os_object_dealloc((void *)a1);
}

_DWORD *voucher_adopt(uint64_t a1)
{
  if (a1 == -3)
  {
    uint64_t v14 = _dispatch_thread_getspecific(0x1CuLL);
    if (v14) {
      os_retain(v14);
    }
    return v14;
  }

  else
  {
    uint64_t v15 = _dispatch_thread_getspecific(0x1CuLL);
    if (v15 == (_DWORD *)a1)
    {
      unsigned int v16 = -1;
    }

    else
    {
      _dispatch_thread_setspecific(28LL, a1);
      _dispatch_thread_getspecific(0LL);
      _dispatch_log("%u\t%p\tvoucher[%p]: swap from voucher[%p]", v1, v2, v3, v4, v5, v6, v7, 400LL);
      if (a1) {
        int v11 = *(_DWORD *)(a1 + 32);
      }
      else {
        int v11 = 0;
      }
      if (v15) {
        int v10 = v15[8];
      }
      else {
        int v10 = 0;
      }
      if (v11 == v10) {
        int v9 = -1;
      }
      else {
        int v9 = v11;
      }
      unsigned int v16 = v9;
    }

    if (v16 != -1) {
      _dispatch_set_priority_and_mach_voucher_slow(0LL, v16);
    }
    return v15;
  }

void *voucher_copy()
{
  uint64_t v1 = _dispatch_thread_getspecific(0x1CuLL);
  if (v1) {
    os_retain(v1);
  }
  return v1;
}

_DWORD *voucher_copy_without_importance()
{
  uint64_t v1 = _dispatch_thread_getspecific(0x1CuLL);
  if (v1) {
    return _voucher_create_without_importance(v1);
  }
  return v1;
}

void *voucher_retain(void *a1)
{
  return a1;
}

void voucher_release(void *a1)
{
}

void _voucher_thread_cleanup(void *a1)
{
}

void _voucher_dealloc_mach_voucher(mach_port_name_t a1)
{
  kern_return_t v14;
  _dispatch_thread_getspecific(0LL);
  _dispatch_log("%u\t%p\tkvoucher[0x%08x]: dealloc", v1, v2, v3, v4, v5, v6, v7, 298LL);
  uint64_t v14 = mach_voucher_deallocate(a1);
  if (v14 == -301)
  {
    qword_E4D78 = (uint64_t)"MIG_REPLY_MISMATCH";
    qword_E4DA8 = -301LL;
    __break(1u);
    JUMPOUT(0x94360LL);
  }

  if (v14) {
    _dispatch_bug(302LL, v14, v8, v9, v10, v11, v12, v13);
  }
}

uint64_t _voucher_task_mach_voucher_init(uint64_t a1)
{
  uint64_t v4 = a1;
  int v3 = 0;
  int v2 = 0;
  uint64_t result = _voucher_create_mach_voucher(_voucher_task_mach_voucher_init_task_create_recipe, 16LL, (ipc_voucher_t *)&v2);
  int v3 = result;
  if ((_DWORD)result)
  {
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Could not create task mach voucher";
    qword_E4DA8 = v3;
    __break(1u);
    JUMPOUT(0x9443CLL);
  }

  _voucher_default_task_int mach_voucher = v2;
  _voucher_task_int mach_voucher = v2;
  return result;
}

uint64_t _voucher_create_mach_voucher(uint8_t *a1, uint64_t a2, ipc_voucher_t *a3)
{
  mach_voucher_attr_raw_recipe_array_t v16 = a1;
  uint64_t v15 = a2;
  uint64_t v14 = a3;
  unsigned int v13 = 0;
  mach_host_mach_port_t port = _dispatch_get_mach_host_port();
  ipc_voucher_t voucher = 0;
  unsigned int v13 = host_create_mach_voucher(mach_host_port, v16, v15, &voucher);
  if (v13 == -301)
  {
    qword_E4D78 = (uint64_t)"MIG_REPLY_MISMATCH";
    qword_E4DA8 = -301LL;
    __break(1u);
    JUMPOUT(0x9452CLL);
  }

  if (!v13)
  {
    _dispatch_thread_getspecific(0LL);
    _dispatch_log("%u\t%p\tkvoucher[0x%08x]: create", v3, v4, v5, v6, v7, v8, v9, 319LL);
  }

  ipc_voucher_t *v14 = voucher;
  return v13;
}

void voucher_replace_default_voucher()
{
  uint64_t v28 = &_voucher_task_mach_voucher_pred;
  uint64_t v27 = 0LL;
  dispatch_function_t v26 = (dispatch_function_t)_voucher_task_mach_voucher_init;
  if (_voucher_task_mach_voucher_pred != -1) {
    dispatch_once_f(v28, v27, v26);
  }
  mach_port_name_t v23 = 0;
  int v22 = 0;
  uint64_t v21 = _dispatch_thread_getspecific(0x1CuLL);
  if (v21 && v21[8])
  {
    int mach_voucher = 0;
    if (v21[9]) {
      mach_port_name_t v17 = v21[9];
    }
    else {
      mach_port_name_t v17 = v21[8];
    }
    mach_port_name_t v23 = v17;
    v19[0] = 0x100000003LL;
    v19[1] = v17;
    int mach_voucher = _voucher_create_mach_voucher((uint8_t *)v19, 16LL, (ipc_voucher_t *)&v22);
    int v18 = mach_voucher;
    uint64_t v25 = mach_voucher;
    uint64_t v24 = 362LL;
    if (mach_voucher) {
      _dispatch_bug(v24, v25, v0, v1, v2, v3, v4, v5);
    }
    if (v18) {
      int v22 = 0;
    }
  }

  if (!v22) {
    int v22 = _voucher_default_task_mach_voucher;
  }
  unsigned int v15 = v22;
  int v16 = _voucher_task_mach_voucher;
  do
  {
    int v6 = v16;
    do
      unsigned int v7 = __ldaxr((unsigned int *)&_voucher_task_mach_voucher);
    while (v7 == v16 && __stlxr(v15, (unsigned int *)&_voucher_task_mach_voucher));
    int v16 = v7;
  }

  while (v7 != v6);
  mach_port_name_t v23 = v7;
  if (v7 && v23 != _voucher_default_task_mach_voucher) {
    _voucher_dealloc_mach_voucher(v23);
  }
  _dispatch_thread_getspecific(0LL);
  _dispatch_log("%u\t%p\tvoucher[%p]: kvoucher[0x%08x] replace default voucher", v8, v9, v10, v11, v12, v13, v14, 371LL);
}

uint64_t _voucher_get_mach_voucher(uint64_t a1)
{
  if (a1)
  {
    if (*(_DWORD *)(a1 + 36))
    {
      return *(unsigned int *)(a1 + 36);
    }

    else
    {
      unsigned int v2 = *(_DWORD *)(a1 + 32);
      if (!v2)
      {
        if (_voucher_task_mach_voucher_pred != -1) {
          dispatch_once_f(&_voucher_task_mach_voucher_pred, 0LL, (dispatch_function_t)_voucher_task_mach_voucher_init);
        }
        return _voucher_task_mach_voucher;
      }

      return v2;
    }
  }

  else
  {
    return 0;
  }

_DWORD *_voucher_create_without_importance(_DWORD *a1)
{
  uint64_t v37 = a1;
  if (!a1) {
    return 0LL;
  }
  if (v37[8] && (v37[18] & 1) != 0)
  {
    int v36 = 0;
    ipc_voucher_t v35 = 0;
    if (v37[9]) {
      int v30 = v37[9];
    }
    else {
      int v30 = v37[8];
    }
    v49[0] = -1;
    v49[1] = 1;
    v49[2] = v30;
    v49[3] = 0;
    v49[4] = 2;
    uint64_t v50 = 2LL;
    int v51 = 0;
    int v36 = _voucher_create_mach_voucher((uint8_t *)v49, 32LL, &v35);
    int v34 = v36;
    uint64_t v41 = v36;
    uint64_t v40 = 639LL;
    if (v36) {
      _dispatch_bug(v40, v41, v1, v2, v3, v4, v5, v6);
    }
    if (v34 || !v35)
    {
      if (v37[9]) {
        return 0LL;
      }
      ipc_voucher_t v35 = 0;
    }

    if (v35 == v30)
    {
      _voucher_dealloc_mach_voucher(v35);
      uint64_t v39 = v37;
      os_retain(v37);
      return v39;
    }

    else
    {
      uint64_t v32 = _voucher_find_and_retain(v35);
      if (v32 && v37[9])
      {
        _dispatch_thread_getspecific(0LL);
        _dispatch_log( "%u\t%p\tvoucher[%p]: kvoucher[0x%08x] find without importance from voucher[%p]",  v14,  v15,  v16,  v17,  v18,  v19,  v20,  650LL);
        _voucher_dealloc_mach_voucher(v35);
        return (_DWORD *)v32;
      }

      else
      {
        uint64_t v31 = v32;
        mach_port_t v47 = v37;
        __int16 v46 = 1;
        unsigned int v45 = 0;
        uint64_t v44 = 0LL;
        if (v37) {
          unsigned int v45 = 0;
        }
        uint64_t v44 = _voucher_alloc(v45, v7, v8, v9, v10, v11, v12, v13);
        if (v47)
        {
          __int16 v43 = ~v46;
          if ((v46 & 1) == 0 && v47[8])
          {
            uint64_t v42 = 0LL;
            if (*((void *)v47 + 5)) {
              uint64_t v29 = (_DWORD *)*((void *)v47 + 5);
            }
            else {
              uint64_t v29 = v47;
            }
            uint64_t v42 = v29;
            uint64_t v48 = v29;
            os_retain(v29);
            v44[5] = v48;
            *((_DWORD *)v44 + 8) = v42[8];
            *((_BYTE *)v44 + 72) = v44[9] & 0xFE | v42[18] & 1;
          }

          if ((v43 & 2) != 0)
          {
            v44[6] = *((void *)v47 + 6);
            v44[7] = *((void *)v47 + 7);
            v44[8] = *((void *)v47 + 8);
          }
        }

        uint64_t v33 = v44;
        *((_DWORD *)v44 + 8) = v35;
        if (v37[9])
        {
          *((_DWORD *)v33 + 9) = v35;
          _voucher_insert(v33);
        }

        else if (v31)
        {
          v33[5] = v31;
          _voucher_dealloc_mach_voucher(v35);
        }

        if (!v31)
        {
          _dispatch_thread_getspecific(0LL);
          _dispatch_log( "%u\t%p\tvoucher[%p]: kvoucher[0x%08x] create without importance from voucher[%p]",  v21,  v22,  v23,  v24,  v25,  v26,  v27,  667LL);
        }

        return v33;
      }
    }
  }

  else
  {
    os_retain(v37);
    return v37;
  }

uint64_t _voucher_find_and_retain(unsigned int a1)
{
  if (!a1) {
    return 0LL;
  }
  unsigned int v33 = _dispatch_thread_getspecific(3uLL);
  do
    unsigned int v1 = __ldaxr((unsigned int *)&_voucher_hash_lock);
  while (!v1 && __stlxr(v33 & 0xFFFFFFFC, (unsigned int *)&_voucher_hash_lock));
  if (v1) {
    _dispatch_unfair_lock_lock_slow((unsigned int *)&_voucher_hash_lock, 0x10000);
  }
  for (uint64_t i = ~_voucher_hash[(a1 >> 8) & 0x3F]; i; uint64_t i = ~*(void *)(i + 16))
  {
    if (*(_DWORD *)(i + 36) == a1)
    {
      uint64_t v27 = (unsigned int *)(i + 12);
      unsigned int v28 = *(_DWORD *)(i + 12);
      do
      {
        unsigned int v2 = v28;
        do
          unsigned int v3 = __ldaxr(v27);
        while (v3 == v28 && __stlxr(v28 + 1, v27));
        unsigned int v26 = v3;
        unsigned int v28 = v3;
      }

      while (v3 != v2);
      unsigned int v29 = v3 + 1;
      _dispatch_thread_getspecific(0LL);
      _dispatch_log("%u\t%p\tvoucher[%p]: retain  -> %d", v4, v5, v6, v7, v8, v9, v10, 234LL);
      if ((int)(v26 + 1) <= 0)
      {
        _dispatch_thread_getspecific(0LL);
        _dispatch_log("%u\t%p\tvoucher[%p]: over-release", v11, v12, v13, v14, v15, v16, v17, 236LL);
        qword_E4D78 = (uint64_t)"API MISUSE: Voucher over-release";
        __break(1u);
        JUMPOUT(0x95220LL);
      }

      if (v29 == 1)
      {
        uint64_t v24 = (unsigned int *)(i + 8);
        unsigned int v25 = *(_DWORD *)(i + 8);
        do
        {
          unsigned int v18 = v25;
          do
            unsigned int v19 = __ldaxr(v24);
          while (v19 == v25 && __stlxr(v25 + 1, v24));
          unsigned int v25 = v19;
        }

        while (v19 != v18);
      }

      break;
    }
  }

  unsigned int v34 = _dispatch_thread_getspecific(3uLL) & 0xFFFFFFFC;
  int v23 = _voucher_hash_lock;
  do
  {
    int v20 = v23;
    do
      unsigned int v21 = __ldaxr((unsigned int *)&_voucher_hash_lock);
    while (v21 == v23 && __stlxr(0, (unsigned int *)&_voucher_hash_lock));
    int v23 = v21;
  }

  while (v21 != v20);
  if (v21 != v34) {
    _dispatch_unfair_lock_unlock_slow((uint64_t)&_voucher_hash_lock, v21);
  }
  return i;
}

void *_voucher_insert(void *result)
{
  unint64_t v36 = (unint64_t)result;
  unsigned int v35 = *((_DWORD *)result + 9);
  if (v35)
  {
    unsigned int v37 = _dispatch_thread_getspecific(3uLL) & 0xFFFFFFFC;
    do
      unsigned int v1 = __ldaxr((unsigned int *)&_voucher_hash_lock);
    while (!v1 && __stlxr(v37, (unsigned int *)&_voucher_hash_lock));
    if (v1) {
      _dispatch_unfair_lock_lock_slow((unsigned int *)&_voucher_hash_lock, 0x10000);
    }
    if (*(void *)(v36 + 24))
    {
      _dispatch_thread_getspecific(0LL);
      _dispatch_log("%u\t%p\tvoucher[%p]: corruption", v2, v3, v4, v5, v6, v7, v8, 259LL);
      qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Voucher corruption";
      __break(1u);
      JUMPOUT(0x9560CLL);
    }

    if (*(void *)(v36 + 48))
    {
      _dispatch_thread_getspecific(0LL);
      _dispatch_log("%u\t%p\tvoucher[%p]: Activity data corruption", v9, v10, v11, v12, v13, v14, v15, 263LL);
      uint64_t v16 = *(void *)(v36 + 48);
      qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: base voucher has non-zero activity value";
      qword_E4DA8 = v16;
      __break(1u);
      JUMPOUT(0x95698LL);
    }

    if (*(void *)(v36 + 40))
    {
      _dispatch_thread_getspecific(0LL);
      _dispatch_log( "%u\t%p\tvoucher[%p]: Incoming voucher with corrupted base",  v17,  v18,  v19,  v20,  v21,  v22,  v23,  267LL);
      _dispatch_thread_getspecific(0LL);
      _dispatch_log( "%u\t%p\tvoucher[%p]: Corrupted base for incoming voucher",  v24,  v25,  v26,  v27,  v28,  v29,  v30,  268LL);
      uint64_t v31 = *(void *)(v36 + 40);
      qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: base voucher has nested base voucher";
      qword_E4DA8 = v31;
      __break(1u);
      JUMPOUT(0x9575CLL);
    }

    uint64_t v39 = &_voucher_hash[(v35 >> 8) & 0x3F];
    unint64_t v38 = ~*v39;
    *(void *)(v36 + 16) = *v39;
    if (v38) {
      *(void *)(v38 + 24) = ~(v36 + 16);
    }
    *uint64_t v39 = ~v36;
    *(void *)(v36 + 24) = ~(unint64_t)v39;
    uint64_t result = _dispatch_thread_getspecific(3uLL);
    int v34 = _voucher_hash_lock;
    do
    {
      int v32 = v34;
      do
        unsigned int v33 = __ldaxr((unsigned int *)&_voucher_hash_lock);
      while (v33 == v34 && __stlxr(0, (unsigned int *)&_voucher_hash_lock));
      int v34 = v33;
    }

    while (v33 != v32);
  }

  return result;
}

void *_voucher_create_accounting_voucher(_DWORD *a1)
{
  unint64_t v38 = a1;
  if (!a1 || !v38[8]) {
    return 0LL;
  }
  int v37 = 0;
  unsigned int v36 = 0;
  ipc_voucher_t v35 = 0;
  if (v38[9]) {
    unsigned int v30 = v38[9];
  }
  else {
    unsigned int v30 = v38[8];
  }
  unsigned int v36 = v30;
  v34[0] = 0x100000003LL;
  v34[1] = v30;
  int v37 = _voucher_create_mach_voucher((uint8_t *)v34, 16LL, &v35);
  int v33 = v37;
  uint64_t v42 = v37;
  uint64_t v41 = 689LL;
  if (v37) {
    _dispatch_bug(v41, v42, v1, v2, v3, v4, v5, v6);
  }
  if (v33 || !v35) {
    return 0LL;
  }
  uint64_t v31 = _voucher_find_and_retain(v35);
  if (v31)
  {
    _dispatch_thread_getspecific(0LL);
    _dispatch_log( "%u\t%p\tvoucher[%p]: kvoucher[0x%08x] find accounting voucher from voucher[%p]",  v14,  v15,  v16,  v17,  v18,  v19,  v20,  695LL);
    _voucher_dealloc_mach_voucher(v35);
    return (void *)v31;
  }

  else
  {
    int v32 = _voucher_alloc(0, v7, v8, v9, v10, v11, v12, v13);
    ipc_voucher_t v21 = v35;
    *((_DWORD *)v32 + 8) = v35;
    *((_DWORD *)v32 + 9) = v21;
    if (v35 == v36)
    {
      uint64_t v40 = v38;
      os_retain(v38);
      v32[5] = v40;
      _voucher_dealloc_mach_voucher(v35);
    }

    _voucher_insert(v32);
    _dispatch_thread_getspecific(0LL);
    _dispatch_log( "%u\t%p\tvoucher[%p]: kvoucher[0x%08x] create accounting voucher from voucher[%p]",  v22,  v23,  v24,  v25,  v26,  v27,  v28,  708LL);
    return v32;
  }

void *_voucher_alloc( unsigned int a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v22 = _os_object_alloc_realized((uint64_t)_OS_voucher_vtable, a1 + 80LL, a3, a4, a5, a6, a7, a8);
  if (a1) {
    _dispatch_abort(62LL, a1 == 0, v8, v9, v10, v11, v12, v13);
  }
  _dispatch_thread_getspecific(0LL);
  _dispatch_log("%u\t%p\tvoucher[%p]: alloc", v14, v15, v16, v17, v18, v19, v20, 64LL);
  return v22;
}

void *_voucher_create_with_mach_msgv( _DWORD *a1, _DWORD *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v15 = a1;
  uint64_t v14 = a2;
  unsigned int v13 = 0;
  uint64_t v12 = 0LL;
  unsigned int v11 = 0;
  uint64_t v19 = a1;
  uint64_t v18 = (int *)&v13;
  if ((*a1 & 0x1F0000) != 0)
  {
    unsigned int v17 = 0;
    unsigned int v17 = v19[4];
    v19[4] = 0;
    int v16 = 538902528;
    *uint64_t v18 = *v19 & 0x201F0000;
    *v19 &= ~v16;
    unsigned int v20 = v17;
  }

  else
  {
    *uint64_t v18 = 0;
    unsigned int v20 = 0;
  }

  if (a2)
  {
    unsigned int v10 = *a2;
    if (*a2 <= 7u)
    {
      qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: Invalid msg aux data size.";
      qword_E4DA8 = v10;
      __break(1u);
      JUMPOUT(0x95E64LL);
    }

    unsigned int v11 = v10 - 8;
    if (v10 == 8) {
      uint64_t v9 = 0LL;
    }
    else {
      uint64_t v9 = a2 + 2;
    }
    uint64_t v12 = (uint64_t)v9;
  }

  return _voucher_create_with_mach_voucher(v20, v13, v12, v11, a5, a6, a7, a8);
}

void *_voucher_create_with_mach_voucher( unsigned int a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v37 = a2;
  unsigned int v35 = a4;
  uint64_t v33 = 0LL;
  if (a1)
  {
    uint64_t v33 = _voucher_find_and_retain(a1);
    if (v33)
    {
      _dispatch_thread_getspecific(0LL);
      _dispatch_log("%u\t%p\tvoucher[%p]: kvoucher[0x%08x] found", v15, v16, v17, v18, v19, v20, v21, 485LL);
      _voucher_dealloc_mach_voucher(a1);
    }

    else
    {
      uint64_t v33 = (uint64_t)_voucher_alloc(0, v8, v9, v10, v11, v12, v13, v14);
      *(_DWORD *)(v33 + 32) = a1;
      *(_DWORD *)(v33 + 36) = a1;
      *(_BYTE *)(v33 + 72) = *(_BYTE *)(v33 + 72) & 0xFE | ((v37 & 0x20000000) != 0);
      _voucher_insert((void *)v33);
    }
  }

  if (v35 < 0x20 || *(_DWORD *)a3 != 59821818 || !*(void *)(a3 + 8)) {
    return (void *)v33;
  }
  if (v33)
  {
    if (*(void *)(v33 + 48))
    {
      uint64_t v22 = *(void *)(v33 + 48);
      qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: base voucher has non-zero activity value";
      qword_E4DA8 = v22;
      __break(1u);
      JUMPOUT(0x96094LL);
    }

    if (*(void *)(v33 + 40))
    {
      uint64_t v23 = *(void *)(v33 + 40);
      qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: base voucher has nested base voucher";
      qword_E4DA8 = v23;
      __break(1u);
      JUMPOUT(0x960ECLL);
    }

    uint64_t v40 = _voucher_alloc(0, a2, a3, a4, a5, a6, a7, a8);
    if (*(_DWORD *)(v33 + 32))
    {
      if (*(void *)(v33 + 40)) {
        uint64_t v32 = *(void *)(v33 + 40);
      }
      else {
        uint64_t v32 = v33;
      }
      os_retain((void *)v32);
      v40[5] = v32;
      *((_DWORD *)v40 + 8) = *(_DWORD *)(v32 + 32);
      *((_BYTE *)v40 + 72) = v40[9] & 0xFE | *(_BYTE *)(v32 + 72) & 1;
    }

    int v34 = v40;
    voucher_release((void *)v33);
  }

  else
  {
    int v34 = _voucher_alloc(0, a2, a3, a4, a5, a6, a7, a8);
  }

  v34[6] = *(void *)(a3 + 8);
  v34[7] = *(void *)(a3 + 16);
  v34[8] = *(void *)(a3 + 24);
  _dispatch_thread_getspecific(0LL);
  _dispatch_log("%u\t%p\tvoucher[%p]: kvoucher[0x%08x] create", v24, v25, v26, v27, v28, v29, v30, 521LL);
  return v34;
}

void *voucher_create_with_mach_msg( _DWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10 = a1;
  unsigned int v9 = 0;
  uint64_t v14 = a1;
  uint64_t v13 = (int *)&v9;
  if ((*a1 & 0x1F0000u) >> 16)
  {
    unsigned int v12 = 0;
    unsigned int v12 = v14[4];
    void v14[4] = 0;
    int v11 = 538902528;
    int *v13 = *v14 & 0x201F0000;
    *v14 &= ~v11;
    unsigned int v15 = v12;
  }

  else
  {
    int *v13 = 0;
    unsigned int v15 = 0;
  }

  return _voucher_create_with_mach_voucher(v15, v9, 0LL, 0LL, a5, a6, a7, a8);
}

void voucher_decrement_importance_count4CF(uint64_t a1)
{
  uint64_t v24 = a1;
  if (a1 && *(_DWORD *)(v24 + 32) && (*(_BYTE *)(v24 + 72) & 1) != 0)
  {
    mach_error_t v23 = 0;
    ipc_voucher_t v22 = 0;
    if (*(_DWORD *)(v24 + 36)) {
      ipc_voucher_t v14 = *(_DWORD *)(v24 + 36);
    }
    else {
      ipc_voucher_t v14 = *(_DWORD *)(v24 + 32);
    }
    ipc_voucher_t v22 = v14;
    int v21 = 1;
    uint64_t v20 = &v21;
    int v19 = 4;
    int v16 = -1;
    uint64_t v18 = &v16;
    mach_msg_type_number_t out_contentCnt = 4;
    mach_error_t v23 = mach_voucher_attr_command( v14,  2u,  2u,  (mach_voucher_attr_content_t)&v21,  4u,  (mach_voucher_attr_content_t)&v16,  &out_contentCnt);
    if (v23 == -301)
    {
      qword_E4D78 = (uint64_t)"MIG_REPLY_MISMATCH";
      qword_E4DA8 = -301LL;
      __break(1u);
      JUMPOUT(0x96554LL);
    }

    if (v23 != 16)
    {
      _dispatch_thread_getspecific(0LL);
      mach_error_string(v23);
      _dispatch_log( "%u\t%p\tvoucher[%p]: kvoucher[0x%08x] decrement importance count to %u: %s - 0x%x",  v1,  v2,  v3,  v4,  v5,  v6,  v7,  764LL);
      mach_error_t v15 = v23;
      uint64_t v26 = v23;
      uint64_t v25 = 766LL;
      if (v23) {
        _dispatch_bug(v25, v26, v8, v9, v10, v11, v12, v13);
      }
      if (v15 == 5)
      {
        qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Voucher importance count underflow";
        qword_E4DA8 = v23;
        __break(1u);
        JUMPOUT(0x96680LL);
      }
    }
  }

_DWORD *_voucher_remove(_DWORD *result)
{
  uint64_t v13 = result;
  int v12 = result[9];
  if (*((void *)result + 3))
  {
    unsigned int v14 = _dispatch_thread_getspecific(3uLL) & 0xFFFFFFFC;
    do
      unsigned int v1 = __ldaxr((unsigned int *)&_voucher_hash_lock);
    while (!v1 && __stlxr(v14, (unsigned int *)&_voucher_hash_lock));
    if (v1) {
      _dispatch_unfair_lock_lock_slow((unsigned int *)&_voucher_hash_lock, 0x10000);
    }
    if (!v12)
    {
      _dispatch_thread_getspecific(0LL);
      _dispatch_log("%u\t%p\tvoucher[%p]: corruption", v2, v3, v4, v5, v6, v7, v8, 282LL);
      qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Voucher corruption";
      __break(1u);
      JUMPOUT(0x96828LL);
    }

    if ((int)v13[3] <= 0 && *((void *)v13 + 3))
    {
      uint64_t v16 = *((void *)v13 + 2);
      uint64_t v15 = *((void *)v13 + 3);
      if (v16 != -1) {
        *(void *)(23 - v16) = v15;
      }
      *(void *)~uint64_t v15 = v16;
      *((void *)v13 + 3) = 0LL;
      *((void *)v13 + 2) = -1985229329LL;
    }

    uint64_t result = _dispatch_thread_getspecific(3uLL);
    int v11 = _voucher_hash_lock;
    do
    {
      int v9 = v11;
      do
        unsigned int v10 = __ldaxr((unsigned int *)&_voucher_hash_lock);
      while (v10 == v11 && __stlxr(0, (unsigned int *)&_voucher_hash_lock));
      int v11 = v10;
    }

    while (v10 != v9);
  }

  return result;
}

void _voucher_activity_debug_channel_init()
{
  kern_return_t v8;
  mach_port_t special_port;
  uint64_t f;
  uint64_t v11;
  int v11 = 0LL;
  if (_voucher_libtrace_hooks) {
    int v11 = *(void *)(_voucher_libtrace_hooks + 16);
  }
  if (v11)
  {
    f = 0LL;
    special_mach_port_t port = 0;
    uint64_t v8 = task_get_special_port(mach_task_self_, 10, &special_port);
    if (v8 == -301)
    {
      qword_E4D78 = (uint64_t)"MIG_REPLY_MISMATCH";
      qword_E4DA8 = -301LL;
      __break(1u);
      JUMPOUT(0x96B28LL);
    }

    if (v8)
    {
      qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Couldn't get debug control port";
      qword_E4DA8 = v8;
      __break(1u);
      JUMPOUT(0x96B78LL);
    }

    if (special_port)
    {
      f = dispatch_mach_create_f((uint64_t)"com.apple.debug-channel", 0LL, 0LL, v11, v0, v1, v2, v3);
      *(_BYTE *)(*(void *)(f + 88) + 29LL) &= ~0x20u;
      dispatch_mach_connect(f, special_port, 0LL, 0LL, v4, v5, v6, v7);
      _voucher_activity_debug_channel = f;
    }
  }

uint64_t _voucher_atfork_prepare()
{
  uint64_t result = (uint64_t)_dispatch_thread_getspecific(3uLL);
  do
    unsigned int v1 = __ldaxr((unsigned int *)&_voucher_hash_lock);
  while (!v1 && __stlxr(result & 0xFFFFFFFC, (unsigned int *)&_voucher_hash_lock));
  if (v1) {
    return _dispatch_unfair_lock_lock_slow((unsigned int *)&_voucher_hash_lock, 0x10000);
  }
  return result;
}

void *_voucher_atfork_parent()
{
  uint64_t result = _dispatch_thread_getspecific(3uLL);
  int v3 = _voucher_hash_lock;
  do
  {
    int v1 = v3;
    do
      unsigned int v2 = __ldaxr((unsigned int *)&_voucher_hash_lock);
    while (v2 == v3 && __stlxr(0, (unsigned int *)&_voucher_hash_lock));
    int v3 = v2;
  }

  while (v2 != v1);
  return result;
}

uint64_t _voucher_atfork_child()
{
  _voucher_hash_locuint64_t k = 0;
  uint64_t result = _dispatch_thread_setspecific(28LL, 0LL);
  _voucher_task_mach_voucher_pred = 0LL;
  _voucher_task_int mach_voucher = 0;
  _voucher_default_task_int mach_voucher = 0;
  _voucher_aid_next = 0LL;
  _firehose_task_buffer_pred = 0LL;
  _firehose_task_buffer = 0LL;
  return result;
}

void *_voucher_hash_reset_locked()
{
  for (unsigned int i = 0; i < 0x40; ++i)
  {
    unsigned int v2 = (void *)((char *)&_voucher_hash + 8 * i);
    while (1)
    {
      uint64_t v1 = ~*v2;
      if (*v2 == -1LL) {
        break;
      }
      *(_DWORD *)(31LL - *v2) = 0;
      *(_DWORD *)(v1 + 36) = 0;
      uint64_t v5 = ~*(void *)(v1 + 16);
      uint64_t v4 = *(void *)(v1 + 24);
      if (*(void *)(v1 + 16) != -1LL) {
        *(void *)(23LL - *(void *)(v1 + free(*(void **)(v0 - 16)) = v4;
      }
      *(void *)~uint64_t v4 = ~v5;
      *(void *)(v1 + 24) = 0LL;
      *(void *)(v1 + 16) = -1985229329LL;
    }
  }

  return memset(&_voucher_hash, -1, 0x200uLL);
}

uint64_t voucher_process_can_use_arbitrary_personas()
{
  if (_voucher_process_can_use_arbitrary_personas_pred != -1) {
    dispatch_once_f( &_voucher_process_can_use_arbitrary_personas_pred,  0LL,  (dispatch_function_t)_voucher_process_can_use_arbitrary_personas_init);
  }
  return _voucher_process_can_use_arbitrary_personas & 1;
}

uint64_t _voucher_process_can_use_arbitrary_personas_init(uint64_t a1)
{
  uint64_t v7 = a1;
  ipc_voucher_t voucher = 0;
  unsigned int v10 = &_voucher_task_mach_voucher_pred;
  int v9 = 0LL;
  dispatch_function_t v8 = (dispatch_function_t)_voucher_task_mach_voucher_init;
  if (_voucher_task_mach_voucher_pred != -1) {
    dispatch_once_f(v10, v9, v8);
  }
  ipc_voucher_t voucher = _voucher_task_mach_voucher;
  int v5 = 0;
  int v2 = 0;
  mach_voucher_attr_content_t out_content = (mach_voucher_attr_content_t)&v2;
  mach_msg_type_number_t out_contentCnt = 4;
  uint64_t result = mach_voucher_attr_command( _voucher_task_mach_voucher,  3u,  4u,  0LL,  0,  (mach_voucher_attr_content_t)&v2,  &out_contentCnt);
  int v5 = result;
  if ((_DWORD)result)
  {
    qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: mach_voucher_attr_command(BANK_PERSONA_ADOPT_ANY) failed";
    qword_E4DA8 = v5;
    __break(1u);
    JUMPOUT(0x97168LL);
  }

  _voucher_process_can_use_arbitrary_personas = v2 != 0;
  return result;
}

uint64_t voucher_copy_with_persona_mach_voucher(unsigned int a1)
{
  unsigned int v39 = a1;
  if (!a1) {
    return (uint64_t)voucher_copy();
  }
  int v38 = 0;
  int v37 = 0;
  ipc_voucher_t v36 = 0;
  unsigned int v35 = _dispatch_thread_getspecific(0x1CuLL);
  if (v35)
  {
    if (v35[9]) {
      int v30 = v35[9];
    }
    else {
      int v30 = v35[8];
    }
    int v37 = v30;
  }

  v51[0] = -1;
  v51[1] = 1;
  void v51[2] = v37;
  v51[3] = 0;
  v51[4] = 3;
  v51[5] = 10;
  uint64_t v52 = v39;
  int v38 = _voucher_create_mach_voucher((uint8_t *)v51, 32LL, &v36);
  int v34 = v38;
  uint64_t v43 = v38;
  uint64_t v42 = 944LL;
  if (v38) {
    _dispatch_bug(v42, v43, v1, v2, v3, v4, v5, v6);
  }
  if (v34)
  {
    if (v38 == 20) {
      return -1LL;
    }
    ipc_voucher_t v36 = 0;
  }

  if (v36 == v37)
  {
    if (v36) {
      _voucher_dealloc_mach_voucher(v36);
    }
    uint64_t v41 = v35;
    os_retain(v35);
    return (uint64_t)v41;
  }

  else
  {
    uint64_t v32 = _voucher_find_and_retain(v36);
    if (v32 && (!v35 || v35[9]))
    {
      _dispatch_thread_getspecific(0LL);
      _dispatch_log( "%u\t%p\tvoucher[%p]: kvoucher[0x%08x] find with persona from voucher[%p]",  v14,  v15,  v16,  v17,  v18,  v19,  v20,  958LL);
      _voucher_dealloc_mach_voucher(v36);
      return v32;
    }

    else
    {
      uint64_t v31 = v32;
      uint64_t v49 = v35;
      __int16 v48 = 1;
      unsigned int v47 = 0;
      __int16 v46 = 0LL;
      if (v35) {
        unsigned int v47 = 0;
      }
      __int16 v46 = _voucher_alloc(v47, v7, v8, v9, v10, v11, v12, v13);
      if (v49)
      {
        __int16 v45 = ~v48;
        if ((v48 & 1) == 0 && v49[8])
        {
          uint64_t v44 = 0LL;
          if (*((void *)v49 + 5)) {
            uint64_t v29 = (_DWORD *)*((void *)v49 + 5);
          }
          else {
            uint64_t v29 = v49;
          }
          uint64_t v44 = v29;
          uint64_t v50 = v29;
          os_retain(v29);
          v46[5] = v50;
          *((_DWORD *)v46 + 8) = v44[8];
          *((_BYTE *)v46 + 72) = v46[9] & 0xFE | v44[18] & 1;
        }

        if ((v45 & 2) != 0)
        {
          v46[6] = *((void *)v49 + 6);
          v46[7] = *((void *)v49 + 7);
          v46[8] = *((void *)v49 + 8);
        }
      }

      uint64_t v33 = v46;
      *((_DWORD *)v46 + 8) = v36;
      if (v35 && !v35[9])
      {
        if (v31)
        {
          v33[5] = v31;
          _voucher_dealloc_mach_voucher(v36);
        }
      }

      else
      {
        *((_DWORD *)v33 + 9) = v36;
        _voucher_insert(v33);
      }

      if (!v31)
      {
        _dispatch_thread_getspecific(0LL);
        _dispatch_log( "%u\t%p\tvoucher[%p]: kvoucher[0x%08x] create with persona from voucher[%p]",  v21,  v22,  v23,  v24,  v25,  v26,  v27,  975LL);
      }

      return (uint64_t)v33;
    }
  }

uint64_t mach_voucher_persona_self(_DWORD *a1)
{
  uint64_t v10 = a1;
  ipc_voucher_t v9 = 0;
  v13[0] = xmmword_C2A98;
  v13[1] = xmmword_C2AA8;
  unsigned int v8 = _voucher_create_mach_voucher((uint8_t *)v13, 32LL, &v9);
  uint64_t v12 = (int)v8;
  uint64_t v11 = 1000LL;
  if (v8)
  {
    _dispatch_bug(v11, v12, v1, v2, v3, v4, v5, v6);
    ipc_voucher_t v9 = 0;
  }

  _DWORD *v10 = v9;
  return v8;
}

uint64_t mach_voucher_persona_for_originator(unsigned int a1, unsigned int a2, uint64_t a3, _DWORD *a4)
{
  unsigned int v23 = a1;
  unsigned int v22 = a2;
  uint64_t v21 = a3;
  uint64_t v20 = a4;
  uint64_t v12 = (ipc_voucher_t *)&v19;
  unsigned int v9 = 0;
  int v19 = 0;
  unsigned int mach_voucher = 46;
  uint64_t v10 = v17;
  v17[0] = a1;
  v17[1] = a3;
  uint64_t v16 = 48LL;
  uint64_t v15 = 0LL;
  unsigned int v8 = v7;
  bzero(v7, 0x30uLL);
  uint64_t v15 = v8;
  uint64_t v11 = -1LL;
  __memset_chk(v8, v9, v16, -1LL);
  uint64_t v4 = v10;
  uint64_t v5 = v11;
  *(void *)&__int128 v14 = 0x100000003LL;
  *((void *)&v14 + _dispatch_source_set_handler((uint64_t)source, handler, 2LL, 1) = v22;
  *(_OWORD *)uint64_t v15 = v14;
  *(void *)&__int128 v13 = 0x26300000003LL;
  *((void *)&v13 + _dispatch_source_set_handler((uint64_t)source, handler, 2LL, 1) = 0x1000000000LL;
  *((_OWORD *)v15 + _dispatch_source_set_handler((uint64_t)source, handler, 2LL, 1) = v13;
  uint64_t v26 = v15 + 32;
  uint64_t v25 = v4;
  uint64_t v24 = 16LL;
  __memcpy_chk(v15 + 32, v4, 16LL, v5);
  unsigned int mach_voucher = _voucher_create_mach_voucher(v15, v16, v12);
  if (mach_voucher) {
    int v19 = 0;
  }
  *uint64_t v20 = v19;
  return mach_voucher;
}

uint64_t voucher_get_current_persona()
{
  unsigned int v8 = -1;
  if (_voucher_get_current_persona_id((uint8_t *)&v8))
  {
    if ((int)kpersona_get(&v8) < 0)
    {
      uint64_t v12 = 1LL;
      uint64_t v13 = 1LL;
      unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
      int v7 = **(_DWORD **)(StatusReg + 8);
      if (v7 != 3)
      {
        uint64_t v11 = v7;
        uint64_t v10 = 1126LL;
        if (v7) {
          _dispatch_bug(v10, v11, v0, v1, v2, v3, v4, v5);
        }
      }
    }

    return v8;
  }

  else
  {
    return v8;
  }

uint64_t _voucher_get_current_persona_id(uint8_t *a1)
{
  kern_return_t v15;
  mach_voucher_attr_content_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v16 = a1;
  uint64_t v15 = 5;
  __int128 v14 = _dispatch_thread_getspecific(0x1CuLL);
  if (v14 && v14[8])
  {
    ipc_voucher_t v13 = 0;
    if (v14[9]) {
      ipc_voucher_t v8 = v14[9];
    }
    else {
      ipc_voucher_t v8 = v14[8];
    }
    ipc_voucher_t v13 = v8;
    mach_voucher_attr_content_t in_content = 0LL;
    mach_msg_type_number_t in_contentCnt = 0;
    mach_voucher_attr_content_t out_content = v16;
    mach_msg_type_number_t out_contentCnt = 4;
    uint64_t v15 = mach_voucher_attr_command(v8, 3u, 3u, 0LL, 0, v16, &out_contentCnt);
    if (v15 != 46 && v15 != 18 && v15 != 4)
    {
      uint64_t v18 = v15;
      uint64_t v17 = 1103LL;
      if (v15) {
        _dispatch_bug(v17, v18, v1, v2, v3, v4, v5, v6);
      }
    }
  }

  return v15;
}

uint64_t voucher_get_current_persona_originator_info(void *a1)
{
  if (_voucher_get_current_persona_token(__b))
  {
    return -1;
  }

  else
  {
    memcpy(a1, __b, 0x30uLL);
    return 0;
  }

uint64_t _voucher_get_current_persona_token(uint8_t *a1)
{
  kern_return_t v15;
  mach_voucher_attr_content_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v16 = a1;
  uint64_t v15 = 5;
  __int128 v14 = _dispatch_thread_getspecific(0x1CuLL);
  if (v14 && v14[8])
  {
    ipc_voucher_t v13 = 0;
    if (v14[9]) {
      ipc_voucher_t v8 = v14[9];
    }
    else {
      ipc_voucher_t v8 = v14[8];
    }
    ipc_voucher_t v13 = v8;
    mach_voucher_attr_content_t in_content = 0LL;
    mach_msg_type_number_t in_contentCnt = 0;
    mach_voucher_attr_content_t out_content = v16;
    mach_msg_type_number_t out_contentCnt = 96;
    uint64_t v15 = mach_voucher_attr_command(v8, 3u, 2u, 0LL, 0, v16, &out_contentCnt);
    if (v15 != 46 && v15 != 18 && v15 != 4)
    {
      uint64_t v18 = v15;
      uint64_t v17 = 1075LL;
      if (v15) {
        _dispatch_bug(v17, v18, v1, v2, v3, v4, v5, v6);
      }
    }
  }

  return v15;
}

uint64_t voucher_get_current_persona_proximate_info(void *a1)
{
  if (_voucher_get_current_persona_token(__b))
  {
    return -1;
  }

  else
  {
    memcpy(a1, &__b[48], 0x30uLL);
    return 0;
  }

BOOLean_t voucher_mach_msg_set(mach_msg_header_t *msg)
{
  uint64_t v10 = _dispatch_thread_getspecific(0x1CuLL);
  if ((msg->msgh_bits & 0x1F0000) >> 16)
  {
    char v12 = 0;
  }

  else
  {
    if (v10)
    {
      mach_port_name_t mach_voucher = _voucher_get_mach_voucher((uint64_t)v10);
    }

    else
    {
      if (_voucher_task_mach_voucher_pred != -1) {
        dispatch_once_f(&_voucher_task_mach_voucher_pred, 0LL, (dispatch_function_t)_voucher_task_mach_voucher_init);
      }
      mach_port_name_t mach_voucher = _voucher_task_mach_voucher;
    }

    if ((msg->msgh_bits & 0x1F0000) >> 16)
    {
      char v13 = 0;
    }

    else if (mach_voucher)
    {
      msg->msgh_voucher_mach_port_t port = mach_voucher;
      msg->msgh_bits |= 0x130000u;
      _dispatch_thread_getspecific(0LL);
      _dispatch_log("%u\t%p\tkvoucher[0x%08x]: msg[%p] set %s", v1, v2, v3, v4, v5, v6, v7, 476LL);
      char v13 = 1;
    }

    else
    {
      char v13 = 0;
    }

    char v12 = v13;
  }

  return v12 & 1;
}

void voucher_mach_msg_clear(mach_msg_header_t *msg)
{
  mach_msg_bits_t v9 = (msg->msgh_bits & 0x1F0000) >> 16;
  msgh_voucher_mach_port_t port = msg->msgh_voucher_port;
  if ((v9 == 19 || v9 == 17) && msgh_voucher_port)
  {
    _dispatch_thread_getspecific(0LL);
    _dispatch_log("%u\t%p\tkvoucher[0x%08x]: msg[%p] clear %s", v1, v2, v3, v4, v5, v6, v7, 520LL);
    if (v9 == 17) {
      _voucher_dealloc_mach_voucher(msgh_voucher_port);
    }
    msg->msgh_voucher_mach_port_t port = 0;
    msg->msgh_bits &= 0xFFE0FFFF;
  }

voucher_mach_msg_state_t voucher_mach_msg_adopt(mach_msg_header_t *msg)
{
  unsigned int v23 = msg;
  unsigned int v22 = 0;
  uint64_t v21 = 0LL;
  unsigned int v20 = 0;
  int v30 = msg;
  uint64_t v29 = &v22;
  if ((msg->msgh_bits & 0x1F0000) >> 16)
  {
    msgh_voucher_mach_port_t port = 0;
    msgh_voucher_mach_port_t port = v30->msgh_voucher_port;
    v30->msgh_voucher_mach_port_t port = 0;
    int v27 = 538902528;
    *uint64_t v29 = v30->msgh_bits & 0x201F0000;
    v30->msgh_bits &= ~v27;
    unsigned int v31 = msgh_voucher_port;
  }

  else
  {
    *uint64_t v29 = 0;
    unsigned int v31 = 0;
  }

  unsigned int v19 = v31;
  if (!v31) {
    return (voucher_mach_msg_state_t)-1LL;
  }
  uint64_t v18 = (unsigned int *)_dispatch_thread_getspecific(0x7BuLL);
  if (v18)
  {
    int v17 = *v18;
    if (*v18 >= 8uLL)
    {
      unsigned int v20 = v17 - 8;
      if (v17 == 8) {
        uint64_t v16 = 0LL;
      }
      else {
        uint64_t v16 = v18 + 2;
      }
      uint64_t v21 = (uint64_t)v16;
    }
  }

  uint64_t v26 = (voucher_mach_msg_state_s *)_voucher_create_with_mach_voucher(v19, v22, v21, v20, v1, v2, v3, v4);
  uint64_t v25 = 0LL;
  uint64_t v25 = (voucher_mach_msg_state_s *)_dispatch_thread_getspecific(0x1CuLL);
  uint64_t v40 = v25;
  unsigned int v39 = v26;
  if (v25 == v26)
  {
    unsigned int v41 = -1;
  }

  else
  {
    if (v40)
    {
      int v38 = 0;
      int v37 = 0;
    }

    _dispatch_thread_setspecific(28LL, (uint64_t)v39);
    if (v39)
    {
      int v36 = 0;
      int v35 = 0;
    }

    _dispatch_thread_getspecific(0LL);
    _dispatch_log("%u\t%p\tvoucher[%p]: swap from voucher[%p]", v5, v6, v7, v8, v9, v10, v11, 400LL);
    int v34 = 0;
    if (v39) {
      int v15 = *((_DWORD *)v39 + 8);
    }
    else {
      int v15 = 0;
    }
    int v34 = v15;
    int v33 = 0;
    if (v40) {
      int v14 = *((_DWORD *)v40 + 8);
    }
    else {
      int v14 = 0;
    }
    int v33 = v14;
    if (v34 == v14) {
      int v13 = -1;
    }
    else {
      int v13 = v34;
    }
    unsigned int v41 = v13;
  }

  unsigned int v32 = v41;
  if (v41 != -1) {
    _dispatch_set_priority_and_mach_voucher_slow(0LL, v32);
  }
  return v25;
}

void voucher_mach_msg_revert(voucher_mach_msg_state_t state)
{
  if (state != (voucher_mach_msg_state_t)-1LL)
  {
    char v12 = _dispatch_thread_getspecific(0x1CuLL);
    if (v12 == (_DWORD *)state)
    {
      unsigned int v13 = -1;
    }

    else
    {
      _dispatch_thread_setspecific(28LL, (uint64_t)state);
      _dispatch_thread_getspecific(0LL);
      _dispatch_log("%u\t%p\tvoucher[%p]: swap from voucher[%p]", v1, v2, v3, v4, v5, v6, v7, 400LL);
      if (state) {
        int v10 = *((_DWORD *)state + 8);
      }
      else {
        int v10 = 0;
      }
      if (v12) {
        int v9 = v12[8];
      }
      else {
        int v9 = 0;
      }
      if (v10 == v9) {
        int v8 = -1;
      }
      else {
        int v8 = v10;
      }
      unsigned int v13 = v8;
    }

    if (v13 != -1) {
      _dispatch_set_priority_and_mach_voucher_slow(0LL, v13);
    }
    if (v12) {
      os_release(v12);
    }
  }

uint64_t *voucher_activity_initialize_4libtrace(uint64_t *result)
{
  if (*result <= 2)
  {
    uint64_t v1 = *result;
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: unsupported vah_version";
    qword_E4DA8 = v1;
    __break(1u);
    JUMPOUT(0x98988LL);
  }

  do
    unint64_t v2 = __ldaxr((unint64_t *)&_voucher_libtrace_hooks);
  while (!v2 && __stlxr((unint64_t)result, (unint64_t *)&_voucher_libtrace_hooks));
  if (v2)
  {
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: voucher_activity_initialize_4libtrace called twice";
    qword_E4DA8 = _voucher_libtrace_hooks;
    __break(1u);
    JUMPOUT(0x98A7CLL);
  }

  return result;
}

uint64_t _voucher_init()
{
  return _voucher_libkernel_init();
}

uint64_t _voucher_libkernel_init()
{
  uint64_t result = __libkernel_voucher_init(&_voucher_libkernel_functions);
  if ((_DWORD)result) {
    _dispatch_abort(1262LL, (_DWORD)result == 0, v1, v2, v3, v4, v5, v6);
  }
  return result;
}

unint64_t voucher_activity_id_allocate(unsigned __int8 a1)
{
  while (1)
  {
    unint64_t v1 = _os_atomic_mo_has_acquire(0)
    unint64_t v5 = v1;
    unint64_t v4 = v1 + 1;
    if (!v1 || !(v4 % 0x10)) {
      break;
    }
    if (_os_atomic_mo_has_release(0)) {
      BOOL v3 = __stlxr(v4, (unint64_t *)&_voucher_aid_next) == 0;
    }
    else {
      BOOL v3 = __stxr(v4, (unint64_t *)&_voucher_aid_next) == 0;
    }
    if (v3) {
      return v5 & 0xFFFFFFFFFFFFFFLL | ((unint64_t)a1 << 56);
    }
  }

  __clrex();
  _voucher_activity_id_allocate_slow();
  return v5 & 0xFFFFFFFFFFFFFFLL | ((unint64_t)a1 << 56);
}

mach_vm_address_t voucher_activity_get_logging_preferences(mach_vm_size_t *a1)
{
  if (_firehose_task_buffer_pred != -1) {
    dispatch_once_f(&_firehose_task_buffer_pred, 0LL, (dispatch_function_t)_firehose_task_buffer_init);
  }
  BOOL v2 = 1;
  if (_firehose_task_buffer) {
    BOOL v2 = *(_DWORD *)(_firehose_task_buffer + 1552) == -1;
  }
  if (!v2) {
    return firehose_buffer_get_logging_prefs(_firehose_task_buffer, a1);
  }
  *a1 = 0LL;
  return 0LL;
}

BOOL voucher_activity_should_send_strings( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (_firehose_task_buffer_pred != -1) {
    dispatch_once_f(&_firehose_task_buffer_pred, 0LL, (dispatch_function_t)_firehose_task_buffer_init);
  }
  BOOL v9 = 1;
  if (_firehose_task_buffer) {
    BOOL v9 = *(_DWORD *)(_firehose_task_buffer + 1552) == -1;
  }
  return !v9 && firehose_buffer_should_send_strings(_firehose_task_buffer, a2, a3, a4, a5, a6, a7, a8);
}

uint64_t voucher_activity_get_metadata_buffer(void *a1)
{
  if (_firehose_task_buffer_pred != -1) {
    dispatch_once_f(&_firehose_task_buffer_pred, 0LL, (dispatch_function_t)_firehose_task_buffer_init);
  }
  BOOL v2 = 1;
  if (_firehose_task_buffer) {
    BOOL v2 = *(_DWORD *)(_firehose_task_buffer + 1552) == -1;
  }
  if (v2)
  {
    *a1 = 0LL;
    return 0LL;
  }

  else
  {
    uint64_t v3 = _firehose_task_buffer;
    *a1 = 2048LL;
    return v3 + 4096 - *a1;
  }

void *voucher_activity_create_with_data_2( unint64_t *a1, void *a2, uint64_t a3, uint64_t a4, unint64_t a5, int a6)
{
  uint64_t v78 = a1;
  uint64_t v77 = a2;
  uint64_t v76 = a3;
  uint64_t v75 = a4;
  unint64_t v74 = a5;
  int v73 = a6;
  unint64_t v72 = 0LL;
  uint64_t v71 = 0LL;
  uint64_t v70 = 0LL;
  unint64_t v69 = 0LL;
  unint64_t v69 = *a1;
  uint64_t v68 = 0LL;
  __int128 v66 = _dispatch_thread_getspecific(0x1CuLL);
  BOOL v64 = (v73 & 1) == 0;
  unsigned __int16 v13 = v74 + 8;
  BOOL v14 = v74 >= 0xFFFFFFFFFFFFFFF8LL;
  if (((v74 + 8) & 0xFFFFFFFFFFFF0000LL) != 0) {
    BOOL v14 = 1;
  }
  unsigned __int16 v67 = v74 + 8;
  BOOL v111 = v14;
  if (v14 || v13 >= 0x81u)
  {
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Absurd publen";
    qword_E4DA8 = v13;
    __break(1u);
    JUMPOUT(0x99094LL);
  }

  if (v77 == (void *)-3LL) {
    uint64_t v77 = v66;
  }
  WORD1(v69) &= ~0x10u;
  if (v66)
  {
    uint64_t v71 = v66[6];
    if (v71)
    {
      WORD1(v69) |= 1u;
      unsigned __int16 v67 = v74 + 16;
      uint64_t v68 = v66[7];
      if (v68)
      {
        WORD1(v69) |= 0x10u;
        unsigned __int16 v67 = v74 + 24;
      }
    }
  }

  if (v77) {
    uint64_t v70 = v77[6];
  }
  if (v70)
  {
    WORD1(v69) |= 0x200u;
    v67 += 8;
    v76 |= HIBYTE(v70);
  }

  if ((MEMORY[0xFFFFFC104] & 0x80) == 0) {
    v76 |= 0x80uLL;
  }
  uint64_t v84 = v77;
  __int16 v83 = 2;
  unsigned int v82 = 0;
  uint64_t v81 = 0LL;
  if (v77) {
    unsigned int v82 = 0;
  }
  uint64_t v81 = _voucher_alloc(v82, v6, v7, v8, v9, v10, v11, v12);
  if (v84)
  {
    __int16 v80 = ~v83;
    if (*((_DWORD *)v84 + 8))
    {
      BOOL v79 = 0LL;
      if (v84[5]) {
        uint64_t v59 = (_DWORD *)v84[5];
      }
      else {
        uint64_t v59 = v84;
      }
      BOOL v79 = v59;
      object = v59;
      os_retain(v59);
      v81[5] = v59;
      *((_DWORD *)v81 + 8) = v79[8];
      *((_BYTE *)v81 + 72) = v81[9] & 0xFE | v79[18] & 1;
    }

    if ((v80 & 2) != 0)
    {
      v81[6] = v84[6];
      v81[7] = v84[7];
      v81[8] = v84[8];
    }
  }

  uint64_t v65 = v81;
  uint64_t v106 = v76;
  unint64_t v105 = 0LL;
  unint64_t v104 = 0LL;
  BOOL v103 = 0;
  uint64_t v102 = (unint64_t *)&_voucher_aid_next;
  while (1)
  {
    unint64_t v15 = _os_atomic_mo_has_acquire(0) ? __ldaxr(v102) : __ldxr(v102);
    unint64_t v105 = v15;
    unint64_t v104 = v15 + 1;
    if (!v15 || (v104 & 0xF) == 0) {
      break;
    }
    if (_os_atomic_mo_has_release(0)) {
      BOOL v103 = __stlxr(v104, v102) == 0;
    }
    else {
      BOOL v103 = __stxr(v104, v102) == 0;
    }
    if (v103) {
      goto LABEL_40;
    }
  }

  __clrex();
  _voucher_activity_id_allocate_slow();
LABEL_40:
  BOOL v101 = v103;
  unint64_t v72 = v105 & 0xFFFFFFFFFFFFFFLL | ((unint64_t)v106 << 56);
  v81[6] = v72;
  v65[7] = _voucher_unique_pid;
  v65[8] = v70;
  predicate = &_firehose_task_buffer_pred;
  context = 0LL;
  dispatch_function_t function = (dispatch_function_t)_firehose_task_buffer_init;
  if (_firehose_task_buffer_pred != -1) {
    dispatch_once_f(predicate, context, function);
  }
  uint64_t v107 = _firehose_task_buffer;
  BOOL v58 = 1;
  if (_firehose_task_buffer) {
    BOOL v58 = *(_DWORD *)(v107 + 1552) == -1;
  }
  if (!v58)
  {
    uint64_t v112 = v76;
    if ((MEMORY[0xFFFFFC104] & 0x80) != 0 && (v112 & 0x80) == 0) {
      uint64_t v113 = mach_continuous_approximate_time();
    }
    else {
      uint64_t v113 = mach_continuous_time();
    }
    uint64_t v62 = v113;
    for (unint64_t i = 0LL; i < 2; ++i)
    {
      if (voucher_activity_create_with_data_2_streams[i] == 3)
      {
        unsigned __int8 v16 = voucher_activity_create_with_data_2_streams[i];
        uint64_t v205 = (void *)_firehose_task_buffer;
        unint64_t v204 = v62;
        unsigned __int8 v203 = v16;
        unsigned __int16 v202 = v67;
        unsigned __int16 v201 = 0;
        uint64_t v200 = 0LL;
        char v199 = 1;
        unsigned int v198 = (unint64_t *)(_firehose_task_buffer + ((unint64_t)v16 << 7) + 640);
        unint64_t v197 = 0LL;
        unint64_t v196 = 0LL;
        int v195 = 0LL;
        char v194 = 0;
        BOOL v193 = 0;
        uint64_t v192 = 0LL;
        unsigned __int8 v191 = 0;
        unint64_t v190 = 0LL;
        unint64_t v189 = *v198;
        unint64_t v190 = v189;
        unint64_t v188 = v189;
        unint64_t v197 = v189;
        do
        {
          while (1)
          {
            while (1)
            {
              unint64_t v196 = v197;
              unsigned __int8 v191 = BYTE4(v197);
              BOOL v57 = 0;
              if (BYTE4(v197)) {
                BOOL v57 = v191 != 255;
              }
              if (v57)
              {
                int v216 = v205;
                unsigned __int8 v215 = v191;
                int v195 = &v205[512 * (unint64_t)v191];
                int v234 = v195;
                unint64_t v233 = v204;
                unsigned __int8 v232 = v203;
                unsigned __int8 v231 = 0;
                unsigned __int16 v230 = v202;
                unsigned __int16 v229 = v201;
                mach_port_name_t v228 = v200;
                __int16 v227 = 24;
                unint64_t v226 = 0LL;
                unint64_t v225 = 0LL;
                char v224 = 0;
                BOOL v223 = 0;
                BOOL v223 = (v204 - v195[1]) >> 48 == 0;
                BOOL v222 = 0;
                uint64_t v221 = v195;
                do
                {
                  if (_os_atomic_mo_has_acquire(0)) {
                    unint64_t v17 = __ldaxr(v221);
                  }
                  else {
                    unint64_t v17 = __ldxr(v221);
                  }
                  unint64_t v226 = v17;
                  if (!v17 || (HIWORD(v226) & 0x1FF) != (unint64_t)v232)
                  {
                    __clrex();
                    uint64_t v235 = 0LL;
                    goto LABEL_85;
                  }

                  unint64_t v225 = v226;
                  v314 = &v226;
                  unsigned __int16 v313 = v230 + v229 + 24;
                  if ((unsigned __int16)v226 + v313 <= WORD1(v226) && v223)
                  {
                    if ((((_BYTE)v230 + 24) & 7) != 0) {
                      int v56 = ((v230 + 24) & 0x1FFF8) + 8;
                    }
                    else {
                      int v56 = v230 + 24;
                    }
                    v225 += v56;
                    v225 -= (unint64_t)v229 << 16;
                    v225 += 0x100000000LL;
                    __int16 v220 = 16;
                    v312 = &v225;
                    __int16 v311 = 40;
                    char v224 = 0;
                  }

                  else
                  {
                    HIBYTE(v225) |= 1u;
                    char v224 = 1;
                  }

                  if (_os_atomic_mo_has_release(0)) {
                    BOOL v222 = __stlxr(v225, v221) == 0;
                  }
                  else {
                    BOOL v222 = __stxr(v225, v221) == 0;
                  }
                }

                while (!v222);
                BOOL v219 = v222;
                if ((v224 & 1) != 0)
                {
                  if (BYTE4(v225)) {
                    uint64_t v235 = 0LL;
                  }
                  else {
                    uint64_t v235 = -1LL;
                  }
                }

                else
                {
                  if (v228) {
                    *mach_port_name_t v228 = (char *)v234 + WORD1(v225);
                  }
                  uint64_t v235 = (unsigned __int16)v226;
                }

LABEL_85:
                uint64_t v192 = v235;
                if (v235 >= 1)
                {
                  uint64_t v187 = 0LL;
                  unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
                  uint64_t v187 = *(void *)(StatusReg - 8);
                  uint64_t v261 = v195;
                  unint64_t v260 = v204;
                  unsigned __int16 v259 = v202;
                  uint64_t v258 = v187;
                  uint64_t v257 = v192;
                  int v256 = (char *)v195 + v192;
                  unint64_t v260 = (v204 - v195[1]) | ((unint64_t)v202 << 48);
                  unint64_t v255 = v260;
                  *(unint64_t *)((char *)v195 + v192 + 16) = v260;
                  *((void *)v256 + _dispatch_source_set_handler((uint64_t)source, handler, 2LL, 1) = v258;
                  unsigned int v206 = v256;
                  goto LABEL_133;
                }

                if (v192 < 0) {
                  firehose_buffer_ring_enqueue((mach_port_context_t)v205, BYTE4(v197));
                }
                BYTE4(v196) = 0;
              }

              if ((v199 & 1) != 0 || ((v194 & 1) == 0 || (v197 & 0x400000000000LL) == 0) && !(BYTE5(v197) >> 7)) {
                break;
              }
              if ((BYTE5(v197) & 0x3Fu) + 1 > 0x3E) {
                char v55 = 63;
              }
              else {
                char v55 = (BYTE5(v197) & 0x3F) + 1;
              }
              BYTE5(v196) = BYTE5(v196) & 0xC0 | v55 & 0x3F;
              unint64_t v186 = v197;
              BOOL v185 = 0;
              uint64_t v18 = v198;
              unint64_t v183 = v196;
              unint64_t v182 = v196;
              unint64_t v184 = v196;
              unint64_t v19 = v197;
              unint64_t v20 = v196;
              do
                unint64_t v21 = __ldaxr(v18);
              while (v21 == v19 && __stlxr(v20, v18));
              if (v21 != v19) {
                unint64_t v186 = v21;
              }
              BOOL v181 = v21 == v19;
              BOOL v185 = v21 == v19;
              unint64_t v197 = v186;
              BOOL v180 = v185;
              BOOL v193 = v21 == v19;
              if (v21 == v19)
              {
                unsigned __int8 v275 = v203;
                unsigned __int8 v274 = v191;
                char v273 = v194 & 1;
                unint64_t v272 = v197;
                unint64_t v271 = v196;
                unint64_t v270 = v203 | ((unint64_t)v191 << 8);
                uint64_t v269 = v194 & 1;
                unsigned int v344 = 772145156;
                unint64_t v343 = v270;
                uint64_t v342 = v269;
                unint64_t v341 = v197;
                unint64_t v340 = v196;
                if (MEMORY[0xFFFFFC100]) {
                  kdebug_trace(v344, v343, v342, v341, v340);
                }
                unsigned int v206 = 0LL;
                goto LABEL_133;
              }
            }

            if (!(_DWORD)v197) {
              break;
            }
            if ((v199 & 1) != 0) {
              LODWORD(v196) = v196 | 1;
            }
            else {
              LODWORD(v196) = v196 | 2;
            }
            BOOL v179 = v196 == v197;
            BOOL v54 = 1;
            if (v196 != v197)
            {
              unint64_t v178 = v197;
              BOOL v177 = 0;
              unsigned int v22 = v198;
              unint64_t v175 = v196;
              unint64_t v174 = v196;
              unint64_t v176 = v196;
              unint64_t v23 = v197;
              unint64_t v24 = v196;
              do
                unint64_t v25 = __ldaxr(v22);
              while (v25 == v23 && __stlxr(v24, v22));
              if (v25 != v23) {
                unint64_t v178 = v25;
              }
              BOOL v173 = v25 == v23;
              BOOL v177 = v25 == v23;
              unint64_t v197 = v178;
              BOOL v172 = v177;
              BOOL v54 = v25 == v23;
            }

            BOOL v193 = v54;
            if (v54)
            {
              unsigned __int8 v290 = v203;
              unsigned __int8 v289 = v191;
              char v288 = v194 & 1;
              unint64_t v287 = v197;
              unint64_t v286 = v196;
              char v285 = v199 & 1;
              unint64_t v284 = v203 | ((unint64_t)v191 << 8);
              uint64_t v283 = v194 & 1 | (2LL * (v199 & 1));
              unsigned int v334 = 772145160;
              unint64_t v333 = v284;
              uint64_t v332 = v283;
              unint64_t v331 = v197;
              unint64_t v330 = v196;
              if (MEMORY[0xFFFFFC100]) {
                kdebug_trace(v334, v333, v332, v331, v330);
              }
              _dispatch_firehose_gate_wait((uint64_t)v198, v196, 0x10000);
              char v194 = 1;
              unint64_t v171 = 0LL;
              unint64_t v170 = *v198;
              unint64_t v171 = v170;
              unint64_t v169 = v170;
              unint64_t v197 = v170;
            }
          }

          unsigned int v214 = _dispatch_thread_getspecific(3uLL);
          LODWORD(v196) = v214 & 0xFFFFFFFC;
          unint64_t v168 = v197;
          BOOL v167 = 0;
          uint64_t v26 = v198;
          unint64_t v165 = v196;
          unint64_t v164 = v196;
          unint64_t v166 = v196;
          unint64_t v27 = v197;
          unint64_t v28 = v196;
          do
            unint64_t v29 = __ldaxr(v26);
          while (v29 == v27 && __stlxr(v28, v26));
          if (v29 != v27) {
            unint64_t v168 = v29;
          }
          BOOL v163 = v29 == v27;
          BOOL v167 = v29 == v27;
          unint64_t v197 = v168;
          BOOL v162 = v167;
          BOOL v193 = v29 == v27;
        }

        while (v29 != v27);
        unint64_t v160 = v204;
        LOWORD(v16_dispatch_source_set_handler((uint64_t)source, handler, 2LL, 1) = v202;
        WORD1(v16_dispatch_source_set_handler((uint64_t)source, handler, 2LL, 1) = v201;
        WORD2(v16_dispatch_source_set_handler((uint64_t)source, handler, 2LL, 1) = v203;
        HIWORD(v16_dispatch_source_set_handler((uint64_t)source, handler, 2LL, 1) = ((1LL << v203) & 0x13) != 0;
        BYTE6(v16_dispatch_source_set_handler((uint64_t)source, handler, 2LL, 1) = (((1LL << v203) & 0x13) != 0) | (2 * (*((_BYTE *)v205 + 1569) & 1));
        BYTE6(v16_dispatch_source_set_handler((uint64_t)source, handler, 2LL, 1) = BYTE6(v161) & 0xFB | (4 * (v199 & 1));
        unint64_t v302 = v204;
        uint64_t v301 = v161;
        unint64_t v300 = v197;
        unint64_t v299 = v196;
        unsigned int v324 = 772145164;
        unint64_t v323 = v204;
        uint64_t v322 = v161;
        unint64_t v321 = v197;
        unint64_t v320 = v196;
        if (MEMORY[0xFFFFFC100]) {
          kdebug_trace(v324, v323, v322, v321, v320);
        }
        unsigned int v206 = firehose_buffer_tracepoint_reserve_slow(v205, &v160, v200);
LABEL_133:
        uint64_t v63 = (unint64_t *)v206;
      }

      else
      {
        unsigned __int8 v30 = voucher_activity_create_with_data_2_streams[i];
        int v158 = (void *)_firehose_task_buffer;
        unint64_t v157 = v62;
        unsigned __int8 v156 = v30;
        unsigned __int16 v155 = v67;
        unsigned __int16 v154 = 0;
        v153[8] = 0;
        *(void *)unsigned int v153 = v64;
        unsigned int v152 = (unint64_t *)(_firehose_task_buffer + ((unint64_t)v30 << 7) + 640);
        unint64_t v151 = *(void *)&v153[1];
        unint64_t v150 = *(void *)&v153[1];
        BOOL v149 = *(unint64_t **)&v153[1];
        char v148 = 0;
        BOOL v147 = 0;
        uint64_t v146 = *(void *)&v153[1];
        unsigned __int8 v145 = 0;
        unint64_t v144 = *(void *)&v153[1];
        unint64_t v143 = *v152;
        unint64_t v144 = v143;
        unint64_t v142 = v143;
        unint64_t v151 = v143;
        do
        {
          while (1)
          {
            while (1)
            {
              unint64_t v150 = v151;
              unsigned __int8 v145 = BYTE4(v151);
              BOOL v53 = 0;
              if (BYTE4(v151)) {
                BOOL v53 = v145 != 255;
              }
              if (v53)
              {
                unsigned int v218 = v158;
                unsigned __int8 v217 = v145;
                BOOL v149 = &v158[512 * (unint64_t)v145];
                uint64_t v251 = v149;
                unint64_t v250 = v157;
                unsigned __int8 v249 = v156;
                unsigned __int8 v248 = 0;
                unsigned __int16 v247 = v155;
                unsigned __int16 v246 = v154;
                v245 = *(void **)&v153[1];
                __int16 v244 = 24;
                unint64_t v243 = 0LL;
                unint64_t v242 = 0LL;
                char v241 = 0;
                BOOL v240 = 0;
                BOOL v240 = (v157 - v149[1]) >> 48 == 0;
                BOOL v239 = 0;
                uint64_t v238 = v149;
                do
                {
                  if (_os_atomic_mo_has_acquire(0)) {
                    unint64_t v31 = __ldaxr(v238);
                  }
                  else {
                    unint64_t v31 = __ldxr(v238);
                  }
                  unint64_t v243 = v31;
                  if (!v31 || (HIWORD(v243) & 0x1FF) != (unint64_t)v249)
                  {
                    __clrex();
                    uint64_t v252 = 0LL;
                    goto LABEL_167;
                  }

                  unint64_t v242 = v243;
                  v310 = &v243;
                  unsigned __int16 v309 = v247 + v246 + 24;
                  if ((unsigned __int16)v243 + v309 <= WORD1(v243) && v240)
                  {
                    if ((((_BYTE)v247 + 24) & 7) != 0) {
                      int v52 = ((v247 + 24) & 0x1FFF8) + 8;
                    }
                    else {
                      int v52 = v247 + 24;
                    }
                    v242 += v52;
                    v242 -= (unint64_t)v246 << 16;
                    v242 += 0x100000000LL;
                    __int16 v237 = 16;
                    v308 = &v242;
                    __int16 v307 = 40;
                    char v241 = 0;
                  }

                  else
                  {
                    HIBYTE(v242) |= 1u;
                    char v241 = 1;
                  }

                  if (_os_atomic_mo_has_release(0)) {
                    BOOL v239 = __stlxr(v242, v238) == 0;
                  }
                  else {
                    BOOL v239 = __stxr(v242, v238) == 0;
                  }
                }

                while (!v239);
                BOOL v236 = v239;
                if ((v241 & 1) != 0)
                {
                  if (BYTE4(v242)) {
                    uint64_t v252 = 0LL;
                  }
                  else {
                    uint64_t v252 = -1LL;
                  }
                }

                else
                {
                  if (v245) {
                    void *v245 = (char *)v251 + WORD1(v242);
                  }
                  uint64_t v252 = (unsigned __int16)v243;
                }

LABEL_167:
                uint64_t v146 = v252;
                if (v252 >= 1)
                {
                  uint64_t v141 = 0LL;
                  unint64_t v254 = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
                  uint64_t v141 = *(void *)(v254 - 8);
                  unsigned int v268 = v149;
                  unint64_t v267 = v157;
                  unsigned __int16 v266 = v155;
                  uint64_t v265 = v141;
                  uint64_t v264 = v146;
                  char v263 = (char *)v149 + v146;
                  unint64_t v267 = (v157 - v149[1]) | ((unint64_t)v155 << 48);
                  unint64_t v262 = v267;
                  *(unint64_t *)((char *)v149 + v146 + 16) = v267;
                  *((void *)v263 + _dispatch_source_set_handler((uint64_t)source, handler, 2LL, 1) = v265;
                  unsigned int v159 = v263;
                  goto LABEL_215;
                }

                if (v146 < 0) {
                  firehose_buffer_ring_enqueue((mach_port_context_t)v158, BYTE4(v151));
                }
                BYTE4(v15_dispatch_source_set_handler((uint64_t)source, handler, 2LL, 0) = 0;
              }

              if ((v153[0] & 1) != 0 || ((v148 & 1) == 0 || (v151 & 0x400000000000LL) == 0) && !(BYTE5(v151) >> 7)) {
                break;
              }
              if ((BYTE5(v151) & 0x3Fu) + 1 > 0x3E) {
                char v51 = 63;
              }
              else {
                char v51 = (BYTE5(v151) & 0x3F) + 1;
              }
              BYTE5(v15_dispatch_source_set_handler((uint64_t)source, handler, 2LL, 0) = BYTE5(v150) & 0xC0 | v51 & 0x3F;
              unint64_t v140 = v151;
              BOOL v139 = 0;
              unsigned int v32 = v152;
              unint64_t v137 = v150;
              unint64_t v136 = v150;
              unint64_t v138 = v150;
              unint64_t v33 = v151;
              unint64_t v34 = v150;
              do
                unint64_t v35 = __ldaxr(v32);
              while (v35 == v33 && __stlxr(v34, v32));
              if (v35 != v33) {
                unint64_t v140 = v35;
              }
              BOOL v135 = v35 == v33;
              BOOL v139 = v35 == v33;
              unint64_t v151 = v140;
              BOOL v134 = v139;
              BOOL v147 = v35 == v33;
              if (v35 == v33)
              {
                unsigned __int8 v282 = v156;
                unsigned __int8 v281 = v145;
                char v280 = v148 & 1;
                unint64_t v279 = v151;
                unint64_t v278 = v150;
                unint64_t v277 = v156 | ((unint64_t)v145 << 8);
                uint64_t v276 = v148 & 1;
                unsigned int v339 = 772145156;
                unint64_t v338 = v277;
                uint64_t v337 = v276;
                unint64_t v336 = v151;
                unint64_t v335 = v150;
                if (MEMORY[0xFFFFFC100]) {
                  kdebug_trace(v339, v338, v337, v336, v335);
                }
                unsigned int v159 = 0LL;
                goto LABEL_215;
              }
            }

            if (!(_DWORD)v151) {
              break;
            }
            if ((v153[0] & 1) != 0) {
              LODWORD(v15_dispatch_source_set_handler((uint64_t)source, handler, 2LL, 0) = v150 | 1;
            }
            else {
              LODWORD(v15_dispatch_source_set_handler((uint64_t)source, handler, 2LL, 0) = v150 | 2;
            }
            BOOL v133 = v150 == v151;
            BOOL v50 = 1;
            if (v150 != v151)
            {
              unint64_t v132 = v151;
              BOOL v131 = 0;
              int v36 = v152;
              unint64_t v129 = v150;
              unint64_t v128 = v150;
              unint64_t v130 = v150;
              unint64_t v37 = v151;
              unint64_t v38 = v150;
              do
                unint64_t v39 = __ldaxr(v36);
              while (v39 == v37 && __stlxr(v38, v36));
              if (v39 != v37) {
                unint64_t v132 = v39;
              }
              BOOL v127 = v39 == v37;
              BOOL v131 = v39 == v37;
              unint64_t v151 = v132;
              BOOL v126 = v131;
              BOOL v50 = v39 == v37;
            }

            BOOL v147 = v50;
            if (v50)
            {
              unsigned __int8 v298 = v156;
              unsigned __int8 v297 = v145;
              char v296 = v148 & 1;
              unint64_t v295 = v151;
              unint64_t v294 = v150;
              char v293 = v153[0] & 1;
              unint64_t v292 = v156 | ((unint64_t)v145 << 8);
              uint64_t v291 = v148 & 1 | (2LL * (v153[0] & 1));
              unsigned int v329 = 772145160;
              unint64_t v328 = v292;
              uint64_t v327 = v291;
              unint64_t v326 = v151;
              unint64_t v325 = v150;
              if (MEMORY[0xFFFFFC100]) {
                kdebug_trace(v329, v328, v327, v326, v325);
              }
              _dispatch_firehose_gate_wait((uint64_t)v152, v150, 0x10000);
              char v148 = 1;
              unint64_t v125 = 0LL;
              unint64_t v124 = *v152;
              unint64_t v125 = v124;
              unint64_t v123 = v124;
              unint64_t v151 = v124;
            }
          }

          unsigned int v213 = _dispatch_thread_getspecific(3uLL);
          LODWORD(v15_dispatch_source_set_handler((uint64_t)source, handler, 2LL, 0) = v213 & 0xFFFFFFFC;
          unint64_t v122 = v151;
          BOOL v121 = 0;
          uint64_t v40 = v152;
          unint64_t v119 = v150;
          unint64_t v118 = v150;
          unint64_t v120 = v150;
          unint64_t v41 = v151;
          unint64_t v42 = v150;
          do
            unint64_t v43 = __ldaxr(v40);
          while (v43 == v41 && __stlxr(v42, v40));
          if (v43 != v41) {
            unint64_t v122 = v43;
          }
          BOOL v117 = v43 == v41;
          BOOL v121 = v43 == v41;
          unint64_t v151 = v122;
          BOOL v116 = v121;
          BOOL v147 = v43 == v41;
        }

        while (v43 != v41);
        unint64_t v114 = v157;
        LOWORD(v115) = v155;
        WORD1(v115) = v154;
        WORD2(v115) = v156;
        HIWORD(v115) = ((1LL << v156) & 0x13) != 0;
        BYTE6(v115) = (((1LL << v156) & 0x13) != 0) | (2 * (*((_BYTE *)v158 + 1569) & 1));
        BYTE6(v115) = BYTE6(v115) & 0xFB | (4 * (v153[0] & 1));
        unint64_t v306 = v157;
        uint64_t v305 = v115;
        unint64_t v304 = v151;
        unint64_t v303 = v150;
        unsigned int v319 = 772145164;
        unint64_t v318 = v157;
        uint64_t v317 = v115;
        unint64_t v316 = v151;
        unint64_t v315 = v150;
        if (MEMORY[0xFFFFFC100]) {
          kdebug_trace(v319, v318, v317, v316, v315);
        }
        unsigned int v159 = firehose_buffer_tracepoint_reserve_slow(v158, &v114, *(void **)&v153[1]);
LABEL_215:
        uint64_t v63 = (unint64_t *)v159;
      }

      if (v63)
      {
        uint64_t v60 = v63 + 3;
        if (v71)
        {
          uint64_t v100 = v63 + 3;
          uint64_t v99 = &v71;
          uint64_t v98 = 8LL;
          __memcpy_chk(v60, &v71, 8LL, -1LL);
          uint64_t v60 = &v100[(unint64_t)v98 / 8];
        }

        if (v68)
        {
          __int16 v97 = v60;
          uint64_t v96 = &v68;
          uint64_t v95 = 8LL;
          __memcpy_chk(v60, &v68, 8LL, -1LL);
          uint64_t v60 = &v97[(unint64_t)v95 / 8];
        }

        if (v70)
        {
          __int16 v94 = v60;
          uint64_t v93 = &v70;
          uint64_t v92 = 8LL;
          __memcpy_chk(v60, &v70, 8LL, -1LL);
          uint64_t v60 = &v94[(unint64_t)v92 / 8];
        }

        __int128 v91 = v60;
        uint64_t v90 = &v72;
        uint64_t v89 = 8LL;
        __memcpy_chk(v60, &v72, 8LL, -1LL);
        __int16 v88 = &v91[(unint64_t)v89 / 8];
        uint64_t v87 = v75;
        unint64_t v86 = v74;
        __memcpy_chk(&v91[(unint64_t)v89 / 8], v75, v74, -1LL);
        unint64_t v210 = v69;
        mach_port_context_t v209 = _firehose_task_buffer;
        int v208 = v63;
        uint64_t v212 = v63;
        unint64_t v211 = (unint64_t)v63 & 0xFFFFFFFFFFFFF000LL;
        unint64_t v207 = (unint64_t)v63 & 0xFFFFFFFFFFFFF000LL;
        unint64_t v351 = v69;
        v350 = (unint64_t *)((unint64_t)v63 & 0xFFFFFFFFFFFFF000LL);
        v349 = v63;
        unint64_t v348 = 0LL;
        unint64_t v347 = v69;
        atomic_store(v69, v63);
        __int16 v48 = v350;
        uint64_t v346 = 0x100000000LL;
        unint64_t v49 = *v350;
        do
        {
          unint64_t v44 = v49;
          do
            unint64_t v45 = __ldaxr(v48);
          while (v45 == v49 && __stlxr(v49 - 0x100000000LL, v48));
          unint64_t v49 = v45;
        }

        while (v45 != v44);
        unint64_t v345 = v45;
        unint64_t v348 = v45;
        char v47 = 0;
        if (BYTE4(v45) == 1) {
          char v47 = HIBYTE(v348) & 1;
        }
        if ((v47 & 1) != 0)
        {
          mach_port_context_t v353 = v209;
          unint64_t v352 = v207;
          firehose_buffer_ring_enqueue(v209, (v207 - v209) >> 12);
        }
      }
    }
  }

  *uint64_t v78 = v69;
  return v65;
}

void *voucher_activity_create_with_data( unint64_t *a1, void *a2, uint64_t a3, uint64_t a4, unint64_t a5)
{
  return voucher_activity_create_with_data_2(a1, a2, a3, a4, a5, 0);
}

void *voucher_activity_create_with_location(unint64_t *a1, void *a2, uint64_t a3, uint64_t a4)
{
  v5[3] = a1;
  v5[2] = a2;
  v5[1] = a3;
  v5[0] = a4;
  return voucher_activity_create_with_data(a1, a2, a3, (uint64_t)v5, 8uLL);
}

uint64_t voucher_get_activity_id_and_creator(void *a1, void *a2, void *a3)
{
  uint64_t v6 = a1;
  if (a1 == (void *)-3LL) {
    uint64_t v6 = _dispatch_thread_getspecific(0x1CuLL);
  }
  if (v6)
  {
    if (a2) {
      *a2 = v6[7];
    }
    if (a3) {
      *a3 = v6[8];
    }
    return v6[6];
  }

  else
  {
    if (a2) {
      *a2 = 0LL;
    }
    if (a3) {
      *a3 = 0LL;
    }
    return 0LL;
  }

uint64_t voucher_get_activity_id(void *a1, void *a2)
{
  return voucher_get_activity_id_and_creator(a1, 0LL, a2);
}

void voucher_activity_flush( unsigned __int8 a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (_firehose_task_buffer_pred != -1) {
    dispatch_once_f(&_firehose_task_buffer_pred, 0LL, (dispatch_function_t)_firehose_task_buffer_init);
  }
  BOOL v11 = 1;
  if (_firehose_task_buffer) {
    BOOL v11 = *(_DWORD *)(_firehose_task_buffer + 1552) == -1;
  }
  if (!v11)
  {
    mach_port_context_t v17 = _firehose_task_buffer;
    unsigned __int8 v16 = (unint64_t *)(_firehose_task_buffer + ((unint64_t)a1 << 7) + 640);
    unint64_t v15 = *v16;
    if (BYTE4(*v16) && BYTE4(v15) != 255)
    {
      unint64_t v31 = _firehose_task_buffer + ((unint64_t)BYTE4(v15) << 12);
      uint64_t v30 = -1LL;
      unsigned __int8 v29 = a1;
      unsigned __int8 v28 = 0;
      unsigned __int16 v27 = 1;
      unsigned __int16 v26 = 0;
      unint64_t v25 = 0LL;
      __int16 v24 = 24;
      unint64_t v23 = 0LL;
      unint64_t v22 = 0LL;
      BOOL v20 = (unint64_t)(-1LL - *(void *)(v31 + 8)) >> 48 == 0;
      uint64_t v18 = (unint64_t *)v31;
      do
      {
        if (_os_atomic_mo_has_acquire(0)) {
          unint64_t v8 = __ldaxr(v18);
        }
        else {
          unint64_t v8 = __ldxr(v18);
        }
        unint64_t v23 = v8;
        if (!v8 || (HIWORD(v23) & 0x1FF) != (unint64_t)v29)
        {
          __clrex();
          uint64_t v32 = 0LL;
          goto LABEL_38;
        }

        unint64_t v22 = v23;
        int v36 = &v23;
        unsigned __int16 v35 = v27 + v26 + 24;
        if ((unsigned __int16)v23 + v35 <= WORD1(v23) && v20)
        {
          if ((((_BYTE)v27 + 24) & 7) != 0) {
            int v10 = ((v27 + 24) & 0x1FFF8) + 8;
          }
          else {
            int v10 = v27 + 24;
          }
          v22 += v10;
          v22 -= (unint64_t)v26 << 16;
          v22 += 0x100000000LL;
          unint64_t v34 = &v22;
          __int16 v33 = 40;
          char v21 = 0;
        }

        else
        {
          HIBYTE(v22) |= 1u;
          char v21 = 1;
        }

        if (_os_atomic_mo_has_release(0)) {
          BOOL v19 = __stlxr(v22, v18) == 0;
        }
        else {
          BOOL v19 = __stxr(v22, v18) == 0;
        }
      }

      while (!v19);
      if ((v21 & 1) != 0)
      {
        if (BYTE4(v22)) {
          uint64_t v32 = 0LL;
        }
        else {
          uint64_t v32 = -1LL;
        }
      }

      else
      {
        if (v25) {
          *unint64_t v25 = v31 + WORD1(v22);
        }
        uint64_t v32 = (unsigned __int16)v23;
      }

unint64_t voucher_activity_trace_v_2( unsigned __int8 a1, unint64_t a2, unint64_t a3, uint64_t *a4, unint64_t a5, unint64_t a6, int a7)
{
  unsigned __int8 v64 = a1;
  unint64_t v63 = a2;
  unint64_t v62 = a3;
  mach_error_t v61 = a4;
  unint64_t v60 = a5;
  unint64_t v59 = a6;
  int v58 = a7;
  unint64_t v57 = a2;
  __int16 v56 = 24;
  uint64_t v55 = 4080LL;
  BOOL v54 = (a7 & 1) == 0;
  uint64_t v84 = &_firehose_task_buffer_pred;
  __int16 v83 = 0LL;
  unsigned int v82 = _firehose_task_buffer_init;
  if (_firehose_task_buffer_pred != -1) {
    dispatch_once_f(v84, v83, (dispatch_function_t)v82);
  }
  uint64_t v81 = _firehose_task_buffer;
  BOOL v43 = 1;
  if (_firehose_task_buffer) {
    BOOL v43 = *(_DWORD *)(v81 + 1552) == -1;
  }
  if (v43) {
    return 0LL;
  }
  BOOL v53 = 0LL;
  uint64_t v52 = 0LL;
  unint64_t v51 = 0LL;
  uint64_t v50 = 0LL;
  unint64_t v49 = 0LL;
  unint64_t v48 = v60;
  char v47 = _dispatch_thread_getspecific(0x1CuLL);
  uint64_t v46 = 0LL;
  BOOL v139 = v47;
  unint64_t v138 = &v46;
  if (&v46)
  {
    if (v139) {
      uint64_t v42 = v139[7];
    }
    else {
      uint64_t v42 = 0LL;
    }
    *unint64_t v138 = v42;
  }

  if (v139) {
    uint64_t v41 = v139[6];
  }
  else {
    uint64_t v41 = 0LL;
  }
  uint64_t v52 = v41;
  if (v41)
  {
    WORD1(v57) |= 1u;
    v48 += 8LL;
  }

  if ((v57 & 0x100000) != 0)
  {
    if (v46) {
      v48 += 8LL;
    }
    else {
      WORD1(v57) &= ~0x10u;
    }
  }

  else
  {
    uint64_t v46 = 0LL;
  }

  if (v59)
  {
    WORD1(v57) |= 0x100u;
    v48 += 4LL;
  }

  if (v48 + v59 + 24 >= 0xFF1)
  {
    uint64_t v45 = v48 + v59 + 24;
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Log is too large";
    qword_E4DA8 = v45;
    __break(1u);
    JUMPOUT(0x9BB50LL);
  }

  unint64_t v132 = (void *)_firehose_task_buffer;
  unint64_t v131 = v62;
  unsigned __int8 v130 = v64;
  unsigned __int16 v129 = v48;
  unsigned __int16 v128 = v59;
  BOOL v127 = &v50;
  BOOL v126 = v54;
  unint64_t v125 = (unint64_t *)(_firehose_task_buffer + ((unint64_t)v64 << 7) + 640);
  unint64_t v124 = 0LL;
  unint64_t v123 = 0LL;
  unint64_t v122 = 0LL;
  char v121 = 0;
  BOOL v120 = 0;
  uint64_t v119 = 0LL;
  unsigned __int8 v118 = 0;
  unint64_t v117 = 0LL;
  unint64_t v116 = *v125;
  unint64_t v117 = v116;
  unint64_t v115 = v116;
  unint64_t v124 = v116;
  do
  {
    while (1)
    {
      while (1)
      {
        unint64_t v123 = v124;
        unsigned __int8 v118 = BYTE4(v124);
        BOOL v40 = 0;
        if (BYTE4(v124)) {
          BOOL v40 = v118 != 255;
        }
        if (v40)
        {
          uint64_t v146 = v132;
          unsigned __int8 v145 = v118;
          unint64_t v122 = &v132[512 * (unint64_t)v118];
          BOOL v162 = v122;
          unint64_t v161 = v131;
          unsigned __int8 v160 = v130;
          unsigned __int8 v159 = 0;
          unsigned __int16 v158 = v129;
          unsigned __int16 v157 = v128;
          unsigned __int8 v156 = v127;
          __int16 v155 = 24;
          unint64_t v154 = 0LL;
          unint64_t v153 = 0LL;
          char v152 = 0;
          BOOL v151 = 0;
          BOOL v151 = (v131 - v122[1]) >> 48 == 0;
          BOOL v150 = 0;
          BOOL v149 = v122;
          do
          {
            if (_os_atomic_mo_has_acquire(0)) {
              unint64_t v7 = __ldaxr(v149);
            }
            else {
              unint64_t v7 = __ldxr(v149);
            }
            unint64_t v154 = v7;
            if (!v7 || (HIWORD(v154) & 0x1FF) != (unint64_t)v160)
            {
              __clrex();
              uint64_t v163 = 0LL;
              goto LABEL_59;
            }

            unint64_t v153 = v154;
            char v194 = &v154;
            unsigned __int16 v193 = v158 + v157 + 24;
            if ((unsigned __int16)v154 + v193 <= WORD1(v154) && v151)
            {
              if ((((_BYTE)v158 + 24) & 7) != 0) {
                int v39 = ((v158 + 24) & 0x1FFF8) + 8;
              }
              else {
                int v39 = v158 + 24;
              }
              v153 += v39;
              v153 -= (unint64_t)v157 << 16;
              v153 += 0x100000000LL;
              __int16 v148 = 16;
              uint64_t v192 = &v153;
              __int16 v191 = 40;
              char v152 = 0;
            }

            else
            {
              HIBYTE(v153) |= 1u;
              char v152 = 1;
            }

            if (_os_atomic_mo_has_release(0)) {
              BOOL v150 = __stlxr(v153, v149) == 0;
            }
            else {
              BOOL v150 = __stxr(v153, v149) == 0;
            }
          }

          while (!v150);
          BOOL v147 = v150;
          if ((v152 & 1) != 0)
          {
            if (BYTE4(v153)) {
              uint64_t v163 = 0LL;
            }
            else {
              uint64_t v163 = -1LL;
            }
          }

          else
          {
            if (v156) {
              uint64_t *v156 = (uint64_t)v162 + WORD1(v153);
            }
            uint64_t v163 = (unsigned __int16)v154;
          }

LABEL_59:
          uint64_t v119 = v163;
          if (v163 >= 1)
          {
            unint64_t v114 = 0LL;
            unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
            unint64_t v114 = *(void *)(StatusReg - 8);
            unint64_t v171 = v122;
            unint64_t v170 = v131;
            unsigned __int16 v169 = v129;
            unint64_t v168 = v114;
            uint64_t v167 = v119;
            unint64_t v166 = (unint64_t *)((char *)v122 + v119);
            unint64_t v170 = v131 - v122[1];
            v170 |= (unint64_t)v129 << 48;
            unint64_t v165 = v170;
            *(unint64_t *)((char *)v122 + v119 + 16) = v170;
            v166[1] = v168;
            BOOL v133 = v166;
            goto LABEL_107;
          }

          if (v119 < 0) {
            firehose_buffer_ring_enqueue((mach_port_context_t)v132, BYTE4(v124));
          }
          BYTE4(v123) = 0;
        }

        if (v126 || ((v121 & 1) == 0 || (v124 & 0x400000000000LL) == 0) && !(BYTE5(v124) >> 7)) {
          break;
        }
        if ((BYTE5(v124) & 0x3Fu) + 1 > 0x3E) {
          char v38 = 63;
        }
        else {
          char v38 = (BYTE5(v124) & 0x3F) + 1;
        }
        BYTE5(v123) = BYTE5(v123) & 0xC0 | v38 & 0x3F;
        unint64_t v113 = v124;
        BOOL v112 = 0;
        unint64_t v8 = v125;
        unint64_t v110 = v123;
        unint64_t v109 = v123;
        unint64_t v111 = v123;
        unint64_t v9 = v124;
        unint64_t v10 = v123;
        do
          unint64_t v11 = __ldaxr(v8);
        while (v11 == v9 && __stlxr(v10, v8));
        if (v11 != v9) {
          unint64_t v113 = v11;
        }
        BOOL v108 = v11 == v9;
        BOOL v112 = v11 == v9;
        unint64_t v124 = v113;
        BOOL v107 = v112;
        BOOL v120 = v11 == v9;
        if (v11 == v9)
        {
          unsigned __int8 v178 = v130;
          unsigned __int8 v177 = v118;
          char v176 = v121 & 1;
          unint64_t v175 = v124;
          unint64_t v174 = v123;
          unint64_t v173 = v130 | ((unint64_t)v118 << 8);
          uint64_t v172 = v121 & 1;
          unsigned int v209 = 772145156;
          unint64_t v208 = v173;
          uint64_t v207 = v172;
          unint64_t v206 = v124;
          unint64_t v205 = v123;
          if (MEMORY[0xFFFFFC100]) {
            kdebug_trace(v209, v208, v207, v206, v205);
          }
          BOOL v133 = 0LL;
          goto LABEL_107;
        }
      }

      if (!(_DWORD)v124) {
        break;
      }
      if (v126) {
        LODWORD(v123) = v123 | 1;
      }
      else {
        LODWORD(v123) = v123 | 2;
      }
      BOOL v106 = v123 == v124;
      BOOL v37 = 1;
      if (v123 != v124)
      {
        unint64_t v105 = v124;
        BOOL v104 = 0;
        uint64_t v12 = v125;
        unint64_t v102 = v123;
        unint64_t v101 = v123;
        unint64_t v103 = v123;
        unint64_t v13 = v124;
        unint64_t v14 = v123;
        do
          unint64_t v15 = __ldaxr(v12);
        while (v15 == v13 && __stlxr(v14, v12));
        if (v15 != v13) {
          unint64_t v105 = v15;
        }
        BOOL v100 = v15 == v13;
        BOOL v104 = v15 == v13;
        unint64_t v124 = v105;
        BOOL v99 = v104;
        BOOL v37 = v15 == v13;
      }

      BOOL v120 = v37;
      if (v37)
      {
        unsigned __int8 v186 = v130;
        unsigned __int8 v185 = v118;
        char v184 = v121 & 1;
        unint64_t v183 = v124;
        unint64_t v182 = v123;
        BOOL v181 = v126;
        unint64_t v180 = v130 | ((unint64_t)v118 << 8);
        uint64_t v179 = v121 & 1 | (2LL * v126);
        unsigned int v204 = 772145160;
        unint64_t v203 = v180;
        uint64_t v202 = v179;
        unint64_t v201 = v124;
        unint64_t v200 = v123;
        if (MEMORY[0xFFFFFC100]) {
          kdebug_trace(v204, v203, v202, v201, v200);
        }
        _dispatch_firehose_gate_wait((uint64_t)v125, v123, 0x10000);
        char v121 = 1;
        unint64_t v98 = 0LL;
        unint64_t v97 = *v125;
        unint64_t v98 = v97;
        unint64_t v96 = v97;
        unint64_t v124 = v97;
      }
    }

    unsigned int v144 = _dispatch_thread_getspecific(3uLL);
    LODWORD(v123) = v144 & 0xFFFFFFFC;
    unint64_t v95 = v124;
    BOOL v94 = 0;
    unsigned __int8 v16 = v125;
    unint64_t v92 = v123;
    unint64_t v91 = v123;
    unint64_t v93 = v123;
    unint64_t v17 = v124;
    unint64_t v18 = v123;
    do
      unint64_t v19 = __ldaxr(v16);
    while (v19 == v17 && __stlxr(v18, v16));
    if (v19 != v17) {
      unint64_t v95 = v19;
    }
    BOOL v90 = v19 == v17;
    BOOL v94 = v19 == v17;
    unint64_t v124 = v95;
    BOOL v89 = v94;
    BOOL v120 = v19 == v17;
  }

  while (v19 != v17);
  unint64_t v87 = v131;
  LOWORD(v88) = v129;
  WORD1(v88) = v128;
  WORD2(v88) = v130;
  HIWORD(v88) = ((1LL << v130) & 0x13) != 0;
  BYTE6(v88) = (((1LL << v130) & 0x13) != 0) | (2 * (*((_BYTE *)v132 + 1569) & 1));
  BYTE6(v88) = BYTE6(v88) & 0xFB | (4 * v126);
  unint64_t v190 = v131;
  uint64_t v189 = v88;
  unint64_t v188 = v124;
  unint64_t v187 = v123;
  unsigned int v199 = 772145164;
  unint64_t v198 = v131;
  uint64_t v197 = v88;
  unint64_t v196 = v124;
  unint64_t v195 = v123;
  if (MEMORY[0xFFFFFC100]) {
    kdebug_trace(v199, v198, v197, v196, v195);
  }
  BOOL v133 = (unint64_t *)firehose_buffer_tracepoint_reserve_slow(v132, &v87, v127);
LABEL_107:
  BOOL v53 = v133;
  if (!v133) {
    return 0LL;
  }
  unint64_t v49 = v53 + 3;
  if (v52)
  {
    __int16 v80 = v49;
    BOOL v79 = &v52;
    uint64_t v78 = 8LL;
    __memcpy_chk(v49, &v52, 8LL, -1LL);
    unint64_t v49 = &v80[(unint64_t)v78 / 8];
  }

  if (v46)
  {
    uint64_t v77 = v49;
    uint64_t v76 = &v46;
    uint64_t v75 = 8LL;
    __memcpy_chk(v49, &v46, 8LL, -1LL);
    unint64_t v49 = &v77[(unint64_t)v75 / 8];
  }

  if (v59)
  {
    unint64_t v143 = v53;
    unint64_t v142 = (unint64_t)v53 & 0xFFFFFFFFFFFFF000LL;
    unint64_t v51 = (unint64_t)v53 & 0xFFFFFFFFFFFFF000LL;
    v44[0] = v50 - ((unsigned __int16)v53 & 0xF000);
    v44[1] = v59;
    unint64_t v74 = v49;
    int v73 = v44;
    uint64_t v72 = 4LL;
    __memcpy_chk(v49, v44, 4LL, -1LL);
    unint64_t v49 = (unint64_t *)((char *)v74 + v72);
  }

  while (v60)
  {
    uint64_t v20 = *v61;
    uint64_t v21 = v61[1];
    uint64_t v71 = v49;
    uint64_t v70 = v20;
    uint64_t v69 = v21;
    __memcpy_chk(v49, v20, v21, -1LL);
    unint64_t v49 = (unint64_t *)((char *)v71 + v69);
    unint64_t v22 = v61[1];
    BOOL v23 = v60 >= v22;
    unint64_t v24 = v60 - v22;
    char v25 = !v23;
    unint64_t v60 = v24;
    char v86 = v25;
    if ((v25 & 1) != 0)
    {
      qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Invalid arguments";
      __break(1u);
      JUMPOUT(0x9C9D0LL);
    }

    v61 += 2;
  }

  while (v59)
  {
    uint64_t v26 = *v61;
    uint64_t v27 = v61[1];
    uint64_t v68 = v50;
    uint64_t v67 = v26;
    uint64_t v66 = v27;
    __memcpy_chk(v50, v26, v27, -1LL);
    uint64_t v50 = v68 + v66;
    unint64_t v28 = v61[1];
    BOOL v23 = v59 >= v28;
    unint64_t v29 = v59 - v28;
    char v30 = !v23;
    unint64_t v59 = v29;
    char v85 = v30;
    if ((v30 & 1) != 0)
    {
      qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Invalid arguments";
      __break(1u);
      JUMPOUT(0x9CA90LL);
    }

    v61 += 2;
  }

  unint64_t v137 = v57;
  uint64_t v136 = _firehose_task_buffer;
  BOOL v135 = v53;
  uint64_t v141 = v53;
  unint64_t v140 = (unint64_t)v53 & 0xFFFFFFFFFFFFF000LL;
  unint64_t v134 = (unint64_t)v53 & 0xFFFFFFFFFFFFF000LL;
  unint64_t v216 = v57;
  unsigned __int8 v215 = (unint64_t *)((unint64_t)v53 & 0xFFFFFFFFFFFFF000LL);
  unsigned int v214 = v53;
  unint64_t v213 = 0LL;
  unint64_t v212 = v57;
  atomic_store(v57, v53);
  unsigned __int16 v35 = v215;
  uint64_t v211 = 0x100000000LL;
  unint64_t v36 = *v215;
  do
  {
    unint64_t v31 = v36;
    do
      unint64_t v32 = __ldaxr(v35);
    while (v32 == v36 && __stlxr(v36 - 0x100000000LL, v35));
    unint64_t v36 = v32;
  }

  while (v32 != v31);
  unint64_t v210 = v32;
  unint64_t v213 = v32;
  char v34 = 0;
  if (BYTE4(v32) == 1) {
    char v34 = HIBYTE(v213) & 1;
  }
  if ((v34 & 1) != 0)
  {
    mach_port_context_t v218 = v136;
    unint64_t v217 = v134;
    firehose_buffer_ring_enqueue(v218, (v134 - v218) >> 12);
  }

  return v57;
}

unint64_t voucher_activity_trace_v( unsigned __int8 a1, unint64_t a2, unint64_t a3, uint64_t *a4, unint64_t a5, unint64_t a6)
{
  return voucher_activity_trace_v_2(a1, a2, a3, a4, a5, a6, 0);
}

unint64_t voucher_activity_trace( unsigned __int8 a1, unint64_t a2, unint64_t a3, uint64_t a4, unint64_t a5)
{
  unsigned __int8 v7 = a1;
  v6[5] = a2;
  v6[4] = a3;
  v6[3] = a4;
  v6[2] = a5;
  v6[0] = a4;
  v6[1] = a5;
  return voucher_activity_trace_v(a1, a2, a3, v6, a5, 0LL);
}

unint64_t format_recipe_detail( uint64_t a1, uint64_t a2, unint64_t a3, unint64_t a4, const char *a5, unint64_t a6)
{
  unint64_t v51 = a4;
  if (a5)
  {
    if (a3 <= a4) {
      size_t v38 = 0LL;
    }
    else {
      size_t v38 = a3 - a4;
    }
    int v48 = __snprintf_chk((char *)(a2 + a4), v38, 0, 0xFFFFFFFFFFFFFFFFLL, "%s", a5);
    if (v48 >= 0)
    {
      if (v48 <= v38) {
        size_t v36 = v48;
      }
      else {
        size_t v36 = v38;
      }
      size_t v37 = v36;
    }

    else
    {
      size_t v37 = 0LL;
    }

    v51 += v37;
  }

  if (a3 <= v51) {
    size_t v35 = 0LL;
  }
  else {
    size_t v35 = a3 - v51;
  }
  int v47 = __snprintf_chk((char *)(a2 + v51), v35, 0, 0xFFFFFFFFFFFFFFFFLL, "Key: %u, ", *(_DWORD *)a1);
  if (v47 >= 0)
  {
    if (v47 <= v35) {
      size_t v33 = v47;
    }
    else {
      size_t v33 = v35;
    }
    size_t v34 = v33;
  }

  else
  {
    size_t v34 = 0LL;
  }

  unint64_t v52 = v51 + v34;
  if (a3 <= v52) {
    size_t v32 = 0LL;
  }
  else {
    size_t v32 = a3 - v52;
  }
  int v46 = __snprintf_chk((char *)(a2 + v52), v32, 0, 0xFFFFFFFFFFFFFFFFLL, "Command: %u, ", *(_DWORD *)(a1 + 4));
  if (v46 >= 0)
  {
    if (v46 <= v32) {
      size_t v30 = v46;
    }
    else {
      size_t v30 = v32;
    }
    size_t v31 = v30;
  }

  else
  {
    size_t v31 = 0LL;
  }

  unint64_t v53 = v52 + v31;
  if (a3 <= v53) {
    size_t v29 = 0LL;
  }
  else {
    size_t v29 = a3 - v53;
  }
  int v45 = __snprintf_chk( (char *)(a2 + v53),  v29,  0,  0xFFFFFFFFFFFFFFFFLL,  "Previous voucher: 0x%x, ",  *(_DWORD *)(a1 + 8));
  if (v45 >= 0)
  {
    if (v45 <= v29) {
      size_t v27 = v45;
    }
    else {
      size_t v27 = v29;
    }
    size_t v28 = v27;
  }

  else
  {
    size_t v28 = 0LL;
  }

  unint64_t v54 = v53 + v28;
  if (a3 <= v54) {
    size_t v26 = 0LL;
  }
  else {
    size_t v26 = a3 - v54;
  }
  int v44 = __snprintf_chk((char *)(a2 + v54), v26, 0, 0xFFFFFFFFFFFFFFFFLL, "Content size: %u\n", *(_DWORD *)(a1 + 12));
  if (v44 >= 0)
  {
    if (v44 <= v26) {
      size_t v24 = v44;
    }
    else {
      size_t v24 = v26;
    }
    size_t v25 = v24;
  }

  else
  {
    size_t v25 = 0LL;
  }

  unint64_t v55 = v54 + v25;
  if (*(_DWORD *)a1 == 2)
  {
    if (a5)
    {
      if (a3 <= v55) {
        size_t v23 = 0LL;
      }
      else {
        size_t v23 = a3 - v55;
      }
      int v43 = __snprintf_chk((char *)(a2 + v55), v23, 0, 0xFFFFFFFFFFFFFFFFLL, "%s", a5);
      if (v43 >= 0)
      {
        if (v43 <= v23) {
          size_t v21 = v43;
        }
        else {
          size_t v21 = v23;
        }
        size_t v22 = v21;
      }

      else
      {
        size_t v22 = 0LL;
      }

      v55 += v22;
    }

    if (a3 <= v55) {
      size_t v20 = 0LL;
    }
    else {
      size_t v20 = a3 - v55;
    }
    int v42 = __snprintf_chk( (char *)(a2 + v55),  v20,  0,  0xFFFFFFFFFFFFFFFFLL,  "IMPORTANCE INFO: %s",  (const char *)(a1 + 16));
    if (v42 >= 0)
    {
      if (v42 <= v20) {
        size_t v18 = v42;
      }
      else {
        size_t v18 = v20;
      }
      size_t v19 = v18;
    }

    else
    {
      size_t v19 = 0LL;
    }

    unint64_t v56 = v55 + v19;
  }

  else if (*(_DWORD *)a1 == 3)
  {
    if (a5)
    {
      if (a3 <= v55) {
        size_t v17 = 0LL;
      }
      else {
        size_t v17 = a3 - v55;
      }
      int v41 = __snprintf_chk((char *)(a2 + v55), v17, 0, 0xFFFFFFFFFFFFFFFFLL, "%s", a5);
      if (v41 >= 0)
      {
        if (v41 <= v17) {
          size_t v15 = v41;
        }
        else {
          size_t v15 = v17;
        }
        size_t v16 = v15;
      }

      else
      {
        size_t v16 = 0LL;
      }

      v55 += v16;
    }

    if (a3 <= v55) {
      size_t v14 = 0LL;
    }
    else {
      size_t v14 = a3 - v55;
    }
    int v40 = __snprintf_chk( (char *)(a2 + v55),  v14,  0,  0xFFFFFFFFFFFFFFFFLL,  "RESOURCE ACCOUNTING INFO: %s",  (const char *)(a1 + 16));
    if (v40 >= 0)
    {
      if (v40 <= v14) {
        size_t v12 = v40;
      }
      else {
        size_t v12 = v14;
      }
      size_t v13 = v12;
    }

    else
    {
      size_t v13 = 0LL;
    }

    unint64_t v56 = v55 + v13;
  }

  else
  {
    uint64_t v11 = a1 + 16;
    else {
      unint64_t v6 = format_hex_data(a5, "Recipe Contents", v11, *(unsigned int *)(a1 + 12), a2, a3, v55);
    }
    unint64_t v56 = v6;
  }

  if (*(_BYTE *)(a2 + v56 - 1) != 10)
  {
    if (a3 <= v56) {
      size_t v10 = 0LL;
    }
    else {
      size_t v10 = a3 - v56;
    }
    int v39 = __snprintf_chk((char *)(a2 + v56), v10, 0, 0xFFFFFFFFFFFFFFFFLL, "\n");
    if (v39 >= 0)
    {
      if (v39 <= v10) {
        size_t v8 = v39;
      }
      else {
        size_t v8 = v10;
      }
      size_t v9 = v8;
    }

    else
    {
      size_t v9 = 0LL;
    }

    v56 += v9;
  }

  return v56;
}

uint64_t voucher_mach_msg_fill_aux(uint64_t a1, unsigned int a2)
{
  unint64_t v5 = (char *)_dispatch_thread_getspecific(0x1CuLL);
  if (v5 && *((void *)v5 + 6))
  {
    if (a2 >= 0x28uLL)
    {
      *(_DWORD *)a1 = 40;
      *(_DWORD *)(a1 + 4) = 0;
      *(void *)&__int128 v3 = 59821818LL;
      *((void *)&v3 + _dispatch_source_set_handler((uint64_t)source, handler, 2LL, 1) = *((void *)v5 + 6);
      __int128 v4 = *(_OWORD *)(v5 + 56);
      *(_OWORD *)(a1 + 8) = v3;
      *(_OWORD *)(a1 + 24) = v4;
      return 40;
    }

    else
    {
      return 0;
    }
  }

  else
  {
    return 0;
  }

void __spoils<X1,X2,X3,X4,X5,X6,X7,X8,X9,X10,X11,X12,X13,X14,X15,X16,X17,Q0,Q1,Q2,Q3,Q4,Q5,Q6,Q7,Q16,Q17,Q18,Q19,Q20,Q21,Q22,Q23,Q24,Q25,Q26,Q27,Q28,Q29,Q30,Q31> _voucher_activity_id_allocate_slow()
{
  kern_return_t v4;
  uint64_t v5;
  __int128 v4 = 0;
  uint64_t activity_id = 0LL;
  __int128 v4 = mach_generate_activity_id(mach_task_self_, 1, &activity_id);
  if (v4)
  {
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Could not generate an activity ID";
    qword_E4DA8 = v4;
    __break(1u);
    JUMPOUT(0x9D928LL);
  }

  activity_id *= 16LL;
  activity_id &= 0xFFFFFFFFFFFFFFuLL;
  if (!activity_id) {
    uint64_t activity_id = 1LL;
  }
  do
  {
    if (_os_atomic_mo_has_acquire(0)) {
      unint64_t v0 = __ldaxr((unint64_t *)&_voucher_aid_next);
    }
    else {
      unint64_t v0 = __ldxr((unint64_t *)&_voucher_aid_next);
    }
    unint64_t v5 = v0;
    uint64_t v2 = activity_id;
    if (!v0)
    {
      uint64_t v2 = activity_id + 1;
      unint64_t v5 = activity_id;
    }

    if (_os_atomic_mo_has_release(0)) {
      BOOL v1 = __stlxr(v2, (unint64_t *)&_voucher_aid_next) == 0;
    }
    else {
      BOOL v1 = __stxr(v2, (unint64_t *)&_voucher_aid_next) == 0;
    }
  }

  while (!v1);
}

uint64_t _firehose_task_buffer_init()
{
  uint64_t v6 = 0LL;
  __int128 v5 = 0u;
  __int128 v4 = 0u;
  __int128 buffer = 0u;
  pid_t v0 = getpid();
  uint64_t result = proc_pidinfo(v0, 17, 1uLL, &buffer, 56);
  if ((_DWORD)result != 56)
  {
    if (!(_DWORD)result)
    {
      uint64_t v2 = **(int **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
      qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: Unable to get the unique pid (error)";
      qword_E4DA8 = v2;
      __break(1u);
      JUMPOUT(0x9DB48LL);
    }

    qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: Unable to get the unique pid (size)";
    qword_E4DA8 = (int)result;
    __break(1u);
    JUMPOUT(0x9DB8CLL);
  }

  _voucher_unique_pid = v4;
  if (_voucher_libtrace_hooks)
  {
    uint64_t result = (*(uint64_t (**)(void))(_voucher_libtrace_hooks + 8))();
    if ((_DWORD)result)
    {
      uint64_t result = (uint64_t)firehose_buffer_create(result, _voucher_unique_pid, (_dispatch_memory_warn & 1) != 0);
      _firehose_task___int128 buffer = result;
      if (*(uint64_t *)_voucher_libtrace_hooks >= 4)
      {
        if (*(void *)(_voucher_libtrace_hooks + 32)) {
          return (*(uint64_t (**)(uint64_t, uint64_t))(_voucher_libtrace_hooks + 32))( _firehose_task_buffer + 2048,  2048LL);
        }
      }
    }
  }

  return result;
}

unint64_t format_hex_data( const char *a1, const char *a2, uint64_t a3, unint64_t a4, uint64_t a5, unint64_t a6, unint64_t a7)
{
  unint64_t v36 = a7;
  if (a2)
  {
    if (a6 <= a7) {
      size_t v26 = 0LL;
    }
    else {
      size_t v26 = a6 - a7;
    }
    int v33 = __snprintf_chk((char *)(a5 + a7), v26, 0, 0xFFFFFFFFFFFFFFFFLL, "%s%s:\n", a1, a2);
    if (v33 >= 0)
    {
      if (v33 <= v26) {
        size_t v24 = v33;
      }
      else {
        size_t v24 = v26;
      }
      size_t v25 = v24;
    }

    else
    {
      size_t v25 = 0LL;
    }

    v36 += v25;
  }

  unint64_t v32 = -1LL;
  for (unint64_t i = 0LL; i < a4; ++i)
  {
    unint64_t v32 = i % 0x10;
    if (!(i % 0x10))
    {
      if (i)
      {
        if (a6 <= v36) {
          size_t v23 = 0LL;
        }
        else {
          size_t v23 = a6 - v36;
        }
        int v31 = __snprintf_chk((char *)(a5 + v36), v23, 0, 0xFFFFFFFFFFFFFFFFLL, "  %s\n", v41);
        if (v31 >= 0)
        {
          if (v31 <= v23) {
            size_t v21 = v31;
          }
          else {
            size_t v21 = v23;
          }
          size_t v22 = v21;
        }

        else
        {
          size_t v22 = 0LL;
        }

        v36 += v22;
      }

      if (a6 <= v36) {
        size_t v20 = 0LL;
      }
      else {
        size_t v20 = a6 - v36;
      }
      int v30 = __snprintf_chk((char *)(a5 + v36), v20, 0, 0xFFFFFFFFFFFFFFFFLL, "%s  %04lx ", a1, i);
      if (v30 >= 0)
      {
        if (v30 <= v20) {
          size_t v18 = v30;
        }
        else {
          size_t v18 = v20;
        }
        size_t v19 = v18;
      }

      else
      {
        size_t v19 = 0LL;
      }

      v36 += v19;
    }

    if (a6 <= v36) {
      size_t v17 = 0LL;
    }
    else {
      size_t v17 = a6 - v36;
    }
    int v29 = __snprintf_chk((char *)(a5 + v36), v17, 0, 0xFFFFFFFFFFFFFFFFLL, " %02x", *(unsigned __int8 *)(a3 + i));
    if (v29 >= 0)
    {
      if (v29 <= v17) {
        size_t v15 = v29;
      }
      else {
        size_t v15 = v17;
      }
      size_t v16 = v15;
    }

    else
    {
      size_t v16 = 0LL;
    }

    v36 += v16;
    else {
      char v14 = 46;
    }
    v41[v32] = v14;
  }

  v41[v32 + 1] = 0;
  if (i % 0x10)
  {
    while (i % 0x10)
    {
      if (a6 <= v36) {
        size_t v13 = 0LL;
      }
      else {
        size_t v13 = a6 - v36;
      }
      int v28 = __snprintf_chk((char *)(a5 + v36), v13, 0, 0xFFFFFFFFFFFFFFFFLL, "   ");
      if (v28 >= 0)
      {
        if (v28 <= v13) {
          size_t v11 = v28;
        }
        else {
          size_t v11 = v13;
        }
        size_t v12 = v11;
      }

      else
      {
        size_t v12 = 0LL;
      }

      v36 += v12;
      ++i;
    }

    if (a6 <= v36) {
      size_t v10 = 0LL;
    }
    else {
      size_t v10 = a6 - v36;
    }
    int v27 = __snprintf_chk((char *)(a5 + v36), v10, 0, 0xFFFFFFFFFFFFFFFFLL, "  %s\n", v41);
    if (v27 >= 0)
    {
      if (v27 <= v10) {
        size_t v8 = v27;
      }
      else {
        size_t v8 = v10;
      }
      size_t v9 = v8;
    }

    else
    {
      size_t v9 = 0LL;
    }

    v36 += v9;
  }

  return v36;
}

void *firehose_buffer_create(mach_port_name_t a1, uint64_t a2, uint64_t a3)
{
  kern_return_t v18;
  mach_vm_address_t address;
  void *v20;
  mach_vm_address_t v21;
  uint64_t v22;
  uint64_t v23;
  mach_port_name_t v24;
  uint64_t v26;
  uint64_t v27;
  kern_return_t v28;
  kern_return_t v29;
  uint64_t v30;
  kern_return_t v31;
  mach_port_name_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  kern_return_t v37;
  mach_port_options_t options;
  mach_port_name_t name;
  void *v40;
  int v41;
  int v42;
  size_t v24 = a1;
  size_t v23 = a2;
  size_t v22 = a3;
  size_t v21 = 0LL;
  size_t v20 = 0LL;
  address = vm_page_size;
  if (0x4000 % vm_page_size)
  {
    qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: Invalid values for MADVISE_CHUNK_COUNT / CHUNK_SIZE";
    qword_E4DA8 = 0x4000LL;
    __break(1u);
    JUMPOUT(0x9E558LL);
  }

  size_t v18 = mach_vm_map(mach_task_self_, &address, 0x40000uLL, 0LL, 1308622851, 0, 0LL, 0, 3, 7, 2u);
  if (v18)
  {
    if (v18 != 3)
    {
      int v27 = v18;
      size_t v26 = 346LL;
      _dispatch_bug(v26, v27, v3, v4, v5, v6, v7, v8);
    }

    unint64_t v32 = v24;
    int v31 = 0;
    int v31 = mach_port_deallocate(mach_task_self_, v24);
    if (v31 == -301)
    {
      int v30 = -301LL;
      qword_E4D78 = (uint64_t)"MIG_REPLY_MISMATCH";
      qword_E4DA8 = -301LL;
      __break(1u);
      JUMPOUT(0x9E688LL);
    }

    int v29 = v31;
    size_t v34 = v31;
    int v33 = 91LL;
    if (v31) {
      _dispatch_bug(v33, v34, v9, v10, v11, v12, v13, v14);
    }
    int v28 = v29;
    return 0LL;
  }

  else
  {
    size_t v20 = (void *)address;
    size_t v21 = address;
    *(_DWORD *)(address + 1548) = v24;
    *(_DWORD *)(v21 + 1544) = getpid();
    *(void *)(v21 + 1536) = v23;
    int v42 = 49;
    int v41 = 5;
    int v40 = v20;
    mach_port_name_t name = 0;
    options.flags = 51;
    options.mpl.mpl_qlimit = 5;
    options.reserved[1] = 0LL;
    options.reserved[0] = 0LL;
    size_t v37 = 0;
    size_t v37 = mach_port_construct(mach_task_self_, &options, (mach_port_context_t)v20, &name);
    if (v37)
    {
      if (v37 == -301)
      {
        unint64_t v36 = -301LL;
        qword_E4D78 = (uint64_t)"MIG_REPLY_MISMATCH";
        qword_E4DA8 = -301LL;
        __break(1u);
        JUMPOUT(0x9E7ECLL);
      }

      size_t v35 = v37;
      qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Unable to allocate mach port";
      qword_E4DA8 = v37;
      __break(1u);
      JUMPOUT(0x9E828LL);
    }

    *(_DWORD *)(v21 + 156_dispatch_source_set_handler((uint64_t)source, handler, 2LL, 0) = name;
    *(_DWORD *)(v21 + 264) = 20180226;
    *(void *)(v21 + 512) = v22;
    for (unint64_t i = 0LL; i < 7; ++i)
    {
      if (i != 3) {
        *(_BYTE *)(v21 + (i << 7) + 644) = -1;
      }
    }

    firehose_buffer_update_limits_unlocked(v20);
    *(void *)(v21 + 5memset(__b, 0, 20) = 31LL;
    for (unsigned __int16 j = 0; j <= 3u; ++j)
      *(_WORD *)(v21 + 2LL * j) = j + 1;
    *(void *)(v21 + 464) = 4LL;
    *(_WORD *)(v21 + 3memset(__b, 0, 20) = 4;
    *(void *)(v21 + 256) = 0x40000LL;
    return v20;
  }

void *firehose_buffer_update_limits_unlocked(void *result)
{
  uint64_t v16 = result[64];
  unsigned __int16 v15 = 0;
  __int16 v14 = 0;
  for (unint64_t i = 0LL; i < 7; ++i)
  {
    if (BYTE4(result[16 * i + 80]) != 255)
    {
      if (((1LL << i) & 0x13) != 0) {
        ++v15;
      }
      else {
        ++v14;
      }
    }
  }

  if ((v16 & 1) != 0)
  {
    if ((v16 & 2) != 0) {
      unsigned __int16 v12 = 4 * v14 + 1 + v15;
    }
    else {
      unsigned __int16 v12 = v14 + 3 + v15;
    }
  }

  else if ((v16 & 2) != 0)
  {
    unsigned __int16 v12 = 6 * v14 + 1 + 3 * v15;
  }

  else
  {
    unsigned __int16 v12 = 2 * (v14 + v15) + 1;
  }

  unsigned __int16 v10 = vm_page_size / 0x1000;
  if (v10 > 1u)
  {
    else {
      LOWORD(v8) = v12;
    }
    unsigned __int16 v12 = v8;
  }

  if (v12 <= 4u) {
    unsigned __int16 v7 = 4;
  }
  else {
    unsigned __int16 v7 = v12;
  }
  unsigned __int16 v13 = v7;
  if ((v16 & 1) == 0)
  {
    if (v7 <= 8u) {
      __int16 v6 = 8;
    }
    else {
      __int16 v6 = v7;
    }
    unsigned __int16 v13 = v6;
  }

  LOWORD(v9) = v13 - 1;
  if (3 * v13 / 8 <= 2 * v15) {
    LOWORD(v5) = 2 * v15;
  }
  else {
    int v5 = 3 * v13 / 8;
  }
  WORD1(v9) = v5;
  HIDWORD(v9) = (v13 + 1);
  uint64_t v17 = result[66];
  result[66] = v9;
  if (v17 != v9)
  {
    uint64_t v3 = result + 56;
    unint64_t v4 = result[56];
    do
    {
      unint64_t v1 = v4;
      do
        unint64_t v2 = __ldaxr(v3);
      while (v2 == v4 && __stlxr(v4 + v9 - v17, v3));
      unint64_t v4 = v2;
    }

    while (v2 != v1);
  }

  return result;
}

mach_vm_address_t firehose_buffer_get_logging_prefs(uint64_t a1, mach_vm_size_t *a2)
{
  kern_return_t v23;
  kern_return_t v24;
  mach_vm_address_t address;
  mach_vm_size_t size;
  mach_port_name_t v27;
  int v28;
  mach_vm_size_t *v29;
  uint64_t v30;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  int v30 = a1;
  int v29 = a2;
  int v28 = 0;
  int v28 = *(_DWORD *)(a1 + 1548);
  int v27 = 0;
  size = 0LL;
  address = 0LL;
  BOOL v21 = 0;
  if (v28) {
    BOOL v21 = v28 != -1;
  }
  if (v21)
  {
    int logging_prefs = firehose_send_get_logging_prefs(v28, &v27, &size);
    if (logging_prefs)
    {
      if (logging_prefs != 268435459)
      {
        if (logging_prefs == -301)
        {
          qword_E4D78 = (uint64_t)"MIG_REPLY_MISMATCH";
          qword_E4DA8 = -301LL;
          __break(1u);
          JUMPOUT(0x9EF18LL);
        }

        size_t v37 = logging_prefs;
        unint64_t v36 = 601LL;
        _dispatch_bug(v36, v37, v2, v3, v4, v5, v6, v7);
      }

      *int v29 = 0LL;
      return 0LL;
    }

    else
    {
      size_t v23 = mach_vm_map(mach_task_self_, &address, size, 0LL, 1, v27, 0LL, 0, 1, 1, 2u);
      if (v23 == -301)
      {
        qword_E4D78 = (uint64_t)"MIG_REPLY_MISMATCH";
        qword_E4DA8 = -301LL;
        __break(1u);
        JUMPOUT(0x9F00CLL);
      }

      size_t v35 = v23;
      size_t v34 = 612LL;
      if (v23)
      {
        _dispatch_bug(v34, v35, v8, v9, v10, v11, v12, v13);
        address = 0LL;
        size = 0LL;
      }

      size_t v24 = mach_port_deallocate(mach_task_self_, v27);
      if (v24 == -301)
      {
        qword_E4D78 = (uint64_t)"MIG_REPLY_MISMATCH";
        qword_E4DA8 = -301LL;
        __break(1u);
        JUMPOUT(0x9F0D8LL);
      }

      int v33 = v24;
      unint64_t v32 = 618LL;
      if (v24) {
        _dispatch_bug(v32, v33, v14, v15, v16, v17, v18, v19);
      }
      *int v29 = size;
      return address;
    }
  }

  else
  {
    *int v29 = 0LL;
    return 0LL;
  }

BOOL firehose_buffer_should_send_strings( mach_port_context_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  mach_port_context_t v20 = a1;
  mach_port_t v19 = 0;
  mach_port_t v19 = *(_DWORD *)(a1 + 1552);
  int should_send_strings = 0;
  mach_port_t v17 = 0;
  if (v19 != -1)
  {
    if (v19)
    {
      int should_send_strings = firehose_send_should_send_strings(v19, &v17);
      if (!should_send_strings) {
        return v17 != 0;
      }
      if (should_send_strings != 268435459)
      {
        if (should_send_strings == -301)
        {
          qword_E4D78 = (uint64_t)"MIG_REPLY_MISMATCH";
          qword_E4DA8 = -301LL;
          __break(1u);
          JUMPOUT(0x9F238LL);
        }

        uint64_t v25 = should_send_strings;
        uint64_t v24 = 642LL;
        _dispatch_bug(v24, v25, v8, a4, a5, a6, a7, a8);
      }
    }

    mach_port_t v19 = firehose_client_reconnect(v20, v19, 0LL, a4, a5, a6, a7, a8);
    BOOL v16 = 0;
    if (v19) {
      BOOL v16 = v19 != -1;
    }
    if (v16)
    {
      int should_send_strings = firehose_send_should_send_strings(v19, &v17);
      if (!should_send_strings) {
        return v17 != 0;
      }
      if (should_send_strings != 268435459)
      {
        if (should_send_strings == -301)
        {
          qword_E4D78 = (uint64_t)"MIG_REPLY_MISMATCH";
          qword_E4DA8 = -301LL;
          __break(1u);
          JUMPOUT(0x9F36CLL);
        }

        uint64_t v23 = should_send_strings;
        uint64_t v22 = 654LL;
        _dispatch_bug(v22, v23, v9, v10, v11, v12, v13, v14);
      }
    }

    return 0;
  }

  return 0;
}

uint64_t firehose_client_reconnect( mach_port_context_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  kern_return_t v64;
  kern_return_t v65;
  uint64_t v66;
  kern_return_t v67;
  mach_port_name_t v68;
  uint64_t v69;
  uint64_t v70;
  kern_return_t v71;
  kern_return_t v72;
  uint64_t v73;
  kern_return_t v74;
  mach_port_name_t v75;
  uint64_t v76;
  uint64_t v77;
  kern_return_t v78;
  kern_return_t v79;
  uint64_t v80;
  kern_return_t v81;
  mach_port_name_t v82;
  uint64_t v83;
  uint64_t v84;
  kern_return_t v85;
  kern_return_t v86;
  uint64_t v87;
  kern_return_t v88;
  mach_port_name_t name;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  kern_return_t v94;
  mach_port_options_t options;
  mach_port_name_t v96;
  mach_port_context_t context;
  int v98;
  int v99;
  BOOL v100;
  BOOL v101;
  unsigned int v102;
  unsigned int v103;
  unsigned int v104;
  BOOL v105;
  unsigned int v106;
  unsigned int v107;
  unsigned int *v108;
  mach_port_context_t v109;
  uint64_t v110;
  uint64_t v111;
  uint64_t v112;
  BOOL v113;
  uint64_t v114;
  uint64_t v115;
  uint64_t v116;
  uint64_t v117;
  uint64_t v118;
  kern_return_t v119;
  mach_port_context_t v120;
  mach_port_name_t v121;
  kern_return_t v122;
  mach_port_context_t v123;
  mach_port_name_t v124;
  unsigned int v125;
  unsigned int v126;
  unsigned int v127;
  int v128;
  int v129;
  int v130;
  unsigned int v131;
  unsigned int v132;
  unsigned int v133;
  unsigned int *v134;
  BOOL v135;
  unsigned int v136;
  unsigned int v137;
  int v138[2];
  mach_port_context_t v61 = a1;
  int v60 = a2;
  unsigned __int8 v59 = a3;
  unsigned int v58 = 0;
  mach_port_t object_handle = 0;
  mach_port_t v56 = 0;
  memory_object_size_t v55 = 0LL;
  v54[4] = 0;
  *(_DWORD *)unint64_t v54 = a2 != 0;
  unint64_t v117 = *(unsigned int *)(a1 + 1548);
  unint64_t v116 = 157LL;
  if (!v117) {
    _dispatch_abort(v116, 0LL, a3, a4, a5, a6, a7, a8);
  }
  unint64_t v115 = *(unsigned int *)(v61 + 1560);
  unint64_t v114 = 158LL;
  if (!v115) {
    _dispatch_abort(v114, 0LL, a3, a4, a5, a6, a7, a8);
  }
  BOOL v8 = *(void *)(v61 + 1536) != 0LL;
  unint64_t v113 = *(void *)(v61 + 1536) != 0LL;
  BOOL v112 = 159LL;
  if (!v8) {
    _dispatch_abort(v112, v113, a3, a4, a5, a6, a7, a8);
  }
  BOOL v108 = (unsigned int *)(v61 + 1564);
  unint64_t v125 = _dispatch_thread_getspecific(3uLL);
  BOOL v107 = v125 & 0xFFFFFFFC;
  BOOL v106 = 0;
  uint64_t v15 = (unsigned int *)(v61 + 1564);
  unint64_t v103 = v125 & 0xFFFFFFFC;
  unint64_t v102 = v125 & 0xFFFFFFFC;
  BOOL v104 = v125 & 0xFFFFFFFC;
  do
    unsigned int v16 = __ldaxr(v15);
  while (!v16 && __stlxr(v125 & 0xFFFFFFFC, v15));
  if (v16) {
    BOOL v106 = v16;
  }
  unint64_t v101 = v16 == 0;
  unint64_t v105 = v16 == 0;
  BOOL v100 = v105;
  if (v16) {
    _dispatch_unfair_lock_lock_slow(v108, 0x10000);
  }
  unsigned int v58 = *(_DWORD *)(v61 + 4LL * v59 + 1552);
  if (v58 == v60 && v58 != -1)
  {
    if ((v54[0] & 1) != 0)
    {
      for (int i = 0; i <= 1; ++i)
      {
        mach_port_name_t v52 = 0;
        mach_port_name_t v52 = *(_DWORD *)(v61 + 4LL * i + 1552);
        unint64_t v111 = v52;
        unint64_t v110 = 171LL;
        if (!v52) {
          _dispatch_abort(v110, v111, v9, v10, v11, v12, v13, v14);
        }
        unint64_t v124 = v52;
        unint64_t v123 = v61;
        unint64_t v122 = mach_port_destruct(mach_task_self_, v52, 0, v61);
        if (v122 == -301)
        {
          qword_E4D78 = (uint64_t)"MIG_REPLY_MISMATCH";
          qword_E4DA8 = -301LL;
          __break(1u);
          JUMPOUT(0x9F6F0LL);
        }

        mach_port_name_t name = v52;
        uint64_t v88 = mach_port_deallocate(mach_task_self_, v52);
        if (v88 == -301)
        {
          unint64_t v87 = -301LL;
          qword_E4D78 = (uint64_t)"MIG_REPLY_MISMATCH";
          qword_E4DA8 = -301LL;
          __break(1u);
          JUMPOUT(0x9F764LL);
        }

        char v86 = v88;
        unint64_t v91 = v88;
        BOOL v90 = 91LL;
        if (v88) {
          _dispatch_bug(v90, v91, v9, v10, v11, v12, v13, v14);
        }
        char v85 = v86;
        *(_DWORD *)(v61 + 4LL * i + 1552) = 0;
      }
    }

    vm_prot_t permission = 4194305;
    memory_object_size_t size = 0x40000LL;
    memory_object_offset_t offset = v61;
    *(_DWORD *)&v54[1] = mach_make_memory_entry_64(mach_task_self_, &size, v61, 4194305, &object_handle, 0);
    if (!(size >> 18))
    {
      qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Invalid size for the firehose buffer";
      qword_E4DA8 = size;
      __break(1u);
      JUMPOUT(0x9F878LL);
    }

    if (*(_DWORD *)&v54[1])
    {
      qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Unable to make memory port";
      qword_E4DA8 = *(int *)&v54[1];
      __break(1u);
      JUMPOUT(0x9F8C8LL);
    }

    if ((v54[0] & 1) != 0)
    {
      if (*(void *)(_voucher_libtrace_hooks + 24))
      {
        *(_DWORD *)&v54[1] = (*(uint64_t (**)(memory_object_offset_t *, memory_object_size_t *))(_voucher_libtrace_hooks + 24))( &offset,  &size);
        if (!*(_DWORD *)&v54[1] && offset && size)
        {
          memory_object_size_t v55 = size;
          *(_DWORD *)&v54[1] = mach_make_memory_entry_64(mach_task_self_, &size, offset, permission, &v56, 0);
          if (*(_DWORD *)&v54[1])
          {
            qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Unable to make memory port";
            qword_E4DA8 = *(int *)&v54[1];
            __break(1u);
            JUMPOUT(0x9F9B0LL);
          }

          *(_DWORD *)&v54[1] = mach_vm_deallocate(mach_task_self_, offset, size);
          uint64_t v63 = *(int *)&v54[1];
          uint64_t v62 = 209LL;
          if (*(_DWORD *)&v54[1]) {
            _dispatch_bug(v62, v63, v17, v18, v19, v20, v21, v22);
          }
        }
      }
    }

    for (int j = 0; j <= 1; ++j)
    {
      BOOL v99 = 21;
      unint64_t v98 = 1;
      context = v61;
      unint64_t v96 = 0;
      options.flags = 23;
      options.mpl.mpl_qlimit = 1;
      options.reserved[1] = 0LL;
      options.reserved[0] = 0LL;
      BOOL v94 = 0;
      BOOL v94 = mach_port_construct(mach_task_self_, &options, v61, &v96);
      if (v94)
      {
        if (v94 == -301)
        {
          unint64_t v93 = -301LL;
          qword_E4D78 = (uint64_t)"MIG_REPLY_MISMATCH";
          qword_E4DA8 = -301LL;
          __break(1u);
          JUMPOUT(0x9FB14LL);
        }

        unint64_t v92 = v94;
        qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Unable to allocate mach port";
        qword_E4DA8 = v94;
        __break(1u);
        JUMPOUT(0x9FB50LL);
      }

      v138[j] = v96;
    }

    unsigned int v58 = v138[v59];
    *(_DWORD *)&v54[1] = firehose_send_register( *(_DWORD *)(v61 + 1548),  object_handle,  0x40000LL,  v138[0],  v138[1],  *(_DWORD *)(v61 + 1560),  v56,  v55);
    if (*(_DWORD *)&v54[1])
    {
      if (*(_DWORD *)&v54[1] != 268435459)
      {
        qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Unable to register with logd";
        qword_E4DA8 = *(int *)&v54[1];
        __break(1u);
        JUMPOUT(0x9FF8CLL);
      }

      for (int k = 0; k <= 1; ++k)
      {
        char v121 = v138[k];
        BOOL v120 = v61;
        uint64_t v119 = 0;
        uint64_t v119 = mach_port_destruct(mach_task_self_, v121, 0, v61);
        if (v119 == -301)
        {
          unsigned __int8 v118 = -301LL;
          qword_E4D78 = (uint64_t)"MIG_REPLY_MISMATCH";
          qword_E4DA8 = -301LL;
          __break(1u);
          JUMPOUT(0x9FCD8LL);
        }

        unsigned int v82 = v138[k];
        uint64_t v81 = 0;
        uint64_t v81 = mach_port_deallocate(mach_task_self_, v82);
        if (v81 == -301)
        {
          __int16 v80 = -301LL;
          qword_E4D78 = (uint64_t)"MIG_REPLY_MISMATCH";
          qword_E4DA8 = -301LL;
          __break(1u);
          JUMPOUT(0x9FD54LL);
        }

        BOOL v79 = v81;
        uint64_t v84 = v81;
        __int16 v83 = 91LL;
        if (v81) {
          _dispatch_bug(v83, v84, v23, v24, v25, v26, v27, v28);
        }
        uint64_t v78 = v79;
        *(_DWORD *)(v61 + 4LL * k + 1552) = -1;
      }

      unsigned int v58 = -1;
      uint64_t v75 = object_handle;
      unint64_t v74 = 0;
      unint64_t v74 = mach_port_deallocate(mach_task_self_, object_handle);
      if (v74 == -301)
      {
        int v73 = -301LL;
        qword_E4D78 = (uint64_t)"MIG_REPLY_MISMATCH";
        qword_E4DA8 = -301LL;
        __break(1u);
        JUMPOUT(0x9FE3CLL);
      }

      uint64_t v72 = v74;
      uint64_t v77 = v74;
      uint64_t v76 = 91LL;
      if (v74) {
        _dispatch_bug(v76, v77, v29, v30, v31, v32, v33, v34);
      }
      uint64_t v71 = v72;
      if (v56)
      {
        uint64_t v68 = v56;
        uint64_t v67 = 0;
        uint64_t v67 = mach_port_deallocate(mach_task_self_, v56);
        if (v67 == -301)
        {
          uint64_t v66 = -301LL;
          qword_E4D78 = (uint64_t)"MIG_REPLY_MISMATCH";
          qword_E4DA8 = -301LL;
          __break(1u);
          JUMPOUT(0x9FF00LL);
        }

        uint64_t v65 = v67;
        uint64_t v70 = v67;
        uint64_t v69 = 91LL;
        if (v67) {
          _dispatch_bug(v69, v70, v35, v36, v37, v38, v39, v40);
        }
        unsigned __int8 v64 = v65;
      }
    }

    else
    {
      for (int m = 0; m <= 1; ++m)
        *(_DWORD *)(v61 + 4LL * m + 1552) = v138[m];
    }
  }

  unint64_t v109 = v61 + 1564;
  unint64_t v134 = (unsigned int *)(v61 + 1564);
  BOOL v133 = 0;
  unint64_t v132 = 0;
  uint64_t v136 = _dispatch_thread_getspecific(3uLL);
  unint64_t v132 = v136 & 0xFFFFFFFC;
  unint64_t v131 = 0;
  int v44 = v134;
  unsigned __int16 v129 = 0;
  unsigned __int16 v128 = 0;
  unsigned __int8 v130 = 0;
  unsigned int v45 = *v134;
  do
  {
    unsigned int v41 = v45;
    do
      unsigned int v42 = __ldaxr(v44);
    while (v42 == v45 && __stlxr(0, v44));
    unsigned int v45 = v42;
  }

  while (v42 != v41);
  BOOL v127 = v42;
  unint64_t v131 = v42;
  BOOL v126 = v42;
  BOOL v133 = v42;
  if (v42 == v132)
  {
    BOOL v135 = 0;
  }

  else
  {
    _dispatch_unfair_lock_unlock_slow((uint64_t)v134, v133);
    unint64_t v137 = v133;
    BOOL v135 = (v133 & 2) != 0;
  }

  return v58;
}

void firehose_client_push_reply(uint64_t a1, int a2)
{
  qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: firehose_push_reply should never be sent to the buffer receive port";
  qword_E4DA8 = a2;
  __break(1u);
}

uint64_t sub_A0150()
{
  return v1;
}

uint64_t firehose_client_push_notify_async(uint64_t a1, unint64_t a2, unint64_t a3, int a4)
{
  for (int i = (char *)_dispatch_thread_getspecific(0x17uLL); i; int i = *(char **)i)
  {
    if (*((char **)i + 1) == "firehose")
    {
      uint64_t v9 = i;
      goto LABEL_7;
    }
  }

  uint64_t v9 = 0LL;
LABEL_7:
  firehose_client_merge_updates(*((void *)v9 + 2), 1, a2, a3, a4 != 0, 0LL);
  return 0LL;
}

void firehose_client_merge_updates( uint64_t a1, char a2, unint64_t a3, unint64_t a4, char a5, void *a6)
{
  char v43 = a2 & 1;
  unsigned __int16 v37 = 0;
  unsigned __int16 v36 = 0;
  if ((a5 & 1) != 0 && !*(_BYTE *)(a1 + 1568))
  {
    uint64_t v6 = (unsigned __int8 *)(a1 + 1568);
    do
      int v7 = __ldaxr(v6);
    while (!v7 && __stlxr(1u, v6));
  }

  BOOL v35 = 0;
  uint64_t v34 = (unint64_t *)(a1 + 464);
  while (1)
  {
    unint64_t v8 = _os_atomic_mo_has_acquire(0) ? __ldaxr(v34) : __ldxr(v34);
    __int16 v38 = v8;
    if (v8 >= a3) {
      break;
    }
    if (_os_atomic_mo_has_release(0)) {
      BOOL v35 = __stlxr(a3, v34) == 0;
    }
    else {
      BOOL v35 = __stxr(a3, v34) == 0;
    }
    if (v35) {
      goto LABEL_16;
    }
  }

  __clrex();
LABEL_16:
  if (v35) {
    unsigned __int16 v36 = a3 - v38;
  }
  BOOL v33 = 0;
  uint64_t v32 = (unint64_t *)(a1 + 488);
  while (1)
  {
    unint64_t v9 = _os_atomic_mo_has_acquire(0) ? __ldaxr(v32) : __ldxr(v32);
    __int16 v39 = v9;
    if (v9 >= a4) {
      break;
    }
    if (_os_atomic_mo_has_release(0)) {
      BOOL v33 = __stlxr(a4, v32) == 0;
    }
    else {
      BOOL v33 = __stxr(a4, v32) == 0;
    }
    if (v33) {
      goto LABEL_28;
    }
  }

  __clrex();
LABEL_28:
  if (v33) {
    unsigned __int16 v37 = a4 - v39;
  }
  _dispatch_thread_getspecific(0LL);
  _dispatch_log("%u\t%p\tclient side: mem: +%d->%llx, io: +%d->%llx", v10, v11, v12, v13, v14, v15, v16, 544LL);
  if (v36 || v37)
  {
    uint64_t v30 = (unint64_t *)(a1 + 256);
    do
    {
      if (_os_atomic_mo_has_acquire(0)) {
        unint64_t v17 = __ldaxr(v30);
      }
      else {
        unint64_t v17 = __ldxr(v30);
      }
      unint64_t v40 = v17;
      HIWORD(v4_dispatch_source_set_handler((uint64_t)source, handler, 2LL, 0) = HIWORD(v17) + v37;
      WORD1(v4_dispatch_source_set_handler((uint64_t)source, handler, 2LL, 0) = WORD1(v17) + v36;
      if (_os_atomic_mo_has_release(0)) {
        BOOL v31 = __stlxr(v40, v30) == 0;
      }
      else {
        BOOL v31 = __stxr(v40, v30) == 0;
      }
    }

    while (!v31);
    uint64_t v28 = (unint64_t *)(a1 + 448);
    uint64_t v29 = *(void *)(a1 + 448);
    do
    {
      uint64_t v18 = v29;
      do
        unint64_t v19 = __ldaxr(v28);
      while (v19 == v29 && __stlxr(v29 + (((unint64_t)v37 << 16) | v36), v28));
      uint64_t v29 = v19;
    }

    while (v19 != v18);
    if (a6) {
      *a6 = v19 + (((unint64_t)v37 << 16) | v36);
    }
    if ((v43 & 1) != 0)
    {
      if (v37)
      {
        uint64_t v26 = (unint64_t *)(a1 + 496);
        unint64_t v27 = *(void *)(a1 + 496);
        do
        {
          unint64_t v20 = v27;
          do
            unint64_t v21 = __ldaxr(v26);
          while (v21 == v27 && __stlxr(v27 + 1, v26));
          unint64_t v27 = v21;
        }

        while (v21 != v20);
      }

      if (v36)
      {
        uint64_t v24 = (unint64_t *)(a1 + 472);
        unint64_t v25 = *(void *)(a1 + 472);
        do
        {
          unint64_t v22 = v25;
          do
            unint64_t v23 = __ldaxr(v24);
          while (v23 == v25 && __stlxr(v25 + 1, v24));
          unint64_t v25 = v23;
        }

        while (v23 != v22);
      }
    }
  }

  else if (a6)
  {
    *a6 = *(void *)(a1 + 448);
  }

void *firehose_buffer_update_limits(void *a1)
{
  uint64_t v6 = (unsigned int *)(a1 + 67);
  unint64_t v9 = (unsigned int *)(a1 + 67);
  unsigned int v8 = _dispatch_thread_getspecific(3uLL) & 0xFFFFFFFC;
  do
    unsigned int v1 = __ldaxr(v9);
  while (!v1 && __stlxr(v8, v9));
  if (v1) {
    _dispatch_unfair_lock_lock_slow(v9, 0x10000);
  }
  firehose_buffer_update_limits_unlocked(a1);
  uint64_t result = _dispatch_thread_getspecific(3uLL);
  unsigned int v5 = *v6;
  do
  {
    unsigned int v3 = v5;
    do
      unsigned int v4 = __ldaxr(v6);
    while (v4 == v5 && __stlxr(0, v6));
    unsigned int v5 = v4;
  }

  while (v4 != v3);
  return result;
}

void firehose_buffer_ring_enqueue(mach_port_context_t a1, unsigned __int8 a2)
{
  BOOL v17 = (*(void *)(a1 + ((unint64_t)a2 << 12)) & 0x200000000000000LL) != 0;
  if ((*(void *)(a1 + ((unint64_t)a2 << 12)) & 0x200000000000000LL) != 0)
  {
    mach_port_context_t v22 = a1 + 128;
    unint64_t v21 = (unsigned __int16 *)(a1 + 384);
  }

  else
  {
    mach_port_context_t v22 = a1;
    unint64_t v21 = (unsigned __int16 *)(a1 + 320);
  }

  unsigned __int16 v20 = *v21;
  while (1)
  {
    while (1)
    {
      unsigned __int16 v19 = v20 & 0xFFC0;
      unsigned __int16 v18 = v20 & 0x3F;
      _dispatch_thread_setspecific(122LL, (uint64_t)v21);
      uint64_t v2 = (unsigned __int16 *)(v22 + 2LL * (v20 & 0x3F));
      int v3 = v20 & 0xFFC0;
      do
        int v4 = __ldaxr(v2);
      while (v4 == (unsigned __int16)v3 && __stlxr(v20 & 0xFFC0 | a2, v2));
      _dispatch_thread_setspecific(122LL, 0LL);
      for (int i = -1024; ; ++i)
      {
        unsigned __int16 v14 = v20;
        unsigned __int16 v20 = *v21;
        BOOL v12 = 1;
        if (*v21 == v14) {
          BOOL v12 = *(unsigned __int16 *)(v22 + 2LL * v18) == v19;
        }
        if (v12) {
          break;
        }
        int v6 = i;
        if (v6 < 0) {
          __yield();
        }
        else {
          _pthread_yield_to_enqueuer_4dispatch(122LL, v21);
        }
      }
    }

    unsigned __int16 v16 = v20;
    do
      int v5 = __ldaxr(v21);
    while (v5 == v20 && __stlxr(v20 + 1, v21));
    BOOL v13 = v20 == (unsigned __int16)v5;
    unsigned __int16 v20 = v16;
    if (v13) {
      break;
    }
    *(_WORD *)(v22 + 2LL * v18) = v19;
    _dispatch_thread_setspecific(122LL, 0LL);
  }

  _dispatch_thread_setspecific(122LL, 0LL);
  firehose_client_send_push_async(a1, 0, v17, v7, v8, v9, v10, v11);
}

void firehose_client_send_push_async( mach_port_context_t a1, int a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned __int8 v22 = a3 & 1;
  int v20 = *(_DWORD *)(a1 + 4LL * (a3 & 1) + 1552);
  if (v20 == -1) {
    return;
  }
  if (!v20) {
    goto LABEL_11;
  }
  int v18 = firehose_send_push_async(v20, a2, 0);
  BOOL v17 = 1;
  if (v18) {
    BOOL v17 = v18 == 268435460;
  }
  if (!v17)
  {
    if (v18 != 268435459)
    {
      if (v18 == -301)
      {
        qword_E4D78 = (uint64_t)"MIG_REPLY_MISMATCH";
        qword_E4DA8 = -301LL;
        __break(1u);
        JUMPOUT(0xA11F4LL);
      }

      if (v18) {
        _dispatch_bug(476LL, v18, v8, a4, a5, a6, a7, a8);
      }
    }

LABEL_11:
    int v21 = firehose_client_reconnect(a1, v20, v22, a4, a5, a6, a7, a8);
    BOOL v16 = 0;
    if (v21) {
      BOOL v16 = v21 != -1;
    }
    if (v16)
    {
      int v19 = firehose_send_push_async(v21, a2, 0);
      BOOL v15 = 1;
      if (v19) {
        BOOL v15 = v19 == 268435460;
      }
      if (!v15 && v19 != 268435459)
      {
        if (v19 == -301)
        {
          qword_E4D78 = (uint64_t)"MIG_REPLY_MISMATCH";
          qword_E4DA8 = -301LL;
          __break(1u);
          JUMPOUT(0xA1348LL);
        }

        if (v19) {
          _dispatch_bug(488LL, v19, v9, v10, v11, v12, v13, v14);
        }
      }
    }
  }

mach_port_context_t firehose_buffer_force_connect( mach_port_context_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!*(_DWORD *)(result + 1552)) {
    return firehose_client_reconnect(result, 0, 0LL, a4, a5, a6, a7, a8);
  }
  return result;
}

char *firehose_buffer_tracepoint_reserve_slow(void *a1, _BYTE *a2, void *a3)
{
  mach_port_name_t v52 = a1;
  unint64_t v51 = a2;
  uint64_t v50 = a3;
  int v49 = 0;
  int v49 = a2[14] & 1;
  int v48 = a1 + 56;
  unint64_t v47 = 0LL;
  unsigned __int8 v45 = 0;
  firehose_drain_notifications_once((uint64_t)a1);
  unint64_t v47 = *v48;
  uint64_t v67 = v52;
  BOOL v66 = v49 != 0;
  uint64_t v65 = &v47;
  BOOL v64 = 0;
  uint64_t v63 = v52 + 56;
  unint64_t v62 = v47;
  unint64_t v61 = 0LL;
  do
  {
    if (!*((_WORD *)&v62 + v66))
    {
      char v68 = 0;
      goto LABEL_11;
    }

    unint64_t v61 = v62;
    --*((_WORD *)&v61 + v66);
    unint64_t v60 = v62;
    BOOL v59 = 0;
    int v3 = v63;
    unint64_t v57 = v61;
    unint64_t v56 = v61;
    unint64_t v58 = v61;
    unint64_t v4 = v62;
    unint64_t v5 = v61;
    do
      unint64_t v6 = __ldaxr(v3);
    while (v6 == v4 && __stlxr(v5, v3));
    if (v6 != v4) {
      unint64_t v60 = v6;
    }
    BOOL v55 = v6 == v4;
    BOOL v59 = v6 == v4;
    unint64_t v62 = v60;
    BOOL v54 = v59;
    BOOL v64 = v6 == v4;
  }

  while (v6 != v4);
  *uint64_t v65 = v61;
  char v68 = 1;
LABEL_11:
  char v46 = v68;
  if ((v68 & 1) != 0)
  {
    while (!v45)
    {
      BOOL v100 = v52;
      unint64_t v99 = 0LL;
      unint64_t v98 = 0LL;
      unint64_t v97 = 0LL;
      __int16 v96 = 0;
      __int16 v95 = 0;
      unsigned __int16 v94 = 0;
      unsigned __int8 v93 = 0;
      unint64_t v92 = 0LL;
      BOOL v91 = 0;
      int v90 = 0;
      BOOL v89 = v52 + 32;
      do
      {
        if (_os_atomic_mo_has_acquire(0)) {
          unint64_t v7 = __ldaxr(v89);
        }
        else {
          unint64_t v7 = __ldxr(v89);
        }
        unint64_t v98 = v7;
        unint64_t v99 = v7;
        if ((unsigned __int16)v98 == WORD1(v98))
        {
          if (WORD2(v98) == HIWORD(v98))
          {
            __clrex();
            unsigned __int8 v101 = 0;
            goto LABEL_44;
          }

          ++WORD2(v99);
        }

        else
        {
          LOWORD(v99) = v99 + 1;
        }

        if (_os_atomic_mo_has_release(0))
        {
          LOBYTE(v9_dispatch_source_set_handler((uint64_t)source, handler, 2LL, 0) = __stlxr(v99, v89) == 0;
          int v90 = v90;
        }

        else
        {
          LOBYTE(v9_dispatch_source_set_handler((uint64_t)source, handler, 2LL, 0) = __stxr(v99, v89) == 0;
          int v90 = v90;
        }
      }

      while (!v90);
      int v88 = v90;
      BOOL v91 = WORD2(v99) != WORD2(v98);
      if (WORD2(v99) == WORD2(v98))
      {
        unint64_t v97 = v100;
        unsigned __int16 v94 = v98 & 0x3F;
      }

      else
      {
        unint64_t v97 = v100 + 16;
        unsigned __int16 v94 = BYTE4(v98) & 0x3F;
      }

      int v87 = 0;
      mach_msg_timeout_t option_time = -1024;
      while (1)
      {
        __int16 v95 = *((_WORD *)v97 + v94);
        int v87 = v95 & 0x3F;
        if (v87) {
          break;
        }
        int v8 = option_time++;
        if (v8 < 0) {
          __yield();
        }
        else {
          thread_switch(0, 4, option_time);
        }
      }

      int v85 = v87;
      __int16 v96 = (v95 & 0xFFC0) + 64;
      unsigned __int8 v93 = v95 & 0x3F;
      unint64_t v103 = v100;
      char v102 = v95 & 0x3F;
      unint64_t v92 = &v100[512 * (unint64_t)(v95 & 0x3F)];
      if (!v91 && *((_BYTE *)v92 + 6) == 3)
      {
        uint64_t v83 = ~(1LL << v93);
        uint64_t v82 = v83;
        uint64_t v84 = v83;
        unint64_t v80 = 0LL;
        unsigned int v42 = v100 + 57;
        uint64_t v78 = v83;
        uint64_t v77 = v83;
        uint64_t v79 = v83;
        uint64_t v43 = v83;
        unint64_t v44 = v100[57];
        do
        {
          unint64_t v9 = v44;
          do
            unint64_t v10 = __ldaxr(v42);
          while (v10 == v44 && __stlxr(v44 & v43, v42));
          unint64_t v44 = v10;
        }

        while (v10 != v9);
        unint64_t v76 = v10;
        unint64_t v80 = v10;
        unint64_t v75 = v10;
        unint64_t v81 = v10 & v84;
      }

      uint64_t v74 = 0x100000000000000LL;
      uint64_t v73 = 0x100000000000000LL;
      *unint64_t v92 = 0x100000000000000LL;
      uint64_t v72 = v74;
      __int16 v71 = v96;
      __int16 v70 = v96;
      *((_WORD *)v97 + v94) = v96;
      __int16 v69 = v71;
      unsigned __int8 v101 = v93;
LABEL_44:
      unsigned __int8 v45 = v101;
      if (!v101) {
        break;
      }
      if (v101 >= (int)BYTE4(v47))
      {
        unint64_t v109 = v52;
        unsigned __int8 v108 = v101;
        uint64_t v107 = 0x4000LL;
        uint64_t v106 = 15LL;
        unint64_t v105 = v52 + 67;
        uint64_t v104 = 0LL;
        unsigned __int8 v118 = (unsigned int *)(v52 + 67);
        unsigned int v117 = 0;
        unsigned int v165 = _dispatch_thread_getspecific(3uLL);
        unsigned int v117 = v165 & 0xFFFFFFFC;
        unsigned int v116 = 0;
        BOOL v115 = 0;
        uint64_t v11 = v118;
        unsigned int v113 = v165 & 0xFFFFFFFC;
        unsigned int v112 = v165 & 0xFFFFFFFC;
        unsigned int v114 = v165 & 0xFFFFFFFC;
        unsigned int v12 = v165 & 0xFFFFFFFC;
        do
          unsigned int v13 = __ldaxr(v11);
        while (!v13 && __stlxr(v12, v11));
        if (v13) {
          unsigned int v116 = v13;
        }
        BOOL v111 = v13 == 0;
        BOOL v115 = v13 == 0;
        BOOL v110 = v115;
        if (v13) {
          _dispatch_unfair_lock_lock_slow(v118, 0x10000);
        }
        if (v108 >= (int)*((unsigned __int8 *)v109 + 532))
        {
          uint64_t v14 = v109[65] & ~(1LL << v108);
          v109[65] = v14;
          uint64_t v104 = v14;
          v108 &= 0xFCu;
          if ((v14 & (15LL << v108)) == 0)
          {
            char v121 = v109;
            unsigned __int8 v120 = v108;
            madvise(&v109[512 * (unint64_t)v108], 0x4000uLL, 5);
          }

          unsigned __int8 v108 = 0;
        }

        uint64_t v119 = v105;
        unsigned __int8 v186 = (unsigned int *)v105;
        unsigned int v185 = 0;
        unsigned int v184 = 0;
        unsigned int v188 = _dispatch_thread_getspecific(3uLL);
        unsigned int v184 = v188 & 0xFFFFFFFC;
        unsigned int v183 = 0;
        unint64_t v40 = v186;
        int v181 = 0;
        int v180 = 0;
        int v182 = 0;
        unsigned int v41 = *v186;
        do
        {
          unsigned int v15 = v41;
          do
            unsigned int v16 = __ldaxr(v40);
          while (v16 == v41 && __stlxr(0, v40));
          unsigned int v41 = v16;
        }

        while (v16 != v15);
        unsigned int v179 = v16;
        unsigned int v183 = v16;
        unsigned int v178 = v16;
        unsigned int v185 = v16;
        if (v16 == v184)
        {
          BOOL v187 = 0;
        }

        else
        {
          _dispatch_unfair_lock_unlock_slow((uint64_t)v186, v185);
          unsigned int v189 = v185;
          BOOL v187 = (v185 & 2) != 0;
        }

        unsigned __int8 v45 = v108;
      }
    }

    if (!v45)
    {
      unint64_t v125 = v48;
      __int16 v124 = BYTE4(v47);
      unsigned __int8 v123 = 0;
      unint64_t v122 = 0LL;
      unint64_t v134 = (unsigned int *)(v48 + 11);
      unsigned int v133 = 0;
      unsigned int v166 = _dispatch_thread_getspecific(3uLL);
      unsigned int v133 = v166 & 0xFFFFFFFC;
      unsigned int v132 = 0;
      BOOL v131 = 0;
      BOOL v17 = v134;
      unsigned int v129 = v166 & 0xFFFFFFFC;
      unsigned int v128 = v166 & 0xFFFFFFFC;
      unsigned int v130 = v166 & 0xFFFFFFFC;
      unsigned int v18 = v166 & 0xFFFFFFFC;
      do
        unsigned int v19 = __ldaxr(v17);
      while (!v19 && __stlxr(v18, v17));
      if (v19) {
        unsigned int v132 = v19;
      }
      BOOL v127 = v19 == 0;
      BOOL v131 = v19 == 0;
      BOOL v126 = v131;
      if (v19) {
        _dispatch_unfair_lock_lock_slow(v134, 0x10000);
      }
      unint64_t v122 = ~(v125[9] | (-1LL << v124));
      if (v122)
      {
        unint64_t v191 = v122;
        BOOL v193 = v122 != 0;
        uint64_t v192 = 45LL;
        unsigned __int8 v123 = __clz(__rbit64(v122));
        v125[9] |= (1 << v123);
      }

      BOOL v135 = v125 + 11;
      unint64_t v175 = (unsigned int *)(v125 + 11);
      unsigned int v174 = 0;
      unsigned int v173 = 0;
      unsigned int v177 = _dispatch_thread_getspecific(3uLL);
      unsigned int v173 = v177 & 0xFFFFFFFC;
      unsigned int v172 = 0;
      __int16 v38 = v175;
      int v170 = 0;
      int v169 = 0;
      int v171 = 0;
      unsigned int v39 = *v175;
      do
      {
        unsigned int v20 = v39;
        do
          unsigned int v21 = __ldaxr(v38);
        while (v21 == v39 && __stlxr(0, v38));
        unsigned int v39 = v21;
      }

      while (v21 != v20);
      unsigned int v168 = v21;
      unsigned int v172 = v21;
      unsigned int v167 = v21;
      unsigned int v174 = v21;
      if (v21 == v173)
      {
        BOOL v176 = 0;
      }

      else
      {
        _dispatch_unfair_lock_unlock_slow((uint64_t)v175, v174);
        unsigned int v190 = v174;
        BOOL v176 = (v174 & 2) != 0;
      }

      unsigned __int8 v45 = v123;
    }
  }

  BOOL v37 = 1;
  if (!v45) {
    BOOL v37 = (v51[14] & 4) == 0;
  }
  if (v37)
  {
    if (!v45 && (v46 & 1) != 0)
    {
      __int16 v148 = v52;
      BOOL v147 = v49 != 0;
      uint64_t v146 = v52 + 56;
      uint64_t v144 = 1LL << (16 * (v49 != 0));
      uint64_t v143 = v144;
      uint64_t v145 = v144;
      unint64_t v141 = 0LL;
      uint64_t v34 = v52 + 56;
      uint64_t v139 = v144;
      uint64_t v138 = v144;
      uint64_t v140 = v144;
      uint64_t v35 = v144;
      unint64_t v36 = v52[56];
      do
      {
        unint64_t v22 = v36;
        do
          unint64_t v23 = __ldaxr(v34);
        while (v23 == v36 && __stlxr(v36 + v35, v34));
        unint64_t v36 = v23;
      }

      while (v23 != v22);
      unint64_t v137 = v23;
      unint64_t v141 = v23;
      unint64_t v136 = v23;
      unint64_t v142 = v23 + v145;
    }

    return firehose_buffer_stream_chunk_install(v52, (uint64_t)v51, v50, v45);
  }

  else
  {
    unsigned __int8 v24 = v51[12];
    unint64_t v164 = v52;
    unsigned __int8 v163 = v24;
    unint64_t v162 = 0LL;
    unint64_t v161 = 0LL;
    unsigned __int8 v160 = &v52[16 * (unint64_t)v24 + 80];
    unint64_t v159 = 0LL;
    unint64_t v158 = *v160;
    unint64_t v159 = v158;
    unint64_t v157 = v158;
    unint64_t v162 = v158;
    if ((v158 & 0x400000000000LL) != 0)
    {
      int v152 = 0;
      BOOL v151 = v160;
      do
      {
        if (_os_atomic_mo_has_acquire(0)) {
          unint64_t v31 = __ldaxr(v151);
        }
        else {
          unint64_t v31 = __ldxr(v151);
        }
        unint64_t v162 = v31;
        LODWORD(v15_dispatch_source_set_handler((uint64_t)source, handler, 2LL, 0) = v31 & 0xFFFFFFFD;
        BYTE4(v15_dispatch_source_set_handler((uint64_t)source, handler, 2LL, 0) = BYTE4(v31);
        BYTE5(v15_dispatch_source_set_handler((uint64_t)source, handler, 2LL, 0) = BYTE5(v150) & 0xC0 | BYTE5(v31) & 0x3F;
        BYTE5(v15_dispatch_source_set_handler((uint64_t)source, handler, 2LL, 0) = BYTE5(v150) & 0xBF | 0x40;
        BYTE5(v15_dispatch_source_set_handler((uint64_t)source, handler, 2LL, 0) = BYTE5(v150) & 0x7F | 0x80;
        HIWORD(v15_dispatch_source_set_handler((uint64_t)source, handler, 2LL, 0) = HIWORD(v31);
        unint64_t v161 = v150;
        if (_os_atomic_mo_has_release(0))
        {
          LOBYTE(v152) = __stlxr(v161, v151) == 0;
          int v152 = v152;
        }

        else
        {
          LOBYTE(v152) = __stxr(v161, v151) == 0;
          int v152 = v152;
        }
      }

      while (!v152);
      int v149 = v152;
    }

    else
    {
      v160[1] = mach_continuous_time();
      int v156 = 0;
      __int16 v155 = v160;
      do
      {
        if (_os_atomic_mo_has_acquire(3)) {
          unint64_t v25 = __ldaxr(v155);
        }
        else {
          unint64_t v25 = __ldxr(v155);
        }
        unint64_t v162 = v25;
        LODWORD(v154) = v25 & 0xFFFFFFFD;
        BYTE4(v154) = BYTE4(v25);
        BYTE5(v154) = BYTE5(v154) & 0xC0 | BYTE5(v25) & 0x3F;
        BYTE5(v154) = BYTE5(v154) & 0xBF | 0x40;
        BYTE5(v154) = BYTE5(v154) & 0x7F | 0x80;
        HIWORD(v154) = HIWORD(v25);
        unint64_t v161 = v154;
        if (_os_atomic_mo_has_release(3))
        {
          LOBYTE(v156) = __stlxr(v161, v155) == 0;
          int v156 = v156;
        }

        else
        {
          LOBYTE(v156) = __stxr(v161, v155) == 0;
          int v156 = v156;
        }
      }

      while (!v156);
      int v153 = v156;
    }

    unint64_t v32 = v160[1];
    unsigned __int8 v197 = v163;
    unint64_t v196 = v32;
    unint64_t v195 = v162;
    unint64_t v194 = v161;
    unsigned int v202 = 772145168;
    uint64_t v201 = v163;
    unint64_t v200 = v32;
    unint64_t v199 = v162;
    unint64_t v198 = v161;
    if (MEMORY[0xFFFFFC100]) {
      kdebug_trace(v202, v201, v200, v199, v198);
    }
    if ((v162 & 2) != 0) {
      _dispatch_gate_broadcast_slow((uint64_t)v160, v162);
    }
    v51[13] = v46 & 1;
    return firehose_buffer_tracepoint_reserve_wait_for_chunks_from_logd(v52, (uint64_t)v51, v50, v26, v27, v28, v29, v30);
  }

BOOL firehose_drain_notifications_once(uint64_t a1)
{
  mach_msg_return_t v26;
  mach_msg_header_t *v27;
  mach_msg_size_t v28;
  uint64_t v29;
  uint64_t v30;
  mach_msg_option_t v31;
  uint64_t v32;
  void *v33;
  uint64_t v34;
  __int128 v35;
  uint64_t v36;
  BOOL v37;
  int v38;
  void *v39;
  mach_msg_header_t *v40;
  uint64_t v41;
  uint64_t (*v42)(_DWORD *, uint64_t);
  uint64_t *v43;
  uint64_t v44;
  BOOL v45;
  unint64_t v32 = a1;
  mach_msg_size_t v23 = 0;
  unint64_t v31 = 67109126;
  uint64_t v30 = 56LL;
  uint64_t v29 = 36LL;
  uint64_t v28 = 124;
  uint64_t v27 = 0LL;
  unint64_t v22 = (mach_msg_header_t *)v15;
  bzero(v15, 0x7CuLL);
  uint64_t v27 = v22;
  uint64_t v26 = v23;
  uint64_t v26 = mach_msg(v22, v31, v23, v28, *(_DWORD *)(v32 + 1560), v23, v23);
  if (v26)
  {
    if (v26 != 268451843)
    {
      uint64_t v24 = v26;
      void v14[4] = v1;
      v14[5] = v2;
      qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: firehose_drain_notifications_once() failed";
      qword_E4DA8 = v26;
      __break(1u);
      JUMPOUT(0xA29F0LL);
    }
  }

  else
  {
    uint64_t v19 = 0LL;
    v25[0] = 0LL;
    v25[1] = "firehose";
    v25[2] = v32;
    BOOL v33 = v25;
    uint64_t v18 = 23LL;
    int v3 = _dispatch_thread_getspecific(0x17uLL);
    uint64_t v4 = v18;
    *BOOL v33 = v3;
    _dispatch_thread_setspecific(v4, (uint64_t)v33);
    unsigned int v20 = v15;
    unsigned int v42 = firehoseReply_server;
    unsigned int v41 = 36LL;
    unint64_t v40 = v27;
    unsigned int v39 = (void *)v19;
    unsigned int v21 = v14;
    bzero(v14, 0x24uLL);
    unsigned int v39 = v21;
    __int16 v38 = 0;
    BOOL v37 = (v40->msgh_bits & 0x1F) == 18;
    unint64_t v5 = v21;
    unint64_t v36 = 0LL;
    uint64_t v35 = 0uLL;
    v21[2] = 0LL;
    *unint64_t v5 = 0uLL;
    if (v42(v40, (uint64_t)v39))
    {
      if ((*((_BYTE *)v39 + 3) & 0x80) != 0) {
        __int16 v38 = 0;
      }
      else {
        __int16 v38 = *((_DWORD *)v39 + 8);
      }
    }

    else
    {
      __int16 v38 = -303;
    }

    BOOL v17 = 0;
    if (!v38) {
      BOOL v17 = v37;
    }
    if (v17)
    {
      uint64_t v34 = 0LL;
      uint64_t v34 = *((int *)v39 + 5);
      qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: firehose_mig_server doesn't handle replies";
      qword_E4DA8 = v34;
      __break(1u);
      JUMPOUT(0xA28D8LL);
    }

    BOOL v16 = 0;
    if (v38) {
      BOOL v16 = v38 != -305;
    }
    if (v16)
    {
      v40->msgh_remote_mach_port_t port = 0;
      mach_msg_destroy(v40);
    }

    uint64_t v43 = v25;
    BOOL v12 = _dispatch_thread_getspecific(0x17uLL) == v25;
    unsigned __int8 v45 = v12;
    unint64_t v44 = 449LL;
    if (!v12) {
      _dispatch_abort(v44, v45, v6, v7, v8, v9, v10, v11);
    }
    _dispatch_thread_setspecific(23LL, *v43);
  }

  return v26 == 0;
}

char *firehose_buffer_stream_chunk_install(void *a1, uint64_t a2, void *a3, unsigned __int8 a4)
{
  uint64_t v77 = a1;
  uint64_t v76 = a2;
  unint64_t v75 = a3;
  unsigned __int8 v74 = a4;
  unint64_t v73 = 0LL;
  unint64_t v72 = 0LL;
  __int16 v71 = 0LL;
  __int16 v70 = 0LL;
  __int16 v69 = a1;
  char v68 = 0LL;
  char v68 = &a1[16 * (unint64_t)*(unsigned __int8 *)(a2 + 12) + 80];
  if (a4)
  {
    unint64_t v67 = 0LL;
    BOOL v66 = 0;
    uint64_t v79 = v77;
    unsigned __int8 v78 = v74;
    uint64_t v65 = (char *)&v77[512 * (unint64_t)v74];
    uint64_t v64 = 0LL;
    uint64_t v63 = *(void *)v65;
    uint64_t v64 = v63;
    uint64_t v62 = v63;
    if (v63) {
      __memset_chk(v65 + 16, 0LL, 4080LL, -1LL);
    }
    if (*(_BYTE *)(v76 + 12) == 3)
    {
      uint64_t v60 = 1LL << v74;
      uint64_t v59 = 1LL << v74;
      uint64_t v61 = 1LL << v74;
      unint64_t v57 = 0LL;
      uint64_t v26 = v69 + 57;
      uint64_t v55 = 1LL << v74;
      uint64_t v54 = 1LL << v74;
      uint64_t v56 = 1LL << v74;
      unint64_t v27 = v69[57];
      do
      {
        unint64_t v4 = v27;
        do
          unint64_t v5 = __ldaxr(v26);
        while (v5 == v27 && __stlxr(v27 | (1LL << v74), v26));
        unint64_t v27 = v5;
      }

      while (v5 != v4);
      unint64_t v53 = v5;
      unint64_t v57 = v5;
      unint64_t v52 = v5;
      unint64_t v58 = v5 | v61;
    }

    unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
    unint64_t v67 = *(void *)(StatusReg - 8);
    unint64_t v51 = 0LL;
    unint64_t v50 = *v68;
    unint64_t v51 = v50;
    unint64_t v49 = v50;
    unint64_t v73 = v50;
    if ((v50 & 0x3F0000000000LL) == 0)
    {
      unsigned int v117 = v65;
      uint64_t v116 = v76;
      BOOL v115 = v75;
      unint64_t v114 = v67;
      uint64_t v113 = 0LL;
      uint64_t v112 = 0LL;
      BOOL v111 = 0LL;
      uint64_t v110 = 0LL;
      __int16 v109 = 24;
      __int16 v108 = 16;
      unsigned __int16 v107 = 4096;
      unint64_t v122 = *(void *)v76;
      if (v122 <= 0x1000000000LL) {
        unint64_t v25 = 0LL;
      }
      else {
        unint64_t v25 = v122 - 0x1000000000LL;
      }
      *((void *)v117 + _dispatch_source_set_handler((uint64_t)source, handler, 2LL, 1) = v25;
      BOOL v111 = v117 + 16;
      else {
        LOWORD(v24) = *(_WORD *)(v116 + 8) + 24;
      }
      v108 += v24;
      v107 -= *(_WORD *)(v116 + 10);
      uint64_t v110 = *(void *)v116 - *((void *)v117 + 1);
      v110 |= (unint64_t)*(unsigned __int16 *)(v116 + 8) << 48;
      uint64_t v106 = v110;
      uint64_t v105 = v110;
      *((void *)v111 + 2) = v110;
      uint64_t v104 = v106;
      *((void *)v111 + _dispatch_source_set_handler((uint64_t)source, handler, 2LL, 1) = v114;
      __src[0] = v108;
      __src[1] = v107;
      __src[2] = 1;
      LOBYTE(__src[3]) = *(_BYTE *)(v116 + 12);
      HIBYTE(__src[3]) &= ~1u;
      HIBYTE(__src[3]) = HIBYTE(__src[3]) & 0xFD | (2 * (*(_BYTE *)(v116 + 14) & 1));
      HIBYTE(__src[3]) = HIBYTE(__src[3]) & 0xFB | (4 * ((*(_BYTE *)(v116 + 14) & 2) != 0));
      HIBYTE(__src[3]) &= 7u;
      memcpy(v117, __src, 8uLL);
      if (v115) {
        *BOOL v115 = &v117[v107];
      }
      __int16 v71 = v111;
      BOOL v48 = 0;
      unint64_t v47 = v68;
      while (1)
      {
        unint64_t v6 = _os_atomic_mo_has_acquire(3) ? __ldaxr(v47) : __ldxr(v47);
        unint64_t v73 = v6;
        if ((v6 & 0x3F0000000000LL) != 0) {
          break;
        }
        LODWORD(v46) = 0;
        WORD2(v46) = v74;
        HIWORD(v46) = HIWORD(v73) + 1;
        unint64_t v72 = v46;
        if (_os_atomic_mo_has_release(3)) {
          BOOL v48 = __stlxr(v72, v47) == 0;
        }
        else {
          BOOL v48 = __stxr(v72, v47) == 0;
        }
        if (v48) {
          goto LABEL_30;
        }
      }

      __clrex();
LABEL_30:
      BOOL v45 = v48;
      BOOL v66 = v48;
    }

    if (!v66)
    {
      unint64_t v44 = 0LL;
      uint64_t v43 = 0LL;
      unint64_t v7 = atomic_load(v68);
      unint64_t v41 = v7;
      unint64_t v42 = v7;
      unint64_t v40 = v7;
      unint64_t v44 = v68[1];
      v68[1] = 0LL;
      uint64_t v43 = mach_continuous_time();
      char v102 = v65;
      uint64_t v101 = v76;
      BOOL v100 = v75;
      unint64_t v99 = v67;
      unint64_t v98 = &v70;
      unint64_t v97 = v44;
      __int16 v96 = 0LL;
      unint64_t v95 = 0LL;
      __int16 v94 = 24;
      __int16 v93 = 16;
      unsigned __int16 v92 = 4096;
      if (&v70)
      {
        __int16 v91 = 24;
        unint64_t v90 = 0LL;
        unint64_t v89 = 0LL;
        __int16 v88 = 0;
        if (*(void *)v101 >= v97) {
          unint64_t v23 = v97;
        }
        else {
          unint64_t v23 = *(void *)v101;
        }
        unint64_t v89 = v23;
        unint64_t v123 = v23;
        if (v23 <= 0x1000000000LL) {
          unint64_t v22 = 0LL;
        }
        else {
          unint64_t v22 = v123 - 0x1000000000LL;
        }
        v102[1] = v22;
        unint64_t v8 = *(void *)v101;
        unsigned int v128 = v102;
        unint64_t v127 = v8;
        if ((v8 - v102[1]) >> 48) {
          v102[1] = *(void *)v101 - 0x1000000000LL;
        }
        *unint64_t v98 = v102 + 2;
        BOOL v126 = v102;
        unint64_t v125 = v97;
        if ((v97 - v102[1]) >> 48) {
          unint64_t v21 = *(void *)v101;
        }
        else {
          unint64_t v21 = v97;
        }
        unint64_t v90 = v21;
        unint64_t v95 = v21 - v102[1];
        v95 |= 0x18000000000000uLL;
        unint64_t v87 = v95;
        uint64_t v9 = *v98;
        unint64_t v86 = v95;
        v9[2] = v95;
        unint64_t v85 = v87;
        (*v98)[1] = v99;
        __int16 v88 = 48;
        v93 += 48;
        __int16 v96 = (char *)(v102 + 8);
      }

      else
      {
        unint64_t v124 = *(void *)v101;
        if (v124 <= 0x1000000000LL) {
          unint64_t v20 = 0LL;
        }
        else {
          unint64_t v20 = v124 - 0x1000000000LL;
        }
        v102[1] = v20;
        __int16 v96 = (char *)(v102 + 2);
      }

      else {
        LOWORD(v19) = *(_WORD *)(v101 + 8) + 24;
      }
      v93 += v19;
      v92 -= *(_WORD *)(v101 + 10);
      unint64_t v95 = *(void *)v101 - v102[1];
      v95 |= (unint64_t)*(unsigned __int16 *)(v101 + 8) << 48;
      unint64_t v84 = v95;
      unint64_t v83 = v95;
      *((void *)v96 + 2) = v95;
      unint64_t v82 = v84;
      *((void *)v96 + _dispatch_source_set_handler((uint64_t)source, handler, 2LL, 1) = v99;
      v81[0] = v93;
      v81[1] = v92;
      v81[2] = 1;
      LOBYTE(v81[3]) = *(_BYTE *)(v101 + 12);
      HIBYTE(v81[3]) &= ~1u;
      HIBYTE(v81[3]) = HIBYTE(v81[3]) & 0xFD | (2 * (*(_BYTE *)(v101 + 14) & 1));
      HIBYTE(v81[3]) = HIBYTE(v81[3]) & 0xFB | (4 * ((*(_BYTE *)(v101 + 14) & 2) != 0));
      HIBYTE(v81[3]) &= 7u;
      memcpy(v102, v81, sizeof(void));
      if (v100) {
        *BOOL v100 = (char *)v102 + v92;
      }
      __int16 v71 = v96;
      BOOL v39 = 0;
      __int16 v38 = v68;
      do
      {
        if (_os_atomic_mo_has_acquire(3)) {
          unint64_t v10 = __ldaxr(v38);
        }
        else {
          unint64_t v10 = __ldxr(v38);
        }
        unint64_t v73 = v10;
        LODWORD(v37) = 0;
        WORD2(v37) = v74;
        HIWORD(v37) = HIWORD(v10) + 1;
        unint64_t v72 = v37;
        if (_os_atomic_mo_has_release(3)) {
          BOOL v39 = __stlxr(v72, v38) == 0;
        }
        else {
          BOOL v39 = __stxr(v72, v38) == 0;
        }
      }

      while (!v39);
      BOOL v36 = v39;
      int v35 = 0;
      v33[0] = v44;
      v33[1] = v43;
      int v34 = BYTE5(v73) & 0x3F;
      __memcpy_chk(v70 + 3, v33, 24LL, -1LL);
      LODWORD(v32) = 7;
      HIDWORD(v32) = *(unsigned __int8 *)(v76 + 12);
      atomic_store(v32, v70);
    }
  }

  else if ((*v68 & 0x400000000000LL) != 0)
  {
    do
    {
      if (_os_atomic_mo_has_acquire(0)) {
        unint64_t v12 = __ldaxr(v68);
      }
      else {
        unint64_t v12 = __ldxr(v68);
      }
      unint64_t v73 = v12;
      LODWORD(v28) = 0;
      BYTE4(v28) = 0;
      if ((BYTE5(v12) & 0x3Fu) + 1 >= 0x3F) {
        char v17 = 63;
      }
      else {
        char v17 = (BYTE5(v73) & 0x3F) + 1;
      }
      BYTE5(v28) = v17 & 0x3F | 0x40;
      HIWORD(v28) = HIWORD(v73);
      unint64_t v72 = v28;
      if (_os_atomic_mo_has_release(0)) {
        BOOL v29 = __stlxr(v72, v68) == 0;
      }
      else {
        BOOL v29 = __stxr(v72, v68) == 0;
      }
    }

    while (!v29);
  }

  else
  {
    v68[1] = mach_continuous_time();
    do
    {
      if (_os_atomic_mo_has_acquire(3)) {
        unint64_t v11 = __ldaxr(v68);
      }
      else {
        unint64_t v11 = __ldxr(v68);
      }
      unint64_t v73 = v11;
      LODWORD(v3_dispatch_source_set_handler((uint64_t)source, handler, 2LL, 0) = 0;
      BYTE4(v3_dispatch_source_set_handler((uint64_t)source, handler, 2LL, 0) = 0;
      if ((BYTE5(v11) & 0x3Fu) + 1 >= 0x3F) {
        char v18 = 63;
      }
      else {
        char v18 = (BYTE5(v73) & 0x3F) + 1;
      }
      BYTE5(v3_dispatch_source_set_handler((uint64_t)source, handler, 2LL, 0) = v18 & 0x3F | 0x40;
      HIWORD(v3_dispatch_source_set_handler((uint64_t)source, handler, 2LL, 0) = HIWORD(v73);
      unint64_t v72 = v30;
      if (_os_atomic_mo_has_release(3)) {
        BOOL v31 = __stlxr(v72, v68) == 0;
      }
      else {
        BOOL v31 = __stxr(v72, v68) == 0;
      }
    }

    while (!v31);
  }

  uint64_t v13 = *(void *)(v76 + 8);
  unint64_t v121 = *(void *)v76;
  uint64_t v120 = v13;
  unint64_t v119 = v73;
  unint64_t v118 = v72;
  unsigned int v133 = 772145172;
  unint64_t v132 = v121;
  uint64_t v131 = v13;
  unint64_t v130 = v73;
  unint64_t v129 = v72;
  if (MEMORY[0xFFFFFC100]) {
    kdebug_trace(v133, v132, v131, v130, v129);
  }
  if ((v73 & 3) != 0) {
    _dispatch_gate_broadcast_slow((uint64_t)v68, v73);
  }
  if (BYTE4(v73) == 255) {
    firehose_buffer_update_limits(v77);
  }
  if (*((_BYTE *)v69 + 1568) == 1)
  {
    uint64_t v14 = (unsigned __int8 *)(v69 + 196);
    do
      int v15 = __ldaxr(v14);
    while (v15 == 1 && __stlxr(2u, v14));
  }

  return v71;
}

char *firehose_buffer_tracepoint_reserve_wait_for_chunks_from_logd( void *a1, uint64_t a2, void *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t v51 = a1;
  uint64_t v50 = a2;
  unint64_t v49 = a3;
  char v48 = 0;
  char v48 = *(_BYTE *)(a2 + 14) & 1;
  unsigned __int8 v47 = v48 & 1;
  unint64_t v46 = a1 + 56;
  unint64_t v45 = 0LL;
  int v42 = 5;
  do
  {
    int v8 = v42--;
    BOOL v41 = 0;
    if (v8) {
      BOOL v41 = firehose_drain_notifications_once((uint64_t)v51);
    }
  }

  while (v41);
  if (((*(_BYTE *)(v50 + 13) ^ 1) & 1) == 0)
  {
    unsigned __int8 v43 = *((_BYTE *)v46 + 4);
    goto LABEL_26;
  }

  unint64_t v45 = *v46;
  while (1)
  {
    BOOL v66 = v51;
    char v65 = v48 & 1;
    uint64_t v64 = &v45;
    BOOL v63 = 0;
    uint64_t v62 = v51 + 56;
    unint64_t v61 = v45;
    unint64_t v60 = 0LL;
    do
    {
      if (!*((_WORD *)&v61 + (v65 & 1)))
      {
        char v67 = 0;
        goto LABEL_17;
      }

      unint64_t v60 = v61;
      --*((_WORD *)&v60 + (v65 & 1));
      unint64_t v59 = v61;
      BOOL v58 = 0;
      uint64_t v9 = v62;
      unint64_t v56 = v60;
      unint64_t v55 = v60;
      unint64_t v57 = v60;
      unint64_t v10 = v61;
      unint64_t v11 = v60;
      do
        unint64_t v12 = __ldaxr(v9);
      while (v12 == v10 && __stlxr(v11, v9));
      if (v12 != v10) {
        unint64_t v59 = v12;
      }
      BOOL v54 = v12 == v10;
      BOOL v58 = v12 == v10;
      unint64_t v61 = v59;
      BOOL v53 = v58;
      BOOL v63 = v12 == v10;
    }

    while (v12 != v10);
    *uint64_t v64 = v60;
    char v67 = 1;
LABEL_17:
    if ((v67 & 1) != 0) {
      break;
    }
    if ((*(_BYTE *)(v50 + 14) & 2) != 0) {
      __FIREHOSE_CLIENT_THROTTLED_DUE_TO_HEAVY_LOGGING__(v51, v48 & 1, &v45, a4, a5, a6, a7, a8);
    }
    else {
      firehose_client_send_push_and_wait(v51, v48 & 1, &v45, a4, a5, a6, a7, a8);
    }
    if (*((_DWORD *)v51 + v47 + 388) == -1) {
      return 0LL;
    }
  }

  unsigned __int8 v43 = BYTE4(v45);
  do
  {
LABEL_26:
    while (1)
    {
      unint64_t v99 = v51;
      unint64_t v98 = 0LL;
      unint64_t v97 = 0LL;
      __int16 v96 = 0LL;
      __int16 v95 = 0;
      __int16 v94 = 0;
      unsigned __int16 v93 = 0;
      unsigned __int8 v92 = 0;
      __int16 v91 = 0LL;
      BOOL v90 = 0;
      int v89 = 0;
      __int16 v88 = v51 + 32;
      do
      {
        if (_os_atomic_mo_has_acquire(0)) {
          unint64_t v13 = __ldaxr(v88);
        }
        else {
          unint64_t v13 = __ldxr(v88);
        }
        unint64_t v97 = v13;
        unint64_t v98 = v13;
        if ((unsigned __int16)v97 == WORD1(v97))
        {
          if (WORD2(v97) == HIWORD(v97))
          {
            __clrex();
            unsigned __int8 v100 = 0;
            goto LABEL_57;
          }

          ++WORD2(v98);
        }

        else
        {
          LOWORD(v98) = v98 + 1;
        }

        if (_os_atomic_mo_has_release(0))
        {
          LOBYTE(v89) = __stlxr(v98, v88) == 0;
          int v89 = v89;
        }

        else
        {
          LOBYTE(v89) = __stxr(v98, v88) == 0;
          int v89 = v89;
        }
      }

      while (!v89);
      int v87 = v89;
      BOOL v90 = WORD2(v98) != WORD2(v97);
      if (WORD2(v98) == WORD2(v97))
      {
        __int16 v96 = v99;
        unsigned __int16 v93 = v97 & 0x3F;
      }

      else
      {
        __int16 v96 = v99 + 16;
        unsigned __int16 v93 = BYTE4(v97) & 0x3F;
      }

      int v86 = 0;
      mach_msg_timeout_t option_time = -1024;
      while (1)
      {
        __int16 v94 = *((_WORD *)v96 + v93);
        int v86 = v94 & 0x3F;
        if (v86) {
          break;
        }
        int v14 = option_time++;
        if (v14 < 0) {
          __yield();
        }
        else {
          thread_switch(0, 4, option_time);
        }
      }

      int v84 = v86;
      __int16 v95 = (v94 & 0xFFC0) + 64;
      unsigned __int8 v92 = v94 & 0x3F;
      char v102 = v99;
      char v101 = v94 & 0x3F;
      __int16 v91 = &v99[512 * (unint64_t)(v94 & 0x3F)];
      if (!v90 && *((_BYTE *)v91 + 6) == 3)
      {
        uint64_t v82 = ~(1LL << v92);
        uint64_t v81 = v82;
        uint64_t v83 = v82;
        unint64_t v79 = 0LL;
        __int16 v38 = v99 + 57;
        uint64_t v77 = v82;
        uint64_t v76 = v82;
        uint64_t v78 = v82;
        uint64_t v39 = v82;
        unint64_t v40 = v99[57];
        do
        {
          unint64_t v15 = v40;
          do
            unint64_t v16 = __ldaxr(v38);
          while (v16 == v40 && __stlxr(v40 & v39, v38));
          unint64_t v40 = v16;
        }

        while (v16 != v15);
        unint64_t v75 = v16;
        unint64_t v79 = v16;
        unint64_t v74 = v16;
        unint64_t v80 = v16 & v83;
      }

      uint64_t v73 = 0x100000000000000LL;
      uint64_t v72 = 0x100000000000000LL;
      *__int16 v91 = 0x100000000000000LL;
      uint64_t v71 = v73;
      __int16 v70 = v95;
      __int16 v69 = v95;
      *((_WORD *)v96 + v93) = v95;
      __int16 v68 = v70;
      unsigned __int8 v100 = v92;
LABEL_57:
      unsigned __int8 v44 = v100;
      if (!v100) {
        break;
      }
      if (v100 >= (int)v43)
      {
        __int16 v108 = v51;
        unsigned __int8 v107 = v100;
        uint64_t v106 = 0x4000LL;
        uint64_t v105 = 15LL;
        uint64_t v104 = v51 + 67;
        uint64_t v103 = 0LL;
        unsigned int v117 = (unsigned int *)(v51 + 67);
        unsigned int v116 = 0;
        unsigned int v135 = _dispatch_thread_getspecific(3uLL);
        unsigned int v116 = v135 & 0xFFFFFFFC;
        unsigned int v115 = 0;
        BOOL v114 = 0;
        char v17 = v117;
        unsigned int v112 = v135 & 0xFFFFFFFC;
        unsigned int v111 = v135 & 0xFFFFFFFC;
        unsigned int v113 = v135 & 0xFFFFFFFC;
        unsigned int v18 = v135 & 0xFFFFFFFC;
        do
          unsigned int v19 = __ldaxr(v17);
        while (!v19 && __stlxr(v18, v17));
        if (v19) {
          unsigned int v115 = v19;
        }
        BOOL v110 = v19 == 0;
        BOOL v114 = v19 == 0;
        BOOL v109 = v114;
        if (v19) {
          _dispatch_unfair_lock_lock_slow(v117, 0x10000);
        }
        if (v107 >= (int)*((unsigned __int8 *)v108 + 532))
        {
          uint64_t v20 = v108[65] & ~(1LL << v107);
          v108[65] = v20;
          uint64_t v103 = v20;
          v107 &= 0xFCu;
          if ((v20 & (15LL << v107)) == 0)
          {
            uint64_t v120 = v108;
            unsigned __int8 v119 = v107;
            madvise(&v108[512 * (unint64_t)v107], 0x4000uLL, 5);
          }

          unsigned __int8 v107 = 0;
        }

        unint64_t v118 = v104;
        int v156 = (unsigned int *)v104;
        unsigned int v155 = 0;
        unsigned int v154 = 0;
        unsigned int v158 = _dispatch_thread_getspecific(3uLL);
        unsigned int v154 = v158 & 0xFFFFFFFC;
        unsigned int v153 = 0;
        BOOL v36 = v156;
        int v151 = 0;
        int v150 = 0;
        int v152 = 0;
        unsigned int v37 = *v156;
        do
        {
          unsigned int v21 = v37;
          do
            unsigned int v22 = __ldaxr(v36);
          while (v22 == v37 && __stlxr(0, v36));
          unsigned int v37 = v22;
        }

        while (v22 != v21);
        unsigned int v149 = v22;
        unsigned int v153 = v22;
        unsigned int v148 = v22;
        unsigned int v155 = v22;
        if (v22 == v154)
        {
          BOOL v157 = 0;
        }

        else
        {
          _dispatch_unfair_lock_unlock_slow((uint64_t)v156, v155);
          unsigned int v159 = v155;
          BOOL v157 = (v155 & 2) != 0;
        }

        unsigned __int8 v44 = v107;
        if (!v107) {
          continue;
        }
      }

      return firehose_buffer_stream_chunk_install(v51, v50, v49, v44);
    }

    unint64_t v124 = v46;
    __int16 v123 = v43;
    unsigned __int8 v122 = 0;
    unint64_t v121 = 0LL;
    unsigned int v133 = (unsigned int *)(v46 + 11);
    unsigned int v132 = 0;
    unsigned int v136 = _dispatch_thread_getspecific(3uLL);
    unsigned int v132 = v136 & 0xFFFFFFFC;
    unsigned int v131 = 0;
    BOOL v130 = 0;
    unint64_t v23 = v133;
    unsigned int v128 = v136 & 0xFFFFFFFC;
    unsigned int v127 = v136 & 0xFFFFFFFC;
    unsigned int v129 = v136 & 0xFFFFFFFC;
    unsigned int v24 = v136 & 0xFFFFFFFC;
    do
      unsigned int v25 = __ldaxr(v23);
    while (!v25 && __stlxr(v24, v23));
    if (v25) {
      unsigned int v131 = v25;
    }
    BOOL v126 = v25 == 0;
    BOOL v130 = v25 == 0;
    BOOL v125 = v130;
    if (v25) {
      _dispatch_unfair_lock_lock_slow(v133, 0x10000);
    }
    unint64_t v121 = ~(v124[9] | (-1LL << v123));
    if (v121)
    {
      unint64_t v161 = v121;
      BOOL v163 = v121 != 0;
      uint64_t v162 = 45LL;
      unsigned __int8 v122 = __clz(__rbit64(v121));
      v124[9] |= (1 << v122);
    }

    unint64_t v134 = v124 + 11;
    uint64_t v145 = (unsigned int *)(v124 + 11);
    unsigned int v144 = 0;
    unsigned int v143 = 0;
    unsigned int v147 = _dispatch_thread_getspecific(3uLL);
    unsigned int v143 = v147 & 0xFFFFFFFC;
    unsigned int v142 = 0;
    int v34 = v145;
    int v140 = 0;
    int v139 = 0;
    int v141 = 0;
    unsigned int v35 = *v145;
    do
    {
      unsigned int v31 = v35;
      do
        unsigned int v32 = __ldaxr(v34);
      while (v32 == v35 && __stlxr(0, v34));
      unsigned int v35 = v32;
    }

    while (v32 != v31);
    unsigned int v138 = v32;
    unsigned int v142 = v32;
    unsigned int v137 = v32;
    unsigned int v144 = v32;
    if (v32 == v143)
    {
      BOOL v146 = 0;
    }

    else
    {
      _dispatch_unfair_lock_unlock_slow((uint64_t)v145, v144);
      unsigned int v160 = v144;
      BOOL v146 = (v144 & 2) != 0;
    }

    unsigned __int8 v44 = v122;
    if (v122) {
      break;
    }
    if ((*(_BYTE *)(v50 + 14) & 2) != 0) {
      __FIREHOSE_CLIENT_THROTTLED_DUE_TO_HEAVY_LOGGING__(v51, v48 & 1, 0LL, v26, v27, v28, v29, v30);
    }
    else {
      firehose_client_send_push_and_wait(v51, v48 & 1, 0LL, v26, v27, v28, v29, v30);
    }
  }

  while (*((_DWORD *)v51 + v47 + 388) != -1);
  return firehose_buffer_stream_chunk_install(v51, v50, v49, v44);
}

void firehose_client_start_quarantine(mach_port_context_t a1)
{
  if (*(uint64_t *)_voucher_libtrace_hooks > 4 && *(void *)(_voucher_libtrace_hooks + 40))
  {
    (*(void (**)(void))(_voucher_libtrace_hooks + 40))();
    *(_BYTE *)(a1 + 1569) = 1;
    unsigned __int8 v43 = (unint64_t *)(a1 + 768);
    unint64_t v42 = *(void *)(a1 + 768);
    if (BYTE4(v42) && BYTE4(*(void *)(a1 + 768)) != 255)
    {
      unint64_t v57 = (unint64_t *)(a1 + ((unint64_t)BYTE4(v42) << 12));
      uint64_t v56 = -1LL;
      unsigned __int8 v55 = 1;
      unsigned __int8 v54 = 0;
      unsigned __int16 v53 = 1;
      unsigned __int16 v52 = 0;
      unint64_t v51 = 0LL;
      __int16 v50 = 24;
      unint64_t v49 = 0LL;
      unint64_t v48 = 0LL;
      BOOL v46 = (-1LL - v57[1]) >> 48 == 0;
      unsigned __int8 v44 = v57;
      do
      {
        if (_os_atomic_mo_has_acquire(0)) {
          unint64_t v15 = __ldaxr(v44);
        }
        else {
          unint64_t v15 = __ldxr(v44);
        }
        unint64_t v49 = v15;
        if (!v15 || (HIWORD(v49) & 0x1FF) != (unint64_t)v55)
        {
          __clrex();
          uint64_t v58 = 0LL;
          goto LABEL_35;
        }

        unint64_t v48 = v49;
        uint64_t v104 = &v49;
        unsigned __int16 v103 = v53 + v52 + 24;
        if ((unsigned __int16)v49 + v103 <= WORD1(v49) && v46)
        {
          if ((((_BYTE)v53 + 24) & 7) != 0) {
            int v30 = ((v53 + 24) & 0x1FFF8) + 8;
          }
          else {
            int v30 = v53 + 24;
          }
          v48 += v30;
          v48 -= (unint64_t)v52 << 16;
          v48 += 0x100000000LL;
          char v102 = &v48;
          __int16 v101 = 40;
          char v47 = 0;
        }

        else
        {
          HIBYTE(v48) |= 1u;
          char v47 = 1;
        }

        if (_os_atomic_mo_has_release(0)) {
          BOOL v45 = __stlxr(v48, v44) == 0;
        }
        else {
          BOOL v45 = __stxr(v48, v44) == 0;
        }
      }

      while (!v45);
      if ((v47 & 1) != 0)
      {
        if (BYTE4(v48)) {
          uint64_t v58 = 0LL;
        }
        else {
          uint64_t v58 = -1LL;
        }
      }

      else
      {
        if (v51) {
          *unint64_t v51 = (char *)v57 + WORD1(v48);
        }
        uint64_t v58 = (unsigned __int16)v49;
      }

LABEL_74:
      uint64_t v36 = v75;
      if (v75 < 0) {
        firehose_buffer_ring_enqueue(a1, BYTE4(v38));
      }
      if (v36 >= 1)
      {
        qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: Allocation should always fail";
        qword_E4DA8 = v36;
        __break(1u);
        JUMPOUT(0xA57A8LL);
      }

      unint64_t v37 = v38;
      BYTE4(v37) = 0;
      do
        unint64_t v25 = __ldaxr(v39);
      while (v25 == v38 && __stlxr(v37, v39));
    }

    else
    {
      firehose_buffer_force_connect(a1, v8, v9, v10, v11, v12, v13, v14);
    }

    unsigned int v35 = (unint64_t *)(a1 + 896);
    unint64_t v34 = *(void *)(a1 + 896);
    if (BYTE4(v34) && BYTE4(*(void *)(a1 + 896)) != 255)
    {
      __int16 v91 = (unint64_t *)(a1 + ((unint64_t)BYTE4(v34) << 12));
      uint64_t v90 = -1LL;
      unsigned __int8 v89 = 2;
      unsigned __int8 v88 = 0;
      unsigned __int16 v87 = 1;
      unsigned __int16 v86 = 0;
      unint64_t v85 = 0LL;
      __int16 v84 = 24;
      unint64_t v83 = 0LL;
      unint64_t v82 = 0LL;
      char v81 = 0;
      BOOL v80 = 0;
      BOOL v80 = (-1LL - v91[1]) >> 48 == 0;
      BOOL v79 = 0;
      uint64_t v78 = v91;
      do
      {
        if (_os_atomic_mo_has_acquire(0)) {
          unint64_t v26 = __ldaxr(v78);
        }
        else {
          unint64_t v26 = __ldxr(v78);
        }
        unint64_t v83 = v26;
        if (!v26 || (HIWORD(v83) & 0x1FF) != (unint64_t)v89)
        {
          __clrex();
          uint64_t v92 = 0LL;
          goto LABEL_113;
        }

        unint64_t v82 = v83;
        __int16 v96 = &v83;
        unsigned __int16 v95 = v87 + v86 + 24;
        if ((unsigned __int16)v83 + v95 <= WORD1(v83) && v80)
        {
          if ((((_BYTE)v87 + 24) & 7) != 0) {
            int v28 = ((v87 + 24) & 0x1FFF8) + 8;
          }
          else {
            int v28 = v87 + 24;
          }
          v82 += v28;
          v82 -= (unint64_t)v86 << 16;
          v82 += 0x100000000LL;
          __int16 v77 = 16;
          __int16 v94 = &v82;
          __int16 v93 = 40;
          char v81 = 0;
        }

        else
        {
          HIBYTE(v82) |= 1u;
          char v81 = 1;
        }

        if (_os_atomic_mo_has_release(0)) {
          BOOL v79 = __stlxr(v82, v78) == 0;
        }
        else {
          BOOL v79 = __stxr(v82, v78) == 0;
        }
      }

      while (!v79);
      BOOL v76 = v79;
      if ((v81 & 1) != 0)
      {
        if (BYTE4(v82)) {
          uint64_t v92 = 0LL;
        }
        else {
          uint64_t v92 = -1LL;
        }
      }

      else
      {
        if (v85) {
          *unint64_t v85 = (char *)v91 + WORD1(v82);
        }
        uint64_t v92 = (unsigned __int16)v83;
      }

LABEL_113:
      uint64_t v32 = v92;
      if (v92 < 0) {
        firehose_buffer_ring_enqueue(a1, BYTE4(v34));
      }
      if (v32 >= 1)
      {
        qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: Allocation should always fail";
        qword_E4DA8 = v32;
        __break(1u);
        JUMPOUT(0xA5C98LL);
      }

      unint64_t v33 = v34;
      BYTE4(v33) = 0;
      do
        unint64_t v27 = __ldaxr(v35);
      while (v27 == v34 && __stlxr(v33, v35));
    }

    else
    {
      firehose_buffer_force_connect(a1, v17, v18, v19, v20, v21, v22, v23);
    }
  }

void __FIREHOSE_CLIENT_THROTTLED_DUE_TO_HEAVY_LOGGING__( void *a1, char a2, void *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void firehose_client_send_push_and_wait( void *a1, char a2, void *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v36 = a1;
  char v35 = a2;
  unint64_t v34 = a3;
  unsigned __int8 v33 = a2 & 1;
  int v32 = 0;
  int v32 = *((_DWORD *)a1 + (a2 & 1) + 388);
  __int128 __s1 = 0uLL;
  int v30 = 0;
  int v29 = 0;
  if (v32 == -1) {
    return;
  }
  if (v32)
  {
    int v29 = firehose_send_push_and_wait(v32, &__s1, &v30);
    if (!v29) {
      goto LABEL_23;
    }
    if (v29 != 268435459)
    {
      if (v29 == -301)
      {
        qword_E4D78 = (uint64_t)"MIG_REPLY_MISMATCH";
        qword_E4DA8 = -301LL;
        __break(1u);
        JUMPOUT(0xA5EA4LL);
      }

      int v28 = v29;
      uint64_t v40 = v29;
      uint64_t v39 = 681LL;
      _dispatch_bug(v39, v40, v8, a4, a5, a6, a7, a8);
      int v27 = v28;
    }
  }

  int v32 = firehose_client_reconnect((mach_port_context_t)v36, v32, v33, a4, a5, a6, a7, a8);
  BOOL v23 = 0;
  if (v32) {
    BOOL v23 = v32 != -1;
  }
  if (!v23) {
    goto LABEL_20;
  }
  int v29 = firehose_send_push_and_wait(v32, &__s1, &v30);
  if (v29)
  {
    if (v29 != 268435459)
    {
      if (v29 == -301)
      {
        qword_E4D78 = (uint64_t)"MIG_REPLY_MISMATCH";
        qword_E4DA8 = -301LL;
        __break(1u);
        JUMPOUT(0xA5FC8LL);
      }

      int v26 = v29;
      uint64_t v38 = v29;
      uint64_t v37 = 693LL;
      _dispatch_bug(v37, v38, v9, v10, v11, v12, v13, v14);
      int v25 = v26;
    }

LABEL_23:
  __s2[0] = -1LL;
  __s2[1] = -1LL;
  if (!memcmp(&__s1, __s2, 0x10uLL))
  {
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Memory corruption in the logging buffers";
    __break(1u);
    JUMPOUT(0xA60ACLL);
  }

  if ((v35 & 1) != 0)
  {
    uint64_t v21 = v36 + 63;
    unint64_t v22 = v36[63];
    do
    {
      unint64_t v15 = v22;
      do
        unint64_t v16 = __ldaxr(v21);
      while (v16 == v22 && __stlxr(v22 + 1, v21));
      unint64_t v22 = v16;
    }

    while (v16 != v15);
  }

  else
  {
    uint64_t v19 = v36 + 60;
    unint64_t v20 = v36[60];
    do
    {
      unint64_t v17 = v20;
      do
        unint64_t v18 = __ldaxr(v19);
      while (v18 == v20 && __stlxr(v20 + 1, v19));
      unint64_t v20 = v18;
    }

    while (v18 != v17);
  }

  firehose_client_merge_updates((uint64_t)v36, 0, __s1, *((unint64_t *)&__s1 + 1), v30 != 0, v34);
}

uint64_t _dispatch_iocntl(uint64_t result)
{
  unint64_t v1 = (result - 1);
  if (v1 <= 3) {
    __asm { BR              X8 }
  }

  return result;
}

void _dispatch_io_dispose( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(void *)(a1 + 112) && (*(_DWORD *)(a1 + 120) & 3) == 0)
  {
    if (*(void *)(*(void *)(a1 + 112) + 8LL)) {
      **(void **)(*(void *)(a1 + 112) + 8LL) = 0LL;
    }
    _dispatch_fd_entry_release(*(void *)(a1 + 112));
  }

  if (*(void *)(a1 + 48)) {
    dispatch_release(*(dispatch_object_t *)(a1 + 48));
  }
  if (*(void *)(a1 + 56)) {
    dispatch_release(*(dispatch_object_t *)(a1 + 56));
  }
  if (*(void *)(a1 + 64)) {
    dispatch_release(*(dispatch_object_t *)(a1 + 64));
  }
}

void _dispatch_fd_entry_release(uint64_t a1)
{
}

dispatch_io_t dispatch_io_create( dispatch_io_type_t type, dispatch_fd_t fd, dispatch_queue_t queue, void *cleanup_handler)
{
  dispatch_io_type_t v38 = type;
  dispatch_fd_t v37 = fd;
  dispatch_queue_t v36 = queue;
  char v35 = cleanup_handler;
  if (type && v38 != 1) {
    return 0LL;
  }
  unint64_t v34 = _dispatch_io_create(v38, *(uint64_t *)&fd, (uint64_t)queue, (uint64_t)cleanup_handler, v4, v5, v6, v7);
  *((_DWORD *)v34 + 3_dispatch_source_set_handler((uint64_t)source, handler, 2LL, 1) = v37;
  _dispatch_thread_getspecific(0LL);
  _dispatch_log("%u\t%p\tchannel[%p]: create", v8, v9, v10, v11, v12, v13, v14, 363LL);
  *((_DWORD *)v34 + 32) = v37;
  dispatch_object_t v33 = (dispatch_object_t)v34[6];
  dispatch_suspend(v33);
  dispatch_queue_t v32 = v36;
  _dispatch_retain((uint64_t)v36);
  unsigned int v31 = v34;
  _dispatch_retain((uint64_t)v34);
  unint64_t v22 = _NSConcreteStackBlock;
  int v23 = 1107296256;
  int v24 = 0;
  int v25 = __dispatch_io_create_block_invoke;
  int v26 = &__block_descriptor_tmp_1;
  int v28 = v34;
  dispatch_io_type_t v29 = v38;
  dispatch_queue_t v30 = v36;
  int v27 = v35;
  _dispatch_fd_entry_init_async(v37, (uint64_t)&v22);
  _dispatch_object_debug((uint64_t)v34, "%s", v15, v16, v17, v18, v19, v20, (char)"dispatch_io_create");
  return (dispatch_io_t)v34;
}

void *_dispatch_io_create( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = _dispatch_object_alloc((uint64_t)_OS_dispatch_io_vtable, 0x98uLL, a3, a4, a5, a6, a7, a8);
  v9[2] = -1985229329LL;
  v9[3] = &off_E46C0;
  v9[9] = a1;
  v9[11] = -1LL;
  v9[10] = qword_E4D30 * dispatch_io_defaults;
  v9[6] = dispatch_queue_create("com.apple.libdispatch-io.channelq", 0LL);
  return v9;
}

void _dispatch_fd_entry_init_async(int a1, uint64_t a2)
{
  int v10 = a1;
  uint64_t v9 = a2;
  uint64_t v13 = &_dispatch_io_init_pred;
  uint64_t v12 = 0LL;
  uint64_t v11 = _dispatch_io_queues_init;
  if (_dispatch_io_init_pred != -1LL) {
    dispatch_once_f(v13, v12, (dispatch_function_t)v11);
  }
  blocint k = _NSConcreteStackBlock;
  int v3 = 1107296256;
  int v4 = 0;
  uint64_t v5 = ___dispatch_fd_entry_init_async_block_invoke;
  uint64_t v6 = &__block_descriptor_tmp_125;
  int v8 = v10;
  uint64_t v7 = v9;
  dispatch_channel_async((dispatch_queue_t)_dispatch_io_fds_lockq, &block);
}

void __dispatch_io_create_block_invoke(uint64_t *a1, uint64_t a2)
{
  int v17 = *(_DWORD *)(a2 + 24);
  if (!v17) {
    int v17 = _dispatch_io_validate_type(a1[5], *(_WORD *)(a2 + 36));
  }
  if (!v17 && a1[6] == 1)
  {
    do
    {
      off_t v16 = lseek(*(_DWORD *)a2, 0LL, 1);
      if (v16 == -1) {
        int v14 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
      }
      else {
        int v14 = 0;
      }
      int v17 = v14;
      if (!v14)
      {
        *(void *)(a1[5] + 136) = v16;
        goto LABEL_13;
      }
    }

    while (v14 == 4);
    _dispatch_bug(389LL, v14, v2, v3, v4, v5, v6, v7);
  }

LABEL_13:
  *(_DWORD *)(a1[5] + 144) = v17;
  _dispatch_fd_entry_retain(a2);
  _dispatch_io_init((void *)a1[5], a2, a1[7], v17, a1[4]);
  dispatch_resume(*(dispatch_object_t *)(a1[5] + 48));
  _dispatch_object_debug(a1[5], "%s", v8, v9, v10, v11, v12, v13, (char)"dispatch_io_create_block_invoke");
  _dispatch_release((unsigned int *)a1[5]);
  _dispatch_release((unsigned int *)a1[7]);
}

uint64_t _dispatch_io_validate_type(uint64_t a1, __int16 a2)
{
  unsigned int v3 = 0;
  if ((a2 & 0xF000) == 0x4000)
  {
    return 21;
  }

  else if (*(void *)(a1 + 72) == 1LL && ((a2 & 0xF000) == 0x1000 || (a2 & 0xF000) == 0xC000))
  {
    return 29;
  }

  return v3;
}

void _dispatch_fd_entry_retain(uint64_t a1)
{
}

void _dispatch_io_init(void *a1, uint64_t a2, uint64_t a3, int a4, uint64_t a5)
{
  uint64_t v21 = a1;
  uint64_t v20 = a2;
  uint64_t v19 = a3;
  int v18 = a4;
  uint64_t v17 = a5;
  if (a5)
  {
    uint64_t v16 = v19;
    _dispatch_retain(v19);
    if (v18) {
      dispatch_queue_t queue = (dispatch_queue_s *)v21[6];
    }
    else {
      dispatch_queue_t queue = *(dispatch_queue_s **)(v20 + 64);
    }
    blocint k = _NSConcreteStackBlock;
    int v8 = 1107296256;
    int v9 = 0;
    uint64_t v10 = ___dispatch_io_init_block_invoke;
    uint64_t v11 = &__block_descriptor_tmp_65;
    uint64_t v13 = v19;
    int v14 = v21;
    int v15 = v18;
    uint64_t v12 = v17;
    dispatch_channel_async(queue, &block);
  }

  if (v20)
  {
    v21[14] = v20;
    dispatch_retain(*(dispatch_object_t *)(v20 + 72));
    dispatch_retain(*(dispatch_object_t *)(v20 + 80));
    v21[7] = *(void *)(v20 + 72);
    v21[8] = *(void *)(v20 + 80);
  }

  else
  {
    dispatch_queue_t v5 = dispatch_queue_create("com.apple.libdispatch-io.barrierq", 0LL);
    v21[7] = v5;
    v21[8] = dispatch_group_create();
  }

void __copy_helper_block_8_32b(uint64_t a1, uint64_t a2)
{
}

void __destroy_helper_block_8_32b(uint64_t a1)
{
}

dispatch_io_t dispatch_io_create_f( dispatch_io_type_t a1, dispatch_fd_t a2, dispatch_queue_s *a3, uint64_t a4, uint64_t a5)
{
  dispatch_io_type_t v17 = a1;
  dispatch_fd_t v16 = a2;
  int v15 = a3;
  uint64_t v14 = a4;
  uint64_t v13 = a5;
  if (!a5) {
    return dispatch_io_create(a1, a2, a3, 0LL);
  }
  uint64_t v6 = _NSConcreteStackBlock;
  int v7 = 0x40000000;
  int v8 = 0;
  int v9 = __dispatch_io_create_f_block_invoke;
  uint64_t v10 = &__block_descriptor_tmp_4;
  uint64_t v11 = v13;
  uint64_t v12 = v14;
  return dispatch_io_create(a1, a2, a3, &v6);
}

uint64_t __dispatch_io_create_f_block_invoke(uint64_t a1, unsigned int a2)
{
  return (*(uint64_t (**)(void, void))(a1 + 32))(*(void *)(a1 + 40), a2);
}

dispatch_io_t dispatch_io_create_with_path( dispatch_io_type_t type, const char *path, int oflag, mode_t mode, dispatch_queue_t queue, void *cleanup_handler)
{
  dispatch_io_type_t v47 = type;
  BOOL v46 = path;
  int v45 = oflag;
  mode_t v44 = mode;
  dispatch_queue_t v43 = queue;
  unint64_t v42 = cleanup_handler;
  if (type && v47 != 1) {
    return 0LL;
  }
  if (*v46 != 47) {
    return 0LL;
  }
  size_t v41 = strlen(v46);
  uint64_t v40 = malloc_type_malloc(v41 + 25, 1527294340LL);
  if (!v40) {
    return 0LL;
  }
  uint64_t v39 = _dispatch_io_create(v47, v6, v7, v8, v9, v10, v11, v12);
  *((_DWORD *)v39 + 3_dispatch_source_set_handler((uint64_t)source, handler, 2LL, 1) = -1;
  _dispatch_thread_getspecific(0LL);
  _dispatch_log("%u\t%p\tchannel[%p]: create with path %s", v13, v14, v15, v16, v17, v18, v19, 444LL);
  *((_DWORD *)v39 + 32) = -1;
  *(void *)uint64_t v40 = v39;
  *(_DWORD *)(v40 + 8) = v45;
  *(_WORD *)(v40 + 12) = v44;
  *(void *)(v40 + 16) = v41;
  __memcpy_chk(v40 + 24, v46, v41 + 1, -1LL);
  dispatch_queue_t v38 = v43;
  _dispatch_retain((uint64_t)v43);
  dispatch_fd_t v37 = v39;
  _dispatch_retain((uint64_t)v39);
  uint64_t v20 = (dispatch_queue_s *)v39[6];
  blocint k = _NSConcreteStackBlock;
  int v29 = 1107296256;
  int v30 = 0;
  unsigned int v31 = __dispatch_io_create_with_path_block_invoke;
  dispatch_queue_t v32 = &__block_descriptor_tmp_8;
  uint64_t v34 = v40;
  char v35 = v39;
  dispatch_queue_t v36 = v43;
  dispatch_object_t v33 = v42;
  dispatch_channel_async(v20, &block);
  _dispatch_object_debug((uint64_t)v39, "%s", v21, v22, v23, v24, v25, v26, (char)"dispatch_io_create_with_path");
  return (dispatch_io_t)v39;
}

void __dispatch_io_create_with_path_block_invoke(uint64_t a1)
{
  uint64_t v29 = a1;
  uint64_t v28 = a1;
  int v27 = 0;
  memset(&__b, 0, sizeof(__b));
  do
  {
    if ((*(_DWORD *)(*(void *)(a1 + 40) + 8LL) & 0x100) == 0x100
      || (*(_DWORD *)(*(void *)(a1 + 40) + 8LL) & 0x200000) == 0x200000)
    {
      int v9 = lstat((const char *)(*(void *)(a1 + 40) + 24LL), &__b);
    }

    else
    {
      int v9 = stat((const char *)(*(void *)(a1 + 40) + 24LL), &__b);
    }

    if (v9 == -1)
    {
      uint64_t v35 = 1LL;
      uint64_t v38 = 1LL;
      unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
      int v8 = **(_DWORD **)(StatusReg + 8);
    }

    else
    {
      int v8 = 0;
    }

    int v27 = v8;
    if (!v8)
    {
      int v27 = _dispatch_io_validate_type(*(void *)(a1 + 48), __b.st_mode);
      goto LABEL_31;
    }
  }

  while (v8 == 4);
  if ((*(_DWORD *)(*(void *)(a1 + 40) + 8LL) & 0x200) != 0
    && *(_BYTE *)(*(void *)(a1 + 40) + 24LL + *(void *)(*(void *)(a1 + 40) + 16LL) - 1) != 47)
  {
    uint64_t v25 = 0LL;
    uint64_t i = 0LL;
    for (uint64_t i = *(void *)(*(void *)(a1 + 40) + 16LL) - 1LL; i >= 0; --i)
    {
      if (*(_BYTE *)(*(void *)(a1 + 40) + 24LL + i) == 47)
      {
        uint64_t v25 = (_BYTE *)(*(void *)(a1 + 40) + 24LL + i);
        break;
      }
    }

    unsigned int v31 = v25;
    uint64_t v30 = 480LL;
    if (!v25) {
      _dispatch_abort(v30, 0LL, v1, v2, v3, v4, v5, v6);
    }
    *uint64_t v25 = 0;
    int v23 = 0;
    while (1)
    {
      if (stat((const char *)(*(void *)(a1 + 40) + 24LL), &__b) == -1)
      {
        uint64_t v36 = 1LL;
        uint64_t v37 = 1LL;
        unint64_t v40 = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
        int v7 = **(_DWORD **)(v40 + 8);
      }

      else
      {
        int v7 = 0;
      }

      int v23 = v7;
      if (!v7) {
        break;
      }
      if (v7 != 4) {
        goto LABEL_30;
      }
    }

    __b.st_mode = 0x8000;
    int v27 = 0;
LABEL_30:
    *uint64_t v25 = 47;
  }

dispatch_queue_t _dispatch_io_queues_init()
{
  _dispatch_io_fds_lockq = (uint64_t)dispatch_queue_create("com.apple.libdispatch-io.fd_lockq", 0LL);
  dispatch_queue_t result = dispatch_queue_create("com.apple.libdispatch-io.dev_lockq", 0LL);
  _dispatch_io_devs_lockq = (uint64_t)result;
  return result;
}

void __dispatch_io_create_with_path_block_invoke_2(uint64_t a1)
{
  int v8 = _dispatch_fd_entry_create_with_path(*(void *)(a1 + 40), *(_DWORD *)(a1 + 48), *(_WORD *)(a1 + 52));
  _dispatch_io_init(*(void **)(a1 + 192), (uint64_t)v8, *(void *)(a1 + 200), 0, *(void *)(a1 + 32));
  dispatch_resume(*(dispatch_object_t *)(*(void *)(a1 + 192) + 48LL));
  _dispatch_object_debug( *(void *)(a1 + 192),  "%s",  v1,  v2,  v3,  v4,  v5,  v6,  (char)"dispatch_io_create_with_path_block_invoke_2");
  _dispatch_release(*(unsigned int **)(a1 + 192));
  _dispatch_release(*(unsigned int **)(a1 + 200));
}

void *_dispatch_fd_entry_create_with_path(uint64_t a1, int a2, __int16 a3)
{
  uint64_t v34 = a1;
  int v33 = a2;
  __int16 v32 = a3;
  unsigned int v31 = 0LL;
  unsigned int v31 = (void *)_dispatch_fd_entry_create(*(dispatch_queue_s **)(*(void *)a1 + 48LL));
  _dispatch_thread_getspecific(0LL);
  _dispatch_log("%u\t%p\tfd_entry[%p]: create: path %s", v3, v4, v5, v6, v7, v8, v9, 1588LL);
  if ((v32 & 0xF000) == 0x8000) {
    _dispatch_disk_init(v31, HIBYTE(v33), v10, v11, v12, v13, v14, v15);
  }
  else {
    _dispatch_stream_init((uint64_t)v31, (dispatch_queue_s *)&off_E4640);
  }
  *(_DWORD *)unsigned int v31 = -1;
  *((_DWORD *)v31 + 4) = -1;
  v31[1] = v34;
  *((_DWORD *)v31 + 8) = v33;
  *((_WORD *)v31 + 18) = v32;
  v31[9] = dispatch_queue_create("com.apple.libdispatch-io.barrierq", 0LL);
  v31[10] = dispatch_group_create();
  uint64_t v16 = (dispatch_queue_s *)v31[8];
  blocint k = _NSConcreteStackBlock;
  int v26 = 0x40000000;
  int v27 = 0;
  uint64_t v28 = ___dispatch_fd_entry_create_with_path_block_invoke;
  uint64_t v29 = &__block_descriptor_tmp_141;
  uint64_t v30 = v31;
  dispatch_channel_async(v16, &block);
  uint64_t v17 = (dispatch_queue_s *)v31[8];
  uint64_t v19 = _NSConcreteStackBlock;
  int v20 = 0x40000000;
  int v21 = 0;
  uint64_t v22 = ___dispatch_fd_entry_create_with_path_block_invoke_2;
  int v23 = &__block_descriptor_tmp_142;
  uint64_t v24 = v31;
  dispatch_channel_async(v17, &v19);
  return v31;
}

dispatch_io_t dispatch_io_create_with_path_f( dispatch_io_type_t a1, const char *a2, int a3, mode_t a4, dispatch_queue_s *a5, uint64_t a6, uint64_t a7)
{
  dispatch_io_type_t v21 = a1;
  int v20 = a2;
  int v19 = a3;
  mode_t v18 = a4;
  uint64_t v17 = a5;
  uint64_t v16 = a6;
  uint64_t v15 = a7;
  if (!a7) {
    return dispatch_io_create_with_path(a1, a2, a3, a4, a5, 0LL);
  }
  uint64_t v8 = _NSConcreteStackBlock;
  int v9 = 0x40000000;
  int v10 = 0;
  uint64_t v11 = __dispatch_io_create_with_path_f_block_invoke;
  uint64_t v12 = &__block_descriptor_tmp_9;
  uint64_t v13 = v15;
  uint64_t v14 = v16;
  return dispatch_io_create_with_path(a1, a2, a3, a4, a5, &v8);
}

uint64_t __dispatch_io_create_with_path_f_block_invoke(uint64_t a1, unsigned int a2)
{
  return (*(uint64_t (**)(void, void))(a1 + 32))(*(void *)(a1 + 40), a2);
}

dispatch_io_t dispatch_io_create_with_io( dispatch_io_type_t type, dispatch_io_t io, dispatch_queue_t queue, void *cleanup_handler)
{
  dispatch_io_type_t v41 = type;
  dispatch_io_t v40 = io;
  dispatch_queue_t v39 = queue;
  uint64_t v38 = cleanup_handler;
  if (type && v41 != 1) {
    return 0LL;
  }
  uint64_t v37 = _dispatch_io_create(v41, (uint64_t)io, (uint64_t)queue, (uint64_t)cleanup_handler, v4, v5, v6, v7);
  _dispatch_thread_getspecific(0LL);
  _dispatch_log("%u\t%p\tchannel[%p]: create with channel %p", v8, v9, v10, v11, v12, v13, v14, 544LL);
  dispatch_object_t v36 = (dispatch_object_t)v37[6];
  dispatch_suspend(v36);
  dispatch_queue_t v35 = v39;
  _dispatch_retain((uint64_t)v39);
  uint64_t v34 = v37;
  _dispatch_retain((uint64_t)v37);
  dispatch_io_t v33 = v40;
  _dispatch_retain((uint64_t)v40);
  uint64_t v15 = (dispatch_queue_s *)*((void *)v40 + 6);
  blocint k = _NSConcreteStackBlock;
  int v24 = 1107296256;
  int v25 = 0;
  int v26 = __dispatch_io_create_with_io_block_invoke;
  int v27 = &__block_descriptor_tmp_13;
  dispatch_io_t v29 = v40;
  uint64_t v30 = v37;
  dispatch_queue_t v31 = v39;
  uint64_t v28 = v38;
  dispatch_io_type_t v32 = v41;
  dispatch_channel_async(v15, &block);
  _dispatch_object_debug((uint64_t)v37, "%s", v16, v17, v18, v19, v20, v21, (char)"dispatch_io_create_with_io");
  return (dispatch_io_t)v37;
}

void __dispatch_io_create_with_io_block_invoke(uint64_t *a1)
{
  uint64_t v18 = a1;
  uint64_t v17 = a1;
  int error = 0;
  int error = _dispatch_io_get_error(0LL, a1[5], 0);
  if (error)
  {
    *(_DWORD *)(a1[6] + 144) = error;
    _dispatch_io_init((void *)a1[6], 0LL, a1[7], error, a1[4]);
    dispatch_object_t v15 = *(dispatch_object_t *)(a1[6] + 48);
    dispatch_resume(v15);
    uint64_t v14 = (unsigned int *)a1[6];
    _dispatch_release(v14);
    uint64_t v13 = (unsigned int *)a1[5];
    _dispatch_release(v13);
    _dispatch_release((unsigned int *)a1[7]);
  }

  else
  {
    uint64_t v1 = *(dispatch_queue_s **)(a1[5] + 56);
    blocint k = _NSConcreteStackBlock;
    int v4 = 1107296256;
    int v5 = 0;
    uint64_t v6 = __dispatch_io_create_with_io_block_invoke_2;
    uint64_t v7 = &__block_descriptor_tmp_12;
    uint64_t v9 = a1[5];
    uint64_t v10 = a1[6];
    uint64_t v11 = a1[8];
    uint64_t v12 = a1[7];
    uint64_t v8 = a1[4];
    dispatch_channel_async(v1, &block);
  }

uint64_t _dispatch_io_get_error(uint64_t a1, uint64_t a2, char a3)
{
  if (a1) {
    a2 = *(void *)(a1 + 136);
  }
  if ((*(_DWORD *)(a2 + 120) & 3) != 0)
  {
    if ((a3 & 1) != 0 && (*(_DWORD *)(a2 + 120) & 2) == 0) {
      return 0;
    }
    else {
      return 89;
    }
  }

  else if (a1)
  {
    return *(unsigned int *)(*(void *)(a1 + 144) + 24LL);
  }

  else
  {
    return *(unsigned int *)(a2 + 144);
  }

void __dispatch_io_create_with_io_block_invoke_2(uint64_t *a1)
{
  dispatch_queue_t v39 = a1;
  uint64_t v38 = a1;
  int error = 0;
  int error = _dispatch_io_get_error(0LL, a1[5], 0);
  if (!error)
  {
    int error = *(_DWORD *)(a1[5] + 144);
    if (!error) {
      int error = *(_DWORD *)(*(void *)(a1[5] + 112) + 24LL);
    }
  }

  if (!error) {
    int error = _dispatch_io_validate_type(a1[6], *(_WORD *)(*(void *)(a1[5] + 112) + 36LL));
  }
  if (!error && a1[7] == 1 && *(_DWORD *)(a1[5] + 124) != -1)
  {
    off_t v36 = 0LL;
    do
    {
      off_t v36 = lseek(**(_DWORD **)(a1[5] + 112), 0LL, 1);
      if (v36 == -1)
      {
        uint64_t v42 = 1LL;
        uint64_t v43 = 1LL;
        unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
        int v13 = **(_DWORD **)(StatusReg + 8);
      }

      else
      {
        int v13 = 0;
      }

      int error = v13;
      if (!v13)
      {
        *(void *)(a1[6] + 136) = v36;
        goto LABEL_20;
      }
    }

    while (v13 == 4);
    int v35 = error;
    uint64_t v41 = error;
    uint64_t v40 = 590LL;
    if (error) {
      _dispatch_bug(v40, v41, v1, v2, v3, v4, v5, v6);
    }
    int v34 = v35;
  }

void __dispatch_io_create_with_io_block_invoke_3(uint64_t a1)
{
  uint64_t v2 = _dispatch_fd_entry_create_with_path(*(void *)(a1 + 40), *(_DWORD *)(a1 + 64), *(_WORD *)(a1 + 68));
  _dispatch_io_init(*(void **)(a1 + 48), (uint64_t)v2, *(void *)(a1 + 56), 0, *(void *)(a1 + 32));
  dispatch_resume(*(dispatch_object_t *)(*(void *)(a1 + 48) + 48LL));
  _dispatch_release(*(unsigned int **)(a1 + 48));
  _dispatch_release(*(unsigned int **)(a1 + 56));
}

dispatch_io_t dispatch_io_create_with_io_f( dispatch_io_type_t a1, dispatch_io_s *a2, dispatch_queue_s *a3, uint64_t a4, uint64_t a5)
{
  dispatch_io_type_t v17 = a1;
  uint64_t v16 = a2;
  uint64_t v15 = a3;
  uint64_t v14 = a4;
  uint64_t v13 = a5;
  if (!a5) {
    return dispatch_io_create_with_io(a1, a2, a3, 0LL);
  }
  uint64_t v6 = _NSConcreteStackBlock;
  int v7 = 0x40000000;
  int v8 = 0;
  uint64_t v9 = __dispatch_io_create_with_io_f_block_invoke;
  uint64_t v10 = &__block_descriptor_tmp_14;
  uint64_t v11 = v13;
  uint64_t v12 = v14;
  return dispatch_io_create_with_io(a1, a2, a3, &v6);
}

uint64_t __dispatch_io_create_with_io_f_block_invoke(uint64_t a1, unsigned int a2)
{
  return (*(uint64_t (**)(void, void))(a1 + 32))(*(void *)(a1 + 40), a2);
}

void dispatch_io_set_high_water(dispatch_io_t channel, size_t high_water)
{
  dispatch_io_t v12 = channel;
  size_t v11 = high_water;
  dispatch_io_t v10 = channel;
  _dispatch_retain((uint64_t)channel);
  uint64_t v2 = (dispatch_queue_s *)*((void *)v12 + 6);
  blocint k = _NSConcreteStackBlock;
  int v4 = 0x40000000;
  int v5 = 0;
  uint64_t v6 = __dispatch_io_set_high_water_block_invoke;
  int v7 = &__block_descriptor_tmp_16;
  dispatch_io_t v8 = v12;
  size_t v9 = v11;
  dispatch_channel_async(v2, &block);
}

void __dispatch_io_set_high_water_block_invoke(uint64_t a1)
{
  if (*(void *)(*(void *)(a1 + 32) + 80LL) > *(void *)(a1 + 40)) {
    *(void *)(*(void *)(a1 + 32) + 8pthread_sigmask(3, _dispatch_sigsuspend_mask, 0LL) = *(void *)(a1 + 40);
  }
  if (*(void *)(a1 + 40)) {
    uint64_t v8 = *(void *)(a1 + 40);
  }
  else {
    uint64_t v8 = 1LL;
  }
  *(void *)(*(void *)(a1 + 32) + 88LL) = v8;
  _dispatch_release(*(unsigned int **)(a1 + 32));
}

void dispatch_io_set_low_water(dispatch_io_t channel, size_t low_water)
{
  dispatch_io_t v12 = channel;
  size_t v11 = low_water;
  dispatch_io_t v10 = channel;
  _dispatch_retain((uint64_t)channel);
  uint64_t v2 = (dispatch_queue_s *)*((void *)v12 + 6);
  blocint k = _NSConcreteStackBlock;
  int v4 = 0x40000000;
  int v5 = 0;
  uint64_t v6 = __dispatch_io_set_low_water_block_invoke;
  uint64_t v7 = &__block_descriptor_tmp_18;
  dispatch_io_t v8 = v12;
  size_t v9 = v11;
  dispatch_channel_async(v2, &block);
}

void __dispatch_io_set_low_water_block_invoke(uint64_t a1)
{
  if (*(void *)(*(void *)(a1 + 32) + 88LL) < *(void *)(a1 + 40))
  {
    if (*(void *)(a1 + 40)) {
      uint64_t v8 = *(void *)(a1 + 40);
    }
    else {
      uint64_t v8 = 1LL;
    }
    *(void *)(*(void *)(a1 + 32) + 88LL) = v8;
  }

  *(void *)(*(void *)(a1 + 32) + 8pthread_sigmask(3, _dispatch_sigsuspend_mask, 0LL) = *(void *)(a1 + 40);
  _dispatch_release(*(unsigned int **)(a1 + 32));
}

void dispatch_io_set_interval(dispatch_io_t channel, uint64_t interval, dispatch_io_interval_flags_t flags)
{
  dispatch_io_t v15 = channel;
  uint64_t v14 = interval;
  dispatch_io_interval_flags_t v13 = flags;
  dispatch_io_t v12 = channel;
  _dispatch_retain((uint64_t)channel);
  uint64_t v3 = (dispatch_queue_s *)*((void *)v15 + 6);
  blocint k = _NSConcreteStackBlock;
  int v5 = 0x40000000;
  int v6 = 0;
  uint64_t v7 = __dispatch_io_set_interval_block_invoke;
  uint64_t v8 = &__block_descriptor_tmp_20;
  dispatch_io_t v9 = v15;
  uint64_t v10 = v14;
  dispatch_io_interval_flags_t v11 = v13;
  dispatch_channel_async(v3, &block);
}

void __dispatch_io_set_interval_block_invoke(uint64_t a1)
{
  if (*(void *)(a1 + 40) >= 0x7FFFFFFFFFFFFFFFuLL) {
    uint64_t v8 = 0x7FFFFFFFFFFFFFFFLL;
  }
  else {
    uint64_t v8 = *(void *)(a1 + 40);
  }
  *(void *)(*(void *)(a1 + 32) + 96LL) = v8;
  *(void *)(*(void *)(a1 + 32) + 104LL) = *(void *)(a1 + 48);
  _dispatch_release(*(unsigned int **)(a1 + 32));
}

void _dispatch_io_set_target_queue(uint64_t a1, uint64_t a2)
{
  uint64_t v13 = a1;
  uint64_t v12 = a2;
  uint64_t v11 = a2;
  _dispatch_retain(a2);
  uint64_t v10 = v13;
  _dispatch_retain(v13);
  uint64_t v2 = *(dispatch_queue_s **)(v13 + 48);
  uint64_t v3 = _NSConcreteStackBlock;
  int v4 = 0x40000000;
  int v5 = 0;
  uint64_t v6 = ___dispatch_io_set_target_queue_block_invoke;
  uint64_t v7 = &__block_descriptor_tmp_21;
  uint64_t v8 = v13;
  uint64_t v9 = v12;
  dispatch_channel_async(v2, &v3);
}

void ___dispatch_io_set_target_queue_block_invoke(uint64_t a1)
{
  uint64_t v8 = *(unsigned int **)(*(void *)(a1 + 32) + 24LL);
  *(void *)(*(void *)(a1 + 32) + 24LL) = *(void *)(a1 + 40);
  _dispatch_release(v8);
  _dispatch_object_debug( *(void *)(a1 + 32),  "%s",  v1,  v2,  v3,  v4,  v5,  v6,  (char)"_dispatch_io_set_target_queue_block_invoke");
  _dispatch_release(*(unsigned int **)(a1 + 32));
}

dispatch_fd_t dispatch_io_get_descriptor(dispatch_io_t channel)
{
  if ((*((_DWORD *)channel + 30) & 3) != 0) {
    return -1;
  }
  if (*((_DWORD *)channel + 32) == -1 && !_dispatch_io_get_error(0LL, (uint64_t)channel, 0))
  {
    for (uint64_t i = (char *)_dispatch_thread_getspecific(0x17uLL); i; uint64_t i = *(char **)i)
    {
      if (*((char **)i + 1) == "io")
      {
        uint64_t v5 = i;
        goto LABEL_11;
      }
    }

    uint64_t v5 = 0LL;
LABEL_11:
    if (v5 && *((dispatch_io_t *)v5 + 2) == channel) {
      _dispatch_fd_entry_open(*((void *)channel + 14), (uint64_t)channel);
    }
  }

  return *((_DWORD *)channel + 32);
}

uint64_t _dispatch_fd_entry_open(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)a1 == -1 && *(void *)(a1 + 8))
  {
    if (*(_DWORD *)(a1 + 24))
    {
      return *(unsigned int *)(a1 + 24);
    }

    else
    {
      if (*(void *)(a1 + 56)) {
        unsigned int v12 = *(_DWORD *)(*(void *)(a1 + 8) + 8LL) & 0xFFFFFFFB;
      }
      else {
        unsigned int v12 = *(_DWORD *)(*(void *)(a1 + 8) + 8LL) | 4;
      }
      while (1)
      {
        unsigned int v14 = _dispatch_fd_entry_guarded_open( a1,  *(void *)(a1 + 8) + 24LL,  v12,  *(_WORD *)(*(void *)(a1 + 8) + 12LL));
        if (v14 != -1) {
          break;
        }
        unsigned int v13 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
        if (v13 != 4)
        {
          uint64_t v8 = (unsigned int *)(a1 + 24);
          do
            unsigned int v9 = __ldaxr(v8);
          while (!v9 && __stlxr(v13, v8));
          return v13;
        }
      }

      do
        unsigned int v10 = __ldaxr((unsigned int *)a1);
      while (v10 == -1 && __stlxr(v14, (unsigned int *)a1));
      if (v10 == -1) {
        *(_DWORD *)(a2 + 128) = v14;
      }
      else {
        _dispatch_fd_entry_guarded_close(a1, v14);
      }
      _dispatch_object_debug(a2, "%s", v2, v3, v4, v5, v6, v7, (char)"_dispatch_fd_entry_open");
      return 0;
    }
  }

  else
  {
    return 0;
  }

void dispatch_io_close(dispatch_io_t channel, dispatch_io_close_flags_t flags)
{
  dispatch_io_t v11 = channel;
  dispatch_io_close_flags_t v10 = flags;
  if ((flags & 1) != 0)
  {
    if ((*((_DWORD *)v11 + 30) & 2) == 0) {
      _dispatch_io_stop((uint64_t)v11);
    }
  }

  else if ((*((_DWORD *)v11 + 30) & 3) == 0)
  {
    dispatch_io_t v9 = v11;
    _dispatch_retain((uint64_t)v11);
    uint64_t v2 = (dispatch_queue_s *)*((void *)v11 + 6);
    uint64_t v3 = _NSConcreteStackBlock;
    int v4 = 0x40000000;
    int v5 = 0;
    uint64_t v6 = __dispatch_io_close_block_invoke;
    uint64_t v7 = &__block_descriptor_tmp_25;
    dispatch_io_t v8 = v11;
    dispatch_channel_async(v2, &v3);
  }

void _dispatch_io_stop(uint64_t a1)
{
  uint64_t v30 = a1;
  _dispatch_thread_getspecific(0LL);
  _dispatch_log("%u\t%p\tchannel[%p]: stop", v1, v2, v3, v4, v5, v6, v7, 736LL);
  int v28 = 2;
  int v27 = 2;
  int v29 = 2;
  unsigned int v25 = 0;
  dispatch_io_t v11 = (unsigned int *)(v30 + 120);
  int v23 = 2;
  int v22 = 2;
  int v24 = 2;
  unsigned int v12 = *(_DWORD *)(v30 + 120);
  do
  {
    unsigned int v8 = v12;
    do
      unsigned int v9 = __ldaxr(v11);
    while (v9 == v12 && __stlxr(v12 | 2, v11));
    unsigned int v12 = v9;
  }

  while (v9 != v8);
  unsigned int v21 = v9;
  unsigned int v25 = v9;
  unsigned int v20 = v9;
  int v26 = v9 | v29;
  uint64_t v19 = v30;
  _dispatch_retain(v30);
  dispatch_io_close_flags_t v10 = *(dispatch_queue_s **)(v30 + 48);
  blocint k = _NSConcreteStackBlock;
  int v14 = 0x40000000;
  int v15 = 0;
  uint64_t v16 = ___dispatch_io_stop_block_invoke;
  dispatch_io_type_t v17 = &__block_descriptor_tmp_76;
  uint64_t v18 = v30;
  dispatch_channel_async(v10, &block);
}

void __dispatch_io_close_block_invoke(uint64_t a1)
{
  uint64_t v10 = a1;
  uint64_t v9 = a1;
  uint64_t v2 = *(dispatch_queue_s **)(*(void *)(a1 + 32) + 56LL);
  blocint k = _NSConcreteStackBlock;
  int v4 = 0x40000000;
  int v5 = 0;
  uint64_t v6 = __dispatch_io_close_block_invoke_2;
  uint64_t v7 = &__block_descriptor_tmp_24;
  uint64_t v8 = *(void *)(a1 + 32);
  dispatch_channel_async(v2, &block);
}

void __dispatch_io_close_block_invoke_2( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if ((*(_DWORD *)(*(void *)(a1 + 32) + 120LL) & 3) == 0)
  {
    dispatch_io_type_t v17 = (unsigned int *)(*(void *)(a1 + 32) + 120LL);
    unsigned int v18 = *v17;
    do
    {
      unsigned int v15 = v18;
      do
        unsigned int v16 = __ldaxr(v17);
      while (v16 == v18 && __stlxr(v18 | 1, v17));
      unsigned int v18 = v16;
    }

    while (v16 != v15);
    uint64_t v20 = *(void *)(*(void *)(a1 + 32) + 112LL);
    if (v20)
    {
      if (*(void *)(v20 + 8)) {
        **(void **)(v20 + 8) = 0LL;
      }
      *(void *)(*(void *)(a1 + 32) + 112LL) = 0LL;
      _dispatch_fd_entry_release(v20);
    }
  }

  _dispatch_release(*(unsigned int **)(a1 + 32));
}

void dispatch_io_barrier(dispatch_io_t channel, dispatch_block_t barrier)
{
  dispatch_io_t v12 = channel;
  dispatch_block_t v11 = barrier;
  dispatch_io_t v10 = channel;
  _dispatch_retain((uint64_t)channel);
  uint64_t v2 = (dispatch_queue_s *)*((void *)v12 + 6);
  blocint k = _NSConcreteStackBlock;
  int v4 = 1107296256;
  int v5 = 0;
  uint64_t v6 = __dispatch_io_barrier_block_invoke;
  uint64_t v7 = &__block_descriptor_tmp_28;
  dispatch_io_t v9 = v12;
  dispatch_block_t v8 = v11;
  dispatch_channel_async(v2, &block);
}

void __dispatch_io_barrier_block_invoke(uint64_t a1)
{
  uint64_t v15 = a1;
  uint64_t v14 = a1;
  uint64_t v13 = 0LL;
  uint64_t v13 = *(void *)(*(void *)(a1 + 40) + 24LL);
  dispatch_queue_t v12 = 0LL;
  dispatch_queue_t v12 = *(dispatch_queue_t *)(*(void *)(a1 + 40) + 56LL);
  uint64_t v11 = 0LL;
  uint64_t v11 = *(void *)(*(void *)(a1 + 40) + 64LL);
  uint64_t v1 = _NSConcreteStackBlock;
  int v2 = 1107296256;
  int v3 = 0;
  int v4 = __dispatch_io_barrier_block_invoke_2;
  int v5 = &__block_descriptor_tmp_27;
  dispatch_queue_t v7 = v12;
  uint64_t v8 = v11;
  uint64_t v9 = v13;
  uint64_t v10 = *(void *)(a1 + 40);
  uint64_t v6 = *(void *)(a1 + 32);
  dispatch_channel_async(v12, &v1);
}

void __dispatch_io_barrier_block_invoke_2(void *a1)
{
  uint64_t v14 = a1;
  uint64_t v13 = a1;
  dispatch_object_t v12 = (dispatch_object_t)a1[5];
  dispatch_suspend(v12);
  uint64_t v1 = (dispatch_group_s *)a1[6];
  int v2 = (dispatch_queue_s *)a1[7];
  blocint k = _NSConcreteStackBlock;
  int v5 = 1107296256;
  int v6 = 0;
  dispatch_queue_t v7 = __dispatch_io_barrier_block_invoke_3;
  uint64_t v8 = &__block_descriptor_tmp_26;
  uint64_t v10 = a1[8];
  uint64_t v9 = a1[4];
  uint64_t v11 = a1[5];
  dispatch_group_notify(v1, v2, &block);
}

void __dispatch_io_barrier_block_invoke_3( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v18 = a1;
  uint64_t v17 = a1;
  uint64_t v16 = 0LL;
  v15[0] = 0LL;
  v15[1] = "io";
  uint64_t v16 = *(void *)(a1 + 40);
  _dispatch_object_debug(*(void *)(a1 + 40), "%s", a3, a4, a5, a6, a7, a8, (char)"dispatch_io_barrier_block_invoke_3");
  uint64_t v19 = v15;
  v15[0] = _dispatch_thread_getspecific(0x17uLL);
  _dispatch_thread_setspecific(23LL, (uint64_t)v19);
  (*(void (**)(void))(*(void *)(a1 + 32) + 16LL))();
  uint64_t v20 = v15;
  BOOL v22 = _dispatch_thread_getspecific(0x17uLL) == v15;
  uint64_t v21 = 449LL;
  if (!v22) {
    _dispatch_abort(v21, 0LL, v8, v9, v10, v11, v12, v13);
  }
  _dispatch_thread_setspecific(23LL, *v20);
  dispatch_resume(*(dispatch_object_t *)(a1 + 48));
  _dispatch_release(*(unsigned int **)(a1 + 40));
}

void dispatch_io_barrier_f(dispatch_io_s *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v12 = a1;
  uint64_t v11 = a2;
  uint64_t v10 = a3;
  barrier = _NSConcreteStackBlock;
  int v4 = 0x40000000;
  int v5 = 0;
  int v6 = __dispatch_io_barrier_f_block_invoke;
  dispatch_queue_t v7 = &__block_descriptor_tmp_29;
  uint64_t v8 = a3;
  uint64_t v9 = a2;
  dispatch_io_barrier(a1, &barrier);
}

uint64_t __dispatch_io_barrier_f_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void))(a1 + 32))(*(void *)(a1 + 40));
}

void dispatch_io_read( dispatch_io_t channel, off_t offset, size_t length, dispatch_queue_t queue, dispatch_io_handler_t io_handler)
{
  dispatch_io_t v22 = channel;
  off_t v21 = offset;
  size_t v20 = length;
  dispatch_queue_t v19 = queue;
  dispatch_io_handler_t v18 = io_handler;
  dispatch_io_t v17 = channel;
  _dispatch_retain((uint64_t)channel);
  dispatch_queue_t v16 = v19;
  _dispatch_retain((uint64_t)v19);
  int v5 = (dispatch_queue_s *)*((void *)v22 + 6);
  int v6 = _NSConcreteStackBlock;
  int v7 = 1107296256;
  int v8 = 0;
  uint64_t v9 = __dispatch_io_read_block_invoke;
  uint64_t v10 = &__block_descriptor_tmp_31;
  dispatch_io_t v12 = v22;
  off_t v13 = v21;
  size_t v14 = v20;
  dispatch_queue_t v15 = v19;
  dispatch_io_handler_t v11 = v18;
  dispatch_channel_async(v5, &v6);
}

void __dispatch_io_read_block_invoke( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v18 = a1;
  uint64_t v17 = a1;
  dispatch_queue_t v16 = 0LL;
  dispatch_queue_t v16 = _dispatch_operation_create( 0,  *(void **)(a1 + 40),  *(void *)(a1 + 48),  *(void *)(a1 + 56),  &_dispatch_data_empty,  *(dispatch_queue_s **)(a1 + 64),  *(const void **)(a1 + 32),  a8);
  if (v16)
  {
    dispatch_queue_t v15 = 0LL;
    dispatch_queue_t v15 = *(dispatch_queue_t *)(*(void *)(a1 + 40) + 56LL);
    blocint k = _NSConcreteStackBlock;
    int v10 = 0x40000000;
    int v11 = 0;
    dispatch_io_t v12 = __dispatch_io_read_block_invoke_2;
    off_t v13 = &__block_descriptor_tmp_30;
    size_t v14 = v16;
    dispatch_channel_async(v15, &block);
  }

  _dispatch_release(*(unsigned int **)(a1 + 40));
  _dispatch_release(*(unsigned int **)(a1 + 64));
}

void *_dispatch_operation_create( unsigned int a1, void *a2, uint64_t a3, uint64_t a4, dispatch_object_s *a5, dispatch_queue_s *a6, const void *a7, uint64_t a8)
{
  unsigned int v52 = a1;
  unint64_t v51 = a2;
  uint64_t v50 = a3;
  uint64_t v49 = a4;
  dispatch_object_t v48 = a5;
  dispatch_queue_t v47 = a6;
  BOOL v46 = a7;
  BOOL v55 = a1 < 2;
  uint64_t v54 = 1064LL;
  if (a1 >= 2) {
    _dispatch_abort(v54, v55, a3, a4, (uint64_t)a5, (uint64_t)a6, (uint64_t)a7, a8);
  }
  int error = _dispatch_io_get_error(0LL, (uint64_t)v51, 0);
  if (!error && v49)
  {
    uint64_t v30 = _dispatch_object_alloc((uint64_t)_OS_dispatch_operation_vtable, 0x110uLL, v8, v9, v10, v11, v12, v13);
    _dispatch_thread_getspecific(0LL);
    _dispatch_log("%u\t%p\tchannel[%p]: operation create: %p", v15, v16, v17, v18, v19, v20, v21, 1092LL);
    v30[2] = -1985229329LL;
    *((_DWORD *)v30 + 3) = 0;
    v30[6] = dispatch_queue_create_with_target_V2("com.apple.libdispatch-io.opq", 0LL, v47);
    *((_BYTE *)v30 + 16_dispatch_source_set_handler((uint64_t)source, handler, 2LL, 0) = 0;
    *((_DWORD *)v30 + 14) = v52;
    v30[13] = v50 + v51[17];
    v30[14] = v49;
    v30[16] = _dispatch_Block_copy(v46);
    _dispatch_retain((uint64_t)v51);
    v30[17] = v51;
    memcpy(v30 + 8, v51 + 9, 0x28uLL);
    for (uint64_t i = *(void *)(v30[17] + 24LL); *(void *)(i + 24); uint64_t i = *(void *)(i + 24))
      ;
    v30[3] = i;
    _dispatch_object_debug((uint64_t)v30, "%s", v22, v23, v24, v25, v26, v27, (char)"_dispatch_operation_create");
    return v30;
  }

  else
  {
    dispatch_object_t v44 = v48;
    dispatch_retain(v48);
    dispatch_queue_t v43 = v47;
    _dispatch_retain((uint64_t)v47);
    uint64_t v42 = v51;
    _dispatch_retain((uint64_t)v51);
    size_t v14 = (dispatch_queue_s *)v51[7];
    blocint k = _NSConcreteStackBlock;
    int v32 = 1107296256;
    int v33 = 0;
    int v34 = ___dispatch_operation_create_block_invoke;
    int v35 = &__block_descriptor_tmp_86;
    dispatch_queue_t v37 = v47;
    dispatch_object_t v38 = v48;
    unsigned int v40 = v52;
    int v41 = error;
    dispatch_queue_t v39 = v51;
    off_t v36 = v46;
    dispatch_channel_async(v14, &block);
    return 0LL;
  }

void __dispatch_io_read_block_invoke_2(uint64_t a1)
{
}

void _dispatch_operation_enqueue(unsigned int *a1, unsigned int a2, dispatch_object_s *a3)
{
  BOOL v46 = a1;
  unsigned int v45 = a2;
  dispatch_object_t v44 = a3;
  dispatch_queue_t v43 = a3;
  dispatch_retain(a3);
  int error = 0;
  int error = _dispatch_io_get_error(0LL, *((void *)v46 + 17), 0);
  if (error)
  {
    uint64_t v41 = 0LL;
    uint64_t v41 = *((void *)v46 + 16);
    int v3 = (dispatch_queue_s *)*((void *)v46 + 6);
    blocint k = _NSConcreteStackBlock;
    int v33 = 1107296256;
    int v34 = 0;
    int v35 = ___dispatch_operation_enqueue_block_invoke;
    off_t v36 = &__block_descriptor_tmp_89;
    dispatch_object_t v38 = v44;
    unsigned int v39 = v45;
    int v40 = error;
    uint64_t v37 = v41;
    dispatch_channel_async(v3, &block);
    _dispatch_thread_getspecific(0LL);
    _dispatch_log("%u\t%p\top[%p]: release -> %d, err %d", v4, v5, v6, v7, v8, v9, v10, 1175LL);
    dispatch_queue_t v31 = v46;
    _dispatch_release(v46);
  }

  else
  {
    *((void *)v46 + 18) = *(void *)(*((void *)v46 + 17) + 112LL);
    _dispatch_fd_entry_retain(*((void *)v46 + 18));
    dispatch_group_enter(*(dispatch_group_t *)(*((void *)v46 + 18) + 80LL));
    uint64_t v30 = 0LL;
    uint64_t v30 = *(void *)(*((void *)v46 + 18) + 56LL);
    if (v30)
    {
      uint64_t v12 = *(dispatch_queue_s **)(v30 + 72);
      uint64_t v13 = _NSConcreteStackBlock;
      int v14 = 0x40000000;
      int v15 = 0;
      uint64_t v16 = ___dispatch_operation_enqueue_block_invoke_2;
      uint64_t v17 = &__block_descriptor_tmp_93;
      uint64_t v18 = v30;
      uint64_t v19 = v46;
      uint64_t v20 = v44;
      dispatch_channel_async(v12, &v13);
    }

    else
    {
      int v29 = 0LL;
      int v29 = *(dispatch_queue_s ***)(*((void *)v46 + 18) + 40LL + 8LL * v45);
      uint64_t v11 = *v29;
      uint64_t v21 = _NSConcreteStackBlock;
      int v22 = 0x40000000;
      int v23 = 0;
      uint64_t v24 = ___dispatch_operation_enqueue_block_invoke_91;
      uint64_t v25 = &__block_descriptor_tmp_92;
      uint64_t v26 = v29;
      uint64_t v27 = v46;
      int v28 = v44;
      dispatch_channel_async(v11, &v21);
    }
  }

void dispatch_io_read_f( dispatch_io_s *a1, off_t a2, size_t a3, dispatch_queue_s *a4, uint64_t a5, uint64_t a6)
{
  uint64_t v18 = a1;
  off_t v17 = a2;
  size_t v16 = a3;
  int v15 = a4;
  uint64_t v14 = a5;
  uint64_t v13 = a6;
  uint64_t v6 = _NSConcreteStackBlock;
  int v7 = 0x40000000;
  int v8 = 0;
  uint64_t v9 = __dispatch_io_read_f_block_invoke;
  uint64_t v10 = &__block_descriptor_tmp_33;
  uint64_t v11 = a6;
  uint64_t v12 = a5;
  dispatch_io_read(a1, a2, a3, a4, &v6);
}

uint64_t __dispatch_io_read_f_block_invoke(uint64_t a1, char a2, uint64_t a3, unsigned int a4)
{
  return (*(uint64_t (**)(void, void, uint64_t, void))(a1 + 32))(*(void *)(a1 + 40), a2 & 1, a3, a4);
}

void dispatch_io_write( dispatch_io_t channel, off_t offset, dispatch_data_t data, dispatch_queue_t queue, dispatch_io_handler_t io_handler)
{
  dispatch_io_t v23 = channel;
  off_t v22 = offset;
  dispatch_data_t v21 = data;
  dispatch_queue_t v20 = queue;
  dispatch_io_handler_t v19 = io_handler;
  dispatch_data_t v18 = data;
  dispatch_retain(data);
  dispatch_io_t v17 = v23;
  _dispatch_retain((uint64_t)v23);
  dispatch_queue_t v16 = v20;
  _dispatch_retain((uint64_t)v20);
  uint64_t v5 = (dispatch_queue_s *)*((void *)v23 + 6);
  blocint k = _NSConcreteStackBlock;
  int v7 = 1107296256;
  int v8 = 0;
  uint64_t v9 = __dispatch_io_write_block_invoke;
  uint64_t v10 = &__block_descriptor_tmp_35;
  dispatch_io_t v12 = v23;
  off_t v13 = v22;
  dispatch_data_t v14 = v21;
  dispatch_queue_t v15 = v20;
  dispatch_io_handler_t v11 = v19;
  dispatch_channel_async(v5, &block);
}

void __dispatch_io_write_block_invoke(uint64_t a1)
{
  uint64_t v16 = a1;
  uint64_t v15 = a1;
  dispatch_data_t v14 = 0LL;
  int v3 = *(void **)(a1 + 40);
  uint64_t v4 = *(void *)(a1 + 48);
  size_t size = dispatch_data_get_size(*(dispatch_data_t *)(a1 + 56));
  dispatch_data_t v14 = _dispatch_operation_create( 1u,  v3,  v4,  size,  *(dispatch_object_s **)(a1 + 56),  *(dispatch_queue_s **)(a1 + 64),  *(const void **)(a1 + 32),  v2);
  if (v14)
  {
    dispatch_queue_t v13 = 0LL;
    dispatch_queue_t v13 = *(dispatch_queue_t *)(*(void *)(a1 + 40) + 56LL);
    blocint k = _NSConcreteStackBlock;
    int v7 = 0x40000000;
    int v8 = 0;
    uint64_t v9 = __dispatch_io_write_block_invoke_2;
    uint64_t v10 = &__block_descriptor_tmp_34;
    dispatch_io_handler_t v11 = v14;
    uint64_t v12 = *(void *)(a1 + 56);
    dispatch_channel_async(v13, &block);
  }

  else
  {
    dispatch_release(*(dispatch_object_t *)(a1 + 56));
  }

  _dispatch_release(*(unsigned int **)(a1 + 40));
  _dispatch_release(*(unsigned int **)(a1 + 64));
}

void __dispatch_io_write_block_invoke_2(uint64_t a1)
{
}

void dispatch_io_write_f( dispatch_io_s *a1, off_t a2, dispatch_data_s *a3, dispatch_queue_s *a4, uint64_t a5, uint64_t a6)
{
  dispatch_data_t v18 = a1;
  off_t v17 = a2;
  uint64_t v16 = a3;
  uint64_t v15 = a4;
  uint64_t v14 = a5;
  uint64_t v13 = a6;
  uint64_t v6 = _NSConcreteStackBlock;
  int v7 = 0x40000000;
  int v8 = 0;
  uint64_t v9 = __dispatch_io_write_f_block_invoke;
  uint64_t v10 = &__block_descriptor_tmp_36;
  uint64_t v11 = a6;
  uint64_t v12 = a5;
  dispatch_io_write(a1, a2, a3, a4, &v6);
}

uint64_t __dispatch_io_write_f_block_invoke(uint64_t a1, char a2, uint64_t a3, unsigned int a4)
{
  return (*(uint64_t (**)(void, void, uint64_t, void))(a1 + 32))(*(void *)(a1 + 40), a2 & 1, a3, a4);
}

void dispatch_read(dispatch_fd_t fd, size_t length, dispatch_queue_t queue, void *handler)
{
  dispatch_fd_t v17 = fd;
  size_t v16 = length;
  dispatch_queue_t v15 = queue;
  uint64_t v14 = handler;
  dispatch_queue_t v13 = queue;
  _dispatch_retain((uint64_t)queue);
  uint64_t v4 = _NSConcreteStackBlock;
  int v5 = 1107296256;
  int v6 = 0;
  int v7 = __dispatch_read_block_invoke;
  int v8 = &__block_descriptor_tmp_45;
  dispatch_queue_t v10 = v15;
  dispatch_fd_t v12 = v17;
  uint64_t v9 = v14;
  size_t v11 = v16;
  _dispatch_fd_entry_init_async(v17, (uint64_t)&v4);
}

void __dispatch_read_block_invoke( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v53 = a1;
  uint64_t v52 = a2;
  uint64_t v51 = a1;
  if (*(_DWORD *)(a2 + 24))
  {
    int v50 = 0;
    int v50 = *(_DWORD *)(v52 + 24);
    int v8 = *(dispatch_queue_s **)(a1 + 40);
    blocint k = _NSConcreteStackBlock;
    int v43 = 1107296256;
    int v44 = 0;
    unsigned int v45 = __dispatch_read_block_invoke_2;
    BOOL v46 = &__block_descriptor_tmp_38;
    int v48 = *(_DWORD *)(a1 + 56);
    uint64_t v47 = *(void *)(a1 + 32);
    int v49 = v50;
    dispatch_channel_async(v8, &block);
    _dispatch_release(*(unsigned int **)(a1 + 40));
  }

  else
  {
    uint64_t v41 = 0LL;
    uint64_t v41 = *(void **)(v52 + 88);
    if (!v41)
    {
      uint64_t v41 = _dispatch_io_create(0LL, a2, a3, a4, a5, a6, a7, a8);
      *((_DWORD *)v41 + 3_dispatch_source_set_handler((uint64_t)source, handler, 2LL, 1) = *(_DWORD *)(a1 + 56);
      *((_DWORD *)v41 + 32) = *(_DWORD *)(a1 + 56);
      v41[14] = v52;
      dispatch_object_t v40 = *(dispatch_object_t *)(v52 + 72);
      dispatch_retain(v40);
      dispatch_object_t v39 = *(dispatch_object_t *)(v52 + 80);
      dispatch_retain(v39);
      v41[7] = *(void *)(v52 + 72);
      v41[8] = *(void *)(v52 + 80);
      *(void *)(v52 + 88) = v41;
    }

    v35[0] = 0LL;
    v35[1] = v35;
    int v36 = 0;
    int v37 = 32;
    dispatch_object_t v38 = &_dispatch_data_empty;
    v31[0] = 0LL;
    v31[1] = v31;
    int v32 = 0;
    int v33 = 32;
    int v34 = 0;
    uint64_t v9 = *(dispatch_queue_s **)(v52 + 64);
    dispatch_data_t v21 = _NSConcreteStackBlock;
    int v22 = 1107296256;
    int v23 = 0;
    uint64_t v24 = __dispatch_read_block_invoke_39;
    uint64_t v25 = &__block_descriptor_tmp_42;
    uint64_t v29 = *(void *)(a1 + 40);
    int v30 = *(_DWORD *)(a1 + 56);
    uint64_t v26 = *(void *)(a1 + 32);
    uint64_t v27 = v35;
    int v28 = v31;
    dispatch_channel_async(v9, &v21);
    dispatch_queue_t v20 = 0LL;
    uint64_t v10 = *(void *)(a1 + 48);
    dispatch_queue_t v13 = _NSConcreteStackBlock;
    int v14 = 1107296256;
    int v15 = 0;
    size_t v16 = __dispatch_read_block_invoke_43;
    dispatch_fd_t v17 = &__block_descriptor_tmp_44;
    dispatch_data_t v18 = v35;
    dispatch_io_handler_t v19 = v31;
    dispatch_queue_t v20 = (unsigned int *)_dispatch_operation_create( 0,  v41,  0LL,  v10,  &_dispatch_data_empty,  (dispatch_queue_s *)&off_E4640,  &v13,  v11);
    if (v20) {
      _dispatch_operation_enqueue(v20, 0, &_dispatch_data_empty);
    }
    _Block_object_dispose(v31, 8);
    _Block_object_dispose(v35, 8);
  }

uint64_t __dispatch_read_block_invoke_2(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16LL))();
}

void __dispatch_read_block_invoke_39(uint64_t a1)
{
  uint64_t v14 = a1;
  uint64_t v13 = a1;
  uint64_t v2 = *(dispatch_queue_s **)(a1 + 56);
  blocint k = _NSConcreteStackBlock;
  int v5 = 1107296256;
  int v6 = 0;
  uint64_t v7 = __dispatch_read_block_invoke_2_40;
  int v8 = &__block_descriptor_tmp_41;
  int v12 = *(_DWORD *)(a1 + 64);
  uint64_t v9 = *(void *)(a1 + 32);
  uint64_t v10 = *(void *)(a1 + 40);
  uint64_t v11 = *(void *)(a1 + 48);
  dispatch_channel_async(v2, &block);
  _dispatch_release(*(unsigned int **)(a1 + 56));
}

void __dispatch_read_block_invoke_2_40(uint64_t a1)
{
}

void __copy_helper_block_8_32b40r48r(uint64_t a1, const void **a2)
{
}

void __destroy_helper_block_8_32b40r48r(const void **a1)
{
}

void __dispatch_read_block_invoke_43(uint64_t a1, char a2, dispatch_data_s *a3, int a4)
{
  char v7 = a2 & 1;
  if (a3)
  {
    dispatch_data_t concat = dispatch_data_create_concat(*(dispatch_data_t *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL), a3);
    dispatch_release(*(dispatch_object_t *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL));
    *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = concat;
  }

  if ((v7 & 1) != 0) {
    *(_DWORD *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL) = a4;
  }
}

void __copy_helper_block_8_32r40r(uint64_t a1, uint64_t a2)
{
}

void __destroy_helper_block_8_32r40r(uint64_t a1)
{
}

void dispatch_read_f(dispatch_fd_t a1, size_t a2, dispatch_queue_s *a3, uint64_t a4, uint64_t a5)
{
  dispatch_fd_t v16 = a1;
  size_t v15 = a2;
  uint64_t v14 = a3;
  uint64_t v13 = a4;
  uint64_t v12 = a5;
  handler = _NSConcreteStackBlock;
  int v6 = 0x40000000;
  int v7 = 0;
  int v8 = __dispatch_read_f_block_invoke;
  uint64_t v9 = &__block_descriptor_tmp_47;
  uint64_t v10 = a5;
  uint64_t v11 = a4;
  dispatch_read(a1, a2, a3, &handler);
}

uint64_t __dispatch_read_f_block_invoke(uint64_t a1, uint64_t a2, unsigned int a3)
{
  return (*(uint64_t (**)(void, uint64_t, void))(a1 + 32))(*(void *)(a1 + 40), a2, a3);
}

void dispatch_write(dispatch_fd_t fd, dispatch_data_t data, dispatch_queue_t queue, void *handler)
{
  dispatch_fd_t v18 = fd;
  dispatch_data_t v17 = data;
  dispatch_queue_t v16 = queue;
  size_t v15 = handler;
  dispatch_data_t v14 = data;
  dispatch_retain(data);
  dispatch_queue_t v13 = v16;
  _dispatch_retain((uint64_t)v16);
  uint64_t v4 = _NSConcreteStackBlock;
  int v5 = 1107296256;
  int v6 = 0;
  int v7 = __dispatch_write_block_invoke;
  int v8 = &__block_descriptor_tmp_55_0;
  dispatch_queue_t v10 = v16;
  dispatch_fd_t v12 = v18;
  uint64_t v9 = v15;
  dispatch_data_t v11 = v17;
  _dispatch_fd_entry_init_async(v18, (uint64_t)&v4);
}

void __dispatch_write_block_invoke( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v55 = a1;
  uint64_t v54 = a2;
  uint64_t v53 = a1;
  if (*(_DWORD *)(a2 + 24))
  {
    int v52 = 0;
    int v52 = *(_DWORD *)(v54 + 24);
    int v8 = *(dispatch_queue_s **)(a1 + 40);
    blocint k = _NSConcreteStackBlock;
    int v45 = 1107296256;
    int v46 = 0;
    uint64_t v47 = __dispatch_write_block_invoke_2;
    int v48 = &__block_descriptor_tmp_48;
    int v50 = *(_DWORD *)(a1 + 56);
    uint64_t v49 = *(void *)(a1 + 32);
    int v51 = v52;
    dispatch_channel_async(v8, &block);
    _dispatch_release(*(unsigned int **)(a1 + 40));
  }

  else
  {
    int v43 = 0LL;
    int v43 = *(void **)(v54 + 88);
    if (!v43)
    {
      int v43 = _dispatch_io_create(0LL, a2, a3, a4, a5, a6, a7, a8);
      *((_DWORD *)v43 + 3_dispatch_source_set_handler((uint64_t)source, handler, 2LL, 1) = *(_DWORD *)(a1 + 56);
      *((_DWORD *)v43 + 32) = *(_DWORD *)(a1 + 56);
      v43[14] = v54;
      dispatch_object_t v42 = *(dispatch_object_t *)(v54 + 72);
      dispatch_retain(v42);
      dispatch_object_t v41 = *(dispatch_object_t *)(v54 + 80);
      dispatch_retain(v41);
      v43[7] = *(void *)(v54 + 72);
      v43[8] = *(void *)(v54 + 80);
      *(void *)(v54 + 88) = v43;
    }

    v37[0] = 0LL;
    v37[1] = v37;
    int v38 = 0;
    int v39 = 32;
    uint64_t v40 = 0LL;
    v33[0] = 0LL;
    v33[1] = v33;
    int v34 = 0;
    int v35 = 32;
    int v36 = 0;
    uint64_t v9 = *(dispatch_queue_s **)(v54 + 64);
    int v23 = _NSConcreteStackBlock;
    int v24 = 1107296256;
    int v25 = 0;
    uint64_t v26 = __dispatch_write_block_invoke_49;
    uint64_t v27 = &__block_descriptor_tmp_52_0;
    uint64_t v31 = *(void *)(a1 + 40);
    int v32 = *(_DWORD *)(a1 + 56);
    uint64_t v28 = *(void *)(a1 + 32);
    uint64_t v29 = v37;
    int v30 = v33;
    dispatch_channel_async(v9, &v23);
    int v22 = 0LL;
    dispatch_queue_t v13 = v43;
    size_t size = dispatch_data_get_size(*(dispatch_data_t *)(a1 + 48));
    dispatch_data_t v11 = *(dispatch_object_s **)(a1 + 48);
    size_t v15 = _NSConcreteStackBlock;
    int v16 = 1107296256;
    int v17 = 0;
    dispatch_fd_t v18 = __dispatch_write_block_invoke_53;
    dispatch_io_handler_t v19 = &__block_descriptor_tmp_54;
    dispatch_queue_t v20 = v37;
    dispatch_data_t v21 = v33;
    int v22 = (unsigned int *)_dispatch_operation_create(1u, v13, 0LL, size, v11, (dispatch_queue_s *)&off_E4640, &v15, v12);
    if (v22) {
      _dispatch_operation_enqueue(v22, 1u, *(dispatch_object_s **)(a1 + 48));
    }
    dispatch_release(*(dispatch_object_t *)(a1 + 48));
    _Block_object_dispose(v33, 8);
    _Block_object_dispose(v37, 8);
  }

uint64_t __dispatch_write_block_invoke_2(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16LL))();
}

void __dispatch_write_block_invoke_49(uint64_t a1)
{
  uint64_t v14 = a1;
  uint64_t v13 = a1;
  uint64_t v2 = *(dispatch_queue_s **)(a1 + 56);
  blocint k = _NSConcreteStackBlock;
  int v5 = 1107296256;
  int v6 = 0;
  uint64_t v7 = __dispatch_write_block_invoke_2_50;
  int v8 = &__block_descriptor_tmp_51;
  int v12 = *(_DWORD *)(a1 + 64);
  uint64_t v9 = *(void *)(a1 + 32);
  uint64_t v10 = *(void *)(a1 + 40);
  uint64_t v11 = *(void *)(a1 + 48);
  dispatch_channel_async(v2, &block);
  _dispatch_release(*(unsigned int **)(a1 + 56));
}

void __dispatch_write_block_invoke_2_50(uint64_t a1)
{
  if (*(void *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL)) {
    dispatch_release(*(dispatch_object_t *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL));
  }
}

void __dispatch_write_block_invoke_53(uint64_t a1, char a2, dispatch_object_s *a3, int a4)
{
  if ((a2 & 1) != 0)
  {
    if (a3)
    {
      dispatch_retain(a3);
      *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = a3;
    }

    *(_DWORD *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL) = a4;
  }

void dispatch_write_f(dispatch_fd_t a1, dispatch_data_s *a2, dispatch_queue_s *a3, uint64_t a4, uint64_t a5)
{
  dispatch_fd_t v16 = a1;
  size_t v15 = a2;
  uint64_t v14 = a3;
  uint64_t v13 = a4;
  uint64_t v12 = a5;
  handler = _NSConcreteStackBlock;
  int v6 = 0x40000000;
  int v7 = 0;
  int v8 = __dispatch_write_f_block_invoke;
  uint64_t v9 = &__block_descriptor_tmp_56;
  uint64_t v10 = a5;
  uint64_t v11 = a4;
  dispatch_write(a1, a2, a3, &handler);
}

uint64_t __dispatch_write_f_block_invoke(uint64_t a1, uint64_t a2, unsigned int a3)
{
  return (*(uint64_t (**)(void, uint64_t, void))(a1 + 32))(*(void *)(a1 + 40), a2, a3);
}

void _dispatch_operation_dispose( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(void *)(a1 + 144))
  {
    _dispatch_operation_deliver_data(a1, 2, v15, v16, v17, v18, v19, v20);
    dispatch_group_leave(*(dispatch_group_t *)(*(void *)(a1 + 144) + 80LL));
    _dispatch_fd_entry_release(*(void *)(a1 + 144));
  }

  if (*(void *)(a1 + 136)) {
    _dispatch_release(*(unsigned int **)(a1 + 136));
  }
  if (*(void *)(a1 + 152)) {
    dispatch_release(*(dispatch_object_t *)(a1 + 152));
  }
  if (*(void *)(a1 + 176) && !*(_DWORD *)(a1 + 56)) {
    free(*(void **)(a1 + 176));
  }
  if (*(void *)(a1 + 224)) {
    dispatch_release(*(dispatch_object_t *)(a1 + 224));
  }
  if (*(void *)(a1 + 232)) {
    dispatch_release(*(dispatch_object_t *)(a1 + 232));
  }
  if (*(void *)(a1 + 48)) {
    dispatch_release(*(dispatch_object_t *)(a1 + 48));
  }
  _Block_release(*(const void **)(a1 + 128));
  _dispatch_thread_getspecific(0LL);
  _dispatch_log("%u\t%p\top[%p]: disposed", v21, v22, v23, v24, v25, v26, v27, 1152LL);
}

void _dispatch_operation_deliver_data( uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v65 = a1;
  int v64 = a2;
  subrange = 0LL;
  int v62 = 0;
  unint64_t v61 = 0LL;
  unint64_t v61 = *(void *)(a1 + 208) + *(void *)(a1 + 200);
  char v60 = 0;
  BOOL v32 = 1;
  if ((a2 & 3) == 0) {
    BOOL v32 = (*(_DWORD *)(v65 + 184) & 1) != 0;
  }
  char v60 = v32;
  *(_DWORD *)(v65 + 184) = 0;
  if ((v60 & 1) != 0)
  {
    int v62 = *(_DWORD *)(v65 + 120);
    if (!v62 && (*(_DWORD *)(*(void *)(v65 + 136) + 120LL) & 2) != 0)
    {
      int v62 = 89;
      *(_DWORD *)(v65 + 1memset(__b, 0, 20) = 89;
    }
  }

  else if (v61 < *(void *)(v65 + 72))
  {
    if (*(void *)(v65 + 200) < *(void *)(v65 + 192))
    {
      _dispatch_thread_getspecific(0LL);
      _dispatch_log("%u\t%p\top[%p]: buffer data: undelivered %zu", v8, v9, v10, v11, v12, v13, v14, 2622LL);
      return;
    }
  }

  else
  {
    char v60 = 1;
  }

  if (!*(_DWORD *)(v65 + 56))
  {
    if (*(void *)(v65 + 200))
    {
      BOOL v59 = 0LL;
      BOOL v59 = *(const void **)(v65 + 176);
      subrange = dispatch_data_create(v59, *(void *)(v65 + 200), 0LL, &__block_literal_global);
      *(void *)(v65 + 176) = 0LL;
      *(void *)(v65 + 20_dispatch_source_set_handler((uint64_t)source, handler, 2LL, 0) = 0LL;
      dispatch_data_t concat = 0LL;
      dispatch_data_t concat = dispatch_data_create_concat(*(dispatch_data_t *)(v65 + 232), subrange);
      dispatch_object_t v57 = *(dispatch_object_t *)(v65 + 232);
      dispatch_release(v57);
      uint64_t v56 = subrange;
      dispatch_release(subrange);
      subrange = concat;
    }

    else
    {
      subrange = *(dispatch_data_s **)(v65 + 232);
    }

    if ((v60 & 1) != 0) {
      uint64_t v31 = &_dispatch_data_empty;
    }
    else {
      uint64_t v31 = subrange;
    }
    *(void *)(v65 + 232) = v31;
LABEL_33:
    if ((v60 & 1) != 0 && ((v64 & 8) == 0 || dispatch_data_get_size(subrange)))
    {
      *(void *)(v65 + 208) = 0LL;
      uint64_t v51 = v65;
      _dispatch_object_debug(v65, "%s", a3, a4, a5, a6, a7, a8, (char)"_dispatch_operation_deliver_data");
      _dispatch_thread_getspecific(0LL);
      _dispatch_log("%u\t%p\top[%p]: deliver data", v23, v24, v25, v26, v27, v28, v29, 2687LL);
      int v50 = 0;
      int v50 = *(_DWORD *)(v65 + 56);
      uint64_t v49 = 0LL;
      uint64_t v49 = *(void *)(v65 + 128);
      uint64_t v48 = 0LL;
      uint64_t v48 = *(void *)(v65 + 144);
      _dispatch_fd_entry_retain(v48);
      uint64_t v47 = 0LL;
      uint64_t v47 = *(void *)(v65 + 136);
      uint64_t v46 = v47;
      _dispatch_retain(v47);
      int v30 = *(dispatch_queue_s **)(v65 + 48);
      blocint k = _NSConcreteStackBlock;
      int v34 = 1107296256;
      int v35 = 0;
      int v36 = ___dispatch_operation_deliver_data_block_invoke;
      int v37 = &__block_descriptor_tmp_147;
      int v43 = v64;
      int v39 = subrange;
      int v44 = v50;
      int v45 = v62;
      uint64_t v40 = v65;
      uint64_t v38 = v49;
      uint64_t v41 = v47;
      uint64_t v42 = v48;
      dispatch_channel_async(v30, &block);
    }

    else
    {
      *(void *)(v65 + 208) = v61;
      _dispatch_thread_getspecific(0LL);
      _dispatch_log("%u\t%p\top[%p]: buffer data: undelivered %zu", v16, v17, v18, v19, v20, v21, v22, 2682LL);
    }

    return;
  }

  if (*(_DWORD *)(v65 + 56) == 1)
  {
    if ((v60 & 1) != 0) {
      subrange = dispatch_data_create_subrange( *(dispatch_data_t *)(v65 + 232),  *(void *)(v65 + 200),  *(void *)(v65 + 112));
    }
    if (*(void *)(v65 + 224) && *(void *)(v65 + 200) == *(void *)(v65 + 192))
    {
      dispatch_object_t v55 = *(dispatch_object_t *)(v65 + 224);
      dispatch_release(v55);
      *(void *)(v65 + 224) = 0LL;
      *(void *)(v65 + 176) = 0LL;
      *(void *)(v65 + 20_dispatch_source_set_handler((uint64_t)source, handler, 2LL, 0) = 0LL;
      dispatch_data_t v54 = 0LL;
      if ((v60 & 1) != 0)
      {
        uint64_t v53 = subrange;
        dispatch_retain(subrange);
        dispatch_data_t v54 = subrange;
      }

      else
      {
        dispatch_data_t v54 = dispatch_data_create_subrange( *(dispatch_data_t *)(v65 + 232),  *(void *)(v65 + 192),  *(void *)(v65 + 112));
      }

      dispatch_object_t v52 = *(dispatch_object_t *)(v65 + 232);
      dispatch_release(v52);
      *(void *)(v65 + 232) = v54;
    }

    goto LABEL_33;
  }

  BOOL v15 = *(_DWORD *)(v65 + 56) < 2u;
  BOOL v67 = v15;
  uint64_t v66 = 2677LL;
  if (!v15) {
    _dispatch_abort(v66, v67, a3, a4, a5, a6, a7, a8);
  }
}

void _dispatch_disk_dispose( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(void *)(a1 + 112)) {
    *(void *)(*(void *)(a1 + 112) + 12pthread_sigmask(3, _dispatch_sigsuspend_mask, 0LL) = *(void *)(a1 + 120);
  }
  **(void **)(a1 + 1memset(__b, 0, 20) = *(void *)(a1 + 112);
  *(void *)(a1 + 112) = -1LL;
  *(void *)(a1 + 1memset(__b, 0, 20) = -1LL;
  if (*(void *)(a1 + 48)) {
    _dispatch_abort(1792LL, *(void *)(a1 + 48) == 0LL, a3, a4, a5, a6, a7, a8);
  }
  for (unint64_t i = 0LL; i < *(void *)(a1 + 128); ++i)
  {
    if (*(void *)(a1 + 136 + 8 * i)) {
      _dispatch_abort(1795LL, *(void *)(a1 + 136 + 8 * i) == 0LL, a3, a4, a5, a6, a7, a8);
    }
  }

  dispatch_release(*(dispatch_object_t *)(a1 + 72));
}

void ___dispatch_io_init_block_invoke(uint64_t a1)
{
  uint64_t v13 = a1;
  uint64_t v12 = a1;
  uint64_t v2 = *(dispatch_queue_s **)(a1 + 40);
  blocint k = _NSConcreteStackBlock;
  int v5 = 1107296256;
  int v6 = 0;
  int v7 = ___dispatch_io_init_block_invoke_2;
  uint64_t v8 = &__block_descriptor_tmp_64;
  uint64_t v10 = *(void *)(a1 + 48);
  int v11 = *(_DWORD *)(a1 + 56);
  uint64_t v9 = *(void *)(a1 + 32);
  dispatch_channel_async(v2, &block);
  _dispatch_release(*(unsigned int **)(a1 + 40));
}

uint64_t ___dispatch_io_init_block_invoke_2(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16LL))();
}

void ___dispatch_io_stop_block_invoke(uint64_t a1)
{
  uint64_t v10 = a1;
  uint64_t v9 = a1;
  uint64_t v2 = *(dispatch_queue_s **)(*(void *)(a1 + 32) + 56LL);
  blocint k = _NSConcreteStackBlock;
  int v4 = 0x40000000;
  int v5 = 0;
  uint64_t v6 = ___dispatch_io_stop_block_invoke_2;
  uint64_t v7 = &__block_descriptor_tmp_75;
  uint64_t v8 = *(void *)(a1 + 32);
  dispatch_channel_async(v2, &block);
}

void ___dispatch_io_stop_block_invoke_2( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v26 = a1;
  uint64_t v25 = a1;
  uint64_t v24 = *(void *)(a1 + 32);
  _dispatch_object_debug(v24, "%s", a3, a4, a5, a6, a7, a8, (char)"_dispatch_io_stop_block_invoke_2");
  uint64_t v23 = 0LL;
  uint64_t v23 = *(void *)(*(void *)(a1 + 32) + 112LL);
  if (v23)
  {
    _dispatch_thread_getspecific(0LL);
    _dispatch_log("%u\t%p\tchannel[%p]: stop cleanup", v8, v9, v10, v11, v12, v13, v14, 744LL);
    _dispatch_fd_entry_cleanup_operations(v23, *(void *)(a1 + 32));
    if ((*(_DWORD *)(*(void *)(a1 + 32) + 120LL) & 1) == 0)
    {
      if (*(void *)(v23 + 8)) {
        **(void **)(v23 + 8) = 0LL;
      }
      *(void *)(*(void *)(a1 + 32) + 112LL) = 0LL;
      _dispatch_fd_entry_release(v23);
    }
  }

  else if (*(_DWORD *)(*(void *)(a1 + 32) + 124LL) != -1)
  {
    uint64_t v22 = *(void *)(a1 + 32);
    _dispatch_retain(v22);
    blocint k = _NSConcreteStackBlock;
    int v17 = 0x40000000;
    int v18 = 0;
    uint64_t v19 = ___dispatch_io_stop_block_invoke_3;
    uint64_t v20 = &__block_descriptor_tmp_74;
    uint64_t v21 = *(void *)(a1 + 32);
    dispatch_channel_async((dispatch_queue_t)_dispatch_io_fds_lockq, &block);
  }

  _dispatch_release(*(unsigned int **)(a1 + 32));
}

void _dispatch_fd_entry_cleanup_operations(uint64_t a1, uint64_t a2)
{
  uint64_t v24 = a1;
  uint64_t v23 = a2;
  if (*(void *)(a1 + 56))
  {
    if (v23)
    {
      uint64_t v22 = v23;
      _dispatch_retain(v23);
    }

    _dispatch_fd_entry_retain(v24);
    uint64_t v2 = *(dispatch_queue_s **)(*(void *)(v24 + 56) + 72LL);
    blocint k = _NSConcreteStackBlock;
    int v16 = 0x40000000;
    int v17 = 0;
    int v18 = ___dispatch_fd_entry_cleanup_operations_block_invoke;
    uint64_t v19 = &__block_descriptor_tmp_77;
    uint64_t v20 = v24;
    uint64_t v21 = v23;
    dispatch_channel_async(v2, &block);
  }

  else
  {
    for (unsigned int i = 0; i < 2; ++i)
    {
      uint64_t v13 = 0LL;
      uint64_t v13 = *(dispatch_queue_s ***)(v24 + 40 + 8LL * i);
      if (v13)
      {
        if (v23)
        {
          uint64_t v12 = v23;
          _dispatch_retain(v23);
        }

        _dispatch_fd_entry_retain(v24);
        uint64_t v3 = *v13;
        int v4 = _NSConcreteStackBlock;
        int v5 = 0x40000000;
        int v6 = 0;
        uint64_t v7 = ___dispatch_fd_entry_cleanup_operations_block_invoke_2;
        uint64_t v8 = &__block_descriptor_tmp_78;
        uint64_t v9 = v13;
        uint64_t v10 = v23;
        uint64_t v11 = v24;
        dispatch_channel_async(v3, &v4);
      }
    }
  }

void ___dispatch_io_stop_block_invoke_3( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  for (uint64_t i = _dispatch_io_fds[*(_DWORD *)(*(void *)(a1 + 32) + 124LL) & 0x3FLL]; i; uint64_t i = *(void *)(i + 112))
  {
    if (*(_DWORD *)i == *(_DWORD *)(*(void *)(a1 + 32) + 124LL))
    {
      _dispatch_fd_entry_cleanup_operations(i, *(void *)(a1 + 32));
      break;
    }
  }

  _dispatch_release(*(unsigned int **)(a1 + 32));
}

void ___dispatch_fd_entry_cleanup_operations_block_invoke(uint64_t a1)
{
  if (*(void *)(a1 + 40)) {
    _dispatch_release(*(unsigned int **)(a1 + 40));
  }
}

void _dispatch_disk_cleanup_inactive_operations(uint64_t a1, uint64_t a2)
{
}

void ___dispatch_fd_entry_cleanup_operations_block_invoke_2( uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1[5]) {
    _dispatch_release((unsigned int *)a1[5]);
  }
}

void _dispatch_stream_cleanup_operations( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10 = 0LL;
  for (uint64_t i = *(void *)(a1 + 48); ; uint64_t i = v10)
  {
    char v9 = 0;
    if (i)
    {
      uint64_t v10 = *(void *)(i + 240);
      char v9 = 1;
    }

    if ((v9 & 1) == 0) {
      break;
    }
    if (!a2 || *(void *)(i + 136) == a2) {
      _dispatch_stream_complete_operation(a1, i, a3, a4, a5, a6, a7, a8);
    }
  }

  for (uint64_t j = *(void *)(a1 + 32); ; uint64_t j = v10)
  {
    char v8 = 0;
    if (j)
    {
      uint64_t v10 = *(void *)(j + 240);
      char v8 = 1;
    }

    if ((v8 & 1) == 0) {
      break;
    }
    if (!a2 || *(void *)(j + 136) == a2) {
      _dispatch_stream_complete_operation(a1, j, a3, a4, a5, a6, a7, a8);
    }
  }

  if ((*(_BYTE *)(a1 + 24) & 1) != 0 && !_dispatch_stream_operation_avail(a1))
  {
    dispatch_suspend(*(dispatch_object_t *)(a1 + 8));
    *(_BYTE *)(a1 + 24) = 0;
  }

void _dispatch_disk_cleanup_specified_operations(uint64_t a1, uint64_t a2, char a3)
{
  char v19 = a3 & 1;
  uint64_t v17 = 0LL;
  for (uint64_t i = *(void *)(a1 + 48); ; uint64_t i = v17)
  {
    char v16 = 0;
    if (i)
    {
      uint64_t v17 = *(void *)(i + 240);
      char v16 = 1;
    }

    if ((v16 & 1) == 0) {
      break;
    }
    if (((v19 & 1) == 0 || (*(_BYTE *)(i + 160) & 1) == 0) && (!a2 || *(void *)(i + 136) == a2))
    {
      _dispatch_thread_getspecific(0LL);
      _dispatch_log("%u\t%p\top[%p]: cleanup: disk %p", v3, v4, v5, v6, v7, v8, v9, 1985LL);
      _dispatch_disk_complete_operation(a1, i, v10, v11, v12, v13, v14, v15);
    }
  }

void _dispatch_disk_complete_operation( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(void *)(a1 + 64) == a2) {
    *(void *)(a1 + 64) = **(void **)(*(void *)(a2 + 248) + 8LL);
  }
  if (!*(void *)(a2 + 64))
  {
    uint64_t v22 = *(void *)(a2 + 256);
    if (v22) {
      *(void *)(*(void *)(a2 + 256) + 264LL) = *(void *)(a2 + 264);
    }
    else {
      *(void *)(*(void *)(a2 + 144) + 104LL) = *(void *)(a2 + 264);
    }
    **(void **)(a2 + 264) = *(void *)(a2 + 256);
    *(void *)(a2 + 256) = -1LL;
    *(void *)(a2 + 264) = -1LL;
    if (v22)
    {
      *(void *)(v22 + 24_dispatch_source_set_handler((uint64_t)source, handler, 2LL, 0) = 0LL;
      *(void *)(v22 + 248) = *(void *)(a1 + 56);
      **(void **)(a1 + 56) = v22;
      *(void *)(a1 + 56) = v22 + 240;
    }
  }

  if (*(void *)(a2 + 240)) {
    *(void *)(*(void *)(a2 + 240) + 248LL) = *(void *)(a2 + 248);
  }
  else {
    *(void *)(a1 + 56) = *(void *)(a2 + 248);
  }
  **(void **)(a2 + 248) = *(void *)(a2 + 240);
  *(void *)(a2 + 24_dispatch_source_set_handler((uint64_t)source, handler, 2LL, 0) = -1LL;
  *(void *)(a2 + 248) = -1LL;
  if (*(void *)(a2 + 152)) {
    dispatch_source_cancel(*(dispatch_source_t *)(a2 + 152));
  }
  _dispatch_thread_getspecific(0LL);
  _dispatch_log("%u\t%p\top[%p]: release -> %d (disk complete)", v15, v16, v17, v18, v19, v20, v21, 1888LL);
  _dispatch_release((unsigned int *)a2);
}

void _dispatch_stream_complete_operation( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(void *)(a2 + 240)) {
    *(void *)(*(void *)(a2 + 240) + 248LL) = *(void *)(a2 + 248);
  }
  else {
    *(void *)(a1 + 32 + 16LL * *(void *)(a2 + 64) + 8) = *(void *)(a2 + 248);
  }
  **(void **)(a2 + 248) = *(void *)(a2 + 240);
  *(void *)(a2 + 24_dispatch_source_set_handler((uint64_t)source, handler, 2LL, 0) = -1LL;
  *(void *)(a2 + 248) = -1LL;
  if (a2 == *(void *)(a1 + 16)) {
    *(void *)(a1 + 16) = 0LL;
  }
  if (*(void *)(a2 + 152)) {
    dispatch_source_cancel(*(dispatch_source_t *)(a2 + 152));
  }
  _dispatch_thread_getspecific(0LL);
  _dispatch_log("%u\t%p\top[%p]: release -> %d (stream complete)", v15, v16, v17, v18, v19, v20, v21, 1860LL);
  _dispatch_release((unsigned int *)a2);
}

BOOL _dispatch_stream_operation_avail(uint64_t a1)
{
  BOOL v2 = 1;
  if (!*(void *)(a1 + 48)) {
    return *(void *)(a1 + 32) != 0LL;
  }
  return v2;
}

void ___dispatch_operation_create_block_invoke(uint64_t a1)
{
  uint64_t v15 = a1;
  uint64_t v14 = a1;
  BOOL v2 = *(dispatch_queue_s **)(a1 + 40);
  blocint k = _NSConcreteStackBlock;
  int v5 = 1107296256;
  int v6 = 0;
  uint64_t v7 = ___dispatch_operation_create_block_invoke_2;
  uint64_t v8 = &__block_descriptor_tmp_85;
  uint64_t v10 = *(void *)(a1 + 48);
  int v12 = *(_DWORD *)(a1 + 64);
  int v13 = *(_DWORD *)(a1 + 68);
  uint64_t v11 = *(void *)(a1 + 56);
  uint64_t v9 = *(void *)(a1 + 32);
  dispatch_channel_async(v2, &block);
  _dispatch_release(*(unsigned int **)(a1 + 40));
}

void ___dispatch_operation_create_block_invoke_2(uint64_t a1)
{
}

void ___dispatch_operation_enqueue_block_invoke(uint64_t a1)
{
}

void ___dispatch_operation_enqueue_block_invoke_91(uint64_t a1)
{
}

void _dispatch_stream_enqueue_operation(dispatch_queue_t *a1, void *a2, dispatch_object_s *a3)
{
  if ((_dispatch_operation_should_enqueue((uint64_t)a2, *a1, a3) & 1) != 0)
  {
    _dispatch_object_debug((uint64_t)a2, "%s", v3, v4, v5, v6, v7, v8, (char)"_dispatch_stream_enqueue_operation");
    BOOL v9 = !_dispatch_stream_operation_avail((uint64_t)a1);
    a2[30] = 0LL;
    a2[31] = a1[2 * a2[8] + 5];
    *(void *)a1[2 * a2[8] + 5] = a2;
    a1[2 * a2[8] + 5] = (dispatch_queue_t)(a2 + 30);
    if (v9) {
      dispatch_channel_async_f(*a1, *a1, (dispatch_function_t)_dispatch_stream_queue_handler);
    }
  }

void ___dispatch_operation_enqueue_block_invoke_2(uint64_t a1)
{
}

void _dispatch_disk_enqueue_operation(uint64_t a1, void *a2, dispatch_object_s *a3)
{
  if ((_dispatch_operation_should_enqueue((uint64_t)a2, *(dispatch_queue_s **)(a1 + 72), a3) & 1) != 0)
  {
    _dispatch_object_debug((uint64_t)a2, "%s", v3, v4, v5, v6, v7, v8, (char)"_dispatch_disk_enqueue_operation");
    if (a2[8])
    {
      a2[30] = 0LL;
      a2[31] = *(void *)(a1 + 56);
      **(void **)(a1 + 56) = a2;
      *(void *)(a1 + 56) = a2 + 30;
    }

    else
    {
      if (!*(void *)(a2[18] + 96LL))
      {
        a2[30] = 0LL;
        a2[31] = *(void *)(a1 + 56);
        **(void **)(a1 + 56) = a2;
        *(void *)(a1 + 56) = a2 + 30;
      }

      a2[32] = 0LL;
      a2[33] = *(void *)(a2[18] + 104LL);
      **(void **)(a2[18] + 104LL) = a2;
      *(void *)(a2[18] + 104LL) = a2 + 32;
    }

    _dispatch_disk_handler(a1);
  }

uint64_t _dispatch_operation_should_enqueue(uint64_t a1, dispatch_queue_s *a2, dispatch_object_s *a3)
{
  *(void *)(a1 + 232) = a3;
  int error = _dispatch_io_get_error(a1, 0LL, 1);
  if (error)
  {
    *(_DWORD *)(a1 + 1memset(__b, 0, 20) = error;
    _dispatch_thread_getspecific(0LL);
    _dispatch_log("%u\t%p\top[%p]: release -> %d, err %d", v10, v11, v12, v13, v14, v15, v16, 1210LL);
    _dispatch_release((unsigned int *)a1);
    char v23 = 0;
  }

  else
  {
    if (*(void *)(a1 + 88))
    {
      dispatch_object_t object = (dispatch_object_s *)_dispatch_operation_timer(a2, a1);
      dispatch_resume(object);
    }

    char v23 = 1;
  }

  return v23 & 1;
}

void _dispatch_stream_queue_handler(dispatch_object_s *a1)
{
  context = dispatch_get_context(a1);
  if (context) {
    _dispatch_stream_handler((uint64_t)context);
  }
}

uint64_t _dispatch_operation_timer(dispatch_queue_s *a1, uint64_t a2)
{
  dispatch_queue_t v13 = a1;
  uint64_t v12 = a2;
  if (!*(void *)(a2 + 152))
  {
    dispatch_source_t v11 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_timer, 0LL, 0LL, v13);
    dispatch_time_t v2 = dispatch_time(0LL, *(void *)(v12 + 88));
    dispatch_source_set_timer(v11, v2, *(void *)(v12 + 88), 0LL);
    handler = _NSConcreteStackBlock;
    int v5 = 0x40000000;
    int v6 = 0;
    uint64_t v7 = ___dispatch_operation_timer_block_invoke;
    uint64_t v8 = &__block_descriptor_tmp_95;
    dispatch_source_t v9 = v11;
    uint64_t v10 = v12;
    dispatch_source_set_event_handler(v11, &handler);
    *(void *)(v12 + 152) = v11;
  }

  return *(void *)(v12 + 152);
}

void ___dispatch_operation_timer_block_invoke(uint64_t a1)
{
  if (!dispatch_source_testcancel(*(dispatch_source_t *)(a1 + 32)))
  {
    BOOL v8 = (*(void *)(*(void *)(a1 + 40) + 96LL) & 1LL) != 0;
    if ((*(_BYTE *)(*(void *)(a1 + 40) + 160LL) & 1) != 0 && (*(void *)(*(void *)(a1 + 40) + 96LL) & 1LL) != 0) {
      *(_DWORD *)(*(void *)(a1 + 40) + 184LL) = v8;
    }
    else {
      _dispatch_operation_deliver_data(*(void *)(a1 + 40), v8, v1, v2, v3, v4, v5, v6);
    }
  }

void _dispatch_stream_handler(uint64_t a1)
{
  while (1)
  {
    uint64_t operation = _dispatch_stream_pick_next_operation(a1, *(void *)(a1 + 16));
    if (!operation)
    {
      _dispatch_thread_getspecific(0LL);
      _dispatch_log("%u\t%p\tno operation found: stream %p", v1, v2, v3, v4, v5, v6, v7, 2072LL);
      return;
    }

    int error = _dispatch_io_get_error(operation, 0LL, 1);
    if (!error) {
      break;
    }
    *(_DWORD *)(operation + 1memset(__b, 0, 20) = error;
    _dispatch_stream_complete_operation(a1, operation, v8, v9, v10, v11, v12, v13);
  }

  *(void *)(a1 + 16) = operation;
  _dispatch_thread_getspecific(0LL);
  _dispatch_log("%u\t%p\top[%p]: stream handler", v14, v15, v16, v17, v18, v19, v20, 2082LL);
  uint64_t v35 = *(void *)(operation + 144);
  _dispatch_fd_entry_retain(v35);
  if (!*(void *)(operation + 216) && (byte_E4D40 & 1) != 0)
  {
    _dispatch_thread_getspecific(0LL);
    _dispatch_log("%u\t%p\top[%p]: initial delivery", v21, v22, v23, v24, v25, v26, v27, 2088LL);
    _dispatch_operation_deliver_data(operation, 1, v28, v29, v30, v31, v32, v33);
  }

  unint64_t v34 = _dispatch_operation_perform(operation) - 1;
  if (v34 <= 6) {
    __asm { BR              X8 }
  }

  _dispatch_fd_entry_release(v35);
}

uint64_t _dispatch_stream_pick_next_operation(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = a2;
  if (a2)
  {
    if (*(void *)(a2 + 64))
    {
      if (*(void *)(a2 + 64) == 1LL)
      {
        uint64_t v4 = *(void *)(a2 + 240);
        if (!v4) {
          return *(void *)(a1 + 48);
        }
        return v4;
      }

      else
      {
        return 0LL;
      }
    }

    else
    {
      return a2;
    }
  }

  else if (_dispatch_stream_operation_avail(a1))
  {
    if (*(void *)(a1 + 32)) {
      return *(void *)(a1 + 32);
    }
    if (*(void *)(a1 + 48)) {
      return *(void *)(a1 + 48);
    }
    return v3;
  }

  else
  {
    return 0LL;
  }

uint64_t _dispatch_operation_perform(uint64_t a1)
{
  uint64_t v76 = a1;
  _dispatch_thread_getspecific(0LL);
  _dispatch_log("%u\t%p\top[%p]: perform", v1, v2, v3, v4, v5, v6, v7, 2328LL);
  int error = _dispatch_io_get_error(v76, 0LL, 1);
  if (error) {
    goto LABEL_45;
  }
  uint64_t v74 = v76;
  _dispatch_object_debug(v76, "%s", v8, v9, v10, v11, v12, v13, (char)"_dispatch_operation_perform");
  if (!*(void *)(v76 + 176))
  {
    unint64_t v73 = 0LL;
    unint64_t v73 = *(void *)(v76 + 80);
    unint64_t v72 = dispatch_io_defaults;
    if (*(_DWORD *)(v76 + 56))
    {
      if (*(_DWORD *)(v76 + 56) == 1)
      {
        if (v72 > v73) {
          unint64_t v72 = v73;
        }
        *(void *)(v76 + 192) = 0LL;
        uint64_t v27 = *(dispatch_data_s **)(v76 + 232);
        applier = _NSConcreteStackBlock;
        int v65 = 0x40000000;
        int v66 = 0;
        BOOL v67 = ___dispatch_operation_perform_block_invoke;
        __int16 v68 = &__block_descriptor_tmp_103;
        uint64_t v69 = v76;
        unint64_t v70 = v72;
        dispatch_data_apply(v27, &applier);
        if (*(void *)(v76 + 192) > v73) {
          *(void *)(v76 + 192) = v73;
        }
        uintptr_t data = dispatch_data_create_subrange(*(dispatch_data_t *)(v76 + 232), 0LL, *(void *)(v76 + 192));
        *(void *)(v76 + 224) = dispatch_data_create_map(data, (const void **)(v76 + 176), 0LL);
        dispatch_release(data);
        _dispatch_thread_getspecific(0LL);
        _dispatch_log("%u\t%p\top[%p]: buffer mapped", v28, v29, v30, v31, v32, v33, v34, 2396LL);
      }
    }

    else
    {
      size_t size = 0LL;
      size_t size = dispatch_data_get_size(*(dispatch_data_t *)(v76 + 232));
      if (size)
      {
        BOOL v81 = size < v73;
        uint64_t v80 = 2342LL;
        if (size >= v73) {
          _dispatch_abort(v80, 0LL, v14, v15, v16, v17, v18, v19);
        }
        v73 -= size;
      }

      if (v73 > v72) {
        unint64_t v73 = v72;
      }
      if (*(void *)(v76 + 112) == -1LL)
      {
        *(void *)(v76 + 192) = v73;
      }

      else
      {
        *(void *)(v76 + 192) = *(void *)(v76 + 112) - *(void *)(v76 + 216);
        if (*(void *)(v76 + 192) > v73) {
          *(void *)(v76 + 192) = v73;
        }
      }

      int error = malloc_type_posix_memalign(v76 + 176, vm_page_size, *(void *)(v76 + 192), 595666265LL);
      if (error) {
        goto LABEL_45;
      }
      _dispatch_thread_getspecific(0LL);
      _dispatch_log("%u\t%p\top[%p]: buffer allocated", v20, v21, v22, v23, v24, v25, v26, 2370LL);
    }
  }

  if (**(_DWORD **)(v76 + 144) == -1)
  {
    int error = _dispatch_fd_entry_open(*(void *)(v76 + 144), *(void *)(v76 + 136));
    if (error)
    {
LABEL_45:
      if (error == 35)
      {
        BOOL v79 = *(void *)(*(void *)(v76 + 144) + 56LL) == 0LL;
        uint64_t v78 = 2583LL;
        if (!v79) {
          _dispatch_abort(v78, 0LL, v8, v9, v10, v11, v12, v13);
        }
        _dispatch_thread_getspecific(0LL);
        _dispatch_log("%u\t%p\top[%p]: performed: EAGAIN/EWOULDBLOCK", v42, v43, v44, v45, v46, v47, v48, 2584LL);
        if (!*(_DWORD *)(v76 + 56)
          && *(void *)(v76 + 216)
          && *(void *)(v76 + 136) == *(void *)(*(void *)(v76 + 144) + 88LL))
        {
          return 4;
        }

        else
        {
          return 5;
        }
      }

      else
      {
        _dispatch_thread_getspecific(0LL);
        _dispatch_log("%u\t%p\top[%p]: performed: err %d", v49, v50, v51, v52, v53, v54, v55, 2592LL);
        *(_DWORD *)(v76 + 1memset(__b, 0, 20) = error;
        if (error == 9)
        {
          uint64_t v56 = (unsigned int *)(*(void *)(v76 + 144) + 24LL);
          do
            unsigned int v57 = __ldaxr(v56);
          while (!v57 && __stlxr(9u, v56));
          return 7;
        }

        else if (error == 89)
        {
          return 6;
        }

        else
        {
          return 1;
        }
      }
    }
  }

  uint64_t v62 = *(void *)(v76 + 176) + *(void *)(v76 + 200);
  uint64_t v61 = *(void *)(v76 + 192) - *(void *)(v76 + 200);
  uint64_t v60 = *(void *)(v76 + 104) + *(void *)(v76 + 216);
  uint64_t NOCANCEL = -1LL;
  while (1)
  {
    if (*(_DWORD *)(v76 + 56))
    {
      if (*(_DWORD *)(v76 + 56) == 1)
      {
        if (*(void *)(v76 + 64))
        {
          if (*(void *)(v76 + 64) == 1LL) {
            uint64_t NOCANCEL = pwrite_NOCANCEL(**(unsigned int **)(v76 + 144), v62, v61, v60);
          }
        }

        else
        {
          uint64_t NOCANCEL = write_NOCANCEL(**(unsigned int **)(v76 + 144), v62, v61);
        }
      }
    }

    else if (*(void *)(v76 + 64))
    {
      if (*(void *)(v76 + 64) == 1LL) {
        uint64_t NOCANCEL = pread_NOCANCEL(**(unsigned int **)(v76 + 144), v62, v61, v60);
      }
    }

    else
    {
      uint64_t NOCANCEL = read_NOCANCEL(**(unsigned int **)(v76 + 144), v62, v61);
    }

    if (NOCANCEL != -1) {
      break;
    }
    uint64_t v82 = 1LL;
    uint64_t v83 = 1LL;
    unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
    int error = **(_DWORD **)(StatusReg + 8);
    if (error != 4) {
      goto LABEL_45;
    }
  }

  if (NOCANCEL)
  {
    *(void *)(v76 + 200) += NOCANCEL;
    *(void *)(v76 + 216) += NOCANCEL;
    if (*(void *)(v76 + 216) == *(void *)(v76 + 112)) {
      return 1;
    }
    else {
      return 2;
    }
  }

  else
  {
    _dispatch_thread_getspecific(0LL);
    _dispatch_log("%u\t%p\top[%p]: performed: EOF", v35, v36, v37, v38, v39, v40, v41, 2568LL);
    return 3;
  }

dispatch_queue_t _dispatch_stream_source(dispatch_queue_t *a1, uint64_t a2)
{
  uint64_t v29 = a1;
  uint64_t v28 = a2;
  if (a1[1]) {
    return v29[1];
  }
  int v27 = 0;
  int v27 = **(_DWORD **)(v28 + 144);
  _dispatch_thread_getspecific(0LL);
  _dispatch_log("%u\t%p\top[%p]: stream source create", v2, v3, v4, v5, v6, v7, v8, 2015LL);
  dispatch_source_t v26 = 0LL;
  if (!*(_DWORD *)(v28 + 56))
  {
    dispatch_source_t v26 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_read, v27, 0LL, *v29);
LABEL_10:
    dispatch_source_t v25 = v26;
    dispatch_set_context(v26, v29);
    dispatch_source_set_event_handler_f(v26, (dispatch_function_t)_dispatch_stream_source_handler);
    uint64_t v24 = 0LL;
    uint64_t v24 = *(void *)(*(void *)(v28 + 144) + 64LL);
    uint64_t v17 = _NSConcreteStackBlock;
    int v18 = 0x40000000;
    int v19 = 0;
    uint64_t v20 = ___dispatch_stream_source_block_invoke;
    uint64_t v21 = &__block_descriptor_tmp_110;
    uint64_t v22 = v28;
    uint64_t v23 = v24;
    dispatch_source_set_mandatory_cancel_handler(v26, &v17);
    v29[1] = (dispatch_queue_t)v26;
    return v29[1];
  }

  if (*(_DWORD *)(v28 + 56) == 1)
  {
    dispatch_source_t v26 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_write, v27, 0LL, *v29);
    goto LABEL_10;
  }

  BOOL v15 = *(_DWORD *)(v28 + 56) < 2u;
  BOOL v32 = v15;
  uint64_t v31 = 2024LL;
  if (!v15) {
    _dispatch_abort(v31, v32, v9, v10, v11, v12, v13, v14);
  }
  return 0LL;
}

void ___dispatch_stream_handler_block_invoke(uint64_t a1)
{
}

BOOL ___dispatch_operation_perform_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  unint64_t v6 = *(void *)(*(void *)(a1 + 32) + 192LL) + a5;
  if (!*(void *)(*(void *)(a1 + 32) + 192LL) || v6 <= *(void *)(a1 + 40)) {
    *(void *)(*(void *)(a1 + 32) + 192LL) = v6;
  }
  return v6 < *(void *)(a1 + 40);
}

uint64_t _dispatch_stream_source_handler(uint64_t a1)
{
  *(_BYTE *)(a1 + 24) = 0;
  return _dispatch_stream_handler(a1);
}

void ___dispatch_stream_source_block_invoke(uint64_t a1)
{
}

void _dispatch_disk_handler(uint64_t a1)
{
  if ((*(_BYTE *)(a1 + 108) & 1) == 0)
  {
    _dispatch_thread_getspecific(0LL);
    _dispatch_log("%u\t%p\tdisk[%p]: disk handler", v1, v2, v3, v4, v5, v6, v7, 2146LL);
    unint64_t v43 = *(void *)(a1 + 80);
    unint64_t v42 = *(void *)(a1 + 88);
    if (v42 <= v43) {
      v42 += *(void *)(a1 + 128);
    }
    while (v43 <= v42)
    {
      if (*(void *)(a1 + 136 + 8 * (v43 % *(void *)(a1 + 128)))) {
        break;
      }
      uint64_t operation = _dispatch_disk_pick_next_operation(a1);
      if (!operation) {
        break;
      }
      int error = _dispatch_io_get_error(operation, 0LL, 1);
      if (error)
      {
        *(_DWORD *)(operation + 1memset(__b, 0, 20) = error;
        _dispatch_disk_complete_operation(a1, operation, v8, v9, v10, v11, v12, v13);
      }

      else
      {
        _dispatch_retain(operation);
        _dispatch_thread_getspecific(0LL);
        _dispatch_log("%u\t%p\top[%p]: retain -> %d", v14, v15, v16, v17, v18, v19, v20, 2162LL);
        *(void *)(a1 + 136 + 8 * (v43 % *(void *)(a1 + 128))) = operation;
        *(_BYTE *)(operation + 16_dispatch_source_set_handler((uint64_t)source, handler, 2LL, 0) = 1;
        _dispatch_thread_getspecific(0LL);
        _dispatch_log("%u\t%p\top[%p]: activate: disk %p", v21, v22, v23, v24, v25, v26, v27, 2165LL);
        _dispatch_object_debug(operation, "%s", v28, v29, v30, v31, v32, v33, (char)"_dispatch_disk_handler");
        ++v43;
      }
    }

    *(void *)(a1 + 8_dispatch_source_set_handler((uint64_t)source, handler, 2LL, 0) = v43 % *(void *)(a1 + 128);
    uint64_t v45 = *(void *)(a1 + 136 + 8LL * *(void *)(a1 + 88));
    if (v45)
    {
      *(_BYTE *)(a1 + 108) = 1;
      _dispatch_thread_getspecific(0LL);
      _dispatch_log("%u\t%p\top[%p]: async perform: disk %p", v34, v35, v36, v37, v38, v39, v40, 2177LL);
      dispatch_channel_async_f(*(dispatch_queue_t *)(v45 + 24), (void *)a1, (dispatch_function_t)_dispatch_disk_perform);
    }
  }

uint64_t _dispatch_disk_pick_next_operation(uint64_t a1)
{
  if (!*(void *)(a1 + 48)) {
    return 0LL;
  }
  if (*(void *)(a1 + 64))
  {
    uint64_t v3 = *(void *)(a1 + 64);
    do
    {
      uint64_t v3 = *(void *)(v3 + 240);
      if (!v3) {
        uint64_t v3 = *(void *)(a1 + 48);
      }
      BOOL v2 = 0;
      if ((*(_BYTE *)(v3 + 160) & 1) != 0) {
        BOOL v2 = v3 != *(void *)(a1 + 64);
      }
    }

    while (v2);
  }

  else
  {
    uint64_t v3 = *(void *)(a1 + 48);
  }

  if ((*(_BYTE *)(v3 + 160) & 1) != 0) {
    return 0LL;
  }
  *(void *)(a1 + 64) = v3;
  return v3;
}

void _dispatch_disk_perform(void *a1)
{
  uint64_t v49 = a1;
  uint64_t v48 = a1;
  _dispatch_thread_getspecific(0LL);
  _dispatch_log("%u\t%p\tdisk[%p]: disk perform", v1, v2, v3, v4, v5, v6, v7, 2186LL);
  uint64_t v47 = dispatch_io_defaults;
  uint64_t v46 = 0LL;
  unint64_t v45 = 0LL;
  unint64_t v45 = v48[12];
  unint64_t v44 = 0LL;
  unint64_t v44 = v48[10];
  if (v44 <= v45) {
    v44 += v48[16];
  }
  while (1)
  {
    uint64_t v46 = v48[v45 % v48[16] + 17];
    if (!v46) {
      break;
    }
    if (*(_DWORD *)(v46 + 56) != 1
      && (**(_DWORD **)(v46 + 144) != -1
       || !_dispatch_fd_entry_open(*(void *)(v46 + 144), *(void *)(v46 + 136))))
    {
      if (!*(void *)(v46 + 216) && (byte_E4D40 & 1) != 0)
      {
        _dispatch_thread_getspecific(0LL);
        _dispatch_log("%u\t%p\top[%p]: initial delivery", v14, v15, v16, v17, v18, v19, v20, 2211LL);
        _dispatch_operation_deliver_data(v46, 1, v21, v22, v23, v24, v25, v26);
      }

      if (v44 - v45 == 1 && !v48[v48[10] + 17] && !*(void *)(v46 + 168)) {
        v47 *= 2LL;
      }
      _dispatch_operation_advise(v46, v47);
    }

    if (++v45 >= v44) {
      goto LABEL_19;
    }
  }

  BOOL v51 = v45 % v48[16] == v48[10];
  uint64_t v50 = 2197LL;
  if (!v51) {
    _dispatch_abort(v50, 0LL, v8, v9, v10, v11, v12, v13);
  }
LABEL_19:
  v48[12] = v45 % v48[16];
  uint64_t v46 = v48[v48[11] + 17];
  int v43 = _dispatch_operation_perform(v46);
  v48[v48[11] + 17] = 0LL;
  v48[11] = (unint64_t)(v48[11] + 1LL) % v48[16];
  _dispatch_thread_getspecific(0LL);
  _dispatch_log("%u\t%p\top[%p]: async perform completion: disk %p", v27, v28, v29, v30, v31, v32, v33, 2227LL);
  uint64_t v34 = (dispatch_queue_s *)v48[9];
  blocint k = _NSConcreteStackBlock;
  int v36 = 0x40000000;
  int v37 = 0;
  uint64_t v38 = ___dispatch_disk_perform_block_invoke;
  uint64_t v39 = &__block_descriptor_tmp_120;
  uint64_t v40 = v46;
  int v42 = v43;
  uint64_t v41 = v48;
  dispatch_channel_async(v34, &block);
}

void _dispatch_operation_advise(uint64_t a1, uint64_t a2)
{
  if (!_dispatch_io_get_error(a1, 0LL, 1)
    && *(void *)(a1 + 168) <= (int64_t)(*(void *)(a1 + 104) + *(void *)(a1 + 216) + a2 + vm_page_size))
  {
    _dispatch_object_debug(a1, "%s", v9, v10, v11, v12, v13, v14, (char)"_dispatch_operation_advise");
    int v24 = a2;
    if (!*(void *)(a1 + 168))
    {
      *(void *)(a1 + 168) = *(void *)(a1 + 104);
      vm_size_t v23 = (*(void *)(a1 + 104) + a2) % vm_page_size;
      if (v23) {
        int v22 = vm_page_size - v23;
      }
      else {
        int v22 = 0;
      }
      int v24 = a2 + v22;
    }

    *(void *)(a1 + 168) += v24;
    while (1)
    {
      int v21 = fcntl_NOCANCEL(**(unsigned int **)(a1 + 144), 44LL) == -1
          ? **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8)
          : 0;
      if (!v21) {
        break;
      }
      if (v21 != 4)
      {
        if (v21 != 27 && v21 != 45) {
          _dispatch_bug(2308LL, v21, v15, v16, v17, v18, v19, v20);
        }
        return;
      }
    }
  }

void ___dispatch_disk_perform_block_invoke(uint64_t a1)
{
  unint64_t v28 = (*(_DWORD *)(a1 + 48) - 1);
  if (v28 <= 6) {
    __asm { BR              X8 }
  }

  if (!*(_DWORD *)(a1 + 48)) {
    _dispatch_abort(2248LL, *(int *)(a1 + 48), v8, v9, v10, v11, v12, v13);
  }
  _dispatch_thread_getspecific(0LL);
  _dispatch_log("%u\t%p\top[%p]: deactivate: disk %p", v14, v15, v16, v17, v18, v19, v20, 2251LL);
  *(_BYTE *)(*(void *)(a1 + 32) + 16pthread_sigmask(3, _dispatch_sigsuspend_mask, 0LL) = 0;
  *(_BYTE *)(*(void *)(a1 + 40) + 108LL) = 0;
  _dispatch_disk_handler(*(void *)(a1 + 40));
  _dispatch_thread_getspecific(0LL);
  _dispatch_log("%u\t%p\top[%p]: release -> %d (disk perform complete)", v21, v22, v23, v24, v25, v26, v27, 2259LL);
  _dispatch_release(*(unsigned int **)(a1 + 32));
}

void _dispatch_disk_cleanup_operations(uint64_t a1, uint64_t a2)
{
}

void ___dispatch_fd_entry_init_async_block_invoke(uint64_t a1)
{
  uint64_t v20 = a1;
  uint64_t v19 = a1;
  uint64_t i = 0LL;
  uint64_t v17 = 0LL;
  uint64_t v17 = *(_DWORD *)(a1 + 40) & 0x3FLL;
  for (uint64_t i = _dispatch_io_fds[v17]; i; uint64_t i = *(void *)(i + 112))
  {
    if (*(_DWORD *)i == *(_DWORD *)(a1 + 40))
    {
      _dispatch_fd_entry_retain(i);
      break;
    }
  }

  if (!i) {
    uint64_t i = _dispatch_fd_entry_create_with_fd(*(_DWORD *)(a1 + 40), v17);
  }
  _dispatch_thread_getspecific(0LL);
  _dispatch_log("%u\t%p\tfd_entry[%p]: init", v1, v2, v3, v4, v5, v6, v7, 1400LL);
  uint64_t v8 = *(dispatch_queue_s **)(i + 72);
  blocint k = _NSConcreteStackBlock;
  int v11 = 1107296256;
  int v12 = 0;
  uint64_t v13 = ___dispatch_fd_entry_init_async_block_invoke_2;
  uint64_t v14 = &__block_descriptor_tmp_124;
  uint64_t v16 = i;
  uint64_t v15 = *(void *)(a1 + 32);
  dispatch_channel_async(v8, &block);
}

uint64_t _dispatch_fd_entry_create_with_fd(int a1, uint64_t a2)
{
  int v36 = a1;
  uint64_t v35 = a2;
  uint64_t v34 = _dispatch_fd_entry_create((dispatch_queue_s *)_dispatch_io_fds_lockq);
  _dispatch_thread_getspecific(0LL);
  _dispatch_log("%u\t%p\tfd_entry[%p]: create: fd %d", v2, v3, v4, v5, v6, v7, v8, 1431LL);
  *(_DWORD *)uint64_t v34 = v36;
  uint64_t v9 = _dispatch_io_fds[v35];
  *(void *)(v34 + 112) = v9;
  if (v9) {
    *(void *)(_dispatch_io_fds[v35] + 12pthread_sigmask(3, _dispatch_sigsuspend_mask, 0LL) = v34 + 112;
  }
  _dispatch_io_fds[v35] = v34;
  *(void *)(v34 + 1memset(__b, 0, 20) = &_dispatch_io_fds[v35];
  *(void *)(v34 + 72) = dispatch_queue_create("com.apple.libdispatch-io.barrierq", 0LL);
  *(void *)(v34 + 8_dispatch_source_set_handler((uint64_t)source, handler, 2LL, 0) = dispatch_group_create();
  uint64_t v10 = *(dispatch_queue_s **)(v34 + 72);
  blocint k = _NSConcreteStackBlock;
  int v28 = 0x40000000;
  int v29 = 0;
  uint64_t v30 = ___dispatch_fd_entry_create_with_fd_block_invoke;
  uint64_t v31 = &__block_descriptor_tmp_129;
  uint64_t v32 = v34;
  int v33 = v36;
  dispatch_channel_async(v10, &block);
  int v11 = *(dispatch_queue_s **)(v34 + 64);
  uint64_t v21 = _NSConcreteStackBlock;
  int v22 = 0x40000000;
  int v23 = 0;
  uint64_t v24 = ___dispatch_fd_entry_create_with_fd_block_invoke_3;
  uint64_t v25 = &__block_descriptor_tmp_132;
  uint64_t v26 = v34;
  dispatch_channel_async(v11, &v21);
  int v12 = *(dispatch_queue_s **)(v34 + 64);
  uint64_t v14 = _NSConcreteStackBlock;
  int v15 = 0x40000000;
  int v16 = 0;
  uint64_t v17 = ___dispatch_fd_entry_create_with_fd_block_invoke_5;
  uint64_t v18 = &__block_descriptor_tmp_136;
  uint64_t v19 = v34;
  int v20 = v36;
  dispatch_channel_async(v12, &v14);
  return v34;
}

void ___dispatch_fd_entry_init_async_block_invoke_2(uint64_t a1)
{
}

uint64_t _dispatch_fd_entry_create(dispatch_queue_s *a1)
{
  uint64_t v2 = _dispatch_calloc(1LL, 128LL);
  *(void *)(v2 + 64) = dispatch_queue_create_with_target_V2("com.apple.libdispatch-io.closeq", 0LL, a1);
  _dispatch_fd_entry_retain(v2);
  return v2;
}

void ___dispatch_fd_entry_create_with_fd_block_invoke(uint64_t a1)
{
  uint64_t v67 = a1;
  uint64_t v66 = a1;
  _dispatch_thread_getspecific(0LL);
  _dispatch_log("%u\t%p\tfd_entry[%p]: stat", v1, v2, v3, v4, v5, v6, v7, 1459LL);
  int v65 = 0;
  int v64 = 0;
  int v63 = -1;
  memset(&__b, 0, sizeof(__b));
  while (1)
  {
    if (fstat(*(_DWORD *)(a1 + 40), &__b) == -1)
    {
      uint64_t v81 = 1LL;
      uint64_t v92 = 1LL;
      unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
      int v43 = **(_DWORD **)(StatusReg + 8);
    }

    else
    {
      int v43 = 0;
    }

    int v65 = v43;
    if (!v43) {
      break;
    }
    if (v43 != 4)
    {
      *(_DWORD *)(*(void *)(a1 + 32) + 24LL) = v65;
      return;
    }
  }

  *(_DWORD *)(*(void *)(a1 + 32) + 32LL) = __b.st_dev;
  *(_WORD *)(*(void *)(a1 + 32) + 36LL) = __b.st_mode;
  _dispatch_object_finalize();
  while (1)
  {
    int v64 = fcntl_NOCANCEL(*(unsigned int *)(a1 + 40), 3LL);
    if (v64 == -1)
    {
      uint64_t v82 = 1LL;
      uint64_t v91 = 1LL;
      unint64_t v94 = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
      int v42 = **(_DWORD **)(v94 + 8);
    }

    else
    {
      int v42 = 0;
    }

    int v65 = v42;
    if (!v42) {
      break;
    }
    if (v42 != 4)
    {
      int v61 = v65;
      uint64_t v77 = v65;
      uint64_t v76 = 1471LL;
      if (v65) {
        _dispatch_bug(v76, v77, v8, v9, v10, v11, v12, v13);
      }
      int v60 = v61;
      break;
    }
  }

  if ((__b.st_mode & 0xF000) == 0x1000)
  {
    while (1)
    {
      int v63 = fcntl_NOCANCEL(*(unsigned int *)(a1 + 40), 74LL);
      if (v63 == -1)
      {
        uint64_t v83 = 1LL;
        uint64_t v90 = 1LL;
        unint64_t v95 = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
        int v41 = **(_DWORD **)(v95 + 8);
      }

      else
      {
        int v41 = 0;
      }

      int v65 = v41;
      if (!v41) {
        break;
      }
      if (v41 != 4)
      {
        int v59 = v65;
        uint64_t v75 = v65;
        uint64_t v74 = 1477LL;
        if (v65) {
          _dispatch_bug(v74, v75, v14, v15, v16, v17, v18, v19);
        }
        int v58 = v59;
        break;
      }
    }

    if (v63 != -1)
    {
      while (1)
      {
        int v63 = fcntl_NOCANCEL(*(unsigned int *)(a1 + 40), 73LL);
        if (v63 == -1)
        {
          uint64_t v84 = 1LL;
          uint64_t v89 = 1LL;
          unint64_t v96 = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
          int v40 = **(_DWORD **)(v96 + 8);
        }

        else
        {
          int v40 = 0;
        }

        int v65 = v40;
        if (!v40) {
          break;
        }
        if (v40 != 4)
        {
          int v63 = -1;
          int v57 = v65;
          uint64_t v73 = v65;
          uint64_t v72 = 1484LL;
          if (v65) {
            _dispatch_bug(v72, v73, v20, v21, v22, v23, v24, v25);
          }
          int v56 = v57;
          break;
        }
      }
    }
  }

  if ((__b.st_mode & 0xF000) == 0x8000)
  {
    if (v64 != -1)
    {
      while (1)
      {
        if (fcntl_NOCANCEL(*(unsigned int *)(a1 + 40), 4LL) == -1)
        {
          uint64_t v85 = 1LL;
          uint64_t v88 = 1LL;
          unint64_t v97 = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
          int v39 = **(_DWORD **)(v97 + 8);
        }

        else
        {
          int v39 = 0;
        }

        int v65 = v39;
        if (!v39) {
          break;
        }
        if (v39 != 4)
        {
          int v64 = -1;
          int v55 = v65;
          uint64_t v71 = v65;
          uint64_t v70 = 1496LL;
          if (v65) {
            _dispatch_bug(v70, v71, v26, v27, v28, v29, v30, v31);
          }
          int v54 = v55;
          break;
        }
      }
    }

    int st_dev_high = HIBYTE(__b.st_dev);
    dispatch_object_t object = *(dispatch_object_t *)(*(void *)(a1 + 32) + 72LL);
    dispatch_suspend(object);
    uint64_t v80 = &_dispatch_io_init_pred;
    BOOL v79 = 0LL;
    uint64_t v78 = _dispatch_io_queues_init;
    if (_dispatch_io_init_pred != -1LL) {
      dispatch_once_f(v80, v79, (dispatch_function_t)v78);
    }
    blocint k = _NSConcreteStackBlock;
    int v46 = 0x40000000;
    int v47 = 0;
    uint64_t v48 = ___dispatch_fd_entry_create_with_fd_block_invoke_2;
    uint64_t v49 = &__block_descriptor_tmp_128;
    uint64_t v50 = *(void *)(a1 + 32);
    int v51 = st_dev_high;
    dispatch_channel_async((dispatch_queue_t)_dispatch_io_devs_lockq, &block);
  }

  else
  {
    if (v64 != -1)
    {
      while (1)
      {
        if (fcntl_NOCANCEL(*(unsigned int *)(a1 + 40), 4LL) == -1)
        {
          uint64_t v86 = 1LL;
          uint64_t v87 = 1LL;
          unint64_t v98 = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
          int v38 = **(_DWORD **)(v98 + 8);
        }

        else
        {
          int v38 = 0;
        }

        int v65 = v38;
        if (!v38) {
          break;
        }
        if (v38 != 4)
        {
          int v64 = -1;
          uint64_t v69 = v65;
          uint64_t v68 = 1516LL;
          if (v65) {
            _dispatch_bug(v68, v69, v32, v33, v34, v35, v36, v37);
          }
          break;
        }
      }
    }

    _dispatch_stream_init(*(void *)(a1 + 32), (dispatch_queue_s *)&off_E4640);
  }

  *(_DWORD *)(*(void *)(a1 + 32) + 16LL) = v64;
  *(_DWORD *)(*(void *)(a1 + 32) + 2pthread_sigmask(3, _dispatch_sigsuspend_mask, 0LL) = v63;
}

void ___dispatch_fd_entry_create_with_fd_block_invoke_2( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

uint64_t _dispatch_disk_init( void *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v11 = a2 & 0x3F;
  for (uint64_t i = (void *)_dispatch_io_devs[v11]; i; uint64_t i = (void *)i[14])
  {
    if (*((_DWORD *)i + 26) == a2)
    {
      uint64_t result = _dispatch_retain((uint64_t)i);
      goto LABEL_9;
    }
  }

  uint64_t v10 = qword_E4D38;
  uint64_t i = _dispatch_object_alloc((uint64_t)_OS_dispatch_disk_vtable, 8 * qword_E4D38 + 136, a3, a4, a5, a6, a7, a8);
  i[2] = -1985229329LL;
  *((_DWORD *)i + 3) = 0;
  i[16] = v10;
  i[3] = &off_E4640;
  *((_DWORD *)i + 26) = a2;
  i[6] = 0LL;
  i[7] = i + 6;
  i[8] = i[6];
  __snprintf_chk(v15, 0x2DuLL, 0, 0x2DuLL, "com.apple.libdispatch-io.deviceq.%d", a2);
  uint64_t result = (uint64_t)dispatch_queue_create(v15, 0LL);
  i[9] = result;
  uint64_t v9 = _dispatch_io_devs[v11];
  i[14] = v9;
  if (v9) {
    *(void *)(_dispatch_io_devs[v11] + 12pthread_sigmask(3, _dispatch_sigsuspend_mask, 0LL) = i + 14;
  }
  _dispatch_io_devs[v11] = i;
  i[15] = &_dispatch_io_devs[v11];
LABEL_9:
  a1[7] = i;
  a1[12] = 0LL;
  a1[13] = a1 + 12;
  return result;
}

void _dispatch_stream_init(uint64_t a1, dispatch_queue_s *a2)
{
  for (unsigned int i = 0; i < 2; ++i)
  {
    context = (dispatch_object_t *)_dispatch_calloc(1LL, 64LL);
    dispatch_object_t *context = dispatch_queue_create_with_target_V2("com.apple.libdispatch-io.streamq", 0LL, a2);
    dispatch_set_context(*context, context);
    context[6] = 0LL;
    context[7] = (dispatch_object_t)(context + 6);
    context[4] = 0LL;
    context[5] = (dispatch_object_t)(context + 4);
    *(void *)(a1 + 40 + 8LL * i) = context;
  }

void ___dispatch_fd_entry_create_with_fd_block_invoke_3(uint64_t a1)
{
  uint64_t v24 = a1;
  uint64_t v23 = a1;
  if (*(void *)(*(void *)(a1 + 32) + 56LL))
  {
    uint64_t v21 = 0LL;
    uint64_t v21 = *(void *)(*(void *)(a1 + 32) + 56LL);
    blocint k = _NSConcreteStackBlock;
    int v16 = 0x40000000;
    int v17 = 0;
    uint64_t v18 = ___dispatch_fd_entry_create_with_fd_block_invoke_4;
    uint64_t v19 = &__block_descriptor_tmp_131;
    uint64_t v20 = v21;
    dispatch_channel_async((dispatch_queue_t)_dispatch_io_devs_lockq, &block);
  }

  else
  {
    _dispatch_thread_getspecific(0LL);
    _dispatch_log("%u\t%p\tfd_entry[%p]: close queue cleanup", v1, v2, v3, v4, v5, v6, v7, 1533LL);
    for (unsigned int i = 0; i < 2; ++i)
      _dispatch_stream_dispose(*(void *)(a1 + 32), i, v8, v9, v10, v11, v12, v13);
  }

  if (*(void *)(*(void *)(a1 + 32) + 112LL)) {
    *(void *)(*(void *)(*(void *)(a1 + 32) + 112LL) + 12pthread_sigmask(3, _dispatch_sigsuspend_mask, 0LL) = *(void *)(*(void *)(a1 + 32) + 120LL);
  }
  **(void **)(*(void *)(a1 + 32) + 12pthread_sigmask(3, _dispatch_sigsuspend_mask, 0LL) = *(void *)(*(void *)(a1 + 32) + 112LL);
  *(void *)(*(void *)(a1 + 32) + 112LL) = -1LL;
  *(void *)(*(void *)(a1 + 32) + 12pthread_sigmask(3, _dispatch_sigsuspend_mask, 0LL) = -1LL;
}

void _dispatch_stream_dispose( uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = *(void **)(a1 + 40 + 8LL * a2);
  if (v8)
  {
    if (*((void *)v8 + 4)) {
      _dispatch_abort(1739LL, *((void *)v8 + 4) == 0LL, a3, a4, a5, a6, a7, a8);
    }
    if (*((void *)v8 + 6)) {
      _dispatch_abort(1740LL, *((void *)v8 + 6) == 0LL, a3, a4, a5, a6, a7, a8);
    }
    if (*((void *)v8 + 1))
    {
      _dispatch_fd_entry_retain(a1);
      dispatch_source_cancel(*((dispatch_source_t *)v8 + 1));
      dispatch_resume(*((dispatch_object_t *)v8 + 1));
      dispatch_release(*((dispatch_object_t *)v8 + 1));
    }

    dispatch_set_context(*(dispatch_object_t *)v8, 0LL);
    dispatch_release(*(dispatch_object_t *)v8);
    free(v8);
  }

void ___dispatch_fd_entry_create_with_fd_block_invoke_4(uint64_t a1)
{
}

void ___dispatch_fd_entry_create_with_fd_block_invoke_5(uint64_t a1)
{
  if (*(_DWORD *)(*(void *)(a1 + 32) + 16LL) != -1)
  {
    do
    {
      else {
        int v23 = 0;
      }
    }

    while (v23 == 4);
  }

  if (*(_DWORD *)(*(void *)(a1 + 32) + 20LL) != -1)
  {
    do
    {
      else {
        int v22 = 0;
      }
    }

    while (v22 == 4);
  }

  _dispatch_object_finalize();
  if (*(void *)(*(void *)(a1 + 32) + 88LL))
  {
    *(void *)(*(void *)(*(void *)(a1 + 32) + 88LL) + 112LL) = 0LL;
    dispatch_release(*(dispatch_object_t *)(*(void *)(a1 + 32) + 88LL));
  }

  free(*(void **)(a1 + 32));
}

void ___dispatch_fd_entry_create_with_path_block_invoke(uint64_t a1)
{
  if (!*(void *)(*(void *)(a1 + 32) + 56LL))
  {
    for (unsigned int i = 0; i < 2; ++i)
      _dispatch_stream_dispose(*(void *)(a1 + 32), i, v8, v9, v10, v11, v12, v13);
  }

  if (**(_DWORD **)(a1 + 32) != -1) {
    _dispatch_fd_entry_guarded_close(*(void *)(a1 + 32), **(_DWORD **)(a1 + 32));
  }
  if (**(void **)(*(void *)(a1 + 32) + 8LL)) {
    *(void *)(**(void **)(*(void *)(a1 + 32) + 8LL) + 112LL) = 0LL;
  }
}

uint64_t _dispatch_fd_entry_guarded_close(uint64_t a1, unsigned int a2)
{
  uint64_t v5 = a1;
  unsigned int v4 = a2;
  if (*(_DWORD *)(a1 + 28))
  {
    uint64_t v3 = v5;
    return guarded_close_np(v4, &v3);
  }

  else
  {
    return close_NOCANCEL(v4);
  }

void ___dispatch_fd_entry_create_with_path_block_invoke_2(uint64_t a1)
{
}

uint64_t _dispatch_fd_entry_guarded_open(uint64_t a1, uint64_t a2, unsigned int a3, __int16 a4)
{
  uint64_t v10 = a1;
  uint64_t v9 = a2;
  unsigned int v8 = a3;
  __int16 v7 = a4;
  uint64_t v6 = a1;
  unsigned int v5 = guarded_open_np(a2, &v6);
  if (v5 == -1)
  {
    uint64_t v12 = 1LL;
    uint64_t v13 = 1LL;
    unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
    **(_DWORD **)(StatusReg + 8) = 0;
    return open_NOCANCEL(v9, v8);
  }

  else
  {
    *(_DWORD *)(v10 + 28) = 15;
    return v5;
  }

void ___dispatch_operation_deliver_data_block_invoke(uint64_t a1)
{
  if ((*(_DWORD *)(a1 + 72) & 2) != 0
    && !*(_DWORD *)(a1 + 76)
    && *(_DWORD *)(a1 + 80)
    && dispatch_data_get_size(*(dispatch_data_t *)(a1 + 40)))
  {
    _dispatch_thread_getspecific(0LL);
    _dispatch_log("%u\t%p\top[%p]: IO handler invoke", v1, v2, v3, v4, v5, v6, v7, 2701LL);
    (*(void (**)(void))(*(void *)(a1 + 32) + 16LL))();
  }

  _dispatch_thread_getspecific(0LL);
  _dispatch_log("%u\t%p\top[%p]: IO handler invoke: err %d", v8, v9, v10, v11, v12, v13, v14, 2709LL);
  (*(void (**)(void))(*(void *)(a1 + 32) + 16LL))();
  _dispatch_release(*(unsigned int **)(a1 + 56));
  _dispatch_fd_entry_release(*(void *)(a1 + 64));
  dispatch_release(*(dispatch_object_t *)(a1 + 40));
}

void _dispatch_data_destroy_buffer(void *a1, mach_vm_size_t a2, dispatch_queue_s *a3, Block_layout *a4)
{
  dispatch_queue_t queue = a3;
  if (a4 == &__block_literal_global)
  {
    free(a1);
  }

  else if (a4 != &__block_literal_global_50)
  {
    if (a4 == &__block_literal_global_53)
    {
      mach_vm_deallocate(mach_task_self_, (mach_vm_address_t)a1, a2);
    }

    else
    {
      if (!a3) {
        dispatch_queue_t queue = (dispatch_queue_s *)&off_E4640;
      }
      dispatch_channel_async_f(queue, a4, (dispatch_function_t)_dispatch_call_block_and_release);
    }
  }

dispatch_data_t dispatch_data_create( const void *buffer, size_t size, dispatch_queue_t queue, dispatch_block_t destructor)
{
  int v22 = (void *)buffer;
  if (buffer && size)
  {
    if (destructor)
    {
      if (destructor == &__block_literal_global_56)
      {
        if (size < 0xFFFFFFFFFFFFFFB0LL)
        {
          v27[8] = 0;
          if (is_mul_ok(0LL, 0x18uLL))
          {
            *(void *)uint64_t v27 = (0 * (unsigned __int128)0x18uLL) >> 64 != 0;
            uint64_t v28 = (dispatch_data_s *)_dispatch_object_alloc( (uint64_t)_OS_dispatch_data_vtable,  size + 80 + *(void *)&v27[1],  (uint64_t)queue,  (uint64_t)destructor,  v4,  v5,  v6,  v7);
            *((void *)v28 + 9) = 0LL;
            *((void *)v28 + 3) = &off_E4640;
            *((void *)v28 + 2) = -1985229329LL;
            uint64_t v29 = v28;
          }

          else
          {
            uint64_t v29 = 0LL;
          }
        }

        else
        {
          uint64_t v29 = 0LL;
        }

        uint64_t v17 = v29;
        int v22 = (void *)__memcpy_chk((char *)v29 + 80, v22, size, -1LL);
        uint64_t v19 = &__block_literal_global_50;
      }

      else
      {
        v24[8] = 0;
        if (is_mul_ok(0LL, 0x18uLL))
        {
          *(void *)uint64_t v24 = (0 * (unsigned __int128)0x18uLL) >> 64 != 0;
          uint64_t v25 = (dispatch_data_s *)_dispatch_object_alloc( (uint64_t)_OS_dispatch_data_vtable,  *(void *)&v24[1] + 80LL,  (uint64_t)queue,  (uint64_t)destructor,  v4,  v5,  v6,  v7);
          *((void *)v25 + 9) = 0LL;
          *((void *)v25 + 3) = &off_E4640;
          *((void *)v25 + 2) = -1985229329LL;
          uint64_t v26 = v25;
        }

        else
        {
          uint64_t v26 = 0LL;
        }

        uint64_t v17 = v26;
        uint64_t v19 = (Block_layout *)_dispatch_Block_copy(destructor);
      }
    }

    else
    {
      uint64_t v16 = malloc_type_malloc(size, 4058601073LL);
      if (!v16) {
        return 0LL;
      }
      int v22 = (void *)__memcpy_chk(v16, v22, size, -1LL);
      v30[8] = 0;
      if (is_mul_ok(0LL, 0x18uLL))
      {
        *(void *)uint64_t v30 = (0 * (unsigned __int128)0x18uLL) >> 64 != 0;
        uint64_t v31 = (dispatch_data_s *)_dispatch_object_alloc( (uint64_t)_OS_dispatch_data_vtable,  *(void *)&v30[1] + 80LL,  v9,  v10,  v11,  v12,  v13,  v14);
        *((void *)v31 + 9) = 0LL;
        *((void *)v31 + 3) = &off_E4640;
        *((void *)v31 + 2) = -1985229329LL;
        uint64_t v32 = v31;
      }

      else
      {
        uint64_t v32 = 0LL;
      }

      uint64_t v17 = v32;
      uint64_t v19 = &__block_literal_global;
    }

    *((void *)v17 + 6) = v22;
    *((void *)v17 + 8) = size;
    *((void *)v17 + 7) = v19;
    if (queue)
    {
      _dispatch_retain((uint64_t)queue);
      *((void *)v17 + 3) = queue;
    }

    return v17;
  }

  else
  {
    if (destructor)
    {
      uint64_t v8 = (Block_layout *)_dispatch_Block_copy(destructor);
      _dispatch_data_destroy_buffer(v22, size, queue, v8);
    }

    return &_dispatch_data_empty;
  }

dispatch_data_t dispatch_data_create_f(const void *a1, size_t a2, dispatch_queue_s *a3, Block_layout *a4)
{
  uint64_t v16 = a1;
  size_t v15 = a2;
  dispatch_queue_t v14 = a3;
  uint64_t v13 = a4;
  uint64_t v12 = a4;
  if (a4
    && v12 != &__block_literal_global
    && v12 != &__block_literal_global_50
    && v12 != &__block_literal_global_53
    && v12 != &__block_literal_global_56)
  {
    uint64_t v5 = _NSConcreteStackBlock;
    int v6 = 0x40000000;
    int v7 = 0;
    uint64_t v8 = __dispatch_data_create_f_block_invoke;
    uint64_t v9 = &__block_descriptor_tmp_2;
    uint64_t v10 = v13;
    uint64_t v11 = v16;
    uint64_t v12 = (Block_layout *)&v5;
  }

  return dispatch_data_create(v16, v15, v14, v12);
}

uint64_t __dispatch_data_create_f_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void))(a1 + 32))(*(void *)(a1 + 40));
}

dispatch_data_s *dispatch_data_create_alloc( unint64_t a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10 = &_dispatch_data_empty;
  uint64_t v9 = 0LL;
  if (a1)
  {
    if (a1 < 0xFFFFFFFFFFFFFFB0LL)
    {
      if (is_mul_ok(0LL, 0x18uLL))
      {
        uint64_t v13 = (dispatch_data_s *)_dispatch_object_alloc( (uint64_t)_OS_dispatch_data_vtable,  a1 + 80,  a3,  a4,  a5,  a6,  a7,  a8);
        *((void *)v13 + 9) = 0LL;
        *((void *)v13 + 3) = &off_E4640;
        *((void *)v13 + 2) = -1985229329LL;
        dispatch_queue_t v14 = v13;
      }

      else
      {
        dispatch_queue_t v14 = 0LL;
      }
    }

    else
    {
      dispatch_queue_t v14 = 0LL;
    }

    uint64_t v10 = v14;
    uint64_t v9 = (void *)((char *)v14 + 80);
    *((void *)v14 + 6) = (char *)v14 + 80;
    *((void *)v14 + 8) = a1;
    *((void *)v14 + 7) = &__block_literal_global_50;
  }

  if (a2) {
    *a2 = v9;
  }
  return v10;
}

void _dispatch_data_dispose(uint64_t a1)
{
  if (*(void *)(a1 + 72))
  {
    for (unint64_t i = 0LL; ; ++i)
    {
      unint64_t v1 = *(void *)(a1 + 72) ? *(void *)(a1 + 72) : 1LL;
      if (i >= v1) {
        break;
      }
      dispatch_release(*(dispatch_object_t *)(a1 + 80 + 24 * i));
    }

    free(*(void **)(a1 + 48));
  }

  else
  {
    _dispatch_data_destroy_buffer( *(void **)(a1 + 48),  *(void *)(a1 + 64),  *(dispatch_queue_s **)(a1 + 24),  *(Block_layout **)(a1 + 56));
  }

size_t dispatch_data_get_size(dispatch_data_t data)
{
  return *((void *)data + 8);
}

dispatch_data_t dispatch_data_create_concat(dispatch_data_t data1, dispatch_data_t data2)
{
  if (*((void *)data1 + 8))
  {
    if (*((void *)data2 + 8))
    {
      if (*((void *)data1 + 9)) {
        uint64_t v17 = *((void *)data1 + 9);
      }
      else {
        uint64_t v17 = 1LL;
      }
      if (*((void *)data2 + 9)) {
        uint64_t v16 = *((void *)data2 + 9);
      }
      else {
        uint64_t v16 = 1LL;
      }
      BOOL v8 = __CFADD__(v17, v16);
      uint64_t v19 = v17 + v16;
      if (v8)
      {
        return 0LL;
      }

      else
      {
        if (((unint64_t)v19 * (unsigned __int128)0x18uLL) >> 64 != 0
          || (unint64_t)(24 * v19) >= 0xFFFFFFFFFFFFFFB0LL)
        {
          uint64_t v24 = 0LL;
        }

        else
        {
          int v23 = (dispatch_data_s *)_dispatch_object_alloc( (uint64_t)_OS_dispatch_data_vtable,  24 * v19 + 80,  v2,  v3,  v4,  v5,  v6,  v7);
          *((void *)v23 + 9) = v19;
          *((void *)v23 + 3) = &off_E4640;
          *((void *)v23 + 2) = -1985229329LL;
          uint64_t v24 = v23;
        }

        *((void *)v24 + 8) = *((void *)data1 + 8) + *((void *)data2 + 8);
        if (*((void *)data1 + 9))
        {
          __memcpy_chk((char *)v24 + 80, (char *)data1 + 80, 24LL * *((void *)data1 + 9), -1LL);
        }

        else
        {
          *((void *)v24 + 1_dispatch_source_set_handler((uint64_t)source, handler, 2LL, 1) = 0LL;
          *((void *)v24 + 12) = *((void *)data1 + 8);
          *((void *)v24 + 1_dispatch_source_set_handler((uint64_t)source, handler, 2LL, 0) = data1;
        }

        if (*((void *)data2 + 9))
        {
          if (*((void *)data1 + 9)) {
            uint64_t v12 = *((void *)data1 + 9);
          }
          else {
            uint64_t v12 = 1LL;
          }
          if (*((void *)data2 + 9)) {
            uint64_t v11 = *((void *)data2 + 9);
          }
          else {
            uint64_t v11 = 1LL;
          }
          __memcpy_chk((char *)v24 + 24 * v12 + 80, (char *)data2 + 80, 24 * v11, -1LL);
        }

        else
        {
          if (*((void *)data1 + 9)) {
            uint64_t v15 = *((void *)data1 + 9);
          }
          else {
            uint64_t v15 = 1LL;
          }
          *((void *)v24 + 3 * v15 + 1_dispatch_source_set_handler((uint64_t)source, handler, 2LL, 1) = 0LL;
          if (*((void *)data1 + 9)) {
            uint64_t v14 = *((void *)data1 + 9);
          }
          else {
            uint64_t v14 = 1LL;
          }
          *((void *)v24 + 3 * v14 + 12) = *((void *)data2 + 8);
          if (*((void *)data1 + 9)) {
            uint64_t v13 = *((void *)data1 + 9);
          }
          else {
            uint64_t v13 = 1LL;
          }
          *((void *)v24 + 3 * v13 + 1_dispatch_source_set_handler((uint64_t)source, handler, 2LL, 0) = data2;
        }

        for (unint64_t i = 0LL; ; ++i)
        {
          unint64_t v10 = *((void *)v24 + 9) ? *((void *)v24 + 9) : 1LL;
          if (i >= v10) {
            break;
          }
          dispatch_retain(*((dispatch_object_t *)v24 + 3 * i + 10));
        }

        return v24;
      }
    }

    else
    {
      dispatch_retain(data1);
      return data1;
    }
  }

  else
  {
    dispatch_retain(data2);
    return data2;
  }

dispatch_data_t dispatch_data_create_subrange(dispatch_data_t data, size_t offset, size_t length)
{
  size_t v20 = offset;
  size_t lengtha = length;
  if (offset >= *((void *)data + 8) || !length) {
    return &_dispatch_data_empty;
  }
  if (length <= *((void *)data + 8) - offset)
  {
    if (length == *((void *)data + 8))
    {
      dispatch_retain(data);
      return data;
    }
  }

  else
  {
    size_t lengtha = *((void *)data + 8) - offset;
  }

  if (*((void *)data + 9))
  {
    unint64_t v12 = *((void *)data + 9);
    BOOL v18 = offset + lengtha == *((void *)data + 8);
    for (unint64_t i = 0LL; ; ++i)
    {
      BOOL v11 = 0;
      if (i < v12) {
        BOOL v11 = v20 >= *((void *)data + 3 * i + 12);
      }
      if (!v11) {
        break;
      }
      BOOL v8 = (char *)data + 24 * i;
      v20 -= *((void *)v8 + 12);
    }

    if (i >= v12)
    {
      qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: dispatch_data_create_subrange out of bounds";
      qword_E4DA8 = i;
      __break(1u);
      JUMPOUT(0xB2438LL);
    }

    if (v20 + lengtha > *((void *)data + 3 * i + 12))
    {
      size_t v14 = 0LL;
      if (offset + lengtha == *((void *)data + 8))
      {
        unint64_t v15 = v12 - i;
      }

      else
      {
        size_t v14 = lengtha + v20 - *((void *)data + 3 * i + 12);
        unint64_t v15 = 1LL;
        while (i + v15 < v12)
        {
          uint64_t v9 = 24 * (i + v15++);
          size_t v13 = *(void *)((char *)data + v9 + 96);
          if (v14 <= v13) {
            break;
          }
          v14 -= v13;
          if (i + v15 >= v12)
          {
            qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: dispatch_data_create_subrange out of bounds";
            qword_E4DA8 = i + v15;
            __break(1u);
            JUMPOUT(0xB25E4LL);
          }
        }
      }

      if (!is_mul_ok(v15, 0x18uLL) || 24 * v15 >= 0xFFFFFFFFFFFFFFB0LL)
      {
        uint64_t v24 = 0LL;
      }

      else
      {
        int v23 = (dispatch_data_s *)_dispatch_object_alloc( (uint64_t)_OS_dispatch_data_vtable,  24 * v15 + 80,  length,  v3,  v4,  v5,  v6,  v7);
        *((void *)v23 + 9) = v15;
        *((void *)v23 + 3) = &off_E4640;
        *((void *)v23 + 2) = -1985229329LL;
        uint64_t v24 = v23;
      }

      *((void *)v24 + 8) = lengtha;
      __memcpy_chk((char *)v24 + 80, (char *)data + 24 * i + 80, 24 * v15, -1LL);
      if (v20)
      {
        *((void *)v24 + 11) += v20;
        *((void *)v24 + 12) -= v20;
      }

      if (!v18) {
        *((void *)v24 + 3 * v15 + 9) = v14;
      }
      for (unint64_t j = 0LL; j < v15; ++j)
        dispatch_retain(*((dispatch_object_t *)v24 + 3 * j + 10));
      return v24;
    }

    else
    {
      return dispatch_data_create_subrange( *((dispatch_data_t *)data + 3 * i + 10),  *((void *)data + 3 * i + 11) + v20,  lengtha);
    }
  }

  else
  {
    if (is_mul_ok(1uLL, 0x18uLL))
    {
      uint64_t v25 = (dispatch_data_s *)_dispatch_object_alloc( (uint64_t)_OS_dispatch_data_vtable,  0x68uLL,  length,  v3,  v4,  v5,  v6,  v7);
      *((void *)v25 + 9) = 1LL;
      *((void *)v25 + 3) = &off_E4640;
      *((void *)v25 + 2) = -1985229329LL;
      uint64_t v26 = v25;
    }

    else
    {
      uint64_t v26 = 0LL;
    }

    *((void *)v26 + 8) = lengtha;
    *((void *)v26 + 1_dispatch_source_set_handler((uint64_t)source, handler, 2LL, 1) = v20;
    *((void *)v26 + 12) = lengtha;
    *((void *)v26 + 1_dispatch_source_set_handler((uint64_t)source, handler, 2LL, 0) = data;
    dispatch_retain(data);
    return v26;
  }

dispatch_data_t dispatch_data_create_map(dispatch_data_t data, const void **buffer_ptr, size_t *size_ptr)
{
  uint64_t v6 = 0LL;
  __int128 buffer = 0LL;
  size_t size = *((void *)data + 8);
  if (size)
  {
    dispatch_data_t v12 = data;
    uint64_t v11 = 0LL;
    if (*((void *)data + 9) == 1LL)
    {
      uint64_t v11 = *((void *)data + 11);
      dispatch_data_t v12 = (dispatch_data_t)*((void *)data + 10);
    }

    if (*((void *)v12 + 9))
    {
      unint64_t v10 = (char *)*((void *)v12 + 6);
      if (v10) {
        v10 += v11;
      }
    }

    else
    {
      unint64_t v10 = (char *)(*((void *)v12 + 6) + v11);
    }

    __int128 buffer = v10;
    if (v10)
    {
      dispatch_retain(data);
      uint64_t v6 = data;
    }

    else
    {
      __int128 buffer = (void *)_dispatch_data_flatten((uint64_t)data);
      if (buffer) {
        uint64_t v6 = dispatch_data_create(buffer, size, 0LL, &__block_literal_global);
      }
      else {
        size_t size = 0LL;
      }
    }
  }

  else
  {
    uint64_t v6 = &_dispatch_data_empty;
  }

  if (buffer_ptr) {
    *buffer_ptr = buffer;
  }
  if (size_ptr) {
    *size_ptr = size;
  }
  return v6;
}

uint64_t _dispatch_data_flatten(uint64_t a1)
{
  dispatch_data_t v9 = (dispatch_data_t)a1;
  uint64_t v8 = 0LL;
  uint64_t v8 = malloc_type_malloc(*(void *)(a1 + 64), 1286759591LL);
  if (v8)
  {
    applier = _NSConcreteStackBlock;
    int v3 = 0x40000000;
    int v4 = 0;
    uint64_t v5 = ___dispatch_data_flatten_block_invoke;
    uint64_t v6 = &__block_descriptor_tmp_11_0;
    uint64_t v7 = v8;
    dispatch_data_apply(v9, &applier);
  }

  return v8;
}

char *dispatch_data_get_flattened_bytes_4libxpc( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v16 = (void *)a1;
  unint64_t v15 = 0LL;
  uint64_t v14 = 0LL;
  if (!*(void *)(a1 + 64)) {
    return 0LL;
  }
  uint64_t v25 = v16;
  uint64_t v24 = 0LL;
  int v23 = (uint64_t *)&v16;
  int v22 = &v14;
  uint64_t v21 = 0LL;
  uint64_t v30 = v16[8];
  uint64_t v29 = 131LL;
  if (!v30) {
    _dispatch_abort(v29, 0LL, a3, a4, a5, a6, a7, a8);
  }
  uint64_t v27 = v25;
  if (v25[9])
  {
    uint64_t v28 = v25;
    uint64_t v11 = v25[9] ? v25[9] : 1LL;
    if (v11 == 1)
    {
      v24 += v25[11];
      uint64_t v25 = (void *)v25[10];
    }
  }

  uint64_t v26 = v25;
  if (v25[9])
  {
    size_t v20 = 0LL;
    uint64_t v19 = (char *)v25[6];
    size_t v20 = v19;
    BOOL v18 = v19;
    uint64_t v21 = v19;
    if (v19) {
      v21 += v24;
    }
  }

  else
  {
    uint64_t v21 = (char *)(v25[6] + v24);
  }

  if (v23) {
    *int v23 = (uint64_t)v25;
  }
  if (v22) {
    *int v22 = v24;
  }
  unint64_t v15 = v21;
  if (v21) {
    return v15;
  }
  size_t v13 = (char *)_dispatch_data_flatten((uint64_t)v16);
  if (!v13) {
    return 0LL;
  }
  unint64_t v12 = 0LL;
  uint64_t v8 = v16 + 6;
  do
    unint64_t v9 = __ldaxr(v8);
  while (!v9 && __stlxr((unint64_t)v13, v8));
  if (v9) {
    unint64_t v12 = v9;
  }
  unint64_t v15 = (char *)v12;
  if (v9) {
    free(v13);
  }
  else {
    unint64_t v15 = v13;
  }
  return &v15[v14];
}

uint64_t dispatch_data_apply_f( void *a1, uint64_t a2, uint64_t (*a3)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t), uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1[8]) {
    char v9 = _dispatch_data_apply(a1, 0LL, 0LL, a1[8], a2, a3, a7, a8) & 1;
  }
  else {
    char v9 = 1;
  }
  return v9 & 1;
}

uint64_t _dispatch_data_apply( void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t (*a6)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t), uint64_t a7, uint64_t a8)
{
  uint64_t v15 = a2;
  char v12 = 1;
  size_t v20 = a1;
  uint64_t v19 = 0LL;
  if (!a1[8]) {
    _dispatch_abort(131LL, 0LL, a3, a4, a5, (uint64_t)a6, a7, a8);
  }
  if (a1[9] == 1LL)
  {
    uint64_t v19 = a1[11];
    size_t v20 = (void *)a1[10];
  }

  if (v20[9])
  {
    uint64_t v18 = v20[6];
    if (v18) {
      v18 += v19;
    }
  }

  else
  {
    uint64_t v18 = v20[6] + v19;
  }

  if (v18)
  {
    char v17 = _dispatch_data_apply_client_callout(a5, (uint64_t)a1, a2, v18 + a3, a4, a6) & 1;
  }

  else
  {
    for (unint64_t i = 0LL; ; ++i)
    {
      unint64_t v10 = a1[9] ? a1[9] : 1LL;
      char v9 = 0;
      if (i < v10) {
        char v9 = v12;
      }
      if ((v9 & 1) == 0) {
        break;
      }
      char v12 = _dispatch_data_apply(a1[3 * i + 10], v15, a1[3 * i + 11], a1[3 * i + 12], a5, a6) & 1;
      v15 += a1[3 * i + 12];
    }

    char v17 = v12;
  }

  return v17 & 1;
}

BOOL dispatch_data_apply(dispatch_data_t data, dispatch_data_applier_t applier)
{
  if (!*((void *)data + 8)) {
    return 1;
  }
  uint64_t v6 = *((void *)data + 8);
  uint64_t v2 = (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))_Block_get_invoke_fn((uint64_t)applier);
  return _dispatch_data_apply(data, 0LL, 0LL, v6, (uint64_t)applier, v2, v3, v4) & 1;
}

dispatch_data_t dispatch_data_copy_region(dispatch_data_t data, size_t location, size_t *offset_ptr)
{
  if (location < *((void *)data + 8))
  {
    *offset_ptr = 0LL;
    return (dispatch_data_t)_dispatch_data_copy_region( data,  0LL,  *((void *)data + 8),  location,  offset_ptr,  v3,  v4,  v5);
  }

  else
  {
    *offset_ptr = *((void *)data + 8);
    return &_dispatch_data_empty;
  }

dispatch_object_s *_dispatch_data_copy_region( dispatch_object_s *a1, unint64_t a2, uint64_t a3, unint64_t a4, void *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v26 = a1;
  unint64_t v25 = a2;
  int v23 = 0LL;
  uint64_t v22 = 0LL;
  if (!a2 && a3 == *((void *)v26 + 8)) {
    int v23 = v26;
  }
  uint64_t v50 = v26;
  unint64_t v49 = v25;
  uint64_t v48 = &v26;
  int v47 = &v25;
  unint64_t v46 = 0LL;
  uint64_t v55 = *((void *)v26 + 8);
  uint64_t v54 = 131LL;
  if (!v55) {
    _dispatch_abort(v54, 0LL, a3, a4, (uint64_t)a5, a6, a7, a8);
  }
  uint64_t v52 = v50;
  if (*((void *)v50 + 9))
  {
    uint64_t v53 = v50;
    uint64_t v17 = *((void *)v50 + 9) ? *((void *)v50 + 9) : 1LL;
    if (v17 == 1)
    {
      v49 += *((void *)v50 + 11);
      uint64_t v50 = (dispatch_object_s *)*((void *)v50 + 10);
    }
  }

  int v51 = v50;
  if (*((void *)v50 + 9))
  {
    unint64_t v45 = 0LL;
    unint64_t v44 = *((void *)v50 + 6);
    unint64_t v45 = v44;
    unint64_t v43 = v44;
    unint64_t v46 = v44;
    if (v44) {
      v46 += v49;
    }
  }

  else
  {
    unint64_t v46 = *((void *)v50 + 6) + v49;
  }

  if (v48) {
    *uint64_t v48 = v50;
  }
  if (v47) {
    *int v47 = v49;
  }
  if (!v46)
  {
    for (unint64_t i = 0LL; ; ++i)
    {
      int v38 = v26;
      if (*((void *)v26 + 9)) {
        unint64_t v16 = *((void *)v26 + 9);
      }
      else {
        unint64_t v16 = 1LL;
      }
      if (i >= v16)
      {
        uint64_t v14 = *a5 + v22;
        qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: dispatch_data_copy_region out of bounds";
        qword_E4DA8 = v14;
        __break(1u);
        JUMPOUT(0xB3A64LL);
      }

      unint64_t v18 = *((void *)v26 + 3 * i + 12);
      if (v25 < v18)
      {
        unint64_t v19 = v18 - v25;
        if (a4 < v22 + v19)
        {
          v25 += *((void *)v26 + 3 * i + 11);
          uint64_t v26 = (dispatch_object_s *)*((void *)v26 + 3 * i + 10);
          *a5 += v22;
          return (dispatch_object_s *)_dispatch_data_copy_region(v26, v25, v19, a4 - v22, a5);
        }

        v22 += v19;
        unint64_t v25 = 0LL;
      }

      else
      {
        v25 -= v18;
      }
    }
  }

  if (v23)
  {
    dispatch_retain(v23);
    return v23;
  }

  else
  {
    dispatch_retain(v26);
    if (v25 || a3 != *((void *)v26 + 8))
    {
      uint64_t v36 = 1LL;
      uint64_t v35 = 0LL;
      uint64_t v34 = 0LL;
      uint64_t v32 = 80LL;
      char v42 = 0;
      uint64_t v31 = 24LL;
      BOOL v41 = !is_mul_ok(1uLL, 0x18uLL);
      BOOL v30 = v41;
      unint64_t v33 = 104LL;
      char v40 = 0;
      char v29 = 0;
      int v28 = v41;
      BOOL v39 = v41;
      if (v41)
      {
        uint64_t v37 = 0LL;
      }

      else
      {
        uint64_t v34 = _dispatch_object_alloc((uint64_t)_OS_dispatch_data_vtable, v33, v8, v9, v10, v11, v12, v13);
        v34[9] = v36;
        v34[3] = &off_E4640;
        void v34[2] = -1985229329LL;
        uint64_t v37 = v34;
      }

      uint64_t v21 = v37;
      v37[8] = a3;
      v21[11] = v25;
      v21[12] = a3;
      v21[10] = v26;
      return (dispatch_object_s *)v21;
    }

    else
    {
      return v26;
    }
  }

uint64_t dispatch_data_make_memory_entry(uint64_t a1)
{
  kern_return_t v26;
  void **applier;
  int v28;
  int v29;
  uint64_t (*v30)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t);
  void *v31;
  mach_vm_address_t v32;
  kern_return_t v33;
  kern_return_t v34;
  BOOL i;
  kern_return_t memory_entry_64;
  vm_prot_t permission;
  mach_vm_address_t address;
  mach_vm_size_t size;
  memory_object_size_t v40;
  mach_port_t object_handle;
  dispatch_data_t v42;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  char v42 = (dispatch_data_t)a1;
  mach_port_t object_handle = 0;
  char v40 = 0LL;
  size_t size = 0LL;
  size_t size = *(void *)(a1 + 64);
  address = 0LL;
  vm_prot_t permission = 0;
  memory_entry_64 = 0;
  unint64_t i = 0;
  for (unint64_t i = *(void *)(a1 + 56) != (void)&__block_literal_global_53; ; unint64_t i = 1)
  {
    if (i)
    {
      address = vm_page_size;
      memory_entry_64 = mach_vm_allocate(mach_task_self_, &address, size, 1);
      if (memory_entry_64)
      {
        if (memory_entry_64 != 3)
        {
          uint64_t v34 = memory_entry_64;
          int v51 = memory_entry_64;
          uint64_t v50 = 704LL;
          _dispatch_bug(v50, v51, v1, v2, v3, v4, v5, v6);
          unint64_t v33 = v34;
        }

        return object_handle;
      }

      applier = _NSConcreteStackBlock;
      int v28 = 0x40000000;
      char v29 = 0;
      BOOL v30 = __dispatch_data_make_memory_entry_block_invoke;
      uint64_t v31 = &__block_descriptor_tmp_9_0;
      uint64_t v32 = address;
      dispatch_data_apply(v42, &applier);
    }

    else
    {
      address = *((void *)v42 + 6);
    }

    vm_prot_t permission = 2097219;
    char v40 = size;
    memory_entry_64 = mach_make_memory_entry_64(mach_task_self_, &v40, address, 2097219, &object_handle, 0);
    if (memory_entry_64 == 18)
    {
      permission &= ~0x200000u;
      memory_entry_64 = mach_make_memory_entry_64(mach_task_self_, &v40, address, permission, &object_handle, 0);
    }

    uint64_t v26 = memory_entry_64;
    unint64_t v49 = memory_entry_64;
    uint64_t v48 = 726LL;
    if (memory_entry_64) {
      _dispatch_bug(v48, v49, v7, v8, v9, v10, v11, v12);
    }
    if (v26)
    {
      mach_port_t object_handle = 0;
      goto LABEL_23;
    }

    if (v40 >= size) {
      goto LABEL_23;
    }
    memory_entry_64 = mach_port_deallocate(mach_task_self_, object_handle);
    int v47 = memory_entry_64;
    unint64_t v46 = 731LL;
    if (memory_entry_64) {
      _dispatch_bug(v46, v47, v13, v14, v15, v16, v17, v18);
    }
    if (i) {
      break;
    }
  }

  mach_port_t object_handle = 0;
LABEL_23:
  if (i)
  {
    memory_entry_64 = mach_vm_deallocate(mach_task_self_, address, size);
    unint64_t v45 = memory_entry_64;
    unint64_t v44 = 740LL;
    if (memory_entry_64) {
      _dispatch_bug(v44, v45, v19, v20, v21, v22, v23, v24);
    }
  }

  return object_handle;
}

uint64_t __dispatch_data_make_memory_entry_block_invoke( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return 1LL;
}

uint64_t ___dispatch_data_flatten_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return 1LL;
}

uint64_t _dispatch_data_apply_client_callout( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t (*a6)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))
{
  return a6(a1, a2, a3, a4, a5) & 1;
}

dispatch_data_s *dispatch_data_create_with_transform(dispatch_data_s *a1, void *a2, uint64_t a3)
{
  uint64_t v7 = a2;
  if (*a2 == 16LL)
  {
    uint64_t v7 = _dispatch_transform_detect_utf(a1);
    if (!v7) {
      return 0LL;
    }
  }

  if ((*v7 & ~*(void *)(a3 + 8)) != 0LL) {
    return 0LL;
  }
  if ((*(void *)a3 & ~v7[2]) != 0LL) {
    return 0LL;
  }
  if (!dispatch_data_get_size(a1)) {
    return a1;
  }
  if (v7[3])
  {
    uint64_t v5 = (dispatch_object_s *)((uint64_t (*)(dispatch_data_s *))v7[3])(a1);
  }

  else
  {
    dispatch_retain(a1);
    uint64_t v5 = a1;
  }

  if (!v5) {
    return 0LL;
  }
  if (*(void *)(a3 + 32))
  {
    uint64_t v4 = (*(uint64_t (**)(dispatch_object_s *))(a3 + 32))(v5);
  }

  else
  {
    dispatch_retain(v5);
    uint64_t v4 = (uint64_t)v5;
  }

  dispatch_release(v5);
  return (dispatch_data_s *)v4;
}

void *_dispatch_transform_detect_utf(dispatch_data_s *a1)
{
  v4[1] = a1;
  v4[0] = 0LL;
  dispatch_data_t v3 = _dispatch_data_subrange_map(a1, v4, 0LL, 2uLL);
  if (!v3) {
    return 0LL;
  }
  uint64_t v2 = &_dispatch_data_format_type_utf8;
  if (*(unsigned __int16 *)v4[0] == 65279)
  {
    uint64_t v2 = &_dispatch_data_format_type_utf16le;
  }

  else if (*(unsigned __int16 *)v4[0] == 65534)
  {
    uint64_t v2 = &_dispatch_data_format_type_utf16be;
  }

  dispatch_release(v3);
  return v2;
}

uint64_t _dispatch_transform_from_base32(dispatch_data_s *a1)
{
  return _dispatch_transform_from_base32_with_table(a1, (uint64_t)&base32_decode_table, 91LL);
}

dispatch_data_t _dispatch_transform_to_base32(dispatch_data_s *a1)
{
  return _dispatch_transform_to_base32_with_table(a1, (uint64_t)"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567");
}

uint64_t _dispatch_transform_from_base32hex(dispatch_data_s *a1)
{
  return _dispatch_transform_from_base32_with_table(a1, (uint64_t)&base32hex_decode_table, 33LL);
}

dispatch_data_t _dispatch_transform_to_base32hex(dispatch_data_s *a1)
{
  return _dispatch_transform_to_base32_with_table(a1, (uint64_t)"0123456789ABCDEFGHIJKLMNOPQRSTUV");
}

uint64_t _dispatch_transform_from_base64(dispatch_data_s *a1)
{
  char v29 = a1;
  v25[0] = 0LL;
  v25[1] = v25;
  int v26 = 0;
  int v27 = 32;
  uint64_t v28 = 0LL;
  v21[0] = 0LL;
  v21[1] = v21;
  int v22 = 0;
  int v23 = 32;
  uint64_t v24 = 0LL;
  v17[0] = 0LL;
  v17[1] = v17;
  int v18 = 0;
  int v19 = 32;
  uint64_t v20 = 0LL;
  uint64_t v12 = 0LL;
  uint64_t v13 = &v12;
  int v14 = 0;
  int v15 = 32;
  uint64_t v16 = &_dispatch_data_empty;
  BOOL v11 = 0;
  applier = _NSConcreteStackBlock;
  int v3 = 1107296256;
  int v4 = 0;
  uint64_t v5 = ___dispatch_transform_from_base64_block_invoke;
  uint64_t v6 = &__block_descriptor_tmp_2;
  uint64_t v7 = v21;
  uint64_t v8 = v17;
  uint64_t v9 = v25;
  uint64_t v10 = &v12;
  BOOL v11 = dispatch_data_apply(a1, &applier);
  if (v11)
  {
    uint64_t v30 = v13[3];
  }

  else
  {
    dispatch_release((dispatch_object_t)v13[3]);
    uint64_t v30 = 0LL;
  }

  _Block_object_dispose(&v12, 8);
  _Block_object_dispose(v17, 8);
  _Block_object_dispose(v21, 8);
  _Block_object_dispose(v25, 8);
  return v30;
}

dispatch_data_t _dispatch_transform_to_base64(dispatch_data_s *a1)
{
  dispatch_data_t v25 = a1;
  size_t size = dispatch_data_get_size(a1);
  size_t v23 = 0LL;
  v19[0] = 0LL;
  v19[1] = v19;
  int v20 = 0;
  int v21 = 32;
  uint64_t v22 = 0LL;
  if (size % 3) {
    unint64_t v2 = size / 3 + 1;
  }
  else {
    unint64_t v2 = size / 3;
  }
  size_t v23 = v2;
  if (v2 <= 0x3FFFFFFFFFFFFFFFLL)
  {
    v23 *= 4LL;
    uint64_t v17 = (void *)malloc_type_malloc(v23, 57655578LL);
    if (v17)
    {
      v13[0] = 0LL;
      v13[1] = v13;
      int v14 = 0;
      int v15 = 32;
      uint64_t v16 = v17;
      BOOL v12 = 0;
      applier = _NSConcreteStackBlock;
      int v4 = 1107296256;
      int v5 = 0;
      uint64_t v6 = ___dispatch_transform_to_base64_block_invoke;
      uint64_t v7 = &__block_descriptor_tmp_3;
      uint64_t v8 = v19;
      dispatch_data_t v10 = v25;
      uint64_t v9 = v13;
      size_t v11 = size;
      BOOL v12 = dispatch_data_apply(v25, &applier);
      if (v12)
      {
        dispatch_data_t v26 = dispatch_data_create(v17, v23, 0LL, &__block_literal_global);
      }

      else
      {
        free(v17);
        dispatch_data_t v26 = 0LL;
      }

      int v18 = 1;
      _Block_object_dispose(v13, 8);
    }

    else
    {
      dispatch_data_t v26 = 0LL;
      int v18 = 1;
    }
  }

  else
  {
    dispatch_data_t v26 = 0LL;
    int v18 = 1;
  }

  _Block_object_dispose(v19, 8);
  return v26;
}

uint64_t _dispatch_transform_from_utf16le(dispatch_data_s *a1)
{
  return _dispatch_transform_from_utf16(a1, 1);
}

uint64_t _dispatch_transform_to_utf16le(dispatch_data_s *a1)
{
  return _dispatch_transform_to_utf16(a1, 1);
}

uint64_t _dispatch_transform_from_utf16be(dispatch_data_s *a1)
{
  return _dispatch_transform_from_utf16(a1, 2);
}

uint64_t _dispatch_transform_to_utf16be(dispatch_data_s *a1)
{
  return _dispatch_transform_to_utf16(a1, 2);
}

dispatch_data_t _dispatch_transform_to_utf8_without_bom(dispatch_data_s *a1)
{
  uint64_t v7 = a1;
  uint64_t v6 = 0LL;
  dispatch_data_t v5 = _dispatch_data_subrange_map(a1, &v6, 0LL, 3uLL);
  BOOL v4 = 0;
  if (v5)
  {
    BOOL v4 = memcmp(v6, &_dispatch_transform_to_utf8_without_bom_utf8_bom, 3uLL) == 0;
    dispatch_release(v5);
  }

  if (v4)
  {
    uintptr_t data = v7;
    size_t size = dispatch_data_get_size(v7);
    return dispatch_data_create_subrange(data, 3uLL, size - 3);
  }

  else
  {
    dispatch_retain(v7);
    return v7;
  }

dispatch_data_t _dispatch_data_subrange_map(dispatch_data_s *a1, const void **a2, size_t a3, size_t a4)
{
  dispatch_data_t map = 0LL;
  uintptr_t data = dispatch_data_create_subrange(a1, a3, a4);
  if (dispatch_data_get_size(data) == a4) {
    dispatch_data_t map = dispatch_data_create_map(data, a2, 0LL);
  }
  dispatch_release(data);
  return map;
}

uint64_t _dispatch_transform_from_base32_with_table(dispatch_data_s *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v35 = a1;
  uint64_t v34 = a2;
  uint64_t v33 = a3;
  v29[0] = 0LL;
  v29[1] = v29;
  int v30 = 0;
  int v31 = 32;
  uint64_t v32 = 0LL;
  v25[0] = 0LL;
  v25[1] = v25;
  int v26 = 0;
  int v27 = 32;
  uint64_t v28 = 0LL;
  v21[0] = 0LL;
  v21[1] = v21;
  int v22 = 0;
  int v23 = 32;
  uint64_t v24 = 0LL;
  uint64_t v16 = 0LL;
  uint64_t v17 = &v16;
  int v18 = 0;
  int v19 = 32;
  int v20 = &_dispatch_data_empty;
  BOOL v15 = 0;
  applier = _NSConcreteStackBlock;
  int v5 = 1107296256;
  int v6 = 0;
  uint64_t v7 = ___dispatch_transform_from_base32_with_table_block_invoke;
  uint64_t v8 = &__block_descriptor_tmp_3;
  uint64_t v13 = a3;
  uint64_t v14 = a2;
  uint64_t v9 = v25;
  dispatch_data_t v10 = v21;
  size_t v11 = v29;
  BOOL v12 = &v16;
  BOOL v15 = dispatch_data_apply(a1, &applier);
  if (v15)
  {
    uint64_t v36 = v17[3];
  }

  else
  {
    dispatch_release((dispatch_object_t)v17[3]);
    uint64_t v36 = 0LL;
  }

  _Block_object_dispose(&v16, 8);
  _Block_object_dispose(v21, 8);
  _Block_object_dispose(v25, 8);
  _Block_object_dispose(v29, 8);
  return v36;
}

uint64_t ___dispatch_transform_from_base32_with_table_block_invoke( void *a1, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t a5)
{
  if (a5 % 8) {
    unint64_t v8 = a5 / 8 + 1;
  }
  else {
    unint64_t v8 = a5 / 8;
  }
  BOOL v15 = (_BYTE *)malloc_type_malloc(5 * v8, 0x100004077774924LL);
  uint64_t v14 = v15;
  if (v15)
  {
    for (unint64_t i = 0LL; i < a5; ++i)
    {
      if (*(_BYTE *)(a4 + i) != 10 && *(_BYTE *)(a4 + i) != 9 && *(_BYTE *)(a4 + i) != 32)
      {
        uint64_t v13 = *(unsigned __int8 *)(a4 + i);
        if (v13 >= a1[8] || *(char *)(a1[9] + v13) == -1)
        {
          free(v15);
          char v19 = 0;
          return v19 & 1;
        }

        ++*(void *)(*(void *)(a1[4] + 8LL) + 24LL);
        char v12 = *(_BYTE *)(a1[9] + v13);
        if (v12 == -2)
        {
          char v12 = 0;
          ++*(void *)(*(void *)(a1[5] + 8LL) + 24LL);
        }

        *(void *)(*(void *)(a1[6] + 8LL) + 24LL) *= 32LL;
        *(void *)(*(void *)(a1[6] + 8LL) + 24LL) += v12;
        if ((*(void *)(*(void *)(a1[4] + 8LL) + 24LL) & 7LL) == 0)
        {
          _BYTE *v14 = BYTE4(*(void *)(*(void *)(a1[6] + 8LL) + 24LL));
          v14[1] = BYTE3(*(void *)(*(void *)(a1[6] + 8LL) + 24LL));
          _OWORD v14[2] = BYTE2(*(void *)(*(void *)(a1[6] + 8LL) + 24LL));
          v14[3] = BYTE1(*(void *)(*(void *)(a1[6] + 8LL) + 24LL));
          int v5 = v14 + 4;
          v14 += 5;
          *int v5 = *(_BYTE *)(*(void *)(a1[6] + 8LL) + 24LL);
        }
      }
    }

    unint64_t v7 = *(void *)(*(void *)(a1[5] + 8LL) + 24LL) - 1LL;
    if (v7 <= 5) {
      __asm { BR              X8 }
    }

    data2 = dispatch_data_create(v15, v14 - v15, 0LL, &__block_literal_global);
    dispatch_data_t concat = dispatch_data_create_concat(*(dispatch_data_t *)(*(void *)(a1[7] + 8LL) + 24LL), data2);
    dispatch_release(data2);
    dispatch_release(*(dispatch_object_t *)(*(void *)(a1[7] + 8LL) + 24LL));
    *(void *)(*(void *)(a1[7] + 8LL) + 24LL) = concat;
    char v19 = 1;
  }

  else
  {
    char v19 = 0;
  }

  return v19 & 1;
}

void __copy_helper_block_8_32r40r48r56r(uint64_t a1, const void **a2)
{
}

void __destroy_helper_block_8_32r40r48r56r(const void **a1)
{
}

dispatch_data_t _dispatch_transform_to_base32_with_table(dispatch_data_s *a1, uint64_t a2)
{
  dispatch_data_t v28 = a1;
  uint64_t v27 = a2;
  size_t size = dispatch_data_get_size(a1);
  size_t v25 = 0LL;
  v21[0] = 0LL;
  v21[1] = v21;
  int v22 = 0;
  int v23 = 32;
  uint64_t v24 = 0LL;
  if (size % 5) {
    unint64_t v3 = size / 5 + 1;
  }
  else {
    unint64_t v3 = size / 5;
  }
  size_t v25 = v3;
  if (v3 <= 0x1FFFFFFFFFFFFFFFLL)
  {
    v25 *= 8LL;
    char v19 = (void *)malloc_type_malloc(v25, 689401293LL);
    if (v19)
    {
      v15[0] = 0LL;
      v15[1] = v15;
      int v16 = 0;
      int v17 = 32;
      int v18 = v19;
      BOOL v14 = 0;
      applier = _NSConcreteStackBlock;
      int v5 = 1107296256;
      int v6 = 0;
      unint64_t v7 = ___dispatch_transform_to_base32_with_table_block_invoke;
      unint64_t v8 = &__block_descriptor_tmp_1;
      uint64_t v9 = v21;
      dispatch_data_t v11 = v28;
      dispatch_data_t v10 = v15;
      uint64_t v12 = v27;
      size_t v13 = size;
      BOOL v14 = dispatch_data_apply(v28, &applier);
      if (v14)
      {
        dispatch_data_t v29 = dispatch_data_create(v19, v25, 0LL, &__block_literal_global);
      }

      else
      {
        free(v19);
        dispatch_data_t v29 = 0LL;
      }

      int v20 = 1;
      _Block_object_dispose(v15, 8);
    }

    else
    {
      dispatch_data_t v29 = 0LL;
      int v20 = 1;
    }
  }

  else
  {
    dispatch_data_t v29 = 0LL;
    int v20 = 1;
  }

  _Block_object_dispose(v21, 8);
  return v29;
}

uint64_t ___dispatch_transform_to_base32_with_table_block_invoke( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t a5)
{
  uint64_t v21 = a1;
  uint64_t v20 = a2;
  uint64_t v19 = a3;
  uint64_t v18 = a4;
  unint64_t v17 = a5;
  uint64_t v16 = a1;
  uint64_t v15 = a4;
  unint64_t v14 = 0LL;
  while (v14 < v17)
  {
    char v13 = 0;
    char v13 = *(_BYTE *)(v15 + v14);
    char v12 = 0;
    if (*(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) % 5uLL)
    {
      if (v14)
      {
        char v12 = *(_BYTE *)(v15 + v14 - 1);
      }

      else
      {
        dispatch_data_t v11 = 0LL;
        dispatch_data_t v10 = _dispatch_data_subrange_map(*(dispatch_data_s **)(a1 + 48), (const void **)&v11, v19 - 1, 1uLL);
        if (!v10)
        {
          char v22 = 0;
          return v22 & 1;
        }

        char v12 = *v11;
        dispatch_release(v10);
      }
    }

    unint64_t v8 = *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) % 5uLL;
    if (v8 <= 4) {
      __asm { BR              X8 }
    }

    ++v14;
    ++*(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL);
  }

  if (v19 + v17 == *(void *)(a1 + 64))
  {
    unint64_t v7 = *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) % 5uLL;
    if (v7 <= 4) {
      __asm { BR              X8 }
    }

    unint64_t v6 = *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) % 5uLL;
    if (v6 <= 4) {
      __asm { BR              X8 }
    }
  }

  char v22 = 1;
  return v22 & 1;
}

uint64_t ___dispatch_transform_from_base64_block_invoke( void *a1, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t a5)
{
  if (a5 % 4) {
    unint64_t v7 = a5 / 4 + 1;
  }
  else {
    unint64_t v7 = a5 / 4;
  }
  uint64_t v15 = (_BYTE *)malloc_type_malloc(3 * v7, 0x100004077774924LL);
  unint64_t v14 = v15;
  if (v15)
  {
    for (unint64_t i = 0LL; i < a5; ++i)
    {
      if (*(_BYTE *)(a4 + i) != 10 && *(_BYTE *)(a4 + i) != 9 && *(_BYTE *)(a4 + i) != 32)
      {
        unint64_t v13 = *(unsigned __int8 *)(a4 + i);
        if (v13 >= 0x7B || base64_decode_table[v13] == -1)
        {
          free(v15);
          char v19 = 0;
          return v19 & 1;
        }

        ++*(void *)(*(void *)(a1[4] + 8LL) + 24LL);
        char v12 = base64_decode_table[v13];
        if (v12 == -2)
        {
          char v12 = 0;
          ++*(void *)(*(void *)(a1[5] + 8LL) + 24LL);
        }

        *(void *)(*(void *)(a1[6] + 8LL) + 24LL) <<= 6;
        *(void *)(*(void *)(a1[6] + 8LL) + 24LL) += v12;
        if ((*(void *)(*(void *)(a1[4] + 8LL) + 24LL) & 3LL) == 0)
        {
          _BYTE *v14 = BYTE2(*(void *)(*(void *)(a1[6] + 8LL) + 24LL));
          v14[1] = BYTE1(*(void *)(*(void *)(a1[6] + 8LL) + 24LL));
          int v5 = v14 + 2;
          v14 += 3;
          *int v5 = *(_BYTE *)(*(void *)(a1[6] + 8LL) + 24LL);
        }
      }
    }

    size_t size = v14 - v15;
    if (*(void *)(*(void *)(a1[5] + 8LL) + 24LL)) {
      size -= *(void *)(*(void *)(a1[5] + 8LL) + 24LL);
    }
    data2 = dispatch_data_create(v15, size, 0LL, &__block_literal_global);
    dispatch_data_t concat = dispatch_data_create_concat(*(dispatch_data_t *)(*(void *)(a1[7] + 8LL) + 24LL), data2);
    dispatch_release(data2);
    dispatch_release(*(dispatch_object_t *)(*(void *)(a1[7] + 8LL) + 24LL));
    *(void *)(*(void *)(a1[7] + 8LL) + 24LL) = concat;
    char v19 = 1;
  }

  else
  {
    char v19 = 0;
  }

  return v19 & 1;
}

uint64_t ___dispatch_transform_to_base64_block_invoke( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t a5)
{
  uint64_t v44 = a1;
  uint64_t v43 = a2;
  uint64_t v42 = a3;
  uint64_t v41 = a4;
  unint64_t v40 = a5;
  uint64_t v39 = a1;
  uint64_t v38 = a4;
  unint64_t v37 = 0LL;
  while (v37 < v40)
  {
    unsigned __int8 v36 = 0;
    unsigned __int8 v36 = *(_BYTE *)(v38 + v37);
    char v35 = 0;
    if (*(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) % 3uLL)
    {
      if (v37)
      {
        char v35 = *(_BYTE *)(v38 + v37 - 1);
      }

      else
      {
        uint64_t v34 = 0LL;
        dispatch_data_t v33 = _dispatch_data_subrange_map(*(dispatch_data_s **)(a1 + 48), (const void **)&v34, v42 - 1, 1uLL);
        if (!v33)
        {
          char v45 = 0;
          return v45 & 1;
        }

        char v35 = *v34;
        dispatch_release(v33);
      }
    }

    unint64_t v31 = *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) % 3uLL;
    if (v31)
    {
      if (v31 == 1)
      {
        char v8 = base64_encode_table[(((int)v36 >> 4) | (16 * v35)) & 0x3F];
        uint64_t v9 = *(void *)(*(void *)(a1 + 40) + 8LL);
        dispatch_data_t v10 = *(char **)(v9 + 24);
        *(void *)(v9 + 24) = v10 + 1;
        char *v10 = v8;
      }

      else if (v31 == 2)
      {
        char v11 = base64_encode_table[(((int)v36 >> 6) | (4 * v35)) & 0x3F];
        uint64_t v12 = *(void *)(*(void *)(a1 + 40) + 8LL);
        unint64_t v13 = *(char **)(v12 + 24);
        *(void *)(v12 + 24) = v13 + 1;
        char *v13 = v11;
        char v14 = base64_encode_table[v36 & 0x3F];
        uint64_t v15 = *(void *)(*(void *)(a1 + 40) + 8LL);
        uint64_t v16 = *(char **)(v15 + 24);
        *(void *)(v15 + 24) = v16 + 1;
        *uint64_t v16 = v14;
      }
    }

    else
    {
      char v5 = base64_encode_table[((int)v36 >> 2) & 0x3F];
      uint64_t v6 = *(void *)(*(void *)(a1 + 40) + 8LL);
      unint64_t v7 = *(char **)(v6 + 24);
      *(void *)(v6 + 24) = v7 + 1;
      *unint64_t v7 = v5;
    }

    ++v37;
    ++*(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL);
  }

  if (v42 + v40 == *(void *)(a1 + 56))
  {
    unint64_t v30 = *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) % 3uLL;
    if (v30)
    {
      if (v30 == 1)
      {
        char v17 = base64_encode_table[(16 * *(unsigned __int8 *)(v38 + v40 - 1)) & 0x30];
        uint64_t v18 = *(void *)(*(void *)(a1 + 40) + 8LL);
        char v19 = *(char **)(v18 + 24);
        *(void *)(v18 + 24) = v19 + 1;
        *char v19 = v17;
        uint64_t v20 = *(void *)(*(void *)(a1 + 40) + 8LL);
        uint64_t v21 = *(_BYTE **)(v20 + 24);
        *(void *)(v20 + 24) = v21 + 1;
        *uint64_t v21 = 61;
        uint64_t v22 = *(void *)(*(void *)(a1 + 40) + 8LL);
        int v23 = *(_BYTE **)(v22 + 24);
        *(void *)(v22 + 24) = v23 + 1;
        *int v23 = 61;
      }

      else if (v30 == 2)
      {
        char v24 = base64_encode_table[(4 * *(unsigned __int8 *)(v38 + v40 - 1)) & 0x3C];
        uint64_t v25 = *(void *)(*(void *)(a1 + 40) + 8LL);
        int v26 = *(char **)(v25 + 24);
        *(void *)(v25 + 24) = v26 + 1;
        *int v26 = v24;
        uint64_t v27 = *(void *)(*(void *)(a1 + 40) + 8LL);
        dispatch_data_t v28 = *(_BYTE **)(v27 + 24);
        *(void *)(v27 + 24) = v28 + 1;
        *dispatch_data_t v28 = 61;
      }
    }
  }

  char v45 = 1;
  return v45 & 1;
}

uint64_t _dispatch_transform_from_utf16(dispatch_data_s *a1, int a2)
{
  char v24 = a1;
  int v23 = a2;
  v19[0] = 0LL;
  v19[1] = v19;
  int v20 = 0;
  int v21 = 32;
  uint64_t v22 = 0LL;
  uint64_t v13 = 0LL;
  char v14 = &v13;
  int v15 = 0;
  int v16 = 56;
  __int128 v17 = off_E2150;
  __int128 v18 = xmmword_E2160;
  BOOL v12 = 0;
  applier = _NSConcreteStackBlock;
  int v4 = 1107296256;
  int v5 = 0;
  uint64_t v6 = ___dispatch_transform_from_utf16_block_invoke;
  unint64_t v7 = &__block_descriptor_tmp_4_0;
  char v8 = &v13;
  uint64_t v9 = v19;
  dispatch_data_t v10 = a1;
  int v11 = a2;
  BOOL v12 = dispatch_data_apply(a1, &applier);
  if (v12)
  {
    uint64_t v25 = v14[3];
  }

  else
  {
    _dispatch_transform_buffer_new((uint64_t)(v14 + 3), 0LL, 0LL);
    dispatch_release((dispatch_object_t)v14[3]);
    uint64_t v25 = 0LL;
  }

  _Block_object_dispose(&v13, 8);
  _Block_object_dispose(v19, 8);
  return v25;
}

uint64_t ___dispatch_transform_from_utf16_block_invoke( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t a5)
{
  uint64_t v51 = a1;
  uint64_t v50 = a2;
  uint64_t v49 = a3;
  uint64_t v48 = a4;
  unint64_t v47 = a5;
  uint64_t v46 = a1;
  uint64_t v45 = a4;
  if (a3
    || ((v44 = 0LL, v47 % 3) ? (unint64_t v33 = v47 / 3 + 1) : (unint64_t v33 = v47 / 3),
        uint64_t v44 = 2 * v33,
        (_dispatch_transform_buffer_new(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL, 2 * v33, 0LL) & 1) != 0))
  {
    unint64_t i = 0LL;
    unint64_t v42 = v47 / 2;
    if (*(void *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL) < v47)
    {
      if (*(void *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL))
      {
        v45 += *(void *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL);
        v47 -= *(void *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL);
        unint64_t v42 = v47 / 2;
        *(void *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL) = 0LL;
      }

      if (v47 % 2) {
        ++v42;
      }
      for (unint64_t i = 0LL; i < v42; ++i)
      {
        unsigned int v41 = 0;
        unsigned __int16 v40 = 0;
        uint64_t v39 = 0LL;
        if (i == v42 - 1 && v42 > v47 / 2)
        {
          uint64_t v38 = 0LL;
          dispatch_data_t v37 = 0LL;
          dispatch_data_t v37 = _dispatch_data_subrange_map(*(dispatch_data_s **)(a1 + 48), (const void **)&v38, v49 + 2 * i, 2uLL);
          if (!v37)
          {
            char v52 = 0;
            return v52 & 1;
          }

          unsigned __int16 v40 = _dispatch_transform_swap_to_host(*v38, *(_DWORD *)(a1 + 56));
          v36[1] = v37;
          dispatch_release(v37);
          ++*(void *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL);
        }

        else
        {
          unsigned __int16 v40 = _dispatch_transform_swap_to_host(*(_WORD *)(v45 + 2 * i), *(_DWORD *)(a1 + 56));
        }

        if (v40 == 65534 && !v49 && !i)
        {
          char v52 = 0;
          return v52 & 1;
        }

        if (v40 != 65279 || v49 || i)
        {
          if (v40 < 0xD800u || v40 > 0xDBFFu)
          {
            if (v40 >= 0xDC00u && v40 < 0xE000u)
            {
              char v52 = 0;
              return v52 & 1;
            }

            unsigned int v41 = v40;
          }

          else
          {
            unsigned int v41 = (v40 - 55296) << 10;
            if (++i < v42)
            {
              unsigned __int16 v40 = _dispatch_transform_swap_to_host(*(_WORD *)(v45 + 2 * i), *(_DWORD *)(a1 + 56));
            }

            else
            {
              v36[0] = 0LL;
              dispatch_data_t v35 = _dispatch_data_subrange_map(*(dispatch_data_s **)(a1 + 48), v36, v49 + 2 * i, 2uLL);
              if (!v35)
              {
                char v52 = 0;
                return v52 & 1;
              }

              unsigned __int16 v40 = _dispatch_transform_swap_to_host(*(_WORD *)v36[0], *(_DWORD *)(a1 + 56));
              dispatch_release(v35);
              *(void *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL) += 2LL;
            }

            if (v40 < 0xDC00u || v40 >= 0xE000u)
            {
              char v52 = 0;
              return v52 & 1;
            }

            v41 |= v40 & 0x3FF;
            v41 += 0x10000;
          }

          uint64_t v39 = 2 * (v42 - i);
          BOOL v53 = (2 * (unsigned __int128)(v42 - i)) >> 64 != 0;
          if (!is_mul_ok(2uLL, v42 - i))
          {
            char v52 = 0;
            return v52 & 1;
          }

          if (v41 >= 0x80)
          {
            if (v41 >= 0x800)
            {
              if (v41 >= 0x10000)
              {
                if (v41 < 0x200000)
                {
                  if ((_dispatch_transform_buffer_new(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL, 4uLL, v39) & 1) == 0)
                  {
                    char v52 = 0;
                    return v52 & 1;
                  }

                  char v22 = (v41 >> 18) | 0xF0;
                  uint64_t v23 = *(void *)(*(void *)(a1 + 32) + 8LL);
                  char v24 = *(_BYTE **)(v23 + 40);
                  *(void *)(v23 + 4_dispatch_source_set_handler((uint64_t)source, handler, 2LL, 0) = v24 + 1;
                  *char v24 = v22;
                  LOBYTE(v24) = (v41 >> 12) & 0x3F | 0x80;
                  uint64_t v25 = *(void *)(*(void *)(a1 + 32) + 8LL);
                  int v26 = *(_BYTE **)(v25 + 40);
                  *(void *)(v25 + 4_dispatch_source_set_handler((uint64_t)source, handler, 2LL, 0) = v26 + 1;
                  *int v26 = (_BYTE)v24;
                  LOBYTE(v24) = (v41 >> 6) & 0x3F | 0x80;
                  uint64_t v27 = *(void *)(*(void *)(a1 + 32) + 8LL);
                  dispatch_data_t v28 = *(_BYTE **)(v27 + 40);
                  *(void *)(v27 + 4_dispatch_source_set_handler((uint64_t)source, handler, 2LL, 0) = v28 + 1;
                  *dispatch_data_t v28 = (_BYTE)v24;
                  char v29 = v41 & 0x3F | 0x80;
                  uint64_t v30 = *(void *)(*(void *)(a1 + 32) + 8LL);
                  unint64_t v31 = *(_BYTE **)(v30 + 40);
                  *(void *)(v30 + 4_dispatch_source_set_handler((uint64_t)source, handler, 2LL, 0) = v31 + 1;
                  *unint64_t v31 = v29;
                }
              }

              else
              {
                if ((_dispatch_transform_buffer_new(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL, 3uLL, v39) & 1) == 0)
                {
                  char v52 = 0;
                  return v52 & 1;
                }

                char v14 = (v41 >> 12) | 0xE0;
                uint64_t v15 = *(void *)(*(void *)(a1 + 32) + 8LL);
                int v16 = *(_BYTE **)(v15 + 40);
                *(void *)(v15 + 4_dispatch_source_set_handler((uint64_t)source, handler, 2LL, 0) = v16 + 1;
                *int v16 = v14;
                LOBYTE(v16) = (v41 >> 6) & 0x3F | 0x80;
                uint64_t v17 = *(void *)(*(void *)(a1 + 32) + 8LL);
                __int128 v18 = *(_BYTE **)(v17 + 40);
                *(void *)(v17 + 4_dispatch_source_set_handler((uint64_t)source, handler, 2LL, 0) = v18 + 1;
                *__int128 v18 = (_BYTE)v16;
                char v19 = v41 & 0x3F | 0x80;
                uint64_t v20 = *(void *)(*(void *)(a1 + 32) + 8LL);
                int v21 = *(_BYTE **)(v20 + 40);
                *(void *)(v20 + 4_dispatch_source_set_handler((uint64_t)source, handler, 2LL, 0) = v21 + 1;
                *int v21 = v19;
              }
            }

            else
            {
              if ((_dispatch_transform_buffer_new(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL, 2uLL, v39) & 1) == 0)
              {
                char v52 = 0;
                return v52 & 1;
              }

              char v8 = (v41 >> 6) | 0xC0;
              uint64_t v9 = *(void *)(*(void *)(a1 + 32) + 8LL);
              dispatch_data_t v10 = *(_BYTE **)(v9 + 40);
              *(void *)(v9 + 4_dispatch_source_set_handler((uint64_t)source, handler, 2LL, 0) = v10 + 1;
              _BYTE *v10 = v8;
              char v11 = v41 & 0x3F | 0x80;
              uint64_t v12 = *(void *)(*(void *)(a1 + 32) + 8LL);
              uint64_t v13 = *(_BYTE **)(v12 + 40);
              *(void *)(v12 + 4_dispatch_source_set_handler((uint64_t)source, handler, 2LL, 0) = v13 + 1;
              _BYTE *v13 = v11;
            }
          }

          else
          {
            if ((_dispatch_transform_buffer_new(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL, 1uLL, v39) & 1) == 0)
            {
              char v52 = 0;
              return v52 & 1;
            }

            char v5 = v41;
            uint64_t v6 = *(void *)(*(void *)(a1 + 32) + 8LL);
            unint64_t v7 = *(_BYTE **)(v6 + 40);
            *(void *)(v6 + 4_dispatch_source_set_handler((uint64_t)source, handler, 2LL, 0) = v7 + 1;
            *unint64_t v7 = v5;
          }
        }
      }

      _dispatch_transform_buffer_new(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL, 0LL, 0LL);
      char v52 = 1;
    }

    else
    {
      *(void *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL) -= v47;
      char v52 = 1;
    }
  }

  else
  {
    char v52 = 0;
  }

  return v52 & 1;
}

uint64_t _dispatch_transform_buffer_new(uint64_t a1, unint64_t a2, uint64_t a3)
{
  if (a2 && *(void *)(a1 + 24) - (*(void *)(a1 + 16) - *(void *)(a1 + 8)) >= a2) {
    goto LABEL_13;
  }
  if (*(void *)(a1 + 8))
  {
    if (*(void *)(a1 + 16) <= *(void *)(a1 + 8))
    {
      free(*(void **)(a1 + 8));
    }

    else
    {
      data2 = dispatch_data_create( *(const void **)(a1 + 8),  *(void *)(a1 + 16) - *(void *)(a1 + 8),  0LL,  &__block_literal_global);
      dispatch_data_t concat = dispatch_data_create_concat(*(dispatch_data_t *)a1, data2);
      dispatch_release(data2);
      dispatch_release(*(dispatch_object_t *)a1);
      *(void *)a1 = concat;
    }
  }

  *(void *)(a1 + 24) = a2 + a3;
  *(void *)(a1 + 8) = 0LL;
  if (!*(void *)(a1 + 24))
  {
LABEL_12:
    *(void *)(a1 + 16) = *(void *)(a1 + 8);
LABEL_13:
    char v9 = 1;
    return v9 & 1;
  }

  if (*(void *)(a1 + 24) <= 0x6400000uLL)
  {
    *(void *)(a1 + 8) = malloc_type_malloc(*(void *)(a1 + 24), 2918043961LL);
    if (!*(void *)(a1 + 8))
    {
      char v9 = 0;
      return v9 & 1;
    }

    goto LABEL_12;
  }

  char v9 = 0;
  return v9 & 1;
}

uint64_t _dispatch_transform_swap_to_host(unsigned __int16 a1, int a2)
{
  if (a2 == 1) {
    return a1;
  }
  else {
    return (unsigned __int16)_OSSwapInt16(a1);
  }
}

uint64_t _OSSwapInt16(unsigned __int16 a1)
{
  return (unsigned __int16)(((int)a1 >> 8) | (a1 << 8));
}

uint64_t _dispatch_transform_to_utf16(dispatch_data_s *a1, int a2)
{
  char v24 = a1;
  int v23 = a2;
  v19[0] = 0LL;
  v19[1] = v19;
  int v20 = 0;
  int v21 = 32;
  uint64_t v22 = 0LL;
  uint64_t v13 = 0LL;
  char v14 = &v13;
  int v15 = 0;
  int v16 = 56;
  __int128 v17 = off_E21A0;
  __int128 v18 = xmmword_E21B0;
  BOOL v12 = 0;
  applier = _NSConcreteStackBlock;
  int v4 = 1107296256;
  int v5 = 0;
  uint64_t v6 = ___dispatch_transform_to_utf16_block_invoke;
  unint64_t v7 = &__block_descriptor_tmp_5;
  char v8 = &v13;
  int v11 = a2;
  char v9 = v19;
  dispatch_data_t v10 = a1;
  BOOL v12 = dispatch_data_apply(a1, &applier);
  if (v12)
  {
    uint64_t v25 = v14[3];
  }

  else
  {
    _dispatch_transform_buffer_new((uint64_t)(v14 + 3), 0LL, 0LL);
    dispatch_release((dispatch_object_t)v14[3]);
    uint64_t v25 = 0LL;
  }

  _Block_object_dispose(&v13, 8);
  _Block_object_dispose(v19, 8);
  return v25;
}

uint64_t ___dispatch_transform_to_utf16_block_invoke( uint64_t a1, uint64_t a2, uint64_t a3, char *a4, unint64_t a5)
{
  uint64_t v36 = a1;
  uint64_t v35 = a2;
  uint64_t v34 = a3;
  unint64_t v33 = a4;
  unint64_t v32 = a5;
  uint64_t v31 = a1;
  uint64_t v30 = a4;
  unint64_t v29 = 0LL;
  unint64_t v28 = 0LL;
  if (!a3)
  {
    uint64_t v27 = 2 * v32;
    BOOL v41 = (v32 * (unsigned __int128)2uLL) >> 64 != 0;
    BOOL v26 = v41;
    unint64_t v28 = 2 * v32 + 2;
    BOOL v40 = 2 * v32 >= 0xFFFFFFFFFFFFFFFELL;
    BOOL v25 = v40;
    int v24 = v41 || v40;
    BOOL v39 = v24 != 0;
    if (v24)
    {
      char v37 = 0;
      return v37 & 1;
    }

    if ((_dispatch_transform_buffer_new(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL, v28, 0LL) & 1) == 0)
    {
      char v37 = 0;
      return v37 & 1;
    }

    __int16 v5 = _dispatch_transform_swap_to_host(0xFEFFu, *(_DWORD *)(a1 + 56));
    uint64_t v6 = *(void *)(*(void *)(a1 + 32) + 8LL);
    unint64_t v7 = *(_WORD **)(v6 + 40);
    *(void *)(v6 + 4_dispatch_source_set_handler((uint64_t)source, handler, 2LL, 0) = v7 + 1;
    *unint64_t v7 = v5;
  }

  if (*(void *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL) < v32)
  {
    if (*(void *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL))
    {
      v30 += *(void *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL);
      v32 -= *(void *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL);
      *(void *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL) = 0LL;
    }

    unint64_t v29 = 0LL;
    while (v29 < v32)
    {
      unsigned int utf8_sequence = 0;
      unsigned __int8 v22 = 0;
      unsigned __int8 v22 = _dispatch_transform_utf8_length(*v30);
      uint64_t v21 = 0LL;
      if (!v22)
      {
        char v37 = 0;
        return v37 & 1;
      }

      if (v22 + v29 <= v32)
      {
        unsigned int utf8_sequence = _dispatch_transform_read_utf8_sequence(v30);
        v30 += v22;
        v29 += v22;
      }

      else
      {
        int v20 = 0LL;
        dispatch_data_t v19 = _dispatch_data_subrange_map(*(dispatch_data_s **)(a1 + 48), (const void **)&v20, v34 + v29, v22);
        if (!v19)
        {
          char v37 = 0;
          return v37 & 1;
        }

        unsigned int utf8_sequence = _dispatch_transform_read_utf8_sequence(v20);
        *(void *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL) += v22 - (v32 - v29);
        v30 += v22;
        unint64_t v29 = v32;
        dispatch_release(v19);
      }

      uint64_t v21 = 2 * (v32 - v29);
      BOOL v38 = ((v32 - v29) * (unsigned __int128)2uLL) >> 64 != 0;
      if (!is_mul_ok(v32 - v29, 2uLL))
      {
        char v37 = 0;
        return v37 & 1;
      }

      if (utf8_sequence != 65279 || v34 + v29 != 3)
      {
        if (utf8_sequence >= 0xD800 && utf8_sequence < 0xDFFF)
        {
          char v37 = 0;
          return v37 & 1;
        }

        if (utf8_sequence < 0x10000)
        {
          if ((_dispatch_transform_buffer_new(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL, 2uLL, v21) & 1) == 0)
          {
            char v37 = 0;
            return v37 & 1;
          }

          __int16 v14 = _dispatch_transform_swap_to_host(utf8_sequence, *(_DWORD *)(a1 + 56));
          uint64_t v15 = *(void *)(*(void *)(a1 + 32) + 8LL);
          int v16 = *(_WORD **)(v15 + 40);
          *(void *)(v15 + 4_dispatch_source_set_handler((uint64_t)source, handler, 2LL, 0) = v16 + 1;
          *int v16 = v14;
        }

        else
        {
          if ((_dispatch_transform_buffer_new(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL, 4uLL, v21) & 1) == 0)
          {
            char v37 = 0;
            return v37 & 1;
          }

          utf8_sequence -= 0x10000;
          __int16 v8 = _dispatch_transform_swap_to_host(((utf8_sequence >> 10) & 0x3FF) - 10240, *(_DWORD *)(a1 + 56));
          uint64_t v9 = *(void *)(*(void *)(a1 + 32) + 8LL);
          dispatch_data_t v10 = *(_WORD **)(v9 + 40);
          *(void *)(v9 + 4_dispatch_source_set_handler((uint64_t)source, handler, 2LL, 0) = v10 + 1;
          _WORD *v10 = v8;
          __int16 v11 = _dispatch_transform_swap_to_host((utf8_sequence & 0x3FF) - 9216, *(_DWORD *)(a1 + 56));
          uint64_t v12 = *(void *)(*(void *)(a1 + 32) + 8LL);
          uint64_t v13 = *(_WORD **)(v12 + 40);
          *(void *)(v12 + 4_dispatch_source_set_handler((uint64_t)source, handler, 2LL, 0) = v13 + 1;
          _WORD *v13 = v11;
        }
      }
    }

    _dispatch_transform_buffer_new(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL, 0LL, 0LL);
    char v37 = 1;
  }

  else
  {
    *(void *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL) -= v32;
    char v37 = 1;
  }

  return v37 & 1;
}

uint64_t _dispatch_transform_utf8_length(char a1)
{
  if (a1 < 0)
  {
    if ((a1 & 0xE0) == 0xC0)
    {
      return 2;
    }

    else if ((a1 & 0xF0) == 0xE0)
    {
      return 3;
    }

    else if ((a1 & 0xF8) == 0xF0)
    {
      return 4;
    }

    else
    {
      return 0;
    }
  }

  else
  {
    return 1;
  }

uint64_t _dispatch_transform_read_utf8_sequence(char *a1)
{
  v3[4] = 0;
  *(_DWORD *)unint64_t v3 = _dispatch_transform_utf8_length(*a1);
  unint64_t v2 = v3[0] - 1;
  if (v2 <= 3) {
    __asm { BR              X8 }
  }

  __int16 v5 = a1 + 1;
  --v3[0];
  while (v3[0])
  {
    *(_DWORD *)&v3[1] |= *v5++ & 0x3F;
    if (--v3[0]) {
      *(_DWORD *)&v3[1] <<= 6;
    }
  }

  return *(unsigned int *)&v3[1];
}

void _dispatch_time_init()
{
  kern_return_t v8;
  mach_timebase_info info;
  uint64_t v10;
  uint64_t v11;
  info = 0LL;
  __int16 v8 = mach_timebase_info(&info);
  __int16 v11 = v8;
  dispatch_data_t v10 = 86LL;
  if (v8) {
    _dispatch_bug(v10, v11, v0, v1, v2, v3, v4, v5);
  }
  BOOL v7 = 0;
  if (info.numer == 125) {
    BOOL v7 = info.denom == 3;
  }
  if (!v7) {
    _dispatch_host_time_init(&info, v6);
  }
}

_DWORD *_dispatch_host_time_init(_DWORD *result, double a2)
{
  LODWORD(a2) = *result;
  *(double *)&unint64_t v2 = (double)*(unint64_t *)&a2;
  _dispatch_host_time_uintptr_t data = v2;
  LODWORD(v2) = result[1];
  *(double *)&_dispatch_host_time_uintptr_t data = *(double *)&_dispatch_host_time_data / (double)v2;
  byte_E5718 = *result == result[1];
  _dispatch_host_time_mach2nano = (uint64_t (*)(void))_dispatch_mach_host_time_mach2nano;
  _dispatch_host_time_nano2mach = (uint64_t (*)(void))_dispatch_mach_host_time_nano2mach;
  return result;
}

dispatch_time_t dispatch_time(dispatch_time_t when, int64_t delta)
{
  dispatch_time_t v8 = when;
  int64_t v7 = delta;
  unint64_t v6 = 0LL;
  if (when == -1LL) {
    return -1LL;
  }
  int v5 = 0;
  uint64_t v4 = 0LL;
  uint64_t v14 = v8;
  char v13 = 1;
  uint64_t v12 = &v5;
  __int16 v11 = &v4;
  unint64_t v10 = 0LL;
  if (v8 == 0x8000000000000000LL)
  {
    *uint64_t v12 = 1;
    *__int16 v11 = _dispatch_monotonic_time();
  }

  else if (v8 == -2LL)
  {
    *uint64_t v12 = 2;
    *__int16 v11 = _dispatch_get_nanoseconds();
  }

  else if (v8)
  {
    if (v14 >= 0)
    {
      *uint64_t v12 = 0;
      unint64_t v10 = v14;
    }

    else if ((v14 & 0x4000000000000000LL) != 0)
    {
      *uint64_t v12 = 2;
      unint64_t v10 = -v14;
    }

    else
    {
      *uint64_t v12 = 1;
      unint64_t v10 = v14 & 0x7FFFFFFFFFFFFFFFLL;
    }

    if (v10 <= 0x3FFFFFFFFFFFFFFFLL) {
      uint64_t v3 = v10;
    }
    else {
      uint64_t v3 = -1LL;
    }
    *__int16 v11 = v3;
  }

  else
  {
    *uint64_t v12 = 0;
    *__int16 v11 = _dispatch_uptime();
  }

  if (v4 == -1) {
    return -1LL;
  }
  if (v5 == 2)
  {
    unint64_t v6 = v7;
    if (v7 < 0)
    {
      v4 += v6;
      if (v4 < 1) {
        uint64_t v4 = 2LL;
      }
    }

    else
    {
      v4 += v6;
      if (v4 <= 0) {
        return -1LL;
      }
    }

    int v25 = 2;
    uint64_t v24 = v4;
    else {
      return -1LL;
    }
  }

  else if (v7 < 0)
  {
    unint64_t v27 = -v7;
    if (_dispatch_host_time_nano2mach)
    {
      unint64_t v28 = _dispatch_host_time_nano2mach(v27);
    }

    else if (v27)
    {
      if (v27 < 0x7FFFFFFFFFFFFFFFLL)
      {
        if (v27 < 0x5555555555555555LL) {
          unint64_t v28 = 3 * v27 / 0x7D;
        }
        else {
          unint64_t v28 = 3 * (v27 / 0x7D);
        }
      }

      else
      {
        unint64_t v28 = 0x7FFFFFFFFFFFFFFFLL;
      }
    }

    else
    {
      unint64_t v28 = 0LL;
    }

    unint64_t v6 = v28;
    v4 -= v28;
    if (v4 >= 1)
    {
      int v16 = v5;
      dispatch_time_t v15 = v4;
      if (!v16) {
        return v15;
      }
      if (v16 == 1) {
        return v15 | 0x8000000000000000LL;
      }
      return -(uint64_t)v15;
    }

    else
    {
      int v19 = v5;
      dispatch_time_t v18 = 1LL;
      if (!v5) {
        return v18;
      }
      if (v19 == 1) {
        return v18 | 0x8000000000000000LL;
      }
      return -(uint64_t)v18;
    }
  }

  else
  {
    unint64_t v29 = v7;
    if (_dispatch_host_time_nano2mach)
    {
      unint64_t v30 = _dispatch_host_time_nano2mach(v29);
    }

    else if (v29)
    {
      if (v29 < 0x7FFFFFFFFFFFFFFFLL)
      {
        if (v29 < 0x5555555555555555LL) {
          unint64_t v30 = 3 * v29 / 0x7D;
        }
        else {
          unint64_t v30 = 3 * (v29 / 0x7D);
        }
      }

      else
      {
        unint64_t v30 = 0x7FFFFFFFFFFFFFFFLL;
      }
    }

    else
    {
      unint64_t v30 = 0LL;
    }

    unint64_t v6 = v30;
    v4 += v30;
    if (v4 > 0)
    {
      int v22 = v5;
      dispatch_time_t v21 = v4;
      if (!v22) {
        return v21;
      }
      if (v22 == 1) {
        return v21 | 0x8000000000000000LL;
      }
      return -(uint64_t)v21;
    }

    else
    {
      return -1LL;
    }
  }

uint64_t dispatch_time_to_nsecs(uint64_t a1, void *a2, unint64_t *a3)
{
  uint64_t v9 = a1;
  dispatch_time_t v8 = a2;
  int64_t v7 = a3;
  int v6 = 0;
  unint64_t v5 = 0LL;
  if (a1 == -1) {
    goto LABEL_41;
  }
  uint64_t v15 = v9;
  char v14 = 1;
  char v13 = &v6;
  uint64_t v12 = &v5;
  unint64_t v11 = 0LL;
  if (v9 == 0x8000000000000000LL)
  {
    int *v13 = 1;
    *uint64_t v12 = _dispatch_monotonic_time();
  }

  else if (v9 == -2)
  {
    int *v13 = 2;
    *uint64_t v12 = _dispatch_get_nanoseconds();
  }

  else if (v9)
  {
    if (v15 >= 0)
    {
      int *v13 = 0;
      unint64_t v11 = v15;
    }

    else if ((v15 & 0x4000000000000000LL) != 0)
    {
      int *v13 = 2;
      unint64_t v11 = -v15;
    }

    else
    {
      int *v13 = 1;
      unint64_t v11 = v15 & 0x7FFFFFFFFFFFFFFFLL;
    }

    if (v11 <= 0x3FFFFFFFFFFFFFFFLL) {
      uint64_t v4 = v11;
    }
    else {
      uint64_t v4 = -1LL;
    }
    *uint64_t v12 = v4;
  }

  else
  {
    int *v13 = 0;
    *uint64_t v12 = _dispatch_uptime();
  }

  if (v6)
  {
    if (v6 != 1)
    {
      if (v6 == 2)
      {
        *dispatch_time_t v8 = 3LL;
        *int64_t v7 = v5;
        char v10 = 1;
        return v10 & 1;
      }

unint64_t dispatch_time_from_nsec(uint64_t a1, unint64_t a2)
{
  unint64_t v3 = a2;
  if (a2 < 2) {
    unint64_t v3 = 2LL;
  }
  if (_dispatch_host_time_nano2mach)
  {
    unint64_t v9 = _dispatch_host_time_nano2mach(v3);
  }

  else if (v3)
  {
    if (v3 < 0x7FFFFFFFFFFFFFFFLL)
    {
      if (v3 < 0x5555555555555555LL) {
        unint64_t v9 = 3 * v3 / 0x7D;
      }
      else {
        unint64_t v9 = 3 * (v3 / 0x7D);
      }
    }

    else
    {
      unint64_t v9 = 0x7FFFFFFFFFFFFFFFLL;
    }
  }

  else
  {
    unint64_t v9 = 0LL;
  }

  switch(a1)
  {
    case 1LL:
      if (v9 < 0x3FFFFFFFFFFFFFFFLL) {
        return v9;
      }
      else {
        return -1LL;
      }
    case 2LL:
      if (v9 < 0x3FFFFFFFFFFFFFFFLL) {
        return v9 | 0x8000000000000000LL;
      }
      else {
        return -1LL;
      }
    case 3LL:
      if (v3 < 0x3FFFFFFFFFFFFFFFLL) {
        return -(uint64_t)v3;
      }
      else {
        return -1LL;
      }
  }

  return v5;
}

dispatch_time_t dispatch_walltime(const timespec *when, int64_t delta)
{
  if (when) {
    __uint64_t nanoseconds = 1000000000 * when->tv_sec + when->tv_nsec;
  }
  else {
    __uint64_t nanoseconds = _dispatch_get_nanoseconds();
  }
  uint64_t v5 = nanoseconds + delta;
  if (v5 > 1) {
    return -v5;
  }
  dispatch_time_t v2 = -2LL;
  if (delta >= 0) {
    return -1LL;
  }
  return v2;
}

unint64_t _dispatch_timeout( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v15 = a1;
  __uint64_t nanoseconds = 0LL;
  switch(a1)
  {
    case -9223372036854775808LL:
    case -2LL:
      return 0LL;
    case -1LL:
      return -1LL;
    case 0LL:
      return 0LL;
  }

  int v13 = 0;
  __uint64_t v12 = 0LL;
  unint64_t v21 = v15;
  char v20 = 0;
  unint64_t v19 = &v13;
  unint64_t v18 = (uint64_t *)&v12;
  unint64_t v17 = 0LL;
  if (v15 >= 0)
  {
    *unint64_t v19 = 0;
    unint64_t v17 = v21;
  }

  else if ((v21 & 0x4000000000000000LL) != 0)
  {
    *unint64_t v19 = 2;
    unint64_t v17 = -(uint64_t)v21;
  }

  else
  {
    *unint64_t v19 = 1;
    unint64_t v17 = v21 & 0x7FFFFFFFFFFFFFFFLL;
  }

  if (v17 <= 0x3FFFFFFFFFFFFFFFLL) {
    uint64_t v11 = v17;
  }
  else {
    uint64_t v11 = -1LL;
  }
  *unint64_t v18 = v11;
  if (v13 == 2)
  {
    __uint64_t nanoseconds = _dispatch_get_nanoseconds();
    if (nanoseconds < v12) {
      return v12 - nanoseconds;
    }
    else {
      return 0LL;
    }
  }

  else
  {
    if (v13)
    {
      BOOL v25 = v13 == 1;
      uint64_t v24 = 241LL;
      if (v13 != 1) {
        _dispatch_abort(v24, v25, a3, a4, a5, a6, a7, a8);
      }
      __uint64_t nanoseconds = _dispatch_monotonic_time();
    }

    else
    {
      __uint64_t nanoseconds = _dispatch_uptime();
    }

    if (nanoseconds >= v12) {
      return 0LL;
    }
    unint64_t v22 = v12 - nanoseconds;
    if (_dispatch_host_time_mach2nano) {
      return _dispatch_host_time_mach2nano(v22);
    }
    if (!v22) {
      return 0LL;
    }
    if (v22 >= 0x3126E978D4FDF3ALL) {
      return 0x7FFFFFFFFFFFFFFFLL;
    }
    if (v22 < 0x20C49BA5E353F7CLL) {
      return 125 * v22 / 3;
    }
    return 125 * (v22 / 3);
  }

unint64_t _dispatch_mach_host_time_mach2nano(unint64_t a1)
{
  char v2 = 1;
  if (a1) {
    char v2 = byte_E5718;
  }
  if ((v2 & 1) != 0) {
    return a1;
  }
  if (a1 >= 0x7FFFFFFFFFFFFFFFLL) {
    return 0x7FFFFFFFFFFFFFFFLL;
  }
  return 0x7FFFFFFFFFFFFFFFLL;
}

unint64_t _dispatch_mach_host_time_nano2mach(unint64_t a1)
{
  char v2 = 1;
  if (a1) {
    char v2 = byte_E5718;
  }
  if ((v2 & 1) != 0) {
    return a1;
  }
  if (a1 >= 0x7FFFFFFFFFFFFFFFLL) {
    return 0x7FFFFFFFFFFFFFFFLL;
  }
  return 0x7FFFFFFFFFFFFFFFLL;
}

unint64_t _dispatch_continuation_alloc_from_heap()
{
  if ((_dispatch_use_dispatch_alloc & 1) != 0) {
    return _dispatch_alloc_continuation_alloc();
  }
  else {
    return _dispatch_malloc_continuation_alloc();
  }
}

void _dispatch_continuation_alloc_once()
{
  if (_dispatch_continuation_alloc_init_pred != -1) {
    dispatch_once_f( &_dispatch_continuation_alloc_init_pred,  0LL,  (dispatch_function_t)_dispatch_continuation_alloc_init);
  }
}

unint64_t _dispatch_alloc_continuation_alloc()
{
  unint64_t v12 = 0LL;
  if (!_dispatch_main_heap) {
    return _dispatch_alloc_continuation_from_heap_slow();
  }
  uint64_t v11 = 0LL;
  uint64_t v17 = _dispatch_main_heap;
  uint64_t v16 = 59LL;
  unsigned int v14 = _dispatch_cpu_number();
  uint64_t v11 = *(void *)(_dispatch_main_heap + ((unint64_t)v14 << 20) + 8);
  if (v11)
  {
    for (unsigned int i = 0; i < 4; ++i)
    {
      unint64_t v9 = (unint64_t *)(v11 + 8LL * i);
      uint64_t v15 = v9;
      unsigned int unset_bit_upto_index = bitmap_set_first_unset_bit_upto_index(v9, 0xFFFFFFFF);
      if (unset_bit_upto_index != -1)
      {
        int64_t v7 = 0LL;
        unsigned int v6 = 0;
        get_cont_and_indices_for_bitmap_and_index( (uint64_t)v9,  unset_bit_upto_index,  (uint64_t *)&v12,  (uint64_t *)&v7,  &v6);
        mark_bitmap_as_full_if_still_full(v7, v6, (uint64_t *)v9, v0, v1, v2, v3, v4);
        return v12;
      }
    }
  }

  unint64_t v12 = _dispatch_alloc_continuation_from_heap(_dispatch_main_heap);
  if (v12) {
    return v12;
  }
  else {
    return _dispatch_alloc_continuation_from_heap_slow();
  }
}

uint64_t _dispatch_malloc_continuation_alloc()
{
  while (1)
  {
    uint64_t v1 = malloc_type_calloc(1LL, 64LL, 2031856694LL);
    if (v1) {
      break;
    }
    _dispatch_temporary_resource_shortage();
  }

  return v1;
}

void _dispatch_continuation_free_to_heap(void *a1)
{
  if ((_dispatch_use_dispatch_alloc & 1) != 0) {
    _dispatch_alloc_continuation_free(a1);
  }
  else {
    _dispatch_malloc_continuation_free(a1);
  }
}

void _dispatch_alloc_continuation_free(void *a1)
{
  uint64_t v17 = a1;
  uint64_t v16 = 0LL;
  uint64_t v15 = 0LL;
  unsigned int v14 = 0;
  unsigned int v13 = 0;
  *a1 = 0LL;
  get_maps_and_indices_for_continuation((uint64_t)v17, &v15, &v14, &v16, &v13);
  BOOL v12 = bitmap_clear_bit(v16, v13, 1LL, v1, v2, v3, v4, v5);
  if (v15) {
    bitmap_clear_bit(v15, v14, 0LL, v6, v7, v8, v9, v10);
  }
  BOOL v11 = 0;
  if (v12) {
    BOOL v11 = v15 != 0LL;
  }
  if (v11) {
    _dispatch_alloc_maybe_madvise_page((uint64_t)v17);
  }
}

void _dispatch_malloc_continuation_free(void *a1)
{
}

const char *_dispatch_continuation_alloc_init()
{
  BOOL v1 = malloc_engaged_nano() == 0;
  uint64_t result = getenv("LIBDISPATCH_CONTINUATION_ALLOCATOR");
  if (result)
  {
    uint64_t result = (const char *)atoi(result);
    BOOL v1 = (_DWORD)result != 0;
  }

  _dispatch_use_dispatch_alloc = v1;
  if (v1) {
    return (const char *)_os_object_atfork_prepare();
  }
  return result;
}

uint64_t get_cont_and_indices_for_bitmap_and_index( uint64_t a1, unsigned int a2, uint64_t *a3, uint64_t *a4, unsigned int *a5)
{
  uint64_t result = magazine_for_continuation(a1);
  uint64_t v15 = result;
  unsigned int v14 = (a1 - (result + 64)) / 8;
  unsigned int v13 = v14 % 0x40;
  unsigned int v12 = v14 / 0x40;
  if (result + 64 + ((unint64_t)(v14 / 0x40) << 9) + 8LL * (v14 % 0x40) != a1) {
    _dispatch_abort( 114LL,  result + 64 + ((unint64_t)(v14 / 0x40) << 9) + 8LL * (v14 % 0x40) == a1,  v6,  v7,  v8,  v9,  v10,  v11);
  }
  if (a3)
  {
    uint64_t result = continuation_address(result, v12, v13, a2, v8, v9, v10, v11);
    *a3 = result;
  }

  if (a4)
  {
    uint64_t result = supermap_address(v15, v12);
    *a4 = result;
  }

  if (a5) {
    *a5 = v13;
  }
  return result;
}

BOOL mark_bitmap_as_full_if_still_full( unint64_t *a1, unsigned int a2, uint64_t *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a2 >= 0x40) {
    _dispatch_abort(274LL, a2 < 0x40, (uint64_t)a3, a4, a5, a6, a7, a8);
  }
  uint64_t v13 = 1LL << a2;
  while (1)
  {
    unint64_t v8 = _os_atomic_mo_has_acquire(0) ? __ldaxr(a1) : __ldxr(a1);
    unint64_t v12 = v8;
    BOOL result = bitmap_is_full(*a3);
    if (!result) {
      break;
    }
    unint64_t v11 = v12 | v13;
    BOOL result = _os_atomic_mo_has_release(0);
    if (result) {
      BOOL v10 = __stlxr(v11, a1) == 0;
    }
    else {
      BOOL v10 = __stxr(v11, a1) == 0;
    }
    if (v10) {
      return result;
    }
  }

  __clrex();
  return result;
}

unint64_t _dispatch_alloc_continuation_from_heap(uint64_t a1)
{
  uint64_t v8 = _dispatch_cpu_number();
  unint64_t page = alloc_continuation_from_first_page(a1 + ((unint64_t)v8 << 20));
  if (page) {
    return page;
  }
  else {
    return alloc_continuation_from_magazine(a1 + ((unint64_t)v8 << 20));
  }
}

unint64_t _dispatch_alloc_continuation_from_heap_slow()
{
  for (unsigned int i = (unint64_t *)&_dispatch_main_heap; ; unsigned int i = (unint64_t *)*i)
  {
    if (!*i) {
      _dispatch_alloc_try_create_heap(i);
    }
    unint64_t v1 = _dispatch_alloc_continuation_from_heap(*i);
    if (v1) {
      break;
    }
  }

  return v1;
}

unint64_t _dispatch_cpu_number()
{
  return _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) & 0xFFF;
}

uint64_t bitmap_set_first_unset_bit_upto_index(unint64_t *a1, unsigned int a2)
{
  do
  {
    if (_os_atomic_mo_has_acquire(0)) {
      unint64_t v2 = __ldaxr(a1);
    }
    else {
      unint64_t v2 = __ldxr(a1);
    }
    unint64_t v10 = v2;
    int v3 = __clz(__rbit64(~v2));
    int v4 = 0;
    if (v10 != -1LL) {
      int v4 = v3 + 1;
    }
    if (!v4 || (unsigned int v11 = v4 - 1, v4 - 1 > a2))
    {
      __clrex();
      return -1;
    }

    unint64_t v9 = v10 | (1LL << v11);
    if (_os_atomic_mo_has_release(0)) {
      BOOL v8 = __stlxr(v9, a1) == 0;
    }
    else {
      BOOL v8 = __stxr(v9, a1) == 0;
    }
  }

  while (!v8);
  return v11;
}

unint64_t magazine_for_continuation(uint64_t a1)
{
  return a1 & 0xFFFFFFFFFFF00000LL;
}

unint64_t continuation_address( uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a2 >= 3) {
    _dispatch_abort(88LL, a2 < 3, a3, a4, a5, a6, a7, a8);
  }
  return a1
       + 0x4000
       + ((unint64_t)a2 << 18)
}

uint64_t supermap_address(uint64_t a1, unsigned int a2)
{
  return a1 + 16 + 8LL * a2;
}

BOOL bitmap_is_full(uint64_t a1)
{
  return a1 == -1;
}

unint64_t alloc_continuation_from_first_page(uint64_t a1)
{
  for (unsigned int i = 0; i < 3; ++i)
  {
    int unset_bit_upto_index = bitmap_set_first_unset_bit_upto_index((unint64_t *)(a1 + 1600 + 8LL * i), 0xFFFFFFFF);
    if (unset_bit_upto_index != -1) {
      return a1 + 1664 + ((unint64_t)(unset_bit_upto_index + (i << 6)) << 6);
    }
  }

  int unset_bit_upto_index = bitmap_set_first_unset_bit_upto_index((unint64_t *)(a1 + 1600 + 8LL * i), 0x25u);
  if (unset_bit_upto_index == -1) {
    return 0LL;
  }
  return a1 + 1664 + ((unint64_t)(unset_bit_upto_index + (i << 6)) << 6);
}

unint64_t alloc_continuation_from_magazine(uint64_t a1)
{
  for (unsigned int i = 0; i < 3; ++i)
  {
    unint64_t v18 = (unint64_t *)supermap_address(a1, i);
    if (!bitmap_is_full(*v18))
    {
      for (unsigned int j = 0; j < 0x40; ++j)
      {
        uint64_t v17 = (unint64_t *)bitmap_address(a1, i, j);
        unsigned int unset_bit_upto_index = bitmap_set_first_unset_bit_upto_index(v17, 0xFFFFFFFF);
        if (unset_bit_upto_index != -1)
        {
          bitmap_in_same_unint64_t page = first_bitmap_in_same_page((unint64_t)v17);
          if (!_dispatch_main_heap) {
            _dispatch_abort(50LL, 0LL, v1, v2, v3, v4, v5, v6);
          }
          *(void *)(_dispatch_main_heap + ((unint64_t)_dispatch_cpu_number() << 20) + 8) = bitmap_in_same_page;
          mark_bitmap_as_full_if_still_full(v18, j, (uint64_t *)v17, v7, v8, v9, v10, v11);
          return continuation_address(a1, i, j, unset_bit_upto_index, v12, v13, v14, v15);
        }
      }
    }
  }

  return 0LL;
}

unint64_t bitmap_address(uint64_t a1, unsigned int a2, unsigned int a3)
{
  return a1 + 64 + ((unint64_t)a2 << 9) + 8LL * a3;
}

unint64_t first_bitmap_in_same_page(unint64_t a1)
{
  unint64_t v8 = magazine_for_continuation(a1);
  if (a1 < v8 + 64) {
    _dispatch_abort(201LL, a1 >= v8 + 64, v1, v2, v3, v4, v5, v6);
  }
  if (a1 >= v8 + 2112) {
    _dispatch_abort(203LL, a1 < v8 + 2112, v1, v2, v3, v4, v5, v6);
  }
  return a1 & 0xFFFFFFFFFFFFFFE0LL;
}

void _dispatch_alloc_try_create_heap(unint64_t *a1)
{
  kern_return_t v15;
  unint64_t *v16;
  uint64_t v17;
  int v18;
  uint64_t v19;
  int v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v16 = a1;
  uint64_t v15 = 0;
  char v20 = 0;
  unint64_t v19 = 0xFFFFFC036LL;
  mach_vm_size_t v14 = MEMORY[0xFFFFFC036] << 20;
  mach_vm_offset_t v13 = 0xFFFFFLL;
  for (mach_vm_address_t address = vm_page_size; ; mach_vm_address_t address = vm_page_size)
  {
    uint64_t v15 = mach_vm_map(mach_task_self_, &address, v14, v13, 1241513985, 0, 0LL, 0, 3, 7, 1u);
    if (!v15) {
      break;
    }
    if (v15 != 3)
    {
      qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Could not allocate heap";
      qword_E4DA8 = v15;
      __break(1u);
      JUMPOUT(0xBA168LL);
    }

    _dispatch_temporary_resource_shortage();
  }

  uint64_t v11 = (void *)address;
  uint64_t v1 = v16;
  mach_vm_address_t v2 = address;
  do
    unint64_t v3 = __ldaxr(v1);
  while (!v3 && __stlxr(v2, v1));
  if (v3)
  {
    unint64_t v18 = 0;
    uint64_t v17 = 0xFFFFFC036LL;
    int v10 = mprotect(v11, MEMORY[0xFFFFFC036] << 20, 0);
    unint64_t v22 = v10;
    unint64_t v21 = 424LL;
    if (v10) {
      _dispatch_bug(v21, v22, v4, v5, v6, v7, v8, v9);
    }
  }

BOOL get_maps_and_indices_for_continuation( uint64_t a1, void *a2, unsigned int *a3, void *a4, unsigned int *a5)
{
  unint64_t v6 = magazine_for_continuation(a1);
  BOOL result = continuation_is_in_first_page(a1);
  if (result)
  {
    unsigned int v8 = ((uint64_t)(a1 - (v6 + 1664)) / 64) / 0x40;
    if (a2) {
      *a2 = 0LL;
    }
    if (a3) {
      *a3 = v8;
    }
    if (a4) {
      *a4 = v6 + 1600 + 8LL * v8;
    }
    if (a5) {
      *a5 = ((uint64_t)(a1 - (v6 + 1664)) / 64) % 0x40;
    }
  }

  else
  {
    unsigned int v10 = ((uint64_t)(a1 - (v6 + 0x4000)) / 64) / 0x1000;
    unsigned int v9 = ((uint64_t)(a1 - (v6 + 0x4000)) / 64) / 0x40 % 0x40;
    if (a2) {
      *a2 = v6 + 16 + 8LL * v10;
    }
    if (a3) {
      *a3 = v9;
    }
    if (a4) {
      *a4 = v6 + 64 + ((unint64_t)v10 << 9) + 8LL * v9;
    }
    if (a5) {
      *a5 = ((uint64_t)(a1 - (v6 + 0x4000)) / 64) % 0x40;
    }
  }

  return result;
}

BOOL bitmap_clear_bit( unint64_t *a1, unsigned int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a2 >= 0x40) {
    _dispatch_abort(251LL, a2 < 0x40, a3, a4, a5, a6, a7, a8);
  }
  uint64_t v13 = 1LL << a2;
  if ((a3 & 1) != 0 && (*a1 & v13) == 0)
  {
    uint64_t v8 = *a1;
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Corruption: failed to clear bit exclusively";
    qword_E4DA8 = v8;
    __break(1u);
    JUMPOUT(0xBA6B8LL);
  }

  unint64_t v12 = *a1;
  do
  {
    unint64_t v9 = v12;
    do
      unint64_t v10 = __ldaxr(a1);
    while (v10 == v12 && __stlxr(v12 & ~v13, a1));
    unint64_t v12 = v10;
  }

  while (v10 != v9);
  return (v10 & ~v13) == 0;
}

void _dispatch_alloc_maybe_madvise_page(uint64_t a1)
{
  uint64_t v14 = a1;
  uint64_t v13 = (void *)madvisable_page_base_for_continuation(a1);
  if (v13)
  {
    unint64_t v12 = 0LL;
    get_maps_and_indices_for_continuation((uint64_t)v13, 0LL, 0LL, &v12, 0LL);
    for (unsigned int i = 0; i < 4; ++i)
    {
      if (v12[i]) {
        return;
      }
    }

    int v10 = 0;
    while (1)
    {
      uint64_t v1 = &v12[v10];
      do
        unint64_t v2 = __ldaxr(v1);
      while (!v2 && __stlxr(0xFFFFFFFFFFFFFFFFLL, v1));
      if (v2) {
        break;
      }
      if (++v10 >= 4)
      {
        __memset_chk(v13, 2947526575LL, 0x4000LL, -1LL);
        int v9 = madvise(v13, 0x4000uLL, 5);
        uint64_t v16 = v9;
        uint64_t v15 = 563LL;
        if (v9) {
          _dispatch_bug(v15, v16, v3, v4, v5, v6, v7, v8);
        }
        break;
      }
    }

    while (v10 > 1)
      v12[--v10] = 0LL;
    if (v10) {
      *unint64_t v12 = 0LL;
    }
  }

BOOL continuation_is_in_first_page(uint64_t a1)
{
  return (a1 & 0xFFFFFFFFFFF00000LL) == (a1 & 0xFFFFFFFFFFFFC000LL);
}

unint64_t madvisable_page_base_for_continuation(uint64_t a1)
{
  if (continuation_is_in_first_page(a1)) {
    return 0LL;
  }
  unint64_t v2 = magazine_for_continuation(a1);
  if ((a1 & 0xFFFFFFFFFFFFC000LL) < v2 + 0x4000)
  {
    qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: madvisable continuation too low";
    qword_E4DA8 = a1 & 0xFFFFFFFFFFFFC000LL;
    __break(1u);
    JUMPOUT(0xBAAFCLL);
  }

  if ((a1 & 0xFFFFFFFFFFFFC000LL) > v2 + 802752)
  {
    qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: madvisable continuation too high";
    qword_E4DA8 = a1 & 0xFFFFFFFFFFFFC000LL;
    __break(1u);
    JUMPOUT(0xBAB60LL);
  }

  return a1 & 0xFFFFFFFFFFFFC000LL;
}

uint64_t dispatch_benchmark(unint64_t a1, uint64_t a2)
{
  unint64_t v2 = (void (*)(uint64_t))_Block_get_invoke_fn(a2);
  return dispatch_benchmark_f(a1, a2, v2);
}

uint64_t dispatch_benchmark_f(unint64_t a1, uint64_t a2, void (*a3)(uint64_t))
{
  unint64_t v4 = 0LL;
  if (dispatch_benchmark_f_pred != -1) {
    dispatch_once_f( &dispatch_benchmark_f_pred,  &dispatch_benchmark_f_bdata,  (dispatch_function_t)_dispatch_benchmark_init);
  }
  if (!a1) {
    return 0LL;
  }
  uint64_t v6 = _dispatch_uptime();
  do
  {
    ++v4;
    a3(a2);
  }

  while (v4 < a1);
  uint64_t v5 = _dispatch_uptime() - v6;
  return __udivti3( v5 * dispatch_benchmark_f_bdata,  (v5 * (unsigned __int128)dispatch_benchmark_f_bdata) >> 64,  dword_E4D4C * a1)
       - qword_E4D50;
}

  ;
}

uint64_t _dispatch_benchmark_init(unsigned int *a1)
{
  uint64_t v15 = (void (*)(uint64_t))*((void *)a1 + 2);
  uint64_t v14 = *((void *)a1 + 3);
  unint64_t v13 = *((void *)a1 + 4);
  unint64_t v12 = 0LL;
  uint64_t v17 = mach_timebase_info((mach_timebase_info_t)a1);
  if (v17) {
    _dispatch_abort(53LL, v17, v1, v2, v3, v4, v5, v6);
  }
  uint64_t v11 = _dispatch_uptime();
  do
  {
    ++v12;
    v15(v14);
  }

  while (v12 < v13);
  unsigned __int128 v7 = (_dispatch_uptime() - v11) * (unsigned __int128)*a1;
  uint64_t v8 = __udivti3(v7, *((void *)&v7 + 1), a1[1]);
  uint64_t result = __udivti3(v8, v9, v13);
  *((void *)a1 + _dispatch_source_set_handler((uint64_t)source, handler, 2LL, 1) = result;
  return result;
}

uint64_t _dispatch_send_wakeup_runloop_thread(unsigned int a1, mach_msg_timeout_t a2)
{
  unsigned int v6 = a1;
  mach_msg_timeout_t v5 = a2;
  *(void *)&v4.msgh_bits = 19LL;
  *(void *)&v4.msgh_voucher_mach_port_t port = 0x4E00000000LL;
  *(void *)&v4.msgh_remote_mach_port_t port = a1;
  unsigned int v3 = mach_msg(&v4, 17, 0x18u, 0, 0, a2, 0);
  if (v3 == 268435460)
  {
    mach_msg_destroy(&v4);
  }

  return v3;
}

uint64_t _dispatch_send_consume_send_once_right(unsigned int a1)
{
  unsigned int v3 = a1;
  *(void *)&v2.msgh_bits = 18LL;
  *(void *)&v2.msgh_voucher_mach_port_t port = 0x4F00000000LL;
  *(void *)&v2.msgh_remote_mach_port_t port = a1;
  return mach_msg(&v2, 1, 0x18u, 0, 0, 0, 0);
}

uint64_t libdispatch_internal_protocol_server_routine(uint64_t a1)
{
  unsigned int v2 = *(_DWORD *)(a1 + 20) - 64;
  if (v2 < 0x10) {
    return qword_E2210[5 * (int)v2 + 1];
  }
  else {
    return 0LL;
  }
}

uint64_t _Xmach_notify_port_deleted(uint64_t a1, uint64_t a2)
{
  uint64_t result = __MIG_check__Request__mach_notify_port_deleted_t((int *)a1);
  if ((_DWORD)result)
  {
    *(_DWORD *)(a2 + 32) = result;
    *(NDR_record_t *)(a2 + 24) = NDR_record;
  }

  else
  {
    uint64_t result = _dispatch_mach_notify_port_deleted( *(unsigned int *)(a1 + 12),  *(unsigned int *)(a1 + 32),  v3,  v4,  v5,  v6,  v7,  v8);
    *(_DWORD *)(a2 + 32) = result;
  }

  return result;
}

uint64_t _Xmach_notify_send_possible(uint64_t a1, uint64_t a2)
{
  uint64_t result = __MIG_check__Request__mach_notify_port_deleted_t((int *)a1);
  if ((_DWORD)result)
  {
    *(_DWORD *)(a2 + 32) = result;
    *(NDR_record_t *)(a2 + 24) = NDR_record;
  }

  else
  {
    uint64_t result = _dispatch_mach_notify_send_possible(*(unsigned int *)(a1 + 12), *(_DWORD *)(a1 + 32));
    *(_DWORD *)(a2 + 32) = result;
  }

  return result;
}

uint64_t _Xmach_notify_port_destroyed(uint64_t a1, uint64_t a2)
{
  uint64_t result = __MIG_check__Request__mach_notify_port_destroyed_t((int *)a1);
  if (!(_DWORD)result) {
    _dispatch_mach_notify_port_destroyed(*(unsigned int *)(a1 + 12), *(_DWORD *)(a1 + 28));
  }
  *(_DWORD *)(a2 + 32) = result;
  *(NDR_record_t *)(a2 + 24) = NDR_record;
  return result;
}

uint64_t _Xmach_notify_no_senders(uint64_t a1, uint64_t a2)
{
  uint64_t result = __MIG_check__Request__mach_notify_port_deleted_t((int *)a1);
  if (!(_DWORD)result) {
    _dispatch_mach_notify_no_senders(*(unsigned int *)(a1 + 12), *(_DWORD *)(a1 + 32));
  }
  *(_DWORD *)(a2 + 32) = result;
  *(NDR_record_t *)(a2 + 24) = NDR_record;
  return result;
}

uint64_t _Xmach_notify_send_once(uint64_t a1, uint64_t a2)
{
  uint64_t result = __MIG_check__Request__mach_notify_send_once_t((int *)a1);
  if ((_DWORD)result)
  {
    *(_DWORD *)(a2 + 32) = result;
    *(NDR_record_t *)(a2 + 24) = NDR_record;
  }

  else
  {
    uint64_t result = _dispatch_mach_notify_send_once(*(unsigned int *)(a1 + 12), v3, v4, v5, v6, v7, v8, v9);
    *(_DWORD *)(a2 + 32) = result;
  }

  return result;
}

uint64_t _Xmach_notify_dead_name(uint64_t a1, uint64_t a2)
{
  uint64_t result = __MIG_check__Request__mach_notify_port_deleted_t((int *)a1);
  if ((_DWORD)result)
  {
    *(_DWORD *)(a2 + 32) = result;
    *(NDR_record_t *)(a2 + 24) = NDR_record;
  }

  else
  {
    uint64_t result = _dispatch_mach_notify_dead_name(*(unsigned int *)(a1 + 12), *(_DWORD *)(a1 + 32));
    *(_DWORD *)(a2 + 32) = result;
  }

  return result;
}

uint64_t _Xwakeup_runloop_thread(int *a1, uint64_t a2)
{
  uint64_t result = __MIG_check__Request__mach_notify_send_once_t(a1);
  if ((_DWORD)result)
  {
    *(_DWORD *)(a2 + 32) = result;
    *(NDR_record_t *)(a2 + 24) = NDR_record;
  }

  else
  {
    uint64_t result = _dispatch_wakeup_runloop_thread();
    *(_DWORD *)(a2 + 32) = result;
  }

  return result;
}

uint64_t _Xconsume_send_once_right(int *a1, uint64_t a2)
{
  uint64_t result = __MIG_check__Request__mach_notify_send_once_t(a1);
  if ((_DWORD)result)
  {
    *(_DWORD *)(a2 + 32) = result;
    *(NDR_record_t *)(a2 + 24) = NDR_record;
  }

  else
  {
    uint64_t result = _dispatch_wakeup_runloop_thread();
    *(_DWORD *)(a2 + 32) = result;
  }

  return result;
}

uint64_t libdispatch_internal_protocol_server(_DWORD *a1, uint64_t a2)
{
  *(_DWORD *)a2 = *a1 & 0x1F;
  *(_DWORD *)(a2 + 8) = a1[2];
  *(_DWORD *)(a2 + 4) = 36;
  *(_DWORD *)(a2 + 12) = 0;
  *(_DWORD *)(a2 + memset(__b, 0, 20) = a1[5] + 100;
  *(_DWORD *)(a2 + 16) = 0;
  if ((int)a1[5] <= 79
    && (int)a1[5] >= 64
    && (uint64_t v3 = (void (*)(_DWORD *, uint64_t))qword_E2210[5 * a1[5] - 319]) != 0LL)
  {
    v3(a1, a2);
    return 1;
  }

  else
  {
    *(NDR_record_t *)(a2 + 24) = NDR_record;
    *(_DWORD *)(a2 + 32) = -303;
    return 0;
  }

uint64_t __MIG_check__Request__mach_notify_port_deleted_t(int *a1)
{
  if (*a1 >= 0 && a1[1] == 36) {
    return 0;
  }
  else {
    return -304;
  }
}

uint64_t __MIG_check__Request__mach_notify_port_destroyed_t(int *a1)
{
  if (*a1 < 0 && a1[6] == 1 && a1[1] == 40)
  {
    else {
      return -300;
    }
  }

  else
  {
    return -304;
  }

uint64_t __MIG_check__Request__mach_notify_send_once_t(int *a1)
{
  if (*a1 >= 0 && a1[1] == 24) {
    return 0;
  }
  else {
    return -304;
  }
}

uint64_t firehose_send_register(int a1, int a2, uint64_t a3, int a4, int a5, int a6, int a7, uint64_t a8)
{
  int v17 = a1;
  int v16 = a2;
  uint64_t v15 = a3;
  int v14 = a4;
  int v13 = a5;
  int v12 = a6;
  int v11 = a7;
  uint64_t v10 = a8;
  memset(__b, 0, sizeof(__b));
  *(_DWORD *)&__b[24] = 5;
  *(_DWORD *)&__b[28] = v16;
  *(_DWORD *)&_WORD __b[36] = *(_DWORD *)&__b[36] & 0xFF00FFFF | 0x110000;
  *(_DWORD *)&__b[36] &= 0xFFFFFFu;
  *(_DWORD *)&__b[40] = v14;
  *(_DWORD *)&__b[48] = *(_DWORD *)&__b[48] & 0xFF00FFFF | 0x100000;
  *(_DWORD *)&__b[48] &= 0xFFFFFFu;
  *(_DWORD *)&__b[52] = v13;
  *(_DWORD *)&__b[60] = *(_DWORD *)&__b[60] & 0xFF00FFFF | 0x100000;
  *(_DWORD *)&__b[60] &= 0xFFFFFFu;
  *(_DWORD *)&__b[64] = v12;
  *(_DWORD *)&__b[72] = *(_DWORD *)&__b[72] & 0xFF00FFFF | 0x140000;
  *(_DWORD *)&__b[72] &= 0xFFFFFFu;
  *(_DWORD *)&__b[76] = v11;
  *(_DWORD *)&__b[84] = *(_DWORD *)&__b[84] & 0xFF00FFFF | 0x110000;
  *(_DWORD *)&__b[84] &= 0xFFFFFFu;
  *(NDR_record_t *)&__b[88] = NDR_record;
  *(void *)&uint8_t __b[96] = v15;
  *(void *)&__b[104] = v10;
  *(_DWORD *)&__b[12] = 0;
  *(_DWORD *)stat __b = -2147483629;
  *(_DWORD *)&__b[8] = v17;
  *(_DWORD *)&__b[20] = 11600;
  *(_DWORD *)&void __b[16] = 0;
  return mach_msg((mach_msg_header_t *)__b, 1, 0x70u, 0, 0, 0, 0);
}

uint64_t firehose_send_push_and_wait(int a1, _OWORD *a2, _DWORD *a3)
{
  uint64_t v3 = memset(__b, 0, sizeof(__b));
  *(_DWORD *)&__b[12] = mig_get_special_reply_port(v3);
  *(_DWORD *)stat __b = 5395;
  *(_DWORD *)&__b[8] = a1;
  *(_DWORD *)&__b[20] = 11601;
  *(_DWORD *)&void __b[16] = 0;
  unsigned int v7 = mach_msg((mach_msg_header_t *)__b, 3162115, 0x18u, 0x40u, *(mach_port_name_t *)&__b[12], 0, 0);
  if (v7)
  {
    BOOL v4 = v7 == 268435459 || v7 == 268435458;
    if (!v4 && v7 != 268435472) {
      mig_dealloc_special_reply_port(*(unsigned int *)&__b[12]);
    }
  }

  if (v7)
  {
    return v7;
  }

  else
  {
    unsigned int v6 = __MIG_check__Reply__push_and_wait_t((int *)__b);
    if (v6)
    {
      mach_msg_destroy((mach_msg_header_t *)__b);
      return v6;
    }

    else
    {
      *a2 = *(_OWORD *)&__b[36];
      *a3 = *(_DWORD *)&__b[52];
      return 0;
    }
  }

uint64_t __MIG_check__Reply__push_and_wait_t(int *a1)
{
  if (a1[5] == 11701)
  {
    int v2 = a1[1];
    if (*a1 >= 0 && (v2 == 56 || v2 == 36 && a1[8]))
    {
      if (a1[2])
      {
        return -300;
      }

      else if (a1[8])
      {
        return a1[8];
      }

      else
      {
        return 0;
      }
    }

    else
    {
      return -300;
    }
  }

  else if (a1[5] == 71)
  {
    return -308;
  }

  else
  {
    return -301;
  }

uint64_t firehose_send_push_async(int a1, int a2, mach_msg_timeout_t a3)
{
  int v8 = a1;
  int v7 = a2;
  mach_msg_timeout_t v6 = a3;
  memset(__b, 0, sizeof(__b));
  *(NDR_record_t *)&__b[24] = NDR_record;
  *(_DWORD *)&__b[32] = v7;
  *(_DWORD *)&__b[12] = 0;
  *(_DWORD *)stat __b = 19;
  *(_DWORD *)&__b[8] = v8;
  *(_DWORD *)&__b[20] = 11602;
  *(_DWORD *)&void __b[16] = 0;
  unsigned int v4 = mach_msg((mach_msg_header_t *)__b, 17, 0x24u, 0, 0, v6, 0);
  if (v4 == 268435460)
  {
    mach_msg_destroy((mach_msg_header_t *)__b);
  }

  return v4;
}

uint64_t firehose_send_get_logging_prefs(int a1, _DWORD *a2, void *a3)
{
  int v11 = a1;
  uint64_t v10 = a2;
  uint64_t v9 = a3;
  uint64_t v3 = memset(__b, 0, sizeof(__b));
  *(_DWORD *)&__b[12] = mig_get_special_reply_port(v3);
  *(_DWORD *)stat __b = 5395;
  *(_DWORD *)&__b[8] = v11;
  *(_DWORD *)&__b[20] = 11603;
  *(_DWORD *)&void __b[16] = 0;
  unsigned int v7 = mach_msg((mach_msg_header_t *)__b, 3162115, 0x18u, 0x40u, *(mach_port_name_t *)&__b[12], 0, 0);
  if (v7)
  {
    BOOL v4 = v7 == 268435459 || v7 == 268435458;
    if (!v4 && v7 != 268435472) {
      mig_dealloc_special_reply_port(*(unsigned int *)&__b[12]);
    }
  }

  if (v7)
  {
    return v7;
  }

  else
  {
    unsigned int v6 = __MIG_check__Reply__get_logging_prefs_t((int *)__b);
    if (v6)
    {
      mach_msg_destroy((mach_msg_header_t *)__b);
      return v6;
    }

    else
    {
      _DWORD *v10 = *(_DWORD *)&__b[28];
      void *v9 = *(void *)&__b[48];
      return 0;
    }
  }

uint64_t __MIG_check__Reply__get_logging_prefs_t(int *a1)
{
  if (a1[5] == 11703)
  {
    int v2 = a1[1];
    if (*a1 < 0 && a1[6] == 1 && v2 == 56 || *a1 >= 0 && v2 == 36 && a1[8])
    {
      if (a1[2])
      {
        return -300;
      }

      else if (*a1 < 0)
      {
        else {
          return -300;
        }
      }

      else
      {
        return a1[8];
      }
    }

    else
    {
      return -300;
    }
  }

  else if (a1[5] == 71)
  {
    return -308;
  }

  else
  {
    return -301;
  }

uint64_t firehose_send_should_send_strings(mach_port_t a1, mach_port_t *a2)
{
  mach_port_t v9 = a1;
  int v8 = a2;
  int v2 = memset(__b, 0, sizeof(__b));
  __b[0].msgh_local_mach_port_t port = mig_get_special_reply_port(v2);
  __b[0].msgh_bits = 5395;
  __b[0].msgh_remote_mach_port_t port = v9;
  __b[0].msgh_id = 11604;
  __b[0].msgh_voucher_mach_port_t port = 0;
  unsigned int v6 = mach_msg(__b, 3162115, 0x18u, 0x30u, __b[0].msgh_local_port, 0, 0);
  if (v6)
  {
    BOOL v3 = v6 == 268435459 || v6 == 268435458;
    if (!v3 && v6 != 268435472) {
      mig_dealloc_special_reply_port(__b[0].msgh_local_port);
    }
  }

  if (v6)
  {
    return v6;
  }

  else
  {
    unsigned int v5 = __MIG_check__Reply__should_send_strings_t((int *)__b);
    if (v5)
    {
      mach_msg_destroy(__b);
      return v5;
    }

    else
    {
      *int v8 = __b[1].msgh_local_port;
      return 0;
    }
  }

uint64_t __MIG_check__Reply__should_send_strings_t(int *a1)
{
  if (a1[5] == 11704)
  {
    int v2 = a1[1];
    if (*a1 >= 0 && (v2 == 40 || v2 == 36 && a1[8]))
    {
      if (a1[2])
      {
        return -300;
      }

      else if (a1[8])
      {
        return a1[8];
      }

      else
      {
        return 0;
      }
    }

    else
    {
      return -300;
    }
  }

  else if (a1[5] == 71)
  {
    return -308;
  }

  else
  {
    return -301;
  }

uint64_t firehoseReply_server_routine(uint64_t a1)
{
  unsigned int v2 = *(_DWORD *)(a1 + 20) - 11700;
  if (v2 <= 4) {
    return qword_E24B0[5 * (int)v2 + 1];
  }
  else {
    return 0LL;
  }
}

uint64_t _Xpush_reply(uint64_t a1, uint64_t a2)
{
  uint64_t result = __MIG_check__Request__push_reply_t((int *)a1);
  if (!(_DWORD)result) {
    firehose_client_push_reply(*(unsigned int *)(a1 + 12), *(_DWORD *)(a1 + 32));
  }
  *(_DWORD *)(a2 + 32) = result;
  *(NDR_record_t *)(a2 + 24) = NDR_record;
  return result;
}

uint64_t _Xpush_notify_async(uint64_t a1, uint64_t a2)
{
  uint64_t result = __MIG_check__Request__push_notify_async_t((int *)a1);
  if ((_DWORD)result)
  {
    *(_DWORD *)(a2 + 32) = result;
    *(NDR_record_t *)(a2 + 24) = NDR_record;
  }

  else
  {
    uint64_t result = firehose_client_push_notify_async( *(unsigned int *)(a1 + 12),  *(void *)(a1 + 32),  *(void *)(a1 + 40),  *(_DWORD *)(a1 + 48));
    *(_DWORD *)(a2 + 32) = result;
  }

  return result;
}

uint64_t firehoseReply_server(_DWORD *a1, uint64_t a2)
{
  *(_DWORD *)a2 = *a1 & 0x1F;
  *(_DWORD *)(a2 + 8) = a1[2];
  *(_DWORD *)(a2 + 4) = 36;
  *(_DWORD *)(a2 + 12) = 0;
  *(_DWORD *)(a2 + memset(__b, 0, 20) = a1[5] + 100;
  *(_DWORD *)(a2 + 16) = 0;
  if ((int)a1[5] <= 11704
    && (int)a1[5] >= 11700
    && (BOOL v3 = (void (*)(_DWORD *, uint64_t))qword_E24B0[5 * a1[5] - 58499]) != 0LL)
  {
    v3(a1, a2);
    return 1;
  }

  else
  {
    *(NDR_record_t *)(a2 + 24) = NDR_record;
    *(_DWORD *)(a2 + 32) = -303;
    return 0;
  }

uint64_t __MIG_check__Request__push_reply_t(int *a1)
{
  if (*a1 >= 0 && a1[1] == 56) {
    return 0;
  }
  else {
    return -304;
  }
}

uint64_t __MIG_check__Request__push_notify_async_t(int *a1)
{
  if (*a1 >= 0 && a1[1] == 52) {
    return 0;
  }
  else {
    return -304;
  }
}

void _dispatch_bug( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (_dispatch_build_pred != -1) {
    dispatch_once_f(&_dispatch_build_pred, 0LL, (dispatch_function_t)_dispatch_build_init);
  }
  uint64_t v9 = _dispatch_bug_last_seen;
  _dispatch_bug_last_seen = v8;
  if (v8 != v9) {
    _dispatch_log("BUG in libdispatch: %s - %lu - 0x%lx", a2, a3, a4, a5, a6, a7, a8, (uint64_t)&_dispatch_build);
  }
}

void _dispatch_log( char *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  v9[1] = a1;
  v9[0] = &a9;
  int v12 = a1;
  uint64_t v11 = 0LL;
  uint64_t v10 = (char **)v9;
  uint64_t v15 = &_dispatch_logv_pred;
  int v14 = 0LL;
  dispatch_function_t v13 = (dispatch_function_t)_dispatch_logv_init;
  if (_dispatch_logv_pred != -1LL) {
    dispatch_once_f(v15, v14, v13);
  }
  if ((dispatch_log_disabled & 1) == 0)
  {
    if (dispatch_logfile == -1)
    {
      if (v10) {
        _dispatch_vsyslog(v12, *v10);
      }
      else {
        _dispatch_syslog((uint64_t)v12);
      }
    }

    else if (v10)
    {
      _dispatch_logv_file(v12, *v10);
    }

    else
    {
      _dispatch_log_file((uint64_t)v12, v11);
    }
  }

void _dispatch_bug_mach_client(uint64_t a1, mach_error_t a2)
{
  uint64_t v10 = _dispatch_bug_mach_client_last_seen;
  _dispatch_bug_mach_client_last_seen = v2;
  if (v2 != v10)
  {
    mach_error_string(a2);
    _dispatch_log("BUG in libdispatch client: %s %s - 0x%x", v3, v4, v5, v6, v7, v8, v9, a1);
    if ((_dispatch_mode & 1) != 0)
    {
      qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: LIBDISPATCH_STRICT: _dispatch_bug_mach_client";
      __break(1u);
      JUMPOUT(0xBCCFCLL);
    }
  }

void _dispatch_bug_kevent_client( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v52 = a7;
  uint64_t v51 = a1;
  uint64_t v50 = a2;
  uint64_t v49 = (char *)a3;
  unsigned int v48 = a4;
  uint64_t v47 = a5;
  uint64_t v46 = (char *)a6;
  uint64_t v45 = 0LL;
  uint64_t v44 = 0LL;
  uint64_t function_symbol = 0LL;
  if (a7)
  {
    uint64_t v44 = ~*(void *)(v52 + 8);
    uint64_t v36 = *(void *)(*(void *)v44 + 16LL);
    if (v36 == 275)
    {
      uint64_t v45 = *(void *)(v52 + 40);
      if (v45) {
        uint64_t function_symbol = _dispatch_continuation_get_function_symbol(v45);
      }
    }

    else if (v36 == 787)
    {
      uint64_t function_symbol = *(void *)(v52 + 40);
    }

    uint64_t v50 = **(void **)v52;
  }

  if (v49 && v48)
  {
    uint64_t v42 = _dispatch_bug_kevent_client_last_seen;
    _dispatch_bug_kevent_client_last_seen = v37;
    BOOL v41 = v37 == v42;
    if (v37 != v42)
    {
      uint64_t v34 = v51;
      unint64_t v33 = v49;
      uint64_t v35 = &v22;
      uint64_t v30 = function_symbol;
      uint64_t v29 = v47;
      uint64_t v28 = v47;
      uint64_t v27 = v50;
      uint64_t v26 = (uint64_t)v46;
      uint64_t v25 = v48;
      uint64_t v24 = strerror(v48);
      int v23 = v49;
      _dispatch_log( "BUG in libdispatch client: %s %s: %s - 0x%x { 0x%llx[%s], ident: %lld / 0x%llx, handler: %p }",  v8,  v9,  v10,  v11,  v12,  v13,  v14,  v51);
      if ((_dispatch_mode & 1) != 0)
      {
        qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: LIBDISPATCH_STRICT: _dispatch_bug_kevent_client";
        __break(1u);
        JUMPOUT(0xBCEECLL);
      }
    }
  }

  else if (v49)
  {
    uint64_t v40 = _dispatch_bug_kevent_client_last_seen_66;
    _dispatch_bug_kevent_client_last_seen_66 = v37;
    if (v37 != v40)
    {
      uint64_t v28 = function_symbol;
      uint64_t v27 = v47;
      uint64_t v26 = v47;
      uint64_t v25 = v50;
      uint64_t v24 = v46;
      int v23 = v49;
      _dispatch_log( "BUG in libdispatch client: %s %s{ 0x%llx[%s], ident: %lld / 0x%llx, handler: %p }",  a2,  a3,  a4,  a5,  a6,  a7,  a8,  v51);
      if ((_dispatch_mode & 1) != 0)
      {
        qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: LIBDISPATCH_STRICT: _dispatch_bug_kevent_client";
        __break(1u);
        JUMPOUT(0xBCFBCLL);
      }
    }
  }

  else
  {
    uint64_t v39 = _dispatch_bug_kevent_client_last_seen_68;
    _dispatch_bug_kevent_client_last_seen_68 = v37;
    BOOL v38 = v37 == v39;
    if (v37 != v39)
    {
      uint64_t v31 = v51;
      unint64_t v32 = &v22;
      uint64_t v29 = function_symbol;
      uint64_t v28 = v47;
      uint64_t v27 = v47;
      uint64_t v26 = v50;
      uint64_t v25 = (uint64_t)v46;
      uint64_t v24 = (char *)v48;
      int v23 = strerror(v48);
      _dispatch_log( "BUG in libdispatch: %s: %s - 0x%x{ 0x%llx[%s], ident: %lld / 0x%llx, handler: %p }",  v15,  v16,  v17,  v18,  v19,  v20,  v21,  v51);
      if ((_dispatch_mode & 1) != 0)
      {
        qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: LIBDISPATCH_STRICT: _dispatch_bug_kevent_client";
        __break(1u);
        JUMPOUT(0xBD09CLL);
      }
    }
  }

void _dispatch_bug_kevent_vanished( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(void *)(*(void *)~*(void *)(a1 + 8) + 16LL) == 275LL && *(void *)(a1 + 40)) {
    _dispatch_continuation_get_function_symbol(*(void *)(a1 + 40));
  }
  uint64_t v9 = _dispatch_bug_kevent_vanished_last_seen;
  _dispatch_bug_kevent_vanished_last_seen = v8;
  if (v8 != v9)
  {
    _dispatch_log( "BUG in libdispatch client: %s, monitored resource vanished before the source cancel handler was invoked { %p[%s], ident: %d / 0x%x, handler: %p }",  a2,  a3,  a4,  a5,  a6,  a7,  a8,  **(void **)a1);
    if ((_dispatch_mode & 1) != 0)
    {
      qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: LIBDISPATCH_STRICT: _dispatch_bug_kevent_vanished";
      __break(1u);
      JUMPOUT(0xBD260LL);
    }
  }

void _dispatch_bug_deprecated( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = _dispatch_bug_deprecated_last_seen;
  _dispatch_bug_deprecated_last_seen = v8;
  if (v8 != v9)
  {
    _dispatch_log( "DEPRECATED USE in libdispatch client: %s; set a breakpoint on _dispatch_bug_deprecated to debug",
      a2,
      a3,
      a4,
      a5,
      a6,
      a7,
      a8,
      a1);
    if ((_dispatch_mode & 1) != 0)
    {
      qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: LIBDISPATCH_STRICT: _dispatch_bug_deprecated";
      __break(1u);
      JUMPOUT(0xBD30CLL);
    }
  }

void _dispatch_abort( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void dispatch_debugv(dispatch_object_t object, const char *message, va_list ap)
{
}

void dispatch_debug(dispatch_object_t object, const char *message, ...)
{
}

size_t _dispatch_object_debug_attr(uint64_t a1, char *a2, size_t a3)
{
  int v6 = __snprintf_chk( a2,  a3,  0,  0xFFFFFFFFFFFFFFFFLL,  "xref = %d, ref = %d, ",  *(_DWORD *)(a1 + 12),  *(_DWORD *)(a1 + 8));
  if (v6 < 0) {
    return 0LL;
  }
  if (v6 <= a3) {
    return v6;
  }
  else {
    return a3;
  }
}

size_t _dispatch_semaphore_debug(uint64_t a1, char *a2, size_t a3)
{
  int v12 = __snprintf_chk( a2,  a3,  0,  0xFFFFFFFFFFFFFFFFLL,  "%s[%p] = { ",  *(const char **)(*(void *)a1 + 24LL),  (const void *)a1);
  if (v12 >= 0)
  {
    if (v12 <= a3) {
      size_t v8 = v12;
    }
    else {
      size_t v8 = a3;
    }
    size_t v9 = v8;
  }

  else
  {
    size_t v9 = 0LL;
  }

  size_t v14 = v9 + _dispatch_object_debug_attr(a1, &a2[v9], a3 - v9);
  int v11 = __snprintf_chk(&a2[v14], a3 - v14, 0, 0xFFFFFFFFFFFFFFFFLL, "port = 0x%x, ", *(_DWORD *)(a1 + 64));
  if (v11 >= 0)
  {
    if (v11 <= a3 - v14) {
      size_t v6 = v11;
    }
    else {
      size_t v6 = a3 - v14;
    }
    size_t v7 = v6;
  }

  else
  {
    size_t v7 = 0LL;
  }

  size_t v15 = v14 + v7;
  int v10 = __snprintf_chk( &a2[v15],  a3 - v15,  0,  0xFFFFFFFFFFFFFFFFLL,  "value = %ld, orig = %ld }",  *(void *)(a1 + 48),  *(void *)(a1 + 56));
  if (v10 >= 0)
  {
    if (v10 <= a3 - v15) {
      size_t v4 = v10;
    }
    else {
      size_t v4 = a3 - v15;
    }
    size_t v5 = v4;
  }

  else
  {
    size_t v5 = 0LL;
  }

  return v15 + v5;
}

size_t _dispatch_group_debug(void *a1, char *a2, size_t a3)
{
  uint64_t v12 = a1[6];
  int v9 = __snprintf_chk(a2, a3, 0, 0xFFFFFFFFFFFFFFFFLL, "%s[%p] = { ", *(const char **)(*a1 + 24LL), a1);
  if (v9 >= 0)
  {
    if (v9 <= a3) {
      size_t v6 = v9;
    }
    else {
      size_t v6 = a3;
    }
    size_t v7 = v6;
  }

  else
  {
    size_t v7 = 0LL;
  }

  size_t v11 = v7 + _dispatch_object_debug_attr((uint64_t)a1, &a2[v7], a3 - v7);
  int v8 = __snprintf_chk( &a2[v11],  a3 - v11,  0,  0xFFFFFFFFFFFFFFFFLL,  "count = %u, gen = %d, waiters = %d, notifs = %d }",  -(v12 & 0xFFFFFFFC) >> 2,  HIDWORD(v12),  (v12 & 1) != 0,  (v12 & 2) != 0);
  if (v8 >= 0)
  {
    if (v8 <= a3 - v11) {
      size_t v4 = v8;
    }
    else {
      size_t v4 = a3 - v11;
    }
    size_t v5 = v4;
  }

  else
  {
    size_t v5 = 0LL;
  }

  return v11 + v5;
}

size_t _dispatch_queue_debug_attr(uint64_t a1, char *a2, size_t a3)
{
  uint64_t v49 = *(void **)(a1 + 24);
  if (v49 && v49[9]) {
    unint64_t v33 = (const char *)v49[9];
  }
  else {
    unint64_t v33 = "";
  }
  unint64_t v48 = *(void *)(a1 + 56);
  int v46 = __snprintf_chk( a2,  a3,  0,  0xFFFFFFFFFFFFFFFFLL,  "sref = %d, target = %s[%p], width = 0x%x, state = 0x%016llx",  *(_DWORD *)(a1 + 96) + 1,  v33,  v49,  *(unsigned __int16 *)(a1 + 80),  v48);
  if (v46 >= 0)
  {
    if (v46 <= a3) {
      size_t v31 = v46;
    }
    else {
      size_t v31 = a3;
    }
    size_t v32 = v31;
  }

  else
  {
    size_t v32 = 0LL;
  }

  size_t v50 = v32;
  if ((v48 & 0xFF80000000000000LL) != 0)
  {
    int v45 = __snprintf_chk(&a2[v32], a3 - v32, 0, 0xFFFFFFFFFFFFFFFFLL, ", suspended = %d", v48 / 0x400000000000000LL);
    if (v45 >= 0)
    {
      if (v45 <= a3 - v32) {
        size_t v29 = v45;
      }
      else {
        size_t v29 = a3 - v32;
      }
      size_t v30 = v29;
    }

    else
    {
      size_t v30 = 0LL;
    }

    size_t v50 = v32 + v30;
  }

  switch(v48 & 0x180000000000000LL)
  {
    case 0x180000000000000uLL:
      int v44 = __snprintf_chk(&a2[v50], a3 - v50, 0, 0xFFFFFFFFFFFFFFFFLL, ", inactive");
      if (v44 >= 0)
      {
        if (v44 <= a3 - v50) {
          size_t v27 = v44;
        }
        else {
          size_t v27 = a3 - v50;
        }
        size_t v28 = v27;
      }

      else
      {
        size_t v28 = 0LL;
      }

      v50 += v28;
      break;
    case 0x100000000000000uLL:
      int v43 = __snprintf_chk(&a2[v50], a3 - v50, 0, 0xFFFFFFFFFFFFFFFFLL, ", activated");
      if (v43 >= 0)
      {
        if (v43 <= a3 - v50) {
          size_t v25 = v43;
        }
        else {
          size_t v25 = a3 - v50;
        }
        size_t v26 = v25;
      }

      else
      {
        size_t v26 = 0LL;
      }

      v50 += v26;
      break;
    case 0x80000000000000uLL:
      int v42 = __snprintf_chk(&a2[v50], a3 - v50, 0, 0xFFFFFFFFFFFFFFFFLL, ", activating");
      if (v42 >= 0)
      {
        if (v42 <= a3 - v50) {
          size_t v23 = v42;
        }
        else {
          size_t v23 = a3 - v50;
        }
        size_t v24 = v23;
      }

      else
      {
        size_t v24 = 0LL;
      }

      v50 += v24;
      break;
  }

  if ((v48 & 0x4000000001LL) != 0)
  {
    int v41 = __snprintf_chk(&a2[v50], a3 - v50, 0, 0xFFFFFFFFFFFFFFFFLL, ", enqueued");
    if (v41 >= 0)
    {
      if (v41 <= a3 - v50) {
        size_t v21 = v41;
      }
      else {
        size_t v21 = a3 - v50;
      }
      size_t v22 = v21;
    }

    else
    {
      size_t v22 = 0LL;
    }

    v50 += v22;
  }

  if ((v48 & 0x8000000000LL) != 0)
  {
    int v40 = __snprintf_chk(&a2[v50], a3 - v50, 0, 0xFFFFFFFFFFFFFFFFLL, ", dirty");
    if (v40 >= 0)
    {
      if (v40 <= a3 - v50) {
        size_t v19 = v40;
      }
      else {
        size_t v19 = a3 - v50;
      }
      size_t v20 = v19;
    }

    else
    {
      size_t v20 = 0LL;
    }

    v50 += v20;
  }

  int v39 = (v48 & 0x700000000LL) >> 32;
  if (v39)
  {
    int v38 = __snprintf_chk(&a2[v50], a3 - v50, 0, 0xFFFFFFFFFFFFFFFFLL, ", max qos %d", v39);
    if (v38 >= 0)
    {
      if (v38 <= a3 - v50) {
        size_t v17 = v38;
      }
      else {
        size_t v17 = a3 - v50;
      }
      size_t v18 = v17;
    }

    else
    {
      size_t v18 = 0LL;
    }

    v50 += v18;
  }

  if ((v48 & 0xFFFFFFFC) != 0) {
    int v57 = v48 | 3;
  }
  else {
    int v57 = 0;
  }
  if (v57 && ((*(_DWORD *)(a1 + 80) & 0x40000) == 0 || (*(_DWORD *)(a1 + 80) & 0x1000000) != 0))
  {
    int v37 = __snprintf_chk(&a2[v50], a3 - v50, 0, 0xFFFFFFFFFFFFFFFFLL, ", draining on 0x%x", v57);
    if (v37 >= 0)
    {
      if (v37 <= a3 - v50) {
        size_t v15 = v37;
      }
      else {
        size_t v15 = a3 - v50;
      }
      size_t v16 = v15;
    }

    else
    {
      size_t v16 = 0LL;
    }

    v50 += v16;
  }

  if ((v48 & 0x40000000000000LL) != 0)
  {
    int v36 = __snprintf_chk(&a2[v50], a3 - v50, 0, 0xFFFFFFFFFFFFFFFFLL, ", in-barrier");
    if (v36 >= 0)
    {
      if (v36 <= a3 - v50) {
        size_t v13 = v36;
      }
      else {
        size_t v13 = a3 - v50;
      }
      size_t v14 = v13;
    }

    else
    {
      size_t v14 = 0LL;
    }

    size_t v51 = v50 + v14;
  }

  else
  {
    size_t v11 = &a2[v50];
    size_t v12 = a3 - v50;
    unsigned __int16 v56 = *(_WORD *)(a1 + 80);
    int v55 = (v48 & 0x3FFE0000000000LL) >> 41;
    if ((v48 & 0x10000000000LL) != 0) {
      int v3 = __snprintf_chk(v11, v12, 0, 0xFFFFFFFFFFFFFFFFLL, ", in-flight = %d", v55 - (4096 - v56) - (v56 - 1));
    }
    else {
      int v3 = __snprintf_chk(v11, v12, 0, 0xFFFFFFFFFFFFFFFFLL, ", in-flight = %d", v55 - (4096 - v56));
    }
    if (v3 >= 0)
    {
      if (v3 <= a3 - v50) {
        size_t v9 = v3;
      }
      else {
        size_t v9 = a3 - v50;
      }
      size_t v10 = v9;
    }

    else
    {
      size_t v10 = 0LL;
    }

    size_t v51 = v50 + v10;
  }

  if ((v48 & 0x10000000000LL) != 0)
  {
    int v35 = __snprintf_chk(&a2[v51], a3 - v51, 0, 0xFFFFFFFFFFFFFFFFLL, ", pending-barrier");
    if (v35 >= 0)
    {
      if (v35 <= a3 - v51) {
        size_t v7 = v35;
      }
      else {
        size_t v7 = a3 - v51;
      }
      size_t v8 = v7;
    }

    else
    {
      size_t v8 = 0LL;
    }

    v51 += v8;
  }

  if ((*(_DWORD *)(a1 + 80) & 0x40000) != 0 && (*(_DWORD *)(a1 + 80) & 0x1000000) == 0)
  {
    int v34 = __snprintf_chk(&a2[v51], a3 - v51, 0, 0xFFFFFFFFFFFFFFFFLL, ", thread = 0x%x ", v57);
    if (v34 >= 0)
    {
      if (v34 <= a3 - v51) {
        size_t v5 = v34;
      }
      else {
        size_t v5 = a3 - v51;
      }
      size_t v6 = v5;
    }

    else
    {
      size_t v6 = 0LL;
    }

    v51 += v6;
  }

  return v51;
}

size_t _dispatch_queue_debug(const char **a1, char *a2, size_t a3)
{
  if (a1[9]) {
    int v3 = __snprintf_chk(a2, a3, 0, 0xFFFFFFFFFFFFFFFFLL, "%s[%p] = { ", a1[9], a1);
  }
  else {
    int v3 = __snprintf_chk(a2, a3, 0, 0xFFFFFFFFFFFFFFFFLL, "%s[%p] = { ", *((const char **)*a1 + 3), a1);
  }
  if (v3 >= 0)
  {
    if (v3 <= a3) {
      size_t v7 = v3;
    }
    else {
      size_t v7 = a3;
    }
    size_t v8 = v7;
  }

  else
  {
    size_t v8 = 0LL;
  }

  size_t v11 = v8 + _dispatch_object_debug_attr((uint64_t)a1, &a2[v8], a3 - v8);
  size_t v12 = v11 + _dispatch_queue_debug_attr((uint64_t)a1, &a2[v11], a3 - v11);
  int v9 = __snprintf_chk(&a2[v12], a3 - v12, 0, 0xFFFFFFFFFFFFFFFFLL, "}");
  if (v9 >= 0)
  {
    if (v9 <= a3 - v12) {
      size_t v5 = v9;
    }
    else {
      size_t v5 = a3 - v12;
    }
    size_t v6 = v5;
  }

  else
  {
    size_t v6 = 0LL;
  }

  return v12 + v6;
}

size_t _dispatch_channel_debug(_DWORD *a1, char *a2, size_t a3)
{
  int v16 = a1[20];
  int v12 = __snprintf_chk(a2, a3, 0, 0xFFFFFFFFFFFFFFFFLL, "%s[%p] = { ", *(const char **)(*(void *)a1 + 24LL), a1);
  if (v12 >= 0)
  {
    if (v12 <= a3) {
      size_t v9 = v12;
    }
    else {
      size_t v9 = a3;
    }
    size_t v10 = v9;
  }

  else
  {
    size_t v10 = 0LL;
  }

  size_t v14 = v10 + _dispatch_object_debug_attr((uint64_t)a1, &a2[v10], a3 - v10);
  size_t v15 = v14 + _dispatch_queue_debug_attr((uint64_t)a1, &a2[v14], a3 - v14);
  if ((v16 & 0x10000000) != 0) {
    int v3 = "cancelled, ";
  }
  else {
    int v3 = "";
  }
  if ((v16 & 0x40000000) != 0) {
    size_t v4 = "needs-event, ";
  }
  else {
    size_t v4 = "";
  }
  size_t v5 = "deleted, ";
  if (v16 >= 0) {
    size_t v5 = "";
  }
  int v11 = __snprintf_chk(a2, a3, 0, 0xFFFFFFFFFFFFFFFFLL, "%s%s%s", v3, v4, v5);
  if (v11 >= 0)
  {
    if (v11 <= a3) {
      size_t v7 = v11;
    }
    else {
      size_t v7 = a3;
    }
    size_t v8 = v7;
  }

  else
  {
    size_t v8 = 0LL;
  }

  return v15 + v8;
}

size_t _dispatch_source_debug(void *a1, char *a2, size_t a3)
{
  size_t v14 = (const char ***)a1[11];
  int v10 = __snprintf_chk(a2, a3, 0, 0xFFFFFFFFFFFFFFFFLL, "%s[%p] = { ", *(const char **)(*a1 + 24LL), a1);
  if (v10 >= 0)
  {
    if (v10 <= a3) {
      size_t v7 = v10;
    }
    else {
      size_t v7 = a3;
    }
    size_t v8 = v7;
  }

  else
  {
    size_t v8 = 0LL;
  }

  size_t v12 = v8 + _dispatch_object_debug_attr((uint64_t)a1, &a2[v8], a3 - v8);
  size_t v13 = v12 + _dispatch_source_debug_attr((uint64_t)a1, &a2[v12], a3 - v12);
  if ((*((_BYTE *)v14 + 29) & 2) != 0) {
    v13 += _dispatch_timer_debug_attr((uint64_t)a1, &a2[v13], a3 - v13);
  }
  if ((*((_BYTE *)v14 + 29) & 1) != 0) {
    int v3 = " (direct)";
  }
  else {
    int v3 = "";
  }
  int v9 = __snprintf_chk(&a2[v13], a3 - v13, 0, 0xFFFFFFFFFFFFFFFFLL, "kevent = %p%s, filter = %s }", v14, v3, **v14);
  if (v9 >= 0)
  {
    if (v9 <= a3 - v13) {
      size_t v5 = v9;
    }
    else {
      size_t v5 = a3 - v13;
    }
    size_t v6 = v5;
  }

  else
  {
    size_t v6 = 0LL;
  }

  return v13 + v6;
}

unint64_t _dispatch_source_debug_attr(uint64_t a1, char *a2, size_t a3)
{
  uint64_t v27 = a1;
  size_t v26 = a2;
  size_t v25 = a3;
  size_t v24 = 0LL;
  size_t v24 = *(void **)(a1 + 24);
  uint64_t v23 = 0LL;
  uint64_t v23 = *(void *)(a1 + 88);
  int v22 = 0;
  uint64_t v21 = a1;
  uint64_t v31 = a1;
  int v30 = 0;
  int v29 = *(_DWORD *)(a1 + 80);
  int v30 = v29;
  int v28 = v29;
  int v22 = v29;
  uint64_t v20 = 0LL;
  uint64_t v19 = v23;
  uint64_t v35 = v23;
  uint64_t v34 = 0LL;
  uint64_t v33 = *(void *)(v23 + 16);
  uint64_t v34 = v33;
  uint64_t v32 = v33;
  uint64_t v20 = v33;
  unint64_t v18 = a3;
  int v17 = 0;
  size_t v15 = a2;
  size_t v16 = a3;
  if (v24 && v24[9]) {
    size_t v14 = (const char *)v24[9];
  }
  else {
    size_t v14 = "";
  }
  int v3 = *(_DWORD *)(v23 + 24);
  int v4 = *(_DWORD *)(v23 + 32);
  uint64_t v5 = *(void *)(v23 + 72);
  uint64_t v37 = v20;
  uint64_t v36 = v20;
  if ((v22 & 0x10000000) != 0) {
    size_t v6 = "cancelled, ";
  }
  else {
    size_t v6 = "";
  }
  if ((v22 & 0x40000000) != 0) {
    size_t v7 = "needs-event, ";
  }
  else {
    size_t v7 = "";
  }
  size_t v8 = "deleted, ";
  if (v22 >= 0) {
    size_t v8 = "";
  }
  size_t v13 = &v10;
  int v17 = __snprintf_chk( v15,  v16,  0,  0xFFFFFFFFFFFFFFFFLL,  "target = %s[%p], ident = 0x%x, mask = 0x%x, pending_data = 0x%llx, registered = %d, armed = %d, %s%s%s",  v14,  v24,  v3,  v4,  v5,  v20 != 0,  (v20 & 1) != 0,  v6,  v7,  v8);
  if (v17 < 0) {
    return 0LL;
  }
  if (v17 <= v18) {
    return v17;
  }
  else {
    return v18;
  }
}

size_t _dispatch_timer_debug_attr(uint64_t a1, char *a2, size_t a3)
{
  int v6 = __snprintf_chk( a2,  a3,  0,  0xFFFFFFFFFFFFFFFFLL,  "timer = { target = 0x%llx, deadline = 0x%llx, interval = 0x%llx, flags = 0x%x }, ",  *(void *)(*(void *)(a1 + 88) + 80LL),  *(void *)(*(void *)(a1 + 88) + 88LL),  *(void *)(*(void *)(a1 + 88) + 96LL),  *(unsigned __int8 *)(*(void *)(a1 + 88) + 30LL));
  if (v6 < 0) {
    return 0LL;
  }
  if (v6 <= a3) {
    return v6;
  }
  else {
    return a3;
  }
}

uint64_t _dispatch_mach_msg_debug(_DWORD *a1, char *a2, size_t a3)
{
  int v40 = __snprintf_chk(a2, a3, 0, 0xFFFFFFFFFFFFFFFFLL, "%s[%p] = { ", *(const char **)(*(void *)a1 + 24LL), a1);
  if (v40 >= 0)
  {
    if (v40 <= a3) {
      size_t v26 = v40;
    }
    else {
      size_t v26 = a3;
    }
    size_t v27 = v26;
  }

  else
  {
    size_t v27 = 0LL;
  }

  size_t v42 = v27 + _dispatch_object_debug_attr((uint64_t)a1, &a2[v27], a3 - v27);
  int v39 = __snprintf_chk(&a2[v42], a3 - v42, 0, 0xFFFFFFFFFFFFFFFFLL, "opts/err = 0x%x, msgh[%p] = { ", a1[12], a1 + 22);
  if (v39 >= 0)
  {
    if (v39 <= a3 - v42) {
      size_t v24 = v39;
    }
    else {
      size_t v24 = a3 - v42;
    }
    size_t v25 = v24;
  }

  else
  {
    size_t v25 = 0LL;
  }

  size_t v43 = v42 + v25;
  uint64_t msg = (_DWORD *)_dispatch_mach_msg_get_msg((uint64_t)a1);
  if (msg[5])
  {
    int v37 = __snprintf_chk(&a2[v43], a3 - v43, 0, 0xFFFFFFFFFFFFFFFFLL, "id 0x%x, ", msg[5]);
    if (v37 >= 0)
    {
      if (v37 <= a3 - v43) {
        size_t v22 = v37;
      }
      else {
        size_t v22 = a3 - v43;
      }
      size_t v23 = v22;
    }

    else
    {
      size_t v23 = 0LL;
    }

    v43 += v23;
  }

  if (msg[1])
  {
    int v36 = __snprintf_chk(&a2[v43], a3 - v43, 0, 0xFFFFFFFFFFFFFFFFLL, "size %u, ", msg[1]);
    if (v36 >= 0)
    {
      if (v36 <= a3 - v43) {
        size_t v20 = v36;
      }
      else {
        size_t v20 = a3 - v43;
      }
      size_t v21 = v20;
    }

    else
    {
      size_t v21 = 0LL;
    }

    v43 += v21;
  }

  if (*msg)
  {
    int v35 = __snprintf_chk( &a2[v43],  a3 - v43,  0,  0xFFFFFFFFFFFFFFFFLL,  "bits <l %u, r %u",  (*msg & 0x1F00u) >> 8,  *msg & 0x1F);
    if (v35 >= 0)
    {
      if (v35 <= a3 - v43) {
        size_t v18 = v35;
      }
      else {
        size_t v18 = a3 - v43;
      }
      size_t v19 = v18;
    }

    else
    {
      size_t v19 = 0LL;
    }

    size_t v44 = v43 + v19;
    if ((*msg & 0xFFE0E0E0) != 0)
    {
      int v34 = __snprintf_chk(&a2[v44], a3 - v44, 0, 0xFFFFFFFFFFFFFFFFLL, ", o 0x%x", *msg & 0xFFE0E0E0);
      if (v34 >= 0)
      {
        if (v34 <= a3 - v44) {
          size_t v16 = v34;
        }
        else {
          size_t v16 = a3 - v44;
        }
        size_t v17 = v16;
      }

      else
      {
        size_t v17 = 0LL;
      }

      v44 += v17;
    }

    int v33 = __snprintf_chk(&a2[v44], a3 - v44, 0, 0xFFFFFFFFFFFFFFFFLL, ">, ");
    if (v33 >= 0)
    {
      if (v33 <= a3 - v44) {
        size_t v14 = v33;
      }
      else {
        size_t v14 = a3 - v44;
      }
      size_t v15 = v14;
    }

    else
    {
      size_t v15 = 0LL;
    }

    size_t v43 = v44 + v15;
  }

  if (msg[3] && msg[2])
  {
    int v32 = __snprintf_chk(&a2[v43], a3 - v43, 0, 0xFFFFFFFFFFFFFFFFLL, "local 0x%x, remote 0x%x", msg[3], msg[2]);
    if (v32 >= 0)
    {
      if (v32 <= a3 - v43) {
        size_t v12 = v32;
      }
      else {
        size_t v12 = a3 - v43;
      }
      size_t v13 = v12;
    }

    else
    {
      size_t v13 = 0LL;
    }

    size_t v45 = v43 + v13;
  }

  else if (msg[3])
  {
    int v31 = __snprintf_chk(&a2[v43], a3 - v43, 0, 0xFFFFFFFFFFFFFFFFLL, "local 0x%x", msg[3]);
    if (v31 >= 0)
    {
      if (v31 <= a3 - v43) {
        size_t v10 = v31;
      }
      else {
        size_t v10 = a3 - v43;
      }
      size_t v11 = v10;
    }

    else
    {
      size_t v11 = 0LL;
    }

    size_t v45 = v43 + v11;
  }

  else if (msg[2])
  {
    int v30 = __snprintf_chk(&a2[v43], a3 - v43, 0, 0xFFFFFFFFFFFFFFFFLL, "remote 0x%x", msg[2]);
    if (v30 >= 0)
    {
      if (v30 <= a3 - v43) {
        size_t v8 = v30;
      }
      else {
        size_t v8 = a3 - v43;
      }
      size_t v9 = v8;
    }

    else
    {
      size_t v9 = 0LL;
    }

    size_t v45 = v43 + v9;
  }

  else
  {
    int v29 = __snprintf_chk(&a2[v43], a3 - v43, 0, 0xFFFFFFFFFFFFFFFFLL, "no ports");
    if (v29 >= 0)
    {
      if (v29 <= a3 - v43) {
        size_t v6 = v29;
      }
      else {
        size_t v6 = a3 - v43;
      }
      size_t v7 = v6;
    }

    else
    {
      size_t v7 = 0LL;
    }

    size_t v45 = v43 + v7;
  }

  int v28 = __snprintf_chk(&a2[v45], a3 - v45, 0, 0xFFFFFFFFFFFFFFFFLL, " } }");
  if (v28 >= 0)
  {
    if (v28 <= a3 - v45) {
      size_t v4 = v28;
    }
    else {
      size_t v4 = a3 - v45;
    }
    size_t v5 = v4;
  }

  else
  {
    size_t v5 = 0LL;
  }

  return v45 + v5;
}

size_t _dispatch_mach_debug(uint64_t a1, char *a2, size_t a3)
{
  if (!*(void *)(a1 + 72) || ((*(_WORD *)(a1 + 116) >> 3) & 1) != 0) {
    int v3 = __snprintf_chk( a2,  a3,  0,  0xFFFFFFFFFFFFFFFFLL,  "%s[%p] = { ",  *(const char **)(*(void *)a1 + 24LL),  (const void *)a1);
  }
  else {
    int v3 = __snprintf_chk(a2, a3, 0, 0xFFFFFFFFFFFFFFFFLL, "%s[%p] = { ", *(const char **)(a1 + 72), (const void *)a1);
  }
  if (v3 >= 0)
  {
    if (v3 <= a3) {
      size_t v7 = v3;
    }
    else {
      size_t v7 = a3;
    }
    size_t v8 = v7;
  }

  else
  {
    size_t v8 = 0LL;
  }

  size_t v11 = v8 + _dispatch_object_debug_attr(a1, &a2[v8], a3 - v8);
  size_t v12 = v11 + _dispatch_mach_debug_attr((void *)a1, &a2[v11], a3 - v11);
  int v9 = __snprintf_chk(&a2[v12], a3 - v12, 0, 0xFFFFFFFFFFFFFFFFLL, "}");
  if (v9 >= 0)
  {
    if (v9 <= a3 - v12) {
      size_t v5 = v9;
    }
    else {
      size_t v5 = a3 - v12;
    }
    size_t v6 = v5;
  }

  else
  {
    size_t v6 = 0LL;
  }

  return v12 + v6;
}

unint64_t _dispatch_mach_debug_attr(void *a1, char *a2, size_t a3)
{
  int v30 = a1;
  int v29 = a2;
  size_t v28 = a3;
  size_t v27 = 0LL;
  size_t v27 = (void *)a1[3];
  uint64_t v26 = 0LL;
  uint64_t v26 = a1[15];
  uint64_t v25 = 0LL;
  uint64_t v25 = a1[11];
  unint64_t v24 = a3;
  int v23 = 0;
  size_t v18 = a2;
  size_t v19 = a3;
  if (v27 && v27[9]) {
    size_t v17 = (const char *)v27[9];
  }
  else {
    size_t v17 = "";
  }
  int v3 = *(_DWORD *)(v25 + 24);
  int v4 = *(_DWORD *)(v26 + 92);
  int v5 = *(_DWORD *)(v26 + 24);
  char v22 = 0;
  char v21 = *(_BYTE *)(v26 + 30);
  char v22 = v21 & 1;
  char v20 = v21 & 1;
  if ((v21 & 1) != 0) {
    size_t v6 = " (armed)";
  }
  else {
    size_t v6 = "";
  }
  int v7 = *(_DWORD *)(v26 + 96);
  if (*(void *)(v26 + 48)) {
    size_t v8 = " (pending)";
  }
  else {
    size_t v8 = "";
  }
  uint64_t v9 = *(void *)(v26 + 64);
  int v10 = *(_DWORD *)(v26 + 88);
  BOOL v11 = (v30[10] & 0x10000000) != 0;
  size_t v16 = &v13;
  int v23 = __snprintf_chk( v18,  v19,  0,  0xFFFFFFFFFFFFFFFFLL,  "target = %s[%p], receive = 0x%x, send = 0x%x, send-possible = 0x%x%s, checkin = 0x%x%s, send state = %016llx, disconnected = %d, canceled = %d ",  v17,  v27,  v3,  v4,  v5,  v6,  v7,  v8,  v9,  v10,  v11);
  if (v23 < 0) {
    return 0LL;
  }
  if (v23 <= v24) {
    return v23;
  }
  else {
    return v24;
  }
}

unint64_t voucher_kvoucher_debug( ipc_space_read_t a1, mach_port_name_t a2, uint64_t a3, unint64_t a4, unint64_t a5, const char *a6, unint64_t a7)
{
  kern_return_t error_value;
  unsigned int object_type;
  unsigned int object_addr;
  mach_msg_type_number_t recipesCnt[2];
  unint64_t v49;
  const char *v50;
  unint64_t v51;
  unint64_t v52;
  uint64_t v53;
  mach_port_name_t name;
  ipc_space_read_t task;
  uint8_t recipes[8192];
  tasint k = a1;
  mach_port_name_t name = a2;
  BOOL v53 = a3;
  uint64_t v52 = a4;
  size_t v51 = a5;
  size_t v50 = a6;
  uint64_t v49 = a7;
  bzero(recipes, 0x2000uLL);
  *(void *)recipesCnt = 0x2000LL;
  object_addr = 0;
  object_type = 0;
  if (mach_port_kernel_object(task, name, &object_type, &object_addr) || object_type != 37)
  {
    if (v50)
    {
      if (v52 <= v51) {
        size_t v14 = 0LL;
      }
      else {
        size_t v14 = v52 - v51;
      }
      int v36 = __snprintf_chk((char *)(v53 + v51), v14, 0, 0xFFFFFFFFFFFFFFFFLL, "%s", v50);
      if (v36 >= 0)
      {
        if (v36 <= v14) {
          size_t v12 = v36;
        }
        else {
          size_t v12 = v14;
        }
        size_t v13 = v12;
      }

      else
      {
        size_t v13 = 0LL;
      }

      v51 += v13;
    }

    if (v52 <= v51) {
      size_t v11 = 0LL;
    }
    else {
      size_t v11 = v52 - v51;
    }
    int v35 = __snprintf_chk((char *)(v53 + v51), v11, 0, 0xFFFFFFFFFFFFFFFFLL, "Invalid voucher: 0x%x\n", name);
    if (v35 >= 0)
    {
      if (v35 <= v11) {
        size_t v9 = v35;
      }
      else {
        size_t v9 = v11;
      }
      size_t v10 = v9;
    }

    else
    {
      size_t v10 = 0LL;
    }

    v51 += v10;
  }

  else
  {
    mach_error_t error_value = mach_voucher_debug_info(task, name, recipes, recipesCnt);
    if (!error_value || error_value == 46)
    {
      if (*(void *)recipesCnt)
      {
        if (v50)
        {
          if (v52 <= v51) {
            size_t v20 = 0LL;
          }
          else {
            size_t v20 = v52 - v51;
          }
          int v40 = __snprintf_chk((char *)(v53 + v51), v20, 0, 0xFFFFFFFFFFFFFFFFLL, "%s", v50);
          if (v40 >= 0)
          {
            if (v40 <= v20) {
              size_t v18 = v40;
            }
            else {
              size_t v18 = v20;
            }
            size_t v19 = v18;
          }

          else
          {
            size_t v19 = 0LL;
          }

          v51 += v19;
        }

        if (v52 <= v51) {
          size_t v17 = 0LL;
        }
        else {
          size_t v17 = v52 - v51;
        }
        int v39 = __snprintf_chk((char *)(v53 + v51), v17, 0, 0xFFFFFFFFFFFFFFFFLL, "Voucher: 0x%x\n", object_addr);
        if (v39 >= 0)
        {
          if (v39 <= v17) {
            size_t v15 = v39;
          }
          else {
            size_t v15 = v17;
          }
          size_t v16 = v15;
        }

        else
        {
          size_t v16 = 0LL;
        }

        v51 += v16;
        for (unsigned int i = 0; *(void *)recipesCnt > (unint64_t)i; i += *((_DWORD *)v37 + 3) + 16)
        {
          int v37 = &recipes[i];
          if (*(_DWORD *)v37) {
            size_t v51 = format_recipe_detail((uint64_t)v37, v53, v52, v51, v50, v49);
          }
        }
      }

      else
      {
        if (v50)
        {
          if (v52 <= v51) {
            size_t v26 = 0LL;
          }
          else {
            size_t v26 = v52 - v51;
          }
          int v42 = __snprintf_chk((char *)(v53 + v51), v26, 0, 0xFFFFFFFFFFFFFFFFLL, "%s", v50);
          if (v42 >= 0)
          {
            if (v42 <= v26) {
              size_t v24 = v42;
            }
            else {
              size_t v24 = v26;
            }
            size_t v25 = v24;
          }

          else
          {
            size_t v25 = 0LL;
          }

          v51 += v25;
        }

        if (v52 <= v51) {
          size_t v23 = 0LL;
        }
        else {
          size_t v23 = v52 - v51;
        }
        int v41 = __snprintf_chk( (char *)(v53 + v51),  v23,  0,  0xFFFFFFFFFFFFFFFFLL,  "Voucher: 0x%x has no contents\n",  object_addr);
        if (v41 >= 0)
        {
          if (v41 <= v23) {
            size_t v21 = v41;
          }
          else {
            size_t v21 = v23;
          }
          size_t v22 = v21;
        }

        else
        {
          size_t v22 = 0LL;
        }

        v51 += v22;
      }
    }

    else
    {
      if (v50)
      {
        if (v52 <= v51) {
          size_t v34 = 0LL;
        }
        else {
          size_t v34 = v52 - v51;
        }
        int v44 = __snprintf_chk((char *)(v53 + v51), v34, 0, 0xFFFFFFFFFFFFFFFFLL, "%s", v50);
        if (v44 >= 0)
        {
          if (v44 <= v34) {
            size_t v32 = v44;
          }
          else {
            size_t v32 = v34;
          }
          size_t v33 = v32;
        }

        else
        {
          size_t v33 = 0LL;
        }

        v51 += v33;
      }

      if (v52 <= v51) {
        size_t v31 = 0LL;
      }
      else {
        size_t v31 = v52 - v51;
      }
      int v30 = (char *)(v53 + v51);
      unsigned int v29 = object_addr;
      int v7 = mach_error_string(error_value);
      int v43 = __snprintf_chk(v30, v31, 0, 0xFFFFFFFFFFFFFFFFLL, "Voucher: 0x%x Failed to get contents %s\n", v29, v7);
      if (v43 >= 0)
      {
        if (v43 <= v31) {
          size_t v27 = v43;
        }
        else {
          size_t v27 = v31;
        }
        size_t v28 = v27;
      }

      else
      {
        size_t v28 = 0LL;
      }

      v51 += v28;
    }
  }

  return v51;
}

size_t _dispatch_io_debug(const void *a1, char *a2, size_t a3)
{
  int v9 = __snprintf_chk(a2, a3, 0, 0xFFFFFFFFFFFFFFFFLL, "%s[%p] = { ", *(const char **)(*(void *)a1 + 24LL), a1);
  if (v9 >= 0)
  {
    if (v9 <= a3) {
      size_t v6 = v9;
    }
    else {
      size_t v6 = a3;
    }
    size_t v7 = v6;
  }

  else
  {
    size_t v7 = 0LL;
  }

  size_t v11 = v7 + _dispatch_object_debug_attr((uint64_t)a1, &a2[v7], a3 - v7);
  size_t v12 = v11 + _dispatch_io_debug_attr((uint64_t)a1, &a2[v11], a3 - v11);
  int v8 = __snprintf_chk(&a2[v12], a3 - v12, 0, 0xFFFFFFFFFFFFFFFFLL, "}");
  if (v8 >= 0)
  {
    if (v8 <= a3 - v12) {
      size_t v4 = v8;
    }
    else {
      size_t v4 = a3 - v12;
    }
    size_t v5 = v4;
  }

  else
  {
    size_t v5 = 0LL;
  }

  return v12 + v5;
}

unint64_t _dispatch_io_debug_attr(uint64_t a1, char *a2, size_t a3)
{
  uint64_t v31 = a1;
  int v30 = a2;
  size_t v29 = a3;
  size_t v28 = 0LL;
  size_t v28 = *(void **)(a1 + 24);
  unint64_t v27 = a3;
  int v26 = 0;
  size_t v22 = a2;
  size_t v23 = a3;
  int v3 = "stream";
  if (*(void *)(a1 + 72)) {
    int v3 = "random";
  }
  size_t v24 = v3;
  uint64_t v25 = *(int *)(v31 + 128);
  if ((*(_DWORD *)(v31 + 120) & 2) != 0)
  {
    size_t v21 = "stopped, ";
  }

  else
  {
    size_t v4 = "closed, ";
    if ((*(_DWORD *)(v31 + 120) & 1) == 0) {
      size_t v4 = "";
    }
    size_t v21 = v4;
  }

  size_t v18 = v21;
  size_t v19 = *(const void **)(v31 + 112);
  size_t v20 = *(const void **)(v31 + 48);
  if (v28 && v28[9]) {
    size_t v17 = (const char *)v28[9];
  }
  else {
    size_t v17 = "";
  }
  size_t v5 = *(const void **)(v31 + 56);
  size_t v6 = *(const void **)(v31 + 64);
  int v7 = *(_DWORD *)(v31 + 144);
  uint64_t v8 = *(void *)(v31 + 80);
  uint64_t v9 = *(void *)(v31 + 88);
  if ((*(void *)(v31 + 104) & 1LL) != 0) {
    size_t v10 = "(strict)";
  }
  else {
    size_t v10 = "";
  }
  uint64_t v11 = *(void *)(v31 + 96);
  size_t v16 = &v13;
  int v26 = __snprintf_chk( v22,  v23,  0,  0xFFFFFFFFFFFFFFFFLL,  "type = %s, fd = 0x%lx, %sfd_entry = %p, queue = %p, target = %s[%p], barrier_queue = %p, barrier_group = %p, e rr = 0x%x, low = 0x%zx, high = 0x%zx, interval%s = %llu ",  v24,  v25,  v18,  v19,  v20,  v17,  v28,  v5,  v6,  v7,  v8,  v9,  v10,  v11);
  if (v26 < 0) {
    return 0LL;
  }
  if (v26 <= v27) {
    return v26;
  }
  else {
    return v27;
  }
}

size_t _dispatch_operation_debug(const void *a1, char *a2, size_t a3)
{
  int v9 = __snprintf_chk(a2, a3, 0, 0xFFFFFFFFFFFFFFFFLL, "%s[%p] = { ", *(const char **)(*(void *)a1 + 24LL), a1);
  if (v9 >= 0)
  {
    if (v9 <= a3) {
      size_t v6 = v9;
    }
    else {
      size_t v6 = a3;
    }
    size_t v7 = v6;
  }

  else
  {
    size_t v7 = 0LL;
  }

  size_t v11 = v7 + _dispatch_object_debug_attr((uint64_t)a1, &a2[v7], a3 - v7);
  size_t v12 = v11 + _dispatch_operation_debug_attr((uint64_t)a1, &a2[v11], a3 - v11);
  int v8 = __snprintf_chk(&a2[v12], a3 - v12, 0, 0xFFFFFFFFFFFFFFFFLL, "}");
  if (v8 >= 0)
  {
    if (v8 <= a3 - v12) {
      size_t v4 = v8;
    }
    else {
      size_t v4 = a3 - v12;
    }
    size_t v5 = v4;
  }

  else
  {
    size_t v5 = 0LL;
  }

  return v12 + v5;
}

unint64_t _dispatch_operation_debug_attr(uint64_t a1, char *a2, size_t a3)
{
  uint64_t v40 = a1;
  int v39 = a2;
  size_t v38 = a3;
  int v37 = 0LL;
  int v37 = *(void **)(a1 + 24);
  int v36 = 0LL;
  if (*(void *)(a1 + 48)) {
    size_t v33 = *(void **)(*(void *)(v40 + 48) + 24LL);
  }
  else {
    size_t v33 = 0LL;
  }
  int v36 = v33;
  unint64_t v35 = v38;
  int v34 = 0;
  size_t v29 = v39;
  size_t v30 = v38;
  int v3 = "stream";
  if (*(void *)(v40 + 64)) {
    int v3 = "random";
  }
  uint64_t v31 = v3;
  size_t v4 = "read";
  if (*(_DWORD *)(v40 + 56)) {
    size_t v4 = "write";
  }
  size_t v32 = v4;
  if (*(void *)(v40 + 144)) {
    int v28 = **(_DWORD **)(v40 + 144);
  }
  else {
    int v28 = -1;
  }
  uint64_t v24 = v28;
  uint64_t v25 = *(const void **)(v40 + 144);
  int v26 = *(const void **)(v40 + 136);
  unint64_t v27 = *(const void **)(v40 + 48);
  if (v36 && v36[9]) {
    size_t v23 = (const char *)v36[9];
  }
  else {
    size_t v23 = "";
  }
  size_t v21 = v23;
  size_t v22 = v36;
  if (v37 && v37[9]) {
    size_t v20 = (const char *)v37[9];
  }
  else {
    size_t v20 = "";
  }
  uint64_t v5 = *(void *)(v40 + 104);
  uint64_t v6 = *(void *)(v40 + 112);
  uint64_t v7 = *(void *)(v40 + 216);
  uint64_t v8 = *(void *)(v40 + 208) + *(void *)(v40 + 200);
  int v9 = *(_DWORD *)(v40 + 184);
  int v10 = *(_DWORD *)(v40 + 120);
  uint64_t v11 = *(void *)(v40 + 72);
  uint64_t v12 = *(void *)(v40 + 80);
  if ((*(void *)(v40 + 96) & 1LL) != 0) {
    uint64_t v13 = "(strict)";
  }
  else {
    uint64_t v13 = "";
  }
  uint64_t v14 = *(void *)(v40 + 88);
  size_t v19 = &v16;
  int v34 = __snprintf_chk( v29,  v30,  0,  0xFFFFFFFFFFFFFFFFLL,  "type = %s %s, fd = 0x%lx, fd_entry = %p, channel = %p, queue = %p -> %s[%p], target = %s[%p], offset = %lld, l ength = %zu, done = %zu, undelivered = %zu, flags = %u, err = 0x%x, low = 0x%zx, high = 0x%zx, interval%s = %llu ",  v31,  v32,  v24,  v25,  v26,  v27,  v21,  v22,  v20,  v37,  v5,  v6,  v7,  v8,  v9,  v10,  v11,  v12,  v13,  v14);
  if (v34 < 0) {
    return 0LL;
  }
  if (v34 <= v35) {
    return v34;
  }
  else {
    return v35;
  }
}

size_t _dispatch_data_debug(uint64_t a1, char *a2, size_t a3)
{
  int v27 = __snprintf_chk(a2, a3, 0, 0xFFFFFFFFFFFFFFFFLL, "data[%p] = { ", (const void *)a1);
  if (v27 >= 0)
  {
    if (v27 <= a3) {
      size_t v20 = v27;
    }
    else {
      size_t v20 = a3;
    }
    size_t v21 = v20;
  }

  else
  {
    size_t v21 = 0LL;
  }

  if (*(void *)(a1 + 72))
  {
    uint64_t v14 = &a2[v21];
    size_t v15 = a3 - v21;
    uint64_t v16 = *(void *)(a1 + 64);
    uint64_t v17 = *(void *)(a1 + 72);
    if (v17) {
      int v3 = __snprintf_chk(v14, v15, 0, 0xFFFFFFFFFFFFFFFFLL, "composite, size = %zd, num_records = %zd ", v16, v17);
    }
    else {
      int v3 = __snprintf_chk(v14, v15, 0, 0xFFFFFFFFFFFFFFFFLL, "composite, size = %zd, num_records = %zd ", v16, 1uLL);
    }
    if (v3 >= 0)
    {
      if (v3 <= a3 - v21) {
        size_t v12 = v3;
      }
      else {
        size_t v12 = a3 - v21;
      }
      size_t v13 = v12;
    }

    else
    {
      size_t v13 = 0LL;
    }

    size_t v29 = v21 + v13;
    if (*(void *)(a1 + 48))
    {
      int v25 = __snprintf_chk(&a2[v29], a3 - v29, 0, 0xFFFFFFFFFFFFFFFFLL, ", flatbuf = %p ", *(const void **)(a1 + 48));
      if (v25 >= 0)
      {
        if (v25 <= a3 - v29) {
          size_t v10 = v25;
        }
        else {
          size_t v10 = a3 - v29;
        }
        size_t v11 = v10;
      }

      else
      {
        size_t v11 = 0LL;
      }

      v29 += v11;
    }

    for (unint64_t i = 0LL; ; ++i)
    {
      unint64_t v9 = *(void *)(a1 + 72) ? *(void *)(a1 + 72) : 1LL;
      if (i >= v9) {
        break;
      }
      int v23 = __snprintf_chk( &a2[v29],  a3 - v29,  0,  0xFFFFFFFFFFFFFFFFLL,  "record[%zd] = { from = %zd, length = %zd, data_object = %p }, ",  i,  *(void *)(a1 + 80 + 24 * i + 8),  *(void *)(a1 + 80 + 24 * i + 16),  *(const void **)(a1 + 80 + 24 * i));
      if (v23 >= 0)
      {
        if (v23 <= a3 - v29) {
          size_t v7 = v23;
        }
        else {
          size_t v7 = a3 - v29;
        }
        size_t v8 = v7;
      }

      else
      {
        size_t v8 = 0LL;
      }

      v29 += v8;
    }
  }

  else
  {
    int v26 = __snprintf_chk( &a2[v21],  a3 - v21,  0,  0xFFFFFFFFFFFFFFFFLL,  "leaf, size = %zd, buf = %p ",  *(void *)(a1 + 64),  *(const void **)(a1 + 48));
    if (v26 >= 0)
    {
      if (v26 <= a3 - v21) {
        size_t v18 = v26;
      }
      else {
        size_t v18 = a3 - v21;
      }
      size_t v19 = v18;
    }

    else
    {
      size_t v19 = 0LL;
    }

    size_t v29 = v21 + v19;
  }

  int v22 = __snprintf_chk(&a2[v29], a3 - v29, 0, 0xFFFFFFFFFFFFFFFFLL, "}");
  if (v22 >= 0)
  {
    if (v22 <= a3 - v29) {
      size_t v5 = v22;
    }
    else {
      size_t v5 = a3 - v29;
    }
    size_t v6 = v5;
  }

  else
  {
    size_t v6 = 0LL;
  }

  return v29 + v6;
}