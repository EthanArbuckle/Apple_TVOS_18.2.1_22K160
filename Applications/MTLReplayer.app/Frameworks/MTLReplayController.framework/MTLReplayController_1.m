id GTUSCSamplingStreamingManagerHelper::ResetSourceForPostProcessing(id *this)
{
  id result;
  uint64_t v3;
  unsigned int v4;
  void *v5;
  result = [this[3] count];
  if (result)
  {
    v3 = 0LL;
    v4 = 1;
    do
    {
      v5 = (void *)objc_claimAutoreleasedReturnValue([this[3] objectAtIndexedSubscript:v3]);
      [v5 resetRawDataPostProcessor];

      v3 = v4;
      result = [this[3] count];
    }

    while ((unint64_t)result > v4++);
  }

  return result;
}

void sub_5D978(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t GTUSCSamplingStreamingManagerHelper::SetupSourceForDerivedCounters( id *this, NSDictionary *a2, unsigned int a3, int a4, int a5)
{
  v46 = a2;
  v9 = (void *)objc_claimAutoreleasedReturnValue([this[2] firstObject]);
  if (!v9)
  {
    uint64_t v15 = 0LL;
    goto LABEL_39;
  }

  if (!a3)
  {
    if ((a4 & 1) != 0 || GTAGXPerfStateControl::IsGPUPerformanceStateInduced((GTAGXPerfStateControl *)(this + 5)))
    {
      v10 = (void *)objc_claimAutoreleasedReturnValue([this[2] firstObject]);
      [v10 setOptions:&off_59FC00];
LABEL_6:

      goto LABEL_7;
    }

    uint64_t v36 = *((unsigned int *)*this + 18);
    if ((_DWORD)v36)
    {
      GTAGXPerfStateControl::EnableConsistentGPUPerfState((uint64_t)(this + 5), v36);
      id v37 = GTApplePMPPerfStateControl::EnableConsistentPerfState( (GTApplePMPPerfStateControl *)(this + 8),  (*((_DWORD *)*this + 18) - 1));
      uint64_t v38 = objc_claimAutoreleasedReturnValue(v37);
      id v39 = this[261];
      this[261] = (id)v38;

      v10 = (void *)objc_claimAutoreleasedReturnValue([this[2] firstObject]);
      [v10 setOptions:&off_59FBD8];
      goto LABEL_6;
    }

    id v40 = GTApplePMPPerfStateControl::EnableConsistentPerfState((GTApplePMPPerfStateControl *)(this + 8), 1LL);
    uint64_t v41 = objc_claimAutoreleasedReturnValue(v40);
    id v42 = this[261];
    this[261] = (id)v41;

    v52[0] = @"DisableOverlap";
    v52[1] = @"LockGPUPerfState";
    v53[0] = &__kCFBooleanTrue;
    v43 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedInt:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedInt:",  *((unsigned int *)*this + 17)));
    v53[1] = v43;
    v44 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v53,  v52,  2LL));
    v45 = (void *)objc_claimAutoreleasedReturnValue([this[2] firstObject]);
    [v45 setOptions:v44];
  }

void sub_5DE84( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  _Unwind_Resume(a1);
}

void GTUSCSamplingStreamingManagerHelper::ReplaySingleFrameForUSCSampling( uint64_t a1, void *a2, uint64_t *a3, void **a4, void *a5)
{
  v6 = a5;
  v84 = (void *)objc_claimAutoreleasedReturnValue( [*(id *)(*(void *)a1 + 16) objectForKeyedSubscript:@"perEncoderDrawCallCount"]);
  uint64_t v7 = **(void **)a1;
  id v8 = *(id *)(v7 + 8);
  uint64_t v95 = v7;
  v9 = *(void **)v7;
  uint64_t v10 = v9[2];
  v11 = (void *)objc_claimAutoreleasedReturnValue([v8 defaultDevice]);
  id v12 = [v11 newEvent];

  std::vector<std::pair<unsigned long long,unsigned long long>>::reserve(a4, *(void *)(a1 + 2272));
  id v13 = (void *)objc_claimAutoreleasedReturnValue([v8 defaultCommandQueue]);
  v14 = (void *)objc_claimAutoreleasedReturnValue([v13 commandBuffer]);
  uint64_t v94 = v10;
  v97 = v8;
  v83 = v6;

  v90 = v12;
  [v14 encodeSignalEvent:v12 value:GTUSCSamplingStreamingManagerHelper::ReplaySingleFrameForUSCSampling(std::unordered_map<unsigned int,GTEncoderSampleIndexInfo> &,std::unordered_map<unsigned int,std::vector<GTCoalescedEncoderIndexInfo>> &,std::vector<std::pair<unsigned long long,unsigned long long>> &,NSObject *,void({block_pointer})(void))::signalCounter];
  [v14 commit];
  v77 = v14;
  uint64_t v15 = (unsigned int *)(v95 + 22480);
  unint64_t v16 = *(unsigned int *)(v95 + 22480);
  if (v9[13] + v9[12] > v16)
  {
    unsigned int v78 = 0;
    char v79 = 0;
    unsigned int v81 = 0;
    char v87 = 0;
    v89 = v9;
    while (1)
    {
      uint64_t v17 = *(unsigned int *)(v95 + 22484);
      context = objc_autoreleasePoolPush();
      unint64_t v18 = *v15;
      uint64_t v96 = *(void *)(v9[15] + 24LL);
      uint64_t v19 = v96 + (v18 << 6);
      unint64_t v20 = (int *)(v19 + 8);
      int FuncEnumConstructorType = GetFuncEnumConstructorType(*(_DWORD *)(v19 + 8));
      if (FuncEnumConstructorType == 25)
      {
        if (std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::find<unsigned long long>( (void *)(a1 + 2248),  v18))
        {
          double v21 = (void *)objc_claimAutoreleasedReturnValue([v97 defaultCommandQueue]);
          double v22 = (void *)objc_claimAutoreleasedReturnValue([v21 commandBuffer]);

          [v22 encodeWaitForEvent:v90 value:GTUSCSamplingStreamingManagerHelper::ReplaySingleFrameForUSCSampling(std::unordered_map<unsigned int,GTEncoderSampleIndexInfo> &,std::unordered_map<unsigned int,std::vector<GTCoalescedEncoderIndexInfo>> &,std::vector<std::pair<unsigned long long,unsigned long long>> &,NSObject *,void({block_pointer})(void))::signalCounter++];
          objc_msgSend(v22, "encodeSignalEvent:value:", v90);
          v99[0] = _NSConcreteStackBlock;
          v99[1] = 3221225472LL;
          v99[2] = ___ZN35GTUSCSamplingStreamingManagerHelper31ReplaySingleFrameForUSCSamplingERNSt3__113unordered_mapIj24GTEncoderSampleIndexInfoNS0_4hashIjEENS0_8equal_toIjEENS0_9allocatorINS0_4pairIKjS2_EEEEEERNS1_IjNS0_6vectorI27GTCoalescedEncoderIndexInfoNS7_ISF_EEEES4_S6_NS7_INS8_IS9_SH_EEEEEERNSE_INS8_IyyEENS7_ISM_EEEEP8NSObjectU13block_pointerFvvE_block_invoke;
          v99[3] = &__block_descriptor_40_e28_v16__0___MTLCommandBuffer__8l;
          v99[4] = a4;
          [v22 addCompletedHandler:v99];
          [v22 commit];
        }

        int v92 = GTMTLReplayController_restoreCommandBuffer(v95, v19);
      }

      else
      {
        int v92 = 0;
      }

      GTMTLReplayController_updateCommandEncoder(v95, v19);
      uint64_t v23 = v16 | (v17 << 32);
      if (*(_DWORD *)(a1 + 2176) == -1) {
        goto LABEL_25;
      }
      int v24 = *v20;
      if ((IsFuncEnumDrawCall(*v20) & 1) != 0) {
        break;
      }
      if (v24 <= -16138)
      {
        BOOL v26 = v24 == -16327;
        int v27 = -16220;
      }

      else
      {
        BOOL v25 = (v24 + 16137) > 0x3B || ((1LL << (v24 + 9)) & 0xC00000000000001LL) == 0;
        BOOL v26 = !v25 || v24 == -15486;
        int v27 = -15297;
      }

      BOOL v28 = v26 || v24 == v27;
      if (IsFuncEnumSampledBlitCall(v24) || IsFuncEnumSampledBlitCallAGX(v24))
      {
        objc_msgSend( *(id *)(a1 + 1944),  "addSampledCallFunctionIndex:forIndex:forEncoder:atEncoderIndex:forType:",  v23,  v78++,  v81,  (*(_DWORD *)(a1 + 1928) - 1),  @"Blit",  v76);
        goto LABEL_25;
      }

LABEL_58:
              if (v24 >> 2 == 1073737833) {
                GTUSCSamplingStreamingManagerHelper::DispatchExpandedIndirectCommand( a1,  v95,  (unint64_t *)v19,  0LL,  0LL);
              }
              else {
                GTMTLReplayController_dispatchForUSCSampling( v95,  v19,  v97,  v94,  *(void **)(a1 + 1944),  (*(_DWORD *)(a1 + 1928) - 1));
              }
              goto LABEL_80;
            }

              if (++v26 == v25) {
                goto LABEL_62;
              }
            }

            std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long>>>::__emplace_unique_key_args<unsigned long long,unsigned long long &,unsigned long &>( (uint64_t)__x,  Offset,  Offset,  SizeInBytes);
LABEL_34:
            unsigned int v31 = *((void *)v27 + 2) - *((void *)v27 + 1);
            v33 = (char *)*((void *)v3 + 1);
            uint64_t v32 = *((void *)v3 + 2);
            if ((unint64_t)v33 < v32)
            {
              *(void *)v33 = Offset;
              *((void *)v33 + 1) = SizeInBytes;
              *((_DWORD *)v33 + 4) = v20;
              *((_DWORD *)v33 + 5) = v31 >> 3;
              *(_OWORD *)(v33 + 24) = 0u;
              *(_OWORD *)(v33 + 40) = 0u;
              *((_DWORD *)v33 + 14) = 1065353216;
              *((void *)v33 + 9) = 0LL;
              *((void *)v33 + 10) = 0LL;
              id v34 = v33 + 88;
              *((void *)v33 + 8) = 0LL;
LABEL_57:
              *((void *)v3 + 1) = v34;
              *((_DWORD *)std::__hash_table<std::__hash_value_type<unsigned long long,unsigned int>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned int>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned int>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned int>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long const&>,std::tuple<>>( v4,  Offset,  &v270)
              + 6) = v20++;
              goto LABEL_58;
            }

            v35 = *(char **)v3;
            uint64_t v36 = 0x2E8BA2E8BA2E8BA3LL * ((uint64_t)&v33[-*(void *)v3] >> 3);
            id v37 = v36 + 1;
            v260 = v20;
            id v38 = 0x2E8BA2E8BA2E8BA3LL * ((uint64_t)(v32 - (void)v35) >> 3);
            if (2 * v38 > v37) {
              id v37 = 2 * v38;
            }
            if (v38 >= 0x1745D1745D1745DLL) {
              uint64_t v39 = 0x2E8BA2E8BA2E8BALL;
            }
            else {
              uint64_t v39 = v37;
            }
            if (v39)
            {
              if (v39 > 0x2E8BA2E8BA2E8BALL) {
                goto LABEL_342;
              }
              uint64_t v40 = v4;
              uint64_t v41 = (char *)operator new(88 * v39);
            }

            else
            {
              uint64_t v40 = v4;
              uint64_t v41 = 0LL;
            }

            id v42 = v31 >> 3;
            v43 = &v41[88 * v36];
            *(void *)v43 = Offset;
            *((void *)v43 + 1) = SizeInBytes;
            *((_DWORD *)v43 + 4) = v260;
            *((_DWORD *)v43 + 5) = v42;
            v44 = &v41[88 * v39];
            *(_OWORD *)(v43 + 24) = 0u;
            *(_OWORD *)(v43 + 40) = 0u;
            *((_DWORD *)v43 + 14) = 1065353216;
            *((void *)v43 + 9) = 0LL;
            *((void *)v43 + 10) = 0LL;
            *((void *)v43 + 8) = 0LL;
            id v34 = v43 + 88;
            if (v33 == v35)
            {
              BOOL v25 = v256;
              v3 = (char *)v259;
              *(void *)v259 = v43;
              *((void *)v259 + 1) = v34;
              *((void *)v259 + 2) = v44;
              v4 = v40;
              unint64_t v20 = v260;
              if (v33) {
                goto LABEL_55;
              }
            }

            else
            {
              uint64_t v45 = 0LL;
              do
              {
                uint64_t v46 = &v43[v45];
                id v47 = &v33[v45];
                uint64_t v48 = *(_OWORD *)&v33[v45 - 88];
                *((void *)v46 - 9) = *(void *)&v33[v45 - 72];
                *(_OWORD *)(v46 - 88) = v48;
                std::__hash_table<std::__hash_value_type<unsigned int,unsigned int>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,unsigned int>>>::__hash_table( (uint64_t)&v43[v45 - 64],  (uint64_t *)&v33[v45 - 64]);
                *((void *)v46 - 3) = 0LL;
                *((void *)v46 - 2) = 0LL;
                *((void *)v46 - 1) = 0LL;
                *(_OWORD *)(v46 - 24) = *(_OWORD *)&v33[v45 - 24];
                *((void *)v46 - 1) = *(void *)&v33[v45 - 8];
                *((void *)v47 - 3) = 0LL;
                *((void *)v47 - 2) = 0LL;
                *((void *)v47 - 1) = 0LL;
                v45 -= 88LL;
              }

              while (&v33[v45] != v35);
              uint64_t v49 = &v43[v45];
              BOOL v25 = v256;
              v3 = (char *)v259;
              v50 = *(char **)v259;
              v33 = (char *)*((void *)v259 + 1);
              *(void *)v259 = v49;
              *((void *)v259 + 1) = v34;
              *((void *)v259 + 2) = v44;
              unint64_t v20 = v260;
              if (v33 == v50)
              {
                v4 = (uint64_t)v254;
                if (v33) {
                  goto LABEL_55;
                }
              }

              else
              {
                v4 = (uint64_t)v254;
                do
                {
                  v33 -= 88;
                  std::allocator<TargetClause>::destroy[abi:nn180100]((uint64_t)v33);
                }

                while (v33 != v50);
                v33 = v50;
                if (!v50) {
                  goto LABEL_56;
                }
LABEL_55:
                operator delete(v33);
              }
            }

    *((void *)v5 + 5) = *(void *)v18;
    return result;
  }

  if (v6 > -10224)
  {
    if (v6 <= -10204)
    {
      if (v6 == -10223)
      {
        result = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
        *((_DWORD *)v5 + 21) = *((void *)result + 1);
      }

      else if (v6 == -10210)
      {
        result = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
        *((void *)v5 + 8) = *((void *)result + 1);
      }

      return result;
    }

    if (v6 == -10203)
    {
      result = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
      *((void *)v5 + 7) = *((void *)result + 1);
      return result;
    }

    if (v6 != -10187)
    {
      if (v6 != -10186) {
        return result;
      }
      result = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
      id v12 = *(_OWORD *)(result + 8);
      goto LABEL_28;
    }

    result = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
    id v34 = *((void *)result + 1);
LABEL_54:
    *((_DWORD *)v5 + 20) = v34;
    return result;
  }

  if (v6 <= -10238)
  {
    if (v6 != -15778)
    {
      if (v6 != -15509) {
        return result;
      }
      id v13 = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
      v14 = *a3;
      *((void *)v5 + 1) = *((void *)v13 + 1);
      *((void *)v5 + 2) = v14;
      *((_DWORD *)v5 + 1) = *((_DWORD *)a3 + 2);
      uint64_t v15 = GTTraceFunc_argumentBytesWithMap(a3, v13[16], a2);
      *((_WORD *)v5 + 48) = *((_WORD *)v15 + 16);
      *((void *)v5 + 13) = *(void *)v15;
      result = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 14), a2);
      *((void *)v5 + 19) = result;
      if (!result) {
        return result;
      }
      unint64_t v16 = *((void *)result + 1);
      *((void *)v5 + 7) = *(void *)result;
      uint64_t v17 = *((_DWORD *)result + 4);
      *((_DWORD *)v5 + 21) = v16;
      *((_DWORD *)v5 + 22) = v17;
      *((void *)v5 + 14) = *((void *)result + 3);
      id v12 = *((_OWORD *)result + 2);
LABEL_28:
      *((_OWORD *)v5 + 8) = v12;
      return result;
    }

    v35 = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
    uint64_t v36 = *a3;
    id v37 = *((void *)v35 + 2);
    *((void *)v5 + 1) = *((void *)v35 + 1);
    *((void *)v5 + 2) = v36;
    *((_DWORD *)v5 + 1) = *((_DWORD *)a3 + 2);
    *((_WORD *)v5 + 48) = *((void *)v35 + 3);
    *((void *)v5 + 13) = v37;
    result = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 14), a2);
    *((void *)v5 + 19) = result;
    if (result)
    {
      id v38 = *((void *)result + 1);
      *((void *)v5 + 7) = *(void *)result;
      uint64_t v39 = *((_DWORD *)result + 4);
      *((_DWORD *)v5 + 21) = v38;
      *((_DWORD *)v5 + 22) = v39;
      *((void *)v5 + 14) = *((void *)result + 3);
      *((_OWORD *)v5 + 8) = *((_OWORD *)result + 2);
    }

    *((void *)v5 + 6) = *(void *)v35;
    id v34 = *((void *)v35 + 4);
    goto LABEL_54;
  }

  switch(v6)
  {
    case -10237:
      goto LABEL_35;
    case -10235:
      result = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
      *((_DWORD *)v5 + 23) = *((_DWORD *)result + 2);
      break;
    case -10228:
      result = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
      *((void *)v5 + 14) = *((void *)result + 1);
      break;
  }

  return result;
}

LABEL_54:
            uint64_t v45 = *(void *)(a1 + 1928);
            *(void *)(a1 + 1928) = v45 + 1;
            **(_DWORD **)(a1 + 1936) = **(unsigned __int8 **)(a1 + 1936) | ((_DWORD)v45 << 8);
            *(void *)(a1 + 1936) += 24LL;
            *(void *)(a1 + 1976) += 24LL;
            GTMTLReplayController_defaultDispatchFunction(v95, v19);
            uint64_t v46 = *((void *)GTTraceFunc_argumentBytesWithMap( (void *)v19,  *(unsigned __int8 *)(v96 + (v18 << 6) + 13),  v94)
                  + 1);
            id v47 = [v97 globalTraceIdForEncoder:v46 ofType:0];
            v29 = (void *)objc_claimAutoreleasedReturnValue([v97 accelerationStructureCommandEncoderForKey:v46]);
            GTUSCSamplingStreamingManagerHelper::AddEncoderSamplePoints( (_DWORD *)a1,  a2,  v19,  v47,  v29,  *(void *)(a1 + 1928) - 1LL,  v23,  a3);
            [*(id *)(a1 + 1944) addOtherEncoderFunctionIndex:v23 forEncoder:v47 atEncoderIndex:(*(_DWORD *)(a1 + 1928) - 1) forType:@"AccelerationStructure"];
LABEL_79:

            goto LABEL_80;
          }

          if (v24 == -15587)
          {
LABEL_60:
            uint64_t v48 = *(void *)(a1 + 1928);
            *(void *)(a1 + 1928) = v48 + 1;
            **(_DWORD **)(a1 + 1936) = **(unsigned __int8 **)(a1 + 1936) | ((_DWORD)v48 << 8);
            *(void *)(a1 + 1936) += 24LL;
            *(void *)(a1 + 1976) += 24LL;
            GTMTLReplayController_defaultDispatchFunction(v95, v19);
            uint64_t v49 = *((void *)GTTraceFunc_argumentBytesWithMap( (void *)v19,  *(unsigned __int8 *)(v96 + (v18 << 6) + 13),  v94)
                  + 1);
            unsigned int v81 = [v97 globalTraceIdForEncoder:v49 ofType:0];
            v29 = (void *)objc_claimAutoreleasedReturnValue([v97 blitCommandEncoderForKey:v49]);
            GTUSCSamplingStreamingManagerHelper::AddEncoderSamplePoints( (_DWORD *)a1,  a2,  v19,  v81,  v29,  *(void *)(a1 + 1928) - 1LL,  v23,  a3);
            unsigned int v78 = 0;
            goto LABEL_79;
          }

          if (v24 != -15586) {
            goto LABEL_58;
          }
          id v37 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInt:](&OBJC_CLASS___NSNumber, "numberWithUnsignedInt:", *v15));
          v29 = (void *)objc_claimAutoreleasedReturnValue([v84 objectForKeyedSubscript:v37]);

          if (v29)
          {
            id v38 = [v29 unsignedIntegerValue];
            uint64_t v39 = *(void *)(a1 + 1928);
            *(void *)(a1 + 1928) = v39 + 1;
            **(_DWORD **)(a1 + 1936) = **(unsigned __int8 **)(a1 + 1936) | ((_DWORD)v39 << 8);
            *(void *)(a1 + 1936) += 24LL;
            v76 = GTTraceFunc_argumentBytesWithMap((void *)v19, *(unsigned __int8 *)(v96 + (v18 << 6) + 13), v94);
            v86 = (void *)objc_claimAutoreleasedReturnValue([v97 commandBufferForKey:*(void *)v76]);
            bzero(v100, 0x2B90uLL);
            GTMTLSMCommandEncoder_processTraceFunc((uint64_t)v100, (uint64_t *)v19, v94);
            uint64_t v40 = v101;
            uint64_t v41 = (void *)objc_claimAutoreleasedReturnValue([v97 computePassDescriptorMap]);
            MTLComputePassDescriptor = MakeMTLComputePassDescriptor(v40, v41);
            v43 = (void *)objc_claimAutoreleasedReturnValue(MTLComputePassDescriptor);

            id v34 = v43;
            -[MTLComputePassDescriptor setAllowCommandEncoderCoalescing:](v34, "setAllowCommandEncoderCoalescing:", 1LL);
            v44 = (void *)objc_claimAutoreleasedReturnValue( [v86 sampledComputeCommandEncoderWithDescriptor:v34 programInfoBuffer:*(void *)(a1 + 1936) capacity:v38]);
            GTUSCSamplingStreamingManagerHelper::AddEncoderSamplePoints( (_DWORD *)a1,  a2,  v19,  [v44 globalTraceObjectID],  v44,  *(void *)(a1 + 1928) - 1,  v23,  a3);
            [v97 setComputeCommandEncoder:v44 forKey:*((void *)v76 + 1)];
            *(void *)(a1 + 1936) += 24LL * (void)v38;
            *(void *)(a1 + 1976) += 24LL * (void)v38 + 24;

            v35 = v34;
LABEL_69:

            goto LABEL_79;
          }
        }

        uint64_t v19 = 0LL;
      }

    v68 = objc_claimAutoreleasedReturnValue( +[NSMutableData dataWithBytes:length:]( &OBJC_CLASS___NSMutableData,  "dataWithBytes:length:",  __p,  v267 - (_BYTE *)__p));
    id v69 = (void *)*((void *)v259 + 26);
    *((void *)v259 + 26) = v68;
  }

  uint64_t v70 = [*((id *)v259 + 1) count];
  *((_DWORD *)v259 + 37) = v70;
  v71 = v70;
  id v72 = (char *)*((void *)v259 + 19);
  v73 = (char *)*((void *)v259 + 20);
  id v74 = (v73 - v72) >> 5;
  if (v70 > v74)
  {
    v75 = v70 - v74;
    v76 = *((void *)v259 + 21);
    if (v75 <= (v76 - (uint64_t)v73) >> 5)
    {
      bzero(*((void **)v259 + 20), 32 * v75);
      *((void *)v259 + 20) = &v73[32 * v75];
      goto LABEL_83;
    }

    v77 = v76 - (void)v72;
    else {
      unsigned int v78 = v71;
    }
    if (v78 >> 59) {
      goto LABEL_245;
    }
    char v79 = (char *)operator new(32 * v78);
    v80 = &v79[32 * v74];
    unsigned int v81 = &v79[32 * v78];
    bzero(v80, 32 * v75);
    v82 = &v80[32 * v75];
    if (v73 == v72)
    {
      *((void *)v259 + 19) = v80;
      *((void *)v259 + 20) = v82;
      *((void *)v259 + 21) = v81;
      if (!v73) {
        goto LABEL_83;
      }
    }

    else
    {
      v83 = 0LL;
      do
      {
        v84 = &v80[v83];
        v85 = &v73[v83];
        *((void *)v84 - 4) = *(void *)&v73[v83 - 32];
        *((void *)v84 - 3) = 0LL;
        *((void *)v84 - 2) = 0LL;
        *((void *)v84 - 1) = 0LL;
        *(_OWORD *)(v84 - 24) = *(_OWORD *)&v73[v83 - 24];
        *((void *)v84 - 1) = *(void *)&v73[v83 - 8];
        *((void *)v85 - 3) = 0LL;
        *((void *)v85 - 2) = 0LL;
        *((void *)v85 - 1) = 0LL;
        v83 -= 32LL;
      }

      while (&v73[v83] != v72);
      v86 = (char *)*((void *)v259 + 19);
      v73 = (char *)*((void *)v259 + 20);
      *((void *)v259 + 19) = &v80[v83];
      *((void *)v259 + 20) = v82;
      *((void *)v259 + 21) = v81;
      if (v73 != v86)
      {
        do
        {
          char v87 = (void *)*((void *)v73 - 3);
          if (v87)
          {
            *((void *)v73 - 2) = v87;
            operator delete(v87);
          }

          v73 -= 32;
        }

        while (v73 != v86);
        v73 = v86;
      }

      if (!v73) {
        goto LABEL_83;
      }
    }

    operator delete(v73);
    goto LABEL_83;
  }

  if (v70 < v74)
  {
    v88 = &v72[32 * v70];
    while (v73 != v88)
    {
      v89 = (void *)*((void *)v73 - 3);
      if (v89)
      {
        *((void *)v73 - 2) = v89;
        operator delete(v89);
      }

      v73 -= 32;
    }

    *((void *)v259 + 20) = v88;
  }

        v55 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), a3);
        *(void *)(a1 + 48) = GTTraceFunc_argumentBytesWithMap(a2, v55[8], a3);
        return;
      }

      if (v7 <= -15823)
      {
        if (v7 > -15885)
        {
          if (v7 == -15884) {
            goto LABEL_65;
          }
          if (v7 != -15870) {
            return;
          }
          id v12 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), a3);
          bzero((void *)a1, 0x2B90uLL);
          id v13 = *((void *)v12 + 1);
          if (!v13) {
            return;
          }
          v14 = 74;
          goto LABEL_433;
        }

        if (v7 == -15890) {
          goto LABEL_54;
        }
        if (v7 == -15888) {
          *(void *)(a1 + 56) = *((void *)GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), a3) + 1);
        }
      }

      else
      {
        if (v7 > -15795)
        {
          if (v7 == -15794) {
            goto LABEL_54;
          }
          if (v7 == -15789) {
            goto LABEL_65;
          }
          if (v7 != -15673) {
            return;
          }
          id v12 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), a3);
          bzero((void *)a1, 0x2B90uLL);
          id v13 = *((void *)v12 + 1);
          if (!v13) {
            return;
          }
          v14 = 17;
LABEL_433:
          *(_DWORD *)a1 = v14;
          v502 = *a2;
          *(void *)(a1 + 8) = v13;
          *(void *)(a1 + 16) = v502;
          *(void *)(a1 + 24) = -1LL;
          *(void *)(a1 + 40) = *(void *)v12;
          return;
        }

        if (v7 == -15822)
        {
          v606 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), a3);
          *(_DWORD *)(a1 + 11128) = *((void *)v606 + 1);
          *(void *)(a1 + 9912) = GTTraceFunc_argumentBytesWithMap(a2, v606[16], a3);
        }

        else if (v7 == -15812)
        {
          v56 = GTTraceFunc_argumentBytesWithMap(a2, *((unsigned __int8 *)a2 + 13), a3);
          *(_BYTE *)(v6 + 2524) = *((void *)v56 + 1);
          *(_DWORD *)(a1 + 11124) = *((void *)v56 + 2);
        }
      }
    }
  }

LABEL_78:
        GTMTLReplayController_dispatchForUSCSampling( v95,  v19,  v97,  v94,  *(void **)(a1 + 1944),  (*(_DWORD *)(a1 + 1928) - 1));
        v29 = 0LL;
        goto LABEL_79;
      }

      if (v24 <= -16287)
      {
        switch(v24)
        {
          case -16361:
            goto LABEL_55;
          case -16355:
            v29 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v95 + 8) defaultCommandQueue]);
            [v29 finish];
            goto LABEL_79;
          case -16354:
            goto LABEL_60;
          case -16353:
            v50 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInt:](&OBJC_CLASS___NSNumber, "numberWithUnsignedInt:", *v15));
            v29 = (void *)objc_claimAutoreleasedReturnValue([v84 objectForKeyedSubscript:v50]);

            if (!v29) {
              goto LABEL_78;
            }
            id v51 = [v29 unsignedIntegerValue];
            uint64_t v52 = *(void *)(a1 + 1928);
            *(void *)(a1 + 1928) = v52 + 1;
            **(_DWORD **)(a1 + 1936) = **(unsigned __int8 **)(a1 + 1936) | ((_DWORD)v52 << 8);
            *(void *)(a1 + 1936) += 24LL;
            v53 = GTTraceFunc_argumentBytesWithMap((void *)v19, *(unsigned __int8 *)(v96 + (v18 << 6) + 13), v94);
            uint64_t RenderPassDescriptor = GetRenderPassDescriptor((uint64_t *)v19, v94);
            v76 = v53;
            v86 = (void *)objc_claimAutoreleasedReturnValue([v97 commandBufferForKey:*(void *)v53]);
            v55 = (void *)objc_claimAutoreleasedReturnValue([v97 renderPassDescriptorMap]);
            MTLuint64_t RenderPassDescriptor = MakeMTLRenderPassDescriptor(RenderPassDescriptor, v55);
            v35 = (MTLComputePassDescriptor *)objc_claimAutoreleasedReturnValue(MTLRenderPassDescriptor);
            id v57 = v51;
            uint64_t v58 = 2LL * (void)v51 + 2;

            id v34 = (MTLComputePassDescriptor *)objc_claimAutoreleasedReturnValue( [v86 sampledRenderCommandEncoderWithDescriptor:v35 programInfoBuffer:*(void *)(a1 + 1936) capacity:v58]);
            GTUSCSamplingStreamingManagerHelper::AddEncoderSamplePoints( (_DWORD *)a1,  a2,  v19,  -[MTLComputePassDescriptor globalTraceObjectID](v34, "globalTraceObjectID"),  v34,  *(void *)(a1 + 1928) - 1LL,  v23,  0LL);
            [v97 setRenderCommandEncoder:v34 forKey:*((void *)v76 + 1)];
            *(void *)(a1 + 1936) += 24 * v58;
            uint64_t v36 = *(void *)(a1 + 1976) + 48LL * (void)v57 + 72;
            goto LABEL_64;
          case -16352:
            v59 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInt:](&OBJC_CLASS___NSNumber, "numberWithUnsignedInt:", *v15));
            v29 = (void *)objc_claimAutoreleasedReturnValue([v84 objectForKeyedSubscript:v59]);

            if (!v29) {
              goto LABEL_78;
            }
            v76 = (char *)[v29 unsignedIntegerValue];
            uint64_t v60 = *(void *)(a1 + 1928);
            *(void *)(a1 + 1928) = v60 + 1;
            **(_DWORD **)(a1 + 1936) = **(unsigned __int8 **)(a1 + 1936) | ((_DWORD)v60 << 8);
            *(void *)(a1 + 1936) += 24LL;
            v61 = GTTraceFunc_argumentBytesWithMap((void *)v19, *(unsigned __int8 *)(v96 + (v18 << 6) + 13), v94);
            v86 = (void *)objc_claimAutoreleasedReturnValue([v97 commandBufferForKey:*(void *)v61]);
            id v34 = objc_alloc_init(&OBJC_CLASS___MTLComputePassDescriptor);
            -[MTLComputePassDescriptor setAllowCommandEncoderCoalescing:](v34, "setAllowCommandEncoderCoalescing:", 1LL);
            v35 = (MTLComputePassDescriptor *)objc_claimAutoreleasedReturnValue( [v86 sampledComputeCommandEncoderWithDescriptor:v34 programInfoBuffer:*(void *)(a1 + 1936) capacity:v76]);
            GTUSCSamplingStreamingManagerHelper::AddEncoderSamplePoints( (_DWORD *)a1,  a2,  v19,  -[MTLComputePassDescriptor globalTraceObjectID](v35, "globalTraceObjectID"),  v35,  *(void *)(a1 + 1928) - 1LL,  v23,  a3);
            [v97 setComputeCommandEncoder:v35 forKey:*((void *)v61 + 1)];
            *(void *)(a1 + 1936) += 24LL * (void)v76;
            *(void *)(a1 + 1976) += 24LL * (void)v76 + 24;

            goto LABEL_69;
          case -16351:
            v62 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInt:](&OBJC_CLASS___NSNumber, "numberWithUnsignedInt:", *v15));
            v29 = (void *)objc_claimAutoreleasedReturnValue([v84 objectForKeyedSubscript:v62]);

            if (v29)
            {
              id v63 = [v29 unsignedIntegerValue];
              uint64_t v64 = *(void *)(a1 + 1928);
              *(void *)(a1 + 1928) = v64 + 1;
              **(_DWORD **)(a1 + 1936) = **(unsigned __int8 **)(a1 + 1936) | ((_DWORD)v64 << 8);
              *(void *)(a1 + 1936) += 24LL;
              v65 = GTTraceFunc_argumentBytesWithMap((void *)v19, *(unsigned __int8 *)(v96 + (v18 << 6) + 13), v94);
              uint64_t v66 = GetRenderPassDescriptor((uint64_t *)v19, v94);
              v80 = v65;
              v86 = (void *)objc_claimAutoreleasedReturnValue([v97 commandBufferForKey:*(void *)v65]);
              v67 = (void *)objc_claimAutoreleasedReturnValue([v97 renderPassDescriptorMap]);
              v68 = MakeMTLRenderPassDescriptor(v66, v67);
              v35 = (MTLComputePassDescriptor *)objc_claimAutoreleasedReturnValue(v68);
              id v69 = v63;
              uint64_t v70 = 2LL * (void)v63 + 2;

              id v34 = (MTLComputePassDescriptor *)objc_claimAutoreleasedReturnValue( [v86 sampledRenderCommandEncoderWithDescriptor:v35 programInfoBuffer:*(void *)(a1 + 1936) capacity:v70]);
              GTUSCSamplingStreamingManagerHelper::AddEncoderSamplePoints( (_DWORD *)a1,  a2,  v19,  -[MTLComputePassDescriptor globalTraceObjectID](v34, "globalTraceObjectID"),  v34,  *(void *)(a1 + 1928) - 1LL,  v23,  0LL);
              [v97 setParallelRenderCommandEncoder:v34 forKey:*((void *)v80 + 1)];
              *(void *)(a1 + 1936) += 24 * v70;
              *(void *)(a1 + 1976) += 48LL * (void)v69 + 72;
              char v79 = 1;
              goto LABEL_69;
            }

            GTMTLReplayController_dispatchForUSCSampling( v95,  v19,  v97,  v94,  *(void **)(a1 + 1944),  (*(_DWORD *)(a1 + 1928) - 1));
            v29 = 0LL;
            char v79 = 1;
            break;
          default:
            goto LABEL_58;
        }

        goto LABEL_79;
      }

      if (v24 == -16286)
      {
        v71 = GTTraceFunc_argumentBytesWithMap((void *)v19, *(unsigned __int8 *)(v96 + (v18 << 6) + 13), v94);
        v29 = (void *)objc_claimAutoreleasedReturnValue([v97 parallelRenderCommandEncoderForKey:*(void *)v71]);
        [v97 setRenderCommandEncoder:v29 forKey:*((void *)v71 + 1)];
        goto LABEL_79;
      }

      if (v24 == -16285) {
        goto LABEL_61;
      }
      if (v24 != -16246) {
        goto LABEL_58;
      }
      if ((v79 & 1) == 0)
      {
LABEL_61:
        GTMTLReplayController_dispatchForUSCSampling( v95,  v19,  v97,  v94,  *(void **)(a1 + 1944),  (*(_DWORD *)(a1 + 1928) - 1));
        char v79 = 0;
      }

      else
      {
        objc_msgSend( v97,  "removeRenderCommandEncoderForKey:",  *(void *)GTTraceFunc_argumentBytesWithMap((void *)v19, *(unsigned __int8 *)(v96 + (v18 << 6) + 13), v94));
        char v79 = 1;
      }

    ++*((void *)a6 + 3);
LABEL_79:
    v27[3] = v22;
    ++v16;
  }

  while (v16 != v17);
LABEL_2:
}

      v30 = 0LL;
      goto LABEL_80;
    }

LABEL_80:
      if (v92)
      {
        id v72 = objc_msgSend( v97,  "commandBufferForKey:",  *((void *)GTTraceFunc_argumentBytesWithMap( (void *)v19,  *(unsigned __int8 *)(v96 + (v18 << 6) + 13),  v94)
                + 1));
        v73 = (void *)objc_claimAutoreleasedReturnValue(v72);
        [v73 encodeWaitForEvent:v90 value:GTUSCSamplingStreamingManagerHelper::ReplaySingleFrameForUSCSampling(std::unordered_map<unsigned int,GTEncoderSampleIndexInfo> &,std::unordered_map<unsigned int,std::vector<GTCoalescedEncoderIndexInfo>> &,std::vector<std::pair<unsigned long long,unsigned long long>> &,NSObject *,void({block_pointer})(void))::signalCounter++];
        objc_msgSend(v73, "encodeSignalEvent:value:", v90);
      }

      if (FuncEnumConstructorType == 25)
      {
        id v74 = objc_msgSend( v97,  "commandBufferForKey:",  *((void *)GTTraceFunc_argumentBytesWithMap( (void *)v19,  *(unsigned __int8 *)(v96 + (v18 << 6) + 13),  v94)
                + 1));
        v75 = (void *)objc_claimAutoreleasedReturnValue(v74);
        v98[0] = _NSConcreteStackBlock;
        v98[1] = 3221225472LL;
        v98[2] = ___ZN35GTUSCSamplingStreamingManagerHelper31ReplaySingleFrameForUSCSamplingERNSt3__113unordered_mapIj24GTEncoderSampleIndexInfoNS0_4hashIjEENS0_8equal_toIjEENS0_9allocatorINS0_4pairIKjS2_EEEEEERNS1_IjNS0_6vectorI27GTCoalescedEncoderIndexInfoNS7_ISF_EEEES4_S6_NS7_INS8_IS9_SH_EEEEEERNSE_INS8_IyyEENS7_ISM_EEEEP8NSObjectU13block_pointerFvvE_block_invoke_2;
        v98[3] = &__block_descriptor_40_e28_v16__0___MTLCommandBuffer__8l;
        v98[4] = a4;
        [v75 addCompletedHandler:v98];
      }

      objc_autoreleasePoolPop(context);
      unint64_t v16 = *v15 + 1;
      *uint64_t v15 = v16;
      v9 = v89;
      if (v89[13] + v89[12] <= v16) {
        goto LABEL_87;
      }
    }

    objc_msgSend(*(id *)(a1 + 1944), "addSampledCallFunctionIndex:", v23, v76, v77);
LABEL_25:
    int v24 = *v20;
    goto LABEL_26;
  }

              if (v61)
              {
                v84 = v134;
                v85 = v61;
                if (v134)
                {
                  id v42 = v130;
                  if (v126 < (unint64_t)[v84 count])
                  {
                    v86 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v84, "objectAtIndexedSubscript:"));
                    v141 = [v86 unsignedIntValue];

                    char v87 = v141;
                    if (v141 != -1)
                    {
                      v88 = v136[275];
                      if (v126 < 0xAAAAAAAAAAAAAAABLL * (v136[276] - v88))
                      {
                        v89 = &v88[3 * v126];
                        v90 = *v89;
                        v91 = v141 >= (unint64_t)(v89[1] - *v89);
                        int v92 = v141;
                        if (!v91)
                        {
                          v93 = (unsigned int *)&v90[v141];
                          int v92 = *v93;
                          char v87 = v93[1];
                        }

                        uint64_t v94 = *v17 == -16353 || *v17 == -16351;
                        if (v94) {
                          uint64_t v95 = v92 + 1;
                        }
                        else {
                          uint64_t v95 = v92;
                        }
                        if (v94) {
                          uint64_t v96 = v87 + 1;
                        }
                        else {
                          uint64_t v96 = v87;
                        }
                        [v85 filterCounterRangeWithFirstBatch:v95 lastBatch:v96 filterIndex:0];
                      }
                    }

                    ++v126;
                  }
                }

                else
                {
                  id v42 = v130;
                }

                v97 = v43 | ((void)[v85 globalTraceObjectID] << 32);
                v98 = a2;
                v100 = a2[1];
                v99 = (unint64_t)a2[2];
                if ((unint64_t)v100 >= v99)
                {
                  v102 = *a2;
                  v103 = (v100 - *a2) >> 3;
                  v104 = v103 + 1;
                  v105 = v99 - (void)v102;
                  if (v105 >> 2 > v104) {
                    v104 = v105 >> 2;
                  }
                  else {
                    v106 = v104;
                  }
                  if (v106)
                  {
                    if (v106 >> 61) {
                      std::__throw_bad_array_new_length[abi:nn180100]();
                    }
                    v107 = (char *)operator new(8 * v106);
                    v98 = a2;
                  }

                  else
                  {
                    v107 = 0LL;
                  }

                  v108 = &v107[8 * v103];
                  *(void *)v108 = v97;
                  uint64_t v101 = v108 + 8;
                  if (v100 != v102)
                  {
                    do
                    {
                      v109 = *((void *)v100 - 1);
                      v100 -= 8;
                      *((void *)v108 - 1) = v109;
                      v108 -= 8;
                    }

                    while (v100 != v102);
                    v100 = *v98;
                  }

                  *v98 = v108;
                  v98[1] = v101;
                  v98[2] = &v107[8 * v106];
                  if (v100)
                  {
                    operator delete(v100);
                    v98 = a2;
                  }

                  id v42 = v130;
                }

                else
                {
                  *(void *)v100 = v97;
                  uint64_t v101 = v100 + 8;
                }

                v98[1] = v101;
              }

              else
              {
                id v42 = v130;
              }
            }

            else if (v58 == 28)
            {
              v59 = (void *)objc_claimAutoreleasedReturnValue([v132 computeCommandEncoderForKey:v40]);
              uint64_t v60 = DEVICEOBJECT(v59);
              v61 = (void *)objc_claimAutoreleasedReturnValue(v60);

              if (a5)
              {
                v62 = [v61 globalTraceObjectID];
                id v63 = (uint64_t)v136[241] + 1;
                v136[241] = (id **)v63;
                GTUSCSamplingStreamingManagerHelper::AddEncoderSamplePoints(v136, a5, v16, v62, v61, v63, v133, 0LL);
              }

              goto LABEL_80;
            }

  result = [*(id *)(a1 + 32) dumpInstructions];
  return result;
}

LABEL_81:
          id v8 = v70;
          break;
        default:
          GTMTLReplay_handleError( 101,  (uint64_t)"Unreachable",  "/Library/Caches/com.apple.xbs/Sources/GPUToolsDevice/GPUTools/GTMTLCapture/replayer/GTMTLReplay_shaderDebugger_internal.m",  (uint64_t)"GTShaderDebuggerEncodeResourcesRender",  4089LL,  4LL);
          break;
      }

      [v9 useResource:a1[23] usage:2];
      [v9 setRenderPipelineState:v7];
    }

    else if (a2)
    {
      Error = GTShaderDebuggerMakeError(1u, @"Internal error: Failed to resolve render encoder", 0LL, 0LL, 0LL);
      *a2 = (id)objc_claimAutoreleasedReturnValue(Error);
    }
  }

  else if (a2)
  {
    v29 = GTShaderDebuggerMakeError(1u, @"Internal error: Failed to resolve render pipeline", 0LL, 0LL, 0LL);
    uint64_t v10 = 0LL;
    *a2 = (id)objc_claimAutoreleasedReturnValue(v29);
  }

  else
  {
    uint64_t v10 = 0LL;
  }

  return v10;
}

  id v47 = 0LL;
  uint64_t v48 = 0;
  v98 = 0;
  v100 = 0;
  uint64_t v94 = 0;
  uint64_t v96 = 0;
  uint64_t v49 = 0;
  int v92 = 0;
  v86 = 0;
  while (2)
  {
    v6 = (unsigned int *)((char *)v6 + *v6);
    uint64_t v52 = v6[1];
    if (a4)
    {
      if (v52 != -12272)
      {
        v76 = *a4;
        v119 = 0u;
        __s = 0u;
        v116 = v76;
        v117 = 500;
        v118 = "header->fenum == kDYFEInternalData";
        v77 = &v116;
        goto LABEL_137;
      }
    }

    else if (v52 != -12272)
    {
      goto LABEL_132;
    }

    v110 = 0LL;
    v53 = FBDecoder_DecodeArguments((unsigned int *)&v110, (uint64_t)(v6 + 9), *v6 - 36, (uint64_t)&v116, 0xDuLL);
    if (!a4)
    {
      v54 = HIDWORD(v110);
      if (v53) {
        v55 = 0;
      }
      else {
        v55 = HIDWORD(v110) > 1;
      }
      if (!v55) {
        goto LABEL_132;
      }
LABEL_94:
      v56 = *(_DWORD *)v119;
      if (*(int *)v119 <= 115)
      {
        switch(v56)
        {
          case 'f':
            v6 = DecodeDYMTLBinding(v101 + 56LL * v49++, v6, v5, v50, a4);
            break;
          case 'g':
            v6 = DecodeDYMTLBinding(v91 + 56LL * (unsigned __int16)v47, v6, v5, v50, a4);
            id v47 = (v47 + 1);
            break;
          case 'h':
            v6 = DecodeDYMTLBinding(v90 + 56LL * v48++, v6, v5, v50, a4);
            break;
          default:
LABEL_104:
            if (a4)
            {
              id v57 = *a4;
              v108 = 0uLL;
              v109 = 0uLL;
              v105 = v57;
              v106 = 500;
              v107 = "0";
              GTError_addError(a4, (uint64_t)&v105);
            }

            break;
        }
      }

      else
      {
        switch(v56)
        {
          case 121:
            v6 = DecodeDYMTLBinding(v87 + 56LL * v100++, v6, v5, v50, a4);
            break;
          case 122:
          case 123:
          case 124:
          case 125:
          case 127:
          case 128:
          case 129:
          case 132:
            goto LABEL_104;
          case 126:
            if (a4)
            {
              if (v54 <= 3)
              {
                unsigned int v81 = *a4;
                v108 = 0u;
                v109 = 0u;
                v105 = v81;
                v106 = 500;
                v80 = "4 <= parser.ntokens";
                goto LABEL_136;
              }
            }

            else if (v54 < 4)
            {
              goto LABEL_132;
            }

            v82 = v47;
            uint64_t v58 = (const void *)__s;
            if ((void)__s)
            {
              v59 = strlen((const char *)__s);
              uint64_t v60 = v5;
              v61 = (char *)v5[23];
              v62 = v61;
              id v63 = v59 + 1;
              if (v59 != -1LL) {
                goto LABEL_119;
              }
            }

            else
            {
              id v63 = 0LL;
              uint64_t v60 = v5;
              v61 = (char *)v5[23];
            }

            v62 = 0LL;
LABEL_119:
            v83 = v35;
            v60[23] = &v61[v63];
            if ((_DWORD)v50) {
              memcpy(v62, v58, v63);
            }
            uint64_t v64 = v33;
            v65 = v121;
            if (v121)
            {
              uint64_t v66 = strlen(v121);
              v67 = (char *)v60[23];
              v68 = v67;
              id v69 = v66 + 1;
              if (v66 != -1LL) {
                goto LABEL_126;
              }
            }

            else
            {
              id v69 = 0LL;
              v67 = (char *)v60[23];
            }

            v68 = 0LL;
LABEL_126:
            v60[23] = &v67[v69];
            if ((_DWORD)v50)
            {
              memcpy(v68, v65, v69);
              *(void *)(v85 + 8LL * v86) = v62;
              *(void *)(v84 + 8LL * v86++) = v68;
            }

            v5 = v60;
            v33 = v64;
            id v47 = v82;
            v35 = v83;
            break;
          case 130:
            v6 = DecodeDYMTLBinding(v33 + 56LL * v98++, v6, v5, v50, a4);
            break;
          case 131:
            v6 = DecodeDYMTLBinding(v89 + 56LL * v96++, v6, v5, v50, a4);
            break;
          case 133:
            v6 = DecodeDYMTLBinding(v35 + 56LL * v94++, v6, v5, v50, a4);
            break;
          case 134:
            v6 = DecodeDYMTLBinding(v88 + 56LL * v92++, v6, v5, v50, a4);
            break;
          default:
            if (v56 != 116) {
              goto LABEL_104;
            }
            break;
        }
      }

      if ((*((_BYTE *)v6 + 33) & 0x20) != 0) {
        goto LABEL_132;
      }
      continue;
    }

    break;
  }

  if (!v53)
  {
    v54 = HIDWORD(v110);
    if (HIDWORD(v110) <= 1)
    {
      char v79 = *a4;
      v108 = 0u;
      v109 = 0u;
      v105 = v79;
      v106 = 500;
      v80 = "2 <= parser.ntokens";
      goto LABEL_136;
    }

    goto LABEL_94;
  }

  unsigned int v78 = *a4;
  v108 = 0u;
  v109 = 0u;
  v105 = v78;
  v106 = 500;
  v80 = "err == FBUF_SUCCESS";
LABEL_136:
  v107 = v80;
  v77 = &v105;
LABEL_137:
  GTError_addError(a4, (uint64_t)v77);
  if ((_DWORD)v50)
  {
LABEL_133:
    uint64_t v70 = v5[12];
    *(void *)uint64_t v70 = -1LL;
    *(_OWORD *)(v70 + 8) = v104;
    *(void *)(v70 + 24) = v91;
    *(void *)(v70 + 32) = v90;
    *(void *)(v70 + 40) = v33;
    *(void *)(v70 + 48) = v89;
    *(void *)(v70 + 56) = v87;
    *(void *)(v70 + 64) = 0LL;
    *(void *)(v70 + 72) = v101;
    *(void *)(v70 + 80) = v35;
    *(void *)(v70 + 88) = v88;
    *(void *)(v70 + 96) = v85;
    *(void *)(v70 + 104) = v84;
    v71 = v112;
    *(_OWORD *)(v70 + 112) = v111;
    *(_OWORD *)(v70 + 128) = v71;
    id v72 = v113;
    v73 = v114;
    id v74 = *(_OWORD *)v115;
    *(void *)(v70 + 190) = *(void *)&v115[14];
    *(_OWORD *)(v70 + 160) = v73;
    *(_OWORD *)(v70 + 176) = v74;
    *(_OWORD *)(v70 + 144) = v72;
    *(_WORD *)(v70 + 198) = v47;
    *(_WORD *)(v70 + 200) = v48;
    *(_WORD *)(v70 + 202) = v100;
    *(_WORD *)(v70 + 204) = v98;
    *(_WORD *)(v70 + 206) = v96;
    *(_WORD *)(v70 + 208) = v49;
    *(_WORD *)(v70 + 210) = v94;
    *(_WORD *)(v70 + 212) = v92;
    *(_WORD *)(v70 + 214) = v86;
    memcpy((void *)(v70 + 216), __src, 0x118uLL);
  }

LABEL_87:
}

    for (k = qword_5B96C8; k; k = *(void *)k)
    {
      v55 = (void *)(k + 16);
      if (std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::find<std::string>( v228,  *((unint64_t *)&v228 + 1),  k + 16))
      {
        v56 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", v55));
        [v176 addObject:v56];
      }
    }

    std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::~__hash_table((uint64_t)&v228);

    id v57 = (void *)xmmword_5B9900;
    *(void *)&xmmword_5B9900 = v176;

    v59 = (void *)objc_opt_new(&OBJC_CLASS___NSMutableArray, v58);
    v61 = (void *)objc_opt_new(&OBJC_CLASS___NSMutableSet, v60);
    v216 = 0u;
    v217 = 0u;
    v214 = 0u;
    v215 = 0u;
    v62 = (id)xmmword_5B9900;
    id v63 = [v62 countByEnumeratingWithState:&v214 objects:&v246 count:16];
    if (v63)
    {
      uint64_t v64 = *(void *)v215;
      do
      {
        for (m = 0LL; m != v63; m = (char *)m + 1)
        {
          if (*(void *)v215 != v64) {
            objc_enumerationMutation(v62);
          }
          std::string::basic_string[abi:nn180100]<0>( __p, (char *)[*(id *)(*((void *)&v214 + 1) + 8 * (void)m) UTF8String]);
          uint64_t v66 = GTAGXProfilingSupportHelper::GetCountersForDerivedCounter((uint64_t)__p);
          v67 = v66;
          if (SBYTE7(v233) < 0)
          {
            operator delete(__p[0]);
            if (!v67) {
              continue;
            }
          }

          else if (!v66)
          {
            continue;
          }

          v68 = *v67;
          id v69 = v67[1];
          while (v68 != v69)
          {
            uint64_t v70 = v68;
            v71 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", v70));
            [v61 addObject:v71];

            v68 += 24LL;
          }
        }

        id v63 = [v62 countByEnumeratingWithState:&v214 objects:&v246 count:16];
      }

      while (v63);
    }

    id v72 = objc_claimAutoreleasedReturnValue([v61 allObjects]);
    obj = (id)v72;
    BOOL v28 = v171;
  }

  std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::~__hash_table((uint64_t)&v210);
  uint64_t v19 = &CATransform3DIdentity_ptr;
LABEL_111:
  v73 = (void *)objc_claimAutoreleasedReturnValue(-[CATransform3D setWithArray:]((id)v19[277], "setWithArray:", obj));
  [v73 addObjectsFromArray:&off_59F830];
  id v74 = (void *)objc_claimAutoreleasedReturnValue( +[NSMutableDictionary dictionaryWithCapacity:]( &OBJC_CLASS___NSMutableDictionary,  "dictionaryWithCapacity:",  4096LL));
  for (n = 0; n < (unint64_t)[*((id *)&xmmword_5B8CE0 + 1) count]; ++n)
  {
    v181 = (id)objc_claimAutoreleasedReturnValue(objc_msgSend(*((id *)&xmmword_5B8CE0 + 1), "objectAtIndexedSubscript:"));
    v75 = (void *)objc_claimAutoreleasedReturnValue([v181 availableCounters]);
    v212 = 0u;
    v213 = 0u;
    v210 = 0u;
    v211 = 0u;
    v76 = v75;
    v77 = [v76 countByEnumeratingWithState:&v210 objects:__p count:16];
    if (v77)
    {
      unsigned int v78 = *(void *)v211;
      do
      {
        for (ii = 0LL; ii != v77; ii = (char *)ii + 1)
        {
          if (*(void *)v211 != v78) {
            objc_enumerationMutation(v76);
          }
          v80 = *(void **)(*((void *)&v210 + 1) + 8LL * (void)ii);
          unsigned int v81 = (void *)objc_claimAutoreleasedReturnValue([v80 name]);
          v82 = [v73 containsObject:v81];

          if (v82)
          {
            v83 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedInteger:]( NSNumber,  "numberWithUnsignedInteger:",  [v80 counterValueType]));
            v84 = (void *)objc_claimAutoreleasedReturnValue([v80 name]);
            [v74 setObject:v83 forKeyedSubscript:v84];
          }
        }

        v77 = [v76 countByEnumeratingWithState:&v210 objects:__p count:16];
      }

      while (v77);
    }
  }

  [v168 setDictionary:v74];
  v85 = (char *)[obj count];
  v190 = (void *)objc_claimAutoreleasedReturnValue( +[NSMutableArray arrayWithCapacity:]( NSMutableArray,  "arrayWithCapacity:",  &v85[(void)[(id)qword_5B9498 count]]));
  [v190 addObjectsFromArray:qword_5B9498];
  v208 = 0u;
  v209 = 0u;
  v206 = 0u;
  v207 = 0u;
  v86 = obj;
  char v87 = [v86 countByEnumeratingWithState:&v206 objects:&v228 count:16];
  if (v87)
  {
    v88 = *(void *)v207;
    do
    {
      for (jj = 0LL; jj != v87; jj = (char *)jj + 1)
      {
        if (*(void *)v207 != v88) {
          objc_enumerationMutation(v86);
        }
        v90 = *(id *)(*((void *)&v206 + 1) + 8LL * (void)jj);
        if ([v90 isEqualToString:@"MTLStat_nSec"])
        {
          v91 = 0LL;
        }

        else
        {
          v91 = 1LL;
        }

        int v92 = objc_claimAutoreleasedReturnValue([&off_59F830 objectAtIndexedSubscript:v91]);

        v90 = (id)v92;
LABEL_133:
        v93 = (void *)objc_claimAutoreleasedReturnValue( +[GPURawCounterSelect selectWithName:options:]( &OBJC_CLASS___GPURawCounterSelect,  "selectWithName:options:",  v90,  0LL));
        [v190 addObject:v93];
      }

      char v87 = [v86 countByEnumeratingWithState:&v206 objects:&v228 count:16];
    }

    while (v87);
  }

  uint64_t v94 = GTUSCSamplingStreamingManagerHelper::SubDividedCounterDictionary(v190);
  uint64_t v95 = (GTUSCSamplingStreamingManagerHelper *)objc_claimAutoreleasedReturnValue(v94);
  uint64_t v96 = v95;
  if (!v95) {
    goto LABEL_196;
  }
  v164 = v95;
  v97 = -[GTUSCSamplingStreamingManagerHelper count](v95, "count");
  uint64_t v96 = v164;
  if (!v97) {
    goto LABEL_196;
  }
  __p[0] = 0LL;
  __p[1] = __p;
  *(void *)&v233 = 0x5812000000LL;
  *((void *)&v233 + 1) = __Block_byref_object_copy__195;
  *(void *)v234 = __Block_byref_object_dispose__196;
  v160 = &v234[16];
  memset(&v234[8], 0, 32);
  v235 = 0LL;
  v236 = 1065353216;
  v179 = GTUSCSamplingStreamingManagerHelper::SetupBumperCounters(v164, v98);
  v175 = v164;
  v163 = (void *)objc_claimAutoreleasedReturnValue( +[NSMutableDictionary dictionaryWithCapacity:]( &OBJC_CLASS___NSMutableDictionary,  "dictionaryWithCapacity:",  -[GTUSCSamplingStreamingManagerHelper count](v175, "count")));
  v99 = (void *)objc_claimAutoreleasedReturnValue([v163 objectForKeyedSubscript:@"passNum"]);
  [v163 setObject:v99 forKeyedSubscript:@"passNum"];

  v100 = (void *)objc_claimAutoreleasedReturnValue( -[GTUSCSamplingStreamingManagerHelper objectForKeyedSubscript:]( v175,  "objectForKeyedSubscript:",  @"passNum"));
  LODWORD(v99) = [v100 unsignedIntValue];

  v170 = v99;
  v172 = (id)objc_claimAutoreleasedReturnValue(+[NSMutableArray arrayWithCapacity:](&OBJC_CLASS___NSMutableArray, "arrayWithCapacity:"));
  if ((_DWORD)v99)
  {
    v177 = 0LL;
    do
    {
      uint64_t v101 = (void *)objc_claimAutoreleasedReturnValue( -[GTUSCSamplingStreamingManagerHelper objectForKeyedSubscript:]( v175,  "objectForKeyedSubscript:",  @"passList"));
      v182 = (id)objc_claimAutoreleasedReturnValue([v101 objectAtIndexedSubscript:v177]);

      v102 = objc_claimAutoreleasedReturnValue( +[NSMutableArray arrayWithCapacity:]( NSMutableArray,  "arrayWithCapacity:",  [v182 count]));
      v230 = 0u;
      v231 = 0u;
      v228 = 0u;
      v229 = 0u;
      v183 = v182;
      obja = (id)v102;
      v103 = [v183 countByEnumeratingWithState:&v228 objects:&v246 count:16];
      if (v103)
      {
        v104 = *(void *)v229;
        do
        {
          for (kk = 0LL; kk != v103; kk = (char *)kk + 1)
          {
            if (*(void *)v229 != v104) {
              objc_enumerationMutation(v183);
            }
            v106 = *(void **)(*((void *)&v228 + 1) + 8LL * (void)kk);
            v107 = (void *)objc_claimAutoreleasedReturnValue([(id)qword_5B9498 arrayByAddingObjectsFromArray:v106]);
            v108 = (void *)objc_claimAutoreleasedReturnValue( +[NSMutableArray arrayWithCapacity:]( NSMutableArray,  "arrayWithCapacity:",  [v107 count]));
            v220 = 0u;
            v221 = 0u;
            v218 = 0u;
            v219 = 0u;
            v109 = v106;
            v110 = [v109 countByEnumeratingWithState:&v218 objects:&v237 count:16];
            if (v110)
            {
              v111 = *(void *)v219;
              do
              {
                for (mm = 0LL; mm != v110; mm = (char *)mm + 1)
                {
                  if (*(void *)v219 != v111) {
                    objc_enumerationMutation(v109);
                  }
                  [v108 addObject:v113];
                }

                v110 = [v109 countByEnumeratingWithState:&v218 objects:&v237 count:16];
              }

              while (v110);
            }

            [obja addObject:v108];
          }

          v103 = [v183 countByEnumeratingWithState:&v228 objects:&v246 count:16];
        }

        while (v103);
      }

      [v172 addObject:obja];
      ++v177;
    }

    while (v177 != v170);
  }

  [v163 setObject:v172 forKeyedSubscript:@"passList"];

  v114 = (void *)objc_claimAutoreleasedReturnValue( [*(id *)(GTUSCSamplingStreamingManagerHelper::Instance(void)::instance + 16) objectForKeyedSubscript:@"perEncoderDrawCallCount"]);
  v161 = [v114 count];

  v166 = (void *)objc_opt_new(&OBJC_CLASS___NSMutableDictionary, v115);
  GTUSCSamplingStreamingManagerHelper::CleanupGPURawCounters((uint64_t)&GTUSCSamplingStreamingManagerHelper::Instance(void)::instance);
  v116 = atomic_load(byte_5B979C);
  if ((v116 & 1) != 0) {
    goto LABEL_195;
  }
  v184 = 0LL;
  v162 = 0;
  while (2)
  {
    v117 = (void *)objc_claimAutoreleasedReturnValue([*(id *)((char *)&xmmword_5B955C + 4) nextPerEncoderBatchList:v166]);

    if (v117)
    {
      dispatch_semaphore_wait((dispatch_semaphore_t)xmmword_5B9690, 0xFFFFFFFFFFFFFFFFLL);
      context = (GTUSCSamplingStreamingManagerHelper *)objc_autoreleasePoolPush();
      GTUSCSamplingStreamingManagerHelper::SetupGPURawCounters(context);
      v184 = v117;
      v118 = (void *)objc_claimAutoreleasedReturnValue( [*(id *)(GTUSCSamplingStreamingManagerHelper::Instance(void)::instance + 16) objectForKeyedSubscript:@"perEncoderIndexDrawCallCount"]);
      v119 = (void *)objc_claimAutoreleasedReturnValue( +[NSMutableArray arrayWithCapacity:]( NSMutableArray,  "arrayWithCapacity:",  [v118 count]));
      v120 = 0LL;
      v121 = 0LL;
      while (v120 < (unint64_t)[v118 count])
      {
        v122 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedInteger:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedInteger:",  v120));
        v123 = (void *)objc_claimAutoreleasedReturnValue([v118 objectForKeyedSubscript:v122]);
        v124 = [v123 unsignedIntegerValue] == 0;

        if (v124)
        {
          [v119 addObject:&off_5A0478];
        }

        else
        {
          v125 = (void *)objc_claimAutoreleasedReturnValue([v184 objectAtIndexedSubscript:v121]);
          [v119 addObject:v125];

          ++v121;
        }

        ++v120;
      }

      v167 = [v166 copy];
      v178 = (void *)objc_opt_new(&OBJC_CLASS___NSMutableArray, v126);
      v246 = 0LL;
      v247 = &v246;
      v248 = 0x4812000000LL;
      v249 = __Block_byref_object_copy__197;
      v250 = __Block_byref_object_dispose__198;
      v251 = "";
      memset(v252, 0, 24);
      v237 = 0LL;
      v238 = &v237;
      v239 = 0x4812000000LL;
      v240 = __Block_byref_object_copy__199;
      v241 = __Block_byref_object_dispose__200;
      v242 = "";
      v244 = 0LL;
      v245 = 0LL;
      v243 = 0LL;
      std::vector<std::vector<DYMTLEncoderInfo>>::resize(v252, v179);
      objb = (id)objc_opt_new(&OBJC_CLASS___NSOperation, v127);
      if (v179)
      {
        v128 = 0LL;
        for (nn = 0; nn != v179; ++nn)
        {
          std::vector<std::vector<DYMTLEncoderInfo>>::reserve(v247 + 6, 2LL * (void)v161);
          v131 = (void *)objc_opt_new(&OBJC_CLASS___NSMutableArray, v130);
          v195[0] = _NSConcreteStackBlock;
          v195[1] = 3221225472LL;
          v195[2] = ___ZN35GTUSCSamplingStreamingManagerHelper29StreamBatchIdFilteredCountersEv_block_invoke;
          v195[3] = &unk_58D7F0;
          v202 = &GTUSCSamplingStreamingManagerHelper::Instance(void)::instance;
          v132 = v175;
          v203 = nn;
          v205 = v173;
          v196 = v132;
          v199 = &v246;
          v200 = &v237;
          v197 = v119;
          v201 = __p;
          v133 = v131;
          v198 = v133;
          v204 = v179;
          v134 = (void *)objc_claimAutoreleasedReturnValue( +[NSBlockOperation blockOperationWithBlock:]( &OBJC_CLASS___NSBlockOperation,  "blockOperationWithBlock:",  v195));
          v135 = v134;
          if (v128) {
            [v134 addDependency:v128];
          }
          [**(id **)(GTUSCSamplingStreamingManagerHelper::Instance(void)::instance + 8) addOperation:v135];
          [v135 setQueuePriority:-8];
          v191[0] = _NSConcreteStackBlock;
          v191[1] = 3221225472LL;
          v191[2] = ___ZN35GTUSCSamplingStreamingManagerHelper29StreamBatchIdFilteredCountersEv_block_invoke_2;
          v191[3] = &unk_58EDA8;
          v194 = &GTUSCSamplingStreamingManagerHelper::Instance(void)::instance;
          v136 = v133;
          v192 = v136;
          v193 = v178;
          v137 = (void *)objc_claimAutoreleasedReturnValue( +[NSBlockOperation blockOperationWithBlock:]( &OBJC_CLASS___NSBlockOperation,  "blockOperationWithBlock:",  v191));
          [v137 addDependency:v135];
          [*(id *)(*(void *)(GTUSCSamplingStreamingManagerHelper::Instance(void)::instance + 8) + 8) addOperation:v137];
          [objb addDependency:v137];

          v128 = v137;
        }
      }

      else
      {
        v137 = 0LL;
      }

      [*(id *)(*(void *)(GTUSCSamplingStreamingManagerHelper::Instance(void)::instance + 8) + 8) addOperation:objb];
      [objb waitUntilFinished];
      GTUSCSamplingStreamingManagerHelper::CleanupGPURawCounters((uint64_t)&GTUSCSamplingStreamingManagerHelper::Instance(void)::instance);
      v138 = atomic_load(byte_5B979C);
      if ((v138 & 1) == 0)
      {
        v139 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableArray arrayWithCapacity:](&OBJC_CLASS___NSMutableArray, "arrayWithCapacity:", v179));
        if (v179)
        {
          v140 = 0LL;
          do
          {
            v141 = (void *)objc_claimAutoreleasedReturnValue( +[NSData dataWithBytes:length:]( &OBJC_CLASS___NSData,  "dataWithBytes:length:",  *(void *)((char *)v247[6] + v140),  *(void *)((char *)v247[6] + v140 + 8) - *(void *)((char *)v247[6] + v140)));
            [v139 addObject:v141];

            v140 += 24LL;
          }

          while (24LL * v179 != v140);
        }

        v226[0] = @"Derived Counter Sample Data";
        v226[1] = @"Subdivided Dictionary";
        v227[0] = v178;
        v227[1] = v163;
        v227[2] = v139;
        v226[2] = @"Encoder Infos";
        v226[3] = @"Encoder Tile Info";
        v142 = (void *)objc_claimAutoreleasedReturnValue( +[NSData dataWithBytes:length:]( &OBJC_CLASS___NSData,  "dataWithBytes:length:",  v238[6],  (char *)v238[7] - (char *)v238[6]));
        v227[3] = v142;
        v227[4] = v119;
        v226[4] = @"BatchInfos";
        v226[5] = @"Counter Info";
        v227[5] = v168;
        v226[6] = @"Num Encoders";
        v143 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedInteger:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedInteger:",  v161));
        v227[6] = v143;
        v226[7] = @"Source Sample Marker";
        v145 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  qword_5B8CF0));
        v227[7] = v145;
        v227[8] = &__kCFBooleanTrue;
        v226[8] = @"Batch Filtered Counters";
        v226[9] = @"Derived Counters Info Data";
        v146 = *(void **)(GTUSCSamplingStreamingManagerHelper::Instance(void)::instance + 48);
        v147 = v146;
        if (!v146)
        {
          v159 = (void *)objc_opt_new(&OBJC_CLASS___NSMutableDictionary, v144);
          v147 = v159;
        }

        v226[10] = @"HighPriorityBatchInfo";
        v227[9] = v147;
        v227[10] = v167;
        v148 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v227,  v226,  11LL,  v159,  v160));
        v149 = (void *)objc_claimAutoreleasedReturnValue( +[NSMutableDictionary dictionaryWithDictionary:]( &OBJC_CLASS___NSMutableDictionary,  "dictionaryWithDictionary:",  v148));

        if (!v146) {
        if ((v162 & 1) != 0)
        }
        {
LABEL_184:
          v162 = 1;
        }

        else
        {
          if ((_DWORD)qword_5B9550 != -1)
          {
            v151 = GTAGXProfilingSupportHelper::RemappedCSV(v150);
            v152 = (void *)objc_claimAutoreleasedReturnValue(v151);
            v153 = v152;
            if (v152 && [v152 length]) {
              [v149 setObject:v153 forKeyedSubscript:@"csv"];
            }

            goto LABEL_184;
          }

          v162 = 0;
        }

        if ((void)xmmword_5B9900)
        {
          v224[0] = @"DerivedCounterDictionary";
          v222 = @"DerivedCounters";
          v223 = xmmword_5B9900;
          v154 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v223,  &v222,  1LL));
          v224[1] = @"DerivedCounterConfigurationVariables";
          v225[0] = v154;
          v225[1] = qword_5B9490;
          v155 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v225,  v224,  2LL));
          [v149 setObject:v155 forKeyedSubscript:@"Derived Counters Info Data"];
        }

        v156 = *(void *)(GTUSCSamplingStreamingManagerHelper::Instance(void)::instance + 32);
        v157 = [v149 copy];
        (*(void (**)(uint64_t, id))(v156 + 16))(v156, v157);
      }

      _Block_object_dispose(&v237, 8);
      if (v243)
      {
        v244 = v243;
        operator delete(v243);
      }

      _Block_object_dispose(&v246, 8);
      v237 = (void **)v252;
      std::vector<std::vector<DYMTLEncoderInfo>>::__destroy_vector::operator()[abi:nn180100](&v237);

      objc_autoreleasePoolPop(context);
      dispatch_semaphore_signal((dispatch_semaphore_t)xmmword_5B9690);
      v158 = atomic_load(byte_5B979C);
      if ((v158 & 1) != 0) {
        goto LABEL_194;
      }
      continue;
    }

    break;
  }

  v184 = 0LL;
LABEL_194:

LABEL_195:
  _Block_object_dispose(__p, 8);
  std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long>>>::~__hash_table((uint64_t)v160);
  uint64_t v96 = v164;
LABEL_196:
}

  uint64_t v60 = (char *)a3[21];
  a3[21] = v60 + 960;
  if (!a4) {
    return;
  }
  if (a5)
  {
    v61 = (uint64_t *)GetAliasStream2(a5, v65[106]);
    if (v61) {
      v62 = *v61;
    }
    else {
      v62 = 0LL;
    }
    v65[106] = v62;
    id v63 = (uint64_t *)GetAliasStream2(a5, v65[110]);
    if (!v63)
    {
      uint64_t v64 = 0LL;
      goto LABEL_96;
    }
  }

  else
  {
    id v63 = &v65[110];
  }

  uint64_t v64 = *v63;
LABEL_96:
  v65[110] = v64;
  memcpy(v60, v65, 0x3C0uLL);
}

void sub_5EFB4( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, void *a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, void *a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, void *a29)
{
}

void ScopedReplayConfiguration::~ScopedReplayConfiguration(ScopedReplayConfiguration *this)
{
  if (*((_BYTE *)this + 16))
  {
    v2 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(*((void *)this + 1) + 8) defaultCommandQueue]);
    [v2 setGPUPriority:1];
  }

  [(id)g_commandBufferDescriptor setErrorOptions:*(void *)this];
}

void sub_5F1D8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

NSString *AddShaderBinary( NSMutableDictionary *a1, NSData *a2, objc_object *a3, int a4, uint64_t a5, NSString *a6, int a7, NSString *a8)
{
  id v38 = a1;
  uint64_t v15 = a2;
  id v37 = a3;
  unint64_t v16 = a6;
  uint64_t v17 = a8;
  if (v16)
  {
    unint64_t v18 = v16;
  }

  else
  {
    uLong v19 = crc32(0LL, 0LL, 0);
    unint64_t v20 = v15;
    double v21 = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"%0.8x_%p",  crc32(v19, (const Bytef *)-[NSData bytes](v20, "bytes"), (uInt)-[NSData length](v20, "length")),  v37);
    unint64_t v18 = (NSString *)objc_claimAutoreleasedReturnValue(v21);
  }

  double v22 = v18;
  uint64_t v23 = objc_autoreleasePoolPush();
  BOOL v25 = (void *)objc_opt_new(&OBJC_CLASS___NSMutableDictionary, v24);
  BOOL v26 = v25;
  if (a7) {
    [v25 setObject:&__kCFBooleanTrue forKeyedSubscript:@"dylib"];
  }
  if (v17) {
    [v26 setObject:v17 forKeyedSubscript:@"type"];
  }
  objc_autoreleasePoolPop(v23);
  if (a4)
  {
    if (v15)
    {
      int v27 = (void *)objc_claimAutoreleasedReturnValue( +[GTShaderProfilerBinaryAnalysisResult analyzeBinary:targetIndex:isaPrinter:]( &OBJC_CLASS___GTShaderProfilerBinaryAnalysisResult,  "analyzeBinary:targetIndex:isaPrinter:",  v15,  a5,  0LL));
      if (v27)
      {
        id v39 = 0LL;
        BOOL v28 = (void *)objc_claimAutoreleasedReturnValue( +[NSKeyedArchiver archivedDataWithRootObject:requiringSecureCoding:error:]( &OBJC_CLASS___NSKeyedArchiver,  "archivedDataWithRootObject:requiringSecureCoding:error:",  v27,  1LL,  &v39));
        id v29 = v39;
        if (v29 || !v28)
        {
          v44 = @"binary";
          uint64_t v45 = v15;
          v35 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v45,  &v44,  1LL));
          [v26 addEntriesFromDictionary:v35];

          id v31 = [v26 copy];
          -[NSMutableDictionary setObject:forKeyedSubscript:](v38, "setObject:forKeyedSubscript:", v31, v22);
        }

        else
        {
          v46[0] = @"binary";
          v46[1] = @"binaryAnalysis";
          v47[0] = v15;
          v47[1] = v28;
          v30 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v47,  v46,  2LL));
          [v26 addEntriesFromDictionary:v30];

          id v31 = [v26 copy];
          -[NSMutableDictionary setObject:forKeyedSubscript:](v38, "setObject:forKeyedSubscript:", v31, v22);
        }
      }

      else
      {
        id v42 = @"binary";
        v43 = v15;
        id v34 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v43,  &v42,  1LL));
        [v26 addEntriesFromDictionary:v34];

        id v29 = [v26 copy];
        -[NSMutableDictionary setObject:forKeyedSubscript:](v38, "setObject:forKeyedSubscript:", v29, v22);
      }
    }

    else
    {
      id v33 = [v26 copy];
      -[NSMutableDictionary setObject:forKeyedSubscript:](v38, "setObject:forKeyedSubscript:", v33, v22);
    }
  }

  else
  {
    if (v15)
    {
      uint64_t v40 = @"binary";
      uint64_t v41 = v15;
      uint64_t v32 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v41,  &v40,  1LL));
      [v26 addEntriesFromDictionary:v32];
    }

    -[NSMutableDictionary setObject:forKeyedSubscript:](v38, "setObject:forKeyedSubscript:", v26, v22);
  }

  return v22;
}

void sub_5F590( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, void *a12)
{
  _Unwind_Resume(a1);
}

id GTUSCSamplingStreamingManagerHelper::AllocUSCSamplingAddressBuffer( GTUSCSamplingStreamingManagerHelper *this)
{
  v2 = objc_alloc_init(&OBJC_CLASS___ProgramAddressTableCollector);
  v3 = (void *)*((void *)this + 243);
  *((void *)this + 243) = v2;

  id v4 = *(id *)(*(void *)this + 16LL);
  v5 = (void *)objc_claimAutoreleasedReturnValue([v4 objectForKeyedSubscript:@"perEncoderDrawCallCount"]);
  id v6 = [v5 count];

  uint64_t v7 = (void *)objc_claimAutoreleasedReturnValue([v4 objectForKeyedSubscript:@"totalDrawCallCount"]);
  id v8 = [v7 unsignedIntegerValue];

  v9 = objc_alloc(&OBJC_CLASS___NSMutableData);
  unint64_t v10 = 12 * (2LL * (void)v8 + 8LL * (void)v6);
  if (v10 <= 0x15555) {
    unint64_t v10 = 87381LL;
  }
  v11 = -[NSMutableData initWithLength:](v9, "initWithLength:", 24 * v10);
  id v12 = (void *)*((void *)this + 246);
  *((void *)this + 246) = v11;

  memset([*((id *)this + 246) mutableBytes], 255, (size_t)objc_msgSend(*((id *)this + 246), "length"));
  id v13 = *((id *)this + 246);

  return v13;
}

void sub_5F768(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t std::__hash_table<std::__hash_value_type<unsigned int,std::vector<GTCoalescedEncoderIndexInfo>>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,std::vector<GTCoalescedEncoderIndexInfo>>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,std::vector<GTCoalescedEncoderIndexInfo>>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,std::vector<GTCoalescedEncoderIndexInfo>>>>::~__hash_table( uint64_t a1)
{
  v2 = *(void **)(a1 + 16);
  if (v2)
  {
    do
    {
      v3 = (void *)*v2;
      id v4 = (void *)v2[3];
      if (v4)
      {
        v2[4] = v4;
        operator delete(v4);
      }

      operator delete(v2);
      v2 = v3;
    }

    while (v3);
  }

  v5 = *(void **)a1;
  *(void *)a1 = 0LL;
  if (v5) {
    operator delete(v5);
  }
  return a1;
}

void HarvestInfo::~HarvestInfo(id *this)
{
}

void std::vector<std::pair<unsigned long long,unsigned long long>>::reserve(void **a1, unint64_t a2)
{
  if (a2 > ((_BYTE *)a1[2] - (_BYTE *)*a1) >> 4)
  {
    if (a2 >> 60) {
      abort();
    }
    int64_t v3 = (_BYTE *)a1[1] - (_BYTE *)*a1;
    id v4 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<std::pair<unsigned long long,unsigned long long>>>(a2);
    v5 = &v4[v3 & 0xFFFFFFFFFFFFFFF0LL];
    uint64_t v7 = &v4[16 * v6];
    v9 = (char *)*a1;
    id v8 = (char *)a1[1];
    unint64_t v10 = v5;
    if (v8 != *a1)
    {
      do
      {
        *((_OWORD *)v10 - 1) = *((_OWORD *)v8 - 1);
        v10 -= 16;
        v8 -= 16;
      }

      while (v8 != v9);
      id v8 = (char *)*a1;
    }

    *a1 = v10;
    a1[1] = v5;
    a1[2] = v7;
    if (v8) {
      operator delete(v8);
    }
  }

void *std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::find<unsigned long long>( void *a1, unint64_t a2)
{
  int8x8_t v2 = (int8x8_t)a1[1];
  if (!*(void *)&v2) {
    return 0LL;
  }
  uint8x8_t v3 = (uint8x8_t)vcnt_s8(v2);
  v3.i16[0] = vaddlv_u8(v3);
  if (v3.u32[0] > 1uLL)
  {
    unint64_t v4 = a2;
    if (*(void *)&v2 <= a2) {
      unint64_t v4 = a2 % *(void *)&v2;
    }
  }

  else
  {
    unint64_t v4 = (*(void *)&v2 - 1LL) & a2;
  }

  v5 = *(void **)(*a1 + 8 * v4);
  if (!v5) {
    return 0LL;
  }
  result = (void *)*v5;
  if (*v5)
  {
    do
    {
      unint64_t v7 = result[1];
      if (v7 == a2)
      {
        if (result[2] == a2) {
          return result;
        }
      }

      else
      {
        if (v3.u32[0] > 1uLL)
        {
          if (v7 >= *(void *)&v2) {
            v7 %= *(void *)&v2;
          }
        }

        else
        {
          v7 &= *(void *)&v2 - 1LL;
        }

        if (v7 != v4) {
          return 0LL;
        }
      }

      result = (void *)*result;
    }

    while (result);
  }

  return result;
}

void ___ZN35GTUSCSamplingStreamingManagerHelper31ReplaySingleFrameForUSCSamplingERNSt3__113unordered_mapIj24GTEncoderSampleIndexInfoNS0_4hashIjEENS0_8equal_toIjEENS0_9allocatorINS0_4pairIKjS2_EEEEEERNS1_IjNS0_6vectorI27GTCoalescedEncoderIndexInfoNS7_ISF_EEEES4_S6_NS7_INS8_IS9_SH_EEEEEERNSE_INS8_IyyEENS7_ISM_EEEEP8NSObjectU13block_pointerFvvE_block_invoke( uint64_t a1, void *a2)
{
  id v22 = a2;
  [v22 GPUStartTime];
  unint64_t v4 = NClockTimeFromCommandBufferTime(v3);
  [v22 GPUEndTime];
  unint64_t v6 = NClockTimeFromCommandBufferTime(v5);
  unint64_t v7 = v6;
  id v8 = *(void ***)(a1 + 32);
  unint64_t v10 = (unint64_t *)v8[1];
  unint64_t v9 = (unint64_t)v8[2];
  if ((unint64_t)v10 >= v9)
  {
    uint64_t v12 = ((char *)v10 - (_BYTE *)*v8) >> 4;
    unint64_t v13 = v12 + 1;
    uint64_t v14 = v9 - (void)*v8;
    if (v14 >> 3 > v13) {
      unint64_t v13 = v14 >> 3;
    }
    else {
      unint64_t v15 = v13;
    }
    unint64_t v16 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<std::pair<unsigned long long,unsigned long long>>>(v15);
    uint64_t v17 = (unint64_t *)&v16[16 * v12];
    uLong v19 = &v16[16 * v18];
    unint64_t *v17 = v4;
    v17[1] = v7;
    v11 = v17 + 2;
    double v21 = (char *)*v8;
    unint64_t v20 = (char *)v8[1];
    if (v20 != *v8)
    {
      do
      {
        *((_OWORD *)v17 - 1) = *((_OWORD *)v20 - 1);
        v17 -= 2;
        v20 -= 16;
      }

      while (v20 != v21);
      unint64_t v20 = (char *)*v8;
    }

    *id v8 = v17;
    v8[1] = v11;
    v8[2] = v19;
    if (v20) {
      operator delete(v20);
    }
  }

  else
  {
    unint64_t *v10 = v4;
    v10[1] = v6;
    v11 = v10 + 2;
  }

  v8[1] = v11;
}

void sub_5FA90( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
}

uint64_t GetRenderPassDescriptor(uint64_t *a1, uint64_t a2)
{
  if (v5[0] == 70 || v5[0] == 65) {
    return v6;
  }
  else {
    return 0LL;
  }
}

void GTUSCSamplingStreamingManagerHelper::AddEncoderSamplePoints( _DWORD *a1, void *a2, uint64_t a3, unsigned int a4, void *a5, uint64_t a6, uint64_t a7, uint64_t *a8)
{
  unsigned int v107 = a4;
  id v14 = a5;
  id v15 = DEVICEOBJECT(v14);
  unint64_t v16 = (void *)objc_claimAutoreleasedReturnValue(v15);
  int v17 = a1[538] + a1[539];
  int FuncEnumConstructorType = GetFuncEnumConstructorType(*(_DWORD *)(a3 + 8));
  if (FuncEnumConstructorType <= 27)
  {
    if (FuncEnumConstructorType == 17)
    {
      if (a4) {
        unsigned int v31 = a4;
      }
      else {
        unsigned int v31 = a7;
      }
      unsigned int v103 = v31;
      *(void *)&__int128 v104 = __PAIR64__(v17, a6);
      *((void *)&v104 + 1) = 0x200000004LL;
      uint64_t v105 = a7;
      unint64_t v106 = 0LL;
      std::__hash_table<std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>>>::__emplace_unique_key_args<unsigned int,unsigned int &,GTEncoderSampleIndexInfo>( (uint64_t)a2,  v31,  v31,  &v104);
      if (a8)
      {
        uint64_t v32 = std::__hash_table<std::__hash_value_type<unsigned int,std::vector<GTCoalescedEncoderIndexInfo>>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,std::vector<GTCoalescedEncoderIndexInfo>>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,std::vector<GTCoalescedEncoderIndexInfo>>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,std::vector<GTCoalescedEncoderIndexInfo>>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>( a8,  v31,  &v103);
        id v33 = v32;
        unint64_t v35 = v32[4];
        unint64_t v34 = v32[5];
        if (v35 >= v34)
        {
          uint64_t v59 = v32[3];
          uint64_t v60 = (uint64_t)(v35 - v59) >> 4;
          unint64_t v61 = v60 + 1;
          uint64_t v62 = v34 - v59;
          if (v62 >> 3 > v61) {
            unint64_t v61 = v62 >> 3;
          }
          else {
            unint64_t v63 = v61;
          }
          uint64_t v64 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<std::pair<unsigned long long,unsigned long long>>>(v63);
          v65 = &v64[16 * v60];
          v67 = &v64[16 * v66];
          *(_DWORD *)v65 = a6;
          *((void *)v65 + 1) = a7;
          uint64_t v36 = v65 + 16;
          id v69 = (char *)v33[3];
          v68 = (char *)v33[4];
          if (v68 != v69)
          {
            do
            {
              *((_OWORD *)v65 - 1) = *((_OWORD *)v68 - 1);
              v65 -= 16;
              v68 -= 16;
            }

            while (v68 != v69);
            v68 = (char *)v33[3];
          }

          v33[3] = v65;
          v33[4] = v36;
          v33[5] = v67;
          if (v68) {
            operator delete(v68);
          }
        }

        else
        {
          *(_DWORD *)unint64_t v35 = a6;
          *(void *)(v35 + 8) = a7;
          uint64_t v36 = (char *)(v35 + 16);
        }

        v33[4] = v36;
      }

      if (!a1[529]
        || !a1[528]
        || (objc_opt_respondsToSelector(v16, "setMTLCounterSampleLocationWithBuffer:startIndex:endIndex:") & 1) == 0)
      {
        goto LABEL_96;
      }

      id v70 = GTSampleBufferManager::CurrentSampleBuffer((GTSampleBufferManager *)(a1 + 526));
      id v38 = (void *)objc_claimAutoreleasedReturnValue(v70);
      if (!v38
        || ([v16 setMTLCounterSampleLocationWithBuffer:v38 startIndex:a1[538] endIndex:(a1[538] + 1)] & 1) == 0)
      {
        v71 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"Error, fail to set counter sample location for %lu",  a6));
        id v72 = __stdoutp;
        int v73 = g_runningInCI;
        id v74 = v71;
        v75 = (const char *)[v74 UTF8String];
        v76 = "#CI_ERROR# ";
        if (!v73) {
          v76 = "";
        }
        fprintf( v72,  "%s%s %u: %s\n",  v76,  "void GTUSCSamplingStreamingManagerHelper::AddEncoderSamplePoints(std::unordered_map<uint32_t, GTEncoderSampleI ndexInfo> &, const GTTraceFunc *, uint32_t, __strong id<MTLCommandEncoder>, size_t, uint64_t, std::unordered_m ap<uint32_t, std::vector<GTCoalescedEncoderIndexInfo>> *)",  5637,  v75);
        id v58 = v74;
        GTMTLReplay_handleError( 101,  (uint64_t)[v58 UTF8String],  "/Library/Caches/com.apple.xbs/Sources/GPUToolsDevice/GPUTools/GTMTLCapture/replayer/profile/GTUSCSamplingStreamingManager.mm",  (uint64_t)"AddEncoderSamplePoints",  5637,  1);
        goto LABEL_93;
      }
    }

    else
    {
      *(void *)&__int128 v104 = __PAIR64__(v17, a6);
      *((void *)&v104 + 1) = 0x200000002LL;
      uint64_t v105 = a7;
      unint64_t v106 = 0LL;
      std::__hash_table<std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>>>::__emplace_unique_key_args<unsigned int,unsigned int &,GTEncoderSampleIndexInfo>( (uint64_t)a2,  a4,  a4,  &v104);
      if (a8)
      {
        double v21 = std::__hash_table<std::__hash_value_type<unsigned int,std::vector<GTCoalescedEncoderIndexInfo>>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,std::vector<GTCoalescedEncoderIndexInfo>>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,std::vector<GTCoalescedEncoderIndexInfo>>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,std::vector<GTCoalescedEncoderIndexInfo>>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>( a8,  a4,  &v107);
        id v22 = v21;
        unint64_t v24 = v21[4];
        unint64_t v23 = v21[5];
        if (v24 >= v23)
        {
          uint64_t v77 = v21[3];
          uint64_t v78 = (uint64_t)(v24 - v77) >> 4;
          unint64_t v79 = v78 + 1;
          uint64_t v80 = v23 - v77;
          if (v80 >> 3 > v79) {
            unint64_t v79 = v80 >> 3;
          }
          else {
            unint64_t v81 = v79;
          }
          v82 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<std::pair<unsigned long long,unsigned long long>>>(v81);
          v83 = &v82[16 * v78];
          v85 = &v82[16 * v84];
          *(_DWORD *)v83 = a6;
          *((void *)v83 + 1) = a7;
          BOOL v25 = v83 + 16;
          char v87 = (char *)v22[3];
          v86 = (char *)v22[4];
          if (v86 != v87)
          {
            do
            {
              *((_OWORD *)v83 - 1) = *((_OWORD *)v86 - 1);
              v83 -= 16;
              v86 -= 16;
            }

            while (v86 != v87);
            v86 = (char *)v22[3];
          }

          v22[3] = v83;
          v22[4] = v25;
          v22[5] = v85;
          if (v86) {
            operator delete(v86);
          }
        }

        else
        {
          *(_DWORD *)unint64_t v24 = a6;
          *(void *)(v24 + 8) = a7;
          BOOL v25 = (char *)(v24 + 16);
        }

        v22[4] = v25;
      }

      if (!a1[529]
        || !a1[528]
        || (objc_opt_respondsToSelector(v16, "setMTLCounterSampleLocationWithBuffer:startIndex:endIndex:") & 1) == 0)
      {
        goto LABEL_96;
      }

      id v88 = GTSampleBufferManager::CurrentSampleBuffer((GTSampleBufferManager *)(a1 + 526));
      id v38 = (void *)objc_claimAutoreleasedReturnValue(v88);
      if (!v38
        || ([v16 setMTLCounterSampleLocationWithBuffer:v38 startIndex:a1[538] endIndex:(a1[538] + 1)] & 1) == 0)
      {
        uint64_t v95 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"Error, fail to set counter sample location for %lu",  a6));
        uint64_t v96 = __stdoutp;
        int v97 = g_runningInCI;
        id v98 = v95;
        v99 = (const char *)[v98 UTF8String];
        v100 = "#CI_ERROR# ";
        if (!v97) {
          v100 = "";
        }
        fprintf( v96,  "%s%s %u: %s\n",  v100,  "void GTUSCSamplingStreamingManagerHelper::AddEncoderSamplePoints(std::unordered_map<uint32_t, GTEncoderSampleI ndexInfo> &, const GTTraceFunc *, uint32_t, __strong id<MTLCommandEncoder>, size_t, uint64_t, std::unordered_m ap<uint32_t, std::vector<GTCoalescedEncoderIndexInfo>> *)",  5605,  v99);
        id v58 = v98;
        GTMTLReplay_handleError( 101,  (uint64_t)[v58 UTF8String],  "/Library/Caches/com.apple.xbs/Sources/GPUToolsDevice/GPUTools/GTMTLCapture/replayer/profile/GTUSCSamplingStreamingManager.mm",  (uint64_t)"AddEncoderSamplePoints",  5605,  1);
        goto LABEL_93;
      }
    }

LABEL_85:
    int v39 = a1[538] + 2;
    goto LABEL_86;
  }

  if (FuncEnumConstructorType == 28)
  {
    *(void *)&__int128 v104 = __PAIR64__(v17, a6);
    *((void *)&v104 + 1) = 0x200000004LL;
    uint64_t v105 = a7;
    unint64_t v106 = 0LL;
    std::__hash_table<std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>>>::__emplace_unique_key_args<unsigned int,unsigned int &,GTEncoderSampleIndexInfo>( (uint64_t)a2,  a4,  a4,  &v104);
    if (!a8) {
      goto LABEL_40;
    }
    BOOL v26 = std::__hash_table<std::__hash_value_type<unsigned int,std::vector<GTCoalescedEncoderIndexInfo>>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,std::vector<GTCoalescedEncoderIndexInfo>>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,std::vector<GTCoalescedEncoderIndexInfo>>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,std::vector<GTCoalescedEncoderIndexInfo>>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>( a8,  a4,  &v107);
    int v27 = v26;
    unint64_t v29 = v26[4];
    unint64_t v28 = v26[5];
    if (v29 < v28)
    {
      *(_DWORD *)unint64_t v29 = a6;
      *(void *)(v29 + 8) = a7;
      v30 = (char *)(v29 + 16);
LABEL_39:
      v27[4] = v30;
LABEL_40:
      if (!a1[529]
        || !a1[528]
        || (objc_opt_respondsToSelector(v16, "setMTLCounterSampleLocationWithBuffer:startIndex:endIndex:") & 1) == 0)
      {
        goto LABEL_96;
      }

      id v51 = GTSampleBufferManager::CurrentSampleBuffer((GTSampleBufferManager *)(a1 + 526));
      id v38 = (void *)objc_claimAutoreleasedReturnValue(v51);
      if (!v38
        || ([v16 setMTLCounterSampleLocationWithBuffer:v38 startIndex:a1[538] endIndex:(a1[538] + 1)] & 1) == 0)
      {
        uint64_t v52 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"Error, fail to set counter sample location for %lu",  a6));
        v53 = __stdoutp;
        int v54 = g_runningInCI;
        id v55 = v52;
        v56 = (const char *)[v55 UTF8String];
        id v57 = "#CI_ERROR# ";
        if (!v54) {
          id v57 = "";
        }
        fprintf( v53,  "%s%s %u: %s\n",  v57,  "void GTUSCSamplingStreamingManagerHelper::AddEncoderSamplePoints(std::unordered_map<uint32_t, GTEncoderSampleI ndexInfo> &, const GTTraceFunc *, uint32_t, __strong id<MTLCommandEncoder>, size_t, uint64_t, std::unordered_m ap<uint32_t, std::vector<GTCoalescedEncoderIndexInfo>> *)",  5576,  v56);
        id v58 = v55;
        GTMTLReplay_handleError( 101,  (uint64_t)[v58 UTF8String],  "/Library/Caches/com.apple.xbs/Sources/GPUToolsDevice/GPUTools/GTMTLCapture/replayer/profile/GTUSCSamplingStreamingManager.mm",  (uint64_t)"AddEncoderSamplePoints",  5576,  1);
        goto LABEL_93;
      }

      goto LABEL_85;
    }

    uint64_t v40 = v26[3];
    uint64_t v41 = (uint64_t)(v29 - v40) >> 4;
    unint64_t v42 = v41 + 1;
    if (!((unint64_t)(v41 + 1) >> 60))
    {
      uint64_t v43 = v28 - v40;
      if (v43 >> 3 > v42) {
        unint64_t v42 = v43 >> 3;
      }
      else {
        unint64_t v44 = v42;
      }
      uint64_t v45 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<std::pair<unsigned long long,unsigned long long>>>(v44);
      uint64_t v46 = &v45[16 * v41];
      uint64_t v48 = &v45[16 * v47];
      *(_DWORD *)uint64_t v46 = a6;
      *((void *)v46 + 1) = a7;
      v30 = v46 + 16;
      v50 = (char *)v27[3];
      uint64_t v49 = (char *)v27[4];
      if (v49 != v50)
      {
        do
        {
          *((_OWORD *)v46 - 1) = *((_OWORD *)v49 - 1);
          v46 -= 16;
          v49 -= 16;
        }

        while (v49 != v50);
        uint64_t v49 = (char *)v27[3];
      }

      v27[3] = v46;
      v27[4] = v30;
      v27[5] = v48;
      if (v49) {
        operator delete(v49);
      }
      goto LABEL_39;
    }

        if ((v25 & (v25 - 1)) != 0)
        {
          if (v25 <= v24) {
            end = v24 % v25;
          }
          else {
            end = v24;
          }
        }

        else
        {
          end = ((_DWORD)v25 - 1) & v24;
        }

        goto LABEL_90;
      }

            id v51 = -1LL;
          }

          v53 = v51 + v27;
          uint64_t v52 = v40 <= 79 && (v40 == 22 || v40 == 57);
          goto LABEL_94;
        }

LABEL_97:
    abort();
  }

  if (FuncEnumConstructorType == 65 || FuncEnumConstructorType == 70)
  {
    if ((objc_opt_respondsToSelector(v16, "tileWidth") & 1) != 0)
    {
      unsigned int v19 = [v16 tileWidth];
      unsigned int v20 = [v16 tileHeight];
    }

    else
    {
      unsigned int v20 = 0;
      unsigned int v19 = 0;
    }

    *(void *)&__int128 v104 = __PAIR64__(v17, a6);
    *((void *)&v104 + 1) = 0x400000000LL;
    uint64_t v105 = a7;
    unint64_t v106 = __PAIR64__(v20, v19);
    std::__hash_table<std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>>>::__emplace_unique_key_args<unsigned int,unsigned int &,GTEncoderSampleIndexInfo>( (uint64_t)a2,  a4,  a4,  &v104);
    if (a1[529])
    {
      if (a1[528]
        && (objc_opt_respondsToSelector( v16,  "setMTLCounterSampleLocationWithBuffer:vertexStartIndex:vertexEndIndex:fragmentStartIndex:fragmentEndIndex:") & 1) != 0)
      {
        id v37 = GTSampleBufferManager::CurrentSampleBuffer((GTSampleBufferManager *)(a1 + 526));
        id v38 = (void *)objc_claimAutoreleasedReturnValue(v37);
        if (v38
          && ([v16 setMTLCounterSampleLocationWithBuffer:v38 vertexStartIndex:a1[538] vertexEndIndex:(a1[538] + 1) fragmentStartIndex:(a1[538] + 2) f ragmentEndIndex:(a1[538] + 3)] & 1) != 0)
        {
          int v39 = a1[538] + 4;
LABEL_86:
          a1[538] = v39;
LABEL_95:

          goto LABEL_96;
        }

        v89 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"Error, fail to set counter sample location for %lu",  a6));
        v90 = __stdoutp;
        int v91 = g_runningInCI;
        id v92 = v89;
        v93 = (const char *)[v92 UTF8String];
        uint64_t v94 = "#CI_ERROR# ";
        if (!v91) {
          uint64_t v94 = "";
        }
        fprintf( v90,  "%s%s %u: %s\n",  v94,  "void GTUSCSamplingStreamingManagerHelper::AddEncoderSamplePoints(std::unordered_map<uint32_t, GTEncoderSampleI ndexInfo> &, const GTTraceFunc *, uint32_t, __strong id<MTLCommandEncoder>, size_t, uint64_t, std::unordered_m ap<uint32_t, std::vector<GTCoalescedEncoderIndexInfo>> *)",  5548,  v93);
        id v58 = v92;
        GTMTLReplay_handleError( 101,  (uint64_t)[v58 UTF8String],  "/Library/Caches/com.apple.xbs/Sources/GPUToolsDevice/GPUTools/GTMTLCapture/replayer/profile/GTUSCSamplingStreamingManager.mm",  (uint64_t)"AddEncoderSamplePoints",  5548,  1);
LABEL_93:

        uint64_t v101 = std::__hash_table<std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>>>::find<unsigned int>( a2,  a4);
        if (v101) {
          *((_DWORD *)v101 + 9) = 0;
        }
        goto LABEL_95;
      }
    }
  }

LABEL_96:
}

  ++self->_cache.__table_.__p2_.__value_;
LABEL_97:
  j[3] = v40;
LABEL_98:
  uint64_t v47 = JSObjectCallAsFunction( -[JSContext JSGlobalContextRef](self->_context, "JSGlobalContextRef"),  v40,  0LL,  0LL,  0LL,  &exception);
  if (exception)
  {
    uint64_t v48 = __stderrp;
    -[DYJSScriptingContext _jsValueToString:](self, "_jsValueToString:");
    uint64_t v49 = -[NSString UTF8String](self->_filename, "UTF8String");
    if (v54 >= 0) {
      v50 = __p;
    }
    else {
      v50 = (void **)__p[0];
    }
    fprintf(v48, "[DYJSScripting] %s when calling %s (%s)", (const char *)v50, a3, v49);
    if (v54 < 0) {
      operator delete(__p[0]);
    }
  }

  return JSValueToNumber(-[JSContext JSGlobalContextRef](self->_context, "JSGlobalContextRef"), v47, 0LL);
}

  v65 = 0LL;
  unint64_t v16 = 0;
LABEL_97:
  if ((_DWORD)a4)
  {
    *(_BYTE *)a1 = 1;
    *(_DWORD *)(a1 + 16) = v16;
    id v58 = v65;
    if (!v16) {
      id v58 = 0LL;
    }
    *(void *)(a1 + 8) = v58;
  }

  return v7;
}

void sub_60368(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t GTUSCSamplingStreamingManagerHelper::DispatchExpandedIndirectCommand( uint64_t a1, uint64_t a2, unint64_t *a3, char **a4, int *a5)
{
  uint64_t v9 = *(void *)a2;
  p = **(apr_pool_t ***)(a2 + 152);
  GTMTLSMContext_indirectCommandBufferResources((uint64_t)v104, *(_DWORD ***)(v9 + 40), *a3, p);
  GetExecuteCommandsInBufferArgs((uint64_t)&v98, (uint64_t)a3, *(void *)(v9 + 16));
  uint64_t v77 = (uint64_t)a3;
  Object = GTMTLSMContext_getObject(**(void **)(v9 + 40), v98, *a3);
  GTMTLCreateIndirectCommandEncoder((uint64_t)v102, Object[13]);
  memset(v96, 0, sizeof(v96));
  int v97 = 1065353216;
  memcpy(v95, (const void *)(a2 + 11312), sizeof(v95));
  id v11 = *(id *)(a2 + 8);
  uint64_t v12 = v11;
  uint64_t v79 = a2;
  int v13 = *(_DWORD *)(a2 + 11312);
  id v88 = a4;
  if (v13 == 28)
  {
    if ((GT_SUPPORT_0 & 0x10) != 0)
    {
      int v91 = v11;
      id v92 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a2 + 8), "computeCommandEncoderForKey:", *(void *)(a2 + 11320), v77));
      uint64_t v48 = v100;
      if (v100)
      {
        uint64_t v49 = 0LL;
        v83 = (unsigned int *)(a2 + 22480);
        int v87 = v99;
        uint64_t v85 = v101;
        uint64_t v50 = v103;
        do
        {
          uint64_t v51 = (v49 + v87);
          uint64_t v52 = v85 + v50 * (int)v51;
          uint64_t v105 = v52;
          memcpy(__dst, &v95[7], 0x8D0uLL);
          int IndirectCommand = GTMTLSMComputeCommandEncoder_loadIndirectCommand((uint64_t)&v95[7], v102, v52, v104);
          GTMTLReplayController_restoreComputeCommandEncoder(v92, (uint64_t)__dst, (uint64_t)&v95[7], v91);
          unint64_t v54 = v95[8];
          if (!std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::find<unsigned long long>( v96,  v95[8]))
          {
            std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__emplace_unique_key_args<unsigned long long,unsigned long long const&>( (uint64_t)v96,  v54,  v54);
            id v55 = (void *)objc_claimAutoreleasedReturnValue([v91 computePipelineStateForKey:v95[8]]);
            v56 = v55;
            if (v55)
            {
              id v57 = *(void **)(a1 + 1944);
              id ComputePipelineBinaries = getComputePipelineBinaries(v55);
              uint64_t v59 = (void *)objc_claimAutoreleasedReturnValue(ComputePipelineBinaries);
              [v57 addBinaries:v59];

              a4 = v88;
            }
          }

          DYMTLDispatchComputeCommandEncoder(v92, (uint64_t)v102, v52);
          if (IndirectCommand)
          {
            [*(id *)(a1 + 1944) addSampledCallFunctionIndex:*v83 | (unint64_t)(v51 << 32)];
            if (a4)
            {
              uint64_t v93 = 0LL;
              id v60 = DEVICEOBJECT(v92);
              unint64_t v61 = (void *)objc_claimAutoreleasedReturnValue(v60);
              [v61 commandBatchIdRangeMin:(char *)&v93 + 4 max:&v93];

              uint64_t v62 = a4[1];
              unint64_t v63 = (unint64_t)a4[2];
              if ((unint64_t)v62 >= v63)
              {
                uint64_t v65 = (v62 - *a4) >> 3;
                unint64_t v66 = v65 + 1;
                uint64_t v67 = v63 - (void)*a4;
                if (v67 >> 2 > v66) {
                  unint64_t v66 = v67 >> 2;
                }
                else {
                  unint64_t v68 = v66;
                }
                id v69 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<std::pair<unsigned int,unsigned int>>>(v68);
                v71 = &v69[8 * v65];
                *(_DWORD *)v71 = HIDWORD(v93);
                *((_DWORD *)v71 + 1) = v93;
                int v73 = *a4;
                id v72 = a4[1];
                id v74 = v71;
                if (v72 != *a4)
                {
                  do
                  {
                    uint64_t v75 = *((void *)v72 - 1);
                    v72 -= 8;
                    *((void *)v74 - 1) = v75;
                    v74 -= 8;
                  }

                  while (v72 != v73);
                  id v72 = *a4;
                }

                uint64_t v64 = v71 + 8;
                *a4 = v74;
                a4[1] = v71 + 8;
                a4[2] = &v69[8 * v70];
                if (v72) {
                  operator delete(v72);
                }
              }

              else
              {
                *(_DWORD *)uint64_t v62 = HIDWORD(v93);
                *((_DWORD *)v62 + 1) = v93;
                uint64_t v64 = v62 + 8;
              }

              a4[1] = v64;
            }
          }

          ++v49;
        }

        while (v49 != v48);
      }

      uint64_t v12 = v91;
      GTMTLReplayController_restoreComputeCommandEncoder(v92, (uint64_t)&v95[7], v79 + 11368, v91);
      goto LABEL_63;
    }
  }

  else if (v13 == 70)
  {
    id v92 = (void *)objc_claimAutoreleasedReturnValue([v11 executeIndirectCommandBufferMap]);
    v86 = a5;
    id v14 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a2 + 8) renderCommandEncoderForKey:*(void *)(a2 + 11320)]);
    uint64_t v84 = v100;
    if (v100)
    {
      uint64_t v15 = 0LL;
      uint64_t v78 = (unsigned int *)(a2 + 22480);
      int v82 = v99;
      uint64_t v80 = v103;
      uint64_t v81 = v101;
      v90 = v12;
      do
      {
        uint64_t v16 = (v15 + v82);
        uint64_t v17 = v81 + v80 * (int)v16;
        uint64_t v105 = v17;
        memcpy(__dst, &v95[7], sizeof(__dst));
        int v18 = GTMTLSMRenderCommandEncoder_loadIndirectCommand((uint64_t)&v95[7], v102, v17, v104);
        GTMTLReplayController_restoreRenderCommandEncoder(v14, (uint64_t)__dst, (uint64_t)&v95[7], v12);
        unsigned int v19 = (void *)objc_claimAutoreleasedReturnValue([v12 renderPipelineStateForKey:v95[1075]]);
        unint64_t v20 = v95[1075];
        if (!std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::find<unsigned long long>( v96,  v95[1075]))
        {
          std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__emplace_unique_key_args<unsigned long long,unsigned long long const&>( (uint64_t)v96,  v20,  v20);
          double v21 = (void *)objc_claimAutoreleasedReturnValue([v90 renderPipelineStateForKey:v95[1075]]);
          id v22 = v21;
          if (v21)
          {
            unint64_t v23 = *(void **)(a1 + 1944);
            id RenderPipelineBinaries = getRenderPipelineBinaries(v21);
            BOOL v25 = (void *)objc_claimAutoreleasedReturnValue(RenderPipelineBinaries);
            [v23 addBinaries:v25];
          }
        }

        if (v86) {
          int v26 = v18;
        }
        else {
          int v26 = 0;
        }
        if (v26 != 1 || (int v27 = *v86, *v86 == -1) || (*v86 = v27 - 1, v27))
        {
          unint64_t v28 = 0LL;
          int v29 = 0;
        }

        else
        {
          id v47 = GTUSCSamplingStreamingManagerHelper::RenderDummyDrawCall((void *)a1, v79, v14, 0LL, v95[1075], v77);
          unint64_t v28 = (void *)objc_claimAutoreleasedReturnValue(v47);
          [v14 setRenderPipelineState:v19];
          int v29 = 1;
        }

        DYMTLDrawRenderCommandEncoder(v14, (uint64_t)v102, v17, (uint64_t)v104, v92);
        if (v18)
        {
          [*(id *)(a1 + 1944) addSampledCallFunctionIndex:*v78 | (unint64_t)(v16 << 32)];
          if (v88)
          {
            uint64_t v93 = 0LL;
            id v30 = DEVICEOBJECT(v14);
            unsigned int v31 = (void *)objc_claimAutoreleasedReturnValue(v30);
            [v31 commandBatchIdRangeMin:(char *)&v93 + 4 max:&v93];

            uint64_t v32 = v88[1];
            unint64_t v33 = (unint64_t)v88[2];
            if ((unint64_t)v32 >= v33)
            {
              uint64_t v36 = (v32 - *v88) >> 3;
              unint64_t v37 = v36 + 1;
              uint64_t v38 = v33 - (void)*v88;
              if (v38 >> 2 > v37) {
                unint64_t v37 = v38 >> 2;
              }
              else {
                unint64_t v39 = v37;
              }
              uint64_t v40 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<std::pair<unsigned int,unsigned int>>>(v39);
              unint64_t v42 = &v40[8 * v36];
              *(_DWORD *)unint64_t v42 = HIDWORD(v93);
              *((_DWORD *)v42 + 1) = v93;
              unint64_t v44 = *v88;
              uint64_t v43 = v88[1];
              uint64_t v45 = v42;
              if (v43 != *v88)
              {
                do
                {
                  uint64_t v46 = *((void *)v43 - 1);
                  v43 -= 8;
                  *((void *)v45 - 1) = v46;
                  v45 -= 8;
                }

                while (v43 != v44);
                uint64_t v43 = *v88;
              }

              unint64_t v34 = v42 + 8;
              *id v88 = v45;
              v88[1] = v42 + 8;
              v88[2] = &v40[8 * v41];
              if (v43) {
                operator delete(v43);
              }
            }

            else
            {
              *(_DWORD *)uint64_t v32 = HIDWORD(v93);
              *((_DWORD *)v32 + 1) = v93;
              unint64_t v34 = v32 + 8;
            }

            v88[1] = v34;
          }

          else if (v29)
          {
            id v35 =  GTUSCSamplingStreamingManagerHelper::RenderDummyDrawCall( (void *)a1,  v79,  v14,  v28,  v95[1075],  v77);
            [v14 setRenderPipelineState:v19];
          }
        }

        ++v15;
        uint64_t v12 = v90;
      }

      while (v15 != v84);
    }

    GTMTLReplayController_restoreRenderCommandEncoder(v14, (uint64_t)&v95[7], v79 + 11368, v12);

LABEL_63:
  }

  apr_pool_clear(p);

  return std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long>>>::~__hash_table((uint64_t)v96);
}

void sub_60B08( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19, void *a20)
{
}

void ___ZN35GTUSCSamplingStreamingManagerHelper31ReplaySingleFrameForUSCSamplingERNSt3__113unordered_mapIj24GTEncoderSampleIndexInfoNS0_4hashIjEENS0_8equal_toIjEENS0_9allocatorINS0_4pairIKjS2_EEEEEERNS1_IjNS0_6vectorI27GTCoalescedEncoderIndexInfoNS7_ISF_EEEES4_S6_NS7_INS8_IS9_SH_EEEEEERNSE_INS8_IyyEENS7_ISM_EEEEP8NSObjectU13block_pointerFvvE_block_invoke_2( uint64_t a1, void *a2)
{
  id v22 = a2;
  [v22 GPUStartTime];
  unint64_t v4 = NClockTimeFromCommandBufferTime(v3);
  [v22 GPUEndTime];
  unint64_t v6 = NClockTimeFromCommandBufferTime(v5);
  unint64_t v7 = v6;
  id v8 = *(void ***)(a1 + 32);
  unint64_t v10 = (unint64_t *)v8[1];
  unint64_t v9 = (unint64_t)v8[2];
  if ((unint64_t)v10 >= v9)
  {
    uint64_t v12 = ((char *)v10 - (_BYTE *)*v8) >> 4;
    unint64_t v13 = v12 + 1;
    uint64_t v14 = v9 - (void)*v8;
    if (v14 >> 3 > v13) {
      unint64_t v13 = v14 >> 3;
    }
    else {
      unint64_t v15 = v13;
    }
    uint64_t v16 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<std::pair<unsigned long long,unsigned long long>>>(v15);
    uint64_t v17 = (unint64_t *)&v16[16 * v12];
    unsigned int v19 = &v16[16 * v18];
    unint64_t *v17 = v4;
    v17[1] = v7;
    id v11 = v17 + 2;
    double v21 = (char *)*v8;
    unint64_t v20 = (char *)v8[1];
    if (v20 != *v8)
    {
      do
      {
        *((_OWORD *)v17 - 1) = *((_OWORD *)v20 - 1);
        v17 -= 2;
        v20 -= 16;
      }

      while (v20 != v21);
      unint64_t v20 = (char *)*v8;
    }

    *id v8 = v17;
    v8[1] = v11;
    v8[2] = v19;
    if (v20) {
      operator delete(v20);
    }
  }

  else
  {
    unint64_t *v10 = v4;
    v10[1] = v6;
    id v11 = v10 + 2;
  }

  v8[1] = v11;
}

void sub_60CE4( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
}

unint64_t NClockTimeFromCommandBufferTime(double a1)
{
  unsigned int v2 = dword_5B8CC8;
  if (!dword_5B8CC8)
  {
    mach_timebase_info((mach_timebase_info_t)&NClockTimeFromCommandBufferTime(double)::timebaseInfo);
    unsigned int v2 = dword_5B8CC8;
  }

  return (unint64_t)((double)v2
                          * a1
                          * 1000000000.0
                          / (double)(NClockTimeFromCommandBufferTime(double)::timebaseInfo | 0x41CDCD6500000000uLL));
}

void *std::__allocate_at_least[abi:nn180100]<std::allocator<std::pair<unsigned long long,unsigned long long>>>( unint64_t a1)
{
  if (a1 >> 60) {
    std::__throw_bad_array_new_length[abi:nn180100]();
  }
  return operator new(16 * a1);
}

void std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__emplace_unique_key_args<unsigned long long,unsigned long long const&>( uint64_t a1, unint64_t a2, uint64_t a3)
{
  unint64_t v7 = *(void *)(a1 + 8);
  if (v7)
  {
    uint8x8_t v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      unint64_t v3 = a2;
      if (v7 <= a2) {
        unint64_t v3 = a2 % v7;
      }
    }

    else
    {
      unint64_t v3 = (v7 - 1) & a2;
    }

    unint64_t v9 = *(void **)(*(void *)a1 + 8 * v3);
    if (v9)
    {
      for (i = (void *)*v9; i; i = (void *)*i)
      {
        unint64_t v11 = i[1];
        if (v11 == a2)
        {
          if (i[2] == a2) {
            return;
          }
        }

        else
        {
          if (v8.u32[0] > 1uLL)
          {
            if (v11 >= v7) {
              v11 %= v7;
            }
          }

          else
          {
            v11 &= v7 - 1;
          }

          if (v11 != v3) {
            break;
          }
        }
      }
    }
  }

  uint64_t v12 = operator new(0x18uLL);
  void *v12 = 0LL;
  v12[1] = a2;
  v12[2] = a3;
  float v13 = (float)(unint64_t)(*(void *)(a1 + 24) + 1LL);
  float v14 = *(float *)(a1 + 32);
  if (!v7 || (float)(v14 * (float)v7) < v13)
  {
    BOOL v15 = 1LL;
    if (v7 >= 3) {
      BOOL v15 = (v7 & (v7 - 1)) != 0;
    }
    unint64_t v16 = v15 | (2 * v7);
    unint64_t v17 = vcvtps_u32_f32(v13 / v14);
    if (v16 <= v17) {
      size_t v18 = v17;
    }
    else {
      size_t v18 = v16;
    }
    std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__rehash<true>( a1,  v18);
    unint64_t v7 = *(void *)(a1 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v7 <= a2) {
        unint64_t v3 = a2 % v7;
      }
      else {
        unint64_t v3 = a2;
      }
    }

    else
    {
      unint64_t v3 = (v7 - 1) & a2;
    }
  }

  uint64_t v19 = *(void *)a1;
  unint64_t v20 = *(void **)(*(void *)a1 + 8 * v3);
  if (v20)
  {
    void *v12 = *v20;
LABEL_38:
    *unint64_t v20 = v12;
    goto LABEL_39;
  }

  void *v12 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = v12;
  *(void *)(v19 + 8 * v3) = a1 + 16;
  if (*v12)
  {
    unint64_t v21 = *(void *)(*v12 + 8LL);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v21 >= v7) {
        v21 %= v7;
      }
    }

    else
    {
      v21 &= v7 - 1;
    }

    unint64_t v20 = (void *)(*(void *)a1 + 8 * v21);
    goto LABEL_38;
  }

void sub_60F8C(_Unwind_Exception *a1)
{
}

id GTUSCSamplingStreamingManagerHelper::RenderDummyDrawCall( void *a1, uint64_t a2, void *a3, void *a4, uint64_t a5, uint64_t a6)
{
  id v11 = a3;
  id v12 = a4;
  if (!v12)
  {
    Object = GTMTLSMContext_getObject(**(void **)(*(void *)a2 + 40LL), a5, *(void *)a6);
    id v17 = *(id *)(*(void *)*a1 + 8LL);
    if (!a1[287])
    {
      size_t v18 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(*(void *)*a1 + 8) defaultDevice]);
      id v41 = 0LL;
      id v19 = objc_msgSend( v18,  "newLibraryWithSource:options:error:",  @"#include <metal_stdlib>\n\nusing namespace metal;\n\nstruct TransformMatrices\n{\n    float4 modelview_projection_matrix[4];\n};\n\nstruct VertexOutput\n{\n    float4 pos [[position]];\n    float4 color;\n};\n\nvertex VertexOutput defaultVertexProgram(uint vid [[ vertex_id ]])\n{\n    VertexOutput out;\n\n    out.pos   = float4(0.0, 0.0, 0.0, 1.0);\n    out.color = float4(0.0, 0.0, 0.0, 1.0);\n\n    return out;\n}\n\nvertex void rasterizationDisabledVertexProgram(uint vid [[ vertex_id ]])\n{\n}\n\nfragment float4 defaultFragmentProgram(VertexOutput vo [[ stage_in ]])\n{\n    return float4(vo.color.bgr, 1.0f);\n}\n\nkernel void defaultKernel()\n{\n\n}\n\n",
              0LL,
              &v41);
      id v20 = v41;

      id v21 = [v19 newFunctionWithName:@"defaultVertexProgram"];
      id v22 = (void *)a1[287];
      a1[287] = v21;

      id v23 = [v19 newFunctionWithName:@"defaultFragmentProgram"];
      unint64_t v24 = (void *)a1[286];
      a1[286] = v23;

      id v25 = [v19 newFunctionWithName:@"rasterizationDisabledVertexProgram"];
      int v26 = (void *)a1[288];
      a1[288] = v25;

      id v27 = [v19 newFunctionWithName:@"defaultKernel"];
      unint64_t v28 = (void *)a1[289];
      a1[289] = v27;
    }

    uint64_t v29 = Object[6];
    if (v29)
    {
      if (a1[287] && a1[286])
      {
        id v30 = (void *)objc_claimAutoreleasedReturnValue([v17 renderPipelineDescriptorMap]);
        MTLRenderPipelineDescriptorWithoutResourceIndex = MakeMTLRenderPipelineDescriptorWithoutResourceIndex(v29, v30);
        uint64_t v32 = (void *)objc_claimAutoreleasedReturnValue(MTLRenderPipelineDescriptorWithoutResourceIndex);

        if ([v32 isRasterizationEnabled])
        {
          [v32 setVertexFunction:a1[287]];
          [v32 setFragmentFunction:a1[286]];
        }

        else
        {
          [v32 setVertexFunction:a1[288]];
        }

        uint64_t v36 = (void *)objc_claimAutoreleasedReturnValue([v17 defaultDevice]);
        id v37 = [v36 newRenderPipelineStateWithDescriptor:v32 error:0];
LABEL_25:
        id v12 = v37;

        if (!v12) {
          goto LABEL_22;
        }
        goto LABEL_2;
      }
    }

    else
    {
      uint64_t v33 = Object[8];
      if (v33 && a1[289])
      {
        unint64_t v34 = (void *)objc_claimAutoreleasedReturnValue([v17 renderPipelineDescriptorMap]);
        MTLTileRenderPipelineDescriptor = MakeMTLTileRenderPipelineDescriptor(v33, v34);
        uint64_t v32 = (void *)objc_claimAutoreleasedReturnValue(MTLTileRenderPipelineDescriptor);

        [v32 setTileFunction:a1[289]];
        uint64_t v36 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(*(void *)*a1 + 8) defaultDevice]);
        id v37 = [v36 newRenderPipelineStateWithTileDescriptor:v32 options:0 reflection:0 error:0];
        goto LABEL_25;
      }
    }

    id v12 = 0LL;
    goto LABEL_22;
  }

LABEL_2:
  [v11 setRenderPipelineState:v12];
  int v13 = *(_DWORD *)(a6 + 8);
  if (v13 == -16137 || v13 == -15297 || v13 == -15486)
  {
    int64x2_t v39 = vdupq_n_s64(1uLL);
    uint64_t v40 = 1LL;
    [v11 dispatchThreadsPerTile:&v39];
  }

  else
  {
    [v11 drawPrimitives:3 vertexStart:0 vertexCount:0 instanceCount:1];
  }

  int v13 = 0LL;
LABEL_33:

  return v13;
}

  GTMTLReplayController_defaultDispatchFunction(a1, a2);
LABEL_16:
}

  uint8x8_t v8 = 1LL;
LABEL_176:

  return v8;
}
}

LABEL_22:
  return v12;
}

  v36[0] = @"draw call info";
  v36[1] = @"vertex fetch shader info";
  v37[0] = v34;
  v37[1] = &__NSDictionary0__struct;
  v36[2] = @"vertex shader info";
  v36[3] = @"fragment shader info";
  v37[2] = v33;
  v37[3] = v32;
  v36[4] = @"compute kernel info";
  v37[4] = v3;
  int v26 = objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v37,  v36,  5LL,  v29));

  id v27 = *(void *)(*(void *)(v30 + 32) + 8LL);
  unint64_t v28 = *(void **)(v27 + 40);
  *(void *)(v27 + 40) = v26;
}

  objc_autoreleasePoolPop(context);
}
}

  uint64_t v32 = objc_claimAutoreleasedReturnValue([v248 objectForKeyedSubscript:@"Counter Info"]);
  uint64_t v33 = (void *)*((void *)v2 + 8);
  *((void *)v2 + 8) = v32;

  unint64_t v34 = objc_claimAutoreleasedReturnValue([v248 objectForKeyedSubscript:@"Derived Counters Info Data"]);
  id v35 = (void *)*((void *)v2 + 11);
  *((void *)v2 + 11) = v34;

  uint64_t v36 = (void *)objc_claimAutoreleasedReturnValue([v248 objectForKeyedSubscript:@"Num Encoders"]);
  *((_DWORD *)v2 + 36) = [v36 unsignedIntValue];

  id v37 = (void *)objc_claimAutoreleasedReturnValue([v248 objectForKeyedSubscript:@"Source Sample Marker"]);
  *((void *)v2 + 28) = [v37 unsignedLongLongValue];

  uint64_t v38 = objc_claimAutoreleasedReturnValue([v248 objectForKeyedSubscript:@"BatchInfos"]);
  int64x2_t v39 = (void *)*((void *)v2 + 16);
  *((void *)v2 + 16) = v38;

  uint64_t v40 = objc_claimAutoreleasedReturnValue([v248 objectForKeyedSubscript:@"HighPriorityBatchInfo"]);
  v244 = a1;
  id v41 = (void *)*((void *)v2 + 9);
  *((void *)v2 + 9) = v40;

  obj = (id)objc_claimAutoreleasedReturnValue([v248 objectForKeyedSubscript:@"Fragment Counter"]);
  if (obj && [obj length])
  {
    objc_storeStrong((id *)v2, obj);
    unsigned int v2 = (char *)v259;
  }

  unint64_t v42 = objc_claimAutoreleasedReturnValue([v248 objectForKeyedSubscript:@"Timebase"]);
  uint64_t v43 = (void *)*((void *)v2 + 27);
  *((void *)v2 + 27) = v42;

  std::vector<GPUEncoderInfo>::vector(&__p, *((unsigned int *)v2 + 36));
  v247 = (void *)objc_claimAutoreleasedReturnValue([v248 objectForKeyedSubscript:@"Encoder Time Sample Data"]);
  unint64_t v44 = objc_claimAutoreleasedReturnValue([v248 objectForKeyedSubscript:@"Encoder Sample Index Data"]);
  uint64_t v45 = (void *)*((void *)v259 + 10);
  *((void *)v259 + 10) = v44;

  if (*((void *)v259 + 10) && [v247 length])
  {
    BufferView<unsigned long long>::BufferView(buf, v247);
    BufferView<EncoderSampleIndexData>::BufferView(v286, *((void **)v259 + 10));
    uint64_t v46 = objc_claimAutoreleasedReturnValue( +[NSMutableArray arrayWithCapacity:]( &OBJC_CLASS___NSMutableArray,  "arrayWithCapacity:",  *((unsigned int *)v259 + 36)));
    id v47 = (void *)*((void *)v259 + 15);
    *((void *)v259 + 15) = v46;

    if (v287)
    {
      uint64_t v48 = 0LL;
      uint64_t v49 = 0LL;
      uint64_t v50 = 8LL;
      while (1)
      {
        uint64_t v51 = [&off_59FBC0 mutableCopy];
        uint64_t v52 = v51;
        v53 = v286[0] + v50;
        *(void *)((char *)__p + v48) = *(void *)(v286[0] + v50);
        unint64_t v54 = *(void *)(v53 - 8);
        id v55 = (unint64_t *)HIWORD(v54);
        if (HIWORD(v54))
        {
          v261 = v51;
          id v57 = *(void *)buf;
          v56 = (unint64_t *)std::__allocate_at_least[abi:nn180100]<std::allocator<std::pair<unsigned int,unsigned int>>>(HIWORD(v54));
          memmove(v56, (const void *)(v57 + 8LL * v54), (v54 >> 45) & 0x7FFF8);
          id v55 = &v56[HIWORD(v54)];
          unint64_t v54 = *(void *)(v53 - 8);
          uint64_t v52 = v261;
        }

        else
        {
          v56 = 0LL;
        }

        if (!WORD2(v54)) {
          break;
        }
        if (WORD2(v54) != 2)
        {
          if (WORD2(v54) != 4) {
            goto LABEL_51;
          }
          id v58 = (double *)((char *)__p + v48);
          *(void *)((char *)__p + v48 + 8) = 1LL;
          uint64_t v59 = (double)v56[1] - (double)*v56;
          if (v59 < 0.0) {
            uint64_t v59 = 0.0;
          }
          v58[4] = v59;
          id v60 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithDouble:](&OBJC_CLASS___NSNumber, "numberWithDouble:"));
          [v52 setObject:v60 atIndexedSubscript:2];
          goto LABEL_50;
        }

        unint64_t v61 = (double *)((char *)__p + v48);
        *(void *)((char *)__p + v48 + 8) = 2LL;
        if ((unint64_t)((char *)v55 - (char *)v56) >= 9)
        {
          uint64_t v62 = (double)v56[1] - (double)*v56;
          if (v62 < 0.0) {
            uint64_t v62 = 0.0;
          }
          v61[5] = v62;
          id v60 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithDouble:](&OBJC_CLASS___NSNumber, "numberWithDouble:"));
          [v52 setObject:v60 atIndexedSubscript:1];
LABEL_50:
        }

        BOOL v15 = v8;
        unint64_t v16 = 22LL;
        return GTResourceTrackerUsingResource(v15, v16, v14, a4, a5);
      }

      size_t v18 = 0u;
      id v19 = 0LL;
      id v30 = 0u;
      unsigned int v31 = 0u;
      unint64_t v28 = 0u;
      uint64_t v29 = 0u;
      id v27 = 0u;
      id v25 = 0u;
      int v26 = 0u;
      unint64_t v24 = 0u;
      id v21 = 0u;
      id v22 = 0u;
      LODWORD(v18) = 16;
      id v20 = -1LL;
      WORD1(v25) = 2;
      id v23 = 0xFFFFFFFFFFFFFFFFLL;
      result = (uint64_t)GTMTLSMAccelerationStructure_processTraceFuncWithMap((char *)&v18, a5, (uint64_t *)v13);
      if ((void)v22) {
        result = GTResourceTrackerUsingResource(v8, 50LL, v22, a4, a5);
      }
      float v14 = v28;
      if ((void)v28) {
        goto LABEL_22;
      }
    }
  }

  return result;
}

void sub_61288(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void *std::__allocate_at_least[abi:nn180100]<std::allocator<std::pair<unsigned int,unsigned int>>>( unint64_t a1)
{
  if (a1 >> 61) {
    std::__throw_bad_array_new_length[abi:nn180100]();
  }
  return operator new(8 * a1);
}

void std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__rehash<true>( uint64_t a1, size_t __n)
{
  if (__n == 1)
  {
    size_t prime = 2LL;
  }

  else
  {
    size_t prime = __n;
    if ((__n & (__n - 1)) != 0) {
      size_t prime = std::__next_prime(__n);
    }
  }

  int8x8_t v4 = *(int8x8_t *)(a1 + 8);
  if (prime <= *(void *)&v4)
  {
    if (prime >= *(void *)&v4) {
      return;
    }
    unint64_t v11 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 32));
    if (*(void *)&v4 < 3uLL || (uint8x8_t v12 = (uint8x8_t)vcnt_s8(v4), v12.i16[0] = vaddlv_u8(v12), v12.u32[0] > 1uLL))
    {
      unint64_t v11 = std::__next_prime(v11);
    }

    else
    {
      uint64_t v13 = 1LL << -(char)__clz(v11 - 1);
      if (v11 >= 2) {
        unint64_t v11 = v13;
      }
    }

    if (prime <= v11) {
      size_t prime = v11;
    }
    if (prime >= *(void *)&v4) {
      return;
    }
    if (!prime)
    {
      unint64_t v16 = *(void **)a1;
      *(void *)a1 = 0LL;
      if (v16) {
        operator delete(v16);
      }
      *(void *)(a1 + 8) = 0LL;
      return;
    }
  }

  if (prime >> 61) {
    std::__throw_bad_array_new_length[abi:nn180100]();
  }
  double v5 = operator new(8 * prime);
  unint64_t v6 = *(void **)a1;
  *(void *)a1 = v5;
  if (v6) {
    operator delete(v6);
  }
  uint64_t v7 = 0LL;
  *(void *)(a1 + 8) = prime;
  do
    *(void *)(*(void *)a1 + 8 * v7++) = 0LL;
  while (prime != v7);
  uint8x8_t v8 = *(void **)(a1 + 16);
  if (v8)
  {
    size_t v9 = v8[1];
    uint8x8_t v10 = (uint8x8_t)vcnt_s8((int8x8_t)prime);
    v10.i16[0] = vaddlv_u8(v10);
    if (v10.u32[0] > 1uLL)
    {
      if (v9 >= prime) {
        v9 %= prime;
      }
    }

    else
    {
      v9 &= prime - 1;
    }

    *(void *)(*(void *)a1 + 8 * v9) = a1 + 16;
    float v14 = (void *)*v8;
    if (*v8)
    {
      do
      {
        size_t v15 = v14[1];
        if (v10.u32[0] > 1uLL)
        {
          if (v15 >= prime) {
            v15 %= prime;
          }
        }

        else
        {
          v15 &= prime - 1;
        }

        if (v15 != v9)
        {
          if (!*(void *)(*(void *)a1 + 8 * v15))
          {
            *(void *)(*(void *)a1 + 8 * v15) = v8;
            goto LABEL_31;
          }

          *uint8x8_t v8 = *v14;
          void *v14 = **(void **)(*(void *)a1 + 8 * v15);
          **(void **)(*(void *)a1 + 8 * v15) = v14;
          float v14 = v8;
        }

        size_t v15 = v9;
LABEL_31:
        uint8x8_t v8 = v14;
        float v14 = (void *)*v14;
        size_t v9 = v15;
      }

      while (v14);
    }
  }

void std::__hash_table<std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>>>::__emplace_unique_key_args<unsigned int,unsigned int &,GTEncoderSampleIndexInfo>( uint64_t a1, unsigned int a2, int a3, _OWORD *a4)
{
  unint64_t v8 = a2;
  unint64_t v9 = *(void *)(a1 + 8);
  if (v9)
  {
    uint8x8_t v10 = (uint8x8_t)vcnt_s8((int8x8_t)v9);
    v10.i16[0] = vaddlv_u8(v10);
    if (v10.u32[0] > 1uLL)
    {
      unint64_t v4 = a2;
      if (v9 <= a2) {
        unint64_t v4 = a2 % v9;
      }
    }

    else
    {
      unint64_t v4 = ((_DWORD)v9 - 1) & a2;
    }

    unint64_t v11 = *(uint64_t ***)(*(void *)a1 + 8 * v4);
    if (v11)
    {
      for (i = *v11; i; i = (uint64_t *)*i)
      {
        unint64_t v13 = i[1];
        if (v13 == a2)
        {
          if (*((_DWORD *)i + 4) == a2) {
            return;
          }
        }

        else
        {
          if (v10.u32[0] > 1uLL)
          {
            if (v13 >= v9) {
              v13 %= v9;
            }
          }

          else
          {
            v13 &= v9 - 1;
          }

          if (v13 != v4) {
            break;
          }
        }
      }
    }
  }

  float v14 = (char *)operator new(0x38uLL);
  *(void *)float v14 = 0LL;
  *((void *)v14 + 1) = v8;
  *((_DWORD *)v14 + 4) = a3;
  __int128 v15 = a4[1];
  *(_OWORD *)(v14 + 24) = *a4;
  *(_OWORD *)(v14 + 40) = v15;
  float v16 = (float)(unint64_t)(*(void *)(a1 + 24) + 1LL);
  float v17 = *(float *)(a1 + 32);
  if (!v9 || (float)(v17 * (float)v9) < v16)
  {
    BOOL v18 = 1LL;
    if (v9 >= 3) {
      BOOL v18 = (v9 & (v9 - 1)) != 0;
    }
    unint64_t v19 = v18 | (2 * v9);
    unint64_t v20 = vcvtps_u32_f32(v16 / v17);
    if (v19 <= v20) {
      size_t v21 = v20;
    }
    else {
      size_t v21 = v19;
    }
    std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__rehash<true>( a1,  v21);
    unint64_t v9 = *(void *)(a1 + 8);
    if ((v9 & (v9 - 1)) != 0)
    {
      if (v9 <= v8) {
        unint64_t v4 = v8 % v9;
      }
      else {
        unint64_t v4 = v8;
      }
    }

    else
    {
      unint64_t v4 = ((_DWORD)v9 - 1) & v8;
    }
  }

  uint64_t v22 = *(void *)a1;
  id v23 = *(void **)(*(void *)a1 + 8 * v4);
  if (v23)
  {
    *(void *)float v14 = *v23;
LABEL_38:
    *id v23 = v14;
    goto LABEL_39;
  }

  *(void *)float v14 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = v14;
  *(void *)(v22 + 8 * v4) = a1 + 16;
  if (*(void *)v14)
  {
    unint64_t v24 = *(void *)(*(void *)v14 + 8LL);
    if ((v9 & (v9 - 1)) != 0)
    {
      if (v24 >= v9) {
        v24 %= v9;
      }
    }

    else
    {
      v24 &= v9 - 1;
    }

    id v23 = (void *)(*(void *)a1 + 8 * v24);
    goto LABEL_38;
  }

void sub_61740(_Unwind_Exception *a1)
{
}

id GTSampleBufferManager::CurrentSampleBuffer(GTSampleBufferManager *this)
{
  int v2 = *((_DWORD *)this + 12);
  unint64_t v3 = (v2 + 3) / (*((_DWORD *)this + 2) >> 3);
  double v5 = (void *)*((void *)this + 3);
  unint64_t v4 = (void *)*((void *)this + 4);
  unint64_t v6 = v4 - v5;
  if (v6 <= v3)
  {
    if (v5 != v4) {
      *((_DWORD *)v4 - 1) = v2;
    }
    unint64_t v7 = *((void *)this + 5);
    if ((unint64_t)v4 >= v7)
    {
      uint64_t v9 = v7 - (void)v5;
      if (v9 >> 2 <= v6 + 1) {
        uint64_t v10 = v6 + 1;
      }
      else {
        uint64_t v10 = v9 >> 2;
      }
      else {
        unint64_t v11 = v10;
      }
      uint8x8_t v12 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<std::pair<unsigned int,unsigned int>>>(v11);
      unint64_t v13 = &v12[8 * v6];
      __int128 v15 = &v12[8 * v14];
      *(void *)unint64_t v13 = 0LL;
      unint64_t v8 = v13 + 8;
      float v17 = (char *)*((void *)this + 3);
      float v16 = (char *)*((void *)this + 4);
      if (v16 != v17)
      {
        do
        {
          uint64_t v18 = *((void *)v16 - 1);
          v16 -= 8;
          *((void *)v13 - 1) = v18;
          v13 -= 8;
        }

        while (v16 != v17);
        float v16 = (char *)*((void *)this + 3);
      }

      *((void *)this + 3) = v13;
      *((void *)this + 4) = v8;
      *((void *)this + 5) = v15;
      if (v16) {
        operator delete(v16);
      }
    }

    else
    {
      *unint64_t v4 = 0LL;
      unint64_t v8 = v4 + 1;
    }

    *((void *)this + 4) = v8;
    int v19 = *((_DWORD *)this + 13) + *((_DWORD *)this + 12);
    *((_DWORD *)this + 12) = 0;
    *((_DWORD *)this + 13) = v19;
    if ((unint64_t)[*((id *)this + 2) count] <= v3)
    {
      unint64_t v20 = objc_autoreleasePoolPush();
      size_t v21 = *(void **)this;
      uint64_t v22 = *((unsigned int *)this + 2);
      id v23 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"GTMTLReplayer_StreamingManager_Buffer_%u",  v3));
      id v24 = [v21 newCounterSampleBufferWithLength:v22 label:v23 error:0];

      if (v24) {
        [*((id *)this + 2) addObject:v24];
      }

      objc_autoreleasePoolPop(v20);
    }
  }

  else {
    id v25 = (void *)objc_claimAutoreleasedReturnValue([*((id *)this + 2) objectAtIndexedSubscript:v3]);
  }
  return v25;
}

void sub_618EC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t *std::__hash_table<std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>>>::find<unsigned int>( void *a1, unsigned int a2)
{
  unint64_t v2 = a1[1];
  if (!v2) {
    return 0LL;
  }
  uint8x8_t v3 = (uint8x8_t)vcnt_s8((int8x8_t)v2);
  v3.i16[0] = vaddlv_u8(v3);
  if (v3.u32[0] > 1uLL)
  {
    unint64_t v4 = a2;
    if (v2 <= a2) {
      unint64_t v4 = a2 % v2;
    }
  }

  else
  {
    unint64_t v4 = ((_DWORD)v2 - 1) & a2;
  }

  double v5 = *(uint64_t ***)(*a1 + 8 * v4);
  if (!v5) {
    return 0LL;
  }
  for (result = *v5; result; result = (uint64_t *)*result)
  {
    unint64_t v7 = result[1];
    if (v7 == a2)
    {
      if (*((_DWORD *)result + 4) == a2) {
        return result;
      }
    }

    else
    {
      if (v3.u32[0] > 1uLL)
      {
        if (v7 >= v2) {
          v7 %= v2;
        }
      }

      else
      {
        v7 &= v2 - 1;
      }

      if (v7 != v4) {
        return 0LL;
      }
    }
  }

  return result;
}

void *std::__hash_table<std::__hash_value_type<unsigned int,std::vector<GTCoalescedEncoderIndexInfo>>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,std::vector<GTCoalescedEncoderIndexInfo>>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,std::vector<GTCoalescedEncoderIndexInfo>>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,std::vector<GTCoalescedEncoderIndexInfo>>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>( uint64_t *a1, unsigned int a2, _DWORD *a3)
{
  unint64_t v6 = a2;
  unint64_t v7 = a1[1];
  if (v7)
  {
    uint8x8_t v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      unint64_t v3 = a2;
      if (v7 <= a2) {
        unint64_t v3 = a2 % v7;
      }
    }

    else
    {
      unint64_t v3 = ((_DWORD)v7 - 1) & a2;
    }

    uint64_t v9 = *(void ***)(*a1 + 8 * v3);
    if (v9)
    {
      uint64_t v10 = *v9;
      if (*v9)
      {
        do
        {
          unint64_t v11 = v10[1];
          if (v11 == a2)
          {
            if (*((_DWORD *)v10 + 4) == a2) {
              return v10;
            }
          }

          else
          {
            if (v8.u32[0] > 1uLL)
            {
              if (v11 >= v7) {
                v11 %= v7;
              }
            }

            else
            {
              v11 &= v7 - 1;
            }

            if (v11 != v3) {
              break;
            }
          }

          uint64_t v10 = (void *)*v10;
        }

        while (v10);
      }
    }
  }

  uint8x8_t v12 = a1 + 2;
  uint64_t v10 = operator new(0x30uLL);
  void *v10 = 0LL;
  v10[1] = v6;
  *((_DWORD *)v10 + 4) = *a3;
  v10[4] = 0LL;
  v10[5] = 0LL;
  v10[3] = 0LL;
  float v13 = (float)(unint64_t)(a1[3] + 1);
  float v14 = *((float *)a1 + 8);
  if (v7 && (float)(v14 * (float)v7) >= v13)
  {
    unint64_t v6 = v3;
    goto LABEL_64;
  }

  BOOL v15 = 1LL;
  if (v7 >= 3) {
    BOOL v15 = (v7 & (v7 - 1)) != 0;
  }
  unint64_t v16 = v15 | (2 * v7);
  unint64_t v17 = vcvtps_u32_f32(v13 / v14);
  if (v16 <= v17) {
    int8x8_t prime = (int8x8_t)v17;
  }
  else {
    int8x8_t prime = (int8x8_t)v16;
  }
  if (*(void *)&prime == 1LL)
  {
    int8x8_t prime = (int8x8_t)2LL;
  }

  else if ((*(void *)&prime & (*(void *)&prime - 1LL)) != 0)
  {
    int8x8_t prime = (int8x8_t)std::__next_prime(*(void *)&prime);
    unint64_t v7 = a1[1];
  }

  if (*(void *)&prime <= v7)
  {
    if (*(void *)&prime >= v7) {
      goto LABEL_60;
    }
    unint64_t v25 = vcvtps_u32_f32((float)(unint64_t)a1[3] / *((float *)a1 + 8));
    if (v7 < 3 || (uint8x8_t v26 = (uint8x8_t)vcnt_s8((int8x8_t)v7), v26.i16[0] = vaddlv_u8(v26), v26.u32[0] > 1uLL))
    {
      unint64_t v25 = std::__next_prime(v25);
    }

    else
    {
      uint64_t v27 = 1LL << -(char)__clz(v25 - 1);
      if (v25 >= 2) {
        unint64_t v25 = v27;
      }
    }

    if (*(void *)&prime <= v25) {
      int8x8_t prime = (int8x8_t)v25;
    }
    if (*(void *)&prime >= v7)
    {
      unint64_t v7 = a1[1];
      goto LABEL_60;
    }

    if (!*(void *)&prime)
    {
      unint64_t v34 = (void *)*a1;
      *a1 = 0LL;
      if (v34) {
        operator delete(v34);
      }
      unint64_t v7 = 0LL;
      a1[1] = 0LL;
      goto LABEL_60;
    }
  }

  if (*(void *)&prime >> 61) {
    std::__throw_bad_array_new_length[abi:nn180100]();
  }
  int v19 = operator new(8LL * *(void *)&prime);
  unint64_t v20 = (void *)*a1;
  *a1 = (uint64_t)v19;
  if (v20) {
    operator delete(v20);
  }
  uint64_t v21 = 0LL;
  a1[1] = (uint64_t)prime;
  do
    *(void *)(*a1 + 8 * v21++) = 0LL;
  while (*(void *)&prime != v21);
  uint64_t v22 = (void *)*v12;
  if (*v12)
  {
    unint64_t v23 = v22[1];
    uint8x8_t v24 = (uint8x8_t)vcnt_s8(prime);
    v24.i16[0] = vaddlv_u8(v24);
    if (v24.u32[0] > 1uLL)
    {
      if (v23 >= *(void *)&prime) {
        v23 %= *(void *)&prime;
      }
    }

    else
    {
      v23 &= *(void *)&prime - 1LL;
    }

    *(void *)(*a1 + 8 * v23) = v12;
    unint64_t v28 = (void *)*v22;
    if (*v22)
    {
      do
      {
        unint64_t v29 = v28[1];
        if (v24.u32[0] > 1uLL)
        {
          if (v29 >= *(void *)&prime) {
            v29 %= *(void *)&prime;
          }
        }

        else
        {
          v29 &= *(void *)&prime - 1LL;
        }

        if (v29 != v23)
        {
          if (!*(void *)(*a1 + 8 * v29))
          {
            *(void *)(*a1 + 8 * v29) = v22;
            goto LABEL_56;
          }

          *uint64_t v22 = *v28;
          void *v28 = **(void **)(*a1 + 8 * v29);
          **(void **)(*a1 + 8 * v29) = v28;
          unint64_t v28 = v22;
        }

        unint64_t v29 = v23;
LABEL_56:
        uint64_t v22 = v28;
        unint64_t v28 = (void *)*v28;
        unint64_t v23 = v29;
      }

      while (v28);
    }
  }

  unint64_t v7 = (unint64_t)prime;
LABEL_60:
  if ((v7 & (v7 - 1)) != 0)
  {
    if (v7 <= v6) {
      v6 %= v7;
    }
  }

  else
  {
    unint64_t v6 = ((_DWORD)v7 - 1) & v6;
  }

LABEL_64:
  uint64_t v30 = *a1;
  unsigned int v31 = *(void **)(*a1 + 8 * v6);
  if (v31)
  {
    void *v10 = *v31;
LABEL_72:
    *unsigned int v31 = v10;
    goto LABEL_73;
  }

  void *v10 = *v12;
  void *v12 = v10;
  *(void *)(v30 + 8 * v6) = v12;
  if (*v10)
  {
    unint64_t v32 = *(void *)(*v10 + 8LL);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v32 >= v7) {
        v32 %= v7;
      }
    }

    else
    {
      v32 &= v7 - 1;
    }

    unsigned int v31 = (void *)(*a1 + 8 * v32);
    goto LABEL_72;
  }

                    uint64_t v59 = v58 >> 3;
                    id v60 = v58 >> 3 < -1;
                    unint64_t v61 = (v58 >> 3) + 2;
                    if (v60) {
                      uint64_t v62 = v61;
                    }
                    else {
                      uint64_t v62 = v59 + 1;
                    }
                    unint64_t v63 = &v54[-8 * (v62 >> 1)];
                    uint64_t v64 = v57 - v54;
                    if (v57 != v54)
                    {
                      memmove(&v54[-8 * (v62 >> 1)], v54, v57 - v54);
                      unint64_t v54 = (char *)*(v41 - 5);
                    }

                    id v57 = &v63[v64];
                    *(v41 - 5) = &v54[-8 * (v62 >> 1)];
                    *(v41 - 4) = &v63[v64];
                    unint64_t v44 = v41 - 6;
                    unint64_t v42 = v120;
                  }

  unint64_t v28 = *(void **)a1;
  unint64_t v29 = *(void **)(*(void *)a1 + 8 * v5);
  if (v29)
  {
    void *v9 = *v29;
LABEL_72:
    void *v29 = v9;
    goto LABEL_73;
  }

  void *v9 = *((void *)a1 + 2);
  *((void *)a1 + 2) = v9;
  v28[v5] = a1 + 4;
  if (*v9)
  {
    uint64_t v30 = *(void *)(*v9 + 8LL);
    if ((v6 & (v6 - 1)) != 0)
    {
      if (v30 >= v6) {
        v30 %= v6;
      }
    }

    else
    {
      v30 &= v6 - 1;
    }

    unint64_t v29 = (void *)(*(void *)a1 + 8 * v30);
    goto LABEL_72;
  }

  unint64_t v29 = *(void **)a1;
  uint64_t v30 = *(void **)(*(void *)a1 + 8 * v6);
  if (v30)
  {
    void *v10 = *v30;
LABEL_72:
    void *v30 = v10;
    goto LABEL_73;
  }

  void *v10 = *((void *)a1 + 2);
  *((void *)a1 + 2) = v10;
  v29[v6] = a1 + 4;
  if (*v10)
  {
    unsigned int v31 = *(void *)(*v10 + 8LL);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v31 >= v7) {
        v31 %= v7;
      }
    }

    else
    {
      v31 &= v7 - 1;
    }

    uint64_t v30 = (void *)(*(void *)a1 + 8 * v31);
    goto LABEL_72;
  }

            if ([v33 textureType] == &dword_4 || objc_msgSend(v33, "textureType") == &dword_8)
            {
              uint64_t v59 = objc_msgSend( v33,  "newTextureViewWithPixelFormat:textureType:levels:slices:",  v31,  objc_msgSend(v33, "textureType"),  v35,  1,  v34,  1);

              if (!v59)
              {
                id v60 = v17;
                v102 = @"GTErrorKeyMTLPixelFormat";
                unint64_t v61 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedInteger:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedInteger:",  v31));
                uint64_t v103 = v61;
                uint64_t v62 = &v103;
                unint64_t v63 = &v102;
                goto LABEL_79;
              }

              uint64_t v33 = v59;
            }

            goto LABEL_68;
          }

          uint64_t v52 = objc_claimAutoreleasedReturnValue(-[MTLRenderPassDescriptor stencilAttachment](v48, "stencilAttachment"));

          uint64_t v50 = (void *)v52;
        }

        else
        {
          unsigned int v31 = v92;
          if ((v46 & 0x40) != 0)
          {
            uint64_t v50 = (void *)objc_claimAutoreleasedReturnValue(-[MTLRenderPassDescriptor stencilAttachment](v47, "stencilAttachment"));
          }

          else
          {
            uint64_t v49 = (void *)objc_claimAutoreleasedReturnValue(-[MTLRenderPassDescriptor colorAttachments](v47, "colorAttachments"));
            uint64_t v50 = (void *)objc_claimAutoreleasedReturnValue([v49 objectAtIndexedSubscript:0]);
          }
        }

        float v14 = v82;
        [v50 setTexture:v18];
        [v50 setLevel:v91];
        [v50 setSlice:v89];
        [v50 setDepthPlane:v45];
        [v50 setResolveTexture:v33];
        [v50 setLoadAction:1];
        [v50 setStoreAction:2];
        goto LABEL_58;
      }

      int v19 = v87;
      if (v43)
      {
        unint64_t v106 = NSUnderlyingErrorKey;
        unsigned int v107 = v43;
        uint64_t v64 = v43;
        uint64_t v65 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v107,  &v106,  1LL));
      }

      else
      {
        uint64_t v64 = 0LL;
        uint64_t v65 = 0LL;
      }

      float v14 = v82;
      id v60 = v83;
      uint64_t v10 = v74;
      unint64_t v11 = v76;
      GTMTLReplay_fillError(v73, 101, v65);
      if (v73) {
        v71 = *v73;
      }
      else {
        v71 = 0LL;
      }
      GTMTLReplay_handleNSError(v71);

      uint64_t v70 = v88;
LABEL_88:

      unint64_t v68 = 0LL;
LABEL_89:

      return v68;
    default:
      uint64_t v30 = 0;
      uint8x8_t v8 = v92;
      unsigned int v31 = v92;
      if (v20 == v92) {
        goto LABEL_28;
      }
      goto LABEL_23;
  }

  unint64_t v34 = *(float ***)(*(void *)(v6 + 312) + 8 * v8);
  i = (float *)v68[0];
  if (v34)
  {
    *(void *)v68[0] = *v34;
LABEL_72:
    *unint64_t v34 = i;
    goto LABEL_73;
  }

  *(void *)v68[0] = *(void *)(v6 + 328);
  *(void *)(v6 + 328) = i;
  *(void *)(*(void *)(v6 + 312) + 8 * v8) = v15;
  if (*(void *)i)
  {
    id v35 = *(void *)(*(void *)i + 8LL);
    if ((v9 & (v9 - 1)) != 0)
    {
      if (v35 >= v9) {
        v35 %= v9;
      }
    }

    else
    {
      v35 &= v9 - 1;
    }

    unint64_t v34 = (float **)(*(void *)(v6 + 312) + 8 * v35);
    goto LABEL_72;
  }

    id v37 = *((void *)v7 + 1);
    uint64_t v38 = (uint8x8_t)vcnt_s8((int8x8_t)v12);
    v38.i16[0] = vaddlv_u8(v38);
    if (v38.u32[0] > 1uLL)
    {
      if (v37 >= v12) {
        v37 %= v12;
      }
    }

    else
    {
      v37 &= v12 - 1;
    }

    int64x2_t v39 = *a1;
    uint64_t v40 = *(void **)(*a1 + 8 * v37);
    if (v40)
    {
      *(void *)unint64_t v7 = *v40;
    }

    else
    {
      *(void *)unint64_t v7 = *v6;
      *unint64_t v6 = v7;
      *(void *)(v39 + 8 * v37) = v6;
      if (!*(void *)v7)
      {
LABEL_77:
        ++a1[3];
        v44[0] = 0LL;
        goto LABEL_78;
      }

      id v41 = *(void *)(*(void *)v7 + 8LL);
      if (v38.u32[0] > 1uLL)
      {
        if (v41 >= v12) {
          v41 %= v12;
        }
      }

      else
      {
        v41 &= v12 - 1;
      }

      uint64_t v40 = (void *)(*a1 + 8 * v41);
    }

    *uint64_t v40 = v7;
    goto LABEL_77;
  }

  while (1)
  {
    int v19 = *((void *)v18 + 1);
    if (v19 == v13) {
      break;
    }
    if (v15 > 1)
    {
      if (v19 >= v12) {
        v19 %= v12;
      }
    }

    else
    {
      v19 &= v12 - 1;
    }

    if (v19 != v16) {
      goto LABEL_23;
    }
LABEL_22:
    uint64_t v18 = *(char **)v18;
    if (!v18) {
      goto LABEL_23;
    }
  }

  unint64_t v7 = v18;
LABEL_78:
  std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,std::vector<std::string>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,std::vector<std::string>>,void *>>>>::reset[abi:nn180100]((uint64_t)v44);
  return v7;
}

  uint64_t v30 = *a1;
  unsigned int v31 = *(void **)(*a1 + 8 * v5);
  if (v31)
  {
    uint64_t *i = *v31;
LABEL_72:
    *unsigned int v31 = i;
    goto LABEL_73;
  }

  uint64_t *i = *v12;
  void *v12 = i;
  *(void *)(v30 + 8 * v5) = v12;
  if (*i)
  {
    unint64_t v32 = *(void *)(*i + 8LL);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v32 >= v7) {
        v32 %= v7;
      }
    }

    else
    {
      v32 &= v7 - 1;
    }

    unsigned int v31 = (void *)(*a1 + 8 * v32);
    goto LABEL_72;
  }

  uint64_t v30 = *a1;
  unsigned int v31 = *(void **)(*a1 + 8 * v5);
  if (v31)
  {
    uint64_t *i = *v31;
LABEL_72:
    *unsigned int v31 = i;
    goto LABEL_73;
  }

  uint64_t *i = *v12;
  void *v12 = i;
  *(void *)(v30 + 8 * v5) = v12;
  if (*i)
  {
    unint64_t v32 = *(void *)(*i + 8LL);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v32 >= v7) {
        v32 %= v7;
      }
    }

    else
    {
      v32 &= v7 - 1;
    }

    unsigned int v31 = (void *)(*a1 + 8 * v32);
    goto LABEL_72;
  }

  uint64_t v30 = *a1;
  unsigned int v31 = *(void **)(*a1 + 8 * v5);
  if (v31)
  {
    uint64_t *i = *v31;
LABEL_72:
    *unsigned int v31 = i;
    goto LABEL_73;
  }

  uint64_t *i = *v12;
  void *v12 = i;
  *(void *)(v30 + 8 * v5) = v12;
  if (*i)
  {
    unint64_t v32 = *(void *)(*i + 8LL);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v32 >= v7) {
        v32 %= v7;
      }
    }

    else
    {
      v32 &= v7 - 1;
    }

    unsigned int v31 = (void *)(*a1 + 8 * v32);
    goto LABEL_72;
  }

  unint64_t v28 = *(void **)a1;
  unint64_t v29 = *(void **)(*(void *)a1 + 8 * v5);
  if (v29)
  {
    void *v9 = *v29;
LABEL_72:
    void *v29 = v9;
    goto LABEL_73;
  }

  void *v9 = *((void *)a1 + 2);
  *((void *)a1 + 2) = v9;
  v28[v5] = a1 + 4;
  if (*v9)
  {
    uint64_t v30 = *(void *)(*v9 + 8LL);
    if ((v6 & (v6 - 1)) != 0)
    {
      if (v30 >= v6) {
        v30 %= v6;
      }
    }

    else
    {
      v30 &= v6 - 1;
    }

    unint64_t v29 = (void *)(*(void *)a1 + 8 * v30);
    goto LABEL_72;
  }

  unsigned int v31 = *(uint64_t **)(*(void *)a1 + 8 * v6);
  i = v35[0];
  if (v31)
  {
    *(void *)v35[0] = *v31;
LABEL_72:
    *unsigned int v31 = i;
    goto LABEL_73;
  }

  *(void *)v35[0] = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = i;
  *(void *)(*(void *)a1 + 8 * v6) = v12;
  if (*(void *)i)
  {
    unint64_t v32 = *(void *)(*(void *)i + 8LL);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v32 >= v7) {
        v32 %= v7;
      }
    }

    else
    {
      v32 &= v7 - 1;
    }

    unsigned int v31 = (uint64_t *)(*(void *)a1 + 8 * v32);
    goto LABEL_72;
  }

  unint64_t v29 = *(void **)a1;
  uint64_t v30 = *(void **)(*(void *)a1 + 8 * v6);
  if (v30)
  {
    void *v10 = *v30;
LABEL_72:
    void *v30 = v10;
    goto LABEL_73;
  }

  void *v10 = *((void *)a1 + 2);
  *((void *)a1 + 2) = v10;
  v29[v6] = a1 + 4;
  if (*v10)
  {
    unsigned int v31 = *(void *)(*v10 + 8LL);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v31 >= v7) {
        v31 %= v7;
      }
    }

    else
    {
      v31 &= v7 - 1;
    }

    uint64_t v30 = (void *)(*(void *)a1 + 8 * v31);
    goto LABEL_72;
  }

LABEL_73:
  ++a1[3];
  return v10;
}

  ++*((void *)a1 + 3);
  return (char *)(v9 + 3);
}

  ++*((void *)a1 + 3);
  return v10;
}

      int v82 = v43;
      v83 = DEVICEOBJECT(v43);
      uint64_t v30 = (void *)objc_claimAutoreleasedReturnValue(v83);

      uint64_t v84 = [v30 gpuResourceID];
      *(void *)((char *)[v88 contents] + v20 + a6) = v84;
      if (v32 != v84)
      {
        v56 = (apr_pool_t **)a1[4];
        v90 = *a7;
        int v91 = *((void *)a7 + 2);
        id v57 = (uint64_t)v84;
        goto LABEL_75;
      }

            return;
          }

  v68[0] = 0LL;
  ++*(void *)(v6 + 336);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<unsigned long long,std::unordered_map<int,unsigned int>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<unsigned long long,std::unordered_map<int,unsigned int>>,void *>>>>::reset[abi:nn180100]((uint64_t)v68);
LABEL_74:
  uint64_t v36 = [v67 subCommandIndex];
  id v37 = v36;
  uint64_t v38 = v36;
  int64x2_t v39 = *((void *)i + 4);
  if (v39)
  {
    uint64_t v40 = (uint8x8_t)vcnt_s8((int8x8_t)v39);
    v40.i16[0] = vaddlv_u8(v40);
    if (v40.u32[0] > 1uLL)
    {
      uint64_t v9 = v36;
      if (v39 <= v36) {
        uint64_t v9 = v36 % v39;
      }
    }

    else
    {
      uint64_t v9 = (v39 - 1) & v36;
    }

    id v41 = *(void ***)(*((void *)i + 3) + 8 * v9);
    if (v41)
    {
      unint64_t v42 = *v41;
      if (*v41)
      {
        do
        {
          uint64_t v43 = v42[1];
          if (v43 == v36)
          {
            if (*((_DWORD *)v42 + 4) == v36) {
              goto LABEL_147;
            }
          }

          else
          {
            if (v40.u32[0] > 1uLL)
            {
              if (v43 >= v39) {
                v43 %= v39;
              }
            }

            else
            {
              v43 &= v39 - 1;
            }

            if (v43 != v9) {
              break;
            }
          }

          unint64_t v42 = (void *)*v42;
        }

        while (v42);
      }
    }
  }

  unint64_t v42 = operator new(0x18uLL);
  *unint64_t v42 = 0LL;
  v42[1] = v38;
  *((_DWORD *)v42 + 4) = v37;
  *((_DWORD *)v42 + 5) = 0;
  unint64_t v44 = (float)(unint64_t)(*((void *)i + 6) + 1LL);
  uint64_t v45 = i[14];
  if (!v39 || (float)(v45 * (float)v39) < v44)
  {
    uint64_t v46 = 1LL;
    if (v39 >= 3) {
      uint64_t v46 = (v39 & (v39 - 1)) != 0;
    }
    id v47 = v46 | (2 * v39);
    uint64_t v48 = vcvtps_u32_f32(v44 / v45);
    if (v47 <= v48) {
      uint64_t v49 = (int8x8_t)v48;
    }
    else {
      uint64_t v49 = (int8x8_t)v47;
    }
    if (*(void *)&v49 == 1LL)
    {
      uint64_t v49 = (int8x8_t)2LL;
    }

    else if ((*(void *)&v49 & (*(void *)&v49 - 1LL)) != 0)
    {
      uint64_t v49 = (int8x8_t)std::__next_prime(*(void *)&v49);
    }

    int64x2_t v39 = *((void *)i + 4);
    if (*(void *)&v49 > v39) {
      goto LABEL_103;
    }
    if (*(void *)&v49 < v39)
    {
      v56 = vcvtps_u32_f32((float)*((unint64_t *)i + 6) / i[14]);
      if (v39 < 3 || (id v57 = (uint8x8_t)vcnt_s8((int8x8_t)v39), v57.i16[0] = vaddlv_u8(v57), v57.u32[0] > 1uLL))
      {
        v56 = std::__next_prime(v56);
      }

      else
      {
        id v58 = 1LL << -(char)__clz(v56 - 1);
        if (v56 >= 2) {
          v56 = v58;
        }
      }

      if (*(void *)&v49 <= v56) {
        uint64_t v49 = (int8x8_t)v56;
      }
      if (*(void *)&v49 >= v39)
      {
        int64x2_t v39 = *((void *)i + 4);
      }

      else
      {
        if (v49)
        {
LABEL_103:
          if (*(void *)&v49 >> 61) {
            std::__throw_bad_array_new_length[abi:nn180100]();
          }
          uint64_t v50 = operator new(8LL * *(void *)&v49);
          uint64_t v51 = (void *)*((void *)i + 3);
          *((void *)i + 3) = v50;
          if (v51) {
            operator delete(v51);
          }
          uint64_t v52 = 0LL;
          *((int8x8_t *)i + 4) = v49;
          do
            *(void *)(*((void *)i + 3) + 8 * v52++) = 0LL;
          while (*(void *)&v49 != v52);
          v53 = (void *)*((void *)i + 5);
          if (v53)
          {
            unint64_t v54 = v53[1];
            id v55 = (uint8x8_t)vcnt_s8(v49);
            v55.i16[0] = vaddlv_u8(v55);
            if (v55.u32[0] > 1uLL)
            {
              if (v54 >= *(void *)&v49) {
                v54 %= *(void *)&v49;
              }
            }

            else
            {
              v54 &= *(void *)&v49 - 1LL;
            }

            *(void *)(*((void *)i + 3) + 8 * v54) = i + 10;
            uint64_t v59 = (void *)*v53;
            if (*v53)
            {
              do
              {
                id v60 = v59[1];
                if (v55.u32[0] > 1uLL)
                {
                  if (v60 >= *(void *)&v49) {
                    v60 %= *(void *)&v49;
                  }
                }

                else
                {
                  v60 &= *(void *)&v49 - 1LL;
                }

                if (v60 != v54)
                {
                  unint64_t v61 = *((void *)i + 3);
                  if (!*(void *)(v61 + 8 * v60))
                  {
                    *(void *)(v61 + 8 * v60) = v53;
                    goto LABEL_128;
                  }

                  FILE *v53 = *v59;
                  void *v59 = **(void **)(*((void *)i + 3) + 8 * v60);
                  **(void **)(*((void *)i + 3) + 8 * v60) = v59;
                  uint64_t v59 = v53;
                }

                id v60 = v54;
LABEL_128:
                v53 = v59;
                uint64_t v59 = (void *)*v59;
                unint64_t v54 = v60;
              }

              while (v59);
            }
          }

          int64x2_t v39 = (unint64_t)v49;
          goto LABEL_132;
        }

        unint64_t v66 = (void *)*((void *)i + 3);
        *((void *)i + 3) = 0LL;
        if (v66) {
          operator delete(v66);
        }
        int64x2_t v39 = 0LL;
        *((void *)i + 4) = 0LL;
      }
    }

  v46[0] = 0LL;
  ++*(void *)(v10 + 72);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<unsigned long long,std::pair<ShaderBinaryInfo * {__strong},std::string>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<unsigned long long,std::pair<ShaderBinaryInfo * {__strong},std::string>>,void *>>>>::reset[abi:nn180100]((uint64_t)v46);
LABEL_74:
  if (SHIBYTE(v45) < 0) {
    operator delete((void *)__p);
  }
}

  ++a1[3];
  return i;
}

  ++a1[3];
  return i;
}

  ++a1[3];
  return i;
}

  ++*((void *)a1 + 3);
  return (char *)(v9 + 3);
}

  dispatch_semaphore_wait(*(dispatch_semaphore_t *)(v84 + 120), 0xFFFFFFFFFFFFFFFFLL);
  [*(id *)v84 removeObject:WeakRetained];
  dispatch_semaphore_signal(*(dispatch_semaphore_t *)(v84 + 120));
  uint64_t v79 = g_signpostLog;
  uint64_t v80 = (os_log_s *)v79;
  uint64_t v81 = *(void *)(a1 + 48);
  if (v81 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled((os_log_t)v79))
  {
    *(_WORD *)buf = 0;
    _os_signpost_emit_with_name_impl( &dword_0,  v80,  OS_SIGNPOST_INTERVAL_END,  v81,  "ShaderProfiler-ProcessStreamedDataPostProcessing",  (const char *)&unk_3189BB,  buf,  2u);
  }
}

  v35[0] = 0LL;
  ++*(void *)(a1 + 24);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<unsigned int,RingBufferSampledData>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<unsigned int,RingBufferSampledData>,void *>>>>::reset[abi:nn180100](v35);
  return i;
}

  ++*((void *)a1 + 3);
  return v10;
}

void sub_61DA0(_Unwind_Exception *a1)
{
}

void std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<unsigned int,std::vector<GTCoalescedEncoderIndexInfo>>,void *>>>::operator()[abi:nn180100]( char a1, void *__p)
{
  if (a1)
  {
    unint64_t v3 = (void *)__p[3];
    if (v3)
    {
      __p[4] = v3;
      operator delete(v3);
    }
  }

  else if (!__p)
  {
    return;
  }

  operator delete(__p);
}

void GTUSCSamplingStreamingManagerHelper::InitQueryShaderInfo( GTUSCSamplingStreamingManagerHelper *this, GTUSCSamplingStreamingManager *a2)
{
  unint64_t v3 = (GTUSCSamplingStreamingManagerHelper *)[*((id *)&xmmword_5B8CE0 + 1) count];
  if (v3)
  {
    unint64_t v4 = v3;
    unint64_t v5 = v3 != (GTUSCSamplingStreamingManagerHelper *)((char *)&dword_0 + 1);
    unint64_t v6 = (unint64_t)v3 - 1 <= 1 ? 1uLL : (unint64_t)v3 - 1;
    std::vector<std::vector<GTMMappedBuffer>>::reserve(&xmmword_5B9600, v6);
    std::vector<std::vector<GTMMappedBuffer>>::reserve(&qword_5B95E8, v6);
    std::vector<std::vector<GTMMappedBuffer>>::reserve(&xmmword_5B9630, v6);
    std::vector<std::vector<NSObject  {objcproto21OS_dispatch_semaphore}* {__strong}>>::reserve(&qword_5B9648, v6);
    std::vector<std::vector<NSObject  {objcproto21OS_dispatch_semaphore}* {__strong}>>::reserve(&xmmword_5B9660, v6);
    std::vector<NSObject  {objcproto21OS_dispatch_semaphore}* {__strong}>::reserve((void *)&xmmword_5B9670 + 1, v6);
    if ((unint64_t)v4 > v5)
    {
      do
        GTUSCSamplingStreamingManagerHelper::SetupBufferForSourceAtIndex((GTUSCSamplingStreamingManagerHelper *)v5++, 1);
      while (v4 != (GTUSCSamplingStreamingManagerHelper *)v5);
    }
  }

  uint64_t v7 = objc_claimAutoreleasedReturnValue(+[NSMutableArray arrayWithCapacity:](&OBJC_CLASS___NSMutableArray, "arrayWithCapacity:", 7LL));
  uint8x8_t v8 = (void *)qword_5B9498;
  qword_5B9498 = v7;

  for (uint64_t i = 0LL; i != 7; ++i)
  {
    uint64_t v10 = (void *)qword_5B9498;
    unint64_t v11 = (void *)objc_claimAutoreleasedReturnValue([&off_59F830 objectAtIndexedSubscript:i]);
    uint8x8_t v12 = (void *)objc_claimAutoreleasedReturnValue( +[GPURawCounterSelect selectWithName:options:]( &OBJC_CLASS___GPURawCounterSelect,  "selectWithName:options:",  v11,  0LL));
    [v10 addObject:v12];
  }

  float v13 = (void *)objc_claimAutoreleasedReturnValue( [*(id *)(GTUSCSamplingStreamingManagerHelper::Instance(void)::instance + 40) objectForKeyedSubscript:@"profileCounters"]);
  id v110 = [v13 mutableCopy];

  float v14 = (void *)objc_claimAutoreleasedReturnValue( [*(id *)(GTUSCSamplingStreamingManagerHelper::Instance(void)::instance + 40) objectForKeyedSubscript:@"profileCounters32"]);
  uint64_t v105 = (void *)objc_claimAutoreleasedReturnValue(+[NSSet setWithArray:](&OBJC_CLASS___NSSet, "setWithArray:", v14));

  unint64_t v15 = (unint64_t)[(id)qword_5B94B8 count];
  char v16 = HIDWORD(qword_5B9548) > 1;
  uint64_t v17 = objc_claimAutoreleasedReturnValue( +[NSMutableArray arrayWithCapacity:]( NSMutableArray,  "arrayWithCapacity:",  [*((id *)&xmmword_5B8CE0 + 1) count]));
  uint64_t v18 = (void *)xmmword_5B94A8;
  *(void *)&xmmword_5B94A8 = v17;

  unint64_t v114 = v15 >> v16;
  unint64_t v106 = (void *)objc_claimAutoreleasedReturnValue( +[NSMutableArray arrayWithCapacity:]( NSMutableArray,  "arrayWithCapacity:",  (char *)[v110 count] + (v15 >> v16)));
  int v19 = (void *)objc_claimAutoreleasedReturnValue( +[NSMutableSet setWithCapacity:]( NSMutableSet,  "setWithCapacity:",  [v110 count]));
  for (unsigned int j = 0; (unint64_t)[v110 count] > j; ++j)
  {
    uint64_t v21 = (void *)objc_claimAutoreleasedReturnValue([v110 objectAtIndexedSubscript:j]);
    unsigned int v22 = [v105 containsObject:v21];

    unint64_t v23 = (void *)objc_claimAutoreleasedReturnValue([v110 objectAtIndexedSubscript:j]);
    if (v22) {
      uint64_t v24 = 32LL;
    }
    else {
      uint64_t v24 = 16LL;
    }
    v129 = @"Width";
    unint64_t v25 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInteger:](&OBJC_CLASS___NSNumber, "numberWithUnsignedInteger:", v24));
    v130 = v25;
    uint8x8_t v26 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v130,  &v129,  1LL));
    uint64_t v27 = (void *)objc_claimAutoreleasedReturnValue( +[GPURawCounterSelect selectWithName:options:]( &OBJC_CLASS___GPURawCounterSelect,  "selectWithName:options:",  v23,  v26));
    [v106 addObject:v27];

    unint64_t v28 = (void *)objc_claimAutoreleasedReturnValue([v110 objectAtIndexedSubscript:j]);
    [v19 addObject:v28];
  }

  unint64_t v29 = (void *)objc_claimAutoreleasedReturnValue( +[NSMutableDictionary dictionaryWithCapacity:]( NSMutableDictionary,  "dictionaryWithCapacity:",  [v110 count]));
  for (unint64_t k = 0; k < (unint64_t)[*((id *)&xmmword_5B8CE0 + 1) count]; ++k)
  {
    uint64_t v30 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*((id *)&xmmword_5B8CE0 + 1), "objectAtIndexedSubscript:"));
    unsigned int v31 = (void *)objc_claimAutoreleasedReturnValue([v30 availableCounters]);
    __int128 v121 = 0u;
    __int128 v122 = 0u;
    __int128 v119 = 0u;
    __int128 v120 = 0u;
    id v32 = v31;
    id v33 = [v32 countByEnumeratingWithState:&v119 objects:v128 count:16];
    if (v33)
    {
      uint64_t v34 = *(void *)v120;
      do
      {
        for (m = 0LL; m != v33; m = (char *)m + 1)
        {
          if (*(void *)v120 != v34) {
            objc_enumerationMutation(v32);
          }
          uint64_t v36 = *(void **)(*((void *)&v119 + 1) + 8LL * (void)m);
          id v37 = (void *)objc_claimAutoreleasedReturnValue([v36 name]);
          unsigned int v38 = [v19 containsObject:v37];

          if (v38)
          {
            int64x2_t v39 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedInteger:]( NSNumber,  "numberWithUnsignedInteger:",  [v36 counterValueType]));
            uint64_t v40 = (void *)objc_claimAutoreleasedReturnValue([v36 name]);
            [v29 setObject:v39 forKeyedSubscript:v40];
          }
        }

        id v33 = [v32 countByEnumeratingWithState:&v119 objects:v128 count:16];
      }

      while (v33);
    }
  }

  id v41 = GTUSCSamplingStreamingManagerHelper::SubDividedCounterDictionary(v106);
  v102 = (void *)objc_claimAutoreleasedReturnValue(v41);
  unint64_t v42 = (void *)objc_claimAutoreleasedReturnValue([v102 objectForKeyedSubscript:@"passList"]);
  unsigned int v107 = (void *)objc_claimAutoreleasedReturnValue([v42 objectAtIndexedSubscript:0]);

  uint64_t v101 = (void *)objc_claimAutoreleasedReturnValue( +[NSMutableArray arrayWithCapacity:]( NSMutableArray,  "arrayWithCapacity:",  4 * (void)[(id)qword_5B94B8 count] + 7));
  uint64_t v103 = (void *)objc_claimAutoreleasedReturnValue( +[NSMutableArray arrayWithCapacity:]( NSMutableArray,  "arrayWithCapacity:",  [v106 count]));
  __int128 v104 = (void *)objc_claimAutoreleasedReturnValue( +[NSMutableDictionary dictionaryWithCapacity:]( NSMutableDictionary,  "dictionaryWithCapacity:",  [v102 count]));
  unint64_t v43 = 0LL;
  unint64_t v111 = 0LL;
  unint64_t v113 = 0LL;
  while (v43 < (unint64_t)[v107 count])
  {
    v108 = (void *)objc_claimAutoreleasedReturnValue([v107 objectAtIndexedSubscript:v43]);
    unint64_t v109 = v43;
    if ([v108 count])
    {
      id v45 = (id)objc_claimAutoreleasedReturnValue( +[NSMutableArray arrayWithCapacity:]( NSMutableArray,  "arrayWithCapacity:",  [v108 count]));
      __int128 v117 = 0u;
      __int128 v118 = 0u;
      __int128 v115 = 0u;
      __int128 v116 = 0u;
      id v46 = v108;
      id v47 = [v46 countByEnumeratingWithState:&v115 objects:v127 count:16];
      if (v47)
      {
        uint64_t v48 = *(void *)v116;
        do
        {
          for (n = 0LL; n != v47; n = (char *)n + 1)
          {
            if (*(void *)v116 != v48) {
              objc_enumerationMutation(v46);
            }
            uint64_t v50 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(*((void *)&v115 + 1) + 8 * (void)n) name]);
            [v45 addObject:v50];
          }

          id v47 = [v46 countByEnumeratingWithState:&v115 objects:v127 count:16];
        }

        while (v47);
      }

      uint64_t v51 = (void *)objc_claimAutoreleasedReturnValue([*((id *)&xmmword_5B8CE0 + 1) objectAtIndexedSubscript:v109]);
      uint64_t v52 = (void *)objc_claimAutoreleasedReturnValue([v51 name]);
      [v104 setObject:v45 forKeyedSubscript:v52];

      [v103 addObjectsFromArray:v45];
      id v53 = [(id)qword_5B9498 copy];
      unint64_t v54 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableArray arrayWithArray:](&OBJC_CLASS___NSMutableArray, "arrayWithArray:", v53));

      [v54 addObjectsFromArray:v46];
      [(id)xmmword_5B94A8 addObject:v54];
      id v55 = (void *)objc_claimAutoreleasedReturnValue([*((id *)&xmmword_5B8CE0 + 1) objectAtIndexedSubscript:v109]);
      v56 = (void *)objc_claimAutoreleasedReturnValue([v55 name]);
      if ([v56 isEqualToString:@"RDE_0"])
      {

        goto LABEL_45;
      }

      uint64_t v62 = (void *)objc_claimAutoreleasedReturnValue([*((id *)&xmmword_5B8CE0 + 1) objectAtIndexedSubscript:v109]);
      unint64_t v63 = (void *)objc_claimAutoreleasedReturnValue([v62 name]);
      unsigned int v64 = [v63 isEqualToString:@"RDE"];

      if (v64) {
LABEL_45:
      }
        unint64_t v113 = v109;

      goto LABEL_47;
    }

    if (HIDWORD(qword_5B9548) >= 2
      && [(id)qword_5B94B8 count]
      && (id v57 = (void *)objc_claimAutoreleasedReturnValue([*((id *)&xmmword_5B8CE0 + 1) objectAtIndexedSubscript:v43]),
          id v58 = (void *)objc_claimAutoreleasedReturnValue([v57 name]),
          unsigned int v59 = [v58 isEqualToString:@"RDE_1"],
          v58,
          v57,
          v59))
    {
      id v60 = (void *)xmmword_5B94A8;
      id v45 = [(id)qword_5B9498 mutableCopy];
      [v60 addObject:v45];
      unint64_t v111 = v109;
    }

    else
    {
      unint64_t v61 = (void *)xmmword_5B94A8;
      id v45 = (id)objc_opt_new(&OBJC_CLASS___NSMutableArray, v44);
      [v61 addObject:v45];
    }

void sub_62BCC( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, void *a11, void *a12, void *a13, void *a14, void *a15, void *a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, _Unwind_Exception *exception_object)
{
  _Unwind_Resume(a1);
}

void GTUSCSamplingStreamingManagerHelper::Init( GTUSCSamplingStreamingManagerHelper *this, GTUSCSamplingStreamingManager *a2)
{
  else {
    ClearCaches();
  }
  if (!(void)xmmword_5B9690)
  {
    dispatch_semaphore_t v3 = dispatch_semaphore_create(0LL);
    unint64_t v4 = (void *)xmmword_5B9690;
    *(void *)&xmmword_5B9690 = v3;
  }

  *(void *)&GTUSCSamplingStreamingManagerHelper::Instance(void)::instance = this;
  atomic_store((unint64_t)this, (unint64_t *)&xmmword_5B9770);
  unint64_t v5 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(*(void *)this + 8) defaultDevice]);
  GTAGXPerfStateControl::InitWithDevice((uint64_t)&unk_5B8CF8, v5);

  qword_5B8D10 = 30LL;
  unint64_t v6 = IOServiceMatching("ApplePMP");
  io_service_t MatchingService = IOServiceGetMatchingService(kIOMasterPortDefault, v6);
  if (MatchingService)
  {
    int v8 = 2;
    if (!dword_5B9428) {
      int v8 = 13;
    }
  }

  else
  {
    uint64_t v9 = IOServiceMatching("ApplePMPv2");
    io_service_t MatchingService = IOServiceGetMatchingService(kIOMasterPortDefault, v9);
    if (!MatchingService) {
      goto LABEL_21;
    }
    dword_5B9428 = 1;
    int v8 = 2;
  }

  for (uint64_t i = 0LL; i != 5; ++i)
    *((_DWORD *)&GTUSCSamplingStreamingManagerHelper::Instance(void)::instance + i + 471) = v8 + i;
  uint64_t v11 = IOServiceOpen(MatchingService, mach_task_self_, 0, (io_connect_t *)&qword_5B8D18);
  if ((_DWORD)v11)
  {
    uint64_t v12 = v11;
    float v13 = +[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", mach_error_string(v11));
    float v14 = (void *)objc_claimAutoreleasedReturnValue(v13);
    unint64_t v15 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"IOServiceOpen (0x%x - %@)",  v12,  v14));

    char v16 = __stdoutp;
    int v17 = g_runningInCI;
    id v18 = v15;
    int v19 = (const char *)[v18 UTF8String];
    unint64_t v20 = "#CI_ERROR# ";
    if (!v17) {
      unint64_t v20 = "";
    }
    fprintf(v16, "%s%s %u: %s\n", v20, "BOOL GTApplePMPPerfStateControl::Open(io_service_t)", 182, v19);
    id v21 = v18;
    GTMTLReplay_handleError( 101,  (uint64_t)[v21 UTF8String],  "/Library/Caches/com.apple.xbs/Sources/GPUToolsDevice/GPUTools/GTMTLCapture/replayer/profile/GTApplePMPPerfStateControl.mm",  (uint64_t)"Open",  182,  2);
  }

  else if ((_DWORD)qword_5B8D18 {
         && (memset(output, 0, sizeof(output)),
  }
             outputCnt[0] = 1,
             !IOConnectCallMethod(qword_5B8D18, dword_5B942C, 0LL, 0, 0LL, 0LL, (uint64_t *)output, outputCnt, 0LL, 0LL)))
  {
    qword_5B9420 = *(void *)&output[0];
    if (*(void *)&output[0])
    {
      uint64_t v43 = 0LL;
      while ((_DWORD)qword_5B8D18)
      {
        *(void *)&output[0] = v43;
        size_t v44 = 16LL;
        if (!dword_5B9428) {
          size_t v44 = 10LL;
        }
        size_t outputStructCnt = v44;
        uint64_t v45 = IOConnectCallMethod( qword_5B8D18,  dword_5B9434,  (const uint64_t *)output,  1u,  0LL,  0LL,  0LL,  0LL,  outputCnt,  &outputStructCnt);
        uint64_t v46 = v45;
        if ((_DWORD)v45)
        {
          id v47 = +[NSString stringWithUTF8String:]( &OBJC_CLASS___NSString,  "stringWithUTF8String:",  mach_error_string(v45));
          uint64_t v48 = (void *)objc_claimAutoreleasedReturnValue(v47);
          uint64_t v49 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"_getDVFSDomainName (0x%x - %@)",  v46,  v48));

          uint64_t v50 = __stdoutp;
          int v51 = g_runningInCI;
          id v52 = v49;
          id v53 = (const char *)[v52 UTF8String];
          unint64_t v54 = "#CI_ERROR# ";
          if (!v51) {
            unint64_t v54 = "";
          }
          fprintf( v50,  "%s%s %u: %s\n",  v54,  "NSString *GTApplePMPPerfStateControl::GetDVFSDomainName(uint64_t)",  266,  v53);
          id v55 = v52;
          GTMTLReplay_handleError( 101,  (uint64_t)[v55 UTF8String],  "/Library/Caches/com.apple.xbs/Sources/GPUToolsDevice/GPUTools/GTMTLCapture/replayer/profile/GTApplePMPPerfStateControl.mm",  (uint64_t)"GetDVFSDomainName",  266,  2);
        }

        if (outputStructCnt)
        {
          v56 = (__CFString *)objc_claimAutoreleasedReturnValue( +[NSString stringWithUTF8String:]( &OBJC_CLASS___NSString,  "stringWithUTF8String:",  outputCnt));
          if (!v56) {
            goto LABEL_61;
          }
        }

        else
        {
          v56 = &stru_591D98;
        }

        if (!-[__CFString length](v56, "length")) {
          goto LABEL_61;
        }
        id v57 = -[__CFString copy](v56, "copy");
        id v58 = (char *)&GTUSCSamplingStreamingManagerHelper::Instance(void)::instance + 56 * v43;
        unsigned int v59 = (void *)*((void *)v58 + 10);
        *((void *)v58 + 10) = v57;

        if (!(_DWORD)qword_5B8D18) {
          goto LABEL_61;
        }
        __int128 v85 = 0u;
        __int128 v86 = 0u;
        __int128 v83 = 0u;
        __int128 v84 = 0u;
        __int128 v81 = 0u;
        __int128 v82 = 0u;
        memset(outputCnt, 0, sizeof(outputCnt));
        *(void *)&output[0] = v43;
        LODWORD(outputStructCnt) = 3;
        uint64_t v60 = IOConnectCallMethod( qword_5B8D18,  dword_5B9430,  (const uint64_t *)output,  1u,  0LL,  0LL,  (uint64_t *)outputCnt,  (uint32_t *)&outputStructCnt,  0LL,  0LL);
        uint64_t v61 = v60;
        if ((_DWORD)v60)
        {
          uint64_t v62 = +[NSString stringWithUTF8String:]( &OBJC_CLASS___NSString,  "stringWithUTF8String:",  mach_error_string(v60));
          unint64_t v63 = (void *)objc_claimAutoreleasedReturnValue(v62);
          unsigned int v64 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"_getNumDVFSStates (0x%x - %@)",  v61,  v63));

          id v65 = __stdoutp;
          int v66 = g_runningInCI;
          id v67 = v64;
          unint64_t v68 = (const char *)[v67 UTF8String];
          unsigned int v69 = "#CI_ERROR# ";
          if (!v66) {
            unsigned int v69 = "";
          }
          fprintf( v65,  "%s%s %u: %s\n",  v69,  "uint64_t GTApplePMPPerfStateControl::GetNumDVFSStates(uint64_t, uint64_t *, uint64_t *)",  228,  v68);
          id v70 = v67;
          GTMTLReplay_handleError( 101,  (uint64_t)[v70 UTF8String],  "/Library/Caches/com.apple.xbs/Sources/GPUToolsDevice/GPUTools/GTMTLCapture/replayer/profile/GTApplePMPPerfStateControl.mm",  (uint64_t)"GetNumDVFSStates",  228,  2);
        }

        uint64_t v71 = *(void *)outputCnt;
        if (!*(void *)outputCnt) {
          goto LABEL_61;
        }
        unint64_t v72 = 0LL;
        *(_OWORD *)(v58 + 120) = *(_OWORD *)&outputCnt[2];
        while (v72 < [&off_59F9C8 count])
        {
          int v73 = (void *)objc_claimAutoreleasedReturnValue([&off_59F9C8 objectAtIndexedSubscript:v72]);
          if (-[__CFString hasPrefix:](v56, "hasPrefix:", v73))
          {
            unint64_t v74 = (char *)[v73 length];
            if (v74 + 1 >= -[__CFString length](v56, "length"))
            {
              unsigned int v75 = [v73 hasPrefix:@"DCS"];
              uint64_t v76 = v71 - 1;
              uint64_t v77 = (void *)&GTUSCSamplingStreamingManagerHelper::Instance(void)::instance + 7 * v43;
              v77[12] = (unint64_t)(v71 - 1) >> (v75 ^ 1);
              v77[13] = v71 - 1;
              if (!v75) {
                uint64_t v76 = 0LL;
              }
              v77[11] = v76;

              break;
            }
          }

          ++v72;
        }
      }

      v56 = 0LL;
LABEL_61:
    }
  }

  else
  {
    qword_5B9420 = 0LL;
  }

LABEL_21:
  unsigned int v22 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(*(void *)this + 8) defaultDevice]);
  id v23 = DEVICEOBJECT(v22);
  uint64_t v24 = (void *)objc_claimAutoreleasedReturnValue(v23);
  io_registry_entry_t v25 = [v24 acceleratorPort];

  CFTypeRef v26 = GTProfilerConfigurationVariables(v25);
  uint64_t v27 = objc_claimAutoreleasedReturnValue(v26);
  unint64_t v28 = (void *)qword_5B9490;
  qword_5B9490 = v27;

  unint64_t v29 = objc_alloc(&OBJC_CLASS___GTPerfStatsHelper);
  uint64_t v30 = -[GTPerfStatsHelper initWithConfigurationVariables:](v29, "initWithConfigurationVariables:", qword_5B9490);
  unsigned int v31 = (void *)*((void *)&GTUSCSamplingStreamingManagerHelper::Instance(void)::instance + 1);
  *((void *)&GTUSCSamplingStreamingManagerHelper::Instance(void)::instance + 1) = v30;

  [*((id *)&GTUSCSamplingStreamingManagerHelper::Instance(void)::instance + 1) setup];
  id v32 = GTAGXPerfStateControl::ConsistentGPUPerfStateLevel((GTAGXPerfStateControl *)&unk_5B8CF8, 0LL);
  uint64_t v33 = objc_claimAutoreleasedReturnValue(v32);
  uint64_t v34 = (void *)qword_5B9500;
  qword_5B9500 = v33;

  id v35 = (void *)objc_claimAutoreleasedReturnValue( [*(id *)(GTUSCSamplingStreamingManagerHelper::Instance(void)::instance + 16) objectForKeyedSubscript:@"GPUState"]);
  if (!v35
    || (uint64_t v36 = (void *)objc_claimAutoreleasedReturnValue( [*(id *)(GTUSCSamplingStreamingManagerHelper::Instance(void)::instance + 16) objectForKeyedSubscript:@"GPUState"]),  v37 = objc_msgSend(v36, "unsignedIntValue"),  v36,  v35,  !v37))
  {
    if (qword_5B9500)
    {
      unsigned int v38 = (void *)objc_claimAutoreleasedReturnValue([(id)qword_5B9500 objectForKeyedSubscript:@"mapped state"]);
      if (v38)
      {
        id v78 = v38;
        BOOL v39 = [v38 count] == (char *)&dword_0 + 3;
        unsigned int v38 = v78;
        if (v39)
        {
          uint64_t v40 = (void *)objc_claimAutoreleasedReturnValue([v78 objectAtIndexedSubscript:1]);
          unsigned int v41 = [v40 unsignedIntValue];
          uint64_t v42 = GTUSCSamplingStreamingManagerHelper::Instance(void)::instance;
          *(_DWORD *)(GTUSCSamplingStreamingManagerHelper::Instance(void)::instance + 64) = 100 * v41;
          *(_DWORD *)(v42 + 68) = 100 * v41;

          unsigned int v38 = v78;
        }
      }
    }
  }

      objc_autoreleasePoolPop(v8);
      io_registry_entry_t v25 = (*v7 + 1);
      *uint64_t v7 = v25;
      if (v6[13] + v6[12] <= v25) {
        goto LABEL_22;
      }
    }

    id v35 = v8;
    unint64_t v15 = (void *)objc_claimAutoreleasedReturnValue([v5 computeCommandEncoderForKey:*((void *)v2 + 1415)]);
    unsigned int v38 = @"compute kernel key";
    char v16 = [v15 newKernelDebugInfo];
    uint64_t v24 = AddShaderBinary(v3, v16);
    id v18 = (void *)objc_claimAutoreleasedReturnValue(v24);
    BOOL v39 = v18;
    int v19 = (id)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v39,  &v38,  1LL));
    -[NSMutableArray addObject:](v34, "addObject:", v19);
LABEL_19:

    int v8 = v35;
LABEL_20:

    goto LABEL_21;
  }

    uint64_t v30 = 0LL;
    uint64_t *result = v4;
    *a2 = v5;
    unsigned int v31 = result[1];
    result[1] = a2[1];
    unint64_t v29 = a2 + 2;
    id v32 = a2[2];
    a2[1] = v31;
    uint64_t v33 = result[2];
    result[2] = v32;
    a2[2] = v33;
    uint64_t v34 = *a3;
    id v35 = *a2;
    while (1)
    {
      uint64_t v36 = CollectCounterData(GTMTLReplayController *,NSArray *,unsigned long long,NSArray *,unsigned long,GTMTLReplayOperationQueues *,NSOperation *,unsigned int,BOOL,unsigned int,GTAGXPerfStateControl *)::kCounterCompare[v30];
      unsigned int v37 = *(void *)(v34 + 8 * v36);
      unsigned int v38 = *(void *)(v35 + 8 * v36);
      if (v37 != v38) {
        break;
      }
      if (++v30 == 4) {
        return result;
      }
    }

    if (v37 < v38)
    {
      *a2 = v34;
      *a3 = v35;
      uint64_t v40 = a2[1];
      a2[1] = a3[1];
      a3[1] = v40;
      goto LABEL_29;
    }
  }

  return result;
}

        uint64_t v9 = v21;
        if (v21 < v24)
        {
          unint64_t v28 = v24;
          do
          {
            unint64_t v29 = *(_OWORD *)v9;
            v143 = *(_OWORD *)(v9 + 16);
            uint64_t v30 = *(void *)(v9 + 32);
            id v32 = *(_OWORD *)v28;
            unsigned int v31 = *(_OWORD *)(v28 + 16);
            *(void *)(v9 + 32) = *(void *)(v28 + 32);
            *(_OWORD *)uint64_t v9 = v32;
            *(_OWORD *)(v9 + 16) = v31;
            *(void *)(v28 + 32) = v30;
            *(_OWORD *)unint64_t v28 = v29;
            *(_OWORD *)(v28 + 16) = v143;
            do
            {
              uint64_t v33 = *(_DWORD *)(v9 + 72);
              v9 += 40LL;
            }

            while (v33 < v19);
            do
            {
              uint64_t v34 = *(_DWORD *)(v28 - 8);
              v28 -= 40LL;
            }

            while (v34 >= v19);
          }

          while (v9 < v28);
        }

        id v35 = (__int128 *)(v9 - 40);
        if (v9 - 40 != a1)
        {
          uint64_t v36 = *v35;
          unsigned int v37 = *(_OWORD *)(v9 - 24);
          *(void *)(a1 + 32) = *(void *)(v9 - 8);
          *(_OWORD *)a1 = v36;
          *(_OWORD *)(a1 + 16) = v37;
        }

        void *v35 = v128;
        *(_OWORD *)(v9 - 24) = v131;
        *(_DWORD *)(v9 - 8) = v19;
        *(_DWORD *)(v9 - 4) = v20;
        if (v21 < v24)
        {
LABEL_32:
          std::__introsort<std::_ClassicAlgPolicy,-[DYPMTLShaderProfilerHelper _processTracePackets:forRenderIndex:andGenerateSampleList:forTargetIndex:forLimiterIndex:]::$_1::operator() const(std::queue<ProfileEvent>)::{lambda(ShaderProfilerUSCSampleInfo const&,ShaderProfilerUSCSampleInfo&)#1} &,ShaderProfilerUSCSampleInfo*,false>( a1,  v9 - 40,  a3,  a4 & 1);
          a4 = 0;
          continue;
        }

        unsigned int v38 = std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,-[DYPMTLShaderProfilerHelper _processTracePackets:forRenderIndex:andGenerateSampleList:forTargetIndex:forLimiterIndex:]::$_1::operator() const(std::queue<ProfileEvent>)::{lambda(ShaderProfilerUSCSampleInfo const&,ShaderProfilerUSCSampleInfo&)#1} &,ShaderProfilerUSCSampleInfo*>( a1,  v9 - 40);
        if (!std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,-[DYPMTLShaderProfilerHelper _processTracePackets:forRenderIndex:andGenerateSampleList:forTargetIndex:forLimiterIndex:]::$_1::operator() const(std::queue<ProfileEvent>)::{lambda(ShaderProfilerUSCSampleInfo const&,ShaderProfilerUSCSampleInfo&)#1} &,ShaderProfilerUSCSampleInfo*>( v9,  a2))
        {
          if (v38) {
            continue;
          }
          goto LABEL_32;
        }

        a2 = v9 - 40;
        if (!v38) {
          goto LABEL_1;
        }
        return;
    }
  }

  return v13;
}

      if (v20 - 48 > 9)
      {
        if (v20 == 42)
        {
          id v23 = (unsigned int *)v196;
          v196 += 8;
          uint64_t v24 = *v23;
          io_registry_entry_t v25 = *(unsigned __int8 *)++v11;
          unint64_t v20 = v25;
          if ((v24 & 0x80000000) == 0LL) {
            int v19 = v19;
          }
          else {
            int v19 = 0LL;
          }
          if ((v24 & 0x80000000) == 0LL) {
            unint64_t v6 = v24;
          }
          else {
            unint64_t v6 = -(int)v24;
          }
          goto LABEL_32;
        }

        v191 = 0;
      }

      else
      {
        unint64_t v6 = *v11 - 48LL;
        id v21 = *(unsigned __int8 *)++v11;
        unint64_t v20 = v21;
        if (v21 - 48 <= 9)
        {
          do
          {
            unint64_t v6 = 10 * v6 + (char)v20 - 48;
            unsigned int v22 = *(unsigned __int8 *)++v11;
            unint64_t v20 = v22;
          }

          while (v22 - 48 < 0xA);
        }

void sub_6371C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, id a13)
{
  _Unwind_Resume(a1);
}

id GTUSCSamplingStreamingManagerHelper::SubDividedCounterDictionary(void *a1)
{
  uint64_t v9 = 0LL;
  uint64_t v10 = &v9;
  uint64_t v11 = 0x3032000000LL;
  uint64_t v12 = __Block_byref_object_copy_;
  float v13 = __Block_byref_object_dispose_;
  id v14 = 0LL;
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 3221225472LL;
  v5[2] = ___ZNK35GTUSCSamplingStreamingManagerHelper27SubDividedCounterDictionaryEP14NSMutableArrayIP19GPURawCounterSelectE_block_invoke;
  v5[3] = &unk_58F838;
  uint64_t v7 = &v9;
  int v8 = &GTUSCSamplingStreamingManagerHelper::Instance(void)::instance;
  id v1 = a1;
  id v6 = v1;
  unint64_t v2 = (void *)objc_claimAutoreleasedReturnValue( +[NSBlockOperation blockOperationWithBlock:]( &OBJC_CLASS___NSBlockOperation,  "blockOperationWithBlock:",  v5));
  [v2 setQueuePriority:8];
  [**(id **)(GTUSCSamplingStreamingManagerHelper::Instance(void)::instance + 8) addOperation:v2];
  [v2 waitUntilFinished];
  id v3 = (id)v10[5];

  _Block_object_dispose(&v9, 8);
  return v3;
}

void sub_638D0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, uint64_t a15, uint64_t a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, id a22)
{
  _Block_object_dispose(&a17, 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy_(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0LL;
  return result;
}

void __Block_byref_object_dispose_(uint64_t a1)
{
}

void ___ZNK35GTUSCSamplingStreamingManagerHelper27SubDividedCounterDictionaryEP14NSMutableArrayIP19GPURawCounterSelectE_block_invoke( void *a1)
{
  id v5 = (id)objc_claimAutoreleasedReturnValue([*(id *)(a1[6] + 16) firstObject]);
  uint64_t v2 = objc_claimAutoreleasedReturnValue([v5 subDivideCounterList:a1[4] withOptions:0]);
  uint64_t v3 = *(void *)(a1[5] + 8LL);
  unint64_t v4 = *(void **)(v3 + 40);
  *(void *)(v3 + 40) = v2;
}

void sub_63980( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
}

void *std::vector<std::vector<GTMMappedBuffer>>::reserve(void *result, unint64_t a2)
{
  if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(result[2] - *result) >> 3) < a2)
  {
    if (a2 >= 0xAAAAAAAAAAAAAABLL) {
      abort();
    }
    uint64_t v2 = result;
    uint64_t v3 = result[1] - *result;
    void v5[4] = result + 2;
    v5[0] = std::__allocate_at_least[abi:nn180100]<std::allocator<std::vector<NSObject  {objcproto21OS_dispatch_semaphore}* {__strong}>>>(a2);
    v5[1] = v5[0] + v3;
    v5[2] = v5[0] + v3;
    v5[3] = v5[0] + 24 * v4;
    std::vector<std::vector<NSObject  {objcproto21OS_dispatch_semaphore}* {__strong}>>::__swap_out_circular_buffer( v2,  v5);
    return (void *)std::__split_buffer<std::vector<GTMMappedBuffer>>::~__split_buffer((uint64_t)v5);
  }

  return result;
}

void *std::vector<std::vector<NSObject {objcproto21OS_dispatch_semaphore}* {__strong}>>::reserve( void *result, unint64_t a2)
{
  if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(result[2] - *result) >> 3) < a2)
  {
    if (a2 >= 0xAAAAAAAAAAAAAABLL) {
      abort();
    }
    uint64_t v2 = result;
    uint64_t v3 = result[1] - *result;
    void v5[4] = result + 2;
    v5[0] = std::__allocate_at_least[abi:nn180100]<std::allocator<std::vector<NSObject  {objcproto21OS_dispatch_semaphore}* {__strong}>>>(a2);
    v5[1] = v5[0] + v3;
    v5[2] = v5[0] + v3;
    v5[3] = v5[0] + 24 * v4;
    std::vector<std::vector<NSObject  {objcproto21OS_dispatch_semaphore}* {__strong}>>::__swap_out_circular_buffer( v2,  v5);
    return (void *)std::__split_buffer<std::vector<NSObject  {objcproto21OS_dispatch_semaphore}* {__strong}>>::~__split_buffer((uint64_t)v5);
  }

  return result;
}

void *std::vector<NSObject {objcproto21OS_dispatch_semaphore}* {__strong}>::reserve( void *result, unint64_t a2)
{
  if (a2 > (uint64_t)(result[2] - *result) >> 3)
  {
    if (a2 >> 61) {
      abort();
    }
    uint64_t v2 = (char **)result;
    uint64_t v3 = result[1] - *result;
    unint64_t v15 = result + 2;
    uint64_t v4 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<std::pair<unsigned int,unsigned int>>>(a2);
    uint64_t v7 = *v2;
    id v6 = v2[1];
    if (v6 == *v2)
    {
      int64x2_t v10 = vdupq_n_s64((unint64_t)v6);
      int v8 = &v4[v3 & 0xFFFFFFFFFFFFFFF8LL];
    }

    else
    {
      int v8 = &v4[v3 & 0xFFFFFFFFFFFFFFF8LL];
      do
      {
        uint64_t v9 = *((void *)v6 - 1);
        v6 -= 8;
        *(void *)id v6 = 0LL;
        *((void *)v8 - 1) = v9;
        v8 -= 8;
      }

      while (v6 != v7);
      int64x2_t v10 = *(int64x2_t *)v2;
    }

    void *v2 = v8;
    v2[1] = &v4[v3 & 0xFFFFFFFFFFFFFFF8LL];
    int64x2_t v13 = v10;
    uint64_t v11 = v2[2];
    v2[2] = &v4[8 * v5];
    id v14 = v11;
    uint64_t v12 = v10.i64[0];
    return (void *)std::__split_buffer<NSObject  {objcproto21OS_dispatch_semaphore}* {__strong}>::~__split_buffer((uint64_t)&v12);
  }

  return result;
}

void GTUSCSamplingStreamingManagerHelper::SetupBufferForSourceAtIndex( GTUSCSamplingStreamingManagerHelper *this, int a2)
{
  uint64_t v3 = (void *)objc_claimAutoreleasedReturnValue([*((id *)&xmmword_5B8CE0 + 1) objectAtIndexedSubscript:this]);
  __int128 v175 = 0uLL;
  v176 = 0LL;
  uint64_t v4 = *((void *)&xmmword_5B9600 + 1);
  if (*((void *)&xmmword_5B9600 + 1) >= (unint64_t)xmmword_5B9610)
  {
    unint64_t v6 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*((void *)&xmmword_5B9600 + 1) - xmmword_5B9600) >> 3);
    unint64_t v7 = v6 + 1;
    if (v6 + 1 > 0xAAAAAAAAAAAAAAALL) {
      abort();
    }
    else {
      unint64_t v8 = v7;
    }
    v180 = &xmmword_5B9610;
    uint64_t v9 = (void **)std::__allocate_at_least[abi:nn180100]<std::allocator<std::vector<NSObject  {objcproto21OS_dispatch_semaphore}* {__strong}>>>(v8);
    int64x2_t v10 = &v9[3 * v6];
    v177 = v9;
    v178.i64[0] = (uint64_t)v10;
    v179 = &v9[3 * v11];
    uint64_t *v10 = 0LL;
    v10[1] = 0LL;
    v10[2] = 0LL;
    *(_OWORD *)int64x2_t v10 = v175;
    v10[2] = v176;
    __int128 v175 = 0uLL;
    v176 = 0LL;
    v178.i64[1] = (uint64_t)(v10 + 3);
    std::vector<std::vector<NSObject  {objcproto21OS_dispatch_semaphore}* {__strong}>>::__swap_out_circular_buffer( &xmmword_5B9600,  &v177);
    uint64_t v5 = *((void *)&xmmword_5B9600 + 1);
    std::__split_buffer<std::vector<GTMMappedBuffer>>::~__split_buffer((uint64_t)&v177);
  }

  else
  {
    **((void **)&xmmword_5B9600 + 1) = 0LL;
    *(void *)(v4 + 8) = 0LL;
    *(void *)(v4 + 16) = 0LL;
    uint64_t v5 = v4 + 24;
    *((void *)&xmmword_5B9600 + 1) = v4 + 24;
  }

  *((void *)&xmmword_5B9600 + 1) = v5;
  v177 = (void **)&v175;
  std::vector<GTMMappedBuffer>::__destroy_vector::operator()[abi:nn180100](&v177);
  std::vector<GTMMappedBuffer>::reserve( (uint64_t *)(*((void *)&xmmword_5B9600 + 1) - 24),  [v3 ringBufferNum]);
  if ((a2 & 1) == 0)
  {
    unsigned int v14 = [v3 ringBufferNum];
    uint64_t v15 = v14;
    char v16 = (DynamicBuffer *)xmmword_5B9620;
    unint64_t v17 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(xmmword_5B9620 - *((void *)&xmmword_5B9610 + 1)) >> 4);
    unint64_t v18 = v14 - v17;
    if (v14 <= v17)
    {
      if (v14 < v17)
      {
        uint64_t v65 = *((void *)&xmmword_5B9610 + 1) + 48LL * v14;
        while (v16 != (DynamicBuffer *)v65)
        {
          int v66 = (void *)*((void *)v16 - 3);
          if (v66)
          {
            *((void *)v16 - 2) = v66;
            operator delete(v66);
          }

          char v16 = (DynamicBuffer *)((char *)v16 - 48);
        }

        *(void *)&xmmword_5B9620 = v65;
      }
    }

    else if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*((void *)&xmmword_5B9620 + 1) - xmmword_5B9620) >> 4) >= v18)
    {
      uint64_t v173 = xmmword_5B9620 + 48 * v18;
      uint64_t v174 = 48LL * v14 - 16 * ((uint64_t)(xmmword_5B9620 - *((void *)&xmmword_5B9610 + 1)) >> 4);
      do
      {
        DynamicBuffer::DynamicBuffer(v16);
        char v16 = (DynamicBuffer *)((char *)v16 + 48);
        v174 -= 48LL;
      }

      while (v174);
      *(void *)&xmmword_5B9620 = v173;
    }

    else
    {
      v180 = (__int128 *)((char *)&xmmword_5B9620 + 8);
      unint64_t v19 = 0x5555555555555556LL * ((uint64_t)(*((void *)&xmmword_5B9620 + 1) - *((void *)&xmmword_5B9610 + 1)) >> 4);
      if (v19 <= v14) {
        unint64_t v19 = v14;
      }
      else {
        unint64_t v20 = v19;
      }
      id v21 = (void **)std::__allocate_at_least[abi:nn180100]<std::allocator<DynamicBuffer>>(v20);
      unsigned int v22 = (DynamicBuffer *)&v21[6 * v17];
      v177 = v21;
      v178.i64[0] = (uint64_t)v22;
      v178.i64[1] = (uint64_t)v22;
      v179 = &v21[6 * v23];
      uint64_t v24 = 3 * v15;
      io_registry_entry_t v25 = &v21[6 * v15];
      uint64_t v26 = 16 * v24 - 48 * v17;
      do
      {
        DynamicBuffer::DynamicBuffer(v22);
        unsigned int v22 = (DynamicBuffer *)((char *)v22 + 48);
        v26 -= 48LL;
      }

      while (v26);
      v178.i64[1] = (uint64_t)v25;
      std::vector<DynamicBuffer>::__swap_out_circular_buffer((uint64_t *)&xmmword_5B9610 + 1, &v177);
      std::__split_buffer<DynamicBuffer>::~__split_buffer((uint64_t)&v177);
    }
  }

  __int128 v175 = 0uLL;
  v176 = 0LL;
  uint64_t v12 = xmmword_5B95F0;
  if ((unint64_t)xmmword_5B95F0 >= *((void *)&xmmword_5B95F0 + 1))
  {
    unint64_t v27 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)xmmword_5B95F0 - qword_5B95E8) >> 3);
    unint64_t v28 = v27 + 1;
    if (v27 + 1 > 0xAAAAAAAAAAAAAAALL) {
      abort();
    }
    if (0x5555555555555556LL * ((*((void *)&xmmword_5B95F0 + 1) - qword_5B95E8) >> 3) > v28) {
      unint64_t v28 = 0x5555555555555556LL * ((*((void *)&xmmword_5B95F0 + 1) - qword_5B95E8) >> 3);
    }
    if (0xAAAAAAAAAAAAAAABLL * ((*((void *)&xmmword_5B95F0 + 1) - qword_5B95E8) >> 3) >= 0x555555555555555LL) {
      unint64_t v29 = 0xAAAAAAAAAAAAAAALL;
    }
    else {
      unint64_t v29 = v28;
    }
    v180 = (__int128 *)((char *)&xmmword_5B95F0 + 8);
    uint64_t v30 = (void **)std::__allocate_at_least[abi:nn180100]<std::allocator<std::vector<NSObject  {objcproto21OS_dispatch_semaphore}* {__strong}>>>(v29);
    unsigned int v31 = &v30[3 * v27];
    v177 = v30;
    v178.i64[0] = (uint64_t)v31;
    v179 = &v30[3 * v32];
    *unsigned int v31 = 0LL;
    v31[1] = 0LL;
    v31[2] = 0LL;
    *(_OWORD *)unsigned int v31 = v175;
    v31[2] = v176;
    __int128 v175 = 0uLL;
    v176 = 0LL;
    v178.i64[1] = (uint64_t)(v31 + 3);
    std::vector<std::vector<NSObject  {objcproto21OS_dispatch_semaphore}* {__strong}>>::__swap_out_circular_buffer( &qword_5B95E8,  &v177);
    uint64_t v13 = xmmword_5B95F0;
    std::__split_buffer<std::vector<GTMMappedBuffer>>::~__split_buffer((uint64_t)&v177);
  }

  else
  {
    *(_OWORD *)xmmword_5B95F0 = 0uLL;
    *(void *)(v12 + 16) = 0LL;
    *(_OWORD *)uint64_t v12 = v175;
    *(void *)(v12 + 16) = v176;
    __int128 v175 = 0uLL;
    v176 = 0LL;
    uint64_t v13 = v12 + 24;
    *(void *)&xmmword_5B95F0 = v12 + 24;
  }

  *(void *)&xmmword_5B95F0 = v13;
  v177 = (void **)&v175;
  std::vector<GTMMappedBuffer>::__destroy_vector::operator()[abi:nn180100](&v177);
  std::vector<GTMMappedBuffer>::reserve( (uint64_t *)(xmmword_5B95F0 - 24),  [v3 ringBufferNum]);
  __int128 v175 = 0uLL;
  v176 = 0LL;
  uint64_t v33 = *((void *)&xmmword_5B9630 + 1);
  if (*((void *)&xmmword_5B9630 + 1) >= qword_5B9640)
  {
    unint64_t v35 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*((void *)&xmmword_5B9630 + 1) - xmmword_5B9630) >> 3);
    unint64_t v36 = v35 + 1;
    if (v35 + 1 > 0xAAAAAAAAAAAAAAALL) {
      abort();
    }
    else {
      unint64_t v37 = v36;
    }
    v180 = (__int128 *)&qword_5B9640;
    unsigned int v38 = (void **)std::__allocate_at_least[abi:nn180100]<std::allocator<std::vector<NSObject  {objcproto21OS_dispatch_semaphore}* {__strong}>>>(v37);
    BOOL v39 = &v38[3 * v35];
    v177 = v38;
    v178.i64[0] = (uint64_t)v39;
    v179 = &v38[3 * v40];
    *BOOL v39 = 0LL;
    v39[1] = 0LL;
    v39[2] = 0LL;
    *(_OWORD *)BOOL v39 = v175;
    v39[2] = v176;
    __int128 v175 = 0uLL;
    v176 = 0LL;
    v178.i64[1] = (uint64_t)(v39 + 3);
    std::vector<std::vector<NSObject  {objcproto21OS_dispatch_semaphore}* {__strong}>>::__swap_out_circular_buffer( &xmmword_5B9630,  &v177);
    uint64_t v34 = *((void *)&xmmword_5B9630 + 1);
    std::__split_buffer<std::vector<GTMMappedBuffer>>::~__split_buffer((uint64_t)&v177);
  }

  else
  {
    **((void **)&xmmword_5B9630 + 1) = 0LL;
    *(void *)(v33 + 8) = 0LL;
    *(void *)(v33 + 16) = 0LL;
    *(_OWORD *)uint64_t v33 = v175;
    *(void *)(v33 + 16) = v176;
    __int128 v175 = 0uLL;
    v176 = 0LL;
    uint64_t v34 = v33 + 24;
    *((void *)&xmmword_5B9630 + 1) = v33 + 24;
  }

  *((void *)&xmmword_5B9630 + 1) = v34;
  v177 = (void **)&v175;
  std::vector<GTMMappedBuffer>::__destroy_vector::operator()[abi:nn180100](&v177);
  std::vector<GTMMappedBuffer>::reserve( (uint64_t *)(*((void *)&xmmword_5B9630 + 1) - 24),  [v3 ringBufferNum]);
  __int128 v175 = 0uLL;
  v176 = 0LL;
  uint64_t v41 = xmmword_5B9650;
  if ((unint64_t)xmmword_5B9650 >= *((void *)&xmmword_5B9650 + 1))
  {
    unint64_t v43 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)xmmword_5B9650 - qword_5B9648) >> 3);
    unint64_t v44 = v43 + 1;
    if (v43 + 1 > 0xAAAAAAAAAAAAAAALL) {
      abort();
    }
    if (0x5555555555555556LL * ((*((void *)&xmmword_5B9650 + 1) - qword_5B9648) >> 3) > v44) {
      unint64_t v44 = 0x5555555555555556LL * ((*((void *)&xmmword_5B9650 + 1) - qword_5B9648) >> 3);
    }
    if (0xAAAAAAAAAAAAAAABLL * ((*((void *)&xmmword_5B9650 + 1) - qword_5B9648) >> 3) >= 0x555555555555555LL) {
      unint64_t v45 = 0xAAAAAAAAAAAAAAALL;
    }
    else {
      unint64_t v45 = v44;
    }
    v180 = (__int128 *)((char *)&xmmword_5B9650 + 8);
    uint64_t v46 = (void **)std::__allocate_at_least[abi:nn180100]<std::allocator<std::vector<NSObject  {objcproto21OS_dispatch_semaphore}* {__strong}>>>(v45);
    id v47 = &v46[3 * v43];
    v177 = v46;
    v178.i64[0] = (uint64_t)v47;
    v179 = &v46[3 * v48];
    *id v47 = 0LL;
    v47[1] = 0LL;
    void v47[2] = 0LL;
    *(_OWORD *)id v47 = v175;
    void v47[2] = v176;
    __int128 v175 = 0uLL;
    v176 = 0LL;
    v178.i64[1] = (uint64_t)(v47 + 3);
    std::vector<std::vector<NSObject  {objcproto21OS_dispatch_semaphore}* {__strong}>>::__swap_out_circular_buffer( &qword_5B9648,  &v177);
    uint64_t v42 = xmmword_5B9650;
    std::__split_buffer<std::vector<NSObject  {objcproto21OS_dispatch_semaphore}* {__strong}>>::~__split_buffer((uint64_t)&v177);
  }

  else
  {
    *(_OWORD *)xmmword_5B9650 = 0uLL;
    *(void *)(v41 + 16) = 0LL;
    *(_OWORD *)uint64_t v41 = v175;
    *(void *)(v41 + 16) = v176;
    __int128 v175 = 0uLL;
    v176 = 0LL;
    uint64_t v42 = v41 + 24;
    *(void *)&xmmword_5B9650 = v41 + 24;
  }

  *(void *)&xmmword_5B9650 = v42;
  v177 = (void **)&v175;
  std::vector<NSObject  {objcproto21OS_dispatch_semaphore}* {__strong}>::__destroy_vector::operator()[abi:nn180100](&v177);
  std::vector<NSObject  {objcproto21OS_dispatch_semaphore}* {__strong}>::reserve( (void *)(xmmword_5B9650 - 24),  [v3 ringBufferNum]);
  __int128 v175 = 0uLL;
  v176 = 0LL;
  uint64_t v49 = *((void *)&xmmword_5B9660 + 1);
  if (*((void *)&xmmword_5B9660 + 1) >= (unint64_t)xmmword_5B9670)
  {
    unint64_t v51 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*((void *)&xmmword_5B9660 + 1) - xmmword_5B9660) >> 3);
    unint64_t v52 = v51 + 1;
    if (v51 + 1 > 0xAAAAAAAAAAAAAAALL) {
      abort();
    }
    else {
      unint64_t v53 = v52;
    }
    v180 = &xmmword_5B9670;
    unint64_t v54 = (void **)std::__allocate_at_least[abi:nn180100]<std::allocator<std::vector<NSObject  {objcproto21OS_dispatch_semaphore}* {__strong}>>>(v53);
    id v55 = &v54[3 * v51];
    v177 = v54;
    v178.i64[0] = (uint64_t)v55;
    v179 = &v54[3 * v56];
    void *v55 = 0LL;
    v55[1] = 0LL;
    v55[2] = 0LL;
    *(_OWORD *)id v55 = v175;
    v55[2] = v176;
    __int128 v175 = 0uLL;
    v176 = 0LL;
    v178.i64[1] = (uint64_t)(v55 + 3);
    std::vector<std::vector<NSObject  {objcproto21OS_dispatch_semaphore}* {__strong}>>::__swap_out_circular_buffer( &xmmword_5B9660,  &v177);
    uint64_t v50 = *((void *)&xmmword_5B9660 + 1);
    std::__split_buffer<std::vector<NSObject  {objcproto21OS_dispatch_semaphore}* {__strong}>>::~__split_buffer((uint64_t)&v177);
  }

  else
  {
    **((void **)&xmmword_5B9660 + 1) = 0LL;
    *(void *)(v49 + 8) = 0LL;
    *(void *)(v49 + 16) = 0LL;
    *(_OWORD *)uint64_t v49 = v175;
    *(void *)(v49 + 16) = v176;
    __int128 v175 = 0uLL;
    v176 = 0LL;
    uint64_t v50 = v49 + 24;
    *((void *)&xmmword_5B9660 + 1) = v49 + 24;
  }

  *((void *)&xmmword_5B9660 + 1) = v50;
  v177 = (void **)&v175;
  std::vector<NSObject  {objcproto21OS_dispatch_semaphore}* {__strong}>::__destroy_vector::operator()[abi:nn180100](&v177);
  std::vector<NSObject  {objcproto21OS_dispatch_semaphore}* {__strong}>::reserve( (void *)(*((void *)&xmmword_5B9660 + 1) - 24),  [v3 ringBufferNum]);
  dispatch_semaphore_t v57 = dispatch_semaphore_create(1LL);
  dispatch_semaphore_t v58 = v57;
  uint64_t v59 = qword_5B9680;
  if (qword_5B9680 >= (unint64_t)qword_5B9688)
  {
    uint64_t v61 = (qword_5B9680 - *((void *)&xmmword_5B9670 + 1)) >> 3;
    unint64_t v62 = (qword_5B9688 - *((void *)&xmmword_5B9670 + 1)) >> 2;
    if (v62 <= v61 + 1) {
      unint64_t v62 = v61 + 1;
    }
    else {
      unint64_t v63 = v62;
    }
    v180 = (__int128 *)&qword_5B9688;
    if (v63) {
      unint64_t v63 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<std::pair<unsigned int,unsigned int>>>(v63);
    }
    else {
      uint64_t v64 = 0LL;
    }
    id v67 = (dispatch_semaphore_t *)(v63 + 8 * v61);
    uint64_t v68 = v63 + 8 * v64;
    v179 = (void **)v68;
    dispatch_semaphore_t *v67 = v58;
    uint64_t v60 = (uint64_t)(v67 + 1);
    v178.i64[1] = (uint64_t)(v67 + 1);
    id v70 = (void *)*((void *)&xmmword_5B9670 + 1);
    unsigned int v69 = (void *)qword_5B9680;
    if (qword_5B9680 == *((void *)&xmmword_5B9670 + 1))
    {
      int64x2_t v72 = vdupq_n_s64(qword_5B9680);
    }

    else
    {
      do
      {
        uint64_t v71 = (dispatch_semaphore_s *)*--v69;
        *unsigned int v69 = 0LL;
        *--id v67 = v71;
      }

      while (v69 != v70);
      int64x2_t v72 = *(int64x2_t *)((char *)&xmmword_5B9670 + 8);
      uint64_t v60 = v178.i64[1];
      uint64_t v68 = (uint64_t)v179;
    }

    *((void *)&xmmword_5B9670 + 1) = v67;
    qword_5B9680 = v60;
    int64x2_t v178 = v72;
    uint64_t v73 = qword_5B9688;
    qword_5B9688 = v68;
    v179 = (void **)v73;
    v177 = (void **)v72.i64[0];
    std::__split_buffer<NSObject  {objcproto21OS_dispatch_semaphore}* {__strong}>::~__split_buffer((uint64_t)&v177);
  }

  else
  {
    *(void *)qword_5B9680 = v57;
    uint64_t v60 = v59 + 8;
  }

  qword_5B9680 = v60;
  unsigned int v74 = objc_msgSend(v3, "ringBufferNum", v175, v176);
  dword_5B9544 += v74;
  unsigned int v75 = [v3 ringBufferNum];
  unsigned int v76 = 0;
  unsigned int v77 = qword_5B9548;
  LODWORD(qword_5B9548) = v77;
  while (v76 < [v3 ringBufferNum])
  {
    if (a2)
    {
      uint64_t v78 = *((void *)&xmmword_5B9600 + 1);
      unint64_t v79 = *(void *)(*((void *)&xmmword_5B9600 + 1) - 16LL);
      unint64_t v80 = *(void *)(*((void *)&xmmword_5B9600 + 1) - 8LL);
      if (v79 >= v80)
      {
        uint64_t v86 = *(void *)(*((void *)&xmmword_5B9600 + 1) - 24LL);
        unint64_t v87 = 0xEEEEEEEEEEEEEEEFLL * ((uint64_t)(v79 - v86) >> 3);
        unint64_t v88 = v87 + 1;
        if (v87 + 1 > 0x222222222222222LL) {
          abort();
        }
        unint64_t v89 = 0xEEEEEEEEEEEEEEEFLL * ((uint64_t)(v80 - v86) >> 3);
        if (2 * v89 > v88) {
          unint64_t v88 = 2 * v89;
        }
        if (v89 >= 0x111111111111111LL) {
          unint64_t v90 = 0x222222222222222LL;
        }
        else {
          unint64_t v90 = v88;
        }
        v180 = (__int128 *)(*((void *)&xmmword_5B9600 + 1) - 8LL);
        if (v90) {
          unint64_t v90 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<GTMMappedBuffer>>(v90);
        }
        else {
          uint64_t v91 = 0LL;
        }
        v177 = (void **)v90;
        v178.i64[0] = v90 + 120 * v87;
        v178.i64[1] = v178.i64[0];
        v179 = (void **)(v90 + 120 * v91);
        GTMMappedBuffer::GTMMappedBuffer((GTMMappedBuffer *)v178.i64[0], 0x8000000uLL, 0x1000000u);
        v178.i64[1] += 120LL;
        std::vector<GTMMappedBuffer>::__swap_out_circular_buffer((uint64_t *)(v78 - 24), &v177);
        unint64_t v81 = *(void *)(v78 - 16);
        std::__split_buffer<GTMMappedBuffer>::~__split_buffer((uint64_t)&v177);
      }

      else
      {
        GTMMappedBuffer::GTMMappedBuffer( *(GTMMappedBuffer **)(*((void *)&xmmword_5B9600 + 1) - 16LL),  0x8000000uLL,  0x1000000u);
        unint64_t v81 = v79 + 120;
        *(void *)(v78 - 16) = v79 + 120;
      }

      *(void *)(v78 - 16) = v81;
      uint64_t v98 = *((void *)&xmmword_5B9630 + 1);
      unint64_t v99 = *(void *)(*((void *)&xmmword_5B9630 + 1) - 16LL);
      unint64_t v100 = *(void *)(*((void *)&xmmword_5B9630 + 1) - 8LL);
      if (v99 >= v100)
      {
        uint64_t v102 = *(void *)(*((void *)&xmmword_5B9630 + 1) - 24LL);
        unint64_t v103 = 0xEEEEEEEEEEEEEEEFLL * ((uint64_t)(v99 - v102) >> 3);
        unint64_t v104 = v103 + 1;
        if (v103 + 1 > 0x222222222222222LL) {
          abort();
        }
        unint64_t v105 = 0xEEEEEEEEEEEEEEEFLL * ((uint64_t)(v100 - v102) >> 3);
        if (2 * v105 > v104) {
          unint64_t v104 = 2 * v105;
        }
        if (v105 >= 0x111111111111111LL) {
          unint64_t v106 = 0x222222222222222LL;
        }
        else {
          unint64_t v106 = v104;
        }
        v180 = (__int128 *)(*((void *)&xmmword_5B9630 + 1) - 8LL);
        if (v106) {
          unint64_t v106 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<GTMMappedBuffer>>(v106);
        }
        else {
          uint64_t v107 = 0LL;
        }
        v177 = (void **)v106;
        v178.i64[0] = v106 + 120 * v103;
        v178.i64[1] = v178.i64[0];
        v179 = (void **)(v106 + 120 * v107);
        GTMMappedBuffer::GTMMappedBuffer((GTMMappedBuffer *)v178.i64[0], 0x8000000uLL, 0x2000000u);
        v178.i64[1] += 120LL;
        std::vector<GTMMappedBuffer>::__swap_out_circular_buffer((uint64_t *)(v98 - 24), &v177);
        unint64_t v101 = *(void *)(v98 - 16);
        std::__split_buffer<GTMMappedBuffer>::~__split_buffer((uint64_t)&v177);
      }

      else
      {
        GTMMappedBuffer::GTMMappedBuffer( *(GTMMappedBuffer **)(*((void *)&xmmword_5B9630 + 1) - 16LL),  0x8000000uLL,  0x2000000u);
        unint64_t v101 = v99 + 120;
        *(void *)(v98 - 16) = v99 + 120;
      }

      *(void *)(v98 - 16) = v101;
      uint64_t v118 = xmmword_5B95F0;
      unint64_t v119 = *(void *)(xmmword_5B95F0 - 16);
      unint64_t v120 = *(void *)(xmmword_5B95F0 - 8);
      if (v119 < v120)
      {
        GTMMappedBuffer::GTMMappedBuffer(*(GTMMappedBuffer **)(xmmword_5B95F0 - 16), 0x100000uLL, 0x100000u);
LABEL_144:
        unint64_t v128 = v119 + 120;
        *(void *)(v118 - 16) = v119 + 120;
        goto LABEL_158;
      }

      uint64_t v121 = *(void *)(xmmword_5B95F0 - 24);
      unint64_t v122 = 0xEEEEEEEEEEEEEEEFLL * ((uint64_t)(v119 - v121) >> 3);
      unint64_t v123 = v122 + 1;
      if (v122 + 1 > 0x222222222222222LL) {
        abort();
      }
      unint64_t v124 = 0xEEEEEEEEEEEEEEEFLL * ((uint64_t)(v120 - v121) >> 3);
      if (2 * v124 > v123) {
        unint64_t v123 = 2 * v124;
      }
      if (v124 >= 0x111111111111111LL) {
        unint64_t v125 = 0x222222222222222LL;
      }
      else {
        unint64_t v125 = v123;
      }
      v180 = (__int128 *)(xmmword_5B95F0 - 8);
      if (v125) {
        unint64_t v125 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<GTMMappedBuffer>>(v125);
      }
      else {
        uint64_t v126 = 0LL;
      }
      v177 = (void **)v125;
      v178.i64[0] = v125 + 120 * v122;
      v178.i64[1] = v178.i64[0];
      v179 = (void **)(v125 + 120 * v126);
      GTMMappedBuffer::GTMMappedBuffer((GTMMappedBuffer *)v178.i64[0], 0x100000uLL, 0x100000u);
      v178.i64[1] += 120LL;
      std::vector<GTMMappedBuffer>::__swap_out_circular_buffer((uint64_t *)(v118 - 24), &v177);
    }

    else
    {
      uint64_t v82 = *((void *)&xmmword_5B9630 + 1);
      unint64_t v83 = *(void *)(*((void *)&xmmword_5B9630 + 1) - 16LL);
      unint64_t v84 = *(void *)(*((void *)&xmmword_5B9630 + 1) - 8LL);
      if (v83 >= v84)
      {
        uint64_t v92 = *(void *)(*((void *)&xmmword_5B9630 + 1) - 24LL);
        unint64_t v93 = 0xEEEEEEEEEEEEEEEFLL * ((uint64_t)(v83 - v92) >> 3);
        unint64_t v94 = v93 + 1;
        if (v93 + 1 > 0x222222222222222LL) {
          abort();
        }
        unint64_t v95 = 0xEEEEEEEEEEEEEEEFLL * ((uint64_t)(v84 - v92) >> 3);
        if (2 * v95 > v94) {
          unint64_t v94 = 2 * v95;
        }
        if (v95 >= 0x111111111111111LL) {
          unint64_t v96 = 0x222222222222222LL;
        }
        else {
          unint64_t v96 = v94;
        }
        v180 = (__int128 *)(*((void *)&xmmword_5B9630 + 1) - 8LL);
        if (v96) {
          unint64_t v96 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<GTMMappedBuffer>>(v96);
        }
        else {
          uint64_t v97 = 0LL;
        }
        v177 = (void **)v96;
        v178.i64[0] = v96 + 120 * v93;
        v178.i64[1] = v178.i64[0];
        v179 = (void **)(v96 + 120 * v97);
        GTMMappedBuffer::GTMMappedBuffer((GTMMappedBuffer *)v178.i64[0], 0x4000uLL, 0x4000u);
        v178.i64[1] += 120LL;
        std::vector<GTMMappedBuffer>::__swap_out_circular_buffer((uint64_t *)(v82 - 24), &v177);
        unint64_t v85 = *(void *)(v82 - 16);
        std::__split_buffer<GTMMappedBuffer>::~__split_buffer((uint64_t)&v177);
      }

      else
      {
        GTMMappedBuffer::GTMMappedBuffer( *(GTMMappedBuffer **)(*((void *)&xmmword_5B9630 + 1) - 16LL),  0x4000uLL,  0x4000u);
        unint64_t v85 = v83 + 120;
        *(void *)(v82 - 16) = v83 + 120;
      }

      *(void *)(v82 - 16) = v85;
      uint64_t v108 = *((void *)&xmmword_5B9600 + 1);
      unint64_t v109 = *(void *)(*((void *)&xmmword_5B9600 + 1) - 16LL);
      unint64_t v110 = *(void *)(*((void *)&xmmword_5B9600 + 1) - 8LL);
      if (v109 >= v110)
      {
        uint64_t v112 = *(void *)(*((void *)&xmmword_5B9600 + 1) - 24LL);
        unint64_t v113 = 0xEEEEEEEEEEEEEEEFLL * ((uint64_t)(v109 - v112) >> 3);
        unint64_t v114 = v113 + 1;
        if (v113 + 1 > 0x222222222222222LL) {
          abort();
        }
        unint64_t v115 = 0xEEEEEEEEEEEEEEEFLL * ((uint64_t)(v110 - v112) >> 3);
        if (2 * v115 > v114) {
          unint64_t v114 = 2 * v115;
        }
        if (v115 >= 0x111111111111111LL) {
          unint64_t v116 = 0x222222222222222LL;
        }
        else {
          unint64_t v116 = v114;
        }
        v180 = (__int128 *)(*((void *)&xmmword_5B9600 + 1) - 8LL);
        if (v116) {
          unint64_t v116 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<GTMMappedBuffer>>(v116);
        }
        else {
          uint64_t v117 = 0LL;
        }
        v177 = (void **)v116;
        v178.i64[0] = v116 + 120 * v113;
        v178.i64[1] = v178.i64[0];
        v179 = (void **)(v116 + 120 * v117);
        GTMMappedBuffer::GTMMappedBuffer((GTMMappedBuffer *)v178.i64[0], 0x4000uLL, 0x4000u);
        v178.i64[1] += 120LL;
        std::vector<GTMMappedBuffer>::__swap_out_circular_buffer((uint64_t *)(v108 - 24), &v177);
        unint64_t v111 = *(void *)(v108 - 16);
        std::__split_buffer<GTMMappedBuffer>::~__split_buffer((uint64_t)&v177);
      }

      else
      {
        GTMMappedBuffer::GTMMappedBuffer( *(GTMMappedBuffer **)(*((void *)&xmmword_5B9600 + 1) - 16LL),  0x4000uLL,  0x4000u);
        unint64_t v111 = v109 + 120;
        *(void *)(v108 - 16) = v109 + 120;
      }

      *(void *)(v108 - 16) = v111;
      uint64_t v118 = xmmword_5B95F0;
      unint64_t v119 = *(void *)(xmmword_5B95F0 - 16);
      unint64_t v127 = *(void *)(xmmword_5B95F0 - 8);
      if (v119 < v127)
      {
        GTMMappedBuffer::GTMMappedBuffer(*(GTMMappedBuffer **)(xmmword_5B95F0 - 16), 0x4000uLL, 0x4000u);
        goto LABEL_144;
      }

      uint64_t v129 = *(void *)(xmmword_5B95F0 - 24);
      unint64_t v130 = 0xEEEEEEEEEEEEEEEFLL * ((uint64_t)(v119 - v129) >> 3);
      unint64_t v131 = v130 + 1;
      if (v130 + 1 > 0x222222222222222LL) {
        abort();
      }
      unint64_t v132 = 0xEEEEEEEEEEEEEEEFLL * ((uint64_t)(v127 - v129) >> 3);
      if (2 * v132 > v131) {
        unint64_t v131 = 2 * v132;
      }
      if (v132 >= 0x111111111111111LL) {
        unint64_t v133 = 0x222222222222222LL;
      }
      else {
        unint64_t v133 = v131;
      }
      v180 = (__int128 *)(xmmword_5B95F0 - 8);
      if (v133) {
        unint64_t v133 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<GTMMappedBuffer>>(v133);
      }
      else {
        uint64_t v134 = 0LL;
      }
      v177 = (void **)v133;
      v178.i64[0] = v133 + 120 * v130;
      v178.i64[1] = v178.i64[0];
      v179 = (void **)(v133 + 120 * v134);
      GTMMappedBuffer::GTMMappedBuffer((GTMMappedBuffer *)v178.i64[0], 0x4000uLL, 0x4000u);
      v178.i64[1] += 120LL;
      std::vector<GTMMappedBuffer>::__swap_out_circular_buffer((uint64_t *)(v118 - 24), &v177);
    }

    unint64_t v128 = *(void *)(v118 - 16);
    std::__split_buffer<GTMMappedBuffer>::~__split_buffer((uint64_t)&v177);
LABEL_158:
    *(void *)(v118 - 16) = v128;
    uint64_t v135 = xmmword_5B9650;
    dispatch_semaphore_t v136 = dispatch_semaphore_create(0LL);
    dispatch_semaphore_t v137 = v136;
    v138 = *(dispatch_semaphore_t **)(v135 - 16);
    unint64_t v139 = *(void *)(v135 - 8);
    if ((unint64_t)v138 >= v139)
    {
      uint64_t v141 = *(void *)(v135 - 24);
      uint64_t v142 = ((uint64_t)v138 - v141) >> 3;
      uint64_t v143 = v139 - v141;
      uint64_t v144 = v143 >> 2;
      else {
        unint64_t v145 = v144;
      }
      v180 = (__int128 *)(v135 - 8);
      if (v145) {
        unint64_t v145 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<std::pair<unsigned int,unsigned int>>>(v145);
      }
      else {
        uint64_t v146 = 0LL;
      }
      v147 = (dispatch_semaphore_t *)(v145 + 8 * v142);
      unint64_t v148 = v145 + 8 * v146;
      v179 = (void **)v148;
      dispatch_semaphore_t *v147 = v137;
      v140 = v147 + 1;
      v178.i64[1] = (uint64_t)(v147 + 1);
      v150 = *(void **)(v135 - 24);
      v149 = *(void **)(v135 - 16);
      if (v149 == v150)
      {
        v152 = *(void ***)(v135 - 16);
      }

      else
      {
        do
        {
          v151 = (dispatch_semaphore_s *)*--v149;
          void *v149 = 0LL;
          *--v147 = v151;
        }

        while (v149 != v150);
        v152 = *(void ***)(v135 - 24);
        v149 = *(void **)(v135 - 16);
        v140 = (void *)v178.i64[1];
        unint64_t v148 = (unint64_t)v179;
      }

      *(void *)(v135 - 24) = v147;
      v178.i64[0] = (uint64_t)v152;
      *(void *)(v135 - 16) = v140;
      v178.i64[1] = (uint64_t)v149;
      v153 = *(void ***)(v135 - 8);
      *(void *)(v135 - 8) = v148;
      v179 = v153;
      v177 = v152;
      std::__split_buffer<NSObject  {objcproto21OS_dispatch_semaphore}* {__strong}>::~__split_buffer((uint64_t)&v177);
    }

    else
    {
      dispatch_semaphore_t *v138 = v136;
      v140 = v138 + 1;
    }

    *(void *)(v135 - 16) = v140;
    uint64_t v154 = *((void *)&xmmword_5B9660 + 1);
    dispatch_semaphore_t v155 = dispatch_semaphore_create(0LL);
    dispatch_semaphore_t v156 = v155;
    v157 = *(dispatch_semaphore_t **)(v154 - 16);
    unint64_t v158 = *(void *)(v154 - 8);
    if ((unint64_t)v157 >= v158)
    {
      uint64_t v160 = *(void *)(v154 - 24);
      uint64_t v161 = ((uint64_t)v157 - v160) >> 3;
      uint64_t v162 = v158 - v160;
      uint64_t v163 = v162 >> 2;
      else {
        unint64_t v164 = v163;
      }
      v180 = (__int128 *)(v154 - 8);
      if (v164) {
        unint64_t v164 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<std::pair<unsigned int,unsigned int>>>(v164);
      }
      else {
        uint64_t v165 = 0LL;
      }
      v166 = (dispatch_semaphore_t *)(v164 + 8 * v161);
      unint64_t v167 = v164 + 8 * v165;
      v179 = (void **)v167;
      dispatch_semaphore_t *v166 = v156;
      v159 = v166 + 1;
      v178.i64[1] = (uint64_t)(v166 + 1);
      v169 = *(void **)(v154 - 24);
      v168 = *(void **)(v154 - 16);
      if (v168 == v169)
      {
        v171 = *(void ***)(v154 - 16);
      }

      else
      {
        do
        {
          v170 = (dispatch_semaphore_s *)*--v168;
          void *v168 = 0LL;
          *--v166 = v170;
        }

        while (v168 != v169);
        v171 = *(void ***)(v154 - 24);
        v168 = *(void **)(v154 - 16);
        v159 = (void *)v178.i64[1];
        unint64_t v167 = (unint64_t)v179;
      }

      *(void *)(v154 - 24) = v166;
      v178.i64[0] = (uint64_t)v171;
      *(void *)(v154 - 16) = v159;
      v178.i64[1] = (uint64_t)v168;
      v172 = *(void ***)(v154 - 8);
      *(void *)(v154 - 8) = v167;
      v179 = v172;
      v177 = v171;
      std::__split_buffer<NSObject  {objcproto21OS_dispatch_semaphore}* {__strong}>::~__split_buffer((uint64_t)&v177);
    }

    else
    {
      dispatch_semaphore_t *v157 = v155;
      v159 = v157 + 1;
    }

    *(void *)(v154 - 16) = v159;
    ++v76;
  }
}

void sub_64BCC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void std::vector<GTMMappedBuffer>::__destroy_vector::operator()[abi:nn180100](void ***a1)
{
  id v1 = *a1;
  uint64_t v2 = (char *)**a1;
  if (v2)
  {
    uint64_t v4 = (char *)v1[1];
    uint64_t v5 = v2;
    if (v4 != v2)
    {
      do
        GTMMappedBuffer::~GTMMappedBuffer((GTMMappedBuffer *)(v4 - 120));
      while (v4 != v2);
      uint64_t v5 = **a1;
    }

    v1[1] = v2;
    operator delete(v5);
  }

uint64_t *std::vector<GTMMappedBuffer>::reserve(uint64_t *result, unint64_t a2)
{
  if (0xEEEEEEEEEEEEEEEFLL * ((result[2] - *result) >> 3) < a2)
  {
    uint64_t v2 = result;
    uint64_t v3 = result[1] - *result;
    void v5[4] = result + 2;
    v5[0] = std::__allocate_at_least[abi:nn180100]<std::allocator<GTMMappedBuffer>>(a2);
    v5[1] = v5[0] + v3;
    v5[2] = v5[0] + v3;
    v5[3] = v5[0] + 120 * v4;
    std::vector<GTMMappedBuffer>::__swap_out_circular_buffer(v2, v5);
    return (uint64_t *)std::__split_buffer<GTMMappedBuffer>::~__split_buffer((uint64_t)v5);
  }

  return result;
}

void sub_64DCC(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

void std::vector<NSObject  {objcproto21OS_dispatch_semaphore}* {__strong}>::__destroy_vector::operator()[abi:nn180100]( void ***a1)
{
  id v1 = *a1;
  uint64_t v2 = (char *)**a1;
  if (v2)
  {
    uint64_t v4 = (char *)v1[1];
    uint64_t v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        unint64_t v6 = (void *)*((void *)v4 - 1);
        v4 -= 8;
      }

      while (v4 != v2);
      uint64_t v5 = **a1;
    }

    v1[1] = v2;
    operator delete(v5);
  }

uint64_t std::__split_buffer<NSObject  {objcproto21OS_dispatch_semaphore}* {__strong}>::~__split_buffer( uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 8;
  }

  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void GTMMappedBuffer::GTMMappedBuffer(GTMMappedBuffer *this, unint64_t a2, unsigned int a3)
{
  *(_OWORD *)this = 0u;
  *((_OWORD *)this + 1) = 0u;
  *((void *)this + 4) = 0xFFFFFFFFLL;
  *((_DWORD *)this + 10) = a3;
  *((_OWORD *)this + 3) = 0u;
  unint64_t v4 = a3;
  *((_OWORD *)this + 4) = 0u;
  *((_OWORD *)this + 5) = 0u;
  *((_OWORD *)this + 6) = 0u;
  *((void *)this + 14) = 0LL;
  if (a3 <= a2)
  {
    unint64_t v6 = (void *)objc_claimAutoreleasedReturnValue(+[NSFileManager defaultManager](&OBJC_CLASS___NSFileManager, "defaultManager"));
    unsigned __int8 v7 = [v6 fileExistsAtPath:@"/tmp/com.apple.gputools.profiling"];

    if ((v7 & 1) == 0)
    {
      unint64_t v8 = (void *)objc_claimAutoreleasedReturnValue(+[NSFileManager defaultManager](&OBJC_CLASS___NSFileManager, "defaultManager"));
      [v8 createDirectoryAtPath:@"/tmp/com.apple.gputools.profiling" withIntermediateDirectories:1 attributes:0 error:0];
    }

    uint64_t v9 = (void *)objc_claimAutoreleasedReturnValue(+[NSUUID UUID](&OBJC_CLASS___NSUUID, "UUID"));
    int64x2_t v10 = (void *)objc_claimAutoreleasedReturnValue([v9 UUIDString]);
    uint64_t v11 = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"%@/Temp_%@_%d.mmapbuffer",  @"/tmp/com.apple.gputools.profiling",  v10,  rand());
    uint64_t v12 = objc_claimAutoreleasedReturnValue(v11);
    uint64_t v13 = (void *)*((void *)this + 3);
    *((void *)this + 3) = v12;

    int v14 = open((const char *)[*((id *)this + 3) UTF8String], 1538, 438);
    *((_DWORD *)this + 8) = v14;
    if (v14 < 0)
    {
      unint64_t v51 = __error();
      unint64_t v52 = +[NSString stringWithFormat:](&OBJC_CLASS___NSString, "stringWithFormat:", @"%s", strerror(*v51));
      unint64_t v53 = (void *)objc_claimAutoreleasedReturnValue(v52);
      unint64_t v54 = __stdoutp;
      int v55 = g_runningInCI;
      id v56 = v53;
      dispatch_semaphore_t v57 = (const char *)[v56 UTF8String];
      dispatch_semaphore_t v58 = "#CI_ERROR# ";
      if (!v55) {
        dispatch_semaphore_t v58 = "";
      }
      fprintf(v54, "%s%s %u: %s\n", v58, "GTMMappedBuffer::GTMMappedBuffer(size_t, size_t)", 1027, v57);
      id v50 = v56;
      GTMTLReplay_handleError( 101,  (uint64_t)[v50 UTF8String],  "/Library/Caches/com.apple.xbs/Sources/GPUToolsDevice/GPUTools/GTMTLCapture/replayer/profile/GTUSCSamplingStreamingManager.mm",  (uint64_t)"GTMMappedBuffer",  1027,  1);
    }

    else
    {
      lseek(v14, a2, 0);
      write(*((_DWORD *)this + 8), "A", 1uLL);
      uint64_t v15 = 0LL;
      int v59 = a2;
      if (a2 / v4 <= 1) {
        uint64_t v16 = 1LL;
      }
      else {
        uint64_t v16 = a2 / v4;
      }
      do
      {
        unint64_t v17 = mmap(0LL, *((unsigned int *)this + 10), 3, 2, *((_DWORD *)this + 8), v15 * *((unsigned int *)this + 10));
        unint64_t v19 = v17;
        if (v17 == (void *)-1LL)
        {
          uint64_t v26 = __error();
          unint64_t v27 = +[NSString stringWithFormat:](&OBJC_CLASS___NSString, "stringWithFormat:", @"%s", strerror(*v26));
          unint64_t v28 = (void *)objc_claimAutoreleasedReturnValue(v27);
          unint64_t v29 = __stdoutp;
          int v30 = g_runningInCI;
          id v31 = v28;
          uint64_t v32 = (const char *)[v31 UTF8String];
          uint64_t v33 = "#CI_ERROR# ";
          if (!v30) {
            uint64_t v33 = "";
          }
          fprintf(v29, "%s%s %u: %s\n", v33, "GTMMappedBuffer::GTMMappedBuffer(size_t, size_t)", 1037, v32);
          id v34 = v31;
          GTMTLReplay_handleError( 101,  (uint64_t)[v34 UTF8String],  "/Library/Caches/com.apple.xbs/Sources/GPUToolsDevice/GPUTools/GTMTLCapture/replayer/profile/GTUSCSamplingStr eamingManager.mm",  (uint64_t)"GTMMappedBuffer",  1037,  1);
        }

        else
        {
          uint64_t v21 = *((void *)this + 12);
          unint64_t v20 = *((void *)this + 13);
          uint64_t v22 = (uint64_t)(v20 - v21) >> 5;
          unint64_t v23 = *((void *)this + 14);
          if (v20 >= v23)
          {
            unint64_t v35 = v22 + 1;
            uint64_t v36 = v23 - v21;
            if (v36 >> 4 > v35) {
              unint64_t v35 = v36 >> 4;
            }
            else {
              unint64_t v37 = v35;
            }
            unsigned int v38 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<GTMMappedBufferBlock>>(v37);
            BOOL v39 = &v38[32 * v22];
            int v40 = *((_DWORD *)this + 10);
            *(void *)BOOL v39 = v22;
            *((void *)v39 + 1) = v19;
            *((_DWORD *)v39 + 5) = 0;
            *((_DWORD *)v39 + 6) = 0;
            *((_DWORD *)v39 + 4) = v40;
            uint64_t v42 = (char *)*((void *)this + 12);
            uint64_t v41 = (char *)*((void *)this + 13);
            unint64_t v43 = v39;
            if (v41 != v42)
            {
              do
              {
                __int128 v44 = *((_OWORD *)v41 - 1);
                *((_OWORD *)v43 - 2) = *((_OWORD *)v41 - 2);
                *((_OWORD *)v43 - 1) = v44;
                v43 -= 32;
                v41 -= 32;
              }

              while (v41 != v42);
              uint64_t v41 = (char *)*((void *)this + 12);
            }

            io_registry_entry_t v25 = v39 + 32;
            *((void *)this + 12) = v43;
            *((void *)this + 13) = v39 + 32;
            *((void *)this + 14) = &v38[32 * v18];
            if (v41) {
              operator delete(v41);
            }
          }

          else
          {
            int v24 = *((_DWORD *)this + 10);
            *(void *)unint64_t v20 = v22;
            *(void *)(v20 + 8) = v17;
            *(_DWORD *)(v20 + 20) = 0;
            *(_DWORD *)(v20 + 24) = 0;
            *(_DWORD *)(v20 + 16) = v24;
            io_registry_entry_t v25 = (char *)(v20 + 32);
          }

          *((void *)this + 13) = v25;
        }

        ++v15;
      }

      while (v15 != v16);
      *((_DWORD *)this + 9) = v59;
      uint64_t v45 = objc_opt_new(&OBJC_CLASS___NSCondition, v18);
      uint64_t v46 = (void *)*((void *)this + 2);
      *((void *)this + 2) = v45;

      dispatch_semaphore_t v47 = dispatch_semaphore_create(1LL);
      uint64_t v48 = *(void **)this;
      *(void *)this = v47;

      dispatch_semaphore_t v49 = dispatch_semaphore_create(1LL);
      id v50 = (id)*((void *)this + 1);
      *((void *)this + 1) = v49;
    }
  }

void sub_65300( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13)
{
  uint64_t v15 = *(void **)(v13 + 96);
  if (v15)
  {
    *(void *)(v13 + 104) = v15;
    operator delete(v15);
  }

  std::deque<GTMMappedBuffer::UsedBlock>::~deque[abi:nn180100](a13);

  _Unwind_Resume(a1);
}

void *std::__allocate_at_least[abi:nn180100]<std::allocator<GTMMappedBuffer>>(unint64_t a1)
{
  if (a1 >= 0x222222222222223LL) {
    std::__throw_bad_array_new_length[abi:nn180100]();
  }
  return operator new(120 * a1);
}

void std::vector<GTMMappedBuffer>::__swap_out_circular_buffer(uint64_t *a1, void *a2)
{
  uint64_t v2 = a1[1];
  uint64_t v52 = *a1;
  uint64_t v3 = a2[1];
  if (v2 == *a1)
  {
    uint64_t v5 = a2[1];
  }

  else
  {
    uint64_t v4 = a1[1];
    uint64_t v5 = a2[1];
    do
    {
      unint64_t v6 = *(void **)(v4 - 120);
      v4 -= 120LL;
      *(void *)(v5 - 120) = v6;
      v5 -= 120LL;
      *(void *)(v3 - 112) = *(id *)(v4 + 8);
      *(void *)(v3 - 104) = *(id *)(v4 + 16);
      *(void *)(v3 - 96) = *(id *)(v4 + 24);
      __int128 v7 = *(_OWORD *)(v4 + 32);
      *(_OWORD *)(v3 - 72) = 0u;
      uint64_t v8 = v3 - 72;
      *(_OWORD *)(v3 - 88) = v7;
      *(_OWORD *)(v8 + 16) = 0u;
      *(_OWORD *)(v8 + 32) = 0u;
      unint64_t v9 = *(void *)(v4 + 80);
      unint64_t v10 = v9 / 0xAA;
      uint64_t v11 = *(void *)(v4 + 56);
      if (*(void *)(v4 + 64) == v11)
      {
        unint64_t v12 = 0LL;
        unint64_t v15 = 0LL;
        int v14 = (void *)(v11 + 8 * ((*(void *)(v2 - 32) + v9) / 0xAA));
      }

      else
      {
        unint64_t v12 = *(void *)(v11 + 8 * (v9 / 0xAA)) + 24 * (v9 % 0xAA);
        unint64_t v13 = *(void *)(v2 - 32) + v9;
        int v14 = (void *)(v11 + 8 * (v13 / 0xAA));
        unint64_t v15 = *v14 + 24 * (v13 % 0xAA);
      }

      if (v15 != v12)
      {
        uint64_t v16 = (void *)(v11 + 8 * v10);
        uint64_t v17 = 170 * (v14 - v16)
        if (v17)
        {
          unint64_t v18 = (v17 + 1) / 0xAAuLL;
          if (-170LL * v18 == ~v17) {
            unint64_t v19 = (v17 + 1) / 0xAAuLL;
          }
          else {
            unint64_t v19 = v18 + 1;
          }
          if (v19)
          {
            uint64_t v56 = v3 - 48;
            *(void *)&__int128 v54 = std::__allocate_at_least[abi:nn180100]<std::allocator<std::pair<unsigned int,unsigned int>>>(v19);
            *((void *)&v54 + 1) = v54;
            *(void *)&__int128 v55 = v54;
            *((void *)&v55 + 1) = v54 + 8 * v20;
            do
            {
              unint64_t v53 = operator new(0xFF0uLL);
              std::__split_buffer<GTMMappedBuffer::UsedBlock *>::push_back(&v54, &v53);
              --v19;
            }

            while (v19);
            for (uint64_t i = *(void **)(v3 - 56);
                  i != *(void **)(v3 - 64);
                  std::__split_buffer<GTMMappedBuffer::UsedBlock *>::push_front((uint64_t)&v54, i))
            {
              --i;
            }

            uint64_t v22 = *(void **)(v3 - 72);
            uint64_t v23 = *((void *)&v54 + 1);
            __int128 v24 = v55;
            *(_OWORD *)(v3 - 72) = v54;
            *(_OWORD *)(v3 - 56) = v24;
            if (v22)
            {
              operator delete(v22);
              uint64_t v25 = *(void *)(v3 - 64);
              uint64_t v26 = *(void *)(v3 - 56);
            }

            else
            {
              uint64_t v25 = v23;
              uint64_t v26 = v24;
            }

            uint64_t v28 = *(void *)(v3 - 32);
            unint64_t v30 = *(void *)(v3 - 40) + v28;
            unint64_t v29 = (uint64_t *)(v25 + 8 * (v30 / 0xAA));
            if (v26 == v25) {
              unint64_t v27 = 0LL;
            }
            else {
              unint64_t v27 = *v29 + 24 * (v30 % 0xAA);
            }
          }

          else
          {
            unint64_t v27 = 0LL;
            uint64_t v28 = 0LL;
            unint64_t v29 = 0LL;
          }

          uint64_t v31 = (uint64_t)(v27 - *v29) / 24 + v17;
          if (v31 < 1)
          {
            unint64_t v35 = 169 - v31;
            uint64_t v32 = &v29[-(v35 / 0xAA)];
            uint64_t v33 = *v32;
            unint64_t v34 = 169 - v35 % 0xAA;
          }

          else
          {
            uint64_t v32 = &v29[v31 / 0xAAuLL];
            uint64_t v33 = *v32;
            unint64_t v34 = v31 % 0xAAuLL;
          }

          uint64_t v36 = v33 + 24 * v34;
          while (v27 != v36)
          {
            uint64_t v37 = v36;
            if (v29 != v32) {
              uint64_t v37 = *v29 + 4080;
            }
            if (v27 == v37)
            {
              uint64_t v37 = v27;
            }

            else
            {
              unint64_t v38 = v27;
              do
              {
                __int128 v39 = *(_OWORD *)v12;
                *(void *)(v38 + 16) = *(void *)(v12 + 16);
                *(_OWORD *)unint64_t v38 = v39;
                v12 += 24LL;
                if (v12 - *v16 == 4080)
                {
                  unint64_t v40 = v16[1];
                  ++v16;
                  unint64_t v12 = v40;
                }

                v38 += 24LL;
              }

              while (v38 != v37);
              uint64_t v28 = *(void *)(v3 - 32);
            }

            v28 -= 0x5555555555555555LL * ((uint64_t)(v37 - v27) >> 3);
            *(void *)(v3 - 32) = v28;
            if (v29 == v32) {
              break;
            }
            unint64_t v41 = v29[1];
            ++v29;
            unint64_t v27 = v41;
          }
        }
      }

      *(void *)(v3 - 24) = 0LL;
      *(void *)(v3 - 16) = 0LL;
      *(void *)(v3 - 8) = 0LL;
      unint64_t v43 = *(_BYTE **)(v2 - 24);
      uint64_t v42 = *(_BYTE **)(v2 - 16);
      int64_t v44 = v42 - v43;
      if (v42 != v43)
      {
        if (v42 - v43 < 0) {
          abort();
        }
        uint64_t v45 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<GTMMappedBufferBlock>>(v44 >> 5);
        *(void *)(v3 - 24) = v45;
        *(void *)(v3 - 16) = v45;
        *(void *)(v3 - 8) = &v45[32 * v46];
        memmove(v45, v43, v44);
        *(void *)(v3 - 16) = &v45[32 * (v44 >> 5)];
      }

      uint64_t v2 = v4;
      uint64_t v3 = v5;
    }

    while (v4 != v52);
  }

  a2[1] = v5;
  uint64_t v47 = *a1;
  *a1 = v5;
  a2[1] = v47;
  uint64_t v48 = a1[1];
  a1[1] = a2[2];
  a2[2] = v48;
  uint64_t v49 = a1[2];
  a1[2] = a2[3];
  a2[3] = v49;
  *a2 = a2[1];
}

void sub_65804( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p)
{
  _Unwind_Resume(a1);
}

uint64_t std::__split_buffer<GTMMappedBuffer>::~__split_buffer(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 120;
    GTMMappedBuffer::~GTMMappedBuffer((GTMMappedBuffer *)(i - 120));
  }

  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void GTMMappedBuffer::~GTMMappedBuffer(GTMMappedBuffer *this)
{
  uint64_t v2 = (void *)*((void *)this + 12);
  uint64_t v3 = *((void *)this + 13);
  if (v2 != (void *)v3 && *((_DWORD *)this + 9))
  {
    do
    {
      munmap(*(void **)(v3 - 24), *((unsigned int *)this + 10));
      uint64_t v4 = *((void *)this + 12);
      uint64_t v3 = *((void *)this + 13) - 32LL;
      *((void *)this + 13) = v3;
    }

    while (v4 != v3);
    close(*((_DWORD *)this + 8));
    uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue(+[NSFileManager defaultManager](&OBJC_CLASS___NSFileManager, "defaultManager"));
    [v5 removeItemAtPath:*((void *)this + 3) error:0];

    uint64_t v2 = (void *)*((void *)this + 12);
  }

  if (v2)
  {
    *((void *)this + 13) = v2;
    operator delete(v2);
  }

  std::deque<GTMMappedBuffer::UsedBlock>::~deque[abi:nn180100]((void *)this + 6);
}

void sub_6596C(_Unwind_Exception *a1)
{
  uint64_t v3 = v2;

  uint64_t v5 = *(void **)(v1 + 96);
  if (v5)
  {
    *(void *)(v1 + 104) = v5;
    operator delete(v5);
  }

  std::deque<GTMMappedBuffer::UsedBlock>::~deque[abi:nn180100]((void *)(v1 + 48));

  _Unwind_Resume(a1);
}

uint64_t std::deque<GTMMappedBuffer::UsedBlock>::~deque[abi:nn180100](void *a1)
{
  uint64_t v2 = (void **)a1[1];
  uint64_t v3 = (void **)a1[2];
  a1[5] = 0LL;
  unint64_t v4 = (char *)v3 - (char *)v2;
  if ((unint64_t)((char *)v3 - (char *)v2) >= 0x11)
  {
    do
    {
      operator delete(*v2);
      uint64_t v3 = (void **)a1[2];
      uint64_t v2 = (void **)(a1[1] + 8LL);
      a1[1] = v2;
      unint64_t v4 = (char *)v3 - (char *)v2;
    }

    while ((unint64_t)((char *)v3 - (char *)v2) > 0x10);
  }

  unint64_t v5 = v4 >> 3;
  if (v5 == 1)
  {
    uint64_t v6 = 85LL;
  }

  else
  {
    if (v5 != 2) {
      goto LABEL_9;
    }
    uint64_t v6 = 170LL;
  }

  a1[4] = v6;
LABEL_9:
  while (v2 != v3)
  {
    __int128 v7 = *v2++;
    operator delete(v7);
  }

  return std::__split_buffer<ProfileEvent *>::~__split_buffer((uint64_t)a1);
}

void *std::__allocate_at_least[abi:nn180100]<std::allocator<GTMMappedBufferBlock>>(unint64_t a1)
{
  if (a1 >> 59) {
    std::__throw_bad_array_new_length[abi:nn180100]();
  }
  return operator new(32 * a1);
}

void std::__split_buffer<GTMMappedBuffer::UsedBlock *>::push_back(void *a1, void *a2)
{
  unint64_t v4 = (char *)a1[2];
  if (v4 == (char *)a1[3])
  {
    unint64_t v5 = (char *)a1[1];
    uint64_t v6 = (uint64_t)&v5[-*a1];
    if ((unint64_t)v5 <= *a1)
    {
      else {
        unint64_t v16 = (uint64_t)&v4[-*a1] >> 2;
      }
      uint64_t v17 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<std::pair<unsigned int,unsigned int>>>(v16);
      unint64_t v19 = &v17[8 * (v16 >> 2)];
      uint64_t v20 = (uint64_t *)a1[1];
      unint64_t v4 = v19;
      uint64_t v21 = a1[2] - (void)v20;
      if (v21)
      {
        unint64_t v4 = &v19[v21 & 0xFFFFFFFFFFFFFFF8LL];
        uint64_t v22 = 8 * (v21 >> 3);
        uint64_t v23 = &v17[8 * (v16 >> 2)];
        do
        {
          uint64_t v24 = *v20++;
          *(void *)uint64_t v23 = v24;
          v23 += 8;
          v22 -= 8LL;
        }

        while (v22);
      }

      uint64_t v25 = (char *)*a1;
      *a1 = v17;
      a1[1] = v19;
      a1[2] = v4;
      a1[3] = &v17[8 * v18];
      if (v25)
      {
        operator delete(v25);
        unint64_t v4 = (char *)a1[2];
      }
    }

    else
    {
      uint64_t v7 = v6 >> 3;
      BOOL v8 = v6 >> 3 < -1;
      uint64_t v9 = (v6 >> 3) + 2;
      if (v8) {
        uint64_t v10 = v9;
      }
      else {
        uint64_t v10 = v7 + 1;
      }
      uint64_t v11 = -(v10 >> 1);
      uint64_t v12 = v10 >> 1;
      uint64_t v13 = &v5[-8 * v12];
      int64_t v14 = v4 - v5;
      if (v4 != v5)
      {
        memmove(&v5[-8 * v12], v5, v4 - v5);
        unint64_t v4 = (char *)a1[1];
      }

      unint64_t v15 = &v4[8 * v11];
      unint64_t v4 = &v13[v14];
      a1[1] = v15;
      a1[2] = &v13[v14];
    }
  }

  *(void *)unint64_t v4 = *a2;
  a1[2] += 8LL;
}

void std::__split_buffer<GTMMappedBuffer::UsedBlock *>::push_front(uint64_t a1, void *a2)
{
  unint64_t v4 = *(char **)(a1 + 8);
  if (v4 == *(char **)a1)
  {
    uint64_t v6 = *(_BYTE **)(a1 + 16);
    uint64_t v7 = *(_BYTE **)(a1 + 24);
    if (v6 >= v7)
    {
      if (v7 == v4) {
        unint64_t v11 = 1LL;
      }
      else {
        unint64_t v11 = (v7 - v4) >> 2;
      }
      uint64_t v12 = 2 * v11;
      uint64_t v13 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<std::pair<unsigned int,unsigned int>>>(v11);
      unint64_t v5 = &v13[(v12 + 6) & 0xFFFFFFFFFFFFFFF8LL];
      unint64_t v15 = *(uint64_t **)(a1 + 8);
      unint64_t v16 = v5;
      uint64_t v17 = *(void *)(a1 + 16) - (void)v15;
      if (v17)
      {
        unint64_t v16 = &v5[v17 & 0xFFFFFFFFFFFFFFF8LL];
        uint64_t v18 = 8 * (v17 >> 3);
        unint64_t v19 = v5;
        do
        {
          uint64_t v20 = *v15++;
          *(void *)unint64_t v19 = v20;
          v19 += 8;
          v18 -= 8LL;
        }

        while (v18);
      }

      uint64_t v21 = *(char **)a1;
      *(void *)a1 = v13;
      *(void *)(a1 + 8) = v5;
      *(void *)(a1 + 16) = v16;
      *(void *)(a1 + 24) = &v13[8 * v14];
      if (v21)
      {
        operator delete(v21);
        unint64_t v5 = *(char **)(a1 + 8);
      }
    }

    else
    {
      uint64_t v8 = (v7 - v6) >> 3;
      if (v8 >= -1) {
        uint64_t v9 = v8 + 1;
      }
      else {
        uint64_t v9 = v8 + 2;
      }
      uint64_t v10 = v9 >> 1;
      unint64_t v5 = &v4[8 * (v9 >> 1)];
      if (v6 != v4)
      {
        memmove(&v4[8 * (v9 >> 1)], v4, v6 - v4);
        unint64_t v4 = *(char **)(a1 + 16);
      }

      *(void *)(a1 + 8) = v5;
      *(void *)(a1 + 16) = &v4[8 * v10];
    }
  }

  else
  {
    unint64_t v5 = *(char **)(a1 + 8);
  }

  *((void *)v5 - 1) = *a2;
  *(void *)(a1 + 8) -= 8LL;
}

void *std::__allocate_at_least[abi:nn180100]<std::allocator<std::vector<NSObject  {objcproto21OS_dispatch_semaphore}* {__strong}>>>( unint64_t a1)
{
  if (a1 >= 0xAAAAAAAAAAAAAABLL) {
    std::__throw_bad_array_new_length[abi:nn180100]();
  }
  return operator new(24 * a1);
}

void *std::vector<std::vector<NSObject {objcproto21OS_dispatch_semaphore}* {__strong}>>::__swap_out_circular_buffer( void *result, void *a2)
{
  uint64_t v3 = (void *)*result;
  uint64_t v2 = (void *)result[1];
  uint64_t v4 = a2[1];
  while (v2 != v3)
  {
    *(void *)(v4 - 24) = 0LL;
    *(void *)(v4 - 16) = 0LL;
    v4 -= 24LL;
    *(void *)(v4 + 16) = 0LL;
    __int128 v5 = *(_OWORD *)(v2 - 3);
    v2 -= 3;
    *(_OWORD *)uint64_t v4 = v5;
    *(void *)(v4 + 16) = v2[2];
    void *v2 = 0LL;
    v2[1] = 0LL;
    v2[2] = 0LL;
  }

  a2[1] = v4;
  uint64_t v6 = (void *)*result;
  uint64_t *result = v4;
  a2[1] = v6;
  uint64_t v7 = result[1];
  result[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = result[2];
  result[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t std::__split_buffer<std::vector<NSObject  {objcproto21OS_dispatch_semaphore}* {__strong}>>::~__split_buffer( uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    uint64_t v4 = (void **)(i - 24);
    *(void *)(a1 + 16) = v4;
    uint64_t v6 = v4;
    std::vector<NSObject  {objcproto21OS_dispatch_semaphore}* {__strong}>::__destroy_vector::operator()[abi:nn180100](&v6);
  }

  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void DynamicBuffer::DynamicBuffer(DynamicBuffer *this)
{
  *((void *)this + 3) = 0LL;
  *((void *)this + 4) = 0LL;
  *((void *)this + 5) = 0LL;
  *(void *)this = 0LL;
  *((void *)this + 1) = 0LL;
  *((_DWORD *)this + 4) = 0;
  uint64_t v2 = (char *)operator new(0xC00uLL);
  *((void *)this + 3) = v2;
  *((void *)this + 4) = v2;
  *((void *)this + 5) = v2 + 3072;
}

void *std::__allocate_at_least[abi:nn180100]<std::allocator<DynamicBuffer>>(unint64_t a1)
{
  if (a1 >= 0x555555555555556LL) {
    std::__throw_bad_array_new_length[abi:nn180100]();
  }
  return operator new(48 * a1);
}

uint64_t *std::vector<DynamicBuffer>::__swap_out_circular_buffer(uint64_t *result, void *a2)
{
  uint64_t v2 = *result;
  uint64_t v3 = result[1];
  uint64_t v4 = a2[1];
  if (v3 == *result)
  {
    uint64_t v5 = a2[1];
  }

  else
  {
    do
    {
      uint64_t v5 = v4 - 48;
      uint64_t v6 = *(void *)(v3 - 32);
      *(_OWORD *)(v4 - 48) = *(_OWORD *)(v3 - 48);
      *(void *)(v4 - 32) = v6;
      *(void *)(v4 - 24) = 0LL;
      *(void *)(v4 - 16) = 0LL;
      *(void *)(v4 - 8) = 0LL;
      *(_OWORD *)(v4 - 24) = *(_OWORD *)(v3 - 24);
      *(void *)(v4 - 8) = *(void *)(v3 - 8);
      *(void *)(v3 - 24) = 0LL;
      *(void *)(v3 - 16) = 0LL;
      *(void *)(v3 - 8) = 0LL;
      v3 -= 48LL;
      v4 -= 48LL;
    }

    while (v3 != v2);
  }

  a2[1] = v5;
  uint64_t v7 = *result;
  uint64_t *result = v5;
  a2[1] = v7;
  uint64_t v8 = result[1];
  result[1] = a2[2];
  a2[2] = v8;
  uint64_t v9 = result[2];
  result[2] = a2[3];
  a2[3] = v9;
  *a2 = a2[1];
  return result;
}

uint64_t std::__split_buffer<DynamicBuffer>::~__split_buffer(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  uint64_t v2 = *(void *)(a1 + 16);
  while (v2 != v3)
  {
    *(void *)(a1 + 16) = v2 - 48;
    uint64_t v4 = *(void **)(v2 - 24);
    if (v4)
    {
      *(void *)(v2 - 16) = v4;
      operator delete(v4);
      uint64_t v2 = *(void *)(a1 + 16);
    }

    else
    {
      v2 -= 48LL;
    }
  }

  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

uint64_t std::__split_buffer<std::vector<GTMMappedBuffer>>::~__split_buffer(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    uint64_t v4 = (void **)(i - 24);
    *(void *)(a1 + 16) = v4;
    uint64_t v6 = v4;
    std::vector<GTMMappedBuffer>::__destroy_vector::operator()[abi:nn180100](&v6);
  }

  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void GTUSCSamplingStreamingManagerHelper::CleanUp(GTUSCSamplingStreamingManagerHelper *this)
{
  uint64_t v3 = (void *)*((void *)this + 274);
  if (v3)
  {
    [v3 cleanup];
    uint64_t v4 = (void *)*((void *)this + 274);
    *((void *)this + 274) = 0LL;
  }

  if (*(void *)this) {
    *(void *)this = 0LL;
  }
  GTUSCSamplingStreamingManagerHelper::CleanupGPURawCounters((uint64_t)this);
  ClearCaches();
  uint64_t v5 = (void *)*((void *)this + 1);
  *((void *)this + 1) = 0LL;

  GTApplePMPPerfStateControl::Close((GTUSCSamplingStreamingManagerHelper *)((char *)this + 64));
  std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::clear((void *)this + 281);
  uint64_t v6 = (void **)*((void *)this + 295);
  uint64_t v7 = (void **)*((void *)this + 294);
  while (v6 != v7)
  {
    v6 -= 3;
    dispatch_semaphore_t v57 = v6;
    std::vector<GTMMappedBuffer>::__destroy_vector::operator()[abi:nn180100](&v57);
  }

  *((void *)this + 295) = v7;
  std::vector<std::vector<GTMMappedBuffer>>::shrink_to_fit((uint64_t)this + 2352);
  uint64_t v8 = (void **)*((void *)this + 292);
  uint64_t v9 = (void **)*((void *)this + 291);
  while (v8 != v9)
  {
    v8 -= 3;
    dispatch_semaphore_t v57 = v8;
    std::vector<GTMMappedBuffer>::__destroy_vector::operator()[abi:nn180100](&v57);
  }

  *((void *)this + 292) = v9;
  std::vector<std::vector<GTMMappedBuffer>>::shrink_to_fit((uint64_t)this + 2328);
  uint64_t v10 = (void **)*((void *)this + 301);
  unint64_t v11 = (void **)*((void *)this + 300);
  while (v10 != v11)
  {
    v10 -= 3;
    dispatch_semaphore_t v57 = v10;
    std::vector<GTMMappedBuffer>::__destroy_vector::operator()[abi:nn180100](&v57);
  }

  *((void *)this + 301) = v11;
  std::vector<std::vector<GTMMappedBuffer>>::shrink_to_fit((uint64_t)this + 2400);
  uint64_t v12 = (void **)*((void *)this + 304);
  uint64_t v13 = (void **)*((void *)this + 303);
  while (v12 != v13)
  {
    v12 -= 3;
    dispatch_semaphore_t v57 = v12;
    std::vector<NSObject  {objcproto21OS_dispatch_semaphore}* {__strong}>::__destroy_vector::operator()[abi:nn180100](&v57);
  }

  *((void *)this + 304) = v13;
  std::vector<std::vector<NSObject  {objcproto21OS_dispatch_semaphore}* {__strong}>>::shrink_to_fit((uint64_t)this + 2424);
  uint64_t v14 = (void **)*((void *)this + 307);
  unint64_t v15 = (void **)*((void *)this + 306);
  while (v14 != v15)
  {
    v14 -= 3;
    dispatch_semaphore_t v57 = v14;
    std::vector<NSObject  {objcproto21OS_dispatch_semaphore}* {__strong}>::__destroy_vector::operator()[abi:nn180100](&v57);
  }

  *((void *)this + 307) = v15;
  std::vector<std::vector<NSObject  {objcproto21OS_dispatch_semaphore}* {__strong}>>::shrink_to_fit((uint64_t)this + 2448);
  unint64_t v16 = (void **)*((void *)this + 310);
  uint64_t v17 = (void **)*((void *)this + 309);
  if (v16 != v17)
  {
    do
    {
      uint64_t v18 = *--v16;
    }

    while (v16 != v17);
    unint64_t v16 = (void **)*((void *)this + 309);
  }

  *((void *)this + 310) = v17;
  unint64_t v19 = v17 - v16;
  if (v19 < (uint64_t)(*((void *)this + 311) - (void)v16) >> 3)
  {
    uint64_t v61 = (char *)this + 2488;
    if (v17 == v16)
    {
      uint64_t v24 = 0LL;
      uint64_t v22 = 8 * v19;
    }

    else
    {
      uint64_t v20 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<std::pair<unsigned int,unsigned int>>>(v17 - v16);
      uint64_t v17 = (void **)*((void *)this + 310);
      uint64_t v21 = (void **)*((void *)this + 309);
      uint64_t v22 = (uint64_t)&v20[8 * v19];
      int v59 = (void **)v22;
      uint64_t v24 = &v20[8 * v23];
      if (v17 != v21)
      {
        uint64_t v25 = &v20[8 * v19];
        do
        {
          uint64_t v26 = (uint64_t)*--v17;
          char *v17 = 0LL;
          *((void *)v25 - 1) = v26;
          v25 -= 8;
        }

        while (v17 != v21);
        unint64_t v27 = (void **)*((void *)this + 309);
        uint64_t v17 = (void **)*((void *)this + 310);
        goto LABEL_32;
      }
    }

    unint64_t v27 = v17;
    uint64_t v25 = (char *)v22;
LABEL_32:
    *((void *)this + 309) = v25;
    *((void *)this + 310) = v22;
    uint64_t v28 = (void **)*((void *)this + 311);
    *((void *)this + 311) = v24;
    int v59 = v17;
    uint64_t v60 = v28;
    dispatch_semaphore_t v57 = v27;
    dispatch_semaphore_t v58 = v27;
    std::__split_buffer<NSObject  {objcproto21OS_dispatch_semaphore}* {__strong}>::~__split_buffer((uint64_t)&v57);
  }

  std::vector<std::vector<ProfileEvent>>::__clear[abi:nn180100]((uint64_t *)this + 275);
  unint64_t v29 = *((void *)this + 275);
  int64x2_t v30 = *((int64x2_t *)this + 138);
  int64x2_t v31 = vshrq_n_s64(vsubq_s64(v30, vdupq_n_s64(v29)), 3uLL);
  unint64_t v32 = 0xAAAAAAAAAAAAAAABLL * v31.i64[0];
  unint64_t v33 = v32;
  if (0xAAAAAAAAAAAAAAABLL * v31.i64[1] > v32)
  {
    uint64_t v61 = (char *)this + 2216;
    if (v30.i64[0] == v29)
    {
      unint64_t v34 = 0LL;
      uint64_t v35 = 0LL;
    }

    else
    {
      unint64_t v34 = (void **)std::__allocate_at_least[abi:nn180100]<std::allocator<std::vector<NSObject  {objcproto21OS_dispatch_semaphore}* {__strong}>>>(v32);
    }

    dispatch_semaphore_t v57 = v34;
    dispatch_semaphore_t v58 = &v34[3 * v33];
    int v59 = v58;
    uint64_t v60 = &v34[3 * v35];
    std::vector<std::vector<NSObject  {objcproto21OS_dispatch_semaphore}* {__strong}>>::__swap_out_circular_buffer( (void *)this + 275,  &v57);
    std::__split_buffer<std::vector<std::pair<unsigned int,unsigned int>>>::~__split_buffer((uint64_t)&v57);
  }

  uint64_t v36 = (void *)*((void *)this + 278);
  *((void *)this + 279) = v36;
  if (*((void **)this + 280) != v36)
  {
    *((void *)this + 278) = 0LL;
    *((void *)this + 279) = 0LL;
    *((void *)this + 280) = 0LL;
    if (v36) {
      operator delete(v36);
    }
  }

  std::vector<DynamicBuffer>::__clear[abi:nn180100]((uint64_t *)this + 297);
  unint64_t v37 = *((void *)this + 297);
  int64x2_t v38 = *((int64x2_t *)this + 149);
  int64x2_t v39 = vshrq_n_s64(vsubq_s64(v38, vdupq_n_s64(v37)), 4uLL);
  unint64_t v40 = 0xAAAAAAAAAAAAAAABLL * v39.i64[0];
  unint64_t v41 = v40;
  if (0xAAAAAAAAAAAAAAABLL * v39.i64[1] > v40)
  {
    uint64_t v61 = (char *)this + 2392;
    if (v38.i64[0] == v37)
    {
      uint64_t v42 = 0LL;
      uint64_t v43 = 0LL;
    }

    else
    {
      uint64_t v42 = (void **)std::__allocate_at_least[abi:nn180100]<std::allocator<DynamicBuffer>>(v40);
    }

    dispatch_semaphore_t v57 = v42;
    dispatch_semaphore_t v58 = &v42[6 * v41];
    int v59 = v58;
    uint64_t v60 = &v42[6 * v43];
    std::vector<DynamicBuffer>::__swap_out_circular_buffer((uint64_t *)this + 297, &v57);
    std::__split_buffer<DynamicBuffer>::~__split_buffer((uint64_t)&v57);
  }

  int64_t v44 = (void *)*((void *)this + 314);
  *((void *)this + 314) = 0LL;

  uint64_t v45 = (void *)*((void *)this + 313);
  *((void *)this + 313) = 0LL;

  uint64_t v46 = (void *)*((void *)this + 315);
  *((void *)this + 315) = 0LL;

  uint64_t v47 = (void *)*((void *)this + 316);
  *((void *)this + 316) = 0LL;

  *((_BYTE *)this + 2184) = 1;
  *((_DWORD *)this + 541) = 0;
  *((void *)this + 271) = 1LL;
  *((void *)this + 241) = 0LL;
  uint64_t v48 = (void *)*((void *)this + 246);
  *((void *)this + 246) = 0LL;

  *((void *)this + 247) = 0LL;
  *((void *)this + 269) = 0LL;
  *((void *)this + 267) = *((void *)this + 266);
  uint64_t v49 = (void *)*((void *)this + 274);
  *((void *)this + 274) = 0LL;

  id v50 = (void *)*((void *)this + 286);
  *((void *)this + 286) = 0LL;

  unint64_t v51 = (void *)*((void *)this + 287);
  *((void *)this + 287) = 0LL;

  uint64_t v52 = (void *)*((void *)this + 289);
  *((void *)this + 289) = 0LL;

  unint64_t v53 = (void *)*((void *)this + 290);
  *((void *)this + 290) = 0LL;

  atomic_store(0, (unsigned int *)this + 684);
  atomic_store(0, (unsigned int *)this + 685);
  atomic_store(0, (unsigned int *)this + 686);
  atomic_store(0, (unsigned int *)this + 687);
  atomic_store(0, (unsigned int *)this + 688);
  atomic_store(0LL, (unint64_t *)this + 341);
  atomic_store(0, (unsigned int *)this + 689);
  atomic_store(0, (unsigned __int8 *)this + 2760);
  atomic_store(0, (unsigned __int8 *)this + 2761);
  atomic_store(0, (unsigned __int8 *)this + 2763);
  atomic_store(0, (unsigned __int8 *)this + 2764);
  uint64_t v54 = *((void *)this + 392);
  uint64_t v55 = *((void *)this + 391);
  while (v54 != v55)
  {
    uint64_t v56 = *(void **)(v54 - 32);
    v54 -= 32LL;
  }

  *((void *)this + 392) = v55;
LABEL_50:
  os_unfair_lock_unlock((os_unfair_lock_t)&GTUSCSamplingStreamingManagerHelper::CleanUp(void)::localSpinLock);
}

void sub_6649C(_Unwind_Exception *a1)
{
}

void ClearCaches(void)
{
  uint64_t v10 = (void *)objc_claimAutoreleasedReturnValue(+[NSFileManager defaultManager](&OBJC_CLASS___NSFileManager, "defaultManager"));
  if ([v10 fileExistsAtPath:@"/tmp/com.apple.gputools.profiling"])
  {
    __int128 v15 = 0u;
    __int128 v16 = 0u;
    __int128 v13 = 0u;
    __int128 v14 = 0u;
    id v12 = 0LL;
    v0 = (void *)objc_claimAutoreleasedReturnValue( [v10 contentsOfDirectoryAtPath:@"/tmp/com.apple.gputools.profiling" error:&v12]);
    id v1 = v12;
    id v2 = [v0 countByEnumeratingWithState:&v13 objects:v17 count:16];
    if (v2)
    {
      uint64_t v3 = *(void *)v14;
      do
      {
        for (uint64_t i = 0LL; i != v2; uint64_t i = (char *)i + 1)
        {
          if (*(void *)v14 != v3) {
            objc_enumerationMutation(v0);
          }
          uint64_t v5 = *(void **)(*((void *)&v13 + 1) + 8LL * (void)i);
          uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue([v5 pathExtension]);
          BOOL v7 = [v6 caseInsensitiveCompare:@"mmapbuffer"] == 0;

          if (v7)
          {
            uint64_t v8 = (void *)objc_claimAutoreleasedReturnValue( [@"/tmp/com.apple.gputools.profiling" stringByAppendingPathComponent:v5]);
            id v11 = v1;
            [v10 removeItemAtPath:v8 error:&v11];
            id v9 = v11;

            id v1 = v9;
          }
        }

        id v2 = [v0 countByEnumeratingWithState:&v13 objects:v17 count:16];
      }

      while (v2);
    }
  }

  else
  {
    [v10 createDirectoryAtPath:@"/tmp/com.apple.gputools.profiling" withIntermediateDirectories:1 attributes:0 error:0];
  }
}

void sub_66698( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  _Unwind_Resume(a1);
}

uint64_t std::vector<std::vector<GTMMappedBuffer>>::shrink_to_fit(uint64_t result)
{
  unint64_t v1 = *(void *)result;
  int64x2_t v2 = *(int64x2_t *)(result + 8);
  int64x2_t v3 = vshrq_n_s64(vsubq_s64(v2, vdupq_n_s64(*(void *)result)), 3uLL);
  unint64_t v4 = 0xAAAAAAAAAAAAAAABLL * v3.i64[0];
  unint64_t v5 = v4;
  if (0xAAAAAAAAAAAAAAABLL * v3.i64[1] > v4)
  {
    uint64_t v6 = (void *)result;
    uint64_t v13 = result + 16;
    if (v2.i64[0] == v1)
    {
      BOOL v7 = 0LL;
      uint64_t v8 = 0LL;
    }

    else
    {
      BOOL v7 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<std::vector<NSObject  {objcproto21OS_dispatch_semaphore}* {__strong}>>>(v4);
    }

    id v9 = v7;
    uint64_t v10 = &v7[24 * v5];
    id v11 = v10;
    id v12 = &v7[24 * v8];
    std::vector<std::vector<NSObject  {objcproto21OS_dispatch_semaphore}* {__strong}>>::__swap_out_circular_buffer( v6,  &v9);
    return std::__split_buffer<std::vector<GTMMappedBuffer>>::~__split_buffer((uint64_t)&v9);
  }

  return result;
}

uint64_t std::vector<std::vector<NSObject  {objcproto21OS_dispatch_semaphore}* {__strong}>>::shrink_to_fit( uint64_t result)
{
  unint64_t v1 = *(void *)result;
  int64x2_t v2 = *(int64x2_t *)(result + 8);
  int64x2_t v3 = vshrq_n_s64(vsubq_s64(v2, vdupq_n_s64(*(void *)result)), 3uLL);
  unint64_t v4 = 0xAAAAAAAAAAAAAAABLL * v3.i64[0];
  unint64_t v5 = v4;
  if (0xAAAAAAAAAAAAAAABLL * v3.i64[1] > v4)
  {
    uint64_t v6 = (void *)result;
    uint64_t v13 = result + 16;
    if (v2.i64[0] == v1)
    {
      BOOL v7 = 0LL;
      uint64_t v8 = 0LL;
    }

    else
    {
      BOOL v7 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<std::vector<NSObject  {objcproto21OS_dispatch_semaphore}* {__strong}>>>(v4);
    }

    id v9 = v7;
    uint64_t v10 = &v7[24 * v5];
    id v11 = v10;
    id v12 = &v7[24 * v8];
    std::vector<std::vector<NSObject  {objcproto21OS_dispatch_semaphore}* {__strong}>>::__swap_out_circular_buffer( v6,  &v9);
    return std::__split_buffer<std::vector<NSObject  {objcproto21OS_dispatch_semaphore}* {__strong}>>::~__split_buffer((uint64_t)&v9);
  }

  return result;
}

void std::vector<DynamicBuffer>::__clear[abi:nn180100](uint64_t *a1)
{
  uint64_t v2 = *a1;
  for (uint64_t i = a1[1]; i != v2; i -= 48LL)
  {
    unint64_t v4 = *(void **)(i - 24);
    if (v4)
    {
      *(void *)(i - 16) = v4;
      operator delete(v4);
    }
  }

  a1[1] = v2;
}

uint64_t std::__split_buffer<std::vector<std::pair<unsigned int,unsigned int>>>::~__split_buffer(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  uint64_t v2 = *(void *)(a1 + 16);
  while (v2 != v3)
  {
    unint64_t v4 = *(void **)(v2 - 24);
    *(void *)(a1 + 16) = v2 - 24;
    if (v4)
    {
      *(void *)(v2 - 16) = v4;
      operator delete(v4);
      uint64_t v2 = *(void *)(a1 + 16);
    }

    else
    {
      v2 -= 24LL;
    }
  }

  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void GTUSCSamplingStreamingManagerHelper::SetupMTLCounterAPIBuffer( GTUSCSamplingStreamingManagerHelper *this)
{
  id v6 = *(id *)(GTUSCSamplingStreamingManagerHelper::Instance(void)::instance + 16);
  unint64_t v1 = (void *)objc_claimAutoreleasedReturnValue( [*(id *)(*(void *)GTUSCSamplingStreamingManagerHelper::Instance(void)::instance + 8) defaultDevice]);
  id v2 = DEVICEOBJECT(v1);
  uint64_t v3 = (void *)objc_claimAutoreleasedReturnValue(v2);

  if (v3
    && *(_DWORD *)(GTUSCSamplingStreamingManagerHelper::Instance(void)::instance + 76)
    && (void)xmmword_5B9440 != *((void *)&xmmword_5B9440 + 1))
  {
    uint64_t v4 = xmmword_5B9440 + 4;
    do
    {
      if ((*(_BYTE *)(v4 - 4) & 0x10) != 0) {
        break;
      }
      BOOL v5 = v4 == *((void *)&xmmword_5B9440 + 1);
      v4 += 4LL;
    }

    while (!v5);
  }
}

void sub_669A8( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void std::vector<std::pair<unsigned int,unsigned int>>::reserve(void **a1, unint64_t a2)
{
  if (a2 > ((_BYTE *)a1[2] - (_BYTE *)*a1) >> 3)
  {
    if (a2 >> 61) {
      abort();
    }
    int64_t v3 = (_BYTE *)a1[1] - (_BYTE *)*a1;
    uint64_t v4 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<std::pair<unsigned int,unsigned int>>>(a2);
    BOOL v5 = &v4[v3 & 0xFFFFFFFFFFFFFFF8LL];
    BOOL v7 = &v4[8 * v6];
    id v9 = (char *)*a1;
    uint64_t v8 = (char *)a1[1];
    uint64_t v10 = v5;
    if (v8 != *a1)
    {
      do
      {
        uint64_t v11 = *((void *)v8 - 1);
        v8 -= 8;
        *((void *)v10 - 1) = v11;
        v10 -= 8;
      }

      while (v8 != v9);
      uint64_t v8 = (char *)*a1;
    }

    *a1 = v10;
    a1[1] = v5;
    a1[2] = v7;
    if (v8) {
      operator delete(v8);
    }
  }

void ___ZN35GTUSCSamplingStreamingManagerHelper20InitBatchIdFilteringEP29GTUSCSamplingStreamingManager_block_invoke( uint64_t a1)
{
  unint64_t v1 = *(uint64_t ***)(a1 + 32);
  GTMTLReplayController_prePlayForProfiling(**v1);
  unint64_t v62 = (void *)objc_claimAutoreleasedReturnValue([(id)(*v1)[2] objectForKeyedSubscript:@"perEncoderDrawCallCount"]);
  uint64_t v60 = v1;
  uint64_t v2 = **v1;
  id v63 = *(id *)(v2 + 8);
  int64_t v3 = *(uint64_t **)v2;
  uint64_t v61 = *(void *)(*(void *)v2 + 16LL);
  int v59 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v2 + 8) defaultCommandQueue]);
  char v71 = 0;
  uint64_t v69 = v2;
  uint64_t v4 = (unsigned int *)(v2 + 22480);
  if (v3[13] + v3[12] > (unint64_t)*(unsigned int *)(v2 + 22480))
  {
    uint64_t v64 = v3;
    unint64_t v65 = 0LL;
    int v5 = 0;
    dispatch_semaphore_t v58 = (char **)(v60 + 278);
    do
    {
      uint64_t v6 = objc_autoreleasePoolPush();
      uint64_t v7 = *(void *)(v3[15] + 24);
      uint64_t v8 = *v4;
      uint64_t v9 = v7 + (v8 << 6);
      uint64_t v11 = (int *)(v9 + 8);
      int v10 = *(_DWORD *)(v9 + 8);
      int FuncEnumConstructorType = GetFuncEnumConstructorType(v10);
      if (FuncEnumConstructorType == 25)
      {
        GTMTLReplayController_restoreCommandBuffer(v69, v7 + (v8 << 6));
        int v10 = *v11;
      }

      uint64_t v66 = v8;
      uint64_t v67 = v7;
      context = v6;
      uint64_t v13 = v4;
      BOOL v14 = IsFuncEnumGPUCommandCall(v10);
      int v15 = IsFuncEnumEndEncoding(v10);
      int v16 = (v14 | v15) & v5;
      if (v16 == 1)
      {
        uint64_t v17 = GTTraceFunc_targetContext(v9, v3[2]);
        uint64_t v18 = 0LL;
        int v19 = *(_DWORD *)(v69 + 11312);
        if (v19 > 64)
        {
          if (v19 == 65)
          {
            uint64_t v20 = (void *)objc_claimAutoreleasedReturnValue([v63 parallelRenderCommandEncoderForKey:v17]);
            id v25 = DEVICEOBJECT(v20);
            uint64_t v22 = objc_claimAutoreleasedReturnValue(v25);
            goto LABEL_16;
          }

          if (v19 == 70)
          {
            uint64_t v20 = (void *)objc_claimAutoreleasedReturnValue([v63 renderCommandEncoderForKey:v17]);
            id v23 = DEVICEOBJECT(v20);
            uint64_t v22 = objc_claimAutoreleasedReturnValue(v23);
            goto LABEL_16;
          }
        }

        else
        {
          if (v19 == 21)
          {
            uint64_t v20 = (void *)objc_claimAutoreleasedReturnValue([v63 blitCommandEncoderForKey:v17]);
            id v24 = DEVICEOBJECT(v20);
            uint64_t v22 = objc_claimAutoreleasedReturnValue(v24);
            goto LABEL_16;
          }

          if (v19 == 28)
          {
            uint64_t v20 = (void *)objc_claimAutoreleasedReturnValue([v63 computeCommandEncoderForKey:v17]);
            id v21 = DEVICEOBJECT(v20);
            uint64_t v22 = objc_claimAutoreleasedReturnValue(v21);
LABEL_16:
            uint64_t v18 = (void *)v22;
          }
        }
      }

      else
      {
        uint64_t v18 = 0LL;
      }

      GTMTLReplayController_updateCommandEncoder(v69, v9);
      if (*v11 >> 2 == 1073737833) {
        GTUSCSamplingStreamingManagerHelper::DispatchExpandedIndirectCommand( (uint64_t)v60,  v69,  (unint64_t *)v9,  v58,  0LL);
      }
      else {
        DispatchFunction((id *)v69, v9, &v71);
      }
      v5 &= v15 ^ 1;
      if (GTMTLReplayHost_IsFuncEnumSampledEncoder(*v11, 1, 0LL))
      {
        uint64_t v4 = v13;
        uint64_t v26 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInt:](&OBJC_CLASS___NSNumber, "numberWithUnsignedInt:", *v13));
        unint64_t v27 = (void *)objc_claimAutoreleasedReturnValue([v62 objectForKeyedSubscript:v26]);

        if (v27) {
          int v5 = 1;
        }
        unint64_t v28 = v65;
        if (v27) {
          unint64_t v28 = v65 + 1;
        }
        unint64_t v65 = v28;
      }

      else if (v16)
      {
        uint64_t v70 = 0LL;
        uint64_t v4 = v13;
        if (v18)
        {
          if (v14)
          {
            [v18 commandBatchIdRangeMin:(char *)&v70 + 4 max:&v70];
            unint64_t v29 = (char *)v60[279];
            unint64_t v30 = (unint64_t)v60[280];
            if ((unint64_t)v29 >= v30)
            {
              uint64_t v42 = (v29 - *v58) >> 3;
              unint64_t v43 = v42 + 1;
              uint64_t v44 = v30 - (void)*v58;
              if (v44 >> 2 > v43) {
                unint64_t v43 = v44 >> 2;
              }
              else {
                unint64_t v45 = v43;
              }
              uint64_t v46 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<std::pair<unsigned int,unsigned int>>>(v45);
              uint64_t v48 = &v46[8 * v42];
              *(_DWORD *)uint64_t v48 = HIDWORD(v70);
              *((_DWORD *)v48 + 1) = v70;
              uint64_t v49 = (char *)v60[279];
              id v50 = (char *)v60[278];
              unint64_t v51 = v48;
              if (v49 != v50)
              {
                do
                {
                  uint64_t v52 = *((void *)v49 - 1);
                  v49 -= 8;
                  *((void *)v51 - 1) = v52;
                  v51 -= 8;
                }

                while (v49 != v50);
                uint64_t v49 = *v58;
              }

              v60[278] = (uint64_t *)v51;
              int64x2_t v31 = (uint64_t *)(v48 + 8);
              v60[279] = (uint64_t *)(v48 + 8);
              v60[280] = (uint64_t *)&v46[8 * v47];
              if (v49) {
                operator delete(v49);
              }
            }

            else
            {
              *(_DWORD *)unint64_t v29 = HIDWORD(v70);
              *((_DWORD *)v29 + 1) = v70;
              int64x2_t v31 = (uint64_t *)(v29 + 8);
            }

            v60[279] = v31;
          }

          else if (v15 && v60[278] != v60[279])
          {
            unsigned int v32 = [v18 commandBatchIdOffset];
            unint64_t v33 = (int32x2_t *)v60[278];
            unint64_t v34 = (int32x2_t *)v60[279];
            if (v33 != v34)
            {
              int32x2_t v35 = vdup_n_s32(v32);
              uint64_t v36 = (int32x2_t *)v60[278];
              do
              {
                *uint64_t v36 = vsub_s32(*v36, v35);
                ++v36;
              }

              while (v36 != v34);
            }

            if (v65)
            {
              unint64_t v37 = v60[275];
              if (v65 <= 0xAAAAAAAAAAAAAAABLL * (v60[276] - v37))
              {
                int64x2_t v38 = &v37[3 * v65];
                int64x2_t v39 = (uint64_t *)*(v38 - 3);
                *(v38 - 3) = (uint64_t)v33;
                v60[278] = v39;
                unint64_t v40 = (uint64_t *)*(v38 - 2);
                *(v38 - 2) = (uint64_t)v60[279];
                v60[279] = v40;
                unint64_t v41 = (uint64_t *)*(v38 - 1);
                *(v38 - 1) = (uint64_t)v60[280];
                v60[280] = v41;
              }
            }
          }
        }
      }

      else
      {
        uint64_t v4 = v13;
      }

      if (FuncEnumConstructorType == 25)
      {
        id v53 = objc_msgSend( v63,  "commandBufferForKey:",  *((void *)GTTraceFunc_argumentBytesWithMap( (void *)v9,  *(unsigned __int8 *)(v67 + (v66 << 6) + 13),  v61)
                + 1));
        uint64_t v54 = (void *)objc_claimAutoreleasedReturnValue(v53);
        id v55 = DEVICEOBJECT(v54);
        uint64_t v56 = (void *)objc_claimAutoreleasedReturnValue(v55);

        [v56 setDisableDeferredEndEncoding:1];
      }

      objc_autoreleasePoolPop(context);
      unint64_t v57 = *v4 + 1;
      *uint64_t v4 = v57;
      int64_t v3 = v64;
    }

    while (v64[13] + v64[12] > v57);
  }

  objc_msgSend(v59, "finish", v58);
}

void sub_66F98( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, void *a13, void *a14)
{
  _Unwind_Resume(a1);
}

void DispatchFunction(id *a1, uint64_t a2, _BYTE *a3)
{
  id v16 = a1[1];
  uint64_t v6 = *((void *)*a1 + 2);
  int v7 = *(_DWORD *)(a2 + 8);
  if (v7 <= -16286)
  {
    if (v7 == -16351)
    {
      *a3 = 1;
      int v10 = GTTraceFunc_argumentBytesWithMap((void *)a2, *(unsigned __int8 *)(a2 + 13), v6);
      uint64_t v11 = GTTraceFunc_argumentBytesWithMap((void *)a2, v10[16], v6);
      uint64_t v9 = (void *)objc_claimAutoreleasedReturnValue([v16 commandBufferForKey:*(void *)v10]);
      id v12 = (void *)objc_claimAutoreleasedReturnValue([v16 renderPassDescriptorMap]);
      MTLuint64_t RenderPassDescriptor = MakeMTLRenderPassDescriptor((uint64_t)v11, v12);
      BOOL v14 = (void *)objc_claimAutoreleasedReturnValue(MTLRenderPassDescriptor);

      int v15 = (void *)objc_claimAutoreleasedReturnValue([v9 renderCommandEncoderWithDescriptor:v14]);
      [v16 setParallelRenderCommandEncoder:v15 forKey:*((void *)v10 + 1)];

      goto LABEL_10;
    }

    if (v7 == -16286)
    {
      uint64_t v8 = GTTraceFunc_argumentBytesWithMap((void *)a2, *(unsigned __int8 *)(a2 + 13), *((void *)*a1 + 2));
      uint64_t v9 = (void *)objc_claimAutoreleasedReturnValue([v16 parallelRenderCommandEncoderForKey:*(void *)v8]);
      [v16 setRenderCommandEncoder:v9 forKey:*((void *)v8 + 1)];
LABEL_10:

      goto LABEL_15;
    }

{
  uint64_t v6;
  int v7;
  char *v8;
  void *v9;
  char *v10;
  uint64_t RenderPassDescriptor;
  void *v12;
  MTLRenderPassDescriptor *MTLRenderPassDescriptor;
  void *v14;
  void *v15;
  id v16;
  id v16 = a1[1];
  uint64_t v6 = *((void *)*a1 + 2);
  int v7 = *(_DWORD *)(a2 + 8);
  if (v7 <= -16286)
  {
    if (v7 == -16351)
    {
      *a3 = 1;
      int v10 = GTTraceFunc_argumentBytesWithMap((void *)a2, *(unsigned __int8 *)(a2 + 13), v6);
      uint64_t RenderPassDescriptor = GetRenderPassDescriptor((uint64_t *)a2, v6);
      uint64_t v9 = (void *)objc_claimAutoreleasedReturnValue([v16 commandBufferForKey:*(void *)v10]);
      id v12 = (void *)objc_claimAutoreleasedReturnValue([v16 renderPassDescriptorMap]);
      MTLuint64_t RenderPassDescriptor = MakeMTLRenderPassDescriptor(RenderPassDescriptor, v12);
      BOOL v14 = (void *)objc_claimAutoreleasedReturnValue(MTLRenderPassDescriptor);

      int v15 = (void *)objc_claimAutoreleasedReturnValue([v9 renderCommandEncoderWithDescriptor:v14]);
      [v16 setParallelRenderCommandEncoder:v15 forKey:*((void *)v10 + 1)];

      goto LABEL_10;
    }

    if (v7 == -16286)
    {
      uint64_t v8 = GTTraceFunc_argumentBytesWithMap((void *)a2, *(unsigned __int8 *)(a2 + 13), *((void *)*a1 + 2));
      uint64_t v9 = (void *)objc_claimAutoreleasedReturnValue([v16 parallelRenderCommandEncoderForKey:*(void *)v8]);
      [v16 setRenderCommandEncoder:v9 forKey:*((void *)v8 + 1)];
LABEL_10:

      goto LABEL_13;
    }

LABEL_12:
    if (v7 >> 2 == 1073737833)
    {
      GTMTLReplayController_executeCommandsInBuffer((uint64_t *)a1, (unint64_t *)a2, 0LL, 0xFFFFFFFFFFFFFFFFLL);
      goto LABEL_15;
    }

  *(_DWORD *)(v2 + 22484) = 0;
}

  uint64_t v9 = atomic_load((unsigned __int8 *)this + 2763);
  if ((v9 & 1) == 0)
  {
    int v10 = (unsigned int *)((char *)this + 2748);
    unint64_t v34 = v7;
    while (1)
    {
      uint64_t v11 = atomic_load((unsigned __int8 *)this + 2764);
      if ((v11 & 1) != 0) {
        goto LABEL_40;
      }
      id v12 = *(dispatch_semaphore_s **)(*(void *)(*((void *)this + 303) + 24LL * a2) + 8LL * a3);
      uint64_t v13 = dispatch_time(0LL, 30000000LL);
      BOOL v14 = dispatch_semaphore_wait(v12, v13);
      int v15 = atomic_load((unsigned __int8 *)this + 2761);
      if ((v15 & 1) != 0)
      {
        id v16 = v14;
        uint64_t v17 = atomic_load((unsigned __int8 *)this + 2760);
        if ((v17 & 1) == 0 || !v14) {
          break;
        }
      }

  v140 = this;
  v138 = (void *)objc_claimAutoreleasedReturnValue([*((id *)this + 3) objectAtIndexedSubscript:v5]);
  int v7 = atomic_load((unsigned __int8 *)this + 2763);
  if ((v7 & 1) == 0)
  {
    uint64_t v8 = (unint64_t *)((char *)this + 2728);
    unint64_t v125 = (std::condition_variable *)((char *)this + 2768);
    uint64_t v126 = (std::condition_variable *)((char *)this + 2880);
    unint64_t v127 = (unsigned int *)((char *)this + 2744);
    unint64_t v128 = 120LL * a3;
    do
    {
      uint64_t v9 = atomic_load((unsigned __int8 *)v140 + 2764);
      if ((v9 & 1) != 0) {
        break;
      }
      dispatch_semaphore_wait( *(dispatch_semaphore_t *)(*(void *)(*((void *)v140 + 306) + 24LL * a2) + 8LL * a3),  0xFFFFFFFFFFFFFFFFLL);
      int v10 = atomic_load((unsigned __int8 *)v140 + 2763);
      if ((v10 & 1) != 0) {
        break;
      }
      uint64_t v11 = atomic_load((unsigned __int8 *)v140 + 2764);
      if ((v11 & 1) != 0) {
        break;
      }
      dispatch_semaphore_wait(*(dispatch_semaphore_t *)(*((void *)v140 + 309) + 8LL * a2), 0xFFFFFFFFFFFFFFFFLL);
      id v12 = *(void *)(*((void *)v140 + 294) + 24LL * a2) + v128;
      uint64_t v13 = *(void *)(*((void *)v140 + 300) + 24LL * a2);
      BOOL v14 = *(void *)(*((void *)v140 + 291) + 24LL * a2);
      dispatch_semaphore_wait(*(dispatch_semaphore_t *)v12, 0xFFFFFFFFFFFFFFFFLL);
      v153 = *(_OWORD *)(v12 + 48);
      *(_OWORD *)(v12 + 48) = 0u;
      uint64_t v154 = *(_OWORD *)(v12 + 64);
      *(_OWORD *)(v12 + 64) = 0u;
      dispatch_semaphore_t v155 = *(_OWORD *)(v12 + 80);
      *(_OWORD *)(v12 + 80) = 0u;
      uint64_t v135 = (GTMMappedBuffer *)v12;
      dispatch_semaphore_signal(*(dispatch_semaphore_t *)v12);
      v152[0] = 0LL;
      v151 = 0u;
      if (*((void *)&v155 + 1))
      {
        if (*((void *)&v155 + 1) > 0xAAAAAAAAAAAAAAAuLL) {
          abort();
        }
        *(void *)&v150 = v152;
        int v15 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<std::vector<NSObject  {objcproto21OS_dispatch_semaphore}* {__strong}>>>(*((unint64_t *)&v155 + 1));
        *(void *)v149 = v15;
        *(void *)&v149[8] = v15;
        uint64_t v17 = &v15[24 * v16];
        *(void *)&v149[16] = v15;
        *(void *)&v149[24] = v17;
        uint64_t v18 = v151.i64[1];
        int v19 = v151.i64[0];
        if (v151.i64[1] == v151.i64[0])
        {
          id v23 = vdupq_n_s64(v151.u64[1]);
          uint64_t v20 = v15;
        }

        else
        {
          uint64_t v20 = v15;
          do
          {
            id v21 = *(_OWORD *)(v18 - 24);
            v18 -= 24LL;
            *(_OWORD *)(v20 - 24) = v21;
            v20 -= 24;
            uint64_t v22 = *(void *)(v18 + 16);
            *(void *)(v18 + 16) = 0LL;
            *((void *)v20 + 2) = v22;
          }

          while (v18 != v19);
          id v23 = v151;
          uint64_t v17 = *(char **)&v149[24];
          int v15 = *(char **)&v149[16];
        }

        v151.i64[0] = (uint64_t)v20;
        v151.i64[1] = (uint64_t)v15;
        *(int64x2_t *)&v149[8] = v23;
        id v24 = v152[0];
        v152[0] = v17;
        *(void *)&v149[24] = v24;
        *(void *)v149 = v23.i64[0];
        std::__split_buffer<std::tuple<unsigned char *,unsigned long long,NSMutableData * {__strong}>>::~__split_buffer((uint64_t)v149);
      }

      unint64_t v133 = (dispatch_semaphore_t *)(v13 + v128);
      dispatch_semaphore_t v136 = (GTMMappedBuffer *)(v14 + v128);
      id v25 = atomic_load((unsigned __int8 *)v140 + 2760);
      if ((v25 & 1) == 0) {
        goto LABEL_35;
      }
      if ((void)v154 == *((void *)&v153 + 1)) {
        goto LABEL_35;
      }
      uint64_t v26 = (unint64_t *)(*((void *)&v153 + 1) + 8 * ((unint64_t)v155 / 0xAA));
      unint64_t v27 = *v26;
      unint64_t v28 = *v26 + 24 * ((unint64_t)v155 % 0xAA);
      unint64_t v29 = *(void *)(*((void *)&v153 + 1) + 8 * ((*((void *)&v155 + 1) + (void)v155) / 0xAAuLL))
          + 24 * ((*((void *)&v155 + 1) + (void)v155) % 0xAAuLL);
      if (v28 == v29) {
        goto LABEL_35;
      }
      unint64_t v30 = 0;
      do
      {
        if (*(_DWORD *)(v28 + 16)) {
          ++v30;
        }
        v28 += 24LL;
        if (v28 - v27 == 4080)
        {
          int64x2_t v31 = v26[1];
          ++v26;
          unint64_t v27 = v31;
          unint64_t v28 = v31;
        }
      }

      while (v28 != v29);
      if (!v30)
      {
LABEL_35:
        unsigned int v32 = atomic_load((unsigned __int8 *)v140 + 2760);
        if ((v32 & 1) != 0)
        {
          dispatch_semaphore_wait(*(dispatch_semaphore_t *)v136, 0xFFFFFFFFFFFFFFFFLL);
          unint64_t v33 = (_OWORD *)(v14 + 120LL * a3);
          *(_OWORD *)v149 = v33[3];
          v33[3] = 0u;
          *(_OWORD *)&v149[16] = v33[4];
          v33[4] = 0u;
          v150 = v33[5];
          v33[5] = 0u;
          dispatch_semaphore_signal(*(dispatch_semaphore_t *)v136);
          if (*((void *)&v150 + 1))
          {
            int32x2_t v35 = *(unsigned __int8 **)v34;
            uint64_t v36 = *(void *)(v34 + 8);
            unint64_t v37 = *(unsigned int *)(v34 + 16);
            int64x2_t v38 = objc_autoreleasePoolPush();
            int64x2_t v39 = (void *)objc_claimAutoreleasedReturnValue( +[NSMutableData dataWithBytes:length:]( &OBJC_CLASS___NSMutableData,  "dataWithBytes:length:",  v36,  v37));
            objc_autoreleasePoolPop(v38);
            GTMMappedBuffer::Deallocate((uint64_t)v136, v35);
            unint64_t v148 = 0LL;
            unint64_t v40 = v39;
            unint64_t v41 = [v40 bytes];
            uint64_t v42 = [v40 length];
            unint64_t v43 = atomic_load((unsigned __int8 *)v140 + 2760);
            GTMMappedBuffer::PostProcessRawDataFromSource( &v145,  v133,  v138,  (uint64_t)v41,  (uint64_t)v42,  &v148,  a3,  v43 & 1);
            uint64_t v44 = v146;
            if (v146 && v44 <= (unint64_t)[v40 length])
            {
              unint64_t v45 = v40;
              GTMMappedBuffer::MemcpyFromSourceBuffer( (dispatch_semaphore_t *)v136,  (unsigned __int8 *)[v45 length] + (void)objc_msgSend(v45, "bytes") - v44,  v44,  0,  0);
            }

            uint64_t v46 = v148;
            uint64_t v47 = v145;
            if (v148 && v145)
            {
              uint64_t v48 = (void *)v151.i64[1];
              if (v151.i64[1] >= v152[0])
              {
                id v50 = 0xAAAAAAAAAAAAAAABLL * ((v151.i64[1] - v151.i64[0]) >> 3);
                unint64_t v51 = v50 + 1;
                if (v50 + 1 > 0xAAAAAAAAAAAAAAALL) {
                  abort();
                }
                if (0x5555555555555556LL * ((v152[0] - v151.i64[0]) >> 3) > v51) {
                  unint64_t v51 = 0x5555555555555556LL * ((v152[0] - v151.i64[0]) >> 3);
                }
                if (0xAAAAAAAAAAAAAAABLL * ((v152[0] - v151.i64[0]) >> 3) >= 0x555555555555555LL) {
                  uint64_t v52 = 0xAAAAAAAAAAAAAAALL;
                }
                else {
                  uint64_t v52 = v51;
                }
                v159 = v152;
                if (v52) {
                  uint64_t v52 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<std::vector<NSObject  {objcproto21OS_dispatch_semaphore}* {__strong}>>>(v52);
                }
                else {
                  id v53 = 0LL;
                }
                uint64_t v54 = (void *)(v52 + 24 * v50);
                dispatch_semaphore_t v156 = v52;
                v157.i64[0] = (uint64_t)v54;
                unint64_t v158 = v52 + 24 * v53;
                *uint64_t v54 = v46;
                v54[1] = v47;
                v54[2] = v147;
                uint64_t v49 = v54 + 3;
                v157.i64[1] = (uint64_t)(v54 + 3);
                id v55 = v151.i64[1];
                uint64_t v56 = v151.i64[0];
                if (v151.i64[1] == v151.i64[0])
                {
                  int v59 = vdupq_n_s64(v151.u64[1]);
                }

                else
                {
                  do
                  {
                    unint64_t v57 = *(_OWORD *)(v55 - 24);
                    v55 -= 24LL;
                    *(_OWORD *)(v54 - 3) = v57;
                    v54 -= 3;
                    dispatch_semaphore_t v58 = *(void *)(v55 + 16);
                    *(void *)(v55 + 16) = 0LL;
                    v54[2] = v58;
                  }

                  while (v55 != v56);
                  int v59 = v151;
                  uint64_t v49 = (void *)v157.i64[1];
                  uint64_t v47 = v145;
                }

                v151.i64[0] = (uint64_t)v54;
                v151.i64[1] = (uint64_t)v49;
                v157 = v59;
                uint64_t v60 = v152[0];
                v152[0] = v158;
                unint64_t v158 = v60;
                dispatch_semaphore_t v156 = v59.i64[0];
                std::__split_buffer<std::tuple<unsigned char *,unsigned long long,NSMutableData * {__strong}>>::~__split_buffer((uint64_t)&v156);
              }

              else
              {
                *(void *)v151.i64[1] = v148;
                v48[1] = v47;
                v48[2] = v147;
                uint64_t v49 = v48 + 3;
              }

              v151.i64[1] = (uint64_t)v49;
            }

            do
              uint64_t v61 = __ldaxr(v8);
            while (__stlxr(v61 + v47, v8));
          }

          std::deque<GTMMappedBuffer::UsedBlock>::~deque[abi:nn180100](v149);
        }

        unint64_t v30 = 0;
      }

      unint64_t v132 = v30;
      if ((void)v154 != *((void *)&v153 + 1))
      {
        unint64_t v62 = (void *)(*((void *)&v153 + 1) + 8 * ((unint64_t)v155 / 0xAA));
        id v63 = *v62 + 24 * ((unint64_t)v155 % 0xAA);
        uint64_t v134 = *(void *)(*((void *)&v153 + 1) + 8 * ((*((void *)&v155 + 1) + (void)v155) / 0xAAuLL))
             + 24 * ((*((void *)&v155 + 1) + (void)v155) % 0xAAuLL);
        if (v63 != v134)
        {
          uint64_t v64 = 0;
          unint64_t v65 = (_OWORD *)(v14 + 120LL * a3);
          unint64_t v130 = v65 + 4;
          unint64_t v131 = v65 + 3;
          uint64_t v129 = v65 + 5;
          do
          {
            unint64_t v145 = 0LL;
            if (*(_DWORD *)(v63 + 16))
            {
              dispatch_semaphore_wait(*(dispatch_semaphore_t *)v136, 0xFFFFFFFFFFFFFFFFLL);
              *(_OWORD *)v149 = *v131;
              *unint64_t v131 = 0u;
              *(_OWORD *)&v149[16] = *v130;
              void *v130 = 0u;
              v150 = *v129;
              CFStringRef v129 = 0u;
              dispatch_semaphore_signal(*(dispatch_semaphore_t *)v136);
              if (*((void *)&v150 + 1))
              {
                uint64_t v68 = *(unsigned __int8 **)v66;
                uint64_t v67 = *(const void **)(v66 + 8);
                uint64_t v69 = *(unsigned int *)(v66 + 16);
                if (v69 > 0x8000)
                {
                  unsigned int v76 = objc_autoreleasePoolPush();
                  unsigned int v77 = (void *)objc_claimAutoreleasedReturnValue( +[NSMutableData dataWithCapacity:]( &OBJC_CLASS___NSMutableData,  "dataWithCapacity:",  (*(_DWORD *)(v63 + 16) + v69)));
                  [v77 appendBytes:v67 length:v69];
                  [v77 appendBytes:*(void *)(v63 + 8) length:*(unsigned int *)(v63 + 16)];
                  char v71 = v77;
                  uint64_t v70 = [v71 bytes];
                  int64x2_t v72 = [v71 length];
                  objc_autoreleasePoolPop(v76);
                }

                else
                {
                  uint64_t v70 = (id)(*(void *)v63 - v69 + 0x8000);
                  memcpy(v70, v67, v69);
                  char v71 = 0LL;
                  int64x2_t v72 = *(_DWORD *)(v63 + 16) + v69;
                }

                GTMMappedBuffer::Deallocate((uint64_t)v136, v68);
              }

              else
              {
                char v71 = 0LL;
                uint64_t v70 = *(id *)(v63 + 8);
                int64x2_t v72 = *(_DWORD *)(v63 + 16);
              }

              GTMMappedBuffer::PostProcessRawDataFromSource( &v156,  v133,  v138,  (uint64_t)v70,  v72,  &v145,  a3,  ++v64 == v132);
              unsigned int v74 = v156;
              if (v157.i64[0])
              {
                uint64_t v78 = *(unsigned int *)(v63 + 16);
                unint64_t v79 = v78 >= v157.i64[0];
                unint64_t v80 = v78 - v157.i64[0];
                if (v79) {
                  GTMMappedBuffer::MemcpyFromSourceBuffer( (dispatch_semaphore_t *)v136,  (unsigned __int8 *)(*(void *)(v63 + 8) + v80),  v157.u32[0],  0LL,  0);
                }
              }

              do
                unint64_t v81 = __ldaxr(v8);
              while (__stlxr(v81 + v74, v8));
              unsigned int v75 = (id)v157.i64[1];

              std::deque<GTMMappedBuffer::UsedBlock>::~deque[abi:nn180100](v149);
              uint64_t v73 = v145;
            }

            else
            {
              uint64_t v73 = 0LL;
              unsigned int v74 = 0LL;
              unsigned int v75 = 0LL;
            }

            GTMMappedBuffer::Deallocate((uint64_t)v135, *(unsigned __int8 **)v63);
            if (v73 && v74)
            {
              uint64_t v82 = (void *)v151.i64[1];
              if (v151.i64[1] >= v152[0])
              {
                unint64_t v84 = 0xAAAAAAAAAAAAAAABLL * ((v151.i64[1] - v151.i64[0]) >> 3);
                unint64_t v85 = v84 + 1;
                if (v84 + 1 > 0xAAAAAAAAAAAAAAALL) {
                  abort();
                }
                if (0x5555555555555556LL * ((v152[0] - v151.i64[0]) >> 3) > v85) {
                  unint64_t v85 = 0x5555555555555556LL * ((v152[0] - v151.i64[0]) >> 3);
                }
                if (0xAAAAAAAAAAAAAAABLL * ((v152[0] - v151.i64[0]) >> 3) >= 0x555555555555555LL) {
                  uint64_t v86 = 0xAAAAAAAAAAAAAAALL;
                }
                else {
                  uint64_t v86 = v85;
                }
                *(void *)&v150 = v152;
                if (v86) {
                  uint64_t v86 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<std::vector<NSObject  {objcproto21OS_dispatch_semaphore}* {__strong}>>>(v86);
                }
                else {
                  unint64_t v87 = 0LL;
                }
                unint64_t v88 = (void *)(v86 + 24 * v84);
                *(void *)v149 = v86;
                *(void *)&v149[8] = v88;
                *(void *)&v149[24] = v86 + 24 * v87;
                *unint64_t v88 = v73;
                v88[1] = v74;
                v88[2] = v75;
                unint64_t v83 = v88 + 3;
                *(void *)&v149[16] = v88 + 3;
                unint64_t v89 = v151.i64[1];
                unint64_t v90 = v151.i64[0];
                if (v151.i64[1] == v151.i64[0])
                {
                  unint64_t v93 = vdupq_n_s64(v151.u64[1]);
                }

                else
                {
                  do
                  {
                    uint64_t v91 = *(_OWORD *)(v89 - 24);
                    v89 -= 24LL;
                    *(_OWORD *)(v88 - 3) = v91;
                    v88 -= 3;
                    uint64_t v92 = *(void *)(v89 + 16);
                    *(void *)(v89 + 16) = 0LL;
                    v88[2] = v92;
                  }

                  while (v89 != v90);
                  unint64_t v93 = v151;
                  unint64_t v83 = *(void **)&v149[16];
                }

                v151.i64[0] = (uint64_t)v88;
                v151.i64[1] = (uint64_t)v83;
                *(int64x2_t *)&v149[8] = v93;
                unint64_t v94 = v152[0];
                v152[0] = *(void *)&v149[24];
                *(void *)&v149[24] = v94;
                *(void *)v149 = v93.i64[0];
                std::__split_buffer<std::tuple<unsigned char *,unsigned long long,NSMutableData * {__strong}>>::~__split_buffer((uint64_t)v149);
              }

              else
              {
                *(void *)v151.i64[1] = v73;
                v82[1] = v74;
                v82[2] = v75;
                unint64_t v83 = v82 + 3;
              }

              v151.i64[1] = (uint64_t)v83;
            }

            v63 += 24LL;
            if (v63 - *v62 == 4080)
            {
              unint64_t v95 = v62[1];
              ++v62;
              id v63 = v95;
            }
          }

          while (v63 != v134);
        }
      }

      dispatch_semaphore_signal(*(dispatch_semaphore_t *)(*((void *)v140 + 309) + 8LL * a2));
      uint64_t v97 = v151.i64[1];
      for (uint64_t i = v151.i64[0]; i != v97; i += 24LL)
      {
        uint64_t v98 = objc_autoreleasePoolPush();
        unint64_t v99 = *(id *)(i + 16);
        unint64_t v100 = v99;
        if (v99)
        {
          unint64_t v104 = (NSData *)v99;
        }

        else
        {
          unint64_t v101 = objc_alloc(&OBJC_CLASS___NSData);
          uint64_t v102 = *(void *)i;
          unint64_t v103 = *(void *)(i + 8);
          v142[0] = _NSConcreteStackBlock;
          v142[1] = 3221225472LL;
          v142[2] = ___ZN35GTUSCSamplingStreamingManagerHelper18PostProcessRawDataEjj_block_invoke;
          v142[3] = &__block_descriptor_48_e12_v24__0_v8Q16l;
          v142[4] = v140;
          uint64_t v143 = a2;
          uint64_t v144 = a3;
          unint64_t v104 = -[NSData initWithBytesNoCopy:length:deallocator:]( v101,  "initWithBytesNoCopy:length:deallocator:",  v102,  v103,  v142);
        }

        unint64_t v105 = v104;
        v163[0] = v104;
        v162[0] = @"ShaderProfilerData";
        v162[1] = @"Source";
        unint64_t v106 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v138, "name", v125));
        v163[1] = v106;
        v162[2] = @"SourceIndex";
        uint64_t v107 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInt:](&OBJC_CLASS___NSNumber, "numberWithUnsignedInt:", a2));
        v163[2] = v107;
        v162[3] = @"RingBufferIndex";
        uint64_t v108 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInt:](&OBJC_CLASS___NSNumber, "numberWithUnsignedInt:", a3));
        v163[3] = v108;
        unint64_t v109 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v163,  v162,  4LL));

        (*(void (**)(void))(*(void *)(*(void *)v140 + 32LL) + 16LL))();
        objc_autoreleasePoolPop(v98);
      }

      unint64_t v110 = DWORD2(v155);
      if (*((void *)&v155 + 1))
      {
        do
          unint64_t v111 = __ldaxr(v127);
        while (__stlxr(v111 + v110, v127));
      }

      uint64_t v112 = v140;
      unint64_t v113 = atomic_load((unsigned __int8 *)v140 + 2760);
      if ((v113 & 1) != 0)
      {
        unint64_t v114 = atomic_load((unsigned int *)v140 + 687);
        if (v114 == *((_DWORD *)v140 + 541))
        {
          unint64_t v115 = atomic_load((unsigned int *)v140 + 685);
          unint64_t v116 = atomic_load((unsigned int *)v140 + 686);
          if (v115 == v116)
          {
            uint64_t v160 = @"Post Processing Frame Marker";
            uint64_t v117 = atomic_load((unsigned int *)v140 + 689);
            uint64_t v118 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInt:](&OBJC_CLASS___NSNumber, "numberWithUnsignedInt:", v117));
            uint64_t v161 = v118;
            unint64_t v119 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v161,  &v160,  1LL));

            (*(void (**)(void))(*(void *)(*(void *)v140 + 32LL) + 16LL))();
            unint64_t v120 = atomic_load((unsigned __int8 *)v140 + 2761);
            if ((v120 & 1) != 0) {
              std::condition_variable::notify_all(v125);
            }
            std::condition_variable::notify_all(v126);

            uint64_t v112 = v140;
          }
        }
      }

      *(void *)v149 = &v151;
      std::vector<std::tuple<unsigned char *,unsigned long long,NSMutableData * {__strong}>>::__destroy_vector::operator()[abi:nn180100]((void ***)v149);
      std::deque<GTMMappedBuffer::UsedBlock>::~deque[abi:nn180100](&v153);
      uint64_t v121 = atomic_load((unsigned __int8 *)v112 + 2763);
    }

    while ((v121 & 1) == 0);
  }

  do
  {
    unint64_t v122 = v137;
    unint64_t v123 = __ldaxr(v137);
  }

  while (__stlxr(v123 - 1, v122));
  if (!atomic_load(v137)) {
    std::condition_variable::notify_all((std::condition_variable *)((char *)v140 + 2992));
  }
}

  uint64_t v20 = 0LL;
LABEL_13:
  uint64_t v26 = (void *)objc_opt_new(&OBJC_CLASS___GTReplayResponse, v19);
  objc_msgSend(v26, "setRequestID:", objc_msgSend(*(id *)(a1 + 32), "requestID"));
  if (UpdateLibraryResource(*(id **)(*(void *)(a1 + 64) + 8LL), v18, v5, v20))
  {
    int64x2_t v31 = v5;
    unint64_t v27 = (void *)objc_claimAutoreleasedReturnValue( -[NSMutableDictionary objectForKeyedSubscript:]( v5,  "objectForKeyedSubscript:",  @"updatedPipelines"));
    unint64_t v28 = [v27 copy];
    unsigned int v32 = 0LL;
    unint64_t v29 = (void *)objc_claimAutoreleasedReturnValue( +[NSKeyedArchiver archivedDataWithRootObject:requiringSecureCoding:error:]( &OBJC_CLASS___NSKeyedArchiver,  "archivedDataWithRootObject:requiringSecureCoding:error:",  v28,  1LL,  &v32));
    unint64_t v30 = v32;
    [v26 setData:v29];

    int v5 = v31;
  }

  else
  {
    unint64_t v30 = (id)objc_claimAutoreleasedReturnValue(-[NSMutableDictionary objectForKeyedSubscript:](v5, "objectForKeyedSubscript:", @"error"));
  }

  [v26 setError:v30];

  [*(id *)(a1 + 40) setObject:v26 atIndexedSubscript:*(int *)(a1 + 72)];
LABEL_17:
}

  if (*(_BYTE *)(a2 + 21))
  {
    *(void *)(result + 88) = v11;
    v11 += 8LL;
  }

  BOOL v14 = (v12 << 63 >> 63) & 0x28;
  if ((v12 & 2) != 0) {
    BOOL v14 = 56LL;
  }
  int v15 = 72LL;
  if ((v12 & 4) != 0) {
    BOOL v14 = 72LL;
  }
  if ((v12 & 8) != 0) {
    BOOL v14 = 80LL;
  }
  if ((v12 & 0x60) != 0) {
    BOOL v14 = 120LL;
  }
  if (v14 <= 0x48) {
    id v16 = 72LL;
  }
  else {
    id v16 = v14;
  }
  if ((v12 & 0x80) != 0) {
    BOOL v14 = v16;
  }
  if (v14 > 0x48) {
    int v15 = v14;
  }
  if ((v12 & 0x100) != 0) {
    BOOL v14 = v15;
  }
  *(void *)(result + 96) = v11;
  *(void *)(result + 104) = v11 + v14;
  return result;
}

    unint64_t v105 = v8;
    uint64_t v73 = v6;
    uint64_t v78 = (void *)objc_claimAutoreleasedReturnValue([v73 objectForKeyedSubscript:@"MetalPluginName"]);
    if (!v78)
    {
      IOAccelerator = GetIOAccelerator();
      MetalPluginName = GetMetalPluginName(IOAccelerator, &v105);
      uint64_t v78 = (void *)objc_claimAutoreleasedReturnValue(MetalPluginName);
    }

    BOOL v14 = objc_alloc(&OBJC_CLASS___NSMutableDictionary);
    dispatch_semaphore_t v136 = @"MetalPluginName";
    dispatch_semaphore_t v137 = v78;
    int v15 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v137,  &v136,  1LL));
    uint64_t v9 = -[NSMutableDictionary initWithDictionary:](v14, "initWithDictionary:", v15);

    char v71 = v9;
    unint64_t v84 = objc_alloc_init(&OBJC_CLASS___NSOperation);
    unint64_t v99 = 0LL;
    unint64_t v100 = &v99;
    unint64_t v101 = 0x3032000000LL;
    uint64_t v102 = __Block_byref_object_copy__53;
    unint64_t v103 = __Block_byref_object_dispose__54;
    unint64_t v104 = 0LL;
    v98[0] = _NSConcreteStackBlock;
    v98[1] = 3221225472LL;
    v98[2] = ___ZL29EmbeddedQueryShaderInfoLegacyP21GTMTLReplayControllerP26GTMTLReplayOperationQueuesP12NSDictionaryi_block_invoke;
    v98[3] = &unk_58F698;
    v98[4] = &v99;
    void v98[5] = a1;
    id v16 = (void *)objc_claimAutoreleasedReturnValue( +[NSBlockOperation blockOperationWithBlock:]( &OBJC_CLASS___NSBlockOperation,  "blockOperationWithBlock:",  v98));
    [v16 setQueuePriority:-8];
    [*a2 addOperation:v16];
    -[NSOperation addDependency:](v84, "addDependency:", v16);

    uint64_t v92 = 0LL;
    unint64_t v93 = &v92;
    unint64_t v94 = 0x3032000000LL;
    unint64_t v95 = __Block_byref_object_copy__53;
    unint64_t v96 = __Block_byref_object_dispose__54;
    uint64_t v97 = 0LL;
    v88[0] = _NSConcreteStackBlock;
    v88[1] = 3221225472LL;
    v88[2] = ___ZL29EmbeddedQueryShaderInfoLegacyP21GTMTLReplayControllerP26GTMTLReplayOperationQueuesP12NSDictionaryi_block_invoke_2;
    v88[3] = &unk_58F838;
    unint64_t v90 = &v92;
    uint64_t v91 = a1;
    unsigned int v77 = (NSDictionary *)v73;
    unint64_t v89 = v77;
    uint64_t v17 = (void *)objc_claimAutoreleasedReturnValue( +[NSBlockOperation blockOperationWithBlock:]( &OBJC_CLASS___NSBlockOperation,  "blockOperationWithBlock:",  v88));
    [v17 setQueuePriority:-8];
    [*a2 addOperation:v17];
    -[NSOperation addDependency:](v84, "addDependency:", v17);
    [v17 waitUntilFinished];

    *(void *)unint64_t v87 = 0LL;
    uint64_t v86 = 0;
    unint64_t v85 = 1.0;
    GetConsistentPStates(v77, &v87[1], v87, &v85, &v86);
    uint64_t v18 = (void *)objc_claimAutoreleasedReturnValue([a1->var1 defaultDevice]);
    Analysis = DYMTLReplayFrameProfiler_loadAnalysis(v18);
    unint64_t v81 = (void *)objc_claimAutoreleasedReturnValue(Analysis);

    if (v81)
    {
      uint64_t v20 = (void *)objc_claimAutoreleasedReturnValue([v81 objectForKeyedSubscript:@"DerivedCounterDictionary"]);
      id v21 = v20;
      if (v20)
      {
        uint64_t v22 = (void *)objc_claimAutoreleasedReturnValue([v20 objectForKeyedSubscript:@"DerivedCounters"]);
        id v23 = v22;
        if (v22)
        {
          id v24 = objc_claimAutoreleasedReturnValue([v22 objectForKeyedSubscript:@"ParameterBufferBytesUsed"]);
          id v25 = (void *)v24;
          if (v24)
          {
            uint64_t v134 = @"ParameterBufferBytesUsed";
            uint64_t v135 = v24;
            uint64_t v26 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v135,  &v134,  1LL));
            unint64_t v27 = GTMTLReplayHost_rawCounters(v26);
            unsigned int v74 = (void *)objc_claimAutoreleasedReturnValue(v27);
          }

          else
          {
            unsigned int v74 = 0LL;
          }
        }

        else
        {
          unsigned int v74 = 0LL;
        }
      }

      else
      {
        unsigned int v74 = 0LL;
      }
    }

    else
    {
      unsigned int v74 = 0LL;
    }

    unint64_t v28 = (id *)operator new(0x18uLL);
    void *v28 = 0LL;
    v28[1] = 0LL;
    v28[2] = 0LL;
    unsigned int v76 = v28;
    unint64_t v29 = (void *)objc_claimAutoreleasedReturnValue([a1->var1 defaultDevice]);
    GTAGXPerfStateControl::InitWithDevice((uint64_t)v28, v29);

    unint64_t v79 = (void *)objc_opt_new(&OBJC_CLASS___NSMutableDictionary, v30);
    unint64_t v80 = (void *)objc_opt_new(&OBJC_CLASS___NSMutableDictionary, v31);
    unint64_t v83 = -[NSMutableArray initWithObjects:]( objc_alloc(&OBJC_CLASS___NSMutableArray),  "initWithObjects:",  &off_5A06E8,  0LL);
    if (v105 > -2)
    {
      unint64_t v34 = v86;
      int32x2_t v35 = v87[0];
      uint64_t v66 = v79;
      uint64_t v64 = v80;
      uint64_t v68 = v83;
      uint64_t v67 = v74;
      unsigned int v75 = objc_alloc_init(&OBJC_CLASS___NSOperation);
      GRCInfo::GRCInfo((GRCInfo *)v106, a1, v34, (GTAGXPerfStateControl *)v28);
      DisableComputeEncoderCoalescing((uint64_t)a1, 1LL);
      uint64_t v36 = v68;
      unint64_t v148 = 0LL;
      v149 = &v148;
      v150 = 0x4812000000LL;
      v151 = __Block_byref_object_copy__94;
      v152 = __Block_byref_object_dispose__95;
      *(void *)&v153 = "";
      *((void *)&v153 + 1) = 0LL;
      uint64_t v154 = 0uLL;
      std::vector<std::tuple<unsigned long long,unsigned long long,unsigned long long>>::reserve( (void **)&v153 + 1,  0x80uLL);
      unint64_t v119 = _NSConcreteStackBlock;
      unint64_t v120 = 3221225472LL;
      uint64_t v121 = (uint64_t)___ZL14GPUTimeDataGRCP26GTMTLReplayOperationQueuesP14NSMutableArrayIP8NSNumberEjR7GRCInfo_block_invoke;
      unint64_t v122 = (__n128 (*)(__n128 *, __n128 *))&unk_58EF30;
      unint64_t v124 = (const char *)&v148;
      uint64_t v70 = v36;
      unint64_t v123 = v70;
      unint64_t v37 = (void *)objc_claimAutoreleasedReturnValue( +[NSBlockOperation blockOperationWithBlock:]( &OBJC_CLASS___NSBlockOperation,  "blockOperationWithBlock:",  &v119));
      v138 = (const __CFString *)_NSConcreteStackBlock;
      unint64_t v139 = 3221225472LL;
      v140 = (uint64_t)___ZL14GPUTimeDataGRCP26GTMTLReplayOperationQueuesP14NSMutableArrayIP8NSNumberEjR7GRCInfo_block_invoke_2;
      uint64_t v141 = (__n128 (*)(__n128 *, __n128 *))&unk_58DFB8;
      LODWORD(v144) = v35;
      uint64_t v143 = (char *)v106;
      uint64_t v142 = (void (*)(uint64_t))&v148;
      int64x2_t v38 = (void *)objc_claimAutoreleasedReturnValue( +[NSBlockOperation blockOperationWithBlock:]( &OBJC_CLASS___NSBlockOperation,  "blockOperationWithBlock:",  &v138));
      [v38 setQueuePriority:-8];
      [*a2 addOperation:v38];
      [v37 addDependency:v38];
      [a2[1] addOperation:v37];

      _Block_object_dispose(&v148, 8);
      if (*((void *)&v153 + 1))
      {
        *(void *)&uint64_t v154 = *((void *)&v153 + 1);
        operator delete(*((void **)&v153 + 1));
      }

      -[NSOperation addDependency:](v75, "addDependency:", v37);
      unint64_t v65 = v66;
      int64x2_t v39 = v67;
      unint64_t v148 = 0LL;
      v149 = &v148;
      v150 = 0x5812000000LL;
      v151 = __Block_byref_object_copy__171;
      v152 = __Block_byref_object_dispose__172;
      v153 = 0u;
      uint64_t v154 = 0u;
      dispatch_semaphore_t v155 = 0LL;
      dispatch_semaphore_t v156 = 1065353216;
      unint64_t v128 = 0LL;
      uint64_t v129 = &v128;
      unint64_t v130 = 0x3032000000LL;
      unint64_t v131 = __Block_byref_object_copy__53;
      unint64_t v132 = __Block_byref_object_dispose__54;
      unint64_t v133 = (id)objc_opt_new(&OBJC_CLASS___NSMutableArray, v40);
      if ([v39 count])
      {
        unint64_t v41 = (void *)objc_claimAutoreleasedReturnValue([v39 firstObject]);
        uint64_t v42 = (void *)objc_claimAutoreleasedReturnValue( +[GPURawCounterSelect selectWithName:options:]( &OBJC_CLASS___GPURawCounterSelect,  "selectWithName:options:",  v41,  0LL));
        id v63 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableArray arrayWithObject:](&OBJC_CLASS___NSMutableArray, "arrayWithObject:", v42));
      }

      else
      {
        id v63 = 0LL;
      }

      unint64_t v119 = 0LL;
      unint64_t v120 = (uint64_t)&v119;
      uint64_t v121 = 0x4812000000LL;
      unint64_t v122 = __Block_byref_object_copy__173;
      unint64_t v123 = __Block_byref_object_dispose__174;
      unint64_t v124 = "";
      __p = 0LL;
      unint64_t v127 = 0LL;
      uint64_t v126 = 0LL;
      v138 = (const __CFString *)_NSConcreteStackBlock;
      unint64_t v139 = 3221225472LL;
      v140 = (uint64_t)___ZL15KickTimeDataGRCP26GTMTLReplayOperationQueuesP19NSMutableDictionaryjR7GRCInfoP7NSArray_block_invoke;
      uint64_t v141 = (__n128 (*)(__n128 *, __n128 *))&unk_58DFE0;
      uint64_t v144 = &v128;
      unint64_t v145 = &v119;
      uint64_t v146 = &v148;
      v147 = v106;
      uint64_t v69 = (void (*)(uint64_t))v39;
      uint64_t v142 = v69;
      int64x2_t v72 = (char *)v65;
      uint64_t v143 = v72;
      unint64_t v43 = (void *)objc_claimAutoreleasedReturnValue( +[NSBlockOperation blockOperationWithBlock:]( &OBJC_CLASS___NSBlockOperation,  "blockOperationWithBlock:",  &v138));
      unint64_t v110 = _NSConcreteStackBlock;
      unint64_t v111 = 3221225472LL;
      uint64_t v112 = ___ZL15KickTimeDataGRCP26GTMTLReplayOperationQueuesP19NSMutableDictionaryjR7GRCInfoP7NSArray_block_invoke_2;
      unint64_t v113 = &unk_58E008;
      uint64_t v117 = v106;
      uint64_t v118 = v35;
      uint64_t v44 = v63;
      unint64_t v114 = (void **)v44;
      unint64_t v115 = &v148;
      unint64_t v116 = (id *)&v128;
      unint64_t v45 = (void *)objc_claimAutoreleasedReturnValue( +[NSBlockOperation blockOperationWithBlock:]( &OBJC_CLASS___NSBlockOperation,  "blockOperationWithBlock:",  &v110));
      [v45 setQueuePriority:-8];
      [*a2 addOperation:v45];
      [v43 addDependency:v45];
      [a2[1] addOperation:v43];

      _Block_object_dispose(&v119, 8);
      if (__p)
      {
        uint64_t v126 = (void **)__p;
        operator delete(__p);
      }

      _Block_object_dispose(&v128, 8);
      _Block_object_dispose(&v148, 8);
      std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long>>>::~__hash_table((uint64_t)&v153 + 8);

      -[NSOperation addDependency:](v75, "addDependency:", v43);
      uint64_t v46 = v64;
      unint64_t v148 = 0LL;
      v149 = &v148;
      v150 = 0x5812000000LL;
      v151 = __Block_byref_object_copy__176;
      v152 = __Block_byref_object_dispose__177;
      v153 = 0u;
      uint64_t v154 = 0u;
      dispatch_semaphore_t v155 = 0LL;
      dispatch_semaphore_t v156 = 1065353216;
      unint64_t v128 = 0LL;
      uint64_t v129 = &v128;
      unint64_t v130 = 0x3032000000LL;
      unint64_t v131 = __Block_byref_object_copy__53;
      unint64_t v132 = __Block_byref_object_dispose__54;
      unint64_t v133 = (id)objc_opt_new(&OBJC_CLASS___NSMutableArray, v47);
      v138 = 0LL;
      unint64_t v139 = (uint64_t)&v138;
      v140 = 0x4812000000LL;
      uint64_t v141 = __Block_byref_object_copy__178;
      uint64_t v142 = __Block_byref_object_dispose__179;
      uint64_t v143 = "";
      uint64_t v144 = 0LL;
      uint64_t v146 = 0LL;
      unint64_t v145 = 0LL;
      unint64_t v119 = _NSConcreteStackBlock;
      unint64_t v120 = 3221225472LL;
      uint64_t v121 = (uint64_t)___ZL20BlitSplitTimeDataGRCP26GTMTLReplayOperationQueuesP19NSMutableDictionaryjR7GRCInfo_block_invoke;
      unint64_t v122 = (__n128 (*)(__n128 *, __n128 *))&unk_58E030;
      unint64_t v124 = (const char *)&v128;
      __p = &v138;
      uint64_t v126 = &v148;
      unint64_t v127 = v106;
      uint64_t v48 = (void (*)(uint64_t))v46;
      unint64_t v123 = v48;
      uint64_t v49 = (void *)objc_claimAutoreleasedReturnValue( +[NSBlockOperation blockOperationWithBlock:]( &OBJC_CLASS___NSBlockOperation,  "blockOperationWithBlock:",  &v119));
      unint64_t v110 = _NSConcreteStackBlock;
      unint64_t v111 = 3221225472LL;
      uint64_t v112 = ___ZL20BlitSplitTimeDataGRCP26GTMTLReplayOperationQueuesP19NSMutableDictionaryjR7GRCInfo_block_invoke_2;
      unint64_t v113 = &unk_58E058;
      unint64_t v116 = v106;
      LODWORD(v117) = v35;
      unint64_t v114 = &v148;
      unint64_t v115 = (void **)&v128;
      id v50 = (void *)objc_claimAutoreleasedReturnValue( +[NSBlockOperation blockOperationWithBlock:]( &OBJC_CLASS___NSBlockOperation,  "blockOperationWithBlock:",  &v110));
      uint64_t v9 = v71;
      [v50 setQueuePriority:-8];
      [*a2 addOperation:v50];
      [v49 addDependency:v50];
      [a2[1] addOperation:v49];

      _Block_object_dispose(&v138, 8);
      if (v144)
      {
        unint64_t v145 = (void ***)v144;
        operator delete(v144);
      }

      _Block_object_dispose(&v128, 8);

      _Block_object_dispose(&v148, 8);
      std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long>>>::~__hash_table((uint64_t)&v153 + 8);

      -[NSOperation addDependency:](v75, "addDependency:", v49);
      [a2[1] addOperation:v75];
      -[NSOperation waitUntilFinished](v75, "waitUntilFinished");
      DisableComputeEncoderCoalescing((uint64_t)a1, 0LL);
      if (v107)
      {
        v138 = @"enabled";
        unint64_t v51 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithBool:](&OBJC_CLASS___NSNumber, "numberWithBool:", v108));
        unint64_t v148 = v51;
        unint64_t v139 = (uint64_t)@"consistent";
        uint64_t v52 = (void **)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithBool:](&OBJC_CLASS___NSNumber, "numberWithBool:", v109));
        v140 = (uint64_t)@"level";
        v149 = v52;
        v150 = v107;
        id v53 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v148,  &v138,  3LL));
        [v72 setObject:v53 forKeyedSubscript:@"Frame Consistent Perf Info"];
      }

      else
      {
        [v72 setObject:&off_59FF70 forKeyedSubscript:@"Frame Consistent Perf Info"];
      }

      GRCInfo::~GRCInfo(v106);

      unint64_t v33 = v75;
      -[NSOperation addDependency:](v84, "addDependency:", v75);
    }

    else
    {
      unsigned int v32 = ProfilingTimingDataLegacy((uint64_t)a1, a2, v79, v80, v83, v87[1], v87[0], v86, (uint64_t)v28);
      unint64_t v33 = (NSOperation *)objc_claimAutoreleasedReturnValue(v32);
      -[NSOperation addDependency:](v84, "addDependency:", v33);
    }

    [a2[1] addOperation:v84];
    -[NSOperation waitUntilFinished](v84, "waitUntilFinished");
    uint64_t v54 = v85;
    id v55 = (void *)objc_claimAutoreleasedReturnValue(-[NSMutableArray objectAtIndexedSubscript:](v83, "objectAtIndexedSubscript:", 1LL));
    uint64_t v56 = [v55 unsignedLongLongValue];
    unint64_t v57 = (void *)objc_claimAutoreleasedReturnValue(-[NSMutableArray objectAtIndexedSubscript:](v83, "objectAtIndexedSubscript:", 0LL));
    dispatch_semaphore_t v58 = [v57 unsignedLongLongValue];

    -[NSMutableDictionary addEntriesFromDictionary:](v9, "addEntriesFromDictionary:", v100[5]);
    -[NSMutableDictionary addEntriesFromDictionary:](v9, "addEntriesFromDictionary:", v93[5]);
    -[NSMutableDictionary addEntriesFromDictionary:](v9, "addEntriesFromDictionary:", v79);
    -[NSMutableDictionary addEntriesFromDictionary:](v9, "addEntriesFromDictionary:", v80);
    int v59 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  (unint64_t)((1.0 - v54) * (double)(unint64_t)v58 + v54 * (double)(unint64_t)v56)));
    uint64_t v60 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObject:forKey:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObject:forKey:",  v59,  @"gputime"));
    -[NSMutableDictionary setObject:forKeyedSubscript:]( v9,  "setObject:forKeyedSubscript:",  v60,  @"consistent time");

    -[NSMutableDictionary setObject:forKeyedSubscript:]( v9,  "setObject:forKeyedSubscript:",  v81,  @"derivedCounterData");
    GTAGXPerfStateControl::~GTAGXPerfStateControl(v76);
    operator delete(v61);

    _Block_object_dispose(&v92, 8);
    _Block_object_dispose(&v99, 8);

    goto LABEL_42;
  }

  uint64_t v9 = 0LL;
LABEL_43:

  return v9;
}

    GTMTLReplayController_defaultDispatchFunction((uint64_t)a1, a2);
    goto LABEL_13;
  }

  if (v7 == -16285)
  {
    *a3 = 0;
    goto LABEL_12;
  }

  if (v7 != -16246 || !*a3) {
    goto LABEL_12;
  }
  objc_msgSend( v16,  "removeRenderCommandEncoderForKey:",  *(void *)GTTraceFunc_argumentBytesWithMap((void *)a2, *(unsigned __int8 *)(a2 + 13), *((void *)*a1 + 2)));
LABEL_13:
}

    vm_deallocate(mach_task_self_, address, vm_page_size + v5);
    if (++v3 == 5) {
      return 0LL;
    }
  }

  *(void *)this = address;
  *((void *)this + 1) = v4;
  *((void *)this + 2) = a3;
  return 1LL;
}

    ;
  }

  for (unsigned int j = *((void *)this + 43); j; unsigned int j = *((void *)this + 43))
  {
    int v19 = *(_DWORD *)(*(void *)(*((void *)this + 39) + ((*((void *)this + 42) >> 6) & 0x3FFFFFFFFFFFFF8LL))
                    + 8 * (*((void *)this + 42) & 0x1FFLL)
                    + 4);
    ++*((void *)this + 42);
    *((void *)this + 43) = j - 1;
    std::deque<ProfileEvent>::__maybe_remove_front_spare[abi:nn180100]((uint64_t)this + 304);
    std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__emplace_unique_key_args<unsigned int,unsigned int const&>( (uint64_t)this + 352,  v19,  v19);
  }

  *(_DWORD *)this = 0;
  uint64_t v20 = *((void *)this + 6);
  if (v20)
  {
    id v21 = 0LL;
    uint64_t v22 = 0;
    id v23 = 0;
    do
    {
      ++*(_DWORD *)this;
      id v24 = *((void *)this + 5);
      uint64_t v70 = *(void *)(*(void *)(*((void *)this + 2) + ((v24 >> 6) & 0x3FFFFFFFFFFFFF8LL)) + 8 * (v24 & 0x1FF));
      id v25 = v70;
      *((void *)this + 5) = v24 + 1;
      *((void *)this + 6) = v20 - 1;
      std::deque<ProfileEvent>::__maybe_remove_front_spare[abi:nn180100]((uint64_t)this + 8);
      if (v25 >> 28
        && !std::__hash_table<std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>>>::find<unsigned int>( (void *)this + 44,  *(_DWORD *)this))
      {
        unint64_t v27 = *((void *)this + 18);
        uint64_t v26 = v25 & 0xFFFFFFF;
        if (v27) {
          v22 += (v26 - v21) / v27;
        }
        uint64_t v69 = v25 & 0xFFFFFFF;
        *((_DWORD *)std::__hash_table<std::__hash_value_type<unsigned int,unsigned int>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,unsigned int>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>( (uint64_t)this + 392,  v25 & 0xFFFFFFF,  &v69)
        + 5) = v22;
        unint64_t v28 = v25 >> 28;
        if (v25 >> 28 <= 7)
        {
          if (((1 << v28) & 0xF6) != 0)
          {
            std::deque<ProfileEvent>::emplace_back<ProfileEvent&>((void *)this + 13, &v70);
          }

          else if (v28 == 3)
          {
            unint64_t v29 = *((void *)this + 18);
            if (v29)
            {
              unint64_t v30 = *(_DWORD *)(*(void *)(*((void *)this + 14)
                                          + ((*((void *)this + 17) >> 6) & 0x3FFFFFFFFFFFFF8LL))
                              + 8 * (*((void *)this + 17) & 0x1FFLL));
              ++*((void *)this + 17);
              *((void *)this + 18) = v29 - 1;
              std::deque<ProfileEvent>::__maybe_remove_front_spare[abi:nn180100]((uint64_t)this + 104);
              uint64_t v69 = v30 & 0xFFFFFFF;
              int64x2_t v31 = *((_DWORD *)std::__hash_table<std::__hash_value_type<unsigned int,unsigned int>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,unsigned int>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>( (uint64_t)this + 392,  v30 & 0xFFFFFFF,  &v69)
                    + 5);
              uint64_t v69 = v26;
              unsigned int v32 = std::__hash_table<std::__hash_value_type<unsigned int,unsigned int>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,unsigned int>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>( (uint64_t)this + 392,  v26,  &v69);
              unint64_t v33 = *((void *)this + 24);
              unint64_t v34 = (*((unsigned int *)this + 125) | (v33 << 36)) & 0x3000000FFFLL;
              uint64_t v68 = v23;
              if (v33 < 2 || (int32x2_t v35 = *((void *)this + 30), v35 < 2))
              {
                int64x2_t v39 = 0;
                uint64_t v36 = 0;
              }

              else
              {
                uint64_t v36 = 0;
                unint64_t v37 = *((void *)this + 23);
                int64x2_t v38 = *((void *)this + 20);
                unint64_t v40 = *((void *)this + 29);
                unint64_t v41 = *((void *)this + 26);
                v34 |= (unint64_t)(*(_DWORD *)(*(void *)(v41
                if (v33 >= 3 && v35 != 2)
                {
                  v34 |= (unint64_t)(*(_DWORD *)(*(void *)(v41
                }
              }

              uint64_t v42 = *((_DWORD *)v32 + 5) - v31;
              uint64_t v44 = *((_DWORD *)this + 62);
              unint64_t v43 = *((_DWORD *)this + 63);
              unint64_t v45 = *((_DWORD *)this + 124);
              if (v44 == -1) {
                uint64_t v46 = v30 >> 28 == 2;
              }
              else {
                uint64_t v46 = v36;
              }
              uint64_t v47 = *((void *)this + 33);
              uint64_t v48 = *((void *)this + 34);
              if (v47 >= v48)
              {
                id v50 = *((void *)this + 32);
                unint64_t v51 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v47 - v50) >> 3);
                uint64_t v52 = v51 + 1;
                if (v51 + 1 > 0x666666666666666LL) {
                  abort();
                }
                id v53 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v48 - v50) >> 3);
                if (2 * v53 > v52) {
                  uint64_t v52 = 2 * v53;
                }
                if (v53 >= 0x333333333333333LL) {
                  uint64_t v54 = 0x666666666666666LL;
                }
                else {
                  uint64_t v54 = v52;
                }
                if (v54)
                {
                  uint64_t v67 = v34;
                  id v55 = v39;
                  unint64_t v65 = *((_DWORD *)this + 124);
                  uint64_t v66 = v42;
                  id v63 = *((_DWORD *)this + 63);
                  uint64_t v64 = v46;
                  uint64_t v54 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<ShaderProfilerUSCSampleInfo>>(v54);
                  unint64_t v43 = v63;
                  uint64_t v46 = v64;
                  unint64_t v45 = v65;
                  uint64_t v42 = v66;
                  int64x2_t v39 = v55;
                  unint64_t v34 = v67;
                }

                else
                {
                  uint64_t v56 = 0LL;
                }

                unint64_t v57 = v54 + 40 * v51;
                *(_DWORD *)unint64_t v57 = v44;
                *(_DWORD *)(v57 + 4) = v43;
                *(_DWORD *)(v57 + 8) = v42;
                *(_DWORD *)(v57 + 12) = v45;
                *(_DWORD *)(v57 + 16) = v39;
                *(_DWORD *)(v57 + 20) = v46;
                *(void *)(v57 + 24) = v34;
                id v23 = v68;
                *(void *)(v57 + 32) = v68;
                int v59 = (char *)*((void *)this + 32);
                dispatch_semaphore_t v58 = (char *)*((void *)this + 33);
                uint64_t v60 = v57;
                if (v58 != v59)
                {
                  do
                  {
                    uint64_t v61 = *(_OWORD *)(v58 - 40);
                    unint64_t v62 = *(_OWORD *)(v58 - 24);
                    *(void *)(v60 - 8) = *((void *)v58 - 1);
                    *(_OWORD *)(v60 - 24) = v62;
                    *(_OWORD *)(v60 - 40) = v61;
                    v60 -= 40LL;
                    v58 -= 40;
                  }

                  while (v58 != v59);
                  dispatch_semaphore_t v58 = (char *)*((void *)this + 32);
                }

                uint64_t v49 = v57 + 40;
                *((void *)this + 32) = v60;
                *((void *)this + 33) = v57 + 40;
                *((void *)this + 34) = v54 + 40 * v56;
                if (v58) {
                  operator delete(v58);
                }
              }

              else
              {
                *(_DWORD *)uint64_t v47 = v44;
                *(_DWORD *)(v47 + 4) = v43;
                *(_DWORD *)(v47 + 8) = v42;
                *(_DWORD *)(v47 + 12) = v45;
                *(_DWORD *)(v47 + 16) = v39;
                *(_DWORD *)(v47 + 20) = v46;
                *(void *)(v47 + 24) = v34;
                uint64_t v49 = v47 + 40;
                *(void *)(v47 + 32) = v23;
              }

              ++v23;
              *((void *)this + 33) = v49;
            }
          }
        }
      }

      else
      {
        uint64_t v26 = v21;
      }

      uint64_t v20 = *((void *)this + 6);
      id v21 = v26;
    }

    while (v20);
  }

  uint64_t v17 = g_signpostLog;
  uint64_t v18 = (os_log_s *)v17;
  int v19 = *(void *)(a1 + 48);
  if (v19 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled((os_log_t)v17))
  {
    LOWORD(v30) = 0;
    _os_signpost_emit_with_name_impl( &dword_0,  v18,  OS_SIGNPOST_INTERVAL_END,  v19,  "Replayer-1-serial",  (const char *)&unk_3189BB,  (uint8_t *)&v30,  2u);
  }

  uint64_t v20 = g_signpostLog;
  id v21 = (os_log_s *)v20;
  uint64_t v22 = *(void *)(a1 + 48);
  if (v22 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled((os_log_t)v20))
  {
    id v23 = *(_DWORD *)(a1 + 64);
    unint64_t v30 = 67109120;
    int64x2_t v31 = v23;
    _os_signpost_emit_with_name_impl( &dword_0,  v21,  OS_SIGNPOST_INTERVAL_BEGIN,  v22,  "Replayer-5-network",  "%u. kGTMessageQueryInducedGPUPerfState",  (uint8_t *)&v30,  8u);
  }

  id v24 = *(void **)(a1 + 40);
  id v25 = (void *)objc_claimAutoreleasedReturnValue( +[GTTransportMessage_replayer messageWithKind:plistPayload:]( GTTransportMessage_replayer,  "messageWithKind:plistPayload:",  [*(id *)(a1 + 32) kind],  v16));
  [v24 send:v25 inReplyTo:*(void *)(a1 + 32) error:0];

  uint64_t v26 = g_signpostLog;
  unint64_t v27 = (os_log_s *)v26;
  unint64_t v28 = *(void *)(a1 + 48);
  if (v28 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled((os_log_t)v26))
  {
    LOWORD(v30) = 0;
    _os_signpost_emit_with_name_impl( &dword_0,  v27,  OS_SIGNPOST_INTERVAL_END,  v28,  "Replayer-5-network",  (const char *)&unk_3189BB,  (uint8_t *)&v30,  2u);
  }

  return [(id)g_activityLog leaveActivity];
}

  [v10 setSynchronous:1];
  unint64_t v45 = dispatch_queue_create("gputools.global_sync", 0LL);
  id v12 = objc_msgSend(v10, "newSourceWithQueue:");
  v48[0] = _NSConcreteStackBlock;
  v48[1] = 3221225472LL;
  v48[2] = __GTMTLReplayClient_createOldTransport_block_invoke;
  v48[3] = &unk_58EFF8;
  id v50 = a1;
  uint64_t v13 = v10;
  uint64_t v49 = v13;
  [v12 setMessageHandler:v48];
  v46[0] = _NSConcreteStackBlock;
  v46[1] = 3221225472LL;
  void v46[2] = __GTMTLReplayClient_createOldTransport_block_invoke_2;
  v46[3] = &unk_58F020;
  BOOL v14 = dispatch_semaphore_create(0LL);
  uint64_t v47 = v14;
  [v12 setRegistrationHandler:v46];
  [v12 resume];
  dispatch_semaphore_wait(v14, 0xFFFFFFFFFFFFFFFFLL);
  uint64_t v44 = (void *)objc_claimAutoreleasedReturnValue([v13 connect]);
  [v44 BOOLResult];
  int v15 = -[ReplayErrorTransport initWithTransport:]( objc_alloc(&OBJC_CLASS___ReplayErrorTransport),  "initWithTransport:",  v13);
  objc_storeStrong((id *)&_observer, v15);

  id v16 = v13;
  context = objc_autoreleasePoolPush();
  mach_timebase_info((mach_timebase_info_t)&g_DYTimebaseInfo);
  uint64_t v17 = v16;
  uint64_t v18 = objc_autoreleasePoolPush();
  int v19 = mach_absolute_time();
  gettimeofday(&v70, 0LL);
  uint64_t v20 = mach_absolute_time();
  char v71 = @"nanoseconds since epoch timestamp";
  id v21 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  1000000000 * v70.tv_sec + 1000LL * v70.tv_usec));
  *(void *)&buf = v21;
  int64x2_t v72 = @"mach absolute timestamp";
  uint64_t v22 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  v19 + ((v20 - v19) >> 1)));
  *((void *)&buf + 1) = v22;
  uint64_t v73 = @"mach timebase numerator";
  id v23 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedInt:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedInt:",  g_DYTimebaseInfo));
  unsigned int v76 = v23;
  unsigned int v74 = @"mach timebase denominator";
  id v24 = (__CFString *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedInt:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedInt:",  dword_5B9CC4));
  unsigned int v77 = v24;
  id v25 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &buf,  &v71,  4LL));

  uint64_t v26 = (void *)objc_claimAutoreleasedReturnValue( +[GTTransportMessage_replayer messageWithKind:attributes:]( &OBJC_CLASS___GTTransportMessage_replayer,  "messageWithKind:attributes:",  1539LL,  v25));
  [v17 send:v26 inReplyTo:0 error:0];

  objc_autoreleasePoolPop(v18);
  unint64_t v27 = (void *)objc_claimAutoreleasedReturnValue(+[NSBundle mainBundle](&OBJC_CLASS___NSBundle, "mainBundle"));
  unint64_t v28 = (void *)objc_claimAutoreleasedReturnValue([v27 executablePath]);
  unint64_t v29 = (void *)objc_claimAutoreleasedReturnValue([v27 bundleIdentifier]);
  if (v29) {
    unint64_t v30 = (__CFString *)objc_claimAutoreleasedReturnValue([v27 bundleIdentifier]);
  }
  else {
    unint64_t v30 = &stru_591D98;
  }

  char v71 = @"pid";
  int64x2_t v31 = +[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", getpid());
  unsigned int v32 = (void *)objc_claimAutoreleasedReturnValue(v31);
  *(void *)&buf = v32;
  int64x2_t v72 = @"path";
  unint64_t v33 = (void *)objc_claimAutoreleasedReturnValue([v27 bundlePath]);
  *((void *)&buf + 1) = v33;
  unsigned int v76 = v28;
  uint64_t v73 = @"executable-path";
  unsigned int v74 = @"identifier";
  unsigned int v77 = v30;
  unint64_t v34 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &buf,  &v71,  4LL));

  int32x2_t v35 = (void *)objc_claimAutoreleasedReturnValue( +[GTTransportMessage_replayer messageWithKind:attributes:]( &OBJC_CLASS___GTTransportMessage_replayer,  "messageWithKind:attributes:",  1536LL,  v34));
  [v17 send:v35 error:0];

  objc_autoreleasePoolPop(context);
  __destructor_8_s88_S_s96_s104_s120_s128_s136_s152_s160_s168_s176_s184_s192_s200_s208_s216_s224_s232_s240_s248_S_s256_s264_s272_s280_s288((id *)&newpool);
}

        int v5 = (uint64_t *)*v8;
        result = v8;
        if (!*v8) {
          goto LABEL_18;
        }
      }

      int v10 = *((_DWORD *)v8 + 8);
      if ((unsigned __int16)a4 != (unsigned __int16)v10)
      {
        uint64_t v11 = (unsigned __int16)*((_DWORD *)v8 + 8);
        if ((unsigned __int16)a4 >= v11)
        {
          goto LABEL_15;
        }

        goto LABEL_12;
      }

      if (v7 < HIWORD(v10)) {
        goto LABEL_12;
      }
      if (HIWORD(v10) >= v7) {
        goto LABEL_18;
      }
LABEL_15:
      result = v8 + 1;
      int v5 = (uint64_t *)v8[1];
      if (!v5) {
        goto LABEL_18;
      }
    }
  }

  uint64_t v8 = result;
LABEL_18:
  *a2 = v8;
  return result;
}

  uint64_t v17 = *v11++;
  LODWORD(v16) = v17;
  v102[0] = v11;
  id v16 = v16;
LABEL_15:
  uint64_t v18 = &__src[502];
  do
  {
    int v19 = *v11;
    uint64_t v20 = v11[1];
    id v21 = v11[2];
    v11 += 3;
    v102[0] = v11;
    if (a4)
    {
      *(_DWORD *)(v18 - 3) = v20;
      *((_BYTE *)v18 - 2) = v21;
      *((_BYTE *)v18 - 1) = v19;
      void *v18 = 0;
    }

    v18 += 4;
    --v16;
  }

  while (v16);
LABEL_19:
  if ((a4 & 1) != 0) {
    memcpy(v101, __src, 0x2E8uLL);
  }
  v101[159] = *v11;
  v101[161] = v11[1];
  HIDWORD(v101[166]) = *((_DWORD *)v11 + 4);
  LOBYTE(v101[185]) = v11[3];
  BYTE1(v101[185]) = v11[4];
  BYTE5(v101[186]) = v11[5];
  WORD2(v101[167]) = v11[6];
  LOWORD(v101[169]) = v11[7];
  uint64_t v22 = v11[8];
  id v23 = v11 + 9;
  v102[0] = v23;
  if (v22)
  {
    id v24 = &v101[93];
    do
    {
      MakeDYMTLRenderPipelineColorAttachmentDescriptor(v102, (uint64_t)v24, a4);
      v24 += 2;
      --v22;
    }

    while (v22);
    id v23 = v102[0];
  }

  result = strlen((const char *)v23);
  v102[0] = (void *)((char *)v23 + (result & 0xFFFFFFFFFFFFFFF8LL) + 8);
  uint64_t v26 = *(unsigned __int8 *)v23;
  if (!*(_BYTE *)v23) {
    id v23 = 0LL;
  }
  if (v26)
  {
    result = strlen((const char *)v23);
    unint64_t v27 = a3 + 52;
    unint64_t v28 = a3[52];
    unint64_t v29 = result + 1;
    if (result != -1LL)
    {
      unint64_t v30 = (void *)a3[52];
      goto LABEL_32;
    }
  }

  else
  {
    unint64_t v27 = a3 + 52;
    unint64_t v28 = a3[52];
  }

  unint64_t v29 = 0LL;
  unint64_t v30 = 0LL;
LABEL_32:
  void *v27 = v28 + v29;
  if (a4) {
    result = (size_t)memcpy(v30, v23, v29);
  }
  v101[150] = v30;
  if (v9 > 6)
  {
    int64x2_t v31 = v102[0];
    BYTE5(v101[185]) = *v102[0];
    if (v9 >= 9)
    {
      BYTE1(v101[188]) = v102[0][1];
      v101[151] = v102[0][2];
      BYTE6(v101[187]) = v102[0][3];
      BYTE5(v101[187]) = v102[0][4];
      BYTE4(v101[187]) = v102[0][5];
      unsigned int v32 = v102[0][6];
      v102[0] += 6;
      HIBYTE(v101[187]) = v32;
      LOBYTE(v101[188]) = v31[7];
      if (v9 >= 0x12)
      {
        unint64_t v33 = v31[8];
        unint64_t v34 = v31 + 9;
        if (v33)
        {
          int32x2_t v35 = (char *)&v101[180] + 7;
          do
          {
            if (a4) {
              void *v35 = *v34;
            }
            ++v34;
            ++v35;
            --v33;
          }

          while (v33);
        }

        int64x2_t v38 = *v34;
        uint64_t v36 = v34 + 1;
        unint64_t v37 = v38;
        v102[0] = v36;
        if (v38)
        {
          int64x2_t v39 = (char *)&v101[169] + 2;
          do
          {
            unint64_t v41 = *v36++;
            unint64_t v40 = v41;
            v102[0] = v36;
            if (a4) {
              *int64x2_t v39 = v40;
            }
            ++v39;
            --v37;
          }

          while (v37);
        }

        if (v9 >= 0x17)
        {
          BYTE3(v101[187]) = *v36;
          if (v9 >= 0x20)
          {
            BYTE3(v101[188]) = v36[1];
            uint64_t v42 = v36[2];
            v102[0] = v36 + 2;
            LODWORD(v101[166]) = v42;
            if (v9 >= 0x26)
            {
              v101[158] = v36[3];
              if (v9 != 38)
              {
                BYTE6(v101[185]) = v36[4];
                HIBYTE(v101[184]) = v36[5];
                LODWORD(v101[167]) = v36[6];
                HIDWORD(v101[165]) = v36[7];
                HIBYTE(v101[185]) = v36[8];
                BYTE1(v101[186]) = v36[9];
                BYTE2(v101[186]) = v36[10];
                BYTE3(v101[186]) = v36[11];
                BYTE2(v101[188]) = v36[12];
                BYTE6(v101[184]) = v36[13];
                BYTE4(v101[186]) = v36[14];
                BYTE2(v101[185]) = v36[15];
                if (v9 >= 0x29)
                {
                  v101[160] = v36[16];
                  if (v9 != 41)
                  {
                    v101[145] = v36[17];
                    v101[146] = v36[18];
                    BYTE6(v101[186]) = v36[19];
                    LOBYTE(v101[186]) = v36[20];
                    BYTE3(v101[185]) = v36[21];
                    BYTE4(v101[185]) = v36[22];
                    unint64_t v43 = v36[23];
                    uint64_t v44 = v36 + 24;
                    unint64_t v45 = (uint64_t *)((char *)v36 + ((v43 + 7) & 0xFFFFFFFFFFFFFFF8LL) + 192);
                    v102[0] = v45;
                    if (v43) {
                      uint64_t v46 = (void *)a3[52];
                    }
                    else {
                      uint64_t v46 = 0LL;
                    }
                    uint64_t v47 = (char *)(a3[52] + v43);
                    a3[52] = v47;
                    if (a4)
                    {
                      if (v43) {
                        uint64_t v48 = v44;
                      }
                      else {
                        uint64_t v48 = 0LL;
                      }
                      result = (size_t)memcpy(v46, v48, v43);
                      uint64_t v47 = (char *)a3[52];
                    }

                    v101[143] = v46;
                    v101[144] = v43;
                    unint64_t v51 = *v45;
                    id v50 = v45 + 1;
                    uint64_t v49 = v51;
                    uint64_t v52 = (void *)((char *)v50 + ((v51 + 7) & 0xFFFFFFFFFFFFFFF8LL));
                    v102[0] = v52;
                    if (v51) {
                      id v53 = v47;
                    }
                    else {
                      id v53 = 0LL;
                    }
                    a3[52] = &v47[v49];
                    if (a4)
                    {
                      if (v49) {
                        uint64_t v54 = v50;
                      }
                      else {
                        uint64_t v54 = 0LL;
                      }
                      result = (size_t)memcpy(v53, v54, v49);
                    }

                    v101[141] = v53;
                    v101[142] = v49;
                    if (v9 >= 0x33)
                    {
                      unint64_t v57 = *v52;
                      uint64_t v56 = v52 + 1;
                      id v55 = v57;
                      v102[0] = v56;
                      v101[164] = v57;
                      if (v57)
                      {
                        dispatch_semaphore_t v58 = 0LL;
                        int v59 = (uint64_t *)a3[50];
                        v101[163] = v59;
                        do
                        {
                          uint64_t v61 = *v56++;
                          uint64_t v60 = v61;
                          v102[0] = v56;
                          if (a4)
                          {
                            if (a5)
                            {
                              result = GetAliasStream2(a5, v60);
                              if (result) {
                                uint64_t v60 = *(void *)result;
                              }
                              else {
                                uint64_t v60 = 0LL;
                              }
                            }

                            int v59 = (uint64_t *)a3[50];
                            void *v59 = v60;
                            id v55 = v101[164];
                          }

                          a3[50] = ++v59;
                          ++v58;
                        }

                        while (v55 > v58);
                      }

                      else
                      {
                        v101[163] = 0LL;
                      }

                      unint64_t v62 = *v56;
                      v102[0] = v56 + 1;
                      v101[149] = v62;
                      if (v62)
                      {
                        id v63 = 0LL;
                        uint64_t v64 = (uint64_t *)a3[50];
                        v101[148] = v64;
                        unint64_t v65 = v56 + 2;
                        do
                        {
                          uint64_t v66 = *(v65 - 1);
                          v102[0] = v65;
                          if (a4)
                          {
                            if (a5)
                            {
                              result = GetAliasStream2(a5, v66);
                              if (result) {
                                uint64_t v66 = *(void *)result;
                              }
                              else {
                                uint64_t v66 = 0LL;
                              }
                            }

                            uint64_t v64 = (uint64_t *)a3[50];
                            *uint64_t v64 = v66;
                            unint64_t v62 = v101[149];
                          }

                          ++v65;
                          a3[50] = ++v64;
                          ++v63;
                        }

                        while (v62 > v63);
                      }

                      else
                      {
                        v101[148] = 0LL;
                      }

                      if (v9 >= 0x37)
                      {
                        MakeDYMTLLinkedFunctions((size_t)v102, &v101[133], a3, a4, a5);
                        result = MakeDYMTLLinkedFunctions((size_t)v102, &v101[109], a3, a4, a5);
                        if (v9 >= 0x3C)
                        {
                          v101[155] = *v102[0];
                          v101[152] = v102[0][1];
                          uint64_t v67 = v102[0][2];
                          uint64_t v68 = v102[0] + 3;
                          if (v67)
                          {
                            uint64_t v69 = &v101[177];
                            do
                            {
                              if (a4) {
                                *uint64_t v69 = *v68;
                              }
                              ++v68;
                              ++v69;
                              --v67;
                            }

                            while (v67);
                          }

                          int64x2_t v72 = *v68;
                          char v71 = v68 + 1;
                          uint64_t v70 = v72;
                          v102[0] = v71;
                          if (v72)
                          {
                            uint64_t v73 = (char *)&v101[173] + 1;
                            do
                            {
                              unsigned int v75 = *v71++;
                              unsigned int v74 = v75;
                              v102[0] = v71;
                              if (a4) {
                                void *v73 = v74;
                              }
                              ++v73;
                              --v70;
                            }

                            while (v70);
                          }

                          uint64_t v78 = *v71;
                          unsigned int v77 = v71 + 1;
                          unsigned int v76 = v78;
                          v102[0] = v77;
                          v101[157] = v78;
                          if (v78)
                          {
                            unint64_t v79 = 0LL;
                            unint64_t v80 = (uint64_t *)a3[50];
                            v101[156] = v80;
                            do
                            {
                              uint64_t v82 = *v77++;
                              unint64_t v81 = v82;
                              v102[0] = v77;
                              if (a4)
                              {
                                if (a5)
                                {
                                  AliasStream2 = (uint64_t *)GetAliasStream2(a5, v81);
                                  if (AliasStream2) {
                                    unint64_t v81 = *AliasStream2;
                                  }
                                  else {
                                    unint64_t v81 = 0LL;
                                  }
                                }

                                unint64_t v80 = (uint64_t *)a3[50];
                                void *v80 = v81;
                                unsigned int v76 = v101[157];
                              }

                              a3[50] = ++v80;
                              ++v79;
                            }

                            while (v76 > v79);
                          }

                          else
                          {
                            v101[156] = 0LL;
                          }

                          unint64_t v84 = *v77;
                          v102[0] = v77 + 1;
                          v101[154] = v84;
                          if (v84)
                          {
                            unint64_t v85 = 0LL;
                            uint64_t v86 = (uint64_t *)a3[50];
                            v101[153] = v86;
                            unint64_t v87 = v77 + 2;
                            do
                            {
                              unint64_t v88 = *(v87 - 1);
                              v102[0] = v87;
                              if (a4)
                              {
                                if (a5)
                                {
                                  unint64_t v89 = (uint64_t *)GetAliasStream2(a5, v88);
                                  if (v89) {
                                    unint64_t v88 = *v89;
                                  }
                                  else {
                                    unint64_t v88 = 0LL;
                                  }
                                }

                                uint64_t v86 = (uint64_t *)a3[50];
                                void *v86 = v88;
                                unint64_t v84 = v101[154];
                              }

                              ++v87;
                              a3[50] = ++v86;
                              ++v85;
                            }

                            while (v84 > v85);
                          }

                          else
                          {
                            v101[153] = 0LL;
                          }

                          MakeDYMTLLinkedFunctions((size_t)v102, &v101[125], a3, a4, a5);
                          result = MakeDYMTLLinkedFunctions((size_t)v102, &v101[117], a3, a4, a5);
                          if (v9 >= 0x42)
                          {
                            BYTE2(v101[187]) = *v102[0];
                            HIBYTE(v101[186]) = v102[0][1];
                            BYTE1(v101[187]) = v102[0][2];
                            LOBYTE(v101[187]) = v102[0][3];
                            if (v9 >= 0x44)
                            {
                              LODWORD(v101[165]) = v102[0][4];
                              if (v9 != 68)
                              {
                                HIWORD(v101[168]) = v102[0][5];
                                LOWORD(v101[168]) = v102[0][6];
                                WORD2(v101[168]) = v102[0][7];
                                WORD1(v101[168]) = v102[0][8];
                                if (v9 >= 0x4B) {
                                  HIWORD(v101[167]) = v102[0][9];
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }

  if (BYTE5(v101[185]) == 255) {
    BYTE5(v101[185]) = 0;
  }
  if (LODWORD(v101[166]) == -1)
  {
    BYTE3(v101[188]) = 0;
    LODWORD(v101[166]) = 1;
  }

  unint64_t v90 = (char *)a3[27];
  a3[27] = v90 + 1512;
  if (a4)
  {
    if (a5)
    {
      uint64_t v91 = (uint64_t *)GetAliasStream2(a5, v101[162]);
      if (v91) {
        uint64_t v92 = *v91;
      }
      else {
        uint64_t v92 = 0LL;
      }
      v101[162] = v92;
      unint64_t v94 = (uint64_t *)GetAliasStream2(a5, v101[147]);
      if (v94) {
        unint64_t v95 = *v94;
      }
      else {
        unint64_t v95 = 0LL;
      }
      v101[147] = v95;
      unint64_t v96 = (uint64_t *)GetAliasStream2(a5, v101[158]);
      if (v96) {
        uint64_t v97 = *v96;
      }
      else {
        uint64_t v97 = 0LL;
      }
      v101[158] = v97;
      uint64_t v98 = (uint64_t *)GetAliasStream2(a5, v101[155]);
      if (v98) {
        unint64_t v99 = *v98;
      }
      else {
        unint64_t v99 = 0LL;
      }
      v101[155] = v99;
      unint64_t v93 = (uint64_t *)GetAliasStream2(a5, v101[152]);
      if (!v93)
      {
        unint64_t v100 = 0LL;
        goto LABEL_153;
      }
    }

    else
    {
      unint64_t v93 = &v101[152];
    }

    unint64_t v100 = *v93;
LABEL_153:
    v101[152] = v100;
    return (size_t)memcpy(v90, v101, 0x5E8uLL);
  }

  return result;
}

      ++v9;
    }

    while (v9 < *(int *)(a2 + 12));
  }

LABEL_14:
    GTMTLReplayController_defaultDispatchFunction((uint64_t)a1, a2);
    goto LABEL_15;
  }

  if (v7 == -16285)
  {
    *a3 = 0;
    goto LABEL_14;
  }

  if (v7 != -16246) {
    goto LABEL_12;
  }
  if (!*a3) {
    goto LABEL_14;
  }
  objc_msgSend( v16,  "removeRenderCommandEncoderForKey:",  *(void *)GTTraceFunc_argumentBytesWithMap((void *)a2, *(unsigned __int8 *)(a2 + 13), *((void *)*a1 + 2)));
LABEL_15:
}

    abort();
  }

  if (a3 && ![a3 filePathURL])
  {
    if (s_logUsingOsLog)
    {
      int v10 = (os_log_s *)gt_default_log();
      if (os_log_type_enabled(v10, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)buf = 136315138;
        int v15 = objc_msgSend(objc_msgSend(a3, "absoluteString"), "UTF8String");
        int v7 = "fail: unix domain socket url must be a file url: %s";
        uint64_t v8 = v10;
        uint64_t v9 = 12;
LABEL_11:
        _os_log_fault_impl(&dword_0, v8, OS_LOG_TYPE_FAULT, v7, buf, v9);
        abort();
      }
    }

    else
    {
      id v12 = __stderrp;
      -[NSString UTF8String]( +[NSString stringWithFormat:]( NSString,  "stringWithFormat:",  @"fail: unix domain socket url must be a file url: %s",  objc_msgSend(objc_msgSend(a3, "absoluteString"), "UTF8String")),  "UTF8String");
      fprintf(v12, "%s\n");
    }

    goto LABEL_14;
  }

  queue = (dispatch_queue_s *)self->super.super.super._queue;
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472LL;
  block[2] = __38__GTUNIXDomainSocketTransport_setUrl___block_invoke;
  block[3] = &unk_58E1F8;
  block[4] = a3;
  block[5] = self;
  dispatch_sync(queue, block);
}

  *(void *)apr_array_push(a1) = ";\n";
  return v12;
}

    id v16 = *v43;
    uint64_t v17 = *v44;
    uint64_t v18 = *v45;
    int v19 = *v46;
    if (v16 != 2)
    {
      if (v16 != 1)
      {
        uint64_t v20 = 0LL;
        goto LABEL_40;
      }

      if (a5)
      {
        if (*v47)
        {
          uint64_t v20 = *(void *)(a3 + 128);
          *(void *)(a3 + 128) = v20 + 24;
          id v21 = (char *)v8 + *v8;
          uint64_t v22 = v20;
          id v23 = a3;
          id v24 = a4;
          id v25 = a5;
LABEL_30:
          uint64_t v8 = (unsigned int *)DecodeDYMTLStructType(v22, v21, v23, v24, v25);
LABEL_36:
          LOBYTE(v16) = 1;
          goto LABEL_40;
        }

        unint64_t v34 = *a5;
        unint64_t v40 = 0u;
        unint64_t v41 = 0u;
        unint64_t v37 = v34;
        int64x2_t v38 = 500;
        int64x2_t v39 = "isStructType";
        GTError_addError(a5, (uint64_t)&v37);
      }

      else if (*v47)
      {
        uint64_t v20 = *(void *)(a3 + 128);
        *(void *)(a3 + 128) = v20 + 24;
        id v21 = (char *)v8 + *v8;
        uint64_t v22 = v20;
        id v23 = a3;
        id v24 = a4;
        id v25 = 0LL;
        goto LABEL_30;
      }

      uint64_t v20 = 0LL;
      goto LABEL_36;
    }

    if (a5)
    {
      if (*v48)
      {
        uint64_t v20 = *(void *)(a3 + 144);
        *(void *)(a3 + 144) = v20 + 32;
        unint64_t v29 = (char *)v8 + *v8;
        unint64_t v30 = v20;
        int64x2_t v31 = a3;
        unsigned int v32 = a4;
        unint64_t v33 = a5;
LABEL_33:
        uint64_t v8 = (unsigned int *)DecodeDYMTLArrayType(v30, v29, v31, v32, v33);
LABEL_39:
        LOBYTE(v16) = 2;
LABEL_40:
        unint64_t v27 = 60;
        if (!(_DWORD)a4) {
          return v8;
        }
        goto LABEL_22;
      }

      int32x2_t v35 = *a5;
      unint64_t v40 = 0u;
      unint64_t v41 = 0u;
      unint64_t v37 = v35;
      int64x2_t v38 = 500;
      int64x2_t v39 = "isArrayType";
      GTError_addError(a5, (uint64_t)&v37);
    }

    else if (*v48)
    {
      uint64_t v20 = *(void *)(a3 + 144);
      *(void *)(a3 + 144) = v20 + 32;
      unint64_t v29 = (char *)v8 + *v8;
      unint64_t v30 = v20;
      int64x2_t v31 = a3;
      unsigned int v32 = a4;
      unint64_t v33 = 0LL;
      goto LABEL_33;
    }

    uint64_t v20 = 0LL;
    goto LABEL_39;
  }

  if (v13) {
    int v15 = 0;
  }
  else {
    int v15 = HIDWORD(v36) > 6;
  }
  if (v15) {
    goto LABEL_14;
  }
LABEL_21:
  unint64_t v27 = 0;
  uint64_t v20 = 0LL;
  int v19 = 0;
  uint64_t v18 = 0;
  LOBYTE(v16) = 0;
  uint64_t v17 = 0;
  if ((_DWORD)a4)
  {
LABEL_22:
    *(_BYTE *)a1 = v27;
    *(_DWORD *)(a1 + 1) = 0;
    *(_DWORD *)(a1 + 4) = 0;
    *(void *)(a1 + 8) = v20;
    *(_DWORD *)(a1 + 16) = v19;
    *(_WORD *)(a1 + 20) = v18;
    *(_BYTE *)(a1 + 22) = v16;
    *(_BYTE *)(a1 + 23) = v17;
  }

  return v8;
}

void sub_671F0( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
}

void *std::string::basic_string[abi:nn180100]<0>(void *a1, char *__s)
{
  size_t v4 = strlen(__s);
  if (v4 >= 0x7FFFFFFFFFFFFFF8LL) {
    abort();
  }
  size_t v5 = v4;
  if (v4 >= 0x17)
  {
    uint64_t v7 = (v4 & 0xFFFFFFFFFFFFFFF8LL) + 8;
    if ((v4 | 7) != 0x17) {
      uint64_t v7 = v4 | 7;
    }
    uint64_t v8 = v7 + 1;
    uint64_t v6 = operator new(v7 + 1);
    a1[1] = v5;
    a1[2] = v8 | 0x8000000000000000LL;
    *a1 = v6;
  }

  else
  {
    *((_BYTE *)a1 + 23) = v4;
    uint64_t v6 = a1;
    if (!v4) {
      goto LABEL_9;
    }
  }

  memmove(v6, __s, v5);
LABEL_9:
  *((_BYTE *)v6 + v5) = 0;
  return a1;
}

void std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::__emplace_unique_key_args<std::string,std::string const&>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v7 = *(char *)(a2 + 23);
  if (v7 >= 0) {
    uint64_t v8 = (uint64_t *)a2;
  }
  else {
    uint64_t v8 = *(uint64_t **)a2;
  }
  if (v7 >= 0) {
    unint64_t v9 = *(unsigned __int8 *)(a2 + 23);
  }
  else {
    unint64_t v9 = *(void *)(a2 + 8);
  }
  unint64_t v10 = std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:nn180100](v8, v9);
  unint64_t v11 = v10;
  unint64_t v12 = *(void *)(a1 + 8);
  if (v12)
  {
    uint8x8_t v13 = (uint8x8_t)vcnt_s8((int8x8_t)v12);
    v13.i16[0] = vaddlv_u8(v13);
    unint64_t v14 = v13.u32[0];
    if (v13.u32[0] > 1uLL)
    {
      unint64_t v3 = v10;
      if (v10 >= v12) {
        unint64_t v3 = v10 % v12;
      }
    }

    else
    {
      unint64_t v3 = (v12 - 1) & v10;
    }

    int v15 = *(unsigned __int8 ***)(*(void *)a1 + 8 * v3);
    if (v15)
    {
      for (uint64_t i = *v15; i; uint64_t i = *(unsigned __int8 **)i)
      {
        unint64_t v17 = *((void *)i + 1);
        if (v17 == v11)
        {
        }

        else
        {
          if (v14 > 1)
          {
            if (v17 >= v12) {
              v17 %= v12;
            }
          }

          else
          {
            v17 &= v12 - 1;
          }

          if (v17 != v3) {
            break;
          }
        }
      }
    }
  }

  uint64_t v18 = operator new(0x28uLL);
  void *v18 = 0LL;
  v18[1] = v11;
  int v19 = (std::string *)(v18 + 2);
  if (*(char *)(a3 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(v19, *(const std::string::value_type **)a3, *(void *)(a3 + 8));
  }

  else
  {
    *(_OWORD *)&v19->__r_.__value_.__l.__data_ = *(_OWORD *)a3;
    v18[4] = *(void *)(a3 + 16);
  }

  float v20 = (float)(unint64_t)(*(void *)(a1 + 24) + 1LL);
  float v21 = *(float *)(a1 + 32);
  if (!v12 || (float)(v21 * (float)v12) < v20)
  {
    BOOL v22 = 1LL;
    if (v12 >= 3) {
      BOOL v22 = (v12 & (v12 - 1)) != 0;
    }
    unint64_t v23 = v22 | (2 * v12);
    unint64_t v24 = vcvtps_u32_f32(v20 / v21);
    if (v23 <= v24) {
      size_t v25 = v24;
    }
    else {
      size_t v25 = v23;
    }
    std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__rehash<true>( a1,  v25);
    unint64_t v12 = *(void *)(a1 + 8);
    if ((v12 & (v12 - 1)) != 0)
    {
      if (v11 >= v12) {
        unint64_t v3 = v11 % v12;
      }
      else {
        unint64_t v3 = v11;
      }
    }

    else
    {
      unint64_t v3 = (v12 - 1) & v11;
    }
  }

  uint64_t v26 = *(void *)a1;
  unint64_t v27 = *(void **)(*(void *)a1 + 8 * v3);
  if (v27)
  {
    void *v18 = *v27;
LABEL_47:
    void *v27 = v18;
    goto LABEL_48;
  }

  void *v18 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = v18;
  *(void *)(v26 + 8 * v3) = a1 + 16;
  if (*v18)
  {
    unint64_t v28 = *(void *)(*v18 + 8LL);
    if ((v12 & (v12 - 1)) != 0)
    {
      if (v28 >= v12) {
        v28 %= v12;
      }
    }

    else
    {
      v28 &= v12 - 1;
    }

    unint64_t v27 = (void *)(*(void *)a1 + 8 * v28);
    goto LABEL_47;
  }

LABEL_48:
  ++*(void *)(a1 + 24);
}

    goto LABEL_49;
  }

  uint64_t v8 = g_signpostLog;
  unint64_t v9 = (os_log_s *)v8;
  unint64_t v10 = *(void *)(a1 + 56);
  if (v10 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled((os_log_t)v8))
  {
    unint64_t v11 = *(_DWORD *)(a1 + 64);
    *(_DWORD *)buf = 67109120;
    *(_DWORD *)&buf[4] = v11;
    _os_signpost_emit_with_name_impl( &dword_0,  v9,  OS_SIGNPOST_INTERVAL_BEGIN,  v10,  "Replayer-5-network",  "%u. kDYMessageReplayerQueryShaderInfo",  buf,  8u);
  }

  unint64_t v12 = *(void **)(a1 + 32);
  uint8x8_t v13 = (void *)objc_claimAutoreleasedReturnValue( +[GTTransportMessage_replayer messageWithKind:plistPayload:]( GTTransportMessage_replayer,  "messageWithKind:plistPayload:",  [*(id *)(a1 + 40) kind],  &__NSDictionary0__struct));
  [v12 send:v13 inReplyTo:*(void *)(a1 + 40) error:0];

  unint64_t v14 = g_signpostLog;
  int v15 = (os_log_s *)v14;
  id v16 = *(void *)(a1 + 56);
  if (v16 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled((os_log_t)v14))
  {
    *(_WORD *)buf = 0;
    _os_signpost_emit_with_name_impl( &dword_0,  v15,  OS_SIGNPOST_INTERVAL_END,  v16,  "Replayer-5-network",  (const char *)&unk_3189BB,  buf,  2u);
  }
}

void sub_67534(_Unwind_Exception *a1)
{
}

uint64_t std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::~__hash_table( uint64_t a1)
{
  uint64_t v2 = *(void ***)(a1 + 16);
  if (v2)
  {
    do
    {
      unint64_t v3 = (void **)*v2;
      operator delete(v2);
      uint64_t v2 = v3;
    }

    while (v3);
  }

  size_t v4 = *(void **)a1;
  *(void *)a1 = 0LL;
  if (v4) {
    operator delete(v4);
  }
  return a1;
}

unint64_t std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:nn180100]( uint64_t *a1, unint64_t a2)
{
  if (a2 > 0x20)
  {
    if (a2 <= 0x40)
    {
      uint64_t v5 = *(uint64_t *)((char *)a1 + a2 - 16);
      uint64_t v6 = *a1 - 0x3C5A37A36834CED9LL * (v5 + a2);
      uint64_t v8 = a1[2];
      uint64_t v7 = a1[3];
      uint64_t v9 = __ROR8__(v6 + v7, 52);
      uint64_t v10 = v6 + a1[1];
      uint64_t v11 = __ROR8__(v10, 7);
      uint64_t v12 = v10 + v8;
      uint64_t v13 = *(uint64_t *)((char *)a1 + a2 - 32) + v8;
      uint64_t v14 = *(uint64_t *)((char *)a1 + a2 - 8) + v7;
      uint64_t v15 = __ROR8__(v14 + v13, 52);
      uint64_t v16 = v11 + __ROR8__(*a1 - 0x3C5A37A36834CED9LL * (v5 + a2), 37) + v9;
      uint64_t v17 = __ROR8__(v13, 37);
      uint64_t v18 = *(uint64_t *)((char *)a1 + a2 - 24) + v13;
      uint64_t v19 = __ROR8__(v18, 7);
      uint64_t v20 = v16 + __ROR8__(v12, 31);
      uint64_t v21 = v18 + v5;
      uint64_t v22 = v21 + v14;
      unint64_t v23 = 0x9AE16A3B2F90404FLL;
      unint64_t v24 = 0xC3A5C85C97CB3127LL * (v22 + v20) - 0x651E95C4D06FBFB1LL * (v12 + v7 + v17 + v19 + v15 + __ROR8__(v21, 31));
      unint64_t v25 = v20 - 0x3C5A37A36834CED9LL * (v24 ^ (v24 >> 47));
      return (v25 ^ (v25 >> 47)) * v23;
    }

    unint64_t v4 = 0x9DDFEA08EB382D69LL;
    uint64_t v32 = *(uint64_t *)((char *)a1 + a2 - 48);
    uint64_t v33 = *(uint64_t *)((char *)a1 + a2 - 40);
    uint64_t v34 = *(uint64_t *)((char *)a1 + a2 - 24);
    uint64_t v36 = *(uint64_t *)((char *)a1 + a2 - 64);
    uint64_t v35 = *(uint64_t *)((char *)a1 + a2 - 56);
    uint64_t v37 = *(uint64_t *)((char *)a1 + a2 - 16);
    uint64_t v38 = *(uint64_t *)((char *)a1 + a2 - 8);
    unint64_t v39 = v35 + v37;
    unint64_t v40 = 0x9DDFEA08EB382D69LL
        * (v34 ^ ((0x9DDFEA08EB382D69LL * (v34 ^ (v32 + a2))) >> 47) ^ (0x9DDFEA08EB382D69LL * (v34 ^ (v32 + a2))));
    unint64_t v41 = 0x9DDFEA08EB382D69LL * (v40 ^ (v40 >> 47));
    unint64_t v42 = v36 + a2 + v35 + v32;
    uint64_t v43 = v42 + v33;
    unint64_t v44 = __ROR8__(v42, 44) + v36 + a2 + __ROR8__(v33 + v36 + a2 - 0x622015F714C7D297LL * (v40 ^ (v40 >> 47)), 21);
    uint64_t v45 = v35 + v37 + *(uint64_t *)((char *)a1 + a2 - 32) - 0x4B6D499041670D8DLL;
    uint64_t v46 = v45 + v34 + v37;
    uint64_t v47 = __ROR8__(v46, 44);
    uint64_t v48 = v46 + v38;
    uint64_t v49 = v47 + v45 + __ROR8__(v45 + v33 + v38, 21);
    uint64_t v51 = *a1;
    id v50 = a1 + 4;
    unint64_t v52 = v51 - 0x4B6D499041670D8DLL * v33;
    uint64_t v53 = -(uint64_t)((a2 - 1) & 0xFFFFFFFFFFFFFFC0LL);
    do
    {
      uint64_t v54 = *(v50 - 3);
      uint64_t v55 = v52 + v43 + v39 + v54;
      uint64_t v56 = v50[2];
      uint64_t v57 = v50[3];
      uint64_t v58 = v50[1];
      unint64_t v39 = v58 + v43 - 0x4B6D499041670D8DLL * __ROR8__(v39 + v44 + v56, 42);
      uint64_t v59 = v41 + v48;
      uint64_t v60 = *(v50 - 2);
      uint64_t v61 = *(v50 - 1);
      uint64_t v62 = *(v50 - 4) - 0x4B6D499041670D8DLL * v44;
      uint64_t v63 = v62 + v48 + v61;
      uint64_t v64 = v62 + v54 + v60;
      uint64_t v43 = v64 + v61;
      uint64_t v65 = __ROR8__(v64, 44) + v62;
      unint64_t v66 = (0xB492B66FBE98F273LL * __ROR8__(v55, 37)) ^ v49;
      unint64_t v52 = 0xB492B66FBE98F273LL * __ROR8__(v59, 33);
      unint64_t v44 = v65 + __ROR8__(v63 + v66, 21);
      unint64_t v67 = v52 + v49 + *v50;
      uint64_t v48 = v67 + v58 + v56 + v57;
      uint64_t v49 = __ROR8__(v67 + v58 + v56, 44) + v67 + __ROR8__(v39 + v60 + v67 + v57, 21);
      v50 += 8;
      unint64_t v41 = v66;
      v53 += 64LL;
    }

    while (v53);
    unint64_t v68 = v52
        - 0x622015F714C7D297LL
        * ((0x9DDFEA08EB382D69LL
          * (v49 ^ ((0x9DDFEA08EB382D69LL * (v49 ^ v44)) >> 47) ^ (0x9DDFEA08EB382D69LL * (v49 ^ v44)))) ^ ((0x9DDFEA08EB382D69LL * (v49 ^ ((0x9DDFEA08EB382D69LL * (v49 ^ v44)) >> 47) ^ (0x9DDFEA08EB382D69LL * (v49 ^ v44)))) >> 47));
    unint64_t v69 = 0x9DDFEA08EB382D69LL
        * (v68 ^ (v66
                - 0x4B6D499041670D8DLL * (v39 ^ (v39 >> 47))
                - 0x622015F714C7D297LL
                * ((0x9DDFEA08EB382D69LL
                  * (v48 ^ ((0x9DDFEA08EB382D69LL * (v48 ^ v43)) >> 47) ^ (0x9DDFEA08EB382D69LL * (v48 ^ v43)))) ^ ((0x9DDFEA08EB382D69LL * (v48 ^ ((0x9DDFEA08EB382D69LL * (v48 ^ v43)) >> 47) ^ (0x9DDFEA08EB382D69LL * (v48 ^ v43)))) >> 47))));
    unint64_t v70 = 0x9DDFEA08EB382D69LL * (v68 ^ (v69 >> 47) ^ v69);
    goto LABEL_13;
  }

  if (a2 > 0x10)
  {
    uint64_t v26 = a1[1];
    unint64_t v27 = 0xB492B66FBE98F273LL * *a1;
    uint64_t v28 = __ROR8__(0x9AE16A3B2F90404FLL * *(uint64_t *)((char *)a1 + a2 - 8), 30) + __ROR8__(v27 - v26, 43);
    unint64_t v29 = v27 + a2 + __ROR8__(v26 ^ 0xC949D7C7509E6557LL, 20) - 0x9AE16A3B2F90404FLL * *(uint64_t *)((char *)a1 + a2 - 8);
    unint64_t v23 = 0x9DDFEA08EB382D69LL;
    unint64_t v30 = 0x9DDFEA08EB382D69LL * (v29 ^ (v28 - 0x3C5A37A36834CED9LL * *(uint64_t *)((char *)a1 + a2 - 16)));
    unint64_t v31 = v29 ^ (v30 >> 47) ^ v30;
LABEL_8:
    unint64_t v25 = 0x9DDFEA08EB382D69LL * v31;
    return (v25 ^ (v25 >> 47)) * v23;
  }

  if (a2 < 9)
  {
    if (a2 >= 4)
    {
      uint64_t v72 = *(unsigned int *)((char *)a1 + a2 - 4);
      unint64_t v23 = 0x9DDFEA08EB382D69LL;
      unint64_t v73 = 0x9DDFEA08EB382D69LL * (((8 * *(_DWORD *)a1) + a2) ^ v72);
      unint64_t v31 = v72 ^ (v73 >> 47) ^ v73;
      goto LABEL_8;
    }

    unint64_t v4 = 0x9AE16A3B2F90404FLL;
    if (!a2) {
      return v4;
    }
    unint64_t v70 = (0xC949D7C7509E6557LL * (a2 + 4LL * *((unsigned __int8 *)a1 + a2 - 1))) ^ (0x9AE16A3B2F90404FLL
                                                                                   * (*(unsigned __int8 *)a1 | ((unint64_t)*((unsigned __int8 *)a1 + (a2 >> 1)) << 8)));
LABEL_13:
    v4 *= v70 ^ (v70 >> 47);
    return v4;
  }

  uint64_t v2 = *(uint64_t *)((char *)a1 + a2 - 8);
  uint64_t v3 = __ROR8__(v2 + a2, a2);
  return (0x9DDFEA08EB382D69LL
        * ((0x9DDFEA08EB382D69LL
          * (v3 ^ ((0x9DDFEA08EB382D69LL * (v3 ^ *a1)) >> 47) ^ (0x9DDFEA08EB382D69LL * (v3 ^ *a1)))) ^ ((0x9DDFEA08EB382D69LL * (v3 ^ ((0x9DDFEA08EB382D69LL * (v3 ^ *a1)) >> 47) ^ (0x9DDFEA08EB382D69LL * (v3 ^ *a1)))) >> 47))) ^ v2;
}

BOOL std::equal_to<std::string>::operator()[abi:nn180100](unsigned __int8 *a1, unsigned __int8 *a2)
{
  uint64_t v2 = a1[23];
  if ((v2 & 0x80u) == 0LL) {
    uint64_t v3 = a1[23];
  }
  else {
    uint64_t v3 = *((void *)a1 + 1);
  }
  uint64_t v4 = a2[23];
  int v5 = (char)v4;
  if ((v4 & 0x80u) != 0LL) {
    uint64_t v4 = *((void *)a2 + 1);
  }
  if (v3 != v4) {
    return 0LL;
  }
  if (v5 < 0) {
    a2 = *(unsigned __int8 **)a2;
  }
  if ((v2 & 0x80) != 0) {
    return memcmp(*(const void **)a1, a2, *((void *)a1 + 1)) == 0;
  }
  if (!a1[23]) {
    return 1LL;
  }
  uint64_t v6 = v2 - 1;
  do
  {
    int v8 = *a1++;
    int v7 = v8;
    int v10 = *a2++;
    int v9 = v10;
    BOOL v12 = v6-- != 0;
    BOOL v13 = v7 == v9;
    BOOL v14 = v7 == v9;
  }

  while (v13 && v12);
  return v14;
}

void std::__hash_node_destructor<std::allocator<std::__hash_node<std::string,void *>>>::operator()[abi:nn180100]( char a1, void **__p)
{
  if (a1)
  {
  }

  else if (!__p)
  {
    return;
  }

  operator delete(__p);
}

void std::string::__init_copy_ctor_external( std::string *this, const std::string::value_type *__s, std::string::size_type __sz)
{
  int v5 = this;
  if (__sz > 0x16)
  {
    if (__sz >= 0x7FFFFFFFFFFFFFF8LL) {
      abort();
    }
    std::string::size_type v6 = (__sz & 0xFFFFFFFFFFFFFFF8LL) + 8;
    if ((__sz | 7) != 0x17) {
      std::string::size_type v6 = __sz | 7;
    }
    std::string::size_type v7 = v6 + 1;
    int v8 = (std::string *)operator new(v6 + 1);
    v5->__r_.__value_.__l.__size_ = __sz;
    v5->__r_.__value_.__l.__cap_ = v7 | 0x8000000000000000LL;
    v5->__r_.__value_.__r.__words[0] = (std::string::size_type)v8;
    int v5 = v8;
  }

  else
  {
    this->__r_.__value_.__s.__size_ = __sz;
  }

  memmove(v5, __s, __sz + 1);
}

uint64_t GTUSCSamplingStreamingManagerHelper::SetupBumperCounters( GTUSCSamplingStreamingManagerHelper *this, NSDictionary *a2)
{
  uint64_t v2 = this;
  uint64_t v3 = (void *)objc_claimAutoreleasedReturnValue( -[GTUSCSamplingStreamingManagerHelper objectForKeyedSubscript:]( v2,  "objectForKeyedSubscript:",  @"passNum"));
  unsigned int v18 = [v3 unsignedIntValue];

  id v19 = [*((id *)&xmmword_5B8CE0 + 1) count];
  unint64_t v4 = 0LL;
  id v20 = [*((id *)&xmmword_5B8CE0 + 1) count];
  while (v4 < (unint64_t)[*((id *)&xmmword_5B8CE0 + 1) count])
  {
    int v5 = (void *)objc_claimAutoreleasedReturnValue([*((id *)&xmmword_5B8CE0 + 1) objectAtIndexedSubscript:v4]);
    for (unint64_t i = 0; i < (unint64_t)[&off_59F848 count]; ++i)
    {
      std::string::size_type v7 = (void *)objc_claimAutoreleasedReturnValue([v5 name]);
      int v8 = (void *)objc_claimAutoreleasedReturnValue([&off_59F848 objectAtIndexedSubscript:i]);
      unsigned int v9 = [v7 isEqualToString:v8];

      if (v9) {
        *(&v19 + i) = (id)v4;
      }
    }

    ++v4;
  }

  if (v18)
  {
    uint64_t v10 = 0LL;
    unint64_t v11 = (unint64_t)v19;
    unint64_t v12 = (unint64_t)v20;
    do
    {
      BOOL v13 = (void *)objc_claimAutoreleasedReturnValue( -[GTUSCSamplingStreamingManagerHelper objectForKeyedSubscript:]( v2,  "objectForKeyedSubscript:",  @"passList"));
      BOOL v14 = (void *)objc_claimAutoreleasedReturnValue([v13 objectAtIndexedSubscript:v10]);

      if (v11 < (unint64_t)[v14 count] && v12 < (unint64_t)objc_msgSend(v14, "count"))
      {
        uint64_t v15 = (void *)objc_claimAutoreleasedReturnValue([v14 objectAtIndexedSubscript:v12]);
        uint64_t v16 = (void *)objc_claimAutoreleasedReturnValue([v14 objectAtIndexedSubscript:v11]);
        [v14 setObject:v16 atIndexedSubscript:v12];

        [v14 setObject:v15 atIndexedSubscript:v11];
      }

      ++v10;
    }

    while (v18 != v10);
  }

  return v18;
}

void sub_67D80(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void GTUSCSamplingStreamingManagerHelper::StreamBatchIdFilteredCounters( GTUSCSamplingStreamingManagerHelper *this, uint64_t a2)
{
  unsigned __int8 v2 = atomic_load(byte_5B979C);
  if ((v2 & 1) != 0) {
    return;
  }
  id v168 = (id)objc_opt_new(&OBJC_CLASS___NSMutableDictionary, a2);
  if ((_DWORD)qword_5B9550 == -1)
  {
    unint64_t v11 = (void *)objc_claimAutoreleasedReturnValue( [*(id *)(GTUSCSamplingStreamingManagerHelper::Instance(void)::instance + 48) objectForKeyedSubscript:@"DerivedCounterDictionary"]);
    unint64_t v12 = (void *)objc_claimAutoreleasedReturnValue([v11 objectForKeyedSubscript:@"DerivedCounters"]);
    BOOL v13 = (void *)objc_claimAutoreleasedReturnValue([v12 objectForKeyedSubscript:@"CSInvocation"]);
    id v174 = (id)objc_claimAutoreleasedReturnValue([v13 objectForKeyedSubscript:@"counters"]);
  }

  else
  {
    uint64_t v3 = std::string::basic_string[abi:nn180100]<0>(&v246, "CSInvocation");
    CountersForDerivedCounter = GTAGXProfilingSupportHelper::GetCountersForDerivedCounter((uint64_t)v3);
    int v5 = CountersForDerivedCounter;
    if (SHIBYTE(v248) < 0)
    {
      operator delete(v246);
      if (v5) {
        goto LABEL_5;
      }
    }

    else if (CountersForDerivedCounter)
    {
LABEL_5:
      std::string::size_type v6 = (void *)objc_claimAutoreleasedReturnValue( +[NSMutableArray arrayWithCapacity:]( &OBJC_CLASS___NSMutableArray,  "arrayWithCapacity:",  0xAAAAAAAAAAAAAAABLL * ((v5[1] - *v5) >> 3)));
      uint64_t v7 = *v5;
      uint64_t v8 = v5[1];
      if (*v5 != v8)
      {
        do
        {
          uint64_t v9 = v7;
          uint64_t v10 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", v9));
          [v6 addObject:v10];

          v7 += 24LL;
        }

        while (v7 != v8);
      }

      id v174 = [v6 copy];

      goto LABEL_13;
    }

    id v174 = 0LL;
  }

LABEL_13:
  BOOL v173 = qword_5B9490
      && ((BOOL v14 = (void *)objc_claimAutoreleasedReturnValue([(id)qword_5B9490 objectForKeyedSubscript:@"num_cores"]),
           unsigned int v15 = [v14 unsignedIntValue],
           v14,
           uint64_t v16 = (void *)objc_claimAutoreleasedReturnValue([(id)qword_5B9490 objectForKeyedSubscript:@"num_mgpus"]),
           unsigned int v17 = [v16 unsignedIntValue],
           v16,
           v17 <= 1)
        ? (unsigned int v18 = 1)
        : (unsigned int v18 = v17),
          v15 / v18 >= 5)
      && [v174 count] == &dword_4;
  obunsigned int j = (id)objc_claimAutoreleasedReturnValue( [*(id *)(GTUSCSamplingStreamingManagerHelper::Instance(void)::instance + 16) objectForKeyedSubscript:@"profileCounters"]);
  id v19 = &CATransform3DIdentity_ptr;
  if ((_DWORD)qword_5B9550 == -1) {
    goto LABEL_111;
  }
  __int128 v210 = 0u;
  __int128 v211 = 0u;
  LODWORD(v212) = 1065353216;
  __int128 v218 = 0u;
  __int128 v219 = 0u;
  __int128 v220 = 0u;
  __int128 v221 = 0u;
  obunsigned int j = obj;
  id v20 = [obj countByEnumeratingWithState:&v218 objects:&v237 count:16];
  if (!v20) {
    goto LABEL_35;
  }
  uint64_t v21 = *(void *)v219;
  do
  {
    for (unint64_t i = 0LL; i != v20; unint64_t i = (char *)i + 1)
    {
      if (*(void *)v219 != v21) {
        objc_enumerationMutation(obj);
      }
      unint64_t v23 = std::string::basic_string[abi:nn180100]<0>( &v246, (char *)[*(id *)(*((void *)&v218 + 1) + 8 * (void)i) UTF8String]);
      unint64_t v24 = GTAGXProfilingSupportHelper::GetCountersForDerivedCounter((uint64_t)v23);
      unint64_t v25 = v24;
      if (SHIBYTE(v248) < 0)
      {
        operator delete(v246);
        if (!v25) {
          continue;
        }
      }

      else if (!v24)
      {
        continue;
      }

      uint64_t v26 = *v25;
      uint64_t v27 = v25[1];
      while (v26 != v27)
      {
        std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::__emplace_unique_key_args<std::string,std::string const&>( (uint64_t)&v210,  v26,  v26);
        v26 += 24LL;
      }
    }

    id v20 = [obj countByEnumeratingWithState:&v218 objects:&v237 count:16];
  }

  while (v20);
LABEL_35:

  uint64_t v28 = (void *)objc_claimAutoreleasedReturnValue( [*(id *)(GTUSCSamplingStreamingManagerHelper::Instance(void)::instance + 16) objectForKeyedSubscript:@"batchFilteredDerivedCounters"]);
  if (v28)
  {
    id v171 = v28;
    id v169 = v28;
    v176 = (void *)objc_claimAutoreleasedReturnValue( +[NSMutableArray arrayWithCapacity:]( NSMutableArray,  "arrayWithCapacity:",  [v169 count]));
    __int128 v228 = 0u;
    __int128 v229 = 0u;
    LODWORD(v230) = 1065353216;
    *(_OWORD *)__p = 0u;
    __int128 v233 = 0u;
    memset(v234, 0, 32);
    id v180 = v169;
    id v29 = [v180 countByEnumeratingWithState:__p objects:&v246 count:16];
    if (!v29) {
      goto LABEL_87;
    }
    uint64_t v188 = *(void *)v233;
    while (2)
    {
      uint64_t v30 = 0LL;
      while (2)
      {
        if (*(void *)v233 != v188) {
          objc_enumerationMutation(v180);
        }
        unint64_t v31 = (char *)[*((id *)__p[1] + v30) UTF8String];
        uint64_t v32 = operator new(0x28uLL);
        *uint64_t v32 = 0LL;
        v32[1] = 0LL;
        std::string::basic_string[abi:nn180100]<0>(v32 + 2, v31);
        int v33 = *((char *)v32 + 39);
        if (v33 >= 0) {
          uint64_t v34 = v32 + 2;
        }
        else {
          uint64_t v34 = (uint64_t *)v32[2];
        }
        if (v33 >= 0) {
          unint64_t v35 = *((unsigned __int8 *)v32 + 39);
        }
        else {
          unint64_t v35 = v32[3];
        }
        v32[1] = std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:nn180100](v34, v35);
        unint64_t v36 = std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:nn180100](v34, v35);
        unint64_t v37 = v36;
        v32[1] = v36;
        unint64_t v38 = *((void *)&v228 + 1);
        if (*((void *)&v228 + 1))
        {
          uint8x8_t v39 = (uint8x8_t)vcnt_s8(*(int8x8_t *)((char *)&v228 + 8));
          v39.i16[0] = vaddlv_u8(v39);
          unint64_t v40 = v39.u32[0];
          if (v39.u32[0] > 1uLL)
          {
            unint64_t v41 = v36;
            if (*((void *)&v228 + 1) <= v36) {
              unint64_t v41 = v36 % *((void *)&v228 + 1);
            }
          }

          else
          {
            unint64_t v41 = (*((void *)&v228 + 1) - 1LL) & v36;
          }

          unint64_t v42 = *(unsigned __int8 ***)(v228 + 8 * v41);
          if (v42)
          {
            for (unsigned int j = *v42; j; unsigned int j = *(unsigned __int8 **)j)
            {
              unint64_t v44 = *((void *)j + 1);
              if (v44 == v37)
              {
                if (std::equal_to<std::string>::operator()[abi:nn180100](j + 16, (unsigned __int8 *)v32 + 16))
                {
                  std::__hash_node_destructor<std::allocator<std::__hash_node<std::string,void *>>>::operator()[abi:nn180100]( 1,  (void **)v32);
                  goto LABEL_85;
                }
              }

              else
              {
                if (v40 > 1)
                {
                  if (v44 >= v38) {
                    v44 %= v38;
                  }
                }

                else
                {
                  v44 &= v38 - 1;
                }

                if (v44 != v41) {
                  break;
                }
              }
            }
          }
        }

        float v45 = (float)(unint64_t)(*((void *)&v229 + 1) + 1LL);
        if (!v38 || (float)(*(float *)&v230 * (float)v38) < v45)
        {
          BOOL v46 = (v38 & (v38 - 1)) != 0;
          if (v38 < 3) {
            BOOL v46 = 1LL;
          }
          unint64_t v47 = v46 | (2 * v38);
          unint64_t v48 = vcvtps_u32_f32(v45 / *(float *)&v230);
          if (v47 <= v48) {
            size_t v49 = v48;
          }
          else {
            size_t v49 = v47;
          }
          std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__rehash<true>( (uint64_t)&v228,  v49);
          unint64_t v38 = *((void *)&v228 + 1);
          unint64_t v37 = v32[1];
        }

        uint8x8_t v50 = (uint8x8_t)vcnt_s8((int8x8_t)v38);
        v50.i16[0] = vaddlv_u8(v50);
        if (v50.u32[0] > 1uLL)
        {
          if (v37 >= v38) {
            v37 %= v38;
          }
        }

        else
        {
          v37 &= v38 - 1;
        }

        uint64_t v51 = v228;
        unint64_t v52 = *(void **)(v228 + 8 * v37);
        if (v52)
        {
          *uint64_t v32 = *v52;
          goto LABEL_83;
        }

        *uint64_t v32 = v229;
        *(void *)&__int128 v229 = v32;
        *(void *)(v51 + 8 * v37) = &v229;
        if (*v32)
        {
          unint64_t v53 = *(void *)(*v32 + 8LL);
          if (v50.u32[0] > 1uLL)
          {
            if (v53 >= v38) {
              v53 %= v38;
            }
          }

          else
          {
            v53 &= v38 - 1;
          }

          unint64_t v52 = (void *)(v228 + 8 * v53);
LABEL_83:
          *unint64_t v52 = v32;
        }

        ++*((void *)&v229 + 1);
LABEL_85:
        if ((id)++v30 != v29) {
          continue;
        }
        break;
      }

      id v29 = [v180 countByEnumeratingWithState:__p objects:&v246 count:16];
      if (v29) {
        continue;
      }
      break;
    }

          unsigned int v18 = v7[1];
          for (uint64_t k = v7 + 2; ; k += 2)
          {
            id v20 = *k;
            if (*k >= v15 && (v15 < v20 || k[1] >= v18)) {
              break;
            }
          }

          if (k - 2 == v7)
          {
            m = a2;
            if (k < a2)
            {
              unint64_t v24 = *v8;
              m = a2 - 2;
              if (*v8 >= v15)
              {
                m = a2 - 2;
                do
                {
                  if (v15 >= v24)
                  {
                    if (m[1] < v18 || k >= m) {
                      break;
                    }
                  }

                  else if (k >= m)
                  {
                    break;
                  }

                  uint64_t v26 = *(m - 2);
                  m -= 2;
                  unint64_t v24 = v26;
                }

                while (v26 >= v15);
              }
            }
          }

          else
          {
            uint64_t v21 = *v8;
            for (m = a2 - 2; v21 >= v15 && (v15 < v21 || m[1] >= v18); m -= 2)
            {
              unint64_t v23 = *(m - 2);
              uint64_t v21 = v23;
            }
          }

          unint64_t i = k;
          if (k < m)
          {
            uint64_t v27 = *m;
            unint64_t i = k;
            uint64_t v28 = m;
            do
            {
              void *i = v27;
              void *v28 = v20;
              id v29 = i[1];
              i[1] = v28[1];
              v28[1] = v29;
              do
              {
                do
                {
                  uint64_t v30 = i[2];
                  i += 2;
                  id v20 = v30;
                }

                while (v30 < v15);
              }

              while (v15 >= v20 && i[1] < v18);
              do
              {
                unint64_t v31 = *(v28 - 2);
                v28 -= 2;
                uint64_t v27 = v31;
              }

              while (v31 >= v15 && (v15 < v27 || v28[1] >= v18));
            }

            while (i < v28);
          }

          if (i - 2 != v7)
          {
            *uint64_t v7 = *(i - 2);
            v7[1] = *(i - 1);
          }

          *(i - 2) = v15;
          *(i - 1) = v18;
          if (k < m)
          {
LABEL_50:
            result = std::__introsort<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned long long,unsigned long long> *,false>( v7,  i - 2,  a3,  a4 & 1);
            a4 = 0;
            continue;
          }

          uint64_t v32 = std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned long long,unsigned long long> *>( v7,  i - 2);
          result = std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned long long,unsigned long long> *>( i,  a2);
          if (!(_DWORD)result)
          {
            if (v32) {
              continue;
            }
            goto LABEL_50;
          }

          a2 = i - 2;
          if (v32) {
            return result;
          }
          goto LABEL_2;
        }

        BOOL v46 = i + 2;
        unint64_t v48 = i == a2 || v46 == a2;
        if ((a4 & 1) == 0)
        {
          if (v48) {
            return result;
          }
          while (1)
          {
            unsigned int v75 = v7;
            uint64_t v7 = v46;
            id v76 = v75[2];
            id v77 = *v75;
            if (v76 < *v75) {
              break;
            }
            if (v77 >= v76)
            {
              uint64_t v78 = v75[3];
              if (v78 < v75[1]) {
                goto LABEL_152;
              }
            }
  }

    unint64_t v4 = *(void *)(a1 + 120);
  }

  GTAGXPerfStateControl::DisableConsistentGPUPerfState((GTAGXPerfStateControl *)v4);
  return [*(id *)(*(void *)(a1 + 112) + 8) addOperation:*(void *)(a1 + 48)];
}
      }
    }
  }

  else
  {
    uint64_t v8 = 0LL;
  }

  objc_autoreleasePoolPop(v3);
  return v4;
}

  [*(id *)(v3 + 136) addObject:v5];
  return 0LL;
}
}

    BOOL v13 = 0LL;
    goto LABEL_24;
  }

  CurrentEncoderFreeBindingSlotIndex = _GetCurrentEncoderFreeBindingSlotIndex((void *)(a1 + 8));
  if (CurrentEncoderFreeBindingSlotIndex == 0x7FFFFFFFFFFFFFFFLL)
  {
    if (a3)
    {
      uint64_t v10 = @"Unable to debug pipeline - no available buffer binding slot";
      unint64_t v11 = 4;
LABEL_10:
      Error = GTShaderDebuggerMakeError(v11, v10, 0LL, 0LL, 0LL);
      BOOL v13 = 0LL;
      *a3 = (id)objc_claimAutoreleasedReturnValue(Error);
      goto LABEL_24;
    }

    goto LABEL_13;
  }

  BOOL v14 = CurrentEncoderFreeBindingSlotIndex;
  uint64_t v28 = 0LL;
  unsigned int v15 = v7;
  uint64_t v16 = objc_alloc_init(&OBJC_CLASS___MTLCompileOptions);
  -[MTLCompileOptions setLibraryType:](v16, "setLibraryType:", 1LL);
  -[MTLCompileOptions setLanguageVersion:](v16, "setLanguageVersion:", 196610LL);
  unsigned int v17 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"@executable_path/%@.metallib",  @"libtracebuffer_gb"));
  -[MTLCompileOptions setInstallName:](v16, "setInstallName:", v17);

  -[MTLCompileOptions setCompileSymbolVisibility:](v16, "setCompileSymbolVisibility:", 1LL);
  id v29 = @"GLOBAL_BINDING";
  unsigned int v18 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", v14));
  uint64_t v30 = v18;
  id v19 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v30,  &v29,  1LL));
  -[MTLCompileOptions setPreprocessorMacros:](v16, "setPreprocessorMacros:", v19);

  id v20 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithUTF8String:]( &OBJC_CLASS___NSString,  "stringWithUTF8String:",  "device void * constant trace_buffer [[ buffer(GLOBAL_BINDING) ]];\n"
                    "extern C {\n"
                    "  [[gnu::visibility(default)]] device void *__tracepoint_get_trace_buffer() {\n"
                    "    return trace_buffer;\n"
                    "  }\n"
                    "}\n"));
  uint64_t v21 = [v15 newLibraryWithSource:v20 options:v16 error:&v28];

  if (v21) {
    uint64_t v22 = [v15 newDynamicLibrary:v21 error:&v28];
  }
  else {
    uint64_t v22 = 0LL;
  }

  unint64_t v23 = v28;
  if (v22)
  {
    unint64_t v24 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
    -[NSMutableArray addObjectsFromArray:](v24, "addObjectsFromArray:", v5);
    -[NSMutableArray addObjectsFromArray:](v24, "addObjectsFromArray:", v8);
    -[NSMutableArray addObject:](v24, "addObject:", v22);
    BOOL v13 = -[NSMutableArray copy](v24, "copy");
  }

  else if (a3)
  {
    if ((*(void *)(a1 + 208) & 0x10LL) != 0) {
      unint64_t v25 = 4;
    }
    else {
      unint64_t v25 = 1;
    }
    uint64_t v26 = GTShaderDebuggerMakeError(v25, @"Internal error: debug dylib setup failed", 0LL, v23, 0LL);
    BOOL v13 = 0LL;
    *a3 = (id)objc_claimAutoreleasedReturnValue(v26);
  }

  else
  {
    BOOL v13 = 0LL;
  }

LABEL_24:
  return v13;
}

  BOOL v13 = *a1;
  v25.i64[0] = *(void *)(a3 + 8600);
  BOOL v14 = *find_entry(v13, &v25, 8uLL, 0LL);
  if (v14) {
    unsigned int v15 = *(void *)(v14 + 32);
  }
  else {
    unsigned int v15 = 0LL;
  }
  GTMTLSMRenderPipelineState_resourceAccess(&v25, v15, a1[1]);
  unint64_t v31 = vandq_s8(v31, (int8x16_t)vdupq_n_s64(~*(void *)(a3 + 6944)));
  BufferAccess(a1, a3 + 6952, &v31, a4);
  uint64_t v21 = a3 + 7448;
  uint64_t v22 = &v32;
LABEL_25:
  unint64_t v23 = a1;
  return TextureAccess(v23, v21, (uint64_t)v22, a4);
}

void sub_69580( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, void *a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19, uint64_t a20, void *a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, _Unwind_Exception *exception_objecta, uint64_t a28, uint64_t a29, void *a30)
{
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__195(uint64_t result, void *a2)
{
  uint64_t v2 = a2[6];
  a2[6] = 0LL;
  *(void *)(result + 4_Block_object_dispose(&STACK[0x3B0], 8) = v2;
  *(void *)(result + 56) = a2[7];
  a2[7] = 0LL;
  uint64_t v5 = a2[8];
  uint64_t v3 = a2 + 8;
  uint64_t v4 = v5;
  *(void *)(result + 64) = v5;
  uint64_t v6 = v3[1];
  *(void *)(result + 72) = v6;
  *(_DWORD *)(result + 80) = *((_DWORD *)v3 + 4);
  if (v6)
  {
    unint64_t v7 = *(void *)(v4 + 8);
    unint64_t v8 = *(void *)(result + 56);
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v7 >= v8) {
        v7 %= v8;
      }
    }

    else
    {
      v7 &= v8 - 1;
    }

    *(void *)(v2 + 8 * v7) = result + 64;
    void *v3 = 0LL;
    v3[1] = 0LL;
  }

  return result;
}

uint64_t __Block_byref_object_dispose__196(uint64_t a1)
{
  return std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long>>>::~__hash_table(a1 + 48);
}

__n128 __Block_byref_object_copy__197(__n128 *a1, __n128 *a2)
{
  a1[3].n128_u64[0] = 0LL;
  a1[3].n128_u64[1] = 0LL;
  a1[4].n128_u64[0] = 0LL;
  __n128 result = a2[3];
  a1[3] = result;
  a1[4].n128_u64[0] = a2[4].n128_u64[0];
  a2[3].n128_u64[0] = 0LL;
  a2[3].n128_u64[1] = 0LL;
  a2[4].n128_u64[0] = 0LL;
  return result;
}

void __Block_byref_object_dispose__198(uint64_t a1)
{
  unint64_t v1 = (void **)(a1 + 48);
  std::vector<std::vector<DYMTLEncoderInfo>>::__destroy_vector::operator()[abi:nn180100](&v1);
}

__n128 __Block_byref_object_copy__199(__n128 *a1, __n128 *a2)
{
  a1[3].n128_u64[0] = 0LL;
  a1[3].n128_u64[1] = 0LL;
  a1[4].n128_u64[0] = 0LL;
  __n128 result = a2[3];
  a1[3] = result;
  a1[4].n128_u64[0] = a2[4].n128_u64[0];
  a2[3].n128_u64[0] = 0LL;
  a2[3].n128_u64[1] = 0LL;
  a2[4].n128_u64[0] = 0LL;
  return result;
}

void __Block_byref_object_dispose__200(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 48);
  if (v2)
  {
    *(void *)(a1 + 56) = v2;
    operator delete(v2);
  }

void std::vector<std::vector<DYMTLEncoderInfo>>::resize(uint64_t *a1, unint64_t a2)
{
  uint64_t v3 = *a1;
  uint64_t v4 = a1[1];
  unint64_t v5 = 0xAAAAAAAAAAAAAAABLL * ((v4 - *a1) >> 3);
  unint64_t v6 = a2 - v5;
  if (a2 <= v5)
  {
    if (a2 < v5)
    {
      uint64_t v15 = v3 + 24 * a2;
      if (v4 != v15)
      {
        uint64_t v16 = a1[1];
        do
        {
          unsigned int v18 = *(void **)(v16 - 24);
          v16 -= 24LL;
          unsigned int v17 = v18;
          if (v18)
          {
            *(void *)(v4 - 16) = v17;
            operator delete(v17);
          }

          uint64_t v4 = v16;
        }

        while (v16 != v15);
      }

      a1[1] = v15;
    }
  }

  else
  {
    uint64_t v7 = a1[2];
    if (0xAAAAAAAAAAAAAAABLL * ((v7 - v4) >> 3) >= v6)
    {
      size_t v19 = 24 * ((24 * v6 - 24) / 0x18) + 24;
      bzero((void *)a1[1], v19);
      a1[1] = v4 + v19;
    }

    else
    {
      if (a2 > 0xAAAAAAAAAAAAAAALL) {
        abort();
      }
      v20[4] = a1 + 2;
      unint64_t v8 = 0xAAAAAAAAAAAAAAABLL * ((v7 - v3) >> 3);
      uint64_t v9 = 2 * v8;
      if (2 * v8 <= a2) {
        uint64_t v9 = a2;
      }
      if (v8 >= 0x555555555555555LL) {
        unint64_t v10 = 0xAAAAAAAAAAAAAAALL;
      }
      else {
        unint64_t v10 = v9;
      }
      unint64_t v11 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<std::vector<NSObject  {objcproto21OS_dispatch_semaphore}* {__strong}>>>(v10);
      unint64_t v12 = &v11[24 * v5];
      v20[0] = v11;
      v20[1] = v12;
      v20[3] = &v11[24 * v13];
      size_t v14 = 24 * ((24 * v6 - 24) / 0x18) + 24;
      bzero(v12, v14);
      v20[2] = &v12[v14];
      std::vector<std::vector<NSObject  {objcproto21OS_dispatch_semaphore}* {__strong}>>::__swap_out_circular_buffer( a1,  v20);
      std::__split_buffer<std::vector<std::pair<unsigned int,unsigned int>>>::~__split_buffer((uint64_t)v20);
    }
  }

void *std::vector<std::vector<DYMTLEncoderInfo>>::reserve(void *result, unint64_t a2)
{
  if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(result[2] - *result) >> 3) < a2)
  {
    if (a2 >= 0xAAAAAAAAAAAAAABLL) {
      abort();
    }
    uint64_t v2 = result;
    uint64_t v3 = result[1] - *result;
    void v5[4] = result + 2;
    v5[0] = std::__allocate_at_least[abi:nn180100]<std::allocator<std::vector<NSObject  {objcproto21OS_dispatch_semaphore}* {__strong}>>>(a2);
    v5[1] = v5[0] + v3;
    v5[2] = v5[0] + v3;
    v5[3] = v5[0] + 24 * v4;
    std::vector<std::vector<NSObject  {objcproto21OS_dispatch_semaphore}* {__strong}>>::__swap_out_circular_buffer( v2,  v5);
    return (void *)std::__split_buffer<std::vector<std::pair<unsigned int,unsigned int>>>::~__split_buffer((uint64_t)v5);
  }

  return result;
}

void ___ZN35GTUSCSamplingStreamingManagerHelper29StreamBatchIdFilteredCountersEv_block_invoke(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 80);
  unsigned __int8 v2 = atomic_load((unsigned __int8 *)(v1 + 2764));
  if ((v2 & 1) == 0)
  {
    GTMTLReplayController_prePlayForProfiling(**(void **)v1);
    DisableComputeEncoderCoalescing(**(GTMTLReplayController ***)v1, 1LL);
    unsigned int v4 = *(_DWORD *)(a1 + 88);
    BOOL v5 = v4 || *(_BYTE *)(a1 + 96) == 0;
    BOOL v6 = !v5;
    if (GTUSCSamplingStreamingManagerHelper::SetupSourceForDerivedCounters( (id *)v1,  *(NSDictionary **)(a1 + 32),  v4,  1,  v6))
    {
      uint64_t v7 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v1 + 16) firstObject]);
      unsigned __int8 v8 = [v7 startSampling];

      if ((v8 & 1) != 0)
      {
        unsigned int v9 = *(_DWORD *)(a1 + 88);
        if (v9) {
          unint64_t v10 = 0LL;
        }
        else {
          unint64_t v10 = (char **)(*(void *)(*(void *)(a1 + 64) + 8LL) + 48LL);
        }
        GTUSCSamplingStreamingManagerHelper::ReplayForDerivedCounters( (uint64_t **)v1,  (char **)(*(void *)(*(void *)(*(void *)(a1 + 56) + 8LL) + 48LL) + 24LL * v9),  v10,  *(void **)(a1 + 40),  (void *)(*(void *)(*(void *)(a1 + 72) + 8LL) + 48LL),  0LL);
        unint64_t v11 = objc_autoreleasePoolPush();
        id v12 = GTUSCSamplingStreamingManagerHelper::DrainRawDerivedCounterData((id *)v1);
        uint64_t v13 = (void *)objc_claimAutoreleasedReturnValue(v12);
        if (v13) {
          [*(id *)(a1 + 48) setArray:v13];
        }

        objc_autoreleasePoolPop(v11);
        size_t v14 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v1 + 16) firstObject]);
        [v14 stopSampling];

        DisableComputeEncoderCoalescing(**(GTMTLReplayController ***)v1, 0LL);
        if (*(_DWORD *)(a1 + 88) + 1 == *(_DWORD *)(a1 + 92))
        {
          GTAGXPerfStateControl::DisableConsistentGPUPerfState((GTAGXPerfStateControl *)(v1 + 40));
          GTApplePMPPerfStateControl::DisableConsistentPerfState((GTApplePMPPerfStateControl *)(v1 + 64));
        }
      }
    }
  }

void sub_69FF0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void ___ZN35GTUSCSamplingStreamingManagerHelper29StreamBatchIdFilteredCountersEv_block_invoke_2(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 48);
  unsigned __int8 v2 = atomic_load((unsigned __int8 *)(v1 + 2764));
  if ((v2 & 1) == 0)
  {
    unsigned int v4 = objc_autoreleasePoolPush();
    id v5 = GTUSCSamplingStreamingManagerHelper::PostProcessRawDerivedCounterData(v1, *(void **)(a1 + 32));
    BOOL v6 = (void *)objc_claimAutoreleasedReturnValue(v5);
    if (v6) {
      [*(id *)(a1 + 40) addObject:v6];
    }

    objc_autoreleasePoolPop(v4);
  }

void sub_6A080(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void std::vector<std::vector<DYMTLEncoderInfo>>::__destroy_vector::operator()[abi:nn180100](void ***a1)
{
  uint64_t v1 = *a1;
  unsigned __int8 v2 = (char *)**a1;
  if (v2)
  {
    unsigned int v4 = (char *)v1[1];
    id v5 = **a1;
    if (v4 != v2)
    {
      BOOL v6 = (char *)v1[1];
      do
      {
        unsigned __int8 v8 = (void *)*((void *)v6 - 3);
        v6 -= 24;
        uint64_t v7 = v8;
        if (v8)
        {
          *((void *)v4 - 2) = v7;
          operator delete(v7);
        }

        unsigned int v4 = v6;
      }

      while (v6 != v2);
      id v5 = **a1;
    }

    v1[1] = v2;
    operator delete(v5);
  }

id GTUSCSamplingStreamingManagerHelper::PostProcessRawDerivedCounterData(uint64_t a1, void *a2)
{
  id v3 = a2;
  if ([*(id *)(a1 + 24) count] && objc_msgSend(v3, "count"))
  {
    unsigned int v4 = &CATransform3DIdentity_ptr;
    id v23 = v3;
    unint64_t v24 = (void *)objc_claimAutoreleasedReturnValue( +[NSMutableArray arrayWithCapacity:]( NSMutableArray,  "arrayWithCapacity:",  [v3 count]));
    unint64_t v5 = 0LL;
    uint64_t v21 = a1;
LABEL_4:
    if (v5 >= (unint64_t)[v3 count])
    {
      id v18 = v24;
    }

    else
    {
      BOOL v6 = (void *)objc_claimAutoreleasedReturnValue([v3 objectAtIndexedSubscript:v5]);
      uint64_t v7 = (void *)objc_claimAutoreleasedReturnValue(-[CATransform3D arrayWithCapacity:]((id)v4[273], "arrayWithCapacity:", [v6 count]));
      unint64_t v22 = v5;
      unsigned __int8 v8 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 24) objectAtIndexedSubscript:v5]);
      for (unint64_t i = 0LL; ; ++i)
      {
        if (i >= (unint64_t)[v6 count])
        {
          [v24 addObject:v7];

          id v3 = v23;
          unint64_t v5 = v22 + 1;
          a1 = v21;
          unsigned int v4 = &CATransform3DIdentity_ptr;
          goto LABEL_4;
        }

        unint64_t v10 = (void *)objc_claimAutoreleasedReturnValue([v6 objectAtIndexedSubscript:i]);
        unint64_t v11 = (char *)[v10 length];
        uint64_t v25 = 0LL;
        uint64_t v26 = 0LL;
        unint64_t v12 = 4 * (void)[v10 length];
        if (v12 <= 0x4000) {
          unint64_t v12 = 0x4000LL;
        }
        unint64_t v13 = (v12 + 7) & 0xFFFFFFFFFFFFFFF8LL;
        size_t v14 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableData dataWithLength:](&OBJC_CLASS___NSMutableData, "dataWithLength:", v13));
        id v15 = v10;
        id v16 = [v15 bytes];
        id v17 = v14;
        LOBYTE(v20) = 1;
        if ((objc_msgSend( v8,  "postProcessRawDataWithRingBufferIndex:source:sourceSize:sourceRead:sourceWrite:output:outp utSize:outputRead:outputWrite:isLast:",  i,  v16,  v11 + 8,  &v26,  v11,  objc_msgSend(v17, "mutableBytes"),  v13,  0,  &v25,  v20) & 1) == 0) {
          break;
        }
        [v17 setLength:v25];
        [v7 addObject:v17];
      }

      NSLog( @"Failed to post process ringBuffer[%lu], srcSize[%llu], srcRead[%llu], srcWrite[%llu], outputSize[%llu], bufferWritten[%llu]",  i,  v11 + 8,  v26,  v11,  v13,  v25);

      id v18 = 0LL;
      id v3 = v23;
    }
  }

  else
  {
    id v18 = 0LL;
  }

  return v18;
}

void sub_6A378( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17, void *a18)
{
  _Unwind_Resume(a1);
}

void DisableComputeEncoderCoalescing(GTMTLReplayController *a1, uint64_t a2)
{
  if (a1)
  {
    id var1 = a1->var1;
    if (var1)
    {
      unsigned int v4 = (void *)objc_claimAutoreleasedReturnValue([var1 defaultDevice]);
      id v5 = DEVICEOBJECT(v4);
      id v6 = (id)objc_claimAutoreleasedReturnValue(v5);

      if (v6)
      {
        if ((objc_opt_respondsToSelector(v6, "disableComputeEncoderCoalescing") & 1) != 0) {
          [v6 setDisableComputeEncoderCoalescing:a2];
        }
      }
    }
  }

void sub_6A480( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
}

void GTUSCSamplingStreamingManagerHelper::ReplayForDerivedCounters( uint64_t **a1, char **a2, char **a3, void *a4, void *a5, void *a6)
{
  id v9 = a4;
  id v10 = a6;
  unint64_t v128 = (void *)objc_claimAutoreleasedReturnValue([(id)(*a1)[2] objectForKeyedSubscript:@"perEncoderDrawCallCount"]);
  id v136 = (id ***)a1;
  uint64_t v11 = **a1;
  v143[1] = v11;
  BOOL v144 = v9 == 0LL;
  if (!v9)
  {
    unint64_t v12 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v11 + 8) defaultCommandQueue]);
    [v12 setGPUPriority:0];
  }

  v143[0] = [(id)g_commandBufferDescriptor errorOptions];
  [(id)g_commandBufferDescriptor setErrorOptions:0];
  unint64_t v131 = a3;
  unint64_t v125 = v10;
  uint64_t v134 = v9;
  id v132 = *(id *)(v11 + 8);
  unint64_t v13 = *(uint64_t **)v11;
  BOOL v124 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v11 + 8) defaultCommandQueue]);
  uint64_t v140 = v11;
  size_t v14 = (unsigned int *)(v11 + 22480);
  if (a5)
  {
    v136[269] = 0LL;
    v136[267] = v136[266];
  }

  char v142 = 0;
  v136[241] = (id **)-1LL;
  unsigned int v141 = -1;
  if (v13[13] + v13[12] > (unint64_t)*v14)
  {
    unint64_t v126 = 0LL;
    do
    {
      id v15 = objc_autoreleasePoolPush();
      uint64_t v138 = *(void *)(v13[15] + 24);
      context = v15;
      uint64_t v137 = *v14;
      uint64_t v16 = v138 + (v137 << 6);
      id v17 = (int *)(v16 + 8);
      int FuncEnumConstructorType = GetFuncEnumConstructorType(*(_DWORD *)(v16 + 8));
      GTMTLReplayController_updateCommandEncoder(v140, v16);
      uint64_t v133 = *(void *)v14;
      id v18 = **v136;
      id v19 = v18[1];
      uint64_t v20 = *v18;
      uint64_t v21 = *((void *)*v18 + 2);
      if (v134)
      {
        unsigned int v22 = *v17;
        if ((IsFuncEnumDrawCall(*v17) & 1) != 0
          || (v22 != -16137 ? (BOOL v23 = v22 == -15297) : (BOOL v23 = 1), !v23 ? (v24 = v22 == -15486) : (v24 = 1), v24))
        {
          unsigned int v25 = v141;
          if (v141 == -1)
          {
            BOOL v26 = 0;
          }

          else
          {
            --v141;
            BOOL v26 = v25 == 0;
          }

          id v27 = objc_msgSend(v19, "renderCommandEncoderForKey:", GTTraceFunc_targetContext(v16, v21));
          uint64_t v28 = (void *)objc_claimAutoreleasedReturnValue(v27);
          id v29 = (void *)objc_claimAutoreleasedReturnValue([v19 renderPipelineStateForKey:v18[2489]]);
          if (v26)
          {
            id v30 = GTUSCSamplingStreamingManagerHelper::RenderDummyDrawCall( v136,  (uint64_t)v18,  v28,  0LL,  (uint64_t)v18[2489],  v16);
            unint64_t v31 = (void *)objc_claimAutoreleasedReturnValue(v30);
            [v28 setRenderPipelineState:v29];
          }

          else
          {
            unint64_t v31 = 0LL;
          }

          GTMTLReplayController_defaultDispatchFunction((uint64_t)v18, v16);
          if (v26)
          {
            id v32 =  GTUSCSamplingStreamingManagerHelper::RenderDummyDrawCall( v136,  (uint64_t)v18,  v28,  v31,  (uint64_t)v18[2489],  v16);
            [v28 setRenderPipelineState:v29];
          }

          goto LABEL_32;
        }

        if (v22 >> 2 == 1073737833)
        {
          GTUSCSamplingStreamingManagerHelper::DispatchExpandedIndirectCommand( (uint64_t)v136,  (uint64_t)v18,  (unint64_t *)v16,  0LL,  (int *)&v141);
          goto LABEL_33;
        }
      }

      DispatchFunction(v18, v16, &v142);
      if (GetFuncEnumConstructorType(*v17) == 21)
      {
        uint64_t v33 = *((void *)GTTraceFunc_argumentBytesWithMap( (void *)v16,  *(unsigned __int8 *)(v138 + (v137 << 6) + 13),  v21)
              + 1);
        if (std::__hash_table<std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>>>::find<unsigned int>( a5,  [v19 globalTraceIdForEncoder:v33 ofType:0]))
        {
          uint64_t v28 = (void *)objc_claimAutoreleasedReturnValue([v19 blitCommandEncoderForKey:v33]);
          [v28 endEncoding];
          id v34 = objc_msgSend(v19, "commandBufferForKey:", GTTraceFunc_targetContext(v16, v20[2]));
          id v29 = (void *)objc_claimAutoreleasedReturnValue(v34);
          unint64_t v31 = (void *)objc_claimAutoreleasedReturnValue([v29 computeCommandEncoder]);
          [v31 endEncoding];
          GTMTLReplayController_defaultDispatchFunction((uint64_t)v18, v16);
LABEL_32:
        }
      }

LABEL_33:
      unint64_t v35 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInt:](&OBJC_CLASS___NSNumber, "numberWithUnsignedInt:", *v14));
      unint64_t v36 = (void *)objc_claimAutoreleasedReturnValue([v128 objectForKeyedSubscript:v35]);

      if (v36)
      {
        uint64_t v37 = v138 + (v137 << 6);
        unsigned int v39 = *(unsigned __int8 *)(v37 + 13);
        unint64_t v38 = (unsigned __int8 *)(v37 + 13);
        uint64_t v40 = *((void *)GTTraceFunc_argumentBytesWithMap((void *)v16, v39, v13[2]) + 1);
        id v41 = objc_msgSend(v132, "commandBufferForKey:", GTTraceFunc_targetContext(v16, v13[2]));
        unint64_t v42 = (void *)objc_claimAutoreleasedReturnValue(v41);
        uint64_t v130 = v42;
        unsigned int v43 = [v42 globalTraceObjectID];
        if (v142) {
          uint64_t v44 = 160LL;
        }
        else {
          uint64_t v44 = 11312LL;
        }
        if (v131)
        {
          BOOL v46 = v131[1];
          unint64_t v45 = (unint64_t)v131[2];
          if ((unint64_t)v46 >= v45)
          {
            uint64_t v48 = (v46 - *v131) >> 3;
            uint64_t v49 = v45 - (void)*v131;
            uint64_t v50 = v49 >> 2;
            else {
              unint64_t v51 = v50;
            }
            if (v51) {
              unint64_t v51 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<std::pair<unsigned int,unsigned int>>>(v51);
            }
            else {
              uint64_t v52 = 0LL;
            }
            unint64_t v53 = (char *)(v51 + 8 * v48);
            *(void *)unint64_t v53 = 0LL;
            unint64_t v47 = v53 + 8;
            uint64_t v55 = *v131;
            uint64_t v54 = v131[1];
            if (v54 == *v131)
            {
              uint64_t v57 = v131;
            }

            else
            {
              do
              {
                uint64_t v56 = *((void *)v54 - 1);
                v54 -= 8;
                *((void *)v53 - 1) = v56;
                v53 -= 8;
              }

              while (v54 != v55);
              uint64_t v57 = v131;
              uint64_t v54 = *v131;
            }

            *uint64_t v57 = v53;
            v57[1] = v47;
            v57[2] = (char *)(v51 + 8 * v52);
            if (v54) {
              operator delete(v54);
            }
          }

          else
          {
            *(void *)BOOL v46 = 0LL;
            unint64_t v47 = v46 + 8;
          }

          v131[1] = v47;
          unint64_t v42 = v130;
        }

        int v58 = *(_DWORD *)(v140 + v44);
        if (v58 > 27)
        {
          if (v58 != 70)
          {
            if (v58 == 65)
            {
              uint64_t v74 = *((void *)GTTraceFunc_argumentBytesWithMap((void *)v16, *v38, v13[2]) + 1);
              unsigned int v75 = (void *)objc_claimAutoreleasedReturnValue([v132 parallelRenderCommandEncoderForKey:v40]);
              id v76 = DEVICEOBJECT(v75);
              uint64_t v61 = (void *)objc_claimAutoreleasedReturnValue(v76);

              if (a5)
              {
                unsigned int v77 = [v132 globalTraceIdForEncoder:v74 ofType:1];
                uint64_t v78 = (uint64_t)v136[241] + 1;
                v136[241] = (id **)v78;
                GTUSCSamplingStreamingManagerHelper::AddEncoderSamplePoints(v136, a5, v16, v77, v61, v78, v133, 0LL);
              }

              if (v131 && (objc_opt_respondsToSelector(v61, "tileWidth") & 1) != 0)
              {
                *((_DWORD *)v131[1] - 2) = [v61 tileWidth];
                *((_DWORD *)v131[1] - 1) = [v61 tileHeight];
              }

      objc_autoreleasePoolPop(context);
      ++v7;
    }

    while (v7 < *(int *)(*(void *)(a2 + 104) + 12LL));
  }

  unint64_t v31 = arr;
  if (arr->nelts <= 0)
  {
    id v34 = 0LL;
    unint64_t v35 = p;
  }

  else
  {
    id v112 = objc_autoreleasePoolPush();
    id v32 = BYTE1(GT_SUPPORT_0) & 0x20;
    id v116 = (dword_5B9DE4 >> 22) & (v32 >> 5);
    if ((dword_5B9DE4 & 0x80) != 0)
    {
      uint64_t v33 = a1;
      GTMTLIndirectResources_allResourcesByKey( (uint64_t *)&v145,  *(_DWORD ***)(*(void *)a1 + 40LL),  *(void *)(*(void *)a1 + 80LL) + *(unsigned int *)(a1 + 22480),  (dword_5B9DE4 >> 22) & (v32 >> 5),  p);
      v153 = v147;
      uint64_t v154 = v148;
      dispatch_semaphore_t v155 = v149;
      *(void *)&uint64_t v156 = v150;
      id v151 = v145;
      v152 = v146;
    }

    else
    {
      GTMTLIndirectResources_rehash( (apr_hash_index_t *)&v145,  a2 + 8,  (dword_5B9DE4 >> 22) & (v32 >> 5),  p);
      v153 = v147;
      uint64_t v154 = v148;
      dispatch_semaphore_t v155 = v149;
      *(void *)&uint64_t v156 = v150;
      id v151 = v145;
      v152 = v146;
      uint64_t v33 = a1;
    }

    *(void *)&unint64_t v145 = v128;
    *((void *)&v145 + 1) = &v151;
    *(void *)&uint64_t v146 = arr;
    unint64_t v36 = apr_array_make(p, 8, 32);
    uint64_t v37 = *(void *)(v33 + 22496);
    id v132 = v36;
    *((void *)&v146 + 1) = v36;
    *(void *)&v147 = v37;
    uint64_t v118 = -[NSMutableDictionary initWithCapacity:]( objc_alloc(&OBJC_CLASS___NSMutableDictionary),  "initWithCapacity:",  arr->nelts);
    uint64_t v115 = *(id *)(v33 + 24);
    unint64_t v38 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v33 + 8) defaultCommandQueue]);
    unsigned int v39 = InternalCommandBuffer(v38, @"AB_Patching");
    unint64_t v113 = (void *)objc_claimAutoreleasedReturnValue(v39);
    unint64_t v119 = v38;
    uint64_t v40 = InternalBlitCommandEncoder(v113, v38);
    uint64_t v117 = (void *)objc_claimAutoreleasedReturnValue(v40);
    [(id)g_activityLog enterArgumentBufferDownload];
    unint64_t v114 = 0;
    id v41 = 0;
    unint64_t v42 = arr->nelts;
    do
    {
      elts = v31->elts;
      uint64_t v44 = (v42 - v41);
      unint64_t v45 = v118;
      BOOL v46 = v41;
      unint64_t v47 = v117;
      uint64_t v48 = *(id *)(a1 + 8);
      uint64_t v49 = *(id *)(a1 + 24);
      unint64_t v123 = v47;
      if ((int)v44 < 1)
      {

        unint64_t v31 = arr;
      }

      else
      {
        contexta = v49;
        uint64_t v137 = v48;
        uint64_t v50 = 0;
        uint64_t v129 = v46;
        unint64_t v51 = &elts[40 * v46];
        do
        {
          uint64_t v52 = objc_autoreleasePoolPush();
          unint64_t v53 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  *(void *)v51));
          uint64_t v54 = (void *)objc_claimAutoreleasedReturnValue(-[NSMutableDictionary objectForKeyedSubscript:](v45, "objectForKeyedSubscript:", v53));

          if (!v54)
          {
            uint64_t v55 = (void *)objc_claimAutoreleasedReturnValue([v137 bufferForKey:*(void *)v51]);
            if ([v55 storageMode])
            {
              uint64_t v56 = [v55 length];
              uint64_t v57 = (GTMTLReplaySharedBufferRange *)objc_claimAutoreleasedReturnValue( objc_msgSend( contexta,  "bufferWithLength:alignment:",  v56,  objc_msgSend(*((id *)v51 + 3), "alignment")));
              int v58 = (void *)objc_claimAutoreleasedReturnValue(-[GTMTLReplaySharedBufferRange heapBuffer](v57, "heapBuffer"));
              uint64_t v59 = -[GTMTLReplaySharedBufferRange heapLocation](v57, "heapLocation");
              id v60 = (void *)objc_claimAutoreleasedReturnValue([contexta blitCommandEncoder]);
              [v60 copyFromBuffer:v55 sourceOffset:0 toBuffer:v58 destinationOffset:v59 size:v56];
              [v123 copyFromBuffer:v58 sourceOffset:v59 toBuffer:v55 destinationOffset:0 size:v56];

              uint64_t v50 = 1;
            }

            else
            {
              uint64_t v57 = -[GTMTLReplaySharedBufferRange initWithBuffer:]( objc_alloc(&OBJC_CLASS___GTMTLReplaySharedBufferRange),  "initWithBuffer:",  v55);
            }

            uint64_t v61 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  *(void *)v51));
            -[NSMutableDictionary setObject:forKeyedSubscript:](v45, "setObject:forKeyedSubscript:", v57, v61);
          }

          objc_autoreleasePoolPop(v52);
          v51 += 40;
          --v44;
        }

        while (v44);

        unint64_t v31 = arr;
        BOOL v46 = v129;
        if ((v50 & 1) != 0)
        {
          [v115 commitCommandBuffer];
          unint64_t v114 = 1;
        }
      }

      [v119 finish];
      unsigned int v62 = v46;
      uint64_t v63 = v45;
      contextb = v121;
      id v41 = v31->nelts;
      uint64_t v130 = v41;
      if (v116)
      {
        if (v41 > v46)
        {
          do
          {
            uint64_t v138 = objc_autoreleasePoolPush();
            uint64_t v64 = v31->elts;
            id v65 = v62;
            unint64_t v66 = &v64[40 * v62];
            v132->nelts = 0;
            id v67 = *((void *)v66 + 2);
            if (*(_BYTE *)(v67 + 22) == 1) {
              uint64_t v68 = *(void **)(v67 + 8);
            }
            else {
              uint64_t v68 = 0LL;
            }
            GTMTLStructType_fillArgumentIndicesRequiresPatching(v68, 0LL, 0LL, v132, v128);
            id v69 = *(unsigned int *)(*((void *)v66 + 2) + 16LL);
            uint64_t v70 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  *(void *)v66));
            id v71 = (void *)objc_claimAutoreleasedReturnValue(-[NSMutableDictionary objectForKeyedSubscript:](v63, "objectForKeyedSubscript:", v70));

            unsigned int v72 = (void *)objc_claimAutoreleasedReturnValue([v71 heapBuffer]);
            uint64_t v73 = DEVICEOBJECT(v72);
            uint64_t v74 = (void *)objc_claimAutoreleasedReturnValue(v73);

            unsigned int v75 = [v71 heapLocation];
            id v76 = [v71 length];
            unsigned int v77 = *(void *)v66;
            uint64_t v78 = *(void *)&v64[40 * v65 + 8];
            if ((dword_5B9DE4 & 0x40) != 0)
            {
              id v84 = *(void **)&v64[40 * v65 + 32];
              *(void *)&v165[0] = *(void *)v66;
              *((void *)&v165[0] + 1) = v78;
              reencodeBufferDataTier2(&v145, contextb, v74, (uint64_t)v75 + v78, v74, (uint64_t)v75 + v78, v165, v84);
            }

            else
            {
              unint64_t v79 = (unint64_t)v76;
              id v80 = v78 % v69;
              unint64_t v81 = v78 % v69 + v69;
              if (v81 <= (unint64_t)v76)
              {
                unsigned int v82 = (void **)&v64[40 * v65 + 32];
                do
                {
                  uint64_t v83 = (uint64_t)v75 + v80;
                  *(void *)&v165[0] = v77;
                  *((void *)&v165[0] + 1) = v80;
                  id v80 = v81;
                  reencodeBufferDataTier2(&v145, contextb, v74, v83, v74, v83, v165, *v82);
                  unint64_t v81 = v80 + v69;
                }

                while (v80 + v69 <= v79);
              }
            }

            objc_autoreleasePoolPop(v138);
            unsigned int v62 = v65 + 1;
            id v41 = v130;
            unint64_t v31 = arr;
          }

          while (v130 != (_DWORD)v65 + 1);
        }
      }

      else if (v41 > v46)
      {
        uint64_t v127 = v63;
        do
        {
          id v85 = objc_autoreleasePoolPush();
          id v86 = v31->elts;
          unsigned int v87 = &v86[40 * v62];
          v132->nelts = 0;
          uint64_t v88 = *((void *)v87 + 2);
          unint64_t v126 = v85;
          if (*(_BYTE *)(v88 + 22) == 1) {
            unint64_t v89 = *(void **)(v88 + 8);
          }
          else {
            unint64_t v89 = 0LL;
          }
          GTMTLStructType_fillArgumentIndicesRequiresPatching(v89, 0LL, 0LL, v132, v128);
          unint64_t v131 = v62;
          id v90 = v86;
          BOOL v91 = *(id *)&v86[40 * v62 + 24];
          unsigned int v92 = (unint64_t)[v91 encodedLength];
          unint64_t v93 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  *(void *)v87));
          uint64_t v135 = (void *)objc_claimAutoreleasedReturnValue(-[NSMutableDictionary objectForKeyedSubscript:](v127, "objectForKeyedSubscript:", v93));

          BOOL v94 = (void *)objc_claimAutoreleasedReturnValue([v135 heapBuffer]);
          uint64_t v95 = DEVICEOBJECT(v94);
          uint64_t v96 = (void *)objc_claimAutoreleasedReturnValue(v95);

          uint64_t v97 = (char *)[v135 heapLocation];
          uint64_t v98 = (char *)[v135 length];
          unint64_t v139 = *(void *)v87;
          if ((dword_5B9DE4 & 0x40) != 0)
          {
            uint64_t v109 = *(void *)&v90[40 * v131 + 8];
            uint64_t v110 = (uint64_t)&v97[v109];
            [v91 setArgumentBuffer:v96 offset:v110];
            *(void *)&v165[0] = v139;
            *((void *)&v165[0] + 1) = v109;
            reencodeBufferData((uint64_t)&v145, contextb, v96, v110, v91, v165);
          }

          else
          {
            unint64_t v99 = v98;
            unint64_t v100 = (void *)objc_claimAutoreleasedReturnValue([v96 device]);
            unint64_t v101 = [v100 supportsArgumentBuffersTier2];

            uint64_t v102 = (void *)objc_claimAutoreleasedReturnValue([v91 layout]);
            uint64_t v103 = [v102 hashValue];
            unint64_t v104 = [v102 hashOffset];
            BOOL v124 = v102;
            uint64_t v105 = *(void *)&v90[40 * v131 + 8];
            unint64_t v106 = v105 % v92;
            uint64_t v107 = (char *)(v105 % v92 + v92);
            if (v107 <= v99)
            {
              uint64_t v133 = &v97[v104];
              do
              {
                uint64_t v108 = v107;
                if ((v101 & 1) != 0
                  || *(_DWORD *)&v133[v106 + (void)[objc_retainAutorelease(v96) contents]] == v103)
                {
                  [v91 setArgumentBuffer:v96 offset:&v97[v106]];
                  *(void *)&v165[0] = v139;
                  *((void *)&v165[0] + 1) = v106;
                  reencodeBufferData((uint64_t)&v145, contextb, v96, (uint64_t)&v97[v106], v91, v165);
                }

                uint64_t v107 = &v108[v92];
                unint64_t v106 = (unint64_t)v108;
              }

              while (&v108[v92] <= v99);
            }

            unint64_t v31 = arr;
          }

          [v91 setArgumentBuffer:0 offset:0];

          objc_autoreleasePoolPop(v126);
          id v41 = v130;
          unsigned int v62 = v131 + 1;
          uint64_t v63 = v127;
        }

        while (v130 != (_DWORD)v131 + 1);
      }

      unint64_t v42 = v31->nelts;
      unint64_t v35 = p;
    }

    while (v41 < v42);
    [(id)g_activityLog leaveActivity];
    [v123 endEncoding];
    if ((v114 & 1) != 0)
    {
      [(id)g_activityLog enterArgumentBufferUpload];
      [(id)g_activityLog logSharedCommandBuffer:v113];
      v143[0] = _NSConcreteStackBlock;
      v143[1] = 3221225472LL;
      void v143[2] = __DYMTLIndirectArgumentBufferManager_processCommandBuffer_block_invoke;
      v143[3] = &unk_58F0C0;
      BOOL v144 = v63;
      [v113 addCompletedHandler:v143];
      GTMTLReplay_commitCommandBuffer(v113);

      [(id)g_activityLog leaveActivity];
    }

    objc_autoreleasePoolPop(v112);
    id v34 = v114 & 1;
  }

  apr_pool_destroy(v35);

  return v34;
}

      id v15 = 0LL;
      goto LABEL_8;
    }

    unsigned int v22 = (int8x8_t)a7[6];
    if (!*(void *)&v22) {
      goto LABEL_33;
    }
    BOOL v23 = Object[1];
    BOOL v24 = (uint8x8_t)vcnt_s8(v22);
    v24.i16[0] = vaddlv_u8(v24);
    if (v24.u32[0] > 1uLL)
    {
      unsigned int v25 = Object[1];
      if (v23 >= *(void *)&v22) {
        unsigned int v25 = v23 % *(void *)&v22;
      }
    }

    else
    {
      unsigned int v25 = (*(void *)&v22 - 1LL) & v23;
    }

    BOOL v26 = *(uint64_t ****)(a7[5] + 8 * v25);
    if (!v26) {
      goto LABEL_33;
    }
    id v27 = *v26;
    if (!v27) {
      goto LABEL_33;
    }
    while (1)
    {
      uint64_t v28 = (unint64_t)v27[1];
      if (v23 == v28) {
        break;
      }
      if (v24.u32[0] > 1uLL)
      {
        if (v28 >= *(void *)&v22) {
          v28 %= *(void *)&v22;
        }
      }

      else
      {
        v28 &= *(void *)&v22 - 1LL;
      }

      if (v28 != v25) {
        goto LABEL_33;
      }
LABEL_31:
      id v15 = 0LL;
      id v27 = (uint64_t **)*v27;
      if (!v27) {
        goto LABEL_8;
      }
    }

    uint64_t v21 = v27[3];
    switch(a1)
    {
      case 1u:
        [v14 setVertexIntersectionFunctionTable:v21 atBufferIndex:v16];
        break;
      case 2u:
        [v14 setFragmentIntersectionFunctionTable:v21 atBufferIndex:v16];
        break;
      case 4u:
        [v14 setTileIntersectionFunctionTable:v21 atBufferIndex:v16];
        break;
      case 8u:
        [v14 setIntersectionFunctionTable:v21 atBufferIndex:v16];
        break;
      default:
        break;
    }

    unint64_t v128 = v13;
    if (g_runningInCI)
    {
      unint64_t v36 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"statisticsName=%@",  v13));
      uint64_t v37 = (void *)objc_claimAutoreleasedReturnValue( [v36 stringByReplacingOccurrencesOfString:@"\n" withString:@"\n#CI-INFO# "]);

      unint64_t v38 = __stdoutp;
      unsigned int v39 = v37;
      fprintf(v38, "#CI-INFO# %s\n", (const char *)[v39 UTF8String]);
    }

    unint64_t v131 = (void *)IORegistryEntryCreateCFProperty(v2, @"MetalPluginName", 0LL, 0);
    uint64_t v40 = [v131 containsString:@"AGXMetal"];
    id v41 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableArray arrayWithCapacity:](&OBJC_CLASS___NSMutableArray, "arrayWithCapacity:", 2LL));
    [v41 addObject:v13];
    if (v40)
    {
      unint64_t v42 = [v13 rangeOfString:@"AGXMetalStatistics"];
      if ([v13 rangeOfString:@"AGXMetalStatisticsExternal"] == (id)0x7FFFFFFFFFFFFFFFLL
        && v42 < [v13 length])
      {
        unsigned int v43 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v13, "substringFromIndex:", objc_msgSend(@"AGXMetalStatistics", "length")));
        uint64_t v44 = (void *)objc_claimAutoreleasedReturnValue([@"AGXMetalStatisticsExternal" stringByAppendingString:v43]);

        [v41 addObject:v44];
      }
    }

    unint64_t v45 = IORegistryEntryCreateCFProperty(v2, @"MetalStatisticsScriptName", 0LL, 0);
    BOOL v46 = (void *)IORegistryEntryCreateCFProperty(v2, @"AGXInternalPerfCounterResourcesPath", 0LL, 0);
    if (v46)
    {
      unint64_t v47 = v46;
      uint64_t v48 = (const __CFString *)objc_claimAutoreleasedReturnValue([v46 stringByAppendingString:@"/%@/%@"]);
    }

    else
    {
      uint64_t v48 = @"/AppleInternal/Library/AGX/Performance/%@/%@";
    }

    unint64_t v120 = (__CFString *)v48;
    v152[0] = v48;
    v152[1] = @"/System/Library/Extensions/%@.bundle/%@";
    v152[2] = @"/System/Library/Extensions/%@.bundle/Contents/Resources/%@";
    BOOL v124 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", v152, 3LL));
    uint64_t v138 = 0u;
    unint64_t v139 = 0u;
    id v136 = 0u;
    uint64_t v137 = 0u;
    obunsigned int j = v41;
    unint64_t v122 = [obj countByEnumeratingWithState:&v136 objects:v151 count:16];
    if (v122)
    {
      uint64_t v49 = *(void *)v137;
      uint64_t v118 = *(void *)v137;
      do
      {
        uint64_t v50 = 0LL;
        do
        {
          if (*(void *)v137 != v49)
          {
            unint64_t v51 = v50;
            objc_enumerationMutation(obj);
            uint64_t v50 = v51;
          }

          unint64_t v119 = v50;
          uint64_t v52 = *(void *)(*((void *)&v136 + 1) + 8 * v50);
          id v132 = 0u;
          uint64_t v133 = 0u;
          uint64_t v134 = 0u;
          uint64_t v135 = 0u;
          unint64_t v53 = v124;
          uint64_t v54 = [v53 countByEnumeratingWithState:&v132 objects:v150 count:16];
          if (v54)
          {
            uint64_t v55 = *(void *)v133;
            while (2)
            {
              for (unint64_t i = 0LL; i != v54; unint64_t i = (char *)i + 1)
              {
                if (*(void *)v133 != v55) {
                  objc_enumerationMutation(v53);
                }
                uint64_t v57 = *(void *)(*((void *)&v132 + 1) + 8LL * (void)i);
                int v58 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  v57,  v131,  v52));
                uint64_t v59 = v58;
                if (v45) {
                  id v60 = (id)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](&OBJC_CLASS___NSString, "stringWithFormat:", v57, v131, v45));
                }
                else {
                  id v60 = v58;
                }
                uint64_t v61 = v60;
                if (g_runningInCI)
                {
                  unsigned int v62 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"Checking with plistPrefix=%@, scriptPrefix=%@",  v59,  v60));
                  uint64_t v63 = (void *)objc_claimAutoreleasedReturnValue( [v62 stringByReplacingOccurrencesOfString:@"\n" withString:@"\n#CI-INFO# "]);

                  uint64_t v64 = __stdoutp;
                  id v65 = v63;
                  fprintf(v64, "#CI-INFO# %s\n", (const char *)[v65 UTF8String]);
                }

                DerivedCounterInfo = GTMTLReplayClient_loadDerivedCounterInfo(v59, v61);
                id v67 = (void *)objc_claimAutoreleasedReturnValue(DerivedCounterInfo);

                if (v67)
                {

                  goto LABEL_65;
                }
              }

              uint64_t v54 = [v53 countByEnumeratingWithState:&v132 objects:v150 count:16];
              if (v54) {
                continue;
              }
              break;
            }
          }

          uint64_t v49 = v118;
          uint64_t v50 = v119 + 1;
        }

        while ((id)(v119 + 1) != v122);
        unint64_t v122 = [obj countByEnumeratingWithState:&v136 objects:v151 count:16];
        id v67 = 0LL;
        uint64_t v49 = v118;
      }

      while (v122);
    }

    else
    {
      id v67 = 0LL;
    }

  return v13;
}

          if (*((_DWORD *)v3 + 6))
          {
            uint64_t v40 = 0LL;
            id v41 = 0LL;
            unint64_t v42 = 0LL;
            do
            {
              unsigned int v43 = (char **)(*(void *)(*v3 + 72LL * (void)v8 + 24 * i) + v40);
              uint64_t v44 = *(unsigned int *)(*(void *)(v472 + 152) + v41);
              v529 = 0LL;
              std::vector<unsigned long long>::resize(v43, v44, &v529);
              ++v42;
              uint64_t v7 = *((unsigned int *)v3 + 6);
              v40 += 24LL;
              v41 += 32LL;
            }

            while (v42 < v7);
          }

          else
          {
            uint64_t v7 = 0LL;
          }
        }

        unsigned __int8 v8 = (JSValueRef)((char *)v8 + 1);
      }

      while (v8 != value);
    }

    unint64_t v45 = v472;
    v523[0] = 0LL;
    v428 = v472 + 176;
    std::unique_ptr<FrameRawCounterData>::reset[abi:nn180100]((void ***)(v472 + 176), (void **)v3);
    std::unique_ptr<FrameRawCounterData>::reset[abi:nn180100](v523, 0LL);
    if (v420 && [v420 count])
    {
      objc_storeStrong((id *)(v472 + 120), a2);
      unint64_t v45 = v472;
    }

    v418 = *(void *)(v45 + 120);
    BOOL v46 = (12 * *(_DWORD *)(v45 + 144));
    if ((_DWORD)v46)
    {
      __p = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<ShaderProfilerUSCSampleInfo>>(v46);
      v435 = &__p[40 * v47];
    }

    else
    {
      __p = 0LL;
      v435 = 0LL;
    }

    v503 = 0u;
    v504 = 0u;
    v501 = 0u;
    v502 = 0u;
    v417 = *(id *)(v45 + 8);
    uint64_t v49 = [v417 countByEnumeratingWithState:&v501 objects:v521 count:16];
    if (!v49)
    {
      uint64_t v50 = (unint64_t)__p;
      goto LABEL_189;
    }

    v421 = 0;
    v415 = v49;
    v416 = *(void *)v502;
    uint64_t v50 = (unint64_t)__p;
    do
    {
      for (unsigned int j = 0LL; j != v415; unsigned int j = (char *)j + 1)
      {
        if (*(void *)v502 != v416) {
          objc_enumerationMutation(v417);
        }
        unint64_t v51 = v421;
        uint64_t v52 = *(void *)(*(void *)(v45 + 152) + 32LL * v421 + 8);
        unint64_t v53 = *(void *)(*(void *)(v45 + 152) + 32LL * v421 + 16) - v52;
        if (v53 && *(_DWORD *)(v52 + 4))
        {
          LODWORD(v54) = 0;
          uint64_t v55 = v53 >> 3;
          do
          {
            v439 = v54;
            uint64_t v54 = (v54 + 1);
          }

          while (v55 > v54 && *(_DWORD *)(v52 + 8 * v54 + 4));
        }

        else
        {
          v439 = 0;
        }

        uint64_t v56 = *(void **)(*((void *)&v501 + 1) + 8LL * (void)j);
        v499 = 0u;
        v500 = 0u;
        v497 = 0u;
        v498 = 0u;
        v422 = v56;
        uint64_t v57 = [v422 countByEnumeratingWithState:&v497 objects:v520 count:16];
        if (!v57)
        {

          ++v421;
          goto LABEL_185;
        }

        int v58 = 0LL;
        uint64_t v59 = 0LL;
        v433 = 0LL;
        v441 = 0;
        v424 = *(void *)v498;
        if (v421) {
          id v60 = 0;
        }
        else {
          id v60 = v418 == 0;
        }
        uint64_t v61 = v60;
        v423 = v61;
        do
        {
          v425 = v57;
          for (uint64_t k = 0LL; k != v425; uint64_t k = (char *)k + 1)
          {
            if (*(void *)v498 != v424) {
              objc_enumerationMutation(v422);
            }
            unsigned int v62 = *(void **)(*((void *)&v497 + 1) + 8LL * (void)k);
            if (v441 == v439) {
              uint64_t v63 = v423;
            }
            else {
              uint64_t v63 = 0;
            }
            v437 = v63;
            v431 = (char *)[v62 count];
            v495 = 0u;
            v496 = 0u;
            v493 = 0u;
            v494 = 0u;
            v447 = v62;
            uint64_t v64 = [v447 countByEnumeratingWithState:&v493 objects:v519 count:16];
            if (v64)
            {
              v458 = *(id *)v494;
              id obja = -1;
              do
              {
                for (m = 0LL; m != v64; m = (char *)m + 1)
                {
                  if (*(id *)v494 != v458) {
                    objc_enumerationMutation(v447);
                  }
                  unint64_t v66 = *(id *)(*((void *)&v493 + 1) + 8LL * (void)m);
                  id v67 = [v66 bytes];
                  uint64_t v68 = [v66 length];
                  if (v58 == v59)
                  {
                    v467 = 0LL;
                    object = 0;
                  }

                  else
                  {
                    v467 = *v58;
                    object = v58[3] & 1;
                  }

                  id v69 = (void *)v472;
                  uint64_t v70 = *(void *)(*(void *)(v472 + 152) + 32 * v51 + 8) + 8LL * v441;
                  id v71 = *(unsigned int *)(v70 + 4);
                  if ((_DWORD)v71)
                  {
                    unsigned int v72 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<std::pair<unsigned int,unsigned int>>>(*(unsigned int *)(v70 + 4));
                    bzero(v72, 8 * v71);
                    uint64_t v73 = &v72[8 * v71];
                  }

                  else
                  {
                    unsigned int v72 = 0LL;
                    uint64_t v73 = 0LL;
                  }

                  value = (JSValueRef)v72;
                  ++obja;
                  unint64_t v51 = v421;
                  if (v68 < 8) {
                    goto LABEL_176;
                  }
                  context = 0;
                  uint64_t v74 = 0;
                  unsigned int v75 = 0LL;
                  v456 = v68 >> 3;
                  v445 = v73 - (char *)value;
                  v443 = 8
                  v450 = (char *)(v67 + 8);
                  while (2)
                  {
                    v484 = v58;
                    id v76 = v74;
                    while (v67[v76] != v69[28])
                    {
                      ++v76;
                      ++v74;
                      if (v456 == v76) {
                        goto LABEL_175;
                      }
                    }

                    if ((_DWORD)v76 == -1)
                    {
LABEL_175:
                      int v58 = v484;
                      break;
                    }

                    unsigned int v77 = &v67[v76];
                    uint64_t v78 = (unsigned int *)(*(void *)(v69[19] + 32 * v51 + 8) + 8LL * v441);
                    unint64_t v79 = v78[1];
                    else {
                      id v80 = v78[1];
                    }
                    v454 = v80;
                    if (v77[3] == 6LL)
                    {
                      unint64_t v81 = 0xCCCCCCCCCCCCCCCDLL * (v59 - v484);
                      if (v81 > context)
                      {
                        unsigned int v82 = v77[1];
                        if ((object & 1) != 0)
                        {
                          if (v82 > v467)
                          {
                            uint64_t v83 = context + 1;
                            if (v81 <= v83)
                            {
                              v467 = -1LL;
                              LODWORD(v83) = context;
                            }

                            else
                            {
                              v467 = v484[5 * v83];
                            }

                            if (v79 >= 8)
                            {
                              uint64_t v133 = *v78;
                              uint64_t v134 = (char *)&v484[5 * context];
                              uint64_t v135 = **(void **)v428 + 72LL * *((unsigned int *)v134 + 8);
                              id v136 = v134 + 24;
                              uint64_t v137 = v79 - 7;
                              uint64_t v138 = (uint64_t *)((char *)value + 56);
                              do
                              {
                                unint64_t v139 = *v138++;
                                uint64_t v140 = *(void *)(*(void *)(v135 + 24LL * (*v136 >> 1)) + 24LL * v421);
                                *(void *)(v140 + 8LL * v133++) += v139;
                                --v137;
                              }

                              while (v137);
                            }

                            if (v445 < 1)
                            {
                              object = 0;
                              context = v83;
                            }

                            else
                            {
                              v465 = v83;
                              v461 = v75;
                              bzero(value, v443);
                              unsigned int v77 = &v67[v76];
                              unsigned int v75 = v461;
                              object = 0;
                              context = v465;
                            }

                            LODWORD(v51) = v421;
                            goto LABEL_168;
                          }
                        }

                        else
                        {
                          if (v82 < v467)
                          {
                            object = 0;
                            goto LABEL_156;
                          }

                          v467 = v484[5 * ++context] + 480;
                        }

                        object = 1;
LABEL_168:
                        if (v79 >= 8)
                        {
                          unsigned int v141 = 0LL;
                          char v142 = *(void *)(*(void *)(v69[29] + 24LL * v51) + 24LL * v441);
                          do
                          {
                            uint64_t v143 = *(void *)&v450[8 * v74 + 8 * v141];
                            if (((*(void *)(v142 + ((v141 >> 3) & 0x1FFFFFFFFFFFFFF8LL)) >> v141) & 1) == 0 && v75) {
                              v143 -= v75[v141 + 8];
                            }
                            *((void *)value + v141++ + 7) += v143;
                          }

                          while (v79 - 7 != v141);
                        }

                        v460 = v77;
                        goto LABEL_101;
                      }
                    }

                    v460 = v75;
LABEL_101:
                    v464 = v77;
                    id v84 = v77[4];
                    id v85 = std::__hash_table<std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>>>::find<unsigned int>( (void *)(v69[23] + 40LL * v421),  v84);
                    id v86 = v85;
                    unsigned int v87 = v437;
                    if (!v85) {
                      unsigned int v87 = 0;
                    }
                    if (v87 == 1)
                    {
                      if (v50 >= (unint64_t)v435)
                      {
                        unsigned int v92 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v50 - (void)__p) >> 3) + 1;
                        if (v92 > 0x666666666666666LL) {
                          abort();
                        }
                        if (0x999999999999999ALL * ((v435 - __p) >> 3) > v92) {
                          unsigned int v92 = 0x999999999999999ALL * ((v435 - __p) >> 3);
                        }
                        if (0xCCCCCCCCCCCCCCCDLL * ((v435 - __p) >> 3) >= 0x333333333333333LL) {
                          unint64_t v93 = 0x666666666666666LL;
                        }
                        else {
                          unint64_t v93 = v92;
                        }
                        BOOL v94 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<ShaderProfilerUSCSampleInfo>>(v93);
                        uint64_t v96 = &v94[8 * ((uint64_t)(v50 - (void)__p) >> 3)];
                        uint64_t v97 = *((_DWORD *)v86 + 5);
                        unint64_t v89 = v464;
                        uint64_t v98 = v464[3];
                        unint64_t v99 = *((_OWORD *)v464 + 2);
                        *(void *)uint64_t v96 = v464[1];
                        *(_OWORD *)(v96 + _Block_object_dispose(&STACK[0x3B0], 8) = v99;
                        *((void *)v96 + 3) = v98;
                        *((_DWORD *)v96 + _Block_object_dispose(&STACK[0x3B0], 8) = v97;
                        *((_DWORD *)v96 + 9) = obja;
                        if ((char *)v50 == __p)
                        {
                          unint64_t v104 = &v94[8 * ((uint64_t)(v50 - (void)__p) >> 3)];
                          unint64_t v101 = __p;
                          id v69 = (void *)v472;
                        }

                        else
                        {
                          unint64_t v100 = &v94[8 * ((uint64_t)(v50 - (void)__p) >> 3)];
                          unint64_t v101 = __p;
                          id v69 = (void *)v472;
                          do
                          {
                            uint64_t v102 = *(_OWORD *)(v50 - 40);
                            uint64_t v103 = *(_OWORD *)(v50 - 24);
                            unint64_t v104 = v100 - 40;
                            *((void *)v100 - 1) = *(void *)(v50 - 8);
                            *(_OWORD *)(v100 - 24) = v103;
                            *(_OWORD *)(v100 - 40) = v102;
                            v50 -= 40LL;
                            v100 -= 40;
                          }

                          while ((char *)v50 != __p);
                        }

                        v435 = &v94[40 * v95];
                        uint64_t v50 = (unint64_t)(v96 + 40);
                        if (v101)
                        {
                          operator delete(v101);
                          unint64_t v89 = v464;
                        }

                        __p = v104;
                      }

                      else
                      {
                        uint64_t v88 = *((_DWORD *)v85 + 5);
                        unint64_t v89 = v464;
                        id v90 = v464[5];
                        BOOL v91 = v464[3];
                        *(void *)uint64_t v50 = v464[1];
                        *(void *)(v50 + _Block_object_dispose(&STACK[0x3B0], 8) = v84;
                        *(void *)(v50 + 16) = v90;
                        *(void *)(v50 + 24) = v91;
                        *(_DWORD *)(v50 + 32) = v88;
                        *(_DWORD *)(v50 + 36) = obja;
                        v50 += 40LL;
                      }

                      unsigned int v75 = v460;
                    }

                    else
                    {
                      unsigned int v75 = v460;
                      unint64_t v89 = v464;
                    }

                    unint64_t v51 = v421;
                    if (v86 && v431 == (_BYTE *)&dword_0 + 1 && v441 > v439)
                    {
                      if (v59 >= (unint64_t *)v433)
                      {
                        uint64_t v108 = 0xCCCCCCCCCCCCCCCDLL * (v59 - v484) + 1;
                        if (v108 > 0x666666666666666LL) {
                          abort();
                        }
                        else {
                          uint64_t v109 = v108;
                        }
                        uint64_t v110 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<ShaderProfilerUSCSampleInfo>>(v109);
                        id v112 = &v110[8 * (v59 - v484)];
                        unint64_t v113 = *((_DWORD *)v86 + 5);
                        unint64_t v89 = v464;
                        unint64_t v114 = v464[3];
                        uint64_t v115 = *((_OWORD *)v464 + 2);
                        *(void *)id v112 = v464[1];
                        *(_OWORD *)(v112 + _Block_object_dispose(&STACK[0x3B0], 8) = v115;
                        *((void *)v112 + 3) = v114;
                        *((void *)v112 + 4) = v113;
                        if (v59 == v484)
                        {
                          unint64_t v120 = &v110[8 * (v59 - v484)];
                          uint64_t v117 = v484;
                        }

                        else
                        {
                          id v116 = &v110[8 * (v59 - v484)];
                          uint64_t v117 = v484;
                          do
                          {
                            uint64_t v118 = *(_OWORD *)(v59 - 5);
                            unint64_t v119 = *(_OWORD *)(v59 - 3);
                            unint64_t v120 = v116 - 40;
                            *((void *)v116 - 1) = *(v59 - 1);
                            *(_OWORD *)(v116 - 24) = v119;
                            *(_OWORD *)(v116 - 40) = v118;
                            v59 -= 5;
                            v116 -= 40;
                          }

                          while (v59 != v484);
                        }

                        v433 = &v110[40 * v111];
                        uint64_t v59 = (unint64_t *)(v112 + 40);
                        if (v117)
                        {
                          operator delete(v117);
                          unint64_t v89 = v464;
                        }

                        v484 = (unint64_t *)v120;
                        unint64_t v51 = v421;
                        unsigned int v75 = v460;
                      }

                      else
                      {
                        uint64_t v105 = *((_DWORD *)v86 + 5);
                        unint64_t v106 = v89[3];
                        uint64_t v107 = *((_OWORD *)v89 + 2);
                        void *v59 = v89[1];
                        *(_OWORD *)(v59 + 1) = v107;
                        v59[3] = v106;
                        v59[4] = v105;
                        v59 += 5;
                      }
                    }

                    uint64_t v121 = (int *)(*(void *)(v69[19] + 32 * v51 + 8) + 8LL * v441);
                    unint64_t v122 = v121[1];
                    if ((_DWORD)v122)
                    {
                      unint64_t v123 = v89[3];
                      if ((v123 & 1) != 0 && v86)
                      {
                        BOOL v124 = *((_DWORD *)v86 + 5);
                        unint64_t v125 = v123 >> 1;
                        if (v441 == v439)
                        {
                          unint64_t v126 = *(void **)(*(void *)(**(void **)v428 + 72LL * v124 + 24LL * v125)
                                            + 24LL * v51);
                          *v126 += v89[2];
                        }

                        if (v122 >= 8)
                        {
                          uint64_t v127 = 0LL;
                          unint64_t v128 = *v121;
                          uint64_t v129 = *(void *)(*(void *)(**(void **)v428 + 72LL * v124 + 24LL * v125)
                                           + 24LL * v51);
                          uint64_t v130 = v122 - 7;
                          do
                          {
                            unint64_t v131 = *(void *)&v450[8 * v74 + 8 * v127];
                            if (v75)
                            {
                              id v132 = v75[v127 + 8];
                              if (((*(void *)(*(void *)(*(void *)(v69[29] + 24LL * v51)
                                                           + 24LL * v441)
                                               + ((v127 >> 3) & 0x1FFFFFFFFFFFFFF8LL)) >> v127) & 1LL) != 0)
                                id v132 = 0LL;
                              v131 -= v132;
                            }

                            *(void *)(v129 + 8LL * (v128 + v127++)) += v131;
                          }

                          while (v130 != v127);
                        }
                      }

                      unsigned int v75 = v89;
                    }

LABEL_119:
LABEL_120:
            if (FuncEnumConstructorType == 25)
            {
              uint64_t v110 = *((void *)GTTraceFunc_argumentBytesWithMap( (void *)v16,  *(unsigned __int8 *)(v138 + (v137 << 6) + 13),  v13[2])
                     + 1);
              if (v134)
              {
                uint64_t v111 = (void *)objc_claimAutoreleasedReturnValue([v132 commandBufferForKey:v110]);
                id v112 = DEVICEOBJECT(v111);
                unint64_t v113 = (void *)objc_claimAutoreleasedReturnValue(v112);

                [v113 setDisableDeferredEndEncoding:1];
              }

              unint64_t v114 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v140 + 8) defaultDevice]);
              uint64_t v115 = (void *)objc_claimAutoreleasedReturnValue( +[MTLTextureDescriptor texture2DDescriptorWithPixelFormat:width:height:mipmapped:]( &OBJC_CLASS___MTLTextureDescriptor,  "texture2DDescriptorWithPixelFormat:width:height:mipmapped:",  70LL,  16LL,  16LL,  0LL));
              [v115 setUsage:4];
              id v116 = [v114 newTextureWithDescriptor:v115];
              uint64_t v117 = (void *)objc_claimAutoreleasedReturnValue( +[MTLRenderPassDescriptor renderPassDescriptor]( &OBJC_CLASS___MTLRenderPassDescriptor,  "renderPassDescriptor"));
              unint64_t v119 = (void *)objc_opt_new(&OBJC_CLASS___MTLRenderPassColorAttachmentDescriptor, v118);
              [v119 setTexture:v116];
              [v119 setLoadAction:2];
              [v119 setStoreAction:1];
              objc_msgSend(v119, "setClearColor:", 0.0, 0.0, 0.0, 1.0);
              unint64_t v120 = (void *)objc_claimAutoreleasedReturnValue([v117 colorAttachments]);
              [v120 setObject:v119 atIndexedSubscript:0];

              uint64_t v121 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v140 + 8) commandBufferForKey:v110]);
              unint64_t v122 = (void *)objc_claimAutoreleasedReturnValue([v121 renderCommandEncoderWithDescriptor:v117]);
              [v122 setLabel:@"GPUToolsCounterProfilingEmptyRender"];
              [v122 endEncoding];
            }

            goto LABEL_124;
          }

          uint64_t v68 = (void *)objc_claimAutoreleasedReturnValue([v132 renderCommandEncoderForKey:v40]);
          id v69 = DEVICEOBJECT(v68);
          uint64_t v70 = (void *)objc_claimAutoreleasedReturnValue(v69);

          id v71 = v70;
          uint64_t v61 = v71;
          if (a5)
          {
            unsigned int v72 = [v71 globalTraceObjectID];
            uint64_t v73 = (uint64_t)v136[241] + 1;
            v136[241] = (id **)v73;
            GTUSCSamplingStreamingManagerHelper::AddEncoderSamplePoints(v136, a5, v16, v72, v61, v73, v133, 0LL);
          }

          if (v131 && (objc_opt_respondsToSelector(v61, "tileWidth") & 1) != 0)
          {
            *((_DWORD *)v131[1] - 2) = [v61 tileWidth];
            *((_DWORD *)v131[1] - 1) = [v61 tileHeight];
          }

  uint64_t v105 = *(void *)(v16 + 8);
  uint64_t v130 = 1LL;
  unint64_t v106 = *(void *)(*(void *)(*find_entry(v105, &v130, 8uLL, 0LL) + 32LL) + 8LL);
  v142[0] = @"device";
  uint64_t v107 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLongLong:](&OBJC_CLASS___NSNumber, "numberWithUnsignedLongLong:", v106));
  v142[1] = @"object";
  v143[0] = v107;
  v143[1] = v123;
  uint64_t v108 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v143,  v142,  2LL));

  return v108;
}

LABEL_79:
          goto LABEL_80;
        }

        if (v58 == 17)
        {
          unint64_t v79 = (void *)objc_claimAutoreleasedReturnValue([v132 accelerationStructureCommandEncoderForKey:v40]);
          id v80 = DEVICEOBJECT(v79);
          unint64_t v81 = (void *)objc_claimAutoreleasedReturnValue(v80);

          id v67 = v81;
          uint64_t v61 = v67;
          if (!a5) {
            goto LABEL_79;
          }
        }

        else
        {
          if (v58 != 21) {
            goto LABEL_119;
          }
          uint64_t v64 = (void *)objc_claimAutoreleasedReturnValue([v132 blitCommandEncoderForKey:v40]);
          id v65 = DEVICEOBJECT(v64);
          unint64_t v66 = (void *)objc_claimAutoreleasedReturnValue(v65);

          id v67 = v66;
          uint64_t v61 = v67;
          if (!a5) {
            goto LABEL_79;
          }
        }

        unsigned int v82 = [v67 globalTraceObjectID];
        uint64_t v83 = (uint64_t)v136[241] + 1;
        v136[241] = (id **)v83;
        GTUSCSamplingStreamingManagerHelper::AddEncoderSamplePoints(v136, a5, v16, v82, v61, v83, v133, 0LL);
        goto LABEL_79;
      }

      ++a2[3];
LABEL_80:
      objc_autoreleasePoolPop(v6);
      unsigned int v4 = *a1;
      unsigned int v43 = (*a1)->var24.var0 + 1;
      (*a1)->var24.var0 = v43;
    }

    while (var0[13] + var0[12] > v43);
  }

  v4->var24.id var1 = 0;
  unint64_t v45 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v4->var1, "defaultCommandQueue", v46));
  [v45 finish];

  GRCInfo::ScopedReplayConfiguration::~ScopedReplayConfiguration((GRCInfo::ScopedReplayConfiguration *)v51);
}

    uint64_t v48 = [v20 pipelineStateId];
    v209[0] = v14;
    std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long long>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long &&>,std::tuple<>>( (uint64_t)(v22 + 6),  (unint64_t)v14,  v209)[3] = v48;

    ++v15;
    ++v14;
  }

  v194 = (id)objc_claimAutoreleasedReturnValue([v195 objectForKeyedSubscript:@"usc sampling address data"]);
  id v193 = (void *)objc_claimAutoreleasedReturnValue([v195 objectForKeyedSubscript:@"usc sampling sample data"]);
  id v192 = (void *)objc_claimAutoreleasedReturnValue([v195 objectForKeyedSubscript:@"usc sampling address mappings"]);
  uint64_t v50 = -[GTShaderProfilerHelper _shouldUseProgramAddressMappings:](self, "_shouldUseProgramAddressMappings:");
  if (g_runningInCI)
  {
    unint64_t v51 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( NSString,  "stringWithFormat:",  @"In _calculatePerSampleActiveShaders, sample data %lu bytes, address data %lu bytes, address mappings %lu",  [v193 length],  objc_msgSend(v194, "length"),  objc_msgSend(v192, "count")));
    uint64_t v52 = (void *)objc_claimAutoreleasedReturnValue( [v51 stringByReplacingOccurrencesOfString:@"\n" withString:@"\n#CI-INFO# "]);

    unint64_t v53 = __stdoutp;
    uint64_t v54 = v52;
    fprintf(v53, "#CI-INFO# %s\n", (const char *)[v54 UTF8String]);
  }

  if (v194)
  {
    if (v193)
    {
      uint64_t v55 = (void *)objc_claimAutoreleasedReturnValue([v199 drawCallInfoList]);
      uint64_t v56 = [v55 count] == 0;

      if (!v56)
      {
        uint64_t v57 = v194;
        int v58 = (char *)[v57 bytes];
        uint64_t v59 = [v57 length];
        v186 = (id)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"/tmp/com.apple.gputools.profiling/shaderProfilerResults/Frames/1/uscSamplingAddressRaw.txt"));
        id v60 = (void *)objc_claimAutoreleasedReturnValue(+[NSFileManager defaultManager](&OBJC_CLASS___NSFileManager, "defaultManager"));
        uint64_t v61 = (void *)objc_claimAutoreleasedReturnValue([v186 stringByDeletingLastPathComponent]);
        [v60 createDirectoryAtPath:v61 withIntermediateDirectories:1 attributes:0 error:0];

        uint64_t v188 = v186;
        unsigned int v62 = v59 / 0x18;
        -[GTShaderProfilerHelper _saveAddressList:size:filename:]( self,  "_saveAddressList:size:filename:",  v58,  v59 / 0x18uLL,  [v188 UTF8String]);
        uint64_t v63 = (void *)objc_claimAutoreleasedReturnValue([v188 stringByDeletingLastPathComponent]);
        uint64_t v64 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"%@/uscSamplingAddressMapRaw.txt",  v63));

        v185 = v64;
        -[GTShaderProfilerHelper _saveAddressMappings:filename:]( self,  "_saveAddressMappings:filename:",  v192,  [v185 UTF8String]);
        if ((v50 & 1) != 0)
        {
          __int128 v207 = 0u;
          __int128 v208 = 0u;
          BOOL v205 = 0u;
          __int128 v206 = 0u;
          obunsigned int j = v192;
          id v65 = [obj countByEnumeratingWithState:&v205 objects:v221 count:16];
          if (v65)
          {
            unint64_t v66 = *(void *)v206;
            do
            {
              for (unsigned int j = 0LL; j != v65; unsigned int j = (char *)j + 1)
              {
                if (*(void *)v206 != v66) {
                  objc_enumerationMutation(obj);
                }
                uint64_t v68 = *(void **)(*((void *)&v205 + 1) + 8LL * (void)j);
                id v69 = (void *)objc_claimAutoreleasedReturnValue([v68 objectForKeyedSubscript:@"encID"]);
                uint64_t v70 = [v69 unsignedIntValue];

                id v71 = (void *)objc_claimAutoreleasedReturnValue([v68 objectForKeyedSubscript:@"drawCallIndex"]);
                unsigned int v72 = [v71 unsignedIntValue];

                uint64_t v73 = (void *)objc_claimAutoreleasedReturnValue([v68 objectForKeyedSubscript:@"mappedAddress"]);
                uint64_t v74 = [v73 unsignedLongLongValue];

                unsigned int v75 = (void *)objc_claimAutoreleasedReturnValue([v68 objectForKeyedSubscript:@"mappedSize"]);
                id v76 = [v75 unsignedLongLongValue];

                unsigned int v77 = (void *)objc_claimAutoreleasedReturnValue([v68 objectForKeyedSubscript:@"type"]);
                uint64_t v78 = -[GTShaderProfilerHelper _getLegacyProgramType:](self, "_getLegacyProgramType:", v77);
                unint64_t v79 = v78;
                if (v78 < 4 || v78 - 100 <= 1)
                {
                  id v80 = std::__hash_table<std::__hash_value_type<unsigned int,unsigned long long>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,unsigned long long>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,unsigned long long>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,unsigned long long>>>::find<unsigned int>( *(uint64_t *)&v219[0],  *((unint64_t *)&v219[0] + 1),  v70);
                  if (v80)
                  {
                    unint64_t v81 = v80[3];
                    unsigned int v82 = std::unordered_map<unsigned long long,-[GTShaderProfilerHelper _calculatePerSampleActiveShaders:withShaderProfilerResult:forWorkloadInfo:]::EncoderRangeInfo>::find[abi:nn180100]( (uint64_t)__p[0],  (unint64_t)__p[1],  v81);
                    if (v82)
                    {
                      uint64_t v83 = v82;
                      if (v79 <= 3)
                      {
                        v209[0] = (void *)v72;
                        unint64_t v81 = std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long long>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long &&>,std::tuple<>>( (uint64_t)(v82 + 6),  v72,  v209)[3];
                      }

                      id v84 = v76 + v74;
                      id v86 = (unsigned int *)v83[4];
                      id v85 = v83[5];
                      if ((unint64_t)v86 >= v85)
                      {
                        uint64_t v88 = (unsigned int *)v83[3];
                        unint64_t v89 = ((char *)v86 - (char *)v88) >> 4;
                        id v90 = v89 + 1;
                        BOOL v91 = v85 - (void)v88;
                        if (v91 >> 3 > v90) {
                          id v90 = v91 >> 3;
                        }
                        unsigned int v92 = (unint64_t)v91 >= 0x7FFFFFFFFFFFFFF0LL;
                        unint64_t v93 = 0xFFFFFFFFFFFFFFFLL;
                        if (!v92) {
                          unint64_t v93 = v90;
                        }
                        if (v93)
                        {
                          unint64_t v93 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<std::pair<unsigned long long,unsigned long long>>>(v93);
                          uint64_t v88 = (unsigned int *)v83[3];
                          id v86 = (unsigned int *)v83[4];
                        }

                        else
                        {
                          BOOL v94 = 0LL;
                        }

                        uint64_t v95 = (unsigned int *)(v93 + 16 * v89);
                        *uint64_t v95 = v74;
                        v95[1] = v84;
                        v95[2] = v81;
                        v95[3] = v79;
                        uint64_t v96 = v95;
                        if (v86 != v88)
                        {
                          do
                          {
                            *((_OWORD *)v96 - 1) = *((_OWORD *)v86 - 1);
                            v96 -= 4;
                            v86 -= 4;
                          }

                          while (v86 != v88);
                          uint64_t v88 = (unsigned int *)v83[3];
                        }

                        unsigned int v87 = v95 + 4;
                        v83[3] = v96;
                        v83[4] = v95 + 4;
                        v83[5] = v93 + 16 * v94;
                        if (v88) {
                          operator delete(v88);
                        }
                      }

                      else
                      {
                        void *v86 = v74;
                        v86[1] = v84;
                        unsigned int v87 = v86 + 4;
                        v86[2] = v81;
                        v86[3] = v79;
                      }

                      v83[4] = v87;
                    }
                  }
                }
              }

              id v65 = [obj countByEnumeratingWithState:&v205 objects:v221 count:16];
            }

            while (v65);
          }
        }

        else if (v59 >= 0x18)
        {
          uint64_t v97 = 0LL;
          if (v62 <= 1) {
            uint64_t v98 = 1LL;
          }
          else {
            uint64_t v98 = v62;
          }
          do
          {
            unint64_t v99 = &v58[24 * v97];
            if ((*(void *)v99 & *((void *)v99 + 1) & *((void *)v99 + 2)) != -1LL)
            {
              unint64_t v100 = *((_DWORD *)v99 + 1);
              if (v100 != -1)
              {
                unint64_t v101 = *(unsigned int *)v99;
                if ((v101 & 0xFC) == 0 || (*(_DWORD *)v99 & 0xFE) == 0x64)
                {
                  uint64_t v102 = std::__hash_table<std::__hash_value_type<unsigned int,unsigned long long>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,unsigned long long>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,unsigned long long>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,unsigned long long>>>::find<unsigned int>( *(uint64_t *)&v219[0],  *((unint64_t *)&v219[0] + 1),  v100);
                  if (v102)
                  {
                    uint64_t v103 = v102[3];
                    unint64_t v104 = std::unordered_map<unsigned long long,-[GTShaderProfilerHelper _calculatePerSampleActiveShaders:withShaderProfilerResult:forWorkloadInfo:]::EncoderRangeInfo>::find[abi:nn180100]( (uint64_t)__p[0],  (unint64_t)__p[1],  v103);
                    if (v104)
                    {
                      uint64_t v105 = v104;
                      if ((v101 & 0xFC) == 0)
                      {
                        v209[0] = (void *)(v101 >> 8);
                        uint64_t v103 = std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long long>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long &&>,std::tuple<>>( (uint64_t)(v104 + 6),  v101 >> 8,  v209)[3];
                        LOBYTE(v101) = *v99;
                      }

                      unint64_t v106 = (int64x2_t *)&v58[24 * v97 + 8];
                      uint64_t v107 = v101;
                      uint64_t v109 = (int32x2_t *)v105[4];
                      uint64_t v108 = v105[5];
                      if ((unint64_t)v109 >= v108)
                      {
                        uint64_t v111 = (int32x2_t *)v105[3];
                        id v112 = ((char *)v109 - (char *)v111) >> 4;
                        unint64_t v113 = v112 + 1;
                        unint64_t v114 = v108 - (void)v111;
                        if (v114 >> 3 > v113) {
                          unint64_t v113 = v114 >> 3;
                        }
                        else {
                          uint64_t v115 = v113;
                        }
                        if (v115)
                        {
                          uint64_t v115 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<std::pair<unsigned long long,unsigned long long>>>(v115);
                          uint64_t v111 = (int32x2_t *)v105[3];
                          uint64_t v109 = (int32x2_t *)v105[4];
                        }

                        else
                        {
                          id v116 = 0LL;
                        }

                        uint64_t v117 = (int32x2_t *)(v115 + 16 * v112);
                        *uint64_t v117 = vmovn_s64(*v106);
                        v117[1].i32[0] = v103;
                        v117[1].i32[1] = v107;
                        uint64_t v118 = v117;
                        if (v109 != v111)
                        {
                          do
                          {
                            *(_OWORD *)v118[-2].i8 = *(_OWORD *)v109[-2].i8;
                            v118 -= 2;
                            v109 -= 2;
                          }

                          while (v109 != v111);
                          uint64_t v111 = (int32x2_t *)v105[3];
                        }

                        uint64_t v110 = v117 + 2;
                        v105[3] = v118;
                        v105[4] = v117 + 2;
                        v105[5] = v115 + 16 * v116;
                        if (v111) {
                          operator delete(v111);
                        }
                      }

                      else
                      {
                        *uint64_t v109 = vmovn_s64(*v106);
                        v109[1].i32[0] = v103;
                        v109[1].i32[1] = v101;
                        uint64_t v110 = v109 + 2;
                      }

                      v105[4] = v110;
                    }
                  }
                }
              }
            }

            ++v97;
          }

          while (v97 != v98);
        }

        for (uint64_t k = (void *)v215; k; uint64_t k = (void *)*k)
        {
          unint64_t v120 = k[3];
          uint64_t v121 = (char *)k[4];
          unint64_t v122 = 126 - 2 * __clz((uint64_t)&v121[-v120] >> 4);
          else {
            unint64_t v123 = v122;
          }
          std::__introsort<std::_ClassicAlgPolicy,std::__less<void,void> &,std::tuple<unsigned int,unsigned int,unsigned int,unsigned int> *,false>( v120,  v121,  v123,  1);
        }

        BOOL v124 = [v193 length];
        unint64_t v125 = (char *)[v193 bytes];
        *(_OWORD *)__int128 v209 = 0u;
        __int128 v210 = 0u;
        LODWORD(v211) = 1050253722;
        v202 = 0u;
        int v203 = 0u;
        unsigned int v204 = 1050253722;
        if (v124 >= 8)
        {
          uint64_t v127 = v125;
          unint64_t v126 = 0;
          unint64_t v128 = 0;
          uint64_t v129 = v124 >> 3;
          LODWORD(v187) = -1;
          id v183 = v124 >> 3;
          id v184 = v125;
          do
          {
            uint64_t v130 = &v127[8 * v128];
            unint64_t v131 = *(void *)v130;
            if (*(void *)v130 != -1)
            {
              id v132 = std::__hash_table<std::__hash_value_type<unsigned int,unsigned long long>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,unsigned long long>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,unsigned long long>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,unsigned long long>>>::find<unsigned int>( *(uint64_t *)&v219[0],  *((unint64_t *)&v219[0] + 1),  *(void *)v130);
              if (v132)
              {
                uint64_t v133 = v132;
                uint64_t v134 = std::unordered_map<unsigned long long,-[GTShaderProfilerHelper _calculatePerSampleActiveShaders:withShaderProfilerResult:forWorkloadInfo:]::EncoderRangeInfo>::find[abi:nn180100]( (uint64_t)__p[0],  (unint64_t)__p[1],  v132[3]);
                if (v134)
                {
                  uint64_t v135 = v134;
                  if (v134[3] != v134[4])
                  {
                    v201 = v133;
                    id v136 = v131;
                    if ((_DWORD)v187 != v131 >> 39)
                    {
                      std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::clear(&v202);
                      id v136 = *(void *)v130;
                      v187 = *(void *)v130 >> 39;
                    }

                    if ((v136 & 0x7F00000000LL) != 0)
                    {
                      uint64_t v137 = 0LL;
                      do
                      {
                        uint64_t v138 = 0LL;
                        unint64_t v139 = (uint64_t)&v130[32 * v137 + 8];
                        do
                        {
                          if ((*(_DWORD *)(v139 + 4 * v138) & 1) != 0)
                          {
                            ++v138;
                            std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__emplace_unique_key_args<unsigned int,unsigned int const&>( (uint64_t)v209,  *(_DWORD *)(v139 + 4 * v138),  *(_DWORD *)(v139 + 4 * v138));
                          }

                          unsigned int v92 = v138++ >= 7;
                        }

                        while (!v92);
                        ++v137;
                      }

                      while (v137 < (*((_DWORD *)v130 + 1) & 0x7Fu));
                    }

                    id obja = (id)v131;
                    uint64_t v140 = (uint64_t *)v210;
                    for (m = v201; v140; uint64_t v140 = (uint64_t *)*v140)
                    {
                      char v142 = *((_DWORD *)v140 + 4);
                      uint64_t v143 = (_DWORD *)v135[3];
                      BOOL v144 = v135[4] - (void)v143;
                      if (v144)
                      {
                        unint64_t v145 = v144 >> 4;
                        uint64_t v146 = (_DWORD *)v135[3];
                        do
                        {
                          v147 = v145 >> 1;
                          unint64_t v148 = &v146[4 * (v145 >> 1)];
                          if (v142 >= *v148)
                          {
                            if (*v148 >= v142 && v148[1] == -1 && v148[2] == -1)
                            {
                              v147 = v145 + ~v147;
                              uint64_t v146 = v148 + 4;
                            }

                            else
                            {
                              uint64_t v146 = v148 + 4;
                              v147 = v145 + ~v147;
                            }
                          }

                          unint64_t v145 = v147;
                        }

                        while (v147);
                      }

                      else
                      {
                        uint64_t v146 = (_DWORD *)v135[3];
                      }

                      if (v143 == v146) {
                        v149 = 0LL;
                      }
                      else {
                        v149 = -1LL;
                      }
                      v150 = &v146[4 * v149];
                      if (v142 >= *v150 && v142 <= v150[1])
                      {
                        v152 = v150[2] & 0x3FFFFFFF | ((m[3] & 0x3FFFFFFF) << 30) | ((unint64_t)v150[3] << 60);
                        if (std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::find<unsigned long long>( &v202,  v152))
                        {
                          m = v201;
                        }

                        else
                        {
                          v153 = v126;
                          std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__emplace_unique_key_args<unsigned long long,unsigned long long &>( (uint64_t)&v202,  v152,  v152);
                          uint64_t v154 = (void **)&v217[3 * (*(void *)v130 >> 39)];
                          dispatch_semaphore_t v155 = v154 + 1;
                          uint64_t v156 = (unint64_t *)v154[1];
                          id v157 = (unint64_t)v154[2];
                          if ((unint64_t)v156 >= v157)
                          {
                            uint64_t v160 = ((char *)v156 - (_BYTE *)*v154) >> 3;
                            id v161 = v157 - (void)*v154;
                            char v162 = v161 >> 2;
                            else {
                              uint64_t v163 = v162;
                            }
                            if (v163) {
                              uint64_t v163 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<std::pair<unsigned int,unsigned int>>>(v163);
                            }
                            else {
                              unint64_t v164 = 0LL;
                            }
                            uint64_t v165 = (unint64_t *)(v163 + 8 * v160);
                            *uint64_t v165 = v152;
                            unsigned __int8 v158 = v165 + 1;
                            v166 = (char *)*v155;
                            id v167 = (char *)*v154;
                            if (*v155 == *v154)
                            {
                              m = v201;
                            }

                            else
                            {
                              m = v201;
                              do
                              {
                                id v168 = *((void *)v166 - 1);
                                v166 -= 8;
                                *--uint64_t v165 = v168;
                              }

                              while (v166 != v167);
                              v166 = (char *)*v154;
                            }

                            *uint64_t v154 = v165;
                            *dispatch_semaphore_t v155 = v158;
                            v154[2] = (void *)(v163 + 8 * v164);
                            if (v166) {
                              operator delete(v166);
                            }
                            v159 = v153;
                          }

                          else
                          {
                            *uint64_t v156 = v152;
                            unsigned __int8 v158 = v156 + 1;
                            v159 = v153;
                            m = v201;
                          }

                          *dispatch_semaphore_t v155 = v158;
                          unint64_t v126 = v159 + 1;
                        }
                      }
                    }

                    std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::clear(v209);
                    uint64_t v129 = v183;
                    uint64_t v127 = v184;
                    unint64_t v131 = (unint64_t)obja;
                  }
                }
              }
            }

            v128 += ((v131 >> 30) & 0x1FC) + 1;
          }

          while (v128 < v129);
        }

        else
        {
          unint64_t v126 = 0;
        }

        id v169 = [v196 numPeriodicSamples];
        if (v169)
        {
          uint64_t v170 = 8LL * v169;
          id v171 = (char *)operator new(v170);
          bzero(v171, v170);
          id v172 = &v171[v170];
        }

        else
        {
          id v171 = 0LL;
          id v172 = 0LL;
        }

        BOOL v173 = (void *)objc_claimAutoreleasedReturnValue( +[NSMutableData dataWithCapacity:]( &OBJC_CLASS___NSMutableData,  "dataWithCapacity:",  8LL * v126));
        id v174 = v217;
        __int128 v175 = v218;
        if (v217 != v218)
        {
          v176 = 0;
          uint64_t v177 = 0;
          do
          {
            int64x2_t v178 = v176;
            *(_DWORD *)&v171[8 * v176 + 4] = v177;
            unsigned int v179 = v174[1];
            if (*v174 != v179)
            {
              *(_DWORD *)&v171[8 * v178] = (unint64_t)(v179 - *v174) >> 3;
              objc_msgSend(v173, "appendBytes:length:");
              v177 += (v174[1] - *v174) >> 3;
            }

            v176 = v178 + 1;
            v174 += 3;
          }

          while (v174 != v175);
        }

        [v196 setActiveShadersPerPeriodicSample:v173];
        id v181 = (void *)objc_opt_new(&OBJC_CLASS___NSData, v180);
        [v196 setActiveCoreInfoMasksPerPeriodicSample:v181];

        id v182 = (void *)objc_claimAutoreleasedReturnValue( +[NSMutableData dataWithBytes:length:]( &OBJC_CLASS___NSMutableData,  "dataWithBytes:length:",  v171,  v172 - v171));
        [v196 setNumActiveShadersPerPeriodicSample:v182];

        if (v171) {
          operator delete(v171);
        }
        std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long>>>::~__hash_table((uint64_t)&v202);
        std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long>>>::~__hash_table((uint64_t)v209);
      }
    }
  }

  std::unordered_map<unsigned long long,-[GTShaderProfilerHelper _calculatePerSampleActiveShaders:withShaderProfilerResult:forWorkloadInfo:]::EncoderRangeInfo>::~unordered_map[abi:nn180100]((uint64_t)__p);
  v209[0] = &v217;
  std::vector<std::vector<DYMTLEncoderInfo>>::__destroy_vector::operator()[abi:nn180100]((void ***)v209);
  std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long>>>::~__hash_table((uint64_t)v219);
}

      if (++v2 >= *(_DWORD *)(a1 + 112)) {
        goto LABEL_80;
      }
    }

    id v9 = *(void *)(v3 + 8LL * v2);
    if ((_DWORD)v9 == -1)
    {
      id v80 = -1;
      id v10 = *(void *)(v3 + 8LL * v2);
    }

    else
    {
      uint64_t v11 = v2;
      unint64_t v12 = *(void *)(a1 + 80);
      *(_DWORD *)__str = *(void *)(v3 + 8LL * v2);
      id v80 = *((_DWORD *)std::__hash_table<std::__hash_value_type<unsigned int,unsigned int>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,unsigned int>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int &&>,std::tuple<>>( v12,  v9,  __str)
            + 5);
      id v10 = *(void *)(v3 + 8 * v4);
      unsigned __int8 v2 = v11;
    }

    uint64_t v7 = v2 + 1;
    unsigned __int8 v8 = (v9 >> 30) & 0x1FC;
    unint64_t v79 = v10 >> 39;
    v2 += v8;
LABEL_14:
    if ((v8 & 3) == 0 && v8 >= 4)
    {
      unsigned int v75 = v2;
      unint64_t v13 = 0;
      size_t v14 = v8 >> 2;
      unsigned int v77 = v8 >> 2;
      uint64_t v78 = v7;
      do
      {
        id v15 = 0LL;
        uint64_t v16 = 0LL;
        id v17 = *(_DWORD *)(a1 + 116);
        id v18 = *(void *)(a1 + 72);
        do
        {
          id v19 = v18 + 8LL * (((v7 + 4 * v13) % v17 + v16) % v17);
          uint64_t v20 = &__str[v15];
          *(_DWORD *)uint64_t v20 = *(void *)v19;
          *((_DWORD *)v20 + 1) = *(_DWORD *)(v19 + 4);
          ++v16;
          v15 += 8LL;
        }

        while (v15 != 32);
        if ((__str[0] & 0xF) == 1)
        {
          unsigned int v82 = 0LL;
          uint64_t v83 = 0LL;
          id v84 = 0LL;
          [*(id *)(a1 + 32) _processTracePackets:__str forRenderIndex:v80 andGenerateSampleList:&v82 forTargetIndex:*(unsigned int *)(a1 + 120) forLimiterIndex:v79];
          if ([*(id *)(a1 + 32) dumpInstructions])
          {
            uint64_t v21 = *(void **)(a1 + 32);
            unsigned int v22 = *(void *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 48LL);
            ++*(_DWORD *)(v22 + 4LL * *(unsigned int *)(a1 + 104));
            objc_msgSend( v21,  "_dumpTraceBufferPacketsInFile:usingTracePackets:withExtractedSamples:withTraceBufferCount:forTargetIndex:",  v76,  __str,  &v82);
            BOOL v24 = v82;
            BOOL v23 = v83;
            unsigned int v25 = *(void *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 48LL);
            *(_DWORD *)(v25 + 4LL * *(unsigned int *)(a1 + 104)) -= 858993459
                                                                  * ((unint64_t)((char *)v83 - (char *)v82) >> 3);
          }

          else
          {
            BOOL v24 = v82;
            BOOL v23 = v83;
          }

          if (v24 != v23)
          {
            do
            {
              BOOL v26 = *(_DWORD *)v24;
              if (*(_DWORD *)v24 != -1 || *((_DWORD *)v24 + 3) == -1)
              {
                uint64_t v28 = *(_DWORD *)(a1 + 124);
                id v29 = v26 >= v28;
                id v30 = v26 - v28;
                if (v29 && *(void *)(a1 + 88) > v30)
                {
                  unint64_t v31 = *(_DWORD *)(**(void **)(a1 + 96) + 4 * v30);
                  unint64_t v81 = v31;
                  if (v31 != -1)
                  {
                    if (*(_BYTE *)(a1 + 128))
                    {
                      unint64_t v31 = *((_DWORD *)std::__hash_table<std::__hash_value_type<unsigned int,unsigned int>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,unsigned int>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>( *(void *)(a1 + 80),  v31,  &v81)
                            + 5);
                      uint64_t v28 = *(_DWORD *)(a1 + 124);
                    }

                    id v29 = v31 >= v28;
                    id v32 = v31 - v28;
                    if (v29 && *(void *)(a1 + 88) > v32)
                    {
                      unint64_t v35 = (void **)(v33 + 1);
                      id v34 = v33[1];
                      uint64_t v37 = v33 + 2;
                      unint64_t v36 = v33[2];
                      if (v34 >= v36)
                      {
                        uint64_t v61 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v34 - *v33) >> 3);
                        unsigned int v62 = v61 + 1;
                        if (v61 + 1 > 0x666666666666666LL) {
                          abort();
                        }
                        uint64_t v63 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v36 - *v33) >> 3);
                        if (2 * v63 > v62) {
                          unsigned int v62 = 2 * v63;
                        }
                        if (v63 >= 0x333333333333333LL) {
                          uint64_t v64 = 0x666666666666666LL;
                        }
                        else {
                          uint64_t v64 = v62;
                        }
                        if (v64) {
                          uint64_t v64 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<ShaderProfilerUSCSampleInfo>>(v64);
                        }
                        else {
                          id v65 = 0LL;
                        }
                        unint64_t v66 = v64 + 40 * v61;
                        id v67 = *v24;
                        uint64_t v68 = v24[1];
                        *(void *)(v66 + 32) = *((void *)v24 + 4);
                        *(_OWORD *)unint64_t v66 = v67;
                        *(_OWORD *)(v66 + 16) = v68;
                        id v69 = (char *)*v35;
                        uint64_t v70 = (char *)*v33;
                        id v71 = v66;
                        if (*v35 != (void *)*v33)
                        {
                          do
                          {
                            unsigned int v72 = *(_OWORD *)(v69 - 40);
                            uint64_t v73 = *(_OWORD *)(v69 - 24);
                            *(void *)(v71 - _Block_object_dispose(&STACK[0x3B0], 8) = *((void *)v69 - 1);
                            *(_OWORD *)(v71 - 24) = v73;
                            *(_OWORD *)(v71 - 40) = v72;
                            v71 -= 40LL;
                            v69 -= 40;
                          }

                          while (v69 != v70);
                          id v69 = (char *)*v33;
                        }

                        int32x2_t *v33 = v71;
                        uint64_t v40 = (void *)(v66 + 40);
                        void *v35 = (void *)(v66 + 40);
                        *uint64_t v37 = v64 + 40 * v65;
                        if (v69) {
                          operator delete(v69);
                        }
                      }

                      else
                      {
                        unint64_t v38 = *v24;
                        unsigned int v39 = v24[1];
                        *(void *)(v34 + 32) = *((void *)v24 + 4);
                        *(_OWORD *)id v34 = v38;
                        *(_OWORD *)(v34 + 16) = v39;
                        uint64_t v40 = (void *)(v34 + 40);
                      }

                      void *v35 = v40;
                    }
                  }
                }
              }

              else
              {
                id v41 = *(void **)(*(void *)(a1 + 56) + 8LL);
                unint64_t v42 = v41[7];
                unsigned int v43 = v41[8];
                if (v42 >= v43)
                {
                  unint64_t v47 = v41[6];
                  uint64_t v48 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v42 - v47) >> 3);
                  uint64_t v49 = v48 + 1;
                  if (v48 + 1 > 0x666666666666666LL) {
                    abort();
                  }
                  uint64_t v50 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v43 - v47) >> 3);
                  if (2 * v50 > v49) {
                    uint64_t v49 = 2 * v50;
                  }
                  if (v50 >= 0x333333333333333LL) {
                    unint64_t v51 = 0x666666666666666LL;
                  }
                  else {
                    unint64_t v51 = v49;
                  }
                  if (v51) {
                    unint64_t v51 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<ShaderProfilerUSCSampleInfo>>(v51);
                  }
                  else {
                    uint64_t v52 = 0LL;
                  }
                  unint64_t v53 = v51 + 40 * v48;
                  uint64_t v54 = *v24;
                  uint64_t v55 = v24[1];
                  *(void *)(v53 + 32) = *((void *)v24 + 4);
                  *(_OWORD *)unint64_t v53 = v54;
                  *(_OWORD *)(v53 + 16) = v55;
                  uint64_t v57 = (char *)v41[6];
                  uint64_t v56 = (char *)v41[7];
                  int v58 = v53;
                  if (v56 != v57)
                  {
                    do
                    {
                      uint64_t v59 = *(_OWORD *)(v56 - 40);
                      id v60 = *(_OWORD *)(v56 - 24);
                      *(void *)(v58 - _Block_object_dispose(&STACK[0x3B0], 8) = *((void *)v56 - 1);
                      *(_OWORD *)(v58 - 24) = v60;
                      *(_OWORD *)(v58 - 40) = v59;
                      v58 -= 40LL;
                      v56 -= 40;
                    }

                    while (v56 != v57);
                    uint64_t v56 = (char *)v41[6];
                  }

                  BOOL v46 = v53 + 40;
                  v41[6] = v58;
                  v41[7] = v53 + 40;
                  v41[8] = v51 + 40 * v52;
                  if (v56) {
                    operator delete(v56);
                  }
                }

                else
                {
                  uint64_t v44 = *v24;
                  unint64_t v45 = v24[1];
                  *(void *)(v42 + 32) = *((void *)v24 + 4);
                  *(_OWORD *)unint64_t v42 = v44;
                  *(_OWORD *)(v42 + 16) = v45;
                  BOOL v46 = v42 + 40;
                }

                v41[7] = v46;
              }

              BOOL v24 = (_OWORD *)((char *)v24 + 40);
            }

            while (v24 != v23);
            BOOL v23 = v82;
          }

          if (v23)
          {
            uint64_t v83 = v23;
            operator delete(v23);
          }

          size_t v14 = v77;
          uint64_t v7 = v78;
        }

        ++v13;
      }

      while (v13 != v14);
      unsigned __int8 v2 = v75;
    }

    goto LABEL_79;
  }

    goto LABEL_80;
  }

LABEL_124:
      objc_autoreleasePoolPop(context);
      unint64_t v123 = *v14 + 1;
      unsigned int *v14 = v123;
    }

    while (v13[13] + v13[12] > v123);
  }

  [v124 finish];

  ScopedReplayConfiguration::~ScopedReplayConfiguration((ScopedReplayConfiguration *)v143);
}

                unsigned int v22 = v104 + 1;
                v18 += 4;
                if (v104 + 1 >= (*(_DWORD *)(v103 + 8 * v102 + 4) & 0x7Fu))
                {
                  id v10 = *(void *)(a1 + 72);
                  uint64_t v11 = *(void *)(a1 + 80);
                  uint64_t v20 = *(_DWORD *)(v11 + 8 * v10 + 4);
                  goto LABEL_126;
                }

                goto LABEL_21;
              }

              BOOL v46 = 1;
            }

            LODWORD(v132) = v138[++v45];
          }

          else if ((v138[v45] & 3) == 2)
          {
            id v136 = (v47 >> 5) & 0xFFF;
            uint64_t v137 = (v47 >> 2) & 7;
            std::deque<ProfileEvent>::emplace_back<unsigned int &,unsigned int &>(v106, &v136, &v137);
            if ((v46 & 1) != 0)
            {
              if (((v47 >> 5) & 0xFFF) <= 1) {
                uint64_t v48 = 1;
              }
              else {
                uint64_t v48 = (v47 >> 5) & 0xFFF;
              }
              HIDWORD(v132) = v48;
            }

            uint64_t v134 = v47 >> 20;
            uint64_t v135 = (v47 >> 17) & 7;
            std::deque<ProfileEvent>::emplace_back<unsigned int &,unsigned int &>(v106, &v134, &v135);
            BOOL v46 = 0;
          }

          uint64_t v49 = v45++ >= 7;
          if (v49) {
            goto LABEL_75;
          }
        }
      }

      unsigned int v39 = 512LL;
    }

    *(void *)&uint64_t v109 = v39;
    goto LABEL_52;
  }

void sub_6B08C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, void *a12, uint64_t a13, uint64_t a14, void *a15, uint64_t a16, void *a17, uint64_t a18, void *a19, uint64_t a20, void *a21)
{
  ScopedReplayConfiguration::~ScopedReplayConfiguration((ScopedReplayConfiguration *)(v24 - 112));
  _Unwind_Resume(a1);
}

id GTUSCSamplingStreamingManagerHelper::DrainRawDerivedCounterData(id *this)
{
  if ([this[3] count])
  {
    id v15 = (void *)objc_claimAutoreleasedReturnValue( +[NSMutableArray arrayWithCapacity:]( NSMutableArray,  "arrayWithCapacity:",  [this[3] count]));
    for (unint64_t i = 0LL; ; ++i)
    {
      if (i >= (unint64_t)[this[3] count])
      {
        id v13 = v15;
        goto LABEL_17;
      }

      id v3 = (void *)objc_claimAutoreleasedReturnValue([this[3] objectAtIndexedSubscript:i]);
      unsigned int v4 = (void *)objc_claimAutoreleasedReturnValue( +[NSMutableArray arrayWithCapacity:]( NSMutableArray,  "arrayWithCapacity:",  [v3 ringBufferNum]));
LABEL_15:
    }

    for (uint64_t j = 0LL; ; uint64_t j = (j + 1))
    {
      if (j >= [v3 ringBufferNum])
      {
        [v15 addObject:v4];
        goto LABEL_15;
      }

      if (([v3 ringBufferInfoAtIndex:j base:&v19 size:&v18 dataOffset:&v17 dataSize:&v16] & 1) == 0) {
        break;
      }
      id v6 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableData dataWithCapacity:](&OBJC_CLASS___NSMutableData, "dataWithCapacity:", v16));
      uint64_t v7 = v6;
      unsigned int v8 = v16;
      if (v16 + v17 <= v18)
      {
        [v6 appendBytes:v19 + v17 length:v16];
      }

      else
      {
        unsigned int v9 = v18 - v17;
        [v6 appendBytes:v19 + v17 length:v18 - v17];
        [v7 appendBytes:v19 length:v8 - v9];
      }

      unsigned int v10 = [v3 drainRingBufferAtIndex:j dataSize:v16];
      if (v10 != v16)
      {
        uint64_t v11 = (void *)objc_claimAutoreleasedReturnValue([v3 name]);
        NSLog(@"Fail, unexpected drain count for source %@!", v11);
      }

      [v4 addObject:v7];
    }

    unint64_t v12 = (void *)objc_claimAutoreleasedReturnValue([v3 name]);
    NSLog(@"Fail, unable to retrieve ring buffer info from source %@!", v12);

    id v13 = 0LL;
LABEL_17:
  }

  else
  {
    id v13 = 0LL;
  }

  return v13;
}

void sub_6B4A8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11)
{
  _Unwind_Resume(a1);
}

void GTUSCSamplingStreamingManagerHelper::GatherCommandBufferRestoreInfo(uint64_t **this)
{
  uint64_t v2 = **this;
  id v3 = *(void **)v2;
  unsigned int v4 = (_DWORD *)(v2 + 22480);
  if (*(void *)(*(void *)v2 + 104LL) + *(void *)(*(void *)v2 + 96LL) > (unint64_t)*(unsigned int *)(v2 + 22480))
  {
    while (1)
    {
      id v5 = objc_autoreleasePoolPush();
      uint64_t v6 = *(void *)(v3[15] + 24LL) + ((unint64_t)*v4 << 6);
      int v7 = GetFuncEnumConstructorType(*(_DWORD *)(v6 + 8)) == 25
         ? GTMTLReplayController_restoreCommandBuffer(v2, v6)
         : 0;
      GTMTLReplayController_updateCommandEncoder(v2, v6);
      if (*(_DWORD *)(v6 + 8) >> 2 == 1073737833) {
        break;
      }
      GTMTLReplayController_defaultDispatchFunction(**this, v6);
      if (v7) {
        goto LABEL_9;
      }
LABEL_10:
      objc_autoreleasePoolPop(v5);
      unint64_t v8 = (*v4 + 1);
      *unsigned int v4 = v8;
      if (v3[13] + v3[12] <= v8)
      {
        uint64_t v2 = **this;
        goto LABEL_12;
      }
    }

    GTMTLReplayController_executeCommandsInBuffer((uint64_t *)v2, (unint64_t *)v6, 0LL, 0xFFFFFFFFFFFFFFFFLL);
    if (!v7) {
      goto LABEL_10;
    }
LABEL_9:
    std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__emplace_unique_key_args<unsigned long long,unsigned long long>( (uint64_t)(this + 281),  *v4,  *v4);
    goto LABEL_10;
  }

void std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__emplace_unique_key_args<unsigned long long,unsigned long long>( uint64_t a1, unint64_t a2, uint64_t a3)
{
  unint64_t v7 = *(void *)(a1 + 8);
  if (v7)
  {
    uint8x8_t v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      unint64_t v3 = a2;
      if (v7 <= a2) {
        unint64_t v3 = a2 % v7;
      }
    }

    else
    {
      unint64_t v3 = (v7 - 1) & a2;
    }

    unsigned int v9 = *(void **)(*(void *)a1 + 8 * v3);
    if (v9)
    {
      for (unint64_t i = (void *)*v9; i; unint64_t i = (void *)*i)
      {
        unint64_t v11 = i[1];
        if (v11 == a2)
        {
          if (i[2] == a2) {
            return;
          }
        }

        else
        {
          if (v8.u32[0] > 1uLL)
          {
            if (v11 >= v7) {
              v11 %= v7;
            }
          }

          else
          {
            v11 &= v7 - 1;
          }

          if (v11 != v3) {
            break;
          }
        }
      }
    }
  }

  unint64_t v12 = operator new(0x18uLL);
  void *v12 = 0LL;
  v12[1] = a2;
  v12[2] = a3;
  float v13 = (float)(unint64_t)(*(void *)(a1 + 24) + 1LL);
  float v14 = *(float *)(a1 + 32);
  if (!v7 || (float)(v14 * (float)v7) < v13)
  {
    BOOL v15 = 1LL;
    if (v7 >= 3) {
      BOOL v15 = (v7 & (v7 - 1)) != 0;
    }
    unint64_t v16 = v15 | (2 * v7);
    unint64_t v17 = vcvtps_u32_f32(v13 / v14);
    if (v16 <= v17) {
      size_t v18 = v17;
    }
    else {
      size_t v18 = v16;
    }
    std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__rehash<true>( a1,  v18);
    unint64_t v7 = *(void *)(a1 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v7 <= a2) {
        unint64_t v3 = a2 % v7;
      }
      else {
        unint64_t v3 = a2;
      }
    }

    else
    {
      unint64_t v3 = (v7 - 1) & a2;
    }
  }

  uint64_t v19 = *(void *)a1;
  uint64_t v20 = *(void **)(*(void *)a1 + 8 * v3);
  if (v20)
  {
    void *v12 = *v20;
LABEL_38:
    *uint64_t v20 = v12;
    goto LABEL_39;
  }

  void *v12 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = v12;
  *(void *)(v19 + 8 * v3) = a1 + 16;
  if (*v12)
  {
    unint64_t v21 = *(void *)(*v12 + 8LL);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v21 >= v7) {
        v21 %= v7;
      }
    }

    else
    {
      v21 &= v7 - 1;
    }

    uint64_t v20 = (void *)(*(void *)a1 + 8 * v21);
    goto LABEL_38;
  }

void sub_6B84C(_Unwind_Exception *a1)
{
}

void GTUSCSamplingStreamingManagerHelper::SetupBuffersForAPSSource( GTUSCSamplingStreamingManagerHelper *this)
{
  if ((_DWORD)qword_5B9550 != -1)
  {
    [*((id *)&xmmword_5B8CE0 + 1) count];
    uint64_t v1 = 0LL;
    if ([*((id *)&xmmword_5B8CE0 + 1) count])
    {
      unint64_t v2 = 0LL;
      do
      {
        unint64_t v3 = (void *)objc_claimAutoreleasedReturnValue([*((id *)&xmmword_5B8CE0 + 1) objectAtIndexedSubscript:v2]);
        for (unint64_t i = 0; i < (unint64_t)[&off_59F860 count]; ++i)
        {
          id v5 = (void *)objc_claimAutoreleasedReturnValue([v3 name]);
          uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue([&off_59F860 objectAtIndexedSubscript:i]);
          unsigned int v7 = [v5 isEqualToString:v6];

          if (v7)
          {
            uint8x8_t v8 = (char *)&GTUSCSamplingStreamingManagerHelper::Instance(void)::instance + 8 * v1++;
            *((void *)v8 + 38_Block_object_dispose(&STACK[0x3B0], 8) = v2;
          }
        }

        ++v2;
      }

      while (v2 < (unint64_t)[*((id *)&xmmword_5B8CE0 + 1) count]);
    }

    std::vector<std::vector<GTMMappedBuffer>>::reserve(&xmmword_5B9600, v1 + 1);
    std::vector<std::vector<GTMMappedBuffer>>::reserve(&qword_5B95E8, v1 + 1);
    std::vector<std::vector<GTMMappedBuffer>>::reserve(&xmmword_5B9630, v1 + 1);
    std::vector<std::vector<NSObject  {objcproto21OS_dispatch_semaphore}* {__strong}>>::reserve(&qword_5B9648, v1 + 1);
    std::vector<std::vector<NSObject  {objcproto21OS_dispatch_semaphore}* {__strong}>>::reserve(&xmmword_5B9660, v1 + 1);
    std::vector<NSObject  {objcproto21OS_dispatch_semaphore}* {__strong}>::reserve( (void *)&xmmword_5B9670 + 1,  v1 + 1);
    *(void *)unint64_t v16 = (int)qword_5B9550;
    *(_OWORD *)&v16[8] = xmmword_5B98F0;
    unsigned int v9 = std::__allocate_at_least[abi:nn180100]<std::allocator<std::pair<unsigned int,unsigned int>>>(3uLL);
    uint64_t v10 = 0LL;
    *(_OWORD *)unsigned int v9 = *(_OWORD *)v16;
    v9[2] = *(void *)&v16[16];
    do
    {
      unint64_t v11 = (GTUSCSamplingStreamingManagerHelper *)v9[v10];
      if (v11 != (GTUSCSamplingStreamingManagerHelper *)-1LL) {
        GTUSCSamplingStreamingManagerHelper::SetupBufferForSourceAtIndex( v11,  v11 != (GTUSCSamplingStreamingManagerHelper *)(int)qword_5B9550);
      }
      ++v10;
    }

    while (v10 != 3);
    dispatch_semaphore_t v12 = dispatch_semaphore_create(0LL);
    float v13 = (void *)xmmword_5B96A0;
    *(void *)&xmmword_5B96A0 = v12;

    dispatch_semaphore_t v14 = dispatch_semaphore_create(0LL);
    BOOL v15 = (void *)*((void *)&xmmword_5B9690 + 1);
    *((void *)&xmmword_5B9690 + 1) = v14;

    if (v9) {
      operator delete(v9);
    }
  }

void sub_6BAC0(_Unwind_Exception *a1)
{
}

char *std::vector<unsigned long>::__vallocate[abi:nn180100](void *a1, unint64_t a2)
{
  if (a2 >> 61) {
    abort();
  }
  __n128 result = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<std::pair<unsigned int,unsigned int>>>(a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[8 * v4];
  return result;
}

void GTUSCSamplingStreamingManagerHelper::ForceDrainAllSourceBuffers( GTUSCSamplingStreamingManagerHelper *this)
{
  __int128 v7 = 0u;
  __int128 v8 = 0u;
  __int128 v9 = 0u;
  __int128 v10 = 0u;
  uint64_t v1 = this;
  id v2 = -[GTUSCSamplingStreamingManagerHelper countByEnumeratingWithState:objects:count:]( v1,  "countByEnumeratingWithState:objects:count:",  &v7,  v11,  16LL);
  if (v2)
  {
    uint64_t v3 = *(void *)v8;
    do
    {
      uint64_t v4 = 0LL;
      do
      {
        if (*(void *)v8 != v3) {
          objc_enumerationMutation(v1);
        }
        uint64_t v5 = 0LL;
        uint64_t v6 = *(void **)(*((void *)&v7 + 1) + 8LL * (void)v4);
        while (v5 < objc_msgSend(v6, "ringBufferNum", (void)v7))
        {
          uint64_t v5 = (v5 + 1);
        }

        uint64_t v4 = (char *)v4 + 1;
      }

      while (v4 != v2);
      id v2 = -[GTUSCSamplingStreamingManagerHelper countByEnumeratingWithState:objects:count:]( v1,  "countByEnumeratingWithState:objects:count:",  &v7,  v11,  16LL);
    }

    while (v2);
  }
}

void sub_6BC5C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t GTUSCSamplingStreamingManagerHelper::DrainAllSourceBuffers(uint64_t this, uint64_t a2)
{
  if (this != a2)
  {
    uint64_t v3 = this;
    do
    {
      uint64_t v4 = *(dispatch_semaphore_s ***)v3;
      uint64_t v5 = *(dispatch_semaphore_s ***)(v3 + 8);
      while (v4 != v5)
      {
        uint64_t v6 = *v4++;
        this = dispatch_semaphore_signal(v6);
      }

      v3 += 24LL;
    }

    while (v3 != a2);
  }

  return this;
}

void GTUSCSamplingStreamingManagerHelper::PollAndDrainSourceRingBuffer( GTUSCSamplingStreamingManagerHelper *this, unsigned int a2, unsigned int a3)
{
  uint64_t v5 = (unsigned int *)((char *)this + 2752);
  do
    unsigned int v6 = __ldaxr(v5);
  while (__stlxr(v6 + 1, v5));
  else {
    unsigned int v7 = a2 + 1;
  }
  if (*((_DWORD *)this + 544) != -1)
  {
    if (a2 == 2)
    {
      __int128 v8 = (char *)this + 3112;
    }

    else
    {
      if (a2 != 1) {
        goto LABEL_12;
      }
      __int128 v8 = (char *)this + 3104;
    }

    unsigned int v7 = *(_DWORD *)v8;
  }

LABEL_35:
      unsigned __int8 v30 = atomic_load((unsigned __int8 *)this + 2763);
      if ((v30 & 1) != 0) {
        goto LABEL_40;
      }
    }

    uint64_t v18 = *(void *)(*((void *)this + 294) + 24LL * a2);
    uint64_t v19 = (void *)objc_claimAutoreleasedReturnValue([*((id *)this + 3) objectAtIndexedSubscript:v34]);
    unsigned __int8 v20 = atomic_load((unsigned __int8 *)this + 2760);
    id v21 = v19;
    if (![v21 isEnabled]
      || ([v21 ringBufferInfoAtIndex:a3 base:&v39 size:&v38 dataOffset:&v37 dataSize:&v36] & 1) == 0 || !v36 || !(v20 & 1 | (v36 >> 13)))
    {
      goto LABEL_27;
    }

    unsigned int v22 = (dispatch_semaphore_t *)(v18 + 120LL * a3);
    if (v37 + v36 <= v38) {
      GTMMappedBuffer::MemcpyFromSourceBuffer(v22, &v39[v37], v36, 0LL, 0);
    }
    else {
      GTMMappedBuffer::MemcpyFromSourceBuffer(v22, &v39[v37], v38 - v37, v39, v36 - (v38 - v37));
    }
    unsigned int v23 = [v21 drainRingBufferAtIndex:a3 dataSize:v36];
    unsigned int v24 = v36;
    if (v23 || !v36)
    {

      if (v24)
      {
        do
          unsigned int v31 = __ldaxr((unsigned int *)this + 685);
        while (__stlxr(v31 + 1, (unsigned int *)this + 685));
LABEL_30:
        dispatch_semaphore_signal(*(dispatch_semaphore_t *)(*(void *)(*((void *)this + 306) + 24LL * a2) + 8LL * a3));
LABEL_31:
        if (!v16)
        {
          do
          {
            unsigned int v28 = __ldaxr(v10);
            unsigned int v29 = v28 + 1;
          }

          while (__stlxr(v29, v10));
          if (v29 == *((_DWORD *)this + 541)) {
            std::condition_variable::notify_all((std::condition_variable *)((char *)this + 2768));
          }
        }

        goto LABEL_35;
      }
    }

    else
    {
LABEL_27:
    }

    unsigned __int8 v25 = atomic_load((unsigned __int8 *)this + 2760);
    if ((v25 & 1) == 0) {
      goto LABEL_31;
    }
    unsigned int v26 = atomic_load((unsigned int *)this + 685);
    unsigned int v27 = atomic_load((unsigned int *)this + 686);
    if (v26 != v27) {
      goto LABEL_31;
    }
    goto LABEL_30;
  }

  do
LABEL_40:
    unsigned int v32 = __ldaxr(v5);
  while (__stlxr(v32 - 1, v5));
  if (!atomic_load(v5)) {
    std::condition_variable::notify_all((std::condition_variable *)((char *)this + 2992));
  }
}

  return v7;
}

      uint64_t v33 = 0;
      LOBYTE(v27) = 0;
      uint64_t v34 = 0;
      unint64_t v35 = 0;
      unsigned int v36 = 0LL;
      unsigned __int8 v30 = 0LL;
LABEL_36:
      if ((_DWORD)a4)
      {
        int v37 = v65 + v17;
        *(void *)int v37 = v30;
        *(void *)(v37 + _Block_object_dispose(&STACK[0x3B0], 8) = v36;
        *(_DWORD *)(v37 + 16) = v35;
        *(_WORD *)(v37 + 20) = 0;
        *(_WORD *)(v37 + 22) = v34;
        *(_BYTE *)(v37 + 24) = v27;
        *(_BYTE *)(v37 + 25) = v33;
        *(_DWORD *)(v37 + 26) = v76;
        *(_WORD *)(v37 + 30) = v77;
      }

      v17 += 32LL;
      if (v66 == v17)
      {
        uint64_t v16 = v60;
        a1 = v61;
        goto LABEL_97;
      }
    }
  }

    uint64_t v18 = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 13), a2);
    unsigned int v24 = *a3;
    unsigned __int8 v25 = *((void *)v18 + 2);
    *((void *)v5 + 1) = *((void *)v18 + 1);
    *((void *)v5 + 2) = v24;
    *((_DWORD *)v5 + 1) = *((_DWORD *)a3 + 2);
    *((_WORD *)v5 + 4_Block_object_dispose(&STACK[0x3B0], 8) = *((void *)v18 + 3);
    *((void *)v5 + 13) = v25;
    __n128 result = GTTraceFunc_argumentBytesWithMap(a3, *((unsigned __int8 *)a3 + 14), a2);
    *((void *)v5 + 19) = result;
    if (result)
    {
      unsigned int v26 = *((void *)result + 1);
      *((void *)v5 + 7) = *(void *)result;
      unsigned int v27 = *((_DWORD *)result + 4);
      *((_DWORD *)v5 + 21) = v26;
      *((_DWORD *)v5 + 22) = v27;
      *((void *)v5 + 14) = *((void *)result + 3);
      *((_OWORD *)v5 + _Block_object_dispose(&STACK[0x3B0], 8) = *((_OWORD *)result + 2);
    }

void sub_6BFA4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void *DynamicBuffer::AddBuffer2( DynamicBuffer *this, const unsigned __int8 *__src, const unsigned __int8 *a3)
{
  unsigned int v6 = (os_unfair_lock_s *)((char *)this + 16);
  while (1)
  {
    uint64_t v7 = *((void *)this + 1);
    unsigned __int8 v9 = (void *)*((void *)this + 3);
    __int128 v8 = (void *)*((void *)this + 4);
    if (v7 == 0xAAAAAAAAAAAAAAABLL * (v8 - v9))
    {
      unint64_t v10 = *((void *)this + 5);
      if ((unint64_t)v8 >= v10)
      {
        unint64_t v12 = v7 + 1;
        unint64_t v13 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v10 - (void)v9) >> 3);
        if (2 * v13 > v12) {
          unint64_t v12 = 2 * v13;
        }
        if (v13 >= 0x555555555555555LL) {
          unint64_t v14 = 0xAAAAAAAAAAAAAAALL;
        }
        else {
          unint64_t v14 = v12;
        }
        if (v14)
        {
          if (v14 > 0xAAAAAAAAAAAAAAALL) {
            std::__throw_bad_array_new_length[abi:nn180100]();
          }
          unsigned __int8 v15 = (char *)operator new(24 * v14);
        }

        else
        {
          unsigned __int8 v15 = 0LL;
        }

        uint64_t v16 = &v15[24 * v7];
        *(void *)uint64_t v16 = 0LL;
        *((void *)v16 + 1) = 0LL;
        *((void *)v16 + 2) = 0x1000000LL;
        unsigned __int8 v17 = v16;
        if (v8 != v9)
        {
          do
          {
            __int128 v18 = *(_OWORD *)(v8 - 3);
            *((void *)v17 - 1) = *(v8 - 1);
            *(_OWORD *)(v17 - 24) = v18;
            v17 -= 24;
            v8 -= 3;
          }

          while (v8 != v9);
          __int128 v8 = (void *)*((void *)this + 3);
        }

        unsigned __int8 v11 = v16 + 24;
        *((void *)this + 3) = v17;
        *((void *)this + 4) = v16 + 24;
        *((void *)this + 5) = &v15[24 * v14];
        if (v8) {
          operator delete(v8);
        }
      }

      else
      {
        *__int128 v8 = 0LL;
        v8[1] = 0LL;
        unsigned __int8 v11 = v8 + 3;
        v8[2] = 0x1000000LL;
      }

      *((void *)this + 4) = v11;
      else {
        size_t v19 = (size_t)a3;
      }
      *(v11 - 1) = v19;
      *(v11 - 3) = malloc(v19);
      *(v11 - 2) = 0LL;
      uint64_t v7 = *((void *)this + 1);
      unsigned __int8 v9 = (void *)*((void *)this + 3);
    }

    unsigned __int8 v20 = &v9[3 * v7];
    uint64_t v21 = v20[1];
    unint64_t v22 = 0x1000000 - v21;
    size_t v23 = 0x1000000 - v21 >= (unint64_t)a3 ? (size_t)a3 : 0x1000000 - v21;
    __n128 result = memcpy((void *)(*v20 + v21), __src, v23);
    v20[1] += v23;
    unsigned __int8 v25 = &a3[-v23];
    os_unfair_lock_lock(v6);
    ++*((void *)this + 1);
    os_unfair_lock_unlock(v6);
    __src = (const unsigned __int8 *)(&a3[(void)__src] - v25);
    a3 = v25;
  }

  return result;
}

void *GTMMappedBuffer::MemcpyFromSourceBuffer( dispatch_semaphore_t *this, unsigned __int8 *a2, unsigned int a3, unsigned __int8 *a4, unsigned int a5)
{
  unsigned int v10 = a5 + a3;
  __n128 result = GTMMappedBuffer::Allocate(this, a5 + a3);
  if (result)
  {
    unint64_t v12 = result;
    unint64_t v13 = result + 4096;
    memcpy(result + 4096, a2, a3);
    memcpy((char *)v13 + a3, a4, a5);
    dispatch_semaphore_wait(*this, 0xFFFFFFFFFFFFFFFFLL);
    unint64_t v14 = (char *)this[8];
    unsigned __int8 v15 = (char *)this[7];
    if (v14 == v15) {
      uint64_t v16 = 0LL;
    }
    else {
      uint64_t v16 = 170 * ((v14 - v15) >> 3) - 1;
    }
    unint64_t v17 = (unint64_t)this[10];
    unint64_t v18 = (unint64_t)this[11] + v17;
    if (v16 != v18) {
      goto LABEL_47;
    }
    size_t v19 = this + 6;
    if (v17 < 0xAA)
    {
      unint64_t v33 = (v14 - v15) >> 3;
      dispatch_semaphore_t v34 = this[9];
      dispatch_semaphore_t v35 = this[6];
      if (v33 >= (v34 - v35) >> 3)
      {
        if (v34 == v35) {
          unint64_t v36 = 1LL;
        }
        else {
          unint64_t v36 = (v34 - v35) >> 2;
        }
        id v76 = (char *)(this + 9);
        *(void *)&__int128 v74 = std::__allocate_at_least[abi:nn180100]<std::allocator<std::pair<unsigned int,unsigned int>>>(v36);
        *((void *)&v74 + 1) = v74 + 8 * v33;
        *(void *)&__int128 v75 = *((void *)&v74 + 1);
        *((void *)&v75 + 1) = v74 + 8 * v37;
        uint64_t v73 = operator new(0xFF0uLL);
        std::__split_buffer<GTMMappedBuffer::UsedBlock *>::push_back(&v74, &v73);
        for (unint64_t i = this[8];
              i != (void *)this[7];
              std::__split_buffer<GTMMappedBuffer::UsedBlock *>::push_front((uint64_t)&v74, i))
        {
          --i;
        }

        __int128 v40 = v74;
        __int128 v41 = v75;
        *(void *)&__int128 v74 = this[6];
        unsigned int v39 = (void *)v74;
        *((void *)&v74 + 1) = i;
        *((_OWORD *)this + 3) = v40;
        *((_OWORD *)this + 4) = v41;
        if (v39) {
          operator delete(v39);
        }
        goto LABEL_46;
      }

      if (v34 != (dispatch_semaphore_t)v14)
      {
        *(void *)&__int128 v74 = operator new(0xFF0uLL);
        std::__split_buffer<GTMMappedBuffer::UsedBlock *>::push_back(this + 6, &v74);
LABEL_46:
        unsigned __int8 v15 = (char *)this[7];
        unint64_t v18 = (unint64_t)this[10] + (void)this[11];
LABEL_47:
        unint64_t v65 = *(void *)&v15[8 * (v18 / 0xAA)] + 24 * (v18 % 0xAA);
        *(void *)unint64_t v65 = v12;
        *(void *)(v65 + _Block_object_dispose(&STACK[0x3B0], 8) = v13;
        *(_DWORD *)(v65 + 16) = v10;
        this[11] = (dispatch_semaphore_t)((char *)this[11] + 1);
        return (void *)dispatch_semaphore_signal(*this);
      }

      *(void *)&__int128 v74 = operator new(0xFF0uLL);
      std::__split_buffer<GTMMappedBuffer::UsedBlock *>::push_front((uint64_t)(this + 6), &v74);
      unint64_t v53 = this[7];
      unint64_t v14 = (char *)this[8];
      uint64_t v55 = *v53;
      uint64_t v54 = (dispatch_semaphore_s *)(v53 + 1);
      uint64_t v21 = v55;
      this[7] = v54;
      if (v14 == (char *)this[9])
      {
        uint64_t v56 = (uint64_t)v54 - *v19;
        if ((unint64_t)v54 > *v19)
        {
          uint64_t v57 = v56 >> 3;
          BOOL v25 = v56 >> 3 < -1;
          uint64_t v58 = (v56 >> 3) + 2;
          if (v25) {
            uint64_t v59 = v58;
          }
          else {
            uint64_t v59 = v57 + 1;
          }
          uint64_t v60 = -(v59 >> 1);
          uint64_t v61 = v59 >> 1;
          unsigned int v62 = (char *)v54 - 8 * v61;
          int64_t v63 = v14 - (char *)v54;
          if (v14 != (char *)v54)
          {
            memmove((char *)v54 - 8 * v61, v54, v14 - (char *)v54);
            uint64_t v54 = this[7];
          }

          unint64_t v14 = &v62[v63];
          uint64_t v64 = (dispatch_semaphore_s *)((char *)v54 + 8 * v60);
          goto LABEL_44;
        }

        else {
          unint64_t v66 = (uint64_t)&v14[-*v19] >> 2;
        }
        unsigned int v43 = (dispatch_semaphore_s *)std::__allocate_at_least[abi:nn180100]<std::allocator<std::pair<unsigned int,unsigned int>>>(v66);
        uint64_t v44 = (char *)v43 + 8 * (v66 >> 2);
        BOOL v46 = (dispatch_semaphore_s *)((char *)v43 + 8 * v67);
        uint64_t v68 = this[7];
        unint64_t v14 = v44;
        uint64_t v69 = this[8] - v68;
        if (v69)
        {
          unint64_t v14 = &v44[v69 & 0xFFFFFFFFFFFFFFF8LL];
          uint64_t v70 = 8 * (v69 >> 3);
          id v71 = (void *)((char *)v43 + 8 * (v66 >> 2));
          do
          {
            uint64_t v72 = *(void *)v68;
            uint64_t v68 = (dispatch_semaphore_s *)((char *)v68 + 8);
            *v71++ = v72;
            v70 -= 8LL;
          }

          while (v70);
        }

LABEL_32:
        dispatch_semaphore_t v52 = this[6];
        this[6] = v43;
        this[7] = (dispatch_semaphore_t)v44;
        this[8] = (dispatch_semaphore_t)v14;
        this[9] = v46;
        if (v52)
        {
          operator delete(v52);
          unint64_t v14 = (char *)this[8];
        }
      }
    }

    else
    {
      this[10] = (dispatch_semaphore_t)(v17 - 170);
      uint64_t v22 = *(void *)v15;
      unsigned __int8 v20 = (dispatch_semaphore_s *)(v15 + 8);
      uint64_t v21 = v22;
      this[7] = v20;
      if (this[9] == (dispatch_semaphore_t)v14)
      {
        uint64_t v23 = (uint64_t)v20 - *v19;
        if ((unint64_t)v20 > *v19)
        {
          uint64_t v24 = v23 >> 3;
          BOOL v25 = v23 >> 3 < -1;
          uint64_t v26 = (v23 >> 3) + 2;
          if (v25) {
            uint64_t v27 = v26;
          }
          else {
            uint64_t v27 = v24 + 1;
          }
          uint64_t v28 = -(v27 >> 1);
          uint64_t v29 = v27 >> 1;
          unsigned __int8 v30 = (char *)v20 - 8 * v29;
          int64_t v31 = v14 - (char *)v20;
          if (v14 == (char *)v20)
          {
            dispatch_semaphore_t v32 = (dispatch_semaphore_t)v14;
          }

          else
          {
            memmove((char *)v20 - 8 * v29, v20, v14 - (char *)v20);
            dispatch_semaphore_t v32 = this[7];
          }

          unint64_t v14 = &v30[v31];
          uint64_t v64 = (dispatch_semaphore_t)((char *)v32 + 8 * v28);
LABEL_44:
          this[7] = v64;
          this[8] = (dispatch_semaphore_t)v14;
          goto LABEL_45;
        }

        else {
          unint64_t v42 = (uint64_t)&v14[-*v19] >> 2;
        }
        unsigned int v43 = (dispatch_semaphore_s *)std::__allocate_at_least[abi:nn180100]<std::allocator<std::pair<unsigned int,unsigned int>>>(v42);
        uint64_t v44 = (char *)v43 + 8 * (v42 >> 2);
        BOOL v46 = (dispatch_semaphore_s *)((char *)v43 + 8 * v45);
        unint64_t v47 = this[7];
        unint64_t v14 = v44;
        uint64_t v48 = this[8] - v47;
        if (v48)
        {
          unint64_t v14 = &v44[v48 & 0xFFFFFFFFFFFFFFF8LL];
          uint64_t v49 = 8 * (v48 >> 3);
          uint64_t v50 = (void *)((char *)v43 + 8 * (v42 >> 2));
          do
          {
            uint64_t v51 = *(void *)v47;
            unint64_t v47 = (dispatch_semaphore_s *)((char *)v47 + 8);
            *v50++ = v51;
            v49 -= 8LL;
          }

          while (v49);
        }

        goto LABEL_32;
      }
    }

    unint64_t v47 = (mach_absolute_time() - v66) * info.numer / info.denom;
    uint64_t v48 = atomic_load(v85 + 24);
    uint64_t v50 = (v48 & 1) == 0 && v47 > 0x3B9AC9FF;
    uint64_t v51 = v85 + 24;
    atomic_store(v50, v85 + 24);
    if (v70 == 1199) {
      break;
    }
    unsigned int v10 = v70 + 1;
    dispatch_semaphore_t v52 = atomic_load(v51);
  }

  while ((v52 & 1) == 0);
  dispatch_source_cancel(source);
  [v62 unmapShaderSampleBuffer];
  -[NSMutableData setLength:](v71, "setLength:", v76);
  v89[0] = @"usc sampling sample data";
  unint64_t v53 = objc_alloc(&OBJC_CLASS___NSData);
  uint64_t v54 = -[NSData initWithBytesNoCopy:length:deallocator:]( v53,  "initWithBytesNoCopy:length:deallocator:",  address,  v61,  &__block_literal_global_791);
  v90[0] = v54;
  v89[1] = @"usc sampling address mappings";
  uint64_t v55 = (void *)objc_claimAutoreleasedReturnValue(-[ProgramAddressTableCollector mappings](v72, "mappings"));
  v89[2] = @"usc sampling address data";
  v90[1] = v55;
  v90[2] = v71;
  uint64_t v56 = objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v90,  v89,  3LL));

  std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long>>>::~__hash_table((uint64_t)v82);
  _Block_object_dispose(&v84, 8);

  uint64_t v57 = *(void *)(*(void *)(a1 + 40) + 8LL);
  uint64_t v58 = *(void **)(v57 + 40);
  *(void *)(v57 + 40) = v56;
}

      uint64_t v24 = GTTraceFunc_argumentBytesWithMap((void *)v21, *(unsigned __int8 *)(v20 + (v18 << 6) + 13), v17) + 8;
    }

    else
    {
      if (v22 != -7156 && v22 != -7157 && v22 != -7158) {
        goto LABEL_38;
      }
      uint64_t v24 = GTTraceFunc_argumentBytesWithMap((void *)v21, *(unsigned __int8 *)(v20 + (v18 << 6) + 13), v17);
    }

    uint64_t v28 = GTMTLSMContext_getObject(**(void **)(v16 + 40), *(void *)v24, *(void *)v21);
    if (v28)
    {
      uint64_t v27 = v28[6];
      goto LABEL_35;
    }

    goto LABEL_38;
  }

        goto LABEL_33;
      }

      objc_autoreleasePoolPop(context);
      unint64_t v53 = *v8 + 1;
      *__int128 v8 = v53;
    }

    while (v53 < *(_DWORD *)(*(void *)(v3 + 120) + 12LL));
  }

  v67[0] = @"Draw ID -> PipelineState ID";
  v67[1] = @"PipelineState ID";
  v68[0] = v61;
  v68[1] = v60;
  uint64_t v54 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v68,  v67,  2LL));

  return v54;
}

        v191 = 1;
      }

      if (v20 == 46)
      {
        uint64_t v26 = *((unsigned __int8 *)v11 + 1);
        if ((v26 - 48) > 9)
        {
          unint64_t v17 = 0;
          if ((char)v26 == 42)
          {
            unsigned int v39 = v196;
            v196 += 8;
            v11 += 2;
            v189 = *v39 & ~((int)*v39 >> 31);
          }

          else
          {
            v189 = 0LL;
            ++v11;
          }
        }

        else
        {
          uint64_t v28 = *((unsigned __int8 *)v11 + 2);
          v11 += 2;
          uint64_t v27 = v28;
          v189 = (char)v26 - 48LL;
          if ((v28 - 48) <= 9)
          {
            uint64_t v29 = (char)v26 - 48LL;
            do
            {
              unsigned __int8 v30 = *(unsigned __int8 *)++v11;
              uint64_t v29 = 10 * v29 + v27 - 48;
              uint64_t v27 = v30;
            }

            while ((v30 - 48) < 0xA);
            v189 = v29;
          }

          unint64_t v17 = 0;
        }
      }

      else
      {
        unint64_t v17 = 1;
      }

LABEL_45:
    *(void *)unint64_t v14 = v21;
    this[8] = (dispatch_semaphore_t)((char *)this[8] + 8);
    goto LABEL_46;
  }

  return result;
}

                Object = GTMTLSMContext_getObject( **(void **)(*(void *)a1 + 40LL),  *v30,  *(void *)(*(void *)a1 + 80LL) + a2);
                if ((!Object[15] || *(_DWORD *)(a1 + 11312) != 28) && (!Object[16] || *(_DWORD *)(a1 + 11312) != 70)) {
                  goto LABEL_50;
                }
LABEL_49:
                v19[v27++] = [v24 resourceForKey:*v30];
                goto LABEL_50;
              }

              if (v31 == 80)
              {
                unint64_t v47 = v28;
                dispatch_semaphore_t v34 = v29;
                dispatch_semaphore_t v35 = v22;
                unint64_t v36 = (void *)objc_claimAutoreleasedReturnValue([v24 textureForKey:*v30]);

                uint64_t v22 = v35;
                uint64_t v29 = v34;
                uint64_t v24 = v46;
                uint64_t v28 = v47;
                goto LABEL_50;
              }

              if (v31 == 83) {
                goto LABEL_45;
              }
LABEL_50:
              uint64_t v26 = apr_hash_next(v26);
              if (!v26)
              {
                if ((_DWORD)v28)
                {
                  uint64_t v37 = (void *)objc_claimAutoreleasedReturnValue([v24 commandBufferForKey:*(void *)(a1 + 11352)]);
                  [v37 useResidencySets:v22 count:(int)v28];
                }

                unint64_t v17 = v44;
                unsigned int v38 = v45;
LABEL_60:
                unsigned int v39 = v38 - v29;
                __int128 v40 = (unint64_t)(v38 - v29) >> 3;
                __int128 v41 = *(_DWORD *)(a1 + 11312);
                switch(v41)
                {
                  case 17:
                    unsigned int v43 = objc_claimAutoreleasedReturnValue([v24 accelerationStructureCommandEncoderForKey:*(void *)(a1 + 11320)]);
                    break;
                  case 28:
                    unsigned int v43 = objc_claimAutoreleasedReturnValue([v24 computeCommandEncoderForKey:*(void *)(a1 + 11320)]);
                    break;
                  case 70:
                    unint64_t v42 = (void *)objc_claimAutoreleasedReturnValue([v24 renderCommandEncoderForKey:*(void *)(a1 + 11320)]);
                    if (!v27)
                    {
LABEL_69:
                      if ((_DWORD)v40) {
                        [v42 useHeaps:v29 count:(int)(v39 >> 3)];
                      }

LABEL_72:
                      apr_pool_clear(v17);
                      _restoreIndirectResourceUsage(a1, a2);

                      return;
                    }

  ++*(void *)(a1 + 24);
}

void sub_6C564( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void *GTMMappedBuffer::Allocate(dispatch_semaphore_t *this, unsigned int a2)
{
  dispatch_semaphore_t v4 = this[12];
  dispatch_semaphore_t v5 = this[13];
  if (v4 == v5)
  {
LABEL_7:
    __int128 v8 = 0LL;
  }

  else
  {
    unsigned int v6 = a2;
    while (1)
    {
      unsigned int v7 = *((_DWORD *)v4 + 6);
      if (*((_DWORD *)v4 + 5) == v7)
      {
        unsigned int v7 = 0;
        *((_DWORD *)v4 + 5) = 0;
        *((_DWORD *)v4 + 6) = 0;
      }

      dispatch_semaphore_t v4 = (dispatch_semaphore_t)((char *)v4 + 32);
      if (v4 == v5) {
        goto LABEL_7;
      }
    }

    unsigned __int8 v9 = (unint64_t *)(*((void *)v4 + 1) + v7);
    unint64_t *v9 = (v6 + 8) | ((unint64_t)*(void *)v4 << 32) | 0xCADDAC0000000000LL;
    __int128 v8 = v9 + 1;
    *((_DWORD *)v4 + 6) += v6 + 8;
  }

  dispatch_semaphore_signal(this[1]);
  return v8;
}

void GTUSCSamplingStreamingManagerHelper::PostProcessRawData( GTUSCSamplingStreamingManagerHelper *this, unsigned int a2, unsigned int a3)
{
  uint64_t v137 = (unsigned int *)((char *)this + 2752);
  do
    unsigned int v4 = __ldaxr(v137);
  while (__stlxr(v4 + 1, (unsigned int *)this + 688));
  else {
    unsigned int v5 = a2 + 1;
  }
  if (*((_DWORD *)this + 544) != -1)
  {
    if (a2 == 2)
    {
      unsigned int v6 = (char *)this + 3112;
    }

    else
    {
      if (a2 != 1) {
        goto LABEL_12;
      }
      unsigned int v6 = (char *)this + 3104;
    }

    unsigned int v5 = *(_DWORD *)v6;
  }

void sub_6D314( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, void *a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, void **a35, uint64_t a36, id a37, uint64_t a38, uint64_t a39, uint64_t a40, uint64_t a41, uint64_t a42, uint64_t a43, uint64_t a44, char a45, uint64_t a46, uint64_t a47, uint64_t a48, uint64_t a49)
{
  std::deque<GTMMappedBuffer::UsedBlock>::~deque[abi:nn180100](&a39);
  a35 = (void **)&a45;
  std::vector<std::tuple<unsigned char *,unsigned long long,NSMutableData * {__strong}>>::__destroy_vector::operator()[abi:nn180100](&a35);
  std::deque<GTMMappedBuffer::UsedBlock>::~deque[abi:nn180100](&a49);

  _Unwind_Resume(a1);
}

uint64_t GTMMappedBuffer::Deallocate(uint64_t this, unsigned __int8 *a2)
{
  if (a2)
  {
    uint64_t v2 = this;
    if (*(void *)(this + 96) != *(void *)(this + 104))
    {
      if (*(_DWORD *)(this + 36))
      {
        this = dispatch_semaphore_wait(*(dispatch_semaphore_t *)(this + 8), 0xFFFFFFFFFFFFFFFFLL);
        unint64_t v6 = *((void *)a2 - 1);
        unsigned int v5 = a2 - 8;
        unint64_t v4 = v6;
        if (v6 >> 40 == 13295020)
        {
          uint64_t v7 = *(void *)(v2 + 96);
          if (BYTE4(v4) < (unint64_t)((*(void *)(v2 + 104) - v7) >> 5))
          {
            uint64_t v8 = v7 + 32LL * BYTE4(v4);
            uint64_t v9 = (uint64_t)&v5[-*(void *)(v8 + 8)];
            return dispatch_semaphore_signal(*(dispatch_semaphore_t *)(v2 + 8));
          }
        }
      }
    }
  }

  return this;
}

void GTMMappedBuffer::PostProcessRawDataFromSource( void *a1, dispatch_semaphore_t *a2, void *a3, uint64_t a4, uint64_t a5, void *a6, uint64_t a7, char a8)
{
  id v15 = a3;
  a1[1] = 0LL;
  a1[2] = 0LL;
  *a1 = 0LL;
  if (a5)
  {
    if (((8 * a5 / 5uLL + 7) & 0x7FFFFFFFFFFFFFF8LL) <= 0x4000) {
      unint64_t v16 = 0x4000LL;
    }
    else {
      unint64_t v16 = (8 * a5 / 5uLL + 7) & 0x7FFFFFFFFFFFFFF8LL;
    }
    unint64_t v17 = GTMMappedBuffer::Allocate(a2, v16);
    *a6 = v17;
    if (v17)
    {
      id v18 = v17;
LABEL_9:
      ++GTMMappedBuffer::PostProcessRawDataFromSource(objc_object  {objcproto19GPURawCounterSource}*,unsigned char *,unsigned long long,unsigned long long,objc_object  {objcproto19GPURawCounterSource}*&,unsigned int,BOOL)::ppData;
      uint64_t v23 = 0LL;
      uint64_t v24 = 0LL;
      LOBYTE(v21) = a8;
      [v15 postProcessRawDataWithRingBufferIndex:a7 source:a4 sourceSize:a5 + 8 sourceRead:&v24 sourceWrite:a5 output:v18 outputSize:v16 outputRead:0 outputWrite:&v23 isLast:v21];
      unint64_t v20 = (a5 + 8 + v24) / (unint64_t)(a5 + 8) * (a5 + 8) - (v24 + 8);
      *a1 = v23;
      a1[1] = v20;
      goto LABEL_10;
    }

    context = objc_autoreleasePoolPush();
    uint64_t v19 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableData dataWithLength:](&OBJC_CLASS___NSMutableData, "dataWithLength:", v16));
    a1[2] = v19;
    objc_autoreleasePoolPop(context);
    if (v19)
    {
      id v18 = [v19 mutableBytes];
      *a6 = v18;
      goto LABEL_9;
    }
  }

LABEL_10:
}

    [v5 setObject:*((void *)begin + 17) forKeyedSubscript:*((void *)begin + 3)];
    begiunint64_t n = (GTPerfStateGroup *)((char *)begin + 152);
  }

  while (begin != end);
  if ((v8 & 1) != 0)
  {
    unint64_t v33 = 0LL;
    id v15 = objc_claimAutoreleasedReturnValue( +[NSKeyedArchiver archivedDataWithRootObject:requiringSecureCoding:error:]( &OBJC_CLASS___NSKeyedArchiver,  "archivedDataWithRootObject:requiringSecureCoding:error:",  v5,  1LL,  &v33));
    unint64_t v16 = v33;
    unint64_t v29 = (void *)v15;
    [v4 setObject:v15 forKeyedSubscript:@"Group Counters"];
    unint64_t v17 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedInt:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedInt:",  self->_timebaseInfo.numer));
    v34[0] = v17;
    id v18 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedInt:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedInt:",  self->_timebaseInfo.denom));
    v34[1] = v18;
    uint64_t v19 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", v34, 2LL));

    unsigned __int8 v32 = v16;
    unint64_t v20 = (void *)objc_claimAutoreleasedReturnValue( +[NSKeyedArchiver archivedDataWithRootObject:requiringSecureCoding:error:]( &OBJC_CLASS___NSKeyedArchiver,  "archivedDataWithRootObject:requiringSecureCoding:error:",  v19,  1LL,  &v32));
    uint64_t v21 = v32;

    [v4 setObject:v20 forKeyedSubscript:@"Time Base Info"];
    socBlockBandwidths = self->_socBlockBandwidths;
    unint64_t v31 = v21;
    uint64_t v23 = (void *)objc_claimAutoreleasedReturnValue( +[NSKeyedArchiver archivedDataWithRootObject:requiringSecureCoding:error:]( &OBJC_CLASS___NSKeyedArchiver,  "archivedDataWithRootObject:requiringSecureCoding:error:",  socBlockBandwidths,  1LL,  &v31));
    uint64_t v24 = v31;

    [v4 setObject:v23 forKeyedSubscript:@"BW Info"];
    configVariables = self->_configVariables;
    int v30 = v24;
    uint64_t v26 = (void *)objc_claimAutoreleasedReturnValue( +[NSKeyedArchiver archivedDataWithRootObject:requiringSecureCoding:error:]( &OBJC_CLASS___NSKeyedArchiver,  "archivedDataWithRootObject:requiringSecureCoding:error:",  configVariables,  1LL,  &v30));
    unint64_t v27 = v30;

    [v4 setObject:v26 forKeyedSubscript:@"Configuration"];
  }

  uint64_t v12 = (void *)objc_claimAutoreleasedReturnValue([v7 device]);
  uint64_t v13 = [v12 newTextureWithDescriptor:v10];

  if (v13)
  {
    uint64_t v36 = v10;
    uint64_t v37 = v9;
    dispatch_semaphore_t v35 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 8) defaultCommandQueue]);
    uint64_t v14 = (void *)objc_claimAutoreleasedReturnValue([v35 commandBuffer]);
    id v15 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"%@.%@",  @"com.apple.gputools.replay",  @"GenerateOutlineTexture"));
    [v14 setLabel:v15];

    unint64_t v16 = (void *)objc_claimAutoreleasedReturnValue([v14 computeCommandEncoder]);
    unint64_t v17 = [v7 sampleCount];
    id v18 = 7LL;
    [v16 setComputePipelineState:a2[v18]];
    unsigned int v38 = (unint64_t)[a2[7] threadExecutionWidth];
    uint64_t v19 = (unint64_t)[a2[7] maxTotalThreadsPerThreadgroup];
    unint64_t v20 = [v7 width];
    uint64_t v21 = [v7 height];
    if ([v7 arrayLength])
    {
      uint64_t v22 = 0LL;
      uint64_t v23 = v19 / v38;
      uint64_t v24 = ((unint64_t)v20 + v38 - 1) / v38;
      unsigned __int8 v25 = ((unint64_t)v21 + v23 - 1) / v23;
      do
      {
        uint64_t v26 = [v7 pixelFormat];
        else {
          unint64_t v27 = 2LL;
        }
        unint64_t v28 = objc_msgSend( v7,  "newTextureViewWithPixelFormat:textureType:levels:slices:",  v26,  v27,  0,  objc_msgSend(v7, "mipmapLevelCount"),  v22,  1);
        unint64_t v29 = objc_msgSend( v13,  "newTextureViewWithPixelFormat:textureType:levels:slices:",  objc_msgSend(v13, "pixelFormat"),  2,  0,  objc_msgSend(v13, "mipmapLevelCount"),  v22,  1);
        [v16 setTexture:v28 atIndex:0];
        [v16 setTexture:v29 atIndex:1];
        v40[0] = v24;
        v40[1] = v25;
        v40[2] = 1LL;
        v39[0] = v38;
        v39[1] = v23;
        v39[2] = 1LL;
        [v16 dispatchThreadgroups:v40 threadsPerThreadgroup:v39];

        ++v22;
      }

      while (v22 < (unint64_t)[v7 arrayLength]);
    }

    [v16 endEncoding];
    GTMTLReplay_commitCommandBuffer(v14);
    int v30 = v13;

    unsigned __int8 v10 = v36;
    uint64_t v9 = v37;
    unint64_t v31 = v35;
  }

  else
  {
    id v42 = @"GTErrorKeyMTLTextureDescriptor";
    unsigned __int8 v43 = v10;
    unint64_t v31 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v43,  &v42,  1LL));
    GTMTLReplay_fillError(a3, 101, v31);
    if (a3) {
      unsigned __int8 v32 = *a3;
    }
    else {
      unsigned __int8 v32 = 0LL;
    }
    GTMTLReplay_handleNSError(v32);
  }

LABEL_30:
  return v13;
}

        uint64_t v7 = -1LL;
      }

      unsigned __int8 v10 = v7 + v4;
      if (v8 > 79)
      {
        if (v8 == 86) {
          goto LABEL_19;
        }
        if (v8 == 80)
        {
          uint64_t v9 = *(unsigned __int16 *)(v5 + 60);
          goto LABEL_22;
        }
      }

      else if (v8 == 22 || v8 == 57)
      {
        uint64_t v9 = 1LL;
        goto LABEL_22;
      }

      uint64_t v9 = 0LL;
LABEL_22:
      unint64_t v4 = (v10 & -v9) + RequestSize(v5);
      if (v4 > 0x2000000) {
        return v6;
      }
      ++v6;
      v5 += 64LL;
    }
  }

  return 1LL;
}

  return v5;
}

void sub_6D63C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t std::__split_buffer<std::tuple<unsigned char *,unsigned long long,NSMutableData * {__strong}>>::~__split_buffer( uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 24;
  }

  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

uint64_t ___ZN35GTUSCSamplingStreamingManagerHelper18PostProcessRawDataEjj_block_invoke( uint64_t result, unsigned __int8 *a2)
{
  uint64_t v2 = *(void *)(result + 32);
  uint64_t v3 = *(void *)(v2 + 2400);
  uint64_t v4 = *(void *)(v2 + 2408);
  if (v3 != v4)
  {
    unint64_t v5 = *(unsigned int *)(result + 40);
    if (0xAAAAAAAAAAAAAAABLL * ((v4 - v3) >> 3) > v5)
    {
      unint64_t v6 = *(unsigned int *)(result + 44);
      uint64_t v8 = (uint64_t *)(v3 + 24LL * v5);
      uint64_t v7 = *v8;
      if (0xEEEEEEEEEEEEEEEFLL * ((v8[1] - *v8) >> 3) < v6) {
        return GTMMappedBuffer::Deallocate(v7 + 120LL * v6, a2);
      }
    }
  }

  return result;
}

void std::vector<std::tuple<unsigned char *,unsigned long long,NSMutableData * {__strong}>>::__destroy_vector::operator()[abi:nn180100]( void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = (id *)**a1;
  if (v2)
  {
    uint64_t v4 = (id *)v1[1];
    unint64_t v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        unint64_t v6 = v4 - 3;

        uint64_t v4 = v6;
      }

      while (v6 != v2);
      unint64_t v5 = **a1;
    }

    v1[1] = v2;
    operator delete(v5);
  }

void GTUSCSamplingStreamingManagerHelper::SignalAndWaitForAllThreadsToTerminate( GTUSCSamplingStreamingManagerHelper *this)
{
  uint64_t v1 = qword_5B9648;
  uint64_t v2 = xmmword_5B9650;
  while (v1 != v2)
  {
    uint64_t v3 = *(dispatch_semaphore_s ***)v1;
    uint64_t v4 = *(dispatch_semaphore_s ***)(v1 + 8);
    while (v3 != v4)
    {
      unint64_t v5 = *v3++;
      dispatch_semaphore_signal(v5);
    }

    v1 += 24LL;
  }

  uint64_t v7 = (dispatch_semaphore_s ***)*((void *)&xmmword_5B9660 + 1);
  for (uint64_t i = (dispatch_semaphore_s ***)xmmword_5B9660; i != v7; i += 3)
  {
    uint64_t v8 = *i;
    uint64_t v9 = i[1];
    while (v8 != v9)
    {
      unsigned __int8 v10 = *v8++;
      dispatch_semaphore_signal(v10);
    }
  }

  v12.__m_ = (std::unique_lock<std::mutex>::mutex_type *)&qword_5B9840;
  v12.__owns_ = 1;
  std::mutex::lock((std::mutex *)&qword_5B9840);
  if (v12.__owns_) {
    std::mutex::unlock(v12.__m_);
  }
}

uint64_t std::__thread_proxy[abi:nn180100]<std::tuple<std::unique_ptr<std::__thread_struct>,GTUSCSamplingStreamingManagerHelper::StartBackgroundProcessingThreads(void)::$_0>>( uint64_t a1)
{
  uint64_t v2 = std::__thread_local_data();
  uint64_t v3 = *(std::__thread_struct **)a1;
  *(void *)a1 = 0LL;
  pthread_setspecific(v2->__key_, v3);
  GTUSCSamplingStreamingManagerHelper::PollAndDrainSourceRingBuffer( *(GTUSCSamplingStreamingManagerHelper **)(a1 + 8),  *(_DWORD *)(a1 + 16),  *(_DWORD *)(a1 + 20));
  std::unique_ptr<std::__thread_struct>::reset[abi:nn180100]((std::__thread_struct **)a1);
  operator delete((void *)a1);
  return 0LL;
}

void sub_6D8C0(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

std::__thread_struct ***std::unique_ptr<std::tuple<std::unique_ptr<std::__thread_struct>,GTUSCSamplingStreamingManagerHelper::StartBackgroundProcessingThreads(void)::$_0>>::~unique_ptr[abi:nn180100]( std::__thread_struct ***a1)
{
  uint64_t v2 = *a1;
  *a1 = 0LL;
  if (v2)
  {
    std::unique_ptr<std::__thread_struct>::reset[abi:nn180100](v2);
    operator delete(v2);
  }

  return a1;
}

uint64_t std::__thread_proxy[abi:nn180100]<std::tuple<std::unique_ptr<std::__thread_struct>,GTUSCSamplingStreamingManagerHelper::StartBackgroundProcessingThreads(void)::$_1>>( uint64_t a1)
{
  uint64_t v2 = std::__thread_local_data();
  uint64_t v3 = *(std::__thread_struct **)a1;
  *(void *)a1 = 0LL;
  pthread_setspecific(v2->__key_, v3);
  GTUSCSamplingStreamingManagerHelper::PostProcessRawData( *(GTUSCSamplingStreamingManagerHelper **)(a1 + 8),  *(_DWORD *)(a1 + 16),  *(_DWORD *)(a1 + 20));
  std::unique_ptr<std::__thread_struct>::reset[abi:nn180100]((std::__thread_struct **)a1);
  operator delete((void *)a1);
  return 0LL;
}

void sub_6D96C(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

void std::unique_ptr<std::__thread_struct>::reset[abi:nn180100](std::__thread_struct **a1)
{
  uint64_t v2 = *a1;
  *a1 = 0LL;
  if (v2)
  {
    std::__thread_struct::~__thread_struct(v2);
    operator delete(v3);
  }

void GTUSCSamplingStreamingManagerHelper::InitForPreSamplingWait(GTUSCSamplingStreamingManagerHelper *this)
{
  if (!*(_DWORD *)(*(void *)this + 72LL))
  {
    dispatch_semaphore_t v2 = dispatch_semaphore_create(0LL);
    uint64_t v3 = (void *)*((void *)this + 315);
    *((void *)this + 315) = v2;

    dispatch_semaphore_t v4 = dispatch_semaphore_create(0LL);
    unint64_t v5 = (void *)*((void *)this + 316);
    *((void *)this + 316) = v4;

    unint64_t v6 = (std::__thread_struct *)operator new(8uLL);
    std::__thread_struct::__thread_struct(v6);
    uint64_t v7 = operator new(0x10uLL);
    *uint64_t v7 = v6;
    v7[1] = this;
    sched_param v10 = (sched_param)v7;
    int v8 = pthread_create( &v9,  0LL,  (void *(__cdecl *)(void *))std::__thread_proxy[abi:nn180100]<std::tuple<std::unique_ptr<std::__thread_struct>,GTUSCSamplingStreamingManagerHelper::InitForPreSamplingWait(void)::$_0>>,  v7);
    if (v8)
    {
      std::__throw_system_error(v8, "thread constructor failed");
      __break(1u);
    }

    else
    {
      v10.sched_priority = sched_get_priority_max(2);
      pthread_setschedparam(v9, 2, &v10);
      std::thread::detach((std::thread *)&v9);
      std::thread::~thread((std::thread *)&v9);
    }
  }

void sub_6DA7C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
}

uint64_t std::__thread_proxy[abi:nn180100]<std::tuple<std::unique_ptr<std::__thread_struct>,GTUSCSamplingStreamingManagerHelper::InitForPreSamplingWait(void)::$_0>>( uint64_t a1)
{
  dispatch_semaphore_t v2 = std::__thread_local_data();
  uint64_t v3 = *(std::__thread_struct **)a1;
  *(void *)a1 = 0LL;
  pthread_setspecific(v2->__key_, v3);
  uint64_t v4 = *(void *)(a1 + 8);
  while (1)
  {
    unsigned __int8 v5 = atomic_load((unsigned __int8 *)(v4 + 2761));
    if ((v5 & 1) != 0) {
      break;
    }
    unsigned __int8 v6 = atomic_load((unsigned __int8 *)(v4 + 2764));
    if ((v6 & 1) != 0) {
      break;
    }
    uint64_t v7 = *(dispatch_semaphore_s **)(v4 + 2520);
    dispatch_time_t v8 = dispatch_time(0LL, 250000LL);
    if (!dispatch_semaphore_wait(v7, v8)) {
      break;
    }
    unsigned __int8 v9 = atomic_load((unsigned __int8 *)(v4 + 2762));
    if ((v9 & 1) != 0) {
      GTUSCSamplingStreamingManagerHelper::ForceDrainAllSourceBuffers(*(GTUSCSamplingStreamingManagerHelper **)(v4 + 24));
    }
  }

  atomic_store(0, (unsigned __int8 *)(v4 + 2762));
  dispatch_semaphore_signal(*(dispatch_semaphore_t *)(v4 + 2528));
  if (a1)
  {
    std::unique_ptr<std::__thread_struct>::reset[abi:nn180100]((std::__thread_struct **)a1);
    operator delete((void *)a1);
  }

  return 0LL;
}

void sub_6DB80(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

unsigned __int8 *GTUSCSamplingStreamingManagerHelper::WaitForPreSampling(unsigned __int8 *this)
{
  if (!*(_DWORD *)(*(void *)this + 72LL))
  {
    uint64_t v1 = this;
    atomic_store(1u, this + 2762);
    usleep(0x30D40u);
    dispatch_semaphore_signal(*((dispatch_semaphore_t *)v1 + 315));
    return (unsigned __int8 *)dispatch_semaphore_wait(*((dispatch_semaphore_t *)v1 + 316), 0xFFFFFFFFFFFFFFFFLL);
  }

  return this;
}

void GTUSCSamplingStreamingManagerHelper::StreamShaderProfilingData( GTUSCSamplingStreamingManagerHelper *this)
{
  unsigned __int8 v1 = atomic_load(byte_5B979C);
  if ((v1 & 1) == 0)
  {
    uint64_t v2 = -1431655765 * ((*((void *)&xmmword_5B9600 + 1) - (void)xmmword_5B9600) >> 3);
    if ((_DWORD)v2)
    {
      for (uint64_t i = 0LL; i != v2; ++i)
      {
        int v4 = -286331153 * ((*(void *)(xmmword_5B9600 + 24 * i + 8) - *(void *)(xmmword_5B9600 + 24 * i)) >> 3);
        if (v4)
        {
          for (int j = 0; j != v4; ++j)
          {
            unsigned __int8 v6 = (std::__thread_struct *)operator new(8uLL);
            std::__thread_struct::__thread_struct(v6);
            uint64_t v7 = operator new(0x18uLL);
            *uint64_t v7 = v6;
            v7[1] = &GTUSCSamplingStreamingManagerHelper::Instance(void)::instance;
            *((_DWORD *)v7 + 4) = i;
            *((_DWORD *)v7 + 5) = j;
            v73[0] = v7;
            int v8 = pthread_create( v71,  0LL,  (void *(__cdecl *)(void *))std::__thread_proxy[abi:nn180100]<std::tuple<std::unique_ptr<std::__thread_struct>,GTUSCSamplingStreamingManagerHelper::StartBackgroundProcessingThreads(void)::$_0>>,  v7);
            if (v8) {
              goto LABEL_28;
            }
            v62.sched_priority = sched_get_priority_max(2);
            pthread_setschedparam(v71[0], 2, &v62);
            std::thread::detach((std::thread *)v71);
            unsigned __int8 v9 = (std::__thread_struct *)operator new(8uLL);
            std::__thread_struct::__thread_struct(v9);
            sched_param v10 = operator new(0x18uLL);
            void *v10 = v9;
            v10[1] = &GTUSCSamplingStreamingManagerHelper::Instance(void)::instance;
            *((_DWORD *)v10 + 4) = i;
            *((_DWORD *)v10 + 5) = j;
            v73[0] = v10;
            int v8 = pthread_create( v60,  0LL,  (void *(__cdecl *)(void *))std::__thread_proxy[abi:nn180100]<std::tuple<std::unique_ptr<std::__thread_struct>,GTUSCSamplingStreamingManagerHelper::StartBackgroundProcessingThreads(void)::$_1>>,  v10);
            if (v8)
            {
LABEL_28:
              std::__throw_system_error(v8, "thread constructor failed");
              __break(1u);
            }

            std::thread::detach((std::thread *)v60);
            std::thread::~thread((std::thread *)v60);
            std::thread::~thread((std::thread *)v71);
          }
        }
      }
    }

    uint64_t v32 = *(void *)GTUSCSamplingStreamingManagerHelper::Instance(void)::instance;
    unsigned __int8 v11 = (GTUSCSamplingStreamingManagerHelper *)objc_claimAutoreleasedReturnValue( [*(id *)(*(void *)GTUSCSamplingStreamingManagerHelper::Instance(void)::instance + 8) defaultDevice]);
    unint64_t v33 = v11;
    if (v11)
    {
      atomic_store(HIDWORD(qword_5B9550), (unsigned int *)&xmmword_5B9780);
      v75[0] = 0LL;
      v75[1] = v75;
      v75[2] = 0x2020000000LL;
      v75[3] = 0LL;
      unsigned __int8 v13 = atomic_load((unsigned __int8 *)&unk_5B979B);
      if ((v13 & 1) == 0)
      {
        unint64_t v31 = &v71[6];
        do
        {
          unsigned __int8 v14 = atomic_load(byte_5B979C);
          if ((v14 & 1) != 0) {
            break;
          }
          unint64_t v34 = (void *)objc_opt_new(&OBJC_CLASS___NSOperation, v12);
          id v15 = 0LL;
          int v16 = 3;
          do
          {
            int v35 = v16;
            v73[0] = 0LL;
            v73[1] = v73;
            v73[2] = 0x5812000000LL;
            v73[3] = __Block_byref_object_copy__195;
            v73[4] = __Block_byref_object_dispose__196;
            memset(&v73[5], 0, 40);
            int v74 = 1065353216;
            v71[0] = 0LL;
            v71[1] = (pthread_t)v71;
            v71[2] = (pthread_t)0x5812000000LL;
            v71[3] = (pthread_t)__Block_byref_object_copy__269;
            v71[4] = (pthread_t)__Block_byref_object_dispose__270;
            memset(&v71[5], 0, 40);
            int v72 = 1065353216;
            sched_param v62 = 0LL;
            unint64_t v63 = &v62;
            uint64_t v64 = 0x4812000000LL;
            unint64_t v65 = __Block_byref_object_copy__271;
            unint64_t v66 = __Block_byref_object_dispose__272;
            uint64_t v67 = "";
            size_t v69 = 0LL;
            uint64_t v70 = 0LL;
            __p = 0LL;
            v60[0] = 0LL;
            v60[1] = (pthread_t)v60;
            v60[2] = (pthread_t)0x3032000000LL;
            v60[3] = (pthread_t)__Block_byref_object_copy_;
            v60[4] = (pthread_t)__Block_byref_object_dispose_;
            id v61 = 0LL;
            unint64_t v17 = objc_autoreleasePoolPush();
            uint64_t v19 = (void *)objc_opt_new(&OBJC_CLASS___NSMutableData, v18);
            objc_autoreleasePoolPop(v17);
            v58[0] = 0LL;
            v58[1] = v58;
            v58[2] = 0x3032000000LL;
            v58[3] = __Block_byref_object_copy_;
            v58[4] = __Block_byref_object_dispose_;
            id v59 = (id)objc_opt_new(&OBJC_CLASS___NSMutableDictionary, v20);
            v49[0] = _NSConcreteStackBlock;
            v49[1] = 3221225472LL;
            v49[2] = ___ZN35GTUSCSamplingStreamingManagerHelper25StreamShaderProfilingDataEv_block_invoke;
            v49[3] = &unk_58D928;
            __int128 v57 = &GTUSCSamplingStreamingManagerHelper::Instance(void)::instance;
            unint64_t v51 = v73;
            unint64_t v52 = &v62;
            uint64_t v53 = v71;
            uint64_t v54 = v75;
            id v21 = v19;
            id v50 = v21;
            uint64_t v55 = v58;
            uint64_t v56 = v60;
            uint64_t v22 = (void *)objc_claimAutoreleasedReturnValue( +[NSBlockOperation blockOperationWithBlock:]( &OBJC_CLASS___NSBlockOperation,  "blockOperationWithBlock:",  v49));
            v39[0] = _NSConcreteStackBlock;
            v39[1] = 3221225472LL;
            v39[2] = ___ZN35GTUSCSamplingStreamingManagerHelper25StreamShaderProfilingDataEv_block_invoke_2;
            v39[3] = &unk_58D838;
            uint64_t v47 = &GTUSCSamplingStreamingManagerHelper::Instance(void)::instance;
            uint64_t v48 = v32;
            uint64_t v23 = v33;
            id v42 = v73;
            unsigned __int8 v43 = v71;
            id v40 = v23;
            id v41 = 0LL;
            unint64_t v44 = &v62;
            id v45 = v58;
            uint64_t v46 = v60;
            uint64_t v24 = (void *)objc_claimAutoreleasedReturnValue( +[NSBlockOperation blockOperationWithBlock:]( &OBJC_CLASS___NSBlockOperation,  "blockOperationWithBlock:",  v39));
            unsigned __int8 v25 = v24;
            if (v15) {
              [v24 addDependency:v15];
            }
            objc_msgSend(v25, "setQueuePriority:", -8, v31);
            [**(id **)(GTUSCSamplingStreamingManagerHelper::Instance(void)::instance + 8) addOperation:v25];
            if (dword_5B9514 && dword_5B9510)
            {
              v36[0] = _NSConcreteStackBlock;
              v36[1] = 3221225472LL;
              v36[2] = ___ZN35GTUSCSamplingStreamingManagerHelper25StreamShaderProfilingDataEv_block_invoke_3;
              v36[3] = &unk_58F270;
              unsigned int v38 = &GTUSCSamplingStreamingManagerHelper::Instance(void)::instance;
              id v37 = v21;
              uint64_t v26 = (void *)objc_claimAutoreleasedReturnValue( +[NSBlockOperation blockOperationWithBlock:]( &OBJC_CLASS___NSBlockOperation,  "blockOperationWithBlock:",  v36));
              [v26 addDependency:v25];
              [v22 addDependency:v26];
              [**(id **)(GTUSCSamplingStreamingManagerHelper::Instance(void)::instance + 8) addOperation:v26];
            }

            else
            {
              [v22 addDependency:v25];
            }

            [*(id *)(*(void *)(GTUSCSamplingStreamingManagerHelper::Instance(void)::instance + 8) + 8) addOperation:v22];
            [v34 addDependency:v22];

            _Block_object_dispose(v58, 8);
            _Block_object_dispose(v60, 8);

            _Block_object_dispose(&v62, 8);
            if (__p)
            {
              size_t v69 = __p;
              operator delete(__p);
            }

            _Block_object_dispose(v71, 8);
            std::__hash_table<std::__hash_value_type<unsigned int,std::vector<GTCoalescedEncoderIndexInfo>>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,std::vector<GTCoalescedEncoderIndexInfo>>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,std::vector<GTCoalescedEncoderIndexInfo>>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,std::vector<GTCoalescedEncoderIndexInfo>>>>::~__hash_table((uint64_t)v31);
            _Block_object_dispose(v73, 8);
            std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long>>>::~__hash_table((uint64_t)&v73[6]);
            id v15 = v22;
            int v16 = v35 - 1;
          }

          while (v35 != 1);
          [*(id *)(*(void *)(GTUSCSamplingStreamingManagerHelper::Instance(void)::instance + 8) + 8) addOperation:v34];
          [v34 waitUntilFinished];

          unsigned __int8 v27 = atomic_load((unsigned __int8 *)&unk_5B979B);
        }

        while ((v27 & 1) == 0);
      }

      GTUSCSamplingStreamingManagerHelper::SignalAndWaitForAllThreadsToTerminate(v11);
      uint64_t v28 = *(void *)(GTUSCSamplingStreamingManagerHelper::Instance(void)::instance + 32);
      v76[0] = @"usc sampling address mappings";
      unint64_t v29 = (void *)objc_claimAutoreleasedReturnValue([(id)xmmword_5B9468 mappings]);
      v76[1] = @"usc sampling address data";
      v77[0] = v29;
      v77[1] = qword_5B9480;
      int v30 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v77,  v76,  2LL));
      (*(void (**)(uint64_t, void *))(v28 + 16))(v28, v30);

      _Block_object_dispose(v75, 8);
    }
  }

void sub_6E338( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15)
{
  _Block_object_dispose((const void *)(v17 - 192), 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__269(uint64_t result, void *a2)
{
  uint64_t v2 = a2[6];
  a2[6] = 0LL;
  *(void *)(result + 4_Block_object_dispose(&STACK[0x3B0], 8) = v2;
  *(void *)(result + 56) = a2[7];
  a2[7] = 0LL;
  uint64_t v5 = a2[8];
  uint64_t v3 = a2 + 8;
  uint64_t v4 = v5;
  *(void *)(result + 64) = v5;
  uint64_t v6 = v3[1];
  *(void *)(result + 72) = v6;
  *(_DWORD *)(result + 80) = *((_DWORD *)v3 + 4);
  if (v6)
  {
    unint64_t v7 = *(void *)(v4 + 8);
    unint64_t v8 = *(void *)(result + 56);
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v7 >= v8) {
        v7 %= v8;
      }
    }

    else
    {
      v7 &= v8 - 1;
    }

    *(void *)(v2 + 8 * v7) = result + 64;
    void *v3 = 0LL;
    v3[1] = 0LL;
  }

  return result;
}

uint64_t __Block_byref_object_dispose__270(uint64_t a1)
{
  return std::__hash_table<std::__hash_value_type<unsigned int,std::vector<GTCoalescedEncoderIndexInfo>>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,std::vector<GTCoalescedEncoderIndexInfo>>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,std::vector<GTCoalescedEncoderIndexInfo>>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,std::vector<GTCoalescedEncoderIndexInfo>>>>::~__hash_table(a1 + 48);
}

__n128 __Block_byref_object_copy__271(__n128 *a1, __n128 *a2)
{
  a1[3].n128_u64[0] = 0LL;
  a1[3].n128_u64[1] = 0LL;
  a1[4].n128_u64[0] = 0LL;
  __n128 result = a2[3];
  a1[3] = result;
  a1[4].n128_u64[0] = a2[4].n128_u64[0];
  a2[3].n128_u64[0] = 0LL;
  a2[3].n128_u64[1] = 0LL;
  a2[4].n128_u64[0] = 0LL;
  return result;
}

void __Block_byref_object_dispose__272(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 48);
  if (v2)
  {
    *(void *)(a1 + 56) = v2;
    operator delete(v2);
  }

void ___ZN35GTUSCSamplingStreamingManagerHelper25StreamShaderProfilingDataEv_block_invoke(void *a1)
{
  uint64_t v2 = a1[11];
  unsigned __int8 v3 = atomic_load((unsigned __int8 *)(v2 + 2763));
  if ((v3 & 1) == 0 || (unsigned __int8 v4 = atomic_load((unsigned __int8 *)(v2 + 2764)), (v4 & 1) != 0))
  {
    __lk.__m_ = (std::unique_lock<std::mutex>::mutex_type *)(v2 + 2928);
    __lk.__owns_ = 1;
    std::mutex::lock((std::mutex *)(v2 + 2928));
    unsigned int v5 = atomic_load((unsigned int *)(v2 + 2740));
    unsigned int v6 = atomic_load((unsigned int *)(v2 + 2744));
    if (v5 != v6)
    {
      do
      {
        std::condition_variable::wait((std::condition_variable *)(v2 + 2880), &__lk);
        unsigned int v7 = atomic_load((unsigned int *)(v2 + 2740));
        unsigned int v8 = atomic_load((unsigned int *)(v2 + 2744));
      }

      while (v7 != v8);
    }

    [*(id *)(v2 + 8) gatherStats];
    unint64_t v101 = (void *)objc_claimAutoreleasedReturnValue( +[NSMutableDictionary dictionaryWithCapacity:]( &OBJC_CLASS___NSMutableDictionary,  "dictionaryWithCapacity:",  *(void *)(*(void *)(a1[5] + 8LL) + 72LL)));
    unint64_t v100 = (void *)objc_claimAutoreleasedReturnValue( +[NSMutableDictionary dictionaryWithCapacity:]( &OBJC_CLASS___NSMutableDictionary,  "dictionaryWithCapacity:",  *(void *)(*(void *)(a1[5] + 8LL) + 72LL)));
    uint64_t v9 = *(void *)(a1[6] + 8LL);
    unint64_t v10 = *(void *)(v9 + 48);
    unsigned __int8 v11 = *(unint64_t **)(v9 + 56);
    unint64_t v12 = 126 - 2 * __clz((uint64_t)((uint64_t)v11 - v10) >> 4);
    else {
      uint64_t v13 = v12;
    }
    std::__introsort<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned long long,unsigned long long> *,false>( v10,  v11,  v13,  1);
    uint64_t v97 = (void *)objc_claimAutoreleasedReturnValue( +[NSMutableArray arrayWithCapacity:]( &OBJC_CLASS___NSMutableArray,  "arrayWithCapacity:",  (uint64_t)(*(void *)(*(void *)(a1[6] + 8LL) + 56LL)
                              - *(void *)(*(void *)(a1[6] + 8LL) + 48LL)) >> 4));
    uint64_t v96 = (void *)objc_claimAutoreleasedReturnValue( +[NSMutableData dataWithCapacity:]( &OBJC_CLASS___NSMutableData,  "dataWithCapacity:",  *(void *)(*(void *)(a1[6] + 8LL) + 56LL) - *(void *)(*(void *)(a1[6] + 8LL) + 48LL)));
    [v96 appendBytes:*(void *)(*(void *)(a1[6] + 8) + 48) length:*(void *)(*(void *)(a1[6] + 8) + 56) - *(void *)(*(void *)(a1[6] + 8) + 48)];
    uint64_t v14 = a1[6];
    uint64_t v15 = *(void *)(v14 + 8);
    uint64_t v16 = *(void *)(v15 + 48);
    uint64_t v17 = *(void *)(v15 + 56);
    uint64_t v98 = a1;
    if (v16 == v17) {
      unint64_t v18 = 0LL;
    }
    else {
      unint64_t v18 = *(void *)(v16 + 8);
    }
    uint64_t v106 = v2;
    if ((unint64_t)(v17 - v16) >= 0x11)
    {
      uint64_t v19 = 0LL;
      unint64_t v20 = 1LL;
      do
      {
        if (v18 < *(void *)(v16 + v19 + 16))
        {
          id v21 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  v18));
          v119[0] = v21;
          uint64_t v22 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  *(void *)(*(void *)(*(void *)(v98[6] + 8LL) + 48LL) + v19 + 16) - 1LL));
          v119[1] = v22;
          uint64_t v23 = (void *)objc_claimAutoreleasedReturnValue( +[NSArray arrayWithObjects:count:]( &OBJC_CLASS___NSArray,  "arrayWithObjects:count:",  v119,  2LL));
          [v97 addObject:v23];

          uint64_t v14 = v98[6];
        }

        uint64_t v24 = *(void *)(v14 + 8);
        uint64_t v16 = *(void *)(v24 + 48);
        uint64_t v25 = *(void *)(v24 + 56);
        if (v18 <= *(void *)(v16 + v19 + 24)) {
          unint64_t v18 = *(void *)(v16 + v19 + 24);
        }
        ++v20;
        v19 += 16LL;
      }

      while (v20 < (v25 - v16) >> 4);
    }

    for (uint64_t i = *(uint64_t ***)(*(void *)(v98[5] + 8LL) + 64LL); i; uint64_t i = (uint64_t **)*i)
    {
      unsigned __int8 v27 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedInt:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedInt:",  *((unsigned int *)i + 6)));
      uint64_t v28 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedInt:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedInt:",  *((unsigned int *)i + 4)));
      [v101 setObject:v27 forKeyedSubscript:v28];

      unint64_t v29 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedInt:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedInt:",  *((unsigned int *)i + 7)));
      v118[0] = v29;
      int v30 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedInt:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedInt:",  *((unsigned int *)i + 8)));
      v118[1] = v30;
      unint64_t v31 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedInt:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedInt:",  *((unsigned int *)i + 9)));
      v118[2] = v31;
      uint64_t v32 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  i[5]));
      v118[3] = v32;
      unint64_t v33 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", v118, 4LL));
      unint64_t v34 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedInt:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedInt:",  *((unsigned int *)i + 4)));
      [v100 setObject:v33 forKeyedSubscript:v34];
    }

    id v99 = (void *)objc_claimAutoreleasedReturnValue( +[NSMutableDictionary dictionaryWithCapacity:]( &OBJC_CLASS___NSMutableDictionary,  "dictionaryWithCapacity:",  *(void *)(*(void *)(v98[7] + 8LL) + 72LL)));
    for (int j = *(uint64_t ***)(*(void *)(v98[7] + 8LL) + 64LL); j; int j = (uint64_t **)*j)
    {
      uint64_t v36 = (void *)objc_claimAutoreleasedReturnValue( +[NSMutableArray arrayWithCapacity:]( &OBJC_CLASS___NSMutableArray,  "arrayWithCapacity:",  ((char *)j[4] - (char *)j[3]) >> 4));
      id v37 = (unsigned int *)j[3];
      unsigned int v38 = (unsigned int *)j[4];
      while (v37 != v38)
      {
        unsigned int v39 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInt:](&OBJC_CLASS___NSNumber, "numberWithUnsignedInt:", *v37));
        v117[0] = v39;
        id v40 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  *((void *)v37 + 1)));
        v117[1] = v40;
        id v41 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", v117, 2LL));
        [v36 addObject:v41];

        v37 += 4;
      }

      id v42 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedInt:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedInt:",  *((unsigned int *)j + 4)));
      [v99 setObject:v36 forKeyedSubscript:v42];
    }

    id v109 = 0LL;
    uint64_t v92 = (void *)objc_claimAutoreleasedReturnValue( +[NSKeyedArchiver archivedDataWithRootObject:requiringSecureCoding:error:]( &OBJC_CLASS___NSKeyedArchiver,  "archivedDataWithRootObject:requiringSecureCoding:error:",  v101,  1LL,  &v109));
    id v43 = v109;
    unint64_t v44 = (char *)[*(id *)(v106 + 1968) mutableBytes];
    uint64_t v45 = *(void *)(*(void *)(v98[8] + 8LL) + 24LL);
    int64x2_t v93 = (void *)objc_claimAutoreleasedReturnValue( +[NSData dataWithBytesNoCopy:length:freeWhenDone:]( &OBJC_CLASS___NSData,  "dataWithBytesNoCopy:length:freeWhenDone:",  &v44[v45],  *(void *)(v106 + 1976) - v45,  0LL));
    id v108 = v43;
    uint64_t v94 = (void *)objc_claimAutoreleasedReturnValue( +[NSKeyedArchiver archivedDataWithRootObject:requiringSecureCoding:error:]( &OBJC_CLASS___NSKeyedArchiver,  "archivedDataWithRootObject:requiringSecureCoding:error:",  v100,  1LL,  &v108));
    id v46 = v108;

    id v107 = v46;
    unint64_t v95 = (void *)objc_claimAutoreleasedReturnValue( +[NSKeyedArchiver archivedDataWithRootObject:requiringSecureCoding:error:]( &OBJC_CLASS___NSKeyedArchiver,  "archivedDataWithRootObject:requiringSecureCoding:error:",  v99,  1LL,  &v107));
    id v91 = v107;

    uint64_t v47 = v106;
    uint64_t v48 = *(void **)(v106 + 1944);
    if (*(int *)(v106 + 2180) >= 2)
    {
      id v90 = (id)objc_claimAutoreleasedReturnValue([v48 mappings]);
      unint64_t v104 = (void *)objc_claimAutoreleasedReturnValue( +[NSMutableArray arrayWithCapacity:]( NSMutableArray,  "arrayWithCapacity:",  [v90 count]));
      uint64_t v105 = (void *)objc_opt_new(&OBJC_CLASS___NSMutableDictionary, v50);
      unint64_t v52 = (void *)objc_opt_new(&OBJC_CLASS___NSMutableDictionary, v51);
      __int128 v113 = 0u;
      __int128 v114 = 0u;
      __int128 v111 = 0u;
      __int128 v112 = 0u;
      obint j = v90;
      id v53 = [obj countByEnumeratingWithState:&v111 objects:v120 count:16];
      if (v53)
      {
        uint64_t v103 = *(void *)v112;
        do
        {
          for (uint64_t k = 0LL; k != v53; uint64_t k = (char *)k + 1)
          {
            if (*(void *)v112 != v103) {
              objc_enumerationMutation(obj);
            }
            uint64_t v55 = *(void **)(*((void *)&v111 + 1) + 8LL * (void)k);
            id v56 = [v55 mutableCopy];
            __int128 v57 = (void *)objc_claimAutoreleasedReturnValue([v55 objectForKeyedSubscript:@"encIndex"]);
            unsigned int v58 = [v57 unsignedIntValue];

            unint64_t v59 = *(void *)(v106 + 1960);
            unint64_t v60 = (void *)objc_claimAutoreleasedReturnValue([v55 objectForKeyedSubscript:@"drawCallIndex"]);
            id v61 = [v60 unsignedIntValue];

            sched_param v62 = (void *)objc_claimAutoreleasedReturnValue([v55 objectForKeyedSubscript:@"mappedSize"]);
            uint64_t v63 = (uint64_t)[v62 unsignedLongLongValue];

            uint64_t v64 = (void *)objc_claimAutoreleasedReturnValue([v55 objectForKeyedSubscript:@"type"]);
            unint64_t v65 = (void *)objc_claimAutoreleasedReturnValue([v55 objectForKeyedSubscript:@"binaryUniqueId"]);
            ComputedKey = GTShaderProfilerGenerateComputedKey(v58 % v59, (uint64_t)v61, v63, v64);
            uint64_t v67 = (void *)objc_claimAutoreleasedReturnValue(ComputedKey);
            uint64_t v68 = (void *)objc_claimAutoreleasedReturnValue([v52 objectForKeyedSubscript:v67]);
            LOBYTE(v63) = v68 == 0LL;

            if ((v63 & 1) == 0)
            {
              size_t v69 = (void *)objc_claimAutoreleasedReturnValue([v105 objectForKeyedSubscript:v67]);
              unsigned int v70 = [v69 unsignedIntValue];

              uint64_t v71 = v70 + 1;
              uint64_t v72 = objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"%@_%u",  v67,  v71));

              uint64_t v73 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInt:](&OBJC_CLASS___NSNumber, "numberWithUnsignedInt:", v71));
              [v105 setObject:v73 forKeyedSubscript:v72];

              uint64_t v67 = (void *)v72;
            }

            [v52 setObject:v65 forKeyedSubscript:v67];
            int v74 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v106 + 1952) objectForKeyedSubscript:v67]);
            [v56 setObject:v74 forKeyedSubscript:@"binaryUniqueId"];

            [v104 addObject:v56];
          }

          id v53 = [obj countByEnumeratingWithState:&v111 objects:v120 count:16];
        }

        while (v53);
      }

      id v49 = [v104 copy];
      uint64_t v47 = v106;
    }

    else
    {
      id v49 = (id)objc_claimAutoreleasedReturnValue([v48 mappings]);
    }

    id v75 = objc_alloc_init(&OBJC_CLASS___ProgramAddressTableCollector);
    id v76 = *(void **)(v47 + 1944);
    *(void *)(v47 + 1944) = v75;

    v115[0] = @"Frame Index";
    uint64_t v77 = v106;
    uint64_t v78 = atomic_load((unsigned int *)(v106 + 2756));
    BOOL v79 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInt:](&OBJC_CLASS___NSNumber, "numberWithUnsignedInt:", v78));
    v116[0] = v79;
    v116[1] = v93;
    v115[1] = @"Program Address Buffer";
    v115[2] = @"Program Address Mappings";
    v116[2] = v49;
    v116[3] = v92;
    v115[3] = @"TraceId to BatchId";
    v115[4] = @"Source Sample Marker";
    unint64_t v80 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  *(void *)(v77 + 32)));
    uint64_t v81 = v98[4];
    v116[4] = v80;
    v116[5] = v81;
    v115[5] = @"Frame Encoder Time Data";
    v115[6] = @"TraceId to SampleIndex";
    v116[6] = v94;
    v115[7] = @"Frame Consistent Perf Info";
    uint64_t v82 = v98[10];
    v116[7] = *(void *)(*(void *)(v98[9] + 8LL) + 40LL);
    v116[8] = v97;
    v115[8] = @"Restore Timestamps";
    v115[9] = @"Command Buffer Timestamps";
    v116[9] = v96;
    v115[10] = @"PState Info Data";
    uint64_t v83 = *(void **)(*(void *)(v82 + 8) + 40LL);
    if (!v83) {
      uint64_t v83 = &__NSDictionary0__struct;
    }
    v116[10] = v83;
    v116[11] = v95;
    v115[11] = @"TraceId to Coalesced BatchId";
    v115[12] = @"PState non-consistent";
    unint64_t v84 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedInt:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedInt:",  *(unsigned int *)(*(void *)v106 + 68LL)));
    v116[12] = v84;
    unint64_t v85 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v116,  v115,  13LL));

    (*(void (**)(void))(*(void *)(*(void *)v106 + 32LL) + 16LL))();
    *(void *)(*(void *)(v98[8] + 8LL) + 24LL) = *(void *)(v106 + 1976);
    unint64_t v86 = (unsigned int *)(v106 + 2736);
    do
      unsigned int v87 = __ldaxr(v86);
    while (__stlxr(v87 - 1, v86));
    unint64_t v88 = atomic_load((unint64_t *)(v106 + 2728));
    if (v88 > 0x3000000 || (int v89 = atomic_load(v86), v89 <= 0)) {
      atomic_store(1u, (unsigned __int8 *)(v106 + 2763));
    }

    if (__lk.__owns_) {
      std::mutex::unlock(__lk.__m_);
    }
  }

void sub_6F0B0( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, void *a12, void *a13, void *a14, void *a15, void *a16, void *a17, void *a18, uint64_t a19, void *a20, void *a21, void *a22, uint64_t a23, uint64_t a24, void *a25, void *a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, std::mutex *a31, char a32)
{
  if (a32) {
    std::mutex::unlock(a31);
  }
  _Unwind_Resume(a1);
}

void ___ZN35GTUSCSamplingStreamingManagerHelper25StreamShaderProfilingDataEv_block_invoke_2(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 88);
  unsigned __int8 v2 = atomic_load((unsigned __int8 *)(v1 + 2763));
  if ((v2 & 1) != 0) {
    return;
  }
  unsigned __int8 v3 = atomic_load((unsigned __int8 *)(v1 + 2764));
  if ((v3 & 1) != 0) {
    return;
  }
  atomic_store(0, (unsigned __int8 *)(v1 + 2760));
  GTUSCSamplingStreamingManagerHelper::InitForPreSamplingWait((GTUSCSamplingStreamingManagerHelper *)v1);
  GTMTLReplayController_prePlayForProfiling(**(void **)v1);
  usleep(0x7A120u);
  if (*(_DWORD *)(v1 + 2180) == 1) {
    uint64_t v5 = 100000LL;
  }
  else {
    uint64_t v5 = 0LL;
  }
  [*(id *)(v1 + 8) startCollectingPerfStatsAtInterval:1000000 andPeriodicSamplesAtInterval:v5];
  id v6 = *(id *)(v1 + 2080);
  unsigned int v7 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v1 + 16) firstObject]);
  id v8 = [*(id *)(v1 + 24) count];
  if (!v8) {
    goto LABEL_35;
  }
  int v9 = *(unsigned __int8 *)(v1 + 2186);
  if (GTAGXPerfStateControl::IsGPUPerformanceStateInduced((GTAGXPerfStateControl *)(v1 + 40)))
  {
    v64[0] = @"DisableOverlap";
    unint64_t v10 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithBool:](&OBJC_CLASS___NSNumber, "numberWithBool:", v9 == 0));
    v65[0] = v10;
    unsigned __int8 v11 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v65,  v64,  1LL));
    [v7 setOptions:v11];
  }

  else
  {
    uint64_t v12 = *(unsigned int *)(*(void *)v1 + 72LL);
    if ((_DWORD)v12)
    {
      GTAGXPerfStateControl::EnableConsistentGPUPerfState(v1 + 40, v12);
      id v13 = GTApplePMPPerfStateControl::EnableConsistentPerfState( (GTApplePMPPerfStateControl *)(v1 + 64),  (*(_DWORD *)(*(void *)v1 + 72LL) - 1));
      uint64_t v14 = objc_claimAutoreleasedReturnValue(v13);
      uint64_t v15 = *(void **)(v1 + 2088);
      *(void *)(v1 + 208_Block_object_dispose(&STACK[0x3B0], 8) = v14;

      v64[0] = @"DisableOverlap";
      unint64_t v10 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithBool:](&OBJC_CLASS___NSNumber, "numberWithBool:", v9 == 0));
      v65[0] = v10;
      unsigned __int8 v11 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v65,  v64,  1LL));
      [v7 setOptions:v11];
    }

    else
    {
      id v16 = GTApplePMPPerfStateControl::EnableConsistentPerfState((GTApplePMPPerfStateControl *)(v1 + 64), 1LL);
      uint64_t v17 = objc_claimAutoreleasedReturnValue(v16);
      unint64_t v18 = *(void **)(v1 + 2088);
      *(void *)(v1 + 208_Block_object_dispose(&STACK[0x3B0], 8) = v17;

      v64[0] = @"LockGPUPerfState";
      unint64_t v10 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedInt:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedInt:",  *(unsigned int *)(*(void *)v1 + 68LL)));
      v64[1] = @"DisableOverlap";
      v65[0] = v10;
      unsigned __int8 v11 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithBool:](&OBJC_CLASS___NSNumber, "numberWithBool:", v9 == 0));
      v65[1] = v11;
      uint64_t v19 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v65,  v64,  2LL));
      [v7 setOptions:v19];
    }
  }

  if (!*(_BYTE *)(v1 + 2184))
  {
    unint64_t v20 = 0LL;
    goto LABEL_14;
  }

  uint64_t v49 = 0LL;
  unsigned int v50 = 1;
  while (1)
  {
    uint64_t v51 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v1 + 2008) objectAtIndexedSubscript:v49]);
    BOOL v52 = [v51 count] == 0;

    if (!v52) {
      break;
    }
LABEL_52:
    uint64_t v49 = v50;
    if ((unint64_t)v8 <= v50++)
    {
      int v56 = 0;
      goto LABEL_55;
    }
  }

  id v53 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v1 + 24) objectAtIndexedSubscript:v49]);
  uint64_t v54 = *(void *)(v1 + 1904);
  if (v50 - 1 >= ((unint64_t)(*(void *)(v1 + 1912) - v54) >> 2)
    || (*(_DWORD *)(v54 + 4 * v49) & 0x10) == 0)
  {

    goto LABEL_52;
  }

  int v56 = 1;
LABEL_55:
  int v57 = *(_DWORD *)(v1 + 2116);
  if (v57) {
    int v57 = *(_DWORD *)(v1 + 2112) != 0;
  }
  if ((v56 | v57) == 1)
  {
    unsigned int v58 = *(std::unique_lock<std::mutex>::mutex_type **)(v1 + 2048);
    __lk.__m_ = v58;
    *(void *)&__lk.__owns_ = v58;
  }

  else
  {
    __lk.__m_ = *(std::unique_lock<std::mutex>::mutex_type **)(v1 + 2040);
    *(void *)&__lk.__owns_ = __lk.__m_;
    unsigned int v58 = *(std::unique_lock<std::mutex>::mutex_type **)(v1 + 2048);
  }

  uint64_t v63 = v58;
  unint64_t v20 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", &__lk, 3LL));
LABEL_14:
  char v21 = 0;
  for (unsigned int i = 0; ; unsigned int i = v23 + 1)
  {
    unint64_t v23 = i;
    uint64_t v24 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v1 + 2008) objectAtIndexedSubscript:i]);
    BOOL v25 = [v24 count] == 0;

    if (!v25)
    {
      uint64_t v26 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v1 + 24) objectAtIndexedSubscript:v23]);
      if (*(_BYTE *)(v1 + 2184))
      {
        id v28 = (unint64_t)[v20 count] <= v23
            ? *(id *)(v1 + 2048)
            : (id)objc_claimAutoreleasedReturnValue([v20 objectAtIndexedSubscript:v23]);
        unint64_t v60 = v28;
        objc_msgSend(v26, "requestTriggers:firstErrorIndex:");
        if ((v21 & 1) != 0
          || (uint64_t v29 = *(void *)(v1 + 1904),
              v23 >= ((unint64_t)(*(void *)(v1 + 1912) - v29) >> 2)))
        {
          [v26 setOptions:*(void *)(v1 + 2080)];
        }

        else if ((*(_DWORD *)(v29 + 4 * v23) & 0x10) != 0)
        {
          unint64_t v31 = (void *)objc_claimAutoreleasedReturnValue( +[NSMutableDictionary dictionaryWithCapacity:]( NSMutableDictionary,  "dictionaryWithCapacity:",  [*(id *)(v1 + 2080) count]));
          [v31 setObject:&__kCFBooleanTrue forKeyedSubscript:@"KickTimestamp"];
          if (*(void *)(v1 + 2080)) {
            objc_msgSend(v31, "addEntriesFromDictionary:");
          }
          [v26 setOptions:v31];

          char v21 = 1;
        }

        else
        {
          char v21 = 0;
        }

        uint64_t v61 = 0LL;
        int v30 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v1 + 2008) objectAtIndexedSubscript:v23]);
        unsigned __int8 v59 = [v26 requestCounters:v30 firstErrorIndex:&v61];

        if ((v59 & 1) == 0)
        {

          goto LABEL_34;
        }
      }

      unsigned int v27 = [v26 setEnabled:1];

      if (!v27) {
        goto LABEL_34;
      }
    }
  }

  *(_BYTE *)(v1 + 2184) = 0;
LABEL_34:

LABEL_35:
  atomic_store(0, (unsigned int *)(v1 + 2748));
  uint64_t v32 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v1 + 16) firstObject]);
  unsigned __int8 v33 = [v32 startSampling];

  if ((v33 & 1) != 0)
  {
    GTUSCSamplingStreamingManagerHelper::ResetSourceForPostProcessing((id *)v1);
    GTUSCSamplingStreamingManagerHelper::WaitForPreSampling((unsigned __int8 *)v1);
    atomic_store(1u, (unsigned __int8 *)(v1 + 2761));
    atomic_store(1u, (unsigned __int8 *)(v1 + 2761));
    unint64_t v34 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(*(void *)(a1 + 96) + 8) defaultCommandQueue]);
    [*(id *)(a1 + 32) mapShaderSampleBufferWithBuffer:0 capacity:0 size:0];
    int v35 = objc_autoreleasePoolPush();
    *(void *)&__lk.__owns_ = *(void *)(a1 + 96);
    LOBYTE(v63) = 0;
    __lk.__m_ = (std::unique_lock<std::mutex>::mutex_type *)[(id)g_commandBufferDescriptor errorOptions];
    [(id)g_commandBufferDescriptor setErrorOptions:0];
    GTUSCSamplingStreamingManagerHelper::ReplaySingleFrameForUSCSampling( v1,  (void *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 48LL),  (uint64_t *)(*(void *)(*(void *)(a1 + 56) + 8LL) + 48LL),  (void **)(*(void *)(*(void *)(a1 + 64) + 8LL) + 48LL),  0LL);
    [v34 finish];
    ScopedReplayConfiguration::~ScopedReplayConfiguration((ScopedReplayConfiguration *)&__lk);
    objc_autoreleasePoolPop(v35);
    [*(id *)(a1 + 32) unmapShaderSampleBuffer];
    atomic_store(1u, (unsigned __int8 *)(v1 + 2760));
    uint64_t v36 = (unsigned int *)(v1 + 2756);
    do
      unsigned int v37 = __ldaxr(v36);
    while (__stlxr(v37 + 1, v36));
    GTUSCSamplingStreamingManagerHelper::DrainAllSourceBuffers(*(void *)(v1 + 2424), *(void *)(v1 + 2432));
    __lk.__m_ = (std::unique_lock<std::mutex>::mutex_type *)(v1 + 2816);
    __lk.__owns_ = 1;
    std::mutex::lock((std::mutex *)(v1 + 2816));
    int v38 = *(_DWORD *)(v1 + 2164);
    unsigned int v39 = atomic_load((unsigned int *)(v1 + 2748));
    if (v38 != v39)
    {
      do
      {
        std::condition_variable::wait((std::condition_variable *)(v1 + 2768), &__lk);
        int v40 = *(_DWORD *)(v1 + 2164);
        unsigned int v41 = atomic_load((unsigned int *)(v1 + 2748));
      }

      while (v40 != v41);
    }

    id v42 = GTAGXPerfStateControl::ConsistentGPUPerfStateLevel((GTAGXPerfStateControl *)(v1 + 40), 0LL);
    id v43 = (void *)objc_claimAutoreleasedReturnValue(v42);
    if (v43) {
      [*(id *)(*(void *)(*(void *)(a1 + 72) + 8) + 40) setDictionary:v43];
    }
    unint64_t v44 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v1 + 16) firstObject]);
    [v44 stopSampling];

    [*(id *)(v1 + 8) gatherStats];
    [*(id *)(v1 + 8) stopCollectingStats];
    uint64_t v45 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v1 + 8) exportStats]);
    id v46 = [v45 copy];
    uint64_t v47 = *(void *)(*(void *)(a1 + 80) + 8LL);
    uint64_t v48 = *(void **)(v47 + 40);
    *(void *)(v47 + 40) = v46;

    [*(id *)(v1 + 8) reset];
    GTAGXPerfStateControl::DisableConsistentGPUPerfState((GTAGXPerfStateControl *)(v1 + 40));
    GTApplePMPPerfStateControl::DisableConsistentPerfState((GTApplePMPPerfStateControl *)(v1 + 64));
    atomic_store(0, (unsigned __int8 *)(v1 + 2761));

    if (__lk.__owns_) {
      std::mutex::unlock(__lk.__m_);
    }
  }

  else
  {
    [*(id *)(v1 + 8) stopCollectingStats];
    [*(id *)(v1 + 8) reset];
    GTUSCSamplingStreamingManagerHelper::WaitForPreSampling((unsigned __int8 *)v1);
    GTAGXPerfStateControl::DisableConsistentGPUPerfState((GTAGXPerfStateControl *)(v1 + 40));
    GTApplePMPPerfStateControl::DisableConsistentPerfState((GTApplePMPPerfStateControl *)(v1 + 64));
  }

void sub_6FB50( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, std::mutex *a13, char a14)
{
  _Unwind_Resume(a1);
}

void ___ZN35GTUSCSamplingStreamingManagerHelper25StreamShaderProfilingDataEv_block_invoke_3(uint64_t a1)
{
  unsigned __int8 v2 = *(void **)(a1 + 40);
  id v3 = GTSampleBufferManager::ResolveSampleBuffers((GTSampleBufferManager *)(v2 + 263));
  id v4 = (id)objc_claimAutoreleasedReturnValue(v3);
  if (v4) {
    [*(id *)(a1 + 32) setData:v4];
  }
  v2[269] = 0LL;
  v2[267] = v2[266];
}

void sub_6FD14( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
}

id GTSampleBufferManager::ResolveSampleBuffers(GTSampleBufferManager *this)
{
  uint64_t v1 = *((void *)this + 4);
  if (*((void *)this + 3) == v1)
  {
    unsigned int v7 = 0LL;
  }

  else
  {
    int v3 = *((_DWORD *)this + 12);
    *((_DWORD *)this + 13) += v3;
    *(_DWORD *)(v1 - 4) = v3;
    id v4 = -[NSMutableArray initWithCapacity:]( [NSMutableArray alloc],  "initWithCapacity:",  [*((id *)this + 2) count]);
    uint64_t v21 = 0LL;
    uint64_t v22 = &v21;
    uint64_t v23 = 0x2020000000LL;
    uint64_t v24 = 0LL;
    uint64_t v5 = (void *)*((void *)this + 2);
    v17[0] = _NSConcreteStackBlock;
    v17[1] = 3221225472LL;
    v17[2] = ___ZN21GTSampleBufferManager20ResolveSampleBuffersEv_block_invoke;
    v17[3] = &unk_58D978;
    uint64_t v19 = &v21;
    unint64_t v20 = this;
    id v6 = v4;
    unint64_t v18 = v6;
    [v5 enumerateObjectsUsingBlock:v17];
    unsigned int v7 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableData dataWithCapacity:](&OBJC_CLASS___NSMutableData, "dataWithCapacity:", v22[3]));
    __int128 v15 = 0u;
    __int128 v16 = 0u;
    __int128 v13 = 0u;
    __int128 v14 = 0u;
    id v8 = v6;
    id v9 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( v8,  "countByEnumeratingWithState:objects:count:",  &v13,  v25,  16LL);
    if (v9)
    {
      uint64_t v10 = *(void *)v14;
      do
      {
        unsigned __int8 v11 = 0LL;
        do
        {
          if (*(void *)v14 != v10) {
            objc_enumerationMutation(v8);
          }
          objc_msgSend(v7, "appendData:", *(void *)(*((void *)&v13 + 1) + 8 * (void)v11), (void)v13);
          unsigned __int8 v11 = (char *)v11 + 1;
        }

        while (v9 != v11);
        id v9 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( v8,  "countByEnumeratingWithState:objects:count:",  &v13,  v25,  16LL);
      }

      while (v9);
    }

    _Block_object_dispose(&v21, 8);
  }

  return v7;
}

void sub_6FF00( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, uint64_t a15, uint64_t a16, ...)
{
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void ___ZN21GTSampleBufferManager20ResolveSampleBuffersEv_block_invoke(uint64_t a1, void *a2, uint64_t a3)
{
  id v5 = a2;
  id v6 = (unsigned int *)(*(void *)(*(void *)(a1 + 48) + 24LL) + 8 * a3);
  id v8 = v5;
  unsigned int v7 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v5, "resolveCounterRange:", *v6, v6[1]));
  *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) += [v7 length];
  [*(id *)(a1 + 32) addObject:v7];
}

void sub_6FFC0( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
}

unint64_t std::__introsort<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned long long,unsigned long long> *,false>( unint64_t result, unint64_t *a2, uint64_t a3, char a4)
{
  unsigned int v7 = (unint64_t *)result;
LABEL_2:
  id v8 = a2 - 2;
  unsigned int i = v7;
  while (2)
  {
    unsigned int v7 = i;
    uint64_t v10 = (char *)a2 - (char *)i;
    unint64_t v11 = ((char *)a2 - (char *)i) >> 4;
    switch(v11)
    {
      case 0uLL:
      case 1uLL:
        return result;
      case 2uLL:
        unint64_t v43 = *v8;
        unint64_t v44 = *i;
        if (*v8 < *i || v44 >= v43 && *(a2 - 1) < i[1])
        {
          unint64_t *i = v43;
          *(a2 - 2) = v44;
          unint64_t v45 = i[1];
          i[1] = *(a2 - 1);
          *(a2 - 1) = v45;
        }

        return result;
      case 3uLL:
        return (unint64_t)std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned long long,unsigned long long> *>( i,  i + 2,  a2 - 2);
      case 4uLL:
        return (unint64_t)std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned long long,unsigned long long> *>( i,  i + 2,  i + 4,  a2 - 2);
      case 5uLL:
        return (unint64_t)std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned long long,unsigned long long> *>( i,  i + 2,  i + 4,  i + 6,  a2 - 2);
      default:
        if (v10 > 383)
        {
          if (!a3)
          {
            if (i == a2) {
              return result;
            }
            int64_t v60 = (v11 - 2) >> 1;
            int64_t v61 = v60;
            while (1)
            {
              int64_t v62 = v61;
              if (v60 >= v61)
              {
                uint64_t v63 = (2 * v61) | 1;
                uint64_t v64 = &i[2 * v63];
                if (2 * v62 + 2 < (uint64_t)v11)
                {
                  unint64_t v65 = v64[2];
                  if (*v64 < v65 || v65 >= *v64 && i[2 * v63 + 1] < v64[3])
                  {
                    v64 += 2;
                    uint64_t v63 = 2 * v62 + 2;
                  }
                }

                unint64_t v66 = &i[2 * v62];
                unint64_t v67 = *v64;
                unint64_t v68 = *v66;
                if (*v64 >= *v66)
                {
                  if (v68 < v67)
                  {
                    unint64_t v69 = v66[1];
LABEL_129:
                    *unint64_t v66 = v67;
                    v66[1] = v64[1];
                    if (v60 >= v63)
                    {
                      while (1)
                      {
                        uint64_t v71 = 2 * v63;
                        uint64_t v63 = (2 * v63) | 1;
                        unsigned int v70 = &i[2 * v63];
                        uint64_t v72 = v71 + 2;
                        if (v72 < (uint64_t)v11)
                        {
                          unint64_t v73 = v70[2];
                          if (*v70 < v73 || v73 >= *v70 && i[2 * v63 + 1] < v70[3])
                          {
                            v70 += 2;
                            uint64_t v63 = v72;
                          }
                        }

                        unint64_t v74 = *v70;
                        if (*v70 < v68 || v68 >= v74 && v70[1] < v69) {
                          break;
                        }
                        *uint64_t v64 = v74;
                        v64[1] = v70[1];
                        uint64_t v64 = v70;
                        if (v60 < v63) {
                          goto LABEL_131;
                        }
                      }
                    }

                    unsigned int v70 = v64;
LABEL_131:
                    *unsigned int v70 = v68;
                    v70[1] = v69;
                    goto LABEL_132;
                  }

                  unint64_t v69 = i[2 * v62 + 1];
                  if (v64[1] >= v69) {
                    goto LABEL_129;
                  }
                }
              }

LABEL_132:
              int64_t v61 = v62 - 1;
              if (!v62)
              {
                uint64_t v83 = (unint64_t)v10 >> 4;
                while (1)
                {
                  int64_t v84 = 0LL;
                  unint64_t v85 = *i;
                  unint64_t v86 = i[1];
                  uint64_t v87 = v83 - 2;
                  if (v83 < 2) {
                    uint64_t v87 = v83 - 1;
                  }
                  uint64_t v88 = v87 >> 1;
                  int v89 = i;
                  do
                  {
                    id v90 = v89;
                    int64_t v91 = v84 + 1;
                    v89 += 2 * v84 + 2;
                    uint64_t v92 = 2 * v84;
                    __n128 result = (2 * v84) | 1;
                    int64_t v84 = result;
                    uint64_t v93 = v92 + 2;
                    if (v93 < v83)
                    {
                      __n128 result = (unint64_t)(v89 + 2);
                      unint64_t v94 = v89[2];
                      if (*v89 < v94 || v94 >= *v89 && v90[2 * v91 + 1] < v89[3])
                      {
                        v89 += 2;
                        int64_t v84 = v93;
                      }
                    }

                    unint64_t *v90 = *v89;
                    v90[1] = v89[1];
                  }

                  while (v84 <= v88);
                  if (v89 == a2 - 2)
                  {
                    unint64_t *v89 = v85;
                    v89[1] = v86;
                  }

                  else
                  {
                    unint64_t *v89 = *(a2 - 2);
                    v89[1] = *(a2 - 1);
                    *(a2 - 2) = v85;
                    *(a2 - 1) = v86;
                    uint64_t v95 = (char *)v89 - (char *)i + 16;
                    if (v95 >= 17)
                    {
                      unint64_t v96 = (v95 >> 4) - 2;
                      unint64_t v97 = v96 >> 1;
                      uint64_t v98 = &i[2 * (v96 >> 1)];
                      unint64_t v99 = *v98;
                      unint64_t v100 = *v89;
                      if (*v98 < *v89)
                      {
                        unint64_t v101 = v89[1];
LABEL_171:
                        unint64_t *v89 = v99;
                        v89[1] = i[2 * v97 + 1];
                        if (v96 >= 2)
                        {
                          while (1)
                          {
                            unint64_t v103 = v97 - 1;
                            unint64_t v97 = (v97 - 1) >> 1;
                            uint64_t v102 = &i[2 * v97];
                            unint64_t v104 = *v102;
                            if (*v102 >= v100)
                            {
                              if (v100 < v104) {
                                break;
                              }
                              __n128 result = i[2 * v97 + 1];
                              if (result >= v101) {
                                break;
                              }
                            }

                            else
                            {
                              __n128 result = v102[1];
                            }

                            *uint64_t v98 = v104;
                            v98[1] = result;
                            uint64_t v98 = &i[2 * v97];
                            if (v103 <= 1) {
                              goto LABEL_178;
                            }
                          }
                        }

                        uint64_t v102 = v98;
LABEL_178:
                        unint64_t *v102 = v100;
                        v102[1] = v101;
                        goto LABEL_180;
                      }

                      if (v100 >= v99)
                      {
                        __n128 result = i[2 * v97 + 1];
                        unint64_t v101 = v89[1];
                        if (result < v101) {
                          goto LABEL_171;
                        }
                      }
                    }
                  }

  v65->nelts = 0;
  uint64_t v95 = v59[7];
  unint64_t v96 = *(_DWORD *)(v95 + 12);
  unint64_t v97 = v147;
  if (v96 >= 1)
  {
    for (unint64_t n = 0LL; n < v96; ++n)
    {
      unint64_t v99 = *(void *)(*(void *)(*(void *)(*(void *)(v95 + 24) + 8 * n) + 104LL) + 8LL);
      if (v99)
      {
        unint64_t v100 = apr_array_push(v65);
        unint64_t v97 = v147;
        void *v100 = v99;
        unint64_t v96 = *(_DWORD *)(v95 + 12);
      }
    }
  }

  ReserveResourceIndices(v97, (uint64_t)v65, 6u);
  if ((g_enableIndexedResourceType & 0x80) != 0)
  {
LABEL_138:
    v65->nelts = 0;
    unint64_t v101 = v59[8];
    uint64_t v102 = *(_DWORD *)(v101 + 12);
    unint64_t v103 = v147;
    if (v102 >= 1)
    {
      for (iunsigned int i = 0LL; ii < v102; ++ii)
      {
        uint64_t v105 = **(void **)(*(void *)(*(void *)(v101 + 24) + 8 * ii) + 104LL);
        if (v105)
        {
          uint64_t v106 = apr_array_push(v65);
          unint64_t v103 = v147;
          *uint64_t v106 = v105;
          uint64_t v102 = *(_DWORD *)(v101 + 12);
        }
      }
    }

    ReserveResourceIndices(v103, (uint64_t)v65, 7u);
  }

    if ((v39 & (v39 - 1)) != 0)
    {
      if (v39 <= v38) {
        id v9 = v38 % v39;
      }
      else {
        id v9 = v38;
      }
    }

    else
    {
      id v9 = (v39 - 1) & v38;
    }
  }

  int64_t v62 = *((void *)i + 3);
  uint64_t v63 = *(void **)(v62 + 8 * v9);
  if (v63)
  {
    *unint64_t v42 = *v63;
LABEL_145:
    *uint64_t v63 = v42;
    goto LABEL_146;
  }

  *unint64_t v42 = *((void *)i + 5);
  *((void *)i + 5) = v42;
  *(void *)(v62 + 8 * v9) = i + 10;
  if (*v42)
  {
    uint64_t v64 = *(void *)(*v42 + 8LL);
    if ((v39 & (v39 - 1)) != 0)
    {
      if (v64 >= v39) {
        v64 %= v39;
      }
    }

    else
    {
      v64 &= v39 - 1;
    }

    uint64_t v63 = (void *)(*((void *)i + 3) + 8 * v64);
    goto LABEL_145;
  }

            __int128 v154 = (void *)(v42 + 344);
            goto LABEL_133;
          }

          unint64_t v24 = v221;
LABEL_119:

          goto LABEL_120;
        }

        __int128 v150 = objc_claimAutoreleasedReturnValue([v20 objectPreloadedLibraries]);
LABEL_90:
        uint64_t v102 = (void *)v150;
        goto LABEL_91;
      }

LABEL_180:
                  a2 -= 2;
                  if (v83-- <= 2) {
                    return result;
                  }
                }
              }
            }
          }

          unint64_t v12 = v11 >> 1;
          __int128 v13 = &i[2 * (v11 >> 1)];
          if ((unint64_t)v10 < 0x801)
          {
            __n128 result = (unint64_t)std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned long long,unsigned long long> *>( &v7[2 * (v11 >> 1)],  v7,  a2 - 2);
          }

          else
          {
            std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned long long,unsigned long long> *>( v7,  &v7[2 * (v11 >> 1)],  a2 - 2);
            std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned long long,unsigned long long> *>( v7 + 2,  v13 - 2,  a2 - 4);
            std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned long long,unsigned long long> *>( v7 + 4,  &v7[2 * v12 + 2],  a2 - 6);
            __n128 result = (unint64_t)std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned long long,unsigned long long> *>( v13 - 2,  v13,  &v7[2 * v12 + 2]);
            __int128 v14 = *(_OWORD *)v7;
            *(_OWORD *)unsigned int v7 = *(_OWORD *)v13;
            *(_OWORD *)__int128 v13 = v14;
          }

          --a3;
          unint64_t v15 = *v7;
          if ((a4 & 1) == 0)
          {
            unint64_t v16 = *(v7 - 2);
            if (v16 >= v15)
            {
              if (v15 < v16)
              {
                unint64_t v17 = v7[1];
              }

              else
              {
                unint64_t v17 = v7[1];
                if (*(v7 - 1) < v17) {
                  goto LABEL_13;
                }
              }

              unint64_t v33 = *v8;
              if (v15 >= *v8 && (v33 < v15 || v17 >= *(a2 - 1)))
              {
                for (unsigned int i = v7 + 2; i < a2 && v15 >= *i && (*i < v15 || v17 >= i[1]); i += 2)
                  ;
              }

              else
              {
                unsigned int i = v7;
                do
                {
                  unint64_t v35 = i[2];
                  i += 2;
                  unint64_t v34 = v35;
                }

                while (v15 >= v35 && (v34 < v15 || v17 >= i[1]));
              }

              int j = a2;
              if (i < a2)
              {
                for (int j = a2 - 2; v15 < v33 || v33 >= v15 && v17 < j[1]; j -= 2)
                {
                  unint64_t v37 = *(j - 2);
                  unint64_t v33 = v37;
                }
              }

              if (i < j)
              {
                unint64_t v38 = *i;
                unint64_t v39 = *j;
                do
                {
                  unint64_t *i = v39;
                  *int j = v38;
                  unint64_t v40 = i[1];
                  i[1] = j[1];
                  j[1] = v40;
                  do
                  {
                    unint64_t v41 = i[2];
                    i += 2;
                    unint64_t v38 = v41;
                  }

                  while (v15 >= v41 && (v38 < v15 || v17 >= i[1]));
                  do
                  {
                    do
                    {
                      unint64_t v42 = *(j - 2);
                      j -= 2;
                      unint64_t v39 = v42;
                    }

                    while (v15 < v42);
                  }

                  while (v39 >= v15 && v17 < j[1]);
                }

                while (i < j);
              }

              if (i - 2 != v7)
              {
                *unsigned int v7 = *(i - 2);
                v7[1] = *(i - 1);
              }

              a4 = 0;
              *(i - 2) = v15;
              *(i - 1) = v17;
              continue;
            }
          }

  v147->nelts = 0;
  GTMTLSMContext_getObjects((_DWORD *)(*a1)[8], (unint64_t)a1[4], v147);
  GTMTLIndirectResources_allResourcesByKey(v265, (_DWORD **)*a1, (unint64_t)a1[4], 1, p[0]);
  if (v147->nelts < 1)
  {
LABEL_189:
    v190 = -[NSMutableDictionary copy](v236, "copy");
    v191 = *(void **)(a2 + 16);
    *(void *)(a2 + 16) = v190;

    id v192 = -[NSMutableDictionary copy](v233, "copy");
    id v193 = *(void **)(a2 + 24);
    *(void *)(a2 + 24) = v192;

    v194 = -[NSMutableDictionary copy](v227, "copy");
    id v183 = *(void **)(a2 + 32);
    *(void *)(a2 + 32) = v194;
    v195 = 1LL;
    goto LABEL_209;
  }

  id v180 = 0LL;
  while (1)
  {
    id v181 = *(void *)&v147->elts[8 * v180];
    id v182 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  *(void *)(v181 + 128)));
    id v183 = (void *)objc_claimAutoreleasedReturnValue([v242 objectForKey:v182]);

    if (v183)
    {
      MTLIntersectionFunctionTableDescriptor = MakeMTLIntersectionFunctionTableDescriptor(*(void *)(v181 + 104));
      v185 = (void *)objc_claimAutoreleasedReturnValue(MTLIntersectionFunctionTableDescriptor);
      v186 = [v183 newIntersectionFunctionTableWithDescriptor:v185 stage:*(unsigned __int8 *)(v181 + 160)];
      if ((UpdateIntersectionFunctionTable((uint64_t)a1, v186, v181, v236, v233, v265) & 1) == 0)
      {
        if (a3)
        {
          id v198 = GTUpdateShaderMakeError( 1u,  @"Internal: Could not update intersection function table for render pipeline",  0LL,  0LL);
          *a3 = (id)objc_claimAutoreleasedReturnValue(v198);
        }

        goto LABEL_208;
      }

      goto LABEL_187;
    }

    v187 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  *(void *)(v181 + 120)));
    id v183 = (void *)objc_claimAutoreleasedReturnValue([v230 objectForKey:v187]);

    if (v183) {
      break;
    }
LABEL_188:
    ++v180;
    id v147 = v239;
    if (v180 >= v239->nelts) {
      goto LABEL_189;
    }
  }

  uint64_t v188 = MakeMTLIntersectionFunctionTableDescriptor(*(void *)(v181 + 104));
  v185 = (void *)objc_claimAutoreleasedReturnValue(v188);
  v186 = [v183 newIntersectionFunctionTableWithDescriptor:v185];
  if ((UpdateIntersectionFunctionTable((uint64_t)a1, v186, v181, v236, v233, v265) & 1) != 0)
  {
LABEL_187:
    v189 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  *(void *)(v181 + 8)));
    -[NSMutableDictionary setObject:forKeyedSubscript:](v227, "setObject:forKeyedSubscript:", v186, v189);

    goto LABEL_188;
  }

  if (a3)
  {
    v200 = GTUpdateShaderMakeError( 1u,  @"Internal: Could not update intersection function table for compute pipeline",  0LL,  0LL);
    *a3 = (id)objc_claimAutoreleasedReturnValue(v200);
  }

LABEL_156:
            id v46 = v7 + 2;
            if (v7 + 2 == a2) {
              return result;
            }
          }

          unint64_t v78 = v75[3];
          do
          {
            do
            {
LABEL_152:
              BOOL v79 = v75;
              unint64_t v80 = v77;
              unint64_t v81 = *(v75 - 2);
              v75 -= 2;
              unint64_t v77 = v81;
              unint64_t v82 = v75[3];
              void v75[4] = v80;
              v75[5] = v82;
            }

            while (v76 < v81);
          }

          while (v77 >= v76 && v78 < *(v79 - 1));
          *BOOL v79 = v76;
          v79[1] = v78;
          goto LABEL_156;
        }

        if (v48) {
          return result;
        }
        uint64_t v49 = 0LL;
        unsigned int v50 = i;
        do
        {
          uint64_t v51 = v50;
          unsigned int v50 = v46;
          unint64_t v52 = v51[2];
          unint64_t v53 = *v51;
          if (v52 >= *v51)
          {
            if (v53 < v52) {
              goto LABEL_115;
            }
            unint64_t v54 = v51[3];
            if (v54 >= v51[1]) {
              goto LABEL_115;
            }
          }

          else
          {
            unint64_t v54 = v51[3];
          }

          void v51[2] = v53;
          v50[1] = v51[1];
          uint64_t v55 = i;
          if (v51 == i) {
            goto LABEL_114;
          }
          uint64_t v56 = v49;
          while (1)
          {
            unint64_t v57 = *(unint64_t *)((char *)i + v56 - 16);
            if (v52 >= v57) {
              break;
            }
            unint64_t v58 = *(unint64_t *)((char *)i + v56 - 8);
LABEL_111:
            v51 -= 2;
            unsigned __int8 v59 = (unint64_t *)((char *)i + v56);
            unint64_t *v59 = v57;
            v59[1] = v58;
            v56 -= 16LL;
            if (!v56)
            {
              uint64_t v55 = i;
              goto LABEL_114;
            }
          }

          if (v57 >= v52)
          {
            uint64_t v55 = (unint64_t *)((char *)i + v56);
            unint64_t v58 = *(unint64_t *)((char *)i + v56 - 8);
            if (v54 >= v58) {
              goto LABEL_114;
            }
            goto LABEL_111;
          }

          uint64_t v55 = v51;
LABEL_114:
          unint64_t *v55 = v52;
          v55[1] = v54;
LABEL_115:
          id v46 = v50 + 2;
          v49 += 16LL;
        }

        while (v50 + 2 != a2);
        return result;
    }
  }

                    unint64_t v74 = v454 + v76;
                    unint64_t v58 = v484;
                    if (v74 < v456) {
                      continue;
                    }
                    break;
                  }

unint64_t *std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned long long,unsigned long long> *>( unint64_t *result, unint64_t *a2, unint64_t *a3)
{
  unint64_t v3 = *a2;
  unint64_t v4 = *result;
  if (*a2 >= *result && (v4 < v3 || a2[1] >= result[1]))
  {
    unint64_t v7 = *a3;
    if (*a3 < v3 || v3 >= v7 && a3[1] < a2[1])
    {
      *a2 = v7;
      *a3 = v3;
      id v8 = a2 + 1;
      unint64_t v9 = a2[1];
      a2[1] = a3[1];
      a3[1] = v9;
      unint64_t v10 = *a2;
      unint64_t v11 = *result;
      if (*a2 < *result || v11 >= v10 && *v8 < result[1])
      {
        *result++ = v10;
        *a2 = v11;
LABEL_18:
        unint64_t v15 = *result;
        void *result = *v8;
        *id v8 = v15;
      }
    }
  }

  else
  {
    unint64_t v5 = *a3;
    if (*a3 < v3 || v3 >= v5 && a3[1] < a2[1])
    {
      *result++ = v5;
      *a3 = v4;
      id v6 = a3 + 1;
LABEL_17:
      id v8 = v6;
      goto LABEL_18;
    }

    void *result = v3;
    *a2 = v4;
    unint64_t v12 = result[1];
    result[1] = a2[1];
    a2[1] = v12;
    unint64_t v13 = *a3;
    unint64_t v14 = *a2;
    if (*a3 < *a2 || v14 >= v13 && a3[1] < v12)
    {
      *a2 = v13;
      *a3 = v14;
      id v6 = a3 + 1;
      __n128 result = a2 + 1;
      goto LABEL_17;
    }
  }

  return result;
}

unint64_t *std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned long long,unsigned long long> *>( unint64_t *a1, unint64_t *a2, unint64_t *a3, unint64_t *a4)
{
  __n128 result = std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned long long,unsigned long long> *>( a1,  a2,  a3);
  unint64_t v9 = *a4;
  unint64_t v10 = *a3;
  if (*a4 < *a3 || v10 >= v9 && a4[1] < a3[1])
  {
    *a3 = v9;
    *a4 = v10;
    unint64_t v11 = a3[1];
    a3[1] = a4[1];
    a4[1] = v11;
    unint64_t v12 = *a3;
    unint64_t v13 = *a2;
    if (*a3 < *a2 || v13 >= v12 && a3[1] < a2[1])
    {
      *a2 = v12;
      *a3 = v13;
      unint64_t v14 = a2[1];
      a2[1] = a3[1];
      a3[1] = v14;
      unint64_t v15 = *a2;
      unint64_t v16 = *a1;
      if (*a2 < *a1 || v16 >= v15 && a2[1] < a1[1])
      {
        *a1 = v15;
        *a2 = v16;
        unint64_t v17 = a1[1];
        a1[1] = a2[1];
        a2[1] = v17;
      }
    }
  }

  return result;
}

unint64_t *std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned long long,unsigned long long> *>( unint64_t *a1, unint64_t *a2, unint64_t *a3, unint64_t *a4, unint64_t *a5)
{
  __n128 result = std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned long long,unsigned long long> *>( a1,  a2,  a3,  a4);
  unint64_t v11 = *a5;
  unint64_t v12 = *a4;
  if (*a5 < *a4 || v12 >= v11 && a5[1] < a4[1])
  {
    *a4 = v11;
    *a5 = v12;
    unint64_t v13 = a4[1];
    a4[1] = a5[1];
    a5[1] = v13;
    unint64_t v14 = *a4;
    unint64_t v15 = *a3;
    if (*a4 < *a3 || v15 >= v14 && a4[1] < a3[1])
    {
      *a3 = v14;
      *a4 = v15;
      unint64_t v16 = a3[1];
      a3[1] = a4[1];
      a4[1] = v16;
      unint64_t v17 = *a3;
      unint64_t v18 = *a2;
      if (*a3 < *a2 || v18 >= v17 && a3[1] < a2[1])
      {
        *a2 = v17;
        *a3 = v18;
        unint64_t v19 = a2[1];
        a2[1] = a3[1];
        a3[1] = v19;
        unint64_t v20 = *a2;
        unint64_t v21 = *a1;
        if (*a2 < *a1 || v21 >= v20 && a2[1] < a1[1])
        {
          *a1 = v20;
          *a2 = v21;
          unint64_t v22 = a1[1];
          a1[1] = a2[1];
          a2[1] = v22;
        }
      }
    }
  }

  return result;
}

BOOL std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned long long,unsigned long long> *>( unint64_t *a1, unint64_t *a2)
{
  uint64_t v4 = ((char *)a2 - (char *)a1) >> 4;
  BOOL result = 1LL;
  switch(v4)
  {
    case 0LL:
    case 1LL:
      return result;
    case 2LL:
      unint64_t v6 = *(a2 - 2);
      unint64_t v7 = *a1;
      if (v6 < *a1 || v7 >= v6 && *(a2 - 1) < a1[1])
      {
        *a1 = v6;
        *(a2 - 2) = v7;
        unint64_t v8 = a1[1];
        a1[1] = *(a2 - 1);
        *(a2 - 1) = v8;
      }

      return result;
    case 3LL:
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned long long,unsigned long long> *>( a1,  a1 + 2,  a2 - 2);
      return 1LL;
    case 4LL:
      std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned long long,unsigned long long> *>( a1,  a1 + 2,  a1 + 4,  a2 - 2);
      return 1LL;
    case 5LL:
      std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned long long,unsigned long long> *>( a1,  a1 + 2,  a1 + 4,  a1 + 6,  a2 - 2);
      return 1LL;
    default:
      unint64_t v9 = a1 + 4;
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned long long,unsigned long long> *>( a1,  a1 + 2,  a1 + 4);
      unint64_t v10 = a1 + 6;
      if (a1 + 6 == a2) {
        return 1LL;
      }
      uint64_t v11 = 0LL;
      int v12 = 0;
      break;
  }

  do
  {
    unint64_t v13 = *v10;
    unint64_t v14 = *v9;
    if (*v10 >= *v9)
    {
      if (v14 < v13) {
        goto LABEL_23;
      }
      unint64_t v15 = v10[1];
      if (v15 >= v9[1]) {
        goto LABEL_23;
      }
    }

    else
    {
      unint64_t v15 = v10[1];
    }

    unint64_t *v10 = v14;
    v10[1] = v9[1];
    unint64_t v16 = a1;
    if (v9 == a1) {
      goto LABEL_22;
    }
    uint64_t v17 = v11;
    while (1)
    {
      unint64_t v18 = (char *)a1 + v17;
      unint64_t v19 = *(unint64_t *)((char *)a1 + v17 + 16);
      if (v13 < v19)
      {
        unint64_t v20 = *((void *)v18 + 3);
        goto LABEL_18;
      }

      if (v19 < v13)
      {
        unint64_t v16 = v9;
        goto LABEL_22;
      }

      unint64_t v20 = *(unint64_t *)((char *)a1 + v17 + 24);
      if (v15 >= v20) {
        break;
      }
LABEL_18:
      v9 -= 2;
      *((void *)v18 + 4) = v19;
      *(unint64_t *)((char *)a1 + v17 + 40) = v20;
      v17 -= 16LL;
      if (v17 == -32)
      {
        unint64_t v16 = a1;
        goto LABEL_22;
      }
    }

    unint64_t v16 = (unint64_t *)((char *)a1 + v17 + 32);
LABEL_22:
    unint64_t *v16 = v13;
    v16[1] = v15;
    if (++v12 == 8) {
      return v10 + 2 == a2;
    }
LABEL_23:
    unint64_t v9 = v10;
    v11 += 16LL;
    v10 += 2;
  }

  while (v10 != a2);
  return 1LL;
}

void GTUSCSamplingStreamingManagerHelper::SetupSourceForFrameTime(id *this, uint64_t a2, int a3)
{
  unint64_t v6 = (void *)objc_claimAutoreleasedReturnValue([this[2] firstObject]);
  if ([this[3] count])
  {
    if (!GTAGXPerfStateControl::IsGPUPerformanceStateInduced((GTAGXPerfStateControl *)(this + 5)))
    {
      uint64_t v7 = *((unsigned int *)*this + 18);
      if ((_DWORD)v7)
      {
        GTAGXPerfStateControl::EnableConsistentGPUPerfState((uint64_t)(this + 5), v7);
        id v8 = GTApplePMPPerfStateControl::EnableConsistentPerfState( (GTApplePMPPerfStateControl *)(this + 8),  (*((_DWORD *)*this + 18) - 1));
        uint64_t v9 = objc_claimAutoreleasedReturnValue(v8);
        id v10 = this[261];
        this[261] = (id)v9;
      }

      else
      {
        id v11 = GTApplePMPPerfStateControl::EnableConsistentPerfState((GTApplePMPPerfStateControl *)(this + 8), 1LL);
        uint64_t v12 = objc_claimAutoreleasedReturnValue(v11);
        id v13 = this[261];
        this[261] = (id)v12;

        unint64_t v21 = @"LockGPUPerfState";
        unint64_t v14 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInt:](&OBJC_CLASS___NSNumber, "numberWithUnsignedInt:", a2));
        unint64_t v22 = v14;
        unint64_t v15 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v22,  &v21,  1LL));
        [v6 setOptions:v15];
      }
    }

    unint64_t v16 = (void *)objc_claimAutoreleasedReturnValue([this[3] lastObject]);
    uint64_t v17 = v16;
    if (!a3) {
      goto LABEL_7;
    }
    if (([v16 requestTriggers:this[257] firstErrorIndex:0] & 1) == 0)
    {
      unint64_t v19 = (void *)objc_claimAutoreleasedReturnValue([v17 name]);
      NSLog(@"Fail, error while requesting triggers for %@", v19);
    }

    [v17 setOptions:0];
    if ([v17 requestCounters:this[249] firstErrorIndex:0])
    {
LABEL_7:
      if ([v17 setEnabled:1])
      {
LABEL_10:

        goto LABEL_11;
      }

      unint64_t v18 = (void *)objc_claimAutoreleasedReturnValue([v17 name]);
      NSLog(@"Fail, error while enabling source[%@]", v18);
    }

    else
    {
      id v20 = [this[249] count];
      unint64_t v18 = (void *)objc_claimAutoreleasedReturnValue([v17 name]);
      NSLog(@"Fail, error while requesting %lu counter for source[%@]", v20, v18);
    }

    goto LABEL_10;
  }

LABEL_11:
}

  if (*(void *)a1)
  {
    unint64_t v14 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:"));
    -[MTLCounterSampleBufferDescriptor setLabel:](v4, "setLabel:", v14);
  }

  -[MTLCounterSampleBufferDescriptor setStorageMode:](v4, "setStorageMode:", *(unsigned __int8 *)(a1 + 44));
  -[MTLCounterSampleBufferDescriptor setSampleCount:](v4, "setSampleCount:", *(unsigned int *)(a1 + 40));

  return v4;
}

  return v6;
}

      if (!vm_protect(v6, v8 + v7 - vm_page_size, vm_page_size, 0, 0)) {
        break;
      }
    }
}
}

        unint64_t v16 = -1LL;
      }

      id v20 = v16 + v13;
      unint64_t v19 = v18 <= 79 && (v18 == 22 || v18 == 57);
LABEL_20:
      unint64_t v21 = v20 & -v19;
      unint64_t v22 = RequestSize((uint64_t)&v17[v14 + 64]);
      if ((unint64_t)(v21 + v22) > 0x2000000)
      {
        unint64_t v26 = v5;
        goto LABEL_39;
      }

      unint64_t v23 = 0LL;
      if (v18 <= 56)
      {
        if (v18 != 16)
        {
          if (v18 != 22) {
LABEL_29:
          }
            unint64_t v23 = -1LL;
LABEL_30:
          BOOL v25 = v23 + v13;
          unint64_t v24 = v18 <= 79 && (v18 == 22 || v18 == 57);
          goto LABEL_38;
        }

        BOOL v25 = v13 + 31;
        unint64_t v24 = 32LL;
      }

      else
      {
        switch(v18)
        {
          case '9':
            goto LABEL_30;
          case 'V':
            BOOL v25 = v13 + 255;
            unint64_t v24 = 256LL;
            break;
          case 'P':
            unint64_t v24 = *(unsigned __int16 *)&v17[v14 + 124];
            BOOL v25 = v13 + v24 - 1;
            break;
          default:
            goto LABEL_29;
        }
      }

  id v13 = (void *)GTMTLSMContext_lastObject(*a1, v19, a5);
  if (!v13)
  {
LABEL_19:
    unint64_t v14 = 0LL;
    goto LABEL_20;
  }

  unint64_t v44 = (void *)objc_claimAutoreleasedReturnValue([v11 computePipelineStateForKey:*(void *)(a3 + 8)]);
  unint64_t v42 = (void *)objc_claimAutoreleasedReturnValue([v11 libraryForKey:v13[5]]);
  if (!v42)
  {

    id v13 = 0LL;
    goto LABEL_19;
  }

  unint64_t v22 = (void *)objc_claimAutoreleasedReturnValue([v11 functionMap]);
  unint64_t v53 = 0LL;
  unint64_t v23 = ObtainTracingFunction(v46, v42, a4, (uint64_t)v13, v22, (uint64_t)&v53);
  id v13 = (void *)objc_claimAutoreleasedReturnValue(v23);
  unint64_t v43 = v53;

  unint64_t v24 = v13;
  if (v13)
  {
    unint64_t v39 = v13;
    GTMTLSMComputePipelineState_computePipelineDescriptor(a1, a3, v51, a6);
    BOOL v25 = MakeMTLComputePipelineDescriptor;
    unint64_t v26 = (void *)objc_claimAutoreleasedReturnValue([v11 computePipelineDescriptorMap]);
    unint64_t v27 = ((uint64_t (*)(void *, void *))v25)(v51, v26);
    id v28 = (void *)objc_claimAutoreleasedReturnValue(v27);

    unint64_t v40 = v28;
    [v28 setComputeFunction:v39];
    unint64_t v29 = ObtainTracingLinkedFunctions( (const GTMTLSMContext *)a1,  v11,  (GTMTLReplayAccessTracking *)a4,  (uint64_t)v52,  a5);
    unint64_t v30 = (void *)objc_claimAutoreleasedReturnValue(v29);
    [v28 setLinkedFunctions:v30];

    if (v44) {
      objc_msgSend(v28, "setMaxTotalThreadsPerThreadgroup:", objc_msgSend(v44, "maxTotalThreadsPerThreadgroup"));
    }
    if (v45)
    {
      unsigned int v50 = v43;
      id v13 = [v46 newComputePipelineStateWithDescriptor:v28 options:v41 reflection:0 error:&v50];
      unint64_t v31 = v50;

      BOOL v32 = 0LL;
      unint64_t v43 = v31;
    }

    else
    {
      BOOL v48 = v43;
      uint64_t v49 = 0LL;
      id v13 = [v46 newComputePipelineStateWithDescriptor:v28 options:v41 | 1 reflection:&v49 error:&v48];
      BOOL v32 = v49;
      unint64_t v34 = v48;

      unint64_t v35 = (void *)objc_claimAutoreleasedReturnValue([v32 bindings]);
      uint64_t v36 = TraceBufferBindingIndex(v35, *(_DWORD *)(a4 + 256));

      uint64_t v47 = *(void *)(a3 + 8);
      *((_DWORD *)std::__hash_table<std::__hash_value_type<unsigned long long,unsigned int>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned int>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned int>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned int>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long &&>,std::tuple<>>( a4,  v47,  &v47)
      + 6) = v36;
      unint64_t v43 = v34;
    }

    if (v13)
    {
      unint64_t v37 = (id *)std::__hash_table<std::__hash_value_type<unsigned long long,objc_object  {objcproto23MTLComputePipelineState}* {__strong}>,std::__unordered_map_hasher<unsigned long long,objc_object  {objcproto23MTLComputePipelineState}* {__strong},std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,objc_object  {objcproto23MTLComputePipelineState}* {__strong},std::equal_to,std::hash,true>,std::allocator<objc_object  {objcproto23MTLComputePipelineState}* {__strong}>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long const&>,std::piecewise_construct_t const&<>>( (uint64_t *)(a4 + 120),  v12,  v54);
      objc_storeStrong(v37 + 3, v13);
      if (*(_DWORD *)(a4 + 256) == 8)
      {
        unint64_t v38 = *(void *)(a3 + 8);
        CreateComputeFunctionHandles(a4, v38, v52[2], (uint64_t)v52[3]);
        CreateComputeFunctionHandles(a4, v38, v52[0], (uint64_t)v52[1]);
      }
    }

    else
    {
      GTMTLReplay_handleNSError(v43);
    }

    unint64_t v24 = v39;
  }

  unint64_t v14 = v24;

  if (v14) {
    goto LABEL_2;
  }
LABEL_20:

  return v14;
}

  apr_pool_create_ex(&newpool, 0LL, 0LL, a4);
  v195 = a1;
  apr_pool_create_ex(&v194, newpool, 0LL, v10);
  unsigned int v144 = (apr_pool_t **)GTCaptureArchiveDecompressor_create(v194);
  uint64_t v12 = (id)objc_opt_new(&OBJC_CLASS___GTMutableShaderProfilerStreamData, v11);
  id v193 = v12;
  id v13 = **a1;
  if (v13)
  {
    uint64_t v4 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", **a1));
    unint64_t v14 = (void *)objc_claimAutoreleasedReturnValue([v4 lastPathComponent]);
    uint64_t v12 = v193;
  }

  else
  {
    unint64_t v14 = 0LL;
  }

  [v12 setTraceName:v14];
  if (v13)
  {
  }

  unsigned int v141 = a1;
  __int128 v150 = (uint64_t)v195[2];
  unint64_t v15 = v195[14];
  unint64_t v158 = v195[15];
  memset(v191, 0, sizeof(v191));
  id v192 = 1065353216;
  memset(v189, 0, sizeof(v189));
  v190 = 1065353216;
  v187 = 0LL;
  v186 = 0LL;
  uint64_t v188 = 0LL;
  v185 = 0LL;
  id v184 = 0LL;
  id v183 = 0LL;
  if (*((int *)v15 + 3) >= 1)
  {
    unint64_t v16 = 0LL;
    uint64_t v17 = 0LL;
    __p = 0LL;
    unint64_t v18 = 0LL;
    id v147 = 0LL;
    uint64_t v148 = 0LL;
    unint64_t v19 = 0LL;
    int64x2_t v151 = 0LL;
    char v142 = 0LL;
    id v20 = 0;
    id v161 = 0LL;
    uint64_t v145 = v15;
    while (1)
    {
      unint64_t v156 = v19;
      unint64_t v21 = v15[3];
      __int128 v154 = v20;
      unint64_t v22 = v20;
      unint64_t v23 = (uint64_t *)(v21 + 32LL * v20);
      unint64_t v24 = v158[3];
      BOOL v25 = *v23;
      unint64_t v26 = v24 + (*v23 << 6);
      if ((*(_BYTE *)(v26 + 15) & 0x40) != 0 && (*((_DWORD *)v23 + 7) + 12542) < 0xFFFFFFFE)
      {
        unint64_t v19 = v156;
LABEL_231:
        id v109 = v154;
        goto LABEL_232;
      }

      __int128 v155 = (unint64_t *)(v21 + 32LL * v20);
      __int128 v153 = (unint64_t *)(v24 + (*v23 << 6));
      unint64_t v29 = *(_DWORD *)(v26 + 8);
      id v28 = (int *)(v26 + 8);
      unint64_t v27 = v29;
      int FuncEnumConstructorType = GetFuncEnumConstructorType(v29);
      if (FuncEnumConstructorType == 51)
      {
        id v182 = 0u;
        id v181 = 0u;
        id v180 = 0u;
        unsigned int v179 = 0u;
        int64x2_t v178 = 0u;
        unint64_t v31 = *v28;
        if (*v28 == -15343)
        {
          unint64_t v35 = 0LL;
          *((void *)&v179 + 1) = *v153;
          __int128 v111 = v156;
          unint64_t v33 = v155;
        }

        else
        {
          BOOL v32 = (uint64_t)v195[2];
          unint64_t v33 = v155;
          if (v31 == -15313)
          {
            int v110 = GTTraceFunc_argumentBytesWithMap(v153, *(unsigned __int8 *)(v24 + (v25 << 6) + 13), (uint64_t)v195[2]);
            *((void *)&v181 + 1) = GTTraceFunc_argumentBytesWithMap(v153, v110[8], v32);
            unint64_t v35 = *((void *)&v178 + 1);
          }

          else if (v31 == -15333)
          {
            unint64_t v34 = GTTraceFunc_argumentBytesWithMap(v153, *(unsigned __int8 *)(v24 + (v25 << 6) + 13), (uint64_t)v195[2]);
            int64x2_t v178 = 0u;
            unsigned int v179 = 0u;
            id v180 = 0u;
            id v181 = 0u;
            id v182 = 0u;
            unint64_t v35 = *((void *)v34 + 1);
            if (v35)
            {
              LODWORD(v17_Block_object_dispose(&STACK[0x3B0], 8) = 51;
              *((void *)&v178 + 1) = v35;
              *(void *)&unsigned int v179 = *v153;
              *((void *)&v179 + 1) = -1LL;
              BYTE9(v182) = 1;
              *(void *)&id v181 = *(void *)v34;
            }
          }

          else
          {
            unint64_t v35 = 0LL;
          }

          __int128 v111 = v156;
        }

        __int128 v112 = *(void *)(*(void *)(*find_entry((uint64_t)v195[1], (_BYTE *)&v178 + 8, 8uLL, 0LL) + 32LL) + 8LL);
        __int128 v113 = *v33;
        __int128 v114 = v151;
        unsigned int v115 = (v151 - v111) >> 5;
        if ((unint64_t)v151 >= v147)
        {
          unsigned int v116 = v115 + 1;
          else {
            uint64_t v117 = v116;
          }
          if (v117) {
            uint64_t v117 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<GTMMappedBufferBlock>>(v117);
          }
          else {
            uint64_t v118 = 0LL;
          }
          unsigned __int8 v121 = (void *)(v117 + 32 * v115);
          *unsigned __int8 v121 = v35;
          v121[1] = v112;
          v121[2] = v113;
          *((_DWORD *)v121 + 6) = v115;
          *((_DWORD *)v121 + 7) = 0;
          unint64_t v122 = v156;
          unsigned int v123 = v151;
          if (v151 != v156)
          {
            BOOL v124 = v117 + 32 * v115;
            do
            {
              unint64_t v125 = *((_OWORD *)v123 - 1);
              unint64_t v19 = (char *)(v124 - 32);
              *(_OWORD *)(v124 - 32) = *((_OWORD *)v123 - 2);
              *(_OWORD *)(v124 - 16) = v125;
              v123 -= 32;
              v124 -= 32LL;
            }

            while (v123 != v156);
            goto LABEL_228;
          }

          goto LABEL_227;
        }

        goto LABEL_207;
      }

      bzero(&v178, 0x2B90uLL);
      bzero(&v176, 0x2B90uLL);
      ++*((_DWORD *)v151 - 1);
      __int128 v175 = 0LL;
      id v174 = 0;
      v173[0] = (unint64_t *)&v175;
      v173[1] = (unint64_t *)&v174;
      v173[2] = (unint64_t *)v191;
      v173[3] = (unint64_t *)&v183;
      v173[4] = (unint64_t *)&v195;
      v173[5] = (unint64_t *)&v193;
      v173[6] = (unint64_t *)&v186;
      unint64_t v41 = *v155;
      unsigned int v143 = v21 + 32 * v22;
      if (*v155 < *(void *)(v143 + 8))
      {
        uint64_t v160 = ((unint64_t)(v151 - v156) >> 5) - 1;
        do
        {
          int64x2_t v157 = v158[3];
          unint64_t v42 = v157 + (v41 << 6);
          unint64_t v43 = (int *)(v42 + 8);
          unint64_t v44 = IsFuncEnumParallelCommandEncoderCall(*(_DWORD *)(v42 + 8));
          if (v44) {
            unint64_t v45 = (unint64_t *)&v178;
          }
          else {
            unint64_t v45 = (unint64_t *)&v176;
          }
          if (v44) {
            id v46 = (uint64_t *)&v178 + 1;
          }
          else {
            id v46 = &v177;
          }
          GTMTLSMCommandEncoder_processTraceFunc((uint64_t)v45, (uint64_t *)v42, (uint64_t)v195[2]);
          uint64_t v47 = v45[1];
          BOOL v48 = std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::find<unsigned long long>( v189,  v47);
          if (v48)
          {
            LODWORD(v49) = *((_DWORD *)v48 + 6);
          }

          else if (__p == v18 || *((void *)v18 - 3) != *v155)
          {
            v149 = v18;
            unint64_t v146 = *(void *)(*(void *)(*find_entry((uint64_t)v195[1], v46, 8uLL, 0LL) + 32LL) + 8LL);
            unint64_t v68 = *v155;
            unint64_t v69 = std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long long>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long const&>,std::tuple<>>( (uint64_t)v189,  v45[1],  v46);
            uint64_t v49 = (v149 - __p) / 40;
            unsigned int v70 = (unint64_t)(v17 - v16) >> 5;
            v69[3] = v49;
            if (v149 >= v148)
            {
              unint64_t v73 = v49 + 1;
              if (0x999999999999999ALL * ((v148 - __p) >> 3) > v73) {
                unint64_t v73 = 0x999999999999999ALL * ((v148 - __p) >> 3);
              }
              if (0xCCCCCCCCCCCCCCCDLL * ((v148 - __p) >> 3) >= 0x333333333333333LL) {
                unint64_t v74 = 0x666666666666666LL;
              }
              else {
                unint64_t v74 = v73;
              }
              if (v74)
              {
                if (v74 > 0x666666666666666LL) {
                  std::__throw_bad_array_new_length[abi:nn180100]();
                }
                id v75 = v74;
                unint64_t v76 = (char *)operator new(40 * v74);
                unint64_t v77 = v146;
                LODWORD(v70) = (unint64_t)(v17 - v16) >> 5;
              }

              else
              {
                unint64_t v76 = 0LL;
                id v75 = 0LL;
                unint64_t v77 = v146;
              }

              unint64_t v100 = &v76[40 * v49];
              *(void *)unint64_t v100 = v47;
              *((void *)v100 + 1) = v77;
              *((void *)v100 + 2) = v68;
              *((_DWORD *)v100 + 6) = v49;
              *((_DWORD *)v100 + 7) = v70;
              *((_DWORD *)v100 + _Block_object_dispose(&STACK[0x3B0], 8) = v160;
              *((_DWORD *)v100 + 9) = 0;
              unint64_t v101 = v149;
              if (__p == v149)
              {
                uint64_t v106 = &v76[40 * v49];
                unint64_t v103 = __p;
              }

              else
              {
                uint64_t v102 = &v76[40 * v49];
                unint64_t v103 = __p;
                do
                {
                  unint64_t v104 = *(_OWORD *)(v101 - 40);
                  uint64_t v105 = *(_OWORD *)(v101 - 24);
                  uint64_t v106 = v102 - 40;
                  *((void *)v102 - 1) = *((void *)v101 - 1);
                  *(_OWORD *)(v102 - 24) = v105;
                  *(_OWORD *)(v102 - 40) = v104;
                  v101 -= 40;
                  v102 -= 40;
                }

                while (v101 != __p);
              }

              uint64_t v148 = &v76[40 * v75];
              unint64_t v18 = v100 + 40;
              if (v103) {
                operator delete(v103);
              }
              __p = v106;
            }

            else
            {
              *(void *)v149 = v47;
              *((void *)v149 + 1) = v146;
              *((void *)v149 + 2) = v68;
              *((_DWORD *)v149 + 6) = v49;
              *((_DWORD *)v149 + 7) = v70;
              *((void *)v149 + 4) = v160;
              unint64_t v18 = v149 + 40;
            }
          }

          else
          {
            uint64_t v49 = -1 - 0x3333333333333333LL * ((v18 - __p) >> 3);
          }

          unsigned int v50 = *v43;
          if (*v43 == -16279 || v50 == -16337)
          {
            __int128 v175 = *((void *)GTTraceFunc_argumentBytesWithMap( (void *)v42,  *(unsigned __int8 *)(v157 + (v41 << 6) + 13),  v150)
                   + 1);
            _GTShaderProfilerStreamDataFromReplayDataSource(GTMTLReplayDataSource const*,apr_pool_t *)::$_0::operator()( v173,  v41,  *v43);
            unsigned int v50 = *v43;
          }

          if (!IsFuncEnumGPUCommandCall(v50))
          {
            if (v50 >> 2 == 1073737833)
            {
              unint64_t v54 = v49;
              p = *v144;
              GTMTLSMContext_indirectCommandBufferResources((uint64_t)v170, (_DWORD **)v195[5], *v153, p);
              GetExecuteCommandsInBufferArgs((uint64_t)&v164, v158[3] + (v41 << 6), (uint64_t)v195[2]);
              Object = GTMTLSMContext_getObject(*v195[5], v164, *v153);
              GTMTLCreateIndirectCommandEncoder((uint64_t)v168, Object[13]);
              memcpy(__dst, v45, sizeof(__dst));
              if (*(_DWORD *)v45 == 28)
              {
                if ((GT_SUPPORT_0 & 0x10) != 0)
                {
                  uint64_t v88 = v166;
                  if (v166)
                  {
                    int v89 = 0LL;
                    do
                    {
                      id v90 = v89 + v165;
                      id v171 = v167 + v169 * ((int)v89 + v165);
                      if (GTMTLSMComputeCommandEncoder_loadIndirectCommand( (uint64_t)&__dst[7],  v168,  v171,  v170))
                      {
                        __int128 v175 = __dst[8];
                        _GTShaderProfilerStreamDataFromReplayDataSource(GTMTLReplayDataSource const*,apr_pool_t *)::$_0::operator()( v173,  v41,  4294950959LL);
                        int64_t v91 = (v17 - v16) >> 5;
                        uint64_t v92 = v174;
                        if ((unint64_t)v17 >= v161)
                        {
                          uint64_t v93 = v91 + 1;
                          else {
                            unint64_t v94 = v93;
                          }
                          if (v94) {
                            unint64_t v94 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<GTMMappedBufferBlock>>(v94);
                          }
                          else {
                            uint64_t v95 = 0LL;
                          }
                          unint64_t v96 = v94 + 32 * v91;
                          *(_DWORD *)unint64_t v96 = v91;
                          *(_DWORD *)(v96 + 4) = v54;
                          *(_DWORD *)(v96 + _Block_object_dispose(&STACK[0x3B0], 8) = v160;
                          *(_DWORD *)(v96 + 12) = v92;
                          *(void *)(v96 + 16) = v41;
                          *(_DWORD *)(v96 + 24) = 2;
                          *(_DWORD *)(v96 + 2_Block_object_dispose(&STACK[0x3B0], 8) = v90;
                          if (v17 == v16)
                          {
                            unint64_t v99 = (char *)(v94 + 32 * v91);
                          }

                          else
                          {
                            unint64_t v97 = v94 + 32 * v91;
                            do
                            {
                              uint64_t v98 = *((_OWORD *)v17 - 1);
                              unint64_t v99 = (char *)(v97 - 32);
                              *(_OWORD *)(v97 - 32) = *((_OWORD *)v17 - 2);
                              *(_OWORD *)(v97 - 16) = v98;
                              v17 -= 32;
                              v97 -= 32LL;
                            }

                            while (v17 != v16);
                          }

                          id v161 = v94 + 32 * v95;
                          uint64_t v17 = (char *)(v96 + 32);
                          if (v16) {
                            operator delete(v16);
                          }
                          unint64_t v16 = v99;
                        }

                        else
                        {
                          *(_DWORD *)uint64_t v17 = v91;
                          *((_DWORD *)v17 + 1) = v54;
                          *((_DWORD *)v17 + 2) = v160;
                          *((_DWORD *)v17 + 3) = v92;
                          *((void *)v17 + 2) = v41;
                          *((_DWORD *)v17 + 6) = 2;
                          *((_DWORD *)v17 + 7) = v90;
                          v17 += 32;
                        }

                        if (v92 != -1) {
                          ++v186[10 * v92 + 7];
                        }
                        ++*(_DWORD *)&__p[40 * v54 + 36];
                        uint64_t v88 = v166;
                      }

                      ++v89;
                    }

                    while (v88 > v89);
                  }
                }
              }

              else if (*(_DWORD *)v45 == 70)
              {
                uint64_t v56 = v166;
                if (v166)
                {
                  unint64_t v57 = 0LL;
                  do
                  {
                    unint64_t v58 = v57 + v165;
                    id v171 = v167 + v169 * ((int)v57 + v165);
                    if (GTMTLSMRenderCommandEncoder_loadIndirectCommand( (uint64_t)&__dst[7],  v168,  v171,  v170))
                    {
                      __int128 v175 = __dst[1075];
                      _GTShaderProfilerStreamDataFromReplayDataSource(GTMTLReplayDataSource const*,apr_pool_t *)::$_0::operator()( v173,  v41,  4294951017LL);
                      unsigned __int8 v59 = (v17 - v16) >> 5;
                      int64_t v60 = v174;
                      if ((unint64_t)v17 >= v161)
                      {
                        int64_t v61 = v59 + 1;
                        else {
                          int64_t v62 = v61;
                        }
                        if (v62) {
                          int64_t v62 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<GTMMappedBufferBlock>>(v62);
                        }
                        else {
                          uint64_t v63 = 0LL;
                        }
                        uint64_t v64 = v62 + 32 * v59;
                        *(_DWORD *)uint64_t v64 = v59;
                        *(_DWORD *)(v64 + 4) = v54;
                        *(_DWORD *)(v64 + _Block_object_dispose(&STACK[0x3B0], 8) = v160;
                        *(_DWORD *)(v64 + 12) = v60;
                        *(void *)(v64 + 16) = v41;
                        *(_DWORD *)(v64 + 24) = 1;
                        *(_DWORD *)(v64 + 2_Block_object_dispose(&STACK[0x3B0], 8) = v58;
                        if (v17 == v16)
                        {
                          unint64_t v67 = (char *)(v62 + 32 * v59);
                        }

                        else
                        {
                          unint64_t v65 = v62 + 32 * v59;
                          do
                          {
                            unint64_t v66 = *((_OWORD *)v17 - 1);
                            unint64_t v67 = (char *)(v65 - 32);
                            *(_OWORD *)(v65 - 32) = *((_OWORD *)v17 - 2);
                            *(_OWORD *)(v65 - 16) = v66;
                            v17 -= 32;
                            v65 -= 32LL;
                          }

                          while (v17 != v16);
                        }

                        id v161 = v62 + 32 * v63;
                        uint64_t v17 = (char *)(v64 + 32);
                        if (v16) {
                          operator delete(v16);
                        }
                        unint64_t v16 = v67;
                      }

                      else
                      {
                        *(_DWORD *)uint64_t v17 = v59;
                        *((_DWORD *)v17 + 1) = v54;
                        *((_DWORD *)v17 + 2) = v160;
                        *((_DWORD *)v17 + 3) = v60;
                        *((void *)v17 + 2) = v41;
                        *((_DWORD *)v17 + 6) = 1;
                        *((_DWORD *)v17 + 7) = v58;
                        v17 += 32;
                      }

                      if (v60 != -1) {
                        ++v186[10 * v60 + 7];
                      }
                      ++*(_DWORD *)&__p[40 * v54 + 36];
                      uint64_t v56 = v166;
                    }

                    ++v57;
                  }

                  while (v56 > v57);
                }
              }

              apr_pool_clear(p);
            }

            goto LABEL_165;
          }

          unint64_t v52 = v49;
          if ((IsFuncEnumDrawCall(v50) & 1) != 0)
          {
            unint64_t v53 = 1;
          }

          else
          {
            unint64_t v53 = 3;
            if (v50 <= -16080)
            {
              uint64_t v71 = v152;
              if (v50 != -16327 && v50 != -16220)
              {
                uint64_t v72 = -16137;
LABEL_107:
                if (v50 != v72)
                {
                  if (IsFuncEnumSampledBlitCallAGX(v50) || IsFuncEnumSampledBlitCall(v50))
                  {
                    ++v142;
                    unint64_t v53 = 4;
                  }

                  else if ((v50 + 15416) >= 3)
                  {
                    unint64_t v53 = v71;
                  }

                  else
                  {
                    unint64_t v53 = 5;
                  }
                }

                goto LABEL_112;
              }

    a2 = GTMTLSMContext_getObject(*a1, v12, a3);
  }

  if (v9 != 22) {
    return result;
  }
LABEL_7:
  uint64_t v12 = a2[6];
  if (v12) {
    goto LABEL_11;
  }
  return result;
}

void sub_710EC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id GTUSCSamplingStreamingManagerHelper::DrainRawFrameData(id *this)
{
  if (![this[3] count]) {
    return 0LL;
  }
  unsigned __int8 v2 = (void *)objc_claimAutoreleasedReturnValue([this[3] firstObject]);
  unint64_t v3 = (void *)objc_claimAutoreleasedReturnValue( +[NSMutableArray arrayWithCapacity:]( NSMutableArray,  "arrayWithCapacity:",  [v2 ringBufferNum]));

  uint64_t v4 = (void *)objc_claimAutoreleasedReturnValue([this[3] lastObject]);
  if ([v4 isEnabled])
  {
    for (uint64_t i = 0LL; ; uint64_t i = (i + 1))
    {
      if (i >= [v4 ringBufferNum])
      {
        id v13 = v3;
        goto LABEL_16;
      }

      if (([v4 ringBufferInfoAtIndex:i base:&v18 size:&v17 dataOffset:&v16 dataSize:&v15] & 1) == 0) {
        break;
      }
      unint64_t v6 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableData dataWithCapacity:](&OBJC_CLASS___NSMutableData, "dataWithCapacity:", v15));
      uint64_t v7 = v6;
      unsigned int v8 = v15;
      if (v15 + v16 <= v17)
      {
        [v6 appendBytes:v18 + v16 length:v15];
      }

      else
      {
        unsigned int v9 = v17 - v16;
        [v6 appendBytes:v18 + v16 length:v17 - v16];
        [v7 appendBytes:v18 length:v8 - v9];
      }

      unsigned int v10 = [v4 drainRingBufferAtIndex:i dataSize:v15];
      if (v10 != v15)
      {
        id v11 = (void *)objc_claimAutoreleasedReturnValue([v4 name]);
        NSLog(@"Fail, unexpected drain count for source %@!", v11);
      }

      [v3 addObject:v7];
    }

    unint64_t v14 = (void *)objc_claimAutoreleasedReturnValue([v4 name]);
    NSLog(@"Fail, unable to retrieve ring buffer info from source %@!", v14);
  }

  id v13 = 0LL;
LABEL_16:

  return v13;
}

void sub_71328(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id GTUSCSamplingStreamingManagerHelper::PostProcessFrameData(id *a1, void *a2)
{
  id v3 = a2;
  if ([v3 count])
  {
    GTUSCSamplingStreamingManagerHelper::ResetSourceForPostProcessing(a1);
    uint64_t v4 = (void *)objc_claimAutoreleasedReturnValue( +[NSMutableArray arrayWithCapacity:]( NSMutableArray,  "arrayWithCapacity:",  [v3 count]));
    unint64_t v5 = (void *)objc_claimAutoreleasedReturnValue([a1[3] lastObject]);
    for (unint64_t i = 0LL; ; ++i)
    {
      if (i >= (unint64_t)[v3 count])
      {
        id v15 = v4;
        goto LABEL_11;
      }

      uint64_t v7 = (void *)objc_claimAutoreleasedReturnValue([v3 objectAtIndexedSubscript:i]);
      unsigned int v8 = (char *)[v7 length];
      uint64_t v18 = 0LL;
      uint64_t v19 = 0LL;
      unint64_t v9 = 4 * (void)[v7 length];
      if (v9 <= 0x4000) {
        unint64_t v9 = 0x4000LL;
      }
      unint64_t v10 = (v9 + 7) & 0xFFFFFFFFFFFFFFF8LL;
      id v11 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableData dataWithLength:](&OBJC_CLASS___NSMutableData, "dataWithLength:", v10));
      id v12 = v7;
      id v13 = [v12 bytes];
      id v14 = v11;
      LOBYTE(v17) = 1;
      if ((objc_msgSend( v5,  "postProcessRawDataWithRingBufferIndex:source:sourceSize:sourceRead:sourceWrite:output:output Size:outputRead:outputWrite:isLast:",  i,  v13,  v8 + 8,  &v19,  v8,  objc_msgSend(v14, "mutableBytes"),  v10,  0,  &v18,  v17) & 1) == 0) {
        break;
      }
      [v14 setLength:v18];
      [v4 addObject:v14];
    }

    id v15 = 0LL;
LABEL_11:
  }

  else
  {
    id v15 = 0LL;
  }

  return v15;
}

void sub_71538(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

__n128 __Block_byref_object_copy__315(__n128 *a1, __n128 *a2)
{
  a1[3].n128_u64[0] = 0LL;
  a1[3].n128_u64[1] = 0LL;
  a1[4].n128_u64[0] = 0LL;
  __n128 result = a2[3];
  a1[3] = result;
  a1[4].n128_u64[0] = a2[4].n128_u64[0];
  a2[3].n128_u64[0] = 0LL;
  a2[3].n128_u64[1] = 0LL;
  a2[4].n128_u64[0] = 0LL;
  return result;
}

void __Block_byref_object_dispose__316(uint64_t a1)
{
  uint64_t v1 = (void **)(a1 + 48);
  std::vector<std::unordered_map<unsigned int,GTEncoderSampleIndexInfo>>::__destroy_vector::operator()[abi:nn180100](&v1);
}

void std::vector<std::tuple<unsigned long long,unsigned long long,unsigned long long>>::reserve( void **a1, unint64_t a2)
{
  if (0xAAAAAAAAAAAAAAABLL * (((_BYTE *)a1[2] - (_BYTE *)*a1) >> 3) < a2)
  {
    if (a2 >= 0xAAAAAAAAAAAAAABLL) {
      abort();
    }
    uint64_t v3 = ((_BYTE *)a1[1] - (_BYTE *)*a1) / 24;
    uint64_t v4 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<std::vector<NSObject  {objcproto21OS_dispatch_semaphore}* {__strong}>>>(a2);
    unint64_t v5 = &v4[24 * v3];
    uint64_t v7 = &v4[24 * v6];
    unint64_t v9 = (char *)*a1;
    unsigned int v8 = (char *)a1[1];
    unint64_t v10 = v5;
    if (v8 != *a1)
    {
      do
      {
        __int128 v11 = *(_OWORD *)(v8 - 24);
        *((void *)v10 - 1) = *((void *)v8 - 1);
        *(_OWORD *)(v10 - 24) = v11;
        v10 -= 24;
        v8 -= 24;
      }

      while (v8 != v9);
      unsigned int v8 = (char *)*a1;
    }

    *a1 = v10;
    a1[1] = v5;
    a1[2] = v7;
    if (v8) {
      operator delete(v8);
    }
  }

void ___ZN35GTUSCSamplingStreamingManagerHelper19StreamFrameTimeDataEv_block_invoke(uint64_t a1)
{
  unsigned __int8 v2 = *(id **)(a1 + 48);
  GTMTLReplayController_prePlayForProfiling(*(void *)*v2);
  GTUSCSamplingStreamingManagerHelper::SetupSourceForFrameTime( v2,  *(unsigned int *)(a1 + 56),  *(_DWORD *)(a1 + 60) == 0);
  DisableComputeEncoderCoalescing(*(GTMTLReplayController **)*v2, 1LL);
  uint64_t v3 = (void *)objc_claimAutoreleasedReturnValue([v2[2] firstObject]);
  [v3 startSampling];

  uint64_t v4 = objc_autoreleasePoolPush();
  uint64_t v38 = a1;
  unsigned int v5 = *(_DWORD *)(a1 + 60);
  uint64_t v6 = *(void *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 48LL);
  unsigned int v50 = *(unsigned int **)*v2;
  uint64_t v7 = (uint64_t)v50;
  char v51 = 0;
  id v49 = [(id)g_commandBufferDescriptor errorOptions];
  [(id)g_commandBufferDescriptor setErrorOptions:0];
  id v8 = *(id *)(*(void *)*v2 + 8LL);
  uint64_t v44 = **(void **)*v2;
  id v45 = v8;
  uint64_t v37 = *(void *)(v44 + 16);
  unint64_t v9 = (void *)objc_claimAutoreleasedReturnValue([v8 defaultDevice]);
  id v42 = [v9 newCommandQueue];

  unint64_t v10 = (void *)objc_claimAutoreleasedReturnValue([v45 defaultDevice]);
  unint64_t v39 = v4;
  unint64_t v41 = v2;
  id v43 = [v10 newEvent];
  __int128 v11 = v50 + 5620;

  unsigned __int8 v48 = 0;
  uint64_t v47 = *(void *)(*(void *)v50 + 120LL);
  unsigned int v46 = *(_DWORD *)(v47 + 12);
  if (v50[5620] < v46)
  {
    unint64_t v40 = (void *)(v6 + 40LL * v5);
    do
    {
      id v12 = objc_autoreleasePoolPush();
      uint64_t v13 = *(void *)(v47 + 24);
      uint64_t v14 = *v11;
      uint64_t v15 = v13 + (v14 << 6);
      int v17 = *(_DWORD *)(v15 + 8);
      unsigned int v16 = (int *)(v15 + 8);
      else {
        int v18 = 0;
      }
      GTMTLReplayController_updateCommandEncoder(v7, v13 + (v14 << 6));
      DispatchFunction((id *)v7, v13 + (v14 << 6), &v48);
      if (GetFuncEnumConstructorType(*v16) == 21)
      {
        uint64_t v28 = *((void *)GTTraceFunc_argumentBytesWithMap( (void *)(v13 + (v14 << 6)),  *(unsigned __int8 *)(v13 + (v14 << 6) + 13),  v37)
              + 1);
        if (std::__hash_table<std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>>>::find<unsigned int>( v40,  [v45 globalTraceIdForEncoder:v28 ofType:0]))
        {
          uint64_t v36 = (void *)objc_claimAutoreleasedReturnValue([v45 blitCommandEncoderForKey:v28]);
          [v36 endEncoding];
          id v29 = objc_msgSend( v45,  "commandBufferForKey:",  GTTraceFunc_targetContext(v13 + (v14 << 6), *(void *)(v44 + 16)));
          unint64_t v35 = (void *)objc_claimAutoreleasedReturnValue(v29);
          unint64_t v30 = (void *)objc_claimAutoreleasedReturnValue([v35 computeCommandEncoder]);
          [v30 endEncoding];
          DispatchFunction((id *)v7, v13 + (v14 << 6), &v48);
        }
      }

      if (v18)
      {
        id v19 = objc_msgSend( v45,  "commandBufferForKey:",  *((void *)GTTraceFunc_argumentBytesWithMap( (void *)(v13 + (v14 << 6)),  *(unsigned __int8 *)(v13 + (v14 << 6) + 13),  *(void *)(v44 + 16))
                + 1));
        id v20 = (void *)objc_claimAutoreleasedReturnValue(v19);
        ++GTUSCSamplingStreamingManagerHelper::ReplayForTimingCounters(std::unordered_map<unsigned int,GTEncoderSampleIndexInfo> &)::signalCounter;
        objc_msgSend(v20, "encodeSignalEvent:value:", v43);
        unint64_t v21 = (void *)objc_claimAutoreleasedReturnValue([v42 commandBuffer]);
        [v21 encodeWaitForEvent:v43 value:GTUSCSamplingStreamingManagerHelper::ReplayForTimingCounters(std::unordered_map<unsigned int,GTEncoderSampleIndexInfo> &)::signalCounter++];
        objc_msgSend(v21, "encodeSignalEvent:value:", v43);
        [v21 commit];
        [v20 encodeWaitForEvent:v43 value:GTUSCSamplingStreamingManagerHelper::ReplayForTimingCounters(std::unordered_map<unsigned int,GTEncoderSampleIndexInfo> &)::signalCounter];
      }

      else
      {
        int v22 = *v16;
        int FuncEnumConstructorType = GetFuncEnumConstructorType(v22);
        int v24 = v48;
        uint64_t v25 = FuncEnumConstructorType == 65;
        uint64_t v26 = *((void *)GTTraceFunc_argumentBytesWithMap( (void *)(v13 + (v14 << 6)),  *(unsigned __int8 *)(v13 + (v14 << 6) + 13),  *(void *)(v44 + 16))
              + 1);
        LODWORD(v25) = [v45 globalTraceIdForEncoder:v26 ofType:v25];
        id v20 = (void *)objc_claimAutoreleasedReturnValue([v45 encoderForKey:v26 ofType:v24 != 0]);
        GTUSCSamplingStreamingManagerHelper::AddEncoderSamplePoints( v41,  v40,  v13 + (v14 << 6),  v25,  v20,  v40[3],  0LL,  0LL);
      }

LABEL_13:
      objc_autoreleasePoolPop(v12);
      unsigned int v27 = *v11 + 1;
      unsigned int *v11 = v27;
    }

    while (v27 < v46);
  }

  *(_DWORD *)(v7 + 22484) = 0;
  unint64_t v31 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v7 + 8) defaultCommandQueue]);
  [v31 finish];

  ScopedReplayConfiguration::~ScopedReplayConfiguration((ScopedReplayConfiguration *)&v49);
  id v32 = GTUSCSamplingStreamingManagerHelper::DrainRawFrameData(v41);
  unint64_t v33 = (void *)objc_claimAutoreleasedReturnValue(v32);
  if (v33) {
    [*(id *)(v38 + 32) setArray:v33];
  }

  objc_autoreleasePoolPop(v39);
  unint64_t v34 = (void *)objc_claimAutoreleasedReturnValue([v41[2] firstObject]);
  [v34 stopSampling];

  DisableComputeEncoderCoalescing(*(GTMTLReplayController **)*v41, 0LL);
  GTAGXPerfStateControl::DisableConsistentGPUPerfState((GTAGXPerfStateControl *)(v41 + 5));
  GTApplePMPPerfStateControl::DisableConsistentPerfState((GTApplePMPPerfStateControl *)(v41 + 8));
}

void sub_71B60( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, void *a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17, void *a18, uint64_t a19, void *a20)
{
  ScopedReplayConfiguration::~ScopedReplayConfiguration((ScopedReplayConfiguration *)(v20 - 104));
  _Unwind_Resume(a1);
}

void ___ZN35GTUSCSamplingStreamingManagerHelper19StreamFrameTimeDataEv_block_invoke_2(uint64_t a1)
{
  unsigned __int8 v2 = *(void **)(a1 + 40);
  id v3 = GTSampleBufferManager::ResolveSampleBuffers((GTSampleBufferManager *)(v2 + 263));
  uint64_t v4 = (void *)objc_claimAutoreleasedReturnValue(v3);
  if (v4)
  {
    id v6 = v4;
    unsigned int v5 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) objectAtIndexedSubscript:*(unsigned int *)(a1 + 48)]);
    [v5 setData:v6];

    uint64_t v4 = v6;
  }

  v2[269] = 0LL;
  v2[267] = v2[266];
}

void sub_71CA8( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void ___ZN35GTUSCSamplingStreamingManagerHelper19StreamFrameTimeDataEv_block_invoke_3(uint64_t a1)
{
  unsigned __int8 v2 = *(id **)(a1 + 48);
  id v3 = objc_autoreleasePoolPush();
  id v4 = GTUSCSamplingStreamingManagerHelper::PostProcessFrameData(v2, *(void **)(a1 + 32));
  unsigned int v5 = (void *)objc_claimAutoreleasedReturnValue(v4);
  if (v5) {
    [*(id *)(a1 + 40) addObject:v5];
  }

  objc_autoreleasePoolPop(v3);
}

void sub_71D24(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void std::vector<unsigned int>::reserve( std::vector<unsigned int> *this, std::vector<unsigned int>::size_type __n)
{
  if (__n > this->__end_cap_.__value_ - this->__begin_)
  {
    if (__n >> 62) {
      abort();
    }
    int64_t v3 = (char *)this->__end_ - (char *)this->__begin_;
    id v4 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned int>>(__n);
    unsigned int v5 = (unsigned int *)&v4[v3 & 0xFFFFFFFFFFFFFFFCLL];
    uint64_t v7 = (unsigned int *)&v4[4 * v6];
    begiunint64_t n = this->__begin_;
    end = this->__end_;
    unint64_t v10 = v5;
    if (end != this->__begin_)
    {
      unint64_t v10 = v5;
      do
      {
        unsigned int v11 = *--end;
        *--unint64_t v10 = v11;
      }

      while (end != begin);
    }

    this->__begin_ = v10;
    this->__end_ = v5;
    this->__end_cap_.__value_ = v7;
    if (begin) {
      operator delete(begin);
    }
  }

void std::vector<std::unordered_map<unsigned int,GTEncoderSampleIndexInfo>>::__destroy_vector::operator()[abi:nn180100]( void ***a1)
{
  uint64_t v1 = *a1;
  unsigned __int8 v2 = **a1;
  if (v2)
  {
    uint64_t v4 = (uint64_t)v1[1];
    unsigned int v5 = v2;
    if ((void *)v4 != v2)
    {
      do
        uint64_t v4 = std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long>>>::~__hash_table(v4 - 40);
      while ((void *)v4 != v2);
      unsigned int v5 = **a1;
    }

    v1[1] = v2;
    operator delete(v5);
  }

void ___ZN35GTUSCSamplingStreamingManagerHelper18CalculateFrameTimeEv_block_invoke(uint64_t a1)
{
  unsigned __int8 v2 = *(uint64_t ***)(a1 + 40);
  GTMTLReplayController_prePlayForProfiling(**v2);
  int64_t v3 = (id *)**v2;
  id v15 = v3[1];
  uint64_t v4 = *v3;
  unsigned int v5 = v3 + 2810;
  if (*((void *)*v3 + 13) + *((void *)*v3 + 12) > (unint64_t)*((unsigned int *)v3 + 5620))
  {
    uint64_t v6 = v4[2];
    do
    {
      uint64_t v7 = objc_autoreleasePoolPush();
      uint64_t v8 = *(void *)(v4[15] + 24LL);
      uint64_t v9 = *v5;
      int FuncEnumConstructorType = GetFuncEnumConstructorType(*(_DWORD *)(v8 + (v9 << 6) + 8));
      GTMTLReplayController_updateCommandEncoder((uint64_t)v3, v8 + (v9 << 6));
      GTMTLReplayController_defaultDispatchFunction((uint64_t)v3, v8 + (v9 << 6));
      if (FuncEnumConstructorType == 25)
      {
        id v11 = objc_msgSend( v15,  "commandBufferForKey:",  *((void *)GTTraceFunc_argumentBytesWithMap( (void *)(v8 + (v9 << 6)),  *(unsigned __int8 *)(v8 + (v9 << 6) + 13),  v6)
                + 1));
        id v12 = (void *)objc_claimAutoreleasedReturnValue(v11);
        v17[0] = _NSConcreteStackBlock;
        v17[1] = 3221225472LL;
        v17[2] = ___ZN35GTUSCSamplingStreamingManagerHelper18CalculateFrameTimeEv_block_invoke_2;
        v17[3] = &unk_58D8B0;
        void v17[4] = *(void *)(a1 + 32);
        [v12 addCompletedHandler:v17];
      }

      objc_autoreleasePoolPop(v7);
      unint64_t v13 = (*v5 + 1);
      _DWORD *v5 = v13;
    }

    while (v4[13] + v4[12] > v13);
  }

  uint64_t v14 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v3[1], "defaultCommandQueue", v15));
  [v14 finish];
}

void sub_71FD0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9)
{
  _Unwind_Resume(a1);
}

void ___ZN35GTUSCSamplingStreamingManagerHelper18CalculateFrameTimeEv_block_invoke_2(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = *(void **)(*(void *)(*(void *)(a1 + 32) + 8LL) + 40LL);
  [v3 GPUStartTime];
  unsigned int v5 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithDouble:](&OBJC_CLASS___NSNumber, "numberWithDouble:"));
  v8[0] = v5;
  [v3 GPUEndTime];
  uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithDouble:](&OBJC_CLASS___NSNumber, "numberWithDouble:"));
  v8[1] = v6;
  uint64_t v7 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", v8, 2LL));
  [v4 addObject:v7];
}

void sub_720F4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id GTUSCSamplingStreamingManagerHelper::GatherFrameMiscEncoderPostProcessedData( char a1, void *a2, void *a3, uint64_t a4, void *a5)
{
  id v21 = a2;
  id v22 = a3;
  id v9 = a5;
  v30[0] = _NSConcreteStackBlock;
  v30[1] = 3221225472LL;
  v30[2] = ___ZN35GTUSCSamplingStreamingManagerHelper39GatherFrameMiscEncoderPostProcessedDataEbP14NSMutableArrayIP6NSDataEP13NSMutableDataRNSt3__113unordered_mapIj24GTEncoderSampleIndexInfoNS7_4hashIjEENS7_8equal_toIjEENS7_9allocatorINS7_4pairIKjS9_EEEEEEP11NSOperation_block_invoke;
  v30[3] = &unk_58D8D8;
  id v32 = &GTUSCSamplingStreamingManagerHelper::Instance(void)::instance;
  uint64_t v33 = a4;
  char v34 = a1;
  id v11 = (id)objc_opt_new(&OBJC_CLASS___NSMutableArray, v10);
  id v31 = v11;
  id v12 = (void *)objc_claimAutoreleasedReturnValue( +[NSBlockOperation blockOperationWithBlock:]( &OBJC_CLASS___NSBlockOperation,  "blockOperationWithBlock:",  v30));
  unint64_t v13 = v12;
  if (v9) {
    [v12 addDependency:v9];
  }
  [**(id **)(GTUSCSamplingStreamingManagerHelper::Instance(void)::instance + 8) addOperation:v13];
  [v13 setQueuePriority:-8];
  id v15 = (void *)objc_opt_new(&OBJC_CLASS___NSOperation, v14);
  if (dword_5B9514 && dword_5B9510)
  {
    v27[0] = _NSConcreteStackBlock;
    v27[1] = 3221225472LL;
    v27[2] = ___ZN35GTUSCSamplingStreamingManagerHelper39GatherFrameMiscEncoderPostProcessedDataEbP14NSMutableArrayIP6NSDataEP13NSMutableDataRNSt3__113unordered_mapIj24GTEncoderSampleIndexInfoNS7_4hashIjEENS7_8equal_toIjEENS7_9allocatorINS7_4pairIKjS9_EEEEEEP11NSOperation_block_invoke_2;
    v27[3] = &unk_58F270;
    id v29 = &GTUSCSamplingStreamingManagerHelper::Instance(void)::instance;
    id v28 = v22;
    id v16 = (void *)objc_claimAutoreleasedReturnValue( +[NSBlockOperation blockOperationWithBlock:]( &OBJC_CLASS___NSBlockOperation,  "blockOperationWithBlock:",  v27));
    [v16 addDependency:v13];
    [v15 addDependency:v16];
    [**(id **)(GTUSCSamplingStreamingManagerHelper::Instance(void)::instance + 8) addOperation:v16];
  }

  v23[0] = _NSConcreteStackBlock;
  v23[1] = 3221225472LL;
  v23[2] = ___ZN35GTUSCSamplingStreamingManagerHelper39GatherFrameMiscEncoderPostProcessedDataEbP14NSMutableArrayIP6NSDataEP13NSMutableDataRNSt3__113unordered_mapIj24GTEncoderSampleIndexInfoNS7_4hashIjEENS7_8equal_toIjEENS7_9allocatorINS7_4pairIKjS9_EEEEEEP11NSOperation_block_invoke_3;
  v23[3] = &unk_58EDA8;
  uint64_t v26 = &GTUSCSamplingStreamingManagerHelper::Instance(void)::instance;
  id v17 = v11;
  id v24 = v17;
  id v18 = v21;
  id v25 = v18;
  id v19 = (void *)objc_claimAutoreleasedReturnValue( +[NSBlockOperation blockOperationWithBlock:]( &OBJC_CLASS___NSBlockOperation,  "blockOperationWithBlock:",  v23));
  [v19 addDependency:v13];
  [v15 addDependency:v19];
  [*(id *)(*(void *)(GTUSCSamplingStreamingManagerHelper::Instance(void)::instance + 8) + 8) addOperation:v19];
  [*(id *)(*(void *)(GTUSCSamplingStreamingManagerHelper::Instance(void)::instance + 8) + 8) addOperation:v15];

  return v15;
}

void sub_723C0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, id *a10, void *a11, void *a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, void *a30)
{
  _Unwind_Resume(a1);
}

void ___ZN35GTUSCSamplingStreamingManagerHelper39GatherFrameMiscEncoderPostProcessedDataEbP14NSMutableArrayIP6NSDataEP13NSMutableDataRNSt3__113unordered_mapIj24GTEncoderSampleIndexInfoNS7_4hashIjEENS7_8equal_toIjEENS7_9allocatorINS7_4pairIKjS9_EEEEEEP11NSOperation_block_invoke( uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 40);
  GTMTLReplayController_prePlayForProfiling(**(void **)v2);
  GTUSCSamplingStreamingManagerHelper::SetupSourceForFrameTime((id *)v2, *(unsigned int *)(*(void *)v2 + 68LL), 0);
  unint64_t v66 = (GTUSCSamplingStreamingManagerHelper *)v2;
  id v3 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v2 + 16) firstObject]);
  unsigned __int8 v4 = [v3 startSampling];

  if ((v4 & 1) != 0)
  {
    unsigned int v5 = objc_autoreleasePoolPush();
    unint64_t v65 = *(void **)(a1 + 48);
    int v68 = *(unsigned __int8 *)(a1 + 56);
    uint64_t v70 = **(void **)v66;
    v73[1] = v70;
    char v74 = 0;
    v73[0] = [(id)g_commandBufferDescriptor errorOptions];
    [(id)g_commandBufferDescriptor setErrorOptions:0];
    id v6 = *(id *)(**(void **)v66 + 8LL);
    uint64_t v7 = ***(uint64_t ****)v66;
    uint64_t v59 = v7[15];
    uint64_t v60 = v7[14];
    uint64_t v8 = (void *)objc_claimAutoreleasedReturnValue([v6 defaultDevice]);
    id v9 = [v8 newEvent];

    uint64_t v10 = (void *)objc_claimAutoreleasedReturnValue([v6 defaultCommandQueue]);
    id v11 = (void *)objc_claimAutoreleasedReturnValue([v10 commandBuffer]);
    uint64_t v56 = v5;
    uint64_t v57 = a1;

    uint64_t v63 = v9;
    [v11 encodeSignalEvent:v9 value:GTUSCSamplingStreamingManagerHelper::ReplayFrameWithMiscEncoderSyncEvents(std::unordered_map<unsigned int,GTEncoderSampleIndexInfo> &,BOOL)::signalCounter];
    [v11 commit];
    unint64_t v58 = v11;
    if (v7[13] + v7[12] > (unint64_t)*(unsigned int *)(**(void **)v66 + 22480LL))
    {
      uint64_t v64 = 0LL;
      uint64_t v12 = 0LL;
      uint64_t v13 = 0LL;
      uint64_t v14 = 0LL;
      int64_t v61 = (unsigned int *)(v70 + 22480);
      unint64_t v67 = v6;
      do
      {
        context = objc_autoreleasePoolPush();
        uint64_t v15 = *(void *)(v7[15] + 24);
        uint64_t v16 = *v61;
        uint64_t v17 = v15 + (v16 << 6);
        uint64_t v71 = (int *)(v17 + 8);
        int FuncEnumConstructorType = GetFuncEnumConstructorType(*(_DWORD *)(v17 + 8));
        if (FuncEnumConstructorType == 25)
        {
          GTMTLReplayController_restoreCommandBuffer(v70, v15 + (v16 << 6));
          uint64_t v64 = *((void *)GTTraceFunc_argumentBytesWithMap( (void *)(v15 + (v16 << 6)),  *(unsigned __int8 *)(v15 + (v16 << 6) + 13),  v7[2])
                + 1);
          int FuncEnumConstructorType = GetFuncEnumConstructorType(*v71);
        }

        if ((FuncEnumConstructorType | 4) == 0x15)
        {
          id v19 = (void *)objc_claimAutoreleasedReturnValue([v6 commandBufferForKey:v64]);
          [v19 encodeWaitForEvent:v63 value:GTUSCSamplingStreamingManagerHelper::ReplayFrameWithMiscEncoderSyncEvents(std::unordered_map<unsigned int,GTEncoderSampleIndexInfo> &,BOOL)::signalCounter++];
          objc_msgSend(v19, "encodeSignalEvent:value:", v63);
          uint64_t v12 = *((void *)GTTraceFunc_argumentBytesWithMap( (void *)(v15 + (v16 << 6)),  *(unsigned __int8 *)(v15 + (v16 << 6) + 13),  v7[2])
                + 1);
          if (v68)
          {
            InclusiveRange = GroupBuilder_findInclusiveRange(*(_DWORD *)(v60 + 12), *(void **)(v60 + 24), *v61);
            unint64_t v21 = InclusiveRange[1];
            unint64_t v22 = v21 - *InclusiveRange;
            if (v21 <= *InclusiveRange)
            {
              uint64_t v14 = v13;
            }

            else
            {
              unint64_t v23 = (int *)(*(void *)(v59 + 24) + (*InclusiveRange << 6) + 8LL);
              uint64_t v14 = v13;
              do
              {
                int v25 = *v23;
                v23 += 16;
                int v24 = v25;
                if (IsFuncEnumSampledBlitCall(v25) || IsFuncEnumSampledBlitCallAGX(v24)) {
                  ++v14;
                }
                uint64_t v13 = v14;
                --v22;
              }

              while (v22);
            }
          }

          uint64_t v26 = v14;
          id v6 = v67;
        }

        else
        {
          uint64_t v26 = v14;
        }

        GTMTLReplayController_updateCommandEncoder(v70, v17);
        uint64_t v69 = v12;
        if (v68 && ((int v27 = *v71, IsFuncEnumSampledBlitCall(*v71)) || IsFuncEnumSampledBlitCallAGX(v27)))
        {
          uint64_t v14 = v26 - 1;
          if (v26 && v13 != v26)
          {
            id v28 = (void *)objc_claimAutoreleasedReturnValue([v6 blitCommandEncoderForKey:v12]);
            [v28 endEncoding];
            id v29 = (void *)objc_claimAutoreleasedReturnValue([v6 commandBufferForKey:v64]);
            [v29 encodeWaitForEvent:v63 value:GTUSCSamplingStreamingManagerHelper::ReplayFrameWithMiscEncoderSyncEvents(std::unordered_map<unsigned int,GTEncoderSampleIndexInfo> &,BOOL)::signalCounter++];
            objc_msgSend(v29, "encodeSignalEvent:value:", v63);
            unint64_t v30 = (void *)objc_claimAutoreleasedReturnValue([v29 blitCommandEncoder]);
            if (std::__hash_table<std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>>>::find<unsigned int>( v65,  [v30 globalTraceObjectID]))
            {
              [v30 endEncoding];
              id v31 = (void *)objc_claimAutoreleasedReturnValue([v29 computeCommandEncoder]);
              [v31 endEncoding];
              uint64_t v32 = objc_claimAutoreleasedReturnValue([v29 blitCommandEncoder]);

              unint64_t v30 = (void *)v32;
              uint64_t v12 = v69;
            }

            [v67 setBlitCommandEncoder:v30 forKey:v12];
            unsigned int v33 = [v67 globalTraceIdForEncoder:v12 ofType:0];
            memset(v75, 0, sizeof(v75));
            DWORD2(v75[0]) = -16354;
            GTUSCSamplingStreamingManagerHelper::AddEncoderSamplePoints( v66,  v65,  (uint64_t)v75,  v33,  v30,  v65[3],  0LL,  0LL);

            id v6 = v67;
          }
        }

        else
        {
          uint64_t v14 = v26;
        }

        GTMTLReplayController_defaultDispatchFunction(v70, v17);
        int v34 = *v71;
        if (GetFuncEnumConstructorType(*v71) == 21)
        {
          unsigned int v35 = [v6 globalTraceIdForEncoder:v12 ofType:0];
          uint64_t v36 = v12;
          unsigned int v37 = v35;
          uint64_t v38 = (void *)objc_claimAutoreleasedReturnValue([v6 blitCommandEncoderForKey:v36]);
          if (std::__hash_table<std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>>>::find<unsigned int>( v65,  v37))
          {
            [v38 endEncoding];
            id v39 = objc_msgSend(v6, "commandBufferForKey:", GTTraceFunc_targetContext(v17, v7[2]));
            unint64_t v40 = (void *)objc_claimAutoreleasedReturnValue(v39);
            unint64_t v41 = (void *)objc_claimAutoreleasedReturnValue([v40 computeCommandEncoder]);
            [v41 endEncoding];
            GTMTLReplayController_defaultDispatchFunction(v70, v17);
            unsigned int v37 = [v67 globalTraceIdForEncoder:v69 ofType:0];

            id v6 = v67;
          }

          GTUSCSamplingStreamingManagerHelper::AddEncoderSamplePoints(v66, v65, v17, v37, v38, v65[3], 0LL, 0LL);
          uint64_t v12 = v69;

          int v34 = *v71;
        }

        if (!v68 && v34 == -16376)
        {
          id v42 = (void *)objc_claimAutoreleasedReturnValue([v6 commandBufferForKey:v64]);
          [v42 encodeWaitForEvent:v63 value:GTUSCSamplingStreamingManagerHelper::ReplayFrameWithMiscEncoderSyncEvents(std::unordered_map<unsigned int,GTEncoderSampleIndexInfo> &,BOOL)::signalCounter++];
          objc_msgSend(v42, "encodeSignalEvent:value:", v63);

          int v34 = *v71;
        }

        if (GetFuncEnumConstructorType(v34) == 17)
        {
          unsigned int v43 = [v6 globalTraceIdForEncoder:v12 ofType:0];
          uint64_t v44 = v12;
          unsigned int v45 = v43;
          unsigned int v46 = (void *)objc_claimAutoreleasedReturnValue([v6 accelerationStructureCommandEncoderForKey:v44]);
          if (std::__hash_table<std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>>>::find<unsigned int>( v65,  v45))
          {
            [v46 endEncoding];
            id v47 = objc_msgSend(v6, "commandBufferForKey:", GTTraceFunc_targetContext(v17, v7[2]));
            unsigned __int8 v48 = (void *)objc_claimAutoreleasedReturnValue(v47);
            id v49 = (void *)objc_claimAutoreleasedReturnValue([v48 computeCommandEncoder]);
            [v49 endEncoding];
            GTMTLReplayController_defaultDispatchFunction(v70, v17);
            unsigned int v45 = [v67 globalTraceIdForEncoder:v69 ofType:0];

            id v6 = v67;
          }

          GTUSCSamplingStreamingManagerHelper::AddEncoderSamplePoints(v66, v65, v17, v45, v46, v65[3], 0LL, 0LL);
          uint64_t v12 = v69;

          int v34 = *v71;
        }

        if (v34 == -15642)
        {
          unsigned int v50 = (void *)objc_claimAutoreleasedReturnValue([v6 commandBufferForKey:v64]);
          [v50 encodeWaitForEvent:v63 value:GTUSCSamplingStreamingManagerHelper::ReplayFrameWithMiscEncoderSyncEvents(std::unordered_map<unsigned int,GTEncoderSampleIndexInfo> &,BOOL)::signalCounter++];
          objc_msgSend(v50, "encodeSignalEvent:value:", v63);
        }

        objc_autoreleasePoolPop(context);
        uint64_t v51 = **(void **)v66;
        unint64_t v52 = (*(_DWORD *)(v51 + 22480) + 1);
        *(_DWORD *)(v51 + 22480) = v52;
      }

      while (v7[13] + v7[12] > v52);
    }

    unint64_t v53 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v70 + 8) defaultCommandQueue]);
    [v53 finish];

    ScopedReplayConfiguration::~ScopedReplayConfiguration((ScopedReplayConfiguration *)v73);
    id v54 = GTUSCSamplingStreamingManagerHelper::DrainRawFrameData((id *)v66);
    uint64_t v55 = (void *)objc_claimAutoreleasedReturnValue(v54);
    if (v55) {
      [*(id *)(v57 + 32) setArray:v55];
    }

    objc_autoreleasePoolPop(v56);
    id v72 = (id)objc_claimAutoreleasedReturnValue([*((id *)v66 + 2) firstObject]);
    [v72 stopSampling];
  }

void sub_72C58( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, id a25, char a26)
{
  _Unwind_Resume(a1);
}

void ___ZN35GTUSCSamplingStreamingManagerHelper39GatherFrameMiscEncoderPostProcessedDataEbP14NSMutableArrayIP6NSDataEP13NSMutableDataRNSt3__113unordered_mapIj24GTEncoderSampleIndexInfoNS7_4hashIjEENS7_8equal_toIjEENS7_9allocatorINS7_4pairIKjS9_EEEEEEP11NSOperation_block_invoke_2( uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 40);
  id v3 = GTSampleBufferManager::ResolveSampleBuffers((GTSampleBufferManager *)(v2 + 263));
  id v4 = (id)objc_claimAutoreleasedReturnValue(v3);
  if (v4) {
    [*(id *)(a1 + 32) setData:v4];
  }
  v2[269] = 0LL;
  v2[267] = v2[266];
}

void sub_72DEC( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
}

void ___ZN35GTUSCSamplingStreamingManagerHelper39GatherFrameMiscEncoderPostProcessedDataEbP14NSMutableArrayIP6NSDataEP13NSMutableDataRNSt3__113unordered_mapIj24GTEncoderSampleIndexInfoNS7_4hashIjEENS7_8equal_toIjEENS7_9allocatorINS7_4pairIKjS9_EEEEEEP11NSOperation_block_invoke_3( uint64_t a1)
{
  id v2 = GTUSCSamplingStreamingManagerHelper::PostProcessFrameData(*(id **)(a1 + 48), *(void **)(a1 + 32));
  id v3 = (id)objc_claimAutoreleasedReturnValue(v2);
  if (v3) {
    [*(id *)(a1 + 40) setArray:v3];
  }
}

void sub_72E4C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
}

void GTUSCSamplingStreamingManagerHelper::StreamEncoderDerivedCounterData( GTUSCSamplingStreamingManagerHelper *this)
{
  unsigned __int8 v1 = atomic_load(byte_5B979C);
  if ((v1 & 1) != 0) {
    return;
  }
  id v182 = (void *)objc_claimAutoreleasedReturnValue( [*(id *)(GTUSCSamplingStreamingManagerHelper::Instance(void)::instance + 48) objectForKeyedSubscript:@"DerivedCounterDictionary"]);
  if ((_DWORD)qword_5B9550 == -1)
  {
    id v9 = (void *)objc_claimAutoreleasedReturnValue([v182 objectForKeyedSubscript:@"DerivedCounters"]);
    id v10 = [v9 mutableCopy];

    __int128 v207 = v10;
    id v11 = (void *)objc_claimAutoreleasedReturnValue([v10 objectForKeyedSubscript:@"CSInvocation"]);
    id v188 = (id)objc_claimAutoreleasedReturnValue([v11 objectForKeyedSubscript:@"counters"]);

    goto LABEL_13;
  }

  std::string::basic_string[abi:nn180100]<0>(&__p, "CSInvocation");
  CountersForDerivedCounter = GTAGXProfilingSupportHelper::GetCountersForDerivedCounter((uint64_t)&__p);
  id v3 = CountersForDerivedCounter;
  if (SHIBYTE(v272) < 0)
  {
    operator delete(__p);
    if (v3) {
      goto LABEL_5;
    }
LABEL_12:
    __int128 v207 = 0LL;
    id v188 = 0LL;
    goto LABEL_13;
  }

  if (!CountersForDerivedCounter) {
    goto LABEL_12;
  }
LABEL_5:
  id v4 = (void *)objc_claimAutoreleasedReturnValue( +[NSMutableArray arrayWithCapacity:]( &OBJC_CLASS___NSMutableArray,  "arrayWithCapacity:",  0xAAAAAAAAAAAAAAABLL * ((v3[1] - *v3) >> 3)));
  uint64_t v5 = *v3;
  uint64_t v6 = v3[1];
  if (*v3 != v6)
  {
    do
    {
      uint64_t v7 = v5;
      uint64_t v8 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", v7));
      [v4 addObject:v8];

      v5 += 24LL;
    }

    while (v5 != v6);
  }

  id v188 = [v4 copy];

  __int128 v207 = 0LL;
LABEL_13:
  id v193 = (void *)objc_claimAutoreleasedReturnValue(+[NSSet setWithArray:](&OBJC_CLASS___NSSet, "setWithArray:", v188));
  __int128 v206 = (void *)objc_claimAutoreleasedReturnValue( +[NSMutableSet setWithCapacity:]( NSMutableSet,  "setWithCapacity:",  [&off_59F878 count]));
  if ((_DWORD)qword_5B9550 == -1)
  {
    __int128 v297 = 0u;
    __int128 v296 = 0u;
    __int128 v295 = 0u;
    __int128 v294 = 0u;
    id v12 = [&off_59F878 countByEnumeratingWithState:&v294 objects:v322 count:16];
    if (v12)
    {
      uint64_t v13 = *(void *)v295;
      do
      {
        for (unint64_t i = 0LL; i != v12; unint64_t i = (char *)i + 1)
        {
          if (*(void *)v295 != v13) {
            objc_enumerationMutation(&off_59F878);
          }
          uint64_t v15 = (void *)objc_claimAutoreleasedReturnValue( [v207 objectForKeyedSubscript:*(void *)(*((void *)&v294 + 1) + 8 * (void)i)]);
          uint64_t v16 = v15;
          if (v15)
          {
            uint64_t v17 = (void *)objc_claimAutoreleasedReturnValue([v15 objectForKeyedSubscript:@"counters"]);
            if (v17) {
              [v206 addObjectsFromArray:v17];
            }
          }
        }

        id v12 = [&off_59F878 countByEnumeratingWithState:&v294 objects:v322 count:16];
      }

      while (v12);
    }
  }

  if (qword_5B9490)
  {
    id v18 = (void *)objc_claimAutoreleasedReturnValue([(id)qword_5B9490 objectForKeyedSubscript:@"num_cores"]);
    unsigned int v19 = [v18 unsignedIntValue];

    uint64_t v20 = (void *)objc_claimAutoreleasedReturnValue([(id)qword_5B9490 objectForKeyedSubscript:@"num_mgpus"]);
    unsigned int v21 = [v20 unsignedIntValue];

    if (v21 <= 1) {
      unsigned int v22 = 1;
    }
    else {
      unsigned int v22 = v21;
    }
    BOOL v23 = v19 / v22 > 4;
  }

  else
  {
    BOOL v23 = 1;
  }

  BOOL v202 = v23;
  __int128 v210 = (void *)objc_claimAutoreleasedReturnValue( +[NSMutableArray arrayWithCapacity:]( NSMutableArray,  "arrayWithCapacity:",  [v188 count]));
  if (v202)
  {
    __int128 v293 = 0u;
    __int128 v292 = 0u;
    __int128 v291 = 0u;
    __int128 v290 = 0u;
    id v24 = v188;
    id v25 = [v24 countByEnumeratingWithState:&v290 objects:v321 count:16];
    if (v25)
    {
      uint64_t v26 = *(void *)v291;
      do
      {
        for (int j = 0LL; j != v25; int j = (char *)j + 1)
        {
          if (*(void *)v291 != v26) {
            objc_enumerationMutation(v24);
          }
          id v28 = (void *)objc_claimAutoreleasedReturnValue( +[GPURawCounterSelect selectWithName:options:]( &OBJC_CLASS___GPURawCounterSelect,  "selectWithName:options:",  *(void *)(*((void *)&v290 + 1) + 8LL * (void)j),  0LL));
          [v210 addObject:v28];
        }

        id v25 = [v24 countByEnumeratingWithState:&v290 objects:v321 count:16];
      }

      while (v25);
    }
  }

  if ((_DWORD)qword_5B9550 == -1)
  {
    v319 = @"FRGTicks";
    uint64_t v32 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v207, "objectForKeyedSubscript:"));
    v320 = v32;
    unsigned int v33 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v320,  &v319,  1LL));
    id v34 = GTMTLReplayHost_rawCounters(v33);
    id v31 = (uint64_t *)objc_claimAutoreleasedReturnValue(v34);

LABEL_51:
    goto LABEL_52;
  }

  std::string::basic_string[abi:nn180100]<0>(&__p, "FRGTicks");
  id v29 = GTAGXProfilingSupportHelper::GetCountersForDerivedCounter((uint64_t)&__p);
  id v31 = v29;
  if ((SHIBYTE(v272) & 0x80000000) == 0)
  {
    if (!v29) {
      goto LABEL_52;
    }
    goto LABEL_46;
  }

  operator delete(__p);
  if (v31)
  {
LABEL_46:
    uint64_t v32 = (void *)objc_opt_new(&OBJC_CLASS___NSMutableArray, v30);
    uint64_t v35 = *v31;
    uint64_t v36 = v31[1];
    if (*v31 != v36)
    {
      do
      {
        uint64_t v37 = v35;
        uint64_t v38 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", v37));
        [v32 addObject:v38];

        v35 += 24LL;
      }

      while (v35 != v36);
    }

    id v31 = (uint64_t *)[v32 copy];
    goto LABEL_51;
  }

LABEL_52:
  uint64_t v39 = objc_claimAutoreleasedReturnValue( +[NSMutableArray arrayWithCapacity:]( NSMutableArray,  "arrayWithCapacity:",  [v31 count]));
  unint64_t v40 = (void *)qword_5B94A0;
  qword_5B94A0 = v39;

  __int128 v289 = 0u;
  __int128 v288 = 0u;
  __int128 v287 = 0u;
  __int128 v286 = 0u;
  obint j = v31;
  id v41 = [obj countByEnumeratingWithState:&v286 objects:v318 count:16];
  if (v41)
  {
    uint64_t v42 = *(void *)v287;
    do
    {
      for (uint64_t k = 0LL; k != v41; uint64_t k = (char *)k + 1)
      {
        if (*(void *)v287 != v42) {
          objc_enumerationMutation(obj);
        }
        uint64_t v44 = (void *)objc_claimAutoreleasedReturnValue( +[GPURawCounterSelect selectWithName:options:]( &OBJC_CLASS___GPURawCounterSelect,  "selectWithName:options:",  *(void *)(*((void *)&v286 + 1) + 8LL * (void)k),  &off_59FCA0));
        [(id)qword_5B94A0 addObject:v44];
      }

      id v41 = [obj countByEnumeratingWithState:&v286 objects:v318 count:16];
    }

    while (v41);
  }

  if ((_DWORD)qword_5B9550 == -1)
  {
    id v50 = GTMTLReplayHost_rawCounters(v207);
    uint64_t v51 = (void *)objc_claimAutoreleasedReturnValue(v50);
    id v189 = [v51 copy];
  }

  else
  {
    id v189 = (id)objc_opt_new(&OBJC_CLASS___NSMutableArray, v45);
    uint64_t v46 = qword_5B96F8;
    for (uint64_t m = xmmword_5B9700; v46 != m; v46 += 24LL)
    {
      uint64_t v48 = v46;
      id v49 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", v48));
      [v189 addObject:v49];
    }
  }

  unint64_t v52 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableSet setWithArray:](&OBJC_CLASS___NSMutableSet, "setWithArray:", v189));
  unint64_t v53 = obj;
  [v52 addObjectsFromArray:&off_59F830];
  if (v188) {
    [v52 addObjectsFromArray:v188];
  }
  [v52 addObjectsFromArray:obj];
  id v54 = (void *)objc_claimAutoreleasedReturnValue( +[NSMutableDictionary dictionaryWithCapacity:]( &OBJC_CLASS___NSMutableDictionary,  "dictionaryWithCapacity:",  4096LL));
  for (unint64_t n = 0; n < [*((id *)&xmmword_5B8CE0 + 1) count]; ++n)
  {
    v200 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*((id *)&xmmword_5B8CE0 + 1), "objectAtIndexedSubscript:"));
    uint64_t v55 = (void *)objc_claimAutoreleasedReturnValue([v200 availableCounters]);
    __int128 v285 = 0u;
    __int128 v284 = 0u;
    __int128 v283 = 0u;
    __int128 v282 = 0u;
    id v56 = v55;
    id v57 = [v56 countByEnumeratingWithState:&v282 objects:v317 count:16];
    if (v57)
    {
      uint64_t v58 = *(void *)v283;
      do
      {
        for (iunint64_t i = 0LL; ii != v57; iunint64_t i = (char *)ii + 1)
        {
          if (*(void *)v283 != v58) {
            objc_enumerationMutation(v56);
          }
          uint64_t v60 = *(void **)(*((void *)&v282 + 1) + 8LL * (void)ii);
          int64_t v61 = (void *)objc_claimAutoreleasedReturnValue([v60 name]);
          unsigned int v62 = [v52 containsObject:v61];

          if (v62)
          {
            uint64_t v63 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedInteger:]( NSNumber,  "numberWithUnsignedInteger:",  [v60 counterValueType]));
            uint64_t v64 = (void *)objc_claimAutoreleasedReturnValue([v60 name]);
            [v54 setObject:v63 forKeyedSubscript:v64];
          }
        }

        id v57 = [v56 countByEnumeratingWithState:&v282 objects:v317 count:16];
      }

      while (v57);
    }

    unint64_t v53 = obj;
  }

  unint64_t v65 = (char *)[v189 count];
  v201 = (void *)objc_claimAutoreleasedReturnValue( +[NSMutableArray arrayWithCapacity:]( NSMutableArray,  "arrayWithCapacity:",  &v65[(void)[(id)qword_5B9498 count]]));
  [v201 addObjectsFromArray:qword_5B9498];
  __int128 v281 = 0u;
  __int128 v280 = 0u;
  __int128 v279 = 0u;
  __int128 v278 = 0u;
  id v209 = v189;
  id v66 = [v209 countByEnumeratingWithState:&v278 objects:v316 count:16];
  if (v66)
  {
    uint64_t v67 = *(void *)v279;
    do
    {
      for (jint j = 0LL; jj != v66; jint j = (char *)jj + 1)
      {
        if (*(void *)v279 != v67) {
          objc_enumerationMutation(v209);
        }
        uint64_t v69 = *(void **)(*((void *)&v278 + 1) + 8LL * (void)jj);
        if (([v69 isEqualToString:@"MTLStat_nSec"] & 1) == 0
          && ([v53 containsObject:v69] & 1) == 0
          && (!v202 || ([v193 containsObject:v69] & 1) == 0))
        {
          else {
            uint64_t v70 = 0LL;
          }
          uint64_t v71 = v70;
          id v72 = (void *)objc_claimAutoreleasedReturnValue( +[GPURawCounterSelect selectWithName:options:]( &OBJC_CLASS___GPURawCounterSelect,  "selectWithName:options:",  v69,  v71));
          [v201 addObject:v72];

          unint64_t v53 = obj;
        }
      }

      id v66 = [v209 countByEnumeratingWithState:&v278 objects:v316 count:16];
    }

    while (v66);
  }

  if (qword_5B94A0)
  {
    id v73 = GTUSCSamplingStreamingManagerHelper::SubDividedCounterDictionary((void *)qword_5B94A0);
    id v181 = (void *)objc_claimAutoreleasedReturnValue(v73);
  }

  else
  {
    id v181 = 0LL;
  }

  id v74 = GTUSCSamplingStreamingManagerHelper::SubDividedCounterDictionary(v201);
  int64x2_t v178 = (NSDictionary *)objc_claimAutoreleasedReturnValue(v74);
  id v75 = DeepMutableCopy(v178);
  unint64_t v76 = (GTUSCSamplingStreamingManagerHelper *)objc_claimAutoreleasedReturnValue(v75);
  unint64_t v77 = v76;
  if (v76)
  {
    v186 = v76;
    if (-[GTUSCSamplingStreamingManagerHelper count](v76, "count"))
    {
      unint64_t v78 = (void *)objc_claimAutoreleasedReturnValue( -[GTUSCSamplingStreamingManagerHelper objectForKeyedSubscript:]( v77,  "objectForKeyedSubscript:",  @"passNum"));
      unsigned int v196 = [v78 unsignedIntValue];

      if (v181)
      {
        BOOL v79 = (void *)objc_claimAutoreleasedReturnValue([v181 objectForKeyedSubscript:@"passNum"]);
        BOOL v80 = [v79 unsignedIntValue] == 1;

        if (v80)
        {
          GTUSCSamplingStreamingManagerHelper::SetupBumperCounters(v186, v81);
          unint64_t v82 = (void *)objc_claimAutoreleasedReturnValue([v181 objectForKeyedSubscript:@"passList"]);
          uint64_t v83 = (void *)objc_claimAutoreleasedReturnValue([v82 objectAtIndexedSubscript:0]);

          if (v196)
          {
            for (kuint64_t k = 0LL; kk != v196; ++kk)
            {
              unint64_t v85 = (void *)objc_claimAutoreleasedReturnValue( -[GTUSCSamplingStreamingManagerHelper objectForKeyedSubscript:]( v186,  "objectForKeyedSubscript:",  @"passList"));
              unint64_t v86 = (void *)objc_claimAutoreleasedReturnValue([v85 objectAtIndexedSubscript:kk]);

              for (muint64_t m = 0; mm < (unint64_t)[v86 count]; ++mm)
              {
                uint64_t v88 = (void *)objc_claimAutoreleasedReturnValue([v83 objectAtIndexedSubscript:mm]);
                BOOL v89 = [v88 count] == 0;

                if (!v89)
                {
                  id v90 = (void *)objc_claimAutoreleasedReturnValue([v86 objectAtIndexedSubscript:mm]);
                  int64_t v91 = (void *)objc_claimAutoreleasedReturnValue([v83 objectAtIndexedSubscript:mm]);
                  [v90 addObjectsFromArray:v91];
                }
              }
            }
          }

          if ([v210 count])
          {
            ++v196;
            uint64_t v92 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInt:](&OBJC_CLASS___NSNumber, "numberWithUnsignedInt:"));
            -[GTUSCSamplingStreamingManagerHelper setObject:forKeyedSubscript:]( v186,  "setObject:forKeyedSubscript:",  v92,  @"passNum");
          }

          if ([v210 count])
          {
            uint64_t v93 = (void *)objc_claimAutoreleasedReturnValue( +[NSMutableArray arrayWithCapacity:]( NSMutableArray,  "arrayWithCapacity:",  [*((id *)&xmmword_5B8CE0 + 1) count]));
            for (unint64_t nn = 0; nn < (unint64_t)[*((id *)&xmmword_5B8CE0 + 1) count]; ++nn)
            {
              unint64_t v96 = (void *)objc_opt_new(&OBJC_CLASS___NSMutableArray, v95);
              [v93 addObject:v96];

              unint64_t v97 = (void *)objc_claimAutoreleasedReturnValue([v83 objectAtIndexedSubscript:nn]);
              BOOL v98 = [v97 count] == 0;

              if (!v98)
              {
                unint64_t v99 = (void *)objc_claimAutoreleasedReturnValue([v93 objectAtIndexedSubscript:nn]);
                unint64_t v100 = (void *)objc_claimAutoreleasedReturnValue([(id)qword_5B9498 arrayByAddingObjectsFromArray:v210]);
                [v99 addObjectsFromArray:v100];
              }
            }

            unint64_t v101 = (void *)objc_claimAutoreleasedReturnValue( -[GTUSCSamplingStreamingManagerHelper objectForKeyedSubscript:]( v186,  "objectForKeyedSubscript:",  @"passList"));
            [v101 addObject:v93];
          }
        }
      }

      uint64_t v102 = objc_autoreleasePoolPush();
      uint64_t v104 = objc_opt_new(&OBJC_CLASS___NSMutableData, v103);
      objc_autoreleasePoolPop(v102);
      id v183 = (void *)v104;
      __p = 0LL;
      p_p = &__p;
      uint64_t v272 = 0x5812000000LL;
      v273 = __Block_byref_object_copy__195;
      v274 = __Block_byref_object_dispose__196;
      memset(v275, 0, sizeof(v275));
      uint64_t v276 = 0LL;
      int v277 = 1065353216;
      v268[0] = 0LL;
      v268[1] = v268;
      v268[2] = 0x5812000000LL;
      v268[3] = __Block_byref_object_copy__195;
      v268[4] = __Block_byref_object_dispose__196;
      memset(&v268[5], 0, 40);
      int v269 = 1065353216;
      uint64_t v261 = 0LL;
      v262 = &v261;
      uint64_t v263 = 0x4812000000LL;
      v264 = __Block_byref_object_copy__197;
      v265 = __Block_byref_object_dispose__198;
      v266 = "";
      memset(v267, 0, sizeof(v267));
      v252 = 0LL;
      v253 = &v252;
      uint64_t v254 = 0x4812000000LL;
      v255 = __Block_byref_object_copy__199;
      v256 = __Block_byref_object_dispose__200;
      v257 = "";
      v258 = 0LL;
      uint64_t v260 = 0LL;
      v259 = 0LL;
      unsigned int v179 = (char *)v196;
      std::vector<std::vector<DYMTLEncoderInfo>>::resize(v267, v196);
      id v171 = *(id *)(GTUSCSamplingStreamingManagerHelper::Instance(void)::instance + 16);
      uint64_t v105 = (void *)objc_claimAutoreleasedReturnValue([v171 objectForKeyedSubscript:@"perEncoderDrawCallCount"]);
      id v174 = [v105 count];

      v185 = (void *)objc_opt_new(&OBJC_CLASS___NSMutableArray, v106);
      v187 = (void *)objc_opt_new(&OBJC_CLASS___NSOperation, v107);
      if (v196)
      {
        id v108 = 0LL;
        for (int i1 = 0; i1 != v196; ++i1)
        {
          std::vector<std::vector<DYMTLEncoderInfo>>::reserve(v262 + 6, 2LL * (void)v174);
          __int128 v111 = (void *)objc_opt_new(&OBJC_CLASS___NSMutableArray, v110);
          v239[0] = _NSConcreteStackBlock;
          v239[1] = 3221225472LL;
          v239[2] = ___ZN35GTUSCSamplingStreamingManagerHelper31StreamEncoderDerivedCounterDataEv_block_invoke;
          v239[3] = &unk_58D900;
          uint64_t v248 = &GTUSCSamplingStreamingManagerHelper::Instance(void)::instance;
          v240 = v186;
          int v249 = i1;
          BOOL v251 = v202;
          id v112 = v188;
          unsigned int v250 = v196;
          v244 = &v261;
          uint64_t v245 = &v252;
          v246 = &__p;
          v247 = v268;
          id v241 = v112;
          id v242 = 0LL;
          id v113 = v111;
          id v243 = v113;
          __int128 v114 = (void *)objc_claimAutoreleasedReturnValue( +[NSBlockOperation blockOperationWithBlock:]( &OBJC_CLASS___NSBlockOperation,  "blockOperationWithBlock:",  v239));
          unsigned int v115 = v114;
          if (v108) {
            [v114 addDependency:v108];
          }
          [**(id **)(GTUSCSamplingStreamingManagerHelper::Instance(void)::instance + 8) addOperation:v115];
          [v115 setQueuePriority:-8];
          v235[0] = _NSConcreteStackBlock;
          v235[1] = 3221225472LL;
          v235[2] = ___ZN35GTUSCSamplingStreamingManagerHelper31StreamEncoderDerivedCounterDataEv_block_invoke_2;
          v235[3] = &unk_58EDA8;
          v238 = &GTUSCSamplingStreamingManagerHelper::Instance(void)::instance;
          id v116 = v113;
          id v236 = v116;
          id v237 = v185;
          uint64_t v117 = (void *)objc_claimAutoreleasedReturnValue( +[NSBlockOperation blockOperationWithBlock:]( &OBJC_CLASS___NSBlockOperation,  "blockOperationWithBlock:",  v235));
          [v117 addDependency:v115];
          [*(id *)(*(void *)(GTUSCSamplingStreamingManagerHelper::Instance(void)::instance + 8) + 8) addOperation:v117];
          [v187 addDependency:v117];
          id v118 = v117;

          if (!i1 && dword_5B9514 && dword_5B9510)
          {
            v232[0] = _NSConcreteStackBlock;
            v232[1] = 3221225472LL;
            v232[2] = ___ZN35GTUSCSamplingStreamingManagerHelper31StreamEncoderDerivedCounterDataEv_block_invoke_3;
            v232[3] = &unk_58F270;
            v234 = &GTUSCSamplingStreamingManagerHelper::Instance(void)::instance;
            id v233 = v183;
            unint64_t v119 = (void *)objc_claimAutoreleasedReturnValue( +[NSBlockOperation blockOperationWithBlock:]( &OBJC_CLASS___NSBlockOperation,  "blockOperationWithBlock:",  v232));
            [v119 addDependency:v118];
            [v187 addDependency:v119];
            [**(id **)(GTUSCSamplingStreamingManagerHelper::Instance(void)::instance + 8) addOperation:v119];
          }

          id v108 = v118;
        }
      }

      else
      {
        id v118 = 0LL;
      }

      id v172 = v118;
      [*(id *)(*(void *)(GTUSCSamplingStreamingManagerHelper::Instance(void)::instance + 8) + 8) addOperation:v187];
      [v187 waitUntilFinished];
      id v184 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableArray arrayWithCapacity:](&OBJC_CLASS___NSMutableArray, "arrayWithCapacity:", v196));
      if (v196)
      {
        uint64_t v120 = 0LL;
        do
        {
          unsigned __int8 v121 = (void *)objc_claimAutoreleasedReturnValue( +[NSData dataWithBytes:length:]( &OBJC_CLASS___NSData,  "dataWithBytes:length:",  *(void *)(v262[6] + v120),  *(void *)(v262[6] + v120 + 8) - *(void *)(v262[6] + v120)));
          [v184 addObject:v121];

          v120 += 24LL;
        }

        while (24LL * v196 != v120);
      }

      BOOL v173 = (void *)objc_claimAutoreleasedReturnValue( +[NSMutableDictionary dictionaryWithCapacity:]( &OBJC_CLASS___NSMutableDictionary,  "dictionaryWithCapacity:",  -[GTUSCSamplingStreamingManagerHelper count](v186, "count")));
      unint64_t v122 = (void *)objc_claimAutoreleasedReturnValue([v173 objectForKeyedSubscript:@"passNum"]);
      [v173 setObject:v122 forKeyedSubscript:@"passNum"];

      __int128 v175 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableArray arrayWithCapacity:](&OBJC_CLASS___NSMutableArray, "arrayWithCapacity:", v196));
      unsigned int v123 = v186;
      if (v196)
      {
        v176 = 0LL;
        do
        {
          BOOL v124 = (void *)objc_claimAutoreleasedReturnValue( -[GTUSCSamplingStreamingManagerHelper objectForKeyedSubscript:]( v123,  "objectForKeyedSubscript:",  @"passList"));
          id v190 = (id)objc_claimAutoreleasedReturnValue([v124 objectAtIndexedSubscript:v176]);

          id v197 = (void *)objc_claimAutoreleasedReturnValue( +[NSMutableArray arrayWithCapacity:]( NSMutableArray,  "arrayWithCapacity:",  [v190 count]));
          __int128 v230 = 0u;
          __int128 v231 = 0u;
          __int128 v228 = 0u;
          __int128 v229 = 0u;
          id v191 = v190;
          id v125 = [v191 countByEnumeratingWithState:&v228 objects:v315 count:16];
          if (v125)
          {
            uint64_t v194 = *(void *)v229;
            do
            {
              id v203 = v125;
              for (i2 = 0LL; i2 != v203; i2 = (char *)i2 + 1)
              {
                if (*(void *)v229 != v194) {
                  objc_enumerationMutation(v191);
                }
                uint64_t v127 = *(void **)(*((void *)&v228 + 1) + 8LL * (void)i2);
                uint64_t v128 = (void *)objc_claimAutoreleasedReturnValue([(id)qword_5B9498 arrayByAddingObjectsFromArray:v127]);
                uint64_t v129 = (void *)objc_claimAutoreleasedReturnValue( +[NSMutableArray arrayWithCapacity:]( NSMutableArray,  "arrayWithCapacity:",  [v128 count]));
                __int128 v226 = 0u;
                __int128 v227 = 0u;
                __int128 v224 = 0u;
                __int128 v225 = 0u;
                id v130 = v127;
                id v131 = [v130 countByEnumeratingWithState:&v224 objects:v314 count:16];
                if (v131)
                {
                  uint64_t v132 = *(void *)v225;
                  do
                  {
                    for (i3 = 0LL; i3 != v131; i3 = (char *)i3 + 1)
                    {
                      if (*(void *)v225 != v132) {
                        objc_enumerationMutation(v130);
                      }
                      [v129 addObject:v134];
                    }

                    id v131 = [v130 countByEnumeratingWithState:&v224 objects:v314 count:16];
                  }

                  while (v131);
                }

                [v197 addObject:v129];
              }

              id v125 = [v191 countByEnumeratingWithState:&v228 objects:v315 count:16];
            }

            while (v125);
          }

          [v175 addObject:v197];
          ++v176;
          unsigned int v123 = v186;
        }

        while (v176 != v179);
      }

      uint64_t v135 = p_p;
      unint64_t v136 = (unint64_t)p_p[9];
      if (v136)
      {
        if (v136 >> 60) {
          abort();
        }
        size_t v137 = 16 * v136;
        uint64_t v138 = (char *)operator new(16 * v136);
        bzero(v138, v137);
        unint64_t v139 = &v138[v137];
      }

      else
      {
        uint64_t v138 = 0LL;
        unint64_t v139 = 0LL;
      }

      for (i4 = (unsigned int *)v135[8]; i4; i4 = *(unsigned int **)i4)
      {
        unint64_t v141 = i4[6];
        if ((v139 - v138) >> 4 > v141)
        {
          char v142 = &v138[16 * v141];
          unint64_t v143 = i4[7] | ((unint64_t)*((unsigned int *)v142 + 1) << 32);
          *(void *)char v142 = v143;
          unint64_t v144 = v143 & 0xFFFF0000FFFFFFFFLL | ((unint64_t)*((unsigned __int16 *)i4 + 16) << 32);
          *(void *)char v142 = v144;
          *(void *)char v142 = v144 & 0xFFFFFFFFFFFFLL | ((unint64_t)(unsigned __int16)i4[9] << 48);
          *((void *)v142 + 1) = *((void *)i4 + 5);
        }
      }

      id v168 = v138;
      if (!dword_5B8CBC) {
        mach_timebase_info((mach_timebase_info_t)&GTUSCSamplingStreamingManagerHelper::StreamEncoderDerivedCounterData(void)::timebaseInfo);
      }
      id v169 = (void *)objc_claimAutoreleasedReturnValue( +[NSMutableData dataWithBytes:length:]( &OBJC_CLASS___NSMutableData,  "dataWithBytes:length:",  v138,  v139 - v138));
      __int128 v222 = 0u;
      __int128 v223 = 0u;
      __int128 v220 = 0u;
      __int128 v221 = 0u;
      id v180 = v185;
      unint64_t v145 = 0LL;
      unint64_t v146 = (char *)[v180 countByEnumeratingWithState:&v220 objects:v313 count:16];
      if (v146)
      {
        uint64_t v147 = 0LL;
        uint64_t v177 = *(void *)v221;
        do
        {
          uint64_t v148 = 0LL;
          uint64_t v170 = v146;
          do
          {
            if (*(void *)v221 != v177) {
              objc_enumerationMutation(v180);
            }
            v149 = *(void **)(*((void *)&v220 + 1) + 8LL * (void)v148);
            __int128 v216 = 0u;
            __int128 v217 = 0u;
            __int128 v218 = 0u;
            __int128 v219 = 0u;
            id v204 = v149;
            id v150 = [v204 countByEnumeratingWithState:&v216 objects:v312 count:16];
            id v192 = v148;
            unint64_t v195 = v145;
            uint64_t v198 = v147;
            unint64_t v151 = 0LL;
            if (v150)
            {
              uint64_t v152 = *(void *)v217;
              do
              {
                for (i5 = 0LL; i5 != v150; i5 = (char *)i5 + 1)
                {
                  if (*(void *)v217 != v152) {
                    objc_enumerationMutation(v204);
                  }
                  __int128 v154 = *(void **)(*((void *)&v216 + 1) + 8LL * (void)i5);
                  __int128 v212 = 0u;
                  __int128 v213 = 0u;
                  __int128 v214 = 0u;
                  __int128 v215 = 0u;
                  id v155 = v154;
                  id v156 = [v155 countByEnumeratingWithState:&v212 objects:v311 count:16];
                  if (v156)
                  {
                    uint64_t v157 = *(void *)v213;
                    do
                    {
                      for (i6 = 0LL; i6 != v156; i6 = (char *)i6 + 1)
                      {
                        if (*(void *)v213 != v157) {
                          objc_enumerationMutation(v155);
                        }
                        v151 += (unint64_t)[*(id *)(*((void *)&v212 + 1) + 8 * (void)i6) length];
                      }

                      id v156 = [v155 countByEnumeratingWithState:&v212 objects:v311 count:16];
                    }

                    while (v156);
                  }
                }

                id v150 = [v204 countByEnumeratingWithState:&v216 objects:v312 count:16];
              }

              while (v150);
            }

            NSLog(@"Total RDE Counter Data for pass %u %llu kB", v198, v151 >> 10);
            unint64_t v145 = v151 + v195;
            uint64_t v147 = (v198 + 1);
            uint64_t v148 = v192 + 1;
          }

          while (v192 + 1 != v170);
          unint64_t v146 = (char *)[v180 countByEnumeratingWithState:&v220 objects:v313 count:16];
        }

        while (v146);
      }

      v159 = (void *)qword_5B94F8;
      if (!qword_5B94F8) {
        v159 = &__NSDictionary0__struct;
      }
      id v160 = v159;
      NSLog(@"Total RDE Counter Data %llu kB", v145 >> 10);
      [v173 setObject:v175 forKeyedSubscript:@"passList"];
      v299[0] = @"Derived Counter Sample Data";
      v299[1] = @"Subdivided Dictionary";
      v300[0] = v180;
      v300[1] = v173;
      v300[2] = v184;
      v299[2] = @"Encoder Infos";
      v299[3] = @"Encoder Tile Info";
      uint64_t v301 = objc_claimAutoreleasedReturnValue( +[NSData dataWithBytes:length:]( &OBJC_CLASS___NSData,  "dataWithBytes:length:",  v253[6],  (char *)v253[7] - (char *)v253[6]));
      v302 = v54;
      v299[4] = @"Counter Info";
      v299[5] = @"Num Encoders";
      id v205 = (id)v301;
      v199 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedInteger:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedInteger:",  v174));
      v303 = v199;
      v304 = v183;
      v299[6] = @"Encoder Time Sample Data";
      v299[7] = @"Encoder Sample Index Data";
      v305 = v169;
      v299[8] = @"Timebase";
      id v161 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedInt:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedInt:",  GTUSCSamplingStreamingManagerHelper::StreamEncoderDerivedCounterData(void)::timebaseInfo));
      v298[0] = v161;
      char v162 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedInt:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedInt:",  dword_5B8CBC));
      v298[1] = v162;
      uint64_t v163 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", v298, 2LL));
      v306 = v163;
      v299[9] = @"Source Sample Marker";
      unint64_t v164 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  qword_5B8CF0));
      v307 = v164;
      v299[10] = @"Derived Counters Info Data";
      uint64_t v165 = *(void **)(GTUSCSamplingStreamingManagerHelper::Instance(void)::instance + 48);
      if (!v165) {
        uint64_t v165 = &__NSDictionary0__struct;
      }
      v308 = v165;
      id v309 = v160;
      v299[11] = @"Perf Info";
      v299[12] = @"Fragment Counter";
      if (obj) {
        v166 = (__CFString *)objc_claimAutoreleasedReturnValue([obj firstObject]);
      }
      else {
        v166 = &stru_591D98;
      }
      v310 = v166;
      id v167 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v300,  v299,  13LL));
      if (obj) {

      }
      (*(void (**)(void))(*(void *)(GTUSCSamplingStreamingManagerHelper::Instance(void)::instance + 32) + 16LL))();
      if (v168) {
        operator delete(v168);
      }

      _Block_object_dispose(&v252, 8);
      if (v258)
      {
        v259 = v258;
        operator delete(v258);
      }

      _Block_object_dispose(&v261, 8);
      v252 = (void **)v267;
      std::vector<std::vector<DYMTLEncoderInfo>>::__destroy_vector::operator()[abi:nn180100](&v252);
      _Block_object_dispose(v268, 8);
      std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long>>>::~__hash_table((uint64_t)&v268[6]);
      _Block_object_dispose(&__p, 8);
      std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long>>>::~__hash_table((uint64_t)&v275[8]);

      unint64_t v77 = v186;
    }
  }
}

      LOWORD(v6) = 0;
      LOWORD(v25) = 0;
      int v27 = 0LL;
      id v28 = 0LL;
      unsigned int v33 = 0LL;
      goto LABEL_20;
    }

    if (a5)
    {
      if (v15 <= 8)
      {
        uint64_t v51 = *a5;
        id v112 = 0u;
        id v113 = 0u;
        id v109 = v51;
        uint64_t v110 = 500;
        __int128 v111 = "9 <= parser.ntokens";
        unint64_t v52 = v21;
        unint64_t v53 = v29;
        id v54 = v31;
        uint64_t v55 = v30;
        GTError_addError(a5, (uint64_t)&v109);
        uint64_t v30 = v55;
        id v31 = v54;
        id v29 = v53;
        unsigned int v21 = v52;
LABEL_77:
        id v24 = 0;
        LOWORD(v6) = 0;
        LOWORD(v25) = 0;
        uint64_t v26 = 0LL;
        int v27 = 0LL;
        id v28 = 0LL;
LABEL_93:
        unsigned int v33 = 0LL;
        LOBYTE(v32) = 1;
        goto LABEL_20;
      }
    }

    else if (v15 < 9)
    {
      goto LABEL_77;
    }

    id v28 = *(unsigned int *)v123 | ((unint64_t)(unsigned __int16)*(void *)v122 << 32);
    if (v15 >= 0xC)
    {
      id v75 = *(void *)v124;
      id v28 = *(unsigned int *)v123 | ((unint64_t)(unsigned __int16)*(void *)v122 << 32) & 0xFF00FFFFFFFFFFFFLL | ((unint64_t)*(void *)v124 << 48);
      if (*v126)
      {
        unint64_t v101 = v21;
        uint64_t v105 = *(unsigned int *)v123 | ((unint64_t)(unsigned __int16)*(void *)v122 << 32) & 0xFF00FFFFFFFFFFFFLL | ((unint64_t)*(void *)v124 << 48);
        uint64_t v92 = *v121;
        uint64_t v95 = *v119;
        BOOL v98 = *v120 & 1;
        unint64_t v76 = *(void *)v125;
        unsigned int v33 = a3[15];
        unint64_t v77 = a3[16];
        a3[15] = v33 + 24;
        a3[16] = v77 + 24;
        uint64_t v8 = DecodeDYMTLStructType(v77, (unsigned int *)((char *)v8 + *v8), a3, v6, a5);
        if (!(_DWORD)v6) {
          return v8;
        }
        unint64_t v78 = v77;
        *(_BYTE *)unsigned int v33 = 60;
        *(_BYTE *)(v33 + 22) = v75;
        *(_DWORD *)(v33 + 16) = v76;
        if (a5 && v75 != 1LL)
        {
          BOOL v79 = *a5;
          id v112 = 0u;
          id v113 = 0u;
          id v109 = v79;
          uint64_t v110 = 500;
          __int128 v111 = "result.threadgroupMemory.dataType == GTMTLDataTypeStruct";
          GTError_addError(a5, (uint64_t)&v109);
        }

        int v27 = 0LL;
        uint64_t v26 = 0LL;
        LOWORD(v25) = 0;
        LOWORD(v6) = 0;
        id v24 = 0;
        *(void *)(v33 + _Block_object_dispose(&STACK[0x3B0], 8) = v78;
        LOBYTE(v32) = 1;
        unsigned int v21 = v101;
        id v28 = v105;
        id v31 = v95;
        id v29 = v98;
        uint64_t v30 = v92;
        goto LABEL_21;
      }
    }

    id v24 = 0;
    LOWORD(v6) = 0;
    LOWORD(v25) = 0;
    uint64_t v26 = 0LL;
    int v27 = 0LL;
    goto LABEL_93;
  }

  if (a5)
  {
    if (v15 <= 9)
    {
      uint64_t v46 = *a5;
      id v112 = 0u;
      id v113 = 0u;
      id v109 = v46;
      uint64_t v110 = 500;
      __int128 v111 = "10 <= parser.ntokens";
      id v47 = v21;
      uint64_t v48 = v29;
      id v49 = v31;
      id v50 = v30;
      GTError_addError(a5, (uint64_t)&v109);
      uint64_t v30 = v50;
      id v31 = v49;
      id v29 = v48;
      unsigned int v21 = v47;
LABEL_68:
      id v24 = 0;
      LOWORD(v6) = 0;
      LOWORD(v25) = 0;
      uint64_t v26 = 0LL;
      int v27 = 0LL;
      id v28 = 0LL;
LABEL_97:
      LOBYTE(v32) = 0;
      unsigned int v33 = 0LL;
      goto LABEL_20;
    }
  }

  else if (v15 < 0xA)
  {
    goto LABEL_68;
  }

  id v28 = *(unsigned int *)v123 | ((unint64_t)(unsigned __int16)*(void *)v122 << 32) & 0xFF00FFFFFFFFFFFFLL | ((unint64_t)*(void *)v124 << 48);
  if (v15 < 0xC)
  {
    id v24 = 0;
    LOWORD(v6) = 0;
    LOWORD(v25) = 0;
    uint64_t v26 = 0LL;
    int v27 = 0LL;
    goto LABEL_97;
  }

  if (*(_BYTE *)v125)
  {
    uint64_t v104 = *(unsigned int *)v123 | ((unint64_t)(unsigned __int16)*(void *)v122 << 32) & 0xFF00FFFFFFFFFFFFLL | ((unint64_t)*(void *)v124 << 48);
    uint64_t v70 = *v121;
    uint64_t v71 = *v119;
    id v72 = *v120 & 1;
    id v73 = v21;
    if (a5 && *(void *)v124 != 1LL)
    {
      id v74 = *a5;
      id v112 = 0u;
      id v113 = 0u;
      id v109 = v74;
      uint64_t v110 = 500;
      __int128 v111 = "result.buffer.dataType == GTMTLDataTypeStruct";
      GTError_addError(a5, (uint64_t)&v109);
    }

    unsigned int v33 = a3[16];
    a3[16] = v33 + 24;
    uint64_t v8 = DecodeDYMTLStructType(v33, (unsigned int *)((char *)v8 + *v8), a3, v6, a5);
    unsigned int v21 = v73;
    id v29 = v72;
    id v31 = v71;
    uint64_t v30 = v70;
    id v28 = v104;
  }

  else
  {
    unsigned int v33 = 0LL;
  }

  id v24 = 0;
  LOWORD(v6) = 0;
  LOWORD(v25) = 0;
  uint64_t v26 = 0LL;
  int v27 = 0LL;
  LOBYTE(v32) = 0;
  v28 |= (unint64_t)*v126 << 56;
LABEL_20:
  if (v107)
  {
LABEL_21:
    *(void *)a1 = v21;
    *(void *)(a1 + _Block_object_dispose(&STACK[0x3B0], 8) = v33;
    *(_BYTE *)(a1 + 16) = v32;
    *(_BYTE *)(a1 + 17) = v31;
    *(_BYTE *)(a1 + 1_Block_object_dispose(&STACK[0x3B0], 8) = v30;
    *(_BYTE *)(a1 + 19) = v29;
    *(_DWORD *)(a1 + 20) = 0;
    *(void *)(a1 + 24) = v28;
    *(void *)(a1 + 32) = v27;
    *(void *)(a1 + 40) = v26;
    *(_WORD *)(a1 + 4_Block_object_dispose(&STACK[0x3B0], 8) = v25;
    *(_WORD *)(a1 + 50) = v6;
    *(_BYTE *)(a1 + 52) = v24;
    *(_WORD *)(a1 + 53) = v114;
    *(_BYTE *)(a1 + 55) = v115;
  }

  return v8;
}

void sub_7491C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *__p, void *a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17, void *a18, void *a19, uint64_t a20, void *a21, uint64_t a22, void *a23, void *a24, void *a25, void *a26, void *a27, void *a28, void *a29, void *a30, void *a31, void *a32, void *a33, uint64_t a34, void *a35, _Unwind_Exception *exception_objecta, uint64_t a37, void *a38, uint64_t a39, void *a40, void *a41, uint64_t a42, void *a43, void *a44)
{
  if (__p) {
    operator delete(__p);
  }

  _Block_object_dispose(&STACK[0x340], 8);
  uint64_t v46 = (void *)STACK[0x370];
  if (STACK[0x370])
  {
    STACK[0x378] = (unint64_t)v46;
    operator delete(v46);
  }

  _Block_object_dispose(&STACK[0x388], 8);
  STACK[0x340] = a14;
  std::vector<std::vector<DYMTLEncoderInfo>>::__destroy_vector::operator()[abi:nn180100]((void ***)&STACK[0x340]);
  _Block_object_dispose(&STACK[0x3D0], 8);
  std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long>>>::~__hash_table(a15);
  _Block_object_dispose(&STACK[0x428], 8);
  std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long>>>::~__hash_table(a16);

  _Unwind_Resume(a1);
}

id DeepMutableCopy(NSDictionary *a1)
{
  unsigned __int8 v1 = a1;
  id v2 = v1;
  if (v1)
  {
    v5[0] = _NSConcreteStackBlock;
    v5[1] = 3221225472LL;
    v5[2] = ___ZL15DeepMutableCopyP12NSDictionary_block_invoke;
    v5[3] = &unk_58E3D0;
    id v3 = (id)objc_claimAutoreleasedReturnValue( +[NSMutableDictionary dictionaryWithCapacity:]( &OBJC_CLASS___NSMutableDictionary,  "dictionaryWithCapacity:",  -[NSDictionary count](v1, "count")));
    id v6 = v3;
    -[NSDictionary enumerateKeysAndObjectsUsingBlock:](v2, "enumerateKeysAndObjectsUsingBlock:", v5);
  }

  else
  {
    id v3 = 0LL;
  }

  return v3;
}

void sub_750A4( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{
  _Unwind_Resume(a1);
}

void ___ZN35GTUSCSamplingStreamingManagerHelper31StreamEncoderDerivedCounterDataEv_block_invoke(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 96);
  GTMTLReplayController_prePlayForProfiling(**(void **)v2);
  DisableComputeEncoderCoalescing(**(GTMTLReplayController ***)v2, 1LL);
  id v3 = *(NSDictionary **)(a1 + 32);
  unsigned int v4 = *(_DWORD *)(a1 + 104);
  int v5 = *(_BYTE *)(a1 + 112)
    && [*(id *)(a1 + 40) count]
    && *(_DWORD *)(a1 + 104) + 1 == *(_DWORD *)(a1 + 108);
  if (GTUSCSamplingStreamingManagerHelper::SetupSourceForDerivedCounters((id *)v2, v3, v4, 0, v5))
  {
    id v6 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v2 + 16) firstObject]);
    unsigned __int8 v7 = [v6 startSampling];

    if ((v7 & 1) != 0)
    {
      if (!*(_DWORD *)(*(void *)v2 + 72LL))
      {
        usleep(0x30D40u);
        GTUSCSamplingStreamingManagerHelper::ForceDrainAllSourceBuffers(*(GTUSCSamplingStreamingManagerHelper **)(v2 + 24));
      }

      GTUSCSamplingStreamingManagerHelper::ResetSourceForPostProcessing((id *)v2);
      unsigned int v8 = *(_DWORD *)(a1 + 104);
      if (v8)
      {
        id v9 = 0LL;
        id v10 = 0LL;
        uint64_t v11 = a1 + 88;
      }

      else
      {
        id v9 = (char **)(*(void *)(*(void *)(a1 + 72) + 8LL) + 48LL);
        uint64_t v11 = a1 + 80;
        id v10 = *(void **)(a1 + 48);
      }

      GTUSCSamplingStreamingManagerHelper::ReplayForDerivedCounters( (uint64_t **)v2,  (char **)(*(void *)(*(void *)(*(void *)(a1 + 64) + 8LL) + 48LL) + 24LL * v8),  v9,  0LL,  (void *)(*(void *)(*(void *)v11 + 8LL) + 48LL),  v10);
      id v12 = objc_autoreleasePoolPush();
      id v13 = GTUSCSamplingStreamingManagerHelper::DrainRawDerivedCounterData((id *)v2);
      uint64_t v14 = (void *)objc_claimAutoreleasedReturnValue(v13);
      if (v14) {
        [*(id *)(a1 + 56) setArray:v14];
      }

      objc_autoreleasePoolPop(v12);
      uint64_t v15 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v2 + 16) firstObject]);
      [v15 stopSampling];

      DisableComputeEncoderCoalescing(**(GTMTLReplayController ***)v2, 0LL);
      if (*(_DWORD *)(a1 + 104) + 1 == *(_DWORD *)(a1 + 108))
      {
        GTAGXPerfStateControl::DisableConsistentGPUPerfState((GTAGXPerfStateControl *)(v2 + 40));
        GTApplePMPPerfStateControl::DisableConsistentPerfState((GTApplePMPPerfStateControl *)(v2 + 64));
      }
    }
  }

void sub_75280(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void ___ZN35GTUSCSamplingStreamingManagerHelper31StreamEncoderDerivedCounterDataEv_block_invoke_2( uint64_t a1)
{
  id v2 = GTUSCSamplingStreamingManagerHelper::PostProcessRawDerivedCounterData(*(void *)(a1 + 48), *(void **)(a1 + 32));
  id v3 = (id)objc_claimAutoreleasedReturnValue(v2);
  if (v3) {
    [*(id *)(a1 + 40) addObject:v3];
  }
}

void sub_752E4( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
}

void ___ZN35GTUSCSamplingStreamingManagerHelper31StreamEncoderDerivedCounterDataEv_block_invoke_3( uint64_t a1)
{
  id v2 = *(void **)(a1 + 40);
  id v3 = GTSampleBufferManager::ResolveSampleBuffers((GTSampleBufferManager *)(v2 + 263));
  id v4 = (id)objc_claimAutoreleasedReturnValue(v3);
  if (v4) {
    [*(id *)(a1 + 32) setData:v4];
  }
  v2[269] = 0LL;
  v2[267] = v2[266];
}

void sub_75350( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
}

void ___ZL15DeepMutableCopyP12NSDictionary_block_invoke(uint64_t a1, void *a2, void *a3)
{
  id v13 = a2;
  int v5 = a3;
  uint64_t v7 = objc_opt_class(&OBJC_CLASS___NSDictionary, v6);
  if ((objc_opt_isKindOfClass(v5, v7) & 1) != 0)
  {
    uint64_t v9 = DeepMutableCopy(v5);
    id v10 = (void *)objc_claimAutoreleasedReturnValue(v9);
    [*(id *)(a1 + 32) setObject:v10 forKeyedSubscript:v13];
  }

  else
  {
    uint64_t v11 = objc_opt_class(&OBJC_CLASS___NSArray, v8);
    if ((objc_opt_isKindOfClass(v5, v11) & 1) == 0)
    {
      [*(id *)(a1 + 32) setObject:v5 forKeyedSubscript:v13];
      goto LABEL_7;
    }

    id v12 = DeepMutableCopy((NSArray *)v5);
    id v10 = (void *)objc_claimAutoreleasedReturnValue(v12);
    [*(id *)(a1 + 32) setObject:v10 forKeyedSubscript:v13];
  }

LABEL_7:
}

void sub_75440( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

id DeepMutableCopy(NSArray *a1)
{
  unsigned __int8 v1 = a1;
  id v2 = v1;
  if (v1)
  {
    v5[0] = _NSConcreteStackBlock;
    v5[1] = 3221225472LL;
    v5[2] = ___ZL15DeepMutableCopyP7NSArray_block_invoke;
    v5[3] = &unk_58D9A0;
    id v3 = (id)objc_claimAutoreleasedReturnValue( +[NSMutableArray arrayWithCapacity:]( &OBJC_CLASS___NSMutableArray,  "arrayWithCapacity:",  -[NSArray count](v1, "count")));
    id v6 = v3;
    -[NSArray enumerateObjectsUsingBlock:](v2, "enumerateObjectsUsingBlock:", v5);
  }

  else
  {
    id v3 = 0LL;
  }

  return v3;
}

void sub_75518( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{
  _Unwind_Resume(a1);
}

void ___ZL15DeepMutableCopyP7NSArray_block_invoke(uint64_t a1, void *a2)
{
  id v13 = a2;
  uint64_t v4 = objc_opt_class(&OBJC_CLASS___NSDictionary, v3);
  if ((objc_opt_isKindOfClass(v13, v4) & 1) != 0)
  {
    id v6 = *(void **)(a1 + 32);
    uint64_t v7 = DeepMutableCopy(v13);
    uint64_t v8 = (void *)objc_claimAutoreleasedReturnValue(v7);
    [v6 addObject:v8];
  }

  else
  {
    uint64_t v9 = objc_opt_class(&OBJC_CLASS___NSArray, v5);
    char isKindOfClass = objc_opt_isKindOfClass(v13, v9);
    uint64_t v11 = *(void **)(a1 + 32);
    if ((isKindOfClass & 1) == 0)
    {
      [*(id *)(a1 + 32) addObject:v13];
      goto LABEL_7;
    }

    uint64_t v12 = DeepMutableCopy((NSArray *)v13);
    uint64_t v8 = (void *)objc_claimAutoreleasedReturnValue(v12);
    [v11 addObject:v8];
  }

LABEL_7:
}

void sub_755FC( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void ___ZN35GTUSCSamplingStreamingManagerHelper17StreamGPUTimelineEv_block_invoke(uint64_t a1)
{
}

void GTUSCSamplingStreamingManagerHelper::InitAPSStreaming( GTUSCSamplingStreamingManagerHelper *this, GTUSCSamplingStreamingManager *a2)
{
  if ((_DWORD)xmmword_5B955C == 2)
  {
    GTUSCSamplingStreamingManagerHelper::CleanupForAPSStreaming(this);
    GTUSCSamplingStreamingManagerHelper::SetupGPURawCounters(v2);
  }

  else
  {
    GTUSCSamplingStreamingManagerHelper::Init(this, a2);
    GTUSCSamplingStreamingManagerHelper::SetupGPURawCounters(v3);
    GTAGXProfilingSupportHelper::Initialize((GTAGXProfilingSupportHelper *)qword_5B9490, v4);
  }

  id v5 = GTUSCSamplingStreamingManagerHelper::AllocUSCSamplingAddressBuffer((GTUSCSamplingStreamingManagerHelper *)&GTUSCSamplingStreamingManagerHelper::Instance(void)::instance);
  qword_5B9460 = (uint64_t)[(id)qword_5B9480 mutableBytes];
  id v6 = -[ProgramAddressTableCollector initForHarvestingBinaries]( objc_alloc(&OBJC_CLASS___ProgramAddressTableCollector),  "initForHarvestingBinaries");
  uint64_t v7 = (void *)xmmword_5B9468;
  *(void *)&xmmword_5B9468 = v6;

  if ((_DWORD)qword_5B9550 != -1)
  {
    GTUSCSamplingStreamingManagerHelper::SetupBuffersForAPSSource(v8);
    uint64_t v9 = (void *)objc_claimAutoreleasedReturnValue([*((id *)&xmmword_5B8CE0 + 1) objectAtIndexedSubscript:(int)qword_5B9550]);
    if ((qword_5B9940 & 2) != 0)
    {
      id v11 = -[GTGPUAPSConfig initForMinimumInfoTimeline]( objc_alloc(&OBJC_CLASS___GTGPUAPSConfig),  "initForMinimumInfoTimeline");
    }

    else
    {
      if ((_DWORD)xmmword_5B955C == 2) {
        id v10 = -[GTGPUAPSConfig initForTimeline](objc_alloc(&OBJC_CLASS___GTGPUAPSConfig), "initForTimeline");
      }
      else {
        id v10 = -[GTGPUAPSConfig initForProfiling](objc_alloc(&OBJC_CLASS___GTGPUAPSConfig), "initForProfiling");
      }
      id v11 = v10;
      uint64_t v12 = *(void **)(GTUSCSamplingStreamingManagerHelper::Instance(void)::instance + 16);
      if ((_DWORD)xmmword_5B955C == 2) {
        uint64_t v13 = objc_claimAutoreleasedReturnValue([v12 objectForKeyedSubscript:@"TimelineConfig"]);
      }
      else {
        uint64_t v13 = objc_claimAutoreleasedReturnValue([v12 objectForKeyedSubscript:@"apsProfilingConfig"]);
      }
      uint64_t v14 = (void *)v13;
      if (v13) {
        [v11 readConfig:v13];
      }
    }

    uint64_t v15 = objc_claimAutoreleasedReturnValue([v11 grcOptions]);
    uint64_t v16 = (void *)qword_5B94E0;
    qword_5B94E0 = v15;

    uint64_t v17 = objc_claimAutoreleasedReturnValue(+[NSMutableArray arrayWithCapacity:](&OBJC_CLASS___NSMutableArray, "arrayWithCapacity:", 1LL));
    id v18 = (void *)xmmword_5B94E8;
    *(void *)&xmmword_5B94E8 = v17;

    unsigned int v19 = (void *)xmmword_5B94E8;
    uint64_t v20 = (void *)objc_claimAutoreleasedReturnValue([v11 grcTrigger]);
    unsigned int v21 = (void *)objc_claimAutoreleasedReturnValue( +[GPURawCounterSourceTriggerSelect selectWithName:options:]( &OBJC_CLASS___GPURawCounterSourceTriggerSelect,  "selectWithName:options:",  @"KickAndStateTracing",  v20));
    [v19 addObject:v21];

    if ((_DWORD)xmmword_5B955C == 2) {
      unsigned int v22 = @"Timeline";
    }
    else {
      unsigned int v22 = @"Profiling";
    }
    BOOL v23 = v22;
    uint64_t v24 = *(void *)(GTUSCSamplingStreamingManagerHelper::Instance(void)::instance + 32);
    int v27 = @"Streaming APS Profiling";
    id v28 = v23;
    id v25 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v28,  &v27,  1LL));
    (*(void (**)(uint64_t, void *))(v24 + 16))(v24, v25);

    GTUSCSamplingStreamingManagerHelper::InitRDELimiterCounters(v26);
  }

void sub_758DC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void GTUSCSamplingStreamingManagerHelper::CleanupForAPSStreaming(GTUSCSamplingStreamingManagerHelper *this)
{
  qword_5B9458 = 0LL;
  dword_5B9544 = 0;
  qword_5B9548 = 1LL;
  id v2 = (void **)*((void *)&xmmword_5B9600 + 1);
  unsigned __int8 v1 = (void **)xmmword_5B9600;
  while (v2 != v1)
  {
    v2 -= 3;
    uint64_t v17 = v2;
    std::vector<GTMMappedBuffer>::__destroy_vector::operator()[abi:nn180100](&v17);
  }

  *((void *)&xmmword_5B9600 + 1) = v1;
  uint64_t v3 = qword_5B95E8;
  uint64_t v4 = (void **)xmmword_5B95F0;
  while (v4 != (void **)v3)
  {
    v4 -= 3;
    uint64_t v17 = v4;
    std::vector<GTMMappedBuffer>::__destroy_vector::operator()[abi:nn180100](&v17);
  }

  *(void *)&xmmword_5B95F0 = v3;
  id v6 = (void **)*((void *)&xmmword_5B9630 + 1);
  id v5 = (void **)xmmword_5B9630;
  while (v6 != v5)
  {
    v6 -= 3;
    uint64_t v17 = v6;
    std::vector<GTMMappedBuffer>::__destroy_vector::operator()[abi:nn180100](&v17);
  }

  *((void *)&xmmword_5B9630 + 1) = v5;
  uint64_t v7 = qword_5B9648;
  uint64_t v8 = (void **)xmmword_5B9650;
  while (v8 != (void **)v7)
  {
    v8 -= 3;
    uint64_t v17 = v8;
    std::vector<NSObject  {objcproto21OS_dispatch_semaphore}* {__strong}>::__destroy_vector::operator()[abi:nn180100](&v17);
  }

  *(void *)&xmmword_5B9650 = v7;
  id v10 = (void **)*((void *)&xmmword_5B9660 + 1);
  uint64_t v9 = (void **)xmmword_5B9660;
  while (v10 != v9)
  {
    v10 -= 3;
    uint64_t v17 = v10;
    std::vector<NSObject  {objcproto21OS_dispatch_semaphore}* {__strong}>::__destroy_vector::operator()[abi:nn180100](&v17);
  }

  *((void *)&xmmword_5B9660 + 1) = v9;
  uint64_t v11 = *((void *)&xmmword_5B9670 + 1);
  for (uint64_t i = qword_5B9680; i != v11; i -= 8LL)
  {
    uint64_t v13 = *(void **)(i - 8);
  }

  qword_5B9680 = v11;
  uint64_t v14 = xmmword_5B9910;
  uint64_t v15 = *((void *)&xmmword_5B9900 + 1);
  while (v14 != v15)
  {
    uint64_t v16 = *(void **)(v14 - 32);
    v14 -= 32LL;
  }

  *(void *)&xmmword_5B9910 = v15;
}

void GTUSCSamplingStreamingManagerHelper::InitRDELimiterCounters(GTUSCSamplingStreamingManagerHelper *this)
{
  unsigned __int8 v1 = (void *)objc_claimAutoreleasedReturnValue( [*(id *)(GTUSCSamplingStreamingManagerHelper::Instance(void)::instance + 40) objectForKeyedSubscript:@"profileCounters"]);
  id v77 = [v1 mutableCopy];

  id v2 = (void *)objc_claimAutoreleasedReturnValue( [*(id *)(GTUSCSamplingStreamingManagerHelper::Instance(void)::instance + 40) objectForKeyedSubscript:@"profileCounters32"]);
  uint64_t v3 = objc_claimAutoreleasedReturnValue(+[NSSet setWithArray:](&OBJC_CLASS___NSSet, "setWithArray:", v2));

  uint64_t v4 = qword_5B9728;
  uint64_t v5 = xmmword_5B9730;
  memset(v93, 0, sizeof(v93));
  int v94 = 1065353216;
  id v75 = (void *)v3;
  if (qword_5B9728 != (void)xmmword_5B9730)
  {
    do
    {
      std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::__emplace_unique_key_args<std::string,std::string const&>( (uint64_t)v93,  v4,  v4);
      v4 += 24LL;
    }

    while (v4 != v5);
  }

  uint64_t v6 = objc_claimAutoreleasedReturnValue( +[NSMutableArray arrayWithCapacity:]( &OBJC_CLASS___NSMutableArray,  "arrayWithCapacity:",  0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*((void *)&xmmword_5B96E0 + 1) - xmmword_5B96E0) >> 3)));
  uint64_t v7 = (void *)xmmword_5B94A8;
  *(void *)&xmmword_5B94A8 = v6;

  BOOL v80 = (void *)objc_claimAutoreleasedReturnValue( +[NSMutableArray arrayWithCapacity:]( NSMutableArray,  "arrayWithCapacity:",  [v77 count]));
  uint64_t v8 = (void *)objc_claimAutoreleasedReturnValue( +[NSMutableSet setWithCapacity:]( NSMutableSet,  "setWithCapacity:",  [v77 count]));
  uint64_t v10 = *((void *)&xmmword_5B96E0 + 1);
  for (uint64_t i = xmmword_5B96E0; i != v10; i += 24LL)
  {
    uint64_t v11 = std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::find<std::string>( *(uint64_t *)&v93[0],  *((unint64_t *)&v93[0] + 1),  i);
    int v12 = *(char *)(i + 23);
    uint64_t v13 = i;
    if (v11)
    {
      if (v12 < 0) {
        uint64_t v13 = *(void *)i;
      }
      uint64_t v14 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", v13));
      uint64_t v15 = (void *)objc_claimAutoreleasedReturnValue( +[GPURawCounterSelect selectWithName:options:]( &OBJC_CLASS___GPURawCounterSelect,  "selectWithName:options:",  v14,  &off_59FCF0));
      [v80 addObject:v15];
    }

    else
    {
      if (v12 < 0) {
        uint64_t v13 = *(void *)i;
      }
      uint64_t v14 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", v13));
      uint64_t v15 = (void *)objc_claimAutoreleasedReturnValue( +[GPURawCounterSelect selectWithName:options:]( &OBJC_CLASS___GPURawCounterSelect,  "selectWithName:options:",  v14,  &off_59FD18));
      [v80 addObject:v15];
    }

    uint64_t v16 = i;
    uint64_t v17 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", v16));
    [v8 addObject:v17];
  }

  if ((_DWORD)xmmword_5B955C == 1)
  {
    unsigned int v19 = (uint64_t *)*((void *)&xmmword_5B9710 + 1);
    for (int j = (uint64_t *)xmmword_5B9710; j != v19; j += 3)
    {
      uint64_t v20 = j;
      unsigned int v21 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", v20));
      unsigned int v22 = (void *)objc_claimAutoreleasedReturnValue( +[GPURawCounterSelect selectWithName:options:]( &OBJC_CLASS___GPURawCounterSelect,  "selectWithName:options:",  v21,  &off_59FD40));
      [v80 addObject:v22];

      BOOL v23 = j;
      uint64_t v24 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", v23));
      [v8 addObject:v24];
    }
  }

  id v25 = (void *)objc_claimAutoreleasedReturnValue( +[NSMutableDictionary dictionaryWithCapacity:]( &OBJC_CLASS___NSMutableDictionary,  "dictionaryWithCapacity:",  0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*((void *)&xmmword_5B96E0 + 1) - xmmword_5B96E0) >> 3)));
  for (unint64_t k = 0; k < (unint64_t)[*((id *)&xmmword_5B8CE0 + 1) count]; ++k)
  {
    unint64_t v81 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*((id *)&xmmword_5B8CE0 + 1), "objectAtIndexedSubscript:"));
    uint64_t v26 = (void *)objc_claimAutoreleasedReturnValue([v81 availableCounters]);
    __int128 v91 = 0u;
    __int128 v92 = 0u;
    __int128 v89 = 0u;
    __int128 v90 = 0u;
    id v27 = v26;
    id v28 = [v27 countByEnumeratingWithState:&v89 objects:v98 count:16];
    if (v28)
    {
      uint64_t v29 = *(void *)v90;
      do
      {
        for (uint64_t m = 0LL; m != v28; uint64_t m = (char *)m + 1)
        {
          if (*(void *)v90 != v29) {
            objc_enumerationMutation(v27);
          }
          id v31 = *(void **)(*((void *)&v89 + 1) + 8LL * (void)m);
          uint64_t v32 = (void *)objc_claimAutoreleasedReturnValue([v31 name]);
          unsigned int v33 = [v8 containsObject:v32];

          if (v33)
          {
            id v34 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedInteger:]( NSNumber,  "numberWithUnsignedInteger:",  [v31 counterValueType]));
            uint64_t v35 = (void *)objc_claimAutoreleasedReturnValue([v31 name]);
            [v25 setObject:v34 forKeyedSubscript:v35];
          }
        }

        id v28 = [v27 countByEnumeratingWithState:&v89 objects:v98 count:16];
      }

      while (v28);
    }
  }

  uint64_t v36 = (void *)qword_5B94A0;
  qword_5B94A0 = 0LL;

  uint64_t v37 = objc_claimAutoreleasedReturnValue( +[NSMutableArray arrayWithCapacity:]( NSMutableArray,  "arrayWithCapacity:",  [&off_59F830 count]));
  uint64_t v38 = (void *)qword_5B9498;
  qword_5B9498 = v37;

  for (uint64_t n = 0LL; n != 7; ++n)
  {
    unint64_t v40 = (void *)qword_5B9498;
    id v41 = (void *)objc_claimAutoreleasedReturnValue([&off_59F830 objectAtIndexedSubscript:n]);
    uint64_t v42 = (void *)objc_claimAutoreleasedReturnValue( +[GPURawCounterSelect selectWithName:options:]( &OBJC_CLASS___GPURawCounterSelect,  "selectWithName:options:",  v41,  0LL));
    [v40 addObject:v42];
  }

  id v43 = GTUSCSamplingStreamingManagerHelper::SubDividedCounterDictionary(v80);
  unint64_t v76 = (void *)objc_claimAutoreleasedReturnValue(v43);
  uint64_t v44 = (void *)objc_claimAutoreleasedReturnValue([v76 objectForKeyedSubscript:@"passList"]);
  unint64_t v82 = (void *)objc_claimAutoreleasedReturnValue([v44 objectAtIndexedSubscript:0]);

  unint64_t v78 = (void *)objc_claimAutoreleasedReturnValue( +[NSMutableArray arrayWithCapacity:]( NSMutableArray,  "arrayWithCapacity:",  [v80 count]));
  BOOL v79 = (void *)objc_claimAutoreleasedReturnValue( +[NSMutableDictionary dictionaryWithCapacity:]( NSMutableDictionary,  "dictionaryWithCapacity:",  [v76 count]));
  for (iuint64_t i = 0; ii < (unint64_t)[v82 count]; ++ii)
  {
    int64_t v84 = (void *)objc_claimAutoreleasedReturnValue([v82 objectAtIndexedSubscript:ii]);
    if ([v84 count])
    {
      id v47 = (void *)objc_claimAutoreleasedReturnValue( +[NSMutableArray arrayWithCapacity:]( NSMutableArray,  "arrayWithCapacity:",  [v84 count]));
      __int128 v87 = 0u;
      __int128 v88 = 0u;
      __int128 v85 = 0u;
      __int128 v86 = 0u;
      id v48 = v84;
      id v49 = [v48 countByEnumeratingWithState:&v85 objects:v97 count:16];
      if (v49)
      {
        uint64_t v50 = *(void *)v86;
        do
        {
          for (jint j = 0LL; jj != v49; jint j = (char *)jj + 1)
          {
            if (*(void *)v86 != v50) {
              objc_enumerationMutation(v48);
            }
            unint64_t v52 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(*((void *)&v85 + 1) + 8 * (void)jj) name]);
            [v47 addObject:v52];
          }

          id v49 = [v48 countByEnumeratingWithState:&v85 objects:v97 count:16];
        }

        while (v49);
      }

      unint64_t v53 = (void *)objc_claimAutoreleasedReturnValue([*((id *)&xmmword_5B8CE0 + 1) objectAtIndexedSubscript:ii]);
      id v54 = (void *)objc_claimAutoreleasedReturnValue([v53 name]);
      [v79 setObject:v47 forKeyedSubscript:v54];

      [v78 addObjectsFromArray:v47];
      if (ii == (int)qword_5B9550)
      {
        id v56 = (void *)objc_opt_new(&OBJC_CLASS___NSMutableArray, v55);
      }

      else
      {
        id v58 = [(id)qword_5B9498 copy];
        id v56 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableArray arrayWithArray:](&OBJC_CLASS___NSMutableArray, "arrayWithArray:", v58));
      }

      [v56 addObjectsFromArray:v48];
      [(id)xmmword_5B94A8 addObject:v56];
    }

    else
    {
      id v57 = (void *)xmmword_5B94A8;
      id v47 = (void *)objc_opt_new(&OBJC_CLASS___NSMutableArray, v46);
      [v57 addObject:v47];
    }
  }

  id v59 = v78;

  [*(id *)(GTUSCSamplingStreamingManagerHelper::Instance(void)::instance + 40) setObject:v59 forKeyedSubscript:@"limiter sample counters"];
  [*(id *)(GTUSCSamplingStreamingManagerHelper::Instance(void)::instance + 40) setObject:v25 forKeyedSubscript:@"Counter Info"];
  [*(id *)(GTUSCSamplingStreamingManagerHelper::Instance(void)::instance + 40) setObject:v79 forKeyedSubscript:@"Limiter Counter List Map"];
  uint64_t v60 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithBool:](&OBJC_CLASS___NSNumber, "numberWithBool:", byte_5B9768));
  [*(id *)(GTUSCSamplingStreamingManagerHelper::Instance(void)::instance + 40) setObject:v60 forKeyedSubscript:@"Uarch Enabled"];

  if ((_DWORD)xmmword_5B955C == 2)
  {
    id v62 = GTAGXProfilingSupportHelper::RemappedCSV(v61);
    uint64_t v63 = (void *)objc_claimAutoreleasedReturnValue(v62);
    if (v63) {
      [*(id *)(GTUSCSamplingStreamingManagerHelper::Instance(void)::instance + 40) setObject:v63 forKeyedSubscript:@"CSV"];
    }
  }

  (*(void (**)(void))(*(void *)(GTUSCSamplingStreamingManagerHelper::Instance(void)::instance + 32) + 16LL))();
  uint64_t v64 = objc_claimAutoreleasedReturnValue(+[NSMutableArray arrayWithCapacity:](&OBJC_CLASS___NSMutableArray, "arrayWithCapacity:", 1LL));
  unint64_t v65 = (void *)qword_5B94D8;
  qword_5B94D8 = v64;

  id v66 = (void *)qword_5B94D8;
  uint64_t v67 = (void *)objc_claimAutoreleasedReturnValue( +[GPURawCounterSourceTriggerSelect selectWithName:options:]( &OBJC_CLASS___GPURawCounterSourceTriggerSelect,  "selectWithName:options:",  @"KickBoundary",  0LL));
  [v66 addObject:v67];

  uint64_t v68 = objc_claimAutoreleasedReturnValue(+[NSMutableArray arrayWithCapacity:](&OBJC_CLASS___NSMutableArray, "arrayWithCapacity:", 1LL));
  uint64_t v69 = (void *)*((void *)&xmmword_5B94C8 + 1);
  *((void *)&xmmword_5B94C8 + 1) = v68;

  if ((qword_5B9940 & 2) != 0) {
    uint64_t v70 = 1200LL;
  }
  else {
    uint64_t v70 = 240LL;
  }
  uint64_t v71 = (void *)*((void *)&xmmword_5B94C8 + 1);
  uint64_t v95 = @"Period";
  id v72 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInteger:](&OBJC_CLASS___NSNumber, "numberWithUnsignedInteger:", v70));
  unint64_t v96 = v72;
  id v73 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v96,  &v95,  1LL));
  id v74 = (void *)objc_claimAutoreleasedReturnValue( +[GPURawCounterSourceTriggerSelect selectWithName:options:]( &OBJC_CLASS___GPURawCounterSourceTriggerSelect,  "selectWithName:options:",  @"TimerNClock",  v73));
  [v71 addObject:v74];

  std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::~__hash_table((uint64_t)v93);
}

void sub_764E8( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, _Unwind_Exception *exception_object, void *a11, void *a12, uint64_t a13, void *a14, void *a15, void *a16, void *a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, char a35)
{
  std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::~__hash_table((uint64_t)&a35);
  _Unwind_Resume(a1);
}

unsigned __int8 *std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::find<std::string>( uint64_t a1, unint64_t a2, uint64_t a3)
{
  int v6 = *(char *)(a3 + 23);
  if (v6 >= 0) {
    uint64_t v7 = (uint64_t *)a3;
  }
  else {
    uint64_t v7 = *(uint64_t **)a3;
  }
  if (v6 >= 0) {
    unint64_t v8 = *(unsigned __int8 *)(a3 + 23);
  }
  else {
    unint64_t v8 = *(void *)(a3 + 8);
  }
  unint64_t v9 = std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:nn180100](v7, v8);
  if (!a2) {
    return 0LL;
  }
  unint64_t v10 = v9;
  uint8x8_t v11 = (uint8x8_t)vcnt_s8((int8x8_t)a2);
  v11.i16[0] = vaddlv_u8(v11);
  unint64_t v12 = v11.u32[0];
  if (v11.u32[0] > 1uLL)
  {
    unint64_t v13 = v9;
    if (v9 >= a2) {
      unint64_t v13 = v9 % a2;
    }
  }

  else
  {
    unint64_t v13 = (a2 - 1) & v9;
  }

  uint64_t v14 = *(unsigned __int8 ***)(a1 + 8 * v13);
  if (!v14) {
    return 0LL;
  }
  for (uint64_t i = *v14; i; uint64_t i = *(unsigned __int8 **)i)
  {
    unint64_t v16 = *((void *)i + 1);
    if (v16 == v10)
    {
    }

    else
    {
      if (v12 > 1)
      {
        if (v16 >= a2) {
          v16 %= a2;
        }
      }

      else
      {
        v16 &= a2 - 1;
      }

      if (v16 != v13) {
        return 0LL;
      }
    }
  }

  return i;
}

void GTUSCSamplingStreamingManagerHelper::StreamAPS(GTUSCSamplingStreamingManagerHelper *this)
{
  unsigned __int8 v1 = atomic_load(byte_5B979C);
  if ((v1 & 1) != 0 || (_DWORD)qword_5B9550 == -1) {
    return;
  }
  uint64_t v23 = *(void *)GTUSCSamplingStreamingManagerHelper::Instance(void)::instance;
  uint64_t v24 = (void *)objc_claimAutoreleasedReturnValue( [*(id *)(*(void *)GTUSCSamplingStreamingManagerHelper::Instance(void)::instance + 8) defaultCommandQueue]);
  [v24 finish];
  GTUSCSamplingStreamingManagerHelper::InitForPreSamplingWait((GTUSCSamplingStreamingManagerHelper *)&GTUSCSamplingStreamingManagerHelper::Instance(void)::instance);
  uint64_t v2 = -1431655765 * ((*((void *)&xmmword_5B9600 + 1) - (void)xmmword_5B9600) >> 3);
  if (!(_DWORD)v2)
  {
LABEL_22:
    usleep(0x3E8u);
    uint64_t v14 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v23 + 8) defaultDevice]);
    if (v14)
    {
      sched_param v64 = 0LL;
      unint64_t v65 = &v64;
      uint64_t v66 = 0x5812000000LL;
      uint64_t v67 = __Block_byref_object_copy__195;
      uint64_t v68 = __Block_byref_object_dispose__196;
      memset(v69, 0, sizeof(v69));
      uint64_t v70 = 0LL;
      int v71 = 1065353216;
      v62[0] = 0LL;
      v62[1] = (pthread_t)v62;
      v62[2] = (pthread_t)0x5812000000LL;
      v62[3] = (pthread_t)__Block_byref_object_copy__269;
      v62[4] = (pthread_t)__Block_byref_object_dispose__270;
      memset(&v62[5], 0, 40);
      int v63 = 1065353216;
      sched_param v53 = 0LL;
      id v54 = &v53;
      uint64_t v55 = 0x4812000000LL;
      id v56 = __Block_byref_object_copy__271;
      id v57 = __Block_byref_object_dispose__272;
      id v58 = "";
      __p = 0LL;
      uint64_t v61 = 0LL;
      uint64_t v60 = 0LL;
      v52[0] = 0LL;
      v52[1] = v52;
      void v52[2] = 0x2020000000LL;
      v52[3] = 0LL;
      v51[0] = 0LL;
      v51[1] = v51;
      void v51[2] = 0x2020000000LL;
      v51[3] = 0LL;
      v50[0] = 0LL;
      v50[1] = (pthread_t)v50;
      void v50[2] = (pthread_t)0x4012000000LL;
      v50[3] = (pthread_t)__Block_byref_object_copy__454;
      v50[4] = (pthread_t)__Block_byref_object_dispose__455;
      v50[5] = (pthread_t)"";
      uint64_t v15 = objc_autoreleasePoolPush();
      uint64_t v17 = (void *)objc_opt_new(&OBJC_CLASS___NSMutableData, v16);
      objc_autoreleasePoolPop(v15);
      v48[0] = 0LL;
      v48[1] = v48;
      v48[2] = 0x3032000000LL;
      v48[3] = __Block_byref_object_copy_;
      v48[4] = __Block_byref_object_dispose_;
      id v49 = (id)objc_opt_new(&OBJC_CLASS___NSMutableDictionary, v18);
      v39[0] = _NSConcreteStackBlock;
      v39[1] = 3221225472LL;
      v39[2] = ___ZN35GTUSCSamplingStreamingManagerHelper9StreamAPSEv_block_invoke;
      v39[3] = &unk_58D928;
      id v41 = &v64;
      uint64_t v42 = &v53;
      id v47 = &GTUSCSamplingStreamingManagerHelper::Instance(void)::instance;
      id v43 = v62;
      id v22 = v17;
      id v40 = v22;
      uint64_t v44 = v48;
      uint64_t v45 = v51;
      uint64_t v46 = v52;
      unsigned int v19 = (void *)objc_claimAutoreleasedReturnValue( +[NSBlockOperation blockOperationWithBlock:]( &OBJC_CLASS___NSBlockOperation,  "blockOperationWithBlock:",  v39));
      v37[0] = 0LL;
      v37[1] = v37;
      v37[2] = 0x2020000000LL;
      char v38 = 0;
      v25[0] = _NSConcreteStackBlock;
      v25[1] = 3221225472LL;
      v25[2] = ___ZN35GTUSCSamplingStreamingManagerHelper9StreamAPSEv_block_invoke_2;
      v25[3] = &unk_58D950;
      id v28 = v52;
      uint64_t v29 = v51;
      uint64_t v36 = &GTUSCSamplingStreamingManagerHelper::Instance(void)::instance;
      uint64_t v30 = v50;
      id v31 = &v64;
      uint64_t v32 = v62;
      id v26 = v14;
      id v27 = 0LL;
      unsigned int v33 = &v53;
      id v34 = v48;
      uint64_t v35 = v37;
      uint64_t v20 = (void *)objc_claimAutoreleasedReturnValue( +[NSBlockOperation blockOperationWithBlock:]( &OBJC_CLASS___NSBlockOperation,  "blockOperationWithBlock:",  v25));
      [v20 setQueuePriority:-8];
      [**(id **)(GTUSCSamplingStreamingManagerHelper::Instance(void)::instance + 8) addOperation:v20];
      [v19 addDependency:v20];
      [*(id *)(*(void *)(GTUSCSamplingStreamingManagerHelper::Instance(void)::instance + 8) + 8) addOperation:v19];
      unsigned int v21 = (GTUSCSamplingStreamingManagerHelper *)[v19 waitUntilFinished];
      atomic_store(1u, (unsigned __int8 *)&unk_5B979B);
      GTUSCSamplingStreamingManagerHelper::SignalAndWaitForAllThreadsToTerminate(v21);
      atomic_load(byte_5B979C);

      _Block_object_dispose(v37, 8);
      _Block_object_dispose(v48, 8);

      _Block_object_dispose(v50, 8);
      _Block_object_dispose(v51, 8);
      _Block_object_dispose(v52, 8);
      _Block_object_dispose(&v53, 8);
      if (__p)
      {
        uint64_t v60 = __p;
        operator delete(__p);
      }

      _Block_object_dispose(v62, 8);
      std::__hash_table<std::__hash_value_type<unsigned int,std::vector<GTCoalescedEncoderIndexInfo>>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,std::vector<GTCoalescedEncoderIndexInfo>>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,std::vector<GTCoalescedEncoderIndexInfo>>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,std::vector<GTCoalescedEncoderIndexInfo>>>>::~__hash_table((uint64_t)&v62[6]);
      _Block_object_dispose(&v64, 8);
      std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long>>>::~__hash_table((uint64_t)&v69[8]);
    }

    return;
  }

  uint64_t v3 = 0LL;
  while (1)
  {
    unsigned int v4 = (*(_DWORD *)(xmmword_5B9600 + 24 * v3 + 8) - *(_DWORD *)(xmmword_5B9600 + 24 * v3)) / 120;
    if (!v3) {
      break;
    }
    if (v4) {
      goto LABEL_11;
    }
LABEL_21:
    if (++v3 == v2) {
      goto LABEL_22;
    }
  }

  unsigned int v5 = v4 / qword_5B9960;
  HIDWORD(qword_5B9960) = v5 - 1;
  dword_5B9968 = v4 - (v5 - 1) * qword_5B9960;
  if (!v4) {
    goto LABEL_21;
  }
LABEL_11:
  int v6 = 0;
  while (1)
  {
    uint64_t v7 = (std::__thread_struct *)operator new(8uLL);
    std::__thread_struct::__thread_struct(v7);
    unint64_t v8 = operator new(0x18uLL);
    *unint64_t v8 = v7;
    v8[1] = &GTUSCSamplingStreamingManagerHelper::Instance(void)::instance;
    *((_DWORD *)v8 + 4) = v3;
    *((_DWORD *)v8 + 5) = v6;
    sched_param v64 = (sched_param)v8;
    int v9 = pthread_create( v62,  0LL,  (void *(__cdecl *)(void *))std::__thread_proxy[abi:nn180100]<std::tuple<std::unique_ptr<std::__thread_struct>,GTUSCSamplingStreamingManagerHelper::StreamAPS(void)::$_0>>,  v8);
    if (v9) {
      break;
    }
    v53.sched_priority = sched_get_priority_max(2);
    pthread_setschedparam(v62[0], 2, &v53);
    std::thread::detach((std::thread *)v62);
    if (v3)
    {
      unint64_t v10 = (std::__thread_struct *)operator new(8uLL);
      std::__thread_struct::__thread_struct(v10);
      uint8x8_t v11 = operator new(0x18uLL);
      void *v11 = v10;
      v11[1] = &GTUSCSamplingStreamingManagerHelper::Instance(void)::instance;
      *((_DWORD *)v11 + 4) = v3;
      *((_DWORD *)v11 + 5) = v6;
      sched_param v64 = (sched_param)v11;
      int v9 = pthread_create( v50,  0LL,  (void *(__cdecl *)(void *))std::__thread_proxy[abi:nn180100]<std::tuple<std::unique_ptr<std::__thread_struct>,GTUSCSamplingStreamingManagerHelper::StreamAPS(void)::$_1>>,  v11);
      if (v9) {
        break;
      }
      std::thread::detach((std::thread *)v50);
      std::thread::~thread((std::thread *)v50);
    }

    else if (v6 == HIDWORD(qword_5B9960))
    {
      unint64_t v12 = (std::__thread_struct *)operator new(8uLL);
      std::__thread_struct::__thread_struct(v12);
      unint64_t v13 = operator new(0x10uLL);
      *unint64_t v13 = v12;
      v13[1] = &GTUSCSamplingStreamingManagerHelper::Instance(void)::instance;
      sched_param v64 = (sched_param)v13;
      int v9 = pthread_create( v50,  0LL,  (void *(__cdecl *)(void *))std::__thread_proxy[abi:nn180100]<std::tuple<std::unique_ptr<std::__thread_struct>,GTUSCSamplingStreamingManagerHelper::StreamAPS(void)::$_2>>,  v13);
      if (!v9)
      {
        v64.sched_priority = sched_get_priority_max(2);
        pthread_setschedparam(v50[0], 2, &v64);
        std::thread::detach((std::thread *)v50);
        std::thread::~thread((std::thread *)v50);
        std::thread::~thread((std::thread *)v62);
        goto LABEL_21;
      }

      break;
    }

    std::thread::~thread((std::thread *)v62);
    if (v4 == ++v6) {
      goto LABEL_21;
    }
  }

  std::__throw_system_error(v9, "thread constructor failed");
  __break(1u);
}

void sub_76F30( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, void *a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *a20, void *a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, char a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, uint64_t a41, uint64_t a42, uint64_t a43, uint64_t a44, uint64_t a45, uint64_t a46, char a47, uint64_t a48, uint64_t a49, uint64_t a50,uint64_t a51,uint64_t a52,std::thread a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,char a61,uint64_t a62,uint64_t a63)
{
  _Block_object_dispose(&a31, 8);
  _Block_object_dispose(&a47, 8);

  _Block_object_dispose(&a53, 8);
  _Block_object_dispose(&a61, 8);
  _Block_object_dispose(&a65, 8);
  _Block_object_dispose(&a69, 8);
  id v72 = (void *)STACK[0x210];
  if (STACK[0x210])
  {
    STACK[0x218] = (unint64_t)v72;
    operator delete(v72);
  }

  _Block_object_dispose(&STACK[0x228], 8);
  std::__hash_table<std::__hash_value_type<unsigned int,std::vector<GTCoalescedEncoderIndexInfo>>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,std::vector<GTCoalescedEncoderIndexInfo>>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,std::vector<GTCoalescedEncoderIndexInfo>>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,std::vector<GTCoalescedEncoderIndexInfo>>>>::~__hash_table(a12);
  _Block_object_dispose((const void *)(v70 - 192), 8);
  std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long>>>::~__hash_table(a13);

  _Unwind_Resume(a1);
}

uint64_t std::__thread_proxy[abi:nn180100]<std::tuple<std::unique_ptr<std::__thread_struct>,GTUSCSamplingStreamingManagerHelper::StreamAPS(void)::$_0>>( uint64_t a1)
{
  uint64_t v1 = a1;
  uint64_t v2 = std::__thread_local_data();
  uint64_t v3 = *(std::__thread_struct **)v1;
  *(void *)uint64_t v1 = 0LL;
  pthread_setspecific(v2->__key_, v3);
  uint64_t v4 = *(void *)(v1 + 8);
  unsigned int v5 = *(_DWORD *)(v1 + 16);
  uint64_t v6 = *(unsigned int *)(v1 + 20);
  if (v5)
  {
    GTUSCSamplingStreamingManagerHelper::PollAndDrainSourceRingBuffer( *(GTUSCSamplingStreamingManagerHelper **)(v1 + 8),  v5,  *(_DWORD *)(v1 + 20));
LABEL_45:
    std::unique_ptr<std::__thread_struct>::reset[abi:nn180100]((std::__thread_struct **)v1);
    operator delete((void *)v1);
    return 0LL;
  }

  uint64_t v7 = objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(v4 + 24), "objectAtIndexedSubscript:"));
  unint64_t v8 = (void *)v7;
  int v9 = (unsigned int *)(v4 + 2752);
  do
    unsigned int v10 = __ldaxr(v9);
  while (__stlxr(v10 + 1, v9));
  unsigned __int8 v11 = atomic_load((unsigned __int8 *)(v4 + 2763));
  if ((v11 & 1) == 0)
  {
    int v12 = v6 + 1;
    unint64_t v13 = (unsigned int *)(v4 + 2740);
    uint64_t v14 = (unsigned int *)(v4 + 2744);
    uint64_t v51 = (void *)v7;
    uint64_t v48 = v6;
    int v50 = v6 + 1;
    while (1)
    {
      unsigned __int8 v15 = atomic_load((unsigned __int8 *)(v4 + 2764));
      if ((v15 & 1) != 0) {
        goto LABEL_41;
      }
      uint64_t v16 = *(dispatch_semaphore_s **)(**(void **)(v4 + 2424) + 8 * v6);
      dispatch_time_t v17 = dispatch_time(0LL, 500000LL);
      uint64_t v49 = dispatch_semaphore_wait(v16, v17);
      unsigned __int8 v18 = atomic_load((unsigned __int8 *)(v4 + 2761));
      if ((v18 & 1) != 0)
      {
        int v19 = *(_DWORD *)(v4 + 3216);
        unint64_t v20 = (v19 * v6);
        uint64_t v21 = *(void *)(v4 + 3128);
        unsigned int v22 = v19 * v12;
        if (v20 < v22)
        {
          while (1)
          {
            if (objc_msgSend(v8, "isEnabled", v48))
            {
              uint64_t v23 = v21 + 32 * v20;
              unsigned int v25 = *(_DWORD *)(v23 + 28);
              uint64_t v24 = (unsigned int *)(v23 + 28);
              if ([v8 ringBufferInfoAtIndex:v25 base:&v56 size:&v55 dataOffset:&v54 dataSize:&v53])
              {
                unsigned int v26 = v53;
                if (v53 >> 13) {
                  break;
                }
                unsigned __int8 v27 = atomic_load((unsigned __int8 *)(v4 + 2760));
                if ((v27 & 1) != 0)
                {
                  unsigned int v26 = v53;
                  if (v53) {
                    break;
                  }
                }
              }
            }

LABEL_27:
            ++v20;
            uint64_t v21 = *(void *)(v4 + 3128);
            unint64_t v36 = (unint64_t)(*(void *)(v4 + 3136) - v21) >> 5;
            unsigned int v37 = *(_DWORD *)(v4 + 3216) * v12;
            else {
              unint64_t v36 = v37;
            }
            if (v20 >= v36) {
              goto LABEL_31;
            }
          }

          if (((*(void *)(*(void *)(v4 + 3192) + ((v20 >> 3) & 0x1FFFFFFFFFFFFFF8LL)) >> v20) & 1) != 0)
          {
            unsigned int v28 = v55;
            int v29 = v26 + v54;
            uint64_t v30 = (DynamicBuffer *)(*(void *)(v4 + 2376) + 48 * v20);
            id v31 = v56;
            uint64_t v32 = &v56[v54];
            if (v26 + v54 <= v55) {
              goto LABEL_22;
            }
            uint64_t v33 = *(void *)(v4 + 2376) + 48 * v20;
            DynamicBuffer::AddBuffer2(v30, v32, (const unsigned __int8 *)(v55 - v54));
            unsigned int v26 = v29 - v28;
            if (v29 != v28)
            {
              uint64_t v32 = v31;
              uint64_t v30 = (DynamicBuffer *)v33;
LABEL_22:
              DynamicBuffer::AddBuffer2(v30, v32, (const unsigned __int8 *)v26);
            }
          }

          unint64_t v8 = v51;
          int v12 = v50;
          if ([v51 drainRingBufferAtIndex:*v24 dataSize:v53] || !v53)
          {
            do
              unsigned int v34 = __ldaxr(v13);
            while (__stlxr(v34 + 1, v13));
            do
              unsigned int v35 = __ldaxr(v14);
            while (__stlxr(v35 + 1, v14));
          }

          goto LABEL_27;
        }

    *((void *)&xmmword_5B9568 + 1) = v25;
    goto LABEL_29;
  }

  if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(unk_5B9578 - *((void *)&xmmword_5B9568 + 1)) >> 3) >= v22)
  {
    bzero(*((void **)&xmmword_5B9568 + 1), 24 * ((24 * v22 - 24) / 0x18) + 24);
    unsigned int v25 = v20 + 24 * ((24 * v22 - 24) / 0x18) + 24;
    goto LABEL_27;
  }

  if (v19 > 0xAAAAAAAAAAAAAAALL) {
    abort();
  }
  int v42 = (__int128 *)&unk_5B9578;
  else {
    uint64_t v23 = v19;
  }
  unsigned __int8 v38 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<std::vector<NSObject  {objcproto21OS_dispatch_semaphore}* {__strong}>>>(v23);
  unsigned __int8 v39 = (uint64_t)&v38[24 * v21];
  uint64_t v41 = &v38[24 * v24];
  bzero((void *)v39, 24 * ((24 * v22 - 24) / 0x18) + 24);
  id v40 = (void (*)(uint64_t))(v39 + 24 * ((24 * v22 - 24) / 0x18) + 24);
  std::vector<std::vector<NSObject  {objcproto21OS_dispatch_semaphore}* {__strong}>>::__swap_out_circular_buffer( &xmmword_5B9568,  &v38);
  std::__split_buffer<std::vector<std::pair<unsigned int,unsigned int>>>::~__split_buffer((uint64_t)&v38);
  unsigned int v25 = *((void *)&xmmword_5B9568 + 1);
LABEL_29:
  std::vector<std::pair<unsigned int,unsigned int>>::reserve( &qword_5B9580,  0xAAAAAAAAAAAAAAABLL * ((v25 - (uint64_t)xmmword_5B9568) >> 3));
  unsigned __int8 v38 = (char *)_NSConcreteStackBlock;
  unsigned __int8 v39 = 3221225472LL;
  id v40 = ___ZN35GTUSCSamplingStreamingManagerHelper20InitBatchIdFilteringEP29GTUSCSamplingStreamingManager_block_invoke;
  uint64_t v41 = (char *)&__block_descriptor_40_e5_v8__0l;
  int v42 = &GTUSCSamplingStreamingManagerHelper::Instance(void)::instance;
  int v29 = (void *)objc_claimAutoreleasedReturnValue( +[NSBlockOperation blockOperationWithBlock:]( &OBJC_CLASS___NSBlockOperation,  "blockOperationWithBlock:",  &v38));
  [v29 setQueuePriority:-8];
  [**(id **)(GTUSCSamplingStreamingManagerHelper::Instance(void)::instance + 8) addOperation:v29];
  [v29 waitUntilFinished];
  uint64_t v30 = objc_claimAutoreleasedReturnValue(+[NSMutableArray arrayWithCapacity:](&OBJC_CLASS___NSMutableArray, "arrayWithCapacity:", 1LL));
  id v31 = (void *)qword_5B94D8;
  qword_5B94D8 = v30;

  uint64_t v32 = (void *)qword_5B94D8;
  uint64_t v33 = (void *)objc_claimAutoreleasedReturnValue( +[GPURawCounterSourceTriggerSelect selectWithName:options:]( &OBJC_CLASS___GPURawCounterSourceTriggerSelect,  "selectWithName:options:",  @"KickBoundary",  0LL));
  [v32 addObject:v33];

  GTUSCSamplingStreamingManagerHelper::StreamBatchIdFilteredCounters(v34, v35);
  (*(void (**)(void))(*(void *)(v1 + 80) + 16LL))();
  unint64_t v36 = atomic_load((unint64_t *)&xmmword_5B9770);
  if (v36 == v37) {
    GTUSCSamplingStreamingManagerHelper::CleanUp((GTUSCSamplingStreamingManagerHelper *)&GTUSCSamplingStreamingManagerHelper::Instance(void)::instance);
  }
}

    uint64_t v24 = a4->__r_.__value_.__s.__size_;
    if ((char)a4->__r_.__value_.__s.__size_ < 0)
    {
      if (a4->__r_.__value_.__l.__size_ != 1)
      {
LABEL_36:
        if ((v24 & 0x80u) == 0) {
          unsigned int v26 = a4->__r_.__value_.__s.__size_;
        }
        else {
          unsigned int v26 = a4->__r_.__value_.__l.__size_;
        }
        unsigned __int8 v27 = &v51;
        std::string::basic_string[abi:nn180100]((uint64_t)&v51, v26 + 1);
        if ((v51.__r_.__value_.__s.__size_ & 0x80u) != 0) {
          unsigned __int8 v27 = (std::string *)v51.__r_.__value_.__r.__words[0];
        }
        if (v26)
        {
          if ((a4->__r_.__value_.__s.__size_ & 0x80u) == 0) {
            unsigned int v28 = a4;
          }
          else {
            unsigned int v28 = (std::string *)a4->__r_.__value_.__r.__words[0];
          }
          memmove(v27, v28, v26);
        }

        *(_WORD *)((char *)&v27->__r_.__value_.__l.__data_ + v26) = 47;
        int v29 = (char)a3->__r_.__value_.__s.__size_;
        if (v29 >= 0) {
          uint64_t v30 = (const std::string::value_type *)a3;
        }
        else {
          uint64_t v30 = (const std::string::value_type *)a3->__r_.__value_.__r.__words[0];
        }
        if (v29 >= 0) {
          id v31 = a3->__r_.__value_.__s.__size_;
        }
        else {
          id v31 = a3->__r_.__value_.__l.__size_;
        }
        uint64_t v32 = std::string::append(&v51, v30, v31);
        uint64_t v33 = v32->__r_.__value_.__r.__words[0];
        v58.__r_.__value_.__r.__words[0] = v32->__r_.__value_.__l.__size_;
        *(std::string::size_type *)((char *)v58.__r_.__value_.__r.__words + 7) = *(std::string::size_type *)((char *)&v32->__r_.__value_.__r.__words[1] + 7);
        unsigned int v34 = v32->__r_.__value_.__s.__size_;
        v32->__r_.__value_.__l.__size_ = 0LL;
        v32->__r_.__value_.__l.__cap_ = 0LL;
        v32->__r_.__value_.__r.__words[0] = 0LL;
        __str.__r_.__value_.__r.__words[0] = v33;
        __str.__r_.__value_.__l.__size_ = v58.__r_.__value_.__r.__words[0];
        *(std::string::size_type *)((char *)&__str.__r_.__value_.__r.__words[1] + 7) = *(std::string::size_type *)((char *)v58.__r_.__value_.__r.__words + 7);
        __str.__r_.__value_.__s.__size_ = v34;
        goto LABEL_56;
      }

      unsigned int v25 = (std::string *)a4->__r_.__value_.__r.__words[0];
    }

    else
    {
      unsigned int v25 = a4;
      if (v24 != 1) {
        goto LABEL_36;
      }
    }

    if (v25->__r_.__value_.__s.__data_[0] == 47)
    {
      std::operator+[abi:nn180100]<char,std::char_traits<char>,std::allocator<char>>( (uint64_t)&v51,  (const void **)&a4->__r_.__value_.__l.__data_,  (const void **)&a3->__r_.__value_.__l.__data_);
      __str = v51;
      goto LABEL_56;
    }

    goto LABEL_36;
  }

  return v17;
}

  unsigned int v5 = 0LL;
  unsigned __int8 v11 = 0LL;
LABEL_28:
  if (a3) {
    goto LABEL_29;
  }
LABEL_30:
  *(void *)(a2 + 48) += 24LL;
  return v5;
}

LABEL_31:
        uint64_t v6 = v48;
        if (!v49) {
          break;
        }
        unsigned __int8 v38 = atomic_load((unsigned __int8 *)(v4 + 2760));
        if ((v38 & 1) != 0) {
          break;
        }
      }

      unsigned __int8 v39 = atomic_load((unsigned __int8 *)(v4 + 2763));
      if ((v39 & 1) != 0) {
        goto LABEL_41;
      }
    }

    id v40 = (unsigned int *)(v4 + 2748);
    uint64_t v41 = 3216LL;
    if (*(_DWORD *)(v4 + 3220) == (_DWORD)v48) {
      uint64_t v41 = 3224LL;
    }
    int v42 = *(_DWORD *)(v4 + v41);
    do
      unsigned int v43 = __ldaxr(v40);
    while (__stlxr(v43 + v42, v40));
    unsigned int v44 = atomic_load((unsigned int *)(v4 + 2748));
    if (v44 == *(_DWORD *)(v4 + 2164)) {
      std::condition_variable::notify_all((std::condition_variable *)(v4 + 2768));
    }
  }

  do
LABEL_41:
    unsigned int v45 = __ldaxr(v9);
  while (__stlxr(v45 - 1, v9));
  if (!atomic_load(v9)) {
    std::condition_variable::notify_all((std::condition_variable *)(v4 + 2992));
  }

  uint64_t v1 = a1;
  if (a1) {
    goto LABEL_45;
  }
  return 0LL;
}

      __int128 v87 = v19;
      unint64_t v36 = [v18 width];
      unsigned int v37 = [v18 height];
      if (v93)
      {
        GTMTLPixelFormatGetInfoForDevice((uint64_t)&v99, (uint64_t)v85, (uint64_t)v20);
        unsigned __int8 v38 = ((unint64_t)DWORD2(v99) >> 11) & 4;
        if ((~DWORD2(v99) & 0x60) == 0)
        {
          if (v22 == (int *)((char *)&dword_8 + 1))
          {
            v38 |= 2uLL;
          }

          else if (v22 == &dword_8)
          {
            v38 |= 1uLL;
          }
        }

        GTMTLGetTextureLevelInfoForDeviceWithOptions( (uint64_t)&v96,  (uint64_t)v85,  (uint64_t)v20,  (uint64_t)v36,  (uint64_t)v37,  1,  (uint64_t)[v18 sampleCount],  (uint64_t)v91,  v38);
        unint64_t v36 = v96;
        unsigned int v37 = v97;
        unsigned __int8 v39 = v98;
      }

      else
      {
        unsigned __int8 v39 = 1LL;
      }

      if (v78 >= v36) {
        id v40 = v36;
      }
      else {
        id v40 = v78;
      }
      uint64_t v41 = 5LL;
      if (!v30) {
        uint64_t v41 = 1LL;
      }
      if (v90) {
        int v42 = v41 | 0x10;
      }
      else {
        int v42 = v41;
      }
      -[MTLTextureDescriptor setPixelFormat:](v79, "setPixelFormat:", v20);
      -[MTLTextureDescriptor setWidth:](v79, "setWidth:", v40);
      -[MTLTextureDescriptor setHeight:](v79, "setHeight:", v37);
      -[MTLTextureDescriptor setUsage:](v79, "setUsage:", v42);
      uint64_t v95 = 0LL;
      uint64_t v33 = [v80 newTextureWithDescriptor:v79 error:&v95];
      unsigned int v43 = v95;
      if (v33)
      {
        int64_t v84 = v43;
        unsigned int v44 = (void *)objc_claimAutoreleasedReturnValue( [v87 objectForKeyedSubscript:@"DependencyGraphRequestedTextureDepthPlane"]);
        unsigned int v45 = [v44 unsignedIntegerValue];

        if (!v30)
        {
          uint64_t v51 = (void *)objc_claimAutoreleasedReturnValue([v76 blitCommandEncoder]);
          v94[0] = 0LL;
          v94[1] = 0LL;
          v94[2] = v45;
          unint64_t v96 = v40;
          unint64_t v97 = v37;
          BOOL v98 = v39;
          unint64_t v99 = v101;
          unint64_t v100 = 0LL;
          [v51 copyFromTexture:v18 sourceSlice:v89 sourceLevel:v91 sourceOrigin:v94 sourceSize:&v96 toTexture:v33 destinationSlice:0 destinationLevel:0  destinationOrigin:&v99];

          unint64_t v8 = v77;
          uint64_t v14 = v82;
          dispatch_time_t v17 = v83;
          int v19 = v87;
          id v31 = v92;
          goto LABEL_61;
        }

        GTMTLPixelFormatGetInfoForDevice((uint64_t)&v96, (uint64_t)v85, (uint64_t)v20);
        uint64_t v46 = (char)v97;
        id v47 = objc_alloc_init(&OBJC_CLASS___MTLRenderPassDescriptor);
        uint64_t v48 = v47;
        int v19 = v87;
        if ((v46 & 0x20) != 0)
        {
          int v50 = (void *)objc_claimAutoreleasedReturnValue(-[MTLRenderPassDescriptor depthAttachment](v47, "depthAttachment"));
          [v50 setTexture:v18];
          [v50 setLevel:v91];
          [v50 setSlice:v89];
          [v50 setDepthPlane:v45];
          [v50 setResolveTexture:v33];
          [v50 setLoadAction:1];
          [v50 setStoreAction:2];
          id v31 = v92;
          if ((v46 & 0x40) == 0)
          {
            uint64_t v14 = v82;
LABEL_58:
            unint64_t v8 = v77;
            unsigned int v53 = v81;
            if (!v81)
            {
              int v54 = (void *)objc_claimAutoreleasedReturnValue([v74 defaultCommandQueue]);
              unsigned int v55 = (void *)objc_claimAutoreleasedReturnValue([v54 commandBuffer]);

              id v56 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"%@.%@",  @"com.apple.gputools.replay",  @"ThumbnailsResolve"));
              [v55 setLabel:v56];

              unsigned int v53 = v55;
              id v31 = v92;
              int v19 = v87;
            }

            unint64_t v81 = v53;
            id v57 = (void *)objc_claimAutoreleasedReturnValue([v53 renderCommandEncoderWithDescriptor:v48]);
            [v57 endEncoding];

            dispatch_time_t v17 = v83;
LABEL_61:

            unsigned int v35 = 0LL;
            unsigned int v34 = 0LL;
            if (v90)
            {
LABEL_62:
              id v58 = v33;
              uint64_t v33 = objc_msgSend( v33,  "newTextureViewWithPixelFormat:textureType:levels:slices:",  v31,  2,  v35,  1,  v34,  1);

              if (!v33)
              {
                uint64_t v60 = v17;
                uint64_t v104 = @"GTErrorKeyMTLPixelFormat";
                uint64_t v61 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedInteger:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedInteger:",  v31));
                uint64_t v105 = v61;
                id v62 = &v105;
                int v63 = &v104;
LABEL_79:
                unsigned __int8 v18 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v62,  v63,  1LL));

                GTMTLReplay_fillError(v73, 101, v18);
                if (v73) {
                  uint64_t v69 = *v73;
                }
                else {
                  uint64_t v69 = 0LL;
                }
                unsigned int v10 = v74;
                unsigned __int8 v11 = v76;
                uint64_t v70 = v88;
                GTMTLReplay_handleNSError(v69);
                goto LABEL_88;
              }

  IOSurfaceUnlock(v11, 0, 0LL);
  apr_pool_clear(v5);
}

      unint64_t v13 = 0LL;
      GTMTLReplay_handleNSError(v42);
      goto LABEL_32;
    }

  unsigned int v34 = v11->nelts;
  if (v34 >= 1)
  {
    unsigned int v35 = 0LL;
    unint64_t v36 = &CATransform3DIdentity_ptr;
    do
    {
      unsigned int v37 = *(void *)&v11->elts[8 * v35];
      if (!v37) {
        goto LABEL_61;
      }
      unsigned __int8 v38 = *(void *)(v37 + 16);
      unsigned __int8 v39 = *(void *)(v9 + 64);
      id v40 = v39 <= v38 && *(void *)(v9 + 72) + v39 > v38;
      if (v40 || (a3 & 8) == 0 && *(void *)(v37 + 120)) {
        goto LABEL_61;
      }
      if (*(void *)(v37 + 128))
      {
        HIDWORD(v42) = *(unsigned __int8 *)(v37 + 160);
        LODWORD(v42) = (HIDWORD(v42) << 24) - 0x2000000;
        uint64_t v41 = v42 >> 25;
        unsigned int v43 = v41 > 7u ? 1 : dword_316FF8[v41];
        if ((v43 & a3) == 0) {
          goto LABEL_61;
        }
      }

      std::unordered_map<unsigned long long,objc_object  {objcproto23MTLVisibleFunctionTable}* {__strong}>::unordered_map( (uint64_t)v66,  v60);
      id v62 = *(id *)(a2 + 8);
      GetIntersectionFunctionTableState(v68, v9, v37, v64, a5, pa);
      unsigned int v44 = objc_alloc_init((Class)v36[236]);
      [v44 setFunctionCount:*(unsigned int *)(*(void *)(v37 + 104) + 8)];
      [v44 setResourceIndex:**(void **)(v37 + 104)];
      [v44 setForceResourceIndex:1];
      unsigned int v45 = *(void *)(v37 + 128);
      if (v45)
      {
        uint64_t v46 = *(unsigned __int8 *)(v37 + 160);
        id v47 = GTMTLSMContext_getObject(**(void **)(v9 + 40), v45, v64);
        if (!v47) {
          goto LABEL_57;
        }
        uint64_t v48 = (void *)objc_claimAutoreleasedReturnValue([v62 renderPipelineStateForKey:v47[1]]);
        uint64_t v49 = v48;
        if (!v48) {
          goto LABEL_57;
        }
        int v50 = [v48 newIntersectionFunctionTableWithDescriptor:v44 stage:v46];
        if (v50)
        {
          uint64_t v51 = *(uint64_t **)(v9 + 40);
          std::unordered_map<unsigned long long,objc_object  {objcproto23MTLVisibleFunctionTable}* {__strong}>::unordered_map( (uint64_t)v67,  (uint64_t)v66);
          SetupRegularIntersectionFunctionTable(v50, v62, v51, v67, v68, *(void *)(v37 + 128), v64);
LABEL_55:
          std::__hash_table<std::__hash_value_type<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>,std::__unordered_map_hasher<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::equal_to,std::hash,true>,std::allocator<objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>>::~__hash_table((uint64_t)v67);
        }
      }

      else
      {
        unint64_t v52 = *(void *)(v37 + 120);
        if (!v52
          || (unsigned int v53 = GTMTLSMContext_getObject(**(void **)(v9 + 40), v52, v64)) == 0LL
          || (int v54 = (void *)objc_claimAutoreleasedReturnValue([v62 computePipelineStateForKey:v53[1]]),
              (uint64_t v49 = v54) == 0LL))
        {
LABEL_57:
          int v50 = 0LL;
          goto LABEL_58;
        }

        unsigned int v55 = v36;
        int v50 = [v54 newIntersectionFunctionTableWithDescriptor:v44];
        if (v50)
        {
          id v56 = *(uint64_t **)(v9 + 40);
          std::unordered_map<unsigned long long,objc_object  {objcproto23MTLVisibleFunctionTable}* {__strong}>::unordered_map( (uint64_t)v67,  (uint64_t)v66);
          SetupRegularIntersectionFunctionTable(v50, v62, v56, v67, v68, *(void *)(v37 + 120), v64);
          unint64_t v36 = v55;
          goto LABEL_55;
        }
      }

LABEL_58:
      std::__hash_table<std::__hash_value_type<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>,std::__unordered_map_hasher<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::equal_to,std::hash,true>,std::allocator<objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>>::~__hash_table((uint64_t)v66);
      if (v50)
      {
        v68[0] = *(void *)(v37 + 8);
        id v57 = (id *)std::__hash_table<std::__hash_value_type<unsigned long long,objc_object  {objcproto28MTLIntersectionFunctionTable}* {__strong}>,std::__unordered_map_hasher<unsigned long long,objc_object  {objcproto28MTLIntersectionFunctionTable}* {__strong},std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,objc_object  {objcproto28MTLIntersectionFunctionTable}* {__strong},std::equal_to,std::hash,true>,std::allocator<objc_object  {objcproto28MTLIntersectionFunctionTable}* {__strong}>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long &&>,std::piecewise_construct_t const&<>>( v58,  v68[0],  v68);
        objc_storeStrong(v57 + 3, v50);
        [*(id *)(a2 + 8) setIntersectionFunctionTable:v50 forKey:*(void *)(v37 + 8)];
      }

      unsigned int v34 = v11->nelts;
LABEL_61:
      ++v35;
    }

    while (v35 < v34);
  }

          int v9 = v63;
          goto LABEL_32;
        }

        unsigned int v10 = v11;
        if (v20 == 70)
        {
          uint64_t v21 = objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLongLong:](&OBJC_CLASS___NSNumber, "numberWithUnsignedLongLong:", *v11));
          int v63 = v9 + 1;
          unsigned int v22 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInt:](&OBJC_CLASS___NSNumber, "numberWithUnsignedInt:", v9));
          v70[0] = v22;
          v70[1] = v21;
          uint64_t v23 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", v70, 2LL));
          [v61 addObject:v23];

          uint64_t v7 = v62;
          sched_param v64 = (void *)v21;
          if (([v62 containsObject:v21] & 1) == 0)
          {
            [v62 addObject:v21];
            uint64_t v24 = GTMTLSMContext_getObject(**(void **)(v3 + 40), *v11, *(void *)v12)[7];
            unsigned int v25 = (uint64_t *)(v24 + 112);
            unsigned int v26 = (uint64_t *)(v24 + 120);
            unsigned __int8 v27 = v11;
            goto LABEL_26;
          }

          goto LABEL_31;
        }
      }

      else
      {
        unsigned int v10 = v11;
      }

        unsigned int v26 = 0LL;
        goto LABEL_32;
      }

void sub_773EC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, void *a5, ...)
{
  std::unique_ptr<std::tuple<std::unique_ptr<std::__thread_struct>,GTUSCSamplingStreamingManagerHelper::StartBackgroundProcessingThreads(void)::$_0>>::~unique_ptr[abi:nn180100]((std::__thread_struct ***)va);
  _Unwind_Resume(a1);
}

uint64_t std::__thread_proxy[abi:nn180100]<std::tuple<std::unique_ptr<std::__thread_struct>,GTUSCSamplingStreamingManagerHelper::StreamAPS(void)::$_1>>( uint64_t a1)
{
  uint64_t v2 = std::__thread_local_data();
  uint64_t v3 = *(std::__thread_struct **)a1;
  *(void *)a1 = 0LL;
  pthread_setspecific(v2->__key_, v3);
  GTUSCSamplingStreamingManagerHelper::PostProcessRawData( *(GTUSCSamplingStreamingManagerHelper **)(a1 + 8),  *(_DWORD *)(a1 + 16),  *(_DWORD *)(a1 + 20));
  std::unique_ptr<std::__thread_struct>::reset[abi:nn180100]((std::__thread_struct **)a1);
  operator delete((void *)a1);
  return 0LL;
}

void sub_77478(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

uint64_t std::__thread_proxy[abi:nn180100]<std::tuple<std::unique_ptr<std::__thread_struct>,GTUSCSamplingStreamingManagerHelper::StreamAPS(void)::$_2>>( uint64_t a1)
{
  uint64_t v2 = std::__thread_local_data();
  uint64_t v3 = *(std::__thread_struct **)a1;
  *(void *)a1 = 0LL;
  pthread_setspecific(v2->__key_, v3);
  uint64_t v4 = *(void *)(a1 + 8);
  do
  {
    unsigned __int8 v5 = atomic_load((unsigned __int8 *)(v4 + 2763));
    if ((v5 & 1) != 0) {
      break;
    }
    unsigned __int8 v6 = atomic_load((unsigned __int8 *)(v4 + 2764));
    if ((v6 & 1) != 0) {
      break;
    }
    uint64_t v7 = *(dispatch_semaphore_s **)(v4 + 2504);
    dispatch_time_t v8 = dispatch_time(0LL, 250000LL);
    uint64_t v24 = dispatch_semaphore_wait(v7, v8);
    uint64_t v9 = *(void *)(v4 + 3136);
    uint64_t v10 = *(void *)(v4 + 3128);
    if (v9 != v10)
    {
      unint64_t v11 = 0LL;
      do
      {
        uint64_t v12 = v10 + 32 * v11;
        unint64_t v13 = *(FILE **)(v12 + 8);
        if (v13)
        {
          unsigned int v14 = *(_DWORD *)(v12 + 28);
          uint64_t v15 = *(void *)(v4 + 2376);
          uint64_t v16 = v15 + 48LL * v14;
          os_unfair_lock_lock((os_unfair_lock_t)(v16 + 16));
          if (v24) {
            unint64_t v17 = *(void *)(v16 + 8);
          }
          else {
            unint64_t v17 = 0xAAAAAAAAAAAAAAABLL
          }
                * ((uint64_t)(*(void *)(v15 + 48LL * v14 + 32) - *(void *)(v15 + 48LL * v14 + 24)) >> 3);
          os_unfair_lock_unlock((os_unfair_lock_t)(v16 + 16));
          unint64_t v18 = *(void *)v16;
          if (v17 > *(void *)v16 && (_DWORD)v17 - *(void *)v16 != 0LL)
          {
            unint64_t v20 = (void *)(v15 + 48LL * v14 + 24);
            do
            {
              uint64_t v21 = *v20 + 24 * v18;
              int v22 = fileno(v13);
              write(v22, *(const void **)v21, *(void *)(v21 + 8));
              unint64_t v18 = *(void *)v16 + 1LL;
              *(void *)uint64_t v16 = v18;
              if (*(void *)v21)
              {
                free(*(void **)v21);
                *(void *)uint64_t v21 = 0LL;
                *(void *)(v21 + _Block_object_dispose(&STACK[0x3B0], 8) = 0LL;
                *(void *)(v21 + 16) = 0LL;
                unint64_t v18 = *(void *)v16;
              }
            }

            while (v18 < v17);
            if (!v24)
            {
              *(void *)(v15 + 48LL * v14 + 32) = *v20;
              *(void *)uint64_t v16 = 0LL;
              *(void *)(v16 + _Block_object_dispose(&STACK[0x3B0], 8) = 0LL;
            }
          }

          uint64_t v9 = *(void *)(v4 + 3136);
          uint64_t v10 = *(void *)(v4 + 3128);
        }

        ++v11;
      }

      while (v11 < (v9 - v10) >> 5);
    }
  }

  while (v24);
  dispatch_semaphore_signal(*(dispatch_semaphore_t *)(v4 + 2512));
  if (a1)
  {
    std::unique_ptr<std::__thread_struct>::reset[abi:nn180100]((std::__thread_struct **)a1);
    operator delete((void *)a1);
  }

  return 0LL;
}

void sub_77664(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

__n128 __Block_byref_object_copy__454(__n128 *a1, __n128 *a2)
{
  __n128 result = a2[3];
  a1[3] = result;
  return result;
}

void ___ZN35GTUSCSamplingStreamingManagerHelper9StreamAPSEv_block_invoke(void *a1)
{
  unsigned __int8 v1 = atomic_load((unsigned __int8 *)(a1[11] + 2764LL));
  if ((v1 & 1) == 0)
  {
    uint64_t v94 = a1[11];
    unint64_t v99 = (void *)objc_claimAutoreleasedReturnValue( +[NSMutableDictionary dictionaryWithCapacity:]( &OBJC_CLASS___NSMutableDictionary,  "dictionaryWithCapacity:",  *(void *)(*(void *)(a1[5] + 8LL) + 72LL)));
    BOOL v98 = (void *)objc_claimAutoreleasedReturnValue( +[NSMutableDictionary dictionaryWithCapacity:]( &OBJC_CLASS___NSMutableDictionary,  "dictionaryWithCapacity:",  *(void *)(*(void *)(a1[5] + 8LL) + 72LL)));
    unint64_t v96 = (void *)objc_claimAutoreleasedReturnValue( +[NSMutableDictionary dictionaryWithCapacity:]( &OBJC_CLASS___NSMutableDictionary,  "dictionaryWithCapacity:",  *(void *)(*(void *)(a1[5] + 8LL) + 72LL)));
    uint64_t v3 = *(void *)(a1[6] + 8LL);
    unint64_t v4 = *(void *)(v3 + 48);
    unsigned __int8 v5 = *(unint64_t **)(v3 + 56);
    unint64_t v6 = 126 - 2 * __clz((uint64_t)((uint64_t)v5 - v4) >> 4);
    else {
      uint64_t v7 = v6;
    }
    std::__introsort<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned long long,unsigned long long> *,false>( v4,  v5,  v7,  1);
    uint64_t v95 = (void *)objc_claimAutoreleasedReturnValue( +[NSMutableArray arrayWithCapacity:]( &OBJC_CLASS___NSMutableArray,  "arrayWithCapacity:",  (uint64_t)(*(void *)(*(void *)(a1[6] + 8LL) + 56LL)
                              - *(void *)(*(void *)(a1[6] + 8LL) + 48LL)) >> 4));
    __int128 v92 = (void *)objc_claimAutoreleasedReturnValue( +[NSMutableData dataWithCapacity:]( &OBJC_CLASS___NSMutableData,  "dataWithCapacity:",  *(void *)(*(void *)(a1[6] + 8LL) + 56LL) - *(void *)(*(void *)(a1[6] + 8LL) + 48LL)));
    [v92 appendBytes:*(void *)(*(void *)(a1[6] + 8) + 48) length:*(void *)(*(void *)(a1[6] + 8) + 56) - *(void *)(*(void *)(a1[6] + 8) + 48)];
    uint64_t v8 = *(void *)(a1[6] + 8LL);
    unint64_t v9 = *(void *)(v8 + 48);
    uint64_t v10 = *(unint64_t **)(v8 + 56);
    unint64_t v11 = 126 - 2 * __clz((uint64_t)((uint64_t)v10 - v9) >> 4);
    else {
      uint64_t v12 = v11;
    }
    std::__introsort<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned long long,unsigned long long> *,false>( v9,  v10,  v12,  1);
    uint64_t v13 = *(void *)(a1[6] + 8LL);
    uint64_t v14 = *(void *)(v13 + 48);
    uint64_t v15 = *(void *)(v13 + 56);
    if (v14 == v15) {
      unint64_t v16 = 0LL;
    }
    else {
      unint64_t v16 = *(void *)(v14 + 8);
    }
    if ((unint64_t)(v15 - v14) >= 0x11)
    {
      uint64_t v17 = 0LL;
      unint64_t v18 = 1LL;
      do
      {
        if (v16 < *(void *)(v14 + v17 + 16))
        {
          int v19 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  v16));
          v111[0] = v19;
          unint64_t v20 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  *(void *)(*(void *)(*(void *)(a1[6] + 8LL) + 48LL) + v17 + 16) - 1LL));
          v111[1] = v20;
          uint64_t v21 = (void *)objc_claimAutoreleasedReturnValue( +[NSArray arrayWithObjects:count:]( &OBJC_CLASS___NSArray,  "arrayWithObjects:count:",  v111,  2LL));
          [v95 addObject:v21];

          uint64_t v13 = *(void *)(a1[6] + 8LL);
          uint64_t v14 = *(void *)(v13 + 48);
        }

        if (v16 <= *(void *)(v14 + v17 + 24)) {
          unint64_t v16 = *(void *)(v14 + v17 + 24);
        }
        ++v18;
        v17 += 16LL;
      }

      while (v18 < (*(void *)(v13 + 56) - v14) >> 4);
    }

    for (uint64_t i = *(uint64_t **)(*(void *)(a1[5] + 8LL) + 64LL); i; uint64_t i = (uint64_t *)*i)
    {
      uint64_t v23 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedInt:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedInt:",  *((unsigned int *)i + 6)));
      uint64_t v24 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedInt:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedInt:",  *((unsigned int *)i + 4)));
      [v99 setObject:v23 forKeyedSubscript:v24];

      unsigned int v25 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedInt:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedInt:",  *((unsigned int *)i + 7)));
      v110[0] = v25;
      unsigned int v26 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedInt:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedInt:",  *((unsigned int *)i + 8)));
      v110[1] = v26;
      unsigned __int8 v27 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedInt:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedInt:",  *((unsigned int *)i + 9)));
      v110[2] = v27;
      unsigned int v28 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  i[5]));
      v110[3] = v28;
      int v29 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", v110, 4LL));
      uint64_t v30 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedInt:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedInt:",  *((unsigned int *)i + 4)));
      [v98 setObject:v29 forKeyedSubscript:v30];

      if (*((_DWORD *)i + 12))
      {
        id v31 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInt:](&OBJC_CLASS___NSNumber, "numberWithUnsignedInt:"));
        v109[0] = v31;
        uint64_t v32 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedInt:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedInt:",  *((unsigned int *)i + 13)));
        v109[1] = v32;
        uint64_t v33 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", v109, 2LL));
        unsigned int v34 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedInt:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedInt:",  *((unsigned int *)i + 4)));
        [v96 setObject:v33 forKeyedSubscript:v34];
      }
    }

    unint64_t v97 = (void *)objc_claimAutoreleasedReturnValue( +[NSMutableDictionary dictionaryWithCapacity:]( &OBJC_CLASS___NSMutableDictionary,  "dictionaryWithCapacity:",  *(void *)(*(void *)(a1[7] + 8LL) + 72LL)));
    for (int j = *(uint64_t ***)(*(void *)(a1[7] + 8LL) + 64LL); j; int j = (uint64_t **)*j)
    {
      unint64_t v36 = (void *)objc_claimAutoreleasedReturnValue( +[NSMutableArray arrayWithCapacity:]( &OBJC_CLASS___NSMutableArray,  "arrayWithCapacity:",  ((char *)j[4] - (char *)j[3]) >> 4));
      unsigned __int8 v38 = (unsigned int *)j[3];
      unsigned int v37 = (unsigned int *)j[4];
      while (v38 != v37)
      {
        unsigned __int8 v39 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInt:](&OBJC_CLASS___NSNumber, "numberWithUnsignedInt:", *v38));
        v108[0] = v39;
        id v40 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  *((void *)v38 + 1)));
        v108[1] = v40;
        uint64_t v41 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", v108, 2LL));
        [v36 addObject:v41];

        v38 += 4;
      }

      int v42 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedInt:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedInt:",  *((unsigned int *)j + 4)));
      [v97 setObject:v36 forKeyedSubscript:v42];
    }

    id v104 = 0LL;
    __int128 v89 = (void *)objc_claimAutoreleasedReturnValue( +[NSKeyedArchiver archivedDataWithRootObject:requiringSecureCoding:error:]( &OBJC_CLASS___NSKeyedArchiver,  "archivedDataWithRootObject:requiringSecureCoding:error:",  v99,  1LL,  &v104));
    id v43 = v104;
    id v103 = v43;
    __int128 v87 = (void *)objc_claimAutoreleasedReturnValue( +[NSKeyedArchiver archivedDataWithRootObject:requiringSecureCoding:error:]( &OBJC_CLASS___NSKeyedArchiver,  "archivedDataWithRootObject:requiringSecureCoding:error:",  v98,  1LL,  &v103));
    id v44 = v103;

    id v102 = v44;
    __int128 v86 = (void *)objc_claimAutoreleasedReturnValue( +[NSKeyedArchiver archivedDataWithRootObject:requiringSecureCoding:error:]( &OBJC_CLASS___NSKeyedArchiver,  "archivedDataWithRootObject:requiringSecureCoding:error:",  v96,  1LL,  &v102));
    id v45 = v102;

    id v101 = v45;
    __int128 v88 = (void *)objc_claimAutoreleasedReturnValue( +[NSKeyedArchiver archivedDataWithRootObject:requiringSecureCoding:error:]( &OBJC_CLASS___NSKeyedArchiver,  "archivedDataWithRootObject:requiringSecureCoding:error:",  v97,  1LL,  &v101));
    id v84 = v101;

    uint64_t v46 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v94 + 1944) mappings]);
    if (v46) {
      __int128 v90 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v94 + 1944) mappings]);
    }
    else {
      __int128 v90 = &__NSArray0__struct;
    }

    uint64_t v47 = objc_claimAutoreleasedReturnValue([*(id *)(v94 + 1944) binaries]);
    uint64_t v49 = &__NSDictionary0__struct;
    if (v47) {
      uint64_t v49 = (void *)v47;
    }
    __int128 v91 = v49;
    int v50 = *(_DWORD *)(v94 + 2188);
    if (v50) {
      uint64_t v51 = v50 != 1;
    }
    else {
      uint64_t v51 = *(_BYTE *)(v94 + 3184) & 1;
    }
    uint64_t v93 = (void *)objc_opt_new(&OBJC_CLASS___NSMutableDictionary, v48);
    [v93 setObject:&off_5A0AC0 forKeyedSubscript:@"version"];
    unint64_t v52 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithDouble:](&OBJC_CLASS___NSNumber, "numberWithDouble:", *(double *)(v94 + 3160)));
    [v93 setObject:v52 forKeyedSubscript:@"fractionOfCores"];

    unsigned int v53 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithDouble:](&OBJC_CLASS___NSNumber, "numberWithDouble:", *(double *)(v94 + 3168)));
    [v93 setObject:v53 forKeyedSubscript:@"thresholdInSeconds"];

    int v54 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  (*(void *)(v94 + 3184) >> 1) & 1LL));
    [v93 setObject:v54 forKeyedSubscript:@"usingMinimumTracingMode"];

    unsigned int v55 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  *(void *)(v94 + 3176)));
    [v93 setObject:v55 forKeyedSubscript:@"drawCountThreshold"];

    id v56 = (void *)objc_claimAutoreleasedReturnValue( +[NSMutableArray arrayWithCapacity:]( &OBJC_CLASS___NSMutableArray,  "arrayWithCapacity:",  *(void *)(v94 + 3200)));
    id v57 = *(void **)(v94 + 3192);
    unint64_t v58 = *(void *)(v94 + 3200);
    int v59 = v58 & 0x3F;
    if (v58 > 0x3F || (v58 & 0x3F) != 0)
    {
      int v60 = 0;
      int v61 = 0;
      id v62 = &v57[v58 >> 6];
      do
      {
        int v63 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithBool:](&OBJC_CLASS___NSNumber, "numberWithBool:", (*v57 >> v61) & 1LL));
        [v56 addObject:v63];

        v57 += v60 == 63;
        if (v60 == 63) {
          int v61 = 0;
        }
        else {
          ++v61;
        }
        int v60 = v61;
      }

      while (v57 != v62 || v59 != v61);
    }

    id v64 = [v56 copy];
    [v93 setObject:v64 forKeyedSubscript:@"usedCoreMasks"];

    mach_timebase_info info = 0LL;
    mach_timebase_info(&info);
    unint64_t v65 = *(void **)(v94 + 2088);
    if (!v65) {
      unint64_t v65 = &__NSDictionary0__struct;
    }
    id v85 = v65;
    v106[0] = @"Program Address Mappings";
    v106[1] = @"TraceId to BatchId";
    v107[0] = v90;
    v107[1] = v89;
    v106[2] = @"Source Sample Marker";
    uint64_t v66 = objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  *(void *)(v94 + 32)));
    uint64_t v67 = a1[4];
    v107[2] = v66;
    v107[3] = v67;
    v106[3] = @"Frame Encoder Time Data";
    v106[4] = @"TraceId to SampleIndex";
    v107[4] = v87;
    v107[5] = v86;
    v106[5] = @"TraceId to Tile Info";
    v106[6] = @"Frame Consistent Perf Info";
    v107[6] = *(void *)(*(void *)(a1[8] + 8LL) + 40LL);
    v107[7] = v95;
    v106[7] = @"Restore Timestamps";
    v106[8] = @"Command Buffer Timestamps";
    v107[8] = v92;
    v107[9] = v88;
    v106[9] = @"TraceId to Coalesced BatchId";
    v106[10] = @"Configuration Variables";
    v107[10] = *(void *)(v94 + 1984);
    v106[11] = @"useOverlap";
    unint64_t v81 = (void *)v66;
    uint64_t v83 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithBool:](&OBJC_CLASS___NSNumber, "numberWithBool:", v51));
    v107[11] = v83;
    v107[12] = v91;
    v106[12] = @"Binaries";
    v106[13] = @"Streaming Counters";
    BOOL v80 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithBool:](&OBJC_CLASS___NSNumber, "numberWithBool:", *(_DWORD *)(v94 + 2188) == 1));
    v107[13] = v80;
    v106[14] = @"Kick State Trigger Options";
    unint64_t v82 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v94 + 2072) firstObject]);
    uint64_t v68 = (void *)objc_claimAutoreleasedReturnValue([v82 options]);
    if (v68)
    {
      unint64_t v78 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v94 + 2072) firstObject]);
      uint64_t v69 = (void *)objc_claimAutoreleasedReturnValue([v78 options]);
    }

    else
    {
      uint64_t v69 = &__NSDictionary0__struct;
    }

    uint64_t v70 = *(void **)(v94 + 2064);
    if (!v70) {
      uint64_t v70 = &__NSDictionary0__struct;
    }
    BOOL v79 = v69;
    v107[14] = v69;
    v107[15] = v70;
    v106[15] = @"APS Options";
    v106[16] = @"Continuous Time";
    int v71 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  *(void *)(*(void *)(a1[9] + 8LL) + 24LL)));
    v107[16] = v71;
    v106[17] = @"Absolute Time";
    id v72 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  *(void *)(*(void *)(a1[10] + 8LL) + 24LL)));
    v107[17] = v72;
    v106[18] = @"Timebase";
    id v73 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInt:](&OBJC_CLASS___NSNumber, "numberWithUnsignedInt:", info.numer));
    v105[0] = v73;
    id v74 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInt:](&OBJC_CLASS___NSNumber, "numberWithUnsignedInt:", info.denom));
    v105[1] = v74;
    id v75 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", v105, 2LL));
    v107[18] = v75;
    v107[19] = v93;
    v106[19] = @"apsProfilingConfig";
    v106[20] = @"Perf Info";
    v107[20] = v85;
    v106[21] = @"ReplayerGPUTime";
    unint64_t v76 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithDouble:](&OBJC_CLASS___NSNumber, "numberWithDouble:", *(double *)(v94 + 3152)));
    v107[21] = v76;
    id v77 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v107,  v106,  22LL));

    if (v68)
    {
    }

    (*(void (**)(void))(*(void *)(*(void *)v94 + 32LL) + 16LL))();
  }

void sub_78280( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, uint64_t a11, void *a12, void *a13, void *a14, void *a15, void *a16, void *a17, void *a18, void *a19, void *a20, void *a21, void *a22, void *a23, void *a24, void *a25, uint64_t a26, void *a27, void *a28, void *a29, void *a30, void *a31)
{
  _Unwind_Resume(a1);
}

void ___ZN35GTUSCSamplingStreamingManagerHelper9StreamAPSEv_block_invoke_2(uint64_t a1)
{
  unsigned __int8 v1 = *(GTMTLReplayController ****)(a1 + 112);
  unsigned __int8 v2 = atomic_load((unsigned __int8 *)v1 + 2763);
  if ((v2 & 1) == 0)
  {
    unsigned __int8 v3 = atomic_load((unsigned __int8 *)v1 + 2764);
    if ((v3 & 1) == 0)
    {
      atomic_store(0, (unsigned __int8 *)v1 + 2760);
      if (*((_DWORD *)v1 + 544) != -1)
      {
        id v118 = (void *)objc_claimAutoreleasedReturnValue([v1[2] firstObject]);
        int v4 = *((_DWORD *)v1 + 547);
        BOOL v5 = v4 == 1 || (v4 | (_BYTE)v1[398] & 1) == 0;
        if (GTAGXPerfStateControl::IsGPUPerformanceStateInduced((GTAGXPerfStateControl *)(v1 + 5)))
        {
          unint64_t v126 = @"DisableOverlap";
          unint64_t v6 = (GTMTLReplayController *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithBool:](&OBJC_CLASS___NSNumber, "numberWithBool:", v5));
          id v131 = v6;
          uint64_t v7 = (GTMTLReplayController *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v131,  &v126,  1LL));
          uint64_t v8 = (void *)objc_claimAutoreleasedReturnValue([v1[2] firstObject]);
          [v8 setOptions:v7];
        }

        else
        {
          uint64_t v9 = *((unsigned int *)*v1 + 18);
          if ((_DWORD)v9)
          {
            GTAGXPerfStateControl::EnableConsistentGPUPerfState((uint64_t)(v1 + 5), v9);
            id v10 = GTApplePMPPerfStateControl::EnableConsistentPerfState( (GTApplePMPPerfStateControl *)(v1 + 8),  (*((_DWORD *)*v1 + 18) - 1));
            uint64_t v11 = objc_claimAutoreleasedReturnValue(v10);
            uint64_t v12 = v1[261];
            v1[261] = (GTMTLReplayController **)v11;

            unint64_t v126 = @"DisableOverlap";
            unint64_t v6 = (GTMTLReplayController *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithBool:](&OBJC_CLASS___NSNumber, "numberWithBool:", v5));
            id v131 = v6;
            uint64_t v7 = (GTMTLReplayController *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v131,  &v126,  1LL));
            uint64_t v8 = (void *)objc_claimAutoreleasedReturnValue([v1[2] firstObject]);
            [v8 setOptions:v7];
          }

          else
          {
            id v13 = GTApplePMPPerfStateControl::EnableConsistentPerfState((GTApplePMPPerfStateControl *)(v1 + 8), 1LL);
            uint64_t v14 = objc_claimAutoreleasedReturnValue(v13);
            uint64_t v15 = v1[261];
            v1[261] = (GTMTLReplayController **)v14;

            unint64_t v126 = @"DisableOverlap";
            unint64_t v6 = (GTMTLReplayController *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithBool:](&OBJC_CLASS___NSNumber, "numberWithBool:", v5));
            id v131 = v6;
            uint64_t v127 = @"LockGPUPerfState";
            uint64_t v7 = (GTMTLReplayController *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedInt:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedInt:",  *((unsigned int *)*v1 + 17)));
            uint64_t v132 = v7;
            uint64_t v8 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v131,  &v126,  2LL));
            unint64_t v16 = (void *)objc_claimAutoreleasedReturnValue([v1[2] firstObject]);
            [v16 setOptions:v8];
          }
        }

        uint64_t v17 = (void *)objc_claimAutoreleasedReturnValue([v1[3] objectAtIndexedSubscript:*((int *)v1 + 544)]);
        [v17 setOptions:v1[258]];
        [v17 requestTriggers:v1[259] firstErrorIndex:0];
        __lk.__m_ = 0LL;
        unint64_t v18 = (void *)objc_claimAutoreleasedReturnValue([v1[251] objectAtIndexedSubscript:*((int *)v1 + 544)]);
        unsigned __int8 v19 = [v17 requestCounters:v18 firstErrorIndex:&__lk];

        if ((v19 & 1) != 0)
        {
          unsigned int v20 = [v17 setEnabled:1];

          if (v20)
          {
            double v21 = *((double *)v1 + 394) + *((double *)v1 + 394);
            if (v21 <= 1.0) {
              double v22 = 10240.0;
            }
            else {
              double v22 = v21 * 10240.0;
            }
            id v23 = [v1[3] count];
            if (v23)
            {
              uint64_t v24 = 0LL;
              unsigned int v25 = 1;
              do
              {
                unsigned int v26 = (void *)objc_claimAutoreleasedReturnValue([v1[251] objectAtIndexedSubscript:v24]);
                [v26 count];

                uint64_t v24 = v25;
              }

              while ((unint64_t)v23 > v25++);
            }

            for (unsigned int i = 0; ; unsigned int i = v29 + 1)
            {
              uint64_t v29 = i;
              uint64_t v30 = (void *)objc_claimAutoreleasedReturnValue([v1[251] objectAtIndexedSubscript:i]);
              if ([v30 count])
              {
                BOOL v31 = i == *((_DWORD *)v1 + 544);

                if (!v31)
                {
                  uint64_t v17 = (void *)objc_claimAutoreleasedReturnValue([v1[3] objectAtIndexedSubscript:v29]);
                  id v125 = @"RingBufferSizeInKB";
                  uint64_t v32 = (std::unique_lock<std::mutex>::mutex_type *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLong:",  (unint64_t)v22));
                  __lk.__m_ = v32;
                  uint64_t v33 = objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &__lk,  &v125,  1LL));
                  [v17 setOptions:v33];

                  [v17 requestTriggers:v1[256] firstErrorIndex:0];
                  BOOL v124 = 0LL;
                  unsigned int v34 = (void *)objc_claimAutoreleasedReturnValue([v1[251] objectAtIndexedSubscript:v29]);
                  LOBYTE(v33) = [v17 requestCounters:v34 firstErrorIndex:&v124];

                  if ((v33 & 1) == 0) {
                    goto LABEL_29;
                  }
                  unsigned int v35 = [v17 setEnabled:1];

                  if (!v35) {
                    break;
                  }
                }
              }

              else
              {
              }
            }
          }
        }

        else
        {
LABEL_29:
        }
      }

      int v36 = *((_DWORD *)v1 + 547);
      unsigned int v37 = @"T";
      if (!v36) {
        unsigned int v37 = @"P";
      }
      if (v36 == 1) {
        unsigned __int8 v38 = @"C";
      }
      else {
        unsigned __int8 v38 = v37;
      }
      id v119 = (id)objc_claimAutoreleasedReturnValue( [@"/tmp/com.apple.gputools.profiling" stringByAppendingPathComponent:v38]);
      if (*((_DWORD *)v1 + 544) != -1)
      {
        id v116 = (void *)objc_claimAutoreleasedReturnValue(+[NSFileManager defaultManager](&OBJC_CLASS___NSFileManager, "defaultManager"));
        [v116 removeItemAtPath:v119 error:0];
        [v116 createDirectoryAtPath:v119 withIntermediateDirectories:1 attributes:0 error:0];
        unsigned __int8 v39 = (void *)objc_claimAutoreleasedReturnValue([v1[3] objectAtIndexedSubscript:*((int *)v1 + 544)]);
        unsigned int v40 = [v39 ringBufferNum];

        if (v40)
        {
          uint64_t v41 = (void *)objc_claimAutoreleasedReturnValue([v1[3] objectAtIndexedSubscript:*((int *)v1 + 544)]);
          unsigned int v42 = [v41 ringBufferNum];

          if (v42)
          {
            unint64_t v43 = 0LL;
            id v44 = (int64x2_t *)(v1 + 391);
            uint64_t v45 = v42;
            do
            {
              unint64_t v46 = (unint64_t)v1[392];
              uint64_t v47 = v1[393];
              if (v46 >= (unint64_t)v47)
              {
                uint64_t v49 = v44->i64[0];
                uint64_t v50 = (uint64_t)(v46 - v44->i64[0]) >> 5;
                unint64_t v51 = v50 + 1;
                uint64_t v52 = (uint64_t)v47 - v49;
                if (v52 >> 4 > v51) {
                  unint64_t v51 = v52 >> 4;
                }
                else {
                  unint64_t v53 = v51;
                }
                if (v53)
                {
                  if (v53 >> 59) {
                    std::__throw_bad_array_new_length[abi:nn180100]();
                  }
                  int v54 = (char *)operator new(32 * v53);
                }

                else
                {
                  int v54 = 0LL;
                }

                unsigned int v55 = &v54[32 * v50];
                *(_OWORD *)unsigned int v55 = 0u;
                *((_OWORD *)v55 + 1) = 0u;
                if (v46 == v49)
                {
                  int64x2_t v59 = vdupq_n_s64(v46);
                  id v56 = &v54[32 * v50];
                }

                else
                {
                  id v56 = &v54[32 * v50];
                  do
                  {
                    uint64_t v57 = *(void *)(v46 - 32);
                    v46 -= 32LL;
                    *(void *)unint64_t v46 = 0LL;
                    *((void *)v56 - 4) = v57;
                    v56 -= 32;
                    __int128 v58 = *(_OWORD *)(v46 + 8);
                    *((void *)v56 + 3) = *(void *)(v46 + 24);
                    *(_OWORD *)(v56 + _Block_object_dispose(&STACK[0x3B0], 8) = v58;
                  }

                  while (v46 != v49);
                  int64x2_t v59 = *v44;
                }

                uint64_t v48 = (GTMTLReplayController **)(v55 + 32);
                v1[391] = (GTMTLReplayController **)v56;
                v1[392] = (GTMTLReplayController **)(v55 + 32);
                v1[393] = (GTMTLReplayController **)&v54[32 * v53];
                int v60 = (char *)v59.i64[1];
                int v61 = (char *)v59.i64[0];
                while (v60 != v61)
                {
                  id v62 = (void *)*((void *)v60 - 4);
                  v60 -= 32;
                }

                if (v61) {
                  operator delete(v61);
                }
              }

              else
              {
                uint64_t v48 = (GTMTLReplayController **)(v46 + 32);
                *(_OWORD *)unint64_t v46 = 0u;
                *(_OWORD *)(v46 + 16) = 0u;
              }

              v1[392] = v48;
              int v63 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"f_%u.raw",  v43));
              uint64_t v64 = objc_claimAutoreleasedReturnValue([v119 stringByAppendingPathComponent:v63]);
              unint64_t v65 = *(v48 - 4);
              *(v48 - 4) = (GTMTLReplayController *)v64;

              *((_DWORD *)v48 - 2) = *((_DWORD *)v1 + 544);
              *((_DWORD *)v48 - 1) = v43;
              if (((*(unint64_t *)((char *)v1[399] + ((v43 >> 3) & 0x1FFFFFFFFFFFFFF8LL)) >> v43) & 1) != 0)
              {
                uint64_t v66 = fopen((const char *)-[GTMTLReplayController UTF8String](*(v48 - 4), "UTF8String"), "wb");
                *(v48 - 3) = (GTMTLReplayController *)v66;
                if (!v66)
                {
                  uint64_t v67 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"Error, fail to open file %@",  *(v48 - 4)));
                  uint64_t v68 = __stdoutp;
                  int v69 = g_runningInCI;
                  id v70 = v67;
                  int v71 = (const char *)[v70 UTF8String];
                  id v72 = "#CI_ERROR# ";
                  if (!v69) {
                    id v72 = "";
                  }
                  fprintf( v68,  "%s%s %u: %s\n",  v72,  "void GTUSCSamplingStreamingManagerHelper::SetupAPSDataFiles(NSString *__strong)",  6974,  v71);
                  id v73 = v70;
                  GTMTLReplay_handleError( 101,  (uint64_t)[v73 UTF8String],  "/Library/Caches/com.apple.xbs/Sources/GPUToolsDevice/GPUTools/GTMTLCapture/replayer/profile/GTUSCSam plingStreamingManager.mm",  (uint64_t)"SetupAPSDataFiles",  6974,  1);
                }
              }

              ++v43;
            }

            while (v43 != v45);
          }
        }
      }

      GTMTLReplayController_prePlayForProfiling((uint64_t)**v1);
      uint64_t v74 = a1;
      mach_get_times( *(void *)(*(void *)(a1 + 48) + 8LL) + 24LL,  *(void *)(*(void *)(a1 + 56) + 8LL) + 24LL,  *(void *)(*(void *)(a1 + 64) + 8LL) + 48LL);
      id v75 = **v1;
      id v114 = v75->var1;
      atomic_store(0, (unsigned int *)v1 + 687);
      [*(id *)(v74 + 32) mapShaderSampleBufferWithBuffer:0 capacity:0 size:0];
      uint64_t v117 = (void *)objc_claimAutoreleasedReturnValue([v75->var1 defaultCommandQueue]);
      unint64_t v76 = objc_autoreleasePoolPush();
      uint64_t v132 = v75;
      LOBYTE(v133) = 0;
      id v131 = (GTMTLReplayController *)[(id)g_commandBufferDescriptor errorOptions];
      [(id)g_commandBufferDescriptor setErrorOptions:0];
      if (*((_DWORD *)v1 + 547) == 1) {
        DisableComputeEncoderCoalescing(**v1, 1LL);
      }
      id v77 = (void *)(*(void *)(*(void *)(a1 + 72) + 8LL) + 48LL);
      unint64_t v78 = (uint64_t *)(*(void *)(*(void *)(a1 + 80) + 8LL) + 48LL);
      BOOL v79 = (void **)(*(void *)(*(void *)(a1 + 88) + 8LL) + 48LL);
      v122[0] = _NSConcreteStackBlock;
      v122[1] = 3221225472LL;
      v122[2] = ___ZN35GTUSCSamplingStreamingManagerHelper9StreamAPSEv_block_invoke_3;
      v122[3] = &__block_descriptor_40_e5_v8__0l;
      v122[4] = v1;
      GTUSCSamplingStreamingManagerHelper::ReplaySingleFrameForUSCSampling((uint64_t)v1, v77, v78, v79, v122);
      if (*((_DWORD *)v1 + 547) == 1) {
        DisableComputeEncoderCoalescing(**v1, 0LL);
      }
      [v117 finish];
      ScopedReplayConfiguration::~ScopedReplayConfiguration((ScopedReplayConfiguration *)&v131);
      objc_autoreleasePoolPop(v76);
      [*(id *)(a1 + 32) unmapShaderSampleBuffer];
      usleep(0x7530u);
      atomic_store(1u, (unsigned __int8 *)v1 + 2760);
      BOOL v80 = (unsigned int *)v1 + 689;
      do
        unsigned int v81 = __ldaxr(v80);
      while (__stlxr(v81 + 1, v80));
      unint64_t v82 = GTAGXPerfStateControl::ConsistentGPUPerfStateLevel((GTAGXPerfStateControl *)(v1 + 5), 0LL);
      uint64_t v83 = objc_claimAutoreleasedReturnValue(v82);
      unsigned int v115 = (void *)v83;
      if (v83) {
        [*(id *)(*(void *)(*(void *)(a1 + 96) + 8) + 40) setDictionary:v83];
      }
      GTUSCSamplingStreamingManagerHelper::DrainAllSourceBuffers((uint64_t)v1[303], (uint64_t)v1[304]);
      __lk.__m_ = (std::unique_lock<std::mutex>::mutex_type *)(v1 + 352);
      __lk.__owns_ = 1;
      std::mutex::lock((std::mutex *)v1 + 44);
      int v84 = *((_DWORD *)v1 + 541);
      unsigned int v85 = atomic_load((unsigned int *)v1 + 687);
      if (v84 != v85)
      {
        do
        {
          std::condition_variable::wait((std::condition_variable *)(v1 + 346), &__lk);
          int v86 = *((_DWORD *)v1 + 541);
          unsigned int v87 = atomic_load((unsigned int *)v1 + 687);
        }

        while (v86 != v87);
      }

      atomic_store(0, (unsigned __int8 *)v1 + 2761);
      __int128 v88 = (void *)objc_claimAutoreleasedReturnValue([v1[2] firstObject]);
      [v88 stopSampling];

      GTAGXPerfStateControl::DisableConsistentGPUPerfState((GTAGXPerfStateControl *)(v1 + 5));
      GTApplePMPPerfStateControl::DisableConsistentPerfState((GTApplePMPPerfStateControl *)(v1 + 8));
      dispatch_semaphore_signal((dispatch_semaphore_t)v1[313]);
      dispatch_semaphore_wait((dispatch_semaphore_t)v1[314], 0xFFFFFFFFFFFFFFFFLL);
      __int128 v89 = (id *)v1[391];
      __int128 v90 = v1[392];
      if (v89 == (id *)v90)
      {
        *(_BYTE *)(*(void *)(*(void *)(a1 + 104) + 8LL) + 24LL) = 0;
      }

      else
      {
        BOOL v91 = 0;
        uint64_t v92 = a1;
        do
        {
          uint64_t v93 = (FILE *)v89[1];
          if (v93)
          {
            fseek(v93, 0LL, 2);
            v89[2] = (id)ftell((FILE *)v89[1]);
            fclose((FILE *)v89[1]);
            if (v91)
            {
              BOOL v91 = 1;
            }

            else
            {
              uint64_t v94 = fopen((const char *)[*v89 UTF8String], "rb");
              unint64_t v95 = (unint64_t)v89[2];
              if (v95 <= 0x200000)
              {
                if (v95 < 0x1000)
                {
LABEL_94:
                  BOOL v91 = 0;
                }

                else
                {
                  uint64_t v96 = 0LL;
                  uint64_t v97 = 0LL;
                  unint64_t v98 = v95 >> 12;
                  if (v95 >> 12 <= 1) {
                    uint64_t v99 = 1LL;
                  }
                  else {
                    uint64_t v99 = v95 >> 12;
                  }
                  BOOL v91 = 1;
                  while (1)
                  {
                    fseek(v94, v96, 0);
                    ftell(v94);
                    int v100 = fgetc(v94);
                    if (v100 != 15 && v100 != -1) {
                      break;
                    }
                    BOOL v91 = ++v97 < v98;
                    v96 += 4096LL;
                    if (v99 == v97) {
                      goto LABEL_94;
                    }
                  }
                }

                fseek(v94, 0LL, 2);
              }

              else
              {
                BOOL v91 = 1;
              }

              fclose(v94);
            }

            v89[1] = 0LL;
            uint64_t v92 = a1;
          }

          v89 += 4;
        }

        while (v89 != (id *)v90);
        *(_BYTE *)(*(void *)(*(void *)(v92 + 104) + 8LL) + 24LL) = v91;
        if (v91)
        {
          unsigned __int8 v121 = (void *)objc_claimAutoreleasedReturnValue(+[NSFileManager defaultManager](&OBJC_CLASS___NSFileManager, "defaultManager"));
          id v101 = v1[391];
          id v102 = v1[392];
          while (v101 != v102)
          {
            unsigned __int8 v103 = [v121 fileExistsAtPath:*v101];
            if (v101[2]) {
              unsigned __int8 v104 = v103;
            }
            else {
              unsigned __int8 v104 = 0;
            }
            if ((v104 & 1) != 0)
            {
              uint64_t v105 = (void *)objc_claimAutoreleasedReturnValue([v1[3] objectAtIndexedSubscript:*((unsigned int *)v101 + 6)]);
              unint64_t v126 = @"APSTraceDataFile";
              id v131 = *v101;
              uint64_t v127 = @"Source";
              uint64_t v106 = (GTMTLReplayController *)objc_claimAutoreleasedReturnValue([v105 name]);
              uint64_t v132 = v106;
              uint64_t v128 = @"SourceIndex";
              uint64_t v107 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedInt:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedInt:",  *((unsigned int *)v101 + 6)));
              uint64_t v133 = v107;
              uint64_t v129 = @"RingBufferIndex";
              id v108 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedInt:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedInt:",  *((unsigned int *)v101 + 7)));
              unint64_t v134 = v108;
              id v130 = @"Serial";
              ++GTUSCSamplingStreamingManagerHelper::StreamAPSDataFiles(void)::serial;
              id v109 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:"));
              uint64_t v135 = v109;
              uint64_t v110 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v131,  &v126,  5LL));

              ((void (*)(void))(*v1)[4]->var2)();
              [v121 removeItemAtPath:*v101 error:0];
            }

            v101 += 4;
          }

          BOOL v124 = @"Post Processing Frame Marker";
          uint64_t v111 = atomic_load(v80);
          id v112 = (__CFString *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedInt:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedInt:",  v111));
          id v125 = v112;
          id v113 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v125,  &v124,  1LL));

          ((void (*)(void))(*v1)[4]->var2)();
        }
      }

      if (__lk.__owns_) {
        std::mutex::unlock(__lk.__m_);
      }
    }
  }

void sub_79348( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, std::mutex *a23, char a24)
{
  _Unwind_Resume(a1);
}

unsigned __int8 *___ZN35GTUSCSamplingStreamingManagerHelper9StreamAPSEv_block_invoke_3(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  unsigned __int8 v2 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v1 + 16) firstObject]);
  [v2 startSampling];

  __n128 result = GTUSCSamplingStreamingManagerHelper::WaitForPreSampling((unsigned __int8 *)v1);
  atomic_store(1u, (unsigned __int8 *)(v1 + 2761));
  return result;
}

void sub_79604(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void ___ZN35GTUSCSamplingStreamingManagerHelper23StreamHarvestedBinariesEv_block_invoke(uint64_t a1)
{
  uint64_t v1 = *(uint64_t ***)(a1 + 40);
  GTMTLReplayController_prePlayForProfiling(**v1);
  uint64_t v2 = **v1;
  unsigned int v81 = -[NSMutableArray initWithCapacity:](objc_alloc(&OBJC_CLASS___NSMutableArray), "initWithCapacity:", 1024LL);
  *(void *)&__int128 v82 = -[NSMutableDictionary initWithCapacity:]( objc_alloc(&OBJC_CLASS___NSMutableDictionary),  "initWithCapacity:",  128LL);
  *((void *)&v82 + 1) = -[NSMutableDictionary initWithCapacity:]( objc_alloc(&OBJC_CLASS___NSMutableDictionary),  "initWithCapacity:",  128LL);
  uint64_t v83 = -[NSMutableDictionary initWithCapacity:]( objc_alloc(&OBJC_CLASS___NSMutableDictionary),  "initWithCapacity:",  128LL);
  uint64_t v66 = v81;
  int v84 = -[NSMutableDictionary initWithCapacity:]( objc_alloc(&OBJC_CLASS___NSMutableDictionary),  "initWithCapacity:",  128LL);
  id v60 = *(id *)(v2 + 8);
  memset(v79, 0, sizeof(v79));
  int v80 = 1065353216;
  memset(v77, 0, sizeof(v77));
  int v78 = 1065353216;
  __p = 0LL;
  id v75 = 0LL;
  uint64_t v76 = 0LL;
  unsigned __int8 v3 = objc_autoreleasePoolPush();
  int v4 = -[ProgramAddressTableCollector initForHarvestingBinaries]( objc_alloc(&OBJC_CLASS___ProgramAddressTableCollector),  "initForHarvestingBinaries");
  BOOL v5 = v1[243];
  v1[243] = v4;

  uint64_t v7 = objc_opt_new(&OBJC_CLASS___NSMutableDictionary, v6);
  uint64_t v8 = v1[244];
  v1[244] = (uint64_t *)v7;

  v1[245] = 0LL;
  objc_autoreleasePoolPop(v3);
  int v63 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v2 + 8) defaultDevice]);
  id v62 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v2 + 8) defaultCommandQueue]);
  [v63 mapShaderSampleBufferWithBuffer:0 capacity:0 size:0];
  uint64_t v9 = objc_autoreleasePoolPush();
  v89[1] = v2;
  char v90 = 0;
  v89[0] = [(id)g_commandBufferDescriptor errorOptions];
  [(id)g_commandBufferDescriptor setErrorOptions:0];
  GTUSCSamplingStreamingManagerHelper::ReplaySingleFrameForUSCSampling((uint64_t)v1, v79, (uint64_t *)v77, &__p, 0LL);
  [v62 finish];
  ScopedReplayConfiguration::~ScopedReplayConfiguration((ScopedReplayConfiguration *)v89);
  objc_autoreleasePoolPop(v9);
  [v63 unmapShaderSampleBuffer];
  int v61 = (void *)objc_claimAutoreleasedReturnValue([v1[243] mappings]);
  uint64_t v64 = (void *)objc_claimAutoreleasedReturnValue([v1[243] binaries]);
  uint64_t v67 = (void *)objc_opt_new(&OBJC_CLASS___NSMutableDictionary, v10);
  __int128 v72 = 0u;
  __int128 v73 = 0u;
  __int128 v70 = 0u;
  __int128 v71 = 0u;
  obint j = v61;
  id v11 = [obj countByEnumeratingWithState:&v70 objects:v89 count:16];
  if (v11)
  {
    id v68 = *(id *)v71;
    do
    {
      uint64_t v12 = 0LL;
      do
      {
        if (*(id *)v71 != v68) {
          objc_enumerationMutation(obj);
        }
        id v13 = *(void **)(*((void *)&v70 + 1) + 8LL * (void)v12);
        uint64_t v14 = (void *)objc_claimAutoreleasedReturnValue([v13 objectForKeyedSubscript:@"encID"]);
        [v14 unsignedIntValue];

        uint64_t v15 = (void *)objc_claimAutoreleasedReturnValue([v13 objectForKeyedSubscript:@"encIndex"]);
        id v16 = [v15 unsignedIntValue];

        uint64_t v17 = (void *)objc_claimAutoreleasedReturnValue([v13 objectForKeyedSubscript:@"drawCallIndex"]);
        id v18 = [v17 unsignedIntValue];

        unsigned __int8 v19 = (void *)objc_claimAutoreleasedReturnValue([v13 objectForKeyedSubscript:@"index"]);
        unsigned int v20 = [v19 unsignedIntValue];

        double v21 = (void *)objc_claimAutoreleasedReturnValue([v13 objectForKeyedSubscript:@"mappedSize"]);
        id v22 = [v21 unsignedLongLongValue];

        id v23 = (void *)objc_claimAutoreleasedReturnValue([v13 objectForKeyedSubscript:@"type"]);
        uint64_t v24 = (objc_object *)objc_claimAutoreleasedReturnValue([v13 objectForKeyedSubscript:@"binaryUniqueId"]);
        if (([v23 isEqualToString:@"AccelerationStructure"] & 1) == 0)
        {
          ComputedKey = GTShaderProfilerGenerateComputedKey((uint64_t)v16, (uint64_t)v18, (uint64_t)v22, v23);
          unsigned int v26 = (void *)objc_claimAutoreleasedReturnValue(ComputedKey);
          unsigned __int8 v27 = (void *)objc_claimAutoreleasedReturnValue([v1[244] objectForKeyedSubscript:v26]);
          BOOL v28 = v27 == 0LL;

          if (!v28)
          {
            uint64_t v29 = (void *)objc_claimAutoreleasedReturnValue([v67 objectForKeyedSubscript:v26]);
            unsigned int v30 = [v29 unsignedIntValue];

            uint64_t v31 = v30 + 1;
            uint64_t v32 = objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](&OBJC_CLASS___NSString, "stringWithFormat:", @"%@_%u", v26, v31));

            uint64_t v33 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInt:](&OBJC_CLASS___NSNumber, "numberWithUnsignedInt:", v31));
            [v67 setObject:v33 forKeyedSubscript:v32];

            unsigned int v26 = (void *)v32;
          }

          [v1[244] setObject:v24 forKeyedSubscript:v26];
          if (v20 != -1)
          {
            id v34 = -[NSMutableArray count](v66, "count");
            int v36 = v81;
            if (v34 == (id)v18)
            {
              unsigned int v37 = (void *)objc_opt_new(&OBJC_CLASS___NSMutableDictionary, v35);
              -[NSMutableArray addObject:](v36, "addObject:", v37);
            }

            uint64_t v66 = v36;
            unsigned __int8 v38 = (void *)objc_claimAutoreleasedReturnValue( -[NSMutableArray objectAtIndexedSubscript:]( v36,  "objectAtIndexedSubscript:",  v18));
            unsigned __int8 v39 = (void *)objc_claimAutoreleasedReturnValue([v38 objectForKeyedSubscript:@"mutiple binary keys"]);
            BOOL v40 = v39 == 0LL;

            if (v40)
            {
              unsigned int v42 = (void *)objc_opt_new(&OBJC_CLASS___NSMutableArray, v41);
              [v38 setObject:v42 forKeyedSubscript:@"mutiple binary keys"];
            }

            unint64_t v43 = (NSData *)objc_claimAutoreleasedReturnValue([v64 objectForKeyedSubscript:v24]);
            if ([v23 isEqualToString:@"vertex"])
            {
              id v44 = AddShaderBinary( (NSMutableDictionary *)v82,  v43,  v24,  *((unsigned __int8 *)v1 + 2185),  *((unsigned int *)*v1 + 19),  (NSString *)&v24->isa,  0,  (NSString *)v23);
              uint64_t v45 = (void *)objc_claimAutoreleasedReturnValue(v44);
              [v38 setObject:v45 forKeyedSubscript:@"vertex shader key"];

              unint64_t v46 = (void *)objc_claimAutoreleasedReturnValue([v38 objectForKeyedSubscript:@"mutiple binary keys"]);
              uint64_t v47 = AddShaderBinary( v84,  v43,  v24,  *((unsigned __int8 *)v1 + 2185),  *((unsigned int *)*v1 + 19),  (NSString *)&v24->isa,  0,  (NSString *)v23);
              uint64_t v48 = (void *)objc_claimAutoreleasedReturnValue(v47);
              [v46 addObject:v48];
              goto LABEL_21;
            }

            if ([v23 isEqualToString:@"fragment"])
            {
              uint64_t v49 = AddShaderBinary( *((NSMutableDictionary **)&v82 + 1),  v43,  v24,  *((unsigned __int8 *)v1 + 2185),  *((unsigned int *)*v1 + 19),  (NSString *)&v24->isa,  0,  (NSString *)v23);
              uint64_t v50 = (void *)objc_claimAutoreleasedReturnValue(v49);
              [v38 setObject:v50 forKeyedSubscript:@"fragment shader key"];

              unint64_t v46 = (void *)objc_claimAutoreleasedReturnValue([v38 objectForKeyedSubscript:@"mutiple binary keys"]);
              unint64_t v51 = AddShaderBinary( v84,  v43,  v24,  *((unsigned __int8 *)v1 + 2185),  *((unsigned int *)*v1 + 19),  (NSString *)&v24->isa,  0,  (NSString *)v23);
              uint64_t v48 = (void *)objc_claimAutoreleasedReturnValue(v51);
              [v46 addObject:v48];
              goto LABEL_21;
            }

            if (([v23 isEqualToString:@"compute"] & 1) != 0
              || [v23 isEqualToString:@"tile"])
            {
              uint64_t v52 = AddShaderBinary( v83,  v43,  v24,  *((unsigned __int8 *)v1 + 2185),  *((unsigned int *)*v1 + 19),  (NSString *)&v24->isa,  0,  (NSString *)v23);
              unint64_t v53 = (void *)objc_claimAutoreleasedReturnValue(v52);
              [v38 setObject:v53 forKeyedSubscript:@"compute kernel key"];

              unint64_t v46 = (void *)objc_claimAutoreleasedReturnValue([v38 objectForKeyedSubscript:@"mutiple binary keys"]);
              int v54 = AddShaderBinary( v84,  v43,  v24,  *((unsigned __int8 *)v1 + 2185),  *((unsigned int *)*v1 + 19),  (NSString *)&v24->isa,  0,  (NSString *)v23);
              uint64_t v48 = (void *)objc_claimAutoreleasedReturnValue(v54);
              [v46 addObject:v48];
              goto LABEL_21;
            }

            if ([v23 containsString:@"dynamic-libraries"])
            {
              unint64_t v46 = (void *)objc_claimAutoreleasedReturnValue([v38 objectForKeyedSubscript:@"mutiple binary keys"]);
              unsigned int v55 = AddShaderBinary( v84,  v43,  v24,  *((unsigned __int8 *)v1 + 2185),  *((unsigned int *)*v1 + 19),  (NSString *)&v24->isa,  1,  (NSString *)v23);
              uint64_t v48 = (void *)objc_claimAutoreleasedReturnValue(v55);
              [v46 addObject:v48];
LABEL_21:
            }
          }
        }

        uint64_t v12 = (char *)v12 + 1;
      }

      while (v11 != v12);
      id v56 = [obj countByEnumeratingWithState:&v70 objects:v89 count:16];
      id v11 = v56;
    }

    while (v56);
  }

  v1[245] = v1[241];
  v1[241] = 0LL;
  id v57 = GTUSCSamplingStreamingManagerHelper::AllocUSCSamplingAddressBuffer((GTUSCSamplingStreamingManagerHelper *)v1);
  v85[0] = @"draw call info";
  v85[1] = @"mutiple binary info";
  v86[0] = v66;
  v86[1] = v84;
  v85[2] = @"internal binary keys";
  v85[3] = @"vertex fetch shader info";
  v86[2] = &__NSArray0__struct;
  v86[3] = &__NSDictionary0__struct;
  __int128 v87 = v82;
  v85[4] = @"vertex shader info";
  v85[5] = @"fragment shader info";
  v85[6] = @"compute kernel info";
  __int128 v88 = v83;
  id v69 = (id)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v86,  v85,  7LL));

  if (__p)
  {
    id v75 = __p;
    operator delete(__p);
  }

  std::__hash_table<std::__hash_value_type<unsigned int,std::vector<GTCoalescedEncoderIndexInfo>>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,std::vector<GTCoalescedEncoderIndexInfo>>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,std::vector<GTCoalescedEncoderIndexInfo>>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,std::vector<GTCoalescedEncoderIndexInfo>>>>::~__hash_table((uint64_t)v77);
  std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long>>>::~__hash_table((uint64_t)v79);

  __int128 v58 = *(void **)(a1 + 32);
  if (v58) {
    [v58 setObject:v69 forKeyedSubscript:@"Havested Binaries"];
  }
}

void sub_7A010( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, id a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, void *__p, uint64_t a31, uint64_t a32, char a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, char a39, uint64_t a40, uint64_t a41, uint64_t a42, uint64_t a43, char a44)
{
}

void ___ZN29GTUSCSamplingStreamingManagerC2EP21GTMTLReplayControllerP26GTMTLReplayOperationQueuesP12NSDictionaryU13block_pointerFvS5_E_block_invoke( uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  uint64_t v2 = *(void *)v1;
  unsigned __int8 v3 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v1 + 16) objectForKeyedSubscript:@"GPUState"]);
  id v13 = v3;
  if (!v3 || (unsigned int v4 = [v3 unsignedIntValue], *(_DWORD *)(v1 + 72) = v4, v5 = v13, !v4))
  {
    *(_DWORD *)(v1 + 72) = 0;
    uint64_t v6 = ExpectedState(v2);
    uint64_t v7 = (void *)objc_claimAutoreleasedReturnValue(v6);
    uint64_t v8 = v7;
    if (v7)
    {
      [v7 doubleValue];
      double v10 = floor(v9);
      unsigned int v11 = (v10 * 100.0);
      *(_DWORD *)(v1 + 64) = v11;
      *(_DWORD *)(v1 + 6_Block_object_dispose(&STACK[0x3B0], 8) = (ceil(v9) * 100.0);
      double v12 = v9 - v10;
      *(double *)(v1 + 24) = v12;
      if (v12 <= 2.22044605e-16) {
        *(_DWORD *)(v1 + 6_Block_object_dispose(&STACK[0x3B0], 8) = v11;
      }
    }

    else
    {
      *(int32x2_t *)(v1 + 64) = vdup_n_s32(0x12Cu);
    }

    BOOL v5 = v13;
  }
}

void sub_7A324( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

uint64_t GTUSCSamplingStreamingManager::GTUSCSamplingStreamingManager( uint64_t a1, uint64_t a2, id *a3, void *a4, void *a5)
{
  id v9 = a4;
  *(void *)a1 = a2;
  *(void *)(a1 + _Block_object_dispose(&STACK[0x3B0], 8) = a3;
  id v10 = v9;
  *(void *)(a1 + 16) = v10;
  id v11 = objc_retainBlock(a5);
  *(void *)(a1 + 40) = 0LL;
  *(void *)(a1 + 32) = v11;
  *(void *)(a1 + 4_Block_object_dispose(&STACK[0x3B0], 8) = 0LL;
  *(void *)(a1 + 56) = 0LL;
  *(_DWORD *)(a1 + 76) = 0x7FFFFFFF;
  uint64_t v13 = objc_opt_new(&OBJC_CLASS___NSMutableDictionary, v12);
  uint64_t v14 = *(void **)(a1 + 40);
  *(void *)(a1 + 40) = v13;

  uint64_t v16 = objc_opt_new(&OBJC_CLASS___NSMutableDictionary, v15);
  uint64_t v17 = *(void **)(a1 + 48);
  *(void *)(a1 + 4_Block_object_dispose(&STACK[0x3B0], 8) = v16;

  *(void *)(a1 + 24) = 0x3FF0000000000000LL;
  v20[0] = _NSConcreteStackBlock;
  v20[1] = 3221225472LL;
  v20[2] = ___ZN29GTUSCSamplingStreamingManagerC2EP21GTMTLReplayControllerP26GTMTLReplayOperationQueuesP12NSDictionaryU13block_pointerFvS5_E_block_invoke;
  v20[3] = &__block_descriptor_40_e5_v8__0l;
  v20[4] = a1;
  id v18 = (void *)objc_claimAutoreleasedReturnValue( +[NSBlockOperation blockOperationWithBlock:]( &OBJC_CLASS___NSBlockOperation,  "blockOperationWithBlock:",  v20));
  [v18 setQueuePriority:8];
  [*a3 addOperation:v18];
  [v18 waitUntilFinished];

  return a1;
}

void sub_7A460(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void GTUSCSamplingStreamingManager::~GTUSCSamplingStreamingManager(id *this)
{
}

void GTUSCSamplingStreamingManager::InitTargetIndex(id *this)
{
  uint64_t v2 = objc_claimAutoreleasedReturnValue([this[2] objectForKeyedSubscript:@"MetalPluginName"]);
  id v3 = this[7];
  this[7] = (id)v2;

  if (this[7])
  {
    unsigned int v4 = (void *)objc_claimAutoreleasedReturnValue([this[2] objectForKeyedSubscript:@"gpuTarget"]);
    id v5 = v4;
    if (v4) {
      *((_DWORD *)this + 19) = [v4 intValue];
    }
  }

  else
  {
    io_registry_entry_t IOAccelerator = GetIOAccelerator();
    id MetalPluginName = GetMetalPluginName(IOAccelerator, (_DWORD *)this + 19);
    uint64_t v8 = objc_claimAutoreleasedReturnValue(MetalPluginName);
    id v5 = this[7];
    this[7] = (id)v8;
  }

  if (*((_DWORD *)this + 19) == 0x7FFFFFFF) {
    *((_DWORD *)this + 19) = MetalPluginTarget(this[7]);
  }
}

void sub_7A598(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void GTUSCSamplingStreamingManager::InitDerivedCountersInfo(id *this)
{
  uint64_t v2 = objc_claimAutoreleasedReturnValue([this[2] objectForKeyedSubscript:@"derivedCounterInfo"]);
  id v3 = this[6];
  this[6] = (id)v2;
}

void GTUSCSamplingStreamingManagerHelper::Instance(GTUSCSamplingStreamingManagerHelper *this)
{
  if ((v1 & 1) == 0)
  {
    if ((_DWORD)v2)
    {
      GTUSCSamplingStreamingManagerHelper::GTUSCSamplingStreamingManagerHelper(v2);
      __cxa_atexit( (void (*)(void *))GTUSCSamplingStreamingManagerHelper::~GTUSCSamplingStreamingManagerHelper,  &GTUSCSamplingStreamingManagerHelper::Instance(void)::instance,  &dword_0);
    }
  }

void GTUSCSamplingStreamingManagerHelper::GTUSCSamplingStreamingManagerHelper( GTUSCSamplingStreamingManagerHelper *this)
{
  byte_5B8D00 = 0;
  xmmword_5B8CE0 = 0u;
  *(_OWORD *)&qword_5B8CF0 = 0u;
  GTUSCSamplingStreamingManagerHelper::Instance(void)::instance = 0u;
  qword_5B8D08 = 0LL;
  qword_5B8D10 = 0LL;
  qword_5B8D18 = 0x300000000LL;
  bzero(&unk_5B8D20, 0x70CuLL);
  unk_5B9450 = 0u;
  xmmword_5B9440 = 0u;
  xmmword_5B9468 = 0u;
  *(_OWORD *)algn_5B9478 = 0u;
  unk_5B9488 = 0u;
  *(_OWORD *)&qword_5B9498 = 0u;
  xmmword_5B94A8 = 0u;
  *(_OWORD *)&qword_5B94B8 = 0u;
  xmmword_5B94C8 = 0u;
  *(_OWORD *)&qword_5B94D8 = 0u;
  xmmword_5B94E8 = 0u;
  *(_OWORD *)&qword_5B94F8 = 0u;
  unk_5B9508 = 0u;
  unk_5B9518 = 0u;
  xmmword_5B9528 = 0u;
  unk_5B9538 = 0u;
  qword_5B9548 = 0LL;
  qword_5B9550 = 0xFFFFFFFFLL;
  unk_5B9558 = 257;
  byte_5B955A = 1;
  unk_5B95A8 = 0u;
  xmmword_5B958C = 0u;
  unk_5B959C = 0u;
  xmmword_5B956C = 0u;
  unk_5B957C = 0u;
  xmmword_5B955C = 0u;
  dword_5B95B8 = 1065353216;
  xmmword_5B95C0 = 0u;
  xmmword_5B95D0 = 0u;
  unk_5B95E0 = 0u;
  xmmword_5B95F0 = 0u;
  xmmword_5B9600 = 0u;
  xmmword_5B9610 = 0u;
  xmmword_5B9620 = 0u;
  xmmword_5B9630 = 0u;
  unk_5B9640 = 0u;
  xmmword_5B9650 = 0u;
  xmmword_5B9660 = 0u;
  xmmword_5B9670 = 0u;
  *(_OWORD *)&qword_5B9680 = 0u;
  xmmword_5B9690 = 0u;
  xmmword_5B96A0 = 0u;
  xmmword_5B96B0 = 0u;
  unk_5B96C0 = 0u;
  qword_5B96D0 = 0LL;
  dword_5B96D8 = 1065353216;
  xmmword_5B96E0 = 0u;
  unk_5B96F0 = 0u;
  xmmword_5B9700 = 0u;
  xmmword_5B9710 = 0u;
  unk_5B9720 = 0u;
  xmmword_5B9730 = 0u;
  xmmword_5B9740 = 0u;
  xmmword_5B9750 = 0u;
  dword_5B9760 = 1065353216;
  byte_5B9768 = 0;
  xmmword_5B9770 = 0u;
  xmmword_5B9780 = 0u;
  *(__int128 *)((char *)&xmmword_5B9780 + 13) = 0u;
  qword_5B97A0 = 1018212795LL;
  unk_5B97A8 = 0u;
  unk_5B97B8 = 0u;
  qword_5B97C8 = 0LL;
  qword_5B97D0 = 850045863LL;
  unk_5B97D8 = 0u;
  unk_5B97E8 = 0u;
  unk_5B97F8 = 0u;
  qword_5B9808 = 0LL;
  qword_5B9810 = 1018212795LL;
  unk_5B9818 = 0u;
  unk_5B9828 = 0u;
  qword_5B9838 = 0LL;
  qword_5B9840 = 850045863LL;
  unk_5B9848 = 0u;
  unk_5B9858 = 0u;
  unk_5B9868 = 0u;
  qword_5B9878 = 0LL;
  qword_5B9880 = 1018212795LL;
  unk_5B9888 = 0u;
  unk_5B9898 = 0u;
  qword_5B98A8 = 0LL;
  qword_5B98B0 = 850045863LL;
  qword_5B98E8 = 0LL;
  unk_5B98D8 = 0u;
  unk_5B98C8 = 0u;
  unk_5B98B8 = 0u;
  *((void *)&xmmword_5B98F0 + 1) = -1LL;
  *(void *)&xmmword_5B98F0 = -1LL;
  qword_5B9920 = 0LL;
  xmmword_5B9910 = 0u;
  xmmword_5B9900 = 0u;
  xmmword_5B9928 = xmmword_318310;
  qword_5B9938 = 50000LL;
  qword_5B9940 = qword_5B9940 & 0xFFFFFFFFFFFFFFFCLL | 1;
  qword_5B9950 = 0LL;
  qword_5B9948 = 0LL;
  qword_5B9958 = 0LL;
  qword_5B9960 = 4LL;
  dword_5B9968 = 0;
}

void GTUSCSamplingStreamingManagerHelper::~GTUSCSamplingStreamingManagerHelper( GTUSCSamplingStreamingManagerHelper *this)
{
  uint64_t v2 = (void *)*((void *)this + 399);
  if (v2) {
    operator delete(v2);
  }
  uint64_t v6 = (void **)((char *)this + 3128);
  std::vector<SourceFileInfo>::__destroy_vector::operator()[abi:nn180100](&v6);

  std::mutex::~mutex((std::mutex *)((char *)this + 3040));
  std::condition_variable::~condition_variable((std::condition_variable *)((char *)this + 2992));
  std::mutex::~mutex((std::mutex *)((char *)this + 2928));
  std::condition_variable::~condition_variable((std::condition_variable *)this + 60);
  std::mutex::~mutex((std::mutex *)this + 44);
  std::condition_variable::~condition_variable((std::condition_variable *)((char *)this + 2768));
  std::__hash_table<std::__hash_value_type<std::string,std::vector<std::string>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<std::string>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<std::string>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<std::string>>>>::~__hash_table((uint64_t)this + 2672);
  for (uint64_t i = 2648LL; i != 2552; i -= 24LL)
  {
    uint64_t v6 = (void **)((char *)this + i);
    std::vector<std::string>::__destroy_vector::operator()[abi:nn180100](&v6);
  }

  std::__hash_table<std::__hash_value_type<std::string,std::vector<std::string>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<std::string>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<std::string>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<std::string>>>>::~__hash_table((uint64_t)this + 2536);

  uint64_t v6 = (void **)((char *)this + 2472);
  std::vector<NSObject  {objcproto21OS_dispatch_semaphore}* {__strong}>::__destroy_vector::operator()[abi:nn180100](&v6);
  uint64_t v6 = (void **)((char *)this + 2448);
  std::vector<std::vector<NSObject  {objcproto21OS_dispatch_semaphore}* {__strong}>>::__destroy_vector::operator()[abi:nn180100](&v6);
  uint64_t v6 = (void **)((char *)this + 2424);
  std::vector<std::vector<NSObject  {objcproto21OS_dispatch_semaphore}* {__strong}>>::__destroy_vector::operator()[abi:nn180100](&v6);
  uint64_t v6 = (void **)((char *)this + 2400);
  std::vector<std::vector<GTMMappedBuffer>>::__destroy_vector::operator()[abi:nn180100](&v6);
  uint64_t v6 = (void **)((char *)this + 2376);
  std::vector<DynamicBuffer>::__destroy_vector::operator()[abi:nn180100](&v6);
  uint64_t v6 = (void **)((char *)this + 2352);
  std::vector<std::vector<GTMMappedBuffer>>::__destroy_vector::operator()[abi:nn180100](&v6);
  uint64_t v6 = (void **)((char *)this + 2328);
  std::vector<std::vector<GTMMappedBuffer>>::__destroy_vector::operator()[abi:nn180100](&v6);

  std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long>>>::~__hash_table((uint64_t)this + 2248);
  unsigned int v4 = (void *)*((void *)this + 278);
  if (v4)
  {
    *((void *)this + 279) = v4;
    operator delete(v4);
  }

  uint64_t v6 = (void **)((char *)this + 2200);
  std::vector<std::vector<ProfileEvent>>::__destroy_vector::operator()[abi:nn180100](&v6);

  GTSampleBufferManager::~GTSampleBufferManager((id *)this + 263);
  id v5 = (void *)*((void *)this + 238);
  if (v5)
  {
    *((void *)this + 239) = v5;
    operator delete(v5);
  }

  GTApplePMPPerfStateControl::~GTApplePMPPerfStateControl((GTUSCSamplingStreamingManagerHelper *)((char *)this + 64));
  GTAGXPerfStateControl::~GTAGXPerfStateControl((id *)this + 5);
}

void sub_7AAEC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void **a10)
{
  uint64_t v12 = *(void **)(v10 + 3192);
  if (v12) {
    operator delete(v12);
  }
  a10 = (void **)(v10 + 3128);
  std::vector<SourceFileInfo>::__destroy_vector::operator()[abi:nn180100](&a10);

  std::mutex::~mutex((std::mutex *)(v10 + 3040));
  std::condition_variable::~condition_variable((std::condition_variable *)(v10 + 2992));
  std::mutex::~mutex((std::mutex *)(v10 + 2928));
  std::condition_variable::~condition_variable((std::condition_variable *)(v10 + 2880));
  std::mutex::~mutex((std::mutex *)(v10 + 2816));
  std::condition_variable::~condition_variable((std::condition_variable *)(v10 + 2768));
  std::__hash_table<std::__hash_value_type<std::string,std::vector<std::string>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<std::string>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<std::string>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<std::string>>>>::~__hash_table(v10 + 2672);
  for (uint64_t i = 0LL; i != -96; i -= 24LL)
  {
    a10 = (void **)(v10 + 2648 + i);
    std::vector<std::string>::__destroy_vector::operator()[abi:nn180100](&a10);
  }

  std::__hash_table<std::__hash_value_type<std::string,std::vector<std::string>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<std::string>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<std::string>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<std::string>>>>::~__hash_table(v10 + 2536);

  a10 = (void **)(v10 + 2472);
  std::vector<NSObject  {objcproto21OS_dispatch_semaphore}* {__strong}>::__destroy_vector::operator()[abi:nn180100](&a10);
  a10 = (void **)(v10 + 2448);
  std::vector<std::vector<NSObject  {objcproto21OS_dispatch_semaphore}* {__strong}>>::__destroy_vector::operator()[abi:nn180100](&a10);
  a10 = (void **)(v10 + 2424);
  std::vector<std::vector<NSObject  {objcproto21OS_dispatch_semaphore}* {__strong}>>::__destroy_vector::operator()[abi:nn180100](&a10);
  a10 = (void **)(v10 + 2400);
  std::vector<std::vector<GTMMappedBuffer>>::__destroy_vector::operator()[abi:nn180100](&a10);
  a10 = (void **)(v10 + 2376);
  std::vector<DynamicBuffer>::__destroy_vector::operator()[abi:nn180100](&a10);
  a10 = (void **)(v10 + 2352);
  std::vector<std::vector<GTMMappedBuffer>>::__destroy_vector::operator()[abi:nn180100](&a10);
  a10 = (void **)(v10 + 2328);
  std::vector<std::vector<GTMMappedBuffer>>::__destroy_vector::operator()[abi:nn180100](&a10);

  std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long>>>::~__hash_table(v10 + 2248);
  uint64_t v14 = *(void **)(v10 + 2224);
  if (v14)
  {
    *(void *)(v10 + 2232) = v14;
    operator delete(v14);
  }

  a10 = (void **)(v10 + 2200);
  std::vector<std::vector<ProfileEvent>>::__destroy_vector::operator()[abi:nn180100](&a10);

  GTSampleBufferManager::~GTSampleBufferManager((id *)(v10 + 2104));
  uint64_t v15 = *(void **)(v10 + 1904);
  if (v15)
  {
    *(void *)(v10 + 1912) = v15;
    operator delete(v15);
  }

  GTApplePMPPerfStateControl::~GTApplePMPPerfStateControl((GTApplePMPPerfStateControl *)(v10 + 64));
  GTAGXPerfStateControl::~GTAGXPerfStateControl((id *)(v10 + 40));

  _Unwind_Resume(a1);
}

void std::vector<SourceFileInfo>::__destroy_vector::operator()[abi:nn180100](void ***a1)
{
  unsigned __int8 v1 = *a1;
  uint64_t v2 = (char *)**a1;
  if (v2)
  {
    unsigned int v4 = (char *)v1[1];
    id v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        uint64_t v6 = (void *)*((void *)v4 - 4);
        v4 -= 32;
      }

      while (v4 != v2);
      id v5 = **a1;
    }

    v1[1] = v2;
    operator delete(v5);
  }

uint64_t std::__hash_table<std::__hash_value_type<std::string,std::vector<std::string>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<std::string>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<std::string>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<std::string>>>>::~__hash_table( uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 16);
  if (v2)
  {
    do
    {
      id v3 = (void *)*v2;
      std::__destroy_at[abi:nn180100]<std::pair<std::string const,std::vector<std::string>>,0>((uint64_t)(v2 + 2));
      operator delete(v2);
      uint64_t v2 = v3;
    }

    while (v3);
  }

  unsigned int v4 = *(void **)a1;
  *(void *)a1 = 0LL;
  if (v4) {
    operator delete(v4);
  }
  return a1;
}

void std::vector<std::vector<NSObject  {objcproto21OS_dispatch_semaphore}* {__strong}>>::__destroy_vector::operator()[abi:nn180100]( void ***a1)
{
  unsigned __int8 v1 = *a1;
  uint64_t v2 = (void **)**a1;
  if (v2)
  {
    unsigned int v4 = (void **)v1[1];
    id v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        v4 -= 3;
        uint64_t v6 = v4;
        std::vector<NSObject  {objcproto21OS_dispatch_semaphore}* {__strong}>::__destroy_vector::operator()[abi:nn180100](&v6);
      }

      while (v4 != v2);
      id v5 = **a1;
    }

    v1[1] = v2;
    operator delete(v5);
  }

void std::vector<std::vector<GTMMappedBuffer>>::__destroy_vector::operator()[abi:nn180100](void ***a1)
{
  unsigned __int8 v1 = *a1;
  uint64_t v2 = (void **)**a1;
  if (v2)
  {
    unsigned int v4 = (void **)v1[1];
    id v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        v4 -= 3;
        uint64_t v6 = v4;
        std::vector<GTMMappedBuffer>::__destroy_vector::operator()[abi:nn180100](&v6);
      }

      while (v4 != v2);
      id v5 = **a1;
    }

    v1[1] = v2;
    operator delete(v5);
  }

void std::vector<DynamicBuffer>::__destroy_vector::operator()[abi:nn180100](void ***a1)
{
  uint64_t v2 = *a1;
  if (*v2)
  {
    std::vector<DynamicBuffer>::__clear[abi:nn180100]((uint64_t *)v2);
    operator delete(**a1);
  }

void GTSampleBufferManager::~GTSampleBufferManager(id *this)
{
  id v2 = *this;
  *this = 0LL;

  id v3 = this[3];
  if (v3)
  {
    this[4] = v3;
    operator delete(v3);
  }
}

void sub_7AF9C(_Unwind_Exception *a1)
{
  id v3 = *(void **)(v1 + 24);
  if (v3)
  {
    *(void *)(v1 + 32) = v3;
    operator delete(v3);
  }

  _Unwind_Resume(a1);
}

void GTApplePMPPerfStateControl::~GTApplePMPPerfStateControl(GTApplePMPPerfStateControl *this)
{
  for (uint64_t i = 1752LL; i != -40; i -= 56LL)
}

void sub_7B00C(_Unwind_Exception *a1)
{
  for (uint64_t i = 1752LL; i != -40; i -= 56LL)

  _Unwind_Resume(a1);
}

void GTAGXPerfStateControl::~GTAGXPerfStateControl(id *this)
{
  io_connect_t v2 = *(_DWORD *)this;
  if (v2)
  {
    IOServiceClose(v2);
    *(_DWORD *)this = 0;
  }
}

void sub_7B068(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void GPURawCounterSetupParams::~GPURawCounterSetupParams(id *this)
{
}

void std::__destroy_at[abi:nn180100]<std::pair<std::string const,std::vector<std::string>>,0>(uint64_t a1)
{
  io_connect_t v2 = (void **)(a1 + 24);
  std::vector<std::string>::__destroy_vector::operator()[abi:nn180100](&v2);
}

float64_t GetTextureRendererUniform( uint64_t a1, float64_t *a2, int a3, uint64_t a4, uint64_t a5, float64x2_t a6, float64_t a7, float64x2_t a8, float64_t a9, float64x2_t a10, float64_t a11, double a12, double a13, double a14, double a15)
{
  v17.f64[0] = a2[8];
  v18.f64[0] = a2[9];
  v17.f64[1] = a2[12];
  v19.f64[0] = *a2;
  v20.f64[0] = a2[1];
  v19.f64[1] = a2[4];
  v18.f64[1] = a2[13];
  v20.f64[1] = a2[5];
  *(float32x4_t *)a1 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v19), v17);
  *(float32x4_t *)(a1 + 16) = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v20), v18);
  v17.f64[0] = a2[10];
  v18.f64[0] = a2[11];
  v22.f64[1] = a2[14];
  v19.f64[0] = a2[2];
  v20.f64[0] = a2[3];
  v19.f64[1] = a2[6];
  float32x4_t v21 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v19), v22);
  v18.f64[1] = a2[15];
  v20.f64[1] = a2[7];
  v22.f64[0] = a14;
  *(float32x4_t *)(a1 + 32) = v21;
  *(float32x4_t *)(a1 + 4_Block_object_dispose(&STACK[0x3B0], 8) = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v20), v18);
  if (a3)
  {
    v23.i64[0] = a4;
    v23.i64[1] = a5;
    float64x2_t v24 = vcvtq_f64_u64(v23);
    double v25 = a14 / v24.f64[0];
    if (a14 / v24.f64[0] >= a15 / v24.f64[1]) {
      double v25 = a15 / v24.f64[1];
    }
    v22.f64[1] = a15;
    float32x2_t v26 = vcvt_f32_f64(vmulq_n_f64(v24, v25 / a12));
    __asm { FMOV            V4.2D, #0.5 }

    a8 = vmulq_f64(vsubq_f64(vdivq_f64(v22, (float64x2_t)vdupq_lane_s64(*(uint64_t *)&a12, 0)), vcvtq_f64_f32(v26)), _Q4);
  }

  else
  {
    a8.f64[1] = a9;
    a10.f64[1] = a11;
    float32x2_t v26 = vcvt_f32_f64(a10);
    v22.f64[1] = a15;
  }

  *(float32x2_t *)(a1 + 64) = vcvt_f32_f64(a8);
  *(float32x2_t *)(a1 + 72) = v26;
  a6.f64[1] = a7;
  *(float32x2_t *)&a6.f64[0] = vcvt_f32_f64(a6);
  float v33 = a12;
  *(float *)(a1 + 96) = v33;
  *(float32x2_t *)(a1 + 80) = vcvt_f32_f64(v22);
  *(float64_t *)(a1 + 8_Block_object_dispose(&STACK[0x3B0], 8) = a6.f64[0];
  return a6.f64[0];
}

void EncodeAttachment( uint64_t a1, void *a2, void *a3, void *a4, void *a5, void *a6, void *a7, unint64_t a8, unint64_t a9, unsigned __int8 a10)
{
  id v16 = a3;
  id v17 = a6;
  id v18 = a7;
  float64x2_t v19 = *(void **)(*(void *)(a1 + 8) + 16LL);
  id v20 = a4;
  id v21 = GTMTLReplayController_resizeTexture(v19, a1 + 96, a2, a5, a8, a9, 0LL);
  float64x2_t v22 = (void *)objc_claimAutoreleasedReturnValue(v21);
  uint64x2_t v23 = (void *)objc_claimAutoreleasedReturnValue([v20 device]);
  id v24 = [v20 pixelFormat];

  GTMTLPixelFormatGetInfoForDevice((uint64_t)v26, (uint64_t)v23, (uint64_t)v24);
  [v16 drawTexture:v22 isDepthStencil:(v26[8] & 0x60) != 0 shrinkToFit:a10];
  if (v17) {
    [v16 drawOverlay:v17 color:*(unsigned int *)(a1 + 72) shrinkToFit:a10];
  }
  if (v18) {
    [v16 drawOverlay:v18 color:*(unsigned int *)(a1 + 76) shrinkToFit:a10];
  }
}

void GTMTLReplayClient_displayAttachment(uint64_t a1, uint64_t a2, unsigned int a3, uint64_t a4)
{
  uint64_t v6 = *(void *)(a1 + 8);
  GTMTLReplayController_debugSubCommandStop(v6, a3, a4);
  uint64_t v7 = GTMTLReplayController_renderPassDescriptor(v6);
  uint64_t v8 = 0LL;
  uint64_t v9 = a3;
  uint64_t v10 = *(uint64_t **)(*(void *)v6 + 40LL);
  id v11 = (uint64_t *)(v7 + 8);
  uint64_t v12 = 0xFFFFFFFFLL;
  uint64_t v13 = 0xFFFFFFFFLL;
  do
  {
    uint64_t v15 = *v11;
    v11 += 8;
    uint64_t v14 = v15;
    if (v15)
    {
      uint64_t v12 = (int)v12 >= 0 ? v12 : v8;
      Object = GTMTLSMContext_getObject(*v10, v14, *(void *)(*(void *)v6 + 80LL) + v9);
      if (Object)
      {
        if (Object[24]) {
          uint64_t v13 = v8;
        }
        else {
          uint64_t v13 = v13;
        }
      }
    }

    ++v8;
  }

  while (v8 != 8);
  if ((v13 & 0x80000000) != 0)
  {
    if ((v12 & 0x80000000) != 0)
    {
      if (*(void *)(v7 + 680))
      {
        id v17 = (uint64_t *)(v7 + 672);
        uint64_t v13 = 8LL;
      }

      else
      {
        if (!*(void *)(v7 + 728)) {
          return;
        }
        id v17 = (uint64_t *)(v7 + 720);
        uint64_t v13 = 9LL;
      }
    }

    else
    {
      id v17 = (uint64_t *)(v7 + ((unint64_t)v12 << 6));
      uint64_t v13 = v12;
    }
  }

  else
  {
    id v17 = (uint64_t *)(v7 + ((unint64_t)v13 << 6));
  }

  uint64_t v18 = *v17;
  if (*v17)
  {
    float64x2_t v19 = (unsigned __int16 *)v17 + 10;
    id v20 = (unsigned __int8 *)v17 + 26;
    id v21 = (unsigned __int16 *)v17 + 9;
  }

  else
  {
    uint64_t v18 = v17[1];
    if (!v18) {
      return;
    }
    float64x2_t v19 = (unsigned __int16 *)v17 + 11;
    id v20 = (unsigned __int8 *)(v17 + 3);
    id v21 = (unsigned __int16 *)(v17 + 2);
  }

  uint64_t v22 = *v20;
  uint64_t v23 = *v19;
  uint64_t v24 = *v21;
  if (*(_BYTE *)(a2 + 10))
  {
    uint64_t v96 = 0LL;
    id v25 = GTMTLReplayController_generateOutlineTexture(v6, (id *)(a1 + 96), &v96);
    unsigned int v85 = (void *)objc_claimAutoreleasedReturnValue(v25);
    float32x2_t v26 = v96;
    GTMTLReplay_handleNSError(v26);
  }

  else
  {
    unsigned int v85 = 0LL;
  }

  if (*(_BYTE *)(a2 + 9))
  {
    unint64_t v95 = 0LL;
    id v27 = GTMTLReplayController_generateWireframeTexture(v6, a1 + 96, 1LL, 0LL, &v95);
    int v84 = (void *)objc_claimAutoreleasedReturnValue(v27);
    BOOL v28 = v95;
    GTMTLReplay_handleNSError(v28);
  }

  else
  {
    int v84 = 0LL;
  }

  uint64_t v29 = *(void *)(*(void *)v6 + 40LL);
  __int128 v87 = GTMTLSMContext_getObject(*(void *)v29, v18, *(void *)(*(void *)v6 + 80LL) + v9);
  if (v87[24])
  {
    unsigned int v30 = apr_array_make(*(apr_pool_t **)a1, 16, 8);
    GTMTLSMContext_getObjects(*(_DWORD **)(v29 + 240), *(void *)(*(void *)v6 + 80LL) + v9, v30);
    uint64_t v31 = -[NSMutableArray initWithCapacity:](objc_alloc(&OBJC_CLASS___NSMutableArray), "initWithCapacity:", v30->nelts);
    uint64_t v32 = -[NSMutableArray initWithCapacity:](objc_alloc(&OBJC_CLASS___NSMutableArray), "initWithCapacity:", v30->nelts);
    float v33 = v32;
    if (v30->nelts >= 1)
    {
      __int128 v89 = v32;
      uint64_t v34 = v6;
      uint64_t v35 = 0LL;
      LODWORD(v36) = -1;
      do
      {
        unsigned int v37 = v31;
        uint64_t v38 = *(void *)&v30->elts[8 * v35];
        if (*(void *)(v38 + 8) == v87[24]) {
          uint64_t v36 = v35;
        }
        else {
          uint64_t v36 = v36;
        }
        v102[0] = &off_5A0598;
        v101[0] = @"type";
        v101[1] = @"object";
        unsigned __int8 v39 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  *(void *)(v38 + 48)));
        v102[1] = v39;
        v102[2] = &off_5A05B0;
        v101[2] = @"DependencyGraphRequestedTextureLevel";
        v101[3] = @"DependencyGraphRequestedTextureSlice";
        v102[3] = &off_5A05B0;
        v102[4] = &off_5A05B0;
        v101[4] = @"DependencyGraphRequestedTextureAttachmentIndex";
        v101[5] = @"DependencyGraphRequestedTextureDepthPlane";
        v102[5] = &off_5A05B0;
        BOOL v40 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v102,  v101,  6LL));

        uint64_t v41 = *(void **)(v34 + 40);
        unsigned int v42 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  *(void *)(v38 + 48)));
        unint64_t v43 = (void *)objc_claimAutoreleasedReturnValue([v41 objectForKeyedSubscript:v42]);

        if (!v43) {
          unint64_t v43 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v34 + 8) textureForKey:*(void *)(v38 + 48)]);
        }
        uint64_t v31 = v37;
        -[NSMutableArray addObject:](v37, "addObject:", v40);
        -[NSMutableArray addObject:](v89, "addObject:", v43);

        ++v35;
      }

      while (v35 < v30->nelts);
      uint64_t v6 = v34;
      float v33 = v89;
      goto LABEL_43;
    }
  }

  else
  {
    v100[0] = &off_5A0598;
    v99[0] = @"type";
    v99[1] = @"object";
    id v44 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLongLong:](&OBJC_CLASS___NSNumber, "numberWithUnsignedLongLong:", v18));
    v100[1] = v44;
    v99[2] = @"DependencyGraphRequestedTextureLevel";
    uint64_t v45 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedShort:](&OBJC_CLASS___NSNumber, "numberWithUnsignedShort:", v22));
    v100[2] = v45;
    v99[3] = @"DependencyGraphRequestedTextureSlice";
    unint64_t v46 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedShort:](&OBJC_CLASS___NSNumber, "numberWithUnsignedShort:", v23));
    v100[3] = v46;
    v99[4] = @"DependencyGraphRequestedTextureAttachmentIndex";
    uint64_t v47 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInt:](&OBJC_CLASS___NSNumber, "numberWithUnsignedInt:", v13));
    v100[4] = v47;
    void v99[5] = @"DependencyGraphRequestedTextureDepthPlane";
    uint64_t v48 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedShort:](&OBJC_CLASS___NSNumber, "numberWithUnsignedShort:", v24));
    v100[5] = v48;
    uint64_t v49 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v100,  v99,  6LL));

    uint64_t v50 = *(void **)(v6 + 40);
    unint64_t v51 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLongLong:](&OBJC_CLASS___NSNumber, "numberWithUnsignedLongLong:", v18));
    uint64_t v52 = (void *)objc_claimAutoreleasedReturnValue([v50 objectForKeyedSubscript:v51]);

    if (!v52) {
      uint64_t v52 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v6 + 8) textureForKey:v18]);
    }
    unint64_t v98 = v49;
    uint64_t v53 = objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", &v98, 1LL));
    uint64_t v97 = v52;
    uint64_t v31 = (NSMutableArray *)v53;
    float v33 = (NSMutableArray *)objc_claimAutoreleasedReturnValue( +[NSArray arrayWithObjects:count:]( &OBJC_CLASS___NSArray,  "arrayWithObjects:count:",  &v97,  1LL));

    unsigned int v30 = 0LL;
  }

  uint64_t v36 = 0xFFFFFFFFLL;
LABEL_43:
  GTMTLReplayClient_waitForUntrackedWritesToComplete(v6, v33);
  uint64_t v83 = v31;
  TexturesForResize = GTMTLReplayClient_retrieveTexturesForResize((id *)v6, v31, v33, 1, 0LL);
  unsigned int v55 = (void *)objc_claimAutoreleasedReturnValue(TexturesForResize);
  id v56 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v6 + 8) defaultCommandQueue]);
  id v57 = InternalCommandBuffer(v56, @"DisplayAttachment");
  __int128 v58 = (void *)objc_claimAutoreleasedReturnValue(v57);

  int64x2_t v59 = objc_alloc(&OBJC_CLASS___GTMTLTextureRenderEncoder);
  id v60 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v6 + 8) defaultDevice]);
  int v61 = -[GTMTLTextureRenderEncoder initWithDevice:](v59, "initWithDevice:", v60);

  char v90 = v33;
  int v86 = v55;
  if (v87[24])
  {
    id v62 = v58;
    if (v30->nelts >= 1)
    {
      uint64_t v63 = 0LL;
      do
      {
        uint64_t v64 = (void *)objc_claimAutoreleasedReturnValue( [*(id *)(v6 + 8) layerForKey:*(void *)(*(void *)&v30->elts[8 * v63] + 40)]);
        [v64 drawableSize];
        double v66 = v65;
        double v68 = v67;
        if (v64) {
          [v64 transform];
        }
        else {
          memset(v94, 0, sizeof(v94));
        }
        -[GTMTLTextureRenderEncoder setTransform:](v61, "setTransform:", v94);
        [v64 bounds];
        double v70 = v69;
        double v72 = v71;
        double v74 = v73;
        double v76 = v75;
        [v64 contentsScale];
        -[GTMTLTextureRenderEncoder setBounds:contentsScale:](v61, "setBounds:contentsScale:", v70, v72, v74, v76, v77);
        [v64 anchorPoint];
        -[GTMTLTextureRenderEncoder setAnchor:](v61, "setAnchor:");
        if (v36 == v63)
        {
          int v78 = (void *)objc_claimAutoreleasedReturnValue(-[NSMutableArray objectAtIndexedSubscript:](v90, "objectAtIndexedSubscript:", v36));
          BOOL v79 = (void *)objc_claimAutoreleasedReturnValue([v86 objectAtIndexedSubscript:v36]);
          id v62 = v58;
          EncodeAttachment(a1, v58, v61, v78, v79, v84, v85, (unint64_t)v66, (unint64_t)v68, 0);
        }

        else
        {
          int v78 = (void *)objc_claimAutoreleasedReturnValue(-[NSMutableArray objectAtIndexedSubscript:](v90, "objectAtIndexedSubscript:", v63));
          BOOL v79 = (void *)objc_claimAutoreleasedReturnValue([v86 objectAtIndexedSubscript:v63]);
          id v62 = v58;
          EncodeAttachment(a1, v58, v61, v78, v79, 0LL, 0LL, (unint64_t)v66, (unint64_t)v68, 0);
        }

        ++v63;
      }

      while (v63 < v30->nelts);
    }
  }

  else
  {
    -[GTMTLTextureRenderEncoder setBounds:contentsScale:]( v61,  "setBounds:contentsScale:",  0.0,  0.0,  (double)*(unint64_t *)(v6 + 22464),  (double)*(unint64_t *)(v6 + 22472),  1.0);
    int v80 = (void *)objc_claimAutoreleasedReturnValue(-[NSMutableArray objectAtIndexedSubscript:](v33, "objectAtIndexedSubscript:", 0LL));
    unsigned int v81 = (void *)objc_claimAutoreleasedReturnValue([v55 objectAtIndexedSubscript:0]);
    EncodeAttachment(a1, v58, v61, v80, v81, v84, v85, *(void *)(v6 + 22464), *(void *)(v6 + 22472), 1u);

    id v62 = v58;
  }

  v91[0] = _NSConcreteStackBlock;
  v91[1] = 3221225472LL;
  v91[2] = __GTMTLReplayClient_displayAttachment_block_invoke;
  v91[3] = &unk_58F760;
  uint64_t v92 = v61;
  uint64_t v93 = a1;
  __int128 v82 = v61;
  [v62 addCompletedHandler:v91];
  GTMTLReplay_commitCommandBuffer(v62);
}

id GTMTLShaderDebugger_generateTrace(uint64_t *a1, void *a2, void *a3)
{
  id v3 = a2;
  unint64_t v548 = 0LL;
  p = 0LL;
  v531 = 0LL;
  __int128 v546 = 0u;
  id v547 = 0LL;
  __int128 v537 = 0u;
  char v536 = 0;
  __int128 v532 = 0u;
  __int128 v533 = 0u;
  __int128 v534 = 0u;
  __int128 v535 = 0u;
  v538 = objc_alloc_init(&OBJC_CLASS___NSDictionary);

  __int128 v539 = 0u;
  __int128 v540 = 0u;

  uint64_t v541 = 0LL;
  uint64_t v542 = 0x7FFFFFFFFFFFFFFFLL;
  id v543 = 0LL;

  uint64_t v544 = 2LL;
  __int128 v545 = 0u;

  *(void *)&__int128 v546 = 0LL;
  apr_pool_create_ex(&p, 0LL, 0LL, v4);
  id v5 = v3;
  v503 = v5;
  if (!v5)
  {
    if (a3)
    {
      id Error = GTShaderDebuggerMakeError(1u, @"Internal error: nil request", 0LL, 0LL, 0LL);
      id v70 = (id)objc_claimAutoreleasedReturnValue(Error);
LABEL_54:
      uint64_t v72 = 0LL;
      id v59 = 0LL;
LABEL_77:
      unint64_t v95 = 0LL;
      *a3 = v70;
      goto LABEL_80;
    }

LABEL_55:
    uint64_t v72 = 0LL;
    id v59 = 0LL;
LABEL_79:
    unint64_t v95 = 0LL;
    goto LABEL_80;
  }

  uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue([v5 objectForKeyedSubscript:@"ProtocolVersion"]);
  unsigned int v7 = [v6 intValue];

  uint64_t v8 = v503;
  if (v7) {
    goto LABEL_34;
  }
LABEL_8:
  id v18 = v8;
  float64x2_t v19 = (void *)objc_claimAutoreleasedReturnValue([v18 objectForKeyedSubscript:@"DYMTLShaderDebuggerFunctionIndex"]);
  id v20 = (char *)[v19 unsignedIntegerValue];

  id v21 = (void *)objc_claimAutoreleasedReturnValue([v18 objectForKeyedSubscript:@"DYMTLShaderDebuggerSubCommandIndex"]);
  id v522 = [v21 unsignedIntegerValue];

  if (v20)
  {
    uint64_t v22 = *a1;
    uint64_t v23 = *(void *)(*(void *)(*a1 + 120) + 24LL);
    uint64_t v24 = (void *)objc_claimAutoreleasedReturnValue([v18 objectForKeyedSubscript:@"DYMTLShaderDebuggerFunctionId"]);
    id v527 = (id)objc_claimAutoreleasedReturnValue([v18 objectForKeyedSubscript:@"DYMTLShaderDebuggerLibraryId"]);
    id v25 = (void *)objc_claimAutoreleasedReturnValue([v18 objectForKeyedSubscript:@"DYMTLShaderDebuggerLibraryType"]);
    v517 = v20 - 1;
    if ([v25 isEqualToString:@"Online"])
    {
      float32x2_t v26 = (unint64_t *)(v23 + ((void)v517 << 6));
      AliasStreauint64_t m = (uint64_t *)GetAliasStream( *(void *)(v22 + 24),  (uint64_t)[v527 unsignedLongLongValue],  *v26);
      if (AliasStream) {
        uint64_t v28 = *AliasStream;
      }
      else {
        uint64_t v28 = 0LL;
      }
      uint64_t Object = GTMTLSMContext_lastObject(**(void **)(v22 + 40), v28, *v26);
      if (!Object || *(_BYTE *)(Object + 161) != 2)
      {
        id v17 = 0LL;
LABEL_31:

        goto LABEL_32;
      }

      float v33 = StringFromArchive(*(void **)v22, a1[19], *(char **)(Object + 96));
      uint64_t v29 = (void *)objc_claimAutoreleasedReturnValue(v33);
      uint64_t v34 = (void *)objc_claimAutoreleasedReturnValue([v18 objectForKeyedSubscript:@"DYMTLShaderDebuggerInstrumentFunctions"]);
      uint64_t v35 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  v28));
      uint64_t v36 = (void *)objc_claimAutoreleasedReturnValue([v35 stringValue]);
      unsigned int v37 = (void *)objc_claimAutoreleasedReturnValue([v34 objectForKeyedSubscript:v36]);

      uint64_t v38 = objc_alloc_init(&OBJC_CLASS___NSMutableDictionary);
      -[NSMutableDictionary setObject:forKeyedSubscript:](v38, "setObject:forKeyedSubscript:", v29, @"Code");
      if ([v37 count]) {
        -[NSMutableDictionary setObject:forKeyedSubscript:]( v38,  "setObject:forKeyedSubscript:",  v37,  @"SelectFunctions");
      }
      id v555 = v527;
      id v39 = -[NSMutableDictionary copy](v38, "copy");
      id v556 = v39;
      unsigned int v30 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v556,  &v555,  1LL));

      uint64_t v31 = @"SourceLibs";
    }

    else
    {
      uint64_t v29 = (void *)objc_claimAutoreleasedReturnValue([v18 objectForKeyedSubscript:@"DYMTLShaderDebuggerInstrumentedMetallib"]);
      id v555 = v527;
      id v556 = v29;
      unsigned int v30 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v556,  &v555,  1LL));
      uint64_t v31 = @"MetalLibs";
    }

    v552 = v24;
    v553[0] = (id)v31;
    v553[1] = @"FunctionUIDs";
    v554[0] = v30;
    BOOL v40 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", &v552, 1LL));
    v554[1] = v40;
    uint64_t v513 = objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v554,  v553,  2LL));

    uint64_t v41 = (void *)objc_claimAutoreleasedReturnValue([v18 objectForKeyedSubscript:@"DYMTLShaderDebuggerTraceBufferSize"]);
    id v42 = [v41 unsignedIntegerValue];

    unint64_t v43 = (void *)objc_claimAutoreleasedReturnValue([v18 objectForKeyedSubscript:@"DYMTLShaderDebuggerPipelineCreationTimeout"]);
    id v44 = [v43 unsignedIntegerValue];

    v551[0] = @"TraceBufferSize";
    uint64_t v45 = (void **)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInteger:](&OBJC_CLASS___NSNumber, "numberWithUnsignedInteger:", v42));
    v566 = v45;
    v551[1] = @"PSOCompileTimeout";
    unint64_t v46 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInteger:](&OBJC_CLASS___NSNumber, "numberWithUnsignedInteger:", v44));
    v551[2] = @"SkipMetadataGen";
    uint64_t v567 = (uint64_t)v46;
    v568 = (uint64_t (*)(uint64_t, void *, void *))&__kCFBooleanFalse;
    id v527 = (id)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v566,  v551,  3LL));

    id v25 = (void *)objc_claimAutoreleasedReturnValue([v18 objectForKeyedSubscript:@"DYMTLShaderDebuggerROIType"]);
    switch((unint64_t)[v25 unsignedIntegerValue])
    {
      case 0uLL:
        uint64_t v47 = (void *)objc_claimAutoreleasedReturnValue([v18 objectForKeyedSubscript:@"DYMTLShaderDebuggerROIMinPositionX"]);
        uint64_t v48 = (void *)objc_claimAutoreleasedReturnValue([v18 objectForKeyedSubscript:@"DYMTLShaderDebuggerROIMinPositionY"]);
        uint64_t v49 = (void *)objc_claimAutoreleasedReturnValue([v18 objectForKeyedSubscript:@"DYMTLShaderDebuggerROIMinPositionZ"]);
        v504 = (void *)objc_claimAutoreleasedReturnValue([v18 objectForKeyedSubscript:@"DYMTLShaderDebuggerROIMaxPositionX"]);
        uint64_t v50 = (void *)objc_claimAutoreleasedReturnValue([v18 objectForKeyedSubscript:@"DYMTLShaderDebuggerROIMaxPositionY"]);
        unint64_t v51 = (void *)objc_claimAutoreleasedReturnValue([v18 objectForKeyedSubscript:@"DYMTLShaderDebuggerROIMaxPositionZ"]);
        *(void *)&__int128 v558 = @"Type";
        *((void *)&v558 + 1) = @"MinPositionX";
        *(void *)__dst = &off_5A0BC8;
        *(void *)&__dst[8] = v47;
        *(void *)&__int128 v559 = @"MinPositionY";
        *((void *)&v559 + 1) = @"MinPositionZ";
        *(void *)&__dst[16] = v48;
        *(void *)&__dst[24] = v49;
        *(void *)&__int128 v560 = @"MaxPositionX";
        *((void *)&v560 + 1) = @"MaxPositionY";
        *(void *)&__dst[32] = v504;
        *(void *)&__dst[40] = v50;
        *(void *)&__int128 v561 = @"MaxPositionZ";
        *(void *)&__dst[48] = v51;
        uint64_t v52 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  __dst,  &v558,  7LL));
        goto LABEL_24;
      case 1uLL:
        uint64_t v47 = (void *)objc_claimAutoreleasedReturnValue([v18 objectForKeyedSubscript:@"DYMTLShaderDebuggerROIInstanceId"]);
        uint64_t v48 = (void *)objc_claimAutoreleasedReturnValue([v18 objectForKeyedSubscript:@"DYMTLShaderDebuggerROIAmplificationId"]);
        uint64_t v49 = (void *)objc_claimAutoreleasedReturnValue([v18 objectForKeyedSubscript:@"DYMTLShaderDebuggerROIVertexIds"]);
        *(void *)&__int128 v558 = @"Type";
        *((void *)&v558 + 1) = @"InstanceID";
        *(void *)__dst = &off_5A0B98;
        *(void *)&__dst[8] = v47;
        *(void *)&__int128 v559 = @"AmplificationID";
        *((void *)&v559 + 1) = @"VertexIDs";
        *(void *)&__dst[16] = v48;
        *(void *)&__dst[24] = v49;
        uint64_t v54 = objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  __dst,  &v558,  4LL));
        goto LABEL_27;
      case 2uLL:
        uint64_t v47 = (void *)objc_claimAutoreleasedReturnValue([v18 objectForKeyedSubscript:@"DYMTLShaderDebuggerROIMinPositionX"]);
        uint64_t v48 = (void *)objc_claimAutoreleasedReturnValue([v18 objectForKeyedSubscript:@"DYMTLShaderDebuggerROIMinPositionY"]);
        uint64_t v49 = (void *)objc_claimAutoreleasedReturnValue([v18 objectForKeyedSubscript:@"DYMTLShaderDebuggerROIMaxPositionX"]);
        v504 = (void *)objc_claimAutoreleasedReturnValue([v18 objectForKeyedSubscript:@"DYMTLShaderDebuggerROIMaxPositionY"]);
        uint64_t v50 = (void *)objc_claimAutoreleasedReturnValue([v18 objectForKeyedSubscript:@"DYMTLShaderDebuggerROIMinSampleId"]);
        unint64_t v51 = (void *)objc_claimAutoreleasedReturnValue([v18 objectForKeyedSubscript:@"DYMTLShaderDebuggerROIMaxSampleId"]);
        uint64_t v53 = (void *)objc_claimAutoreleasedReturnValue( [v18 objectForKeyedSubscript:@"DYMTLShaderDebuggerROIRenderTargetArrayIndex"]);
        *(void *)&__int128 v558 = @"Type";
        *((void *)&v558 + 1) = @"MinPositionX";
        *(void *)__dst = &off_5A0BB0;
        *(void *)&__dst[8] = v47;
        *(void *)&__int128 v559 = @"MinPositionY";
        *((void *)&v559 + 1) = @"MaxPositionX";
        *(void *)&__dst[16] = v48;
        *(void *)&__dst[24] = v49;
        *(void *)&__int128 v560 = @"MaxPositionY";
        *((void *)&v560 + 1) = @"MinSampleID";
        *(void *)&__dst[32] = v504;
        *(void *)&__dst[40] = v50;
        *(void *)&__int128 v561 = @"MaxSampleID";
        *((void *)&v561 + 1) = @"RenderTargetArrayIndex";
        *(void *)&__dst[48] = v51;
        *(void *)&__dst[56] = v53;
        uint64_t v52 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  __dst,  &v558,  8LL));

LABEL_24:
        goto LABEL_28;
      case 3uLL:
        uint64_t v47 = (void *)objc_claimAutoreleasedReturnValue([v18 objectForKeyedSubscript:@"DYMTLShaderDebuggerROIInstanceId"]);
        uint64_t v48 = (void *)objc_claimAutoreleasedReturnValue([v18 objectForKeyedSubscript:@"DYMTLShaderDebuggerROIAmplificationId"]);
        uint64_t v49 = (void *)objc_claimAutoreleasedReturnValue([v18 objectForKeyedSubscript:@"DYMTLShaderDebuggerROIPatchIds"]);
        *(void *)&__int128 v558 = @"Type";
        *((void *)&v558 + 1) = @"InstanceID";
        *(void *)__dst = &off_5A0BE0;
        *(void *)&__dst[8] = v47;
        *(void *)&__int128 v559 = @"AmplificationID";
        *((void *)&v559 + 1) = @"PatchIDs";
        *(void *)&__dst[16] = v48;
        *(void *)&__dst[24] = v49;
        uint64_t v54 = objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  __dst,  &v558,  4LL));
LABEL_27:
        uint64_t v52 = (void *)v54;
LABEL_28:

        *(void *)&__int128 v571 = &off_5A0BB0;
        *(void *)&__int128 v562 = @"ProtocolVersion";
        *((void *)&v562 + 1) = @"FunctionIndex";
        unsigned int v55 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedInteger:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedInteger:",  v517));
        *((void *)&v571 + 1) = v55;
        *(void *)&__int128 v563 = @"SubCommandIndex";
        id v56 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedInteger:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedInteger:",  v522));
        *(void *)&__int128 v572 = v56;
        *((void *)&v572 + 1) = v513;
        *((void *)&v563 + 1) = @"Program";
        *(void *)&__int128 v564 = @"ROI";
        *((void *)&v564 + 1) = @"Options";
        *(void *)&__int128 v573 = v52;
        *((void *)&v573 + 1) = v527;
        id v17 = (id)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v571,  &v562,  6LL));

        break;
      default:
        GTMTLReplay_handleError( 101,  (uint64_t)"Unknown region of interest type",  "/Library/Caches/com.apple.xbs/Sources/GPUToolsDevice/GPUTools/GTMTLCapture/replayer/GTMTLReplay_shaderDebugger_internal.m",  (uint64_t)"_UpgradeRequest_to_StarSkyE_from_StarSky",  759LL,  4LL);
        id v17 = 0LL;
        break;
    }

    uint64_t v24 = (void *)v513;
    goto LABEL_31;
  }

  id v17 = 0LL;
LABEL_32:

  while (1)
  {
    id v57 = v17;

    __int128 v58 = (void *)objc_claimAutoreleasedReturnValue([v57 objectForKeyedSubscript:@"ProtocolVersion"]);
    unsigned int v7 = [v58 intValue];

    uint64_t v8 = v57;
    if (!v7) {
      goto LABEL_8;
    }
LABEL_34:
    if (v7 != 2) {
      break;
    }
    id v9 = v8;
    uint64_t v10 = (void *)objc_claimAutoreleasedReturnValue([v9 objectForKeyedSubscript:@"Program"]);
    id v11 = [v10 mutableCopy];

    uint64_t v12 = (void *)objc_claimAutoreleasedReturnValue([v11 objectForKeyedSubscript:@"UseGlobalRelocation"]);
    else {
      uint64_t v13 = 0LL;
    }
    uint64_t v14 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInt:](&OBJC_CLASS___NSNumber, "numberWithUnsignedInt:", v13));
    [v11 setObject:v14 forKeyedSubscript:@"TraceBufferBindingType"];

    id v15 = [v9 mutableCopy];
    id v16 = [v11 copy];
    [v15 setObject:v16 forKeyedSubscript:@"Program"];

    [v15 setObject:&off_5A0BC8 forKeyedSubscript:@"ProtocolVersion"];
    id v17 = [v15 copy];
  }

  if (v7 != 3)
  {
    while (1)
      ;
  }

  if (!v8)
  {
    if (a3)
    {
      id v71 = GTShaderDebuggerMakeError(1u, @"Internal error: Unexpected request: Upgrade failure", 0LL, 0LL, 0LL);
      id v70 = (id)objc_claimAutoreleasedReturnValue(v71);
      goto LABEL_54;
    }

    goto LABEL_55;
  }

  id v59 = v8;
  __int128 v571 = 0u;
  __int128 v572 = 0u;
  __int128 v573 = 0u;
  __int128 v574 = 0u;
  id v60 = [&off_59FAD0 countByEnumeratingWithState:&v571 objects:__dst count:16];
  if (v60)
  {
    uint64_t v61 = *(void *)v572;
    while (2)
    {
      for (uint64_t i = 0LL; i != v60; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v572 != v61) {
          objc_enumerationMutation(&off_59FAD0);
        }
        uint64_t v63 = (void *)objc_claimAutoreleasedReturnValue( [v59 objectForKeyedSubscript:*(void *)(*((void *)&v571 + 1) + 8 * (void)i)]);
        BOOL v64 = v63 == 0LL;

        if (v64)
        {

          goto LABEL_75;
        }
      }

      id v60 = [&off_59FAD0 countByEnumeratingWithState:&v571 objects:__dst count:16];
      if (v60) {
        continue;
      }
      break;
    }
  }

  double v65 = (void *)objc_claimAutoreleasedReturnValue([v59 objectForKeyedSubscript:@"Program"]);
  double v66 = (void *)objc_claimAutoreleasedReturnValue([v65 objectForKeyedSubscript:@"FunctionUIDs"]);
  BOOL v67 = v66 == 0LL;

  if (v67) {
    goto LABEL_74;
  }
  double v68 = (void *)objc_claimAutoreleasedReturnValue([v65 objectForKeyedSubscript:@"MetalLibs"]);
  if (!v68)
  {
    double v73 = (void *)objc_claimAutoreleasedReturnValue([v65 objectForKeyedSubscript:@"SourceLibs"]);
    BOOL v74 = v73 == 0LL;

    if (!v74) {
      goto LABEL_57;
    }
LABEL_74:

    goto LABEL_75;
  }

LABEL_57:
  double v75 = (void *)objc_claimAutoreleasedReturnValue([v59 objectForKeyedSubscript:@"ROI"]);
  double v76 = (void *)objc_claimAutoreleasedReturnValue([v75 objectForKeyedSubscript:@"Type"]);
  double v77 = v76;
  if (!v76 || (unint64_t v78 = (unint64_t)[v76 unsignedIntegerValue] - 1, v78 > 5))
  {
LABEL_73:

LABEL_75:
    if (a3)
    {
      id v94 = GTShaderDebuggerMakeError(1u, @"Internal error: Invalid request", 0LL, 0LL, 0LL);
      id v70 = (id)objc_claimAutoreleasedReturnValue(v94);
      uint64_t v72 = 0LL;
      goto LABEL_77;
    }

    uint64_t v72 = 0LL;
    goto LABEL_79;
  }

  BOOL v79 = off_58F930[v78];
  __int128 v565 = 0u;
  __int128 v564 = 0u;
  __int128 v563 = 0u;
  __int128 v562 = 0u;
  id v80 = [v79 countByEnumeratingWithState:&v562 objects:&v558 count:16];
  if (v80)
  {
    uint64_t v81 = *(void *)v563;
LABEL_61:
    uint64_t v82 = 0LL;
    while (1)
    {
      if (*(void *)v563 != v81) {
        objc_enumerationMutation(v79);
      }
      uint64_t v83 = (void *)objc_claimAutoreleasedReturnValue([v75 objectForKeyedSubscript:*(void *)(*((void *)&v562 + 1) + 8 * v82)]);
      BOOL v84 = v83 == 0LL;

      if (v84) {
        goto LABEL_73;
      }
      if (v80 == (id)++v82)
      {
        id v80 = [v79 countByEnumeratingWithState:&v562 objects:&v558 count:16];
        if (v80) {
          goto LABEL_61;
        }
        break;
      }
    }
  }

  unsigned int v85 = (void *)objc_claimAutoreleasedReturnValue([v59 objectForKeyedSubscript:@"Options"]);
  int v86 = (void *)objc_claimAutoreleasedReturnValue([v85 objectForKeyedSubscript:@"SkipMetadataGen"]);

  unsigned int v87 = [v86 BOOLValue];
  __int128 v88 = (void *)objc_claimAutoreleasedReturnValue([v59 objectForKeyedSubscript:@"Options"]);
  __int128 v89 = (void *)objc_claimAutoreleasedReturnValue([v88 objectForKeyedSubscript:@"SaveTempsDir"]);

  if ([v89 length]) {
    uint64_t v90 = v87 ^ 1 | 8LL;
  }
  else {
    uint64_t v90 = v87 ^ 1;
  }
  BOOL v91 = (void *)objc_claimAutoreleasedReturnValue([v59 objectForKeyedSubscript:@"Program"]);
  uint64_t v92 = (void *)objc_claimAutoreleasedReturnValue([v91 objectForKeyedSubscript:@"TraceBufferBindingType"]);

  unsigned int v93 = [v92 integerValue];
  if (v93 == 2)
  {
    v90 |= 4uLL;
  }

  else if (v93 == 1)
  {
    v90 |= 2uLL;
  }

  id v172 = (void *)objc_claimAutoreleasedReturnValue([(id)a1[1] defaultDevice]);
  unsigned int v173 = [v172 supportsFamily:1001];

  if (v173) {
    uint64_t v72 = v90;
  }
  else {
    uint64_t v72 = v90 | 0x10;
  }
  id v59 = v59;
  unint64_t v95 = v59;
LABEL_80:

  if (!v95)
  {
LABEL_138:

    goto LABEL_139;
  }

  uint64_t v96 = (void *)objc_claimAutoreleasedReturnValue([v95 objectForKeyedSubscript:@"FunctionIndex"]);
  unsigned int v97 = [v96 unsignedIntValue];

  uint64_t v98 = *(void *)(*(void *)(*a1 + 120) + 24LL);
  if ((v72 & 1) != 0)
  {
    if (_IsLLVMDylibLoaded_onceToken != -1) {
      dispatch_once(&_IsLLVMDylibLoaded_onceToken, &__block_literal_global_6817);
    }
    if ((_IsLLVMDylibLoaded_llvmLoaded & 1) == 0)
    {
      unsigned __int8 v104 = (void *)objc_claimAutoreleasedReturnValue(+[NSBundle mainBundle](&OBJC_CLASS___NSBundle, "mainBundle"));
      id v102 = (void *)objc_claimAutoreleasedReturnValue([v104 infoDictionary]);

      uint64_t v105 = (void *)objc_claimAutoreleasedReturnValue([v102 objectForKeyedSubscript:@"DTPlatformName"]);
      uint64_t v106 = (void *)objc_claimAutoreleasedReturnValue([v102 objectForKeyedSubscript:@"DTPlatformVersion"]);
      if ([v105 length] && objc_msgSend(v106, "length"))
      {
        uint64_t v107 = (void *)objc_claimAutoreleasedReturnValue([&off_5A0308 objectForKeyedSubscript:v105]);
        id v108 = v107;
        if (v107)
        {
          id v109 = (void *)objc_claimAutoreleasedReturnValue([v107 stringByAppendingString:v106]);
          uint64_t v110 = (__CFString *)objc_claimAutoreleasedReturnValue([v109 stringByAppendingString:@" or later"]);
        }

        else
        {
          uint64_t v110 = 0LL;
        }
      }

      else
      {
        uint64_t v110 = 0LL;
      }

      if (v110) {
        uint64_t v157 = v110;
      }
      else {
        uint64_t v157 = @"the latest version available";
      }
      unint64_t v158 = (void *)objc_claimAutoreleasedReturnValue([@"Please update your target OS to " stringByAppendingString:v157]);
      if (a3)
      {
        id v159 = GTShaderDebuggerMakeError( 4u,  @"Debugging information not available from the target OS",  v158,  0LL,  0LL);
        *a3 = (id)objc_claimAutoreleasedReturnValue(v159);
      }

      goto LABEL_137;
    }
  }

  if ((v72 & 4) == 0) {
    goto LABEL_86;
  }
  id v102 = (void *)objc_claimAutoreleasedReturnValue([(id)a1[1] defaultDevice]);
  if ((objc_opt_respondsToSelector(v102, "supportsGlobalVariableRelocationCompute") & 1) != 0) {
    unsigned int v103 = [v102 supportsGlobalVariableRelocationCompute] ^ 1;
  }
  else {
    unsigned int v103 = 1;
  }
  if ((objc_opt_respondsToSelector(v102, "supportsGlobalVariableRelocationRender") & 1) != 0) {
    char v154 = [v102 supportsGlobalVariableRelocationRender] ^ 1;
  }
  else {
    char v154 = 1;
  }
  int v155 = *(_DWORD *)(v98 + ((unint64_t)v97 << 6) + 8);
  if ((v155 + 16079) >= 2 && v155 != -16327 && v155 != -16220)
  {
    if ((v154 & 1) == 0) {
      goto LABEL_156;
    }
LABEL_127:
    if (a3)
    {
      id v156 = GTShaderDebuggerMakeError( 4u,  @"The metal device does not support debugging shaders in pipelines created with multiple metal libraries",  0LL,  0LL,  0LL);
      *a3 = (id)objc_claimAutoreleasedReturnValue(v156);
    }

      v23[6] = v43;
      *(void *)&id v296 = &v303[1];
      std::vector<DebugInfo::BlockInfo>::__destroy_vector::operator()[abi:nn180100]((void ***)&v296);
      std::vector<-[GTShaderProfilerHelper _processPerLineCostDataForLineTable:withFileCost:withDebugInfo:andAllDrawCost:withKey:withShaderSourcePath:withDrawCost:]::SourceDisassemblyInfo>::~vector[abi:nn180100]((uint64_t *)v303);
      id v59 = *v19;
      id v60 = (uint64_t)(v23[6] - 3);
      __int128 v284 = v19;
      if (v60 != *v19 + 56)
      {
        std::vector<DebugInfo::BlockInfo>::__assign_with_size[abi:nn180100]<DebugInfo::BlockInfo*,DebugInfo::BlockInfo*>( v60,  *(void *)(v59 + 56),  *(void *)(v59 + 64),  0x4EC4EC4EC4EC4EC5LL * ((uint64_t)(*(void *)(v59 + 64) - *(void *)(v59 + 56)) >> 3));
        id v59 = *v19;
      }

      uint64_t v61 = *(void *)(v59 + 32);
      __streauint64_t m = *(FILE **)(v59 + 40);
      if ((FILE *)v61 != __stream)
      {
        id v62 = *(_DWORD *)(v59 + 24);
        while (1)
        {
          uint64_t v63 = *(void **)v61;
          if (*(void *)v61) {
            break;
          }
LABEL_79:
          ++v62;
          v61 += 40LL;
          if ((FILE *)v61 == __stream) {
            goto LABEL_84;
          }
        }

        BOOL v64 = v23[6];
        double v66 = *(v64 - 5);
        double v65 = *(v64 - 4);
        if (v66 < v65)
        {
          BOOL v67 = *(void **)(v61 + 8);
          double v68 = *(void *)(v61 + 16);
          double v69 = *(_DWORD *)(v61 + 24);
          id v70 = *(unsigned int *)(v61 + 36);
          id v71 = *(void *)(v61 + 28);
          *(void *)&uint64_t v72 = v71;
          *((void *)&v72 + 1) = HIDWORD(v71);
          double v73 = v63;
          BOOL v74 = v67;
          *(void *)double v66 = v73;
          *(void *)(v66 + _Block_object_dispose(&STACK[0x3B0], 8) = v74;
          *(_DWORD *)(v66 + 16) = v62;
          *(_DWORD *)(v66 + 20) = v69;
          *(void *)(v66 + 24) = v68;
          *(_OWORD *)(v66 + 32) = v72;
          double v75 = (char *)(v66 + 56);
          *(void *)(v66 + 4_Block_object_dispose(&STACK[0x3B0], 8) = v70;
LABEL_78:
          *(v64 - 5) = (uint64_t)v75;
          goto LABEL_79;
        }

        double v76 = *(v64 - 6);
        double v77 = 0x6DB6DB6DB6DB6DB7LL * ((uint64_t)(v66 - v76) >> 3);
        unint64_t v78 = v77 + 1;
        BOOL v79 = 0x6DB6DB6DB6DB6DB7LL * ((uint64_t)(v65 - v76) >> 3);
        if (2 * v79 > v78) {
          unint64_t v78 = 2 * v79;
        }
        if (v79 >= 0x249249249249249LL) {
          id v80 = 0x492492492492492LL;
        }
        else {
          id v80 = v78;
        }
        if (v80)
        {
          uint64_t v81 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<-[GTShaderProfilerHelper _processPerLineCostDataForLineTable:withFileCost:withDebugInfo:andAllDrawCost:withKey:withShaderSourcePath:withDrawCost:]::SourceDisassemblyInfo>>(v80);
          __int128 v288 = v82;
          uint64_t v63 = *(void **)v61;
        }

        else
        {
          uint64_t v81 = 0LL;
          __int128 v288 = 0LL;
        }

        uint64_t v83 = &v81[56 * v77];
        BOOL v84 = *(void **)(v61 + 8);
        unsigned int v85 = *(void *)(v61 + 16);
        int v86 = *(_DWORD *)(v61 + 24);
        unsigned int v87 = *(unsigned int *)(v61 + 36);
        __int128 v88 = *(void *)(v61 + 28);
        *(void *)&__int128 v89 = v88;
        *((void *)&v89 + 1) = HIDWORD(v88);
        uint64_t v90 = v63;
        BOOL v91 = v84;
        *(void *)uint64_t v83 = v90;
        *((void *)v83 + 1) = v91;
        *((_DWORD *)v83 + 4) = v62;
        *((_DWORD *)v83 + 5) = v86;
        *((void *)v83 + 3) = v85;
        *((_OWORD *)v83 + 2) = v89;
        *((void *)v83 + 6) = v87;
        uint64_t v92 = (id *)*(v64 - 6);
        unsigned int v93 = (id *)*(v64 - 5);
        if (v93 == v92)
        {
          double v75 = v83 + 56;
          *(v64 - 6) = (uint64_t)v83;
          *(v64 - 5) = (uint64_t)(v83 + 56);
          *(v64 - 4) = (uint64_t)&v81[56 * v288];
        }

        else
        {
          id v94 = v83;
          do
          {
            unint64_t v95 = *(_OWORD *)(v93 - 7);
            v93 -= 7;
            FILE *v93 = 0LL;
            v93[1] = 0LL;
            *(_OWORD *)(v94 - 56) = v95;
            v94 -= 56;
            uint64_t v96 = *((_OWORD *)v93 + 1);
            unsigned int v97 = *((_OWORD *)v93 + 2);
            *((void *)v94 + 6) = v93[6];
            *((_OWORD *)v94 + 1) = v96;
            *((_OWORD *)v94 + 2) = v97;
          }

          while (v93 != v92);
          unsigned int v93 = (id *)*(v64 - 6);
          uint64_t v98 = (id *)*(v64 - 5);
          double v75 = v83 + 56;
          *(v64 - 6) = (uint64_t)v94;
          *(v64 - 5) = (uint64_t)(v83 + 56);
          *(v64 - 4) = (uint64_t)&v81[56 * v288];
          if (v98 != v93)
          {
            do
            {

              uint64_t v99 = *(v98 - 7);
              v98 -= 7;
            }

            while (v98 != v93);
            if (!v93) {
              goto LABEL_78;
            }
LABEL_77:
            operator delete(v93);
            goto LABEL_78;
          }
        }

        if (!v93) {
          goto LABEL_78;
        }
        goto LABEL_77;
      }

          goto LABEL_68;
        }

            uint64_t v38 = v41;
            break;
        }
      }

      unint64_t v43 = *v34;
      if (*v34 == *v37)
      {
        BOOL v40 = 0;
      }

      else
      {
        BOOL v40 = 0;
        do
        {
          v40 += v43[1];
          v43 += 4;
        }

        while (v43 != *v37);
      }

      id v44 = *(void *)*TargetClauseAnalysis
          + 88LL * *(void *)(*(void *)(*TargetClauseAnalysis + 24LL) + 48LL * v31 + 8LL * v26[8]);
      uint64_t v45 = *(void *)(v5 + 8);
      if (v45)
      {
        unint64_t v46 = (uint8x8_t)vcnt_s8((int8x8_t)v45);
        v46.i16[0] = vaddlv_u8(v46);
        if (v46.u32[0] > 1uLL)
        {
          uint64_t v47 = v44;
          if (v45 <= v44) {
            uint64_t v47 = v44 % v45;
          }
        }

        else
        {
          uint64_t v47 = (v45 - 1) & v44;
        }

        uint64_t v48 = *(void ***)(*(void *)v5 + 8 * v47);
        if (v48)
        {
          uint64_t v49 = (float *)*v48;
          if (*v48)
          {
            do
            {
              uint64_t v50 = *((void *)v49 + 1);
              if (v50 == v44)
              {
                if (*((void *)v49 + 2) == v44) {
                  goto LABEL_119;
                }
              }

              else
              {
                if (v46.u32[0] > 1uLL)
                {
                  if (v50 >= v45) {
                    v50 %= v45;
                  }
                }

                else
                {
                  v50 &= v45 - 1;
                }

                if (v50 != v47) {
                  break;
                }
              }

              uint64_t v49 = *(float **)v49;
            }

            while (v49);
          }
        }

        id v172 = 0u;
        unsigned int v173 = 0u;
        uint64_t v174 = 1065353216;
        if (v46.u32[0] > 1uLL)
        {
          uint64_t v1 = v44;
          if (v45 <= v44) {
            uint64_t v1 = v44 % v45;
          }
        }

        else
        {
          uint64_t v1 = (v45 - 1) & v44;
        }

        unint64_t v51 = *(void ***)(*(void *)v5 + 8 * v1);
        if (v51)
        {
          uint64_t v49 = (float *)*v51;
          if (*v51)
          {
            do
            {
              uint64_t v52 = *((void *)v49 + 1);
              if (v52 == v44)
              {
                if (*((void *)v49 + 2) == v44)
                {
                  uint64_t v1 = v169;
                  goto LABEL_115;
                }
              }

              else
              {
                if (v46.u32[0] > 1uLL)
                {
                  if (v52 >= v45) {
                    v52 %= v45;
                  }
                }

                else
                {
                  v52 &= v45 - 1;
                }

                if (v52 != v1) {
                  break;
                }
              }

              uint64_t v49 = *(float **)v49;
            }

            while (v49);
          }
        }
      }

      else
      {
        id v172 = 0u;
        unsigned int v173 = 0u;
        uint64_t v174 = 1065353216;
      }

      uint64_t v49 = (float *)operator new(0x40uLL);
      v177[0] = v49;
      v177[1] = v160;
      *(void *)uint64_t v49 = 0LL;
      *((void *)v49 + 1) = v44;
      *((void *)v49 + 2) = v44;
      std::__hash_table<std::__hash_value_type<unsigned int,unsigned int>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,unsigned int>>>::__hash_table( (uint64_t)(v49 + 6),  (uint64_t *)&v172);
      uint64_t v178 = 1;
      uint64_t v53 = (float)(unint64_t)(*(void *)(v5 + 24) + 1LL);
      uint64_t v54 = *(float *)(v5 + 32);
      if (!v45 || (float)(v54 * (float)v45) < v53)
      {
        unsigned int v55 = (v45 & (v45 - 1)) != 0;
        if (v45 < 3) {
          unsigned int v55 = 1LL;
        }
        id v56 = v55 | (2 * v45);
        id v57 = vcvtps_u32_f32(v53 / v54);
        if (v56 <= v57) {
          __int128 v58 = v57;
        }
        else {
          __int128 v58 = v56;
        }
        std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__rehash<true>( v5,  v58);
        uint64_t v45 = *(void *)(v5 + 8);
        if ((v45 & (v45 - 1)) != 0)
        {
          if (v45 <= v44) {
            uint64_t v1 = v44 % v45;
          }
          else {
            uint64_t v1 = v44;
          }
        }

        else
        {
          uint64_t v1 = (v45 - 1) & v44;
        }
      }

      id v59 = *(void *)v5;
      id v60 = *(float ***)(*(void *)v5 + 8 * v1);
      if (v60) {
        break;
      }
      *(void *)uint64_t v49 = *v160;
      *id v160 = v49;
      *(void *)(v59 + 8 * std::__hash_node_destructor<std::allocator<std::__hash_node<std::string,void *>>>::operator()[abi:nn180100](0, v1) = v160;
      uint64_t v1 = v169;
      if (*(void *)v49)
      {
        uint64_t v61 = *(void *)(*(void *)v49 + 8LL);
        if ((v45 & (v45 - 1)) != 0)
        {
          if (v61 >= v45) {
            v61 %= v45;
          }
        }

        else
        {
          v61 &= v45 - 1;
        }

        id v60 = (float **)(*(void *)v5 + 8 * v61);
        goto LABEL_113;
      }

  unsigned int v4 = v74;
  id v5 = v64;
  id v56 = v65;
  uint64_t v6 = v72;
LABEL_57:
  v81[0] = @"blitEncoderIndices";
  v81[1] = @"perCommandBufferEncoderCount";
  v82[0] = v69;
  v82[1] = v4;
  v81[2] = @"perEncoderDrawCallCount";
  v81[3] = @"perEncoderIndexDrawCallCount";
  v82[2] = v5;
  v82[3] = v6;
  v82[4] = v75;
  v81[4] = @"perFrameCommandBufferCount";
  v81[5] = @"totalDrawCallCount";
  id v57 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInteger:](&OBJC_CLASS___NSNumber, "numberWithUnsignedInteger:", v56));
  v82[5] = v57;
  v82[6] = &off_5A08F8;
  v81[6] = @"uscSamplingPeriod";
  v81[7] = @"withoutBlitPerEncoderIndexDrawCallCount";
  v82[7] = v68;
  v82[8] = v71;
  v81[8] = @"activePerEncoderDrawCallCount";
  v81[9] = @"perEncoderKickCount";
  v82[9] = v70;
  v82[10] = v67;
  v81[10] = @"splitEncoderCommandCount";
  v81[11] = @"splitPerEncoderKickCount";
  v82[11] = v66;
  __int128 v58 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v82,  v81,  12LL));

  return v58;
}

    std::__hash_table<std::__hash_value_type<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>,std::__unordered_map_hasher<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::equal_to,std::hash,true>,std::allocator<objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>>::~__hash_table((uint64_t)&v63[48]);
    std::__hash_table<std::__hash_value_type<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>,std::__unordered_map_hasher<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::equal_to,std::hash,true>,std::allocator<objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>>::~__hash_table((uint64_t)&v63[8]);

LABEL_56:
    goto LABEL_57;
  }

  *(void *)uint64_t v63 = v18;
  float32x2_t v26 = (void *)objc_claimAutoreleasedReturnValue([a2->var1 computeCommandEncoderForKey:a2->var21.var0.var2]);
  if (!v26
    || (id v27 = GTMTLSMContext_getObject(*(void *)a2->var0->var5, a2->var21.var3.var0.var1[0], *(void *)a3)) == 0LL
    || (uint64_t v28 = v27,
        uint64_t v29 = ObtainTracingComputePipelineState( (uint64_t *)a2->var0->var5,  a2->var1,  (uint64_t)v27,  a4,  *(void *)a3,  a6),  (v30 = objc_claimAutoreleasedReturnValue(v29)) == 0))
  {
LABEL_25:

LABEL_57:
    id v18 = *(void **)v63;
    goto LABEL_58;
  }

  id v59 = (void *)v30;
  ReplaceFunctionTablesWithInstrumented((uint64_t)&v63[8], (uint64_t)a2, a4, *(void *)a3, v28, (uint64_t *)&v66, a6);
  uint64_t v31 = std::unordered_map<unsigned long long,-[GTShaderProfilerHelper _calculatePerSampleActiveShaders:withShaderProfilerResult:forWorkloadInfo:]::EncoderRangeInfo>::find[abi:nn180100]( *(void *)a4,  *(void *)(a4 + 8),  v28[1]);
  if (!v31)
  {
    std::__hash_table<std::__hash_value_type<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>,std::__unordered_map_hasher<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::equal_to,std::hash,true>,std::allocator<objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>>::~__hash_table((uint64_t)&v63[48]);
    std::__hash_table<std::__hash_value_type<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>,std::__unordered_map_hasher<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::equal_to,std::hash,true>,std::allocator<objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>>::~__hash_table((uint64_t)&v63[8]);

    goto LABEL_25;
  }

  [v26 setBuffer:*(void *)(a4 + 240) offset:0 atIndex:*((unsigned int *)v31 + 6)];
LABEL_19:
  [v26 setComputePipelineState:v59];
  [v26 useResource:*(void *)(a4 + 240) usage:3];
  updated = UpdateFunctionTables<31ul,1ul>( 8u,  v26,  (uint64_t)&a2->var21.var3.var0.var3.var0.var0[1],  (uint64_t)a2->var21.var3.var0.var2,  var5,  *(void *)a3,  &v63[8]);
  std::__hash_table<std::__hash_value_type<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>,std::__unordered_map_hasher<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::equal_to,std::hash,true>,std::allocator<objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>>::~__hash_table((uint64_t)&v63[48]);
  std::__hash_table<std::__hash_value_type<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>,std::__unordered_map_hasher<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::equal_to,std::hash,true>,std::allocator<objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>>::~__hash_table((uint64_t)&v63[8]);

  id v18 = *(void **)v63;
  if ((updated & 1) == 0) {
    goto LABEL_58;
  }
LABEL_40:

  RemapIndirectResources((uint64_t)&v63[8], a5, a2->var1, a6);
  double v69 = *(_OWORD *)&v63[56];
  id v70 = v64;
  id v71 = v65;
  double v66 = *(_OWORD *)&v63[8];
  BOOL v67 = *(_OWORD *)&v63[24];
  double v68 = *(_OWORD *)&v63[40];
  PopulateResourceTrackingBufferV2( *(void **)(a4 + 240),  &v66,  v35,  v36,  v37,  v38,  v39,  v40,  v55,  (uint64_t)v57,  (uint64_t)v59,  (uint64_t)var5,  *(__int128 *)v63,  *(__int128 *)&v63[16],  *(__int128 *)&v63[32],  *(__int128 *)&v63[48]);
  GTMTLReplayController_defaultDispatchFunction((uint64_t)a2, a3);
  FlushCommandQueue(a2);
  if (!IsTraceBufferValidV2(*(void **)(a4 + 240)))
  {
LABEL_60:
    *(void *)(a1 + _Block_object_dispose(&STACK[0x3B0], 8) = 0LL;
    *(void *)(a1 + 16) = 0LL;
    *(void *)(a1 + 24) = 0LL;
    *(_BYTE *)a1 = 0;
    goto LABEL_61;
  }

  DecodeResourceTrackingBufferV2( (unint64_t *)&v63[8],  *(void **)(a4 + 240),  &v66,  v41,  v42,  v43,  v44,  v45,  v56,  v58,  v60,  v62,  *(__int128 *)v63,  *(__int128 *)&v63[16],  *(__int128 *)&v63[32],  *(__int128 *)&v63[48]);
  unint64_t v46 = *(void **)&v63[8];
  uint64_t v47 = *(void *)&v63[16] - *(void *)&v63[8];
  if (*(void *)&v63[16] == *(void *)&v63[8])
  {
    uint64_t v48 = 0LL;
    uint64_t v50 = 0LL;
    unint64_t v51 = 0LL;
  }

  else
  {
    if (0xAAAAAAAAAAAAAAABLL * (v47 >> 3) >= 0xAAAAAAAAAAAAAABLL) {
      abort();
    }
    uint64_t v48 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<std::vector<NSObject  {objcproto21OS_dispatch_semaphore}* {__strong}>>>(0xAAAAAAAAAAAAAAABLL * (v47 >> 3));
    uint64_t v50 = &v48[24 * v49];
    memmove(v48, v46, v47);
    unint64_t v51 = &v48[8 * (v47 >> 3)];
  }

  *(_BYTE *)a1 = 1;
  *(void *)(a1 + _Block_object_dispose(&STACK[0x3B0], 8) = v48;
  *(void *)(a1 + 16) = v51;
  *(void *)(a1 + 24) = v50;
  if (v46) {
    operator delete(v46);
  }
LABEL_61:
}

  if (v10 >= 7)
  {
    id v60 = *v45;
    HIWORD(__dst[100]) = *v45;
    if (v10 < 0xD)
    {
      BOOL v67 = 0;
      double v66 = 0;
      double v65 = 0;
      BOOL v64 = 0;
      uint64_t v63 = 0;
      id v62 = 0;
      uint64_t v61 = 0;
    }

    else
    {
      uint64_t v61 = v45[4];
      WORD2(__dst[100]) = v45[4];
      id v62 = *((_DWORD *)v45 + 4);
      LODWORD(__dst[100]) = v62;
      uint64_t v63 = v45[12];
      HIWORD(__dst[101]) = v45[12];
      BOOL v64 = v45[16];
      WORD2(__dst[101]) = v45[16];
      double v65 = v45[20];
      WORD1(__dst[101]) = v45[20];
      double v66 = v45[24];
      LOWORD(__dst[101]) = v45[24];
      BOOL v67 = *((unsigned __int8 *)v45 + 56);
      LOBYTE(__dst[102]) = *((_BYTE *)v45 + 56);
      if (v10 != 13)
      {
        double v68 = *((void *)v45 + 8);
        double v69 = v45 + 36;
        id v70 = *(_DWORD **)(a3 + 408);
        __dst[95] = v70;
        __dst[96] = (int)v68;
        if (v68 << 32)
        {
          id v71 = 2LL * (int)v68;
          if (v71 <= 1) {
            id v71 = 1LL;
          }
          uint64_t v72 = v70;
          do
          {
            if (v8) {
              *uint64_t v72 = *(_DWORD *)v69;
            }
            v69 += 4;
            ++v72;
            --v71;
          }

          while (v71);
        }

        *(void *)(a3 + 40_Block_object_dispose(&STACK[0x3B0], 8) = &v70[2 * (_DWORD)v68];
        if (v10 >= 0x14)
        {
          BYTE4(__dst[94]) = *(void *)v69;
          if (v10 >= 0x18)
          {
            BYTE2(__dst[102]) = *((void *)v69 + 1);
            if (v10 >= 0x21)
            {
              __dst[98] = *((void *)v69 + 2);
              if (v10 >= 0x27)
              {
                BYTE1(__dst[102]) = *((void *)v69 + 3);
                if (v10 >= 0x2A)
                {
                  __dst[97] = *((void *)v69 + 4);
                  BYTE3(__dst[102]) = *((void *)v69 + 5);
                  if (v10 >= 0x32)
                  {
                    unint64_t v95 = v66;
                    uint64_t v99 = v67;
                    for (uint64_t i = (uint64_t *)(v69 + 44); ; i += 6)
                    {
                      BOOL v74 = *(i - 5);
                      if (v74 == -1) {
                        break;
                      }
                      if (v8)
                      {
                        double v75 = *(i - 4);
                        double v76 = *(i - 3);
                        unint64_t v78 = *(i - 2);
                        double v77 = *(i - 1);
                        BOOL v79 = *i;
                        if (result)
                        {
                          unsigned int v103 = *(i - 1);
                          uint64_t v107 = *(i - 3);
                          id v80 = (uint64_t *)GetAliasStream2((uint64_t)result, v75);
                          if (v80) {
                            double v75 = *v80;
                          }
                          else {
                            double v75 = 0LL;
                          }
                          __n128 result = (void *)v108;
                          uint64_t v10 = v88;
                          uint64_t v8 = v89;
                          double v76 = v107;
                          double v77 = v103;
                        }

                        uint64_t v81 = &__dst[5 * v74 + 64];
                        *uint64_t v81 = v79;
                        v81[1] = v78;
                        v81[2] = v75;
                        v81[3] = v77;
                        v81[4] = v76;
                      }
                    }

                    double v66 = v95;
                    BOOL v67 = v99;
                    if (v10 >= 0x43) {
                      BYTE4(__dst[102]) = *(i - 4);
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

    if (v60 == 0xFFFF) {
      HIWORD(__dst[100]) = 0;
    }
    if (v61 == 0xFFFF) {
      WORD2(__dst[100]) = 0;
    }
    if (v62 == -1) {
      LODWORD(__dst[100]) = 0;
    }
    if (v63 == 0xFFFF) {
      HIWORD(__dst[101]) = 0;
    }
    if (v64 == 0xFFFF) {
      WORD2(__dst[101]) = 0;
    }
    if (v65 == 0xFFFF) {
      WORD1(__dst[101]) = 0;
    }
    if (v66 == 0xFFFF) {
      LOWORD(__dst[101]) = 0;
    }
    if (v67 == 255) {
      LOBYTE(__dst[102]) = 0;
    }
  }

  uint64_t v82 = *(char **)(a3 + 240);
  *(void *)(a3 + 240) = v82 + 824;
  if (v8)
  {
    if (!result)
    {
      unsigned int v85 = &__dst[98];
      goto LABEL_105;
    }

    uint64_t v83 = (uint64_t *)GetAliasStream2((uint64_t)result, __dst[99]);
    if (v83) {
      BOOL v84 = *v83;
    }
    else {
      BOOL v84 = 0LL;
    }
    __dst[99] = v84;
    unsigned int v85 = (uint64_t *)GetAliasStream2(v108, __dst[98]);
    if (v85) {
LABEL_105:
    }
      int v86 = *v85;
    else {
      int v86 = 0LL;
    }
    __dst[98] = v86;
    return memcpy(v82, __dst, 0x338uLL);
  }

  return result;
}

LABEL_137:
    goto LABEL_138;
  }

  if (v103) {
    goto LABEL_127;
  }
LABEL_156:

LABEL_86:
  uint64_t v99 = (void *)objc_claimAutoreleasedReturnValue([v503 objectForKeyedSubscript:@"Options"]);
  int v100 = (void *)objc_claimAutoreleasedReturnValue([v99 objectForKeyedSubscript:@"SaveTempsDir"]);

  if ([v100 length])
  {
    id v101 = v100;
  }

  else
  {
    uint64_t v111 = NSTemporaryDirectory();
    id v101 = (id)objc_claimAutoreleasedReturnValue(v111);
  }

  id v112 = v101;
  id v113 = (void *)objc_claimAutoreleasedReturnValue([v101 stringByAppendingPathComponent:@"GTMTLReplay_ShaderDebugger"]);
  id v114 = (void *)objc_claimAutoreleasedReturnValue(+[NSFileManager defaultManager](&OBJC_CLASS___NSFileManager, "defaultManager"));
  id v550 = 0LL;
  unsigned __int8 v115 = [v114 createDirectoryAtPath:v113 withIntermediateDirectories:1 attributes:0 error:&v550];
  id v116 = v550;

  if ((v115 & 1) != 0)
  {
    v531 = (unsigned int *)a1;
    objc_storeStrong((id *)&v546 + 1, v95);
    objc_storeStrong(&v547, v113);
    unint64_t v548 = v72;
  }

  else if (a3)
  {
    id v117 = GTShaderDebuggerMakeError(1u, @"Internal error", 0LL, v116, 0LL);
    *a3 = (id)objc_claimAutoreleasedReturnValue(v117);
  }

  if ((v115 & 1) == 0) {
    goto LABEL_139;
  }
  id v118 = (void *)objc_claimAutoreleasedReturnValue([*((id *)&v546 + 1) objectForKeyedSubscript:@"FunctionIndex"]);
  unsigned int v119 = [v118 unsignedIntValue];

  uint64_t v120 = (void *)objc_claimAutoreleasedReturnValue([*((id *)&v546 + 1) objectForKeyedSubscript:@"SubCommandIndex"]);
  int v121 = [v120 unsignedIntValue];

  unint64_t v122 = v531;
  unsigned int v123 = v119 + 1;
  GTMTLReplayController_debugSubCommandResume(v531, v123, v121);
  unsigned int v124 = v531[2828];
  if (v124 != 28 && v124 != 70)
  {
    unsigned int v142 = v124 - 1;
    if (v142 > 0x55) {
      unint64_t v143 = "Unknown";
    }
    else {
      unint64_t v143 = (&off_5901A8)[v142];
    }
    char v162 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", v143));
    uint64_t v163 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"Unsupported encoder: %@",  v162));

    if (a3)
    {
      id v164 = GTShaderDebuggerMakeError(4u, v163, 0LL, 0LL, 0LL);
      *a3 = (id)objc_claimAutoreleasedReturnValue(v164);
    }

    goto LABEL_139;
  }

  v531[5620] = v123;
  v122[5621] = v121;
  id v125 = v531;
  unint64_t v126 = (uint64_t *)(v531 + 5620);
  unsigned int v127 = v531[5620];
  uint64_t v128 = *(void *)(*(void *)(*(void *)v531 + 120LL) + 24LL);
  uint64_t v129 = (void *)objc_claimAutoreleasedReturnValue([*((id *)&v546 + 1) objectForKeyedSubscript:@"ROI"]);
  id v130 = (void *)objc_claimAutoreleasedReturnValue([v129 objectForKeyedSubscript:@"Type"]);
  unsigned int v499 = [v130 integerValue];

  uint64_t v131 = v128 + ((unint64_t)(v127 - 1) << 6);
  if (*(_DWORD *)(v131 + 8) >> 2 == 1073737833)
  {
    uint64_t v132 = apr_palloc(p, 0xD0uLL);
    uint64_t v133 = (uint64_t)v132;
    if (v132)
    {
      v132[11] = 0u;
      v132[12] = 0u;
      v132[9] = 0u;
      v132[10] = 0u;
      v132[7] = 0u;
      v132[8] = 0u;
      v132[5] = 0u;
      v132[6] = 0u;
      v132[3] = 0u;
      v132[4] = 0u;
      v132[1] = 0u;
      v132[2] = 0u;
      *uint64_t v132 = 0u;
    }

    uint64_t v134 = *(void *)v125;
    GTMTLSMContext_indirectCommandBufferResources( (uint64_t)__dst,  *(_DWORD ***)(*(void *)v125 + 40LL),  *(void *)v131,  p);
    __int128 v135 = *(_OWORD *)&__dst[48];
    *(_OWORD *)(v133 + 144) = *(_OWORD *)&__dst[32];
    *(_OWORD *)(v133 + 160) = v135;
    *(_OWORD *)(v133 + 176) = *(_OWORD *)&__dst[64];
    *(void *)(v133 + 192) = *(void *)&__dst[80];
    __int128 v136 = *(_OWORD *)&__dst[16];
    *(_OWORD *)(v133 + 112) = *(_OWORD *)__dst;
    *(_OWORD *)(v133 + 12_Block_object_dispose(&STACK[0x3B0], 8) = v136;
    GetExecuteCommandsInBufferArgs((uint64_t)&v558, v131, *(void *)(v134 + 16));
    size_t v137 = GTMTLSMContext_getObject(**(void **)(v134 + 40), v558, *(void *)v131);
    GTMTLCreateIndirectCommandEncoder(v133, v137[13]);
    uint64_t v138 = *((void *)&v559 + 1) + *(void *)(v133 + 104) * *((unsigned int *)v126 + 1);
    *(void *)(v133 + 200) = v138;
    if (v125[2828] == 70)
    {
      memcpy(__dst, v125 + 2842, sizeof(__dst));
      if (GTMTLSMRenderCommandEncoder_loadIndirectCommand( (uint64_t)(v125 + 2842),  (void *)v133,  *(void *)(v133 + 200),  (uint64_t *)(v133 + 112)))
      {
        uint64_t v139 = *((void *)v125 + 1415);
        id v140 = *((id *)v125 + 1);
        unint64_t v141 = (void *)objc_claimAutoreleasedReturnValue([v140 renderCommandEncoderForKey:v139]);
        GTMTLReplayController_restoreRenderCommandEncoder(v141, (uint64_t)__dst, (uint64_t)(v125 + 2842), v140);

        goto LABEL_114;
      }

LABEL_148:
      if (!a3) {
        goto LABEL_139;
      }
      id v168 = GTShaderDebuggerMakeError(1u, @"Internal error: Failed to decode ICB", 0LL, 0LL, 0LL);
      id v169 = (id)objc_claimAutoreleasedReturnValue(v168);
      goto LABEL_150;
    }

    if ((GT_SUPPORT_0 & 0x10) == 0) {
      goto LABEL_148;
    }
    memcpy(__dst, v125 + 2842, 0x8D0uLL);
    if (!GTMTLSMComputeCommandEncoder_loadIndirectCommand( (uint64_t)(v125 + 2842),  (void *)v133,  v138,  (uint64_t *)(v133 + 112))) {
      goto LABEL_148;
    }
    uint64_t v165 = *((void *)v125 + 1415);
    id v166 = *((id *)v125 + 1);
    id v167 = (void *)objc_claimAutoreleasedReturnValue([v166 computeCommandEncoderForKey:v165]);
    GTMTLReplayController_restoreComputeCommandEncoder(v167, (uint64_t)__dst, (uint64_t)(v125 + 2842), v166);
  }

  else
  {
    uint64_t v133 = 0LL;
  }

  unsigned int v119 = *v137;
  id v118 = *v135;
  uint64_t v120 = *v138;
LABEL_149:
  int v155 = (void *)objc_claimAutoreleasedReturnValue([v224 functionForKey:v118]);
  id v156 = DEVICEOBJECT(v155);
  uint64_t v157 = (void *)objc_claimAutoreleasedReturnValue(v156);

  __int128 v223 = v157;
  unint64_t v158 = [v157 newArgumentEncoderWithBufferIndex:*(unsigned __int8 *)(v134 + 18)];
  id v159 = (void *)objc_claimAutoreleasedReturnValue([v224 bufferForKey:v119]);
  id v160 = [v159 length];
  id v161 = v244[3];
  char v162 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v161, "bufferWithLength:alignment:", v160, objc_msgSend(v158, "alignment")));
  uint64_t v163 = (void *)objc_claimAutoreleasedReturnValue([v161 blitCommandEncoder]);
  id v164 = (void *)objc_claimAutoreleasedReturnValue([v162 heapBuffer]);
  id v237 = (unint64_t)v160;
  objc_msgSend( v163,  "copyFromBuffer:sourceOffset:toBuffer:destinationOffset:size:",  v159,  0,  v164,  objc_msgSend(v162, "heapLocation"),  v160);

  uint64_t v165 = (void *)objc_claimAutoreleasedReturnValue([v161 commandBuffer]);
  id v166 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"%@.%@",  @"com.apple.gputools.replay",  @"DecodeAB Blit"));
  [v165 setLabel:v166];

  [v161 commitCommandBuffer];
  [v165 waitUntilCompleted];
  id v167 = (void *)objc_claimAutoreleasedReturnValue([v162 heapBuffer]);

  __int128 v222 = v162;
  __int128 v226 = (char *)[v162 heapLocation];

  id v168 = apr_array_make(a3, 8, 32);
  id v169 = *(unsigned __int8 **)(v134 + 8);
  if (!v169) {
    goto LABEL_155;
  }
  uint64_t v170 = *v169;
  if (v170 == 1) {
    goto LABEL_156;
  }
  if (v170 == 60 && v169[22] == 1) {
    id v169 = (unsigned __int8 *)*((void *)v169 + 1);
  }
  else {
LABEL_155:
  }
    id v169 = 0LL;
LABEL_156:
  GTMTLStructType_fillArgumentIndicesRequiresPatching(v169, 0LL, 0LL, v168, 0x1FFuLL);
  __int128 v221 = v167;
  uint64_t v171 = DEVICEOBJECT(v167);
  id v172 = (id)objc_claimAutoreleasedReturnValue(v171);
  unsigned int v173 = v158;
  uint64_t v174 = (unint64_t)[v173 encodedLength];
  __int128 v220 = v173;
  __int128 v225 = (void *)objc_claimAutoreleasedReturnValue([v173 layout]);
  uint64_t v175 = v120 % v174;
  id v236 = v174;
  uint64_t v176 = (v237 - v120 % v174) / v174;
  nelts = v168->nelts;
  uint64_t v178 = apr_array_make(a3, (int)nelts + (int)v176 + (int)v176 * (int)nelts + 2, 8);
  *(void *)apr_array_push(v17_Block_object_dispose(&STACK[0x3B0], 8) = v176;
  *(void *)apr_array_push(v17_Block_object_dispose(&STACK[0x3B0], 8) = nelts;
  if (v168->nelts >= 1)
  {
    unsigned int v179 = 0LL;
    id v180 = 8LL;
    do
    {
      uint64_t v181 = *(void *)&v168->elts[v180];
      *(void *)apr_array_push(v17_Block_object_dispose(&STACK[0x3B0], 8) = v181;
      ++v179;
      v180 += 32LL;
    }

    while (v179 < v168->nelts);
  }

  id v182 = v175 + v236;
  if (v175 + v236 <= v237)
  {
    id v183 = v250;
    __int128 v228 = v172;
    __int128 v227 = v250;
    while (1)
    {
      uint64_t v184 = v182;
      *(void *)apr_array_push(v17_Block_object_dispose(&STACK[0x3B0], 8) = v175;
      if (!v183) {
        break;
      }
      if (v183 == 1)
      {
        id v242 = v184;
        uint64_t v185 = v172;
        v186 = v168->nelts;
        if (v186 >= 1)
        {
          v187 = v185;
          id v188 = 0LL;
          id v189 = 0LL;
          id v190 = &v226[v175];
          id v191 = v245;
          while (1)
          {
            id v192 = &v168->elts[v188];
            id v193 = *(void *)v192;
            id v194 = *(void *)v192 - 58LL;
            if (v194 <= 0x3C)
            {
              unint64_t v195 = *((void *)v192 + 2);
              if (((1LL << v194) & 0x1E00000000700003LL) != 0)
              {
                id v196 = [v187 contents];
                if (v193 > 0x72u)
                {
                  id v197 = (uint64_t *)&v249;
                  if (v193 - 117 >= 2)
                  {
                    id v197 = (uint64_t *)&v248;
                  }
                }

                else if (v193 <= 0x4Du)
                {
                  id v197 = (uint64_t *)&v245 + 1;
                }

                else
                {
                  id v197 = (uint64_t *)&v246 + 1;
                  if (v193 != 78)
                  {
                    id v197 = (uint64_t *)&v247;
                  }
                }

                uint64_t v198 = *(void *)&v190[v195 + (void)v196];
                v199 = *v197;
                *(void *)__dst = v198;
                BOOL v200 = *find_entry(v199, __dst, 8uLL, 0LL);
                if (v200)
                {
                  v201 = *(void *)(v200 + 32);
                  if (v201) {
                    uint64_t v198 = *(void *)(v201 + 8);
                  }
                }
              }

              else
              {
                if (*(void *)v192 != 60LL) {
                  goto LABEL_181;
                }
                uint64_t v198 = *(void *)&v190[v195 + (void)[objc_retainAutorelease(v187) contents]];
                BOOL v202 = GTMTLGPUAddressResource_resourceForGPUAddress(*(void **)(v191 + 24), *(int *)(v191 + 12), v198);
                if (v202) {
                  uint64_t v198 = v202[2] + v198 - *v202;
                }
              }

              *(void *)apr_array_push(v17_Block_object_dispose(&STACK[0x3B0], 8) = v198;
              v186 = v168->nelts;
            }

LABEL_114:
  unint64_t v144 = *(void *)v131;
  unsigned int v145 = v531[2828];
  *(void *)&__int128 v494 = v133;
  *((void *)&v494 + 1) = v131;
  if (v145 == 70)
  {
    uint64_t v170 = GTMTLSMContext_getObject(**(void **)(*(void *)v531 + 40LL), *((void *)v531 + 2489), v144);
    if (v170)
    {
      uint64_t v171 = v170[7];
      if (v171)
      {
        switch(v499)
        {
          case 1u:
          case 4u:
            uint64_t v148 = (uint64_t *)(v171 + 24);
            v149 = (_WORD *)(v171 + 198);
            id v150 = (uint64_t *)(v531 + 2848);
            unint64_t v151 = (uint64_t *)(v531 + 3034);
            uint64_t v152 = (uint64_t *)(v531 + 3290);
            v518 = (uint64_t *)(v531 + 2844);
            uint64_t v153 = 2910LL;
            goto LABEL_433;
          case 2u:
            uint64_t v148 = (uint64_t *)(v171 + 32);
            v149 = (_WORD *)(v171 + 200);
            id v150 = (uint64_t *)(v531 + 3324);
            unint64_t v151 = (uint64_t *)(v531 + 3448);
            uint64_t v152 = (uint64_t *)(v531 + 3704);
            v518 = (uint64_t *)(v531 + 3322);
            uint64_t v153 = 3386LL;
            goto LABEL_433;
          case 3u:
            uint64_t v148 = (uint64_t *)(v171 + 56);
            v149 = (_WORD *)(v171 + 202);
            id v150 = (uint64_t *)(v531 + 4566);
            unint64_t v151 = (uint64_t *)(v531 + 4690);
            uint64_t v152 = (uint64_t *)(v531 + 4946);
            v518 = (uint64_t *)(v531 + 4564);
            uint64_t v153 = 4628LL;
            goto LABEL_433;
          case 5u:
            uint64_t v148 = (uint64_t *)(v171 + 40);
            v149 = (_WORD *)(v171 + 204);
            id v150 = (uint64_t *)(v531 + 3738);
            unint64_t v151 = (uint64_t *)(v531 + 3862);
            uint64_t v152 = (uint64_t *)(v531 + 4118);
            v518 = (uint64_t *)(v531 + 3736);
            uint64_t v153 = 3800LL;
            goto LABEL_433;
          case 6u:
            uint64_t v148 = (uint64_t *)(v171 + 48);
            v149 = (_WORD *)(v171 + 206);
            id v150 = (uint64_t *)(v531 + 4152);
            unint64_t v151 = (uint64_t *)(v531 + 4276);
            uint64_t v152 = (uint64_t *)(v531 + 4532);
            v518 = (uint64_t *)(v531 + 4150);
            uint64_t v153 = 4214LL;
            goto LABEL_433;
          default:
            GTMTLReplay_handleError( 101,  (uint64_t)"Unreachable",  "/Library/Caches/com.apple.xbs/Sources/GPUToolsDevice/GPUTools/GTMTLCapture/replayer/GTMTLReplay_shaderDebugger_internal.m",  (uint64_t)"_SetCurrentEncoderResourceBindings",  934LL,  4LL);
            goto LABEL_163;
        }
      }
    }

    goto LABEL_163;
  }

  if (v145 != 28
    || (unint64_t v146 = GTMTLSMContext_getObject(**(void **)(*(void *)v531 + 40LL), *((void *)v531 + 1422), v144)) == 0LL
    || (uint64_t v147 = v146[8]) == 0)
  {
LABEL_163:
    id v150 = 0LL;
    unint64_t v151 = 0LL;
    uint64_t v152 = 0LL;
    v518 = 0LL;
    id obja = 0LL;
    uint64_t v174 = 0LL;
    uint64_t v175 = 0LL;
    uint64_t v176 = 0LL;
    char v177 = 1;
    goto LABEL_164;
  }

  uint64_t v148 = (uint64_t *)(v147 + 32);
  v149 = (_WORD *)(v147 + 94);
  id v150 = (uint64_t *)(v531 + 2850);
  unint64_t v151 = (uint64_t *)(v531 + 3036);
  uint64_t v152 = (uint64_t *)(v531 + 3292);
  v518 = (uint64_t *)(v531 + 2846);
  uint64_t v153 = 2912LL;
LABEL_433:
  id obja = (uint64_t *)&v531[v153];
  char v177 = 0;
  uint64_t v429 = (unsigned __int16)*v149;
  uint64_t v176 = 16LL;
  uint64_t v175 = 128LL;
  uint64_t v174 = 31LL;
  if (*v149)
  {
    uint64_t v430 = *v148;
    if (*v148)
    {
      v514 = objc_alloc_init(&OBJC_CLASS___NSMutableDictionary);
      v505 = objc_alloc_init(&OBJC_CLASS___NSMutableDictionary);
      v528 = objc_alloc_init(&OBJC_CLASS___NSMutableDictionary);
      v523 = objc_alloc_init(&OBJC_CLASS___NSMutableDictionary);
      v431 = objc_alloc_init(&OBJC_CLASS___NSMutableDictionary);
      v493 = objc_alloc_init(&OBJC_CLASS___NSMutableDictionary);
      v432 = (unsigned __int8 *)(v430 + 18);
      while (1)
      {
        unsigned int v433 = *(v432 - 2);
        if (v433 > 2)
        {
          if (v433 == 3)
          {
            v434 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  v152[*v432]));
            v435 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedChar:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedChar:",  *v432));
            -[NSMutableDictionary setObject:forKeyedSubscript:](v523, "setObject:forKeyedSubscript:", v434, v435);
            goto LABEL_447;
          }

          if (v433 == 24)
          {
            v434 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  v150[*v432]));
            v435 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedChar:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedChar:",  *v432));
            -[NSMutableDictionary setObject:forKeyedSubscript:](v431, "setObject:forKeyedSubscript:", v434, v435);
            goto LABEL_447;
          }
        }

        else
        {
          if (!*(v432 - 2))
          {
            unint64_t v436 = *v432;
            uint64_t v437 = v150[v436];
            if (((*(unint64_t *)((char *)v518 + ((v436 >> 3) & 0x18)) >> v436) & 1) != 0)
            {
              uint64_t v438 = obja[v436];
              v434 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  v437));
              *(void *)__dst = v434;
              v435 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  v438));
              *(void *)&__dst[8] = v435;
              v439 = (void *)objc_claimAutoreleasedReturnValue( +[NSArray arrayWithObjects:count:]( &OBJC_CLASS___NSArray,  "arrayWithObjects:count:",  __dst,  2LL));
              v440 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedChar:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedChar:",  *v432));
              -[NSMutableDictionary setObject:forKeyedSubscript:](v514, "setObject:forKeyedSubscript:", v439, v440);
            }

            else
            {
              v434 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  v437));
              v435 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedChar:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedChar:",  *v432));
              -[NSMutableDictionary setObject:forKeyedSubscript:](v505, "setObject:forKeyedSubscript:", v434, v435);
            }

            goto LABEL_447;
          }

          if (v433 == 2)
          {
            v434 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  v151[*v432]));
            v435 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedChar:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedChar:",  *v432));
            -[NSMutableDictionary setObject:forKeyedSubscript:](v528, "setObject:forKeyedSubscript:", v434, v435);
LABEL_447:
          }
        }

        v432 += 56;
        if (!--v429)
        {
          id v441 = -[NSMutableDictionary copy](v514, "copy");
          v442 = (void *)v533;
          *(void *)&__int128 v533 = v441;

          id v443 = -[NSMutableDictionary copy](v505, "copy");
          v444 = (void *)*((void *)&v533 + 1);
          *((void *)&v533 + 1) = v443;

          id v445 = -[NSMutableDictionary copy](v528, "copy");
          v446 = (void *)v534;
          *(void *)&__int128 v534 = v445;

          id v447 = -[NSMutableDictionary copy](v523, "copy");
          v448 = (void *)*((void *)&v534 + 1);
          *((void *)&v534 + 1) = v447;

          id v449 = -[NSMutableDictionary copy](v431, "copy");
          v450 = (void *)v535;
          *(void *)&__int128 v535 = v449;

          id v451 = -[NSMutableDictionary copy](v493, "copy");
          v452 = (void *)*((void *)&v535 + 1);
          *((void *)&v535 + 1) = v451;

          BOOL v200 = 1;
          goto LABEL_181;
        }
      }
    }
  }

      v177[0] = 0LL;
      ++*(void *)(v5 + 24);
      std::unique_ptr<std::__hash_node<std::__hash_value_type<long,std::unordered_map<unsigned int,DrawDurationInfo>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<long,std::unordered_map<unsigned int,DrawDurationInfo>>,void *>>>>::reset[abi:nn180100]((uint64_t)v177);
LABEL_115:
      std::__hash_table<std::__hash_value_type<unsigned int,DrawDurationInfo>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,DrawDurationInfo>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,DrawDurationInfo>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,DrawDurationInfo>>>::~__hash_table((uint64_t)&v172);
      id v62 = *((void *)v49 + 4);
      if (v62) {
        uint64_t v63 = (float)*((unint64_t *)v49 + 6) / (float)v62;
      }
      else {
        uint64_t v63 = 0.0;
      }
      BOOL v64 = fmaxf(v63, 0.3);
      v49[14] = v64;
      std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__rehash<true>( (uint64_t)(v49 + 6),  vcvtps_u32_f32(32.0 / v64));
LABEL_119:
      double v65 = std::__hash_table<std::__hash_value_type<unsigned int,DrawDurationInfo>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,DrawDurationInfo>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,DrawDurationInfo>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,DrawDurationInfo>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>( (uint64_t)(v49 + 6),  v175,  &v175);
      double v66 = v65;
      BOOL v67 = *((_DWORD *)v65 + 7) + v26[2];
      ++*((_DWORD *)v65 + 6);
      *((_DWORD *)v65 + 7) = v67;
      double v68 = *(_DWORD *)(v1 + 184) & 0x1F | (32 * *(_DWORD *)(v1 + 188)) | (unint64_t)(v27 << 32);
      id v70 = (char *)*((void *)v65 + 5);
      double v69 = *((void *)v65 + 6);
      if ((unint64_t)v70 >= v69)
      {
        uint64_t v72 = (char *)*((void *)v65 + 4);
        double v73 = (v70 - v72) >> 3;
        BOOL v74 = v73 + 1;
        double v75 = v69 - (void)v72;
        if (v75 >> 2 > v74) {
          BOOL v74 = v75 >> 2;
        }
        double v76 = (unint64_t)v75 >= 0x7FFFFFFFFFFFFFF8LL;
        double v77 = 0x1FFFFFFFFFFFFFFFLL;
        if (!v76) {
          double v77 = v74;
        }
        if (v77)
        {
          double v77 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<std::pair<unsigned int,unsigned int>>>(v77);
          uint64_t v72 = (char *)*((void *)v66 + 4);
          id v70 = (char *)*((void *)v66 + 5);
        }

        else
        {
          unint64_t v78 = 0LL;
        }

        BOOL v79 = (unint64_t *)(v77 + 8 * v73);
        *BOOL v79 = v68;
        id v71 = v79 + 1;
        while (v70 != v72)
        {
          id v80 = *((void *)v70 - 1);
          v70 -= 8;
          *--BOOL v79 = v80;
        }

        *((void *)v66 + 4) = v79;
        *((void *)v66 + 5) = v71;
        *((void *)v66 + 6) = v77 + 8 * v78;
        if (v72) {
          operator delete(v72);
        }
      }

      else
      {
        *(void *)id v70 = v68;
        id v71 = v70 + 8;
      }

      *((void *)v66 + 5) = v71;
LABEL_135:
      uint64_t v81 = sqrt((double)[WeakRetained _computeSampleNormFactorForSample:v26 forProgramStartAddress:*(void *)(v170 + 8) forProgramEndAddress:*(void *)(v170 + 16)]);
      if (v81 <= 1) {
        uint64_t v82 = 1;
      }
      else {
        uint64_t v82 = v81;
      }
      uint64_t v83 = objc_claimAutoreleasedReturnValue( [*(id *)(*(void *)(*(void *)(v1 + 56) + 8) + 40) objectAtIndexedSubscript:v27]);
      int v86 = v83;
      *(void *)(v83 + _Block_object_dispose(&STACK[0x3B0], 8) = *v166;
      *(_DWORD *)(v83 + 16) = v26[1];
      unsigned int v87 = *(_DWORD *)(v1 + 188);
      *(_DWORD *)(v83 + 24) = *(_DWORD *)(v83 + 24) & 0xF8000000 | v87 & 0x7FFFFFF;
      __int128 v88 = v87 & 0x7FFFFFF | (*(_DWORD *)(v1 + 184) << 27);
      __int128 v89 = v176;
      *(_DWORD *)(v83 + 20) = v176;
      *(_DWORD *)(v83 + 24) = v88;
      *(double *)(v83 + 32) = v38;
      if (v34)
      {
        uint64_t v90 = (char *)v34[1] - (char *)*v34;
        BOOL v91 = v90 >> 4;
        uint64_t v92 = *(void *)(v86 + 48);
        if (v90 < 0) {
          abort();
        }
      }

      else
      {
        uint64_t v92 = *(void *)(v83 + 48);
        if (*(void *)(v83 + 64) != v92) {
          goto LABEL_149;
        }
        BOOL v91 = 1LL;
      }

      unsigned int v93 = *(void *)(v86 + 56);
      id v94 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<std::pair<unsigned long long,unsigned long long>>>(v91);
      unsigned int v97 = *(char **)(v86 + 48);
      uint64_t v96 = *(char **)(v86 + 56);
      uint64_t v98 = &v94[(v93 - v92) & 0xFFFFFFFFFFFFFFF0LL];
      if (v96 != v97)
      {
        do
        {
          BOOL v84 = *((_OWORD *)v96 - 1);
          *((_OWORD *)v98 - 1) = v84;
          v98 -= 16;
          v96 -= 16;
        }

        while (v96 != v97);
        uint64_t v96 = *(char **)(v86 + 48);
      }

      *(void *)(v86 + 4_Block_object_dispose(&STACK[0x3B0], 8) = v98;
      *(void *)(v86 + 56) = &v94[(v93 - v92) & 0xFFFFFFFFFFFFFFF0LL];
      *(void *)(v86 + 64) = &v94[16 * v95];
      if (v96) {
        operator delete(v96);
      }
LABEL_149:
      if (v167 <= 2)
      {
        uint64_t v99 = (void *)(*v161 + 40LL * v167);
        int v100 = v175;
        id v101 = std::__hash_table<std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>>>::find<unsigned int>( v99,  v175);
        if (v101)
        {
          id v102 = v26[1];
          LODWORD(v103) = v102 - 1;
          if ((_DWORD)v102) {
            unsigned int v103 = v103;
          }
          else {
            unsigned int v103 = 0LL;
          }
          if (v101[3] < v103) {
            unsigned int v103 = v101[3];
          }
          if (v101[4] > v102) {
            id v102 = v101[4];
          }
          v101[3] = v103;
          v101[4] = v102;
        }

        else
        {
          unsigned __int8 v104 = v26[1];
          LODWORD(v105) = v104 - 1;
          if ((_DWORD)v104) {
            uint64_t v105 = v105;
          }
          else {
            uint64_t v105 = 0LL;
          }
          LODWORD(v172) = v100;
          *((void *)&v172 + 1) = v105;
          *(void *)&unsigned int v173 = v104;
          std::__hash_table<std::__hash_value_type<unsigned int,std::pair<unsigned long long,unsigned long long>>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,std::pair<unsigned long long,unsigned long long>>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,std::pair<unsigned long long,unsigned long long>>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,std::pair<unsigned long long,unsigned long long>>>>::__emplace_unique_key_args<unsigned int,std::pair<unsigned int const,std::pair<unsigned long long,unsigned long long>>>( (uint64_t)v99,  v100,  (uint64_t)&v172);
        }
      }

      if (v34)
      {
        uint64_t v107 = *v34;
        uint64_t v106 = v34[1];
        if (v107 == v106) {
          goto LABEL_193;
        }
        id v108 = 0;
        id v109 = (double)(v82 * v40);
        uint64_t v110 = v175 & 0xFFFFFFF | v162;
        do
        {
          LODWORD(v84) = v26[2];
          LODWORD(v85) = v107[1];
          unsigned int v85 = (double)*(unint64_t *)&v85;
          uint64_t v111 = v38 * (double)(unint64_t)v84 * v85 / v109;
          DWORD1(v84) = 1018167296;
          if (v111 > 2.22044605e-16)
          {
            id v112 = *v107;
            id v114 = *(void *)(v86 + 56);
            id v113 = *(void *)(v86 + 64);
            if (v114 >= v113)
            {
              id v116 = *(void *)(v86 + 48);
              id v117 = (uint64_t)(v114 - v116) >> 4;
              id v118 = v117 + 1;
              unsigned int v119 = v113 - v116;
              if (v119 >> 3 > v118) {
                id v118 = v119 >> 3;
              }
              else {
                uint64_t v120 = v118;
              }
              if (v120) {
                uint64_t v120 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<std::pair<unsigned long long,unsigned long long>>>(v120);
              }
              else {
                int v121 = 0LL;
              }
              unint64_t v122 = v120 + 16 * v117;
              *(_DWORD *)unint64_t v122 = v112;
              *(_DWORD *)(v122 + 4) = v110;
              *(double *)(v122 + _Block_object_dispose(&STACK[0x3B0], 8) = v111;
              unsigned int v124 = *(char **)(v86 + 48);
              unsigned int v123 = *(char **)(v86 + 56);
              id v125 = v122;
              if (v123 != v124)
              {
                do
                {
                  BOOL v84 = *((_OWORD *)v123 - 1);
                  *(_OWORD *)(v125 - 16) = v84;
                  v125 -= 16LL;
                  v123 -= 16;
                }

                while (v123 != v124);
                unsigned int v123 = *(char **)(v86 + 48);
              }

              unsigned __int8 v115 = v122 + 16;
              *(void *)(v86 + 4_Block_object_dispose(&STACK[0x3B0], 8) = v125;
              *(void *)(v86 + 56) = v122 + 16;
              *(void *)(v86 + 64) = v120 + 16 * v121;
              if (v123) {
                operator delete(v123);
              }
            }

            else
            {
              *(_DWORD *)id v114 = v112;
              *(_DWORD *)(v114 + 4) = v110;
              unsigned __int8 v115 = v114 + 16;
              *(double *)(v114 + _Block_object_dispose(&STACK[0x3B0], 8) = v111;
            }

            *(void *)(v86 + 56) = v115;
            ++v108;
            if (WeakRetained[752])
            {
              LODWORD(v85) = v107[1];
              fprintf( *(FILE **)(v169 + 160),  "%u %u:0x%llx %u %10u %10u %10u %10u %15f %15f %15f\n",  v27,  *(_DWORD *)(v115 - 16),  *(void *)(v170 + 8),  *(_DWORD *)(v115 - 12) >> 28,  v89,  *(_DWORD *)(v115 - 12) & 0xFFFFFFF,  *(_DWORD *)(v86 + 16),  v26[2],  *(double *)(v115 - 8),  v38,  (double)*(unint64_t *)&v85 / v109);
            }
          }

          v107 += 4;
        }

        while (v107 != v106);
        if (!v108) {
          goto LABEL_193;
        }
        goto LABEL_187;
      }

      LODWORD(v84) = v26[2];
      uint64_t v131 = (double)(unint64_t)v84 / (double)v82;
      if (v131 > 2.22044605e-16)
      {
        if (v157 != 5)
        {
          if (v157 == 4)
          {
            uint64_t v132 = v169;
            if (!v26[5])
            {
              [WeakRetained _waitLatencyAdjustmentWithLimiterData:*(void *)(v169 + 152) forIndex:(*(_DWORD *)(v169 + 180) * v26[1]) withLimiterTypeIndexMap:v155];
              uint64_t v131 = v131 * v133;
            }

            uint64_t v134 = v152;
LABEL_206:
            __int128 v136 = *(void *)(*(void *)(*(void *)(*(void *)v134 + 8LL) + 48LL)
                             + 24LL * *(unsigned int *)(v132 + 168));
            *(double *)(v136 + 8LL * (*v26 % *(_DWORD *)(v132 + 192))) = v131
                                                                                     + *(double *)(v136
                                                                                                 + 8LL
                                                                                                 * (*v26 % *(_DWORD *)(v132 + 192)));
          }

          size_t v137 = v26[3];
          uint64_t v138 = v175 & 0xFFFFFFF | v162;
          id v140 = *(void *)(v86 + 56);
          uint64_t v139 = *(void *)(v86 + 64);
          if (v140 >= v139)
          {
            unsigned int v142 = *(void *)(v86 + 48);
            unint64_t v143 = (uint64_t)(v140 - v142) >> 4;
            unint64_t v144 = v143 + 1;
            unsigned int v145 = v139 - v142;
            if (v145 >> 3 > v144) {
              unint64_t v144 = v145 >> 3;
            }
            else {
              unint64_t v146 = v144;
            }
            if (v146) {
              unint64_t v146 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<std::pair<unsigned long long,unsigned long long>>>(v146);
            }
            else {
              uint64_t v147 = 0LL;
            }
            uint64_t v148 = v146 + 16 * v143;
            *(_DWORD *)uint64_t v148 = v137;
            *(_DWORD *)(v148 + 4) = v138;
            *(double *)(v148 + _Block_object_dispose(&STACK[0x3B0], 8) = v131;
            id v150 = *(char **)(v86 + 48);
            v149 = *(char **)(v86 + 56);
            unint64_t v151 = v148;
            if (v149 != v150)
            {
              do
              {
                *(_OWORD *)(v151 - 16) = *((_OWORD *)v149 - 1);
                v151 -= 16LL;
                v149 -= 16;
              }

              while (v149 != v150);
              v149 = *(char **)(v86 + 48);
            }

            unint64_t v141 = v148 + 16;
            *(void *)(v86 + 4_Block_object_dispose(&STACK[0x3B0], 8) = v151;
            *(void *)(v86 + 56) = v148 + 16;
            *(void *)(v86 + 64) = v146 + 16 * v147;
            if (v149) {
              operator delete(v149);
            }
          }

          else
          {
            *(_DWORD *)id v140 = v137;
            *(_DWORD *)(v140 + 4) = v138;
            unint64_t v141 = v140 + 16;
            *(double *)(v140 + _Block_object_dispose(&STACK[0x3B0], 8) = v131;
          }

          *(void *)(v86 + 56) = v141;
          id v108 = 1;
LABEL_187:
          unint64_t v126 = *(void *)(v86 + 8);
          if (v126 && *(void *)(v126 + 8))
          {
            unsigned int v127 = (unsigned int *)(v126 + 40);
            do
              uint64_t v128 = __ldaxr(v127);
            while (__stlxr(v128 + v108, v127));
            uint64_t v129 = (unint64_t *)(*(void *)(*(void *)(*(void *)(v86 + 8) + 16LL)
            do
              id v130 = __ldaxr(v129);
            while (__stlxr(v130 + v108, v129));
          }

          goto LABEL_193;
        }

        if (v26[5])
        {
          uint64_t v134 = v153;
          uint64_t v132 = v169;
        }

        else
        {
          uint64_t v132 = v169;
          [WeakRetained _latencyAdjustmentFactorWithLimiterData:*(void *)(v169 + 152) forIndex:(*(_DWORD *)(v169 + 180) * v26[1]) withLimiterTypeIndexMap:v155 forLimiterType:4];
          uint64_t v131 = v131 * v135;
          uint64_t v134 = v153;
        }

        goto LABEL_206;
      }

    if (!*((void *)&v163 + 1)) {
      goto LABEL_131;
    }
    id v80 = (void *)(*((void *)__p + v59) + 8 * HIDWORD(v59));
    uint64_t v81 = v80[4];
    uint64_t v82 = (uint8x8_t)vcnt_s8(*(int8x8_t *)((char *)&v163 + 8));
    v82.i16[0] = vaddlv_u8(v82);
    if (v82.u32[0] > 1uLL)
    {
      uint64_t v83 = v80[4];
    }

    else
    {
      uint64_t v83 = (DWORD2(v163) - 1) & v81;
    }

    BOOL v84 = *(uint64_t ***)(v163 + 8 * v83);
    if (!v84)
    {
LABEL_131:
      unsigned int v87 = v58;
      goto LABEL_132;
    }

    unsigned int v85 = *v84;
    if (!*v84)
    {
LABEL_130:
      unsigned int v87 = v58;
      goto LABEL_132;
    }

    while (2)
    {
      int v86 = v85[1];
      if (v86 != v81)
      {
        if (v82.u32[0] > 1uLL)
        {
          if (v86 >= *((void *)&v163 + 1)) {
            v86 %= *((void *)&v163 + 1);
          }
        }

        else
        {
          v86 &= *((void *)&v163 + 1) - 1LL;
        }

        if (v86 != v83) {
          goto LABEL_130;
        }
LABEL_129:
        unsigned int v85 = (uint64_t *)*v85;
        if (!v85) {
          goto LABEL_130;
        }
        continue;
      }

      break;
    }

    if (*((_DWORD *)v85 + 4) != (_DWORD)v81) {
      goto LABEL_129;
    }
    unsigned int v87 = v80[1];
    uint64_t v98 = (double)(unint64_t)(v87 - v58);
    uint64_t v99 = v148;
    if (v148 <= 1) {
      int v100 = 1;
    }
    else {
      int v100 = v148;
    }
    id v101 = v98 / (double)v100 * 125.0 / 3.0;
    id v102 = v80[3];
    unsigned int v103 = (v102 >> 1) & 3;
    unsigned __int8 v104 = (uint64_t *)v154;
    if ((v102 & 1) != 0)
    {
      if (!(void)v154) {
        goto LABEL_183;
      }
      id v114 = 0;
      do
      {
        unsigned __int8 v115 = 0LL;
        id v116 = v104[3];
        id v117 = v116 + 24;
        do
        {
          if (*(_DWORD *)(v116 + 4 * v115 + 24)) {
            *(double *)(v116 + 8 * v115) = v101 + *(double *)(v116 + 8 * v115);
          }
          ++v115;
        }

        while (v115 != 3);
        if (v81 == *((_DWORD *)v104 + 4))
        {
          id v118 = *(_DWORD *)(v117 + 4 * v103);
          if (v118)
          {
            unsigned int v119 = v118 - 1;
            *(_DWORD *)(v117 + 4 * v103) = v119;
            uint64_t v99 = (__PAIR64__(v99, v119) - 1) >> 32;
          }

          else
          {
            ++v99;
          }

          id v114 = 1;
        }

        unsigned __int8 v104 = (uint64_t *)*v104;
      }

      while (v104);
      if ((v114 & 1) == 0)
      {
LABEL_183:
        --*((_DWORD *)v85 + v103 + 12);
        id v113 = std::unordered_map<unsigned int,GRCSplitBlitTimeData::CalculateBlitEncoderTime(NSArray<NSData *> *,NSData *)::TimeInfo *,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<std::pair<unsigned int const,GRCSplitBlitTimeData::CalculateBlitEncoderTime(NSArray<NSData *> *,NSData *)::TimeInfo *>>>::operator[]( (float *)&v153,  v81);
LABEL_184:
        *(void *)id v113 = v85 + 3;
        ++v99;
      }
    }

    else
    {
      if (!(void)v154) {
        goto LABEL_169;
      }
      uint64_t v105 = 0;
      do
      {
        uint64_t v106 = 0LL;
        uint64_t v107 = v104[3];
        id v108 = v107 + 24;
        do
        {
          if (*(_DWORD *)(v107 + 4 * v106 + 24)) {
            *(double *)(v107 + 8 * v106) = v101 + *(double *)(v107 + 8 * v106);
          }
          ++v106;
        }

        while (v106 != 3);
        if (v81 == *((_DWORD *)v104 + 4))
        {
          id v109 = *(_DWORD *)(v108 + 4 * v103);
          if (v109)
          {
            uint64_t v110 = __CFADD__(v109, 1);
            uint64_t v111 = v109 + 1;
            id v112 = v110;
            *(_DWORD *)(v108 + 4 * v103) = v111;
            v99 -= v112;
          }

          else
          {
            ++v99;
          }

          uint64_t v105 = 1;
        }

        unsigned __int8 v104 = (uint64_t *)*v104;
      }

      while (v104);
      if ((v105 & 1) == 0)
      {
LABEL_169:
        ++*((_DWORD *)v85 + v103 + 12);
        id v113 = std::unordered_map<unsigned int,GRCSplitBlitTimeData::CalculateBlitEncoderTime(NSArray<NSData *> *,NSData *)::TimeInfo *,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<std::pair<unsigned int const,GRCSplitBlitTimeData::CalculateBlitEncoderTime(NSArray<NSData *> *,NSData *)::TimeInfo *>>>::operator[]( (float *)&v153,  v81);
        goto LABEL_184;
      }
    }

    uint64_t v120 = 0LL;
    int v121 = 0;
    do
    {
      v120 += 4LL;
    }

    while (v120 != 12);
    uint64_t v148 = v99;
    if (v121) {
      goto LABEL_132;
    }
    unint64_t v122 = *((void *)&v153 + 1);
    if (!*((void *)&v153 + 1)) {
      goto LABEL_132;
    }
    unsigned int v123 = v80[4];
    unsigned int v124 = v123;
    id v125 = (uint8x8_t)vcnt_s8(*(int8x8_t *)((char *)&v153 + 8));
    v125.i16[0] = vaddlv_u8(v125);
    if (v125.u32[0] > 1uLL)
    {
      unint64_t v126 = v80[4];
    }

    else
    {
      unint64_t v126 = (DWORD2(v153) - 1) & v123;
    }

    unsigned int v127 = *(void ***)(v153 + 8 * v126);
    if (!v127) {
      goto LABEL_132;
    }
    uint64_t v128 = (__int128 *)*v127;
    if (!*v127) {
      goto LABEL_132;
    }
    uint64_t v129 = *((void *)&v153 + 1) - 1LL;
    while (2)
    {
      id v130 = *((void *)v128 + 1);
      if (v130 != v123)
      {
        if (v125.u32[0] > 1uLL)
        {
          if (v130 >= *((void *)&v153 + 1)) {
            v130 %= *((void *)&v153 + 1);
          }
        }

        else
        {
          v130 &= v129;
        }

        if (v130 != v126) {
          goto LABEL_132;
        }
LABEL_206:
        uint64_t v128 = *(__int128 **)v128;
        if (!v128) {
          goto LABEL_132;
        }
        continue;
      }

      break;
    }

    if (*((_DWORD *)v128 + 4) != (_DWORD)v123) {
      goto LABEL_206;
    }
    if (v125.u32[0] > 1uLL)
    {
    }

    else
    {
      unsigned int v124 = v129 & v123;
    }

    uint64_t v131 = *(__int128 **)v128;
    uint64_t v132 = *(__int128 **)(v153 + 8 * v124);
    do
    {
      uint64_t v133 = v132;
      uint64_t v132 = *(__int128 **)v132;
    }

    while (v132 != v128);
    if (v133 == &v154) {
      goto LABEL_225;
    }
    uint64_t v134 = *((void *)v133 + 1);
    if (v125.u32[0] > 1uLL)
    {
      if (v134 >= *((void *)&v153 + 1)) {
        v134 %= *((void *)&v153 + 1);
      }
    }

    else
    {
      v134 &= v129;
    }

    if (v134 == v124)
    {
LABEL_227:
      if (v131)
      {
        __int128 v135 = *((void *)v131 + 1);
        goto LABEL_229;
      }
    }

    else
    {
LABEL_225:
      if (!v131) {
        goto LABEL_226;
      }
      __int128 v135 = *((void *)v131 + 1);
      if (v125.u32[0] > 1uLL)
      {
        __int128 v136 = *((void *)v131 + 1);
        if (v135 >= *((void *)&v153 + 1)) {
          __int128 v136 = v135 % *((void *)&v153 + 1);
        }
      }

      else
      {
        __int128 v136 = v135 & v129;
      }

      if (v136 != v124)
      {
LABEL_226:
        *(void *)(v153 + 8 * v124) = 0LL;
        uint64_t v131 = *(__int128 **)v128;
        goto LABEL_227;
      }

LABEL_164:
  v514 = objc_alloc_init(&OBJC_CLASS___NSMutableDictionary);
  v505 = objc_alloc_init(&OBJC_CLASS___NSMutableDictionary);
  v528 = objc_alloc_init(&OBJC_CLASS___NSMutableDictionary);
  v523 = objc_alloc_init(&OBJC_CLASS___NSMutableDictionary);
  if ((v177 & 1) == 0)
  {
    uint64_t v178 = 0LL;
    do
    {
      if (v151[v178])
      {
        unsigned int v179 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLongLong:](&OBJC_CLASS___NSNumber, "numberWithUnsignedLongLong:"));
        id v180 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedChar:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedChar:",  v178));
        -[NSMutableDictionary setObject:forKeyedSubscript:](v528, "setObject:forKeyedSubscript:", v179, v180);
      }

      ++v178;
    }

    while (v175 != v178);
    uint64_t v181 = 0LL;
    do
    {
      if (v152[v181])
      {
        id v182 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLongLong:](&OBJC_CLASS___NSNumber, "numberWithUnsignedLongLong:"));
        id v183 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedChar:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedChar:",  v181));
        -[NSMutableDictionary setObject:forKeyedSubscript:](v523, "setObject:forKeyedSubscript:", v182, v183);
      }

      ++v181;
    }

    while (v176 != v181);
    uint64_t v184 = 0LL;
    do
    {
      if (v150[v184])
      {
        if ((((unint64_t)v518[v184 >> 6] >> v184) & 1) != 0)
        {
          uint64_t v185 = obja[v184];
          v186 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:"));
          *(void *)__dst = v186;
          v187 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  v185));
          *(void *)&__dst[8] = v187;
          id v188 = (void *)objc_claimAutoreleasedReturnValue( +[NSArray arrayWithObjects:count:]( &OBJC_CLASS___NSArray,  "arrayWithObjects:count:",  __dst,  2LL));
          id v189 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedChar:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedChar:",  v184));
          -[NSMutableDictionary setObject:forKeyedSubscript:](v514, "setObject:forKeyedSubscript:", v188, v189);
        }

        else
        {
          v186 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:"));
          v187 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedChar:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedChar:",  v184));
          -[NSMutableDictionary setObject:forKeyedSubscript:](v505, "setObject:forKeyedSubscript:", v186, v187);
        }
      }

      ++v184;
    }

    while (v174 != v184);
  }

  id v190 = -[NSMutableDictionary copy](v514, "copy");
  id v191 = (void *)v533;
  *(void *)&__int128 v533 = v190;

  id v192 = -[NSMutableDictionary copy](v505, "copy");
  id v193 = (void *)*((void *)&v533 + 1);
  *((void *)&v533 + 1) = v192;

  id v194 = -[NSMutableDictionary copy](v528, "copy");
  unint64_t v195 = (void *)v534;
  *(void *)&__int128 v534 = v194;

  id v196 = -[NSMutableDictionary copy](v523, "copy");
  id v197 = (void *)*((void *)&v534 + 1);
  *((void *)&v534 + 1) = v196;

  uint64_t v198 = (void *)v535;
  *(void *)&__int128 v535 = &__NSDictionary0__struct;

  v199 = (void *)*((void *)&v535 + 1);
  *((void *)&v535 + 1) = &__NSDictionary0__struct;

  BOOL v200 = -[NSMutableDictionary count](v505, "count") == 0LL;
LABEL_181:
  BOOL objb = v200;

  uint64_t v515 = *(void *)v531;
  InclusiveRange = GroupBuilder_findInclusiveRange( *(_DWORD *)(*(void *)(*(void *)v531 + 112LL) + 12LL),  *(void **)(*(void *)(*(void *)v531 + 112LL) + 24LL),  v531[5620]);
  if (InclusiveRange)
  {
    do
    {
      BOOL CommandEncoder = IsFuncEnumCreateCommandEncoder(*((_DWORD *)InclusiveRange + 7));
      if (CommandEncoder) {
        break;
      }
      uint64_t v203 = *((unsigned int *)InclusiveRange + 4);
      if ((_DWORD)v203) {
        InclusiveRange -= 4 * v203;
      }
      else {
        InclusiveRange = 0LL;
      }
    }

    while (InclusiveRange);
    char v204 = !CommandEncoder;
  }

  else
  {
    char v204 = 1;
  }

  if (objb)
  {
    v506 = 0LL;
    v519 = 0LL;
  }

  else
  {
    v519 = objc_alloc_init(&OBJC_CLASS___NSMutableDictionary);
    v506 = objc_alloc_init(&OBJC_CLASS___NSMutableDictionary);
  }

  v529 = objc_alloc_init(&OBJC_CLASS___NSMutableOrderedSet);
  v524 = objc_alloc_init(&OBJC_CLASS___NSMutableOrderedSet);
  if ((v204 & 1) != 0)
  {
    BOOL v205 = 0;
  }

  else
  {
    unint64_t v206 = *InclusiveRange + 1LL;
    if (v206 >= InclusiveRange[1])
    {
      BOOL v490 = 0;
    }

    else
    {
      BOOL v490 = 0;
      uint64_t v488 = (int)(v499 - 1);
      do
      {
        uint64_t v207 = *(void *)(*(void *)(v515 + 120) + 24LL);
        uint64_t v208 = v207 + (v206 << 6);
        int v211 = *(_DWORD *)(v208 + 8);
        __int128 v210 = (int *)(v208 + 8);
        int v209 = v211;
        if (v211 > -15820)
        {
          switch(v209)
          {
            case -15819:
              __int128 v231 = GTTraceFunc_argumentBytesWithMap( (void *)(v207 + (v206 << 6)),  *(unsigned __int8 *)(v207 + (v206 << 6) + 13),  *(void *)(v515 + 16));
              else {
                uint64_t v232 = qword_317030[v488];
              }
              if ((*((void *)v231 + 3) & v232) != 0)
              {
                id v241 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  *((void *)v231 + 1)));
                -[NSMutableOrderedSet addObject:](v529, "addObject:", v241);
              }

              break;
            case -15818:
              id v233 = GTTraceFunc_argumentBytesWithMap( (void *)(v207 + (v206 << 6)),  *(unsigned __int8 *)(v207 + (v206 << 6) + 13),  *(void *)(v515 + 16));
              v234 = v233;
              else {
                uint64_t v235 = qword_317030[v488];
              }
              if ((*((void *)v233 + 3) & v235) != 0)
              {
                id v242 = GTTraceFunc_argumentBytesWithMap( (void *)(v207 + (v206 << 6)),  v233[32],  *(void *)(v515 + 16));
                if (*((void *)v234 + 1))
                {
                  id v243 = v242;
                  unint64_t v244 = 0LL;
                  do
                  {
                    uint64_t v245 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  *(void *)&v243[8 * v244]));
                    -[NSMutableOrderedSet addObject:](v529, "addObject:", v245);

                    ++v244;
                  }

                  while (v244 < *((void *)v234 + 1));
                }
              }

              break;
            case -15732:
              BOOL v490 = *((_DWORD *)GTTraceFunc_argumentBytesWithMap( (void *)(v207 + (v206 << 6)),  *(unsigned __int8 *)(v207 + (v206 << 6) + 13),  *(void *)(v515 + 16))
                     + 2) != 0;
              break;
          }
        }

        else
        {
          switch(v209)
          {
            case -16047:
            case -16043:
              __int128 v212 = +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  *((void *)GTTraceFunc_argumentBytesWithMap( (void *)(v207 + (v206 << 6)),  *(unsigned __int8 *)(v207 + (v206 << 6) + 13),  *(void *)(v515 + 16))
                       + 1));
              __int128 v213 = (void *)objc_claimAutoreleasedReturnValue(v212);
              -[NSMutableOrderedSet addObject:](v529, "addObject:", v213);

              break;
            case -16046:
              __int128 v221 = GTTraceFunc_argumentBytesWithMap( (void *)(v207 + (v206 << 6)),  *(unsigned __int8 *)(v207 + (v206 << 6) + 13),  *(void *)(v515 + 16));
              __int128 v222 = GTTraceFunc_argumentBytesWithMap( (void *)(v207 + (v206 << 6)),  v221[24],  *(void *)(v515 + 16));
              if (*((void *)v221 + 1))
              {
                __int128 v223 = v222;
                unint64_t v224 = 0LL;
                do
                {
                  __int128 v225 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  *(void *)&v223[8 * v224]));
                  -[NSMutableOrderedSet addObject:](v529, "addObject:", v225);

                  ++v224;
                }

                while (v224 < *((void *)v221 + 1));
              }

              break;
            case -16045:
            case -16041:
              __int128 v214 = +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  *((void *)GTTraceFunc_argumentBytesWithMap( (void *)(v207 + (v206 << 6)),  *(unsigned __int8 *)(v207 + (v206 << 6) + 13),  *(void *)(v515 + 16))
                       + 1));
              __int128 v215 = (void *)objc_claimAutoreleasedReturnValue(v214);
              -[NSMutableOrderedSet addObject:](v524, "addObject:", v215);

              break;
            case -16044:
              __int128 v216 = GTTraceFunc_argumentBytesWithMap( (void *)(v207 + (v206 << 6)),  *(unsigned __int8 *)(v207 + (v206 << 6) + 13),  *(void *)(v515 + 16));
              __int128 v217 = GTTraceFunc_argumentBytesWithMap( (void *)(v207 + (v206 << 6)),  v216[16],  *(void *)(v515 + 16));
              if (*((void *)v216 + 1))
              {
                __int128 v218 = v217;
                unint64_t v219 = 0LL;
                do
                {
                  __int128 v220 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  *(void *)&v218[8 * v219]));
                  -[NSMutableOrderedSet addObject:](v524, "addObject:", v220);

                  ++v219;
                }

                while (v219 < *((void *)v216 + 1));
              }

              break;
            case -16042:
              id v236 = GTTraceFunc_argumentBytesWithMap( (void *)(v207 + (v206 << 6)),  *(unsigned __int8 *)(v207 + (v206 << 6) + 13),  *(void *)(v515 + 16));
              id v237 = GTTraceFunc_argumentBytesWithMap( (void *)(v207 + (v206 << 6)),  v236[24],  *(void *)(v515 + 16));
              if (*((void *)v236 + 1))
              {
                v238 = v237;
                unint64_t v239 = 0LL;
                do
                {
                  v240 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  *(void *)&v238[8 * v239]));
                  -[NSMutableOrderedSet addObject:](v529, "addObject:", v240);

                  ++v239;
                }

                while (v239 < *((void *)v236 + 1));
              }

              break;
            case -16040:
              __int128 v226 = GTTraceFunc_argumentBytesWithMap( (void *)(v207 + (v206 << 6)),  *(unsigned __int8 *)(v207 + (v206 << 6) + 13),  *(void *)(v515 + 16));
              __int128 v227 = GTTraceFunc_argumentBytesWithMap( (void *)(v207 + (v206 << 6)),  v226[16],  *(void *)(v515 + 16));
              if (*((void *)v226 + 1))
              {
                __int128 v228 = v227;
                unint64_t v229 = 0LL;
                do
                {
                  __int128 v230 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  *(void *)&v228[8 * v229]));
                  -[NSMutableOrderedSet addObject:](v524, "addObject:", v230);

                  ++v229;
                }

                while (v229 < *((void *)v226 + 1));
              }

              break;
            default:
              break;
          }
        }

        if (!objb)
        {
          int v246 = *v210;
          switch(*v210)
          {
            case -15456:
              if (v499 == 2) {
                goto LABEL_260;
              }
              break;
            case -15455:
              if (v499 == 2)
              {
                v264 = GTTraceFunc_argumentBytesWithMap( (void *)(v207 + (v206 << 6)),  *(unsigned __int8 *)(v207 + (v206 << 6) + 13),  *(void *)(v515 + 16));
                v265 = GTTraceFunc_argumentBytesWithMap( (void *)(v207 + (v206 << 6)),  v264[24],  *(void *)(v515 + 16));
                uint64_t v266 = *((void *)v264 + 2);
                if (v266)
                {
                  v267 = v265;
                  uint64_t v268 = *((void *)v264 + 1);
                  do
                  {
                    uint64_t v269 = *(void *)v267;
                    v267 += 8;
                    v270 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  v269));
                    v271 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  v268));
                    -[NSMutableDictionary setObject:forKeyedSubscript:]( v519,  "setObject:forKeyedSubscript:",  v270,  v271);

                    ++v268;
                    --v266;
                  }

                  while (v266);
                }
              }

              break;
            case -15454:
            case -15453:
            case -15452:
            case -15449:
            case -15448:
            case -15447:
              break;
            case -15451:
              if (v499 == 3) {
                goto LABEL_260;
              }
              break;
            case -15450:
              if (v499 == 3)
              {
                v256 = GTTraceFunc_argumentBytesWithMap( (void *)(v207 + (v206 << 6)),  *(unsigned __int8 *)(v207 + (v206 << 6) + 13),  *(void *)(v515 + 16));
                v257 = GTTraceFunc_argumentBytesWithMap( (void *)(v207 + (v206 << 6)),  v256[24],  *(void *)(v515 + 16));
                uint64_t v258 = *((void *)v256 + 2);
                if (!v258) {
                  goto LABEL_260;
                }
                v259 = v257;
                uint64_t v260 = *((void *)v256 + 1);
                do
                {
                  uint64_t v261 = *(void *)v259;
                  v259 += 8;
                  v262 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  v261));
                  uint64_t v263 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  v260));
                  -[NSMutableDictionary setObject:forKeyedSubscript:](v519, "setObject:forKeyedSubscript:", v262, v263);

                  ++v260;
                  --v258;
                }

                while (v258);
                goto LABEL_250;
              }

              break;
            case -15446:
              if (v499 == 1) {
                goto LABEL_260;
              }
              break;
            case -15445:
              if (v499 == 1)
              {
                v275 = GTTraceFunc_argumentBytesWithMap( (void *)(v207 + (v206 << 6)),  *(unsigned __int8 *)(v207 + (v206 << 6) + 13),  *(void *)(v515 + 16));
                uint64_t v276 = GTTraceFunc_argumentBytesWithMap( (void *)(v207 + (v206 << 6)),  v275[24],  *(void *)(v515 + 16));
                uint64_t v277 = *((void *)v275 + 2);
                if (v277)
                {
                  __int128 v278 = v276;
                  uint64_t v279 = *((void *)v275 + 1);
                  do
                  {
                    uint64_t v280 = *(void *)v278;
                    v278 += 8;
                    __int128 v281 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  v280));
                    __int128 v282 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  v279));
                    -[NSMutableDictionary setObject:forKeyedSubscript:]( v519,  "setObject:forKeyedSubscript:",  v281,  v282);

                    ++v279;
                    --v277;
                  }

                  while (v277);
                }
              }

              break;
            default:
              if (v246 == -15581)
              {
LABEL_250:
                if (v499 == 3)
                {
LABEL_260:
                  uint64_t v272 = GTTraceFunc_argumentBytesWithMap( (void *)(v207 + (v206 << 6)),  *(unsigned __int8 *)(v207 + (v206 << 6) + 13),  *(void *)(v515 + 16));
                  v273 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  *((void *)v272 + 1)));
                  v274 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  *((void *)v272 + 2)));
                  -[NSMutableDictionary setObject:forKeyedSubscript:](v519, "setObject:forKeyedSubscript:", v273, v274);
                }
              }

              else if (v246 == -15580 && v499 == 3)
              {
                uint64_t v248 = GTTraceFunc_argumentBytesWithMap( (void *)(v207 + (v206 << 6)),  *(unsigned __int8 *)(v207 + (v206 << 6) + 13),  *(void *)(v515 + 16));
                int v249 = GTTraceFunc_argumentBytesWithMap( (void *)(v207 + (v206 << 6)),  v248[24],  *(void *)(v515 + 16));
                uint64_t v250 = *((void *)v248 + 2);
                if (v250)
                {
                  BOOL v251 = v249;
                  uint64_t v252 = *((void *)v248 + 1);
                  do
                  {
                    uint64_t v253 = *(void *)v251;
                    v251 += 8;
                    uint64_t v254 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  v253));
                    v255 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  v252));
                    -[NSMutableDictionary setObject:forKeyedSubscript:]( v519,  "setObject:forKeyedSubscript:",  v254,  v255);

                    ++v252;
                    --v250;
                  }

                  while (v250);
                }
              }

              break;
          }
        }

        ++v206;
      }

      while (v206 < InclusiveRange[1]);
    }

    BOOL v205 = v490;
  }

  if (!objb && (-[NSMutableDictionary count](v519, "count") || -[NSMutableDictionary count](v506, "count")))
  {
    id v283 = [*((id *)&v533 + 1) mutableCopy];
    __int128 v573 = 0u;
    __int128 v574 = 0u;
    __int128 v571 = 0u;
    __int128 v572 = 0u;
    __int128 v284 = v519;
    id v285 = -[NSMutableDictionary countByEnumeratingWithState:objects:count:]( v284,  "countByEnumeratingWithState:objects:count:",  &v571,  __dst,  16LL);
    if (v285)
    {
      uint64_t v286 = *(void *)v572;
      do
      {
        for (int j = 0LL; j != v285; int j = (char *)j + 1)
        {
          if (*(void *)v572 != v286) {
            objc_enumerationMutation(v284);
          }
          [v283 removeObjectForKey:*(void *)(*((void *)&v571 + 1) + 8 * (void)j)];
        }

        id v285 = -[NSMutableDictionary countByEnumeratingWithState:objects:count:]( v284,  "countByEnumeratingWithState:objects:count:",  &v571,  __dst,  16LL);
      }

      while (v285);
    }

    __int128 v565 = 0u;
    __int128 v564 = 0u;
    __int128 v563 = 0u;
    __int128 v562 = 0u;
    __int128 v288 = v506;
    id v289 = -[NSMutableDictionary countByEnumeratingWithState:objects:count:]( v288,  "countByEnumeratingWithState:objects:count:",  &v562,  &v558,  16LL);
    if (v289)
    {
      uint64_t v290 = *(void *)v563;
      do
      {
        for (unint64_t k = 0LL; k != v289; unint64_t k = (char *)k + 1)
        {
          if (*(void *)v563 != v290) {
            objc_enumerationMutation(v288);
          }
          [v283 removeObjectForKey:*(void *)(*((void *)&v562 + 1) + 8 * (void)k)];
        }

        id v289 = -[NSMutableDictionary countByEnumeratingWithState:objects:count:]( v288,  "countByEnumeratingWithState:objects:count:",  &v562,  &v558,  16LL);
      }

      while (v289);
    }

    id v292 = [v283 copy];
    __int128 v293 = (void *)*((void *)&v533 + 1);
    *((void *)&v533 + 1) = v292;

    id v294 = -[NSMutableDictionary copy](v284, "copy");
    __int128 v295 = (void *)v535;
    *(void *)&__int128 v535 = v294;

    id v296 = -[NSMutableDictionary copy](v288, "copy");
    __int128 v297 = (void *)*((void *)&v535 + 1);
    *((void *)&v535 + 1) = v296;
  }

  uint64_t v298 = objc_claimAutoreleasedReturnValue(-[NSMutableOrderedSet array](v524, "array"));
  v299 = (void *)v532;
  *(void *)&__int128 v532 = v298;

  uint64_t v300 = objc_claimAutoreleasedReturnValue(-[NSMutableOrderedSet array](v529, "array"));
  uint64_t v301 = (void *)*((void *)&v532 + 1);
  *((void *)&v532 + 1) = v300;

  char v536 = v536 & 0xFE | v205;
  __int128 v537 = v494;
  v516 = (void *)objc_claimAutoreleasedReturnValue([*((id *)&v546 + 1) objectForKeyedSubscript:@"Program"]);
  v507 = (void *)objc_claimAutoreleasedReturnValue([v516 objectForKeyedSubscript:@"Stitching"]);
  if ([v507 count])
  {
    v530 = v507;
    id v520 = -[NSDictionary copy](v538, "copy");
    v525 = (void *)objc_claimAutoreleasedReturnValue( -[NSMutableDictionary objectForKeyedSubscript:]( v530,  "objectForKeyedSubscript:",  @"DAGMetalLibs"));
    if ((GTShaderDebuggerMakeRuntimeLibrariesFromMetallibs((id *)&v531, v525, a3) & 1) == 0)
    {
      v327 = (NSDictionary *)[v520 copy];
      v328 = v538;
      v538 = v327;

      goto LABEL_421;
    }

    v500 = (void *)objc_claimAutoreleasedReturnValue( -[NSMutableDictionary objectForKeyedSubscript:]( v530,  "objectForKeyedSubscript:",  @"DAGFunctionUIDs"));
    if ((GTShaderDebuggerMakeRuntimeFunctions((uint64_t)&v531, v500, a3) & 1) == 0)
    {
      v329 = (NSDictionary *)[v520 copy];
      v330 = v538;
      v538 = v329;

      goto LABEL_421;
    }

    id v302 = -[NSDictionary copy](v538, "copy");
    v303 = (void *)objc_claimAutoreleasedReturnValue([v520 allKeys]);
    v304 = (void *)objc_claimAutoreleasedReturnValue([v302 allKeys]);
    id v305 = [v304 mutableCopy];

    [v305 removeObjectsInArray:v303];
    id v491 = [v305 copy];

    id v306 = (id)objc_claimAutoreleasedReturnValue( -[NSMutableDictionary objectForKeyedSubscript:]( v530,  "objectForKeyedSubscript:",  @"LibraryUIDs"));
    id v495 = -[NSDictionary mutableCopy](v538, "mutableCopy");
    v497 = (void *)objc_claimAutoreleasedReturnValue([*((id *)v531 + 1) defaultDevice]);
    v307 = *(uint64_t **)(*(void *)v531 + 40LL);
    unint64_t v308 = **((void **)&v537 + 1);
    __int128 v558 = 0u;
    __int128 v559 = 0u;
    __int128 v560 = 0u;
    __int128 v561 = 0u;
    objc = (NSDictionary *)v306;
    id v309 = -[NSDictionary countByEnumeratingWithState:objects:count:]( objc,  "countByEnumeratingWithState:objects:count:",  &v558,  __dst,  16LL);
    if (v309)
    {
      uint64_t v310 = *(void *)v559;
LABEL_293:
      uint64_t v311 = 0LL;
      while (1)
      {
        if (*(void *)v559 != v310) {
          objc_enumerationMutation(objc);
        }
        v312 = *(void **)(*((void *)&v558 + 1) + 8 * v311);
        id v313 = _ObjectUIDsWithAliasID((void **)&v531, (uint64_t)[v312 unsignedLongLongValue]);
        v314 = (void *)objc_claimAutoreleasedReturnValue(v313);
        if (![v314 count])
        {
          v331 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"Internal error: Library '%@' not found",  v312));
          if (a3)
          {
            id v332 = GTShaderDebuggerMakeError(1u, v331, 0LL, 0LL, 0LL);
            *a3 = (id)objc_claimAutoreleasedReturnValue(v332);
          }

          goto LABEL_318;
        }

        v315 = (void *)objc_claimAutoreleasedReturnValue([v314 firstObject]);
        uint64_t v316 = GTMTLSMContext_lastObject(*v307, (uint64_t)[v315 unsignedLongLongValue], v308);

        if (!v316) {
          break;
        }
        if (*(_BYTE *)(v316 + 161) != 6)
        {
          v331 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"Internal error: Unexpected library data type (%d)",  *(unsigned __int8 *)(v316 + 161)));
          if (a3)
          {
            id v334 = GTShaderDebuggerMakeError(1u, v331, 0LL, 0LL, 0LL);
            *a3 = (id)objc_claimAutoreleasedReturnValue(v334);
          }

            unsigned int v142 = apr_array_make(v98, 0, 32);
            v696.st_mtimespec.tv_nsec = (uint64_t)v142;
            unint64_t v143 = apr_array_make(v98, 0, 32);
LABEL_165:
            id v150 = (uint64_t)v143;
            v696.st_ctimespec.tv_sec = (__darwin_time_t)v143;
            if (v137->nelts >= 1)
            {
              unint64_t v151 = 0LL;
              uint64_t v152 = 16LL;
              do
              {
                elts = v137->elts;
                char v154 = (uint64_t *)GetAliasStream2((uint64_t)&v695, *(void *)&elts[v152]);
                if (v154) {
                  int v155 = *v154;
                }
                else {
                  int v155 = 0LL;
                }
                *(void *)&elts[v152] = v155;
                ++v151;
                v152 += 24LL;
              }

              while (v151 < v137->nelts);
            }

            ConvertUniqueIdentifierResources((uint64_t *)&v695.st_dev, (uint64_t)UniqueIdentifierResourceGroup);
            ConvertUniqueIdentifierResources((uint64_t *)&v695.st_dev, (uint64_t)arrc);
            ConvertUniqueIdentifierResources((uint64_t *)&v695.st_dev, (uint64_t)v663);
            ConvertUniqueIdentifierResources((uint64_t *)&v695.st_dev, (uint64_t)v644);
            ConvertUniqueIdentifierResources((uint64_t *)&v695.st_dev, tv_nsec);
            ConvertUniqueIdentifierResources((uint64_t *)&v695.st_dev, (uint64_t)v141);
            ConvertUniqueIdentifierResources((uint64_t *)&v695.st_dev, (uint64_t)v142);
            ConvertUniqueIdentifierResources((uint64_t *)&v695.st_dev, v150);
            GTMTLIndirectResources_optimizeByKey((uint64_t *)buf, (uint64_t *)&v696.st_dev, 0, v98);
            *(_OWORD *)(v647 + 40) = v698;
            *(_OWORD *)(v647 + 56) = v699;
            *(_OWORD *)(v647 + 72) = v700;
            *((void *)v647 + 11) = v701;
            *(_OWORD *)(v647 + _Block_object_dispose(&STACK[0x3B0], 8) = *(_OWORD *)buf;
            *(_OWORD *)(v647 + 24) = *(_OWORD *)&buf[16];
            apr_pool_clear(v646);
            if (v689)
            {
              id v156 = GTCaptureArchive_readData( *(const char ***)&v695.st_dev,  (apr_pool_t **)v695.st_ino,  v689,  v98,  0LL);
              unint64_t v158 = dispatch_data_create(v156, v157, 0LL, &__block_literal_global_2002);
              id v159 = (void *)*((void *)v647 + 15);
              *((void *)v647 + 15) = v158;

              apr_pool_cleanup_register( v98,  v647,  (apr_status_t (__cdecl *)(void *))DYMTLIndirectArgumentBufferManager_cleanup,  v160);
            }

            double v68 = v641;
            BOOL v64 = v642;
            double v69 = v645;
            uint64_t v72 = v650;
            double v73 = ht;
            double v75 = v653;
            do
              id v161 = __ldaxr(v654);
            while (__stlxr(v161 + 1, v654));
            __int128 v88 = v679;
LABEL_196:
            pool_high = HIDWORD(v88->pool);
            goto LABEL_197;
          }
        }

        uint64_t v32 = v664;
        unint64_t v141 = apr_array_make(v98, 0, 32);
        v696.st_mtimespec.tv_sec = (__darwin_time_t)v141;
        goto LABEL_164;
      }

      GTTraceFbufToFunc(&v695, v89);
      unint64_t v144 = HIDWORD(v679->pool);
      int FuncEnumConstructorType = GetFuncEnumConstructorType(v144);
      if (FuncEnumConstructorType == 51 || FuncEnumConstructorType == 25)
      {
        unint64_t v146 = (LODWORD(v679->pool) - 36);
        *(void *)&v696.st_dev = 0LL;
        FBDecoder_DecodeArguments((unsigned int *)&v696, (uint64_t)&v679[1].pool + 4, v146, (uint64_t)buf, 0x10uLL);
        *(_DWORD *)&v696.st_mode = 0;
        FBDecoder_DecodeArguments((unsigned int *)&v696, (uint64_t)&v679[1].pool + 4, v146, (uint64_t)buf, 0x10uLL);
        *(void *)&v696.st_dev = **(void **)buf;
        uint64_t v147 = (apr_hash_t *)*((void *)v682 + 18);
        uint64_t v148 = *(uint64_t **)(*(void *)(*find_entry(*((void *)v682 + 3), &v696, 8uLL, 0LL) + 32LL) + 8LL);
        if (v148) {
          v149 = *v148;
        }
        else {
          v149 = 0LL;
        }
        entry = find_entry((uint64_t)v147, &v696, 8uLL, 0LL);
        if (*entry)
        {
          uint64_t v163 = *(void **)(*entry + 32LL);
          if (v163)
          {
            *(void *)buf = *v163;
            apr_hash_set(v147, buf, 8LL, 0LL);
            *uint64_t v163 = v149;
            apr_hash_set(v147, v163, 8LL, v163);
          }
        }

        unint64_t v144 = HIDWORD(v679->pool);
        double v73 = ht;
      }

      id v164 = (uint64_t)v673 - v64;
      if (v144 == -12281
        || (IsFuncEnumPushDebugGroup(v144) & 1) != 0
        || IsFuncEnumCreateCommandEncoder(v144)
        || (uint64_t v165 = GetFuncEnumConstructorType(v144), v165 == 51)
        || v165 == 25)
      {
        id v166 = v692->nelts;
        if (v166) {
          id v167 = &v692->elts[8 * v166 - 8];
        }
        else {
          id v167 = 0LL;
        }
        id v168 = apr_array_push(v692);
        id v169 = v691;
        char *v168 = v691->nelts;
        v168[1] = v144;
        uint64_t v170 = apr_array_push(v169);
        v170[7] = v168[1];
        if (v167) {
          uint64_t v171 = *v168 - *(_DWORD *)v167;
        }
        else {
          uint64_t v171 = 0;
        }
        id v172 = v679;
        v170[4] = v171;
        *(void *)uint64_t v170 = v164;
      }

      else
      {
        if (v144 != -12280 && (IsFuncEnumPopDebugGroup(v144) & 1) == 0)
        {
          id v197 = IsFuncEnumEndEncoding(v144);
          id v172 = v679;
          if ((v197 & 1) == 0)
          {
            if (v144 > -15344)
            {
            }

            else if (v144 != -16361 && v144 != -16202 && v144 != -15908)
            {
              goto LABEL_193;
            }
          }
        }

        if ((IsFuncEnumEndEncoding(v144) & 1) != 0) {
          goto LABEL_263;
        }
        if (v144 > -15344)
        {
          if ((v144 + 15343) <= 0x1B && ((1 << (v144 - 17)) & 0xA000001) != 0)
          {
LABEL_263:
            while (1)
            {
              uint64_t v198 = v692;
              if (!v692) {
                break;
              }
              v199 = v692->nelts;
              GroupBuilder_popGroup((uint64_t)v690, v164);
            }

LABEL_318:
LABEL_327:
LABEL_328:
          int v326 = 0;
          v325 = objc;
          goto LABEL_329;
        }

        uint64_t v317 = *(void *)(v316 + 72);
        if (!v317)
        {
          if (a3)
          {
            uint64_t v335 = *(void *)(v316 + 80);
            if (v335) {
              v336 = @"-[MTLDevice newLibraryWithDAG:functions:error:] is not supported";
            }
            else {
              v336 = @"Internal error: Failed to read stitched library descriptor";
            }
            if (v335) {
              unsigned int v337 = 4;
            }
            else {
              unsigned int v337 = 1;
            }
            id v338 = GTShaderDebuggerMakeError(v337, v336, 0LL, 0LL, 0LL);
            *a3 = (id)objc_claimAutoreleasedReturnValue(v338);
          }

          goto LABEL_327;
        }

        MTLStitchedLibraryDescriptor = MakeMTLStitchedLibraryDescriptor(v317, v538);
        v319 = (void *)objc_claimAutoreleasedReturnValue(MTLStitchedLibraryDescriptor);
        *(void *)&__int128 v571 = 0LL;
        id v320 = [v497 newLibraryWithStitchedDescriptor:v319 error:&v571];
        id v321 = (id)v571;
        if (v320)
        {
          v322 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  *(void *)(v316 + 8)));
          [v495 setObject:v320 forKeyedSubscript:v322];
        }

        else if (a3)
        {
          id v323 = GTShaderDebuggerMakeError( 1u,  @"Internal error: Failed to set up runtime stitched library",  0LL,  v321,  0LL);
          *a3 = (id)objc_claimAutoreleasedReturnValue(v323);
        }

        if (!v320) {
          goto LABEL_328;
        }
        if (v309 == (id)++v311)
        {
          id v309 = -[NSDictionary countByEnumeratingWithState:objects:count:]( objc,  "countByEnumeratingWithState:objects:count:",  &v558,  __dst,  16LL);
          if (v309) {
            goto LABEL_293;
          }
          goto LABEL_307;
        }
      }

      v331 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"Internal error: Library '%@' not found",  v312));
      if (a3)
      {
        id v333 = GTShaderDebuggerMakeError(1u, v331, 0LL, 0LL, 0LL);
        *a3 = (id)objc_claimAutoreleasedReturnValue(v333);
      }

      goto LABEL_318;
    }

    *(void *)apr_array_push(v32_Block_object_dispose(&STACK[0x3B0], 8) = ",\n"
                                      "\tuint2 gid [[ thread_position_in_grid ]],\n"
                                      "\tushort2 lid [[ thread_position_in_threadgroup ]],\n"
                                      "\t";
    if ((_DWORD)v320) {
      id v346 = "texture2d_array";
    }
    else {
      id v346 = "texture2d";
    }
    *(void *)apr_array_push(v32_Block_object_dispose(&STACK[0x3B0], 8) = v346;
    *(void *)apr_array_push(v32_Block_object_dispose(&STACK[0x3B0], 8) = "<";
    uint64_t v347 = BYTE6(v320) - 3;
    else {
      uint64_t v348 = off_58FB98[(BYTE6(v320) - 3)];
    }
    *(void *)apr_array_push(v32_Block_object_dispose(&STACK[0x3B0], 8) = v348;
    *(void *)apr_array_push(v32_Block_object_dispose(&STACK[0x3B0], 8) = ", access::write> imageBlockData [[ texture(0) ]])\n";
    *(void *)apr_array_push(v32_Block_object_dispose(&STACK[0x3B0], 8) = "{\n";
    *(void *)apr_array_push(v32_Block_object_dispose(&STACK[0x3B0], 8) = "\tthreadgroup_imageblock ImageblockMaster* ib = imageBlock.data(lid);\n";
    v349 = apr_array_push(v328);
    if ((_DWORD)v320)
    {
      *v349 = "\tfor (int uint64_t i = 0; i < ";
      id v350 = apr_psprintf(v328->pool, "%u", v320);
      *(void *)apr_array_push(v32_Block_object_dispose(&STACK[0x3B0], 8) = v350;
      *(void *)apr_array_push(v32_Block_object_dispose(&STACK[0x3B0], 8) = "; i++) {\n";
      *(void *)apr_array_push(v32_Block_object_dispose(&STACK[0x3B0], 8) = "\t\t";
      else {
        v351 = off_58FD48[(BYTE6(v320) - 3)];
      }
      uint64_t v352 = v403;
      *(void *)apr_array_push(v32_Block_object_dispose(&STACK[0x3B0], 8) = v351;
      *(void *)apr_array_push(v32_Block_object_dispose(&STACK[0x3B0], 8) = " currData = ib->";
      *(void *)apr_array_push(v32_Block_object_dispose(&STACK[0x3B0], 8) = v398;
      *(void *)apr_array_push(v32_Block_object_dispose(&STACK[0x3B0], 8) = "[i];\n";
      *(void *)apr_array_push(v32_Block_object_dispose(&STACK[0x3B0], 8) = "\t\timageBlockData.write(";
      GenerateStringForWritingDataToTexture(v328, (uint64_t)__dst);
      *(void *)apr_array_push(v32_Block_object_dispose(&STACK[0x3B0], 8) = ", gid, i);\n";
      uint64_t v354 = apr_array_push(v328);
      v355 = "\t}\n";
    }

    else
    {
      void *v349 = "\t";
      uint64_t v352 = v403;
      if (v347 > 0x35u) {
        v353 = 0LL;
      }
      else {
        v353 = off_58FD48[v347];
      }
      *(void *)apr_array_push(v32_Block_object_dispose(&STACK[0x3B0], 8) = v353;
      *(void *)apr_array_push(v32_Block_object_dispose(&STACK[0x3B0], 8) = " currData = ib->";
      *(void *)apr_array_push(v32_Block_object_dispose(&STACK[0x3B0], 8) = v398;
      *(void *)apr_array_push(v32_Block_object_dispose(&STACK[0x3B0], 8) = ";\n";
      *(void *)apr_array_push(v32_Block_object_dispose(&STACK[0x3B0], 8) = "\timageBlockData.write(";
      GenerateStringForWritingDataToTexture(v328, (uint64_t)__dst);
      uint64_t v354 = apr_array_push(v328);
      v355 = ", gid);\n";
    }

    *uint64_t v354 = v355;
    *(void *)apr_array_push(v32_Block_object_dispose(&STACK[0x3B0], 8) = "}\n";
    v357 = +[NSString stringWithUTF8String:]( &OBJC_CLASS___NSString,  "stringWithUTF8String:",  apr_array_pstrcat(v352, v328, v356));
    id v358 = (void *)objc_claimAutoreleasedReturnValue(v357);
    v505[0] = 0LL;
    uint64_t v359 = -[apr_hash_t newLibraryWithSource:options:error:]( htb,  "newLibraryWithSource:options:error:",  v358,  0LL,  v505);
    v360 = v505[0];
    v361 = v360;
    if (v360)
    {
      id v522 = NSUnderlyingErrorKey;
      *(void *)&v487 = v360;
      v362 = (MTLTileRenderPipelineDescriptor *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v487,  &v522,  1LL));
      GTMTLReplay_fillError(&v456, 101, v362);
      GTMTLReplay_handleNSError(v456);
      v363 = 0LL;
      v364 = 1;
    }

    else
    {
      v362 = objc_alloc_init(&OBJC_CLASS___MTLTileRenderPipelineDescriptor);
      -[MTLTileRenderPipelineDescriptor setLabel:]( v362,  "setLabel:",  @"Tile Pipeline for dumping Image Block data");
      id v365 = [v359 newFunctionWithName:@"dumpImageBlockData"];
      -[MTLTileRenderPipelineDescriptor setTileFunction:](v362, "setTileFunction:", v365);

      -[MTLTileRenderPipelineDescriptor setThreadgroupSizeMatchesTileSize:]( v362,  "setThreadgroupSizeMatchesTileSize:",  1LL);
      id v366 = GTMTLReplayController_renderPassDescriptor((uint64_t)a1);
      FillAttachmentPixelFormats(v366, v401[5], v399, v362);
      *(void *)&v487 = 0LL;
      v363 = -[apr_hash_t newRenderPipelineStateWithTileDescriptor:error:]( htb,  "newRenderPipelineStateWithTileDescriptor:error:",  v362,  &v487);
      v367 = (id)v487;
      v368 = v367;
      if (v367)
      {
        v521 = NSUnderlyingErrorKey;
        id v522 = (NSErrorUserInfoKey)v367;
        v369 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v522,  &v521,  1LL));
        GTMTLReplay_fillError(&v456, 101, v369);
        GTMTLReplay_handleNSError(v456);

        v364 = 1;
      }

      else
      {
        v364 = 0;
      }
    }

    if (v364)
    {

      goto LABEL_349;
    }

    v374 = (void *)objc_claimAutoreleasedReturnValue([v406 renderCommandEncoderForKey:a1[1415]]);
    [v374 pushDebugGroup:@"Dump Tile Data"];
    [v374 setRenderPipelineState:v363];
    [v374 setTileTexture:v409 atIndex:0];
    v375 = [v374 tileWidth];
    v376 = [v374 tileHeight];
    *(void *)&v504[0] = v375;
    *((void *)&v504[0] + 1) = v376;
    *(void *)&v504[1] = 1LL;
    [v374 dispatchThreadsPerTile:v504];
    [v374 popDebugGroup];

    goto LABEL_351;
  }

  if ((_DWORD)v11 != 2)
  {
LABEL_34:
    htc = (apr_hash_t *) objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString, "stringWithFormat:", @"kDYMessageFetchResourceObject: %u invalidType", v11));
    GTMTLReplay_handleError( 101,  (uint64_t)-[apr_hash_t UTF8String](htc, "UTF8String"),  "/Library/Caches/com.apple.xbs/Sources/GPUToolsDevice/GPUTools/GTMTLCapture/replayer/GTMTLReplay_harvestResource.m",  (uint64_t)"HarvestResourceObject",  573LL,  32LL);
    uint64_t v36 = &dword_0 + 1;

    goto LABEL_239;
  }

  if (obj == (char *)-1347LL)
  {
    if (s_logUsingOsLog)
    {
      __int128 v89 = gt_tagged_log(1uLL);
      uint64_t v90 = (os_log_s *)objc_claimAutoreleasedReturnValue(v89);
      if (os_log_type_enabled(v90, OS_LOG_TYPE_INFO))
      {
        LOWORD(v504[0]) = 0;
        _os_log_impl(&dword_0, v90, OS_LOG_TYPE_INFO, "Harvesting translation buffer", (uint8_t *)v504, 2u);
      }
    }

    else
    {
      uint64_t v129 = __stdoutp;
      uint64_t v90 = (os_log_s *) objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString, "stringWithFormat:", @"Harvesting translation buffer"));
      fprintf(v129, "%s\n", (const char *)-[os_log_s UTF8String](v90, "UTF8String"));
    }

    apr_pool_create_ex(v505, 0LL, 0LL, v130);
    uint64_t v131 = *a1;
    uint64_t v132 = *((void *)*a1 + 10) + v14;
    uint64_t v133 = v505[0];
    GTMTLSMContext_indirectCommandBufferResources((uint64_t)v504, *((_DWORD ***)*a1 + 5), v132, v505[0]);
    uint64_t v134 = v131[1];
    __int128 v135 = a1[1];
    __int128 v136 = *(void *)&v504[0];
    size_t v137 = apr_array_make(v133, *(_DWORD *)(*(void *)&v504[0] + 12LL), 24);
    hta = apr_hash_make(v133);
    pc = v133;
    int v412 = apr_hash_make(v133);
    if (*(int *)(v136 + 12) >= 1)
    {
      uint64_t v138 = 0LL;
      uint64_t v139 = 16LL;
      do
      {
        id v140 = *(void *)(v136 + 24);
        unint64_t v141 = apr_array_push(v137);
        unsigned int v142 = (void *)objc_claimAutoreleasedReturnValue([v135 bufferForKey:*(void *)(v140 + v139)]);
        unint64_t v143 = DEVICEOBJECT(v142);
        unint64_t v144 = (void *)objc_claimAutoreleasedReturnValue(v143);

        *unint64_t v141 = [v144 gpuAddress];
        v141[1] = [v144 length];
        v141[2] = *(void *)(v140 + v139);

        ++v138;
        v139 += 24LL;
      }

      while (v138 < *(int *)(v136 + 12));
    }

    qsort( v137->elts,  v137->nelts,  v137->elt_size,  (int (__cdecl *)(const void *, const void *))GTMTLGPUAddressResource_compare);
    unsigned int v145 = *((void *)&v504[1] + 1);
    unint64_t v146 = (apr_hash_index_t *)(*((void *)&v504[1] + 1) + 16LL);
    *(void *)(*((void *)&v504[1] + 1) + 24LL) = 0LL;
    *(void *)(v145 + 32) = 0LL;
    *(void *)(v145 + 16) = v145;
    *(_DWORD *)(v145 + 40) = 0;
    uint64_t v147 = apr_hash_next(v146);
    if (v147)
    {
      uint64_t v148 = v147;
      do
      {
        v149 = *(void *)(*((void *)v148 + 1) + 32LL);
        id v150 = apr_palloc(pc, 0x20uLL);
        unint64_t v151 = (void *)objc_claimAutoreleasedReturnValue([v135 renderPipelineStateForKey:*(void *)(v149 + 8)]);
        uint64_t v152 = DEVICEOBJECT(v151);
        uint64_t v153 = (void *)objc_claimAutoreleasedReturnValue(v152);

        uint64_t *v150 = [v153 uniqueIdentifier];
        v150[1] = *(void *)(v149 + 8);
        v150[2] = [v153 gpuResourceID];
        apr_hash_set(hta, v150, 8LL, v150);

        uint64_t v148 = apr_hash_next(v148);
      }

      while (v148);
    }

    char v154 = *(void *)&v504[2];
    int v155 = (apr_hash_index_t *)(*(void *)&v504[2] + 16LL);
    *(void *)(*(void *)&v504[2] + 24LL) = 0LL;
    *(void *)(v154 + 32) = 0LL;
    *(void *)(v154 + 16) = v154;
    *(_DWORD *)(v154 + 40) = 0;
    id v156 = apr_hash_next(v155);
    if (v156)
    {
      uint64_t v157 = v156;
      do
      {
        unint64_t v158 = *(void *)(*((void *)v157 + 1) + 32LL);
        id v159 = apr_palloc(pc, 0x20uLL);
        id v160 = (void *)objc_claimAutoreleasedReturnValue([v135 computePipelineStateForKey:*(void *)(v158 + 8)]);
        id v161 = DEVICEOBJECT(v160);
        char v162 = (void *)objc_claimAutoreleasedReturnValue(v161);

        void *v159 = [v162 uniqueIdentifier];
        v159[1] = *(void *)(v158 + 8);
        v159[2] = [v162 gpuResourceID];
        apr_hash_set(v412, v159, 8LL, v159);

        uint64_t v157 = apr_hash_next(v157);
      }

      while (v157);
    }

    uint64_t v163 = apr_array_make(pc, 3 * v137->nelts + 2 * (*((_DWORD *)v412 + 12) + *((_DWORD *)hta + 12)) + 3, 8);
    nelts = v137->nelts;
    *(void *)apr_array_push(v163) = nelts;
    if (v137->nelts >= 1)
    {
      uint64_t v165 = 0LL;
      id v166 = 0LL;
      do
      {
        id v167 = &v137->elts[v165];
        *(void *)__dst = *((void *)v167 + 2);
        id v168 = *(void *)(*(void *)(*find_entry(v134, __dst, 8uLL, 0LL) + 32LL) + 8LL);
        *(void *)apr_array_push(v163) = v168;
        id v169 = *(void *)v167;
        *(void *)apr_array_push(v163) = v169;
        uint64_t v170 = *((void *)v167 + 1);
        *(void *)apr_array_push(v163) = v170;
        ++v166;
        v165 += 24LL;
      }

      while (v166 < v137->nelts);
    }

    uint64_t v171 = *((unsigned int *)hta + 12);
    *(void *)apr_array_push(v163) = v171;
    *((_DWORD *)hta + 10) = 0;
    *((void *)hta + 2) = hta;
    *((void *)hta + 3) = 0LL;
    *((void *)hta + 4) = 0LL;
    id v172 = apr_hash_next((apr_hash_t *)((char *)hta + 16));
    if (v172)
    {
      unsigned int v173 = v172;
      do
      {
        uint64_t v174 = *(uint64_t **)(*((void *)v173 + 1) + 32LL);
        *(void *)__dst = v174[1];
        uint64_t v175 = *(void *)(*(void *)(*find_entry(v134, __dst, 8uLL, 0LL) + 32LL) + 8LL);
        *(void *)apr_array_push(v163) = v175;
        uint64_t v176 = *v174;
        *(void *)apr_array_push(v163) = v176;
        unsigned int v173 = apr_hash_next(v173);
      }

      while (v173);
    }

    char v177 = *((unsigned int *)v412 + 12);
    *(void *)apr_array_push(v163) = v177;
    *((_DWORD *)v412 + 10) = 0;
    *((void *)v412 + 2) = v412;
    *((void *)v412 + 3) = 0LL;
    *((void *)v412 + 4) = 0LL;
    uint64_t v178 = apr_hash_next((apr_hash_t *)((char *)v412 + 16));
    if (v178)
    {
      unsigned int v179 = v178;
      do
      {
        id v180 = *(uint64_t **)(*((void *)v179 + 1) + 32LL);
        *(void *)__dst = v180[1];
        uint64_t v181 = *(void *)(*(void *)(*find_entry(v134, __dst, 8uLL, 0LL) + 32LL) + 8LL);
        *(void *)apr_array_push(v163) = v181;
        id v182 = *v180;
        *(void *)apr_array_push(v163) = v182;
        unsigned int v179 = apr_hash_next(v179);
      }

      while (v179);
    }

    elts = v163->elts;
    elt_size = v163->elt_size;
    uint64_t v184 = v163->nelts;

    v186 = objc_alloc(&OBJC_CLASS___NSData);
    v450[0] = _NSConcreteStackBlock;
    v450[1] = 3221225472LL;
    v450[2] = __HarvestResourceObject_block_invoke_137;
    v450[3] = &__block_descriptor_40_e12_v24__0_v8Q16l;
    v450[4] = pc;
    uint64_t v111 = -[NSData initWithBytesNoCopy:length:deallocator:]( v186,  "initWithBytesNoCopy:length:deallocator:",  elts,  elt_size * (uint64_t)v184,  v450);
LABEL_146:
    uint64_t v92 = (apr_hash_t *)v111;
LABEL_153:
    BOOL v91 = 0LL;
    goto LABEL_154;
  }

  if (obj != (char *)-1026LL)
  {
    if ((unint64_t)obj > 0xFFFFFFFFFFFFFBFELL)
    {
      BOOL v91 = 0LL;
      uint64_t v92 = 0LL;
LABEL_154:
      if (v414) {
        id v194 = (char *)v414;
      }
      else {
        id v194 = obj;
      }
      unint64_t v195 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"MTLBuffer-0x%llx-Fetch",  v194));
      [a4[1] setObject:v92 forKeyedSubscript:v195];
      ht = v92;
      if (a4[2] && v413)
      {
        id v196 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  v413));
        [a4[2] setObject:v196 forKeyedSubscript:v195];
      }

      v444[0] = 0LL;
      v444[1] = v194;
      id v197 = v195;
      v444[2] = [v197 UTF8String];
      v444[3] = v91;
      v444[4] = -[apr_hash_t length](ht, "length");
      DYTraceEncode_MTLCommandBuffer_restoreMTLBufferContents((uint64_t)v444, **a4);
      uint64_t v198 = **a4;
      v199 = *v198;
      if ((*((_BYTE *)v198 + 33) & 0x10) != 0)
      {
        v201 = **a4;
        BOOL v200 = *v198;
        do
        {
          v201 = (unsigned int *)((char *)v201 + v199);
          v199 = *v201;
          v200 += v199;
        }

        while ((*((_BYTE *)v201 + 33) & 0x20) == 0);
      }

      else
      {
        BOOL v200 = *v198;
      }

      [(*a4)[2] appendBytes:v198 length:v200];
      goto LABEL_236;
    }

    if ((unint64_t)obj < 0xFFFFFFFFFFFFFBBELL)
    {
      if ((unint64_t)obj < 0xFFFFFFFFFFFFFB7ELL)
      {
        if ((unint64_t)obj < 0xFFFFFFFFFFFFFB3ELL)
        {
          if ((unint64_t)obj < 0xFFFFFFFFFFFFFAFELL)
          {
            if ((unint64_t)obj < 0xFFFFFFFFFFFFFABELL)
            {
              pe = (apr_pool_t *)a1[3];
              uint64_t v343 = v414;
              if (!v414)
              {
                v344 = (uint64_t *)GetAliasStream(*((void *)*a1 + 3), (uint64_t)obj, *((void *)*a1 + 10) + v14 - 1LL);
                if (v344) {
                  uint64_t v343 = *v344;
                }
                else {
                  uint64_t v343 = 0LL;
                }
              }

              v377 = (void *)objc_claimAutoreleasedReturnValue([a1[1] bufferForKey:v343]);
              v378 = (void *)objc_claimAutoreleasedReturnValue([v423 objectForKeyedSubscript:@"range.location"]);
              id v379 = [v378 unsignedIntValue];
              v380 = (id)objc_claimAutoreleasedReturnValue([v423 objectForKeyedSubscript:@"range.length"]);
              v381 = [v380 unsignedIntValue];

              v382 = (char *)[v377 length];
              v383 = v382;
              if (v381)
              {
                v384 = v381 + (unint64_t)v379;
                v385 = v384 >= v379;
                v386 = v384 - v379;
                if (v385) {
                  BOOL v91 = v379;
                }
                else {
                  BOOL v91 = 0LL;
                }
                if (v385) {
                  v383 = (char *)v386;
                }
                else {
                  v383 = 0LL;
                }
              }

              else
              {
                BOOL v91 = 0LL;
              }

              if (s_logUsingOsLog)
              {
                v387 = gt_tagged_log(1uLL);
                id v388 = (os_log_s *)objc_claimAutoreleasedReturnValue(v387);
                if (os_log_type_enabled(v388, OS_LOG_TYPE_INFO))
                {
                  v389 = (void *)objc_claimAutoreleasedReturnValue([v377 label]);
                  if (v389)
                  {
                    id v379 = objc_claimAutoreleasedReturnValue([v377 label]);
                    v390 = (const char *)[v379 UTF8String];
                  }

                  else
                  {
                    v390 = "no label";
                  }

                  LODWORD(v504[0]) = 134218754;
                  *(void *)((char *)v504 + 4) = v343;
                  WORD6(v504[0]) = 2080;
                  *(void *)((char *)v504 + 14) = v390;
                  WORD3(v504[1]) = 2048;
                  *((void *)&v504[1] + 1) = v91;
                  LOWORD(v504[2]) = 2048;
                  *(void *)((char *)&v504[2] + 2) = &v383[v91];
                  _os_log_impl( &dword_0,  v388,  OS_LOG_TYPE_INFO,  "Harvesting buffer %llu (%s) range: %llu - %llu",  (uint8_t *)v504,  0x2Au);
                  if (v389) {
                }
                  }
              }

              else
              {
                v391 = __stdoutp;
                id v388 = (os_log_s *)objc_claimAutoreleasedReturnValue([v377 label]);
                if (v388)
                {
                  v380 = objc_claimAutoreleasedReturnValue([v377 label]);
                  id v392 = (const char *)[v380 UTF8String];
                }

                else
                {
                  id v392 = "no label";
                }

                id v393 = objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString, "stringWithFormat:", @"Harvesting buffer %llu (%s) range: %llu - %llu", v343, v392, v91, &v383[v91]));
                fprintf(v391, "%s\n", (const char *)[v393 UTF8String]);

                if (v388) {
                else
                }
                  id v388 = 0LL;
              }

              id v394 = (void *)objc_claimAutoreleasedReturnValue(-[apr_pool_t bufferWithLength:alignment:](pe, "bufferWithLength:alignment:", v383, 1LL));
              id v473 = v377;
              id v395 = (void *)objc_claimAutoreleasedReturnValue( +[NSArray arrayWithObjects:count:]( &OBJC_CLASS___NSArray,  "arrayWithObjects:count:",  &v473,  1LL));
              GTMTLReplayClient_waitForUntrackedWritesToComplete((uint64_t)a1, v395);

              uint64_t v396 = (void *)objc_claimAutoreleasedReturnValue(-[apr_pool_t blitCommandEncoder](pe, "blitCommandEncoder"));
              v397 = (void *)objc_claimAutoreleasedReturnValue([v394 heapBuffer]);
              objc_msgSend( v396,  "copyFromBuffer:sourceOffset:toBuffer:destinationOffset:size:",  v377,  v91,  v397,  objc_msgSend(v394, "heapLocation"),  v383);

              uint64_t v92 = (apr_hash_t *)objc_claimAutoreleasedReturnValue([v394 data]);
              goto LABEL_154;
            }

            apr_pool_create_ex((apr_pool_t **)v504, 0LL, 0LL, v25);
            unint64_t v308 = *(void *)&v504[0];
            id v309 = DYMTLIndirectArgumentBufferManager_decodeArgumentBuffer( (uint64_t)a1,  (unint64_t)obj,  *(apr_pool_t **)&v504[0]);
            uint64_t v311 = v310;
            v312 = objc_alloc(&OBJC_CLASS___NSData);
            v445[0] = _NSConcreteStackBlock;
            v445[1] = 3221225472LL;
            v445[2] = __HarvestResourceObject_block_invoke_6;
            v445[3] = &__block_descriptor_40_e12_v24__0_v8Q16l;
            v445[4] = v308;
            uint64_t v111 = -[NSData initWithBytesNoCopy:length:deallocator:]( v312,  "initWithBytesNoCopy:length:deallocator:",  v309,  v311,  v445);
          }

          else
          {
            apr_pool_create_ex((apr_pool_t **)v504, 0LL, 0LL, v25);
            __int128 v291 = *(void *)&v504[0];
            id v292 = DYMTLIndirectArgumentBufferManager_decodeArgumentBuffer( (uint64_t)a1,  (unint64_t)obj,  *(apr_pool_t **)&v504[0]);
            id v294 = v293;
            __int128 v295 = objc_alloc(&OBJC_CLASS___NSData);
            v446[0] = _NSConcreteStackBlock;
            v446[1] = 3221225472LL;
            v446[2] = __HarvestResourceObject_block_invoke_5;
            v446[3] = &__block_descriptor_40_e12_v24__0_v8Q16l;
            v446[4] = v291;
            uint64_t v111 = -[NSData initWithBytesNoCopy:length:deallocator:]( v295,  "initWithBytesNoCopy:length:deallocator:",  v292,  v294,  v446);
          }
        }

        else
        {
          apr_pool_create_ex((apr_pool_t **)v504, 0LL, 0LL, v25);
          uint64_t v269 = *(void *)&v504[0];
          v270 = DYMTLIndirectArgumentBufferManager_decodeArgumentBuffer( (uint64_t)a1,  (unint64_t)obj,  *(apr_pool_t **)&v504[0]);
          uint64_t v272 = v271;
          v273 = objc_alloc(&OBJC_CLASS___NSData);
          v447[0] = _NSConcreteStackBlock;
          v447[1] = 3221225472LL;
          v447[2] = __HarvestResourceObject_block_invoke_4;
          v447[3] = &__block_descriptor_40_e12_v24__0_v8Q16l;
          v447[4] = v269;
          uint64_t v111 = -[NSData initWithBytesNoCopy:length:deallocator:]( v273,  "initWithBytesNoCopy:length:deallocator:",  v270,  v272,  v447);
        }
      }

      else
      {
        apr_pool_create_ex((apr_pool_t **)v504, 0LL, 0LL, v25);
        v264 = *(void *)&v504[0];
        v265 = DYMTLIndirectArgumentBufferManager_decodeArgumentBuffer( (uint64_t)a1,  (unint64_t)obj,  *(apr_pool_t **)&v504[0]);
        v267 = v266;
        uint64_t v268 = objc_alloc(&OBJC_CLASS___NSData);
        v448[0] = _NSConcreteStackBlock;
        v448[1] = 3221225472LL;
        v448[2] = __HarvestResourceObject_block_invoke_3;
        v448[3] = &__block_descriptor_40_e12_v24__0_v8Q16l;
        v448[4] = v264;
        uint64_t v111 = -[NSData initWithBytesNoCopy:length:deallocator:]( v268,  "initWithBytesNoCopy:length:deallocator:",  v265,  v267,  v448);
      }
    }

    else
    {
      apr_pool_create_ex((apr_pool_t **)v504, 0LL, 0LL, v25);
      uint64_t v106 = *(void *)&v504[0];
      uint64_t v107 = DYMTLIndirectArgumentBufferManager_decodeArgumentBuffer( (uint64_t)a1,  (unint64_t)obj,  *(apr_pool_t **)&v504[0]);
      id v109 = v108;
      uint64_t v110 = objc_alloc(&OBJC_CLASS___NSData);
      v449[0] = _NSConcreteStackBlock;
      v449[1] = 3221225472LL;
      v449[2] = __HarvestResourceObject_block_invoke_2;
      v449[3] = &__block_descriptor_40_e12_v24__0_v8Q16l;
      v449[4] = v106;
      uint64_t v111 = -[NSData initWithBytesNoCopy:length:deallocator:]( v110,  "initWithBytesNoCopy:length:deallocator:",  v107,  v109,  v449);
    }

    goto LABEL_146;
  }

  if (s_logUsingOsLog)
  {
    uint64_t v28 = gt_tagged_log(1uLL);
    uint64_t v29 = (os_log_s *)objc_claimAutoreleasedReturnValue(v28);
    if (os_log_type_enabled(v29, OS_LOG_TYPE_INFO))
    {
      LOWORD(v504[0]) = 0;
      _os_log_impl(&dword_0, v29, OS_LOG_TYPE_INFO, "Harvesting vertex data", (uint8_t *)v504, 2u);
    }
  }

  else
  {
    unsigned int v119 = __stdoutp;
    uint64_t v29 = (os_log_s *) objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString, "stringWithFormat:", @"Harvesting vertex data"));
    fprintf(v119, "%s\n", (const char *)-[os_log_s UTF8String](v29, "UTF8String"));
  }

  pb = a2;
  uint64_t v120 = v416;
  int v121 = a1[1];
  unint64_t v122 = (uint64_t)*a1;
  unsigned int v123 = *((void *)*a1 + 15);
  unsigned int v124 = (*v23 - 1);
  id v125 = *(void *)(v123 + 24) + (v124 << 6);
  id v520 = 0u;
  v519 = 0u;
  v518 = 0u;
  v517 = 0u;
  v516 = 0u;
  uint64_t v515 = 0u;
  v514 = 0u;
  uint64_t v513 = 0u;
  v512 = 0u;
  v511 = 0u;
  v510 = 0u;
  v509 = 0u;
  v508 = 0u;
  v507 = 0u;
  v506 = 0u;
  *(_OWORD *)v505 = 0u;
  memcpy(v504, a1 + 1421, 0x2B58uLL);
  if (*(_DWORD *)(v125 + 8) >> 2 == 1073737833)
  {
    *((void *)&v520 + 1) = *(void *)a1[19];
    GTMTLSMContext_indirectCommandBufferResources( (uint64_t)&v514 + 8,  *(_DWORD ***)(v122 + 40),  *(void *)v125,  *((apr_pool_t **)&v520 + 1));
    GetExecuteCommandsInBufferArgs((uint64_t)v505, v125, *(void *)(v122 + 16));
    uint64_t Object = GTMTLSMContext_getObject(**(void **)(v122 + 40), (uint64_t)v505[0], *(void *)v125);
    GTMTLCreateIndirectCommandEncoder((uint64_t)&v507 + 8, Object[13]);
    *(void *)&id v520 = *((void *)&v506 + 1) + v514 * *((unsigned int *)a1 + 5621);
    GTMTLSMRenderCommandEncoder_loadIndirectCommand((uint64_t)v504, (void *)&v507 + 1, v520, (uint64_t *)&v514 + 1);
  }

  unsigned int v127 = GTMTLSMContext_getObject(**(void **)(v122 + 40), *(uint64_t *)&v504[534], *(void *)v125);
  if (v127[9])
  {
    memcpy(__dst, v504, sizeof(__dst));
    unsigned int v499 = v517;
    v500 = v518;
    v501 = v519;
    v502 = v520;
    id v495 = v513;
    v496 = v514;
    v497 = v515;
    v498 = v516;
    id v491 = v509;
    v492 = v510;
    v493 = v511;
    __int128 v494 = v512;
    v487 = *(_OWORD *)v505;
    uint64_t v488 = v506;
    v489 = v507;
    BOOL v490 = v508;
    PostMeshData = GTMTLReplayController_generatePostMeshData( (uint64_t)a1,  v121,  v122,  v123,  v124,  v125,  (uint64_t)__dst,  (uint64_t)v127,  (uint64_t)&v487,  (uint64_t)pb,  v120,  a5);
  }

  else
  {
    memcpy(__dst, v504, sizeof(__dst));
    unsigned int v499 = v517;
    v500 = v518;
    v501 = v519;
    v502 = v520;
    id v495 = v513;
    v496 = v514;
    v497 = v515;
    v498 = v516;
    id v491 = v509;
    v492 = v510;
    v493 = v511;
    __int128 v494 = v512;
    v487 = *(_OWORD *)v505;
    uint64_t v488 = v506;
    v489 = v507;
    BOOL v490 = v508;
    PostMeshData = GTMTLReplayController_generatePostVertexData( (uint64_t)a1,  v121,  v122,  v123,  v124,  v125,  (uint64_t)__dst,  (uint64_t)v127,  (uint64_t)&v487,  (uint64_t)pb,  a5);
  }

  uint64_t v36 = (void *)objc_claimAutoreleasedReturnValue(PostMeshData);

  if (v36)
  {
    id v189 = objc_alloc(&OBJC_CLASS___NSData);
    id v190 = v36;
    id v191 = [v190 contents];
    id v192 = [v190 length];
    v451[0] = _NSConcreteStackBlock;
    v451[1] = 3221225472LL;
    v451[2] = __HarvestResourceObject_block_invoke;
    v451[3] = &unk_58EC78;
    id v193 = v190;
    v452 = v193;
    uint64_t v92 = -[NSData initWithBytesNoCopy:length:deallocator:]( v189,  "initWithBytesNoCopy:length:deallocator:",  v191,  v192,  v451);

    goto LABEL_153;
  }

LABEL_307:
    v324 = (NSDictionary *)[v495 copy];
    v325 = v538;
    v538 = v324;
    int v326 = 1;
LABEL_329:

    id v339 = -[NSDictionary mutableCopy](v538, "mutableCopy");
    [v339 removeObjectsForKeys:v491];
    v340 = (NSDictionary *)[v339 copy];
    v341 = v538;
    v538 = v340;

    if (!v326) {
      goto LABEL_422;
    }
  }

  v487 = (NSMutableDictionary *)objc_claimAutoreleasedReturnValue([v516 objectForKeyedSubscript:@"SourceLibs"]);
  if (-[NSMutableDictionary count](v487, "count"))
  {
    v530 = v487;
    v498 = (char *)-[NSMutableDictionary count](v530, "count");
    if (!v498)
    {
      if (a3)
      {
        id v414 = GTShaderDebuggerMakeError(4u, @"No source", 0LL, 0LL, 0LL);
        *a3 = (id)objc_claimAutoreleasedReturnValue(v414);
      }

      goto LABEL_421;
    }

    id v477 = *((id *)v531 + 1);
    v492 = (void *)objc_claimAutoreleasedReturnValue([v477 defaultDevice]);
    id v483 = [v492 argumentBuffersSupport];
    v480 = objc_alloc_init(&OBJC_CLASS___NSMutableDictionary);
    id v479 = -[NSDictionary mutableCopy](v538, "mutableCopy");
    v342 = (void *)objc_claimAutoreleasedReturnValue([v477 dynamicLibraries]);
    id v481 = [v342 mutableCopy];

    v489 = v498 - 1;
    uint64_t v343 = (v548 >> 2) & 1;
    if (v498 != (_BYTE *)&dword_0 + 1) {
      LODWORD(v343) = 1;
    }
    int v482 = v343;
    v344 = (unint64_t *)*((void *)&v537 + 1);
    v345 = *(uint64_t **)(*(void *)v531 + 40LL);
    v496 = -[NSMutableDictionary initWithCapacity:]( objc_alloc(&OBJC_CLASS___NSMutableDictionary),  "initWithCapacity:",  -[NSMutableDictionary count](v530, "count"));
    v501 = -[NSMutableDictionary initWithCapacity:]( objc_alloc(&OBJC_CLASS___NSMutableDictionary),  "initWithCapacity:",  -[NSMutableDictionary count](v530, "count"));
    __int128 v573 = 0u;
    __int128 v574 = 0u;
    __int128 v571 = 0u;
    __int128 v572 = 0u;
    v530 = v530;
    id v346 = -[NSMutableDictionary countByEnumeratingWithState:objects:count:]( v530,  "countByEnumeratingWithState:objects:count:",  &v571,  __dst,  16LL);
    if (v346)
    {
      uint64_t v347 = *(void *)v572;
LABEL_336:
      uint64_t v348 = 0LL;
      while (1)
      {
        if (*(void *)v572 != v347) {
          objc_enumerationMutation(v530);
        }
        v349 = *(void **)(*((void *)&v571 + 1) + 8 * v348);
        id v350 = [v349 unsignedIntegerValue];
        v351 = (void *)GetAliasStream(*(void *)(*(void *)v531 + 24LL), (uint64_t)v350, **((void **)&v537 + 1));
        uint64_t v352 = v351 ? *v351 : 0LL;
        v353 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  v352));
        uint64_t v354 = GTMTLSMContext_lastObject(*v345, (uint64_t)[v353 unsignedLongLongValue], *v344);
        if (!v354 || *(_BYTE *)(v354 + 161) != 2) {
          break;
        }
        v355 = (void *)objc_claimAutoreleasedReturnValue(+[NSValue valueWithPointer:](&OBJC_CLASS___NSValue, "valueWithPointer:", v354));
        -[NSMutableDictionary setObject:forKeyedSubscript:](v496, "setObject:forKeyedSubscript:", v355, v353);

        -[NSMutableDictionary setObject:forKeyedSubscript:](v501, "setObject:forKeyedSubscript:", v349, v353);
        if (v346 == (id)++v348)
        {
          id v346 = -[NSMutableDictionary countByEnumeratingWithState:objects:count:]( v530,  "countByEnumeratingWithState:objects:count:",  &v571,  __dst,  16LL);
          if (!v346) {
            goto LABEL_346;
          }
          goto LABEL_336;
        }
      }

      v410 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"Invalid library %@: Expected library with source",  v353));
      if (a3)
      {
        id v411 = GTShaderDebuggerMakeError(4u, v410, 0LL, 0LL, 0LL);
        *a3 = (id)objc_claimAutoreleasedReturnValue(v411);
      }

      v526 = 0LL;
      int v412 = 0;
      v413 = v530;
LABEL_410:

      if (v412) {
        goto LABEL_411;
      }
LABEL_421:

LABEL_422:
      goto LABEL_139;
    }

LABEL_346:
    v356 = (void *)objc_claimAutoreleasedReturnValue(-[NSMutableDictionary allKeys](v496, "allKeys"));
    v566 = _NSConcreteStackBlock;
    uint64_t v567 = 3221225472LL;
    v568 = __GTShaderDebuggerMakeRuntimeLibrariesFromSources_block_invoke;
    v569 = &unk_58F8A0;
    v486 = v496;
    v570 = v486;
    v357 = (void *)objc_claimAutoreleasedReturnValue([v356 sortedArrayUsingComparator:&v566]);

    __int128 v565 = 0u;
    __int128 v564 = 0u;
    __int128 v563 = 0u;
    __int128 v562 = 0u;
    id v478 = v357;
    id v358 = [v478 countByEnumeratingWithState:&v562 objects:&v558 count:16];
    if (!v358)
    {
      v526 = 0LL;
LABEL_408:

      v416 = (NSDictionary *)[v479 copy];
      v417 = v538;
      v538 = v416;

      id v418 = -[NSMutableDictionary copy](v480, "copy");
      v415 = (void *)v539;
      *(void *)&__int128 v539 = v418;
      int v412 = 1;
LABEL_409:

      v413 = v570;
      goto LABEL_410;
    }

    v526 = 0LL;
    uint64_t v485 = *(void *)v563;
LABEL_348:
    uint64_t v359 = 0LL;
    id v484 = v358;
    while (1)
    {
      if (*(void *)v563 != v485) {
        objc_enumerationMutation(v478);
      }
      v360 = *(void **)(*((void *)&v562 + 1) + 8 * v359);
      id objd = (id)objc_claimAutoreleasedReturnValue(-[NSMutableDictionary objectForKeyedSubscript:](v501, "objectForKeyedSubscript:", v360));
      v361 = (void *)objc_claimAutoreleasedReturnValue(-[NSMutableDictionary objectForKeyedSubscript:](v486, "objectForKeyedSubscript:", v360));
      v362 = [v361 pointerValue];

      v521 = (void *)objc_claimAutoreleasedReturnValue(-[NSMutableDictionary objectForKeyedSubscript:](v530, "objectForKeyedSubscript:", objd));
      v363 = (void *)objc_claimAutoreleasedReturnValue([v521 objectForKeyedSubscript:@"Code"]);
      if (v498 == (_BYTE *)&dword_0 + 1)
      {
        -[NSMutableDictionary setObject:forKeyedSubscript:]( v480,  "setObject:forKeyedSubscript:",  v363,  @"/program_source");
        goto LABEL_360;
      }

      v364 = (void *)objc_claimAutoreleasedReturnValue(+[NSCharacterSet newlineCharacterSet](&OBJC_CLASS___NSCharacterSet, "newlineCharacterSet"));
      id v365 = [v363 rangeOfCharacterFromSet:v364];

      if (v365 == (id)0x7FFFFFFFFFFFFFFFLL) {
        goto LABEL_353;
      }
      v369 = (void *)objc_claimAutoreleasedReturnValue([v363 substringToIndex:v365]);
      if (([v369 containsString:@"#line"] & 1) == 0
        && ([v369 containsString:@"# line"] & 1) == 0)
      {
        break;
      }

      id v370 = v526;
LABEL_359:

      v526 = v370;
LABEL_360:
      uint64_t v373 = v362[13];
      if (v373)
      {
        MTLCompileOptions = MakeMTLCompileOptions(v373, v481);
        v375 = (MTLCompileOptions *)objc_claimAutoreleasedReturnValue(MTLCompileOptions);
      }

      else
      {
        v375 = objc_alloc_init(&OBJC_CLASS___MTLCompileOptions);
      }

      v376 = v375;
      v377 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
      v378 = (void *)objc_claimAutoreleasedReturnValue(-[MTLCompileOptions additionalCompilerArguments](v376, "additionalCompilerArguments"));
      id v379 = [v378 length];

      if (v379)
      {
        v380 = (void *)objc_claimAutoreleasedReturnValue(-[MTLCompileOptions additionalCompilerArguments](v376, "additionalCompilerArguments"));
        -[NSMutableArray addObject:](v377, "addObject:", v380);
      }

      if (v498 == (_BYTE *)&dword_0 + 1) {
        -[NSMutableArray addObject:](v377, "addObject:", @"-fno-tracepoint-instrument-line-markers");
      }
      v381 = (void *)objc_claimAutoreleasedReturnValue([v521 objectForKeyedSubscript:@"SelectFunctions"]);
      if (v381)
      {
        -[NSMutableArray addObject:](v377, "addObject:", @"-fno-tracepoint-default-instrument");
        v382 = (void *)objc_claimAutoreleasedReturnValue([v381 componentsJoinedByString:@","]);
        v383 = (void *)objc_claimAutoreleasedReturnValue([@"-ftracepoint-instrument-functions=" stringByAppendingString:v382]);
        -[NSMutableArray addObject:](v377, "addObject:", v383);
      }

      if (!v483) {
        -[NSMutableArray addObject:](v377, "addObject:", @"-fno-tracepoint-instrument-argument-buffers");
      }
      if (v482)
      {
        -[NSMutableArray addObject:](v377, "addObject:", @"-dynamic-libtracepoint");
        -[NSMutableArray addObject:](v377, "addObject:", @"-Wl,-mllvm");
        -[NSMutableArray addObject:](v377, "addObject:", @"-Wl,-disable-legacy-trace-buffer");
        -[NSMutableArray addObject:](v377, "addObject:", @"-fexternally-initialized");
        -[NSMutableArray addObject:](v377, "addObject:", @"-Wl,-mllvm");
        -[NSMutableArray addObject:](v377, "addObject:", @"-Wl,-external-initialization");
        -[NSMutableArray addObject:](v377, "addObject:", @"-Wl,-mllvm");
        v384 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithInteger:](&OBJC_CLASS___NSNumber, "numberWithInteger:", v489));
        v385 = (void *)objc_claimAutoreleasedReturnValue([v384 stringValue]);
        v386 = (void *)objc_claimAutoreleasedReturnValue([@"-Wl,__trace.base_id=" stringByAppendingString:v385]);
        -[NSMutableArray addObject:](v377, "addObject:", v386);

        --v489;
      }

      -[MTLCompileOptions setTracingEnabled:](v376, "setTracingEnabled:", 1LL);
      v387 = (void *)objc_claimAutoreleasedReturnValue(-[NSMutableArray componentsJoinedByString:](v377, "componentsJoinedByString:", @" "));
      -[MTLCompileOptions setAdditionalCompilerArguments:](v376, "setAdditionalCompilerArguments:", v387);

      if (*((_BYTE *)v362 + 160) == 1)
      {
        -[MTLCompileOptions setLibraryType:](v376, "setLibraryType:", 1LL);
        id v388 = v547;
        v389 = (void *)objc_claimAutoreleasedReturnValue([v360 stringValue]);
        v390 = (void *)objc_claimAutoreleasedReturnValue([v389 stringByAppendingPathExtension:@"metallib"]);
        v391 = (void *)objc_claimAutoreleasedReturnValue([v388 stringByAppendingPathComponent:v390]);
        -[MTLCompileOptions setInstallName:](v376, "setInstallName:", v391);
      }

      v554[0] = v526;
      id v392 = [v492 newLibraryWithSource:v363 options:v376 error:v554];
      id v393 = v554[0];

      if (!v392)
      {
        if (a3)
        {
          id v404 = GTShaderDebuggerMakeError(1u, @"Internal error: Failed to set up main function", 0LL, v393, 0LL);
          *a3 = (id)objc_claimAutoreleasedReturnValue(v404);
        }

        int v403 = 1;
        goto LABEL_395;
      }

      if (*((_BYTE *)v362 + 160) == 1)
      {
        v553[0] = v393;
        id v394 = [v492 newDynamicLibrary:v392 error:v553];
        id v395 = v553[0];

        if (v394)
        {
          uint64_t DylibObjectIDForParentLibrary = _FindDylibObjectIDForParentLibrary( (unint64_t **)&v531,  (uint64_t)v362,  v396,  v397);
          if (DylibObjectIDForParentLibrary)
          {
            uint64_t v399 = DylibObjectIDForParentLibrary;
            v400 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  DylibObjectIDForParentLibrary));
            [v479 setObject:v394 forKeyedSubscript:v400];

            v401 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  v362[1]));
            [v479 setObject:v392 forKeyedSubscript:v401];

            v402 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  v399));
            [v481 setObject:v394 forKeyedSubscript:v402];

            int v403 = 0;
LABEL_394:
            id v393 = v395;
            goto LABEL_395;
          }

          v408 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"Internal error: Failed to resolve dynamic library %@",  v360));
          if (a3)
          {
            id v409 = GTShaderDebuggerMakeError(1u, v408, 0LL, 0LL, 0LL);
            *a3 = (id)objc_claimAutoreleasedReturnValue(v409);
          }
        }

        else if (a3)
        {
          id v407 = GTShaderDebuggerMakeError( 1u,  @"Internal error: Failed to set up dynamic library",  0LL,  v395,  0LL);
          *a3 = (id)objc_claimAutoreleasedReturnValue(v407);
        }

        int v403 = 1;
        goto LABEL_394;
      }

      v405 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  v362[1]));
      [v479 setObject:v392 forKeyedSubscript:v405];

      int v403 = 0;
LABEL_395:

      v526 = v393;
LABEL_396:

      if (v403)
      {
        int v412 = 0;
        v415 = v478;
        goto LABEL_409;
      }

      if (v484 == (id)++v359)
      {
        id v358 = [v478 countByEnumeratingWithState:&v562 objects:&v558 count:16];
        if (v358) {
          goto LABEL_348;
        }
        goto LABEL_408;
      }
    }

LABEL_353:
    id v366 = v547;
    v367 = (void *)objc_claimAutoreleasedReturnValue([v360 stringValue]);
    v368 = (void *)objc_claimAutoreleasedReturnValue([v367 stringByAppendingPathExtension:@"metal"]);
    v369 = (void *)objc_claimAutoreleasedReturnValue([v366 stringByAppendingPathComponent:v368]);

    v551[0] = v526;
    LODWORD(v36_Block_object_dispose(&STACK[0x3B0], 8) = [v363 writeToFile:v369 atomically:1 encoding:4 error:v551];
    id v370 = v551[0];

    if (!(_DWORD)v368)
    {

      if (a3)
      {
        id v406 = GTShaderDebuggerMakeError(1u, @"Internal error trying to disambiguate libraries", 0LL, v370, 0LL);
        *a3 = (id)objc_claimAutoreleasedReturnValue(v406);
      }

      int v403 = 1;
      v526 = v370;
      goto LABEL_396;
    }

    v371 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"#line 1 %@\n",  v369));
    uint64_t v372 = objc_claimAutoreleasedReturnValue([v371 stringByAppendingString:v363]);

    v363 = (void *)v372;
    goto LABEL_359;
  }

LABEL_411:
  v419 = (void *)objc_claimAutoreleasedReturnValue([v516 objectForKeyedSubscript:@"MetalLibs"]);
  if ([v419 count]
    && !GTShaderDebuggerMakeRuntimeLibrariesFromMetallibs((id *)&v531, v419, a3))
  {
    goto LABEL_420;
  }

  v420 = (void *)objc_claimAutoreleasedReturnValue([v516 objectForKeyedSubscript:@"DependentLibs"]);
  if ([v420 count]
    && !GTShaderDebuggerMakeRuntimeLibrariesFromDependentLibs((uint64_t)&v531, v420, a3))
  {
LABEL_419:

LABEL_420:
    v530 = v487;
    goto LABEL_421;
  }

  v421 = (void *)objc_claimAutoreleasedReturnValue([v516 objectForKeyedSubscript:@"FunctionUIDs"]);
  if (!GTShaderDebuggerMakeRuntimeFunctions((uint64_t)&v531, v421, a3))
  {

    goto LABEL_419;
  }

  if (v419) {
    v422 = (void *)objc_claimAutoreleasedReturnValue([v419 allKeys]);
  }
  else {
    v422 = (void *)objc_claimAutoreleasedReturnValue(-[NSMutableDictionary allKeys](v487, "allKeys"));
  }
  v423 = v422;
  char DebugMetadata = GTShaderDebuggerMakeDebugMetadata((uint64_t)&v531, v421, v422, a3);

  unsigned int v427 = v531[2828];
  if (v427 != 70)
  {
    if (v427 == 28)
    {
      int PSOCompute = GTShaderDebuggerMakePSOCompute((uint64_t)&v531, a3, v425, v426);
      goto LABEL_451;
    }

    GTMTLReplay_handleError( 101,  (uint64_t)"Unreachable",  "/Library/Caches/com.apple.xbs/Sources/GPUToolsDevice/GPUTools/GTMTLCapture/replayer/GTMTLReplay_shaderDebugger.m",  (uint64_t)"GTMTLShaderDebugger_makePipelineState",  141LL,  4LL);
    if (!a3) {
      goto LABEL_139;
    }
    id v455 = GTShaderDebuggerMakeError(1u, @"Internal error: Unknown encoder", 0LL, 0LL, 0LL);
    id v169 = (id)objc_claimAutoreleasedReturnValue(v455);
LABEL_150:
    *a3 = v169;
    goto LABEL_139;
  }

  int PSOCompute = GTShaderDebuggerMakePSORender((id *)&v531, a3);
LABEL_451:
  if (PSOCompute)
  {
    GTShaderDebuggerJITResources(&v531);
    v453 = v531;
    unsigned int v454 = v531[2828];
    if (v454 == 28)
    {
    }

    else if (v454 == 70 && (GTShaderDebuggerEncodeResourcesRender(&v531, a3) & 1) == 0)
    {
      goto LABEL_139;
    }

    if (GTShaderDebuggerExecuteEncoder((uint64_t *)&v531, a3))
    {
      id v456 = *((id *)v453 + 1);
      *(void *)&__int128 v571 = 0LL;
      *((void *)&v571 + 1) = &v571;
      *(void *)&__int128 v572 = 0x2020000000LL;
      BYTE8(v572) = 0;
      *(void *)__dst = 0LL;
      *(void *)&__dst[8] = __dst;
      *(void *)&__dst[16] = 0x3032000000LL;
      *(void *)&__dst[24] = __Block_byref_object_copy__238;
      *(void *)&__dst[32] = __Block_byref_object_dispose__239;
      *(void *)&__dst[40] = 0LL;
      v457 = (void *)objc_claimAutoreleasedReturnValue([v456 commandBufferForKey:*((void *)v453 + 1419)]);
      *(void *)&__int128 v558 = _NSConcreteStackBlock;
      *((void *)&v558 + 1) = 3221225472LL;
      *(void *)&__int128 v559 = __GTMTLShaderDebugger_executeCommandEncoder_block_invoke;
      *((void *)&v559 + 1) = &unk_58D9C8;
      *(void *)&__int128 v560 = __dst;
      *((void *)&v560 + 1) = &v571;
      [v457 addCompletedHandler:&v558];

      [v456 commitCommandBuffers];
      v458 = (void *)objc_claimAutoreleasedReturnValue([*((id *)v453 + 1) defaultCommandQueue]);
      [v458 finish];

      if (*(_BYTE *)(*((void *)&v571 + 1) + 24LL))
      {
        v459 = (char *)[*(id *)(*(void *)&__dst[8] + 40) code];
        if (v459 != (_BYTE *)&dword_8 + 1 && v459 != (_BYTE *)&dword_0 + 3
          || GTShaderDebuggerValidateUserEncoderBindings((uint64_t)&v531, a3))
        {
          v460 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(*(void *)&__dst[8] + 40) localizedDescription]);
          v461 = (void *)objc_claimAutoreleasedReturnValue( [@"Internal error: Problem encountered during execution: " stringByAppendingString:v460]);

          if (a3)
          {
            if ((v548 & 0x10) != 0) {
              unsigned int v462 = 4;
            }
            else {
              unsigned int v462 = 3;
            }
            id v463 = GTShaderDebuggerMakeError(v462, v461, 0LL, *(void **)(*(void *)&__dst[8] + 40LL), 0LL);
            *a3 = (id)objc_claimAutoreleasedReturnValue(v463);
          }
        }

        _Block_object_dispose(__dst, 8);

        _Block_object_dispose(&v571, 8);
        goto LABEL_139;
      }

      _Block_object_dispose(__dst, 8);

      _Block_object_dispose(&v571, 8);
      id v464 = v503;
      *(void *)&__int128 v571 = 0LL;
      id TraceData = GTShaderDebuggerMakeTraceData((uint64_t)&v531, &v571);
      v466 = (void *)objc_claimAutoreleasedReturnValue(TraceData);
      id v467 = (id)v571;
      v468 = v467;
      if (v466)
      {
        *(void *)__dst = v466;
        *(void *)&__int128 v558 = @"TraceData";
        *((void *)&v558 + 1) = @"ResourceMapping";
        id ResourceMappings = GTShaderDebuggerMakeResourceMappings((uint64_t **)&v531);
        v470 = (void *)objc_claimAutoreleasedReturnValue(ResourceMappings);
        *(void *)&__dst[8] = v470;
        v471 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  __dst,  &v558,  2LL));
        v472 = (void *)objc_claimAutoreleasedReturnValue( +[NSMutableDictionary dictionaryWithDictionary:]( &OBJC_CLASS___NSMutableDictionary,  "dictionaryWithDictionary:",  v471));

        id v473 = v543;
        if (v473) {
          [v472 setObject:v473 forKeyedSubscript:@"TraceMetadata"];
        }
        id v474 = GTShaderDebuggerSanitizeResponse(v472, v464, v531, a3);
        id v160 = (void *)objc_claimAutoreleasedReturnValue(v474);

        goto LABEL_483;
      }

      if ([v467 code] == (char *)&dword_0 + 3)
      {
        char v475 = GTShaderDebuggerValidateUserComputeDispatch(&v531, a3);
        if (a3) {
          char v476 = v475;
        }
        else {
          char v476 = 0;
        }
        if ((v476 & 1) == 0) {
          goto LABEL_480;
        }
      }

      else if (!a3)
      {
LABEL_480:
        id v160 = 0LL;
LABEL_483:

        GTShaderDebuggerContextDeinit(&v531);
        goto LABEL_140;
      }

      id v160 = 0LL;
      *a3 = v468;
      goto LABEL_483;
    }
  }

LABEL_139:
  GTShaderDebuggerContextDeinit(&v531);
  id v160 = 0LL;
LABEL_140:
  __destructor_8_S_S_s8_s16_S_s24_s32_s40_s48_s56_s64_S_s96_s104_s112_s120_S_s128_s136_S_s152_S_s168_s176_s184_s192_s200((id *)&v531);

  return v160;
}

  uint64_t v248 = 0u;
  v247 = 0u;
  uint64_t v250 = 0u;
  BOOL v251 = 0u;
  LODWORD(v249) = 1065353216;
  uint64_t v252 = 1065353216;
  __int128 v230 = 0u;
  __int128 v231 = 0u;
  uint64_t v235 = 1LL;
  uint64_t v232 = 1065353216;
  std::unordered_map<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,std::allocator<std::pair<FunctionHandleKey const,objc_object  {objcproto17MTLFunctionHandle}*>>>::unordered_map( (uint64_t)&v236,  (uint64_t)&v230);
  __int128 v227 = 0u;
  __int128 v228 = 0u;
  unint64_t v229 = 1065353216;
  unint64_t v239 = 2LL;
  std::unordered_map<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,std::allocator<std::pair<FunctionHandleKey const,objc_object  {objcproto17MTLFunctionHandle}*>>>::unordered_map( (uint64_t)v240,  (uint64_t)&v227);
  unint64_t v224 = 0u;
  __int128 v225 = 0u;
  __int128 v226 = 1065353216;
  id v241 = 4LL;
  std::unordered_map<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,std::allocator<std::pair<FunctionHandleKey const,objc_object  {objcproto17MTLFunctionHandle}*>>>::unordered_map( (uint64_t)v242,  (uint64_t)&v224);
  __int128 v221 = 0u;
  __int128 v222 = 0u;
  __int128 v223 = 1065353216;
  id v243 = 16LL;
  std::unordered_map<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,std::allocator<std::pair<FunctionHandleKey const,objc_object  {objcproto17MTLFunctionHandle}*>>>::unordered_map( (uint64_t)v244,  (uint64_t)&v221);
  __int128 v218 = 0u;
  unint64_t v219 = 0u;
  __int128 v220 = 1065353216;
  uint64_t v245 = 8LL;
  std::unordered_map<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,std::allocator<std::pair<FunctionHandleKey const,objc_object  {objcproto17MTLFunctionHandle}*>>>::unordered_map( (uint64_t)v246,  (uint64_t)&v218);
  std::unordered_map<unsigned long,std::unordered_map<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,std::allocator<std::pair<FunctionHandleKey const,objc_object  {objcproto17MTLFunctionHandle}*>>>,std::hash<unsigned long>,FunctionHandleKeyHash<unsigned long>,std::equal_to<FunctionHandleKey><std::allocator<unsigned long const>>>::unordered_map( (uint64_t)v253,  (unint64_t *)&v235,  5LL);
  for (i10 = 200LL; i10 != -40; i10 -= 48LL)
    std::__hash_table<std::__hash_value_type<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong}>,std::__unordered_map_hasher<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,true>,std::__unordered_map_equal<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},std::equal_to,std::__unordered_map_hasher,true>,std::allocator<objc_object  {objcproto17MTLFunctionHandle}* {__strong}>>::~__hash_table((uint64_t)&v235 + i10);
  std::__hash_table<std::__hash_value_type<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong}>,std::__unordered_map_hasher<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,true>,std::__unordered_map_equal<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},std::equal_to,std::__unordered_map_hasher,true>,std::allocator<objc_object  {objcproto17MTLFunctionHandle}* {__strong}>>::~__hash_table((uint64_t)&v218);
  std::__hash_table<std::__hash_value_type<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong}>,std::__unordered_map_hasher<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,true>,std::__unordered_map_equal<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},std::equal_to,std::__unordered_map_hasher,true>,std::allocator<objc_object  {objcproto17MTLFunctionHandle}* {__strong}>>::~__hash_table((uint64_t)&v221);
  std::__hash_table<std::__hash_value_type<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong}>,std::__unordered_map_hasher<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,true>,std::__unordered_map_equal<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},std::equal_to,std::__unordered_map_hasher,true>,std::allocator<objc_object  {objcproto17MTLFunctionHandle}* {__strong}>>::~__hash_table((uint64_t)&v224);
  std::__hash_table<std::__hash_value_type<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong}>,std::__unordered_map_hasher<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,true>,std::__unordered_map_equal<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},std::equal_to,std::__unordered_map_hasher,true>,std::allocator<objc_object  {objcproto17MTLFunctionHandle}* {__strong}>>::~__hash_table((uint64_t)&v227);
  std::__hash_table<std::__hash_value_type<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong}>,std::__unordered_map_hasher<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,true>,std::__unordered_map_equal<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},std::equal_to,std::__unordered_map_hasher,true>,std::allocator<objc_object  {objcproto17MTLFunctionHandle}* {__strong}>>::~__hash_table((uint64_t)&v230);
  uint64_t v254 = 0u;
  v255 = 0u;
  v256 = 1065353216;
  v257 = 0u;
  uint64_t v258 = 0u;
  uint64_t v260 = 0u;
  uint64_t v261 = 0u;
  v259 = 1065353216;
  v262 = 1065353216;
  uint64_t v138 = (void *)objc_claimAutoreleasedReturnValue([a1->var1 defaultDevice]);
  uint64_t v139 = ObtainResourceTrackingTracingBufferV2(v138, v233);
  uint64_t v263 = (id)objc_claimAutoreleasedReturnValue(v139);
  v264 = 2LL;
  v265 = 0x100000004LL;

  id v140 = newpool;
  InstrumentFunctionWithResourceTrackingV2((uint64_t)&v235, a1, a2, (uint64_t)&v247, (uint64_t)v233, newpool);
  id v108 = (_BYTE)v235 != 0;
  ReplaceFunctionTablesWithRegular((uint64_t)v214, (uint64_t)a1, 4, *(void *)a2, v233, v140);
  std::__hash_table<std::__hash_value_type<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>,std::__unordered_map_hasher<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::equal_to,std::hash,true>,std::allocator<objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>>::~__hash_table((uint64_t)&v215);
  std::__hash_table<std::__hash_value_type<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>,std::__unordered_map_hasher<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::equal_to,std::hash,true>,std::allocator<objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>>::~__hash_table((uint64_t)v214);
  unint64_t v141 = objc_alloc(&OBJC_CLASS___NSMutableArray);
  unsigned int v142 = v237;
  unint64_t v143 = v236;
  unsigned int v123 = -[NSMutableArray initWithCapacity:](v141, "initWithCapacity:", 0xAAAAAAAAAAAAAAABLL * ((v237 - v236) >> 3));
  if (v143 != v142)
  {
    unint64_t v144 = v143;
    do
    {
      __int128 v230 = *(_OWORD *)v144;
      *(void *)&__int128 v231 = v144[2];
      unsigned int v145 = MakeResourceUsageItem((uint64_t)&v230, 4LL);
      unint64_t v146 = (void *)objc_claimAutoreleasedReturnValue(v145);
      -[NSMutableArray addObject:](v123, "addObject:", v146);

      v144 += 3;
    }

    while (v144 != v142);
  }

  if (v143) {
    operator delete(v143);
  }

LABEL_155:
  std::__hash_table<std::__hash_value_type<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong}>,std::__unordered_map_hasher<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,true>,std::__unordered_map_equal<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},std::equal_to,std::__unordered_map_hasher,true>,std::allocator<objc_object  {objcproto17MTLFunctionHandle}* {__strong}>>::~__hash_table((uint64_t)&v260);
  std::__hash_table<std::__hash_value_type<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>,std::__unordered_map_hasher<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::equal_to,std::hash,true>,std::allocator<objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>>::~__hash_table((uint64_t)&v257);
  std::__hash_table<std::__hash_value_type<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>,std::__unordered_map_hasher<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::equal_to,std::hash,true>,std::allocator<objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>>::~__hash_table((uint64_t)&v254);
  std::__hash_table<std::__hash_value_type<unsigned long,std::unordered_map<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,std::allocator<std::pair<FunctionHandleKey const,objc_object  {objcproto17MTLFunctionHandle}*>>>>,std::__unordered_map_hasher<unsigned long,std::unordered_map<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,std::allocator<std::pair<FunctionHandleKey const,objc_object  {objcproto17MTLFunctionHandle}*>>>,std::hash<unsigned long>,FunctionHandleKeyHash<unsigned long>,true>,std::__unordered_map_equal<unsigned long,std::unordered_map<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,std::allocator<std::pair<FunctionHandleKey const,objc_object  {objcproto17MTLFunctionHandle}*>>>,std::hash<unsigned long>,std::hash,true>,std::equal_to<FunctionHandleKey><std::unordered_map<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,std::allocator<std::pair<FunctionHandleKey const,objc_object  {objcproto17MTLFunctionHandle}*>>>>>::~__hash_table((uint64_t)v253);
  std::__hash_table<std::__hash_value_type<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>,std::__unordered_map_hasher<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::equal_to,std::hash,true>,std::allocator<objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>>::~__hash_table((uint64_t)&v250);
  std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long>>>::~__hash_table((uint64_t)&v247);
LABEL_156:
  uint64_t v96 = context;
LABEL_157:
  objc_autoreleasePoolPop(v96);
  apr_pool_destroy(newpool);
  if (v123)
  {
    uint64_t v157 = -[NSMutableArray copy](v123, "copy");
    *a4 = v157;
  }

  else
  {
    *a4 = &__NSArray0__struct;
  }

  return v108;
}

            *((void *)v75 + 42) = v103;
LABEL_165:
            id v161 = (void *)objc_claimAutoreleasedReturnValue([v555 objectAtIndexedSubscript:*v76]);
            GRCPerFrameData::FindNextMarker((uint64_t)this, v161, v76[1], v76[2], (uint64_t)v76);

            if (v96 >= v558)
            {
              char v162 = (v96 - v19) >> 3;
              uint64_t v163 = v162 + 1;
              double v75 = this;
              if ((v558 - v19) >> 2 > v163) {
                uint64_t v163 = (v558 - v19) >> 2;
              }
              else {
                id v164 = v163;
              }
              if (v164)
              {
                id v164 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<std::pair<unsigned int,unsigned int>>>(v164);
                double v75 = this;
              }

              else
              {
                uint64_t v165 = 0LL;
              }

              id v166 = (char *)(v164 + 8 * v162);
              *(void *)id v166 = v76;
              id v20 = v166 + 8;
              while (v96 != v19)
              {
                id v167 = *((void *)v96 - 1);
                v96 -= 8;
                *((void *)v166 - 1) = v167;
                v166 -= 8;
              }

              __int128 v558 = (char *)(v164 + 8 * v165);
              operator delete(v19);
              float64x2_t v19 = v166;
            }

            else
            {
              *(void *)uint64_t v96 = v76;
              double v75 = this;
            }

            std::__sift_up[abi:nn180100]<std::_ClassicAlgPolicy,GRCPerFrameData::GreaterPQElement &,std::__wrap_iter<GRCPerFrameData::PriorityQueueElement **>>( (BOOL)v19,  (uint64_t)v20,  (v20 - v19) >> 3);
            uint64_t v96 = v20;
            goto LABEL_181;
          }

          if (v97 > 0xD || ((1LL << v97) & 0x3F3F) == 0) {
            goto LABEL_165;
          }
          uint64_t v105 = this;
          uint64_t v106 = *((void *)v76 + 6);
          uint64_t v107 = std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::find<unsigned long long>( (void *)(*((void *)this + 61) + 88LL),  v106);
          if (v107)
          {
            id v108 = v107[3];
            id v109 = (uint64_t *)(v76 + 14);
            uint64_t v110 = *((void *)v76 + 7);
            if (!v108) {
LABEL_141:
            }
              id v108 = v106 + 0xFFFFFFFFLL;
            *id v109 = v108;
            if (v97 - 8 <= 5) {
              *((void *)v76 + 5) -= 8LL;
            }
            uint64_t v133 = *((void *)this + 39);
            uint64_t v132 = *((void *)this + 40);
            if (v133 >= v132)
            {
              uint64_t v139 = *((void *)this + 38);
              id v140 = 0x4EC4EC4EC4EC4EC5LL * ((uint64_t)(v133 - v139) >> 3);
              unint64_t v141 = v140 + 1;
              unsigned int v142 = v110;
              unint64_t v143 = 0x4EC4EC4EC4EC4EC5LL * ((uint64_t)(v132 - v139) >> 3);
              if (2 * v143 > v141) {
                unint64_t v141 = 2 * v143;
              }
              if (v143 >= 0x13B13B13B13B13BLL) {
                unint64_t v144 = 0x276276276276276LL;
              }
              else {
                unint64_t v144 = v141;
              }
              v575 = (char *)this + 320;
              if (v144)
              {
                if (v144 > 0x276276276276276LL) {
                  std::__throw_bad_array_new_length[abi:nn180100]();
                }
                unsigned int v145 = (char *)operator new(104 * v144);
                uint64_t v105 = this;
              }

              else
              {
                unsigned int v145 = 0LL;
              }

              unint64_t v146 = &v145[104 * v140];
              v574[0] = v145;
              v574[1] = v146;
              v574[2] = v146;
              v574[3] = &v145[104 * v144];
              *(_DWORD *)unint64_t v146 = (_DWORD)v586;
              uint64_t v147 = *((_OWORD *)v76 + 3);
              uint64_t v148 = *((_OWORD *)v76 + 4);
              v149 = *(_OWORD *)v1;
              *(_OWORD *)(v146 + 24) = *((_OWORD *)v76 + 2);
              *(_OWORD *)(v146 + _Block_object_dispose(&STACK[0x3B0], 8) = v149;
              *(_OWORD *)(v146 + 56) = v148;
              *(_OWORD *)(v146 + 40) = v147;
              std::vector<unsigned long long>::vector((void *)v146 + 9, (uint64_t)(v76 + 20));
              *((void *)v146 + 12) = v142;
              id v150 = (char *)v574[1];
              uint64_t v138 = (char *)v574[2] + 104;
              v574[2] = (char *)v574[2] + 104;
              uint64_t v152 = *((void *)v105 + 38);
              unint64_t v151 = *((void *)v105 + 39);
              if (v151 == v152)
              {
                id v159 = vdupq_n_s64(v151);
              }

              else
              {
                uint64_t v153 = 0LL;
                do
                {
                  char v154 = &v150[v153];
                  int v155 = v151 + v153;
                  *((_DWORD *)v154 - 26) = *(_DWORD *)(v151 + v153 - 104);
                  *((void *)v154 - 3) = 0LL;
                  *((void *)v154 - 2) = 0LL;
                  *((void *)v154 - 4) = 0LL;
                  *((_OWORD *)v154 - 2) = *(_OWORD *)(v151 + v153 - 32);
                  *((void *)v154 - 2) = *(void *)(v151 + v153 - 16);
                  *(void *)(v155 - 32) = 0LL;
                  *(void *)(v155 - 24) = 0LL;
                  *(void *)(v155 - 16) = 0LL;
                  id v156 = *(_OWORD *)(v151 + v153 - 96);
                  uint64_t v157 = *(_OWORD *)(v151 + v153 - 80);
                  unint64_t v158 = *(_OWORD *)(v151 + v153 - 48);
                  *((_OWORD *)v154 - 4) = *(_OWORD *)(v151 + v153 - 64);
                  *((_OWORD *)v154 - 3) = v158;
                  *((_OWORD *)v154 - 6) = v156;
                  *((_OWORD *)v154 - 5) = v157;
                  *((void *)v154 - 1) = *(void *)(v151 + v153 - 8);
                  v153 -= 104LL;
                }

                while (v151 + v153 != v152);
                v150 += v153;
                id v159 = *((int64x2_t *)v105 + 19);
                uint64_t v138 = (char *)v574[2];
              }

              *((void *)v105 + 3_Block_object_dispose(&STACK[0x3B0], 8) = v150;
              *((void *)v105 + 39) = v138;
              *(int64x2_t *)&v574[1] = v159;
              id v160 = (void *)*((void *)v105 + 40);
              *((void **)v105 + 40) = v574[3];
              v574[3] = v160;
              v574[0] = (void *)v159.i64[0];
              std::__split_buffer<std::tuple<unsigned int,SampleInfoWithPayload,unsigned long long>>::~__split_buffer((uint64_t)v574);
              uint64_t v134 = v586;
            }

            else
            {
              uint64_t v134 = v586;
              *(_DWORD *)uint64_t v133 = (_DWORD)v586;
              __int128 v135 = *((_OWORD *)v76 + 3);
              __int128 v136 = *((_OWORD *)v76 + 4);
              size_t v137 = *((_OWORD *)v76 + 2);
              *(_OWORD *)(v133 + _Block_object_dispose(&STACK[0x3B0], 8) = *(_OWORD *)v1;
              *(_OWORD *)(v133 + 56) = v136;
              *(_OWORD *)(v133 + 40) = v135;
              *(_OWORD *)(v133 + 24) = v137;
              std::vector<unsigned long long>::vector((void *)(v133 + 72), (uint64_t)(v76 + 20));
              *(void *)(v133 + 96) = v110;
              uint64_t v138 = (char *)(v133 + 104);
              *((void *)this + 39) = v138;
            }

            *((void *)v105 + 39) = v138;
            GRCPerFrameData::AddLimiterCounterSample((uint64_t)v105, v134, (__int128 *)v76 + 1, 1);
            goto LABEL_165;
          }

          id v109 = (uint64_t *)(v76 + 14);
          uint64_t v110 = *((void *)v76 + 7);
          goto LABEL_141;
        }

        double v75 = this;
LABEL_184:
        if (*((void *)v75 + 38) != *((void *)v75 + 39)) {
          GRCPerFrameData::AddDeferredKickSamples((ProgramAddressHelper *)v75, v586, (void *)this + 45);
        }
        if (*((void *)v75 + 21))
        {
          id v168 = (void *)*((void *)v75 + 20);
          if (v168)
          {
            do
            {
              id v169 = (void *)*v168;
              operator delete(v168);
              id v168 = v169;
            }

            while (v169);
          }

          *((void *)this + 20) = 0LL;
          uint64_t v170 = *((void *)this + 19);
          if (v170)
          {
            for (unint64_t k = 0LL; k != v170; ++k)
              *(void *)(*((void *)this + 18) + 8 * k) = 0LL;
          }

          *((void *)this + 21) = 0LL;
        }

        [*((id *)v537 + 9) setLength:8 * *((unsigned int *)v537 + 21)];
        if (v19) {
          operator delete(v19);
        }
        v574[0] = &v571;
        std::vector<std::unique_ptr<GRCPerFrameData::PriorityQueueElement>>::__destroy_vector::operator()[abi:nn180100]((void ***)v574);

        objc_autoreleasePoolPop(context);
        v571.i32[0] = [v530 unsignedIntValue];
        id v172 = std::__hash_table<std::__hash_value_type<unsigned int,RingBufferSampledData>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,RingBufferSampledData>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,RingBufferSampledData>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,RingBufferSampledData>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>( (uint64_t)v533,  v571.u32[0],  &v571);
        memset(v574, 0, 24);
        unsigned int v173 = (unint64_t)[*((id *)this + 62) maxConcurrentOperationCount];
        std::vector<unsigned long long>::reserve(v574, v173 + 1);
        __int128 v559 = (_DWORD *)(v172 + 24);
        uint64_t v175 = (unint64_t *)v574[1];
        uint64_t v176 = (unint64_t *)v574[2];
        if (v173)
        {
          char v177 = 0LL;
          uint64_t v178 = (unint64_t *)v574[0];
          do
          {
            unsigned int v179 = (unint64_t)v177 * (*v559 & 0x3FFFFFF) / v173 * ((unint64_t)*v559 >> 26);
            if (v175 >= v176)
            {
              id v180 = v175 - v178;
              uint64_t v181 = v180 + 1;
              if ((unint64_t)(v180 + 1) >> 61)
              {
                v574[0] = v178;
                abort();
              }

              else {
                id v182 = v181;
              }
              if (v182) {
                id v182 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<std::pair<unsigned int,unsigned int>>>(v182);
              }
              else {
                uint64_t v174 = 0LL;
              }
              id v183 = (unint64_t *)(v182 + 8 * v180);
              *id v183 = v179;
              uint64_t v1 = (uint64_t)(v183 + 1);
              while (v175 != v178)
              {
                uint64_t v184 = *--v175;
                *--id v183 = v184;
              }

              uint64_t v176 = (unint64_t *)(v182 + 8 * v174);
              v574[1] = (void *)v1;
              if (v178) {
                operator delete(v178);
              }
              uint64_t v178 = v183;
              uint64_t v175 = (unint64_t *)v1;
            }

            else
            {
              *v175++ = v179;
            }

            v574[1] = v175;
            char v177 = (char *)v177 + 1;
          }

          while (v177 != (void *)v173);
          v574[2] = v176;
          v574[0] = v178;
        }

        uint64_t v185 = ((*(void *)(v172 + 40) - *(void *)(v172 + 32)) >> 2);
        if (v175 >= v176)
        {
          v186 = (unint64_t *)v574[0];
          v187 = ((char *)v175 - (char *)v574[0]) >> 3;
          id v188 = v187 + 1;
          else {
            id v189 = v188;
          }
          if (v189) {
            id v189 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<std::pair<unsigned int,unsigned int>>>(v189);
          }
          else {
            uint64_t v174 = 0LL;
          }
          id v190 = (unint64_t *)(v189 + 8 * v187);
          void *v190 = v185;
          id v191 = v190 + 1;
          while (v175 != v186)
          {
            id v192 = *--v175;
            *--id v190 = v192;
          }

          v574[0] = v190;
          v574[1] = v191;
          v574[2] = (void *)(v189 + 8 * v174);
          if (v186) {
            operator delete(v186);
          }
        }

        else
        {
          *uint64_t v175 = v185;
        }

        id v193 = (unsigned int *)(v172 + 24);
        id v194 = (void *)objc_opt_new(&OBJC_CLASS___NSOperation, v174);
        unint64_t v195 = objc_claimAutoreleasedReturnValue( +[NSMutableData dataWithLength:]( &OBJC_CLASS___NSMutableData,  "dataWithLength:",  8LL * (*v559 & 0x3FFFFFFu) * *((_DWORD *)this + 130)));
        id v196 = *(void **)(v172 + 104);
        *(void *)(v172 + 104) = v195;

        id v556 = [*(id *)(v172 + 104) mutableBytes];
        id v197 = [*(id *)(v172 + 56) mutableBytes];
        uint64_t v198 = (unint64_t)[*(id *)(v172 + 56) length];
        v199 = v198;
        *(void *)&v590 = 0LL;
        *((void *)&v590 + 1) = &v590;
        *(void *)&v591 = 0x4812000000LL;
        *((void *)&v591 + 1) = __Block_byref_object_copy__357;
        *(void *)&v592 = __Block_byref_object_dispose__358;
        *((void *)&v592 + 1) = "";
        __p[1] = 0LL;
        v594 = 0LL;
        __p[0] = 0LL;
        if (v198 >= 8)
        {
          BOOL v200 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<std::pair<unsigned int,unsigned int>>>(v198 >> 3);
          __p[0] = v200;
          v594 = (const __CFString *)&v200[8 * v201];
          BOOL v202 = v199 & 0xFFFFFFFFFFFFFFF8LL;
          bzero(v200, v202);
          __p[1] = &v200[v202];
        }

        if ((*v559 & 0x3FFFFFE) != 0)
        {
          uint64_t v203 = 0LL;
          do
          {
            *(void *)(*(void *)(*((void *)&v590 + 1) + 48LL) + 8 * v203 + _Block_object_dispose(&STACK[0x3B0], 8) = v197[v203 + 1] - v197[v203];
            char v204 = v203 + 2;
            ++v203;
          }

          while (v204 < (*v559 & 0x3FFFFFFu));
        }

        BOOL v205 = *(void **)(*((void *)&v590 + 1) + 48LL);
        if (*(void *)(*((void *)&v590 + 1) + 56LL) - (void)v205 > 8uLL) {
          *BOOL v205 = v205[1];
        }
        if (v173)
        {
          unint64_t v206 = 0LL;
          id v547 = (char *)v574[0];
          uint64_t v544 = v571.i32[0];
          do
          {
            uint64_t v207 = v194;
            uint64_t v208 = (void **)&v547[8 * v206];
            int v209 = *v208;
            __int128 v210 = v208[1];
            int v211 = *v193;
            __int128 v212 = (void *)objc_claimAutoreleasedReturnValue( [*(id *)(*((void *)this + 61) + 280) objectForKeyedSubscript:@"DerivedCounterScript"]);
            __int128 v213 = *(id *)(*((void *)this + 61) + 288LL);
            __int128 v214 = (void *)objc_claimAutoreleasedReturnValue( [*(id *)(*((void *)this + 61) + 280) objectForKeyedSubscript:@"DerivedCounterConfigurationVariables"]);
            v602 = _NSConcreteStackBlock;
            v603.i64[0] = 3221225472LL;
            v603.i64[1] = (uint64_t)___ZN15GRCPerFrameData23EvaluateDerivedLimitersEj_block_invoke;
            v604 = &unk_58FB58;
            v608 = this;
            __int128 v215 = v212;
            v605 = v215;
            __int128 v216 = v213;
            *(void *)&v606 = v216;
            __int128 v217 = v214;
            *((void *)&v606 + 1) = v217;
            v607 = &v590;
            v609 = v209;
            v610 = v559;
            v611 = (v210 - (_BYTE *)v209) / (v211 >> 26);
            v612 = v206;
            LODWORD(v615) = v544;
            v613 = v559;
            v614 = v556;
            uint64_t v1 = objc_claimAutoreleasedReturnValue( +[NSBlockOperation blockOperationWithBlock:]( &OBJC_CLASS___NSBlockOperation,  "blockOperationWithBlock:",  &v602));
            id v194 = v207;
            [*((id *)this + 62) addOperation:v1];
            [v207 addDependency:v1];

            id v193 = v559;
            ++v206;
          }

          while (v173 != v206);
        }

        [*((id *)this + 62) addOperation:v194];
        [v194 waitUntilFinished];
        _Block_object_dispose(&v590, 8);
        if (__p[0])
        {
          __p[1] = __p[0];
          operator delete(__p[0]);
        }

        if (v574[0]) {
          operator delete(v574[0]);
        }
        __int128 v218 = objc_autoreleasePoolPush();
        unint64_t v219 = [v530 unsignedIntValue];
        LODWORD(v574[0]) = (_DWORD)v219;
        __int128 v220 = std::__hash_table<std::__hash_value_type<unsigned int,RingBufferSampledData>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,RingBufferSampledData>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,RingBufferSampledData>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,RingBufferSampledData>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>( (uint64_t)v533,  v219,  v574);
        __int128 v221 = v220;
        if ((*(_DWORD *)(v220 + 24) & 0x3FFFFFF) != 0 && *(_DWORD *)(v220 + 80))
        {
          __int128 v222 = std::thread::hardware_concurrency();
          __int128 v223 = v222 >> 1;
          unint64_t v224 = (void *)objc_claimAutoreleasedReturnValue( +[NSMutableArray arrayWithCapacity:]( &OBJC_CLASS___NSMutableArray,  "arrayWithCapacity:",  v223));
          if (v222 >= 2)
          {
            __int128 v225 = 0LL;
            if (v223 <= 1) {
              __int128 v226 = 1LL;
            }
            else {
              __int128 v226 = v222 >> 1;
            }
            do
            {
              __int128 v227 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedInt:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedInt:",  *(unsigned int *)(*(void *)(v221 + 112)
                                                 + 4 * (v225 * (unint64_t)*(unsigned int *)(v221 + 80) / v223))));
              [v224 addObject:v227];

              ++v225;
            }

            while (v226 != v225);
          }

          __int128 v228 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedInt:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedInt:",  *(unsigned int *)(v221 + 84)));
          [v224 addObject:v228];

          unint64_t v229 = (void *)objc_claimAutoreleasedReturnValue( +[NSMutableDictionary dictionaryWithCapacity:]( &OBJC_CLASS___NSMutableDictionary,  "dictionaryWithCapacity:",  *(void *)(*((void *)this + 61) + 152LL)));
          for (uint64_t m = *(void **)(*((void *)this + 61) + 144LL); m; uint64_t m = (void *)*m)
          {
            __int128 v231 = (void *)objc_claimAutoreleasedReturnValue( +[NSMutableArray arrayWithCapacity:]( &OBJC_CLASS___NSMutableArray,  "arrayWithCapacity:",  (uint64_t)(m[4] - m[3]) >> 4));
            uint64_t v232 = m[3];
            id v233 = m[4];
            while (v232 != v233)
            {
              v234 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  *(void *)(v232 + 8)));
              [v231 addObject:v234];

              v232 += 16LL;
            }

            if ((unint64_t)[v231 count] >= 2)
            {
              uint64_t v235 = (void *)objc_claimAutoreleasedReturnValue([v231 firstObject]);
              [v229 setObject:v231 forKeyedSubscript:v235];
            }
          }

          *(void *)&v590 = @"ring buffer";
          id v236 = (void **)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInt:](&OBJC_CLASS___NSNumber, "numberWithUnsignedInt:", v219));
          v602 = v236;
          *((void *)&v590 + 1) = @"frame index";
          id v237 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedInt:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedInt:",  *(unsigned int *)(*((void *)this + 61) + 360LL)));
          v238 = *(void *)(v221 + 104);
          v603.i64[0] = (uint64_t)v237;
          v603.i64[1] = v238;
          *(void *)&v591 = @"limiter data";
          *((void *)&v591 + 1) = @"limiter time stamps";
          unint64_t v239 = *(__int128 **)(*((void *)this + 61) + 296LL);
          v604 = *(void **)(v221 + 56);
          v605 = v239;
          *(void *)&v592 = @"limiter counter list";
          *((void *)&v592 + 1) = @"shader timeline data";
          v606 = *(_OWORD *)(v221 + 88);
          __p[0] = @"shader timeline data ex";
          __p[1] = @"usc sampling sample data";
          v607 = *(__int128 **)(v221 + 72);
          v594 = @"usc sample count";
          v240 = (GRCPerFrameData *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedInt:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedInt:",  *(unsigned int *)(v221 + 80)));
          v608 = v240;
          v609 = v224;
          v595 = @"usc sample data thread offsets";
          v596 = @"usc sampling address data";
          id v241 = *((void *)this + 61);
          id v242 = *(void **)(v241 + 312);
          if (!v242) {
            id v242 = &__NSArray0__struct;
          }
          v610 = *(_DWORD **)(v241 + 304);
          v611 = (unint64_t)v242;
          v597 = @"usc sampling address mappings";
          v598 = @"DerivedCounterConfigurationVariables";
          id v243 = objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(v241 + 280), "objectForKeyedSubscript:"));
          unint64_t v244 = (void *)v243;
          uint64_t v245 = *((void *)this + 61);
          v247 = *(_UNKNOWN ***)(v245 + 320);
          int v246 = *(void **)(v245 + 328);
          if (!v247) {
            v247 = &off_5A03F8;
          }
          v612 = v243;
          v613 = v247;
          v599 = @"Frame Consistent Perf Info";
          v600 = @"coalesced encoder mapping";
          v601 = @"Restore Timestamps";
          if (!v246) {
            int v246 = &__NSArray0__struct;
          }
          v614 = v229;
          v615 = v246;
          uint64_t v1 = objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v602,  &v590,  16LL));

          uint64_t v248 = (id)(*(uint64_t (**)(void))(*((void *)this + 63) + 16LL))();
        }

        objc_autoreleasePoolPop(v218);

        io_connect_t v2 = this;
      }

      v525 = [obj countByEnumeratingWithState:&v561 objects:v589 count:16];
    }

    while (v525);
  }

  if (*((_DWORD *)this + 134) != 2) {
    return;
  }
  int v249 = [**((id **)this + 61) count];
  uint64_t v541 = v249;
  uint64_t v250 = v249;
  v553 = v249;
  if (v249)
  {
    id v550 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<std::vector<NSObject  {objcproto21OS_dispatch_semaphore}* {__strong}>>>(v249);
    uint64_t v252 = &v550[24 * v251];
    uint64_t v250 = v553;
  }

  else
  {
    uint64_t v252 = 0LL;
    id v550 = 0LL;
  }

  v586 = 0LL;
  v587 = 0LL;
  v588 = 0LL;
  uint64_t v253 = v250;
  std::vector<BufferView2D<double>>::reserve(&v586, v250);
  uint64_t v254 = 8 * v253;
  if (v253)
  {
    v255 = v253;
    v256 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<std::pair<unsigned int,unsigned int>>>(v253);
    bzero(v256, v254);
    __int128 v560 = v256;
    v526 = &v256[8 * v255];
  }

  else
  {
    v526 = 0LL;
    __int128 v560 = 0LL;
  }

  v516 = v254;
  LODWORD(v602) = 0;
  if (v541)
  {
    v257 = 0;
    v538 = 0LL;
    unint64_t v548 = -1LL;
    uint64_t v258 = v550;
    do
    {
      v259 = std::__hash_table<std::__hash_value_type<unsigned int,RingBufferSampledData>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,RingBufferSampledData>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,RingBufferSampledData>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,RingBufferSampledData>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>( (uint64_t)this + 448,  v257,  &v602);
      uint64_t v260 = v259;
      if (v258 >= v252)
      {
        uint64_t v261 = 0xAAAAAAAAAAAAAAABLL * ((v258 - v550) >> 3) + 1;
        if (v261 > 0xAAAAAAAAAAAAAAALL) {
          abort();
        }
        if (0x5555555555555556LL * ((v252 - v550) >> 3) > v261) {
          uint64_t v261 = 0x5555555555555556LL * ((v252 - v550) >> 3);
        }
        if (0xAAAAAAAAAAAAAAABLL * ((v252 - v550) >> 3) >= 0x555555555555555LL) {
          v262 = 0xAAAAAAAAAAAAAAALL;
        }
        else {
          v262 = v261;
        }
        if (v262)
        {
          uint64_t v263 = std::__allocate_at_least[abi:nn180100]<std::allocator<std::vector<NSObject  {objcproto21OS_dispatch_semaphore}* {__strong}>>>(v262);
          v265 = v264;
        }

        else
        {
          uint64_t v263 = 0LL;
          v265 = 0LL;
        }

        uint64_t v266 = (char *)BufferView<unsigned long long>::BufferView(&v263[(v258 - v550) >> 3], *(void **)(v260 + 56));
        if (v258 == v550)
        {
          uint64_t v269 = v258;
          id v550 = v266;
        }

        else
        {
          v267 = v266;
          do
          {
            uint64_t v268 = *(_OWORD *)(v258 - 24);
            *((void *)v267 - 1) = *((void *)v258 - 1);
            *(_OWORD *)(v267 - 24) = v268;
            v267 -= 24;
            v258 -= 24;
          }

          while (v258 != v550);
          uint64_t v269 = v550;
          id v550 = v267;
        }

        uint64_t v252 = (char *)&v263[3 * v265];
        uint64_t v258 = v266 + 24;
        if (v269) {
          operator delete(v269);
        }
      }

      else
      {
        BufferView<unsigned long long>::BufferView(v258, *(void **)(v259 + 56));
        v258 += 24;
      }

      v270 = *((void *)v258 - 1);
      if (v270)
      {
        v271 = (unint64_t *)*((void *)v258 - 3);
        uint64_t v272 = v548;
        if (v548 >= *v271) {
          uint64_t v272 = *v271;
        }
        unint64_t v548 = v272;
        v273 = v271[v270 - 1];
        v274 = v538;
        v538 = v274;
      }

      v275 = v587;
      if ((unint64_t)v587 >= v588)
      {
        uint64_t v277 = ((char *)v587 - (_BYTE *)v586) >> 5;
        __int128 v278 = (uint64_t)(v588 - (void)v586) >> 4;
        if (v278 <= v277 + 1) {
          __int128 v278 = v277 + 1;
        }
        else {
          uint64_t v279 = v278;
        }
        if (v279)
        {
          uint64_t v280 = (char **)std::__allocate_at_least[abi:nn180100]<std::allocator<GTMMappedBufferBlock>>(v279);
          __int128 v282 = v281;
        }

        else
        {
          uint64_t v280 = 0LL;
          __int128 v282 = 0LL;
        }

        id v283 = BufferView2D<double>::BufferView2D( &v280[4 * v277],  *(void **)(v260 + 104),  (char *)*((unsigned int *)this + 130));
        id v285 = (char **)v586;
        __int128 v284 = v587;
        uint64_t v286 = v283;
        if (v587 != v586)
        {
          do
          {
            __int128 v287 = *((_OWORD *)v284 - 1);
            *((_OWORD *)v286 - 2) = *((_OWORD *)v284 - 2);
            *((_OWORD *)v286 - 1) = v287;
            v286 -= 4;
            v284 -= 4;
          }

          while (v284 != v285);
          __int128 v284 = v285;
        }

        uint64_t v276 = v283 + 4;
        v586 = v286;
        v588 = (unint64_t)&v280[4 * v282];
        if (v284) {
          operator delete(v284);
        }
      }

      else
      {
        BufferView2D<double>::BufferView2D(v587, *(void **)(v260 + 104), (char *)*((unsigned int *)this + 130));
        uint64_t v276 = v275 + 4;
      }

      v587 = v276;
      v257 = (_DWORD)v602 + 1;
      LODWORD(v602) = v257;
    }

    while (v257 < v541);
  }

  else
  {
    v538 = 0LL;
    unint64_t v548 = -1LL;
  }

  __int128 v288 = this;
  id v289 = *((unsigned int *)this + 130);
  v584 = 0LL;
  v585 = 0LL;
  v583 = 0LL;
  if ((_DWORD)v289)
  {
    std::vector<BOOL>::__vallocate[abi:nn180100](&v583, v289);
    uint64_t v290 = v584;
    __int128 v291 = v584 + v289;
    v584 += v289;
    if (v290)
    {
      id v292 = v291 - 1;
      if (((v291 - 1) ^ (v290 - 1)) <= 0x3F)
      {
        __int128 v293 = v583;
        goto LABEL_331;
      }
    }

    else
    {
      id v292 = v291 - 1;
    }

    __int128 v293 = v583;
    id v294 = v292 >> 6;
    if (v291 >= 0x41) {
      __int128 v295 = v294;
    }
    else {
      __int128 v295 = 0LL;
    }
    *((void *)v583 + v295) = 0LL;
LABEL_331:
    v602 = (void **)&v293[v290 >> 6];
    v603.i32[0] = v290 & 0x3F;
    std::__fill_n[abi:nn180100]<false,std::vector<BOOL>>((uint64_t)&v602, v289);
    if (*((_DWORD *)this + 130))
    {
      id v296 = 0LL;
      __int128 v297 = this;
      do
      {
        uint64_t v298 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(*((void *)v297 + 61) + 296), "objectAtIndexedSubscript:", v296, v516));
        v299 = [v298 containsString:@"Bandwidth"];
        uint64_t v300 = v296 >> 6;
        uint64_t v301 = 1LL << v296;
        if ((v299 & 1) != 0) {
          id v302 = v293[v300] & ~v301;
        }
        else {
          id v302 = v293[v300] | v301;
        }
        v293[v300] = v302;

        ++v296;
        __int128 v297 = this;
      }

      while (v296 < *((unsigned int *)this + 130));
      __int128 v288 = this;
    }
  }

  contexta = (void *)objc_claimAutoreleasedReturnValue( +[NSMutableArray arrayWithCapacity:]( &OBJC_CLASS___NSMutableArray,  "arrayWithCapacity:",  (uint64_t)(*(void *)(*((void *)v288 + 61) + 264LL)
                                 - *(void *)(*((void *)v288 + 61) + 256LL)) >> 2,
                         v516));
  v303 = *((void *)v288 + 61);
  v304 = *(unsigned int **)(v303 + 256);
  for (uint64_t n = *(unsigned int **)(v303 + 264); v304 != n; ++v304)
  {
    id v306 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInt:](&OBJC_CLASS___NSNumber, "numberWithUnsignedInt:", *v304));
    [contexta addObject:v306];
  }

  __int128 v534 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableArray arrayWithCapacity:](&OBJC_CLASS___NSMutableArray, "arrayWithCapacity:", v553));
  v580 = 0LL;
  v581 = 0LL;
  v582 = 0LL;
  std::vector<DYMTLShaderProfilerProgramAddress>::reserve(&v580, v553);
  char v536 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableArray arrayWithCapacity:](&OBJC_CLASS___NSMutableArray, "arrayWithCapacity:", v553));
  v577 = 0LL;
  v578 = 0LL;
  v579 = 0LL;
  std::vector<BufferView2D<double>>::reserve(&v577, v553);
  id v520 = ((unint64_t)v538 - v548) / 0x3C;
  v307 = v520 + 1;
  if (v541)
  {
    for (iuint64_t i = 0; ii != v541; ++ii)
    {
      id v309 = (void *)objc_claimAutoreleasedReturnValue( +[NSMutableData dataWithLength:]( &OBJC_CLASS___NSMutableData,  "dataWithLength:",  8LL * (*((_DWORD *)this + 130) * v307)));
      [v536 addObject:v309];

      uint64_t v310 = (void *)objc_claimAutoreleasedReturnValue([v536 lastObject]);
      uint64_t v311 = v578;
      if ((unint64_t)v578 >= v579)
      {
        id v313 = ((char *)v578 - (_BYTE *)v577) >> 5;
        v314 = (uint64_t)(v579 - (void)v577) >> 4;
        if (v314 <= v313 + 1) {
          v314 = v313 + 1;
        }
        else {
          v315 = v314;
        }
        if (v315)
        {
          uint64_t v316 = (char **)std::__allocate_at_least[abi:nn180100]<std::allocator<GTMMappedBufferBlock>>(v315);
          v318 = v317;
        }

        else
        {
          uint64_t v316 = 0LL;
          v318 = 0LL;
        }

        v319 = BufferView2D<double>::BufferView2D(&v316[4 * v313], v310, (char *)*((unsigned int *)this + 130));
        id v321 = (char **)v577;
        id v320 = v578;
        v322 = v319;
        if (v578 != v577)
        {
          do
          {
            id v323 = *((_OWORD *)v320 - 1);
            *((_OWORD *)v322 - 2) = *((_OWORD *)v320 - 2);
            *((_OWORD *)v322 - 1) = v323;
            v322 -= 4;
            v320 -= 4;
          }

          while (v320 != v321);
          id v320 = v321;
        }

        v312 = v319 + 4;
        v577 = v322;
        v579 = (unint64_t)&v316[4 * v318];
        if (v320) {
          operator delete(v320);
        }
      }

      else
      {
        BufferView2D<double>::BufferView2D(v578, v310, (char *)*((unsigned int *)this + 130));
        v312 = v311 + 4;
      }

      v578 = v312;

      v324 = (void *)objc_claimAutoreleasedReturnValue( +[NSMutableData dataWithLength:]( &OBJC_CLASS___NSMutableData,  "dataWithLength:",  8LL * (v520 + 1)));
      [v534 addObject:v324];

      v325 = (void *)objc_claimAutoreleasedReturnValue([v534 lastObject]);
      int v326 = v581;
      if ((unint64_t)v581 >= v582)
      {
        v328 = 0xAAAAAAAAAAAAAAABLL * ((v581 - (_BYTE *)v580) >> 3);
        v329 = v328 + 1;
        if (v328 + 1 > 0xAAAAAAAAAAAAAAALL) {
          abort();
        }
        else {
          v330 = v329;
        }
        if (v330)
        {
          v331 = std::__allocate_at_least[abi:nn180100]<std::allocator<std::vector<NSObject  {objcproto21OS_dispatch_semaphore}* {__strong}>>>(v330);
          id v333 = v332;
        }

        else
        {
          v331 = 0LL;
          id v333 = 0LL;
        }

        id v334 = (char *)BufferView<double>::BufferView(&v331[3 * v328], v325);
        v336 = v580;
        uint64_t v335 = v581;
        unsigned int v337 = v334;
        if (v581 != v580)
        {
          do
          {
            id v338 = *(_OWORD *)(v335 - 3);
            *((void *)v337 - 1) = *(v335 - 1);
            *(_OWORD *)(v337 - 24) = v338;
            v337 -= 24;
            v335 -= 3;
          }

          while (v335 != v336);
          uint64_t v335 = v580;
        }

        v327 = v334 + 24;
        v580 = v337;
        v582 = (unint64_t)&v331[3 * v333];
        if (v335) {
          operator delete(v335);
        }
      }

      else
      {
        BufferView<double>::BufferView(v581, v325);
        v327 = v326 + 24;
      }

      v581 = v327;
    }
  }

  id v522 = (void *)objc_claimAutoreleasedReturnValue( +[NSMutableData dataWithLength:]( &OBJC_CLASS___NSMutableData,  "dataWithLength:",  8LL * (*((_DWORD *)this + 130) * v307)));
  BufferView2D<double>::BufferView2D(v576, v522, (char *)*((unsigned int *)this + 130));
  id v527 = (void *)objc_claimAutoreleasedReturnValue( +[NSMutableData dataWithCapacity:]( &OBJC_CLASS___NSMutableData,  "dataWithCapacity:",  8LL * (v520 + 1)));
  id v339 = (char *)*((void *)this + 59);
  if (!v339)
  {
    v531 = 0LL;
    v340 = 0LL;
LABEL_381:
    uint64_t v343 = 0LL;
    goto LABEL_382;
  }

  v340 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<std::vector<NSObject  {objcproto21OS_dispatch_semaphore}* {__strong}>>>((unint64_t)v339);
  v531 = &v340[24 * v341];
  id v339 = (char *)*((void *)this + 59);
  if (!v339) {
    goto LABEL_381;
  }
  id v339 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<std::vector<NSObject  {objcproto21OS_dispatch_semaphore}* {__strong}>>>((unint64_t)v339);
  uint64_t v343 = &v339[24 * v342];
LABEL_382:
  __int128 v545 = v339;
  v557 = v340;
  v344 = (uint64_t **)*((void *)this + 58);
  if (v344)
  {
    v345 = 0LL;
    id v346 = v340;
    uint64_t v347 = v339;
    do
    {
      if (v346 >= v531)
      {
        uint64_t v348 = 0xAAAAAAAAAAAAAAABLL * ((v346 - v557) >> 3) + 1;
        if (v348 > 0xAAAAAAAAAAAAAAALL) {
          abort();
        }
        if (0x5555555555555556LL * ((v531 - v557) >> 3) > v348) {
          uint64_t v348 = 0x5555555555555556LL * ((v531 - v557) >> 3);
        }
        if (0xAAAAAAAAAAAAAAABLL * ((v531 - v557) >> 3) >= 0x555555555555555LL) {
          v349 = 0xAAAAAAAAAAAAAAALL;
        }
        else {
          v349 = v348;
        }
        if (v349)
        {
          id v350 = std::__allocate_at_least[abi:nn180100]<std::allocator<std::vector<NSObject  {objcproto21OS_dispatch_semaphore}* {__strong}>>>(v349);
          uint64_t v352 = v351;
        }

        else
        {
          id v350 = 0LL;
          uint64_t v352 = 0LL;
        }

        v353 = (char *)BufferView<ShaderProfilerSampleTimelineInfo>::BufferView(&v350[(v346 - v557) >> 3], v344[11]);
        if (v346 == v557)
        {
          v357 = v353;
          v355 = v557;
        }

        else
        {
          uint64_t v354 = v353;
          v355 = v557;
          do
          {
            v356 = *(_OWORD *)(v346 - 24);
            v357 = v354 - 24;
            *((void *)v354 - 1) = *((void *)v346 - 1);
            *(_OWORD *)(v354 - 24) = v356;
            v346 -= 24;
            v354 -= 24;
          }

          while (v346 != v557);
        }

        v531 = (char *)&v350[3 * v352];
        id v346 = v353 + 24;
        if (v355) {
          operator delete(v355);
        }
        v557 = v357;
      }

      else
      {
        BufferView<ShaderProfilerSampleTimelineInfo>::BufferView(v346, v344[11]);
        v346 += 24;
      }

      if (v347 >= v343)
      {
        id v358 = 0xAAAAAAAAAAAAAAABLL * ((v347 - v545) >> 3) + 1;
        if (v358 > 0xAAAAAAAAAAAAAAALL) {
          abort();
        }
        if (0x5555555555555556LL * ((v343 - v545) >> 3) > v358) {
          id v358 = 0x5555555555555556LL * ((v343 - v545) >> 3);
        }
        if (0xAAAAAAAAAAAAAAABLL * ((v343 - v545) >> 3) >= 0x555555555555555LL) {
          uint64_t v359 = 0xAAAAAAAAAAAAAAALL;
        }
        else {
          uint64_t v359 = v358;
        }
        if (v359)
        {
          v360 = std::__allocate_at_least[abi:nn180100]<std::allocator<std::vector<NSObject  {objcproto21OS_dispatch_semaphore}* {__strong}>>>(v359);
          v362 = v361;
        }

        else
        {
          v360 = 0LL;
          v362 = 0LL;
        }

        v363 = (char *)BufferView<ShaderProfilerSampleTimelineInfoEx>::BufferView(&v360[(v347 - v545) >> 3], v344[12]);
        if (v347 == v545)
        {
          v367 = v363;
          id v365 = v545;
        }

        else
        {
          v364 = v363;
          id v365 = v545;
          do
          {
            id v366 = *(_OWORD *)(v347 - 24);
            v367 = v364 - 24;
            *((void *)v364 - 1) = *((void *)v347 - 1);
            *(_OWORD *)(v364 - 24) = v366;
            v347 -= 24;
            v364 -= 24;
          }

          while (v347 != v545);
        }

        uint64_t v343 = (char *)&v360[3 * v362];
        uint64_t v347 = v363 + 24;
        if (v365) {
          operator delete(v365);
        }
        __int128 v545 = v367;
      }

      else
      {
        BufferView<ShaderProfilerSampleTimelineInfoEx>::BufferView(v347, v344[12]);
        v347 += 24;
      }

      v345 += *((void *)v346 - 1);
      v344 = (uint64_t **)*v344;
    }

    while (v344);
    if (v345)
    {
      v345 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<std::vector<NSObject  {objcproto21OS_dispatch_semaphore}* {__strong}>>>((unint64_t)v345);
      v369 = &v345[24 * v368];
      goto LABEL_428;
    }
  }

  else
  {
    v345 = 0LL;
  }

  v369 = 0LL;
LABEL_428:
  if (v541)
  {
    id v370 = 0LL;
    v371 = (unint64_t)v345;
    do
    {
      if (*(void *)&v557[24 * v370 + 16])
      {
        uint64_t v372 = 0LL;
        do
        {
          uint64_t v373 = *(void *)&v557[24 * v370] + 24 * v372;
          v374 = *(void *)&v545[24 * v370] + 24 * v372;
          if (v371 >= (unint64_t)v369)
          {
            v375 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v371 - (void)v345) >> 3) + 1;
            if (v375 > 0xAAAAAAAAAAAAAAALL) {
              abort();
            }
            if (0x5555555555555556LL * ((v369 - v345) >> 3) > v375) {
              v375 = 0x5555555555555556LL * ((v369 - v345) >> 3);
            }
            if (0xAAAAAAAAAAAAAAABLL * ((v369 - v345) >> 3) >= 0x555555555555555LL) {
              v376 = 0xAAAAAAAAAAAAAAALL;
            }
            else {
              v376 = v375;
            }
            v377 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<std::vector<NSObject  {objcproto21OS_dispatch_semaphore}* {__strong}>>>(v376);
            id v379 = &v377[8 * ((uint64_t)(v371 - (void)v345) >> 3)];
            *(void *)id v379 = v373;
            *((void *)v379 + 1) = v374;
            *((_DWORD *)v379 + 4) = v370;
            if ((char *)v371 == v345)
            {
              v382 = &v377[8 * ((uint64_t)(v371 - (void)v345) >> 3)];
            }

            else
            {
              v380 = &v377[8 * ((uint64_t)(v371 - (void)v345) >> 3)];
              do
              {
                v381 = *(_OWORD *)(v371 - 24);
                v382 = v380 - 24;
                *((void *)v380 - 1) = *(void *)(v371 - 8);
                *(_OWORD *)(v380 - 24) = v381;
                v371 -= 24LL;
                v380 -= 24;
              }

              while ((char *)v371 != v345);
            }

            v369 = &v377[24 * v378];
            v371 = (unint64_t)(v379 + 24);
            if (v345) {
              operator delete(v345);
            }
            v345 = v382;
          }

          else
          {
            *(void *)v371 = v373;
            *(void *)(v371 + _Block_object_dispose(&STACK[0x3B0], 8) = v374;
            *(_DWORD *)(v371 + 16) = v370;
            v371 += 24LL;
          }

          ++v372;
        }

        while (v372 < *(void *)&v557[24 * v370 + 16]);
      }

      ++v370;
    }

    while (v370 != v553);
  }

  else
  {
    v371 = (unint64_t)v345;
  }

  v383 = 126 - 2 * __clz(0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v371 - (void)v345) >> 3));
  else {
    v384 = v383;
  }
  std::__introsort<std::_ClassicAlgPolicy,std::__less<void,void> &,GRCPerFrameData::EvaluateAggregatedSamples(void)::ShaderTimelineInfos *,false>( (uint64_t)v345,  v371,  v384,  1);
  memset(v574, 0, sizeof(v574));
  LODWORD(v575) = 1065353216;
  std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__rehash<true>( (uint64_t)v574,  0x20uLL);
  __int128 v571 = 0u;
  __int128 v572 = 0u;
  __int128 v573 = 1065353216;
  std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__rehash<true>( (uint64_t)&v571,  0x20uLL);
  v524 = (void *)objc_claimAutoreleasedReturnValue( +[NSMutableData dataWithCapacity:]( &OBJC_CLASS___NSMutableData,  "dataWithCapacity:",  v371 - (void)v345));
  __int128 v532 = (void *)objc_claimAutoreleasedReturnValue( +[NSMutableData dataWithCapacity:]( &OBJC_CLASS___NSMutableData,  "dataWithCapacity:",  v371 - (void)v345));
  v568 = 0LL;
  v569 = 0LL;
  v570 = 0LL;
  std::vector<unsigned long long>::reserve((void **)&v568, v520 + 1);
  if ((unint64_t)v538 >= v548)
  {
    v386 = v569;
    v385 = v570;
    v387 = v568;
    do
    {
      if ((unint64_t)v386 >= v385)
      {
        v390 = v386 - v387;
        v391 = v390 + 1;
        if ((unint64_t)(v390 + 1) >> 61)
        {
          v570 = v385;
          v568 = v387;
          abort();
        }

        else {
          id v392 = v391;
        }
        if (v392) {
          id v392 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<std::pair<unsigned int,unsigned int>>>(v392);
        }
        else {
          id v393 = 0LL;
        }
        id v394 = (unint64_t *)(v392 + 8 * v390);
        *id v394 = v548;
        v389 = v394 + 1;
        while (v386 != v387)
        {
          id v395 = *--v386;
          *--id v394 = v395;
        }

        v385 = v392 + 8 * v393;
        v569 = v389;
        if (v387) {
          operator delete(v387);
        }
        v387 = v394;
        id v388 = v548;
      }

      else
      {
        id v388 = v548;
        void *v386 = v548;
        v389 = v386 + 1;
      }

      v569 = v389;
      v386 = v389;
      unint64_t v548 = v388 + 60;
    }

    while (v388 + 60 <= (unint64_t)v538);
    v570 = v385;
    v568 = v387;
  }

  __int128 v565 = 0LL;
  v566 = 0LL;
  uint64_t v567 = 0LL;
  std::vector<std::pair<unsigned long long,unsigned long long>>::reserve( (void **)&v565,  0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v371 - (void)v345) >> 3));
  if ((char *)v371 != v345)
  {
    for (jint j = (unsigned int **)v345; jj != (unsigned int **)v371; jj += 3)
    {
      v397 = *jj;
      v398 = ((unint64_t)**jj >> 1) & 7 | ((unint64_t)(*jj)[5] << 32);
      if (!v574[1]) {
        goto LABEL_495;
      }
      uint64_t v399 = (uint8x8_t)vcnt_s8((int8x8_t)v574[1]);
      v399.i16[0] = vaddlv_u8(v399);
      if (v399.u32[0] > 1uLL)
      {
        v400 = ((unint64_t)**jj >> 1) & 7 | ((unint64_t)(*jj)[5] << 32);
      }

      else
      {
        v400 = ((unint64_t)v574[1] - 1) & v398;
      }

      v401 = (void ***)*((void *)v574[0] + v400);
      if (v401)
      {
        for (kunint64_t k = *v401; kk; kunint64_t k = (void **)*kk)
        {
          int v403 = (unint64_t)kk[1];
          if (v403 == v398)
          {
          }

          else
          {
            if (v399.u32[0] > 1uLL)
            {
            }

            else
            {
              v403 &= (unint64_t)v574[1] - 1;
            }

            if (v403 != v400) {
              goto LABEL_495;
            }
          }
        }
      }

      else
      {
LABEL_495:
        kunint64_t k = 0LL;
      }

      id v404 = v569;
      if ((unint64_t)v569 >= v570)
      {
        id v406 = v568;
        id v407 = v569 - v568;
        v408 = v407 + 1;
        id v409 = *jj;
        v410 = v570 - (void)v568;
        else {
          id v411 = v408;
        }
        if (v411) {
          id v411 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<std::pair<unsigned int,unsigned int>>>(v411);
        }
        else {
          int v412 = 0LL;
        }
        v413 = (unint64_t *)(v411 + 8 * v407);
        NSMutableDictionary *v413 = *(void *)(v409 + 3);
        v405 = (unint64_t)(v413 + 1);
        while (v404 != v406)
        {
          id v414 = *--v404;
          *--v413 = v414;
        }

        v568 = v413;
        v570 = v411 + 8 * v412;
        if (v406) {
          operator delete(v406);
        }
        v397 = v409;
      }

      else
      {
        void *v569 = *(void *)(v397 + 3);
        v405 = (unint64_t)(v404 + 1);
      }

      v569 = (unint64_t *)v405;
      if ((*(_BYTE *)v397 & 1) != 0)
      {
        if (kk)
        {
          v415 = *((_DWORD *)kk + 6) - 1;
          *((_DWORD *)kk + 6) = v415;
          if (!v415)
          {
            v416 = v397;
            objc_msgSend(v524, "appendBytes:length:");
            [v532 appendBytes:jj[1] length:24];
            v417 = (unint64_t)v574[1];
            id v418 = (unint64_t)kk[1];
            v419 = (uint8x8_t)vcnt_s8((int8x8_t)v574[1]);
            v419.i16[0] = vaddlv_u8(v419);
            if (v419.u32[0] > 1uLL)
            {
            }

            else
            {
              v418 &= (unint64_t)v574[1] - 1;
            }

            v423 = (void **)*((void *)v574[0] + v418);
            do
            {
              v424 = v423;
              v423 = (void **)*v423;
            }

            while (v423 != kk);
            if (v424 == &v574[2]) {
              goto LABEL_562;
            }
            uint64_t v425 = (unint64_t)v424[1];
            if (v419.u32[0] > 1uLL)
            {
            }

            else
            {
              v425 &= (unint64_t)v574[1] - 1;
            }

            if (v425 != v418)
            {
LABEL_562:
              if (!*kk) {
                goto LABEL_563;
              }
              v435 = *((void *)*kk + 1);
              if (v419.u32[0] > 1uLL)
              {
              }

              else
              {
                v435 &= (unint64_t)v574[1] - 1;
              }

              if (v435 != v418) {
LABEL_563:
              }
                *((void *)v574[0] + v41_Block_object_dispose(&STACK[0x3B0], 8) = 0LL;
            }

            unint64_t v436 = (unint64_t *)*kk;
            if (*kk)
            {
              uint64_t v437 = v436[1];
              if (v419.u32[0] > 1uLL)
              {
                if (v437 >= v417) {
                  v437 %= v417;
                }
              }

              else
              {
                v437 &= v417 - 1;
              }

              if (v437 != v418)
              {
                *((void *)v574[0] + v437) = v424;
                unint64_t v436 = (unint64_t *)*kk;
              }
            }

            *v424 = v436;
            --v574[3];
            operator delete(kk);
            if (*(void *)jj[1] <= 0xFFFFFFFEuLL)
            {
              uint64_t v438 = (__int128 *)std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::find<unsigned long long>( &v571,  v398);
              if (v438)
              {
                v439 = v571.u64[1];
                v440 = *((void *)v438 + 1);
                id v441 = (uint8x8_t)vcnt_s8((int8x8_t)v571.u64[1]);
                v441.i16[0] = vaddlv_u8(v441);
                if (v441.u32[0] > 1uLL)
                {
                  if (v440 >= v571.i64[1]) {
                    v440 %= v571.i64[1];
                  }
                }

                else
                {
                  v440 &= v571.i64[1] - 1;
                }

                id v447 = *(__int128 **)(v571.i64[0] + 8 * v440);
                do
                {
                  v448 = v447;
                  id v447 = *(__int128 **)v447;
                }

                while (v447 != v438);
                if (v448 == &v572) {
                  goto LABEL_618;
                }
                id v449 = *((void *)v448 + 1);
                if (v441.u32[0] > 1uLL)
                {
                  if (v449 >= v571.i64[1]) {
                    v449 %= v571.i64[1];
                  }
                }

                else
                {
                  v449 &= v571.i64[1] - 1;
                }

                if (v449 != v440)
                {
LABEL_618:
                  if (!*(void *)v438) {
                    goto LABEL_619;
                  }
                  v459 = *(void *)(*(void *)v438 + 8LL);
                  if (v441.u32[0] > 1uLL)
                  {
                    if (v459 >= v571.i64[1]) {
                      v459 %= v571.i64[1];
                    }
                  }

                  else
                  {
                    v459 &= v571.i64[1] - 1;
                  }

                  if (v459 != v440) {
LABEL_619:
                  }
                    *(void *)(v571.i64[0] + 8 * v440) = 0LL;
                }

                v460 = *(void *)v438;
                if (*(void *)v438)
                {
                  v461 = *(void *)(v460 + 8);
                  if (v441.u32[0] > 1uLL)
                  {
                    if (v461 >= v439) {
                      v461 %= v439;
                    }
                  }

                  else
                  {
                    v461 &= v439 - 1;
                  }

                  if (v461 != v440)
                  {
                    *(void *)(v571.i64[0] + 8 * v461) = v448;
                    v460 = *(void *)v438;
                  }
                }

                *(void *)v448 = v460;
                --*((void *)&v572 + 1);
                operator delete(v438);
              }

              if (!*((void *)&v572 + 1) && v565 != v566)
              {
                unsigned int v462 = *(void *)(v416 + 3);
                if (*((void *)v566 - 2) <= v462) {
                  *((void *)v566 - 1) = v462;
                }
              }
            }
          }
        }
      }

      else
      {
        if (!kk)
        {
          v420 = v397;
          objc_msgSend(v524, "appendBytes:length:");
          [v532 appendBytes:jj[1] length:24];
          v421 = (unint64_t)v574[1];
          if (v574[1])
          {
            v422 = (uint8x8_t)vcnt_s8((int8x8_t)v574[1]);
            v422.i16[0] = vaddlv_u8(v422);
            if (v422.u32[0] > 1uLL)
            {
              v405 = v398;
            }

            else
            {
              v405 = ((unint64_t)v574[1] - 1) & v398;
            }

            v426 = (void *)*((void *)v574[0] + v405);
            if (v426)
            {
              for (muint64_t m = (void *)*v426; mm; muint64_t m = (void *)*mm)
              {
                v428 = mm[1];
                if (v428 == v398)
                {
                  if (mm[2] == v398) {
                    goto LABEL_586;
                  }
                }

                else
                {
                  if (v422.u32[0] > 1uLL)
                  {
                  }

                  else
                  {
                    v428 &= (unint64_t)v574[1] - 1;
                  }

                  if (v428 != v405) {
                    break;
                  }
                }
              }
            }
          }

          uint64_t v429 = operator new(0x20uLL);
          *uint64_t v429 = 0LL;
          v429[1] = v398;
          v429[2] = v398;
          *((_DWORD *)v429 + 6) = 1;
          uint64_t v430 = (float)((unint64_t)v574[3] + 1);
          if (!v421 || (float)(*(float *)&v575 * (float)v421) < v430)
          {
            v431 = (v421 & (v421 - 1)) != 0;
            if (v421 < 3) {
              v431 = 1LL;
            }
            v432 = v431 | (2 * v421);
            unsigned int v433 = vcvtps_u32_f32(v430 / *(float *)&v575);
            if (v432 <= v433) {
              v434 = v433;
            }
            else {
              v434 = v432;
            }
            std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__rehash<true>( (uint64_t)v574,  v434);
            v421 = (unint64_t)v574[1];
            if (((unint64_t)v574[1] & ((unint64_t)v574[1] - 1)) != 0)
            {
              else {
                v405 = v398;
              }
            }

            else
            {
              v405 = ((unint64_t)v574[1] - 1) & v398;
            }
          }

          v442 = v574[0];
          id v443 = (void *)*((void *)v574[0] + v405);
          if (v443)
          {
            *uint64_t v429 = *v443;
            goto LABEL_584;
          }

          *uint64_t v429 = v574[2];
          v574[2] = v429;
          v442[v405] = &v574[2];
          if (*v429)
          {
            v444 = *(void *)(*v429 + 8LL);
            if ((v421 & (v421 - 1)) != 0)
            {
              if (v444 >= v421) {
                v444 %= v421;
              }
            }

            else
            {
              v444 &= v421 - 1;
            }

            id v443 = (char *)v574[0] + 8 * v444;
LABEL_584:
            *id v443 = v429;
          }

          ++v574[3];
LABEL_586:
          if (*(void *)jj[1] <= 0xFFFFFFFEuLL)
          {
            if (!*((void *)&v572 + 1))
            {
              id v445 = v566;
              if (v566 >= v567)
              {
                v450 = v565;
                id v451 = (v566 - v565) >> 4;
                v452 = v451 + 1;
                if ((unint64_t)(v451 + 1) >> 60) {
LABEL_724:
                }
                  abort();
                v453 = v567 - v565;
                if ((v567 - v565) >> 3 > v452) {
                  v452 = v453 >> 3;
                }
                else {
                  unsigned int v454 = v452;
                }
                id v455 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<std::pair<unsigned long long,unsigned long long>>>(v454);
                v457 = &v455[16 * v451];
                *(void *)v457 = *(void *)(v420 + 3);
                *((void *)v457 + 1) = *(void *)(v420 + 3);
                v458 = v457;
                if (v445 != v450)
                {
                  do
                  {
                    *((_OWORD *)v458 - 1) = *((_OWORD *)v445 - 1);
                    v458 -= 16;
                    v445 -= 16;
                  }

                  while (v445 != v450);
                  id v445 = v450;
                }

                v446 = v457 + 16;
                __int128 v565 = v458;
                uint64_t v567 = &v455[16 * v456];
                if (v445) {
                  operator delete(v445);
                }
              }

              else
              {
                *(void *)v566 = *(void *)(v420 + 3);
                *((void *)v445 + 1) = *(void *)(v420 + 3);
                v446 = v445 + 16;
              }

              v566 = v446;
            }

            std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__emplace_unique_key_args<unsigned long long,unsigned long long &>( (uint64_t)&v571,  v398,  v398);
          }

          continue;
        }

        ++*((_DWORD *)kk + 6);
      }
    }
  }

  id v464 = v565;
  id v463 = v566;
  v465 = v566 - v565;
  v466 = (v566 - v565) >> 4;
  __int128 v539 = (id)objc_claimAutoreleasedReturnValue(+[NSMutableArray arrayWithCapacity:](&OBJC_CLASS___NSMutableArray, "arrayWithCapacity:"));
  id obja = v464;
  if (v464 == v463) {
    id v467 = 0LL;
  }
  else {
    id v467 = *((void *)v464 + 1);
  }
  if (v465 >= 0x11)
  {
    v468 = v464 + 16;
    v469 = 1LL;
    do
    {
      if (v467 + 6000 < *v468)
      {
        v470 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  v467));
        v616[0] = v470;
        if (*v468 - 6000LL <= v467 + 6000) {
          v471 = v467 + 6000;
        }
        else {
          v471 = *v468 - 6000LL;
        }
        v472 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  v471));
        v616[1] = v472;
        id v473 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", v616, 2LL));
        [v539 addObject:v473];
      }

      if (v467 <= v468[1]) {
        id v467 = v468[1];
      }
      ++v469;
      v468 += 2;
    }

    while (v469 < v466);
  }

  objc_storeStrong((id *)(*((void *)this + 61) + 328LL), v539);
  id v474 = (void ***)v568;
  uint64_t v542 = (void ***)v569;
  std::__sort<std::__less<unsigned long long,unsigned long long> &,unsigned long long *>(v568);
  if (v553)
  {
    char v475 = std::__allocate_at_least[abi:nn180100]<std::allocator<std::pair<unsigned int,unsigned int>>>(v553);
    bzero(v475, v517);
  }

  else
  {
    char v475 = 0LL;
  }

  v521 = v474;
  if (v474 != v542)
  {
    char v476 = 0LL;
    id v477 = 0LL;
    else {
      id v478 = (v526 - v560) >> 3;
    }
    id v479 = (char *)v586;
    v480 = v580;
    id v481 = v577;
    int v482 = (char *)v583;
    id v483 = v521;
    do
    {
      v549 = v483;
      v602 = *v483;
      [v527 appendBytes:&v602 length:8];
      if (v526 != v560)
      {
        id v484 = 0LL;
        uint64_t v485 = v602;
        do
        {
          v486 = &v550[24 * v484];
          v487 = *(void *)&v560[8 * v484];
          uint64_t v488 = *((void *)v486 + 2);
          if (v487 < v488)
          {
            while (*(void *)(*(void *)v486 + 8 * v487) <= (unint64_t)v485)
            {
              if (v488 == ++v487)
              {
                v487 = *((void *)v486 + 2);
                break;
              }
            }
          }

          if (v487 <= 1) {
            v487 = 1LL;
          }
          v489 = (double)v487 + -1.0;
          *(void *)&v560[8 * v484] = v487 - 1;
          if (v487 < *((void *)v486 + 2))
          {
            BOOL v490 = *(void *)v486;
            id v491 = *(void *)(v490 + 8 * (v487 - 1));
          }

          *((double *)v475 + v484++) = v489;
        }

        while (v484 != v478);
      }

      if (v553)
      {
        v492 = 0LL;
        v493 = *((unsigned int *)this + 130);
        do
        {
          __int128 v494 = *(unsigned int *)&v560[8 * v492];
          id v495 = &v479[32 * v492];
          v496 = *((void *)v495 + 2);
          *(void *)(v480[3 * v492] + 8 * v477) = *((void *)v475 + v492);
          if ((_DWORD)v493)
          {
            v497 = 0LL;
            else {
              v498 = (v494 + 1);
            }
            unsigned int v499 = (double)v494;
            v500 = *(void *)v495;
            v501 = *((void *)v495 + 3);
            v502 = *(void *)v495 + 8 * v501 * v498;
            v503 = v500 + 8 * v501 * v494;
            v504 = &v576[0][v476 * (uint64_t)v576[3]];
            v505 = v481[4 * v492] + v476 * v481[4 * v492 + 3];
            do
            {
              v506 = *((double *)v475 + v492) - v499;
              if (v506 < 0.0) {
                v506 = 0.0;
              }
              v507 = (1.0 - v506) * *(double *)(v503 + 8 * v497) + v506 * *(double *)(v502 + 8 * v497);
              *(double *)(v505 + 8 * v497) = v507;
              if (((*(void *)&v482[(v497 >> 3) & 0x1FFFFFFFFFFFFFF8LL] >> v497) & 1) != 0)
              {
                if (v508 > 100.0) {
                  v508 = 100.0;
                }
              }

              else
              {
                v508 = v507 + *(double *)&v504[8 * v497];
              }

              *(double *)&v504[8 * v497++] = v508;
            }

            while (v493 != v497);
          }

          ++v492;
        }

        while (v492 != v553);
      }

      ++v477;
      id v483 = v549 + 1;
      v476 += 8LL;
    }

    while (v549 + 1 != v542);
  }

  *(void *)&v590 = @"frame index";
  v509 = (void **)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedInt:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedInt:",  *(unsigned int *)(*((void *)this + 61) + 360LL)));
  v602 = v509;
  v603.i64[0] = (uint64_t)v527;
  *((void *)&v590 + 1) = @"sampled timestamps";
  *(void *)&v591 = @"aggregated timeline data";
  v603.i64[1] = (uint64_t)v524;
  v604 = v532;
  *((void *)&v591 + 1) = @"aggregated timeline data ex";
  *(void *)&v592 = @"aggregated derived counters";
  v605 = (__int128 *)v522;
  *(void *)&v606 = v536;
  *((void *)&v592 + 1) = @"ring buffer sampled counter data";
  __p[0] = @"ring buffer blend factors";
  *((void *)&v606 + 1) = v534;
  v607 = (__int128 *)contexta;
  __p[1] = @"core counts";
  v594 = @"Frame Consistent Perf Info";
  v510 = *((void *)this + 61);
  v511 = (GRCPerFrameData *)&off_5A0420;
  uint64_t v513 = *(GRCPerFrameData **)(v510 + 320);
  v512 = *(void **)(v510 + 328);
  if (v513) {
    v511 = v513;
  }
  v595 = @"Restore Timestamps";
  if (!v512) {
    v512 = &__NSArray0__struct;
  }
  v608 = v511;
  v609 = v512;
  v514 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v602,  &v590,  10LL));

  uint64_t v515 = (id)(*(uint64_t (**)(void))(*((void *)this + 63) + 16LL))();
  if (v475) {
    operator delete(v475);
  }

  if (obja) {
    operator delete(obja);
  }
  if (v521) {
    operator delete(v521);
  }

  std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long>>>::~__hash_table((uint64_t)&v571);
  std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long>>>::~__hash_table((uint64_t)v574);
  if (v345) {
    operator delete(v345);
  }
  if (v545) {
    operator delete(v545);
  }
  if (v557) {
    operator delete(v557);
  }

  if (v577) {
    operator delete(v577);
  }

  if (v580) {
    operator delete(v580);
  }

  if (v583) {
    operator delete(v583);
  }
  if (v560) {
    operator delete(v560);
  }
  if (v586) {
    operator delete(v586);
  }
  if (v550) {
    operator delete(v550);
  }
}

  std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long>>>::~__hash_table((uint64_t)&v265);
  std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long>>>::~__hash_table((uint64_t)__x);
  llvm::Expected<std::vector<llvm::iterator_range<llvm::agxclauseanalyzer::AnalyzerInput::InstIteratorImpl<llvm::agxclauseanalyzer::AnalyzerInput const>>>>::~Expected((uint64_t)&v272);
  *(void *)__x = v269;
  std::vector<llvm::Error>::__destroy_vector::operator()[abi:nn180100]((void ***)__x);
  int v121 = *((void *)v3 + 32) + 1LL;
  __x[0] = -1;
  std::vector<unsigned int>::resize(v246, v121, __x);
  unint64_t v122 = operator new(0x80uLL);
  *(void *)&uint64_t v266 = v122 + 8;
  v122[2] = 0u;
  v122[3] = 0u;
  v122[4] = 0u;
  void v122[5] = 0u;
  v122[6] = 0u;
  v122[7] = 0u;
  *unint64_t v122 = 0u;
  v122[1] = 0u;
  *((_DWORD *)v122 + _Block_object_dispose(&STACK[0x3B0], 8) = 1065353216;
  *(_OWORD *)((char *)v122 + 40) = 0u;
  *(_OWORD *)((char *)v122 + 56) = 0u;
  *((_DWORD *)v122 + 1_Block_object_dispose(&STACK[0x3B0], 8) = 1065353216;
  *((void *)v122 + 10) = -1LL;
  *(_OWORD *)((char *)v122 + 8_Block_object_dispose(&STACK[0x3B0], 8) = 0u;
  *(_OWORD *)((char *)v122 + 104) = 0u;
  *((_DWORD *)v122 + 30) = 1065353216;
  *(void *)&v265 = v122;
  *((void *)&v265 + 1) = v122 + 8;
  unsigned int v123 = (_OWORD *)*((void *)v3 + 25);
  unsigned int v124 = (_OWORD *)*((void *)v3 + 26);
  if (v124 == v123)
  {
    if (*((void *)v3 + 27) == (void)v124)
    {
      uint64_t v277 = (uint64_t)(v3 + 216);
      unsigned int v127 = std::__allocate_at_least[abi:nn180100]<std::allocator<GTMMappedBufferBlock>>(1uLL);
      *(void *)__x = v127;
      *(void *)&__x[2] = v127;
      *(void *)&__x[6] = &v127[2 * v128];
      *unsigned int v127 = 0u;
      v127[1] = 0u;
      *(void *)&__x[4] = v127 + 2;
      std::vector<ALUTargetBlockInfo>::__swap_out_circular_buffer(v245, __x);
      std::__split_buffer<ALUTargetBlockInfo>::~__split_buffer((uint64_t)__x);
    }

    else
    {
      *unsigned int v124 = 0uLL;
      v124[1] = 0uLL;
      *((void *)v3 + 26) = v124 + 2;
    }
  }

  else if ((unint64_t)((char *)v124 - (char *)v123) >= 0x21)
  {
    id v125 = v123 + 2;
    while (v124 != v125)
    {
      unint64_t v126 = (void *)*((void *)v124 - 3);
      if (v126)
      {
        *((void *)v124 - 2) = v126;
        operator delete(v126);
      }

      v124 -= 2;
    }

    *((void *)v3 + 26) = v125;
  }

  uint64_t v129 = v266;
  id v130 = v265;
  if (!(((void)v266 - (void)v265) >> 17))
  {
    uint64_t v131 = *((void *)&v265 + 1);
    uint64_t v277 = (uint64_t)&v266;
    uint64_t v132 = (char *)operator new(0x20000uLL);
    uint64_t v133 = &v132[v131 - v130];
    *(void *)__x = v132;
    *(void *)&__x[2] = v133;
    uint64_t v134 = v132 + 0x20000;
    *(void *)&__x[4] = v133;
    *(void *)&__x[6] = v132 + 0x20000;
    if (v131 == v130)
    {
      __int128 v136 = vdupq_n_s64(v130);
      __int128 v135 = (uint64_t)&v132[v131 - v130];
    }

    else
    {
      __int128 v135 = (uint64_t)&v132[v131 - v130];
      do
      {
        v135 -= 128LL;
        v131 -= 128LL;
        std::allocator<TargetBlock>::construct[abi:nn180100]<TargetBlock,TargetBlock>(v135, v131);
      }

      while (v131 != v130);
      __int128 v136 = (int64x2_t)v265;
      uint64_t v129 = v266;
      uint64_t v134 = *(char **)&__x[6];
      uint64_t v133 = *(char **)&__x[4];
    }

    *(void *)&v265 = v135;
    *((void *)&v265 + 1) = v133;
    *(int64x2_t *)&__x[2] = v136;
    *(void *)&uint64_t v266 = v134;
    *(void *)&__x[6] = v129;
    *(void *)__x = v136.i64[0];
    std::__split_buffer<TargetBlock>::~__split_buffer((uint64_t)__x);
  }

  v255 = v3 + 216;
  size_t v137 = *((void *)v3 + 25);
  if (!((unint64_t)(*((void *)v3 + 27) - v137) >> 15))
  {
    uint64_t v138 = *((void *)v3 + 26) - v137;
    uint64_t v277 = (uint64_t)(v3 + 216);
    *(void *)__x = operator new(0x8000uLL);
    *(void *)&__x[2] = *(void *)__x + v138;
    *(void *)&__x[4] = *(void *)__x + v138;
    *(void *)&__x[6] = *(void *)__x + 0x8000LL;
    std::vector<ALUTargetBlockInfo>::__swap_out_circular_buffer(v245, __x);
    std::__split_buffer<ALUTargetBlockInfo>::~__split_buffer((uint64_t)__x);
  }

  uint64_t v139 = *(void *)(*((void *)v3 + 6) + 120LL);
  id v140 = *(void *)(v139 + 16);
  uint64_t v272 = v139;
  v273 = 0LL;
  unint64_t v141 = 0;
  if (v140)
  {
    unsigned int v142 = 0LL;
    uint64_t v258 = v3 + 176;
    unint64_t v143 = v139;
    v262 = v139;
    while (1)
    {
      (*(void (**)(std::vector<unsigned int>::value_type *__return_ptr))(*(void *)v143 + 24LL))(__x);
      unint64_t v144 = *(void *)__x;
      if ((__x[2] & 1) != 0)
      {
        if (*(void *)__x) {
          (*(void (**)(void))(**(void **)__x + 8LL))(*(void *)__x);
        }
        goto LABEL_296;
      }

      unsigned int v145 = **(void **)__x;
      if (!*((void *)&v263[0] + 1)) {
        goto LABEL_180;
      }
      unint64_t v146 = (uint8x8_t)vcnt_s8(*(int8x8_t *)((char *)v263 + 8));
      v146.i16[0] = vaddlv_u8(v146);
      if (v146.u32[0] > 1uLL)
      {
        uint64_t v147 = **(void **)__x;
        if (v145 >= *((void *)&v263[0] + 1)) {
          uint64_t v147 = v145 % *((void *)&v263[0] + 1);
        }
      }

      else
      {
        uint64_t v147 = (*((void *)&v263[0] + 1) - 1LL) & v145;
      }

      uint64_t v148 = *(void **)(*(void *)&v263[0] + 8 * v147);
      if (!v148) {
        goto LABEL_180;
      }
      v149 = (void *)*v148;
      if (!v149) {
        goto LABEL_180;
      }
      while (1)
      {
        id v150 = v149[1];
        if (v145 == v150) {
          break;
        }
        if (v146.u32[0] > 1uLL)
        {
          if (v150 >= *((void *)&v263[0] + 1)) {
            v150 %= *((void *)&v263[0] + 1);
          }
        }

        else
        {
          v150 &= *((void *)&v263[0] + 1) - 1LL;
        }

        if (v150 != v147) {
          goto LABEL_180;
        }
LABEL_179:
        v149 = (void *)*v149;
        if (!v149) {
          goto LABEL_180;
        }
      }

      if (v149[2] != v145) {
        goto LABEL_179;
      }
      if (*(_DWORD *)(*((void *)&v265 + 1) - 48LL) == -1) {
        goto LABEL_180;
      }
      *(_OWORD *)&v282[8] = 0u;
      *(_OWORD *)&v279[8] = 0u;
      uint64_t v277 = 1065353216LL;
      memset(__x, 0, sizeof(__x));
      __int128 v278 = 0u;
      *(_OWORD *)uint64_t v279 = 0u;
      *(_DWORD *)&v279[16] = 1065353216;
      uint64_t v280 = -1LL;
      __int128 v281 = 0u;
      *(_OWORD *)__int128 v282 = 0u;
      *(_DWORD *)&v282[16] = 1065353216;
      std::vector<TargetBlock>::push_back[abi:nn180100]((uint64_t *)&v265, (uint64_t)__x);
      std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long>>>::~__hash_table((uint64_t)&v281);
      std::__hash_table<std::__hash_value_type<unsigned int,std::vector<GTCoalescedEncoderIndexInfo>>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,std::vector<GTCoalescedEncoderIndexInfo>>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,std::vector<GTCoalescedEncoderIndexInfo>>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,std::vector<GTCoalescedEncoderIndexInfo>>>>::~__hash_table((uint64_t)&v278);
      std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long>>>::~__hash_table((uint64_t)__x);
      __int128 v215 = (char *)*((void *)v3 + 25);
      __int128 v216 = (char *)*((void *)v3 + 26);
      if (v215 != v216 && *((void *)v216 - 3) == *((void *)v216 - 2)) {
        goto LABEL_180;
      }
      if ((unint64_t)v216 < *v255)
      {
        __int128 v217 = v216 + 32;
        *(_OWORD *)__int128 v216 = 0u;
        *((_OWORD *)v216 + 1) = 0u;
        goto LABEL_323;
      }

      unint64_t v219 = (v216 - v215) >> 5;
      __int128 v220 = v219 + 1;
      __int128 v221 = *v255 - (void)v215;
      if (v221 >> 4 > v220) {
        __int128 v220 = v221 >> 4;
      }
      else {
        __int128 v222 = v220;
      }
      uint64_t v277 = (uint64_t)v255;
      __int128 v223 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<GTMMappedBufferBlock>>(v222);
      unint64_t v224 = &v223[32 * v219];
      *(void *)__x = v223;
      *(void *)&__x[2] = v224;
      *(void *)&__x[6] = &v223[32 * v225];
      *(_OWORD *)unint64_t v224 = 0u;
      *((_OWORD *)v224 + 1) = 0u;
      *(void *)&__x[4] = v224 + 32;
      std::vector<ALUTargetBlockInfo>::__swap_out_circular_buffer(v245, __x);
      __int128 v217 = (_OWORD *)*((void *)v3 + 26);
      std::__split_buffer<ALUTargetBlockInfo>::~__split_buffer((uint64_t)__x);
LABEL_323:
      *((void *)v3 + 26) = v217;
LABEL_180:
      unint64_t v151 = *((void *)&v265 + 1);
      uint64_t v152 = v3;
      uint64_t v153 = *((void *)v3 + 26);
      if (*(_DWORD *)(*((void *)&v265 + 1) - 48LL) == -1) {
        *(_DWORD *)(*((void *)&v265 + 1) - 48LL) = v141;
      }
      *(_DWORD *)(v151 - 44) = v141;
      char v154 = (*(uint64_t (**)(void, uint64_t))(**(void **)(*((void *)v152 + 6) + 88LL) + 56LL))( *(void *)(*((void *)v152 + 6) + 88LL),  v144);
      int v155 = (*(uint64_t (**)(void, uint64_t))(**(void **)(*((void *)v152 + 6) + 88LL) + 64LL))( *(void *)(*((void *)v152 + 6) + 88LL),  v144);
      id v156 = v155;
      if (v154 != 1 && (v154 != 2 || v155 != 1)) {
        goto LABEL_207;
      }
      unint64_t v158 = (*(uint64_t (**)(void, uint64_t))(**(void **)(*((void *)v259 + 6) + 136LL) + 16LL))( *(void *)(*((void *)v259 + 6) + 136LL),  v144 + 24);
      id v159 = (v158 & 0xFF00000000LL) != 0 ? v158 : 1;
      if (v156 == 24) {
        goto LABEL_207;
      }
      id v160 = (double)v159;
      char v162 = *(void *)(v153 - 16);
      id v161 = *(void *)(v153 - 8);
      if (v162 < v161)
      {
        *(_DWORD *)char v162 = v145;
        *(double *)(v162 + _Block_object_dispose(&STACK[0x3B0], 8) = v160;
        uint64_t v163 = (char *)(v162 + 16);
        goto LABEL_206;
      }

      id v164 = *(void *)(v153 - 24);
      uint64_t v165 = (uint64_t)(v162 - v164) >> 4;
      id v166 = v165 + 1;
      id v167 = v161 - v164;
      if (v167 >> 3 > v166) {
        id v166 = v167 >> 3;
      }
      else {
        id v168 = v166;
      }
      if (v168 >> 60) {
        goto LABEL_342;
      }
      id v169 = (char *)operator new(16 * v168);
      uint64_t v170 = (double *)&v169[16 * v165];
      *(_DWORD *)uint64_t v170 = v145;
      v170[1] = v160;
      id v172 = *(char **)(v153 - 24);
      uint64_t v171 = *(char **)(v153 - 16);
      unsigned int v173 = v170;
      if (v171 != v172)
      {
        do
        {
          *((_OWORD *)v173 - 1) = *((_OWORD *)v171 - 1);
          v173 -= 2;
          v171 -= 16;
        }

        while (v171 != v172);
        uint64_t v171 = *(char **)(v153 - 24);
      }

      uint64_t v174 = &v169[16 * v168];
      uint64_t v163 = (char *)(v170 + 2);
      *(void *)(v153 - 24) = v173;
      *(void *)(v153 - 16) = v170 + 2;
      *(void *)(v153 - _Block_object_dispose(&STACK[0x3B0], 8) = v174;
      if (v171) {
        operator delete(v171);
      }
LABEL_206:
      *(void *)(v153 - 16) = v163;
      *(_DWORD *)(v153 - 32) += v159;
LABEL_207:
      if (!(*(unsigned int (**)(void, uint64_t))(**(void **)(*((void *)v259 + 6) + 88LL) + 72LL))( *(void *)(*((void *)v259 + 6) + 88LL),  v144)) {
        goto LABEL_220;
      }
      *(_OWORD *)&v282[8] = 0u;
      *(_OWORD *)&v279[8] = 0u;
      uint64_t v277 = 1065353216LL;
      memset(__x, 0, sizeof(__x));
      __int128 v278 = 0u;
      *(_OWORD *)uint64_t v279 = 0u;
      *(_DWORD *)&v279[16] = 1065353216;
      uint64_t v280 = -1LL;
      __int128 v281 = 0u;
      *(_OWORD *)__int128 v282 = 0u;
      *(_DWORD *)&v282[16] = 1065353216;
      std::vector<TargetBlock>::push_back[abi:nn180100]((uint64_t *)&v265, (uint64_t)__x);
      std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long>>>::~__hash_table((uint64_t)&v281);
      std::__hash_table<std::__hash_value_type<unsigned int,std::vector<GTCoalescedEncoderIndexInfo>>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,std::vector<GTCoalescedEncoderIndexInfo>>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,std::vector<GTCoalescedEncoderIndexInfo>>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,std::vector<GTCoalescedEncoderIndexInfo>>>>::~__hash_table((uint64_t)&v278);
      std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long>>>::~__hash_table((uint64_t)__x);
      uint64_t v175 = (char *)*((void *)v259 + 25);
      uint64_t v176 = (char *)*((void *)v259 + 26);
      if (v175 != v176 && *((void *)v176 - 3) == *((void *)v176 - 2)) {
        goto LABEL_220;
      }
      if ((unint64_t)v176 < *v255)
      {
        char v177 = v176 + 32;
        *(_OWORD *)uint64_t v176 = 0u;
        *((_OWORD *)v176 + 1) = 0u;
        goto LABEL_219;
      }

      uint64_t v178 = (v176 - v175) >> 5;
      unsigned int v179 = v178 + 1;
      id v180 = *v255 - (void)v175;
      if (v180 >> 4 > v179) {
        unsigned int v179 = v180 >> 4;
      }
      else {
        uint64_t v181 = v179;
      }
      uint64_t v277 = (uint64_t)v255;
      id v182 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<GTMMappedBufferBlock>>(v181);
      id v183 = &v182[32 * v178];
      *(void *)__x = v182;
      *(void *)&__x[2] = v183;
      *(void *)&__x[6] = &v182[32 * v184];
      *(_OWORD *)id v183 = 0u;
      *((_OWORD *)v183 + 1) = 0u;
      *(void *)&__x[4] = v183 + 32;
      std::vector<ALUTargetBlockInfo>::__swap_out_circular_buffer(v245, __x);
      char v177 = (_OWORD *)*((void *)v259 + 26);
      std::__split_buffer<ALUTargetBlockInfo>::~__split_buffer((uint64_t)__x);
LABEL_219:
      *((void *)v259 + 26) = v177;
LABEL_220:
      uint64_t v185 = v140;
      v186 = *(void *)(v144 + 16);
      v187 = *((void *)v259 + 21);
      if (v187)
      {
        id v188 = (uint8x8_t)vcnt_s8((int8x8_t)v187);
        v188.i16[0] = vaddlv_u8(v188);
        if (v188.u32[0] > 1uLL)
        {
          id v140 = v141;
          if (v187 <= v141) {
            id v140 = v141 % v187;
          }
        }

        else
        {
          id v140 = ((_DWORD)v187 - 1) & v141;
        }

        id v189 = *(void ***)(*((void *)v259 + 20) + 8 * v140);
        if (v189)
        {
          id v190 = *v189;
          if (*v189)
          {
            do
            {
              id v191 = v190[1];
              if (v191 == v141)
              {
                if (*((_DWORD *)v190 + 4) == v141)
                {
                  id v140 = v185;
                  id v3 = (char *)v259;
                  uint64_t v139 = v262;
                  goto LABEL_293;
                }
              }

              else
              {
                if (v188.u32[0] > 1uLL)
                {
                  if (v191 >= v187) {
                    v191 %= v187;
                  }
                }

                else
                {
                  v191 &= v187 - 1;
                }

                if (v191 != v140) {
                  break;
                }
              }

              id v190 = (void *)*v190;
            }

            while (v190);
          }
        }
      }

      id v190 = operator new(0x28uLL);
      void *v190 = 0LL;
      v190[1] = v141;
      *((_DWORD *)v190 + 4) = v141;
      v190[3] = 0LL;
      *((_DWORD *)v190 + _Block_object_dispose(&STACK[0x3B0], 8) = 0;
      id v192 = (float)(unint64_t)(*((void *)v259 + 23) + 1LL);
      id v193 = v259[48];
      if (!v187 || (float)(v193 * (float)v187) < v192)
      {
        id v194 = (v187 & (v187 - 1)) != 0;
        if (v187 < 3) {
          id v194 = 1LL;
        }
        unint64_t v195 = v194 | (2 * v187);
        id v196 = vcvtps_u32_f32(v192 / v193);
        if (v195 <= v196) {
          int8x8_t prime = (int8x8_t)v196;
        }
        else {
          int8x8_t prime = (int8x8_t)v195;
        }
        if (*(void *)&prime == 1LL)
        {
          int8x8_t prime = (int8x8_t)2LL;
        }

        else if ((*(void *)&prime & (*(void *)&prime - 1LL)) != 0)
        {
          int8x8_t prime = (int8x8_t)std::__next_prime(*(void *)&prime);
          v187 = *((void *)v259 + 21);
        }

        if (*(void *)&prime > v187)
        {
          uint64_t v198 = (int8x8_t *)v259;
          goto LABEL_249;
        }

        if (*(void *)&prime < v187)
        {
          BOOL v205 = vcvtps_u32_f32((float)*((unint64_t *)v259 + 23) / v259[48]);
          if (v187 < 3
            || (unint64_t v206 = (uint8x8_t)vcnt_s8((int8x8_t)v187), v206.i16[0] = vaddlv_u8(v206), v206.u32[0] > 1uLL))
          {
            BOOL v205 = std::__next_prime(v205);
          }

          else
          {
            uint64_t v207 = 1LL << -(char)__clz(v205 - 1);
            if (v205 >= 2) {
              BOOL v205 = v207;
            }
          }

          if (*(void *)&prime <= v205) {
            int8x8_t prime = (int8x8_t)v205;
          }
          if (*(void *)&prime >= v187)
          {
            v187 = *((void *)v259 + 21);
            goto LABEL_278;
          }

          uint64_t v198 = (int8x8_t *)v259;
          if (!*(void *)&prime)
          {
            __int128 v218 = (void *)*((void *)v259 + 20);
            *((void *)v259 + 20) = 0LL;
            if (v218) {
              operator delete(v218);
            }
            v187 = 0LL;
            *((void *)v259 + 21) = 0LL;
            goto LABEL_278;
          }

void sub_80E1C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, id a35)
{
}

uint64_t __Block_byref_object_copy__238(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0LL;
  return result;
}

void __Block_byref_object_dispose__239(uint64_t a1)
{
}

void __destructor_8_S_S_s8_s16_S_s24_s32_s40_s48_s56_s64_S_s96_s104_s112_s120_S_s128_s136_S_s152_S_s168_s176_s184_s192_s200( id *a1)
{
}

void __destructor_8_s0_s8_s16_s24_s32_s40(id *a1)
{
}

apr_array_header_t *LoadUniqueIdentifierResourceGroup(int **a1, unsigned int a2, apr_pool_t *p)
{
  int v5 = **a1;
  *a1 += 2;
  uint64_t v6 = apr_array_make(p, v5, 32);
  if (v5 >= 1)
  {
    do
    {
      unsigned int v7 = apr_array_push(v6);
      uint64_t v8 = *a1;
      uint64_t v9 = *(void *)*a1;
      *a1 += 2;
      v7[1] = v9;
      uint64_t v10 = *((void *)v8 + 1);
      *a1 = v8 + 4;
      *unsigned int v7 = v10;
      if (a2 >= 0x41)
      {
        uint64_t v11 = *((void *)v8 + 2);
        *a1 = v8 + 6;
        v7[2] = v11;
      }

      --v5;
    }

    while (v5);
  }

  return v6;
}

id MakeMTLRenderPassAttachmentDescriptor(void *a1, uint64_t a2, void *a3)
{
  id v5 = a1;
  uint64_t v6 = *(void *)(a2 + 8);
  id v7 = a3;
  uint64_t v8 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLongLong:](&OBJC_CLASS___NSNumber, "numberWithUnsignedLongLong:", v6));
  uint64_t v9 = (void *)objc_claimAutoreleasedReturnValue([v7 objectForKeyedSubscript:v8]);
  [v5 setTexture:v9];

  [v5 setLevel:*(unsigned __int8 *)(a2 + 24)];
  [v5 setSlice:*(unsigned __int16 *)(a2 + 22)];
  [v5 setDepthPlane:*(unsigned __int16 *)(a2 + 16)];
  uint64_t v10 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  *(void *)a2));
  uint64_t v11 = (void *)objc_claimAutoreleasedReturnValue([v7 objectForKeyedSubscript:v10]);

  [v5 setResolveTexture:v11];
  [v5 setResolveLevel:*(unsigned __int8 *)(a2 + 26)];
  [v5 setResolveSlice:*(unsigned __int16 *)(a2 + 20)];
  [v5 setResolveDepthPlane:*(unsigned __int16 *)(a2 + 18)];
  [v5 setLoadAction:*(unsigned __int8 *)(a2 + 25)];
  [v5 setStoreAction:*(unsigned __int8 *)(a2 + 27)];
  [v5 setStoreActionOptions:*(unsigned __int8 *)(a2 + 28)];
  if ((objc_opt_respondsToSelector(v5, "yInvert") & 1) != 0) {
    [v5 setYInvert:*(_BYTE *)(a2 + 29) != 0];
  }
  return v5;
}

MTLTextureDescriptor *MakeMTLTextureDescriptorWithoutResourceIndex(uint64_t a1)
{
  io_connect_t v2 = objc_alloc_init(&OBJC_CLASS___MTLTextureDescriptor);
  -[MTLTextureDescriptor setTextureType:](v2, "setTextureType:", *(unsigned __int8 *)(a1 + 49));
  -[MTLTextureDescriptor setPixelFormat:](v2, "setPixelFormat:", *(unsigned __int16 *)(a1 + 34));
  -[MTLTextureDescriptor setWidth:](v2, "setWidth:", *(unsigned int *)(a1 + 24));
  -[MTLTextureDescriptor setHeight:](v2, "setHeight:", *(unsigned __int16 *)(a1 + 32));
  -[MTLTextureDescriptor setDepth:](v2, "setDepth:", *(unsigned __int16 *)(a1 + 30));
  -[MTLTextureDescriptor setMipmapLevelCount:](v2, "setMipmapLevelCount:", *(unsigned __int8 *)(a1 + 45));
  -[MTLTextureDescriptor setSampleCount:](v2, "setSampleCount:", *(unsigned __int8 *)(a1 + 47));
  -[MTLTextureDescriptor setArrayLength:](v2, "setArrayLength:", *(unsigned __int16 *)(a1 + 28));
  -[MTLTextureDescriptor setFramebufferOnly:](v2, "setFramebufferOnly:", *(_BYTE *)(a1 + 43) != 0);
  -[MTLTextureDescriptor setIsDrawable:](v2, "setIsDrawable:", *(_BYTE *)(a1 + 44) != 0);
  -[MTLTextureDescriptor setUsage:](v2, "setUsage:", *(unsigned int *)(a1 + 20));
  if ((objc_opt_respondsToSelector(v2, "rotation") & 1) != 0) {
    -[MTLTextureDescriptor setRotation:](v2, "setRotation:", *(unsigned __int8 *)(a1 + 46));
  }
  -[MTLTextureDescriptor setResourceOptions:](v2, "setResourceOptions:", *(unsigned __int16 *)(a1 + 36));
  -[MTLTextureDescriptor setAllowGPUOptimizedContents:](v2, "setAllowGPUOptimizedContents:", *(_BYTE *)(a1 + 38) != 0);
  if ((objc_opt_respondsToSelector(v2, "swizzleKey") & 1) != 0) {
    -[MTLTextureDescriptor setSwizzleKey:](v2, "setSwizzleKey:", *(unsigned int *)(a1 + 16));
  }
  if ((objc_opt_respondsToSelector(v2, "sparseSurfaceDefaultValue") & 1) != 0) {
    -[MTLTextureDescriptor setSparseSurfaceDefaultValue:]( v2,  "setSparseSurfaceDefaultValue:",  *(unsigned __int8 *)(a1 + 48));
  }
  -[MTLTextureDescriptor setWriteSwizzleEnabled:](v2, "setWriteSwizzleEnabled:", *(_BYTE *)(a1 + 50) != 0);
  if ((objc_opt_respondsToSelector(v2, "compressionType") & 1) != 0) {
    -[MTLTextureDescriptor setCompressionType:](v2, "setCompressionType:", *(unsigned __int8 *)(a1 + 41));
  }
  if ((objc_opt_respondsToSelector(v2, "compressionMode") & 1) != 0) {
    -[MTLTextureDescriptor setCompressionMode:](v2, "setCompressionMode:", *(unsigned __int8 *)(a1 + 40));
  }
  return v2;
}

id MakeMTLTextureDescriptorWithResourceIndex(uint64_t a1)
{
  MTLTextureDescriptorWithoutResourceIndex = MakeMTLTextureDescriptorWithoutResourceIndex(a1);
  id v3 = (void *)objc_claimAutoreleasedReturnValue(MTLTextureDescriptorWithoutResourceIndex);
  [v3 setForceResourceIndex:*(void *)(a1 + 8) != 0];
  [v3 setResourceIndex:*(void *)(a1 + 8)];
  return v3;
}

id MakeMTLBufferDescriptor(uint64_t a1)
{
  id v2 = objc_alloc_init(&OBJC_CLASS___MTLBufferDescriptor);
  [v2 setLength:*(void *)a1];
  [v2 setResourceOptions:*(unsigned __int16 *)(a1 + 32)];
  [v2 setNoCopy:*(_BYTE *)(a1 + 34) != 0];
  return v2;
}

id MakeMTLRenderPipelineColorAttachmentDescriptor(void *a1, unsigned __int16 *a2)
{
  id v3 = a1;
  [v3 setBlendingEnabled:*((_BYTE *)a2 + 3) != 0];
  [v3 setSourceRGBBlendFactor:*((unsigned __int8 *)a2 + 8)];
  [v3 setDestinationRGBBlendFactor:*((unsigned __int8 *)a2 + 5)];
  [v3 setRgbBlendOperation:*((unsigned __int8 *)a2 + 6)];
  [v3 setSourceAlphaBlendFactor:*((unsigned __int8 *)a2 + 7)];
  [v3 setDestinationAlphaBlendFactor:*((unsigned __int8 *)a2 + 4)];
  [v3 setAlphaBlendOperation:*((unsigned __int8 *)a2 + 2)];
  [v3 setWriteMask:*((unsigned __int8 *)a2 + 9)];
  [v3 setPixelFormat:*a2];
  return v3;
}

id CreateObjectArrayWithMap(uint64_t *a1, int a2, void *a3)
{
  id v5 = a3;
  uint64_t v6 = -[NSMutableArray initWithCapacity:](objc_alloc(&OBJC_CLASS___NSMutableArray), "initWithCapacity:", a2);
  if (a2 >= 1)
  {
    uint64_t v7 = a2;
    do
    {
      uint64_t v8 = *a1++;
      uint64_t v9 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLongLong:](&OBJC_CLASS___NSNumber, "numberWithUnsignedLongLong:", v8));
      uint64_t v10 = (void *)objc_claimAutoreleasedReturnValue([v5 objectForKeyedSubscript:v9]);

      if (v10) {
        -[NSMutableArray addObject:](v6, "addObject:", v10);
      }

      --v7;
    }

    while (v7);
  }

  id v11 = -[NSMutableArray copy](v6, "copy");

  return v11;
}

MTLRenderPipelineDescriptor *MakeMTLRenderPipelineDescriptorWithoutResourceIndex(uint64_t a1, void *a2)
{
  id v3 = a2;
  unsigned int v4 = objc_alloc_init(&OBJC_CLASS___MTLRenderPipelineDescriptor);
  id v5 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  *(void *)(a1 + 1296)));
  uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue([v3 objectForKeyedSubscript:v5]);
  -[MTLRenderPipelineDescriptor setVertexFunction:](v4, "setVertexFunction:", v6);

  uint64_t v7 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  *(void *)(a1 + 1176)));
  uint64_t v8 = (void *)objc_claimAutoreleasedReturnValue([v3 objectForKeyedSubscript:v7]);
  -[MTLRenderPipelineDescriptor setFragmentFunction:](v4, "setFragmentFunction:", v8);

  id v9 = (id)objc_claimAutoreleasedReturnValue(-[MTLRenderPipelineDescriptor vertexDescriptor](v4, "vertexDescriptor"));
  uint64_t v10 = 0LL;
  id v11 = (unsigned __int8 *)(a1 + 10);
  do
  {
    uint64_t v12 = (void *)objc_claimAutoreleasedReturnValue([v9 layouts]);
    id v13 = (id)objc_claimAutoreleasedReturnValue([v12 objectAtIndexedSubscript:v10]);
    [v13 setStride:*(void *)(v11 - 10)];
    [v13 setStepRate:*((unsigned __int16 *)v11 - 1)];
    unsigned int v14 = *v11;
    v11 += 16;
    [v13 setStepFunction:v14];

    ++v10;
  }

  while (v10 != 31);
  uint64_t v15 = 0LL;
  id v16 = (unsigned __int8 *)(a1 + 501);
  do
  {
    id v17 = (void *)objc_claimAutoreleasedReturnValue([v9 attributes]);
    id v18 = (id)objc_claimAutoreleasedReturnValue([v17 objectAtIndexedSubscript:v15]);
    [v18 setFormat:*v16];
    [v18 setOffset:*(unsigned int *)(v16 - 5)];
    [v18 setBufferIndex:*(v16 - 1)];

    ++v15;
    v16 += 8;
  }

  while (v15 != 31);

  -[MTLRenderPipelineDescriptor setRasterSampleCount:](v4, "setRasterSampleCount:", *(void *)(a1 + 1272));
  -[MTLRenderPipelineDescriptor setSampleMask:](v4, "setSampleMask:", *(void *)(a1 + 1288));
  LODWORD(v19) = *(_DWORD *)(a1 + 1332);
  -[MTLRenderPipelineDescriptor setSampleCoverage:](v4, "setSampleCoverage:", v19);
  -[MTLRenderPipelineDescriptor setAlphaToCoverageEnabled:]( v4,  "setAlphaToCoverageEnabled:",  *(_BYTE *)(a1 + 1480) != 0);
  -[MTLRenderPipelineDescriptor setAlphaToOneEnabled:](v4, "setAlphaToOneEnabled:", *(_BYTE *)(a1 + 1481) != 0);
  -[MTLRenderPipelineDescriptor setRasterizationEnabled:](v4, "setRasterizationEnabled:", *(_BYTE *)(a1 + 1493) != 0);
  -[MTLRenderPipelineDescriptor setDepthAttachmentPixelFormat:]( v4,  "setDepthAttachmentPixelFormat:",  *(unsigned __int16 *)(a1 + 1340));
  -[MTLRenderPipelineDescriptor setStencilAttachmentPixelFormat:]( v4,  "setStencilAttachmentPixelFormat:",  *(unsigned __int16 *)(a1 + 1352));
  uint64_t v20 = 0LL;
  id v21 = (unsigned __int16 *)(a1 + 744);
  do
  {
    uint64_t v22 = (void *)objc_claimAutoreleasedReturnValue(-[MTLRenderPipelineDescriptor colorAttachments](v4, "colorAttachments"));
    uint64_t v23 = (void *)objc_claimAutoreleasedReturnValue([v22 objectAtIndexedSubscript:v20]);

    ++v20;
    v21 += 8;
  }

  while (v20 != 8);
  if (*(void *)(a1 + 1200))
  {
    uint64_t v24 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:"));
    -[MTLRenderPipelineDescriptor setLabel:](v4, "setLabel:", v24);
  }

  -[MTLRenderPipelineDescriptor setInputPrimitiveTopology:]( v4,  "setInputPrimitiveTopology:",  *(unsigned __int8 *)(a1 + 1485));
  -[MTLRenderPipelineDescriptor setTessellationPartitionMode:]( v4,  "setTessellationPartitionMode:",  *(unsigned __int8 *)(a1 + 1505));
  -[MTLRenderPipelineDescriptor setMaxTessellationFactor:](v4, "setMaxTessellationFactor:", *(void *)(a1 + 1208));
  -[MTLRenderPipelineDescriptor setTessellationFactorScaleEnabled:]( v4,  "setTessellationFactorScaleEnabled:",  *(_BYTE *)(a1 + 1502) != 0);
  -[MTLRenderPipelineDescriptor setTessellationFactorFormat:]( v4,  "setTessellationFactorFormat:",  *(unsigned __int8 *)(a1 + 1501));
  -[MTLRenderPipelineDescriptor setTessellationControlPointIndexType:]( v4,  "setTessellationControlPointIndexType:",  *(unsigned __int8 *)(a1 + 1500));
  -[MTLRenderPipelineDescriptor setTessellationFactorStepFunction:]( v4,  "setTessellationFactorStepFunction:",  *(unsigned __int8 *)(a1 + 1503));
  -[MTLRenderPipelineDescriptor setTessellationOutputWindingOrder:]( v4,  "setTessellationOutputWindingOrder:",  *(unsigned __int8 *)(a1 + 1504));
  for (uint64_t i = 0LL; i != 31; ++i)
  {
    float32x2_t v26 = (void *)objc_claimAutoreleasedReturnValue(-[MTLRenderPipelineDescriptor vertexBuffers](v4, "vertexBuffers"));
    id v27 = (id)objc_claimAutoreleasedReturnValue([v26 objectAtIndexedSubscript:i]);
    [v27 setMutability:*(unsigned __int8 *)(a1 + 1447 + i)];
  }

  for (uint64_t j = 0LL; j != 31; ++j)
  {
    uint64_t v29 = (void *)objc_claimAutoreleasedReturnValue(-[MTLRenderPipelineDescriptor fragmentBuffers](v4, "fragmentBuffers"));
    id v30 = (id)objc_claimAutoreleasedReturnValue([v29 objectAtIndexedSubscript:j]);
    [v30 setMutability:*(unsigned __int8 *)(a1 + 1354 + j)];
  }

  -[MTLRenderPipelineDescriptor setSupportIndirectCommandBuffers:]( v4,  "setSupportIndirectCommandBuffers:",  *(_BYTE *)(a1 + 1499) != 0);
  if ((objc_opt_respondsToSelector(v4, "vertexAmplificationMode") & 1) != 0) {
    -[MTLRenderPipelineDescriptor setVertexAmplificationMode:]( v4,  "setVertexAmplificationMode:",  *(unsigned __int8 *)(a1 + 1507));
  }
  if ((objc_opt_respondsToSelector(v4, "maxVertexAmplificationCount") & 1) != 0) {
    -[MTLRenderPipelineDescriptor setMaxVertexAmplificationCount:]( v4,  "setMaxVertexAmplificationCount:",  *(unsigned int *)(a1 + 1328));
  }
  uint64_t v31 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  *(void *)(a1 + 1264)));
  uint64_t v32 = (void *)objc_claimAutoreleasedReturnValue([v3 objectForKeyedSubscript:v31]);
  -[MTLRenderPipelineDescriptor setPipelineLibrary:](v4, "setPipelineLibrary:", v32);

  if ((objc_opt_respondsToSelector(v4, "logicOperation") & 1) != 0) {
    -[MTLRenderPipelineDescriptor setLogicOperation:](v4, "setLogicOperation:", *(unsigned __int8 *)(a1 + 1486));
  }
  if ((objc_opt_respondsToSelector(v4, "alphaTestFunction") & 1) != 0) {
    -[MTLRenderPipelineDescriptor setAlphaTestFunction:](v4, "setAlphaTestFunction:", *(unsigned __int8 *)(a1 + 1479));
  }
  if ((objc_opt_respondsToSelector(v4, "vertexDepthCompareClampMask") & 1) != 0) {
    -[MTLRenderPipelineDescriptor setVertexDepthCompareClampMask:]( v4,  "setVertexDepthCompareClampMask:",  *(unsigned int *)(a1 + 1336));
  }
  if ((objc_opt_respondsToSelector(v4, "fragmentDepthCompareClampMask") & 1) != 0) {
    -[MTLRenderPipelineDescriptor setFragmentDepthCompareClampMask:]( v4,  "setFragmentDepthCompareClampMask:",  *(unsigned int *)(a1 + 1324));
  }
  if ((objc_opt_respondsToSelector(v4, "isLogicOperationEnabled") & 1) != 0) {
    -[MTLRenderPipelineDescriptor setLogicOperationEnabled:]( v4,  "setLogicOperationEnabled:",  *(_BYTE *)(a1 + 1487) != 0);
  }
  if ((objc_opt_respondsToSelector(v4, "openGLModeEnabled") & 1) != 0) {
    -[MTLRenderPipelineDescriptor setOpenGLModeEnabled:](v4, "setOpenGLModeEnabled:", *(_BYTE *)(a1 + 1489) != 0);
  }
  if ((objc_opt_respondsToSelector(v4, "isTwoSideEnabled") & 1) != 0) {
    -[MTLRenderPipelineDescriptor setTwoSideEnabled:](v4, "setTwoSideEnabled:", *(_BYTE *)(a1 + 1506) != 0);
  }
  if ((objc_opt_respondsToSelector(v4, "isAlphaTestEnabled") & 1) != 0) {
    -[MTLRenderPipelineDescriptor setAlphaTestEnabled:](v4, "setAlphaTestEnabled:", *(_BYTE *)(a1 + 1478) != 0);
  }
  if ((objc_opt_respondsToSelector(v4, "clipDistanceEnableMask") & 1) != 0) {
    -[MTLRenderPipelineDescriptor setClipDistanceEnableMask:]( v4,  "setClipDistanceEnableMask:",  *(unsigned __int8 *)(a1 + 1482));
  }
  if ((objc_opt_respondsToSelector(v4, "colorSampleCount") & 1) != 0) {
    -[MTLRenderPipelineDescriptor setColorSampleCount:](v4, "setColorSampleCount:", *(void *)(a1 + 1160));
  }
  if ((objc_opt_respondsToSelector(v4, "sampleCoverageInvert") & 1) != 0) {
    -[MTLRenderPipelineDescriptor setSampleCoverageInvert:](v4, "setSampleCoverageInvert:", *(_BYTE *)(a1 + 1494) != 0);
  }
  if ((objc_opt_respondsToSelector(v4, "needsCustomBorderColorSamplers") & 1) != 0) {
    -[MTLRenderPipelineDescriptor setNeedsCustomBorderColorSamplers:]( v4,  "setNeedsCustomBorderColorSamplers:",  *(_BYTE *)(a1 + 1488) != 0);
  }
  if ((objc_opt_respondsToSelector(v4, "isDepthStencilWriteDisabled") & 1) != 0) {
    -[MTLRenderPipelineDescriptor setDepthStencilWriteDisabled:]( v4,  "setDepthStencilWriteDisabled:",  *(_BYTE *)(a1 + 1483) != 0);
  }
  -[MTLRenderPipelineDescriptor setForceSoftwareVertexFetch:]( v4,  "setForceSoftwareVertexFetch:",  *(_BYTE *)(a1 + 1484) != 0);
  id Dictionary = GTData_MakeDictionary(*(void *)(a1 + 1144), *(void *)(a1 + 1152));
  uint64_t v34 = (void *)objc_claimAutoreleasedReturnValue(Dictionary);
  -[MTLRenderPipelineDescriptor setPluginData:](v4, "setPluginData:", v34);

  id v35 = GTData_MakeDictionary(*(void *)(a1 + 1128), *(void *)(a1 + 1136));
  uint64_t v36 = (void *)objc_claimAutoreleasedReturnValue(v35);
  -[MTLRenderPipelineDescriptor setDriverCompilerOptions:](v4, "setDriverCompilerOptions:", v36);

  uint64_t v37 = *(void *)(a1 + 1312);
  if (v37)
  {
    id ObjectArrayWithMap = CreateObjectArrayWithMap(*(uint64_t **)(a1 + 1304), v37, v3);
    id v39 = (void *)objc_claimAutoreleasedReturnValue(ObjectArrayWithMap);
    -[MTLRenderPipelineDescriptor setVertexPreloadedLibraries:](v4, "setVertexPreloadedLibraries:", v39);
  }

  uint64_t v40 = *(void *)(a1 + 1192);
  if (v40)
  {
    id v41 = CreateObjectArrayWithMap(*(uint64_t **)(a1 + 1184), v40, v3);
    id v42 = (void *)objc_claimAutoreleasedReturnValue(v41);
    -[MTLRenderPipelineDescriptor setFragmentPreloadedLibraries:](v4, "setFragmentPreloadedLibraries:", v42);
  }

  unint64_t v43 = (void *)objc_claimAutoreleasedReturnValue(-[MTLRenderPipelineDescriptor vertexLinkedFunctions](v4, "vertexLinkedFunctions"));
  MakeMTLLinkedFunctions(v43, a1 + 1064, v3);

  id v44 = (void *)objc_claimAutoreleasedReturnValue(-[MTLRenderPipelineDescriptor fragmentLinkedFunctions](v4, "fragmentLinkedFunctions"));
  MakeMTLLinkedFunctions(v44, a1 + 872, v3);

  uint64_t v45 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  *(void *)(a1 + 1240)));
  unint64_t v46 = (void *)objc_claimAutoreleasedReturnValue([v3 objectForKeyedSubscript:v45]);
  -[MTLRenderPipelineDescriptor setObjectFunction:](v4, "setObjectFunction:", v46);

  uint64_t v47 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  *(void *)(a1 + 1216)));
  uint64_t v48 = (void *)objc_claimAutoreleasedReturnValue([v3 objectForKeyedSubscript:v47]);
  -[MTLRenderPipelineDescriptor setMeshFunction:](v4, "setMeshFunction:", v48);

  for (uint64_t k = 0LL; k != 31; ++k)
  {
    uint64_t v50 = (void *)objc_claimAutoreleasedReturnValue(-[MTLRenderPipelineDescriptor objectBuffers](v4, "objectBuffers"));
    id v51 = (id)objc_claimAutoreleasedReturnValue([v50 objectAtIndexedSubscript:k]);
    [v51 setMutability:*(unsigned __int8 *)(a1 + 1416 + k)];
  }

  for (uint64_t m = 0LL; m != 31; ++m)
  {
    uint64_t v53 = (void *)objc_claimAutoreleasedReturnValue(-[MTLRenderPipelineDescriptor meshBuffers](v4, "meshBuffers"));
    id v54 = (id)objc_claimAutoreleasedReturnValue([v53 objectAtIndexedSubscript:m]);
    [v54 setMutability:*(unsigned __int8 *)(a1 + 1385 + m)];
  }

  uint64_t v55 = *(void *)(a1 + 1256);
  if (v55)
  {
    id v56 = CreateObjectArrayWithMap(*(uint64_t **)(a1 + 1248), v55, v3);
    id v57 = (void *)objc_claimAutoreleasedReturnValue(v56);
    -[MTLRenderPipelineDescriptor setObjectPreloadedLibraries:](v4, "setObjectPreloadedLibraries:", v57);
  }

  uint64_t v58 = *(void *)(a1 + 1232);
  if (v58)
  {
    id v59 = CreateObjectArrayWithMap(*(uint64_t **)(a1 + 1224), v58, v3);
    id v60 = (void *)objc_claimAutoreleasedReturnValue(v59);
    -[MTLRenderPipelineDescriptor setMeshPreloadedLibraries:](v4, "setMeshPreloadedLibraries:", v60);
  }

  uint64_t v61 = (void *)objc_claimAutoreleasedReturnValue(-[MTLRenderPipelineDescriptor objectLinkedFunctions](v4, "objectLinkedFunctions"));
  MakeMTLLinkedFunctions(v61, a1 + 1000, v3);

  id v62 = (void *)objc_claimAutoreleasedReturnValue(-[MTLRenderPipelineDescriptor meshLinkedFunctions](v4, "meshLinkedFunctions"));
  MakeMTLLinkedFunctions(v62, a1 + 936, v3);

  if ((objc_opt_respondsToSelector(v4, "supportAddingVertexBinaryFunctions") & 1) != 0) {
    -[MTLRenderPipelineDescriptor setSupportAddingVertexBinaryFunctions:]( v4,  "setSupportAddingVertexBinaryFunctions:",  *(_BYTE *)(a1 + 1498) != 0);
  }
  if ((objc_opt_respondsToSelector(v4, "supportAddingFragmentBinaryFunctions") & 1) != 0) {
    -[MTLRenderPipelineDescriptor setSupportAddingFragmentBinaryFunctions:]( v4,  "setSupportAddingFragmentBinaryFunctions:",  *(_BYTE *)(a1 + 1495) != 0);
  }
  if ((objc_opt_respondsToSelector(v4, "supportAddingObjectBinaryFunctions") & 1) != 0) {
    -[MTLRenderPipelineDescriptor setSupportAddingObjectBinaryFunctions:]( v4,  "setSupportAddingObjectBinaryFunctions:",  *(_BYTE *)(a1 + 1497) != 0);
  }
  if ((objc_opt_respondsToSelector(v4, "supportAddingMeshBinaryFunctions") & 1) != 0) {
    -[MTLRenderPipelineDescriptor setSupportAddingMeshBinaryFunctions:]( v4,  "setSupportAddingMeshBinaryFunctions:",  *(_BYTE *)(a1 + 1496) != 0);
  }
  if ((objc_opt_respondsToSelector(v4, "explicitVisibilityGroupID") & 1) != 0) {
    -[MTLRenderPipelineDescriptor setExplicitVisibilityGroupID:]( v4,  "setExplicitVisibilityGroupID:",  *(unsigned int *)(a1 + 1320));
  }
  if ((objc_opt_respondsToSelector(v4, "maxVertexCallStackDepth") & 1) != 0) {
    -[MTLRenderPipelineDescriptor setMaxVertexCallStackDepth:]( v4,  "setMaxVertexCallStackDepth:",  *(unsigned __int16 *)(a1 + 1350));
  }
  if ((objc_opt_respondsToSelector(v4, "maxFragmentCallStackDepth") & 1) != 0) {
    -[MTLRenderPipelineDescriptor setMaxFragmentCallStackDepth:]( v4,  "setMaxFragmentCallStackDepth:",  *(unsigned __int16 *)(a1 + 1344));
  }
  if ((objc_opt_respondsToSelector(v4, "maxObjectCallStackDepth") & 1) != 0) {
    -[MTLRenderPipelineDescriptor setMaxObjectCallStackDepth:]( v4,  "setMaxObjectCallStackDepth:",  *(unsigned __int16 *)(a1 + 1348));
  }
  if ((objc_opt_respondsToSelector(v4, "maxMeshCallStackDepth") & 1) != 0) {
    -[MTLRenderPipelineDescriptor setMaxMeshCallStackDepth:]( v4,  "setMaxMeshCallStackDepth:",  *(unsigned __int16 *)(a1 + 1346));
  }
  if ((objc_opt_respondsToSelector(v4, "maxAccelerationStructureTraversalDepth") & 1) != 0) {
    -[MTLRenderPipelineDescriptor setMaxAccelerationStructureTraversalDepth:]( v4,  "setMaxAccelerationStructureTraversalDepth:",  *(unsigned __int16 *)(a1 + 1342));
  }
  uint64_t v63 = v4;

  return v63;
}

id GTData_MakeDictionary(uint64_t a1, uint64_t a2)
{
  if (!a1) {
    return 0LL;
  }
  uint64_t v4 = objc_opt_class(&OBJC_CLASS___NSDictionary, a2);
  uint64_t v6 = objc_opt_class(&OBJC_CLASS___NSNumber, v5);
  uint64_t v8 = objc_opt_class(&OBJC_CLASS___NSString, v7);
  uint64_t v10 = objc_opt_class(&OBJC_CLASS___NSData, v9);
  uint64_t v12 = +[NSSet setWithObjects:]( &OBJC_CLASS___NSSet,  "setWithObjects:",  v4,  v6,  v8,  v10,  objc_opt_class(&OBJC_CLASS___NSNull, v11),  0LL);
  id v13 = (void *)objc_claimAutoreleasedReturnValue(v12);
  unsigned int v14 = (void *)objc_claimAutoreleasedReturnValue( +[NSData dataWithBytesNoCopy:length:freeWhenDone:]( &OBJC_CLASS___NSData,  "dataWithBytesNoCopy:length:freeWhenDone:",  a1,  a2,  0LL));
  id v24 = 0LL;
  uint64_t v15 = (void *)objc_claimAutoreleasedReturnValue( +[NSKeyedUnarchiver unarchivedObjectOfClasses:fromData:error:]( &OBJC_CLASS___NSKeyedUnarchiver,  "unarchivedObjectOfClasses:fromData:error:",  v13,  v14,  &v24));
  id v16 = v24;

  if (v16)
  {
    if (s_logUsingOsLog)
    {
      id v17 = gt_default_log();
      id v18 = (os_log_s *)objc_claimAutoreleasedReturnValue(v17);
      if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
      {
        id v19 = objc_claimAutoreleasedReturnValue([v16 localizedDescription]);
        id v20 = [v19 UTF8String];
        *(_DWORD *)buf = 136315138;
        id v26 = v20;
        _os_log_error_impl(&dword_0, v18, OS_LOG_TYPE_ERROR, "warning: %s", buf, 0xCu);
      }
    }

    else
    {
      uint64_t v22 = __stderrp;
      id v18 = (os_log_s *) objc_claimAutoreleasedReturnValue([v16 localizedDescription]);
      id v23 = objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString, "stringWithFormat:", @"warning: %s", -[os_log_s UTF8String](v18, "UTF8String")));
      fprintf(v22, "%s\n", (const char *)[v23 UTF8String]);
    }
  }

  return v15;
}

void MakeMTLLinkedFunctions(void *a1, uint64_t a2, void *a3)
{
  id v24 = a1;
  id v5 = a3;
  if (*(void *)(a2 + 56) + *(void *)(a2 + 24) + *(void *)(a2 + 8) + *(void *)(a2 + 40))
  {
    id v6 = v24;
    id v7 = v5;
    uint64_t v8 = *(void *)(a2 + 24);
    if (v8)
    {
      id ObjectArrayWithMap = CreateObjectArrayWithMap(*(uint64_t **)(a2 + 16), v8, v7);
      uint64_t v10 = (void *)objc_claimAutoreleasedReturnValue(ObjectArrayWithMap);
      [v6 setFunctions:v10];
    }

    uint64_t v11 = *(void *)(a2 + 8);
    if (v11)
    {
      id v12 = CreateObjectArrayWithMap(*(uint64_t **)a2, v11, v7);
      id v13 = (void *)objc_claimAutoreleasedReturnValue(v12);
      [v6 setBinaryFunctions:v13];
    }

    uint64_t v14 = *(void *)(a2 + 56);
    if (v14)
    {
      id v15 = CreateObjectArrayWithMap(*(uint64_t **)(a2 + 48), v14, v7);
      id v16 = (void *)objc_claimAutoreleasedReturnValue(v15);
      [v6 setPrivateFunctions:v16];
    }

    if (*(void *)(a2 + 40))
    {
      id v17 = -[NSMutableDictionary initWithCapacity:]( objc_alloc(&OBJC_CLASS___NSMutableDictionary),  "initWithCapacity:",  *(void *)(a2 + 40));
      if (*(void *)(a2 + 40))
      {
        uint64_t v18 = 0LL;
        unint64_t v19 = 0LL;
        do
        {
          id v20 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithUTF8String:]( &OBJC_CLASS___NSString,  "stringWithUTF8String:",  *(void *)(*(void *)(a2 + 32) + v18)));
          id v21 = CreateObjectArrayWithMap( *(uint64_t **)(*(void *)(a2 + 32) + v18 + 8),  *(_DWORD *)(*(void *)(a2 + 32) + v18 + 16),  v7);
          uint64_t v22 = (void *)objc_claimAutoreleasedReturnValue(v21);
          -[NSMutableDictionary setObject:forKeyedSubscript:](v17, "setObject:forKeyedSubscript:", v22, v20);

          ++v19;
          v18 += 24LL;
        }

        while (*(void *)(a2 + 40) > v19);
      }

      id v23 = -[NSMutableDictionary copy](v17, "copy");
      [v6 setGroups:v23];
    }
  }
}

id MakeMTLRenderPipelineDescriptorWithResourceIndex(uint64_t a1, void *a2)
{
  MTLRenderPipelineDescriptorWithoutResourceIndex = MakeMTLRenderPipelineDescriptorWithoutResourceIndex(a1, a2);
  uint64_t v4 = (void *)objc_claimAutoreleasedReturnValue(MTLRenderPipelineDescriptorWithoutResourceIndex);
  id v5 = v4;
  if (*(_BYTE *)(a1 + 1499)) {
    [v4 setResourceIndex:*(void *)(a1 + 1280)];
  }
  return v5;
}

MTLMeshRenderPipelineDescriptor *MakeMTLMeshRenderPipelineDescriptorWithoutResourceIndex( uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = objc_alloc_init(&OBJC_CLASS___MTLMeshRenderPipelineDescriptor);
  if (*(void *)(a1 + 352))
  {
    id v5 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:"));
    -[MTLMeshRenderPipelineDescriptor setLabel:](v4, "setLabel:", v5);
  }

  id v6 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  *(void *)(a1 + 368)));
  id v7 = (void *)objc_claimAutoreleasedReturnValue([v3 objectForKeyedSubscript:v6]);
  -[MTLMeshRenderPipelineDescriptor setObjectFunction:](v4, "setObjectFunction:", v7);

  uint64_t v8 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  *(void *)(a1 + 360)));
  uint64_t v9 = (void *)objc_claimAutoreleasedReturnValue([v3 objectForKeyedSubscript:v8]);
  -[MTLMeshRenderPipelineDescriptor setMeshFunction:](v4, "setMeshFunction:", v9);

  uint64_t v10 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  *(void *)(a1 + 344)));
  uint64_t v11 = (void *)objc_claimAutoreleasedReturnValue([v3 objectForKeyedSubscript:v10]);
  -[MTLMeshRenderPipelineDescriptor setFragmentFunction:](v4, "setFragmentFunction:", v11);

  if ((objc_opt_respondsToSelector(v4, "maxTotalThreadsPerObjectThreadgroup") & 1) != 0) {
    -[MTLMeshRenderPipelineDescriptor setMaxTotalThreadsPerObjectThreadgroup:]( v4,  "setMaxTotalThreadsPerObjectThreadgroup:",  *(unsigned __int16 *)(a1 + 406));
  }
  if ((objc_opt_respondsToSelector(v4, "maxTotalThreadsPerMeshThreadgroup") & 1) != 0) {
    -[MTLMeshRenderPipelineDescriptor setMaxTotalThreadsPerMeshThreadgroup:]( v4,  "setMaxTotalThreadsPerMeshThreadgroup:",  *(unsigned __int16 *)(a1 + 404));
  }
  if ((objc_opt_respondsToSelector(v4, "objectThreadgroupSizeIsMultipleOfThreadExecutionWidth") & 1) != 0) {
    -[MTLMeshRenderPipelineDescriptor setObjectThreadgroupSizeIsMultipleOfThreadExecutionWidth:]( v4,  "setObjectThreadgroupSizeIsMultipleOfThreadExecutionWidth:",  *(_BYTE *)(a1 + 507) != 0);
  }
  if ((objc_opt_respondsToSelector(v4, "meshThreadgroupSizeIsMultipleOfThreadExecutionWidth") & 1) != 0) {
    -[MTLMeshRenderPipelineDescriptor setMeshThreadgroupSizeIsMultipleOfThreadExecutionWidth:]( v4,  "setMeshThreadgroupSizeIsMultipleOfThreadExecutionWidth:",  *(_BYTE *)(a1 + 506) != 0);
  }
  -[MTLMeshRenderPipelineDescriptor setPayloadMemoryLength:](v4, "setPayloadMemoryLength:", *(void *)(a1 + 376));
  uint64_t v12 = *(void *)(a1 + 336);
  __int128 v30 = *(_OWORD *)(a1 + 320);
  uint64_t v31 = v12;
  -[MTLMeshRenderPipelineDescriptor setMaxThreadgroupsPerMeshGrid:](v4, "setMaxThreadgroupsPerMeshGrid:", &v30);
  for (uint64_t i = 0LL; i != 31; ++i)
  {
    uint64_t v14 = (void *)objc_claimAutoreleasedReturnValue(-[MTLMeshRenderPipelineDescriptor objectBuffers](v4, "objectBuffers"));
    id v15 = (void *)objc_claimAutoreleasedReturnValue([v14 objectAtIndexedSubscript:i]);
    [v15 setMutability:*(unsigned __int8 *)(a1 + 472 + i)];
  }

  for (uint64_t j = 0LL; j != 31; ++j)
  {
    id v17 = (void *)objc_claimAutoreleasedReturnValue(-[MTLMeshRenderPipelineDescriptor meshBuffers](v4, "meshBuffers"));
    uint64_t v18 = (void *)objc_claimAutoreleasedReturnValue([v17 objectAtIndexedSubscript:j]);
    [v18 setMutability:*(unsigned __int8 *)(a1 + 441 + j)];
  }

  for (uint64_t k = 0LL; k != 31; ++k)
  {
    id v20 = (void *)objc_claimAutoreleasedReturnValue(-[MTLMeshRenderPipelineDescriptor fragmentBuffers](v4, "fragmentBuffers"));
    id v21 = (void *)objc_claimAutoreleasedReturnValue([v20 objectAtIndexedSubscript:k]);
    [v21 setMutability:*(unsigned __int8 *)(a1 + 410 + k)];
  }

  -[MTLMeshRenderPipelineDescriptor setRasterSampleCount:](v4, "setRasterSampleCount:", *(unsigned __int8 *)(a1 + 508));
  -[MTLMeshRenderPipelineDescriptor setAlphaToCoverageEnabled:]( v4,  "setAlphaToCoverageEnabled:",  *(_BYTE *)(a1 + 503) != 0);
  -[MTLMeshRenderPipelineDescriptor setAlphaToOneEnabled:](v4, "setAlphaToOneEnabled:", *(_BYTE *)(a1 + 504) != 0);
  -[MTLMeshRenderPipelineDescriptor setRasterizationEnabled:](v4, "setRasterizationEnabled:", *(_BYTE *)(a1 + 509) != 0);
  if ((objc_opt_respondsToSelector(v4, "maxVertexAmplificationCount") & 1) != 0) {
    -[MTLMeshRenderPipelineDescriptor setMaxVertexAmplificationCount:]( v4,  "setMaxVertexAmplificationCount:",  *(unsigned int *)(a1 + 396));
  }
  uint64_t v22 = 0LL;
  id v23 = (unsigned __int16 *)a1;
  do
  {
    id v24 = (void *)objc_claimAutoreleasedReturnValue(-[MTLMeshRenderPipelineDescriptor colorAttachments](v4, "colorAttachments"));
    id v25 = (void *)objc_claimAutoreleasedReturnValue([v24 objectAtIndexedSubscript:v22]);

    ++v22;
    v23 += 8;
  }

  while (v22 != 8);
  -[MTLMeshRenderPipelineDescriptor setDepthAttachmentPixelFormat:]( v4,  "setDepthAttachmentPixelFormat:",  *(unsigned __int16 *)(a1 + 400));
  -[MTLMeshRenderPipelineDescriptor setStencilAttachmentPixelFormat:]( v4,  "setStencilAttachmentPixelFormat:",  *(unsigned __int16 *)(a1 + 408));
  if ((objc_opt_respondsToSelector(v4, "supportIndirectCommandBuffers") & 1) != 0) {
    -[MTLMeshRenderPipelineDescriptor setSupportIndirectCommandBuffers:]( v4,  "setSupportIndirectCommandBuffers:",  *(_BYTE *)(a1 + 510) != 0);
  }
  if ((objc_opt_respondsToSelector(v4, "explicitVisibilityGroupID") & 1) != 0) {
    -[MTLMeshRenderPipelineDescriptor setExplicitVisibilityGroupID:]( v4,  "setExplicitVisibilityGroupID:",  *(unsigned int *)(a1 + 392));
  }
  id v26 = (void *)objc_claimAutoreleasedReturnValue(-[MTLMeshRenderPipelineDescriptor objectLinkedFunctions](v4, "objectLinkedFunctions"));
  MakeMTLLinkedFunctions(v26, a1 + 256, v3);

  id v27 = (void *)objc_claimAutoreleasedReturnValue(-[MTLMeshRenderPipelineDescriptor meshLinkedFunctions](v4, "meshLinkedFunctions"));
  MakeMTLLinkedFunctions(v27, a1 + 192, v3);

  uint64_t v28 = (void *)objc_claimAutoreleasedReturnValue(-[MTLMeshRenderPipelineDescriptor fragmentLinkedFunctions](v4, "fragmentLinkedFunctions"));
  MakeMTLLinkedFunctions(v28, a1 + 128, v3);

  if ((objc_opt_respondsToSelector(v4, "maxAccelerationStructureTraversalDepth") & 1) != 0) {
    -[MTLMeshRenderPipelineDescriptor setMaxAccelerationStructureTraversalDepth:]( v4,  "setMaxAccelerationStructureTraversalDepth:",  *(unsigned __int16 *)(a1 + 402));
  }

  return v4;
}

id MakeMTLMeshRenderPipelineDescriptorWithResourceIndex(uint64_t a1, void *a2)
{
  MTLMeshRenderPipelineDescriptorWithoutResourceIndex = MakeMTLMeshRenderPipelineDescriptorWithoutResourceIndex(a1, a2);
  uint64_t v4 = (void *)objc_claimAutoreleasedReturnValue(MTLMeshRenderPipelineDescriptorWithoutResourceIndex);
  id v5 = v4;
  if (*(_BYTE *)(a1 + 510)) {
    [v4 setResourceIndex:*(void *)(a1 + 384)];
  }
  return v5;
}

id MakeMTLStencilDescriptor(void *a1, unsigned int *a2)
{
  id v3 = a1;
  [v3 setStencilCompareFunction:*((unsigned __int8 *)a2 + 10)];
  [v3 setStencilFailureOperation:*((unsigned __int8 *)a2 + 11)];
  [v3 setDepthFailureOperation:*((unsigned __int8 *)a2 + 8)];
  [v3 setDepthStencilPassOperation:*((unsigned __int8 *)a2 + 9)];
  [v3 setReadMask:*a2];
  [v3 setWriteMask:a2[1]];
  return v3;
}

MTLDepthStencilDescriptor *MakeMTLDepthStencilDescriptor(uint64_t a1)
{
  id v2 = objc_alloc_init(&OBJC_CLASS___MTLDepthStencilDescriptor);
  -[MTLDepthStencilDescriptor setDepthCompareFunction:](v2, "setDepthCompareFunction:", *(unsigned __int8 *)(a1 + 40));
  -[MTLDepthStencilDescriptor setDepthWriteEnabled:](v2, "setDepthWriteEnabled:", *(_BYTE *)(a1 + 41) != 0);
  if (*(void *)(a1 + 32))
  {
    id v3 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:"));
    -[MTLDepthStencilDescriptor setLabel:](v2, "setLabel:", v3);
  }

  uint64_t v4 = (void *)objc_claimAutoreleasedReturnValue(-[MTLDepthStencilDescriptor frontFaceStencil](v2, "frontFaceStencil"));

  id v5 = (void *)objc_claimAutoreleasedReturnValue(-[MTLDepthStencilDescriptor backFaceStencil](v2, "backFaceStencil"));
  return v2;
}

MTLSamplerDescriptor *MakeMTLSamplerDescriptorWithoutResourceIndex(uint64_t a1)
{
  id v2 = objc_alloc_init(&OBJC_CLASS___MTLSamplerDescriptor);
  -[MTLSamplerDescriptor setMinFilter:](v2, "setMinFilter:", *(unsigned __int8 *)(a1 + 56));
  -[MTLSamplerDescriptor setMagFilter:](v2, "setMagFilter:", *(unsigned __int8 *)(a1 + 55));
  -[MTLSamplerDescriptor setMipFilter:](v2, "setMipFilter:", *(unsigned __int8 *)(a1 + 57));
  -[MTLSamplerDescriptor setMaxAnisotropy:](v2, "setMaxAnisotropy:", *(void *)(a1 + 8));
  -[MTLSamplerDescriptor setSAddressMode:](v2, "setSAddressMode:", *(unsigned __int8 *)(a1 + 61));
  -[MTLSamplerDescriptor setTAddressMode:](v2, "setTAddressMode:", *(unsigned __int8 *)(a1 + 63));
  -[MTLSamplerDescriptor setRAddressMode:](v2, "setRAddressMode:", *(unsigned __int8 *)(a1 + 59));
  -[MTLSamplerDescriptor setNormalizedCoordinates:](v2, "setNormalizedCoordinates:", *(_BYTE *)(a1 + 58) != 0);
  LODWORD(v3) = *(_DWORD *)(a1 + 44);
  -[MTLSamplerDescriptor setLodMinClamp:](v2, "setLodMinClamp:", v3);
  LODWORD(v4) = *(_DWORD *)(a1 + 40);
  -[MTLSamplerDescriptor setLodMaxClamp:](v2, "setLodMaxClamp:", v4);
  if (*(void *)a1)
  {
    id v5 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:"));
    -[MTLSamplerDescriptor setLabel:](v2, "setLabel:", v5);
  }

  -[MTLSamplerDescriptor setLodAverage:](v2, "setLodAverage:", *(_BYTE *)(a1 + 54) != 0);
  -[MTLSamplerDescriptor setCompareFunction:](v2, "setCompareFunction:", *(unsigned __int8 *)(a1 + 51));
  -[MTLSamplerDescriptor setBorderColor:](v2, "setBorderColor:", *(unsigned __int8 *)(a1 + 50));
  -[MTLSamplerDescriptor setSupportArgumentBuffers:](v2, "setSupportArgumentBuffers:", *(_BYTE *)(a1 + 62) != 0);
  if ((objc_opt_respondsToSelector(v2, "customBorderColorValue_0") & 1) != 0) {
    -[MTLSamplerDescriptor setCustomBorderColorValue_0:](v2, "setCustomBorderColorValue_0:", *(unsigned int *)(a1 + 24));
  }
  if ((objc_opt_respondsToSelector(v2, "customBorderColorValue_1") & 1) != 0) {
    -[MTLSamplerDescriptor setCustomBorderColorValue_1:](v2, "setCustomBorderColorValue_1:", *(unsigned int *)(a1 + 28));
  }
  if ((objc_opt_respondsToSelector(v2, "customBorderColorValue_2") & 1) != 0) {
    -[MTLSamplerDescriptor setCustomBorderColorValue_2:](v2, "setCustomBorderColorValue_2:", *(unsigned int *)(a1 + 32));
  }
  if ((objc_opt_respondsToSelector(v2, "customBorderColorValue_3") & 1) != 0) {
    -[MTLSamplerDescriptor setCustomBorderColorValue_3:](v2, "setCustomBorderColorValue_3:", *(unsigned int *)(a1 + 36));
  }
  if ((objc_opt_respondsToSelector(v2, "forceSeamsOnCubemapFiltering") & 1) != 0) {
    -[MTLSamplerDescriptor setForceSeamsOnCubemapFiltering:]( v2,  "setForceSeamsOnCubemapFiltering:",  *(_BYTE *)(a1 + 53) != 0);
  }
  if ((objc_opt_respondsToSelector(v2, "pixelFormat") & 1) != 0) {
    -[MTLSamplerDescriptor setPixelFormat:](v2, "setPixelFormat:", *(unsigned __int16 *)(a1 + 48));
  }
  return v2;
}

id MakeMTLSamplerDescriptorWithResourceIndex(uint64_t a1)
{
  MTLSamplerDescriptorWithoutResourceIndex = MakeMTLSamplerDescriptorWithoutResourceIndex(a1);
  double v3 = (void *)objc_claimAutoreleasedReturnValue(MTLSamplerDescriptorWithoutResourceIndex);
  [v3 setForceResourceIndex:*(void *)(a1 + 16) != 0];
  [v3 setResourceIndex:*(void *)(a1 + 16)];
  return v3;
}

MTLHeapDescriptor *MakeMTLHeapDescriptor(uint64_t a1)
{
  id v2 = objc_alloc_init(&OBJC_CLASS___MTLHeapDescriptor);
  -[MTLHeapDescriptor setSize:](v2, "setSize:", *(void *)(a1 + 8));
  if ((objc_opt_respondsToSelector(v2, "type") & 1) != 0) {
    -[MTLHeapDescriptor setType:](v2, "setType:", *(unsigned __int8 *)(a1 + 19));
  }
  if ((objc_opt_respondsToSelector(v2, "resourceOptions") & 1) != 0) {
    -[MTLHeapDescriptor setResourceOptions:](v2, "setResourceOptions:", *(unsigned __int16 *)(a1 + 16));
  }
  if ((objc_opt_respondsToSelector(v2, "sparsePageSize") & 1) != 0) {
    -[MTLHeapDescriptor setSparsePageSize:](v2, "setSparsePageSize:", *(unsigned __int8 *)(a1 + 18));
  }
  return v2;
}

MTLIndirectCommandBufferDescriptor *MakeMTLIndirectCommandBufferDescriptorWithoutResourceIndex(uint64_t a1)
{
  id v2 = objc_alloc_init(&OBJC_CLASS___MTLIndirectCommandBufferDescriptor);
  -[MTLIndirectCommandBufferDescriptor setCommandTypes:](v2, "setCommandTypes:", *(unsigned __int16 *)(a1 + 8));
  if ((objc_opt_respondsToSelector(v2, "inheritPipelineState") & 1) != 0) {
    -[MTLIndirectCommandBufferDescriptor setInheritPipelineState:]( v2,  "setInheritPipelineState:",  *(_BYTE *)(a1 + 11) != 0);
  }
  -[MTLIndirectCommandBufferDescriptor setInheritBuffers:](v2, "setInheritBuffers:", *(_BYTE *)(a1 + 10) != 0);
  -[MTLIndirectCommandBufferDescriptor setMaxVertexBufferBindCount:]( v2,  "setMaxVertexBufferBindCount:",  *(unsigned __int8 *)(a1 + 18));
  -[MTLIndirectCommandBufferDescriptor setMaxFragmentBufferBindCount:]( v2,  "setMaxFragmentBufferBindCount:",  *(unsigned __int8 *)(a1 + 12));
  if ((objc_opt_respondsToSelector(v2, "maxKernelBufferBindCount") & 1) != 0) {
    -[MTLIndirectCommandBufferDescriptor setMaxKernelBufferBindCount:]( v2,  "setMaxKernelBufferBindCount:",  *(unsigned __int8 *)(a1 + 13));
  }
  if ((objc_opt_respondsToSelector(v2, "maxKernelThreadgroupMemoryBindCount") & 1) != 0) {
    -[MTLIndirectCommandBufferDescriptor setMaxKernelThreadgroupMemoryBindCount:]( v2,  "setMaxKernelThreadgroupMemoryBindCount:",  *(unsigned __int8 *)(a1 + 14));
  }
  if ((objc_opt_respondsToSelector(v2, "supportRayTracing") & 1) != 0) {
    -[MTLIndirectCommandBufferDescriptor setSupportRayTracing:](v2, "setSupportRayTracing:", *(_BYTE *)(a1 + 20) != 0);
  }
  if ((objc_opt_respondsToSelector(v2, "maxObjectBufferBindCount") & 1) != 0) {
    -[MTLIndirectCommandBufferDescriptor setMaxObjectBufferBindCount:]( v2,  "setMaxObjectBufferBindCount:",  *(unsigned __int8 *)(a1 + 16));
  }
  if ((objc_opt_respondsToSelector(v2, "maxMeshBufferBindCount") & 1) != 0) {
    -[MTLIndirectCommandBufferDescriptor setMaxMeshBufferBindCount:]( v2,  "setMaxMeshBufferBindCount:",  *(unsigned __int8 *)(a1 + 15));
  }
  if ((objc_opt_respondsToSelector(v2, "maxObjectThreadgroupMemoryBindCount") & 1) != 0) {
    -[MTLIndirectCommandBufferDescriptor setMaxObjectThreadgroupMemoryBindCount:]( v2,  "setMaxObjectThreadgroupMemoryBindCount:",  *(unsigned __int8 *)(a1 + 17));
  }
  if ((objc_opt_respondsToSelector(v2, "supportDynamicAttributeStride") & 1) != 0) {
    -[MTLIndirectCommandBufferDescriptor setSupportDynamicAttributeStride:]( v2,  "setSupportDynamicAttributeStride:",  *(_BYTE *)(a1 + 19) != 0);
  }
  return v2;
}

id MakeMTLIndirectCommandBufferDescriptorWithResourceIndex(void *a1)
{
  MTLIndirectCommandBufferDescriptorWithoutResourceIndex = MakeMTLIndirectCommandBufferDescriptorWithoutResourceIndex((uint64_t)a1);
  double v3 = (void *)objc_claimAutoreleasedReturnValue(MTLIndirectCommandBufferDescriptorWithoutResourceIndex);
  [v3 setResourceIndex:*a1];
  return v3;
}

MTLComputePipelineDescriptor *MakeMTLComputePipelineDescriptorWithoutResourceIndex(uint64_t a1, void *a2)
{
  id v3 = a2;
  double v4 = objc_alloc_init(&OBJC_CLASS___MTLComputePipelineDescriptor);
  id v5 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  *(void *)(a1 + 848)));
  id v6 = (void *)objc_claimAutoreleasedReturnValue([v3 objectForKeyedSubscript:v5]);
  -[MTLComputePipelineDescriptor setComputeFunction:](v4, "setComputeFunction:", v6);

  -[MTLComputePipelineDescriptor setThreadGroupSizeIsMultipleOfThreadExecutionWidth:]( v4,  "setThreadGroupSizeIsMultipleOfThreadExecutionWidth:",  *(_BYTE *)(a1 + 958) != 0);
  if (*(void *)(a1 + 872))
  {
    id v7 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:"));
    -[MTLComputePipelineDescriptor setLabel:](v4, "setLabel:", v7);
  }

  id v8 = (id)objc_claimAutoreleasedReturnValue(-[MTLComputePipelineDescriptor stageInputDescriptor](v4, "stageInputDescriptor"));
  uint64_t v9 = 0LL;
  uint64_t v10 = (unsigned __int8 *)(a1 + 10);
  do
  {
    uint64_t v11 = (void *)objc_claimAutoreleasedReturnValue([v8 layouts]);
    id v12 = (id)objc_claimAutoreleasedReturnValue([v11 objectAtIndexedSubscript:v9]);
    [v12 setStride:*(void *)(v10 - 10)];
    [v12 setStepRate:*((unsigned __int16 *)v10 - 1)];
    unsigned int v13 = *v10;
    v10 += 16;
    [v12 setStepFunction:v13];

    ++v9;
  }

  while (v9 != 31);
  uint64_t v14 = 0LL;
  id v15 = (unsigned __int8 *)(a1 + 501);
  do
  {
    id v16 = (void *)objc_claimAutoreleasedReturnValue([v8 attributes]);
    id v17 = (id)objc_claimAutoreleasedReturnValue([v16 objectAtIndexedSubscript:v14]);
    [v17 setFormat:*v15];
    [v17 setOffset:*(unsigned int *)(v15 - 5)];
    [v17 setBufferIndex:*(v15 - 1)];

    ++v14;
    v15 += 8;
  }

  while (v14 != 31);
  [v8 setIndexType:*(unsigned __int8 *)(a1 + 745)];
  [v8 setIndexBufferIndex:*(unsigned __int8 *)(a1 + 744)];

  for (uint64_t i = 0LL; i != 31; ++i)
  {
    unint64_t v19 = (void *)objc_claimAutoreleasedReturnValue(-[MTLComputePipelineDescriptor buffers](v4, "buffers"));
    id v20 = (void *)objc_claimAutoreleasedReturnValue([v19 objectAtIndexedSubscript:i]);
    [v20 setMutability:*(unsigned __int8 *)(a1 + 920 + i)];
  }

  if ((objc_opt_respondsToSelector(v4, "supportIndirectCommandBuffers") & 1) != 0) {
    -[MTLComputePipelineDescriptor setSupportIndirectCommandBuffers:]( v4,  "setSupportIndirectCommandBuffers:",  *(_BYTE *)(a1 + 956) != 0);
  }
  -[MTLComputePipelineDescriptor setMaxTotalThreadsPerThreadgroup:]( v4,  "setMaxTotalThreadsPerThreadgroup:",  *(unsigned __int16 *)(a1 + 918));
  id v21 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  *(void *)(a1 + 880)));
  uint64_t v22 = (void *)objc_claimAutoreleasedReturnValue([v3 objectForKeyedSubscript:v21]);
  -[MTLComputePipelineDescriptor setPipelineLibrary:](v4, "setPipelineLibrary:", v22);

  uint64_t v23 = *(void *)(a1 + 864);
  if (v23)
  {
    id ObjectArrayWithMap = CreateObjectArrayWithMap(*(uint64_t **)(a1 + 856), v23, v3);
    id v25 = (void *)objc_claimAutoreleasedReturnValue(ObjectArrayWithMap);
    -[MTLComputePipelineDescriptor setFunctionPointers:](v4, "setFunctionPointers:", v25);
  }

  if ((objc_opt_respondsToSelector(v4, "textureWriteRoundingMode") & 1) != 0) {
    -[MTLComputePipelineDescriptor setTextureWriteRoundingMode:]( v4,  "setTextureWriteRoundingMode:",  *(unsigned __int8 *)(a1 + 957));
  }
  if ((objc_opt_respondsToSelector(v4, "openGLModeEnabled") & 1) != 0) {
    -[MTLComputePipelineDescriptor setOpenGLModeEnabled:](v4, "setOpenGLModeEnabled:", *(_BYTE *)(a1 + 954) != 0);
  }
  if ((objc_opt_respondsToSelector(v4, "openCLModeEnabled") & 1) != 0) {
    -[MTLComputePipelineDescriptor setOpenCLModeEnabled:](v4, "setOpenCLModeEnabled:", *(_BYTE *)(a1 + 953) != 0);
  }
  if ((objc_opt_respondsToSelector(v4, "needsCustomBorderColorSamplers") & 1) != 0) {
    -[MTLComputePipelineDescriptor setNeedsCustomBorderColorSamplers:]( v4,  "setNeedsCustomBorderColorSamplers:",  *(_BYTE *)(a1 + 952) != 0);
  }
  id Dictionary = GTData_MakeDictionary(*(void *)(a1 + 832), *(void *)(a1 + 840));
  id v27 = (void *)objc_claimAutoreleasedReturnValue(Dictionary);
  -[MTLComputePipelineDescriptor setPluginData:](v4, "setPluginData:", v27);

  id v28 = GTData_MakeDictionary(*(void *)(a1 + 816), *(void *)(a1 + 824));
  uint64_t v29 = (void *)objc_claimAutoreleasedReturnValue(v28);
  -[MTLComputePipelineDescriptor setDriverCompilerOptions:](v4, "setDriverCompilerOptions:", v29);

  if ((objc_opt_respondsToSelector(v4, "maxCallStackDepth") & 1) != 0) {
    -[MTLComputePipelineDescriptor setMaxCallStackDepth:](v4, "setMaxCallStackDepth:", *(unsigned __int16 *)(a1 + 916));
  }
  if ((objc_opt_respondsToSelector(v4, "supportAddingBinaryFunctions") & 1) != 0) {
    -[MTLComputePipelineDescriptor setSupportAddingBinaryFunctions:]( v4,  "setSupportAddingBinaryFunctions:",  *(_BYTE *)(a1 + 955) != 0);
  }
  __int128 v30 = (void *)objc_claimAutoreleasedReturnValue(-[MTLComputePipelineDescriptor linkedFunctions](v4, "linkedFunctions"));
  MakeMTLLinkedFunctions(v30, a1 + 752, v3);

  uint64_t v31 = *(void *)(a1 + 896);
  if (v31)
  {
    id v32 = CreateObjectArrayWithMap(*(uint64_t **)(a1 + 888), v31, v3);
    float v33 = (void *)objc_claimAutoreleasedReturnValue(v32);
    -[MTLComputePipelineDescriptor setPreloadedLibraries:](v4, "setPreloadedLibraries:", v33);
  }

  if ((objc_opt_respondsToSelector(v4, "maxAccelerationStructureTraversalDepth") & 1) != 0) {
    -[MTLComputePipelineDescriptor setMaxAccelerationStructureTraversalDepth:]( v4,  "setMaxAccelerationStructureTraversalDepth:",  *(unsigned __int16 *)(a1 + 914));
  }

  return v4;
}

id MakeMTLComputePipelineDescriptorWithResourceIndex(uint64_t a1, void *a2)
{
  MTLComputePipelineDescriptorWithoutResourceIndex = MakeMTLComputePipelineDescriptorWithoutResourceIndex(a1, a2);
  double v4 = (void *)objc_claimAutoreleasedReturnValue(MTLComputePipelineDescriptorWithoutResourceIndex);
  id v5 = v4;
  if (*(_BYTE *)(a1 + 956)) {
    [v4 setResourceIndex:*(void *)(a1 + 904)];
  }
  return v5;
}

MTLTileRenderPipelineDescriptor *MakeMTLTileRenderPipelineDescriptor(uint64_t a1, void *a2)
{
  id v3 = a2;
  double v4 = objc_alloc_init(&OBJC_CLASS___MTLTileRenderPipelineDescriptor);
  if (*(void *)(a1 + 96))
  {
    id v5 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:"));
    -[MTLTileRenderPipelineDescriptor setLabel:](v4, "setLabel:", v5);
  }

  id v6 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  *(void *)(a1 + 120)));
  id v7 = (void *)objc_claimAutoreleasedReturnValue([v3 objectForKeyedSubscript:v6]);
  -[MTLTileRenderPipelineDescriptor setTileFunction:](v4, "setTileFunction:", v7);

  -[MTLTileRenderPipelineDescriptor setRasterSampleCount:](v4, "setRasterSampleCount:", *(unsigned __int16 *)(a1 + 134));
  for (uint64_t i = 0LL; i != 8; ++i)
  {
    uint64_t v9 = (void *)objc_claimAutoreleasedReturnValue(-[MTLTileRenderPipelineDescriptor colorAttachments](v4, "colorAttachments"));
    uint64_t v10 = (void *)objc_claimAutoreleasedReturnValue([v9 objectAtIndexedSubscript:i]);
    [v10 setPixelFormat:*(unsigned __int16 *)(a1 + 2 * i + 64)];
  }

  -[MTLTileRenderPipelineDescriptor setThreadgroupSizeMatchesTileSize:]( v4,  "setThreadgroupSizeMatchesTileSize:",  *(_BYTE *)(a1 + 169) != 0);
  for (uint64_t j = 0LL; j != 31; ++j)
  {
    id v12 = (void *)objc_claimAutoreleasedReturnValue(-[MTLTileRenderPipelineDescriptor tileBuffers](v4, "tileBuffers"));
    unsigned int v13 = (void *)objc_claimAutoreleasedReturnValue([v12 objectAtIndexedSubscript:j]);
    [v13 setMutability:*(unsigned __int8 *)(a1 + j + 136)];
  }

  id Dictionary = GTData_MakeDictionary(*(void *)(a1 + 80), *(void *)(a1 + 88));
  id v15 = (void *)objc_claimAutoreleasedReturnValue(Dictionary);
  -[MTLTileRenderPipelineDescriptor setPluginData:](v4, "setPluginData:", v15);

  uint64_t v16 = *(void *)(a1 + 112);
  if (v16)
  {
    id ObjectArrayWithMap = CreateObjectArrayWithMap(*(uint64_t **)(a1 + 104), v16, v3);
    uint64_t v18 = (void *)objc_claimAutoreleasedReturnValue(ObjectArrayWithMap);
    -[MTLTileRenderPipelineDescriptor setPreloadedLibraries:](v4, "setPreloadedLibraries:", v18);
  }

  unint64_t v19 = (void *)objc_claimAutoreleasedReturnValue(-[MTLTileRenderPipelineDescriptor linkedFunctions](v4, "linkedFunctions"));
  MakeMTLLinkedFunctions(v19, a1, v3);

  if ((objc_opt_respondsToSelector(v4, "supportAddingBinaryFunctions") & 1) != 0) {
    -[MTLTileRenderPipelineDescriptor setSupportAddingBinaryFunctions:]( v4,  "setSupportAddingBinaryFunctions:",  *(_BYTE *)(a1 + 168) != 0);
  }
  if ((objc_opt_respondsToSelector(v4, "maxCallStackDepth") & 1) != 0) {
    -[MTLTileRenderPipelineDescriptor setMaxCallStackDepth:]( v4,  "setMaxCallStackDepth:",  *(unsigned __int16 *)(a1 + 130));
  }
  if ((objc_opt_respondsToSelector(v4, "maxAccelerationStructureTraversalDepth") & 1) != 0) {
    -[MTLTileRenderPipelineDescriptor setMaxAccelerationStructureTraversalDepth:]( v4,  "setMaxAccelerationStructureTraversalDepth:",  *(unsigned __int16 *)(a1 + 128));
  }
  if ((objc_opt_respondsToSelector(v4, "maxTotalThreadsPerThreadgroup") & 1) != 0) {
    -[MTLTileRenderPipelineDescriptor setMaxTotalThreadsPerThreadgroup:]( v4,  "setMaxTotalThreadsPerThreadgroup:",  *(unsigned __int16 *)(a1 + 132));
  }
  if ((objc_opt_respondsToSelector(v4, "colorSampleCount") & 1) != 0) {
    -[MTLTileRenderPipelineDescriptor setColorSampleCount:](v4, "setColorSampleCount:", *(unsigned __int8 *)(a1 + 167));
  }

  return v4;
}

MTLCommandQueueDescriptor *MakeMTLCommandQueueDescriptor(unsigned int *a1)
{
  id v2 = objc_alloc_init(&OBJC_CLASS___MTLCommandQueueDescriptor);
  -[MTLCommandQueueDescriptor setMaxCommandBufferCount:](v2, "setMaxCommandBufferCount:", *a1);
  if ((objc_opt_respondsToSelector(v2, "qosLevel") & 1) != 0) {
    -[MTLCommandQueueDescriptor setQosLevel:](v2, "setQosLevel:", *((unsigned __int8 *)a1 + 8));
  }
  if ((objc_opt_respondsToSelector(v2, "commitSynchronously") & 1) != 0) {
    -[MTLCommandQueueDescriptor setCommitSynchronously:](v2, "setCommitSynchronously:", *((_BYTE *)a1 + 4) != 0);
  }
  if ((objc_opt_respondsToSelector(v2, "isOpenGLQueue") & 1) != 0) {
    -[MTLCommandQueueDescriptor setIsOpenGLQueue:](v2, "setIsOpenGLQueue:", *((_BYTE *)a1 + 7) != 0);
  }
  if ((objc_opt_respondsToSelector(v2, "disableCrossQueueHazardTracking") & 1) != 0) {
    -[MTLCommandQueueDescriptor setDisableCrossQueueHazardTracking:]( v2,  "setDisableCrossQueueHazardTracking:",  *((_BYTE *)a1 + 6) != 0);
  }
  if ((objc_opt_respondsToSelector(v2, "commitsWithQoS") & 1) != 0) {
    -[MTLCommandQueueDescriptor setCommitsWithQoS:](v2, "setCommitsWithQoS:", *((_BYTE *)a1 + 5) != 0);
  }
  return v2;
}

MTLIOCommandQueueDescriptor *MakeMTLIOCommandQueueDescriptor(unsigned int *a1)
{
  id v2 = objc_alloc_init(&OBJC_CLASS___MTLIOCommandQueueDescriptor);
  -[MTLIOCommandQueueDescriptor setMaxCommandBufferCount:](v2, "setMaxCommandBufferCount:", *a1);
  -[MTLIOCommandQueueDescriptor setPriority:](v2, "setPriority:", *((unsigned __int8 *)a1 + 4));
  -[MTLIOCommandQueueDescriptor setType:](v2, "setType:", *((unsigned __int8 *)a1 + 5));
  return v2;
}

MTLVisibleFunctionTableDescriptor *MakeMTLVisibleFunctionTableDescriptorWithoutResourceIndex(void *a1)
{
  id v2 = objc_alloc_init(&OBJC_CLASS___MTLVisibleFunctionTableDescriptor);
  -[MTLVisibleFunctionTableDescriptor setFunctionCount:](v2, "setFunctionCount:", *a1);
  return v2;
}

MTLVisibleFunctionTableDescriptor *MakeMTLVisibleFunctionTableDescriptorWithResourceIndex(void *a1)
{
  id v2 = objc_alloc_init(&OBJC_CLASS___MTLVisibleFunctionTableDescriptor);
  -[MTLVisibleFunctionTableDescriptor setFunctionCount:](v2, "setFunctionCount:", *a1);
  -[MTLVisibleFunctionTableDescriptor setForceResourceIndex:](v2, "setForceResourceIndex:", a1[1] != 0LL);
  -[MTLVisibleFunctionTableDescriptor setResourceIndex:](v2, "setResourceIndex:", a1[1]);
  return v2;
}

MTLBlitPassDescriptor *MakeMTLBlitPassDescriptor(uint64_t a1, void *a2)
{
  id v3 = a2;
  double v4 = objc_alloc_init(&OBJC_CLASS___MTLBlitPassDescriptor);
  uint64_t v5 = 0LL;
  id v6 = (uint64_t *)(a1 + 8);
  do
  {
    if (*v6)
    {
      id v7 = (void *)objc_claimAutoreleasedReturnValue(-[MTLBlitPassDescriptor sampleBufferAttachments](v4, "sampleBufferAttachments"));
      id v8 = (id)objc_claimAutoreleasedReturnValue([v7 objectAtIndexedSubscript:v5]);
      uint64_t v9 = *v6;
      id v10 = v3;
      uint64_t v11 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLongLong:](&OBJC_CLASS___NSNumber, "numberWithUnsignedLongLong:", v9));
      id v12 = (void *)objc_claimAutoreleasedReturnValue([v10 objectForKeyedSubscript:v11]);

      [v8 setSampleBuffer:v12];
      [v8 setStartOfEncoderSampleIndex:v6[1]];
      [v8 setEndOfEncoderSampleIndex:*(v6 - 1)];
    }

    ++v5;
    v6 += 3;
  }

  while (v5 != 4);

  return v4;
}

MTLComputePassDescriptor *MakeMTLComputePassDescriptor(uint64_t a1, void *a2)
{
  id v3 = a2;
  double v4 = objc_alloc_init(&OBJC_CLASS___MTLComputePassDescriptor);
  -[MTLComputePassDescriptor setDispatchType:](v4, "setDispatchType:", *(unsigned __int8 *)(a1 + 96));
  uint64_t v5 = 0LL;
  id v6 = (uint64_t *)(a1 + 8);
  do
  {
    if (*v6)
    {
      id v7 = (void *)objc_claimAutoreleasedReturnValue(-[MTLComputePassDescriptor sampleBufferAttachments](v4, "sampleBufferAttachments"));
      id v8 = (id)objc_claimAutoreleasedReturnValue([v7 objectAtIndexedSubscript:v5]);
      uint64_t v9 = *v6;
      id v10 = v3;
      uint64_t v11 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLongLong:](&OBJC_CLASS___NSNumber, "numberWithUnsignedLongLong:", v9));
      id v12 = (void *)objc_claimAutoreleasedReturnValue([v10 objectForKeyedSubscript:v11]);

      [v8 setSampleBuffer:v12];
      [v8 setStartOfEncoderSampleIndex:v6[1]];
      [v8 setEndOfEncoderSampleIndex:*(v6 - 1)];
    }

    ++v5;
    v6 += 3;
  }

  while (v5 != 4);

  return v4;
}

MTLResourceStatePassDescriptor *MakeMTLResourceStatePassDescriptor(uint64_t a1, void *a2)
{
  id v3 = a2;
  double v4 = objc_alloc_init(&OBJC_CLASS___MTLResourceStatePassDescriptor);
  uint64_t v5 = 0LL;
  id v6 = (uint64_t *)(a1 + 8);
  do
  {
    if (*v6)
    {
      id v7 = (void *)objc_claimAutoreleasedReturnValue(-[MTLResourceStatePassDescriptor sampleBufferAttachments](v4, "sampleBufferAttachments"));
      id v8 = (id)objc_claimAutoreleasedReturnValue([v7 objectAtIndexedSubscript:v5]);
      uint64_t v9 = *v6;
      id v10 = v3;
      uint64_t v11 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLongLong:](&OBJC_CLASS___NSNumber, "numberWithUnsignedLongLong:", v9));
      id v12 = (void *)objc_claimAutoreleasedReturnValue([v10 objectForKeyedSubscript:v11]);

      [v8 setSampleBuffer:v12];
      [v8 setStartOfEncoderSampleIndex:v6[1]];
      [v8 setEndOfEncoderSampleIndex:*(v6 - 1)];
    }

    ++v5;
    v6 += 3;
  }

  while (v5 != 4);

  return v4;
}

MTLAccelerationStructurePassDescriptor *MakeMTLAccelerationStructurePassDescriptor(uint64_t a1, void *a2)
{
  id v3 = a2;
  double v4 = objc_alloc_init(&OBJC_CLASS___MTLAccelerationStructurePassDescriptor);
  uint64_t v5 = 0LL;
  id v6 = (uint64_t *)(a1 + 8);
  do
  {
    if (*v6)
    {
      id v7 = (void *)objc_claimAutoreleasedReturnValue(-[MTLAccelerationStructurePassDescriptor sampleBufferAttachments](v4, "sampleBufferAttachments"));
      id v8 = (id)objc_claimAutoreleasedReturnValue([v7 objectAtIndexedSubscript:v5]);
      uint64_t v9 = *v6;
      id v10 = v3;
      uint64_t v11 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLongLong:](&OBJC_CLASS___NSNumber, "numberWithUnsignedLongLong:", v9));
      id v12 = (void *)objc_claimAutoreleasedReturnValue([v10 objectForKeyedSubscript:v11]);

      [v8 setSampleBuffer:v12];
      [v8 setStartOfEncoderSampleIndex:v6[1]];
      [v8 setEndOfEncoderSampleIndex:*(v6 - 1)];
    }

    ++v5;
    v6 += 3;
  }

  while (v5 != 4);

  return v4;
}

MTLIntersectionFunctionTableDescriptor *MakeMTLIntersectionFunctionTableDescriptorWithoutResourceIndex( uint64_t a1)
{
  id v2 = objc_alloc_init(&OBJC_CLASS___MTLIntersectionFunctionTableDescriptor);
  -[MTLIntersectionFunctionTableDescriptor setFunctionCount:](v2, "setFunctionCount:", *(unsigned int *)(a1 + 8));
  return v2;
}

MTLIntersectionFunctionTableDescriptor *MakeMTLIntersectionFunctionTableDescriptorWithResourceIndex( uint64_t a1)
{
  id v2 = objc_alloc_init(&OBJC_CLASS___MTLIntersectionFunctionTableDescriptor);
  -[MTLIntersectionFunctionTableDescriptor setFunctionCount:](v2, "setFunctionCount:", *(unsigned int *)(a1 + 8));
  -[MTLIntersectionFunctionTableDescriptor setForceResourceIndex:](v2, "setForceResourceIndex:", *(void *)a1 != 0LL);
  -[MTLIntersectionFunctionTableDescriptor setResourceIndex:](v2, "setResourceIndex:", *(void *)a1);
  return v2;
}

MTLRenderPipelineFunctionsDescriptor *MakeMTLRenderPipelineFunctionsDescriptor(uint64_t a1, void *a2)
{
  id v3 = a2;
  double v4 = objc_alloc_init(&OBJC_CLASS___MTLRenderPipelineFunctionsDescriptor);
  uint64_t v5 = *(void *)(a1 + 72);
  if (v5)
  {
    id ObjectArrayWithMap = CreateObjectArrayWithMap(*(uint64_t **)(a1 + 64), v5, v3);
    id v7 = (void *)objc_claimAutoreleasedReturnValue(ObjectArrayWithMap);
    -[MTLRenderPipelineFunctionsDescriptor setVertexAdditionalBinaryFunctions:]( v4,  "setVertexAdditionalBinaryFunctions:",  v7);
  }

  uint64_t v8 = *(void *)(a1 + 8);
  if (v8)
  {
    id v9 = CreateObjectArrayWithMap(*(uint64_t **)a1, v8, v3);
    id v10 = (void *)objc_claimAutoreleasedReturnValue(v9);
    -[MTLRenderPipelineFunctionsDescriptor setFragmentAdditionalBinaryFunctions:]( v4,  "setFragmentAdditionalBinaryFunctions:",  v10);
  }

  uint64_t v11 = *(void *)(a1 + 56);
  if (v11)
  {
    id v12 = CreateObjectArrayWithMap(*(uint64_t **)(a1 + 48), v11, v3);
    unsigned int v13 = (void *)objc_claimAutoreleasedReturnValue(v12);
    -[MTLRenderPipelineFunctionsDescriptor setTileAdditionalBinaryFunctions:]( v4,  "setTileAdditionalBinaryFunctions:",  v13);
  }

  uint64_t v14 = *(void *)(a1 + 24);
  if (v14)
  {
    id v15 = CreateObjectArrayWithMap(*(uint64_t **)(a1 + 16), v14, v3);
    uint64_t v16 = (void *)objc_claimAutoreleasedReturnValue(v15);
    -[MTLRenderPipelineFunctionsDescriptor setMeshAdditionalBinaryFunctions:]( v4,  "setMeshAdditionalBinaryFunctions:",  v16);
  }

  uint64_t v17 = *(void *)(a1 + 40);
  if (v17)
  {
    id v18 = CreateObjectArrayWithMap(*(uint64_t **)(a1 + 32), v17, v3);
    unint64_t v19 = (void *)objc_claimAutoreleasedReturnValue(v18);
    -[MTLRenderPipelineFunctionsDescriptor setObjectAdditionalBinaryFunctions:]( v4,  "setObjectAdditionalBinaryFunctions:",  v19);
  }

  return v4;
}

id MakeMTLResidencySetDescriptor(uint64_t a1)
{
  id v2 = objc_alloc_init(&OBJC_CLASS___MTLResidencySetDescriptor);
  [v2 setEvictsImmediately:*(_BYTE *)(a1 + 16) != 0];
  if ((objc_opt_respondsToSelector(v2, "initialCapacity") & 1) != 0) {
    [v2 setInitialCapacity:*(void *)a1];
  }
  if (*(void *)(a1 + 8))
  {
    id v3 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:"));
    [v2 setLabel:v3];
  }

  return v2;
}

MTLTextureDescriptor *MakeMTLTextureDescriptorFromTextureWithoutResourceIndex(void *a1)
{
  id v1 = a1;
  id v2 = objc_alloc_init(&OBJC_CLASS___MTLTextureDescriptor);
  -[MTLTextureDescriptor setTextureType:](v2, "setTextureType:", [v1 textureType]);
  -[MTLTextureDescriptor setPixelFormat:](v2, "setPixelFormat:", [v1 pixelFormat]);
  -[MTLTextureDescriptor setUsage:](v2, "setUsage:", [v1 usage]);
  -[MTLTextureDescriptor setWidth:](v2, "setWidth:", [v1 width]);
  -[MTLTextureDescriptor setHeight:](v2, "setHeight:", [v1 height]);
  -[MTLTextureDescriptor setDepth:](v2, "setDepth:", [v1 depth]);
  -[MTLTextureDescriptor setArrayLength:](v2, "setArrayLength:", [v1 arrayLength]);
  -[MTLTextureDescriptor setStorageMode:](v2, "setStorageMode:", [v1 storageMode]);
  -[MTLTextureDescriptor setSampleCount:](v2, "setSampleCount:", [v1 sampleCount]);
  -[MTLTextureDescriptor setCpuCacheMode:](v2, "setCpuCacheMode:", [v1 cpuCacheMode]);
  -[MTLTextureDescriptor setMipmapLevelCount:](v2, "setMipmapLevelCount:", [v1 mipmapLevelCount]);
  if ((objc_opt_respondsToSelector(v2, "hazardTrackingMode") & 1) != 0) {
    -[MTLTextureDescriptor setHazardTrackingMode:](v2, "setHazardTrackingMode:", [v1 hazardTrackingMode]);
  }
  if ((objc_opt_respondsToSelector(v2, "allowGPUOptimizedContents") & 1) != 0) {
    -[MTLTextureDescriptor setAllowGPUOptimizedContents:]( v2,  "setAllowGPUOptimizedContents:",  [v1 allowGPUOptimizedContents]);
  }
  if ((objc_opt_respondsToSelector(v2, "swizzle") & 1) != 0) {
    -[MTLTextureDescriptor setSwizzle:](v2, "setSwizzle:", [v1 swizzle]);
  }
  if ((objc_opt_respondsToSelector(v2, "swizzleKey") & 1) != 0
    && (objc_opt_respondsToSelector(v1, "swizzleKey") & 1) != 0)
  {
    -[MTLTextureDescriptor setSwizzleKey:](v2, "setSwizzleKey:", [v1 swizzleKey]);
  }

  if ((objc_opt_respondsToSelector(v2, "rotation") & 1) != 0 && (objc_opt_respondsToSelector(v1, "rotation") & 1) != 0) {
    -[MTLTextureDescriptor setRotation:](v2, "setRotation:", [v1 rotation]);
  }
  if ((objc_opt_respondsToSelector(v2, "sparseSurfaceDefaultValue") & 1) != 0
    && (objc_opt_respondsToSelector(v1, "sparseSurfaceDefaultValue") & 1) != 0)
  {
    -[MTLTextureDescriptor setSparseSurfaceDefaultValue:]( v2,  "setSparseSurfaceDefaultValue:",  [v1 sparseSurfaceDefaultValue]);
  }

  if ((objc_opt_respondsToSelector(v2, "compressionType") & 1) != 0
    && (objc_opt_respondsToSelector(v1, "compressionType") & 1) != 0)
  {
    -[MTLTextureDescriptor setCompressionType:](v2, "setCompressionType:", [v1 compressionType]);
  }

  if ((objc_opt_respondsToSelector(v2, "compressionFootprint") & 1) != 0
    && (objc_opt_respondsToSelector(v1, "compressionFootprint") & 1) != 0)
  {
    -[MTLTextureDescriptor setCompressionFootprint:]( v2,  "setCompressionFootprint:",  [v1 compressionFootprint]);
  }

  return v2;
}

void MakeGTMTLSamplerDescriptor(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = objc_claimAutoreleasedReturnValue([v3 label]);
  uint64_t v5 = (const char *)[v4 UTF8String];

  if (v5) {
    strlen(v5);
  }
  __chkstk_darwin();
  id v7 = (char *)&v19 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  id v8 = v3;
  *(_OWORD *)a1 = GTMTLSamplerDescriptorDefaults;
  *(_OWORD *)(a1 + 16) = unk_317BD8;
  *(_OWORD *)(a1 + 32) = xmmword_317BE8;
  *(_OWORD *)(a1 + 4_Block_object_dispose((const void *)(v35 - 176), 8) = unk_317BF8;
  id v9 = v8;
  id v10 = objc_claimAutoreleasedReturnValue([v9 label]);
  uint64_t v11 = (const char *)[v10 UTF8String];
  id v12 = v11;
  if (!v11 || (size_t v13 = strlen(v11), v14 = v13 + 1, v13 == -1LL))
  {
    size_t v14 = 0LL;
    id v7 = 0LL;
  }

  memcpy(v7, v12, v14);

  *(_BYTE *)(a1 + 56) = [v9 minFilter];
  *(_BYTE *)(a1 + 55) = [v9 magFilter];
  *(_BYTE *)(a1 + 57) = [v9 mipFilter];
  *(void *)(a1 + _Block_object_dispose((const void *)(v35 - 176), 8) = [v9 maxAnisotropy];
  *(_BYTE *)(a1 + 61) = [v9 sAddressMode];
  *(_BYTE *)(a1 + 63) = [v9 tAddressMode];
  *(_BYTE *)(a1 + 59) = [v9 rAddressMode];
  *(_BYTE *)(a1 + 5_Block_object_dispose((const void *)(v35 - 176), 8) = [v9 normalizedCoordinates];
  [v9 lodMinClamp];
  *(_DWORD *)(a1 + 44) = v15;
  [v9 lodMaxClamp];
  *(_DWORD *)(a1 + 40) = v16;
  *(void *)a1 = v7;
  *(_BYTE *)(a1 + 54) = [v9 lodAverage];
  *(_BYTE *)(a1 + 51) = [v9 compareFunction];
  *(_BYTE *)(a1 + 50) = [v9 borderColor];
  *(_BYTE *)(a1 + 62) = [v9 supportArgumentBuffers];
  if ((objc_opt_respondsToSelector(v9, "resourceIndex") & 1) != 0) {
    *(void *)(a1 + 16) = [v9 resourceIndex];
  }
  *(_BYTE *)(a1 + 52) = [v9 forceResourceIndex];
  if ((objc_opt_respondsToSelector(v9, "customBorderColorValue_0") & 1) != 0) {
    *(_DWORD *)(a1 + 24) = [v9 customBorderColorValue];
  }
  if ((objc_opt_respondsToSelector(v9, "customBorderColorValue_1") & 1) != 0) {
    *(_DWORD *)(a1 + 2_Block_object_dispose((const void *)(v35 - 176), 8) = [v9 customBorderColorValue];
  }
  if ((objc_opt_respondsToSelector(v9, "customBorderColorValue_2") & 1) != 0) {
    *(_DWORD *)(a1 + 32) = [v9 customBorderColorValue];
  }
  if ((objc_opt_respondsToSelector(v9, "customBorderColorValue_3") & 1) != 0) {
    *(_DWORD *)(a1 + 36) = [v9 customBorderColorValue];
  }
  if ((objc_opt_respondsToSelector(v9, "forceSeamsOnCubemapFiltering") & 1) != 0) {
    *(_BYTE *)(a1 + 53) = [v9 forceSeamsOnCubemapFiltering];
  }
  if ((objc_opt_respondsToSelector(v9, "pixelFormat") & 1) != 0) {
    *(_WORD *)(a1 + 4_Block_object_dispose((const void *)(v35 - 176), 8) = (unsigned __int16)[v9 pixelFormat];
  }

  uint64_t v17 = (void *)objc_claimAutoreleasedReturnValue([v9 label]);
  id v18 = v17;
  *(void *)a1 = [v18 UTF8String];
}

MTLRenderPassDescriptor *MakeMTLRenderPassDescriptor(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = objc_alloc_init(&OBJC_CLASS___MTLRenderPassDescriptor);
  uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  *(void *)(a1 + 792)));
  uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue([v3 objectForKeyedSubscript:v5]);
  -[MTLRenderPassDescriptor setVisibilityResultBuffer:](v4, "setVisibilityResultBuffer:", v6);

  uint64_t v7 = 0LL;
  uint64_t v8 = a1;
  do
  {
    if (*(void *)(v8 + 8))
    {
      id v9 = (void *)objc_claimAutoreleasedReturnValue(-[MTLRenderPassDescriptor colorAttachments](v4, "colorAttachments"));
      id v10 = (id)objc_claimAutoreleasedReturnValue([v9 objectAtIndexedSubscript:v7]);
      objc_msgSend( MakeMTLRenderPassAttachmentDescriptor(v10, v8, v3),  "setClearColor:",  *(double *)(v8 + 32),  *(double *)(v8 + 40),  *(double *)(v8 + 48),  *(double *)(v8 + 56));
    }

    v8 += 64LL;
    ++v7;
  }

  while (v7 != 8);
  id v11 = (id)objc_claimAutoreleasedReturnValue(-[MTLRenderPassDescriptor depthAttachment](v4, "depthAttachment"));
  objc_msgSend( MakeMTLRenderPassAttachmentDescriptor(v11, a1 + 672, v3),  "setClearDepth:",  *(double *)(a1 + 704));
  [v11 setDepthResolveFilter:*(unsigned __int8 *)(a1 + 712)];

  id v12 = (id)objc_claimAutoreleasedReturnValue(-[MTLRenderPassDescriptor stencilAttachment](v4, "stencilAttachment"));
  objc_msgSend( MakeMTLRenderPassAttachmentDescriptor(v12, a1 + 720, v3),  "setClearStencil:",  *(unsigned int *)(a1 + 752));
  if ((objc_opt_respondsToSelector(v12, "stencilResolveFilter") & 1) != 0) {
    [v12 setStencilResolveFilter:*(unsigned __int8 *)(a1 + 756)];
  }

  -[MTLRenderPassDescriptor setRenderTargetArrayLength:]( v4,  "setRenderTargetArrayLength:",  *(unsigned __int16 *)(a1 + 806));
  if ((objc_opt_respondsToSelector(v4, "imageblockSampleLength") & 1) != 0) {
    -[MTLRenderPassDescriptor setImageblockSampleLength:]( v4,  "setImageblockSampleLength:",  *(unsigned __int16 *)(a1 + 804));
  }
  if ((objc_opt_respondsToSelector(v4, "threadgroupMemoryLength") & 1) != 0) {
    -[MTLRenderPassDescriptor setThreadgroupMemoryLength:]( v4,  "setThreadgroupMemoryLength:",  *(unsigned int *)(a1 + 800));
  }
  if ((objc_opt_respondsToSelector(v4, "tileWidth") & 1) != 0) {
    -[MTLRenderPassDescriptor setTileWidth:](v4, "setTileWidth:", *(unsigned __int16 *)(a1 + 814));
  }
  if ((objc_opt_respondsToSelector(v4, "tileHeight") & 1) != 0) {
    -[MTLRenderPassDescriptor setTileHeight:](v4, "setTileHeight:", *(unsigned __int16 *)(a1 + 812));
  }
  if ((objc_opt_respondsToSelector(v4, "renderTargetWidth") & 1) != 0) {
    -[MTLRenderPassDescriptor setRenderTargetWidth:](v4, "setRenderTargetWidth:", *(unsigned __int16 *)(a1 + 810));
  }
  if ((objc_opt_respondsToSelector(v4, "renderTargetHeight") & 1) != 0) {
    -[MTLRenderPassDescriptor setRenderTargetHeight:](v4, "setRenderTargetHeight:", *(unsigned __int16 *)(a1 + 808));
  }
  if ((objc_opt_respondsToSelector(v4, "defaultRasterSampleCount") & 1) != 0) {
    -[MTLRenderPassDescriptor setDefaultRasterSampleCount:]( v4,  "setDefaultRasterSampleCount:",  *(unsigned __int8 *)(a1 + 816));
  }
  if ((objc_opt_respondsToSelector(v4, "openGLModeEnabled") & 1) != 0) {
    -[MTLRenderPassDescriptor setOpenGLModeEnabled:](v4, "setOpenGLModeEnabled:", *(_BYTE *)(a1 + 818) != 0);
  }
  size_t v13 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  *(void *)(a1 + 784)));
  size_t v14 = (void *)objc_claimAutoreleasedReturnValue([v3 objectForKeyedSubscript:v13]);
  -[MTLRenderPassDescriptor setRasterizationRateMap:](v4, "setRasterizationRateMap:", v14);

  if ((objc_opt_respondsToSelector(v4, "ditherEnabled") & 1) != 0) {
    -[MTLRenderPassDescriptor setDitherEnabled:](v4, "setDitherEnabled:", *(_BYTE *)(a1 + 817) != 0);
  }
  if ((objc_opt_respondsToSelector(v4, "defaultColorSampleCount") & 1) != 0) {
    -[MTLRenderPassDescriptor setDefaultColorSampleCount:](v4, "setDefaultColorSampleCount:", *(void *)(a1 + 776));
  }
  uint64_t v15 = 0LL;
  int v16 = (void *)(a1 + 544);
  do
  {
    if (*(v16 - 2))
    {
      uint64_t v17 = (void *)objc_claimAutoreleasedReturnValue(-[MTLRenderPassDescriptor sampleBufferAttachments](v4, "sampleBufferAttachments"));
      id v18 = (id)objc_claimAutoreleasedReturnValue([v17 objectAtIndexedSubscript:v15]);
      uint64_t v19 = *(v16 - 2);
      id v20 = v3;
      id v21 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  v19));
      uint64_t v22 = (void *)objc_claimAutoreleasedReturnValue([v20 objectForKeyedSubscript:v21]);

      [v18 setSampleBuffer:v22];
      [v18 setStartOfVertexSampleIndex:*v16];
      [v18 setEndOfVertexSampleIndex:*(v16 - 3)];
      [v18 setStartOfFragmentSampleIndex:*(v16 - 1)];
      [v18 setEndOfFragmentSampleIndex:*(v16 - 4)];
    }

    ++v15;
    v16 += 5;
  }

  while (v15 != 4);
  if ((objc_opt_respondsToSelector(v4, "skipEmptyTilesOnClearEnabled") & 1) != 0) {
    -[MTLRenderPassDescriptor setSkipEmptyTilesOnClearEnabled:]( v4,  "setSkipEmptyTilesOnClearEnabled:",  *(_BYTE *)(a1 + 820) != 0);
  }

  -[MTLRenderPassDescriptor setSamplePositions:count:]( v4,  "setSamplePositions:count:",  *(void *)(a1 + 760),  *(void *)(a1 + 768));
  return v4;
}

id MakeMTLRasterizationRateMapDescriptor(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 16);
  uint64_t v3 = 8 * v2;
  __chkstk_darwin();
  id v4 = (char *)v22 - ((8 * v2 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  bzero(v4, 8 * v2);
  if (*(void *)(a1 + 16))
  {
    v22[1] = v22;
    uint64_t v5 = 0LL;
    unint64_t v6 = 0LL;
    do
    {
      uint64_t v7 = (unsigned __int16 *)(*(void *)(a1 + 8) + v5);
      uint64_t v8 = v7[8];
      uint64_t v9 = v7[10];
      uint64_t v10 = v7[9];
      id v11 = objc_alloc(&OBJC_CLASS___MTLRasterizationRateLayerDescriptor);
      uint64_t v23 = v8;
      uint64_t v24 = v9;
      uint64_t v25 = v10;
      id v12 = -[MTLRasterizationRateLayerDescriptor initWithSampleCount:](v11, "initWithSampleCount:", &v23);
      size_t v13 = *(void **)&v4[8 * v6];
      *(void *)&v4[8 * v6] = v12;

      memcpy( -[MTLRasterizationRateLayerDescriptor horizontalSampleStorage](v12, "horizontalSampleStorage"),  *(const void **)(*(void *)(a1 + 8) + v5),  4 * v8);
      memcpy( -[MTLRasterizationRateLayerDescriptor verticalSampleStorage](v12, "verticalSampleStorage"),  *(const void **)(*(void *)(a1 + 8) + v5 + 8),  4 * v9);
      ++v6;
      unint64_t v14 = *(void *)(a1 + 16);
      v5 += 24LL;
    }

    while (v6 < v14);
  }

  else
  {
    unint64_t v14 = 0LL;
  }

  uint64_t v15 = *(unsigned __int16 *)(a1 + 30);
  uint64_t v16 = *(unsigned __int16 *)(a1 + 28);
  uint64_t v23 = *(unsigned __int16 *)(a1 + 32);
  uint64_t v24 = v15;
  uint64_t v25 = v16;
  uint64_t v17 = (void *)objc_claimAutoreleasedReturnValue( +[MTLRasterizationRateMapDescriptor rasterizationRateMapDescriptorWithScreenSize:layerCount:layers:]( &OBJC_CLASS___MTLRasterizationRateMapDescriptor,  "rasterizationRateMapDescriptorWithScreenSize:layerCount:layers:",  &v23,  v14,  (char *)v22 - ((v3 + 15) & 0xFFFFFFFFFFFFFFF0LL)));
  if (*(void *)a1)
  {
    id v18 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:"));
    [v17 setLabel:v18];
  }

  if ((objc_opt_respondsToSelector(v17, "mutability") & 1) != 0) {
    [v17 setMutability:*(unsigned __int8 *)(a1 + 34)];
  }
  if ((objc_opt_respondsToSelector(v17, "minFactor") & 1) != 0)
  {
    LODWORD(v19) = *(_DWORD *)(a1 + 24);
    [v17 setMinFactor:v19];
  }

  if ((objc_opt_respondsToSelector(v17, "skipSampleValidationAndApplySampleAtTileGranularity") & 1) != 0) {
    [v17 setSkipSampleValidationAndApplySampleAtTileGranularity:*(_BYTE *)(a1 + 35) != 0];
  }
  if (v2)
  {
    id v20 = v4 - 8;
    do
    {

      v3 -= 8LL;
    }

    while (v3);
  }

  return v17;
}

MTLCounterSampleBufferDescriptor *MakeMTLCounterSampleBufferDescriptor(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = objc_alloc_init(&OBJC_CLASS___MTLCounterSampleBufferDescriptor);
  uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", *(void *)(a1 + 8)));
  __int128 v17 = 0u;
  __int128 v18 = 0u;
  __int128 v19 = 0u;
  __int128 v20 = 0u;
  uint64_t v16 = v3;
  unint64_t v6 = (void *)objc_claimAutoreleasedReturnValue([v3 counterSets]);
  id v7 = [v6 countByEnumeratingWithState:&v17 objects:v21 count:16];
  if (v7)
  {
    id v8 = v7;
    uint64_t v9 = *(void *)v18;
    while (2)
    {
      for (uint64_t i = 0LL; i != v8; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v18 != v9) {
          objc_enumerationMutation(v6);
        }
        id v11 = *(void **)(*((void *)&v17 + 1) + 8LL * (void)i);
        id v12 = (void *)objc_claimAutoreleasedReturnValue([v11 name]);
        unsigned int v13 = [v5 isEqualToString:v12];

        if (v13)
        {
          -[MTLCounterSampleBufferDescriptor setCounterSet:](v4, "setCounterSet:", v11);
          goto LABEL_11;
        }
      }

      id v8 = [v6 countByEnumeratingWithState:&v17 objects:v21 count:16];
      if (v8) {
        continue;
      }
      break;
    }
  }

MTLCompileOptions *MakeMTLCompileOptions(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = objc_alloc_init(&OBJC_CLASS___MTLCompileOptions);
  id Dictionary = GTData_MakeDictionary(*(void *)a1, *(void *)(a1 + 8));
  unint64_t v6 = (void *)objc_claimAutoreleasedReturnValue(Dictionary);
  -[MTLCompileOptions setPreprocessorMacros:](v4, "setPreprocessorMacros:", v6);

  -[MTLCompileOptions setDebuggingEnabled:](v4, "setDebuggingEnabled:", *(_BYTE *)(a1 + 56) != 0);
  -[MTLCompileOptions setLanguageVersion:](v4, "setLanguageVersion:", *(unsigned int *)(a1 + 48));
  if (*(void *)(a1 + 16))
  {
    id v7 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:"));
    -[MTLCompileOptions setAdditionalCompilerArguments:](v4, "setAdditionalCompilerArguments:", v7);
  }

  if ((objc_opt_respondsToSelector(v4, "preserveInvariance") & 1) != 0) {
    -[MTLCompileOptions setPreserveInvariance:](v4, "setPreserveInvariance:", *(_BYTE *)(a1 + 62) != 0);
  }
  if (*(void *)(a1 + 24))
  {
    id v8 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:"));
    -[MTLCompileOptions setInstallName:](v4, "setInstallName:", v8);
  }

  if ((objc_opt_respondsToSelector(v4, "libraryType") & 1) != 0) {
    -[MTLCompileOptions setLibraryType:](v4, "setLibraryType:", *(unsigned __int8 *)(a1 + 58));
  }
  uint64_t v9 = *(void *)(a1 + 40);
  if (v9)
  {
    id ObjectArrayWithMap = CreateObjectArrayWithMap(*(uint64_t **)(a1 + 32), v9, v3);
    id v11 = (void *)objc_claimAutoreleasedReturnValue(ObjectArrayWithMap);
    -[MTLCompileOptions setLibraries:](v4, "setLibraries:", v11);
  }

  if ((objc_opt_respondsToSelector(v4, "sourceLanguage") & 1) != 0) {
    -[MTLCompileOptions setSourceLanguage:](v4, "setSourceLanguage:", *(unsigned __int8 *)(a1 + 63));
  }
  if ((objc_opt_respondsToSelector(v4, "optimizationLevel") & 1) != 0) {
    -[MTLCompileOptions setOptimizationLevel:](v4, "setOptimizationLevel:", *(unsigned __int8 *)(a1 + 61));
  }
  if ((objc_opt_respondsToSelector(v4, "compileSymbolVisibility") & 1) != 0) {
    -[MTLCompileOptions setCompileSymbolVisibility:](v4, "setCompileSymbolVisibility:", *(unsigned __int8 *)(a1 + 55));
  }
  if ((objc_opt_respondsToSelector(v4, "allowReferencingUndefinedSymbols") & 1) != 0) {
    -[MTLCompileOptions setAllowReferencingUndefinedSymbols:]( v4,  "setAllowReferencingUndefinedSymbols:",  *(_BYTE *)(a1 + 54) != 0);
  }
  if ((objc_opt_respondsToSelector(v4, "maxTotalThreadsPerThreadgroup") & 1) != 0) {
    -[MTLCompileOptions setMaxTotalThreadsPerThreadgroup:]( v4,  "setMaxTotalThreadsPerThreadgroup:",  *(unsigned __int16 *)(a1 + 52));
  }
  if ((objc_opt_respondsToSelector(v4, "mathFloatingPointFunctions") & 1) != 0) {
    -[MTLCompileOptions setMathFloatingPointFunctions:]( v4,  "setMathFloatingPointFunctions:",  *(unsigned __int8 *)(a1 + 59));
  }
  if ((objc_opt_respondsToSelector(v4, "mathMode") & 1) != 0) {
    -[MTLCompileOptions setMathMode:](v4, "setMathMode:", *(unsigned __int8 *)(a1 + 60));
  }

  return v4;
}

MTLFunctionConstantValues *MakeMTLFunctionConstantValues(void *a1)
{
  uint64_t v2 = objc_alloc_init(&OBJC_CLASS___MTLFunctionConstantValues);
  unint64_t v3 = a1[1];
  if (v3)
  {
    uint64_t v4 = 0LL;
    for (unint64_t i = 0LL; i < v3; ++i)
    {
      uint64_t v6 = *(void *)(*a1 + v4);
      if (v6)
      {
        -[MTLFunctionConstantValues setConstantValue:type:atIndex:]( v2,  "setConstantValue:type:atIndex:",  v6,  *(unsigned __int8 *)(*a1 + v4 + 27),  *(unsigned __int16 *)(*a1 + v4 + 24));
        unint64_t v3 = a1[1];
      }

      v4 += 32LL;
    }
  }

  return v2;
}

MTLFunctionDescriptor *MakeMTLFunctionDescriptor(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = objc_alloc_init(&OBJC_CLASS___MTLFunctionDescriptor);
  -[MTLFunctionDescriptor setOptions:](v4, "setOptions:", *(unsigned __int8 *)(a1 + 40));
  if (*(void *)(a1 + 8))
  {
    uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:"));
    -[MTLFunctionDescriptor setName:](v4, "setName:", v5);
  }

  if (*(void *)(a1 + 32))
  {
    uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:"));
    -[MTLFunctionDescriptor setSpecializedName:](v4, "setSpecializedName:", v6);
  }

  if (*(void *)a1)
  {
    MTLFunctionConstantValues = MakeMTLFunctionConstantValues(*(void **)a1);
    id v8 = (void *)objc_claimAutoreleasedReturnValue(MTLFunctionConstantValues);
    -[MTLFunctionDescriptor setConstantValues:](v4, "setConstantValues:", v8);
  }

  if (*(void *)(a1 + 24) && (objc_opt_respondsToSelector(v4, "privateFunctions") & 1) != 0)
  {
    id ObjectArrayWithMap = CreateObjectArrayWithMap(*(uint64_t **)(a1 + 16), *(_DWORD *)(a1 + 24), v3);
    uint64_t v10 = (void *)objc_claimAutoreleasedReturnValue(ObjectArrayWithMap);
    -[MTLFunctionDescriptor setPrivateFunctions:](v4, "setPrivateFunctions:", v10);
  }

  return v4;
}

id MakeMTLAccelerationStructureDescriptor(unsigned __int8 *a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = v3;
  int v5 = *a1;
  switch(v5)
  {
    case 3:
      id v116 = objc_alloc_init(&OBJC_CLASS___MTLIndirectInstanceAccelerationStructureDescriptor);
      id v117 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  *((void *)a1 + 1)));
      id v118 = (void *)objc_claimAutoreleasedReturnValue([v4 objectForKeyedSubscript:v117]);
      -[MTLIndirectInstanceAccelerationStructureDescriptor setInstanceDescriptorBuffer:]( v116,  "setInstanceDescriptorBuffer:",  v118);

      -[MTLIndirectInstanceAccelerationStructureDescriptor setInstanceDescriptorBufferOffset:]( v116,  "setInstanceDescriptorBufferOffset:",  *((void *)a1 + 2));
      unsigned int v119 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  *((void *)a1 + 3)));
      uint64_t v120 = (void *)objc_claimAutoreleasedReturnValue([v4 objectForKeyedSubscript:v119]);
      -[MTLIndirectInstanceAccelerationStructureDescriptor setInstanceCountBuffer:]( v116,  "setInstanceCountBuffer:",  v120);

      -[MTLIndirectInstanceAccelerationStructureDescriptor setInstanceCountBufferOffset:]( v116,  "setInstanceCountBufferOffset:",  *((void *)a1 + 4));
      int v121 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  *((void *)a1 + 5)));
      unint64_t v122 = (void *)objc_claimAutoreleasedReturnValue([v4 objectForKeyedSubscript:v121]);
      -[MTLIndirectInstanceAccelerationStructureDescriptor setMotionTransformBuffer:]( v116,  "setMotionTransformBuffer:",  v122);

      -[MTLIndirectInstanceAccelerationStructureDescriptor setMotionTransformBufferOffset:]( v116,  "setMotionTransformBufferOffset:",  *((void *)a1 + 6));
      unsigned int v123 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  *((void *)a1 + 7)));
      unsigned int v124 = (void *)objc_claimAutoreleasedReturnValue([v4 objectForKeyedSubscript:v123]);
      -[MTLIndirectInstanceAccelerationStructureDescriptor setMotionTransformCountBuffer:]( v116,  "setMotionTransformCountBuffer:",  v124);

      id v101 = v116;
      -[MTLIndirectInstanceAccelerationStructureDescriptor setMotionTransformCountBufferOffset:]( v116,  "setMotionTransformCountBufferOffset:",  *((void *)a1 + 8));
      -[MTLIndirectInstanceAccelerationStructureDescriptor setMaxInstanceCount:]( v116,  "setMaxInstanceCount:",  *((unsigned int *)a1 + 20));
      -[MTLIndirectInstanceAccelerationStructureDescriptor setInstanceDescriptorStride:]( v116,  "setInstanceDescriptorStride:",  *((unsigned int *)a1 + 21));
      -[MTLIndirectInstanceAccelerationStructureDescriptor setMaxMotionTransformCount:]( v116,  "setMaxMotionTransformCount:",  *((unsigned int *)a1 + 22));
      -[MTLIndirectInstanceAccelerationStructureDescriptor setInstanceDescriptorType:]( v116,  "setInstanceDescriptorType:",  a1[92]);
      if ((objc_opt_respondsToSelector(v116, "motionTransformStride") & 1) != 0) {
        -[MTLIndirectInstanceAccelerationStructureDescriptor setMotionTransformStride:]( v116,  "setMotionTransformStride:",  *((void *)a1 + 9));
      }
      if ((objc_opt_respondsToSelector(v116, "motionTransformType") & 1) != 0) {
        -[MTLIndirectInstanceAccelerationStructureDescriptor setMotionTransformType:]( v116,  "setMotionTransformType:",  a1[93]);
      }
      if ((objc_opt_respondsToSelector(v116, "instanceTransformationMatrixLayout") & 1) != 0) {
        -[MTLIndirectInstanceAccelerationStructureDescriptor setInstanceTransformationMatrixLayout:]( v116,  "setInstanceTransformationMatrixLayout:",  a1[94]);
      }
      break;
    case 2:
      uint64_t v104 = a1[1];
      uint64_t v105 = objc_alloc_init(&OBJC_CLASS___MTLInstanceAccelerationStructureDescriptor);
      -[MTLInstanceAccelerationStructureDescriptor setUsage:](v105, "setUsage:", v104);
      uint64_t v106 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  *((void *)a1 + 2)));
      uint64_t v107 = (void *)objc_claimAutoreleasedReturnValue([v4 objectForKeyedSubscript:v106]);
      -[MTLInstanceAccelerationStructureDescriptor setInstanceDescriptorBuffer:]( v105,  "setInstanceDescriptorBuffer:",  v107);

      -[MTLInstanceAccelerationStructureDescriptor setInstanceDescriptorBufferOffset:]( v105,  "setInstanceDescriptorBufferOffset:",  *((void *)a1 + 4));
      -[MTLInstanceAccelerationStructureDescriptor setInstanceDescriptorStride:]( v105,  "setInstanceDescriptorStride:",  *((unsigned int *)a1 + 15));
      id v108 = v105;
      -[MTLInstanceAccelerationStructureDescriptor setInstanceCount:]( v105,  "setInstanceCount:",  *((unsigned int *)a1 + 16));
      id v109 = -[NSMutableArray initWithCapacity:]( objc_alloc(&OBJC_CLASS___NSMutableArray),  "initWithCapacity:",  *((unsigned int *)a1 + 14));
      if (*((_DWORD *)a1 + 14))
      {
        unint64_t v110 = 0LL;
        do
        {
          uint64_t v111 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  *(void *)(*((void *)a1 + 1) + 8 * v110)));
          id v112 = (void *)objc_claimAutoreleasedReturnValue([v4 objectForKeyedSubscript:v111]);
          -[NSMutableArray addObject:](v109, "addObject:", v112);

          ++v110;
        }

        while (v110 < *((unsigned int *)a1 + 14));
      }

      if (-[NSMutableArray count](v109, "count")) {
        id v113 = v109;
      }
      else {
        id v113 = 0LL;
      }
      -[MTLInstanceAccelerationStructureDescriptor setInstancedAccelerationStructures:]( v108,  "setInstancedAccelerationStructures:",  v113);
      -[MTLInstanceAccelerationStructureDescriptor setInstanceDescriptorType:]( v108,  "setInstanceDescriptorType:",  a1[72]);
      id v114 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  *((void *)a1 + 3)));
      unsigned __int8 v115 = (void *)objc_claimAutoreleasedReturnValue([v4 objectForKeyedSubscript:v114]);
      -[MTLInstanceAccelerationStructureDescriptor setMotionTransformBuffer:](v108, "setMotionTransformBuffer:", v115);

      id v101 = v108;
      -[MTLInstanceAccelerationStructureDescriptor setMotionTransformBufferOffset:]( v108,  "setMotionTransformBufferOffset:",  *((void *)a1 + 5));
      -[MTLInstanceAccelerationStructureDescriptor setMotionTransformCount:]( v108,  "setMotionTransformCount:",  *((unsigned int *)a1 + 17));
      if ((objc_opt_respondsToSelector(v108, "motionTransformStride") & 1) != 0) {
        -[MTLInstanceAccelerationStructureDescriptor setMotionTransformStride:]( v108,  "setMotionTransformStride:",  *((void *)a1 + 6));
      }
      if ((objc_opt_respondsToSelector(v108, "motionTransformType") & 1) != 0) {
        -[MTLInstanceAccelerationStructureDescriptor setMotionTransformType:](v108, "setMotionTransformType:", a1[73]);
      }
      if ((objc_opt_respondsToSelector(v108, "instanceTransformationMatrixLayout") & 1) != 0) {
        -[MTLInstanceAccelerationStructureDescriptor setInstanceTransformationMatrixLayout:]( v108,  "setInstanceTransformationMatrixLayout:",  a1[74]);
      }

      break;
    case 1:
      uint64_t v6 = a1[1];
      id v127 = v3;
      id v136 = v3;
      unint64_t v126 = objc_alloc_init(&OBJC_CLASS___MTLPrimitiveAccelerationStructureDescriptor);
      -[MTLPrimitiveAccelerationStructureDescriptor setUsage:](v126, "setUsage:", v6);
      __int128 v135 = -[NSMutableArray initWithCapacity:]( objc_alloc(&OBJC_CLASS___NSMutableArray),  "initWithCapacity:",  *((void *)a1 + 2));
      if (*((void *)a1 + 2))
      {
        unint64_t v7 = 0LL;
        id v8 = &CATransform3DIdentity_ptr;
        uint64_t v9 = &CATransform3DIdentity_ptr;
        uint64_t v129 = a1;
        do
        {
          uint64_t v10 = *((void *)a1 + 1);
          uint64_t v11 = v10 + 136 * v7;
          id v12 = v136;
          unint64_t v143 = v12;
          switch(*(_BYTE *)(v11 + 36))
          {
            case 1:
              unint64_t v140 = v7;
              uint64_t v13 = v10 + 136 * v7;
              id v14 = v12;
              uint64_t v15 = objc_alloc_init(&OBJC_CLASS___MTLAccelerationStructureTriangleGeometryDescriptor);
              uint64_t v16 = (void *)objc_claimAutoreleasedReturnValue( -[CATransform3D numberWithUnsignedLongLong:]( (id)v8[280],  "numberWithUnsignedLongLong:",  *(void *)(v13 + 80)));
              __int128 v17 = (void *)objc_claimAutoreleasedReturnValue([v14 objectForKeyedSubscript:v16]);
              -[MTLAccelerationStructureTriangleGeometryDescriptor setVertexBuffer:](v15, "setVertexBuffer:", v17);

              -[MTLAccelerationStructureTriangleGeometryDescriptor setVertexBufferOffset:]( v15,  "setVertexBufferOffset:",  *(void *)(v13 + 88));
              -[MTLAccelerationStructureTriangleGeometryDescriptor setVertexStride:]( v15,  "setVertexStride:",  *(void *)(v13 + 96));
              __int128 v18 = (void *)objc_claimAutoreleasedReturnValue( -[CATransform3D numberWithUnsignedLongLong:]( (id)v8[280],  "numberWithUnsignedLongLong:",  *(void *)(v13 + 40)));
              __int128 v19 = (void *)objc_claimAutoreleasedReturnValue([v14 objectForKeyedSubscript:v18]);
              -[MTLAccelerationStructureTriangleGeometryDescriptor setIndexBuffer:](v15, "setIndexBuffer:", v19);

              __int128 v20 = (MTLAccelerationStructureCurveGeometryDescriptor *)v15;
              -[MTLAccelerationStructureTriangleGeometryDescriptor setIndexBufferOffset:]( v15,  "setIndexBufferOffset:",  *(void *)(v13 + 48));
              -[MTLAccelerationStructureTriangleGeometryDescriptor setIndexType:]( v15,  "setIndexType:",  *(unsigned __int8 *)(v13 + 104));
              -[MTLAccelerationStructureTriangleGeometryDescriptor setTriangleCount:]( v15,  "setTriangleCount:",  *(void *)(v13 + 72));
              if ((objc_opt_respondsToSelector(v15, "vertexFormat") & 1) != 0) {
                -[MTLAccelerationStructureTriangleGeometryDescriptor setVertexFormat:]( v15,  "setVertexFormat:",  *(unsigned __int8 *)(v11 + 106));
              }
              unint64_t v7 = v140;
              if ((objc_opt_respondsToSelector(v15, "transformationMatrixBuffer") & 1) != 0)
              {
                uint64_t v21 = v10 + 136 * v140;
                uint64_t v22 = v20;
                uint64_t v23 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  *(void *)(v21 + 56)));
                uint64_t v24 = (void *)objc_claimAutoreleasedReturnValue([v14 objectForKeyedSubscript:v23]);
                -[MTLAccelerationStructureCurveGeometryDescriptor setTransformationMatrixBuffer:]( v22,  "setTransformationMatrixBuffer:",  v24);

                __int128 v20 = v22;
                -[MTLAccelerationStructureCurveGeometryDescriptor setTransformationMatrixBufferOffset:]( v22,  "setTransformationMatrixBufferOffset:",  *(void *)(v21 + 64));
              }

              if ((objc_opt_respondsToSelector(v20, "transformationMatrixLayout") & 1) != 0) {
                -[MTLAccelerationStructureCurveGeometryDescriptor setTransformationMatrixLayout:]( v20,  "setTransformationMatrixLayout:",  *(unsigned __int8 *)(v11 + 105));
              }

              id v8 = &CATransform3DIdentity_ptr;
              uint64_t v9 = &CATransform3DIdentity_ptr;
              break;
            case 2:
              uint64_t v25 = (void *)(v10 + 136 * v7);
              uint64_t v26 = v10;
              id v27 = v12;
              uint64_t v28 = v11;
              uint64_t v29 = objc_alloc_init(&OBJC_CLASS___MTLAccelerationStructureBoundingBoxGeometryDescriptor);
              __int128 v30 = (void *)objc_claimAutoreleasedReturnValue( -[CATransform3D numberWithUnsignedLongLong:]( (id)v8[280],  "numberWithUnsignedLongLong:",  v25[5]));
              uint64_t v31 = v27;
              uint64_t v10 = v26;
              id v32 = (void *)objc_claimAutoreleasedReturnValue([v31 objectForKeyedSubscript:v30]);
              -[MTLAccelerationStructureBoundingBoxGeometryDescriptor setBoundingBoxBuffer:]( v29,  "setBoundingBoxBuffer:",  v32);

              uint64_t v9 = &CATransform3DIdentity_ptr;
              __int128 v20 = (MTLAccelerationStructureCurveGeometryDescriptor *)v29;
              uint64_t v11 = v28;
              -[MTLAccelerationStructureCurveGeometryDescriptor setBoundingBoxBufferOffset:]( v20,  "setBoundingBoxBufferOffset:",  v25[6]);
              -[MTLAccelerationStructureCurveGeometryDescriptor setBoundingBoxStride:]( v20,  "setBoundingBoxStride:",  v25[8]);
              -[MTLAccelerationStructureCurveGeometryDescriptor setBoundingBoxCount:]( v20,  "setBoundingBoxCount:",  v25[7]);
              break;
            case 3:
              uint64_t v130 = v10 + 136 * v7;
              unint64_t v141 = v7;
              uint64_t v137 = v10;
              id v33 = v12;
              uint64_t v132 = objc_alloc_init(&OBJC_CLASS___MTLAccelerationStructureMotionTriangleGeometryDescriptor);
              uint64_t v34 = -[NSMutableArray initWithCapacity:]( objc_alloc(&OBJC_CLASS___NSMutableArray),  "initWithCapacity:",  *(void *)(v130 + 88));
              if (*(void *)(v130 + 88))
              {
                uint64_t v35 = 0LL;
                unint64_t v36 = 0LL;
                uint64_t v37 = (void *)(v137 + 136 * v7 + 80);
                do
                {
                  id v38 = objc_alloc_init((Class)v9[239]);
                  id v39 = (void *)objc_claimAutoreleasedReturnValue( -[CATransform3D numberWithUnsignedLongLong:]( (id)v8[280],  "numberWithUnsignedLongLong:",  *(void *)(*v37 + v35)));
                  uint64_t v40 = (void *)objc_claimAutoreleasedReturnValue([v33 objectForKeyedSubscript:v39]);
                  [v38 setBuffer:v40];

                  id v8 = &CATransform3DIdentity_ptr;
                  [v38 setOffset:*(void *)(*v37 + v35 + 8)];
                  -[NSMutableArray addObject:](v34, "addObject:", v38);

                  ++v36;
                  v35 += 16LL;
                }

                while (*(void *)(v130 + 88) > v36);
              }

              id v41 = -[NSMutableArray copy](v34, "copy");
              -[MTLAccelerationStructureMotionTriangleGeometryDescriptor setVertexBuffers:]( v132,  "setVertexBuffers:",  v41);

              uint64_t v42 = v137 + 136 * v7;
              -[MTLAccelerationStructureMotionTriangleGeometryDescriptor setVertexStride:]( v132,  "setVertexStride:",  *(void *)(v42 + 96));
              unint64_t v43 = (void *)objc_claimAutoreleasedReturnValue( -[CATransform3D numberWithUnsignedLongLong:]( (id)v8[280],  "numberWithUnsignedLongLong:",  *(void *)(v130 + 40)));
              id v44 = (void *)objc_claimAutoreleasedReturnValue([v33 objectForKeyedSubscript:v43]);
              -[MTLAccelerationStructureMotionTriangleGeometryDescriptor setIndexBuffer:](v132, "setIndexBuffer:", v44);

              __int128 v20 = (MTLAccelerationStructureCurveGeometryDescriptor *)v132;
              -[MTLAccelerationStructureMotionTriangleGeometryDescriptor setIndexBufferOffset:]( v132,  "setIndexBufferOffset:",  *(void *)(v42 + 48));
              -[MTLAccelerationStructureMotionTriangleGeometryDescriptor setIndexType:]( v132,  "setIndexType:",  *(unsigned __int8 *)(v42 + 104));
              -[MTLAccelerationStructureMotionTriangleGeometryDescriptor setTriangleCount:]( v132,  "setTriangleCount:",  *(void *)(v42 + 72));
              uint64_t v11 = v130;
              if ((objc_opt_respondsToSelector(v132, "vertexFormat") & 1) != 0) {
                -[MTLAccelerationStructureMotionTriangleGeometryDescriptor setVertexFormat:]( v132,  "setVertexFormat:",  *(unsigned __int8 *)(v130 + 106));
              }
              unint64_t v7 = v141;
              if ((objc_opt_respondsToSelector(v132, "transformationMatrixBuffer") & 1) != 0)
              {
                uint64_t v45 = v137 + 136 * v141;
                unint64_t v46 = (void *)objc_claimAutoreleasedReturnValue( -[CATransform3D numberWithUnsignedLongLong:]( (id)v8[280],  "numberWithUnsignedLongLong:",  *(void *)(v45 + 56)));
                uint64_t v47 = (void *)objc_claimAutoreleasedReturnValue([v33 objectForKeyedSubscript:v46]);
                -[MTLAccelerationStructureMotionTriangleGeometryDescriptor setTransformationMatrixBuffer:]( v132,  "setTransformationMatrixBuffer:",  v47);

                id v8 = &CATransform3DIdentity_ptr;
                __int128 v20 = (MTLAccelerationStructureCurveGeometryDescriptor *)v132;
                -[MTLAccelerationStructureMotionTriangleGeometryDescriptor setTransformationMatrixBufferOffset:]( v132,  "setTransformationMatrixBufferOffset:",  *(void *)(v45 + 64));
              }

              a1 = v129;
              if ((objc_opt_respondsToSelector(v20, "transformationMatrixLayout") & 1) != 0) {
                -[MTLAccelerationStructureCurveGeometryDescriptor setTransformationMatrixLayout:]( v20,  "setTransformationMatrixLayout:",  *(unsigned __int8 *)(v130 + 105));
              }

              uint64_t v9 = &CATransform3DIdentity_ptr;
              uint64_t v10 = v137;
              break;
            case 4:
              uint64_t v131 = v10 + 136 * v7;
              uint64_t v138 = v10;
              uint64_t v48 = v12;
              uint64_t v133 = objc_alloc_init(&OBJC_CLASS___MTLAccelerationStructureMotionBoundingBoxGeometryDescriptor);
              uint64_t v49 = v9;
              uint64_t v50 = -[NSMutableArray initWithCapacity:]( objc_alloc(&OBJC_CLASS___NSMutableArray),  "initWithCapacity:",  *(void *)(v131 + 48));
              if (*(void *)(v131 + 48))
              {
                uint64_t v51 = 0LL;
                unint64_t v52 = 0LL;
                uint64_t v53 = (void *)(v131 + 40);
                do
                {
                  id v54 = objc_alloc_init((Class)v49[239]);
                  uint64_t v55 = (void *)objc_claimAutoreleasedReturnValue( -[CATransform3D numberWithUnsignedLongLong:]( (id)v8[280],  "numberWithUnsignedLongLong:",  *(void *)(*v53 + v51)));
                  id v56 = (void *)objc_claimAutoreleasedReturnValue([v48 objectForKeyedSubscript:v55]);
                  [v54 setBuffer:v56];

                  id v8 = &CATransform3DIdentity_ptr;
                  [v54 setOffset:*(void *)(*v53 + v51 + 8)];
                  -[NSMutableArray addObject:](v50, "addObject:", v54);

                  ++v52;
                  v51 += 16LL;
                }

                while (*(void *)(v131 + 48) > v52);
              }

              id v57 = -[NSMutableArray copy](v50, "copy");
              -[MTLAccelerationStructureMotionBoundingBoxGeometryDescriptor setBoundingBoxBuffers:]( v133,  "setBoundingBoxBuffers:",  v57);

              __int128 v20 = (MTLAccelerationStructureCurveGeometryDescriptor *)v133;
              uint64_t v10 = v138;
              uint64_t v58 = v138 + 136 * v7;
              -[MTLAccelerationStructureMotionBoundingBoxGeometryDescriptor setBoundingBoxStride:]( v133,  "setBoundingBoxStride:",  *(void *)(v58 + 64));
              -[MTLAccelerationStructureMotionBoundingBoxGeometryDescriptor setBoundingBoxCount:]( v133,  "setBoundingBoxCount:",  *(void *)(v58 + 56));

              a1 = v129;
              uint64_t v9 = v49;
              goto LABEL_38;
            case 5:
              uint64_t v59 = v10 + 136 * v7;
              id v60 = v12;
              __int128 v20 = objc_alloc_init(&OBJC_CLASS___MTLAccelerationStructureCurveGeometryDescriptor);
              uint64_t v61 = (void *)objc_claimAutoreleasedReturnValue( -[CATransform3D numberWithUnsignedLongLong:]( (id)v8[280],  "numberWithUnsignedLongLong:",  *(void *)(v59 + 40)));
              id v62 = (void *)objc_claimAutoreleasedReturnValue([v60 objectForKeyedSubscript:v61]);
              -[MTLAccelerationStructureCurveGeometryDescriptor setControlPointBuffer:]( v20,  "setControlPointBuffer:",  v62);

              -[MTLAccelerationStructureCurveGeometryDescriptor setControlPointBufferOffset:]( v20,  "setControlPointBufferOffset:",  *(void *)(v59 + 48));
              uint64_t v63 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  *(void *)(v59 + 88)));
              BOOL v64 = (void *)objc_claimAutoreleasedReturnValue([v60 objectForKeyedSubscript:v63]);
              -[MTLAccelerationStructureCurveGeometryDescriptor setRadiusBuffer:](v20, "setRadiusBuffer:", v64);

              -[MTLAccelerationStructureCurveGeometryDescriptor setRadiusBufferOffset:]( v20,  "setRadiusBufferOffset:",  *(void *)(v59 + 96));
              -[MTLAccelerationStructureCurveGeometryDescriptor setControlPointCount:]( v20,  "setControlPointCount:",  *(void *)(v59 + 56));
              -[MTLAccelerationStructureCurveGeometryDescriptor setControlPointStride:]( v20,  "setControlPointStride:",  *(void *)(v59 + 64));
              -[MTLAccelerationStructureCurveGeometryDescriptor setRadiusStride:]( v20,  "setRadiusStride:",  *(void *)(v59 + 104));
              double v65 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  *(void *)(v59 + 72)));
              double v66 = (void *)objc_claimAutoreleasedReturnValue([v60 objectForKeyedSubscript:v65]);
              -[MTLAccelerationStructureCurveGeometryDescriptor setIndexBuffer:](v20, "setIndexBuffer:", v66);

              id v8 = &CATransform3DIdentity_ptr;
              uint64_t v11 = v59;
              -[MTLAccelerationStructureCurveGeometryDescriptor setIndexBufferOffset:]( v20,  "setIndexBufferOffset:",  *(void *)(v59 + 80));
              -[MTLAccelerationStructureCurveGeometryDescriptor setSegmentCount:]( v20,  "setSegmentCount:",  *(void *)(v59 + 120));
              -[MTLAccelerationStructureCurveGeometryDescriptor setSegmentControlPointCount:]( v20,  "setSegmentControlPointCount:",  *(void *)(v59 + 112));
              -[MTLAccelerationStructureCurveGeometryDescriptor setControlPointFormat:]( v20,  "setControlPointFormat:",  *(unsigned __int8 *)(v59 + 128));
              -[MTLAccelerationStructureCurveGeometryDescriptor setRadiusFormat:]( v20,  "setRadiusFormat:",  *(unsigned __int8 *)(v59 + 133));
              -[MTLAccelerationStructureCurveGeometryDescriptor setIndexType:]( v20,  "setIndexType:",  *(unsigned __int8 *)(v59 + 132));
              -[MTLAccelerationStructureCurveGeometryDescriptor setCurveType:]( v20,  "setCurveType:",  *(unsigned __int8 *)(v59 + 130));
              -[MTLAccelerationStructureCurveGeometryDescriptor setCurveBasis:]( v20,  "setCurveBasis:",  *(unsigned __int8 *)(v59 + 129));
              uint64_t v67 = *(unsigned __int8 *)(v59 + 131);
              uint64_t v9 = &CATransform3DIdentity_ptr;
              -[MTLAccelerationStructureCurveGeometryDescriptor setEndCaps:](v20, "setEndCaps:", v67);
              break;
            case 6:
              uint64_t v131 = v10 + 136 * v7;
              unint64_t v142 = v7;
              uint64_t v139 = v10;
              double v68 = v12;
              uint64_t v134 = objc_alloc_init(&OBJC_CLASS___MTLAccelerationStructureMotionCurveGeometryDescriptor);
              double v69 = -[NSMutableArray initWithCapacity:]( objc_alloc(&OBJC_CLASS___NSMutableArray),  "initWithCapacity:",  *(void *)(v131 + 48));
              if (*(void *)(v131 + 48))
              {
                uint64_t v70 = 0LL;
                unint64_t v71 = 0LL;
                uint64_t v72 = (void *)(v131 + 40);
                do
                {
                  id v73 = objc_alloc_init((Class)v9[239]);
                  BOOL v74 = (void *)objc_claimAutoreleasedReturnValue( -[CATransform3D numberWithUnsignedLongLong:]( (id)v8[280],  "numberWithUnsignedLongLong:",  *(void *)(*v72 + v70)));
                  double v75 = (void *)objc_claimAutoreleasedReturnValue([v68 objectForKeyedSubscript:v74]);
                  [v73 setBuffer:v75];

                  id v8 = &CATransform3DIdentity_ptr;
                  [v73 setOffset:*(void *)(*v72 + v70 + 8)];
                  -[NSMutableArray addObject:](v69, "addObject:", v73);

                  ++v71;
                  v70 += 16LL;
                }

                while (*(void *)(v131 + 48) > v71);
              }

              uint64_t v128 = v69;
              double v76 = objc_alloc(&OBJC_CLASS___NSMutableArray);
              uint64_t v77 = v139 + 136 * v7;
              uint64_t v79 = *(void *)(v77 + 96);
              unint64_t v78 = (unint64_t *)(v77 + 96);
              id v80 = -[NSMutableArray initWithCapacity:](v76, "initWithCapacity:", v79);
              if (*v78)
              {
                uint64_t v81 = 0LL;
                unint64_t v82 = 0LL;
                uint64_t v83 = (void *)(v139 + 136 * v142 + 88);
                do
                {
                  id v84 = objc_alloc_init((Class)v9[239]);
                  unsigned int v85 = (void *)objc_claimAutoreleasedReturnValue( -[CATransform3D numberWithUnsignedLongLong:]( (id)v8[280],  "numberWithUnsignedLongLong:",  *(void *)(*v83 + v81)));
                  int v86 = (void *)objc_claimAutoreleasedReturnValue([v68 objectForKeyedSubscript:v85]);
                  [v84 setBuffer:v86];

                  id v8 = &CATransform3DIdentity_ptr;
                  [v84 setOffset:*(void *)(*v83 + v81 + 8)];
                  -[NSMutableArray addObject:](v80, "addObject:", v84);

                  ++v82;
                  v81 += 16LL;
                }

                while (*v78 > v82);
              }

              id v87 = -[NSMutableArray copy](v128, "copy");
              -[MTLAccelerationStructureMotionCurveGeometryDescriptor setControlPointBuffers:]( v134,  "setControlPointBuffers:",  v87);

              id v88 = -[NSMutableArray copy](v80, "copy");
              -[MTLAccelerationStructureMotionCurveGeometryDescriptor setRadiusBuffers:](v134, "setRadiusBuffers:", v88);

              uint64_t v89 = v139 + 136 * v142;
              -[MTLAccelerationStructureMotionCurveGeometryDescriptor setControlPointCount:]( v134,  "setControlPointCount:",  *(void *)(v89 + 56));
              -[MTLAccelerationStructureMotionCurveGeometryDescriptor setControlPointStride:]( v134,  "setControlPointStride:",  *(void *)(v89 + 64));
              -[MTLAccelerationStructureMotionCurveGeometryDescriptor setRadiusStride:]( v134,  "setRadiusStride:",  *(void *)(v89 + 104));
              uint64_t v90 = (void *)objc_claimAutoreleasedReturnValue( -[CATransform3D numberWithUnsignedLongLong:]( (id)v8[280],  "numberWithUnsignedLongLong:",  *(void *)(v89 + 72)));
              BOOL v91 = v68;
              uint64_t v10 = v139;
              uint64_t v92 = (void *)objc_claimAutoreleasedReturnValue([v91 objectForKeyedSubscript:v90]);
              -[MTLAccelerationStructureMotionCurveGeometryDescriptor setIndexBuffer:](v134, "setIndexBuffer:", v92);

              id v8 = &CATransform3DIdentity_ptr;
              __int128 v20 = (MTLAccelerationStructureCurveGeometryDescriptor *)v134;
              -[MTLAccelerationStructureMotionCurveGeometryDescriptor setIndexBufferOffset:]( v134,  "setIndexBufferOffset:",  *(void *)(v89 + 80));
              -[MTLAccelerationStructureMotionCurveGeometryDescriptor setSegmentCount:]( v134,  "setSegmentCount:",  *(void *)(v89 + 120));
              -[MTLAccelerationStructureMotionCurveGeometryDescriptor setControlPointFormat:]( v134,  "setControlPointFormat:",  *(unsigned __int8 *)(v89 + 128));
              -[MTLAccelerationStructureMotionCurveGeometryDescriptor setRadiusFormat:]( v134,  "setRadiusFormat:",  *(unsigned __int8 *)(v89 + 133));
              -[MTLAccelerationStructureMotionCurveGeometryDescriptor setIndexType:]( v134,  "setIndexType:",  *(unsigned __int8 *)(v89 + 132));
              -[MTLAccelerationStructureMotionCurveGeometryDescriptor setSegmentControlPointCount:]( v134,  "setSegmentControlPointCount:",  *(void *)(v89 + 112));
              -[MTLAccelerationStructureMotionCurveGeometryDescriptor setCurveType:]( v134,  "setCurveType:",  *(unsigned __int8 *)(v89 + 130));
              -[MTLAccelerationStructureMotionCurveGeometryDescriptor setCurveBasis:]( v134,  "setCurveBasis:",  *(unsigned __int8 *)(v89 + 129));
              uint64_t v93 = *(unsigned __int8 *)(v89 + 131);
              unint64_t v7 = v142;
              -[MTLAccelerationStructureMotionCurveGeometryDescriptor setEndCaps:](v134, "setEndCaps:", v93);

              a1 = v129;
LABEL_38:
              uint64_t v11 = v131;
              break;
            default:
              __int128 v20 = 0LL;
              break;
          }

          uint64_t v94 = v10 + 136 * v7;
          -[MTLAccelerationStructureCurveGeometryDescriptor setIntersectionFunctionTableOffset:]( v20,  "setIntersectionFunctionTableOffset:",  *(unsigned int *)(v94 + 32));
          -[MTLAccelerationStructureCurveGeometryDescriptor setOpaque:](v20, "setOpaque:", *(_BYTE *)(v94 + 37) != 0);
          -[MTLAccelerationStructureCurveGeometryDescriptor setAllowDuplicateIntersectionFunctionInvocation:]( v20,  "setAllowDuplicateIntersectionFunctionInvocation:",  *(_BYTE *)(v94 + 38) != 0);
          if (*(void *)v11)
          {
            unint64_t v95 = v20;
            uint64_t v96 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:"));
            -[MTLAccelerationStructureCurveGeometryDescriptor setLabel:](v95, "setLabel:", v96);

            __int128 v20 = v95;
          }

          if ((objc_opt_respondsToSelector(v20, "primitiveDataBuffer") & 1) != 0)
          {
            uint64_t v97 = v10 + 136 * v7;
            uint64_t v98 = v20;
            uint64_t v99 = (void *)objc_claimAutoreleasedReturnValue( -[CATransform3D numberWithUnsignedLongLong:]( (id)v8[280],  "numberWithUnsignedLongLong:",  *(void *)(v97 + 8)));
            int v100 = (void *)objc_claimAutoreleasedReturnValue([v143 objectForKeyedSubscript:v99]);
            -[MTLAccelerationStructureCurveGeometryDescriptor setPrimitiveDataBuffer:]( v98,  "setPrimitiveDataBuffer:",  v100);

            id v8 = &CATransform3DIdentity_ptr;
            __int128 v20 = v98;
            -[MTLAccelerationStructureCurveGeometryDescriptor setPrimitiveDataBufferOffset:]( v98,  "setPrimitiveDataBufferOffset:",  *(void *)(v97 + 16));
            -[MTLAccelerationStructureCurveGeometryDescriptor setPrimitiveDataStride:]( v98,  "setPrimitiveDataStride:",  *(unsigned int *)(v97 + 24));
            -[MTLAccelerationStructureCurveGeometryDescriptor setPrimitiveDataElementSize:]( v98,  "setPrimitiveDataElementSize:",  *(unsigned int *)(v97 + 28));
          }

          -[NSMutableArray addObject:](v135, "addObject:", v20);
          ++v7;
        }

        while (*((void *)a1 + 2) > v7);
      }

      id v101 = v126;
      -[MTLPrimitiveAccelerationStructureDescriptor setGeometryDescriptors:](v126, "setGeometryDescriptors:", v135);
      LODWORD(v102) = *((_DWORD *)a1 + 8);
      -[MTLPrimitiveAccelerationStructureDescriptor setMotionStartTime:](v126, "setMotionStartTime:", v102);
      LODWORD(v103) = *((_DWORD *)a1 + 6);
      -[MTLPrimitiveAccelerationStructureDescriptor setMotionEndTime:](v126, "setMotionEndTime:", v103);
      -[MTLPrimitiveAccelerationStructureDescriptor setMotionKeyframeCount:]( v126,  "setMotionKeyframeCount:",  *((unsigned int *)a1 + 7));
      -[MTLPrimitiveAccelerationStructureDescriptor setMotionStartBorderMode:]( v126,  "setMotionStartBorderMode:",  a1[37]);
      -[MTLPrimitiveAccelerationStructureDescriptor setMotionEndBorderMode:](v126, "setMotionEndBorderMode:", a1[36]);

      uint64_t v4 = v127;
      break;
    default:
      id v101 = 0LL;
      break;
  }

  return v101;
}

MTLIntersectionFunctionDescriptor *MakeMTLIntersectionFunctionDescriptor(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = objc_alloc_init(&OBJC_CLASS___MTLIntersectionFunctionDescriptor);
  -[MTLIntersectionFunctionDescriptor setOptions:](v4, "setOptions:", *(unsigned __int8 *)(a1 + 40));
  if (*(void *)(a1 + 8))
  {
    int v5 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:"));
    -[MTLIntersectionFunctionDescriptor setName:](v4, "setName:", v5);
  }

  if (*(void *)(a1 + 32))
  {
    uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:"));
    -[MTLIntersectionFunctionDescriptor setSpecializedName:](v4, "setSpecializedName:", v6);
  }

  if (*(void *)a1)
  {
    MTLFunctionConstantValues = MakeMTLFunctionConstantValues(*(void **)a1);
    id v8 = (void *)objc_claimAutoreleasedReturnValue(MTLFunctionConstantValues);
    -[MTLIntersectionFunctionDescriptor setConstantValues:](v4, "setConstantValues:", v8);
  }

  if (*(void *)(a1 + 24) && (objc_opt_respondsToSelector(v4, "privateFunctions") & 1) != 0)
  {
    id ObjectArrayWithMap = CreateObjectArrayWithMap(*(uint64_t **)(a1 + 16), *(_DWORD *)(a1 + 24), v3);
    uint64_t v10 = (void *)objc_claimAutoreleasedReturnValue(ObjectArrayWithMap);
    -[MTLIntersectionFunctionDescriptor setPrivateFunctions:](v4, "setPrivateFunctions:", v10);
  }

  return v4;
}

MTLStitchedLibraryDescriptor *MakeMTLStitchedLibraryDescriptor(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = objc_alloc_init(&OBJC_CLASS___MTLStitchedLibraryDescriptor);
  -[MTLStitchedLibraryDescriptor setOptions:](v4, "setOptions:", *(unsigned __int8 *)(a1 + 20));
  id MTLFunctionStitchingGraphArray = MakeMTLFunctionStitchingGraphArray(*(void *)a1, *(unsigned __int16 *)(a1 + 16));
  uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue(MTLFunctionStitchingGraphArray);
  -[MTLStitchedLibraryDescriptor setFunctionGraphs:](v4, "setFunctionGraphs:", v6);

  id ObjectArrayWithMap = CreateObjectArrayWithMap(*(uint64_t **)(a1 + 8), *(unsigned __int16 *)(a1 + 18), v3);
  id v8 = (void *)objc_claimAutoreleasedReturnValue(ObjectArrayWithMap);

  -[MTLStitchedLibraryDescriptor setFunctions:](v4, "setFunctions:", v8);
  return v4;
}

id MakeMTLFunctionStitchingGraphArray(uint64_t a1, int a2)
{
  uint64_t v32 = a2;
  __int128 v30 = -[NSMutableArray initWithCapacity:](objc_alloc(&OBJC_CLASS___NSMutableArray), "initWithCapacity:");
  id v33 = objc_alloc_init(&OBJC_CLASS___NSMutableDictionary);
  if (a2 >= 1)
  {
    uint64_t v4 = 0LL;
    uint64_t v31 = a1;
    while (1)
    {
      uint64_t v5 = a1 + 40 * v4;
      uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithUTF8String:]( &OBJC_CLASS___NSString,  "stringWithUTF8String:",  *(void *)v5,  v30));
      id MTLFunctionStitchingFunctionNodeArray = MakeMTLFunctionStitchingFunctionNodeArray( *(unsigned __int8 **)(v5 + 8),  *(unsigned __int16 *)(v5 + 32),  v33);
      uint64_t v8 = objc_claimAutoreleasedReturnValue(MTLFunctionStitchingFunctionNodeArray);
      uint64_t v9 = (void *)v8;
      uint64_t v10 = &__NSArray0__struct;
      if (v8) {
        uint64_t v10 = (void *)v8;
      }
      id v11 = v10;

      id MTLFunctionStitchingFunctionNode = MakeMTLFunctionStitchingFunctionNode(*(unsigned __int8 **)(v5 + 16), v33);
      uint64_t v13 = (void *)objc_claimAutoreleasedReturnValue(MTLFunctionStitchingFunctionNode);
      uint64_t v14 = *(unsigned __int16 *)(v5 + 34);
      if (*(_WORD *)(v5 + 34))
      {
        uint64_t v15 = *(unsigned __int8 **)(v5 + 24);
        uint64_t v16 = -[NSMutableArray initWithCapacity:](objc_alloc(&OBJC_CLASS___NSMutableArray), "initWithCapacity:", v14);
        while (1)
        {
          int v18 = *v15;
          v15 += 8;
          int v17 = v18;
          if (v18 == 1) {
            break;
          }
          if (v17 == 2)
          {
            __int128 v19 = (Class *)&OBJC_CLASS___MTLFunctionStitchingAttributeKernel_ptr;
LABEL_11:
            id v20 = objc_alloc_init(*v19);
            -[NSMutableArray addObject:](v16, "addObject:", v20);
          }

          if (!--v14)
          {
            id v21 = -[NSMutableArray copy](v16, "copy");

            goto LABEL_15;
          }
        }

        __int128 v19 = (Class *)&OBJC_CLASS___MTLFunctionStitchingAttributeAlwaysInline_ptr;
        goto LABEL_11;
      }

      id v21 = 0LL;
LABEL_15:
      a1 = v31;
      uint64_t v22 = &__NSArray0__struct;
      if (v21) {
        uint64_t v22 = v21;
      }
      id v23 = v22;

      int v24 = *(unsigned __int8 *)(v31 + 40 * v4 + 36);
      if (v24 == 2) {
        break;
      }
      if (v24 == 1)
      {
        uint64_t v25 = (Class *)&OBJC_CLASS___MTLFunctionStitchingGraph_ptr;
LABEL_21:
        id v26 = [objc_alloc(*v25) initWithFunctionName:v6 nodes:v11 outputNode:v13 attributes:v23];
        -[NSMutableArray addObject:](v30, "addObject:", v26);
      }

      if (++v4 == v32) {
        goto LABEL_23;
      }
    }

    uint64_t v25 = (Class *)&OBJC_CLASS___MTLFunctionStitchingGraphSPI_ptr;
    goto LABEL_21;
  }

LABEL_23:
  id v27 = v30;
  id v28 = -[NSMutableArray copy](v30, "copy", v30);

  return v28;
}

      abort();
    }

    id v12 = __stderrp;
    uint64_t v13 = +[NSString stringWithFormat:]( NSString,  "stringWithFormat:",  @"fail: url scheme has to be dysmt: %s",  objc_msgSend(objc_msgSend(a3, "absoluteString"), "UTF8String"));
LABEL_22:
    -[NSString UTF8String](v13, "UTF8String");
    fprintf(v12, "%s\n");
    goto LABEL_23;
  }

  if (!objc_msgSend(objc_msgSend(a3, "path"), "length"))
  {
    if (s_logUsingOsLog)
    {
      uint64_t v10 = (os_log_s *)gt_default_log();
      if (os_log_type_enabled(v10, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)buf = 136315138;
        uint64_t v16 = objc_msgSend(objc_msgSend(a3, "absoluteString"), "UTF8String");
        unint64_t v7 = "fail: url path cannot be nil or empty: %s";
LABEL_17:
        uint64_t v8 = v10;
        uint64_t v9 = 12;
LABEL_18:
        _os_log_fault_impl(&dword_0, v8, OS_LOG_TYPE_FAULT, v7, buf, v9);
        abort();
      }

      goto LABEL_23;
    }

    id v12 = __stderrp;
    uint64_t v13 = +[NSString stringWithFormat:]( NSString,  "stringWithFormat:",  @"fail: url path cannot be nil or empty: %s",  objc_msgSend(objc_msgSend(a3, "absoluteString"), "UTF8String"));
    goto LABEL_22;
  }

  queue = (dispatch_queue_s *)self->super.super._queue;
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472LL;
  block[2] = __34__GTSharedMemoryTransport_setUrl___block_invoke;
  block[3] = &unk_58E1F8;
  block[4] = a3;
  block[5] = self;
  dispatch_sync(queue, block);
}

  objc_msgSend( a4,  "setError:",  +[NSError errorWithDomain:code:userInfo:]( NSError,  "errorWithDomain:code:userInfo:",  NSPOSIXErrorDomain,  *__error(),  0));
  objc_msgSend(a4, "setResult:", +[NSNumber numberWithBool:](NSNumber, "numberWithBool:", 0));
  if (v17 != -1) {
    close(v17);
  }
}

id MakeMTLFunctionStitchingFunctionNodeArray(unsigned __int8 *a1, unsigned int a2, void *a3)
{
  id v5 = a3;
  if (a2)
  {
    uint64_t v6 = a2;
    unint64_t v7 = -[NSMutableArray initWithCapacity:](objc_alloc(&OBJC_CLASS___NSMutableArray), "initWithCapacity:", a2);
    do
    {
      id MTLFunctionStitchingFunctionNode = MakeMTLFunctionStitchingFunctionNode(a1, v5);
      uint64_t v9 = (void *)objc_claimAutoreleasedReturnValue(MTLFunctionStitchingFunctionNode);
      -[NSMutableArray addObject:](v7, "addObject:", v9);

      a1 += 48;
      --v6;
    }

    while (v6);
    id v10 = -[NSMutableArray copy](v7, "copy");
  }

  else
  {
    id v10 = 0LL;
  }

  return v10;
}

id MakeMTLFunctionStitchingFunctionNode(unsigned __int8 *a1, void *a2)
{
  id v3 = a2;
  if (a1)
  {
    uint64_t v4 = *((void *)a1 + 4);
    if (!v4
      || (v5 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( NSNumber,  "numberWithUnsignedLongLong:",  *((void *)a1 + 4))),  uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue([v3 objectForKeyedSubscript:v5]),  v5,  !v6))
    {
      unint64_t v7 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithUTF8String:]( &OBJC_CLASS___NSString,  "stringWithUTF8String:",  *((void *)a1 + 1)));
      uint64_t v8 = *((void *)a1 + 2);
      uint64_t v9 = (char *)*((unsigned __int16 *)a1 + 20);
      id v10 = v3;
      if (v9)
      {
        id v11 = -[NSMutableArray initWithCapacity:](objc_alloc(&OBJC_CLASS___NSMutableArray), "initWithCapacity:", v9);
        do
        {
          switch(*(_BYTE *)v8)
          {
            case 1:
            case 2:
            case 0xC:
              uint64_t MTLFunctionStitchingFunctionNode = MakeMTLFunctionStitchingFunctionNode(v8, v10);
              uint64_t v13 = (MTLFunctionStitchingInputNode *)objc_claimAutoreleasedReturnValue(MTLFunctionStitchingFunctionNode);
              goto LABEL_19;
            case 3:
              uint64_t v13 = -[MTLFunctionStitchingInputNode initWithArgumentIndex:]( objc_alloc(&OBJC_CLASS___MTLFunctionStitchingInputNode),  "initWithArgumentIndex:",  *(unsigned __int16 *)(v8 + 12));
              goto LABEL_19;
            case 4:
              uint64_t v14 = (objc_class *)&OBJC_CLASS___MTLFunctionStitchingInputBuffer;
              goto LABEL_15;
            case 5:
              uint64_t v13 = (MTLFunctionStitchingInputNode *)[[MTLFunctionStitchingInputBufferAddress alloc] initWithBindIndex:*(unsigned __int16 *)(v8 + 12) byteOffset:*(unsigned int *)(v8 + 8) dereference:*(_BYTE *)(v8 + 14) != 0];
              goto LABEL_19;
            case 6:
              uint64_t v14 = (objc_class *)&OBJC_CLASS___MTLFunctionStitchingInputTexture;
              goto LABEL_15;
            case 7:
              uint64_t v14 = (objc_class *)&OBJC_CLASS___MTLFunctionStitchingInputSampler;
              goto LABEL_15;
            case 8:
              uint64_t v14 = (objc_class *)&OBJC_CLASS___MTLFunctionStitchingInputThreadgroup;
              goto LABEL_15;
            case 9:
              uint64_t v14 = (objc_class *)&OBJC_CLASS___MTLFunctionStitchingInputImageblock;
LABEL_15:
              uint64_t v13 = (MTLFunctionStitchingInputNode *)[[v14 alloc] initWithBindIndex:*(unsigned __int16 *)(v8 + 12)];
              goto LABEL_19;
            case 0xA:
              uint64_t v15 = (objc_class *)&OBJC_CLASS___MTLFunctionStitchingBuiltinThreadPositionInGrid;
              goto LABEL_18;
            case 0xB:
              uint64_t v15 = (objc_class *)&OBJC_CLASS___MTLFunctionStitchingBuiltinThreadPositionInThreadgroup;
LABEL_18:
              uint64_t v13 = (MTLFunctionStitchingInputNode *)objc_alloc_init(v15);
LABEL_19:
              uint64_t v16 = v13;
              -[NSMutableArray addObject:](v11, "addObject:", v13);

              break;
            default:
              break;
          }

          v8 += 48LL;
          --v9;
        }

        while (v9);
        uint64_t v9 = (char *)-[NSMutableArray copy](v11, "copy");
      }

      if (v9) {
        int v17 = v9;
      }
      else {
        int v17 = (char *)&__NSArray0__struct;
      }
      int v18 = v17;

      uint64_t MTLFunctionStitchingFunctionNodeArray = MakeMTLFunctionStitchingFunctionNodeArray( *((void *)a1 + 3),  *((unsigned __int16 *)a1 + 21),  v10);
      uint64_t v20 = objc_claimAutoreleasedReturnValue(MTLFunctionStitchingFunctionNodeArray);
      id v21 = (void *)v20;
      if (v20) {
        uint64_t v22 = (void *)v20;
      }
      else {
        uint64_t v22 = &__NSArray0__struct;
      }
      id v23 = v22;

      int v24 = *a1;
      switch(v24)
      {
        case 1:
          id v26 = (objc_class *)&OBJC_CLASS___MTLFunctionStitchingFunctionNode;
          break;
        case 12:
          id v26 = (objc_class *)&OBJC_CLASS___MTLFunctionStitchingEarlyReturnNode;
          break;
        case 2:
          id v25 = [[MTLFunctionStitchingFunctionNodeSPI alloc] initWithName:v7 arguments:v18 controlDependencies:v23 isEarlyReturn:a1[44] != 0];
LABEL_36:
          uint64_t v6 = v25;
          if (v4)
          {
            id v27 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  v4));
            [v10 setObject:v6 forKeyedSubscript:v27];
          }

          goto LABEL_39;
        default:
          uint64_t v6 = 0LL;
LABEL_39:

          goto LABEL_40;
      }

      id v25 = [[v26 alloc] initWithName:v7 arguments:v18 controlDependencies:v23];
      goto LABEL_36;
    }
  }

  else
  {
    uint64_t v6 = 0LL;
  }

LABEL_40:
  return v6;
}

  uint64_t v31 = 0LL;
  uint64_t v32 = 0LL;
LABEL_41:
  MTLAccelerationStructureBoundingBoxGeometryDescriptor *v29 = v30 + v31;
  if (a4) {
    __n128 result = (size_t)memcpy(v32, v28, v31);
  }
  if (v15)
  {
    __n128 result = strlen(v15);
    id v33 = (void *)(a3 + 416);
    uint64_t v34 = *(void *)(a3 + 416);
    uint64_t v35 = v18;
    unint64_t v36 = result + 1;
    if (result != -1LL)
    {
      uint64_t v37 = *(void **)(a3 + 416);
      goto LABEL_48;
    }
  }

  else
  {
    uint64_t v35 = v18;
    id v33 = (void *)(a3 + 416);
    uint64_t v34 = *(void *)(a3 + 416);
  }

  unint64_t v36 = 0LL;
  uint64_t v37 = 0LL;
LABEL_48:
  NSMutableDictionary *v33 = v34 + v36;
  if (a4) {
    __n128 result = (size_t)memcpy(v37, v15, v36);
  }
  if (v16)
  {
    __n128 result = strlen(v16);
    id v38 = (void *)(a3 + 416);
    id v39 = *(void *)(a3 + 416);
    uint64_t v40 = result + 1;
    if (result != -1LL)
    {
      id v41 = *(void **)(a3 + 416);
      goto LABEL_55;
    }
  }

  else
  {
    id v38 = (void *)(a3 + 416);
    id v39 = *(void *)(a3 + 416);
  }

  uint64_t v40 = 0LL;
  id v41 = 0LL;
LABEL_55:
  *id v38 = v39 + v40;
  if (a4) {
    __n128 result = (size_t)memcpy(v41, v16, v40);
  }
  if (v17)
  {
    __n128 result = strlen(v17);
    uint64_t v42 = (void *)(a3 + 416);
    unint64_t v43 = *(void *)(a3 + 416);
    id v44 = result + 1;
    if (result != -1LL)
    {
      uint64_t v45 = *(void **)(a3 + 416);
      goto LABEL_62;
    }
  }

  else
  {
    uint64_t v42 = (void *)(a3 + 416);
    unint64_t v43 = *(void *)(a3 + 416);
  }

  id v44 = 0LL;
  uint64_t v45 = 0LL;
LABEL_62:
  *uint64_t v42 = v43 + v44;
  if ((a4 & 1) != 0)
  {
    __n128 result = (size_t)memcpy(v45, v17, v44);
    unint64_t v46 = *(void *)(a3 + 312);
    *(void *)(a3 + 312) = v46 + 112;
    *(_OWORD *)unint64_t v46 = v53;
    *(void *)(v46 + 16) = v47;
    *(_OWORD *)(v46 + 24) = v59;
    *(int16x8_t *)(v46 + 40) = v51;
    *(_WORD *)(v46 + 56) = WORD2(v50);
    *(_WORD *)(v46 + 5_Block_object_dispose((const void *)(v35 - 176), 8) = v50;
    *(_DWORD *)(v46 + 60) = 0;
    *(void *)(v46 + 64) = v32;
    *(void *)(v46 + 72) = v37;
    *(void *)(v46 + 80) = v41;
    *(void *)(v46 + 8_Block_object_dispose((const void *)(v35 - 176), 8) = v45;
    *(_WORD *)(v46 + 96) = v57;
    *(_WORD *)(v46 + 9_Block_object_dispose((const void *)(v35 - 176), 8) = v56;
    *(_WORD *)(v46 + 100) = v55;
    *(_BYTE *)(v46 + 102) = v8;
    *(_BYTE *)(v46 + 103) = BYTE4(v49);
    *(_BYTE *)(v46 + 104) = v7;
    *(_BYTE *)(v46 + 105) = v58;
    *(_BYTE *)(v46 + 106) = v35;
    *(_BYTE *)(v46 + 107) = v54;
    *(_BYTE *)(v46 + 10_Block_object_dispose((const void *)(v35 - 176), 8) = v52;
    *(_BYTE *)(v46 + 109) = v49;
    *(_BYTE *)(v46 + 110) = v48;
    *(_BYTE *)(v46 + 111) = 0;
  }

  else
  {
    *(void *)(a3 + 312) += 112LL;
  }

  return result;
}

id MakeMTLStitchedLibraryDescriptorSPI(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = objc_alloc_init(&OBJC_CLASS___MTLStitchedLibraryDescriptorSPI);
  [v4 setOptions:*(unsigned __int8 *)(a1 + 20)];
  id MTLFunctionStitchingGraphArray = MakeMTLFunctionStitchingGraphArray(*(void *)a1, *(unsigned __int16 *)(a1 + 16));
  uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue(MTLFunctionStitchingGraphArray);
  [v4 setFunctionGraphs:v6];

  id ObjectArrayWithMap = CreateObjectArrayWithMap(*(uint64_t **)(a1 + 8), *(unsigned __int16 *)(a1 + 18), v3);
  uint64_t v8 = (void *)objc_claimAutoreleasedReturnValue(ObjectArrayWithMap);

  [v4 setFunctions:v8];
  return v4;
}

id MakeMTLAccelerationStructureAllocationDescriptor(uint64_t a1)
{
  id v2 = objc_alloc_init(&OBJC_CLASS___MTLAccelerationStructureAllocationDescriptor);
  [v2 setStorageMode:*(unsigned __int8 *)(a1 + 9)];
  [v2 setForceResourceIndex:*(void *)a1 != 0];
  [v2 setResourceIndex:*(void *)a1];
  return v2;
}

id ValidateLibrary(void *a1)
{
  id v1 = a1;
  if ((dword_5B9DE4 & 0x80000) != 0)
  {
    id v2 = (void *)objc_claimAutoreleasedReturnValue(+[NSProcessInfo processInfo](&OBJC_CLASS___NSProcessInfo, "processInfo"));
    id v3 = v2;
    if (v2)
    {
      [v2 operatingSystemVersion];
      uint64_t v4 = v11;
      [v3 operatingSystemVersion];
      uint64_t v5 = v10;
      [v3 operatingSystemVersion];
      uint64_t v6 = v9;
    }

    else
    {
      uint64_t v6 = 0LL;
      uint64_t v5 = 0LL;
      uint64_t v4 = 0LL;
    }

    unint64_t v7 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"air64-apple-%s%ld.%ld.%ld",  "tvos",  v4,  v5,  v6));
    [v1 setOverrideTriple:v7];
  }

  return v1;
}

id MTLDevice_newLibraryWithFile(void *a1, uint64_t a2, void *a3)
{
  id v9 = 0LL;
  id v4 = [a1 newLibraryWithURL:a2 error:&v9];
  id v5 = v9;
  uint64_t v6 = v5;
  if (a3) {
    *a3 = v5;
  }
  id v7 = ValidateLibrary(v4);
  objc_claimAutoreleasedReturnValue(v7);

  return v4;
}

id MTLDevice_newLibraryWithData(void *a1, uint64_t a2, void *a3)
{
  id v9 = 0LL;
  id v4 = [a1 newLibraryWithData:a2 error:&v9];
  id v5 = v9;
  uint64_t v6 = v5;
  if (a3) {
    *a3 = v5;
  }
  id v7 = ValidateLibrary(v4);
  objc_claimAutoreleasedReturnValue(v7);

  return v4;
}

void GTMTLReplay_commitCommandBuffer(void *a1)
{
  id v1 = a1;
  if (v1)
  {
    id v2 = v1;
    LogCommandBuffer(@"Committed", v1);
    AddHandlers(v2);
    [v2 commit];
    id v1 = v2;
    if ((dword_5B9DE4 & 2) != 0)
    {
      [v2 waitUntilCompleted];
      id v1 = v2;
    }
  }
}

void LogCommandBuffer(void *a1, void *a2)
{
  id v4 = a1;
  id v5 = a2;
  uint64_t v6 = v5;
  if (s_logUsingOsLog)
  {
    id v7 = gt_tagged_log(0LL);
    uint64_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue(v7);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_INFO))
    {
      id v9 = (void *)objc_claimAutoreleasedReturnValue([v6 label]);
      if (v9)
      {
        id v2 = objc_claimAutoreleasedReturnValue([v6 label]);
        uint64_t v10 = (const char *)[v2 UTF8String];
      }

      else
      {
        uint64_t v10 = "no label";
      }

      *(_DWORD *)buf = 138412802;
      id v15 = v4;
      __int16 v16 = 2048;
      int v17 = v6;
      __int16 v18 = 2080;
      __int128 v19 = v10;
      _os_log_impl(&dword_0, v8, OS_LOG_TYPE_INFO, "%@: %lx (%s)", buf, 0x20u);
      if (v9) {
    }
      }
  }

  else
  {
    uint64_t v11 = __stdoutp;
    uint64_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue([v5 label]);
    if (v8)
    {
      id v2 = objc_claimAutoreleasedReturnValue([v6 label]);
      id v12 = (const char *)[v2 UTF8String];
    }

    else
    {
      id v12 = "no label";
    }

    id v13 = objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString, "stringWithFormat:", @"%@: %lx (%s)", v4, v6, v12));
    fprintf(v11, "%s\n", (const char *)[v13 UTF8String]);

    if (v8) {
  }
    }
}

void AddHandlers(void *a1)
{
  id v1 = a1;
  [v1 addCompletedHandler:&__block_literal_global_36];
}

void GTMTLReplay_commitCommandBufferAndWaitUntilSubmitted(void *a1)
{
  id v1 = a1;
  if (v1)
  {
    id v2 = v1;
    LogCommandBuffer(@"Commit and wait until submitted", v1);
    AddHandlers(v2);
    [v2 commitAndWaitUntilSubmitted];
    id v1 = v2;
    if ((dword_5B9DE4 & 2) != 0)
    {
      [v2 waitUntilCompleted];
      id v1 = v2;
    }
  }
}

id PreferDevice(uint64_t a1)
{
  uint64_t Object = GTMTLSMContext_getObject(**(void **)(a1 + 40), 1LL, *(void *)(a1 + 80));
  unsigned int v3 = (dword_5B9DE4 >> 19) & 1;
  if (*(_BYTE *)(Object[5] + 102LL) != 3) {
    unsigned int v3 = 1;
  }
  if (v3) {
    int v4 = 0x80000;
  }
  else {
    int v4 = 0;
  }
  dword_5B9DE4 = v4 | dword_5B9DE4 & 0xFFF7FFFF;
  size_t FileWithFilename = GTCaptureArchive_getFileWithFilename(*(void *)a1, "is_almond");
  unsigned int v6 = (dword_5B9DE4 >> 19) & 1;
  if (FileWithFilename) {
    unsigned int v6 = 1;
  }
  if (v6) {
    int v7 = 0x80000;
  }
  else {
    int v7 = 0;
  }
  dword_5B9DE4 = v7 | dword_5B9DE4 & 0xFFF7FFFF;
  id v8 = MTLCreateSystemDefaultDevice();
  id v9 = DEVICEOBJECT(v8);
  uint64_t v10 = (void *)objc_claimAutoreleasedReturnValue(v9);
  char v11 = objc_opt_respondsToSelector(v10, "setShaderDebugInfoCaching:");

  if ((v11 & 1) != 0) {
    [v8 setShaderDebugInfoCaching:1];
  }
  if ((dword_5B9DE4 & 0x80000) != 0)
  {
    id v12 = DEVICEOBJECT(v8);
    id v13 = (void *)objc_claimAutoreleasedReturnValue(v12);
    char v14 = objc_opt_respondsToSelector(v13, "allowLibrariesFromOtherPlatforms");

    if ((v14 & 1) != 0) {
      [v8 allowLibrariesFromOtherPlatforms];
    }
  }

  return v8;
}

uint64_t CleanupSandboxExtensionURL(void *a1)
{
  return 0LL;
}

BOOL BeginDebugArchivePath(apr_pool_t **a1, void *a2, void *a3, void *a4, void *a5)
{
  id v9 = a2;
  id v10 = a3;
  id v11 = a4;
  id v12 = a5;
  id v13 = a1;
  char v14 = v12;
  id v15 = v9;
  DataSource = GTMTLReplayController_makeDataSource((const char *)[v15 UTF8String], *a1);
  int v17 = DataSource;
  if (!DataSource)
  {
    v14[2](v14, 0LL);
    goto LABEL_107;
  }

  uint64_t v139 = v14;
  unint64_t v141 = v10;
  id v18 = PreferDevice((uint64_t)DataSource);
  __int128 v19 = (void *)objc_claimAutoreleasedReturnValue(v18);
  uint64_t v138 = v13;
  uint64_t v20 = *v13;
  id v137 = v19;
  id v21 = (void *)objc_claimAutoreleasedReturnValue(+[NSProcessInfo processInfo](&OBJC_CLASS___NSProcessInfo, "processInfo"));
  id v22 = objc_claimAutoreleasedReturnValue([v21 operatingSystemVersionString]);
  id v23 = apr_pstrdup(v20, (const char *)[v22 UTF8String]);

  int v24 = apr_palloc(v20, 0x30uLL);
  id v25 = v24;
  if (v24)
  {
    _OWORD *v24 = 0u;
    v24[1] = 0u;
  }

  *((void *)v24 + 4) = "iOS";
  *((void *)v24 + 5) = v23;
  id v26 = (void *)objc_claimAutoreleasedReturnValue([v137 targetDeviceArchitecture]);
  *(_DWORD *)id v25 = [v26 cpuType];
  *((_DWORD *)v25 + 1) = [v26 subType];
  *((_WORD *)v25 + 4) = (unsigned __int16)[v26 version];
  *((_BYTE *)v25 + 10) = [v26 version] >> 16;
  *((_BYTE *)v25 + 11) = [v26 version] >> 24;
  *((_DWORD *)v25 + 3) = [v26 versionCombined];
  *((void *)v25 + 2) = [v26 driverVersion];

  if (*(_DWORD *)v25 != 16777235) {
    goto LABEL_45;
  }
  uint64_t v27 = 0LL;
  unsigned int v28 = *((_DWORD *)v25 + 1) & 0xFFFFFF;
  if (v28 <= 0x162)
  {
    if ((*((_DWORD *)v25 + 1) & 0xFFFFFFu) <= 0xD1)
    {
      if ((*((_DWORD *)v25 + 1) & 0xFFFFFFu) > 0xA2)
      {
        if (v28 != 163 && v28 != 179)
        {
          if (v28 != 194) {
            goto LABEL_45;
          }
          goto LABEL_46;
        }
      }

      else if (v28 - 67 > 0x30 || ((1LL << (v28 - 67)) & 0x1000100010001LL) == 0)
      {
        goto LABEL_45;
      }
    }

    else
    {
      char v29 = *((_BYTE *)v25 + 4) + 29;
      if (v28 - 227 > 0x3F) {
        goto LABEL_8;
      }
      if (((1LL << v29) & 0x100010000LL) != 0) {
        goto LABEL_42;
      }
      if (((1LL << v29) & 0x1000000000001LL) == 0)
      {
        if (((1LL << v29) & 0x8000800000000000LL) != 0) {
          goto LABEL_46;
        }
LABEL_8:
        uint64_t v30 = v28 - 291;
        if (((1LL << (v28 - 35)) & 0x100000001LL) == 0)
        {
          if (v30 != 48)
          {
LABEL_12:
            if (v28 != 210) {
              goto LABEL_45;
            }
            goto LABEL_46;
          }

LABEL_108:
    uint64_t v27 = 1LL;
    goto LABEL_46;
  }

  if ((*((_DWORD *)v25 + 1) & 0xFFFFFFu) > 0x1B2)
  {
    if ((*((_DWORD *)v25 + 1) & 0xFFFFFFu) > 0x231)
    {
      unsigned int v32 = v28 - 562;
      if (v32 <= 0x30 && ((1LL << v32) & 0x1000100010001LL) != 0) {
        goto LABEL_46;
      }
      goto LABEL_45;
    }

    if (v28 != 435)
    {
      if (v28 != 482) {
        goto LABEL_45;
      }
      goto LABEL_46;
    }

    goto LABEL_42;
  }

  uint64_t v31 = v28 - 355;
  if (v31 <= 0x3F)
  {
    if (v31 == 48)
    {
LABEL_42:
      uint64_t v27 = 2LL;
      goto LABEL_46;
    }
  }

  if (v28 == 419) {
    goto LABEL_108;
  }
  if (v28 != 434) {
LABEL_45:
  }
    uint64_t v27 = 0xFFFFFFFFLL;
LABEL_46:
  *((void *)v25 + 3) = v27;

  id v136 = v11;
  uint64_t v147 = v17;
  unint64_t v140 = v15;
  if (*((void *)v17 + 6))
  {
    uint64_t v153 = objc_alloc_init(&OBJC_CLASS___GTCaptureArchiveOverrideKey);
    __int128 v160 = 0u;
    __int128 v161 = 0u;
    __int128 v162 = 0u;
    __int128 v163 = 0u;
    obuint64_t j = (id)objc_claimAutoreleasedReturnValue([*((id *)v17 + 6) filenameOverrides]);
    id v150 = [obj countByEnumeratingWithState:&v160 objects:v164 count:16];
    if (v150)
    {
      uint64_t v148 = *(void *)v161;
      unsigned int v145 = v25;
      do
      {
        for (unint64_t i = 0LL; i != v150; unint64_t i = (char *)i + 1)
        {
          if (*(void *)v161 != v148) {
            objc_enumerationMutation(obj);
          }
          uint64_t v34 = *(void *)(*((void *)&v160 + 1) + 8LL * (void)i);
          uint64_t v35 = (void *)objc_claimAutoreleasedReturnValue([*((id *)v17 + 6) filenameOverrides]);
          unint64_t v36 = (void *)objc_claimAutoreleasedReturnValue([v35 objectForKeyedSubscript:v34]);

          uint64_t v37 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithUTF8String:]( &OBJC_CLASS___NSString,  "stringWithUTF8String:",  *((void *)v25 + 4)));
          -[GTCaptureArchiveOverrideKey setPlatform:](v153, "setPlatform:", v37);
          id v38 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  *((void *)v25 + 3)));
          -[GTCaptureArchiveOverrideKey setRiaGeneration:](v153, "setRiaGeneration:", v38);

          id v39 = (void *)objc_claimAutoreleasedReturnValue([v36 objectForKeyedSubscript:v153]);
          if (v39) {
            goto LABEL_55;
          }
          -[GTCaptureArchiveOverrideKey setPlatform:](v153, "setPlatform:", 0LL);
          uint64_t v40 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  *((void *)v25 + 3)));
          -[GTCaptureArchiveOverrideKey setRiaGeneration:](v153, "setRiaGeneration:", v40);

          id v39 = (void *)objc_claimAutoreleasedReturnValue([v36 objectForKeyedSubscript:v153]);
          if (v39
            || (-[GTCaptureArchiveOverrideKey setPlatform:](v153, "setPlatform:", v37),
                -[GTCaptureArchiveOverrideKey setRiaGeneration:](v153, "setRiaGeneration:", 0LL),
                (id v39 = (void *)objc_claimAutoreleasedReturnValue([v36 objectForKeyedSubscript:v153])) != 0))
          {
LABEL_55:
            id v156 = v37;
            uint64_t v41 = *(void *)v17;
            id v42 = objc_claimAutoreleasedReturnValue([v39 originalFilename]);
            unint64_t v43 = (const char *)[v42 UTF8String];
            id v44 = objc_claimAutoreleasedReturnValue([v39 overrideFilename]);
            uint64_t v45 = (const char *)[v44 UTF8String];
            apr_pool_create_ex((apr_pool_t **)&newpool, *(apr_pool_t **)(v41 + 8), 0LL, v46);
            uint64_t v47 = (apr_pool_t *)newpool;
            uint64_t v48 = gt_filepath_merge(*(const char **)v41, v45, (apr_pool_t *)newpool);
            uint64_t v49 = fopen(v48, "r");
            uint64_t v50 = v49;
            if (v49)
            {
              int v51 = fileno(v49);
              if (!fstat(v51, &v174))
              {
                key = apr_pstrdup(*(apr_pool_t **)(v41 + 8), v43);
                unint64_t v52 = apr_pstrdup(*(apr_pool_t **)(v41 + 8), v45);
                uint64_t v53 = *(apr_array_header_t **)(v41 + 48);
                int nelts = v53->nelts;
                *(void *)apr_array_push(v53) = v52;
                LODWORD(v52) = (LODWORD(v174.st_size) + vm_page_size - 1) & -(int)vm_page_size;
                uint64_t v55 = apr_array_push(*(apr_array_header_t **)(v41 + 80));
                _DWORD *v55 = (_DWORD)v52;
                v55[1] = nelts;
                *((void *)v55 + 1) = 0LL;
                *((void *)v55 + 2) = 2LL;
                apr_hash_set(*(apr_hash_t **)(v41 + 88), key, -1LL, v55);
              }
            }

            fclose(v50);
            apr_pool_destroy(v47);

            id v25 = v145;
            int v17 = v147;
            uint64_t v37 = v156;
          }
        }

        id v150 = [obj countByEnumeratingWithState:&v160 objects:v164 count:16];
      }

      while (v150);
    }
  }

  id v56 = v137;
  id v57 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
  for (uint64_t j = 0LL; j != 17; ++j)
  {
    uint64_t v59 = qword_316D40[j];
    if ([v56 supportsFamily:v59])
    {
      id v60 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithInteger:](&OBJC_CLASS___NSNumber, "numberWithInteger:", v59));
      -[NSMutableArray addObject:](v57, "addObject:", v60);
    }
  }

  *(void *)&__int128 newpool = @"argumentBuffersSupport";
  uint64_t v157 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedInteger:]( NSNumber,  "numberWithUnsignedInteger:",  [v56 argumentBuffersSupport]));
  *(void *)&v174.st_dev = v157;
  *((void *)&newpool + 1) = @"supportsTLS";
  if ((objc_opt_respondsToSelector(v56, "supportsTLS") & 1) != 0) {
    id v61 = [v56 supportsTLS];
  }
  else {
    id v61 = 0LL;
  }
  char v154 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", v61));
  v174.st_ino = (__darwin_ino64_t)v154;
  *(void *)&__int128 v170 = @"supportsGlobalVariableRelocation";
  if ((objc_opt_respondsToSelector(v56, "supportsGlobalVariableRelocation") & 1) != 0) {
    id v62 = [v56 supportsGlobalVariableRelocation];
  }
  else {
    id v62 = 0LL;
  }
  unint64_t v151 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", v62));
  *(void *)&v174.st_uid = v151;
  *((void *)&v170 + 1) = @"supportsGlobalVariableRelocationCompute";
  if ((objc_opt_respondsToSelector(v56, "supportsGlobalVariableRelocationCompute") & 1) != 0) {
    id v63 = [v56 supportsGlobalVariableRelocationCompute];
  }
  else {
    id v63 = 0LL;
  }
  BOOL v64 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", v63));
  *(void *)&v174.st_rdev = v64;
  *(void *)&__int128 v171 = @"supportsGlobalVariableRelocationRender";
  if ((objc_opt_respondsToSelector(v56, "supportsGlobalVariableRelocationRender") & 1) != 0) {
    id v65 = [v56 supportsGlobalVariableRelocationRender];
  }
  else {
    id v65 = 0LL;
  }
  double v66 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", v65));
  v174.st_atimespec.tv_sec = (__darwin_time_t)v66;
  *((void *)&v171 + 1) = @"supportsDynamicLibraries";
  if ((objc_opt_respondsToSelector(v56, "supportsDynamicLibraries") & 1) != 0) {
    id v67 = [v56 supportsDynamicLibraries];
  }
  else {
    id v67 = 0LL;
  }
  double v68 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", v67));
  v174.st_atimespec.tv_nsec = (uint64_t)v68;
  *(void *)&__int128 v172 = @"supportsRenderDynamicLibraries";
  if ((objc_opt_respondsToSelector(v56, "supportsRenderDynamicLibraries") & 1) != 0) {
    id v69 = [v56 supportsRenderDynamicLibraries];
  }
  else {
    id v69 = 0LL;
  }
  uint64_t v70 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", v69));
  v174.st_mtimespec.tv_sec = (__darwin_time_t)v70;
  *((void *)&v172 + 1) = @"supportsFunctionPointers";
  else {
    id v71 = 0LL;
  }
  uint64_t v72 = v56;
  id v73 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", v71));
  v174.st_mtimespec.tv_nsec = (uint64_t)v73;
  unsigned int v173 = @"supportsFunctionPointersFromRender";
  else {
    id v74 = 0LL;
  }
  double v75 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", v74));
  v174.st_ctimespec.tv_sec = (__darwin_time_t)v75;
  double v76 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v174,  &newpool,  9LL));

  v167[0] = @"shaderDebuggerSupport";
  v167[1] = @"deviceVendorName";
  v168[0] = &off_5A05C8;
  uint64_t v77 = (void *)objc_claimAutoreleasedReturnValue([v72 vendorName]);
  v168[1] = v77;
  unint64_t v78 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v168,  v167,  2LL));

  BOOL v79 = [v72 argumentBuffersSupport] != 0;
  LODWORD(v77) = objc_opt_respondsToSelector(v72, "sparseTileSizeInBytesForSparsePageSize:");
  unsigned int v80 = [v72 supportsFamily:1006];
  v165[0] = @"SupportedFamilies";
  v165[1] = @"FeatureSupport";
  v166[0] = v57;
  v166[1] = v76;
  v166[2] = v78;
  v165[2] = @"DebugSupport";
  v165[3] = @"ResourceAccessTrackingSupport";
  uint64_t v81 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithBool:](&OBJC_CLASS___NSNumber, "numberWithBool:", v79 & v80 & v77));
  v166[3] = v81;
  uint64_t v82 = objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v166,  v165,  4LL));

  unint64_t v158 = v72;
  int v155 = (void *)v82;
  v139[2](v139, v82);
  id v83 = v140;
  id v84 = -[NSURL initFileURLWithPath:isDirectory:]( objc_alloc(&OBJC_CLASS___NSURL),  "initFileURLWithPath:isDirectory:",  v83,  1LL);

  unsigned int v85 = -[NSURL initWithString:relativeToURL:]( objc_alloc(&OBJC_CLASS___NSURL),  "initWithString:relativeToURL:",  @"metadata",  v84);
  int v86 = -[NSDictionary initWithContentsOfURL:error:]( objc_alloc(&OBJC_CLASS___NSDictionary),  "initWithContentsOfURL:error:",  v85,  0LL);

  id v87 = v138[35];
  uint64_t v152 = v86;
  id v88 = (void *)objc_claimAutoreleasedReturnValue( -[NSDictionary objectForKeyedSubscript:]( v86,  "objectForKeyedSubscript:",  @"DYCaptureEngine.launch_dictionary"));
  uint64_t v89 = (void *)objc_claimAutoreleasedReturnValue([v88 objectForKeyedSubscript:@"title"]);
  -[apr_pool_t setWindowTitle:](v87, "setWindowTitle:", v89);

  uint64_t v90 = objc_alloc_init(&OBJC_CLASS___NSMutableDictionary);
  uint64_t v91 = *(void *)(*((void *)v147 + 5) + 88LL);
  int v92 = *(_DWORD *)(v91 + 12);
  if (v92 >= 1)
  {
    for (uint64_t k = 0LL; k < v92; ++k)
    {
      uint64_t v94 = *(void *)(*(void *)(v91 + 24) + 8 * k);
      if (*(void *)(v94 + 128))
      {
        unint64_t v95 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  *(void *)(v94 + 8)));
        uint64_t v96 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithUTF8String:]( &OBJC_CLASS___NSString,  "stringWithUTF8String:",  *(void *)(v94 + 128)));
        -[NSMutableDictionary setObject:forKey:](v90, "setObject:forKey:", v95, v96);

        int v92 = *(_DWORD *)(v91 + 12);
      }
    }
  }

  id v97 = v141;
  uint64_t v98 = v90;
  v149 = v97;
  uint64_t v99 = -[NSURL initFileURLWithPath:](objc_alloc(&OBJC_CLASS___NSURL), "initFileURLWithPath:", v97);
  int v100 = -[NSMutableDictionary initWithCapacity:]( objc_alloc(&OBJC_CLASS___NSMutableDictionary),  "initWithCapacity:",  -[NSMutableDictionary count](v98, "count"));
  id v101 = (void *)objc_claimAutoreleasedReturnValue(+[NSFileManager defaultManager](&OBJC_CLASS___NSFileManager, "defaultManager"));
  v166[0] = NSURLNameKey;
  double v102 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", v166, 1LL));
  id obja = v101;
  unint64_t v146 = v99;
  double v103 = (void *)objc_claimAutoreleasedReturnValue( [v101 enumeratorAtURL:v99 includingPropertiesForKeys:v102 options:0 errorHandler:0]);

  __int128 v171 = 0u;
  __int128 v172 = 0u;
  __int128 newpool = 0u;
  __int128 v170 = 0u;
  id v104 = v103;
  id v105 = [v104 countByEnumeratingWithState:&newpool objects:&v174 count:16];
  if (v105)
  {
    id v106 = v105;
    uint64_t v107 = *(void *)v170;
    do
    {
      for (uint64_t m = 0LL; m != v106; uint64_t m = (char *)m + 1)
      {
        if (*(void *)v170 != v107) {
          objc_enumerationMutation(v104);
        }
        id v109 = *(void **)(*((void *)&newpool + 1) + 8LL * (void)m);
        unint64_t v110 = (void *)objc_claimAutoreleasedReturnValue([v109 pathExtension]);
        unsigned int v111 = [v110 isEqualToString:@"metallib"];

        if (v111)
        {
          id v112 = (void *)objc_claimAutoreleasedReturnValue([v109 lastPathComponent]);
          id v113 = (void *)objc_claimAutoreleasedReturnValue([v112 stringByDeletingPathExtension]);

          id v114 = (void *)objc_claimAutoreleasedReturnValue(-[NSMutableDictionary objectForKeyedSubscript:](v98, "objectForKeyedSubscript:", v113));
          if (v114) {
            -[NSMutableDictionary setObject:forKeyedSubscript:](v100, "setObject:forKeyedSubscript:", v109, v114);
          }
        }
      }

      id v106 = [v104 countByEnumeratingWithState:&newpool objects:&v174 count:16];
    }

    while (v106);
  }

  id v11 = v136;
  UpdateDebugFileCache(v136, v100, v98, v149);
  unsigned __int8 v115 = -[GTMTLReplayObjectMap initWithDevice:]( objc_alloc(&OBJC_CLASS___GTMTLReplayObjectMap),  "initWithDevice:",  v158);
  GTMTLReplaySupport_init(v158);
  int v17 = v147;
  GTMTLReplayController_initializeArgumentBufferSupport((uint64_t)v147, v158, v115);
  GTMTLReplayController_populateUnusedResources(v147, v115);
  v138[1] = (apr_pool_t *)GTMTLReplayController_makeController((uint64_t)v147, *v138, v158, v115, v98, v100);
  GTMTLReplayWireframeRenderer_initWithDevice((uint64_t)(v138 + 12), v158);
  -[apr_pool_t setOrientation:]( v138[35],  "setOrientation:",  -[GTMTLReplayObjectMap interfaceOrientation](v115, "interfaceOrientation"));
  -[apr_pool_t setDevice:](v138[35], "setDevice:", v158);
  id v116 = v138[35];
  -[GTMTLReplayObjectMap contentRect](v115, "contentRect");
  double v118 = v117;
  double v120 = v119;
  double v122 = v121;
  double v124 = v123;
  -[GTMTLReplayObjectMap windowRect](v115, "windowRect");
  double v126 = v125;
  double v128 = v127;
  double v130 = v129;
  double v132 = v131;
  uint64_t v133 = (void *)objc_claimAutoreleasedReturnValue(-[GTMTLReplayObjectMap windowProperties](v115, "windowProperties"));
  -[apr_pool_t setContentRect:windowRect:properties:]( v116,  "setContentRect:windowRect:properties:",  v133,  v118,  v120,  v122,  v124,  v126,  v128,  v130,  v132);

  v159[0] = _NSConcreteStackBlock;
  v159[1] = 3221225472LL;
  v159[2] = __BeginDebugArchivePath_block_invoke;
  v159[3] = &__block_descriptor_40_e5_v8__0l;
  v159[4] = v138;
  uint64_t v134 = (void *)objc_claimAutoreleasedReturnValue( +[NSBlockOperation blockOperationWithBlock:]( &OBJC_CLASS___NSBlockOperation,  "blockOperationWithBlock:",  v159));
  [v134 setQueuePriority:-8];
  -[apr_pool_t addOperation:](v138[32], "addOperation:", v134);

  id v15 = v140;
  id v10 = v141;
  char v14 = v139;
LABEL_107:

  return v17 != 0LL;
}

      if (v86 == v85
        || v86 - v83 == -8
        || ShaderDebugger::Metadata::MDSerializer::isMetadataIdReserved((char **)v81 + 5, a2))
      {
        id v87 = ShaderDebugger::Metadata::MDSerializer::addAndLinearizeMetadataId(v84, a2);
        ShaderDebugger::Metadata::MDSerializer::serializeTypeBase( (unint64_t *)v82 + 11,  v87,  (uint64_t)&__dst,  v76,  v79,  v77,  v78,  Tag,  0LL);
        ShaderDebugger::Metadata::MDSerializer::write<unsigned int>((unint64_t *)v82 + 11, __p);
      }

      if (SHIBYTE(v197) < 0) {
        operator delete(__dst);
      }
      return v40;
    case 0xC:
      v189[0] = 0LL;
      v189[1] = 0LL;
      id v188 = v189;
      std::set<llvm::DIType *>::insert[abi:nn180100]<std::__tree_const_iterator<llvm::DIType *,std::__tree_node<llvm::DIType *,void *> *,long>>( (uint64_t *)&v188,  *a3,  v7);
      uint64_t v41 = *(unsigned int *)(a2 + 8);
      id v42 = *(void *)(a2 - 8 * v41 + 24);
      if (v42)
      {
        id v196 = 0LL;
        id v197 = 0LL;
        __dst = &v196;
        std::set<llvm::DIType *>::insert[abi:nn180100]<std::__tree_const_iterator<llvm::DIType *,std::__tree_node<llvm::DIType *,void *> *,long>>( (uint64_t *)&__dst,  v188,  v189);
        unint64_t v43 = ShaderDebugger::Metadata::MDSerializerLLVM3XXX::serializeType(v5, v42, &__dst);
        std::__tree<llvm::DIType *>::destroy(v196);
        id v44 = -(uint64_t)*(unsigned int *)(a2 + 8);
      }

      else
      {
        id v44 = -v41;
        unint64_t v43 = -1LL;
      }

      id v106 = *(void *)(a2 + 52);
      uint64_t v107 = v106;
      id v182 = v107;
      id v108 = *(llvm::MDString **)(a2 + 8 * v44 + 16);
      if (v108 && (id v109 = (void *)llvm::MDString::getString(v108)) != 0LL)
      {
        unsigned int v111 = v21;
        std::string::basic_string[abi:nn180100](&v192, v109, v110);
      }

      else
      {
        unsigned int v111 = v21;
        id v192 = 0LL;
        id v193 = 0LL;
        id v194 = 0LL;
      }

      id v112 = *(unsigned int *)(a2 + 28);
      id v113 = *(unsigned int *)(a2 + 48);
      unsigned __int8 v115 = *(void *)(a2 + 32);
      id v114 = *(void *)(a2 + 40);
      id v116 = llvm::DINode::getTag((llvm::DINode *)a2);
      __p[0] = (void *)v43;
      v199[0] = 3LL;
      double v117 = std::__tree<std::__value_type<ShaderDebugger::Metadata::MDBase::MetadataType,ShaderDebugger::Metadata::MDSerializer::MetadataTypeContainer>,std::__map_value_compare<ShaderDebugger::Metadata::MDBase::MetadataType,std::__value_type<ShaderDebugger::Metadata::MDBase::MetadataType,ShaderDebugger::Metadata::MDSerializer::MetadataTypeContainer>,std::less<ShaderDebugger::Metadata::MDBase::MetadataType>,true>,std::allocator<std::__value_type<ShaderDebugger::Metadata::MDBase::MetadataType,ShaderDebugger::Metadata::MDSerializer::MetadataTypeContainer>>>::__emplace_unique_key_args<ShaderDebugger::Metadata::MDBase::MetadataType,std::piecewise_construct_t const&,std::tuple<ShaderDebugger::Metadata::MDBase::MetadataType&&>,std::tuple<>>( v181,  3uLL,  v199);
      double v118 = v117;
      double v120 = (uint64_t)(v117 + 40);
      double v119 = (char *)*((void *)v117 + 5);
      double v121 = (char *)*((void *)v117 + 6);
      double v122 = v119;
      if (v119 == v121) {
        goto LABEL_146;
      }
      while (*(void *)v122 != a2)
      {
        v122 += 8;
        if (v122 == v121)
        {
          double v122 = (char *)*((void *)v117 + 6);
          break;
        }
      }

void __BeginDebugArchivePath_block_invoke(uint64_t a1)
{
}

uint64_t CleanupSandboxExtension(void *a1)
{
  return 0LL;
}

void sub_88E54( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
}

LABEL_24:
      ++v18;
      id v73 = (void *)objc_claimAutoreleasedReturnValue([v4 requests]);
      id v74 = [v73 count];
    }

    while ((unint64_t)v74 > v18);
  }

  double v75 = objc_alloc(&OBJC_CLASS___GTReplayerOperation);
  v90[0] = _NSConcreteStackBlock;
  v90[1] = 3221225472LL;
  v90[2] = __28__GTMTLReplayService_query___block_invoke_5_80;
  v90[3] = &unk_58DBE8;
  uint64_t v91 = group;
  int v92 = v8;
  uint64_t v93 = v4;
  uint64_t v94 = v83;
  double v76 = v4;
  uint64_t v77 = v8;
  unint64_t v78 = group;
  BOOL v79 = -[GTReplayerOperation initWithBatch:withBlock:](v75, "initWithBatch:withBlock:", v5, v90);
  -[GTReplayerOperationBatch addOperation:](v5, "addOperation:", v79);
  -[GTReplayerOperationBatch finish:](v5, "finish:", clientContext->var7.var0);

  return 0LL;
}

  if ((v25 & 6) == 0)
  {
    id v38 = (void *)objc_claimAutoreleasedReturnValue([v217 renderPipelineDescriptorMap]);
    id v39 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  *(void *)(v18 + 120)));
    uint64_t v40 = (void *)objc_claimAutoreleasedReturnValue([v38 objectForKeyedSubscript:v39]);

    if (v40) {
      uint64_t v41 = [v221 loadDynamicLibrariesForFunction:v40 insertLibraries:&__NSArray0__struct error:0];
    }
    else {
      uint64_t v41 = 0LL;
    }
    if ([v41 count])
    {
      id v104 = (void *)objc_claimAutoreleasedReturnValue([v20 preloadedLibraries]);
      id v105 = [v104 mutableCopy];

      [v105 addObjectsFromArray:v41];
      id v106 = [v105 copy];
      [v20 setPreloadedLibraries:v106];

      int v24 = v221;
      uint64_t v107 = (char *)[v105 count];
      else {
        id v108 = *(unsigned __int16 *)(v18 + 130);
      }
      [v20 setMaxCallStackDepth:&v107[v108]];
    }

    id v23 = (void *)v220;
  }

  __int128 v228 = 0LL;
  unint64_t v229 = 0LL;
  id v109 = [v24 newRenderPipelineStateWithTileDescriptor:v20 options:0x200000 reflection:&v229 error:&v228];
  unint64_t v110 = v229;
  id v67 = (unsigned __int16 *)v228;
LABEL_170:

  if (!v109)
  {
LABEL_182:
    if (a2)
    {
      id v196 = (void *)objc_claimAutoreleasedReturnValue([v67 description]);
      if ([v196 localizedCaseInsensitiveContainsString:@"Undefined symbol"])
      {
        *a2 = v67;
      }

      else
      {
        if ((*(void *)(v220 + 208) & 0x10LL) != 0) {
          id v197 = 4;
        }
        else {
          id v197 = 2;
        }
        id Error = GTShaderDebuggerMakeError( v197,  @"Failed to set up render pipeline state for debugging",  0LL,  v67,  0LL);
        v199 = objc_claimAutoreleasedReturnValue(Error);
        *a2 = v199;
      }
    }

    goto LABEL_190;
  }

  id v190 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLongLong:](&OBJC_CLASS___NSNumber, "numberWithUnsignedLongLong:", v218));
  [v11 setObject:v109 forKeyedSubscript:v190];

  id v191 = [v110 traceBufferIndex];
  if (v191 == -1) {
    CurrentEncoderFreeBindingSlotIndex = 0x7FFFFFFFFFFFFFFFLL;
  }
  else {
    CurrentEncoderFreeBindingSlotIndex = v191;
  }
  if ((v23[26] & 2) != 0) {
    CurrentEncoderFreeBindingSlotIndex = _GetCurrentEncoderFreeBindingSlotIndex(v23 + 1);
  }
  if (CurrentEncoderFreeBindingSlotIndex == 0x7FFFFFFFFFFFFFFFLL && (v23[26] & 4) == 0)
  {
    if (a2)
    {
      id v193 = GTShaderDebuggerMakeError(1u, @"Internal error: Failed to set up GPU data buffer", 0LL, 0LL, 0LL);
      id v194 = 0LL;
      *a2 = (id)objc_claimAutoreleasedReturnValue(v193);
      goto LABEL_199;
    }
}

LABEL_49:
      id v15 = (char *)v15 + 1;
    }

    while (v14 != v15);
    id v105 = [obj countByEnumeratingWithState:&v141 objects:v161 count:16];
    char v14 = v105;
  }

  while (v105);
LABEL_56:

  id v5 = v116;
  id v106 = (void *)objc_claimAutoreleasedReturnValue([v116 completionHandler]);
  v132[0] = _NSConcreteStackBlock;
  v132[1] = 3221225472LL;
  v132[2] = __28__GTMTLReplayService_fetch___block_invoke;
  v132[3] = &unk_58DC10;
  uint64_t v133 = v116;
  uint64_t v134 = v127;
  __int128 v135 = v117;
  id v136 = v106;
  uint64_t v107 = v117;
  id v108 = v127;
  id v109 = v106;
  unint64_t v110 = v128;
  FetchResourceObjectBatch((uint64_t)clientContext, v128, 0LL, v132);

LABEL_58:
  return 0LL;
}

        self->_processedBatches.__end_ = v26;
        std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long>>>::~__hash_table((uint64_t)&v128);
        id v38 = (float *)self->_processedBatches.__end_;
        id v39 = *((void *)v38 - 4);
        if (v39) {
          uint64_t v40 = (float)*((unint64_t *)v38 - 2) / (float)v39;
        }
        else {
          uint64_t v40 = 0.0;
        }
        *(v38 - 2) = fmaxf(v40, 0.4);
        std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__rehash<true>( (uint64_t)(v38 - 10),  vcvtps_u32_f32((float)(unint64_t)[v9 count] / *(v38 - 2)));
        uint64_t v41 = self->_perEncoderBatchQueue.__end_;
        double v124 = 0u;
        double v125 = 0u;
        double v126 = 0u;
        double v127 = 0u;
        id v42 = v9;
        unint64_t v43 = [v42 countByEnumeratingWithState:&v124 objects:v136 count:16];
        if (v43)
        {
          id v44 = v41 - 6;
          double v120 = v42;
          double v121 = *(void *)v125;
          uint64_t v45 = (char **)(v41 - 3);
          double v119 = v8;
          do
          {
            unint64_t v46 = 0LL;
            double v122 = v43;
            do
            {
              if (*(void *)v125 != v121) {
                objc_enumerationMutation(v42);
              }
              double v123 = v7;
              uint64_t v47 = [*(id *)(*((void *)&v124 + 1) + 8 * (void)v46) unsignedIntValue];
              uint64_t v48 = (char *)*(v41 - 4);
              uint64_t v49 = (char *)*(v41 - 5);
              if (v48 == v49) {
                uint64_t v50 = 0LL;
              }
              else {
                uint64_t v50 = ((v48 - v49) << 7) - 1;
              }
              unint64_t v52 = *(v41 - 2);
              int v51 = *(v41 - 1);
              uint64_t v53 = v51 + v52;
              if (v50 == v51 + v52)
              {
                if (v52 >= 0x400)
                {
                  *(v41 - 2) = v52 - 1024;
                  id v56 = *(void *)v49;
                  id v54 = v49 + 8;
                  uint64_t v55 = v56;
                  *(v41 - 5) = v54;
                  id v57 = (char *)*(v41 - 4);
                  if (v57 == (char *)*(v41 - 3))
                  {
                    uint64_t v58 = (uint64_t)&v54[-*v44];
                    else {
                      uint64_t v91 = (uint64_t)&v57[-*v44] >> 2;
                    }
                    int v92 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<std::pair<unsigned int,unsigned int>>>(v91);
                    uint64_t v94 = &v92[8 * (v91 >> 2)];
                    unint64_t v95 = (uint64_t *)*(v41 - 5);
                    id v57 = v94;
                    uint64_t v96 = *(v41 - 4) - (void)v95;
                    if (v96)
                    {
                      id v57 = &v94[v96 & 0xFFFFFFFFFFFFFFF8LL];
                      id v97 = 8 * (v96 >> 3);
                      uint64_t v98 = &v92[8 * (v91 >> 2)];
                      do
                      {
                        uint64_t v99 = *v95++;
                        *(void *)uint64_t v98 = v99;
                        v98 += 8;
                        v97 -= 8LL;
                      }

                      while (v97);
                    }

              uint64_t v50 = atomic_load((unsigned int *)(v30 + 4));
              int v51 = v34 + (v50 >> 6);
              unint64_t v52 = (HIDWORD(v34) + 1);
              uint64_t v34 = (v52 << 32) | v34;
              if ((_DWORD)v52 == v51 - 1)
              {
                uint64_t v34 = (v52 << 32) | v52;
                uint64_t v30 = *(void *)(v30 + 40);
                goto LABEL_30;
              }

              goto LABEL_31;
            }
          }
        }

        ++v11;
        v10 += 16LL;
      }

      while (v11 < *(int *)(v9 + 12));
LABEL_52:
      __n128 result = apr_hash_next(v6);
      unsigned int v6 = result;
    }

    while (result);
  }

  return result;
}

  a3[33] += 24LL;
  return result;
}

LABEL_34:
  unsigned int v85 = objc_alloc(&OBJC_CLASS___GTReplayerOperation);
  v96[0] = _NSConcreteStackBlock;
  v96[1] = 3221225472LL;
  _OWORD v96[2] = __29__GTMTLReplayService_update___block_invoke_4;
  v96[3] = &unk_58DCB0;
  id v97 = v10;
  uint64_t v98 = v5;
  int v86 = v5;
  id v87 = v10;
  id v88 = -[GTReplayerOperation initWithBatch:withBlock:](v85, "initWithBatch:withBlock:", v93, v96);
  -[GTReplayerOperationBatch addOperation:](v93, "addOperation:", v88);
  -[GTReplayerOperationBatch finish:](v93, "finish:", clientContext->var7.var0);

  return 0LL;
}

    id v42 = v142;
    goto LABEL_114;
  }

            WriteDynamicBufferString(&v45, (const char *)[v19 UTF8String]);
            uint64_t v31 = v46 + 8;
            if (v46 + 8 <= v47) {
              *(void *)((char *)v45 + v46) = v24;
            }
            unint64_t v46 = v31;
            WriteDynamicBufferString( &v45, (const char *)-[__CFString UTF8String](v20, "UTF8String"));
            unsigned int v32 = [v16 offset];
            id v33 = v46 + 8;
            if (v46 + 8 <= v47) {
              *(void *)((char *)v45 + v46) = v32;
            }
            id v23 = 0LL;
            unint64_t v46 = v33;
            goto LABEL_39;
          }
        }

        else
        {
          id v21 = 0LL;
        }

        id v22 = (void *)objc_claimAutoreleasedReturnValue([v16 arrayType]);
        id v23 = v22;
        if (v21)
        {
          int v24 = [v21 unsignedIntegerValue];
          if (!v23) {
            goto LABEL_34;
          }
        }

        else
        {
          if (!v22) {
            goto LABEL_33;
          }
          int v24 = [v22 elementType];
        }

        if ([v23 arrayLength])
        {
          id v25 = 0LL;
          do
          {
            WriteDynamicBufferString(&v45, (const char *)[v19 UTF8String]);
            id v26 = v46 + 8;
            if (v46 + 8 <= v47) {
              *(void *)((char *)v45 + v46) = v24;
            }
            unint64_t v46 = v26;
            uint64_t v27 = objc_claimAutoreleasedReturnValue( -[__CFString stringByAppendingFormat:]( v20, "stringByAppendingFormat:", @"[%lu]", v25));
            WriteDynamicBufferString(&v45, (const char *)[v27 UTF8String]);

            unsigned int v28 = (char *)[v16 offset];
            char v29 = [v23 stride];
            uint64_t v30 = v46 + 8;
            if (v46 + 8 <= v47) {
              *(void *)((char *)v45 + v46) = &v28[(void)v29 * v25];
            }
            unint64_t v46 = v30;
            ++v25;
          }

          while (v25 < (unint64_t)[v23 arrayLength]);
          id v10 = v36;
          char v14 = obj;
        }

void sub_8B328( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, id *location, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, uint64_t a41, uint64_t a42, id a43)
{
}

void sub_8C17C(_Unwind_Exception *a1)
{
}

uint64_t __Block_byref_object_copy__562(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0LL;
  return result;
}

void __Block_byref_object_dispose__563(uint64_t a1)
{
}

void sub_8D994( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, char a22, uint64_t a23, uint64_t a24, uint64_t a25, char a26)
{
}

void BatchFilteredPause()
{
}

void BatchFilteredResume()
{
}

dispatch_data_s *NewResourceData( void *a1, void *a2, void *a3, void *a4, uint64_t a5, uint64_t a6, void *a7, uint64_t a8, void *a9)
{
  id v12 = a1;
  id v87 = a2;
  id v86 = a3;
  id v85 = a4;
  id v13 = a9;
  char v14 = &_dispatch_data_empty;
  id v15 = &_dispatch_data_empty;
  uint64_t v82 = v13;
  int size = dispatch_data_get_size(v13);
  id v16 = v12;
  int v17 = (char *)[v16 bytes];
  uint64_t v81 = v16;
  id v18 = [v16 length];
  if ((unint64_t)v18 >= 9)
  {
    unint64_t v19 = (unint64_t)v18;
    unint64_t v20 = 8LL;
    unint64_t v83 = (unint64_t)v18;
    id v84 = v17;
    do
    {
      id v21 = objc_autoreleasePoolPush();
      id v22 = &v17[v20];
      int v23 = *(_DWORD *)&v17[v20 + 4];
      if (v23 == -16236 || v23 == -10236)
      {
        uint64_t v89 = v21;
        DYTraceDecode_MTLTexture_replaceRegion_mipmapLevel_slice_withBytes_bytesPerRow_bytesPerImage( (uint64_t)v103,  (uint64_t)&v17[v20],  (*(_DWORD *)v22 - 36),  0LL);
        uint64_t v25 = v111;
        id v26 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", v111));
        uint64_t v27 = (void *)objc_claimAutoreleasedReturnValue([v87 objectForKeyedSubscript:v26]);

        unsigned int v28 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", v25));
        char v29 = (void *)objc_claimAutoreleasedReturnValue([v86 objectForKeyedSubscript:v28]);
        id v30 = [v29 unsignedLongLongValue];

        id v97 = v30;
        uint64_t v31 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  v30));
        uint64_t v99 = (void *)objc_claimAutoreleasedReturnValue([v85 objectForKeyedSubscript:v31]);

        id v32 = v27;
        id v33 = (int *)[v32 bytes];
        uint64_t v98 = v32;
        id v34 = [v32 length];
        unint64_t v88 = v20;
        uint64_t v93 = *((_WORD *)v33 + 5) == 1 ? *((void *)v33 + 2) : 0LL;
        if (*(void *)v33 == 0x63617074757265LL)
        {
          uint64_t v53 = v33[3];
          if (*((_WORD *)v33 + 4) == 1) {
            v53 += 16LL;
          }
          int v92 = (char *)v33 + v53;
        }

        else
        {
          int v92 = (char *)v33;
        }

        if (v93)
        {
          uint64_t v54 = 0LL;
          uint64_t v55 = 0LL;
          id v56 = v33 + 16;
          do
          {
            *(_WORD *)(a5 + 34) = *((void *)v56 - 5);
            id v57 = (void *)objc_claimAutoreleasedReturnValue([v99 objectForKeyedSubscript:@"DependencyGraphRequestedTextureSlice"]);
            id v58 = [v57 unsignedLongLongValue];
            if (v58) {
              __int16 v59 = (__int16)v58;
            }
            else {
              __int16 v59 = v110;
            }

            id v60 = (void *)objc_claimAutoreleasedReturnValue([v99 objectForKeyedSubscript:@"DependencyGraphRequestedTextureLevel"]);
            id v61 = [v60 unsignedLongLongValue];
            if (v61) {
              char v62 = (char)v61;
            }
            else {
              char v62 = v109;
            }

            id v63 = (void *)objc_claimAutoreleasedReturnValue( [v99 objectForKeyedSubscript:@"DependencyGraphRequestedTextureAttachmentIndex"]);
            id v64 = [v63 unsignedLongLongValue];
            if (v64) {
              int v65 = (int)v64;
            }
            else {
              int v65 = v55;
            }

            uint64_t v66 = (*a7)++;
            uint64_t v67 = *((void *)v56 - 5);
            if ((unsigned __int16)v67 == 255 || (unsigned __int16)v67 == 260)
            {
              LOWORD(v67) = 252;
              if (v65) {
                LOWORD(v67) = 253;
              }
            }

            uint64_t v68 = v103[0];
            int v69 = *v56;
            uint64_t v70 = a6 + 80 * v66;
            int v71 = v106;
            __int16 v72 = v107;
            __int16 v73 = v108;
            *(void *)uint64_t v70 = v97;
            *(void *)(v70 + _Block_object_dispose((const void *)(v1 - 144), 8) = v68;
            *(void *)(v70 + 16) = a8;
            *(_DWORD *)(v70 + 24) = size;
            *(_DWORD *)(v70 + 2_Block_object_dispose((const void *)(v1 - 144), 8) = v69;
            *(_WORD *)(v70 + 32) = 0;
            *(_BYTE *)(v70 + 34) = 1;
            *(void *)(v70 + 35) = 0LL;
            *(void *)(v70 + 40) = 0LL;
            *(_DWORD *)(v70 + 4_Block_object_dispose((const void *)(v1 - 144), 8) = v71;
            *(_WORD *)(v70 + 52) = v72;
            *(_WORD *)(v70 + 54) = v73;
            *(void *)(v70 + 56) = (unsigned __int16)v67;
            *(int32x2_t *)(v70 + 64) = vmovn_s64(v112);
            *(_WORD *)(v70 + 72) = 0;
            *(_WORD *)(v70 + 74) = v59;
            *(_BYTE *)(v70 + 76) = v62;
            *(_BYTE *)(v70 + 77) = v65;
            *(_WORD *)(v70 + 7_Block_object_dispose((const void *)(v1 - 144), 8) = 0;
            size_t v74 = *(void *)v56;
            v56 += 12;
            v101[0] = _NSConcreteStackBlock;
            v101[1] = 3221225472LL;
            v101[2] = __NewResourceData_block_invoke_2;
            v101[3] = &unk_58F020;
            id v102 = v98;
            double v75 = dispatch_data_create(&v92[v54], v74, 0LL, v101);
            dispatch_data_t concat = dispatch_data_create_concat(v14, v75);

            size_t v77 = dispatch_data_get_size(v75);
            v54 += v77;
            size += v77;

            ++v55;
            char v14 = concat;
          }

          while (v93 != v55);
        }

        else
        {
LABEL_38:
          dispatch_data_t concat = v14;
        }

        char v14 = concat;
        unint64_t v19 = v83;
        int v17 = v84;
        unint64_t v20 = v88;
        id v21 = v89;
      }

      else if (v23 == -10240)
      {
        uint64_t v90 = v21;
        DYTraceDecode_MTLCommandBuffer_restoreMTLBufferContents((uint64_t)v103, (uint64_t)&v17[v20]);
        uint64_t v35 = v104;
        unint64_t v36 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", v104));
        uint64_t v37 = (void *)objc_claimAutoreleasedReturnValue([v87 objectForKeyedSubscript:v36]);

        id v38 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", v35));
        id v39 = (void *)objc_claimAutoreleasedReturnValue([v86 objectForKeyedSubscript:v38]);
        id v40 = [v39 unsignedLongLongValue];

        uint64_t v41 = (*a7)++;
        unint64_t v42 = v20;
        uint64_t v43 = a6 + 80 * v41;
        uint64_t v44 = v103[1];
        unsigned int v45 = [v37 length];
        int v46 = v105;
        *(void *)uint64_t v43 = v40;
        *(void *)(v43 + _Block_object_dispose((const void *)(v1 - 144), 8) = v44;
        *(void *)(v43 + 16) = a8;
        *(_DWORD *)(v43 + 24) = size;
        *(_DWORD *)(v43 + 2_Block_object_dispose((const void *)(v1 - 144), 8) = v45;
        *(_WORD *)(v43 + 32) = 0;
        *(_BYTE *)(v43 + 34) = 2;
        *(_DWORD *)(v43 + 35) = 0;
        *(_BYTE *)(v43 + 39) = 0;
        *(_DWORD *)(v43 + 40) = v46;
        *(_OWORD *)(v43 + 44) = 0u;
        *(_OWORD *)(v43 + 60) = 0u;
        *(_DWORD *)(v43 + 76) = 0;
        unint64_t v20 = v42;
        id v47 = v37;
        id v48 = [v47 bytes];
        id v49 = [v47 length];
        destructor[0] = _NSConcreteStackBlock;
        destructor[1] = 3221225472LL;
        destructor[2] = __NewResourceData_block_invoke;
        destructor[3] = &unk_58F020;
        id v114 = v47;
        id v50 = v47;
        int v51 = dispatch_data_create(v48, (size_t)v49, 0LL, destructor);
        dispatch_data_t v52 = dispatch_data_create_concat(v14, v51);

        size += dispatch_data_get_size(v51);
        id v21 = v90;
        char v14 = v52;
      }

      objc_autoreleasePoolPop(v21);
      uint64_t v78 = *(unsigned int *)v22;
      if ((v22[33] & 0x10) != 0)
      {
        uint64_t v79 = *(unsigned int *)v22;
        do
        {
          v22 += v78;
          uint64_t v78 = *(unsigned int *)v22;
          v79 += v78;
        }

        while ((v22[33] & 0x20) == 0);
      }

      else
      {
        uint64_t v79 = *(unsigned int *)v22;
      }

      v20 += v79;
    }

    while (v20 < v19);
  }

  return v14;
}

id __NewResourceData_block_invoke(uint64_t a1)
{
  return [*(id *)(a1 + 32) length];
}

id __NewResourceData_block_invoke_2(uint64_t a1)
{
  return [*(id *)(a1 + 32) length];
}

void sub_8EFC0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
}

uint64_t CleanupSandboxExtensionURL_615(void *a1)
{
  return 0LL;
}

BOOL UpdateDebugFileCache(void *a1, void *a2, void *a3, void *a4)
{
  id v7 = a1;
  id v8 = a2;
  id v9 = a3;
  id v26 = a4;
  id v10 = -[NSURL initFileURLWithPath:isDirectory:]( objc_alloc(&OBJC_CLASS___NSURL),  "initFileURLWithPath:isDirectory:",  v26,  1LL);
  unsigned int v28 = v8;
  char v29 = v9;
  uint64_t v27 = v10;
  if (v7)
  {
    uint64_t v35 = 0LL;
    unint64_t v36 = &v35;
    uint64_t v37 = 0x2020000000LL;
    char v38 = 1;
    v30[0] = _NSConcreteStackBlock;
    v30[1] = 3221225472LL;
    v30[2] = __UpdateDebugFileCache_block_invoke;
    v30[3] = &unk_58DA50;
    uint64_t v31 = v10;
    id v34 = &v35;
    id v32 = v9;
    id v33 = v8;
    objc_msgSend(v7, "enumerateKeysAndObjectsUsingBlock:", v30, v7);
    BOOL v11 = *((_BYTE *)v36 + 24) != 0;

    _Block_object_dispose(&v35, 8);
  }

  else
  {
    id v12 = (void *)objc_claimAutoreleasedReturnValue(+[NSFileManager defaultManager](&OBJC_CLASS___NSFileManager, "defaultManager", 0LL));
    v45[0] = NSURLNameKey;
    v45[1] = NSURLIsDirectoryKey;
    id v13 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", v45, 2LL));
    char v14 = (void *)objc_claimAutoreleasedReturnValue( [v12 enumeratorAtURL:v27 includingPropertiesForKeys:v13 options:4 errorHandler:0]);

    __int128 v42 = 0u;
    __int128 v43 = 0u;
    __int128 v40 = 0u;
    __int128 v41 = 0u;
    id v15 = v14;
    id v16 = [v15 countByEnumeratingWithState:&v40 objects:v44 count:16];
    if (v16)
    {
      uint64_t v17 = *(void *)v41;
      do
      {
        for (unint64_t i = 0LL; i != v16; unint64_t i = (char *)i + 1)
        {
          if (*(void *)v41 != v17) {
            objc_enumerationMutation(v15);
          }
          unint64_t v19 = *(void **)(*((void *)&v40 + 1) + 8LL * (void)i);
          id v39 = 0LL;
          [v19 getResourceValue:&v39 forKey:NSURLIsDirectoryKey error:0];
          id v20 = v39;
          if (([v20 BOOLValue] & 1) == 0)
          {
            id v21 = (void *)objc_claimAutoreleasedReturnValue([v19 lastPathComponent]);
            id v22 = (void *)objc_claimAutoreleasedReturnValue([v21 stringByDeletingPathExtension]);
            int v23 = (void *)objc_claimAutoreleasedReturnValue([v29 objectForKeyedSubscript:v22]);

            if (v23) {
              [v28 setObject:v19 forKeyedSubscript:v23];
            }
          }
        }

        id v16 = [v15 countByEnumeratingWithState:&v40 objects:v44 count:16];
      }

      while (v16);
    }

    BOOL v11 = 1LL;
  }

  return v11;
}

void sub_8F938( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, ...)
{
}

void __StoreDebugFileCache_block_invoke(uint64_t a1, void *a2, void *a3)
{
  id v5 = a3;
  id v6 = a2;
  id v7 = objc_alloc(&OBJC_CLASS___NSURL);
  id v8 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](&OBJC_CLASS___NSString, "stringWithFormat:", @"%@.metallib", v6));

  id v9 = -[NSURL initFileURLWithPath:relativeToURL:](v7, "initFileURLWithPath:relativeToURL:", v8, *(void *)(a1 + 32));
  id v11 = 0LL;
  [v5 writeToURL:v9 options:0 error:&v11];

  id v10 = v11;
  if (v10) {
    *(_BYTE *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL) = 0;
  }
}

void __UpdateDebugFileCache_block_invoke(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  id v7 = objc_alloc(&OBJC_CLASS___NSURL);
  id v8 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](&OBJC_CLASS___NSString, "stringWithFormat:", @"%@.metallib", v5));
  id v9 = -[NSURL initFileURLWithPath:relativeToURL:](v7, "initFileURLWithPath:relativeToURL:", v8, *(void *)(a1 + 32));

  id v12 = 0LL;
  [v6 writeToURL:v9 options:0 error:&v12];

  id v10 = v12;
  if (v10)
  {
    *(_BYTE *)(*(void *)(*(void *)(a1 + 56) + 8LL) + 24LL) = 0;
  }

  else
  {
    id v11 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 40) objectForKeyedSubscript:v5]);
    if (v11) {
      [*(id *)(a1 + 48) setObject:v9 forKeyedSubscript:v11];
    }
  }
}

void sub_910A4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  _Unwind_Resume(a1);
}

uint64_t GTMTLCreateIndirectCommandEncoder(uint64_t result, uint64_t a2)
{
  *(void *)&__int128 v2 = -1LL;
  *((void *)&v2 + 1) = -1LL;
  *(_OWORD *)(result + 80) = v2;
  *(_OWORD *)(result + 96) = v2;
  *(_OWORD *)(result + 4_Block_object_dispose(va, 8) = v2;
  *(_OWORD *)(result + 64) = v2;
  *(_OWORD *)(result + 16) = v2;
  *(_OWORD *)(result + 32) = v2;
  *(void *)__n128 result = a2;
  *(void *)(result + _Block_object_dispose(va, 8) = 0LL;
  if (*(_BYTE *)(a2 + 11))
  {
    uint64_t v3 = 8LL;
  }

  else
  {
    *(void *)(result + 16) = 8LL;
    uint64_t v3 = 16LL;
  }

  if (!*(_BYTE *)(a2 + 10))
  {
    uint64_t v4 = *(unsigned __int8 *)(a2 + 18);
    *(void *)(result + 24) = v3;
    *(void *)(result + 32) = v3 + 8 * v4;
    uint64_t v5 = v4 + *(unsigned __int8 *)(a2 + 12);
    uint64_t v6 = v3 + 8 * v5;
    uint64_t v7 = v5 + *(unsigned __int8 *)(a2 + 16);
    *(void *)(result + 40) = v6;
    *(void *)(result + 4_Block_object_dispose(va, 8) = v3 + 8 * v7;
    uint64_t v8 = v7 + *(unsigned __int8 *)(a2 + 15);
    *(void *)(result + 56) = v3 + 8 * v8;
    v3 += 8 * (v8 + *(unsigned __int8 *)(a2 + 13));
  }

  uint64_t v9 = *(unsigned __int8 *)(a2 + 17);
  *(void *)(result + 64) = v3;
  *(void *)(result + 72) = v3 + 8 * v9;
  uint64_t v10 = v9 + *(unsigned __int8 *)(a2 + 14);
  uint64_t v11 = v3 + 8 * v10;
  uint64_t v12 = *(unsigned __int16 *)(a2 + 8);
  *(void *)(result + 80) = v11;
  if (*(_BYTE *)(a2 + 19))
  {
    if ((v12 & 0xF) != 0)
    {
      uint64_t v13 = *(unsigned __int8 *)(a2 + 18);
    }

    else
    {
      if ((v12 & 0x60) == 0) {
        goto LABEL_12;
      }
      uint64_t v13 = *(unsigned __int8 *)(a2 + 13);
    }

    uint64_t v11 = v3 + 8 * (v10 + v13);
  }

double GetExecuteCommandsInBufferArgs(uint64_t a1, uint64_t a2, uint64_t a3)
{
  switch(*(_DWORD *)(a2 + 8))
  {
    case 0xFFFFC1A4:
    case 0xFFFFC1A6:
      uint64_t v10 = GTTraceFunc_argumentBytesWithMap((void *)a2, *(unsigned __int8 *)(a2 + 13), a3);
      *(_OWORD *)a1 = *(_OWORD *)(v10 + 8);
      uint64_t v9 = *((void *)v10 + 4);
      *(void *)(a1 + 16) = *((void *)v10 + 3);
      unsigned int v8 = v10[40];
      goto LABEL_4;
    case 0xFFFFC1A5:
    case 0xFFFFC1A7:
      uint64_t v6 = GTTraceFunc_argumentBytesWithMap((void *)a2, *(unsigned __int8 *)(a2 + 13), a3);
      uint64_t v7 = GTTraceFunc_argumentBlobWithMap((void *)a2, v6[41], a3);
      *(void *)a1 = *((void *)v6 + 1);
      *(_OWORD *)(a1 + _Block_object_dispose(va, 8) = *(_OWORD *)(v7 + 16);
      unsigned int v8 = v6[40];
      uint64_t v9 = *((void *)v6 + 4);
LABEL_4:
      uint64_t v11 = GTTraceMemoryMap_argumentBlobAtIndex(v8, a3, v9);
      if (v11)
      {
        uint64_t v13 = v11 + 16;
        uint64_t v14 = *(unsigned int *)(v11 + 12);
      }

      else
      {
        uint64_t v13 = 0LL;
        uint64_t v14 = 0LL;
      }

      *(void *)(a1 + 24) = v13;
      *(void *)(a1 + 32) = v14;
      break;
    default:
      *(void *)(a1 + 32) = 0LL;
      double result = 0.0;
      *(_OWORD *)a1 = 0u;
      *(_OWORD *)(a1 + 16) = 0u;
      break;
  }

  return result;
}

NSMutableDictionary *GTMTLReplayClient_embeddedQueryShaderInfo(GTMTLReplayController *a1, id *a2, void *a3)
{
  id v5 = a3;
  uint64_t v6 = v5;
  if (v5)
  {
    uint64_t v7 = (void *)objc_claimAutoreleasedReturnValue([v5 objectForKeyedSubscript:@"gpuTarget"]);
    uint64_t v82 = v7;
    if (v7) {
      unsigned int v8 = [v7 intValue];
    }
    else {
      unsigned int v8 = 0x7FFFFFFF;
    }
    id v10 = (id)objc_claimAutoreleasedReturnValue([v6 objectForKeyedSubscript:@"MetalPluginName"]);
    uint64_t v11 = v10;
    if (v8 == 0x7FFFFFFF)
    {
      if (!v10)
      {
        unsigned int v8 = 0x7FFFFFFF;
        goto LABEL_12;
      }

      unsigned int v8 = MetalPluginTarget(v10);
    }

    if ((v8 & 0x80000000) == 0)
    {
      uint64_t v9 = (NSMutableDictionary *)&off_59FF20;
LABEL_42:

      goto LABEL_43;
    }

void sub_92764( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, void *a22, uint64_t a23, void *a24, uint64_t a25, uint64_t a26, GTAGXPerfStateControl *a27, uint64_t a28, void *a29, uint64_t a30, uint64_t a31, void *a32, void *a33, uint64_t a34, void *a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, uint64_t a41, uint64_t a42, uint64_t a43, uint64_t a44, uint64_t a45, char a46, uint64_t a47, uint64_t a48, uint64_t a49, uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,char a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  _Block_object_dispose(&a46, 8);
  _Block_object_dispose(&a58, 8);

  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__53(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0LL;
  return result;
}

void __Block_byref_object_dispose__54(uint64_t a1)
{
}

void ___ZL29EmbeddedQueryShaderInfoLegacyP21GTMTLReplayControllerP26GTMTLReplayOperationQueuesP12NSDictionaryi_block_invoke( uint64_t a1)
{
  uint64_t v29 = a1;
  __int128 v2 = *(unsigned int **)(a1 + 40);
  unsigned int v34 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
  id v33 = objc_alloc_init(&OBJC_CLASS___NSMutableDictionary);
  id v32 = objc_alloc_init(&OBJC_CLASS___NSMutableDictionary);
  uint64_t v3 = objc_alloc_init(&OBJC_CLASS___NSMutableDictionary);
  id v4 = *((id *)v2 + 1);
  id v5 = v4;
  uint64_t v6 = *(void **)v2;
  uint64_t v7 = v2 + 5620;
  if (*(void *)(*(void *)v2 + 104LL) + *(void *)(*(void *)v2 + 96LL) > (unint64_t)v2[5620])
  {
    id v31 = v4;
    while (1)
    {
      unsigned int v8 = objc_autoreleasePoolPush();
      uint64_t v9 = *(void *)(v6[15] + 24LL) + ((unint64_t)*v7 << 6);
      id v10 = (int *)(v9 + 8);
      GTMTLReplayController_updateCommandEncoder((uint64_t)v2, v9);
      GTMTLReplayController_defaultDispatchFunction((uint64_t)v2, v9);
      int v11 = *v10;
      if ((IsFuncEnumDrawCall(*v10) & 1) == 0)
      {
        BOOL v12 = (v11 + 16079) < 2 || v11 == -16220;
        if (!v12 && v11 != -16327) {
          goto LABEL_21;
        }
      }

      unsigned int v14 = v2[2828];
      if (v14 == 28) {
        break;
      }
      if (v14 == 70)
      {
        uint64_t v15 = (void *)objc_claimAutoreleasedReturnValue([v5 renderPipelineStateForKey:*((void *)v2 + 2489)]);
        if (IsFuncEnumDrawCall(*v10))
        {
          unsigned int v35 = v8;
          v40[0] = @"vertex shader key";
          id v16 = [v15 newVertexShaderDebugInfo];
          uint64_t v17 = AddShaderBinary(v33, v16);
          id v18 = (void *)objc_claimAutoreleasedReturnValue(v17);
          v40[1] = @"fragment shader key";
          v41[0] = v18;
          id v19 = [v15 newFragmentShaderDebugInfo];
          id v20 = AddShaderBinary(v32, v19);
          id v21 = (void *)objc_claimAutoreleasedReturnValue(v20);
          v41[1] = v21;
          id v22 = v3;
          int v23 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v41,  v40,  2LL));
          -[NSMutableArray addObject:](v34, "addObject:", v23);

          uint64_t v3 = v22;
          id v5 = v31;

          goto LABEL_19;
        }

        goto LABEL_20;
      }

void ___ZL29EmbeddedQueryShaderInfoLegacyP21GTMTLReplayControllerP26GTMTLReplayOperationQueuesP12NSDictionaryi_block_invoke_2( uint64_t a1)
{
  double v75 = *(id **)(a1 + 48);
  id v64 = *(id *)(a1 + 32);
  uint64_t v1 = (void *)objc_claimAutoreleasedReturnValue([v64 objectForKeyedSubscript:@"uscBufferSize"]);
  vm_size_t v2 = (void)[v1 unsignedIntegerValue] << 20;

  if (v2 - 1 >= 0x1FFFFFF) {
    vm_size_t v3 = 0x2000000LL;
  }
  else {
    vm_size_t v3 = v2;
  }
  vm_allocate(mach_task_self_, &address, v3, 1);
  memset((void *)address, 255, v3);
  id v60 = v75[1];
  vm_size_t v61 = v3;
  char v62 = (void *)objc_claimAutoreleasedReturnValue([v60 defaultDevice]);
  [v62 mapShaderSampleBufferWithBuffer:address capacity:v3 / 0xC size:v3];
  mach_timebase_info(&info);
  uint64_t v84 = 0LL;
  double v85 = (unsigned __int8 *)&v84;
  uint64_t v86 = 0x2020000000LL;
  uint64_t v66 = mach_absolute_time();
  id v4 = -[NSMutableData initWithLength:](objc_alloc(&OBJC_CLASS___NSMutableData), "initWithLength:", 2097144LL);
  memset(-[NSMutableData mutableBytes](v4, "mutableBytes"), 255, -[NSMutableData length](v4, "length"));
  int v69 = v4;
  id v5 = -[NSMutableData mutableBytes](v69, "mutableBytes");
  id v67 = (void *)objc_claimAutoreleasedReturnValue([v64 objectForKeyedSubscript:@"perEncoderDrawCallCount"]);
  memset(v82, 0, sizeof(v82));
  int v83 = 1065353216;
  dispatch_queue_attr_t v6 = dispatch_queue_attr_make_with_autorelease_frequency(0LL, DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM);
  uint64_t v7 = (dispatch_queue_attr_s *)objc_claimAutoreleasedReturnValue(v6);
  queue = dispatch_queue_create("com.apple.MTLReplayer.memoryPresure", v7);

  unsigned int v8 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_memorypressure, 0LL, 2uLL, queue);
  handler[0] = _NSConcreteStackBlock;
  handler[1] = 3221225472LL;
  handler[2] = ___ZL18PerformUSCSamplingP21GTMTLReplayControllerP12NSDictionary_block_invoke;
  handler[3] = &unk_58DE18;
  handler[4] = &v84;
  dispatch_source_set_event_handler(v8, handler);
  source = v8;
  dispatch_activate(v8);
  uint64_t v68 = objc_alloc_init(&OBJC_CLASS___ProgramAddressTableCollector);
  uint64_t v76 = 0LL;
  uint64_t v9 = 0LL;
  int v10 = 0;
  unsigned int v80 = (unsigned int *)(v75 + 2810);
  do
  {
    int v70 = v10;
    GTMTLReplayController_prePlayForProfiling((uint64_t)v75);
    id v74 = v67;
    int v71 = v69;
    __int16 v72 = v68;
    id v79 = v75[1];
    int v11 = *v75;
    if (*((void *)*v75 + 13) + *((void *)*v75 + 12) > (unint64_t)*v80)
    {
      char v73 = 0;
      uint64_t v77 = v11[2];
      while (1)
      {
        BOOL v12 = objc_autoreleasePoolPush();
        uint64_t v13 = *(void *)(v11[15] + 24LL);
        uint64_t v14 = *v80;
        uint64_t v15 = v13 + (v14 << 6);
        int v18 = *(_DWORD *)(v15 + 8);
        uint64_t v17 = (int *)(v15 + 8);
        int v16 = v18;
        if (GetFuncEnumConstructorType(v18) == 25)
        {
          GTMTLReplayController_restoreCommandBuffer((uint64_t)v75, v13 + (v14 << 6));
          int v16 = *v17;
        }

        if (v16 <= -16287) {
          break;
        }
        if (v16 <= -16247)
        {
          if (v16 != -16286)
          {
            if (v16 != -16285) {
              goto LABEL_30;
            }
LABEL_29:
            GTMTLReplayController_dispatchForUSCSampling( (uint64_t)v75,  v13 + (v14 << 6),  v79,  v77,  v72,  (v9 - 1));
            char v73 = 0;
            goto LABEL_31;
          }

          unsigned int v34 = GTTraceFunc_argumentBytesWithMap( (void *)(v13 + (v14 << 6)),  *(unsigned __int8 *)(v13 + (v14 << 6) + 13),  v77);
          unsigned int v35 = (void *)objc_claimAutoreleasedReturnValue([v79 parallelRenderCommandEncoderForKey:*(void *)v34]);
          [v79 setRenderCommandEncoder:v35 forKey:*((void *)v34 + 1)];
          goto LABEL_26;
        }

        if (v16 != -16246)
        {
          if (v16 != -16014)
          {
LABEL_30:
            GTMTLReplayController_dispatchForUSCSampling( (uint64_t)v75,  v13 + (v14 << 6),  v79,  v77,  v72,  (v9 - 1));
            goto LABEL_31;
          }

          uint64_t v30 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInt:](&OBJC_CLASS___NSNumber, "numberWithUnsignedInt:", *v80));
          uint64_t v78 = (void *)objc_claimAutoreleasedReturnValue([v74 objectForKeyedSubscript:v30]);

          id v31 = [v78 unsignedIntegerValue];
          int *v5 = *(unsigned __int8 *)v5 | ((_DWORD)v9 << 8);
          id v32 = v5 + 6;
          id v33 = GTTraceFunc_argumentBytesWithMap( (void *)(v13 + (v14 << 6)),  *(unsigned __int8 *)(v13 + (v14 << 6) + 13),  v77);
          uint64_t v24 = (void *)objc_claimAutoreleasedReturnValue([v79 commandBufferForKey:*(void *)v33]);
          uint64_t v27 = (void *)objc_claimAutoreleasedReturnValue( [v24 sampledComputeCommandEncoderWithDispatchType:*((void *)v33 + 2) programInfoBuffer:v32 capacity:v31]);
          LODWORD(v90[0]) = [v27 globalTraceObjectID];
          *((_DWORD *)std::__hash_table<std::__hash_value_type<unsigned int,unsigned int>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,unsigned int>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int &&>,std::tuple<>>( (uint64_t)v82,  v90[0],  v90)
          + 5) = v9++;
          [v79 setComputeCommandEncoder:v27 forKey:*((void *)v33 + 1)];
LABEL_24:
          id v5 = &v32[6 * (void)v31];
          uint64_t v29 = 24LL * (void)v31 + 24;
          goto LABEL_25;
        }

        if ((v73 & 1) == 0) {
          goto LABEL_29;
        }
        objc_msgSend( v79,  "removeRenderCommandEncoderForKey:",  *(void *)GTTraceFunc_argumentBytesWithMap( (void *)(v13 + (v14 << 6)),  *(unsigned __int8 *)(v13 + (v14 << 6) + 13),  v77));
        char v73 = 1;
LABEL_31:
        objc_autoreleasePoolPop(v12);
        unint64_t v46 = *v80 + 1;
        unsigned int *v80 = v46;
        if (v11[13] + v11[12] <= v46) {
          goto LABEL_32;
        }
      }

      switch(v16)
      {
        case -16353:
          unint64_t v36 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInt:](&OBJC_CLASS___NSNumber, "numberWithUnsignedInt:", *v80));
          uint64_t v78 = (void *)objc_claimAutoreleasedReturnValue([v74 objectForKeyedSubscript:v36]);

          id v37 = [v78 unsignedIntegerValue];
          int *v5 = *(unsigned __int8 *)v5 | ((_DWORD)v9 << 8);
          char v38 = v5 + 6;
          id v39 = GTTraceFunc_argumentBytesWithMap( (void *)(v13 + (v14 << 6)),  *(unsigned __int8 *)(v13 + (v14 << 6) + 13),  v77);
          uint64_t RenderPassDescriptor = GetRenderPassDescriptor((uint64_t *)(v13 + (v14 << 6)), v77);
          uint64_t v24 = (void *)objc_claimAutoreleasedReturnValue([v79 commandBufferForKey:*(void *)v39]);
          __int128 v41 = (void *)objc_claimAutoreleasedReturnValue([v79 renderPassDescriptorMap]);
          MTLuint64_t RenderPassDescriptor = MakeMTLRenderPassDescriptor(RenderPassDescriptor, v41);
          uint64_t v27 = (void *)objc_claimAutoreleasedReturnValue(MTLRenderPassDescriptor);

          __int128 v43 = (void *)objc_claimAutoreleasedReturnValue( [v24 sampledRenderCommandEncoderWithDescriptor:v27 programInfoBuffer:v38 capacity:2 * (void)v37 + 2]);
          LODWORD(v90[0]) = [v43 globalTraceObjectID];
          *((_DWORD *)std::__hash_table<std::__hash_value_type<unsigned int,unsigned int>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,unsigned int>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int &&>,std::tuple<>>( (uint64_t)v82,  v90[0],  v90)
          + 5) = v9++;
          [v79 setRenderCommandEncoder:v43 forKey:*((void *)v39 + 1)];

          id v5 = &v38[12 * (void)v37 + 12];
          uint64_t v29 = 48LL * (void)v37 + 72;
          break;
        case -16352:
          uint64_t v44 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInt:](&OBJC_CLASS___NSNumber, "numberWithUnsignedInt:", *v80));
          uint64_t v78 = (void *)objc_claimAutoreleasedReturnValue([v74 objectForKeyedSubscript:v44]);

          id v31 = [v78 unsignedIntegerValue];
          int *v5 = *(unsigned __int8 *)v5 | ((_DWORD)v9 << 8);
          id v32 = v5 + 6;
          unsigned int v45 = GTTraceFunc_argumentBytesWithMap( (void *)(v13 + (v14 << 6)),  *(unsigned __int8 *)(v13 + (v14 << 6) + 13),  v77);
          uint64_t v24 = (void *)objc_claimAutoreleasedReturnValue([v79 commandBufferForKey:*(void *)v45]);
          uint64_t v27 = (void *)objc_claimAutoreleasedReturnValue([v24 sampledComputeCommandEncoderWithProgramInfoBuffer:v32 capacity:v31]);
          LODWORD(v90[0]) = [v27 globalTraceObjectID];
          *((_DWORD *)std::__hash_table<std::__hash_value_type<unsigned int,unsigned int>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,unsigned int>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int &&>,std::tuple<>>( (uint64_t)v82,  v90[0],  v90)
          + 5) = v9++;
          [v79 setComputeCommandEncoder:v27 forKey:*((void *)v45 + 1)];
          goto LABEL_24;
        case -16351:
          id v19 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInt:](&OBJC_CLASS___NSNumber, "numberWithUnsignedInt:", *v80));
          uint64_t v78 = (void *)objc_claimAutoreleasedReturnValue([v74 objectForKeyedSubscript:v19]);

          id v20 = [v78 unsignedIntegerValue];
          int *v5 = *(unsigned __int8 *)v5 | ((_DWORD)v9 << 8);
          id v21 = v5 + 6;
          id v22 = GTTraceFunc_argumentBytesWithMap( (void *)(v13 + (v14 << 6)),  *(unsigned __int8 *)(v13 + (v14 << 6) + 13),  v77);
          uint64_t v23 = GetRenderPassDescriptor((uint64_t *)(v13 + (v14 << 6)), v77);
          uint64_t v24 = (void *)objc_claimAutoreleasedReturnValue([v79 commandBufferForKey:*(void *)v22]);
          unint64_t v25 = (void *)objc_claimAutoreleasedReturnValue([v79 renderPassDescriptorMap]);
          uint64_t v26 = MakeMTLRenderPassDescriptor(v23, v25);
          uint64_t v27 = (void *)objc_claimAutoreleasedReturnValue(v26);

          unsigned int v28 = (void *)objc_claimAutoreleasedReturnValue( [v24 sampledRenderCommandEncoderWithDescriptor:v27 programInfoBuffer:v21 capacity:2 * (void)v20 + 2]);
          LODWORD(v90[0]) = [v28 globalTraceObjectID];
          *((_DWORD *)std::__hash_table<std::__hash_value_type<unsigned int,unsigned int>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,unsigned int>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int &&>,std::tuple<>>( (uint64_t)v82,  v90[0],  v90)
          + 5) = v9++;
          [v79 setParallelRenderCommandEncoder:v28 forKey:*((void *)v22 + 1)];

          id v5 = &v21[12 * (void)v20 + 12];
          uint64_t v29 = 48LL * (void)v20 + 72;
          char v73 = 1;
          break;
        default:
          goto LABEL_30;
      }

LABEL_25:
      v76 += v29;
      unsigned int v35 = v78;
LABEL_26:

      goto LABEL_31;
    }

    BOOL v12 = v13;
    v13 += 3;
    if (v13 != a2) {
      continue;
    }
    return 1LL;
  }

  -[GTBaseStreamTransport_replayer _clearBuffers](self, "_clearBuffers");
  return v6;
}

  uint64_t v27 = (void *)objc_claimAutoreleasedReturnValue([v241 drawCallInfoList]);
  unsigned int v28 = [v27 count];
  uint64_t v29 = (unint64_t)v28 + 1;
  uint64_t v30 = *((void *)self + 10);
  id v31 = *((void *)self + 11);
  id v32 = 0xCCCCCCCCCCCCCCCDLL * ((v31 - v30) >> 3);
  id v33 = (unint64_t)v28 - v32 + 1;
  if ((unint64_t)v28 + 1 <= v32)
  {
    if ((unint64_t)v28 + 1 < v32)
    {
      uint64_t v53 = v30 + 40 * v29;
      while (v31 != v53)
      {
        v31 -= 40LL;
        std::__hash_table<std::__hash_value_type<unsigned long long,std::pair<ShaderBinaryStatsInfo *,std::string>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,std::pair<ShaderBinaryStatsInfo *,std::string>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,std::pair<ShaderBinaryStatsInfo *,std::string>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,std::pair<ShaderBinaryStatsInfo *,std::string>>>>::~__hash_table(v31);
      }

      *((void *)self + 11) = v53;
    }
  }

  else
  {
    unsigned int v34 = *((void *)self + 12);
    if (0xCCCCCCCCCCCCCCCDLL * ((v34 - v31) >> 3) >= v33)
    {
      double v54 = v31 + 40 * v33;
      do
      {
        *(_OWORD *)id v31 = 0uLL;
        *(_OWORD *)(v31 + 16) = 0uLL;
        *(_DWORD *)(v31 + 32) = 1065353216;
        v31 += 40LL;
      }

      while (v31 != v54);
      *((void *)self + 11) = v54;
    }

    else
    {
      if (v29 > 0x666666666666666LL) {
        abort();
      }
      unsigned int v35 = 0xCCCCCCCCCCCCCCCDLL * ((v34 - v30) >> 3);
      unint64_t v36 = 2 * v35;
      if (2 * v35 <= v29) {
        unint64_t v36 = (uint64_t)v28 + 1;
      }
      if (v35 >= 0x333333333333333LL) {
        id v37 = 0x666666666666666LL;
      }
      else {
        id v37 = v36;
      }
      if (v37 > 0x666666666666666LL) {
        std::__throw_bad_array_new_length[abi:nn180100]();
      }
      char v38 = (char *)operator new(40 * v37);
      id v39 = &v38[8 * ((v31 - v30) >> 3)];
      uint64_t v40 = &v38[40 * v29];
      __int128 v41 = v39;
      do
      {
        *(_OWORD *)__int128 v41 = 0uLL;
        *((_OWORD *)v41 + 1) = 0uLL;
        *((_DWORD *)v41 + _Block_object_dispose(va, 8) = 1065353216;
        v41 += 40;
      }

      while (v41 != v40);
      __int128 v42 = &v38[40 * v37];
      if (v31 != v30)
      {
        __int128 v43 = 0LL;
        do
        {
          uint64_t v44 = &v39[v43];
          unsigned int v45 = v31 + v43;
          unint64_t v46 = *(void *)(v31 + v43 - 40);
          *(void *)(v45 - 40) = 0LL;
          *((void *)v44 - 5) = v46;
          *((void *)v44 - 4) = *(void *)(v31 + v43 - 32);
          *(void *)(v45 - 32) = 0LL;
          uint64_t v47 = *(void *)(v31 + v43 - 24);
          *(void *)&v39[v43 - 24] = v47;
          unsigned __int8 v48 = *(void *)(v31 + v43 - 16);
          *((void *)v44 - 2) = v48;
          *((_DWORD *)v44 - 2) = *(_DWORD *)(v31 + v43 - 8);
          if (v48)
          {
            id v49 = *(void *)(v47 + 8);
            unsigned __int8 v50 = *((void *)v44 - 4);
            if ((v50 & (v50 - 1)) != 0)
            {
              if (v49 >= v50) {
                v49 %= v50;
              }
            }

            else
            {
              v49 &= v50 - 1;
            }

            *(void *)(v46 + 8 * v49) = &v39[v43 - 24];
            *(void *)(v31 + v43 - 24) = 0LL;
            *(void *)(v31 + v43 - 16) = 0LL;
          }

          v43 -= 40LL;
        }

        while (v31 + v43 != v30);
        v39 += v43;
      }

      unsigned __int8 v52 = (void *)*((void *)self + 10);
      int v51 = *((void *)self + 11);
      *((void *)self + 10) = v39;
      *((void *)self + 11) = v40;
      *((void *)self + 12) = v42;
      if (v52) {
        operator delete(v52);
      }
    }
  }

  uint64_t v55 = objc_claimAutoreleasedReturnValue(+[NSMutableArray arrayWithCapacity:](&OBJC_CLASS___NSMutableArray, "arrayWithCapacity:", v251));
  uint64_t v56 = (void *)*((void *)self + 21);
  *((void *)self + 21) = v55;

  uint64_t v57 = objc_claimAutoreleasedReturnValue(+[NSMutableArray arrayWithCapacity:](&OBJC_CLASS___NSMutableArray, "arrayWithCapacity:", v251));
  id v58 = (void *)*((void *)self + 22);
  *((void *)self + 22) = v57;

  __int16 v59 = objc_claimAutoreleasedReturnValue(+[NSMutableArray arrayWithCapacity:](&OBJC_CLASS___NSMutableArray, "arrayWithCapacity:", v251));
  id v60 = (void *)*((void *)self + 23);
  *((void *)self + 23) = v59;

  vm_size_t v61 = objc_claimAutoreleasedReturnValue(+[NSMutableArray arrayWithCapacity:](&OBJC_CLASS___NSMutableArray, "arrayWithCapacity:", v251));
  char v62 = (void *)*((void *)self + 24);
  *((void *)self + 24) = v61;

  id v63 = v251;
  id v65 = (void *)*((void *)self + 25);
  id v64 = (void *)*((void *)self + 26);
  uint64_t v66 = 0xAAAAAAAAAAAAAAABLL * (v64 - v65);
  id v67 = v251 - v66;
  if (v251 > v66)
  {
    uint64_t v68 = *((void *)self + 27);
    if (0xAAAAAAAAAAAAAAABLL * ((v68 - (uint64_t)v64) >> 3) >= v67)
    {
      bzero(*((void **)self + 26), 24 * ((24 * v67 - 24) / 0x18) + 24);
      *((void *)self + 26) = &v64[3 * ((24 * v67 - 24) / 0x18) + 3];
      goto LABEL_82;
    }

    int v69 = 0xAAAAAAAAAAAAAAABLL * ((v68 - (uint64_t)v65) >> 3);
    int v70 = 0x5555555555555556LL * ((v68 - (uint64_t)v65) >> 3);
    if (v70 > v251) {
      id v63 = v70;
    }
    if (v69 >= 0x555555555555555LL) {
      int v71 = 0xAAAAAAAAAAAAAAALL;
    }
    else {
      int v71 = v63;
    }
    if (v71 > 0xAAAAAAAAAAAAAAALL) {
      goto LABEL_270;
    }
    __int16 v72 = (char *)operator new(24 * v71);
    char v73 = &v72[8 * (v64 - v65)];
    id v74 = &v72[24 * v71];
    double v75 = 24 * ((24 * v67 - 24) / 0x18) + 24;
    bzero(v73, v75);
    uint64_t v76 = &v73[v75];
    if (v64 == v65)
    {
      *((void *)self + 25) = v73;
      *((void *)self + 26) = v76;
      *((void *)self + 27) = v74;
      if (!v64) {
        goto LABEL_82;
      }
    }

    else
    {
      do
      {
        *((void *)v73 - 3) = 0LL;
        *((void *)v73 - 2) = 0LL;
        v73 -= 24;
        *((void *)v73 + 2) = 0LL;
        uint64_t v77 = *(_OWORD *)(v64 - 3);
        v64 -= 3;
        *(_OWORD *)char v73 = v77;
        *((void *)v73 + 2) = v64[2];
        *id v64 = 0LL;
        v64[1] = 0LL;
        void v64[2] = 0LL;
      }

      while (v64 != v65);
      uint64_t v78 = (void *)*((void *)self + 25);
      id v64 = (void *)*((void *)self + 26);
      *((void *)self + 25) = v73;
      *((void *)self + 26) = v76;
      *((void *)self + 27) = v74;
      if (v64 != v78)
      {
        do
        {
          v64 -= 3;
          *(void *)uint64_t v252 = v64;
          std::vector<std::unique_ptr<std::vector<std::vector<std::pair<unsigned int,double>>>>>::__destroy_vector::operator()[abi:nn180100]((void ***)v252);
        }

        while (v64 != v78);
        id v64 = v78;
      }

      if (!v64) {
        goto LABEL_82;
      }
    }

    operator delete(v64);
    goto LABEL_82;
  }

  if (v251 < v66)
  {
    id v79 = &v65[3 * v251];
    while (v64 != v79)
    {
      v64 -= 3;
      *(void *)uint64_t v252 = v64;
      std::vector<std::unique_ptr<std::vector<std::vector<std::pair<unsigned int,double>>>>>::__destroy_vector::operator()[abi:nn180100]((void ***)v252);
    }

    *((void *)self + 26) = v79;
  }

      double result = apr_hash_next(v6);
      dispatch_queue_attr_t v6 = result;
    }

    while (result);
  }

  return result;
}

      uint64_t v26 = 1LL;
LABEL_32:

      return v26;
    }

    uint64_t v24 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"Dispatched total threads per grid (width(%llu) * height(%llu) * depth(%llu)) must not be 0",  v29,  v30,  v31));
    if (!a2) {
      goto LABEL_31;
    }
    unint64_t v25 = @"Failed to launch compute kernel: Dispatched total threads per grid size is 0";
LABEL_30:
    id Error = GTShaderDebuggerMakeError(4u, v25, v24, 0LL, 0LL);
    *a2 = (id)objc_claimAutoreleasedReturnValue(Error);
    goto LABEL_31;
  }

  return 1LL;
}

      if ((*((_BYTE *)v9 + 33) & 0x20) != 0) {
        goto LABEL_28;
      }
    }

    uint64_t v17 = __s[0];
    if (!__s[0]) {
      goto LABEL_20;
    }
LABEL_17:
    int v18 = strlen(v17);
    id v19 = *(char **)(a2 + 184);
    int v11 = v19;
    id v20 = v18 + 1;
    if (v18 == -1LL) {
LABEL_21:
    }
      int v11 = 0LL;
    *(void *)(a2 + 184) = &v19[v20];
    if (a3)
    {
      memcpy(v11, v17, v20);
      id v5 = v26;
    }

    else
    {
      id v5 = v16;
    }

    goto LABEL_25;
  }

  uint64_t v30 = 0;
LABEL_26:
  id v31 = *(void *)(a3 + 192);
  double result = v31 + 64;
  *(void *)(a3 + 192) = v31 + 64;
  if (a4)
  {
    if (v27 == 255) {
      LOBYTE(v27) = 0;
    }
    *(void *)id v31 = v20;
    *(void *)(v31 + _Block_object_dispose(va, 8) = v8;
    if (v26 == -1) {
      uint64_t v26 = 0LL;
    }
    *(void *)(v31 + 16) = v26;
    if (v25 == 255) {
      id v33 = 0;
    }
    else {
      id v33 = v25;
    }
    *(int32x4_t *)(v31 + 24) = v21;
    if (v24 == 255) {
      LOBYTE(v24) = 0;
    }
    if (v22 == 255) {
      LOBYTE(v22) = 0;
    }
    *(_DWORD *)(v31 + 40) = v13;
    *(_DWORD *)(v31 + 44) = v11;
    *(_WORD *)(v31 + 4_Block_object_dispose(va, 8) = v30;
    *(_BYTE *)(v31 + 50) = v24;
    *(_BYTE *)(v31 + 51) = v23;
    *(_BYTE *)(v31 + 52) = v27;
    *(_BYTE *)(v31 + 53) = v29;
    *(_BYTE *)(v31 + 54) = v22;
    *(_BYTE *)(v31 + 55) = v34;
    *(_BYTE *)(v31 + 56) = v36;
    *(_BYTE *)(v31 + 57) = v35;
    *(_BYTE *)(v31 + 5_Block_object_dispose(va, 8) = v10;
    *(_BYTE *)(v31 + 59) = v9;
    *(_BYTE *)(v31 + 60) = v28;
    *(_BYTE *)(v31 + 61) = v37;
    *(_BYTE *)(v31 + 62) = v33;
    *(_BYTE *)(v31 + 63) = v38;
  }

  return result;
}

void sub_93948( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, void *a13, void *a14, void *a15, void *a16, uint64_t a17, void *a18, void *a19, void *a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, char a37)
{
  std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long>>>::~__hash_table((uint64_t)&a37);
  _Block_object_dispose((const void *)(v39 - 192), 8);

  _Unwind_Resume(a1);
}

void GetConsistentPStates( NSDictionary *a1, unsigned int *a2, unsigned int *a3, double *a4, unsigned int *a5)
{
  int v16 = a1;
  uint64_t v9 = (void *)objc_claimAutoreleasedReturnValue(-[NSDictionary objectForKeyedSubscript:](v16, "objectForKeyedSubscript:", @"GPUState"));
  int v10 = v9;
  if (!v9 || (unsigned int v11 = [v9 unsignedIntValue], (*a5 = v11) == 0))
  {
    BOOL v12 = (void *)objc_claimAutoreleasedReturnValue(-[NSDictionary objectForKeyedSubscript:](v16, "objectForKeyedSubscript:", @"XPState"));
    uint64_t v13 = v12;
    if (v12)
    {
      [v12 doubleValue];
      double v15 = floor(v14);
      *a2 = (v15 * 100.0);
      *a3 = (ceil(v14) * 100.0);
      *a4 = v14 - v15;
    }

    else
    {
      *a3 = 3;
      *a2 = 3;
    }
  }
}

void sub_93C70( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

NSOperation *ProfilingTimingDataLegacy( uint64_t a1, id *a2, void *a3, void *a4, void *a5, int a6, int a7, int a8, uint64_t a9)
{
  id v16 = a3;
  id v17 = a4;
  id v18 = a5;
  v39[0] = 0LL;
  v39[1] = v39;
  v39[2] = 0x3032000000LL;
  v39[3] = __Block_byref_object_copy__53;
  void v39[4] = __Block_byref_object_dispose__54;
  id v19 = (void *)objc_claimAutoreleasedReturnValue( +[NSArray arrayWithObjects:]( &OBJC_CLASS___NSArray,  "arrayWithObjects:",  @"MTLStatCommandBufferIndex",  @"MTLStatEncoderIndex",  @"MTLStatCommandIndex",  @"MTLStat_nSec",  @"MTLStatDataMaster",  @"MTLStatSampleLocation",  @"MTLStatTotalGPUCycles",  0LL));
  id v40 = [v19 mutableCopy];

  v27[0] = _NSConcreteStackBlock;
  v27[1] = 3221225472LL;
  v27[2] = ___ZL25ProfilingTimingDataLegacyP21GTMTLReplayControllerP26GTMTLReplayOperationQueuesP12NSDictionaryP19NSMutableDictionaryS6_P14NSMutableArrayIP8NSNumberEjjjP21GTAGXPerfStateControl_block_invoke;
  v27[3] = &unk_58DE80;
  id v32 = v39;
  uint64_t v33 = a1;
  id v20 = objc_alloc_init(&OBJC_CLASS___NSOperation);
  unsigned int v28 = v20;
  unsigned int v34 = a2;
  int v36 = a6;
  id v21 = v18;
  id v29 = v21;
  uint64_t v35 = a9;
  int v37 = a8;
  int v38 = a7;
  id v22 = v16;
  id v30 = v22;
  id v23 = v17;
  id v31 = v23;
  uint64_t v24 = (void *)objc_claimAutoreleasedReturnValue( +[NSBlockOperation blockOperationWithBlock:]( &OBJC_CLASS___NSBlockOperation,  "blockOperationWithBlock:",  v27));
  [v24 setQueuePriority:-8];
  [*a2 addOperation:v24];
  -[NSOperation addDependency:](v20, "addDependency:", v24);
  [a2[1] addOperation:v20];
  unint64_t v25 = v20;

  _Block_object_dispose(v39, 8);
  return v25;
}

void sub_93EC4( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *a20, void *a21, void *a22, void *a23)
{
  _Block_object_dispose((const void *)(v27 - 136), 8);
  _Unwind_Resume(a1);
}

void GRCInfo::GRCInfo(GRCInfo *this, GTMTLReplayController *a2, int a3, GTAGXPerfStateControl *a4)
{
  *(void *)this = a2;
  *((void *)this + 1) = a4;
  *((_OWORD *)this + 1) = 0u;
  id v5 = (id *)((char *)this + 16);
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *((_DWORD *)this + 16) = a3;
  *((_WORD *)this + 34) = 0;
  GRCReleaseAllCounterSourceGroup();
  context = objc_autoreleasePoolPush();
  uint64_t v6 = GRCCopyAllCounterSourceGroup();
  id v7 = *v5;
  id *v5 = (id)v6;

  if (*v5 && [*v5 count])
  {
    id v23 = (void *)objc_claimAutoreleasedReturnValue([*v5 firstObject]);
    uint64_t v24 = (void *)objc_claimAutoreleasedReturnValue([v23 sourceList]);
    if (!v24 || ![v24 count]) {
      goto LABEL_21;
    }
    obuint64_t j = (id)objc_claimAutoreleasedReturnValue(+[NSMutableArray arrayWithCapacity:](&OBJC_CLASS___NSMutableArray, "arrayWithCapacity:", 3LL));
    __int128 v29 = 0u;
    __int128 v30 = 0u;
    __int128 v27 = 0u;
    __int128 v28 = 0u;
    id v8 = v24;
    id v9 = [v8 countByEnumeratingWithState:&v27 objects:v31 count:16];
    if (v9)
    {
      uint64_t v10 = *(void *)v28;
LABEL_7:
      uint64_t v11 = 0LL;
      while (1)
      {
        if (*(void *)v28 != v10) {
          objc_enumerationMutation(v8);
        }
        BOOL v12 = *(void **)(*((void *)&v27 + 1) + 8 * v11);
        uint64_t v13 = (void *)objc_claimAutoreleasedReturnValue([v12 name]);
        unsigned int v14 = [v13 hasPrefix:@"Firmware"];

        if (v14) {
          [obj addObject:v12];
        }
        if (v9 == (id)++v11)
        {
          id v9 = [v8 countByEnumeratingWithState:&v27 objects:v31 count:16];
          if (v9) {
            goto LABEL_7;
          }
          goto LABEL_15;
        }
      }
    }

    else
    {
LABEL_15:

      if (![obj count])
      {
LABEL_20:

LABEL_21:
        goto LABEL_22;
      }

      objc_storeStrong((id *)this + 3, obj);
      *((void *)this + 4) = [v23 sampleMarker];
      uint64_t v15 = objc_claimAutoreleasedReturnValue(+[NSMutableArray arrayWithCapacity:](&OBJC_CLASS___NSMutableArray, "arrayWithCapacity:", 7LL));
      id v16 = (void *)*((void *)this + 6);
      *((void *)this + 6) = v15;

      for (uint64_t i = 0LL; i != 7; ++i)
      {
        id v18 = (void *)*((void *)this + 6);
        id v19 = (void *)objc_claimAutoreleasedReturnValue([&off_59F8F0 objectAtIndexedSubscript:i]);
        id v20 = (void *)objc_claimAutoreleasedReturnValue( +[GPURawCounterSelect selectWithName:options:]( &OBJC_CLASS___GPURawCounterSelect,  "selectWithName:options:",  v19,  0LL));
        [v18 addObject:v20];
      }

      id v8 = (id)objc_claimAutoreleasedReturnValue( +[GPURawCounterSourceTriggerSelect selectWithName:options:]( &OBJC_CLASS___GPURawCounterSourceTriggerSelect,  "selectWithName:options:",  @"KickBoundary",  0LL));
      uint64_t v21 = objc_claimAutoreleasedReturnValue(+[NSMutableArray arrayWithObject:](&OBJC_CLASS___NSMutableArray, "arrayWithObject:", v8));
      id v22 = (void *)*((void *)this + 5);
      *((void *)this + 5) = v21;
    }

    goto LABEL_20;
  }

void sub_94218( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9, void *a10, void *a11)
{
  GPURawCounterSetupParams::~GPURawCounterSetupParams(v12);
  _Unwind_Resume(a1);
}

void DisableComputeEncoderCoalescing(uint64_t a1, uint64_t a2)
{
  if (a1)
  {
    vm_size_t v2 = *(void **)(a1 + 8);
    if (v2)
    {
      id v4 = (void *)objc_claimAutoreleasedReturnValue([v2 defaultDevice]);
      id v5 = DEVICEOBJECT(v4);
      id v6 = (id)objc_claimAutoreleasedReturnValue(v5);

      if (v6)
      {
        if ((objc_opt_respondsToSelector(v6, "disableComputeEncoderCoalescing") & 1) != 0) {
          [v6 setDisableComputeEncoderCoalescing:a2];
        }
      }
    }
  }

void sub_94350( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
}

__n128 __Block_byref_object_copy__94(__n128 *a1, __n128 *a2)
{
  a1[3].n128_u64[0] = 0LL;
  a1[3].n128_u64[1] = 0LL;
  a1[4].n128_u64[0] = 0LL;
  __n128 result = a2[3];
  a1[3] = result;
  a1[4].n128_u64[0] = a2[4].n128_u64[0];
  a2[3].n128_u64[0] = 0LL;
  a2[3].n128_u64[1] = 0LL;
  a2[4].n128_u64[0] = 0LL;
  return result;
}

void __Block_byref_object_dispose__95(uint64_t a1)
{
  vm_size_t v2 = *(void **)(a1 + 48);
  if (v2)
  {
    *(void *)(a1 + 56) = v2;
    operator delete(v2);
  }

void ___ZL14GPUTimeDataGRCP26GTMTLReplayOperationQueuesP14NSMutableArrayIP8NSNumberEjR7GRCInfo_block_invoke( uint64_t a1)
{
  uint64_t v2 = *(void *)(*(void *)(a1 + 40) + 8LL);
  unint64_t v3 = *(void *)(v2 + 48);
  id v4 = *(unint64_t **)(v2 + 56);
  unint64_t v5 = 126 - 2 * __clz(0xAAAAAAAAAAAAAAABLL * ((uint64_t)((uint64_t)v4 - v3) >> 3));
  else {
    uint64_t v6 = v5;
  }
  std::__introsort<std::_ClassicAlgPolicy,std::__less<void,void> &,std::tuple<unsigned long long,unsigned long long,unsigned long long> *,false>( v3,  v4,  v6,  1);
  uint64_t v7 = *(void *)(*(void *)(a1 + 40) + 8LL);
  id v8 = *(unint64_t **)(v7 + 48);
  id v9 = *(unint64_t **)(v7 + 56);
  if (v8 == v9)
  {
    uint64_t v10 = 0LL;
  }

  else
  {
    uint64_t v10 = 0LL;
    unint64_t v11 = 0LL;
    do
    {
      unint64_t v12 = *v8;
      unint64_t v13 = v8[1];
      v8 += 3;
      if (v11 <= v12) {
        unint64_t v11 = v12;
      }
      BOOL v14 = v13 >= v11;
      unint64_t v15 = v13 - v11;
      if (v13 > v11) {
        unint64_t v11 = v13;
      }
      if (!v14) {
        unint64_t v15 = 0LL;
      }
      v10 += v15;
    }

    while (v8 != v9);
  }

  id v16 = (id)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLongLong:](&OBJC_CLASS___NSNumber, "numberWithUnsignedLongLong:", v10));
  objc_msgSend(*(id *)(a1 + 32), "setObject:atIndexedSubscript:");
  [*(id *)(a1 + 32) setObject:v16 atIndexedSubscript:0];
}

void sub_9448C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
}

void ___ZL14GPUTimeDataGRCP26GTMTLReplayOperationQueuesP14NSMutableArrayIP8NSNumberEjR7GRCInfo_block_invoke_2( uint64_t a1)
{
  uint64_t v1 = a1;
  GTMTLReplayController_prePlayForProfiling(**(void **)(a1 + 40));
  GRCInfo::SetupSource(*(void *)(v1 + 40), *(unsigned int *)(v1 + 48), 0, 0LL);
  uint64_t v2 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(*(void *)(v1 + 40) + 16) firstObject]);
  [v2 startSampling];

  unint64_t v3 = objc_autoreleasePoolPush();
  id v4 = *(id ***)(v1 + 40);
  uint64_t v5 = *(void *)(*(void *)(v1 + 32) + 8LL);
  v28[1] = *v4;
  char v29 = 0;
  v28[0] = [(id)g_commandBufferDescriptor errorOptions];
  [(id)g_commandBufferDescriptor setErrorOptions:0];
  id v25 = (*v4)[1];
  uint64_t v6 = *v4;
  uint64_t v7 = (uint64_t *)**v4;
  char v27 = 0;
  if (v7[13] + v7[12] > (unint64_t)*((unsigned int *)v6 + 5620))
  {
    id v23 = v3;
    uint64_t v24 = v1;
    uint64_t v8 = v7[15];
    do
    {
      id v9 = objc_autoreleasePoolPush();
      uint64_t v10 = *(void *)(v8 + 24);
      unint64_t v11 = *v4;
      uint64_t v12 = *((unsigned int *)*v4 + 5620);
      int FuncEnumConstructorType = GetFuncEnumConstructorType(*(_DWORD *)(v10 + (v12 << 6) + 8));
      if (FuncEnumConstructorType == 25)
      {
        GTMTLReplayController_restoreCommandBuffer((uint64_t)v11, v10 + (v12 << 6));
        unint64_t v11 = *v4;
      }

      GTMTLReplayController_updateCommandEncoder((uint64_t)v11, v10 + (v12 << 6));
      DispatchFunction(*v4, v10 + (v12 << 6), &v27);
      if (FuncEnumConstructorType == 25)
      {
        id v14 = objc_msgSend( v25,  "commandBufferForKey:",  *((void *)GTTraceFunc_argumentBytesWithMap( (void *)(v10 + (v12 << 6)),  *(unsigned __int8 *)(v10 + (v12 << 6) + 13),  v7[2])
                + 1));
        unint64_t v15 = (void *)objc_claimAutoreleasedReturnValue(v14);
        v26[0] = _NSConcreteStackBlock;
        v26[1] = 3221225472LL;
        v26[2] = ___ZN7GRCInfo23ReplayForTimingCountersERNSt3__16vectorINS0_5tupleIJyyyEEENS0_9allocatorIS3_EEEE_block_invoke;
        v26[3] = &__block_descriptor_40_e28_v16__0___MTLCommandBuffer__8l;
        v26[4] = v5 + 48;
        [v15 addCompletedHandler:v26];
      }

      objc_autoreleasePoolPop(v9);
      uint64_t v6 = *v4;
      unint64_t v16 = (*((_DWORD *)*v4 + 5620) + 1);
      *((_DWORD *)*v4 + 5620) = v16;
    }

    while (v7[13] + v7[12] > v16);
    unint64_t v3 = v23;
    uint64_t v1 = v24;
  }

  *((_DWORD *)v6 + 5621) = 0;
  id v17 = (void *)objc_claimAutoreleasedReturnValue([v6[1] defaultCommandQueue]);
  [v17 finish];

  GRCInfo::ScopedReplayConfiguration::~ScopedReplayConfiguration((GRCInfo::ScopedReplayConfiguration *)v28);
  id v18 = *(id **)(v1 + 40);
  id v19 = GRCInfo::DrainRawFrameData(v18);
  id v20 = (void *)objc_claimAutoreleasedReturnValue(v19);
  id v21 = GRCInfo::PostProcessFrameData((uint64_t)v18, v20);

  objc_autoreleasePoolPop(v3);
  id v22 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(*(void *)(v1 + 40) + 16) firstObject]);
  [v22 stopSampling];

  GRCInfo::AddConsistencyInfo(*(GTAGXPerfStateControl ***)(v1 + 40));
  GTAGXPerfStateControl::DisableConsistentGPUPerfState(*(GTAGXPerfStateControl **)(*(void *)(v1 + 40) + 8LL));
}

void sub_9472C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__171(uint64_t result, void *a2)
{
  uint64_t v2 = a2[6];
  a2[6] = 0LL;
  *(void *)(result + 4_Block_object_dispose(va, 8) = v2;
  *(void *)(result + 56) = a2[7];
  a2[7] = 0LL;
  uint64_t v5 = a2[8];
  unint64_t v3 = a2 + 8;
  uint64_t v4 = v5;
  *(void *)(result + 64) = v5;
  uint64_t v6 = v3[1];
  *(void *)(result + 72) = v6;
  *(_DWORD *)(result + 80) = *((_DWORD *)v3 + 4);
  if (v6)
  {
    unint64_t v7 = *(void *)(v4 + 8);
    unint64_t v8 = *(void *)(result + 56);
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v7 >= v8) {
        v7 %= v8;
      }
    }

    else
    {
      v7 &= v8 - 1;
    }

    *(void *)(v2 + 8 * v7) = result + 64;
    void *v3 = 0LL;
    v3[1] = 0LL;
  }

  return result;
}

uint64_t __Block_byref_object_dispose__172(uint64_t a1)
{
  return std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long>>>::~__hash_table(a1 + 48);
}

__n128 __Block_byref_object_copy__173(__n128 *a1, __n128 *a2)
{
  a1[3].n128_u64[0] = 0LL;
  a1[3].n128_u64[1] = 0LL;
  a1[4].n128_u64[0] = 0LL;
  __n128 result = a2[3];
  a1[3] = result;
  a1[4].n128_u64[0] = a2[4].n128_u64[0];
  a2[3].n128_u64[0] = 0LL;
  a2[3].n128_u64[1] = 0LL;
  a2[4].n128_u64[0] = 0LL;
  return result;
}

void __Block_byref_object_dispose__174(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 48);
  if (v2)
  {
    *(void *)(a1 + 56) = v2;
    operator delete(v2);
  }

void ___ZL15KickTimeDataGRCP26GTMTLReplayOperationQueuesP19NSMutableDictionaryjR7GRCInfoP7NSArray_block_invoke( uint64_t a1)
{
  uint64_t v2 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(*(void *)(*(void *)(a1 + 48) + 8) + 40) firstObject]);
  if (!v2) {
    goto LABEL_55;
  }
  unint64_t v3 = *(void **)(*(void *)(a1 + 56) + 8LL);
  unint64_t v4 = *(void *)(*(void *)(*(void *)(a1 + 64) + 8LL) + 72LL);
  uint64_t v6 = (char *)v3[6];
  uint64_t v5 = (char *)v3[7];
  unint64_t v7 = 0x8E38E38E38E38E39LL * ((v5 - v6) >> 3);
  unint64_t v8 = v4 - v7;
  id v56 = v2;
  if (v4 <= v7)
  {
    if (v4 < v7) {
      v3[7] = &v6[72 * v4];
    }
    goto LABEL_22;
  }

  uint64_t v9 = v3[8];
  if (0x8E38E38E38E38E39LL * ((v9 - (uint64_t)v5) >> 3) >= v8)
  {
    bzero(v5, 72 * ((72 * v8 - 72) / 0x48) + 72);
    v3[7] = &v5[72 * ((72 * v8 - 72) / 0x48) + 72];
  }

  else
  {
    if (v4 > 0x38E38E38E38E38ELL) {
      abort();
    }
    unint64_t v10 = 0x8E38E38E38E38E39LL * ((v9 - (uint64_t)v6) >> 3);
    if (2 * v10 > v4) {
      unint64_t v4 = 2 * v10;
    }
    if (v10 >= 0x1C71C71C71C71C7LL) {
      unint64_t v11 = 0x38E38E38E38E38ELL;
    }
    else {
      unint64_t v11 = v4;
    }
    if (v11 > 0x38E38E38E38E38ELL) {
      std::__throw_bad_array_new_length[abi:nn180100]();
    }
    uint64_t v12 = (char *)operator new(72 * v11);
    unint64_t v13 = &v12[8 * ((v5 - v6) >> 3)];
    id v14 = &v12[72 * v11];
    size_t v15 = 72 * ((72 * v8 - 72) / 0x48) + 72;
    bzero(v13, v15);
    unint64_t v16 = &v13[v15];
    if (v5 == v6)
    {
      uint64_t v2 = v56;
    }

    else
    {
      uint64_t v2 = v56;
      do
      {
        *(_OWORD *)(v13 - 72) = *(_OWORD *)(v5 - 72);
        __int128 v17 = *(_OWORD *)(v5 - 56);
        __int128 v18 = *(_OWORD *)(v5 - 40);
        __int128 v19 = *(_OWORD *)(v5 - 24);
        *((void *)v13 - 1) = *((void *)v5 - 1);
        *(_OWORD *)(v13 - 24) = v19;
        *(_OWORD *)(v13 - 40) = v18;
        *(_OWORD *)(v13 - 56) = v17;
        v13 -= 72;
        v5 -= 72;
      }

      while (v5 != v6);
      uint64_t v5 = v6;
    }

    v3[6] = v13;
    v3[7] = v16;
    v3[8] = v14;
    if (!v5) {
      goto LABEL_22;
    }
    operator delete(v5);
  }

  uint64_t v2 = v56;
LABEL_22:
  id v20 = v2;
  id v21 = (char *)[v20 bytes];
  uint64_t v22 = 0LL;
  id v23 = 0LL;
  while (1)
  {
    int NextMarker = GRCInfo::FindNextMarker((GRCInfo *)v20, v23, *(void *)(*(void *)(a1 + 72) + 32LL));
    int v26 = NextMarker;
    if (NextMarker == -1) {
      break;
    }
    char v27 = &v21[8 * NextMarker];
    __int128 v28 = std::__hash_table<std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>>>::find<unsigned int>( (void *)(*(void *)(*(void *)(a1 + 64) + 8LL) + 48LL),  *((_DWORD *)v27 + 8));
    id v23 = (NSData *)(v26 + 8);
    if (v28)
    {
      BOOL v29 = *((void *)v27 + 3) > 5uLL || (*((void *)v27 + 3) & 1LL) == 0;
      if (v29
        || (unint64_t v30 = *((unsigned int *)v28 + 6),
            uint64_t v31 = *(void *)(*(void *)(a1 + 56) + 8LL),
            uint64_t v32 = *(void *)(v31 + 48),
            0x8E38E38E38E38E39LL * ((*(void *)(v31 + 56) - v32) >> 3) <= v30))
      {
        uint64_t v33 = (uint64_t *)(v27 + 8);
      }

      else
      {
        uint64_t v33 = (uint64_t *)(v27 + 8);
        unint64_t v34 = 125 * (*((void *)v27 + 1) - v22);
        *(void *)(v32 + 72LL * v30) += v34 / 3;
        if ([*(id *)(a1 + 32) count])
        {
          if (*(_WORD *)v27) {
            *(void *)(v32 + 72LL * v30 + 56) += *((void *)v27 + 8);
          }
        }

        unint64_t v35 = v34 / 3;
        uint64_t v36 = *((void *)v27 + 3);
        switch(v36)
        {
          case 5LL:
            *(void *)(v32 + 72LL * v30 + 24) += 2 * v35;
            int v38 = 4;
            break;
          case 3LL:
            uint64_t v39 = v32 + 72LL * v30;
            *(void *)(v39 + 16) += v35;
            *(void *)(v39 + 40) += *((void *)v27 + 2);
            int v38 = 2;
            break;
          case 1LL:
            uint64_t v37 = v32 + 72LL * v30;
            *(void *)(v37 + 8) += v35;
            *(void *)(v37 + 32) += *((void *)v27 + 2);
            int v38 = 1;
            break;
          default:
            goto LABEL_38;
        }

        *(_DWORD *)(v32 + 72LL * v30 + 64) |= v38;
      }

LABEL_38:
      uint64_t v22 = *v33;
    }
  }

  id v40 = &CATransform3DIdentity_ptr;
  vm_size_t v61 = (void *)objc_opt_new(&OBJC_CLASS___NSMutableArray, v25);
  id v60 = (void *)objc_opt_new(&OBJC_CLASS___NSMutableArray, v41);
  __int16 v59 = (void *)objc_opt_new(&OBJC_CLASS___NSMutableArray, v42);
  id v58 = (void *)objc_opt_new(&OBJC_CLASS___NSMutableArray, v43);
  uint64_t v44 = *(void *)(*(void *)(a1 + 56) + 8LL);
  uint64_t v45 = *(void *)(v44 + 48);
  for (uint64_t i = *(void *)(v44 + 56); v45 != i; v45 += 72LL)
  {
    if (*(_DWORD *)(v45 + 64))
    {
      unint64_t v46 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  *(void *)v45));
      [v61 addObject:v46];

      if ([*(id *)(a1 + 32) count])
      {
        uint64_t v47 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  *(void *)(v45 + 56)));
        [v58 addObject:v47];
      }

      unsigned __int8 v48 = (void *)objc_claimAutoreleasedReturnValue(-[CATransform3D arrayWithCapacity:]((id)v40[273], "arrayWithCapacity:", 3LL, v56));
      id v49 = v40;
      unsigned __int8 v50 = (void *)objc_claimAutoreleasedReturnValue(-[CATransform3D arrayWithCapacity:]((id)v40[273], "arrayWithCapacity:", 3LL));
      if (*(_DWORD *)(v45 + 64)) {
        int v51 = *(_DWORD *)(v45 + 64);
      }
      else {
        int v51 = 2;
      }
      do
      {
        unsigned int v52 = v51 & -v51;
        uint64_t v53 = v52 >> 1;
        double v54 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  *(void *)(v45 + 8LL * v53 + 8)));
        [v48 addObject:v54];

        uint64_t v55 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  *(void *)(v45 + 8 * v53 + 32)));
        [v50 addObject:v55];

        v51 ^= v52;
      }

      while (v51);
      [v60 addObject:v48];
      [v59 addObject:v50];

      id v40 = v49;
    }
  }

  objc_msgSend(*(id *)(a1 + 40), "setObject:forKeyedSubscript:", v61, @"encoder time data", v56);
  [*(id *)(a1 + 40) setObject:v60 forKeyedSubscript:@"kick time data"];
  [*(id *)(a1 + 40) setObject:v59 forKeyedSubscript:@"kick cycle data"];
  if ([v58 count]) {
    [*(id *)(a1 + 40) setObject:v58 forKeyedSubscript:@"tilerParamBufBytesUsedArray"];
  }

  uint64_t v2 = v57;
LABEL_55:
}

    uint64_t v9 = v71;
    unint64_t v34 = [v71 encoderCount];
    unint64_t v35 = v34;
    if (v34)
    {
      uint64_t v36 = 48LL * v34;
      uint64_t v37 = (char *)operator new(v36);
      bzero(v37, 48 * ((v36 - 48) / 0x30) + 48);
      int v38 = std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned int>>(v35);
      bzero(v38, 4LL * v35);
      id v40 = (uint64_t *)v80;
      for (i = v38; v40; id v40 = (uint64_t *)*v40)
      {
        uint64_t v41 = 0LL;
        uint64_t v42 = *((_DWORD *)v40 + 4);
        uint64_t v43 = (double *)(v40 + 6);
        uint64_t v44 = -3LL;
        uint64_t v45 = v37 + 24;
        do
        {
          unint64_t v46 = v42 % v35;
          uint64_t v47 = (uint64_t)&v37[48 * v46 + 8 * v41];
          *(double *)(v47 + 24) = *v43 + *(double *)(v47 + 24);
          unsigned __int8 v48 = *(v43 - 3);
          if (v48 < *v43)
          {
            fprintf(__stderrp, "%u[%u]: Duration %f < Effective Time %f\n", v42, v44 + 3, *(v43 - 3), *v43);
            unsigned __int8 v48 = *(v43 - 3);
            uint64_t v42 = *((_DWORD *)v40 + 4);
            unint64_t v46 = v42 % v35;
          }

          id v49 = &v45[48 * v46];
          uint64_t v39 = v48 + *((double *)v49 - 3);
          *((double *)v49 - 3) = v39;
          ++v41;
          v45 += 8;
          ++v43;
        }

        while (!__CFADD__(v44++, 1LL));
        int v38 = i;
        ++*((_DWORD *)i + v46);
      }

      int v51 = 0LL;
      if (v35 <= 1uLL) {
        unsigned int v52 = 1LL;
      }
      else {
        unsigned int v52 = v35;
      }
      uint64_t v53 = v37;
      uint64_t v9 = v71;
      unint64_t v10 = v72;
      do
      {
        double v54 = 0LL;
        LODWORD(v39) = *((_DWORD *)v38 + v51);
        uint64_t v39 = (double)*(unint64_t *)&v39;
        do
        {
          uint64_t v55 = (double *)&v53[v54];
          v55[3] = *(double *)&v53[v54 + 24] / v39;
          void *v55 = *(double *)&v53[v54] / v39;
          v54 += 8LL;
        }

        while (v54 != 24);
        ++v51;
        v53 += 48;
      }

      while (v51 != v52);
      options = v70->_options;
      if ((*((_BYTE *)options + 16) & 0x40) != 0)
      {
        id v57 = objc_claimAutoreleasedReturnValue( [options->var0 stringByAppendingPathComponent:@"/EffectGPUTimePerBatch.txt"]);
        id v58 = fopen((const char *)[v57 UTF8String], "wt");
        if (v58)
        {
          char v73 = v57;
          __int16 v59 = *((void *)&v80 + 1);
          fwrite("Batch DM  Time\n", 0xFuLL, 1uLL, v58);
          id v60 = 0LL;
          vm_size_t v61 = v37;
          do
          {
            for (uint64_t j = 0LL; j != 3; ++j)
            {
              id v63 = *(double *)&v61[8 * j + 24];
              if (v63 > 2.22044605e-16) {
                fprintf( v58,  "%lu %u\t%f s / %f s = %f %% \n",  v60,  j,  v63 * 0.001,  *(double *)&v61[8 * j] * 0.001,  v63 * 100.0 / *(double *)&v61[8 * j]);
              }
            }

            ++v60;
            v61 += 48;
          }

          while (v60 != v52);
          fwrite("\n\n", 2uLL, 1uLL, v58);
          if (v59)
          {
            for (uint64_t k = 0LL; k != v59; ++k)
            {
              for (uint64_t m = 0LL; m != 3; ++m)
              {
                if (*(double *)&std::unordered_map<unsigned int,-[GTShaderProfilerHelper _calculateEffectiveGPUEncoderCostforData:andPerLimiterBatchCost:forShaderProfilerResult:]::TimeStats>::operator[]( (uint64_t)&v79,  k)[8 * m + 24] > 2.22044605e-16)
                {
                  uint64_t v66 = *(double *)&std::unordered_map<unsigned int,-[GTShaderProfilerHelper _calculateEffectiveGPUEncoderCostforData:andPerLimiterBatchCost:forShaderProfilerResult:]::TimeStats>::operator[]( (uint64_t)&v79,  k)[8 * m + 24];
                  id v67 = *(double *)&std::unordered_map<unsigned int,-[GTShaderProfilerHelper _calculateEffectiveGPUEncoderCostforData:andPerLimiterBatchCost:forShaderProfilerResult:]::TimeStats>::operator[]( (uint64_t)&v79,  k)[8 * m];
                  uint64_t v68 = *(double *)&std::unordered_map<unsigned int,-[GTShaderProfilerHelper _calculateEffectiveGPUEncoderCostforData:andPerLimiterBatchCost:forShaderProfilerResult:]::TimeStats>::operator[]( (uint64_t)&v79,  k)[8 * m + 24];
                  int v69 = std::unordered_map<unsigned int,-[GTShaderProfilerHelper _calculateEffectiveGPUEncoderCostforData:andPerLimiterBatchCost:forShaderProfilerResult:]::TimeStats>::operator[]( (uint64_t)&v79,  k);
                  fprintf( v58,  "%lu %u\t%f s / %f s = %f %% \n",  k,  m,  v66 * 0.001,  v67 * 0.001,  v68 * 100.0 / *(double *)&v69[8 * m]);
                }
              }
            }
          }

          fclose(v58);
          uint64_t v9 = v71;
          unint64_t v10 = v72;
          id v57 = v73;
          int v38 = i;
        }
      }

      if (v38) {
        operator delete(v38);
      }
      operator delete(v37);
    }

    std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long>>>::~__hash_table((uint64_t)&v76);
    std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long>>>::~__hash_table((uint64_t)&v79);
  }
}

      double v125 = (unint64_t *)v21;
      unint64_t v34 = *v23;
      if ((IsFuncEnumDrawCall(*v23) & 1) != 0 || (v34 & 0xFFFFFFFC) == 0xFFFFC1A4)
      {
        if (v19 && *v19 <= v18 && v19[1] >= v18) {
          goto LABEL_108;
        }
        InclusiveRange = GroupBuilder_findInclusiveRange(*(_DWORD *)(v119 + 12), *(void **)(v119 + 24), v18);
        if (InclusiveRange)
        {
          uint64_t v36 = InclusiveRange;
          while (1)
          {
            uint64_t v37 = *((_DWORD *)v36 + 7);
            if (v37 == -16353 || v37 == -16351) {
              break;
            }
            uint64_t v39 = *((unsigned int *)v36 + 4);
            if ((_DWORD)v39) {
              id v40 = v36 == 0LL;
            }
            else {
              id v40 = 1;
            }
            v36 -= 4 * v39;
            if (v40) {
              goto LABEL_54;
            }
          }

          bzero(&v130, 0x2B90uLL);
          GTMTLSMCommandEncoder_processTraceFunc((uint64_t)&v130, (uint64_t *)(*(void *)(v7 + 24) + (*v36 << 6)), v17);
          id v116 = v36;
          id v113 = v23;
          id v114 = v18;
          if ((_DWORD)v130 == 70 || (_DWORD)v130 == 65) {
            uint64_t v41 = (void *)v135[2];
          }
          else {
            uint64_t v41 = 0LL;
          }
          -[NSMutableArray removeAllObjects](v129, "removeAllObjects", v110);
          uint64_t v42 = 0LL;
          uint64_t v43 = 0LL;
          uint64_t v121 = v41;
          do
          {
            if (((v11 >> v43) & 1) != 0)
            {
              uint64_t v44 = &v41[v42];
              if (v41[v42 + 1])
              {
                uint64_t v45 = (unsigned __int16 *)(v44 + 2);
                unint64_t v46 = *v44 == 0LL;
                if (*v44) {
                  uint64_t v47 = *v44;
                }
                else {
                  uint64_t v47 = v41[v42 + 1];
                }
                if (*v44) {
                  unsigned __int8 v48 = (unsigned __int16 *)v44 + 10;
                }
                else {
                  unsigned __int8 v48 = (unsigned __int16 *)v44 + 11;
                }
                if (*v44) {
                  id v49 = (unsigned __int8 *)v44 + 26;
                }
                else {
                  id v49 = (unsigned __int8 *)(v44 + 3);
                }
                unsigned __int8 v50 = (unsigned __int16 *)v44 + 9;
                if (v46) {
                  unsigned __int8 v50 = v45;
                }
                double v127 = v50;
                GTMTLSMContext_getTextureDescriptor((uint64_t *)v122[5], v47, *v125, (uint64_t)&v130);
                int v51 = v122[1];
                unint64_t v141 = v47;
                unsigned int v52 = *(void *)(*(void *)(*find_entry(v51, &v141, 8uLL, 0LL) + 32LL) + 8LL);
                v149[0] = &off_5A0910;
                v148[0] = @"type";
                v148[1] = @"DependencyGraphRequestedTextureAttachmentIndex";
                uint64_t v53 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", v43));
                v149[1] = v53;
                v148[2] = @"object";
                double v54 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  v52));
                v149[2] = v54;
                v149[3] = v126;
                v148[3] = @"resolution";
                v148[4] = @"DependencyGraphRequestedTextureSlice";
                uint64_t v55 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", *v48));
                v149[4] = v55;
                v148[5] = @"DependencyGraphRequestedTextureLevel";
                id v56 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", *v49));
                v149[5] = v56;
                v148[6] = @"DependencyGraphRequestedTextureDepthPlane";
                id v57 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", *v127));
                v149[6] = v57;
                v148[7] = @"format";
                id v58 = +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  ResizeFormat(v134));
                __int16 v59 = (void *)objc_claimAutoreleasedReturnValue(v58);
                v149[7] = v59;
                id v60 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v149,  v148,  8LL));
                -[NSMutableArray addObject:](v129, "addObject:", v60);

                uint64_t v41 = v121;
                unint64_t v7 = v120;

                if (!v118)
                {
                  unint64_t v8 = v112;
                  unint64_t v16 = (uint64_t)v122;
                  __int128 v18 = v114;
                  __int128 v17 = v115;
                  __int128 v19 = v116;
                  goto LABEL_107;
                }
              }
            }

            ++v43;
            v42 += 8LL;
          }

          while (v42 != 64);
          __int128 v19 = v116;
          if ((v11 & 0x100) == 0 || !v41[85]) {
            goto LABEL_90;
          }
          vm_size_t v61 = v41[84];
          char v62 = v61 ? v41[84] : v41[85];
          id v63 = v61 ? 692LL : 694LL;
          id v64 = v61 ? 698LL : 696LL;
          id v65 = v61 ? 690LL : 688LL;
          GTMTLSMContext_getTextureDescriptor((uint64_t *)v122[5], v62, *v125, (uint64_t)&v130);
          uint64_t v66 = v122[1];
          unint64_t v141 = v62;
          id v67 = *(void *)(*(void *)(*find_entry(v66, &v141, 8uLL, 0LL) + 32LL) + 8LL);
          v146[0] = @"type";
          v146[1] = @"DependencyGraphRequestedTextureAttachmentIndex";
          v147[0] = &off_5A0910;
          v147[1] = &off_5A0928;
          v146[2] = @"object";
          uint64_t v68 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  v67));
          v147[2] = v68;
          v147[3] = v126;
          v146[3] = @"resolution";
          v146[4] = @"DependencyGraphRequestedTextureSlice";
          int v69 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithInt:]( &OBJC_CLASS___NSNumber,  "numberWithInt:",  *(unsigned __int16 *)((char *)v121 + v63)));
          v147[4] = v69;
          v146[5] = @"DependencyGraphRequestedTextureLevel";
          int v70 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithInt:]( &OBJC_CLASS___NSNumber,  "numberWithInt:",  *((unsigned __int8 *)v121 + v64)));
          v147[5] = v70;
          v146[6] = @"DependencyGraphRequestedTextureDepthPlane";
          int v71 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithInt:]( &OBJC_CLASS___NSNumber,  "numberWithInt:",  *(unsigned __int16 *)((char *)v121 + v65)));
          v147[6] = v71;
          v146[7] = @"format";
          __int16 v72 = +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  ResizeFormat(v134));
          char v73 = (void *)objc_claimAutoreleasedReturnValue(v72);
          v147[7] = v73;
          id v74 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v147,  v146,  8LL));
          -[NSMutableArray addObject:](v129, "addObject:", v74);

          unint64_t v7 = v120;
          uint64_t v41 = v121;

          __int128 v19 = v116;
          if (!v118)
          {
            unint64_t v8 = v112;
            unint64_t v16 = (uint64_t)v122;
            __int128 v18 = v114;
            __int128 v17 = v115;
          }

          else
          {
LABEL_90:
            unint64_t v8 = v112;
            unint64_t v16 = (uint64_t)v122;
            if ((v11 & 0x200) != 0 && v41[91])
            {
              double v75 = v41[90];
              uint64_t v76 = v41;
              if (v75) {
                uint64_t v77 = v41[90];
              }
              else {
                uint64_t v77 = v41[91];
              }
              if (v75) {
                uint64_t v78 = 740LL;
              }
              else {
                uint64_t v78 = 742LL;
              }
              if (v75) {
                id v79 = 746LL;
              }
              else {
                id v79 = 744LL;
              }
              unsigned int v80 = 738LL;
              if (!v75) {
                unsigned int v80 = 736LL;
              }
              uint64_t v128 = v80;
              GTMTLSMContext_getTextureDescriptor((uint64_t *)v122[5], v77, *v125, (uint64_t)&v130);
              uint64_t v81 = v122[1];
              unint64_t v141 = v77;
              uint64_t v82 = *(void *)(*(void *)(*find_entry(v81, &v141, 8uLL, 0LL) + 32LL) + 8LL);
              v144[0] = @"type";
              v144[1] = @"DependencyGraphRequestedTextureAttachmentIndex";
              v145[0] = &off_5A0910;
              v145[1] = &off_5A0940;
              v144[2] = @"object";
              int v83 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  v82));
              v145[2] = v83;
              v145[3] = v126;
              v144[3] = @"resolution";
              v144[4] = @"DependencyGraphRequestedTextureSlice";
              uint64_t v84 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithInt:]( &OBJC_CLASS___NSNumber,  "numberWithInt:",  *(unsigned __int16 *)((char *)v76 + v78)));
              v145[4] = v84;
              v144[5] = @"DependencyGraphRequestedTextureLevel";
              double v85 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithInt:]( &OBJC_CLASS___NSNumber,  "numberWithInt:",  *((unsigned __int8 *)v76 + v79)));
              v145[5] = v85;
              v144[6] = @"DependencyGraphRequestedTextureDepthPlane";
              uint64_t v86 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithInt:]( &OBJC_CLASS___NSNumber,  "numberWithInt:",  *(unsigned __int16 *)((char *)v76 + v128)));
              v145[6] = v86;
              v144[7] = @"format";
              id v87 = +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  ResizeFormat(v134));
              unint64_t v88 = (void *)objc_claimAutoreleasedReturnValue(v87);
              v145[7] = v88;
              uint64_t v89 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v145,  v144,  8LL));
              -[NSMutableArray addObject:](v129, "addObject:", v89);

              unint64_t v7 = v120;
              unint64_t v16 = (uint64_t)v122;

              __int128 v19 = v116;
            }

            __int128 v18 = v114;
            __int128 v17 = v115;
          }

      unint64_t v13 = (v25 & -v24) + v22;
      int v26 = a1;
LABEL_39:
      char v27 = apr_array_push(v26);
      __int128 v28 = *(_OWORD *)&v17[v14 + 112];
      unint64_t v30 = *(_OWORD *)&v17[v14 + 64];
      BOOL v29 = *(_OWORD *)&v17[v14 + 80];
      v27[2] = *(_OWORD *)&v17[v14 + 96];
      v27[3] = v28;
      char *v27 = v30;
      v27[1] = v29;
      v14 += 64LL;
    }

    while (v15 != v14);
  }

  apr_pool_destroy(p);
}

          if (v42) {
            goto LABEL_60;
          }
          unint64_t v10 = v75 + 1;
        }

        while ((id)(v75 + 1) != v70);
        id v57 = [v8 countByEnumeratingWithState:&v85 objects:v90 count:16];
        int v70 = v57;
        uint64_t v9 = &selRef_getTextureAccessCounters_region_mipLevel_slice_resetCounters_countersBuffer_countersBufferOffset_;
      }

      while (v57);
    }

    id v58 = [v6 copy];
    unint64_t v8 = *(id *)(a1 + 96);
    *(void *)(a1 + 96) = v58;
    __int16 v59 = 1LL;
LABEL_61:
    uint64_t v5 = v65;
  }

  else if (a3)
  {
    id v60 = GTShaderDebuggerMakeError(1u, @"Internal error: Entry function not found", 0LL, 0LL, 0LL);
    __int16 v59 = 0LL;
    *a3 = (id)objc_claimAutoreleasedReturnValue(v60);
  }

  else
  {
    __int16 v59 = 0LL;
  }

  return v59;
}

void sub_94E08( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, id a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13)
{
}

void ___ZL15KickTimeDataGRCP26GTMTLReplayOperationQueuesP19NSMutableDictionaryjR7GRCInfoP7NSArray_block_invoke_2( uint64_t a1)
{
  uint64_t v2 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(*(void *)(a1 + 56) + 16) firstObject]);
  [v2 startSampling];

  unint64_t v3 = objc_autoreleasePoolPush();
  GRCInfo::ReplayForKickCounters( *(GTMTLReplayController ***)(a1 + 56),  (uint64_t *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 48LL));
  id v4 = GRCInfo::DrainRawFrameData(*(id **)(a1 + 56));
  uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue(v4);
  id v6 = GRCInfo::PostProcessFrameData(*(void *)(a1 + 56), v5);
  unint64_t v7 = (void *)objc_claimAutoreleasedReturnValue(v6);
  if (v7) {
    [*(id *)(*(void *)(*(void *)(a1 + 48) + 8) + 40) setArray:v7];
  }

  objc_autoreleasePoolPop(v3);
  unint64_t v8 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(*(void *)(a1 + 56) + 16) firstObject]);
  [v8 stopSampling];

  GRCInfo::AddConsistencyInfo(*(GTAGXPerfStateControl ***)(a1 + 56));
  GTAGXPerfStateControl::DisableConsistentGPUPerfState(*(GTAGXPerfStateControl **)(*(void *)(a1 + 56) + 8LL));
}

void sub_94F9C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__176(uint64_t a1, uint64_t a2)
{
  return std::__hash_table<std::__hash_value_type<unsigned int,unsigned int>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,unsigned int>>>::__hash_table( a1 + 48,  (uint64_t *)(a2 + 48));
}

uint64_t __Block_byref_object_dispose__177(uint64_t a1)
{
  return std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long>>>::~__hash_table(a1 + 48);
}

__n128 __Block_byref_object_copy__178(__n128 *a1, __n128 *a2)
{
  a1[3].n128_u64[0] = 0LL;
  a1[3].n128_u64[1] = 0LL;
  a1[4].n128_u64[0] = 0LL;
  __n128 result = a2[3];
  a1[3] = result;
  a1[4].n128_u64[0] = a2[4].n128_u64[0];
  a2[3].n128_u64[0] = 0LL;
  a2[3].n128_u64[1] = 0LL;
  a2[4].n128_u64[0] = 0LL;
  return result;
}

void __Block_byref_object_dispose__179(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 48);
  if (v2)
  {
    *(void *)(a1 + 56) = v2;
    operator delete(v2);
  }

void ___ZL20BlitSplitTimeDataGRCP26GTMTLReplayOperationQueuesP19NSMutableDictionaryjR7GRCInfo_block_invoke( uint64_t a1)
{
  uint64_t v2 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(*(void *)(*(void *)(a1 + 40) + 8) + 40) firstObject]);
  if (v2)
  {
    id v23 = v2;
    uint64_t v25 = 0LL;
    std::vector<unsigned long long>::resize( (char **)(*(void *)(*(void *)(a1 + 48) + 8LL) + 48LL),  *(void *)(*(void *)(*(void *)(a1 + 56) + 8LL) + 72LL),  &v25);
    id v3 = v23;
    id v4 = (char *)[v3 bytes];
    uint64_t v5 = 0LL;
    id v6 = 0LL;
    while (1)
    {
      int NextMarker = GRCInfo::FindNextMarker((GRCInfo *)v3, v6, *(void *)(*(void *)(a1 + 64) + 32LL));
      int v9 = NextMarker;
      if (NextMarker == -1) {
        break;
      }
      unint64_t v10 = &v4[8 * NextMarker];
      unint64_t v11 = std::__hash_table<std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>>>::find<unsigned int>( (void *)(*(void *)(*(void *)(a1 + 56) + 8LL) + 48LL),  *((_DWORD *)v10 + 8));
      id v6 = (NSData *)(v9 + 8);
      if (v11)
      {
        BOOL v12 = *((void *)v10 + 3) > 5uLL || (*((void *)v10 + 3) & 1LL) == 0;
        if (v12
          || (unint64_t v13 = *((unsigned int *)v11 + 5),
              uint64_t v14 = *(void *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 48LL),
              v13 >= (*(void *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 56LL) - v14) >> 3))
        {
          size_t v15 = (uint64_t *)(v10 + 8);
        }

        else
        {
          uint64_t v16 = *((void *)v10 + 1);
          size_t v15 = (uint64_t *)(v10 + 8);
          *(void *)(v14 + 8 * v13) += 125 * (v16 - v5) / 3uLL;
        }

        uint64_t v5 = *v15;
      }
    }

    __int128 v17 = (void *)objc_opt_new(&OBJC_CLASS___NSMutableArray, v8);
    uint64_t v18 = *(void *)(*(void *)(a1 + 48) + 8LL);
    __int128 v19 = *(void **)(v18 + 48);
    for (uint64_t i = *(void **)(v18 + 56); v19 != i; ++v19)
    {
      if (*v19)
      {
        id v21 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLongLong:](&OBJC_CLASS___NSNumber, "numberWithUnsignedLongLong:"));
        [v17 addObject:v21];
      }
    }

    uint64_t v22 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObject:forKey:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObject:forKey:",  v17,  @"PerDrawNsecTimes",  v23));
    [*(id *)(a1 + 32) setObject:v22 forKeyedSubscript:@"SplitEncoderData"];

    uint64_t v2 = v24;
  }
}

void sub_951E0( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, id a9)
{
  _Unwind_Resume(a1);
}

void ___ZL20BlitSplitTimeDataGRCP26GTMTLReplayOperationQueuesP19NSMutableDictionaryjR7GRCInfo_block_invoke_2( uint64_t a1)
{
  uint64_t v1 = a1;
  GTMTLReplayController_prePlayForProfiling(**(void **)(a1 + 48));
  GRCInfo::SetupSource(*(void *)(v1 + 48), *(unsigned int *)(v1 + 56), 1, 0LL);
  uint64_t v2 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(*(void *)(v1 + 48) + 16) firstObject]);
  [v2 startSampling];

  uint64_t v41 = objc_autoreleasePoolPush();
  id v3 = *(GTMTLReplayController ***)(v1 + 48);
  uint64_t v45 = *(void *)(*(void *)(v1 + 32) + 8LL);
  GRCInfo::ScopedReplayConfiguration::ScopedReplayConfiguration((GRCInfo::ScopedReplayConfiguration *)v53, *v3);
  id v4 = (*v3)->var1;
  var0 = (uint64_t *)(*v3)->var0;
  uint64_t v42 = var0[15];
  uint64_t v43 = var0[14];
  id v6 = (void *)objc_claimAutoreleasedReturnValue([v4 defaultDevice]);
  id v46 = [v6 newEvent];

  unint64_t v7 = *v3;
  if (var0[13] + var0[12] > (unint64_t)(*v3)->var24.var0)
  {
    uint64_t v40 = v1;
    unsigned __int8 v50 = var0;
    int v51 = v4;
    uint64_t v47 = 0LL;
    uint64_t v48 = 0LL;
    uint64_t v8 = 0LL;
    uint64_t v9 = 0LL;
    uint64_t v44 = v45 + 48;
    do
    {
      context = objc_autoreleasePoolPush();
      uint64_t v10 = *(void *)(var0[15] + 24);
      unint64_t v11 = *v3;
      uint64_t v12 = (*v3)->var24.var0;
      uint64_t v13 = v10 + (v12 << 6);
      size_t v15 = (int *)(v13 + 8);
      int v14 = *(_DWORD *)(v13 + 8);
      if (GetFuncEnumConstructorType(v14) == 25)
      {
        GTMTLReplayController_restoreCommandBuffer((uint64_t)v11, v10 + (v12 << 6));
        uint64_t v48 = *((void *)GTTraceFunc_argumentBytesWithMap( (void *)(v10 + (v12 << 6)),  *(unsigned __int8 *)(v10 + (v12 << 6) + 13),  v50[2])
              + 1);
        int v14 = *v15;
      }

      if (v14 == -16354)
      {
        uint64_t v16 = (void *)objc_claimAutoreleasedReturnValue([v51 commandBufferForKey:v48]);
        ++GRCInfo::ReplayFrameWithBlitSyncEvents(std::unordered_map<unsigned int,unsigned int> &,BOOL)::signalCounter;
        objc_msgSend(v16, "encodeSignalEvent:value:", v46);
        [v16 encodeWaitForEvent:v46 value:GRCInfo::ReplayFrameWithBlitSyncEvents(std::unordered_map<unsigned int,unsigned int> &,BOOL)::signalCounter];
        uint64_t v8 = *((void *)GTTraceFunc_argumentBytesWithMap( (void *)(v10 + (v12 << 6)),  *(unsigned __int8 *)(v10 + (v12 << 6) + 13),  v50[2])
             + 1);
        InclusiveRange = GroupBuilder_findInclusiveRange( *(_DWORD *)(v43 + 12),  *(void **)(v43 + 24),  (*v3)->var24.var0);
        unint64_t v18 = InclusiveRange[1];
        unint64_t v19 = v18 - *InclusiveRange;
        if (v18 > *InclusiveRange)
        {
          id v20 = (int *)(*(void *)(v42 + 24) + (*InclusiveRange << 6) + 8LL);
          do
          {
            int v22 = *v20;
            v20 += 16;
            int v21 = v22;
            if (IsFuncEnumSampledBlitCall(v22) || IsFuncEnumSampledBlitCallAGX(v21)) {
              ++v9;
            }
            --v19;
          }

          while (v19);
        }

        uint64_t v23 = v9;
      }

      else
      {
        uint64_t v23 = v47;
      }

      GTMTLReplayController_updateCommandEncoder((uint64_t)*v3, v13);
      int v24 = *v15;
      if (IsFuncEnumSampledBlitCall(*v15) || IsFuncEnumSampledBlitCallAGX(v24))
      {
        uint64_t v47 = v23 - 1;
        if (v23 && v9 != v23)
        {
          uint64_t v25 = v8;
          int v26 = (void *)objc_claimAutoreleasedReturnValue([v51 blitCommandEncoderForKey:v8]);
          [v26 endEncoding];
          char v27 = (void *)objc_claimAutoreleasedReturnValue([v51 commandBufferForKey:v48]);
          ++GRCInfo::ReplayFrameWithBlitSyncEvents(std::unordered_map<unsigned int,unsigned int> &,BOOL)::signalCounter;
          objc_msgSend(v27, "encodeSignalEvent:value:", v46);
          [v27 encodeWaitForEvent:v46 value:GRCInfo::ReplayFrameWithBlitSyncEvents(std::unordered_map<unsigned int,unsigned int> &,BOOL)::signalCounter];
          __int128 v28 = (void *)objc_claimAutoreleasedReturnValue([v27 blitCommandEncoder]);
          [v51 setBlitCommandEncoder:v28 forKey:v25];
          unsigned int v52 = [v51 globalTraceIdForEncoder:v25 ofType:0];
          uint64_t v29 = *(void *)(v45 + 72);
          *((_DWORD *)std::__hash_table<std::__hash_value_type<unsigned int,unsigned int>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,unsigned int>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>( v44,  v52,  &v52)
          + 5) = v29;

          uint64_t v8 = v25;
        }
      }

      else
      {
        uint64_t v47 = v23;
      }

      GTMTLReplayController_defaultDispatchFunction((uint64_t)*v3, v13);
      int v30 = *v15;
      var0 = v50;
      if (*v15 == -16354)
      {
        unsigned int v52 = [v51 globalTraceIdForEncoder:v8 ofType:0];
        uint64_t v31 = *(void *)(v45 + 72);
        *((_DWORD *)std::__hash_table<std::__hash_value_type<unsigned int,unsigned int>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,unsigned int>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>( v44,  v52,  &v52)
        + 5) = v31;
        int v30 = *v15;
      }

      if (v30 == -16376)
      {
        uint64_t v32 = (void *)objc_claimAutoreleasedReturnValue([v51 commandBufferForKey:v48]);
        ++GRCInfo::ReplayFrameWithBlitSyncEvents(std::unordered_map<unsigned int,unsigned int> &,BOOL)::signalCounter;
        objc_msgSend(v32, "encodeSignalEvent:value:", v46);
        [v32 encodeWaitForEvent:v46 value:GRCInfo::ReplayFrameWithBlitSyncEvents(std::unordered_map<unsigned int,unsigned int> &,BOOL)::signalCounter];
      }

      objc_autoreleasePoolPop(context);
      unint64_t v7 = *v3;
      unint64_t v33 = (*v3)->var24.var0 + 1;
      (*v3)->var24.var0 = v33;
    }

    while (v50[13] + v50[12] > v33);
    id v4 = v51;
    uint64_t v1 = v40;
  }

  unint64_t v34 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v7->var1, "defaultCommandQueue", v40));
  [v34 finish];

  GRCInfo::ScopedReplayConfiguration::~ScopedReplayConfiguration((GRCInfo::ScopedReplayConfiguration *)v53);
  id v35 = GRCInfo::DrainRawFrameData(*(id **)(v1 + 48));
  uint64_t v36 = (void *)objc_claimAutoreleasedReturnValue(v35);
  id v37 = GRCInfo::PostProcessFrameData(*(void *)(v1 + 48), v36);
  int v38 = (void *)objc_claimAutoreleasedReturnValue(v37);
  if (v38) {
    [*(id *)(*(void *)(*(void *)(v1 + 40) + 8) + 40) setArray:v38];
  }

  objc_autoreleasePoolPop(v41);
  uint64_t v39 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(*(void *)(v1 + 48) + 16) firstObject]);
  [v39 stopSampling];

  GRCInfo::AddConsistencyInfo(*(GTAGXPerfStateControl ***)(v1 + 48));
  GTAGXPerfStateControl::DisableConsistentGPUPerfState(*(GTAGXPerfStateControl **)(*(void *)(v1 + 48) + 8LL));
}

void sub_956F8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void GRCInfo::~GRCInfo(id *this)
{
}

void sub_95818(_Unwind_Exception *a1)
{
  GPURawCounterSetupParams::~GPURawCounterSetupParams(v1 + 2);
  _Unwind_Resume(a1);
}

void GRCInfo::SetupSource(uint64_t a1, uint64_t a2, int a3, void *a4)
{
  id v7 = a4;
  uint64_t v8 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 16) firstObject]);
  uint64_t v9 = *(void **)(a1 + 48);
  if (v7) {
    id v10 = (id)objc_claimAutoreleasedReturnValue([v9 arrayByAddingObjectsFromArray:v7]);
  }
  else {
    id v10 = v9;
  }
  unint64_t v11 = v10;
  if ([*(id *)(a1 + 24) count])
  {
    uint64_t v12 = *(void **)(*(void *)a1 + 8LL);
    if (a3)
    {
      if (IsGPUPerformanceStateInduced(v12))
      {
        uint64_t v13 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 16) firstObject]);
        [v13 setOptions:&off_59FF98];

        goto LABEL_14;
      }

      uint64_t v14 = *(unsigned int *)(a1 + 64);
      if (!(_DWORD)v14)
      {
        v26[0] = @"DisableOverlap";
        v26[1] = @"LockGPUPerfState";
        v27[0] = &__kCFBooleanTrue;
        __int128 v17 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInt:](&OBJC_CLASS___NSNumber, "numberWithUnsignedInt:", a2));
        v27[1] = v17;
        unint64_t v18 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v27,  v26,  2LL));
        unint64_t v19 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 16) firstObject]);
        [v19 setOptions:v18];

LABEL_14:
        id v20 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 24) firstObject]);
        if (([v20 requestTriggers:*(void *)(a1 + 40) firstErrorIndex:0] & 1) == 0)
        {
          int v21 = (void *)objc_claimAutoreleasedReturnValue([v20 name]);
          NSLog(@"Fail, error while requesting triggers for %@", v21);
        }

        [v20 setOptions:0];
        if ([v20 requestCounters:v11 firstErrorIndex:0])
        {
          if ([v20 setEnabled:1])
          {
LABEL_21:

            goto LABEL_22;
          }

          int v22 = (void *)objc_claimAutoreleasedReturnValue([v20 name]);
          NSLog(@"Fail, error while enabling source[%@]", v22);
        }

        else
        {
          id v23 = [*(id *)(a1 + 48) count];
          int v22 = (void *)objc_claimAutoreleasedReturnValue([v20 name]);
          NSLog(@"Fail, error while requesting %lu counter for source[%@]", v23, v22);
        }

        goto LABEL_21;
      }
    }

    else
    {
      if (IsGPUPerformanceStateInduced(v12)) {
        goto LABEL_14;
      }
      uint64_t v14 = *(unsigned int *)(a1 + 64);
      if (!(_DWORD)v14)
      {
        int v24 = @"LockGPUPerfState";
        size_t v15 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInt:](&OBJC_CLASS___NSNumber, "numberWithUnsignedInt:", a2));
        uint64_t v25 = v15;
        uint64_t v16 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v25,  &v24,  1LL));
        [v8 setOptions:v16];

        goto LABEL_14;
      }
    }

    GTAGXPerfStateControl::EnableConsistentGPUPerfState(*(void *)(a1 + 8), v14);
    goto LABEL_14;
  }

void sub_95B0C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id GRCInfo::DrainRawFrameData(id *this)
{
  if (![this[3] count]) {
    return 0LL;
  }
  uint64_t v2 = (void *)objc_claimAutoreleasedReturnValue([this[3] firstObject]);
  id v3 = (void *)objc_claimAutoreleasedReturnValue( +[NSMutableArray arrayWithCapacity:]( NSMutableArray,  "arrayWithCapacity:",  [v2 ringBufferNum]));

  id v4 = (void *)objc_claimAutoreleasedReturnValue([this[3] lastObject]);
  if ([v4 isEnabled])
  {
    for (uint64_t i = 0LL; ; uint64_t i = (i + 1))
    {
      if (i >= [v4 ringBufferNum])
      {
        id v13 = v3;
        goto LABEL_16;
      }

      if (([v4 ringBufferInfoAtIndex:i base:&v18 size:&v17 dataOffset:&v16 dataSize:&v15] & 1) == 0) {
        break;
      }
      id v6 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableData dataWithCapacity:](&OBJC_CLASS___NSMutableData, "dataWithCapacity:", v15));
      id v7 = v6;
      unsigned int v8 = v15;
      if (v15 + v16 <= v17)
      {
        [v6 appendBytes:v18 + v16 length:v15];
      }

      else
      {
        unsigned int v9 = v17 - v16;
        [v6 appendBytes:v18 + v16 length:v17 - v16];
        [v7 appendBytes:v18 length:v8 - v9];
      }

      unsigned int v10 = [v4 drainRingBufferAtIndex:i dataSize:v15];
      if (v10 != v15)
      {
        unint64_t v11 = (void *)objc_claimAutoreleasedReturnValue([v4 name]);
        NSLog(@"Fail, unexpected drain count for source %@!", v11);
      }

      [v3 addObject:v7];
    }

    uint64_t v14 = (void *)objc_claimAutoreleasedReturnValue([v4 name]);
    NSLog(@"Fail, unable to retrieve ring buffer info from source %@!", v14);
  }

  id v13 = 0LL;
LABEL_16:

  return v13;
}

void sub_95D90(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id GRCInfo::PostProcessFrameData(uint64_t a1, void *a2)
{
  id v19 = a2;
  if ([v19 count])
  {
    id v3 = (void *)objc_claimAutoreleasedReturnValue( +[NSMutableArray arrayWithCapacity:]( NSMutableArray,  "arrayWithCapacity:",  [v19 count]));
    id v4 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 24) lastObject]);
    __int128 v25 = 0u;
    __int128 v26 = 0u;
    __int128 v23 = 0u;
    __int128 v24 = 0u;
    obuint64_t j = v19;
    id v5 = [obj countByEnumeratingWithState:&v23 objects:v27 count:16];
    if (v5)
    {
      uint64_t v6 = *(void *)v24;
      while (2)
      {
        id v7 = 0LL;
        do
        {
          if (*(void *)v24 != v6) {
            objc_enumerationMutation(obj);
          }
          unsigned int v8 = *(void **)(*((void *)&v23 + 1) + 8LL * (void)v7);
          [v4 resetRawDataPostProcessor];
          uint64_t v21 = 0LL;
          id v9 = [v8 length];
          else {
            uint64_t v10 = 4LL * (void)v9;
          }
          unint64_t v11 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableData dataWithLength:](&OBJC_CLASS___NSMutableData, "dataWithLength:", v10));
          if ([v8 length])
          {
            id v12 = v8;
            id v13 = [v12 bytes];
            id v14 = [v12 length];
            id v15 = v11;
            LOBYTE(v1_Block_object_dispose(va, 8) = 1;
            if ((objc_msgSend( v4,  "postProcessRawDataWithSource:sourceSize:sourceRead:output:outputSize:outputWritten:isLast:",  v13,  v14,  v22,  objc_msgSend(v15, "mutableBytes"),  objc_msgSend(v15, "length"),  &v21,  v18) & 1) == 0)
            {

              id v16 = 0LL;
              goto LABEL_17;
            }
          }

          [v11 setLength:v21];
          [v3 addObject:v11];

          id v7 = (char *)v7 + 1;
        }

        while (v5 != v7);
        id v5 = [obj countByEnumeratingWithState:&v23 objects:v27 count:16];
        if (v5) {
          continue;
        }
        break;
      }
    }

    id v16 = v3;
LABEL_17:
  }

  else
  {
    id v16 = 0LL;
  }

  return v16;
}

void sub_96048( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, void *a12)
{
  _Unwind_Resume(a1);
}

void GRCInfo::AddConsistencyInfo(GTAGXPerfStateControl **this)
{
  if (*((_DWORD *)this + 16))
  {
    uint64_t v2 = GTAGXPerfStateControl::ConsistentGPUPerfStateLevel(this[1], 0LL);
    id v3 = (void *)objc_claimAutoreleasedReturnValue(v2);
    if (v3)
    {
      uint64_t v10 = v3;
      if (this[7])
      {
        if (*((_BYTE *)this + 68))
        {
          id v4 = (void *)objc_claimAutoreleasedReturnValue([v3 objectForKeyedSubscript:@"enabled"]);
          *((_BYTE *)this + 6_Block_object_dispose(va, 8) = [v4 BOOLValue];

          id v3 = v10;
        }

        else
        {
          *((_BYTE *)this + 6_Block_object_dispose(va, 8) = 0;
        }

        if (!*((_BYTE *)this + 69))
        {
          *((_BYTE *)this + 69) = 0;
          goto LABEL_13;
        }

        unsigned int v8 = (void *)objc_claimAutoreleasedReturnValue([v3 objectForKeyedSubscript:@"consistent"]);
        unsigned __int8 v9 = [v8 BOOLValue];
      }

      else
      {
        uint64_t v5 = objc_claimAutoreleasedReturnValue([v3 objectForKeyedSubscript:@"level"]);
        uint64_t v6 = this[7];
        this[7] = (GTAGXPerfStateControl *)v5;

        id v7 = (void *)objc_claimAutoreleasedReturnValue([v10 objectForKeyedSubscript:@"enabled"]);
        *((_BYTE *)this + 6_Block_object_dispose(va, 8) = [v7 BOOLValue];

        unsigned int v8 = (void *)objc_claimAutoreleasedReturnValue([v10 objectForKeyedSubscript:@"consistent"]);
        unsigned __int8 v9 = [v8 BOOLValue];
      }

      *((_BYTE *)this + 69) = v9;

      id v3 = v10;
    }

void sub_961C8( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

GRCInfo::ScopedReplayConfiguration *GRCInfo::ScopedReplayConfiguration::ScopedReplayConfiguration( GRCInfo::ScopedReplayConfiguration *this, GTMTLReplayController *a2)
{
  *((void *)this + 1) = a2;
  *((_BYTE *)this + 16) = 1;
  id v3 = (void *)objc_claimAutoreleasedReturnValue([a2->var1 defaultCommandQueue]);
  [v3 setGPUPriority:0];

  *(void *)this = [(id)g_commandBufferDescriptor errorOptions];
  [(id)g_commandBufferDescriptor setErrorOptions:0];
  return this;
}

void sub_96258(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void *std::__hash_table<std::__hash_value_type<unsigned int,unsigned int>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,unsigned int>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>( uint64_t a1, unsigned int a2, _DWORD *a3)
{
  unint64_t v6 = a2;
  unint64_t v7 = *(void *)(a1 + 8);
  if (v7)
  {
    uint8x8_t v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      unint64_t v3 = a2;
      if (v7 <= a2) {
        unint64_t v3 = a2 % v7;
      }
    }

    else
    {
      unint64_t v3 = ((_DWORD)v7 - 1) & a2;
    }

    unsigned __int8 v9 = *(void ***)(*(void *)a1 + 8 * v3);
    if (v9)
    {
      uint64_t v10 = *v9;
      if (*v9)
      {
        do
        {
          unint64_t v11 = v10[1];
          if (v11 == a2)
          {
            if (*((_DWORD *)v10 + 4) == a2) {
              return v10;
            }
          }

          else
          {
            if (v8.u32[0] > 1uLL)
            {
              if (v11 >= v7) {
                v11 %= v7;
              }
            }

            else
            {
              v11 &= v7 - 1;
            }

            if (v11 != v3) {
              break;
            }
          }

          uint64_t v10 = (void *)*v10;
        }

        while (v10);
      }
    }
  }

  uint64_t v10 = operator new(0x18uLL);
  void *v10 = 0LL;
  v10[1] = v6;
  *((_DWORD *)v10 + 4) = *a3;
  *((_DWORD *)v10 + 5) = 0;
  float v12 = (float)(unint64_t)(*(void *)(a1 + 24) + 1LL);
  float v13 = *(float *)(a1 + 32);
  if (!v7 || (float)(v13 * (float)v7) < v12)
  {
    BOOL v14 = 1LL;
    if (v7 >= 3) {
      BOOL v14 = (v7 & (v7 - 1)) != 0;
    }
    unint64_t v15 = v14 | (2 * v7);
    unint64_t v16 = vcvtps_u32_f32(v12 / v13);
    if (v15 <= v16) {
      size_t v17 = v16;
    }
    else {
      size_t v17 = v15;
    }
    std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__rehash<true>( a1,  v17);
    unint64_t v7 = *(void *)(a1 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v7 <= v6) {
        unint64_t v3 = v6 % v7;
      }
      else {
        unint64_t v3 = v6;
      }
    }

    else
    {
      unint64_t v3 = ((_DWORD)v7 - 1) & v6;
    }
  }

  uint64_t v18 = *(void *)a1;
  id v19 = *(void **)(*(void *)a1 + 8 * v3);
  if (v19)
  {
    void *v10 = *v19;
LABEL_38:
    void *v19 = v10;
    goto LABEL_39;
  }

  void *v10 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = v10;
  *(void *)(v18 + 8 * v3) = a1 + 16;
  if (*v10)
  {
    unint64_t v20 = *(void *)(*v10 + 8LL);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v20 >= v7) {
        v20 %= v7;
      }
    }

    else
    {
      v20 &= v7 - 1;
    }

    id v19 = (void *)(*(void *)a1 + 8 * v20);
    goto LABEL_38;
  }

void sub_96464(_Unwind_Exception *a1)
{
}

void GRCInfo::ScopedReplayConfiguration::~ScopedReplayConfiguration( GRCInfo::ScopedReplayConfiguration *this)
{
  if (*((_BYTE *)this + 16))
  {
    uint64_t v2 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(*((void *)this + 1) + 8) defaultCommandQueue]);
    [v2 setGPUPriority:1];
  }

  [(id)g_commandBufferDescriptor setErrorOptions:*(void *)this];
}

void sub_964D0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void std::vector<unsigned long long>::resize(char **a1, unint64_t a2, void *a3)
{
  unint64_t v6 = *a1;
  uint64_t v5 = a1[1];
  unint64_t v7 = (v5 - *a1) >> 3;
  if (a2 <= v7)
  {
    if (a2 < v7) {
      a1[1] = &v6[8 * a2];
    }
  }

  else
  {
    unsigned __int8 v9 = a1[2];
    if (a2 - v7 <= (v9 - v5) >> 3)
    {
      __int128 v23 = &v5[8 * (a2 - v7)];
      uint64_t v24 = 8 * a2 - 8 * v7;
      do
      {
        *(void *)uint64_t v5 = *a3;
        v5 += 8;
        v24 -= 8LL;
      }

      while (v24);
      a1[1] = v23;
    }

    else
    {
      if (a2 >> 61) {
        abort();
      }
      unint64_t v10 = v9 - v6;
      unint64_t v11 = (v9 - v6) >> 2;
      if (v11 <= a2) {
        unint64_t v11 = a2;
      }
      if (v10 >= 0x7FFFFFFFFFFFFFF8LL) {
        unint64_t v12 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v12 = v11;
      }
      float v13 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<std::pair<unsigned int,unsigned int>>>(v12);
      unint64_t v15 = &v13[8 * v7];
      unint64_t v16 = &v13[8 * a2];
      uint64_t v17 = 8 * a2 - 8 * v7;
      uint64_t v18 = v15;
      do
      {
        *(void *)uint64_t v18 = *a3;
        v18 += 8;
        v17 -= 8LL;
      }

      while (v17);
      id v19 = &v13[8 * v14];
      unint64_t v20 = *a1;
      for (uint64_t i = a1[1]; i != v20; i -= 8)
      {
        uint64_t v22 = *((void *)i - 1);
        *((void *)v15 - 1) = v22;
        v15 -= 8;
      }

      *a1 = v15;
      a1[1] = v16;
      a1[2] = v19;
      if (v20) {
        operator delete(v20);
      }
    }
  }

uint64_t GRCInfo::FindNextMarker(GRCInfo *this, NSData *a2, uint64_t a3)
{
  unsigned int v4 = a2;
  uint64_t v5 = this;
  unsigned int v6 = -[GRCInfo length](v5, "length");
  unint64_t v7 = v5;
  uint8x8_t v8 = -[GRCInfo bytes](v7, "bytes");
  unsigned int v9 = (v6 - 64) >> 3;
  BOOL v10 = v9 >= v4;
  unsigned int v11 = v9 - v4;
  if (v10)
  {
    uint64_t v12 = v4;
    unsigned int v13 = v11 + 1;
    while (v8[v12] != a3)
    {
      ++v12;
      if (!--v13) {
        goto LABEL_6;
      }
    }
  }

  else
  {
LABEL_6:
    uint64_t v12 = 0xFFFFFFFFLL;
  }

  return v12;
}

void sub_96684(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t std::__hash_table<std::__hash_value_type<unsigned int,unsigned int>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,unsigned int>>>::__hash_table( uint64_t result, uint64_t *a2)
{
  uint64_t v2 = *a2;
  *a2 = 0LL;
  *(void *)__n128 result = v2;
  *(void *)(result + _Block_object_dispose(va, 8) = a2[1];
  a2[1] = 0LL;
  uint64_t v5 = a2[2];
  unint64_t v3 = a2 + 2;
  uint64_t v4 = v5;
  *(void *)(result + 16) = v5;
  uint64_t v6 = v3[1];
  *(void *)(result + 24) = v6;
  *(_DWORD *)(result + 32) = *((_DWORD *)v3 + 4);
  if (v6)
  {
    unint64_t v7 = *(void *)(v4 + 8);
    unint64_t v8 = *(void *)(result + 8);
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v7 >= v8) {
        v7 %= v8;
      }
    }

    else
    {
      v7 &= v8 - 1;
    }

    *(void *)(v2 + 8 * v7) = result + 16;
    void *v3 = 0LL;
    v3[1] = 0LL;
  }

  return result;
}

void GRCInfo::ReplayForKickCounters(GTMTLReplayController **a1, uint64_t *a2)
{
  id v47 = (*a1)->var1;
  uint64_t v4 = *a1;
  var0 = (uint64_t *)(*a1)->var0;
  char v50 = 0;
  if (var0[13] + var0[12] > (unint64_t)v4->var24.var0)
  {
    id v46 = a2 + 2;
    uint64_t v48 = var0[15];
    LODWORD(v49) = -1;
    do
    {
      uint64_t v6 = objc_autoreleasePoolPush();
      uint64_t v7 = *(void *)(v48 + 24);
      uint64_t v8 = (*a1)->var24.var0;
      GTMTLReplayController_updateCommandEncoder((uint64_t)*a1, v7 + (v8 << 6));
      DispatchFunction((id *)&(*a1)->var0, v7 + (v8 << 6), &v50);
      uint64_t v9 = v7 + (v8 << 6);
      unint64_t v10 = *(unsigned int *)(v9 + 8);
      int FuncEnumConstructorType = GetFuncEnumConstructorType(*(_DWORD *)(v9 + 8));
      else {
        uint64_t v12 = v49;
      }
      uint64_t v49 = v12;
      if (!GTMTLReplayHost_IsFuncEnumSampledEncoder(v10, 1, 0LL)
        || v50 != (FuncEnumConstructorType == 65))
      {
        goto LABEL_80;
      }

      unsigned int v13 = objc_msgSend( v47,  "globalTraceIdForEncoder:ofType:",  *((void *)GTTraceFunc_argumentBytesWithMap( (void *)(v7 + (v8 << 6)),  *(unsigned __int8 *)(v7 + (v8 << 6) + 13),  var0[2])
                            + 1),
                            FuncEnumConstructorType == 65);
      unsigned int v14 = v13;
      uint64_t v15 = a2[3];
      unint64_t v16 = v13;
      unint64_t v17 = a2[1];
      if (v17)
      {
        uint8x8_t v18 = (uint8x8_t)vcnt_s8((int8x8_t)v17);
        v18.i16[0] = vaddlv_u8(v18);
        if (v18.u32[0] > 1uLL)
        {
          unint64_t v10 = v13;
          if (v17 <= v13) {
            unint64_t v10 = v13 % v17;
          }
        }

        else
        {
          unint64_t v10 = ((_DWORD)v17 - 1) & v13;
        }

        id v19 = *(uint64_t ***)(*a2 + 8 * v10);
        if (v19)
        {
          for (uint64_t i = *v19; i; uint64_t i = (uint64_t *)*i)
          {
            unint64_t v21 = i[1];
            if (v21 == v13)
            {
              if (*((_DWORD *)i + 4) == v13) {
                goto LABEL_80;
              }
            }

            else
            {
              if (v18.u32[0] > 1uLL)
              {
                if (v21 >= v17) {
                  v21 %= v17;
                }
              }

              else
              {
                v21 &= v17 - 1;
              }

              if (v21 != v10) {
                break;
              }
            }
          }
        }
      }

      uint64_t v22 = operator new(0x20uLL);
      *uint64_t v22 = 0LL;
      v22[1] = v16;
      *((_DWORD *)v22 + 4) = v14;
      *(void *)((char *)v22 + 20) = v49 | (v15 << 32);
      float v23 = (float)(unint64_t)(v15 + 1);
      float v24 = *((float *)a2 + 8);
      if (v17 && (float)(v24 * (float)v17) >= v23)
      {
        unint64_t v16 = v10;
        goto LABEL_70;
      }

      BOOL v25 = (v17 & (v17 - 1)) != 0;
      if (v17 < 3) {
        BOOL v25 = 1LL;
      }
      unint64_t v26 = v25 | (2 * v17);
      unint64_t v27 = vcvtps_u32_f32(v23 / v24);
      if (v26 <= v27) {
        int8x8_t prime = (int8x8_t)v27;
      }
      else {
        int8x8_t prime = (int8x8_t)v26;
      }
      if (*(void *)&prime == 1LL)
      {
        int8x8_t prime = (int8x8_t)2LL;
      }

      else if ((*(void *)&prime & (*(void *)&prime - 1LL)) != 0)
      {
        int8x8_t prime = (int8x8_t)std::__next_prime(*(void *)&prime);
        unint64_t v17 = a2[1];
      }

      if (*(void *)&prime <= v17)
      {
        if (*(void *)&prime >= v17) {
          goto LABEL_66;
        }
        unint64_t v35 = vcvtps_u32_f32((float)(unint64_t)a2[3] / *((float *)a2 + 8));
        if (v17 < 3 || (uint8x8_t v36 = (uint8x8_t)vcnt_s8((int8x8_t)v17), v36.i16[0] = vaddlv_u8(v36), v36.u32[0] > 1uLL))
        {
          unint64_t v35 = std::__next_prime(v35);
        }

        else
        {
          uint64_t v37 = 1LL << -(char)__clz(v35 - 1);
          if (v35 >= 2) {
            unint64_t v35 = v37;
          }
        }

        if (*(void *)&prime <= v35) {
          int8x8_t prime = (int8x8_t)v35;
        }
        if (*(void *)&prime >= v17)
        {
          unint64_t v17 = a2[1];
          goto LABEL_66;
        }

        if (!*(void *)&prime)
        {
          uint64_t v44 = (void *)*a2;
          *a2 = 0LL;
          if (v44) {
            operator delete(v44);
          }
          unint64_t v17 = 0LL;
          a2[1] = 0LL;
          goto LABEL_66;
        }
      }

      if (*(void *)&prime >> 61) {
        std::__throw_bad_array_new_length[abi:nn180100]();
      }
      uint64_t v29 = operator new(8LL * *(void *)&prime);
      int v30 = (void *)*a2;
      *a2 = (uint64_t)v29;
      if (v30) {
        operator delete(v30);
      }
      uint64_t v31 = 0LL;
      a2[1] = (uint64_t)prime;
      do
        *(void *)(*a2 + 8 * v31++) = 0LL;
      while (*(void *)&prime != v31);
      uint64_t v32 = (void *)*v46;
      if (*v46)
      {
        unint64_t v33 = v32[1];
        uint8x8_t v34 = (uint8x8_t)vcnt_s8(prime);
        v34.i16[0] = vaddlv_u8(v34);
        if (v34.u32[0] > 1uLL)
        {
          if (v33 >= *(void *)&prime) {
            v33 %= *(void *)&prime;
          }
        }

        else
        {
          v33 &= *(void *)&prime - 1LL;
        }

        *(void *)(*a2 + 8 * v33) = v46;
        int v38 = (void *)*v32;
        if (*v32)
        {
          do
          {
            unint64_t v39 = v38[1];
            if (v34.u32[0] > 1uLL)
            {
              if (v39 >= *(void *)&prime) {
                v39 %= *(void *)&prime;
              }
            }

            else
            {
              v39 &= *(void *)&prime - 1LL;
            }

            if (v39 != v33)
            {
              if (!*(void *)(*a2 + 8 * v39))
              {
                *(void *)(*a2 + 8 * v39) = v32;
                goto LABEL_62;
              }

              *uint64_t v32 = *v38;
              *int v38 = **(void **)(*a2 + 8 * v39);
              **(void **)(*a2 + 8 * v39) = v38;
              int v38 = v32;
            }

            unint64_t v39 = v33;
LABEL_62:
            uint64_t v32 = v38;
            int v38 = (void *)*v38;
            unint64_t v33 = v39;
          }

          while (v38);
        }
      }

      unint64_t v17 = (unint64_t)prime;
LABEL_66:
      if ((v17 & (v17 - 1)) != 0)
      {
        if (v17 <= v16) {
          v16 %= v17;
        }
      }

      else
      {
        unint64_t v16 = ((_DWORD)v17 - 1) & v16;
      }

LABEL_70:
      uint64_t v40 = *a2;
      uint64_t v41 = *(void **)(*a2 + 8 * v16);
      if (v41)
      {
        *uint64_t v22 = *v41;
LABEL_78:
        *uint64_t v41 = v22;
        goto LABEL_79;
      }

      *uint64_t v22 = *v46;
      void *v46 = v22;
      *(void *)(v40 + 8 * v16) = v46;
      if (*v22)
      {
        unint64_t v42 = *(void *)(*v22 + 8LL);
        if ((v17 & (v17 - 1)) != 0)
        {
          if (v42 >= v17) {
            v42 %= v17;
          }
        }

        else
        {
          v42 &= v17 - 1;
        }

        uint64_t v41 = (void *)(*a2 + 8 * v42);
        goto LABEL_78;
      }

    char v50 = *(_DWORD *)(v24 + 12);
    if (v50 >= 1)
    {
      for (uint64_t i = 0LL; i < v50; ++i)
      {
        unsigned int v52 = *(void *)(*(void *)(v24 + 24) + 8 * i);
        uint64_t v53 = *(void *)(v52 + 48);
        if (*(_BYTE *)(v53 + 19) == 2)
        {
          double v54 = MakeMTLHeapDescriptor(v53);
          uint64_t v55 = (void *)objc_claimAutoreleasedReturnValue(v54);
          id v56 = [v55 size];
          id v57 = (id)*(unsigned int *)(v52 + 76);
          if (v56 >= v57) {
            id v57 = [v55 size];
          }
          [v55 setSize:v57];
          id v58 = [v23 newHeapWithDescriptor:v55];
          if (v58) {
            [v12 setHeap:v58 forKey:*(void *)(v52 + 8)];
          }
          else {
            GTMTLReplay_handleError( 101,  (uint64_t)"Sparse heap creation failed",  "/Library/Caches/com.apple.xbs/Sources/GPUToolsDevice/GPUTools/GTMTLCapture/replayer/GTMTLReplay_argumentBuffers.m",  (uint64_t)"GTMTLReplayController_allocateBuffersAndHeaps",  309LL,  1LL);
          }

          char v50 = *(_DWORD *)(v24 + 12);
        }
      }
    }

    uint64_t v5 = v141;
    a1 = v143;
  }

  uint64_t v147 = v5;

  __int16 v59 = *(uint64_t **)(a1 + 40);
  id v60 = initializeResourcePatchingTypes(v147, (_BYTE *)&dword_0 + 1);
  g_forcePatchingTypeReplaceMasuint64_t k = 0LL;
  char v62 = v60 & ~qword_5B9DD0;
  if (v62 && (*(_BYTE *)(a1 + 272) & 2) == 0) {
    char v62 = 0LL;
  }
  g_enableIndexedResourceType = v62;
  apr_pool_create_ex(&v151, 0LL, 0LL, v61);
  id v63 = v151;
  id v64 = apr_array_make(v151, 128, 8);
  id v65 = v64;
  uint64_t v66 = g_enableIndexedResourceType;
  if ((g_enableIndexedResourceType & 1) == 0)
  {
    if ((g_enableIndexedResourceType & 2) == 0) {
      goto LABEL_86;
    }
    goto LABEL_101;
  }

  v64->int nelts = 0;
  id v67 = v59[2];
  uint64_t v68 = *(_DWORD *)(v67 + 12);
  if (v68 >= 1)
  {
    int v69 = 0LL;
    while (1)
    {
      int v70 = *(void *)(*(void *)(v67 + 24) + 8 * v69);
      int v71 = *(void *)(v70 + 104);
      if (!v71) {
        break;
      }
      __int16 v72 = *(void *)(v71 + 8);
      if (v72) {
        goto LABEL_95;
      }
LABEL_96:
      if (++v69 >= v68) {
        goto LABEL_100;
      }
    }

    __int16 v72 = *(void *)(v70 + 176);
    if (!v72) {
      goto LABEL_96;
    }
LABEL_95:
    *(void *)apr_array_push(v65) = v72;
    uint64_t v68 = *(_DWORD *)(v67 + 12);
    goto LABEL_96;
  }

void sub_96C64(_Unwind_Exception *a1, uint64_t a2, void *a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  GRCInfo::ScopedReplayConfiguration::~ScopedReplayConfiguration((GRCInfo::ScopedReplayConfiguration *)va);
  _Unwind_Resume(a1);
}

void sub_96E4C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
}

void ___ZN7GRCInfo23ReplayForTimingCountersERNSt3__16vectorINS0_5tupleIJyyyEEENS0_9allocatorIS3_EEEE_block_invoke( uint64_t a1, void *a2)
{
  id v24 = a2;
  unint64_t v3 = (void *)objc_claimAutoreleasedReturnValue([v24 label]);
  unsigned __int8 v4 = [v3 hasPrefix:@"com.apple.gputools.replay"];

  uint64_t v5 = v24;
  if ((v4 & 1) == 0)
  {
    [v24 GPUStartTime];
    double v7 = v6;
    [v24 GPUEndTime];
    unint64_t v8 = (unint64_t)(v7 * 1000000000.0);
    unint64_t v10 = (unint64_t)(v9 * 1000000000.0);
    uint64_t v11 = *(void *)(a1 + 32);
    uint64_t v12 = *(unint64_t **)(v11 + 8);
    unint64_t v13 = *(void *)(v11 + 16);
    if ((unint64_t)v12 >= v13)
    {
      unint64_t v15 = 0xAAAAAAAAAAAAAAALL;
      unint64_t v16 = *(unint64_t **)v11;
      unint64_t v17 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v12 - *(void *)v11) >> 3);
      unint64_t v18 = v17 + 1;
      if (v17 + 1 > 0xAAAAAAAAAAAAAAALL) {
        abort();
      }
      unint64_t v19 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v13 - (void)v16) >> 3);
      if (2 * v19 > v18) {
        unint64_t v18 = 2 * v19;
      }
      if (v19 < 0x555555555555555LL) {
        unint64_t v15 = v18;
      }
      if (v15)
      {
        unint64_t v15 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<std::vector<NSObject  {objcproto21OS_dispatch_semaphore}* {__strong}>>>(v15);
        unint64_t v16 = *(unint64_t **)v11;
        uint64_t v12 = *(unint64_t **)(v11 + 8);
      }

      else
      {
        uint64_t v20 = 0LL;
      }

      unint64_t v21 = (unint64_t *)(v15 + 24 * v17);
      unint64_t v22 = v15 + 24 * v20;
      *unint64_t v21 = v8;
      v21[1] = v10;
      v21[2] = (unint64_t)v24;
      unsigned int v14 = v21 + 3;
      if (v12 != v16)
      {
        do
        {
          __int128 v23 = *(_OWORD *)(v12 - 3);
          *(v21 - 1) = *(v12 - 1);
          *(_OWORD *)(v21 - 3) = v23;
          v21 -= 3;
          v12 -= 3;
        }

        while (v12 != v16);
        unint64_t v16 = *(unint64_t **)v11;
      }

      *(void *)uint64_t v11 = v21;
      *(void *)(v11 + _Block_object_dispose(va, 8) = v14;
      *(void *)(v11 + 16) = v22;
      if (v16) {
        operator delete(v16);
      }
      uint64_t v5 = v24;
    }

    else
    {
      unint64_t *v12 = v8;
      v12[1] = v10;
      unsigned int v14 = v12 + 3;
      uint64_t v5 = v24;
      v12[2] = (unint64_t)v24;
    }

    *(void *)(v11 + _Block_object_dispose(va, 8) = v14;
  }
}

void sub_9702C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
}

unint64_t std::__introsort<std::_ClassicAlgPolicy,std::__less<void,void> &,std::tuple<unsigned long long,unsigned long long,unsigned long long> *,false>( unint64_t result, unint64_t *a2, uint64_t a3, char a4)
{
  double v7 = (unint64_t *)result;
LABEL_2:
  unint64_t v8 = a2 - 3;
  uint64_t i = v7;
  while (2)
  {
    double v7 = i;
    uint64_t v10 = (char *)a2 - (char *)i;
    uint64_t v11 = 0xAAAAAAAAAAAAAAABLL * (a2 - i);
    switch(v11)
    {
      case 0LL:
      case 1LL:
        return result;
      case 2LL:
        unint64_t v63 = *v8;
        unint64_t v64 = *i;
        if (*v8 < *i || v64 >= v63 && ((v65 = *(a2 - 2), unint64_t v66 = i[1], v65 < v66) || v66 >= v65 && *(a2 - 1) < i[2]))
        {
          unint64_t *i = v63;
          *(a2 - 3) = v64;
          unint64_t v67 = i[1];
          i[1] = *(a2 - 2);
          *(a2 - 2) = v67;
          unint64_t v68 = i[2];
          i[2] = *(a2 - 1);
          *(a2 - 1) = v68;
        }

        return result;
      case 3LL:
        return (unint64_t)std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::tuple<unsigned long long,unsigned long long,unsigned long long> *>( i,  i + 3,  a2 - 3);
      case 4LL:
        return (unint64_t)std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::tuple<unsigned long long,unsigned long long,unsigned long long> *>( i,  i + 3,  i + 6,  a2 - 3);
      case 5LL:
        return (unint64_t)std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::tuple<unsigned long long,unsigned long long,unsigned long long> *>( i,  i + 3,  i + 6,  i + 9,  a2 - 3);
      default:
        if (v10 > 575)
        {
          if (!a3)
          {
            if (i == a2) {
              return result;
            }
            int64_t v85 = (unint64_t)(v11 - 2) >> 1;
            int64_t v86 = v85;
            while (1)
            {
              int64_t v87 = v86;
              if (v85 >= v86)
              {
                uint64_t v88 = (2 * v86) | 1;
                uint64_t v89 = &i[3 * v88];
                if (2 * v87 + 2 < v11)
                {
                  unint64_t v90 = v89[3];
                  if (*v89 < v90
                    || v90 >= *v89 && ((unint64_t v103 = v89[1], v104 = v89[4], v103 < v104) || v104 >= v103 && v89[2] < v89[5]))
                  {
                    v89 += 3;
                    uint64_t v88 = 2 * v87 + 2;
                  }
                }

                uint64_t v91 = &i[3 * v87];
                unint64_t v92 = *v89;
                unint64_t v93 = *v91;
                if (*v89 >= *v91)
                {
                  if (v93 < v92)
                  {
                    unint64_t v94 = v91[1];
LABEL_160:
                    unint64_t v95 = v91[2];
                    while (1)
                    {
                      *uint64_t v91 = v92;
                      v91[1] = v89[1];
                      v91[2] = v89[2];
                      if (v85 < v88) {
                        goto LABEL_175;
                      }
                      uint64_t v91 = v89;
                      uint64_t v96 = 2 * v88;
                      uint64_t v88 = (2 * v88) | 1;
                      uint64_t v89 = &i[3 * v88];
                      uint64_t v97 = v96 + 2;
                      if (v97 < v11)
                      {
                        unint64_t v98 = v89[3];
                        if (*v89 < v98
                          || v98 >= *v89
                          && ((unint64_t v99 = v89[1], v100 = v89[4], v99 < v100) || v100 >= v99 && v89[2] < v89[5]))
                        {
                          v89 += 3;
                          uint64_t v88 = v97;
                        }
                      }

                      unint64_t v92 = *v89;
                      if (*v89 < v93) {
                        break;
                      }
                      if (v93 >= v92)
                      {
                        unint64_t v101 = v89[1];
                        if (v101 < v94 || v94 >= v101 && v89[2] < v95) {
                          break;
                        }
                      }
                    }

                    uint64_t v89 = v91;
LABEL_175:
                    unint64_t *v89 = v93;
                    v89[1] = v94;
                    void v89[2] = v95;
                    goto LABEL_177;
                  }

                  unint64_t v102 = v89[1];
                  unint64_t v94 = v91[1];
                  if (v102 >= v94 && (v94 < v102 || v89[2] >= v91[2])) {
                    goto LABEL_160;
                  }
                }
              }

LABEL_177:
              int64_t v86 = v87 - 1;
              if (!v87)
              {
                int64_t v117 = v10 / 0x18uLL;
                while (1)
                {
                  uint64_t v118 = 0LL;
                  unint64_t v119 = *i;
                  unint64_t v120 = i[1];
                  unint64_t v121 = i[2];
                  uint64_t v122 = v117 - 2;
                  if (v117 < 2) {
                    uint64_t v122 = v117 - 1;
                  }
                  uint64_t v123 = v122 >> 1;
                  double v124 = i;
                  do
                  {
                    __n128 result = (unint64_t)v124;
                    v124 += 3 * v118 + 3;
                    uint64_t v125 = 2 * v118;
                    uint64_t v118 = (2 * v118) | 1;
                    int64_t v126 = v125 + 2;
                    if (v126 < v117)
                    {
                      unint64_t v127 = v124[3];
                      if (*v124 < v127
                        || v127 >= *v124
                        && ((unint64_t v128 = v124[1], v129 = v124[4], v128 < v129) || v129 >= v128 && v124[2] < v124[5]))
                      {
                        v124 += 3;
                        uint64_t v118 = v126;
                      }
                    }

                    *(void *)__n128 result = *v124;
                    *(void *)(result + _Block_object_dispose(va, 8) = v124[1];
                    *(void *)(result + 16) = v124[2];
                  }

                  while (v118 <= v123);
                  if (v124 == a2 - 3)
                  {
                    *double v124 = v119;
                    v124[1] = v120;
                    void v124[2] = v121;
                    goto LABEL_233;
                  }

                  *double v124 = *(a2 - 3);
                  v124[1] = *(a2 - 2);
                  void v124[2] = *(a2 - 1);
                  *(a2 - 3) = v119;
                  *(a2 - 2) = v120;
                  *(a2 - 1) = v121;
                  uint64_t v130 = (char *)v124 - (char *)i + 24;
                  if (v130 < 25) {
                    goto LABEL_233;
                  }
                  unint64_t v131 = 0xAAAAAAAAAAAAAAABLL * (v130 >> 3) - 2;
                  unint64_t v132 = v131 >> 1;
                  id v133 = &i[3 * (v131 >> 1)];
                  unint64_t v134 = *v133;
                  unint64_t v135 = *v124;
                  if (*v133 >= *v124)
                  {
                    if (v135 < v134) {
                      goto LABEL_233;
                    }
                    __n128 result = v133[1];
                    unint64_t v136 = v124[1];
                    if (result >= v136)
                    {
                      if (v136 < result) {
                        goto LABEL_233;
                      }
                      __n128 result = v133[2];
                      if (result >= v124[2]) {
                        goto LABEL_233;
                      }
                    }
                  }

                  else
                  {
                    unint64_t v136 = v124[1];
                  }

                  __n128 result = v124[2];
                  *double v124 = v134;
                  v124[1] = v133[1];
                  void v124[2] = v133[2];
                  if (v131 < 2) {
                    goto LABEL_232;
                  }
                  while (1)
                  {
                    id v137 = v133;
                    unint64_t v138 = v132 - 1;
                    unint64_t v132 = (v132 - 1) >> 1;
                    id v133 = &i[3 * v132];
                    unint64_t v139 = *v133;
                    if (*v133 >= v135) {
                      break;
                    }
                    unint64_t v140 = v133[1];
LABEL_229:
                    *id v137 = v139;
                    v137[1] = v140;
                    v137[2] = v133[2];
                    if (v138 <= 1) {
                      goto LABEL_232;
                    }
                  }

                  if (v135 >= v139)
                  {
                    unint64_t v140 = v133[1];
                    if (v140 < v136 || v136 >= v140 && v133[2] < result) {
                      goto LABEL_229;
                    }
                  }

                  id v133 = v137;
LABEL_232:
                  *id v133 = v135;
                  v133[1] = v136;
                  v133[2] = result;
LABEL_233:
                  a2 -= 3;
                  if (v117-- <= 2) {
                    return result;
                  }
                }
              }
            }
          }

          unint64_t v12 = (unint64_t)v11 >> 1;
          unint64_t v13 = &i[3 * ((unint64_t)v11 >> 1)];
          if ((unint64_t)v10 < 0xC01)
          {
            __n128 result = (unint64_t)std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::tuple<unsigned long long,unsigned long long,unsigned long long> *>( &v7[3 * v12],  v7,  a2 - 3);
          }

          else
          {
            std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::tuple<unsigned long long,unsigned long long,unsigned long long> *>( v7,  &v7[3 * v12],  a2 - 3);
            uint64_t v14 = 3 * v12;
            unint64_t v15 = &v7[3 * v12 - 3];
            std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::tuple<unsigned long long,unsigned long long,unsigned long long> *>( v7 + 3,  v15,  a2 - 6);
            unint64_t v16 = &v7[v14 + 3];
            std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::tuple<unsigned long long,unsigned long long,unsigned long long> *>( v7 + 6,  v16,  a2 - 9);
            __n128 result = (unint64_t)std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::tuple<unsigned long long,unsigned long long,unsigned long long> *>( v15,  v13,  v16);
            __int128 v17 = *(_OWORD *)v7;
            *(_OWORD *)double v7 = *(_OWORD *)v13;
            *(_OWORD *)unint64_t v13 = v17;
            unint64_t v18 = v7[2];
            v7[2] = v13[2];
            v13[2] = v18;
          }

          --a3;
          unint64_t v19 = *v7;
          if ((a4 & 1) == 0)
          {
            unint64_t v20 = *(v7 - 3);
            if (v20 >= v19)
            {
              if (v19 < v20)
              {
                unint64_t v22 = v7[1];
              }

              else
              {
                unint64_t v21 = *(v7 - 2);
                unint64_t v22 = v7[1];
                if (v21 < v22 || v22 >= v21 && *(v7 - 1) < v7[2]) {
                  goto LABEL_15;
                }
              }

              unint64_t v45 = v7[2];
              unint64_t v46 = *v8;
              if (v19 < *v8 || v46 >= v19 && ((unint64_t v62 = *(a2 - 2), v22 < v62) || v62 >= v22 && v45 < *(a2 - 1)))
              {
                uint64_t i = v7;
                while (1)
                {
                  unint64_t v48 = i[3];
                  i += 3;
                  unint64_t v47 = v48;
                  if (v19 < v48) {
                    break;
                  }
                  if (v47 >= v19)
                  {
                    unint64_t v49 = i[1];
                    if (v22 < v49 || v49 >= v22 && v45 < i[2]) {
                      break;
                    }
                  }
                }
              }

              else
              {
                for (uint64_t i = v7 + 3; i < a2; i += 3)
                {
                  if (v19 < *i) {
                    break;
                  }
                  if (*i >= v19)
                  {
                    unint64_t v61 = i[1];
                    if (v22 < v61 || v61 >= v22 && v45 < i[2]) {
                      break;
                    }
                  }
                }
              }

              uint64_t j = a2;
              if (i < a2)
              {
                for (uint64_t j = a2 - 3; ; j -= 3)
                {
                  if (v19 >= v46)
                  {
                    if (v46 < v19) {
                      break;
                    }
                    unint64_t v51 = j[1];
                    if (v22 >= v51 && (v51 < v22 || v45 >= j[2])) {
                      break;
                    }
                  }

                  unint64_t v52 = *(j - 3);
                  unint64_t v46 = v52;
                }
              }

              if (i < j)
              {
                unint64_t v53 = *i;
                unint64_t v54 = *j;
                do
                {
                  unint64_t *i = v54;
                  *uint64_t j = v53;
                  unint64_t v55 = i[1];
                  i[1] = j[1];
                  j[1] = v55;
                  unint64_t v56 = i[2];
                  i[2] = j[2];
                  j[2] = v56;
                  while (1)
                  {
                    unint64_t v57 = i[3];
                    i += 3;
                    unint64_t v53 = v57;
                    if (v19 < v57) {
                      break;
                    }
                    if (v53 >= v19)
                    {
                      unint64_t v58 = i[1];
                      if (v22 < v58 || v58 >= v22 && v45 < i[2]) {
                        break;
                      }
                    }
                  }

                  do
                  {
                    do
                    {
                      unint64_t v59 = *(j - 3);
                      j -= 3;
                      unint64_t v54 = v59;
                    }

                    while (v19 < v59);
                    if (v54 < v19) {
                      break;
                    }
                    unint64_t v60 = j[1];
                  }

                  while (v22 < v60 || v60 >= v22 && v45 < j[2]);
                }

                while (i < j);
              }

              if (i - 3 != v7)
              {
                *double v7 = *(i - 3);
                v7[1] = *(i - 2);
                v7[2] = *(i - 1);
              }

              a4 = 0;
              *(i - 3) = v19;
              *(i - 2) = v22;
              *(i - 1) = v45;
              continue;
            }
          }

                    *(void *)uint64_t v118 = v120;
                    *(_DWORD *)(v118 + _Block_object_dispose(va, 8) = v187;
                    *(_DWORD *)(v118 + 12) = v121;
                    *(void *)(v118 + 16) = v184;
                    *(void *)(v118 + 24) = v185;
                    *(void *)(v118 + 32) = v122;
                    a2 = (double *)v193;
                  }
                }

                unint64_t v115 = v116 - 1;
              }

              while (v116);
              unint64_t v135 = v13 / 0x28uLL;
              do
              {
                unint64_t v136 = a2;
                id v137 = 0LL;
                uint64_t v208 = *(void *)(a1 + 32);
                uint64_t v198 = *(_OWORD *)a1;
                uint64_t v203 = *(_OWORD *)(a1 + 16);
                unint64_t v138 = v135 - 2;
                if (v135 < 2) {
                  unint64_t v138 = v135 - 1;
                }
                unint64_t v139 = v138 >> 1;
                unint64_t v140 = a1;
                do
                {
                  unint64_t v141 = v140 + 40 * v137 + 40;
                  unint64_t v142 = (2 * v137) | 1;
                  unint64_t v143 = 2 * v137 + 2;
                  if (v143 < v135 && USCSampleComparator::operator()(v140 + 40 * v137 + 40, v140 + 40 * v137 + 80))
                  {
                    v141 += 40LL;
                    unint64_t v142 = v143;
                  }

                  unint64_t v144 = *(_OWORD *)v141;
                  unsigned int v145 = *(_OWORD *)(v141 + 16);
                  *(void *)(v140 + 32) = *(void *)(v141 + 32);
                  *(_OWORD *)unint64_t v140 = v144;
                  *(_OWORD *)(v140 + 16) = v145;
                  unint64_t v140 = v141;
                  id v137 = v142;
                }

                while (v142 <= v139);
                unint64_t v146 = v136 - 5;
                if ((double *)v141 == v146)
                {
                  v149 = v146;
                  __n128 result = *(double *)&v198;
                  *(void *)(v141 + 32) = v208;
                  *(_OWORD *)unint64_t v141 = v198;
                  *(_OWORD *)(v141 + 16) = v203;
                }

                else
                {
                  uint64_t v147 = *(_OWORD *)v146;
                  uint64_t v148 = *((_OWORD *)v146 + 1);
                  *(double *)(v141 + 32) = v146[4];
                  *(_OWORD *)unint64_t v141 = v147;
                  *(_OWORD *)(v141 + 16) = v148;
                  __n128 result = *(double *)&v198;
                  *((void *)v146 + 4) = v208;
                  *(_OWORD *)unint64_t v146 = v198;
                  *((_OWORD *)v146 + 1) = v203;
                  v149 = v146;
                  uint64_t v150 = v141 - a1 + 40;
                  if (v150 >= 41)
                  {
                    unint64_t v151 = -2 - 0x3333333333333333LL * (v150 >> 3);
                    uint64_t v152 = v151 >> 1;
                    __int128 v153 = a1 + 40 * (v151 >> 1);
                    if (USCSampleComparator::operator()(v153, v141))
                    {
                      __int128 v154 = *(void *)v141;
                      uint64_t v155 = *(_DWORD *)(v141 + 8);
                      int v156 = *(_DWORD *)(v141 + 12);
                      unint64_t v158 = *(void *)(v141 + 16);
                      uint64_t v157 = *(void *)(v141 + 24);
                      __n128 result = *(double *)(v141 + 32);
                      id v159 = *(void *)(v153 + 32);
                      __int128 v160 = *(_OWORD *)(v153 + 16);
                      *(_OWORD *)unint64_t v141 = *(_OWORD *)v153;
                      *(_OWORD *)(v141 + 16) = v160;
                      *(void *)(v141 + 32) = v159;
                      if (v151 >= 2)
                      {
                        while (1)
                        {
                          __int128 v161 = v153;
                          __int128 v162 = v152 - 1;
                          uint64_t v152 = (v152 - 1) >> 1;
                          __int128 v153 = a1 + 40 * v152;
                          __int128 v163 = *(_DWORD *)(v153 + 12);
                          id v164 = v163 >= v156;
                          if (v163 == v156)
                          {
                            uint64_t v165 = *(_DWORD *)(a1 + 40 * v152 + 32);
                            id v164 = v165 >= LODWORD(result);
                            if (v165 == LODWORD(result))
                            {
                              id v164 = *(_DWORD *)v153 >= v154;
                              if (*(_DWORD *)v153 == (_DWORD)v154)
                              {
                                id v166 = *(_DWORD *)(a1 + 40 * v152 + 8);
                                id v164 = v166 >= v155;
                                if (v166 == v155) {
                                  id v164 = *(void *)(a1 + 40 * v152 + 24) >= v157;
                                }
                              }
                            }
                          }

                          if (v164) {
                            break;
                          }
                          id v167 = *(_OWORD *)v153;
                          id v168 = *(_OWORD *)(v153 + 16);
                          *(void *)(v161 + 32) = *(void *)(v153 + 32);
                          *(_OWORD *)__int128 v161 = v167;
                          *(_OWORD *)(v161 + 16) = v168;
                          if (v162 <= 1) {
                            goto LABEL_201;
                          }
                        }

                        __int128 v153 = v161;
                      }

LABEL_15:
          unint64_t v23 = v7[1];
          unint64_t v24 = v7[2];
          for (uint64_t k = v7 + 3; ; k += 3)
          {
            unint64_t v26 = *k;
            if (*k >= v19)
            {
              if (v19 < v26) {
                break;
              }
              unint64_t v27 = k[1];
              if (v27 >= v23 && (v23 < v27 || k[2] >= v24)) {
                break;
              }
            }
          }

          if (k - 3 == v7)
          {
            uint64_t m = a2;
            if (k < a2)
            {
              unint64_t v32 = *v8;
              uint64_t m = a2 - 3;
              if (*v8 >= v19)
              {
                uint64_t m = a2 - 3;
                do
                {
                  if (v19 < v32) {
                    goto LABEL_36;
                  }
                  unint64_t v33 = m[1];
                  if (v33 < v23) {
                    break;
                  }
                  if (v23 >= v33)
                  {
                    if (m[2] < v24 || k >= m) {
                      break;
                    }
                  }

                  else
                  {
LABEL_36:
                    if (k >= m) {
                      break;
                    }
                  }

                  unint64_t v35 = *(m - 3);
                  m -= 3;
                  unint64_t v32 = v35;
                }

                while (v35 >= v19);
              }
            }
          }

          else
          {
            unint64_t v28 = *v8;
            for (uint64_t m = a2 - 3; v28 >= v19; m -= 3)
            {
              if (v19 >= v28)
              {
                unint64_t v30 = m[1];
                if (v30 < v23 || v23 >= v30 && m[2] < v24) {
                  break;
                }
              }

              unint64_t v31 = *(m - 3);
              unint64_t v28 = v31;
            }
          }

          uint64_t i = k;
          if (k < m)
          {
            unint64_t v36 = *m;
            uint64_t i = k;
            uint64_t v37 = m;
            do
            {
              unint64_t *i = v36;
              *uint64_t v37 = v26;
              unint64_t v38 = i[1];
              i[1] = v37[1];
              v37[1] = v38;
              unint64_t v39 = i[2];
              i[2] = v37[2];
              v37[2] = v39;
              do
              {
                do
                {
                  unint64_t v40 = i[3];
                  i += 3;
                  unint64_t v26 = v40;
                }

                while (v40 < v19);
                if (v19 < v26) {
                  break;
                }
                unint64_t v41 = i[1];
              }

              while (v41 < v23 || v23 >= v41 && i[2] < v24);
              while (1)
              {
                unint64_t v42 = *(v37 - 3);
                v37 -= 3;
                unint64_t v36 = v42;
                if (v42 < v19) {
                  break;
                }
                if (v19 >= v36)
                {
                  unint64_t v43 = v37[1];
                  if (v43 < v23 || v23 >= v43 && v37[2] < v24) {
                    break;
                  }
                }
              }
            }

            while (i < v37);
          }

          if (i - 3 != v7)
          {
            *double v7 = *(i - 3);
            v7[1] = *(i - 2);
            v7[2] = *(i - 1);
          }

          *(i - 3) = v19;
          *(i - 2) = v23;
          *(i - 1) = v24;
          if (k < m)
          {
LABEL_62:
            __n128 result = std::__introsort<std::_ClassicAlgPolicy,std::__less<void,void> &,std::tuple<unsigned long long,unsigned long long,unsigned long long> *,false>( v7,  i - 3,  a3,  a4 & 1);
            a4 = 0;
            continue;
          }

          BOOL v44 = std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::tuple<unsigned long long,unsigned long long,unsigned long long> *>( v7,  i - 3);
          __n128 result = std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::tuple<unsigned long long,unsigned long long,unsigned long long> *>( i,  a2);
          if (!(_DWORD)result)
          {
            if (v44) {
              continue;
            }
            goto LABEL_62;
          }

          a2 = i - 3;
          if (v44) {
            return result;
          }
          goto LABEL_2;
        }

        int v69 = i + 3;
        BOOL v71 = i == a2 || v69 == a2;
        if ((a4 & 1) == 0)
        {
          if (v71) {
            return result;
          }
          while (1)
          {
            int v105 = v7;
            double v7 = v69;
            unint64_t v106 = v105[3];
            unint64_t v107 = *v105;
            if (v106 < *v105) {
              break;
            }
            if (v107 >= v106)
            {
              unint64_t v108 = v105[4];
              unint64_t v109 = v105[1];
              if (v108 < v109 || v109 >= v108 && v105[5] < v105[2]) {
                goto LABEL_193;
              }
            }

      unint64_t v16 = v21;

      goto LABEL_16;
    }

    unint64_t v16 = 0LL;
  }

      GTTraceFunc_argumentBytesWithMap((void *)a1, *(unsigned __int8 *)(a1 + 13), a2);
      return 0LL;
    }

    if (v4 == -16147 || v4 == -16145) {
      goto LABEL_15;
    }
  }

  return result;
}

    unint64_t v13 = "Internal";
    goto LABEL_16;
  }

  unint64_t v13 = "Shader Profiler";
  switch(a6)
  {
    case 1LL:
      uint64_t v14 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", a2));
      break;
    case 2LL:
      goto LABEL_16;
    case 4LL:
      unint64_t v13 = "Shader Debugger";
      goto LABEL_16;
    case 8LL:
      unint64_t v13 = "Thumbnails";
      goto LABEL_16;
    default:
      goto LABEL_15;
  }

        uint64_t v11 = v7;
        goto LABEL_22;
      }

      unint64_t v48 = NSUnderlyingErrorKey;
      unint64_t v49 = v18;
      unint64_t v20 = (NSMutableData *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v49,  &v48,  1LL));
      unint64_t v36 = MakeNSError(101, v20);
      uint64_t v37 = (id)objc_claimAutoreleasedReturnValue(v36);
      GTMTLReplay_handleNSError(v37);
    }

    goto LABEL_21;
  }

  uint64_t v11 = v7;
LABEL_22:

  return v11;
}

  return v14;
}

          unint64_t v23 = *(void *)(v7 + 8);
          unint64_t v24 = *(void *)(v7 + 16);
          for (uint64_t k = v7 + 24; ; k += 24LL)
          {
            unint64_t v26 = *(_DWORD *)k;
            if (*(_DWORD *)k >= v19)
            {
              if (v19 < v26) {
                break;
              }
              unint64_t v27 = *(void *)(k + 8);
              if (v27 >= v23 && (v23 < v27 || *(void *)(k + 16) >= v24)) {
                break;
              }
            }
          }

          if (k - 24 == v7)
          {
            uint64_t m = a2;
            if (k < a2)
            {
              unint64_t v32 = *v8;
              uint64_t m = a2 - 24;
              if (*v8 >= v19)
              {
                uint64_t m = a2 - 24;
                do
                {
                  if (v19 < v32) {
                    goto LABEL_36;
                  }
                  unint64_t v33 = *(void *)(m + 8);
                  if (v33 < v23) {
                    break;
                  }
                  if (v23 >= v33)
                  {
                    if (*(void *)(m + 16) < v24 || k >= m) {
                      break;
                    }
                  }

                  else
                  {
LABEL_36:
                    if (k >= m) {
                      break;
                    }
                  }

                  unint64_t v35 = *(_DWORD *)(m - 24);
                  m -= 24LL;
                  unint64_t v32 = v35;
                }

                while (v35 >= v19);
              }
            }
          }

          else
          {
            unint64_t v28 = *v8;
            for (uint64_t m = a2 - 24; v28 >= v19; m -= 24LL)
            {
              if (v19 >= v28)
              {
                unint64_t v30 = *(void *)(m + 8);
                if (v30 < v23 || v23 >= v30 && *(void *)(m + 16) < v24) {
                  break;
                }
              }

              unint64_t v31 = *(_DWORD *)(m - 24);
              unint64_t v28 = v31;
            }
          }

          uint64_t i = k;
          if (k < m)
          {
            unint64_t v36 = *(_DWORD *)m;
            uint64_t i = k;
            uint64_t v37 = m;
            do
            {
              *(_DWORD *)uint64_t i = v36;
              *(_DWORD *)uint64_t v37 = v26;
              unint64_t v38 = *(_OWORD *)(i + 8);
              *(_OWORD *)(i + _Block_object_dispose(va, 8) = *(_OWORD *)(v37 + 8);
              *(_OWORD *)(v37 + _Block_object_dispose(va, 8) = v38;
              do
              {
                do
                {
                  unint64_t v39 = *(_DWORD *)(i + 24);
                  i += 24LL;
                  unint64_t v26 = v39;
                }

                while (v39 < v19);
                if (v19 < v26) {
                  break;
                }
                unint64_t v40 = *(void *)(i + 8);
              }

              while (v40 < v23 || v23 >= v40 && *(void *)(i + 16) < v24);
              while (1)
              {
                unint64_t v41 = *(_DWORD *)(v37 - 24);
                v37 -= 24LL;
                unint64_t v36 = v41;
                if (v41 < v19) {
                  break;
                }
                if (v19 >= v36)
                {
                  unint64_t v42 = *(void *)(v37 + 8);
                  if (v42 < v23 || v23 >= v42 && *(void *)(v37 + 16) < v24) {
                    break;
                  }
                }
              }
            }

            while (i < v37);
          }

          if (i - 24 != v7)
          {
            *(_DWORD *)double v7 = *(_DWORD *)(i - 24);
            *(_OWORD *)(v7 + _Block_object_dispose(va, 8) = *(_OWORD *)(i - 16);
          }

          *(_DWORD *)(i - 24) = v19;
          *(void *)(i - 16) = v23;
          *(void *)(i - _Block_object_dispose(va, 8) = v24;
          if (k < m)
          {
LABEL_62:
            __n128 result = std::__introsort<std::_ClassicAlgPolicy,std::__less<void,void> &,std::tuple<int,unsigned long,unsigned long long> *,false>( v7,  i - 24,  a3,  a4 & 1);
            a4 = 0;
            continue;
          }

          unint64_t v43 = std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::tuple<int,unsigned long,unsigned long long> *>( v7,  i - 24);
          __n128 result = std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::tuple<int,unsigned long,unsigned long long> *>( i,  a2);
          if (!(_DWORD)result)
          {
            if (v43) {
              continue;
            }
            goto LABEL_62;
          }

          a2 = i - 24;
          if (v43) {
            return result;
          }
          goto LABEL_2;
        }

        unint64_t v65 = i + 24;
        unint64_t v67 = i == a2 || v65 == a2;
        if ((a4 & 1) == 0)
        {
          if (v67) {
            return result;
          }
          for (uint64_t n = (_OWORD *)(i + 32); ; uint64_t n = (_OWORD *)((char *)n + 24))
          {
            unint64_t v106 = v7;
            double v7 = v65;
            unint64_t v107 = *(_DWORD *)(v106 + 24);
            unint64_t v108 = *(_DWORD *)v106;
            if (v107 < *(_DWORD *)v106) {
              break;
            }
            if (v108 >= v107)
            {
              unint64_t v109 = *(void *)(v106 + 32);
              unint64_t v110 = *(void *)(v106 + 8);
              if (v109 < v110 || v110 >= v109 && *(void *)(v106 + 40) < *(void *)(v106 + 16)) {
                goto LABEL_195;
              }
            }

    unint64_t v16 = *a1;
    v25.i64[0] = *(void *)(a3 + 64);
    __int128 v17 = *find_entry(v16, &v25, 8uLL, 0LL);
    if (v17) {
      __int128 v17 = *(void *)(v17 + 32);
    }
    unint64_t v18 = a1[1];
    BOOL v25 = 0u;
    v26[0] = 0LL;
    unint64_t v30 = 0LL;
    memset(v29, 0, sizeof(v29));
    unint64_t v27 = 0u;
    memset(v28, 0, 48);
    v25.i32[0] = 29;
    v26[1] = -1LL;
    v28[3] = (int8x16_t)0xFFFFFFFFFFFFFFFFLL;
    if (v17 && (unint64_t v19 = *(void *)(v17 + 32)) != 0 && (*(_BYTE *)(v19 + 79) & 8) != 0) {
      unint64_t v20 = (uint64_t *)(v19 + 64);
    }
    else {
      unint64_t v20 = 0LL;
    }
    GTMTLSMComputePipelineState_processTraceFuncWithMap(v25.i8, v18, v20);
    unint64_t v33 = *(int8x16_t *)((char *)v29 + 8);
    v34[0] = *(int8x16_t *)((char *)&v29[1] + 8);
    unint64_t v24 = vandq_s8(*(int8x16_t *)((char *)v29 + 8), (int8x16_t)vdupq_n_s64(~*(void *)(a3 + 72)));
    unint64_t v35 = v29[3].i64[1];
    v34[1] = *(int8x16_t *)((char *)&v29[2] + 8);
    unint64_t v33 = v24;
    BufferAccess(a1, a3 + 88, &v33, a4);
    unint64_t v21 = a3 + 832;
    unint64_t v23 = a1;
    unint64_t v22 = (uint64_t *)v34;
    return TextureAccess(v23, v21, (uint64_t)v22, a4);
  }

  if (a2 != -15297)
  {
    unint64_t v12 = -15486;
    goto LABEL_12;
  }

  if ((v15 & 1) == 0) {
    bzero(a3, a4);
  }
}

LABEL_200:
            int v69 = v7 + 3;
            if (v7 + 3 == a2) {
              return result;
            }
          }

          unint64_t v108 = v105[4];
LABEL_193:
          unint64_t v110 = v105[5];
          do
          {
            do
            {
              uint64_t v111 = v105;
              unint64_t v112 = v107;
              unint64_t v113 = *(v105 - 3);
              v105 -= 3;
              unint64_t v107 = v113;
              unint64_t v114 = v105[4];
              unint64_t v115 = v105[5];
              v105[6] = v112;
              v105[7] = v114;
              v105[8] = v115;
            }

            while (v106 < v113);
            if (v107 < v106) {
              break;
            }
            unint64_t v116 = *(v111 - 2);
          }

          while (v108 < v116 || v116 >= v108 && v110 < *(v111 - 1));
          *uint64_t v111 = v106;
          v111[1] = v108;
          void v111[2] = v110;
          goto LABEL_200;
        }

        if (v71) {
          return result;
        }
        uint64_t v72 = 0LL;
        char v73 = i;
        do
        {
          id v74 = v73;
          char v73 = v69;
          unint64_t v75 = v74[3];
          unint64_t v76 = *v74;
          if (v75 >= *v74)
          {
            if (v76 < v75) {
              goto LABEL_148;
            }
            unint64_t v77 = v74[4];
            unint64_t v78 = v74[1];
            if (v77 >= v78 && (v78 < v77 || v74[5] >= v74[2])) {
              goto LABEL_148;
            }
          }

          else
          {
            unint64_t v77 = v74[4];
          }

          unint64_t v79 = v74[5];
          v74[3] = v76;
          v73[1] = v74[1];
          void v73[2] = v74[2];
          unsigned int v80 = i;
          if (v74 == i) {
            goto LABEL_147;
          }
          uint64_t v81 = v72;
          while (1)
          {
            unint64_t v82 = *(unint64_t *)((char *)i + v81 - 24);
            if (v75 < v82)
            {
              unint64_t v83 = *(unint64_t *)((char *)i + v81 - 16);
              goto LABEL_144;
            }

            if (v82 < v75) {
              goto LABEL_146;
            }
            unint64_t v83 = *(unint64_t *)((char *)i + v81 - 16);
            if (v77 >= v83) {
              break;
            }
LABEL_144:
            v74 -= 3;
            uint64_t v84 = (unint64_t *)((char *)i + v81);
            unint64_t *v84 = v82;
            v84[1] = v83;
            v84[2] = *(unint64_t *)((char *)i + v81 - 8);
            v81 -= 24LL;
            if (!v81)
            {
              unsigned int v80 = i;
              goto LABEL_147;
            }
          }

          if (v83 >= v77)
          {
            unsigned int v80 = (unint64_t *)((char *)i + v81);
            __n128 result = *(unint64_t *)((char *)i + v81 - 8);
            if (v79 >= result) {
              goto LABEL_147;
            }
            goto LABEL_144;
          }

LABEL_146:
          unsigned int v80 = v74;
LABEL_147:
          unint64_t *v80 = v75;
          v80[1] = v77;
          v80[2] = v79;
LABEL_148:
          int v69 = v73 + 3;
          v72 += 24LL;
        }

        while (v73 + 3 != a2);
        return result;
    }
  }

      if (v122 == v121
        || v122 - v119 == -8
        || ShaderDebugger::Metadata::MDSerializer::isMetadataIdReserved((char **)v117 + 5, a2))
      {
        uint64_t v123 = ShaderDebugger::Metadata::MDSerializer::addAndLinearizeMetadataId(v120, a2);
        ShaderDebugger::Metadata::MDSerializer::serializeTypeBase( (unint64_t *)v118 + 11,  v123,  (uint64_t)&v192,  v112,  v115,  v113,  v114,  v116,  2LL);
        ShaderDebugger::Metadata::MDSerializer::write<unsigned long long>((unint64_t *)v118 + 11, __p);
        double v124 = 100LL;
        if ((v106 & 0xFF00000000LL) != 0) {
          double v124 = v182;
        }
        v199[0] = v124;
        ShaderDebugger::Metadata::MDSerializer::write<unsigned long long>((unint64_t *)v118 + 11, v199);
      }

      if (SHIBYTE(v194) < 0) {
        operator delete(v192);
      }
      std::__tree<llvm::DIType *>::destroy(v189[0]);
      return v111;
    case 0xD:
      v187[0] = 0LL;
      v187[1] = 0LL;
      v186 = v187;
      std::set<llvm::DIType *>::insert[abi:nn180100]<std::__tree_const_iterator<llvm::DIType *,std::__tree_node<llvm::DIType *,void *> *,long>>( (uint64_t *)&v186,  *a3,  v7);
      unint64_t v45 = *(unsigned int *)(a2 + 8);
      unint64_t v46 = *(void *)(a2 - 8 * v45 + 24);
      if (v46)
      {
        id v196 = 0LL;
        id v197 = 0LL;
        __dst = &v196;
        std::set<llvm::DIType *>::insert[abi:nn180100]<std::__tree_const_iterator<llvm::DIType *,std::__tree_node<llvm::DIType *,void *> *,long>>( (uint64_t *)&__dst,  v186,  v187);
        char v177 = ShaderDebugger::Metadata::MDSerializerLLVM3XXX::serializeType(v5, v46, &__dst);
        std::__tree<llvm::DIType *>::destroy(v196);
        unint64_t v47 = -(uint64_t)*(unsigned int *)(a2 + 8);
      }

      else
      {
        unint64_t v47 = -v45;
        char v177 = -1LL;
      }

      id v180 = v21;
      uint64_t v125 = *(void *)(a2 + 8 * v47 + 32);
      if (v125) {
        int64_t v126 = (llvm::DISubrange **)(v125 - 8LL * *(unsigned int *)(v125 + 8));
      }
      else {
        int64_t v126 = 0LL;
      }
      if (v126 != (llvm::DISubrange **)v125)
      {
        unint64_t v127 = 0LL;
        unint64_t v128 = 0LL;
        unint64_t v129 = 0LL;
        id v183 = *(void *)(a2 + 8 * v47 + 32);
        while (1)
        {
          uint64_t v130 = *v126;
          unint64_t v131 = *(unsigned __int8 *)*v126;
          if (v131 == 9)
          {
            Count = llvm::DISubrange::getCount(*v126);
            unint64_t v134 = Count & 0xFFFFFFFFFFFFFFF8LL;
            if ((Count & 6) != 0 || v134 == 0)
            {
              unint64_t v136 = -1LL;
            }

            else
            {
              unint64_t v144 = *(_DWORD *)(v134 + 32);
              if (v144 > 0x40) {
                unint64_t v136 = **(void **)(v134 + 24);
              }
              else {
                unint64_t v136 = (uint64_t)(*(void *)(v134 + 24) << -(char)v144) >> -(char)v144;
              }
            }

            LowerBound = llvm::DISubrange::getLowerBound(v130);
            unint64_t v146 = 0LL;
            if ((LowerBound & 6) == 0)
            {
              uint64_t v147 = LowerBound & 0xFFFFFFFFFFFFFFF8LL;
              if ((LowerBound & 0xFFFFFFFFFFFFFFF8LL) != 0)
              {
                uint64_t v148 = *(_DWORD *)(v147 + 32);
                if (v148 > 0x40) {
                  unint64_t v146 = **(void **)(v147 + 24);
                }
                else {
                  unint64_t v146 = (uint64_t)(*(void *)(v147 + 24) << -(char)v148) >> -(char)v148;
                }
              }
            }

            __p[0] = (void *)v146;
            uint64_t v198 = 4LL;
            v199[0] = v136;
            v149 = std::__tree<std::__value_type<ShaderDebugger::Metadata::MDBase::MetadataType,ShaderDebugger::Metadata::MDSerializer::MetadataTypeContainer>,std::__map_value_compare<ShaderDebugger::Metadata::MDBase::MetadataType,std::__value_type<ShaderDebugger::Metadata::MDBase::MetadataType,ShaderDebugger::Metadata::MDSerializer::MetadataTypeContainer>,std::less<ShaderDebugger::Metadata::MDBase::MetadataType>,true>,std::allocator<std::__value_type<ShaderDebugger::Metadata::MDBase::MetadataType,ShaderDebugger::Metadata::MDSerializer::MetadataTypeContainer>>>::__emplace_unique_key_args<ShaderDebugger::Metadata::MDBase::MetadataType,std::piecewise_construct_t const&,std::tuple<ShaderDebugger::Metadata::MDBase::MetadataType&&>,std::tuple<>>( v5,  4uLL,  &v198);
            uint64_t v150 = v149;
            uint64_t v152 = (uint64_t)(v149 + 40);
            unint64_t v151 = (llvm::DISubrange **)*((void *)v149 + 5);
            __int128 v153 = (llvm::DISubrange **)*((void *)v149 + 6);
            __int128 v154 = v151;
            if (v151 != v153)
            {
              while (*v154 != v130)
              {
                if (++v154 == v153)
                {
                  __int128 v154 = (llvm::DISubrange **)*((void *)v149 + 6);
                  break;
                }
              }
            }

            uint64_t v155 = v154 - v151;
            if (v154 == v153) {
              int v156 = -1LL;
            }
            else {
              int v156 = v155;
            }
            if (v156 == -1
              || ShaderDebugger::Metadata::MDSerializer::isMetadataIdReserved( (char **)v149 + 5,  (uint64_t)v130))
            {
              int v156 = ShaderDebugger::Metadata::MDSerializer::addAndLinearizeMetadataId(v152, (uint64_t)v130);
              uint64_t v198 = v156;
              ShaderDebugger::Metadata::MDSerializer::write<unsigned long long>((unint64_t *)v150 + 11, &v198);
              ShaderDebugger::Metadata::MDSerializer::write<unsigned long long>((unint64_t *)v150 + 11, __p);
              ShaderDebugger::Metadata::MDSerializer::write<unsigned long long>((unint64_t *)v150 + 11, v199);
            }

            if ((unint64_t)v128 < v129)
            {
              *(void *)unint64_t v128 = 4LL;
              *((void *)v128 + 1) = v156;
              v128 += 16;
              uint64_t v5 = v181;
              goto LABEL_223;
            }

            uint64_t v157 = (v128 - v127) >> 4;
            unint64_t v158 = v157 + 1;
            else {
              unint64_t v139 = v158;
            }
            if (v139) {
              unint64_t v139 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<std::pair<unsigned long long,unsigned long long>>>(v139);
            }
            else {
              unint64_t v140 = 0LL;
            }
            unint64_t v141 = (void *)(v139 + 16 * v157);
            *unint64_t v141 = 4LL;
            v141[1] = v156;
            if (v128 == v127)
            {
              unint64_t v143 = (char *)(v139 + 16 * v157);
              uint64_t v5 = v181;
            }

            else
            {
              id v159 = v139 + 16 * v157;
              uint64_t v5 = v181;
              do
              {
                unint64_t v143 = (char *)(v159 - 16);
                *(_OWORD *)(v159 - 16) = *((_OWORD *)v128 - 1);
                v128 -= 16;
                v159 -= 16LL;
              }

              while (v128 != v127);
            }

            goto LABEL_220;
          }

  ++*((void *)i + 6);
LABEL_147:
  *((_DWORD *)v42 + 5) = a3;
}

      unint64_t v78 = [v117 copy];

      unint64_t v79 = v137;
    }

    else
    {
      uint64_t v111 = v1;
      unint64_t v112 = v10;
      unint64_t v113 = v5;
      unint64_t v114 = v4;
      int64_t v126 = v10;
      unint64_t v13 = [v126 size];
      uint64_t v14 = v156;
      uint64_t v122 = v13;
      double v124 = (id)objc_claimAutoreleasedReturnValue(+[NSMutableData dataWithLength:](&OBJC_CLASS___NSMutableData, "dataWithLength:", v156 * (void)v13));
      if (v13)
      {
        unint64_t v15 = 0LL;
        unint64_t v115 = 0LL;
        unint64_t v116 = 0LL;
        context = 0LL;
        unint64_t v16 = 0LL;
        unint64_t v110 = 0LL;
        __int128 v17 = 0LL;
        unint64_t v18 = "getVertexBufferAddressAtIndex:";
        unint64_t v141 = 0LL;
        uint64_t v118 = v14;
        unint64_t v120 = v144;
        do
        {
          unint64_t v19 = v18;
          unint64_t v20 = objc_autoreleasePoolPush();
          unint64_t v21 = (void *)objc_claimAutoreleasedReturnValue([v126 indirectRenderCommandAtIndex:v17]);
          unint64_t v134 = v17;
          unint64_t v136 = (char *)[v124 mutableBytes];
          unint64_t v22 = &v136[v14 * v17];
          unint64_t v23 = (uint32_t *)[v21 getCommandType];
          *(void *)&v22[v120] = v23;
          if (v23)
          {
            unint64_t v24 = v23;
            unint64_t v128 = v20;
            uint64_t v130 = v16;
            unint64_t v132 = v22;
            BOOL v25 = v155;
            unint64_t v26 = &v22[v155];
            if ((int)((unint64_t)(v155 - v153) >> 3) >= 1)
            {
              unint64_t v27 = 0LL;
              unint64_t v28 = ((unint64_t)(v155 - v153) >> 3);
              uint64_t v29 = &v136[v153 + v15];
              do
              {
                *(void *)&v29[8 * v27] = [v21 getVertexAttributeStrideAtIndex:v27];
                ++v27;
              }

              while (v28 != v27);
            }

            unint64_t v18 = v19;
            unint64_t v30 = v132;
            switch((unint64_t)v24)
            {
              case 1uLL:
                unint64_t v31 = (void *)objc_claimAutoreleasedReturnValue([v21 drawArguments]);
                *(void *)unint64_t v26 = [v31 primitiveType];
                *((void *)v26 + 1) = [v31 vertexStart];
                *((void *)v26 + 2) = [v31 vertexCount];
                *((void *)v26 + 3) = [v31 instanceCount];
                *((void *)v26 + 4) = [v31 baseInstance];
                goto LABEL_44;
              case 2uLL:
                unint64_t v31 = (void *)objc_claimAutoreleasedReturnValue([v21 drawIndexedArguments]);
                *(void *)unint64_t v26 = [v31 primitiveType];
                *((void *)v26 + 1) = [v31 indexCount];
                *((void *)v26 + 2) = [v31 indexType];
                *((void *)v26 + 3) = [v31 indexBufferGPUVirtualAddress];
                *((void *)v26 + 4) = [v31 instanceCount];
                *((void *)v26 + 5) = [v31 baseVertex];
                *((void *)v26 + 6) = [v31 baseInstance];
                if (*((void *)v26 + 2) == -1LL) {
                  *((void *)v26 + 2) = *((void *)v110 + 2);
                }
                unint64_t v110 = v26;
                goto LABEL_44;
              case 3uLL:
              case 5uLL:
              case 6uLL:
              case 7uLL:
                goto LABEL_45;
              case 4uLL:
                uint64_t v37 = (void *)objc_claimAutoreleasedReturnValue([v21 getTessellationFactorArguments]);
                unint64_t v38 = &v132[v25];
                *(void *)&v132[v25] = [v37 virtualAddress];
                *((void *)v26 + 1) = [v37 instanceStride];
                [v37 scale];
                *((_DWORD *)v26 + 4) = v39;

                unint64_t v31 = (void *)objc_claimAutoreleasedReturnValue([v21 drawPatchesArguments]);
                *((void *)v38 + 3) = [v31 numberOfPatchControlPoints];
                *((void *)v38 + 4) = [v31 patchStart];
                *((void *)v38 + 5) = [v31 patchCount];
                *((void *)v38 + 6) = [v31 patchIndexBufferVirtualAddress];
                *((void *)v38 + 7) = [v31 instanceCount];
                *((void *)v38 + _Block_object_dispose(va, 8) = [v31 baseInstance];
                goto LABEL_44;
              case 8uLL:
                unint64_t v40 = (void *)objc_claimAutoreleasedReturnValue([v21 getTessellationFactorArguments]);
                unint64_t v41 = &v132[v25];
                *(void *)&v132[v25] = [v40 virtualAddress];
                *((void *)v26 + 1) = [v40 instanceStride];
                [v40 scale];
                *((_DWORD *)v26 + 4) = v42;

                unint64_t v31 = (void *)objc_claimAutoreleasedReturnValue([v21 drawIndexedPatchesArguments]);
                *((void *)v41 + 3) = [v31 numberOfPatchControlPoints];
                *((void *)v41 + 4) = [v31 patchStart];
                *((void *)v41 + 5) = [v31 patchCount];
                *((void *)v41 + 6) = [v31 patchIndexBufferVirtualAddress];
                *((void *)v41 + 7) = [v31 controlPointIndexBufferVirtualAddress];
                *((void *)v41 + _Block_object_dispose(va, 8) = [v31 instanceCount];
                *((void *)v41 + 9) = [v31 baseInstance];
                goto LABEL_44;
              default:
                if (v24 == (uint32_t *)&stru_68.segname[8])
                {
                  unint64_t v43 = (void *)objc_claimAutoreleasedReturnValue([v21 drawMeshThreadgroupsArguments]);
                  unint64_t v31 = v43;
                  if (v43)
                  {
                    [v43 threadgroupsPerGrid];
                    BOOL v44 = v165;
                    *(_OWORD *)unint64_t v26 = v164;
                    *((void *)v26 + 2) = v44;
                    [v31 threadsPerObjectThreadgroup];
                    unint64_t v45 = v170;
                    *(_OWORD *)(v26 + 24) = v169;
                    *((void *)v26 + 5) = v45;
                    [v31 threadsPerMeshThreadgroup];
                    unint64_t v35 = v167;
                    unint64_t v36 = v168;
                    unint64_t v18 = v19;
                    unint64_t v30 = v132;
                  }

                  else
                  {
                    if (s_logUsingOsLog)
                    {
                      unint64_t v48 = gt_default_log();
                      unint64_t v49 = (os_log_s *)objc_claimAutoreleasedReturnValue(v48);
                      if (os_log_type_enabled(v49, OS_LOG_TYPE_FAULT))
                      {
                        *(_WORD *)buf = 0;
                        _os_log_fault_impl( &dword_0,  v49,  OS_LOG_TYPE_FAULT,  "fail: Unable to decode MTLIndirectCommandTypeDrawMeshThreadgroups",  buf,  2u);
                      }
                    }

                    else
                    {
                      unint64_t v51 = __stderrp;
                      unint64_t v49 = (os_log_s *) objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString, "stringWithFormat:", @"fail: Unable to decode MTLIndirectCommandTypeDrawMeshThreadgroups"));
                      fprintf(v51, "%s\n", (const char *)-[os_log_s UTF8String](v49, "UTF8String"));
                    }

                    unint64_t v18 = v19;
                    unint64_t v30 = v132;

                    unint64_t v36 = 0LL;
                    *(void *)&uint64_t v165 = 0LL;
                    unint64_t v35 = 0uLL;
                    id v164 = 0u;
                    *((void *)v26 + 2) = 0LL;
                    *(_OWORD *)unint64_t v26 = 0u;
                    __int128 v170 = 0LL;
                    id v169 = 0u;
                    *((void *)v26 + 5) = 0LL;
                    *(_OWORD *)(v26 + 24) = 0u;
                    id v168 = 0LL;
                    id v167 = 0u;
                  }
                }

                else
                {
                  unint64_t v30 = v132;
                  if (v24 != &stru_B8.reserved2)
                  {
                    unint64_t v18 = v19;
                    goto LABEL_45;
                  }

                  unint64_t v32 = (void *)objc_claimAutoreleasedReturnValue([v21 drawMeshThreadsArguments]);
                  unint64_t v31 = v32;
                  unint64_t v18 = v19;
                  if (v32)
                  {
                    [v32 threadsPerGrid];
                    unint64_t v33 = v162;
                    *(_OWORD *)unint64_t v26 = v161;
                    *((void *)v26 + 2) = v33;
                    [v31 threadsPerObjectThreadgroup];
                    uint8x8_t v34 = v160;
                    *(_OWORD *)(v26 + 24) = v159;
                    *((void *)v26 + 5) = v34;
                    [v31 threadsPerMeshThreadgroup];
                    unint64_t v35 = v157;
                    unint64_t v36 = v158;
                  }

                  else
                  {
                    if (s_logUsingOsLog)
                    {
                      unint64_t v46 = gt_default_log();
                      unint64_t v47 = (os_log_s *)objc_claimAutoreleasedReturnValue(v46);
                      if (os_log_type_enabled(v47, OS_LOG_TYPE_FAULT))
                      {
                        *(_WORD *)buf = 0;
                        _os_log_fault_impl( &dword_0,  v47,  OS_LOG_TYPE_FAULT,  "fail: Unable to decode MTLIndirectCommandTypeDrawMeshThreads",  buf,  2u);
                      }
                    }

                    else
                    {
                      char v50 = __stderrp;
                      unint64_t v47 = (os_log_s *) objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString, "stringWithFormat:", @"fail: Unable to decode MTLIndirectCommandTypeDrawMeshThreads"));
                      fprintf(v50, "%s\n", (const char *)-[os_log_s UTF8String](v47, "UTF8String"));
                    }

                    unint64_t v36 = 0LL;
                    __int128 v162 = 0LL;
                    unint64_t v35 = 0uLL;
                    __int128 v161 = 0u;
                    *((void *)v26 + 2) = 0LL;
                    *(_OWORD *)unint64_t v26 = 0u;
                    __int128 v160 = 0LL;
                    id v159 = 0u;
                    *((void *)v26 + 5) = 0LL;
                    *(_OWORD *)(v26 + 24) = 0u;
                    unint64_t v158 = 0LL;
                    uint64_t v157 = 0u;
                  }
                }

                *((_OWORD *)v26 + 3) = v35;
                *((void *)v26 + _Block_object_dispose(va, 8) = v36;
LABEL_44:

LABEL_45:
                unint64_t v52 = v143;
                if (!v143[11])
                {
                  unint64_t v53 = [v21 getPipelineStateUniqueIdentifier];
                  unint64_t v54 = v116;
                  if (v53 != (id)-1LL) {
                    unint64_t v54 = v53;
                  }
                  unint64_t v116 = v54;
                  *(void *)&v30[v145] = v54;
                }

                unint64_t v16 = v130;
                if (!v52[10])
                {
                  unint64_t v55 = v146;
                  if (v52[18])
                  {
                    unint64_t v56 = 0LL;
                    unint64_t v57 = &v136[v146 + v15];
                    do
                    {
                      if ((objc_opt_respondsToSelector(v21, v18) & 1) != 0) {
                        unint64_t v58 = [v21 getVertexBufferAddressAtIndex:v56];
                      }
                      else {
                        unint64_t v58 = [v21 getVertexBufferAtIndex:v56];
                      }
                      if (v58 == (id)-1LL) {
                        unint64_t v59 = 0LL;
                      }
                      else {
                        unint64_t v59 = v58;
                      }
                      if (v58 == (id)-1LL && v115) {
                        unint64_t v59 = *(id *)&v115[8 * v56];
                      }
                      *(void *)&v57[8 * v56++] = v59;
                    }

                    while (v56 < v52[18]);
                  }

                  unint64_t v60 = v147;
                  if (v52[12])
                  {
                    unint64_t v61 = 0LL;
                    unint64_t v62 = &v136[v147 + v15];
                    do
                    {
                      if ((objc_opt_respondsToSelector(v21, "getFragmentBufferAddressAtIndex:") & 1) != 0) {
                        unint64_t v63 = [v21 getFragmentBufferAddressAtIndex:v61];
                      }
                      else {
                        unint64_t v63 = [v21 getFragmentBufferAtIndex:v61];
                      }
                      if (v63 == (id)-1LL) {
                        unint64_t v64 = 0LL;
                      }
                      else {
                        unint64_t v64 = v63;
                      }
                      if (v63 == (id)-1LL && v141) {
                        unint64_t v64 = *(id *)&v141[8 * v61];
                      }
                      *(void *)&v62[8 * v61++] = v64;
                    }

                    while (v61 < v52[12]);
                  }

                  unint64_t v65 = v148;
                  if (v52[16])
                  {
                    unint64_t v66 = 0LL;
                    unint64_t v67 = &v136[v148 + v15];
                    do
                    {
                      if ((objc_opt_respondsToSelector(v21, "getObjectBufferAddressAtIndex:") & 1) != 0)
                      {
                        unint64_t v68 = [v21 getObjectBufferAddressAtIndex:v66];
                        if (v68 == (id)-1LL) {
                          int v69 = 0LL;
                        }
                        else {
                          int v69 = v68;
                        }
                        if (v68 == (id)-1LL && context) {
                          int v69 = *(id *)&context[8 * v66];
                        }
                      }

                      else
                      {
                        if (GTMTLDecodeIndirectRenderCommandBuffer_onceToken != -1) {
                          dispatch_once(&GTMTLDecodeIndirectRenderCommandBuffer_onceToken, &__block_literal_global_873);
                        }
                        int v69 = 0LL;
                      }

                      *(void *)&v67[8 * v66++] = v69;
                    }

                    while (v66 < v52[16]);
                  }

                  unint64_t v30 = v132;
                  unint64_t v115 = &v132[v55];
                  unint64_t v141 = &v132[v60];
                  context = &v132[v65];
                  int v70 = &v132[v149];
                  if (v52[15])
                  {
                    BOOL v71 = 0LL;
                    uint64_t v72 = &v136[v149 + v15];
                    do
                    {
                      if ((objc_opt_respondsToSelector(v21, "getMeshBufferAddressAtIndex:") & 1) != 0)
                      {
                        char v73 = [v21 getMeshBufferAddressAtIndex:v71];
                        if (v73 == (id)-1LL) {
                          id v74 = 0LL;
                        }
                        else {
                          id v74 = v73;
                        }
                        if (v73 == (id)-1LL && v130) {
                          id v74 = *(id *)&v130[8 * v71];
                        }
                      }

                      else
                      {
                        if (GTMTLDecodeIndirectRenderCommandBuffer_onceToken_33 != -1) {
                          dispatch_once( &GTMTLDecodeIndirectRenderCommandBuffer_onceToken_33,  &__block_literal_global_35);
                        }
                        id v74 = 0LL;
                      }

                      *(void *)&v72[8 * v71++] = v74;
                    }

                    while (v71 < v52[15]);
                    unint64_t v16 = v70;
                    unint64_t v30 = v132;
                  }

                  else
                  {
                    unint64_t v16 = &v132[v149];
                  }
                }

                if (v52[17])
                {
                  unint64_t v75 = 0LL;
                  unint64_t v76 = &v136[v151 + v15];
                  do
                  {
                    *(void *)&v76[8 * v75] = [v21 getObjectThreadgroupMemoryLengthAtIndex:v75];
                    ++v75;
                  }

                  while (v75 < v52[17]);
                }

                if (v52[21])
                {
                  unint64_t v77 = v154;
                  *(void *)&v30[v77] = [v21 hasBarrier];
                }

                uint64_t v14 = v118;
                unint64_t v20 = v128;
                break;
            }
          }

          else
          {
            unint64_t v18 = v19;
          }

          objc_autoreleasePoolPop(v20);
          __int128 v17 = v134 + 1;
          v15 += v14;
        }

        while ((id)(v134 + 1) != v122);
      }

      unint64_t v78 = [v124 copy];

      unint64_t v79 = v126;
    }

    uint64_t v5 = v113;
    unsigned __int8 v4 = v114;
    double v6 = &CATransform3DIdentity_ptr;
    uint64_t v1 = v111;
    if (v78)
    {
      unint64_t v108 = v78;
      unint64_t v12 = v108;
LABEL_150:

      goto LABEL_151;
    }

          unint64_t v101 = __p;
          unint64_t v102 = *(std::string ***)(__p + 8 * k);
          if (v102)
          {
            v83->__r_.__value_.__r.__words[0] = (std::string::size_type)*v102;
            goto LABEL_154;
          }

          v83->__r_.__value_.__r.__words[0] = v323;
          *(void *)&id v323 = v83;
          *(void *)(v101 + 8 * k) = &v323;
          if (v83->__r_.__value_.__r.__words[0])
          {
            unint64_t v103 = *(void *)(v83->__r_.__value_.__r.__words[0] + 8);
            if ((v80 & (v80 - 1)) != 0)
            {
              if (v103 >= v80) {
                v103 %= v80;
              }
            }

            else
            {
              v103 &= v80 - 1;
            }

            unint64_t v102 = (std::string **)(__p + 8 * v103);
LABEL_154:
            void *v102 = v83;
          }

          ++*((void *)&v323 + 1);
LABEL_156:
          std::string::assign(v83 + 1, v107);
        }
      }

      else
      {
        if ((SBYTE7(v352) & 0x80u) == 0) {
          unint64_t v65 = &v351;
        }
        else {
          unint64_t v65 = (__int128 *)v351;
        }
        if ((SBYTE7(v352) & 0x80u) == 0) {
          unint64_t v66 = BYTE7(v352);
        }
        else {
          unint64_t v66 = *((void *)&v351 + 1);
        }
        unint64_t v67 = -[NSString initWithBytes:length:encoding:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithBytes:length:encoding:",  v65,  v66,  +[NSString defaultCStringEncoding](&OBJC_CLASS___NSString, "defaultCStringEncoding"));
        unint64_t v68 = GTShaderDebuggerMDSerializerError(1u, v67);
        __int128 v278 = (id)objc_claimAutoreleasedReturnValue(v68);
      }

      unint64_t v104 = v346[0];
      v346[0] = 0LL;
      if (v104)
      {
        llvm::Module::~Module(v104);
        operator delete(v105);
      }

      unint64_t v106 = v358[0].__r_.__value_.__r.__words[0];
      v358[0].__r_.__value_.__r.__words[0] = 0LL;
      if (v106) {
        (*(void (**)(std::string::size_type))(*(void *)v106 + 8LL))(v106);
      }

      if (!v59)
      {
        id v180 = 0LL;
        v262 = 0LL;
        goto LABEL_460;
      }

      ++v57;
      unint64_t v55 = v285;
      if (v57 == v289) {
        goto LABEL_178;
      }
    }
  }

  __int128 v278 = 0LL;
LABEL_178:
  v315 = 0LL;
  uint64_t v316 = 0LL;
  v314 = &v315;
  uint64_t v317 = 0u;
  v318 = 0u;
  v319 = 1065353216;
  id v320 = 0LL;
  uint64_t v310 = 0u;
  uint64_t v311 = 0u;
  v312 = 0u;
  id v313 = 0u;
  uint64_t v111 = v276;
  unint64_t v112 = [v111 countByEnumeratingWithState:&v310 objects:v346 count:16];
  if (v112)
  {
    unint64_t v113 = *(void *)v311;
    do
    {
      for (uint64_t n = 0LL; n != v112; uint64_t n = (char *)n + 1)
      {
        if (*(void *)v311 != v113) {
          objc_enumerationMutation(v111);
        }
        unint64_t v115 = *(void **)(*((void *)&v310 + 1) + 8LL * (void)n);
        unint64_t v116 = (void *)objc_claimAutoreleasedReturnValue([v111 objectForKeyedSubscript:v115]);
        std::string::basic_string[abi:nn180100]<0>( v358, (char *)[v115 UTF8String]);
        int64_t v117 = v116;
        std::string::basic_string[abi:nn180100]<0>(&v338, (char *)[v117 UTF8String]);
        ShaderDebugger::Metadata::MDSerializer::addReferencedSourceFile( (uint64_t)&v314,  v358,  (const std::string *)&v338);
        if (SBYTE7(v339) < 0) {
          operator delete((void *)v338);
        }
      }

      unint64_t v112 = [v111 countByEnumeratingWithState:&v310 objects:v346 count:16];
    }

    while (v112);
  }

  std::__tree<std::__value_type<ShaderDebugger::Metadata::MDBase::MetadataType,ShaderDebugger::Metadata::MDSerializer::MetadataTypeContainer>,std::__map_value_compare<ShaderDebugger::Metadata::MDBase::MetadataType,std::__value_type<ShaderDebugger::Metadata::MDBase::MetadataType,ShaderDebugger::Metadata::MDSerializer::MetadataTypeContainer>,std::less<ShaderDebugger::Metadata::MDBase::MetadataType>,true>,std::allocator<std::__value_type<ShaderDebugger::Metadata::MDBase::MetadataType,ShaderDebugger::Metadata::MDSerializer::MetadataTypeContainer>>>::destroy(v315);
  v315 = 0LL;
  uint64_t v316 = 0LL;
  v314 = &v315;
  uint64_t v118 = v358;
  std::string::basic_string[abi:nn180100]<0>(v358, "tracepoint_thread_begin");
  unint64_t v119 = operator new(0x20uLL);
  *unint64_t v119 = off_58E988;
  v119[1] = ShaderDebugger::Metadata::MDSerializerLLVM3XXX::serializeThreadTracePoint;
  void v119[2] = 0LL;
  v119[3] = &v314;
  uint64_t v359 = v119;
  std::string::basic_string[abi:nn180100]<0>(v360, "tracepoint_function_begin");
  unint64_t v120 = operator new(0x20uLL);
  *unint64_t v120 = off_58E988;
  v120[1] = ShaderDebugger::Metadata::MDSerializerLLVM3XXX::serializeFunctionBeginTracePoint;
  v120[2] = 0LL;
  v120[3] = &v314;
  v363[1] = v120;
  std::string::basic_string[abi:nn180100]<0>(v364, "tracepoint_function_end");
  unint64_t v121 = operator new(0x20uLL);
  *unint64_t v121 = off_58E988;
  v121[1] = ShaderDebugger::Metadata::MDSerializerLLVM3XXX::serializeFunctionEndTracePoint;
  v121[2] = 0LL;
  v121[3] = &v314;
  id v365 = v121;
  std::string::basic_string[abi:nn180100]<0>(&v366, "tracepoint_call");
  uint64_t v122 = operator new(0x20uLL);
  *uint64_t v122 = off_58E988;
  v122[1] = ShaderDebugger::Metadata::MDSerializerLLVM3XXX::serializeFunctionCallTracePoint;
  v122[2] = 0LL;
  v122[3] = &v314;
  v367[5] = v122;
  std::string::basic_string[abi:nn180100]<0>(&v368, "tracepoint_variable");
  uint64_t v123 = operator new(0x20uLL);
  *uint64_t v123 = off_58E988;
  v123[1] = ShaderDebugger::Metadata::MDSerializerLLVM3XXX::serializeVariableTracePoint;
  void v123[2] = 0LL;
  v123[3] = &v314;
  v371[2] = v123;
  std::string::basic_string[abi:nn180100]<0>(v372, "tracepoint_data");
  double v124 = operator new(0x20uLL);
  *double v124 = off_58E988;
  v124[1] = ShaderDebugger::Metadata::MDSerializerLLVM3XXX::serializeDataTracePoint;
  void v124[2] = 0LL;
  v124[3] = &v314;
  v374 = (uint64_t)v124;
  std::string::basic_string[abi:nn180100]<0>(v375, "tracepoint_data_value");
  uint64_t v125 = operator new(0x20uLL);
  *uint64_t v125 = off_58E988;
  v125[1] = ShaderDebugger::Metadata::MDSerializerLLVM3XXX::serializeDataValueTracePoint;
  void v125[2] = 0LL;
  v125[3] = &v314;
  v375[6] = v125;
  std::string::basic_string[abi:nn180100]<0>(&v376, "tracepoint_loop_begin_for");
  int64_t v126 = operator new(0x28uLL);
  *int64_t v126 = &off_58E9D0;
  v126[1] = ShaderDebugger::Metadata::MDSerializerLLVM3XXX::serializeWaypointTracePoint;
  void v126[2] = 0LL;
  v126[3] = &v314;
  v126[4] = 0LL;
  v381[1] = v126;
  std::string::basic_string[abi:nn180100]<0>(v382, "tracepoint_loop_begin_while");
  unint64_t v127 = operator new(0x28uLL);
  *unint64_t v127 = &off_58E9D0;
  v127[1] = ShaderDebugger::Metadata::MDSerializerLLVM3XXX::serializeWaypointTracePoint;
  v127[2] = 0LL;
  v127[3] = &v314;
  v127[4] = 1LL;
  v382[6] = v127;
  std::string::basic_string[abi:nn180100]<0>(v383, "tracepoint_loop_begin_do");
  unint64_t v128 = operator new(0x28uLL);
  *unint64_t v128 = &off_58E9D0;
  v128[1] = ShaderDebugger::Metadata::MDSerializerLLVM3XXX::serializeWaypointTracePoint;
  v128[2] = 0LL;
  v128[3] = &v314;
  v128[4] = 2LL;
  v383[6] = v128;
  std::string::basic_string[abi:nn180100]<0>(v384, "tracepoint_loop_init_begin");
  unint64_t v129 = operator new(0x28uLL);
  uint64_t *v129 = &off_58E9D0;
  v129[1] = ShaderDebugger::Metadata::MDSerializerLLVM3XXX::serializeWaypointTracePoint;
  v129[2] = 0LL;
  v129[3] = &v314;
  v129[4] = 3LL;
  v384[6] = v129;
  std::string::basic_string[abi:nn180100]<0>(v385, "tracepoint_loop_init_end");
  uint64_t v130 = operator new(0x28uLL);
  void *v130 = &off_58E9D0;
  v130[1] = ShaderDebugger::Metadata::MDSerializerLLVM3XXX::serializeWaypointTracePoint;
  v130[2] = 0LL;
  v130[3] = &v314;
  v130[4] = 4LL;
  v385[6] = v130;
  std::string::basic_string[abi:nn180100]<0>(v386, "tracepoint_loop_cond_begin");
  unint64_t v131 = operator new(0x28uLL);
  *unint64_t v131 = &off_58E9D0;
  v131[1] = ShaderDebugger::Metadata::MDSerializerLLVM3XXX::serializeWaypointTracePoint;
  v131[2] = 0LL;
  v131[3] = &v314;
  v131[4] = 5LL;
  v386[6] = v131;
  std::string::basic_string[abi:nn180100]<0>(v387, "tracepoint_loop_cond_end");
  unint64_t v132 = operator new(0x28uLL);
  *unint64_t v132 = &off_58E9D0;
  v132[1] = ShaderDebugger::Metadata::MDSerializerLLVM3XXX::serializeWaypointTracePoint;
  v132[2] = 0LL;
  v132[3] = &v314;
  v132[4] = 6LL;
  v387[6] = v132;
  std::string::basic_string[abi:nn180100]<0>(v388, "tracepoint_loop_inc_begin");
  id v133 = operator new(0x28uLL);
  *id v133 = &off_58E9D0;
  v133[1] = ShaderDebugger::Metadata::MDSerializerLLVM3XXX::serializeWaypointTracePoint;
  v133[2] = 0LL;
  v133[3] = &v314;
  v133[4] = 7LL;
  v388[6] = v133;
  std::string::basic_string[abi:nn180100]<0>(v389, "tracepoint_loop_inc_end");
  unint64_t v134 = operator new(0x28uLL);
  *unint64_t v134 = &off_58E9D0;
  v134[1] = ShaderDebugger::Metadata::MDSerializerLLVM3XXX::serializeWaypointTracePoint;
  v134[2] = 0LL;
  v134[3] = &v314;
  v134[4] = 8LL;
  v389[6] = v134;
  std::string::basic_string[abi:nn180100]<0>(v390, "tracepoint_loop_body_begin");
  unint64_t v135 = operator new(0x28uLL);
  *unint64_t v135 = &off_58E9D0;
  v135[1] = ShaderDebugger::Metadata::MDSerializerLLVM3XXX::serializeWaypointTracePoint;
  v135[2] = 0LL;
  v135[3] = &v314;
  v135[4] = 9LL;
  v390[6] = v135;
  std::string::basic_string[abi:nn180100]<0>(v391, "tracepoint_loop_body_end");
  unint64_t v136 = operator new(0x28uLL);
  *unint64_t v136 = &off_58E9D0;
  v136[1] = ShaderDebugger::Metadata::MDSerializerLLVM3XXX::serializeWaypointTracePoint;
  v136[2] = 0LL;
  v136[3] = &v314;
  v136[4] = 10LL;
  v391[6] = v136;
  std::string::basic_string[abi:nn180100]<0>(v392, "tracepoint_loop_end");
  id v137 = operator new(0x28uLL);
  *id v137 = &off_58E9D0;
  v137[1] = ShaderDebugger::Metadata::MDSerializerLLVM3XXX::serializeWaypointTracePoint;
  v137[2] = 0LL;
  v137[3] = &v314;
  v137[4] = 11LL;
  v392[6] = v137;
  std::string::basic_string[abi:nn180100]<0>(v393, "tracepoint_thread_exit");
  unint64_t v138 = operator new(0x28uLL);
  unint64_t v139 = 0LL;
  CFStringRef v138 = &off_58E9D0;
  v138[1] = ShaderDebugger::Metadata::MDSerializerLLVM3XXX::serializeWaypointTracePoint;
  v138[2] = 0LL;
  v138[3] = &v314;
  v138[4] = 12LL;
  v393[6] = v138;
  id v338 = 0u;
  id v339 = 0u;
  v340 = 1.0;
  do
  {
    unint64_t v140 = (char *)v358 + 56 * v139;
    unint64_t v141 = v140[23];
    unint64_t v142 = *(const std::string::value_type **)v140;
    unint64_t v143 = *((void *)v140 + 1);
    if (v141 >= 0) {
      unint64_t v144 = (uint64_t *)((char *)v358 + 56 * v139);
    }
    else {
      unint64_t v144 = *(uint64_t **)v140;
    }
    if (v141 >= 0) {
      unsigned int v145 = v140[23];
    }
    else {
      unsigned int v145 = *((void *)v140 + 1);
    }
    unint64_t v146 = std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:nn180100](v144, v145);
    uint64_t v147 = v146;
    uint64_t v148 = *((void *)&v338 + 1);
    if (*((void *)&v338 + 1))
    {
      v149 = (uint8x8_t)vcnt_s8(*(int8x8_t *)((char *)&v338 + 8));
      v149.i16[0] = vaddlv_u8(v149);
      uint64_t v150 = v149.u32[0];
      if (v149.u32[0] > 1uLL)
      {
        uint64_t v118 = (std::string *)v146;
        if (v146 >= *((void *)&v338 + 1)) {
          uint64_t v118 = (std::string *)(v146 % *((void *)&v338 + 1));
        }
      }

      else
      {
        uint64_t v118 = (std::string *)((*((void *)&v338 + 1) - 1LL) & v146);
      }

      unint64_t v151 = *(unsigned __int8 ***)(v338 + 8LL * (void)v118);
      if (v151)
      {
        for (iuint64_t i = *v151; ii; iuint64_t i = *(unsigned __int8 **)ii)
        {
          __int128 v153 = *((void *)ii + 1);
          if (v153 == v147)
          {
          }

          else
          {
            if (v150 > 1)
            {
              if (v153 >= v148) {
                v153 %= v148;
              }
            }

            else
            {
              v153 &= v148 - 1;
            }

            if ((std::string *)v153 != v118) {
              break;
            }
          }
        }
      }
    }

    __int128 v154 = operator new(0x48uLL);
    *__int128 v154 = 0LL;
    v154[1] = v147;
    uint64_t v155 = (std::string *)(v154 + 2);
    if (v141 < 0)
    {
      std::string::__init_copy_ctor_external(v155, v142, v143);
    }

    else
    {
      *(_OWORD *)&v155->__r_.__value_.__l.__data_ = *(_OWORD *)v140;
      v154[4] = *((void *)v140 + 2);
    }

    int v156 = (char *)v358 + 56 * v139;
    uint64_t v157 = (char *)*((void *)v156 + 6);
    if (v157)
    {
      unint64_t v158 = v156 + 24;
      if (v157 == v158)
      {
        v154[8] = v154 + 5;
        (*(void (**)(char *))(*(void *)v158 + 24LL))(v158);
      }

      else
      {
        v154[8] = (*(uint64_t (**)(char *))(*(void *)v157 + 16LL))(v157);
      }
    }

    else
    {
      v154[8] = 0LL;
    }

    id v159 = (float)(unint64_t)(*((void *)&v339 + 1) + 1LL);
    if (!v148 || (float)(v340 * (float)v148) < v159)
    {
      __int128 v160 = (v148 & (v148 - 1)) != 0;
      if (v148 < 3) {
        __int128 v160 = 1LL;
      }
      __int128 v161 = v160 | (2 * v148);
      __int128 v162 = vcvtps_u32_f32(v159 / v340);
      if (v161 <= v162) {
        __int128 v163 = (int8x8_t)v162;
      }
      else {
        __int128 v163 = (int8x8_t)v161;
      }
      if (*(void *)&v163 == 1LL)
      {
        __int128 v163 = (int8x8_t)2LL;
      }

      else if ((*(void *)&v163 & (*(void *)&v163 - 1LL)) != 0)
      {
        __int128 v163 = (int8x8_t)std::__next_prime(*(void *)&v163);
      }

      uint64_t v148 = *((void *)&v338 + 1);
      if (*(void *)&v163 > *((void *)&v338 + 1)) {
        goto LABEL_232;
      }
      if (*(void *)&v163 < *((void *)&v338 + 1))
      {
        __int128 v170 = vcvtps_u32_f32((float)*((unint64_t *)&v339 + 1) / v340);
        if (*((void *)&v338 + 1) < 3uLL
          || (__int128 v171 = (uint8x8_t)vcnt_s8(*(int8x8_t *)((char *)&v338 + 8)),
              v171.i16[0] = vaddlv_u8(v171),
              v171.u32[0] > 1uLL))
        {
          __int128 v170 = std::__next_prime(v170);
        }

        else
        {
          __int128 v172 = 1LL << -(char)__clz(v170 - 1);
          if (v170 >= 2) {
            __int128 v170 = v172;
          }
        }

        if (*(void *)&v163 <= v170) {
          __int128 v163 = (int8x8_t)v170;
        }
        if (*(void *)&v163 >= v148)
        {
          uint64_t v148 = *((void *)&v338 + 1);
        }

        else
        {
          if (v163)
          {
LABEL_232:
            if (*(void *)&v163 >> 61) {
              std::__throw_bad_array_new_length[abi:nn180100]();
            }
            id v164 = operator new(8LL * *(void *)&v163);
            uint64_t v165 = (void *)v338;
            *(void *)&id v338 = v164;
            if (v165) {
              operator delete(v165);
            }
            id v166 = 0LL;
            *((int8x8_t *)&v338 + 1) = v163;
            do
              *(void *)(v338 + 8 * v166++) = 0LL;
            while (*(void *)&v163 != v166);
            id v167 = (void **)v339;
            if ((void)v339)
            {
              id v168 = *(void *)(v339 + 8);
              id v169 = (uint8x8_t)vcnt_s8(v163);
              v169.i16[0] = vaddlv_u8(v169);
              if (v169.u32[0] > 1uLL)
              {
                if (v168 >= *(void *)&v163) {
                  v168 %= *(void *)&v163;
                }
              }

              else
              {
                v168 &= *(void *)&v163 - 1LL;
              }

              *(void *)(v338 + 8 * v16_Block_object_dispose(va, 8) = &v339;
              for (juint64_t j = *v167; jj; v168 = v174)
              {
                stat v174 = jj[1];
                if (v169.u32[0] > 1uLL)
                {
                  if (v174 >= *(void *)&v163) {
                    v174 %= *(void *)&v163;
                  }
                }

                else
                {
                  v174 &= *(void *)&v163 - 1LL;
                }

                if (v174 != v168)
                {
                  if (!*(void *)(v338 + 8 * v174))
                  {
                    *(void *)(v338 + 8 * v174) = v167;
                    goto LABEL_257;
                  }

                  *id v167 = (void *)*jj;
                  *juint64_t j = **(void **)(v338 + 8 * v174);
                  **(void **)(v338 + 8 * v174) = jj;
                  juint64_t j = v167;
                }

                stat v174 = v168;
LABEL_257:
                id v167 = (void **)jj;
                juint64_t j = (void *)*jj;
              }
            }

            uint64_t v148 = (unint64_t)v163;
            goto LABEL_261;
          }

          uint64_t v178 = (void *)v338;
          *(void *)&id v338 = 0LL;
          if (v178) {
            operator delete(v178);
          }
          uint64_t v148 = 0LL;
          *((void *)&v338 + 1) = 0LL;
        }
      }

              objc_msgSend( v20,  "setMaxFragmentCallStackDepth:",  (char *)objc_msgSend(v20, "maxFragmentCallStackDepth") + 1);
              goto LABEL_150;
            }

            if (v45 != (_BYTE *)&dword_0 + 2)
            {
              __int128 v154 = (void *)(v42 + 368);
              if (v101)
              {
                __int128 v154 = (void *)(v42 + 360);
                unint64_t v101 = 1;
              }

              else
              {
                unint64_t v101 = 0;
              }

          unint64_t v134 = &stru_591D98;
LABEL_147:
          id v137 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"Failed to recreate render pipeline%@",  v134));
          if (a3)
          {
            unint64_t v139 = GTUpdateShaderMakeError(4u, v137, 0LL, v70);
            unint64_t v82 = 0LL;
            unint64_t v138 = 0;
            *a3 = (id)objc_claimAutoreleasedReturnValue(v139);
          }

          else
          {
            unint64_t v82 = 0LL;
            unint64_t v138 = 0;
          }

unint64_t *std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::tuple<unsigned long long,unsigned long long,unsigned long long> *>( unint64_t *result, unint64_t *a2, unint64_t *a3)
{
  unint64_t v3 = *a2;
  unint64_t v4 = *result;
  if (*a2 < *result || v4 >= v3 && ((unint64_t v29 = a2[1], v30 = result[1], v29 < v30) || v30 >= v29 && a2[2] < result[2]))
  {
    unint64_t v5 = *a3;
    if (*a3 < v3 || v3 >= v5 && ((v19 = a3[1], unint64_t v20 = a2[1], v19 < v20) || v20 >= v19 && a3[2] < a2[2]))
    {
      unsigned __int8 *result = v5;
      *a3 = v4;
      unint64_t v6 = result[1];
      result[1] = a3[1];
      a3[1] = v6;
      double v7 = (uint64_t *)(result + 2);
    }

    else
    {
      unsigned __int8 *result = v3;
      *a2 = v4;
      unint64_t v21 = result[1];
      result[1] = a2[1];
      a2[1] = v21;
      double v7 = (uint64_t *)(a2 + 2);
      unint64_t v22 = result[2];
      result[2] = a2[2];
      a2[2] = v22;
      unint64_t v23 = *a3;
      unint64_t v24 = *a2;
      if (*a3 >= *a2)
      {
        if (v24 < v23) {
          return result;
        }
        unint64_t v25 = a3[1];
        unint64_t v26 = a2[1];
        if (v25 >= v26 && (v26 < v25 || a3[2] >= v22)) {
          return result;
        }
      }

      *a2 = v23;
      *a3 = v24;
      unint64_t v27 = a2[1];
      a2[1] = a3[1];
      a3[1] = v27;
    }

    unint64_t v13 = (uint64_t *)(a3 + 2);
    goto LABEL_27;
  }

  unint64_t v8 = *a3;
  if (*a3 < v3 || v3 >= v8 && ((v9 = a3[1], unint64_t v10 = a2[1], v9 < v10) || v10 >= v9 && a3[2] < a2[2]))
  {
    *a2 = v8;
    *a3 = v3;
    unint64_t v11 = a2[1];
    a2[1] = a3[1];
    a3[1] = v11;
    unint64_t v13 = (uint64_t *)(a2 + 2);
    unint64_t v12 = a2[2];
    a2[2] = a3[2];
    a3[2] = v12;
    unint64_t v14 = *a2;
    unint64_t v15 = *result;
    if (*a2 < *result || v15 >= v14 && ((unint64_t v16 = a2[1], v17 = result[1], v16 < v17) || v17 >= v16 && *v13 < result[2]))
    {
      unsigned __int8 *result = v14;
      *a2 = v15;
      unint64_t v18 = result[1];
      result[1] = a2[1];
      a2[1] = v18;
      double v7 = (uint64_t *)(result + 2);
LABEL_27:
      uint64_t v28 = *v7;
      *double v7 = *v13;
      *unint64_t v13 = v28;
    }
  }

  return result;
}

unint64_t *std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::tuple<unsigned long long,unsigned long long,unsigned long long> *>( unint64_t *a1, unint64_t *a2, unint64_t *a3, unint64_t *a4)
{
  __n128 result = std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::tuple<unsigned long long,unsigned long long,unsigned long long> *>( a1,  a2,  a3);
  unint64_t v9 = *a4;
  unint64_t v10 = *a3;
  if (*a4 < *a3 || v10 >= v9 && ((v11 = a4[1], unint64_t v12 = a3[1], v11 < v12) || v12 >= v11 && a4[2] < a3[2]))
  {
    *a3 = v9;
    *a4 = v10;
    unint64_t v13 = a3[1];
    a3[1] = a4[1];
    a4[1] = v13;
    unint64_t v14 = a3[2];
    a3[2] = a4[2];
    a4[2] = v14;
    unint64_t v15 = *a3;
    unint64_t v16 = *a2;
    if (*a3 < *a2 || v16 >= v15 && ((unint64_t v17 = a3[1], v18 = a2[1], v17 < v18) || v18 >= v17 && a3[2] < a2[2]))
    {
      *a2 = v15;
      *a3 = v16;
      unint64_t v19 = a2[1];
      a2[1] = a3[1];
      a3[1] = v19;
      unint64_t v20 = a2[2];
      a2[2] = a3[2];
      a3[2] = v20;
      unint64_t v21 = *a2;
      unint64_t v22 = *a1;
      if (*a2 < *a1 || v22 >= v21 && ((unint64_t v23 = a2[1], v24 = a1[1], v23 < v24) || v24 >= v23 && a2[2] < a1[2]))
      {
        *a1 = v21;
        *a2 = v22;
        unint64_t v25 = a1[1];
        a1[1] = a2[1];
        a2[1] = v25;
        unint64_t v26 = a1[2];
        a1[2] = a2[2];
        a2[2] = v26;
      }
    }
  }

  return result;
}

unint64_t *std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::tuple<unsigned long long,unsigned long long,unsigned long long> *>( unint64_t *a1, unint64_t *a2, unint64_t *a3, unint64_t *a4, unint64_t *a5)
{
  __n128 result = std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::tuple<unsigned long long,unsigned long long,unsigned long long> *>( a1,  a2,  a3,  a4);
  unint64_t v11 = *a5;
  unint64_t v12 = *a4;
  if (*a5 < *a4 || v12 >= v11 && ((v33 = a5[1], unint64_t v34 = a4[1], v33 < v34) || v34 >= v33 && a5[2] < a4[2]))
  {
    *a4 = v11;
    *a5 = v12;
    unint64_t v13 = a4[1];
    a4[1] = a5[1];
    a5[1] = v13;
    unint64_t v14 = a4[2];
    a4[2] = a5[2];
    a5[2] = v14;
    unint64_t v15 = *a4;
    unint64_t v16 = *a3;
    if (*a4 < *a3 || v16 >= v15 && ((unint64_t v17 = a4[1], v18 = a3[1], v17 < v18) || v18 >= v17 && a4[2] < a3[2]))
    {
      *a3 = v15;
      *a4 = v16;
      unint64_t v19 = a3[1];
      a3[1] = a4[1];
      a4[1] = v19;
      unint64_t v20 = a3[2];
      a3[2] = a4[2];
      a4[2] = v20;
      unint64_t v21 = *a3;
      unint64_t v22 = *a2;
      if (*a3 < *a2 || v22 >= v21 && ((unint64_t v23 = a3[1], v24 = a2[1], v23 < v24) || v24 >= v23 && a3[2] < a2[2]))
      {
        *a2 = v21;
        *a3 = v22;
        unint64_t v25 = a2[1];
        a2[1] = a3[1];
        a3[1] = v25;
        unint64_t v26 = a2[2];
        a2[2] = a3[2];
        a3[2] = v26;
        unint64_t v27 = *a2;
        unint64_t v28 = *a1;
        if (*a2 < *a1 || v28 >= v27 && ((unint64_t v29 = a2[1], v30 = a1[1], v29 < v30) || v30 >= v29 && a2[2] < a1[2]))
        {
          *a1 = v27;
          *a2 = v28;
          unint64_t v31 = a1[1];
          a1[1] = a2[1];
          a2[1] = v31;
          unint64_t v32 = a1[2];
          a1[2] = a2[2];
          a2[2] = v32;
        }
      }
    }
  }

  return result;
}

BOOL std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::tuple<unsigned long long,unsigned long long,unsigned long long> *>( unint64_t *a1, unint64_t *a2)
{
  unint64_t v4 = 0xAAAAAAAAAAAAAAABLL * (a2 - a1);
  BOOL result = 1LL;
  switch(v4)
  {
    case 0uLL:
    case 1uLL:
      return result;
    case 2uLL:
      unint64_t v6 = *(a2 - 3);
      unint64_t v7 = *a1;
      if (v6 < *a1 || v7 >= v6 && ((unint64_t v26 = *(a2 - 2), v27 = a1[1], v26 < v27) || v27 >= v26 && *(a2 - 1) < a1[2]))
      {
        *a1 = v6;
        *(a2 - 3) = v7;
        unint64_t v8 = a1[1];
        a1[1] = *(a2 - 2);
        *(a2 - 2) = v8;
        unint64_t v9 = a1[2];
        a1[2] = *(a2 - 1);
        *(a2 - 1) = v9;
      }

      return result;
    case 3uLL:
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::tuple<unsigned long long,unsigned long long,unsigned long long> *>( a1,  a1 + 3,  a2 - 3);
      return 1LL;
    case 4uLL:
      std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::tuple<unsigned long long,unsigned long long,unsigned long long> *>( a1,  a1 + 3,  a1 + 6,  a2 - 3);
      return 1LL;
    case 5uLL:
      std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::tuple<unsigned long long,unsigned long long,unsigned long long> *>( a1,  a1 + 3,  a1 + 6,  a1 + 9,  a2 - 3);
      return 1LL;
    default:
      unint64_t v10 = a1 + 6;
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::tuple<unsigned long long,unsigned long long,unsigned long long> *>( a1,  a1 + 3,  a1 + 6);
      unint64_t v11 = a1 + 9;
      if (a1 + 9 == a2) {
        return 1LL;
      }
      uint64_t v12 = 0LL;
      int v13 = 0;
      break;
  }

  do
  {
    unint64_t v14 = *v11;
    unint64_t v15 = *v10;
    if (*v11 >= *v10)
    {
      if (v15 < v14) {
        goto LABEL_27;
      }
      unint64_t v16 = v11[1];
      unint64_t v25 = v10[1];
      if (v16 >= v25 && (v25 < v16 || v11[2] >= v10[2])) {
        goto LABEL_27;
      }
    }

    else
    {
      unint64_t v16 = v11[1];
    }

    unint64_t v17 = v11[2];
    unint64_t *v11 = v15;
    v11[1] = v10[1];
    v11[2] = v10[2];
    unint64_t v18 = a1;
    if (v10 == a1) {
      goto LABEL_26;
    }
    uint64_t v19 = v12;
    while (1)
    {
      unint64_t v20 = (char *)a1 + v19;
      unint64_t v21 = *(unint64_t *)((char *)a1 + v19 + 24);
      if (v14 < v21)
      {
        unint64_t v22 = *((void *)v20 + 4);
        goto LABEL_17;
      }

      if (v21 < v14) {
        goto LABEL_24;
      }
      unint64_t v22 = *(unint64_t *)((char *)a1 + v19 + 32);
      if (v16 >= v22)
      {
        if (v22 < v16)
        {
LABEL_24:
          unint64_t v18 = v10;
          goto LABEL_26;
        }
      }

LABEL_17:
      v10 -= 3;
      *((void *)v20 + 6) = v21;
      unint64_t v23 = (char *)a1 + v19;
      uint64_t v24 = *(unint64_t *)((char *)a1 + v19 + 40);
      *((void *)v23 + 7) = v22;
      *((void *)v23 + _Block_object_dispose(va, 8) = v24;
      v19 -= 24LL;
      if (v19 == -48)
      {
        unint64_t v18 = a1;
        goto LABEL_26;
      }
    }

    unint64_t v18 = (unint64_t *)((char *)a1 + v19 + 48);
LABEL_26:
    unint64_t *v18 = v14;
    v18[1] = v16;
    v18[2] = v17;
    if (++v13 == 8) {
      return v11 + 3 == a2;
    }
LABEL_27:
    unint64_t v10 = v11;
    v12 += 24LL;
    v11 += 3;
  }

  while (v11 != a2);
  return 1LL;
}

    if (a6)
    {
      unint64_t v18 = +[NSError errorWithDomain:code:userInfo:]( &OBJC_CLASS___NSError,  "errorWithDomain:code:userInfo:",  NSPOSIXErrorDomain,  *__error(),  0LL);
      LOBYTE(v16) = 0;
      *a6 = v18;
    }

    else
    {
      LOBYTE(v16) = 0;
    }
  }

  return (char)v16;
}

  return v8;
}

  uint64_t v19 = (uint64_t *)*((void *)v15 + 2);
  if (v19)
  {
    unint64_t v20 = (double)a3 / (double)*((unint64_t *)v15 + 3);
    do
    {
      BOOL result = (double *)std::unordered_map<unsigned int,-[GTShaderProfilerHelper _calculateEffectiveGPUEncoderCostforData:andPerLimiterBatchCost:forShaderProfilerResult:]::TimeStats>::operator[]( *((void *)v4 + 1),  *((_DWORD *)v19 + 4));
      unint64_t v21 = &result[*((unsigned int *)v19 + 6)];
      v21[3] = v20 + v21[3];
      uint64_t v19 = (uint64_t *)*v19;
    }

    while (v19);
  }

  return result;
}

      v10 -= 4;
      *((_DWORD *)v20 + _Block_object_dispose(va, 8) = v21;
      uint64_t v24 = (char *)a1 + v19;
      *((_DWORD *)v24 + 9) = v22;
      *((void *)v24 + 5) = *(void *)((char *)a1 + v19 + 24);
      v19 -= 16LL;
      if (v19 == -32)
      {
        unint64_t v18 = a1;
        goto LABEL_20;
      }
    }

    unint64_t v18 = (int *)((char *)a1 + v19 + 32);
LABEL_20:
    unint64_t *v18 = v14;
    v18[1] = v15;
    v18[2] = v16;
    v18[3] = v17;
    if (++v13 != 8)
    {
LABEL_21:
      unint64_t v10 = v11;
      v12 += 16LL;
      v11 += 4;
      continue;
    }

    return v11 + 4 == (int *)a2;
  }

      unint64_t v26 = *(void *)(v22 + 8 * v23);
      if (v26 == v11)
      {
        *(_DWORD *)(v9 + 4 * v13) = v25;
        unint64_t v27 = 1.0;
        LODWORD(v20) = v25;
      }

      else
      {
        unint64_t v27 = 0.0;
        if (v25 > v20)
        {
          LODWORD(v20) = v25 - 1;
          *(_DWORD *)(v9 + 4 * v13) = v25 - 1;
          unint64_t v28 = *(void *)(v22 + 8LL * (v25 - 1));
          unint64_t v27 = (double)(v11 - v28) / (double)(unint64_t)(v26 - v28);
        }
      }

      unint64_t v29 = *(void **)(*(void *)a9 + 8 * v13);
      unint64_t v30 = (double *)operator new(0x20uLL);
      *(_DWORD *)unint64_t v30 = v20;
      v30[1] = 1.0 - v27;
      *((_DWORD *)v30 + 4) = v25;
      v30[3] = v27;
      unint64_t v31 = (unsigned int *)(v30 + 4);
      __p = v30;
      do
      {
        unint64_t v32 = *(unsigned int *)v30;
        unint64_t v33 = *v29 + 24LL * v32;
        unint64_t v35 = *(double **)v33;
        unint64_t v34 = *(unsigned int **)(v33 + 8);
        while (v35 != (double *)v34)
        {
          unint64_t v36 = *(unsigned int *)v35;
          if ((_DWORD)v36 == -1)
          {
LABEL_43:
            BOOL v44 = v35[1];
            unint64_t v45 = v30[1];
            unint64_t v46 = (double *)std::__hash_table<std::__hash_value_type<unsigned int,double>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,double>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,double>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,double>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>( (float *)(*(void *)a3 + 40 * v13),  v36,  v35);
            v46[3] = v46[3] + v44 * v45;
          }

          else
          {
            uint64_t v37 = (void *)(*(void *)a8 + 40 * v13);
            unint64_t v38 = (int8x8_t)v37[1];
            if (v38)
            {
              unint64_t v39 = (uint8x8_t)vcnt_s8(v38);
              v39.i16[0] = vaddlv_u8(v39);
              if (v39.u32[0] > 1uLL)
              {
                unint64_t v40 = *(unsigned int *)v35;
                if (*(void *)&v38 <= v36) {
                  unint64_t v40 = v36 % *(void *)&v38;
                }
              }

              else
              {
                unint64_t v40 = (v38.i32[0] - 1) & v36;
              }

              unint64_t v41 = *(uint64_t ***)(*v37 + 8 * v40);
              if (v41)
              {
                for (uint64_t j = *v41; j; uint64_t j = (uint64_t *)*j)
                {
                  unint64_t v43 = j[1];
                  if (v43 == v36)
                  {
                    if (*((_DWORD *)j + 4) == (_DWORD)v36) {
                      goto LABEL_43;
                    }
                  }

                  else
                  {
                    if (v39.u32[0] > 1uLL)
                    {
                      if (v43 >= *(void *)&v38) {
                        v43 %= *(void *)&v38;
                      }
                    }

                    else
                    {
                      v43 &= *(void *)&v38 - 1LL;
                    }

                    if (v43 != v40) {
                      break;
                    }
                  }
                }
              }
            }
          }

          v35 += 2;
        }

        v30 += 2;
      }

      while (v30 != (double *)v31);
      operator delete(__p);
      ++v13;
      unint64_t v9 = *(void *)a6;
      unint64_t v11 = a5;
    }

    while (v13 < (uint64_t)(*((void *)a6 + 1) - *(void *)a6) >> 2);
  }

  if (v12) {
    unint64_t v17 = v12;
  }
  else {
    unint64_t v17 = __big;
  }
  v25[0] = v14;
  v24[0] = NSLocalizedDescriptionKey;
  v24[1] = @"GTErrorKeyFile";
  unint64_t v18 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", v17));
  v25[1] = v18;
  v24[2] = @"GTErrorKeyFunction";
  uint64_t v19 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", a4));
  v25[2] = v19;
  v24[3] = @"GTErrorKeyLine";
  unint64_t v20 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", a5));
  v25[3] = v20;
  unint64_t v21 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v25,  v24,  4LL));
  NSid Error = MakeNSError(a1, v21);
  unint64_t v23 = (void *)objc_claimAutoreleasedReturnValue(NSError);

  GTMTLReplay_handleNSError(v23);
}

    unint64_t v15 = 256LL;
    goto LABEL_20;
  }

  unint64_t v15 = 1LL;
  if (v14 != 22 && v14 != 57) {
    goto LABEL_19;
  }
LABEL_20:
  unint64_t v17 = v16 & -v15;
  unint64_t v18 = *(void **)(a1 + 24);
  uint64_t v19 = a6;
  unint64_t v20 = a3;
  unint64_t v21 = (void *)objc_claimAutoreleasedReturnValue([v18 blitCommandEncoder]);
  unint64_t v22 = (void *)objc_claimAutoreleasedReturnValue([v20 heapBuffer]);
  unint64_t v23 = (char *)[v20 heapLocation];

  [v21 copyFromBuffer:v22 sourceOffset:&v23[a4] toBuffer:v19 destinationOffset:v17 size:a5];
  uint64_t v24 = apr_array_push(a8);
  unint64_t v25 = *(void *)(a2 + 8);
  unint64_t v26 = *(_DWORD *)(a2 + 32) + a4;
  CFStringRef v24 = v17;
  v24[1] = 22;
  *((void *)v24 + 1) = v25;
  v24[4] = v26;
  v24[5] = a5;
  return v17 + a5;
}

  int v13 = objc_alloc(&OBJC_CLASS___GTMTLReplayActivityLog);
  unint64_t v14 = -[GTMTLReplayActivityLog initWithLog:](v13, "initWithLog:", g_activityLog);
  if ((v9 & 1) == 0 && *(int *)(v6 + 12) >= 1)
  {
    unint64_t v15 = 0LL;
    do
    {
      unint64_t v16 = *(void *)(*(void *)(v6 + 24) + 8 * v15);
      unint64_t v17 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 8) rasterizationRateMapForKey:*(void *)(v16 + 8)]);
      MTLRasterizationRateMapDescriptor = MakeMTLRasterizationRateMapDescriptor(*(void *)(v16 + 48));
      uint64_t v19 = (void *)objc_claimAutoreleasedReturnValue(MTLRasterizationRateMapDescriptor);
      [v17 resetUsingDescriptor:v19];

      ++v15;
    }

    while (v15 < *(int *)(v6 + 12));
  }

  unint64_t v20 = *(void *)(*(void *)a1 + 8LL);
  unint64_t v43 = v42;
  entry = find_entry(v20, &v43, 8uLL, 0LL);
  unint64_t v22 = CommandBufferCommitIndex(*(void *)(*(void *)(*entry + 32LL) + 32LL));
  RestoreVisibleFunctionTablesForFunctionIndex((id *)a1, v22);
  unint64_t v23 = *(void *)(*(void *)a1 + 8LL);
  unint64_t v43 = v42;
  uint64_t v24 = find_entry(v23, &v43, 8uLL, 0LL);
  unint64_t v25 = CommandBufferCommitIndex(*(void *)(*(void *)(*v24 + 32LL) + 32LL));
  RestoreIntersectionFunctionTablesForFunctionIndex((id *)a1, v25);
  unint64_t v26 = find_entry(*(void *)(a1 + 22544), &v42, 8uLL, 0LL);
  if (*v26)
  {
    unint64_t v27 = *(void *)(*v26 + 32LL);
    if (v27) {
      v4 |= RestoreResourcesFromBuffer( (id *)a1,  *(void **)(a1 + 22536),  *(void *)(v27 + 24),  *(_DWORD *)(v27 + 12),  v14);
    }
  }

  unint64_t v28 = (unsigned int *)(a1 + 22512);
  do
    unint64_t v29 = __ldaxr(v28);
  while (__stlxr(v29 + 1, v28));
  unint64_t v30 = *(void *)(a1 + 22504);
  if (v29 >= *(_DWORD *)(v30 + 12)) {
    unint64_t v31 = 0LL;
  }
  else {
    unint64_t v31 = *(void *)(v30 + 24) + 16LL * v29;
  }
  while (v31)
  {
    unint64_t v32 = objc_autoreleasePoolPush();
    DoLoadJob((uint64_t **)a1, v31, v14, 0LL);
    do
      unint64_t v33 = __ldaxr(v28);
    while (__stlxr(v33 + 1, v28));
    unint64_t v34 = *(void *)(a1 + 22504);
    if (v33 >= *(_DWORD *)(v34 + 12)) {
      unint64_t v31 = 0LL;
    }
    else {
      unint64_t v31 = *(void *)(v34 + 24) + 16LL * v33;
    }
    objc_autoreleasePoolPop(v32);
  }

  dispatch_group_wait(*(dispatch_group_t *)(a1 + 22528), 0xFFFFFFFFFFFFFFFFLL);
  *(_DWORD *)(*(void *)(a1 + 22504) + 12LL) = 0;
  if (byte_5B9DE2) {
    sleep(byte_5B9DE2);
  }
  unint64_t v35 = *find_entry(*(void *)(*(void *)a1 + 144LL), &v42, 8uLL, 0LL);
  if (v35) {
    unint64_t v36 = *(void *)(v35 + 32);
  }
  else {
    unint64_t v36 = 0LL;
  }
  uint64_t v37 = v4 | DYMTLIndirectArgumentBufferManager_processCommandBuffer(a1, v36);
  [(id)g_activityLog leaveActivity];
  return v37;
}

  uint64_t v24 = **a1;
  unint64_t v25 = *(void *)(*(void *)(*find_entry(*(void *)(*a1[4] + 8), *a1, 8uLL, 0LL) + 32LL) + 8LL);
  unint64_t v26 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(a1[6][1] - *a1[6]) >> 3);
  unint64_t v27 = -1431655765 * ((a1[3][1] - *a1[3]) >> 4) - v11;
  std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long long>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long const&>,std::tuple<>>( (uint64_t)a1[2],  **a1,  *a1)[3] = v26;
  unint64_t v28 = a1[6];
  unint64_t v30 = (void *)*v28;
  unint64_t v29 = (void *)v28[1];
  unint64_t v31 = v11;
  unint64_t v32 = (uint64_t)((uint64_t)v29 - *v28) / 40;
  *(_DWORD *)a1[1] = v32;
  unint64_t v33 = v28[2];
  if ((unint64_t)v29 >= v33)
  {
    unint64_t v42 = v31;
    unint64_t v35 = v32 + 1;
    unint64_t v36 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v33 - (void)v30) >> 3);
    if (2 * v36 > v35) {
      unint64_t v35 = 2 * v36;
    }
    if (v36 >= 0x333333333333333LL) {
      uint64_t v37 = 0x666666666666666LL;
    }
    else {
      uint64_t v37 = v35;
    }
    if (v37)
    {
      if (v37 > 0x666666666666666LL) {
        std::__throw_bad_array_new_length[abi:nn180100]();
      }
      unint64_t v38 = (char *)operator new(40 * v37);
    }

    else
    {
      unint64_t v38 = 0LL;
    }

    unint64_t v39 = &v38[40 * v32];
    *(void *)unint64_t v39 = v24;
    *((void *)v39 + 1) = v25;
    *((void *)v39 + 2) = a2;
    *((_DWORD *)v39 + 6) = v26;
    *((_DWORD *)v39 + 7) = 0;
    *((_DWORD *)v39 + _Block_object_dispose(va, 8) = v42;
    *((_DWORD *)v39 + 9) = v27;
    unint64_t v34 = v39 + 40;
    if (v29 != v30)
    {
      do
      {
        unint64_t v40 = *(_OWORD *)(v29 - 5);
        unint64_t v41 = *(_OWORD *)(v29 - 3);
        *((void *)v39 - 1) = *(v29 - 1);
        *(_OWORD *)(v39 - 24) = v41;
        *(_OWORD *)(v39 - 40) = v40;
        v39 -= 40;
        v29 -= 5;
      }

      while (v29 != v30);
      unint64_t v29 = (void *)*v28;
    }

    void *v28 = (unint64_t)v39;
    v28[1] = (unint64_t)v34;
    void v28[2] = (unint64_t)&v38[40 * v37];
    if (v29) {
      operator delete(v29);
    }
  }

  else
  {
    void *v29 = v24;
    v29[1] = v25;
    v29[2] = a2;
    *((_DWORD *)v29 + 6) = v26;
    *((_DWORD *)v29 + 7) = 0;
    unint64_t v34 = v29 + 5;
    *((_DWORD *)v29 + _Block_object_dispose(va, 8) = v31;
    *((_DWORD *)v29 + 9) = v27;
  }

  v28[1] = (unint64_t)v34;
}

      v10 -= 4;
      *((void *)v20 + _Block_object_dispose(va, 8) = v21;
      uint64_t v24 = (char *)a1 + v19;
      *((void *)v24 + 9) = v22;
      *((_OWORD *)v24 + 5) = *(_OWORD *)((char *)a1 + v19 + 48);
      v19 -= 32LL;
      if (v19 == -64)
      {
        unint64_t v18 = a1;
        goto LABEL_20;
      }
    }

    unint64_t v18 = (uint64_t *)((char *)a1 + v19 + 64);
LABEL_20:
    unint64_t *v18 = v14;
    v18[1] = v15;
    v18[2] = v16;
    v18[3] = v17;
    if (++v13 != 8)
    {
LABEL_21:
      unint64_t v10 = v11;
      v12 += 32LL;
      v11 += 4;
      continue;
    }

    return v11 + 4 == (uint64_t *)a2;
  }

      v8 -= 24LL;
      *(void *)(v18 + 4_Block_object_dispose(va, 8) = v19;
      unint64_t v22 = a1 + v17;
      unint64_t v23 = *(_DWORD *)(a1 + v17 + 36);
      *(_DWORD *)(v22 + 56) = v20;
      *(_DWORD *)(v22 + 60) = v23;
      *(void *)(v22 + 64) = *(void *)(a1 + v17 + 40);
      v17 -= 24LL;
      if (v17 == -48)
      {
        unint64_t v16 = a1;
        goto LABEL_20;
      }
    }

    unint64_t v16 = a1 + v17 + 48;
LABEL_20:
    *(void *)unint64_t v16 = v12;
    *(_DWORD *)(v16 + _Block_object_dispose(va, 8) = v13;
    *(_DWORD *)(v16 + 12) = v14;
    *(void *)(v16 + 16) = v15;
    if (++v11 != 8)
    {
LABEL_21:
      unint64_t v8 = v9;
      v10 += 24LL;
      v9 += 24LL;
      if (v9 == a2) {
        return 1LL;
      }
      continue;
    }

    return v9 + 24 == a2;
  }

        unint64_t v23 = _GTMTLSMFunctionDisplayLabel(a2, *(void *)(*(void *)a1 + 8LL));
        uint64_t v24 = (void *)objc_claimAutoreleasedReturnValue(v23);
        unint64_t v25 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"Failed to instantiate function '%@'",  v24));

        if (a4)
        {
          unint64_t v26 = GTUpdateShaderMakeError(3u, v25, 0LL, v18);
          *a4 = (id)objc_claimAutoreleasedReturnValue(v26);
        }

        int v13 = 0LL;
        goto LABEL_20;
      }

      MTLFunctionDescriptor = MakeMTLFunctionDescriptor(v16, v7);
      uint64_t v12 = (void *)objc_claimAutoreleasedReturnValue(MTLFunctionDescriptor);
      unint64_t v29 = 0LL;
      int v13 = [v9 newFunctionWithDescriptor:v12 error:&v29];
      unint64_t v14 = v29;
    }

    unint64_t v18 = v14;
    goto LABEL_9;
  }

  if (a4)
  {
    unint64_t v15 = GTUpdateShaderMakeError(1u, @"Internal error: Failed to find runtime library for function", 0LL, 0LL);
    int v13 = 0LL;
    *a4 = (id)objc_claimAutoreleasedReturnValue(v15);
  }

  else
  {
    int v13 = 0LL;
  }

      unint64_t v17 = v7[2];
      if (v8 < v17)
      {
        *(_DWORD *)unint64_t v8 = v10;
        *((_DWORD *)v8 + 1) = v11;
        unint64_t v18 = (std::string *)(v8 + 1);
        if ((char)v13->__r_.__value_.__s.__size_ < 0)
        {
          std::string::__init_copy_ctor_external(v18, v13->__r_.__value_.__l.__data_, v13->__r_.__value_.__l.__size_);
        }

        else
        {
          uint64_t v19 = *(_OWORD *)&v13->__r_.__value_.__l.__data_;
          v8[3] = (void *)v13->__r_.__value_.__l.__cap_;
          *(_OWORD *)&v18->__r_.__value_.__l.__data_ = v19;
        }

        v8[4] = v38;
        unint64_t v26 = v8 + 5;
        goto LABEL_47;
      }

      unint64_t v20 = *v7;
      unint64_t v21 = 0xCCCCCCCCCCCCCCCDLL * (v8 - *v7);
      unint64_t v22 = v21 + 1;
      if (v21 + 1 > 0x666666666666666LL) {
        abort();
      }
      unint64_t v23 = 0xCCCCCCCCCCCCCCCDLL * (v17 - v20);
      if (2 * v23 > v22) {
        unint64_t v22 = 2 * v23;
      }
      if (v23 >= 0x333333333333333LL) {
        uint64_t v24 = 0x666666666666666LL;
      }
      else {
        uint64_t v24 = v22;
      }
      if (v24)
      {
        if (v24 > 0x666666666666666LL) {
          std::__throw_bad_array_new_length[abi:nn180100]();
        }
        unint64_t v25 = operator new(40 * v24);
      }

      else
      {
        unint64_t v25 = 0LL;
      }

      unint64_t v27 = (char *)&v25[5 * v21];
      *(_DWORD *)unint64_t v27 = v10;
      *((_DWORD *)v27 + 1) = v11;
      unint64_t v28 = (std::string *)(v27 + 8);
      if ((char)v13->__r_.__value_.__s.__size_ < 0)
      {
        std::string::__init_copy_ctor_external(v28, v13->__r_.__value_.__l.__data_, v13->__r_.__value_.__l.__size_);
        unint64_t v20 = *v7;
        unint64_t v8 = v7[1];
      }

      else
      {
        unint64_t v29 = *(_OWORD *)&v13->__r_.__value_.__l.__data_;
        *((void *)v27 + 3) = v13->__r_.__value_.__l.__cap_;
        *(_OWORD *)&v28->__r_.__value_.__l.__data_ = v29;
      }

      unint64_t v30 = (void **)&v25[5 * v24];
      v25[5 * v21 + 4] = v38;
      unint64_t v26 = (void **)(v27 + 40);
      if (v8 == v20)
      {
        *unint64_t v7 = (void **)v27;
        v7[1] = v26;
        v7[2] = v30;
      }

      else
      {
        do
        {
          unint64_t v31 = (uint64_t)*(v8 - 5);
          v8 -= 5;
          *((void *)v27 - 5) = v31;
          v27 -= 40;
          unint64_t v32 = *(_OWORD *)(v8 + 1);
          *((void *)v27 + 3) = v8[3];
          *(_OWORD *)(v27 + _Block_object_dispose(va, 8) = v32;
          void v8[2] = 0LL;
          v8[3] = 0LL;
          v8[1] = 0LL;
          *((void *)v27 + 4) = v8[4];
        }

        while (v8 != v20);
        unint64_t v33 = *v7;
        unint64_t v20 = v7[1];
        *unint64_t v7 = (void **)v27;
        v7[1] = v26;
        v7[2] = v30;
        if (v20 != v33)
        {
          unint64_t v6 = a2;
          unint64_t v5 = a4;
          unint64_t v4 = v35;
          do
          {
            v20 -= 5;
          }

          while (v20 != v33);
          unint64_t v20 = v33;
          if (!v33) {
            goto LABEL_47;
          }
LABEL_46:
          operator delete(v20);
LABEL_47:
          v7[1] = v26;
          llvm::raw_ostream::~raw_ostream((llvm::raw_ostream *)&v43);
          if (SHIBYTE(v40) < 0) {
            operator delete(__p[0]);
          }
          unint64_t v8 = v26;
          goto LABEL_50;
        }
      }

      unint64_t v6 = a2;
      unint64_t v5 = a4;
      unint64_t v4 = v35;
      if (v20) {
        goto LABEL_46;
      }
      goto LABEL_47;
    }

void ___ZL25ProfilingTimingDataLegacyP21GTMTLReplayControllerP26GTMTLReplayOperationQueuesP12NSDictionaryP19NSMutableDictionaryS6_P14NSMutableArrayIP8NSNumberEjjjP21GTAGXPerfStateControl_block_invoke( uint64_t a1)
{
  uint64_t v1 = a1;
  uint64_t v2 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(*(void *)(a1 + 72) + 8) defaultCommandQueue]);
  [v2 setStatEnabled:1];
  unint64_t v3 = (NSArray *)objc_claimAutoreleasedReturnValue([v2 availableCounters]);
  if ((IsCounterAvailable(v3, @"SW_PBUsed") & 1) != 0)
  {
    unint64_t v4 = @"SW_PBUsed";
  }

  else
  {
    unint64_t v4 = @"_fedf2c59";
  }

  [*(id *)(*(void *)(*(void *)(v1 + 64) + 8) + 40) addObject:v4];
LABEL_6:
  unint64_t v5 = (NSArray *)objc_claimAutoreleasedReturnValue( [v2 subdivideCounterList:*(void *)(*(void *)(*(void *)(v1 + 64) + 8) + 40)]);
  [v2 setStatEnabled:0];
  unint64_t v6 = *(void **)(v1 + 32);
  id v7 = CalculateFrameTimeLegacy( *(uint64_t **)(v1 + 72),  *(id **)(v1 + 80),  v5,  *(_DWORD *)(v1 + 96),  *(void **)(v1 + 40),  0LL,  *(_DWORD *)(v1 + 100),  *(void *)(v1 + 88));
  unint64_t v8 = (void *)objc_claimAutoreleasedReturnValue(v7);
  [v6 addDependency:v8];

  unint64_t v9 = *(void **)(v1 + 32);
  id v10 = CalculateFrameTimeLegacy( *(uint64_t **)(v1 + 72),  *(id **)(v1 + 80),  v5,  *(_DWORD *)(v1 + 104),  *(void **)(v1 + 40),  1LL,  *(_DWORD *)(v1 + 100),  *(void *)(v1 + 88));
  unint64_t v11 = (void *)objc_claimAutoreleasedReturnValue(v10);
  [v9 addDependency:v11];

  id v12 = CollectCounters( *(GTMTLReplayController **)(v1 + 72),  *(GTMTLReplayOperationQueues **)(v1 + 80),  *(NSArray **)(*(void *)(*(void *)(v1 + 64) + 8LL) + 40LL),  v5,  *(void **)(v1 + 48),  (NSMutableDictionary *)*(unsigned int *)(v1 + 104),  *(_DWORD *)(v1 + 100),  *(void *)(v1 + 88),  v38);
  uint64_t v13 = objc_claimAutoreleasedReturnValue(v12);
  unint64_t v14 = *(void **)(v1 + 48);
  unint64_t v15 = (NSArray *)*(id *)(*(void *)(*(void *)(v1 + 64) + 8LL) + 40LL);
  unint64_t v52 = _NSConcreteStackBlock;
  uint64_t v53 = 3221225472LL;
  unint64_t v54 = ___ZL17TimeDataOperationP7NSArrayP19NSMutableDictionaryP26GTMTLReplayOperationQueues_block_invoke;
  unint64_t v55 = &unk_58E1F8;
  unint64_t v56 = v15;
  unint64_t v57 = v14;
  unint64_t v16 = v15;
  unint64_t v17 = v57;
  unint64_t v18 = (void *)objc_claimAutoreleasedReturnValue( +[NSBlockOperation blockOperationWithBlock:]( &OBJC_CLASS___NSBlockOperation,  "blockOperationWithBlock:",  &v52));

  [v18 addDependency:v13];
  [*(id *)(*(void *)(v1 + 80) + 8) addOperation:v18];
  [*(id *)(v1 + 32) addDependency:v18];
  unint64_t v46 = v18;
  uint64_t v19 = *(void *)(v1 + 72);
  unint64_t v20 = *(void **)(v1 + 56);
  int32x2_t v21 = *(int32x2_t *)(v1 + 100);
  __int128 v48 = *(_OWORD *)(v1 + 80);
  id v22 = *(id *)(*(void *)(*(void *)(v1 + 64) + 8LL) + 40LL);
  unint64_t v23 = v5;
  id v47 = v20;
  unint64_t v49 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v19 + 8) defaultCommandQueue]);
  char v50 = v23;
  uint64_t v24 = -[NSArray count](v23, "count");
  unint64_t v45 = (void *)v13;
  unint64_t v51 = -[NSMutableArray initWithCapacity:](objc_alloc(&OBJC_CLASS___NSMutableArray), "initWithCapacity:", v24);
  id v40 = v22;
  if (v24)
  {
    unint64_t v25 = v24;
    do
    {
      unint64_t v26 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableData dataWithCapacity:](&OBJC_CLASS___NSMutableData, "dataWithCapacity:", 0x10000LL));
      -[NSMutableArray addObject:](v51, "addObject:", v26);

      --v25;
    }

    while (v25);
  }

  v69[0] = _NSConcreteStackBlock;
  v69[1] = 3221225472LL;
  v69[2] = ___ZL21CollectBlitSplitTimesP21GTMTLReplayControllerP26GTMTLReplayOperationQueuesP7NSArrayS4_yP19NSMutableDictionaryjjP21GTAGXPerfStateControl_block_invoke;
  v69[3] = &unk_58EF80;
  id v27 = v22;
  id v70 = v27;
  unint64_t v28 = v51;
  BOOL v71 = v28;
  id v44 = v47;
  id v72 = v44;
  unint64_t v29 = (void *)objc_claimAutoreleasedReturnValue( +[NSBlockOperation blockOperationWithBlock:]( &OBJC_CLASS___NSBlockOperation,  "blockOperationWithBlock:",  v69));
  unint64_t v43 = v27;
  unint64_t v39 = v5;
  if (v24)
  {
    uint64_t v41 = v1;
    unint64_t v42 = v2;
    unint64_t v30 = 0LL;
    int32x2_t v31 = vrev64_s32(v21);
    uint64_t v32 = v48;
    do
    {
      v65[0] = _NSConcreteStackBlock;
      v65[1] = 3221225472LL;
      void v65[2] = ___ZL21CollectBlitSplitTimesP21GTMTLReplayControllerP26GTMTLReplayOperationQueuesP7NSArrayS4_yP19NSMutableDictionaryjjP21GTAGXPerfStateControl_block_invoke_2;
      v65[3] = &unk_58EDA8;
      unint64_t v33 = v28;
      unint64_t v66 = v33;
      unint64_t v68 = v30;
      unint64_t v34 = v50;
      unint64_t v67 = v34;
      unint64_t v35 = (void *)objc_claimAutoreleasedReturnValue( +[NSBlockOperation blockOperationWithBlock:]( &OBJC_CLASS___NSBlockOperation,  "blockOperationWithBlock:",  v65,  v39,  v40));
      [v29 addDependency:v35];
      unint64_t v52 = _NSConcreteStackBlock;
      uint64_t v53 = 3221225472LL;
      unint64_t v54 = ___ZL21CollectBlitSplitTimesP21GTMTLReplayControllerP26GTMTLReplayOperationQueuesP7NSArrayS4_yP19NSMutableDictionaryjjP21GTAGXPerfStateControl_block_invoke_3;
      unint64_t v55 = &unk_58F788;
      uint64_t v60 = v19;
      unint64_t v56 = v34;
      unint64_t v61 = v30;
      uint64_t v62 = 12LL;
      unint64_t v57 = v33;
      id v36 = v35;
      id v58 = v36;
      int32x2_t v64 = v31;
      __int128 v63 = v48;
      id v59 = v49;
      uint64_t v37 = (void *)objc_claimAutoreleasedReturnValue( +[NSBlockOperation blockOperationWithBlock:]( &OBJC_CLASS___NSBlockOperation,  "blockOperationWithBlock:",  &v52));
      [v37 setQueuePriority:-8];
      [*(id *)v48 addOperation:v37];

      ++v30;
    }

    while (v24 != v30);
    uint64_t v1 = v41;
    uint64_t v2 = v42;
  }

  else
  {
    uint64_t v32 = v48;
  }

  objc_msgSend(*(id *)(v32 + 8), "addOperation:", v29, v39);

  [*(id *)(v1 + 32) addDependency:v29];
}

void sub_989A4( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9)
{
  _Unwind_Resume(a1);
}

id IsCounterAvailable(NSArray *a1, NSString *a2)
{
  unint64_t v3 = a1;
  unint64_t v4 = a2;
  __int128 v10 = 0u;
  __int128 v11 = 0u;
  __int128 v12 = 0u;
  __int128 v13 = 0u;
  unint64_t v5 = v3;
  id v6 = -[NSArray countByEnumeratingWithState:objects:count:]( v5,  "countByEnumeratingWithState:objects:count:",  &v10,  v14,  16LL);
  if (v6)
  {
    uint64_t v7 = *(void *)v11;
    while (2)
    {
      for (uint64_t i = 0LL; i != v6; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v11 != v7) {
          objc_enumerationMutation(v5);
        }
        if (-[NSString isEqualToString:]( v4,  "isEqualToString:",  *(void *)(*((void *)&v10 + 1) + 8LL * (void)i),  (void)v10))
        {
          id v6 = &dword_0 + 1;
          goto LABEL_11;
        }
      }

      id v6 = -[NSArray countByEnumeratingWithState:objects:count:]( v5,  "countByEnumeratingWithState:objects:count:",  &v10,  v14,  16LL);
      if (v6) {
        continue;
      }
      break;
    }
  }

void sub_98C50(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id CalculateFrameTimeLegacy(uint64_t *a1, id *a2, void *a3, int a4, void *a5, uint64_t a6, int a7, uint64_t a8)
{
  id v14 = a3;
  id v24 = a5;
  unint64_t v26 = (void *)objc_claimAutoreleasedReturnValue([(id)a1[1] defaultCommandQueue]);
  [v14 count];
  v43[0] = 0LL;
  v43[1] = v43;
  v43[2] = 0x4812000000LL;
  v43[3] = __Block_byref_object_copy__94;
  v43[4] = __Block_byref_object_dispose__95;
  v43[5] = "";
  id v44 = 0LL;
  unint64_t v45 = 0LL;
  uint64_t v46 = 0LL;
  std::vector<std::tuple<unsigned long long,unsigned long long,unsigned long long>>::reserve(&v44, 0x80uLL);
  v39[0] = _NSConcreteStackBlock;
  v39[1] = 3221225472LL;
  v39[2] = ___ZL24CalculateFrameTimeLegacyP21GTMTLReplayControllerP26GTMTLReplayOperationQueuesP7NSArrayS4_yjP14NSMutableArrayIP8NSNumberEmjP21GTAGXPerfStateControl_block_invoke;
  v39[3] = &unk_58F838;
  uint64_t v41 = v43;
  id v15 = v24;
  id v40 = v15;
  uint64_t v42 = a6;
  unint64_t v16 = (void *)objc_claimAutoreleasedReturnValue( +[NSBlockOperation blockOperationWithBlock:]( &OBJC_CLASS___NSBlockOperation,  "blockOperationWithBlock:",  v39));
  uint64_t v17 = *a1;
  v27[0] = _NSConcreteStackBlock;
  v27[1] = 3221225472LL;
  void v27[2] = ___ZL24CalculateFrameTimeLegacyP21GTMTLReplayControllerP26GTMTLReplayOperationQueuesP7NSArrayS4_yjP14NSMutableArrayIP8NSNumberEmjP21GTAGXPerfStateControl_block_invoke_2;
  v27[3] = &unk_58DED0;
  uint64_t v32 = a1;
  id v18 = v26;
  id v28 = v18;
  uint64_t v33 = a8;
  uint64_t v34 = 0LL;
  int v37 = a7;
  int v38 = a4;
  id v19 = v14;
  id v29 = v19;
  int32x2_t v31 = v43;
  uint64_t v35 = v17;
  id v36 = a2;
  id v20 = v16;
  id v30 = v20;
  int32x2_t v21 = (void *)objc_claimAutoreleasedReturnValue( +[NSBlockOperation blockOperationWithBlock:]( &OBJC_CLASS___NSBlockOperation,  "blockOperationWithBlock:",  v27));
  [v21 setQueuePriority:-8];
  [*a2 addOperation:v21];
  id v22 = v20;

  _Block_object_dispose(v43, 8);
  if (v44)
  {
    unint64_t v45 = v44;
    operator delete(v44);
  }

  return v22;
}

void sub_98EA0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, uint64_t a11, void *a12, void *a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18, void *a19, void *a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, void *a32)
{
  _Block_object_dispose((const void *)(v33 - 176), 8);
  uint64_t v35 = *(void **)(v33 - 128);
  if (v35)
  {
    *(void *)(v33 - 120) = v35;
    operator delete(v35);
  }

  _Unwind_Resume(a1);
}

id CollectCounters( GTMTLReplayController *a1, GTMTLReplayOperationQueues *a2, NSArray *a3, NSArray *a4, void *a5, NSMutableDictionary *a6, int a7, uint64_t a8, GTAGXPerfStateControl *a9)
{
  int v37 = (int)a6;
  uint64_t v35 = a3;
  __int128 v13 = a4;
  id v34 = a5;
  id v36 = a1;
  uint64_t v41 = (void *)objc_claimAutoreleasedReturnValue([a1->var1 defaultCommandQueue]);
  id v14 = -[NSArray count](v13, "count");
  unint64_t v16 = -[NSMutableArray initWithCapacity:](objc_alloc(&OBJC_CLASS___NSMutableArray), "initWithCapacity:", v14);
  if (v14)
  {
    uint64_t v17 = v14;
    do
    {
      id v18 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableData dataWithCapacity:](&OBJC_CLASS___NSMutableData, "dataWithCapacity:", 0x10000LL));
      -[NSMutableArray addObject:](v16, "addObject:", v18);

      --v17;
    }

    while (v17);
  }

  v74[0] = 0LL;
  v74[1] = v74;
  v74[2] = 0x2020000000LL;
  char v75 = 0;
  v72[0] = 0LL;
  v72[1] = v72;
  v72[2] = 0x2020000000LL;
  char v73 = 0;
  v70[0] = 0LL;
  v70[1] = v70;
  v70[2] = 0x3032000000LL;
  v70[3] = __Block_byref_object_copy__53;
  v70[4] = __Block_byref_object_dispose__54;
  id v71 = (id)objc_opt_new(&OBJC_CLASS___NSMutableString, v15);
  v61[0] = _NSConcreteStackBlock;
  v61[1] = 3221225472LL;
  v61[2] = ___ZL15CollectCountersP21GTMTLReplayControllerP26GTMTLReplayOperationQueuesP7NSArrayS4_yP19NSMutableDictionaryjjP21GTAGXPerfStateControl_block_invoke;
  v61[3] = &unk_58DEF8;
  id v31 = v34;
  id v62 = v31;
  uint64_t v33 = v35;
  __int128 v63 = v33;
  id v40 = v13;
  int32x2_t v64 = v40;
  id v19 = v16;
  unint64_t v68 = v70;
  int v69 = v14;
  unint64_t v65 = v19;
  unint64_t v66 = v74;
  unint64_t v67 = v72;
  uint64_t v20 = objc_claimAutoreleasedReturnValue(+[NSBlockOperation blockOperationWithBlock:](&OBJC_CLASS___NSBlockOperation, "blockOperationWithBlock:", v61));
  int32x2_t v21 = v14;
  id v22 = (void *)v20;
  if (v21)
  {
    unint64_t v23 = v21;
    for (uint64_t i = 0LL; i != v23; ++i)
    {
      v57[0] = _NSConcreteStackBlock;
      v57[1] = 3221225472LL;
      v57[2] = ___ZL15CollectCountersP21GTMTLReplayControllerP26GTMTLReplayOperationQueuesP7NSArrayS4_yP19NSMutableDictionaryjjP21GTAGXPerfStateControl_block_invoke_2;
      v57[3] = &unk_58EDA8;
      unint64_t v25 = v19;
      id v58 = v25;
      uint64_t v60 = i;
      unint64_t v26 = v40;
      id v59 = v26;
      id v27 = (void *)objc_claimAutoreleasedReturnValue( +[NSBlockOperation blockOperationWithBlock:]( &OBJC_CLASS___NSBlockOperation,  "blockOperationWithBlock:",  v57,  v31,  v33));
      [v22 addDependency:v27];
      v42[0] = _NSConcreteStackBlock;
      v42[1] = 3221225472LL;
      v42[2] = ___ZL15CollectCountersP21GTMTLReplayControllerP26GTMTLReplayOperationQueuesP7NSArrayS4_yP19NSMutableDictionaryjjP21GTAGXPerfStateControl_block_invoke_3;
      v42[3] = &unk_58DF20;
      char v50 = v36;
      unint64_t v43 = v26;
      unint64_t v51 = i;
      uint64_t v52 = 63LL;
      id v44 = v25;
      uint64_t v53 = a2;
      id v28 = v27;
      int v55 = v37;
      int v56 = a7;
      id v45 = v28;
      uint64_t v54 = a8;
      id v46 = v41;
      id v47 = v70;
      __int128 v48 = v74;
      unint64_t v49 = v72;
      id v29 = (void *)objc_claimAutoreleasedReturnValue( +[NSBlockOperation blockOperationWithBlock:]( &OBJC_CLASS___NSBlockOperation,  "blockOperationWithBlock:",  v42));
      [v29 setQueuePriority:-8];
      [a2->var0 addOperation:v29];
    }
  }

  objc_msgSend(a2->var1, "addOperation:", v22, v31);

  _Block_object_dispose(v70, 8);
  _Block_object_dispose(v72, 8);
  _Block_object_dispose(v74, 8);

  return v22;
}

void sub_99300( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, void *a12, void *a13, void *a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, uint64_t a41, uint64_t a42, uint64_t a43, uint64_t a44, uint64_t a45, uint64_t a46, uint64_t a47, void *a48, void *a49, void *a50,void *a51)
{
  _Block_object_dispose((const void *)(v52 - 216), 8);
  _Block_object_dispose((const void *)(v52 - 168), 8);
  _Block_object_dispose((const void *)(v52 - 136), 8);

  _Unwind_Resume(a1);
}

void ___ZL17TimeDataOperationP7NSArrayP19NSMutableDictionaryP26GTMTLReplayOperationQueues_block_invoke( uint64_t a1)
{
  uint64_t v1 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) lastObject]);
  if ([@"SW_PBUsed" isEqualToString:v1])
  {

LABEL_4:
    uint64_t v4 = a1;
    unsigned int v44 = [*(id *)(a1 + 32) count] - 1;
    goto LABEL_6;
  }

  uint64_t v2 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) lastObject]);
  unsigned int v3 = [@"_fedf2c59" isEqualToString:v2];

  if (v3) {
    goto LABEL_4;
  }
  unsigned int v44 = -1;
  uint64_t v4 = a1;
LABEL_6:
  id v31 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v4 + 40) objectForKeyedSubscript:@"AverageSamples"]);
  int v38 = (void *)objc_opt_new(&OBJC_CLASS___NSMutableArray, v5);
  unint64_t v39 = (void *)objc_opt_new(&OBJC_CLASS___NSMutableArray, v6);
  id v40 = (void *)objc_opt_new(&OBJC_CLASS___NSMutableArray, v7);
  id v36 = (void *)objc_opt_new(&OBJC_CLASS___NSMutableArray, v8);
  __int128 v57 = 0u;
  __int128 v58 = 0u;
  __int128 v55 = 0u;
  __int128 v56 = 0u;
  obuint64_t j = v31;
  id v29 = [obj countByEnumeratingWithState:&v55 objects:v61 count:16];
  if (v29)
  {
    uint64_t v30 = *(void *)v56;
    do
    {
      for (uint64_t i = 0LL; i != v29; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v56 != v30) {
          objc_enumerationMutation(obj);
        }
        unint64_t v9 = *(void **)(*((void *)&v55 + 1) + 8LL * (void)i);
        __int128 v51 = 0u;
        __int128 v52 = 0u;
        __int128 v53 = 0u;
        __int128 v54 = 0u;
        id v35 = v9;
        id v41 = [v35 countByEnumeratingWithState:&v51 objects:v60 count:16];
        if (v41)
        {
          uint64_t v37 = *(void *)v52;
          do
          {
            for (uint64_t j = 0LL; j != v41; uint64_t j = (char *)j + 1)
            {
              if (*(void *)v52 != v37) {
                objc_enumerationMutation(v35);
              }
              __int128 v11 = *(void **)(*((void *)&v51 + 1) + 8LL * (void)j);
              id v46 = (void *)objc_opt_new(&OBJC_CLASS___NSMutableArray, v10);
              id v45 = (void *)objc_opt_new(&OBJC_CLASS___NSMutableArray, v12);
              __int128 v49 = 0u;
              __int128 v50 = 0u;
              __int128 v47 = 0u;
              __int128 v48 = 0u;
              id v43 = v11;
              id v13 = [v43 countByEnumeratingWithState:&v47 objects:v59 count:16];
              if (v13)
              {
                uint64_t v14 = *(void *)v48;
                uint64_t v15 = &off_5A06E8;
                unint64_t v16 = &off_5A06E8;
                do
                {
                  for (uint64_t k = 0LL; k != v13; uint64_t k = (char *)k + 1)
                  {
                    if (*(void *)v48 != v14) {
                      objc_enumerationMutation(v43);
                    }
                    id v18 = *(void **)(*((void *)&v47 + 1) + 8LL * (void)k);
                    id v19 = (void *)objc_claimAutoreleasedReturnValue([v18 objectAtIndexedSubscript:3]);
                    uint64_t v20 = (void *)objc_claimAutoreleasedReturnValue([v19 objectAtIndexedSubscript:0]);
                    uint64_t v21 = objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( NSNumber,  "numberWithUnsignedLongLong:",  (char *)[v20 unsignedLongLongValue]
                            + (void)[v16 unsignedLongLongValue]));

                    unint64_t v16 = (_UNKNOWN **)v21;
                    id v22 = (void *)objc_claimAutoreleasedReturnValue([v18 objectAtIndexedSubscript:3]);
                    unint64_t v23 = (void *)objc_claimAutoreleasedReturnValue([v22 objectAtIndexedSubscript:0]);
                    [v46 addObject:v23];

                    id v24 = (void *)objc_claimAutoreleasedReturnValue([v18 objectAtIndexedSubscript:6]);
                    unint64_t v25 = (void *)objc_claimAutoreleasedReturnValue([v24 objectAtIndexedSubscript:0]);
                    [v45 addObject:v25];

                    if (v44 != -1)
                    {
                      unint64_t v26 = (void *)objc_claimAutoreleasedReturnValue([v18 objectAtIndexedSubscript:v44]);
                      id v27 = (void *)objc_claimAutoreleasedReturnValue([v26 objectAtIndexedSubscript:0]);
                      uint64_t v28 = objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( NSNumber,  "numberWithUnsignedLongLong:",  (char *)[v27 unsignedLongLongValue]
                              + (void)[v15 unsignedLongLongValue]));

                      uint64_t v15 = (_UNKNOWN **)v28;
                    }
                  }

                  id v13 = [v43 countByEnumeratingWithState:&v47 objects:v59 count:16];
                }

                while (v13);
              }

              else
              {
                uint64_t v15 = &off_5A06E8;
                unint64_t v16 = &off_5A06E8;
              }

              [v38 addObject:v16];
              [v39 addObject:v46];
              [v40 addObject:v45];
              if (v44 != -1) {
                [v36 addObject:v15];
              }
            }

            id v41 = [v35 countByEnumeratingWithState:&v51 objects:v60 count:16];
          }

          while (v41);
        }
      }

      id v29 = [obj countByEnumeratingWithState:&v55 objects:v61 count:16];
    }

    while (v29);
  }

  [*(id *)(a1 + 40) setObject:v38 forKeyedSubscript:@"encoder time data"];
  [*(id *)(a1 + 40) setObject:v39 forKeyedSubscript:@"kick time data"];
  [*(id *)(a1 + 40) setObject:v40 forKeyedSubscript:@"kick cycle data"];
  if (v44 != -1) {
    [*(id *)(a1 + 40) setObject:v36 forKeyedSubscript:@"tilerParamBufBytesUsedArray"];
  }
}

void sub_99980( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, void *a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17, uint64_t a18, void *a19, void *a20, void *a21)
{
}

void ___ZL21CollectBlitSplitTimesP21GTMTLReplayControllerP26GTMTLReplayOperationQueuesP7NSArrayS4_yP19NSMutableDictionaryjjP21GTAGXPerfStateControl_block_invoke( uint64_t a1)
{
  uint64_t v1 = a1;
  uint64_t v2 = *(void **)(a1 + 32);
  unsigned int v3 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 40) objectAtIndexedSubscript:0]);
  id v4 = v2;
  id v36 = v3;
  unint64_t v5 = (unint64_t)[v36 length];
  id v6 = [v4 count];
  id v7 = [v4 count];
  id v8 = v36;
  unint64_t v9 = (uint64_t *)[v8 bytes];
  unint64_t v10 = 8LL * (void)v6;
  if (8 * (uint64_t)v6 <= v5)
  {
    uint64_t v14 = v9;
    id v33 = v8;
    uint64_t v34 = v1;
    id v35 = v4;
    __int128 v11 = 0LL;
    uint64_t v12 = 0LL;
    unint64_t v15 = 0LL;
    uint64_t v16 = 0LL;
    unint64_t v17 = v5 / v10;
    if (v17 <= 1) {
      uint64_t v18 = 1LL;
    }
    else {
      uint64_t v18 = v17;
    }
    uint64_t v19 = -1LL;
    uint64_t v20 = -1LL;
    id v37 = v7;
    do
    {
      uint64_t v21 = v19;
      uint64_t v19 = *v14;
      if (*v14 == v21) {
        uint64_t v22 = v20;
      }
      else {
        uint64_t v22 = -1LL;
      }
      uint64_t v20 = v14[1];
      if (v20 == v22)
      {
        uint64_t v20 = v22;
      }

      else if ((unint64_t)v12 >= v15)
      {
        uint64_t v23 = (v12 - v11) >> 3;
        unint64_t v24 = v23 + 1;
        else {
          unint64_t v25 = v24;
        }
        if (v25) {
          unint64_t v25 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<std::pair<unsigned int,unsigned int>>>(v25);
        }
        else {
          uint64_t v26 = 0LL;
        }
        id v27 = (char *)(v25 + 8 * v23);
        *(void *)id v27 = 0LL;
        uint64_t v28 = v27 + 8;
        while (v12 != v11)
        {
          uint64_t v29 = *((void *)v12 - 1);
          v12 -= 8;
          *((void *)v27 - 1) = v29;
          v27 -= 8;
        }

        unint64_t v15 = v25 + 8 * v26;
        if (v11) {
          operator delete(v11);
        }
        __int128 v11 = v27;
        uint64_t v12 = v28;
        id v7 = v37;
      }

      else
      {
        *(void *)uint64_t v12 = 0LL;
        v12 += 8;
      }

      *((void *)v12 - 1) += v14[3];
      v14 += (uint64_t)v7;
      ++v16;
    }

    while (v16 != v18);
    id v13 = v11;
    uint64_t v1 = v34;
    id v4 = v35;
    id v8 = v33;
  }

  else
  {
    __int128 v11 = 0LL;
    uint64_t v12 = 0LL;
    id v13 = 0LL;
  }

  id v38 = (id)objc_claimAutoreleasedReturnValue(+[NSMutableArray arrayWithCapacity:](&OBJC_CLASS___NSMutableArray, "arrayWithCapacity:", (v12 - v13) >> 3));
  if (v11 != v12)
  {
    uint64_t v30 = v11;
    do
    {
      id v31 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  *(void *)v30));
      [v38 addObject:v31];

      v30 += 8;
    }

    while (v30 != v12);
  }

  if (v11) {
    operator delete(v11);
  }

  id v32 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObject:forKey:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObject:forKey:",  v38,  @"PerDrawNsecTimes"));
  [*(id *)(v1 + 48) setObject:v32 forKeyedSubscript:@"SplitEncoderData"];
}

void sub_99D78( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, id a14)
{
  _Unwind_Resume(a1);
}

void ___ZL21CollectBlitSplitTimesP21GTMTLReplayControllerP26GTMTLReplayOperationQueuesP7NSArrayS4_yP19NSMutableDictionaryjjP21GTAGXPerfStateControl_block_invoke_2( uint64_t a1)
{
  unsigned int v3 = (NSMutableData *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) objectAtIndexedSubscript:*(void *)(a1 + 48)]);
  uint64_t v2 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 40) objectAtIndexedSubscript:*(void *)(a1 + 48)]);
  SortCounterData(v3, (uint64_t)[v2 count]);
}

void sub_99E68( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
}

id ___ZL21CollectBlitSplitTimesP21GTMTLReplayControllerP26GTMTLReplayOperationQueuesP7NSArrayS4_yP19NSMutableDictionaryjjP21GTAGXPerfStateControl_block_invoke_3( uint64_t a1)
{
  uint64_t v2 = *(GTMTLReplayController **)(a1 + 64);
  unsigned int v3 = (NSArray *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) objectAtIndexedSubscript:*(void *)(a1 + 72)]);
  CollectCounterData( v2,  v3,  *(void *)(a1 + 80),  *(NSArray **)(a1 + 40),  *(void *)(a1 + 72),  *(GTMTLReplayOperationQueues **)(a1 + 88),  *(NSOperation **)(a1 + 48),  *(unsigned int *)(a1 + 104),  1,  *(_DWORD *)(a1 + 108),  *(GTAGXPerfStateControl **)(a1 + 96));

  [*(id *)(a1 + 56) finish];
  [*(id *)(a1 + 56) setStatEnabled:0];
  [*(id *)(a1 + 56) setGPUPriority:1];
  return [*(id *)(*(void *)(a1 + 88) + 8) addOperation:*(void *)(a1 + 48)];
}

void sub_99F24(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void CollectCounterData( GTMTLReplayController *a1, NSArray *a2, uint64_t a3, NSArray *a4, uint64_t a5, GTMTLReplayOperationQueues *a6, NSOperation *a7, uint64_t a8, BOOL a9, unsigned int a10, GTAGXPerfStateControl *a11)
{
  unint64_t v17 = a2;
  id v74 = a4;
  id v72 = a7;
  if (a9) {
    uint64_t v18 = 0LL;
  }
  else {
    uint64_t v18 = 4LL;
  }
  NSUInteger v19 = -[NSArray count](v17, "count");
  uint64_t v91 = a1;
  uint64_t v20 = (void *)objc_claimAutoreleasedReturnValue([a1->var1 defaultCommandQueue]);
  char v75 = v20;
  [v20 setStatEnabled:1];
  [v20 setGPUPriority:0];
  if (*((void *)a11 + 2) || *((_DWORD *)a11 + 1) == 1)
  {
    if (!GTAGXPerfStateControl::IsGPUPerformanceStateInduced(a11)) {
      GTAGXPerfStateControl::EnableConsistentGPUPerfState((uint64_t)a11, a10);
    }
    goto LABEL_8;
  }

  if (!(_DWORD)a8)
  {
LABEL_8:
    [v20 setStatOptions:0x10000000];
    goto LABEL_9;
  }

  unint64_t v68 = (void *)objc_claimAutoreleasedReturnValue([v91->var1 defaultDevice]);
  if ((objc_opt_respondsToSelector(v68, "setConsistentGPUPerfStateTo:") & 1) != 0) {
    [v68 setConsistentGPUPerfStateTo:a8];
  }
  [v20 setStatOptions:2415919104];

LABEL_9:
  [v20 setStatLocations:a3];
  [v20 requestCounters:v17 withIndex:a5];
  uint64_t v21 = (void *)objc_claimAutoreleasedReturnValue([v20 counterInfo]);
  NSUInteger v83 = v19;
  uint64_t v86 = v18;
  uint64_t v88 = a5;
  uint64_t v81 = a6;
  unsigned __int8 v103 = 0;
  std::vector<BOOL>::vector(v102, -[NSArray count](v17, "count"), &v103);
  __int128 v98 = 0u;
  __int128 v99 = 0u;
  __int128 v100 = 0u;
  __int128 v101 = 0u;
  uint64_t v22 = v17;
  id v23 = -[NSArray countByEnumeratingWithState:objects:count:]( v22,  "countByEnumeratingWithState:objects:count:",  &v98,  v104,  16LL);
  if (v23)
  {
    int v24 = 0;
    uint64_t v25 = *(void *)v99;
    do
    {
      for (uint64_t i = 0LL; i != v23; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v99 != v25) {
          objc_enumerationMutation(v22);
        }
        id v27 = (void *)objc_claimAutoreleasedReturnValue( [v21 objectForKeyedSubscript:*(void *)(*((void *)&v98 + 1) + 8 * (void)i)]);
        uint64_t v28 = (void *)objc_claimAutoreleasedReturnValue([v27 objectForKeyedSubscript:@"type"]);

        unsigned int v29 = [v28 characterAtIndex:0];
        uint64_t v30 = (v24 + (_DWORD)i) >> 6;
        uint64_t v31 = 1LL << (v24 + i);
        if (v29 == 68) {
          uint64_t v32 = *((void *)v102[0] + v30) | v31;
        }
        else {
          uint64_t v32 = *((void *)v102[0] + v30) & ~v31;
        }
        *((void *)v102[0] + v30) = v32;
      }

      id v23 = -[NSArray countByEnumeratingWithState:objects:count:]( v22,  "countByEnumeratingWithState:objects:count:",  &v98,  v104,  16LL);
      v24 += (int)i;
    }

    while (v23);
  }

  id v71 = (void *)objc_claimAutoreleasedReturnValue(-[NSArray objectAtIndexedSubscript:](v74, "objectAtIndexedSubscript:", v88));
  v92[0] = _NSConcreteStackBlock;
  v92[1] = 3321888768LL;
  v92[2] = ___ZL18CollectCounterDataP21GTMTLReplayControllerP7NSArrayyS2_mP26GTMTLReplayOperationQueuesP11NSOperationjbjP21GTAGXPerfStateControl_block_invoke;
  v92[3] = &unk_58DF80;
  uint64_t v95 = v86;
  NSUInteger v96 = v83;
  std::vector<BOOL>::vector(__p, (uint64_t)v102);
  id v70 = v71;
  id v93 = v70;
  int v69 = v72;
  unint64_t v94 = v69;
  __p[3] = v81;
  [v75 addPerfSampleHandler:v92];
  id v33 = v91->var1;
  var0 = (uint64_t *)v91->var0;
  unint64_t v82 = v33;
  if (a9)
  {
    uint64_t v76 = var0[14];
    int64_t v87 = (void *)objc_claimAutoreleasedReturnValue([v33 defaultCommandQueue]);
    p_var24 = &v91->var24;
    if (var0[13] + var0[12] > (unint64_t)v91->var24.var0)
    {
      uint64_t v77 = 0LL;
      uint64_t v79 = 0LL;
      uint64_t v35 = 0LL;
      uint64_t v84 = 0LL;
      uint64_t v73 = var0[15];
      do
      {
        id v36 = objc_autoreleasePoolPush();
        uint64_t v37 = *(void *)(var0[15] + 24);
        uint64_t v38 = p_var24->var0;
        uint64_t v39 = v37 + (v38 << 6);
        id v41 = (int *)(v39 + 8);
        int v40 = *(_DWORD *)(v39 + 8);
        if (GetFuncEnumConstructorType(v40) == 25)
        {
          [v87 setStatLocations:0];
          GTMTLReplayController_restoreCommandBuffer((uint64_t)v91, v37 + (v38 << 6));
          [v87 setStatLocations:a3];
          uint64_t v77 = *((unsigned int *)GTTraceFunc_argumentBytesWithMap( (void *)(v37 + (v38 << 6)),  *(unsigned __int8 *)(v37 + (v38 << 6) + 13),  var0[2])
                + 2);
          int v40 = *v41;
        }

        if (GetFuncEnumConstructorType(v40) == 21)
        {
          uint64_t v79 = *((unsigned int *)GTTraceFunc_argumentBytesWithMap( (void *)(v37 + (v38 << 6)),  *(unsigned __int8 *)(v37 + (v38 << 6) + 13),  var0[2])
                + 2);
          InclusiveRange = GroupBuilder_findInclusiveRange(*(_DWORD *)(v76 + 12), *(void **)(v76 + 24), p_var24->var0);
          unint64_t v43 = InclusiveRange[1];
          unint64_t v44 = v43 - *InclusiveRange;
          if (v43 > *InclusiveRange)
          {
            id v45 = (int *)(*(void *)(v73 + 24) + (*InclusiveRange << 6) + 8LL);
            do
            {
              int v47 = *v45;
              v45 += 16;
              int v46 = v47;
              if (IsFuncEnumSampledBlitCall(v47) || IsFuncEnumSampledBlitCallAGX(v46)) {
                ++v35;
              }
              --v44;
            }

            while (v44);
          }

          uint64_t v48 = v35;
        }

        else
        {
          uint64_t v48 = v84;
        }

        GTMTLReplayController_updateCommandEncoder((uint64_t)v91, v39);
        int v49 = *v41;
        if (IsFuncEnumSampledBlitCall(*v41) || IsFuncEnumSampledBlitCallAGX(v49))
        {
          uint64_t v84 = v48 - 1;
          if (v48 && v35 != v48)
          {
            __int128 v50 = (void *)objc_claimAutoreleasedReturnValue([v82 blitCommandEncoderForKey:v79]);
            [v50 endEncoding];
            __int128 v51 = (void *)objc_claimAutoreleasedReturnValue([v82 commandBufferForKey:v77]);
            __int128 v52 = (void *)objc_claimAutoreleasedReturnValue([v51 blitCommandEncoder]);
            [v82 setBlitCommandEncoder:v52 forKey:v79];
          }
        }

        else
        {
          uint64_t v84 = v48;
        }

        GTMTLReplayController_defaultDispatchFunction((uint64_t)v91, v39);
        objc_autoreleasePoolPop(v36);
        unint64_t v53 = p_var24->var0 + 1;
        p_var24->var0 = v53;
      }

      while (var0[13] + var0[12] > v53);
    }
  }

  else
  {
    int64_t v87 = (void *)objc_claimAutoreleasedReturnValue([v33 defaultCommandQueue]);
    unsigned __int8 v103 = 0;
    __int128 v54 = &v91->var24;
    for (unint64_t j = v91->var24.var0; var0[13] + var0[12] > j; v54->var0 = j)
    {
      __int128 v56 = objc_autoreleasePoolPush();
      uint64_t v57 = *(void *)(var0[15] + 24);
      uint64_t v58 = v54->var0;
      int FuncEnumConstructorType = GetFuncEnumConstructorType(*(_DWORD *)(v57 + (v58 << 6) + 8));
      if (FuncEnumConstructorType == 25)
      {
        [v87 setStatLocations:0];
        GTMTLReplayController_restoreCommandBuffer((uint64_t)v91, v57 + (v58 << 6));
        [v87 setStatLocations:a3];
      }

      GTMTLReplayController_updateCommandEncoder((uint64_t)v91, v57 + (v58 << 6));
      DispatchFunction((id *)&v91->var0, v57 + (v58 << 6), &v103);
      if (FuncEnumConstructorType == 25)
      {
        uint64_t v60 = *((void *)GTTraceFunc_argumentBytesWithMap( (void *)(v57 + (v58 << 6)),  *(unsigned __int8 *)(v57 + (v58 << 6) + 13),  var0[2])
              + 1);
        unint64_t v61 = (void *)objc_claimAutoreleasedReturnValue([v91->var1 defaultCommandQueue]);
        if ([v61 isStatEnabled])
        {
          unint64_t v90 = (void *)objc_claimAutoreleasedReturnValue([v91->var1 defaultDevice]);
          unsigned int v80 = (void *)objc_claimAutoreleasedReturnValue( +[MTLTextureDescriptor texture2DDescriptorWithPixelFormat:width:height:mipmapped:]( &OBJC_CLASS___MTLTextureDescriptor,  "texture2DDescriptorWithPixelFormat:width:height:mipmapped:",  70LL,  16LL,  16LL,  0LL));
          [v80 setUsage:4];
          id v85 = [v90 newTextureWithDescriptor:v80];
          id v62 = (void *)objc_claimAutoreleasedReturnValue( +[MTLRenderPassDescriptor renderPassDescriptor]( &OBJC_CLASS___MTLRenderPassDescriptor,  "renderPassDescriptor"));
          int32x2_t v64 = (void *)objc_opt_new(&OBJC_CLASS___MTLRenderPassColorAttachmentDescriptor, v63);
          [v64 setTexture:v85];
          [v64 setLoadAction:2];
          [v64 setStoreAction:1];
          objc_msgSend(v64, "setClearColor:", 0.0, 0.0, 0.0, 1.0);
          unint64_t v65 = (void *)objc_claimAutoreleasedReturnValue([v62 colorAttachments]);
          [v65 setObject:v64 atIndexedSubscript:0];

          unint64_t v66 = (void *)objc_claimAutoreleasedReturnValue([v91->var1 commandBufferForKey:v60]);
          unint64_t v67 = (void *)objc_claimAutoreleasedReturnValue([v66 renderCommandEncoderWithDescriptor:v62]);
          [v67 setLabel:@"GPUToolsCounterProfilingEmptyRender"];
          [v67 endEncoding];
        }
      }

      objc_autoreleasePoolPop(v56);
      unint64_t j = v54->var0 + 1;
    }
  }

  if (__p[0]) {
    operator delete(__p[0]);
  }

  if (v102[0]) {
    operator delete(v102[0]);
  }
}

void sub_9A744( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, uint64_t a15, void *a16, void *a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, void *__p)
{
}

void *std::vector<BOOL>::vector(void *a1, unint64_t a2, unsigned __int8 *a3)
{
  *a1 = 0LL;
  a1[1] = 0LL;
  a1[2] = 0LL;
  if (a2)
  {
    std::vector<BOOL>::__vallocate[abi:nn180100](a1, a2);
    int v6 = *a3;
    unint64_t v7 = a1[1];
    unint64_t v8 = v7 + a2;
    a1[1] = v7 + a2;
    if (v7)
    {
      unint64_t v9 = v8 - 1;
      if (((v8 - 1) ^ (v7 - 1)) < 0x40)
      {
LABEL_10:
        uint64_t v13 = *a1 + 8 * (v7 >> 6);
        int v14 = v7 & 0x3F;
        if (v6) {
          std::__fill_n[abi:nn180100]<true,std::vector<BOOL>>(&v13, a2);
        }
        else {
          std::__fill_n[abi:nn180100]<false,std::vector<BOOL>>((uint64_t)&v13, a2);
        }
        return a1;
      }
    }

    else
    {
      unint64_t v9 = v8 - 1;
    }

    unint64_t v10 = v9 >> 6;
    if (v8 >= 0x41) {
      unint64_t v11 = v10;
    }
    else {
      unint64_t v11 = 0LL;
    }
    *(void *)(*a1 + 8 * v11) = 0LL;
    goto LABEL_10;
  }

  return a1;
}

void ___ZL18CollectCounterDataP21GTMTLReplayControllerP7NSArrayyS2_mP26GTMTLReplayOperationQueuesP11NSOperationjbjP21GTAGXPerfStateControl_block_invoke( uint64_t a1, void *a2, void *a3, uint64_t a4)
{
  id v7 = a2;
  id v8 = a3;
  unint64_t v9 = v8;
  if (v8 && a4)
  {
    id v10 = [v8 copy];
    uint64_t v13 = _NSConcreteStackBlock;
    uint64_t v14 = 3321888768LL;
    unint64_t v15 = ___ZL18CollectCounterDataP21GTMTLReplayControllerP7NSArrayyS2_mP26GTMTLReplayOperationQueuesP11NSOperationjbjP21GTAGXPerfStateControl_block_invoke_2;
    uint64_t v16 = &unk_58DF48;
    uint64_t v19 = a4;
    __int128 v20 = *(_OWORD *)(a1 + 48);
    id v11 = v10;
    id v17 = v11;
    std::vector<BOOL>::vector(&__p, a1 + 64);
    id v18 = *(id *)(a1 + 32);
    uint64_t v12 = (void *)objc_claimAutoreleasedReturnValue( +[NSBlockOperation blockOperationWithBlock:]( &OBJC_CLASS___NSBlockOperation,  "blockOperationWithBlock:",  &v13));
    objc_msgSend(*(id *)(a1 + 40), "addDependency:", v12, v13, v14, v15, v16);
    [*(id *)(*(void *)(a1 + 88) + 8) addOperation:v12];

    if (__p) {
      operator delete(__p);
    }
  }
}

void sub_9AB14( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, void *a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p)
{
  if (__p) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

void *std::vector<BOOL>::vector(void *a1, uint64_t a2)
{
  *a1 = 0LL;
  a1[1] = 0LL;
  a1[2] = 0LL;
  uint64_t v4 = *(void *)(a2 + 8);
  if (!v4) {
    return a1;
  }
  std::vector<BOOL>::__vallocate[abi:nn180100](a1, v4);
  unint64_t v5 = *(void **)a2;
  unint64_t v6 = *(void *)(a2 + 8);
  unint64_t v7 = a1[1];
  unint64_t v8 = v7 + v6;
  a1[1] = v7 + v6;
  if (v7)
  {
    unint64_t v9 = v8 - 1;
    if (((v8 - 1) ^ (v7 - 1)) < 0x40) {
      goto LABEL_10;
    }
  }

  else
  {
    unint64_t v9 = v8 - 1;
  }

  unint64_t v10 = v9 >> 6;
  if (v8 >= 0x41) {
    unint64_t v11 = v10;
  }
  else {
    unint64_t v11 = 0LL;
  }
  *(void *)(*a1 + 8 * v11) = 0LL;
LABEL_10:
  int v12 = v6 & 0x3F;
  if (v6 > 0x3F || (v6 & 0x3F) != 0)
  {
    int v13 = 0;
    int v14 = 0;
    unint64_t v15 = &v5[v6 >> 6];
    int v16 = v7 & 0x3F;
    id v17 = (uint64_t *)(*a1 + 8 * (v7 >> 6));
    do
    {
      uint64_t v18 = 1LL << v16;
      if (((*v5 >> v14) & 1) != 0) {
        uint64_t v19 = *v17 | v18;
      }
      else {
        uint64_t v19 = *v17 & ~v18;
      }
      uint64_t *v17 = v19;
      ++v14;
      v5 += v13 == 63;
      if (v13 == 63) {
        int v14 = 0;
      }
      v17 += v16 == 63;
      if (v16 == 63) {
        int v16 = 0;
      }
      else {
        ++v16;
      }
      int v13 = v14;
    }

    while (v5 != v15 || v12 != v14);
  }

  return a1;
}

void *std::vector<BOOL>::__vallocate[abi:nn180100](void *a1, uint64_t a2)
{
  if (a2 < 0) {
    abort();
  }
  BOOL result = std::__allocate_at_least[abi:nn180100]<std::allocator<std::pair<unsigned int,unsigned int>>>(((unint64_t)(a2 - 1) >> 6) + 1);
  *a1 = result;
  a1[1] = 0LL;
  a1[2] = v4;
  return result;
}

void *__copy_helper_block_ea8_64c39_ZTSNSt3__16vectorIbNS_9allocatorIbEEEE(uint64_t a1, uint64_t a2)
{
  return std::vector<BOOL>::vector((void *)(a1 + 64), a2 + 64);
}

void __destroy_helper_block_ea8_64c39_ZTSNSt3__16vectorIbNS_9allocatorIbEEEE(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 64);
  if (v1) {
    operator delete(v1);
  }
}

void ___ZL18CollectCounterDataP21GTMTLReplayControllerP7NSArrayyS2_mP26GTMTLReplayOperationQueuesP11NSOperationjbjP21GTAGXPerfStateControl_block_invoke_2( uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 48);
  uint64_t v3 = *(void *)(a1 + 56);
  unint64_t v4 = *(void *)(a1 + 64);
  if (v4)
  {
    if (v4 >> 61) {
      abort();
    }
    unint64_t v5 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<std::pair<unsigned int,unsigned int>>>(*(void *)(a1 + 64));
    bzero(v5, 8 * v4);
    unint64_t v6 = &v5[8 * v4];
  }

  else
  {
    unint64_t v5 = 0LL;
    unint64_t v6 = 0LL;
  }

  unint64_t v7 = 0LL;
  unint64_t v8 = v2 - v3;
  __int128 v50 = 0LL;
  __int128 v51 = 0LL;
  __int128 v52 = 0LL;
  if ((unint64_t)(v2 - v3) >= 2)
  {
    if (v8 >= 0x1555555555555556LL) {
      abort();
    }
    unint64_t v9 = v8 >> 1;
    unint64_t v10 = (char **)std::__allocate_at_least[abi:nn180100]<std::allocator<std::vector<NSObject  {objcproto21OS_dispatch_semaphore}* {__strong}>>>(v8 >> 1);
    uint64_t v11 = 3 * v9;
    __int128 v50 = v10;
    __int128 v52 = &v10[3 * v12];
    unint64_t v7 = (uint64_t *)&v10[3 * v9];
    uint64_t v13 = 8 * v11;
    do
    {
      void *v10 = 0LL;
      v10[1] = 0LL;
      v10[2] = 0LL;
      if (v6 != v5)
      {
        std::vector<unsigned long>::__vallocate[abi:nn180100](v10, (v6 - v5) >> 3);
        int v14 = v10[1];
        memmove(v14, v5, v6 - v5);
        v10[1] = &v14[8 * ((v6 - v5) >> 3)];
      }

      v10 += 3;
      v13 -= 24LL;
    }

    while (v13);
    __int128 v51 = v7;
  }

  if (v5) {
    operator delete(v5);
  }
  unint64_t v15 = (uint64_t *)v50;
  if (v50 != (char **)v7)
  {
    unint64_t v16 = *(void *)(a1 + 56);
    if (v16 < *(void *)(a1 + 48))
    {
      id v17 = 0LL;
      uint64_t v18 = 0LL;
      uint64_t v19 = 8 * v16;
      do
      {
        __int128 v20 = (char *)[*(id *)(a1 + 32) bytes];
        uint64_t v21 = *(void *)(a1 + 64);
        uint64_t v22 = &v20[8 * v21 * v16];
        if (*(void *)v22 != -1LL)
        {
          if (*((void *)v22 + 5) == 1LL)
          {
            id v17 = &v20[8 * v21 * v16];
          }

          else
          {
            if (v21)
            {
              unint64_t v23 = 0LL;
              uint64_t v24 = *(void *)(a1 + 72);
              uint64_t v25 = v50[3 * v18];
              do
              {
                uint64_t v26 = *(void *)&v20[8 * v23 + v21 * v19];
                if (((*(void *)(v24 + ((v23 >> 3) & 0x1FFFFFFFFFFFFFF8LL)) >> v23) & 1) != 0) {
                  v26 -= *(void *)&v17[8 * v23];
                }
                *(void *)&v25[8 * v23++] = v26;
              }

              while (v21 != v23);
            }

            ++v18;
          }
        }

        ++v16;
        v19 += 8LL;
      }

      while (v16 < *(void *)(a1 + 48));
      unint64_t v15 = (uint64_t *)v50;
      unint64_t v7 = v51;
    }

    unint64_t v27 = 126 - 2 * __clz(0xAAAAAAAAAAAAAAABLL * (v7 - v15));
    if (v7 == v15) {
      uint64_t v28 = 0LL;
    }
    else {
      uint64_t v28 = v27;
    }
    _ZNSt3__111__introsortINS_17_ClassicAlgPolicyERZZZL18CollectCounterDataP21GTMTLReplayControllerP7NSArrayyS5_mP26GTMTLReplayOperationQueuesP11NSOperationjbjP21GTAGXPerfStateControlEUb_EUb0_E3__0PNS_6vectorIyNS_9allocatorIyEEEELb0EEEvT1_SJ_T0_NS_15iterator_traitsISJ_E15difference_typeEb( v15,  v7,  v28,  1);
    __p = 0LL;
    __dst = 0LL;
    uint64_t v49 = 0LL;
    std::vector<unsigned long long>::reserve( &__p,  ((*(void *)(a1 + 48) - *(void *)(a1 + 56)) >> 1) * *(void *)(a1 + 64));
    std::vector<unsigned long long>::__insert_with_size[abi:nn180100]<std::__wrap_iter<unsigned long long *>,std::__wrap_iter<unsigned long long *>>( &__p,  (char *)__dst,  *v50,  v50[1],  (v50[1] - *v50) >> 3);
    uint64_t v30 = v50;
    unsigned int v29 = v51;
    if (0xAAAAAAAAAAAAAAABLL * (((char *)v51 - (char *)v50) >> 3) >= 2)
    {
      unint64_t v31 = 1LL;
      do
      {
        uint64_t v32 = 0LL;
        id v33 = (char *)__p;
        int64_t v34 = ((_BYTE *)__dst - (_BYTE *)__p) >> 3;
        unint64_t v35 = *(void *)(a1 + 64);
        unint64_t v36 = v34 - v35;
        uint64_t v37 = v30[3 * v31];
        do
        {
          uint64_t v38 = CollectCounterData(GTMTLReplayController *,NSArray *,unsigned long long,NSArray *,unsigned long,GTMTLReplayOperationQueues *,NSOperation *,unsigned int,BOOL,unsigned int,GTAGXPerfStateControl *)::kCounterCompare[v32];
          uint64_t v39 = *((void *)__p + v36 + v38);
          uint64_t v40 = *(void *)&v37[8 * v38];
        }

        while (v39 == v40 && v32++ != 3);
        if (v39 == v40)
        {
          *((void *)__p + v36 + 3) += *((void *)v37 + 3);
          if (v35 >= 7)
          {
            unint64_t v42 = 6 - v35;
            unint64_t v43 = &v33[8 * v34];
            unint64_t v44 = (uint64_t *)(v37 + 48);
            do
            {
              uint64_t v45 = *v44++;
              *(void *)&v43[8 * v42] += v45;
            }

            while (!__CFADD__(v42++, 1LL));
          }
        }

        else
        {
          std::vector<unsigned long long>::__insert_with_size[abi:nn180100]<std::__wrap_iter<unsigned long long *>,std::__wrap_iter<unsigned long long *>>( &__p,  (char *)__dst,  v37,  v30[3 * v31 + 1],  (v30[3 * v31 + 1] - v37) >> 3);
          uint64_t v30 = v50;
          unsigned int v29 = v51;
        }

        ++v31;
      }

      while (v31 < 0xAAAAAAAAAAAAAAABLL * (((char *)v29 - (char *)v30) >> 3));
    }

    [*(id *)(a1 + 40) appendBytes:__p length:(_BYTE *)__dst - (_BYTE *)__p];
    if (__p)
    {
      __dst = __p;
      operator delete(__p);
    }
  }

  __p = &v50;
  std::vector<std::vector<DYMTLEncoderInfo>>::__destroy_vector::operator()[abi:nn180100]((void ***)&__p);
}

void sub_9B06C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, char *__p, char *a10, uint64_t a11, char a12)
{
  if (__p)
  {
    a10 = __p;
    operator delete(__p);
  }

  __p = &a12;
  std::vector<std::vector<DYMTLEncoderInfo>>::__destroy_vector::operator()[abi:nn180100]((void ***)&__p);
  _Unwind_Resume(a1);
}

void *__copy_helper_block_ea8_72c39_ZTSNSt3__16vectorIbNS_9allocatorIbEEEE(uint64_t a1, uint64_t a2)
{
  return std::vector<BOOL>::vector((void *)(a1 + 72), a2 + 72);
}

void __destroy_helper_block_ea8_72c39_ZTSNSt3__16vectorIbNS_9allocatorIbEEEE(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 72);
  if (v1) {
    operator delete(v1);
  }
}

void _ZNSt3__111__introsortINS_17_ClassicAlgPolicyERZZZL18CollectCounterDataP21GTMTLReplayControllerP7NSArrayyS5_mP26GTMTLReplayOperationQueuesP11NSOperationjbjP21GTAGXPerfStateControlEUb_EUb0_E3__0PNS_6vectorIyNS_9allocatorIyEEEELb0EEEvT1_SJ_T0_NS_15iterator_traitsISJ_E15difference_typeEb( uint64_t *a1, uint64_t *a2, uint64_t a3, char a4)
{
LABEL_1:
  id v196 = a2 - 3;
  unint64_t v8 = a1;
  while (2)
  {
    a1 = v8;
    uint64_t v9 = (char *)a2 - (char *)v8;
    uint64_t v10 = 0xAAAAAAAAAAAAAAABLL * (a2 - v8);
    switch(v10)
    {
      case 0LL:
      case 1LL:
        return;
      case 2LL:
        uint64_t v99 = 0LL;
        uint64_t v100 = *v196;
        uint64_t v101 = *v8;
        while (1)
        {
          uint64_t v102 = CollectCounterData(GTMTLReplayController *,NSArray *,unsigned long long,NSArray *,unsigned long,GTMTLReplayOperationQueues *,NSOperation *,unsigned int,BOOL,unsigned int,GTAGXPerfStateControl *)::kCounterCompare[v99];
          unint64_t v103 = *(void *)(v100 + 8 * v102);
          unint64_t v104 = *(void *)(v101 + 8 * v102);
          if (v103 != v104) {
            break;
          }
          if (++v99 == 4) {
            return;
          }
        }

        if (v103 < v104)
        {
          *unint64_t v8 = v100;
          *(a2 - 3) = v101;
          uint64_t v175 = v8[1];
          v8[1] = *(a2 - 2);
          *(a2 - 2) = v175;
          uint64_t v176 = v8[2];
          void v8[2] = *(a2 - 1);
          *(a2 - 1) = v176;
        }

        return;
      case 3LL:
        _ZNSt3__17__sort3B8nn180100INS_17_ClassicAlgPolicyERZZZL18CollectCounterDataP21GTMTLReplayControllerP7NSArrayyS5_mP26GTMTLReplayOperationQueuesP11NSOperationjbjP21GTAGXPerfStateControlEUb_EUb0_E3__0PNS_6vectorIyNS_9allocatorIyEEEEEEjT1_SJ_SJ_T0_( v8,  v8 + 3,  v196);
        return;
      case 4LL:
        _ZNSt3__17__sort4B8nn180100INS_17_ClassicAlgPolicyERZZZL18CollectCounterDataP21GTMTLReplayControllerP7NSArrayyS5_mP26GTMTLReplayOperationQueuesP11NSOperationjbjP21GTAGXPerfStateControlEUb_EUb0_E3__0PNS_6vectorIyNS_9allocatorIyEEEEEEvT1_SJ_SJ_SJ_T0_( v8,  v8 + 3,  v8 + 6,  v196);
        return;
      case 5LL:
        _ZNSt3__124__sort5_maybe_branchlessB8nn180100INS_17_ClassicAlgPolicyERZZZL18CollectCounterDataP21GTMTLReplayControllerP7NSArrayyS5_mP26GTMTLReplayOperationQueuesP11NSOperationjbjP21GTAGXPerfStateControlEUb_EUb0_E3__0PNS_6vectorIyNS_9allocatorIyEEEELi0EEEvT1_SJ_SJ_SJ_SJ_T0_( v8,  v8 + 3,  v8 + 6,  v8 + 9,  v196);
        return;
      default:
        if (v9 <= 575)
        {
          int v105 = v8 + 3;
          BOOL v107 = v8 == a2 || v105 == a2;
          if ((a4 & 1) != 0)
          {
            if (!v107)
            {
              unint64_t v108 = v8;
              do
              {
                uint64_t v109 = 0LL;
                unint64_t v110 = v108;
                unint64_t v108 = v105;
                uint64_t v111 = v110[3];
                while (1)
                {
                  uint64_t v112 = CollectCounterData(GTMTLReplayController *,NSArray *,unsigned long long,NSArray *,unsigned long,GTMTLReplayOperationQueues *,NSOperation *,unsigned int,BOOL,unsigned int,GTAGXPerfStateControl *)::kCounterCompare[v109];
                  unint64_t v113 = *(void *)(v111 + 8 * v112);
                  unint64_t v114 = *(void *)(*v110 + 8 * v112);
                  if (v113 != v114) {
                    break;
                  }
                  if (++v109 == 4) {
                    goto LABEL_153;
                  }
                }

                if (v113 < v114)
                {
                  __int128 v115 = *((_OWORD *)v110 + 2);
                  *int v105 = 0LL;
                  v105[1] = 0LL;
                  unint64_t v116 = v105;
                  void v105[2] = 0LL;
                  while (1)
                  {
                    int64_t v117 = v116;
                    unint64_t v116 = v110;
                    *(_OWORD *)int64_t v117 = *(_OWORD *)v110;
                    void v117[2] = v110[2];
                    *unint64_t v110 = 0LL;
                    v110[1] = 0LL;
                    v110[2] = 0LL;
                    if (v110 == v8) {
                      break;
                    }
                    uint64_t v118 = 0LL;
                    v110 -= 3;
                    while (1)
                    {
                      uint64_t v119 = CollectCounterData(GTMTLReplayController *,NSArray *,unsigned long long,NSArray *,unsigned long,GTMTLReplayOperationQueues *,NSOperation *,unsigned int,BOOL,unsigned int,GTAGXPerfStateControl *)::kCounterCompare[v118];
                      unint64_t v120 = *(void *)(v111 + 8 * v119);
                      unint64_t v121 = *(void *)(*(v116 - 3) + 8 * v119);
                      if (v120 != v121) {
                        break;
                      }
                      if (++v118 == 4) {
                        goto LABEL_150;
                      }
                    }

                    if (v120 >= v121) {
                      goto LABEL_150;
                    }
                  }

                  unint64_t v116 = v8;
LABEL_150:
                  uint64_t v122 = (void *)*v116;
                  if (*v116)
                  {
                    v116[1] = (uint64_t)v122;
                    __int128 v197 = v115;
                    operator delete(v122);
                    __int128 v115 = v197;
                  }

                  *unint64_t v116 = v111;
                  *(_OWORD *)(v116 + 1) = v115;
                }

LABEL_153:
                int v105 = v108 + 3;
              }

              while (v108 + 3 != a2);
            }
          }

          else if (!v107)
          {
            do
            {
              uint64_t v177 = 0LL;
              uint64_t v178 = a1;
              a1 = v105;
              uint64_t v179 = v178[3];
              while (1)
              {
                uint64_t v180 = CollectCounterData(GTMTLReplayController *,NSArray *,unsigned long long,NSArray *,unsigned long,GTMTLReplayOperationQueues *,NSOperation *,unsigned int,BOOL,unsigned int,GTAGXPerfStateControl *)::kCounterCompare[v177];
                unint64_t v181 = *(void *)(v179 + 8 * v180);
                unint64_t v182 = *(void *)(*v178 + 8 * v180);
                if (v181 != v182) {
                  break;
                }
                if (++v177 == 4) {
                  goto LABEL_232;
                }
              }

              if (v181 < v182)
              {
                __int128 v183 = *((_OWORD *)v178 + 2);
                *a1 = 0LL;
                a1[1] = 0LL;
                uint64_t v184 = a1;
                a1[2] = 0LL;
                do
                {
                  uint64_t v185 = 0LL;
                  v186 = v184;
                  uint64_t v184 = v178;
                  *(_OWORD *)v186 = *(_OWORD *)v178;
                  v186[2] = v178[2];
                  *uint64_t v178 = 0LL;
                  v178[1] = 0LL;
                  v178[2] = 0LL;
                  uint64_t v188 = *(v178 - 3);
                  v178 -= 3;
                  uint64_t v187 = v188;
                  while (1)
                  {
                    uint64_t v189 = CollectCounterData(GTMTLReplayController *,NSArray *,unsigned long long,NSArray *,unsigned long,GTMTLReplayOperationQueues *,NSOperation *,unsigned int,BOOL,unsigned int,GTAGXPerfStateControl *)::kCounterCompare[v185];
                    unint64_t v190 = *(void *)(v179 + 8 * v189);
                    unint64_t v191 = *(void *)(v187 + 8 * v189);
                    if (v190 != v191) {
                      break;
                    }
                    if (++v185 == 4) {
                      goto LABEL_231;
                    }
                  }
                }

                while (v190 < v191);
LABEL_231:
                *uint64_t v184 = v179;
                *(_OWORD *)(v184 + 1) = v183;
              }

          uint64_t v91 = v84;
LABEL_154:
          *(void *)uint64_t v91 = v89;
          *(_DWORD *)(v91 + _Block_object_dispose(va, 8) = v86;
          *(_DWORD *)(v91 + 12) = v87;
          *(void *)(v91 + 16) = v88;
LABEL_155:
          uint64_t v80 = v85 + 24;
          v83 += 24LL;
          unint64_t v84 = v85;
        }

        while ((unint64_t *)(v85 + 24) != a2);
        return result;
    }
  }

LABEL_232:
              int v105 = a1 + 3;
            }

            while (a1 + 3 != a2);
          }

          return;
        }

        if (!a3)
        {
          if (v8 == a2) {
            return;
          }
          int64_t v123 = (unint64_t)(v10 - 2) >> 1;
          int64_t v124 = v123;
          do
          {
            int64_t v125 = v124;
            if (v123 < v124) {
              goto LABEL_186;
            }
            uint64_t v126 = (2 * v124) | 1;
            unint64_t v127 = &v8[3 * v126];
            if (2 * v125 + 2 < v10)
            {
              uint64_t v128 = 0LL;
              while (1)
              {
                uint64_t v129 = CollectCounterData(GTMTLReplayController *,NSArray *,unsigned long long,NSArray *,unsigned long,GTMTLReplayOperationQueues *,NSOperation *,unsigned int,BOOL,unsigned int,GTAGXPerfStateControl *)::kCounterCompare[v128];
                unint64_t v130 = *(void *)(*v127 + 8 * v129);
                unint64_t v131 = *(void *)(v127[3] + 8 * v129);
                if (v130 != v131) {
                  break;
                }
                if (++v128 == 4) {
                  goto LABEL_165;
                }
              }

              if (v130 < v131)
              {
                v127 += 3;
                uint64_t v126 = 2 * v125 + 2;
              }
            }

LABEL_165:
            uint64_t v132 = 0LL;
            id v133 = &v8[3 * v125];
            uint64_t v134 = *v133;
            while (1)
            {
              uint64_t v135 = CollectCounterData(GTMTLReplayController *,NSArray *,unsigned long long,NSArray *,unsigned long,GTMTLReplayOperationQueues *,NSOperation *,unsigned int,BOOL,unsigned int,GTAGXPerfStateControl *)::kCounterCompare[v132];
              unint64_t v136 = *(void *)(*v127 + 8 * v135);
              unint64_t v137 = *(void *)(v134 + 8 * v135);
              if (v136 != v137) {
                break;
              }
              if (++v132 == 4) {
                goto LABEL_170;
              }
            }

            if (v136 < v137) {
              goto LABEL_186;
            }
LABEL_170:
            __int128 v138 = *(_OWORD *)&v8[3 * v125 + 1];
            *id v133 = 0LL;
            v133[1] = 0LL;
            v133[2] = 0LL;
LABEL_171:
            do
            {
              unint64_t v139 = v127;
              *(_OWORD *)id v133 = *(_OWORD *)v127;
              v133[2] = v127[2];
              *unint64_t v127 = 0LL;
              v127[1] = 0LL;
              v127[2] = 0LL;
              if (v123 < v126) {
                break;
              }
              uint64_t v140 = (2 * v126) | 1;
              unint64_t v127 = &v8[3 * v140];
              uint64_t v126 = 2 * v126 + 2;
              if (v126 >= v10)
              {
LABEL_176:
                uint64_t v126 = v140;
              }

              else
              {
                uint64_t v141 = 0LL;
                while (1)
                {
                  uint64_t v142 = CollectCounterData(GTMTLReplayController *,NSArray *,unsigned long long,NSArray *,unsigned long,GTMTLReplayOperationQueues *,NSOperation *,unsigned int,BOOL,unsigned int,GTAGXPerfStateControl *)::kCounterCompare[v141];
                  unint64_t v143 = *(void *)(*v127 + 8 * v142);
                  unint64_t v144 = *(void *)(v127[3] + 8 * v142);
                  if (v143 != v144) {
                    break;
                  }
                  if (++v141 == 4) {
                    goto LABEL_176;
                  }
                }

                if (v143 >= v144) {
                  uint64_t v126 = v140;
                }
                else {
                  v127 += 3;
                }
              }

              uint64_t v145 = 0LL;
              while (1)
              {
                uint64_t v146 = CollectCounterData(GTMTLReplayController *,NSArray *,unsigned long long,NSArray *,unsigned long,GTMTLReplayOperationQueues *,NSOperation *,unsigned int,BOOL,unsigned int,GTAGXPerfStateControl *)::kCounterCompare[v145];
                unint64_t v147 = *(void *)(*v127 + 8 * v146);
                unint64_t v148 = *(void *)(v134 + 8 * v146);
                if (v147 != v148) {
                  break;
                }
                if (++v145 == 4)
                {
                  id v133 = v139;
                  goto LABEL_171;
                }
              }

              id v133 = v139;
            }

            while (v147 >= v148);
            *unint64_t v139 = v134;
            *(_OWORD *)(v139 + 1) = v138;
LABEL_186:
            int64_t v124 = v125 - 1;
          }

          while (v125);
          int64_t v149 = v9 / 0x18uLL;
          while (2)
          {
            uint64_t v150 = 0LL;
            uint64_t v152 = *v8;
            uint64_t v151 = v8[1];
            uint64_t v153 = v8[2];
            v8[1] = 0LL;
            void v8[2] = 0LL;
            __int128 v154 = v8;
            *unint64_t v8 = 0LL;
            do
            {
              uint64_t v155 = v154;
              v154 += 3 * v150 + 3;
              uint64_t v156 = 2 * v150;
              uint64_t v150 = (2 * v150) | 1;
              if (v156 + 2 < v149)
              {
                uint64_t v157 = 0LL;
                while (1)
                {
                  uint64_t v158 = CollectCounterData(GTMTLReplayController *,NSArray *,unsigned long long,NSArray *,unsigned long,GTMTLReplayOperationQueues *,NSOperation *,unsigned int,BOOL,unsigned int,GTAGXPerfStateControl *)::kCounterCompare[v157];
                  unint64_t v159 = *(void *)(*v154 + 8 * v158);
                  unint64_t v160 = *(void *)(v154[3] + 8 * v158);
                  if (v159 != v160) {
                    break;
                  }
                  if (++v157 == 4) {
                    goto LABEL_196;
                  }
                }

                if (v159 < v160)
                {
                  v154 += 3;
                  uint64_t v150 = v156 + 2;
                }
              }

LABEL_196:
              *(_OWORD *)uint64_t v155 = *(_OWORD *)v154;
              v155[2] = v154[2];
              *__int128 v154 = 0LL;
              v154[1] = 0LL;
              v154[2] = 0LL;
            }

            while (v150 <= (uint64_t)((unint64_t)(v149 - 2) >> 1));
            if (v154 != a2 - 3)
            {
              *(_OWORD *)__int128 v154 = *(_OWORD *)(a2 - 3);
              v154[2] = *(a2 - 1);
              *(a2 - 3) = v152;
              *(a2 - 2) = v151;
              *(a2 - 1) = v153;
              uint64_t v161 = (char *)v154 - (char *)v8 + 24;
              if (v161 >= 25)
              {
                uint64_t v162 = 0LL;
                unint64_t v163 = (v161 / 0x18uLL - 2) >> 1;
                id v164 = &v8[3 * v163];
                uint64_t v165 = *v154;
                while (1)
                {
                  uint64_t v166 = CollectCounterData(GTMTLReplayController *,NSArray *,unsigned long long,NSArray *,unsigned long,GTMTLReplayOperationQueues *,NSOperation *,unsigned int,BOOL,unsigned int,GTAGXPerfStateControl *)::kCounterCompare[v162];
                  unint64_t v167 = *(void *)(*v164 + 8 * v166);
                  unint64_t v168 = *(void *)(v165 + 8 * v166);
                  if (v167 != v168) {
                    break;
                  }
                  if (++v162 == 4) {
                    goto LABEL_205;
                  }
                }

                if (v167 < v168)
                {
                  uint64_t v151 = v154[1];
                  uint64_t v153 = v154[2];
                  v154[1] = 0LL;
                  v154[2] = 0LL;
                  __int128 v170 = v154;
                  *__int128 v154 = 0LL;
                  do
                  {
                    __int128 v154 = v164;
                    *(_OWORD *)__int128 v170 = *(_OWORD *)v164;
                    v170[2] = v164[2];
                    *id v164 = 0LL;
                    v164[1] = 0LL;
                    v164[2] = 0LL;
                    if (!v163) {
                      break;
                    }
                    uint64_t v171 = 0LL;
                    unint64_t v163 = (v163 - 1) >> 1;
                    id v164 = &v8[3 * v163];
                    while (1)
                    {
                      uint64_t v172 = CollectCounterData(GTMTLReplayController *,NSArray *,unsigned long long,NSArray *,unsigned long,GTMTLReplayOperationQueues *,NSOperation *,unsigned int,BOOL,unsigned int,GTAGXPerfStateControl *)::kCounterCompare[v171];
                      unint64_t v173 = *(void *)(*v164 + 8 * v172);
                      unint64_t v174 = *(void *)(v165 + 8 * v172);
                      if (v173 != v174) {
                        break;
                      }
                      if (++v171 == 4) {
                        goto LABEL_216;
                      }
                    }

                    __int128 v170 = v154;
                  }

                  while (v173 < v174);
LABEL_216:
                  *__int128 v154 = v165;
LABEL_204:
                  v154[1] = v151;
                  v154[2] = v153;
                }
              }

LABEL_205:
              a2 -= 3;
              if (v149-- <= 2) {
                return;
              }
              continue;
            }

            break;
          }

          *__int128 v154 = v152;
          goto LABEL_204;
        }

        unint64_t v11 = (unint64_t)v10 >> 1;
        uint64_t v12 = &v8[3 * ((unint64_t)v10 >> 1)];
        if ((unint64_t)v9 < 0xC01)
        {
          _ZNSt3__17__sort3B8nn180100INS_17_ClassicAlgPolicyERZZZL18CollectCounterDataP21GTMTLReplayControllerP7NSArrayyS5_mP26GTMTLReplayOperationQueuesP11NSOperationjbjP21GTAGXPerfStateControlEUb_EUb0_E3__0PNS_6vectorIyNS_9allocatorIyEEEEEEjT1_SJ_SJ_T0_( &a1[3 * v11],  a1,  v196);
        }

        else
        {
          _ZNSt3__17__sort3B8nn180100INS_17_ClassicAlgPolicyERZZZL18CollectCounterDataP21GTMTLReplayControllerP7NSArrayyS5_mP26GTMTLReplayOperationQueuesP11NSOperationjbjP21GTAGXPerfStateControlEUb_EUb0_E3__0PNS_6vectorIyNS_9allocatorIyEEEEEEjT1_SJ_SJ_T0_( a1,  &a1[3 * v11],  v196);
          uint64_t v13 = 3 * v11;
          int v14 = &a1[v13];
          _ZNSt3__17__sort3B8nn180100INS_17_ClassicAlgPolicyERZZZL18CollectCounterDataP21GTMTLReplayControllerP7NSArrayyS5_mP26GTMTLReplayOperationQueuesP11NSOperationjbjP21GTAGXPerfStateControlEUb_EUb0_E3__0PNS_6vectorIyNS_9allocatorIyEEEEEEjT1_SJ_SJ_T0_( a1 + 3,  v14 - 3,  a2 - 6);
          _ZNSt3__17__sort3B8nn180100INS_17_ClassicAlgPolicyERZZZL18CollectCounterDataP21GTMTLReplayControllerP7NSArrayyS5_mP26GTMTLReplayOperationQueuesP11NSOperationjbjP21GTAGXPerfStateControlEUb_EUb0_E3__0PNS_6vectorIyNS_9allocatorIyEEEEEEjT1_SJ_SJ_T0_( a1 + 6,  &a1[v13 + 3],  a2 - 9);
          _ZNSt3__17__sort3B8nn180100INS_17_ClassicAlgPolicyERZZZL18CollectCounterDataP21GTMTLReplayControllerP7NSArrayyS5_mP26GTMTLReplayOperationQueuesP11NSOperationjbjP21GTAGXPerfStateControlEUb_EUb0_E3__0PNS_6vectorIyNS_9allocatorIyEEEEEEjT1_SJ_SJ_T0_( v14 - 3,  v12,  &a1[v13 + 3]);
          __int128 v18 = *(_OWORD *)a1;
          *(_OWORD *)a1 = *(_OWORD *)v12;
          *(_OWORD *)uint64_t v12 = v18;
          uint64_t v19 = a1[2];
          a1[2] = v14[2];
          v14[2] = v19;
        }

        --a3;
        uint64_t v20 = *a1;
        if ((a4 & 1) == 0)
        {
          uint64_t v21 = 0LL;
          while (1)
          {
            uint64_t v22 = CollectCounterData(GTMTLReplayController *,NSArray *,unsigned long long,NSArray *,unsigned long,GTMTLReplayOperationQueues *,NSOperation *,unsigned int,BOOL,unsigned int,GTAGXPerfStateControl *)::kCounterCompare[v21];
            unint64_t v23 = *(void *)(*(a1 - 3) + 8 * v22);
            unint64_t v24 = *(void *)(v20 + 8 * v22);
            if (v23 != v24) {
              break;
            }
            if (++v21 == 4) {
              goto LABEL_12;
            }
          }

          if (v23 >= v24)
          {
LABEL_12:
            uint64_t v25 = 0LL;
            __int128 v26 = *(_OWORD *)(a1 + 1);
            *a1 = 0LL;
            a1[1] = 0LL;
            a1[2] = 0LL;
            while (1)
            {
              uint64_t v27 = CollectCounterData(GTMTLReplayController *,NSArray *,unsigned long long,NSArray *,unsigned long,GTMTLReplayOperationQueues *,NSOperation *,unsigned int,BOOL,unsigned int,GTAGXPerfStateControl *)::kCounterCompare[v25];
              unint64_t v28 = *(void *)(v20 + 8 * v27);
              unint64_t v29 = *(void *)(*v196 + 8 * v27);
              if (v28 != v29) {
                break;
              }
              if (++v25 == 4)
              {
                unint64_t v8 = a1;
                do
                {
LABEL_78:
                  v8 += 3;
                  if (v8 >= a2) {
                    break;
                  }
                  uint64_t v74 = 0LL;
                  while (1)
                  {
                    uint64_t v75 = CollectCounterData(GTMTLReplayController *,NSArray *,unsigned long long,NSArray *,unsigned long,GTMTLReplayOperationQueues *,NSOperation *,unsigned int,BOOL,unsigned int,GTAGXPerfStateControl *)::kCounterCompare[v74];
                    unint64_t v76 = *(void *)(v20 + 8 * v75);
                    unint64_t v77 = *(void *)(*v8 + 8 * v75);
                    if (v76 != v77) {
                      break;
                    }
                    if (++v74 == 4) {
                      goto LABEL_84;
                    }
                  }

                  BOOL v15 = v76 < v77;
LABEL_84:
                  ;
                }

                while (v76 == v77 || !v15);
                goto LABEL_86;
              }
            }

            unint64_t v8 = a1;
            if (v28 >= v29) {
              goto LABEL_78;
            }
            do
            {
              uint64_t v68 = 0LL;
              uint64_t v70 = v8[3];
              v8 += 3;
              uint64_t v69 = v70;
              while (1)
              {
                uint64_t v71 = CollectCounterData(GTMTLReplayController *,NSArray *,unsigned long long,NSArray *,unsigned long,GTMTLReplayOperationQueues *,NSOperation *,unsigned int,BOOL,unsigned int,GTAGXPerfStateControl *)::kCounterCompare[v68];
                unint64_t v72 = *(void *)(v20 + 8 * v71);
                unint64_t v73 = *(void *)(v69 + 8 * v71);
                if (v72 != v73) {
                  break;
                }
                if (++v68 == 4) {
                  goto LABEL_75;
                }
              }

              BOOL v15 = v72 < v73;
LABEL_75:
              ;
            }

            while (v72 == v73 || !v15);
LABEL_86:
            unint64_t v78 = a2;
            if (v8 < a2)
            {
              unint64_t v78 = a2;
              do
              {
                uint64_t v79 = 0LL;
                uint64_t v81 = *(v78 - 3);
                v78 -= 3;
                uint64_t v80 = v81;
                while (1)
                {
                  uint64_t v82 = CollectCounterData(GTMTLReplayController *,NSArray *,unsigned long long,NSArray *,unsigned long,GTMTLReplayOperationQueues *,NSOperation *,unsigned int,BOOL,unsigned int,GTAGXPerfStateControl *)::kCounterCompare[v79];
                  unint64_t v83 = *(void *)(v20 + 8 * v82);
                  unint64_t v84 = *(void *)(v80 + 8 * v82);
                  if (v83 != v84) {
                    break;
                  }
                  if (++v79 == 4) {
                    goto LABEL_93;
                  }
                }
              }

              while (v83 < v84);
            }

                a2 = v111 - 16;
              }

              while (v110-- > 2);
            }

            return result;
          }

          int v14 = (unint64_t)v13 >> 1;
          BOOL v15 = &v7[4 * ((unint64_t)v13 >> 1)];
          if ((unint64_t)v12 < 0x801)
          {
            std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::tuple<unsigned int,unsigned int,unsigned int,unsigned int> *>( v15,  v7,  v8);
          }

          else
          {
            std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::tuple<unsigned int,unsigned int,unsigned int,unsigned int> *>( v7,  v15,  v8);
            std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::tuple<unsigned int,unsigned int,unsigned int,unsigned int> *>( v7 + 4,  v15 - 4,  v9);
            std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::tuple<unsigned int,unsigned int,unsigned int,unsigned int> *>( v7 + 8,  &v7[4 * v14 + 4],  v10);
            std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::tuple<unsigned int,unsigned int,unsigned int,unsigned int> *>( v15 - 4,  v15,  &v7[4 * v14 + 4]);
            unint64_t v16 = *(_OWORD *)v7;
            *(_OWORD *)unint64_t v7 = *(_OWORD *)v15;
            *(_OWORD *)BOOL v15 = v16;
          }

          --a3;
          a2 = v152;
          if ((a4 & 1) == 0)
          {
            BOOL result = std::__tuple_less<4ul>::operator()[abi:nn180100]<std::tuple<unsigned int,unsigned int,unsigned int,unsigned int>,std::tuple<unsigned int,unsigned int,unsigned int,unsigned int>>( v7 - 4,  v7);
            if ((result & 1) == 0)
            {
              uint64_t v46 = *v7;
              uint64_t v47 = v7[1];
              uint64_t v48 = v7[2];
              uint64_t v49 = v7[3];
              unint64_t v50 = *v8;
              if (*v7 < *v8
                || v50 >= v46
                && ((unint64_t v72 = *((_DWORD *)v152 - 3), v47 < v72)
                 || v72 >= v47
                 && ((unint64_t v73 = *((_DWORD *)v152 - 2), v48 < v73) || v73 >= v48 && v49 < *((_DWORD *)v152 - 1))))
              {
                uint64_t i = v7;
                while (1)
                {
                  uint64_t v52 = i[4];
                  i += 4;
                  unint64_t v51 = v52;
                  if (v46 < v52) {
                    break;
                  }
                  if (v51 >= v46)
                  {
                    unint64_t v53 = i[1];
                    if (v47 < v53) {
                      break;
                    }
                    if (v53 >= v47)
                    {
                      uint64_t v54 = i[2];
                      if (v48 < v54 || v54 >= v48 && v49 < i[3]) {
                        break;
                      }
                    }
                  }
                }
              }

              else
              {
                for (uint64_t i = v7 + 4; i < (int *)v152; i += 4)
                {
                  if (v46 < *i) {
                    break;
                  }
                  if (*i >= v46)
                  {
                    uint64_t v70 = i[1];
                    if (v47 < v70) {
                      break;
                    }
                    if (v70 >= v47)
                    {
                      uint64_t v71 = i[2];
                      if (v48 < v71 || v71 >= v48 && v49 < i[3]) {
                        break;
                      }
                    }
                  }
                }
              }

              unint64_t j = (int *)v152;
              if (i < (int *)v152)
              {
                for (unint64_t j = v8; ; j -= 4)
                {
                  if (v46 >= v50)
                  {
                    if (v50 < v46) {
                      break;
                    }
                    uint64_t v56 = j[1];
                    if (v47 >= v56)
                    {
                      if (v56 < v47) {
                        break;
                      }
                      uint64_t v57 = j[2];
                      if (v48 >= v57 && (v57 < v48 || v49 >= j[3])) {
                        break;
                      }
                    }
                  }

                  uint64_t v58 = *(j - 4);
                  unint64_t v50 = v58;
                }
              }

              if (i < j)
              {
                unint64_t v59 = *i;
                unint64_t v60 = *j;
                do
                {
                  void *i = v60;
                  *unint64_t j = v59;
                  uint64_t v61 = i[1];
                  i[1] = j[1];
                  j[1] = v61;
                  uint64_t v62 = i[2];
                  i[2] = j[2];
                  j[2] = v62;
                  uint64_t v63 = i[3];
                  i[3] = j[3];
                  j[3] = v63;
                  while (1)
                  {
                    unint64_t v64 = i[4];
                    i += 4;
                    unint64_t v59 = v64;
                    if (v46 < v64) {
                      break;
                    }
                    if (v59 >= v46)
                    {
                      unint64_t v65 = i[1];
                      if (v47 < v65) {
                        break;
                      }
                      if (v65 >= v47)
                      {
                        unint64_t v66 = i[2];
                        if (v48 < v66 || v66 >= v48 && v49 < i[3]) {
                          break;
                        }
                      }
                    }
                  }

                  while (1)
                  {
                    do
                    {
                      BOOL v67 = *(j - 4);
                      j -= 4;
                      unint64_t v60 = v67;
                    }

                    while (v46 < v67);
                    if (v60 < v46) {
                      break;
                    }
                    uint64_t v68 = j[1];
                    if (v47 >= v68)
                    {
                      if (v68 < v47) {
                        break;
                      }
                      uint64_t v69 = j[2];
                      if (v48 >= v69 && (v69 < v48 || v49 >= j[3])) {
                        break;
                      }
                    }
                  }
                }

                while (i < j);
              }

              if (i - 4 != v7)
              {
                *unint64_t v7 = *(i - 4);
                v7[1] = *(i - 3);
                v7[2] = *(i - 2);
                v7[3] = *(i - 1);
              }

              a4 = 0;
              *(i - 4) = v46;
              *(i - 3) = v47;
              *(i - 2) = v48;
              *(i - 1) = v49;
              continue;
            }
          }

          BOOL v17 = *v7;
          __int128 v18 = v7[1];
          uint64_t v19 = (char *)(v7 + 4);
          uint64_t v21 = v7[2];
          uint64_t v20 = v7[3];
          while (1)
          {
            uint64_t v22 = *(_DWORD *)v19;
            if (*(_DWORD *)v19 >= v17)
            {
              if (v17 < v22) {
                break;
              }
              unint64_t v23 = *((_DWORD *)v19 + 1);
              if (v23 >= v18)
              {
                if (v18 < v23) {
                  break;
                }
                unint64_t v24 = *((_DWORD *)v19 + 2);
                if (v24 >= v21 && (v21 < v24 || *((_DWORD *)v19 + 3) >= v20)) {
                  break;
                }
              }
            }

            v19 += 16;
          }

          if (v19 - 16 == (char *)v7)
          {
            uint64_t k = v152;
            if (v19 < v152)
            {
              __int128 v30 = *v8;
              uint64_t k = (char *)v8;
              if (*v8 >= v17)
              {
                uint64_t k = (char *)v8;
                do
                {
                  if (v17 >= v30)
                  {
                    unint64_t v31 = *((_DWORD *)k + 1);
                    if (v31 < v18) {
                      break;
                    }
                    if (v18 >= v31)
                    {
                      uint64_t v32 = *((_DWORD *)k + 2);
                      if (v32 < v21 || v21 >= v32 && *((_DWORD *)k + 3) < v20) {
                        break;
                      }
                    }
                  }

                  if (v19 >= k) {
                    break;
                  }
                  id v33 = *((_DWORD *)k - 4);
                  k -= 16;
                  __int128 v30 = v33;
                }

                while (v33 >= v17);
              }
            }
          }

          else
          {
            uint64_t v25 = *v8;
            for (uint64_t k = (char *)v8; v25 >= v17; k -= 16)
            {
              if (v17 >= v25)
              {
                uint64_t v27 = *((_DWORD *)k + 1);
                if (v27 < v18) {
                  break;
                }
                if (v18 >= v27)
                {
                  unint64_t v28 = *((_DWORD *)k + 2);
                  if (v28 < v21 || v21 >= v28 && *((_DWORD *)k + 3) < v20) {
                    break;
                  }
                }
              }

              unint64_t v29 = *((_DWORD *)k - 4);
              uint64_t v25 = v29;
            }
          }

          uint64_t i = (int *)v19;
          if (v19 < k)
          {
            uint64_t v34 = *(_DWORD *)k;
            uint64_t i = (int *)v19;
            uint64_t v35 = (int *)k;
            do
            {
              void *i = v34;
              NSArray *v35 = v22;
              uint64_t v36 = i[1];
              i[1] = v35[1];
              v35[1] = v36;
              unint64_t v37 = i[2];
              i[2] = v35[2];
              v35[2] = v37;
              unint64_t v38 = i[3];
              i[3] = v35[3];
              v35[3] = v38;
              while (1)
              {
                do
                {
                  uint64_t v39 = i[4];
                  i += 4;
                  uint64_t v22 = v39;
                }

                while (v39 < v17);
                if (v17 < v22) {
                  break;
                }
                uint64_t v40 = i[1];
                if (v40 >= v18)
                {
                  if (v18 < v40) {
                    break;
                  }
                  uint64_t v41 = i[2];
                  if (v41 >= v21 && (v21 < v41 || i[3] >= v20)) {
                    break;
                  }
                }
              }

              while (1)
              {
                uint64_t v42 = *(v35 - 4);
                v35 -= 4;
                uint64_t v34 = v42;
                if (v42 < v17) {
                  break;
                }
                if (v17 >= v34)
                {
                  uint64_t v43 = v35[1];
                  if (v43 < v18) {
                    break;
                  }
                  if (v18 >= v43)
                  {
                    unint64_t v44 = v35[2];
                    if (v44 < v21 || v21 >= v44 && v35[3] < v20) {
                      break;
                    }
                  }
                }
              }
            }

            while (i < v35);
          }

          if (i - 4 != v7)
          {
            *unint64_t v7 = *(i - 4);
            v7[1] = *(i - 3);
            v7[2] = *(i - 2);
            v7[3] = *(i - 1);
          }

          *(i - 4) = v17;
          *(i - 3) = v18;
          *(i - 2) = v21;
          *(i - 1) = v20;
          if (v19 < k)
          {
LABEL_64:
            BOOL result = std::__introsort<std::_ClassicAlgPolicy,std::__less<void,void> &,std::tuple<unsigned int,unsigned int,unsigned int,unsigned int> *,false>( v7,  i - 4,  a3,  a4 & 1);
            a4 = 0;
            continue;
          }

          unint64_t v45 = std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::tuple<unsigned int,unsigned int,unsigned int,unsigned int> *>( v7,  (char *)i - 16);
          BOOL result = std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::tuple<unsigned int,unsigned int,unsigned int,unsigned int> *>( i,  v152);
          if (!(_DWORD)result)
          {
            if (v45) {
              continue;
            }
            goto LABEL_64;
          }

          a2 = (char *)(i - 4);
          if (v45) {
            return result;
          }
          goto LABEL_2;
        }

        unint64_t v78 = (char *)(v7 + 4);
        uint64_t v80 = v7 == (int *)a2 || v78 == a2;
        if ((a4 & 1) == 0)
        {
          if (!v80)
          {
            do
            {
              uint64_t v134 = v78;
              BOOL result = std::__tuple_less<4ul>::operator()[abi:nn180100]<std::tuple<unsigned int,unsigned int,unsigned int,unsigned int>,std::tuple<unsigned int,unsigned int,unsigned int,unsigned int>>( v78,  v7);
              if ((_DWORD)result)
              {
                uint64_t v135 = *(_DWORD *)v134;
                unint64_t v136 = v7[5];
                unint64_t v137 = v7[6];
                __int128 v138 = v7[7];
                unint64_t v139 = *v7;
                while (1)
                {
                  do
                  {
                    uint64_t v140 = v7;
                    uint64_t v141 = v139;
                    uint64_t v142 = *(v7 - 4);
                    v7 -= 4;
                    unint64_t v139 = v142;
                    v7[8] = v141;
                    *(void *)(v7 + 9) = *(void *)(v7 + 5);
                    v7[11] = v7[7];
                  }

                  while (v135 < v142);
                  if (v139 < v135) {
                    break;
                  }
                  unint64_t v143 = *(v140 - 3);
                  if (v136 >= v143)
                  {
                    if (v143 < v136) {
                      break;
                    }
                    unint64_t v144 = *(v140 - 2);
                    if (v137 >= v144 && (v144 < v137 || v138 >= *(v140 - 1))) {
                      break;
                    }
                  }
                }

                void *v140 = v135;
                v140[1] = v136;
                v140[2] = v137;
                v140[3] = v138;
              }

              unint64_t v78 = v134 + 16;
              unint64_t v7 = (int *)v134;
            }

            while (v134 + 16 != a2);
          }

          return result;
        }

        if (v80) {
          return result;
        }
        uint64_t v81 = 0LL;
        uint64_t v82 = v7;
        do
        {
          unint64_t v83 = v78;
          BOOL result = std::__tuple_less<4ul>::operator()[abi:nn180100]<std::tuple<unsigned int,unsigned int,unsigned int,unsigned int>,std::tuple<unsigned int,unsigned int,unsigned int,unsigned int>>( v78,  v82);
          if (!(_DWORD)result) {
            goto LABEL_154;
          }
          unint64_t v84 = v82[4];
          uint64_t v85 = v82[5];
          uint64_t v86 = v82[6];
          uint64_t v87 = v82[7];
          uint64_t v88 = v82[1];
          v82[4] = *v82;
          *((_DWORD *)v83 + 1) = v88;
          *((_DWORD *)v83 + 2) = v82[2];
          *((_DWORD *)v83 + 3) = v82[3];
          uint64_t v89 = v7;
          if (v82 == v7) {
            goto LABEL_153;
          }
          uint64_t v90 = v81;
          while (1)
          {
            uint64_t v91 = *(int *)((char *)v7 + v90 - 16);
            if (v84 < v91)
            {
              unint64_t v92 = *(int *)((char *)v7 + v90 - 12);
              goto LABEL_150;
            }

            if (v91 < v84) {
              goto LABEL_152;
            }
            unint64_t v92 = *(int *)((char *)v7 + v90 - 12);
            if (v85 >= v92)
            {
              if (v92 < v85) {
                goto LABEL_152;
              }
              unint64_t v93 = *(int *)((char *)v7 + v90 - 8);
              if (v86 >= v93) {
                break;
              }
            }

                a2 = v113 - 32;
              }

              while (v112-- > 2);
            }

            return result;
          }

          int v14 = (unint64_t)v13 >> 1;
          BOOL v15 = &v7[4 * ((unint64_t)v13 >> 1)];
          if ((unint64_t)v12 <= 0x1000)
          {
            std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::tuple<unsigned long long,unsigned long long,unsigned long long,unsigned long long> *>( v15,  v7,  v8);
          }

          else
          {
            std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::tuple<unsigned long long,unsigned long long,unsigned long long,unsigned long long> *>( v7,  v15,  v8);
            std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::tuple<unsigned long long,unsigned long long,unsigned long long,unsigned long long> *>( v7 + 4,  v15 - 4,  v9);
            std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::tuple<unsigned long long,unsigned long long,unsigned long long,unsigned long long> *>( v7 + 8,  &v7[4 * v14 + 4],  v10);
            std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::tuple<unsigned long long,unsigned long long,unsigned long long,unsigned long long> *>( v15 - 4,  v15,  &v7[4 * v14 + 4]);
            unint64_t v16 = *(_OWORD *)v7;
            BOOL v17 = *((_OWORD *)v7 + 1);
            __int128 v18 = *((_OWORD *)v15 + 1);
            *(_OWORD *)unint64_t v7 = *(_OWORD *)v15;
            *((_OWORD *)v7 + 1) = v18;
            *(_OWORD *)BOOL v15 = v16;
            *((_OWORD *)v15 + 1) = v17;
          }

          --a3;
          a2 = v154;
          if ((a4 & 1) == 0)
          {
            BOOL result = std::__tuple_less<4ul>::operator()[abi:nn180100]<std::tuple<unsigned long long,unsigned long long,unsigned long long,unsigned long long>,std::tuple<unsigned long long,unsigned long long,unsigned long long,unsigned long long>>( v7 - 4,  v7);
            if ((result & 1) == 0)
            {
              uint64_t v48 = *v7;
              uint64_t v49 = v7[1];
              unint64_t v50 = v7[2];
              unint64_t v51 = v7[3];
              uint64_t v52 = *v8;
              if (*v7 < (unint64_t)*v8
                || v52 >= v48
                && ((uint64_t v74 = *((void *)v154 - 3), v49 < v74)
                 || v74 >= v49
                 && ((uint64_t v75 = *((void *)v154 - 2), v50 < v75) || v75 >= v50 && v51 < *((void *)v154 - 1))))
              {
                uint64_t i = v7;
                while (1)
                {
                  uint64_t v54 = i[4];
                  i += 4;
                  unint64_t v53 = v54;
                  if (v48 < v54) {
                    break;
                  }
                  if (v53 >= v48)
                  {
                    uint64_t v55 = i[1];
                    if (v49 < v55) {
                      break;
                    }
                    if (v55 >= v49)
                    {
                      uint64_t v56 = i[2];
                      if (v50 < v56 || v56 >= v50 && v51 < i[3]) {
                        break;
                      }
                    }
                  }
                }
              }

              else
              {
                for (uint64_t i = v7 + 4; i < (uint64_t *)v154; i += 4)
                {
                  if (v48 < *i) {
                    break;
                  }
                  if (*i >= v48)
                  {
                    unint64_t v72 = i[1];
                    if (v49 < v72) {
                      break;
                    }
                    if (v72 >= v49)
                    {
                      unint64_t v73 = i[2];
                      if (v50 < v73 || v73 >= v50 && v51 < i[3]) {
                        break;
                      }
                    }
                  }
                }
              }

              unint64_t j = (uint64_t *)v154;
              if (i < (uint64_t *)v154)
              {
                for (unint64_t j = v8; ; j -= 4)
                {
                  if (v48 >= v52)
                  {
                    if (v52 < v48) {
                      break;
                    }
                    uint64_t v58 = j[1];
                    if (v49 >= v58)
                    {
                      if (v58 < v49) {
                        break;
                      }
                      unint64_t v59 = j[2];
                      if (v50 >= v59 && (v59 < v50 || v51 >= j[3])) {
                        break;
                      }
                    }
                  }

                  unint64_t v60 = *(j - 4);
                  uint64_t v52 = v60;
                }
              }

              if (i < j)
              {
                uint64_t v61 = *i;
                uint64_t v62 = *j;
                do
                {
                  void *i = v62;
                  *unint64_t j = v61;
                  uint64_t v63 = i[1];
                  i[1] = j[1];
                  j[1] = v63;
                  unint64_t v64 = i[2];
                  i[2] = j[2];
                  j[2] = v64;
                  unint64_t v65 = i[3];
                  i[3] = j[3];
                  j[3] = v65;
                  while (1)
                  {
                    unint64_t v66 = i[4];
                    i += 4;
                    uint64_t v61 = v66;
                    if (v48 < v66) {
                      break;
                    }
                    if (v61 >= v48)
                    {
                      BOOL v67 = i[1];
                      if (v49 < v67) {
                        break;
                      }
                      if (v67 >= v49)
                      {
                        uint64_t v68 = i[2];
                        if (v50 < v68 || v68 >= v50 && v51 < i[3]) {
                          break;
                        }
                      }
                    }
                  }

                  while (1)
                  {
                    do
                    {
                      uint64_t v69 = *(j - 4);
                      j -= 4;
                      uint64_t v62 = v69;
                    }

                    while (v48 < v69);
                    if (v62 < v48) {
                      break;
                    }
                    uint64_t v70 = j[1];
                    if (v49 >= v70)
                    {
                      if (v70 < v49) {
                        break;
                      }
                      uint64_t v71 = j[2];
                      if (v50 >= v71 && (v71 < v50 || v51 >= j[3])) {
                        break;
                      }
                    }
                  }
                }

                while (i < j);
              }

              if (i - 4 != v7)
              {
                *unint64_t v7 = *(i - 4);
                v7[1] = *(i - 3);
                v7[2] = *(i - 2);
                v7[3] = *(i - 1);
              }

              a4 = 0;
              *(i - 4) = v48;
              *(i - 3) = v49;
              *(i - 2) = v50;
              *(i - 1) = v51;
              continue;
            }
          }

          uint64_t v19 = *v7;
          uint64_t v20 = v7[1];
          uint64_t v21 = (char *)(v7 + 4);
          unint64_t v23 = v7[2];
          uint64_t v22 = v7[3];
          while (1)
          {
            unint64_t v24 = *(void *)v21;
            if (*(void *)v21 >= v19)
            {
              if (v19 < v24) {
                break;
              }
              uint64_t v25 = *((void *)v21 + 1);
              if (v25 >= v20)
              {
                if (v20 < v25) {
                  break;
                }
                __int128 v26 = *((void *)v21 + 2);
                if (v26 >= v23 && (v23 < v26 || *((void *)v21 + 3) >= v22)) {
                  break;
                }
              }
            }

            v21 += 32;
          }

          if (v21 - 32 == (char *)v7)
          {
            uint64_t k = v154;
            if (v21 < v154)
            {
              uint64_t v32 = *v8;
              uint64_t k = (char *)v8;
              if (*v8 >= v19)
              {
                uint64_t k = (char *)v8;
                do
                {
                  if (v19 >= v32)
                  {
                    id v33 = *((void *)k + 1);
                    if (v33 < v20) {
                      break;
                    }
                    if (v20 >= v33)
                    {
                      uint64_t v34 = *((void *)k + 2);
                      if (v34 < v23 || v23 >= v34 && *((void *)k + 3) < v22) {
                        break;
                      }
                    }
                  }

                  if (v21 >= k) {
                    break;
                  }
                  uint64_t v35 = *((void *)k - 4);
                  k -= 32;
                  uint64_t v32 = v35;
                }

                while (v35 >= v19);
              }
            }
          }

          else
          {
            uint64_t v27 = *v8;
            for (uint64_t k = (char *)v8; v27 >= v19; k -= 32)
            {
              if (v19 >= v27)
              {
                unint64_t v29 = *((void *)k + 1);
                if (v29 < v20) {
                  break;
                }
                if (v20 >= v29)
                {
                  __int128 v30 = *((void *)k + 2);
                  if (v30 < v23 || v23 >= v30 && *((void *)k + 3) < v22) {
                    break;
                  }
                }
              }

              unint64_t v31 = *((void *)k - 4);
              uint64_t v27 = v31;
            }
          }

          uint64_t i = (uint64_t *)v21;
          if (v21 < k)
          {
            uint64_t v36 = *(void *)k;
            uint64_t i = (uint64_t *)v21;
            unint64_t v37 = (uint64_t *)k;
            do
            {
              void *i = v36;
              *unint64_t v37 = v24;
              unint64_t v38 = i[1];
              i[1] = v37[1];
              v37[1] = v38;
              uint64_t v39 = i[2];
              i[2] = v37[2];
              v37[2] = v39;
              uint64_t v40 = i[3];
              i[3] = v37[3];
              void v37[3] = v40;
              while (1)
              {
                do
                {
                  uint64_t v41 = i[4];
                  i += 4;
                  unint64_t v24 = v41;
                }

                while (v41 < v19);
                if (v19 < v24) {
                  break;
                }
                uint64_t v42 = i[1];
                if (v42 >= v20)
                {
                  if (v20 < v42) {
                    break;
                  }
                  uint64_t v43 = i[2];
                  if (v43 >= v23 && (v23 < v43 || i[3] >= v22)) {
                    break;
                  }
                }
              }

              while (1)
              {
                unint64_t v44 = *(v37 - 4);
                v37 -= 4;
                uint64_t v36 = v44;
                if (v44 < v19) {
                  break;
                }
                if (v19 >= v36)
                {
                  unint64_t v45 = v37[1];
                  if (v45 < v20) {
                    break;
                  }
                  if (v20 >= v45)
                  {
                    uint64_t v46 = v37[2];
                    if (v46 < v23 || v23 >= v46 && v37[3] < v22) {
                      break;
                    }
                  }
                }
              }
            }

            while (i < v37);
          }

          if (i - 4 != v7)
          {
            *unint64_t v7 = *(i - 4);
            v7[1] = *(i - 3);
            v7[2] = *(i - 2);
            v7[3] = *(i - 1);
          }

          *(i - 4) = v19;
          *(i - 3) = v20;
          *(i - 2) = v23;
          *(i - 1) = v22;
          if (v21 < k)
          {
LABEL_64:
            BOOL result = std::__introsort<std::_ClassicAlgPolicy,std::__less<void,void> &,std::tuple<unsigned long long,unsigned long long,unsigned long long,unsigned long long> *,false>( v7,  i - 4,  a3,  a4 & 1);
            a4 = 0;
            continue;
          }

          uint64_t v47 = std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::tuple<unsigned long long,unsigned long long,unsigned long long,unsigned long long> *>( v7,  (char *)i - 32);
          BOOL result = std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::tuple<unsigned long long,unsigned long long,unsigned long long,unsigned long long> *>( i,  v154);
          if (!(_DWORD)result)
          {
            if (v47) {
              continue;
            }
            goto LABEL_64;
          }

          a2 = (char *)(i - 4);
          if (v47) {
            return result;
          }
          goto LABEL_2;
        }

        uint64_t v80 = (char *)(v7 + 4);
        uint64_t v82 = v7 == (uint64_t *)a2 || v80 == a2;
        if ((a4 & 1) == 0)
        {
          if (!v82)
          {
            do
            {
              unint64_t v136 = v80;
              BOOL result = std::__tuple_less<4ul>::operator()[abi:nn180100]<std::tuple<unsigned long long,unsigned long long,unsigned long long,unsigned long long>,std::tuple<unsigned long long,unsigned long long,unsigned long long,unsigned long long>>( v80,  v7);
              if ((_DWORD)result)
              {
                unint64_t v137 = *(void *)v136;
                __int128 v138 = v7[5];
                unint64_t v139 = v7[6];
                uint64_t v140 = v7[7];
                uint64_t v141 = *v7;
                while (1)
                {
                  do
                  {
                    uint64_t v142 = v7;
                    unint64_t v143 = v141;
                    unint64_t v144 = *(v7 - 4);
                    v7 -= 4;
                    uint64_t v141 = v144;
                    v7[8] = v143;
                    *(_OWORD *)(v7 + 9) = *(_OWORD *)(v7 + 5);
                    v7[11] = v7[7];
                  }

                  while (v137 < v144);
                  if (v141 < v137) {
                    break;
                  }
                  uint64_t v145 = *(v142 - 3);
                  if (v138 >= v145)
                  {
                    if (v145 < v138) {
                      break;
                    }
                    uint64_t v146 = *(v142 - 2);
                    if (v139 >= v146 && (v146 < v139 || v140 >= *(v142 - 1))) {
                      break;
                    }
                  }
                }

                *uint64_t v142 = v137;
                v142[1] = v138;
                v142[2] = v139;
                v142[3] = v140;
              }

              uint64_t v80 = v136 + 32;
              unint64_t v7 = (uint64_t *)v136;
            }

            while (v136 + 32 != a2);
          }

          return result;
        }

        if (v82) {
          return result;
        }
        unint64_t v83 = 0LL;
        unint64_t v84 = v7;
        do
        {
          uint64_t v85 = v80;
          BOOL result = std::__tuple_less<4ul>::operator()[abi:nn180100]<std::tuple<unsigned long long,unsigned long long,unsigned long long,unsigned long long>,std::tuple<unsigned long long,unsigned long long,unsigned long long,unsigned long long>>( v80,  v84);
          if (!(_DWORD)result) {
            goto LABEL_154;
          }
          uint64_t v86 = v84[4];
          uint64_t v87 = v84[5];
          uint64_t v88 = v84[6];
          uint64_t v89 = v84[7];
          uint64_t v90 = v84[1];
          v84[4] = *v84;
          *((void *)v85 + 1) = v90;
          *((void *)v85 + 2) = v84[2];
          *((void *)v85 + 3) = v84[3];
          uint64_t v91 = v7;
          if (v84 == v7) {
            goto LABEL_153;
          }
          unint64_t v92 = v83;
          while (1)
          {
            unint64_t v93 = *(uint64_t *)((char *)v7 + v92 - 32);
            if (v86 < v93)
            {
              uint64_t v94 = *(uint64_t *)((char *)v7 + v92 - 24);
              goto LABEL_150;
            }

            if (v93 < v86) {
              goto LABEL_152;
            }
            uint64_t v94 = *(uint64_t *)((char *)v7 + v92 - 24);
            if (v87 >= v94)
            {
              if (v94 < v87) {
                goto LABEL_152;
              }
              uint64_t v95 = *(uint64_t *)((char *)v7 + v92 - 16);
              if (v88 >= v95) {
                break;
              }
            }

      __int128 v195 = 0LL;
      goto LABEL_210;
    }

LABEL_93:
            if (v8 < v78)
            {
              uint64_t v85 = *v8;
              uint64_t v86 = *v78;
              do
              {
                *unint64_t v8 = v86;
                *unint64_t v78 = v85;
                uint64_t v87 = v8[1];
                v8[1] = v78[1];
                v78[1] = v87;
                uint64_t v88 = v8[2];
                void v8[2] = v78[2];
                v78[2] = v88;
                do
                {
                  uint64_t v89 = 0LL;
                  uint64_t v90 = v8[3];
                  v8 += 3;
                  uint64_t v85 = v90;
                  while (1)
                  {
                    uint64_t v91 = CollectCounterData(GTMTLReplayController *,NSArray *,unsigned long long,NSArray *,unsigned long,GTMTLReplayOperationQueues *,NSOperation *,unsigned int,BOOL,unsigned int,GTAGXPerfStateControl *)::kCounterCompare[v89];
                    unint64_t v92 = *(void *)(v20 + 8 * v91);
                    unint64_t v93 = *(void *)(v85 + 8 * v91);
                    if (v92 != v93) {
                      break;
                    }
                    if (++v89 == 4) {
                      goto LABEL_101;
                    }
                  }

                  LOBYTE(v16) = v92 < v93;
LABEL_101:
                  ;
                }

                while (v92 == v93 || (v16 & 1) == 0);
                do
                {
                  uint64_t v94 = 0LL;
                  uint64_t v95 = *(v78 - 3);
                  v78 -= 3;
                  uint64_t v86 = v95;
                  while (1)
                  {
                    uint64_t v96 = CollectCounterData(GTMTLReplayController *,NSArray *,unsigned long long,NSArray *,unsigned long,GTMTLReplayOperationQueues *,NSOperation *,unsigned int,BOOL,unsigned int,GTAGXPerfStateControl *)::kCounterCompare[v94];
                    unint64_t v16 = *(void *)(v20 + 8 * v96);
                    unint64_t v97 = *(void *)(v86 + 8 * v96);
                    if (v16 != v97) {
                      break;
                    }
                    if (++v94 == 4) {
                      goto LABEL_108;
                    }
                  }
                }

                while (v16 < v97);
LABEL_108:
                ;
              }

              while (v8 < v78);
            }

            __int128 v98 = (void *)*a1;
            if (v8 - 3 == a1)
            {
              if (v98)
              {
                *(v8 - 2) = (uint64_t)v98;
                __int128 v195 = v26;
                operator delete(v98);
                __int128 v26 = v195;
              }
            }

            else
            {
              if (v98)
              {
                a1[1] = (uint64_t)v98;
                __int128 v194 = v26;
                operator delete(v98);
                __int128 v26 = v194;
                *a1 = 0LL;
                a1[1] = 0LL;
                a1[2] = 0LL;
              }

              *(_OWORD *)a1 = *(_OWORD *)(v8 - 3);
              a1[2] = *(v8 - 1);
              *(v8 - 3) = 0LL;
              *(v8 - 2) = 0LL;
              *(v8 - 1) = 0LL;
            }

            a4 = 0;
            *(v8 - 3) = v20;
            *((_OWORD *)v8 - 1) = v26;
            continue;
          }
        }

        __int128 v30 = *(_OWORD *)(a1 + 1);
        *a1 = 0LL;
        a1[1] = 0LL;
        unint64_t v31 = a1;
        a1[2] = 0LL;
        do
        {
          uint64_t v32 = 0LL;
          id v33 = v31;
          uint64_t v35 = v31[3];
          v31 += 3;
          uint64_t v34 = v35;
          while (1)
          {
            uint64_t v36 = CollectCounterData(GTMTLReplayController *,NSArray *,unsigned long long,NSArray *,unsigned long,GTMTLReplayOperationQueues *,NSOperation *,unsigned int,BOOL,unsigned int,GTAGXPerfStateControl *)::kCounterCompare[v32];
            unint64_t v37 = *(void *)(v34 + 8 * v36);
            unint64_t v38 = *(void *)(v20 + 8 * v36);
            if (v37 != v38) {
              break;
            }
            if (++v32 == 4) {
              goto LABEL_23;
            }
          }
        }

        while (v37 < v38);
LABEL_23:
        uint64_t v39 = a2;
        if (v33 == a1)
        {
          uint64_t v39 = a2;
          do
          {
            if (v31 >= v39) {
              break;
            }
            uint64_t v46 = 0LL;
            uint64_t v48 = *(v39 - 3);
            v39 -= 3;
            uint64_t v47 = v48;
            while (1)
            {
              uint64_t v49 = CollectCounterData(GTMTLReplayController *,NSArray *,unsigned long long,NSArray *,unsigned long,GTMTLReplayOperationQueues *,NSOperation *,unsigned int,BOOL,unsigned int,GTAGXPerfStateControl *)::kCounterCompare[v46];
              unint64_t v50 = *(void *)(v47 + 8 * v49);
              unint64_t v51 = *(void *)(v20 + 8 * v49);
              if (v50 != v51) {
                break;
              }
              if (++v46 == 4) {
                goto LABEL_39;
              }
            }

            LOBYTE(v16) = v50 < v51;
LABEL_39:
            ;
          }

          while (v50 == v51 || (v16 & 1) == 0);
        }

        else
        {
          do
          {
            uint64_t v40 = 0LL;
            uint64_t v42 = *(v39 - 3);
            v39 -= 3;
            uint64_t v41 = v42;
            while (1)
            {
              uint64_t v43 = CollectCounterData(GTMTLReplayController *,NSArray *,unsigned long long,NSArray *,unsigned long,GTMTLReplayOperationQueues *,NSOperation *,unsigned int,BOOL,unsigned int,GTAGXPerfStateControl *)::kCounterCompare[v40];
              unint64_t v44 = *(void *)(v41 + 8 * v43);
              unint64_t v45 = *(void *)(v20 + 8 * v43);
              if (v44 != v45) {
                break;
              }
              if (++v40 == 4) {
                goto LABEL_29;
              }
            }

            LOBYTE(v16) = v44 < v45;
LABEL_29:
            ;
          }

          while (v44 == v45 || (v16 & 1) == 0);
        }

        if (v31 >= v39)
        {
          unint64_t v8 = v31;
        }

        else
        {
          uint64_t v52 = *v39;
          unint64_t v8 = v31;
          unint64_t v53 = v39;
          do
          {
            *unint64_t v8 = v52;
            uint64_t *v53 = v34;
            uint64_t v54 = v8[1];
            v8[1] = v53[1];
            v53[1] = v54;
            uint64_t v55 = v8[2];
            void v8[2] = v53[2];
            void v53[2] = v55;
            do
            {
              uint64_t v56 = 0LL;
              uint64_t v57 = v8[3];
              v8 += 3;
              uint64_t v34 = v57;
              while (1)
              {
                uint64_t v58 = CollectCounterData(GTMTLReplayController *,NSArray *,unsigned long long,NSArray *,unsigned long,GTMTLReplayOperationQueues *,NSOperation *,unsigned int,BOOL,unsigned int,GTAGXPerfStateControl *)::kCounterCompare[v56];
                unint64_t v59 = *(void *)(v34 + 8 * v58);
                unint64_t v60 = *(void *)(v20 + 8 * v58);
                if (v59 != v60) {
                  break;
                }
                if (++v56 == 4) {
                  goto LABEL_49;
                }
              }
            }

            while (v59 < v60);
            do
            {
LABEL_49:
              uint64_t v61 = 0LL;
              uint64_t v62 = *(v53 - 3);
              v53 -= 3;
              uint64_t v52 = v62;
              while (1)
              {
                uint64_t v63 = CollectCounterData(GTMTLReplayController *,NSArray *,unsigned long long,NSArray *,unsigned long,GTMTLReplayOperationQueues *,NSOperation *,unsigned int,BOOL,unsigned int,GTAGXPerfStateControl *)::kCounterCompare[v61];
                unint64_t v64 = *(void *)(v52 + 8 * v63);
                unint64_t v65 = *(void *)(v20 + 8 * v63);
                if (v64 != v65) {
                  break;
                }
                if (++v61 == 4) {
                  goto LABEL_54;
                }
              }

              BOOL v17 = v64 < v65;
LABEL_54:
              ;
            }

            while (v64 == v65 || !v17);
          }

          while (v8 < v53);
        }

        unint64_t v66 = (void *)*a1;
        if (v8 - 3 == a1)
        {
          if (v66)
          {
            *(v8 - 2) = (uint64_t)v66;
            __int128 v193 = v30;
            operator delete(v66);
            __int128 v30 = v193;
          }
        }

        else
        {
          if (v66)
          {
            a1[1] = (uint64_t)v66;
            __int128 v192 = v30;
            operator delete(v66);
            __int128 v30 = v192;
            *a1 = 0LL;
            a1[1] = 0LL;
            a1[2] = 0LL;
          }

          *(_OWORD *)a1 = *(_OWORD *)(v8 - 3);
          a1[2] = *(v8 - 1);
          *(v8 - 3) = 0LL;
          *(v8 - 2) = 0LL;
          *(v8 - 1) = 0LL;
        }

        *(v8 - 3) = v20;
        *((_OWORD *)v8 - 1) = v30;
        if (v31 < v39)
        {
LABEL_68:
          _ZNSt3__111__introsortINS_17_ClassicAlgPolicyERZZZL18CollectCounterDataP21GTMTLReplayControllerP7NSArrayyS5_mP26GTMTLReplayOperationQueuesP11NSOperationjbjP21GTAGXPerfStateControlEUb_EUb0_E3__0PNS_6vectorIyNS_9allocatorIyEEEELb0EEEvT1_SJ_T0_NS_15iterator_traitsISJ_E15difference_typeEb( a1,  v8 - 3,  a3,  a4 & 1);
          a4 = 0;
          continue;
        }

        BOOL v67 = _ZNSt3__127__insertion_sort_incompleteB8nn180100INS_17_ClassicAlgPolicyERZZZL18CollectCounterDataP21GTMTLReplayControllerP7NSArrayyS5_mP26GTMTLReplayOperationQueuesP11NSOperationjbjP21GTAGXPerfStateControlEUb_EUb0_E3__0PNS_6vectorIyNS_9allocatorIyEEEEEEbT1_SJ_T0_( a1,  v8 - 3);
        if (!_ZNSt3__127__insertion_sort_incompleteB8nn180100INS_17_ClassicAlgPolicyERZZZL18CollectCounterDataP21GTMTLReplayControllerP7NSArrayyS5_mP26GTMTLReplayOperationQueuesP11NSOperationjbjP21GTAGXPerfStateControlEUb_EUb0_E3__0PNS_6vectorIyNS_9allocatorIyEEEEEEbT1_SJ_T0_( v8,  a2))
        {
          if (v67) {
            continue;
          }
          goto LABEL_68;
        }

        a2 = v8 - 3;
        if (!v67) {
          goto LABEL_1;
        }
        return;
    }
  }

        ++*(void *)(v49 + 32);
LABEL_94:
        unint64_t v65 = v54[3];
        unint64_t v66 = objc_claimAutoreleasedReturnValue(+[NSMutableData dataWithLength:](&OBJC_CLASS___NSMutableData, "dataWithLength:", v65));
        BOOL v67 = (void *)*((void *)v537 + 9);
        *((void *)v537 + 9) = v66;

        std::vector<unsigned int>::reserve((std::vector<unsigned int> *)(v537 + 112), v65 >> 6);
        v65 >>= 4;
        std::vector<unsigned int>::reserve((std::vector<unsigned int> *)(v537 + 32), v65);
        uint64_t v68 = objc_claimAutoreleasedReturnValue(+[NSMutableData dataWithCapacity:](&OBJC_CLASS___NSMutableData, "dataWithCapacity:", v65));
        uint64_t v69 = (void *)*((void *)v537 + 7);
        *((void *)v537 + 7) = v68;

        uint64_t v70 = (void *)objc_claimAutoreleasedReturnValue( [*(id *)(*((void *)this + 61) + 280) objectForKeyedSubscript:@"limiter sample counters"]);
        *((_DWORD *)v537 + 6) = *((_DWORD *)v537 + 6) & 0x3FFFFFF | ([v70 count] << 26);

        uint64_t v71 = objc_claimAutoreleasedReturnValue(+[NSMutableData dataWithCapacity:](&OBJC_CLASS___NSMutableData, "dataWithCapacity:", 1572864LL));
        unint64_t v72 = (void *)*((void *)v537 + 11);
        *((void *)v537 + 11) = v71;

        unint64_t v73 = objc_claimAutoreleasedReturnValue(+[NSMutableData dataWithCapacity:](&OBJC_CLASS___NSMutableData, "dataWithCapacity:", 1572864LL));
        uint64_t v74 = (void *)*((void *)v537 + 12);
        *((void *)v537 + 12) = v73;

        if (v19 != v20)
        {
          uint64_t v75 = this;
          __int128 v540 = v18;
          while (1)
          {
            unint64_t v76 = *(unsigned int **)v19;
            unint64_t v77 = v20 - v19;
            if (v20 - v19 >= 9)
            {
              id v543 = *(unsigned int **)v19;
              __int128 v546 = v19;
              unint64_t v78 = 0LL;
              uint64_t v79 = v77 >> 3;
              uint64_t v80 = __OFSUB__(v77 >> 3, 2LL);
              uint64_t v81 = (v77 >> 3) - 2;
              if (v81 < 0 != v80) {
                uint64_t v81 = v79 - 1;
              }
              uint64_t v82 = v81 >> 1;
              unint64_t v83 = (uint64_t *)v19;
              do
              {
                unint64_t v84 = &v83[v78];
                uint64_t v86 = v84[1];
                uint64_t v85 = v84 + 1;
                uint64_t v1 = v86;
                uint64_t v87 = (2 * v78) | 1;
                uint64_t v88 = 2 * v78 + 2;
                if (v88 < v79)
                {
                  uint64_t v89 = (void *)v85[1];
                  uint64_t v90 = v79;
                  uint64_t v91 = GRCPerFrameData::GreaterPQElement::operator()((void *)v1, v89);
                  uint64_t v79 = v90;
                  uint64_t v19 = v546;
                  if (v91)
                  {
                    uint64_t v1 = (uint64_t)v89;
                    ++v85;
                    uint64_t v87 = v88;
                  }
                }

                NSMutableArray *v83 = v1;
                unint64_t v83 = v85;
                unint64_t v78 = v87;
              }

              while (v87 <= v82);
              unint64_t v92 = v20 - 8;
              if (v20 - 8 == (char *)v85)
              {
                unsigned __int8 *v85 = (uint64_t)v543;
                unint64_t v76 = v543;
              }

              else
              {
                unsigned __int8 *v85 = *(void *)v92;
                unint64_t v93 = (char *)(v85 + 1);
                *(void *)unint64_t v92 = v543;
                uint64_t v94 = (v93 - v19) >> 3;
                uint64_t v95 = (uint64_t)v93;
                unint64_t v76 = v543;
                std::__sift_up[abi:nn180100]<std::_ClassicAlgPolicy,GRCPerFrameData::GreaterPQElement &,std::__wrap_iter<GRCPerFrameData::PriorityQueueElement **>>( (BOOL)v19,  v95,  v94);
              }

              uint64_t v75 = this;
              __int128 v18 = v540;
            }

            uint64_t v96 = v20 - 8;
            if (v76[1] != -1) {
              break;
            }
            v20 -= 8;
LABEL_181:
            if (v19 == v96) {
              goto LABEL_184;
            }
          }

          uint64_t v1 = (uint64_t)(v76 + 4);
          unint64_t v97 = *((void *)v76 + 5);
          if (v97 == 6)
          {
            GRCPerFrameData::AddLimiterCounterSample((uint64_t)v75, v586, (__int128 *)v76 + 1, 1);
            goto LABEL_165;
          }

          if (v97 == 7)
          {
            __int128 v98 = *((void *)v75 + 42);
            uint64_t v99 = *((void *)v75 + 43);
            if (v98 < v99)
            {
              *(_DWORD *)__int128 v98 = (_DWORD)v586;
              *(void *)(v98 + 80) = 0LL;
              *(void *)(v98 + 8_Block_object_dispose(va, 8) = 0LL;
              *(void *)(v98 + 72) = 0LL;
              *(_OWORD *)(v98 + 72) = *((_OWORD *)v76 + 5);
              *(void *)(v98 + 8_Block_object_dispose(va, 8) = *((void *)v76 + 12);
              *((void *)v76 + 10) = 0LL;
              *((void *)v76 + 11) = 0LL;
              *((void *)v76 + 12) = 0LL;
              uint64_t v101 = *((_OWORD *)v76 + 3);
              uint64_t v100 = *((_OWORD *)v76 + 4);
              uint64_t v102 = *((_OWORD *)v76 + 2);
              *(_OWORD *)(v98 + _Block_object_dispose(va, 8) = *(_OWORD *)v1;
              *(_OWORD *)(v98 + 24) = v102;
              *(_OWORD *)(v98 + 40) = v101;
              *(_OWORD *)(v98 + 56) = v100;
              unint64_t v103 = (char *)(v98 + 96);
              goto LABEL_139;
            }

            uint64_t v111 = *((void *)v75 + 41);
            uint64_t v112 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v98 - v111) >> 5);
            unint64_t v113 = v112 + 1;
            if (v112 + 1 > 0x2AAAAAAAAAAAAAALL) {
              abort();
            }
            unint64_t v114 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v99 - v111) >> 5);
            if (2 * v114 > v113) {
              unint64_t v113 = 2 * v114;
            }
            if (v114 >= 0x155555555555555LL) {
              __int128 v115 = 0x2AAAAAAAAAAAAAALL;
            }
            else {
              __int128 v115 = v113;
            }
            if (v115 > 0x2AAAAAAAAAAAAAALL) {
              std::__throw_bad_array_new_length[abi:nn180100]();
            }
            unint64_t v116 = (char *)operator new(96 * v115);
            int64_t v117 = &v116[96 * v112];
            uint64_t v118 = &v116[96 * v115];
            *(_DWORD *)int64_t v117 = (_DWORD)v586;
            *((void *)v117 + 10) = 0LL;
            *((void *)v117 + 11) = 0LL;
            *((void *)v117 + 9) = 0LL;
            *(_OWORD *)(v117 + 72) = *((_OWORD *)v76 + 5);
            *((void *)v117 + 11) = *((void *)v76 + 12);
            *((void *)v76 + 11) = 0LL;
            *((void *)v76 + 12) = 0LL;
            *((void *)v76 + 10) = 0LL;
            unint64_t v120 = *((_OWORD *)v76 + 3);
            uint64_t v119 = *((_OWORD *)v76 + 4);
            unint64_t v121 = *(_OWORD *)v1;
            *(_OWORD *)(v117 + 24) = *((_OWORD *)v76 + 2);
            *(_OWORD *)(v117 + 40) = v120;
            *(_OWORD *)(v117 + _Block_object_dispose(va, 8) = v121;
            *(_OWORD *)(v117 + 56) = v119;
            unint64_t v103 = v117 + 96;
            uint64_t v75 = this;
            uint64_t v122 = (char *)*((void *)this + 41);
            int64_t v123 = (char *)*((void *)this + 42);
            if (v123 == v122)
            {
              *((void *)this + 41) = v117;
              *((void *)this + 42) = v103;
              *((void *)this + 43) = v118;
              if (v123) {
                goto LABEL_138;
              }
            }

            else
            {
              int64_t v124 = 0LL;
              do
              {
                int64_t v125 = &v117[v124];
                uint64_t v126 = &v123[v124];
                *((_DWORD *)v125 - 24) = *(_DWORD *)&v123[v124 - 96];
                *((void *)v125 - 2) = 0LL;
                *((void *)v125 - 1) = 0LL;
                *((void *)v125 - 3) = 0LL;
                *(_OWORD *)(v125 - 24) = *(_OWORD *)&v123[v124 - 24];
                *((void *)v125 - 1) = *(void *)&v123[v124 - 8];
                *((void *)v126 - 3) = 0LL;
                *((void *)v126 - 2) = 0LL;
                *((void *)v126 - 1) = 0LL;
                unint64_t v127 = *(_OWORD *)&v123[v124 - 88];
                uint64_t v128 = *(_OWORD *)&v123[v124 - 72];
                uint64_t v129 = *(_OWORD *)&v123[v124 - 56];
                *(_OWORD *)(v125 - 40) = *(_OWORD *)&v123[v124 - 40];
                *(_OWORD *)(v125 - 56) = v129;
                *(_OWORD *)(v125 - 72) = v128;
                *(_OWORD *)(v125 - 8_Block_object_dispose(va, 8) = v127;
                v124 -= 96LL;
              }

              while (&v123[v124] != v122);
              unint64_t v130 = (char *)*((void *)this + 41);
              int64_t v123 = (char *)*((void *)this + 42);
              *((void *)this + 41) = &v117[v124];
              *((void *)this + 42) = v103;
              *((void *)this + 43) = v118;
              if (v123 != v130)
              {
                do
                {
                  unint64_t v131 = (void *)*((void *)v123 - 3);
                  if (v131)
                  {
                    *((void *)v123 - 2) = v131;
                    operator delete(v131);
                  }

                  v123 -= 96;
                }

                while (v123 != v130);
                int64_t v123 = v130;
              }

              if (v123) {
LABEL_138:
              }
                operator delete(v123);
            }

void std::vector<unsigned long long>::reserve(void **a1, unint64_t a2)
{
  if (a2 > ((_BYTE *)a1[2] - (_BYTE *)*a1) >> 3)
  {
    if (a2 >> 61) {
      abort();
    }
    int64_t v3 = (_BYTE *)a1[1] - (_BYTE *)*a1;
    unint64_t v4 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<std::pair<unsigned int,unsigned int>>>(a2);
    unint64_t v5 = &v4[v3 & 0xFFFFFFFFFFFFFFF8LL];
    unint64_t v7 = &v4[8 * v6];
    unint64_t v8 = (char *)*a1;
    uint64_t v9 = (char *)a1[1];
    uint64_t v10 = v5;
    if (v9 != *a1)
    {
      uint64_t v10 = v5;
      do
      {
        uint64_t v11 = *((void *)v9 - 1);
        v9 -= 8;
        *((void *)v10 - 1) = v11;
        v10 -= 8;
      }

      while (v9 != v8);
    }

    *a1 = v10;
    a1[1] = v5;
    a1[2] = v7;
    if (v8) {
      operator delete(v8);
    }
  }

void std::vector<unsigned long long>::__insert_with_size[abi:nn180100]<std::__wrap_iter<unsigned long long *>,std::__wrap_iter<unsigned long long *>>( void **a1, char *__dst, char *__src, char *a4, uint64_t a5)
{
  if (a5 < 1) {
    return;
  }
  uint64_t v6 = __src;
  uint64_t v9 = a1 + 2;
  uint64_t v10 = a1[2];
  unint64_t v11 = (unint64_t)a1[1];
  if (a5 > (uint64_t)&v10[-v11] >> 3)
  {
    uint64_t v12 = *a1;
    unint64_t v13 = a5 + ((uint64_t)(v11 - (void)*a1) >> 3);
    if (v13 >> 61) {
      abort();
    }
    uint64_t v14 = (__dst - v12) >> 3;
    uint64_t v15 = v10 - v12;
    if (v15 >> 2 > v13) {
      unint64_t v13 = v15 >> 2;
    }
    else {
      unint64_t v16 = v13;
    }
    __p[4] = v9;
    if (v16) {
      unint64_t v16 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<std::pair<unsigned int,unsigned int>>>(v16);
    }
    else {
      uint64_t v17 = 0LL;
    }
    uint64_t v27 = (void *)(v16 + 8 * v14);
    __p[0] = (void *)v16;
    __p[1] = v27;
    __p[3] = (void *)(v16 + 8 * v17);
    uint64_t v28 = 8 * a5;
    unint64_t v29 = &v27[a5];
    do
    {
      uint64_t v30 = *(void *)v6;
      v6 += 8;
      *v27++ = v30;
      v28 -= 8LL;
    }

    while (v28);
    __p[2] = v29;
    std::vector<unsigned long long>::__swap_out_circular_buffer(a1, (uint64_t)__p, __dst);
    if (__p[0]) {
      operator delete(__p[0]);
    }
    return;
  }

  uint64_t v18 = v11 - (void)__dst;
  uint64_t v19 = (uint64_t)(v11 - (void)__dst) >> 3;
  if (v19 >= a5)
  {
    uint64_t v20 = &__src[8 * a5];
    uint64_t v22 = (char *)a1[1];
LABEL_17:
    unint64_t v23 = &__dst[8 * a5];
    unint64_t v24 = &v22[-8 * a5];
    uint64_t v25 = v22;
    if ((unint64_t)v24 < v11)
    {
      uint64_t v25 = v22;
      do
      {
        uint64_t v26 = *(void *)v24;
        v24 += 8;
        *(void *)uint64_t v25 = v26;
        v25 += 8;
      }

      while ((unint64_t)v24 < v11);
    }

    a1[1] = v25;
    if (v22 != v23) {
      memmove(&v22[-8 * ((v22 - v23) >> 3)], __dst, v22 - v23);
    }
    if (v20 != v6) {
      memmove(__dst, v6, v20 - v6);
    }
    return;
  }

  uint64_t v20 = &__src[8 * v19];
  int64_t v21 = a4 - v20;
  if (a4 != v20) {
    memmove(a1[1], &__src[8 * v19], a4 - v20);
  }
  uint64_t v22 = (char *)(v11 + v21);
  a1[1] = (void *)(v11 + v21);
  if (v18 >= 1) {
    goto LABEL_17;
  }
}

char *std::vector<unsigned long long>::__swap_out_circular_buffer(void **a1, uint64_t a2, char *__src)
{
  unint64_t v5 = *(char **)(a2 + 8);
  uint64_t v6 = (char *)*a1;
  unint64_t v7 = v5;
  if (*a1 != __src)
  {
    unint64_t v8 = __src;
    unint64_t v7 = *(char **)(a2 + 8);
    do
    {
      uint64_t v9 = *((void *)v8 - 1);
      v8 -= 8;
      *((void *)v7 - 1) = v9;
      v7 -= 8;
    }

    while (v8 != v6);
  }

  *(void *)(a2 + _Block_object_dispose(va, 8) = v7;
  uint64_t v10 = a1[1];
  uint64_t v11 = *(void *)(a2 + 16);
  int64_t v12 = v10 - __src;
  if (v10 != __src)
  {
    memmove(*(void **)(a2 + 16), __src, v10 - __src);
    unint64_t v7 = *(char **)(a2 + 8);
  }

  *(void *)(a2 + 16) = v11 + v12;
  unint64_t v13 = (char *)*a1;
  *a1 = v7;
  *(void *)(a2 + _Block_object_dispose(va, 8) = v13;
  uint64_t v14 = a1[1];
  a1[1] = *(void **)(a2 + 16);
  *(void *)(a2 + 16) = v14;
  uint64_t v15 = a1[2];
  a1[2] = *(void **)(a2 + 24);
  *(void *)(a2 + 24) = v15;
  *(void *)a2 = *(void *)(a2 + 8);
  return v5;
}

uint64_t *_ZNSt3__17__sort3B8nn180100INS_17_ClassicAlgPolicyERZZZL18CollectCounterDataP21GTMTLReplayControllerP7NSArrayyS5_mP26GTMTLReplayOperationQueuesP11NSOperationjbjP21GTAGXPerfStateControlEUb_EUb0_E3__0PNS_6vectorIyNS_9allocatorIyEEEEEEjT1_SJ_SJ_T0_( uint64_t *result, uint64_t *a2, uint64_t *a3)
{
  uint64_t v3 = 0LL;
  uint64_t v4 = *a2;
  uint64_t v5 = *result;
  while (1)
  {
    uint64_t v6 = CollectCounterData(GTMTLReplayController *,NSArray *,unsigned long long,NSArray *,unsigned long,GTMTLReplayOperationQueues *,NSOperation *,unsigned int,BOOL,unsigned int,GTAGXPerfStateControl *)::kCounterCompare[v3];
    unint64_t v7 = *(void *)(v4 + 8 * v6);
    unint64_t v8 = *(void *)(v5 + 8 * v6);
    if (v7 != v8) {
      break;
    }
    if (++v3 == 4) {
      goto LABEL_10;
    }
  }

  if (v7 >= v8)
  {
LABEL_10:
    uint64_t v14 = 0LL;
    uint64_t v15 = *a3;
    while (1)
    {
      uint64_t v16 = CollectCounterData(GTMTLReplayController *,NSArray *,unsigned long long,NSArray *,unsigned long,GTMTLReplayOperationQueues *,NSOperation *,unsigned int,BOOL,unsigned int,GTAGXPerfStateControl *)::kCounterCompare[v14];
      unint64_t v17 = *(void *)(v15 + 8 * v16);
      unint64_t v18 = *(void *)(v4 + 8 * v16);
      if (v17 != v18) {
        break;
      }
      if (++v14 == 4) {
        return result;
      }
    }

    if (v17 < v18)
    {
      uint64_t v19 = 0LL;
      *a2 = v15;
      *a3 = v4;
      uint64_t v20 = a2[1];
      a2[1] = a3[1];
      a3[1] = v20;
      uint64_t v22 = a2 + 2;
      uint64_t v21 = a2[2];
      a2[2] = a3[2];
      a3[2] = v21;
      uint64_t v23 = *a2;
      uint64_t v24 = *result;
      while (1)
      {
        uint64_t v25 = CollectCounterData(GTMTLReplayController *,NSArray *,unsigned long long,NSArray *,unsigned long,GTMTLReplayOperationQueues *,NSOperation *,unsigned int,BOOL,unsigned int,GTAGXPerfStateControl *)::kCounterCompare[v19];
        unint64_t v26 = *(void *)(v23 + 8 * v25);
        unint64_t v27 = *(void *)(v24 + 8 * v25);
        if (v26 != v27) {
          break;
        }
        if (++v19 == 4) {
          return result;
        }
      }

      if (v26 < v27)
      {
        void *result = v23;
        *a2 = v24;
        uint64_t v39 = result[1];
        result[1] = a2[1];
        a2[1] = v39;
        unint64_t v29 = result + 2;
LABEL_30:
        uint64_t v41 = *v29;
        uint64_t *v29 = *v22;
        *uint64_t v22 = v41;
      }
    }
  }

  else
  {
    uint64_t v9 = 0LL;
    uint64_t v10 = *a3;
    while (1)
    {
      uint64_t v11 = CollectCounterData(GTMTLReplayController *,NSArray *,unsigned long long,NSArray *,unsigned long,GTMTLReplayOperationQueues *,NSOperation *,unsigned int,BOOL,unsigned int,GTAGXPerfStateControl *)::kCounterCompare[v9];
      unint64_t v12 = *(void *)(v10 + 8 * v11);
      unint64_t v13 = *(void *)(v4 + 8 * v11);
      if (v12 != v13) {
        break;
      }
      if (++v9 == 4) {
        goto LABEL_21;
      }
    }

    if (v12 < v13)
    {
      void *result = v10;
      *a3 = v5;
      uint64_t v28 = result[1];
      result[1] = a3[1];
      a3[1] = v28;
      unint64_t v29 = result + 2;
LABEL_29:
      uint64_t v22 = a3 + 2;
      goto LABEL_30;
    }

uint64_t *_ZNSt3__17__sort4B8nn180100INS_17_ClassicAlgPolicyERZZZL18CollectCounterDataP21GTMTLReplayControllerP7NSArrayyS5_mP26GTMTLReplayOperationQueuesP11NSOperationjbjP21GTAGXPerfStateControlEUb_EUb0_E3__0PNS_6vectorIyNS_9allocatorIyEEEEEEvT1_SJ_SJ_SJ_T0_( uint64_t *a1, uint64_t *a2, uint64_t *a3, uint64_t *a4)
{
  BOOL result = _ZNSt3__17__sort3B8nn180100INS_17_ClassicAlgPolicyERZZZL18CollectCounterDataP21GTMTLReplayControllerP7NSArrayyS5_mP26GTMTLReplayOperationQueuesP11NSOperationjbjP21GTAGXPerfStateControlEUb_EUb0_E3__0PNS_6vectorIyNS_9allocatorIyEEEEEEjT1_SJ_SJ_T0_( a1,  a2,  a3);
  uint64_t v9 = 0LL;
  uint64_t v10 = *a4;
  uint64_t v11 = *a3;
  while (1)
  {
    uint64_t v12 = CollectCounterData(GTMTLReplayController *,NSArray *,unsigned long long,NSArray *,unsigned long,GTMTLReplayOperationQueues *,NSOperation *,unsigned int,BOOL,unsigned int,GTAGXPerfStateControl *)::kCounterCompare[v9];
    unint64_t v13 = *(void *)(v10 + 8 * v12);
    unint64_t v14 = *(void *)(v11 + 8 * v12);
    if (v13 != v14) {
      break;
    }
    if (++v9 == 4) {
      return result;
    }
  }

  if (v13 < v14)
  {
    uint64_t v15 = 0LL;
    *a3 = v10;
    *a4 = v11;
    uint64_t v16 = a3[1];
    a3[1] = a4[1];
    a4[1] = v16;
    uint64_t v17 = a3[2];
    a3[2] = a4[2];
    a4[2] = v17;
    uint64_t v18 = *a3;
    uint64_t v19 = *a2;
    while (1)
    {
      uint64_t v20 = CollectCounterData(GTMTLReplayController *,NSArray *,unsigned long long,NSArray *,unsigned long,GTMTLReplayOperationQueues *,NSOperation *,unsigned int,BOOL,unsigned int,GTAGXPerfStateControl *)::kCounterCompare[v15];
      unint64_t v21 = *(void *)(v18 + 8 * v20);
      unint64_t v22 = *(void *)(v19 + 8 * v20);
      if (v21 != v22) {
        break;
      }
      if (++v15 == 4) {
        return result;
      }
    }

    if (v21 < v22)
    {
      uint64_t v23 = 0LL;
      *a2 = v18;
      *a3 = v19;
      uint64_t v24 = a2[1];
      a2[1] = a3[1];
      a3[1] = v24;
      uint64_t v25 = a2[2];
      a2[2] = a3[2];
      a3[2] = v25;
      uint64_t v26 = *a2;
      uint64_t v27 = *a1;
      while (1)
      {
        uint64_t v28 = CollectCounterData(GTMTLReplayController *,NSArray *,unsigned long long,NSArray *,unsigned long,GTMTLReplayOperationQueues *,NSOperation *,unsigned int,BOOL,unsigned int,GTAGXPerfStateControl *)::kCounterCompare[v23];
        unint64_t v29 = *(void *)(v26 + 8 * v28);
        unint64_t v30 = *(void *)(v27 + 8 * v28);
        if (v29 != v30) {
          break;
        }
        if (++v23 == 4) {
          return result;
        }
      }

      if (v29 < v30)
      {
        *a1 = v26;
        *a2 = v27;
        uint64_t v31 = a1[1];
        a1[1] = a2[1];
        a2[1] = v31;
        uint64_t v32 = a1[2];
        a1[2] = a2[2];
        a2[2] = v32;
      }
    }
  }

  return result;
}

uint64_t *_ZNSt3__124__sort5_maybe_branchlessB8nn180100INS_17_ClassicAlgPolicyERZZZL18CollectCounterDataP21GTMTLReplayControllerP7NSArrayyS5_mP26GTMTLReplayOperationQueuesP11NSOperationjbjP21GTAGXPerfStateControlEUb_EUb0_E3__0PNS_6vectorIyNS_9allocatorIyEEEELi0EEEvT1_SJ_SJ_SJ_SJ_T0_( uint64_t *a1, uint64_t *a2, uint64_t *a3, uint64_t *a4, uint64_t *a5)
{
  BOOL result = _ZNSt3__17__sort4B8nn180100INS_17_ClassicAlgPolicyERZZZL18CollectCounterDataP21GTMTLReplayControllerP7NSArrayyS5_mP26GTMTLReplayOperationQueuesP11NSOperationjbjP21GTAGXPerfStateControlEUb_EUb0_E3__0PNS_6vectorIyNS_9allocatorIyEEEEEEvT1_SJ_SJ_SJ_T0_( a1,  a2,  a3,  a4);
  uint64_t v11 = 0LL;
  uint64_t v12 = *a5;
  uint64_t v13 = *a4;
  while (1)
  {
    uint64_t v14 = CollectCounterData(GTMTLReplayController *,NSArray *,unsigned long long,NSArray *,unsigned long,GTMTLReplayOperationQueues *,NSOperation *,unsigned int,BOOL,unsigned int,GTAGXPerfStateControl *)::kCounterCompare[v11];
    unint64_t v15 = *(void *)(v12 + 8 * v14);
    unint64_t v16 = *(void *)(v13 + 8 * v14);
    if (v15 != v16) {
      break;
    }
    if (++v11 == 4) {
      return result;
    }
  }

  if (v15 < v16)
  {
    uint64_t v17 = 0LL;
    *a4 = v12;
    *a5 = v13;
    uint64_t v18 = a4[1];
    a4[1] = a5[1];
    a5[1] = v18;
    uint64_t v19 = a4[2];
    a4[2] = a5[2];
    a5[2] = v19;
    uint64_t v20 = *a4;
    uint64_t v21 = *a3;
    while (1)
    {
      uint64_t v22 = CollectCounterData(GTMTLReplayController *,NSArray *,unsigned long long,NSArray *,unsigned long,GTMTLReplayOperationQueues *,NSOperation *,unsigned int,BOOL,unsigned int,GTAGXPerfStateControl *)::kCounterCompare[v17];
      unint64_t v23 = *(void *)(v20 + 8 * v22);
      unint64_t v24 = *(void *)(v21 + 8 * v22);
      if (v23 != v24) {
        break;
      }
      if (++v17 == 4) {
        return result;
      }
    }

    if (v23 < v24)
    {
      uint64_t v25 = 0LL;
      *a3 = v20;
      *a4 = v21;
      uint64_t v26 = a3[1];
      a3[1] = a4[1];
      a4[1] = v26;
      uint64_t v27 = a3[2];
      a3[2] = a4[2];
      a4[2] = v27;
      uint64_t v28 = *a3;
      uint64_t v29 = *a2;
      while (1)
      {
        uint64_t v30 = CollectCounterData(GTMTLReplayController *,NSArray *,unsigned long long,NSArray *,unsigned long,GTMTLReplayOperationQueues *,NSOperation *,unsigned int,BOOL,unsigned int,GTAGXPerfStateControl *)::kCounterCompare[v25];
        unint64_t v31 = *(void *)(v28 + 8 * v30);
        unint64_t v32 = *(void *)(v29 + 8 * v30);
        if (v31 != v32) {
          break;
        }
        if (++v25 == 4) {
          return result;
        }
      }

      if (v31 < v32)
      {
        uint64_t v33 = 0LL;
        *a2 = v28;
        *a3 = v29;
        uint64_t v34 = a2[1];
        a2[1] = a3[1];
        a3[1] = v34;
        uint64_t v35 = a2[2];
        a2[2] = a3[2];
        a3[2] = v35;
        uint64_t v36 = *a2;
        uint64_t v37 = *a1;
        while (1)
        {
          uint64_t v38 = CollectCounterData(GTMTLReplayController *,NSArray *,unsigned long long,NSArray *,unsigned long,GTMTLReplayOperationQueues *,NSOperation *,unsigned int,BOOL,unsigned int,GTAGXPerfStateControl *)::kCounterCompare[v33];
          unint64_t v39 = *(void *)(v36 + 8 * v38);
          unint64_t v40 = *(void *)(v37 + 8 * v38);
          if (v39 != v40) {
            break;
          }
          if (++v33 == 4) {
            return result;
          }
        }

        if (v39 < v40)
        {
          *a1 = v36;
          *a2 = v37;
          uint64_t v41 = a1[1];
          a1[1] = a2[1];
          a2[1] = v41;
          uint64_t v42 = a1[2];
          a1[2] = a2[2];
          a2[2] = v42;
        }
      }
    }
  }

  return result;
}

BOOL _ZNSt3__127__insertion_sort_incompleteB8nn180100INS_17_ClassicAlgPolicyERZZZL18CollectCounterDataP21GTMTLReplayControllerP7NSArrayyS5_mP26GTMTLReplayOperationQueuesP11NSOperationjbjP21GTAGXPerfStateControlEUb_EUb0_E3__0PNS_6vectorIyNS_9allocatorIyEEEEEEbT1_SJ_T0_( uint64_t *a1, uint64_t *a2)
{
  unint64_t v4 = 0xAAAAAAAAAAAAAAABLL * (a2 - a1);
  BOOL result = 1LL;
  switch(v4)
  {
    case 0uLL:
    case 1uLL:
      return result;
    case 2uLL:
      uint64_t v6 = 0LL;
      uint64_t v7 = *(a2 - 3);
      uint64_t v8 = *a1;
      while (1)
      {
        uint64_t v9 = CollectCounterData(GTMTLReplayController *,NSArray *,unsigned long long,NSArray *,unsigned long,GTMTLReplayOperationQueues *,NSOperation *,unsigned int,BOOL,unsigned int,GTAGXPerfStateControl *)::kCounterCompare[v6];
        unint64_t v10 = *(void *)(v7 + 8 * v9);
        unint64_t v11 = *(void *)(v8 + 8 * v9);
        if (v10 != v11) {
          break;
        }
        if (++v6 == 4) {
          return 1LL;
        }
      }

      if (v10 < v11)
      {
        *a1 = v7;
        *(a2 - 3) = v8;
        uint64_t v29 = a1[1];
        a1[1] = *(a2 - 2);
        *(a2 - 2) = v29;
        uint64_t v30 = a1[2];
        a1[2] = *(a2 - 1);
        *(a2 - 1) = v30;
      }

      return 1LL;
    case 3uLL:
      _ZNSt3__17__sort3B8nn180100INS_17_ClassicAlgPolicyERZZZL18CollectCounterDataP21GTMTLReplayControllerP7NSArrayyS5_mP26GTMTLReplayOperationQueuesP11NSOperationjbjP21GTAGXPerfStateControlEUb_EUb0_E3__0PNS_6vectorIyNS_9allocatorIyEEEEEEjT1_SJ_SJ_T0_( a1,  a1 + 3,  a2 - 3);
      return 1LL;
    case 4uLL:
      _ZNSt3__17__sort4B8nn180100INS_17_ClassicAlgPolicyERZZZL18CollectCounterDataP21GTMTLReplayControllerP7NSArrayyS5_mP26GTMTLReplayOperationQueuesP11NSOperationjbjP21GTAGXPerfStateControlEUb_EUb0_E3__0PNS_6vectorIyNS_9allocatorIyEEEEEEvT1_SJ_SJ_SJ_T0_( a1,  a1 + 3,  a1 + 6,  a2 - 3);
      return 1LL;
    case 5uLL:
      _ZNSt3__124__sort5_maybe_branchlessB8nn180100INS_17_ClassicAlgPolicyERZZZL18CollectCounterDataP21GTMTLReplayControllerP7NSArrayyS5_mP26GTMTLReplayOperationQueuesP11NSOperationjbjP21GTAGXPerfStateControlEUb_EUb0_E3__0PNS_6vectorIyNS_9allocatorIyEEEELi0EEEvT1_SJ_SJ_SJ_SJ_T0_( a1,  a1 + 3,  a1 + 6,  a1 + 9,  a2 - 3);
      return 1LL;
    default:
      uint64_t v12 = a1 + 6;
      _ZNSt3__17__sort3B8nn180100INS_17_ClassicAlgPolicyERZZZL18CollectCounterDataP21GTMTLReplayControllerP7NSArrayyS5_mP26GTMTLReplayOperationQueuesP11NSOperationjbjP21GTAGXPerfStateControlEUb_EUb0_E3__0PNS_6vectorIyNS_9allocatorIyEEEEEEjT1_SJ_SJ_T0_( a1,  a1 + 3,  a1 + 6);
      uint64_t v13 = a1 + 9;
      if (a1 + 9 == a2) {
        return 1LL;
      }
      int v14 = 0;
      break;
  }

  while (2)
  {
    uint64_t v15 = 0LL;
    uint64_t v16 = *v13;
    while (1)
    {
      uint64_t v17 = CollectCounterData(GTMTLReplayController *,NSArray *,unsigned long long,NSArray *,unsigned long,GTMTLReplayOperationQueues *,NSOperation *,unsigned int,BOOL,unsigned int,GTAGXPerfStateControl *)::kCounterCompare[v15];
      unint64_t v18 = *(void *)(v16 + 8 * v17);
      unint64_t v19 = *(void *)(*v12 + 8 * v17);
      if (v18 != v19) {
        break;
      }
      if (++v15 == 4) {
        goto LABEL_25;
      }
    }

    if (v18 < v19)
    {
      __int128 v20 = *(_OWORD *)(v13 + 1);
      *uint64_t v13 = 0LL;
      v13[1] = 0LL;
      uint64_t v21 = v13;
      v13[2] = 0LL;
      while (1)
      {
        *(_OWORD *)uint64_t v21 = *(_OWORD *)v12;
        v21[2] = v12[2];
        uint64_t *v12 = 0LL;
        v12[1] = 0LL;
        v12[2] = 0LL;
        if (v12 == a1) {
          break;
        }
        uint64_t v21 = v12;
        uint64_t v22 = 0LL;
        uint64_t v24 = *(v12 - 3);
        v12 -= 3;
        uint64_t v23 = v24;
        while (1)
        {
          uint64_t v25 = CollectCounterData(GTMTLReplayController *,NSArray *,unsigned long long,NSArray *,unsigned long,GTMTLReplayOperationQueues *,NSOperation *,unsigned int,BOOL,unsigned int,GTAGXPerfStateControl *)::kCounterCompare[v22];
          unint64_t v26 = *(void *)(v16 + 8 * v25);
          unint64_t v27 = *(void *)(v23 + 8 * v25);
          if (v26 != v27) {
            break;
          }
          if (++v22 == 4) {
            goto LABEL_22;
          }
        }

        if (v26 >= v27) {
          goto LABEL_22;
        }
      }

      uint64_t v21 = a1;
LABEL_22:
      uint64_t v28 = (void *)*v21;
      if (*v21)
      {
        v21[1] = (uint64_t)v28;
        __int128 v31 = v20;
        operator delete(v28);
        __int128 v20 = v31;
      }

      *uint64_t v21 = v16;
      *(_OWORD *)(v21 + 1) = v20;
      if (++v14 == 8) {
        return v13 + 3 == a2;
      }
    }

void *std::vector<unsigned long long>::vector(void *a1, uint64_t a2)
{
  *a1 = 0LL;
  a1[1] = 0LL;
  a1[2] = 0LL;
  unint64_t v4 = *(const void **)a2;
  uint64_t v3 = *(void *)(a2 + 8);
  int64_t v5 = v3 - *(void *)a2;
  if (v3 != *(void *)a2)
  {
    std::vector<unsigned long>::__vallocate[abi:nn180100](a1, v5 >> 3);
    uint64_t v6 = (char *)a1[1];
    memmove(v6, v4, v5);
    a1[1] = &v6[v5];
  }

  return a1;
}

void *std::__fill_n[abi:nn180100]<true,std::vector<BOOL>>(void *result, unint64_t a2)
{
  unint64_t v2 = a2;
  uint64_t v3 = result;
  int v4 = *((_DWORD *)result + 2);
  int64_t v5 = (void *)*result;
  if (v4)
  {
    else {
      unint64_t v6 = (64 - v4);
    }
    *v5++ |= (0xFFFFFFFFFFFFFFFFLL >> (64 - v4 - v6)) & (-1LL << v4);
    unint64_t v2 = a2 - v6;
    uint64_t *result = v5;
  }

  unint64_t v7 = v2 >> 6;
  if (v2 >= 0x40) {
    BOOL result = memset(v5, 255, 8 * v7);
  }
  if ((v2 & 0x3F) != 0)
  {
    uint64_t v8 = &v5[v7];
    void *v3 = v8;
    *v8 |= 0xFFFFFFFFFFFFFFFFLL >> -(v2 & 0x3F);
  }

  return result;
}

void std::__fill_n[abi:nn180100]<false,std::vector<BOOL>>(uint64_t a1, unint64_t a2)
{
  unint64_t v2 = a2;
  int v4 = *(_DWORD *)(a1 + 8);
  int64_t v5 = *(void **)a1;
  if (v4)
  {
    else {
      unint64_t v6 = (64 - v4);
    }
    *v5++ &= ~((0xFFFFFFFFFFFFFFFFLL >> (64 - v4 - v6)) & (-1LL << v4));
    unint64_t v2 = a2 - v6;
    *(void *)a1 = v5;
  }

  unint64_t v7 = v2 >> 6;
  if (v2 >= 0x40) {
    bzero(v5, 8 * v7);
  }
  if ((v2 & 0x3F) != 0)
  {
    uint64_t v8 = &v5[v7];
    *(void *)a1 = v8;
    *v8 &= ~(0xFFFFFFFFFFFFFFFFLL >> -(v2 & 0x3F));
  }

void SortCounterData(NSMutableData *a1, uint64_t a2)
{
  uint64_t v3 = a1;
  NSUInteger v4 = -[NSMutableData length](v3, "length");
  int64_t v5 = v3;
  qsort( -[NSMutableData mutableBytes](v5, "mutableBytes"),  v4 / (8 * a2),  8 * a2,  (int (__cdecl *)(const void *, const void *))compareSampleData);
}

void sub_9C934(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t compareSampleData(void *a1, void *a2)
{
  uint64_t v2 = 0LL;
  while (1)
  {
    uint64_t v3 = compareSampleData(void const*,void const*)::kCounterCompare[v2];
    unint64_t v4 = a1[v3];
    unint64_t v5 = a2[v3];
    if (v4 < v5) {
      return 0xFFFFFFFFLL;
    }
    if (v5 < v4) {
      break;
    }
    if (++v2 == 4) {
      return 0LL;
    }
  }

  return 1LL;
}

void ___ZL15CollectCountersP21GTMTLReplayControllerP26GTMTLReplayOperationQueuesP7NSArrayS4_yP19NSMutableDictionaryjjP21GTAGXPerfStateControl_block_invoke( uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 48);
  uint64_t v2 = *(void **)(a1 + 56);
  id v3 = *(id *)(a1 + 40);
  id v45 = v1;
  id v43 = v2;
  unint64_t v53 = (char *)[v45 count];
  unint64_t v4 = (void *)objc_claimAutoreleasedReturnValue([v43 objectAtIndexedSubscript:0]);
  unint64_t v5 = (void *)objc_claimAutoreleasedReturnValue([v45 objectAtIndexedSubscript:0]);
  unint64_t v55 = (unint64_t)[v4 length];
  id v6 = [v5 count];

  unint64_t v50 = (unint64_t)[v3 count];
  unint64_t v51 = 8LL * (void)v6;
  unint64_t v47 = v55 / (8 * (uint64_t)v6);
  id v44 = (id)objc_claimAutoreleasedReturnValue(+[NSMutableData dataWithLength:](&OBJC_CLASS___NSMutableData, "dataWithLength:", 8 * v47 * 2 * v50));
  if (v53)
  {
    uint64_t v8 = 0LL;
    if (v47 <= 1) {
      unint64_t v9 = 1LL;
    }
    else {
      unint64_t v9 = v55 / (8 * (uint64_t)v6);
    }
    do
    {
      unint64_t v10 = (void *)objc_claimAutoreleasedReturnValue([v45 objectAtIndexedSubscript:v8]);
      id v11 = [v10 count];
      if (v11)
      {
        for (uint64_t i = 0LL; i != v11; uint64_t i = (char *)i + 1)
        {
          uint64_t v13 = (void *)objc_claimAutoreleasedReturnValue([v10 objectAtIndexedSubscript:i]);
          v61[(void)i] = [v3 indexOfObject:v13];
        }
      }

      id v14 = objc_claimAutoreleasedReturnValue([v43 objectAtIndexedSubscript:v8]);
      uint64_t v15 = (char *)[v14 bytes];
      uint64_t v16 = (char *)[v44 mutableBytes];
      if (v51 <= v55)
      {
        uint64_t v17 = 0LL;
        do
        {
          if (v11)
          {
            for (unint64_t j = 0LL; j != v11; unint64_t j = (char *)j + 1)
            {
              uint64_t v19 = v61[(void)j];
              if (v19 != 0x7FFFFFFFFFFFFFFFLL)
              {
                __int128 v20 = &v16[16 * v19];
                *(void *)__int128 v20 = *(void *)&v15[8 * (void)j];
                *((void *)v20 + 1) = *((void *)v15 + 6);
              }
            }
          }

          v15 += 8 * (void)v11;
          v16 += 16 * v50;
          ++v17;
        }

        while (v17 != v9);
      }

      ++v8;
    }

    while (v8 != v53);
  }

  uint64_t v46 = (void *)objc_opt_new(&OBJC_CLASS___NSMutableArray, v7);
  id v21 = v44;
  uint64_t v22 = [v21 bytes];
  id v40 = v21;
  uint64_t v23 = [v40 bytes];
  if (v51 <= v55)
  {
    uint64_t v49 = 0LL;
    uint64_t v54 = 0LL;
    uint64_t v56 = 0LL;
    if (v47 <= 1) {
      uint64_t v24 = 1LL;
    }
    else {
      uint64_t v24 = v47;
    }
    uint64_t v42 = v24;
    uint64_t v52 = v23 + 5;
    while (1)
    {
      uint64_t v48 = v23;
      if (*v23 == *v22)
      {
        if (v23[2] != v22[2])
        {

          uint64_t v56 = 0LL;
        }

        if (v54) {
          goto LABEL_29;
        }
      }

      else
      {

        uint64_t v56 = 0LL;
      }

      uint64_t v54 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableArray array](&OBJC_CLASS___NSMutableArray, "array"));
      [v46 addObject:v54];
LABEL_29:
      if (!v56)
      {
        uint64_t v56 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableArray array](&OBJC_CLASS___NSMutableArray, "array"));
        [v54 addObject:v56];
      }

      uint64_t v25 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableArray arrayWithCapacity:](&OBJC_CLASS___NSMutableArray, "arrayWithCapacity:", v50));
      [v56 addObject:v25];
      unint64_t v26 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedInteger:]( NSNumber,  "numberWithUnsignedInteger:",  (char *)[v46 count] - 1));
      v61[0] = v26;
      v61[1] = &off_5A0700;
      unint64_t v27 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", v61, 2LL));
      [v25 addObject:v27];

      uint64_t v28 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedInteger:]( NSNumber,  "numberWithUnsignedInteger:",  (char *)[v54 count] - 1));
      v60[0] = v28;
      v60[1] = &off_5A0700;
      uint64_t v29 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", v60, 2LL));
      [v25 addObject:v29];

      uint64_t v30 = v52;
      unint64_t v31 = v50 - 2;
      if (v50 > 2)
      {
        do
        {
          unint64_t v32 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  *(v30 - 1)));
          v59[0] = v32;
          uint64_t v33 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  *v30));
          v59[1] = v33;
          uint64_t v34 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", v59, 2LL));
          [v25 addObject:v34];

          v30 += 2;
          --v31;
        }

        while (v31);
      }

      uint64_t v22 = v48;
      uint64_t v23 = &v48[2 * v50];
      v52 += 2 * v50;
      if (++v49 == v42) {
        goto LABEL_34;
      }
    }
  }

  uint64_t v54 = 0LL;
  uint64_t v56 = 0LL;
LABEL_34:
  id v35 = v46;

  [*(id *)(a1 + 32) setObject:v35 forKeyedSubscript:@"AverageSamples"];
  [*(id *)(a1 + 32) setObject:*(void *)(a1 + 48) forKeyedSubscript:@"counterLists"];
  [*(id *)(a1 + 32) setObject:*(void *)(a1 + 40) forKeyedSubscript:@"counters"];
  uint64_t v36 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedInteger:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedInteger:",  *(void *)(a1 + 88)));
  [*(id *)(a1 + 32) setObject:v36 forKeyedSubscript:@"numberOfPasses"];

  if (*(_BYTE *)(*(void *)(*(void *)(a1 + 64) + 8LL) + 24LL))
  {
    v57[0] = @"enabled";
    uint64_t v37 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithBool:](&OBJC_CLASS___NSNumber, "numberWithBool:", 1LL));
    v58[0] = v37;
    v57[1] = @"consistent";
    uint64_t v38 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithBool:]( &OBJC_CLASS___NSNumber,  "numberWithBool:",  *(unsigned __int8 *)(*(void *)(*(void *)(a1 + 72) + 8LL) + 24LL)));
    v58[1] = v38;
    v57[2] = @"level";
    v58[2] = *(void *)(*(void *)(*(void *)(a1 + 80) + 8LL) + 40LL);
    unint64_t v39 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v58,  v57,  3LL));
    [*(id *)(a1 + 32) setObject:v39 forKeyedSubscript:@"Frame Consistent Perf Info"];
  }

  else
  {
    [*(id *)(a1 + 32) setObject:&off_59FF48 forKeyedSubscript:@"Frame Consistent Perf Info"];
  }

void sub_9D020(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void ___ZL15CollectCountersP21GTMTLReplayControllerP26GTMTLReplayOperationQueuesP7NSArrayS4_yP19NSMutableDictionaryjjP21GTAGXPerfStateControl_block_invoke_2( uint64_t a1)
{
  id v3 = (NSMutableData *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) objectAtIndexedSubscript:*(void *)(a1 + 48)]);
  uint64_t v2 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 40) objectAtIndexedSubscript:*(void *)(a1 + 48)]);
  SortCounterData(v3, (uint64_t)[v2 count]);
}

void sub_9D1F0( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
}

id ___ZL15CollectCountersP21GTMTLReplayControllerP26GTMTLReplayOperationQueuesP7NSArrayS4_yP19NSMutableDictionaryjjP21GTAGXPerfStateControl_block_invoke_3( uint64_t a1)
{
  uint64_t v2 = *(GTMTLReplayController **)(a1 + 88);
  id v3 = (NSArray *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) objectAtIndexedSubscript:*(void *)(a1 + 96)]);
  CollectCounterData( v2,  v3,  *(void *)(a1 + 104),  *(NSArray **)(a1 + 40),  *(void *)(a1 + 96),  *(GTMTLReplayOperationQueues **)(a1 + 112),  *(NSOperation **)(a1 + 48),  *(unsigned int *)(a1 + 128),  0,  *(_DWORD *)(a1 + 132),  *(GTAGXPerfStateControl **)(a1 + 120));

  [*(id *)(a1 + 56) finish];
  [*(id *)(a1 + 56) setStatEnabled:0];
  [*(id *)(a1 + 56) setGPUPriority:1];
  uint64_t v4 = *(void *)(a1 + 120);
  if (*(void *)(v4 + 16) || *(_DWORD *)(v4 + 4) == 1)
  {
    unint64_t v5 = GTAGXPerfStateControl::ConsistentGPUPerfStateLevel((GTAGXPerfStateControl *)v4, 0LL);
    id v6 = (void *)objc_claimAutoreleasedReturnValue(v5);
    if (v6)
    {
      if ([*(id *)(*(void *)(*(void *)(a1 + 64) + 8) + 40) length])
      {
        uint64_t v7 = *(void *)(*(void *)(a1 + 72) + 8LL);
        if (*(_BYTE *)(v7 + 24))
        {
          uint64_t v8 = (void *)objc_claimAutoreleasedReturnValue([v6 objectForKeyedSubscript:@"enabled"]);
          *(_BYTE *)(*(void *)(*(void *)(a1 + 72) + 8) + 24) = [v8 BOOLValue];
        }

        else
        {
          *(_BYTE *)(v7 + 24) = 0;
        }

        if (!*(_BYTE *)(*(void *)(*(void *)(a1 + 72) + 8LL) + 24LL))
        {
          *(_BYTE *)(*(void *)(*(void *)(a1 + 80) + 8LL) + 24LL) = 0;
          goto LABEL_13;
        }

        uint64_t v12 = (void *)objc_claimAutoreleasedReturnValue([v6 objectForKeyedSubscript:@"consistent"]);
        unsigned __int8 v13 = [v12 BOOLValue];
      }

      else
      {
        unint64_t v9 = *(void **)(*(void *)(*(void *)(a1 + 64) + 8LL) + 40LL);
        unint64_t v10 = (void *)objc_claimAutoreleasedReturnValue([v6 objectForKeyedSubscript:@"level"]);
        [v9 setString:v10];

        id v11 = (void *)objc_claimAutoreleasedReturnValue([v6 objectForKeyedSubscript:@"enabled"]);
        *(_BYTE *)(*(void *)(*(void *)(a1 + 72) + 8) + 24) = [v11 BOOLValue];

        uint64_t v12 = (void *)objc_claimAutoreleasedReturnValue([v6 objectForKeyedSubscript:@"consistent"]);
        unsigned __int8 v13 = [v12 BOOLValue];
      }

      *(_BYTE *)(*(void *)(*(void *)(a1 + 80) + 8LL) + 24LL) = v13;
    }

void sub_9D40C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void ___ZL24CalculateFrameTimeLegacyP21GTMTLReplayControllerP26GTMTLReplayOperationQueuesP7NSArrayS4_yjP14NSMutableArrayIP8NSNumberEmjP21GTAGXPerfStateControl_block_invoke( uint64_t a1)
{
  uint64_t v2 = *(void *)(*(void *)(a1 + 40) + 8LL);
  unint64_t v3 = *(void *)(v2 + 48);
  uint64_t v4 = *(unint64_t **)(v2 + 56);
  unint64_t v5 = 126 - 2 * __clz(0xAAAAAAAAAAAAAAABLL * ((uint64_t)((uint64_t)v4 - v3) >> 3));
  else {
    uint64_t v6 = v5;
  }
  std::__introsort<std::_ClassicAlgPolicy,std::__less<void,void> &,std::tuple<unsigned long long,unsigned long long,unsigned long long> *,false>( v3,  v4,  v6,  1);
  uint64_t v7 = *(void *)(*(void *)(a1 + 40) + 8LL);
  uint64_t v8 = *(unint64_t **)(v7 + 48);
  unint64_t v9 = *(unint64_t **)(v7 + 56);
  if (v8 == v9)
  {
    uint64_t v10 = 0LL;
  }

  else
  {
    uint64_t v10 = 0LL;
    unint64_t v11 = 0LL;
    do
    {
      unint64_t v12 = *v8;
      unint64_t v13 = v8[1];
      v8 += 3;
      if (v11 <= v12) {
        unint64_t v11 = v12;
      }
      BOOL v14 = v13 >= v11;
      unint64_t v15 = v13 - v11;
      if (v13 > v11) {
        unint64_t v11 = v13;
      }
      if (!v14) {
        unint64_t v15 = 0LL;
      }
      v10 += v15;
    }

    while (v8 != v9);
  }

  id v16 = (id)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLongLong:](&OBJC_CLASS___NSNumber, "numberWithUnsignedLongLong:", v10));
  objc_msgSend(*(id *)(a1 + 32), "setObject:atIndexedSubscript:");
}

void sub_9D50C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
}

id ___ZL24CalculateFrameTimeLegacyP21GTMTLReplayControllerP26GTMTLReplayOperationQueuesP7NSArrayS4_yjP14NSMutableArrayIP8NSNumberEmjP21GTAGXPerfStateControl_block_invoke_2( uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 72);
  if (*(void *)(v2 + 16) || *(_DWORD *)(v2 + 4) == 1)
  {
    if (!GTAGXPerfStateControl::IsGPUPerformanceStateInduced((GTAGXPerfStateControl *)v2)) {
      GTAGXPerfStateControl::EnableConsistentGPUPerfState(*(void *)(a1 + 72), *(unsigned int *)(a1 + 104));
    }
    [*(id *)(a1 + 32) setStatOptions:805306368];
  }

  else if (*(_DWORD *)(a1 + 108))
  {
    uint64_t v7 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(*(void *)(a1 + 64) + 8) defaultDevice]);
    if ((objc_opt_respondsToSelector(v7, "setConsistentGPUPerfStateTo:") & 1) != 0) {
      [v7 setConsistentGPUPerfStateTo:*(unsigned int *)(a1 + 108)];
    }
    [*(id *)(a1 + 32) setStatOptions:2952790016];
  }

  [*(id *)(a1 + 32) setStatLocations:*(void *)(a1 + 80)];
  unint64_t v3 = *(void **)(a1 + 32);
  uint64_t v4 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 40) objectAtIndexedSubscript:0]);
  [v3 requestCounters:v4 withIndex:0];

  unint64_t v5 = *(void **)(a1 + 32);
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 3221225472LL;
  void v8[2] = ___ZL24CalculateFrameTimeLegacyP21GTMTLReplayControllerP26GTMTLReplayOperationQueuesP7NSArrayS4_yjP14NSMutableArrayIP8NSNumberEmjP21GTAGXPerfStateControl_block_invoke_3;
  v8[3] = &unk_58DEA8;
  v8[4] = *(void *)(a1 + 56);
  [v5 addPerfSampleHandler:v8];
  GTMTLReplayController_playTo( *(void *)(a1 + 64),  *(void *)(*(void *)(a1 + 88) + 104LL) + *(void *)(*(void *)(a1 + 88) + 96LL));
  [*(id *)(a1 + 32) finish];
  [*(id *)(a1 + 32) setGPUPriority:1];
  [*(id *)(a1 + 32) setStatEnabled:0];
  GTAGXPerfStateControl::DisableConsistentGPUPerfState(*(GTAGXPerfStateControl **)(a1 + 72));
  return [*(id *)(*(void *)(a1 + 96) + 8) addOperation:*(void *)(a1 + 48)];
}

void sub_9D6B8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void ___ZL24CalculateFrameTimeLegacyP21GTMTLReplayControllerP26GTMTLReplayOperationQueuesP7NSArrayS4_yjP14NSMutableArrayIP8NSNumberEmjP21GTAGXPerfStateControl_block_invoke_3( uint64_t a1, void *a2, void *a3)
{
  id v26 = a2;
  id v5 = a3;
  uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue([v26 label]);
  unsigned __int8 v7 = [v6 hasPrefix:@"com.apple.gputools.replay"];

  if ((v7 & 1) == 0)
  {
    [v26 GPUStartTime];
    double v9 = v8;
    [v26 GPUEndTime];
    unint64_t v10 = (unint64_t)(v9 * 1000000000.0);
    unint64_t v12 = (unint64_t)(v11 * 1000000000.0);
    unint64_t v13 = *(void **)(*(void *)(a1 + 32) + 8LL);
    BOOL v14 = (unint64_t *)v13[7];
    unint64_t v15 = v13[8];
    if ((unint64_t)v14 >= v15)
    {
      unint64_t v17 = 0xAAAAAAAAAAAAAAALL;
      unint64_t v18 = (unint64_t *)v13[6];
      unint64_t v19 = 0xAAAAAAAAAAAAAAABLL * (v14 - v18);
      unint64_t v20 = v19 + 1;
      if (v19 + 1 > 0xAAAAAAAAAAAAAAALL) {
        abort();
      }
      unint64_t v21 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v15 - (void)v18) >> 3);
      if (2 * v21 > v20) {
        unint64_t v20 = 2 * v21;
      }
      if (v21 < 0x555555555555555LL) {
        unint64_t v17 = v20;
      }
      if (v17)
      {
        unint64_t v17 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<std::vector<NSObject  {objcproto21OS_dispatch_semaphore}* {__strong}>>>(v17);
        unint64_t v18 = (unint64_t *)v13[6];
        BOOL v14 = (unint64_t *)v13[7];
      }

      else
      {
        uint64_t v22 = 0LL;
      }

      uint64_t v23 = (unint64_t *)(v17 + 24 * v19);
      unint64_t v24 = v17 + 24 * v22;
      *uint64_t v23 = v10;
      v23[1] = v12;
      v23[2] = (unint64_t)v26;
      id v16 = v23 + 3;
      if (v14 != v18)
      {
        do
        {
          __int128 v25 = *(_OWORD *)(v14 - 3);
          *(v23 - 1) = *(v14 - 1);
          *(_OWORD *)(v23 - 3) = v25;
          v23 -= 3;
          v14 -= 3;
        }

        while (v14 != v18);
        unint64_t v18 = (unint64_t *)v13[6];
      }

      v13[6] = v23;
      v13[7] = v16;
      v13[8] = v24;
      if (v18) {
        operator delete(v18);
      }
    }

    else
    {
      unint64_t *v14 = v10;
      v14[1] = v12;
      id v16 = v14 + 3;
      v14[2] = (unint64_t)v26;
    }

    v13[7] = v16;
  }
}

void sub_9D878( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

uint64_t ___ZL18PerformUSCSamplingP21GTMTLReplayControllerP12NSDictionary_block_invoke(uint64_t result)
{
  return result;
}

void *std::__hash_table<std::__hash_value_type<unsigned int,unsigned int>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,unsigned int>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int &&>,std::tuple<>>( uint64_t a1, unsigned int a2, _DWORD *a3)
{
  unint64_t v6 = a2;
  unint64_t v7 = *(void *)(a1 + 8);
  if (v7)
  {
    uint8x8_t v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      unint64_t v3 = a2;
      if (v7 <= a2) {
        unint64_t v3 = a2 % v7;
      }
    }

    else
    {
      unint64_t v3 = ((_DWORD)v7 - 1) & a2;
    }

    double v9 = *(void ***)(*(void *)a1 + 8 * v3);
    if (v9)
    {
      unint64_t v10 = *v9;
      if (*v9)
      {
        do
        {
          unint64_t v11 = v10[1];
          if (v11 == a2)
          {
            if (*((_DWORD *)v10 + 4) == a2) {
              return v10;
            }
          }

          else
          {
            if (v8.u32[0] > 1uLL)
            {
              if (v11 >= v7) {
                v11 %= v7;
              }
            }

            else
            {
              v11 &= v7 - 1;
            }

            if (v11 != v3) {
              break;
            }
          }

          unint64_t v10 = (void *)*v10;
        }

        while (v10);
      }
    }
  }

  unint64_t v10 = operator new(0x18uLL);
  void *v10 = 0LL;
  v10[1] = v6;
  *((_DWORD *)v10 + 4) = *a3;
  *((_DWORD *)v10 + 5) = 0;
  float v12 = (float)(unint64_t)(*(void *)(a1 + 24) + 1LL);
  float v13 = *(float *)(a1 + 32);
  if (!v7 || (float)(v13 * (float)v7) < v12)
  {
    BOOL v14 = 1LL;
    if (v7 >= 3) {
      BOOL v14 = (v7 & (v7 - 1)) != 0;
    }
    unint64_t v15 = v14 | (2 * v7);
    unint64_t v16 = vcvtps_u32_f32(v12 / v13);
    if (v15 <= v16) {
      size_t v17 = v16;
    }
    else {
      size_t v17 = v15;
    }
    std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__rehash<true>( a1,  v17);
    unint64_t v7 = *(void *)(a1 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v7 <= v6) {
        unint64_t v3 = v6 % v7;
      }
      else {
        unint64_t v3 = v6;
      }
    }

    else
    {
      unint64_t v3 = ((_DWORD)v7 - 1) & v6;
    }
  }

  uint64_t v18 = *(void *)a1;
  unint64_t v19 = *(void **)(*(void *)a1 + 8 * v3);
  if (v19)
  {
    void *v10 = *v19;
LABEL_38:
    void *v19 = v10;
    goto LABEL_39;
  }

  void *v10 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = v10;
  *(void *)(v18 + 8 * v3) = a1 + 16;
  if (*v10)
  {
    unint64_t v20 = *(void *)(*v10 + 8LL);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v20 >= v7) {
        v20 %= v7;
      }
    }

    else
    {
      v20 &= v7 - 1;
    }

    unint64_t v19 = (void *)(*(void *)a1 + 8 * v20);
    goto LABEL_38;
  }

void sub_9DABC(_Unwind_Exception *a1)
{
}

void ___ZL18PerformUSCSamplingP21GTMTLReplayControllerP12NSDictionary_block_invoke_2( id a1, void *a2, unint64_t a3)
{
}

id GTMTLReplayClient_embeddedDerivedCounterData(GTMTLReplayController *a1, id *a2, void *a3)
{
  id v4 = a3;
  uint64_t v232 = v4;
  v234 = (void *)objc_opt_new(&OBJC_CLASS___NSMutableDictionary, v5);
  if (v4)
  {
    unint64_t v6 = (void *)objc_claimAutoreleasedReturnValue([v4 objectForKeyedSubscript:@"profileCounters"]);
    [v234 setObject:v6 forKeyedSubscript:@"profileCounters"];
  }

  else
  {
    unint64_t v7 = (void *)objc_claimAutoreleasedReturnValue([a1->var1 defaultDevice]);
    id Analysis = DYMTLReplayFrameProfiler_loadAnalysis(v7);
    unint64_t v6 = (void *)objc_claimAutoreleasedReturnValue(Analysis);

    [v234 addEntriesFromDictionary:v6];
  }

  int v270 = 0x7FFFFFFF;
  __int128 v231 = (void *)objc_claimAutoreleasedReturnValue([v4 objectForKeyedSubscript:@"MetalPluginName"]);
  if (v231)
  {
    double v9 = (void *)objc_claimAutoreleasedReturnValue([v4 objectForKeyedSubscript:@"gpuTarget"]);
    unint64_t v10 = v9;
    if (v9) {
      int v270 = [v9 intValue];
    }
  }

  else
  {
    io_registry_entry_t IOAccelerator = GetIOAccelerator();
    id MetalPluginName = GetMetalPluginName(IOAccelerator, &v270);
    __int128 v231 = (void *)objc_claimAutoreleasedReturnValue(MetalPluginName);
  }

  float v13 = (GTAGXPerfStateControl *)operator new(0x18uLL);
  v256 = a2;
  *(void *)float v13 = 0LL;
  *((void *)v13 + 1) = 0LL;
  uint64_t v235 = v13;
  *((void *)v13 + 2) = 0LL;
  BOOL v14 = (void *)objc_claimAutoreleasedReturnValue([a1->var1 defaultDevice]);
  GTAGXPerfStateControl::InitWithDevice((uint64_t)v235, v14);

  MetalPluginTarget(v231);
  if (v270 <= -2)
  {
    id v15 = v234;
    uint64_t v305 = 0LL;
    id v306 = &v305;
    uint64_t v307 = 0x3032000000LL;
    unint64_t v308 = __Block_byref_object_copy__53;
    id v309 = __Block_byref_object_dispose__54;
    id v310 = (id)objc_opt_new(&OBJC_CLASS___NSMutableDictionary, v16);
    uint64_t v18 = (void *)objc_opt_new(&OBJC_CLASS___NSOperation, v17);
    uint64_t v311 = _NSConcreteStackBlock;
    uint64_t v312 = 3221225472LL;
    id v313 = ___ZL31CollectDerivedCounterDataLegacyP21GTMTLReplayControllerP26GTMTLReplayOperationQueuesP12NSDictionaryP21GTAGXPerfStateControl_block_invoke;
    v314 = &unk_58E080;
    unint64_t v19 = (NSDictionary *)v15;
    v315 = v19;
    unint64_t v20 = v18;
    v318 = a1;
    v319 = a2;
    uint64_t v316 = v20;
    uint64_t v317 = (double *)&v305;
    id v320 = v235;
    obunint64_t j = (id)objc_claimAutoreleasedReturnValue( +[NSBlockOperation blockOperationWithBlock:]( &OBJC_CLASS___NSBlockOperation,  "blockOperationWithBlock:",  &v311));
    objc_msgSend(a2[1], "addOperation:");
    uint64_t v22 = (void *)objc_opt_new(&OBJC_CLASS___NSMutableDictionary, v21);
    unint64_t v24 = (void *)objc_opt_new(&OBJC_CLASS___NSMutableDictionary, v23);
    __int128 v25 = -[NSMutableArray initWithObjects:]( objc_alloc(&OBJC_CLASS___NSMutableArray),  "initWithObjects:",  &off_5A06E8,  0LL);
    double v287 = 1.0;
    id v26 = (void *)objc_claimAutoreleasedReturnValue( -[NSDictionary objectForKeyedSubscript:]( v19,  "objectForKeyedSubscript:",  @"CollectTimingData"));
    BOOL v27 = v26 == 0LL;

    if (!v27)
    {
      v275[0] = 0;
      LODWORD(v282) = 0;
      GetConsistentPStates(v19, v275, (unsigned int *)&v282, &v287, v271);
      uint64_t v28 = ProfilingTimingDataLegacy((uint64_t)a1, a2, v22, v24, v25, v275[0], v282, v271[0], (uint64_t)v235);
      uint64_t v29 = (void *)objc_claimAutoreleasedReturnValue(v28);
      [v20 addDependency:v29];
    }

    [v20 waitUntilFinished];
    uint64_t v30 = (void *)objc_claimAutoreleasedReturnValue( -[NSDictionary objectForKeyedSubscript:]( v19,  "objectForKeyedSubscript:",  @"CollectTimingData"));
    BOOL v31 = v30 == 0LL;

    if (!v31)
    {
      [(id)v306[5] setObject:v22 forKeyedSubscript:@"TimingPerformanceData"];
      [(id)v306[5] setObject:v24 forKeyedSubscript:@"BlitTimeData"];
      double v32 = v287;
      uint64_t v33 = (void *)objc_claimAutoreleasedReturnValue(-[NSMutableArray objectAtIndexedSubscript:](v25, "objectAtIndexedSubscript:", 1LL));
      id v34 = [v33 unsignedLongLongValue];
      id v35 = (void *)objc_claimAutoreleasedReturnValue(-[NSMutableArray objectAtIndexedSubscript:](v25, "objectAtIndexedSubscript:", 0LL));
      id v36 = [v35 unsignedLongLongValue];

      uint64_t v37 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  (unint64_t)((1.0 - v32) * (double)(unint64_t)v36 + v32 * (double)(unint64_t)v34)));
      uint64_t v38 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObject:forKey:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObject:forKey:",  v37,  @"gputime"));
      [(id)v306[5] setObject:v38 forKeyedSubscript:@"consistent time"];
    }

    id v233 = (id)v306[5];

    _Block_object_dispose(&v305, 8);
    goto LABEL_213;
  }

  unint64_t v39 = v234;
  *(void *)id v296 = 0LL;
  double v294 = 1.0;
  __int128 v223 = v39;
  GetConsistentPStates(v39, &v296[1], v296, &v294, &v295);
  double v287 = 0.0;
  __int128 v288 = &v287;
  uint64_t v289 = 0x7812000000LL;
  uint64_t v290 = __Block_byref_object_copy__188;
  __int128 v291 = __Block_byref_object_dispose__189;
  id v292 = "!1 2";
  GRCInfo::GRCInfo((GRCInfo *)v293, a1, v295, v235);
  uint64_t v41 = (void *)objc_opt_new(&OBJC_CLASS___NSMutableDictionary, v40);
  v259 = v288;
  id v229 = v41;
  __int128 v228 = v39;
  __src = (void *)objc_claimAutoreleasedReturnValue(-[NSDictionary objectForKeyedSubscript:](v228, "objectForKeyedSubscript:", @"profileCounters"));
  uint64_t v42 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableSet setWithArray:](&OBJC_CLASS___NSMutableSet, "setWithArray:", __src));
  [v42 addObjectsFromArray:&off_59F8F0];
  id v43 = (void *)objc_claimAutoreleasedReturnValue( +[NSMutableDictionary dictionaryWithCapacity:]( &OBJC_CLASS___NSMutableDictionary,  "dictionaryWithCapacity:",  4096LL));
  for (id obja = 0; obja < [*((id *)v259 + 9) count]; ++obja)
  {
    uint64_t v261 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*((id *)v259 + 9), "objectAtIndexedSubscript:"));
    id v44 = (void *)objc_claimAutoreleasedReturnValue([v261 availableCounters]);
    __int128 v277 = 0u;
    __int128 v278 = 0u;
    *(_OWORD *)v275 = 0u;
    __int128 v276 = 0u;
    id v45 = v44;
    id v46 = [v45 countByEnumeratingWithState:v275 objects:&v311 count:16];
    if (v46)
    {
      uint64_t v47 = *(void *)v276;
      do
      {
        for (uint64_t i = 0LL; i != v46; uint64_t i = (char *)i + 1)
        {
          if (*(void *)v276 != v47) {
            objc_enumerationMutation(v45);
          }
          uint64_t v49 = *(void **)(*(void *)&v275[2] + 8LL * (void)i);
          unint64_t v50 = (void *)objc_claimAutoreleasedReturnValue([v49 name]);
          unsigned int v51 = [v42 containsObject:v50];

          if (v51)
          {
            uint64_t v52 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedInteger:]( NSNumber,  "numberWithUnsignedInteger:",  [v49 counterValueType]));
            unint64_t v53 = (void *)objc_claimAutoreleasedReturnValue([v49 name]);
            [v43 setObject:v52 forKeyedSubscript:v53];
          }
        }

        id v46 = [v45 countByEnumeratingWithState:v275 objects:&v311 count:16];
      }

      while (v46);
    }
  }

  [v229 setDictionary:v43];
  v262 = (void *)objc_claimAutoreleasedReturnValue( +[NSMutableArray arrayWithCapacity:]( NSMutableArray,  "arrayWithCapacity:",  (char *)[__src count] + (void)objc_msgSend(*((id *)v259 + 12), "count")));
  [v262 addObjectsFromArray:*((void *)v259 + 12)];
  __int128 v284 = 0u;
  __int128 v285 = 0u;
  __int128 v282 = 0u;
  __int128 v283 = 0u;
  id objb = __src;
  id v54 = [objb countByEnumeratingWithState:&v282 objects:&v305 count:16];
  if (v54)
  {
    uint64_t v55 = *(void *)v283;
    do
    {
      for (unint64_t j = 0LL; j != v54; unint64_t j = (char *)j + 1)
      {
        if (*(void *)v283 != v55) {
          objc_enumerationMutation(objb);
        }
        id v57 = *(id *)(*((void *)&v282 + 1) + 8LL * (void)j);
        if (([v57 containsString:@"MTLStat"] & 1) == 0)
        {
          uint64_t v58 = (void *)objc_claimAutoreleasedReturnValue( +[GPURawCounterSelect selectWithName:options:]( &OBJC_CLASS___GPURawCounterSelect,  "selectWithName:options:",  v57,  0LL));
          [v262 addObject:v58];
        }
      }

      id v54 = [objb countByEnumeratingWithState:&v282 objects:&v305 count:16];
    }

    while (v54);
  }

  unint64_t v59 = v288 + 6;
  id v60 = v262;
  uint64_t v305 = 0LL;
  id v306 = &v305;
  uint64_t v307 = 0x3032000000LL;
  unint64_t v308 = __Block_byref_object_copy__53;
  id v309 = __Block_byref_object_dispose__54;
  id v310 = 0LL;
  uint64_t v311 = _NSConcreteStackBlock;
  uint64_t v312 = 3221225472LL;
  id v313 = ___ZNK7GRCInfo27SubDividedCounterDictionaryEP14NSMutableArrayIP19GPURawCounterSelectEP26GTMTLReplayOperationQueues_block_invoke;
  v314 = &unk_58F838;
  uint64_t v316 = &v305;
  uint64_t v317 = v59;
  __int128 v226 = (NSDictionary *)v60;
  v315 = v226;
  uint64_t v61 = (void *)objc_claimAutoreleasedReturnValue( +[NSBlockOperation blockOperationWithBlock:]( &OBJC_CLASS___NSBlockOperation,  "blockOperationWithBlock:",  &v311));
  [v61 setQueuePriority:8];
  [*v256 addOperation:v61];
  [v61 waitUntilFinished];
  id v245 = (id)v306[5];

  _Block_object_dispose(&v305, 8);
  DisableComputeEncoderCoalescing((uint64_t)a1, 1LL);
  uint64_t v62 = (void *)objc_claimAutoreleasedReturnValue([v245 objectForKeyedSubscript:@"passNum"]);
  id v63 = [v62 unsignedIntValue];

  *(void *)&__int128 v282 = 0LL;
  *((void *)&v282 + 1) = &v282;
  *(void *)&__int128 v283 = 0x4812000000LL;
  *((void *)&v283 + 1) = __Block_byref_object_copy__193;
  *(void *)&__int128 v284 = __Block_byref_object_dispose__194;
  *((void *)&v284 + 1) = "";
  __int128 v285 = 0uLL;
  uint64_t v286 = 0LL;
  if ((_DWORD)v63)
  {
    unint64_t v65 = (char *)operator new(40LL * v63);
    *(void *)&__int128 v285 = v65;
    unint64_t v66 = &v65[40 * v63];
    uint64_t v286 = v66;
    do
    {
      *(_OWORD *)unint64_t v65 = 0uLL;
      *((_OWORD *)v65 + 1) = 0uLL;
      *((_DWORD *)v65 + _Block_object_dispose(va, 8) = 1065353216;
      v65 += 40;
    }

    while (v65 != v66);
    *((void *)&v285 + 1) = v66;
  }

  unint64_t v239 = (void *)objc_opt_new(&OBJC_CLASS___NSMutableArray, v64);
  uint64_t v263 = v63;
  v240 = (void *)objc_opt_new(&OBJC_CLASS___NSOperation, v67);
  if ((_DWORD)v63)
  {
    int v68 = 0;
    unsigned int v69 = v296[0];
    do
    {
      *(void *)v275 = _NSConcreteStackBlock;
      *(void *)&v275[2] = 3221225472LL;
      *(void *)&__int128 v276 = ___ZL28CollectDerivedCounterDataGRCP21GTMTLReplayControllerP26GTMTLReplayOperationQueuesP12NSDictionaryP21GTAGXPerfStateControl_block_invoke;
      *((void *)&v276 + 1) = &unk_58E0D0;
      *(void *)&__int128 v278 = &v287;
      unsigned int v279 = v69;
      id v70 = v245;
      int v280 = v68;
      *(void *)&__int128 v277 = v70;
      *((void *)&v278 + 1) = &v282;
      *((void *)&v277 + 1) = v239;
      int v281 = (int)v63;
      uint64_t v71 = (void *)objc_claimAutoreleasedReturnValue( +[NSBlockOperation blockOperationWithBlock:]( &OBJC_CLASS___NSBlockOperation,  "blockOperationWithBlock:",  v275));
      [*v256 addOperation:v71];
      [v71 setQueuePriority:-8];
      [v240 addDependency:v71];

      ++v68;
    }

    while ((_DWORD)v63 != v68);
  }

  [v256[1] addOperation:v240];
  [v240 waitUntilFinished];
  DisableComputeEncoderCoalescing((uint64_t)a1, 0LL);
  __int128 v225 = (void *)objc_claimAutoreleasedReturnValue( +[NSArray arrayWithObjects:]( &OBJC_CLASS___NSArray,  "arrayWithObjects:",  @"MTLStatCommandBufferIndex",  @"MTLStatEncoderIndex",  @"MTLStatCommandIndex",  @"MTLStat_nSec",  @"MTLStatDataMaster",  @"MTLStatSampleLocation",  @"MTLStatTotalGPUCycles",  0LL,  v223));
  id v233 = (id)objc_opt_new(&OBJC_CLASS___NSMutableDictionary, v72);
  unint64_t v73 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInt:](&OBJC_CLASS___NSNumber, "numberWithUnsignedInt:", v63));
  [v233 setObject:v73 forKeyedSubscript:@"numberOfPasses"];

  id objc = (id)objc_opt_new(&OBJC_CLASS___NSMutableArray, v74);
  uint64_t v75 = (void *)objc_claimAutoreleasedReturnValue(-[NSDictionary objectForKeyedSubscript:](v228, "objectForKeyedSubscript:", @"profileCounters"));
  id v227 = [v75 mutableCopy];

  [v227 removeObject:@"MTLStat_nSec"];
  id v76 = [v225 mutableCopy];
  unint64_t v77 = (void *)objc_claimAutoreleasedReturnValue([v76 arrayByAddingObjectsFromArray:v227]);
  [v233 setObject:v77 forKeyedSubscript:@"counters"];

  if ((_DWORD)v63)
  {
    uint64_t v78 = 0LL;
    do
    {
      uint64_t v79 = (void *)objc_claimAutoreleasedReturnValue([v245 objectForKeyedSubscript:@"passList"]);
      uint64_t v80 = (void *)objc_claimAutoreleasedReturnValue([v79 objectAtIndexedSubscript:v78]);

      uint64_t v82 = (void *)objc_opt_new(&OBJC_CLASS___NSMutableArray, v81);
      [objc addObject:v82];

      __int128 v273 = 0u;
      __int128 v274 = 0u;
      *(_OWORD *)v271 = 0u;
      __int128 v272 = 0u;
      unint64_t v83 = (void *)objc_claimAutoreleasedReturnValue([v80 firstObject]);
      id v84 = [v83 countByEnumeratingWithState:v271 objects:&v305 count:16];
      if (v84)
      {
        uint64_t v85 = *(void *)v272;
        do
        {
          for (uint64_t k = 0LL; k != v84; uint64_t k = (char *)k + 1)
          {
            if (*(void *)v272 != v85) {
              objc_enumerationMutation(v83);
            }
            uint64_t v87 = *(void **)(*(void *)&v271[2] + 8LL * (void)k);
            uint64_t v88 = (void *)objc_claimAutoreleasedReturnValue([objc lastObject]);
            uint64_t v89 = (void *)objc_claimAutoreleasedReturnValue([v87 name]);
            [v88 addObject:v89];
          }

          id v84 = [v83 countByEnumeratingWithState:v271 objects:&v305 count:16];
        }

        while (v84);
      }

      ++v78;
    }

    while (v78 != v263);
  }

  [v233 setObject:objc forKeyedSubscript:@"counterLists"];
  v264 = v288;
  uint64_t v90 = (void *)objc_claimAutoreleasedReturnValue([v233 objectForKeyedSubscript:@"counters"]);
  uint64_t v257 = *((void *)&v282 + 1);
  id v91 = v90;
  id v246 = objc;
  id v238 = v239;
  id v242 = v229;
  uint64_t v260 = v91;
  id v92 = [v91 count];
  LOBYTE(v311) = 0;
  std::vector<BOOL>::vector(&v303, (unint64_t)v92, (unsigned __int8 *)&v311);
  for (unint64_t m = 0; m < (unint64_t)[v91 count]; ++m)
  {
    uint64_t v94 = (void *)objc_claimAutoreleasedReturnValue([v91 objectAtIndexedSubscript:m]);
    uint64_t v95 = (void *)objc_claimAutoreleasedReturnValue([v242 objectForKeyedSubscript:v94]);
    uint64_t v96 = v95;
    if (v95)
    {
      unsigned int v97 = [v95 BOOLValue];
      unint64_t v98 = m >> 6;
      uint64_t v99 = 1LL << m;
      if (v97) {
        uint64_t v100 = v303[v98] | v99;
      }
      else {
        uint64_t v100 = v303[v98] & ~v99;
      }
      v303[v98] = v100;
    }
  }

  unint64_t v101 = (unint64_t)[v246 count];
  unint64_t v102 = v101;
  if (v101)
  {
    if (v101 >> 61) {
      abort();
    }
    v255 = (GTMTLReplayController *)std::__allocate_at_least[abi:nn180100]<std::allocator<std::pair<unsigned int,unsigned int>>>(v101);
    bzero(v255, 8 * v102);
  }

  else
  {
    v255 = 0LL;
  }

  for (unint64_t n = 0; n < (unint64_t)[v246 count]; ++n)
  {
    unint64_t v104 = (void *)objc_claimAutoreleasedReturnValue([v246 objectAtIndexedSubscript:n]);
    int v105 = [v104 count];
    *((void *)&v255->var0 + n) = v105 - (_BYTE *)[&off_59F8F0 count];
  }

  uint64_t v106 = *(void *)(v257 + 48);
  unint64_t v107 = *(void *)(v106 + 24);
  if (v107)
  {
    if (v107 >> 61) {
      abort();
    }
    unint64_t v108 = (unsigned int *)std::__allocate_at_least[abi:nn180100]<std::allocator<std::pair<unsigned int,unsigned int>>>(v107);
    unint64_t v110 = &v108[2 * v109];
    uint64_t v106 = *(void *)(v257 + 48);
  }

  else
  {
    unint64_t v108 = 0LL;
    unint64_t v110 = 0LL;
  }

  uint64_t v111 = *(uint64_t **)(v106 + 16);
  if (v111)
  {
    unsigned int v112 = 0;
    unint64_t v113 = v108;
    do
    {
      unint64_t v114 = v108;
      if (v113 >= v110)
      {
        unint64_t v116 = v108;
        uint64_t v117 = ((char *)v113 - (char *)v108) >> 3;
        unint64_t v118 = v117 + 1;
        unint64_t v119 = (char *)v110 - (char *)v108;
        unint64_t v120 = v110 - v116;
        if (v120 > v118) {
          unint64_t v118 = v120;
        }
        if (v119 >= 0x7FFFFFFFFFFFFFF8LL) {
          unint64_t v121 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v121 = v118;
        }
        if (v121) {
          unint64_t v121 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<std::pair<unsigned int,unsigned int>>>(v121);
        }
        else {
          uint64_t v122 = 0LL;
        }
        int64_t v123 = (unsigned int *)(v121 + 8 * v117);
        *(void *)int64_t v123 = *(uint64_t *)((char *)v111 + 20);
        __int128 v115 = v123 + 2;
        if (v113 == v114)
        {
          int64_t v125 = v114;
        }

        else
        {
          do
          {
            uint64_t v124 = *((void *)v113 - 1);
            v113 -= 2;
            *((void *)v123 - 1) = v124;
            v123 -= 2;
            int64_t v125 = v114;
          }

          while (v113 != v114);
        }

        unint64_t v110 = (unsigned int *)(v121 + 8 * v122);
        if (v125) {
          operator delete(v125);
        }
        unint64_t v114 = v123;
      }

      else
      {
        *(void *)unint64_t v113 = *(uint64_t *)((char *)v111 + 20);
        __int128 v115 = v113 + 2;
      }

      if (v112 <= *((_DWORD *)v111 + 6)) {
        unsigned int v112 = *((_DWORD *)v111 + 6);
      }
      uint64_t v111 = (uint64_t *)*v111;
      unint64_t v113 = v115;
      unint64_t v108 = v114;
    }

    while (v111);
  }

  else
  {
    unsigned int v112 = 0;
    __int128 v115 = v108;
  }

  __int128 v230 = v108;
  unint64_t v126 = 126 - 2 * __clz(((char *)v115 - (char *)v108) >> 3);
  if (v115 == v108) {
    uint64_t v127 = 0LL;
  }
  else {
    uint64_t v127 = v126;
  }
  std::__introsort<std::_ClassicAlgPolicy,GRCInfo::MergeCounterData(NSArray *,NSArray*<NSArray*<NSString *>>,NSArray *,std::vector<std::unordered_map<unsigned int,GRCInfo::EncoderCounterInfo>> &,NSMutableDictionary<NSArray*,NSNumber *> *)::{lambda(GRCInfo::EncoderCounterInfo const&,GRCInfo::EncoderCounterInfo const&)#1} &,GRCInfo::EncoderCounterInfo*,false>( (unint64_t)v108,  v115,  v127,  1);
  uint64_t v128 = (int *)v230;
  if (v115 == v230)
  {
    uint64_t v142 = 0LL;
    unint64_t v143 = 0LL;
    unint64_t v129 = 0LL;
    uint64_t v141 = v112 + 1;
LABEL_128:
    uint64_t v144 = (v143 - v142) >> 3;
    unint64_t v145 = v144 + 1;
    uint64_t v146 = v142;
    unint64_t v147 = v129 - (void)v142;
    unint64_t v148 = (uint64_t)(v129 - (void)v142) >> 2;
    if (v148 > v145) {
      unint64_t v145 = v148;
    }
    if (v147 >= 0x7FFFFFFFFFFFFFF8LL) {
      unint64_t v149 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v149 = v145;
    }
    if (v149) {
      unint64_t v149 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<std::pair<unsigned int,unsigned int>>>(v149);
    }
    unint64_t v130 = (char *)(v149 + 8 * v144);
    *(void *)unint64_t v130 = v141;
    uint64_t v150 = v130;
    if (v143 != v146)
    {
      uint64_t v150 = v130;
      do
      {
        uint64_t v151 = *((void *)v143 - 1);
        v143 -= 8;
        *((void *)v150 - 1) = v151;
        v150 -= 8;
      }

      while (v143 != v146);
    }

    if (v146) {
      operator delete(v146);
    }
    __p = v150;
    goto LABEL_142;
  }

  __p = 0LL;
  unint64_t v129 = 0LL;
  unint64_t v130 = 0LL;
  int v131 = -1;
  do
  {
    if (v131 != *v128)
    {
      uint64_t v132 = v128[1];
      if ((unint64_t)v130 >= v129)
      {
        uint64_t v134 = (v130 - __p) >> 3;
        unint64_t v135 = v134 + 1;
        else {
          unint64_t v136 = v135;
        }
        if (v136) {
          unint64_t v136 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<std::pair<unsigned int,unsigned int>>>(v136);
        }
        else {
          uint64_t v137 = 0LL;
        }
        __int128 v138 = (char *)(v136 + 8 * v134);
        *(void *)__int128 v138 = v132;
        id v133 = v138 + 8;
        if (v130 == __p)
        {
          unint64_t v139 = __p;
        }

        else
        {
          unint64_t v139 = __p;
          do
          {
            uint64_t v140 = *((void *)v130 - 1);
            v130 -= 8;
            *((void *)v138 - 1) = v140;
            v138 -= 8;
          }

          while (v130 != __p);
        }

        unint64_t v129 = v136 + 8 * v137;
        if (v139) {
          operator delete(v139);
        }
        __p = v138;
      }

      else
      {
        *(void *)unint64_t v130 = v132;
        id v133 = v130 + 8;
      }

      int v131 = *v128;
      unint64_t v130 = v133;
    }

    v128 += 2;
  }

  while (v128 != (int *)v115);
  uint64_t v141 = v112 + 1;
  if ((unint64_t)v130 >= v129)
  {
    unint64_t v143 = v130;
    uint64_t v142 = __p;
    goto LABEL_128;
  }

  *(void *)unint64_t v130 = v141;
LABEL_142:
  unint64_t v152 = (unint64_t)[v260 count];
  __int128 v297 = 0LL;
  uint64_t v298 = 0LL;
  uint64_t v299 = 0LL;
  if (v152)
  {
    std::vector<GRCInfo::MergeCounterData(NSArray *,NSArray*<NSArray*<NSString *>>,NSArray *,std::vector<std::unordered_map<unsigned int,GRCInfo::EncoderCounterInfo>> &,NSMutableDictionary<NSArray*,NSNumber *> *)::CounterValueData,std::allocator<GRCInfo::MergeCounterData(NSArray *,NSArray*<NSArray*<NSString *>>,NSArray *,std::vector<std::unordered_map<unsigned int,GRCInfo::EncoderCounterInfo>> &,NSMutableDictionary<NSArray*,NSNumber *> *)::CounterValueData>>::__vallocate[abi:nn180100]( &v297,  v152);
    uint64_t v153 = v298;
    bzero(v298, 16 * v152);
    __int128 v154 = &v153[2 * v152];
    uint64_t v298 = v154;
  }

  else
  {
    __int128 v154 = 0LL;
  }

  uint64_t v311 = 0LL;
  uint64_t v312 = 0LL;
  id v313 = 0LL;
  uint64_t v155 = (void **)operator new(0x48uLL);
  uint64_t v156 = 0LL;
  unint64_t v224 = v130 + 8;
  uint64_t v311 = v155;
  uint64_t v312 = (uint64_t)v155;
  id v313 = v155 + 9;
  __srca = v297;
  size_t v157 = (char *)v154 - (char *)v297;
  unint64_t v158 = ((char *)v154 - (char *)v297) >> 4;
  do
  {
    unint64_t v159 = &v155[v156];
    void *v159 = 0LL;
    v159[1] = 0LL;
    v159[2] = 0LL;
    if (v154 != __srca)
    {
      std::vector<GRCInfo::MergeCounterData(NSArray *,NSArray*<NSArray*<NSString *>>,NSArray *,std::vector<std::unordered_map<unsigned int,GRCInfo::EncoderCounterInfo>> &,NSMutableDictionary<NSArray*,NSNumber *> *)::CounterValueData,std::allocator<GRCInfo::MergeCounterData(NSArray *,NSArray*<NSArray*<NSString *>>,NSArray *,std::vector<std::unordered_map<unsigned int,GRCInfo::EncoderCounterInfo>> &,NSMutableDictionary<NSArray*,NSNumber *> *)::CounterValueData>>::__vallocate[abi:nn180100]( &v155[v156],  v158);
      unint64_t v160 = (char *)v155[v156 + 1];
      memmove(v160, __srca, v157);
      v155[v156 + 1] = &v160[16 * v158];
    }

    v156 += 3LL;
  }

  while (v156 != 9);
  uint64_t v312 = (uint64_t)(v155 + 9);
  uint64_t v301 = 0LL;
  id v302 = 0LL;
  uint64_t v300 = 0LL;
  if (v141)
  {
    uint64_t v161 = operator new(24 * v141);
    uint64_t v300 = v161;
    uint64_t v301 = v161;
    v247 = &v161[3 * v141];
    id v302 = v247;
    do
    {
      *uint64_t v161 = 0LL;
      v161[1] = 0LL;
      v161[2] = 0LL;
      uint64_t v162 = v311;
      unint64_t v163 = (void **)v312;
      int64_t v164 = v312 - (void)v311;
      if ((void **)v312 != v311)
      {
        unint64_t v165 = 0xAAAAAAAAAAAAAAABLL * (v164 >> 3);
        if (v165 >= 0xAAAAAAAAAAAAAABLL) {
          abort();
        }
        uint64_t v166 = operator new(v164);
        *uint64_t v161 = v166;
        v161[1] = v166;
        v161[2] = &v166[3 * v165];
        unint64_t v167 = v166;
        do
        {
          *unint64_t v167 = 0LL;
          v167[1] = 0LL;
          void v167[2] = 0LL;
          id v169 = *v162;
          unint64_t v168 = v162[1];
          int64_t v170 = v168 - (_BYTE *)*v162;
          if (v168 != *v162)
          {
            std::vector<GRCInfo::MergeCounterData(NSArray *,NSArray*<NSArray*<NSString *>>,NSArray *,std::vector<std::unordered_map<unsigned int,GRCInfo::EncoderCounterInfo>> &,NSMutableDictionary<NSArray*,NSNumber *> *)::CounterValueData,std::allocator<GRCInfo::MergeCounterData(NSArray *,NSArray*<NSArray*<NSString *>>,NSArray *,std::vector<std::unordered_map<unsigned int,GRCInfo::EncoderCounterInfo>> &,NSMutableDictionary<NSArray*,NSNumber *> *)::CounterValueData>>::__vallocate[abi:nn180100]( v167,  v170 >> 4);
            uint64_t v171 = (char *)v167[1];
            memmove(v171, v169, v170);
            v167[1] = &v171[16 * (v170 >> 4)];
          }

          v167 += 3;
          v162 += 3;
        }

        while (v162 != v163);
        v161[1] = v167;
      }

      v161 += 3;
    }

    while (v161 != v247);
    uint64_t v301 = v247;
  }

  v304 = &v311;
  std::vector<std::vector<DYMTLEncoderInfo>>::__destroy_vector::operator()[abi:nn180100]((void ***)&v304);
  if (__srca) {
    operator delete(__srca);
  }
  id v172 = [v246 count];
  if (v172)
  {
    unint64_t v173 = 0LL;
    id v236 = v172;
    do
    {
      unint64_t v174 = (void *)objc_claimAutoreleasedReturnValue([v246 objectAtIndexedSubscript:v173]);
      id v175 = [v174 count];
      bzero(&v311, 0x800uLL);
      if (v175)
      {
        for (iuint64_t i = 0LL; ii != v175; iuint64_t i = (char *)ii + 1)
        {
          uint64_t v177 = (void *)objc_claimAutoreleasedReturnValue([v174 objectAtIndexedSubscript:ii]);
          (&v311)[(void)ii] = (void **)[v260 indexOfObject:v177];
        }
      }

      uint64_t v178 = (void *)objc_claimAutoreleasedReturnValue([v238 objectAtIndexedSubscript:v173]);
      uint64_t v179 = (void *)objc_claimAutoreleasedReturnValue([v178 firstObject]);

      id v180 = v179;
      id v243 = v174;
      unint64_t v181 = (char *)[v180 bytes];
      unint64_t v182 = 0LL;
      __int128 v183 = 0LL;
LABEL_168:
      uint64_t v184 = v182;
      while (1)
      {
        int NextMarker = GRCInfo::FindNextMarker((GRCInfo *)v180, v183, *((void *)v264 + 10));
        int v186 = NextMarker;
        if (NextMarker == -1) {
          break;
        }
        unint64_t v182 = &v181[8 * NextMarker];
        uint64_t v187 = std::__hash_table<std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>>>::find<unsigned int>( (void *)(*(void *)(v257 + 48) + 40LL * (void)v173),  *((_DWORD *)v182 + 8));
        __int128 v183 = (NSData *)(v186 + 8);
        if (v187)
        {
          unint64_t v188 = *((void *)v182 + 3);
          if (v188 <= 5 && (*((void *)v182 + 3) & 1LL) != 0)
          {
            unint64_t v190 = v184 ? v184 : &v181[8 * v186];
            uint64_t v191 = *((unsigned int *)v187 + 6);
            unint64_t v192 = 125LL * (*((void *)v182 + 1) - *((void *)v190 + 1));
            unint64_t v193 = v188 >> 1;
            uint64_t v194 = *(void *)(v300[3 * v191] + 24 * (v188 >> 1));
            *(void *)uint64_t v194 = *((unsigned int *)v187 + 5);
            unint64_t v195 = *((void *)v182 + 2);
            *(void *)(v194 + 8) += v195;
            *(void *)(v194 + 16) = v191;
            unsigned int __srcb = v191;
            uint64_t v196 = *(void *)(v194 + 40);
            unint64_t v197 = *(void *)(v194 + 48) + v192 / 3;
            *(void *)(v194 + 24) += v195;
            *(void *)(v194 + 32) = 0LL;
            *(void *)(v194 + 40) = v196 + v195;
            *(void *)(v194 + 4_Block_object_dispose(va, 8) = v197;
            *(void *)(v194 + 56) += v195;
            *(void *)(v194 + 64) = v193;
            *(void *)(v194 + 72) += v195;
            *(void *)(v194 + 80) = 1LL;
            *(int64x2_t *)(v194 + 8_Block_object_dispose(va, 8) = vaddq_s64(*(int64x2_t *)(v194 + 88), vdupq_n_s64(v195));
            *(void *)(v194 + 104) += v195;
            if (*((void *)&v255->var0 + (void)v173))
            {
              unint64_t v198 = v193;
              unint64_t v199 = 0LL;
              uint64_t v248 = v190 + 64;
              uint64_t v200 = (uint64_t)&v181[8 * v186 + 64];
              do
              {
                unsigned int v201 = [&off_59F8F0 count];
                uint64_t v202 = *(void *)(v200 + 8 * v199);
                unint64_t v203 = (unint64_t)(&(&v311)[v199])[v201];
                char v204 = (void *)(*(void *)(v300[3 * __srcb] + 24 * v198) + 16 * v203);
                uint64_t v205 = v204[1];
                *v204 += v202;
                v204[1] = v205 + *((void *)v182 + 2);
                ++v199;
              }

              while (v199 < *((void *)&v255->var0 + (void)v173));
            }
          }

          goto LABEL_168;
        }
      }

      unint64_t v173 = (char *)v173 + 1;
    }

    while (v173 != v236);
  }

  id v237 = (void *)objc_claimAutoreleasedReturnValue( +[NSMutableArray arrayWithCapacity:]( &OBJC_CLASS___NSMutableArray,  "arrayWithCapacity:",  0xAAAAAAAAAAAAAAABLL * (v301 - v300)));
  if ((unint64_t)(v224 - __p) >= 9)
  {
    uint64_t v207 = 0LL;
    uint64_t v208 = 1LL;
    do
    {
      int v209 = *(void **)&__p[8 * v207];
      uint64_t v244 = v208;
      __int128 v210 = *(void **)&__p[8 * v208];
      int v249 = (void *)objc_opt_new(&OBJC_CLASS___NSMutableArray, v206);
      uint64_t v258 = v209;
      __srcc = v210;
      if (v209 < v210)
      {
        do
        {
          int v211 = v300;
          v265 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableArray arrayWithCapacity:](&OBJC_CLASS___NSMutableArray, "arrayWithCapacity:", 3LL));
          __int128 v212 = &v211[3 * (void)v258];
          __int128 v213 = (void *)*v212;
          __int128 v214 = (void *)v212[1];
          while (v213 != v214)
          {
            if (*(void *)(*v213 + 96LL))
            {
              __int128 v215 = (void *)objc_claimAutoreleasedReturnValue( +[NSMutableArray arrayWithCapacity:]( NSMutableArray,  "arrayWithCapacity:",  [v260 count]));
              __int128 v217 = (void *)*v213;
              __int128 v216 = (void *)v213[1];
              while (v217 != v216)
              {
                __int128 v218 = (void **)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  *v217));
                uint64_t v311 = v218;
                unint64_t v219 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  v217[1]));
                uint64_t v312 = (uint64_t)v219;
                __int128 v220 = (void *)objc_claimAutoreleasedReturnValue( +[NSArray arrayWithObjects:count:]( &OBJC_CLASS___NSArray,  "arrayWithObjects:count:",  &v311,  2LL));
                [v215 addObject:v220];

                v217 += 2;
              }

              [v265 addObject:v215];
            }

            v213 += 3;
          }

          if ([v265 count]) {
            [v249 addObject:v265];
          }

          uint64_t v258 = (char *)v258 + 1;
        }

        while (v258 != __srcc);
      }

      if ([v249 count]) {
        [v237 addObject:v249];
      }

      uint64_t v207 = v244;
      uint64_t v208 = v244 + 1;
    }

    while (v244 + 1 < (unint64_t)((v224 - __p) >> 3));
  }

  __int128 v297 = (void **)&v300;
  std::vector<std::vector<std::vector<GRCInfo::MergeCounterData(NSArray *,NSArray*<NSArray*<NSString *>>,NSArray *,std::vector<std::unordered_map<unsigned int,GRCInfo::EncoderCounterInfo>> &,NSMutableDictionary<NSArray*,NSNumber *> *)::CounterValueData,std::allocator<GRCInfo::MergeCounterData(NSArray *,NSArray*<NSArray*<NSString *>>,NSArray *,std::vector<std::unordered_map<unsigned int,GRCInfo::EncoderCounterInfo>> &,NSMutableDictionary<NSArray*,NSNumber *> *)::CounterValueData>>>>::__destroy_vector::operator()[abi:nn180100](&v297);
  if (__p) {
    operator delete(__p);
  }
  if (v230) {
    operator delete(v230);
  }
  if (v255) {
    operator delete(v255);
  }
  if (v303) {
    operator delete(v303);
  }

  if (v237) {
    [v233 setObject:v237 forKeyedSubscript:@"AverageSamples"];
  }

  _Block_object_dispose(&v282, 8);
  uint64_t v311 = (void **)&v285;
  std::vector<std::unordered_map<unsigned int,GTEncoderSampleIndexInfo>>::__destroy_vector::operator()[abi:nn180100](&v311);

  _Block_object_dispose(&v287, 8);
  GRCInfo::~GRCInfo(v293);

LABEL_213:
  GTAGXPerfStateControl::~GTAGXPerfStateControl((id *)v235);
  operator delete(v221);

  return v233;
}

void sub_9F4E4( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *a16, uint64_t a17, id *a18, uint64_t a19, void *a20, void *a21, void *a22, uint64_t a23, void *a24, void *a25, void *a26, void *a27, void *a28, void *a29, id *a30, uint64_t a31, uint64_t a32, void *a33, void *a34, uint64_t a35, void *a36, uint64_t a37, uint64_t a38, void *a39, uint64_t a40, uint64_t a41, void *__p, void *a43, _Unwind_Exception *exception_objecta, uint64_t a45, uint64_t a46, void *a47, uint64_t a48, uint64_t a49, uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  _Block_object_dispose(&a67, 8);
  *(void *)(v68 + 264) = a17;
  std::vector<std::unordered_map<unsigned int,GTEncoderSampleIndexInfo>>::__destroy_vector::operator()[abi:nn180100]((void ***)&STACK[0x2D8]);

  _Block_object_dispose(&STACK[0x218], 8);
  GRCInfo::~GRCInfo(a18);

  GTAGXPerfStateControl::~GTAGXPerfStateControl(a30);
  operator delete(v69);

  _Unwind_Resume(a1);
}

void ___ZL31CollectDerivedCounterDataLegacyP21GTMTLReplayControllerP26GTMTLReplayOperationQueuesP12NSDictionaryP21GTAGXPerfStateControl_block_invoke( uint64_t a1)
{
  uint64_t v2 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) objectForKeyedSubscript:@"profileCounters"]);
  uint64_t v3 = *(void *)(a1 + 56);
  id v4 = *(void **)(a1 + 40);
  uint64_t v5 = *(void **)(*(void *)(*(void *)(a1 + 48) + 8LL) + 40LL);
  __int128 v25 = *(_OWORD *)(a1 + 64);
  id v6 = v2;
  id v24 = v5;
  v36[0] = @"MTLStatCommandBufferIndex";
  v36[1] = @"MTLStatEncoderIndex";
  v36[2] = @"MTLStatCommandIndex";
  v36[3] = @"MTLStat_nSec";
  void v36[4] = @"MTLStatDataMaster";
  void v36[5] = @"MTLStatSampleLocation";
  v36[6] = @"MTLStatTotalGPUCycles";
  id v22 = v6;
  unint64_t v7 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", v36, 7LL));
  uint8x8_t v8 = (void *)objc_claimAutoreleasedReturnValue(+[NSSet setWithArray:](&OBJC_CLASS___NSSet, "setWithArray:", v7));
  double v9 = (void *)objc_claimAutoreleasedReturnValue( +[NSMutableArray arrayWithCapacity:]( NSMutableArray,  "arrayWithCapacity:",  (char *)[v7 count] + (void)objc_msgSend(v22, "count")));
  uint64_t v23 = v4;
  [v9 addObjectsFromArray:v7];
  __int128 v28 = 0u;
  __int128 v29 = 0u;
  __int128 v26 = 0u;
  __int128 v27 = 0u;
  id v10 = v22;
  id v11 = [v10 countByEnumeratingWithState:&v26 objects:v30 count:16];
  if (v11)
  {
    uint64_t v12 = *(void *)v27;
    do
    {
      for (uint64_t i = 0LL; i != v11; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v27 != v12) {
          objc_enumerationMutation(v10);
        }
        uint64_t v14 = *(void *)(*((void *)&v26 + 1) + 8LL * (void)i);
      }

      id v11 = [v10 countByEnumeratingWithState:&v26 objects:v30 count:16];
    }

    while (v11);
  }

  uint64_t v16 = (void *)objc_opt_new(&OBJC_CLASS___NSOperation, v15);
  v30[0] = _NSConcreteStackBlock;
  v30[1] = 3221225472LL;
  v30[2] = ___ZL18DerivedCounterDataP21GTMTLReplayControllerP26GTMTLReplayOperationQueuesP7NSArrayP19NSMutableDictionaryjP21GTAGXPerfStateControl_block_invoke;
  v30[3] = &unk_58E0A8;
  uint64_t v34 = v3;
  id v17 = v9;
  id v31 = v17;
  id v18 = v24;
  id v32 = v18;
  __int128 v35 = v25;
  id v19 = v16;
  id v33 = v19;
  unint64_t v20 = (void *)objc_claimAutoreleasedReturnValue( +[NSBlockOperation blockOperationWithBlock:]( &OBJC_CLASS___NSBlockOperation,  "blockOperationWithBlock:",  v30));
  [v20 setQueuePriority:-8];
  [*(id *)v25 addOperation:v20];
  id v21 = v19;

  [v23 addDependency:v21];
  [*(id *)(*(void *)(a1 + 64) + 8) addOperation:*(void *)(a1 + 40)];
}

void sub_9FE4C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
}

id __Block_byref_object_copy__188(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)(a1 + 4_Block_object_dispose(va, 8) = *(_OWORD *)(a2 + 48);
  *(void *)(a1 + 64) = *(id *)(a2 + 64);
  id v4 = *(id *)(a2 + 72);
  uint64_t v5 = *(void *)(a2 + 80);
  id v6 = *(void **)(a2 + 88);
  *(void *)(a1 + 72) = v4;
  *(void *)(a1 + 80) = v5;
  *(void *)(a1 + 8_Block_object_dispose(va, 8) = v6;
  *(void *)(a1 + 96) = *(id *)(a2 + 96);
  id result = *(id *)(a2 + 104);
  *(void *)(a1 + 104) = result;
  *(void *)(a1 + 112) = *(void *)(a2 + 112);
  return result;
}

void __Block_byref_object_dispose__189(uint64_t a1)
{
}

__n128 __Block_byref_object_copy__193(__n128 *a1, __n128 *a2)
{
  a1[3].n128_u64[0] = 0LL;
  a1[3].n128_u64[1] = 0LL;
  a1[4].n128_u64[0] = 0LL;
  __n128 result = a2[3];
  a1[3] = result;
  a1[4].n128_u64[0] = a2[4].n128_u64[0];
  a2[3].n128_u64[0] = 0LL;
  a2[3].n128_u64[1] = 0LL;
  a2[4].n128_u64[0] = 0LL;
  return result;
}

void __Block_byref_object_dispose__194(uint64_t a1)
{
  uint64_t v1 = (void **)(a1 + 48);
  std::vector<std::unordered_map<unsigned int,GTEncoderSampleIndexInfo>>::__destroy_vector::operator()[abi:nn180100](&v1);
}

void ___ZL28CollectDerivedCounterDataGRCP21GTMTLReplayControllerP26GTMTLReplayOperationQueuesP12NSDictionaryP21GTAGXPerfStateControl_block_invoke( uint64_t a1)
{
  uint64_t v2 = *(void *)(*(void *)(a1 + 48) + 8LL);
  uint64_t v3 = *(unsigned int *)(a1 + 64);
  uint64_t v4 = *(unsigned int *)(a1 + 68);
  id v5 = *(id *)(a1 + 32);
  id v6 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v2 + 64) firstObject]);
  if (v6)
  {
    if (!(_DWORD)v4)
    {
      if (IsGPUPerformanceStateInduced(*(void **)(*(void *)(v2 + 48) + 8LL)))
      {
        unint64_t v7 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v2 + 64) firstObject]);
        [v7 setOptions:&off_59FFC0];
      }

      else
      {
        uint64_t v8 = *(unsigned int *)(v2 + 112);
        if ((_DWORD)v8)
        {
          GTAGXPerfStateControl::EnableConsistentGPUPerfState(*(void *)(v2 + 56), v8);
        }

        else
        {
          v39[0] = @"DisableOverlap";
          v39[1] = @"LockGPUPerfState";
          v40[0] = &__kCFBooleanTrue;
          double v9 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInt:](&OBJC_CLASS___NSNumber, "numberWithUnsignedInt:", v3));
          v40[1] = v9;
          id v10 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v40,  v39,  2LL));
          id v11 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v2 + 64) firstObject]);
          [v11 setOptions:v10];
        }
      }
    }

    uint64_t v12 = (void *)objc_claimAutoreleasedReturnValue([v5 objectForKeyedSubscript:@"passList"]);
    float v13 = (void *)objc_claimAutoreleasedReturnValue([v12 objectAtIndexedSubscript:v4]);

    if (v13)
    {
      for (unint64_t i = 0; i < (unint64_t)[*(id *)(v2 + 72) count]; ++i)
      {
        uint64_t v15 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v2 + 72) objectAtIndexedSubscript:i]);
        uint64_t v16 = v15;
        if (!(_DWORD)v4)
        {
          [v15 setOptions:0];
          if (([v16 requestTriggers:*(void *)(v2 + 88) firstErrorIndex:0] & 1) == 0)
          {
            uint64_t v17 = *(void *)(v2 + 88);
            id v18 = (void *)objc_claimAutoreleasedReturnValue([v16 name]);
            NSLog(@"Failed to set %@ Trigger for %@", v17, v18);
          }
        }

        id v19 = (void *)objc_claimAutoreleasedReturnValue([v13 objectAtIndexedSubscript:i]);
        if (![v19 count])
        {
          id v20 = *(id *)(v2 + 96);

          id v19 = v20;
        }

        if (([v16 requestCounters:v19 firstErrorIndex:&v38] & 1) == 0)
        {
          uint64_t v37 = v38;
          id v36 = [v19 count];
          unint64_t v30 = v38;
          id v31 = [v19 count];
          if (v30 >= (unint64_t)v31)
          {
            id v32 = &stru_591D98;
          }

          else
          {
            __int128 v35 = (void *)objc_claimAutoreleasedReturnValue([v19 objectAtIndexedSubscript:v38]);
            id v32 = (__CFString *)objc_claimAutoreleasedReturnValue([v35 name]);
          }

          uint64_t v34 = (void *)objc_claimAutoreleasedReturnValue([v16 name]);
          NSLog( @"Fail, error while requesting counter[%u/%lu] (%@) for source[%@] in pass[%u]",  v37,  v36,  v32,  v34,  v4);

          if (v30 < (unint64_t)v31)
          {
          }

          NSLog(@"%@\n", v19);
          goto LABEL_32;
        }

        if (([v16 setEnabled:1] & 1) == 0)
        {
          id v33 = (void *)objc_claimAutoreleasedReturnValue([v16 name]);
          NSLog(@"Fail, error while enabling source[%@] in pass[%u]", v33, v4);

LABEL_32:
          goto LABEL_33;
        }
      }

      id v21 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(*(void *)(*(void *)(a1 + 48) + 8) + 64) firstObject]);
      unsigned __int8 v22 = [v21 startSampling];

      if ((v22 & 1) != 0)
      {
        GRCInfo::ReplayForKickCounters( (GTMTLReplayController **)(*(void *)(*(void *)(a1 + 48) + 8LL) + 48LL),  (uint64_t *)(*(void *)(*(void *)(*(void *)(a1 + 56) + 8LL) + 48LL) + 40LL * *(unsigned int *)(a1 + 68)));
        uint64_t v23 = objc_autoreleasePoolPush();
        id v24 = (id *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 48LL);
        id v25 = GRCInfo::DrainRawFrameData(v24);
        __int128 v26 = (void *)objc_claimAutoreleasedReturnValue(v25);
        id v27 = GRCInfo::PostProcessFrameData((uint64_t)v24, v26);
        __int128 v28 = (void *)objc_claimAutoreleasedReturnValue(v27);

        if (v28) {
          [*(id *)(a1 + 40) addObject:v28];
        }

        objc_autoreleasePoolPop(v23);
        [v29 stopSampling];

        if (*(_DWORD *)(a1 + 68) + 1 == *(_DWORD *)(a1 + 72))
        {
          GRCInfo::AddConsistencyInfo((GTAGXPerfStateControl **)(*(void *)(*(void *)(a1 + 48) + 8LL) + 48LL));
          GTAGXPerfStateControl::DisableConsistentGPUPerfState(*(GTAGXPerfStateControl **)(*(void *)(*(void *)(a1 + 48) + 8LL)
                                                                                         + 56LL));
        }
      }
    }

    else
    {
LABEL_33:
    }
  }

  else
  {
  }

void sub_A0474(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

unint64_t std::__introsort<std::_ClassicAlgPolicy,GRCInfo::MergeCounterData(NSArray *,NSArray*<NSArray*<NSString *>>,NSArray *,std::vector<std::unordered_map<unsigned int,GRCInfo::EncoderCounterInfo>> &,NSMutableDictionary<NSArray*,NSNumber *> *)::{lambda(GRCInfo::EncoderCounterInfo const&,GRCInfo::EncoderCounterInfo const&)#1} &,GRCInfo::EncoderCounterInfo*,false>( unint64_t result, unsigned int *a2, uint64_t a3, char a4)
{
  unint64_t v7 = (unsigned int *)result;
LABEL_2:
  uint64_t v8 = a2 - 2;
  double v9 = v7;
  while (2)
  {
    unint64_t v7 = v9;
    uint64_t v10 = (char *)a2 - (char *)v9;
    unint64_t v11 = ((char *)a2 - (char *)v9) >> 3;
    switch(v11)
    {
      case 0uLL:
      case 1uLL:
        return result;
      case 2uLL:
        unsigned int v69 = *(a2 - 2);
        BOOL v73 = v69 == *v9;
        BOOL v70 = v69 < *v9;
        if (v73) {
          BOOL v70 = *(a2 - 1) < v9[1];
        }
        if (v70)
        {
          int32x2_t v71 = *(int32x2_t *)v9;
          *(void *)double v9 = *(void *)v8;
          *(int32x2_t *)uint64_t v8 = v71;
        }

        return result;
      case 3uLL:
        return (unint64_t)std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,GRCInfo::MergeCounterData(NSArray *,NSArray*<NSArray*<NSString *>>,NSArray *,std::vector<std::unordered_map<unsigned int,GRCInfo::EncoderCounterInfo>> &,NSMutableDictionary<NSArray*,NSNumber *> *)::{lambda(GRCInfo::EncoderCounterInfo const&,GRCInfo::EncoderCounterInfo const&)#1} &,GRCInfo::EncoderCounterInfo*>( v9,  v9 + 2,  a2 - 2);
      case 4uLL:
        return (unint64_t)std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,GRCInfo::MergeCounterData(NSArray *,NSArray*<NSArray*<NSString *>>,NSArray *,std::vector<std::unordered_map<unsigned int,GRCInfo::EncoderCounterInfo>> &,NSMutableDictionary<NSArray*,NSNumber *> *)::{lambda(GRCInfo::EncoderCounterInfo const&,GRCInfo::EncoderCounterInfo const&)#1} &,GRCInfo::EncoderCounterInfo*>( v9,  v9 + 2,  v9 + 4,  a2 - 2);
      case 5uLL:
        return (unint64_t)std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,GRCInfo::MergeCounterData(NSArray *,NSArray*<NSArray*<NSString *>>,NSArray *,std::vector<std::unordered_map<unsigned int,GRCInfo::EncoderCounterInfo>> &,NSMutableDictionary<NSArray*,NSNumber *> *)::{lambda(GRCInfo::EncoderCounterInfo const&,GRCInfo::EncoderCounterInfo const&)#1} &,GRCInfo::EncoderCounterInfo*>( v9,  v9 + 2,  v9 + 4,  v9 + 6,  a2 - 2);
      default:
        if (v10 <= 191)
        {
          uint64_t v72 = v9 + 2;
          BOOL v73 = v9 == a2 || v72 == a2;
          char v74 = v73;
          if ((a4 & 1) != 0)
          {
            if ((v74 & 1) == 0)
            {
              uint64_t v75 = 0LL;
              id v76 = v9;
              do
              {
                unsigned int v77 = v76[2];
                unsigned int v78 = v76[3];
                unsigned int v79 = *v76;
                unsigned int v80 = v76[1];
                id v76 = v72;
                BOOL v81 = v78 < v80;
                BOOL v73 = v77 == v79;
                BOOL v82 = v77 < v79;
                if (!v73) {
                  BOOL v81 = v82;
                }
                if (v81)
                {
                  uint64_t v83 = *(void *)v76;
                  uint64_t v84 = HIDWORD(*(void *)v76);
                  uint64_t v85 = v75;
                  while (1)
                  {
                    uint64_t v86 = (char *)v9 + v85;
                    *(void *)((char *)v9 + v85 + _Block_object_dispose(va, 8) = *(void *)((char *)v9 + v85);
                    if (!v85) {
                      break;
                    }
                    unsigned int v87 = *((_DWORD *)v86 - 2);
                    BOOL v88 = *((_DWORD *)v86 - 1) > v84;
                    BOOL v73 = v87 == (_DWORD)v83;
                    BOOL v89 = v87 > v83;
                    if (!v73) {
                      BOOL v88 = v89;
                    }
                    v85 -= 8LL;
                    if (!v88)
                    {
                      uint64_t v90 = (unsigned int *)((char *)v9 + v85 + 8);
                      goto LABEL_103;
                    }
                  }

                  uint64_t v90 = v9;
LABEL_103:
                  *(void *)uint64_t v90 = v83;
                }

                uint64_t v72 = v76 + 2;
                v75 += 8LL;
              }

              while (v76 + 2 != a2);
            }
          }

          else if ((v74 & 1) == 0)
          {
            do
            {
              unsigned int v134 = v7[2];
              unsigned int v135 = v7[3];
              unsigned int v136 = *v7;
              unsigned int v137 = v7[1];
              unint64_t v7 = v72;
              BOOL v138 = v135 < v137;
              BOOL v73 = v134 == v136;
              BOOL v139 = v134 < v136;
              if (v73) {
                BOOL v139 = v138;
              }
              if (v139)
              {
                uint64_t v140 = *(void *)v72;
                uint64_t v141 = HIDWORD(*(void *)v72);
                do
                {
                  uint64_t v142 = v72;
                  uint64_t v143 = *((void *)v72 - 1);
                  v72 -= 2;
                  *(void *)uint64_t v142 = v143;
                  unsigned int v144 = *(v142 - 4);
                  BOOL v145 = *(v142 - 3) > v141;
                  BOOL v73 = v144 == (_DWORD)v140;
                  BOOL v146 = v144 > v140;
                  if (!v73) {
                    BOOL v145 = v146;
                  }
                }

                while (v145);
                *(void *)uint64_t v72 = v140;
              }

              uint64_t v72 = v7 + 2;
            }

            while (v7 + 2 != a2);
          }

          return result;
        }

        if (!a3)
        {
          if (v9 != a2)
          {
            int64_t v91 = (v11 - 2) >> 1;
            int64_t v92 = v91;
            do
            {
              int64_t v93 = v92;
              if (v91 >= v92)
              {
                uint64_t v94 = (2 * v92) | 1;
                uint64_t v95 = (uint32x2_t *)&v9[2 * v94];
                if (2 * v93 + 2 >= (uint64_t)v11)
                {
                  unsigned __int32 v98 = v95->i32[0];
                }

                else
                {
                  uint32x2_t v96 = v95[1];
                  uint32x2_t v97 = vcgt_u32(v96, *v95);
                  unsigned __int32 v98 = (unsigned __int32)*v95;
                  __int8 v99 = v97.i8[4];
                  if (v98 != v96.i32[0]) {
                    __int8 v99 = v97.i8[0];
                  }
                  if ((v99 & 1) != 0)
                  {
                    unsigned __int32 v98 = (unsigned __int32)v95[1];
                    ++v95;
                    uint64_t v94 = 2 * v93 + 2;
                  }
                }

                uint64_t v100 = (uint32x2_t *)&v9[2 * v93];
                __n128 result = v100->u32[1];
                BOOL v73 = v98 == v100->i32[0];
                BOOL v101 = v98 < v100->i32[0];
                if (v73) {
                  BOOL v101 = v95->i32[1] < result;
                }
                if (!v101)
                {
                  uint32x2_t v102 = *v100;
                  unint64_t v103 = HIDWORD(*(unint64_t *)v100);
                  do
                  {
                    unint64_t v104 = v100;
                    uint64_t v100 = v95;
                    *unint64_t v104 = *v95;
                    if (v91 < v94) {
                      break;
                    }
                    uint64_t v105 = (2 * v94) | 1;
                    uint64_t v95 = (uint32x2_t *)&v9[2 * v105];
                    uint64_t v94 = 2 * v94 + 2;
                    if (v94 >= (uint64_t)v11)
                    {
                      unsigned int v108 = v95->i32[0];
                      uint64_t v94 = v105;
                    }

                    else
                    {
                      uint32x2_t v106 = v95[1];
                      uint32x2_t v107 = vcgt_u32(v106, *v95);
                      unsigned int v108 = *v95;
                      __int8 v109 = v107.i8[4];
                      if (v108 != v106.i32[0]) {
                        __int8 v109 = v107.i8[0];
                      }
                      if ((v109 & 1) != 0)
                      {
                        unsigned int v108 = v95[1];
                        ++v95;
                      }

                      else
                      {
                        uint64_t v94 = v105;
                      }
                    }

                    BOOL v110 = v95->i32[1] < v103;
                    BOOL v73 = v108 == v102.i32[0];
                    __n128 result = v108 < v102.i32[0];
                    if (!v73) {
                      BOOL v110 = result;
                    }
                  }

                  while (!v110);
                  uint32x2_t *v100 = v102;
                }
              }

              int64_t v92 = v93 - 1;
            }

            while (v93);
            uint64_t v111 = (unint64_t)v10 >> 3;
            do
            {
              uint64_t v112 = 0LL;
              int32x2_t v113 = *(int32x2_t *)v9;
              uint64_t v114 = v111 - 2;
              if (v111 < 2) {
                uint64_t v114 = v111 - 1;
              }
              uint64_t v115 = v114 >> 1;
              unint64_t v116 = (int32x2_t *)v9;
              do
              {
                uint64_t v117 = &v116[v112 + 1];
                uint64_t v118 = (2 * v112) | 1;
                uint64_t v119 = 2 * v112 + 2;
                if (v119 < v111)
                {
                  int32x2_t v120 = v117[1];
                  unsigned __int8 v121 = vceq_s32(*v117, v120).u8[0];
                  uint32x2_t v122 = vcgt_u32((uint32x2_t)v120, (uint32x2_t)*v117);
                  __n128 result = v122.u32[1];
                  __int8 v123 = (v121 & 1) != 0 ? v122.i8[4] : v122.i8[0];
                  if ((v123 & 1) != 0)
                  {
                    ++v117;
                    uint64_t v118 = v119;
                  }
                }

                *unint64_t v116 = *v117;
                unint64_t v116 = v117;
                uint64_t v112 = v118;
              }

              while (v118 <= v115);
              a2 -= 2;
              if (v117 == (int32x2_t *)a2)
              {
                *uint64_t v117 = v113;
              }

              else
              {
                *uint64_t v117 = *(int32x2_t *)a2;
                *(int32x2_t *)a2 = v113;
                uint64_t v124 = (char *)v117 - (char *)v9 + 8;
                if (v124 >= 9)
                {
                  unint64_t v125 = (unint64_t)((v124 >> 3) - 2) >> 1;
                  unint64_t v126 = (uint32x2_t *)&v9[2 * v125];
                  int32x2_t v127 = *v117;
                  uint32x2_t v128 = vcgt_u32((uint32x2_t)*v117, *v126);
                  __int8 v129 = (vceq_s32((int32x2_t)*v126, *v117).u8[0] & 1) != 0 ? v128.i8[4] : v128.i8[0];
                  if ((v129 & 1) != 0)
                  {
                    do
                    {
                      unint64_t v130 = v117;
                      uint64_t v117 = (int32x2_t *)v126;
                      void *v130 = *v126;
                      if (!v125) {
                        break;
                      }
                      unint64_t v125 = (v125 - 1) >> 1;
                      unint64_t v126 = (uint32x2_t *)&v9[2 * v125];
                      uint32x2_t v131 = vcgt_u32((uint32x2_t)v127, *v126);
                      __int8 v132 = (vceq_s32((int32x2_t)*v126, v127).u8[0] & 1) != 0 ? v131.i8[4] : v131.i8[0];
                    }

                    while ((v132 & 1) != 0);
                    *uint64_t v117 = v127;
                  }
                }
              }
            }

            while (v111-- > 2);
          }

          return result;
        }

        unint64_t v12 = v11 >> 1;
        float v13 = &v9[2 * (v11 >> 1)];
        if ((unint64_t)v10 < 0x401)
        {
          __n128 result = (unint64_t)std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,GRCInfo::MergeCounterData(NSArray *,NSArray*<NSArray*<NSString *>>,NSArray *,std::vector<std::unordered_map<unsigned int,GRCInfo::EncoderCounterInfo>> &,NSMutableDictionary<NSArray*,NSNumber *> *)::{lambda(GRCInfo::EncoderCounterInfo const&,GRCInfo::EncoderCounterInfo const&)#1} &,GRCInfo::EncoderCounterInfo*>( &v7[2 * (v11 >> 1)],  v7,  a2 - 2);
        }

        else
        {
          std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,GRCInfo::MergeCounterData(NSArray *,NSArray*<NSArray*<NSString *>>,NSArray *,std::vector<std::unordered_map<unsigned int,GRCInfo::EncoderCounterInfo>> &,NSMutableDictionary<NSArray*,NSNumber *> *)::{lambda(GRCInfo::EncoderCounterInfo const&,GRCInfo::EncoderCounterInfo const&)#1} &,GRCInfo::EncoderCounterInfo*>( v7,  &v7[2 * (v11 >> 1)],  a2 - 2);
          std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,GRCInfo::MergeCounterData(NSArray *,NSArray*<NSArray*<NSString *>>,NSArray *,std::vector<std::unordered_map<unsigned int,GRCInfo::EncoderCounterInfo>> &,NSMutableDictionary<NSArray*,NSNumber *> *)::{lambda(GRCInfo::EncoderCounterInfo const&,GRCInfo::EncoderCounterInfo const&)#1} &,GRCInfo::EncoderCounterInfo*>( v7 + 2,  v13 - 2,  a2 - 4);
          std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,GRCInfo::MergeCounterData(NSArray *,NSArray*<NSArray*<NSString *>>,NSArray *,std::vector<std::unordered_map<unsigned int,GRCInfo::EncoderCounterInfo>> &,NSMutableDictionary<NSArray*,NSNumber *> *)::{lambda(GRCInfo::EncoderCounterInfo const&,GRCInfo::EncoderCounterInfo const&)#1} &,GRCInfo::EncoderCounterInfo*>( v7 + 4,  &v7[2 * v12 + 2],  a2 - 6);
          __n128 result = (unint64_t)std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,GRCInfo::MergeCounterData(NSArray *,NSArray*<NSArray*<NSString *>>,NSArray *,std::vector<std::unordered_map<unsigned int,GRCInfo::EncoderCounterInfo>> &,NSMutableDictionary<NSArray*,NSNumber *> *)::{lambda(GRCInfo::EncoderCounterInfo const&,GRCInfo::EncoderCounterInfo const&)#1} &,GRCInfo::EncoderCounterInfo*>( v13 - 2,  v13,  &v7[2 * v12 + 2]);
          uint64_t v14 = *(void *)v7;
          *(void *)unint64_t v7 = *(void *)v13;
          *(void *)float v13 = v14;
        }

        --a3;
        if ((a4 & 1) == 0)
        {
          unsigned int v15 = *(v7 - 2);
          BOOL v73 = v15 == *v7;
          BOOL v16 = v15 < *v7;
          if (v73) {
            BOOL v16 = *(v7 - 1) < v7[1];
          }
          if (!v16)
          {
            uint64_t v42 = *(void *)v7;
            uint64_t v43 = HIDWORD(*(void *)v7);
            unsigned int v44 = *(a2 - 2);
            BOOL v73 = v44 == *(void *)v7;
            BOOL v45 = v44 > *(void *)v7;
            if (v73) {
              BOOL v45 = *(a2 - 1) > v43;
            }
            if (v45)
            {
              double v9 = v7;
              do
              {
                unsigned int v46 = v9[2];
                unsigned int v47 = v9[3];
                v9 += 2;
                BOOL v48 = v47 > v43;
                BOOL v73 = v46 == (_DWORD)v42;
                BOOL v49 = v46 > v42;
                if (v73) {
                  BOOL v49 = v48;
                }
              }

              while (!v49);
            }

            else
            {
              unint64_t v50 = v7 + 2;
              do
              {
                double v9 = v50;
                if (v50 >= a2) {
                  break;
                }
                unsigned int v51 = *v50;
                BOOL v52 = v9[1] > v43;
                BOOL v73 = v51 == (_DWORD)v42;
                BOOL v53 = v51 > v42;
                if (!v73) {
                  BOOL v52 = v53;
                }
                unint64_t v50 = v9 + 2;
              }

              while (!v52);
            }

            id v54 = a2;
            if (v9 < a2)
            {
              id v54 = a2;
              do
              {
                unsigned int v55 = *(v54 - 2);
                unsigned int v56 = *(v54 - 1);
                v54 -= 2;
                BOOL v57 = v56 > v43;
                BOOL v73 = v55 == (_DWORD)v42;
                BOOL v58 = v55 > v42;
                if (v73) {
                  BOOL v58 = v57;
                }
              }

              while (v58);
            }

            while (v9 < v54)
            {
              int32x2_t v59 = *(int32x2_t *)v9;
              *(void *)double v9 = *(void *)v54;
              *(int32x2_t *)id v54 = v59;
              do
              {
                unsigned int v60 = v9[2];
                unsigned int v61 = v9[3];
                v9 += 2;
                BOOL v62 = v61 > v43;
                BOOL v73 = v60 == (_DWORD)v42;
                BOOL v63 = v60 > v42;
                if (v73) {
                  BOOL v63 = v62;
                }
              }

              while (!v63);
              do
              {
                unsigned int v64 = *(v54 - 2);
                unsigned int v65 = *(v54 - 1);
                v54 -= 2;
                BOOL v66 = v65 > v43;
                BOOL v73 = v64 == (_DWORD)v42;
                BOOL v67 = v64 > v42;
                if (v73) {
                  BOOL v67 = v66;
                }
              }

              while (v67);
            }

            uint64_t v68 = v9 - 2;
            if (v9 - 2 != v7) {
              *(void *)unint64_t v7 = *(void *)v68;
            }
            a4 = 0;
            *(void *)uint64_t v68 = v42;
            continue;
          }
        }

        uint64_t v17 = *(void *)v7;
        uint64_t v18 = HIDWORD(*(void *)v7);
        id v19 = v7;
        do
        {
          id v20 = v19;
          unsigned int v21 = v19[2];
          v19 += 2;
          BOOL v22 = v21 < v17;
          if (v21 == (_DWORD)v17) {
            BOOL v22 = v20[3] < v18;
          }
        }

        while (v22);
        uint64_t v23 = a2;
        if (v20 == v7)
        {
          uint64_t v23 = a2;
          do
          {
            if (v19 >= v23) {
              break;
            }
            unsigned int v28 = *(v23 - 2);
            unsigned int v29 = *(v23 - 1);
            v23 -= 2;
            BOOL v30 = v29 < v18;
            BOOL v73 = v28 == (_DWORD)v17;
            BOOL v31 = v28 < v17;
            if (v73) {
              BOOL v31 = v30;
            }
          }

          while (!v31);
        }

        else
        {
          do
          {
            unsigned int v24 = *(v23 - 2);
            unsigned int v25 = *(v23 - 1);
            v23 -= 2;
            BOOL v26 = v25 < v18;
            BOOL v73 = v24 == (_DWORD)v17;
            BOOL v27 = v24 < v17;
            if (v73) {
              BOOL v27 = v26;
            }
          }

          while (!v27);
        }

        if (v19 < v23)
        {
          id v32 = v19;
          id v33 = v23;
          do
          {
            uint64_t v34 = *(void *)v32;
            *(void *)id v32 = *(void *)v33;
            *(void *)id v33 = v34;
            do
            {
              id v20 = v32;
              unsigned int v35 = v32[2];
              v32 += 2;
              BOOL v36 = v35 < v17;
              if (v35 == (_DWORD)v17) {
                BOOL v36 = v20[3] < v18;
              }
            }

            while (v36);
            do
            {
              unsigned int v37 = *(v33 - 2);
              unsigned int v38 = *(v33 - 1);
              v33 -= 2;
              BOOL v39 = v38 < v18;
              BOOL v73 = v37 == (_DWORD)v17;
              BOOL v40 = v37 < v17;
              if (v73) {
                BOOL v40 = v39;
              }
            }

            while (!v40);
          }

          while (v32 < v33);
        }

        if (v20 != v7) {
          *(void *)unint64_t v7 = *(void *)v20;
        }
        *(void *)id v20 = v17;
        if (v19 < v23)
        {
LABEL_42:
          __n128 result = std::__introsort<std::_ClassicAlgPolicy,GRCInfo::MergeCounterData(NSArray *,NSArray*<NSArray*<NSString *>>,NSArray *,std::vector<std::unordered_map<unsigned int,GRCInfo::EncoderCounterInfo>> &,NSMutableDictionary<NSArray*,NSNumber *> *)::{lambda(GRCInfo::EncoderCounterInfo const&,GRCInfo::EncoderCounterInfo const&)#1} &,GRCInfo::EncoderCounterInfo*,false>( v7,  v20,  a3,  a4 & 1);
          a4 = 0;
          double v9 = v20 + 2;
          continue;
        }

        BOOL v41 = std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,GRCInfo::MergeCounterData(NSArray *,NSArray*<NSArray*<NSString *>>,NSArray *,std::vector<std::unordered_map<unsigned int,GRCInfo::EncoderCounterInfo>> &,NSMutableDictionary<NSArray*,NSNumber *> *)::{lambda(GRCInfo::EncoderCounterInfo const&,GRCInfo::EncoderCounterInfo const&)#1} &,GRCInfo::EncoderCounterInfo*>( v7,  v20);
        double v9 = v20 + 2;
        __n128 result = std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,GRCInfo::MergeCounterData(NSArray *,NSArray*<NSArray*<NSString *>>,NSArray *,std::vector<std::unordered_map<unsigned int,GRCInfo::EncoderCounterInfo>> &,NSMutableDictionary<NSArray*,NSNumber *> *)::{lambda(GRCInfo::EncoderCounterInfo const&,GRCInfo::EncoderCounterInfo const&)#1} &,GRCInfo::EncoderCounterInfo*>( v20 + 2,  a2);
        if (!(_DWORD)result)
        {
          if (v41) {
            continue;
          }
          goto LABEL_42;
        }

        a2 = v20;
        if (!v41) {
          goto LABEL_2;
        }
        return result;
    }
  }

char *std::vector<GRCInfo::MergeCounterData(NSArray *,NSArray*<NSArray*<NSString *>>,NSArray *,std::vector<std::unordered_map<unsigned int,GRCInfo::EncoderCounterInfo>> &,NSMutableDictionary<NSArray*,NSNumber *> *)::CounterValueData,std::allocator<GRCInfo::MergeCounterData(NSArray *,NSArray*<NSArray*<NSString *>>,NSArray *,std::vector<std::unordered_map<unsigned int,GRCInfo::EncoderCounterInfo>> &,NSMutableDictionary<NSArray*,NSNumber *> *)::CounterValueData>>::__vallocate[abi:nn180100]( void *a1, unint64_t a2)
{
  if (a2 >> 60) {
    abort();
  }
  __n128 result = (char *)operator new(16 * a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[16 * a2];
  return result;
}

void std::vector<std::vector<std::vector<GRCInfo::MergeCounterData(NSArray *,NSArray*<NSArray*<NSString *>>,NSArray *,std::vector<std::unordered_map<unsigned int,GRCInfo::EncoderCounterInfo>> &,NSMutableDictionary<NSArray*,NSNumber *> *)::CounterValueData,std::allocator<GRCInfo::MergeCounterData(NSArray *,NSArray*<NSArray*<NSString *>>,NSArray *,std::vector<std::unordered_map<unsigned int,GRCInfo::EncoderCounterInfo>> &,NSMutableDictionary<NSArray*,NSNumber *> *)::CounterValueData>>>>::__destroy_vector::operator()[abi:nn180100]( void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = (void **)**a1;
  if (v2)
  {
    uint64_t v4 = (void **)v1[1];
    id v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        v4 -= 3;
        id v6 = v4;
        std::vector<std::vector<DYMTLEncoderInfo>>::__destroy_vector::operator()[abi:nn180100](&v6);
      }

      while (v4 != v2);
      id v5 = **a1;
    }

    v1[1] = v2;
    operator delete(v5);
  }

unsigned int *std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,GRCInfo::MergeCounterData(NSArray *,NSArray*<NSArray*<NSString *>>,NSArray *,std::vector<std::unordered_map<unsigned int,GRCInfo::EncoderCounterInfo>> &,NSMutableDictionary<NSArray*,NSNumber *> *)::{lambda(GRCInfo::EncoderCounterInfo const&,GRCInfo::EncoderCounterInfo const&)#1} &,GRCInfo::EncoderCounterInfo*>( unsigned int *result, unsigned int *a2, unsigned int *a3)
{
  unsigned int v3 = *a2;
  unsigned int v4 = a2[1];
  BOOL v5 = *a2 < *result;
  if (*a2 == *result) {
    BOOL v5 = v4 < result[1];
  }
  BOOL v6 = a3[1] < v4;
  BOOL v7 = *a3 == v3;
  BOOL v8 = *a3 < v3;
  if (!v7) {
    BOOL v6 = v8;
  }
  if (v5)
  {
    uint64_t v9 = *(void *)result;
    if (v6)
    {
      *(void *)__n128 result = *(void *)a3;
LABEL_17:
      *(void *)a3 = v9;
      return result;
    }

    *(void *)__n128 result = *(void *)a2;
    *(void *)a2 = v9;
    BOOL v13 = *a3 < v9;
    if (*a3 == (_DWORD)v9) {
      BOOL v13 = a3[1] < HIDWORD(v9);
    }
    if (v13)
    {
      *(void *)a2 = *(void *)a3;
      goto LABEL_17;
    }
  }

  else if (v6)
  {
    uint64_t v10 = *(void *)a2;
    *(void *)a2 = *(void *)a3;
    *(void *)a3 = v10;
    BOOL v11 = *a2 < *result;
    if (*a2 == *result) {
      BOOL v11 = a2[1] < result[1];
    }
    if (v11)
    {
      uint64_t v12 = *(void *)result;
      *(void *)__n128 result = *(void *)a2;
      *(void *)a2 = v12;
    }
  }

  return result;
}

unsigned int *std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,GRCInfo::MergeCounterData(NSArray *,NSArray*<NSArray*<NSString *>>,NSArray *,std::vector<std::unordered_map<unsigned int,GRCInfo::EncoderCounterInfo>> &,NSMutableDictionary<NSArray*,NSNumber *> *)::{lambda(GRCInfo::EncoderCounterInfo const&,GRCInfo::EncoderCounterInfo const&)#1} &,GRCInfo::EncoderCounterInfo*>( unsigned int *a1, unsigned int *a2, unsigned int *a3, unsigned int *a4)
{
  __n128 result = std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,GRCInfo::MergeCounterData(NSArray *,NSArray*<NSArray*<NSString *>>,NSArray *,std::vector<std::unordered_map<unsigned int,GRCInfo::EncoderCounterInfo>> &,NSMutableDictionary<NSArray*,NSNumber *> *)::{lambda(GRCInfo::EncoderCounterInfo const&,GRCInfo::EncoderCounterInfo const&)#1} &,GRCInfo::EncoderCounterInfo*>( a1,  a2,  a3);
  BOOL v9 = *a4 < *a3;
  if (*a4 == *a3) {
    BOOL v9 = a4[1] < a3[1];
  }
  if (v9)
  {
    uint64_t v10 = *(void *)a3;
    *(void *)a3 = *(void *)a4;
    *(void *)a4 = v10;
    BOOL v11 = *a3 < *a2;
    if (*a3 == *a2) {
      BOOL v11 = a3[1] < a2[1];
    }
    if (v11)
    {
      uint64_t v12 = *(void *)a2;
      *(void *)a2 = *(void *)a3;
      *(void *)a3 = v12;
      BOOL v13 = *a2 < *a1;
      if (*a2 == *a1) {
        BOOL v13 = a2[1] < a1[1];
      }
      if (v13)
      {
        uint64_t v14 = *(void *)a1;
        *(void *)a1 = *(void *)a2;
        *(void *)a2 = v14;
      }
    }
  }

  return result;
}

unsigned int *std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,GRCInfo::MergeCounterData(NSArray *,NSArray*<NSArray*<NSString *>>,NSArray *,std::vector<std::unordered_map<unsigned int,GRCInfo::EncoderCounterInfo>> &,NSMutableDictionary<NSArray*,NSNumber *> *)::{lambda(GRCInfo::EncoderCounterInfo const&,GRCInfo::EncoderCounterInfo const&)#1} &,GRCInfo::EncoderCounterInfo*>( unsigned int *a1, unsigned int *a2, unsigned int *a3, unsigned int *a4, unsigned int *a5)
{
  __n128 result = std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,GRCInfo::MergeCounterData(NSArray *,NSArray*<NSArray*<NSString *>>,NSArray *,std::vector<std::unordered_map<unsigned int,GRCInfo::EncoderCounterInfo>> &,NSMutableDictionary<NSArray*,NSNumber *> *)::{lambda(GRCInfo::EncoderCounterInfo const&,GRCInfo::EncoderCounterInfo const&)#1} &,GRCInfo::EncoderCounterInfo*>( a1,  a2,  a3,  a4);
  BOOL v11 = *a5 < *a4;
  if (*a5 == *a4) {
    BOOL v11 = a5[1] < a4[1];
  }
  if (v11)
  {
    uint64_t v12 = *(void *)a4;
    *(void *)a4 = *(void *)a5;
    *(void *)a5 = v12;
    BOOL v13 = *a4 < *a3;
    if (*a4 == *a3) {
      BOOL v13 = a4[1] < a3[1];
    }
    if (v13)
    {
      uint64_t v14 = *(void *)a3;
      *(void *)a3 = *(void *)a4;
      *(void *)a4 = v14;
      BOOL v15 = *a3 < *a2;
      if (*a3 == *a2) {
        BOOL v15 = a3[1] < a2[1];
      }
      if (v15)
      {
        uint64_t v16 = *(void *)a2;
        *(void *)a2 = *(void *)a3;
        *(void *)a3 = v16;
        BOOL v17 = *a2 < *a1;
        if (*a2 == *a1) {
          BOOL v17 = a2[1] < a1[1];
        }
        if (v17)
        {
          uint64_t v18 = *(void *)a1;
          *(void *)a1 = *(void *)a2;
          *(void *)a2 = v18;
        }
      }
    }
  }

  return result;
}

BOOL std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,GRCInfo::MergeCounterData(NSArray *,NSArray*<NSArray*<NSString *>>,NSArray *,std::vector<std::unordered_map<unsigned int,GRCInfo::EncoderCounterInfo>> &,NSMutableDictionary<NSArray*,NSNumber *> *)::{lambda(GRCInfo::EncoderCounterInfo const&,GRCInfo::EncoderCounterInfo const&)#1} &,GRCInfo::EncoderCounterInfo*>( unsigned int *a1, unsigned int *a2)
{
  uint64_t v4 = ((char *)a2 - (char *)a1) >> 3;
  BOOL result = 1LL;
  switch(v4)
  {
    case 0LL:
    case 1LL:
      return result;
    case 2LL:
      unsigned int v6 = *(a2 - 2);
      BOOL v7 = v6 == *a1;
      BOOL v8 = v6 < *a1;
      if (v7) {
        BOOL v8 = *(a2 - 1) < a1[1];
      }
      if (v8)
      {
        uint64_t v9 = *(void *)a1;
        *(void *)a1 = *((void *)a2 - 1);
        *((void *)a2 - 1) = v9;
      }

      return result;
    case 3LL:
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,GRCInfo::MergeCounterData(NSArray *,NSArray*<NSArray*<NSString *>>,NSArray *,std::vector<std::unordered_map<unsigned int,GRCInfo::EncoderCounterInfo>> &,NSMutableDictionary<NSArray*,NSNumber *> *)::{lambda(GRCInfo::EncoderCounterInfo const&,GRCInfo::EncoderCounterInfo const&)#1} &,GRCInfo::EncoderCounterInfo*>( a1,  a1 + 2,  a2 - 2);
      return 1LL;
    case 4LL:
      std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,GRCInfo::MergeCounterData(NSArray *,NSArray*<NSArray*<NSString *>>,NSArray *,std::vector<std::unordered_map<unsigned int,GRCInfo::EncoderCounterInfo>> &,NSMutableDictionary<NSArray*,NSNumber *> *)::{lambda(GRCInfo::EncoderCounterInfo const&,GRCInfo::EncoderCounterInfo const&)#1} &,GRCInfo::EncoderCounterInfo*>( a1,  a1 + 2,  a1 + 4,  a2 - 2);
      return 1LL;
    case 5LL:
      std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,GRCInfo::MergeCounterData(NSArray *,NSArray*<NSArray*<NSString *>>,NSArray *,std::vector<std::unordered_map<unsigned int,GRCInfo::EncoderCounterInfo>> &,NSMutableDictionary<NSArray*,NSNumber *> *)::{lambda(GRCInfo::EncoderCounterInfo const&,GRCInfo::EncoderCounterInfo const&)#1} &,GRCInfo::EncoderCounterInfo*>( a1,  a1 + 2,  a1 + 4,  a1 + 6,  a2 - 2);
      return 1LL;
    default:
      uint64_t v10 = a1 + 4;
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,GRCInfo::MergeCounterData(NSArray *,NSArray*<NSArray*<NSString *>>,NSArray *,std::vector<std::unordered_map<unsigned int,GRCInfo::EncoderCounterInfo>> &,NSMutableDictionary<NSArray*,NSNumber *> *)::{lambda(GRCInfo::EncoderCounterInfo const&,GRCInfo::EncoderCounterInfo const&)#1} &,GRCInfo::EncoderCounterInfo*>( a1,  a1 + 2,  a1 + 4);
      BOOL v11 = a1 + 6;
      if (a1 + 6 == a2) {
        return 1LL;
      }
      uint64_t v12 = 0LL;
      int v13 = 0;
      break;
  }

  while (1)
  {
    BOOL v14 = *v11 < *v10;
    if (*v11 == *v10) {
      BOOL v14 = v11[1] < v10[1];
    }
    if (v14)
    {
      uint64_t v15 = *(void *)v11;
      uint64_t v16 = HIDWORD(*(void *)v11);
      uint64_t v17 = v12;
      while (1)
      {
        uint64_t v18 = (char *)a1 + v17;
        *(void *)((char *)a1 + v17 + 24) = *(void *)((char *)a1 + v17 + 16);
        if (v17 == -16) {
          break;
        }
        unsigned int v19 = *((_DWORD *)v18 + 2);
        BOOL v20 = *((_DWORD *)v18 + 3) > v16;
        BOOL v7 = v19 == (_DWORD)v15;
        BOOL v21 = v19 > v15;
        if (!v7) {
          BOOL v20 = v21;
        }
        v17 -= 8LL;
        if (!v20)
        {
          BOOL v22 = (unsigned int *)((char *)a1 + v17 + 24);
          goto LABEL_18;
        }
      }

      BOOL v22 = a1;
LABEL_18:
      *(void *)BOOL v22 = v15;
      if (++v13 == 8) {
        return v11 + 2 == a2;
      }
    }

    uint64_t v10 = v11;
    v12 += 8LL;
    v11 += 2;
    if (v11 == a2) {
      return 1LL;
    }
  }

void ___ZNK7GRCInfo27SubDividedCounterDictionaryEP14NSMutableArrayIP19GPURawCounterSelectEP26GTMTLReplayOperationQueues_block_invoke( void *a1)
{
  id v5 = (id)objc_claimAutoreleasedReturnValue([*(id *)(a1[6] + 16) firstObject]);
  uint64_t v2 = objc_claimAutoreleasedReturnValue([v5 subDivideCounterList:a1[4] withOptions:0]);
  uint64_t v3 = *(void *)(a1[5] + 8LL);
  uint64_t v4 = *(void **)(v3 + 40);
  *(void *)(v3 + 40) = v2;
}

void sub_A1360( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
}

void ___ZL18DerivedCounterDataP21GTMTLReplayControllerP26GTMTLReplayOperationQueuesP7NSArrayP19NSMutableDictionaryjP21GTAGXPerfStateControl_block_invoke( uint64_t a1)
{
  id v6 = (id)objc_claimAutoreleasedReturnValue([*(id *)(*(void *)(a1 + 56) + 8) defaultCommandQueue]);
  [v6 setStatEnabled:1];
  uint64_t v2 = (NSArray *)objc_claimAutoreleasedReturnValue([v6 subdivideCounterList:*(void *)(a1 + 32)]);
  [v6 setStatEnabled:0];
  id v3 = CollectCounters( *(GTMTLReplayController **)(a1 + 56),  *(GTMTLReplayOperationQueues **)(a1 + 64),  *(NSArray **)(a1 + 32),  v2,  *(void **)(a1 + 40),  0LL,  0,  *(void *)(a1 + 72),  v5);
  uint64_t v4 = (void *)objc_claimAutoreleasedReturnValue(v3);
  [*(id *)(a1 + 48) addDependency:v4];
  [*(id *)(*(void *)(a1 + 64) + 8) addOperation:*(void *)(a1 + 48)];
}

void sub_A1428( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void GTMTLReplayClient_streamShaderProfilingData(uint64_t a1, id *a2, void *a3, void *a4)
{
  id v7 = a3;
  id v8 = a4;
  unsigned int v51 = v7;
  if (v7)
  {
    uint64_t v58 = 0LL;
    int32x2_t v59 = (id *)&v58;
    uint64_t v60 = 0x8012000000LL;
    unsigned int v61 = __Block_byref_object_copy__827;
    BOOL v62 = __Block_byref_object_dispose__828;
    BOOL v63 = "!0 3";
    BOOL v48 = a2;
    id v49 = v8;
    GTUSCSamplingStreamingManager::GTUSCSamplingStreamingManager((uint64_t)v64, a1, a2, v7, v8);
    uint64_t v9 = v59;
    GTUSCSamplingStreamingManager::InitTargetIndex(v59 + 6);
    uint64_t v10 = (id *)v9[6];
    id v11 = v9[12];
    int v12 = *((_DWORD *)v9 + 31);
    id v52 = v9[11];
    id v53 = v11;
    int v13 = (void *)objc_claimAutoreleasedReturnValue([v10[1] defaultDevice]);
    id Analysis = DYMTLReplayFrameProfiler_loadAnalysis(v13);
    uint64_t v15 = (void *)objc_claimAutoreleasedReturnValue(Analysis);
    [v53 addEntriesFromDictionary:v15];

    unint64_t v50 = (void *)objc_claimAutoreleasedReturnValue([v53 objectForKeyedSubscript:@"DerivedCounterDictionary"]);
    unsigned int v55 = (void *)objc_opt_new(&OBJC_CLASS___NSMutableDictionary, v16);
    uint64_t v17 = (void *)objc_claimAutoreleasedReturnValue([v50 objectForKeyedSubscript:@"DerivedCounters"]);
    if (v12)
    {
      uint64_t v18 = 0LL;
      BOOL v20 = (void *)objc_claimAutoreleasedReturnValue(+[NSSet setWithArray:](&OBJC_CLASS___NSSet, "setWithArray:", &off_59F8C0, v17));
    }

    else
    {
      uint64_t v21 = objc_claimAutoreleasedReturnValue(+[NSSet setWithArray:](&OBJC_CLASS___NSSet, "setWithArray:", &off_59F890, v17));
      BOOL v20 = (void *)objc_claimAutoreleasedReturnValue(+[NSSet setWithArray:](&OBJC_CLASS___NSSet, "setWithArray:", &off_59F8A8));
      uint64_t v18 = (void *)v21;
    }

    unsigned int v56 = v18;
    id v54 = (void *)objc_opt_new(&OBJC_CLASS___NSMutableDictionary, v19);
    uint64_t v23 = (_UNKNOWN **)objc_opt_new(&OBJC_CLASS___NSMutableArray, v22);
    __int128 v67 = 0u;
    __int128 v68 = 0u;
    __int128 v65 = 0u;
    __int128 v66 = 0u;
    id v24 = v17;
    id v25 = [v24 countByEnumeratingWithState:&v65 objects:v73 count:16];
    if (v25)
    {
      uint64_t v26 = *(void *)v66;
      do
      {
        for (unint64_t i = 0LL; i != v25; unint64_t i = (char *)i + 1)
        {
          if (*(void *)v66 != v26) {
            objc_enumerationMutation(v24);
          }
          unsigned int v28 = *(void **)(*((void *)&v65 + 1) + 8LL * (void)i);
          if ([v20 containsObject:v28])
          {
            unsigned int v29 = (void *)objc_claimAutoreleasedReturnValue([v24 objectForKeyedSubscript:v28]);
            [v55 setObject:v29 forKeyedSubscript:v28];
          }

          if ([v56 containsObject:v28])
          {
            BOOL v30 = (void *)objc_claimAutoreleasedReturnValue([v24 objectForKeyedSubscript:v28]);
            [v54 setObject:v30 forKeyedSubscript:v28];
          }

          if ([v28 isEqualToString:@"FRGTicks"])
          {
            int32x2_t v71 = v28;
            BOOL v31 = (void *)objc_claimAutoreleasedReturnValue([v24 objectForKeyedSubscript:v28]);
            uint64_t v72 = v31;
            id v32 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v72,  &v71,  1LL));
            id v33 = GTMTLReplayHost_rawCounters(v32);
            uint64_t v34 = objc_claimAutoreleasedReturnValue(v33);

            uint64_t v23 = (_UNKNOWN **)v34;
          }
        }

        id v25 = [v24 countByEnumeratingWithState:&v65 objects:v73 count:16];
      }

      while (v25);
    }

    id v35 = GTMTLReplayHost_rawCounters(v55);
    BOOL v36 = (void *)objc_claimAutoreleasedReturnValue(v35);
    unsigned int v37 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableArray arrayWithArray:](&OBJC_CLASS___NSMutableArray, "arrayWithArray:", v36));

    id v38 = GTMTLReplayHost_rawCounters(v54);
    BOOL v39 = (void *)objc_claimAutoreleasedReturnValue(v38);
    if (![v23 count])
    {

      uint64_t v23 = &off_59F8D8;
    }

    [v37 addObjectsFromArray:v23];
    [v52 setObject:v37 forKeyedSubscript:@"profileCounters"];
    if ([v39 count]) {
      [v52 setObject:v39 forKeyedSubscript:@"profileCounters32"];
    }
    BOOL v40 = (void *)objc_claimAutoreleasedReturnValue([v53 objectForKeyedSubscript:@"DerivedCounterConfigurationVariables"]);
    BOOL v41 = v40 == 0LL;

    if (!v41)
    {
      uint64_t v42 = (void *)objc_claimAutoreleasedReturnValue([v53 objectForKeyedSubscript:@"DerivedCounterConfigurationVariables"]);
      [v52 setObject:v42 forKeyedSubscript:@"DerivedCounterConfigurationVariables"];
    }

    unsigned int v69 = @"DerivedCounters";
    BOOL v70 = v55;
    uint64_t v43 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v70,  &v69,  1LL));
    [v52 setObject:v43 forKeyedSubscript:@"DerivedCounterDictionary"];

    unsigned int v44 = (void *)objc_claimAutoreleasedReturnValue([v53 objectForKeyedSubscript:@"DerivedCounterScript"]);
    [v52 setObject:v44 forKeyedSubscript:@"DerivedCounterScript"];

    BOOL v45 = (void *)objc_claimAutoreleasedReturnValue([v53 objectForKeyedSubscript:@"DerivedCounterAnalysis"]);
    [v52 setObject:v45 forKeyedSubscript:@"DerivedCounterAnalysis"];

    unsigned int v46 = (void *)objc_claimAutoreleasedReturnValue([v53 objectForKeyedSubscript:@"DerivedCounterAnalysisFunctions"]);
    [v52 setObject:v46 forKeyedSubscript:@"DerivedCounterAnalysisFunctions"];

    v57[0] = _NSConcreteStackBlock;
    v57[1] = 3221225472LL;
    v57[2] = __GTMTLReplayClient_streamShaderProfilingData_block_invoke;
    void v57[3] = &unk_58DE18;
    void v57[4] = &v58;
    unsigned int v47 = (void *)objc_claimAutoreleasedReturnValue( +[NSBlockOperation blockOperationWithBlock:]( &OBJC_CLASS___NSBlockOperation,  "blockOperationWithBlock:",  v57));
    [v48[1] addOperation:v47];

    _Block_object_dispose(&v58, 8);
    GTUSCSamplingStreamingManager::~GTUSCSamplingStreamingManager(v64);
    id v8 = v49;
  }
}

void sub_A1A54( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, id *a11, void *a12, void *a13, void *a14, void *a15, void *a16, void *a17, void *a18, void *a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, char a25)
{
  _Block_object_dispose(&a25, 8);
  GTUSCSamplingStreamingManager::~GTUSCSamplingStreamingManager(a11);

  _Unwind_Resume(a1);
}

__n128 __Block_byref_object_copy__827(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)(a1 + 4_Block_object_dispose(va, 8) = *(_OWORD *)(a2 + 48);
  *(void *)(a1 + 64) = *(id *)(a2 + 64);
  *(void *)(a1 + 72) = *(void *)(a2 + 72);
  *(void *)(a1 + 80) = objc_retainBlock(*(id *)(a2 + 80));
  *(void *)(a1 + 8_Block_object_dispose(va, 8) = *(id *)(a2 + 88);
  *(void *)(a1 + 96) = *(id *)(a2 + 96);
  *(void *)(a1 + 104) = *(id *)(a2 + 104);
  __n128 result = *(__n128 *)(a2 + 112);
  *(__n128 *)(a1 + 112) = result;
  return result;
}

void __Block_byref_object_dispose__828(uint64_t a1)
{
}

void sub_A2DB8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, void *a11, void *a12, void *a13, uint64_t a14, uint64_t a15, id a16, void *a17, void *a18, void *a19, void *a20, void *a21, void *a22, void *a23, uint64_t a24, uint64_t a25, void *__p, uint64_t a27, uint64_t a28, char a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, char a37)
{
  if (v41) {
    operator delete(v41);
  }

  if (__p) {
    operator delete(__p);
  }

  std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long>>>::~__hash_table((uint64_t)&a29);
  std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long>>>::~__hash_table((uint64_t)&a37);

  _Unwind_Resume(a1);
}

void GTMTLReplayClient_streamDerivedCounterData(uint64_t a1, id *a2, void *a3, void *a4)
{
  id v7 = a3;
  id v8 = a4;
  if (v7)
  {
    uint64_t v11 = 0LL;
    int v12 = (id *)&v11;
    uint64_t v13 = 0x8012000000LL;
    BOOL v14 = __Block_byref_object_copy__827;
    uint64_t v15 = __Block_byref_object_dispose__828;
    uint64_t v16 = "!0 3";
    GTUSCSamplingStreamingManager::GTUSCSamplingStreamingManager((uint64_t)v17, a1, a2, v7, v8);
    GTUSCSamplingStreamingManager::InitDerivedCountersInfo(v12 + 6);
    v10[0] = _NSConcreteStackBlock;
    v10[1] = 3221225472LL;
    v10[2] = __GTMTLReplayClient_streamDerivedCounterData_block_invoke;
    v10[3] = &unk_58DE18;
    v10[4] = &v11;
    uint64_t v9 = (void *)objc_claimAutoreleasedReturnValue( +[NSBlockOperation blockOperationWithBlock:]( &OBJC_CLASS___NSBlockOperation,  "blockOperationWithBlock:",  v10));
    [a2[1] addOperation:v9];

    _Block_object_dispose(&v11, 8);
    GTUSCSamplingStreamingManager::~GTUSCSamplingStreamingManager(v17);
  }
}

void sub_A3394( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  _Block_object_dispose(va, 8);
  GTUSCSamplingStreamingManager::~GTUSCSamplingStreamingManager(v9);

  _Unwind_Resume(a1);
}

void sub_A35C4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL GTMTLReplayClient_streamBatchFilteredData(uint64_t a1, id *a2, void *a3, void *a4)
{
  id v7 = a3;
  id v8 = a4;
  if (v7)
  {
    uint64_t v12 = 0LL;
    uint64_t v13 = (id *)&v12;
    uint64_t v14 = 0x8012000000LL;
    uint64_t v15 = __Block_byref_object_copy__827;
    uint64_t v16 = __Block_byref_object_dispose__828;
    uint64_t v17 = "!0 3";
    GTUSCSamplingStreamingManager::GTUSCSamplingStreamingManager((uint64_t)v18, a1, a2, v7, v8);
    GTUSCSamplingStreamingManager::InitDerivedCountersInfo(v13 + 6);
    v11[0] = _NSConcreteStackBlock;
    v11[1] = 3221225472LL;
    v11[2] = __GTMTLReplayClient_streamBatchFilteredData_block_invoke;
    v11[3] = &unk_58DE18;
    v11[4] = &v12;
    uint64_t v9 = (void *)objc_claimAutoreleasedReturnValue( +[NSBlockOperation blockOperationWithBlock:]( &OBJC_CLASS___NSBlockOperation,  "blockOperationWithBlock:",  v11));
    [a2[1] addOperation:v9];

    _Block_object_dispose(&v12, 8);
    GTUSCSamplingStreamingManager::~GTUSCSamplingStreamingManager(v18);
  }

  return v7 != 0LL;
}

void sub_A3718( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  _Block_object_dispose(va, 8);
  GTUSCSamplingStreamingManager::~GTUSCSamplingStreamingManager(v9);

  _Unwind_Resume(a1);
}

void sub_A3BD4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void GTMTLReplayClient_collectGPUShaderTimelineData(uint64_t a1, id *a2, void *a3, void *a4)
{
  id v7 = a3;
  id v8 = a4;
  unsigned int v61 = v7;
  if (v7)
  {
    uint64_t v68 = 0LL;
    unsigned int v69 = &v68;
    uint64_t v70 = 0x8012000000LL;
    int32x2_t v71 = __Block_byref_object_copy__827;
    uint64_t v72 = __Block_byref_object_dispose__828;
    BOOL v73 = "!0 3";
    id v54 = a2;
    id v55 = v8;
    GTUSCSamplingStreamingManager::GTUSCSamplingStreamingManager((uint64_t)v74, a1, a2, v7, v8);
    uint64_t v9 = v69;
    GTUSCSamplingStreamingManager::InitTargetIndex((id *)v69 + 6);
    uint64_t v10 = v9[6];
    uint64_t v11 = (void *)v9[11];
    uint64_t v12 = (void *)v9[12];
    id v62 = v11;
    id v63 = v12;
    uint64_t v13 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v10 + 8) defaultDevice]);
    id Analysis = DYMTLReplayFrameProfiler_loadAnalysis(v13);
    uint64_t v15 = (void *)objc_claimAutoreleasedReturnValue(Analysis);
    [v63 addEntriesFromDictionary:v15];

    BOOL v57 = (void *)objc_claimAutoreleasedReturnValue([v63 objectForKeyedSubscript:@"DerivedCounterDictionary"]);
    unsigned int v56 = (void *)objc_claimAutoreleasedReturnValue([v57 objectForKeyedSubscript:@"Instruments"]);
    uint64_t v16 = (void *)objc_claimAutoreleasedReturnValue([v56 objectForKeyedSubscript:@"Profiles"]);
    uint64_t v58 = (void *)objc_claimAutoreleasedReturnValue([v16 objectForKeyedSubscript:@"Set1"]);

    int32x2_t v59 = (void *)objc_claimAutoreleasedReturnValue([v58 objectForKeyedSubscript:@"DerivedCounters"]);
    uint64_t v17 = (void *)objc_claimAutoreleasedReturnValue([v58 objectForKeyedSubscript:@"RawCounterWidth"]);
    uint64_t v18 = -[NSMutableSet initWithCapacity:]( [NSMutableSet alloc],  "initWithCapacity:",  [v59 count]);
    __int128 v85 = 0u;
    __int128 v86 = 0u;
    __int128 v83 = 0u;
    __int128 v84 = 0u;
    obunint64_t j = v59;
    id v19 = [obj countByEnumeratingWithState:&v83 objects:v93 count:16];
    if (v19)
    {
      uint64_t v20 = *(void *)v84;
      do
      {
        for (unint64_t i = 0LL; i != v19; unint64_t i = (char *)i + 1)
        {
          if (*(void *)v84 != v20) {
            objc_enumerationMutation(obj);
          }
          uint64_t v22 = (void *)objc_claimAutoreleasedReturnValue( [*(id *)(*((void *)&v83 + 1) + 8 * (void)i) objectForKeyedSubscript:@"Name"]);
          if (v22) {
            -[NSMutableSet addObject:](v18, "addObject:", v22);
          }
        }

        id v19 = [obj countByEnumeratingWithState:&v83 objects:v93 count:16];
      }

      while (v19);
    }

    id v53 = (void *)objc_claimAutoreleasedReturnValue([v57 objectForKeyedSubscript:@"DerivedCounters"]);
    __int128 v65 = (void *)objc_opt_new(&OBJC_CLASS___NSMutableDictionary, v23);
    unsigned int v64 = (void *)objc_opt_new(&OBJC_CLASS___NSMutableArray, v24);
    __int128 v81 = 0u;
    __int128 v82 = 0u;
    __int128 v79 = 0u;
    __int128 v80 = 0u;
    id v25 = v53;
    id v26 = objc_msgSend(v25, "countByEnumeratingWithState:objects:count:", &v79, v92, 16, v53);
    if (v26)
    {
      uint64_t v27 = *(void *)v80;
      do
      {
        for (unint64_t j = 0LL; j != v26; unint64_t j = (char *)j + 1)
        {
          if (*(void *)v80 != v27) {
            objc_enumerationMutation(v25);
          }
          unsigned int v29 = *(void **)(*((void *)&v79 + 1) + 8LL * (void)j);
          if (-[NSMutableSet containsObject:](v18, "containsObject:", v29))
          {
            BOOL v30 = (void *)objc_claimAutoreleasedReturnValue([v25 objectForKeyedSubscript:v29]);
            [v65 setObject:v30 forKeyedSubscript:v29];
          }

          if ([v29 isEqualToString:@"FRGTicks"])
          {
            uint64_t v90 = v29;
            BOOL v31 = (void *)objc_claimAutoreleasedReturnValue([v25 objectForKeyedSubscript:v29]);
            int64_t v91 = v31;
            id v32 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v91,  &v90,  1LL));
            id v33 = GTMTLReplayHost_rawCounters(v32);
            uint64_t v34 = (void *)objc_claimAutoreleasedReturnValue(v33);
            [v64 setArray:v34];
          }
        }

        id v26 = [v25 countByEnumeratingWithState:&v79 objects:v92 count:16];
      }

      while (v26);
    }

    id v35 = GTMTLReplayHost_rawCounters(v65);
    BOOL v36 = (void *)objc_claimAutoreleasedReturnValue(v35);
    uint64_t v60 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableArray arrayWithArray:](&OBJC_CLASS___NSMutableArray, "arrayWithArray:", v36));

    [v60 addObjectsFromArray:v64];
    unsigned int v37 = -[NSMutableArray initWithCapacity:]( [NSMutableArray alloc],  "initWithCapacity:",  [v60 count]);
    __int128 v77 = 0u;
    __int128 v78 = 0u;
    __int128 v75 = 0u;
    __int128 v76 = 0u;
    id v38 = v60;
    id v39 = [v38 countByEnumeratingWithState:&v75 objects:v89 count:16];
    if (v39)
    {
      uint64_t v40 = *(void *)v76;
      do
      {
        for (uint64_t k = 0LL; k != v39; uint64_t k = (char *)k + 1)
        {
          if (*(void *)v76 != v40) {
            objc_enumerationMutation(v38);
          }
          uint64_t v42 = *(void *)(*((void *)&v75 + 1) + 8LL * (void)k);
          uint64_t v43 = (void *)objc_claimAutoreleasedReturnValue([v17 objectForKeyedSubscript:v42]);
          unsigned int v44 = v43;
        }

        id v39 = [v38 countByEnumeratingWithState:&v75 objects:v89 count:16];
      }

      while (v39);
    }

    [v62 setObject:v38 forKeyedSubscript:@"profileCounters"];
    [v62 setObject:v37 forKeyedSubscript:@"profileCounters32"];
    BOOL v45 = (void *)objc_claimAutoreleasedReturnValue([v63 objectForKeyedSubscript:@"DerivedCounterConfigurationVariables"]);
    BOOL v46 = v45 == 0LL;

    if (!v46)
    {
      unsigned int v47 = (void *)objc_claimAutoreleasedReturnValue([v63 objectForKeyedSubscript:@"DerivedCounterConfigurationVariables"]);
      [v62 setObject:v47 forKeyedSubscript:@"DerivedCounterConfigurationVariables"];
    }

    unsigned int v87 = @"DerivedCounters";
    BOOL v88 = v65;
    BOOL v48 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v88,  &v87,  1LL));
    [v62 setObject:v48 forKeyedSubscript:@"DerivedCounterDictionary"];

    id v49 = (void *)objc_claimAutoreleasedReturnValue([v63 objectForKeyedSubscript:@"DerivedCounterScript"]);
    [v62 setObject:v49 forKeyedSubscript:@"DerivedCounterScript"];

    unint64_t v50 = (void *)objc_claimAutoreleasedReturnValue([v63 objectForKeyedSubscript:@"DerivedCounterAnalysis"]);
    [v62 setObject:v50 forKeyedSubscript:@"DerivedCounterAnalysis"];

    unsigned int v51 = (void *)objc_claimAutoreleasedReturnValue([v63 objectForKeyedSubscript:@"DerivedCounterAnalysisFunctions"]);
    [v62 setObject:v51 forKeyedSubscript:@"DerivedCounterAnalysisFunctions"];

    v67[0] = _NSConcreteStackBlock;
    v67[1] = 3221225472LL;
    v67[2] = __GTMTLReplayClient_collectGPUShaderTimelineData_block_invoke;
    v67[3] = &unk_58DE18;
    v67[4] = &v68;
    id v52 = (void *)objc_claimAutoreleasedReturnValue( +[NSBlockOperation blockOperationWithBlock:]( &OBJC_CLASS___NSBlockOperation,  "blockOperationWithBlock:",  v67));
    [v54[1] addOperation:v52];

    _Block_object_dispose(&v68, 8);
    GTUSCSamplingStreamingManager::~GTUSCSamplingStreamingManager(v74);
    id v8 = v55;
  }
}

void sub_A439C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, id *a11, void *a12, void *a13, void *a14, void *a15, void *a16, void *a17, void *a18, void *a19, void *a20, void *a21, void *a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, char a29)
{
  _Block_object_dispose(&a29, 8);
  GTUSCSamplingStreamingManager::~GTUSCSamplingStreamingManager(a11);

  _Unwind_Resume(a1);
}

void sub_A46DC( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, id a9)
{
  _Unwind_Resume(a1);
}

void GTMTLReplayClient_addBatchFilteringRequest(void *a1)
{
  uint64_t v1 = a1;
  GTUSCSamplingStreamingManagerHelper::Instance(v1);
  id v7 = v1;
  uint64_t v2 = (void *)objc_claimAutoreleasedReturnValue( -[GTUSCSamplingStreamingManagerHelper objectForKeyedSubscript:]( v7,  "objectForKeyedSubscript:",  @"highPriorityBatches"));
  if (v2)
  {
    id v3 = qword_5B9560;
    uint64_t v4 = (void *)objc_claimAutoreleasedReturnValue( -[GTUSCSamplingStreamingManagerHelper objectForKeyedSubscript:]( v7,  "objectForKeyedSubscript:",  @"HighPriorityBatchInfo"));
    [v3 nextPerEncoderBatchListForHighPriorityBatches:v2 withHighPriorityInfo:v4];
  }

  else
  {
    id v5 = (void *)objc_claimAutoreleasedReturnValue( -[GTUSCSamplingStreamingManagerHelper objectForKeyedSubscript:]( v7,  "objectForKeyedSubscript:",  @"pause"));

    if (v5)
    {
      [qword_5B9560 pause];
    }

    else
    {
      id v6 = (void *)objc_claimAutoreleasedReturnValue( -[GTUSCSamplingStreamingManagerHelper objectForKeyedSubscript:]( v7,  "objectForKeyedSubscript:",  @"resume"));

      if (v6) {
        [qword_5B9560 resume];
      }
    }
  }
}

void sub_A47F4( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  uint64_t v13 = v12;

  _Unwind_Resume(a1);
}

void GTMTLReplayClient_collectAPSData(uint64_t a1, id *a2, void *a3, void *a4)
{
  id v7 = a3;
  id v8 = a4;
  if (v7)
  {
    uint64_t v11 = 0LL;
    uint64_t v12 = (id *)&v11;
    uint64_t v13 = 0x8012000000LL;
    uint64_t v14 = __Block_byref_object_copy__827;
    uint64_t v15 = __Block_byref_object_dispose__828;
    uint64_t v16 = "!0 3";
    GTUSCSamplingStreamingManager::GTUSCSamplingStreamingManager((uint64_t)v17, a1, a2, v7, v8);
    GTUSCSamplingStreamingManager::InitTargetIndex(v12 + 6);
    v10[0] = _NSConcreteStackBlock;
    v10[1] = 3221225472LL;
    v10[2] = __GTMTLReplayClient_collectAPSData_block_invoke;
    v10[3] = &unk_58DE18;
    v10[4] = &v11;
    uint64_t v9 = (void *)objc_claimAutoreleasedReturnValue( +[NSBlockOperation blockOperationWithBlock:]( &OBJC_CLASS___NSBlockOperation,  "blockOperationWithBlock:",  v10));
    [a2[1] addOperation:v9];

    _Block_object_dispose(&v11, 8);
    GTUSCSamplingStreamingManager::~GTUSCSamplingStreamingManager(v17);
  }
}

void sub_A4954( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  _Block_object_dispose(va, 8);
  GTUSCSamplingStreamingManager::~GTUSCSamplingStreamingManager(v9);

  _Unwind_Resume(a1);
}

void sub_A5774( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, void *a13, id a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, char a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32)
{
  _Unwind_Resume(a1);
}

void sub_A5AF4( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, id location)
{
}

uint64_t GTCoreOperationControl_getOperation(uint64_t a1)
{
  uint64_t v4 = a1;
  pthread_mutex_lock((pthread_mutex_t *)(control + 8));
  entry = find_entry(*(void *)control, &v4, 8uLL, 0LL);
  if (*entry) {
    uint64_t v2 = *(void *)(*entry + 32LL);
  }
  else {
    uint64_t v2 = 0LL;
  }
  pthread_mutex_unlock((pthread_mutex_t *)(control + 8));
  return v2;
}

uint64_t GTCoreOperationControl_addOperation(uint64_t a1)
{
  uint64_t v2 = apr_palloc(**(apr_pool_t ***)control, 0x20uLL);
  v2[1] = 0LL;
  v2[2] = 0LL;
  void *v2 = a1;
  *((_BYTE *)v2 + 24) = 0;
  apr_hash_set(*(apr_hash_t **)control, v2, 8LL, v2);
  return pthread_mutex_unlock((pthread_mutex_t *)(control + 8));
}

uint64_t GTCoreOperationControl_removeOperation(uint64_t a1)
{
  uint64_t v4 = a1;
  pthread_mutex_lock((pthread_mutex_t *)(control + 8));
  entry = find_entry(*(void *)control, &v4, 8uLL, 0LL);
  if (*entry)
  {
    uint64_t v2 = *(const void **)(*entry + 32LL);
    if (v2) {
      apr_hash_set(*(apr_hash_t **)control, v2, 8LL, 0LL);
    }
  }

  return pthread_mutex_unlock((pthread_mutex_t *)(control + 8));
}

uint64_t DYMTLDrawRenderCommandEncoder(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, void *a5)
{
  id v9 = a1;
  id v10 = a5;
  uint64_t v11 = *(void *)(a3 + *(void *)(a2 + 8));
  uint64_t v12 = 1LL;
  uint64_t v13 = 0LL;
  switch(v11)
  {
    case 0LL:
      goto LABEL_31;
    case 1LL:
      [v9 drawPrimitives:*(void *)(a3 + *(void *)(a2 + 96)) vertexStart:*(void *)(a3 + *(void *)(a2 + 96) + 8) vertexCount:*(void *)(a3 + *(void *)(a2 + 96) + 16) instanceCount:*(void *)(a3 + *(void *)(a2 + 96) + 24) baseInstance:*(void *)(a3 + *(void *)(a2 + 96) + 32)];
      break;
    case 2LL:
      uint64_t v18 = (void *)(a3 + *(void *)(a2 + 96));
      id v19 = *(void **)(*(void *)a4 + 24LL);
      unint64_t v20 = *(int *)(*(void *)a4 + 12LL);
      unint64_t v21 = v18[3];
      uint64_t v22 = GTMTLGPUAddressResource_resourceForGPUAddress(v19, v20, v21);
      if (v22)
      {
        unint64_t v23 = v21 - *v22;
        uint64_t v24 = v22[2];
      }

      else
      {
        unint64_t v23 = 0LL;
        uint64_t v24 = 0LL;
      }

      id ObjectForKey = GetObjectForKey(v10, v24);
      uint64_t v43 = (void *)objc_claimAutoreleasedReturnValue(ObjectForKey);
      uint64_t v12 = v43 != 0LL;
      if (v43) {
        [v9 drawIndexedPrimitives:*v18 indexCount:v18[1] indexType:v18[2] indexBuffer:v43 indexBufferOffset:v23 instanceCount:v18[4] baseVertex:v18[5] baseInstance:v18[6]];
      }
      goto LABEL_19;
    case 3LL:
    case 5LL:
    case 6LL:
    case 7LL:
      break;
    case 4LL:
      id v25 = (void *)(*(void *)(a2 + 96) + a3);
      id v26 = *(void **)(*(void *)a4 + 24LL);
      unint64_t v27 = *(int *)(*(void *)a4 + 12LL);
      unint64_t v28 = v25[6];
      unsigned int v29 = GTMTLGPUAddressResource_resourceForGPUAddress(v26, v27, v28);
      if (v29)
      {
        unint64_t v30 = v28 - *v29;
        uint64_t v31 = v29[2];
      }

      else
      {
        unint64_t v30 = 0LL;
        uint64_t v31 = 0LL;
      }

      id v44 = GetObjectForKey(v10, v31);
      uint64_t v43 = (void *)objc_claimAutoreleasedReturnValue(v44);
      int v45 = v43 != 0LL;
      unsigned int v46 = v31 == 0;
      uint64_t v12 = v45 ^ v46;
      if (v45 != v46) {
        [v9 drawPatches:v25[3] patchStart:v25[4] patchCount:v25[5] patchIndexBuffer:v43 patchIndexBufferOffset:v30 instanceCount:v25[7] baseInstance:v25[8]];
      }
LABEL_19:

      break;
    case 8LL:
      uint64_t v32 = *(void *)(a2 + 96) + a3;
      id v33 = (void *)(v32 + 24);
      unint64_t v34 = *(void *)(v32 + 48);
      id v35 = GTMTLGPUAddressResource_resourceForGPUAddress( *(void **)(*(void *)a4 + 24LL),  *(int *)(*(void *)a4 + 12LL),  v34);
      if (v35)
      {
        unint64_t v36 = v34 - *v35;
        uint64_t v37 = v35[2];
      }

      else
      {
        unint64_t v36 = 0LL;
        uint64_t v37 = 0LL;
      }

      id v47 = GetObjectForKey(v10, v37);
      BOOL v48 = (void *)objc_claimAutoreleasedReturnValue(v47);
      unsigned int v49 = (v48 != 0LL) ^ (v37 == 0);
      unint64_t v50 = *(void **)(*(void *)a4 + 24LL);
      unint64_t v51 = *(int *)(*(void *)a4 + 12LL);
      unint64_t v52 = v33[4];
      id v53 = GTMTLGPUAddressResource_resourceForGPUAddress(v50, v51, v52);
      if (v53)
      {
        unint64_t v54 = v52 - *v53;
        uint64_t v55 = v53[2];
      }

      else
      {
        unint64_t v54 = 0LL;
        uint64_t v55 = 0LL;
      }

      id v56 = GetObjectForKey(v10, v55);
      BOOL v57 = (void *)objc_claimAutoreleasedReturnValue(v56);
      if (v57) {
        uint64_t v12 = v49;
      }
      else {
        uint64_t v12 = 0LL;
      }
      if ((_DWORD)v12 == 1) {
        [v9 drawIndexedPatches:*v33 patchStart:v33[1] patchCount:v33[2] patchIndexBuffer:v48 patchIndexBufferOffset:v36 controlPointIndexBuffer:v57 contr olPointIndexBufferOffset:v54 instanceCount:v33[5] baseInstance:v33[6]];
      }

      break;
    default:
      if (v11 == 128)
      {
        id v38 = (__int128 *)(a3 + *(void *)(a2 + 96));
        uint64_t v39 = *((void *)v38 + 2);
        __int128 v69 = *v38;
        uint64_t v70 = v39;
        uint64_t v40 = *((void *)v38 + 5);
        __int128 v67 = *(__int128 *)((char *)v38 + 24);
        uint64_t v68 = v40;
        uint64_t v41 = *((void *)v38 + 8);
        __int128 v65 = v38[3];
        uint64_t v66 = v41;
        [v9 drawMeshThreadgroups:&v69 threadsPerObjectThreadgroup:&v67 threadsPerMeshThreadgroup:&v65];
      }

      else if (v11 == 256)
      {
        uint64_t v14 = (__int128 *)(a3 + *(void *)(a2 + 96));
        uint64_t v15 = *((void *)v14 + 2);
        __int128 v63 = *v14;
        uint64_t v64 = v15;
        uint64_t v16 = *((void *)v14 + 5);
        __int128 v61 = *(__int128 *)((char *)v14 + 24);
        uint64_t v62 = v16;
        uint64_t v17 = *((void *)v14 + 8);
        __int128 v59 = v14[3];
        uint64_t v60 = v17;
        [v9 drawMeshThreads:&v63 threadsPerObjectThreadgroup:&v61 threadsPerMeshThreadgroup:&v59];
      }

      break;
  }

  uint64_t v13 = v12;
LABEL_31:

  return v13;
}

id GetObjectForKey(void *a1, uint64_t a2)
{
  id v3 = a1;
  uint64_t v4 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLongLong:](&OBJC_CLASS___NSNumber, "numberWithUnsignedLongLong:", a2));
  id v5 = (void *)objc_claimAutoreleasedReturnValue([v3 objectForKeyedSubscript:v4]);

  return v5;
}

uint64_t DYMTLDispatchComputeCommandEncoder(void *a1, uint64_t a2, uint64_t a3)
{
  id v5 = a1;
  id v6 = v5;
  uint64_t v7 = *(void *)(a3 + *(void *)(a2 + 8));
  if (v7 == 64)
  {
    uint64_t v11 = *(void *)(a2 + 96) + a3;
    uint64_t v12 = *(void *)(v11 + 88);
    __int128 v18 = *(_OWORD *)(v11 + 72);
    uint64_t v19 = v12;
    uint64_t v13 = *(void *)(v11 + 112);
    __int128 v16 = *(_OWORD *)(v11 + 96);
    uint64_t v17 = v13;
    [v5 dispatchThreads:&v18 threadsPerThreadgroup:&v16];
  }

  else
  {
    if (v7 != 32)
    {
      uint64_t v14 = 0LL;
      goto LABEL_7;
    }

    uint64_t v8 = *(void *)(a2 + 96) + a3;
    uint64_t v9 = *(void *)(v8 + 88);
    __int128 v22 = *(_OWORD *)(v8 + 72);
    uint64_t v23 = v9;
    uint64_t v10 = *(void *)(v8 + 112);
    __int128 v20 = *(_OWORD *)(v8 + 96);
    uint64_t v21 = v10;
    [v5 dispatchThreadgroups:&v22 threadsPerThreadgroup:&v20];
  }

  uint64_t v14 = 1LL;
LABEL_7:

  return v14;
}

void GTMTLEncodeIndirectCommandBufferWithRange( void *a1, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t *a6, void *a7)
{
  id v11 = a1;
  id v12 = a7;
  GTMTLCreateIndirectCommandEncoder((uint64_t)&v151, a4);
  int v13 = *(unsigned __int16 *)(a4 + 8);
  if ((v13 & 0xFE70) == 0)
  {
    id v126 = v11;
    id v141 = v11;
    id v125 = v12;
    id v146 = v12;
    uint64_t v139 = a2 + a3;
    if (a2 < a2 + a3)
    {
      uint64_t v43 = v164;
      uint64_t v137 = v152;
      uint64_t v44 = a5 + a2 * v164;
      uint64_t v128 = v164;
      do
      {
        int v45 = objc_autoreleasePoolPush();
        uint64_t v46 = a5 + v43 * a2;
        unint64_t v149 = a2;
        id v47 = (void *)objc_claimAutoreleasedReturnValue([v141 indirectRenderCommandAtIndex:a2]);
        BOOL v48 = v47;
        uint64_t v49 = *(void *)(v46 + v137);
        switch(v49)
        {
          case 0LL:
            [v47 reset];
            goto LABEL_112;
          case 1LL:
            [v47 drawPrimitives:*(void *)(v46 + v163) vertexStart:*(void *)(v46 + v163 + 8) vertexCount:*(void *)(v46 + v163 + 16) instanceCount:*(void *)(v46 + v163 + 24) baseInstance:*(void *)(v46 + v163 + 32)];
            break;
          case 2LL:
            id v53 = (void *)(v46 + v163);
            unint64_t v54 = *(void *)(v46 + v163 + 24);
            uint64_t v55 = GTMTLGPUAddressResource_resourceForGPUAddress(*(void **)(*a6 + 24), *(int *)(*a6 + 12), v54);
            if (v55)
            {
              unint64_t v56 = v54 - *v55;
              uint64_t v57 = v55[2];
            }

            else
            {
              unint64_t v56 = 0LL;
              uint64_t v57 = 0LL;
            }

            id ObjectForKey = GetObjectForKey(v146, v57);
            char v74 = (void *)objc_claimAutoreleasedReturnValue(ObjectForKey);
            if (v74) {
              [v48 drawIndexedPrimitives:*v53 indexCount:v53[1] indexType:v53[2] indexBuffer:v74 indexBufferOffset:v56 instanceCount:v53[4] baseVertex:v53[5] baseInstance:v53[6]];
            }
            else {
              [v48 reset];
            }

            break;
          case 3LL:
          case 5LL:
          case 6LL:
          case 7LL:
            break;
          case 4LL:
            uint64_t v58 = v163;
            __int128 v59 = (void *)(v163 + v46);
            unint64_t v60 = *(void *)(v163 + v46 + 48);
            __int128 v61 = GTMTLGPUAddressResource_resourceForGPUAddress(*(void **)(*a6 + 24), *(int *)(*a6 + 12), v60);
            uint64_t v62 = v46;
            if (v61)
            {
              unint64_t v133 = v60 - *v61;
              uint64_t v63 = v61[2];
            }

            else
            {
              unint64_t v133 = 0LL;
              uint64_t v63 = 0LL;
            }

            id v75 = GetObjectForKey(v146, v63);
            __int128 v76 = (void *)objc_claimAutoreleasedReturnValue(v75);
            BOOL v77 = v63 == 0;
            __int128 v78 = (unint64_t *)(v62 + v58);
            unint64_t v79 = *v78;
            __int128 v80 = GTMTLGPUAddressResource_resourceForGPUAddress(*(void **)(*a6 + 24), *(int *)(*a6 + 12), *v78);
            uint64_t v81 = v44;
            if (v80)
            {
              unint64_t v82 = v79 - *v80;
              uint64_t v83 = v80[2];
            }

            else
            {
              unint64_t v82 = 0LL;
              uint64_t v83 = 0LL;
            }

            id v90 = GetObjectForKey(v146, v83);
            uint64_t v91 = objc_claimAutoreleasedReturnValue(v90);
            int64_t v92 = (void *)v91;
            if (v91) {
              int v93 = (v76 != 0LL) ^ v77;
            }
            else {
              int v93 = 0;
            }
            if (v93 == 1) {
              [v48 drawPatches:v59[3] patchStart:v59[4] patchCount:v59[5] patchIndexBuffer:v76 patchIndexBufferOffset:v133 instanceCount:v59[7] baseInstance:v59[8] tes sellationFactorBuffer:v91 tessellationFactorBufferOffset:v82 tessellationFactorBufferInstanceStride:v78[1]];
            }
            else {
              [v48 reset];
            }
            uint64_t v43 = v128;
            uint64_t v44 = v81;
            uint64_t v46 = v62;
            goto LABEL_83;
          case 8LL:
            uint64_t v64 = v163;
            uint64_t v65 = v163 + v46;
            unint64_t v66 = *(void *)(v163 + v46 + 48);
            __int128 v67 = GTMTLGPUAddressResource_resourceForGPUAddress(*(void **)(*a6 + 24), *(int *)(*a6 + 12), v66);
            uint64_t v143 = v45;
            uint64_t v68 = v46;
            if (v67)
            {
              unint64_t v134 = v66 - *v67;
              uint64_t v69 = v67[2];
            }

            else
            {
              unint64_t v134 = 0LL;
              uint64_t v69 = 0LL;
            }

            __int128 v84 = (void *)(v65 + 24);
            id v85 = GetObjectForKey(v146, v69);
            __int128 v76 = (void *)objc_claimAutoreleasedReturnValue(v85);
            BOOL v86 = v69 == 0;
            unint64_t v87 = v84[4];
            BOOL v88 = GTMTLGPUAddressResource_resourceForGPUAddress(*(void **)(*a6 + 24), *(int *)(*a6 + 12), v87);
            if (v88)
            {
              unint64_t v130 = v87 - *v88;
              uint64_t v89 = v88[2];
            }

            else
            {
              unint64_t v130 = 0LL;
              uint64_t v89 = 0LL;
            }

            id v94 = GetObjectForKey(v146, v89);
            int64_t v92 = (void *)objc_claimAutoreleasedReturnValue(v94);
            if (v92) {
              int v95 = (v76 != 0LL) ^ v86;
            }
            else {
              int v95 = 0;
            }
            uint64_t v96 = v68 + v64;
            unint64_t v97 = *(void *)(v68 + v64);
            unsigned __int32 v98 = GTMTLGPUAddressResource_resourceForGPUAddress(*(void **)(*a6 + 24), *(int *)(*a6 + 12), v97);
            if (v98)
            {
              unint64_t v99 = v97 - *v98;
              uint64_t v100 = v98[2];
            }

            else
            {
              unint64_t v99 = 0LL;
              uint64_t v100 = 0LL;
            }

            id v101 = GetObjectForKey(v146, v100);
            uint64_t v102 = objc_claimAutoreleasedReturnValue(v101);
            unint64_t v103 = (void *)v102;
            if (v102) {
              int v104 = v95;
            }
            else {
              int v104 = 0;
            }
            if (v104 == 1) {
              [v48 drawIndexedPatches:*v84 patchStart:v84[1] patchCount:v84[2] patchIndexBuffer:v76 patchIndexBufferOffset:v134 controlPointIndexBuffer :v92 controlPointIndexBufferOffset:v130 instanceCount:v84[5] baseInstance:v84[6] tessellationFactorBuffer:v102 tessellationFactorBuf ferOffset:v99 tessellationFactorBufferInstanceStride:*(void *)(v96 + 8)];
            }
            else {
              [v48 reset];
            }
            uint64_t v43 = v128;
            int v45 = v143;
            uint64_t v46 = v68;

LABEL_83:
            break;
          default:
            if (v49 == 128)
            {
              uint64_t v70 = *(void *)(v46 + v163 + 16);
              __int128 v171 = *(_OWORD *)(v46 + v163);
              *(void *)&__int128 v172 = v70;
              uint64_t v71 = *(void *)(v46 + v163 + 40);
              __int128 v176 = *(_OWORD *)(v46 + v163 + 24);
              uint64_t v177 = v71;
              uint64_t v72 = *(void *)(v46 + v163 + 64);
              __int128 v174 = *(_OWORD *)(v46 + v163 + 48);
              uint64_t v175 = v72;
              [v47 drawMeshThreadgroups:&v171 threadsPerObjectThreadgroup:&v176 threadsPerMeshThreadgroup:&v174];
            }

            else if (v49 == 256)
            {
              uint64_t v50 = *(void *)(v46 + v163 + 16);
              __int128 v169 = *(_OWORD *)(v46 + v163);
              uint64_t v170 = v50;
              uint64_t v51 = *(void *)(v46 + v163 + 40);
              __int128 v167 = *(_OWORD *)(v46 + v163 + 24);
              uint64_t v168 = v51;
              uint64_t v52 = *(void *)(v46 + v163 + 64);
              __int128 v165 = *(_OWORD *)(v46 + v163 + 48);
              uint64_t v166 = v52;
              [v47 drawMeshThreads:&v169 threadsPerObjectThreadgroup:&v167 threadsPerMeshThreadgroup:&v165];
            }

            break;
        }

        uint64_t v105 = v151;
        if (!v151[11])
        {
          uint64_t v106 = *(void *)(v46 + v153);
          if (v106)
          {
            uint64_t v107 = GTMTLIndirectResources_renderPipelineIdForUniqueIdentifier(a6[3], v106);
            id v108 = GetObjectForKey(v146, v107);
            __int8 v109 = (void *)objc_claimAutoreleasedReturnValue(v108);
            if (v109) {
              [v48 setRenderPipelineState:v109];
            }
          }
        }

        if (v105[19]) {
          uint64_t v110 = v46 + v161;
        }
        else {
          uint64_t v110 = 0LL;
        }
        if (!v105[10])
        {
          uint64_t v131 = v46;
          uint64_t v135 = v44;
          unsigned int v144 = v45;
          uint64_t v111 = v154;
          uint64_t v112 = v105[18];
          id v113 = v48;
          id v114 = v146;
          if (v112)
          {
            uint64_t v115 = 0LL;
            uint64_t v116 = v44 + v111;
            do
            {
              uint64_t v117 = *(void *)(v116 + 8 * v115);
              if (v117)
              {
                uint64_t v118 = GTMTLGPUAddressResource_resourceForGPUAddress( *(void **)(*a6 + 24),  *(int *)(*a6 + 12),  *(void *)(v116 + 8 * v115));
                if (v118)
                {
                  uint64_t v119 = v117 - *v118;
                  uint64_t v120 = v118[2];
                }

                else
                {
                  uint64_t v119 = 0LL;
                  uint64_t v120 = 0LL;
                }

                id v121 = GetObjectForKey(v114, v120);
                uint32x2_t v122 = (void *)objc_claimAutoreleasedReturnValue(v121);
                if (v122)
                {
                  if (v110) {
                    [v113 setVertexBuffer:v122 offset:v119 attributeStride:*(void *)(v110 + 8 * v115) atIndex:v115];
                  }
                  else {
                    [v113 setVertexBuffer:v122 offset:v119 atIndex:v115];
                  }
                }
              }

              ++v115;
            }

            while (v112 != v115);
          }

          uint64_t v46 = v131;
          GTMTLEncodeIndirectBufferBindings(v113, v131 + v155, v105[12], 2LL, (uint64_t)a6, v114);
          GTMTLEncodeIndirectBufferBindings(v113, v131 + v156, v105[16], 8LL, (uint64_t)a6, v114);
          GTMTLEncodeIndirectBufferBindings(v113, v131 + v157, v105[15], 16LL, (uint64_t)a6, v114);
          uint64_t v43 = v128;
          uint64_t v44 = v135;
          int v45 = v144;
        }

        if (v105[17])
        {
          unint64_t v123 = 0LL;
          uint64_t v124 = v44 + v159;
          do
          {
            [v48 setObjectThreadgroupMemoryLength:*(void *)(v124 + 8 * v123) atIndex:v123];
            ++v123;
          }

          while (v123 < v105[17]);
        }

        if (v105[21] && *(void *)(v46 + v162)) {
          [v48 setBarrier];
        }
LABEL_112:

        objc_autoreleasePoolPop(v45);
        a2 = v149 + 1;
        v44 += v43;
      }

      while (v149 + 1 != v139);
    }

    uint64_t v42 = v141;
LABEL_114:

    id v12 = v125;
    id v11 = v126;
    goto LABEL_115;
  }

  if ((v13 & 0xFFFFFF9F) == 0)
  {
    id v126 = v11;
    id v142 = v11;
    id v125 = v12;
    id v14 = v12;
    uint64_t v140 = a2 + a3;
    if (a2 < a2 + a3)
    {
      uint64_t v15 = v164;
      uint64_t v132 = v163;
      __int128 v16 = v151;
      uint64_t v127 = v153;
      uint64_t v129 = v163 + 72;
      uint64_t v136 = v161;
      uint64_t v138 = v152;
      uint64_t v17 = a5 + v158 + a2 * v164;
      uint64_t v18 = a5 + v160 + a2 * v164;
      while (1)
      {
        uint64_t v19 = objc_autoreleasePoolPush();
        uint64_t v20 = a5 + v15 * a2;
        uint64_t v21 = *(void *)(v20 + v138);
        unint64_t v148 = a2;
        __int128 v22 = (void *)objc_claimAutoreleasedReturnValue([v142 indirectComputeCommandAtIndex:a2]);
        uint64_t v23 = v22;
        if (v21 == 64) {
          break;
        }
        if (v21 == 32)
        {
          uint64_t v24 = *(void *)(v20 + v129 + 16);
          __int128 v176 = *(_OWORD *)(v20 + v129);
          uint64_t v177 = v24;
          uint64_t v25 = *(void *)(v20 + v129 + 40);
          __int128 v174 = *(_OWORD *)(v20 + v129 + 24);
          uint64_t v175 = v25;
          [v22 concurrentDispatchThreadgroups:&v176 threadsPerThreadgroup:&v174];
          goto LABEL_11;
        }

        if (v21) {
          goto LABEL_13;
        }
        [v22 reset];
LABEL_33:

        objc_autoreleasePoolPop(v19);
        a2 = v148 + 1;
        v17 += v15;
        v18 += v15;
        if (v148 + 1 == v140) {
          goto LABEL_34;
        }
      }

      uint64_t v26 = *(void *)(v20 + v129 + 16);
      __int128 v169 = *(_OWORD *)(v20 + v129);
      uint64_t v170 = v26;
      uint64_t v27 = *(void *)(v20 + v129 + 40);
      __int128 v167 = *(_OWORD *)(v20 + v129 + 24);
      uint64_t v168 = v27;
      [v22 concurrentDispatchThreads:&v169 threadsPerThreadgroup:&v167];
LABEL_11:
      __int128 v28 = *(_OWORD *)(v20 + v132 + 16);
      __int128 v171 = *(_OWORD *)(v20 + v132);
      __int128 v172 = v28;
      __int128 v173 = *(_OWORD *)(v20 + v132 + 32);
      [v23 setStageInRegion:&v171];
      if (*(_BYTE *)(v20 + v132 + 64)) {
        [v23 setBarrier];
      }
LABEL_13:
      BOOL v145 = v19;
      if (!v16[11])
      {
        uint64_t v29 = GTMTLIndirectResources_renderPipelineIdForUniqueIdentifier(a6[4], *(void *)(v20 + v127));
        id v30 = GetObjectForKey(v14, v29);
        uint64_t v31 = (void *)objc_claimAutoreleasedReturnValue(v30);
        [v23 setComputePipelineState:v31];
      }

      if (v16[19]) {
        uint64_t v32 = v20 + v136;
      }
      else {
        uint64_t v32 = 0LL;
      }
      if (!v16[10])
      {
        unsigned __int8 v33 = v16[13];
        if (v33)
        {
          for (unint64_t i = 0LL; i < v33; ++i)
          {
            uint64_t v35 = *(void *)(v17 + 8 * i);
            if (v35)
            {
              unint64_t v36 = GTMTLGPUAddressResource_resourceForGPUAddress( *(void **)(*a6 + 24),  *(int *)(*a6 + 12),  *(void *)(v17 + 8 * i));
              if (v36)
              {
                uint64_t v37 = v35 - *v36;
                uint64_t v38 = v36[2];
              }

              else
              {
                uint64_t v37 = 0LL;
                uint64_t v38 = 0LL;
              }

              id v39 = GetObjectForKey(v14, v38);
              uint64_t v40 = (void *)objc_claimAutoreleasedReturnValue(v39);
              if (v32) {
                [v23 setKernelBuffer:v40 offset:v37 attributeStride:*(void *)(v32 + 8 * i) atIndex:i];
              }
              else {
                [v23 setKernelBuffer:v40 offset:v37 atIndex:i];
              }

              unsigned __int8 v33 = v16[13];
            }
          }
        }
      }

      uint64_t v19 = v145;
      if (v16[14])
      {
        unint64_t v41 = 0LL;
        do
        {
          [v23 setThreadgroupMemoryLength:*(void *)(v18 + 8 * v41) atIndex:v41];
          ++v41;
        }

        while (v41 < v16[14]);
      }

      goto LABEL_33;
    }

LABEL_115:
}

      fclose(v10);
      if (__p) {
        operator delete(__p);
      }
    }
  }

void GTMTLEncodeIndirectBufferBindings(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, void *a6)
{
  id v19 = a1;
  id v11 = a6;
  if (a3)
  {
    uint64_t v12 = 0LL;
    do
    {
      uint64_t v13 = *(void *)(a2 + 8 * v12);
      if (v13)
      {
        id v14 = GTMTLGPUAddressResource_resourceForGPUAddress( *(void **)(*(void *)a5 + 24LL),  *(int *)(*(void *)a5 + 12LL),  *(void *)(a2 + 8 * v12));
        if (v14)
        {
          uint64_t v15 = v13 - *v14;
          uint64_t v16 = v14[2];
        }

        else
        {
          uint64_t v15 = 0LL;
          uint64_t v16 = 0LL;
        }

        id ObjectForKey = GetObjectForKey(v11, v16);
        uint64_t v18 = (void *)objc_claimAutoreleasedReturnValue(ObjectForKey);
        if (v18)
        {
          switch(a4)
          {
            case 16LL:
              [v19 setMeshBuffer:v18 offset:v15 atIndex:v12];
              break;
            case 8LL:
              [v19 setObjectBuffer:v18 offset:v15 atIndex:v12];
              break;
            case 2LL:
              [v19 setFragmentBuffer:v18 offset:v15 atIndex:v12];
              break;
          }
        }
      }

      ++v12;
    }

    while (a3 != v12);
  }
}

CFStringRef _StringForError(uint64_t a1)
{
  if (a1 <= 511)
  {
    switch(a1)
    {
      case 1LL:
        return (const __CFString *)+[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"invalid filename (%ld)",  1LL);
      case 2LL:
        return (const __CFString *)+[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"data is too large (%ld)",  2LL);
      case 3LL:
        return (const __CFString *)+[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"IO failure (%ld)",  3LL);
      case 4LL:
        return (const __CFString *)+[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"out of memory (%ld)",  4LL);
      case 5LL:
        uint64_t v3 = 5LL;
        goto LABEL_64;
      case 6LL:
        uint64_t v3 = 6LL;
LABEL_64:
        __n128 result = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"Unable to connect to the device. (%ld)",  v3);
        break;
      case 7LL:
        __n128 result = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"read-only capture archive (%ld)",  7LL);
        break;
      case 8LL:
        __n128 result = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"truncated capture archive store (%ld)",  8LL);
        break;
      case 9LL:
        __n128 result = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"truncated capture archive index (%ld)",  9LL);
        break;
      case 10LL:
        __n128 result = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"invalid capture archive index (%ld)",  10LL);
        break;
      case 11LL:
        __n128 result = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"unknown capture archive index version (%ld)",  11LL);
        break;
      case 12LL:
        __n128 result = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"file exists in capture archive (%ld)",  12LL);
        break;
      case 13LL:
        __n128 result = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"file does not exists in capture archive (%ld)",  13LL);
        break;
      case 14LL:
        __n128 result = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"capture archive does not exist (%ld)",  14LL);
        break;
      case 15LL:
        __n128 result = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"missing capture archive index (%ld)",  15LL);
        break;
      case 16LL:
        __n128 result = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"invalid capture archive metadata (%ld)",  16LL);
        break;
      case 17LL:
      case 27LL:
        return 0LL;
      case 18LL:
        __n128 result = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"corrupted capture archive store (%ld)",  18LL);
        break;
      case 19LL:
        __n128 result = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"could not write capture archive metadata (%ld)",  19LL);
        break;
      case 20LL:
        __n128 result = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"capture archive has been closed (%ld)",  20LL);
        break;
      case 21LL:
        __n128 result = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"already tried to launch guest app (%ld)",  21LL);
        break;
      case 22LL:
        __n128 result = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"invalid launch dictionary (%ld)",  22LL);
        break;
      case 23LL:
        __n128 result = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"guest app not found (%ld)",  23LL);
        break;
      case 24LL:
        __n128 result = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"guest app launch timed out (%ld)",  24LL);
        break;
      case 25LL:
        __n128 result = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"invalid guest app session (%ld)",  25LL);
        break;
      case 26LL:
        __n128 result = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"guest app has not been launched yet (%ld)",  26LL);
        break;
      case 28LL:
        __n128 result = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"did not find interpose dylib (%ld)",  28LL);
        break;
      case 29LL:
        __n128 result = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"failed to launch guest app (%ld)",  29LL);
        break;
      case 30LL:
        __n128 result = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"guest app terminated (%ld)",  30LL);
        break;
      case 31LL:
        __n128 result = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"lost transport connection (%ld)",  31LL);
        break;
      case 32LL:
        __n128 result = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"invalid transport (%ld)",  32LL);
        break;
      case 33LL:
        __n128 result = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"transport is not connected (%ld)",  33LL);
        break;
      case 34LL:
        __n128 result = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"message has already been sent (%ld)",  34LL);
        break;
      case 35LL:
        __n128 result = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"in-reply-to message has not been sent (%ld)",  35LL);
        break;
      case 36LL:
        __n128 result = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"failed to encode message attributes (%ld)",  36LL);
        break;
      case 37LL:
        __n128 result = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"connect timed out (%ld)",  37LL);
        break;
      case 38LL:
        __n128 result = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"undefined socket path (%ld)",  38LL);
        break;
      case 39LL:
        __n128 result = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"socket path is too long (%ld)",  39LL);
        break;
      case 40LL:
        __n128 result = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"message originated from this transport (%ld)",  40LL);
        break;
      case 41LL:
        __n128 result = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"initialized function stream with immutable data but swapping is required (%ld)",  41LL);
        break;
      case 42LL:
        __n128 result = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"transfer refused (%ld)",  42LL);
        break;
      case 43LL:
        __n128 result = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"protocol error (%ld)",  43LL);
        break;
      case 44LL:
        __n128 result = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"path outside destination root (%ld)",  44LL);
        break;
      case 45LL:
        __n128 result = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"transfer aborted (%ld)",  45LL);
        break;
      case 46LL:
        __n128 result = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"unknown item type (%ld)",  46LL);
        break;
      default:
        switch(a1)
        {
          case 256LL:
            __n128 result = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"invalid socket descriptor (%ld)",  256LL);
            break;
          case 257LL:
            __n128 result = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"invalid socket url (%ld)",  257LL);
            break;
          case 258LL:
            __n128 result = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"transport source cancelled (%ld)",  258LL);
            break;
          case 259LL:
            __n128 result = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"corrupt transport message header (%ld)",  259LL);
            break;
          case 260LL:
            __n128 result = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"corrupt transport message attributes (%ld)",  260LL);
            break;
          case 261LL:
            __n128 result = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"message too large (%ld)",  261LL);
            break;
          default:
            return 0LL;
        }

        break;
    }

    return result;
  }

  if (a1 <= 2047)
  {
    if (a1 <= 1023)
    {
      uint64_t v2 = a1 - 512;
      __n128 result = @"Device connection lost.";
      switch(v2)
      {
        case 0LL:
          __n128 result = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"guest app crashed (%ld)",  512LL);
          break;
        case 1LL:
          __n128 result = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"another capture session is active (%ld)",  513LL);
          break;
        case 2LL:
          __n128 result = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"capture session is already active (%ld)",  514LL);
          break;
        case 3LL:
          __n128 result = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"capture session activation failed (%ld)",  515LL);
          break;
        case 4LL:
          __n128 result = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"inferior already running (%ld)",  516LL);
          break;
        case 5LL:
          __n128 result = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"GL dispatch table mismatch (%ld)",  517LL);
          break;
        case 6LL:
          __n128 result = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"inferior and host session ids mismatch (%ld)",  518LL);
          break;
        case 7LL:
          return result;
        default:
          return 0LL;
      }

      return result;
    }

    if (a1 <= 1279)
    {
      switch(a1)
      {
        case 1024LL:
          return (const __CFString *)+[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"truncated data (%ld)",  1024LL);
        case 1025LL:
          return (const __CFString *)+[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"invalid transport message payload (%ld)",  1025LL);
        case 1026LL:
          return (const __CFString *)+[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"unexpected transport message (%ld)",  1026LL);
      }
    }

    else if (a1 > 1791)
    {
      if (a1 == 1792) {
        return (const __CFString *)+[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"no data (%ld)",  1792LL);
      }
      if (a1 == 1793) {
        return (const __CFString *)+[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"guest app session error (%ld)",  1793LL);
      }
    }

    else
    {
      if (a1 == 1280) {
        return (const __CFString *)+[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"invalid function stream header (%ld)",  1280LL);
      }
      if (a1 == 1536) {
        return (const __CFString *)+[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"position does not exist in archive (%ld)",  1536LL);
      }
    }

    return 0LL;
  }

  if (a1 <= 4351)
  {
    if (a1 > 2304)
    {
      switch(a1)
      {
        case 2305LL:
          return (const __CFString *)+[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"no archive data (%ld)",  2305LL);
        case 2306LL:
          return (const __CFString *)+[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"no thumbnail support (%ld)",  2306LL);
        case 4096LL:
          return (const __CFString *)+[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"failed to create core symbolicator (%ld)",  4096LL);
      }
    }

    else
    {
      switch(a1)
      {
        case 2048LL:
          return (const __CFString *)+[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"already replaying (%ld)",  2048LL);
        case 2049LL:
          return (const __CFString *)+[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"no loaded archives (%ld)",  2049LL);
        case 2304LL:
          return (const __CFString *)+[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"no resource streamer (%ld)",  2304LL);
      }
    }

    return 0LL;
  }

  switch(a1)
  {
    case 4608LL:
      __n128 result = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"Cannot find the specified username and host (%ld)",  4608LL);
      break;
    case 4609LL:
      __n128 result = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"Specified remote machine is not available. Please make sure to login with specified user (%ld)",  4609LL);
      break;
    case 4610LL:
      __n128 result = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"Cannot find the target path provided (%ld)",  4610LL);
      break;
    case 4611LL:
      __n128 result = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"Cannot authenticate SSH, make sure the authentication is done right (%ld)",  4611LL);
      break;
    case 4612LL:
      __n128 result = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"Cannot find Xcode.app on the remote machine. Please make sure that Xcode.app is in the Applications folder (%ld)",  4612LL);
      break;
    case 4613LL:
      __n128 result = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"Metal.framework is not available on the remote machine (%ld)",  4613LL);
      break;
    case 4614LL:
      __n128 result = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"Missing environment variables, please make sure all the required environment variables are enabled (%ld)",  4614LL);
      break;
    default:
      if (a1 == 4352)
      {
        __n128 result = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"Shader profiler failed due to an internal error (%ld)",  4352LL);
      }

      else
      {
        if (a1 != 4353) {
          return 0LL;
        }
        __n128 result = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"Shader profiler does not support multi-context captures (%ld)",  4353LL);
      }

      break;
  }

  return result;
}

void sub_A7DC4(_Unwind_Exception *a1)
{
  uint64_t v3 = (void *)std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long>>>::~__hash_table(v1);
  operator delete(v3);
  _Unwind_Resume(a1);
}

void sub_A80A0(_Unwind_Exception *a1)
{
}

void sub_A837C(_Unwind_Exception *a1)
{
}

void sub_AA8EC(_Unwind_Exception *exception_object)
{
}

void sub_AA924(void *exc_buf, int a2)
{
  if (a2)
  {
    objc_begin_catch(exc_buf);
    if (a2 == 2)
    {
      *(void *)(v2 + 40) = 0LL;
      objc_end_catch();
    }

    JUMPOUT(0xAA880LL);
  }

  JUMPOUT(0xAA914LL);
}

void sub_AB99C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

LABEL_36:
    LOBYTE(v15) = 0;
    return v15;
  }

  uint64_t v15 = -[GTTransport_replayer _packMessage:error:](self, "_packMessage:error:", a3, a5);
  if (v15)
  {
    uint64_t v16 = -[GTTransport_replayer _nextMessageSerial](self, "_nextMessageSerial");
    if (a4) {
      uint64_t v17 = (uint64_t)[a4 serial];
    }
    else {
      uint64_t v17 = 0xFFFFFFFFLL;
    }
    [a3 _setSerial:v16 replySerial:v17 transport:self];
    if (a8)
    {
      uint64_t v18 = -[GTContinuation_replayer initWithQueue:block:]( objc_alloc(&OBJC_CLASS___GTTransportMessageReplyContinuation_replayer),  "initWithQueue:block:",  a6,  a8);
      id v19 = v18;
      p_invalid = &self->_invalid;
      do
        uint64_t v21 = __ldaxr((unsigned int *)p_invalid);
      while (__stlxr(v21 + 1, (unsigned int *)p_invalid));
      isa = self[1].super.isa;
      uint64_t v23 = BYTE1(self->_interposerVersion);
      if (v18)
      {
        if (a7)
        {
          v18->timeout = a7;
          uint64_t v24 = dispatch_time(0LL, a7);
          queue = (dispatch_queue_s *)self->_queue;
          block[0] = _NSConcreteStackBlock;
          block[1] = 3221225472LL;
          block[2] = __63__GTTransport_send_inReplyTo_error_replyQueue_timeout_handler___block_invoke;
          block[3] = &unk_58E248;
          block[4] = self;
          uint64_t v40 = v16;
          dispatch_after(v24, queue, block);
        }

        uint64_t v26 = (dispatch_queue_s *)self->_queue;
        v37[0] = _NSConcreteStackBlock;
        v37[1] = 3221225472LL;
        v37[2] = __63__GTTransport_send_inReplyTo_error_replyQueue_timeout_handler___block_invoke_2;
        void v37[3] = &unk_58E298;
        v37[4] = self;
        void v37[5] = v19;
        uint64_t v38 = v16;
        dispatch_sync(v26, v37);
        if (!v23) {
          goto LABEL_24;
        }
      }

      else if (!BYTE1(self->_interposerVersion))
      {
LABEL_24:
        uint64_t v29 = 0;
        goto LABEL_25;
      }
    }

    else
    {
      uint64_t v27 = &self->_invalid;
      do
        __int128 v28 = __ldaxr((unsigned int *)v27);
      while (__stlxr(v28 + 1, (unsigned int *)v27));
      id v19 = 0LL;
      isa = self[1].super.isa;
      uint64_t v29 = BYTE1(self->_interposerVersion);
      if (!v29) {
        goto LABEL_25;
      }
    }

    dispatch_suspend((dispatch_object_t)self->_queue);
    uint64_t v29 = 1;
LABEL_25:
    sendQueue = self->_sendQueue;
    v34[0] = _NSConcreteStackBlock;
    v34[1] = 3221225472LL;
    v34[2] = __63__GTTransport_send_inReplyTo_error_replyQueue_timeout_handler___block_invoke_3;
    v34[3] = &unk_58E2E8;
    unint64_t v36 = v29;
    v34[4] = self;
    v34[5] = v19;
    v34[6] = a3;
    uint64_t v35 = v16;
    ((void (*)(OS_dispatch_queue *, void *))isa)(sendQueue, v34);

    LOBYTE(v15) = 1;
  }

  return v15;
}

                  int v45 = *(v28 - 1);
                  if (v45)
                  {
                    uint64_t v46 = v28[1];
                    if (!v46) {
                      uint64_t v46 = *(v28 - 1);
                    }
                    id v47 = (double)v46 / (double)v45;
                  }

                  else
                  {
                    id v47 = 1.0;
                  }

                  unint64_t v34 = v36 * ((1.0 - v36) * (v34 * v47) + v34 * v36);
                  break;
              }
            }

            BOOL v48 = v33 + 40LL * v31;
            *(double *)(v48 + 16) = v34 + *(double *)(v48 + 16);
            ++*(_DWORD *)(v48 + 24);
            uint64_t v20 = v57;
            goto LABEL_43;
          }

          uint64_t v20 = v57;
        }

          unint64_t v36 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedInteger:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedInteger:",  v22));
          -[NSMutableArray addObject:](v74, "addObject:", v36);

          uint64_t v8 = v62 + 1;
          uint64_t v7 = v63;
          goto LABEL_52;
        }
      }

      else
      {
        uint64_t v27 = v12 + 32 * v10;
        unint64_t v60 = (unint64_t *)(v27 + 8);
        __int128 v28 = v13 + 1;
        if ((unint64_t)(v13 + 1) >= *(void *)(v27 + 8))
        {
          id v30 = 0LL;
        }

        else
        {
          uint64_t v29 = *(void *)(v27 + 8);
          id v30 = 0LL;
          do
          {
            uint64_t v31 = *(void *)(v76 + 24) + (v28 << 6);
            uint64_t v32 = *(_DWORD *)(v31 + 8);
            if (IsFuncEnumSampledCall(v32, v73))
            {
              ++v30;
            }

            else if (v32 >> 2 == 1073737833)
            {
              GetExecuteCommandsInBufferArgs((uint64_t)v77, v31, *(void *)(v61 + 16));
              uint64_t Object = GTMTLSMContext_getObject(**(void **)(v61 + 40), v77[0], *(void *)v31);
              GTMTLCreateIndirectCommandEncoder((uint64_t)v80, Object[13]);
              unint64_t v34 = v78;
              if (v78)
              {
                uint64_t v35 = v77[1] << 32;
                do
                {
                  if (*(void *)(v79 + v80[1] + v80[13] * (v35 >> 32))) {
                    ++v30;
                  }
                  v35 += 0x100000000LL;
                  --v34;
                }

                while (v34);
              }

              uint64_t v29 = *v60;
            }

            ++v28;
          }

          while (v28 < v29);
        }

        uint64_t v37 = -[NSMutableDictionary count](v72, "count");
        uint64_t v38 = *(void *)v15 - *(void *)(v61 + 80);
        id v39 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedInteger:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedInteger:",  v30));
        -[NSMutableArray addObject:](v71, "addObject:", v39);

        uint64_t v40 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedInteger:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedInteger:",  v30));
        unint64_t v41 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedInteger:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedInteger:",  v38));
        -[NSMutableDictionary setObject:forKeyedSubscript:](v64, "setObject:forKeyedSubscript:", v40, v41);

        uint64_t v42 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedInteger:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedInteger:",  v30));
        uint64_t v43 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedInteger:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedInteger:",  v37));
        -[NSMutableDictionary setObject:forKeyedSubscript:](v72, "setObject:forKeyedSubscript:", v42, v43);

        v65 += v30;
        uint64_t v44 = GetFuncEnumConstructorType(*(_DWORD *)(v15 + 8));
        if (((1 << v44) & 0x10220000) != 0) {
          int v45 = 1;
        }
        else {
          int v45 = 2;
        }
        if (v44 <= 0x1C) {
          uint64_t v46 = v45;
        }
        else {
          uint64_t v46 = 2LL;
        }
        id v47 = v44;
        BOOL v48 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", v46));
        -[NSMutableArray addObject:](v70, "addObject:", v48);

        if ((v47 | 4) == 0x15)
        {
          uint64_t v49 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedInteger:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedInteger:",  v37));
          uint64_t v50 = v69;
        }

        else
        {
          uint64_t v51 = -[NSMutableDictionary count](v68, "count");
          uint64_t v52 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedInteger:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedInteger:",  v30));
          id v53 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedInteger:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedInteger:",  v51));
          -[NSMutableDictionary setObject:forKeyedSubscript:](v68, "setObject:forKeyedSubscript:", v52, v53);

          unint64_t v54 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedInteger:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedInteger:",  v30));
          -[NSMutableArray addObject:](v67, "addObject:", v54);

          uint64_t v49 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", v46));
          uint64_t v50 = v66;
        }

        -[NSMutableArray addObject:](v50, "addObject:", v49);

        uint64_t v20 = v12 + 32 * v10;
      }

      LODWORD(v10) = *(_DWORD *)(v20 + 20) + v10;
    }

    apr_hash_set(v7, v9 + 1, 8LL, v9);
  }

  return v9;
}

void __Block_byref_object_copy__1099(uint64_t a1, uint64_t a2)
{
}

void __Block_byref_object_dispose__1100(uint64_t a1)
{
}

void sub_ACC84(_Unwind_Exception *a1)
{
}

void sub_ACD3C(_Unwind_Exception *a1)
{
}

uint64_t GPUTools::VMBuffer::_alloc(GPUTools::VMBuffer *this, vm_size_t a2, uint64_t a3)
{
  int v3 = 0;
  vm_address_t address = 0LL;
  if (3 * vm_page_size <= a2) {
    vm_size_t v4 = (a2 + vm_page_size - 1) & -(uint64_t)vm_page_size;
  }
  else {
    vm_size_t v4 = 3 * vm_page_size;
  }
  vm_size_t v5 = v4 + v4 * a3;
  while (1)
  {
    vm_map_t v6 = mach_task_self_;
    vm_size_t v7 = vm_page_size + v5;
    if (!vm_allocate(mach_task_self_, &address, vm_page_size + v5, 1))
    {
      vm_address_t v8 = address;
      vm_address_t v9 = address + v4;
      target_vm_address_t address = address + v4;
      uint64_t v10 = a3;
      if (a3)
      {
        while (!vm_deallocate(v6, v9, v4)
             && !vm_remap(v6, &target_address, v4, 0LL, 0, v6, address, 0, &cur_protection, &v15, 2u))
        {
          vm_address_t v9 = target_address + v4;
          target_address += v4;
          if (!--v10)
          {
            vm_address_t v8 = address;
            goto LABEL_11;
          }
        }

        goto LABEL_12;
      }

vm_address_t *GPUTools::VMBuffer::_dealloc(vm_address_t *this)
{
  if (*this)
  {
    uint64_t v1 = this;
    this = (vm_address_t *)vm_deallocate(mach_task_self_, *this, vm_page_size + this[1] + this[1] * this[2]);
    v1[1] = 0LL;
    v1[2] = 0LL;
    vm_address_t *v1 = 0LL;
  }

  return this;
}

LABEL_20:
          iov += v18;
          id v14 = v7 - ((unint64_t)((char *)iov - (char *)self->_iov) >> 4);
        }

        uint64_t v17 = *v16;
      }

      while (*v16 == 4);
      if (v17 != 35) {
        break;
      }
      if (LOBYTE(self->super._interposerVersion))
      {
        if (a3) {
          *a3 = -[GTTransport_replayer error](self, "error");
        }
        goto LABEL_24;
      }

      -[GTBaseStreamTransport_replayer _waitEAGAIN](self, "_waitEAGAIN");
    }

    __int128 v22 = +[NSError errorWithDomain:code:userInfo:]( &OBJC_CLASS___NSError,  "errorWithDomain:code:userInfo:",  NSPOSIXErrorDomain,  v17,  0LL);
    -[GTBaseStreamTransport_replayer _scheduleInvalidation:](self, "_scheduleInvalidation:", v22);
    if (a3) {
      *a3 = v22;
    }
    *__error() = v17;
LABEL_24:
    vm_map_t v6 = -1LL;
  }

  uint64_t v16 = atomic_load((unsigned int *)self->_incomingShmem + 4);
  if (v16 != -1) {
    return;
  }
  vm_size_t v4 = 31LL;
LABEL_23:
  uint64_t v17 = objc_autoreleasePoolPush();
  -[GTBaseStreamTransport_replayer _scheduleInvalidation:]( self,  "_scheduleInvalidation:",  +[GTError_replayer errorWithDomain:code:userInfo:]( &OBJC_CLASS___GTError_replayer,  "errorWithDomain:code:userInfo:",  @"DYErrorDomain",  v4,  0LL));
  objc_autoreleasePoolPop(v17);
}

        uint64_t v10 = v21;
        if (v21 < v24)
        {
          __int128 v28 = v24;
          do
          {
            uint64_t v29 = *(_OWORD *)v10;
            id v125 = *(_OWORD *)(v10 + 16);
            id v30 = *(void *)(v10 + 32);
            uint64_t v32 = *(_OWORD *)v28;
            uint64_t v31 = *(_OWORD *)(v28 + 16);
            *(void *)(v10 + 32) = *(void *)(v28 + 32);
            *(_OWORD *)uint64_t v10 = v32;
            *(_OWORD *)(v10 + 16) = v31;
            *(void *)(v28 + 32) = v30;
            *(_OWORD *)__int128 v28 = v29;
            *(_OWORD *)(v28 + 16) = v125;
            do
            {
              unsigned __int8 v33 = *(_DWORD *)(v10 + 72);
              v10 += 40LL;
            }

            while (v33 < v20);
            do
            {
              unint64_t v34 = *(_DWORD *)(v28 - 8);
              v28 -= 40LL;
            }

            while (v34 >= v20);
          }

          while (v10 < v28);
        }

        uint64_t v35 = (__int128 *)(v10 - 40);
        if (v10 - 40 != a1)
        {
          unint64_t v36 = *v35;
          uint64_t v37 = *(_OWORD *)(v10 - 24);
          *(void *)(a1 + 32) = *(void *)(v10 - 8);
          *(_OWORD *)a1 = v36;
          *(_OWORD *)(a1 + 16) = v37;
        }

        void *v35 = v111;
        *(_OWORD *)(v10 - 24) = v114;
        *(void *)(v10 - _Block_object_dispose(va, 8) = v20;
        if (v21 < v24)
        {
LABEL_31:
          std::__introsort<std::_ClassicAlgPolicy,ProfileEventHelper::ProcessQueue(void)::{lambda(ShaderProfilerUSCSampleInfo const&,ShaderProfilerUSCSampleInfo&)#1} &,ShaderProfilerUSCSampleInfo*,false>( a1,  v10 - 40,  a3,  a4 & 1);
          a4 = 0;
          continue;
        }

        uint64_t v38 = std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,ProfileEventHelper::ProcessQueue(void)::{lambda(ShaderProfilerUSCSampleInfo const&,ShaderProfilerUSCSampleInfo&)#1} &,ShaderProfilerUSCSampleInfo*>( a1,  v10 - 40);
        if (!std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,ProfileEventHelper::ProcessQueue(void)::{lambda(ShaderProfilerUSCSampleInfo const&,ShaderProfilerUSCSampleInfo&)#1} &,ShaderProfilerUSCSampleInfo*>( v10,  a2))
        {
          if (v38) {
            continue;
          }
          goto LABEL_31;
        }

        a2 = v10 - 40;
        if (!v38) {
          goto LABEL_1;
        }
        return result;
    }
  }

      objc_autoreleasePoolPop(v22);
      id v30 = (*v21 + 1);
      *uint64_t v21 = v30;
    }

    while (v67 > v30);
  }

  v68[5621] = 0;
  [v62 finish];
  [v62 setGPUPriority:1];
  [v62 setStatEnabled:0];
  [(id)g_commandBufferDescriptor setErrorOptions:v57];

  uint64_t v50 = g_signpostLog;
  uint64_t v51 = (os_log_s *)v50;
  uint64_t v52 = *(void *)(a1 + 80);
  if (v52 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled((os_log_t)v50))
  {
    LOWORD(v83[0]) = 0;
    _os_signpost_emit_with_name_impl( &dword_0,  v51,  OS_SIGNPOST_INTERVAL_END,  v52,  "Replayer-1-serial",  (const char *)&unk_3189BB,  (uint8_t *)v83,  2u);
  }

  id v53 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 48) commandBufferWithUnretainedReferences]);
  unint64_t v54 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"%@.%@",  @"com.apple.gputools.replay",  @"CollectFrameCounters"));
  [v53 setLabel:v54];

  v69[0] = _NSConcreteStackBlock;
  v69[1] = 3221225472LL;
  v69[2] = __CollectFrameCounters_block_invoke_315;
  v69[3] = &unk_58F760;
  uint64_t v71 = *(void *)(a1 + 104);
  uint64_t v70 = *(id *)(a1 + 56);
  [v53 addCompletedHandler:v69];
  GTMTLReplay_commitCommandBuffer(v53);

  return [(id)g_activityLog leaveActivity];
}

  uint64_t v26 = (unint64_t *)[v6 copy];
  uint64_t v27 = v41[12];
  v41[12] = v26;
  __int128 v28 = 1LL;
LABEL_37:

  return v28;
}

  __int128 v22 = v11 >> 26;
  uint64_t v23 = *(unsigned int *)(a1 + 120);
  uint64_t v24 = v7;
  [v24 setRawArrayValues:@"_RawCounterValues" withUint32Values:v13 andNumCounters:v10 * v22];
  objc_msgSend(v24, "setRawArrayValues:withUint32Values:andNumCounters:", @"_CoreCount");
  uint64_t v25 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLong:](&OBJC_CLASS___NSNumber, "numberWithUnsignedLong:", v10));
  uint64_t v26 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLong:",  (int)v22 - 1,  v25));
  v38[1] = v26;
  uint64_t v27 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLong:](&OBJC_CLASS___NSNumber, "numberWithUnsignedLong:", v23));
  v38[2] = v27;
  __int128 v28 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", v38, 3LL));
  [v24 callFunction:@"_SetAndEvaluateRawCounterValues" withArguments:v28];

  uint64_t v29 = (void *)objc_claimAutoreleasedReturnValue([v24 getValue:@"_DerivedCounterResult"]);
  id v30 = (void *)objc_claimAutoreleasedReturnValue([v29 toArray]);

  uint64_t v31 = *(unsigned int *)(v2 + 520);
  if (*(void *)(a1 + 88) * v31)
  {
    uint64_t v32 = 0LL;
    unsigned __int8 v33 = 1;
    unint64_t v34 = *(void *)(a1 + 72) * v31 / ((unint64_t)**(unsigned int **)(a1 + 104) >> 26);
    do
    {
      uint64_t v35 = (void *)objc_claimAutoreleasedReturnValue([v30 objectAtIndexedSubscript:v32]);
      [v35 doubleValue];
      *(void *)(*(void *)(a1 + 112) + 8 * (v32 + v34)) = v36;

      uint64_t v32 = v33;
    }

    while (*(void *)(a1 + 88) * (unint64_t)*(unsigned int *)(v2 + 520) > v33++);
  }

  if (v13) {
    operator delete(v13);
  }
LABEL_25:

  objc_autoreleasePoolPop(v3);
}

        ++v11;
      }

      if (v20 == 32)
      {
        id v14 = 1;
        goto LABEL_20;
      }

      if (v20 == 35)
      {
        uint64_t v16 = 1;
        goto LABEL_20;
      }

    uint64_t v18 = *(_DWORD *)v92;
    if (*(_DWORD *)v92 == 126)
    {
      ++v10;
    }

    else if (v18 == 106)
    {
      ++v13;
    }

    else if (v18 == 105)
    {
      ++v12;
    }

    a1 = InternalDataArgumentChainEnd(v14, a4);
    if ((*((_BYTE *)a1 + 33) & 0x20) != 0) {
      goto LABEL_31;
    }
  }

  uint64_t v21 = *a4;
  __int128 v80 = 0u;
  uint64_t v81 = 0u;
  BOOL v77 = v21;
  __int128 v78 = 500;
  uint64_t v23 = "err == 0 || err == 2";
LABEL_29:
  unint64_t v79 = v23;
  uint64_t v20 = &v77;
LABEL_30:
  GTError_addError(a4, (uint64_t)v20);
LABEL_31:
  if (v12) {
    uint64_t v24 = a2[14];
  }
  else {
    uint64_t v24 = 0LL;
  }
  id v11 = a2[14] + 56LL * v12;
  id v75 = v24;
  __int128 v76 = v11;
  if (!v13)
  {
LABEL_35:
    uint64_t v13 = 0;
    __int128 v76 = 0LL;
  }

  a2[14] = v11 + 56LL * v13;
  if (v10) {
    uint64_t v25 = a2[22];
  }
  else {
    uint64_t v25 = 0LL;
  }
  if (v10) {
    uint64_t v26 = a2[22] + 8LL * v10;
  }
  else {
    uint64_t v26 = 0LL;
  }
  a2[22] += 8LL * v10 + 8LL * v10;
  uint64_t v27 = v7[8];
  if ((v27 & 0x1000) == 0) {
    goto LABEL_95;
  }
  if (!a4)
  {
    if ((v27 & 0x2000) == 0) {
      goto LABEL_47;
    }
LABEL_95:
    LOWORD(v29) = 0;
    LOWORD(v30) = 0;
    LOWORD(v31) = 0;
    LOWORD(v32) = 0;
    char v74 = 0;
LABEL_96:
    if (!(_DWORD)a3) {
      goto LABEL_98;
    }
LABEL_97:
    __int128 v61 = a2[11];
    *(_OWORD *)(v61 + _Block_object_dispose(va, 8) = 0uLL;
    uint64_t v62 = v87;
    *(_OWORD *)(v61 + 56) = v86;
    *(_OWORD *)(v61 + 72) = v62;
    *(_OWORD *)(v61 + 144) = *(_OWORD *)((char *)v85 + 10);
    *(_OWORD *)(v61 + 134) = v85[0];
    uint64_t v63 = v83;
    *(_OWORD *)(v61 + 11_Block_object_dispose(va, 8) = v84;
    *(void *)__int128 v61 = -1LL;
    *(void *)(v61 + 24) = v75;
    *(void *)(v61 + 32) = v76;
    *(void *)(v61 + 40) = v25;
    *(void *)(v61 + 4_Block_object_dispose(va, 8) = v26;
    *(_DWORD *)(v61 + 8_Block_object_dispose(va, 8) = v88;
    *(_WORD *)(v61 + 92) = v29;
    *(_WORD *)(v61 + 94) = v30;
    *(_WORD *)(v61 + 96) = v31;
    *(_WORD *)(v61 + 9_Block_object_dispose(va, 8) = v32;
    *(_WORD *)(v61 + 100) = v74;
    *(_OWORD *)(v61 + 102) = v63;
    goto LABEL_98;
  }

  if ((v27 & 0x2000) != 0)
  {
    __int128 v28 = *a4;
    int64_t v92 = 0u;
    __s = 0u;
    uint64_t v89 = v28;
    id v90 = 500;
    uint64_t v91 = "!(header->flags & FBUF_ASSOCIATION_CHAIN_END)";
    GTError_addError(a4, (uint64_t)&v89);
    goto LABEL_95;
  }

    uint64_t v23 = *(_DWORD *)v119;
    if (*(int *)v119 <= 120)
    {
      if (v23 == 104) {
        uint64_t v24 = v9 + 1;
      }
      else {
        uint64_t v24 = v9;
      }
      if (v23 == 103) {
        uint64_t v25 = v17 + 1;
      }
      else {
        uint64_t v25 = v17;
      }
      if (v23 == 103) {
        uint64_t v24 = v9;
      }
      if (v23 == 102)
      {
        ++v18;
      }

      else
      {
        uint64_t v17 = v25;
        vm_address_t v9 = v24;
      }
    }

    else
    {
      switch(v23)
      {
        case 121:
          ++v99;
          break;
        case 126:
          ++v15;
          break;
        case 130:
          ++v11;
          break;
        case 131:
          ++v95;
          break;
        case 133:
          ++v13;
          break;
        case 134:
          ++v97;
          break;
        default:
          break;
      }
    }

    a1 = InternalDataArgumentChainEnd(v19, a4);
    if ((*((_BYTE *)a1 + 33) & 0x20) != 0) {
      goto LABEL_44;
    }
  }

  __int128 v28 = *a4;
  id v108 = 0u;
  __int8 v109 = 0u;
  uint64_t v105 = v28;
  uint64_t v106 = 500;
  id v30 = "err == 0";
LABEL_42:
  uint64_t v107 = v30;
  uint64_t v27 = &v105;
LABEL_43:
  GTError_addError(a4, (uint64_t)v27);
LABEL_44:
  vm_size_t v5 = a2;
  uint64_t v12 = v95;
  if ((_WORD)v17) {
    uint64_t v31 = a2[14];
  }
  else {
    uint64_t v31 = 0LL;
  }
  uint64_t v91 = v31;
  uint64_t v16 = a2[14] + 56LL * (unsigned __int16)v17;
  id v101 = v16;
  id v14 = v97;
  uint64_t v10 = v99;
  if (!v18)
  {
LABEL_48:
    uint64_t v18 = 0;
    id v101 = 0LL;
  }

  uint64_t v32 = v16 + 56LL * v18;
  if (v11) {
    unsigned __int8 v33 = v32;
  }
  else {
    unsigned __int8 v33 = 0LL;
  }
  unint64_t v34 = v32 + 56LL * v11;
  if (v13) {
    uint64_t v35 = v34;
  }
  else {
    uint64_t v35 = 0LL;
  }
  unint64_t v36 = v34 + 56LL * v13;
  if (v12) {
    uint64_t v37 = v36;
  }
  else {
    uint64_t v37 = 0LL;
  }
  uint64_t v89 = v37;
  uint64_t v38 = v36 + 56LL * v12;
  if (v14) {
    id v39 = v38;
  }
  else {
    id v39 = 0LL;
  }
  BOOL v88 = v39;
  uint64_t v40 = v38 + 56LL * v14;
  if ((_WORD)v9) {
    unint64_t v41 = v40;
  }
  else {
    unint64_t v41 = 0LL;
  }
  id v90 = v41;
  uint64_t v42 = v40 + 56LL * (unsigned __int16)v9;
  if (v10) {
    uint64_t v43 = v42;
  }
  else {
    uint64_t v43 = 0LL;
  }
  unint64_t v87 = v43;
  _DWORD v5[14] = v42 + 56LL * v10;
  if (v15) {
    uint64_t v44 = v5[22];
  }
  else {
    uint64_t v44 = 0LL;
  }
  if (v15) {
    int v45 = v5[22] + 8LL * v15;
  }
  else {
    int v45 = 0LL;
  }
  __int128 v84 = v45;
  id v85 = v44;
  v5[22] += 8LL * v15 + 8LL * v15;
  uint64_t v46 = v6[8];
  if ((v46 & 0x1000) == 0)
  {
    LOWORD(v47) = 0;
    BOOL v48 = 0;
    unsigned __int32 v98 = 0;
    uint64_t v100 = 0;
    id v94 = 0;
    uint64_t v96 = 0;
    uint64_t v49 = 0;
    int64_t v92 = 0;
    BOOL v86 = 0;
    if (!a3) {
      goto LABEL_134;
    }
    goto LABEL_133;
  }

  if (!a4)
  {
    uint64_t v50 = a3;
    if ((v46 & 0x2000) == 0) {
      goto LABEL_80;
    }
LABEL_131:
    LOWORD(v47) = 0;
    BOOL v48 = 0;
    unsigned __int32 v98 = 0;
    uint64_t v100 = 0;
    id v94 = 0;
    uint64_t v96 = 0;
    uint64_t v49 = 0;
    int64_t v92 = 0;
    BOOL v86 = 0;
LABEL_132:
    if (!(_DWORD)v50) {
      goto LABEL_134;
    }
    goto LABEL_133;
  }

  uint64_t v50 = a3;
  if ((v46 & 0x2000) != 0)
  {
    uint64_t v51 = *a4;
    uint64_t v119 = 0u;
    __s = 0u;
    uint64_t v116 = v51;
    uint64_t v117 = 500;
    uint64_t v118 = "!(header->flags & FBUF_ASSOCIATION_CHAIN_END)";
    GTError_addError(a4, (uint64_t)&v116);
    goto LABEL_131;
  }

void sub_AF118( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
}

uint64_t smt_poll_thread_entry(void *a1)
{
  uint64_t v2 = (dispatch_queue_s *)a1[1];
  int v3 = (void *)a1[2];
  snprintf(__str, 0x40uLL, "gputools.smt_poll.%p", a1);
  pthread_setname_np(__str);
  while (!*((_BYTE *)a1 + 24))
  {
    dispatch_sync(v2, v3);
    usleep(0x1F40u);
  }

  return 0LL;
}

void sub_B0648( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
}

BOOL CallIO<AGXConsistentPerfStateControlRec,AGXConsistentPerfStateControlRec>( mach_port_t a1, void *inputStruct, void *outputStruct, uint64_t a4)
{
  if (!a1) {
    return 0LL;
  }
  size_t outputStructCnt = 8LL;
  uint64_t v5 = IOConnectCallStructMethod(a1, 0x41u, inputStruct, 8uLL, outputStruct, &outputStructCnt);
  BOOL v6 = (_DWORD)v5 == 0;
  if ((_DWORD)v5 && g_runningInCI)
  {
    vm_size_t v7 = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"IOConnectCallStructMethod method:%u for:%s failed (0x%x - %s)",  65LL,  a4,  v5,  mach_error_string(v5));
    vm_address_t v8 = (void *)objc_claimAutoreleasedReturnValue(v7);
    vm_address_t v9 = (void *)objc_claimAutoreleasedReturnValue( [v8 stringByReplacingOccurrencesOfString:@"\n" withString:@"\n#CI-ERROR# "]);

    uint64_t v10 = __stdoutp;
    id v11 = v9;
    fprintf(v10, "#CI-ERROR# %s\n", (const char *)[v11 UTF8String]);
  }

  return v6;
}

void sub_B1620(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t RecommendedState(void *a1, uint64_t a2, unsigned int a3)
{
  id v5 = a1;
  BOOL v6 = v5;
  if (v5)
  {
    [v5 doubleValue];
    double v8 = v7;
    vm_address_t v9 = (double *)operator new(0x18uLL);
    uint64_t v10 = 0LL;
    LODWORD(v11) = 0;
    double *v9 = (double)a2;
    v9[1] = (double)HIDWORD(a2);
    v9[2] = (double)a3;
    double v12 = 1.79769313e308;
    do
    {
      double v13 = vabdd_f64(v9[v10], v8 + -2.22044605e-16);
      double v14 = v13 + (double)v10++ * 0.2;
      if (v14 >= v12)
      {
        uint64_t v11 = v11;
      }

      else
      {
        double v12 = v13;
        uint64_t v11 = v10;
      }
    }

    while (v10 != 3);
    operator delete(v9);
  }

  else
  {
    uint64_t v11 = 0LL;
  }

  return v11;
}

void sub_B16F8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void GTAGXPerfStateControl::InitWithDevice(uint64_t a1, void *a2)
{
  id v10 = a2;
  if ((objc_opt_respondsToSelector(v10, "enableConsistentPerfState:") & 1) != 0
    && (objc_opt_respondsToSelector(v10, "disableConsistentPerfState") & 1) != 0
    && (objc_opt_respondsToSelector(v10, "getConsistentPerfStateInfoAndReset:") & 1) != 0
    && (objc_opt_respondsToSelector(v10, "getConsistentPerfStateMappingTable") & 1) != 0)
  {
    objc_storeStrong((id *)(a1 + 16), a2);
    goto LABEL_11;
  }

  io_service_t IOAccelerator = GetIOAccelerator();
  if (IOServiceOpen(IOAccelerator, mach_task_self_, 1u, (io_connect_t *)a1))
  {
    int v5 = 2;
LABEL_10:
    *(_DWORD *)(a1 + 4) = v5;
    goto LABEL_11;
  }

  uint64_t outputStruct = 258LL;
  if (CallIO<AGXConsistentPerfStateControlRec,AGXConsistentPerfStateControlRec>( *(_DWORD *)a1,  &outputStruct,  &outputStruct,  (uint64_t)"ConsistentPerfState_Get"))
  {
    int v5 = 1;
    goto LABEL_10;
  }

  if (g_runningInCI)
  {
    BOOL v6 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"Error, fail to get consistent perf status!\n"));
    double v7 = (void *)objc_claimAutoreleasedReturnValue( [v6 stringByReplacingOccurrencesOfString:@"\n" withString:@"\n#CI-ERROR# "]);

    double v8 = __stdoutp;
    id v9 = v7;
    fprintf(v8, "#CI-ERROR# %s\n", (const char *)[v9 UTF8String]);
  }

  *(_DWORD *)(a1 + 4) = 2;
  if (*(_DWORD *)a1)
  {
    IOServiceClose(*(_DWORD *)a1);
    *(_DWORD *)a1 = 0;
  }

void sub_B1890( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, id a11)
{
  _Unwind_Resume(a1);
}

void GTAGXPerfStateControl::EnableConsistentGPUPerfState(uint64_t a1, uint64_t a2)
{
  vm_size_t v4 = *(void **)(a1 + 16);
  if (v4)
  {
    if ([v4 enableConsistentPerfState:a2])
    {
      usleep(0x186A0u);
    }

    else if (g_runningInCI)
    {
      id v18 = (id)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"Error, fail to set consistent perf state to level = %u!\n",  a2));
      uint64_t v16 = (void *)objc_claimAutoreleasedReturnValue( [v18 stringByReplacingOccurrencesOfString:@"\n" withString:@"\n#CI-ERROR# "]);

      uint64_t v17 = __stdoutp;
      id v19 = v16;
      fprintf(v17, "#CI-ERROR# %s\n", (const char *)[v19 UTF8String]);
    }
  }

  else
  {
    mach_port_t v5 = *(_DWORD *)a1;
    if (*(_DWORD *)a1)
    {
      uint64_t outputStruct = 256LL;
      BOOL v6 = CallIO<AGXConsistentPerfStateControlRec,AGXConsistentPerfStateControlRec>( v5,  &outputStruct,  &outputStruct,  (uint64_t)"ConsistentPerfState_Lock");
      *(_BYTE *)(a1 + _Block_object_dispose(va, 8) = v6;
      if (!v6 && g_runningInCI)
      {
        double v7 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"Error, fail to acquire consistent perf state SPI access!\n"));
        double v8 = (void *)objc_claimAutoreleasedReturnValue( [v7 stringByReplacingOccurrencesOfString:@"\n" withString:@"\n#CI-ERROR# "]);

        id v9 = __stdoutp;
        id v10 = v8;
        fprintf(v9, "#CI-ERROR# %s\n", (const char *)[v10 UTF8String]);
      }

      if (v6)
      {
        LOBYTE(outputStruct) = 1;
        BYTE1(outputStruct) = a2;
        BOOL v11 = CallIO<AGXConsistentPerfStateControlRec,AGXConsistentPerfStateControlRec>( *(_DWORD *)a1,  &outputStruct,  &outputStruct,  (uint64_t)"ConsistentPerfState_Set");
        if (!v11 && g_runningInCI)
        {
          double v12 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"Error, fail to set consistent perf state to level = %u!\n",  a2));
          double v13 = (void *)objc_claimAutoreleasedReturnValue( [v12 stringByReplacingOccurrencesOfString:@"\n" withString:@"\n#CI-ERROR# "]);

          double v14 = __stdoutp;
          id v15 = v13;
          fprintf(v14, "#CI-ERROR# %s\n", (const char *)[v15 UTF8String]);
        }

        if (v11) {
          usleep(0x30D40u);
        }
      }
    }
  }

void sub_B1B34( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, id a11)
{
  _Unwind_Resume(a1);
}

void GTAGXPerfStateControl::DisableConsistentGPUPerfState(GTAGXPerfStateControl *this)
{
  uint64_t v2 = (void *)*((void *)this + 2);
  if (v2)
  {
    [v2 disableConsistentPerfState];
  }

  else
  {
    mach_port_t v3 = *(_DWORD *)this;
    if (*(_DWORD *)this)
    {
      if (*((_BYTE *)this + 8))
      {
        uint64_t outputStruct = 0LL;
        if (!CallIO<AGXConsistentPerfStateControlRec,AGXConsistentPerfStateControlRec>( v3,  &outputStruct,  &outputStruct,  (uint64_t)"ConsistentPerfState_Unlock"))
        {
          if (g_runningInCI)
          {
            vm_size_t v4 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"Error, fail to release consistent perf state SPI access!\n"));
            mach_port_t v5 = (void *)objc_claimAutoreleasedReturnValue( [v4 stringByReplacingOccurrencesOfString:@"\n" withString:@"\n#CI-ERROR# "]);

            BOOL v6 = __stdoutp;
            id v7 = v5;
            fprintf(v6, "#CI-ERROR# %s\n", (const char *)[v7 UTF8String]);
          }
        }
      }
    }
  }

void sub_B1C50(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

_UNKNOWN **GTAGXPerfStateControl::ConsistentGPUPerfStateLevel(GTAGXPerfStateControl *this, NSNumber *a2)
{
  mach_port_t v3 = a2;
  vm_size_t v4 = (void *)*((void *)this + 2);
  uint64_t v63 = v3;
  if (!v4)
  {
    uint64_t v32 = v3;
    if (!*(_DWORD *)this)
    {
      uint64_t v69 = &__kCFBooleanFalse;
      unint64_t v66 = @"enabled";
      __int128 v67 = @"supported";
      unsigned __int8 v33 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithBool:](&OBJC_CLASS___NSNumber, "numberWithBool:", *((_DWORD *)this + 1) == 1));
      uint64_t v70 = v33;
      uint64_t v52 = (_UNKNOWN **)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v69,  &v66,  2LL));
LABEL_37:
      id v7 = v52;
LABEL_38:

      goto LABEL_39;
    }

    unsigned __int8 v33 = (void *)objc_opt_new(&OBJC_CLASS___NSMutableDictionary, v31);
    unint64_t v34 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithBool:](&OBJC_CLASS___NSNumber, "numberWithBool:", *((_DWORD *)this + 1) == 1));
    [v33 setObject:v34 forKeyedSubscript:@"supported"];

    uint64_t outputStruct = 258LL;
    if (!CallIO<AGXConsistentPerfStateControlRec,AGXConsistentPerfStateControlRec>( *(_DWORD *)this,  &outputStruct,  &outputStruct,  (uint64_t)"ConsistentPerfState_Get"))
    {
      if (g_runningInCI)
      {
        id v53 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"Error, fail to get consistent perf mapping table!\n"));
        unint64_t v54 = (void *)objc_claimAutoreleasedReturnValue( [v53 stringByReplacingOccurrencesOfString:@"\n" withString:@"\n#CI-ERROR# "]);

        uint64_t v55 = __stdoutp;
        id v56 = v54;
        fprintf(v55, "#CI-ERROR# %s\n", (const char *)[v56 UTF8String]);
      }

      uint64_t v69 = &__kCFBooleanFalse;
      unint64_t v66 = @"enabled";
      __int128 v67 = @"supported";
      uint64_t v57 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithBool:](&OBJC_CLASS___NSNumber, "numberWithBool:", *((_DWORD *)this + 1) == 1));
      uint64_t v70 = v57;
      id v7 = (_UNKNOWN **)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v69,  &v66,  2LL));

      goto LABEL_38;
    }

    unint64_t v66 = @"enabled";
    uint64_t v35 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithBool:](&OBJC_CLASS___NSNumber, "numberWithBool:", BYTE2(outputStruct) == 1));
    uint64_t v69 = v35;
    __int128 v67 = @"consistent";
    unint64_t v36 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithBool:](&OBJC_CLASS___NSNumber, "numberWithBool:", BYTE3(outputStruct) == 1));
    uint64_t v70 = v36;
    uint64_t v68 = @"level";
    uint64_t v37 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedChar:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedChar:",  BYTE4(outputStruct)));
    uint64_t v71 = v37;
    uint64_t v38 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v69,  &v66,  3LL));
    [v33 addEntriesFromDictionary:v38];

    uint64_t outputStruct = 3LL;
    if (CallIO<AGXConsistentPerfStateControlRec,AGXConsistentPerfStateControlRec>( *(_DWORD *)this,  &outputStruct,  &outputStruct,  (uint64_t)"ConsistentPerfState_GetMappingTable"))
    {
      if (v32)
      {
        id v39 = +[NSNumber numberWithUnsignedInt:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedInt:",  RecommendedState( v32,  BYTE1(outputStruct) | ((unint64_t)BYTE2(outputStruct) << 32),  BYTE3(outputStruct)));
        uint64_t v40 = (void *)objc_claimAutoreleasedReturnValue(v39);
        [v33 setObject:v40 forKeyedSubscript:@"recommended"];
      }

      unint64_t v41 = (void *)objc_claimAutoreleasedReturnValue([v33 objectForKeyedSubscript:@"level"]);
      unsigned int v42 = [v41 unsignedIntValue];

      switch(v42)
      {
        case 1u:
          id v43 = (id)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedChar:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedChar:",  BYTE1(outputStruct)));
          [v33 setObject:v43 forKeyedSubscript:@"mapping"];
          goto LABEL_35;
        case 2u:
          id v43 = (id)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedChar:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedChar:",  BYTE2(outputStruct)));
          [v33 setObject:v43 forKeyedSubscript:@"mapping"];
          goto LABEL_35;
        case 3u:
          id v43 = (id)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedChar:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedChar:",  BYTE3(outputStruct)));
          [v33 setObject:v43 forKeyedSubscript:@"mapping"];
LABEL_35:

          break;
      }
    }

    else if (g_runningInCI)
    {
      uint64_t v58 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"Error, fail to get consistent perf state status!\n"));
      __int128 v59 = (void *)objc_claimAutoreleasedReturnValue( [v58 stringByReplacingOccurrencesOfString:@"\n" withString:@"\n#CI-ERROR# "]);

      unint64_t v60 = __stdoutp;
      id v43 = v59;
      fprintf(v60, "#CI-ERROR# %s\n", (const char *)[v43 UTF8String]);
      goto LABEL_35;
    }

    uint64_t v52 = v33;
    unsigned __int8 v33 = v52;
    goto LABEL_37;
  }

  BOOL v6 = (void *)objc_claimAutoreleasedReturnValue([v4 getConsistentPerfStateInfoAndReset:1]);
  if (!v6)
  {
    if (g_runningInCI)
    {
      uint64_t v44 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"Error, fail to get consistent perf state status!\n"));
      int v45 = (void *)objc_claimAutoreleasedReturnValue( [v44 stringByReplacingOccurrencesOfString:@"\n" withString:@"\n#CI-ERROR# "]);

      uint64_t v46 = __stdoutp;
      id v47 = v45;
      fprintf(v46, "#CI-ERROR# %s\n", (const char *)[v47 UTF8String]);
    }

    id v7 = &off_59FFE8;
    goto LABEL_30;
  }

  id v7 = (_UNKNOWN **)objc_opt_new(&OBJC_CLASS___NSMutableDictionary, v5);
  [v7 setObject:&__kCFBooleanTrue forKeyedSubscript:@"supported"];
  double v8 = (void *)objc_claimAutoreleasedReturnValue([v6 objectForKeyedSubscript:@"is_enabled"]);
  id v9 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithBool:](NSNumber, "numberWithBool:", [v8 BOOLValue]));
  [v7 setObject:v9 forKeyedSubscript:@"enabled"];

  id v10 = (void *)objc_claimAutoreleasedReturnValue([v6 objectForKeyedSubscript:@"was_consistent"]);
  BOOL v11 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithBool:](NSNumber, "numberWithBool:", [v10 BOOLValue]));
  [v7 setObject:v11 forKeyedSubscript:@"consistent"];

  double v12 = (void *)objc_claimAutoreleasedReturnValue([v6 objectForKeyedSubscript:@"level"]);
  double v13 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedInt:]( NSNumber,  "numberWithUnsignedInt:",  [v12 unsignedIntValue]));
  [v7 setObject:v13 forKeyedSubscript:@"level"];

  double v14 = (void *)objc_claimAutoreleasedReturnValue([*((id *)this + 2) getConsistentPerfStateMappingTable]);
  id v15 = v14;
  if (!v14)
  {
    if (g_runningInCI)
    {
      BOOL v48 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"Error, fail to get consistent perf mapping table!\n"));
      uint64_t v49 = (void *)objc_claimAutoreleasedReturnValue( [v48 stringByReplacingOccurrencesOfString:@"\n" withString:@"\n#CI-ERROR# "]);

      uint64_t v50 = __stdoutp;
      id v51 = v49;
      fprintf(v50, "#CI-ERROR# %s\n", (const char *)[v51 UTF8String]);
    }

    goto LABEL_29;
  }

  uint64_t v62 = v14;
  uint64_t v16 = (void *)objc_claimAutoreleasedReturnValue([v14 objectForKeyedSubscript:@"min_pstate"]);
  id v17 = [v16 unsignedIntValue];
  id v18 = (void *)objc_claimAutoreleasedReturnValue([v15 objectForKeyedSubscript:@"mid_pstate"]);
  id v19 = [v18 unsignedIntValue];
  uint64_t v20 = (void *)objc_claimAutoreleasedReturnValue([v15 objectForKeyedSubscript:@"max_pstate"]);
  id v21 = [v20 unsignedIntValue];

  id v15 = v62;
  __int128 v22 = +[NSNumber numberWithUnsignedInt:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedInt:",  RecommendedState(v63, v17 | ((void)v19 << 32), v21));
  uint64_t v23 = (void *)objc_claimAutoreleasedReturnValue(v22);
  [v7 setObject:v23 forKeyedSubscript:@"recommended"];

  uint64_t v24 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInt:](&OBJC_CLASS___NSNumber, "numberWithUnsignedInt:", v17));
  v65[0] = v24;
  uint64_t v25 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInt:](&OBJC_CLASS___NSNumber, "numberWithUnsignedInt:", v19));
  v65[1] = v25;
  uint64_t v26 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInt:](&OBJC_CLASS___NSNumber, "numberWithUnsignedInt:", v21));
  void v65[2] = v26;
  uint64_t v27 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", v65, 3LL));
  [v7 setObject:v27 forKeyedSubscript:@"mapped state"];

  __int128 v28 = (void *)objc_claimAutoreleasedReturnValue([v6 objectForKeyedSubscript:@"level"]);
  unsigned int v29 = [v28 unsignedIntValue];

  switch(v29)
  {
    case 1u:
      id v30 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInt:](&OBJC_CLASS___NSNumber, "numberWithUnsignedInt:", v17));
      [v7 setObject:v30 forKeyedSubscript:@"mapping"];
      goto LABEL_28;
    case 2u:
      id v30 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInt:](&OBJC_CLASS___NSNumber, "numberWithUnsignedInt:", v19));
      [v7 setObject:v30 forKeyedSubscript:@"mapping"];
      goto LABEL_28;
    case 3u:
      id v30 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInt:](&OBJC_CLASS___NSNumber, "numberWithUnsignedInt:", v21));
      [v7 setObject:v30 forKeyedSubscript:@"mapping"];
LABEL_28:

      break;
  }

LABEL_29:
LABEL_30:
LABEL_39:

  return v7;
}

  uint64_t v44 = g_signpostLog;
  int v45 = (os_log_s *)v44;
  if (v49 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled((os_log_t)v44))
  {
    *(_WORD *)buf = 0;
    _os_signpost_emit_with_name_impl( &dword_0,  v45,  OS_SIGNPOST_INTERVAL_END,  spid,  "Replayer-4-parallel",  (const char *)&unk_3189BB,  buf,  2u);
  }
}

  while (2)
  {
    uint64_t v37 = *v14;
    if (!*v14) {
      goto LABEL_1212;
    }
    uint64_t v38 = *(void *)(v37 + 32);
    if (!v38 || (*(_BYTE *)(v38 + 79) & 8) == 0) {
      goto LABEL_1212;
    }
    id v39 = *(_DWORD *)(v38 + 72);
    if (v39 == -7163)
    {
      uint64_t v40 = 30;
      id v43 = GTTraceFunc_argumentBytesWithPool( (uint64_t *)(v38 + 64),  *(unsigned __int8 *)(v38 + 77),  *(void *)(v37 + 24))
          + 8;
    }

    else
    {
      unint64_t v41 = GetFuncEnumConstructorType(*(_DWORD *)(v38 + 72)) - 2;
      if (v41 > 0x51) {
        uint64_t v40 = 255;
      }
      else {
        uint64_t v40 = byte_3182B0[v41];
      }
      unsigned int v42 = *(void *)(v37 + 24);
      if (v39 == -15913 || v39 == -15914) {
        id v43 = GTTraceFunc_argumentBytesWithPool((uint64_t *)(v38 + 64), *(unsigned __int8 *)(v38 + 77), v42) + 16;
      }
      else {
        id v43 = GTTraceFunc_argumentBytesWithPool((uint64_t *)(v38 + 64), *(unsigned __int8 *)(v38 + 77), v42);
      }
    }

    uint64_t v44 = *(void *)v43;
    v1227 = *(void *)v43;
    if (v40 != 29 && v44 != 1)
    {
      int v45 = *find_entry((uint64_t)ht, &v1227, 8uLL, 0LL);
      if (!v45 || !*(void *)(v45 + 32)) {
        goto LABEL_1211;
      }
    }

    v1220 = v14;
    switch((char)v40)
    {
      case 0:
        if (!GTMTLSMBuilder_streamIntersectionRange(v1235, v1236, v37)) {
          goto LABEL_1211;
        }
        memset(__src, 0, 24);
        memset(&__src[8], 0, 32);
        memset(&__src[5], 0, 32);
        *(void *)&__src[2] = 0LL;
        __src[3] = 0u;
        LODWORD(__src[0]) = 22;
        *((void *)&__src[1] + 1) = -1LL;
        WORD1(__src[6]) = 2;
        __src[4] = 0xFFFFFFFFFFFFFFFFLL;
        __src[7] = 0xFFFFFFFFFFFFFFFFLL;
        *((void *)&__src[2] + 1) = v1234;
        LODWORD(v1240) = v1240 + 1;
        uint64_t v46 = *(void *)(v37 + 32);
        if (v46 && (*(_BYTE *)(v46 + 79) & 8) != 0) {
          id v47 = (uint64_t *)(v46 + 64);
        }
        else {
          id v47 = 0LL;
        }
        GTMTLSMBuffer_processTraceFuncWithMap((char *)__src, v1239, v47);
        v812 = *(void *)(v37 + 32);
        if (v812)
        {
          v813 = 0;
          while (1)
          {
            v814 = atomic_load((unsigned int *)(v812 + 4));
            v815 = v813 + (v814 >> 6) - 1;
            v812 = *(void *)(v812 + 40);
            v813 = v815;
            if (!v812)
            {
              v813 = v815;
              goto LABEL_1079;
            }
          }

          v815 = 1LL;
        }

        else
        {
          v813 = 0;
          v815 = 0LL;
        }

void sub_B2594( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11)
{
  _Unwind_Resume(a1);
}

BOOL GTAGXPerfStateControl::IsGPUPerformanceStateInduced(GTAGXPerfStateControl *this)
{
  uint64_t v2 = (void *)*((void *)this + 2);
  if (v2)
  {
    mach_port_t v3 = (void *)objc_claimAutoreleasedReturnValue([v2 getConsistentPerfStateInfoAndReset:1]);
    vm_size_t v4 = v3;
    if (v3)
    {
      id v5 = (id)objc_claimAutoreleasedReturnValue([v3 objectForKeyedSubscript:@"is_enabled"]);
      id v6 = [v5 BOOLValue];
    }

    else
    {
      if (!g_runningInCI)
      {
        id v6 = 0LL;
        goto LABEL_10;
      }

      double v8 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"Error, fail to get consistent perf state status!\n"));
      id v9 = (void *)objc_claimAutoreleasedReturnValue( [v8 stringByReplacingOccurrencesOfString:@"\n" withString:@"\n#CI-ERROR# "]);

      id v10 = __stdoutp;
      id v5 = v9;
      fprintf(v10, "#CI-ERROR# %s\n", (const char *)[v5 UTF8String]);
      id v6 = 0LL;
    }

LABEL_10:
    return (BOOL)v6;
  }

  mach_port_t v7 = *(_DWORD *)this;
  if (!*(_DWORD *)this) {
    return 0LL;
  }
  uint64_t outputStruct = 258LL;
  if (!CallIO<AGXConsistentPerfStateControlRec,AGXConsistentPerfStateControlRec>( v7,  &outputStruct,  &outputStruct,  (uint64_t)"ConsistentPerfState_Get"))
  {
    if (g_runningInCI)
    {
      BOOL v11 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"Error, fail to get consistent perf state status!\n"));
      double v12 = (void *)objc_claimAutoreleasedReturnValue( [v11 stringByReplacingOccurrencesOfString:@"\n" withString:@"\n#CI-ERROR# "]);

      double v13 = __stdoutp;
      id v14 = v12;
      fprintf(v13, "#CI-ERROR# %s\n", (const char *)[v14 UTF8String]);
    }

    return 0LL;
  }

  return BYTE2(outputStruct) == 1;
}

void sub_B2944(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_B29EC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

LABEL_104:
                    uint64_t v100 = (void *)*(v41 - 6);
                    *(v41 - 6) = v92;
                    *(v41 - 5) = v94;
                    *(v41 - 4) = v57;
                    *(v41 - 3) = &v92[8 * v93];
                    if (v100)
                    {
                      operator delete(v100);
                      uint64_t v57 = (char *)*(v41 - 4);
                    }
                  }

                  goto LABEL_107;
                }

                uint64_t v65 = (v48 - v49) >> 3;
                unint64_t v66 = *v45;
                __int128 v67 = (uint64_t)&(*v45)[-*v44];
                if (v65 >= v67 >> 3)
                {
                  else {
                    uint64_t v68 = v67 >> 2;
                  }
                  *(void *)&unint64_t v130 = v41 - 3;
                  *(void *)&uint64_t v128 = std::__allocate_at_least[abi:nn180100]<std::allocator<std::pair<unsigned int,unsigned int>>>(v68);
                  *((void *)&v128 + 1) = v128 + 8 * v65;
                  *(void *)&uint64_t v129 = *((void *)&v128 + 1);
                  *((void *)&v129 + 1) = v128 + 8 * v69;
                  uint64_t v135 = operator new(0x1000uLL);
                  std::__split_buffer<GTMMappedBuffer::UsedBlock *>::push_back(&v128, &v135);
                  uint64_t v70 = *(v41 - 4);
                  uint64_t v71 = (char *)*((void *)&v128 + 1);
                  uint64_t v72 = (char *)v128;
                  char v74 = (char *)*((void *)&v129 + 1);
                  BOOL v73 = (char *)v129;
                  while (v70 != *(v41 - 5))
                  {
                    if (v71 == v72)
                    {
                      if (v73 >= v74)
                      {
                        if (v74 == v72) {
                          __int128 v80 = 1LL;
                        }
                        else {
                          __int128 v80 = (v74 - v72) >> 2;
                        }
                        uint64_t v81 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<std::pair<unsigned int,unsigned int>>>(v80);
                        uint64_t v83 = v81;
                        uint64_t v71 = &v81[(2 * v80 + 6) & 0xFFFFFFFFFFFFFFF8LL];
                        __int128 v84 = v73 - v72;
                        __int128 v78 = v73 == v72;
                        BOOL v73 = v71;
                        if (!v78)
                        {
                          BOOL v73 = &v71[v84 & 0xFFFFFFFFFFFFFFF8LL];
                          id v85 = 8 * (v84 >> 3);
                          BOOL v86 = v71;
                          unint64_t v87 = v72;
                          do
                          {
                            BOOL v88 = *(void *)v87;
                            v87 += 8;
                            *(void *)BOOL v86 = v88;
                            v86 += 8;
                            v85 -= 8LL;
                          }

                          while (v85);
                        }

                        char v74 = &v81[8 * v82];
                        if (v72) {
                          operator delete(v72);
                        }
                        uint64_t v72 = v83;
                      }

                      else
                      {
                        id v75 = (v74 - v73) >> 3;
                        if (v75 >= -1) {
                          __int128 v76 = v75 + 1;
                        }
                        else {
                          __int128 v76 = v75 + 2;
                        }
                        BOOL v77 = &v73[8 * (v76 >> 1)];
                        uint64_t v71 = &v77[-(v73 - v72)];
                        unint64_t v79 = v73 - v72;
                        __int128 v78 = v73 == v72;
                        BOOL v73 = v77;
                        if (!v78) {
                          memmove(v71, v72, v79);
                        }
                      }
                    }

                    uint64_t v89 = *(void *)(v70 - 8);
                    v70 -= 8LL;
                    *((void *)v71 - 1) = v89;
                    v71 -= 8;
                  }

                  *(void *)&uint64_t v128 = v72;
                  *((void *)&v128 + 1) = v71;
                  *(void *)&uint64_t v129 = v73;
                  *((void *)&v129 + 1) = v74;
                  id v90 = (void *)*(v41 - 6);
                  *((_OWORD *)v41 - 3) = v128;
                  *((_OWORD *)v41 - 2) = v129;
                  if (v90) {
                    operator delete(v90);
                  }
                  p_batchToEncoderMap = v118;
                  double v8 = v119;
                  uint64_t v44 = v41 - 6;
                  unsigned int v42 = v120;
                }

                else if (v66 == v48)
                {
                  *(void *)&uint64_t v128 = operator new(0x1000uLL);
                  std::__split_buffer<GTMMappedBuffer::UsedBlock *>::push_front((uint64_t)v44, &v128);
                  id v101 = (void *)*(v41 - 5);
                  uint64_t v57 = (char *)*(v41 - 4);
                  uint64_t v102 = *v101;
                  unint64_t v54 = (char *)(v101 + 1);
                  uint64_t v55 = v102;
                  *(v41 - 5) = v54;
                  if (v57 == (char *)*(v41 - 3))
                  {
                    uint64_t v58 = (uint64_t)&v54[-*v44];
                    if ((unint64_t)v54 <= *v44)
                    {
                      else {
                        unint64_t v103 = (uint64_t)&v57[-*v44] >> 2;
                      }
                      int64_t v92 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<std::pair<unsigned int,unsigned int>>>(v103);
                      id v94 = &v92[8 * (v103 >> 2)];
                      int v104 = (uint64_t *)*(v41 - 5);
                      uint64_t v57 = v94;
                      uint64_t v105 = *(v41 - 4) - (void)v104;
                      if (v105)
                      {
                        uint64_t v57 = &v94[v105 & 0xFFFFFFFFFFFFFFF8LL];
                        uint64_t v106 = 8 * (v105 >> 3);
                        uint64_t v107 = &v92[8 * (v103 >> 2)];
                        do
                        {
                          id v108 = *v104++;
                          *(void *)uint64_t v107 = v108;
                          v107 += 8;
                          v106 -= 8LL;
                        }

                        while (v106);
                      }

                      goto LABEL_104;
                    }

LABEL_107:
                  *(void *)uint64_t v57 = v55;
                  *(v41 - 4) += 8LL;
                }

                else
                {
                  *(void *)&uint64_t v128 = operator new(0x1000uLL);
                  std::__split_buffer<GTMMappedBuffer::UsedBlock *>::push_back(v44, &v128);
                }

                uint64_t v49 = (char *)*(v41 - 5);
                id v51 = *(v41 - 1);
                id v53 = *(v41 - 2) + v51;
              }

              *(_DWORD *)(*(void *)&v49[(v53 >> 7) & 0x1FFFFFFFFFFFFF8LL] + 4 * (v53 & 0x3FF)) = v47;
              *(v41 - 1) = v51 + 1;
              LODWORD(v12_Block_object_dispose(va, 8) = v123;
              mach_port_t v7 = v123 + 1;
              *((_DWORD *)std::__hash_table<std::__hash_value_type<unsigned int,unsigned int>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,unsigned int>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int &&>,std::tuple<>>( (uint64_t)p_batchToEncoderMap,  v123,  &v128)
              + 5) = v8;
              uint64_t v46 = (char *)v46 + 1;
            }

            while (v46 != v122);
            __int8 v109 = [v42 countByEnumeratingWithState:&v124 objects:v136 count:16];
            id v43 = v109;
          }

          while (v109);
        }

        ++v8;
        uint64_t v117 = (char *)v117 + 1;
        self = v114;
      }

      while (v117 != v116);
      uint64_t v110 = [obj countByEnumeratingWithState:&v131 objects:v137 count:16];
      uint64_t v116 = v110;
    }

    while (v110);
  }

  gInitialized = 1;
}

          uint64_t v23 = v113;
LABEL_108:
          if (-[NSMutableArray count](v129, "count", v110))
          {
            uint64_t v117 = v19;
            if (*v23 >> 2 == 1073737833)
            {
              GetExecuteCommandsInBufferArgs((uint64_t)&v130, *(void *)(v7 + 24) + (v18 << 6), *(void *)(v16 + 16));
              id v90 = GTMTLSMContext_getObject(**(void **)(v16 + 40), v130, *v125);
              GTMTLCreateIndirectCommandEncoder((uint64_t)v110, v90[13]);
              uint64_t v91 = v132;
              if (v132)
              {
                int64_t v92 = 0LL;
                int v93 = v136;
                id v94 = v131 << 32;
                int v95 = (void *)(v133 + v135[1] + v136 * v131);
                do
                {
                  if (*v95)
                  {
                    uint64_t v96 = v18;
                    unint64_t v97 = v94 | v18;
                    unsigned __int32 v98 = _processThumbnailAttachments(v124, v129, v97);
                    unint64_t v99 = (void *)objc_claimAutoreleasedReturnValue(v98);
                    uint64_t v100 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  v97));
                    -[NSMutableDictionary setObject:forKeyedSubscript:](v123, "setObject:forKeyedSubscript:", v99, v100);

                    id v18 = v96;
                  }

                  int v95 = (void *)((char *)v95 + v93);
                  ++v92;
                  v94 += 0x100000000LL;
                }

                while (v91 > v92);
              }

              uint64_t v16 = (uint64_t)v122;
              id v17 = v115;
              mach_port_t v7 = v120;
            }

            else
            {
              id v101 = _processThumbnailAttachments(v124, v129, v18);
              uint64_t v102 = v18;
              unint64_t v103 = (void *)objc_claimAutoreleasedReturnValue(v101);
              int v104 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", v102));
              -[NSMutableDictionary setObject:forKeyedSubscript:](v123, "setObject:forKeyedSubscript:", v103, v104);

              id v18 = v102;
            }

            id v19 = v117;
          }

          goto LABEL_118;
        }

              *(void *)unint64_t v79 = *(void *)v78;
            }

            while (v75 <= (uint64_t)((unint64_t)(v76 - 2) >> 1));
            id v94 = v60 - 8;
            if (v78 == v60 - 8)
            {
              *(void *)__int128 v78 = v77;
            }

            else
            {
              *(void *)__int128 v78 = *(void *)v94;
              *(void *)id v94 = v77;
              std::__sift_up[abi:nn180100]<std::_ClassicAlgPolicy,GRCFrameTimeData::ProcessSingleFrameData(NSArray<NSData *> *,std::unordered_set<unsigned int> const&)::$_0 &,std::__wrap_iter<GRCFrameTimeData::ProcessSingleFrameData(NSArray<NSData *> *,std::unordered_set<unsigned int> const&)::PriorityQueueElement *>>( (uint64_t)v59,  (uint64_t)(v78 + 8),  (uint64_t **)&p_p,  (v78 + 8 - v59) >> 3);
            }

void sub_B3408( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, void *__p)
{
}

void sub_B3624(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_B3998( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9, void *a10, void *a11, void *a12)
{
}

void sub_B3BD4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t std::deque<unsigned int>::~deque[abi:nn180100](uint64_t a1)
{
  uint64_t v2 = *(void ***)(a1 + 8);
  mach_port_t v3 = *(void ***)(a1 + 16);
  *(void *)(a1 + 40) = 0LL;
  unint64_t v4 = (char *)v3 - (char *)v2;
  if ((unint64_t)((char *)v3 - (char *)v2) >= 0x11)
  {
    do
    {
      operator delete(*v2);
      mach_port_t v3 = *(void ***)(a1 + 16);
      uint64_t v2 = (void **)(*(void *)(a1 + 8) + 8LL);
      *(void *)(a1 + _Block_object_dispose(va, 8) = v2;
      unint64_t v4 = (char *)v3 - (char *)v2;
    }

    while ((unint64_t)((char *)v3 - (char *)v2) > 0x10);
  }

  unint64_t v5 = v4 >> 3;
  if (v5 == 1)
  {
    uint64_t v6 = 512LL;
    goto LABEL_7;
  }

  if (v5 == 2)
  {
    uint64_t v6 = 1024LL;
LABEL_7:
    *(void *)(a1 + 32) = v6;
  }

  if (v2 != v3)
  {
    do
    {
      mach_port_t v7 = *v2++;
      operator delete(v7);
    }

    while (v2 != v3);
    uint64_t v9 = *(void *)(a1 + 8);
    uint64_t v8 = *(void *)(a1 + 16);
    if (v8 != v9) {
      *(void *)(a1 + 16) = v8 + ((v9 - v8 + 7) & 0xFFFFFFFFFFFFFFF8LL);
    }
  }

  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void std::vector<std::pair<NSDictionary * {__strong},NSArray * {__strong}>>::__base_destruct_at_end[abi:nn180100]( uint64_t a1, uint64_t a2)
{
  for (uint64_t i = *(void *)(a1 + 8); i != a2; i -= 16LL)
  {

    unint64_t v5 = *(void **)(i - 16);
  }

  *(void *)(a1 + _Block_object_dispose(va, 8) = a2;
}

void std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__emplace_unique_key_args<unsigned int,unsigned int const&>( uint64_t a1, unsigned int a2, int a3)
{
  unint64_t v6 = a2;
  unint64_t v7 = *(void *)(a1 + 8);
  if (v7)
  {
    uint8x8_t v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      unint64_t v3 = a2;
      if (v7 <= a2) {
        unint64_t v3 = a2 % v7;
      }
    }

    else
    {
      unint64_t v3 = ((_DWORD)v7 - 1) & a2;
    }

    uint64_t v9 = *(uint64_t ***)(*(void *)a1 + 8 * v3);
    if (v9)
    {
      for (uint64_t i = *v9; i; uint64_t i = (uint64_t *)*i)
      {
        unint64_t v11 = i[1];
        if (v11 == a2)
        {
          if (*((_DWORD *)i + 4) == a2) {
            return;
          }
        }

        else
        {
          if (v8.u32[0] > 1uLL)
          {
            if (v11 >= v7) {
              v11 %= v7;
            }
          }

          else
          {
            v11 &= v7 - 1;
          }

          if (v11 != v3) {
            break;
          }
        }
      }
    }
  }

  double v12 = operator new(0x18uLL);
  void *v12 = 0LL;
  v12[1] = v6;
  *((_DWORD *)v12 + 4) = a3;
  float v13 = (float)(unint64_t)(*(void *)(a1 + 24) + 1LL);
  float v14 = *(float *)(a1 + 32);
  if (!v7 || (float)(v14 * (float)v7) < v13)
  {
    BOOL v15 = 1LL;
    if (v7 >= 3) {
      BOOL v15 = (v7 & (v7 - 1)) != 0;
    }
    unint64_t v16 = v15 | (2 * v7);
    unint64_t v17 = vcvtps_u32_f32(v13 / v14);
    if (v16 <= v17) {
      size_t v18 = v17;
    }
    else {
      size_t v18 = v16;
    }
    std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__rehash<true>( a1,  v18);
    unint64_t v7 = *(void *)(a1 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v7 <= v6) {
        unint64_t v3 = v6 % v7;
      }
      else {
        unint64_t v3 = v6;
      }
    }

    else
    {
      unint64_t v3 = ((_DWORD)v7 - 1) & v6;
    }
  }

  uint64_t v19 = *(void *)a1;
  uint64_t v20 = *(void **)(*(void *)a1 + 8 * v3);
  if (v20)
  {
    void *v12 = *v20;
LABEL_38:
    *uint64_t v20 = v12;
    goto LABEL_39;
  }

  void *v12 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = v12;
  *(void *)(v19 + 8 * v3) = a1 + 16;
  if (*v12)
  {
    unint64_t v21 = *(void *)(*v12 + 8LL);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v21 >= v7) {
        v21 %= v7;
      }
    }

    else
    {
      v21 &= v7 - 1;
    }

    uint64_t v20 = (void *)(*(void *)a1 + 8 * v21);
    goto LABEL_38;
  }

void sub_B4034(_Unwind_Exception *a1)
{
}

void std::deque<unsigned int>::__maybe_remove_front_spare[abi:nn180100](uint64_t a1)
{
  if (*(void *)(a1 + 32) >= 0x800uLL)
  {
    operator delete(**(void ***)(a1 + 8));
    *(void *)(a1 + 8) += 8LL;
    *(void *)(a1 + 32) -= 1024LL;
  }

void TranslateGTMTLArgument(uint64_t a1, void *a2, void *a3, uint64_t a4)
{
  id v60 = a2;
  id v7 = objc_claimAutoreleasedReturnValue([v60 name]);
  id v8 = [v7 UTF8String];
  id v9 = objc_claimAutoreleasedReturnValue([v60 name]);
  if ([v9 UTF8String])
  {
    id v10 = objc_claimAutoreleasedReturnValue([v60 name]);
    size_t v11 = strlen((const char *)[v10 UTF8String]);
    size_t v12 = v11 + 1;
    if (v11 == -1LL) {
      float v13 = 0LL;
    }
    else {
      float v13 = (void *)a3[23];
    }
    a3[23] += v12;
    if ((_DWORD)a4) {
      memcpy(v13, v8, v12);
    }
  }

  else
  {
    float v13 = 0LL;
  }

  unsigned __int8 v14 = [v60 access];
  unsigned __int8 v15 = [v60 isActive];
  unsigned __int8 v16 = [v60 index];
  unsigned __int8 v17 = [v60 type];
  size_t v18 = (int *)[v60 type];
  uint64_t v19 = 0LL;
  unsigned __int16 v20 = 0;
  unsigned __int8 v58 = v14;
  __int128 v59 = v13;
  unsigned __int8 v57 = v16;
  unsigned __int8 v56 = v15;
  unsigned __int8 v55 = v17;
  if ((uint64_t)v18 > 15)
  {
    if (v18 == &dword_10)
    {
      id v43 = v60;
      uint64_t v44 = [v43 imageBlockDataSize];
      unint64_t v45 = v44 & 0xFFFFFF00FFFFFFFFLL | ((unint64_t)[v43 aliasImplicitImageBlockRenderTarget] << 32);
      unsigned int v46 = [v43 aliasImplicitImageBlock];
      uint64_t v47 = 0x10000000000LL;
      if (!v46) {
        uint64_t v47 = 0LL;
      }
      uint64_t v23 = v45 | v47;
      BOOL v48 = (void *)objc_claimAutoreleasedReturnValue([v43 imageBlockMasterStructMembers]);
      if (!v48)
      {
LABEL_37:
        uint64_t v49 = (void *)objc_claimAutoreleasedReturnValue([v43 dataTypeDescription]);
        uint64_t v25 = TranslateGTMTLType(v49, a3, a4);
        unint64_t v24 = 0LL;
LABEL_38:

        unsigned __int16 v20 = 0;
        unsigned __int16 v21 = 0;
        unsigned __int8 v22 = 0;
        uint64_t v19 = 0LL;
        if (!(_DWORD)a4) {
          goto LABEL_29;
        }
        goto LABEL_28;
      }
    }

    else
    {
      if (v18 != (int *)((char *)&dword_10 + 1))
      {
        unsigned __int16 v21 = 0;
        unsigned __int8 v22 = 0;
        uint64_t v23 = 0LL;
        unint64_t v24 = 0LL;
        uint64_t v25 = 0LL;
        if (v18 == (int *)((char *)&stru_20.cmd + 3))
        {
          id v31 = v60;
          uint64_t v32 = (void *)objc_claimAutoreleasedReturnValue([v31 meshVertexStruct]);
          uint64_t v23 = TranslateGTMTLStructType(v32, a3, a4);

          unsigned __int8 v33 = (void *)objc_claimAutoreleasedReturnValue([v31 meshPrimitiveStruct]);
          uint64_t v19 = TranslateGTMTLStructType(v33, a3, a4);

          unsigned __int16 v20 = (unsigned __int16)[v31 meshVertexCount];
          unsigned __int16 v21 = (unsigned __int16)[v31 meshPrimitiveCount];
          unsigned __int8 v22 = [v31 meshTopologyType];
          uint64_t v34 = [v31 builtInType];
          unsigned __int8 v35 = [v31 builtInDataType];

          uint64_t v25 = 0LL;
          unint64_t v24 = v34 & 0xFFFFFFFFFFFF00FFLL | ((unint64_t)v35 << 8);
          if (!(_DWORD)a4) {
            goto LABEL_29;
          }
          goto LABEL_28;
        }

        goto LABEL_27;
      }

      id v43 = v60;
      unsigned __int8 v50 = [v43 imageBlockKind];
      unint64_t v51 = [v43 imageBlockDataSize] | ((unint64_t)v50 << 48);
      unint64_t v52 = v51 & 0xFFFFFF00FFFFFFFFLL | ((unint64_t)[v43 aliasImplicitImageBlockRenderTarget] << 32);
      unsigned int v53 = [v43 aliasImplicitImageBlock];
      uint64_t v54 = 0x10000000000LL;
      if (!v53) {
        uint64_t v54 = 0LL;
      }
      uint64_t v23 = v52 | v54;
      BOOL v48 = (void *)objc_claimAutoreleasedReturnValue([v43 dataTypeDescription]);
      if (v48) {
        goto LABEL_37;
      }
    }

    uint64_t v49 = (void *)objc_claimAutoreleasedReturnValue([v43 imageBlockMasterStructMembers]);
    unint64_t v24 = TranslateGTMTLStructType(v49, a3, a4);
    uint64_t v25 = 0LL;
    goto LABEL_38;
  }

  if (!v18)
  {
    unsigned __int16 v36 = (unsigned __int16)[v60 bufferAlignment];
    unint64_t v37 = [v60 bufferDataSize] | ((unint64_t)v36 << 32);
    unint64_t v38 = v37 & 0xFF00FFFFFFFFFFFFLL | ((unint64_t)[v60 bufferDataType] << 48);
    unsigned int v39 = [v60 isVertexDescriptorBuffer];
    uint64_t v40 = 0x100000000000000LL;
    if (!v39) {
      uint64_t v40 = 0LL;
    }
    unint64_t v24 = v38 | v40;
    goto LABEL_26;
  }

  if (v18 == (int *)((char *)&dword_0 + 1))
  {
    unsigned __int16 v41 = (unsigned __int16)[v60 threadgroupMemoryAlignment];
    unint64_t v24 = [v60 threadgroupMemoryDataSize] | ((unint64_t)v41 << 32);
LABEL_26:
    unsigned int v42 = (void *)objc_claimAutoreleasedReturnValue([v60 dataTypeDescription]);
    uint64_t v25 = TranslateGTMTLType(v42, a3, a4);

    unsigned __int16 v20 = 0;
    unsigned __int16 v21 = 0;
    unsigned __int8 v22 = 0;
    uint64_t v19 = 0LL;
    uint64_t v23 = 0LL;
LABEL_27:
    if (!(_DWORD)a4) {
      goto LABEL_29;
    }
LABEL_28:
    *(void *)a1 = v59;
    *(void *)(a1 + _Block_object_dispose(va, 8) = v25;
    *(_BYTE *)(a1 + 16) = v55;
    *(_BYTE *)(a1 + 17) = v58;
    *(_BYTE *)(a1 + 1_Block_object_dispose(va, 8) = v57;
    *(_BYTE *)(a1 + 19) = v56 | 2;
    *(_DWORD *)(a1 + 20) = 0;
    *(void *)(a1 + 24) = v24;
    *(void *)(a1 + 32) = v23;
    *(void *)(a1 + 40) = v19;
    *(_WORD *)(a1 + 4_Block_object_dispose(va, 8) = v20;
    *(_WORD *)(a1 + 50) = v21;
    *(_BYTE *)(a1 + 52) = v22;
    *(_WORD *)(a1 + 53) = 0;
    *(_BYTE *)(a1 + 55) = 0;
    goto LABEL_29;
  }

  unsigned __int16 v21 = 0;
  unsigned __int8 v22 = 0;
  uint64_t v23 = 0LL;
  unint64_t v24 = 0LL;
  uint64_t v25 = 0LL;
  unsigned __int8 v26 = [v60 textureDataType];
  unint64_t v27 = [v60 textureType] | ((unint64_t)v26 << 8);
  unint64_t v28 = v27 & 0xFFFFFFFFFF00FFFFLL | ((unint64_t)[v60 arrayLength] << 16);
  unsigned int v29 = [v60 isDepthTexture];
  unsigned __int16 v20 = 0;
  unsigned __int16 v21 = 0;
  unsigned __int8 v22 = 0;
  uint64_t v19 = 0LL;
  uint64_t v23 = 0LL;
  uint64_t v25 = 0LL;
  uint64_t v30 = 0x1000000LL;
  if (!v29) {
    uint64_t v30 = 0LL;
  }
  unint64_t v24 = v28 | v30;
  if ((_DWORD)a4) {
    goto LABEL_28;
  }
LABEL_29:
}

uint64_t TranslateGTMTLType(void *a1, void *a2, uint64_t a3)
{
  id v5 = a1;
  unint64_t v6 = v5;
  if (v5)
  {
    id v7 = (char *)[v5 dataType];
    uint64_t v8 = 0LL;
    if ((uint64_t)v7 > 57)
    {
      if (v7 == (_BYTE *)&stru_20.vmaddr + 2)
      {
        uint64_t v8 = a2[19];
        a2[19] = v8 + 16;
        if ((_DWORD)a3)
        {
          *(_BYTE *)uint64_t v8 = 58;
          id v14 = v6;
          *(_BYTE *)(v8 + 10) = [v14 access];
          *(_BYTE *)(v8 + _Block_object_dispose(va, 8) = [v14 textureDataType];
          unsigned __int8 v15 = [v14 textureType];

          *(_BYTE *)(v8 + 9) = v15;
        }
      }

      else if (v7 == (_BYTE *)&stru_20.vmaddr + 4)
      {
        id v9 = v6;
        uint64_t v8 = a2[15];
        a2[15] = v8 + 24;
        size_t v12 = (void *)objc_claimAutoreleasedReturnValue([v9 elementTypeDescription]);
        uint64_t v13 = TranslateGTMTLType(v12, a2, a3);

        if ((_DWORD)a3)
        {
          *(_BYTE *)uint64_t v8 = 60;
          *(_BYTE *)(v8 + 23) = [v9 access];
          *(_WORD *)(v8 + 20) = (unsigned __int16)[v9 alignment];
          *(_DWORD *)(v8 + 16) = [v9 dataSize];
          *(_BYTE *)(v8 + 22) = [v9 elementType];
          *(void *)(v8 + _Block_object_dispose(va, 8) = v13;
        }

        goto LABEL_13;
      }
    }

    else
    {
      if (v7 == (_BYTE *)&dword_0 + 1)
      {
        uint64_t v8 = TranslateGTMTLStructType(v6, a2, a3);
        goto LABEL_17;
      }

      if (v7 == (_BYTE *)&dword_0 + 2)
      {
        id v9 = v6;
        uint64_t v8 = a2[18];
        a2[18] = v8 + 32;
        id v10 = (void *)objc_claimAutoreleasedReturnValue([v9 elementTypeDescription]);
        uint64_t v11 = TranslateGTMTLType(v10, a2, a3);

        if ((_DWORD)a3)
        {
          *(_BYTE *)uint64_t v8 = 2;
          *(_WORD *)(v8 + 20) = (unsigned __int16)[v9 arrayLength];
          *(_BYTE *)(v8 + 24) = [v9 elementType];
          *(_DWORD *)(v8 + 16) = [v9 stride];
          *(_WORD *)(v8 + 22) = (unsigned __int16)[v9 argumentIndexStride];
          *(void *)(v8 + _Block_object_dispose(va, 8) = v11;
          if ((objc_opt_respondsToSelector(v9, "aluType") & 1) != 0) {
            *(_BYTE *)(v8 + 25) = [v9 aluType];
          }
        }

uint64_t TranslateGTMTLStructType(void *a1, void *a2, uint64_t a3)
{
  id v5 = a1;
  unint64_t v6 = v5;
  if (v5)
  {
    uint64_t v7 = a2[16];
    uint64_t v8 = a2[17];
    a2[16] = v7 + 24;
    id v9 = (void *)objc_claimAutoreleasedReturnValue([v5 members]);
    a2[17] += 32 * (void)[v9 count];

    __int128 v36 = 0u;
    __int128 v37 = 0u;
    __int128 v34 = 0u;
    __int128 v35 = 0u;
    obunint64_t j = (id)objc_claimAutoreleasedReturnValue([v6 members]);
    id v33 = [obj countByEnumeratingWithState:&v34 objects:v38 count:16];
    if (v33)
    {
      uint64_t v27 = v7;
      unint64_t v28 = v6;
      int v10 = 0;
      uint64_t v32 = *(void *)v35;
      uint64_t v26 = v8;
      uint64_t v29 = v8 + 25;
      do
      {
        uint64_t v11 = 0LL;
        int v30 = v10;
        size_t v12 = (_BYTE *)(v29 + 32LL * v10);
        do
        {
          if (*(void *)v35 != v32) {
            objc_enumerationMutation(obj);
          }
          id v13 = *(id *)(*((void *)&v34 + 1) + 8LL * (void)v11);
          id v14 = objc_claimAutoreleasedReturnValue([v13 name]);
          id v15 = [v14 UTF8String];
          id v16 = objc_claimAutoreleasedReturnValue([v13 name]);
          if ([v16 UTF8String])
          {
            id v17 = objc_claimAutoreleasedReturnValue([v13 name]);
            size_t v18 = strlen((const char *)[v17 UTF8String]);
            size_t v19 = v18 + 1;
            if (v18 == -1LL) {
              unsigned __int16 v20 = 0LL;
            }
            else {
              unsigned __int16 v20 = (void *)a2[23];
            }
            a2[23] += v19;
            if ((_DWORD)a3) {
              memcpy(v20, v15, v19);
            }
          }

          else
          {
            unsigned __int16 v20 = 0LL;
          }

          unsigned __int16 v21 = (void *)objc_claimAutoreleasedReturnValue([v13 dataTypeDescription]);
          uint64_t v22 = TranslateGTMTLType(v21, a2, a3);

          if ((_DWORD)a3)
          {
            *(void *)(v12 - 25) = v20;
            *(_DWORD *)(v12 - 9) = [v13 offset];
            *(v12 - 1) = [v13 dataType];
            *(_WORD *)(v12 - 5) = (unsigned __int16)[v13 argumentIndex];
            *(_WORD *)(v12 - 3) = (unsigned __int16)[v13 indirectArgumentIndex];
            *(void *)(v12 - 17) = v22;
            if ((objc_opt_respondsToSelector(v13, "aluType") & 1) != 0)
            {
              id v23 = v13;
              _BYTE *v12 = [v23 aluType];
            }
          }

          uint64_t v11 = (char *)v11 + 1;
          v12 += 32;
        }

        while (v33 != v11);
        int v10 = v30 + (_DWORD)v11;
        id v33 = [obj countByEnumeratingWithState:&v34 objects:v38 count:16];
      }

      while (v33);
      uint64_t v7 = v27;
      unint64_t v6 = v28;
      uint64_t v8 = v26;
    }

    else
    {
      int v10 = 0;
    }

    if ((_DWORD)a3)
    {
      *(_BYTE *)uint64_t v7 = 1;
      if (v10) {
        uint64_t v24 = v8;
      }
      else {
        uint64_t v24 = 0LL;
      }
      *(void *)(v7 + _Block_object_dispose(va, 8) = v24;
      *(_DWORD *)(v7 + 16) = v10;
    }
  }

  else
  {
    uint64_t v7 = 0LL;
  }

  return v7;
}

void sub_B4C38(_Unwind_Exception *a1)
{
  unint64_t v4 = v3;

  _Unwind_Resume(a1);
}

void sub_B4CB4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_B4D10(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_B4E30( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, _Unwind_Exception *exception_object, char a10)
{
  for (uint64_t i = 24LL; i != -8; i -= 8LL)
  _Unwind_Resume(a1);
}

void sub_B5978( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, uint64_t a14, void *a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, uint64_t a41, uint64_t a42, void *a43, uint64_t a44, char a45, uint64_t a46, uint64_t a47, uint64_t a48, uint64_t a49, uint64_t a50,uint64_t a51,uint64_t a52,char a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  a68 = (void **)&a45;
  std::vector<std::unordered_map<unsigned int,GTEncoderSampleIndexInfo>>::__destroy_vector::operator()[abi:nn180100](&a68);
  std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long>>>::~__hash_table((uint64_t)&a53);

  _Unwind_Resume(a1);
}

void sub_B5D20(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

LABEL_113:
      id v9 = v107 + 1;
    }

    while (v107 + 1 < nelts);
  }

  if ((objc_opt_respondsToSelector(v6, "buildDrawCallIndexMap") & 1) != 0) {
    [v6 buildDrawCallIndexMap];
  }
  std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long>>>::~__hash_table((uint64_t)&v132);
  return v6;
}

                  *id v60 = v58;
                  v60[1] = v57;
                }

                uint64_t v49 = v53 + 2;
                v52 += 8LL;
              }

              while (v53 + 2 != a2);
            }
          }

          else if (!v51)
          {
            do
            {
              __int128 v80 = v7;
              uint64_t v7 = v49;
              uint64_t v81 = v80[2];
              unint64_t v82 = *v80;
              if (v81 < *v80 || v82 >= v81 && v80[3] < v80[1])
              {
                uint64_t v83 = *v49;
                __int128 v84 = v49[1];
                do
                {
                  do
                  {
                    id v85 = v80;
                    BOOL v86 = *(v80 - 2);
                    v80 -= 2;
                    unint64_t v87 = v80[3];
                    v80[4] = v82;
                    v80[5] = v87;
                    unint64_t v82 = v86;
                    BOOL v88 = v86 >= v83;
                  }

                  while (v86 > v83);
                }

                while (v88 && *(v85 - 1) > v84);
                unsigned __int8 *v85 = v83;
                v85[1] = v84;
              }

              uint64_t v49 = v7 + 2;
            }

            while (v7 + 2 != a2);
          }

          return result;
        }

        if (!a3)
        {
          if (i != a2)
          {
            uint64_t v65 = (v11 - 2) >> 1;
            unint64_t v66 = v65;
            do
            {
              __int128 v67 = v66;
              if (v65 >= v66)
              {
                uint64_t v68 = (2 * v66) | 1;
                uint64_t v69 = &i[2 * v68];
                if (2 * v67 + 2 < (uint64_t)v11)
                {
                  uint64_t v70 = v69[2];
                  if (*v69 < v70 || v70 >= *v69 && i[2 * v68 + 1] < v69[3])
                  {
                    v69 += 2;
                    uint64_t v68 = 2 * v67 + 2;
                  }
                }

                uint64_t v71 = &i[2 * v67];
                uint64_t v72 = *v69;
                if (*v69 >= *v71 && (*v71 < v72 || v69[1] >= i[2 * v67 + 1]))
                {
                  __n128 result = (unint64_t)&i[2 * v67];
                  BOOL v73 = *(_DWORD *)result;
                  char v74 = *(_DWORD *)(result + 4);
                  void *v71 = v72;
                  *(_DWORD *)(result + 4) = v69[1];
                  if (v65 >= v68)
                  {
                    while (1)
                    {
                      __int128 v76 = 2 * v68;
                      uint64_t v68 = (2 * v68) | 1;
                      id v75 = &i[2 * v68];
                      BOOL v77 = v76 + 2;
                      if (v77 < (uint64_t)v11)
                      {
                        __n128 result = (unint64_t)(v75 + 2);
                        __int128 v78 = v75[2];
                        if (*v75 < v78 || v78 >= *v75 && i[2 * v68 + 1] < v75[3])
                        {
                          v75 += 2;
                          uint64_t v68 = v77;
                        }
                      }

                      unint64_t v79 = *v75;
                      if (*v75 < v73) {
                        break;
                      }
                      if (v79 <= v73)
                      {
                        __n128 result = v75[1];
                      }

                      *uint64_t v69 = v79;
                      v69[1] = v75[1];
                      uint64_t v69 = v75;
                      if (v65 < v68) {
                        goto LABEL_129;
                      }
                    }
                  }

                  id v75 = v69;
LABEL_129:
                  void *v75 = v73;
                  v75[1] = v74;
                }
              }

              unint64_t v66 = v67 - 1;
            }

            while (v67);
            uint64_t v89 = (unint64_t)v10 >> 3;
            do
            {
              id v90 = 0LL;
              uint64_t v91 = *(void *)i;
              int64_t v92 = v89 - 2;
              if (v89 < 2) {
                int64_t v92 = v89 - 1;
              }
              int v93 = v92 >> 1;
              id v94 = i;
              do
              {
                int v95 = v94;
                uint64_t v96 = v90 + 1;
                v94 += 2 * v90 + 2;
                unint64_t v97 = 2 * v90;
                id v90 = (2 * v90) | 1;
                unsigned __int32 v98 = v97 + 2;
                if (v98 < v89)
                {
                  __n128 result = v94[2];
                  if (*v94 < result
                    || result >= *v94 && (__n128 result = v94[3], v95[2 * v96 + 1] < result))
                  {
                    v94 += 2;
                    id v90 = v98;
                  }
                }

                *int v95 = *v94;
                v95[1] = v94[1];
              }

              while (v90 <= v93);
              if (v94 == a2 - 2)
              {
                *(void *)id v94 = v91;
              }

              else
              {
                *id v94 = *(a2 - 2);
                v94[1] = *(a2 - 1);
                *((void *)a2 - 1) = v91;
                unint64_t v99 = (char *)v94 - (char *)i + 8;
                if (v99 >= 9)
                {
                  uint64_t v100 = (v99 >> 3) - 2;
                  id v101 = v100 >> 1;
                  uint64_t v102 = &i[2 * (v100 >> 1)];
                  unint64_t v103 = *v102;
                  if (*v102 < *v94 || *v94 >= v103 && i[2 * v101 + 1] < v94[1])
                  {
                    int v104 = *v94;
                    uint64_t v105 = v94[1];
                    *id v94 = v103;
                    v94[1] = v102[1];
                    if (v100 >= 2)
                    {
                      while (1)
                      {
                        uint64_t v107 = v101 - 1;
                        id v101 = (v101 - 1) >> 1;
                        uint64_t v106 = &i[2 * v101];
                        id v108 = *v106;
                        if (*v106 >= v104)
                        {
                          if (v108 > v104) {
                            break;
                          }
                          __n128 result = i[2 * v101 + 1];
                        }

                        else
                        {
                          __n128 result = v106[1];
                        }

                        void *v102 = v108;
                        v102[1] = result;
                        uint64_t v102 = &i[2 * v101];
                        if (v107 <= 1) {
                          goto LABEL_176;
                        }
                      }
                    }

                    uint64_t v106 = v102;
LABEL_176:
                    *uint64_t v106 = v104;
                    v106[1] = v105;
                  }
                }
              }

              a2 -= 2;
              int v30 = v89-- <= 2;
            }

            while (!v30);
          }

          return result;
        }

        size_t v12 = v11 >> 1;
        id v13 = &i[2 * (v11 >> 1)];
        if ((unint64_t)v10 < 0x401)
        {
          __n128 result = (unint64_t)std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned int,unsigned int> *>( &v7[2 * (v11 >> 1)],  v7,  a2 - 2);
        }

        else
        {
          std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned int,unsigned int> *>( v7,  &v7[2 * (v11 >> 1)],  a2 - 2);
          std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned int,unsigned int> *>( v7 + 2,  v13 - 2,  a2 - 4);
          std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned int,unsigned int> *>( v7 + 4,  &v7[2 * v12 + 2],  a2 - 6);
          __n128 result = (unint64_t)std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned int,unsigned int> *>( v13 - 2,  v13,  &v7[2 * v12 + 2]);
          id v14 = *(void *)v7;
          *(void *)uint64_t v7 = *(void *)v13;
          *(void *)id v13 = v14;
        }

        --a3;
        if ((a4 & 1) == 0)
        {
          id v15 = *(v7 - 2);
          if (v15 >= *v7 && (*v7 < v15 || *(v7 - 1) >= v7[1]))
          {
            __int128 v34 = *v7;
            id v33 = v7[1];
            __int128 v35 = *v8;
            if (*v8 <= *v7 && (v35 < v34 || *(a2 - 1) <= v33))
            {
              for (uint64_t i = v7 + 2; i < a2 && *i <= v34 && (*i < v34 || i[1] <= v33); i += 2)
                ;
            }

            else
            {
              uint64_t i = v7;
              do
              {
                __int128 v37 = i[2];
                i += 2;
                __int128 v36 = v37;
              }

              while (v37 <= v34 && (v36 < v34 || i[1] <= v33));
            }

            unint64_t j = a2;
            if (i < a2)
            {
              for (unint64_t j = a2 - 2; v35 > v34 || v35 >= v34 && j[1] > v33; j -= 2)
              {
                unsigned int v39 = *(j - 2);
                __int128 v35 = v39;
              }
            }

            if (i < j)
            {
              uint64_t v40 = *i;
              unsigned __int16 v41 = *j;
              do
              {
                uint64_t *i = v41;
                *unint64_t j = v40;
                unsigned int v42 = i[1];
                i[1] = j[1];
                j[1] = v42;
                do
                {
                  id v43 = i[2];
                  i += 2;
                  uint64_t v40 = v43;
                }

                while (v43 <= v34 && (v40 < v34 || i[1] <= v33));
                do
                {
                  do
                  {
                    uint64_t v44 = *(j - 2);
                    j -= 2;
                    unsigned __int16 v41 = v44;
                    unint64_t v45 = v44 >= v34;
                  }

                  while (v44 > v34);
                }

                while (v45 && j[1] > v33);
              }

              while (i < j);
            }

            if (i - 2 != v7)
            {
              *uint64_t v7 = *(i - 2);
              v7[1] = *(i - 1);
            }

            a4 = 0;
            *(i - 2) = v34;
            *(i - 1) = v33;
            continue;
          }
        }

        id v16 = v7 + 2;
        id v17 = *(void *)v7;
        size_t v18 = HIDWORD(*(void *)v7);
        while (1)
        {
          size_t v19 = *v16;
          v16 += 2;
        }

        if (v16 - 2 == v7)
        {
          uint64_t k = a2;
          if (v16 < a2)
          {
            id v23 = *v8;
            uint64_t k = a2 - 2;
            if (*v8 >= v17)
            {
              uint64_t k = a2 - 2;
              do
              {
                if (v23 <= v17)
                {
                }

                else if (v16 >= k)
                {
                  break;
                }

                uint64_t v25 = *(k - 2);
                k -= 2;
                id v23 = v25;
              }

              while (v25 >= v17);
            }
          }
        }

        else
        {
          unsigned __int16 v20 = *v8;
          for (uint64_t k = a2 - 2; v20 >= v17 && (v20 > v17 || k[1] >= v18); k -= 2)
          {
            uint64_t v22 = *(k - 2);
            unsigned __int16 v20 = v22;
          }
        }

        uint64_t i = v16;
        if (v16 < k)
        {
          uint64_t v26 = *k;
          uint64_t i = v16;
          uint64_t v27 = k;
          do
          {
            uint64_t *i = v26;
            void *v27 = v19;
            unint64_t v28 = i[1];
            i[1] = v27[1];
            v27[1] = v28;
            do
            {
              do
              {
                uint64_t v29 = i[2];
                i += 2;
                size_t v19 = v29;
                int v30 = v29 > v17;
              }

              while (v29 < v17);
            }

            while (!v30 && i[1] < v18);
            do
            {
              id v31 = *(v27 - 2);
              v27 -= 2;
              uint64_t v26 = v31;
            }

            while (v31 >= v17 && (v26 > v17 || v27[1] >= v18));
          }

          while (i < v27);
        }

        if (i - 2 != v7)
        {
          *uint64_t v7 = *(i - 2);
          v7[1] = *(i - 1);
        }

        *(i - 2) = v17;
        *(i - 1) = v18;
        if (v16 < k)
        {
LABEL_50:
          __n128 result = std::__introsort<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned int,unsigned int> *,false>( v7,  i - 2,  a3,  a4 & 1);
          a4 = 0;
          continue;
        }

        uint64_t v32 = std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned int,unsigned int> *>( v7,  i - 2);
        __n128 result = std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned int,unsigned int> *>( i,  a2);
        if (!(_DWORD)result)
        {
          if (v32) {
            continue;
          }
          goto LABEL_50;
        }

        a2 = i - 2;
        if (!v32) {
          goto LABEL_2;
        }
        return result;
    }
  }

void sub_B6B3C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_B79C4( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, void *a12, void *a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19, uint64_t a20, uint64_t a21, void *a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, char a29, uint64_t a30, uint64_t a31, char a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, uint64_t a41, uint64_t a42, uint64_t a43, void *__p)
{
}

LABEL_69:
    unint64_t v45 = *(void **)a6;
    unsigned int v46 = *(void **)(*(void *)a6 + 8 * v23);
    if (v46)
    {
      void *v27 = *v46;
LABEL_77:
      FILE *v46 = v27;
      goto LABEL_78;
    }

    void *v27 = *v18;
    int *v18 = v27;
    v45[v23] = v18;
    if (*v27)
    {
      uint64_t v47 = *(void *)(*v27 + 8LL);
      if ((v24 & (v24 - 1)) != 0)
      {
        if (v47 >= v24) {
          v47 %= v24;
        }
      }

      else
      {
        v47 &= v24 - 1;
      }

      unsigned int v46 = (void *)(*(void *)a6 + 8 * v47);
      goto LABEL_77;
    }

  if ((v12 & (v12 - 1)) != 0)
  {
    if (v11 >= v12) {
      uint64_t v2 = v11 % v12;
    }
    else {
      uint64_t v2 = v11;
    }
  }

  else
  {
    uint64_t v2 = (v12 - 1) & v11;
  }

void sub_B8130( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9, uint64_t a10, void *a11, void *a12)
{
  _Unwind_Resume(a1);
}

void sub_B93C8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, void *a15, uint64_t a16, uint64_t a17, void *a18, void *a19, void *a20, void *a21, void *a22, void *a23, void *a24, void *a25, uint64_t a26, void *a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, uint64_t a41, uint64_t a42, void **a43, uint64_t a44, uint64_t a45, uint64_t a46, uint64_t a47, uint64_t a48, uint64_t a49, uint64_t a50,char a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,char a56,uint64_t a57,uint64_t a58,char a59)
{
  a43 = (void **)&a56;
  std::vector<std::vector<DYMTLEncoderInfo>>::__destroy_vector::operator()[abi:nn180100](&a43);
  std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long>>>::~__hash_table((uint64_t)&a59);

  _Unwind_Resume(a1);
}

void sub_B9944( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, id a16)
{
  _Unwind_Resume(a1);
}

LABEL_126:
        if (++v30 == v32)
        {
          id v13 = v90;
          LODWORD(v86) = v87;
          -[DYPMTLShaderProfilerHelper evaluateStreamingSamples:withUSCSampleNum:withProgramAddressLUT:targetIndex:forRingBufferIndex:withMinEncoderIndex:withMaxEncoderIndex:withEncoderIdToEncoderIndexMap:withProfilingData:]( self->_shaderProfilerHelper, "evaluateStreamingSamples:withUSCSampleNum:withProgramAddressLUT:targetIndex:forRingBufferIndex:withMinEncode rIndex:withMaxEncoderIndex:withEncoderIdToEncoderIndexMap:withProfilingData:", [v95 bytes], v91, &v97, a9, a8, v24, v86, &v106, v90);
          std::__hash_table<std::__hash_value_type<unsigned int,std::vector<GTCoalescedEncoderIndexInfo>>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,std::vector<GTCoalescedEncoderIndexInfo>>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,std::vector<GTCoalescedEncoderIndexInfo>>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,std::vector<GTCoalescedEncoderIndexInfo>>>>::~__hash_table((uint64_t)&v97);
          std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long>>>::~__hash_table((uint64_t)&v100);
          size_t v19 = v88;
          id v14 = v89;
          if (v103) {
            operator delete(v103);
          }
          break;
        }
      }
    }
  }

  std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long>>>::~__hash_table((uint64_t)&v106);
}

  v65->int nelts = 0;
  uint64_t v89 = v59[6];
  id v90 = *(_DWORD *)(v89 + 12);
  uint64_t v91 = v147;
  if (v90 >= 1)
  {
    for (unint64_t m = 0LL; m < v90; ++m)
    {
      int v93 = **(void **)(*(void *)(*(void *)(v89 + 24) + 8 * m) + 104LL);
      if (v93)
      {
        id v94 = apr_array_push(v65);
        uint64_t v91 = v147;
        *id v94 = v93;
        id v90 = *(_DWORD *)(v89 + 12);
      }
    }
  }

  ReserveResourceIndices(v91, (uint64_t)v65, 5u);
  unint64_t v66 = g_enableIndexedResourceType;
  if ((g_enableIndexedResourceType & 0x40) == 0)
  {
LABEL_89:
    if ((v66 & 0x80) == 0) {
      goto LABEL_144;
    }
    goto LABEL_138;
  }

void sub_BA1EC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, void *a15, void *a16, uint64_t a17, uint64_t a18, uint64_t a19, void *a20, uint64_t a21, uint64_t a22, void *a23, uint64_t a24, char a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, char a31)
{
  id v33 = *(void **)(v31 - 152);
  if (v33) {
    operator delete(v33);
  }
  std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long>>>::~__hash_table(v31 - 128);

  _Unwind_Resume(a1);
}

void sub_BA9A8( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, void *a15, void *a16, void *a17, void *a18, void *a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, char a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, char a41, uint64_t a42, uint64_t a43, uint64_t a44, uint64_t a45, void *__p, uint64_t a47, uint64_t a48, char a49)
{
  if (__p) {
    operator delete(__p);
  }
  std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long>>>::~__hash_table((uint64_t)&a49);

  _Unwind_Resume(a1);
}

void sub_BAF4C( _Unwind_Exception *a1, uint64_t a2, void *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, ...)
{
  _Unwind_Resume(a1);
}

void sub_BB2CC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9, void *a10)
{
  _Unwind_Resume(a1);
}

void sub_BB56C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  _Unwind_Resume(a1);
}

void sub_BB7EC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_BB84C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_BBDCC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, void *a11, void *a12, void *a13, void *a14, void *a15, void *a16, void *a17, void *a18, uint64_t a19, void *a20)
{
  _Unwind_Resume(a1);
}

void sub_BCA74( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, void *a16, uint64_t a17, void *a18, void *a19, void *a20, uint64_t a21, void *__p, void *a23, uint64_t a24, uint64_t a25, char *a26, uint64_t a27, uint64_t a28, char a29, uint64_t a30, uint64_t a31, uint64_t *a32)
{
  a32 = (uint64_t *)&a26;
  std::vector<NSObject  {objcproto21OS_dispatch_semaphore}* {__strong}>::__destroy_vector::operator()[abi:nn180100]((void ***)&a32);
  a26 = &a29;
  std::vector<NSObject  {objcproto21OS_dispatch_semaphore}* {__strong}>::__destroy_vector::operator()[abi:nn180100]((void ***)&a26);

  if (__p) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

LABEL_117:
          v240 = 0LL;
          __p = 0u;
          memset(v238, 0, sizeof(v238));
          id v237 = 0u;
          memset(buffer, 0, sizeof(buffer));
          if (v90 >= *((void *)v85 + 10 * v46 + 9))
          {
            id v101 = std::vector<DebugInfo::BlockInfo>::__push_back_slow_path<DebugInfo::BlockInfo>(v88, (uint64_t)buffer);
            uint64_t v102 = SHIBYTE(v240);
            *uint64_t v91 = v101;
            if (v102 < 0) {
              operator delete((void *)__p);
            }
          }

          else
          {
            *(void *)id v90 = 0LL;
            unint64_t v97 = *(_OWORD *)&buffer[8];
            *(void *)(v90 + 24) = *(void *)&buffer[24];
            *(_OWORD *)(v90 + _Block_object_dispose(va, 8) = v97;
            memset(&buffer[8], 0, 24);
            unsigned __int32 v98 = v238[0];
            *(_OWORD *)(v90 + 32) = v237;
            *(void *)(v90 + 4_Block_object_dispose(va, 8) = v98;
            v238[0] = 0LL;
            id v237 = 0uLL;
            unint64_t v99 = *(_OWORD *)&v238[1];
            *(void *)(v90 + 72) = v238[3];
            *(_OWORD *)(v90 + 56) = v99;
            memset(&v238[1], 0, 24);
            uint64_t v100 = __p;
            *(void *)(v90 + 96) = v240;
            *(_OWORD *)(v90 + 80) = v100;
            __p = 0uLL;
            v240 = 0LL;
            *uint64_t v91 = v90 + 104;
          }

          if (SHIBYTE(v238[3]) < 0) {
            operator delete((void *)v238[1]);
          }
          if (SHIBYTE(v238[0]) < 0) {
            operator delete((void *)v237);
          }
          if (buffer[31] < 0) {
            operator delete(*(void **)&buffer[8]);
          }
          unint64_t v103 = *v91;
          std::string::operator=((std::string *)(*v91 - 72), &__s1);
          if (lldb::SBFileSpec::GetDirectory((lldb::SBFileSpec *)v216)
            && lldb::SBFileSpec::GetFilename((lldb::SBFileSpec *)v216))
          {
            int v104 = (const std::string::value_type *)lldb::SBFileSpec::GetDirectory((lldb::SBFileSpec *)v216);
            std::string::assign((std::string *)(v103 - 96), v104);
            uint64_t v105 = (const std::string::value_type *)lldb::SBFileSpec::GetFilename((lldb::SBFileSpec *)v216);
            std::string::assign((std::string *)(v103 - 48), v105);
            constructFullPath((uint64_t)buffer, v103 - 96, v103 - 48);
            uint64_t v106 = (void **)(v103 - 24);
            *(_OWORD *)uint64_t v106 = *(_OWORD *)buffer;
            *(void *)(v103 - _Block_object_dispose(va, 8) = *(void *)&buffer[16];
          }

          *(_DWORD *)(v103 - 104) = Line;
          unint64_t v87 = *v88;
          id v90 = *v91;
        }

  BOOL v86 = *(void *)(Subprogram - 8LL * *(unsigned int *)(Subprogram + 8) + 32);
  if (!v86
    || (unint64_t v87 = *(void *)(v86 - 8LL * *(unsigned int *)(v86 + 8) + 24)) == 0
    || (BOOL v88 = *(unsigned int *)(v87 + 8), !(_DWORD)v88)
    || (uint64_t v89 = *(void *)(v87 - 8 * v88)) == 0)
  {
LABEL_122:
    id v90 = -1LL;
    goto LABEL_123;
  }

  v99[0] = 0LL;
  v99[1] = 0LL;
  unsigned __int32 v98 = v99;
  id v90 = ShaderDebugger::Metadata::MDSerializerLLVM3XXX::serializeType(a1, v89, &v98);
  std::__tree<llvm::DIType *>::destroy(v99[0]);
LABEL_123:
  uint64_t v91 = *(void *)(v4 + 32);
  std::string::basic_string[abi:nn180100]<0>(&__p, "ret");
  uint64_t v71 = a1;
  uint64_t v72 = v91;
  BOOL v73 = v90;
  char v74 = -1LL;
  uint64_t v70 = 0;
LABEL_94:
  id v75 = ShaderDebugger::Metadata::MDSerializer::serializeLocalVariable(v71, v72, (uint64_t)&__p, v73, v74, v70);
LABEL_105:
  unsigned __int8 v57 = v75;
LABEL_107:
  __p.__r_.__value_.__r.__words[0] = v7 & 0xFFFFFF | (v11 << 24);
  __dst.__r_.__value_.__r.__words[0] = v57;
  v107[0] = 7LL;
  __int128 v80 = std::__tree<std::__value_type<ShaderDebugger::Metadata::MDBase::MetadataType,ShaderDebugger::Metadata::MDSerializer::MetadataTypeContainer>,std::__map_value_compare<ShaderDebugger::Metadata::MDBase::MetadataType,std::__value_type<ShaderDebugger::Metadata::MDBase::MetadataType,ShaderDebugger::Metadata::MDSerializer::MetadataTypeContainer>,std::less<ShaderDebugger::Metadata::MDBase::MetadataType>,true>,std::allocator<std::__value_type<ShaderDebugger::Metadata::MDBase::MetadataType,ShaderDebugger::Metadata::MDSerializer::MetadataTypeContainer>>>::__emplace_unique_key_args<ShaderDebugger::Metadata::MDBase::MetadataType,std::piecewise_construct_t const&,std::tuple<ShaderDebugger::Metadata::MDBase::MetadataType&&>,std::tuple<>>( a1,  7uLL,  v107);
  uint64_t v81 = v80;
  uint64_t v83 = (uint64_t)(v80 + 40);
  unint64_t v82 = (char *)*((void *)v80 + 5);
  __int128 v84 = (char *)*((void *)v80 + 6);
  id v85 = v82;
  if (v82 != v84)
  {
    while (*(void *)v85 != v3)
    {
      v85 += 8;
      if (v85 == v84)
      {
        id v85 = (char *)*((void *)v80 + 6);
        break;
      }
    }
  }

  if (v85 == v84
    || v85 - v82 == -8
    || ShaderDebugger::Metadata::MDSerializer::isMetadataIdReserved((char **)v80 + 5, v3))
  {
    v107[0] = ShaderDebugger::Metadata::MDSerializer::addAndLinearizeMetadataId(v83, v3);
    ShaderDebugger::Metadata::MDSerializer::write<unsigned long long>((unint64_t *)v81 + 11, v107);
    ShaderDebugger::Metadata::MDSerializer::write<unsigned long long>((unint64_t *)v81 + 11, &__p);
    ShaderDebugger::Metadata::MDSerializer::write<unsigned long long>((unint64_t *)v81 + 11, &__dst);
    uint64_t v106 = v10;
    ShaderDebugger::Metadata::MDSerializer::write<unsigned long long>((unint64_t *)v81 + 11, &v106);
  }

LABEL_133:
        if (v87 != v90)
        {
          uint64_t v107 = v90 - 104;
          if (v90 - 104 > v87)
          {
            id v108 = v87 + 104;
            do
            {
              __int8 v109 = *(void *)(v108 - 104);
              uint64_t v110 = *(void *)(v108 - 96);
              uint64_t v111 = *(void *)(v108 - 88);
              *(void *)&buffer[7] = *(void *)(v108 - 81);
              *(void *)buffer = v111;
              uint64_t v112 = *(_BYTE *)(v108 - 73);
              id v113 = (void **)(v108 - 72);
              id v114 = *(void *)(v108 - 72);
              *(void *)(v108 - 96) = 0LL;
              *(void *)(v108 - 8_Block_object_dispose(va, 8) = 0LL;
              uint64_t v115 = *(void *)(v108 - 57);
              *(void *)__int128 v231 = *(void *)(v108 - 64);
              *(void *)&v231[7] = v115;
              uint64_t v196 = *(_BYTE *)(v108 - 49);
              *(void *)(v108 - 64) = 0LL;
              *(void *)(v108 - 72) = 0LL;
              uint64_t v116 = (void **)(v108 - 48);
              uint64_t v200 = *(void *)(v108 - 48);
              uint64_t v117 = *(void *)(v108 - 40);
              *(void *)&v242[7] = *(void *)(v108 - 33);
              *(void *)id v242 = v117;
              uint64_t v118 = v108 - 24;
              uint64_t v205 = *(void *)(v108 - 24);
              *(void *)(v108 - 80) = 0LL;
              *(void *)(v108 - 56) = 0LL;
              unint64_t v198 = *(_BYTE *)(v108 - 25);
              *(void *)(v108 - 40) = 0LL;
              *(void *)(v108 - 4_Block_object_dispose(va, 8) = 0LL;
              uint64_t v119 = *(void *)(v108 - 16);
              *(void *)((char *)v241 + 7) = *(void *)(v108 - 9);
              v241[0] = v119;
              uint64_t v202 = *(_BYTE *)(v108 - 1);
              *(void *)(v118 + _Block_object_dispose(va, 8) = 0LL;
              *(void *)(v118 + 16) = 0LL;
              *(void *)(v108 - 32) = 0LL;
              *(void *)uint64_t v118 = 0LL;
              *(void *)(v108 - 104) = *(void *)v107;
              uint64_t v120 = *(_OWORD *)(v107 + 8);
              *(void *)(v108 - 80) = *(void *)(v107 + 24);
              *(_OWORD *)(v108 - 96) = v120;
              *(_BYTE *)(v107 + 31) = 0;
              *(_BYTE *)(v107 + _Block_object_dispose(va, 8) = 0;
              id v121 = *(_OWORD *)(v107 + 32);
              *(void *)(v108 - 56) = *(void *)(v107 + 48);
              *(_OWORD *)id v113 = v121;
              *(_BYTE *)(v107 + 55) = 0;
              *(_BYTE *)(v107 + 32) = 0;
              uint32x2_t v122 = *(_OWORD *)(v107 + 56);
              *(void *)(v108 - 32) = *(void *)(v107 + 72);
              *(_OWORD *)uint64_t v116 = v122;
              *(_BYTE *)(v107 + 79) = 0;
              *(_BYTE *)(v107 + 56) = 0;
              unint64_t v123 = *(_OWORD *)(v107 + 80);
              *(void *)(v108 - _Block_object_dispose(va, 8) = *(void *)(v107 + 96);
              *(_OWORD *)uint64_t v118 = v123;
              *(_BYTE *)(v107 + 103) = 0;
              *(_BYTE *)(v107 + 80) = 0;
              *(void *)uint64_t v107 = v109;
              *(void *)(v107 + _Block_object_dispose(va, 8) = v110;
              uint64_t v124 = *(void *)buffer;
              *(void *)(v107 + 23) = *(void *)&buffer[7];
              *(void *)(v107 + 16) = v124;
              *(_BYTE *)(v107 + 31) = v112;
              *(void *)(v107 + 32) = v114;
              id v125 = *(void *)v231;
              *(void *)(v107 + 47) = *(void *)&v231[7];
              *(void *)(v107 + 40) = v125;
              *(_BYTE *)(v107 + 55) = v196;
              *(void *)(v107 + 56) = v200;
              id v126 = *(void *)v242;
              *(void *)(v107 + 71) = *(void *)&v242[7];
              *(void *)(v107 + 64) = v126;
              *(_BYTE *)(v107 + 79) = v198;
              unsigned int v46 = v193;
              *(void *)(v107 + 80) = v205;
              uint64_t v127 = v241[0];
              *(void *)(v107 + 95) = *(void *)((char *)v241 + 7);
              *(void *)(v107 + 8_Block_object_dispose(va, 8) = v127;
              *(_BYTE *)(v107 + 103) = v202;
              v107 -= 104LL;
              uint64_t v128 = v108 >= v107;
              v108 += 104LL;
            }

            while (!v128);
          }
        }
      }

      lldb::SBFileSpec::~SBFileSpec((lldb::SBFileSpec *)v216);
      lldb::SBBlock::~SBBlock((lldb::SBBlock *)v217);
      lldb::SBBlock::~SBBlock((lldb::SBBlock *)v218);
      uint64_t v31 = (uint64_t)v194;
      var0 = v194->var0.var0;
      goto LABEL_155;
    }

    lldb::SBLineEntry::GetFileSpec((lldb::SBLineEntry *)&v222);
    var0 = *(LineEntry **)v31;
    unint64_t v66 = *(void *)v31 + 80 * v46;
    v240 = 0LL;
    __p = 0u;
    memset(v238, 0, sizeof(v238));
    id v237 = 0u;
    memset(buffer, 0, sizeof(buffer));
    __int128 v67 = *(void *)(v66 + 64);
    uint64_t v68 = *(void *)(v66 + 72);
    uint64_t v69 = (unint64_t *)(v66 + 64);
    if (v67 >= v68)
    {
      __int128 v76 = std::vector<DebugInfo::BlockInfo>::__push_back_slow_path<DebugInfo::BlockInfo>( (unint64_t *)var0 + 10 * v46 + 7,  (uint64_t)buffer);
      BOOL v77 = SHIBYTE(v240);
      *uint64_t v69 = v76;
      if (v77 < 0) {
        operator delete((void *)__p);
      }
    }

    else
    {
      *(void *)__int128 v67 = 0LL;
      uint64_t v70 = *(_OWORD *)&buffer[8];
      *(void *)(v67 + 24) = *(void *)&buffer[24];
      *(_OWORD *)(v67 + _Block_object_dispose(va, 8) = v70;
      memset(&buffer[8], 0, 24);
      uint64_t v71 = v238[0];
      *(_OWORD *)(v67 + 32) = v237;
      *(void *)(v67 + 4_Block_object_dispose(va, 8) = v71;
      v238[0] = 0LL;
      id v237 = 0uLL;
      uint64_t v72 = *(_OWORD *)&v238[1];
      *(void *)(v67 + 72) = v238[3];
      *(_OWORD *)(v67 + 56) = v72;
      memset(&v238[1], 0, 24);
      BOOL v73 = __p;
      *(void *)(v67 + 96) = v240;
      *(_OWORD *)(v67 + 80) = v73;
      __p = 0uLL;
      v240 = 0LL;
      *uint64_t v69 = v67 + 104;
    }

    if (SHIBYTE(v238[3]) < 0) {
      operator delete((void *)v238[1]);
    }
    if (SHIBYTE(v238[0]) < 0) {
      operator delete((void *)v237);
    }
    if (buffer[31] < 0) {
      operator delete(*(void **)&buffer[8]);
    }
    lldb::SBLineEntry::GetStartAddress((lldb::SBLineEntry *)&v222);
    lldb::SBAddress::GetFunction((lldb::SBAddress *)&__s1);
    __int128 v78 = lldb::SBFunction::GetName((lldb::SBFunction *)buffer);
    if (v78)
    {
      lldb::SBLineEntry::GetStartAddress((lldb::SBLineEntry *)&v222);
      lldb::SBAddress::GetFunction((lldb::SBAddress *)v220);
      unint64_t v79 = (const std::string::value_type *)lldb::SBFunction::GetName((lldb::SBFunction *)v221);
    }

    else
    {
      unint64_t v79 = "-";
    }

    std::string::assign((std::string *)(*v69 - 72), v79);
    if (v78)
    {
      lldb::SBFunction::~SBFunction((lldb::SBFunction *)v221);
      lldb::SBAddress::~SBAddress((lldb::SBAddress *)v220);
    }

    lldb::SBFunction::~SBFunction((lldb::SBFunction *)buffer);
    lldb::SBAddress::~SBAddress((lldb::SBAddress *)&__s1);
    if (lldb::SBFileSpec::GetDirectory((lldb::SBFileSpec *)v242)
      && lldb::SBFileSpec::GetFilename((lldb::SBFileSpec *)v242))
    {
      __int128 v80 = (const std::string::value_type *)lldb::SBFileSpec::GetDirectory((lldb::SBFileSpec *)v242);
      std::string::assign((std::string *)(*v69 - 96), v80);
      uint64_t v81 = (const std::string::value_type *)lldb::SBFileSpec::GetFilename((lldb::SBFileSpec *)v242);
      std::string::assign((std::string *)(*v69 - 48), v81);
      unint64_t v82 = (char *)lldb::SBFileSpec::GetDirectory((lldb::SBFileSpec *)v242);
      std::string::basic_string[abi:nn180100]<0>(&__s1, v82);
      uint64_t v83 = (char *)lldb::SBFileSpec::GetFilename((lldb::SBFileSpec *)v242);
      std::string::basic_string[abi:nn180100]<0>(v231, v83);
      constructFullPath((uint64_t)buffer, (uint64_t)&__s1, (uint64_t)v231);
      __int128 v84 = *v69 - 24;
      *(_OWORD *)__int128 v84 = *(_OWORD *)buffer;
      *(void *)(v84 + 16) = *(void *)&buffer[16];
      if (v232 < 0) {
        operator delete(*(void **)v231);
      }
    }

    *(_DWORD *)(*v69 - 104) = lldb::SBLineEntry::GetLine((lldb::SBLineEntry *)&v222);
    lldb::SBFileSpec::~SBFileSpec((lldb::SBFileSpec *)v242);
LABEL_155:
    uint64_t v129 = (char *)var0 + 80 * v46;
    uint64_t v131 = *((void *)v129 + 7);
    unint64_t v130 = (unsigned int **)(v129 + 56);
    constructFullPath((uint64_t)buffer, v131 + 8, v131 + 56);
    uint64_t v132 = (char *)var0 + 80 * v46;
    if (v132[23] < 0) {
      operator delete(*(void **)v132);
    }
    *(_OWORD *)uint64_t v132 = *(_OWORD *)buffer;
    *((void *)v132 + 2) = *(void *)&buffer[16];
    lldb::SBLineEntry::GetStartAddress((lldb::SBLineEntry *)&v222);
    unint64_t v133 = lldb::SBAddress::GetFileAddress((lldb::SBAddress *)buffer);
    unint64_t v134 = *(_DWORD *)(v31 + 64);
    if (v134 >= v133) {
      uint64_t v135 = v133;
    }
    else {
      uint64_t v135 = *(_DWORD *)(v31 + 64);
    }
    *((_DWORD *)var0 + 20 * v46 + 6) = v135;
    lldb::SBAddress::~SBAddress((lldb::SBAddress *)buffer);
    lldb::SBLineEntry::GetEndAddress((lldb::SBLineEntry *)&v222);
    uint64_t v136 = lldb::SBAddress::GetFileAddress((lldb::SBAddress *)buffer);
    if (v134 >= v136) {
      uint64_t v137 = v136;
    }
    else {
      uint64_t v137 = v134;
    }
    *((_DWORD *)var0 + 20 * v46 + 7) = v137;
    lldb::SBAddress::~SBAddress((lldb::SBAddress *)buffer);
    uint64_t v138 = **v130;
    if (v138 != -1)
    {
      uint64_t v139 = *(_DWORD *)(v31 + 48);
      if (v138 < v139) {
        uint64_t v139 = **v130;
      }
      if (*(_DWORD *)(v31 + 52) > v138) {
        uint64_t v138 = *(_DWORD *)(v31 + 52);
      }
      *(_DWORD *)(v31 + 4_Block_object_dispose(va, 8) = v139;
      *(_DWORD *)(v31 + 52) = v138;
      if (v193)
      {
        uint64_t v140 = v187;
        id v141 = (void *)((char *)var0 + v186);
        unint64_t v197 = var0;
        do
        {
          id v142 = v140;
          uint64_t v143 = (char *)var0 + 80 * v140;
          BOOL v145 = *((_DWORD *)v143 + 6);
          unsigned int v144 = v143 + 24;
          if (*((_DWORD *)v141 - 12) < v145)
          {
            id v146 = *(_OWORD *)(v141 - 9);
            *(void *)&buffer[16] = *(v141 - 7);
            *(_OWORD *)buffer = v146;
            *(v141 - _Block_object_dispose(va, 8) = 0LL;
            *(v141 - 7) = 0LL;
            *(v141 - 9) = 0LL;
            unint64_t v147 = *(v141 - 6);
            *(void *)&buffer[24] = v147;
            unint64_t v148 = (char *)var0 + 80 * v140;
            unsigned int v201 = *(_OWORD *)(v141 - 5);
            id v237 = v201;
            unint64_t v199 = *(v141 - 3);
            v238[0] = v199;
            *(v141 - 5) = 0LL;
            *(v141 - 4) = 0LL;
            *(v141 - 3) = 0LL;
            *(_OWORD *)uint64_t v206 = *((_OWORD *)v141 - 1);
            *(_OWORD *)&v238[1] = *(_OWORD *)v206;
            unint64_t v203 = *v141;
            v238[3] = *v141;
            *(v141 - 1) = 0LL;
            *id v141 = 0LL;
            *(v141 - 2) = 0LL;
            unint64_t v149 = *(_OWORD *)v148;
            *(v141 - 7) = *((void *)v148 + 2);
            *(_OWORD *)(v141 - 9) = v149;
            v148[23] = 0;
            *unint64_t v148 = 0;
            *(v141 - 6) = *v144;
            std::vector<DebugInfo::LineDisassemblyInfo>::__vdeallocate(v141 - 5);
            *(_OWORD *)(v141 - 5) = *((_OWORD *)v148 + 2);
            *(v141 - 3) = *((void *)v148 + 6);
            *((void *)v148 + 5) = 0LL;
            *((void *)v148 + 4) = 0LL;
            *((void *)v148 + 6) = 0LL;
            std::vector<DebugInfo::BlockInfo>::__vdeallocate((void **)v141 - 2);
            *((_OWORD *)v141 - 1) = *(_OWORD *)(v148 + 56);
            *id v141 = *((void *)v148 + 9);
            *((void *)v148 + _Block_object_dispose(va, 8) = 0LL;
            *((void *)v148 + 7) = 0LL;
            *((void *)v148 + 9) = 0LL;
            if (v148[23] < 0) {
              operator delete(*(void **)v148);
            }
            uint64_t v150 = *(_OWORD *)buffer;
            *((void *)v148 + 2) = *(void *)&buffer[16];
            *(_OWORD *)unint64_t v148 = v150;
            buffer[23] = 0;
            buffer[0] = 0;
            *unsigned int v144 = v147;
            std::vector<DebugInfo::LineDisassemblyInfo>::__vdeallocate((uint64_t *)v148 + 4);
            *((_OWORD *)v148 + 2) = v201;
            *((void *)v148 + 6) = v199;
            id v237 = 0uLL;
            v238[0] = 0LL;
            std::vector<DebugInfo::BlockInfo>::__vdeallocate((void **)v148 + 7);
            *(_OWORD *)(v148 + 56) = *(_OWORD *)v206;
            *((void *)v148 + 9) = v203;
            memset(&v238[1], 0, 24);
            __s1.__r_.__value_.__r.__words[0] = (std::string::size_type)&v238[1];
            std::vector<DebugInfo::BlockInfo>::__destroy_vector::operator()[abi:nn180100]((void ***)&__s1);
            __s1.__r_.__value_.__r.__words[0] = (std::string::size_type)&v237;
            std::vector<DebugInfo::LineDisassemblyInfo>::__destroy_vector::operator()[abi:nn180100]((void ***)&__s1);
            if (buffer[23] < 0) {
              operator delete(*(void **)buffer);
            }
            uint64_t v31 = (uint64_t)v194;
            var0 = v197;
          }

          v141 -= 10;
          --v140;
        }

        while (v142);
      }
    }

    lldb::SBLineEntry::~SBLineEntry((lldb::SBLineEntry *)&v222);
    unsigned int v46 = v193 + 1;
    v186 += 80LL;
    ++v187;
  }

  *(_DWORD *)(v31 + 56) = *(_DWORD *)(v31 + 52) - *(_DWORD *)(v31 + 48) + 1;
  uint64_t v151 = *(LineEntry **)v31;
  uint64_t v152 = *(void *)(v31 + 8) - *(void *)v31;
  if (v152)
  {
    uint64_t v153 = 0LL;
    uint64_t v154 = 0;
    uint64_t v155 = 0xCCCCCCCCCCCCCCCDLL * (v152 >> 4);
    do
    {
      uint64_t v156 = *((_DWORD *)v151 + 20 * v153 + 7);
      uint64_t v157 = v154 + 1;
      if (v155 > v157)
      {
        uint64_t v158 = *((_DWORD *)v151 + 20 * v153 + 6);
        do
        {
          if (v158 != *((_DWORD *)v151 + 20 * v157 + 6)) {
            break;
          }
          if (v156 <= *((_DWORD *)v151 + 20 * v157 + 7)) {
            uint64_t v156 = *((_DWORD *)v151 + 20 * v157 + 7);
          }
          uint64_t v157 = (v157 + 1);
        }

        while (v155 > v157);
      }

      uint64_t v153 = v154;
      if (v154 < v157)
      {
        uint64_t v159 = v157 - (unint64_t)v154;
        uint64_t v160 = (unsigned int *)((char *)v151 + 80 * v154 + 28);
        do
        {
          *uint64_t v160 = v156;
          v160 += 20;
          --v159;
        }

        while (v159);
        uint64_t v153 = v157;
        uint64_t v154 = v157;
      }
    }

    while (v155 > v153);
  }

  if ((a6 & 0x80000000) == 0)
  {
    uint64_t v207 = (GPUToolsPlatformLLVMShaderProfilerHelper *)operator new(8uLL);
    GPUToolsPlatformLLVMShaderProfilerHelper::GPUToolsPlatformLLVMShaderProfilerHelper(v207);
    uint64_t v161 = v192;
    GPUToolsPlatformLLVMShaderProfilerHelper::SetBinaryForAnalysis( v207,  (const char *)[v161 bytes],  (uint64_t)objc_msgSend(v161, "length"),  a6);
    uint64_t v162 = [v161 length];
    memset(buffer, 0, 28);
    *(void *)int v209 = v162;
    std::vector<DebugInfo::LineDisassemblyInfo>::resize((void **)&p_var1->var0, (unint64_t)v162, (uint64_t)buffer);
    uint64_t v164 = v194->var0.var0;
    id var1 = v194->var0.var1;
    char v204 = var1;
    while (v164 != var1)
    {
      uint64_t v166 = *((_DWORD *)v164 + 6);
      __int128 v165 = *((_DWORD *)v164 + 7);
      memset(buffer, 0, 28);
      std::vector<DebugInfo::LineDisassemblyInfo>::resize( (void **)v164 + 4,  (v165 - v166 + 1),  (uint64_t)buffer);

      GPUToolsPlatformLLVMShaderProfilerHelper::ShaderInstructionInfoFromBinary( (void ***)buffer,  *(void *)v207,  *((unsigned int *)v164 + 6),  *((unsigned int *)v164 + 7));
      __int128 v167 = *(int **)buffer;
      uint64_t v168 = *(int **)&buffer[8];
      while (v167 != v168)
      {
        __int128 v169 = v167 + 2;
        uint64_t v170 = v167 + 2;
        __int128 v171 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", v170));
        __int128 v172 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", v169));
        __int128 v173 = *v167;
        __int128 v174 = v167[1];
        uint64_t v175 = *((void *)v167 + 4);
        __int128 v176 = (v175 - *((_DWORD *)v164 + 6));
        uint64_t v177 = *((void *)v164 + 4);
        if (0xCCCCCCCCCCCCCCCDLL * ((*((void *)v164 + 5) - v177) >> 3) > v176)
        {
          objc_storeStrong((id *)(v177 + 40LL * v176), v171);
          objc_storeStrong((id *)(v177 + 40LL * v176 + 8), v172);
          uint64_t v178 = v177 + 40LL * v176;
          *(void *)(v178 + 16) = 0LL;
          *(_DWORD *)(v178 + 24) = 0;
          *(_DWORD *)(v178 + 2_Block_object_dispose(va, 8) = v173;
          *(_DWORD *)(v178 + 32) = v174;
          *(_DWORD *)(v178 + 36) = 0;
          uint64_t v175 = *((void *)v167 + 4);
        }

        if (v175 < *(void *)v209)
        {
          uint64_t v179 = (id *)p_var1->var0;
          objc_storeStrong((id *)p_var1->var0 + 5 * v175, v171);
          objc_storeStrong(&v179[5 * v175 + 1], v172);
          id v180 = &v179[5 * v175];
          v180[2] = 0LL;
          *((_DWORD *)v180 + 6) = 0;
          *((_DWORD *)v180 + 7) = v173;
          *((_DWORD *)v180 + _Block_object_dispose(va, 8) = v174;
          *((_DWORD *)v180 + 9) = 0;
        }

        v167 += 10;
      }

      __s1.__r_.__value_.__r.__words[0] = (std::string::size_type)buffer;
      std::vector<InstructionInfo>::__destroy_vector::operator()[abi:nn180100]((void ***)&__s1);
      uint64_t v164 = (LineEntry *)((char *)v164 + 80);
      id var1 = v204;
    }

    std::unique_ptr<GPUToolsPlatformLLVMShaderProfilerHelperImpl>::reset[abi:nn180100]((uint64_t *)v207, 0LL);
    operator delete(v207);
  }

              __int128 v169 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  *v154));
              uint64_t v170 = (void *)objc_claimAutoreleasedReturnValue([v215 objectForKeyedSubscript:v169]);

              if (v170) {
                __int128 v171 = [v221 loadDynamicLibrariesForFunction:v170 insertLibraries:&__NSArray0__struct error:0];
              }
              else {
                __int128 v171 = 0LL;
              }
              if ([v171 count])
              {
                if (v45 == (_BYTE *)&dword_0 + 2)
                {
                  __int128 v172 = (void *)objc_claimAutoreleasedReturnValue([v20 fragmentPreloadedLibraries]);
                  __int128 v173 = [v172 mutableCopy];

                  [v173 addObjectsFromArray:v171];
                  __int128 v174 = [v173 copy];
                  [v20 setFragmentPreloadedLibraries:v174];

                  objc_msgSend(v20, "setMaxFragmentCallStackDepth:", (char *)objc_msgSend(v173, "count") + 1);
                }

                else if (v101)
                {
                  uint64_t v175 = (void *)objc_claimAutoreleasedReturnValue([v20 meshPreloadedLibraries]);
                  __int128 v173 = [v175 mutableCopy];

                  [v173 addObjectsFromArray:v171];
                  __int128 v176 = [v173 copy];
                  [v20 setMeshPreloadedLibraries:v176];

                  objc_msgSend(v20, "setMaxMeshCallStackDepth:", (char *)objc_msgSend(v173, "count") + 1);
                }

                else
                {
                  uint64_t v177 = (void *)objc_claimAutoreleasedReturnValue([v20 objectPreloadedLibraries]);
                  __int128 v173 = [v177 mutableCopy];

                  [v173 addObjectsFromArray:v171];
                  uint64_t v178 = [v173 copy];
                  [v20 setObjectPreloadedLibraries:v178];

                  objc_msgSend(v20, "setMaxObjectCallStackDepth:", (char *)objc_msgSend(v173, "count") + 1);
                }

                unint64_t v45 = v216;
              }

              goto LABEL_144;
            }

      uint64_t v116 = 0LL;
      uint64_t v117 = v253;
      do
      {
        *(void *)(*((void *)v3 + 3) + v71 + v116) = v117;
        uint64_t v118 = *(void *)(*(void *)v3 + 88 * v117 + 8) + *(void *)(*(void *)v3 + 88 * v117);
        __int128 v274 = v118;
        uint64_t v119 = std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::find<unsigned long long>( v254,  v118);
        if (!v119 || (uint64_t v120 = *((unsigned int *)v119 + 6), (_DWORD)v120 == -1))
        {
          uint64_t v120 = v117;
          *((_DWORD *)std::__hash_table<std::__hash_value_type<unsigned long long,unsigned int>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned int>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned int>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned int>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long const&>,std::tuple<>>( (uint64_t)v254,  v118,  &v274)
          + 6) = v117;
        }

        v116 += 8LL;
        uint64_t v117 = v120;
      }

      while (v116 != 48);
      uint64_t v72 = v253 + 1;
      uint64_t v70 = *(void *)v3;
      v71 += 48LL;
    }

    while (v253 + 1 < (unint64_t)(0x2E8BA2E8BA2E8BA3LL * ((uint64_t)(*((void *)v3 + 1) - *(void *)v3) >> 3)));
  }

    *(void *)v452 = &v435;
    std::vector<std::string>::__destroy_vector::operator()[abi:nn180100]((void ***)v452);
    if (v434 < 0) {
      operator delete(v433);
    }
    if (v432 < 0) {
      operator delete(v431);
    }
    if (v430 < 0) {
      operator delete(v428);
    }
    if (v427 < 0) {
      operator delete(*(void **)&v425[16]);
    }
    goto LABEL_141;
  }

  uint64_t v40 = 0;
LABEL_147:
LABEL_149:
  unint64_t v82 = *(void *)v466;
  *(void *)v466 = 0LL;
  if (v82) {
    (*(void (**)(uint64_t))(*(void *)v82 + 8LL))(v82);
  }
  uint64_t v83 = v441;
  id v441 = 0LL;
  if (v83) {
    (*(void (**)(llvm::MemoryBuffer *))(*(void *)v83 + 8LL))(v83);
  }

  if (v40)
  {
    unint64_t v87 = v379;
    if (([v379 setupBinary:v11 targetIndex:a2] & 1) == 0)
    {

      unint64_t v87 = 0LL;
    }

    BOOL v88 = operator new(0x108uLL);
    uint64_t v89 = v87;
    *(_OWORD *)BOOL v88 = 0u;
    *((_OWORD *)v88 + 1) = 0u;
    *((_OWORD *)v88 + 2) = 0u;
    *((_OWORD *)v88 + 3) = 0u;
    *((_OWORD *)v88 + 4) = 0u;
    *(_OWORD *)(v88 + 11) = 0u;
    v377 = (void **)(v88 + 11);
    *((_DWORD *)v88 + 20) = 1065353216;
    v88[23] = 0LL;
    *(_OWORD *)(v88 + 21) = 0u;
    *(_OWORD *)(v88 + 19) = 0u;
    *(_OWORD *)(v88 + 17) = 0u;
    *(_OWORD *)(v88 + 15) = 0u;
    *(_OWORD *)(v88 + 13) = 0u;
    *((_DWORD *)v88 + 4_Block_object_dispose(va, 8) = 1065353216;
    *(_OWORD *)(v88 + 25) = 0u;
    v405 = (void **)(v88 + 25);
    *(_OWORD *)(v88 + 27) = 0u;
    *(_OWORD *)(v88 + 29) = 0u;
    v88[31] = &v413;
    v88[32] = v89;
    id v90 = v420[1];
    uint64_t v91 = *((void *)v420[1] + 2);
    id v379 = v89;
    if (v89)
    {
      int64_t v92 = (char *)objc_claimAutoreleasedReturnValue([v89 isaForDiassemblyAtAddressStart:0 end:v91]);
      int v93 = v88[5];
      id v94 = (_BYTE *)v88[3];
    }

    else
    {
      id v94 = 0LL;
      int v93 = 0LL;
      int64_t v92 = 0LL;
    }

    if (0x8E38E38E38E38E39LL * ((v93 - (uint64_t)v94) >> 2) <= 2)
    {
      int v95 = (_BYTE *)v88[4];
      uint64_t v96 = (char *)operator new(0x6CuLL);
      unint64_t v97 = &v96[36 * ((v95 - v94) / 36)];
      unsigned __int32 v98 = v97;
      if (v95 != v94)
      {
        unint64_t v99 = &v96[36 * ((v95 - v94) / 36)];
        do
        {
          uint64_t v100 = *(_OWORD *)(v95 - 36);
          id v101 = *(_OWORD *)(v95 - 20);
          unsigned __int32 v98 = v99 - 36;
          *((_DWORD *)v99 - 1) = *((_DWORD *)v95 - 1);
          *(_OWORD *)(v99 - 20) = v101;
          *(_OWORD *)(v99 - 36) = v100;
          v95 -= 36;
          v99 -= 36;
        }

        while (v95 != v94);
      }

      v88[3] = v98;
      void v88[4] = v97;
      v88[5] = v96 + 108;
      if (v94) {
        operator delete(v94);
      }
    }

    id v463 = (unint64_t)v90;
    if (v91)
    {
      id v409 = v88 + 6;
      v384 = v88 + 8;
      uint64_t v102 = v90;
      id v392 = v90;
      __s1 = v92;
      v389 = v91;
      while (1)
      {
        (*(void (**)(_BYTE *__return_ptr))(*(void *)v102 + 24LL))(v452);
        unint64_t v103 = *(unint64_t **)v452;
        if ((v452[8] & 1) != 0)
        {
          fwrite("Unexpected instruction found", 0x1CuLL, 1uLL, __stderrp);
          if (v103) {
            (*(void (**)(unint64_t *))(*v103 + 8))(v103);
          }
          goto LABEL_262;
        }

        if (*(void *)v452) {
          break;
        }
LABEL_254:
        llvm::agxclauseanalyzer::AnalyzerInput::InstIteratorImpl<llvm::agxclauseanalyzer::AnalyzerInput>::operator++(&v463);
        uint64_t v102 = (llvm::MCContext *)v463;
        if ((llvm::MCContext *)v463 == v90 && *((void *)&v463 + 1) == v91) {
          goto LABEL_262;
        }
      }

      int v104 = (*(uint64_t (**)(void, uint64_t))(**(void **)(v88[31] + 112LL) + 16LL))( *(void *)(v88[31] + 112LL),  *(void *)v452 + 24LL);
      if ((_DWORD)v104 == -1 || (v104 & 0xFF00000000LL) == 0) {
        uint64_t v106 = 1;
      }
      else {
        uint64_t v106 = v104;
      }
      id v406 = v106;
      std::string::basic_string[abi:nn180100]<0>(v452, "");
      uint64_t v107 = GTShaderProfilerLLVMTargetClauseAnalysis::addString((uint64_t)v88, (__int128 *)v452);
      if ((v452[23] & 0x80000000) != 0) {
        operator delete(*(void **)v452);
      }
      if (*(void *)(v88[31] + 72) && (!v92 || ![v92 count]))
      {
        memset(v425, 0, 24);
        *(_DWORD *)&v452[8] = 0;
        unsigned int v454 = 0;
        id v455 = 0LL;
        id v456 = 1;
        v453 = 0LL;
        *(_OWORD *)&v452[16] = 0uLL;
        __str = (std::string *)v425;
        llvm::raw_ostream::SetUnbuffered((llvm::raw_ostream *)v452);
        (*(void (**)(void, unint64_t *, void, const char *, void, void, _BYTE *))(**(void **)(v88[31] + 72LL) + 32LL))( *(void *)(v88[31] + 72LL),  v103 + 3,  0LL,  "",  0LL,  *(void *)(v88[31] + 64LL),  v452);
        std::string::operator=((std::string *)v425, __str);
        id v108 = v425[23];
        if (v425[23] >= 0) {
          __int8 v109 = v425;
        }
        else {
          __int8 v109 = *(_BYTE **)v425;
        }
        if (v425[23] < 0) {
          id v108 = *(void *)&v425[8];
        }
        if (v108)
        {
          uint64_t v110 = v109;
          while (*v110 == 9)
          {
            ++v110;
            if (!--v108) {
              goto LABEL_193;
            }
          }

          if (v110 - v109 != -1) {
            std::string::erase((std::string *)v425, 0LL, v110 - v109);
          }
        }

LABEL_209:
  lldb::SBCompileUnit::~SBCompileUnit((lldb::SBCompileUnit *)&v226);
LABEL_210:
  lldb::SBModule::~SBModule((lldb::SBModule *)v227);
  lldb::SBFileSpec::~SBFileSpec((lldb::SBFileSpec *)v228);
LABEL_211:
  lldb::SBTarget::~SBTarget((lldb::SBTarget *)v229);
  uint64_t v24 = v184;
LABEL_212:
  lldb::SBDebugger::~SBDebugger((lldb::SBDebugger *)v230);
  GTScopeFunction::~GTScopeFunction((GTScopeFunction *)v235);
LABEL_213:

  int v10 = v182;
  id v13 = v183;
LABEL_214:

LABEL_215:
  return result;
}

      uint64_t v155 = std::__hash_table<std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,GTEncoderSampleIndexInfo>>>::find<unsigned int>( (void *)a1 + 5 * v153 + 23,  v150);
      if (v155)
      {
        uint64_t v156 = v155[4];
        if (v156 == -1LL)
        {
          uint64_t v156 = v155[3];
          if (v156 <= *(void *)(v231 + 8)) {
            uint64_t v156 = *(void *)(v231 + 8);
          }
        }

        else if (v156 >= *(void *)(v231 + 8))
        {
          uint64_t v156 = *(void *)(v231 + 8);
        }

        uint64_t v157 = (unint64_t *)(*(void *)v246 + 8LL * (v149 - 1));
        do
        {
          if (!--v149) {
            break;
          }
          uint64_t v158 = *v157--;
        }

        while (v158 >= v156);
        uint64_t v154 = *v147 & 0x7FFFFFFFFFLL | ((unint64_t)v149 << 39);
        goto LABEL_220;
      }

void sub_BE2E0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, void *a11, void *a12, void *a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17, uint64_t a18, uint64_t a19, void *a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, void *a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t *a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, uint64_t a41, uint64_t a42, uint64_t a43, uint64_t a44, void *a45, uint64_t a46, uint64_t a47, uint64_t a48, uint64_t a49, uint64_t a50,void *__p,uint64_t a52,int a53,__int16 a54,char a55,char a56,uint64_t a57,uint64_t a58,char a59,int a60,__int16 a61,uint64_t a62,char a63)
{
  if (a56 < 0) {
    operator delete(__p);
  }
  lldb::SBCompileUnit::~SBCompileUnit((lldb::SBCompileUnit *)&a59);
  lldb::SBModule::~SBModule((lldb::SBModule *)&a61);
  lldb::SBFileSpec::~SBFileSpec((lldb::SBFileSpec *)&a63);
  lldb::SBTarget::~SBTarget((lldb::SBTarget *)&a65);
  lldb::SBDebugger::~SBDebugger((lldb::SBDebugger *)&a67);
  GTScopeFunction::~GTScopeFunction((GTScopeFunction *)&a72);

  a72 = a19;
  std::vector<DebugInfo::LineDisassemblyInfo>::__destroy_vector::operator()[abi:nn180100]((void ***)&a72);
  a72 = a25;
  std::vector<DebugInfo::LineEntry>::__destroy_vector::operator()[abi:nn180100]((void ***)&a72);

  _Unwind_Resume(a1);
}

void sub_BEDE4( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19)
{
  *(void *)(v20 - 8_Block_object_dispose(va, 8) = &a19;
  std::vector<std::vector<ProfileEvent>>::__destroy_vector::operator()[abi:nn180100]((void ***)(v20 - 88));
  if (v19) {
    operator delete(v19);
  }
  _Unwind_Resume(a1);
}

LABEL_147:
            if ((v48 & (v48 - 1)) != 0)
            {
              if (v48 <= a8) {
                id v15 = a8 % v48;
              }
              else {
                id v15 = a8;
              }
            }

            else
            {
              id v15 = ((_DWORD)v48 - 1) & a8;
            }

            goto LABEL_152;
          }

          uint64_t v47 = *(void *)(*i + 8);
          if ((v21 & (v21 - 1)) != 0)
          {
            if (v47 >= v21) {
              v47 %= v21;
            }
          }

          else
          {
            v47 &= v21 - 1;
          }

          unsigned int v46 = (void *)(*(void *)a4 + 8 * v47);
        }

        FILE *v46 = i;
        goto LABEL_89;
      }

      uint64_t v32 = (v21 & (v21 - 1)) != 0;
      if (v21 < 3) {
        uint64_t v32 = 1LL;
      }
      id v33 = v32 | (2 * v21);
      __int128 v34 = vcvtps_u32_f32(v30 / v31);
      if (v33 <= v34) {
        id v15 = v34;
      }
      else {
        id v15 = v33;
      }
      if (v15 == 1)
      {
        id v15 = 2LL;
      }

      else if ((v15 & (v15 - 1)) != 0)
      {
        id v15 = std::__next_prime(v15);
      }

      unsigned __int16 v21 = *((void *)a4 + 1);
      if (v15 > v21) {
        goto LABEL_46;
      }
      if (v15 < v21)
      {
        unsigned __int16 v41 = vcvtps_u32_f32((float)*((unint64_t *)a4 + 3) / *((float *)a4 + 8));
        if (v21 < 3 || (unsigned int v42 = (uint8x8_t)vcnt_s8((int8x8_t)v21), v42.i16[0] = vaddlv_u8(v42), v42.u32[0] > 1uLL))
        {
          unsigned __int16 v41 = std::__next_prime(v41);
        }

        else
        {
          id v43 = 1LL << -(char)__clz(v41 - 1);
          if (v41 >= 2) {
            unsigned __int16 v41 = v43;
          }
        }

        if (v15 <= v41) {
          id v15 = v41;
        }
        if (v15 >= v21)
        {
          unsigned __int16 v21 = *((void *)a4 + 1);
        }

        else
        {
          if (v15)
          {
LABEL_46:
            if (v15 >> 61) {
              std::__throw_bad_array_new_length[abi:nn180100]();
            }
            __int128 v35 = operator new(8 * v15);
            __int128 v36 = *(void **)a4;
            *(void *)a4 = v35;
            if (v36) {
              operator delete(v36);
            }
            __int128 v37 = 0LL;
            *((void *)a4 + 1) = v15;
            do
              *(void *)(*(void *)a4 + 8 * v37++) = 0LL;
            while (v15 != v37);
            unint64_t v38 = (void *)*v95;
            if (*v95)
            {
              unsigned int v39 = v38[1];
              uint64_t v40 = (uint8x8_t)vcnt_s8((int8x8_t)v15);
              v40.i16[0] = vaddlv_u8(v40);
              if (v40.u32[0] > 1uLL)
              {
                if (v39 >= v15) {
                  v39 %= v15;
                }
              }

              else
              {
                v39 &= v15 - 1;
              }

              *(void *)(*(void *)a4 + 8 * v39) = v95;
              uint64_t v44 = (void *)*v38;
              if (*v38)
              {
                do
                {
                  unint64_t v45 = v44[1];
                  if (v40.u32[0] > 1uLL)
                  {
                    if (v45 >= v15) {
                      v45 %= v15;
                    }
                  }

                  else
                  {
                    v45 &= v15 - 1;
                  }

                  if (v45 != v39)
                  {
                    if (!*(void *)(*(void *)a4 + 8 * v45))
                    {
                      *(void *)(*(void *)a4 + 8 * v45) = v38;
                      goto LABEL_71;
                    }

                    *unint64_t v38 = *v44;
                    void *v44 = **(void **)(*(void *)a4 + 8 * v45);
                    **(void **)(*(void *)a4 + 8 * v45) = v44;
                    uint64_t v44 = v38;
                  }

                  unint64_t v45 = v39;
LABEL_71:
                  unint64_t v38 = v44;
                  uint64_t v44 = (void *)*v44;
                  unsigned int v39 = v45;
                }

                while (v44);
              }
            }

            unsigned __int16 v21 = v15;
            goto LABEL_75;
          }

          unint64_t v87 = *(void **)a4;
          *(void *)a4 = 0LL;
          if (v87) {
            operator delete(v87);
          }
          unsigned __int16 v21 = 0LL;
          *((void *)a4 + 1) = 0LL;
        }
      }

    uint64_t v248 = 0u;
    v247 = 0u;
    uint64_t v250 = 0u;
    BOOL v251 = 0u;
    LODWORD(v249) = 1065353216;
    uint64_t v252 = 1065353216;
    __int128 v230 = 0u;
    __int128 v231 = 0u;
    uint64_t v235 = 1LL;
    uint64_t v232 = 1065353216;
    std::unordered_map<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,std::allocator<std::pair<FunctionHandleKey const,objc_object  {objcproto17MTLFunctionHandle}*>>>::unordered_map( (uint64_t)&v236,  (uint64_t)&v230);
    id v227 = 0u;
    __int128 v228 = 0u;
    id v229 = 1065353216;
    unint64_t v239 = 2LL;
    std::unordered_map<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,std::allocator<std::pair<FunctionHandleKey const,objc_object  {objcproto17MTLFunctionHandle}*>>>::unordered_map( (uint64_t)v240,  (uint64_t)&v227);
    unint64_t v224 = 0u;
    __int128 v225 = 0u;
    __int128 v226 = 1065353216;
    id v241 = 4LL;
    std::unordered_map<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,std::allocator<std::pair<FunctionHandleKey const,objc_object  {objcproto17MTLFunctionHandle}*>>>::unordered_map( (uint64_t)v242,  (uint64_t)&v224);
    __int128 v221 = 0u;
    __int128 v222 = 0u;
    __int128 v223 = 1065353216;
    id v243 = 16LL;
    std::unordered_map<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,std::allocator<std::pair<FunctionHandleKey const,objc_object  {objcproto17MTLFunctionHandle}*>>>::unordered_map( (uint64_t)v244,  (uint64_t)&v221);
    __int128 v218 = 0u;
    unint64_t v219 = 0u;
    __int128 v220 = 1065353216;
    id v245 = 8LL;
    std::unordered_map<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,std::allocator<std::pair<FunctionHandleKey const,objc_object  {objcproto17MTLFunctionHandle}*>>>::unordered_map( (uint64_t)v246,  (uint64_t)&v218);
    std::unordered_map<unsigned long,std::unordered_map<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,std::allocator<std::pair<FunctionHandleKey const,objc_object  {objcproto17MTLFunctionHandle}*>>>,std::hash<unsigned long>,FunctionHandleKeyHash<unsigned long>,std::equal_to<FunctionHandleKey><std::allocator<unsigned long const>>>::unordered_map( (uint64_t)v253,  (unint64_t *)&v235,  5LL);
    for (i4 = 200LL; i4 != -40; i4 -= 48LL)
      std::__hash_table<std::__hash_value_type<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong}>,std::__unordered_map_hasher<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,true>,std::__unordered_map_equal<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},std::equal_to,std::__unordered_map_hasher,true>,std::allocator<objc_object  {objcproto17MTLFunctionHandle}* {__strong}>>::~__hash_table((uint64_t)&v235 + i4);
    std::__hash_table<std::__hash_value_type<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong}>,std::__unordered_map_hasher<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,true>,std::__unordered_map_equal<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},std::equal_to,std::__unordered_map_hasher,true>,std::allocator<objc_object  {objcproto17MTLFunctionHandle}* {__strong}>>::~__hash_table((uint64_t)&v218);
    std::__hash_table<std::__hash_value_type<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong}>,std::__unordered_map_hasher<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,true>,std::__unordered_map_equal<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},std::equal_to,std::__unordered_map_hasher,true>,std::allocator<objc_object  {objcproto17MTLFunctionHandle}* {__strong}>>::~__hash_table((uint64_t)&v221);
    std::__hash_table<std::__hash_value_type<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong}>,std::__unordered_map_hasher<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,true>,std::__unordered_map_equal<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},std::equal_to,std::__unordered_map_hasher,true>,std::allocator<objc_object  {objcproto17MTLFunctionHandle}* {__strong}>>::~__hash_table((uint64_t)&v224);
    std::__hash_table<std::__hash_value_type<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong}>,std::__unordered_map_hasher<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,true>,std::__unordered_map_equal<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},std::equal_to,std::__unordered_map_hasher,true>,std::allocator<objc_object  {objcproto17MTLFunctionHandle}* {__strong}>>::~__hash_table((uint64_t)&v227);
    std::__hash_table<std::__hash_value_type<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong}>,std::__unordered_map_hasher<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,true>,std::__unordered_map_equal<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},std::equal_to,std::__unordered_map_hasher,true>,std::allocator<objc_object  {objcproto17MTLFunctionHandle}* {__strong}>>::~__hash_table((uint64_t)&v230);
    uint64_t v254 = 0u;
    v255 = 0u;
    v256 = 1065353216;
    uint64_t v257 = 0u;
    uint64_t v258 = 0u;
    uint64_t v260 = 0u;
    uint64_t v261 = 0u;
    v259 = 1065353216;
    v262 = 1065353216;
    unint64_t v148 = (void *)objc_claimAutoreleasedReturnValue([a1->var1 defaultDevice]);
    unint64_t v149 = ObtainResourceTrackingTracingBufferV2(v148, v233);
    uint64_t v263 = (id)objc_claimAutoreleasedReturnValue(v149);
    v264 = 2LL;
    v265 = 0x100000008LL;

    uint64_t v150 = newpool;
    InstrumentFunctionWithResourceTrackingV2((uint64_t)&v235, a1, a2, (uint64_t)&v247, (uint64_t)v233, newpool);
    id v108 = (_BYTE)v235 != 0;
    ReplaceFunctionTablesWithRegular((uint64_t)v212, (uint64_t)a1, 8, *(void *)a2, v233, v150);
    std::__hash_table<std::__hash_value_type<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>,std::__unordered_map_hasher<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::equal_to,std::hash,true>,std::allocator<objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>>::~__hash_table((uint64_t)&v213);
    std::__hash_table<std::__hash_value_type<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>,std::__unordered_map_hasher<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::equal_to,std::hash,true>,std::allocator<objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>>::~__hash_table((uint64_t)v212);
    uint64_t v151 = objc_alloc(&OBJC_CLASS___NSMutableArray);
    uint64_t v152 = v237;
    uint64_t v153 = v236;
    unint64_t v123 = -[NSMutableArray initWithCapacity:](v151, "initWithCapacity:", 0xAAAAAAAAAAAAAAABLL * ((v237 - v236) >> 3));
    if (v153 != v152)
    {
      uint64_t v154 = v153;
      do
      {
        __int128 v230 = *(_OWORD *)v154;
        *(void *)&__int128 v231 = v154[2];
        uint64_t v155 = MakeResourceUsageItem((uint64_t)&v230);
        uint64_t v156 = (void *)objc_claimAutoreleasedReturnValue(v155);
        -[NSMutableArray addObject:](v123, "addObject:", v156);

        v154 += 3;
      }

      while (v154 != v152);
    }

    if (v153) {
      operator delete(v153);
    }

    goto LABEL_155;
  }

  if (v97 == -15297) {
    goto LABEL_139;
  }
  __int8 v109 = -15486;
LABEL_138:
  if (v97 != v109)
  {
    if ((v97 & 0xFFFFFFFE) == 0xFFFFC1A4)
    {
      __int128 v169 = v96;
      uint64_t v248 = 0u;
      v247 = 0u;
      uint64_t v250 = 0u;
      BOOL v251 = 0u;
      LODWORD(v249) = 1065353216;
      uint64_t v252 = 1065353216;
      __int128 v230 = 0u;
      __int128 v231 = 0u;
      uint64_t v235 = 1LL;
      uint64_t v232 = 1065353216;
      std::unordered_map<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,std::allocator<std::pair<FunctionHandleKey const,objc_object  {objcproto17MTLFunctionHandle}*>>>::unordered_map( (uint64_t)&v236,  (uint64_t)&v230);
      id v227 = 0u;
      __int128 v228 = 0u;
      id v229 = 1065353216;
      unint64_t v239 = 2LL;
      std::unordered_map<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,std::allocator<std::pair<FunctionHandleKey const,objc_object  {objcproto17MTLFunctionHandle}*>>>::unordered_map( (uint64_t)v240,  (uint64_t)&v227);
      unint64_t v224 = 0u;
      __int128 v225 = 0u;
      __int128 v226 = 1065353216;
      id v241 = 4LL;
      std::unordered_map<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,std::allocator<std::pair<FunctionHandleKey const,objc_object  {objcproto17MTLFunctionHandle}*>>>::unordered_map( (uint64_t)v242,  (uint64_t)&v224);
      __int128 v221 = 0u;
      __int128 v222 = 0u;
      __int128 v223 = 1065353216;
      id v243 = 16LL;
      std::unordered_map<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,std::allocator<std::pair<FunctionHandleKey const,objc_object  {objcproto17MTLFunctionHandle}*>>>::unordered_map( (uint64_t)v244,  (uint64_t)&v221);
      __int128 v218 = 0u;
      unint64_t v219 = 0u;
      __int128 v220 = 1065353216;
      id v245 = 8LL;
      std::unordered_map<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,std::allocator<std::pair<FunctionHandleKey const,objc_object  {objcproto17MTLFunctionHandle}*>>>::unordered_map( (uint64_t)v246,  (uint64_t)&v218);
      std::unordered_map<unsigned long,std::unordered_map<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,std::allocator<std::pair<FunctionHandleKey const,objc_object  {objcproto17MTLFunctionHandle}*>>>,std::hash<unsigned long>,FunctionHandleKeyHash<unsigned long>,std::equal_to<FunctionHandleKey><std::allocator<unsigned long const>>>::unordered_map( (uint64_t)v253,  (unint64_t *)&v235,  5LL);
      for (i5 = 200LL; i5 != -40; i5 -= 48LL)
        std::__hash_table<std::__hash_value_type<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong}>,std::__unordered_map_hasher<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,true>,std::__unordered_map_equal<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},std::equal_to,std::__unordered_map_hasher,true>,std::allocator<objc_object  {objcproto17MTLFunctionHandle}* {__strong}>>::~__hash_table((uint64_t)&v235 + i5);
      std::__hash_table<std::__hash_value_type<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong}>,std::__unordered_map_hasher<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,true>,std::__unordered_map_equal<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},std::equal_to,std::__unordered_map_hasher,true>,std::allocator<objc_object  {objcproto17MTLFunctionHandle}* {__strong}>>::~__hash_table((uint64_t)&v218);
      std::__hash_table<std::__hash_value_type<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong}>,std::__unordered_map_hasher<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,true>,std::__unordered_map_equal<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},std::equal_to,std::__unordered_map_hasher,true>,std::allocator<objc_object  {objcproto17MTLFunctionHandle}* {__strong}>>::~__hash_table((uint64_t)&v221);
      std::__hash_table<std::__hash_value_type<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong}>,std::__unordered_map_hasher<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,true>,std::__unordered_map_equal<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},std::equal_to,std::__unordered_map_hasher,true>,std::allocator<objc_object  {objcproto17MTLFunctionHandle}* {__strong}>>::~__hash_table((uint64_t)&v224);
      std::__hash_table<std::__hash_value_type<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong}>,std::__unordered_map_hasher<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,true>,std::__unordered_map_equal<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},std::equal_to,std::__unordered_map_hasher,true>,std::allocator<objc_object  {objcproto17MTLFunctionHandle}* {__strong}>>::~__hash_table((uint64_t)&v227);
      std::__hash_table<std::__hash_value_type<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong}>,std::__unordered_map_hasher<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,true>,std::__unordered_map_equal<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},std::equal_to,std::__unordered_map_hasher,true>,std::allocator<objc_object  {objcproto17MTLFunctionHandle}* {__strong}>>::~__hash_table((uint64_t)&v230);
      uint64_t v254 = 0u;
      v255 = 0u;
      v256 = 1065353216;
      uint64_t v257 = 0u;
      uint64_t v258 = 0u;
      uint64_t v260 = 0u;
      uint64_t v261 = 0u;
      v259 = 1065353216;
      v262 = 1065353216;
      __int128 v171 = (void *)objc_claimAutoreleasedReturnValue([a1->var1 defaultDevice]);
      __int128 v172 = ObtainResourceTrackingTracingBufferV2(v171, v233);
      uint64_t v263 = (id)objc_claimAutoreleasedReturnValue(v172);
      v264 = 2LL;
      v265 = 8LL;

      __int128 v173 = newpool;
      InstrumentSubCommandWithAccessTrackingV2((uint64_t)&v235, a1, a2, a3, (uint64_t)&v247, v233, newpool);
      id v108 = (_BYTE)v235 != 0;
      ReplaceFunctionTablesWithRegular((uint64_t)v208, (uint64_t)a1, 8, *(void *)a2, v233, v173);
      std::__hash_table<std::__hash_value_type<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>,std::__unordered_map_hasher<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::equal_to,std::hash,true>,std::allocator<objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>>::~__hash_table((uint64_t)&v209);
      std::__hash_table<std::__hash_value_type<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>,std::__unordered_map_hasher<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::equal_to,std::hash,true>,std::allocator<objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>>::~__hash_table((uint64_t)v208);
      __int128 v174 = objc_alloc(&OBJC_CLASS___NSMutableArray);
      uint64_t v175 = v237;
      __int128 v176 = v236;
      unint64_t v123 = -[NSMutableArray initWithCapacity:](v174, "initWithCapacity:", 0xAAAAAAAAAAAAAAABLL * ((v237 - v236) >> 3));
      if (v176 != v175)
      {
        uint64_t v177 = v176;
        do
        {
          __int128 v230 = *(_OWORD *)v177;
          *(void *)&__int128 v231 = v177[2];
          uint64_t v178 = MakeResourceUsageItem((uint64_t)&v230);
          uint64_t v179 = (void *)objc_claimAutoreleasedReturnValue(v178);
          -[NSMutableArray addObject:](v123, "addObject:", v179);

          v177 += 3;
        }

        while (v177 != v175);
      }

      if (v176) {
        operator delete(v176);
      }
      GTMTLReplayAccessTracking::~GTMTLReplayAccessTracking((id *)&v247);
      uint64_t v96 = v169;
      goto LABEL_157;
    }

    if ((v97 & 0xFFFFFFFE) != 0xFFFFC1A6)
    {
      id v108 = 0LL;
      unint64_t v123 = 0LL;
      goto LABEL_157;
    }

    uint64_t v159 = (void *)objc_claimAutoreleasedReturnValue([a1->var1 defaultDevice]);
    uint64_t v160 = ObtainResourceTrackingTracingBufferV2(v159, v233);
    uint64_t v161 = (void *)objc_claimAutoreleasedReturnValue(v160);

    __pa = v161;
    if (*(_DWORD *)(a2 + 8) >> 2 == 1073737833)
    {
      uint64_t v162 = a1->var0;
      uint64_t v163 = a1->var1;
      GetExecuteCommandsInBufferArgs((uint64_t)&v235, a2, (uint64_t)v162->var2);
      uint64_t v164 = GTMTLSMContext_getObject(*(void *)v162->var5, v235, *(void *)a2);
      GTMTLCreateIndirectCommandEncoder((uint64_t)&v247, v164[13]);
      if ((unint64_t)v236 <= a3 && &v236[(void)v237] >= (char *)a3 && v238)
      {
        __int128 v165 = (*(void *)(v238 + v253[3] * a3 + *((void *)&v247 + 1)) - 128LL) & 0xFFFFFFFFFFFFFF7FLL;

        if (!v165)
        {
          if (ShouldInstrumentICBObjectStage((uint64_t *)a1, a2, a3))
          {
            uint64_t v248 = 0u;
            v247 = 0u;
            uint64_t v250 = 0u;
            BOOL v251 = 0u;
            LODWORD(v249) = 1065353216;
            uint64_t v252 = 1065353216;
            __int128 v230 = 0u;
            __int128 v231 = 0u;
            uint64_t v235 = 1LL;
            uint64_t v232 = 1065353216;
            std::unordered_map<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,std::allocator<std::pair<FunctionHandleKey const,objc_object  {objcproto17MTLFunctionHandle}*>>>::unordered_map( (uint64_t)&v236,  (uint64_t)&v230);
            id v227 = 0u;
            __int128 v228 = 0u;
            id v229 = 1065353216;
            unint64_t v239 = 2LL;
            std::unordered_map<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,std::allocator<std::pair<FunctionHandleKey const,objc_object  {objcproto17MTLFunctionHandle}*>>>::unordered_map( (uint64_t)v240,  (uint64_t)&v227);
            unint64_t v224 = 0u;
            __int128 v225 = 0u;
            __int128 v226 = 1065353216;
            id v241 = 4LL;
            std::unordered_map<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,std::allocator<std::pair<FunctionHandleKey const,objc_object  {objcproto17MTLFunctionHandle}*>>>::unordered_map( (uint64_t)v242,  (uint64_t)&v224);
            __int128 v221 = 0u;
            __int128 v222 = 0u;
            __int128 v223 = 1065353216;
            id v243 = 16LL;
            std::unordered_map<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,std::allocator<std::pair<FunctionHandleKey const,objc_object  {objcproto17MTLFunctionHandle}*>>>::unordered_map( (uint64_t)v244,  (uint64_t)&v221);
            __int128 v218 = 0u;
            unint64_t v219 = 0u;
            __int128 v220 = 1065353216;
            id v245 = 8LL;
            std::unordered_map<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,std::allocator<std::pair<FunctionHandleKey const,objc_object  {objcproto17MTLFunctionHandle}*>>>::unordered_map( (uint64_t)v246,  (uint64_t)&v218);
            std::unordered_map<unsigned long,std::unordered_map<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,std::allocator<std::pair<FunctionHandleKey const,objc_object  {objcproto17MTLFunctionHandle}*>>>,std::hash<unsigned long>,FunctionHandleKeyHash<unsigned long>,std::equal_to<FunctionHandleKey><std::allocator<unsigned long const>>>::unordered_map( (uint64_t)v253,  (unint64_t *)&v235,  5LL);
            for (i6 = 200LL; i6 != -40; i6 -= 48LL)
              std::__hash_table<std::__hash_value_type<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong}>,std::__unordered_map_hasher<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,true>,std::__unordered_map_equal<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},std::equal_to,std::__unordered_map_hasher,true>,std::allocator<objc_object  {objcproto17MTLFunctionHandle}* {__strong}>>::~__hash_table((uint64_t)&v235 + i6);
            std::__hash_table<std::__hash_value_type<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong}>,std::__unordered_map_hasher<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,true>,std::__unordered_map_equal<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},std::equal_to,std::__unordered_map_hasher,true>,std::allocator<objc_object  {objcproto17MTLFunctionHandle}* {__strong}>>::~__hash_table((uint64_t)&v218);
            std::__hash_table<std::__hash_value_type<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong}>,std::__unordered_map_hasher<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,true>,std::__unordered_map_equal<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},std::equal_to,std::__unordered_map_hasher,true>,std::allocator<objc_object  {objcproto17MTLFunctionHandle}* {__strong}>>::~__hash_table((uint64_t)&v221);
            std::__hash_table<std::__hash_value_type<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong}>,std::__unordered_map_hasher<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,true>,std::__unordered_map_equal<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},std::equal_to,std::__unordered_map_hasher,true>,std::allocator<objc_object  {objcproto17MTLFunctionHandle}* {__strong}>>::~__hash_table((uint64_t)&v224);
            std::__hash_table<std::__hash_value_type<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong}>,std::__unordered_map_hasher<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,true>,std::__unordered_map_equal<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},std::equal_to,std::__unordered_map_hasher,true>,std::allocator<objc_object  {objcproto17MTLFunctionHandle}* {__strong}>>::~__hash_table((uint64_t)&v227);
            std::__hash_table<std::__hash_value_type<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong}>,std::__unordered_map_hasher<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,true>,std::__unordered_map_equal<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},std::equal_to,std::__unordered_map_hasher,true>,std::allocator<objc_object  {objcproto17MTLFunctionHandle}* {__strong}>>::~__hash_table((uint64_t)&v230);
            uint64_t v254 = 0u;
            v255 = 0u;
            v256 = 1065353216;
            uint64_t v257 = 0u;
            uint64_t v258 = 0u;
            uint64_t v260 = 0u;
            uint64_t v261 = 0u;
            v259 = 1065353216;
            v262 = 1065353216;
            uint64_t v263 = v161;
            v264 = 2LL;
            v265 = 16LL;
            InstrumentSubCommandWithAccessTrackingV2((uint64_t)&v235, a1, a2, a3, (uint64_t)&v247, v233, newpool);
            __int128 v167 = (_BYTE)v235 != 0;
            uint64_t v168 = v236;
            GTMTLReplayAccessTracking::~GTMTLReplayAccessTracking((id *)&v247);
          }

          else
          {
            uint64_t v168 = 0LL;
            __int128 v167 = 1;
          }

          uint64_t v248 = 0u;
          v247 = 0u;
          uint64_t v250 = 0u;
          BOOL v251 = 0u;
          LODWORD(v249) = 1065353216;
          uint64_t v252 = 1065353216;
          __int128 v230 = 0u;
          __int128 v231 = 0u;
          uint64_t v235 = 1LL;
          uint64_t v232 = 1065353216;
          std::unordered_map<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,std::allocator<std::pair<FunctionHandleKey const,objc_object  {objcproto17MTLFunctionHandle}*>>>::unordered_map( (uint64_t)&v236,  (uint64_t)&v230);
          id v227 = 0u;
          __int128 v228 = 0u;
          id v229 = 1065353216;
          unint64_t v239 = 2LL;
          std::unordered_map<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,std::allocator<std::pair<FunctionHandleKey const,objc_object  {objcproto17MTLFunctionHandle}*>>>::unordered_map( (uint64_t)v240,  (uint64_t)&v227);
          unint64_t v224 = 0u;
          __int128 v225 = 0u;
          __int128 v226 = 1065353216;
          id v241 = 4LL;
          std::unordered_map<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,std::allocator<std::pair<FunctionHandleKey const,objc_object  {objcproto17MTLFunctionHandle}*>>>::unordered_map( (uint64_t)v242,  (uint64_t)&v224);
          __int128 v221 = 0u;
          __int128 v222 = 0u;
          __int128 v223 = 1065353216;
          id v243 = 16LL;
          std::unordered_map<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,std::allocator<std::pair<FunctionHandleKey const,objc_object  {objcproto17MTLFunctionHandle}*>>>::unordered_map( (uint64_t)v244,  (uint64_t)&v221);
          __int128 v218 = 0u;
          unint64_t v219 = 0u;
          __int128 v220 = 1065353216;
          id v245 = 8LL;
          std::unordered_map<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,std::allocator<std::pair<FunctionHandleKey const,objc_object  {objcproto17MTLFunctionHandle}*>>>::unordered_map( (uint64_t)v246,  (uint64_t)&v218);
          std::unordered_map<unsigned long,std::unordered_map<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,std::allocator<std::pair<FunctionHandleKey const,objc_object  {objcproto17MTLFunctionHandle}*>>>,std::hash<unsigned long>,FunctionHandleKeyHash<unsigned long>,std::equal_to<FunctionHandleKey><std::allocator<unsigned long const>>>::unordered_map( (uint64_t)v253,  (unint64_t *)&v235,  5LL);
          for (i7 = 200LL; i7 != -40; i7 -= 48LL)
            std::__hash_table<std::__hash_value_type<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong}>,std::__unordered_map_hasher<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,true>,std::__unordered_map_equal<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},std::equal_to,std::__unordered_map_hasher,true>,std::allocator<objc_object  {objcproto17MTLFunctionHandle}* {__strong}>>::~__hash_table((uint64_t)&v235 + i7);
          std::__hash_table<std::__hash_value_type<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong}>,std::__unordered_map_hasher<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,true>,std::__unordered_map_equal<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},std::equal_to,std::__unordered_map_hasher,true>,std::allocator<objc_object  {objcproto17MTLFunctionHandle}* {__strong}>>::~__hash_table((uint64_t)&v218);
          std::__hash_table<std::__hash_value_type<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong}>,std::__unordered_map_hasher<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,true>,std::__unordered_map_equal<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},std::equal_to,std::__unordered_map_hasher,true>,std::allocator<objc_object  {objcproto17MTLFunctionHandle}* {__strong}>>::~__hash_table((uint64_t)&v221);
          std::__hash_table<std::__hash_value_type<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong}>,std::__unordered_map_hasher<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,true>,std::__unordered_map_equal<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},std::equal_to,std::__unordered_map_hasher,true>,std::allocator<objc_object  {objcproto17MTLFunctionHandle}* {__strong}>>::~__hash_table((uint64_t)&v224);
          std::__hash_table<std::__hash_value_type<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong}>,std::__unordered_map_hasher<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,true>,std::__unordered_map_equal<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},std::equal_to,std::__unordered_map_hasher,true>,std::allocator<objc_object  {objcproto17MTLFunctionHandle}* {__strong}>>::~__hash_table((uint64_t)&v227);
          std::__hash_table<std::__hash_value_type<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong}>,std::__unordered_map_hasher<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,true>,std::__unordered_map_equal<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},std::equal_to,std::__unordered_map_hasher,true>,std::allocator<objc_object  {objcproto17MTLFunctionHandle}* {__strong}>>::~__hash_table((uint64_t)&v230);
          uint64_t v254 = 0u;
          v255 = 0u;
          v256 = 1065353216;
          uint64_t v257 = 0u;
          uint64_t v258 = 0u;
          uint64_t v260 = 0u;
          uint64_t v261 = 0u;
          v259 = 1065353216;
          v262 = 1065353216;
          uint64_t v263 = v161;
          v264 = 2LL;
          v265 = 32LL;
          unint64_t v181 = newpool;
          InstrumentSubCommandWithAccessTrackingV2((uint64_t)&v235, a1, a2, a3, (uint64_t)&v247, v233, newpool);
          if ((_BYTE)v235) {
            uint64_t v184 = v167;
          }
          else {
            uint64_t v184 = 0;
          }
          uint64_t v185 = v236;
          GTMTLReplayAccessTracking::~GTMTLReplayAccessTracking((id *)&v247);
          __int128 v183 = 0LL;
          unint64_t v182 = 0LL;
          goto LABEL_186;
        }
      }

      else
      {
      }
    }

    uint64_t v248 = 0u;
    v247 = 0u;
    uint64_t v250 = 0u;
    BOOL v251 = 0u;
    LODWORD(v249) = 1065353216;
    uint64_t v252 = 1065353216;
    __int128 v230 = 0u;
    __int128 v231 = 0u;
    uint64_t v235 = 1LL;
    uint64_t v232 = 1065353216;
    std::unordered_map<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,std::allocator<std::pair<FunctionHandleKey const,objc_object  {objcproto17MTLFunctionHandle}*>>>::unordered_map( (uint64_t)&v236,  (uint64_t)&v230);
    id v227 = 0u;
    __int128 v228 = 0u;
    id v229 = 1065353216;
    unint64_t v239 = 2LL;
    std::unordered_map<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,std::allocator<std::pair<FunctionHandleKey const,objc_object  {objcproto17MTLFunctionHandle}*>>>::unordered_map( (uint64_t)v240,  (uint64_t)&v227);
    unint64_t v224 = 0u;
    __int128 v225 = 0u;
    __int128 v226 = 1065353216;
    id v241 = 4LL;
    std::unordered_map<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,std::allocator<std::pair<FunctionHandleKey const,objc_object  {objcproto17MTLFunctionHandle}*>>>::unordered_map( (uint64_t)v242,  (uint64_t)&v224);
    __int128 v221 = 0u;
    __int128 v222 = 0u;
    __int128 v223 = 1065353216;
    id v243 = 16LL;
    std::unordered_map<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,std::allocator<std::pair<FunctionHandleKey const,objc_object  {objcproto17MTLFunctionHandle}*>>>::unordered_map( (uint64_t)v244,  (uint64_t)&v221);
    __int128 v218 = 0u;
    unint64_t v219 = 0u;
    __int128 v220 = 1065353216;
    id v245 = 8LL;
    std::unordered_map<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,std::allocator<std::pair<FunctionHandleKey const,objc_object  {objcproto17MTLFunctionHandle}*>>>::unordered_map( (uint64_t)v246,  (uint64_t)&v218);
    std::unordered_map<unsigned long,std::unordered_map<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,std::allocator<std::pair<FunctionHandleKey const,objc_object  {objcproto17MTLFunctionHandle}*>>>,std::hash<unsigned long>,FunctionHandleKeyHash<unsigned long>,std::equal_to<FunctionHandleKey><std::allocator<unsigned long const>>>::unordered_map( (uint64_t)v253,  (unint64_t *)&v235,  5LL);
    for (i8 = 200LL; i8 != -40; i8 -= 48LL)
      std::__hash_table<std::__hash_value_type<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong}>,std::__unordered_map_hasher<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,true>,std::__unordered_map_equal<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},std::equal_to,std::__unordered_map_hasher,true>,std::allocator<objc_object  {objcproto17MTLFunctionHandle}* {__strong}>>::~__hash_table((uint64_t)&v235 + i8);
    std::__hash_table<std::__hash_value_type<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong}>,std::__unordered_map_hasher<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,true>,std::__unordered_map_equal<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},std::equal_to,std::__unordered_map_hasher,true>,std::allocator<objc_object  {objcproto17MTLFunctionHandle}* {__strong}>>::~__hash_table((uint64_t)&v218);
    std::__hash_table<std::__hash_value_type<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong}>,std::__unordered_map_hasher<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,true>,std::__unordered_map_equal<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},std::equal_to,std::__unordered_map_hasher,true>,std::allocator<objc_object  {objcproto17MTLFunctionHandle}* {__strong}>>::~__hash_table((uint64_t)&v221);
    std::__hash_table<std::__hash_value_type<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong}>,std::__unordered_map_hasher<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,true>,std::__unordered_map_equal<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},std::equal_to,std::__unordered_map_hasher,true>,std::allocator<objc_object  {objcproto17MTLFunctionHandle}* {__strong}>>::~__hash_table((uint64_t)&v224);
    std::__hash_table<std::__hash_value_type<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong}>,std::__unordered_map_hasher<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,true>,std::__unordered_map_equal<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},std::equal_to,std::__unordered_map_hasher,true>,std::allocator<objc_object  {objcproto17MTLFunctionHandle}* {__strong}>>::~__hash_table((uint64_t)&v227);
    std::__hash_table<std::__hash_value_type<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong}>,std::__unordered_map_hasher<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,true>,std::__unordered_map_equal<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},std::equal_to,std::__unordered_map_hasher,true>,std::allocator<objc_object  {objcproto17MTLFunctionHandle}* {__strong}>>::~__hash_table((uint64_t)&v230);
    uint64_t v254 = 0u;
    v255 = 0u;
    v256 = 1065353216;
    uint64_t v257 = 0u;
    uint64_t v258 = 0u;
    uint64_t v260 = 0u;
    uint64_t v261 = 0u;
    v259 = 1065353216;
    v262 = 1065353216;
    uint64_t v263 = v161;
    v264 = 2LL;
    v265 = 1LL;
    unint64_t v181 = newpool;
    InstrumentSubCommandWithAccessTrackingV2((uint64_t)&v235, a1, a2, a3, (uint64_t)&v247, v233, newpool);
    unint64_t v182 = v236;
    __int128 v183 = v237;
    uint64_t v184 = v235;

    std::__hash_table<std::__hash_value_type<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong}>,std::__unordered_map_hasher<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,true>,std::__unordered_map_equal<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},std::equal_to,std::__unordered_map_hasher,true>,std::allocator<objc_object  {objcproto17MTLFunctionHandle}* {__strong}>>::~__hash_table((uint64_t)&v260);
    std::__hash_table<std::__hash_value_type<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>,std::__unordered_map_hasher<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::equal_to,std::hash,true>,std::allocator<objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>>::~__hash_table((uint64_t)&v257);
    std::__hash_table<std::__hash_value_type<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>,std::__unordered_map_hasher<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::equal_to,std::hash,true>,std::allocator<objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>>::~__hash_table((uint64_t)&v254);
    std::__hash_table<std::__hash_value_type<unsigned long,std::unordered_map<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,std::allocator<std::pair<FunctionHandleKey const,objc_object  {objcproto17MTLFunctionHandle}*>>>>,std::__unordered_map_hasher<unsigned long,std::unordered_map<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,std::allocator<std::pair<FunctionHandleKey const,objc_object  {objcproto17MTLFunctionHandle}*>>>,std::hash<unsigned long>,FunctionHandleKeyHash<unsigned long>,true>,std::__unordered_map_equal<unsigned long,std::unordered_map<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,std::allocator<std::pair<FunctionHandleKey const,objc_object  {objcproto17MTLFunctionHandle}*>>>,std::hash<unsigned long>,std::hash,true>,std::equal_to<FunctionHandleKey><std::unordered_map<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,std::allocator<std::pair<FunctionHandleKey const,objc_object  {objcproto17MTLFunctionHandle}*>>>>>::~__hash_table((uint64_t)v253);
    std::__hash_table<std::__hash_value_type<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>,std::__unordered_map_hasher<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::equal_to,std::hash,true>,std::allocator<objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>>::~__hash_table((uint64_t)&v250);
    std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long>>>::~__hash_table((uint64_t)&v247);
    uint64_t v185 = 0LL;
    uint64_t v168 = 0LL;
LABEL_186:
    if (ShouldInstrumentFragmentStage((uint64_t *)a1, (uint64_t)v233, a2, a3))
    {
      uint64_t v248 = 0u;
      v247 = 0u;
      uint64_t v250 = 0u;
      BOOL v251 = 0u;
      LODWORD(v249) = 1065353216;
      uint64_t v252 = 1065353216;
      __int128 v230 = 0u;
      __int128 v231 = 0u;
      uint64_t v235 = 1LL;
      uint64_t v232 = 1065353216;
      std::unordered_map<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,std::allocator<std::pair<FunctionHandleKey const,objc_object  {objcproto17MTLFunctionHandle}*>>>::unordered_map( (uint64_t)&v236,  (uint64_t)&v230);
      id v227 = 0u;
      __int128 v228 = 0u;
      id v229 = 1065353216;
      unint64_t v239 = 2LL;
      std::unordered_map<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,std::allocator<std::pair<FunctionHandleKey const,objc_object  {objcproto17MTLFunctionHandle}*>>>::unordered_map( (uint64_t)v240,  (uint64_t)&v227);
      unint64_t v224 = 0u;
      __int128 v225 = 0u;
      __int128 v226 = 1065353216;
      id v241 = 4LL;
      std::unordered_map<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,std::allocator<std::pair<FunctionHandleKey const,objc_object  {objcproto17MTLFunctionHandle}*>>>::unordered_map( (uint64_t)v242,  (uint64_t)&v224);
      __int128 v221 = 0u;
      __int128 v222 = 0u;
      __int128 v223 = 1065353216;
      id v243 = 16LL;
      std::unordered_map<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,std::allocator<std::pair<FunctionHandleKey const,objc_object  {objcproto17MTLFunctionHandle}*>>>::unordered_map( (uint64_t)v244,  (uint64_t)&v221);
      __int128 v218 = 0u;
      unint64_t v219 = 0u;
      __int128 v220 = 1065353216;
      id v245 = 8LL;
      std::unordered_map<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,std::allocator<std::pair<FunctionHandleKey const,objc_object  {objcproto17MTLFunctionHandle}*>>>::unordered_map( (uint64_t)v246,  (uint64_t)&v218);
      std::unordered_map<unsigned long,std::unordered_map<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,std::allocator<std::pair<FunctionHandleKey const,objc_object  {objcproto17MTLFunctionHandle}*>>>,std::hash<unsigned long>,FunctionHandleKeyHash<unsigned long>,std::equal_to<FunctionHandleKey><std::allocator<unsigned long const>>>::unordered_map( (uint64_t)v253,  (unint64_t *)&v235,  5LL);
      for (i9 = 200LL; i9 != -40; i9 -= 48LL)
        std::__hash_table<std::__hash_value_type<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong}>,std::__unordered_map_hasher<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,true>,std::__unordered_map_equal<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},std::equal_to,std::__unordered_map_hasher,true>,std::allocator<objc_object  {objcproto17MTLFunctionHandle}* {__strong}>>::~__hash_table((uint64_t)&v235 + i9);
      std::__hash_table<std::__hash_value_type<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong}>,std::__unordered_map_hasher<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,true>,std::__unordered_map_equal<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},std::equal_to,std::__unordered_map_hasher,true>,std::allocator<objc_object  {objcproto17MTLFunctionHandle}* {__strong}>>::~__hash_table((uint64_t)&v218);
      std::__hash_table<std::__hash_value_type<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong}>,std::__unordered_map_hasher<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,true>,std::__unordered_map_equal<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},std::equal_to,std::__unordered_map_hasher,true>,std::allocator<objc_object  {objcproto17MTLFunctionHandle}* {__strong}>>::~__hash_table((uint64_t)&v221);
      std::__hash_table<std::__hash_value_type<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong}>,std::__unordered_map_hasher<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,true>,std::__unordered_map_equal<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},std::equal_to,std::__unordered_map_hasher,true>,std::allocator<objc_object  {objcproto17MTLFunctionHandle}* {__strong}>>::~__hash_table((uint64_t)&v224);
      std::__hash_table<std::__hash_value_type<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong}>,std::__unordered_map_hasher<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,true>,std::__unordered_map_equal<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},std::equal_to,std::__unordered_map_hasher,true>,std::allocator<objc_object  {objcproto17MTLFunctionHandle}* {__strong}>>::~__hash_table((uint64_t)&v227);
      std::__hash_table<std::__hash_value_type<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong}>,std::__unordered_map_hasher<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},FunctionHandleKeyHash,std::equal_to<FunctionHandleKey>,true>,std::__unordered_map_equal<FunctionHandleKey,objc_object  {objcproto17MTLFunctionHandle}* {__strong},std::equal_to,std::__unordered_map_hasher,true>,std::allocator<objc_object  {objcproto17MTLFunctionHandle}* {__strong}>>::~__hash_table((uint64_t)&v230);
      uint64_t v254 = 0u;
      v255 = 0u;
      v256 = 1065353216;
      uint64_t v257 = 0u;
      uint64_t v258 = 0u;
      uint64_t v260 = 0u;
      uint64_t v261 = 0u;
      v259 = 1065353216;
      v262 = 1065353216;
      uint64_t v263 = __pa;
      v264 = 2LL;
      v265 = 0x100000002LL;
      unint64_t v181 = newpool;
      InstrumentSubCommandWithAccessTrackingV2((uint64_t)&v235, a1, a2, a3, (uint64_t)&v247, v233, newpool);
      uint64_t v187 = v236;
      unint64_t v188 = v237;
      if (v184) {
        uint64_t v189 = v235 == 0;
      }
      else {
        uint64_t v189 = 1;
      }
      LOBYTE(v184) = !v189;
      GTMTLReplayAccessTracking::~GTMTLReplayAccessTracking((id *)&v247);
    }

    else
    {
      unint64_t v188 = 0LL;
      uint64_t v187 = 0LL;
    }

    ReplaceFunctionTablesWithRegular((uint64_t)v210, (uint64_t)a1, 3, *(void *)a2, v233, v181);
    std::__hash_table<std::__hash_value_type<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>,std::__unordered_map_hasher<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::equal_to,std::hash,true>,std::allocator<objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>>::~__hash_table((uint64_t)&v211);
    std::__hash_table<std::__hash_value_type<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>,std::__unordered_map_hasher<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,objc_object  {objcproto22MTLRenderPipelineState}* {__strong},std::equal_to,std::hash,true>,std::allocator<objc_object  {objcproto22MTLRenderPipelineState}* {__strong}>>::~__hash_table((uint64_t)v210);
    unint64_t v123 = -[NSMutableArray initWithCapacity:]( objc_alloc(&OBJC_CLASS___NSMutableArray),  "initWithCapacity:",  0xAAAAAAAAAAAAAAABLL * ((v183 - v182) >> 3) - 0x5555555555555555LL * ((v188 - v187) >> 3));
    if (v182 != v183)
    {
      unint64_t v190 = v182;
      do
      {
        v247 = *(_OWORD *)v190;
        *(void *)&uint64_t v248 = v190[2];
        uint64_t v191 = MakeResourceUsageItem((uint64_t)&v247, 1LL);
        unint64_t v192 = (void *)objc_claimAutoreleasedReturnValue(v191);
        -[NSMutableArray addObject:](v123, "addObject:", v192);

        v190 += 3;
      }

      while (v190 != (void *)v183);
    }

    if (v187 != v188)
    {
      unint64_t v193 = v187;
      do
      {
        v247 = *(_OWORD *)v193;
        *(void *)&uint64_t v248 = v193[2];
        uint64_t v194 = MakeResourceUsageItem((uint64_t)&v247, 2LL);
        unint64_t v195 = (void *)objc_claimAutoreleasedReturnValue(v194);
        -[NSMutableArray addObject:](v123, "addObject:", v195);

        v193 += 3;
      }

      while (v193 != (void *)v188);
    }

    if (v185) {
      operator delete(v185);
    }
    if (v168) {
      operator delete(v168);
    }
    if (v187) {
      operator delete(v187);
    }
    if (v182) {
      operator delete(v182);
    }

    id v108 = v184 & 1;
    goto LABEL_156;
  }

LABEL_75:
      if ((v21 & (v21 - 1)) != 0)
      {
        if (v20 >= v21) {
          size_t v12 = v20 % v21;
        }
        else {
          size_t v12 = v20;
        }
      }

      else
      {
        size_t v12 = (v21 - 1) & v20;
      }

      goto LABEL_80;
    }

    NSLog(@"Empty Path", a2);
    id v16 = *(unsigned __int8 *)(v15 + 23);
    goto LABEL_7;
  }

      unint64_t v99 = [v28 uniqueIdentifier];
      if (v19 != v99)
      {
        uint64_t v100 = (uint64_t)v99;
        id v101 = *(apr_pool_t ***)(a1 + 32);
        __int8 v109 = *a6;
        uint64_t v110 = *((void *)a6 + 2);
        StoreArgumentIndexReencoding(v101, (uint64_t)&v109, v100);
      }

    unsigned __int8 v57 = -1LL;
    goto LABEL_107;
  }

  size_t v18 = *(void *)(a2 + 8);
  size_t v19 = (void *)llvm::MDString::getString(*(llvm::MDString **)(v4 + 32));
  if (v20 < 0xD) {
    goto LABEL_75;
  }
  unsigned __int16 v21 = v19;
  uint64_t v22 = *v19 == 0x765F6E7275746572LL && *(void *)((char *)v19 + 5) == 0x2865756C61765F6ELL;
  if (!v22) {
    goto LABEL_75;
  }
  id v23 = v20;
  if (*((_BYTE *)v19 + v20 - 1) != 41) {
    goto LABEL_75;
  }
  std::string::basic_string[abi:nn180100]<0>(&__p, "return_value(");
  int size = __p.__r_.__value_.__l.__size_;
  if ((__p.__r_.__value_.__s.__size_ & 0x80u) == 0) {
    int size = __p.__r_.__value_.__s.__size_;
  }
  if (v23 < size) {
    int size = v23;
  }
  unint64_t v97 = size;
  if (size <= v23 - 1) {
    int size = v23 - 1;
  }
  if (v23 < size) {
    int size = v23;
  }
  uint64_t v96 = size;
  uint64_t v25 = *(void *)(v3 - 8LL * *(unsigned int *)(v3 + 8) + 24);
  if (!v25
    || *(_BYTE *)v25 != 5
    || (Subprograunint64_t m = llvm::DILocalScope::getSubprogram(*(llvm::DILocalScope **)(v25 - 8LL * *(unsigned int *)(v25 + 8)))) == 0)
  {
    uint64_t v27 = *(unsigned int *)(v18 + 88);
    if ((_DWORD)v27)
    {
      __s2 = (char *)v21 + v97;
      unint64_t v28 = v18;
      uint64_t v29 = v96 - v97;
      int64_t v92 = v28;
      int v30 = *(uint64_t **)(v28 + 80);
      uint64_t v31 = 8 * v27;
      id v94 = v7;
      int v95 = v10;
      do
      {
        Subprograunint64_t m = *v30;
        uint64_t v32 = *(llvm::MDString **)(*v30 - 8LL * *(unsigned int *)(*v30 + 8) + 24);
        if (v32 && (id v33 = (void *)llvm::MDString::getString(v32)) != 0LL)
        {
          std::string::basic_string[abi:nn180100](&__p, v33, v34);
          __int128 v35 = __p.__r_.__value_.__s.__size_;
          __int128 v36 = __p.__r_.__value_.__l.__size_;
          __int128 v37 = (std::string *)__p.__r_.__value_.__r.__words[0];
        }

        else
        {
          __int128 v36 = 0LL;
          __int128 v37 = 0LL;
          __int128 v35 = 0LL;
          memset(&__p, 0, sizeof(__p));
        }

        unint64_t v38 = (char)v35;
        if ((v35 & 0x80u) != 0LL) {
          __int128 v35 = v36;
        }
        unsigned int v39 = v29;
        uint64_t v40 = v35 == v29;
        if (v40 && v96 != v97)
        {
          if (v38 >= 0) {
            p_p = &__p;
          }
          else {
            p_p = v37;
          }
          uint64_t v40 = memcmp(p_p, __s2, v39) == 0;
        }

        if (v38 < 0) {
          operator delete(v37);
        }
        if (v40)
        {
LABEL_116:
          LODWORD(v7) = v94;
          LODWORD(v10) = v95;
          goto LABEL_117;
        }

        ++v30;
        v31 -= 8LL;
        LODWORD(v7) = v94;
        LODWORD(v10) = v95;
        uint64_t v29 = v96 - v97;
      }

      while (v31);
      id v43 = *(unsigned int *)(v92 + 88);
      if ((_DWORD)v43)
      {
        uint64_t v44 = *(uint64_t **)(v92 + 80);
        unint64_t v45 = 8 * v43;
        while (1)
        {
          Subprograunint64_t m = *v44;
          unsigned int v46 = *(llvm::MDString **)(*v44 - 8LL * *(unsigned int *)(*v44 + 8) + 16);
          if (v46 && (uint64_t v47 = (void *)llvm::MDString::getString(v46)) != 0LL)
          {
            std::string::basic_string[abi:nn180100](&__p, v47, v48);
            uint64_t v49 = __p.__r_.__value_.__s.__size_;
            unsigned __int8 v50 = __p.__r_.__value_.__l.__size_;
            unint64_t v51 = (std::string *)__p.__r_.__value_.__r.__words[0];
          }

          else
          {
            unsigned __int8 v50 = 0LL;
            unint64_t v51 = 0LL;
            uint64_t v49 = 0LL;
            memset(&__p, 0, sizeof(__p));
          }

          unint64_t v52 = (char)v49;
          if ((v49 & 0x80u) != 0LL) {
            uint64_t v49 = v50;
          }
          uint64_t v22 = v49 == v29;
          unsigned int v53 = v29;
          uint64_t v54 = v49 == v29;
          if (!v22 || v96 == v97)
          {
            if (v52 < 0) {
              goto LABEL_72;
            }
          }

          else
          {
            if (v52 >= 0) {
              unsigned __int8 v56 = &__p;
            }
            else {
              unsigned __int8 v56 = v51;
            }
            uint64_t v54 = memcmp(v56, __s2, v53) == 0;
            if (v52 < 0)
            {
LABEL_72:
              operator delete(v51);
              if (v54) {
                goto LABEL_116;
              }
              goto LABEL_73;
            }
          }

          if (v54) {
            goto LABEL_116;
          }
LABEL_73:
          ++v44;
          v45 -= 8LL;
          LODWORD(v7) = v94;
          LODWORD(v10) = v95;
          uint64_t v29 = v96 - v97;
          if (!v45) {
            goto LABEL_122;
          }
        }
      }
    }

    goto LABEL_122;
  }

  qsort( v32->elts,  v32->nelts,  v32->elt_size,  (int (__cdecl *)(const void *, const void *))GTMTLDataSource_compareRestores);
  uint64_t v64 = atomic_load((unint64_t *)(*(void *)&v695.st_uid + 72LL));
  if (!(v39[8] + v39[9])) {
    v39[8] = v64;
  }
  uint64_t v65 = v32->nelts;
  unint64_t v66 = pool;
  if ((int)v65 >= 1)
  {
    __int128 v67 = (unint64_t *)(v32->elts + 16);
    do
    {
      CFStringRef v67 = v64;
      v67 += 8;
      --v65;
    }

    while (v65);
  }

  LODWORD(v690[0]) = 1;
  *(_OWORD *)((char *)v690 + 4) = 0u;
  memset((char *)&v690[2] + 4, 0, 28);
  v692 = apr_array_make(pool, 15, 8);
  v691 = apr_array_make(pool, 2048, 32);
  v39[16] = apr_array_make(pool, 128, 8);
  v39[18] = apr_hash_make(pool);
  v39[21] = apr_hash_make(pool);
  uint64_t v68 = apr_hash_make(pool);
  v39[22] = v68;
  uint64_t v69 = (apr_hash_t *)v39[21];
  uint64_t v70 = p;
  v651 = GTCaptureArchive_mapData((uint64_t)arr, st_ino, "capture", p);
  uint64_t v72 = v71;
  BOOL v73 = apr_hash_make(v70);
  v660 = apr_hash_make(v70);
  char v74 = g_signpostLog;
  if (os_signpost_enabled((os_log_t)v74))
  {
    *(_DWORD *)buf = 136446466;
    *(void *)&uint8_t buf[4] = "capture";
    *(_WORD *)&buf[12] = 2048;
    *(void *)&buf[14] = v72;
    _os_signpost_emit_with_name_impl( &dword_0,  (os_log_t)v74,  OS_SIGNPOST_INTERVAL_BEGIN,  0xEEEEB0B5B2B2EEEELL,  "Replayer-2-restore",  "ReadTrace %{public}s (%{xcode:size-in-bytes}zu)",  buf,  0x16u);
  }

  if (v72 >= 9)
  {
    v658 = 0;
    v654 = (unint64_t *)(v656 + 72);
    v655 = v64;
    id v75 = (unint64_t *)(v656 + 80);
    v645 = v69;
    v648 = (char *)v73 + 24;
    v649 = (apr_hash_t *)((char *)v73 + 16);
    __int128 v76 = 8LL;
    v673 = (apr_hash_t *)v64;
    v650 = v72;
    ht = v73;
    v653 = (unint64_t *)(v656 + 80);
    v641 = v68;
    v642 = v64;
    while (1)
    {
      v679 = (apr_array_header_t *)((char *)v651 + v76);
      BOOL v77 = *(unsigned int *)((char *)v651 + v76 + 4);
      __int128 v78 = (v77 + 15345) > 0x38 || ((0x17C40BE00017E7FuLL >> (v77 - 15)) & 1) == 0;
      v657 = v76;
      if (!v78) {
        break;
      }
      if (!v658)
      {
        unint64_t v82 = GetFuncEnumConstructorType(v77) == 25;
LABEL_99:
        unint64_t v79 = v82;
        goto LABEL_102;
      }

      unint64_t v79 = 0;
      if (v77 <= -15909)
      {
        __int128 v80 = v77 == -16361;
        uint64_t v81 = -16202;
      }

      else
      {
        __int128 v80 = v77 == -15908 || v77 == -15318;
        uint64_t v81 = -15316;
      }

      __int128 v84 = v80 || v77 == v81;
      uint64_t v83 = v654;
      if (!v84) {
        unint64_t v79 = 1;
      }
LABEL_109:
      v658 = v79;
      if (IsFuncEnumDestructor(v77))
      {
        id v85 = *(void *)&v679[1].elt_size;
        BOOL v86 = *(void *)&v695.st_rdev;
        unint64_t v87 = atomic_load((unint64_t *)(*(void *)&v695.st_uid + 72LL));
        if (GetAliasStream(v86, v85, v87))
        {
          BOOL v88 = v679;
          GTTraceFbufToFunc(&v695, v679);
          goto LABEL_196;
        }
      }

      uint64_t v89 = v679;
      if (((uint64_t)v679[1].pool & 2) != 0
        || v79
        && (v90 = AddResourceRestoreRequest(v32, (uint64_t)&v695, (uint64_t)v679, (unint64_t)v673), uint64_t v89 = v679, v90))
      {
        do
          uint64_t v91 = __ldaxr(v83);
        while (__stlxr(v91 + 1, v83));
        pool_high = HIDWORD(v89->pool);
        if (!GetFuncEnumConstructorType(pool_high))
        {
          BOOL v88 = v679;
          goto LABEL_197;
        }

        BOOL v88 = v679;
        do
          int v93 = __ldaxr(v75);
        while (__stlxr(v93 + 1, v75));
        goto LABEL_196;
      }

      if (HIDWORD(v89->pool) == -10229)
      {
        id v94 = (uint64_t)&v89[1].pool + 4;
        int v95 = v89;
        uint64_t v96 = strcmp((const char *)&v89[1].pool + 4, "CUUUU");
        v689 = 0LL;
        error = *(CFErrorRef *)&v95[1].nelts;
        *(void *)buf = 16LL;
        appended = (char *)AppendString_10195((const char **)&appended, v94, (uint64_t *)buf);
        v687 = (char *)AppendString_10195((const char **)&v687, v94, (uint64_t *)buf);
        v688 = (char *)AppendString_10195((const char **)&v688, v94, (uint64_t *)buf);
        if (!v96) {
          v689 = (char *)AppendString_10195((const char **)&v689, v94, (uint64_t *)buf);
        }
        unint64_t v97 = (apr_pool_t **)*((void *)v682 + 18);
        unsigned __int32 v98 = *v97;
        unint64_t v99 = (char *)apr_palloc(*v97, 0x80uLL);
        if (v99)
        {
          *((void *)v99 + 15) = 0LL;
          *(_OWORD *)(v99 + 104) = 0u;
          *(_OWORD *)(v99 + 8_Block_object_dispose(va, 8) = 0u;
          *(_OWORD *)(v99 + 72) = 0u;
          *(_OWORD *)(v99 + 56) = 0u;
          *(_OWORD *)(v99 + 40) = 0u;
          *(_OWORD *)(v99 + 24) = 0u;
          *(_OWORD *)(v99 + _Block_object_dispose(va, 8) = 0u;
        }

        *(void *)unint64_t v99 = error;
        v647 = v99;
        apr_hash_set((apr_hash_t *)v97, v99, 8LL, v99);
        v646 = *(apr_pool_t **)v695.st_ino;
        Data = GTCaptureArchive_readData( *(const char ***)&v695.st_dev,  (apr_pool_t **)v695.st_ino,  appended,  *(apr_pool_t **)v695.st_ino,  0LL);
        id v101 = *((void *)Data + 1);
        arra = apr_array_make(v98, v101, 8);
        v662 = v101;
        if (v101)
        {
          uint64_t v102 = 0LL;
          unint64_t v103 = (uint64_t *)(Data + 16);
          do
          {
            uint64_t v105 = *v103++;
            int v104 = v105;
            uint64_t v106 = apr_hash_make(v98);
            *(void *)apr_array_push(arra) = v106;
            if (v105)
            {
              uint64_t v107 = 0LL;
              do
              {
                id v108 = apr_palloc(v98, 8uLL);
                AliasStream2 = (uint64_t *)GetAliasStream2((uint64_t)&v695, *v103);
                if (AliasStream2) {
                  uint64_t v110 = *AliasStream2;
                }
                else {
                  uint64_t v110 = 0LL;
                }
                unsigned int *v108 = v110;
                uint64_t v111 = v103[1];
                uint64_t v112 = apr_array_make(v98, v111, 16);
                apr_hash_set(v106, v108, 8LL, v112);
                for (v103 += 2; v111; --v111)
                {
                  id v113 = (uint64_t *)GetAliasStream2((uint64_t)&v695, *v103);
                  if (v113)
                  {
                    id v114 = *v113;
                    if (*v113)
                    {
                      uint64_t v115 = v103[1];
                      uint64_t v116 = apr_array_push(v112);
                      *uint64_t v116 = v114;
                      v116[1] = v115;
                    }
                  }

                  v103 += 2;
                }

                qsort( v112->elts,  v112->nelts,  v112->elt_size,  (int (__cdecl *)(const void *, const void *))DYMTLMutableBufferAncestor_compare);
                ++v107;
              }

              while (v107 != v104);
            }

            ++v102;
          }

          while (v102 != v662);
        }

        *((void *)v647 + 12) = arra;
        apr_pool_clear(v646);
        uint64_t v117 = GTCaptureArchive_readData(*(const char ***)&v695.st_dev, (apr_pool_t **)v695.st_ino, v687, v646, 0LL);
        uint64_t v118 = *((_DWORD *)v117 + 2);
        uint64_t v119 = apr_array_make(v98, 32, 40);
        arrb = apr_array_make(v98, v118, 16);
        if (v118 >= 1)
        {
          uint64_t v120 = 0;
          id v121 = (uint64_t *)(v117 + 16);
          do
          {
            uint32x2_t v122 = v119->nelts;
            uint64_t v124 = *v121++;
            unint64_t v123 = v124;
            id v125 = apr_array_push(arrb);
            *id v125 = v122;
            v125[1] = v124;
            id v126 = v124;
            if (v124)
            {
              do
              {
                uint64_t v127 = apr_array_push(v119);
                uint64_t v128 = v121 + 5;
                uint64_t v129 = (uint64_t *)GetAliasStream2((uint64_t)&v695, *v121);
                if (v129) {
                  unint64_t v130 = *v129;
                }
                else {
                  unint64_t v130 = 0LL;
                }
                *uint64_t v127 = v130;
                v127[1] = v121[1];
                v127[2] = v121[2];
                uint64_t v131 = (uint64_t *)GetAliasStream2((uint64_t)&v695, v121[3]);
                if (v131) {
                  uint64_t v132 = *v131;
                }
                else {
                  uint64_t v132 = 0LL;
                }
                v127[3] = v132;
                v127[4] = v121[4];
                v121 += 5;
                --v126;
              }

              while (v126);
              id v121 = v128;
            }

            qsort( &v119->elts[40 * (int)v122],  v123,  v119->elt_size,  (int (__cdecl *)(const void *, const void *))GTTrackerIndirectArgumentBufferInfo_compare);
            ++v120;
          }

          while (v120 != v118);
        }

        *((void *)v647 + 13) = v119;
        *((void *)v647 + 14) = arrb;
        apr_pool_clear(v646);
        unint64_t v133 = (unsigned int *)GTCaptureArchive_readData( *(const char ***)&v695.st_dev,  (apr_pool_t **)v695.st_ino,  v688,  v646,  0LL);
        unint64_t v134 = *v133;
        uint64_t v135 = v133[2];
        uint64_t v136 = v133 + 4;
        uint64_t v137 = apr_array_make(v98, v135, 24);
        if (v135 >= 1)
        {
          do
          {
            uint64_t v138 = apr_array_push(v137);
            v138[2] = *v136;
            char *v138 = v136[1];
            uint64_t v139 = v136[2];
            v136 += 3;
            v138[1] = v139;
            --v135;
          }

          while (v135);
        }

        *(void *)buf = v136;
        *(void *)&v696.st_dev = v137;
        UniqueIdentifierResourceGroup = LoadUniqueIdentifierResourceGroup((int **)buf, v134, v98);
        v696.st_ino = (__darwin_ino64_t)UniqueIdentifierResourceGroup;
        *(void *)&v696.st_uid = LoadUniqueIdentifierResourceGroup((int **)buf, v134, v98);
        arrc = *(apr_array_header_t **)&v696.st_uid;
        if (v134 <= 0x16)
        {
          v663 = apr_array_make(v98, 0, 32);
          *(void *)&v696.st_rdev = v663;
          v644 = apr_array_make(v98, 0, 32);
          v696.st_atimespec.tv_sec = (__darwin_time_t)v644;
          tv_nsec = (uint64_t)apr_array_make(v98, 0, 32);
          v696.st_atimespec.tv_nsec = tv_nsec;
        }

        else
        {
          v663 = LoadUniqueIdentifierResourceGroup((int **)buf, v134, v98);
          *(void *)&v696.st_rdev = v663;
          v644 = LoadUniqueIdentifierResourceGroup((int **)buf, v134, v98);
          v696.st_atimespec.tv_sec = (__darwin_time_t)v644;
          v696.st_atimespec.tv_nsec = (uint64_t)LoadUniqueIdentifierResourceGroup((int **)buf, v134, v98);
          tv_nsec = v696.st_atimespec.tv_nsec;
          if (v134 > 0x2E)
          {
            id v141 = LoadUniqueIdentifierResourceGroup((int **)buf, v134, v98);
            v696.st_mtimespec.tv_sec = (__darwin_time_t)v141;
            uint64_t v32 = v664;
            if (v134 >= 0x36)
            {
              id v142 = LoadUniqueIdentifierResourceGroup((int **)buf, v134, v98);
              v696.st_mtimespec.tv_nsec = (uint64_t)v142;
              uint64_t v143 = LoadUniqueIdentifierResourceGroup((int **)buf, v134, v98);
              goto LABEL_165;
            }

void sub_BF83C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
}

LABEL_84:
      size_t v19 = v284 + 1;
      if (v284 + 1 == v280)
      {
        id v15 = *v271;
        id v14 = v271[1];
        id v16 = v274;
        goto LABEL_88;
      }
    }
  }

    if ((v8 & (v8 - 1)) != 0)
    {
      if (v19 >= v8) {
        unint64_t v6 = v19 % v8;
      }
      else {
        unint64_t v6 = v19;
      }
    }

    else
    {
      unint64_t v6 = (v8 - 1) & v19;
    }
  }

  unint64_t v45 = *(void *)(a1 + 160);
  unsigned int v46 = *(void **)(v45 + 8 * v6);
  if (v46)
  {
    *(void *)unint64_t j = *v46;
  }

  else
  {
    uint64_t v47 = (void *)*v25;
    *(void *)unint64_t j = *v25;
    void *v25 = j;
    *(void *)(v45 + 8 * v6) = v25;
    if (!v47) {
      goto LABEL_98;
    }
    BOOL v48 = v47[1];
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v48 >= v8) {
        v48 %= v8;
      }
    }

    else
    {
      v48 &= v8 - 1;
    }

    unsigned int v46 = (void *)(*(void *)(a1 + 160) + 8 * v48);
  }

  FILE *v46 = j;
LABEL_98:
  ++*(void *)(a1 + 184);
  uint64_t v70 = *(std::string **)(a1 + 144);
LABEL_99:
  uint64_t v69 = -1431655765 * (((unint64_t)v16 - v17) >> 3);
  *((_DWORD *)j + 10) = v69;
  uint64_t v49 = *(void *)(a1 + 152);
  if ((unint64_t)v70 >= v49)
  {
    unint64_t v51 = *(void *)(a1 + 136);
    unint64_t v52 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v70 - v51) >> 3);
    if (v52 + 1 > 0xAAAAAAAAAAAAAAALL) {
      abort();
    }
    unsigned int v53 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v49 - v51) >> 3);
    uint64_t v54 = 2 * v53;
    if (2 * v53 <= v52 + 1) {
      uint64_t v54 = v52 + 1;
    }
    if (v53 >= 0x555555555555555LL) {
      unsigned __int8 v55 = 0xAAAAAAAAAAAAAAALL;
    }
    else {
      unsigned __int8 v55 = v54;
    }
    v75.__end_cap_.__value_ = (std::allocator<std::string> *)(a1 + 152);
    if (v55)
    {
      unsigned __int8 v56 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<std::vector<NSObject  {objcproto21OS_dispatch_semaphore}* {__strong}>>>(v55);
      unsigned __int8 v58 = v57;
    }

    else
    {
      unsigned __int8 v56 = 0LL;
      unsigned __int8 v58 = 0LL;
    }

    id v60 = (std::string *)&v56[24 * v52];
    if (*((char *)a2 + 23) < 0)
    {
      std::string::__init_copy_ctor_external(v60, *(const std::string::value_type **)a2, *((void *)a2 + 1));
    }

    else
    {
      __int128 v61 = *a2;
      v60->__r_.__value_.__l.__cap_ = *((void *)a2 + 2);
      *(_OWORD *)&v60->__r_.__value_.__l.__data_ = v61;
    }

    uint64_t v63 = *(void *)(a1 + 136);
    uint64_t v62 = *(void *)(a1 + 144);
    if (v62 == v63)
    {
      unint64_t v66 = vdupq_n_s64(v62);
      uint64_t v64 = v60;
    }

    else
    {
      uint64_t v64 = v60;
      do
      {
        uint64_t v65 = *(_OWORD *)(v62 - 24);
        v64[-1].__r_.__value_.__l.__cap_ = *(void *)(v62 - 8);
        *(_OWORD *)&v64[-1].__r_.__value_.__l.__data_ = v65;
        --v64;
        *(void *)(v62 - 16) = 0LL;
        *(void *)(v62 - _Block_object_dispose(va, 8) = 0LL;
        *(void *)(v62 - 24) = 0LL;
        v62 -= 24LL;
      }

      while (v62 != v63);
      unint64_t v66 = *(int64x2_t *)(a1 + 136);
    }

    __int128 v59 = v60 + 1;
    *(void *)(a1 + 136) = v64;
    *(void *)(a1 + std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long>>>::~__hash_table(v2 - 144) = v60 + 1;
    *(int64x2_t *)&v75.__begin_ = v66;
    __int128 v67 = *(std::string **)(a1 + 152);
    *(void *)(a1 + 152) = &v56[24 * v58];
    v75.__end_cap_.__value_ = v67;
    v75.__first_ = (std::__split_buffer<std::string>::pointer)v66.i64[0];
    std::__split_buffer<std::string>::~__split_buffer(&v75);
  }

  else
  {
    if (*((char *)a2 + 23) < 0)
    {
      std::string::__init_copy_ctor_external(v70, *(const std::string::value_type **)a2, *((void *)a2 + 1));
    }

    else
    {
      unsigned __int8 v50 = *a2;
      v70->__r_.__value_.__l.__cap_ = *((void *)a2 + 2);
      *(_OWORD *)&v70->__r_.__value_.__l.__data_ = v50;
    }

    __int128 v59 = v70 + 1;
  }

  *(void *)(a1 + std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long>>>::~__hash_table(v2 - 144) = v59;
  return v69;
}

LABEL_89:
  id v296 = 0u;
  __int128 v297 = 0u;
  uint64_t v298 = 1065353216;
  v295[0] = &v296;
  v295[1] = &v299;
  memset(&__p, 0, sizeof(__p));
  if (v262
    && (uint64_t v100 = (void *)objc_claimAutoreleasedReturnValue(+[NSFileManager defaultManager](&OBJC_CLASS___NSFileManager, "defaultManager")),
        id v101 = [v100 fileExistsAtPath:v262],
        v100,
        v101))
  {
    std::string::basic_string[abi:nn180100]<0>(v303, (char *)[v262 UTF8String]);
    __p = v303[0];
    -[GTShaderProfilerHelper _processPerLineCostDataForLineTable:withFileCost:withDebugInfo:andAllDrawCost:withKey:withShaderSourcePath:withDrawCost:]::$_2::operator()( v295,  &__p);
    __int128 v278 = 1;
  }

  else
  {
    __int128 v278 = 0;
  }

  uint64_t v102 = v300;
  if (v300 == &v301) {
    goto LABEL_173;
  }
  p_p = &__p;
  if (!v278) {
    p_p = v303;
  }
  __int128 v276 = (uint64_t)p_p;
  do
  {
    int v104 = v102[5][3];
    if (*(char *)(v104 + 103) < 0) {
      std::string::__init_copy_ctor_external( v303,  *(const std::string::value_type **)(v104 + 80),  *(void *)(v104 + 88));
    }
    else {
      v303[0] = *(std::string *)(v104 + 80);
    }
    if ((v278 & 1) == 0) {
      -[GTShaderProfilerHelper _processPerLineCostDataForLineTable:withFileCost:withDebugInfo:andAllDrawCost:withKey:withShaderSourcePath:withDrawCost:]::$_2::operator()( v295,  v303);
    }
    uint64_t v106 = v102[5];
    uint64_t v105 = v102[6];
    if (v106 == v105)
    {
      uint64_t v112 = 0.0;
      goto LABEL_138;
    }

    if ((v303[0].__r_.__value_.__s.__size_ & 0x80u) == 0) {
      uint64_t v107 = v303;
    }
    else {
      uint64_t v107 = (std::string *)v303[0].__r_.__value_.__r.__words[0];
    }
    if ((v303[0].__r_.__value_.__s.__size_ & 0x80u) == 0) {
      int size = v303[0].__r_.__value_.__s.__size_;
    }
    else {
      int size = v303[0].__r_.__value_.__l.__size_;
    }
    __int8 v109 = *(int8x8_t *)((char *)a4 + 8);
    uint64_t v286 = *(void *)a4;
    uint64_t v110 = (uint8x8_t)vcnt_s8(v109);
    v110.i16[0] = vaddlv_u8(v110);
    uint64_t v111 = v110.u32[0];
    __streama = *(void *)&v109 - 1LL;
    int v281 = *((_DWORD *)a5 + 12);
    uint64_t v112 = 0.0;
    id v113 = v102[5];
    uint64_t v289 = v102[6];
    do
    {
      id v114 = *v113;
      uint64_t v115 = v113[1];
      if (*v113 != v115)
      {
        do
        {
          uint64_t v112 = v112 + *(double *)(v114 + 24);
          v114 += 56LL;
        }

        while (v114 != v115);
        goto LABEL_133;
      }

      uint64_t v116 = std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:nn180100]((uint64_t *)v107, size);
      if (!*(void *)&v109) {
        goto LABEL_133;
      }
      uint64_t v117 = v116;
      if (v111 > 1)
      {
        uint64_t v118 = v116;
        if (v116 >= *(void *)&v109) {
          uint64_t v118 = v116 % *(void *)&v109;
        }
      }

      else
      {
        uint64_t v118 = __streama & v116;
      }

      uint64_t v119 = *(unsigned __int8 ***)(v286 + 8 * v118);
      if (!v119) {
        goto LABEL_132;
      }
      uint64_t v120 = size;
      id v121 = v107;
      uint32x2_t v122 = *v119;
      if (!*v119)
      {
LABEL_131:
        uint64_t v107 = v121;
        int size = v120;
LABEL_132:
        uint64_t v105 = v289;
        goto LABEL_133;
      }

      while (1)
      {
        unint64_t v123 = *((void *)v122 + 1);
        if (v123 == v117) {
          break;
        }
        if (v111 > 1)
        {
          if (v123 >= *(void *)&v109) {
            v123 %= *(void *)&v109;
          }
        }

        else
        {
          v123 &= __streama;
        }

        if (v123 != v118) {
          goto LABEL_131;
        }
LABEL_130:
        uint32x2_t v122 = *(unsigned __int8 **)v122;
        if (!v122) {
          goto LABEL_131;
        }
      }

      uint64_t v124 = *((void *)v122 + 5);
      id v125 = *((void *)v122 + 6) - v124;
      id v126 = *((_DWORD *)v102 + 8) - v281;
      uint64_t v107 = v121;
      int size = v120;
      uint64_t v105 = v289;
      if (v126 < v125 >> 3) {
        uint64_t v112 = *(double *)(v124 + 8 * v126);
      }
LABEL_133:
      v113 += 6;
    }

    while (v113 != v105);
LABEL_138:
    uint64_t v127 = std::unordered_map<std::string,std::vector<-[GTShaderProfilerHelper _processPerLineCostDataForLineTable:withFileCost:withDebugInfo:andAllDrawCost:withKey:withShaderSourcePath:withDrawCost:]::LineSourceInfo>>::find[abi:nn180100]( &v296,  v276);
    if (v127)
    {
      uint64_t v128 = (*((_DWORD *)v102 + 8) - 1);
      uint64_t v129 = *((void *)v127 + 5);
      if (0x6DB6DB6DB6DB6DB7LL * ((*((void *)v127 + 6) - v129) >> 3) > v128)
      {
        unint64_t v130 = (double *)(v129 + 56LL * v128);
        void *v130 = v112;
        uint64_t v131 = (uint64_t *)(v130 + 4);
        if (v131 != (uint64_t *)(v102 + 5))
        {
          uint64_t v132 = v129 + 56LL * v128;
          uint64_t v135 = *(void *)(v132 + 48);
          unint64_t v134 = (void *)(v132 + 48);
          unint64_t v133 = v135;
          uint64_t v136 = 0xAAAAAAAAAAAAAAABLL * (((char *)v105 - (char *)v106) >> 4);
          uint64_t v137 = (uint64_t *)*v131;
          if (0xAAAAAAAAAAAAAAABLL * ((v135 - *v131) >> 4) >= v136)
          {
            if (0xAAAAAAAAAAAAAAABLL
               * ((uint64_t)(*(void *)(v129 + 56LL * v128 + 40) - (void)v137) >> 4) < v136)
            {
              id v142 = &v106[2 * ((uint64_t)(*(void *)(v129 + 56LL * v128 + 40) - (void)v137) >> 4)];
              std::__copy[abi:nn180100]<std::_ClassicAlgPolicy,-[GTShaderProfilerHelper _processPerLineCostDataForLineTable:withFileCost:withDebugInfo:andAllDrawCost:withKey:withShaderSourcePath:withDrawCost:]::LineInfo *,-[GTShaderProfilerHelper _processPerLineCostDataForLineTable:withFileCost:withDebugInfo:andAllDrawCost:withKey:withShaderSourcePath:withDrawCost:]::LineInfo *,-[GTShaderProfilerHelper _processPerLineCostDataForLineTable:withFileCost:withDebugInfo:andAllDrawCost:withKey:withShaderSourcePath:withDrawCost:]::LineInfo *>( v106,  v142,  v137);
              uint64_t v106 = v142;
              goto LABEL_154;
            }

            uint64_t v152 = std::__copy[abi:nn180100]<std::_ClassicAlgPolicy,-[GTShaderProfilerHelper _processPerLineCostDataForLineTable:withFileCost:withDebugInfo:andAllDrawCost:withKey:withShaderSourcePath:withDrawCost:]::LineInfo *,-[GTShaderProfilerHelper _processPerLineCostDataForLineTable:withFileCost:withDebugInfo:andAllDrawCost:withKey:withShaderSourcePath:withDrawCost:]::LineInfo *,-[GTShaderProfilerHelper _processPerLineCostDataForLineTable:withFileCost:withDebugInfo:andAllDrawCost:withKey:withShaderSourcePath:withDrawCost:]::LineInfo *>( v106,  v105,  v137);
            std::vector<-[GTShaderProfilerHelper _processPerLineCostDataForLineTable:withFileCost:withDebugInfo:andAllDrawCost:withKey:withShaderSourcePath:withDrawCost:]::LineInfo>::__base_destruct_at_end[abi:nn180100]( v131,  v152);
          }

          else
          {
            if (v137)
            {
              std::vector<-[GTShaderProfilerHelper _processPerLineCostDataForLineTable:withFileCost:withDebugInfo:andAllDrawCost:withKey:withShaderSourcePath:withDrawCost:]::LineInfo>::__base_destruct_at_end[abi:nn180100]( v131,  (uint64_t *)*v131);
              operator delete((void *)*v131);
              unint64_t v133 = 0LL;
              *uint64_t v131 = 0LL;
              v131[1] = 0LL;
              v131[2] = 0LL;
            }

            if (v136 > 0x555555555555555LL) {
              goto LABEL_251;
            }
            uint64_t v138 = 0xAAAAAAAAAAAAAAABLL * (v133 >> 4);
            uint64_t v139 = 2 * v138;
            if (2 * v138 <= v136) {
              uint64_t v139 = 0xAAAAAAAAAAAAAAABLL * (((char *)v105 - (char *)v106) >> 4);
            }
            uint64_t v140 = v138 >= 0x2AAAAAAAAAAAAAALL ? 0x555555555555555LL : v139;
            if (v140 > 0x555555555555555LL) {
LABEL_251:
            }
              abort();
            id v141 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<DynamicBuffer>>(v140);
            *(int64x2_t *)uint64_t v131 = vdupq_n_s64((unint64_t)v141);
            *unint64_t v134 = &v141[48 * v13];
LABEL_154:
            uint64_t v143 = v129 + 56LL * v128;
            id v146 = *(void **)(v143 + 40);
            unsigned int v144 = (void *)(v143 + 40);
            BOOL v145 = v146;
            if (v106 == v105)
            {
              unint64_t v147 = v145;
            }

            else
            {
              unint64_t v147 = v145;
              do
              {
                id *v147 = 0LL;
                v147[1] = 0LL;
                v147[2] = 0LL;
                unint64_t v148 = *v106;
                unint64_t v149 = v106[1];
                if (v149 != *v106)
                {
                  std::vector<-[GTShaderProfilerHelper _processPerLineCostDataForLineTable:withFileCost:withDebugInfo:andAllDrawCost:withKey:withShaderSourcePath:withDrawCost:]::SourceDisassemblyInfo>::__vallocate[abi:nn180100]( v147,  0x6DB6DB6DB6DB6DB7LL * ((v149 - *v106) >> 3));
                  std::vector<-[GTShaderProfilerHelper _processPerLineCostDataForLineTable:withFileCost:withDebugInfo:andAllDrawCost:withKey:withShaderSourcePath:withDrawCost:]::SourceDisassemblyInfo>::__construct_at_end<-[GTShaderProfilerHelper _processPerLineCostDataForLineTable:withFileCost:withDebugInfo:andAllDrawCost:withKey:withShaderSourcePath:withDrawCost:]::SourceDisassemblyInfo*,-[GTShaderProfilerHelper _processPerLineCostDataForLineTable:withFileCost:withDebugInfo:andAllDrawCost:withKey:withShaderSourcePath:withDrawCost:]::SourceDisassemblyInfo*>( v147,  v148,  v149);
                }

                v147[3] = 0LL;
                v147[4] = 0LL;
                v147[5] = 0LL;
                uint64_t v150 = v106[3];
                uint64_t v151 = v106[4];
                if (v151 != v150)
                {
                  std::vector<DebugInfo::BlockInfo>::__vallocate[abi:nn180100]( v147 + 3,  0x4EC4EC4EC4EC4EC5LL * ((v151 - v150) >> 3));
                  std::vector<DebugInfo::BlockInfo>::__construct_at_end<DebugInfo::BlockInfo*,DebugInfo::BlockInfo*>( (uint64_t)(v147 + 3),  v150,  v151);
                }

                v147 += 6;
                v106 += 6;
              }

              while (v106 != v105);
            }

            *unsigned int v144 = v147;
          }
        }
      }
    }

    uint64_t v153 = v102[1];
    if (v153)
    {
      do
      {
        uint64_t v154 = (uint64_t **)v153;
        uint64_t v153 = (uint64_t *)*v153;
      }

      while (v153);
    }

    else
    {
      do
      {
        uint64_t v154 = (uint64_t **)v102[2];
        uint64_t v155 = *v154 == (uint64_t *)v102;
        uint64_t v102 = v154;
      }

      while (!v155);
    }

    uint64_t v102 = v154;
  }

  while (v154 != &v301);
LABEL_173:
  __int128 v272 = (void *)objc_opt_new(&OBJC_CLASS___NSMutableArray, v13);
  uint64_t v156 = (void *)objc_claimAutoreleasedReturnValue( +[NSCharacterSet characterSetWithCharactersInString:]( &OBJC_CLASS___NSCharacterSet,  "characterSetWithCharactersInString:",  @"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"));
  int v270 = (void *)objc_claimAutoreleasedReturnValue([v156 invertedSet]);

  for (uint64_t i = (uint64_t *)v297; i; uint64_t i = (uint64_t *)*i)
  {
    uint64_t v159 = i + 2;
    uint64_t v160 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", v159));
    uint64_t v161 = (void *)objc_claimAutoreleasedReturnValue([v160 lastPathComponent]);
    uint64_t v162 = (void *)objc_claimAutoreleasedReturnValue([v161 stringByDeletingPathExtension]);

    uint64_t v163 = (void *)objc_claimAutoreleasedReturnValue([v162 componentsSeparatedByCharactersInSet:v270]);
    uint64_t v164 = (void *)objc_claimAutoreleasedReturnValue([v163 componentsJoinedByString:&stru_591D98]);

    [v272 addObject:v164];
  }

  uint64_t v261 = (void *)objc_opt_new(&OBJC_CLASS___NSMutableDictionary, v157);
  uint64_t v260 = objc_claimAutoreleasedReturnValue([v272 componentsJoinedByString:@"_"]);
  __int128 v165 = (const char *)[v260 UTF8String];
  v259 = v258;
  snprintf( (char *)v303,  0x400uLL,  "/tmp/com.apple.gputools.profiling/shaderProfilerResults/shader_cost_%s_%s.txt",  v165,  (const char *)[v259 UTF8String]);
  __streamb = fopen((const char *)v303, "w");
  uint64_t v263 = (void *)objc_opt_new(&OBJC_CLASS___NSMutableDictionary, v166);
  objc_msgSend(v261, "setObject:forKeyedSubscript:");
  __int128 v167 = (uint64_t *)v297;
  uint64_t v168 = 100.0 / (a6 + 2.22507386e-308);
  if ((void)v297)
  {
    do
    {
      __int128 v169 = (const char **)(v167 + 2);
      uint64_t v266 = (uint64_t **)v167;
      uint64_t v170 = *((char *)v167 + 39);
      __int128 v171 = (const char *)(v167 + 2);
      if (v170 < 0) {
        __int128 v171 = *v169;
      }
      fprintf(__streamb, "%s\n", v171);
      v267 = (void *)objc_opt_new(&OBJC_CLASS___NSMutableDictionary, v172);
      v265 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", v169));
      objc_msgSend(v263, "setObject:forKeyedSubscript:", v267);
      __int128 v277 = (void *)objc_opt_new(&OBJC_CLASS___NSMutableArray, v173);
      objc_msgSend(v267, "setObject:forKeyedSubscript:");
      __int128 v283 = v266[5];
      v275 = v266[6];
      if (v283 != v275)
      {
        unsigned int v279 = 1LL;
        do
        {
          __int128 v282 = (void *)objc_opt_new(&OBJC_CLASS___NSMutableDictionary, v174);
          objc_msgSend(v277, "addObject:");
          uint64_t v175 = (uint64_t)(v283 + 1);
          __int128 v176 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", v175));
          [v282 setObject:v176 forKeyedSubscript:@"source"];

          uint64_t v177 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInt:](&OBJC_CLASS___NSNumber, "numberWithUnsignedInt:", v279));
          [v282 setObject:v177 forKeyedSubscript:@"line"];

          uint64_t v178 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithDouble:](&OBJC_CLASS___NSNumber, "numberWithDouble:", *(double *)v283));
          [v282 setObject:v178 forKeyedSubscript:@"cost"];

          uint64_t v179 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithDouble:]( &OBJC_CLASS___NSNumber,  "numberWithDouble:",  v168 * *(double *)v283));
          [v282 setObject:v179 forKeyedSubscript:@"percent"];

          else {
            fprintf(__streamb, "%u: %s      %.1f %.2f%%\n");
          }
          double v287 = (void *)objc_opt_new(&OBJC_CLASS___NSMutableArray, v180);
          objc_msgSend(v282, "setObject:forKeyedSubscript:");
          __int128 v183 = (uint64_t *)v283[4];
          unint64_t v182 = (uint64_t *)v283[5];
          __int128 v285 = v182;
          while (v183 != v182)
          {
            uint64_t v290 = (void *)objc_opt_new(&OBJC_CLASS___NSMutableDictionary, v181);
            int v186 = (void *)objc_opt_new(&OBJC_CLASS___NSMutableArray, v184);
            uint64_t v187 = (uint64_t *)v183[3];
            unint64_t v188 = (uint64_t *)v183[4];
            if (v187 != v188)
            {
              uint64_t v189 = v187 + 7;
              do
              {
                unint64_t v190 = (void *)objc_opt_new(&OBJC_CLASS___NSMutableDictionary, v185);
                uint64_t v191 = v189 - 7;
                unint64_t v192 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedInt:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedInt:",  *((unsigned int *)v189 - 14)));
                [v190 setObject:v192 forKeyedSubscript:@"lineIndex"];

                unint64_t v193 = (const char *)(v189 - 3);
                uint64_t v194 = (const char *)(v189 - 3);
                unint64_t v195 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithUTF8String:]( &OBJC_CLASS___NSString,  "stringWithUTF8String:",  v194));
                [v190 setObject:v195 forKeyedSubscript:@"function"];

                uint64_t v196 = v189;
                unint64_t v197 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithUTF8String:]( &OBJC_CLASS___NSString,  "stringWithUTF8String:",  v196));
                [v190 setObject:v197 forKeyedSubscript:@"filename"];

                unint64_t v198 = v189 + 3;
                unint64_t v199 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithUTF8String:]( &OBJC_CLASS___NSString,  "stringWithUTF8String:",  v198));
                [v190 setObject:v199 forKeyedSubscript:@"fullpath"];

                uint64_t v200 = v189 - 6;
                unsigned int v201 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithUTF8String:]( &OBJC_CLASS___NSString,  "stringWithUTF8String:",  v200));
                [v190 setObject:v201 forKeyedSubscript:@"directory"];

                uint64_t v202 = (const char *)v189;
                fprintf(__streamb, "      -----> %u:  %s : %s\n", *(_DWORD *)v191, v193, v202);
                [v186 addObject:v190];

                v189 += 13;
              }

              while (v191 + 13 != v188);
            }

            if ([v186 count]) {
              [v290 setObject:v186 forKeyedSubscript:@"callstackInfos"];
            }
            [v287 addObject:v290];
            if (*v183 != v183[1])
            {
              char v204 = (void *)objc_opt_new(&OBJC_CLASS___NSMutableArray, v203);
              [v290 setObject:v204 forKeyedSubscript:@"diassembly"];
              uint64_t v206 = *v183;
              uint64_t v207 = v183[1];
              if (*v183 != v207)
              {
                do
                {
                  uint64_t v208 = (void *)objc_opt_new(&OBJC_CLASS___NSMutableDictionary, v205);
                  [v204 addObject:v208];
                  int v209 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedInt:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedInt:",  *(unsigned int *)(v206 + 16)));
                  [v208 setObject:v209 forKeyedSubscript:@"offset"];

                  [v208 setObject:*(void *)v206 forKeyedSubscript:@"disasm"];
                  __int128 v210 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithDouble:]( &OBJC_CLASS___NSNumber,  "numberWithDouble:",  *(double *)(v206 + 24)));
                  [v208 setObject:v210 forKeyedSubscript:@"cost"];

                  int v211 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithDouble:]( &OBJC_CLASS___NSNumber,  "numberWithDouble:",  v168 * *(double *)(v206 + 24)));
                  [v208 setObject:v211 forKeyedSubscript:@"percent"];

                  v206 += 56LL;
                }

                while (v206 != v207);
                __int128 v212 = *v183;
                __int128 v213 = v183[1];
                while (v212 != v213)
                {
                  __int128 v214 = *(void **)(v212 + 8);
                  if (*(double *)(v212 + 24) <= 2.22507386e-308)
                  {
                    [v214 UTF8String];
                    fprintf(__streamb, "    %d %s\n");
                  }

                  else
                  {
                    [v214 UTF8String];
                    fprintf(__streamb, "    %d %s %.1f %.2f%%\n");
                  }

                  v212 += 56LL;
                }
              }
            }

            v183 += 6;
            unint64_t v182 = v285;
          }

          unsigned int v279 = (v279 + 1);
          v283 += 7;
        }

        while (v283 != v275);
      }

      __int128 v167 = *v266;
    }

    while (*v266);
  }

  if (*((void *)a5 + 3) != *((void *)a5 + 4))
  {
    fwrite("\n----------- Full Binary Disassembly -----------\n", 0x31uLL, 1uLL, __streamb);
    __int128 v217 = (void *)objc_opt_new(&OBJC_CLASS___NSMutableArray, v215);
    __int128 v218 = *((void *)a5 + 3);
    unint64_t v219 = *((void *)a5 + 4);
    if (v218 != v219)
    {
      __int128 v220 = 0LL;
      do
      {
        if (*(void *)v218)
        {
          __int128 v221 = (void *)objc_opt_new(&OBJC_CLASS___NSMutableDictionary, v216);
          __int128 v222 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInt:](&OBJC_CLASS___NSNumber, "numberWithUnsignedInt:", v220));
          [v221 setObject:v222 forKeyedSubscript:@"offset"];

          [v221 setObject:*(void *)v218 forKeyedSubscript:@"disasmSource"];
          [v221 setObject:*(void *)(v218 + 8) forKeyedSubscript:@"irSource"];
          __int128 v223 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithDouble:]( &OBJC_CLASS___NSNumber,  "numberWithDouble:",  *(double *)(v218 + 16)));
          [v221 setObject:v223 forKeyedSubscript:@"cost"];

          unint64_t v224 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithDouble:]( &OBJC_CLASS___NSNumber,  "numberWithDouble:",  v168 * *(double *)(v218 + 16)));
          [v221 setObject:v224 forKeyedSubscript:@"costPercentage"];

          __int128 v225 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithInt:]( &OBJC_CLASS___NSNumber,  "numberWithInt:",  *(unsigned int *)(v218 + 28)));
          [v221 setObject:v225 forKeyedSubscript:@"opcodeType"];

          __int128 v226 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithInt:]( &OBJC_CLASS___NSNumber,  "numberWithInt:",  *(unsigned int *)(v218 + 32)));
          [v221 setObject:v226 forKeyedSubscript:@"opcodeSubType"];

          id v227 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithInt:]( &OBJC_CLASS___NSNumber,  "numberWithInt:",  *(unsigned int *)(v218 + 36)));
          [v221 setObject:v227 forKeyedSubscript:@"opcode"];

          [v217 addObject:v221];
          __int128 v228 = *(void **)v218;
          if (*(double *)(v218 + 16) <= 2.22507386e-308)
          {
            [v228 UTF8String];
            fprintf(__streamb, "    %d %s\n");
          }

          else
          {
            [v228 UTF8String];
            fprintf(__streamb, "    %d %s %.1f %.2f%%\n");
          }
        }

        __int128 v220 = (v220 + 1);
        v218 += 40LL;
      }

      while (v218 != v219);
    }

    [v261 setObject:v217 forKeyedSubscript:@"binaryDisassemblyInfo"];
  }

  fclose(__streamb);
  id v229 = (void *)objc_claimAutoreleasedReturnValue( +[NSJSONSerialization dataWithJSONObject:options:error:]( &OBJC_CLASS___NSJSONSerialization,  "dataWithJSONObject:options:error:",  v261,  1LL,  0LL));
  if (v229)
  {
    snprintf( (char *)v303, 0x400uLL, "/tmp/com.apple.gputools.profiling/shaderProfilerResults/json/shader_cost_%s_%s.json", (const char *)[v260 UTF8String], (const char *)objc_msgSend(v259, "UTF8String"));
    __int128 v230 = -[NSString initWithData:encoding:](objc_alloc(&OBJC_CLASS___NSString), "initWithData:encoding:", v229, 4LL);
    __int128 v231 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", v303));
    -[NSString writeToFile:atomically:encoding:error:]( v230,  "writeToFile:atomically:encoding:error:",  v231,  0LL,  4LL,  0LL);
  }

  std::unordered_map<std::string,std::vector<-[GTShaderProfilerHelper _processPerLineCostDataForLineTable:withFileCost:withDebugInfo:andAllDrawCost:withKey:withShaderSourcePath:withDrawCost:]::LineSourceInfo>>::~unordered_map[abi:nn180100]((uint64_t)&v296);
  uint64_t v232 = (void *)objc_claimAutoreleasedReturnValue( +[NSMutableDictionary dictionaryWithCapacity:]( &OBJC_CLASS___NSMutableDictionary,  "dictionaryWithCapacity:",  *((void *)a4 + 3) == 0LL));
  [v264 setPerFileCost:v232];
  id v233 = objc_alloc_init(&OBJC_CLASS___NSMutableDictionary);
  [v264 setPerFileLineCostDictForCI:v233];
  for (unint64_t j = (uint64_t *)*((void *)a4 + 2); j; unint64_t j = (uint64_t *)*j)
  {
    uint64_t v235 = (void *)objc_claimAutoreleasedReturnValue( -[GTShaderProfilerHelper _createPerFileCostDictionaryWith:lineOffset:]( self,  "_createPerFileCostDictionaryWith:lineOffset:",  j + 5,  *((unsigned int *)a5 + 12)));
    id v236 = j + 2;
    id v237 = j + 2;
    id v238 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", v237));
    [v232 setObject:v235 forKeyedSubscript:v238];

    unint64_t v239 = (void *)objc_claimAutoreleasedReturnValue( -[GTShaderProfilerHelper _createPerFileLineCostDictionaryForCIWith:lineOffset:]( self,  "_createPerFileLineCostDictionaryForCIWith:lineOffset:",  j + 5,  *((unsigned int *)a5 + 12)));
    v240 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", v236));
    -[NSMutableDictionary setObject:forKeyedSubscript:](v233, "setObject:forKeyedSubscript:", v239, v240);
  }

  [v264 setTotalCost:a6];
  id v241 = (void *)objc_claimAutoreleasedReturnValue( +[NSMutableDictionary dictionaryWithCapacity:]( &OBJC_CLASS___NSMutableDictionary,  "dictionaryWithCapacity:",  *((void *)a9 + 3)));
  [v264 setDrawCallCost:v241];
  for (uint64_t k = (double *)*((void *)a9 + 2); k; uint64_t k = *(double **)k)
  {
    id v243 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithDouble:](&OBJC_CLASS___NSNumber, "numberWithDouble:", k[3]));
    uint64_t v244 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedInt:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedInt:",  *((unsigned int *)k + 4)));
    [v241 setObject:v243 forKeyedSubscript:v244];
  }

  id v245 = (void *)objc_claimAutoreleasedReturnValue([v264 perFileCost]);
  id v246 = [v245 count] == (char *)&dword_0 + 1;

  if (v246)
  {
    v247 = (void *)objc_claimAutoreleasedReturnValue([v264 perFileCost]);
    uint64_t v248 = (void *)objc_claimAutoreleasedReturnValue([v247 allValues]);

    int v249 = (void *)objc_claimAutoreleasedReturnValue([v248 objectAtIndexedSubscript:0]);
    uint64_t v250 = (void *)objc_claimAutoreleasedReturnValue([v249 objectForKeyedSubscript:@"allDrawCall"]);
    [v264 setTotalPerLineCost:v250];

    BOOL v251 = (void *)objc_claimAutoreleasedReturnValue([v248 objectAtIndexedSubscript:0]);
    uint64_t v252 = (void *)objc_claimAutoreleasedReturnValue([v251 objectForKeyedSubscript:@"perDrawCall"]);
    [v264 setDrawCallPerLineCost:v252];

    goto LABEL_247;
  }

  uint64_t v253 = (void *)objc_claimAutoreleasedReturnValue([v264 perFileCost]);
  uint64_t v248 = (void *)objc_claimAutoreleasedReturnValue([v253 objectForKeyedSubscript:@"/program_source"]);

  if (v248)
  {
    uint64_t v254 = (void *)objc_claimAutoreleasedReturnValue([v248 objectForKeyedSubscript:@"allDrawCall"]);
    [v264 setTotalPerLineCost:v254];

    BOOL v251 = (void *)objc_claimAutoreleasedReturnValue([v248 objectForKeyedSubscript:@"perDrawCall"]);
    [v264 setDrawCallPerLineCost:v251];
LABEL_247:
  }

  v255 = v264;
  std::__tree<std::__value_type<unsigned int,std::vector<-[GTShaderProfilerHelper _processPerLineCostDataForLineTable:withFileCost:withDebugInfo:andAllDrawCost:withKey:withShaderSourcePath:withDrawCost:]::LineInfo>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::vector<-[GTShaderProfilerHelper _processPerLineCostDataForLineTable:withFileCost:withDebugInfo:andAllDrawCost:withKey:withShaderSourcePath:withDrawCost:]::LineInfo>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,std::vector<-[GTShaderProfilerHelper _processPerLineCostDataForLineTable:withFileCost:withDebugInfo:andAllDrawCost:withKey:withShaderSourcePath:withDrawCost:]::LineInfo>>>>::destroy(v301);

  return v255;
}

void sub_C12E8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18, uint64_t a19, void *a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, void *__p, uint64_t a42, uint64_t a43, uint64_t a44, uint64_t a45, uint64_t a46, uint64_t a47, uint64_t a48, uint64_t a49, uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,void *a55)
{
  std::__tree<std::__value_type<unsigned int,std::vector<-[GTShaderProfilerHelper _processPerLineCostDataForLineTable:withFileCost:withDebugInfo:andAllDrawCost:withKey:withShaderSourcePath:withDrawCost:]::LineInfo>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::vector<-[GTShaderProfilerHelper _processPerLineCostDataForLineTable:withFileCost:withDebugInfo:andAllDrawCost:withKey:withShaderSourcePath:withDrawCost:]::LineInfo>>,std::less<unsigned int>,true>,std::allocator<std::__value_type<unsigned int,std::vector<-[GTShaderProfilerHelper _processPerLineCostDataForLineTable:withFileCost:withDebugInfo:andAllDrawCost:withKey:withShaderSourcePath:withDrawCost:]::LineInfo>>>>::destroy(a55);
  _Unwind_Resume(a1);
}

void sub_C1DA4( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, void *__p, uint64_t a9, void *a10, void *a11, uint64_t a12, void *a13, void *a14, void *a15, void *__pa, void *a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, char a23, uint64_t a24, char *a25, DebugInfo *a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, char a31, uint64_t a32, uint64_t a33, uint64_t a34)
{
  std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long>>>::~__hash_table((uint64_t)&a19);
  std::__hash_table<std::__hash_value_type<std::string,PerFileCost>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,PerFileCost>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,PerFileCost>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,PerFileCost>>>::~__hash_table((uint64_t)&a25);
  a25 = &a31;
  std::vector<std::vector<ProfileEvent>>::__destroy_vector::operator()[abi:nn180100]((void ***)&a25);
  if (__pa) {
    operator delete(__pa);
  }
  DebugInfo::~DebugInfo((DebugInfo *)&a34);

  _Unwind_Resume(a1);
}

void sub_C2214( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, void *__p, uint64_t a8, char a9, uint64_t a10, void *a11, void *a12, void *a13, void *a14, void *__pa, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, char a21, uint64_t a22, char *a23, DebugInfo *a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, char a29, uint64_t a30, uint64_t a31, uint64_t a32)
{
  a23 = &a29;
  std::vector<std::vector<ProfileEvent>>::__destroy_vector::operator()[abi:nn180100]((void ***)&a23);
  if (__pa) {
    operator delete(__pa);
  }
  DebugInfo::~DebugInfo((DebugInfo *)&a32);

  _Unwind_Resume(a1);
}

void sub_C2440(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long>>>::~__hash_table((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_C256C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_C260C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_C37E4( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, void *a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, uint64_t a41, uint64_t a42, uint64_t a43, uint64_t a44, uint64_t a45, uint64_t a46, uint64_t a47, uint64_t a48, uint64_t a49, uint64_t a50,void **a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,char a57)
{
  a51 = (void **)&a57;
  std::vector<std::vector<DYMTLEncoderInfo>>::__destroy_vector::operator()[abi:nn180100](&a51);

  _Unwind_Resume(a1);
}

void sub_C4264( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{
}

void sub_C4524(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_C4664( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{
  objc_destroyWeak(v15);
  objc_destroyWeak((id *)(v16 - 40));

  _Unwind_Resume(a1);
}

void sub_C4838(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_C4D20( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, void *a11, uint64_t a12, void *a13, void *a14, uint64_t a15, uint64_t a16, void *a17, uint64_t a18, uint64_t a19, void *a20)
{
  _Unwind_Resume(a1);
}

void sub_C4F98( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, id location, id a16)
{
  objc_destroyWeak(v18);
  objc_destroyWeak(v17);
  objc_destroyWeak(&location);
  objc_destroyWeak(&a16);

  _Unwind_Resume(a1);
}

void sub_C5504( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, void *a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18)
{
  _Unwind_Resume(a1);
}

void sub_C5720(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_C58D4( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, id location, id a18, char a19)
{
  objc_destroyWeak(v21);
  objc_destroyWeak(v20);
  objc_destroyWeak(&location);
  objc_destroyWeak(&a18);
  _Block_object_dispose(&a19, 8);

  _Unwind_Resume(a1);
}

void sub_C5AB8( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, id location)
{
  objc_destroyWeak(v16);
  objc_destroyWeak(&location);

  _Unwind_Resume(a1);
}

void sub_C5C38(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_C6248( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18, void *a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, void *a24)
{
  *(void *)(v25 - 136) = v25 - 112;
  std::vector<std::vector<ShaderBinaryInfo * {__strong}>>::__destroy_vector::operator()[abi:nn180100]((void ***)(v25 - 136));

  _Unwind_Resume(a1);
}

void sub_C66B8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18, void *a19)
{
}

LABEL_201:
}

                      *(void *)uint64_t v153 = v154;
                      *(_DWORD *)(v153 + _Block_object_dispose(va, 8) = v155;
                      *(_DWORD *)(v153 + 12) = v156;
                      *(void *)(v153 + 16) = v158;
                      *(void *)(v153 + 24) = v157;
                      *(double *)(v153 + 32) = result;
                    }
                  }
                }

                __int128 v169 = v135-- <= 2;
                a2 = v149;
              }

              while (!v169);
            }

            return result;
          }

          id v15 = (unint64_t)v14 >> 1;
          uint64_t v16 = a1 + 40 * ((unint64_t)v14 >> 1);
          if ((unint64_t)v13 < 0x1401)
          {
            std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,USCSampleComparator &,ShaderProfilerUSCSampleInfo *>( v16,  a1,  v9);
          }

          else
          {
            std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,USCSampleComparator &,ShaderProfilerUSCSampleInfo *>( a1,  v16,  v9);
            id v17 = 5 * v15;
            std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,USCSampleComparator &,ShaderProfilerUSCSampleInfo *>( a1 + 40,  a1 + 8 * v17 - 40,  v10);
            std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,USCSampleComparator &,ShaderProfilerUSCSampleInfo *>( a1 + 80,  a1 + 40 + 8 * v17,  v11);
            std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,USCSampleComparator &,ShaderProfilerUSCSampleInfo *>( a1 + 8 * v17 - 40,  v16,  a1 + 40 + 8 * v17);
            char v204 = *(void *)(a1 + 32);
            uint64_t v194 = *(_OWORD *)a1;
            unint64_t v199 = *(_OWORD *)(a1 + 16);
            size_t v18 = *(_OWORD *)v16;
            size_t v19 = *(_OWORD *)(v16 + 16);
            *(void *)(a1 + 32) = *(void *)(v16 + 32);
            *(_OWORD *)a1 = v18;
            *(_OWORD *)(a1 + 16) = v19;
            *(void *)(v16 + 32) = v204;
            *(_OWORD *)uint64_t v16 = v194;
            *(_OWORD *)(v16 + 16) = v199;
          }

          --a3;
          a2 = (double *)v193;
          if ((a4 & 1) == 0 && !USCSampleComparator::operator()(a1 - 40, a1))
          {
            __n128 result = *(double *)a1;
            unsigned __int8 v57 = *(_DWORD *)(a1 + 8);
            unsigned __int8 v58 = *(_DWORD *)(a1 + 12);
            id v60 = *(void *)(a1 + 16);
            __int128 v59 = *(void *)(a1 + 24);
            __int128 v61 = *(void *)(a1 + 32);
            uint64_t v62 = *(_DWORD *)(v193 - 28);
            if (v58 == v62)
            {
              uint64_t v63 = *(_DWORD *)(v193 - 8);
              uint64_t v64 = *(void *)(a1 + 32);
              uint64_t v65 = v61 >= v63;
              if ((_DWORD)v61 == v63)
              {
                uint64_t v65 = LODWORD(result) >= *(_DWORD *)v9;
                if (LODWORD(result) == *(_DWORD *)v9)
                {
                  unint64_t v66 = *(_DWORD *)(v193 - 32);
                  uint64_t v65 = v57 >= v66;
                  if (v57 == v66) {
                    uint64_t v65 = v59 >= *(void *)(v193 - 16);
                  }
                }
              }

              if (!v65) {
                goto LABEL_76;
              }
            }

            else if (v58 < v62)
            {
              uint64_t v64 = *(void *)(a1 + 32);
LABEL_76:
              for (uint64_t i = a1 + 40; ; i += 40LL)
              {
                __int128 v67 = *(_DWORD *)(i + 12);
                uint64_t v68 = v58 >= v67;
                if (v58 == v67)
                {
                  uint64_t v69 = *(_DWORD *)(i + 32);
                  uint64_t v68 = v64 >= v69;
                  if (v64 == v69)
                  {
                    uint64_t v68 = LODWORD(result) >= *(_DWORD *)i;
                    if (LODWORD(result) == *(_DWORD *)i)
                    {
                      uint64_t v70 = *(_DWORD *)(i + 8);
                      uint64_t v68 = v57 >= v70;
                      if (v57 == v70) {
                        uint64_t v68 = v59 >= *(void *)(i + 24);
                      }
                    }
                  }
                }

                if (!v68) {
                  break;
                }
              }

              goto LABEL_94;
            }

            for (uint64_t i = a1 + 40; i < v193; i += 40LL)
            {
              uint64_t v71 = *(_DWORD *)(i + 12);
              uint64_t v72 = v58 >= v71;
              if (v58 == v71)
              {
                BOOL v73 = *(_DWORD *)(i + 32);
                uint64_t v72 = v61 >= v73;
                if ((_DWORD)v61 == v73)
                {
                  uint64_t v72 = LODWORD(result) >= *(_DWORD *)i;
                  if (LODWORD(result) == *(_DWORD *)i)
                  {
                    char v74 = *(_DWORD *)(i + 8);
                    uint64_t v72 = v57 >= v74;
                    if (v57 == v74) {
                      uint64_t v72 = v59 >= *(void *)(i + 24);
                    }
                  }
                }
              }

              if (!v72) {
                break;
              }
            }

void sub_C7ADC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, void *a22, void *a23, void *a24, uint64_t a25, void *a26, void *a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, uint64_t a41, uint64_t a42, uint64_t a43, char a44, uint64_t a45, uint64_t a46, char a47, uint64_t a48, uint64_t a49, uint64_t a50,uint64_t a51,uint64_t a52,void *__p,uint64_t a54,uint64_t a55,void *a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  a68 = (uint64_t)&a44;
  std::vector<std::vector<DYMTLEncoderInfo>>::__destroy_vector::operator()[abi:nn180100]((void ***)&a68);
  std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long>>>::~__hash_table((uint64_t)&a47);
  if (__p)
  {
    a54 = (uint64_t)__p;
    operator delete(__p);
  }

  if (a56) {
    operator delete(a56);
  }

  _Unwind_Resume(a1);
}

void sub_C8B08( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18, void *a19, void *a20, uint64_t a21, void *a22, void *a23, uint64_t a24, void *a25)
{
}

void sub_C90A0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_C9324(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_C9444(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_C95E8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long>>>::~__hash_table((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_C97B0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_C9928(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_C9AE8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_C9F78( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, void *a16, void *a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, char a24, uint64_t a25, char a26, int a27, char a28, uint64_t a29, char a30)
{
  _Unwind_Resume(a1);
}

LABEL_94:
        std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long>>>::~__hash_table((uint64_t)&v112);
        std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long>>>::~__hash_table((uint64_t)&v98);
        int v10 = v87;
        id v14 = v86;
        uint64_t v7 = v85;
        id v15 = v83;
        self = v84;
        uint64_t v16 = v82;
      }

      llvm::Expected<std::vector<llvm::iterator_range<llvm::agxclauseanalyzer::AnalyzerInput::InstIteratorImpl<llvm::agxclauseanalyzer::AnalyzerInput const>>>>::~Expected((uint64_t)&v119);
      *(void *)&unsigned __int32 v98 = v116;
      std::vector<llvm::Error>::__destroy_vector::operator()[abi:nn180100]((void ***)&v98);
      uint64_t v69 = (std::string *)v109;
      if (*((char *)v109 + 23) < 0)
      {
        uint64_t v71 = *v109;
        uint64_t v70 = (unsigned __int8 *)v109[1];
      }

      else
      {
        uint64_t v70 = (unsigned __int8 *)*((unsigned __int8 *)v109 + 23);
        uint64_t v71 = v109;
      }

      LOBYTE(v9_Block_object_dispose(va, 8) = 9;
      uint64_t v72 = std::remove[abi:nn180100]<std::__wrap_iter<char *>,char>(v71, &v70[(void)v71], (unsigned __int8 *)&v98);
      if ((char)v69->__r_.__value_.__s.__size_ < 0)
      {
        char v74 = v69->__r_.__value_.__r.__words[0];
        BOOL v73 = (char *)(v69->__r_.__value_.__r.__words[0] + v69->__r_.__value_.__l.__size_);
      }

      else
      {
        BOOL v73 = (char *)v69 + v69->__r_.__value_.__s.__size_;
        char v74 = (std::string::size_type)v69;
      }

      std::string::erase(v69, (std::string::size_type)&v72[-v74], v73 - (char *)v72);
      LODWORD(v112) = 0;
      *((void *)&v112 + 1) = std::system_category();
      id v75 = __s;
      if (__s)
      {
        __int128 v76 = strlen(__s);
        id v75 = __s;
        BOOL v77 = v76;
      }

      else
      {
        BOOL v77 = 0LL;
      }

      llvm::raw_fd_ostream::raw_fd_ostream(&v98, v75, v77, &v112, 1LL);
      int size = (char)v69->__r_.__value_.__s.__size_;
      if (size >= 0) {
        unint64_t v79 = (const char *)v69;
      }
      else {
        unint64_t v79 = (const char *)v69->__r_.__value_.__r.__words[0];
      }
      if (size >= 0) {
        __int128 v80 = v69->__r_.__value_.__s.__size_;
      }
      else {
        __int128 v80 = v69->__r_.__value_.__l.__size_;
      }
      llvm::raw_ostream::write((llvm::raw_ostream *)&v98, v79, v80);
      llvm::raw_fd_ostream::~raw_fd_ostream((llvm::raw_fd_ostream *)&v98);
      llvm::raw_ostream::~raw_ostream((llvm::raw_ostream *)&v101);
      if (SHIBYTE(v111) < 0) {
        operator delete(__p[0]);
      }
    }

    uint64_t v81 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v10, "stringByAppendingString:", @".txt", v82, v83, v84));
    -[GTShaderProfilerHelper _saveDebugInfoFrom:to:withTextSegment:targetIndex:]( self,  "_saveDebugInfoFrom:to:withTextSegment:targetIndex:",  v16,  v81,  v14,  v7);

    std::unique_ptr<GPUToolsPlatformLLVMShaderProfilerHelperImpl>::reset[abi:nn180100]((uint64_t *)v15, 0LL);
    operator delete(v15);
  }
}

            id v75 = v193;
            if (i < v193)
            {
              for (unint64_t j = v191; ; j -= 5)
              {
                BOOL v77 = v58 >= v62;
                if (v58 == v62)
                {
                  __int128 v78 = *((_DWORD *)j + 6);
                  BOOL v77 = v61 >= v78;
                  if ((_DWORD)v61 == v78)
                  {
                    unint64_t v79 = *((_DWORD *)j - 2);
                    BOOL v77 = LODWORD(result) >= v79;
                    if (LODWORD(result) == v79)
                    {
                      BOOL v77 = v57 >= *(_DWORD *)j;
                      if (v57 == *(_DWORD *)j) {
                        BOOL v77 = v59 >= *((void *)j + 2);
                      }
                    }
                  }
                }

                if (v77) {
                  break;
                }
                uint64_t v62 = *((_DWORD *)j - 9);
              }

              id v75 = (unint64_t)(j - 1);
            }

            while (i < v75)
            {
              uint64_t v206 = *(void *)(i + 32);
              uint64_t v196 = *(_OWORD *)i;
              unsigned int v201 = *(_OWORD *)(i + 16);
              __int128 v80 = *(_OWORD *)v75;
              uint64_t v81 = *(_OWORD *)(v75 + 16);
              *(void *)(i + 32) = *(void *)(v75 + 32);
              *(_OWORD *)uint64_t i = v80;
              *(_OWORD *)(i + 16) = v81;
              *(void *)(v75 + 32) = v206;
              *(_OWORD *)id v75 = v196;
              *(_OWORD *)(v75 + 16) = v201;
              do
              {
                i += 40LL;
                unint64_t v82 = *(_DWORD *)(i + 12);
                uint64_t v83 = v58 >= v82;
                if (v58 == v82)
                {
                  __int128 v84 = *(_DWORD *)(i + 32);
                  uint64_t v83 = v61 >= v84;
                  if ((_DWORD)v61 == v84)
                  {
                    uint64_t v83 = LODWORD(result) >= *(_DWORD *)i;
                    if (LODWORD(result) == *(_DWORD *)i)
                    {
                      id v85 = *(_DWORD *)(i + 8);
                      uint64_t v83 = v57 >= v85;
                      if (v57 == v85) {
                        uint64_t v83 = v59 >= *(void *)(i + 24);
                      }
                    }
                  }
                }
              }

              while (v83);
              do
              {
                v75 -= 40LL;
                BOOL v86 = *(_DWORD *)(v75 + 12);
                unint64_t v87 = v58 >= v86;
                if (v58 == v86)
                {
                  BOOL v88 = *(_DWORD *)(v75 + 32);
                  unint64_t v87 = v61 >= v88;
                  if ((_DWORD)v61 == v88)
                  {
                    unint64_t v87 = LODWORD(result) >= *(_DWORD *)v75;
                    if (LODWORD(result) == *(_DWORD *)v75)
                    {
                      uint64_t v89 = *(_DWORD *)(v75 + 8);
                      unint64_t v87 = v57 >= v89;
                      if (v57 == v89) {
                        unint64_t v87 = v59 >= *(void *)(v75 + 24);
                      }
                    }
                  }
                }
              }

              while (!v87);
            }

            if (i - 40 != a1)
            {
              id v90 = *(_OWORD *)(i - 40);
              uint64_t v91 = *(_OWORD *)(i - 24);
              *(void *)(a1 + 32) = *(void *)(i - 8);
              *(_OWORD *)a1 = v90;
              *(_OWORD *)(a1 + 16) = v91;
            }

            a4 = 0;
            *(double *)(i - 40) = result;
            *(_DWORD *)(i - 32) = v57;
            *(_DWORD *)(i - 2_Block_object_dispose(va, 8) = v58;
            *(void *)(i - 24) = v60;
            *(void *)(i - 16) = v59;
            *(void *)(i - _Block_object_dispose(va, 8) = v61;
            continue;
          }

          uint64_t v20 = *(void *)a1;
          unsigned __int16 v21 = *(_DWORD *)(a1 + 8);
          uint64_t v22 = *(_DWORD *)(a1 + 12);
          id v23 = *(void *)(a1 + 16);
          uint64_t v24 = *(void *)(a1 + 24);
          uint64_t v25 = *(void *)(a1 + 32);
          uint64_t v26 = *(void *)a1;
          for (uint64_t k = a1 + 40; ; k += 40LL)
          {
            unint64_t v28 = *(_DWORD *)(k + 12);
            uint64_t v29 = v28 >= v22;
            if (v28 == v22)
            {
              int v30 = *(_DWORD *)(k + 32);
              uint64_t v29 = v30 >= v25;
              if (v30 == (_DWORD)v25)
              {
                uint64_t v29 = *(_DWORD *)k >= v26;
                if (*(_DWORD *)k == v26)
                {
                  uint64_t v31 = *(_DWORD *)(k + 8);
                  uint64_t v29 = v31 >= v21;
                  if (v31 == v21) {
                    uint64_t v29 = *(void *)(k + 24) >= v24;
                  }
                }
              }
            }

            if (v29) {
              break;
            }
          }

          unint64_t m = v9;
          if (k - 40 == a1)
          {
            unint64_t m = v193;
            if (k < v193)
            {
              for (unint64_t m = v9; ; m -= 40LL)
              {
                __int128 v37 = *(_DWORD *)(m + 12);
                unint64_t v38 = v37 >= v22;
                if (v37 == v22
                  && (v39 = *(_DWORD *)(m + 32), unint64_t v38 = v39 >= v25, v39 == (_DWORD)v25)
                  && (unint64_t v38 = *(_DWORD *)m >= v26, *(_DWORD *)m == v26))
                {
                  uint64_t v40 = *(_DWORD *)(m + 8);
                  unsigned __int16 v41 = v40 >= v21;
                  if (v40 == v21) {
                    unsigned __int16 v41 = *(void *)(m + 24) >= v24;
                  }
                  if (!v41 || k >= m) {
                    break;
                  }
                }

                else if (!v38 || k >= m)
                {
                  break;
                }
              }
            }
          }

          else
          {
            while (1)
            {
              id v33 = *(_DWORD *)(m + 12);
              __int128 v34 = v33 >= v22;
              if (v33 == v22)
              {
                __int128 v35 = *(_DWORD *)(m + 32);
                __int128 v34 = v35 >= v25;
                if (v35 == (_DWORD)v25)
                {
                  __int128 v34 = *(_DWORD *)m >= v26;
                  if (*(_DWORD *)m == v26)
                  {
                    __int128 v36 = *(_DWORD *)(m + 8);
                    __int128 v34 = v36 >= v21;
                    if (v36 == v21) {
                      __int128 v34 = *(void *)(m + 24) >= v24;
                    }
                  }
                }
              }

              if (!v34) {
                break;
              }
              m -= 40LL;
            }
          }

          uint64_t i = k;
          if (k < m)
          {
            uint64_t i = k;
            id v43 = m;
            do
            {
              uint64_t v205 = *(void *)(i + 32);
              unint64_t v195 = *(_OWORD *)i;
              uint64_t v200 = *(_OWORD *)(i + 16);
              uint64_t v44 = *(_OWORD *)v43;
              unint64_t v45 = *(_OWORD *)(v43 + 16);
              *(void *)(i + 32) = *(void *)(v43 + 32);
              *(_OWORD *)uint64_t i = v44;
              *(_OWORD *)(i + 16) = v45;
              *(void *)(v43 + 32) = v205;
              *(_OWORD *)id v43 = v195;
              *(_OWORD *)(v43 + 16) = v200;
              do
              {
                i += 40LL;
                unsigned int v46 = *(_DWORD *)(i + 12);
                uint64_t v47 = v46 >= v22;
                if (v46 == v22)
                {
                  BOOL v48 = *(_DWORD *)(i + 32);
                  uint64_t v47 = v48 >= v25;
                  if (v48 == (_DWORD)v25)
                  {
                    uint64_t v47 = *(_DWORD *)i >= v26;
                    if (*(_DWORD *)i == v26)
                    {
                      uint64_t v49 = *(_DWORD *)(i + 8);
                      uint64_t v47 = v49 >= v21;
                      if (v49 == v21) {
                        uint64_t v47 = *(void *)(i + 24) >= v24;
                      }
                    }
                  }
                }
              }

              while (!v47);
              do
              {
                v43 -= 40LL;
                unsigned __int8 v50 = *(_DWORD *)(v43 + 12);
                unint64_t v51 = v50 >= v22;
                if (v50 == v22)
                {
                  unint64_t v52 = *(_DWORD *)(v43 + 32);
                  unint64_t v51 = v52 >= v25;
                  if (v52 == (_DWORD)v25)
                  {
                    unint64_t v51 = *(_DWORD *)v43 >= v26;
                    if (*(_DWORD *)v43 == v26)
                    {
                      unsigned int v53 = *(_DWORD *)(v43 + 8);
                      unint64_t v51 = v53 >= v21;
                      if (v53 == v21) {
                        unint64_t v51 = *(void *)(v43 + 24) >= v24;
                      }
                    }
                  }
                }
              }

              while (v51);
            }

            while (i < v43);
          }

          if (i - 40 != a1)
          {
            uint64_t v54 = *(_OWORD *)(i - 40);
            unsigned __int8 v55 = *(_OWORD *)(i - 24);
            *(void *)(a1 + 32) = *(void *)(i - 8);
            *(_OWORD *)a1 = v54;
            *(_OWORD *)(a1 + 16) = v55;
          }

          *(void *)(i - 40) = v20;
          *(_DWORD *)(i - 32) = v21;
          *(_DWORD *)(i - 2_Block_object_dispose(va, 8) = v22;
          *(void *)(i - 24) = v23;
          *(void *)(i - 16) = v24;
          *(void *)(i - _Block_object_dispose(va, 8) = v25;
          if (k < m)
          {
LABEL_65:
            std::__introsort<std::_ClassicAlgPolicy,USCSampleComparator &,ShaderProfilerUSCSampleInfo *,false>( a1,  i - 40,  a3,  a4 & 1);
            a4 = 0;
            continue;
          }

          unsigned __int8 v56 = std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,USCSampleComparator &,ShaderProfilerUSCSampleInfo *>( a1,  i - 40);
          if (!std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,USCSampleComparator &,ShaderProfilerUSCSampleInfo *>( i,  v193))
          {
            if (v56) {
              continue;
            }
            goto LABEL_65;
          }

          a2 = (double *)(i - 40);
          if (v56) {
            return result;
          }
          goto LABEL_1;
        }

        id v94 = a1 + 40;
        uint64_t v96 = (double *)a1 == a2 || v94 == (void)a2;
        if ((a4 & 1) == 0)
        {
          if (!v96)
          {
            do
            {
              uint64_t v170 = (double *)v94;
              if (USCSampleComparator::operator()(v94, a1))
              {
                __n128 result = *v170;
                __int128 v171 = *(_DWORD *)(a1 + 48);
                __int128 v172 = *(_DWORD *)(a1 + 52);
                __int128 v173 = *(void *)(a1 + 56);
                __int128 v174 = *(void *)(a1 + 64);
                uint64_t v175 = *(void *)(a1 + 72);
                __int128 v176 = *(void *)v170;
                do
                {
                  uint64_t v177 = a1;
                  uint64_t v178 = *(_OWORD *)(a1 + 16);
                  *(_OWORD *)(a1 + 40) = *(_OWORD *)a1;
                  *(_OWORD *)(a1 + 56) = v178;
                  *(void *)(a1 + 72) = *(void *)(a1 + 32);
                  a1 -= 40LL;
                  uint64_t v179 = *(_DWORD *)(v177 - 28);
                  id v180 = v172 >= v179;
                  if (v172 == v179)
                  {
                    unint64_t v181 = *(_DWORD *)(v177 - 8);
                    id v180 = v175 >= v181;
                    if ((_DWORD)v175 == v181)
                    {
                      unint64_t v182 = *(_DWORD *)(v177 - 40);
                      id v180 = v176 >= v182;
                      if (v176 == v182)
                      {
                        __int128 v183 = *(_DWORD *)(v177 - 32);
                        id v180 = v171 >= v183;
                        if (v171 == v183) {
                          id v180 = v174 >= *(void *)(v177 - 16);
                        }
                      }
                    }
                  }
                }

                while (!v180);
                *(double *)uint64_t v177 = result;
                *(_DWORD *)(v177 + _Block_object_dispose(va, 8) = v171;
                *(_DWORD *)(v177 + 12) = v172;
                *(void *)(v177 + 16) = v173;
                *(void *)(v177 + 24) = v174;
                *(void *)(v177 + 32) = v175;
              }

              id v94 = (uint64_t)(v170 + 5);
              a1 = (uint64_t)v170;
            }

            while (v170 + 5 != a2);
          }

          return result;
        }

        if (v96) {
          return result;
        }
        unint64_t v97 = 0LL;
        unsigned __int32 v98 = a1;
        do
        {
          unint64_t v99 = v94;
          if (!USCSampleComparator::operator()(v94, v98)) {
            goto LABEL_155;
          }
          uint64_t v100 = *(void *)(v98 + 40);
          id v101 = *(_DWORD *)(v98 + 48);
          uint64_t v102 = *(_DWORD *)(v98 + 52);
          int v104 = *(void *)(v98 + 56);
          unint64_t v103 = *(void *)(v98 + 64);
          __n128 result = *(double *)(v98 + 72);
          uint64_t v105 = *(_OWORD *)(v98 + 16);
          *(_OWORD *)unint64_t v99 = *(_OWORD *)v98;
          *(_OWORD *)(v99 + 16) = v105;
          uint64_t v106 = a1;
          *(void *)(v99 + 32) = *(void *)(v98 + 32);
          if (v98 == a1) {
            goto LABEL_154;
          }
          uint64_t v107 = v97;
          while (1)
          {
            id v108 = a1 + v107;
            __int8 v109 = (_DWORD *)(a1 + v107 - 40);
            uint64_t v110 = *(_DWORD *)(a1 + v107 - 28);
            uint64_t v111 = v102 >= v110;
            if (v102 == v110)
            {
              uint64_t v112 = *(_DWORD *)(v108 - 8);
              uint64_t v111 = LODWORD(result) >= v112;
              if (LODWORD(result) == v112)
              {
                uint64_t v111 = v100 >= *v109;
                if ((_DWORD)v100 == *v109)
                {
                  id v113 = *(_DWORD *)(a1 + v107 - 32);
                  uint64_t v111 = v101 >= v113;
                  if (v101 == v113)
                  {
                    if (v103 >= *(void *)(a1 + v107 - 16))
                    {
                      uint64_t v106 = a1 + v107;
                      goto LABEL_154;
                    }

                    goto LABEL_151;
                  }
                }
              }
            }

            if (v111) {
              break;
            }
LABEL_151:
            v98 -= 40LL;
            id v114 = *(_OWORD *)(a1 + v107 - 24);
            *(_OWORD *)id v108 = *(_OWORD *)v109;
            *(_OWORD *)(v108 + 16) = v114;
            *(void *)(v108 + 32) = *(void *)(a1 + v107 - 8);
            v107 -= 40LL;
            if (!v107)
            {
              uint64_t v106 = a1;
              goto LABEL_154;
            }
          }

          uint64_t v106 = v98;
LABEL_154:
          *(void *)uint64_t v106 = v100;
          *(_DWORD *)(v106 + _Block_object_dispose(va, 8) = v101;
          *(_DWORD *)(v106 + 12) = v102;
          *(void *)(v106 + 16) = v104;
          *(void *)(v106 + 24) = v103;
          *(double *)(v106 + 32) = result;
LABEL_155:
          id v94 = v99 + 40;
          v97 += 40LL;
          unsigned __int32 v98 = v99;
        }

        while ((double *)(v99 + 40) != a2);
        return result;
    }
  }

void sub_CAAAC( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, id a25)
{
  std::unique_ptr<GPUToolsPlatformLLVMShaderProfilerHelperImpl>::reset[abi:nn180100](v28, 0LL);
  operator delete(v28);

  _Unwind_Resume(a1);
}

void sub_CAFD4( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, id a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, void *a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, void *a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, void *a37)
{
  _Unwind_Resume(a1);
}

void sub_CB5C0( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, void *a10, void *a11, void *a12, void *a13, void *a14, void *a15, void *a16, uint64_t a17, uint64_t a18, void *a19, void *__p, uint64_t a21, uint64_t a22)
{
  if (__p) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

void sub_CB848(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_CB91C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_CB9EC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_CBB28(_Unwind_Exception *a1)
{
  unint64_t v3 = v2;

  _Unwind_Resume(a1);
}

void sub_CBC20( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  _Unwind_Resume(a1);
}

void sub_CBCFC(_Unwind_Exception *a1)
{
  unint64_t v4 = v3;

  _Unwind_Resume(a1);
}

void sub_CC058( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12)
{
  _Unwind_Resume(a1);
}

void sub_CC170(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_CC2C8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_CC4EC( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, id a12)
{
  _Unwind_Resume(a1);
}

void sub_CC728( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  _Unwind_Resume(a1);
}

void sub_CC7B0()
{
}

void sub_CCE28( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, char a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, char a29)
{
  if (v32) {
    operator delete(v32);
  }
  operator delete(v31);
  std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long>>>::~__hash_table((uint64_t)&a23);
  std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long>>>::~__hash_table((uint64_t)&a29);

  _Unwind_Resume(a1);
}

void std::unique_ptr<MTLGRCStreamingSampleHelper>::reset[abi:nn180100](uint64_t **a1, uint64_t *a2)
{
  uint64_t v2 = *a1;
  *a1 = a2;
  if (v2)
  {
    uint64_t v3 = *v2;
    uint64_t *v2 = 0LL;
    if (v3)
    {
      atomic_store(1u, (unsigned __int8 *)(v3 + 140));
      [*(id *)(v3 + 48) cancelAllOperations];

      std::unique_ptr<GRCSplitBlitTimeData>::reset[abi:nn180100]((id **)(v3 + 24), 0LL);
      std::unique_ptr<GRCSplitBlitTimeData>::reset[abi:nn180100]((id **)(v3 + 16), 0LL);
      std::unique_ptr<GRCCurrentFrameStream>::reset[abi:nn180100]((uint64_t *)(v3 + 8), 0LL);

      operator delete((void *)v3);
    }

    operator delete(v2);
  }

void sub_CD074(_Unwind_Exception *a1)
{
  std::unique_ptr<GRCSplitBlitTimeData>::reset[abi:nn180100]((id **)(v1 + 24), 0LL);
  std::unique_ptr<GRCSplitBlitTimeData>::reset[abi:nn180100]((id **)(v1 + 16), 0LL);
  std::unique_ptr<GRCCurrentFrameStream>::reset[abi:nn180100]((uint64_t *)(v1 + 8), 0LL);

  _Unwind_Resume(a1);
}

void sub_CD4F0(_Unwind_Exception *a1)
{
}

LABEL_8:
      int v10 = (uint64_t *)*v10;
    }

    while (v10);
    unint64_t v6 = *a2;
    id v5 = a2[1];
LABEL_11:
    ++v9;
  }

  while (v9 < v5 + (v6 >> 4));
  id v15 = *(float **)v4;
  if (v8 > 2.22044605e-16)
  {
    for (uint64_t i = (uint64_t *)*((void *)v15 + 2); i; uint64_t i = (uint64_t *)*i)
    {
      id v17 = *((double *)i + 5) / v8 * (double)a3;
      __n128 result = (double *)std::unordered_map<unsigned int,-[GTShaderProfilerHelper _calculateEffectiveGPUEncoderCostforData:andPerLimiterBatchCost:forShaderProfilerResult:]::TimeStats>::operator[]( *((void *)v4 + 1),  *((_DWORD *)i + 4));
      size_t v18 = &result[*((unsigned int *)i + 6)];
      v18[3] = v17 + v18[3];
      i[5] = 0LL;
    }

    return result;
  }
}
}

  uint64_t v16 = *(_DWORD *)v13;
  id v17 = *(_DWORD *)v12;
  if (*(_DWORD *)v13 >= *(_DWORD *)v12)
  {
    if (v17 < v16) {
      goto LABEL_28;
    }
    size_t v18 = *(void *)(v13 + 8);
    size_t v19 = *(void *)(v12 + 8);
    if (v18 >= v19 && (v19 < v18 || *(void *)(v13 + 16) >= *(void *)(v12 + 16))) {
      goto LABEL_28;
    }
  }

  else
  {
    size_t v18 = *(void *)(v13 + 8);
    size_t v19 = *(void *)(v12 + 8);
  }

  uint64_t v20 = *(void *)(v13 + 16);
  *(_DWORD *)id v13 = v17;
  unsigned __int16 v21 = *(void *)(v12 + 16);
  *(void *)(v13 + _Block_object_dispose(va, 8) = v19;
  *(void *)(v13 + 16) = v21;
  uint64_t v22 = a1;
  if (v12 == a1) {
    goto LABEL_27;
  }
  id v23 = v14;
  while (1)
  {
    uint64_t v24 = a1 + v23;
    uint64_t v25 = *(_DWORD *)(a1 + v23 + 24);
    if (v16 >= v25)
    {
      if (v25 < v16) {
        goto LABEL_25;
      }
      uint64_t v26 = *(void *)(a1 + v23 + 32);
      if (v18 >= v26)
      {
        if (v26 < v18)
        {
LABEL_25:
          uint64_t v22 = v12;
          goto LABEL_27;
        }

        if (v20 >= *(void *)(a1 + v23 + 40))
        {
          uint64_t v22 = a1 + v23 + 48;
LABEL_27:
          *(_DWORD *)uint64_t v22 = v16;
          *(void *)(v22 + _Block_object_dispose(va, 8) = v18;
          *(void *)(v22 + 16) = v20;
          if (++v15 == 8) {
            return v13 + 24 == a2;
          }
LABEL_28:
          size_t v12 = v13;
          v14 += 24LL;
          v13 += 24LL;
          if (v13 == a2) {
            return 1LL;
          }
          goto LABEL_8;
        }
      }
    }

    else
    {
      uint64_t v26 = *(void *)(v24 + 32);
    }

    v12 -= 24LL;
    *(_DWORD *)(v24 + 4_Block_object_dispose(va, 8) = v25;
    uint64_t v27 = a1 + v23;
    unint64_t v28 = *(void *)(a1 + v23 + 40);
    *(void *)(v27 + 56) = v26;
    *(void *)(v27 + 64) = v28;
    v23 -= 24LL;
    if (v23 == -48)
    {
      uint64_t v22 = a1;
      goto LABEL_27;
    }
  }

  uint64_t v11 = v8 | (unint64_t)(v10 << 32);
LABEL_9:
  size_t v12 = v7 + 64;
  while (v7 && (*(_BYTE *)(v12 + ((uint64_t)(HIDWORD(v11) - (int)v11) << 6) + 15) & 8) != 0)
  {
    id v13 = v12 + ((uint64_t)(HIDWORD(v11) - (int)v11) << 6);
    id v14 = (int *)(v13 + 8);
    id v15 = IsFuncEnumEndEncoding(*(_DWORD *)(v13 + 8));
    uint64_t v16 = *(void *)v13;
    if ((v15 & 1) != 0) {
      return v16;
    }
    GTResourceTrackerProcessResourceUse(a1, v13, v16);
    GTMTLSMCommandEncoder_processTraceFunc(a3, (uint64_t *)v13, a1[1]);
    ResourceTracker_processCommandEncoder(a1, *v14, a3, *(void *)v13);
    if (IsFuncEnumDrawCall(*v14))
    {
      if (*(_DWORD *)a3 == 70) {
        id v17 = *(unsigned __int8 *)(a3 + 11141);
      }
      else {
        id v17 = 0LL;
      }
      size_t v18 = 0LL;
      size_t v19 = *(void *)v13;
      do
      {
        RenderEncoderLoadAttachment(a1, a2 + v18, v19);
        v18 += 64LL;
      }

      while (v18 != 512);
      RenderEncoderLoadAttachment(a1, a2 + 672, v19);
      RenderEncoderLoadAttachment(a1, a2 + 720, v19);
      if (v17)
      {
        uint64_t v20 = *(void *)(a2 + 792);
        if (v20)
        {
          unsigned __int16 v21 = tracker_resource_get(a1, 22, v20, v19);
          if (v21) {
            v21[4] = v19;
          }
        }
      }

      GTResourceTrackerUsingResource(a1[2], 68, *(void *)(a2 + 784), *a1, a1[1]);
    }

    uint64_t v22 = atomic_load((unsigned int *)(v7 + 4));
    id v23 = v11 + (v22 >> 6);
    uint64_t v24 = (HIDWORD(v11) + 1);
    uint64_t v11 = (v24 << 32) | v11;
    if ((_DWORD)v24 == v23 - 1)
    {
      uint64_t v11 = (v24 << 32) | v24;
      uint64_t v7 = *(void *)(v7 + 40);
      goto LABEL_9;
    }
  }

  return -1LL;
}

    size_t v12 = gt_filepath_merge(*(const char **)a1, *(const char **)(*(void *)(v11 + 24) + 8LL * v10), a3);
    id v13 = open(v12, 0);
    id v14 = v13;
    if (a4)
    {
      if (v13 < 0)
      {
        id v15 = *a4;
        uint64_t v25 = 0u;
        uint64_t v26 = 0u;
        uint64_t v22 = v15;
        id v23 = 500;
        id v9 = "0 <= fd";
        goto LABEL_12;
      }
    }

    else if (v13 < 0)
    {
      return 0LL;
    }

    id v17 = mmap(0LL, *a2, 1, 2, v13, 0LL);
    size_t v19 = *a2;
    close(v14);
    uint64_t v20 = apr_palloc(a3, 0x10uLL);
    *uint64_t v20 = v17;
    v20[1] = v19;
    apr_pool_cleanup_register(a3, v20, (apr_status_t (__cdecl *)(void *))GTData_munmap, v21);
    return v17;
  }

  uint64_t v8 = *a4;
  uint64_t v25 = 0u;
  uint64_t v26 = 0u;
  uint64_t v22 = v8;
  id v23 = 500;
  id v9 = "entry->flags & 0x00000002";
LABEL_12:
  uint64_t v24 = v9;
  GTError_addError(a4, (uint64_t)&v22);
  return 0LL;
}

void sub_CD8A4(_Unwind_Exception *a1)
{
}

void sub_CDAC0(_Unwind_Exception *a1)
{
}

void sub_CDB48( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
}

void sub_CDBE8( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, id a12)
{
  _Unwind_Resume(a1);
}

void sub_CDC98( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, id a12)
{
  _Unwind_Resume(a1);
}

void sub_CDD48( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, id a12)
{
  _Unwind_Resume(a1);
}

void sub_CDDF8( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, id a12)
{
  _Unwind_Resume(a1);
}

void *std::__hash_table<std::__hash_value_type<unsigned int,double>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,double>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,double>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,double>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>( float *a1, unsigned int a2, _DWORD *a3)
{
  unint64_t v6 = a2;
  unint64_t v7 = *((void *)a1 + 1);
  if (v7)
  {
    uint8x8_t v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      unint64_t v3 = a2;
      if (v7 <= a2) {
        unint64_t v3 = a2 % v7;
      }
    }

    else
    {
      unint64_t v3 = ((_DWORD)v7 - 1) & a2;
    }

    id v9 = *(void ***)(*(void *)a1 + 8 * v3);
    if (v9)
    {
      int v10 = *v9;
      if (*v9)
      {
        do
        {
          unint64_t v11 = v10[1];
          if (v11 == a2)
          {
            if (*((_DWORD *)v10 + 4) == a2) {
              return v10;
            }
          }

          else
          {
            if (v8.u32[0] > 1uLL)
            {
              if (v11 >= v7) {
                v11 %= v7;
              }
            }

            else
            {
              v11 &= v7 - 1;
            }

            if (v11 != v3) {
              break;
            }
          }

          int v10 = (void *)*v10;
        }

        while (v10);
      }
    }
  }

  int v10 = operator new(0x20uLL);
  void *v10 = 0LL;
  v10[1] = v6;
  *((_DWORD *)v10 + 4) = *a3;
  v10[3] = 0LL;
  float v12 = (float)(unint64_t)(*((void *)a1 + 3) + 1LL);
  float v13 = a1[8];
  if (v7 && (float)(v13 * (float)v7) >= v12)
  {
    unint64_t v6 = v3;
    goto LABEL_64;
  }

  BOOL v14 = 1LL;
  if (v7 >= 3) {
    BOOL v14 = (v7 & (v7 - 1)) != 0;
  }
  unint64_t v15 = v14 | (2 * v7);
  unint64_t v16 = vcvtps_u32_f32(v12 / v13);
  if (v15 <= v16) {
    int8x8_t prime = (int8x8_t)v16;
  }
  else {
    int8x8_t prime = (int8x8_t)v15;
  }
  if (*(void *)&prime == 1LL)
  {
    int8x8_t prime = (int8x8_t)2LL;
  }

  else if ((*(void *)&prime & (*(void *)&prime - 1LL)) != 0)
  {
    int8x8_t prime = (int8x8_t)std::__next_prime(*(void *)&prime);
    unint64_t v7 = *((void *)a1 + 1);
  }

  if (*(void *)&prime <= v7)
  {
    if (*(void *)&prime >= v7) {
      goto LABEL_60;
    }
    unint64_t v24 = vcvtps_u32_f32((float)*((unint64_t *)a1 + 3) / a1[8]);
    if (v7 < 3 || (uint8x8_t v25 = (uint8x8_t)vcnt_s8((int8x8_t)v7), v25.i16[0] = vaddlv_u8(v25), v25.u32[0] > 1uLL))
    {
      unint64_t v24 = std::__next_prime(v24);
    }

    else
    {
      uint64_t v26 = 1LL << -(char)__clz(v24 - 1);
      if (v24 >= 2) {
        unint64_t v24 = v26;
      }
    }

    if (*(void *)&prime <= v24) {
      int8x8_t prime = (int8x8_t)v24;
    }
    if (*(void *)&prime >= v7)
    {
      unint64_t v7 = *((void *)a1 + 1);
      goto LABEL_60;
    }

    if (!*(void *)&prime)
    {
      id v33 = *(void **)a1;
      *(void *)a1 = 0LL;
      if (v33) {
        operator delete(v33);
      }
      unint64_t v7 = 0LL;
      *((void *)a1 + 1) = 0LL;
      goto LABEL_60;
    }
  }

  if (*(void *)&prime >> 61) {
    std::__throw_bad_array_new_length[abi:nn180100]();
  }
  size_t v18 = operator new(8LL * *(void *)&prime);
  size_t v19 = *(void **)a1;
  *(void *)a1 = v18;
  if (v19) {
    operator delete(v19);
  }
  uint64_t v20 = 0LL;
  *((int8x8_t *)a1 + 1) = prime;
  do
    *(void *)(*(void *)a1 + 8 * v20++) = 0LL;
  while (*(void *)&prime != v20);
  unsigned __int16 v21 = (void *)*((void *)a1 + 2);
  if (v21)
  {
    unint64_t v22 = v21[1];
    uint8x8_t v23 = (uint8x8_t)vcnt_s8(prime);
    v23.i16[0] = vaddlv_u8(v23);
    if (v23.u32[0] > 1uLL)
    {
      if (v22 >= *(void *)&prime) {
        v22 %= *(void *)&prime;
      }
    }

    else
    {
      v22 &= *(void *)&prime - 1LL;
    }

    *(void *)(*(void *)a1 + 8 * v22) = a1 + 4;
    uint64_t v27 = (void *)*v21;
    if (*v21)
    {
      do
      {
        unint64_t v28 = v27[1];
        if (v23.u32[0] > 1uLL)
        {
          if (v28 >= *(void *)&prime) {
            v28 %= *(void *)&prime;
          }
        }

        else
        {
          v28 &= *(void *)&prime - 1LL;
        }

        if (v28 != v22)
        {
          if (!*(void *)(*(void *)a1 + 8 * v28))
          {
            *(void *)(*(void *)a1 + 8 * v2_Block_object_dispose(va, 8) = v21;
            goto LABEL_56;
          }

          *unsigned __int16 v21 = *v27;
          void *v27 = **(void **)(*(void *)a1 + 8 * v28);
          **(void **)(*(void *)a1 + 8 * v2_Block_object_dispose(va, 8) = v27;
          uint64_t v27 = v21;
        }

        unint64_t v28 = v22;
LABEL_56:
        unsigned __int16 v21 = v27;
        uint64_t v27 = (void *)*v27;
        unint64_t v22 = v28;
      }

      while (v27);
    }
  }

  unint64_t v7 = (unint64_t)prime;
LABEL_60:
  if ((v7 & (v7 - 1)) != 0)
  {
    if (v7 <= v6) {
      v6 %= v7;
    }
  }

  else
  {
    unint64_t v6 = ((_DWORD)v7 - 1) & v6;
  }

void sub_CE1F8(_Unwind_Exception *a1)
{
}

void sub_CE320(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_CE428(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_CE4E8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void std::vector<DYMTLShaderProfilerProgramAddress>::reserve(void **a1, unint64_t a2)
{
  if (0xAAAAAAAAAAAAAAABLL * (((_BYTE *)a1[2] - (_BYTE *)*a1) >> 3) < a2)
  {
    if (a2 >= 0xAAAAAAAAAAAAAABLL) {
      abort();
    }
    uint64_t v3 = ((_BYTE *)a1[1] - (_BYTE *)*a1) / 24;
    unint64_t v4 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<std::vector<NSObject  {objcproto21OS_dispatch_semaphore}* {__strong}>>>(a2);
    id v5 = &v4[24 * v3];
    unint64_t v7 = &v4[24 * v6];
    id v9 = (char *)*a1;
    uint8x8_t v8 = (char *)a1[1];
    int v10 = v5;
    if (v8 != *a1)
    {
      do
      {
        __int128 v11 = *(_OWORD *)(v8 - 24);
        *((void *)v10 - 1) = *((void *)v8 - 1);
        *(_OWORD *)(v10 - 24) = v11;
        v10 -= 24;
        v8 -= 24;
      }

      while (v8 != v9);
      uint8x8_t v8 = (char *)*a1;
    }

    *a1 = v10;
    a1[1] = v5;
    a1[2] = v7;
    if (v8) {
      operator delete(v8);
    }
  }

void std::vector<std::vector<ShaderBinaryInfo * {__strong}>>::__destroy_vector::operator()[abi:nn180100]( void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = (void **)**a1;
  if (v2)
  {
    unint64_t v4 = (void **)v1[1];
    id v5 = **a1;
    if (v4 != v2)
    {
      uint64_t v6 = (void **)v1[1];
      do
      {
        uint8x8_t v8 = (char *)*(v6 - 3);
        v6 -= 3;
        unint64_t v7 = v8;
        if (v8)
        {
          id v9 = (char *)*(v4 - 2);
          int v10 = v7;
          if (v9 != v7)
          {
            do
            {
              __int128 v11 = (void *)*((void *)v9 - 1);
              v9 -= 8;
            }

            while (v9 != v7);
            int v10 = *v6;
          }

          *(v4 - 2) = v7;
          operator delete(v10);
        }

        unint64_t v4 = v6;
      }

      while (v6 != v2);
      id v5 = **a1;
    }

    v1[1] = v2;
    operator delete(v5);
  }

void sub_CE7B0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_CED2C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_CEEC8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_CEFEC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_CF0D8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_CF204(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_CF2F4( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
}

void sub_CF3E0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, void *a16)
{
  _Unwind_Resume(a1);
}

void sub_CF5E8( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, id a16)
{
  _Unwind_Resume(a1);
}

void std::vector<std::vector<DebugInfo::LineEntry *>>::__vdeallocate(uint64_t *a1)
{
  if (*a1)
  {
    std::vector<std::vector<ProfileEvent>>::__clear[abi:nn180100](a1);
    operator delete((void *)*a1);
    *a1 = 0LL;
    a1[1] = 0LL;
    a1[2] = 0LL;
  }

uint64_t std::__hash_table<std::__hash_value_type<std::string,PerFileCost>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,PerFileCost>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,PerFileCost>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,PerFileCost>>>::~__hash_table( uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 16);
  if (v2)
  {
    do
    {
      uint64_t v3 = (void *)*v2;
      std::__destroy_at[abi:nn180100]<std::pair<std::string const,PerFileCost>,0>((uint64_t)(v2 + 2));
      operator delete(v2);
      uint64_t v2 = v3;
    }

    while (v3);
  }

  unint64_t v4 = *(void **)a1;
  *(void *)a1 = 0LL;
  if (v4) {
    operator delete(v4);
  }
  return a1;
}

void std::vector<DebugInfo::LineDisassemblyInfo>::__destroy_vector::operator()[abi:nn180100](void ***a1)
{
  uint64_t v2 = *a1;
  if (*v2)
  {
    std::vector<DebugInfo::LineDisassemblyInfo>::__base_destruct_at_end[abi:nn180100]((uint64_t)v2, (uint64_t)*v2);
    operator delete(**a1);
  }

void std::vector<DebugInfo::LineEntry>::__destroy_vector::operator()[abi:nn180100](void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = **a1;
  if (v2)
  {
    uint64_t v4 = (uint64_t)v1[1];
    id v5 = **a1;
    if ((void *)v4 != v2)
    {
      do
      {
        v4 -= 80LL;
        std::allocator<DebugInfo::LineEntry>::destroy[abi:nn180100](v4);
      }

      while ((void *)v4 != v2);
      id v5 = **a1;
    }

    v1[1] = v2;
    operator delete(v5);
  }

void DebugInfo::~DebugInfo(DebugInfo *this)
{
  p_var0 = (void **)&this->var1.var0;
  std::vector<DebugInfo::LineDisassemblyInfo>::__destroy_vector::operator()[abi:nn180100](&p_var0);
  p_var0 = (void **)&this->var0.var0;
  std::vector<DebugInfo::LineEntry>::__destroy_vector::operator()[abi:nn180100](&p_var0);
}

void std::allocator<DebugInfo::LineEntry>::destroy[abi:nn180100](uint64_t a1)
{
  uint64_t v2 = (void **)(a1 + 56);
  std::vector<DebugInfo::BlockInfo>::__destroy_vector::operator()[abi:nn180100](&v2);
  uint64_t v2 = (void **)(a1 + 32);
  std::vector<DebugInfo::LineDisassemblyInfo>::__destroy_vector::operator()[abi:nn180100](&v2);
}

void std::vector<DebugInfo::BlockInfo>::__destroy_vector::operator()[abi:nn180100](void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = **a1;
  if (v2)
  {
    uint64_t v4 = (uint64_t)v1[1];
    id v5 = **a1;
    if ((void *)v4 != v2)
    {
      do
      {
        v4 -= 104LL;
        std::allocator<DebugInfo::BlockInfo>::destroy[abi:nn180100](v4);
      }

      while ((void *)v4 != v2);
      id v5 = **a1;
    }

    v1[1] = v2;
    operator delete(v5);
  }

void std::allocator<DebugInfo::BlockInfo>::destroy[abi:nn180100](uint64_t a1)
{
}

void std::vector<DebugInfo::LineDisassemblyInfo>::__base_destruct_at_end[abi:nn180100]( uint64_t a1, uint64_t a2)
{
  for (uint64_t i = *(void *)(a1 + 8); i != a2; i -= 40LL)
  {

    id v5 = *(void **)(i - 40);
  }

  *(void *)(a1 + _Block_object_dispose(va, 8) = a2;
}

void std::__destroy_at[abi:nn180100]<std::pair<std::string const,PerFileCost>,0>(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 72);
  if (v2)
  {
    do
    {
      uint64_t v3 = (void *)*v2;
      uint64_t v4 = (void *)v2[3];
      if (v4)
      {
        v2[4] = v4;
        operator delete(v4);
      }

      operator delete(v2);
      uint64_t v2 = v3;
    }

    while (v3);
  }

  id v5 = *(void **)(a1 + 56);
  *(void *)(a1 + 56) = 0LL;
  if (v5) {
    operator delete(v5);
  }
  uint64_t v6 = *(void **)(a1 + 24);
  if (v6)
  {
    *(void *)(a1 + 32) = v6;
    operator delete(v6);
  }

uint64_t *std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>( uint64_t *result, uint64_t *a2)
{
  *((_BYTE *)a2 + 24) = a2 == result;
  if (a2 != result)
  {
    do
    {
      uint64_t v2 = (uint64_t *)a2[2];
      if (*((_BYTE *)v2 + 24)) {
        return result;
      }
      uint64_t v3 = (uint64_t *)v2[2];
      uint64_t v4 = (uint64_t *)*v3;
      if ((uint64_t *)*v3 == v2)
      {
        uint64_t v7 = v3[1];
        if (!v7 || (int v8 = *(unsigned __int8 *)(v7 + 24), v5 = (_BYTE *)(v7 + 24), v8))
        {
          if ((uint64_t *)*v2 == a2)
          {
            id v9 = (uint64_t **)a2[2];
          }

          else
          {
            id v9 = (uint64_t **)v2[1];
            int v10 = *v9;
            v2[1] = (uint64_t)*v9;
            if (v10)
            {
              v10[2] = (uint64_t)v2;
              uint64_t v3 = (uint64_t *)v2[2];
            }

            v9[2] = v3;
            *(void *)(v2[2] + 8LL * (*(void *)v2[2] != (void)v2)) = v9;
            char *v9 = v2;
            v2[2] = (uint64_t)v9;
            uint64_t v3 = v9[2];
            uint64_t v2 = (uint64_t *)*v3;
          }

          *((_BYTE *)v9 + 24) = 1;
          *((_BYTE *)v3 + 24) = 0;
          uint64_t v13 = v2[1];
          uint64_t *v3 = v13;
          if (v13) {
            *(void *)(v13 + 16) = v3;
          }
          v2[2] = v3[2];
          *(void *)(v3[2] + 8LL * (*(void *)v3[2] != (void)v3)) = v2;
          v2[1] = (uint64_t)v3;
          goto LABEL_27;
        }
      }

      else if (!v4 || (int v6 = *((unsigned __int8 *)v4 + 24), v5 = v4 + 3, v6))
      {
        if ((uint64_t *)*v2 == a2)
        {
          uint64_t v11 = a2[1];
          uint64_t *v2 = v11;
          if (v11)
          {
            *(void *)(v11 + 16) = v2;
            uint64_t v3 = (uint64_t *)v2[2];
          }

          a2[2] = (uint64_t)v3;
          *(void *)(v2[2] + 8LL * (*(void *)v2[2] != (void)v2)) = a2;
          a2[1] = (uint64_t)v2;
          v2[2] = (uint64_t)a2;
          uint64_t v3 = (uint64_t *)a2[2];
        }

        else
        {
          a2 = (uint64_t *)a2[2];
        }

        *((_BYTE *)a2 + 24) = 1;
        *((_BYTE *)v3 + 24) = 0;
        uint64_t v2 = (uint64_t *)v3[1];
        uint64_t v12 = *v2;
        v3[1] = *v2;
        if (v12) {
          *(void *)(v12 + 16) = v3;
        }
        v2[2] = v3[2];
        *(void *)(v3[2] + 8LL * (*(void *)v3[2] != (void)v3)) = v2;
        uint64_t *v2 = (uint64_t)v3;
LABEL_27:
        v3[2] = (uint64_t)v2;
        return result;
      }

      *((_BYTE *)v2 + 24) = 1;
      a2 = v3;
      *((_BYTE *)v3 + 24) = v3 == result;
      _BYTE *v5 = 1;
    }

    while (v3 != result);
  }

  return result;
}

void std::vector<DebugInfo::BlockInfo>::__assign_with_size[abi:nn180100]<DebugInfo::BlockInfo*,DebugInfo::BlockInfo*>( uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  uint64_t v8 = *(void *)a1;
  if (0x4EC4EC4EC4EC4EC5LL * ((uint64_t)(*(void *)(a1 + 16) - *(void *)a1) >> 3) < a4)
  {
    std::vector<DebugInfo::BlockInfo>::__vdeallocate((void **)a1);
    if (a4 > 0x276276276276276LL) {
      abort();
    }
    unint64_t v9 = 0x9D89D89D89D89D8ALL * ((uint64_t)(*(void *)(a1 + 16) - *(void *)a1) >> 3);
    if (v9 <= a4) {
      unint64_t v9 = a4;
    }
    else {
      unint64_t v10 = v9;
    }
    std::vector<DebugInfo::BlockInfo>::__vallocate[abi:nn180100]((void *)a1, v10);
    uint64_t v11 = a1;
    uint64_t v12 = a2;
    goto LABEL_11;
  }

  if (0x4EC4EC4EC4EC4EC5LL * ((*(void *)(a1 + 8) - v8) >> 3) < a4)
  {
    uint64_t v13 = a2 + 8 * ((*(void *)(a1 + 8) - v8) >> 3);
    std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<DebugInfo::BlockInfo *,DebugInfo::BlockInfo *,DebugInfo::BlockInfo *>( a2,  v13,  v8);
    uint64_t v11 = a1;
    uint64_t v12 = v13;
LABEL_11:
    std::vector<DebugInfo::BlockInfo>::__construct_at_end<DebugInfo::BlockInfo*,DebugInfo::BlockInfo*>(v11, v12, a3);
    return;
  }

  uint64_t v14 = std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<DebugInfo::BlockInfo *,DebugInfo::BlockInfo *,DebugInfo::BlockInfo *>( a2,  a3,  v8);
  for (uint64_t i = *(void *)(a1 + 8); i != v14; std::allocator<DebugInfo::BlockInfo>::destroy[abi:nn180100](i))
    i -= 104LL;
  *(void *)(a1 + _Block_object_dispose(va, 8) = v14;
}

void *std::__allocate_at_least[abi:nn180100]<std::allocator<-[GTShaderProfilerHelper _processPerLineCostDataForLineTable:withFileCost:withDebugInfo:andAllDrawCost:withKey:withShaderSourcePath:withDrawCost:]::SourceDisassemblyInfo>>( unint64_t a1)
{
  if (a1 >= 0x492492492492493LL) {
    std::__throw_bad_array_new_length[abi:nn180100]();
  }
  return operator new(56 * a1);
}

LABEL_74:
  __int128 v37 = *(std::locale::__imp ***)(*(void *)v5 + 8 * v2);
  if (v37)
  {
    *(void *)v79[0].__locale_ = *v37;
    *__int128 v37 = v79[0].__locale_;
  }

  else
  {
    *(void *)v79[0].__locale_ = *(void *)(v5 + 16);
    *(std::locale *)(v5 + 16) = v79[0];
    *(void *)(*(void *)v5 + 8 * v2) = v19;
    if (*(void *)v79[0].__locale_)
    {
      uint64_t v38 = *(void *)(*(void *)v79[0].__locale_ + 8LL);
      if ((v12 & (v12 - 1)) != 0)
      {
        if (v38 >= v12) {
          v38 %= v12;
        }
      }

      else
      {
        v38 &= v12 - 1;
      }

      *(std::locale *)(*(void *)v5 + 8 * v3_Block_object_dispose(va, 8) = v79[0];
    }
  }

  uint64_t i = v79[0].__locale_;
  v79[0].__locale_ = 0LL;
  ++*(void *)(v5 + 24);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,std::vector<-[GTShaderProfilerHelper _processPerLineCostDataForLineTable:withFileCost:withDebugInfo:andAllDrawCost:withKey:withShaderSourcePath:withDrawCost:]::LineSourceInfo>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,std::vector<-[GTShaderProfilerHelper _processPerLineCostDataForLineTable:withFileCost:withDebugInfo:andAllDrawCost:withKey:withShaderSourcePath:withDrawCost:]::LineSourceInfo>>,void *>>>>::~unique_ptr[abi:nn180100]((uint64_t)v79);
LABEL_83:
  std::vector<-[GTShaderProfilerHelper _processPerLineCostDataForLineTable:withFileCost:withDebugInfo:andAllDrawCost:withKey:withShaderSourcePath:withDrawCost:]::LineSourceInfo>::~vector[abi:nn180100]((void **)&v87);
  std::vector<-[GTShaderProfilerHelper _processPerLineCostDataForLineTable:withFileCost:withDebugInfo:andAllDrawCost:withKey:withShaderSourcePath:withDrawCost:]::LineSourceInfo>::~vector[abi:nn180100]((void **)&v84);
  uint64_t v83 = 0;
  unsigned int v39 = (void *)objc_claimAutoreleasedReturnValue(+[NSFileManager defaultManager](&OBJC_CLASS___NSFileManager, "defaultManager"));
  if ((a2->__r_.__value_.__s.__size_ & 0x80u) == 0) {
    uint64_t v40 = a2;
  }
  else {
    uint64_t v40 = (std::string *)a2->__r_.__value_.__r.__words[0];
  }
  unsigned __int16 v41 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", v40));
  unsigned int v42 = [v39 fileExistsAtPath:v41 isDirectory:&v83];
  if (v83) {
    id v43 = 0;
  }
  else {
    id v43 = v42;
  }

  if ((v43 & 1) == 0)
  {
    uint64_t v65 = *((void *)i + 5);
    unint64_t v66 = *((void *)i + 6);
    __int128 v67 = (*(_DWORD *)v77[1] + 1);
    uint64_t v68 = 0x6DB6DB6DB6DB6DB7LL * ((v66 - v65) >> 3);
    uint64_t v69 = v67 - v68;
    if (v67 <= v68)
    {
      if (v67 < v68)
      {
        id v75 = v65 + 56LL * v67;
        while (v66 != v75)
        {
          v66 -= 56LL;
          std::allocator_traits<std::allocator<-[GTShaderProfilerHelper _processPerLineCostDataForLineTable:withFileCost:withDebugInfo:andAllDrawCost:withKey:withShaderSourcePath:withDrawCost:]::LineSourceInfo>>::destroy[abi:nn180100]<-[GTShaderProfilerHelper _processPerLineCostDataForLineTable:withFileCost:withDebugInfo:andAllDrawCost:withKey:withShaderSourcePath:withDrawCost:]::LineSourceInfo,void>(v66);
        }

        *((void *)i + 6) = v75;
      }
    }

    else
    {
      uint64_t v70 = *((void *)i + 7);
      if (0x6DB6DB6DB6DB6DB7LL * ((v70 - v66) >> 3) >= v69)
      {
        bzero(*((void **)i + 6), 56 * ((56 * v69 - 56) / 0x38) + 56);
        *((void *)i + 6) = v66 + 56 * ((56 * v69 - 56) / 0x38) + 56;
      }

      else
      {
        uint64_t v71 = 0x6DB6DB6DB6DB6DB7LL * ((v70 - v65) >> 3);
        if (2 * v71 > v67) {
          __int128 v67 = 2 * v71;
        }
        if (v71 >= 0x249249249249249LL) {
          uint64_t v72 = 0x492492492492492LL;
        }
        else {
          uint64_t v72 = v67;
        }
        std::__split_buffer<-[GTShaderProfilerHelper _processPerLineCostDataForLineTable:withFileCost:withDebugInfo:andAllDrawCost:withKey:withShaderSourcePath:withDrawCost:]::LineSourceInfo>::__split_buffer( &v86,  v72,  v68,  (uint64_t)i + 56);
        cap = v86.__r_.__value_.__l.__cap_;
        char v74 = 56 * ((56 * v69 - 56) / 0x38) + 56;
        bzero((void *)v86.__r_.__value_.__l.__cap_, v74);
        v86.__r_.__value_.__l.__cap_ = cap + v74;
        std::vector<-[GTShaderProfilerHelper _processPerLineCostDataForLineTable:withFileCost:withDebugInfo:andAllDrawCost:withKey:withShaderSourcePath:withDrawCost:]::LineSourceInfo>::__swap_out_circular_buffer( (uint64_t *)i + 5,  &v86);
        std::__split_buffer<-[GTShaderProfilerHelper _processPerLineCostDataForLineTable:withFileCost:withDebugInfo:andAllDrawCost:withKey:withShaderSourcePath:withDrawCost:]::LineSourceInfo>::~__split_buffer((uint64_t)&v86);
      }
    }

    return;
  }

  v86.__r_.__value_.__r.__words[0] = v44;
  *(std::string::size_type *)((char *)v86.__r_.__value_.__r.__words + *(void *)(v44 - 24)) = v45;
  v86.__r_.__value_.__l.__size_ = 0LL;
  unsigned int v46 = (std::ios_base *)((char *)&v86 + *(void *)(v86.__r_.__value_.__r.__words[0] - 24));
  std::ios_base::init(v46, &v86.__r_.__value_.__r.__words[2]);
  v46[1].__vftable = 0LL;
  v46[1].__fmtflags_ = -1;
  std::filebuf::basic_filebuf(&v86.__r_.__value_.__r.__words[2]);
  if ((a2->__r_.__value_.__s.__size_ & 0x80u) == 0) {
    uint64_t v47 = a2;
  }
  else {
    uint64_t v47 = (std::string *)a2->__r_.__value_.__r.__words[0];
  }
  if (!std::filebuf::open(&v86.__r_.__value_.__r.__words[2], v47, 8LL)) {
    std::ios_base::clear( (std::ios_base *)((char *)&v86 + *(void *)(v86.__r_.__value_.__r.__words[0] - 24)),  *(_DWORD *)((char *)&v88[-1] + *(void *)(v86.__r_.__value_.__r.__words[0] - 24)) | 4);
  }
  memset(&__str, 0, sizeof(__str));
  BOOL v48 = (void *)((char *)i + 40);
  while (2)
  {
    std::ios_base::getloc((const std::ios_base *)((char *)&v86 + *(void *)(v86.__r_.__value_.__r.__words[0] - 24)));
    uint64_t v49 = std::locale::use_facet(v79, &std::ctype<char>::id);
    unsigned __int8 v50 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v49->__vftable[2].~facet_0)(v49, 10LL);
    std::locale::~locale(v79);
    std::istream::sentry::sentry(v79, &v86, 1LL);
    if (!LOBYTE(v79[0].__locale_)) {
      goto LABEL_116;
    }
    if ((char)__str.__r_.__value_.__s.__size_ < 0)
    {
      *__str.__r_.__value_.__l.__data_ = 0;
      __str.__r_.__value_.__l.__size_ = 0LL;
    }

    else
    {
      __str.__r_.__value_.__s.__data_[0] = 0;
      __str.__r_.__value_.__s.__size_ = 0;
    }

    unint64_t v51 = 0LL;
    while (1)
    {
      unint64_t v52 = *(void **)((char *)v88 + *(void *)(v86.__r_.__value_.__r.__words[0] - 24));
      unsigned int v53 = (_BYTE *)v52[3];
      if (v53 != (_BYTE *)v52[4])
      {
        v52[3] = v53 + 1;
        LOBYTE(v52) = *v53;
        goto LABEL_107;
      }

      LODWORD(v52) = (*(uint64_t (**)(void *))(*v52 + 80LL))(v52);
      if ((_DWORD)v52 == -1) {
        break;
      }
LABEL_107:
      if (v50 == v52)
      {
        uint64_t v54 = 0;
        goto LABEL_115;
      }

      std::string::push_back(&__str, (std::string::value_type)v52);
      ++v51;
      if ((char)__str.__r_.__value_.__s.__size_ < 0 && __str.__r_.__value_.__l.__size_ == 0x7FFFFFFFFFFFFFF7LL)
      {
        uint64_t v54 = 4;
        goto LABEL_115;
      }
    }

    if (v51) {
      uint64_t v54 = 2;
    }
    else {
      uint64_t v54 = 6;
    }
LABEL_115:
    std::ios_base::clear( (std::ios_base *)((char *)&v86 + *(void *)(v86.__r_.__value_.__r.__words[0] - 24)),  *(_DWORD *)((char *)&v88[-1] + *(void *)(v86.__r_.__value_.__r.__words[0] - 24)) | v54);
LABEL_116:
    if ((*((_BYTE *)&v88[-1] + *(void *)(v86.__r_.__value_.__r.__words[0] - 24)) & 5) == 0)
    {
      uint64_t v81 = 0LL;
      __int128 v80 = 0u;
      memset(v79, 0, sizeof(v79));
      unsigned __int8 v55 = *((void *)i + 6);
      unsigned __int8 v56 = *((void *)i + 7);
      if (v55 >= v56)
      {
        __int128 v59 = 0x6DB6DB6DB6DB6DB7LL * ((uint64_t)(v55 - *v48) >> 3);
        id v60 = v59 + 1;
        __int128 v61 = 0x6DB6DB6DB6DB6DB7LL * ((uint64_t)(v56 - *v48) >> 3);
        if (2 * v61 > v60) {
          id v60 = 2 * v61;
        }
        if (v61 >= 0x249249249249249LL) {
          uint64_t v62 = 0x492492492492492LL;
        }
        else {
          uint64_t v62 = v60;
        }
        std::__split_buffer<-[GTShaderProfilerHelper _processPerLineCostDataForLineTable:withFileCost:withDebugInfo:andAllDrawCost:withKey:withShaderSourcePath:withDrawCost:]::LineSourceInfo>::__split_buffer( &v84,  v62,  v59,  (uint64_t)i + 56);
        uint64_t v63 = v85;
        v85->__locale_ = (std::locale::__imp *)v79[0];
        uint64_t v64 = *(_OWORD *)&v79[1].__locale_;
        v63[3].__locale_ = (std::locale::__imp *)v79[3];
        v63[4].__locale_ = 0LL;
        *(_OWORD *)&v63[1].__locale_ = v64;
        memset(&v79[1], 0, 24);
        v63[5].__locale_ = 0LL;
        v63[6].__locale_ = 0LL;
        *(_OWORD *)&v63[4].__locale_ = v80;
        v63[6].__locale_ = v81;
        __int128 v80 = 0uLL;
        uint64_t v81 = 0LL;
        v85 += 7;
        std::vector<-[GTShaderProfilerHelper _processPerLineCostDataForLineTable:withFileCost:withDebugInfo:andAllDrawCost:withKey:withShaderSourcePath:withDrawCost:]::LineSourceInfo>::__swap_out_circular_buffer( (uint64_t *)i + 5,  &v84);
        unsigned __int8 v58 = *((void *)i + 6);
        std::__split_buffer<-[GTShaderProfilerHelper _processPerLineCostDataForLineTable:withFileCost:withDebugInfo:andAllDrawCost:withKey:withShaderSourcePath:withDrawCost:]::LineSourceInfo>::~__split_buffer((uint64_t)&v84);
      }

      else
      {
        *(void *)unsigned __int8 v55 = 0LL;
        unsigned __int8 v57 = *(_OWORD *)&v79[1].__locale_;
        *(std::locale *)(v55 + 24) = v79[3];
        *(void *)(v55 + 32) = 0LL;
        *(_OWORD *)(v55 + _Block_object_dispose(va, 8) = v57;
        memset(&v79[1], 0, 24);
        *(void *)(v55 + 40) = 0LL;
        *(void *)(v55 + 4_Block_object_dispose(va, 8) = 0LL;
        *(_OWORD *)(v55 + 32) = v80;
        *(void *)(v55 + 4_Block_object_dispose(va, 8) = v81;
        __int128 v80 = 0uLL;
        uint64_t v81 = 0LL;
        unsigned __int8 v58 = v55 + 56;
      }

      *((void *)i + 6) = v58;
      std::vector<-[GTShaderProfilerHelper _processPerLineCostDataForLineTable:withFileCost:withDebugInfo:andAllDrawCost:withKey:withShaderSourcePath:withDrawCost:]::LineInfo>::~vector[abi:nn180100]((uint64_t *)&v80);
      if (SHIBYTE(v79[3].__locale_) < 0) {
        operator delete(v79[1].__locale_);
      }
      std::string::operator=((std::string *)(*((void *)i + 6) - 48LL), &__str);
      continue;
    }

    break;
  }

                  __int128 v36 = 0LL;
                  goto LABEL_36;
                }

                __int128 v34 = *v88;
                uint64_t v40 = *v90 != 0;
                if (!*v89) {
                  goto LABEL_54;
                }
                uint64_t v62 = *v87;
                uint64_t v63 = *v86;
LABEL_57:
                uint64_t v7 = (unsigned int *)((char *)v7 + *v7);
                id v75 = 0LL;
                unsigned __int16 v41 = FBDecoder_DecodeArguments((unsigned int *)&v75, (uint64_t)(v7 + 9), *v7 - 36, (uint64_t)&v80, 9uLL);
                if (a5)
                {
                  if (v41)
                  {
                    unsigned int v42 = *a5;
                    uint64_t v71 = 0LL;
                    uint64_t v72 = 0LL;
                    BOOL v73 = 0LL;
                    uint64_t v68 = v42;
                    uint64_t v69 = 500;
                    uint64_t v70 = "err == FBUF_SUCCESS";
                    char v74 = 0LL;
                    GTError_addError(a5, (uint64_t)&v68);
LABEL_61:
                    id v33 = 0;
                    goto LABEL_74;
                  }

                  else {
                    id v43 = asc_317218[(v27 - 62)];
                  }
                  if (*(void *)v83 != v43)
                  {
                    uint64_t v44 = *a5;
                    uint64_t v71 = 0LL;
                    uint64_t v72 = 0LL;
                    BOOL v73 = 0LL;
                    uint64_t v68 = v44;
                    uint64_t v69 = 500;
                    uint64_t v70 = "pixelFormat == DataTypeToPixelFormat(result.dataType)";
                    char v74 = 0LL;
                    GTError_addError(a5, (uint64_t)&v68);
                  }
                }

                else if (v41)
                {
                  goto LABEL_61;
                }

                id v33 = *(_BYTE *)__s;
                unsigned int v39 = v62;
                uint64_t v38 = v63;
                goto LABEL_68;
              }

              if (*(_BYTE *)v88)
              {
                uint64_t v62 = *v87;
                uint64_t v63 = *v86;
                __int128 v34 = 0;
LABEL_51:
                uint64_t v40 = 0;
                goto LABEL_57;
              }
            }

            __int128 v34 = 0;
            goto LABEL_53;
          }
        }

        else
        {
          unint64_t v31 = 0LL;
          uint64_t v29 = (char *)a3[23];
        }

        int v30 = 0LL;
        goto LABEL_42;
      }

LABEL_143:
  std::filebuf::~filebuf(&v86.__r_.__value_.__r.__words[2]);
  std::ios::~ios(&v89);
}

void sub_D08C8( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, std::locale a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, void *__p, uint64_t a22, int a23, __int16 a24, char a25, char a26, uint64_t a27, void *a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, char a34)
{
}

uint64_t *std::__copy[abi:nn180100]<std::_ClassicAlgPolicy,-[GTShaderProfilerHelper _processPerLineCostDataForLineTable:withFileCost:withDebugInfo:andAllDrawCost:withKey:withShaderSourcePath:withDrawCost:]::LineInfo *,-[GTShaderProfilerHelper _processPerLineCostDataForLineTable:withFileCost:withDebugInfo:andAllDrawCost:withKey:withShaderSourcePath:withDrawCost:]::LineInfo *,-[GTShaderProfilerHelper _processPerLineCostDataForLineTable:withFileCost:withDebugInfo:andAllDrawCost:withKey:withShaderSourcePath:withDrawCost:]::LineInfo *>( uint64_t *a1, uint64_t *a2, uint64_t *a3)
{
  if (a1 != a2)
  {
    id v5 = a1;
    while (a3 == v5)
    {
LABEL_23:
      v5 += 6;
      a3 += 6;
      if (v5 == a2) {
        return a3;
      }
    }

    uint64_t v7 = *v5;
    uint64_t v6 = v5[1];
    unint64_t v8 = 0x6DB6DB6DB6DB6DB7LL * ((v6 - *v5) >> 3);
    uint64_t v9 = a3[2];
    uint64_t v10 = *a3;
    if (0x6DB6DB6DB6DB6DB7LL * ((v9 - *a3) >> 3) >= v8)
    {
      uint64_t v16 = a3[1];
      if (0x6DB6DB6DB6DB6DB7LL * ((v16 - v10) >> 3) >= v8)
      {
        while (v7 != v6)
        {
          objc_storeStrong((id *)v10, *(id *)v7);
          objc_storeStrong((id *)(v10 + 8), *(id *)(v7 + 8));
          __int128 v20 = *(_OWORD *)(v7 + 16);
          __int128 v21 = *(_OWORD *)(v7 + 32);
          *(void *)(v10 + 4_Block_object_dispose(va, 8) = *(void *)(v7 + 48);
          *(_OWORD *)(v10 + 16) = v20;
          *(_OWORD *)(v10 + 32) = v21;
          v10 += 56LL;
          v7 += 56LL;
        }

        std::vector<-[GTShaderProfilerHelper _processPerLineCostDataForLineTable:withFileCost:withDebugInfo:andAllDrawCost:withKey:withShaderSourcePath:withDrawCost:]::SourceDisassemblyInfo>::__base_destruct_at_end[abi:nn180100]( (uint64_t)a3,  v10);
        goto LABEL_22;
      }

      uint64_t v17 = v7 + 8 * ((v16 - v10) >> 3);
      if (v16 != v10)
      {
        do
        {
          objc_storeStrong((id *)v10, *(id *)v7);
          objc_storeStrong((id *)(v10 + 8), *(id *)(v7 + 8));
          __int128 v18 = *(_OWORD *)(v7 + 16);
          __int128 v19 = *(_OWORD *)(v7 + 32);
          *(void *)(v10 + 4_Block_object_dispose(va, 8) = *(void *)(v7 + 48);
          *(_OWORD *)(v10 + 16) = v18;
          *(_OWORD *)(v10 + 32) = v19;
          v7 += 56LL;
          v10 += 56LL;
        }

        while (v7 != v17);
      }

      uint64_t v14 = a3;
      uint64_t v15 = v17;
    }

    else
    {
      if (v10)
      {
        std::vector<-[GTShaderProfilerHelper _processPerLineCostDataForLineTable:withFileCost:withDebugInfo:andAllDrawCost:withKey:withShaderSourcePath:withDrawCost:]::SourceDisassemblyInfo>::__base_destruct_at_end[abi:nn180100]( (uint64_t)a3,  *a3);
        operator delete((void *)*a3);
        uint64_t v9 = 0LL;
        *a3 = 0LL;
        a3[1] = 0LL;
        a3[2] = 0LL;
      }

      if (v8 > 0x492492492492492LL) {
        abort();
      }
      unint64_t v11 = 0x6DB6DB6DB6DB6DB7LL * (v9 >> 3);
      uint64_t v12 = 2 * v11;
      if (2 * v11 <= v8) {
        uint64_t v12 = v8;
      }
      if (v11 >= 0x249249249249249LL) {
        unint64_t v13 = 0x492492492492492LL;
      }
      else {
        unint64_t v13 = v12;
      }
      std::vector<-[GTShaderProfilerHelper _processPerLineCostDataForLineTable:withFileCost:withDebugInfo:andAllDrawCost:withKey:withShaderSourcePath:withDrawCost:]::SourceDisassemblyInfo>::__vallocate[abi:nn180100]( a3,  v13);
      uint64_t v14 = a3;
      uint64_t v15 = v7;
    }

    std::vector<-[GTShaderProfilerHelper _processPerLineCostDataForLineTable:withFileCost:withDebugInfo:andAllDrawCost:withKey:withShaderSourcePath:withDrawCost:]::SourceDisassemblyInfo>::__construct_at_end<-[GTShaderProfilerHelper _processPerLineCostDataForLineTable:withFileCost:withDebugInfo:andAllDrawCost:withKey:withShaderSourcePath:withDrawCost:]::SourceDisassemblyInfo*,-[GTShaderProfilerHelper _processPerLineCostDataForLineTable:withFileCost:withDebugInfo:andAllDrawCost:withKey:withShaderSourcePath:withDrawCost:]::SourceDisassemblyInfo*>( v14,  v15,  v6);
LABEL_22:
    std::vector<DebugInfo::BlockInfo>::__assign_with_size[abi:nn180100]<DebugInfo::BlockInfo*,DebugInfo::BlockInfo*>( (uint64_t)(a3 + 3),  v5[3],  v5[4],  0x4EC4EC4EC4EC4EC5LL * ((v5[4] - v5[3]) >> 3));
    goto LABEL_23;
  }

  return a3;
}

char *std::vector<DebugInfo::BlockInfo>::__vallocate[abi:nn180100](void *a1, unint64_t a2)
{
  if (a2 >= 0x276276276276277LL) {
    abort();
  }
  __n128 result = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<DebugInfo::BlockInfo>>(a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[104 * v4];
  return result;
}

void std::vector<DebugInfo::BlockInfo>::__construct_at_end<DebugInfo::BlockInfo*,DebugInfo::BlockInfo*>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = *(void *)(a1 + 8);
  if (a2 != a3)
  {
    uint64_t v7 = 0LL;
    do
    {
      uint64_t v8 = a2 + v7;
      *(void *)(v4 + v7) = *(void *)(a2 + v7);
      uint64_t v9 = (const std::string::value_type **)(a2 + v7 + 8);
      if (*(char *)(a2 + v7 + 31) < 0)
      {
        std::string::__init_copy_ctor_external((std::string *)(v4 + v7 + 8), *v9, *(void *)(v8 + 16));
      }

      else
      {
        __int128 v10 = *(_OWORD *)v9;
        *(void *)(v4 + v7 + 24) = *(void *)(a2 + v7 + 24);
        *(_OWORD *)(v4 + v7 + _Block_object_dispose(va, 8) = v10;
      }

      unint64_t v11 = (const std::string::value_type **)(a2 + v7 + 32);
      if (*(char *)(v8 + 55) < 0)
      {
        std::string::__init_copy_ctor_external((std::string *)(v4 + v7 + 32), *v11, *(void *)(a2 + v7 + 40));
      }

      else
      {
        __int128 v12 = *(_OWORD *)v11;
        *(void *)(v4 + v7 + 4_Block_object_dispose(va, 8) = *(void *)(a2 + v7 + 48);
        *(_OWORD *)(v4 + v7 + 32) = v12;
      }

      unint64_t v13 = (const std::string::value_type **)(a2 + v7 + 56);
      if (*(char *)(v8 + 79) < 0)
      {
        std::string::__init_copy_ctor_external((std::string *)(v4 + v7 + 56), *v13, *(void *)(a2 + v7 + 64));
      }

      else
      {
        __int128 v14 = *(_OWORD *)v13;
        *(void *)(v4 + v7 + 72) = *(void *)(a2 + v7 + 72);
        *(_OWORD *)(v4 + v7 + 56) = v14;
      }

      uint64_t v15 = (std::string *)(v4 + v7 + 80);
      uint64_t v16 = (const std::string::value_type **)(a2 + v7 + 80);
      if (*(char *)(v8 + 103) < 0)
      {
        std::string::__init_copy_ctor_external(v15, *v16, *(void *)(a2 + v7 + 88));
      }

      else
      {
        __int128 v17 = *(_OWORD *)v16;
        *(void *)(v4 + v7 + 96) = *(void *)(a2 + v7 + 96);
        *(_OWORD *)&v15->__r_.__value_.__l.__data_ = v17;
      }

      v7 += 104LL;
    }

    while (v8 + 104 != a3);
    v4 += v7;
  }

  *(void *)(a1 + _Block_object_dispose(va, 8) = v4;
}

void sub_D10FC(_Unwind_Exception *exception_object)
{
  if (v6[79] < 0) {
    operator delete(*v4);
  }
  if (v6[55] < 0) {
    operator delete(*v3);
  }
  if (v6[31] < 0) {
    operator delete(*v2);
  }
  *(void *)(v1 + _Block_object_dispose(va, 8) = v5;
  _Unwind_Resume(exception_object);
}

void *std::__allocate_at_least[abi:nn180100]<std::allocator<DebugInfo::BlockInfo>>(unint64_t a1)
{
  if (a1 >= 0x276276276276277LL) {
    std::__throw_bad_array_new_length[abi:nn180100]();
  }
  return operator new(104 * a1);
}

void *std::ifstream::~ifstream(void *a1)
{
  return a1;
}

uint64_t std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<DebugInfo::BlockInfo *,DebugInfo::BlockInfo *,DebugInfo::BlockInfo *>( uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a1 != a2)
  {
    uint64_t v5 = a1;
    do
    {
      *(void *)a3 = *(void *)v5;
      std::string::operator=((std::string *)(a3 + 8), (const std::string *)(v5 + 8));
      std::string::operator=((std::string *)(a3 + 32), (const std::string *)(v5 + 32));
      std::string::operator=((std::string *)(a3 + 56), (const std::string *)(v5 + 56));
      std::string::operator=((std::string *)(a3 + 80), (const std::string *)(v5 + 80));
      a3 += 104LL;
      v5 += 104LL;
    }

    while (v5 != a2);
  }

  return a3;
}

void std::vector<DebugInfo::BlockInfo>::__vdeallocate(void **a1)
{
  uint64_t v1 = *a1;
  if (*a1)
  {
    uint64_t v3 = (uint64_t)a1[1];
    uint64_t v4 = *a1;
    if ((void *)v3 != v1)
    {
      do
      {
        v3 -= 104LL;
        std::allocator<DebugInfo::BlockInfo>::destroy[abi:nn180100](v3);
      }

      while ((void *)v3 != v1);
      uint64_t v4 = *a1;
    }

    a1[1] = v1;
    operator delete(v4);
    *a1 = 0LL;
    a1[1] = 0LL;
    a1[2] = 0LL;
  }

void std::vector<double>::resize(char **a1, unint64_t a2, void *a3)
{
  uint64_t v6 = *a1;
  uint64_t v5 = a1[1];
  unint64_t v7 = (v5 - *a1) >> 3;
  if (a2 <= v7)
  {
    if (a2 < v7) {
      a1[1] = &v6[8 * a2];
    }
  }

  else
  {
    uint64_t v9 = a1[2];
    if (a2 - v7 <= (v9 - v5) >> 3)
    {
      uint8x8_t v23 = &v5[8 * (a2 - v7)];
      uint64_t v24 = 8 * a2 - 8 * v7;
      do
      {
        *(void *)uint64_t v5 = *a3;
        v5 += 8;
        v24 -= 8LL;
      }

      while (v24);
      a1[1] = v23;
    }

    else
    {
      if (a2 >> 61) {
        abort();
      }
      unint64_t v10 = v9 - v6;
      unint64_t v11 = (v9 - v6) >> 2;
      if (v11 <= a2) {
        unint64_t v11 = a2;
      }
      if (v10 >= 0x7FFFFFFFFFFFFFF8LL) {
        unint64_t v12 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v12 = v11;
      }
      unint64_t v13 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<std::pair<unsigned int,unsigned int>>>(v12);
      uint64_t v15 = &v13[8 * v7];
      uint64_t v16 = &v13[8 * a2];
      uint64_t v17 = 8 * a2 - 8 * v7;
      __int128 v18 = v15;
      do
      {
        *(void *)__int128 v18 = *a3;
        v18 += 8;
        v17 -= 8LL;
      }

      while (v17);
      __int128 v19 = &v13[8 * v14];
      __int128 v20 = *a1;
      for (uint64_t i = a1[1]; i != v20; i -= 8)
      {
        uint64_t v22 = *((void *)i - 1);
        *((void *)v15 - 1) = v22;
        v15 -= 8;
      }

      *a1 = v15;
      a1[1] = v16;
      a1[2] = v19;
      if (v20) {
        operator delete(v20);
      }
    }
  }

void std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,PerFileCost>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,PerFileCost>,void *>>>>::reset[abi:nn180100]( uint64_t a1)
{
  uint64_t v1 = *(void **)a1;
  *(void *)a1 = 0LL;
  if (v1)
  {
    if (*(_BYTE *)(a1 + 16)) {
      std::__destroy_at[abi:nn180100]<std::pair<std::string const,PerFileCost>,0>((uint64_t)v1 + 16);
    }
    operator delete(v1);
  }

void MachOInfo::MachOInfo(MachOInfo *this, unsigned __int8 *a2)
{
  *((_OWORD *)this + 1) = 0u;
  *(_OWORD *)this = 0u;
  if (a2)
  {
    uint64_t v2 = a2 + 32;
    for (int i = *((_DWORD *)a2 + 4); i; --i)
    {
      if (*(_DWORD *)v2 == 25) {
        break;
      }
      v2 += *((unsigned int *)v2 + 1);
    }

    int v4 = *((_DWORD *)v2 + 16);
    if (v4)
    {
      uint64_t v5 = v2 + 88;
      do
      {
        BOOL v6 = *(_DWORD *)v5 == 1163157343 && *(_DWORD *)(v5 + 3) == 5527621;
        unint64_t v7 = (char *)this + 8;
        uint64_t v8 = this;
        if (v6
          || (*(void *)v5 == 0x454D5F5550475F5FLL ? (BOOL v9 = *(void *)(v5 + 7) == 0x41544144415445LL) : (BOOL v9 = 0),
              unint64_t v7 = (char *)this + 24,
              uint64_t v8 = (MachOInfo *)((char *)this + 16),
              v9))
        {
          *(void *)unint64_t v7 = *((unsigned int *)v5 + 6);
          *(void *)uint64_t v8 = *((unsigned int *)v5 + 8);
        }

        v5 += 80;
        --v4;
      }

      while (v4);
    }
  }

void std::vector<DebugInfo::LineEntry>::resize(uint64_t a1, unint64_t a2)
{
  int v4 = *(char **)a1;
  uint64_t v3 = *(char **)(a1 + 8);
  unint64_t v5 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)&v3[-*(void *)a1] >> 4);
  unint64_t v6 = a2 - v5;
  if (a2 > v5)
  {
    uint64_t v7 = *(void *)(a1 + 16);
    if (0xCCCCCCCCCCCCCCCDLL * ((v7 - (uint64_t)v3) >> 4) >= v6)
    {
      bzero(*(void **)(a1 + 8), 80 * ((80 * v6 - 80) / 0x50) + 80);
      *(void *)(a1 + _Block_object_dispose(va, 8) = &v3[80 * ((80 * v6 - 80) / 0x50) + 80];
      return;
    }

    if (a2 > 0x333333333333333LL) {
      abort();
    }
    unint64_t v8 = 0xCCCCCCCCCCCCCCCDLL * ((v7 - (uint64_t)v4) >> 4);
    uint64_t v9 = 2 * v8;
    if (2 * v8 <= a2) {
      uint64_t v9 = a2;
    }
    if (v8 >= 0x199999999999999LL) {
      unint64_t v10 = 0x333333333333333LL;
    }
    else {
      unint64_t v10 = v9;
    }
    if (v10 > 0x333333333333333LL) {
      std::__throw_bad_array_new_length[abi:nn180100]();
    }
    uint64_t v11 = 5 * v10;
    unint64_t v12 = (char *)operator new(80 * v10);
    unint64_t v13 = &v12[80 * v5];
    uint64_t v14 = &v12[16 * v11];
    size_t v15 = 80 * ((80 * v6 - 80) / 0x50) + 80;
    bzero(v13, v15);
    uint64_t v16 = &v13[v15];
    if (v3 == v4)
    {
      *(void *)a1 = v13;
      *(void *)(a1 + _Block_object_dispose(va, 8) = v16;
      *(void *)(a1 + 16) = v14;
      if (!v3) {
        return;
      }
    }

    else
    {
      uint64_t v17 = 0LL;
      do
      {
        __int128 v18 = &v13[v17];
        __int128 v19 = &v3[v17];
        __int128 v20 = *(_OWORD *)&v3[v17 - 80];
        *((void *)v18 - _Block_object_dispose(va, 8) = *(void *)&v3[v17 - 64];
        *((_OWORD *)v18 - 5) = v20;
        *((void *)v19 - 9) = 0LL;
        *((void *)v19 - _Block_object_dispose(va, 8) = 0LL;
        *((void *)v19 - 10) = 0LL;
        *((void *)v18 - 7) = *(void *)&v3[v17 - 56];
        *((void *)v18 - 4) = 0LL;
        *((_OWORD *)v18 - 3) = *(_OWORD *)&v3[v17 - 48];
        *((void *)v18 - 4) = *(void *)&v3[v17 - 32];
        *((void *)v19 - 6) = 0LL;
        *((void *)v19 - 5) = 0LL;
        *((void *)v19 - 4) = 0LL;
        *((void *)v18 - 1) = 0LL;
        *(_OWORD *)(v18 - 24) = *(_OWORD *)&v3[v17 - 24];
        *((void *)v18 - 1) = *(void *)&v3[v17 - 8];
        *((void *)v19 - 3) = 0LL;
        *((void *)v19 - 2) = 0LL;
        *((void *)v19 - 1) = 0LL;
        v17 -= 80LL;
      }

      while (&v3[v17] != v4);
      __int128 v21 = &v13[v17];
      uint64_t v22 = *(char **)a1;
      uint64_t v3 = *(char **)(a1 + 8);
      *(void *)a1 = v21;
      *(void *)(a1 + _Block_object_dispose(va, 8) = v16;
      *(void *)(a1 + 16) = v14;
      if (v3 != v22)
      {
        do
        {
          v3 -= 80;
          std::allocator<DebugInfo::LineEntry>::destroy[abi:nn180100]((uint64_t)v3);
        }

        while (v3 != v22);
        uint64_t v3 = v22;
      }

      if (!v3) {
        return;
      }
    }

    operator delete(v3);
    return;
  }

  if (a2 < v5)
  {
    uint8x8_t v23 = &v4[80 * a2];
    while (v3 != v23)
    {
      v3 -= 80;
      std::allocator<DebugInfo::LineEntry>::destroy[abi:nn180100]((uint64_t)v3);
    }

    *(void *)(a1 + _Block_object_dispose(va, 8) = v23;
  }

unint64_t std::vector<DebugInfo::BlockInfo>::__push_back_slow_path<DebugInfo::BlockInfo>( unint64_t *a1, uint64_t a2)
{
  uint64_t v2 = 0x4EC4EC4EC4EC4EC5LL * ((uint64_t)(a1[1] - *a1) >> 3);
  unint64_t v3 = v2 + 1;
  else {
    unint64_t v6 = v3;
  }
  if (v6) {
    unint64_t v6 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<DebugInfo::BlockInfo>>(v6);
  }
  else {
    uint64_t v7 = 0LL;
  }
  unint64_t v8 = v6 + 104 * v2;
  unint64_t v9 = v6 + 104 * v7;
  *(void *)unint64_t v8 = *(void *)a2;
  __int128 v10 = *(_OWORD *)(a2 + 8);
  *(void *)(v8 + 24) = *(void *)(a2 + 24);
  *(_OWORD *)(v8 + _Block_object_dispose(va, 8) = v10;
  *(void *)(a2 + 16) = 0LL;
  *(void *)(a2 + 24) = 0LL;
  *(void *)(a2 + _Block_object_dispose(va, 8) = 0LL;
  __int128 v11 = *(_OWORD *)(a2 + 32);
  *(void *)(v8 + 4_Block_object_dispose(va, 8) = *(void *)(a2 + 48);
  *(_OWORD *)(v8 + 32) = v11;
  *(void *)(a2 + 40) = 0LL;
  *(void *)(a2 + 4_Block_object_dispose(va, 8) = 0LL;
  *(void *)(a2 + 32) = 0LL;
  __int128 v12 = *(_OWORD *)(a2 + 56);
  *(void *)(v8 + 72) = *(void *)(a2 + 72);
  *(_OWORD *)(v8 + 56) = v12;
  *(void *)(a2 + 64) = 0LL;
  *(void *)(a2 + 72) = 0LL;
  *(void *)(a2 + 56) = 0LL;
  __int128 v13 = *(_OWORD *)(a2 + 80);
  *(void *)(v8 + 96) = *(void *)(a2 + 96);
  *(_OWORD *)(v8 + 80) = v13;
  *(void *)(a2 + 80) = 0LL;
  *(void *)(a2 + 8_Block_object_dispose(va, 8) = 0LL;
  *(void *)(a2 + 96) = 0LL;
  unint64_t v14 = v8 + 104;
  unint64_t v15 = *a1;
  unint64_t v16 = a1[1];
  if (v16 == *a1)
  {
    *a1 = v8;
    a1[1] = v14;
    a1[2] = v9;
  }

  else
  {
    do
    {
      uint64_t v17 = *(void *)(v16 - 104);
      v16 -= 104LL;
      *(void *)(v8 - 104) = v17;
      v8 -= 104LL;
      __int128 v18 = *(_OWORD *)(v16 + 8);
      *(void *)(v8 + 24) = *(void *)(v16 + 24);
      *(_OWORD *)(v8 + _Block_object_dispose(va, 8) = v18;
      *(void *)(v16 + 16) = 0LL;
      *(void *)(v16 + 24) = 0LL;
      *(void *)(v16 + _Block_object_dispose(va, 8) = 0LL;
      __int128 v19 = *(_OWORD *)(v16 + 32);
      *(void *)(v8 + 4_Block_object_dispose(va, 8) = *(void *)(v16 + 48);
      *(_OWORD *)(v8 + 32) = v19;
      *(void *)(v16 + 40) = 0LL;
      *(void *)(v16 + 4_Block_object_dispose(va, 8) = 0LL;
      *(void *)(v16 + 32) = 0LL;
      __int128 v20 = *(_OWORD *)(v16 + 56);
      *(void *)(v8 + 72) = *(void *)(v16 + 72);
      *(_OWORD *)(v8 + 56) = v20;
      *(void *)(v16 + 64) = 0LL;
      *(void *)(v16 + 72) = 0LL;
      *(void *)(v16 + 56) = 0LL;
      __int128 v21 = *(_OWORD *)(v16 + 80);
      *(void *)(v8 + 96) = *(void *)(v16 + 96);
      *(_OWORD *)(v8 + 80) = v21;
      *(void *)(v16 + 80) = 0LL;
      *(void *)(v16 + 8_Block_object_dispose(va, 8) = 0LL;
      *(void *)(v16 + 96) = 0LL;
    }

    while (v16 != v15);
    unint64_t v16 = *a1;
    uint64_t v22 = a1[1];
    *a1 = v8;
    a1[1] = v14;
    a1[2] = v9;
    while (v22 != v16)
    {
      v22 -= 104LL;
      std::allocator<DebugInfo::BlockInfo>::destroy[abi:nn180100](v22);
    }
  }

  if (v16) {
    operator delete((void *)v16);
  }
  return v14;
}

void constructFullPath(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(void *)a1 = 0LL;
  *(void *)(a1 + _Block_object_dispose(va, 8) = 0LL;
  *(void *)(a1 + 16) = 0LL;
  int v6 = *(unsigned __int8 *)(a2 + 23);
  if ((*(char *)(a2 + 23) & 0x80000000) == 0)
  {
    if (*(_BYTE *)(a2 + 23))
    {
      uint64_t v7 = (_BYTE *)a2;
      if (v6 != 1) {
        goto LABEL_10;
      }
      goto LABEL_8;
    }

LABEL_9:
    std::operator+<char>(&v18, "/", a3);
    *(std::string *)a1 = v18;
    return;
  }

  uint64_t v8 = *(void *)(a2 + 8);
  if (!v8) {
    goto LABEL_9;
  }
  if (v8 != 1) {
    goto LABEL_10;
  }
  uint64_t v7 = *(_BYTE **)a2;
LABEL_8:
  if (*v7 == 47) {
    goto LABEL_9;
  }
LABEL_10:
  if ((v6 & 0x80u) == 0) {
    size_t v9 = *(unsigned __int8 *)(a2 + 23);
  }
  else {
    size_t v9 = *(void *)(a2 + 8);
  }
  __int128 v10 = &v18;
  std::string::basic_string[abi:nn180100]((uint64_t)&v18, v9 + 1);
  if ((v18.__r_.__value_.__s.__size_ & 0x80u) != 0) {
    __int128 v10 = (std::string *)v18.__r_.__value_.__r.__words[0];
  }
  if (v9)
  {
    else {
      __int128 v11 = *(const void **)a2;
    }
    memmove(v10, v11, v9);
  }

  *(_WORD *)((char *)&v10->__r_.__value_.__l.__data_ + v9) = 47;
  int v12 = *(char *)(a3 + 23);
  if (v12 >= 0) {
    __int128 v13 = (const std::string::value_type *)a3;
  }
  else {
    __int128 v13 = *(const std::string::value_type **)a3;
  }
  if (v12 >= 0) {
    std::string::size_type v14 = *(unsigned __int8 *)(a3 + 23);
  }
  else {
    std::string::size_type v14 = *(void *)(a3 + 8);
  }
  unint64_t v15 = std::string::append(&v18, v13, v14);
  std::string::size_type size = v15->__r_.__value_.__l.__size_;
  *(void *)a1 = v15->__r_.__value_.__r.__words[0];
  *(void *)(a1 + _Block_object_dispose(va, 8) = size;
  *(void *)(a1 + 15) = *(std::string::size_type *)((char *)&v15->__r_.__value_.__r.__words[1] + 7);
  LOBYTE(size) = v15->__r_.__value_.__s.__size_;
  v15->__r_.__value_.__l.__size_ = 0LL;
  v15->__r_.__value_.__l.__cap_ = 0LL;
  v15->__r_.__value_.__r.__words[0] = 0LL;
  int v17 = (char)v18.__r_.__value_.__s.__size_;
  *(_BYTE *)(a1 + 23) = size;
  if (v17 < 0) {
    operator delete(v18.__r_.__value_.__l.__data_);
  }
}

        if (v13)
        {
LABEL_20:

          goto LABEL_21;
        }

void sub_D1D00( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void DebugInfo::BlockInfo::~BlockInfo(void **this)
{
}

void std::vector<DebugInfo::LineDisassemblyInfo>::resize(void **a1, unint64_t a2, uint64_t a3)
{
  unint64_t v5 = (char *)*a1;
  int v6 = (char *)a1[1];
  unint64_t v7 = 0xCCCCCCCCCCCCCCCDLL * ((v6 - (_BYTE *)*a1) >> 3);
  unint64_t v8 = a2 - v7;
  if (a2 > v7)
  {
    __int128 v10 = a1[2];
    if (0xCCCCCCCCCCCCCCCDLL * ((v10 - v6) >> 3) >= v8)
    {
      uint8x8_t v25 = &v6[40 * v8];
      uint64_t v26 = (_OWORD *)(a3 + 16);
      do
      {
        *(void *)int v6 = *(id *)a3;
        *((void *)v6 + 1) = *(id *)(a3 + 8);
        uint64_t v27 = *(void *)(a3 + 32);
        *((_OWORD *)v6 + 1) = *v26;
        *((void *)v6 + 4) = v27;
        v6 += 40;
      }

      while (v6 != v25);
      a1[1] = v25;
      return;
    }

    if (a2 > 0x666666666666666LL) {
      abort();
    }
    unint64_t v11 = 0xCCCCCCCCCCCCCCCDLL * ((v10 - v5) >> 3);
    uint64_t v12 = 2 * v11;
    if (2 * v11 <= a2) {
      uint64_t v12 = a2;
    }
    if (v11 >= 0x333333333333333LL) {
      unint64_t v13 = 0x666666666666666LL;
    }
    else {
      unint64_t v13 = v12;
    }
    if (v13 > 0x666666666666666LL) {
      std::__throw_bad_array_new_length[abi:nn180100]();
    }
    std::string::size_type v14 = (char *)operator new(40 * v13);
    unint64_t v15 = &v14[40 * v7];
    unint64_t v16 = &v14[40 * a2];
    int v17 = v15;
    do
    {
      *(void *)int v17 = *(id *)a3;
      *((void *)v17 + 1) = *(id *)(a3 + 8);
      *((_OWORD *)v17 + 1) = *(_OWORD *)(a3 + 16);
      *((void *)v17 + 4) = *(void *)(a3 + 32);
      v17 += 40;
    }

    while (v17 != v16);
    std::string v18 = &v14[40 * v13];
    __int128 v19 = (char *)*a1;
    __int128 v20 = (char *)a1[1];
    if (v20 == *a1)
    {
      *a1 = v15;
      a1[1] = v16;
      a1[2] = v18;
      if (!v20) {
        return;
      }
    }

    else
    {
      do
      {
        __int128 v21 = *(_OWORD *)(v20 - 40);
        v20 -= 40;
        *(void *)__int128 v20 = 0LL;
        *((void *)v20 + 1) = 0LL;
        *(_OWORD *)(v15 - 40) = v21;
        v15 -= 40;
        __int128 v22 = *((_OWORD *)v20 + 1);
        *((void *)v15 + 4) = *((void *)v20 + 4);
        *((_OWORD *)v15 + 1) = v22;
      }

      while (v20 != v19);
      uint8x8_t v23 = (char *)*a1;
      __int128 v20 = (char *)a1[1];
      *a1 = v15;
      a1[1] = v16;
      a1[2] = v18;
      if (v20 != v23)
      {
        do
        {

          uint64_t v24 = (void *)*((void *)v20 - 5);
          v20 -= 40;
        }

        while (v20 != v23);
        __int128 v20 = v23;
      }

      if (!v20) {
        return;
      }
    }

    operator delete(v20);
    return;
  }

  if (a2 < v7) {
    std::vector<DebugInfo::LineDisassemblyInfo>::__base_destruct_at_end[abi:nn180100]( (uint64_t)a1,  (uint64_t)&v5[40 * a2]);
  }
}

void std::vector<InstructionInfo>::__destroy_vector::operator()[abi:nn180100](void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = (void **)**a1;
  if (v2)
  {
    int v4 = (void **)v1[1];
    unint64_t v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        v4 -= 5;
      }

      while (v4 != v2);
      unint64_t v5 = **a1;
    }

    v1[1] = v2;
    operator delete(v5);
  }

void GTScopeFunction::~GTScopeFunction(GTScopeFunction *this)
{
  uint64_t v2 = *((void *)this + 3);
  if (v2)
  {
    (*(void (**)(uint64_t))(*(void *)v2 + 48LL))(v2);
    unint64_t v3 = (GTScopeFunction *)*((void *)this + 3);
    if (v3 == this)
    {
      uint64_t v4 = 4LL;
      unint64_t v3 = this;
    }

    else
    {
      if (!v3) {
        return;
      }
      uint64_t v4 = 5LL;
    }

    (*(void (**)(void))(*(void *)v3 + 8 * v4))();
  }

void sub_D2074(_Unwind_Exception *exception_object)
{
  unint64_t v3 = (void *)v1[3];
  if (v3 == v1)
  {
    uint64_t v4 = 4LL;
  }

  else
  {
    if (!v3) {
      goto LABEL_6;
    }
    uint64_t v4 = 5LL;
    uint64_t v1 = (void *)v1[3];
  }

  (*(void (**)(void *))(*v1 + 8 * v4))(v1);
LABEL_6:
  _Unwind_Resume(exception_object);
}

void std::vector<DebugInfo::LineDisassemblyInfo>::__vdeallocate(uint64_t *a1)
{
  if (*a1)
  {
    std::vector<DebugInfo::LineDisassemblyInfo>::__base_destruct_at_end[abi:nn180100]((uint64_t)a1, *a1);
    operator delete((void *)*a1);
    *a1 = 0LL;
    a1[1] = 0LL;
    a1[2] = 0LL;
  }

uint64_t std::string::basic_string[abi:nn180100](uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x7FFFFFFFFFFFFFF8LL) {
    abort();
  }
  if (a2 > 0x16)
  {
    uint64_t v4 = (a2 & 0xFFFFFFFFFFFFFFF8LL) + 8;
    if ((a2 | 7) != 0x17) {
      uint64_t v4 = a2 | 7;
    }
    uint64_t v5 = v4 + 1;
    int v6 = operator new(v4 + 1);
    *(void *)(a1 + _Block_object_dispose(va, 8) = a2;
    *(void *)(a1 + 16) = v5 | 0x8000000000000000LL;
    *(void *)a1 = v6;
  }

  else
  {
    *(void *)(a1 + _Block_object_dispose(va, 8) = 0LL;
    *(void *)(a1 + 16) = 0LL;
    *(void *)a1 = 0LL;
    *(_BYTE *)(a1 + 23) = a2;
  }

  return a1;
}

uint64_t std::__function::__func<DebugInfo::DebugInfo(GTShaderProfilerHelper *,NSData *,NSData *,int,MachOInfo *)::$_0,std::allocator<DebugInfo::DebugInfo(GTShaderProfilerHelper *,NSData *,NSData *,int,MachOInfo *)::$_0>,void ()(void)>::~__func( uint64_t a1)
{
  return a1;
}

void std::__function::__func<DebugInfo::DebugInfo(GTShaderProfilerHelper *,NSData *,NSData *,int,MachOInfo *)::$_0,std::allocator<DebugInfo::DebugInfo(GTShaderProfilerHelper *,NSData *,NSData *,int,MachOInfo *)::$_0>,void ()(void)>::~__func( id *a1)
{
}

void *std::__function::__func<DebugInfo::DebugInfo(GTShaderProfilerHelper *,NSData *,NSData *,int,MachOInfo *)::$_0,std::allocator<DebugInfo::DebugInfo(GTShaderProfilerHelper *,NSData *,NSData *,int,MachOInfo *)::$_0>,void ()(void)>::__clone( uint64_t a1)
{
  uint64_t v2 = operator new(0x10uLL);
  void *v2 = off_58E6A8;
  v2[1] = *(id *)(a1 + 8);
  return v2;
}

id std::__function::__func<DebugInfo::DebugInfo(GTShaderProfilerHelper *,NSData *,NSData *,int,MachOInfo *)::$_0,std::allocator<DebugInfo::DebugInfo(GTShaderProfilerHelper *,NSData *,NSData *,int,MachOInfo *)::$_0>,void ()(void)>::__clone( uint64_t a1, void *a2)
{
  *a2 = off_58E6A8;
  id result = *(id *)(a1 + 8);
  a2[1] = result;
  return result;
}

void std::__function::__func<DebugInfo::DebugInfo(GTShaderProfilerHelper *,NSData *,NSData *,int,MachOInfo *)::$_0,std::allocator<DebugInfo::DebugInfo(GTShaderProfilerHelper *,NSData *,NSData *,int,MachOInfo *)::$_0>,void ()(void)>::destroy( uint64_t a1)
{
}

void std::__function::__func<DebugInfo::DebugInfo(GTShaderProfilerHelper *,NSData *,NSData *,int,MachOInfo *)::$_0,std::allocator<DebugInfo::DebugInfo(GTShaderProfilerHelper *,NSData *,NSData *,int,MachOInfo *)::$_0>,void ()(void)>::destroy_deallocate( id *a1)
{
}

void std::__function::__func<DebugInfo::DebugInfo(GTShaderProfilerHelper *,NSData *,NSData *,int,MachOInfo *)::$_0,std::allocator<DebugInfo::DebugInfo(GTShaderProfilerHelper *,NSData *,NSData *,int,MachOInfo *)::$_0>,void ()(void)>::operator()( uint64_t a1)
{
  id v2 = (id)objc_claimAutoreleasedReturnValue(+[NSFileManager defaultManager](&OBJC_CLASS___NSFileManager, "defaultManager"));
  [v2 removeItemAtURL:*(void *)(a1 + 8) error:0];
}

void sub_D22A8( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
}

void sub_D2360( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{
  _Unwind_Resume(a1);
}

void sub_D2468( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void *std::__hash_table<std::__hash_value_type<unsigned int,std::vector<DYMTLShaderProfilerProgramAddress *>>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,std::vector<DYMTLShaderProfilerProgramAddress *>>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,std::vector<DYMTLShaderProfilerProgramAddress *>>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,std::vector<DYMTLShaderProfilerProgramAddress *>>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>( uint64_t a1, unsigned int a2, _DWORD *a3)
{
  unint64_t v6 = a2;
  unint64_t v7 = *(void *)(a1 + 8);
  if (v7)
  {
    uint8x8_t v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      unint64_t v3 = a2;
      if (v7 <= a2) {
        unint64_t v3 = a2 % v7;
      }
    }

    else
    {
      unint64_t v3 = ((_DWORD)v7 - 1) & a2;
    }

    size_t v9 = *(void ***)(*(void *)a1 + 8 * v3);
    if (v9)
    {
      __int128 v10 = *v9;
      if (*v9)
      {
        do
        {
          unint64_t v11 = v10[1];
          if (v11 == a2)
          {
            if (*((_DWORD *)v10 + 4) == a2) {
              return v10;
            }
          }

          else
          {
            if (v8.u32[0] > 1uLL)
            {
              if (v11 >= v7) {
                v11 %= v7;
              }
            }

            else
            {
              v11 &= v7 - 1;
            }

            if (v11 != v3) {
              break;
            }
          }

          __int128 v10 = (void *)*v10;
        }

        while (v10);
      }
    }
  }

  __int128 v10 = operator new(0x30uLL);
  void *v10 = 0LL;
  v10[1] = v6;
  *((_DWORD *)v10 + 4) = *a3;
  v10[4] = 0LL;
  void v10[5] = 0LL;
  v10[3] = 0LL;
  float v12 = (float)(unint64_t)(*(void *)(a1 + 24) + 1LL);
  float v13 = *(float *)(a1 + 32);
  if (!v7 || (float)(v13 * (float)v7) < v12)
  {
    BOOL v14 = 1LL;
    if (v7 >= 3) {
      BOOL v14 = (v7 & (v7 - 1)) != 0;
    }
    unint64_t v15 = v14 | (2 * v7);
    unint64_t v16 = vcvtps_u32_f32(v12 / v13);
    if (v15 <= v16) {
      size_t v17 = v16;
    }
    else {
      size_t v17 = v15;
    }
    std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__rehash<true>( a1,  v17);
    unint64_t v7 = *(void *)(a1 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v7 <= v6) {
        unint64_t v3 = v6 % v7;
      }
      else {
        unint64_t v3 = v6;
      }
    }

    else
    {
      unint64_t v3 = ((_DWORD)v7 - 1) & v6;
    }
  }

  uint64_t v18 = *(void *)a1;
  __int128 v19 = *(void **)(*(void *)a1 + 8 * v3);
  if (v19)
  {
    void *v10 = *v19;
LABEL_38:
    void *v19 = v10;
    goto LABEL_39;
  }

  void *v10 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = v10;
  *(void *)(v18 + 8 * v3) = a1 + 16;
  if (*v10)
  {
    unint64_t v20 = *(void *)(*v10 + 8LL);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v20 >= v7) {
        v20 %= v7;
      }
    }

    else
    {
      v20 &= v7 - 1;
    }

    __int128 v19 = (void *)(*(void *)a1 + 8 * v20);
    goto LABEL_38;
  }

void sub_D26A4(_Unwind_Exception *a1)
{
}

void *std::vector<std::vector<DYGPUTimelinePipelineStateInfo>>::vector(void *a1, uint64_t a2)
{
  *a1 = 0LL;
  a1[1] = 0LL;
  a1[2] = 0LL;
  if (a2)
  {
    uint64_t v3 = 3 * a2;
    uint64_t v4 = 24 * a2;
    uint64_t v5 = (char *)operator new(24 * a2);
    *a1 = v5;
    a1[2] = &v5[8 * v3];
    size_t v6 = 24 * ((v4 - 24) / 0x18uLL) + 24;
    bzero(v5, v6);
    a1[1] = &v5[v6];
  }

  return a1;
}

void *std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long long>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long &&>,std::tuple<>>( uint64_t a1, unint64_t a2, void *a3)
{
  unint64_t v7 = *(void *)(a1 + 8);
  if (v7)
  {
    uint8x8_t v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      unint64_t v3 = a2;
      if (v7 <= a2) {
        unint64_t v3 = a2 % v7;
      }
    }

    else
    {
      unint64_t v3 = (v7 - 1) & a2;
    }

    size_t v9 = *(void ***)(*(void *)a1 + 8 * v3);
    if (v9)
    {
      for (int i = *v9; i; int i = (void *)*i)
      {
        unint64_t v11 = i[1];
        if (v11 == a2)
        {
          if (i[2] == a2) {
            return i;
          }
        }

        else
        {
          if (v8.u32[0] > 1uLL)
          {
            if (v11 >= v7) {
              v11 %= v7;
            }
          }

          else
          {
            v11 &= v7 - 1;
          }

          if (v11 != v3) {
            break;
          }
        }
      }
    }
  }

  int i = operator new(0x20uLL);
  void *i = 0LL;
  i[1] = a2;
  i[2] = *a3;
  i[3] = 0LL;
  float v12 = (float)(unint64_t)(*(void *)(a1 + 24) + 1LL);
  float v13 = *(float *)(a1 + 32);
  if (!v7 || (float)(v13 * (float)v7) < v12)
  {
    BOOL v14 = 1LL;
    if (v7 >= 3) {
      BOOL v14 = (v7 & (v7 - 1)) != 0;
    }
    unint64_t v15 = v14 | (2 * v7);
    unint64_t v16 = vcvtps_u32_f32(v12 / v13);
    if (v15 <= v16) {
      size_t v17 = v16;
    }
    else {
      size_t v17 = v15;
    }
    std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__rehash<true>( a1,  v17);
    unint64_t v7 = *(void *)(a1 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v7 <= a2) {
        unint64_t v3 = a2 % v7;
      }
      else {
        unint64_t v3 = a2;
      }
    }

    else
    {
      unint64_t v3 = (v7 - 1) & a2;
    }
  }

  uint64_t v18 = *(void *)a1;
  __int128 v19 = *(void **)(*(void *)a1 + 8 * v3);
  if (v19)
  {
    void *i = *v19;
LABEL_38:
    void *v19 = i;
    goto LABEL_39;
  }

  void *i = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = i;
  *(void *)(v18 + 8 * v3) = a1 + 16;
  if (*i)
  {
    unint64_t v20 = *(void *)(*i + 8LL);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v20 >= v7) {
        v20 %= v7;
      }
    }

    else
    {
      v20 &= v7 - 1;
    }

    __int128 v19 = (void *)(*(void *)a1 + 8 * v20);
    goto LABEL_38;
  }

void sub_D2A5C(_Unwind_Exception *a1)
{
}

uint64_t *std::__hash_table<std::__hash_value_type<unsigned int,unsigned long long>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,unsigned long long>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,unsigned long long>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,unsigned long long>>>::find<unsigned int>( uint64_t a1, unint64_t a2, unsigned int a3)
{
  if (!a2) {
    return 0LL;
  }
  uint8x8_t v3 = (uint8x8_t)vcnt_s8((int8x8_t)a2);
  v3.i16[0] = vaddlv_u8(v3);
  if (v3.u32[0] > 1uLL)
  {
    unint64_t v4 = a3;
    if (a3 >= a2) {
      unint64_t v4 = a3 % a2;
    }
  }

  else
  {
    unint64_t v4 = ((_DWORD)a2 - 1) & a3;
  }

  uint64_t v5 = *(uint64_t ***)(a1 + 8 * v4);
  if (!v5) {
    return 0LL;
  }
  for (id result = *v5; result; id result = (uint64_t *)*result)
  {
    unint64_t v7 = result[1];
    if (v7 == a3)
    {
      if (*((_DWORD *)result + 4) == a3) {
        return result;
      }
    }

    else
    {
      if (v3.u32[0] > 1uLL)
      {
        if (v7 >= a2) {
          v7 %= a2;
        }
      }

      else
      {
        v7 &= a2 - 1;
      }

      if (v7 != v4) {
        return 0LL;
      }
    }
  }

  return result;
}

uint64_t std::__introsort<std::_ClassicAlgPolicy,std::__less<void,void> &,std::tuple<unsigned int,unsigned int,unsigned int,unsigned int> *,false>( uint64_t result, char *a2, uint64_t a3, char a4)
{
  unint64_t v7 = (int *)result;
LABEL_2:
  uint8x8_t v8 = (int *)(a2 - 16);
  size_t v9 = (int *)(a2 - 32);
  __int128 v10 = (int *)(a2 - 48);
  int i = v7;
  uint64_t v152 = a2;
  while (2)
  {
    unint64_t v7 = i;
    uint64_t v12 = a2 - (char *)i;
    uint64_t v13 = (a2 - (char *)i) >> 4;
    switch(v13)
    {
      case 0LL:
      case 1LL:
        return result;
      case 2LL:
        id result = std::__tuple_less<4ul>::operator()[abi:nn180100]<std::tuple<unsigned int,unsigned int,unsigned int,unsigned int>,std::tuple<unsigned int,unsigned int,unsigned int,unsigned int>>( v8,  v7);
        if ((_DWORD)result)
        {
          int v74 = *v7;
          *unint64_t v7 = *((_DWORD *)a2 - 4);
          *((_DWORD *)a2 - 4) = v74;
          int v75 = v7[1];
          v7[1] = *((_DWORD *)a2 - 3);
          *((_DWORD *)a2 - 3) = v75;
          int v76 = v7[2];
          v7[2] = *((_DWORD *)a2 - 2);
          *((_DWORD *)a2 - 2) = v76;
          int v77 = v7[3];
          v7[3] = *((_DWORD *)a2 - 1);
          *((_DWORD *)a2 - 1) = v77;
        }

        return result;
      case 3LL:
        return std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::tuple<unsigned int,unsigned int,unsigned int,unsigned int> *>( v7,  v7 + 4,  v8);
      case 4LL:
        return std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::tuple<unsigned int,unsigned int,unsigned int,unsigned int> *>( v7,  v7 + 4,  v7 + 8,  v8);
      case 5LL:
        return std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::tuple<unsigned int,unsigned int,unsigned int,unsigned int> *>( v7,  v7 + 4,  v7 + 8,  v7 + 12,  v8);
      default:
        if (v12 > 383)
        {
          if (!a3)
          {
            if (v7 != (int *)a2)
            {
              int64_t v95 = (unint64_t)(v13 - 2) >> 1;
              int64_t v150 = v95;
              do
              {
                int64_t v96 = v95;
                if (v150 >= v95)
                {
                  uint64_t v97 = (2 * v95) | 1;
                  unsigned __int32 v98 = (unsigned int *)&v7[4 * v97];
                  if (2 * v95 + 2 < v13
                    && std::__tuple_less<4ul>::operator()[abi:nn180100]<std::tuple<unsigned int,unsigned int,unsigned int,unsigned int>,std::tuple<unsigned int,unsigned int,unsigned int,unsigned int>>( &v7[4 * v97],  v98 + 4))
                  {
                    v98 += 4;
                    uint64_t v97 = 2 * v96 + 2;
                  }

                  unint64_t v99 = (unsigned int *)&v7[4 * v96];
                  id result = std::__tuple_less<4ul>::operator()[abi:nn180100]<std::tuple<unsigned int,unsigned int,unsigned int,unsigned int>,std::tuple<unsigned int,unsigned int,unsigned int,unsigned int>>( v98,  v99);
                  a2 = v152;
                  if ((result & 1) == 0)
                  {
                    uint64_t v101 = *v99;
                    unsigned int v100 = v99[1];
                    unsigned int v102 = v99[2];
                    unsigned int v145 = v99[3];
                    unsigned int *v99 = *v98;
                    v99[1] = v98[1];
                    v99[2] = v98[2];
                    v99[3] = v98[3];
                    if (v150 >= v97)
                    {
                      int64_t v148 = v96;
                      unsigned int v146 = v100;
                      while (1)
                      {
                        unint64_t v103 = v98;
                        uint64_t v104 = 2 * v97;
                        uint64_t v97 = (2 * v97) | 1;
                        unsigned __int32 v98 = (unsigned int *)&v7[4 * v97];
                        uint64_t v105 = v104 + 2;
                        if (v104 + 2 < v13)
                        {
                          uint64_t v106 = v101;
                          id result = std::__tuple_less<4ul>::operator()[abi:nn180100]<std::tuple<unsigned int,unsigned int,unsigned int,unsigned int>,std::tuple<unsigned int,unsigned int,unsigned int,unsigned int>>( &v7[4 * v97],  v98 + 4);
                          uint64_t v101 = v106;
                          int64_t v96 = v148;
                          unsigned int v100 = v146;
                          if ((_DWORD)result)
                          {
                            v98 += 4;
                            uint64_t v97 = v105;
                          }
                        }

                        unsigned int v107 = *v98;
                        if (v101 >= v107)
                        {
                          unsigned int v108 = v98[1];
                          if (v108 < v100) {
                            break;
                          }
                          if (v100 >= v108)
                          {
                            unsigned int v109 = v98[2];
                            if (v109 < v102 || v102 >= v109 && v98[3] < v145) {
                              break;
                            }
                          }
                        }

                        *unint64_t v103 = v107;
                        v103[1] = v98[1];
                        void v103[2] = v98[2];
                        v103[3] = v98[3];
                        if (v150 < v97) {
                          goto LABEL_178;
                        }
                      }

                      unsigned __int32 v98 = v103;
                    }

LABEL_178:
                    *unsigned __int32 v98 = v101;
                    v98[1] = v100;
                    v98[2] = v102;
                    v98[3] = v145;
                    a2 = v152;
                  }
                }

                int64_t v95 = v96 - 1;
              }

              while (v96);
              uint64_t v110 = (unint64_t)v12 >> 4;
              do
              {
                uint64_t v111 = a2;
                uint64_t v112 = 0LL;
                int v151 = *v7;
                int v113 = v7[3];
                int v147 = v7[2];
                int v149 = v7[1];
                uint64_t v114 = v110 - 2;
                if (v110 < 2) {
                  uint64_t v114 = v110 - 1;
                }
                uint64_t v115 = v114 >> 1;
                uint64_t v116 = v7;
                do
                {
                  uint64_t v117 = &v116[4 * v112 + 4];
                  uint64_t v118 = (2 * v112) | 1;
                  uint64_t v119 = 2 * v112 + 2;
                  if (v119 < v110)
                  {
                    id result = std::__tuple_less<4ul>::operator()[abi:nn180100]<std::tuple<unsigned int,unsigned int,unsigned int,unsigned int>,std::tuple<unsigned int,unsigned int,unsigned int,unsigned int>>( &v116[4 * v112 + 4],  &v116[4 * v112 + 8]);
                    if ((_DWORD)result)
                    {
                      v117 += 4;
                      uint64_t v118 = v119;
                    }
                  }

                  *uint64_t v116 = *v117;
                  v116[1] = v117[1];
                  v116[2] = v117[2];
                  v116[3] = v117[3];
                  uint64_t v116 = v117;
                  uint64_t v112 = v118;
                }

                while (v118 <= v115);
                if (v117 == (int *)(v111 - 16))
                {
                  *uint64_t v117 = v151;
                  v117[1] = v149;
                  void v117[2] = v147;
                  v117[3] = v113;
                  goto LABEL_205;
                }

                *uint64_t v117 = *((_DWORD *)v111 - 4);
                v117[1] = *((_DWORD *)v111 - 3);
                void v117[2] = *((_DWORD *)v111 - 2);
                v117[3] = *((_DWORD *)v111 - 1);
                *((_DWORD *)v111 - 4) = v151;
                *((_DWORD *)v111 - 3) = v149;
                *((_DWORD *)v111 - 2) = v147;
                *((_DWORD *)v111 - 1) = v113;
                uint64_t v120 = (char *)v117 - (char *)v7 + 16;
                if (v120 >= 17)
                {
                  unint64_t v121 = (v120 >> 4) - 2;
                  unint64_t v122 = v121 >> 1;
                  unint64_t v123 = &v7[4 * (v121 >> 1)];
                  id result = std::__tuple_less<4ul>::operator()[abi:nn180100]<std::tuple<unsigned int,unsigned int,unsigned int,unsigned int>,std::tuple<unsigned int,unsigned int,unsigned int,unsigned int>>( v123,  v117);
                  if ((_DWORD)result)
                  {
                    unsigned int v124 = *v117;
                    unsigned int v125 = v117[1];
                    unsigned int v126 = v117[2];
                    unsigned int v127 = v117[3];
                    *uint64_t v117 = *v123;
                    v117[1] = v123[1];
                    void v117[2] = v123[2];
                    v117[3] = v123[3];
                    if (v121 < 2) {
                      goto LABEL_204;
                    }
                    while (1)
                    {
                      uint64_t v128 = v123;
                      unint64_t v129 = v122 - 1;
                      unint64_t v122 = (v122 - 1) >> 1;
                      unint64_t v123 = &v7[4 * v122];
                      unsigned int v130 = *v123;
                      if (*v123 >= v124)
                      {
                        if (v124 < v130
                          || (unsigned int v131 = v123[1], v131 >= v125)
                          && (v125 < v131 || (unsigned int v132 = v123[2], v132 >= v126) && (v126 < v132 || v123[3] >= v127)))
                        {
                          unint64_t v123 = v128;
LABEL_204:
                          *unint64_t v123 = v124;
                          v123[1] = v125;
                          void v123[2] = v126;
                          v123[3] = v127;
                          break;
                        }
                      }

                      else
                      {
                        unsigned int v131 = v123[1];
                      }

                      *uint64_t v128 = v130;
                      v128[1] = v131;
                      v128[2] = v123[2];
                      v128[3] = v123[3];
                      if (v129 <= 1) {
                        goto LABEL_204;
                      }
                    }
                  }
                }

                    uint32x2_t *v100 = v103;
                    v100[1] = v102;
                    v100[2] = v104;
                    v100[3] = v147;
                    a2 = v154;
                  }
                }

                uint64_t v97 = v98 - 1;
              }

              while (v98);
              uint64_t v112 = (unint64_t)v12 >> 5;
              do
              {
                int v113 = a2;
                uint64_t v114 = 0LL;
                int v151 = v7[1];
                uint64_t v153 = *v7;
                uint64_t v115 = v7[3];
                int v149 = v7[2];
                uint64_t v116 = v112 - 2;
                if (v112 < 2) {
                  uint64_t v116 = v112 - 1;
                }
                uint64_t v117 = v116 >> 1;
                uint64_t v118 = v7;
                do
                {
                  uint64_t v119 = &v118[4 * v114 + 4];
                  uint64_t v120 = (2 * v114) | 1;
                  unint64_t v121 = 2 * v114 + 2;
                  if (v121 < v112)
                  {
                    id result = std::__tuple_less<4ul>::operator()[abi:nn180100]<std::tuple<unsigned long long,unsigned long long,unsigned long long,unsigned long long>,std::tuple<unsigned long long,unsigned long long,unsigned long long,unsigned long long>>( &v118[4 * v114 + 4],  &v118[4 * v114 + 8]);
                    if ((_DWORD)result)
                    {
                      v119 += 4;
                      uint64_t v120 = v121;
                    }
                  }

                  *uint64_t v118 = *v119;
                  v118[1] = v119[1];
                  v118[2] = v119[2];
                  v118[3] = v119[3];
                  uint64_t v118 = v119;
                  uint64_t v114 = v120;
                }

                while (v120 <= v117);
                if (v119 == (uint64_t *)(v113 - 32))
                {
                  *uint64_t v119 = v153;
                  v119[1] = v151;
                  void v119[2] = v149;
                  v119[3] = v115;
                  goto LABEL_205;
                }

                *uint64_t v119 = *((void *)v113 - 4);
                v119[1] = *((void *)v113 - 3);
                void v119[2] = *((void *)v113 - 2);
                v119[3] = *((void *)v113 - 1);
                *((void *)v113 - 4) = v153;
                *((void *)v113 - 3) = v151;
                *((void *)v113 - 2) = v149;
                *((void *)v113 - 1) = v115;
                unint64_t v122 = (char *)v119 - (char *)v7 + 32;
                if (v122 >= 33)
                {
                  unint64_t v123 = (v122 >> 5) - 2;
                  unsigned int v124 = v123 >> 1;
                  unsigned int v125 = &v7[4 * (v123 >> 1)];
                  id result = std::__tuple_less<4ul>::operator()[abi:nn180100]<std::tuple<unsigned long long,unsigned long long,unsigned long long,unsigned long long>,std::tuple<unsigned long long,unsigned long long,unsigned long long,unsigned long long>>( v125,  v119);
                  if ((_DWORD)result)
                  {
                    unsigned int v126 = *v119;
                    unsigned int v127 = v119[1];
                    uint64_t v128 = v119[2];
                    unint64_t v129 = v119[3];
                    *uint64_t v119 = *v125;
                    v119[1] = v125[1];
                    void v119[2] = v125[2];
                    v119[3] = v125[3];
                    if (v123 < 2) {
                      goto LABEL_204;
                    }
                    while (1)
                    {
                      unsigned int v130 = v125;
                      unsigned int v131 = v124 - 1;
                      unsigned int v124 = (v124 - 1) >> 1;
                      unsigned int v125 = &v7[4 * v124];
                      unsigned int v132 = *v125;
                      if (*v125 >= v126)
                      {
                        if (v126 < v132
                          || (unint64_t v133 = v125[1], v133 >= v127)
                          && (v127 < v133 || (unint64_t v134 = v125[2], v134 >= v128) && (v128 < v134 || v125[3] >= v129)))
                        {
                          unsigned int v125 = v130;
LABEL_204:
                          *unsigned int v125 = v126;
                          v125[1] = v127;
                          void v125[2] = v128;
                          v125[3] = v129;
                          break;
                        }
                      }

                      else
                      {
                        unint64_t v133 = v125[1];
                      }

                      void *v130 = v132;
                      v130[1] = v133;
                      v130[2] = v125[2];
                      v130[3] = v125[3];
                      if (v131 <= 1) {
                        goto LABEL_204;
                      }
                    }
                  }
                }

    uint64_t v179 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  *(void *)(v171 + 8)));
    -[NSMutableDictionary setObject:forKeyedSubscript:](v233, "setObject:forKeyedSubscript:", v176, v179);

    goto LABEL_179;
  }

  if (v15) {
    unint64_t v99 = 43;
  }
  else {
    unint64_t v99 = 32 * (v14 != 0);
  }
LABEL_407:
  unsigned int v40 = flush_func;
LABEL_408:
  LOBYTE(v16) = 0;
  LOBYTE(v35) = v99 != 0;
  if (v99 && v7 != "(null)")
  {
    LOBYTE(v16) = 0;
    *--unint64_t v7 = v99;
    ++v195;
    LOBYTE(v35) = 1;
  }

  uint64_t v5 = v186;
LABEL_412:
  uint64_t v177 = (unint64_t)v195;
  uint64_t v178 = v35 ^ 1;
  if (v18 != 48) {
    uint64_t v178 = 1;
  }
  if ((v178 & 1) != 0)
  {
    do
    {
LABEL_424:
      if (curpos)
      {
        if (curpos >= v101)
        {
          v5->curpos = curpos;
          curpos = v5->curpos;
          uint64_t v101 = v5->endpos;
          LODWORD(v19) = v192;
        }

        *curpos++ = v18;
        uint64_t v177 = (unint64_t)v195;
      }

      ++v8;
      --v6;
    }

    while (v6 > v177);
LABEL_430:
    if (v177) {
      uint64_t v179 = v16;
    }
    else {
      uint64_t v179 = 1;
    }
    if ((v179 & 1) == 0)
    {
      v8 += v177;
      do
      {
        if (curpos)
        {
          if (curpos >= v101)
          {
            v5->curpos = curpos;
            curpos = v5->curpos;
            uint64_t v101 = v5->endpos;
            LODWORD(v19) = v192;
          }

          *curpos++ = *v7;
        }

        ++v7;
        --v177;
      }

      while (v177);
      uint64_t v177 = (unint64_t)v195;
    }

    if (v191 && !(_DWORD)v19)
    {
      while (v6 > v177)
      {
        if (curpos)
        {
          if (curpos >= v101)
          {
            v5->curpos = curpos;
            curpos = v5->curpos;
            uint64_t v101 = v5->endpos;
          }

          *curpos++ = v18;
          uint64_t v177 = (unint64_t)v195;
        }

        ++v8;
        --v6;
      }
    }

    endpos = v101;
    goto LABEL_452;
  }

  if (!curpos) {
    goto LABEL_423;
  }
  if (curpos < v101) {
    goto LABEL_422;
  }
  v5->curpos = curpos;
  if (!((unsigned int (*)(apr_vformatter_buff_t *))v40)(v5))
  {
    curpos = v5->curpos;
    uint64_t v101 = v5->endpos;
    LODWORD(v19) = v192;
LABEL_422:
    *curpos++ = *v7;
    uint64_t v177 = (unint64_t)v195;
LABEL_423:
    ++v8;
    ++v7;
    unint64_t v195 = (_BYTE *)--v177;
    --v6;
    goto LABEL_424;
  }

  return -1;
}

LABEL_150:
            v82 -= 4;
            id v94 = (char *)v7 + v90;
            *(_DWORD *)id v94 = v91;
            *((_DWORD *)v94 + 1) = v92;
            *((void *)v94 + 1) = *(void *)((char *)v7 + v90 - 8);
            v90 -= 16LL;
            if (!v90)
            {
              uint64_t v89 = v7;
              goto LABEL_153;
            }
          }

          if (v93 >= v86)
          {
            uint64_t v89 = (int *)((char *)v7 + v90);
            goto LABEL_150;
          }

            v84 -= 4;
            int64_t v96 = (char *)v7 + v92;
            *(void *)int64_t v96 = v93;
            *((void *)v96 + 1) = v94;
            *((_OWORD *)v96 + 1) = *(_OWORD *)((char *)v7 + v92 - 16);
            v92 -= 32LL;
            if (!v92)
            {
              unsigned int v91 = v7;
              goto LABEL_153;
            }
          }

          if (v95 >= v88)
          {
            unsigned int v91 = (uint64_t *)((char *)v7 + v92);
            goto LABEL_150;
          }

          if ((v138 & 1) == 0) {
            goto LABEL_199;
          }
          goto LABEL_99;
        }

        *(void *)&int v270 = v91[15];
        *((void *)&v270 + 1) = v91;
        unsigned int v93 = v91[13];
        unsigned int v92 = v91[14];
        *(void *)&v271 = v93;
        *((void *)&v271 + 1) = v92;
        uint64_t v261 = (apr_pool_t *)&v270;
        v262 = 1LL;
        int v88 = GetProgramUpdateObjectMapForPipelineObjects((uint64_t *)&v261, (id *)a1, &v254, &v253);
      }
    }

    id v94 = v88;
    goto LABEL_85;
  }

  if (!v47[5])
  {
    unsigned int v65 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  v47[5]));
    unsigned int v66 = (void *)objc_claimAutoreleasedReturnValue(-[NSMutableDictionary objectForKeyedSubscript:](v226, "objectForKeyedSubscript:", v65));
    unsigned int v67 = v66 == 0LL;

    if (!v67)
    {
      int v62 = 0LL;
      goto LABEL_64;
    }

    goto LABEL_99;
  }

  unsigned int v52 = objc_alloc_init(&OBJC_CLASS___NSMutableDictionary);
  unsigned int v53 = 0LL;
  unsigned int v54 = v51[9];
  *(void *)&int v270 = v51[8];
  DWORD2(v270) = v54;
  *(void *)&v271 = *v51;
  DWORD2(v271) = v51[1];
  unsigned __int8 v55 = v51[7];
  *(void *)&__int128 v272 = v51[6];
  DWORD2(v272) = v55;
  *(void *)&__int128 v273 = v51[4];
  DWORD2(v273) = v51[5];
  __int128 v274 = v51[2];
  LODWORD(v275) = v51[3];
  do
  {
    unsigned int v56 = (uint64_t *)*((void *)&v270 + 2 * v53);
    if (v56)
    {
      unsigned int v57 = *((unsigned int *)&v270 + 4 * v53 + 2);
      if ((int)v57 >= 1)
      {
        do
        {
          unsigned int v58 = *v56++;
          unsigned int v59 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  v58));
          unsigned int v60 = (void *)objc_claimAutoreleasedReturnValue([a1[9] objectForKeyedSubscript:v59]);
          if (v60) {
            -[NSMutableDictionary setObject:forKeyedSubscript:](v52, "setObject:forKeyedSubscript:", v60, v59);
          }

          --v57;
        }

        while (v57);
      }
    }

    ++v53;
  }

  while (v53 != 5);
  int v61 = -[NSMutableDictionary copy](v52, "copy");

  int v62 = v61;
LABEL_64:
  unsigned int v68 = (void *)objc_claimAutoreleasedReturnValue([v238 functionMap]);
  unsigned int v69 = [v68 mutableCopy];

  uint64_t v258 = 0u;
  v259 = 0u;
  v256 = 0u;
  uint64_t v257 = 0u;
  unsigned int v70 = v62;
  unsigned int v71 = [v70 countByEnumeratingWithState:&v256 objects:v265 count:16];
  if (v71)
  {
    unsigned int v72 = *(void *)v257;
    do
    {
      for (uint64_t k = 0LL; k != v71; uint64_t k = (char *)k + 1)
      {
        if (*(void *)v257 != v72) {
          objc_enumerationMutation(v70);
        }
        int v74 = *(void *)(*((void *)&v256 + 1) + 8LL * (void)k);
        int v75 = (void *)objc_claimAutoreleasedReturnValue([v70 objectForKeyedSubscript:v74]);
        [v69 setObject:v75 forKeyedSubscript:v74];
      }

      unsigned int v71 = [v70 countByEnumeratingWithState:&v256 objects:v265 count:16];
    }

    while (v71);
  }

  MTLRenderPipelineFunctionsDescriptor = MakeMTLRenderPipelineFunctionsDescriptor(v47[10], v69);
  int v77 = (id)objc_claimAutoreleasedReturnValue(MTLRenderPipelineFunctionsDescriptor);
  __int128 v78 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLongLong:](&OBJC_CLASS___NSNumber, "numberWithUnsignedLongLong:", v47[5]));
  unint64_t v79 = (void *)objc_claimAutoreleasedReturnValue(-[NSMutableDictionary objectForKeyedSubscript:](v226, "objectForKeyedSubscript:", v78));
  BOOL v80 = v79;
  if (v79) {
    uint64_t v81 = v79;
  }
  else {
    uint64_t v81 = (id)objc_claimAutoreleasedReturnValue([v238 renderPipelineStateForKey:v47[5]]);
  }
  unint64_t v82 = v81;

  v255 = 0LL;
  uint64_t v83 = [v82 newRenderPipelineStateWithAdditionalBinaryFunctions:v77 error:&v255];
  id v229 = v255;
  if (v83)
  {
    unsigned int v84 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLongLong:](&OBJC_CLASS___NSNumber, "numberWithUnsignedLongLong:", v241));
    -[NSMutableDictionary setObject:forKeyedSubscript:](v226, "setObject:forKeyedSubscript:", v83, v84);

    goto LABEL_76;
  }

  if (a3)
  {
    unint64_t v197 = GTUpdateShaderMakeError(4u, @"Failed to recreate render pipeline with additional shaders", 0LL, v229);
    *a3 = (id)objc_claimAutoreleasedReturnValue(v197);
  }

LABEL_199:
  __int128 v223 = 0LL;
LABEL_153:
  apr_pool_destroy(newpool);

  if (!v223)
  {
    unint64_t v195 = 0LL;
    goto LABEL_211;
  }

  uint64_t v140 = -[NSMutableDictionary copy](v219, "copy");
  unsigned int v141 = *(void **)(a2 + 40);
  *(void *)(a2 + 40) = v140;

  unsigned int v142 = [v223 copy];
  unsigned int v143 = *(id *)a2;
  *(void *)a2 = v142;

  unsigned int v144 = [v224 copy];
  unsigned int v145 = *(void **)(a2 + 8);
  *(void *)(a2 + _Block_object_dispose(va, 8) = v144;

  id v233 = objc_alloc_init(&OBJC_CLASS___NSMutableDictionary);
  id v227 = objc_alloc_init(&OBJC_CLASS___NSMutableDictionary);
  id v236 = objc_alloc_init(&OBJC_CLASS___NSMutableDictionary);
  id v242 = *(id *)a2;
  __int128 v230 = *(id *)(a2 + 8);
  apr_pool_create_ex(p, 0LL, 0LL, v146);
  int v147 = apr_array_make(p[0], 128, 8);
  v147->int nelts = 0;
  GTMTLSMContext_getObjects((_DWORD *)(*a1)[32], (unint64_t)a1[4], v147);
  unint64_t v239 = v147;
  if (v147->nelts >= 1)
  {
    int64_t v148 = 0LL;
    while (1)
    {
      int v149 = *(void *)&v147->elts[8 * v148];
      int64_t v150 = v149 ? *(void *)(v149 + 8) : 0LL;
      int v151 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  *(void *)(v149 + 56)));
      uint64_t v152 = (void *)objc_claimAutoreleasedReturnValue([v242 objectForKey:v151]);

      if (v152) {
        break;
      }
      uint64_t v158 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  *(void *)(v149 + 48)));
      uint64_t v157 = (id)objc_claimAutoreleasedReturnValue([v230 objectForKey:v158]);

      if (v157)
      {
        uint64_t v159 = a1[9];
        uint64_t v160 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  *(void *)(v149 + 40)));
        uint64_t v161 = (void *)objc_claimAutoreleasedReturnValue([v159 objectForKeyedSubscript:v160]);
        uint64_t v162 = v161;
        if (v161)
        {
          uint64_t v163 = v161;
        }

        else
        {
          __int128 v167 = (void *)objc_claimAutoreleasedReturnValue([a1[1] functionMap]);
          uint64_t v168 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  *(void *)(v149 + 40)));
          uint64_t v163 = (id)objc_claimAutoreleasedReturnValue([v167 objectForKeyedSubscript:v168]);
        }

        uint64_t v166 = (void *)objc_claimAutoreleasedReturnValue([v157 functionHandleWithFunction:v163]);
        __int128 v169 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  v150));
        -[NSMutableDictionary setObject:forKeyedSubscript:](v236, "setObject:forKeyedSubscript:", v166, v169);

        goto LABEL_169;
      }

LABEL_152:
          uint64_t v89 = v82;
LABEL_153:
          int *v89 = v84;
          v89[1] = v85;
          void v89[2] = v86;
          void v89[3] = v87;
LABEL_154:
          __int128 v78 = v83 + 16;
          v81 += 16LL;
          unint64_t v82 = (int *)v83;
        }

        while (v83 + 16 != a2);
        return result;
    }
  }

          unsigned int v91 = v84;
LABEL_153:
          *unsigned int v91 = v86;
          v91[1] = v87;
          v91[2] = v88;
          v91[3] = v89;
LABEL_154:
          BOOL v80 = v85 + 32;
          v83 += 32LL;
          unsigned int v84 = (uint64_t *)v85;
        }

        while (v85 + 32 != a2);
        return result;
    }
  }

void std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__emplace_unique_key_args<unsigned long long,unsigned long long &>( uint64_t a1, unint64_t a2, uint64_t a3)
{
  unint64_t v7 = *(void *)(a1 + 8);
  if (v7)
  {
    uint8x8_t v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      unint64_t v3 = a2;
      if (v7 <= a2) {
        unint64_t v3 = a2 % v7;
      }
    }

    else
    {
      unint64_t v3 = (v7 - 1) & a2;
    }

    size_t v9 = *(void **)(*(void *)a1 + 8 * v3);
    if (v9)
    {
      for (int i = (void *)*v9; i; int i = (void *)*i)
      {
        unint64_t v11 = i[1];
        if (v11 == a2)
        {
          if (i[2] == a2) {
            return;
          }
        }

        else
        {
          if (v8.u32[0] > 1uLL)
          {
            if (v11 >= v7) {
              v11 %= v7;
            }
          }

          else
          {
            v11 &= v7 - 1;
          }

          if (v11 != v3) {
            break;
          }
        }
      }
    }
  }

  uint64_t v12 = operator new(0x18uLL);
  void *v12 = 0LL;
  v12[1] = a2;
  v12[2] = a3;
  float v13 = (float)(unint64_t)(*(void *)(a1 + 24) + 1LL);
  float v14 = *(float *)(a1 + 32);
  if (!v7 || (float)(v14 * (float)v7) < v13)
  {
    BOOL v15 = 1LL;
    if (v7 >= 3) {
      BOOL v15 = (v7 & (v7 - 1)) != 0;
    }
    unint64_t v16 = v15 | (2 * v7);
    unint64_t v17 = vcvtps_u32_f32(v13 / v14);
    if (v16 <= v17) {
      size_t v18 = v17;
    }
    else {
      size_t v18 = v16;
    }
    std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__rehash<true>( a1,  v18);
    unint64_t v7 = *(void *)(a1 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v7 <= a2) {
        unint64_t v3 = a2 % v7;
      }
      else {
        unint64_t v3 = a2;
      }
    }

    else
    {
      unint64_t v3 = (v7 - 1) & a2;
    }
  }

  uint64_t v19 = *(void *)a1;
  unsigned int v20 = *(void **)(*(void *)a1 + 8 * v3);
  if (v20)
  {
    void *v12 = *v20;
LABEL_38:
    *unsigned int v20 = v12;
    goto LABEL_39;
  }

  void *v12 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = v12;
  *(void *)(v19 + 8 * v3) = a1 + 16;
  if (*v12)
  {
    unint64_t v21 = *(void *)(*v12 + 8LL);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v21 >= v7) {
        v21 %= v7;
      }
    }

    else
    {
      v21 &= v7 - 1;
    }

    unsigned int v20 = (void *)(*(void *)a1 + 8 * v21);
    goto LABEL_38;
  }

void sub_D3990(_Unwind_Exception *a1)
{
}

BOOL std::__tuple_less<4ul>::operator()[abi:nn180100]<std::tuple<unsigned int,unsigned int,unsigned int,unsigned int>,std::tuple<unsigned int,unsigned int,unsigned int,unsigned int>>( _DWORD *a1, _DWORD *a2)
{
  if (*a1 < *a2) {
    return 1LL;
  }
  if (*a2 < *a1) {
    return 0LL;
  }
  unsigned int v2 = a1[1];
  unsigned int v3 = a2[1];
  if (v2 < v3) {
    return 1LL;
  }
  if (v3 < v2) {
    return 0LL;
  }
  unsigned int v4 = a1[2];
  unsigned int v5 = a2[2];
  if (v4 < v5) {
    return 1LL;
  }
  return v5 >= v4 && a1[3] < a2[3];
}

BOOL std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::tuple<unsigned int,unsigned int,unsigned int,unsigned int> *>( int *a1, int *a2, int *a3)
{
  BOOL v6 = std::__tuple_less<4ul>::operator()[abi:nn180100]<std::tuple<unsigned int,unsigned int,unsigned int,unsigned int>,std::tuple<unsigned int,unsigned int,unsigned int,unsigned int>>( a2,  a1);
  BOOL result = std::__tuple_less<4ul>::operator()[abi:nn180100]<std::tuple<unsigned int,unsigned int,unsigned int,unsigned int>,std::tuple<unsigned int,unsigned int,unsigned int,unsigned int>>( a3,  a2);
  if (v6)
  {
    size_t v9 = a1 + 3;
    int v8 = *a1;
    if (result)
    {
      *a1 = *a3;
      *a3 = v8;
      int v10 = a1[1];
      a1[1] = a3[1];
      a3[1] = v10;
      int v11 = a1[2];
      a1[2] = a3[2];
    }

    else
    {
      *a1 = *a2;
      *a2 = v8;
      int v20 = a1[1];
      a1[1] = a2[1];
      a2[1] = v20;
      int v21 = a1[2];
      a1[2] = a2[2];
      a2[2] = v21;
      size_t v9 = a2 + 3;
      int v22 = a1[3];
      a1[3] = a2[3];
      a2[3] = v22;
      BOOL result = std::__tuple_less<4ul>::operator()[abi:nn180100]<std::tuple<unsigned int,unsigned int,unsigned int,unsigned int>,std::tuple<unsigned int,unsigned int,unsigned int,unsigned int>>( a3,  a2);
      if (!result) {
        return result;
      }
      int v23 = *a2;
      *a2 = *a3;
      *a3 = v23;
      int v24 = a2[1];
      a2[1] = a3[1];
      a3[1] = v24;
      int v11 = a2[2];
      a2[2] = a3[2];
    }

    a3[2] = v11;
    unint64_t v16 = a3 + 3;
    goto LABEL_10;
  }

  if (result)
  {
    int v12 = *a2;
    *a2 = *a3;
    *a3 = v12;
    int v13 = a2[1];
    a2[1] = a3[1];
    a3[1] = v13;
    int v14 = a2[2];
    a2[2] = a3[2];
    a3[2] = v14;
    unint64_t v16 = a2 + 3;
    int v15 = a2[3];
    a2[3] = a3[3];
    a3[3] = v15;
    BOOL result = std::__tuple_less<4ul>::operator()[abi:nn180100]<std::tuple<unsigned int,unsigned int,unsigned int,unsigned int>,std::tuple<unsigned int,unsigned int,unsigned int,unsigned int>>( a2,  a1);
    if (result)
    {
      int v17 = *a1;
      *a1 = *a2;
      *a2 = v17;
      int v18 = a1[1];
      a1[1] = a2[1];
      a2[1] = v18;
      int v19 = a1[2];
      a1[2] = a2[2];
      a2[2] = v19;
      size_t v9 = a1 + 3;
LABEL_10:
      int v25 = *v9;
      int *v9 = *v16;
      int *v16 = v25;
    }
  }

  return result;
}

BOOL std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::tuple<unsigned int,unsigned int,unsigned int,unsigned int> *>( int *a1, int *a2, int *a3, int *a4)
{
  BOOL result = std::__tuple_less<4ul>::operator()[abi:nn180100]<std::tuple<unsigned int,unsigned int,unsigned int,unsigned int>,std::tuple<unsigned int,unsigned int,unsigned int,unsigned int>>( a4,  a3);
  if (result)
  {
    int v9 = *a3;
    *a3 = *a4;
    *a4 = v9;
    int v10 = a3[1];
    a3[1] = a4[1];
    a4[1] = v10;
    int v11 = a3[2];
    a3[2] = a4[2];
    a4[2] = v11;
    int v12 = a3[3];
    a3[3] = a4[3];
    a4[3] = v12;
    BOOL result = std::__tuple_less<4ul>::operator()[abi:nn180100]<std::tuple<unsigned int,unsigned int,unsigned int,unsigned int>,std::tuple<unsigned int,unsigned int,unsigned int,unsigned int>>( a3,  a2);
    if (result)
    {
      int v13 = *a2;
      *a2 = *a3;
      *a3 = v13;
      int v14 = a2[1];
      a2[1] = a3[1];
      a3[1] = v14;
      int v15 = a2[2];
      a2[2] = a3[2];
      a3[2] = v15;
      int v16 = a2[3];
      a2[3] = a3[3];
      a3[3] = v16;
      BOOL result = std::__tuple_less<4ul>::operator()[abi:nn180100]<std::tuple<unsigned int,unsigned int,unsigned int,unsigned int>,std::tuple<unsigned int,unsigned int,unsigned int,unsigned int>>( a2,  a1);
      if (result)
      {
        int v17 = *a1;
        *a1 = *a2;
        *a2 = v17;
        int v18 = a1[1];
        a1[1] = a2[1];
        a2[1] = v18;
        int v19 = a1[2];
        a1[2] = a2[2];
        a2[2] = v19;
        int v20 = a1[3];
        a1[3] = a2[3];
        a2[3] = v20;
      }
    }
  }

  return result;
}

BOOL std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::tuple<unsigned int,unsigned int,unsigned int,unsigned int> *>( int *a1, int *a2, int *a3, int *a4, int *a5)
{
  BOOL result = std::__tuple_less<4ul>::operator()[abi:nn180100]<std::tuple<unsigned int,unsigned int,unsigned int,unsigned int>,std::tuple<unsigned int,unsigned int,unsigned int,unsigned int>>( a5,  a4);
  if (result)
  {
    int v11 = *a4;
    *a4 = *a5;
    *a5 = v11;
    int v12 = a4[1];
    a4[1] = a5[1];
    a5[1] = v12;
    int v13 = a4[2];
    a4[2] = a5[2];
    a5[2] = v13;
    int v14 = a4[3];
    a4[3] = a5[3];
    a5[3] = v14;
    BOOL result = std::__tuple_less<4ul>::operator()[abi:nn180100]<std::tuple<unsigned int,unsigned int,unsigned int,unsigned int>,std::tuple<unsigned int,unsigned int,unsigned int,unsigned int>>( a4,  a3);
    if (result)
    {
      int v15 = *a3;
      *a3 = *a4;
      *a4 = v15;
      int v16 = a3[1];
      a3[1] = a4[1];
      a4[1] = v16;
      int v17 = a3[2];
      a3[2] = a4[2];
      a4[2] = v17;
      int v18 = a3[3];
      a3[3] = a4[3];
      a4[3] = v18;
      BOOL result = std::__tuple_less<4ul>::operator()[abi:nn180100]<std::tuple<unsigned int,unsigned int,unsigned int,unsigned int>,std::tuple<unsigned int,unsigned int,unsigned int,unsigned int>>( a3,  a2);
      if (result)
      {
        int v19 = *a2;
        *a2 = *a3;
        *a3 = v19;
        int v20 = a2[1];
        a2[1] = a3[1];
        a3[1] = v20;
        int v21 = a2[2];
        a2[2] = a3[2];
        a3[2] = v21;
        int v22 = a2[3];
        a2[3] = a3[3];
        a3[3] = v22;
        BOOL result = std::__tuple_less<4ul>::operator()[abi:nn180100]<std::tuple<unsigned int,unsigned int,unsigned int,unsigned int>,std::tuple<unsigned int,unsigned int,unsigned int,unsigned int>>( a2,  a1);
        if (result)
        {
          int v23 = *a1;
          *a1 = *a2;
          *a2 = v23;
          int v24 = a1[1];
          a1[1] = a2[1];
          a2[1] = v24;
          int v25 = a1[2];
          a1[2] = a2[2];
          a2[2] = v25;
          int v26 = a1[3];
          a1[3] = a2[3];
          a2[3] = v26;
        }
      }
    }
  }

  return result;
}

BOOL std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::tuple<unsigned int,unsigned int,unsigned int,unsigned int> *>( int *a1, char *a2)
{
  uint64_t v4 = (a2 - (char *)a1) >> 4;
  BOOL result = 1LL;
  switch(v4)
  {
    case 0LL:
    case 1LL:
      return result;
    case 2LL:
      if (std::__tuple_less<4ul>::operator()[abi:nn180100]<std::tuple<unsigned int,unsigned int,unsigned int,unsigned int>,std::tuple<unsigned int,unsigned int,unsigned int,unsigned int>>( (_DWORD *)a2 - 4,  a1))
      {
        int v6 = *a1;
        *a1 = *((_DWORD *)a2 - 4);
        *((_DWORD *)a2 - 4) = v6;
        int v7 = a1[1];
        a1[1] = *((_DWORD *)a2 - 3);
        *((_DWORD *)a2 - 3) = v7;
        int v8 = a1[2];
        a1[2] = *((_DWORD *)a2 - 2);
        *((_DWORD *)a2 - 2) = v8;
        int v9 = a1[3];
        a1[3] = *((_DWORD *)a2 - 1);
        *((_DWORD *)a2 - 1) = v9;
      }

      return 1LL;
    case 3LL:
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::tuple<unsigned int,unsigned int,unsigned int,unsigned int> *>( a1,  a1 + 4,  (int *)a2 - 4);
      return 1LL;
    case 4LL:
      std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::tuple<unsigned int,unsigned int,unsigned int,unsigned int> *>( a1,  a1 + 4,  a1 + 8,  (int *)a2 - 4);
      return 1LL;
    case 5LL:
      std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::tuple<unsigned int,unsigned int,unsigned int,unsigned int> *>( a1,  a1 + 4,  a1 + 8,  a1 + 12,  (int *)a2 - 4);
      return 1LL;
    default:
      int v10 = a1 + 8;
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::tuple<unsigned int,unsigned int,unsigned int,unsigned int> *>( a1,  a1 + 4,  a1 + 8);
      int v11 = a1 + 12;
      uint64_t v12 = 0LL;
      int v13 = 0;
      break;
  }

  while (2)
  {
    if (!std::__tuple_less<4ul>::operator()[abi:nn180100]<std::tuple<unsigned int,unsigned int,unsigned int,unsigned int>,std::tuple<unsigned int,unsigned int,unsigned int,unsigned int>>( v11,  v10)) {
      goto LABEL_21;
    }
    unsigned int v14 = *v11;
    unsigned int v15 = v11[1];
    unsigned int v16 = v11[2];
    unsigned int v17 = v11[3];
    int *v11 = *v10;
    v11[1] = v10[1];
    v11[2] = v10[2];
    v11[3] = v10[3];
    int v18 = a1;
    if (v10 == a1) {
      goto LABEL_20;
    }
    uint64_t v19 = v12;
    while (1)
    {
      int v20 = (char *)a1 + v19;
      unsigned int v21 = *(int *)((char *)a1 + v19 + 16);
      if (v14 < v21)
      {
        unsigned int v22 = *((_DWORD *)v20 + 5);
        goto LABEL_17;
      }

      if (v21 < v14) {
        goto LABEL_19;
      }
      unsigned int v22 = *(int *)((char *)a1 + v19 + 20);
      if (v15 >= v22)
      {
        if (v22 < v15) {
          goto LABEL_19;
        }
        unsigned int v23 = *(int *)((char *)a1 + v19 + 24);
        if (v16 >= v23)
        {
          if (v23 < v16)
          {
LABEL_19:
            int v18 = v10;
            goto LABEL_20;
          }
        }
      }

void *BufferView<DYGPUTimelineEncoderTimelineInfo>::BufferView(void *a1, void *a2)
{
  id v3 = a2;
  *a1 = [v3 bytes];
  unint64_t v4 = (unint64_t)[v3 length];
  a1[1] = *a1 + 24 * (v4 / 0x18);
  a1[2] = v4 / 0x18;

  return a1;
}

void sub_D419C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void *BufferView<unsigned long long>::BufferView(void *a1, void *a2)
{
  id v3 = a2;
  *a1 = [v3 bytes];
  unint64_t v4 = (unint64_t)[v3 length];
  a1[1] = *a1 + 8 * (v4 >> 3);
  a1[2] = v4 >> 3;

  return a1;
}

{
  id v3;
  unint64_t v4;
  id v3 = a2;
  *a1 = [v3 mutableBytes];
  unint64_t v4 = (unint64_t)[v3 length];
  a1[1] = *a1 + 8 * (v4 >> 3);
  a1[2] = v4 >> 3;

  return a1;
}

void sub_D41FC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void *std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long long>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long const&>,std::tuple<>>( uint64_t a1, unint64_t a2, void *a3)
{
  unint64_t v7 = *(void *)(a1 + 8);
  if (v7)
  {
    uint8x8_t v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      unint64_t v3 = a2;
      if (v7 <= a2) {
        unint64_t v3 = a2 % v7;
      }
    }

    else
    {
      unint64_t v3 = (v7 - 1) & a2;
    }

    int v9 = *(void ***)(*(void *)a1 + 8 * v3);
    if (v9)
    {
      for (int i = *v9; i; int i = (void *)*i)
      {
        unint64_t v11 = i[1];
        if (v11 == a2)
        {
          if (i[2] == a2) {
            return i;
          }
        }

        else
        {
          if (v8.u32[0] > 1uLL)
          {
            if (v11 >= v7) {
              v11 %= v7;
            }
          }

          else
          {
            v11 &= v7 - 1;
          }

          if (v11 != v3) {
            break;
          }
        }
      }
    }
  }

  int i = operator new(0x20uLL);
  void *i = 0LL;
  i[1] = a2;
  i[2] = *a3;
  i[3] = 0LL;
  float v12 = (float)(unint64_t)(*(void *)(a1 + 24) + 1LL);
  float v13 = *(float *)(a1 + 32);
  if (!v7 || (float)(v13 * (float)v7) < v12)
  {
    BOOL v14 = 1LL;
    if (v7 >= 3) {
      BOOL v14 = (v7 & (v7 - 1)) != 0;
    }
    unint64_t v15 = v14 | (2 * v7);
    unint64_t v16 = vcvtps_u32_f32(v12 / v13);
    if (v15 <= v16) {
      size_t v17 = v16;
    }
    else {
      size_t v17 = v15;
    }
    std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__rehash<true>( a1,  v17);
    unint64_t v7 = *(void *)(a1 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v7 <= a2) {
        unint64_t v3 = a2 % v7;
      }
      else {
        unint64_t v3 = a2;
      }
    }

    else
    {
      unint64_t v3 = (v7 - 1) & a2;
    }
  }

  uint64_t v18 = *(void *)a1;
  uint64_t v19 = *(void **)(*(void *)a1 + 8 * v3);
  if (v19)
  {
    void *i = *v19;
LABEL_38:
    void *v19 = i;
    goto LABEL_39;
  }

  void *i = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = i;
  *(void *)(v18 + 8 * v3) = a1 + 16;
  if (*i)
  {
    unint64_t v20 = *(void *)(*i + 8LL);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v20 >= v7) {
        v20 %= v7;
      }
    }

    else
    {
      v20 &= v7 - 1;
    }

    uint64_t v19 = (void *)(*(void *)a1 + 8 * v20);
    goto LABEL_38;
  }

void sub_D4404(_Unwind_Exception *a1)
{
}

void *BufferView<double>::BufferView(void *a1, void *a2)
{
  id v3 = a2;
  *a1 = [v3 bytes];
  unint64_t v4 = (unint64_t)[v3 length];
  a1[1] = *a1 + 8 * (v4 >> 3);
  a1[2] = v4 >> 3;

  return a1;
}

{
  id v3;
  unint64_t v4;
  id v3 = a2;
  *a1 = [v3 mutableBytes];
  unint64_t v4 = (unint64_t)[v3 length];
  a1[1] = *a1 + 8 * (v4 >> 3);
  a1[2] = v4 >> 3;

  return a1;
}

void sub_D4468(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void *std::__hash_table<std::__hash_value_type<unsigned long long,unsigned int>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned int>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned int>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned int>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long const&>,std::tuple<>>( uint64_t a1, unint64_t a2, void *a3)
{
  unint64_t v7 = *(void *)(a1 + 8);
  if (v7)
  {
    uint8x8_t v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      unint64_t v3 = a2;
      if (v7 <= a2) {
        unint64_t v3 = a2 % v7;
      }
    }

    else
    {
      unint64_t v3 = (v7 - 1) & a2;
    }

    int v9 = *(void ***)(*(void *)a1 + 8 * v3);
    if (v9)
    {
      int v10 = *v9;
      if (*v9)
      {
        do
        {
          unint64_t v11 = v10[1];
          if (v11 == a2)
          {
            if (v10[2] == a2) {
              return v10;
            }
          }

          else
          {
            if (v8.u32[0] > 1uLL)
            {
              if (v11 >= v7) {
                v11 %= v7;
              }
            }

            else
            {
              v11 &= v7 - 1;
            }

            if (v11 != v3) {
              break;
            }
          }

          int v10 = (void *)*v10;
        }

        while (v10);
      }
    }
  }

  int v10 = operator new(0x20uLL);
  void *v10 = 0LL;
  v10[1] = a2;
  v10[2] = *a3;
  *((_DWORD *)v10 + 6) = 0;
  float v12 = (float)(unint64_t)(*(void *)(a1 + 24) + 1LL);
  float v13 = *(float *)(a1 + 32);
  if (!v7 || (float)(v13 * (float)v7) < v12)
  {
    BOOL v14 = 1LL;
    if (v7 >= 3) {
      BOOL v14 = (v7 & (v7 - 1)) != 0;
    }
    unint64_t v15 = v14 | (2 * v7);
    unint64_t v16 = vcvtps_u32_f32(v12 / v13);
    if (v15 <= v16) {
      size_t v17 = v16;
    }
    else {
      size_t v17 = v15;
    }
    std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__rehash<true>( a1,  v17);
    unint64_t v7 = *(void *)(a1 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v7 <= a2) {
        unint64_t v3 = a2 % v7;
      }
      else {
        unint64_t v3 = a2;
      }
    }

    else
    {
      unint64_t v3 = (v7 - 1) & a2;
    }
  }

  uint64_t v18 = *(void *)a1;
  uint64_t v19 = *(void **)(*(void *)a1 + 8 * v3);
  if (v19)
  {
    void *v10 = *v19;
LABEL_38:
    void *v19 = v10;
    goto LABEL_39;
  }

  void *v10 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = v10;
  *(void *)(v18 + 8 * v3) = a1 + 16;
  if (*v10)
  {
    unint64_t v20 = *(void *)(*v10 + 8LL);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v20 >= v7) {
        v20 %= v7;
      }
    }

    else
    {
      v20 &= v7 - 1;
    }

    uint64_t v19 = (void *)(*(void *)a1 + 8 * v20);
    goto LABEL_38;
  }

void sub_D4674(_Unwind_Exception *a1)
{
}

void *std::__hash_table<std::__hash_value_type<unsigned long long,std::pair<unsigned int,unsigned long long>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,std::pair<unsigned int,unsigned long long>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,std::pair<unsigned int,unsigned long long>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,std::pair<unsigned int,unsigned long long>>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long &&>,std::tuple<>>( uint64_t a1, unint64_t a2, void *a3)
{
  unint64_t v7 = *(void *)(a1 + 8);
  if (v7)
  {
    uint8x8_t v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      unint64_t v3 = a2;
      if (v7 <= a2) {
        unint64_t v3 = a2 % v7;
      }
    }

    else
    {
      unint64_t v3 = (v7 - 1) & a2;
    }

    int v9 = *(void ***)(*(void *)a1 + 8 * v3);
    if (v9)
    {
      int v10 = *v9;
      if (*v9)
      {
        do
        {
          unint64_t v11 = v10[1];
          if (v11 == a2)
          {
            if (v10[2] == a2) {
              return v10;
            }
          }

          else
          {
            if (v8.u32[0] > 1uLL)
            {
              if (v11 >= v7) {
                v11 %= v7;
              }
            }

            else
            {
              v11 &= v7 - 1;
            }

            if (v11 != v3) {
              break;
            }
          }

          int v10 = (void *)*v10;
        }

        while (v10);
      }
    }
  }

  int v10 = operator new(0x28uLL);
  void *v10 = 0LL;
  v10[1] = a2;
  v10[2] = *a3;
  *((_DWORD *)v10 + 6) = 0;
  v10[4] = 0LL;
  float v12 = (float)(unint64_t)(*(void *)(a1 + 24) + 1LL);
  float v13 = *(float *)(a1 + 32);
  if (!v7 || (float)(v13 * (float)v7) < v12)
  {
    BOOL v14 = 1LL;
    if (v7 >= 3) {
      BOOL v14 = (v7 & (v7 - 1)) != 0;
    }
    unint64_t v15 = v14 | (2 * v7);
    unint64_t v16 = vcvtps_u32_f32(v12 / v13);
    if (v15 <= v16) {
      size_t v17 = v16;
    }
    else {
      size_t v17 = v15;
    }
    std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__rehash<true>( a1,  v17);
    unint64_t v7 = *(void *)(a1 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v7 <= a2) {
        unint64_t v3 = a2 % v7;
      }
      else {
        unint64_t v3 = a2;
      }
    }

    else
    {
      unint64_t v3 = (v7 - 1) & a2;
    }
  }

  uint64_t v18 = *(void *)a1;
  uint64_t v19 = *(void **)(*(void *)a1 + 8 * v3);
  if (v19)
  {
    void *v10 = *v19;
LABEL_38:
    void *v19 = v10;
    goto LABEL_39;
  }

  void *v10 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = v10;
  *(void *)(v18 + 8 * v3) = a1 + 16;
  if (*v10)
  {
    unint64_t v20 = *(void *)(*v10 + 8LL);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v20 >= v7) {
        v20 %= v7;
      }
    }

    else
    {
      v20 &= v7 - 1;
    }

    uint64_t v19 = (void *)(*(void *)a1 + 8 * v20);
    goto LABEL_38;
  }

void sub_D4888(_Unwind_Exception *a1)
{
}

void sub_D4940( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{
  _Unwind_Resume(a1);
}

void sub_D4A84( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, id a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21)
{
  _Unwind_Resume(a1);
}

void sub_D4BC4( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, id a12)
{
  _Unwind_Resume(a1);
}

void sub_D4CCC( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, id a12)
{
}

void sub_D4DD0( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

id ArrayFromDownloadRequests(uint64_t a1, int a2)
{
  int v2 = a2;
  unint64_t v4 = -[NSMutableArray initWithCapacity:](objc_alloc(&OBJC_CLASS___NSMutableArray), "initWithCapacity:", a2);
  if (v2 >= 1)
  {
    do
    {
      unsigned int v5 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithUTF8String:]( &OBJC_CLASS___NSString,  "stringWithUTF8String:",  *(void *)(a1 + 24)));
      -[NSMutableArray addObject:](v4, "addObject:", v5);

      --v2;
    }

    while (v2);
  }

  id v6 = -[NSMutableArray copy](v4, "copy");

  return v6;
}

id ArrayFromActivities(void *a1, char a2)
{
  id v3 = a1;
  unint64_t v4 = objc_alloc(&OBJC_CLASS___NSMutableArray);
  id v5 = v3;
  if (v5)
  {
    id v6 = v5;
    uint64_t v7 = 0LL;
    uint8x8_t v8 = v5;
    do
    {
      uint64_t v9 = objc_claimAutoreleasedReturnValue([v8 previousActivity]);

      ++v7;
      uint8x8_t v8 = (void *)v9;
    }

    while (v9);
    int v10 = -[NSMutableArray initWithCapacity:](v4, "initWithCapacity:", v7);
    do
    {
      if ((a2 & 1) != 0)
      {
        unint64_t v11 = (void *)objc_claimAutoreleasedReturnValue([v6 jsonObject]);
        -[NSMutableArray addObject:](v10, "addObject:", v11);
      }

      else
      {
        -[NSMutableArray addObject:](v10, "addObject:", v6);
      }

      uint64_t v12 = objc_claimAutoreleasedReturnValue([v6 previousActivity]);

      id v6 = (void *)v12;
    }

    while (v12);
  }

  else
  {
    int v10 = -[NSMutableArray initWithCapacity:](v4, "initWithCapacity:", 0LL);
  }

  float v13 = v10;
  unint64_t v14 = (unint64_t)-[NSMutableArray count](v13, "count");
  if (v14 >= 2)
  {
    uint64_t v15 = 0LL;
    unint64_t v16 = v14 >> 1;
    unint64_t v17 = v14 - 1;
    do
    {
      uint64_t v18 = v15 + 1;
      -[NSMutableArray exchangeObjectAtIndex:withObjectAtIndex:](v13, "exchangeObjectAtIndex:withObjectAtIndex:");
      --v17;
      uint64_t v15 = v18;
    }

    while (v16 != v18);
  }

  id v19 = -[NSMutableArray copy](v13, "copy");
  return v19;
}

NSMutableArray *BreadcrumbSummary(void *a1)
{
  id v1 = ArrayFromActivities(a1, 0);
  int v2 = (void *)objc_claimAutoreleasedReturnValue(v1);
  id v3 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
  __int128 v11 = 0u;
  __int128 v12 = 0u;
  __int128 v13 = 0u;
  __int128 v14 = 0u;
  id v4 = v2;
  id v5 = [v4 countByEnumeratingWithState:&v11 objects:v15 count:16];
  if (v5)
  {
    id v6 = v5;
    uint64_t v7 = *(void *)v12;
    do
    {
      uint8x8_t v8 = 0LL;
      do
      {
        if (*(void *)v12 != v7) {
          objc_enumerationMutation(v4);
        }
        uint64_t v9 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(*((void *)&v11 + 1) + 8 * (void)v8), "summary", (void)v11));
        -[NSMutableArray addObject:](v3, "addObject:", v9);

        uint8x8_t v8 = (char *)v8 + 1;
      }

      while (v6 != v8);
      id v6 = [v4 countByEnumeratingWithState:&v11 objects:v15 count:16];
    }

    while (v6);
  }

  return v3;
}

void sub_D8BD0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_D8CA0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_D8DA0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_D9630( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *__p, void *a17, void *a18, void *a19, void *a20, void *a21, void *a22, uint64_t a23, void *a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, void *a41, uint64_t a42, uint64_t a43, void *a44, uint64_t a45, uint64_t a46, void *a47, uint64_t a48, uint64_t a49, void *a50,uint64_t a51,uint64_t a52,void *a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,void *a61)
{
  if (a41) {
    operator delete(a41);
  }
  if (a44) {
    operator delete(a44);
  }
  if (a47) {
    operator delete(a47);
  }
  if (a50) {
    operator delete(a50);
  }
  if (a53) {
    operator delete(a53);
  }
  operator delete(a20);
  operator delete(a18);
  operator delete(a21);

  _Unwind_Resume(a1);
}

void sub_D9E08(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_DA304( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

void sub_DA660( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9)
{
  _Unwind_Resume(a1);
}

void GTPerfStateGroup::~GTPerfStateGroup(GTPerfStateGroup *this)
{
  int v2 = (const void *)*((void *)this + 2);
  if (v2)
  {
    CFRelease(v2);
    *((void *)this + 2) = 0LL;
  }

  id v3 = (void *)*((void *)this + 14);
  if (v3)
  {
    *((void *)this + 15) = v3;
    operator delete(v3);
  }

  id v4 = (void *)*((void *)this + 10);
  if (v4)
  {
    *((void *)this + 11) = v4;
    operator delete(v4);
  }

  id v5 = (void *)*((void *)this + 6);
  if (v5)
  {
    *((void *)this + 7) = v5;
    operator delete(v5);
  }
}

void sub_DA830(_Unwind_Exception *a1)
{
  id v3 = *(void **)(v1 + 112);
  if (v3)
  {
    *(void *)(v1 + 120) = v3;
    operator delete(v3);
  }

  id v4 = *(void **)(v1 + 80);
  if (v4)
  {
    *(void *)(v1 + 8_Block_object_dispose(va, 8) = v4;
    operator delete(v4);
  }

  id v5 = *(void **)(v1 + 48);
  if (v5)
  {
    *(void *)(v1 + 56) = v5;
    operator delete(v5);
  }

  _Unwind_Resume(a1);
}

void ___ZN16GTPerfStateGroup32_GatherSampleDataPeriodicSamplesERK18mach_timebase_info_block_invoke( uint64_t a1, void *a2, uint64_t a3)
{
  id v5 = a2;
  uint64_t v6 = *(void *)(*(void *)(a1 + 32) + 8LL);
  id v9 = v5;
  if (a3)
  {
    uint64_t SamplesDelta = IOReportCreateSamplesDelta(*(void *)(v6 + 24), v5, 0LL);
    uint8x8_t v8 = (const void *)SamplesDelta;
    if (SamplesDelta)
    {
      *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = v9;
      IOReportGetChannelCount(SamplesDelta);
      IOReportIterate(v8, &__block_literal_global_1897);
      CFRelease(v8);
    }
  }

  else
  {
    *(void *)(v6 + 24) = v5;
  }
}

void sub_DA92C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
}

int ___ZN16GTPerfStateGroup32_GatherSampleDataPeriodicSamplesERK18mach_timebase_info_block_invoke_2( id a1, __CFDictionary *a2)
{
  int Format = IOReportChannelGetFormat(a2);
  if (Format)
  {
    if (Format == 1)
    {
      uint64_t ChannelName = IOReportChannelGetChannelName(a2);
      id v5 = (void *)objc_claimAutoreleasedReturnValue(ChannelName);
      IOReportChannelGetChannelID(a2);
      uint64_t Unit = IOReportChannelGetUnit(a2);
      uint64_t UnitLabel = IOReportChannelGetUnitLabel(a2);
      uint64_t v7 = (void *)objc_claimAutoreleasedReturnValue(UnitLabel);
      IOReportSimpleGetIntegerValue(a2, &Unit);
    }

    else
    {
      IOReportChannelGetUnit(a2);
      uint64_t v8 = IOReportChannelGetUnitLabel(a2);
    }
  }

  return 16;
}

void sub_DA9EC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void ___ZN16GTPerfStateGroup29_GatherSampleDataSOCPerfStateERK18mach_timebase_info_block_invoke( uint64_t a1, void *a2, uint64_t a3)
{
  id v5 = a2;
  uint64_t v6 = v5;
  uint64_t v7 = *(void *)(*(void *)(a1 + 32) + 8LL);
  if (a3)
  {
    uint64_t v8 = *(void *)(a1 + 40);
    uint64_t SamplesDelta = IOReportCreateSamplesDelta(*(void *)(v7 + 24), v5, 0LL);
    int v10 = (const void *)SamplesDelta;
    if (SamplesDelta)
    {
      *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = v6;
      v12[0] = 0LL;
      v12[1] = v12;
      v12[2] = 0x2020000000LL;
      int v13 = 0;
      v11[0] = _NSConcreteStackBlock;
      v11[1] = 3221225472LL;
      v11[2] = ___ZN16GTPerfStateGroup29_GatherSampleDataSOCPerfStateERK18mach_timebase_info_block_invoke_2;
      v11[3] = &unk_58E860;
      void v11[5] = v8;
      v11[6] = a3;
      v11[4] = v12;
      IOReportIterate(SamplesDelta, v11);
      CFRelease(v10);
      _Block_object_dispose(v12, 8);
    }
  }

  else
  {
    *(void *)(v7 + 24) = v5;
  }
}

void sub_DAAFC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t ___ZN16GTPerfStateGroup29_GatherSampleDataSOCPerfStateERK18mach_timebase_info_block_invoke_2( void *a1, uint64_t a2)
{
  id v4 = (void *)a1[5];
  if (IOReportChannelGetFormat(a2) == 2)
  {
    IOReportStateGetCurrent(a2);
    int Count = IOReportStateGetCount(a2);
    if (Count >= 2)
    {
      int v6 = Count;
      uint64_t v7 = 1LL;
      do
      {
        uint64_t Residency = IOReportStateGetResidency(a2, v7);
        if (Residency)
        {
          uint64_t v9 = Residency;
          unint64_t v10 = (*(_DWORD *)(*(void *)(a1[4] + 8LL) + 24LL) << 23) | (v7 << 15) | 0x302u | (unint64_t)(IOReportStateGetInTransitions(a2, v7) << 32);
          uint64_t v11 = *(void *)(v4[6] + 8LL * a1[6]);
          unint64_t v12 = v4[11];
          unint64_t v13 = v4[12];
          if (v12 >= v13)
          {
            uint64_t v15 = v4[10];
            unint64_t v16 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v12 - v15) >> 3);
            unint64_t v17 = v16 + 1;
            if (v16 + 1 > 0xAAAAAAAAAAAAAAALL) {
              abort();
            }
            unint64_t v18 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v13 - v15) >> 3);
            if (2 * v18 > v17) {
              unint64_t v17 = 2 * v18;
            }
            if (v18 >= 0x555555555555555LL) {
              unint64_t v19 = 0xAAAAAAAAAAAAAAALL;
            }
            else {
              unint64_t v19 = v17;
            }
            if (v19) {
              unint64_t v19 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<std::vector<NSObject  {objcproto21OS_dispatch_semaphore}* {__strong}>>>(v19);
            }
            else {
              uint64_t v20 = 0LL;
            }
            unint64_t v21 = v19 + 24 * v16;
            *(_BYTE *)(v21 + 4) = BYTE4(v10);
            *(_DWORD *)unint64_t v21 = v10;
            *(_WORD *)(v21 + 5) = 0;
            *(_BYTE *)(v21 + 7) = 0;
            *(void *)(v21 + _Block_object_dispose(va, 8) = v11;
            *(void *)(v21 + 16) = v9;
            unsigned int v23 = (char *)v4[10];
            unsigned int v22 = (char *)v4[11];
            unint64_t v24 = v21;
            if (v22 != v23)
            {
              do
              {
                __int128 v25 = *(_OWORD *)(v22 - 24);
                *(void *)(v24 - _Block_object_dispose(va, 8) = *((void *)v22 - 1);
                *(_OWORD *)(v24 - 24) = v25;
                v24 -= 24LL;
                v22 -= 24;
              }

              while (v22 != v23);
              unsigned int v22 = (char *)v4[10];
            }

            unint64_t v14 = v21 + 24;
            v4[10] = v24;
            v4[11] = v21 + 24;
            v4[12] = v19 + 24 * v20;
            if (v22) {
              operator delete(v22);
            }
          }

          else
          {
            *(_DWORD *)unint64_t v12 = (*(_DWORD *)(*(void *)(a1[4] + 8LL) + 24LL) << 23) | (v7 << 15) | 0x302;
            *(_BYTE *)(v12 + 4) = BYTE4(v10);
            *(_WORD *)(v12 + 5) = 0;
            *(_BYTE *)(v12 + 7) = 0;
            unint64_t v14 = v12 + 24;
            *(void *)(v12 + _Block_object_dispose(va, 8) = v11;
            *(void *)(v12 + 16) = v9;
          }

          v4[11] = v14;
        }

        uint64_t v7 = (v7 + 1);
      }

      while ((_DWORD)v7 != v6);
    }
  }

  ++*(_DWORD *)(*(void *)(a1[4] + 8LL) + 24LL);
  return 16LL;
}

void ___ZN16GTPerfStateGroup26_GatherSampleDataPerfStateERK18mach_timebase_info_block_invoke( uint64_t a1, void *a2, uint64_t a3)
{
  id v5 = a2;
  int v6 = v5;
  uint64_t v7 = *(void *)(*(void *)(a1 + 32) + 8LL);
  if (a3)
  {
    uint64_t v8 = *(void *)(a1 + 40);
    uint64_t SamplesDelta = IOReportCreateSamplesDelta(*(void *)(v7 + 24), v5, 0LL);
    unint64_t v10 = (const void *)SamplesDelta;
    if (SamplesDelta)
    {
      *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = v6;
      v11[0] = _NSConcreteStackBlock;
      v11[1] = 3221225472LL;
      v11[2] = ___ZN16GTPerfStateGroup26_GatherSampleDataPerfStateERK18mach_timebase_info_block_invoke_2;
      v11[3] = &__block_descriptor_48_e25_i16__0____CFDictionary__8l;
      v11[4] = v8;
      void v11[5] = a3;
      IOReportIterate(SamplesDelta, v11);
      CFRelease(v10);
    }
  }

  else
  {
    *(void *)(v7 + 24) = v5;
  }
}

void sub_DADD8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t ___ZN16GTPerfStateGroup26_GatherSampleDataPerfStateERK18mach_timebase_info_block_invoke_2( uint64_t a1, uint64_t a2)
{
  id v4 = *(void **)(a1 + 32);
  int Format = IOReportChannelGetFormat(a2);
  if (Format)
  {
    if (Format == 2)
    {
      unsigned __int8 Current = IOReportStateGetCurrent(a2);
      int Count = IOReportStateGetCount(a2);
      if (Count >= 1)
      {
        int v8 = Count;
        uint64_t v9 = 0LL;
        int v42 = Current << 23;
        while (1)
        {
          uint64_t Residency = IOReportStateGetResidency(a2, v9);
          if (Residency) {
            break;
          }
LABEL_40:
          uint64_t v9 = (v9 + 1);
          if ((_DWORD)v9 == v8) {
            return 16LL;
          }
        }

        uint64_t v11 = Residency;
        uint64_t NameForIndex = IOReportStateGetNameForIndex(a2, v9);
        unint64_t v13 = (void *)objc_claimAutoreleasedReturnValue(NameForIndex);
        unint64_t v14 = v13;
        if (v13)
        {
          if ((unint64_t)[v13 length] < 2
            || [v14 characterAtIndex:0] != 80)
          {
            goto LABEL_39;
          }

          uint64_t v15 = (void *)objc_claimAutoreleasedReturnValue([v14 substringFromIndex:1]);
          unsigned __int8 v16 = [v15 integerValue];

          int v17 = (v16 << 15) | v42 | 0x102;
          uint64_t v18 = *(void *)(v4[6] + 8LL * *(void *)(a1 + 40));
          unint64_t v19 = v4[11];
          unint64_t v20 = v4[12];
          if (v19 >= v20)
          {
            uint64_t v21 = v4[10];
            unint64_t v22 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v19 - v21) >> 3);
            unint64_t v23 = v22 + 1;
            if (v22 + 1 > 0xAAAAAAAAAAAAAAALL) {
              abort();
            }
            unint64_t v24 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v20 - v21) >> 3);
            if (2 * v24 > v23) {
              unint64_t v23 = 2 * v24;
            }
            if (v24 >= 0x555555555555555LL) {
              unint64_t v25 = 0xAAAAAAAAAAAAAAALL;
            }
            else {
              unint64_t v25 = v23;
            }
            if (v25) {
              unint64_t v25 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<std::vector<NSObject  {objcproto21OS_dispatch_semaphore}* {__strong}>>>(v25);
            }
            else {
              uint64_t v26 = 0LL;
            }
            unint64_t v33 = v25 + 24 * v22;
            *(_BYTE *)(v33 + 4) = 0;
            *(_DWORD *)unint64_t v33 = v17;
            *(_WORD *)(v33 + 5) = 0;
            *(_BYTE *)(v33 + 7) = 0;
            *(void *)(v33 + _Block_object_dispose(va, 8) = v18;
            *(void *)(v33 + 16) = v11;
            int v38 = (char *)v4[10];
            unsigned int v34 = (char *)v4[11];
            unint64_t v36 = v33;
            if (v34 == v38) {
              goto LABEL_36;
            }
            do
            {
              __int128 v39 = *(_OWORD *)(v34 - 24);
              *(void *)(v36 - _Block_object_dispose(va, 8) = *((void *)v34 - 1);
              *(_OWORD *)(v36 - 24) = v39;
              v36 -= 24LL;
              v34 -= 24;
            }

            while (v34 != v38);
LABEL_35:
            unsigned int v34 = (char *)v4[10];
LABEL_36:
            unint64_t v28 = v33 + 24;
            v4[10] = v36;
            v4[11] = v33 + 24;
            v4[12] = v25 + 24 * v26;
            if (v34) {
              operator delete(v34);
            }
            goto LABEL_38;
          }
        }

        else
        {
          int v17 = v42 | (v9 << 15) | 0x202;
          uint64_t v18 = *(void *)(v4[6] + 8LL * *(void *)(a1 + 40));
          unint64_t v19 = v4[11];
          unint64_t v27 = v4[12];
          if (v19 >= v27)
          {
            uint64_t v29 = v4[10];
            unint64_t v30 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v19 - v29) >> 3);
            unint64_t v31 = v30 + 1;
            if (v30 + 1 > 0xAAAAAAAAAAAAAAALL) {
              abort();
            }
            unint64_t v32 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v27 - v29) >> 3);
            if (2 * v32 > v31) {
              unint64_t v31 = 2 * v32;
            }
            if (v32 >= 0x555555555555555LL) {
              unint64_t v25 = 0xAAAAAAAAAAAAAAALL;
            }
            else {
              unint64_t v25 = v31;
            }
            if (v25) {
              unint64_t v25 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<std::vector<NSObject  {objcproto21OS_dispatch_semaphore}* {__strong}>>>(v25);
            }
            else {
              uint64_t v26 = 0LL;
            }
            unint64_t v33 = v25 + 24 * v30;
            *(_BYTE *)(v33 + 4) = 0;
            *(_DWORD *)unint64_t v33 = v17;
            *(_WORD *)(v33 + 5) = 0;
            *(_BYTE *)(v33 + 7) = 0;
            *(void *)(v33 + _Block_object_dispose(va, 8) = v18;
            *(void *)(v33 + 16) = v11;
            __int128 v35 = (char *)v4[10];
            unsigned int v34 = (char *)v4[11];
            unint64_t v36 = v33;
            if (v34 == v35) {
              goto LABEL_36;
            }
            do
            {
              __int128 v37 = *(_OWORD *)(v34 - 24);
              *(void *)(v36 - _Block_object_dispose(va, 8) = *((void *)v34 - 1);
              *(_OWORD *)(v36 - 24) = v37;
              v36 -= 24LL;
              v34 -= 24;
            }

            while (v34 != v35);
            goto LABEL_35;
          }
        }

        *(_BYTE *)(v19 + 4) = 0;
        *(_DWORD *)unint64_t v19 = v17;
        *(_WORD *)(v19 + 5) = 0;
        *(_BYTE *)(v19 + 7) = 0;
        unint64_t v28 = v19 + 24;
        *(void *)(v19 + _Block_object_dispose(va, 8) = v18;
        *(void *)(v19 + 16) = v11;
LABEL_38:
        v4[11] = v28;
LABEL_39:

        goto LABEL_40;
      }
    }

    else
    {
      IOReportChannelGetUnit(a2);
      uint64_t UnitLabel = IOReportChannelGetUnitLabel(a2);
    }
  }

  return 16LL;
}

void sub_DB134(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void ___ZN16GTPerfStateGroup20StartCollectingStatsEy_block_invoke(uint64_t a1, uint64_t a2)
{
  int v2 = *(void **)(a1 + 32);
  uint64_t IntegerValue = IOReportSimpleGetIntegerValue(a2, 0LL);
  uint64_t v4 = IntegerValue;
  int v6 = (uint64_t *)v2[15];
  unint64_t v5 = v2[16];
  if ((unint64_t)v6 >= v5)
  {
    int v8 = (uint64_t *)v2[14];
    uint64_t v9 = v6 - v8;
    unint64_t v10 = v9 + 1;
    uint64_t v11 = v5 - (void)v8;
    if (v11 >> 2 > v10) {
      unint64_t v10 = v11 >> 2;
    }
    BOOL v12 = (unint64_t)v11 >= 0x7FFFFFFFFFFFFFF8LL;
    unint64_t v13 = 0x1FFFFFFFFFFFFFFFLL;
    if (!v12) {
      unint64_t v13 = v10;
    }
    if (v13)
    {
      unint64_t v13 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<std::pair<unsigned int,unsigned int>>>(v13);
      int v8 = (uint64_t *)v2[14];
      int v6 = (uint64_t *)v2[15];
    }

    else
    {
      uint64_t v14 = 0LL;
    }

    uint64_t v15 = (uint64_t *)(v13 + 8 * v9);
    unint64_t v16 = v13 + 8 * v14;
    *uint64_t v15 = v4;
    uint64_t v7 = v15 + 1;
    while (v6 != v8)
    {
      uint64_t v17 = *--v6;
      *--uint64_t v15 = v17;
    }

    v2[14] = v15;
    v2[15] = v7;
    v2[16] = v16;
    if (v8) {
      operator delete(v8);
    }
  }

  else
  {
    *int v6 = IntegerValue;
    uint64_t v7 = v6 + 1;
  }

  v2[15] = v7;
}

void ___ZN16GTPerfStateGroup20StartCollectingStatsEy_block_invoke_2(void *a1)
{
  uint64_t v1 = a1[5];
  uint64_t v2 = *(void *)(a1[4] + 8LL);
  unint64_t v3 = *(unsigned int *)(v2 + 24);
  *(_DWORD *)(v2 + 24) = v3 + 1;
  if (a1[6] > v3)
  {
    if ((*(_DWORD *)(v1 + 76) - 1) > 1)
    {
      if (IOReportUpdateSamples(*(void *)(v1 + 104), *(void *)(v1 + 16), 0LL))
      {
        uint64_t v66 = 0LL;
        unsigned int v67 = &v66;
        uint64_t v68 = 0x2020000000LL;
        int v69 = 0;
        uint64_t v10 = mach_absolute_time();
        uint64_t v11 = v10;
        unint64_t v13 = *(char **)(v1 + 56);
        unint64_t v12 = *(void *)(v1 + 64);
        if ((unint64_t)v13 >= v12)
        {
          unint64_t v22 = *(char **)(v1 + 48);
          uint64_t v23 = (v13 - v22) >> 3;
          unint64_t v24 = v23 + 1;
          uint64_t v25 = v12 - (void)v22;
          if (v25 >> 2 > v24) {
            unint64_t v24 = v25 >> 2;
          }
          BOOL v19 = (unint64_t)v25 >= 0x7FFFFFFFFFFFFFF8LL;
          unint64_t v26 = 0x1FFFFFFFFFFFFFFFLL;
          if (!v19) {
            unint64_t v26 = v24;
          }
          if (v26)
          {
            unint64_t v26 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<std::pair<unsigned int,unsigned int>>>(v26);
            unint64_t v22 = *(char **)(v1 + 48);
            unint64_t v13 = *(char **)(v1 + 56);
          }

          else
          {
            uint64_t v27 = 0LL;
          }

          unint64_t v31 = (uint64_t *)(v26 + 8 * v23);
          unint64_t v32 = v26 + 8 * v27;
          *unint64_t v31 = v11;
          uint64_t v14 = v31 + 1;
          while (v13 != v22)
          {
            uint64_t v33 = *((void *)v13 - 1);
            v13 -= 8;
            *--unint64_t v31 = v33;
          }

          *(void *)(v1 + 4_Block_object_dispose(va, 8) = v31;
          *(void *)(v1 + 56) = v14;
          *(void *)(v1 + 64) = v32;
          if (v22) {
            operator delete(v22);
          }
        }

        else
        {
          *(void *)unint64_t v13 = v10;
          uint64_t v14 = v13 + 8;
        }

        *(void *)(v1 + 56) = v14;
        uint64_t v34 = *(void *)(v1 + 48);
        uint64_t v35 = *(void *)(v1 + 104);
        v65[0] = _NSConcreteStackBlock;
        v65[1] = 3221225472LL;
        void v65[2] = ___ZN16GTPerfStateGroup17AddPeriodicSampleEv_block_invoke;
        void v65[3] = &unk_58E7F0;
        void v65[4] = &v66;
        v65[5] = v1;
        IOReportIterate(v35, v65);
        uint64_t v36 = ((uint64_t)v14 - v34) >> 3;
        __int128 v37 = v67;
        int v38 = *((_DWORD *)v67 + 6);
        __int128 v39 = *(_BYTE **)(v1 + 112);
        unsigned int v40 = *(char **)(v1 + 120);
        unint64_t v41 = (v40 - v39) >> 3;
        if (v41 < v38)
        {
          unint64_t v47 = v38;
          unsigned int v48 = (char *)(*(void *)(v1 + 48) + 8 * v36);
          uint64_t v49 = *(void *)(v1 + 128);
          id v64 = (id)v36;
          if (v38 <= (unint64_t)((v49 - (uint64_t)v39) >> 3))
          {
            unsigned __int8 v55 = &v48[8 * v38];
            uint64_t v60 = (v40 - v39) >> 3;
            int v62 = &v48[8 * v41];
            if (v40 != v39)
            {
              memmove(v39, v48, v40 - v39);
              __int128 v39 = *(_BYTE **)(v1 + 120);
              unsigned int v40 = v39;
            }

            unsigned int v56 = v39;
            if (v62 != v55)
            {
              unsigned int v57 = v62;
              uint64_t v58 = 8 * v47 - 8 * v60;
              unsigned int v56 = v40;
              do
              {
                uint64_t v59 = *(void *)v57;
                v57 += 8;
                *(void *)unsigned int v56 = v59;
                v56 += 8;
                v58 -= 8LL;
              }

              while (v58);
            }

            int64_t v54 = v56 - v39;
          }

          else
          {
            int v50 = *((_DWORD *)v67 + 6);
            int v61 = (void *)(v1 + 112);
            if (v39)
            {
              *(void *)(v1 + 120) = v39;
              operator delete(v39);
              uint64_t v49 = 0LL;
              void *v61 = 0LL;
              *(void *)(v1 + 120) = 0LL;
              *(void *)(v1 + 12_Block_object_dispose(va, 8) = 0LL;
            }

            if (v50 < 0) {
              abort();
            }
            uint64_t v51 = v49 >> 2;
            if (v49 >> 2 <= v47) {
              uint64_t v51 = v47;
            }
            else {
              unint64_t v52 = v51;
            }
            std::vector<unsigned long>::__vallocate[abi:nn180100](v61, v52);
            int64_t v53 = 0LL;
            unsigned int v40 = *(char **)(v1 + 120);
            do
            {
              *(void *)&v40[v53] = *(void *)&v48[v53];
              v53 += 8LL;
            }

            while (8 * v47 != v53);
            int64_t v54 = v53;
          }

          uint64_t v36 = (uint64_t)v64;
          *(void *)(v1 + 120) = &v40[v54];
          __int128 v37 = v67;
          int v38 = *((_DWORD *)v67 + 6);
        }

        int v42 = v38 - 1;
        *((_DWORD *)v37 + 6) = v38 - 1;
        if (v38)
        {
          uint64_t v43 = *(void *)(v1 + 48);
          uint64_t v44 = *(void *)(v1 + 112);
          do
          {
            uint64_t v45 = v36 + v42;
            uint64_t v46 = *(void *)(v43 + 8 * v45);
            *(void *)(v43 + 8 * v45) = v46 - *(void *)(v44 + 8LL * v42);
            *(void *)(v44 + 8LL * *((int *)v67 + 6)) = v46;
            LODWORD(v46) = *((_DWORD *)v67 + 6);
            int v42 = v46 - 1;
            *((_DWORD *)v67 + 6) = v46 - 1;
          }

          while ((_DWORD)v46);
        }

        _Block_object_dispose(&v66, 8);
      }
    }

    else
    {
      uint64_t Samples = IOReportCreateSamples(*(void *)(v1 + 16), a1[7], 0LL);
      if (Samples)
      {
        id v63 = (id)Samples;
        uint64_t v5 = mach_absolute_time();
        uint64_t v6 = v5;
        int v8 = *(char **)(v1 + 56);
        unint64_t v7 = *(void *)(v1 + 64);
        if ((unint64_t)v8 >= v7)
        {
          uint64_t v15 = *(char **)(v1 + 48);
          uint64_t v16 = (v8 - v15) >> 3;
          unint64_t v17 = v16 + 1;
          uint64_t v18 = v7 - (void)v15;
          if (v18 >> 2 > v17) {
            unint64_t v17 = v18 >> 2;
          }
          BOOL v19 = (unint64_t)v18 >= 0x7FFFFFFFFFFFFFF8LL;
          unint64_t v20 = 0x1FFFFFFFFFFFFFFFLL;
          if (!v19) {
            unint64_t v20 = v17;
          }
          if (v20)
          {
            unint64_t v20 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<std::pair<unsigned int,unsigned int>>>(v20);
            uint64_t v15 = *(char **)(v1 + 48);
            int v8 = *(char **)(v1 + 56);
          }

          else
          {
            uint64_t v21 = 0LL;
          }

          unint64_t v28 = (uint64_t *)(v20 + 8 * v16);
          unint64_t v29 = v20 + 8 * v21;
          uint64_t *v28 = v6;
          uint64_t v9 = v28 + 1;
          while (v8 != v15)
          {
            uint64_t v30 = *((void *)v8 - 1);
            v8 -= 8;
            *--unint64_t v28 = v30;
          }

          *(void *)(v1 + 4_Block_object_dispose(va, 8) = v28;
          *(void *)(v1 + 56) = v9;
          *(void *)(v1 + 64) = v29;
          if (v15) {
            operator delete(v15);
          }
        }

        else
        {
          *(void *)int v8 = v5;
          uint64_t v9 = v8 + 8;
        }

        *(void *)(v1 + 56) = v9;
        [*(id *)(v1 + 40) addObject:v63];
      }
    }
  }

void sub_DB63C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, id a12)
{
}

void ___ZN16GTPerfStateGroup17AddPeriodicSampleEv_block_invoke(uint64_t a1, uint64_t a2)
{
  unint64_t v3 = *(void **)(a1 + 40);
  uint64_t IntegerValue = IOReportSimpleGetIntegerValue(a2, 0LL);
  uint64_t v5 = IntegerValue;
  unint64_t v7 = (uint64_t *)v3[7];
  unint64_t v6 = v3[8];
  if ((unint64_t)v7 >= v6)
  {
    uint64_t v9 = (uint64_t *)v3[6];
    uint64_t v10 = v7 - v9;
    unint64_t v11 = v10 + 1;
    uint64_t v12 = v6 - (void)v9;
    if (v12 >> 2 > v11) {
      unint64_t v11 = v12 >> 2;
    }
    BOOL v13 = (unint64_t)v12 >= 0x7FFFFFFFFFFFFFF8LL;
    unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
    if (!v13) {
      unint64_t v14 = v11;
    }
    if (v14)
    {
      unint64_t v14 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<std::pair<unsigned int,unsigned int>>>(v14);
      uint64_t v9 = (uint64_t *)v3[6];
      unint64_t v7 = (uint64_t *)v3[7];
    }

    else
    {
      uint64_t v15 = 0LL;
    }

    uint64_t v16 = (uint64_t *)(v14 + 8 * v10);
    unint64_t v17 = v14 + 8 * v15;
    uint64_t *v16 = v5;
    int v8 = v16 + 1;
    while (v7 != v9)
    {
      uint64_t v18 = *--v7;
      *--uint64_t v16 = v18;
    }

    v3[6] = v16;
    v3[7] = v8;
    v3[8] = v17;
    if (v9) {
      operator delete(v9);
    }
  }

  else
  {
    *unint64_t v7 = IntegerValue;
    int v8 = v7 + 1;
  }

  v3[7] = v8;
  ++*(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL);
}

uint64_t std::vector<GTPerfStateGroup>::__emplace_back_slow_path<NSString * {__strong},NSDictionary * {__strong},GTPerfStateGroup::eGTPerfStateGroup,GTPerfStateGroup::eGTPerfStateGroupType>( void *a1, void *a2, void *a3, int a4, int a5)
{
  unint64_t v5 = 0x86BCA1AF286BCA1BLL * ((uint64_t)(a1[1] - *a1) >> 3);
  unint64_t v6 = v5 + 1;
  if (v5 + 1 > 0x1AF286BCA1AF286LL) {
    abort();
  }
  else {
    unint64_t v12 = v6;
  }
  v19[4] = a1 + 2;
  if (v12)
  {
    if (v12 > 0x1AF286BCA1AF286LL) {
      std::__throw_bad_array_new_length[abi:nn180100]();
    }
    BOOL v13 = (char *)operator new(152 * v12);
  }

  else
  {
    BOOL v13 = 0LL;
  }

  unint64_t v14 = &v13[152 * v5];
  v19[0] = v13;
  v19[1] = v14;
  v19[3] = &v13[152 * v12];
  id v15 = a2;
  id v16 = a3;
  *(void *)unint64_t v14 = 0LL;
  *((void *)v14 + 1) = 0LL;
  *((void *)v14 + 3) = v15;
  *((void *)v14 + 4) = v16;
  *(_OWORD *)(v14 + 40) = 0u;
  *(_OWORD *)(v14 + 56) = 0u;
  *((_DWORD *)v14 + 1_Block_object_dispose((const void *)(v12 - 64), 8) = a4;
  *((_DWORD *)v14 + 19) = a5;
  *((void *)v14 + 11) = 0LL;
  *((void *)v14 + 12) = 0LL;
  *((void *)v14 + 10) = 0LL;
  *((_OWORD *)v14 + 7) = 0u;
  *((_OWORD *)v14 + _Block_object_dispose((const void *)(v12 - 64), 8) = 0u;
  *(void *)(v14 + 141) = 0LL;
  v19[2] = v14 + 152;
  std::vector<GTPerfStateGroup>::__swap_out_circular_buffer(a1, v19);
  uint64_t v17 = a1[1];
  std::__split_buffer<GTPerfStateGroup>::~__split_buffer((uint64_t)v19);
  return v17;
}

void sub_DB8B8(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

uint64_t ___ZN16GTPerfStateGroup5SetupEP14__CFDictionary_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = a2;
  uint64_t v3 = *(void *)(a1 + 32);
  uint64_t Group = IOReportChannelGetGroup(a2);
  uint64_t v34 = (void *)objc_claimAutoreleasedReturnValue(Group);
  if (([*(id *)(v3 + 24) isEqualToString:v34] & 1) == 0)
  {
    uint64_t v26 = 16LL;
    goto LABEL_48;
  }

  Subuint64_t Group = IOReportChannelGetSubGroup(v2);
  uint64_t v35 = (void *)objc_claimAutoreleasedReturnValue(SubGroup);
  __int128 v46 = 0u;
  __int128 v47 = 0u;
  __int128 v44 = 0u;
  __int128 v45 = 0u;
  obunint64_t j = (id)objc_claimAutoreleasedReturnValue([*(id *)(v3 + 32) allKeys]);
  id v6 = [obj countByEnumeratingWithState:&v44 objects:v50 count:16];
  if (!v6)
  {
    uint64_t v26 = 16LL;
    goto LABEL_47;
  }

  uint64_t v7 = *(void *)v45;
  uint64_t v29 = v3;
  uint64_t v30 = v2;
  uint64_t v28 = *(void *)v45;
  while (2)
  {
    int v8 = 0LL;
    id v31 = v6;
    do
    {
      if (*(void *)v45 != v7) {
        objc_enumerationMutation(obj);
      }
      uint64_t v9 = *(void *)(*((void *)&v44 + 1) + 8LL * (void)v8);
      if (objc_msgSend(v35, "hasPrefix:", v9, v28, v29, v30))
      {
        id v10 = (id)objc_claimAutoreleasedReturnValue([*(id *)(v3 + 32) objectForKeyedSubscript:v9]);
        if (v10)
        {
          uint64_t ChannelName = IOReportChannelGetChannelName(v2);
          unint64_t v12 = (void *)objc_claimAutoreleasedReturnValue(ChannelName);
          int v13 = *(_DWORD *)(v3 + 76);
          if (v13)
          {
            if (v13 != 2)
            {
              if (v13 == 1 && ([v10 containsObject:v12] & 1) != 0)
              {
LABEL_45:

                uint64_t v26 = 0LL;
                goto LABEL_47;
              }

              goto LABEL_39;
            }

            __int128 v42 = 0u;
            __int128 v43 = 0u;
            __int128 v40 = 0u;
            __int128 v41 = 0u;
            unint64_t v32 = v10;
            id v10 = v10;
            id v17 = [v10 countByEnumeratingWithState:&v40 objects:v49 count:16];
            if (v17)
            {
              uint64_t v18 = *(void *)v41;
              do
              {
                for (int i = 0LL; i != v17; int i = (char *)i + 1)
                {
                  if (*(void *)v41 != v18) {
                    objc_enumerationMutation(v10);
                  }
                  uint64_t v20 = *(void *)(*((void *)&v40 + 1) + 8LL * (void)i);
                  if (([v12 containsString:@"_1_"] & 1) == 0)
                  {
                    unint64_t v22 = [v12 rangeOfString:v20];
                    if (v22 != (_BYTE *)0x7FFFFFFFFFFFFFFFLL)
                    {
                      unint64_t v24 = objc_msgSend( v12,  "rangeOfString:options:range:",  @"_",  0,  &v22[v21],  (_BYTE *)objc_msgSend(v12, "length") - &v22[v21]);
                      if (v24 != (_BYTE *)0x7FFFFFFFFFFFFFFFLL)
                      {
                        uint64_t v25 = (char *)((_BYTE *)[v12 length] - &v24[v23]);
                        if (v25 == (char *)&dword_4)
                        {
                          if (objc_msgSend( v12,  "characterAtIndex:",  (char *)objc_msgSend(v12, "length") - 4) == 86) {
                            goto LABEL_44;
                          }
                        }

                        else if (v25 == (_BYTE *)&dword_0 + 2 {
                               && objc_msgSend( v12,  "characterAtIndex:",  (char *)objc_msgSend(v12, "length") - 2) == 70)
                        }
                        {
                          goto LABEL_44;
                        }
                      }
                    }
                  }
                }

                id v17 = [v10 countByEnumeratingWithState:&v40 objects:v49 count:16];
              }

              while (v17);
            }
          }

          else
          {
            __int128 v38 = 0u;
            __int128 v39 = 0u;
            __int128 v36 = 0u;
            __int128 v37 = 0u;
            unint64_t v32 = v10;
            id v10 = v10;
            id v14 = [v10 countByEnumeratingWithState:&v36 objects:v48 count:16];
            if (v14)
            {
              uint64_t v15 = *(void *)v37;
              while (2)
              {
                for (unint64_t j = 0LL; j != v14; unint64_t j = (char *)j + 1)
                {
                  if (*(void *)v37 != v15) {
                    objc_enumerationMutation(v10);
                  }
                  if ([v12 containsString:*(void *)(*((void *)&v36 + 1) + 8 * (void)j)])
                  {
LABEL_44:

                    goto LABEL_45;
                  }
                }

                id v14 = [v10 countByEnumeratingWithState:&v36 objects:v48 count:16];
                if (v14) {
                  continue;
                }
                break;
              }
            }
          }

          id v10 = v32;

          uint64_t v3 = v29;
          uint64_t v2 = v30;
          uint64_t v7 = v28;
          id v6 = v31;
LABEL_39:
        }
      }

      int v8 = (char *)v8 + 1;
    }

    while (v8 != v6);
    id v6 = [obj countByEnumeratingWithState:&v44 objects:v50 count:16];
    uint64_t v26 = 16LL;
    if (v6) {
      continue;
    }
    break;
  }

void sub_DBCA8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, void *a15, void *a16)
{
}

uint64_t ___ZN16GTPerfStateGroup27_FindSubscribedCounterNamesEv_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a1 + 40);
  uint64_t ChannelName = IOReportChannelGetChannelName(a2);
  unint64_t v5 = (void *)objc_claimAutoreleasedReturnValue(ChannelName);
  id v6 = (char *)[v5 rangeOfString:@"_0_"];
  if (v6 != (char *)0x7FFFFFFFFFFFFFFFLL)
  {
    uint64_t v8 = objc_claimAutoreleasedReturnValue([v5 substringFromIndex:&v6[v7]]);

    unint64_t v5 = (void *)v8;
  }

  __int128 v20 = 0u;
  __int128 v21 = 0u;
  __int128 v18 = 0u;
  __int128 v19 = 0u;
  id v9 = *(id *)(a1 + 32);
  id v10 = [v9 countByEnumeratingWithState:&v18 objects:v22 count:16];
  if (v10)
  {
    uint64_t v11 = *(void *)v19;
    while (2)
    {
      for (int i = 0LL; i != v10; int i = (char *)i + 1)
      {
        if (*(void *)v19 != v11) {
          objc_enumerationMutation(v9);
        }
        uint64_t v13 = *(void *)(*((void *)&v18 + 1) + 8LL * (void)i);
        if (objc_msgSend(v5, "hasSuffix:", v13, (void)v18))
        {
          id v14 = (char *)[v5 length];
          uint64_t v15 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) objectForKeyedSubscript:v13]);
          uint64_t v16 = objc_claimAutoreleasedReturnValue(objc_msgSend(v5, "stringByReplacingCharactersInRange:withString:", v14 - 4, 4, v15));

          unint64_t v5 = (void *)v16;
          goto LABEL_13;
        }
      }

      id v10 = [v9 countByEnumeratingWithState:&v18 objects:v22 count:16];
      if (v10) {
        continue;
      }
      break;
    }
  }

void sub_DBEF0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void *std::vector<GTPerfStateGroup>::__swap_out_circular_buffer(void *result, void *a2)
{
  uint64_t v2 = result[1];
  uint64_t v3 = a2[1];
  uint64_t v28 = *result;
  if (v2 != *result)
  {
    uint64_t v26 = result;
    uint64_t v27 = a2;
    uint64_t v4 = 0LL;
    uint64_t v29 = result[1];
    do
    {
      uint64_t v5 = v3 + v4;
      *(void *)(v5 - 152) = *(id *)(v2 + v4 - 152);
      id v6 = *(id *)(v2 + v4 - 144);
      uint64_t v7 = *(void *)(v2 + v4 - 136);
      uint64_t v8 = *(void **)(v2 + v4 - 128);
      *(void *)(v5 - std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long>>>::~__hash_table(v2 - 144) = v6;
      *(void *)(v5 - 136) = v7;
      *(void *)(v5 - 12_Block_object_dispose((const void *)(v12 - 64), 8) = v8;
      *(void *)(v5 - 120) = *(id *)(v2 + v4 - 120);
      *(void *)(v5 - 112) = *(id *)(v2 + v4 - 112);
      std::vector<unsigned long long>::vector((void *)(v3 + v4 - 104), v2 + v4 - 104);
      uint64_t v9 = *(void *)(v2 + v4 - 80);
      *(void *)(v5 - 72) = 0LL;
      uint64_t v10 = v3 + v4 - 72;
      *(void *)(v5 - 80) = v9;
      *(void *)(v10 + _Block_object_dispose((const void *)(v12 - 64), 8) = 0LL;
      *(void *)(v10 + 16) = 0LL;
      unint64_t v12 = *(_BYTE **)(v2 + v4 - 72);
      uint64_t v11 = *(_BYTE **)(v2 + v4 - 64);
      int64_t v13 = v11 - v12;
      if (v11 != v12)
      {
        std::vector<PStateInfo>::__vallocate[abi:nn180100]((void *)(v5 - 72), 0xAAAAAAAAAAAAAAABLL * (v13 >> 3));
        id v14 = *(char **)(v3 + v4 - 64);
        memmove(v14, v12, v13);
        *(void *)(v3 + v4 - 64) = &v14[8 * (v13 >> 3)];
        uint64_t v2 = v29;
      }

      uint64_t v15 = v3 + v4;
      uint64_t v16 = v2 + v4;
      uint64_t v17 = *(void *)(v2 + v4 - 48);
      *(void *)(v3 + v4 - 40) = 0LL;
      __int128 v18 = (void *)(v3 + v4 - 40);
      *(v18 - 1) = v17;
      v18[1] = 0LL;
      v18[2] = 0LL;
      __int128 v20 = *(_BYTE **)(v2 + v4 - 40);
      __int128 v19 = *(_BYTE **)(v2 + v4 - 32);
      int64_t v21 = v19 - v20;
      if (v19 != v20)
      {
        std::vector<unsigned long>::__vallocate[abi:nn180100](v18, v21 >> 3);
        unint64_t v22 = *(char **)(v3 + v4 - 32);
        memmove(v22, v20, v21);
        *(void *)(v3 + v4 - 32) = &v22[8 * (v21 >> 3)];
        uint64_t v2 = v29;
      }

      *(void *)(v15 - 16) = *(id *)(v16 - 16);
      *(void *)(v15 - _Block_object_dispose((const void *)(v12 - 64), 8) = *(void *)(v16 - 8);
      v4 -= 152LL;
    }

    while (v2 + v4 != v28);
    v3 += v4;
    BOOL result = v26;
    a2 = v27;
  }

  a2[1] = v3;
  uint64_t v23 = *result;
  uint64_t *result = v3;
  a2[1] = v23;
  uint64_t v24 = result[1];
  result[1] = a2[2];
  a2[2] = v24;
  uint64_t v25 = result[2];
  result[2] = a2[3];
  a2[3] = v25;
  *a2 = a2[1];
  return result;
}

void sub_DC100(_Unwind_Exception *a1)
{
  uint64_t v5 = *v2;
  if (*v2)
  {
    *(void *)(v3 - 64) = v5;
    operator delete(v5);
  }

  id v6 = *v1;
  if (*v1)
  {
    *(void *)(v3 - 96) = v6;
    operator delete(v6);
  }

  _Unwind_Resume(a1);
}

uint64_t std::__split_buffer<GTPerfStateGroup>::~__split_buffer(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 152;
    GTPerfStateGroup::~GTPerfStateGroup((GTPerfStateGroup *)(i - 152));
  }

  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

char *std::vector<PStateInfo>::__vallocate[abi:nn180100](void *a1, unint64_t a2)
{
  if (a2 >= 0xAAAAAAAAAAAAAABLL) {
    abort();
  }
  BOOL result = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<std::vector<NSObject  {objcproto21OS_dispatch_semaphore}* {__strong}>>>(a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[24 * v4];
  return result;
}

void sub_DC2B4( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void GTMTLReplayController_initializeArgumentBufferSupport(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v145 = a3;
  uint64_t v6 = GTMTLSMContext_getObject(**(void **)(a1 + 40), 1LL, *(void *)(a1 + 80))[5];
  if ((dword_5B9DE4 & 0x10000) != 0)
  {
    if ((GT_SUPPORT_0 & 0x80000) != 0) {
      uint64_t v7 = (*(_DWORD *)(a1 + 272) << 18) & 0x80000;
    }
    else {
      uint64_t v7 = 0LL;
    }
    GT_SUPPORT_0 = v7 | GT_SUPPORT_0 & 0xFFFFFFFFFFF7FFFFLL;
  }

  if (*(_BYTE *)(v6 + 110))
  {
    uint64_t v8 = 0x80000LL;
    unint64_t v9 = v8 | GT_SUPPORT_0 & 0xFFFFFFFFFFF7FFFFLL;
  }

  else
  {
    unint64_t v9 = GT_SUPPORT_0 & 0xFFFFFFFFFFF7FFFFLL;
  }

  BOOL v20 = ((*(void *)(v6 + 32) >> 8) & 1 & (v9 >> 20)) == 0;
  uint64_t v10 = 0x100000LL;
  if (v20) {
    uint64_t v10 = 0LL;
  }
  GT_SUPPORT_0 = v10 | v9 & 0xFFFFFFFFFFEFFFFFLL;
  if ((v9 & 0x80000) != 0)
  {
    id v141 = v5;
    id v11 = v5;
    id v12 = v145;
    uint64_t v13 = *(void *)(a1 + 192);
    int v14 = *(_DWORD *)(v13 + 12);
    if (v14 >= 1)
    {
      int v15 = 0;
      int v16 = GT_SUPPORT_0;
      do
      {
        uint64_t v17 = *(void *)(v13 + 24);
        __int128 v18 = *(int **)(v17 + 8LL * v15);
        int v19 = *v18;
        BOOL v20 = *v18 == 50 || v19 == 22;
        if (v20 || v19 == 16 && (v16 & 0x100000) == 0)
        {
          *(_DWORD *)(v13 + 12) = --v14;
          *(void *)(v17 + 8LL * v15) = *(void *)(v17 + 8LL * v14);
          *(void *)(*(void *)(v13 + 24) + 8LL * v14) = v18;
        }

        else
        {
          ++v15;
        }
      }

      while (v15 < v14);
    }

    uint64_t v143 = a1;
    int64_t v21 = *(void **)(a1 + 40);
    id v23 = v11;
    unsigned int v146 = v21;
    uint64_t v24 = v21[10];
    if (*(int *)(v24 + 12) >= 1)
    {
      uint64_t v25 = 0LL;
      while (1)
      {
        uint64_t v26 = *(void *)(*(void *)(v24 + 24) + 8 * v25);
        uint64_t v27 = *(void **)(v26 + 48);
        MTLHeapDescriptor = MakeMTLHeapDescriptor((uint64_t)v27);
        uint64_t v29 = (void *)objc_claimAutoreleasedReturnValue(MTLHeapDescriptor);
        [v29 setPinnedGPUAddress:*v27];
        id v30 = [v29 size];
        id v31 = (id)*(unsigned int *)(v26 + 76);
        if (v30 >= v31) {
          id v31 = [v29 size];
        }
        [v29 setSize:v31];
        unint64_t v32 = (char *)[v29 type];
        if (v32 != (_BYTE *)&dword_0 + 2) {
          goto LABEL_34;
        }
LABEL_38:
      }

      [v29 setType:1];
LABEL_34:
      id v33 = [v23 newHeapWithDescriptor:v29];
      if (v33) {
        [v12 setHeap:v33 forKey:*(void *)(v26 + 8)];
      }
      else {
        GTMTLReplay_handleError( 101,  (uint64_t)"Heap creation failed",  "/Library/Caches/com.apple.xbs/Sources/GPUToolsDevice/GPUTools/GTMTLCapture/replayer/GTMTLReplay_argumentBuffers.m",  (uint64_t)"GTMTLReplayController_allocateBuffersAndHeaps",  177LL,  1LL);
      }

      goto LABEL_38;
    }

LABEL_100:
  ReserveResourceIndices(v147, (uint64_t)v65, 0);
  char v66 = g_enableIndexedResourceType;
  if ((g_enableIndexedResourceType & 2) == 0)
  {
LABEL_86:
    if ((v66 & 0x10) == 0) {
      goto LABEL_87;
    }
    goto LABEL_110;
  }

  uint64_t v70 = *a4;
  uint64_t v80 = 0u;
  int v81 = 0u;
  uint64_t v77 = v70;
  uint64_t v78 = 500;
  uint64_t v69 = "4 <= parser.ntokens";
LABEL_101:
  unint64_t v79 = v69;
  char v66 = &v77;
LABEL_102:
  GTError_addError(a4, (uint64_t)v66);
  if ((_DWORD)a3) {
    goto LABEL_97;
  }
LABEL_98:
  BOOL result = a2[11];
  a2[11] = result + 160;
  return result;
}

LABEL_101:
  v65->int nelts = 0;
  uint64_t v73 = v59[3];
  int v74 = *(_DWORD *)(v73 + 12);
  int v75 = v147;
  if (v74 >= 1)
  {
    for (uint64_t j = 0LL; j < v74; ++j)
    {
      uint64_t v77 = *(void *)(*(void *)(*(void *)(v73 + 24) + 8 * j) + 48LL);
      if (v77)
      {
        if (*(_BYTE *)(v77 + 62))
        {
          uint64_t v78 = *(void *)(v77 + 16);
          int v75 = v147;
          if (v78)
          {
            unint64_t v79 = apr_array_push(v65);
            int v75 = v147;
            *unint64_t v79 = v78;
            int v74 = *(_DWORD *)(v73 + 12);
          }
        }

        else
        {
          int v75 = v147;
        }
      }
    }
  }

  ReserveResourceIndices(v75, (uint64_t)v65, 1u);
  char v66 = g_enableIndexedResourceType;
  if ((g_enableIndexedResourceType & 0x10) == 0)
  {
LABEL_87:
    if ((v66 & 0x20) == 0) {
      goto LABEL_88;
    }
    goto LABEL_126;
  }

                  uint64_t v71 = v68 | (unint64_t)(v70 << 32);
LABEL_102:
                  uint64_t v72 = v67 + 64;
                  while (v67 && (*(_BYTE *)(v72 + ((uint64_t)(HIDWORD(v71) - (int)v71) << 6) + 15) & 8) != 0)
                  {
                    uint64_t v73 = v72 + ((uint64_t)(HIDWORD(v71) - (int)v71) << 6);
                    if (!IsFuncEnumCreateCommandEncoder(*(_DWORD *)(v73 + 8))) {
                      GTMTLSMCommandEncoder_processTraceFunc((uint64_t)&v81, (uint64_t *)v73, a1[1]);
                    }
                    int v74 = atomic_load((unsigned int *)(v67 + 4));
                    int v75 = v71 + (v74 >> 6);
                    int v76 = (HIDWORD(v71) + 1);
                    uint64_t v71 = (v76 << 32) | v71;
                    if ((_DWORD)v76 == v75 - 1)
                    {
                      uint64_t v71 = (v76 << 32) | v76;
                      uint64_t v67 = *(void *)(v67 + 40);
                      goto LABEL_102;
                    }
                  }

                  int v50 = v85;
                  unint64_t v79 = v86;
                  uint64_t v80 = v86[64];
                  uint64_t v51 = renderCommandEncoder_processStreamWithDescriptor(a1, (uint64_t)v85, (uint64_t)&v87);
LABEL_110:
                  RenderEncoderWithDescriptor(a1, v50);
                  if ((_DWORD)v87 == 70)
                  {
                    id v64 = (__int128 **)&v79;
                    unsigned int v65 = a1;
                    char v66 = (uint64_t)v50;
                    id v63 = v51;
LABEL_112:
                    RenderEncoderEndEncoding(v65, v66, (uint64_t)v64, v63);
                  }

                  return;
                }
              }
            }
          }

          else
          {
            id v12 = 0LL;
          }

          int v14 = 0LL;
          goto LABEL_94;
        }

        id v31 = *a1;
        *(void *)&uint64_t v87 = v78;
        unint64_t v32 = *find_entry(v31, &v87, 8uLL, 0LL);
        if (v32)
        {
          id v33 = *(void *)(v32 + 32);
          bzero(&v87, 0x2B90uLL);
          if (v33)
          {
            uint64_t v34 = *(void *)(v33 + 32);
            if (v34)
            {
              if ((*(_BYTE *)(v34 + 79) & 8) != 0)
              {
                uint64_t v35 = (uint64_t *)(v34 + 64);
LABEL_74:
                GTMTLSMCommandEncoder_processTraceFunc((uint64_t)&v87, v35, a1[1]);
                uint64_t v52 = *((void *)&v91 + 1);
                RenderEncoderWithDescriptor(a1, *((uint64_t **)&v91 + 1));
                uint64_t v53 = *(void *)(v33 + 32);
                if (v53)
                {
                  int64_t v54 = 0;
                  while (1)
                  {
                    unsigned __int8 v55 = atomic_load((unsigned int *)(v53 + 4));
                    id v56 = v54 + (v55 >> 6) - 1;
                    uint64_t v53 = *(void *)(v53 + 40);
                    int64_t v54 = v56;
                    if (!v53)
                    {
                      int64_t v54 = v56;
                      goto LABEL_81;
                    }
                  }

                  id v56 = 1LL;
                }

                else
                {
                  int64_t v54 = 0;
                  id v56 = 0LL;
                }

LABEL_110:
  v65->int nelts = 0;
  uint64_t v80 = v59[4];
  int v81 = *(_DWORD *)(v80 + 12);
  if (v81 >= 1)
  {
    for (uint64_t k = 0LL; k < v81; ++k)
    {
      uint64_t v83 = *(void *)(*(void *)(*(void *)(v80 + 24) + 8 * k) + 48LL);
      if (v83)
      {
        if (*(_BYTE *)(v83 + 1499))
        {
          uint64_t v84 = *(void *)(v83 + 1280);
          if (v84)
          {
            *(void *)apr_array_push(v65) = v84;
            int v81 = *(_DWORD *)(v80 + 12);
          }
        }
      }
    }
  }

  uint64_t v85 = v59[5];
  if (*(int *)(v85 + 12) >= 1)
  {
    uint64_t v86 = 0LL;
    do
    {
      GTMTLSMComputePipelineState_computePipelineDescriptor( v59,  *(void *)(*(void *)(v85 + 24) + 8 * v86),  newpool,  v63);
      uint64_t v87 = v149;
      if (v150) {
        BOOL v88 = v149 == 0;
      }
      else {
        BOOL v88 = 1;
      }
      if (!v88) {
        *(void *)apr_array_push(v65) = v87;
      }
      ++v86;
    }

    while (v86 < *(int *)(v85 + 12));
  }

  ReserveResourceIndices(v147, (uint64_t)v65, 4u);
  char v66 = g_enableIndexedResourceType;
  if ((g_enableIndexedResourceType & 0x20) == 0)
  {
LABEL_88:
    if ((v66 & 0x40) == 0) {
      goto LABEL_89;
    }
    goto LABEL_132;
  }

      *(void *)id v64 = *(void *)v63;
    }

    while (v60 <= (uint64_t)((unint64_t)(v61 - 2) >> 1));
    unint64_t v79 = v45 - 8;
    if (v63 == v45 - 8)
    {
      *(void *)id v63 = v62;
    }

    else
    {
      *(void *)id v63 = *(void *)v79;
      *(void *)unint64_t v79 = v62;
      std::__sift_up[abi:nn180100]<std::_ClassicAlgPolicy,GRCFrameTimeData::ProcessSingleFrameData(NSArray<NSData *> *,std::unordered_set<unsigned int> const&)::$_0 &,std::__wrap_iter<GRCFrameTimeData::ProcessSingleFrameData(NSArray<NSData *> *,std::unordered_set<unsigned int> const&)::PriorityQueueElement *>>( (uint64_t)v44,  (uint64_t)(v63 + 8),  (uint64_t **)&p_p,  (v63 + 8 - v44) >> 3);
    }

LABEL_144:
  if ((GT_SUPPORT_0 & 0x100000) != 0 && (g_enableIndexedResourceType & 0x100) != 0)
  {
    v65->int nelts = 0;
    uint64_t v107 = v59[9];
    if (*(int *)(v107 + 12) >= 1)
    {
      uint64_t v108 = 0LL;
      do
      {
        uint64_t v109 = *(void *)(*(void *)(*(void *)(v107 + 24) + 8 * v108) + 152LL);
        *(void *)apr_array_push(v65) = v109;
        ++v108;
      }

      while (v108 < *(int *)(v107 + 12));
    }

    ReserveResourceIndices(v147, (uint64_t)v65, 8u);
  }

  apr_pool_destroy(v63);
  uint64_t v110 = (uint64_t (*)(void))MakeMTLTextureDescriptorWithResourceIndex;
  if ((g_enableIndexedResourceType & 1) == 0) {
    uint64_t v110 = (uint64_t (*)(void))MakeMTLTextureDescriptorWithoutResourceIndex;
  }
  MakeMTLTextureDescriptor = v110;
  uint64_t v111 = MakeMTLSamplerDescriptorWithResourceIndex;
  if ((g_enableIndexedResourceType & 2) == 0) {
    uint64_t v111 = MakeMTLSamplerDescriptorWithoutResourceIndex;
  }
  MakeMTLSamplerDescriptor = v111;
  uint64_t v112 = MakeMTLIndirectCommandBufferDescriptorWithResourceIndex;
  if ((g_enableIndexedResourceType & 0x20) == 0) {
    uint64_t v112 = MakeMTLIndirectCommandBufferDescriptorWithoutResourceIndex;
  }
  MakeMTLIndirectCommandBufferDescriptor = v112;
  int v113 = (uint64_t (*)(void))MakeMTLRenderPipelineDescriptorWithResourceIndex;
  if ((g_enableIndexedResourceType & 0x10) == 0) {
    int v113 = (uint64_t (*)(void))MakeMTLRenderPipelineDescriptorWithoutResourceIndex;
  }
  MakeMTLRenderPipelineDescriptor = v113;
  uint64_t v114 = (uint64_t (*)(void))MakeMTLMeshRenderPipelineDescriptorWithResourceIndex;
  if ((g_enableIndexedResourceType & 0x10) == 0) {
    uint64_t v114 = (uint64_t (*)(void))MakeMTLMeshRenderPipelineDescriptorWithoutResourceIndex;
  }
  MakeMTLMeshRenderPipelineDescriptor = v114;
  uint64_t v115 = (uint64_t (*)(void))MakeMTLComputePipelineDescriptorWithResourceIndex;
  if ((g_enableIndexedResourceType & 0x10) == 0) {
    uint64_t v115 = (uint64_t (*)(void))MakeMTLComputePipelineDescriptorWithoutResourceIndex;
  }
  MakeMTLComputePipelineDescriptor = v115;
  uint64_t v116 = MakeMTLVisibleFunctionTableDescriptorWithResourceIndex;
  if ((g_enableIndexedResourceType & 0x40) == 0) {
    uint64_t v116 = MakeMTLVisibleFunctionTableDescriptorWithoutResourceIndex;
  }
  MakeMTLVisibleFunctionTableDescriptor = v116;
  uint64_t v117 = MakeMTLIntersectionFunctionTableDescriptorWithResourceIndex;
  if ((g_enableIndexedResourceType & 0x80) == 0) {
    uint64_t v117 = MakeMTLIntersectionFunctionTableDescriptorWithoutResourceIndex;
  }
  MakeMTLIntersectionFunctionTableDescriptor = v117;

  if ((GT_SUPPORT_0 & 0x80000) != 0)
  {
    id v118 = v147;
    id v119 = v145;
    uint64_t v120 = *(void *)(a1 + 40);
    id v121 = v118;
    uint64_t v142 = v120;
    uint64_t v122 = *(void *)(v120 + 8);
    id v144 = objc_alloc_init(&OBJC_CLASS___MTLBufferDescriptor);
    if (*(int *)(v122 + 12) >= 1)
    {
      uint64_t v123 = 0LL;
      do
      {
        uint64_t v124 = *(void *)(*(void *)(v122 + 24) + 8 * v123);
        if (*(void *)(v124 + 48))
        {
          unsigned int v125 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v119, "heapForKey:"));
          if (!v125) {
            GTMTLReplay_handleError( 101,  (uint64_t)"Buffer creationg failed: heap is nil",  "/Library/Caches/com.apple.xbs/Sources/GPUToolsDevice/GPUTools/GTMTLCapture/replayer/GTMTLReplay_argumentBuffers.m",  (uint64_t)"GTMTLReplayController_allocateHeapAndBufferChildren",  336LL,  1LL);
          }
          id v126 = [v125 newBufferWithLength:*(void *)(v124 + 104) options:*(unsigned __int16 *)(v124 + 96) offset:*(unsigned int *)(v124 + 80)];

          if (v126)
          {
            [v119 setBuffer:v126 forKey:*(void *)(v124 + 8)];
          }

          else
          {
            GTMTLReplay_handleError( 101,  (uint64_t)"Buffer freation Failed",  "/Library/Caches/com.apple.xbs/Sources/GPUToolsDevice/GPUTools/GTMTLCapture/replayer/GTMTLReplay_argumentBuffers.m",  (uint64_t)"GTMTLReplayController_allocateHeapAndBufferChildren",  351LL,  1LL);
          }
        }

        ++v123;
      }

      while (v123 < *(int *)(v122 + 12));
    }

    uint64_t v127 = *(void *)(v142 + 72);
    if (*(int *)(v127 + 12) >= 1)
    {
      for (juint64_t j = 0LL; jj < *(int *)(v127 + 12); ++jj)
      {
        uint64_t v129 = *(void *)(*(void *)(v127 + 24) + 8 * jj);
        if (*(void *)(v129 + 144))
        {
          uint64_t v130 = objc_claimAutoreleasedReturnValue(objc_msgSend(v119, "bufferForKey:"));
          if (!v130)
          {
            unsigned int v137 = "Acceleration structure creation failed: buffer is nil";
            uint64_t v138 = 367LL;
LABEL_193:
            GTMTLReplay_handleError( 101,  (uint64_t)v137,  "/Library/Caches/com.apple.xbs/Sources/GPUToolsDevice/GPUTools/GTMTLCapture/replayer/GTMTLReplay_argumentBuffers.m",  (uint64_t)"GTMTLReplayController_allocateHeapAndBufferChildren",  v138,  1LL);
            continue;
          }

          unsigned int v131 = (void *)v130;
          uint64_t v132 = *(void *)(v129 + 200);
          if (*(void *)(v129 + 152)) {
            id v133 = objc_msgSend(v121, "newAccelerationStructureWithBuffer:offset:resourceIndex:", v130, v132);
          }
          else {
            id v133 = [v121 newAccelerationStructureWithBuffer:v130 offset:v132];
          }
        }

        else
        {
          if (!*(void *)(v129 + 48)) {
            continue;
          }
          unint64_t v134 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v119, "heapForKey:"));
          if (!v134)
          {
            unsigned int v137 = "Accelertion structure creation failed: heap is nil";
            uint64_t v138 = 387LL;
            goto LABEL_193;
          }

          unsigned int v131 = v134;
          uint64_t v135 = *(void *)(v129 + 184);
          uint64_t v136 = *(unsigned int *)(v129 + 80);
          if (*(void *)(v129 + 152)) {
            id v133 = objc_msgSend(v134, "newAccelerationStructureWithSize:offset:resourceIndex:", v135, v136);
          }
          else {
            id v133 = [v134 newAccelerationStructureWithSize:v135 offset:v136];
          }
        }

        unsigned int v139 = v133;

        if (!v139)
        {
          unsigned int v137 = "Acceleration Structure Creation Failed";
          uint64_t v138 = 416LL;
          goto LABEL_193;
        }

        [v119 setAccelerationStructure:v139 forKey:*(void *)(v129 + 8)];
      }
    }
  }
}

uint64_t initializeResourcePatchingTypes(void *a1, char *a2)
{
  id v3 = a1;
  id v4 = DEVICEOBJECT(v3);
  id v5 = (void *)objc_claimAutoreleasedReturnValue(v4);
  char v6 = objc_opt_respondsToSelector(v5, "resourcePatchingTypeForResourceType:");

  if ((v6 & 1) != 0)
  {
    uint64_t v7 = 0LL;
    uint64_t v8 = 0LL;
    do
    {
      if (v7 == 3)
      {
      }

      else if ([v3 resourcePatchingTypeForResourceType:v7] == a2)
      {
        v8 |= 1LL << v7;
      }

      ++v7;
    }

    while (v7 != 9);
  }

  else if (a2 == (_BYTE *)&dword_0 + 2)
  {
    uint64_t v8 = 511LL;
  }

  else
  {
    uint64_t v8 = 0LL;
  }

  return v8;
}

void ReserveResourceIndices(void *a1, uint64_t a2, unsigned int a3)
{
  id v5 = a1;
  size_t v6 = *(int *)(a2 + 12);
  if ((_DWORD)v6)
  {
    int v14 = v5;
    qsort(*(void **)(a2 + 24), v6, *(int *)(a2 + 8), (int (__cdecl *)(const void *, const void *))CompareU64);
    uint64_t v7 = *(uint64_t **)(a2 + 24);
    uint64_t v8 = *v7;
    *(_DWORD *)(a2 + 12) = 1;
    if ((int)v6 >= 2)
    {
      uint64_t v9 = v6 - 1LL;
      uint64_t v10 = v7 + 1;
      int v11 = 1;
      do
      {
        uint64_t v13 = *v10++;
        uint64_t v12 = v13;
        if (v8 != v13)
        {
          v7[v11++] = v12;
          *(_DWORD *)(a2 + 12) = v11;
          uint64_t v8 = v12;
        }

        --v9;
      }

      while (v9);
    }

    objc_msgSend(v14, "reserveResourceIndicesForResourceType:indices:indexCount:", a3);
  }

  else
  {
    g_forcePatchingTypeReplaceMask |= 1LL << a3;
    g_enableIndexedResourceType &= ~(1LL << a3);
  }

uint64_t CompareU64(void *a1, void *a2)
{
  if (*a1 < *a2) {
    return 0xFFFFFFFFLL;
  }
  else {
    return *a1 != *a2;
  }
}

uint64_t GetAliasStream2(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = a2;
  entry = find_entry(*(void *)(a1 + 24), &v7, 8uLL, 0LL);
  if (*entry
    && (uint64_t v4 = *(void *)(*entry + 32LL)) != 0
    && (unint64_t v5 = atomic_load((unint64_t *)(*(void *)(a1 + 16) + 72LL)), v5 < *(void *)(v4 + 24)))
  {
    return *(void *)(v4 + 8);
  }

  else
  {
    return 0LL;
  }

uint64_t DYMTLMutableBufferAncestor_compare(void *a1, void *a2)
{
  unint64_t v2 = a1[1];
  unint64_t v3 = a2[1];
  if (v2 == v3)
  {
    if (*a1 < *a2) {
      return 0xFFFFFFFFLL;
    }
    else {
      return *a1 != *a2;
    }
  }

  else if (v2 < v3)
  {
    return 0xFFFFFFFFLL;
  }

  else
  {
    return 1LL;
  }

uint64_t GTTrackerIndirectArgumentBufferInfo_compare(void *a1, void *a2)
{
  unint64_t v2 = a1[2];
  unint64_t v3 = a2[2];
  BOOL v4 = v2 >= v3;
  if (v2 == v3 && (v5 = a1[3], v6 = a2[3], BOOL v4 = v5 >= v6, v5 == v6))
  {
    unint64_t v7 = a1[4];
    unint64_t v8 = a2[4];
    BOOL v4 = v7 >= v8;
    BOOL v9 = v7 != v8;
    if (v4) {
      return v9;
    }
    else {
      return 0xFFFFFFFFLL;
    }
  }

  else if (v4)
  {
    return 1LL;
  }

  else
  {
    return 0xFFFFFFFFLL;
  }

uint64_t *ConvertUniqueIdentifierResources(uint64_t *result, uint64_t a2)
{
  if (*(int *)(a2 + 12) >= 1)
  {
    uint64_t v3 = (uint64_t)result;
    uint64_t v4 = 0LL;
    uint64_t v5 = 8LL;
    do
    {
      uint64_t v6 = *(void *)(a2 + 24);
      BOOL result = (uint64_t *)GetAliasStream2(v3, *(void *)(v6 + v5));
      if (result) {
        uint64_t v7 = *result;
      }
      else {
        uint64_t v7 = 0LL;
      }
      *(void *)(v6 + v5) = v7;
      ++v4;
      v5 += 32LL;
    }

    while (v4 < *(int *)(a2 + 12));
  }

  return result;
}

uint64_t DYMTLIndirectArgumentBufferManager_cleanup(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 120);
  *(void *)(a1 + 120) = 0LL;

  return 0LL;
}

uint64_t DYMTLIndirectArgumentBufferManager_processCommandBuffer(uint64_t a1, uint64_t a2)
{
  id v121 = *(id *)(a1 + 8);
  uint64_t v3 = (void *)objc_claimAutoreleasedReturnValue([v121 defaultDevice]);
  uint64_t v4 = initializeResourcePatchingTypes(v3, (_BYTE *)&dword_0 + 2);

  unint64_t v128 = qword_5B9DD0 | g_forcePatchingTypeReplaceMask | v4;
  apr_pool_create_ex(&newpool, 0LL, 0LL, v5);
  p = newpool;
  arr = apr_array_make(newpool, 4, 40);
  apr_pool_cleanup_register(p, arr, (apr_status_t (__cdecl *)(void *))DYMTLIABDecodingOp_cleanup, v6);
  if (*(int *)(*(void *)(a2 + 104) + 12LL) >= 1)
  {
    uint64_t v7 = 0LL;
    int8x16_t v134 = (int8x16_t)vdupq_n_s64(0xFFFFFFFFFFFFFFF8LL);
    int64x2_t v136 = vdupq_n_s64(7uLL);
    do
    {
      context = objc_autoreleasePoolPush();
      uint64_t v8 = *(void *)(*(void *)(a2 + 104) + 24LL);
      uint64_t v9 = v8 + 40 * v7;
      uint64_t v10 = (void *)objc_claimAutoreleasedReturnValue([v121 functionForKey:*(void *)(v9 + 24)]);
      id v11 = DEVICEOBJECT(v10);
      uint64_t v12 = (void *)objc_claimAutoreleasedReturnValue(v11);

      uint64_t v13 = *(void *)(v9 + 32);
      id v163 = 0LL;
      id v14 = [v12 newArgumentEncoderWithBufferIndex:v13 reflection:&v163];
      id v15 = v163;
      id v16 = v163;
      __int128 v161 = 0u;
      __int128 v162 = 0u;
      __int128 v159 = 0u;
      __int128 v160 = 0u;
      __int128 v157 = 0u;
      __int128 v155 = 0u;
      __int128 v156 = 0u;
      __int128 v153 = 0u;
      __int128 v154 = 0u;
      __int128 v151 = 0u;
      __int128 v152 = 0u;
      __int128 v158 = 0x38uLL;
      TranslateGTMTLArgument(0LL, v16, &v151, 0LL);
      uint64_t v17 = 0LL;
      int64x2_t v18 = 0uLL;
      do
      {
        int64x2_t v18 = vaddq_s64((int64x2_t)vandq_s8((int8x16_t)vaddq_s64(*(int64x2_t *)((char *)&v151 + v17), v136), v134), v18);
        v17 += 16LL;
      }

      while (v17 != 192);
      int v19 = (char *)apr_palloc(p, vaddvq_s64(v18));
      for (uint64_t i = 0LL; i != 192; i += 8LL)
      {
        else {
          int64_t v21 = 0LL;
        }
        v19 += (*(void *)((char *)&v151 + i) + 7LL) & 0xFFFFFFFFFFFFFFF8LL;
        *(void *)((char *)&v151 + i) = v21;
      }

      uint64_t v22 = v158;
      *(void *)&__int128 v158 = v158 + 56;
      TranslateGTMTLArgument(v22, v16, &v151, 1LL);
      id v23 = *(unsigned __int8 **)(v22 + 8);
      if (!v23) {
        goto LABEL_18;
      }
      int v24 = *v23;
      if (v24 == 1) {
        goto LABEL_19;
      }
      if (v24 == 60 && v23[22] == 1) {
        id v23 = (unsigned __int8 *)*((void *)v23 + 1);
      }
      else {
LABEL_18:
      }
        id v23 = 0LL;
LABEL_19:
      if (GTMTLStructType_requiresPatching((uint64_t)v23, v128))
      {
        uint64_t v25 = apr_array_push(arr);
        uint64_t v26 = (uint64_t)v25;
        *(_OWORD *)uint64_t v25 = *(_OWORD *)(v8 + 40 * v7);
        if (*(_BYTE *)(v22 + 16) || (uint64_t v27 = *(_BYTE **)(v22 + 8)) == 0LL || *v27 != 60) {
          uint64_t v27 = 0LL;
        }
        *((void *)v25 + 2) = v27;
        objc_storeStrong((id *)v25 + 3, v14);
        objc_storeStrong((id *)(v26 + 32), v15);
        if ((dword_5B9DE4 & 0x40) == 0 && arr->nelts >= 2)
        {
          uint64_t v28 = 0LL;
          uint64_t v29 = 0LL;
          while (!DYMTLIABDecodingOp_isEqual((uint64_t)&arr->elts[v28], v26))
          {
            ++v29;
            v28 += 40LL;
            if (v29 >= arr->nelts - 1LL) {
              goto LABEL_33;
            }
          }

          int nelts = arr->nelts;
          if (nelts) {
            arr->int nelts = nelts - 1;
          }
        }
      }

void sub_DE004(_Unwind_Exception *a1)
{
}

uint64_t DYMTLIABDecodingOp_cleanup(uint64_t a1)
{
  if (*(int *)(a1 + 16) >= 1)
  {
    uint64_t v2 = 0LL;
    uint64_t v3 = 24LL;
    do
    {
      uint64_t v4 = *(void *)(a1 + 24);
      uint64_t v5 = *(void **)(v4 + v3);
      *(void *)(v4 + v3) = 0LL;

      ++v2;
      v3 += 40LL;
    }

    while (v2 < *(int *)(a1 + 16));
  }

  return 0LL;
}

BOOL GTMTLStructType_requiresPatching(uint64_t a1, unint64_t a2)
{
  unint64_t v2 = *(unsigned int *)(a1 + 16);
  if ((_DWORD)v2)
  {
    uint64_t v4 = 0LL;
    uint64_t v5 = (unsigned __int8 *)(*(void *)(a1 + 8) + 24LL);
    BOOL v6 = 1;
    do
    {
      uint64_t v7 = *v5;
      if ((_DWORD)v7 == 1)
      {
        if ((GTMTLStructType_requiresPatching(*((void *)v5 - 2)) & 1) != 0) {
          return v6;
        }
      }

      else if ((_DWORD)v7 == 2)
      {
        if ((GTMTLArrayType_requiresPatching(*((void *)v5 - 2), a2) & 1) != 0) {
          return v6;
        }
      }

      else if ((GTMTLDataType_requiresPatching(v7, a2) & 1) != 0)
      {
        return v6;
      }

      BOOL v6 = ++v4 < v2;
      v5 += 32;
    }

    while (v2 != v4);
  }

  else
  {
    return 0;
  }

  return v6;
}

BOOL DYMTLIABDecodingOp_isEqual(uint64_t a1, uint64_t a2)
{
  if (*(void *)a1 != *(void *)a2) {
    return 0LL;
  }
  id v4 = [*(id *)(a1 + 24) encodedLength];
  if (v4 != [*(id *)(a2 + 24) encodedLength]) {
    return 0LL;
  }
  unint64_t v5 = (unint64_t)[*(id *)(a1 + 24) alignment];
  if ((id)v5 != [*(id *)(a2 + 24) alignment] || *(void *)(a1 + 8) % v5 != *(void *)(a2 + 8) % v5) {
    return 0LL;
  }
  uint64_t v6 = *(void *)(a1 + 16);
  if (*(_BYTE *)(v6 + 22) == 1) {
    uint64_t v7 = *(void *)(v6 + 8);
  }
  else {
    uint64_t v7 = 0LL;
  }
  uint64_t v9 = *(void *)(a2 + 16);
  if (*(_BYTE *)(v9 + 22) == 1) {
    uint64_t v10 = *(void *)(v9 + 8);
  }
  else {
    uint64_t v10 = 0LL;
  }
  return GTMTLStructType_isEqual(v7, v10);
}

void *GTMTLStructType_fillArgumentIndicesRequiresPatching( void *result, uint64_t a2, uint64_t a3, apr_array_header_t *a4, unint64_t a5)
{
  if (*((_DWORD *)result + 4))
  {
    uint64_t v8 = result;
    uint64_t v9 = 0LL;
    unint64_t v10 = 0LL;
    do
    {
      uint64_t v11 = v8[1];
      uint64_t v12 = v11 + v9;
      uint64_t v13 = *(unsigned __int16 *)(v11 + v9 + 22) + a2;
      uint64_t v14 = *(unsigned int *)(v11 + v9 + 16) + a3;
      int v15 = *(unsigned __int8 *)(v11 + v9 + 24);
      if (v15 == 2)
      {
        BOOL result = (void *)GTMTLArrayType_fillArgumentIndicesRequiresPatching( *(void *)(v12 + 8),  *(unsigned __int16 *)(v11 + v9 + 22) + a2,  v14,  a4,  a5);
      }

      else if (v15 == 1)
      {
        BOOL result = (void *)GTMTLStructType_fillArgumentIndicesRequiresPatching( *(void *)(v11 + v9 + 8),  *(unsigned __int16 *)(v11 + v9 + 22) + a2,  v14,  a4,  a5);
      }

      else
      {
        BOOL result = (void *)GTMTLDataType_requiresPatching(*(unsigned __int8 *)(v11 + v9 + 24), a5);
        if ((_DWORD)result)
        {
          if (v15 == 60) {
            uint64_t v16 = *(void *)(v11 + v9 + 8);
          }
          else {
            uint64_t v16 = 0LL;
          }
          BOOL result = apr_array_push(a4);
          uint64_t v17 = result;
          char *result = *(unsigned __int8 *)(v12 + 24);
          result[1] = v13;
          result[2] = *(unsigned int *)(v12 + 16);
          if (v16)
          {
            BOOL result = (void *)GTMTLPointerType_requiresPatching(v16, a5);
            if ((_DWORD)result) {
              uint64_t v18 = v16;
            }
            else {
              uint64_t v18 = 0LL;
            }
          }

          else
          {
            uint64_t v18 = 0LL;
          }

          v17[3] = v18;
        }
      }

      ++v10;
      v9 += 32LL;
    }

    while (v10 < *((unsigned int *)v8 + 4));
  }

  return result;
}

void reencodeBufferDataTier2( void *a1, void *a2, void *a3, uint64_t a4, void *a5, uint64_t a6, __int128 *a7, void *a8)
{
  id v89 = a2;
  id v14 = a3;
  id v88 = a5;
  id v85 = a8;
  uint64_t v15 = a1[3];
  if (*(int *)(v15 + 12) >= 1)
  {
    uint64_t v16 = 0LL;
    uint64_t v17 = 0LL;
    uint64_t v86 = a4;
    do
    {
      uint64_t v18 = (uint64_t *)(*(void *)(v15 + 24) + v16);
      uint64_t v19 = *v18;
      uint64_t v20 = v18[2];
      *((void *)a7 + 2) = v18[1];
      if (v19 > 79)
      {
        if (v19 > 116)
        {
          id v32 = *(id *)((char *)[v14 contents] + v20 + a4);
          uint64_t v44 = a1[4];
          __int128 v90 = *a7;
          uint64_t v91 = *((void *)a7 + 2);
          entry = find_entry(v44, &v90, 0x18uLL, 0LL);
          if (*entry)
          {
            uint64_t v46 = *(void *)(*entry + 32LL);
            if (v46)
            {
              if (*(id *)(v46 + 24) == v32) {
                goto LABEL_77;
              }
            }
          }

          uint64_t v36 = *(void *)(a1[1] + 64LL);
        }

        else
        {
          if (v19 == 80)
          {
            id v32 = *(id *)((char *)[v14 contents] + v20 + a4);
            uint64_t v64 = a1[4];
            __int128 v90 = *a7;
            uint64_t v91 = *((void *)a7 + 2);
            uint64_t v65 = find_entry(v64, &v90, 0x18uLL, 0LL);
            if (*v65)
            {
              uint64_t v66 = *(void *)(*v65 + 32LL);
              if (v66)
              {
                if (*(id *)(v66 + 24) == v32) {
                  goto LABEL_77;
                }
              }
            }

            uint64_t v67 = *(void *)(a1[1] + 40LL);
            *(void *)&__int128 v90 = v32;
            int v68 = find_entry(v67, &v90, 8uLL, 0LL);
            if (!*v68) {
              goto LABEL_77;
            }
            uint64_t v69 = *(void *)(*v68 + 32LL);
            if (!v69) {
              goto LABEL_77;
            }
            uint64_t v43 = (void *)objc_claimAutoreleasedReturnValue([v89 indirectCommandBufferForKey:*(void *)(v69 + 8)]);
            goto LABEL_73;
          }

          if (v19 == 115)
          {
            id v32 = *(id *)((char *)[v14 contents] + v20 + a4);
            uint64_t v70 = a1[4];
            __int128 v90 = *a7;
            uint64_t v91 = *((void *)a7 + 2);
            uint64_t v71 = find_entry(v70, &v90, 0x18uLL, 0LL);
            if (*v71)
            {
              uint64_t v72 = *(void *)(*v71 + 32LL);
              if (v72)
              {
                if (*(id *)(v72 + 24) == v32) {
                  goto LABEL_77;
                }
              }
            }

            uint64_t v73 = *(void *)(a1[1] + 48LL);
            *(void *)&__int128 v90 = v32;
            int v74 = find_entry(v73, &v90, 8uLL, 0LL);
            if (!*v74) {
              goto LABEL_77;
            }
            uint64_t v75 = *(void *)(*v74 + 32LL);
            if (!v75) {
              goto LABEL_77;
            }
            uint64_t v43 = (void *)objc_claimAutoreleasedReturnValue([v89 visibleFunctionTableForKey:*(void *)(v75 + 8)]);
            goto LABEL_73;
          }

          if (v19 != 116) {
            goto LABEL_77;
          }
          id v32 = *(id *)((char *)[v14 contents] + v20 + a4);
          uint64_t v33 = a1[4];
          __int128 v90 = *a7;
          uint64_t v91 = *((void *)a7 + 2);
          uint64_t v34 = find_entry(v33, &v90, 0x18uLL, 0LL);
          if (*v34)
          {
            uint64_t v35 = *(void *)(*v34 + 32LL);
            if (v35)
            {
              if (*(id *)(v35 + 24) == v32) {
                goto LABEL_77;
              }
            }
          }

          uint64_t v36 = *(void *)(a1[1] + 56LL);
        }

        *(void *)&__int128 v90 = v32;
        id v47 = find_entry(v36, &v90, 8uLL, 0LL);
        if (!*v47) {
          goto LABEL_77;
        }
        uint64_t v48 = *(void *)(*v47 + 32LL);
        if (!v48) {
          goto LABEL_77;
        }
        uint64_t v43 = (void *)objc_claimAutoreleasedReturnValue([v89 intersectionFunctionTableForKey:*(void *)(v48 + 8)]);
      }

      else if (v19 <= 59)
      {
        if (v19 == 58)
        {
          id v32 = *(id *)((char *)[v14 contents] + v20 + a4);
          uint64_t v76 = a1[4];
          __int128 v90 = *a7;
          uint64_t v91 = *((void *)a7 + 2);
          uint64_t v77 = find_entry(v76, &v90, 0x18uLL, 0LL);
          if (*v77)
          {
            uint64_t v78 = *(void *)(*v77 + 32LL);
            if (v78)
            {
              if (*(id *)(v78 + 24) == v32) {
                goto LABEL_77;
              }
            }
          }

          uint64_t v79 = *(void *)(a1[1] + 8LL);
          *(void *)&__int128 v90 = v32;
          unint64_t v80 = find_entry(v79, &v90, 8uLL, 0LL);
          if (!*v80) {
            goto LABEL_77;
          }
          uint64_t v81 = *(void *)(*v80 + 32LL);
          if (!v81) {
            goto LABEL_77;
          }
          uint64_t v43 = (void *)objc_claimAutoreleasedReturnValue([v89 textureForKey:*(void *)(v81 + 8)]);
        }

        else
        {
          if (v19 != 59) {
            goto LABEL_77;
          }
          id v32 = *(id *)((char *)[v14 contents] + v20 + a4);
          uint64_t v37 = a1[4];
          __int128 v90 = *a7;
          uint64_t v91 = *((void *)a7 + 2);
          uint64_t v38 = find_entry(v37, &v90, 0x18uLL, 0LL);
          if (*v38)
          {
            uint64_t v39 = *(void *)(*v38 + 32LL);
            if (v39)
            {
              if (*(id *)(v39 + 24) == v32) {
                goto LABEL_77;
              }
            }
          }

          uint64_t v40 = *(void *)(a1[1] + 16LL);
          *(void *)&__int128 v90 = v32;
          int v41 = find_entry(v40, &v90, 8uLL, 0LL);
          if (!*v41) {
            goto LABEL_77;
          }
          uint64_t v42 = *(void *)(*v41 + 32LL);
          if (!v42) {
            goto LABEL_77;
          }
          uint64_t v43 = (void *)objc_claimAutoreleasedReturnValue([v89 samplerStateForKey:*(void *)(v42 + 8)]);
        }
      }

      else
      {
        if (v19 == 60)
        {
          unint64_t v21 = *(void *)((char *)[v14 contents] + v20 + a4);
          uint64_t v49 = a1[4];
          __int128 v90 = *a7;
          uint64_t v91 = *((void *)a7 + 2);
          char v50 = find_entry(v49, &v90, 0x18uLL, 0LL);
          if (*v50)
          {
            uint64_t v51 = *(void *)(*v50 + 32LL);
            if (v51)
            {
              if (*(void *)(v51 + 24) == v21) {
                goto LABEL_77;
              }
            }
          }

          uint64_t v52 = GTMTLGPUAddressResource_resourceForGPUAddress( *(void **)(*(void *)a1[1] + 24LL),  *(int *)(*(void *)a1[1] + 12LL),  v21);
          if (!v52 || !v52[2]) {
            goto LABEL_77;
          }
          unint64_t v53 = v21 - *v52;
          int64_t v54 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v89, "bufferForKey:"));
          id v55 = DEVICEOBJECT(v54);
          id v30 = (void *)objc_claimAutoreleasedReturnValue(v55);

          id v31 = (char *)[v30 gpuAddress] + v53;
          goto LABEL_46;
        }

        if (v19 != 78)
        {
          if (v19 != 79) {
            goto LABEL_77;
          }
          if ((GT_SUPPORT_0 & 0x10) == 0) {
            goto LABEL_77;
          }
          unint64_t v21 = *(void *)((char *)[v14 contents] + v20 + a4);
          uint64_t v22 = a1[4];
          __int128 v90 = *a7;
          uint64_t v91 = *((void *)a7 + 2);
          id v23 = find_entry(v22, &v90, 0x18uLL, 0LL);
          if (*v23)
          {
            uint64_t v24 = *(void *)(*v23 + 32LL);
            if (v24)
            {
              if (*(void *)(v24 + 24) == v21) {
                goto LABEL_77;
              }
            }
          }

          uint64_t v25 = *(void *)(a1[1] + 32LL);
          *(void *)&__int128 v90 = v21;
          uint64_t v26 = find_entry(v25, &v90, 8uLL, 0LL);
          if (!*v26) {
            goto LABEL_77;
          }
          uint64_t v27 = *(void *)(*v26 + 32LL);
          if (!v27 || !*(void *)(v27 + 8)) {
            goto LABEL_77;
          }
          uint64_t v28 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v89, "computePipelineStateForKey:"));
          id v29 = DEVICEOBJECT(v28);
          id v30 = (void *)objc_claimAutoreleasedReturnValue(v29);

          id v31 = (char *)[v30 gpuResourceID];
LABEL_46:
          *(void *)((char *)[v88 contents] + v20 + a6) = v31;
          if ((char *)v21 != v31)
          {
            id v56 = (apr_pool_t **)a1[4];
            __int128 v90 = *a7;
            uint64_t v91 = *((void *)a7 + 2);
            uint64_t v57 = (uint64_t)v31;
LABEL_75:
            StoreArgumentIndexReencoding(v56, (uint64_t)&v90, v57);
            goto LABEL_76;
          }

          goto LABEL_76;
        }

        id v32 = *(id *)((char *)[v14 contents] + v20 + a4);
        uint64_t v58 = a1[4];
        __int128 v90 = *a7;
        uint64_t v91 = *((void *)a7 + 2);
        id v59 = find_entry(v58, &v90, 0x18uLL, 0LL);
        if (*v59)
        {
          uint64_t v60 = *(void *)(*v59 + 32LL);
          if (v60)
          {
            if (*(id *)(v60 + 24) == v32) {
              goto LABEL_77;
            }
          }
        }

        uint64_t v61 = *(void *)(a1[1] + 24LL);
        *(void *)&__int128 v90 = v32;
        uint64_t v62 = find_entry(v61, &v90, 8uLL, 0LL);
        if (!*v62) {
          goto LABEL_77;
        }
        uint64_t v63 = *(void *)(*v62 + 32LL);
        if (!v63 || !*(void *)(v63 + 8)) {
          goto LABEL_77;
        }
        uint64_t v43 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v89, "renderPipelineStateForKey:"));
      }

LABEL_76:
      a4 = v86;
LABEL_77:
      ++v17;
      uint64_t v15 = a1[3];
      v16 += 32LL;
    }

    while (v17 < *(int *)(v15 + 12));
  }
}

LABEL_98:
            goto LABEL_99;
          }

          if (v132)
          {
            int8x16_t v134 = (__CFString *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @": '%s'",  v132));
            goto LABEL_147;
          }

void reencodeBufferData(uint64_t a1, void *a2, void *a3, uint64_t a4, void *a5, __int128 *a6)
{
  id v11 = a2;
  id v12 = a3;
  id v107 = a5;
  uint64_t v108 = (void *)objc_claimAutoreleasedReturnValue([v107 layout]);
  uint64_t v13 = *(void *)(a1 + 24);
  if (*(int *)(v13 + 12) >= 1)
  {
    uint64_t v14 = 0LL;
    id v105 = v11;
    id v106 = v12;
    uint64_t v104 = a4;
    do
    {
      uint64_t v15 = (uint64_t *)(*(void *)(v13 + 24) + 32 * v14);
      uint64_t v16 = *v15;
      uint64_t v17 = v15[1];
      uint64_t v18 = v15[3];
      *((void *)a6 + 2) = v17;
      if (v16 > 78)
      {
        switch(v16)
        {
          case 's':
            id v19 = [v108 uniqueIdentifierForVisibleFunctionTableAtIndex:v17 inIndirectArgumentBuffer:v12 atOffset:a4];
            uint64_t v29 = *(void *)(a1 + 32);
            __int128 v109 = *a6;
            uint64_t v110 = *((void *)a6 + 2);
            entry = find_entry(v29, &v109, 0x18uLL, 0LL);
            if (!*entry || (uint64_t v31 = *(void *)(*entry + 32LL)) == 0 || *(id *)(v31 + 24) != v19)
            {
              uint64_t v32 = *(void *)(*(void *)(a1 + 8) + 48LL);
              *(void *)&__int128 v109 = v19;
              uint64_t v33 = find_entry(v32, &v109, 8uLL, 0LL);
              if (*v33)
              {
                uint64_t v34 = *(void *)(*v33 + 32LL);
                if (v34)
                {
                  uint64_t v35 = (void *)objc_claimAutoreleasedReturnValue([v11 visibleFunctionTableForKey:*(void *)(v34 + 8)]);
                  id v36 = DEVICEOBJECT(v35);
                  uint64_t v28 = (void *)objc_claimAutoreleasedReturnValue(v36);

                  [v107 setVisibleFunctionTable:v28 atIndex:v17];
                  goto LABEL_75;
                }
              }
            }

            goto LABEL_78;
          case 't':
            id v19 = [v108 uniqueIdentifierForIntersectionFunctionTableAtIndex:v17 inIndirectArgumentBuffer:v12 atOffset:a4];
            uint64_t v76 = *(void *)(a1 + 32);
            __int128 v109 = *a6;
            uint64_t v110 = *((void *)a6 + 2);
            uint64_t v77 = find_entry(v76, &v109, 0x18uLL, 0LL);
            if (!*v77 || (uint64_t v78 = *(void *)(*v77 + 32LL)) == 0 || *(id *)(v78 + 24) != v19)
            {
              uint64_t v79 = *(void *)(*(void *)(a1 + 8) + 56LL);
              *(void *)&__int128 v109 = v19;
              unint64_t v80 = find_entry(v79, &v109, 8uLL, 0LL);
              if (*v80)
              {
                uint64_t v81 = *(void *)(*v80 + 32LL);
                if (v81)
                {
                  unint64_t v82 = (void *)objc_claimAutoreleasedReturnValue([v11 intersectionFunctionTableForKey:*(void *)(v81 + 8)]);
                  id v83 = DEVICEOBJECT(v82);
                  uint64_t v28 = (void *)objc_claimAutoreleasedReturnValue(v83);

                  [v107 setIntersectionFunctionTable:v28 atIndex:v17];
                  goto LABEL_75;
                }
              }
            }

            goto LABEL_78;
          case 'u':
            id v84 = [v108 uniqueIdentifierForPrimitiveAccelerationStructureAtIndex:v17 inIndirectArgumentBuffer:v12 atOffset:a4];
            goto LABEL_63;
          case 'v':
            id v84 = [v108 uniqueIdentifierForInstanceAccelerationStructureAtIndex:v17 inIndirectArgumentBuffer:v12 atOffset:a4];
LABEL_63:
            id v19 = v84;
            uint64_t v85 = *(void *)(a1 + 32);
            __int128 v109 = *a6;
            uint64_t v110 = *((void *)a6 + 2);
            uint64_t v86 = find_entry(v85, &v109, 0x18uLL, 0LL);
            if (*v86)
            {
              uint64_t v87 = *(void *)(*v86 + 32LL);
              if (v87)
              {
                if (*(id *)(v87 + 24) == v19) {
                  goto LABEL_78;
                }
              }
            }

            uint64_t v88 = *(void *)(*(void *)(a1 + 8) + 64LL);
            *(void *)&__int128 v109 = v19;
            id v89 = find_entry(v88, &v109, 8uLL, 0LL);
            if (!*v89) {
              goto LABEL_78;
            }
            uint64_t v90 = *(void *)(*v89 + 32LL);
            if (!v90) {
              goto LABEL_78;
            }
            uint64_t v91 = (void *)objc_claimAutoreleasedReturnValue([v11 intersectionFunctionTableForKey:*(void *)(v90 + 8)]);
            id v92 = DEVICEOBJECT(v91);
            uint64_t v28 = (void *)objc_claimAutoreleasedReturnValue(v92);

            [v107 setAccelerationStructure:v28 atIndex:v17];
            goto LABEL_75;
          default:
            if (v16 == 79)
            {
              if ((GT_SUPPORT_0 & 0x10) != 0)
              {
                id v19 = [v108 uniqueIdentifierForComputePipelineAtIndex:v17 inIndirectArgumentBuffer:v12 atOffset:a4];
                uint64_t v93 = *(void *)(a1 + 32);
                __int128 v109 = *a6;
                uint64_t v110 = *((void *)a6 + 2);
                id v94 = find_entry(v93, &v109, 0x18uLL, 0LL);
                if (!*v94 || (uint64_t v95 = *(void *)(*v94 + 32LL)) == 0 || *(id *)(v95 + 24) != v19)
                {
                  uint64_t v96 = GTMTLIndirectResources_renderPipelineIdForUniqueIdentifier( *(void *)(*(void *)(a1 + 8) + 32LL),  (uint64_t)v19);
                  if (v96)
                  {
                    uint64_t v97 = (void *)objc_claimAutoreleasedReturnValue([v11 computePipelineStateForKey:v96]);
                    id v98 = DEVICEOBJECT(v97);
                    uint64_t v28 = (void *)objc_claimAutoreleasedReturnValue(v98);

                    [v107 setComputePipelineState:v28 atIndex:v17];
                    goto LABEL_75;
                  }
                }
              }
            }

            else if (v16 == 80)
            {
              id v19 = [v108 uniqueIdentifierForIndirectCommandBufferAtIndex:v17 inIndirectArgumentBuffer:v12 atOffset:a4];
              uint64_t v43 = *(void *)(a1 + 32);
              __int128 v109 = *a6;
              uint64_t v110 = *((void *)a6 + 2);
              uint64_t v44 = find_entry(v43, &v109, 0x18uLL, 0LL);
              if (!*v44 || (uint64_t v45 = *(void *)(*v44 + 32LL)) == 0 || *(id *)(v45 + 24) != v19)
              {
                uint64_t v46 = *(void *)(*(void *)(a1 + 8) + 40LL);
                *(void *)&__int128 v109 = v19;
                id v47 = find_entry(v46, &v109, 8uLL, 0LL);
                if (*v47)
                {
                  uint64_t v48 = *(void *)(*v47 + 32LL);
                  if (v48)
                  {
                    uint64_t v49 = (void *)objc_claimAutoreleasedReturnValue([v11 indirectCommandBufferForKey:*(void *)(v48 + 8)]);
                    id v50 = DEVICEOBJECT(v49);
                    uint64_t v28 = (void *)objc_claimAutoreleasedReturnValue(v50);

                    [v107 setIndirectCommandBuffer:v28 atIndex:v17];
                    goto LABEL_75;
                  }
                }
              }
            }

            break;
        }

        goto LABEL_78;
      }

      if (v16 > 59)
      {
        if (v16 == 60)
        {
          id v59 = (char *)[v108 virtualAddressForBufferAtIndex:v17 inIndirectArgumentBuffer:v12 atOffset:a4];
          uint64_t v60 = *(void *)(a1 + 32);
          __int128 v109 = *a6;
          uint64_t v110 = *((void *)a6 + 2);
          uint64_t v61 = find_entry(v60, &v109, 0x18uLL, 0LL);
          if (*v61)
          {
            uint64_t v62 = *(void *)(*v61 + 32LL);
            if (v62)
            {
            }
          }

          uint64_t v63 = GTMTLGPUAddressResource_resourceForGPUAddress( *(void **)(**(void **)(a1 + 8) + 24LL),  *(int *)(**(void **)(a1 + 8) + 12LL),  (unint64_t)v59);
          if (!v63) {
            goto LABEL_78;
          }
          uint64_t v64 = v63[2];
          if (!v64) {
            goto LABEL_78;
          }
          uint64_t v65 = &v59[-*v63];
          uint64_t v66 = (void *)objc_claimAutoreleasedReturnValue([v11 bufferForKey:v64]);
          id v67 = DEVICEOBJECT(v66);
          uint64_t v28 = (void *)objc_claimAutoreleasedReturnValue(v67);

          [v107 setBuffer:v28 offset:v65 atIndex:v17];
          int v68 = &v65[(void)[v28 gpuAddress]];
          if (v68 != v59)
          {
            uint64_t v69 = *(apr_pool_t ***)(a1 + 32);
            __int128 v109 = *a6;
            uint64_t v110 = *((void *)a6 + 2);
            StoreArgumentIndexReencoding(v69, (uint64_t)&v109, (uint64_t)v68);
          }

          id v11 = v105;
          if (!v18) {
            goto LABEL_80;
          }
          if ((GT_SUPPORT_0 & 0x2000) == 0) {
            goto LABEL_80;
          }
          uint64_t v70 = apr_array_push(*(apr_array_header_t **)(a1 + 16));
          *uint64_t v70 = v64;
          v70[1] = v65;
          v70[2] = v18;
          id v71 = [v107 newArgumentEncoderForBufferAtIndex:v17];
          uint64_t v72 = (void *)v70[3];
          v70[3] = v71;

          uint64_t v73 = *(void *)(a1 + 16);
          if (*(int *)(v73 + 12) >= 2)
          {
            uint64_t v74 = 0LL;
            uint64_t v75 = 0LL;
            a4 = v104;
            while (!DYMTLIABDecodingOp_isEqual(*(void *)(v73 + 24) + v74, (uint64_t)v70))
            {
              ++v75;
              uint64_t v73 = *(void *)(a1 + 16);
              v74 += 40LL;
              if (v75 >= *(int *)(v73 + 12) - 1LL)
              {
                id v11 = v105;
                goto LABEL_77;
              }
            }

            uint64_t v102 = *(void *)(a1 + 16);
            id v11 = v105;
            if (v102)
            {
              int v103 = *(_DWORD *)(v102 + 12);
              if (v103) {
                *(_DWORD *)(v102 + 12) = v103 - 1;
              }
            }
          }

          else
          {
LABEL_80:
            a4 = v104;
          }

          goto LABEL_77;
        }

        if (v16 != 78) {
          goto LABEL_78;
        }
        id v19 = [v108 uniqueIdentifierForRenderPipelineAtIndex:v17 inIndirectArgumentBuffer:v12 atOffset:a4];
        uint64_t v37 = *(void *)(a1 + 32);
        __int128 v109 = *a6;
        uint64_t v110 = *((void *)a6 + 2);
        uint64_t v38 = find_entry(v37, &v109, 0x18uLL, 0LL);
        if (*v38)
        {
          uint64_t v39 = *(void *)(*v38 + 32LL);
          if (v39)
          {
            if (*(id *)(v39 + 24) == v19) {
              goto LABEL_78;
            }
          }
        }

        uint64_t v40 = GTMTLIndirectResources_renderPipelineIdForUniqueIdentifier( *(void *)(*(void *)(a1 + 8) + 24LL),  (uint64_t)v19);
        if (!v40) {
          goto LABEL_78;
        }
        int v41 = (void *)objc_claimAutoreleasedReturnValue([v11 renderPipelineStateForKey:v40]);
        id v42 = DEVICEOBJECT(v41);
        uint64_t v28 = (void *)objc_claimAutoreleasedReturnValue(v42);

        [v107 setRenderPipelineState:v28 atIndex:v17];
      }

      else if (v16 == 58)
      {
        id v19 = [v108 uniqueIdentifierForTextureAtIndex:v17 inIndirectArgumentBuffer:v12 atOffset:a4];
        uint64_t v51 = *(void *)(a1 + 32);
        __int128 v109 = *a6;
        uint64_t v110 = *((void *)a6 + 2);
        uint64_t v52 = find_entry(v51, &v109, 0x18uLL, 0LL);
        if (*v52)
        {
          uint64_t v53 = *(void *)(*v52 + 32LL);
          if (v53)
          {
            if (*(id *)(v53 + 24) == v19) {
              goto LABEL_78;
            }
          }
        }

        uint64_t v54 = *(void *)(*(void *)(a1 + 8) + 8LL);
        *(void *)&__int128 v109 = v19;
        id v55 = find_entry(v54, &v109, 8uLL, 0LL);
        if (!*v55) {
          goto LABEL_78;
        }
        uint64_t v56 = *(void *)(*v55 + 32LL);
        if (!v56) {
          goto LABEL_78;
        }
        uint64_t v57 = (void *)objc_claimAutoreleasedReturnValue([v11 textureForKey:*(void *)(v56 + 8)]);
        id v58 = DEVICEOBJECT(v57);
        uint64_t v28 = (void *)objc_claimAutoreleasedReturnValue(v58);

        [v107 setTexture:v28 atIndex:v17];
      }

      else
      {
        if (v16 != 59) {
          goto LABEL_78;
        }
        id v19 = [v108 uniqueIdentifierForSamplerAtIndex:v17 inIndirectArgumentBuffer:v12 atOffset:a4];
        uint64_t v20 = *(void *)(a1 + 32);
        __int128 v109 = *a6;
        uint64_t v110 = *((void *)a6 + 2);
        unint64_t v21 = find_entry(v20, &v109, 0x18uLL, 0LL);
        if (*v21)
        {
          uint64_t v22 = *(void *)(*v21 + 32LL);
          if (v22)
          {
            if (*(id *)(v22 + 24) == v19) {
              goto LABEL_78;
            }
          }
        }

        uint64_t v23 = *(void *)(*(void *)(a1 + 8) + 16LL);
        *(void *)&__int128 v109 = v19;
        uint64_t v24 = find_entry(v23, &v109, 8uLL, 0LL);
        if (!*v24) {
          goto LABEL_78;
        }
        uint64_t v25 = *(void *)(*v24 + 32LL);
        if (!v25) {
          goto LABEL_78;
        }
        uint64_t v26 = (void *)objc_claimAutoreleasedReturnValue([v11 samplerStateForKey:*(void *)(v25 + 8)]);
        id v27 = DEVICEOBJECT(v26);
        uint64_t v28 = (void *)objc_claimAutoreleasedReturnValue(v27);

        [v107 setSamplerState:v28 atIndex:v17];
      }

LABEL_77:
      id v12 = v106;
LABEL_78:
      ++v14;
      uint64_t v13 = *(void *)(a1 + 24);
    }

    while (v14 < *(int *)(v13 + 12));
  }
}

    if ((v16 & (v16 - 1)) != 0)
    {
      if (v8 >= v16) {
        uint64_t v3 = v8 % v16;
      }
      else {
        uint64_t v3 = v8;
      }
    }

    else
    {
      uint64_t v3 = (v16 - 1) & v8;
    }
  }

  uint64_t v39 = self->_stringCache.__table_.__bucket_list_.__ptr_.__value_;
  uint64_t v40 = (void **)v39[v3];
  if (v40)
  {
    *uint64_t j = *v40;
  }

  else
  {
    *uint64_t j = self->_stringCache.__table_.__p1_.__value_.__next_;
    self->_stringCache.__table_.__p1_.__value_.__next_ = j;
    v39[v3] = &self->_stringCache.__table_.__p1_;
    if (!*j) {
      goto LABEL_91;
    }
    int v41 = *(void *)(*j + 8LL);
    if ((v16 & (v16 - 1)) != 0)
    {
      if (v41 >= v16) {
        v41 %= v16;
      }
    }

    else
    {
      v41 &= v16 - 1;
    }

    uint64_t v40 = &self->_stringCache.__table_.__bucket_list_.__ptr_.__value_[v41];
  }

  *uint64_t v40 = j;
LABEL_91:
  ++self->_stringCache.__table_.__p2_.__value_;
LABEL_92:
  j[3] = v12;
  return v12;
}

void StoreArgumentIndexReencoding(apr_pool_t **a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = *find_entry((uint64_t)a1, (_BYTE *)a2, 0x18uLL, 0LL);
  if (!v6 || (uint64_t v7 = *(void **)(v6 + 32)) == 0LL)
  {
    uint64_t v7 = apr_palloc(*a1, 0x20uLL);
    uint64_t v8 = *(void *)(a2 + 16);
    *(_OWORD *)uint64_t v7 = *(_OWORD *)a2;
    v7[2] = v8;
    apr_hash_set((apr_hash_t *)a1, v7, 24LL, v7);
  }

  v7[3] = a3;
}

uint64_t GTMTLArrayType_fillArgumentIndicesRequiresPatching( uint64_t result, uint64_t a2, uint64_t a3, apr_array_header_t *a4, unint64_t a5)
{
  uint64_t v9 = result;
  uint64_t v10 = *(unsigned __int8 *)(result + 24);
  int v11 = *(unsigned __int16 *)(result + 20);
  uint64_t v12 = *(unsigned __int16 *)(result + 22);
  if ((_DWORD)v10 == 1)
  {
    if (*(_WORD *)(result + 20))
    {
      do
      {
        if (*(_BYTE *)(v9 + 24) == 1) {
          uint64_t v14 = *(void *)(v9 + 8);
        }
        else {
          uint64_t v14 = 0LL;
        }
        BOOL result = GTMTLStructType_fillArgumentIndicesRequiresPatching(v14, a2, a3, a4, a5);
        a2 += v12;
        a3 += *(unsigned int *)(v9 + 16);
        --v11;
      }

      while (v11);
    }
  }

  else if ((_DWORD)v10 == 2)
  {
    if (*(_WORD *)(result + 20))
    {
      do
      {
        if (*(_BYTE *)(v9 + 24) == 2) {
          uint64_t v13 = *(void *)(v9 + 8);
        }
        else {
          uint64_t v13 = 0LL;
        }
        BOOL result = GTMTLArrayType_fillArgumentIndicesRequiresPatching(v13, a2, a3, a4, a5);
        a2 += v12;
        a3 += *(unsigned int *)(v9 + 16);
        --v11;
      }

      while (v11);
    }
  }

  else
  {
    BOOL result = GTMTLDataType_requiresPatching(*(unsigned __int8 *)(result + 24), a5);
    if ((_DWORD)result)
    {
      if ((_DWORD)v10 == 60 && (uint64_t v15 = *(void *)(v9 + 8)) != 0)
      {
        BOOL result = GTMTLPointerType_requiresPatching(*(void *)(v9 + 8), a5);
        uint64_t v16 = (_DWORD)result ? v15 : 0LL;
      }

      else
      {
        uint64_t v16 = 0LL;
      }

      for (; v11; --v11)
      {
        BOOL result = (uint64_t)apr_array_push(a4);
        *(void *)BOOL result = v10;
        *(void *)(result + _Block_object_dispose((const void *)(v12 - 64), 8) = a2;
        *(void *)(result + 16) = a3;
        *(void *)(result + 24) = v16;
        a2 += v12;
        a3 += *(unsigned int *)(v9 + 16);
      }
    }
  }

  return result;
}

uint64_t GTMTLDataType_requiresPatching(uint64_t a1, unint64_t a2)
{
  if (a1 > 79)
  {
    switch(a1)
    {
      case 's':
        uint64_t result = (a2 >> 6) & 1;
        break;
      case 't':
        uint64_t result = (a2 >> 7) & 1;
        break;
      case 'u':
      case 'v':
        uint64_t result = (a2 >> 8) & 1;
        break;
      default:
        if (a1 == 80) {
          uint64_t result = (a2 >> 5) & 1;
        }
        else {
          uint64_t result = 0LL;
        }
        break;
    }
  }

  else
  {
    unsigned int v2 = a2 & 1;
    uint64_t v3 = (a2 >> 1) & 1;
    uint64_t v4 = (a2 >> 3) & 1;
    if (a1 != 60) {
      LODWORD(v4) = 0;
    }
    if (a1 != 59) {
      LODWORD(v3) = v4;
    }
    if (a1 != 58) {
      unsigned int v2 = v3;
    }
    if (a1 <= 77) {
      return v2;
    }
    else {
      return (a2 >> 4) & 1;
    }
  }

  return result;
}

uint64_t GTMTLPointerType_requiresPatching(uint64_t a1, unint64_t a2)
{
  int v2 = *(unsigned __int8 *)(a1 + 22);
  if (v2 == 2) {
    return GTMTLArrayType_requiresPatching(*(void *)(a1 + 8), a2);
  }
  if (v2 == 1) {
    return GTMTLStructType_requiresPatching(*(void *)(a1 + 8), a2);
  }
  return GTMTLDataType_requiresPatching(*(unsigned __int8 *)(a1 + 22), a2);
}

uint64_t GTMTLArrayType_requiresPatching(uint64_t a1, unint64_t a2)
{
  while (1)
  {
    int v2 = *(unsigned __int8 *)(a1 + 24);
    if (v2 != 2) {
      break;
    }
    a1 = *(void *)(a1 + 8);
  }

  if (v2 == 1) {
    return GTMTLStructType_requiresPatching(*(void *)(a1 + 8));
  }
  else {
    return GTMTLDataType_requiresPatching(*(unsigned __int8 *)(a1 + 24), a2);
  }
}

BOOL GTMTLStructType_isEqual(uint64_t a1, uint64_t a2)
{
  unint64_t v2 = *(unsigned int *)(a1 + 16);
  if ((_DWORD)v2 == *(_DWORD *)(a2 + 16))
  {
    if ((_DWORD)v2)
    {
      uint64_t v3 = 0LL;
      BOOL v4 = 0;
      uint64_t v5 = *(void *)(a1 + 8);
      uint64_t v6 = *(void *)(a2 + 8);
      do
      {
        uint64_t v7 = v5 + 32 * v3;
        uint64_t v8 = v6 + 32 * v3;
        if (*(_DWORD *)(v7 + 16) != *(_DWORD *)(v8 + 16)) {
          break;
        }
        int v9 = *(unsigned __int8 *)(v7 + 24);
        if (v9 == 1)
        {
        }

        else if (v9 == 2)
        {
          uint64_t v10 = *(void *)(v5 + 32 * v3 + 8);
          uint64_t v11 = v6 + 32 * v3;
          while (1)
          {
            uint64_t v11 = *(void *)(v11 + 8);
            int v12 = *(unsigned __int8 *)(v10 + 24);
            if (v12 != 2)
            {
              if (v12 != 1 || (GTMTLStructType_isEqual(*(void *)(v10 + 8), *(void *)(v11 + 8)) & 1) != 0) {
                break;
              }
              return v4;
            }

            uint64_t v10 = *(void *)(v10 + 8);
          }
        }

        BOOL v4 = ++v3 >= v2;
      }

      while (v3 != v2);
    }

    else
    {
      return 1;
    }
  }

  else
  {
    return 0;
  }

  return v4;
}

char *DYMTLIndirectArgumentBufferManager_decodeArgumentBuffer( uint64_t a1, unint64_t a2, apr_pool_t *a3)
{
  BOOL v4 = (uint64_t **)a1;
  uint64_t v5 = (unsigned int *)(a1 + 22480);
  id v224 = *(id *)(a1 + 8);
  uint64_t v6 = *v4;
  uint64_t v7 = *(void *)(v6[15] + 24)
     + (*GroupBuilder_getCommandBuffer(*(_DWORD *)((*v4)[14] + 12), *(void **)((*v4)[14] + 24), *v5) << 6);
  *(void *)__dst = *((void *)GTTraceFunc_argumentBytesWithMap((void *)v7, *(unsigned __int8 *)(v7 + 13), v6[2]) + 1);
  uint64_t v8 = *find_entry(v6[18], __dst, 8uLL, 0LL);
  id v243 = v5;
  if (v8) {
    uint64_t v9 = *(void *)(v8 + 32);
  }
  else {
    uint64_t v9 = 0LL;
  }
  uint64_t v244 = v4;
  uint64_t v10 = v4[1];
  uint64_t v11 = apr_array_make(a3, *(_DWORD *)(*(void *)(v9 + 8) + 12LL), 24);
  *(void *)&__int128 v245 = v11;
  v234 = apr_hash_make(a3);
  *((void *)&v245 + 1) = v234;
  *(void *)&__int128 v235 = apr_hash_make(a3);
  *((void *)&v235 + 1) = apr_hash_make(a3);
  __int128 v246 = v235;
  *(void *)&__int128 v238 = apr_hash_make(a3);
  *((void *)&v238 + 1) = apr_hash_make(a3);
  __int128 v247 = v238;
  *(void *)&__int128 v240 = apr_hash_make(a3);
  *((void *)&v240 + 1) = apr_hash_make(a3);
  __int128 v248 = v240;
  id v241 = apr_hash_make(a3);
  *(void *)&__int128 v249 = v241;
  *((void *)&v249 + 1) = apr_hash_make(a3);
  uint64_t v250 = 0LL;
  uint64_t v12 = *(void *)(v9 + 8);
  if (*(int *)(v12 + 12) >= 1)
  {
    uint64_t v13 = 0LL;
    uint64_t v14 = 0LL;
    do
    {
      BOOL v4 = (uint64_t **)(*(void *)(v12 + 24) + v13);
      uint64_t v15 = apr_array_push(v11);
      uint64_t v16 = (void *)objc_claimAutoreleasedReturnValue([v10 bufferForKey:v4[2]]);
      id v17 = DEVICEOBJECT(v16);
      uint64_t v18 = (void *)objc_claimAutoreleasedReturnValue(v17);

      *uint64_t v15 = [v18 gpuAddress];
      v15[1] = [v18 length];
      v15[2] = *v4;

      ++v14;
      uint64_t v12 = *(void *)(v9 + 8);
      v13 += 24LL;
    }

    while (v14 < *(int *)(v12 + 12));
  }

  qsort( v11->elts,  v11->nelts,  v11->elt_size,  (int (__cdecl *)(const void *, const void *))GTMTLGPUAddressResource_compare);
  uint64_t v19 = *(void *)(v9 + 16);
  *(void *)(v19 + 24) = 0LL;
  *(void *)(v19 + 32) = 0LL;
  *(void *)(v19 + 16) = v19;
  *(_DWORD *)(v19 + 40) = 0;
  uint64_t v20 = apr_hash_next((apr_hash_index_t *)(v19 + 16));
  if (v20)
  {
    unint64_t v21 = v20;
    do
    {
      BOOL v4 = *(uint64_t ***)(*((void *)v21 + 1) + 32LL);
      uint64_t v22 = apr_palloc(a3, 0x20uLL);
      uint64_t v23 = (void *)objc_claimAutoreleasedReturnValue([v10 textureForKey:v4[1]]);
      id v24 = DEVICEOBJECT(v23);
      uint64_t v25 = (void *)objc_claimAutoreleasedReturnValue(v24);

      *uint64_t v22 = [v25 uniqueIdentifier];
      v22[1] = *v4;
      void v22[2] = [v25 gpuResourceID];
      uint64_t v26 = v22 + 2;
      int v27 = *(unsigned __int8 *)(v9 + 88);
      if (v27 != 1) {
        uint64_t v26 = v22;
      }
      if (v27 == 2) {
        uint64_t v28 = v22 + 3;
      }
      else {
        uint64_t v28 = v26;
      }
      apr_hash_set(v234, v28, 8LL, v22);

      unint64_t v21 = apr_hash_next(v21);
    }

    while (v21);
  }

  uint64_t v29 = *(void *)(v9 + 24);
  *(void *)(v29 + 24) = 0LL;
  *(void *)(v29 + 32) = 0LL;
  *(void *)(v29 + 16) = v29;
  *(_DWORD *)(v29 + 40) = 0;
  id v30 = apr_hash_next((apr_hash_index_t *)(v29 + 16));
  if (v30)
  {
    uint64_t v31 = v30;
    do
    {
      uint64_t v32 = *(uint64_t ***)(*((void *)v31 + 1) + 32LL);
      BOOL v4 = (uint64_t **)apr_palloc(a3, 0x20uLL);
      uint64_t v33 = (void *)objc_claimAutoreleasedReturnValue([v10 samplerStateForKey:v32[1]]);
      id v34 = DEVICEOBJECT(v33);
      uint64_t v35 = (void *)objc_claimAutoreleasedReturnValue(v34);

      *BOOL v4 = (uint64_t *)[v35 uniqueIdentifier];
      v4[1] = *v32;
      v4[2] = (uint64_t *)[v35 gpuResourceID];
      id v36 = v4 + 2;
      int v37 = *(unsigned __int8 *)(v9 + 88);
      if (v37 != 1) {
        id v36 = v4;
      }
      if (v37 == 2) {
        uint64_t v38 = v4 + 3;
      }
      else {
        uint64_t v38 = v36;
      }
      apr_hash_set((apr_hash_t *)v235, v38, 8LL, v4);

      uint64_t v31 = apr_hash_next(v31);
    }

    while (v31);
  }

  uint64_t v39 = *(void *)(v9 + 32);
  *(void *)(v39 + 24) = 0LL;
  *(void *)(v39 + 32) = 0LL;
  *(void *)(v39 + 16) = v39;
  *(_DWORD *)(v39 + 40) = 0;
  uint64_t v40 = apr_hash_next((apr_hash_index_t *)(v39 + 16));
  if (v40)
  {
    int v41 = v40;
    do
    {
      id v42 = *(uint64_t ***)(*((void *)v41 + 1) + 32LL);
      BOOL v4 = (uint64_t **)apr_palloc(a3, 0x20uLL);
      uint64_t v43 = (void *)objc_claimAutoreleasedReturnValue([v10 renderPipelineStateForKey:v42[1]]);
      id v44 = DEVICEOBJECT(v43);
      uint64_t v45 = (void *)objc_claimAutoreleasedReturnValue(v44);

      *BOOL v4 = (uint64_t *)[v45 uniqueIdentifier];
      v4[1] = *v42;
      v4[2] = (uint64_t *)[v45 gpuResourceID];
      uint64_t v46 = v4 + 2;
      int v47 = *(unsigned __int8 *)(v9 + 88);
      if (v47 != 1) {
        uint64_t v46 = v4;
      }
      if (v47 == 2) {
        uint64_t v48 = v4 + 3;
      }
      else {
        uint64_t v48 = v46;
      }
      apr_hash_set(*((apr_hash_t **)&v235 + 1), v48, 8LL, v4);

      int v41 = apr_hash_next(v41);
    }

    while (v41);
  }

  uint64_t v49 = *(void *)(v9 + 40);
  *(void *)(v49 + 24) = 0LL;
  *(void *)(v49 + 32) = 0LL;
  *(void *)(v49 + 16) = v49;
  *(_DWORD *)(v49 + 40) = 0;
  id v50 = apr_hash_next((apr_hash_index_t *)(v49 + 16));
  if (v50)
  {
    uint64_t v51 = v50;
    do
    {
      uint64_t v52 = *(uint64_t ***)(*((void *)v51 + 1) + 32LL);
      BOOL v4 = (uint64_t **)apr_palloc(a3, 0x20uLL);
      uint64_t v53 = (void *)objc_claimAutoreleasedReturnValue([v10 computePipelineStateForKey:v52[1]]);
      id v54 = DEVICEOBJECT(v53);
      id v55 = (void *)objc_claimAutoreleasedReturnValue(v54);

      *BOOL v4 = (uint64_t *)[v55 uniqueIdentifier];
      v4[1] = *v52;
      v4[2] = (uint64_t *)[v55 gpuResourceID];
      uint64_t v56 = v4 + 2;
      int v57 = *(unsigned __int8 *)(v9 + 88);
      if (v57 != 1) {
        uint64_t v56 = v4;
      }
      if (v57 == 2) {
        id v58 = v4 + 3;
      }
      else {
        id v58 = v56;
      }
      apr_hash_set((apr_hash_t *)v238, v58, 8LL, v4);

      uint64_t v51 = apr_hash_next(v51);
    }

    while (v51);
  }

  uint64_t v59 = *(void *)(v9 + 48);
  *(void *)(v59 + 24) = 0LL;
  *(void *)(v59 + 32) = 0LL;
  *(void *)(v59 + 16) = v59;
  *(_DWORD *)(v59 + 40) = 0;
  uint64_t v60 = apr_hash_next((apr_hash_index_t *)(v59 + 16));
  if (v60)
  {
    uint64_t v61 = v60;
    do
    {
      uint64_t v62 = *(uint64_t ***)(*((void *)v61 + 1) + 32LL);
      BOOL v4 = (uint64_t **)apr_palloc(a3, 0x20uLL);
      uint64_t v63 = (void *)objc_claimAutoreleasedReturnValue([v10 indirectCommandBufferForKey:v62[1]]);
      id v64 = DEVICEOBJECT(v63);
      uint64_t v65 = (void *)objc_claimAutoreleasedReturnValue(v64);

      *BOOL v4 = (uint64_t *)[v65 uniqueIdentifier];
      v4[1] = *v62;
      v4[2] = (uint64_t *)[v65 gpuResourceID];
      uint64_t v66 = v4 + 2;
      int v67 = *(unsigned __int8 *)(v9 + 88);
      if (v67 != 1) {
        uint64_t v66 = v4;
      }
      if (v67 == 2) {
        int v68 = v4 + 3;
      }
      else {
        int v68 = v66;
      }
      apr_hash_set(*((apr_hash_t **)&v238 + 1), v68, 8LL, v4);

      uint64_t v61 = apr_hash_next(v61);
    }

    while (v61);
  }

  uint64_t v69 = *(void *)(v9 + 56);
  *(void *)(v69 + 24) = 0LL;
  *(void *)(v69 + 32) = 0LL;
  *(void *)(v69 + 16) = v69;
  *(_DWORD *)(v69 + 40) = 0;
  uint64_t v70 = apr_hash_next((apr_hash_index_t *)(v69 + 16));
  if (v70)
  {
    id v71 = v70;
    do
    {
      uint64_t v72 = *(uint64_t ***)(*((void *)v71 + 1) + 32LL);
      BOOL v4 = (uint64_t **)apr_palloc(a3, 0x20uLL);
      uint64_t v73 = (void *)objc_claimAutoreleasedReturnValue([v10 visibleFunctionTableForKey:v72[1]]);
      id v74 = DEVICEOBJECT(v73);
      uint64_t v75 = (void *)objc_claimAutoreleasedReturnValue(v74);

      *BOOL v4 = (uint64_t *)[v75 uniqueIdentifier];
      v4[1] = *v72;
      v4[2] = (uint64_t *)[v75 gpuResourceID];
      uint64_t v76 = v4 + 2;
      int v77 = *(unsigned __int8 *)(v9 + 88);
      if (v77 != 1) {
        uint64_t v76 = v4;
      }
      if (v77 == 2) {
        uint64_t v78 = v4 + 3;
      }
      else {
        uint64_t v78 = v76;
      }
      apr_hash_set((apr_hash_t *)v240, v78, 8LL, v4);

      id v71 = apr_hash_next(v71);
    }

    while (v71);
  }

  uint64_t v79 = *(void *)(v9 + 64);
  *(void *)(v79 + 24) = 0LL;
  *(void *)(v79 + 32) = 0LL;
  *(void *)(v79 + 16) = v79;
  *(_DWORD *)(v79 + 40) = 0;
  unint64_t v80 = apr_hash_next((apr_hash_index_t *)(v79 + 16));
  if (v80)
  {
    uint64_t v81 = v80;
    do
    {
      unint64_t v82 = *(uint64_t ***)(*((void *)v81 + 1) + 32LL);
      BOOL v4 = (uint64_t **)apr_palloc(a3, 0x20uLL);
      id v83 = (void *)objc_claimAutoreleasedReturnValue([v10 intersectionFunctionTableForKey:v82[1]]);
      id v84 = DEVICEOBJECT(v83);
      uint64_t v85 = (void *)objc_claimAutoreleasedReturnValue(v84);

      *BOOL v4 = (uint64_t *)[v85 uniqueIdentifier];
      v4[1] = *v82;
      v4[2] = (uint64_t *)[v85 gpuResourceID];
      uint64_t v86 = v4 + 2;
      int v87 = *(unsigned __int8 *)(v9 + 88);
      if (v87 != 1) {
        uint64_t v86 = v4;
      }
      if (v87 == 2) {
        uint64_t v88 = v4 + 3;
      }
      else {
        uint64_t v88 = v86;
      }
      apr_hash_set(*((apr_hash_t **)&v240 + 1), v88, 8LL, v4);

      uint64_t v81 = apr_hash_next(v81);
    }

    while (v81);
  }

  uint64_t v89 = *(void *)(v9 + 72);
  *(void *)(v89 + 24) = 0LL;
  *(void *)(v89 + 32) = 0LL;
  *(void *)(v89 + 16) = v89;
  *(_DWORD *)(v89 + 40) = 0;
  uint64_t v90 = apr_hash_next((apr_hash_index_t *)(v89 + 16));
  if (v90)
  {
    uint64_t v91 = v90;
    do
    {
      id v92 = *(uint64_t ***)(*((void *)v91 + 1) + 32LL);
      BOOL v4 = (uint64_t **)apr_palloc(a3, 0x20uLL);
      uint64_t v93 = (void *)objc_claimAutoreleasedReturnValue([v10 accelerationStructureForKey:v92[1]]);
      id v94 = DEVICEOBJECT(v93);
      uint64_t v95 = (void *)objc_claimAutoreleasedReturnValue(v94);

      *BOOL v4 = (uint64_t *)[v95 uniqueIdentifier];
      v4[1] = *v92;
      v4[2] = (uint64_t *)[v95 gpuResourceID];
      uint64_t v96 = v4 + 2;
      int v97 = *(unsigned __int8 *)(v9 + 88);
      if (v97 != 1) {
        uint64_t v96 = v4;
      }
      if (v97 == 2) {
        id v98 = v4 + 3;
      }
      else {
        id v98 = v96;
      }
      apr_hash_set(v241, v98, 8LL, v4);

      uint64_t v91 = apr_hash_next(v91);
    }

    while (v91);
  }

  GTMTLIndirectResources_rehash((apr_hash_index_t *)__dst, (uint64_t)&v245, 1, a3);
  __int128 v247 = *(_OWORD *)&__dst[32];
  __int128 v248 = *(_OWORD *)&__dst[48];
  __int128 v249 = *(_OWORD *)&__dst[64];
  uint64_t v250 = *(void *)&__dst[80];
  __int128 v245 = *(_OWORD *)__dst;
  __int128 v246 = *(_OWORD *)&__dst[16];
  id v99 = *v244;
  if (*v243) {
    uint64_t v100 = *(void *)(v99[15] + 24) + ((unint64_t)(*v243 - 1) << 6);
  }
  else {
    uint64_t v100 = 0LL;
  }
  if (*(_DWORD *)(v100 + 8) >> 2 == 1073737833)
  {
    p = (apr_pool_t *)*v244[19];
    GTMTLSMContext_indirectCommandBufferResources((uint64_t)v255, (_DWORD **)v99[5], *(void *)v100, p);
    GetExecuteCommandsInBufferArgs((uint64_t)v253, v100, v99[2]);
    uint64_t Object = GTMTLSMContext_getObject(*(void *)v99[5], v253[0], *(void *)v100);
    GTMTLCreateIndirectCommandEncoder((uint64_t)v254, Object[13]);
    BOOL v4 = (uint64_t **)(v253[3] + v254[13] * v243[1]);
    v255[11] = (uint64_t)v4;
  }

  int v102 = *((_DWORD *)v244 + 2828);
  if (v102 == 28)
  {
    memcpy(__dst, v244 + 1421, 0x8D0uLL);
    if (*(_DWORD *)(v100 + 8) >> 2 == 1073737833)
    {
      GTMTLSMComputeCommandEncoder_loadIndirectCommand((uint64_t)__dst, v254, (uint64_t)v4, v255);
      apr_pool_clear(p);
    }

    uint64_t v111 = GTMTLSMContext_getObject(*(void *)v99[5], *(uint64_t *)&__dst[8], *(void *)v100);
    uint64_t v112 = v111[8];
    GTMTLSMComputePipelineState_computePipelineDescriptor((uint64_t *)v99[5], (uint64_t)v111, v251, a3);
    unint64_t v113 = a2 + 1346;
    if (*(_WORD *)(v112 + 94))
    {
      uint64_t v114 = 0LL;
      uint64_t v115 = *(void *)(v112 + 32);
      unsigned int v116 = (unsigned __int8 *)(v115 + 18);
      while (v113 != *v116 || *(v116 - 2) > 1u)
      {
        v116 += 56;
      }

      uint64_t v134 = v115 + 56 * v114;
    }

    else
    {
LABEL_100:
      uint64_t v134 = 0LL;
    }

    uint64_t v118 = v251[106];
    uint64_t v127 = &__dst[8 * v113];
    uint64_t v119 = *((void *)v127 + 4);
    unint64_t v120 = *((void *)v127 + 35);
    goto LABEL_149;
  }

  if (v102 != 70)
  {
    uint64_t v134 = 0LL;
    uint64_t v118 = 0LL;
    uint64_t v119 = 0LL;
    unint64_t v120 = 0LL;
    goto LABEL_149;
  }

  memcpy(__dst, v244 + 1421, sizeof(__dst));
  if (*(_DWORD *)(v100 + 8) >> 2 == 1073737833)
  {
    GTMTLSMRenderCommandEncoder_loadIndirectCommand((uint64_t)__dst, v254, (uint64_t)v4, v255);
    apr_pool_clear(p);
  }

  int v103 = GTMTLSMContext_getObject(*(void *)v99[5], *(uint64_t *)&__dst[8544], *(void *)v100);
  uint64_t v104 = v103[7];
  if (a2 < 0xFFFFFFFFFFFFFBBELL)
  {
    if (a2 < 0xFFFFFFFFFFFFFB7ELL)
    {
      if (a2 < 0xFFFFFFFFFFFFFB3ELL)
      {
        if (a2 >= 0xFFFFFFFFFFFFFAFELL)
        {
          unint64_t v139 = a2 + 1282;
          uint64_t v140 = *(unsigned __int16 *)(v104 + 204);
          if (*(_WORD *)(v104 + 204))
          {
            uint64_t v141 = 0LL;
            uint64_t v142 = *(void *)(v104 + 40);
            uint64_t v143 = (unsigned __int8 *)(v142 + 18);
            while (v139 != *v143 || *(v143 - 2) > 1u)
            {
              v143 += 56;
              if (v140 == ++v141) {
                goto LABEL_133;
              }
            }

            uint64_t v134 = v142 + 56 * v141;
          }

          else
          {
LABEL_133:
            uint64_t v134 = 0LL;
          }

          uint64_t v135 = (uint64_t *)(v103[9] + 368LL);
          __int128 v154 = &__dst[8 * v139];
          unsigned int v137 = (uint64_t *)(v154 + 3584);
          uint64_t v138 = (unint64_t *)(v154 + 3832);
          goto LABEL_148;
        }

        unint64_t v146 = a2 + 1346;
        uint64_t v147 = *(unsigned __int16 *)(v104 + 202);
        if (*(_WORD *)(v104 + 202))
        {
          uint64_t v148 = 0LL;
          uint64_t v149 = *(void *)(v104 + 56);
          uint64_t v150 = (unsigned __int8 *)(v149 + 18);
          while (v146 != *v150 || *(v150 - 2) > 1u)
          {
            v150 += 56;
            if (v147 == ++v148) {
              goto LABEL_143;
            }
          }

          uint64_t v134 = v149 + 56 * v148;
        }

        else
        {
LABEL_143:
          uint64_t v134 = 0LL;
        }

        uint64_t v135 = (uint64_t *)(v103[8] + 120LL);
        __int128 v152 = &__dst[8 * v146];
        unsigned int v137 = (uint64_t *)(v152 + 6896);
        uint64_t v153 = 7144LL;
      }

      else
      {
        unint64_t v128 = a2 + 1218;
        uint64_t v129 = *(unsigned __int16 *)(v104 + 206);
        if (*(_WORD *)(v104 + 206))
        {
          uint64_t v130 = 0LL;
          uint64_t v131 = *(void *)(v104 + 48);
          uint64_t v132 = (unsigned __int8 *)(v131 + 18);
          while (v128 != *v132 || *(v132 - 2) > 1u)
          {
            v132 += 56;
            if (v129 == ++v130) {
              goto LABEL_122;
            }
          }

          uint64_t v134 = v131 + 56 * v130;
        }

        else
        {
LABEL_122:
          uint64_t v134 = 0LL;
        }

        uint64_t v135 = (uint64_t *)(v103[9] + 360LL);
        __int128 v152 = &__dst[8 * v128];
        unsigned int v137 = (uint64_t *)(v152 + 5240);
        uint64_t v153 = 5488LL;
      }

      uint64_t v138 = (unint64_t *)&v152[v153];
    }

    else
    {
      unint64_t v121 = a2 + 1154;
      uint64_t v122 = *(unsigned __int16 *)(v104 + 200);
      if (*(_WORD *)(v104 + 200))
      {
        uint64_t v123 = 0LL;
        uint64_t v124 = *(void *)(v104 + 32);
        unsigned int v125 = (unsigned __int8 *)(v124 + 18);
        while (v121 != *v125 || *(v125 - 2) > 1u)
        {
          v125 += 56;
          if (v122 == ++v123) {
            goto LABEL_111;
          }
        }

        uint64_t v134 = v124 + 56 * v123;
      }

      else
      {
LABEL_111:
        uint64_t v134 = 0LL;
      }

      uint64_t v135 = (uint64_t *)(v103[6] + 1176LL);
      __int128 v145 = &__dst[8 * v121];
      unsigned int v137 = (uint64_t *)(v145 + 1928);
      uint64_t v138 = (unint64_t *)(v145 + 2176);
    }
  }

  else
  {
    unint64_t v105 = a2 + 1090;
    uint64_t v106 = *(unsigned __int16 *)(v104 + 198);
    if (*(_WORD *)(v104 + 198))
    {
      uint64_t v107 = 0LL;
      uint64_t v108 = *(void *)(v104 + 24);
      __int128 v109 = (unsigned __int8 *)(v108 + 18);
      while (v105 != *v109 || *(v109 - 2) > 1u)
      {
        v109 += 56;
        if (v106 == ++v107) {
          goto LABEL_89;
        }
      }

      uint64_t v134 = v108 + 56 * v107;
    }

    else
    {
LABEL_89:
      uint64_t v134 = 0LL;
    }

    uint64_t v135 = (uint64_t *)(v103[6] + 1296LL);
    int64x2_t v136 = &__dst[8 * v105];
    unsigned int v137 = (uint64_t *)(v136 + 24);
    uint64_t v138 = (unint64_t *)(v136 + 272);
  }

LABEL_181:
            ++v189;
            v188 += 32LL;
            if (v189 >= v186) {
              goto LABEL_215;
            }
          }
        }

        goto LABEL_215;
      }
            }
          }

          else
          {
            id v98 = (size_t *)(v150 + (v152 << 6));
            id v99 = v98[5];
            v98 += 5;
            __int128 v165 = (void *)objc_claimAutoreleasedReturnValue([v143 bufferWithLength:v99 alignment:1]);
            GTCaptureArchive_fillBuffer( v142,  v147,  *(char **)(v150 + (v152 << 6) + 24),  (char *)[v165 contents],  *v98,  0);
            __int128 v169 = FillBufferWithBufferBlitOperation((uint64_t)v148, v85, v165, 0LL, *v98, v151, v169, v163);
          }
        }

        apr_pool_clear(*v147);
        objc_autoreleasePoolPop(context);
        if (++v152 == v146) {
          goto LABEL_183;
        }
      }

      uint64_t v164 = v151;
      uint64_t v88 = **v148;
      uint64_t v89 = (apr_pool_t **)v148[19];
      __int128 v162 = v148[3];
      __int128 v145 = v148[1];
      __int128 v161 = (void *)objc_claimAutoreleasedReturnValue([v145 defaultDevice]);
      uint64_t v90 = v150 + (v152 << 6);
      size_t FileWithFilename = (unsigned int *)GTCaptureArchive_getFileWithFilename(v88, *(char **)(v90 + 24));
      id v92 = (void *)objc_claimAutoreleasedReturnValue([v162 bufferWithLength:*FileWithFilename alignment:1]);
      GTCaptureArchive_fillBuffer( v88,  v89,  *(char **)(v90 + 24),  (char *)[v92 contents],  *FileWithFilename,  0);
      uint64_t v93 = (int *)[v92 contents];
      id v94 = [v92 length];
      if (v93) {
        uint64_t v95 = (unint64_t)v94 >= 0x10;
      }
      else {
        uint64_t v95 = 0;
      }
      if (v95)
      {
        int v97 = v148;
        if (*(void *)v93 == 0x63617074757265LL)
        {
          if (*((_WORD *)v93 + 4) == 1) {
            uint64_t v96 = v93[3] + 16LL;
          }
          else {
            uint64_t v96 = v93[3];
          }
        }

        else
        {
          uint64_t v93 = 0LL;
          uint64_t v96 = 0LL;
        }
      }

      else
      {
        uint64_t v93 = 0LL;
        uint64_t v96 = 0LL;
        int v97 = v148;
      }

      uint64_t v100 = 0LL;
      unsigned __int8 v101 = *(void *)v85;
      __int128 v167 = v92;
      if (*(uint64_t *)v85 <= 56)
      {
        if (v101 == 16)
        {
          int v103 = v169 + 31;
          int v102 = 32LL;
          goto LABEL_158;
        }

        if (v101 == 22) {
          goto LABEL_141;
        }
      }

      else
      {
        switch(v101)
        {
          case '9':
LABEL_141:
            int v103 = v100 + v169;
            if (v101 <= 79)
            {
              if (v101 == 22 || v101 == 57)
              {
                int v102 = 1LL;
                goto LABEL_158;
              }

LABEL_216:
      unint64_t v182 = v184 + v236;
      unint64_t v175 = v184;
      if (v184 + v236 > v237) {
        goto LABEL_217;
      }
    }

    unint64_t v242 = v184;
    id v203 = v172;
    id v204 = v225;
    int v205 = v168->nelts;
    if (v205 < 1)
    {
LABEL_214:

LABEL_215:
      id v172 = v228;

      int v183 = v227;
      unint64_t v184 = v242;
      goto LABEL_216;
    }

    uint64_t v206 = 0LL;
    uint64_t v207 = 0LL;
    uint64_t v239 = v249;
    uint64_t v208 = &v226[v175];
    __int128 v230 = v248;
    __int128 v229 = v247;
    __int128 v233 = v246;
    __int128 v231 = v245;
    while (1)
    {
      int v209 = (uint64_t *)&v168->elts[v206];
      uint64_t v211 = *v209;
      uint64_t v210 = v209[1];
      if (*v209 > 78) {
        break;
      }
      if (v211 > 59)
      {
        if (v211 == 60)
        {
          __int128 v212 = (char *)[v204 virtualAddressForBufferAtIndex:v210 inIndirectArgumentBuffer:v203 atOffset:v208];
          __int128 v214 = GTMTLGPUAddressResource_resourceForGPUAddress( *(void **)(v231 + 24),  *(int *)(v231 + 12),  (unint64_t)v212);
          if (v214) {
            __int128 v212 = &v212[v214[2] - *v214];
          }
          goto LABEL_212;
        }

        if (v211 == 78)
        {
          __int128 v212 = (char *)[v204 uniqueIdentifierForRenderPipelineAtIndex:v210 inIndirectArgumentBuffer:v203 atOffset:v208];
          *(void *)__dst = v212;
          uint64_t v213 = *((void *)&v233 + 1);
          goto LABEL_209;
        }
      }

      else
      {
        if (v211 == 58)
        {
          __int128 v212 = (char *)[v204 uniqueIdentifierForTextureAtIndex:v210 inIndirectArgumentBuffer:v203 atOffset:v208];
          *(void *)__dst = v212;
          uint64_t v213 = *((void *)&v231 + 1);
LABEL_209:
          uint64_t v216 = *find_entry(v213, __dst, 8uLL, 0LL);
          if (v216)
          {
            uint64_t v217 = *(void *)(v216 + 32);
            if (v217) {
              __int128 v212 = *(char **)(v217 + 8);
            }
          }

LABEL_212:
          *(void *)apr_array_push(v17_Block_object_dispose((const void *)(v12 - 64), 8) = v212;
          int v205 = v168->nelts;
          goto LABEL_213;
        }

        if (v211 == 59)
        {
          __int128 v212 = (char *)[v204 uniqueIdentifierForSamplerAtIndex:v210 inIndirectArgumentBuffer:v203 atOffset:v208];
          *(void *)__dst = v212;
          uint64_t v213 = v233;
          goto LABEL_209;
        }
      }

LABEL_213:
      ++v207;
      v206 += 32LL;
      if (v207 >= v205) {
        goto LABEL_214;
      }
    }

    switch(v211)
    {
      case 's':
        __int128 v212 = (char *)[v204 uniqueIdentifierForVisibleFunctionTableAtIndex:v210 inIndirectArgumentBuffer:v203 atOffset:v208];
        *(void *)__dst = v212;
        uint64_t v213 = v230;
        goto LABEL_209;
      case 't':
        __int128 v212 = (char *)[v204 uniqueIdentifierForIntersectionFunctionTableAtIndex:v210 inIndirectArgumentBuffer:v203 atOffset:v208];
        *(void *)__dst = v212;
        uint64_t v213 = *((void *)&v230 + 1);
        goto LABEL_209;
      case 'u':
        __int128 v215 = (char *)[v204 uniqueIdentifierForPrimitiveAccelerationStructureAtIndex:v210 inIndirectArgumentBuffer:v203 atOffset:v208];
        goto LABEL_207;
      case 'v':
        __int128 v215 = (char *)[v204 uniqueIdentifierForInstanceAccelerationStructureAtIndex:v210 inIndirectArgumentBuffer:v203 atOffset:v208];
LABEL_207:
        __int128 v212 = v215;
        *(void *)__dst = v215;
        uint64_t v213 = v239;
        goto LABEL_209;
      default:
        if (v211 == 79)
        {
          __int128 v212 = (char *)[v204 uniqueIdentifierForComputePipelineAtIndex:v210 inIndirectArgumentBuffer:v203 atOffset:v208];
          *(void *)__dst = v212;
          uint64_t v213 = v229;
        }

        else
        {
          if (v211 != 80) {
            goto LABEL_213;
          }
          __int128 v212 = (char *)[v204 uniqueIdentifierForIndirectCommandBufferAtIndex:v210 inIndirectArgumentBuffer:v203 atOffset:v208];
          *(void *)__dst = v212;
          uint64_t v213 = *((void *)&v229 + 1);
        }

        break;
    }

    goto LABEL_209;
  }

LABEL_217:
  elts = v178->elts;
  return elts;
}

        uint64_t v178 = *(void *)&v88[1].nelts;
        goto LABEL_218;
      }

      if (pool_high > -15546)
      {
        if (pool_high == -15545) {
          goto LABEL_217;
        }
        if (pool_high != -15544) {
          goto LABEL_219;
        }
        DYTraceDecode_MTLArgumentEncoder_setBuffers_offsets_withRange( (uint64_t)buf,  (uint64_t)v88,  (LODWORD(v88->pool) - 36),  0LL);
      }

      else
      {
        if (pool_high == -15559) {
          goto LABEL_217;
        }
        if (pool_high != -15558) {
          goto LABEL_219;
        }
        DYTraceDecode_MTLArgumentEncoder_setIndirectCommandBuffers_withRange( (uint64_t)buf,  (uint64_t)v88,  (LODWORD(v88->pool) - 36),  0LL);
      }

      uint64_t v178 = *(void *)buf;
LABEL_218:
      uint64_t v179 = GetDeviceObjectStreamRef((uint64_t)&v695, v178);
      uint64_t v180 = apr_palloc(*(apr_pool_t **)v660, 8uLL);
      void *v180 = v179;
      apr_hash_set(v660, v180, 8LL, &RecordIntersectionFunctionTableMutation_sValue);
      uint64_t v88 = v679;
LABEL_219:
      uint64_t v181 = HIDWORD(v88->pool);
      if (v181 <= -15909)
      {
        if (v181 == -16361) {
          goto LABEL_226;
        }
        unint64_t v182 = -16202;
      }

      else
      {
        if (v181 == -15908 || v181 == -15316)
        {
LABEL_226:
          *((void *)v73 + 2) = v73;
          *(void *)v648 = 0LL;
          *((void *)v648 + 1) = 0LL;
          *((_DWORD *)v648 + 4) = 0;
          int v183 = apr_hash_next(v649);
          if (v183)
          {
            unint64_t v184 = v183;
            do
            {
              *(void *)buf = **(void **)(*((void *)v184 + 1) + 16LL);
              id v185 = *find_entry((uint64_t)v69, buf, 8uLL, 0LL);
              if (!v185 || (int v186 = *(apr_array_header_t **)(v185 + 32)) == 0LL)
              {
                int v186 = apr_array_make(v66, 8, 16);
                uint64_t v187 = apr_palloc(v66, 8uLL);
                void *v187 = *(void *)buf;
                apr_hash_set(v69, v187, 8LL, v186);
              }

              uint64_t v188 = apr_array_push(v186);
              *uint64_t v188 = v655 + 1;
              v188[1] = (char *)v673 - v655;
              unint64_t v184 = apr_hash_next(v184);
            }

            while (v184);
          }

          *((void *)v660 + 2) = v660;
          *((void *)v660 + 3) = 0LL;
          *((void *)v660 + 4) = 0LL;
          *((_DWORD *)v660 + 10) = 0;
          uint64_t v189 = apr_hash_next((apr_hash_t *)((char *)v660 + 16));
          if (v189)
          {
            unint64_t v190 = v189;
            do
            {
              *(void *)buf = **(void **)(*((void *)v190 + 1) + 16LL);
              uint64_t v191 = *find_entry((uint64_t)v68, buf, 8uLL, 0LL);
              if (!v191 || (unint64_t v192 = *(apr_array_header_t **)(v191 + 32)) == 0LL)
              {
                unint64_t v192 = apr_array_make(v66, 8, 16);
                uint64_t v193 = apr_palloc(v66, 8uLL);
                *uint64_t v193 = *(void *)buf;
                apr_hash_set(v68, v193, 8LL, v192);
              }

              unint64_t v194 = apr_array_push(v192);
              __int128 *v194 = v655 + 1;
              v194[1] = (char *)v673 - v655;
              unint64_t v190 = apr_hash_next(v190);
            }

            while (v190);
          }

          uint64_t v73 = ht;
          apr_hash_clear(ht);
          apr_hash_clear(v660);
          uint64_t v88 = v679;
          v655 = (unint64_t)v673;
          uint64_t v72 = v650;
          uint64_t v75 = v653;
          goto LABEL_239;
        }

        unint64_t v182 = -15318;
      }

      if (v181 == v182) {
        goto LABEL_226;
      }
LABEL_239:
      pool_low = LODWORD(v88->pool);
      if ((BYTE1(v88[1].pool) & 0x10) != 0)
      {
        id v196 = LODWORD(v88->pool);
        do
        {
          uint64_t v88 = (apr_array_header_t *)((char *)v88 + pool_low);
          pool_low = LODWORD(v88->pool);
          v196 += pool_low;
        }

        while ((BYTE1(v88[1].pool) & 0x20) == 0);
      }

      else
      {
        id v196 = LODWORD(v88->pool);
      }

      uint64_t v76 = v196 + v657;
      v673 = (apr_hash_t *)((char *)v673 + 1);
      if (v196 + v657 >= v72) {
        goto LABEL_274;
      }
    }

    if (!v658)
    {
      unint64_t v82 = GetFuncEnumConstructorType(v77) == 51;
      goto LABEL_99;
    }

    uint64_t v79 = v77 != -15343;
LABEL_102:
    id v83 = v654;
    goto LABEL_109;
  }

id GTMTLReplayDefaults_logCommandBufferHandlers()
{
  v0 = @"com.apple.gputools.replay.logCommandBufferHandlers";
  uint64_t v1 = (void *)objc_claimAutoreleasedReturnValue(+[NSUserDefaults standardUserDefaults](&OBJC_CLASS___NSUserDefaults, "standardUserDefaults"));
  id v2 = [v1 BOOLForKey:@"com.apple.gputools.replay.logCommandBufferHandlers"];

  return v2;
}

void GTMTLReplayController_restoreRenderCommandEncoder(void *a1, uint64_t a2, uint64_t a3, void *a4)
{
  uint64_t v7 = a3 + 10012;
  uint64_t v8 = a2 + 10012;
  id v9 = a1;
  id v10 = a4;
  id v35 = v9;
  uint64_t v11 = *(void *)(a3 + 8544);
  if (*(void *)(a2 + 8544) != v11 && v11 != 0)
  {
    uint64_t v13 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v10, "renderPipelineStateForKey:"));
    [v35 setRenderPipelineState:v13];
  }

  if (*(void *)(a2 + 9848) != *(void *)(a3 + 9848))
  {
    uint64_t v14 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v10, "depthStencilStateForKey:"));
    [v35 setDepthStencilState:v14];
  }

  if (*(float *)(a2 + 10000) != *(float *)(a3 + 10000)
    || *(float *)(a2 + 10004) != *(float *)(a3 + 10004)
    || *(float *)(a2 + 10008) != *(float *)(a3 + 10008))
  {
    objc_msgSend(v35, "setDepthBias:slopeScale:clamp:");
  }

  if (*(_DWORD *)(a2 + 10028) != *(_DWORD *)(a3 + 10028) || *(_DWORD *)(a2 + 10032) != *(_DWORD *)(a3 + 10032)) {
    objc_msgSend(v35, "setStencilFrontReferenceValue:backReferenceValue:");
  }
  uint64_t v15 = *(void *)(a3 + 8552);
  uint64_t v16 = *(void *)(a3 + 9328);
  if ((GT_SUPPORT_0 & 2) != 0)
  {
    if (*(unsigned __int8 *)(v8 + 1072) != *(unsigned __int8 *)(v7 + 1072)
      || *(_DWORD *)(a2 + 11068) != *(_DWORD *)(a3 + 11068))
    {
      objc_msgSend(v35, "setVertexAmplificationMode:value:");
    }

    if (*(_DWORD *)(a2 + 11072) != *(_DWORD *)(a3 + 11072) || *(void *)(a2 + 9856) != *(void *)(a3 + 9856)) {
      objc_msgSend(v35, "setVertexAmplificationCount:viewMappings:");
    }
  }

  if (*(void *)v8 != *(void *)v7 || *(void *)(v8 + 8) != *(void *)(v7 + 8))
  {
    LODWORD(v17) = *(_DWORD *)(a3 + 10012);
    LODWORD(v1_Block_object_dispose((const void *)(v12 - 64), 8) = *(_DWORD *)(a3 + 10016);
    LODWORD(v19) = *(_DWORD *)(a3 + 10020);
    LODWORD(v20) = *(_DWORD *)(a3 + 10024);
    [v35 setBlendColorRed:v17 green:v18 blue:v19 alpha:v20];
  }

  if (*(unsigned __int8 *)(v8 + 1073) != *(unsigned __int8 *)(v7 + 1073)
    || (uint64_t v22 = v35, *(_DWORD *)(a2 + 11076) != *(_DWORD *)(a3 + 11076)))
  {
    objc_msgSend(v35, "setVisibilityResultMode:offset:");
    uint64_t v22 = v35;
  }

  uint64_t v36 = a2 + 24;
  uint64_t v37 = a3 + 24;
  uint64_t v38 = 31LL;
  uint64_t v39 = a2 + 272;
  uint64_t v40 = a3 + 272;
  uint64_t v41 = 31LL;
  *(void *)&__int128 v42 = a2 + 520;
  *((void *)&v42 + 1) = a3 + 520;
  *(void *)&__int128 v43 = 31LL;
  *((void *)&v43 + 1) = a2 + 16;
  *(void *)&__int128 v44 = a3 + 16;
  *((void *)&v44 + 1) = 1LL;
  uint64_t v45 = a2 + 8;
  uint64_t v46 = a3 + 8;
  uint64_t v47 = 1LL;
  uint64_t v48 = a3 + 24;
  uint64_t v49 = a3 + 272;
  uint64_t v50 = a2 + 768;
  uint64_t v51 = a3 + 768;
  uint64_t v52 = 128LL;
  uint64_t v53 = a2 + 1792;
  uint64_t v54 = a3 + 1792;
  uint64_t v55 = 16LL;
  uint64_t v56 = a2 + 10036;
  uint64_t v57 = a2 + 10100;
  uint64_t v58 = a3 + 10036;
  uint64_t v59 = a3 + 10100;
  uint64_t v60 = 16LL;
  uint64_t v61 = "setVertexBuffer:offset:atIndex:";
  uint64_t v62 = "setVertexBuffer:offset:attributeStride:atIndex:";
  uint64_t v63 = "setVertexAccelerationStructure:atBufferIndex:";
  id v64 = "setVertexIntersectionFunctionTable:atBufferIndex:";
  uint64_t v65 = "setVertexVisibleFunctionTable:atBufferIndex:";
  uint64_t v66 = "setVertexBytes:length:atIndex:";
  int v67 = "setVertexBytes:length:attributeStride:atIndex:";
  int v68 = "setVertexTextures:withRange:";
  uint64_t v69 = "setVertexSamplerStates:lodMinClamps:lodMaxClamps:withRange:";
  RestoreRenderStageResources(v22, &v36, v10);
  uint64_t v36 = a2 + 1928;
  uint64_t v37 = a3 + 1928;
  uint64_t v38 = 31LL;
  uint64_t v39 = a2 + 2176;
  uint64_t v40 = a3 + 2176;
  uint64_t v41 = 31LL;
  __int128 v42 = 0u;
  __int128 v43 = 0u;
  __int128 v44 = 0u;
  uint64_t v45 = a2 + 1920;
  uint64_t v46 = a3 + 1920;
  uint64_t v47 = 1LL;
  uint64_t v48 = a3 + 1928;
  uint64_t v49 = a3 + 2176;
  uint64_t v50 = a2 + 2424;
  uint64_t v51 = a3 + 2424;
  uint64_t v52 = 128LL;
  uint64_t v53 = a2 + 3448;
  uint64_t v54 = a3 + 3448;
  uint64_t v55 = 16LL;
  uint64_t v56 = a2 + 10164;
  uint64_t v57 = a2 + 10228;
  uint64_t v58 = a3 + 10164;
  uint64_t v59 = a3 + 10228;
  uint64_t v60 = 16LL;
  uint64_t v61 = "setFragmentBuffer:offset:atIndex:";
  uint64_t v62 = 0LL;
  uint64_t v63 = "setFragmentAccelerationStructure:atBufferIndex:";
  id v64 = "setFragmentIntersectionFunctionTable:atBufferIndex:";
  uint64_t v65 = "setFragmentVisibleFunctionTable:atBufferIndex:";
  uint64_t v66 = "setFragmentBytes:length:atIndex:";
  int v67 = 0LL;
  int v68 = "setFragmentTextures:withRange:";
  uint64_t v69 = "setFragmentSamplerStates:lodMinClamps:lodMaxClamps:withRange:";
  RestoreRenderStageResources(v35, &v36, v10);
  if (*(void *)(a2 + 9864) != *(void *)(a3 + 9864)
    || *(_DWORD *)(a2 + 10688) != *(_DWORD *)(a3 + 10688)
    || *(_DWORD *)(a2 + 10692) != *(_DWORD *)(a3 + 10692))
  {
    uint64_t v23 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v10, "bufferForKey:"));
    [v35 setTessellationFactorBuffer:v23 offset:*(unsigned int *)(a3 + 10688) instanceStride:*(unsigned int *)(a3 + 10692)];
  }

  id v24 = v35;
  if (*(float *)(a2 + 10676) != *(float *)(a3 + 10676))
  {
    objc_msgSend(v35, "setTessellationFactorScale:");
    id v24 = v35;
  }

  uint64_t v36 = a2 + 3584;
  uint64_t v37 = a3 + 3584;
  uint64_t v38 = 31LL;
  uint64_t v39 = a2 + 3832;
  uint64_t v40 = a3 + 3832;
  uint64_t v41 = 31LL;
  __int128 v42 = 0u;
  __int128 v43 = 0u;
  __int128 v44 = 0u;
  uint64_t v45 = a2 + 3576;
  uint64_t v46 = a3 + 3576;
  uint64_t v47 = 1LL;
  uint64_t v48 = a3 + 3584;
  uint64_t v49 = a3 + 3832;
  uint64_t v50 = a2 + 4080;
  uint64_t v51 = a3 + 4080;
  uint64_t v52 = 128LL;
  uint64_t v53 = a2 + 5104;
  uint64_t v54 = a3 + 5104;
  uint64_t v55 = 16LL;
  uint64_t v56 = a2 + 10292;
  uint64_t v57 = a2 + 10356;
  uint64_t v58 = a3 + 10292;
  uint64_t v59 = a3 + 10356;
  uint64_t v60 = 16LL;
  uint64_t v61 = "setObjectBuffer:offset:atIndex:";
  uint64_t v62 = 0LL;
  uint64_t v63 = "setObjectAccelerationStructure:atBufferIndex:";
  id v64 = "setObjectIntersectionFunctionTable:atBufferIndex:";
  uint64_t v65 = "setObjectVisibleFunctionTable:atBufferIndex:";
  uint64_t v66 = "setObjectBytes:length:atIndex:";
  int v67 = 0LL;
  int v68 = "setObjectTextures:withRange:";
  uint64_t v69 = "setObjectSamplerStates:lodMinClamps:lodMaxClamps:withRange:";
  RestoreRenderStageResources(v24, &v36, v10);
  for (uint64_t i = 0LL; i != 31; ++i)
  {
    uint64_t v26 = *(unsigned int *)(a3 + 10944 + 4 * i);
    if ((_DWORD)v26 != *(_DWORD *)(a2 + 10944 + 4 * i)) {
      [v35 setObjectThreadgroupMemoryLength:v26 atIndex:i];
    }
  }

  uint64_t v36 = a2 + 5240;
  uint64_t v37 = a3 + 5240;
  uint64_t v38 = 31LL;
  uint64_t v39 = a2 + 5488;
  uint64_t v40 = a3 + 5488;
  uint64_t v41 = 31LL;
  __int128 v42 = 0u;
  __int128 v43 = 0u;
  __int128 v44 = 0u;
  uint64_t v45 = a2 + 5232;
  uint64_t v46 = a3 + 5232;
  uint64_t v47 = 1LL;
  uint64_t v48 = a3 + 5240;
  uint64_t v49 = a3 + 5488;
  uint64_t v50 = a2 + 5736;
  uint64_t v51 = a3 + 5736;
  uint64_t v52 = 128LL;
  uint64_t v53 = a2 + 6760;
  uint64_t v54 = a3 + 6760;
  uint64_t v55 = 16LL;
  uint64_t v56 = a2 + 10420;
  uint64_t v57 = a2 + 10484;
  uint64_t v58 = a3 + 10420;
  uint64_t v59 = a3 + 10484;
  uint64_t v60 = 16LL;
  uint64_t v61 = "setMeshBuffer:offset:atIndex:";
  uint64_t v62 = 0LL;
  uint64_t v63 = "setMeshAccelerationStructure:atBufferIndex:";
  id v64 = "setMeshIntersectionFunctionTable:atBufferIndex:";
  uint64_t v65 = "setMeshVisibleFunctionTable:atBufferIndex:";
  uint64_t v66 = "setMeshBytes:length:atIndex:";
  int v67 = 0LL;
  int v68 = "setMeshTextures:withRange:";
  uint64_t v69 = "setMeshSamplerStates:lodMinClamps:lodMaxClamps:withRange:";
  RestoreRenderStageResources(v35, &v36, v10);
  if ((GT_SUPPORT_0 & 1) != 0)
  {
    uint64_t v36 = a2 + 6896;
    uint64_t v37 = a3 + 6896;
    uint64_t v38 = 31LL;
    uint64_t v39 = a2 + 7144;
    uint64_t v40 = a3 + 7144;
    uint64_t v41 = 31LL;
    __int128 v42 = 0u;
    __int128 v43 = 0u;
    __int128 v44 = 0u;
    uint64_t v45 = a2 + 6888;
    uint64_t v46 = a3 + 6888;
    uint64_t v47 = 1LL;
    uint64_t v48 = a3 + 6896;
    uint64_t v49 = a3 + 7144;
    uint64_t v50 = a2 + 7392;
    uint64_t v51 = a3 + 7392;
    uint64_t v52 = 128LL;
    uint64_t v53 = a2 + 8416;
    uint64_t v54 = a3 + 8416;
    uint64_t v55 = 16LL;
    uint64_t v56 = a2 + 10548;
    uint64_t v57 = a2 + 10612;
    uint64_t v58 = a3 + 10548;
    uint64_t v59 = a3 + 10612;
    uint64_t v60 = 16LL;
    uint64_t v61 = "setTileBuffer:offset:atIndex:";
    uint64_t v62 = 0LL;
    uint64_t v63 = "setTileAccelerationStructure:atBufferIndex:";
    id v64 = "setTileIntersectionFunctionTable:atBufferIndex:";
    uint64_t v65 = "setTileVisibleFunctionTable:atBufferIndex:";
    uint64_t v66 = "setTileBytes:length:atIndex:";
    int v67 = 0LL;
    int v68 = "setTileTextures:withRange:";
    uint64_t v69 = "setTileSamplerStates:lodMinClamps:lodMaxClamps:withRange:";
    RestoreRenderStageResources(v35, &v36, v10);
    uint64_t v27 = 0LL;
    uint64_t v28 = (unsigned int *)(a3 + 10820);
    uint64_t v29 = (_DWORD *)(a2 + 10820);
    do
    {
      ++v28;
      ++v27;
      ++v29;
    }

    while (v27 != 31);
  }

  uint64_t v30 = 0LL;
  uint64_t v31 = (void *)(a3 + 9936);
  uint64_t v32 = (void *)(a2 + 9936);
  uint64_t v33 = v35;
  do
  {
    if (*(v32 - 8) != *(v31 - 8))
    {
      objc_msgSend(v33, "setColorStoreAction:atIndex:");
      uint64_t v33 = v35;
    }

    if (*v32 != *v31)
    {
      objc_msgSend(v33, "setColorStoreActionOptions:atIndex:");
      uint64_t v33 = v35;
    }

    ++v31;
    ++v30;
    ++v32;
  }

  while (v30 != 8);
  if (*(unsigned __int8 *)(v8 + 1074) != *(unsigned __int8 *)(v7 + 1074))
  {
    objc_msgSend(v33, "setDepthStoreAction:");
    uint64_t v33 = v35;
  }

  if (*(unsigned __int8 *)(v8 + 1076) != *(unsigned __int8 *)(v7 + 1076))
  {
    objc_msgSend(v33, "setDepthStoreActionOptions:");
    uint64_t v33 = v35;
  }

  if (*(unsigned __int8 *)(v8 + 1075) != *(unsigned __int8 *)(v7 + 1075))
  {
    objc_msgSend(v33, "setStencilStoreAction:");
    uint64_t v33 = v35;
  }

  if (*(unsigned __int8 *)(v8 + 1077) != *(unsigned __int8 *)(v7 + 1077))
  {
    objc_msgSend(v33, "setStencilStoreActionOptions:");
    uint64_t v33 = v35;
  }

  if (*(float *)(a2 + 10680) != *(float *)(a3 + 10680))
  {
    objc_msgSend(v33, "setLineWidth:");
    uint64_t v33 = v35;
  }

  int v34 = *(unsigned __int8 *)(v7 + 1078);
}

void RestoreRenderStageResources(void *a1, uint64_t *a2, void *a3)
{
  id v5 = a1;
  id v6 = a3;
  unint64_t v7 = CompareObjectIdRange(*a2, a2[1], a2[2]);
  NSUInteger v9 = v8;
  NSUInteger v10 = CompareObjectIdRange(a2[3], a2[4], a2[5]);
  v12.NSUInteger length = v11;
  if (v9) {
    NSUInteger v13 = v7;
  }
  else {
    NSUInteger v13 = v10;
  }
  if (v11) {
    v12.locatiouint64_t n = v10;
  }
  else {
    v12.locatiouint64_t n = v13;
  }
  v69.locatiouint64_t n = v13;
  v69.NSUInteger length = v9;
  NSRange v14 = NSUnionRange(v69, v12);
  NSRange v67 = v14;
  if (!v14.length) {
    goto LABEL_39;
  }
  locatiouint64_t n = v14.location;
  NSUInteger length = v14.length;
  do
  {
    *(void *)&v68[0] = location;
    if (((*(void *)(a2[13] + ((location >> 3) & 0x1FFFFFFFFFFFFFF8LL)) >> location) & 1) == 0
      && *(void *)(a2[1] + 8 * location))
    {
      uint64_t v66 = (_OWORD *)objc_claimAutoreleasedReturnValue(objc_msgSend(v6, "resourceForKey:"));
      if ([v66 conformsToProtocol:&OBJC_PROTOCOL___MTLBuffer])
      {
        NSUInteger v65 = *(void *)(a2[4] + 8LL * *(void *)&v68[0]);
        uint64_t v17 = a2[10];
        if (v17
          && ((*(void *)(v17 + ((*(void *)&v68[0] >> 3) & 0x1FFFFFFFFFFFFFF8LL)) >> SLOBYTE(v68[0])) & 1) != 0)
        {
          NSUInteger v64 = *(void *)(a2[7] + 8LL * *(void *)&v68[0]);
          double v18 = (void *)objc_claimAutoreleasedReturnValue([v5 methodSignatureForSelector:a2[29]]);
          double v19 = (void *)objc_claimAutoreleasedReturnValue( +[NSInvocation invocationWithMethodSignature:]( &OBJC_CLASS___NSInvocation,  "invocationWithMethodSignature:",  v18));

          [v19 setSelector:a2[29]];
          [v19 setTarget:v5];
          [v19 setArgument:&v66 atIndex:2];
          [v19 setArgument:&v65 atIndex:3];
          [v19 setArgument:&v64 atIndex:4];
          double v20 = v19;
          uint64_t v21 = 5LL;
        }

        else
        {
          uint64_t v25 = (void *)objc_claimAutoreleasedReturnValue([v5 methodSignatureForSelector:a2[28]]);
          double v19 = (void *)objc_claimAutoreleasedReturnValue( +[NSInvocation invocationWithMethodSignature:]( &OBJC_CLASS___NSInvocation,  "invocationWithMethodSignature:",  v25));

          [v19 setSelector:a2[28]];
          [v19 setTarget:v5];
          [v19 setArgument:&v66 atIndex:2];
          [v19 setArgument:&v65 atIndex:3];
          double v20 = v19;
          uint64_t v21 = 4LL;
        }
      }

      else
      {
        if ([v66 conformsToProtocol:&OBJC_PROTOCOL___MTLAccelerationStructure] && a2[30])
        {
          uint64_t v22 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v5, "methodSignatureForSelector:"));
          double v19 = (void *)objc_claimAutoreleasedReturnValue( +[NSInvocation invocationWithMethodSignature:]( &OBJC_CLASS___NSInvocation,  "invocationWithMethodSignature:",  v22));

          uint64_t v23 = a2[30];
        }

        else if ([v66 conformsToProtocol:&OBJC_PROTOCOL___MTLIntersectionFunctionTable] {
               && a2[31])
        }
        {
          id v24 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v5, "methodSignatureForSelector:"));
          double v19 = (void *)objc_claimAutoreleasedReturnValue( +[NSInvocation invocationWithMethodSignature:]( &OBJC_CLASS___NSInvocation,  "invocationWithMethodSignature:",  v24));

          uint64_t v23 = a2[31];
        }

        else
        {
          if (![v66 conformsToProtocol:&OBJC_PROTOCOL___MTLVisibleFunctionTable]
            || !a2[32])
          {
            goto LABEL_27;
          }

          uint64_t v26 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v5, "methodSignatureForSelector:"));
          double v19 = (void *)objc_claimAutoreleasedReturnValue( +[NSInvocation invocationWithMethodSignature:]( &OBJC_CLASS___NSInvocation,  "invocationWithMethodSignature:",  v26));

          uint64_t v23 = a2[32];
        }

        [v19 setSelector:v23];
        [v19 setTarget:v5];
        [v19 setArgument:&v66 atIndex:2];
        double v20 = v19;
        uint64_t v21 = 3LL;
      }

      [v20 setArgument:v68 atIndex:v21];
      [v19 invoke];

LABEL_27:
    }

    ++location;
    --length;
  }

  while (length);
  if (a2[14])
  {
    unint64_t v27 = 0LL;
    do
    {
      int v28 = 0;
      int v29 = (_DWORD)v27 << 6;
      do
      {
        unint64_t v30 = *(void *)(a2[13] + 8 * v27) >> v28;
        if (!v30) {
          break;
        }
        int v31 = v28 + __clz(__rbit64(v30));
        *(void *)&v68[0] = v31 + v29;
        uint64_t v32 = a2[10];
        if (v32
          && ((*(void *)(v32 + (((unint64_t)(v31 + v29) >> 3) & 0x1FFFFFFFFFFFFFF8LL)) >> (v31
                                                                                                  + v29)) & 1) != 0)
        {
          uint64_t v33 = (void *)objc_claimAutoreleasedReturnValue([v5 methodSignatureForSelector:a2[34]]);
          int v34 = (void *)objc_claimAutoreleasedReturnValue( +[NSInvocation invocationWithMethodSignature:]( &OBJC_CLASS___NSInvocation,  "invocationWithMethodSignature:",  v33));

          [v34 setSelector:a2[34]];
          [v34 setTarget:v5];
          [v34 setArgument:a2[15] + 8 * *(void *)&v68[0] atIndex:2];
          [v34 setArgument:a2[16] + 8 * *(void *)&v68[0] atIndex:3];
          [v34 setArgument:a2[7] + 8 * *(void *)&v68[0] atIndex:4];
          id v35 = v34;
          uint64_t v36 = 5LL;
        }

        else
        {
          uint64_t v37 = (void *)objc_claimAutoreleasedReturnValue([v5 methodSignatureForSelector:a2[33]]);
          int v34 = (void *)objc_claimAutoreleasedReturnValue( +[NSInvocation invocationWithMethodSignature:]( &OBJC_CLASS___NSInvocation,  "invocationWithMethodSignature:",  v37));

          [v34 setSelector:a2[33]];
          [v34 setTarget:v5];
          [v34 setArgument:a2[15] + 8 * *(void *)&v68[0] atIndex:2];
          [v34 setArgument:a2[16] + 8 * *(void *)&v68[0] atIndex:3];
          id v35 = v34;
          uint64_t v36 = 4LL;
        }

        [v35 setArgument:v68 atIndex:v36];
        [v34 invoke];

        int v28 = v31 + 1;
      }

      while (v31 < 63);
      ++v27;
    }

    while (a2[14] > v27);
  }

unint64_t CompareObjectIdRange(uint64_t a1, uint64_t a2, unint64_t a3)
{
  unint64_t v3 = 0LL;
  if (a3)
  {
    while (*(void *)(a1 + 8 * v3) == *(void *)(a2 + 8 * v3))
    {
      if (a3 == ++v3)
      {
        unint64_t v3 = a3;
        break;
      }
    }
  }

  if (v3 >= a3) {
    unint64_t v4 = a3;
  }
  else {
    unint64_t v4 = v3;
  }
  while (v3 < a3)
  {
    unint64_t v5 = a3 - 1;
    uint64_t v6 = *(void *)(a1 - 8 + 8 * a3);
    uint64_t v7 = *(void *)(a2 - 8 + 8 * a3--);
    if (v6 != v7)
    {
      unint64_t v4 = v5 + 1;
      break;
    }
  }

  if (v4 == v3) {
    return 0LL;
  }
  else {
    return v3;
  }
}

unint64_t CompareFloatRange(uint64_t a1, uint64_t a2, unint64_t a3)
{
  unint64_t v3 = 0LL;
  if (a3)
  {
    while (*(float *)(a1 + 4 * v3) == *(float *)(a2 + 4 * v3))
    {
      if (a3 == ++v3)
      {
        unint64_t v3 = a3;
        break;
      }
    }
  }

  if (v3 >= a3) {
    unint64_t v4 = a3;
  }
  else {
    unint64_t v4 = v3;
  }
  while (v3 < a3)
  {
    unint64_t v5 = a3 - 1;
    float v6 = *(float *)(a1 - 4 + 4 * a3);
    float v7 = *(float *)(a2 - 4 + 4 * a3--);
    if (v6 != v7)
    {
      unint64_t v4 = v5 + 1;
      break;
    }
  }

  if (v4 == v3) {
    return 0LL;
  }
  else {
    return v3;
  }
}

void GTMTLReplayController_restoreDefaultRenderCommandEncoder( void *a1, unint64_t a2, unint64_t a3, uint64_t *a4, void *a5)
{
  uint64_t v9 = *a4;
  id v10 = a5;
  id v11 = a1;
  GTMTLSMRenderCommandEncoder_init((uint64_t)v12, v9);
  uint64_t v13 = 1LL;
  double v14 = (double)a2;
  double v15 = (double)a3;
  uint64_t v16 = 0x3FF0000000000000LL;
  uint64_t v17 = 1LL;
  unint64_t v18 = a2;
  unint64_t v19 = a3;
  GTMTLReplayController_restoreRenderCommandEncoder(v11, (uint64_t)v12, (uint64_t)a4, v10);
}

void GTMTLReplayController_restoreComputeCommandEncoder(void *a1, uint64_t a2, uint64_t a3, void *a4)
{
  id v7 = a1;
  id v8 = a4;
  uint64_t v9 = v8;
  uint64_t v10 = *(void *)(a3 + 8);
  if (*(void *)(a2 + 8) != v10 && v10 != 0)
  {
    NSRange v12 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v8, "computePipelineStateForKey:"));
    [v7 setComputePipelineState:v12];
  }

  unint64_t v13 = CompareObjectIdRange(a2 + 32, a3 + 32, 0x1FuLL);
  NSUInteger v15 = v14;
  NSUInteger v16 = CompareObjectIdRange(a2 + 280, a3 + 280, 0x1FuLL);
  v18.NSUInteger length = v17;
  if (v15) {
    NSUInteger v19 = v13;
  }
  else {
    NSUInteger v19 = v16;
  }
  if (v17) {
    v18.locatiouint64_t n = v16;
  }
  else {
    v18.locatiouint64_t n = v19;
  }
  v69.locatiouint64_t n = v19;
  v69.NSUInteger length = v15;
  NSRange v20 = NSUnionRange(v69, v18);
  uint64_t v60 = a2;
  if (v20.length)
  {
    locatiouint64_t n = v20.location;
    NSUInteger length = v20.length;
    uint64_t v59 = a3 + 32;
    uint64_t v23 = (uint64_t *)(a3 + 8 * v20.location + 280);
    do
    {
      if ((*(void *)(a3 + 8 * (location >> 6) + 16) & (1LL << location)) == 0 && *(v23 - 31) != 0)
      {
        uint64_t v25 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v9, "resourceForKey:"));
        if ([v25 conformsToProtocol:&OBJC_PROTOCOL___MTLBuffer])
        {
          uint64_t v26 = *v23;
          if ((*(void *)(a3 + 8 * (location >> 6) + 24) & (1LL << location)) != 0) {
            [v7 setBuffer:v25 offset:v26 attributeStride:v23[31] atIndex:location];
          }
          else {
            [v7 setBuffer:v25 offset:v26 atIndex:location];
          }
        }

        else if ([v25 conformsToProtocol:&OBJC_PROTOCOL___MTLAccelerationStructure])
        {
          [v7 setAccelerationStructure:v25 atBufferIndex:location];
        }

        else if ([v25 conformsToProtocol:&OBJC_PROTOCOL___MTLIntersectionFunctionTable])
        {
          [v7 setIntersectionFunctionTable:v25 atBufferIndex:location];
        }

        else if ([v25 conformsToProtocol:&OBJC_PROTOCOL___MTLVisibleFunctionTable])
        {
          [v7 setVisibleFunctionTable:v25 atBufferIndex:location];
        }
      }

      ++location;
      ++v23;
      --length;
    }

    while (length);
    int v27 = 0;
    a2 = v60;
    do
    {
      unint64_t v28 = *(void *)(a3 + 16) >> v27;
      if (!v28) {
        break;
      }
      int v29 = __clz(__rbit64(v28));
      unint64_t v30 = v27 + v29;
      if (((*(void *)(a3 + 8 * (v30 >> 6) + 24) >> (v27 + v29)) & 1) != 0) {
        [v7 setBytes:*(void *)(v59 + 8 * v30) length:*(void *)(a3 + 8 * v30 + 280) attributeStride:*(void *)(a3 + 8 * v30 + 528) atIndex:v30];
      }
      else {
        [v7 setBytes:*(void *)(v59 + 8 * v30) length:*(void *)(a3 + 8 * v30 + 280) atIndex:v30];
      }
      int v27 = v30 + 1;
    }

    while ((int)v30 < 63);
  }

  unint64_t v31 = CompareObjectIdRange(a2 + 776, a3 + 776, 0x80uLL);
  if (v32)
  {
    unint64_t v33 = v31;
    uint64_t v34 = v32;
    bzero(&v61, 0x400uLL);
    for (uint64_t i = 0LL; i != v34; ++i)
    {
      uint64_t v36 = objc_claimAutoreleasedReturnValue(objc_msgSend(v9, "textureForKey:", *(void *)(a3 + 8 * v33 + 776 + 8 * i), v59));
      uint64_t v37 = (void *)*((void *)&v61 + i);
      *((void *)&v61 + i) = v36;
    }

    objc_msgSend(v7, "setTextures:withRange:", &v61, v33, v34);
    for (uint64_t j = 1016LL; j != -8; j -= 8LL)
  }

  unint64_t v39 = CompareObjectIdRange(a2 + 1800, a3 + 1800, 0x10uLL);
  NSUInteger v41 = v40;
  NSUInteger v42 = CompareFloatRange(a2 + 2120, a3 + 2120, 0x10uLL);
  v44.NSUInteger length = v43;
  if (v41) {
    NSUInteger v45 = v39;
  }
  else {
    NSUInteger v45 = v42;
  }
  if (v43) {
    v44.locatiouint64_t n = v42;
  }
  else {
    v44.locatiouint64_t n = v45;
  }
  v70.locatiouint64_t n = v45;
  v70.NSUInteger length = v41;
  NSRange v46 = NSUnionRange(v70, v44);
  NSUInteger v47 = CompareFloatRange(a2 + 2184, a3 + 2184, 0x10uLL);
  v49.NSUInteger length = v48;
  if (v46.length) {
    NSUInteger v50 = v46.location;
  }
  else {
    NSUInteger v50 = v47;
  }
  if (v48) {
    v49.locatiouint64_t n = v47;
  }
  else {
    v49.locatiouint64_t n = v50;
  }
  v71.locatiouint64_t n = v50;
  v71.NSUInteger length = v46.length;
  NSRange v51 = NSUnionRange(v71, v49);
  if (v51.length)
  {
    uint64_t v52 = 0LL;
    __int128 v67 = 0u;
    __int128 v68 = 0u;
    __int128 v65 = 0u;
    __int128 v66 = 0u;
    __int128 v63 = 0u;
    __int128 v64 = 0u;
    __int128 v61 = 0u;
    __int128 v62 = 0u;
    do
    {
      uint64_t v53 = objc_claimAutoreleasedReturnValue(objc_msgSend(v9, "samplerStateForKey:", *(void *)(a3
                                                                                                + 8 * v51.location
                                                                                                + 1800
                                                                                                + 8 * v52), v59));
      NSUInteger v54 = (void *)*((void *)&v61 + v52);
      *((void *)&v61 + v52) = v53;

      ++v52;
    }

    while (v51.length != v52);
    objc_msgSend( v7,  "setSamplerStates:lodMinClamps:lodMaxClamps:withRange:",  &v61,  a3 + 2120 + 4 * v51.location,  a3 + 2184 + 4 * v51.location,  v51.location,  v51.length);
    for (uint64_t k = 120LL; k != -8; k -= 8LL)

    a2 = v60;
  }

  for (uint64_t m = 0LL; m != 31; ++m)
  {
    if (*(_DWORD *)(a2 + 1984 + 4 * m) != *(_DWORD *)(a3 + 1984 + 4 * m)) {
      objc_msgSend(v7, "setThreadgroupMemoryLength:atIndex:");
    }
  }

  if ((GT_SUPPORT_0 & 0x200) != 0 && *(_DWORD *)(a3 + 2108) && *(_DWORD *)(a3 + 2112)) {
    objc_msgSend(v7, "setImageblockWidth:height:");
  }
  unint64_t v57 = (__int128 *)(a3 + 1928);
  if (memcmp((const void *)(a2 + 1928), v57, 0x30uLL))
  {
    __int128 v58 = v57[1];
    __int128 v61 = *v57;
    __int128 v62 = v58;
    __int128 v63 = v57[2];
    [v7 setStageInRegion:&v61];
  }
}

uint64_t GTMTLReplayController_renderPassDescriptor(uint64_t a1)
{
  unint64_t v1 = *(void *)(*(void *)a1 + 80LL) + *(unsigned int *)(a1 + 22480);
  if (*(void *)(a1 + 184) <= v1)
  {
    if (*(void *)(a1 + 11336) <= v1) {
      return 0LL;
    }
    uint64_t v2 = a1 + 11312;
  }

  else
  {
    uint64_t v2 = a1 + 160;
  }

  if (*(_DWORD *)v2 == 70 || *(_DWORD *)v2 == 65) {
    return *(void *)(v2 + 56);
  }
  return 0LL;
}

void GTMTLReplayController_updateCommandEncoder(uint64_t a1, uint64_t a2)
{
  unint64_t v4 = objc_autoreleasePoolPush();
  int v5 = IsFuncEnumParallelCommandEncoderCall(*(_DWORD *)(a2 + 8));
  uint64_t v6 = 11312LL;
  if (v5) {
    uint64_t v6 = 160LL;
  }
  uint64_t v7 = a1 + v6;
  GTMTLSMCommandEncoder_processTraceFunc(a1 + v6, (uint64_t *)a2, *(void *)(*(void *)a1 + 16LL));
  int v8 = *(_DWORD *)(a2 + 8);
  switch(v8)
  {
    case -16353:
      goto LABEL_6;
    case -16286:
      unint64_t v20 = *(void *)(a1 + 22464);
      unint64_t v21 = *(void *)(a1 + 22472);
      *(void *)(v7 + 860_Block_object_dispose((const void *)(v12 - 64), 8) = 1LL;
      *(double *)(v7 + 8632) = (double)v20;
      *(double *)(v7 + 8640) = (double)v21;
      *(void *)(v7 + 8656) = 0x3FF0000000000000LL;
      *(void *)(v7 + 9384) = 1LL;
      *(void *)(v7 + 940_Block_object_dispose((const void *)(v12 - 64), 8) = v20;
      *(void *)(v7 + 9416) = v21;
      break;
    case -16351:
LABEL_6:
      uint64_t v9 = GTMTLReplayController_renderPassDescriptor(a1);
      id v10 = *(id *)(a1 + 8);
      id v11 = (void *)objc_claimAutoreleasedReturnValue([v10 renderPassDescriptorMap]);
      MTLuint64_t RenderPassDescriptor = MakeMTLRenderPassDescriptor(v9, v11);
      unint64_t v13 = (void *)objc_claimAutoreleasedReturnValue(MTLRenderPassDescriptor);

      if ((GT_SUPPORT_0 & 0x400) != 0
        && (uint64_t v14 = objc_claimAutoreleasedReturnValue([v13 rasterizationRateMap])) != 0)
      {
        NSUInteger v15 = (void *)v14;
        id v16 = [v13 renderTargetWidth];
        id v25 = v16;
        id v17 = [v13 renderTargetHeight];
        unint64_t v18 = (unint64_t)v17;
        unint64_t v24 = (unint64_t)v17;
        if (v16)
        {
          if (!v17) {
            goto LABEL_16;
          }
        }

        else
        {
          [v15 screenSize];
          id v16 = v23;
          id v25 = v23;
          if (!v18)
          {
LABEL_16:
            [v15 screenSize];
            unint64_t v18 = v22;
            unint64_t v24 = v22;
          }
        }
      }

      else
      {
        NSUInteger v19 = (void *)objc_claimAutoreleasedReturnValue([v10 defaultDevice]);
        [v13 validate:v19 width:&v25 height:&v24];

        NSUInteger v15 = 0LL;
        unint64_t v18 = v24;
        id v16 = v25;
      }

      *(void *)(a1 + 22464) = v16;
      *(void *)(a1 + 22472) = v18;
      *(void *)(v7 + 860_Block_object_dispose((const void *)(v12 - 64), 8) = 1LL;
      *(double *)(v7 + 8632) = (double)(unint64_t)v16;
      *(double *)(v7 + 8640) = (double)v18;
      *(void *)(v7 + 8656) = 0x3FF0000000000000LL;
      *(void *)(v7 + 9384) = 1LL;
      *(void *)(v7 + 940_Block_object_dispose((const void *)(v12 - 64), 8) = v16;
      *(void *)(v7 + 9416) = v18;

      break;
  }

  objc_autoreleasePoolPop(v4);
}

void GTMTLReplayController_playTo(uint64_t a1, unint64_t a2)
{
  uint64_t v2 = (unsigned int *)(a1 + 22480);
  if (*(unsigned int *)(a1 + 22480) < a2)
  {
    uint64_t v5 = *(void *)(*(void *)a1 + 120LL);
    do
    {
      uint64_t v6 = objc_autoreleasePoolPush();
      uint64_t v7 = *(void *)(v5 + 24) + ((unint64_t)*v2 << 6);
      GTMTLReplayController_updateCommandEncoder(a1, v7);
      if (*(_DWORD *)(v7 + 8) >> 2 == 1073737833) {
        GTMTLReplayController_executeCommandsInBuffer((uint64_t *)a1, (unint64_t *)v7, 0LL, 0xFFFFFFFFFFFFFFFFLL);
      }
      else {
        GTMTLReplayController_defaultDispatchFunction(a1, v7);
      }
      objc_autoreleasePoolPop(v6);
      unint64_t v8 = *v2 + 1;
      unsigned int *v2 = v8;
    }

    while (v8 < a2);
  }

  v2[1] = 0;
}

void GTMTLReplayController_executeCommandsInBuffer( uint64_t *a1, unint64_t *a2, NSUInteger a3, NSUInteger a4)
{
  uint64_t v8 = *a1;
  GetExecuteCommandsInBufferArgs((uint64_t)&v25, (uint64_t)a2, *(void *)(*a1 + 16));
  v28.locatiouint64_t n = a3;
  v28.NSUInteger length = a4;
  NSRange v9 = NSIntersectionRange(v28, v26);
  if (v9.length)
  {
    p = *(apr_pool_t **)a1[19];
    GTMTLSMContext_indirectCommandBufferResources((uint64_t)v23, *(_DWORD ***)(v8 + 40), *a2, p);
    uint64_t Object = GTMTLSMContext_getObject(**(void **)(v8 + 40), v25, *a2);
    GTMTLCreateIndirectCommandEncoder((uint64_t)v22, Object[13]);
    id v11 = (id)a1[1];
    NSRange v12 = (void *)objc_claimAutoreleasedReturnValue([v11 defaultDevice]);
    uint64_t v13 = v22[0];
    MTLIndirectCommandBufferDescriptorWithoutResourceIndex = MakeMTLIndirectCommandBufferDescriptorWithoutResourceIndex(v22[0]);
    NSUInteger v15 = (void *)objc_claimAutoreleasedReturnValue(MTLIndirectCommandBufferDescriptorWithoutResourceIndex);
    id v16 = [v12 newIndirectCommandBufferWithDescriptor:v15 maxCommandCount:v9.length options:0];

    uint64_t v17 = v27 + v22[13] * v9.location;
    unint64_t v18 = (void *)objc_claimAutoreleasedReturnValue([v11 restoreIndirectCommandBufferDataMap]);
    GTMTLEncodeIndirectCommandBufferWithRange(v16, 0LL, v9.length, v13, v17, v23, v18);

    int v19 = *((_DWORD *)a1 + 2828);
    if (v19 == 28)
    {
      if ((GT_SUPPORT_0 & 0x10) != 0)
      {
        unint64_t v20 = (void *)objc_claimAutoreleasedReturnValue([v11 computeCommandEncoderForKey:a1[1415]]);
        goto LABEL_7;
      }
    }

    else if (v19 == 70)
    {
      unint64_t v20 = (void *)objc_claimAutoreleasedReturnValue([v11 renderCommandEncoderForKey:a1[1415]]);
LABEL_7:
      unint64_t v21 = v20;
      objc_msgSend(v20, "executeCommandsInBuffer:withRange:", v16, 0, v9.length);
    }

    apr_pool_clear(p);
  }

id GTMTLReplayController_debugSubCommandStop(uint64_t a1, unsigned int a2, uint64_t a3)
{
  return [(id)g_activityLog leaveActivity];
}

void sub_E299C(_Unwind_Exception *a1)
{
}

unsigned int *GTMTLReplayController_debugSubCommand(unsigned int *result, unsigned int a2, uint64_t a3)
{
  unsigned int v3 = a3;
  uint64_t v4 = (uint64_t)result;
  uint64_t v5 = result + 5620;
  uint64_t v6 = *(void *)(*(void *)result + 120LL);
  unsigned int v7 = *(_DWORD *)(v6 + 12);
  if (v7 >= a2) {
    unint64_t v8 = a2;
  }
  else {
    unint64_t v8 = v7;
  }
  if (*v5 == (_DWORD)v8)
  {
    unsigned int v9 = result[5621];
    if (v9 == (_DWORD)a3) {
      return result;
    }
    BOOL v10 = v9 < a3;
  }

  else
  {
    BOOL v10 = 1;
  }

  if (s_logUsingOsLog)
  {
    id v11 = gt_default_log();
    NSRange v12 = (os_log_s *)objc_claimAutoreleasedReturnValue(v11);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 67109376;
      *(_DWORD *)&uint8_t buf[4] = v8;
      LOWORD(v15_Block_object_dispose((const void *)(v12 - 64), 8) = 1024;
      *(_DWORD *)((char *)&v158 + 2) = v3;
      _os_log_impl( &dword_0,  v12,  OS_LOG_TYPE_INFO,  "debugSubCommand - functionIndex: %u, subCommandIndex: %u",  buf,  0xEu);
    }
  }

  else
  {
    uint64_t v13 = __stdoutp;
    id v14 = objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString, "stringWithFormat:", @"debugSubCommand - functionIndex: %u, subCommandIndex: %u", v8, a3));
    fprintf(v13, "%s\n", (const char *)[v14 UTF8String]);
  }

  char v15 = !v10;
  if ((v15 & 1) != 0 || (dword_5B9DE4 & 0x1000) != 0) {
    GTMTLReplayController_rewind(v4);
  }
  uint64_t v16 = *(void *)(*(void *)v4 + 112LL);
  int v17 = *(_DWORD *)(v16 + 12);
  unint64_t v18 = *(void **)(v16 + 24);
  unint64_t v143 = (v8 - 1);
  InclusiveRange = GroupBuilder_findInclusiveRange(v17, v18, v143);
  if (InclusiveRange)
  {
    while (1)
    {
      int v20 = *((_DWORD *)InclusiveRange + 7);
      if (v20 == -16353 || v20 == -16351) {
        break;
      }
      uint64_t v22 = *((unsigned int *)InclusiveRange + 4);
      if ((_DWORD)v22) {
        BOOL v23 = InclusiveRange == 0LL;
      }
      else {
        BOOL v23 = 1;
      }
      InclusiveRange -= 4 * v22;
      if (v23)
      {
        InclusiveRange = 0LL;
        break;
      }
    }
  }

  unint64_t v24 = *v5;
  ExclusiveRange = GroupBuilder_findExclusiveRange(v17, v18, (v24 - 1));
  if (ExclusiveRange)
  {
    NSRange v26 = ExclusiveRange;
    while (1)
    {
      int v27 = *((_DWORD *)v26 + 7);
      if (v27 == -16353 || v27 == -16351) {
        break;
      }
      uint64_t v29 = *((unsigned int *)v26 + 4);
      if ((_DWORD)v29) {
        BOOL v30 = v26 == 0LL;
      }
      else {
        BOOL v30 = 1;
      }
      v26 -= 4 * v29;
      if (v30)
      {
        NSRange v26 = 0LL;
        uint64_t v31 = 0LL;
        goto LABEL_44;
      }
    }

    if (v26 == InclusiveRange) {
      uint64_t v31 = (*v26 < v24) | 2u;
    }
    else {
      uint64_t v31 = *v26 < v24;
    }
LABEL_44:
    GTMTLReplayController_restoreGroup((unsigned int *)v4, (uint64_t)ExclusiveRange, v31);
    if (!(_DWORD)v8) {
      goto LABEL_51;
    }
  }

  else
  {
    NSRange v26 = 0LL;
    if (!(_DWORD)v8)
    {
LABEL_51:
      uint64_t v33 = 0LL;
      uint64_t v34 = 0LL;
      goto LABEL_52;
    }
  }

  uint64_t v32 = *(void *)(v6 + 24);
  if (!v32) {
    goto LABEL_51;
  }
  uint64_t v33 = v32 + (v143 << 6);
  if (*(_DWORD *)(v33 + 8) >> 2 == 1073737833) {
    uint64_t v34 = (unint64_t *)(v32 + (v143 << 6));
  }
  else {
    uint64_t v34 = 0LL;
  }
LABEL_52:
  if (*v5)
  {
    uint64_t v35 = *(void *)(v6 + 24);
    if (v35)
    {
      uint64_t v36 = v35 + ((unint64_t)(*v5 - 1) << 6);
      if (*(_DWORD *)(v36 + 8) >> 2 == 1073737833)
      {
        unsigned int v37 = v5[1];
        NSUInteger v38 = v37 + 1;
        NSUInteger v39 = v3 - v37;
        if ((unint64_t *)v36 == v34)
        {
          uint64_t v34 = 0LL;
          NSUInteger v40 = v39;
        }

        else
        {
          NSUInteger v40 = ~v38;
        }

        GTMTLReplayController_executeCommandsInBuffer((uint64_t *)v4, (unint64_t *)v36, v38, v40);
      }
    }
  }

  if (InclusiveRange)
  {
    if (v26 != InclusiveRange)
    {
      uint64_t v142 = v16;
      GTMTLReplayController_playTo(v4, *InclusiveRange);
      GTMTLReplayController_updateCommandEncoder(v4, *(void *)(v6 + 24) + (*InclusiveRange << 6));
      GTMTLReplayController_tileMemoryFree(v4);
      uint64_t v41 = GTMTLReplayController_renderPassDescriptor(v4);
      unint64_t v42 = *(void *)(*(void *)v4 + 80LL) + *v5;
      for (uint64_t i = 8LL; i != 520; i += 64LL)
        AddMemorylessTexture((uint64_t *)v4, *(void *)(v41 + i), v42);
      AddMemorylessTexture((uint64_t *)v4, *(void *)(v41 + 680), v42);
      AddMemorylessTexture((uint64_t *)v4, *(void *)(v41 + 728), v42);
      int v44 = 0;
      if (*(_WORD *)(v41 + 814) && *(_WORD *)(v41 + 812)) {
        int v44 = ((unint64_t)*(unsigned __int16 *)(v41 + 812) + *(void *)(v4 + 22472) - 1)
      }
            / *(unsigned __int16 *)(v41 + 812)
      if ((GT_SUPPORT_0 & 1) != 0
        && v44
        && !((*(_DWORD *)(v41 + 800) + *(unsigned __int16 *)(v41 + 804) < 0) ^ __OFADD__( *(_DWORD *)(v41 + 800),  *(unsigned __int16 *)(v41 + 804)) | (*(_DWORD *)(v41 + 800) + *(unsigned __int16 *)(v41 + 804) == 0)))
      {
        uint64_t v133 = *(unsigned int *)(v41 + 800);
        unint64_t v135 = *(unsigned __int16 *)(v41 + 804);
        uint64_t v131 = v34;
        uint64_t v132 = v33;
        unint64_t v138 = v8;
        unint64_t v139 = v5;
        unsigned int v140 = v3;
        uint64_t v137 = v44;
        id v144 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v4 + 8) defaultDevice]);
        NSUInteger v45 = objc_alloc_init(&OBJC_CLASS___MTLTileRenderPipelineDescriptor);
        uint64_t v141 = (void *)v4;
        uint64_t v128 = v41;
        FillAttachmentPixelFormats(v41, *(uint64_t **)(*(void *)v4 + 40LL), v42, v45);
        uint64_t v46 = 0LL;
        uint64_t v47 = 0LL;
        do
        {
          NSUInteger v48 = v45;
          NSRange v49 = (void *)objc_claimAutoreleasedReturnValue(-[MTLTileRenderPipelineDescriptor colorAttachments](v45, "colorAttachments"));
          NSUInteger v50 = (void *)objc_claimAutoreleasedReturnValue([v49 objectAtIndexedSubscript:v46]);
          id v51 = [v50 pixelFormat];

          if (v51)
          {
            v155.i64[v47] = (uint64_t)v51;
            uint64_t v52 = v47 + 1;
            uint64_t v53 = &buf[56 * v47];
            GTMTLPixelFormatGetInfoForDevice((uint64_t)v153, (uint64_t)v144, (uint64_t)v51);
            __int128 v54 = v153[1];
            *(_OWORD *)uint64_t v53 = v153[0];
            *((_OWORD *)v53 + 1) = v54;
            *((_OWORD *)v53 + 2) = v153[2];
            *((void *)v53 + 6) = v154;
            uint64_t v47 = v52;
          }

          ++v46;
          NSUInteger v45 = v48;
        }

        while (v46 != 8);
        unint64_t v55 = (MTLPixelFormatComputeTotalSizeUsed( buf,  &v155,  v47,  -[MTLTileRenderPipelineDescriptor rasterSampleCount](v48, "rasterSampleCount") > 1)
             + 7) & 0xFFFFFFFFFFFFFFF8LL;
        NSUInteger v56 = objc_alloc_init(&OBJC_CLASS___MTLCompileOptions);
        uint64_t v130 = v56;
        if ((int)v133 <= 0)
        {
          id v129 = 0LL;
          uint64_t v73 = v144;
        }

        else
        {
          unint64_t v57 = v56;
          __int128 v152 = @"THREADGROUP_MEMORY_LENGTH";
          __int128 v58 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", v133));
          *(void *)&v153[0] = v58;
          uint64_t v59 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v153,  &v152,  1LL));
          -[MTLCompileOptions setPreprocessorMacros:](v57, "setPreprocessorMacros:", v59);

          id v151 = 0LL;
          unint64_t v126 = v55;
          id v60 = objc_msgSend( v144,  "newLibraryWithSource:options:error:",  @"#include <metal_stdlib>\nusing namespace metal;\n\nstruct ThreadgroupData { uint8_t data[THREADGROUP_MEMORY_LENGTH]; };\n\nkernel void ThreadgroupStore(ushort2 threadgroup_position_in_grid [[ threadgroup_position_in_grid ]],\n                                ushort2 threadgroups_per_grid [[ threadgroups_per_grid ]],\n                                device ThreadgroupData* buffer [[ buffer(0) ]],\n                                const threadgroup ThreadgroupData& threadgroupData [[ threadgroup(0) ]])\n{\n   ushort i = (threadgroup_position_in_grid.y * threadgroups_per_grid.x) + threadgroup_position_in_grid.x;\n   for (ushort j = 0; j < THREADGROUP_MEMORY_LENGTH; j++)\n       buffer[i].data[j] = threadgroupData.data[j];\n}\n\nkernel void ThreadgroupLoad(ushort2 threadgroup_position_in_grid [[ threadgroup_position_in_grid ]],\n                                ushort2 threadgroups_per_grid [[ threadgroups_per_grid ]],\n                                const device ThreadgroupData* buffer [[ buffer(0) ]],\n                                threadgroup ThreadgroupData& threadgroupData [[ threadgroup(0) ]])\n{\n   ushort i = (threadgroup_position_in_grid.y * threadgroups_per_grid.x) + threadgroup_position_in_grid.x;\n   for (ushort j = 0; j < THREADGROUP_MEMORY_LENGTH; j++)\n       threadgroupData.data[j] = buffer[i].data[j];\n}\n\nkernel void Fence()\n{\n}\n",
                  v57,
                  &v151);
          id v61 = v151;
          id v62 = [v60 newFunctionWithName:@"ThreadgroupStore"];
          -[MTLTileRenderPipelineDescriptor setTileFunction:](v48, "setTileFunction:", v62);

          id v150 = v61;
          id v63 = [v144 newRenderPipelineStateWithTileDescriptor:v48 options:0 reflection:0 error:&v150];
          id v64 = v150;

          __int128 v65 = (void *)v141[8];
          v141[8] = v63;

          id v66 = [v60 newFunctionWithName:@"ThreadgroupLoad"];
          -[MTLTileRenderPipelineDescriptor setTileFunction:](v48, "setTileFunction:", v66);

          id v149 = v64;
          id v67 = [v144 newRenderPipelineStateWithTileDescriptor:v48 options:0 reflection:0 error:&v149];
          id v68 = v149;

          NSRange v69 = (void *)v141[9];
          v141[9] = v67;

          id v70 = [v60 newFunctionWithName:@"Fence"];
          -[MTLTileRenderPipelineDescriptor setTileFunction:](v48, "setTileFunction:", v70);

          id v148 = v68;
          id v71 = [v144 newRenderPipelineStateWithTileDescriptor:v48 options:0 reflection:0 error:&v148];
          id v129 = v148;

          uint64_t v72 = (void *)v141[10];
          v141[10] = v71;
          uint64_t v73 = v144;

          id v74 = [v144 newBufferWithLength:v137 * v133 options:32];
          uint64_t v75 = (void *)v141[13];
          v141[13] = v74;

          unint64_t v55 = v126;
        }

        int v76 = v135 - v55;
        if (v135 <= v55)
        {
          uint64_t v34 = v131;
          uint64_t v33 = v132;
          id v92 = v48;
          uint64_t v4 = (uint64_t)v141;
          unint64_t v113 = v129;
          uint64_t v110 = v130;
        }

        else
        {
          int v77 = 8;
          if ((v76 & 7) != 0)
          {
            do
            {
              if (v77 >= 0) {
                int v78 = v77;
              }
              else {
                int v78 = v77 + 1;
              }
              int v77 = v78 >> 1;
            }

            while (v76 % (v78 >> 1));
          }

          uint64_t v136 = v135 - v55;
          int v79 = v76 / v77;
          unint64_t v80 = -[NSMutableArray initWithCapacity:]( objc_alloc(&OBJC_CLASS___NSMutableArray),  "initWithCapacity:",  v76 / v77);
          uint64_t v81 = -[NSMutableArray initWithCapacity:](objc_alloc(&OBJC_CLASS___NSMutableArray), "initWithCapacity:", v79);
          if (v79 >= 1)
          {
            uint64_t v82 = 0LL;
            uint64_t v83 = (8 * v77);
            do
            {
              id v84 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"uint%d_t _%d",  v83,  v82);
              -[NSMutableArray addObject:](v80, "addObject:", v84);

              uint64_t v85 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"(dest)->_%d = (src)->_%d",  v82,  v82);
              -[NSMutableArray addObject:](v81, "addObject:", v85);

              uint64_t v82 = (v82 + 1);
            }

            while (v79 != (_DWORD)v82);
          }

          v155.i64[0] = (uint64_t)@"IMAGEBLOCK_SAMPLE_MEMBERS";
          uint64_t v86 = objc_alloc(&OBJC_CLASS___NSString);
          uint64_t v134 = v80;
          int v87 = (void *)objc_claimAutoreleasedReturnValue(-[NSMutableArray componentsJoinedByString:](v80, "componentsJoinedByString:", @"; "));
          uint64_t v88 = -[NSString initWithFormat:](v86, "initWithFormat:", @"%@", v87);
          *(void *)buf = v88;
          v155.i64[1] = (uint64_t)@"IMAGEBLOCK_SAMPLE_COPY(dest,src)";
          uint64_t v89 = objc_alloc(&OBJC_CLASS___NSString);
          uint64_t v127 = v81;
          uint64_t v90 = (void *)objc_claimAutoreleasedReturnValue(-[NSMutableArray componentsJoinedByString:](v81, "componentsJoinedByString:", @"; "));
          uint64_t v91 = -[NSString initWithFormat:](v89, "initWithFormat:", @"%@", v90);
          id v158 = v91;
          id v156 = @"SAMPLE_COUNT";
          id v92 = v48;
          uint64_t v93 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedInteger:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedInteger:",  -[MTLTileRenderPipelineDescriptor rasterSampleCount](v48, "rasterSampleCount")));
          uint64_t v159 = (uint64_t)v93;
          id v94 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  buf,  &v155,  3LL));
          -[MTLCompileOptions setPreprocessorMacros:](v130, "setPreprocessorMacros:", v94);

          id v147 = v129;
          id v95 = objc_msgSend( v144,  "newLibraryWithSource:options:error:",  @"#include <metal_stdlib>\nusing namespace metal;\n\nstruct ImageblockData { IMAGEBLOCK_SAMPLE_MEMBERS; };\n\nkernel void ImageblockStore(ushort2 threadgroup_position_in_grid [[ threadgroup_position_in_grid ]],\n                            ushort2 threadgroups_per_grid [[ threadgroups_per_grid ]],\n                            ushort2 threads_per_threadgroup [[ threads_per_threadgroup ]],\n                            ushort thread_index_in_threadgroup [[ thread_index_in_threadgroup ]],\n                            ushort2 thread_position_in_threadgroup [[ thread_position_in_threadgroup ]],\n                            device ImageblockData* buffer [[ buffer(0) ]],\n                            const imageblock<ImageblockData,imageblock_layout_explicit> ib)\n{\n   uint i = (threadgroup_position_in_grid.y * threadgroups_per_grid.x) + threadgroup_position_in_grid.x;\n   i *= threads_per_threadgroup.x * threads_per_threadgroup.y;\n   i += thread_index_in_threadgroup;\n   for (ushort j = 0; j < SAMPLE_COUNT; j++)\n   {\n       const threadgroup_imageblock ImageblockData* src = ib.data(thread_position_in_threadgroup, j, imageblock_data_rate::sample);\n       device ImageblockData* dest = buffer + i * SAMPLE_COUNT + j;       IMAGEBLOCK_SAMPLE_COPY(dest,src);\n   }\n}\n\nkernel void ImageblockLoad(ushort2 threadgroup_position_in_grid [[ threadgroup_position_in_grid ]],\n                           ushort2 threadgroups_per_grid [[ threadgroups_per_grid ]],\n                           ushort2 threads_per_threadgroup [[ threads_per_threadgroup ]],\n                           ushort thread_index_in_threadgroup [[ thread_index_in_threadgroup ]],\n                           ushort2 thread_position_in_threadgroup [[ thread_position_in_threadgroup ]],\n                           const device ImageblockData* buffer [[ buffer(0) ]],\n                           imageblock<ImageblockData,imageblock_layout_explicit> ib)\n{\n   uint i = (threadgroup_position_in_grid.y * threadgroups_per_grid.x) + threadgroup_position_in_grid.x;\n   i *= threads_per_threadgroup.x * threads_per_threadgroup.y;\n   i += thread_index_in_threadgroup;\n   for (ushort j = 0; j < SAMPLE_COUNT; j++)\n   {\n       threadgroup_imageblock ImageblockData* dest = ib.data(thread_position_in_threadgroup, j, imageblock_data_rate::sample);\n       const device ImageblockData* src = buffer + i * SAMPLE_COUNT + j;       IMAGEBLOCK_SAMPLE_COPY(dest,src);\n   }\n}\n",
                  v130,
                  &v147);
          id v96 = v147;

          -[MTLTileRenderPipelineDescriptor setThreadgroupSizeMatchesTileSize:]( v48,  "setThreadgroupSizeMatchesTileSize:",  1LL);
          id v97 = [v95 newFunctionWithName:@"ImageblockStore"];
          -[MTLTileRenderPipelineDescriptor setTileFunction:](v48, "setTileFunction:", v97);

          id v146 = v96;
          id v98 = [v144 newRenderPipelineStateWithTileDescriptor:v48 options:0 reflection:0 error:&v146];
          id v99 = v146;

          uint64_t v4 = (uint64_t)v141;
          uint64_t v100 = (void *)v141[11];
          v141[11] = v98;

          id v101 = [v95 newFunctionWithName:@"ImageblockLoad"];
          -[MTLTileRenderPipelineDescriptor setTileFunction:](v92, "setTileFunction:", v101);

          id v145 = v99;
          id v102 = [v144 newRenderPipelineStateWithTileDescriptor:v92 options:0 reflection:0 error:&v145];
          id v103 = v145;

          uint64_t v104 = (void *)v141[12];
          v141[12] = v102;

          uint64_t v105 = *(unsigned __int16 *)(v128 + 814);
          uint64_t v106 = *(unsigned __int16 *)(v128 + 812);
          NSUInteger v107 = -[MTLTileRenderPipelineDescriptor rasterSampleCount](v92, "rasterSampleCount");
          uint64_t v108 = v136 * v137 * v105;
          uint64_t v73 = v144;
          uint64_t v109 = v108 * v106;
          uint64_t v110 = v130;
          id v111 = [v144 newBufferWithLength:v109 * v107 options:32];
          uint64_t v112 = (void *)v141[14];
          v141[14] = v111;

          unint64_t v113 = v103;
          uint64_t v5 = v139;
          unsigned int v3 = v140;
          unint64_t v8 = v138;
          uint64_t v34 = v131;
          uint64_t v33 = v132;
        }
      }

      GTMTLReplayController_restoreCommandEncoder(v4, *InclusiveRange, 2);
      unsigned int *v5 = *(_DWORD *)InclusiveRange + 1;
      uint64_t v16 = v142;
    }
  }

  else
  {
    GTMTLReplayController_tileMemoryFree(v4);
  }

  if (v34)
  {
    GTMTLReplayController_playTo(v4, v143);
    GTMTLReplayController_executeCommandsInBuffer((uint64_t *)v4, v34, 0LL, v3 + 1);
    unsigned int *v5 = v8;
  }

  else
  {
    GTMTLReplayController_playTo(v4, v8);
  }

  uint64_t v114 = GroupBuilder_findInclusiveRange(*(_DWORD *)(v16 + 12), *(void **)(v16 + 24), v8);
  if (v114)
  {
    while (1)
    {
      uint64_t v115 = v114;
      int v116 = *((_DWORD *)v114 + 7);
      if (v116 > -15674)
      {
        if (v116 == -15673 || v116 == -15586 || v116 == -15364)
        {
LABEL_114:
          GTMTLReplayController_restoreIndirectResourceUsageForCommandBuffer(v4, v114[1]);
          break;
        }
      }

      else if ((v116 + 16353) < 2 || v116 == -16014 || v116 == -15712)
      {
        goto LABEL_114;
      }

      uint64_t v121 = *((unsigned int *)v114 + 4);
      if ((_DWORD)v121)
      {
        v114 -= 4 * v121;
        if (v115) {
          continue;
        }
      }

      break;
    }
  }

  if (!InclusiveRange || (IsFuncEnumEndEncoding(*(_DWORD *)(v33 + 8)) & 1) != 0 || (GT_SUPPORT_0 & 1) == 0) {
    goto LABEL_125;
  }
  uint64_t v122 = GTMTLReplayController_renderPassDescriptor(v4);
  uint64_t v123 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v4 + 8) renderCommandEncoderForKey:*(void *)(v4 + 11320)]);
  uint64_t v124 = v123;
  if (*(void *)(v4 + 112))
  {
    [v123 setRenderPipelineState:*(void *)(v4 + 88)];
    [v124 setTileBuffer:*(void *)(v4 + 112) offset:0 atIndex:0];
    uint64_t v125 = *(unsigned __int16 *)(v122 + 812);
    *(void *)buf = *(unsigned __int16 *)(v122 + 814);
    goto LABEL_122;
  }

  if (*(void *)(v4 + 104))
  {
    [v123 setRenderPipelineState:*(void *)(v4 + 80)];
    uint64_t v125 = 1LL;
    *(void *)buf = 1LL;
LABEL_122:
    id v158 = (NSString *)v125;
    uint64_t v159 = 1LL;
    objc_msgSend(v124, "dispatchThreadsPerTile:");
    if (*(void *)(v4 + 104))
    {
      [v124 setRenderPipelineState:*(void *)(v4 + 64)];
      [v124 setThreadgroupMemoryLength:*(unsigned int *)(v122 + 800) offset:0 atIndex:0];
      [v124 setTileBuffer:*(void *)(v4 + 104) offset:0 atIndex:0];
      int64x2_t v155 = vdupq_n_s64(1uLL);
      id v156 = (const __CFString *)(&dword_0 + 1);
      [v124 dispatchThreadsPerTile:&v155];
    }
  }

LABEL_125:
  v5[1] = v3;
  return (unsigned int *)[*(id *)(v4 + 24) commitCommandBuffer];
}

void GTMTLReplayController_restoreGroup(unsigned int *a1, uint64_t a2, uint64_t a3)
{
  char v3 = a3;
  uint64_t v6 = *(unsigned int *)(a2 + 16);
  if ((_DWORD)v6) {
    BOOL v7 = a2 == 0;
  }
  else {
    BOOL v7 = 1;
  }
  if (!v7) {
    GTMTLReplayController_restoreGroup(a1, a2 - 32 * v6, a3);
  }
  uint64_t v8 = *(void *)a2;
  uint64_t v9 = *(void *)(*(void *)(*(void *)a1 + 120LL) + 24LL) + (v8 << 6);
  if (IsFuncEnumCreateCommandEncoder(*(_DWORD *)(v9 + 8)))
  {
    GTMTLReplayController_restoreCommandEncoder((uint64_t)a1, v8, v3);
    GTMTLReplayController_restoreIndirectResourceUsageForCommandBuffer((uint64_t)a1, a1[5620]);
  }

  else
  {
    GTMTLReplayController_defaultDispatchFunction((uint64_t)a1, v9);
  }

void GTMTLReplayController_restoreCommandEncoder(uint64_t a1, uint64_t a2, char a3)
{
  uint64_t v6 = objc_autoreleasePoolPush();
  uint64_t v7 = *(void *)(*(void *)a1 + 16LL);
  uint64_t v8 = *(void *)(*(void *)a1 + 120LL);
  id v9 = *(id *)(a1 + 8);
  uint64_t v10 = *(void *)(v8 + 24);
  bzero(v52, 0x2B90uLL);
  GTMTLSMCommandEncoder_processTraceFunc((uint64_t)v52, (uint64_t *)(v10 + (a2 << 6)), v7);
  switch(v52[0])
  {
    case 0x1C:
      GTMTLReplayController_defaultDispatchFunction(a1, v10 + (a2 << 6));
      id v12 = (id)objc_claimAutoreleasedReturnValue([v9 computeCommandEncoderForKey:*(void *)(a1 + 11320)]);
      if ([(id)g_commandBufferDescriptor errorOptions])
      {
        uint64_t v13 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"debugIndex(%u)",  *(unsigned int *)(a1 + 22480));
        [v12 insertDebugSignpost:v13];
      }

      GTMTLReplayController_restoreComputeCommandEncoder(v12, (uint64_t)__src, a1 + 11368, v9);
      goto LABEL_49;
    case 0x46:
      uint64_t v14 = v10 + (a2 << 6);
      int v15 = *(_DWORD *)(v14 + 8);
      if (v15 == -16286)
      {
        uint64_t v31 = GTTraceFunc_argumentBytesWithMap((void *)(v10 + (a2 << 6)), *(unsigned __int8 *)(v14 + 13), v7);
        uint64_t v32 = (void *)objc_claimAutoreleasedReturnValue([v9 parallelRenderCommandEncoderForKey:*(void *)v31]);
        uint64_t v33 = (void *)objc_claimAutoreleasedReturnValue([v32 renderCommandEncoder]);
        if ([(id)g_commandBufferDescriptor errorOptions])
        {
          uint64_t v34 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"debugIndex(%u)",  *(unsigned int *)(a1 + 22480));
          [v33 insertDebugSignpost:v34];
        }

        [v9 setRenderCommandEncoder:v33 forKey:*((void *)v31 + 1)];

        if ((a3 & 1) == 0) {
          goto LABEL_81;
        }
      }

      else if (v15 == -16353)
      {
        uint64_t v16 = GTTraceFunc_argumentBytesWithMap( (void *)(v10 + (a2 << 6)),  *(unsigned __int8 *)(v10 + (a2 << 6) + 13),  v7);
        memcpy(__dst, __src[0], sizeof(__dst));
        if ((a3 & 1) != 0)
        {
          for (uint64_t i = 0LL; i != 64; i += 8LL)
            BYTE1(__dst[i + 3]) = 1;
          BYTE1(__dst[87]) = 1;
          BYTE1(__dst[93]) = 1;
        }

        else if ((dword_5B9DE4 & 1) != 0)
        {
          _clearDontCareAttachments((uint64_t)__dst);
        }

        if ((a3 & 2) != 0)
        {
          for (uint64_t j = 0LL; j != 64; j += 8LL)
          {
            if (__dst[j]) {
              char v37 = 3;
            }
            else {
              char v37 = 1;
            }
            BYTE3(__dst[j + 3]) = v37;
          }

          if (__dst[84]) {
            char v38 = 3;
          }
          else {
            char v38 = 1;
          }
          BYTE3(__dst[87]) = v38;
          if (__dst[90]) {
            char v39 = 3;
          }
          else {
            char v39 = 1;
          }
          BYTE3(__dst[93]) = v39;
        }

        NSUInteger v40 = (void *)objc_claimAutoreleasedReturnValue([v9 commandBufferForKey:*(void *)v16]);
        uint64_t v41 = (void *)objc_claimAutoreleasedReturnValue([v9 renderPassDescriptorMapWithMemorylessSubstitutes:*(void *)(a1 + 40)]);
        MTLuint64_t RenderPassDescriptor = MakeMTLRenderPassDescriptor((uint64_t)__dst, v41);
        NSUInteger v43 = (void *)objc_claimAutoreleasedReturnValue(MTLRenderPassDescriptor);

        uint64_t v33 = (void *)objc_claimAutoreleasedReturnValue([v40 renderCommandEncoderWithDescriptor:v43]);
        if ([(id)g_commandBufferDescriptor errorOptions])
        {
          int v44 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"debugIndex(%u)",  *(unsigned int *)(a1 + 22480));
          [v33 insertDebugSignpost:v44];
        }

        [v9 setRenderCommandEncoder:v33 forKey:*((void *)v16 + 1)];

        if ((a3 & 1) == 0) {
          goto LABEL_81;
        }
      }

      else
      {
        uint64_t v33 = 0LL;
        if ((a3 & 1) == 0)
        {
LABEL_81:
          unint64_t v49 = *(void *)(a1 + 22464);
          unint64_t v50 = *(void *)(a1 + 22472);
          uint64_t v55 = 1LL;
          double v56 = (double)v49;
          double v57 = (double)v50;
          uint64_t v58 = 0x3FF0000000000000LL;
          uint64_t v59 = 1LL;
          unint64_t v60 = v49;
          unint64_t v61 = v50;
          GTMTLReplayController_restoreRenderCommandEncoder(v33, (uint64_t)__src, a1 + 11368, v9);

          goto LABEL_82;
        }
      }

      if ((GT_SUPPORT_0 & 1) != 0)
      {
        uint64_t v45 = GTMTLReplayController_renderPassDescriptor(a1);
        uint64_t v46 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 8) renderCommandEncoderForKey:*(void *)(a1 + 11320)]);
        uint64_t v47 = v46;
        if (*(void *)(a1 + 112))
        {
          [v46 setRenderPipelineState:*(void *)(a1 + 96)];
          [v47 setTileBuffer:*(void *)(a1 + 112) offset:0 atIndex:0];
          uint64_t v48 = *(unsigned __int16 *)(v45 + 812);
          __dst[0] = *(unsigned __int16 *)(v45 + 814);
          __dst[1] = v48;
          __dst[2] = 1LL;
          [v47 dispatchThreadsPerTile:__dst];
        }

        if (*(void *)(a1 + 104))
        {
          [v47 setRenderPipelineState:*(void *)(a1 + 72)];
          [v47 setThreadgroupMemoryLength:*(unsigned int *)(v45 + 800) offset:0 atIndex:0];
          [v47 setTileBuffer:*(void *)(a1 + 104) offset:0 atIndex:0];
          int64x2_t v62 = vdupq_n_s64(1uLL);
          uint64_t v63 = 1LL;
          [v47 dispatchThreadsPerTile:&v62];
        }
      }

      goto LABEL_81;
    case 0x41:
      id v11 = GTTraceFunc_argumentBytesWithMap( (void *)(v10 + (a2 << 6)),  *(unsigned __int8 *)(v10 + (a2 << 6) + 13),  v7);
      memcpy(__dst, __src[0], sizeof(__dst));
      if ((a3 & 1) != 0)
      {
        for (uint64_t k = 0LL; k != 64; k += 8LL)
          BYTE1(__dst[k + 3]) = 1;
        BYTE1(__dst[87]) = 1;
        BYTE1(__dst[93]) = 1;
      }

      else if ((dword_5B9DE4 & 1) != 0)
      {
        _clearDontCareAttachments((uint64_t)__dst);
      }

      if ((a3 & 2) != 0)
      {
        for (uint64_t m = 0LL; m != 64; m += 8LL)
        {
          if (__dst[m]) {
            char v19 = 3;
          }
          else {
            char v19 = 1;
          }
          BYTE3(__dst[m + 3]) = v19;
        }

        if (__dst[84]) {
          char v20 = 3;
        }
        else {
          char v20 = 1;
        }
        BYTE3(__dst[87]) = v20;
        if (__dst[90]) {
          char v21 = 3;
        }
        else {
          char v21 = 1;
        }
        BYTE3(__dst[93]) = v21;
      }

      uint64_t v22 = (void *)objc_claimAutoreleasedReturnValue([v9 commandBufferForKey:*(void *)v11]);
      BOOL v23 = (void *)objc_claimAutoreleasedReturnValue([v9 renderPassDescriptorMapWithMemorylessSubstitutes:*(void *)(a1 + 40)]);
      unint64_t v24 = MakeMTLRenderPassDescriptor((uint64_t)__dst, v23);
      uint64_t v25 = (void *)objc_claimAutoreleasedReturnValue(v24);

      NSRange v26 = (void *)objc_claimAutoreleasedReturnValue([v22 parallelRenderCommandEncoderWithDescriptor:v25]);
      if ([(id)g_commandBufferDescriptor errorOptions])
      {
        int v27 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"debugIndex(%u)",  *(unsigned int *)(a1 + 22480));
        [v26 insertDebugSignpost:v27];
      }

      [v9 setParallelRenderCommandEncoder:v26 forKey:*((void *)v11 + 1)];

      id v12 = v26;
      uint64_t v28 = 0LL;
      uint64_t v29 = (void *)(a1 + 288);
      BOOL v30 = v54;
      do
      {
        if (*(v30 - 8) != *(v29 - 8)) {
          objc_msgSend(v12, "setColorStoreAction:atIndex:");
        }
        if (*v30 != *v29) {
          objc_msgSend(v12, "setColorStoreActionOptions:atIndex:");
        }
        ++v29;
        ++v28;
        ++v30;
      }

      while (v28 != 8);

LABEL_49:
      goto LABEL_82;
  }

  GTMTLReplayController_defaultDispatchFunction(a1, v10 + (a2 << 6));
LABEL_82:

  objc_autoreleasePoolPop(v6);
}

void GTMTLReplayController_restoreIndirectResourceUsageForCommandBuffer(uint64_t a1, unint64_t a2)
{
  uint64_t v4 = *(void **)a1;
  if ((*(_BYTE *)(*(void *)a1 + 272LL) & 2) == 0)
  {
    _restoreIndirectResourceUsage(a1, a2);
    return;
  }

  int v5 = *(_DWORD *)(a1 + 11312);
  if (v5 == 70 || v5 == 28)
  {
    InclusiveRange = GroupBuilder_findInclusiveRange(*(_DWORD *)(v4[14] + 12LL), *(void **)(v4[14] + 24LL), a2);
    if (InclusiveRange)
    {
      uint64_t v8 = InclusiveRange;
      while (1)
      {
        int FuncEnumConstructorType = GetFuncEnumConstructorType(*((_DWORD *)v8 + 7));
        uint64_t v10 = *((unsigned int *)v8 + 4);
        if ((_DWORD)v10) {
          v8 -= 4 * v10;
        }
        else {
          uint64_t v8 = 0LL;
        }
        if (!v8) {
          return;
        }
      }

      uint64_t v11 = *(void *)(v4[15] + 24LL) + (*v8 << 6);
      uint64_t v12 = v4[2];
      uint64_t v13 = GetFuncEnumConstructorType(*(_DWORD *)(v11 + 8))
      uint64_t v48 = v13;
      if (v13)
      {
        entry = find_entry(v4[20], &v48, 8uLL, 0LL);
        if (*entry)
        {
          uint64_t v15 = *(void *)(*entry + 32LL);
          if (v15)
          {
            uint64_t v16 = *(int *)(*(void *)(v15 + 16) + 48LL);
            int v17 = **(apr_pool_t ***)(a1 + 152);
            unint64_t v18 = apr_palloc(v17, 8 * v16);
            char v19 = v18;
            if (v18) {
              bzero(v18, 8 * v16);
            }
            uint64_t v45 = (char *)&v19[v16];
            apr_size_t v20 = 8LL * *(int *)(*(void *)(v4[5] + 280LL) + 12LL);
            char v21 = apr_palloc(v17, v20);
            uint64_t v22 = v21;
            if (v21) {
              bzero(v21, v20);
            }
            uint64_t v23 = *(void *)(v15 + 16);
            id v24 = *(id *)(a1 + 8);
            *(void *)(v23 + 24) = 0LL;
            *(void *)(v23 + 32) = 0LL;
            *(void *)(v23 + 16) = v23;
            *(_DWORD *)(v23 + 40) = 0;
            uint64_t v25 = apr_hash_next((apr_hash_index_t *)(v23 + 16));
            if (!v25)
            {
              int v27 = 0;
              char v38 = (char *)&v19[v16];
              uint64_t v29 = v38;
              goto LABEL_60;
            }

            NSRange v26 = v25;
            int v44 = v17;
            int v27 = 0;
            uint64_t v28 = 0LL;
            uint64_t v29 = (char *)&v19[v16];
            id v46 = v24;
            while (1)
            {
              BOOL v30 = *(uint64_t **)(*((void *)v26 + 1) + 32LL);
              int v31 = *((_DWORD *)v30 + 2);
              if (v31 <= 59) {
                break;
              }
              if (v31 <= 79)
              {
                if (v31 != 60)
                {
                  if (v31 == 72)
                  {
                    v22[(int)v28] = [v24 residencySetForKey:*v30];
                    uint64_t v28 = (v28 + 1);
                  }

                  goto LABEL_50;
                }

LABEL_68:
                    [v42 useResources:v19 count:v27 usage:1];
                    goto LABEL_69;
                  default:
                    goto LABEL_72;
                }

                unint64_t v42 = (void *)v43;
                if (!v27) {
                  goto LABEL_69;
                }
                goto LABEL_68;
              }
            }

            if (v31 > 49)
            {
              if (v31 == 50)
              {
                *((void *)v29 - 1) = [v24 heapForKey:*v30];
                v29 -= 8;
                goto LABEL_50;
              }

              if (v31 != 57) {
                goto LABEL_50;
              }
            }

            else if (v31 != 16 && v31 != 22)
            {
              goto LABEL_50;
            }

            goto LABEL_49;
          }
        }
      }
    }
  }

    if (v19[18] || ((GT_SUPPORT_0 & 0x100000) == 0 || !v19[19]) && v19[20]) {
      goto LABEL_73;
    }
    goto LABEL_72;
  }

              -[NSMutableArray addObject:](v14, "addObject:", v33);

              unint64_t v18 = v33;
              goto LABEL_69;
            }

    if ((v14 & (v14 - 1)) != 0)
    {
      if (v13 >= v14) {
        uint64_t v4 = v13 % v14;
      }
      else {
        uint64_t v4 = v13;
      }
    }

    else
    {
      uint64_t v4 = (v14 - 1) & v13;
    }
  }

  int v41 = *(unsigned __int8 ***)(*(void *)a1 + 8 * v4);
  uint64_t i = (unsigned __int8 *)v45[0];
  if (v41)
  {
    *(void *)v45[0] = *v41;
LABEL_81:
    *int v41 = i;
    goto LABEL_82;
  }

  *(void *)v45[0] = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = i;
  *(void *)(*(void *)a1 + 8 * v4) = v20;
  if (*(void *)i)
  {
    unint64_t v42 = *(void *)(*(void *)i + 8LL);
    if ((v14 & (v14 - 1)) != 0)
    {
      if (v42 >= v14) {
        v42 %= v14;
      }
    }

    else
    {
      v42 &= v14 - 1;
    }

    int v41 = (unsigned __int8 **)(*(void *)a1 + 8 * v42);
    goto LABEL_81;
  }

          uint64_t v48 = -1LL;
        }

        unint64_t v50 = v48 + v27;
        unint64_t v49 = v40 <= 79 && (v40 == 22 || v40 == 57);
LABEL_77:
        if ((v50 & (unint64_t)-v49) + v42 <= 0x18000000)
        {
          id v51 = 0LL;
          if (v40 <= 56)
          {
            if (v40 == 16)
            {
              uint64_t v53 = v27 + 31;
              uint64_t v52 = 32LL;
              goto LABEL_94;
            }

            if (v40 != 22) {
              goto LABEL_85;
            }
          }

          else if (v40 != 57)
          {
            if (v40 == 86)
            {
              uint64_t v53 = v27 + 255;
              uint64_t v52 = 256LL;
              goto LABEL_94;
            }

            if (v40 == 80)
            {
              uint64_t v52 = *(unsigned __int16 *)&v36[64 * v35 + 60];
              uint64_t v53 = v27 + v52 - 1;
LABEL_94:
              int v27 = (v53 & -v52) + v42;
              __int128 v54 = v33->nelts;
              v33->uint64_t nelts = v54 + 1;
              uint64_t v55 = v33->elts;
              double v56 = &v55[64 * v35];
              *(_OWORD *)buf = *(_OWORD *)v56;
              uint64_t v179 = *((_OWORD *)v56 + 1);
              uint64_t v180 = *((_OWORD *)v56 + 2);
              uint64_t v181 = *((_OWORD *)v56 + 3);
              double v57 = &v55[64 * v54];
              uint64_t v58 = *((_OWORD *)v57 + 3);
              unint64_t v60 = *(_OWORD *)v57;
              uint64_t v59 = *((_OWORD *)v57 + 1);
              *((_OWORD *)v56 + 2) = *((_OWORD *)v57 + 2);
              *((_OWORD *)v56 + 3) = v58;
              *(_OWORD *)double v56 = v60;
              *((_OWORD *)v56 + 1) = v59;
              unint64_t v61 = &v33->elts[64 * v54];
              *(_OWORD *)unint64_t v61 = *(_OWORD *)buf;
              *((_OWORD *)v61 + 1) = v179;
              *((_OWORD *)v61 + 2) = v180;
              *((_OWORD *)v61 + 3) = v181;
              goto LABEL_95;
            }

    if ((v12 & (v12 - 1)) != 0)
    {
      if (v11 >= v12) {
        char v3 = v11 % v12;
      }
      else {
        char v3 = v11;
      }
    }

    else
    {
      char v3 = (v12 - 1) & v11;
    }
  }

  char v37 = *a1;
  char v38 = *(void **)(*a1 + 8 * v3);
  if (v38)
  {
    *(void *)uint64_t v16 = *v38;
LABEL_81:
    *char v38 = v16;
    goto LABEL_82;
  }

  *(void *)uint64_t v16 = *v18;
  void *v18 = v16;
  *(void *)(v37 + 8 * v3) = v18;
  if (*(void *)v16)
  {
    uint64_t v39 = *(void *)(*(void *)v16 + 8LL);
    if ((v12 & (v12 - 1)) != 0)
    {
      if (v39 >= v12) {
        v39 %= v12;
      }
    }

    else
    {
      v39 &= v12 - 1;
    }

    char v38 = (void *)(*a1 + 8 * v39);
    goto LABEL_81;
  }

void _restoreIndirectResourceUsage(uint64_t a1, unint64_t a2)
{
  uint64_t v4 = *(void *)a1;
  InclusiveRange = (int *)GroupBuilder_findInclusiveRange( *(_DWORD *)(*(void *)(*(void *)a1 + 112LL) + 12LL),  *(void **)(*(void *)(*(void *)a1 + 112LL) + 24LL),  a2);
  if (InclusiveRange)
  {
    uint64_t v6 = InclusiveRange;
    while (1)
    {
      int v7 = v6[7];
      if (IsFuncEnumCreateCommandEncoder(v7)) {
        break;
      }
      uint64_t v8 = v6[4];
      if ((_DWORD)v8) {
        v6 -= 8 * v8;
      }
      else {
        uint64_t v6 = 0LL;
      }
      if (!v6) {
        return;
      }
    }

    int FuncEnumConstructorType = GetFuncEnumConstructorType(v7);
    if ((FuncEnumConstructorType - 17) <= 0x35
      && ((1LL << (FuncEnumConstructorType - 17)) & 0x20000000000801LL) != 0)
    {
      unint64_t v11 = *v6;
      uint64_t v12 = a2 - v11;
      if (a2 > v11)
      {
        uint64_t v13 = v11 << 6;
        do
        {
          uint64_t v14 = *(void *)(*(void *)(v4 + 120) + 24LL) + v13;
          v13 += 64LL;
          --v12;
        }

        while (v12);
      }
    }
  }

uint64_t _clearDontCareAttachments(uint64_t result)
{
  uint64_t v1 = 0LL;
  __asm { FMOV            V1.2D, #1.0 }

  do
  {
    uint64_t v7 = result + v1;
    if (!*(_BYTE *)(result + v1 + 25))
    {
      *(_BYTE *)(v7 + 25) = 2;
      *(_OWORD *)(v7 + 32) = xmmword_3183D0;
      *(_OWORD *)(v7 + 4_Block_object_dispose((const void *)(v12 - 64), 8) = _Q1;
    }

    v1 += 64LL;
  }

  while (v1 != 512);
  if (!*(_BYTE *)(result + 697))
  {
    *(_BYTE *)(result + 697) = 2;
    *(void *)(result + 704) = 0x3FE0000000000000LL;
  }

  if (!*(_BYTE *)(result + 745))
  {
    *(_BYTE *)(result + 745) = 2;
    *(_DWORD *)(result + 752) = -1431655766;
  }

  return result;
}

void GTMTLReplayController_debugSubCommandResume(unsigned int *a1, unsigned int a2, int a3)
{
  uint64_t v4 = a1;
  uint64_t v5 = *(void *)a1;
  if (a2)
  {
    uint64_t v6 = *(void *)(*(void *)(v5 + 120) + 24LL) + ((unint64_t)(a2 - 1) << 6);
    if (!a3) {
      goto LABEL_7;
    }
  }

  else
  {
    uint64_t v6 = 0LL;
    if (!a3) {
      goto LABEL_7;
    }
  }

  if ((*(_DWORD *)(v6 + 8) & 0xFFFFFFFC) == 0xFFFFC1A4)
  {
    GTMTLReplayController_debugSubCommandStop((uint64_t)a1, a2, (a3 - 1));
    unsigned int v7 = a2 - 1;
    goto LABEL_11;
  }

void GTMTLReplayController_prePlayForProfiling(uint64_t a1)
{
  if (s_logUsingOsLog)
  {
    id v2 = gt_default_log();
    char v3 = (os_log_s *)objc_claimAutoreleasedReturnValue(v2);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_0, v3, OS_LOG_TYPE_INFO, "Pre-playing for profiling", buf, 2u);
    }
  }

  else
  {
    uint64_t v4 = __stdoutp;
    id v5 = objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString, "stringWithFormat:", @"Pre-playing for profiling"));
    fprintf(v4, "%s\n", (const char *)[v5 UTF8String]);
  }

  uint64_t v6 = objc_autoreleasePoolPush();
  uint64_t v7 = *(void *)a1;
  if (s_logUsingOsLog)
  {
    id v8 = gt_default_log();
    unsigned int v9 = (os_log_s *)objc_claimAutoreleasedReturnValue(v8);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)uint64_t v16 = 0;
      _os_log_impl(&dword_0, v9, OS_LOG_TYPE_INFO, "Rewinding for profiling", v16, 2u);
    }
  }

  else
  {
    uint64_t v10 = __stdoutp;
    unsigned int v9 = (os_log_s *) objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString, "stringWithFormat:", @"Rewinding for profiling"));
    fprintf(v10, "%s\n", (const char *)-[os_log_s UTF8String](v9, "UTF8String"));
  }

  Rewind((_DWORD *)a1);
  if ((dword_5B9DE4 & 0x100000) != 0) {
    unsigned int v12 = &off_340480;
  }
  else {
    unsigned int v12 = (__objc2_class **)&OBJC_CLASS___CAMetalLayer_ptr;
  }
  objc_msgSend(*(id *)(a1 + 8), "setLayerClass:", objc_opt_class(*v12, v11));
  unint64_t v13 = *(void *)(v7 + 96);
  if (v13)
  {
    GTMTLReplayController_playTo(a1, v13);
    uint64_t v14 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 8) defaultCommandQueue]);
    [v14 finish];
  }

  objc_autoreleasePoolPop(v6);
}

void GTMTLReplayController_populateUnusedResources(void *a1, void *a2)
{
  id v12 = a2;
  uint64_t v3 = 0LL;
  uint64_t v4 = a1[5];
  do
  {
    uint64_t v5 = *(void *)(v4 + 8 * v3 + 8);
    int v6 = *(_DWORD *)(v5 + 12);
    if (v6 >= 1)
    {
      for (uint64_t i = 0LL; i < v6; ++i)
      {
        uint64_t v8 = *(void *)(*(void *)(v5 + 24) + 8 * i);
        unint64_t v9 = *(void *)(v8 + 16);
        unint64_t v10 = a1[8];
        if (v10 <= v9 && a1[9] + v10 > v9)
        {
          [v12 addUnusedResourceKey:*(void *)(v8 + 8)];
          int v6 = *(_DWORD *)(v5 + 12);
        }
      }
    }

    ++v3;
  }

  while (v3 != 35);
}

id GTMTLReplayController_defaultLibrary(void *a1)
{
  id v1 = a1;
  uint64_t v3 = +[NSBundle bundleForClass:]( &OBJC_CLASS___NSBundle,  "bundleForClass:",  objc_opt_class(&OBJC_CLASS___GTMTLReplayObjectMap, v2));
  uint64_t v4 = (void *)objc_claimAutoreleasedReturnValue(v3);
  id v5 = [v1 newDefaultLibraryWithBundle:v4 error:0];

  return v5;
}

void sub_E4EB4( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

void sub_E53D8(_Unwind_Exception *a1)
{
}

LABEL_82:
    if ((v20 & (v20 - 1)) != 0)
    {
      if (v9 >= v20) {
        uint64_t v3 = v9 % v20;
      }
      else {
        uint64_t v3 = v9;
      }
    }

    else
    {
      uint64_t v3 = (v20 - 1) & v9;
    }
  }

  int v44 = self->_cache.__table_.__bucket_list_.__ptr_.__value_;
  uint64_t v45 = (void **)v44[v3];
  if (v45)
  {
    *uint64_t j = *v45;
LABEL_95:
    char *v45 = j;
    goto LABEL_96;
  }

  *uint64_t j = self->_cache.__table_.__p1_.__value_.__next_;
  self->_cache.__table_.__p1_.__value_.__next_ = j;
  v44[v3] = &self->_cache.__table_.__p1_;
  if (*j)
  {
    id v46 = *(void *)(*j + 8LL);
    if ((v20 & (v20 - 1)) != 0)
    {
      if (v46 >= v20) {
        v46 %= v20;
      }
    }

    else
    {
      v46 &= v20 - 1;
    }

    uint64_t v45 = &self->_cache.__table_.__bucket_list_.__ptr_.__value_[v46];
    goto LABEL_95;
  }

  unint64_t v80 = v251;
  uint64_t v82 = (void *)*((void *)self + 28);
  uint64_t v81 = (void *)*((void *)self + 29);
  uint64_t v83 = 0xAAAAAAAAAAAAAAABLL * (v81 - v82);
  id v84 = v251 - v83;
  if (v251 <= v83)
  {
    if (v251 < v83)
    {
      id v96 = &v82[3 * v251];
      while (v81 != v96)
      {
        v81 -= 3;
        *(void *)uint64_t v252 = v81;
        std::vector<std::unique_ptr<std::vector<std::unordered_map<unsigned int,std::pair<unsigned long long,unsigned long long>>>>>::__destroy_vector::operator()[abi:nn180100]((void ***)v252);
      }

      *((void *)self + 29) = v96;
    }

    goto LABEL_105;
  }

  uint64_t v85 = *((void *)self + 30);
  if (0xAAAAAAAAAAAAAAABLL * ((v85 - (uint64_t)v81) >> 3) >= v84)
  {
    bzero(*((void **)self + 29), 24 * ((24 * v84 - 24) / 0x18) + 24);
    *((void *)self + 29) = &v81[3 * ((24 * v84 - 24) / 0x18) + 3];
    goto LABEL_105;
  }

  uint64_t v86 = 0xAAAAAAAAAAAAAAABLL * ((v85 - (uint64_t)v82) >> 3);
  int v87 = 0x5555555555555556LL * ((v85 - (uint64_t)v82) >> 3);
  if (v87 > v251) {
    unint64_t v80 = v87;
  }
  if (v86 >= 0x555555555555555LL) {
    uint64_t v88 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    uint64_t v88 = v80;
  }
  if (v88 > 0xAAAAAAAAAAAAAAALL) {
LABEL_270:
  }
    std::__throw_bad_array_new_length[abi:nn180100]();
  uint64_t v89 = (char *)operator new(24 * v88);
  uint64_t v90 = &v89[8 * (v81 - v82)];
  uint64_t v91 = &v89[24 * v88];
  id v92 = 24 * ((24 * v84 - 24) / 0x18) + 24;
  bzero(v90, v92);
  uint64_t v93 = &v90[v92];
  if (v81 != v82)
  {
    do
    {
      *((void *)v90 - 3) = 0LL;
      *((void *)v90 - 2) = 0LL;
      v90 -= 24;
      *((void *)v90 + 2) = 0LL;
      id v94 = *(_OWORD *)(v81 - 3);
      v81 -= 3;
      *(_OWORD *)uint64_t v90 = v94;
      *((void *)v90 + 2) = v81[2];
      *uint64_t v81 = 0LL;
      v81[1] = 0LL;
      v81[2] = 0LL;
    }

    while (v81 != v82);
    id v95 = (void *)*((void *)self + 28);
    uint64_t v81 = (void *)*((void *)self + 29);
    *((void *)self + 2_Block_object_dispose(va, 8) = v90;
    *((void *)self + 29) = v93;
    *((void *)self + 30) = v91;
    if (v81 != v95)
    {
      do
      {
        v81 -= 3;
        *(void *)uint64_t v252 = v81;
        std::vector<std::unique_ptr<std::vector<std::unordered_map<unsigned int,std::pair<unsigned long long,unsigned long long>>>>>::__destroy_vector::operator()[abi:nn180100]((void ***)v252);
      }

      while (v81 != v95);
      uint64_t v81 = v95;
    }

    if (!v81) {
      goto LABEL_105;
    }
    goto LABEL_104;
  }

  *((void *)self + 2_Block_object_dispose(va, 8) = v90;
  *((void *)self + 29) = v93;
  *((void *)self + 30) = v91;
  if (v81) {
LABEL_104:
  }
    operator delete(v81);
LABEL_105:
  id v97 = (void *)((char *)self + 248);
  std::vector<std::vector<std::unique_ptr<std::vector<double>>>>::resize((char **)self + 31, v251);
  id v98 = (void *)((char *)self + 272);
  std::vector<std::vector<std::unique_ptr<std::vector<double>>>>::resize((char **)self + 34, v251);
  *((_DWORD *)self + 182) = a5;
  __int128 v240 = self;
  if (v251)
  {
    for (uint64_t i = 0LL; i < v251; ++i)
    {
      uint64_t v100 = (void *)*((void *)self + 21);
      id v101 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableArray arrayWithCapacity:](&OBJC_CLASS___NSMutableArray, "arrayWithCapacity:", 20LL));
      [v100 addObject:v101];

      id v102 = (void *)*((void *)v240 + 22);
      id v103 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableArray arrayWithCapacity:](&OBJC_CLASS___NSMutableArray, "arrayWithCapacity:", 20LL));
      [v102 addObject:v103];

      uint64_t v104 = (void *)*((void *)v240 + 23);
      uint64_t v105 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableArray arrayWithCapacity:](&OBJC_CLASS___NSMutableArray, "arrayWithCapacity:", 20LL));
      [v104 addObject:v105];

      uint64_t v106 = (void *)*((void *)v240 + 24);
      NSUInteger v107 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableArray arrayWithCapacity:](&OBJC_CLASS___NSMutableArray, "arrayWithCapacity:", 20LL));
      [v106 addObject:v107];

      uint64_t v108 = *((void *)v240 + 25);
      uint64_t v109 = (char **)(v108 + 24 * i);
      uint64_t v110 = (uint64_t *)(v109 + 2);
      id v111 = *v109;
      if ((unint64_t)(v109[2] - *v109) <= 0x9F)
      {
        uint64_t v112 = v108 + 24 * i;
        uint64_t v115 = *(void *)(v112 + 8);
        unint64_t v113 = (char **)(v112 + 8);
        uint64_t v114 = v115;
        uint64_t v253 = v109 + 2;
        int v116 = (char *)operator new(0xA0uLL);
        uint64_t v117 = *v113;
        uint64_t v118 = *v109;
        if (*v113 == *v109)
        {
          uint64_t v121 = vdupq_n_s64((unint64_t)v117);
          uint64_t v119 = &v116[(v114 - (void)v111) & 0xFFFFFFFFFFFFFFF8LL];
        }

        else
        {
          uint64_t v119 = &v116[(v114 - (void)v111) & 0xFFFFFFFFFFFFFFF8LL];
          do
          {
            unint64_t v120 = *((void *)v117 - 1);
            v117 -= 8;
            *(void *)uint64_t v117 = 0LL;
            *((void *)v119 - 1) = v120;
            v119 -= 8;
          }

          while (v117 != v118);
          uint64_t v121 = *(int64x2_t *)v109;
        }

        *uint64_t v109 = v119;
        *unint64_t v113 = &v116[(v114 - (void)v111) & 0xFFFFFFFFFFFFFFF8LL];
        *(int64x2_t *)&v252[8] = v121;
        uint64_t v122 = *v110;
        *uint64_t v110 = (uint64_t)(v116 + 160);
        *(void *)&v252[24] = v122;
        *(void *)uint64_t v252 = v121.i64[0];
        std::__split_buffer<std::unique_ptr<std::vector<std::vector<std::pair<unsigned int,double>>>>>::~__split_buffer((uint64_t)v252);
      }

      std::vector<std::unique_ptr<std::vector<double>>>::reserve((int64x2_t *)(*v97 + 24 * i));
      std::vector<std::unique_ptr<std::vector<double>>>::reserve((int64x2_t *)(*v98 + 24 * i));
      self = v240;
      uint64_t v123 = *((void *)v240 + 28);
      uint64_t v124 = (char **)(v123 + 24 * i);
      uint64_t v125 = (uint64_t *)(v124 + 2);
      unint64_t v126 = *v124;
      if ((unint64_t)(v124[2] - *v124) <= 0x9F)
      {
        uint64_t v127 = v123 + 24 * i;
        uint64_t v130 = *(void *)(v127 + 8);
        uint64_t v128 = (char **)(v127 + 8);
        id v129 = v130;
        uint64_t v253 = v124 + 2;
        uint64_t v131 = (char *)operator new(0xA0uLL);
        uint64_t v132 = &v131[(v130 - (void)v126) & 0xFFFFFFFFFFFFFFF8LL];
        uint64_t v133 = *v128;
        uint64_t v134 = *v124;
        if (*v128 == *v124)
        {
          uint64_t v137 = vdupq_n_s64((unint64_t)v133);
          unint64_t v135 = &v131[(v129 - (void)v126) & 0xFFFFFFFFFFFFFFF8LL];
        }

        else
        {
          unint64_t v135 = &v131[(v129 - (void)v126) & 0xFFFFFFFFFFFFFFF8LL];
          do
          {
            uint64_t v136 = *((void *)v133 - 1);
            v133 -= 8;
            *(void *)uint64_t v133 = 0LL;
            *((void *)v135 - 1) = v136;
            v135 -= 8;
          }

          while (v133 != v134);
          uint64_t v137 = *(int64x2_t *)v124;
        }

        self = v240;
        *uint64_t v124 = v135;
        *uint64_t v128 = v132;
        *(int64x2_t *)&v252[8] = v137;
        unint64_t v138 = *v125;
        *uint64_t v125 = (uint64_t)(v131 + 160);
        *(void *)&v252[24] = v138;
        *(void *)uint64_t v252 = v137.i64[0];
        std::__split_buffer<std::unique_ptr<std::vector<std::unordered_map<unsigned int,std::pair<unsigned long long,unsigned long long>>>>>::~__split_buffer((uint64_t)v252);
      }
    }
  }

  unint64_t v139 = (void *)objc_claimAutoreleasedReturnValue([v241 drawCallInfoList]);
  __int128 v238 = [v139 count];

  unsigned int v140 = (void *)objc_claimAutoreleasedReturnValue([v241 programInfoList]);
  uint64_t v141 = objc_claimAutoreleasedReturnValue( +[NSMutableDictionary dictionaryWithCapacity:]( NSMutableDictionary,  "dictionaryWithCapacity:",  [v140 count]));
  uint64_t v142 = (void *)*((void *)self + 19);
  *((void *)self + 19) = v141;

  unint64_t v143 = 0;
  uint64_t v250 = &v251;
  *((_DWORD *)self + 26) = 0;
  uint64_t v239 = (uint64_t *)((char *)self + 16);
  while (1)
  {
    id v144 = (void *)objc_claimAutoreleasedReturnValue([v241 drawCallInfoList]);
    v234 = v143;
    id v145 = (unint64_t)[v144 count] > v143;

    if (!v145) {
      break;
    }
    id v146 = (void *)objc_claimAutoreleasedReturnValue([v241 drawCallInfoList]);
    __int128 v235 = (void *)objc_claimAutoreleasedReturnValue([v146 objectAtIndexedSubscript:v234]);

    id v147 = (void *)objc_claimAutoreleasedReturnValue([v235 programInfo]);
    if (v147)
    {
      id v148 = (void *)objc_claimAutoreleasedReturnValue([v235 programInfo]);
      id v149 = [v148 programId] == (id)-1;

      if (v149) {
        goto LABEL_266;
      }
    }

    id v150 = *((_DWORD *)self + 26);
    id v151 = *((void *)self + 10);
    *((_DWORD *)self + 26) = v150 + 1;
    __int128 v152 = *((void *)self + 7);
    __int128 v247 = 0LL;
    std::string::basic_string[abi:nn180100]<0>(&__p, "");
    uint64_t v153 = (unint64_t *)(v152 + 24LL * v150);
    int64x2_t v155 = v153 + 1;
    uint64_t v154 = v153[1];
    id v156 = *v153;
    __int128 v157 = v154 - *v153;
    if ((unint64_t)v157 > 0xBF)
    {
      if (v157 == 192) {
        goto LABEL_157;
      }
      unint64_t v175 = v156 + 192;
      while (v154 != v175)
      {
        v154 -= 32LL;
      }

      goto LABEL_154;
    }

    id v158 = v157 >> 5;
    uint64_t v159 = 6 - (v157 >> 5);
    id v160 = v152 + 24LL * v150;
    id v163 = *(void *)(v160 + 16);
    __int128 v162 = (void *)(v160 + 16);
    __int128 v161 = v163;
    if (v159 <= (uint64_t)(v163 - v154) >> 5)
    {
      unint64_t v175 = v154 + 32 * v159;
      unint64_t v176 = (std::string *)(v154 + 8);
      uint64_t v177 = 192 - 32 * v158;
      do
      {
        v176[-1].__r_.__value_.__l.__cap_ = v247;
        if (SHIBYTE(v249) < 0)
        {
          std::string::__init_copy_ctor_external( v176,  (const std::string::value_type *)__p,  *((std::string::size_type *)&__p + 1));
        }

        else
        {
          uint64_t v178 = __p;
          v176->__r_.__value_.__l.__cap_ = v249;
          *(_OWORD *)&v176->__r_.__value_.__l.__data_ = v178;
        }

        unint64_t v176 = (std::string *)((char *)v176 + 32);
        v177 -= 32LL;
      }

      while (v177);
LABEL_154:
      *int64x2_t v155 = v175;
      goto LABEL_157;
    }

    uint64_t v164 = v161 - v156;
    __int128 v165 = v164 >> 4;
    else {
      uint64_t v166 = v165;
    }
    uint64_t v253 = v162;
    if (v166 >> 59) {
      std::__throw_bad_array_new_length[abi:nn180100]();
    }
    *(void *)uint64_t v252 = operator new(32 * v166);
    *(void *)&v252[8] = *(void *)v252 + 32 * v158;
    *(void *)&v252[16] = *(void *)&v252[8];
    *(void *)&v252[24] = *(void *)v252 + 32 * v166;
    __int128 v167 = *(void *)v252 + 192LL;
    uint64_t v168 = (std::string *)(*(void *)&v252[8] + 8LL);
    do
    {
      v168[-1].__r_.__value_.__l.__cap_ = v247;
      if (SHIBYTE(v249) < 0)
      {
        std::string::__init_copy_ctor_external( v168,  (const std::string::value_type *)__p,  *((std::string::size_type *)&__p + 1));
      }

      else
      {
        *(_OWORD *)&v168->__r_.__value_.__l.__data_ = __p;
        v168->__r_.__value_.__l.__cap_ = v249;
      }

      ++v158;
      uint64_t v168 = (std::string *)((char *)v168 + 32);
    }

    while (v158 != 6);
    *(void *)&v252[16] = v167;
    __int128 v169 = *v155;
    int v170 = *v153;
    id v171 = *(void *)&v252[8];
    if (*v155 == *v153)
    {
      unint64_t v174 = vdupq_n_s64(v169);
      self = v240;
    }

    else
    {
      self = v240;
      do
      {
        id v172 = *(void *)(v169 - 32);
        v169 -= 32LL;
        *(void *)(v171 - 32) = v172;
        v171 -= 32LL;
        id v173 = *(_OWORD *)(v169 + 8);
        *(void *)(v171 + 24) = *(void *)(v169 + 24);
        *(_OWORD *)(v171 + _Block_object_dispose(va, 8) = v173;
        *(void *)(v169 + 16) = 0LL;
        *(void *)(v169 + 24) = 0LL;
        *(void *)(v169 + _Block_object_dispose(va, 8) = 0LL;
      }

      while (v169 != v170);
      unint64_t v174 = *(int64x2_t *)v153;
    }

    GTCaptureArchiveOverrideKey *v153 = v171;
    uint64_t v179 = *v162;
    uint64_t v180 = *(_OWORD *)&v252[16];
    *(int64x2_t *)&v252[8] = v174;
    *(_OWORD *)int64x2_t v155 = v180;
    *(void *)&v252[24] = v179;
    *(void *)uint64_t v252 = v174.i64[0];
    std::__split_buffer<std::pair<ShaderBinaryStatsInfo *,std::string>>::~__split_buffer((uint64_t)v252);
LABEL_157:
    if (SHIBYTE(v249) < 0) {
      operator delete((void *)__p);
    }
    uint64_t v181 = (void *)v235[1];
    unint64_t v182 = (void *)objc_claimAutoreleasedReturnValue([v241[30] objectForKeyedSubscript:v181]);
    *(void *)(*v153 + 32) = -[DYPMTLShaderProfilerHelper setupDataForEvaluatingStreamingSamples:forRingBufferCount:forTargetIndex:]::$_2::operator()( &v250,  v181,  v182,  v239,  *((void **)self + 19));

    int v183 = (void *)v235[1];
    if (v183)
    {
      std::string::basic_string[abi:nn180100]<0>(v252, (char *)[v183 UTF8String]);
      unint64_t v184 = *v153 + 40;
      *(_OWORD *)unint64_t v184 = *(_OWORD *)v252;
      *(void *)(v184 + 16) = *(void *)&v252[16];
      -[DYPMTLShaderProfilerHelper _setupShaderBinaryInfo:withBinaryKey:andNumDraws:]( self,  "_setupShaderBinaryInfo:withBinaryKey:andNumDraws:",  *(void *)(*(void *)(*v153 + 32) + 8LL),  *v153 + 40,  v238);
    }

    id v185 = (void *)v235[2];
    int v186 = (void *)objc_claimAutoreleasedReturnValue([v241[31] objectForKeyedSubscript:v185]);
    *(void *)(*v153 + 64) = -[DYPMTLShaderProfilerHelper setupDataForEvaluatingStreamingSamples:forRingBufferCount:forTargetIndex:]::$_2::operator()( &v250,  v185,  v186,  v239,  *((void **)self + 19));

    uint64_t v187 = (void *)v235[2];
    if (v187)
    {
      std::string::basic_string[abi:nn180100]<0>(v252, (char *)[v187 UTF8String]);
      uint64_t v188 = *v153 + 72;
      *(_OWORD *)uint64_t v188 = *(_OWORD *)v252;
      *(void *)(v188 + 16) = *(void *)&v252[16];
      -[DYPMTLShaderProfilerHelper _setupShaderBinaryInfo:withBinaryKey:andNumDraws:]( self,  "_setupShaderBinaryInfo:withBinaryKey:andNumDraws:",  *(void *)(*(void *)(*v153 + 64) + 8LL),  *v153 + 72,  v238);
    }

    uint64_t v189 = (void *)v235[3];
    unint64_t v190 = (void *)objc_claimAutoreleasedReturnValue([v241[32] objectForKeyedSubscript:v189]);
    *(void *)(*v153 + 96) = -[DYPMTLShaderProfilerHelper setupDataForEvaluatingStreamingSamples:forRingBufferCount:forTargetIndex:]::$_2::operator()( &v250,  v189,  v190,  v239,  *((void **)self + 19));

    uint64_t v191 = (void *)v235[3];
    if (v191)
    {
      std::string::basic_string[abi:nn180100]<0>(v252, (char *)[v191 UTF8String]);
      unint64_t v192 = *v153 + 104;
      *(_OWORD *)unint64_t v192 = *(_OWORD *)v252;
      *(void *)(v192 + 16) = *(void *)&v252[16];
      -[DYPMTLShaderProfilerHelper _setupShaderBinaryInfo:withBinaryKey:andNumDraws:]( self,  "_setupShaderBinaryInfo:withBinaryKey:andNumDraws:",  *(void *)(*(void *)(*v153 + 96) + 8LL),  *v153 + 104,  v238);
    }

    uint64_t v193 = (void *)objc_claimAutoreleasedReturnValue([v235 allShaderKeys]);
    unint64_t v194 = v193 == 0LL;

    if (!v194)
    {
      __int128 v245 = 0u;
      __int128 v246 = 0u;
      id v243 = 0u;
      uint64_t v244 = 0u;
      obuint64_t j = (id)objc_claimAutoreleasedReturnValue([v235 allShaderKeys]);
      uint64_t v195 = [obj countByEnumeratingWithState:&v243 objects:v254 count:16];
      if (v195)
      {
        id v196 = (uint64_t *)(v151 + 40LL * v150);
        unint64_t v237 = *(void *)v244;
        unint64_t v197 = v196 + 2;
        do
        {
          unint64_t v242 = v195;
          for (uint64_t j = 0LL; j != v242; uint64_t j = (char *)j + 1)
          {
            if (*(void *)v244 != v237) {
              objc_enumerationMutation(obj);
            }
            uint64_t v199 = *(id *)(*((void *)&v243 + 1) + 8LL * (void)j);
            uint64_t v200 = strtoull((const char *)[v199 UTF8String], 0, 16);
            uint64_t v201 = (void *)objc_claimAutoreleasedReturnValue([v241[33] objectForKeyedSubscript:v199]);
            uint64_t v202 = -[DYPMTLShaderProfilerHelper setupDataForEvaluatingStreamingSamples:forRingBufferCount:forTargetIndex:]::$_2::operator()( &v250,  v199,  v201,  v239,  *((void **)self + 19));
            id v203 = v199;
            id v204 = (char *)[v203 UTF8String];
            *(void *)uint64_t v252 = v202;
            std::string::basic_string[abi:nn180100]<0>(&v252[8], v204);
            int v205 = v196[1];
            if (v205)
            {
              uint64_t v206 = (uint8x8_t)vcnt_s8((int8x8_t)v205);
              v206.i16[0] = vaddlv_u8(v206);
              if (v206.u32[0] > 1uLL)
              {
                uint64_t v202 = v200;
                if (v200 >= v205) {
                  uint64_t v202 = v200 % v205;
                }
              }

              else
              {
                uint64_t v202 = (v205 - 1) & v200;
              }

              uint64_t v207 = *(void **)(*v196 + 8 * v202);
              if (v207)
              {
                for (uint64_t k = (void *)*v207; k; uint64_t k = (void *)*k)
                {
                  int v209 = k[1];
                  if (v209 == v200)
                  {
                    if (k[2] == v200) {
                      goto LABEL_249;
                    }
                  }

                  else
                  {
                    if (v206.u32[0] > 1uLL)
                    {
                      if (v209 >= v205) {
                        v209 %= v205;
                      }
                    }

                    else
                    {
                      v209 &= v205 - 1;
                    }

                    if (v209 != v202) {
                      break;
                    }
                  }
                }
              }
            }

            uint64_t v210 = operator new(0x38uLL);
            *uint64_t v210 = 0LL;
            v210[1] = v200;
            uint64_t v211 = *(void *)v252;
            v210[2] = v200;
            v210[3] = v211;
            *((_OWORD *)v210 + 2) = *(_OWORD *)&v252[8];
            v210[6] = *(void *)&v252[24];
            memset(&v252[8], 0, 24);
            __int128 v212 = (float)(unint64_t)(v196[3] + 1);
            uint64_t v213 = *((float *)v196 + 8);
            if (!v205 || (float)(v213 * (float)v205) < v212)
            {
              __int128 v214 = (v205 & (v205 - 1)) != 0;
              if (v205 < 3) {
                __int128 v214 = 1LL;
              }
              __int128 v215 = v214 | (2 * v205);
              uint64_t v216 = vcvtps_u32_f32(v212 / v213);
              if (v215 <= v216) {
                int8x8_t prime = (int8x8_t)v216;
              }
              else {
                int8x8_t prime = (int8x8_t)v215;
              }
              if (*(void *)&prime == 1LL)
              {
                int8x8_t prime = (int8x8_t)2LL;
              }

              else if ((*(void *)&prime & (*(void *)&prime - 1LL)) != 0)
              {
                int8x8_t prime = (int8x8_t)std::__next_prime(*(void *)&prime);
              }

              int v205 = v196[1];
              if (*(void *)&prime <= v205)
              {
                if (*(void *)&prime < v205)
                {
                  id v224 = vcvtps_u32_f32((float)(unint64_t)v196[3] / *((float *)v196 + 8));
                  if (v205 < 3
                    || (__int128 v225 = (uint8x8_t)vcnt_s8((int8x8_t)v205), v225.i16[0] = vaddlv_u8(v225), v225.u32[0] > 1uLL))
                  {
                    id v224 = std::__next_prime(v224);
                  }

                  else
                  {
                    __int128 v226 = 1LL << -(char)__clz(v224 - 1);
                    if (v224 >= 2) {
                      id v224 = v226;
                    }
                  }

                  if (*(void *)&prime <= v224) {
                    int8x8_t prime = (int8x8_t)v224;
                  }
                  if (*(void *)&prime >= v205)
                  {
                    int v205 = v196[1];
                  }

                  else
                  {
                    if (prime) {
                      goto LABEL_205;
                    }
                    uint64_t v232 = (void *)*v196;
                    uint64_t *v196 = 0LL;
                    if (v232) {
                      operator delete(v232);
                    }
                    int v205 = 0LL;
                    v196[1] = 0LL;
                  }
                }
              }

              else
              {
LABEL_205:
                if (*(void *)&prime >> 61) {
                  std::__throw_bad_array_new_length[abi:nn180100]();
                }
                __int128 v218 = operator new(8LL * *(void *)&prime);
                unint64_t v219 = (void *)*v196;
                uint64_t *v196 = (uint64_t)v218;
                if (v219) {
                  operator delete(v219);
                }
                __int128 v220 = 0LL;
                v196[1] = (uint64_t)prime;
                do
                  *(void *)(*v196 + 8 * v220++) = 0LL;
                while (*(void *)&prime != v220);
                __int128 v221 = (void *)*v197;
                if (*v197)
                {
                  __int128 v222 = v221[1];
                  __int128 v223 = (uint8x8_t)vcnt_s8(prime);
                  v223.i16[0] = vaddlv_u8(v223);
                  if (v223.u32[0] > 1uLL)
                  {
                    if (v222 >= *(void *)&prime) {
                      v222 %= *(void *)&prime;
                    }
                  }

                  else
                  {
                    v222 &= *(void *)&prime - 1LL;
                  }

                  *(void *)(*v196 + 8 * v222) = v197;
                  int v227 = (void *)*v221;
                  if (*v221)
                  {
                    do
                    {
                      __int128 v228 = v227[1];
                      if (v223.u32[0] > 1uLL)
                      {
                        if (v228 >= *(void *)&prime) {
                          v228 %= *(void *)&prime;
                        }
                      }

                      else
                      {
                        v228 &= *(void *)&prime - 1LL;
                      }

                      if (v228 != v222)
                      {
                        if (!*(void *)(*v196 + 8 * v228))
                        {
                          *(void *)(*v196 + 8 * v22_Block_object_dispose(va, 8) = v221;
                          goto LABEL_230;
                        }

                        *__int128 v221 = *v227;
                        *int v227 = **(void **)(*v196 + 8 * v228);
                        **(void **)(*v196 + 8 * v22_Block_object_dispose(va, 8) = v227;
                        int v227 = v221;
                      }

                      __int128 v228 = v222;
LABEL_230:
                      __int128 v221 = v227;
                      int v227 = (void *)*v227;
                      __int128 v222 = v228;
                    }

                    while (v227);
                  }
                }

                int v205 = (unint64_t)prime;
              }

              if ((v205 & (v205 - 1)) != 0)
              {
                if (v200 >= v205) {
                  uint64_t v202 = v200 % v205;
                }
                else {
                  uint64_t v202 = v200;
                }
              }

              else
              {
                uint64_t v202 = (v205 - 1) & v200;
              }
            }

            __int128 v229 = *v196;
            __int128 v230 = *(void **)(*v196 + 8 * v202);
            if (v230)
            {
              *uint64_t v210 = *v230;
LABEL_247:
              *__int128 v230 = v210;
              goto LABEL_248;
            }

            *uint64_t v210 = *v197;
            *unint64_t v197 = v210;
            *(void *)(v229 + 8 * v202) = v197;
            if (*v210)
            {
              __int128 v231 = *(void *)(*v210 + 8LL);
              if ((v205 & (v205 - 1)) != 0)
              {
                if (v231 >= v205) {
                  v231 %= v205;
                }
              }

              else
              {
                v231 &= v205 - 1;
              }

              __int128 v230 = (void *)(*v196 + 8 * v231);
              goto LABEL_247;
            }

  v45[0] = 0LL;
  ++*(void *)(a1 + 24);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,std::unique_ptr<GPUToolsPlatformLLVMShaderProfilerHelper>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,std::unique_ptr<GPUToolsPlatformLLVMShaderProfilerHelper>>,void *>>>>::reset[abi:nn180100]((uint64_t)v45);
  return i;
}

  if (*(void *)v147)
  {
    uint64_t v35 = 0LL;
    uint64_t v36 = *(void **)v147;
    char v37 = v120;
    do
    {
      ++v35;
      uint64_t v36 = (void *)*v36;
    }

    while (v36);
  }

  else
  {
    uint64_t v35 = 0LL;
    char v37 = v120;
  }

  std::vector<std::string>::__assign_with_size[abi:nn180100]<std::__hash_const_iterator<std::__hash_node<std::string,void *> *>,std::__hash_const_iterator<std::__hash_node<std::string,void *> *>>( (uint64_t *)&xmmword_5B96E0,  *(void **)v147,  v35);
  if (*(void *)v144)
  {
    char v38 = 0LL;
    uint64_t v39 = *(void **)v144;
    do
    {
      ++v38;
      uint64_t v39 = (void *)*v39;
    }

    while (v39);
  }

  else
  {
    char v38 = 0LL;
  }

  std::vector<std::string>::__assign_with_size[abi:nn180100]<std::__hash_const_iterator<std::__hash_node<std::string,void *> *>,std::__hash_const_iterator<std::__hash_node<std::string,void *> *>>( &qword_5B9728,  *(void **)v144,  v38);
  unint64_t v40 = 0LL;
  memset(v133, 0, sizeof(v133));
  uint64_t v134 = 1065353216;
  do
  {
    uint64_t v119 = v40;
    int v41 = agxps_counter_group_get_derived_counters(v37, off_58ECE0[v40], &v136, &v135);
    if (v135) {
      unint64_t v42 = v41;
    }
    else {
      unint64_t v42 = 0;
    }
    if (v42 == 1)
    {
      for (uint64_t j = 0LL; j < v135; ++j)
      {
        int v44 = agxps_counter_get_name(*(void *)(v136 + 8 * j));
        uint64_t v131 = 3735928559LL;
        uint64_t v132 = 1LL;
        if (agxps_counter_get_raw_counters_used_by_derived_counters( v37,  (unint64_t *)(v136 + 8 * j),  1LL,  &v132,  &v131))
        {
          memset(&v153, 0, 24);
          uint64_t v45 = std::__hash_table<std::__hash_value_type<std::string,std::vector<std::string>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<std::string>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<std::string>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<std::string>>>>::__emplace_unique_impl<char const*&,std::vector<std::string>>( (uint64_t *)&xmmword_5B9740,  v44,  (uint64_t)&v153);
          v129.i64[0] = (uint64_t)&v153;
          std::vector<std::string>::__destroy_vector::operator()[abi:nn180100]((void ***)&v129);
          uint64_t v122 = v45;
          uint64_t v121 = (std::__split_buffer<std::string>::pointer *)(v45 + 40);
          uint64_t v123 = *((void *)v45 + 6);
          uint64_t v125 = *((void *)v45 + 5);
          id v129 = 0uLL;
          v130[0] = 0LL;
          if (v131)
          {
            if (v131 > 0xAAAAAAAAAAAAAAALL) {
              abort();
            }
            v153.__end_cap_.__value_ = (std::allocator<std::string> *)v130;
            id v46 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<std::vector<NSObject  {objcproto21OS_dispatch_semaphore}* {__strong}>>>(v131);
            uint64_t v48 = v129.i64[1];
            unint64_t v49 = v129.i64[0];
            if (v129.i64[1] == v129.i64[0])
            {
              uint64_t v52 = vdupq_n_s64(v129.u64[1]);
              unint64_t v50 = v46;
            }

            else
            {
              unint64_t v50 = v46;
              do
              {
                id v51 = *(_OWORD *)(v48 - 24);
                *((void *)v50 - 1) = *(void *)(v48 - 8);
                *(_OWORD *)(v50 - 24) = v51;
                v50 -= 24;
                *(void *)(v48 - 16) = 0LL;
                *(void *)(v48 - _Block_object_dispose(va, 8) = 0LL;
                *(void *)(v48 - 24) = 0LL;
                v48 -= 24LL;
              }

              while (v48 != v49);
              uint64_t v52 = v129;
            }

            v129.i64[0] = (uint64_t)v50;
            v129.i64[1] = (uint64_t)v46;
            *(int64x2_t *)&v153.__begin_ = v52;
            uint64_t v53 = (std::string *)v130[0];
            v130[0] = &v46[24 * v47];
            v153.__end_cap_.__value_ = v53;
            v153.__first_ = (std::__split_buffer<std::string>::pointer)v52.i64[0];
            std::__split_buffer<std::string>::~__split_buffer(&v153);
            if (v131)
            {
              for (uint64_t k = 0LL; k < v131; ++k)
              {
                uint64_t v55 = agxps_counter_get_name(*(void *)(v132 + 8 * k));
                double v56 = (char *)agxps_counter_get_grc_enable_str(*(void *)(v132 + 8 * k));
                uint64_t v128 = v56;
                double v57 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", v56));
                if ([v57 isEqualToString:@"C444B68E04C1CF9E9C5216C15B1C3904605D5CA532A21B510E59CB9AFEE553E3"])
                {
                  uint64_t v58 = 1;
                }

                else
                {
                  uint64_t v59 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithUTF8String:]( &OBJC_CLASS___NSString,  "stringWithUTF8String:",  v56));
                  uint64_t v58 = [v59 isEqualToString:@"004461E8D695B050A2073DC949CCDE4089182A897EA18AEEA2485923F3A19B19"];
                }

                unint64_t v60 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", v55));
                if ([v60 isEqualToString:@"CA64702D3D4494B38F08BCB24ABD879988FB0FFE1D929F859EC9AED1C1C160E1"])
                {

                  continue;
                }

                unint64_t v61 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", v55));
                int64x2_t v62 = [v61 isEqualToString:@"2EAC2CEBA509E12A31090A56155DDCE41EAEE148F6832947CA8A512BDCFA0DF9"];

                if ((v62 & 1) != 0) {
                  continue;
                }
                std::string::basic_string[abi:nn180100]<0>(&v153, v56);
                std::string::basic_string[abi:nn180100]<0>(__p, v55);
                end_high = HIBYTE(v153.__end_);
                if (SHIBYTE(v153.__end_) >= 0) {
                  begiuint64_t n = (std::__split_buffer<std::string>::pointer)HIBYTE(v153.__end_);
                }
                else {
                  begiuint64_t n = v153.__begin_;
                }
                __int128 v65 = (std::__split_buffer<std::string>::pointer)HIBYTE(v127);
                id v66 = SHIBYTE(v127);
                if (v127 < 0) {
                  __int128 v65 = (std::__split_buffer<std::string>::pointer)__p[1];
                }
                if (begin == v65)
                {
                  if (v127 >= 0) {
                    id v67 = __p;
                  }
                  else {
                    id v67 = (void **)__p[0];
                  }
                  if (SHIBYTE(v153.__end_) < 0)
                  {
                    int v76 = memcmp(v153.__first_, v67, (size_t)v153.__begin_) == 0;
                    if (v66 < 0) {
                      goto LABEL_145;
                    }
                  }

                  else if (HIBYTE(v153.__end_))
                  {
                    id v68 = HIBYTE(v153.__end_) - 1LL;
                    NSRange v69 = &v153;
                    do
                    {
                      first_low = LOBYTE(v69->__first_);
                      NSRange v69 = (std::__split_buffer<std::string> *)((char *)v69 + 1);
                      id v70 = first_low;
                      uint64_t v73 = *(unsigned __int8 *)v67;
                      id v67 = (void **)((char *)v67 + 1);
                      uint64_t v72 = v73;
                      uint64_t v75 = v68-- != 0;
                      int v76 = v70 == v72;
                    }

                    while (v70 == v72 && v75);
                    if (SHIBYTE(v127) < 0)
                    {
LABEL_145:
                      operator delete(__p[0]);
                      if ((HIBYTE(v153.__end_) & 0x80) == 0) {
                        goto LABEL_133;
                      }
                      goto LABEL_146;
                    }
                  }

                  else
                  {
                    int v76 = 1;
                    if (SHIBYTE(v127) < 0) {
                      goto LABEL_145;
                    }
                  }
                }

                else
                {
                  int v76 = 0;
                  if (SHIBYTE(v127) < 0) {
                    goto LABEL_145;
                  }
                }

                if ((end_high & 0x80) == 0) {
                  goto LABEL_133;
                }
LABEL_146:
                operator delete(v153.__first_);
LABEL_133:
                if (!byte_5B9768)
                {
                  uint64_t v83 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithUTF8String:]( &OBJC_CLASS___NSString,  "stringWithUTF8String:",  v56));
                  id v84 = [v83 isEqualToString:@"_b08194796a2cb35a8699c8d23b129c582951d9d1941fbc8e36dbaafa02d474e7"];

                  if ((v84 & 1) != 0) {
                    continue;
                  }
                  if (!byte_5B9768) {
                    goto LABEL_135;
                  }
                }

                int v77 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", v56));
                int v78 = [v77 isEqualToString:@"_6c6b4958950feeff7717076797af362e443d3c99b08053bcf8ca2d302a9f67a6"];

                if ((v78 & 1) == 0)
                {
LABEL_135:
                  int v79 = agxps_counter_deobfuscate_name(v56);
                  uint64_t v128 = v79;
                  if (*v79) {
                    unint64_t v80 = v58;
                  }
                  else {
                    unint64_t v80 = 1;
                  }
                  if ((v80 & 1) == 0)
                  {
                    if (v76)
                    {
                      std::string::basic_string[abi:nn180100]<0>(&v153, v79);
                      std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::__emplace_unique_key_args<std::string,std::string>( (uint64_t)&v140,  (uint64_t)&v153,  (uint64_t)&v153);
                      if (SHIBYTE(v153.__end_) < 0) {
                        operator delete(v153.__first_);
                      }
                      std::string::basic_string[abi:nn180100]<0>(__p, v79);
                      uint64_t v81 = (_OWORD *)v129.i64[1];
                      if (v129.i64[1] < v130[0])
                      {
                        uint64_t v82 = *(_OWORD *)__p;
                        *(void *)(v129.i64[1] + 16) = v127;
                        *uint64_t v81 = v82;
                        v129.i64[1] = (uint64_t)v81 + 24;
                        goto LABEL_173;
                      }

                      uint64_t v86 = 0xAAAAAAAAAAAAAAABLL * ((v129.i64[1] - v129.i64[0]) >> 3);
                      int v87 = v86 + 1;
                      if (v86 + 1 > 0xAAAAAAAAAAAAAAALL) {
                        abort();
                      }
                      if (0x5555555555555556LL * ((v130[0] - v129.i64[0]) >> 3) > v87) {
                        int v87 = 0x5555555555555556LL * ((v130[0] - v129.i64[0]) >> 3);
                      }
                      if (0xAAAAAAAAAAAAAAABLL * ((v130[0] - v129.i64[0]) >> 3) >= 0x555555555555555LL) {
                        uint64_t v88 = 0xAAAAAAAAAAAAAAALL;
                      }
                      else {
                        uint64_t v88 = v87;
                      }
                      v153.__end_cap_.__value_ = (std::allocator<std::string> *)v130;
                      if (v88) {
                        uint64_t v88 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<std::vector<NSObject  {objcproto21OS_dispatch_semaphore}* {__strong}>>>(v88);
                      }
                      else {
                        uint64_t v89 = 0LL;
                      }
                      uint64_t v90 = v88 + 24 * v86;
                      uint64_t v91 = *(_OWORD *)__p;
                      *(void *)(v90 + 16) = v127;
                      *(_OWORD *)uint64_t v90 = v91;
                      __p[1] = 0LL;
                      uint64_t v127 = 0LL;
                      __p[0] = 0LL;
                      id v92 = v129.i64[1];
                      uint64_t v93 = v129.i64[0];
                      if (v129.i64[1] == v129.i64[0])
                      {
                        id v96 = vdupq_n_s64(v129.u64[1]);
                        id v94 = v88 + 24 * v86;
                      }

                      else
                      {
                        id v94 = v88 + 24 * v86;
                        do
                        {
                          id v95 = *(_OWORD *)(v92 - 24);
                          *(void *)(v94 - _Block_object_dispose(va, 8) = *(void *)(v92 - 8);
                          *(_OWORD *)(v94 - 24) = v95;
                          v94 -= 24LL;
                          *(void *)(v92 - 16) = 0LL;
                          *(void *)(v92 - _Block_object_dispose(va, 8) = 0LL;
                          *(void *)(v92 - 24) = 0LL;
                          v92 -= 24LL;
                        }

                        while (v92 != v93);
                        id v96 = v129;
                      }

                      id v97 = v90 + 24;
                      v129.i64[0] = v94;
                      v129.i64[1] = v90 + 24;
                      *(int64x2_t *)&v153.__begin_ = v96;
                      id v98 = (std::string *)v130[0];
                      v130[0] = v88 + 24 * v89;
                      v153.__end_cap_.__value_ = v98;
                      v153.__first_ = (std::__split_buffer<std::string>::pointer)v96.i64[0];
                      std::__split_buffer<std::string>::~__split_buffer(&v153);
                      v129.i64[1] = v97;
                      if ((SHIBYTE(v127) & 0x80000000) == 0) {
                        goto LABEL_173;
                      }
                      first = (std::__split_buffer<std::string>::pointer)__p[0];
LABEL_172:
                      operator delete(first);
                    }

                    else
                    {
                      std::string::basic_string[abi:nn180100]<0>(&v153, v79);
                      std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::__emplace_unique_key_args<std::string,std::string>( (uint64_t)&v137,  (uint64_t)&v153,  (uint64_t)&v153);
                      if (SHIBYTE(v153.__end_) < 0)
                      {
                        first = v153.__first_;
                        goto LABEL_172;
                      }
                    }

  ++a1[3];
  return v16;
}

void sub_E5A1C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
}

void sub_E5B34( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_E5C50( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_E5E14( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_E5FD8( _Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t std::__hash_table<std::__hash_value_type<unsigned int,std::string>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,std::string>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,std::string>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,std::string>>>::~__hash_table( uint64_t a1)
{
  uint64_t v2 = *(void ***)(a1 + 16);
  if (v2)
  {
    do
    {
      uint64_t v3 = (void **)*v2;
      operator delete(v2);
      uint64_t v2 = v3;
    }

    while (v3);
  }

  uint64_t v4 = *(void **)a1;
  *(void *)a1 = 0LL;
  if (v4) {
    operator delete(v4);
  }
  return a1;
}

void std::__tree<std::__value_type<ShaderDebugger::Metadata::MDBase::MetadataType,ShaderDebugger::Metadata::MDSerializer::MetadataTypeContainer>,std::__map_value_compare<ShaderDebugger::Metadata::MDBase::MetadataType,std::__value_type<ShaderDebugger::Metadata::MDBase::MetadataType,ShaderDebugger::Metadata::MDSerializer::MetadataTypeContainer>,std::less<ShaderDebugger::Metadata::MDBase::MetadataType>,true>,std::allocator<std::__value_type<ShaderDebugger::Metadata::MDBase::MetadataType,ShaderDebugger::Metadata::MDSerializer::MetadataTypeContainer>>>::destroy( void *a1)
{
  if (a1)
  {
    std::__tree<std::__value_type<ShaderDebugger::Metadata::MDBase::MetadataType,ShaderDebugger::Metadata::MDSerializer::MetadataTypeContainer>,std::__map_value_compare<ShaderDebugger::Metadata::MDBase::MetadataType,std::__value_type<ShaderDebugger::Metadata::MDBase::MetadataType,ShaderDebugger::Metadata::MDSerializer::MetadataTypeContainer>,std::less<ShaderDebugger::Metadata::MDBase::MetadataType>,true>,std::allocator<std::__value_type<ShaderDebugger::Metadata::MDBase::MetadataType,ShaderDebugger::Metadata::MDSerializer::MetadataTypeContainer>>>::destroy(*a1);
    std::__tree<std::__value_type<ShaderDebugger::Metadata::MDBase::MetadataType,ShaderDebugger::Metadata::MDSerializer::MetadataTypeContainer>,std::__map_value_compare<ShaderDebugger::Metadata::MDBase::MetadataType,std::__value_type<ShaderDebugger::Metadata::MDBase::MetadataType,ShaderDebugger::Metadata::MDSerializer::MetadataTypeContainer>,std::less<ShaderDebugger::Metadata::MDBase::MetadataType>,true>,std::allocator<std::__value_type<ShaderDebugger::Metadata::MDBase::MetadataType,ShaderDebugger::Metadata::MDSerializer::MetadataTypeContainer>>>::destroy(a1[1]);
    std::__destroy_at[abi:nn180100]<std::pair<ShaderDebugger::Metadata::MDBase::MetadataType const,ShaderDebugger::Metadata::MDSerializer::MetadataTypeContainer>,0>(a1 + 4);
    operator delete(a1);
  }

void ShaderDebugger::Metadata::MDSerializerLLVM3XXX::serializeThreadTracePoint(uint64_t **a1, uint64_t *a2)
{
  uint64_t v3 = *a2;
  uint64_t v4 = *(void *)(*(void *)(*a2 - 8LL * *(unsigned int *)(*a2 + 8) + 16) + 128LL);
  unsigned int v5 = *(_DWORD *)(v4 + 32);
  if (v5 > 0x40) {
    uint64_t v6 = **(void **)(v4 + 24);
  }
  else {
    uint64_t v6 = (uint64_t)(*(void *)(v4 + 24) << -(char)v5) >> -(char)v5;
  }
  int v7 = *((_DWORD *)a2 + 4);
  ShaderDebugger::Metadata::MDSerializerLLVM3XXX::extractTracePointLocation(a1, *a2);
  uint64_t v8 = *(void *)(*(void *)(v3 - 8LL * *(unsigned int *)(v3 + 8) + 32) + 128LL);
  unsigned int v9 = *(_DWORD *)(v8 + 32);
  if (v9 > 0x40) {
    LODWORD(v_Block_object_dispose(va, 8) = **(_DWORD **)(v8 + 24);
  }
  else {
    uint64_t v8 = (uint64_t)(*(void *)(v8 + 24) << -(char)v9) >> -(char)v9;
  }
  uint64_t v17 = v8;
  uint64_t v18 = v6 & 0xFFFFFF | (v7 << 24);
  uint64_t v16 = 5LL;
  unint64_t v10 = std::__tree<std::__value_type<ShaderDebugger::Metadata::MDBase::MetadataType,ShaderDebugger::Metadata::MDSerializer::MetadataTypeContainer>,std::__map_value_compare<ShaderDebugger::Metadata::MDBase::MetadataType,std::__value_type<ShaderDebugger::Metadata::MDBase::MetadataType,ShaderDebugger::Metadata::MDSerializer::MetadataTypeContainer>,std::less<ShaderDebugger::Metadata::MDBase::MetadataType>,true>,std::allocator<std::__value_type<ShaderDebugger::Metadata::MDBase::MetadataType,ShaderDebugger::Metadata::MDSerializer::MetadataTypeContainer>>>::__emplace_unique_key_args<ShaderDebugger::Metadata::MDBase::MetadataType,std::piecewise_construct_t const&,std::tuple<ShaderDebugger::Metadata::MDBase::MetadataType&&>,std::tuple<>>( a1,  5uLL,  &v16);
  uint64_t v11 = v10;
  uint64_t v13 = (uint64_t)(v10 + 40);
  id v12 = (char *)*((void *)v10 + 5);
  uint64_t v14 = (char *)*((void *)v10 + 6);
  uint64_t v15 = v12;
  if (v12 != v14)
  {
    while (*(void *)v15 != v3)
    {
      v15 += 8;
      if (v15 == v14)
      {
        uint64_t v15 = (char *)*((void *)v10 + 6);
        break;
      }
    }
  }

  if (v15 == v14
    || v15 - v12 == -8
    || ShaderDebugger::Metadata::MDSerializer::isMetadataIdReserved((char **)v10 + 5, v3))
  {
    uint64_t v16 = ShaderDebugger::Metadata::MDSerializer::addAndLinearizeMetadataId(v13, v3);
    ShaderDebugger::Metadata::MDSerializer::write<unsigned long long>((unint64_t *)v11 + 11, &v16);
    ShaderDebugger::Metadata::MDSerializer::write<unsigned long long>((unint64_t *)v11 + 11, &v18);
    ShaderDebugger::Metadata::MDSerializer::write<unsigned long long>((unint64_t *)v11 + 11, &v17);
  }

void ShaderDebugger::Metadata::MDSerializerLLVM3XXX::serializeFunctionBeginTracePoint( uint64_t **a1, _DWORD *a2)
{
  uint64_t v3 = *(void *)a2;
  uint64_t v4 = *(void *)a2 - 8LL * *(unsigned int *)(*(void *)a2 + 8LL);
  uint64_t v5 = *(void *)(*(void *)(v4 + 16) + 128LL);
  unsigned int v6 = *(_DWORD *)(v5 + 32);
  if (v6 > 0x40) {
    uint64_t v7 = **(void **)(v5 + 24);
  }
  else {
    uint64_t v7 = (uint64_t)(*(void *)(v5 + 24) << -(char)v6) >> -(char)v6;
  }
  uint64_t v8 = v7 & 0xFFFFFF | (a2[4] << 24);
  uint64_t v9 = ShaderDebugger::Metadata::MDSerializerLLVM3XXX::serializeSubprogram(a1, *(void *)(v4 + 32));
  ShaderDebugger::Metadata::MDSerializer::serializeFunctionTracepoint(a1, v3, v8, 1LL, v9, -1LL);
}

void ShaderDebugger::Metadata::MDSerializerLLVM3XXX::serializeFunctionEndTracePoint( uint64_t **a1, uint64_t *a2)
{
  uint64_t v3 = *a2;
  uint64_t v4 = *(void *)(*(void *)(*a2 - 8LL * *(unsigned int *)(*a2 + 8) + 16) + 128LL);
  unsigned int v5 = *(_DWORD *)(v4 + 32);
  if (v5 > 0x40) {
    uint64_t v6 = **(void **)(v4 + 24);
  }
  else {
    uint64_t v6 = (uint64_t)(*(void *)(v4 + 24) << -(char)v5) >> -(char)v5;
  }
  uint64_t v7 = v6 & 0xFFFFFF | (*((_DWORD *)a2 + 4) << 24);
  TracePointLocatiouint64_t n = ShaderDebugger::Metadata::MDSerializerLLVM3XXX::extractTracePointLocation(a1, *a2);
  uint64_t v9 = ShaderDebugger::Metadata::MDSerializerLLVM3XXX::serializeSubprogram( a1,  *(void *)(v3 - 8LL * *(unsigned int *)(v3 + 8) + 32));
  ShaderDebugger::Metadata::MDSerializer::serializeFunctionTracepoint(a1, v3, v7, 2LL, v9, TracePointLocation);
}

void ShaderDebugger::Metadata::MDSerializerLLVM3XXX::serializeFunctionCallTracePoint( uint64_t **a1, uint64_t *a2)
{
  uint64_t v3 = *a2;
  uint64_t v4 = *(void *)(*(void *)(*a2 - 8LL * *(unsigned int *)(*a2 + 8) + 16) + 128LL);
  unsigned int v5 = *(_DWORD *)(v4 + 32);
  if (v5 > 0x40) {
    uint64_t v6 = **(void **)(v4 + 24);
  }
  else {
    uint64_t v6 = (uint64_t)(*(void *)(v4 + 24) << -(char)v5) >> -(char)v5;
  }
  uint64_t v7 = v6 & 0xFFFFFF | (*((_DWORD *)a2 + 4) << 24);
  TracePointLocatiouint64_t n = ShaderDebugger::Metadata::MDSerializerLLVM3XXX::extractTracePointLocation(a1, *a2);
  uint64_t v9 = *(llvm::MDString **)(v3 - 8LL * *(unsigned int *)(v3 + 8) + 32);
  if (v9)
  {
    if (*(_BYTE *)v9)
    {
      if (*(_BYTE *)v9 == 17)
      {
        uint64_t v10 = ShaderDebugger::Metadata::MDSerializerLLVM3XXX::serializeSubprogram(a1, (uint64_t)v9);
        ShaderDebugger::Metadata::MDSerializer::serializeFunctionTracepoint(a1, v3, v7, 0LL, v10, TracePointLocation);
      }

      return;
    }

    String = (void *)llvm::MDString::getString(v9);
    if (String)
    {
      std::string::basic_string[abi:nn180100](__p, String, v12);
    }

    else
    {
      __p[0] = 0LL;
      __p[1] = 0LL;
      uint64_t v15 = 0LL;
    }
  }

  else
  {
    std::string::basic_string[abi:nn180100]<0>(__p, "__gt_unnamed_function_call__");
  }

  uint64_t v13 = ShaderDebugger::Metadata::MDSerializer::serializeSubprogram(a1, -1LL, (uint64_t)__p, TracePointLocation);
  if (SHIBYTE(v15) < 0) {
    operator delete(__p[0]);
  }
  ShaderDebugger::Metadata::MDSerializer::serializeFunctionTracepoint(a1, v3, v7, 0LL, v13, TracePointLocation);
}

void ShaderDebugger::Metadata::MDSerializerLLVM3XXX::serializeVariableTracePoint(uint64_t **a1, uint64_t a2)
{
  uint64_t v3 = *(void *)a2;
  uint64_t v4 = *(void *)a2 - 8LL * *(unsigned int *)(*(void *)a2 + 8LL);
  uint64_t v5 = *(void *)(*(void *)(v4 + 16) + 128LL);
  unsigned int v6 = *(_DWORD *)(v5 + 32);
  if (v6 > 0x40) {
    uint64_t v7 = **(void **)(v5 + 24);
  }
  else {
    uint64_t v7 = (uint64_t)(*(void *)(v5 + 24) << -(char)v6) >> -(char)v6;
  }
  uint64_t v8 = *(void *)(*(void *)(v4 + 40) + 128LL);
  unsigned int v9 = *(_DWORD *)(v8 + 32);
  if (v9 > 0x40) {
    LODWORD(v10) = **(_DWORD **)(v8 + 24);
  }
  else {
    uint64_t v10 = (uint64_t)(*(void *)(v8 + 24) << -(char)v9) >> -(char)v9;
  }
  int v11 = *(_DWORD *)(a2 + 16);
  size_t v12 = *(llvm::DIVariable **)(v4 + 32);
  int v13 = *(unsigned __int8 *)v12;
  if (*(_BYTE *)v12)
  {
    if (v13 == 24)
    {
      unint64_t v58 = ((void *)v12 - *((unsigned int *)v12 + 2))[3];
      v101[0] = 0LL;
      v101[1] = 0LL;
      uint64_t v100 = v101;
      uint64_t v59 = ShaderDebugger::Metadata::MDSerializerLLVM3XXX::serializeType(a1, v58, &v100);
      std::__tree<llvm::DIType *>::destroy(v101[0]);
      Filename = llvm::DIVariable::getFilename(v12);
      if (Filename) {
        std::string::basic_string[abi:nn180100](&__p, Filename, v61);
      }
      else {
        memset(&__p, 0, sizeof(__p));
      }
      Directory = llvm::DIVariable::getDirectory(v12);
      if (Directory) {
        std::string::basic_string[abi:nn180100](&__dst, Directory, v65);
      }
      else {
        memset(&__dst, 0, sizeof(__dst));
      }
      uint64_t v76 = ShaderDebugger::Metadata::MDSerializer::serializeLocation( a1,  (uint64_t)v12 + 1,  &__p,  &__dst,  *((unsigned int *)v12 + 6),  -1LL);
      int v77 = (llvm::MDString *)((void *)v12 - *((unsigned int *)v12 + 2))[1];
      else {
        memset(&__p, 0, sizeof(__p));
      }
      uint64_t v75 = ShaderDebugger::Metadata::MDSerializer::serializeGlobalVariable(a1, (uint64_t)v12, (uint64_t)&__p, v59, v76);
      goto LABEL_105;
    }

    if (v13 == 25)
    {
      unint64_t v14 = ((void *)v12 - *((unsigned int *)v12 + 2))[3];
      v105[0] = 0LL;
      v105[1] = 0LL;
      uint64_t v104 = v105;
      uint64_t v15 = ShaderDebugger::Metadata::MDSerializerLLVM3XXX::serializeType(a1, v14, &v104);
      std::__tree<llvm::DIType *>::destroy(v105[0]);
      uint64_t v16 = llvm::DIVariable::getFilename(v12);
      if (v16) {
        std::string::basic_string[abi:nn180100](&__p, v16, v17);
      }
      else {
        memset(&__p, 0, sizeof(__p));
      }
      int64x2_t v62 = llvm::DIVariable::getDirectory(v12);
      if (v62) {
        std::string::basic_string[abi:nn180100](&__dst, v62, v63);
      }
      else {
        memset(&__dst, 0, sizeof(__dst));
      }
      uint64_t v66 = ShaderDebugger::Metadata::MDSerializer::serializeLocation( a1,  (uint64_t)v12 + 1,  &__p,  &__dst,  *((unsigned int *)v12 + 6),  -1LL);
      id v67 = (llvm::MDString *)((void *)v12 - *((unsigned int *)v12 + 2))[1];
      else {
        memset(&__p, 0, sizeof(__p));
      }
      char v70 = *((_WORD *)v12 + 16) != 0;
      id v71 = a1;
      uint64_t v72 = (uint64_t)v12;
      uint64_t v73 = v15;
      uint64_t v74 = v66;
      goto LABEL_94;
    }

void ShaderDebugger::Metadata::MDSerializerLLVM3XXX::serializeDataTracePoint(uint64_t **a1, uint64_t *a2)
{
  uint64_t v3 = *a2;
  uint64_t v4 = *(void *)(*(void *)(*a2 - 8LL * *(unsigned int *)(*a2 + 8) + 16) + 128LL);
  unsigned int v5 = *(_DWORD *)(v4 + 32);
  if (v5 > 0x40) {
    uint64_t v6 = **(void **)(v4 + 24);
  }
  else {
    uint64_t v6 = (uint64_t)(*(void *)(v4 + 24) << -(char)v5) >> -(char)v5;
  }
  int v7 = *((_DWORD *)a2 + 4);
  TracePointLocatiouint64_t n = ShaderDebugger::Metadata::MDSerializerLLVM3XXX::extractTracePointLocation(a1, *a2);
  uint64_t v9 = v3 - 8LL * *(unsigned int *)(v3 + 8);
  uint64_t v10 = *(void *)(*(void *)(v9 + 32) + 128LL);
  unsigned int v11 = *(_DWORD *)(v10 + 32);
  if (v11 > 0x40) {
    uint64_t v12 = **(void **)(v10 + 24);
  }
  else {
    uint64_t v12 = (uint64_t)(*(void *)(v10 + 24) << -(char)v11) >> -(char)v11;
  }
  uint64_t v13 = *(void *)(*(void *)(v9 + 40) + 128LL);
  unsigned int v14 = *(_DWORD *)(v13 + 32);
  if (v14 > 0x40) {
    LODWORD(v15) = **(_DWORD **)(v13 + 24);
  }
  else {
    uint64_t v15 = (uint64_t)(*(void *)(v13 + 24) << -(char)v14) >> -(char)v14;
  }
  uint64_t v25 = TracePointLocation;
  uint64_t v26 = v6 & 0xFFFFFF | (v7 << 24);
  int v24 = v12;
  uint64_t v23 = 8LL;
  uint64_t v16 = std::__tree<std::__value_type<ShaderDebugger::Metadata::MDBase::MetadataType,ShaderDebugger::Metadata::MDSerializer::MetadataTypeContainer>,std::__map_value_compare<ShaderDebugger::Metadata::MDBase::MetadataType,std::__value_type<ShaderDebugger::Metadata::MDBase::MetadataType,ShaderDebugger::Metadata::MDSerializer::MetadataTypeContainer>,std::less<ShaderDebugger::Metadata::MDBase::MetadataType>,true>,std::allocator<std::__value_type<ShaderDebugger::Metadata::MDBase::MetadataType,ShaderDebugger::Metadata::MDSerializer::MetadataTypeContainer>>>::__emplace_unique_key_args<ShaderDebugger::Metadata::MDBase::MetadataType,std::piecewise_construct_t const&,std::tuple<ShaderDebugger::Metadata::MDBase::MetadataType&&>,std::tuple<>>( a1,  8uLL,  &v23);
  size_t v17 = v16;
  uint64_t v19 = (uint64_t)(v16 + 40);
  uint64_t v18 = (char *)*((void *)v16 + 5);
  unint64_t v20 = (char *)*((void *)v16 + 6);
  char v21 = v18;
  if (v18 != v20)
  {
    while (*(void *)v21 != v3)
    {
      v21 += 8;
      if (v21 == v20)
      {
        char v21 = (char *)*((void *)v16 + 6);
        break;
      }
    }
  }

  if (v21 == v20
    || v21 - v18 == -8
    || ShaderDebugger::Metadata::MDSerializer::isMetadataIdReserved((char **)v16 + 5, v3))
  {
    uint64_t v23 = ShaderDebugger::Metadata::MDSerializer::addAndLinearizeMetadataId(v19, v3);
    ShaderDebugger::Metadata::MDSerializer::write<unsigned long long>((unint64_t *)v17 + 11, &v23);
    ShaderDebugger::Metadata::MDSerializer::write<unsigned long long>((unint64_t *)v17 + 11, &v26);
    ShaderDebugger::Metadata::MDSerializer::write<unsigned long long>((unint64_t *)v17 + 11, &v25);
    ShaderDebugger::Metadata::MDSerializer::write<unsigned int>((unint64_t *)v17 + 11, &v24);
    uint64_t v22 = v15;
    ShaderDebugger::Metadata::MDSerializer::write<unsigned long long>((unint64_t *)v17 + 11, &v22);
  }

void ShaderDebugger::Metadata::MDSerializerLLVM3XXX::serializeDataValueTracePoint(uint64_t **a1, uint64_t *a2)
{
  uint64_t v3 = *a2;
  uint64_t v4 = *(void *)(*(void *)(*a2 - 8LL * *(unsigned int *)(*a2 + 8) + 16) + 128LL);
  unsigned int v5 = *(_DWORD *)(v4 + 32);
  if (v5 > 0x40) {
    uint64_t v6 = **(void **)(v4 + 24);
  }
  else {
    uint64_t v6 = (uint64_t)(*(void *)(v4 + 24) << -(char)v5) >> -(char)v5;
  }
  int v7 = *((_DWORD *)a2 + 4);
  TracePointLocatiouint64_t n = ShaderDebugger::Metadata::MDSerializerLLVM3XXX::extractTracePointLocation(a1, *a2);
  uint64_t v9 = *(llvm::DIVariable **)(v3 - 8LL * *(unsigned int *)(v3 + 8) + 32);
  int v10 = *(unsigned __int8 *)v9;
  if (v10 == 24)
  {
    unint64_t v15 = ((void *)v9 - *((unsigned int *)v9 + 2))[3];
    v47[0] = 0LL;
    v47[1] = 0LL;
    id v46 = v47;
    uint64_t v16 = ShaderDebugger::Metadata::MDSerializerLLVM3XXX::serializeType(a1, v15, &v46);
    std::__tree<llvm::DIType *>::destroy(v47[0]);
    Filename = llvm::DIVariable::getFilename(v9);
    if (Filename) {
      std::string::basic_string[abi:nn180100](&__dst, Filename, v18);
    }
    else {
      memset(&__dst, 0, sizeof(__dst));
    }
    Directory = llvm::DIVariable::getDirectory(v9);
    if (Directory) {
      std::string::basic_string[abi:nn180100](&__p, Directory, v23);
    }
    else {
      memset(&__p, 0, sizeof(__p));
    }
    uint64_t v29 = ShaderDebugger::Metadata::MDSerializer::serializeLocation( a1,  (uint64_t)v9 + 1,  &__dst,  &__p,  *((unsigned int *)v9 + 6),  -1LL);
    BOOL v30 = (llvm::MDString *)((void *)v9 - *((unsigned int *)v9 + 2))[1];
    else {
      memset(&__dst, 0, sizeof(__dst));
    }
    uint64_t v28 = ShaderDebugger::Metadata::MDSerializer::serializeGlobalVariable(a1, (uint64_t)v9, (uint64_t)&__dst, v16, v29);
  }

  else
  {
    if (v10 != 25)
    {
      uint64_t v19 = -1LL;
      goto LABEL_39;
    }

    unint64_t v11 = ((void *)v9 - *((unsigned int *)v9 + 2))[3];
    v51[0] = 0LL;
    v51[1] = 0LL;
    std::string::size_type v50 = v51;
    uint64_t v12 = ShaderDebugger::Metadata::MDSerializerLLVM3XXX::serializeType(a1, v11, &v50);
    std::__tree<llvm::DIType *>::destroy(v51[0]);
    uint64_t v13 = llvm::DIVariable::getFilename(v9);
    if (v13) {
      std::string::basic_string[abi:nn180100](&__dst, v13, v14);
    }
    else {
      memset(&__dst, 0, sizeof(__dst));
    }
    unint64_t v20 = llvm::DIVariable::getDirectory(v9);
    if (v20) {
      std::string::basic_string[abi:nn180100](&__p, v20, v21);
    }
    else {
      memset(&__p, 0, sizeof(__p));
    }
    uint64_t v24 = ShaderDebugger::Metadata::MDSerializer::serializeLocation( a1,  (uint64_t)v9 + 1,  &__dst,  &__p,  *((unsigned int *)v9 + 6),  -1LL);
    uint64_t v25 = (llvm::MDString *)((void *)v9 - *((unsigned int *)v9 + 2))[1];
    else {
      memset(&__dst, 0, sizeof(__dst));
    }
    uint64_t v28 = ShaderDebugger::Metadata::MDSerializer::serializeLocalVariable( a1,  (uint64_t)v9,  (uint64_t)&__dst,  v12,  v24,  *((_WORD *)v9 + 16) != 0);
  }

  uint64_t v19 = v28;
LABEL_39:
  uint64_t v33 = *(unsigned int *)(v3 + 8);
  uint64_t v34 = *(void *)(v3 - 8 * v33 + 40);
  if (*(_BYTE *)v34 == 6)
  {
    llvm::DIExpression::getFragmentInfo(&__dst, *(void *)(v34 + 24), *(void *)(v34 + 32));
    std::string::size_type v35 = __dst.__r_.__value_.__r.__words[0];
    if (__dst.__r_.__value_.__s.__data_[16]) {
      std::string::size_type size = __dst.__r_.__value_.__l.__size_;
    }
    else {
      std::string::size_type size = 0LL;
    }
    if (!__dst.__r_.__value_.__s.__data_[16]) {
      std::string::size_type v35 = 0LL;
    }
    uint64_t v33 = *(unsigned int *)(v3 + 8);
  }

  else
  {
    std::string::size_type size = 0LL;
    std::string::size_type v35 = 0LL;
  }

  uint64_t v37 = *(void *)(*(void *)(v3 - 8 * v33 + 48) + 128LL);
  unsigned int v38 = *(_DWORD *)(v37 + 32);
  if (v38 > 0x40) {
    uint64_t v39 = **(void **)(v37 + 24);
  }
  else {
    uint64_t v39 = (uint64_t)(*(void *)(v37 + 24) << -(char)v38) >> -(char)v38;
  }
  __dst.__r_.__value_.__r.__words[0] = v6 & 0xFFFFFF | (v7 << 24);
  __p.__r_.__value_.__r.__words[0] = TracePointLocation;
  uint64_t v55 = v39;
  uint64_t v56 = v19;
  std::string::size_type v53 = size;
  std::string::size_type v54 = v35;
  uint64_t v52 = 10LL;
  BOOL v40 = std::__tree<std::__value_type<ShaderDebugger::Metadata::MDBase::MetadataType,ShaderDebugger::Metadata::MDSerializer::MetadataTypeContainer>,std::__map_value_compare<ShaderDebugger::Metadata::MDBase::MetadataType,std::__value_type<ShaderDebugger::Metadata::MDBase::MetadataType,ShaderDebugger::Metadata::MDSerializer::MetadataTypeContainer>,std::less<ShaderDebugger::Metadata::MDBase::MetadataType>,true>,std::allocator<std::__value_type<ShaderDebugger::Metadata::MDBase::MetadataType,ShaderDebugger::Metadata::MDSerializer::MetadataTypeContainer>>>::__emplace_unique_key_args<ShaderDebugger::Metadata::MDBase::MetadataType,std::piecewise_construct_t const&,std::tuple<ShaderDebugger::Metadata::MDBase::MetadataType&&>,std::tuple<>>( a1,  0xAuLL,  &v52);
  int v41 = v40;
  uint64_t v43 = (uint64_t)(v40 + 40);
  unint64_t v42 = (char *)*((void *)v40 + 5);
  int v44 = (char *)*((void *)v40 + 6);
  uint64_t v45 = v42;
  if (v42 != v44)
  {
    while (*(void *)v45 != v3)
    {
      v45 += 8;
      if (v45 == v44)
      {
        uint64_t v45 = (char *)*((void *)v40 + 6);
        break;
      }
    }
  }

  if (v45 == v44
    || v45 - v42 == -8
    || ShaderDebugger::Metadata::MDSerializer::isMetadataIdReserved((char **)v40 + 5, v3))
  {
    uint64_t v52 = ShaderDebugger::Metadata::MDSerializer::addAndLinearizeMetadataId(v43, v3);
    ShaderDebugger::Metadata::MDSerializer::write<unsigned long long>((unint64_t *)v41 + 11, &v52);
    ShaderDebugger::Metadata::MDSerializer::write<unsigned long long>((unint64_t *)v41 + 11, &__dst);
    ShaderDebugger::Metadata::MDSerializer::write<unsigned long long>((unint64_t *)v41 + 11, &__p);
    ShaderDebugger::Metadata::MDSerializer::write<unsigned long long>((unint64_t *)v41 + 11, &v56);
    ShaderDebugger::Metadata::MDSerializer::write<unsigned long long>((unint64_t *)v41 + 11, &v55);
    ShaderDebugger::Metadata::MDSerializer::write<unsigned long long>((unint64_t *)v41 + 11, &v54);
    ShaderDebugger::Metadata::MDSerializer::write<unsigned long long>((unint64_t *)v41 + 11, &v53);
  }

void ShaderDebugger::Metadata::MDSerializerLLVM3XXX::serializeWaypointTracePoint( uint64_t **a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v5 = *a2;
  uint64_t v6 = *(void *)(*(void *)(*a2 - 8LL * *(unsigned int *)(*a2 + 8) + 16) + 128LL);
  unsigned int v7 = *(_DWORD *)(v6 + 32);
  if (v7 > 0x40) {
    uint64_t v8 = **(void **)(v6 + 24);
  }
  else {
    uint64_t v8 = (uint64_t)(*(void *)(v6 + 24) << -(char)v7) >> -(char)v7;
  }
  uint64_t v9 = v8 & 0xFFFFFF | (*((_DWORD *)a2 + 4) << 24);
  TracePointLocatiouint64_t n = ShaderDebugger::Metadata::MDSerializerLLVM3XXX::extractTracePointLocation(a1, *a2);
  uint64_t v19 = v9;
  uint64_t v17 = 9LL;
  int v10 = std::__tree<std::__value_type<ShaderDebugger::Metadata::MDBase::MetadataType,ShaderDebugger::Metadata::MDSerializer::MetadataTypeContainer>,std::__map_value_compare<ShaderDebugger::Metadata::MDBase::MetadataType,std::__value_type<ShaderDebugger::Metadata::MDBase::MetadataType,ShaderDebugger::Metadata::MDSerializer::MetadataTypeContainer>,std::less<ShaderDebugger::Metadata::MDBase::MetadataType>,true>,std::allocator<std::__value_type<ShaderDebugger::Metadata::MDBase::MetadataType,ShaderDebugger::Metadata::MDSerializer::MetadataTypeContainer>>>::__emplace_unique_key_args<ShaderDebugger::Metadata::MDBase::MetadataType,std::piecewise_construct_t const&,std::tuple<ShaderDebugger::Metadata::MDBase::MetadataType&&>,std::tuple<>>( a1,  9uLL,  &v17);
  unint64_t v11 = v10;
  uint64_t v13 = (uint64_t)(v10 + 40);
  uint64_t v12 = (char *)*((void *)v10 + 5);
  size_t v14 = (char *)*((void *)v10 + 6);
  unint64_t v15 = v12;
  if (v12 != v14)
  {
    while (*(void *)v15 != v5)
    {
      v15 += 8;
      if (v15 == v14)
      {
        unint64_t v15 = (char *)*((void *)v10 + 6);
        break;
      }
    }
  }

  if (v15 == v14
    || v15 - v12 == -8
    || ShaderDebugger::Metadata::MDSerializer::isMetadataIdReserved((char **)v10 + 5, v5))
  {
    uint64_t v17 = ShaderDebugger::Metadata::MDSerializer::addAndLinearizeMetadataId(v13, v5);
    ShaderDebugger::Metadata::MDSerializer::write<unsigned long long>((unint64_t *)v11 + 11, &v17);
    ShaderDebugger::Metadata::MDSerializer::write<unsigned long long>((unint64_t *)v11 + 11, &v19);
    uint64_t v16 = a3;
    ShaderDebugger::Metadata::MDSerializer::write<unsigned long long>((unint64_t *)v11 + 11, &v16);
    ShaderDebugger::Metadata::MDSerializer::write<unsigned long long>((unint64_t *)v11 + 11, &TracePointLocation);
  }

void ShaderDebugger::Metadata::MDSerializerLLVM3XXX::serializeModules(std::vector<std::unique_ptr<llvm::Module>> const&,std::unordered_map<unsigned int,std::string> const&,unsigned long long *)::$_0::operator()( int **a1, uint64_t a2)
{
  if (!a2) {
    return;
  }
  String = (void *)llvm::MDString::getString(*(llvm::MDString **)(a2 - 8LL * *(unsigned int *)(a2 + 8)));
  if (String)
  {
    std::string::basic_string[abi:nn180100](&__p, String, v5);
  }

  else
  {
    std::string __p = 0LL;
    unint64_t v32 = 0LL;
    uint64_t v33 = 0LL;
  }

  int v6 = **a1;
  uint64_t v7 = *(void *)(a2 - 8LL * *(unsigned int *)(a2 + 8) + 8);
  if (v7 && *(_BYTE *)v7 == 1)
  {
    uint64_t v8 = *(void *)(v7 + 128);
    if (v8 && *(_BYTE *)(v8 + 16) == 3)
    {
      uint64_t v10 = *(void *)(v8 - 32);
      unint64_t v11 = (void *)(v10 + 24);
      if (*(_DWORD *)(v10 + 32) >= 0x41u) {
        unint64_t v11 = (void *)*v11;
      }
      int v6 = *(_DWORD *)v11;
    }
  }

  uint64_t v12 = a1[1];
  char v13 = HIBYTE(v33);
  if (v33 >= 0) {
    p_p = (uint64_t *)&__p;
  }
  else {
    p_p = (uint64_t *)__p;
  }
  if (v33 >= 0) {
    unint64_t v15 = HIBYTE(v33);
  }
  else {
    unint64_t v15 = v32;
  }
  unint64_t v16 = std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:nn180100](p_p, v15);
  int8x8_t v17 = *(int8x8_t *)(v12 + 2);
  if (!*(void *)&v17) {
    goto LABEL_37;
  }
  unint64_t v18 = v16;
  uint8x8_t v19 = (uint8x8_t)vcnt_s8(v17);
  v19.i16[0] = vaddlv_u8(v19);
  unint64_t v20 = v19.u32[0];
  if (v19.u32[0] > 1uLL)
  {
    unint64_t v21 = v16;
    if (v16 >= *(void *)&v17) {
      unint64_t v21 = v16 % *(void *)&v17;
    }
  }

  else
  {
    unint64_t v21 = (*(void *)&v17 - 1LL) & v16;
  }

  uint64_t v22 = *(unsigned __int8 ***)(*(void *)v12 + 8 * v21);
  if (!v22 || (size_t v23 = *v22) == 0LL)
  {
LABEL_37:
    if (v13 < 0) {
      goto LABEL_38;
    }
    return;
  }

  while (1)
  {
    unint64_t v24 = *((void *)v23 + 1);
    if (v18 == v24) {
      break;
    }
    if (v20 > 1)
    {
      if (v24 >= *(void *)&v17) {
        v24 %= *(void *)&v17;
      }
    }

    else
    {
      v24 &= *(void *)&v17 - 1LL;
    }

    if (v24 != v21) {
      goto LABEL_37;
    }
LABEL_36:
    size_t v23 = *(unsigned __int8 **)v23;
    if (!v23) {
      goto LABEL_37;
    }
  }

  uint64_t v25 = a1[2];
  v28[0] = a2;
  v28[1] = v25;
  int v29 = v6;
  int v30 = 0;
  uint64_t v34 = v28;
  uint64_t v26 = *((void *)v23 + 8);
  if (v26)
  {
    (*(void (**)(uint64_t, void **))(*(void *)v26 + 48LL))(v26, &v34);
    if (v33 < 0) {
LABEL_38:
    }
      operator delete(__p);
  }

  else
  {
    uint64_t v27 = std::__throw_bad_function_call[abi:nn180100]();
    std::__destroy_at[abi:nn180100]<std::pair<std::string const,std::function<void ()(ShaderDebugger::Metadata::MDSerializerLLVM3XXX::TracepointContext *)>>,0>(v27);
  }

void std::__destroy_at[abi:nn180100]<std::pair<std::string const,std::function<void ()(ShaderDebugger::Metadata::MDSerializerLLVM3XXX::TracepointContext *)>>,0>( uint64_t a1)
{
  uint64_t v2 = (void *)(a1 + 24);
  uint64_t v3 = *(void **)(a1 + 48);
  if (v3 == v2)
  {
    uint64_t v4 = 4LL;
    uint64_t v3 = v2;
  }

  else
  {
    if (!v3) {
      goto LABEL_6;
    }
    uint64_t v4 = 5LL;
  }

  (*(void (**)(void))(*v3 + 8 * v4))();
LABEL_6:
}

void *std::string::basic_string[abi:nn180100](void *__dst, void *__src, size_t __len)
{
  if (__len >= 0x7FFFFFFFFFFFFFF8LL) {
    abort();
  }
  if (__len >= 0x17)
  {
    size_t v7 = (__len & 0xFFFFFFFFFFFFFFF8LL) + 8;
    if ((__len | 7) != 0x17) {
      size_t v7 = __len | 7;
    }
    size_t v8 = v7 + 1;
    int v6 = operator new(v7 + 1);
    __dst[1] = __len;
    __dst[2] = v8 | 0x8000000000000000LL;
    void *__dst = v6;
  }

  else
  {
    *((_BYTE *)__dst + 23) = __len;
    int v6 = __dst;
    if (!__len) {
      goto LABEL_9;
    }
  }

  memmove(v6, __src, __len);
LABEL_9:
  *((_BYTE *)v6 + __len) = 0;
  return __dst;
}

uint64_t std::__throw_bad_function_call[abi:nn180100]()
{
  return ShaderDebugger::Metadata::MDSerializerLLVM3XXX::extractTracePointLocation();
}

uint64_t ShaderDebugger::Metadata::MDSerializerLLVM3XXX::extractTracePointLocation(uint64_t **a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 - 8LL * *(unsigned int *)(a2 + 8) + 24);
  if (!v2) {
    return -1LL;
  }
  uint64_t v4 = *(void *)(v2 - 8LL * *(unsigned int *)(v2 + 8));
  if (*(_BYTE *)v4 != 15)
  {
    uint64_t v4 = *(void *)(v4 - 8LL * *(unsigned int *)(v4 + 8));
    if (!v4)
    {
      size_t v9 = 0LL;
      size_t v8 = "";
      goto LABEL_10;
    }
  }

  size_t v5 = *(llvm::MDString **)(v4 - 8LL * *(unsigned int *)(v4 + 8));
  if (v5)
  {
    String = (char *)llvm::MDString::getString(v5);
    if (String)
    {
      size_t v8 = String;
      size_t v9 = v7;
LABEL_10:
      std::string::basic_string[abi:nn180100](&__dst, v8, v9);
      goto LABEL_11;
    }
  }

  memset(&__dst, 0, sizeof(__dst));
LABEL_11:
  uint64_t v11 = *(void *)(v2 - 8LL * *(unsigned int *)(v2 + 8));
  if (*(_BYTE *)v11 != 15)
  {
    uint64_t v11 = *(void *)(v11 - 8LL * *(unsigned int *)(v11 + 8));
    if (!v11)
    {
      size_t v16 = 0LL;
      unint64_t v15 = "";
      goto LABEL_18;
    }
  }

  uint64_t v12 = *(llvm::MDString **)(v11 - 8LL * *(unsigned int *)(v11 + 8) + 8);
  if (v12)
  {
    char v13 = (char *)llvm::MDString::getString(v12);
    if (v13)
    {
      unint64_t v15 = v13;
      size_t v16 = v14;
LABEL_18:
      std::string::basic_string[abi:nn180100](&__p, v15, v16);
      goto LABEL_19;
    }
  }

  memset(&__p, 0, sizeof(__p));
LABEL_19:
  uint64_t v10 = ShaderDebugger::Metadata::MDSerializer::serializeLocation( a1,  v2,  &__dst,  &__p,  *(unsigned int *)(v2 + 4),  *(unsigned __int16 *)(v2 + 2));
  return v10;
}

__n128 std::__function::__func<std::__bind<void (ShaderDebugger::Metadata::MDSerializerLLVM3XXX::*)(ShaderDebugger::Metadata::MDSerializerLLVM3XXX::TracepointContext *,ShaderDebugger::Metadata::MDWaypointTracePoint::TracePointWaypointType),ShaderDebugger::Metadata::MDSerializerLLVM3XXX*,std::placeholders::__ph<1> const&,ShaderDebugger::Metadata::MDWaypointTracePoint::TracePointWaypointType>,std::allocator<std::__bind<void (ShaderDebugger::Metadata::MDSerializerLLVM3XXX::*)(ShaderDebugger::Metadata::MDSerializerLLVM3XXX::TracepointContext *,ShaderDebugger::Metadata::MDWaypointTracePoint::TracePointWaypointType),ShaderDebugger::Metadata::MDSerializerLLVM3XXX*,std::placeholders::__ph<1> const&,ShaderDebugger::Metadata::MDWaypointTracePoint::TracePointWaypointType>>,void ()(ShaderDebugger::Metadata::MDSerializerLLVM3XXX::TracepointContext *)>::__clone( uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = &off_58E9D0;
  *(_OWORD *)(v2 + _Block_object_dispose(va, 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

__n128 std::__function::__func<std::__bind<void (ShaderDebugger::Metadata::MDSerializerLLVM3XXX::*)(ShaderDebugger::Metadata::MDSerializerLLVM3XXX::TracepointContext *,ShaderDebugger::Metadata::MDWaypointTracePoint::TracePointWaypointType),ShaderDebugger::Metadata::MDSerializerLLVM3XXX*,std::placeholders::__ph<1> const&,ShaderDebugger::Metadata::MDWaypointTracePoint::TracePointWaypointType>,std::allocator<std::__bind<void (ShaderDebugger::Metadata::MDSerializerLLVM3XXX::*)(ShaderDebugger::Metadata::MDSerializerLLVM3XXX::TracepointContext *,ShaderDebugger::Metadata::MDWaypointTracePoint::TracePointWaypointType),ShaderDebugger::Metadata::MDSerializerLLVM3XXX*,std::placeholders::__ph<1> const&,ShaderDebugger::Metadata::MDWaypointTracePoint::TracePointWaypointType>>,void ()(ShaderDebugger::Metadata::MDSerializerLLVM3XXX::TracepointContext *)>::__clone( uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &off_58E9D0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + _Block_object_dispose(va, 8) = result;
  return result;
}

uint64_t std::__function::__func<std::__bind<void (ShaderDebugger::Metadata::MDSerializerLLVM3XXX::*)(ShaderDebugger::Metadata::MDSerializerLLVM3XXX::TracepointContext *,ShaderDebugger::Metadata::MDWaypointTracePoint::TracePointWaypointType),ShaderDebugger::Metadata::MDSerializerLLVM3XXX*,std::placeholders::__ph<1> const&,ShaderDebugger::Metadata::MDWaypointTracePoint::TracePointWaypointType>,std::allocator<std::__bind<void (ShaderDebugger::Metadata::MDSerializerLLVM3XXX::*)(ShaderDebugger::Metadata::MDSerializerLLVM3XXX::TracepointContext *,ShaderDebugger::Metadata::MDWaypointTracePoint::TracePointWaypointType),ShaderDebugger::Metadata::MDSerializerLLVM3XXX*,std::placeholders::__ph<1> const&,ShaderDebugger::Metadata::MDWaypointTracePoint::TracePointWaypointType>>,void ()(ShaderDebugger::Metadata::MDSerializerLLVM3XXX::TracepointContext *)>::operator()( void *a1, void *a2)
{
  uint64_t v2 = a1[2];
  uint64_t v3 = (uint64_t (*)(void *, void, void))a1[1];
  uint64_t v4 = (void *)(a1[3] + (v2 >> 1));
  if ((v2 & 1) != 0) {
    uint64_t v3 = *(uint64_t (**)(void *, void, void))(*v4 + v3);
  }
  return v3(v4, *a2, a1[4]);
}

uint64_t ShaderDebugger::Metadata::MDSerializerLLVM3XXX::serializeType( uint64_t **a1, unint64_t a2, void **a3)
{
  size_t v5 = a1;
  size_t v7 = a3 + 1;
  int v6 = a3[1];
  if (v6)
  {
    size_t v8 = a3 + 1;
    size_t v9 = a3[1];
    do
    {
      unint64_t v10 = v9[4];
      BOOL v11 = v10 >= a2;
      if (v10 >= a2) {
        uint64_t v12 = v9;
      }
      else {
        uint64_t v12 = v9 + 1;
      }
      if (v11) {
        size_t v8 = (void **)v9;
      }
      size_t v9 = (void *)*v12;
    }

    while (*v12);
    if (v8 != v7 && (unint64_t)v8[4] <= a2)
    {
      std::string __dst = (void **)(&dword_0 + 3);
      unint64_t v24 = std::__tree<std::__value_type<ShaderDebugger::Metadata::MDBase::MetadataType,ShaderDebugger::Metadata::MDSerializer::MetadataTypeContainer>,std::__map_value_compare<ShaderDebugger::Metadata::MDBase::MetadataType,std::__value_type<ShaderDebugger::Metadata::MDBase::MetadataType,ShaderDebugger::Metadata::MDSerializer::MetadataTypeContainer>,std::less<ShaderDebugger::Metadata::MDBase::MetadataType>,true>,std::allocator<std::__value_type<ShaderDebugger::Metadata::MDBase::MetadataType,ShaderDebugger::Metadata::MDSerializer::MetadataTypeContainer>>>::__emplace_unique_key_args<ShaderDebugger::Metadata::MDBase::MetadataType,std::piecewise_construct_t const&,std::tuple<ShaderDebugger::Metadata::MDBase::MetadataType&&>,std::tuple<>>( a1,  3uLL,  &__dst);
      uint64_t v25 = (void *)*((void *)v24 + 5);
      uint64_t v26 = (void *)*((void *)v24 + 6);
      uint64_t v27 = v25;
      if (v25 != v26)
      {
        while (*v27 != a2)
        {
          if (++v27 == v26)
          {
            uint64_t v27 = (void *)*((void *)v24 + 6);
            break;
          }
        }
      }

      uint64_t v28 = v27 - v25;
      if (v27 == v26) {
        return -1LL;
      }
      else {
        return v28;
      }
    }

    while (1)
    {
      while (1)
      {
        char v13 = (uint64_t **)v6;
        unint64_t v14 = v6[4];
        if (v14 <= a2) {
          break;
        }
        int v6 = *v13;
        unint64_t v15 = v13;
        if (!*v13) {
          goto LABEL_19;
        }
      }

      if (v14 >= a2) {
        break;
      }
      int v6 = v13[1];
      if (!v6)
      {
        unint64_t v15 = v13 + 1;
        goto LABEL_19;
      }
    }
  }

  else
  {
    unint64_t v15 = a3 + 1;
    char v13 = a3 + 1;
LABEL_19:
    size_t v16 = (uint64_t *)operator new(0x28uLL);
    v16[4] = a2;
    std::__tree<llvm::DIType *>::__insert_node_at(a3, (uint64_t)v13, v15, v16);
  }

  std::string __dst = (void **)(&dword_0 + 3);
  int8x8_t v17 = std::__tree<std::__value_type<ShaderDebugger::Metadata::MDBase::MetadataType,ShaderDebugger::Metadata::MDSerializer::MetadataTypeContainer>,std::__map_value_compare<ShaderDebugger::Metadata::MDBase::MetadataType,std::__value_type<ShaderDebugger::Metadata::MDBase::MetadataType,ShaderDebugger::Metadata::MDSerializer::MetadataTypeContainer>,std::less<ShaderDebugger::Metadata::MDBase::MetadataType>,true>,std::allocator<std::__value_type<ShaderDebugger::Metadata::MDBase::MetadataType,ShaderDebugger::Metadata::MDSerializer::MetadataTypeContainer>>>::__emplace_unique_key_args<ShaderDebugger::Metadata::MDBase::MetadataType,std::piecewise_construct_t const&,std::tuple<ShaderDebugger::Metadata::MDBase::MetadataType&&>,std::tuple<>>( v5,  3uLL,  &__dst);
  unint64_t v18 = (char *)*((void *)v17 + 5);
  uint8x8_t v19 = (char *)*((void *)v17 + 6);
  unint64_t v20 = v18;
  if (v18 != v19)
  {
    unint64_t v20 = (char *)*((void *)v17 + 5);
    while (*(void *)v20 != a2)
    {
      v20 += 8;
      if (v20 == v19)
      {
        unint64_t v20 = (char *)*((void *)v17 + 6);
        break;
      }
    }
  }

  if (v20 == v19) {
    uint64_t v21 = -1LL;
  }
  else {
    uint64_t v21 = (v20 - v18) >> 3;
  }
  if (v21 == -1)
  {
    unint64_t v22 = *((void *)v17 + 7);
    if ((unint64_t)v19 >= v22)
    {
      uint64_t v29 = (v19 - v18) >> 3;
      unint64_t v30 = v29 + 1;
      if ((unint64_t)(v29 + 1) >> 61) {
LABEL_248:
      }
        abort();
      uint64_t v31 = v22 - (void)v18;
      if (v31 >> 2 > v30) {
        unint64_t v30 = v31 >> 2;
      }
      BOOL v11 = (unint64_t)v31 >= 0x7FFFFFFFFFFFFFF8LL;
      unint64_t v32 = 0x1FFFFFFFFFFFFFFFLL;
      if (!v11) {
        unint64_t v32 = v30;
      }
      if (v32)
      {
        unint64_t v32 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<std::pair<unsigned int,unsigned int>>>(v32);
        unint64_t v18 = (char *)*((void *)v17 + 5);
        uint8x8_t v19 = (char *)*((void *)v17 + 6);
      }

      else
      {
        uint64_t v33 = 0LL;
      }

      uint64_t v34 = (unint64_t *)(v32 + 8 * v29);
      unint64_t v35 = v32 + 8 * v33;
      *uint64_t v34 = a2;
      size_t v23 = v34 + 1;
      while (v19 != v18)
      {
        unint64_t v36 = *((void *)v19 - 1);
        v19 -= 8;
        *--uint64_t v34 = v36;
      }

      *((void *)v17 + 5) = v34;
      *((void *)v17 + 6) = v23;
      *((void *)v17 + 7) = v35;
      if (v18) {
        operator delete(v18);
      }
    }

    else
    {
      *(void *)uint8x8_t v19 = a2;
      size_t v23 = v19 + 8;
    }

    *((void *)v17 + 6) = v23;
    LOBYTE(v192) = 1;
    std::vector<BOOL>::push_back((uint64_t *)v17 + 8, &v192);
    uint64_t v21 = ((uint64_t)(*((void *)v17 + 6) - *((void *)v17 + 5)) >> 3) - 1;
  }

  uint64_t v181 = v5;
  switch(*(_BYTE *)a2)
  {
    case 0xB:
      uint64_t v37 = *(llvm::MDString **)(a2 - 8LL * *(unsigned int *)(a2 + 8) + 16);
      if (v37 && (String = (void *)llvm::MDString::getString(v37)) != 0LL)
      {
        uint64_t v40 = v21;
        std::string::basic_string[abi:nn180100](&__dst, String, v39);
      }

      else
      {
        uint64_t v40 = v21;
        std::string __dst = 0LL;
        id v196 = 0LL;
        uint64_t v197 = 0LL;
      }

      uint64_t v76 = *(unsigned int *)(a2 + 28);
      uint64_t v77 = *(unsigned int *)(a2 + 48);
      uint64_t v79 = *(void *)(a2 + 32);
      uint64_t v78 = *(void *)(a2 + 40);
      unsigned int Tag = llvm::DINode::getTag((llvm::DINode *)a2);
      LODWORD(__p[0]) = *(_DWORD *)(a2 + 52);
      unint64_t v192 = (void **)(&dword_0 + 3);
      uint64_t v81 = std::__tree<std::__value_type<ShaderDebugger::Metadata::MDBase::MetadataType,ShaderDebugger::Metadata::MDSerializer::MetadataTypeContainer>,std::__map_value_compare<ShaderDebugger::Metadata::MDBase::MetadataType,std::__value_type<ShaderDebugger::Metadata::MDBase::MetadataType,ShaderDebugger::Metadata::MDSerializer::MetadataTypeContainer>,std::less<ShaderDebugger::Metadata::MDBase::MetadataType>,true>,std::allocator<std::__value_type<ShaderDebugger::Metadata::MDBase::MetadataType,ShaderDebugger::Metadata::MDSerializer::MetadataTypeContainer>>>::__emplace_unique_key_args<ShaderDebugger::Metadata::MDBase::MetadataType,std::piecewise_construct_t const&,std::tuple<ShaderDebugger::Metadata::MDBase::MetadataType&&>,std::tuple<>>( v181,  3uLL,  &v192);
      uint64_t v82 = v81;
      uint64_t v84 = (uint64_t)(v81 + 40);
      uint64_t v83 = (char *)*((void *)v81 + 5);
      uint64_t v85 = (char *)*((void *)v81 + 6);
      uint64_t v86 = v83;
      if (v83 == v85) {
        goto LABEL_108;
      }
      while (*(void *)v86 != a2)
      {
        v86 += 8;
        if (v86 == v85)
        {
          uint64_t v86 = (char *)*((void *)v81 + 6);
          break;
        }
      }

LABEL_224:
          if (++v126 == (llvm::DISubrange **)v125)
          {
            uint64_t v47 = -(uint64_t)*(unsigned int *)(a2 + 8);
            goto LABEL_227;
          }
        }

        uint64_t v193 = 0LL;
        uint64_t v194 = 0LL;
        unint64_t v192 = &v193;
        std::set<llvm::DIType *>::insert[abi:nn180100]<std::__tree_const_iterator<llvm::DIType *,std::__tree_node<llvm::DIType *,void *> *,long>>( (uint64_t *)&v192,  v186,  v187);
        uint64_t v132 = ShaderDebugger::Metadata::MDSerializerLLVM3XXX::serializeType(v5, v130, &v192);
        std::__tree<llvm::DIType *>::destroy(v193);
        if ((unint64_t)v128 < v129)
        {
          *(void *)uint64_t v128 = 3LL;
          *((void *)v128 + 1) = v132;
          v128 += 16;
LABEL_223:
          uint64_t v125 = v183;
          goto LABEL_224;
        }

        uint64_t v137 = (v128 - v127) >> 4;
        unint64_t v138 = v137 + 1;
        else {
          unint64_t v139 = v138;
        }
        if (v139) {
          unint64_t v139 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<std::pair<unsigned long long,unsigned long long>>>(v139);
        }
        else {
          uint64_t v140 = 0LL;
        }
        uint64_t v141 = (void *)(v139 + 16 * v137);
        *uint64_t v141 = 3LL;
        v141[1] = v132;
        if (v128 == v127)
        {
          unint64_t v143 = (char *)(v139 + 16 * v137);
        }

        else
        {
          unint64_t v142 = v139 + 16 * v137;
          do
          {
            unint64_t v143 = (char *)(v142 - 16);
            *(_OWORD *)(v142 - 16) = *((_OWORD *)v128 - 1);
            v128 -= 16;
            v142 -= 16LL;
          }

          while (v128 != v127);
        }
}

LABEL_220:
        unint64_t v129 = v139 + 16 * v140;
        uint64_t v128 = (char *)(v141 + 2);
        if (v127) {
          operator delete(v127);
        }
        uint64_t v127 = v143;
        goto LABEL_223;
      }

      uint64_t v127 = 0LL;
      uint64_t v128 = 0LL;
LABEL_227:
      id v160 = *(llvm::MDString **)(a2 + 8 * v47 + 16);
      if (v160 && (__int128 v161 = (void *)llvm::MDString::getString(v160)) != 0LL)
      {
        std::string::basic_string[abi:nn180100](__p, v161, v162);
      }

      else
      {
        __p[0] = 0LL;
        __p[1] = 0LL;
        uint64_t v191 = 0LL;
      }

      uint64_t v163 = *(unsigned int *)(a2 + 28);
      uint64_t v164 = *(unsigned int *)(a2 + 48);
      uint64_t v166 = *(void *)(a2 + 32);
      uint64_t v165 = *(void *)(a2 + 40);
      unsigned int v167 = llvm::DINode::getTag((llvm::DINode *)a2);
      uint64_t v198 = 3LL;
      v199[0] = v177;
      uint64_t v168 = std::__tree<std::__value_type<ShaderDebugger::Metadata::MDBase::MetadataType,ShaderDebugger::Metadata::MDSerializer::MetadataTypeContainer>,std::__map_value_compare<ShaderDebugger::Metadata::MDBase::MetadataType,std::__value_type<ShaderDebugger::Metadata::MDBase::MetadataType,ShaderDebugger::Metadata::MDSerializer::MetadataTypeContainer>,std::less<ShaderDebugger::Metadata::MDBase::MetadataType>,true>,std::allocator<std::__value_type<ShaderDebugger::Metadata::MDBase::MetadataType,ShaderDebugger::Metadata::MDSerializer::MetadataTypeContainer>>>::__emplace_unique_key_args<ShaderDebugger::Metadata::MDBase::MetadataType,std::piecewise_construct_t const&,std::tuple<ShaderDebugger::Metadata::MDBase::MetadataType&&>,std::tuple<>>( v181,  3uLL,  &v198);
      __int128 v169 = v168;
      uint64_t v171 = (uint64_t)(v168 + 40);
      int v170 = (char *)*((void *)v168 + 5);
      id v172 = (char *)*((void *)v168 + 6);
      id v173 = v170;
      if (v170 != v172)
      {
        while (*(void *)v173 != a2)
        {
          v173 += 8;
          if (v173 == v172)
          {
            id v173 = (char *)*((void *)v168 + 6);
            break;
          }
        }
      }

      if (v173 == v172
        || v173 - v170 == -8
        || ShaderDebugger::Metadata::MDSerializer::isMetadataIdReserved((char **)v168 + 5, a2))
      {
        uint64_t v174 = ShaderDebugger::Metadata::MDSerializer::addAndLinearizeMetadataId(v171, a2);
        ShaderDebugger::Metadata::MDSerializer::serializeTypeBase( (unint64_t *)v169 + 11,  v174,  (uint64_t)__p,  v163,  v166,  v164,  v165,  v167,  1LL);
        ShaderDebugger::Metadata::MDSerializer::write<unsigned long long>((unint64_t *)v169 + 11, v199);
        uint64_t v198 = (v128 - v127) >> 4;
        ShaderDebugger::Metadata::MDSerializer::write<unsigned long long>((unint64_t *)v169 + 11, &v198);
        if (v128 != v127)
        {
          unint64_t v175 = (uint64_t *)v127;
          do
          {
            uint64_t v198 = *v175;
            ShaderDebugger::Metadata::MDSerializer::write<unsigned long long>((unint64_t *)v169 + 11, &v198);
            uint64_t v198 = v175[1];
            ShaderDebugger::Metadata::MDSerializer::write<unsigned long long>((unint64_t *)v169 + 11, &v198);
            v175 += 2;
          }

          while (v175 != (uint64_t *)v128);
        }
      }

      if (SHIBYTE(v191) < 0) {
        operator delete(__p[0]);
      }
      uint64_t v21 = v180;
      if (v127) {
        operator delete(v127);
      }
      uint64_t v105 = (void *)v187[0];
LABEL_246:
      std::__tree<llvm::DIType *>::destroy(v105);
      break;
    case 0xE:
      uint64_t v179 = v21;
      size_t v48 = v185;
      v185[0] = 0LL;
      v185[1] = 0LL;
      unint64_t v184 = v185;
      std::set<llvm::DIType *>::insert[abi:nn180100]<std::__tree_const_iterator<llvm::DIType *,std::__tree_node<llvm::DIType *,void *> *,long>>( (uint64_t *)&v184,  *a3,  v7);
      uint64_t v49 = *(unsigned int *)(a2 + 8);
      uint64_t v50 = -v49;
      uint64_t v51 = *(void *)(a2 - 8 * v49 + 24);
      if (v51 && (uint64_t v52 = *(unsigned int *)(v51 + 8), (int)v52 >= 1))
      {
        std::string::size_type v53 = 0LL;
        unint64_t v54 = 0LL;
        uint64_t v55 = 0LL;
        uint64_t v56 = 0LL;
        std::string::size_type v57 = &v196;
        uint64_t v178 = *(void *)(a2 - 8 * v49 + 24);
        do
        {
          uint64_t v58 = *(void *)(v51 - 8LL * *(unsigned int *)(v51 + 8) + 8 * v56);
          if (v56 || v58)
          {
            *std::string::size_type v57 = 0LL;
            v57[1] = 0LL;
            std::string __dst = v57;
            std::set<llvm::DIType *>::insert[abi:nn180100]<std::__tree_const_iterator<llvm::DIType *,std::__tree_node<llvm::DIType *,void *> *,long>>( (uint64_t *)&__dst,  v184,  v48);
            uint64_t v59 = ShaderDebugger::Metadata::MDSerializerLLVM3XXX::serializeType(v181, v58, &__dst);
            std::__tree<llvm::DIType *>::destroy(v196);
            if ((unint64_t)v53 >= v54)
            {
              id v64 = v57;
              uint64_t v65 = v52;
              uint64_t v66 = v48;
              uint64_t v67 = (v53 - v55) >> 4;
              unint64_t v68 = v67 + 1;
              else {
                unint64_t v69 = v68;
              }
              if (v69) {
                unint64_t v69 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<std::pair<unsigned long long,unsigned long long>>>(v69);
              }
              else {
                uint64_t v70 = 0LL;
              }
              uint64_t v73 = (void *)(v69 + 16 * v67);
              void *v73 = 3LL;
              v73[1] = v59;
              if (v53 == v55)
              {
                uint64_t v75 = v53;
                uint64_t v55 = (char *)(v69 + 16 * v67);
                size_t v48 = v66;
              }

              else
              {
                uint64_t v74 = (char *)(v69 + 16 * v67);
                size_t v48 = v66;
                do
                {
                  *((_OWORD *)v74 - 1) = *((_OWORD *)v53 - 1);
                  v74 -= 16;
                  v53 -= 16;
                }

                while (v53 != v55);
                uint64_t v75 = v55;
                uint64_t v55 = v74;
              }

              uint64_t v52 = v65;
              unint64_t v54 = v69 + 16 * v70;
              std::string::size_type v53 = (char *)(v73 + 2);
              std::string::size_type v57 = v64;
              if (v75) {
                operator delete(v75);
              }
              uint64_t v51 = v178;
            }

            else
            {
              *(void *)std::string::size_type v53 = 3LL;
              *((void *)v53 + 1) = v59;
              v53 += 16;
            }
          }

          else if ((unint64_t)v53 >= v54)
          {
            uint64_t v60 = (v53 - v55) >> 4;
            unint64_t v61 = v60 + 1;
            else {
              unint64_t v62 = v61;
            }
            if (v62) {
              unint64_t v62 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<std::pair<unsigned long long,unsigned long long>>>(v62);
            }
            else {
              uint64_t v63 = 0LL;
            }
            id v71 = (char *)(v62 + 16 * v60);
            *(_OWORD *)id v71 = xmmword_3183E0;
            uint64_t v72 = v71 + 16;
            if (v53 != v55)
            {
              do
              {
                *((_OWORD *)v71 - 1) = *((_OWORD *)v53 - 1);
                v71 -= 16;
                v53 -= 16;
              }

              while (v53 != v55);
              std::string::size_type v53 = v55;
            }

            uint64_t v55 = v71;
            unint64_t v54 = v62 + 16 * v63;
            if (v53) {
              operator delete(v53);
            }
            std::string::size_type v53 = v72;
          }

          else
          {
            *(_OWORD *)std::string::size_type v53 = xmmword_3183E0;
            v53 += 16;
          }

          ++v56;
        }

        while (v56 != v52);
        uint64_t v50 = -(uint64_t)*(unsigned int *)(a2 + 8);
      }

      else
      {
        std::string::size_type v53 = 0LL;
        uint64_t v55 = 0LL;
      }

      uint64_t v88 = *(llvm::MDString **)(a2 + 8 * v50 + 16);
      if (v88 && (unint64_t v89 = (void *)llvm::MDString::getString(v88)) != 0LL)
      {
        std::string::basic_string[abi:nn180100](&v192, v89, v90);
      }

      else
      {
        unint64_t v192 = 0LL;
        uint64_t v193 = 0LL;
        uint64_t v194 = 0LL;
      }

      uint64_t v91 = *(unsigned int *)(a2 + 28);
      uint64_t v92 = *(unsigned int *)(a2 + 48);
      uint64_t v94 = *(void *)(a2 + 32);
      uint64_t v93 = *(void *)(a2 + 40);
      unsigned int v95 = llvm::DINode::getTag((llvm::DINode *)a2);
      __p[0] = &dword_0 + 3;
      unint64_t v96 = std::__tree<std::__value_type<ShaderDebugger::Metadata::MDBase::MetadataType,ShaderDebugger::Metadata::MDSerializer::MetadataTypeContainer>,std::__map_value_compare<ShaderDebugger::Metadata::MDBase::MetadataType,std::__value_type<ShaderDebugger::Metadata::MDBase::MetadataType,ShaderDebugger::Metadata::MDSerializer::MetadataTypeContainer>,std::less<ShaderDebugger::Metadata::MDBase::MetadataType>,true>,std::allocator<std::__value_type<ShaderDebugger::Metadata::MDBase::MetadataType,ShaderDebugger::Metadata::MDSerializer::MetadataTypeContainer>>>::__emplace_unique_key_args<ShaderDebugger::Metadata::MDBase::MetadataType,std::piecewise_construct_t const&,std::tuple<ShaderDebugger::Metadata::MDBase::MetadataType&&>,std::tuple<>>( v181,  3uLL,  __p);
      unint64_t v97 = v96;
      uint64_t v99 = (uint64_t)(v96 + 40);
      id v98 = (char *)*((void *)v96 + 5);
      uint64_t v100 = (char *)*((void *)v96 + 6);
      id v101 = v98;
      if (v98 != v100)
      {
        while (*(void *)v101 != a2)
        {
          v101 += 8;
          if (v101 == v100)
          {
            id v101 = (char *)*((void *)v96 + 6);
            break;
          }
        }
      }

      if (v101 == v100
        || v101 - v98 == -8
        || ShaderDebugger::Metadata::MDSerializer::isMetadataIdReserved((char **)v96 + 5, a2))
      {
        uint64_t v102 = ShaderDebugger::Metadata::MDSerializer::addAndLinearizeMetadataId(v99, a2);
        id v103 = (unint64_t *)(v97 + 88);
        ShaderDebugger::Metadata::MDSerializer::serializeTypeBase( (unint64_t *)v97 + 11,  v102,  (uint64_t)&v192,  v91,  v94,  v92,  v93,  v95,  3LL);
        __p[0] = (void *)((v53 - v55) >> 4);
        ShaderDebugger::Metadata::MDSerializer::write<unsigned long long>((unint64_t *)v97 + 11, __p);
        if (v53 != v55)
        {
          uint64_t v104 = (void **)v55;
          do
          {
            __p[0] = *v104;
            ShaderDebugger::Metadata::MDSerializer::write<unsigned long long>(v103, __p);
            __p[0] = v104[1];
            ShaderDebugger::Metadata::MDSerializer::write<unsigned long long>(v103, __p);
            v104 += 2;
          }

          while (v104 != (void **)v53);
        }
      }

      if (SHIBYTE(v194) < 0) {
        operator delete(v192);
      }
      uint64_t v21 = v179;
      if (v55) {
        operator delete(v55);
      }
      uint64_t v105 = (void *)v185[0];
      goto LABEL_246;
    default:
      return v21;
  }

  return v21;
}

void std::__tree<llvm::DIType *>::destroy(void *a1)
{
  if (a1)
  {
    std::__tree<llvm::DIType *>::destroy(*a1);
    std::__tree<llvm::DIType *>::destroy(a1[1]);
    operator delete(a1);
  }

llvm::MDString *llvm::DIVariable::getFilename(llvm::DIVariable *this)
{
  uint64_t v1 = ((void *)this - *((unsigned int *)this + 2))[2];
  if (!v1) {
    return (llvm::MDString *)"";
  }
  __n128 result = *(llvm::MDString **)(v1 - 8LL * *(unsigned int *)(v1 + 8));
  if (result) {
    return (llvm::MDString *)llvm::MDString::getString(result);
  }
  return result;
}

llvm::MDString *llvm::DIVariable::getDirectory(llvm::DIVariable *this)
{
  uint64_t v1 = ((void *)this - *((unsigned int *)this + 2))[2];
  if (!v1) {
    return (llvm::MDString *)"";
  }
  __n128 result = *(llvm::MDString **)(v1 - 8LL * *(unsigned int *)(v1 + 8) + 8);
  if (result) {
    return (llvm::MDString *)llvm::MDString::getString(result);
  }
  return result;
}

char *std::__tree<std::__value_type<ShaderDebugger::Metadata::MDBase::MetadataType,ShaderDebugger::Metadata::MDSerializer::MetadataTypeContainer>,std::__map_value_compare<ShaderDebugger::Metadata::MDBase::MetadataType,std::__value_type<ShaderDebugger::Metadata::MDBase::MetadataType,ShaderDebugger::Metadata::MDSerializer::MetadataTypeContainer>,std::less<ShaderDebugger::Metadata::MDBase::MetadataType>,true>,std::allocator<std::__value_type<ShaderDebugger::Metadata::MDBase::MetadataType,ShaderDebugger::Metadata::MDSerializer::MetadataTypeContainer>>>::__emplace_unique_key_args<ShaderDebugger::Metadata::MDBase::MetadataType,std::piecewise_construct_t const&,std::tuple<ShaderDebugger::Metadata::MDBase::MetadataType&&>,std::tuple<>>( uint64_t **a1, unint64_t a2, void *a3)
{
  int v6 = a1 + 1;
  size_t v5 = (char *)a1[1];
  if (v5)
  {
    while (1)
    {
      while (1)
      {
        size_t v7 = v5;
        unint64_t v8 = *((void *)v5 + 4);
        if (v8 <= a2) {
          break;
        }
        size_t v5 = *(char **)v7;
        int v6 = (uint64_t **)v7;
        if (!*(void *)v7) {
          goto LABEL_9;
        }
      }

      if (v8 >= a2) {
        break;
      }
      size_t v5 = (char *)*((void *)v7 + 1);
      if (!v5)
      {
        int v6 = (uint64_t **)(v7 + 8);
        goto LABEL_9;
      }
    }
  }

  else
  {
    size_t v7 = (char *)(a1 + 1);
LABEL_9:
    size_t v9 = v7;
    size_t v7 = (char *)operator new(0x70uLL);
    *((void *)v7 + 4) = *a3;
    *(_OWORD *)(v7 + 40) = 0u;
    *(_OWORD *)(v7 + 56) = 0u;
    *(_OWORD *)(v7 + 72) = 0u;
    *(_OWORD *)(v7 + 8_Block_object_dispose(va, 8) = 0u;
    *((void *)v7 + 13) = 0LL;
    *(void *)size_t v7 = 0LL;
    *((void *)v7 + 1) = 0LL;
    *((void *)v7 + 2) = v9;
    *int v6 = (uint64_t *)v7;
    unint64_t v10 = (uint64_t *)**a1;
    BOOL v11 = (uint64_t *)v7;
    if (v10)
    {
      *a1 = v10;
      BOOL v11 = *v6;
    }

    std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(a1[1], v11);
    a1[2] = (uint64_t *)((char *)a1[2] + 1);
  }

  return v7;
}

uint64_t *std::set<llvm::DIType *>::insert[abi:nn180100]<std::__tree_const_iterator<llvm::DIType *,std::__tree_node<llvm::DIType *,void *> *,long>>( uint64_t *result, void *a2, void *a3)
{
  if (a2 != a3)
  {
    uint64_t v4 = a2;
    size_t v5 = result;
    int v6 = result + 1;
    do
    {
      size_t v7 = (uint64_t *)v5[1];
      unint64_t v8 = v6;
      size_t v9 = (uint64_t *)v5[1];
      unint64_t v10 = v6;
      if (v7)
      {
        do
        {
          unint64_t v8 = v9;
          size_t v9 = (uint64_t *)v9[1];
        }

        while (v9);
      }

      else
      {
        do
        {
          unint64_t v8 = (uint64_t *)v10[2];
          BOOL v11 = *v8 == (void)v10;
          unint64_t v10 = v8;
        }

        while (v11);
      }

      unint64_t v12 = v4[4];
      if (v8[4] < v12)
      {
LABEL_9:
        if (v7) {
          char v13 = (uint64_t **)v8;
        }
        else {
          char v13 = (uint64_t **)v6;
        }
        if (v7) {
          unint64_t v14 = (uint64_t **)(v8 + 1);
        }
        else {
          unint64_t v14 = (uint64_t **)v6;
        }
      }

      else
      {
        char v13 = (uint64_t **)v6;
        unint64_t v14 = (uint64_t **)v6;
        if (v7)
        {
          unint64_t v14 = (uint64_t **)v6;
          while (1)
          {
            while (1)
            {
              char v13 = (uint64_t **)v7;
              unint64_t v18 = v7[4];
              if (v12 >= v18) {
                break;
              }
              size_t v7 = *v13;
              unint64_t v14 = v13;
              if (!*v13) {
                goto LABEL_16;
              }
            }

            if (v18 >= v12) {
              break;
            }
            unint64_t v14 = v13 + 1;
            size_t v7 = v13[1];
            if (!v7) {
              goto LABEL_16;
            }
          }
        }
      }

      if (!*v14)
      {
LABEL_16:
        unint64_t v15 = (uint64_t *)operator new(0x28uLL);
        v15[4] = v4[4];
        __n128 result = std::__tree<llvm::DIType *>::__insert_node_at((uint64_t **)v5, (uint64_t)v13, v14, v15);
      }

      size_t v16 = (void *)v4[1];
      if (v16)
      {
        do
        {
          int8x8_t v17 = v16;
          size_t v16 = (void *)*v16;
        }

        while (v16);
      }

      else
      {
        do
        {
          int8x8_t v17 = (void *)v4[2];
          BOOL v11 = *v17 == (void)v4;
          uint64_t v4 = v17;
        }

        while (!v11);
      }

      uint64_t v4 = v17;
    }

    while (v17 != a3);
  }

  return result;
}

uint64_t *std::__tree<llvm::DIType *>::__insert_node_at(uint64_t **a1, uint64_t a2, uint64_t **a3, uint64_t *a4)
{
  *a4 = 0LL;
  a4[1] = 0LL;
  a4[2] = a2;
  *a3 = a4;
  size_t v5 = (uint64_t *)**a1;
  if (v5)
  {
    *a1 = v5;
    a4 = *a3;
  }

  __n128 result = std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(a1[1], a4);
  a1[2] = (uint64_t *)((char *)a1[2] + 1);
  return result;
}

void std::__destroy_at[abi:nn180100]<std::pair<ShaderDebugger::Metadata::MDBase::MetadataType const,ShaderDebugger::Metadata::MDSerializer::MetadataTypeContainer>,0>( void *a1)
{
  uint64_t v2 = (void *)a1[7];
  if (v2)
  {
    a1[8] = v2;
    operator delete(v2);
  }

  uint64_t v3 = (void *)a1[4];
  if (v3) {
    operator delete(v3);
  }
  uint64_t v4 = (void *)a1[1];
  if (v4)
  {
    a1[2] = v4;
    operator delete(v4);
  }

uint64_t ShaderDebugger::Metadata::MDSerializerLLVM3XXX::serializeSubprogram(uint64_t **a1, uint64_t a2)
{
  uint64_t v4 = a2 + 1;
  uint64_t v5 = a2;
  if (*(_BYTE *)a2 != 15)
  {
    uint64_t v5 = *(void *)(a2 - 8LL * *(unsigned int *)(a2 + 8));
    if (!v5)
    {
      size_t v10 = 0LL;
      size_t v9 = "";
      goto LABEL_8;
    }
  }

  int v6 = *(llvm::MDString **)(v5 - 8LL * *(unsigned int *)(v5 + 8));
  if (v6)
  {
    String = (char *)llvm::MDString::getString(v6);
    if (String)
    {
      size_t v9 = String;
      size_t v10 = v8;
LABEL_8:
      std::string::basic_string[abi:nn180100](&__dst, v9, v10);
      goto LABEL_9;
    }
  }

  memset(&__dst, 0, sizeof(__dst));
LABEL_9:
  uint64_t v11 = a2;
  if (*(_BYTE *)a2 == 15 || (uint64_t v11 = *(void *)(a2 - 8LL * *(unsigned int *)(a2 + 8))) != 0)
  {
    unint64_t v12 = *(llvm::MDString **)(v11 - 8LL * *(unsigned int *)(v11 + 8) + 8);
    if (!v12 || (char v13 = (char *)llvm::MDString::getString(v12)) == 0LL)
    {
      memset(&__p, 0, sizeof(__p));
      goto LABEL_17;
    }

    unint64_t v15 = v13;
    size_t v16 = v14;
  }

  else
  {
    size_t v16 = 0LL;
    unint64_t v15 = "";
  }

  std::string::basic_string[abi:nn180100](&__p, v15, v16);
LABEL_17:
  uint64_t v17 = ShaderDebugger::Metadata::MDSerializer::serializeLocation( a1,  v4,  &__dst,  &__p,  *(unsigned int *)(a2 + 24),  -1LL);
  unint64_t v18 = *(llvm::MDString **)(a2 - 8LL * *(unsigned int *)(a2 + 8) + 16);
  else {
    memset(&__dst, 0, sizeof(__dst));
  }
  uint64_t v21 = ShaderDebugger::Metadata::MDSerializer::serializeSubprogram(a1, a2, (uint64_t)&__dst, v17);
  return v21;
}

__n128 std::__function::__func<std::__bind<void (ShaderDebugger::Metadata::MDSerializerLLVM3XXX::*)(ShaderDebugger::Metadata::MDSerializerLLVM3XXX::TracepointContext *),ShaderDebugger::Metadata::MDSerializerLLVM3XXX*,std::placeholders::__ph<1> const&>,std::allocator<std::__bind<void (ShaderDebugger::Metadata::MDSerializerLLVM3XXX::*)(ShaderDebugger::Metadata::MDSerializerLLVM3XXX::TracepointContext *),ShaderDebugger::Metadata::MDSerializerLLVM3XXX*,std::placeholders::__ph<1> const&>>,void ()(ShaderDebugger::Metadata::MDSerializerLLVM3XXX::TracepointContext *)>::__clone( uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = off_58E988;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + _Block_object_dispose(va, 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 std::__function::__func<std::__bind<void (ShaderDebugger::Metadata::MDSerializerLLVM3XXX::*)(ShaderDebugger::Metadata::MDSerializerLLVM3XXX::TracepointContext *),ShaderDebugger::Metadata::MDSerializerLLVM3XXX*,std::placeholders::__ph<1> const&>,std::allocator<std::__bind<void (ShaderDebugger::Metadata::MDSerializerLLVM3XXX::*)(ShaderDebugger::Metadata::MDSerializerLLVM3XXX::TracepointContext *),ShaderDebugger::Metadata::MDSerializerLLVM3XXX*,std::placeholders::__ph<1> const&>>,void ()(ShaderDebugger::Metadata::MDSerializerLLVM3XXX::TracepointContext *)>::__clone( uint64_t a1, uint64_t a2)
{
  *(void *)a2 = off_58E988;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + _Block_object_dispose(va, 8) = result;
  return result;
}

uint64_t std::__function::__func<std::__bind<void (ShaderDebugger::Metadata::MDSerializerLLVM3XXX::*)(ShaderDebugger::Metadata::MDSerializerLLVM3XXX::TracepointContext *),ShaderDebugger::Metadata::MDSerializerLLVM3XXX*,std::placeholders::__ph<1> const&>,std::allocator<std::__bind<void (ShaderDebugger::Metadata::MDSerializerLLVM3XXX::*)(ShaderDebugger::Metadata::MDSerializerLLVM3XXX::TracepointContext *),ShaderDebugger::Metadata::MDSerializerLLVM3XXX*,std::placeholders::__ph<1> const&>>,void ()(ShaderDebugger::Metadata::MDSerializerLLVM3XXX::TracepointContext *)>::operator()( void *a1, void *a2)
{
  uint64_t v2 = a1[2];
  uint64_t v3 = (uint64_t (*)(void *, void))a1[1];
  uint64_t v4 = (void *)(a1[3] + (v2 >> 1));
  if ((v2 & 1) != 0) {
    uint64_t v3 = *(uint64_t (**)(void *, void))(*v4 + v3);
  }
  return v3(v4, *a2);
}

NSString *StringFromArchive(void *a1, uint64_t a2, char *a3)
{
  size_t FileWithFilename = (unsigned int *)GTCaptureArchive_getFileWithFilename((uint64_t)a1, a3);
  if ((FileWithFilename[4] & 2) != 0)
  {
    uint64_t v11 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", *a1));
    unint64_t v12 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", a3));
    char v13 = (void *)objc_claimAutoreleasedReturnValue([v11 stringByAppendingPathComponent:v12]);

    size_t v10 = -[NSString initWithContentsOfFile:encoding:error:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithContentsOfFile:encoding:error:",  v13,  4LL,  0LL);
  }

  else
  {
    size_t v7 = FileWithFilename;
    size_t v8 = *FileWithFilename;
    size_t v9 = malloc(v8);
    GTCaptureArchive_fillBufferCompressedDeflate((uint64_t)a1, a2, (uint64_t)v7, v9, v8, 0LL);
    size_t v10 = -[NSString initWithBytesNoCopy:length:encoding:freeWhenDone:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithBytesNoCopy:length:encoding:freeWhenDone:",  v9,  *v7,  4LL,  1LL);
  }

  return v10;
}

void GTMTLReplayController_defaultDispatchFunction(uint64_t a1, uint64_t a2)
{
  if ((dword_5B9DE4 & 0x4000000) == 0 || (int v4 = *(_DWORD *)(a1 + 22488)) == 0 || v4 != *(_DWORD *)(a1 + 22480))
  {
    if ((GT_SUPPORT_0 & 0x80000) == 0)
    {
      GTMTLReplayController_defaultDispatchFunction_noPinning(a1, (void *)a2);
      return;
    }

    uint64_t v5 = *(void *)(*(void *)a1 + 16LL);
    id v6 = *(id *)(a1 + 8);
    int v7 = *(_DWORD *)(a2 + 8);
    if (v7 <= -15660)
    {
      if (v7 <= -16164)
      {
        if (v7 <= -16314)
        {
          if (v7 == -16370) {
            goto LABEL_73;
          }
          int v22 = -16314;
          goto LABEL_35;
        }

        if (v7 != -16313)
        {
          int v23 = -16312;
LABEL_41:
          if (v7 != v23) {
            goto LABEL_72;
          }
        }
      }

      else
      {
        if (v7 <= -15779)
        {
          uint64_t v8 = (v7 + 16163);
          if (v8 <= 0x2F)
          {
            if (((1LL << v8) & 0x680000000001LL) == 0)
            {
              if (v8 == 47)
              {
                size_t v9 = GTTraceFunc_argumentBytesWithMap((void *)a2, *(unsigned __int8 *)(a2 + 13), v5);
                size_t v10 = (void *)objc_claimAutoreleasedReturnValue([v6 heapForKey:*(void *)v9]);
                if ([v10 type] == (char *)&dword_0 + 1)
                {
                  uint64_t Object = GTMTLSMContext_lastObject( **(void **)(*(void *)a1 + 40LL),  *((void *)v9 + 1),  *(void *)a2);
                  GTTraceFunc_argumentBytesWithMap((void *)a2, v9[16], v5);
                  id MTLTextureDescriptor = _MakeMTLTextureDescriptor();
                  char v13 = (void *)objc_claimAutoreleasedReturnValue(MTLTextureDescriptor);
                  id v14 = [v10 newTextureWithDescriptor:v13 offset:*(unsigned int *)(Object + 80)];
                }

                else
                {
                  GTTraceFunc_argumentBytesWithMap((void *)a2, v9[16], v5);
                  id v34 = _MakeMTLTextureDescriptor();
                  char v13 = (void *)objc_claimAutoreleasedReturnValue(v34);
                  id v14 = [v10 newTextureWithDescriptor:v13];
                }

                unint64_t v35 = v14;

                uint64_t v36 = *((void *)v9 + 1);
                if (v35)
                {
                  [v6 setTexture:v35 forKey:v36];
                }

                else if (v36)
                {
                  GTMTLReplay_dispatchFailedToSet(a2, *((void *)v9 + 1));
                }

                goto LABEL_73;
              }

              goto LABEL_72;
            }

LABEL_72:
          GTMTLReplayController_defaultDispatchFunction_noPinning(a1, (void *)a2);
          goto LABEL_73;
        }

        if (v7 == -15778) {
          goto LABEL_73;
        }
        if (v7 != -15707)
        {
          int v22 = -15705;
          goto LABEL_35;
        }
      }

      unint64_t v24 = GTTraceFunc_argumentBytesWithMap((void *)a2, *(unsigned __int8 *)(a2 + 13), v5);
      uint64_t v25 = (void *)objc_claimAutoreleasedReturnValue([v6 bufferForKey:*((void *)v24 + 1)]);
      uint64_t v26 = *((void *)v24 + 1);
      *(void *)buf = 22LL;
      uint64_t v42 = v26;
      uint64_t v43 = 0LL;
      uint64_t v44 = GTTraceFunc_argumentBytesWithMap((void *)a2, v24[40], v5);
      __int128 v45 = 0u;
      __int128 v46 = 0u;
      *((void *)&v45 + 1) = *((void *)v24 + 2);
      GTMTLReplayController_restoreMTLBufferContents(a1, buf);

      goto LABEL_73;
    }

    if (v7 > -15465)
    {
      switch(v7)
      {
        case -15356:
        case -15355:
        case -15354:
        case -15353:
          unint64_t v15 = GTTraceFunc_argumentBytesWithMap((void *)a2, *(unsigned __int8 *)(a2 + 13), v5);
          size_t v16 = GTMTLSMContext_getObject(**(void **)(*(void *)a1 + 40LL), *((void *)v15 + 1), *(void *)a2);
          if ((GT_SUPPORT_0 & 0x100000) != 0 && v16[19]) {
            goto LABEL_72;
          }
          break;
        case -15352:
        case -15351:
          if ((GT_SUPPORT_0 & 0x80000) == 0) {
            goto LABEL_72;
          }
          break;
        default:
          if (v7 != -15464)
          {
            int v23 = -10237;
            goto LABEL_41;
          }

          break;
      }

      goto LABEL_73;
    }

    if (v7 > -15615)
    {
      if (v7 != -15614)
      {
        int v22 = -15509;
LABEL_35:
        if (v7 == v22) {
          goto LABEL_73;
        }
        goto LABEL_72;
      }

      uint64_t v31 = GTTraceFunc_argumentBytesWithMap((void *)a2, *(unsigned __int8 *)(a2 + 13), v5);
      unint64_t v32 = GTMTLSMContext_getObject(**(void **)(*(void *)a1 + 40LL), *((void *)v31 + 1), *(void *)a2);
      uint8x8_t v19 = v32;
      if ((GT_SUPPORT_0 & 0x100000) == 0 && v32[19])
      {
        if (s_logUsingOsLog)
        {
          id v33 = gt_default_log();
          uint64_t v21 = (os_log_s *)objc_claimAutoreleasedReturnValue(v33);
          if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)buf = 0;
            goto LABEL_76;
          }

LABEL_62:
        uint64_t v37 = __stderrp;
        id v38 = objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString, "stringWithFormat:", @"warning: Acceleration structure indirection is not supported, but acceleration structures have indices"));
        fprintf(v37, "%s\n", (const char *)[v38 UTF8String]);
      }
    }

    else
    {
      if (v7 == -15659)
      {
        uint64_t v27 = (uint64_t *)GTTraceFunc_argumentBytesWithMap((void *)a2, *(unsigned __int8 *)(a2 + 13), v5);
        uint64_t v28 = GTMTLSMContext_getObject(**(void **)(*(void *)a1 + 40LL), *v27, *(void *)a2 - 1LL);
        uint8x8_t v19 = v28;
        if ((GT_SUPPORT_0 & 0x100000) == 0 && v28[19])
        {
          if (s_logUsingOsLog)
          {
            id v29 = gt_default_log();
            unint64_t v30 = (os_log_s *)objc_claimAutoreleasedReturnValue(v29);
            if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
            {
              *(_WORD *)buf = 0;
              _os_log_error_impl( &dword_0,  v30,  OS_LOG_TYPE_ERROR,  "warning: Acceleration structure indirection is not supported, but acceleration structures have indices",  buf,  2u);
            }
          }

          else
          {
            size_t v39 = __stderrp;
            id v40 = objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString, "stringWithFormat:", @"warning: Acceleration structure indirection is not supported, but acceleration structures have indices"));
            fprintf(v39, "%s\n", (const char *)[v40 UTF8String]);
          }
        }

        if (v19[6])
        {
          if ((GT_SUPPORT_0 & 0x100000) == 0 || !v19[19]) {
            goto LABEL_73;
          }
          goto LABEL_72;
        }

        goto LABEL_68;
      }

      if (v7 != -15615) {
        goto LABEL_72;
      }
      uint64_t v17 = GTTraceFunc_argumentBytesWithMap((void *)a2, *(unsigned __int8 *)(a2 + 13), v5);
      unint64_t v18 = GTMTLSMContext_getObject(**(void **)(*(void *)a1 + 40LL), *((void *)v17 + 1), *(void *)a2);
      uint8x8_t v19 = v18;
      if ((GT_SUPPORT_0 & 0x100000) == 0 && v18[19])
      {
        if (s_logUsingOsLog)
        {
          id v20 = gt_default_log();
          uint64_t v21 = (os_log_s *)objc_claimAutoreleasedReturnValue(v20);
          if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)buf = 0;
LABEL_76:
            _os_log_error_impl( &dword_0,  v21,  OS_LOG_TYPE_ERROR,  "warning: Acceleration structure indirection is not supported, but acceleration structures have indices",  buf,  2u);
            goto LABEL_55;
          }

          goto LABEL_55;
        }

        goto LABEL_62;
      }
    }

          uint64_t v51 = llvm::agxclauseanalyzer::InstrStream::getSizeInBytes(v250);
          uint64_t v21 = v51 + v252;
          uint64_t v52 = *((void *)v3 + 32);
          if (v51 + v252 > v52) {
            uint64_t v52 = v51 + v252;
          }
          *((void *)v3 + 32) = v52;
          if (v250) {
            (*(void (**)(llvm::agxclauseanalyzer::InstrStream *))(*(void *)v250 + 8LL))(v250);
          }
          uint64_t v11 = v247;
          uint64_t v5 = v248;
          int v22 = v249;
          int v23 = v251;
        }

        std::string::size_type v53 = v274;
        __int128 v274 = 0LL;
        if (v53) {
          (*(void (**)(unint64_t))(*(void *)v53 + 8LL))(v53);
        }
        if ((v23 & 1) != 0) {
          goto LABEL_139;
        }
      }

      uint8x8_t v19 = v244 + 32;
    }

    while (v244 + 32 != v243);
  }

  unint64_t v54 = 0x2E8BA2E8BA2E8BA3LL * ((uint64_t)(*((void *)v3 + 1) - *(void *)v3) >> 3);
  uint64_t v56 = (_BYTE *)*((void *)v3 + 3);
  uint64_t v55 = (char *)*((void *)v3 + 4);
  std::string::size_type v57 = 0xAAAAAAAAAAAAAAABLL * ((v55 - v56) >> 4);
  uint64_t v58 = v54 - v57;
  if (v54 > v57)
  {
    uint64_t v59 = *((void *)v3 + 5);
    if (0xAAAAAAAAAAAAAAABLL * ((v59 - (uint64_t)v55) >> 4) < v58)
    {
      if (v54 > 0x555555555555555LL) {
LABEL_341:
      }
        abort();
      uint64_t v60 = 0xAAAAAAAAAAAAAAABLL * ((v59 - (uint64_t)v56) >> 4);
      if (2 * v60 > v54) {
        unint64_t v54 = 2 * v60;
      }
      if (v60 >= 0x2AAAAAAAAAAAAAALL) {
        unint64_t v54 = 0x555555555555555LL;
      }
      if (v54 > 0x555555555555555LL) {
        goto LABEL_342;
      }
      unint64_t v61 = 3 * v54;
      unint64_t v62 = (char *)operator new(48 * v54);
      uint64_t v63 = &v62[16 * ((v55 - v56) >> 4)];
      id v64 = &v62[16 * v61];
      uint64_t v65 = 48 * ((48 * v58 - 48) / 0x30) + 48;
      bzero(v63, v65);
      uint64_t v66 = &v63[v65];
      if (v55 == v56)
      {
        uint64_t v3 = (char *)v259;
      }

      else
      {
        uint64_t v3 = (char *)v259;
        do
        {
          uint64_t v67 = *((_OWORD *)v55 - 3);
          unint64_t v68 = *((_OWORD *)v55 - 1);
          *((_OWORD *)v63 - 2) = *((_OWORD *)v55 - 2);
          *((_OWORD *)v63 - 1) = v68;
          *((_OWORD *)v63 - 3) = v67;
          v63 -= 48;
          v55 -= 48;
        }

        while (v55 != v56);
        uint64_t v55 = (char *)*((void *)v259 + 3);
      }

      *((void *)v3 + 3) = v63;
      *((void *)v3 + 4) = v66;
      *((void *)v3 + 5) = v64;
      if (v55) {
        operator delete(v55);
      }
      goto LABEL_91;
    }

    bzero(*((void **)v3 + 4), 48 * ((48 * v58 - 48) / 0x30) + 48);
    unint64_t v69 = &v55[48 * ((48 * v58 - 48) / 0x30) + 48];
    goto LABEL_87;
  }

  if (v54 < v57)
  {
    unint64_t v69 = &v56[0xBA2E8BA2E8BA2E90LL * ((uint64_t)(*((void *)v3 + 1) - *(void *)v3) >> 3)];
LABEL_87:
    *((void *)v3 + 4) = v69;
  }

  uint64_t v47 = 0LL;
  size_t v48 = 0LL;
  size_t v10 = 0;
  uint64_t v11 = 0;
  __int128 v45 = 0LL;
  __int128 v46 = 0LL;
  unint64_t v12 = 0LL;
  uint64_t v49 = 0LL;
  std::string __dst = 0LL;
LABEL_63:
  if (a3) {
    goto LABEL_64;
  }
LABEL_65:
  a2[3] += 56LL;
}